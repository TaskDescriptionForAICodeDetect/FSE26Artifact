[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n\nusing namespace std;\n\n#define int long long\n\nlist<bool*> fld;\n\nlist<bool*>::iterator GetHeight(int l, int r)\n{\n\tlist<bool*>::iterator itr = fld.begin();\n\t//fld.push_front((bool*)new bool[5]{});\n\tfor (; itr != fld.end(); itr++)\n\t{\n\t\tfor (int i = l; i < r; i++)\n\t\t{\n\t\t\tif ((*itr)[i] == true) return --itr;\n\t\t}\n\t}\n\treturn --itr;\n}\n\nvoid PushFront()\n{\n\tfld.push_front((bool*)new bool[5]);\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\t(*fld.begin())[i] = false;\n\t}\n}\n\nbool IsFull(list<bool*>::iterator itr)\n{\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif ((*itr)[i] == false) return false;\n\t}\n\treturn true;\n}\n\nbool IsEmpty(list<bool*>::iterator itr)\n{\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif ((*itr)[i] == true) return false;\n\t}\n\treturn true;\n}\n\nvoid Drop(int d, int p, int q)\n{\n\tif (!IsEmpty(fld.begin())) PushFront();\n\tint l = q - 1, r = (d == 1) ? l + p : l + 1;\n\tlist<bool*>::iterator itr = GetHeight(l, r);\n\n\tint h = (d == 1) ? 1 : p;\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tif (itr == fld.begin()) PushFront();\n\t\tfor (int j = l; j < r; j++)\n\t\t{\n\t\t\t(*itr)[j] = true;\n\t\t}\n\t\tif (IsFull(itr))\n\t\t{\n\t\t\tdelete *itr;\n\t\t\titr = fld.erase(itr);\n\t\t}\n\t\titr--;\n\t}\n}\n\nsigned main()\n{\n\tint N;\n\twhile (cin >> N, N)\n\t{\n\t\tfld.clear();\n\t\tPushFront();\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\t\t\tDrop(d, p, q);\n\t\t}\n\t\tint ans = 0;\n\t\tfor (list<bool*>::iterator itr = fld.begin(); itr != fld.end(); itr++)\n\t\t{\n\t\t\tfor (int i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tans += ((*itr)[i] == true);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint mp[10000000][5];\n//d<muki p<nagasa q<basyo\nint d,p,q;\nint ktflg = 0,th;\n\nvoid deb() {\n  for(int i=0;i<10;i++) {\n    for(int j=0;j<5;j++)\n      cout << mp[i][j] << \" \";\n    cout << endl;\n  }\n  cout << \"----------------------------\" <<endl;\n\n}\n\n\nvoid tumeru() { \n  \n  int t;\n  for(int i=1;i<th;i++) {\n    for(int j=0;j<5;j++) {\n      if(mp[i][j] > 0 && ((j>0 && mp[i][j] != mp[i][j-1]) || j==0)){\n\t//\tcout <<j<<\" \"<<mp[i][j]<< endl;\n\tint o=i;\n\tt = mp[i][j];\n\twhile(1) {\n\tint count = 0;\n\tfor(int k=j;k<5;k++) if(t == mp[o][k]) count++;\n\tint flg = 0;\n\tfor(int k=j;k<count;k++) {\n\t  if(mp[o-1][k] != 0) break;\n\t  if(k == count-1) flg = 1;\n\t}\n\tif(flg == 1){\n\t  for(int k=j;k<count;k++) mp[o-1][k] = t , mp[o][k] = 0;\n\t  o--;\n\t  ktflg = 1;\n\t}\n\tif(flg == 0 || o == 0) break;\n\t  }\n      }\n      if(mp[i][j] < 0 && mp[i-1][j] == 0) {\n\tint t = i;\n\tktflg = 1;\n\twhile(1){\n\t  if(t-1 < 0 || mp[t-1][j] !=0) break;\n\t  mp[t-1][j] = mp[t][j],mp[t][j] = 0;\n\t  t--;\n\t}\n      }\n\t\n    }\n  }\n}\n\nvoid kesu() {\n\n     int h = 0;\n  while(1) {\n    int flg =0;\n    for(int i=0;i<5;i++) {\n      if(mp[h][i] !=0) break;\n      if(i == 4) flg = 1;\n    }\n    if(flg == 1) break;\n    h++;\n  }\n  th = h;\n\n  h = 0;\n  while(1) {\n    int zero = 0;\n    int count = 0;\n    for(int i=0;i<5;i++) {\n      if(mp[h][i] == 0) zero++;\n      else count++;\n    }\n\n    if(zero == 5) break;\n    if(count == 5)\n      for(int i=0;i<5;i++)\n\tmp[h][i] = 0;\n    h++;\n  }\n\n  \n}\n       \n\nvoid add(int c) {\n\n  int h = 0;\n  while(1) {\n    int flg =0;\n    for(int i=0;i<5;i++) {\n      if(mp[h][i] !=0) break;\n      if(i == 4) flg = 1;\n    }\n    if(flg == 1) break;\n    h++;\n  }\n  \n  if(d == 1) {\n    while(1) {\n      if(h <= 0)break;\n      int flg = 0;\n      for(int i=0;i<p;i++)\n\tif(mp[h-1][i+q-1] != 0) break;\n\telse if(i == p-1) h-- ,flg = 1;\n      if(flg == 0) break;\n    }\n  \n  \n    for(int i=0;i<p;i++)\n      mp[h][i+q-1] = c;\n  }\n  \n  if(d == 2) {\n    while(1) {\n      int flg = 0;\n    for(int i=0;i<p;i++){\n      if(h-i <0 || mp[h-i][q-1] != 0) break;\n      if(i == p-1)flg =1;\n    }\n    if(flg == 1){\n      if(h-p >= 0 && mp[h-p][q-1] == 0){\n\th--;\n\tcontinue;\n      }\n      for(int i=0;i<p;i++)mp[h-i][q-1] = -1*c;\n      break;\n    }\n    h++;\n    }\n    \n  }\n  \n}\n\nint main() {\n\n  int ques;\n  while(1) {\n  cin >> ques;\n  if(ques == 0) break;\n  for(int i=0;i<50000;i++)\n    for(int j=0;j<5;j++)\n      mp[i][j] = 0;\n  \n  int c = 1;\n  for(int i=0;i<ques;i++) {\n    cin >> d >> p >>q;\n    //cout << d <<\" \" << p <<\" \"<<q<<endl;\n    add(c);\n    c++;\n  }\n  //deb();\n  ktflg = 1;\n  while(1) {\n    if(ktflg == 0) break;\n    ktflg = 0;\n    kesu();\n    tumeru();\n  }\n  //    deb();\n    \n  int h=0;\n  int ans = 0;\n  while(1) {\n    int zero = 0;\n    for(int i=0;i<5;i++){\n      if(mp[h][i] == 0) zero++;\n      else ans++;\n    }\n    if(zero == 5) break;\n    h++;\n  }\n  cout << ans << endl;\n\n  }\n    return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define HORIZONTAL 1\n#define VERTICAL 2\n\nint bit(int bits)\n{\n\tint ret = 0;\n\twhile(bits != 0)\n\t{\n\t\tret += bits & 0x00000001;\n\t\tbits >>= 1;\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\tint n, a, b, c, block, ret;\n\twhile(cin >>n, n)\n\t{\n\t\tvector<int> data(5001, 0);\n\t\tdata[5000] = 63; /* 63 = 0x11111 */\n\t\tret = 0;\n\t\t\n\t\twhile(n--)\n\t\t{\n\t\t\tcin >> a >> b >> c;\n\t\t\tc--;\n\t\t\tif(a==HORIZONTAL)\n\t\t\t{\n\t\t\t\tblock = ((1<<b)-1) << c;\n\t\t\t\tfor(int i=0; i<data.size()-1; i++)\n\t\t\t\t{\n\t\t\t\t\tif(data[i+1] & block)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata[i] += block;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tblock = 1 << c;\n\t\t\t\tfor(int i=0; i<data.size()-1; i++)\n\t\t\t\t{\n\t\t\t\t\tif(data[i+1] & block)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor(int j=0; j<b; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdata[i-j] += block;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvector<int>::iterator it = data.begin();\n\t\t\twhile(it != data.end())\n\t\t\t{\n\t\t\t\tif((*it) == 31)\n\t\t\t\t{\n\t\t\t\t\tit = data.erase(it);\n\t\t\t\t\tit--;\n\t\t\t\t}\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t\tret = 0;\n\t\tfor(int i=0; i<data.size()-1; i++)\n\t\t{\n\t\t\tret += bit(data[i]);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint grid[5][6000];\nint n,d,p,q;\nll int ans = 0;\n\nint GetBottom(int x){\n\tREP(i,6000){\n\t\tif(grid[x][i]==-1) return i;\n\t}\n\treturn 0;\n}\n\nbool isallclear(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=-1) return false;\n\t}\n\treturn true;\n}\n\nbool isallblock(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(cin>>n,n){\n\t\tREP(i,5) REP(j,6000) grid[i][j] = -1;\n\t\tREP(i,n){\n\t\t\tcin >> d >> p >> q;\n\t\t\tif(d==2){\n\t\t\t\tint tmp = GetBottom(q-1);\n\t\t\t\tFOR(j,tmp,tmp+p) grid[q-1][j] = 1;\n\t\t\t}else{\n\t\t\t\tint tmp = -1;\n\t\t\t\tFOR(j,q-1,q-1+p){\n\t\t\t\t\ttmp = max(tmp,GetBottom(j));\n\t\t\t\t}\n\t\t\t\tFOR(j,q-1,q-1+p) {\n\t\t\t\t\tgrid[j][tmp] = 1;\n\t\t\t\t\tREP(k,tmp) if(grid[j][k]==-1) grid[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowline = 0;\n\t\t\twhile(1){\n\t\t\t\tif(isallclear(nowline)) break;\n\t\t\t\tif(isallblock(nowline)){\n\t\t\t\t\tREP(j,5) {\n\t\t\t\t\t\tint nline = nowline+1;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tif(grid[j][nline]==-1) {\n\t\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\tnline++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnowline = 0;\n\t\t\t\t}else{\n\t\t\t\t\tnowline++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tint line = 0;\n\t\twhile(1){\n\t\t\tif(isallclear(line)) break;\n\t\t\tREP(i,5){\n\t\t\t\tif(grid[i][line]==1) ans++;\n\t\t\t}\n\t\t\tline++;\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\tflg &= board[h_max][j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tboard[h_max][j] = 0;\n\t\t\t\t\t\tfor(int k = h_max + 1; k < top[j]+10; k++) {\n\t\t\t\t\t\t\tboard[k - 1][j] = board[k][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\n\t\t\t\tint h = top[q - 1];\n\t\t\t\ttop[q - 1] += p;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tflg &= board[h + j][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++)\n\t\t\t\t\t\t\tboard[h + j - del][k] = board[h + j + 1][k];\n\t\t\t\t\t\tdel++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tfor(int k = h + p - del; k < top[j]; k++) {\n\t\t\t\t\t\tboard[k][j] = board[k + del][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//*\n\t\t\tfor(int i = 10; i >= 0; i--) {\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tcout << (board[i][j] ? '*' : '.');\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t// */\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\n\t\t\tfor(int j = 0; j < 6; j++) {\n\t\t\t\tans += board[i][j];\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <array>\n#include <list>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <tuple>\n#include <bitset>\n#include <memory>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n#include <cfloat>\n#include <cassert>\n#include <random>\nenum class Direction {\n\tHorizontal, Vertical\n};\nDirection as_direction(int d) {\n\tswitch (d) {\n\tcase 1: return Direction::Horizontal;\n\tcase 2: return Direction::Vertical;\n\tdefault: throw 0;\n\t}\n}\nstruct Block {\n\tDirection direction;\n\tint length;\n\tint position;\n\tint height() const {\n\t\tswitch (direction) {\n\t\tcase Direction::Horizontal: return 1;\n\t\tcase Direction::Vertical: return length;\n\t\tdefault: throw 0;\n\t\t}\n\t}\n\tint width() const {\n\t\tswitch (direction) {\n\t\tcase Direction::Horizontal: return length;\n\t\tcase Direction::Vertical: return 1;\n\t\tdefault: throw 0;\n\t\t}\n\t}\n};\nstruct Line {\n\tint state = 0;\n\tvoid write(Block block) {\n\t\tstate |= (1 << (block.position + block.width())) - (1 << block.position);\n\t}\n\tbool can_put(Block block) const {\n\t\treturn (state & ((1 << (block.position + block.width())) - (1 << block.position))) == 0;\n\t}\n\tbool is_filled() const {\n\t\treturn state + 2 == (1 << 6);\n\t}\n};\nstruct Field {\n\tstd::list<Line> list;\n\tint block_rest = 0;\n\tvoid drop_block(Block block) {\n\t\tblock_rest += block.height() * block.width();\n\t\tauto last = std::find_if(list.rbegin(), list.rend(), [block](const Line& line) {return !line.can_put(block); });\n\t\tif (last == list.rend()) {\n\t\t\twhile (list.size() < block.height()) {\n\t\t\t\tlist.push_back(Line());\n\t\t\t}\n\t\t\tfor (auto itr = list.begin(); std::distance(list.begin(), itr) < block.height(); ++itr) {\n\t\t\t\titr->write(block);\n\t\t\t}\n\t\t\tauto itr = list.begin();\n\t\t\tfor (auto i = 0; i < block.height(); ++i) {\n\t\t\t\tif (itr->is_filled()) {\n\t\t\t\t\titr = list.erase(itr);\n\t\t\t\t\tblock_rest -= 5;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t++itr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (last == list.rbegin()) {\n\t\t\tfor (auto i = 0; i < block.height(); ++i) {\n\t\t\t\tauto line = Line();\n\t\t\t\tline.write(block);\n\t\t\t\tlist.push_back(line);\n\t\t\t}\n\t\t\tfor (auto itr = std::prev(list.end(), block.height()); itr != list.end();) {\n\t\t\t\tif (itr->is_filled()) {\n\t\t\t\t\titr = list.erase(itr);\n\t\t\t\t\tblock_rest -= 5;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t++itr;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tauto rev_count = std::distance(list.rbegin(), last);\n\t\t\tfor (; rev_count < block.height(); ++rev_count) {\n\t\t\t\tlist.push_back(Line());\n\t\t\t}\n\t\t\tauto itr = std::prev(list.end(), rev_count);\n\t\t\tfor (auto i = 0; i < block.height(); ++i) {\n\t\t\t\titr->write(block);\n\t\t\t\tif (itr->is_filled()) {\n\t\t\t\t\titr = list.erase(itr);\n\t\t\t\t\tblock_rest -= 5;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t++itr;\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t}\n\tint block_count() const { return block_rest; }\n};\nint main() {\n\twhile (true) {\n\t\tint n; std::cin >> n; if (n == 0) break;\n\t\tField field;\n\t\tfor (auto i = 0; i < n; ++i) {\n\t\t\tint d, l, p; std::cin >> d >> l >> p;\n\t\t\tBlock block{ as_direction(d), l, p };\n\t\t\tfield.drop_block(block);\n\t\t}\n\t\tstd::cout << field.block_count() << '\\n';\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nint n, hmax;\nbool maps[4999][5];\n\nint serch(int x, int l) {\n\tfor (int i = hmax; i >= 0; i--) {\n\t\tREP(j, l) if (maps[i][x + j]) return i + 1;\n\t}\n\treturn 0;\n}\n\nint check(int y, int l) {\n\tREP(i, l) {\n\t\tbool flag = true;\n\t\tREP(j, 5) if (!maps[y + i][j]) flag = false;\n\t\tif (flag) return y + i;\n\t}\n\treturn -1;\n}\n\nvoid bset(int d, int p, int q) {\n\tint hl = d == 2 ? p : 1;\n\tint xl = d == 1 ? p : 1;\n\tint hpos = serch(q - 1, xl);\n\t\n\tif (d == 1) REP(i, p) maps[hpos][q + i - 1] = true;\n\telse REP(i, p) maps[hpos + i][q - 1] = true;\n\thmax = max(hmax, hpos + hl);\n\t\n\tint tmp;\n\twhile ((tmp = check(hpos, hl)) != -1) {\n\t\tREP(i, 5) maps[tmp][i] = false;\n\t\tFOR(i, tmp, hmax) {\n\t\t\tREP(j, 5) swap(maps[i][j], maps[i + 1][j]);\n\t\t}\n\t\thmax--;\n\t}\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tmemset(maps, 0, sizeof(maps));\n\t\thmax = 0;\n\t\t\n\t\twhile (n--) {\n\t\t\tint d, p, q;\n\t\t\tscanf(\"%d %d %d\", &d, &p, &q);\n\t\t\tbset(d, p, q);\n\t\t}\n\t\tcout << count(maps[0], maps[4999], true) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tchar field[10][5];\n\t\tfor(int i = 0; i < 10; i++)\n\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\tfield[i][j]='0';\n\t\tint d,p,q;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>d>>p>>q;\n\t\t\tif(d==1){\n\t\t\t\tint init=q-1;\n\t\t\t\tint at=10000000;\n\t\t\t\tfor(int j = init; j < p+init; j++){\n\t\t\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\t\t\tif(field[k][j]=='1'){\n\t\t\t\t\t\t\tat=min(at,k-1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(k==9){\n\t\t\t\t\t\t\tat=min(at,k);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// atÌÀWÌ³ÉubNð¨­\n\t\t\t\tfor(int j = init; j < p+init; j++){\n\t\t\t\t\tfield[at][j]='1';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint at=10000000;\n\t\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\t\tif(field[k][q-1]=='1'){\n\t\t\t\t\t\tat=k-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(k==9)\n\t\t\t\t\t\tat=k;\n\t\t\t\t}\n\t\t\t\t//ubNð¨­\n\t\t\t\tfor(int j = at; j!=at-p; j--){\n\t\t\t\t\tfield[j][q-1]='1';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool er=false;\n\t\t\t// ubNÌÁ\n\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\tbool f=false;\n\t\t\t\tfor(int k = 0; k < 5; k++){\n\t\t\t\t\tif(field[j][k]!='1'){\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f){\n\t\t\t\t\tfor(int k = 0; k < 5; k++)\n\t\t\t\t\t\tfield[j][k]='0';\n\t\t\t\t\t// Á¦½sæèãÉ éubNðº\n\t\t\t\t\tfor(int k = j-1; k >= 0; k--){\n\t\t\t\t\t\tfor(int l = 0; l < 5; l++){\n\t\t\t\t\t\t\tfield[k+1][l]=field[k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//for(int j = 0; j < 10; j++){\n\t\t\t//\tfor(int k = 0; k < 5; k++){\n\t\t\t//\t\tcout<<field[j][k]<<flush;\n\t\t\t//\t}\n\t\t\t//\tcout<<endl;\n\t\t\t//}\n\t\t\t//cout<<endl;\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tif(field[i][j]=='1')\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tvector<int>\tvi;\n\nchar field[5050];\n\nbool vanish(int u,int l){\n\tvi rem;\n\tfor(int i=l;i>=u;i--){\n\t\tif((field[i]&=31)!=31)\trem.pb(i);\n\t}\n//printf(\"rem=%d\\n\",rem.size());\n\tint rnum=rem.size(),h=l-u+1;\n\tif(rnum!=l){\n\t\tfor(int i=0;i<rnum;i++)\tfield[l-i]=field[rem[i]];\n\t\tfor(int i=u-1;i>=0;i--)\tfield[h-rnum+i]=field[i];\n\t\tfor(int i=0;i<rnum;i++)\tfield[i]=0;\n\t}\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tfor(int i=0;i<5050;i++)\tfield[i]=0;\n\t\tfor(int t=0;t<n;t++){\n\t\t\tint type,len,p;\tscanf(\"%d%d%d\",&type,&len,&p);\n\t\t\tp--;\n\n\t\t\tchar blk;\n\t\t\tif(type==1)\tblk=((1<<len)-1)<<(5-p-len);\n\t\t\telse\t\tblk=1<<(4-p);\n\n\t\t\tfor(int i=0;i<=5050;i++){\n\t\t\t\tif(i==5050 || (field[i]&blk)!=0){\n\t\t\t\t\tif(type==1){\n\t\t\t\t\t\tfield[i-1]|=blk;\n\t\t\t\t\t\tvanish(i-1,i-1);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int j=1;j<=len;j++)\tfield[i-j]|=blk;\n\t\t\t\t\t\tvanish(i-len,i-1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n//for(int i=4992;i<5000;i++){for(int j=0;j<5;j++)putchar(field[i]&(1<<4-j)?'@':'.');puts(\"\");}puts(\"\");\n\t\t}\n\n\t\tint cnt=0;\n\t\tfor(int i=0;i<5050;i++){\n\t\t\tfor(int j=0;j<5;j++)\tif(field[i]&(1<<j))\tcnt++;\n\t\t}\n\t\tprintf(\"%d\\n\",cnt);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define MH 100\nusing namespace std;\nbool ck(int *f){\n\trep(i,5)if(!f[i])return 0;\n\treturn 1;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tint d,l,x,y,c=0;\n\t\tint field[MH][5]={0};\n\t\trep(i,n){\n\t\t\tcin>>d>>l>>x,y=MH,x--,d--;\n\t\t\tfor(;y>0;y--)rep(j,(d?1:l))if(field[y-1][x+j])goto END;\n\t\t\tEND:\n\t\t\trep(j,l)field[y+d*j][x+(1-d)*j]=1;\n\t\t\trep(i,MH)while(ck(field[i])){\n\t\t\t\trep(j,MH-i-1)rep(k,5)field[j+i][k]=field[j+i+1][k];\n\t\t\t\trep(k,5)field[MH-1][k]=0;\n\t\t\t}\n\t\t}\n\t\trep(i,MH)rep(j,5)c+=field[i][j];\n\t\tcout<<c<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n#define UNDER 10000\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint t[UNDER + 10][5], n;\n\nint count() {\n\tint res = 0;\n\trep(i, UNDER)\n\t\trep(j, 5)\n\t\t\tif (t[i][j] == 1)\n\t\t\t\tres++;\n\treturn res;\n}\n\nvoid deleteblock() {\n\tfor (int y = UNDER - 1; y >= 0; y--) {\n\t\tint f = 0;\n\t\trep(i, 5)\n\t\t\tif (t[y][i] == 0) {\n\t\t\t\tf = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tif (f)\n\t\t\tcontinue;\n\t\trep(i, 5)\n\t\t{\n\t\t\tfor (int c = y; c > 0; c--) {\n\t\t\t\tt[c][i] = t[c - 1][i];\n\t\t\t}\n\t\t}\n\t\tt[0][0] = t[0][1] = t[0][2] = t[0][3] = t[0][4] = 0;\n\t\ty++;\n\t}\n\treturn;\n}\n\nint main() {\n\twhile (scanf(\"%d\", &n) && n) {\n\t\tint d, p, q;\n\t\tmemset(t, 0, sizeof(t));\n\t\trep(i, 5)\n\t\t\tt[UNDER][i] = 1;\n\n\t\trep(i, n)\n\t\t{\n\t\t\tscanf(\"%d%d%d\", &d, &p, &q);\n\t\t\tq--;\n\t\t\tif (d == 1) {\n\t\t\t\tREP(y, 1, UNDER+1)\n\t\t\t\t{\n\t\t\t\t\tint f = 0;\n\t\t\t\t\tREP(x, q, q+p)\n\t\t\t\t\t\tif (t[y][x] == 1)\n\t\t\t\t\t\t\tf = 1;\n\t\t\t\t\tif (!f)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tREP(x, q, q+p)\n\t\t\t\t\t\tt[y - 1][x] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\trep(y, UNDER+1)\n\t\t\t\t{\n\t\t\t\t\tif (!t[y][q])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int c = y - 1; c > y - p - 1; c--)\n\t\t\t\t\t\tt[c][q] = 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeleteblock();\n\t\t\t/*      REP(i, 990, UNDER+1){\n\t\t\t rep(j, 5) printf(\"%d \", t[i][j]); puts(\"\");\n\t\t\t }*/\n\t\t}\n\n\t\tprintf(\"%d\\n\", count());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*テ」ツ?禿」ツつ古」ツ?ッTERODES\n  Sample1:\n  9\n  1 1 1\n  1 2 1\n  1 3 1\n  1 4 1\n  1 3 1\n  1 2 1\n  1 1 1\n  2 5 5\n  2 5 4\n  0\n  Output:\n  11\n\n  Sample2:\n  10\n  1 4 1\n  1 1 1\n  1 4 1\n  1 1 2\n  1 4 1\n  1 1 3\n  1 4 1\n  1 1 4\n  2 5 5\n  2 5 5\n  0\n  Output:\n  10\n\n\n\n4444.    44445     .....        .....\n.3... -> .3..5 ->  .....    NOT .....\n2222.    22225     .3...        .....\n1....    1...5     1....        13...\n\n*/\n\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n \nusing namespace std;\ntypedef pair<int,int> ii;\nint field[5010][5];\nint top[5];\nint n,d,p,q;\nvector<ii> input;\n \nbool checkX(int y)\n{\n  rep(x,5)if(!field[y][x])return false;\n  return true;\n}\n \nvoid updateD(int x,int y)\n{\n  ii info = input[field[y][x]];\n  if(info.first == 1)\n    {//yoko\n      //while(true)//テ」ツ?禿」ツ?禿」ツ?ョwhileテ」ツつ津」ツつづ」ツ?ゥテ」ツ?崚」ツ?ーテ」ツ?、テ」ツ?」テ」ツ?凝」ツ?凝」ツつ凝」ツ?セテ」ツ?ァティツ青ステ」ツ?。テ」ツつ?\n      //{\n      bool check = true;\n      rep(i,5)\n        {\n          if(field[y][x] != field[y][i])continue;\n          if(y-1 >= 0 && field[y-1][i] != 0)\n\t    {\n\t      check = false;\n\t      break;\n\t    }\n        }\n      if(!check)return;\n      int v = field[y][x];\n      rep(i,5)\n        {\n          if(v != field[y][i])continue;\n          assert(field[y-1][i] == 0);\n          field[y-1][i] = field[y][i];\n          field[y][i] = 0;\n        }\n      y = y-1;\n      if(y <= 0)return;\n      //}\n    }\n  else\n    {\n      int v = field[y][x];\n     \n      int bot = 0;\n      int py = y;\n      while(py-1 >= 0 && field[py-1][x] == 0)py--;\n      bot = y-py;\n \n      if(bot == 0)return;\n      bot = 1;//テ」ツ?禿」ツ?禿」ツつ鍛otテ」ツ?ョテ」ツ?セテ」ツ?セテ」ツ?ォテ」ツ?凖」ツつ古」ツ?ーテ」ツ?、テ」ツ?」テ」ツ?凝」ツ?凝」ツつ凝」ツ?セテ」ツ?ァテ」ツ?甘」ツ?。テ」ツつ?\n      while(v == field[y][x])\n\t{\n\t  assert(y-bot >= 0);\n\t  assert(field[y-bot][x] == 0);\n\t  field[y-bot][x] = field[y][x];\n\t  field[y][x] = 0;\n\t  y++;\n\t}\n     \n    }\n}\n \nint main()\n{\n  while(cin >> n,n)\n    {\n      input.clear();\n      input.resize(1010,ii(-1,-1));\n      rep(i,5010)rep(j,5)field[i][j] = 0;\n      rep(i,5)top[i] = 0;\n      REP(i,1,n+1)\n\t{\n\t  cin >> d >> p >> q;\n\t  if(d == 1 && p == 5)continue;\n\t  q--;\n\t  input[i] = ii(d,p);\n\t  int cyb,cyt;\n\t  if(d == 2)\n\t    {\n\t      cyb = top[q],cyt = top[q]+p;\n\t      REP(j,top[q],top[q]+p)field[j][q] = i;\n\t      top[q] += p;\n\t    }\n\t  else\n\t    {\n\t      int mexico = -inf;\n\t      REP(j,q,q+p)mexico = max(mexico,top[j]);\n\t      REP(j,q,q+p)field[mexico][j] = i;\n\t      cyb = cyt = mexico;\n\t      REP(j,q,q+p)top[j] = mexico+1;\n\t    }\n \n      bool update = true;\n      while(update)\n\t{\n\t  update = false;\n\t  vector<int> erasedY;\n\t  REP(y,cyb,cyt+1)\n\t    {\n\t      if(checkX(y))\n\t\t{\n\t\t  update = true;\n\t\t  erasedY.push_back(y);\n\t\t  rep(x,5)field[y][x] = 0;\n\t\t}\n\t    }\n \n\t  //down\n\t  if(!erasedY.empty())\n\t    {\n \n \n\t      int yt = 0;\n\t      rep(j,5)yt = max(yt,top[j]);\n\t      rep(j,erasedY.size())\n\t\t{\n\t\t  REP(y,erasedY[j],yt)\n\t\t    {\n\t\t      int pre = -1;\n\t\t      rep(x,5)\n\t\t\t{\n\t\t\t  if(field[y][x] == pre)continue;\n\t\t\t  if(field[y][x] == 0 || y-1 < 0)continue;\n \n\t\t\t  pre = field[y][x];\n\t\t\t  updateD(x,y);\n\t\t\t}\n\t\t    }\n\t\t}\n \n \n\t    }\n      \n\t  //update top\n\t  rep(j,5)\n\t    {\n\t      int y = top[j];\n\t      while(y >= 0 && field[y][j] == 0)y--;\n\t      top[j] = y+1;\n\t    }\n      \n\t}\n    }\n\n      int yt = 0;\n      rep(i,5)yt = max(yt,top[i]);\n      int ans = 0;\n      rep(y,yt)\n\trep(x,5)\n\tif(field[y][x] != 0)ans++;    \n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n\tint n, d, p, q, s, t;\n\t\n\twhile(cin>>n&&n){\n\t\tvector<bool> vec[5];\n\t\t\n\t\twhile(n--){\n\t\t\tcin >> d >> p >> q;\n\t\t\tq--;\n\t\t\tif(d == 1){\n\t\t\t\tt = -1;\n\t\t\t\tfor(int i = q, k = 0; k < p; i++, k++){\n\t\t\t\t\tfor(int j = vec[i].size()-1; j >= 0; j--){\n\t\t\t\t\t\tif(vec[i][j]){\n\t\t\t\t\t\t\tt = max(t, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = q, k = 0; k < p; i++, k++){\n\t\t\t\t\tif(vec[i].size() <= (t+1)){\n\t\t\t\t\t\twhile(vec[i].size() < (t+1)){\n\t\t\t\t\t\t\tvec[i].push_back(false);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvec[i].push_back(true);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tvec[i][t+1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tt = -1;\n\t\t\t\tfor(int i = vec[q].size()-1; i >= 0; i--){\n\t\t\t\t\tif(vec[q][i]){\n\t\t\t\t\t\tt = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts = 0;\n\t\t\t\tfor(int i = t+1; i < vec[q].size() && s < p; i++, s++){\n\t\t\t\t\tvec[q][i] = true;\n\t\t\t\t}\n\t\t\t\tfor(;s < p; s++){\n\t\t\t\t\tvec[q].push_back(true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tt = vec[0].size();\n\t\t\tfor(int i = 1; i < 5; i++){\n\t\t\t\ts = vec[i].size();\n\t\t\t\tt = min(s, t);\n\t\t\t}\n\n\t\t\tfor(int i = t-1; i >= 0; i--){\n\t\t\t\tbool f = true;\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\tif(!vec[j][i]){\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(f){\n\t\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\t\tvec[j].erase((vec[j].begin()+i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tt = 0;\n\t\tfor(int i = 0; i < 5; i++){\n\t\t\tfor(int j = 0; j < vec[i].size(); j++){\n\t\t\t\tif(vec[i][j]){\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << t << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\tflg &= board[h_max][j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tboard[h_max][j] = 0;\n\t\t\t\t\t\tfor(int k = h_max + 1; k < top[j]; k++) {\n\t\t\t\t\t\t\tboard[k - 1][j] = board[k][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\n\t\t\t\tint h = top[q - 1];\n\t\t\t\ttop[q - 1] += p;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tflg &= board[h + j][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++)\n\t\t\t\t\t\t\tboard[h + j - del][k] = board[h + j + 1][k];\n\t\t\t\t\t\tdel++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tfor(int k = h + p - del; k < top[j]; k++) {\n\t\t\t\t\t\tboard[k][j] = board[k + del][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\ttop[j] -= del;\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\n\t\t\tfor(int j = 0; j < 6; j++) {\n\t\t\t\tans += board[i][j];\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n  \nusing namespace std;\n  \nconst int Height = 5100;\nconst int Width = 5;\nchar field[Height][Width];\nint top,ans;\nint dx[] = {1,0};\nint dy[] = {0,-1};\n  \nvoid print(int h, int w){\n  \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl; \n}\n\nbool isInside(int h, int w){ return 0<=h&&h<Height&&0<=w&&w<Width;}\n\nint getH(int d, int len, int pos){\n  for(int i = top+10; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?' || !isInside(h,w)) return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n  return 0;\n}\n \nvoid down(int n){\n  \n  for(int i = n; i <= top+6; i++)\n    for(int j = 0; j < Width; j++) field[i][j] = field[i+1][j];\n   top--;\n}\n \nvoid erase(){\n \n  for(int i = 0; i <= top+6; i++){\n    bool f = true;\n    for(int j = 0; j < Width; j++) if(field[i][j] == '?') f = false;\n    if(f){\n      ans -= 5;\n      down(i--);\n    }\n  }\n}\n  \nvoid put(int d, int len, int pos){\n  \n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n  \n  int h = nex;\n  int w = pos;\n  \n  for(int i = 0; i < len; i++){\n    field[h][w] = '.';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n  \nint main(){\n  \n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    ans = top = 0;\n     \n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      ans += len;\n      put(d-1,len,pos-1);\n      erase();\n    }\n    cout << ans << endl;\n    //  print(10,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass TETORIS {\npublic:\n\tint N;\n\tvector<vector<int> > bd;\n\tTETORIS() : N(0) {}\n\tvoid put(int len, int pos) {\n\t\tint k = bd.size()-1;\n\t\tfor (; k>=0; --k) {\n\t\t\tfor (int i=0; i<len; ++i) {\n\t\t\t\tif (bd[k][pos+i]) goto brk;\n\t\t\t}\n\t\t} brk:;\n\t\t++k;\n\t\tif (bd.size() == k) bd.push_back(vector<int>(5, 0));\n\t\tfor (int i=0; i<len; ++i) {\n\t\t\tbd[k][pos+i] = 1;\n\t\t}\n\t\tN += len;\n\t}\n\tvoid update() {\n\t\tfor (int i=bd.size()-1; i>=0; --i) {\n\t\t\tif ( ! count(bd[i].begin(), bd[i].end(), 0)) {\n\t\t\t\tbd.erase(bd.begin()+i);\n\t\t\t\tN -= 5;\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main() {\n\tint n, d, p, q;\n\twhile (cin >> n, n) {\n\t\tTETORIS tet;\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tcin >> d >> p >> q;\n\t\t\tif (d == 1) {\n\t\t\t\ttet.put(p, q-1);\n\t\t\t\ttet.update();\n\t\t\t} else {\n\t\t\t\tfor (int j=0; j<p; ++j) tet.put(1, q-1);\n\t\t\t\ttet.update();\n\t\t\t}\n\t\t}\n\t\tcout << tet.N << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int N = 6000;\nbool b[N][5];\n\nvoid all_fall(int y){\n  rep(j,5)b[y][j]=false;\n  REP(i,y,N-1){\n    rep(j,5)b[i][j]=b[i+1][j];\n  }\n  rep(j,5)b[N-1][j]=false;\n}\n\nint getmax(int l,int r){\n  int ret=0;\n  REP(j,l,r){    \n    int tmp = N-1;\n    for(int i=N-1;i>=0;i--){\n      if (b[i][j])break;\n      tmp=i;\n    }\n    ret=max(ret,tmp);\n  }\n  return ret;\n}\n\nvoid fall(){\n  rep(i,N){\n    if (b[i][0]&b[i][1]&b[i][2]&b[i][3]&b[i][4]){\n      all_fall(i);\n      i--;\n    }\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    rep(i,N)rep(j,5)b[i][j]=false;\n    rep(i,n){\n      int d,p,q;\n      int wid=1,hei=1,pos;\n      cin>>d>>p>>q;\n      q--;\n      if (d == 1){//yoko\n\tpos = getmax(q,q+p);\t\n\twid=p;\n      }else if (d == 2){//tate\n\tpos = getmax(q,q+1);\n\thei=p;\n      }\n\n      rep(i,hei){\n\trep(j,wid){\n\t  b[pos+i][q+j]=true;\n\t}\n      }\n      fall();\n    }\n\n    cout << count(&b[0][0],&b[N][0],true) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  while(true){\n    int n;\n    int ans=0;\n    scanf(\"%d\",&n);\n\n    if(n==0)break;\n    int row[10000]={0,};\n    int h[6]={0,};\n    for(int i = 0; i < n; ++i){\n      int mh = 0;\n      int d,p,q;\n      scanf(\"%d%d%d\", &d, &p, &q);\n\n      if(d==1){\n\tint maxh = 0;\n\tfor(int j = q; j < q + p; ++j){\n\t  maxh = max( maxh, h[j] );\n\t}\n\tfor(int j = q; j < q + p; ++j){\n\t  h[j] = maxh + 1;\n\t}\n\trow[maxh]+=p;\n      }else{\n\tfor(int j = h[q]; j < p + h[q]; ++j){\n\t  row[ j ]++;\n\t}\n\th[q]+=p;\n      }\n\n      // cout << \" DROPPED : \" << i << endl;\n      for(int j = 1; j < 6; ++j){\n\tmh = max( mh , h[j] );\n      }\n\n      for(int j = 0; j < mh; ++j){\n\t// cout << \" row[\"<<j<<\"] = \" << row[j] << endl;\n\tif( row[j] == 5 ){\n\t  for(int k = 1; k < 6; ++k){\n\t    --h[k];\n\t  }\n\t  for(int k = j; k < mh; ++k){\n\t    row[k] = row[k + 1];\n\t  }\n\t  j = -1;\n\t  continue;\n\t}\n      }\n    }\n    for(int i = 0; i < 10000; ++i){\n      ans += row[i];\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d==2&&q-1+p>5)\n\t\t\t\tabort();\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\tflg = flg && board[h_max][j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tfor(int k = h_max; k < top[j]; k++) {\n\t\t\t\t\t\t\tboard[k][j] = board[k + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\n\t\t\t\tint h = top[q - 1];\n\t\t\t\ttop[q - 1] += p;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tflg = flg && board[h + j][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tboard[h + j - del][k] = board[h + j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdel++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tfor(int k = h + p - del; k < top[j] + 10; k++) {\n\t\t\t\t\t\tboard[k][j] = board[k + del][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tans += board[i][j];\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t   for(int i = 10; i >= 0; i--) {\n\t\t   for(int j = 0; j < 5; j++) {\n\t\t   cout << (board[i][j] ? '*' : '.');\n\t\t   }\n\t\t   cout << endl;\n\t\t   }\n\t\t   cout << endl;\n\t\t// */\n\t\t/*\n\t\t   for(int i = 0; i < 5; i++)\n\t\t   cout << top[i] << \" \";\n\t\t   cout << endl;\n\t\t// */\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint mp[10000000][5];\n//d<muki p<nagasa q<basyo\nint d,p,q;\nint ktflg = 0,th;\n\nvoid deb() {\n  for(int i=0;i<10;i++) {\n    for(int j=0;j<5;j++)\n      cout << mp[i][j] << \" \";\n    cout << endl;\n  }\n  cout << \"----------------------------\" <<endl;\n\n}\n\n\nvoid tumeru() { \n  \n  int t;\n  for(int i=1;i<th;i++) {\n    for(int j=0;j<5;j++) {\n      if(mp[i][j] > 0 && ((j>0 && mp[i][j] != mp[i][j-1]) || j==0)){\n\t//\tcout <<j<<\" \"<<mp[i][j]<< endl;\n\tint o=i;\n\tt = mp[i][j];\n\twhile(1) {\n\tint count = 0;\n\tfor(int k=j;k<5;k++) if(t == mp[o][k]) count++;\n\tint flg = 0;\n\tfor(int k=j;k<count;k++) {\n\t  if(mp[o-1][k] != 0) break;\n\t  if(k == count-1) flg = 1;\n\t}\n\tif(flg == 1){\n\t  for(int k=j;k<count;k++) mp[o-1][k] = t , mp[o][k] = 0;\n\t  o--;\n\t  ktflg = 1;\n\t}\n\tif(flg == 0 || o == 0) break;\n\t  }\n      }\n      if(mp[i][j] < 0 && mp[i-1][j] == 0) {\n\tint t = i;\n\tktflg = 1;\n\twhile(1){\n\t  if(t-1 < 0 || mp[t-1][j] !=0) break;\n\t  mp[t-1][j] = mp[t][j],mp[t][j] = 0;\n\t  t--;\n\t}\n      }\n\t\n    }\n  }\n}\n\nvoid kesu() {\n\n     int h = 0;\n  while(1) {\n    int flg =0;\n    for(int i=0;i<5;i++) {\n      if(mp[h][i] !=0) break;\n      if(i == 4) flg = 1;\n    }\n    if(flg == 1) break;\n    h++;\n  }\n  th = h;\n\n  h = 0;\n  while(1) {\n    int zero = 0;\n    int count = 0;\n    for(int i=0;i<5;i++) {\n      if(mp[h][i] == 0) zero++;\n      else count++;\n    }\n\n    if(zero == 5) break;\n    if(count == 5)\n      for(int i=0;i<5;i++)\n\tmp[h][i] = 0;\n    h++;\n  }\n\n  \n}\n       \n\nvoid add(int c) {\n\n  int h = 0;\n  while(1) {\n    int flg =0;\n    for(int i=0;i<5;i++) {\n      if(mp[h][i] !=0) break;\n      if(i == 4) flg = 1;\n    }\n    if(flg == 1) break;\n    h++;\n  }\n  \n  if(d == 1) {\n    while(1) {\n      if(h <= 0)break;\n      int flg = 0;\n      for(int i=0;i<p;i++)\n\tif(mp[h-1][i+q-1] != 0) break;\n\telse if(i == p-1) h-- ,flg = 1;\n      if(flg == 0) break;\n    }\n  \n  \n    for(int i=0;i<p;i++)\n      mp[h][i+q-1] = c;\n  }\n  \n  if(d == 2) {\n\n    int t=1;\n    while(1) {\n      if(h-t >= 0 && mp[h-t][q-1] == 0){\n\th--;\n\tcontinue;\n      }\n      break;\n    }\n    for(int i=0;i<p;i++)mp[h+i][q-1] = -1*c;\n  }\n\n  // deb();\n}\n  \n\n\nint main() {\n\n  int ques;\n  while(1) {\n  cin >> ques;\n  if(ques == 0) break;\n  for(int i=0;i<50000;i++)\n    for(int j=0;j<5;j++)\n      mp[i][j] = 0;\n  \n  int c = 1;\n  for(int i=0;i<ques;i++) {\n    cin >> d >> p >>q;\n    //cout << d <<\" \" << p <<\" \"<<q<<endl;\n    add(c);\n    c++;\n  }\n  //deb();\n  ktflg = 1;\n  while(1) {\n    if(ktflg == 0) break;\n    ktflg = 0;\n    kesu();\n    tumeru();\n  }\n  //    deb();\n    \n  int h=0;\n  int ans = 0;\n  while(1) {\n    int zero = 0;\n    for(int i=0;i<5;i++){\n      if(mp[h][i] == 0) zero++;\n      else ans++;\n    }\n    if(zero == 5) break;\n    h++;\n  }\n  cout << ans << endl;\n\n  }\n    return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nint main() {\n\tint n;\n\twhile(cin >> n) {\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\tvector<int> retu[5];\n\tfor (int i = 0; i < n; i++) {\n\t\tint d, p, q;\n\t\tcin >> d >> p >> q;\n\t\tq--;\n\t\tif (d == 1) {\n\t\t\tint MAX = 0;\n\t\t\tfor (int j = q; j < q+p; j++) {\n\t\t\t\tint k = retu[j].size();\n\t\t\t\tMAX = max(MAX, k);\n\t\t\t}\n\t\t\tfor (int j = q; j < q+p; j++) {\n\t\t\t\tfor (int k = retu[j].size(); k < MAX; k++) {\n\t\t\t\t\tretu[j].push_back(0);\n\t\t\t\t}\n\t\t\t\tretu[j].push_back(1);\n\t\t\t}\n\t\t} else {\n\t\t\tfor (int j = 0; j < p; j++) {\n\t\t\t\tretu[q].push_back(1);\n\t\t\t}\n\t\t}\n\t\tint MIN = retu[0].size();\n\t\tfor (int j = 1; j < 5; j++) {\n\t\t\tint k = retu[j].size();\n\t\t\tMIN = min(MIN, k);\n\t\t}\n\t\tfor (int j = MIN-1; j >= 0; j--) {\n\t\t\tif (retu[0][j]+retu[1][j]+retu[2][j]+retu[3][j]+retu[4][j] == 5) {\n\t\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\t\tfor (int l = j+1; l < retu[k].size(); l++) {\n\t\t\t\t\t\tretu[k][l-1] = retu[k][l];\n\t\t\t\t\t}\n\t\t\t\t\tvector<int>::iterator it = retu[k].end();\n\t\t\t\t\tit--;\n\t\t\t\t\tretu[k].erase(it);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int j = 0; j < 5; j++) {\n\t\t\tvector<int>::iterator it = retu[j].end();\n\t\t\tvector<int>::iterator itt = retu[j].begin();\n\t\t\tit--;\n\t\t\tfor (int k = retu[j].size()-1; k >= 0; k--) {\n\t\t\t\tif (retu[j][k] == 0) {\n\t\t\t\t\tretu[j].erase(it);\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tit--;\n\t\t\t}\n\t\t}\n\t}\n\tint counter = 0;\n\tfor (int i = 0; i < 5; i++) {\n\t\tfor (int j = 0; j < retu[i].size(); j++) {\n\t\t\tif (retu[i][j] == 1) {\n\t\t\t\tcounter++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << counter << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nconst int SIZE = 1001;\nconst int HEIGHT = 5001;\nint n;\nint D[SIZE+10], P[SIZE+10], Q[SIZE+10];\nbool B[HEIGHT+10][10];\n\nint solve() {\n    fill( (bool*)B, (bool*)B+HEIGHT*5, false );\n    \n    \n    for ( int i = 0; i < n; ++ i ) {\n        int d = D[i], p = P[i], q = Q[i];\n        if ( d == 1 ) {\n            bool flag2 = true;\n            for ( int j = HEIGHT - 1; j >= 0; -- j ) {\n                bool flag = false;\n                for ( int k = 0; k < p; ++ k ) {\n                    if ( B[j][q+k] ) flag = true;\n                }\n                if ( flag ) {\n                    for ( int k = 0; k < p; ++ k ) {\n                        B[j+1][q+k] = true;\n                    }\n                    flag2 = false;\n                    break;\n                }\n            }\n            if ( flag2 ) {\n                for ( int k = 0; k < p; ++ k ) {\n                    B[0][q+k] = true;\n                }\n            }\n        } else if ( d == 2 ) {\n            bool flag2 = true;\n            for ( int j = HEIGHT - 1; j >= 0; -- j ) {\n                bool flag = false;\n                for ( int k = 0; k < p; ++ k ) {\n                    if ( B[j+k][q] ) flag = true;\n                }\n                if ( flag ) {\n                    for ( int k = 0; k < p; ++ k ) {\n                        B[j+k+1][q] = true;\n                    }\n                    flag2 = false;\n                    break;\n                }\n            }\n            if ( flag2 ) {\n                for ( int k = 0; k < p; ++ k ) {\n                    B[k][q] = true;\n                }\n            }\n        }\n\n        \n        \n        for ( int j = HEIGHT - 1; j >= 0; -- j ) {\n            bool flag = true;\n            for ( int k = 0; k < 5; ++ k ) {\n                if ( ! B[j][k] ) flag = false;\n            }\n            if ( flag ) {\n                for ( int k = j + 1; k < HEIGHT; ++ k ) {\n                    for ( int l = 0; l < 5; ++ l ) {\n                        B[k-1][l] = B[k][l];\n                    }\n                    for ( int l = 0; l < 5; ++ l ) {\n                        B[k][l] = false;\n                    }\n                }\n            }\n        }\n\n        \n    }\n    int res = 0;\n    for ( int i = 0; i < HEIGHT; ++ i ) {\n        for ( int j = 0; j < 5; ++ j ) {\n            if ( B[i][j] ) res ++;\n        }\n    }\n    return res;\n}\n\nint main() {\n    while ( cin >> n && n ) {\n        for ( int i = 0; i < n; ++ i ) {\n            cin >> D[i] >> P[i] >> Q[i];\n            Q[i] --;\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <cstring>\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n  list<char *>::iterator itr, bef;\n  list<char *> space;\n  int n, b, p, q;\n  while (true) {\n    space.push_back(new char[5]);\n    itr = space.begin();\n    memset(*itr, 0, sizeof(char)*5);\n    cin >> n;\n    if (n == 0)\n      break;\n    for (int i = 0; i < n; i++) {\n      cin >> b >> p >> q;\n      itr = space.begin();\n      q--;\n      if (b == 1) {//yoko                                                                                                                                                                                                                                                                                                                           \n        while (true) {\n          bool avail = true;\n          for (int j = 0; j < p; j++)\n            if((*itr)[q+j])\n              avail = false;\n          if (avail) {\n            bef = itr;\n            itr++;\n            if (itr == space.end()) {\n              for (int j = 0; j < p; j++)\n                (*bef)[q+j] = 1;\n              break;\n            }\n          } else if (!avail && itr == space.begin()) {\n            space.push_front(new char[5]);\n            bef = space.begin();\n            memset(*bef, 0, sizeof(char)*5);\n          } else {\n            for (int j = 0; j < p; j++)\n              (*bef)[q+j] = 1;\n            break;\n          }\n        }\n      } else {//tate                                                                                                                                                                                                                                                                                                                                \n        bef = itr;\n        while (!(*itr)[q] && itr != space.end())\n          itr++;\n        list<char *>::iterator tmp = itr;\n        while (p > 0) {\n          if (itr == space.begin())\n            break;\n          itr--;\n          p--;\n          (*itr)[q] = 1;\n        }\n        for (int j = 0; j < p; j++) {\n          space.push_front(new char[5]);\n          bef = space.begin();\n          memset(*bef, 0, sizeof(char)*5);\n          (*bef)[q] = 1;\n        }\n        itr = tmp;\n      }\n      while (bef != itr) {\n        if ((*bef)[0] && (*bef)[1] && (*bef)[2] &&\n            (*bef)[3] && (*bef)[4]) {\n          list<char *>::iterator tmp = bef;\n          tmp++;\n          space.erase(bef);\n          delete *bef;\n          bef = tmp;\n        } else {\n          bef++;\n        }\n      }\n    }\n    int result = 0;\n    for (list<char *>::iterator prt = space.begin();\n         prt != space.end(); prt++) {\n      for (int j = 0; j < 5; j++) {\n        //cout << (int)(*prt)[j];                                                                                                                                                                                                                                                                                                                   \n        if ((*prt)[j])\n          result++;\n      }\n      /*if (prt == bef)                                                                                                                                                                                                                                                                                                                             \n        cout << \"<-bef\";                                                                                                                                                                                                                                                                                                                            \n      else if (prt == itr)                                                                                                                                                                                                                                                                                                                          \n        cout << \"<-itr\";                                                                                                                                                                                                                                                                                                                            \n        cout << endl;*/\n      delete *prt;\n    }\n    cout << result << endl;\n    space.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <bitset>\nusing namespace std;\n\nint bit(int bits) {\n  bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);\n  bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);\n  bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);\n  bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);\n  return (bits & 0x0000ffff) + (bits >>16 & 0x0000ffff);\n}\n\n\nint main(){\n\tint n,a,b,c,mask,ret;\n\twhile(cin >> n && n){\n\t\tvector<int> data(5001,0);\n\t\tdata[5000] = 63;\n\t\tret = 0;\n\t\twhile(n--){\n\t\t\tcin >> a >> b >> c;\n\t\t\tc--;\n\t\t\tif(a==1){\n\t\t\t\tmask  =  ( (1<<b)-1 ) << c;\n\t\t\t\tfor(int i=0;i+1<data.size();i++){\n\t\t\t\t\tif(data[i+1] & mask){\n\t\t\t\t\t\tdata[i] += mask;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tmask  = 1 << c;\n\t\t\t\tfor(int i=0;i+1<data.size();i++){\n\t\t\t\t\tif(data[i+1] & mask){\n\t\t\t\t\t\tfor(int j=0;j<b;j++)\n\t\t\t\t\t\t\tdata[i-j]+=mask;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\tvector<int>::iterator it = data.begin();\n\t\t\twhile(it != data.end()){\n\t\t\t\tif((*it) == 31){\n\t\t\t\t\tit = data.erase(it);\n\t\t\t\t\tit--;\n\t\t\t\t}\n\t\t\t\tit++;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<data.size()-1;i++){\n\t\t\tret += bit( data[i] );\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\t\t\t\ttop[q - 1] += p;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 10; i >= 0; i--) {\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tcout << (board[i][j] ? '*' : '.');\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t// */\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\n\t\t\tfor(int j = 0; j < 6; j++) {\n\t\t\t\tans += board[i][j];\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 6000; i++) {\n\t\t\tbool flg = true;\n\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\tflg &= board[i][j];\n\t\t\tif(flg)\n\t\t\t\tans -= 5;\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < 5; i++)\n\t\t\tcout << top[i] << \" \";\n\t\tcout << endl;\n\t\t// */\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#define max(a,b) (a>b?a:b)\nchar B[15005][5];\nint N,d,p,q,res;\n\n\nint cnt(int y,int x,int c)\n{\n\tint t=0;\n\tfor(int i=0;i<c;i++)\n\t\tt+=B[y][x+i];\n\treturn t;\n}\n\nvoid dbg()\n{\n\tfor(int i=0;;i++,puts(\"\"))\n\t{\n\t\tint f=cnt(i,0,5);\n\t\tif(!f)break;\n\t\tfor(int j=0;j<5;j++)\n\t\t\tputchar(B[i][j]?'x':'o');\n\t}\n\tputs(\"\");\n}\n\n\nint sch(int h,int w,int p,int y)\n{\n\tint i;\n\tfor(i=y;i>=0;)\n\t{\n\t\tint l=cnt(i,p,w);\n\t\tif(!l)\n\t\t{\n\t\t\tif(i&&cnt(i-1,p,w)==0)\n\t\t\t\ti--;\n\t\t\telse\n\t\t\t\treturn i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(cnt(i+1,p,w)==0)\n\t\t\t\ti++;\n\t\t\telse\n\t\t\t\treturn i;\n\t\t}\n\t}\n\treturn i;\n}\n\nvoid Tset(int y,int x,int h,int w)\n{\n\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\t\tB[y+i][x+j]=1;\n}\n\nvoid flsh()\n{\n\tfor(int i=0;;)\n\t{\n\t\tint j,f=cnt(i,0,5);\n\t\tif(!f)break;\n\t\tif(f==5)\n\t\t{\n\t\t\tint tmp=sizeof(char)*(6000*5-i*(5+1));\n\t\t\tmemmove(B[i],B[i+1],sizeof(char)*25000);\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n}\n\nint r()\n{\n\tint res=0;\n\tfor(int i=0;;i++)\n\t{\n\t\tint t=cnt(i,0,5);\n\t\tif(t==0)break;\n\t\telse if(t==5)continue;\n\t\telse res+=t;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tint h=0,t;\n\t\tres=0;\n\t\tmemset(B,0,sizeof(B));\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&d,&p,&q);\n\t\t\tres+=p;\n\t\t\tq--;\n\t\t\tt=sch(d==1?1:p,d==1?p:1,q,h);\n\t\t\tTset(t,q,d==1?1:p,d==1?p:1);\n\t\t\tif(d==2)t+=p;\n\t\t\telse t++;\n\t\t\th=max(t,h);\n\t\t\tflsh();\n\t\t}\n\t\tprintf(\"%d\\n\",r());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <algorithm>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <cstring>\n#include <deque>\n#include <cstdio>\n#include <cmath>\n#include <complex>\n#include <iostream>\n#include <iterator>\n\nusing namespace std;\n\n#define reps(i,f,t) for(int i=f ; i<int(t) ; ++i)\n#define rep(i,n) reps(i, 0, n) \n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\n\nint find(vi& map, int mask)\n{\n\tfor(int i=map.size()-1; i>=0; --i){\n\t\tif(map[i] & mask)\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\nbool add(vi& map, int y, int mask)\n{\n\tif(y == map.size())\n\t\tmap.push_back(mask);\n\telse\n\t\tmap[y] |= mask;\n\t\n\tif(map[y] == 31){\n\t\tmap.erase(map.begin()+y);\n\t\treturn true;\n\t}\n\telse\n\t\treturn false;\n}\n\nint main()\n{\n\tint n;\n\twhile(scanf(\"%d\", &n), n){\n\t\tvi map;\n\t\trep(i, n){\n\t\t\tint d, p, q;\n\t\t\tscanf(\"%d%d%d\", &d, &p, &q);\n\t\t\t--q;\n\t\t\tif(d == 1){\n\t\t\t\tint mask = ((1<<p)-1) << q;\n\t\t\t\tadd(map, find(map, mask) + 1, mask);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint mask = 1 << q;\n\t\t\t\tint y = find(map, mask) + 1;\n\t\t\t\trep(j, p){\n\t\t\t\t\tif(add(map, y+j, mask))\n\t\t\t\t\t\t--y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\trep(i, map.size())\n\t\t\tans += __builtin_popcount(map[i]);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tdeque<int>E[5];\n\t\trep(i, n) {\n\t\t\tint d, p, q; scanf(\"%d%d%d\", &d, &p, &q); q--;\n\t\t\tif (d == 1) {\n\t\t\t\tint Max = 0;\n\t\t\t\trep(i, p)Max = max(Max, (int)E[q + i].size());\n\t\t\t\trep(i, p) {\n\t\t\t\t\tint k = E[q + i].size();\n\t\t\t\t\trep(j, Max - k)E[q + i].push_back(0);\n\t\t\t\t\tE[q + i].push_back(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep(i, p)E[q].push_back(1);\n\t\t\t}\n\t\t\tint Min = INT_MAX;\n\t\t\trep(i, 5)Min = min(Min, (int)E[i].size());\n\t\t\trep(i, Min) {\n\t\t\t\tbool ok = true;\n\t\t\t\trep(j, 5)ok &= E[j][i];\n\t\t\t\tif (ok) {\n\t\t\t\t\trep(j, 5)E[j][i] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 5)E[i].erase(remove(E[i].begin(), E[i].end(), -1), E[i].end());\n\t\t\trep(i, 5) {\n\t\t\t\twhile (!E[i].empty() && !E[i].back())E[i].pop_back();\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\trep(i, 5)rep(j, E[i].size()) {\n\t\t\tif (E[i][j])sum++;\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nint n, hmax;\nbool maps[6000][5];\n\nint serch(int x, int l) {\n\tfor (int i = hmax; i >= 0; i--) {\n\t\tREP(j, l) if (maps[i][x + j]) return i + 1;\n\t}\n\treturn 0;\n}\n\nint check(int y, int l) {\n\tREP(i, l) {\n\t\tbool flag = true;\n\t\tREP(j, 5) if (!maps[y + i][j]) flag = false;\n\t\tif (flag) return y + i;\n\t}\n\treturn -1;\n}\n\nvoid bset(int d, int p, int q) {\n\tint hl = d == 2 ? p : 1;\n\tint xl = d == 1 ? p : 1;\n\tint hpos = serch(q - 1, xl);\n\t\n\tif (d == 1) REP(i, p) maps[hpos][q + i - 1] = true;\n\telse REP(i, p) maps[hpos + i][q - 1] = true;\n\thmax = max(hmax, hpos + hl);\n\t\n\tint tmp;\n\twhile ((tmp = check(hpos, hl)) != -1) {\n\t\tREP(i, 5) maps[tmp][i] = false;\n\t\tFOR(i, tmp, hmax) {\n\t\t\tREP(j, 5) swap(maps[i][j], maps[i + 1][j]);\n\t\t}\n\t\thmax--;\n\t}\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tmemset(maps, 0, sizeof(maps));\n\t\thmax = 0;\n\t\t\n\t\twhile (n--) {\n\t\t\tint d, p, q;\n\t\t\tscanf(\"%d %d %d\", &d, &p, &q);\n\t\t\tbset(d, p, q);\n\t\t}\n\t\tcout << count(maps[0], maps[6000], true) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX 5000\nclass Tetoris{\n    public:\n    int stack[MAX+1], top;\n    Tetoris(){ stack[0] = 31; top = 0; }\n    \n    void insert( int o, int p, int q ){\n\tint value = (o == 1 ? (((2 << p-1)-1) << (q-1)) : (1 << (q-1)));\n        int target = getTarget( value );\n        for ( int i = target;  i < target + ((o == 2) ? p : 1); i++ ){\n            if ( i > top ){\n                stack[i] = value;\n                top = i;\n            } else {\n\t\tstack[i] += value;\n\t    }\n\t}\n        while( erase());\n    }\n    \n    bool erase(){\n\tfor ( int i = 1; i <= top; i++ ){\n\t    if ( stack[i] == 31 ){\n\t\tfor ( int j = i+1; j <= top; j++ ) stack[j-1] = stack[j];\n\t\ttop--; return true;\n\t    }\n\t}\n\treturn false;\n    }\n    \n    int getResult(){\n\tint sum = 0;\n\tfor ( int i = top; i >= 1; i-- ){\n\t    int val = stack[i];\n\t    while( val ){\n\t\tif ( val%2 ) sum++;\n\t\tval /= 2;\n\t    }\n\t}\n\treturn sum;\n    }\n    \n    int getTarget( int value ){\n\tint target = top;\n\twhile( (stack[target] & value) == 0 ) target--;\n\treturn target + 1;\n    }\n};\n\nint main(){\n    int n, o, p, q;\n    while( cin >> n && n ){\n\tTetoris tetoris;\n\tfor ( int i = 0; i < n; i++ ) {\n\t    cin >> o >> p >> q;\n\t    tetoris.insert(o, p, q);\n\t}\n\tcout << tetoris.getResult() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\tflg &= board[h_max][j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tboard[h_max][j] = 0;\n\t\t\t\t\t\tfor(int k = h_max; k < top[j]; k++) {\n\t\t\t\t\t\t\tboard[k][j] = board[k + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\n\t\t\t\tint h = top[q - 1];\n\t\t\t\ttop[q - 1] += p;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tflg &= board[h + j][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tboard[h + j - del][k] = board[h + j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdel++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tfor(int k = h + p - del; k < top[j] + 10; k++) {\n\t\t\t\t\t\tboard[k][j] = board[k + del][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 10; i >= 0; i--) {\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tcout << (board[i][j] ? '*' : '.');\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t// */\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\n\t\t\tfor(int j = 0; j < 6; j++) {\n\t\t\t\tans += board[i][j];\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < 5; i++)\n\t\t\tcout << top[i] << \" \";\n\t\tcout << endl;\n\t\t// */\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n;\n  while(cin>>n,n){\n    int a[5][10000]={},b[5]={},sum=0;\n    while(n--){\n      int q,w,e;\n      cin>>q>>w>>e;e--;\n      sum+=w;\n      if(q==2){\n        for(int i=b[e];i<b[e]+w;i++)\n          a[e][i+1]=1;\n        b[e]+=w;\n      }\n      else{\n        int res=0;\n        for(int i=e;i<e+w;i++)\n          res=max(res,b[i]);\n        for(int i=e;i<e+w;i++)\n          a[i][res+1]=1;\n        for(int i=e;i<e+w;i++)\n          b[i]=res+1;\n      }\n    }\n    for(int i=0;i<10000;i++){\n      int pp=0;\n      for(int j=0;j<5;j++)if(a[j][i])pp++;\n      if(pp==5)sum-=5;\n    }\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\n#define int long long int\nconst int INF = 1001001001001001LL;\nconst int MOD = 1000000007;\n\nint di[] = {-1, 0, 1, 0, -1, 1, 1, -1};\nint dj[] = {0, 1, 0, -1, 1, 1, -1, -1};\n    \nint g[5100][5];\n\nsigned main(){\n    \n    while(1){\n    memset(g, 0, sizeof(g));\n    int n; cin >> n;\n    if(!n) break;\n    int sum = 0;\n    for(int j = 0; j < 5; j++){\n        g[0][j] = 1;\n    }\n\n\n    for(int i = 0; i < n; i++){\n\n        int a, p, q; cin >> a >> p >> q;\n        swap(p, q);\n        p--;\n        sum += q;\n        if(a == 1){\n\n\n            // 落とす\n            int y;\n            for(int i = 5000; i >= 1; i--){\n                bool flag = false;\n                for(int j = p; j < p + q; j++){\n                    if(g[i - 1][j] == 1){\n                        flag = true;\n                        y = i;        \n                        break;\n                    }\n                }\n                if(flag) break;\n            }\n\n            for(int j = p; j < p + q; j++){\n                g[y][j] = 1;\n            }\n\n            // 消えるかどうか\n            bool erase = true;\n            for(int j = 0; j < 5; j++){\n                if(!g[y][j]) erase = false;\n            }\n\n            if(erase){\n                sum -= 5;\n                for(int i = y + 1; i <= 5000; i++){\n                    for(int j = 0; j < 5; j++){\n                        g[i - 1][j] = g[i][j];\n                        g[i][j] = 0;\n                    }\n                }\n            }\n\n        }else{\n            \n\n            // 落とす\n            int y = 0;\n            for(int i = 5000; i >= 0; i--){\n                if(g[i - q][p]){\n                    y = i;\n                    break;\n                }\n            }\n\n            for(int i = y - q + 1; i <= y; i++) g[i][p] = 1;\n\n            // 消えるかどうか\n            y = y - q + 1;\n            for(int itr = 0; itr < 5; itr++){\n                bool erase = true;\n                for(int j = 0; j < 5; j++){\n                    if(!g[y][j]) erase = false;\n                }\n\n                if(erase){\n                    sum -= 5;\n                    for(int i = y + 1; i <= 5000; i++){\n                        for(int j = 0; j < 5; j++){\n                            g[i - 1][j] = g[i][j];\n                            g[i][j] = 0;\n                        }\n                    }\n                }else{\n                    y++;\n                }\n            }\n        }\n\n        /*\n        // デバック\n        for(int i = 10; i >= 0; i--){\n            for(int j = 0; j < 5; j++){\n                cout << g[i][j] << \" \";\n            }\n            cout << endl;\n        }\n        */\n    }\n\n\n    cout << sum << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nbool t[5001][5];\nint u[5];\nvoid init();\nvoid make_table();\nint n;\nint d,p,q,cnt;\nint main(){\n\n  while(cin>>n&&n!=0){\n    init();\n    for(int i=0;i<n;i++){\n\n      cin>>d>>p>>q;\n      q--;\n      make_table();\n\n\n\n    }\n    cnt=0;\n    for(int i=0;i<5000;i++)for(int j=0;j<5;j++)if(t[i][j])cnt++;\n    \n    cout<<cnt<<endl;\n  }  \n  return 0;\n}\n\nvoid init(){\n  for(int i=0;i<=5000;i++){\n    for(int j=0;j<5;j++){\n      t[i][j]=false;\n    }\n  }\n  for(int i=0;i<5;i++)u[i]=0;\n}\n\nvoid make_table(){\n  int h;\n  if(d==1){\n    h=0;\n    for(int j=q;j<q+p;j++)h=max(h,u[j]);\n    for(int j=q;j<q+p;j++){t[h][j]=true;u[j]=h+1;}\n  }else{\n    h=u[q];\n    for(int i=h;i<h+p;i++)t[i][q]=true;\n    u[q]+=p;\n  }\n\n\n\n\n\n\n  h=0;\n  for(int j=0;j<5;j++)h=max(h,u[j]);\n\n  for(int i=0;i<h;i++){\n    if(t[i][0]&&t[i][1]&&t[i][2]&&t[i][3]&&t[i][4]){\n      for(int j=0;j<5;j++){\n\tt[i][j]=false;\n\tu[j]--;\n      }\n    }\n  }\n \n  /*\n      for(int I=7;I>=0;I--){\n\tfor(int j=0;j<5;j++){\n\t  cout<<(int)t[I][j];\n\t}\n\tcout<<endl;\n      }\n      cout<<endl;\n\n  */\n  int H=0;\n  for(int i=0;i<=5000;i++){\n    if(t[i][0]||t[i][1]||t[i][2]||t[i][3]||t[i][4]){\n      for(int j=0;j<5;j++){\n\tt[H][j]=t[i][j];\n\tif(H!=i)t[i][j]=false;\n      }\n      H++;\n    }\n  }\n\n  for(int j=0;j<5;j++){\n    for(int i=u[j]+1;i>=0;i--){\n      if(t[i][j]){\n\tu[j]=i+1;\n\tbreak;\n      }\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#line 0 \"cmacro.cpp\"\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define in ,\n#define esc_paren(...) __VA_ARGS__\n#define pp_empty(...)\n#define pp_cat_i(x, y) x ## y\n#define pp_cat(x, y) pp_cat_i(x, y)\n\n#define pp_inc0 1\n#define pp_inc1 2\n#define pp_inc2 3\n#define pp_inc3 4\n#define pp_inc4 5\n#define pp_inc5 6\n#define pp_inc6 7\n#define pp_inc7 8\n#define pp_inc8 9\n#define pp_inc(i) pp_cat(pp_inc, i)\n\n#define pp_arg10(_0, _1, _2, _3, _4, _5, _6, _7, _8, _9, ...) _9\n#define pp_has_comma(...) pp_arg10(__VA_ARGS__, 1, 1, 1, 1, 1, 1, 1, 1, 0)\n#define pp_trigger_paren(...) ,\n#define pp_is_empty(...) \\\n  pp_is_empty1( \\\n      pp_has_comma(__VA_ARGS__), \\\n      pp_has_comma(pp_trigger_paren __VA_ARGS__), \\\n      pp_has_comma(__VA_ARGS__()), \\\n      pp_has_comma(pp_trigger_paren __VA_ARGS__()) \\\n      ) \n#define pp_paste5(_0, _1, _2, _3, _4) _0 ## _1 ## _2 ## _3 ## _4\n#define pp_is_empty1(_0, _1, _2, _3) pp_has_comma(pp_paste5(pp_is_empty_case_, _0, _1, _2, _3))\n#define pp_is_empty_case_0001 ,\n\n#define pp_is_one(...) pp_is_one_(__VA_ARGS__, pp_one_seq)\n#define pp_is_one_(...) pp_is_one_n(__VA_ARGS__)\n#define pp_is_one_n(_1,_2,_3,_4,_5,_6,_7,_8,_9,_10, N, ...) N\n#define pp_one_seq 0,0,0,0,0,0,0,0,0,1,0\n\n#define pp_narg(...) \\\n         pp_narg_(__VA_ARGS__, pp_narg_seq)\n#define pp_narg_(...) \\\n         pp_narg_n(__VA_ARGS__)\n#define pp_narg_n( \\\n          _1, _2, _3, _4, _5, _6, _7, _8, _9,_10, \\\n         _11,_12,_13,_14,_15,_16,_17,_18,_19,_20, \\\n         _21,_22,_23,_24,_25,_26,_27,_28,_29,_30, \\\n         _31,_32,_33,_34,_35,_36,_37,_38,_39,_40, \\\n         _41,_42,_43,_44,_45,_46,_47,_48,_49,_50, \\\n         _51,_52,_53,_54,_55,_56,_57,_58,_59,_60, \\\n         _61,_62,_63,n,...) n\n#define pp_narg_seq \\\n         63,62,61,60, \\\n         59,58,57,56,55,54,53,52,51,50, \\\n         49,48,47,46,45,44,43,42,41,40, \\\n         39,38,37,36,35,34,33,32,31,30, \\\n         29,28,27,26,25,24,23,22,21,20, \\\n         19,18,17,16,15,14,13,12,11,10, \\\n          9, 8, 7, 6, 5, 4, 3, 2, 1, 0\n\n#define pp_if_0(x, y) y\n#define pp_if_1(x, y) x\n#define pp_if(cond, x, y) pp_cat(pp_if_, cond)(x, y)\n\n#define pp_foreach_i9(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i8(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i7(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i6(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i5(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i4(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i3(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i2(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i1(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i0(i, f, x, ...) f(x) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach_i(i, f, ...) pp_if(pp_is_empty(__VA_ARGS__), pp_empty, pp_cat(pp_foreach_i, i))(pp_inc(i), f, __VA_ARGS__)\n#define pp_foreach(f, ...) pp_foreach_i(0, f, __VA_ARGS__)\n\n\ntypedef long long ll;\n#define down_queue(x) priority_queue<x>\n#define up_queue(x) priority_queue<x, vector<x>, greater<x>>\n#define all(x) x.begin(), x.end()\n#define split_str(str, sp_word) istringstream stream(str); string res; for(int cnt = 0; getline(stream,res,sp_word); cnt++)\n#define digit(x) ((int)log10((double)(x)) + 1)\n#define mp(x,y) make_pair(x,y)\n#define pb(x) push_back(x)\n#define pf(x) push_front(x)\n#define vec_cpy(to,from) copy(all(to),back_inserter(from))\n#define ary_cpy(to,from) memcpy(to, from, sizeof(from))\n#define MOD 1000000007\n#define INF 999999999\n\n\ntemplate <typename T>\nstruct RepIterator {\n  T i;\n  RepIterator() : i(0) {}\n  RepIterator(T n) : i(n) {}\n  bool operator ==(const RepIterator<T>& rhs) { return i == rhs.i; }\n  bool operator !=(const RepIterator<T>& rhs) { return i != rhs.i; }\n  T operator *() { return i; }\n  RepIterator<T> operator ++() {i++; return *this; };\n};\ntemplate <typename T>\nstruct RepLoop {\n  T i;\n  RepLoop(T n) : i(n) {}\n  RepIterator<T> begin() { return RepIterator<T>(); }\n  RepIterator<T> end() { return RepIterator<T>(i); }\n};\n\ntemplate <typename T>\nstruct rep_range {\n  static T range(T v) {\n    return v;\n  }\n};\n\n#define def_range(t) \\\n  template <> \\\n  struct rep_range<t> { \\\n    static RepLoop<t> range(t n) { \\\n      return RepLoop<t>(n); \\\n    } \\\n  };\ndef_range(int);\ndef_range(size_t);\n\n#define rep(...) rep1(rep2, (__VA_ARGS__))\n#define rep1(X, A) X A\n#define rep2(i, ...) pp_if(pp_is_one(__VA_ARGS__), rep_len1(i, __VA_ARGS__), rep3(i, __VA_ARGS__))\n#define rep_len1(i, end, ...) for (auto i : rep_range<decltype(end)>::range(end))\n#define rep3(i, iter, ...) rep4(rep5, (iter, i, esc_paren __VA_ARGS__))\n#define rep4(X, A) X A\n#define rep5(iter, ...) iter(__VA_ARGS__)\n\n#define up up_iter ,\n#define up_iter3(i, start, end) for (auto i = start; i < end; i++)\n#define up_iter4(i, start, end, up) for (auto i = start; i < end; i += up)\n#define up_iter(...) pp_cat(up_iter, pp_narg(__VA_ARGS__))(__VA_ARGS__)\n#define down down_iter ,\n#define down_iter2(i, end) for(auto i = end-1; i >= 0; i--)\n#define down_iter3(i, start, end) for (auto i = end-1; i >= start; i--)\n#define down_iter4(i, start, end, down) for (auto i = end-1; i >= start; i -= down)\n#define down_iter(...) pp_cat(down_iter, pp_narg(__VA_ARGS__))(__VA_ARGS__)\n\n\n#define pp_init2(cnt, body) struct _InitStruct ## cnt { _InitStruct ## cnt() { body } } _initstruct ## cnt;\n#define pp_init1(f, cnt, body) f(cnt, body)\n#define pp_init(body) pp_init1(pp_init2, __COUNTER__, body)\n\n#define init_array(arr, N, val) pp_init(rep (i in N) { arr[i] = val; })\n#define iota_array(arr, N, start) pp_init(rep (i in N) { arr[i] = start + i; })\n\n\n#define debug_var_elem(v) << #v << \"=\" << v << \" \"\n#ifdef DEBUG\n#define debug_echo(e) cout << \"L\" << __LINE__ << \": \" << e << endl\n#define debug_var(...) cout << \"L\" << __LINE__ << \": \" pp_foreach(debug_var_elem, __VA_ARGS__) << endl\n#define debug_time2(i, e) auto start ## i = clock(); e; auto end ## i = clock(); cout << \"L\" << __LINE__ << \": \" << (double)(end ## i - start ## i) << \"ms\" << endl;\n#define debug_time1(f, i, e) f(i, e)\n#define debug_time(e) debug_time1(debug_time2, __COUNTER__, e)\n#else\n#define debug_echo(e)\n#define debug_var(...)\n#define debug_time(e) e;\n#endif\n\n\n#define pp_gen_field(list) pp_gen_field1 list\n#define pp_gen_field1(name, val) decltype(val) name;\n#define pp_gen_init(list) pp_gen_init1 list\n#define pp_gen_init1(name, val) ,val\n#define pp_gen_find_set_wrap(ufnodename) ufnodename pp_gen_find_set\n#define pp_gen_find_set(list) pp_gen_find_set1 list\n#define pp_gen_find_set1(name, val) \\\n  find_set_ ## name(int x, decltype(val) v) { \\\n    if (nodes[x].parent == x) { \\\n      nodes[x].name = v; \\\n      return nodes[x]; \\\n    } else { \\\n      return nodes[x] = find_set_ ## name(nodes[x].parent, v); \\\n    } \\\n  }\n#define pp_gen_unite_set(list) pp_gen_unite_set1 list\n#define pp_gen_unite_set1(name, val) \\\n  if (nodes[x].name == val) { \\\n    find_set_ ## name(x, find(y).name); \\\n  } \\\n  if (nodes[y].name == val) { \\\n    find_set_ ## name(y, find(x).name); \\\n  }\n\n#define def_unionfind(ufname, ufnodename, ...) \\\n  struct ufnodename { \\\n    int parent; \\\n    pp_foreach(pp_gen_field, __VA_ARGS__) \\\n  }; \\\n  struct ufname { \\\n    vector<ufnodename> nodes; \\\n    vector<int> rank; \\\n    ufname(int n) : nodes(n+1), rank(n+1) { \\\n      rep (i in n) { \\\n        nodes[i] = ufnodename{i pp_foreach(pp_gen_init, __VA_ARGS__)}; \\\n        rank[i] = 0; \\\n      } \\\n    } \\\n    ufnodename find(int x) { \\\n      if (nodes[x].parent == x) { \\\n        return nodes[x]; \\\n      } else { \\\n        return nodes[x] = find(nodes[x].parent); \\\n      } \\\n    } \\\n    pp_foreach(pp_gen_find_set_wrap(ufnodename), __VA_ARGS__) \\\n    void unite(int x, int y) { \\\n      x = find(x).parent; \\\n      y = find(y).parent; \\\n      if (x == y) return; \\\n      if (rank[x] < rank[y]) { \\\n        pp_foreach(pp_gen_unite_set, __VA_ARGS__); \\\n        nodes[x].parent = y; \\\n      } else { \\\n        pp_foreach(pp_gen_unite_set, __VA_ARGS__); \\\n        nodes[y].parent = x; \\\n        if (rank[x] == rank[y]) rank[x]++; \\\n      } \\\n    } \\\n    bool same(int x, int y) { \\\n      return find(x).parent == find(y).parent; \\\n    } \\\n  }\n\n\nll gcd(ll a,ll b){while(b){ll tmp = a % b;a = b;b = tmp;}return a;}\nll lcm(ll a,ll b){return a / gcd(a,b) * b;}\nbool is_prime(ll n){switch(n){case 0:case 1: return false;case 2: return true;}if(n % 2 == 0) return false;for(ll i=3;i * i <= n; i += 2)if(n%i == 0) return false;return true;}\n\n#define def_varargs(name, f) \\\n  template<typename First> \\\n  inline First name(First first) { return first; } \\\n  template<typename First, typename... Rest> \\\n  inline First name(First first, Rest... rest) { return f(first, name(rest...)); }\n\n#line 1 \"procon.cpp\"\n\nbool tetris[5001][5];\n\nbool is_align(int n) {\n  rep (i in 5) {\n    if (!tetris[n][i]) return false;\n  }\n  return true;\n}\nbool is_emptyline(int n) {\n  rep (i in 5) {\n    if (tetris[n][i]) return false;\n  }\n  return true;\n}\nbool can_down_hori(int n, int s, int l) {\n  if (n < 0) return false;\n  rep (i in l) {\n    if (tetris[n][s+i]) return false;\n  }\n  return true;\n}\nbool can_down_vert(int n, int s, int l) {\n  if (n < 0) return false;\n  if (tetris[n][s]) return false;\n  return true;\n}\n\n\nvoid debug_tetris(int upper) {\n#ifdef DEBUG\n  rep (i in down(upper+1)) {\n    rep (j in 5) cout << tetris[i][j] << \" \";\n    cout << endl;\n  }\n#endif\n}\n\nint main() {\n  int N;\n  while (cin >> N && N) {\n    memset(tetris, false, sizeof(tetris));\n    int upper = 0;\n    rep (_ in N) {\n      int d, l, s; cin >> d >> l >> s;\n      s--;\n      debug_var(upper);\n      rep (i in down(upper+1)) {\n        if (d == 1) {\n          if (can_down_hori(i-1, s, l)) continue;\n          debug_var(can_down_hori(i-1, s, l), i, d, l, s);\n          rep (j in l) {\n            tetris[i][s+j] = true;\n          }\n          upper = max(upper, i+1);\n          debug_tetris(upper);\n          break;\n        } else {\n          debug_var(can_down_vert(i-1, s, l), i, d, l, s);\n          if (can_down_vert(i-1, s, l)) continue;\n          rep (j in l) {\n            tetris[i+j][s] = true;\n          }\n          upper = max(upper, i+l);\n          debug_tetris(upper);\n          break;\n        }\n      }\n      int i = 0;\n      while (i < upper) {\n        debug_var(i, is_align(i));\n        if (is_align(i)) {\n          rep (j in up(i, upper)) {\n            rep (k in 5) {\n              tetris[j][k] = tetris[j+1][k];\n            }\n          }\n          upper--;\n          debug_tetris(upper);\n        } else {\n          if (is_emptyline(i)) break;\n          i++;\n        }\n      }\n    }\n    int cnt = 0;\n    rep (i in upper) {\n      rep (j in 5) {\n        if (tetris[i][j]) cnt++;\n      }\n    }\n    cout << cnt << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n \nusing namespace std;\n \nconst int Height = 5010;\nconst int Width = 5;\nchar field[Height][Width];\nint top,ans;\nint dx[] = {1,0};\nint dy[] = {0,-1};\n \nvoid print(int h, int w){\n \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl;\n     \n}\nbool isInside(int h, int w){return 0<=h&&h<Height&&0<=w&&w<Width;}\n \nint getH(int d, int len, int pos){\n  for(int i = top+1; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?' || !isInside(h,w)) return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n}\n\nvoid down(int n){\n \n  for(int i = n; i <= top+2; i++)\n    for(int j = 0; j < Width; j++) field[i][j] = field[i+1][j];\n  top--;\n}\n\nvoid erase(){\n  while(1){\n    bool update = false;\n    for(int i = 0; i <= top+2; i++){\n      bool f = true;\n      for(int j = 0; j < Width; j++) if(field[i][j] == '?') f = false;\n      if(f){\n\tans -= 5;\n\tdown(i--);\n\tupdate = true;\n      }\n    }\n    if(!update) break;\n  }\n}\n \nvoid put(int d, int len, int pos){\n \n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n \n  int h = nex;\n  int w = pos;\n \n  for(int i = 0; i < len; i++){\n    field[h][w] = '.';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n \nint main(){\n \n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    ans = top = 0;\n    \n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      ans += len;\n      put(d-1,len,pos-1);\n      erase();\n    }\n    cout << ans << endl;\n    //  print(5,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint grid[5][100010];\nint n,d,p,q;\nll int ans = 0;\n\nint GetBottom(int x){\n\tREP(i,100000){\n\t\tif(grid[x][i]==-1) return i;\n\t}\n\treturn -1;\n}\n\nbool isallclear(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=-1) return false;\n\t}\n\treturn true;\n}\n\nbool isallblock(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n;\n\t\tREP(i,5) REP(j,100000) grid[i][j] = -1;\n\t\tREP(i,n){\n\t\t\tcin >> d >> p >> q;\n\t\t\tif(d==2){\n\t\t\t\tint tmp = GetBottom(q-1);\n\t\t\t\tFOR(j,tmp,tmp+p) grid[q-1][j] = 1;\n\t\t\t}else{\n\t\t\t\tint tmp = -1;\n\t\t\t\tFOR(j,q-1,q-1+p){\n\t\t\t\t\ttmp = max(tmp,GetBottom(j));\n\t\t\t\t}\n\t\t\t\tFOR(j,q-1,q-1+p) {\n\t\t\t\t\tgrid[j][tmp] = 1;\n\t\t\t\t\tREP(k,tmp) if(grid[j][k]==-1) grid[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowline = 0;\n\t\t\twhile(1){\n\t\t\t\tif(isallclear(nowline)) break;\n\t\t\t\tif(isallblock(nowline)){\n\t\t\t\t\tREP(j,5) grid[j][nowline] = 0;\n\t\t\t\t}\n\t\t\t\tnowline++;\n\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tint line = 0;\n\t\twhile(1){\n\t\t\tif(isallclear(line)) break;\n\t\t\tREP(i,5){\n\t\t\t\tif(grid[i][line]==1) ans++;\n\t\t\t}\n\t\t\tline++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nint main() {\n  int n;\n  while(cin >> n) {\n    if(!n) return 0;\n    int m[5][5005] = {};\n    int gou = 0;\n    rep(i, 0, n) {\n      int d, p, q;\n      cin >> d >> p >> q;\n      gou += p;\n      if(d == 1) {\n        dep(j, 4998, 0) {\n          int f = 0;\n          rep(k, q - 1, p) {\n            if(m[k][j]) {\n              rep(l, q - 1, p) {\n                m[l][j + 1] = 1;\n              }\n              f = 1;\n              break;\n            }\n          }\n          if(f) break;\n          if(j == 0) {\n            rep(l, q - 1, p) {\n              m[l][j] = 1;\n            }\n            break;\n          }\n        }\n      }else {\n        dep(j, 4998, 0) {\n          int f = 0;\n          if(m[q - 1][j - (p - 1)]) {\n            rep(k, 0, p) {\n              m[q - 1][j + k] = 1;\n              f = 1;\n              break;\n            }\n          }\n          if(f) break;\n          if(j == 0) {\n            rep(l, 0, p) {\n              m[q - 1][j + l] = 1;\n            }\n            break;\n          }\n        }\n      }\n    }\n\n    rep(i, 0, 5005) {\n      int f = 0;\n      rep(j, 0, 5) {\n        if(!m[j][i]) {\n          f = 1;\n          break;\n        }\n      }\n      if(!f) gou -= 5;\n    }\n\n\n    cout << gou << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/08/10 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nclass Tetoris{\n\tprivate:\n\t\tint stack[5001][5];\n\t\tint top;\n\tpublic:\n\t\tTetoris();\n\t\tvoid insert(int d, int p, int q);\n\t\tbool erase();\n\t\tint getResult();\n\t\tvoid printStack();\n};\n\nTetoris::Tetoris()\n{\n\tfor(int i=0; i<=5000; i++)\n\t\tfor(int j=0; j<5; j++)\n\t\t\tif(i==0)\n\t\t\t\tstack[i][j] = 1;\n\t\t\telse\n\t\t\t\tstack[i][j] = 0;\n\n\ttop = 0;\n}\n\nvoid Tetoris::insert(int d, int p, int q)\n{\n\tif(d==1){\n\t\tint target;\n\t\tbool flg = false;\n\t\tfor(int i=top; i>=0; i--){\n\t\t\tfor(int j=0; j<p; j++){\n\t\t\t\tif(stack[i][q-1+j]!=0){\n\t\t\t\t\ttarget = i+1;\n\t\t\t\t\tflg = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg)\n\t\t\t\tbreak;\n\t\t}\n\t\tfor(int j=0; j<p; j++)\n\t\t\tstack[target][q-1+j] = 1;\n\t\tif(top<target)\n\t\t\ttop = target;\n\t}\n\telse{\n\t\tint target;\n\t\tfor(int i=top; i>=0; i--)\n\t\t\tif(stack[i][q-1]!=0){\n\t\t\t\ttarget = i+1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\tfor(int i=0; i<p; i++)\n\t\t\tstack[target+i][q-1] = 1;\n\t\tif(top<target+p-1)\n\t\t\ttop = target+p-1;\n\t}\n\n\twhile(erase())\n\t\t;\n}\n\nbool Tetoris::erase()\n{\n\tfor(int i=1; i<=top; i++)\n\t\tif(stack[i][0]==1&&stack[i][1]==1&&stack[i][2]==1&&stack[i][3]==1&&stack[i][4]==1){\n\t\t\tfor(int ii=i+1; ii<=top; ii++){\n\t\t\t\tstack[ii-1][0] = stack[ii][0];\n\t\t\t\tstack[ii-1][1] = stack[ii][1];\n\t\t\t\tstack[ii-1][2] = stack[ii][2];\n\t\t\t\tstack[ii-1][3] = stack[ii][3];\n\t\t\t\tstack[ii-1][4] = stack[ii][4];\n\t\t\t}\n\t\t\ttop--;\n\t\t\treturn true;\n\t\t}\n\n\treturn false;\n}\n\nint Tetoris::getResult()\n{\n\tint sum = 0;\n\tfor(int i=top; i>=1; i--)\n\t\tfor(int j=0; j<5; j++)\n\t\t\tif(stack[i][j]==1)\n\t\t\t\tsum++;\n\n\treturn sum;\n}\n\nvoid Tetoris::printStack()\n{\n\tfor(int i=top; i>=1; i--){\n\t\tfor(int j=0; j<5; j++)\n\t\t\tcout << stack[i][j];\n\t\tcout << endl;\n\t}\n}\n\nint main()\n{\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0)\n\t\t\tbreak;\n\n\t\tTetoris tetoris;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\t\t\ttetoris.insert(d, p, q);\n\t\t}\n\n//\t\ttetoris.printStack();\n\t\tcout << tetoris.getResult() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define H_MAX 1001\nusing namespace std;\n\nvoid breakLine(int data[H_MAX][5], int y) {\n  for(int i = y; i+1 < H_MAX; i++) {\n    for(int j = 0; j < 5; j++) {\n      data[i][j] = data[i+1][j];\n    }\n  }\n}\n\nvoid search(int data[H_MAX][5], int sy, int ey) {\n  for(int i = sy; i <= ey; i++) {\n    bool flag = true;\n    for(int j = 0; j < 5; j++) {\n      if(data[i][j] != 1) {\n\tflag = false;\n\tbreak;\n      }\n    }\n    if(flag) {\n      breakLine(data, i);\n      i--;\n    }\n  }\n}\n\nint main() {\n  while(1) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n\n    int data[H_MAX][5];\n    //fill(&data[0][0], &data[H_MAX-1][4] + 1, 0);\n    for(int i = 0; i < H_MAX; i++) {\n      for(int j = 0; j < 5; j++) {\n\tdata[i][j] = 0;\n      }\n    }\n    for(int i = 0; i < 5; i++) {\n      data[0][i] = 1;\n    }\n\n    for(int i = 0; i < n; i++) {\n      int d, p, q, qy;\n      cin >> d >> p >> q;\n      q--;\n      for(int y = H_MAX-1; y >= 0; y--) {\n\tbool put = false;\n\tswitch(d) {\n\tcase 1:\n\t  for(int j = 0; j < p; j++) {\n\t    if(data[y][q+j] == 1) {\n\t      put = true;\n\t      y++;\n\t      qy = y;\n\t      for(int k = 0; k < p; k++) {\n\t\tdata[y][q+k] = 1;\n\t      }\n\t      break;\n\t    }\n\t  }\n\t  break;\n\tcase 2:\n\t  if(data[y][q] == 1) {\n\t    put = true;\n\t    y++;\n\t    qy = y;\n\t    for(int j = 0; j < p; j++) {\n\t      data[y+j][q] = 1;\n\t    }\n\t  }\n\t  break;\n\t}\n\tif(put) {\n\t  break;\n\t}\n      }\n\n      switch(d) {\n      case 1: search(data, qy, qy); break;\n      case 2: search(data, qy, qy+p-1); break;\n      }\n    }\n\n    int count = 0;\n    for(int i = 1; i < H_MAX; i++) {\n      for(int j = 0; j < 5; j++) {\n\tcount += data[i][j];\n      }\n    }\n    cout << count << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int N = 6000;\nbool block[N][5];\n\nvoid all_fall(int y){\n  rep(j,5)block[y][j]=false;\n  REP(i,y,N-1){\n    rep(j,5)block[i][j]=block[i+1][j];\n  }\n  rep(j,5)block[N-1][j]=false;\n}\n\nint getmax(int l,int r){\n  int ret=0;\n  REP(j,l,r){    \n    int tmp = N-1;\n    for(int i=N-1;i>=0;i--){\n      if (block[i][j])break;\n      tmp=i;\n    }\n    ret=max(ret,tmp);\n  }\n  return ret;\n}\n\nvoid fall(){\n  rep(i,N){\n    if (block[i][0]&block[i][1]&block[i][2]&block[i][3]&block[i][4]){\n      all_fall(i);\n      i--;\n    }\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    rep(i,N)rep(j,5)block[i][j]=false;\n    rep(i,n){\n      int d,p,q;\n      int wid=1,hei=1,pos;\n      cin>>d>>p>>q;\n      q--;\n      if (d == 1){//yoko\n\tpos = getmax(q,q+p);\t\n\twid=p;\n      }else if (d == 2){//tate\n\tpos = getmax(q,q+1);\n\thei=p;\n      }\n\n      rep(i,hei){\n\trep(j,wid){\n\t  block[pos+i][q+j]=true;\n\t}\n      }\n      fall();\n    }\n\n    cout << count(&block[0][0],&block[N][0],true) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\tflg = flg && board[h_max][j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tfor(int k = h_max; k < top[j]; k++) {\n\t\t\t\t\t\t\tboard[k][j] = board[k + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\n\t\t\t\tint h = top[q - 1];\n\t\t\t\ttop[q - 1] += p;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tflg = flg && board[h + j][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tboard[h + j - del][k] = board[h + j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdel++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tfor(int k = h + p - del; k < top[j] + 10; k++) {\n\t\t\t\t\t\tboard[k][j] = board[k + del][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tans += board[i][j];\n\t\t\t\tif(board[i][j] > 1)\n\t\t\t\t\tabort();\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 10; i >= 0; i--) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tcout << (board[i][j] ? '*' : '.');\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t// */\n\t\t/*\n\t\tfor(int i = 0; i < 5; i++)\n\t\t\tcout << top[i] << \" \";\n\t\tcout << endl;\n\t\t// */\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int HORIZONTAL = 1;\nconst int VERTICAL   = 2;\nconst int MAX_H = 5000;\nconst int WIDTH = 5;\nconst int N_BLOCK_MAX = 1000;\n\nclass Block\n{\npublic:\n\tint d, p, q;\n\tBlock() {}\n};\n\nclass Row\n{\npublic:\n\tint i[5];\n\tRow()\n\t{\n\t\tfor(int m=0; m<5; m++) i[m] = 0;\n\t}\n};\n\nint n;\nBlock blocks[N_BLOCK_MAX];\nvector<Row> field;\n\nbool isSetOk(Block b, int y)\n{\n\tif(b.d == HORIZONTAL)\n\t{\n\t\tfor(int dx=0; dx<b.p; dx++)\n\t\t{\n\t\t\tint xx = b.q + dx;\n\t\t\tif(field[y].i[xx]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\telse if(b.d == VERTICAL)\n\t{\n\t\tfor(int dy=0; dy<b.p; dy++)\n\t\t{\n\t\t\tint yy = y + dy;\n\t\t\tif(field[yy].i[b.q]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid setBlock(Block b, int y)\n{\n\tif(b.d == HORIZONTAL)\n\t{\n\t\tfor(int dx=0; dx<b.p; dx++)\n\t\t{\n\t\t\tint xx = b.q + dx;\n\t\t\tfield[y].i[xx] = 1;\n\t\t}\n\t}\n\telse if(b.d == VERTICAL)\n\t{\n\t\tfor(int dy=0; dy<b.p; dy++)\n\t\t{\n\t\t\tint yy = y + dy;\n\t\t\tfield[yy].i[b.q] = 1;\n\t\t}\n\t}\n}\n\nvoid checkErase()\n{\n\tvector<Row>::iterator iter = field.begin();\n\twhile(iter != field.end())\n\t{\n\t\tbool is_empty = true;\n\t\tbool is_fill = true;\n\t\tfor(int x=0; x<WIDTH; x++)\n\t\t{\n\t\t\tif((*iter).i[x] != 0) is_empty = false;\n\t\t\tif((*iter).i[x] == 0) is_fill = false;\n\t\t}\n\n\t\tif(is_fill)\n\t\t{\n\t\t\tfield.erase(iter);\n\t\t\tfield.push_back(Row());\n\t\t\tcontinue;\n\t\t}\n\t\t\t\n\t\tif(is_empty) return;\n\n\t\t++iter;\n\t}\n}\n\nint countBlock()\n{\n\tint retVal = 0;\n\tfor(int y=0; y<MAX_H; y++)\n\t{\n\t\tbool is_empty = true;\n\t\tfor(int x=0; x<WIDTH; x++)\n\t\t{\n\t\t\tif(field[y].i[x] != 0)\n\t\t\t{\n\t\t\t\tis_empty = false;\n\t\t\t\tretVal++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(is_empty) break;\n\t}\n\n\treturn retVal;\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tcin >> blocks[i].d;\n\t\t\tcin >> blocks[i].p;\n\t\t\tcin >> blocks[i].q;\n\t\t\tblocks[i].q--;\n\t\t}\n\n\t\tfield = vector<Row>(MAX_H);\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tfor(int j=MAX_H-1; j>=0; j--)\n\t\t\t{\n\t\t\t\tif(!isSetOk(blocks[i], j))\n\t\t\t\t{\n\t\t\t\t\tsetBlock(blocks[i], j+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(j==0)\n\t\t\t\t{\n\t\t\t\t\tsetBlock(blocks[i], 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcheckErase();\n\t\t\t\n\t\t\t/*\n\t\t\tfor(int y=9; y>=0; y--)\n\t\t\t{\n\t\t\t\tfor(int x=0; x<WIDTH; x++)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d \", field[y].i[x]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t\t*/\n\t\t}\n\t\n\t\tprintf(\"%d\\n\", countBlock());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n){\n\t\tvector<int> board(1, (1 << 5) - 1);\n\t\tint res = 0;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint d, p, q;\n\t\t\tscanf(\"%d %d %d\", &d, &p, &q);\n\t\t\t--q;\n\t\t\t\n\t\t\tint block = 0, num;\n\t\t\tif (d == 1){\n\t\t\t\tfor (int j = 0; j < p; j++){\n\t\t\t\t\tblock |= 1 << (q + j);\n\t\t\t\t}\n\t\t\t\tnum = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tblock = 1 << q;\n\t\t\t\tnum = p;\n\t\t\t}\n\t\t\t\n\t\t\tfor (int j = 0; j < num; j++){\n\t\t\t\tfor (int h = board.size(); h > 0; h--){\n\t\t\t\t\tif (!(board[h - 1] & block)) continue;\n\t\t\t\t\tif (h == board.size()) board.push_back(0);\n\t\t\t\t\tboard[h] |= block;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tres += p;\n\t\t\tfor (int h = board.size() - 1; h > 0; h--){\n\t\t\t\tif (board[h] == (1 << 5) - 1){\n\t\t\t\t\tboard.erase(board.begin() + h);\n\t\t\t\t\tres -= 5;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dat[5000][5];\nint m[5];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<5000;i++)\n\t\t\tfor(int j=0;j<5;j++)dat[i][j]=0;\n\t\tfor(int i=0;i<5;i++)m[i]=0;\n\t\tint count=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b,c,d;\n\t\t\tscanf(\"%d%d%d\",&b,&c,&d);d--;\n\t\t\tcount+=c;\n\t\t\tif(b==2){\n\t\t\t\tfor(int i=0;i<c;i++)dat[m[d]+i][d]=1;\n\t\t\t\tm[d]+=c;\n\t\t\t}else{\n\t\t\t\tint h=0;\n\t\t\t\tfor(int i=0;i<c;i++)h=max(h,m[i+d]);\n\t\t\t\tfor(int i=0;i<c;i++)dat[h][i+d]=1;\n\t\t\t\tfor(int i=0;i<c;i++)m[i+d]=h+1;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<5000;i++){\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<5;j++)if(!dat[i][j])ok=false;\n\t\t\tif(ok)count-=5;\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int limit=5000;\n\nint main(){\n\n\tint n;\n\tchar field[limit][5];\n\twhile(cin>>n&&n!=0){\n\t\tfor(int i = 0; i < limit; i++)\n\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\tfield[i][j]='0';\n\t\tint d,p,q;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>d>>p>>q;\n\t\t\tif(d==1){\n\t\t\t\tint init=q-1;\n\t\t\t\tint at=10000000;\n\t\t\t\tfor(int j = init; j < p+init; j++){\n\t\t\t\t\tfor(int k = 0; k < limit; k++){\n\t\t\t\t\t\tif(field[k][j]=='1'){\n\t\t\t\t\t\t\tat=min(at,k-1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(k==limit-1){\n\t\t\t\t\t\t\tat=min(at,k);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// atÌÀWÌ³ÉubNð¨­\n\t\t\t\tfor(int j = init; j < p+init; j++){\n\t\t\t\t\tfield[at][j]='1';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint at=10000000;\n\t\t\t\tfor(int k = 0; k < limit; k++){\n\t\t\t\t\tif(field[k][q-1]=='1'){\n\t\t\t\t\t\tat=k-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(k==4999)\n\t\t\t\t\t\tat=k;\n\t\t\t\t}\n\t\t\t\t//ubNð¨­\n\t\t\t\tfor(int j = at; j!=at-p; j--){\n\t\t\t\t\tfield[j][q-1]='1';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ubNÌÁ\n\t\t\tfor(int j = 0; j < limit; j++){\n\t\t\t\tbool f=false;\n\t\t\t\tfor(int k = 0; k < 5; k++){\n\t\t\t\t\tif(field[j][k]!='1'){\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f){\n\t\t\t\t\tfor(int k = 0; k < 5; k++)\n\t\t\t\t\t\tfield[j][k]='0';\n\t\t\t\t\t// Á¦½sæèãÉ éubNðº\n\t\t\t\t\tfor(int k = j-1; k >= 0; k--){\n\t\t\t\t\t\tfor(int l = 0; l < 5; l++){\n\t\t\t\t\t\t\tfield[k+1][l]=field[k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//for(int j = 0; j < 10; j++){\n\t\t\t//\tfor(int k = 0; k < 5; k++){\n\t\t\t//\t\tcout<<field[j][k]<<flush;\n\t\t\t//\t}\n\t\t\t//\tcout<<endl;\n\t\t\t//}\n\t\t\t//cout<<endl;\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i = 0; i < limit; i++){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tif(field[i][j]=='1')\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/08/10 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0)\n\t\t\tbreak;\n\n\t\tint T[6000][5];\n\t\tfor(int i=0; i<5000; i++)\n\t\t\tfor(int j=0; j<5; j++)\n\t\t\t\tT[i][j] = 0;\n\t\tint I1 = 0;\n\t\tint I2 = 0;\n\n\t\tint N = 0;\n\n\t\tfor(int k=0; k<n; k++){\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d==1){\n\t\t\t\tint i;\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(i=I1-1; i>=I2; i--){\n\t\t\t\t\tfor(int j=0; j<p; j++){\n\t\t\t\t\t\tif(T[i][q-1+j]!=0){\n\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!flg)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int j=0; j<p; j++)\n\t\t\t\t\tT[i+1][q-1+j] = 1;\n\t\t\t\tif(I1<i+2)\n\t\t\t\t\tI1 = i+2;\n\t\t\t}\n\t\t\telse if(d==2){\n\t\t\t\tint i;\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(i=I1-1; i>=I2; i--){\n\t\t\t\t\tfor(int j=0; j<p; j++){\n\t\t\t\t\t\tif(T[i+j][q-1]!=0){\n\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!flg)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int j=0; j<p; j++)\n\t\t\t\t\tT[i+1+j][q-1] = 1;\n\t\t\t\tif(I1<i+1+p)\n\t\t\t\t\tI1 = i+1+p;\n\t\t\t}\n\n\t\t\tN += p;\n\n\t\t\tfor(int i=I2; i<I1; i++)\n\t\t\t\tif(T[i][0]==1&&T[i][1]==1&&T[i][2]==1&&T[i][3]==1&&T[i][4]==1){\n\t\t\t\t\tN -= 5;\n\t\t\t\t\tfor(int j=i; j<I1-1; j++){\n\t\t\t\t\t\tT[j][0] = T[j+1][0];\n\t\t\t\t\t\tT[j][1] = T[j+1][1];\n\t\t\t\t\t\tT[j][2] = T[j+1][2];\n\t\t\t\t\t\tT[j][3] = T[j+1][3];\n\t\t\t\t\t\tT[j][4] = T[j+1][4];\n\t\t\t\t\t}\n\t\t\t\t\tI1--;\n\t\t\t\t\ti--;\n\t\t\t\t}\n\n\t\t}\n/*\n\t\tfor(int i=I2; i<I1; i++){\n\t\t\tfor(int j=0; j<5; j++)\n\t\t\t\tcout << T[i][j];\n\t\t\tcout << endl;\n\t\t}\t\t\t\t\n*/\n\t\tcout << N << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint grid[5][5010];\nint n,d,p,q;\nll int ans = 0;\n\nint GetBottom(int x){\n\tREP(i,5000){\n\t\tif(grid[x][i]==-1) return i;\n\t}\n\treturn -1;\n}\n\nbool isallclear(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=-1) return false;\n\t}\n\treturn true;\n}\n\nbool isallblock(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n;\n\t\tREP(i,5) REP(j,5000) grid[i][j] = -1;\n\t\tREP(i,n){\n\t\t\tcin >> d >> p >> q;\n\t\t\tif(d==2){\n\t\t\t\tint tmp = GetBottom(q-1);\n\t\t\t\tFOR(j,tmp,tmp+p) grid[q-1][j] = 1;\n\t\t\t}else{\n\t\t\t\tint tmp = -1;\n\t\t\t\tFOR(j,q-1,q-1+p){\n\t\t\t\t\ttmp = max(tmp,GetBottom(j));\n\t\t\t\t}\n\t\t\t\tFOR(j,q-1,q-1+p) {\n\t\t\t\t\tgrid[j][tmp] = 1;\n\t\t\t\t\tREP(k,tmp) if(grid[j][k]==-1) grid[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowline = 0;\n\t\t\twhile(1){\n\t\t\t\tif(isallclear(nowline)) break;\n\t\t\t\tif(isallblock(nowline)){\n\t\t\t\t\tREP(j,5) {\n\t\t\t\t\t\t//grid[j][nowline] = 0;\n\t\t\t\t\t\tint nline = nowline+1;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tif(grid[j][nline]==-1) {\n\t\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\tnline++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tnowline++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tint line = 0;\n\t\twhile(1){\n\t\t\tif(isallclear(line)) break;\n\t\t\tREP(i,5){\n\t\t\t\tif(grid[i][line]==1) ans++;\n\t\t\t}\n\t\t\tline++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint grid[5][5010];\nint n,d,p,q;\nll int ans = 0;\n\nint GetBottom(int x){\n\tREP(i,5000){\n\t\tif(grid[x][i]==-1) return i;\n\t}\n\treturn -1;\n}\n\nbool isallclear(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=-1) return false;\n\t}\n\treturn true;\n}\n\nbool isallblock(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n;\n\t\tREP(i,5) REP(j,5000) grid[i][j] = -1;\n\t\tREP(i,n){\n\t\t\tcin >> d >> p >> q;\n\t\t\tif(d==2){\n\t\t\t\tint tmp = GetBottom(q-1);\n\t\t\t\tFOR(j,tmp,tmp+p) grid[q-1][j] = 1;\n\t\t\t}else{\n\t\t\t\tint tmp = -1;\n\t\t\t\tFOR(j,q-1,q-1+p){\n\t\t\t\t\ttmp = max(tmp,GetBottom(j));\n\t\t\t\t}\n\t\t\t\tFOR(j,q-1,q-1+p) {\n\t\t\t\t\tgrid[j][tmp] = 1;\n\t\t\t\t\tREP(k,tmp) if(grid[j][k]==-1) grid[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowline = 0;\n\t\t\twhile(1){\n\t\t\t\tif(isallclear(nowline)) break;\n\t\t\t\tif(isallblock(nowline)){\n\t\t\t\t\tREP(j,5) {\n\t\t\t\t\t\tgrid[j][nowline] = 0;\n\t\t\t\t\t\tint nline = nowline+1;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tif(grid[j][nline]==-1) break;\n\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\tnline++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnowline++;\n\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tint line = 0;\n\t\twhile(1){\n\t\t\tif(isallclear(line)) break;\n\t\t\tREP(i,5){\n\t\t\t\tif(grid[i][line]==1) ans++;\n\t\t\t}\n\t\t\tline++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <list>\n\nusing namespace std;\n\n#define inf 1e9 + 7\n\n/* \ntypedef struct Node {\n  int id;\n  int score;\n  Node *right;\n  Node *left;\n};\n*/\n\nvector<vector<int>> grid(5010, vector<int>(5, 0));\nvector<int> ma(5, 0);\n\nvoid check(int start , int end){\n  // endは含まれない\n\n  for(int i = end - 1; i >= start; i--){\n    bool vanish = true;\n    for(int j = 0; j < 5; j++){\n      if(grid[i][j] != 1){\n        vanish = false;\n        break;\n      }\n    }\n    if(vanish){\n      //cout << \"消す \" << i << \"行目\" << endl;\n      // 消す\n      for(int j = 0; j < 5; j++){\n        grid[i][j] = inf;\n        // 最大値更新\n\n        if(ma[j] == i + 1){\n\n          // 下の1まで下がる\n          for(int k = i - 1; k >= 0; k--){\n            if(grid[k][j] == 1){\n              ma[j] = k + 1;\n              break;\n            }\n            if(k == 0) ma[j] = 0; \n          }\n\n        }\n\n      }\n\n    }\n  }\n}\n\nint main(){\n\n  while(1){\n    int n;\n    cin >> n;\n    if(n == 0) break;\n\n    // 初期化\n    for(int i = 0; i < 5010; i++){\n      for(int j = 0; j < 5; j++){\n        grid[i][j] = 0;\n      }\n    }\n    for(int j = 0; j < 5; j++) ma[j] = 0;\n\n    vector<int> d(n), p(n), q(n);\n    for(int i = 0; i < n; i++) cin >> d[i] >> p[i] >> q[i];\n\n    for(int i = 0; i < n; i++){\n      if(d[i] == 1){ // 横\n        int ster = 0;\n        for(int j = q[i] - 1; j < q[i] - 1 + p[i]; j++){\n          ster = max(ster,ma[j]);\n        }\n        // sterのとこにおく\n        while(grid[ster][q[i] - 1] == inf){\n          ster++;\n        }\n        for(int j = q[i] - 1; j < q[i] - 1 + p[i]; j++){\n          grid[ster][j] = 1;\n          ma[j] = ster + 1;\n        }\n        check(ster, ster + 1);\n      }\n      else{ // 縦\n        int ster = ma[q[i] - 1];\n        while(grid[ster][q[i] - 1] == inf) ster++;\n        int cnt = 0;\n        for(int j = 0; j < p[i]; j++){\n          if(grid[ster+j+cnt][q[i] - 1] == inf){\n            cnt++;\n            j--;\n            continue;\n          }\n          grid[ster + cnt + j][q[i] - 1] = 1;\n        }\n        ma[q[i] - 1] = ster + p[i] + cnt;\n        check(ma[q[i] - 1] - p[i] - ster - cnt, ma[q[i] - 1] + cnt);\n      }\n    }\n\n    int ans = 0;\n    for(int i = 5010 - 1; i >= 0; i--){\n      for(int j = 0; j < 5; j++){\n        //cout << grid[i][j] << \" \";\n        if(grid[i][j] == 1) ans++;\n      }\n      //cout << endl;\n    }\n\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int INF = 100000000;\n\nint n;\nbool table[5000][5];\nint height[5];\nint width[5000];\nint ans;\nint d, p, q;\n\nvoid clear(){\n  bool f = false;\n  int h = -1;\n  for(int i=0;i<5;i++){\n    h = max(h, height[i]);\n  }\n  int pos = 0;\n  for(int i=0;i<h;i++){\n    if(width[i] == 5){\n      width[i] = 0;\n      ans -= 5;\n      f = true;\n      for(int j=0;j<5;j++){\n\ttable[i][j] = false;\n      }\n    }else{\n      if(i != pos){\n\tfor(int j=0;j<5;j++){\n\t  table[pos][j] = table[i][j];\n\t  table[i][j] = false;\n\t}\n\twidth[pos] = width[i];\n\twidth[i] = 0;\n      }\n      ++pos;\n    }\n  }\n  if(!f) return;\n  fill(height, height+5, 0);\n  for(int j=0;j<5;j++){\n    for(int i=0;i<5000;i++){\n      if(!table[i][j]) continue;\n      height[j] = max(height[j], i+1);\n    }\n  }\n}\n\nmain(){\n  while(cin >> n && n){\n    fill(table[0], table[5000], false);\n    fill(height, height+5, 0);\n    fill(width, width+5000, 0);\n    ans = 0;\n    for(int i=0;i<n;i++){\n      cin >> d >> p >> q;\n      --q;\n      ans += p;\n      if(d == 1){\n\tint h = -1;\n\tfor(int j=0;j<p;j++){\n\t  h = max(h, height[q+j]);\n\t}\n\tfor(int j=0;j<p;j++){\n\t  table[h][q+j] = true;\n\t  height[q+j] = h+1;\n\t}\n\twidth[h] += p;\n      }else if(d == 2){\n\tfor(int j=0;j<p;j++){\n\t  table[height[q]+j][q] = true;\n\t  ++width[height[q]+j];\n\t}\n\theight[q] += p;\n      }\n      clear();\n      /*for(int j=0;j<5;j++){\n\tcout << height[j] << ' ';\n      }\n      cout << endl;\n      for(int j=0;j<8;j++){\n\tcout << width[j] << ' ';\n      }\n      cout << endl << endl;\n      for(int i=9;i>=0;i--){\n\tfor(int j=0;j<5;j++){\n\t  cout << table[i][j];\n\t}\n\tcout << endl;\n      }\n      cout << endl;*/\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\nconst int WIDTH = 5;\nconst int BLOCK_LENGTH_MAX = 5;\n\nclass Tetoris\n{\npublic:\n\tTetoris( int num ) :\n\t\tm_numBlocks( num ),\n\t\tm_pField( NULL ),\n\t\tm_heightMax( 0 ),\n\t\tm_cellCount( 0 )\n\t{\n\t\tmemset( m_heights, 0, sizeof(m_heights) );\n\t\tm_pField = new bool[ num * BLOCK_LENGTH_MAX * WIDTH ]();\n\t\tm_pFullLine = new bool[ num * BLOCK_LENGTH_MAX ]();\n\t}\n\t~Tetoris()\n\t{\n\t\tdelete[] m_pField;\n\t\tdelete[] m_pFullLine;\n\t}\n\tvoid dropBlock( int direction, int length, int position )\n\t{\n\t\tm_cellCount += length;\n\t\tint h = 0;\n\t\tif( direction == 1 ){\n\t\t\tfor( int i = 0; i < length; ++i ){\n\t\t\t\tif( h < m_heights[ i + position ] ) h = m_heights[ i + position ];\n\t\t\t}\n\t\t\tfor( int i = 0; i < length; ++i ){\n\t\t\t\tm_pField[ h * WIDTH + i + position ] = true;\n\t\t\t\tm_heights[ i + position ] = h + 1;\n\t\t\t}\n\t\t\tif( isFilled( h ) ){\n\t\t\t\tm_pFullLine[ h ] = true;\n\t\t\t}\n\t\t\tdetectHeights( m_heightMax + 1 );\n\t\t}else{\n\t\t\th = m_heights[ position ];\n\t\t\tint up = 0;\n\t\t\tfor( int i = 0; i < length; ++i ){\n\t\t\t\twhile( m_pFullLine[ h + i + up ] ){\n\t\t\t\t\t++up;\n\t\t\t\t}\n\t\t\t\tm_pField[ ( h + i + up ) * WIDTH + position ] = true;\n\t\t\t}\n\t\t\tm_heights[ position ] += length + up;\n\t\t\tfor( int i = 0; i < length + up; ++i ){\n\t\t\t\tif( isFilled( h + i ) ){\n\t\t\t\t\tm_pFullLine[ h + i ] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdetectHeights( m_heightMax + length );\n\t\t}\n\t}\n\tbool isFilled( int h )\n\t{\n\t\tfor( int i = 0; i < WIDTH; ++i ){\n\t\t\tif( !m_pField[ h * WIDTH + i ] ){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tvoid detectHeights( int h )\n\t{\n\t\tm_heightMax = 0;\n\t\tfor( int i = 0; i < WIDTH; ++i ){\n\t\t\tint p = h;\n\t\t\twhile( p >= 0 && ( !m_pField[ p * WIDTH + i ] || m_pFullLine[ p ] ) ){\n\t\t\t\t--p;\n\t\t\t}\n\t\t\tp += 1;\n\t\t\twhile( p < m_numBlocks * BLOCK_LENGTH_MAX && m_pField[ p * WIDTH + i ] ){\n\t\t\t\t++p;\n\t\t\t}\n\t\t\tm_heights[ i ] = p;\n\t\t\tif( m_heightMax < m_heights[ i ] ){\n\t\t\t\tm_heightMax = m_heights[ i ];\n\t\t\t}\n\t\t}\n\t}\n\tint getResult()\n\t{\n\t\tint countFilledLine = 0;\n\t\tfor( int i = 0; i < m_heightMax; ++i ){\n\t\t\tif( m_pFullLine[ i ] ) ++countFilledLine;\n\t\t}\n\t\treturn m_cellCount - countFilledLine * WIDTH;\n\t}\n\tvoid outputState()\n\t{\n\t\tfor( int i = m_heightMax - 1; i >= 0; --i ){\n\t\t\tfor( int j = 0; j < WIDTH; ++j ){\n\t\t\t\tcout << ( m_pField[ i * WIDTH + j ] ? 'o' : '.' );\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << \"heights:\" << endl;\n\t\tfor( int i = 0; i < WIDTH; ++i ){\n\t\t\tcout << m_heights[ i ] << ' ';\n\t\t}\n\t\tcout << endl;\n\t\tcout << \"heightMax : \" << m_heightMax << endl << endl;\n\t}\n\nprivate:\n\tint m_numBlocks;\n\tbool* m_pField;\n\tint m_heightMax;\n\tint m_heights[ WIDTH ];\n\tbool* m_pFullLine;\n\tint m_cellCount;\n};\n\nint main()\n{\n\tint n;\n\n\twhile( cin >> n && n )\n\t{\n\t\tTetoris t( n );\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tint d, l, p;\n\t\t\tcin >> d >> l >> p;\n\t\t\tt.dropBlock( d, l, p - 1 );\n\t\t\tt.outputState();\n\t\t}\n\t\tcout << t.getResult() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint grid[5][5010];\nint n,d,p,q;\nll int ans = 0;\n\nint GetBottom(int x){\n\tREP(i,5000){\n\t\tif(grid[x][i]==-1) return i;\n\t}\n\treturn 0;\n}\n\nbool isallclear(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=-1) return false;\n\t}\n\treturn true;\n}\n\nbool isallblock(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tREP(i,5) REP(j,5000) grid[i][j] = -1;\n\t\tREP(i,n){\n\t\t\tcin >> d >> p >> q;\n\t\t\tif(d==2){\n\t\t\t\tint tmp = GetBottom(q-1);\n\t\t\t\tFOR(j,tmp,tmp+p) grid[q-1][j] = 1;\n\t\t\t}else{\n\t\t\t\tint tmp = -1;\n\t\t\t\tFOR(j,q-1,q-1+p){\n\t\t\t\t\ttmp = max(tmp,GetBottom(j));\n\t\t\t\t}\n\t\t\t\tFOR(j,q-1,q-1+p) {\n\t\t\t\t\tgrid[j][tmp] = 1;\n\t\t\t\t\tREP(k,tmp) if(grid[j][k]==-1) grid[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowline = 0;\n\t\t\twhile(1){\n\t\t\t\tif(isallclear(nowline)) break;\n\t\t\t\tif(isallblock(nowline)){\n\t\t\t\t\tREP(j,5) {\n\t\t\t\t\t\tint nline = nowline+1;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tif(grid[j][nline]==-1) {\n\t\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\tnline++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tnowline++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tint line = 0;\n\t\twhile(1){\n\t\t\tif(isallclear(line)) break;\n\t\t\tREP(i,5){\n\t\t\t\tif(grid[i][line]==1) ans++;\n\t\t\t}\n\t\t\tline++;\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\n\tint n;\n\twhile(cin>>n&&n!=0){\n\t\tchar field[10][5];\n\t\tfor(int i = 0; i < 10; i++)\n\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\tfield[i][j]='0';\n\t\tint d,p,q;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>d>>p>>q;\n\t\t\tif(d==1){\n\t\t\t\tint init=q-1;\n\t\t\t\tint at=10000000;\n\t\t\t\tfor(int j = init; j < p+init; j++){\n\t\t\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\t\t\tif(field[k][j]=='1'){\n\t\t\t\t\t\t\tat=min(at,k-1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(k==9){\n\t\t\t\t\t\t\tat=min(at,k);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// atÌÀWÌ³ÉubNð¨­\n\t\t\t\tfor(int j = init; j < p+init; j++){\n\t\t\t\t\tfield[at][j]='1';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint at=10000000;\n\t\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\t\tif(field[k][q-1]=='1'){\n\t\t\t\t\t\tat=k-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(k==9)\n\t\t\t\t\t\tat=k;\n\t\t\t\t}\n\t\t\t\t//ubNð¨­\n\t\t\t\tfor(int j = at; j!=at-p; j--){\n\t\t\t\t\tfield[j][q-1]='1';\n\t\t\t\t}\n\t\t\t}\n\t\t\tbool er=false;\n\t\t\t// ubNÌÁ\n\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\tbool f=false;\n\t\t\t\tfor(int k = 0; k < 5; k++){\n\t\t\t\t\tif(field[j][k]!='1'){\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f){\n\t\t\t\t\ter=true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++)\n\t\t\t\t\t\tfield[j][k]='0';\n\t\t\t\t\t// Á¦½sæèãÉ éubNðº\n\t\t\t\t\tfor(int k = j-1; k >= 0; k--){\n\t\t\t\t\t\tfor(int l = 0; l < 5; l++){\n\t\t\t\t\t\t\tfield[k+1][l]=field[k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//for(int l = 0; l < 5; l++){\n\t\t\t\t\t//\tint empPlace=-1;\n\t\t\t\t\t//\tfor(int k = j; k >= 0; k--){\n\t\t\t\t\t//\t\tif(field[k][l]=='1'){\n\t\t\t\t\t//\t\t\tfor(int m = k+1; m < 10; m++){\n\t\t\t\t\t//\t\t\t\tif(field[m][l]=='0'&&(m==9||field[m+1][l]=='1')){\n\t\t\t\t\t//\t\t\t\t\tfield[m][l]=='1';\n\t\t\t\t\t//\t\t\t\t\tfield[k][l]='0';\n\t\t\t\t\t//\t\t\t\t\tbreak;\n\t\t\t\t\t//\t\t\t\t}\n\t\t\t\t\t//\t\t\t}\n\t\t\t\t\t//\t\t}\n\t\t\t\t\t//\t}\n\t\t\t\t\t//}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(er){\n\n\n\t\t\t\t//// ubNÌº\n\t\t\t\t//for(int j = 0; j < 5; j++){\n\t\t\t\t//\tif(i==3&&j==3){\n\t\t\t\t//\t\t//\tcout<<endl;\n\t\t\t\t//\t}\n\t\t\t\t//\tint empPlace=-1;\n\t\t\t\t//\tfor(int k = 9; k >= 0; k--){\n\t\t\t\t//\t\tif(field[k][j]=='1'){\n\t\t\t\t//\t\t\tif(k==9){\n\t\t\t\t//\t\t\t\tcontinue;\n\t\t\t\t//\t\t\t}\n\t\t\t\t//\t\t\telse if(empPlace!=-1){\n\t\t\t\t//\t\t\t\tfield[empPlace][j]='1';\n\t\t\t\t//\t\t\t\tfield[k][j]='0';\n\t\t\t\t//\t\t\t\tempPlace=empPlace-1;\n\t\t\t\t//\t\t\t}\n\t\t\t\t//\t\t}\n\t\t\t\t//\t\telse{\n\t\t\t\t//\t\t\tif(empPlace==-1)\n\t\t\t\t//\t\t\t\tempPlace=k;\n\t\t\t\t//\t\t}\n\t\t\t\t//\t}\n\t\t\t\t//}\n\t\t\t}\n\t\t\t//for(int j = 0; j < 10; j++){\n\t\t\t//\tfor(int k = 0; k < 5; k++){\n\t\t\t//\t\tcout<<field[j][k]<<flush;\n\t\t\t//\t}\n\t\t\t//\tcout<<endl;\n\t\t\t//}\n\t\t\t//cout<<endl;\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tif(field[i][j]=='1')\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n#include <iterator>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> Pii;\ntypedef pair<ll,ll> Pll;\n \n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n\ntypedef unsigned long long ull;\nconst int INF = (int)1e8;\n\nbool t[5*1000][5];\n\nint GetUnder(int x){\n\tfor(int i = 5000-1; i >= 0; i--){\n\t\tif(t[i][x]) return i+1;\n\t}\n\treturn 0;\n}\n\nint GetUnder(int d,int p,int q){\n\tint under = -1;\n\tif(d==2){\n\t\tunder = GetUnder(q);\n\t}\n\telse {\n\t\tFOR(i,p){\n\t\t\tunder = max(under,GetUnder(q+i));\n\t\t}\n\t}\n\treturn under;\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tmemset(t,0,sizeof(t));\n\t\tFOR(i,n){\n\t\t\tint d,p,q; cin>>d>>p>>q;\n\t\t\tq--;\n\n\t\t\tint under = GetUnder(d,p,q);\n\n\t\t\tif(d==2){\n\t\t\t\tFOR(i,p) t[under+i][q] = true;\n\t\t\t} else {\n\t\t\t\tFOR(i,p) t[under][q+i] = true;\n\t\t\t}\n\n\t\t\tint c = 0;\n\t\t\tFOR(i,5000){\n\t\t\t\tif(accumulate(t[i],t[i]+5,0) == 5) continue;\n\t\t\t\tmemcpy(t[c++],t[i],5);\n\t\t\t}\n\t\t\tfor(int i = c; i < 5000; i++) FOR(j,5) t[i][j] = false;\n\t\t}\n\t\tint ans = 0;\n\t\tFOR(i,5000) FOR(j,5) ans += t[i][j];\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\tflg &= board[h_max][j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tfor(int k = h_max; k < top[j]; k++) {\n\t\t\t\t\t\t\tboard[k][j] = board[k + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\n\t\t\t\tint h = top[q - 1];\n\t\t\t\ttop[q - 1] += p;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tflg &= board[h + j][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tboard[h + j - del][k] = board[h + j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdel++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tfor(int k = h + p - del; k < top[j] + 10; k++) {\n\t\t\t\t\t\tboard[k][j] = board[k + del][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\n\t\t\tfor(int j = 0; j < 6; j++) {\n\t\t\t\tans += board[i][j];\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 10; i >= 0; i--) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tcout << (board[i][j] ? '*' : '.');\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t// */\n\t\t/*\n\t\tfor(int i = 0; i < 5; i++)\n\t\t\tcout << top[i] << \" \";\n\t\tcout << endl;\n\t\t// */\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n#define unless(p) if(!(p))\n#define until(p) while(!(p))\n\nusing ll = std::int64_t;\n\nstd::list<int> board;\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    while(true){\n        int N;\n        std::cin >> N;\n\n        if(N == 0){\n            break;\n        }\n\n        board.clear();\n\n        for(int i=0;i<N;++i){\n            int D, P, Q;\n            std::cin >> D >> P >> Q;\n\n            Q -= 1;\n\n            if(D == 1){\n                if(P == 5){\n                    continue;\n                }\n\n                int block = ((1 << P) - 1) << Q;\n\n                auto it = board.end();\n                while(it != board.begin() &&\n                      (*std::prev(it) & block) == 0){\n                    std::advance(it, -1);\n                }\n\n                if(it == board.end()){\n                    board.push_back(block);\n                }else{\n                    *it |= block;\n\n                    if(*it == 31){\n                        board.erase(it);\n                    }\n                }\n            }else{\n                auto it = board.end();\n                while(it != board.begin() &&\n                      (*std::prev(it) >> Q & 1) == 0){\n                    std::advance(it, -1);\n                }\n\n                for(int i=0;i<P;++i){\n                    if(it == board.end()){\n                        board.push_back(1 << Q);\n                    }else{\n                        *it |= 1 << Q;\n                        if(*it == 31){\n                            it = board.erase(it);\n                        }else{\n                            std::advance(it, 1);\n                        }\n                    }\n                }\n            }\n        }\n\n        int cnt = 0;\n        \n        for(int l : board){\n            cnt += __builtin_popcount(l);\n        }\n\n        std::cout << cnt << std::endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nbool map[5000][6];\nint N;\n\nvoid func(){\n\n\tint max_height = 5*N-1;\n\n\tfor(int row = 0; row <= max_height; row++){\n\t\tfor(int col = 1; col <= 5; col++){\n\t\t\tmap[row][col] = false;\n\t\t}\n\t}\n\n\tint top_pos[6] = {0,0,0,0,0,0};\n\n\tint dir,len,loc,tmp_max;\n\tstack<int> delete_row;\n\tbool FLG;\n\n\tfor(int loop = 0; loop < N; loop++){\n\t\tscanf(\"%d %d %d\",&dir,&len,&loc);\n\n\t\tif(dir == 1){\n\t\t\ttmp_max = 0;\n\t\t\tfor(int col = loc; col <= loc+len-1; col++){\n\t\t\t\ttmp_max = max(tmp_max,top_pos[col]);\n\t\t\t}\n\n\t\t\tfor(int col = loc; col <= loc+len-1; col++){\n\t\t\t\tmap[tmp_max][col] = true;\n\t\t\t\ttop_pos[col] = tmp_max+1;\n\t\t\t}\n\t\t}else{\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tmap[top_pos[loc]+i][loc] = true;\n\t\t\t}\n\t\t\ttop_pos[loc] += len;\n\t\t}\n\n\t\ttmp_max = 0;\n\t\tfor(int col = 1; col <= 5; col++){\n\t\t\ttmp_max = max(tmp_max,top_pos[col]);\n\t\t}\n\n\t\tfor(int row = 0; row <= tmp_max;row++){\n\t\t\tFLG = true;\n\t\t\tfor(int col = 1; col <= 5; col++){\n\t\t\t\tif(map[row][col] == false){\n\t\t\t\t\tFLG = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tif(FLG){\n\t\t\t\tfor(int col = 1; col <= 5; col++){\n\t\t\t\t\tmap[row][col] = false;\n\t\t\t\t}\n\t\t\t\tdelete_row.push(row);\n\t\t\t}\n\t\t}\n\n\t\twhile(!delete_row.empty()){\n\n\t\t\tfor(int col = 1; col <= 5; col++){\n\t\t\t\tfor(int row = delete_row.top()+1; row <= top_pos[col]; row++){\n\t\t\t\t\tif(map[row][col]){\n\t\t\t\t\t\tmap[row][col] = false;\n\t\t\t\t\t\tmap[row-1][col] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int row = top_pos[col]; row >= 0; row--){\n\t\t\t\t\tif(row == 0){\n\t\t\t\t\t\tif(map[row][col]){\n\t\t\t\t\t\t\ttop_pos[col] = 1;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\ttop_pos[col] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(map[row][col]){\n\t\t\t\t\t\t\ttop_pos[col] = row+1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\ttmp_max = 0;\n\t\t\tfor(int col = 1; col <= 5; col++){\n\t\t\t\ttmp_max = max(tmp_max,top_pos[col]);\n\t\t\t}\n\n\t\t\tfor(int row = 0; row <= tmp_max;row++){\n\t\t\t\tFLG = true;\n\t\t\t\tfor(int col = 1; col <= 5; col++){\n\t\t\t\t\tif(map[row][col] == false){\n\t\t\t\t\t\tFLG = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tif(FLG){\n\t\t\t\t\tfor(int col = 1; col <= 5; col++){\n\t\t\t\t\t\tmap[row][col] = false;\n\t\t\t\t\t}\n\t\t\t\t\tdelete_row.push(row);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdelete_row.pop();\n\t\t}\n\t}\n\n\tmax_height = 0;\n\tfor(int col = 1; col <= 5; col++){\n\t\tmax_height = max(max_height,top_pos[col]);\n\t}\n\n\tint ans = 0;\n\tfor(int row = 0; row <= max_height; row++){\n\t\tfor(int col = 1; col <= 5; col++){\n\t\t\tif(map[row][col]){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",ans);\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define INF 1e9\n \nint field[5000][5],tmp[5000][5];\n \nvoid down()\n{\n    memset(tmp, 0, sizeof(tmp));\n    for (int j = 0; j < 5; j++) {\n\tint p = 4999;\n\tfor (int i = 4999; i >= 0; i--) {\n\t    if (field[i][j] == -1) continue;\n\t    tmp[p--][j] = field[i][j];\n\t}\n    }\n    for (int i = 0; i < 5000; i++) {\n\tfor (int j = 0; j < 5; j++) {\n\t    field[i][j] = tmp[i][j];\n\t}\n    }\n}\n \nvoid remove()\n{\n    bool flg = false;\n    for (int i = 0; i < 5000; i++) {\n\tint cnt = 0;\n\tfor (int j = 0; j < 5; j++, cnt++) {\n\t    if (!field[i][j]) break;\n\t}\n\tif (cnt == 5) {\n\t    flg = true;\n\t    for (int j = 0; j < 5; j++) {\n\t\tfield[i][j] = -1;\n\t    }\n\t}\n    }\n   \n    if (flg) {\n\tdown();\n    }\n}\n \nint main()\n{\n    int N, d, p, q;\n \n    while (cin >> N, N) {\n\tmemset(field, 0, sizeof(field));\n\tfor (int i = 0; i < N; i++) {\n\t    cin >> d >> p >> q; q--;\n\t    if (d == 1) {\n\t\tint min = INF;\n\t\tfor (int j = q; j < p+q; j++) {\n\t\t    for (int i = 0; i < 5000; i++) {\n\t\t\tif (i == 4999 || field[i+1][j] == 1) {\n\t\t\t    min = std::min(min, i);\n\t\t\t    break;\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tfor (int j = q; j < p+q; j++) {\n\t\t    field[min][j] = 1;\n\t\t}\n\t    } else {\n\t\tfor (int i = 0; i < 5000; i++) {\n\t\t    if (i == 4999 || field[i+1][q] == 1) {\n\t\t\tfor (int j = 0; j < p; j++) {\n\t\t\t    field[i-j][q] = 1;\n\t\t\t}\n\t\t\tbreak;\n\t\t    }\n\t\t}\n\t    }\n\t    remove();\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < 5000; i++) {\n\t    for (int j = 0; j < 5; j++) {\n\t\tif (field[i][j] == 1) ans++;\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\tflg = flg && board[h_max][j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tfor(int k = h_max; k < top[j]; k++) {\n\t\t\t\t\t\t\tboard[k][j] = board[k + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\n\t\t\t\tint h = top[q - 1];\n\t\t\t\ttop[q - 1] += p;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tflg = flg && board[h + j][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tboard[h + j - del][k] = board[h + j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdel++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tfor(int k = h + p - del; k < top[j] + 10; k++) {\n\t\t\t\t\t\tboard[k][j] = board[k + del][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\n\t\t\tbool flg = true;\n\t\t\tfor(int j = 0; j < 6; j++) {\n\t\t\t\tans += board[i][j];\n\t\t\t\tflg = flg && (board[i][j] == 1);\n\t\t\t}\n\t\t\tif(flg)\n\t\t\t\tabort();\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 10; i >= 0; i--) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tcout << (board[i][j] ? '*' : '.');\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t// */\n\t\t/*\n\t\tfor(int i = 0; i < 5; i++)\n\t\t\tcout << top[i] << \" \";\n\t\tcout << endl;\n\t\t// */\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <utility>\n#include <tuple>\n#include <math.h>\n#include <iomanip>\n\nusing namespace std;\n\nclass Sover {\n};\n\nint main()\n{\n\twhile (true) {\n\t\tint n;\n\t\tcin >> n;\n\t\tif (n == 0)break;\n\n\t\tint length = n * 5 + 10;\n\t\tvector<vector<bool>> grid(length, vector<bool>(5, false));\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\t\t\tq--;\n\t\t\tint bottom = length - 1;\n\t\t\tif (d == 1) {\n\t\t\t\tfor (; bottom >= 0; bottom--) {\n\t\t\t\t\tbool interrupt = false;\n\t\t\t\t\tfor (int j = 0; j < p; j++) {\n\t\t\t\t\t\tif (grid[bottom][q+j])interrupt = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (interrupt)break;\n\t\t\t\t}\n\n\t\t\t\tfor (int j = 0; j < p; j++)grid[bottom + 1][q + j] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (bottom >= 0 && !grid[bottom][q])bottom--;\n\n\t\t\t\tfor (int j = 0; j < p; j++)grid[bottom + 1 + j][q] = true;\n\t\t\t}\n\n\t\t\tint shift_cnt = 0;\n\t\t\tfor (int j = bottom + 1; j < length; j++) {\n\t\t\t\tbool full = true;\n\t\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\t\tif (!grid[j][k]) {\n\t\t\t\t\t\tfull = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (full) {\n\t\t\t\t\tshift_cnt++;\n\t\t\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\t\t\tgrid[j][k] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\t\t\tgrid[j - shift_cnt][k] = grid[j][k];\n\t\t\t\t\t\tif (shift_cnt > 0)grid[j][k] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor (int i = 0; i < length; i++) {\n\t\t\tfor (int j = 0; j < 5; j++)if (grid[i][j])res++;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<bitset>\n\n\nusing namespace std;\n#define rep(i,n) for(int i = 0 ; i < n ; ++i)\n\n\n\nint solve(){\n    int n;\n    cin>>n;\n    if(n==0)return 0;\n    vector<int> res(5000);\n    rep(i,n){\n        int d,p,q;\n        cin>>d>>p>>q;\n        if(d==1){\n            int bit = ((1<<p)-1)<<(q-1);\n            int i = res.size();\n            while(i>0&&(res[i-1]&bit)==0)--i;\n            res[i]|=bit;\n            if(res[i]==31){\n                res.erase(res.begin()+i);\n            }\n        }\n        else {\n            int i = res.size();\n            int bit = 1<<(q-1);\n            while(i>0&&(res[i-1]&bit)==0)--i;\n            rep(j,p)res[i+j]|=bit;\n            for(int j=p-1;j>=0;--j){\n                if(res[i+j]==31)res.erase(res.begin()+i+j);\n            }\n        }\n    }\n    int ans = 0;\n    for(auto e : res){\n        ans += __builtin_popcount(e);\n    }\n    cout<<ans<<endl;\n    return 1;\n}\n\nint main(){\n    while(solve());\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n//#include <utility>\n#include <set>\n#include <iostream>\n//#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n//#include <functional>\n#include <sstream>\n//#include <deque>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n//#include <cctype>\n#include <cstring>\n//#include <ctime>\n#include <iterator>\n#include <bitset>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n#if __cplusplus >= 201103L\n#include <array>\n#include <tuple>\n#include <initializer_list>\n#include <unordered_set>\n#include <unordered_map>\n#include <forward_list>\n\n#define cauto const auto&\n#else\n\n#endif\n\nusing namespace std;\n\n\nnamespace{\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\n\nvoid mainmain(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvector<string> v(5);\n\t\trep(i,n){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tif(a==1){\n\t\t\t\tint t=0;\n\t\t\t\treep(j,c-1,b+c-1){\n\t\t\t\t\tt=max(t,(int)v[j].size());\n\t\t\t\t}\n\t\t\t\treep(j,c-1,b+c-1){\n\t\t\t\t\twhile(v[j].size()<t){\n\t\t\t\t\t\tv[j]=v[j]+\" \";\n\t\t\t\t\t}\n\t\t\t\t\tv[j]=v[j]+\"#\";\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tstring tmp=\"\";\n\t\t\t\trep(j,b){\n\t\t\t\t\ttmp=tmp+\"#\";\n\t\t\t\t}\n\t\t\t\tv[c-1]=v[c-1]+tmp;\n\t\t\t}\n\t\t\tint M=0;\n\t\t\trep(j,5){\n\t\t\t\tM=max(M,(int)v[j].size());\n\t\t\t}\n\t\t\tif(M==0) continue;\n\t\t\tfor(int j=M-1;j;j--){\n\t\t\t\tbool f=true;\n\t\t\t\trep(k,5){\n\t\t\t\t\tif(v[k][j]!='#'){\n\t\t\t\t\t\tf=false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f){\n\t\t\t\t\trep(k,5){\n\t\t\t\t\t\tv[k]=v[k].substr(0,j)+v[k].substr(j+1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\trep(i,5){\n\t\t\trep(j,v[i].size()){\n\t\t\t\tif(v[i][j]=='#') ans++;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}\n\n\n\n}\nmain() try{\n    mainmain();\n}\ncatch(...){\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int HORIZONTAL = 1;\nconst int VERTICAL   = 2;\nconst int MAX_H = 5001;\nconst int WIDTH = 5;\nconst int N_BLOCK_MAX = 1000;\n\nclass Block\n{\npublic:\n\tint d, p, q;\n\tBlock() {}\n};\n\nclass Row\n{\npublic:\n\tint i[5];\n\tRow()\n\t{\n\t\tfor(int m=0; m<5; m++) i[m] = 0;\n\t}\n};\n\nint n;\nvector<Row> field;\n\nbool isSetOk(Block b, int y)\n{\n\tif(b.d == HORIZONTAL)\n\t{\n\t\tfor(int dx=0; dx<b.p; dx++)\n\t\t{\n\t\t\tint xx = b.q + dx;\n\t\t\tif(field[y].i[xx]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\telse if(b.d == VERTICAL)\n\t{\n\t\tfor(int dy=0; dy<b.p; dy++)\n\t\t{\n\t\t\tint yy = y + dy;\n\t\t\tif(field[yy].i[b.q]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid setBlock(Block b, int y)\n{\n\tif(b.d == HORIZONTAL)\n\t{\n\t\tfor(int dx=0; dx<b.p; dx++)\n\t\t{\n\t\t\tint xx = b.q + dx;\n\t\t\tfield[y].i[xx] = 1;\n\t\t}\n\t}\n\telse if(b.d == VERTICAL)\n\t{\n\t\tfor(int dy=0; dy<b.p; dy++)\n\t\t{\n\t\t\tint yy = y + dy;\n\t\t\tfield[yy].i[b.q] = 1;\n\t\t}\n\t}\n}\n\nvoid checkErase()\n{\n\tvector<Row>::iterator iter = field.begin();\n\twhile(iter != field.end())\n\t{\n\t\tbool is_empty = true;\n\t\tbool is_fill = true;\n\t\tfor(int x=0; x<WIDTH; x++)\n\t\t{\n\t\t\tif((*iter).i[x] != 0) is_empty = false;\n\t\t\tif((*iter).i[x] == 0) is_fill = false;\n\t\t}\n\n\t\tif(is_fill)\n\t\t{\n\t\t\tfield.erase(iter);\n\t\t\tcontinue;\n\t\t}\n\t\t\t\n\t\tif(is_empty) return;\n\n\t\t++iter;\n\t}\n}\n\nint countBlock()\n{\n\tint retVal = 0;\n\tfor(int y=0; y<MAX_H; y++)\n\t{\n\t\tbool is_empty = true;\n\t\tfor(int x=0; x<WIDTH; x++)\n\t\t{\n\t\t\tif(field[y].i[x] != 0)\n\t\t\t{\n\t\t\t\tis_empty = false;\n\t\t\t\tretVal++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(is_empty) break;\n\t}\n\n\treturn retVal;\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tfield = vector<Row>(MAX_H);\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tBlock block;\n\t\t\tcin >> block.d;\n\t\t\tcin >> block.p;\n\t\t\tcin >> block.q;\n\t\t\tblock.q--;\n\n\t\t\tfor(int j=field.size()-1; j>=0; j--)\n\t\t\t{\n\t\t\t\tif(!isSetOk(block, j))\n\t\t\t\t{\n\t\t\t\t\tsetBlock(block, j+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(j==0)\n\t\t\t\t{\n\t\t\t\t\tsetBlock(block, 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcheckErase();\n\t\t\t\n/*\n\t\t\tfor(int y=9; y>=0; y--)\n\t\t\t{\n\t\t\t\tfor(int x=0; x<WIDTH; x++)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d \", field[y].i[x]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n*/\n\t\t}\t\n\t\tprintf(\"%d\\n\", countBlock());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint x[10000][5], m[5], maxn, sum;\nint n;\nint a, b, c;\nint main() {\n\twhile (true) {\n\t\tsum = 0;\n\t\tmaxn = 0;\n\t\tmemset(x, 0, sizeof(x));\n\t\tmemset(m, 0, sizeof(m));\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int h = 0; h < n; h++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tc--;\n\t\t\tif (a == 1) {\n\t\t\t\tmaxn = 0;\n\t\t\t\tfor (int j = c; j < c + b; j++) {\n\t\t\t\t\tmaxn = max(maxn, m[j]);\n\t\t\t\t}\n\t\t\t\tfor (int j = c; j < c + b; j++) {\n\t\t\t\t\tx[maxn][j] = 1;\n\t\t\t\t\tm[j] = maxn + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\t\tx[m[c] + j][c] = 1;\n\t\t\t\t}\n\t\t\t\tm[c] += b;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 10000; i++) {\n\t\t\t\tif (x[i][0] + x[i][1] + x[i][2] + x[i][3] + x[i][4] == 5) {\n\t\t\t\t\tx[i][0] = 0; x[i][1] = 0; x[i][2] = 0; x[i][3] = 0; x[i][4] = 0;\n\t\t\t\t\tfor (int j = i; j < 9999; j++) {\n\t\t\t\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tx[j][k] = x[j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx[9999][0] = 0; x[9999][1] = 0; x[9999][2] = 0; x[9999][3] = 0; x[9999][4] = 0;\n\t\t\t\t\ti--;\n\t\t\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\t\t\tfor (int k = m[j]; k >= 0; k--) {\n\t\t\t\t\t\t\tif (x[k][j] == 1) {\n\t\t\t\t\t\t\t\tm[j] = k + 1; goto E;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm[j] = 0;\n\t\t\t\t\tE:;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 10000; i++) {\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\tsum += x[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint fall(vector<vector<int>>&field, vector<vector<int>>&pino,int l) {\n\tint y = 0;\n\tfor ( y = 0; y < field.size() - pino.size(); ++y) {\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < pino.size(); ++i) {\n\t\t\tfor (int j = 0; j < pino[i].size(); ++j) {\n\t\t\t\tif (pino[i][j]) {\n\t\t\t\t\tif (field[y + i+1][l + j])ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < pino.size(); ++i) {\n\t\tfor (int j = 0; j < pino[i].size(); ++j) {\n\t\t\tif (pino[i][j]) {\n\t\t\t\tassert(!field[y + i][l + j]);\n\t\t\t\tfield[y + i][l + j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint delline = 0;\n\tfor (int i = y + pino.size() - 1; i >= y; --i) {\n\t\twhile (all_of(field[i].begin(), field[i].end(), [](const int a) {return a == 1; })) {\n\t\t\ttransform(field[i].begin(), field[i].end(), field[i].begin(), [](const int a) {return false; });\n\t\t\tfor (int j = i- 1; j >= 0; --j) {\n\t\t\t\tswap(field[j], field[j + 1]);\n\t\t\t}\n\t\t\tdelline += 1;\n\t\t}\n\t}\n\treturn delline;\n}\n\nint main() {\n\tint N;\n\twhile (cin>>N,N) {\n\t\tint sum = 0;\n\t\tvector<vector<int>>field(5*N, vector<int>(5));\n\t\twhile(N--){\n\t\t\tint d, p, q; cin >> d >> p >> q; q--;\n\t\t\tsum += p;\n\t\t\tvector<vector<int>>pino(d == 1 ? 1 : p, vector<int>(d == 2 ? 1 : p, 1));\n\t\t\tsum -= fall(field, pino, q) * 5;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n\nint n;\nbool block[5050][5];\n\nvoid down(int py) {\n\tfor_(y,py,5010) {\n\t\tfor_(x,0,5) {\n\t\t\tblock[y][x] = block[y + 1][x];\n\t\t\tblock[y + 1][x] = false;\n\t\t}\n\t}\n}\n\nvoid vanish() {\n\tfor_(y,0,5050) {\n\t\tbool van = true;\n\t\t\n\t\tfor_(x,0,5) van &= block[y][x];\n\t\t\n\t\tif (van) {\n\t\t\tdown(y);\n\t\t\t--y;\n\t\t}\n\t}\n}\n\nvoid fall(int dir, int len, int lft) {\n\tint by = 5010, bx = lft;\n\t\n\twhile (by > 0) {\n\t\tbool end = false;\n\t\t\n\t\tif (dir) {\n\t\t\tend |= block[by - 1][bx];\n\t\t} else {\n\t\t\tfor_(x,bx,bx+len) end |= block[by - 1][x];\n\t\t}\n\t\t\n\t\tif (end) break;\n\t\t\n\t\t--by;\n\t}\n\t\n\tif (dir) {\n\t\tfor_(y,by,by+len) block[y][bx] = true;\n\t} else {\n\t\tfor_(x,bx,bx+len) block[by][x] = true;\n\t}\n}\n\nvoid play() {\n\tfor_(i,0,n) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\tfall(--a, b, --c);\n\t\tvanish();\n\t}\n\t\n\tint ans = 0;\n\tfor_(y,0,5050) for_(x,0,5) ans += block[y][x];\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tmemset(block, false, sizeof(block));\n\t\tplay();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// * template\n\n#include <bits/stdc++.h>\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\ntemplate<class T, class U> inline void fill_array(T &e, const U &v) { e = v; }\ntemplate<class T, class U, size_t s> inline void fill_array(T (&a)[s], const U &v) {for(auto&e:a)fill_array(e,v);}\ntemplate<class T, class U, size_t s> inline void fill_array(array<T, s> &a, const U &v) {for(auto&e:a)fill_array(e,v);}\ntemplate<class T, class U> inline void fill_array(vector<T> &a, const U &v) {for(auto&e:a)fill_array(e,v);}\n\nstruct range {\n\ttypedef int Int;\n\tstruct iter {\n\t\tInt i;\n\t\tconst Int s;\n\t\tconstexpr iter(const Int &i_, const Int &s_):i(i_), s(s_) {}\n\t\tconstexpr bool operator!=(const iter &r) const { return s > 0 ? i < r.i : i > r.i; }\n\t\tconstexpr const Int &operator*() const { return i; }\n\t\titer &operator++() { i += s; return *this; }\n\t};\n\tconst Int f, l, s;\n\tconstexpr range(const Int &f_, const Int &l_, const Int &s_):f(f_), l(l_), s(s_) {}\n\tconstexpr range(const Int &f_, const Int &l_):f(f_), l(l_), s(1) {}\n\tconstexpr range(const Int &num):f(0), l(num), s(1) {}\n\tconstexpr iter begin() const { return iter(f, s); }\n\tconstexpr iter end() const { return iter(l, s); }\n};\n\n// * solve\n\nconstexpr int MAX_NUM_BLOCK = 1000;\nconstexpr int MAX_BLOCK_SIZE = 5;\nconstexpr int WIDTH = 5;\n\nbool field[MAX_NUM_BLOCK * MAX_BLOCK_SIZE + 1][WIDTH];\nint next_pos[WIDTH];\n\nvoid drop_block() {\n\tstatic constexpr int dx[] = {0, 1, 0};\n\tstatic constexpr int dy[] = {0, 0, 1};\n\n\tint d, p, q;\n\tcin >> d >> p >> q;\n\n\tint x = q - 1;\n\tint y = (d == 1 ? *max_element(begin(next_pos) + x, begin(next_pos) + x + p) : next_pos[x]);\n\n\tfor(int i : range(p)) {\n\t\tfield[y][x] = true;\n\t\tchmax(next_pos[x], y + 1);\n\n\t\tx += dx[d];\n\t\ty += dy[d];\n\t}\n}\n\nint calc_score() {\n\tconst int h = *max_element(begin(next_pos), end(next_pos));\n\n\tint res = 0;\n\tfor(int i : range(h)) {\n\t\tconst int cnt = count(begin(field[i]), end(field[i]), true);\n\t\tif(cnt < WIDTH) res += cnt;\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tmemset(field, false, sizeof(field));\n\t\tmemset(next_pos, 0, sizeof(next_pos));\n\n\t\tfor(int i : range(n)) {\n\t\t\tdrop_block();\n\t\t}\n\n\t\tcout << calc_score() << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nint fall(vector<vector<int>>&field, vector<vector<int>>&pino,int l) {\n\t{\n\n\t}\n\tint y = 0;\n\tfor ( y = 0; y < field.size() - pino.size(); ++y) {\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < pino.size(); ++i) {\n\t\t\tfor (int j = 0; j < pino[i].size(); ++j) {\n\t\t\t\tif (pino[i][j]) {\n\t\t\t\t\tif (field[y + i+1][l + j])ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < pino.size(); ++i) {\n\t\tfor (int j = 0; j < pino[i].size(); ++j) {\n\t\t\tif (pino[i][j]) {\n\t\t\t\tassert(!field[y + i][l + j]);\n\t\t\t\tfield[y + i][l + j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint delline = 0;\n\tfor (int i = y + pino.size() - 1; i >= y; --i) {\n\t\twhile (all_of(field[i].begin(), field[i].end(), [](const int a) {return a == 1; })) {\n\t\t\ttransform(field[i].begin(), field[i].end(), field[i].begin(), [](const int a) {return false; });\n\t\t\tfor (int j = i- 1; j >= 0; --j) {\n\t\t\t\tswap(field[j], field[j + 1]);\n\t\t\t}\n\t\t\tdelline += 1;\n\t\t}\n\t}\n\treturn delline;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tint sum = 0;\n\t\tvector<vector<int>>field(10, vector<int>(5));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint d, p, q; cin >> d >> p >> q; q--;\n\t\t\tint w = d == 2 ? 1 : p;\n\t\t\tint h = d == 1 ? 1 : p;\n\t\t\tsum += p;\n\t\t\tvector<vector<int>>pino(h, vector<int>(w, 1));\n\t\t\tsum -= fall(field, pino, q) * 5;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tint E[15]{};\n\t\trep(i, n) {\n\t\t\tint d, p, q; scanf(\"%d%d%d\", &d, &p, &q); q--;\n\t\t\tif (d == 1) {\n\t\t\t\trep(i, p)E[q + i]++;\n\t\t\t}\n\t\t\telse E[q] += p;\n\t\t\tint Min = *min_element(E, E + 5);\n\t\t\trep(i, 5)E[i] -= Min;\n\t\t}\n\t\tprintf(\"%d\\n\", accumulate(E, E + 5, 0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\n#define chmax(a,x) a=max(a,x)\n\nvector<bool> F[5];\n\nbool eraser(int idx) {\n  \n  rep(i, 5) {\n    if((int)F[i].size() <= idx) { return false; }\n    if(!F[i][idx]) { return false; }\n  }\n  \n  rep(i, 5)\n    F[i].erase(F[i].begin()+idx);\n  \n  rep(i, 5) {\n    while(1) {\n      if(!F[i].empty() && !F[i].back()) { F[i].pop_back(); }\n      else { break; }\n    }\n  }\n  \n  return true;\n}\n\nint main() {\n  \n  for(int N; cin>>N && N;) {\n    rep(i, 5) F[i].clear();\n    rep(i, N) {\n      int type, len, pos; cin >> type >> len >> pos; pos --;\n      if(type == 1) {\n\tint mx = -1;\n\tREP(i, pos, pos+len) { chmax(mx, int(F[i].size())); }\n\tREP(i, pos, pos+len) {\n\t  REP(j, F[i].size(), mx) {\n\t    F[i].push_back(false);\n\t  }\n\t  F[i].push_back(true);\n\t}\n\teraser(mx);\n      }\n      else {\n\trep(i, len) { F[pos].push_back(true); }\n\tint cnt = 0;\n\trep(i, len) { if(!eraser((int)F[pos].size()-1-cnt)) cnt++; }\n      }\n    }\n    int sum = 0;\n    rep(i, 5) rep(j, F[i].size()) sum += F[i][j];\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n#define UNDER 10000\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint t[UNDER+10][5], n;\n\nint count(){\n  int res = 0;\n  rep(i, UNDER) rep(j, 5) if(t[i][j] == 1) res++;\n  return res;\n}\n\nvoid deleteblock(){\n  for(int y = UNDER-1; y >= 0; y--){\n    int f = 0;\n    rep(i, 5) if(t[y][i] == 0){ f = 1; break;}\n    if(f) continue;\n    rep(i, 5){\n      for(int c = y; c > 0; c--){\n\tt[c][i] = t[c-1][i];\n      }\n    }\n    t[0][0] = t[0][1] = t[0][2] = t[0][3] = t[0][4] = 0;\n    y++;\n  }\n  return;\n}\n\nint main(){\n  while(scanf(\"%d\", &n) && n){\n    int d, p, q;\n    memset(t, 0, sizeof(t));\n    rep(i, 5) t[UNDER][i] = 1;\n\n    rep(i, n){\n      scanf(\"%d%d%d\", &d, &p, &q); q--;\n      if(d == 1){\n\tREP(y, 1, UNDER+1){\n\t  int f = 0;\n\t  REP(x, q, q+p) if(t[y][x] == 1) f = 1;\n\t  if(!f) continue;\n\t  REP(x, q, q+p) t[y-1][x] = 1;\n\t  break;\n\t}\n      }else{\n\trep(y, UNDER+1){\n\t  if(!t[y][q]) continue;\n\t  for(int c = y-1; c > y-p-1; c--) t[c][q] = 1;\n\t  break;\n\t}\n      }\n      deleteblock();\n      /*      REP(i, 990, UNDER+1){\n\trep(j, 5) printf(\"%d \", t[i][j]); puts(\"\");\n\t}*/\n    }\n\n    printf(\"%d\\n\", count());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define N 10020\nusing namespace std;\nint main(){\n  while(true){\n    int n;\n    int ans=0;\n    scanf(\"%d\",&n);\n\n    if(n==0)break;\n    int row[N]={0,};\n    int h[5]={0,};\n    for(int i = 0; i < n; ++i){\n      int mh = 0;\n      int d,p,q;\n      scanf(\"%d%d%d\", &d, &p, &q);\n      --q;\n      \n      if(d==1){\n\tint maxh = 0;\n\tfor(int j = q; j < q + p; ++j){\n\t  maxh = max( maxh, h[j] );\n\t}\n\tfor(int j = q; j < q + p; ++j){\n\t  h[j] = maxh + 1;\n\t}\n\trow[maxh]+=p;\n      }else{\n\tfor(int j = h[q]; j < p + h[q]; ++j){\n\t  row[ j ]++;\n\t}\n\th[q]+=p;\n      }\n\n      // cout << \" DROPPED : \" << i << endl;\n      for(int j = 0; j < 5; ++j){\n\tmh = max( mh , h[j] );\n      }\n\n      for(int j = 0; j < mh; ++j){\n\t// cout << \" row[\"<<j<<\"] = \" << row[j] << endl;\n\tif( row[j] == 5 ){\n\t  for(int k = 0; k < 5; ++k){\n\t    --h[k];\n\t  }\n\t  for(int k = j; k < mh+2; ++k){\n\t    row[k] = row[k + 1];\n\t  }\n\t  j = -1;\n\t  continue;\n\t}\n      }\n    }\n    for(int i = 0; i < N; ++i){\n      ans += row[i];\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvvi field(5000,vi(5));\n\t\tvi top(5);\n\t\trep(i,n){\n\t\t\tint d,p,q; cin>>d>>p>>q;\n\t\t\tif(d==1){\n\t\t\t\tint t=*max_element(top.begin()+q-1,top.begin()+q-1+p);\n\t\t\t\trep(i,p){\n\t\t\t\t\tfield[t][q-1+i]=1;\n\t\t\t\t\ttop[q-1+i]=t+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\trep(i,p)\n\t\t\t\t\tfield[top[q-1]+i][q-1]=1;\n\t\t\t\ttop[q-1]+=p;\n\t\t\t}\n\t\t}\n\t\tint res=0;\n\t\trep(i,field.size())\n\t\t\tres+=count(allof(field[i]),1)%5;\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n\tint n, d, p, q, s, t;\n\t\n\twhile(cin>>n&&n){\n\t\tvector<bool> vec[5];\n\t\t\n\t\twhile(n--){\n\t\t\tcin >> d >> p >> q;\n\t\t\tq--;\n\t\t\tif(d == 1){\n\t\t\t\tt = -1;\n\t\t\t\tfor(int i = q, k = 0; k < p; i++, k++){\n\t\t\t\t\tfor(int j = vec[i].size()-1; j >= 0; j--){\n\t\t\t\t\t\tif(vec[i][j]){\n\t\t\t\t\t\t\tt = max(t, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = q, k = 0; k < p; i++, k++){\n\t\t\t\t\twhile(vec[i].size() < (t+1)){\n\t\t\t\t\t\tvec[i].push_back(false);\n\t\t\t\t\t}\n\t\t\t\t\tvec[i].push_back(true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tt = -1;\n\t\t\t\tfor(int i = vec[q].size()-1; i >= 0; i--){\n\t\t\t\t\tif(vec[q][i]){\n\t\t\t\t\t\tt = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts = 0;\n\t\t\t\tfor(int i = t+1; i < vec[q].size() && s < p; i++, s++){\n\t\t\t\t\tvec[q][i] = true;\n\t\t\t\t}\n\t\t\t\tfor(;s < p; s++){\n\t\t\t\t\tvec[q].push_back(true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tt = vec[0].size();\n\t\t\tfor(int i = 1; i < 5; i++){\n\t\t\t\ts = vec[i].size();\n\t\t\t\tt = min(s, t);\n\t\t\t}\n\n\t\t\tfor(int i = t-1; i >= 0; i--){\n\t\t\t\tbool f = true;\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\tif(!vec[j][i]){\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(f){\n\t\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\t\tvec[j].erase((vec[j].begin()+i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tt = 0;\n\t\tfor(int i = 0; i < 5; i++){\n\t\t\tfor(int j = 0; j < vec[i].size(); j++){\n\t\t\t\tif(vec[i][j]){\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << t << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define YOKO 1\n#define TATE 2\n\nusing namespace std;\n\nstruct B{\n\tint d;\t// ubNÌü«@(1: ¡ü« 2: cü« )\n\tint p;\t// ubNÌ·³  (1  d  5 )\n\tint q;\t// ubNÌÊu@(1  p  5 ¡ü«ÌêÍ¶[ÌR}ª¿éÊu )\n};\n\nconst int Hight = 5001;\nconst int Width = 5;\n\nbool f[Hight][Width];\n\n// cÁ½ubNðJEg\nint count_block (void )\n{\n\tint res = 0;\n\n\tfor (int i = 0; i < Hight; i++ ){\n\t\tfor (int j = 0; j < Width; j++ ){\n\t\t\tif (f[i][j] )\n\t\t\t\tres++;\n\t\t} // end for\n\t} // end for\n\n\treturn res;\n}\n\n// ubNªlÜÁÄ¢éCðÁ·\nvoid del_block (int n )\n{\n\tfor (int i = n + 1; i < Hight; i++ ){\n\t\tfor (int j = 0; j < Width; j++ ){\n\t\t\tf[i-1][j] = f[i][j];\n\t\t} // end for\n\t} // end for\n}\n\nvoid is_all_row (void ) // ·×ÄubNªÜÁÄ¢éCðÁ·\n{\n\tbool found = false;\n\tdo{\n\t\tfound = false;\n\t\tfor (int i = 0; i < Hight; i++ ){\n\t\t\tint sum = 0;\n\t\t\tfor (int j = 0; j < Width; j++ ){\n\t\t\t\tif (f[i][j] ){\n\t\t\t\t\t++sum;\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t\tif (sum == Width ){\n\t\t\t\tdel_block (i );\n\t\t\t\tfound = true;\n\t\t\t\tbreak;\t\t\t\n\t\t\t} // end if\n\t\t} // end for\n\t}while (found );\n}\n\n// row,colÌêÌãÌÊuªJ¢Ä¢é©Ç¤©Ì`FbN\nbool check_tate (int row, int col )\n{\n\tfor (int i = row; i < Hight; i++ ){\n\t\tif (f[i][col] )\n\t\t\treturn false;\n\t} // end for\n\n\treturn true;\n}\n\nint main()\n{\n\tint n;\n\n\twhile (cin >> n && n ){\n\t\tmemset (f, false, sizeof(f ) );\n\t\tvector <B> b (n );\n\t\tfor (int i = 0; i < n; i++ ){\n\t\t\tcin >> b[i].d >> b[i].p >> b[i].q;\n\t\t\tb[i].q--;\n\t\t}// end for\n\t\n\t\tfor (int i = 0; i < n; i++ ){\n\t\t\tint curr = 0;\n\t\t\tbool found = false; // »ÌÊuÉæqª é©Ç¤©\n\t\t\tdo{\n\t\t\t\tfound = false;\t\n\t\t\t\tfor (int j = b[i].q; j < b[i].q + b[i].p; j++ ){\n\t\t\t\t\tif (!check_tate (curr, j ) ){\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} // end if\n\t\t\t\t\tif (!f[curr][j] ){\n\t\t\t\t\t\tif (b[i].d == TATE ){\t// cü«ÌêAê¾¯ÅOK\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}else{ \n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t} // end if\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} // end if\n\t\t\t\t} // end for\n\t\t\t\tif (!found ){\n\t\t\t\t\tif (b[i].d == YOKO ){\t// ¡ü«Ìê\n\t\t\t\t\t\tfor (int j = b[i].q; j < b[i].q + b[i].p; j++ ){\n\t\t\t\t\t\t\tf[curr][j] = true;\n\t\t\t\t\t\t} // end for\n\t\t\t\t\t}else{\t\t\t\t\t// cü«Ìê\n\t\t\t\t\t\tfor (int j = 0; j < b[i].p; j++ ){\n\t\t\t\t\t\t\tf[curr+j][b[i].q] = true;\n\t\t\t\t\t\t} // end for \t\t\t\t\t\t\n\t\t\t\t\t} // end if\n\t\t\t\t}else{\n\t\t\t\t\tcurr++;\t// ²¸·ésðâ·\n\t\t\t\t} // end if\n\t\t\t}while (found );\n\t\t\tis_all_row ();\t// ·×ÄÌCªlÜÁÄ¢é©`FbN\n\t\t} // end for\n\n\t\tint res = count_block();\n\t\tcout << res << endl;\n\t} // end loop\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#ifdef _WIN32\n#define __builtin_popcount __popcnt\n#endif\nint n, d, p, q;\nint main() {\n\twhile (cin >> n, n) {\n\t\tvector<int> bit;\n\t\tvector<int> c(5);\n\t\twhile (n--) {\n\t\t\tcin >> d >> p >> q; q--;\n\t\t\tif (d == 1) {\n\t\t\t\tint r = *max_element(c.begin() + q, c.begin() + q + p);\n\t\t\t\tint b = (1 << (q + p)) - (1 << q);\n\t\t\t\tif (bit.size() == r) bit.push_back(b);\n\t\t\t\telse bit[r] |= b;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = c[q]; i < c[q] + p; i++) {\n\t\t\t\t\tif (bit.size() == i) bit.push_back(1 << q);\n\t\t\t\t\telse bit[i] |= 1 << q;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<int> bit2;\n\t\t\tfor (int i : bit) {\n\t\t\t\tif (i != 31) bit2.push_back(i);\n\t\t\t}\n\t\t\tbit = bit2;\n\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\tc[i] = 0;\n\t\t\t\tfor (int j = bit2.size() - 1; j >= 0; j--) {\n\t\t\t\t\tif (bit2[j] & (1 << i)) {\n\t\t\t\t\t\tc[i] = j + 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i : bit) ret += __builtin_popcount(i);\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint x[1000][5], m[5], maxn, sum;\nint n;\nint a, b, c;\nint main() {\n\twhile (true) {\n\t\tsum = 0;\n\t\tmemset(x, 0, sizeof(x));\n\t\tmemset(m, 0, sizeof(m));\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int h = 0; h < n; h++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tc--;\n\t\t\tif (a == 1) {\n\t\t\t\tmaxn = 0;\n\t\t\t\tfor (int j = c; j < c + b; j++) {\n\t\t\t\t\tmaxn = max(maxn, m[j]);\n\t\t\t\t}\n\t\t\t\tfor (int j = c; j < c + b; j++) {\n\t\t\t\t\tx[maxn][j] = 1;\n\t\t\t\t\tm[j] = maxn + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\t\tx[m[c] + j][c] = 1;\n\t\t\t\t}\n\t\t\t\tm[c] += b;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\t\tif (x[i][0] + x[i][1] + x[i][2] + x[i][3] + x[i][4] == 5) {\n\t\t\t\t\tx[i][0] = 0; x[i][1] = 0; x[i][2] = 0; x[i][3] = 0; x[i][4] = 0;\n\t\t\t\t\tfor (int j = i; j < 999; j++) {\n\t\t\t\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tx[j][k] = x[j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx[999][0] = 0; x[999][1] = 0; x[999][2] = 0; x[999][3] = 0; x[999][4] = 0;\n\t\t\t\t\ti--;\n\t\t\t\t\tm[0]--; m[1]--; m[2]--; m[3]--; m[4]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\tsum += x[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long Long;\n#define Whole(xs) xs.begin(), xs.end()\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& vs) {\n    if (vs.empty()) return os << \"[]\";\n    os << \"[\" << vs[0];\n    for (int i = 0; i < vs.size(); i++) os << \" \" << vs[i];\n    return os << \"]\";\n}\nostream& operator<<(ostream& os, const vector<int>& vs) {\n    if (vs.empty()) return os << \"[]\";\n    bool flag = false;\n    os << \"[\";\n    for (int i = 0; i < vs.size(); i++) {\n        if (flag) {\n            os << \" \";\n        } else {\n            flag = true;\n        }\n        for (int j = 0; j < 5; j++) {\n            os << ( (vs[i] & (1 << j)) > 0 );\n        }\n    }\n    return os << \"]\";\n}\n\nconst int IINF = 1<<28;\nconst Long LINF = 1LL<<56;\n#define INF IINF\n\nint N;\nvector<int> F;\nbool Input() {\n    cin >> N;\n    if (N == 0 || cin.eof()) return false;\n    F.clear();\n    return true;\n}\n\nvoid WSet(int Q, int P) {\n    int R = 0;\n    for (int i = Q; i < Q + P; i++) {\n        R ^= (1 << i);\n    }\n    if (F.empty()) {\n        F.push_back(R);\n    } else{\n        if ((F.back() & R) == 0) {\n            for (int i = F.size() - 1; i >= -1; i--) {\n                if ( i < 0 || (F[i] & R) > 0 ) {\n                    F[i + 1] ^= R;\n                    break;\n                }\n            }\n        } else {\n            F.push_back(R);\n        }\n    }\n}\n\nvoid HSet(int Q, int P) {   \n    if (F.empty()) {\n        for (int i = 0; i < P; i++) {\n            F.push_back(1 << Q);\n        }\n        return;\n    }\n    int Rem = P;\n    for (int i = F.size() - 1; i >= -1; i--) {\n        if (i < 0 || F[i] & (1 << Q)) {\n            for (int j = i + 1; Rem > 0 && j < F.size(); j++) {\n                Rem--;\n                F[j] ^= (1 << Q);\n            }\n            break;\n        }\n    }\n    for (int i = 0; i < Rem; i++) {\n        F.push_back(1 << Q);\n    }\n}\n\nvoid Fall() {\n    vector<int> nF;\n    for (int i = 0; i < F.size(); i++) {\n        if (F[i] != (1 << 5) - 1) {\n            nF.push_back(F[i]);\n        }\n    }\n    F = nF;\n}\n\nvoid Solve() {\n    for (int n = 0; n < N; n++) {\n        int D, P, Q; cin >> D >> P >> Q;\n        Q--;\n        if (D == 1) {\n            WSet(Q, P);\n        } else {\n            HSet(Q, P);\n        }\n        Fall();\n    }\n    int Ans = 0;\n    for (int i = 0; i < F.size(); i++) {\n        for (int j = 0; j < 5; j++) {\n            if (F[i] & (1 << j)) {\n                Ans++;\n            }\n        }\n    }\n    cout << Ans << endl;\n}\n\nint main() {\n    while (Input()) {\n        Solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n  \nusing namespace std;\n  \nconst int Height = 5100;\nconst int Width = 5;\nchar field[Height][Width];\nint top,ans;\nint dx[] = {1,0};\nint dy[] = {0,-1};\n  \nvoid print(int h, int w){\n  \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl; \n}\n\nbool isInside(int h, int w){ return 0<=h&&h<Height&&0<=w&&w<Width;}\n\nint getH(int d, int len, int pos){\n  for(int i = top+10; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?' || !isInside(h,w)) return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n}\n \nvoid down(int n){\n  \n  for(int i = n; i <= top+6; i++)\n    for(int j = 0; j < Width; j++) field[i][j] = field[i+1][j];\n  // top--;\n}\n \nvoid erase(){\n \n  while(1){\n    bool update = false;\n    for(int i = 0; i <= top+6; i++){\n      bool f = true;\n      for(int j = 0; j < Width; j++) if(field[i][j] == '?') f = false;\n      if(f){\n\tupdate = true;\n\tans -= 5;\n\tdown(i--);\n      }\n    }\n    if(!update) break;\n  }\n}\n  \nvoid put(int d, int len, int pos){\n  \n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n  \n  int h = nex;\n  int w = pos;\n  \n  for(int i = 0; i < len; i++){\n    field[h][w] = '.';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n  \nint main(){\n  \n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    ans = top = 0;\n     \n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      ans += len;\n      put(d-1,len,pos-1);\n      erase();\n    }\n    cout << ans << endl;\n    //   print(10,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define N 10020\nusing namespace std;\nint main(){\n  while(true){\n    int n;\n    int ans=0;\n    scanf(\"%d\",&n);\n\n    if(n==0)break;\n    int row[N]={0,};\n    int h[5]={0,};\n    for(int i = 0; i < n; ++i){\n      int mh = 0;\n      int d,p,q;\n      scanf(\"%d%d%d\", &d, &p, &q);\n      --q;\n      \n      if(d==1){\n\tint maxh = 0;\n\tfor(int j = q; j < q + p; ++j){\n\t  maxh = max( maxh, h[j] );\n\t}\n\tfor(int j = q; j < q + p; ++j){\n\t  h[j] = maxh + 1;\n\t}\n\trow[maxh]+=p;\n      }else{\n\tfor(int j = h[q]; j < p + h[q]; ++j){\n\t  row[ j ]++;\n\t}\n\th[q]+=p;\n      }\n\n      // cout << \" DROPPED : \" << i << endl;\n      for(int j = 0; j < 5; ++j){\n\tmh = max( mh , h[j] );\n      }\n\n      for(int j = 0; j < mh; ++j){\n\t// cout << \" row[\"<<j<<\"] = \" << row[j] << endl;\n\tif( row[j] == 5 ){\n\t  for(int k = 0; k < 5; ++k){\n\t    --h[k];\n\t  }\n\t  for(int k = j; k < mh; ++k){\n\t    row[k] = row[k + 1];\n\t  }\n\t  j = -1;\n\t  continue;\n\t}\n      }\n    }\n    for(int i = 0; i < N; ++i){\n      ans += row[i];\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n \nusing namespace std;\n \nconst int Height = 5500;\nconst int Width = 5;\nchar field[Height][Width];\nint top,ans;\nint dx[] = {1,0};\nint dy[] = {0,-1};\n \n \nvoid print(int h, int w){\n \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl;\n     \n}\nbool isInside(int h, int w){return 0<=h&&h<Height&&0<=w&&w<Width;}\n \nint getH(int d, int len, int pos){\n  for(int i = top+5; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?' || !isInside(h,w)) return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n}\n\nvoid down(int n){\n\n  for(int i = n; i <= top+5; i++)\n    for(int j = 0; j < Width; j++) field[i][j] = field[i+1][j];\n\n}\n\nvoid erase(){\n\n  for(int i = 0; i <= top; i++){\n    bool f = true;\n    for(int j = 0; j < Width; j++) if(field[i][j] == '?') f = false;\n    if(f){\n      ans -= 5;\n      down(i);\n      i--;\n    }\n  }\n}\n \nvoid put(int d, int len, int pos){\n \n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n \n  int h = nex;\n  int w = pos;\n \n  for(int i = 0; i < len; i++){\n    field[h][w] = '.';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n \nint main(){\n \n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    ans = top = 0;\n    \n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      ans += len;\n      put(d-1,len,pos-1);\n      erase();\n    }\n    cout << ans << endl;\n    print(10,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n \nusing namespace std;\n \nconst int Height = 5010;\nconst int Width = 5;\nchar field[Height][Width];\nint top,ans;\nint dx[] = {1,0};\nint dy[] = {0,-1};\n \n \nvoid print(int h, int w){\n \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl;\n     \n}\nbool isInside(int h, int w){return 0<=h&&h<Height&&0<=w&&w<Width;}\n \nint getH(int d, int len, int pos){\n  for(int i = top+1; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?' || !isInside(h,w)) return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n}\n\nvoid down(int n){\n  top--;\n  for(int i = n; i <= top+1; i++)\n    for(int j = 0; j < Width; j++) field[i][j] = field[i+1][j];\n\n}\n\nvoid erase(){\n\n  for(int i = 0; i <= top+1; i++){\n    bool f = true;\n    for(int j = 0; j < Width; j++) if(field[i][j] == '?') f = false;\n    if(f){\n      ans -= 5;\n      down(i--);\n    }\n  }\n}\n \nvoid put(int d, int len, int pos){\n \n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n \n  int h = nex;\n  int w = pos;\n \n  for(int i = 0; i < len; i++){\n    field[h][w] = '.';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n \nint main(){\n \n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    ans = top = 0;\n    \n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      ans += len;\n      put(d-1,len,pos-1);\n      erase();\n    }\n    cout << ans << endl;\n    print(5,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n\nusing namespace std;\n\n#define int long long\n\nlist<bool*> fld;\n\nlist<bool*>::iterator GetHeight(int l, int r)\n{\n\tlist<bool*>::iterator itr = fld.begin();\n\tfld.push_front((bool*)new bool[5]{});\n\tfor (; itr != fld.end(); itr++)\n\t{\n\t\tfor (int j = l; j < r; j++)\n\t\t{\n\t\t\tif ((*itr)[j] == true) return --itr;\n\t\t}\n\t}\n\treturn --itr;\n}\n\nbool IsFull(list<bool*>::iterator itr)\n{\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif ((*itr)[i] == false) return false;\n\t}\n\treturn true;\n}\n\nbool IsEmpty(list<bool*>::iterator itr)\n{\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif ((*itr)[i] == true) return false;\n\t}\n\treturn true;\n}\n\nvoid Drop(int d, int p, int q)\n{\n\tif (!IsEmpty(fld.begin())) fld.push_front((bool*)new bool[5]{});\n\tint l = q - 1, r = (d == 1) ? l + p : l + 1;\n\tlist<bool*>::iterator itr = GetHeight(l, r);\n\n\tint h = (d == 1) ? 1 : p;\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tif (itr == fld.begin()) fld.push_front((bool*)new bool[5]{});\n\t\tfor (int j = l; j < r; j++)\n\t\t{\n\t\t\t(*itr)[j] = true;\n\t\t}\n\t\tif (IsFull(itr))\n\t\t{\n\t\t\tdelete *itr;\n\t\t\titr = fld.erase(itr);\n\t\t}\n\t\titr--;\n\t}\n}\n\nsigned main()\n{\n\tint N;\n\twhile (cin >> N, N)\n\t{\n\t\tfld.clear();\n\t\tfor (int i = 0; i < 2; i++) fld.push_back((bool*)new bool[5]{});\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\t\t\tDrop(d, p, q);\n\t\t}\n\t\tint ans = 0;\n\t\tfor (list<bool*>::iterator itr = fld.begin(); itr != fld.end(); itr++)\n\t\t{\n\t\t\tfor (int i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tans += ((*itr)[i] == true);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvvi field(5000,vi(5));\n\t\tvi top(5);\n\t\trep(k,n){\n\t\t\tint d,p,q; cin>>d>>p>>q;\n\t\t\tif(d==1){\n\t\t\t\tint t=*max_element(top.begin()+q-1,top.begin()+q-1+p);\n\t\t\t\trep(i,p){\n\t\t\t\t\tfield[t][q-1+i]=1;\n\t\t\t\t\ttop[q-1+i]=t+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\trep(i,p)\n\t\t\t\t\tfield[top[q-1]+i][q-1]=1;\n\t\t\t\ttop[q-1]+=p;\n\t\t\t}\n\t\t\t\n\t\t\tint cnt=0;\n\t\t\trep(i,field.size()){\n\t\t\t\tif(count(allof(field[i]),1)<5)\n\t\t\t\t\tfield[i-cnt]=field[i];\n\t\t\t\telse\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t\t\n\t\t\trepi(i,*max_element(allof(top))-cnt,field.size())\n\t\t\t\tfield[i]=vi(5);\n\t\t\tfill(allof(top),0);\n\t\t\trep(i,field.size())\n\t\t\t\trep(j,5)\n\t\t\t\t\tif(field[i][j])\n\t\t\t\t\t\ttop[j]=i+1;\n\t\t}\n\t\tint res=0;\n\t\trep(i,field.size())\n\t\t\tres+=count(allof(field[i]),1)%5;\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\tflg &= (bool)board[h_max][j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tfor(int k = h_max; k < top[j]; k++) {\n\t\t\t\t\t\t\tboard[k][j] = board[k + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\n\t\t\t\tint h = top[q - 1];\n\t\t\t\ttop[q - 1] += p;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tflg &= (bool)board[h + j][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tboard[h + j - del][k] = board[h + j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdel++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tfor(int k = h + p - del; k < top[j] + 10; k++) {\n\t\t\t\t\t\tboard[k][j] = board[k + del][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\n\t\t\tfor(int j = 0; j < 6; j++) {\n\t\t\t\tans += board[i][j];\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 10; i >= 0; i--) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tcout << (board[i][j] ? '*' : '.');\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t// */\n\t\t/*\n\t\tfor(int i = 0; i < 5; i++)\n\t\t\tcout << top[i] << \" \";\n\t\tcout << endl;\n\t\t// */\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint n;\n\ntypedef struct Block\n{\n\tint d;\n\tint p;\n\tint q;\n} B;\n\nint F[5005][5];\nint H[5];\n\nB blocks[1000];\n\nint highest(int r, int l)\n{\n\tint max = 0;\n\tfor(int i=r; i<l; i++)\n\t{\n\t\tif(max < H[i])\n\t\t{\n\t\t\tmax =H[i];\n\t\t}\n\t}\n\treturn max;\n}\n\nvoid yoko_set(B b)\n{\n\tint hp = highest(b.q, b.p+b.q);\n\tfor(int i=b.q; i<b.p+b.q; i++)\n\t{\n\t\tF[hp][i] =1;\n\t\tH[i] = hp+1;\n\t}\n}\n\nvoid tate_set(B b)\n{\n\tint hp = H[b.q];\n\tfor(int i=hp; i<hp+b.p; i++)\n\t{\n\t\tF[i][b.q] = 1;\n\t}\n\tH[b.q] = hp+b.p;\n}\n\nvoid col_clear()\n{\n\t\n\tint hp = highest(0, 5);\n\tbool is_ok = false;\n\tvector<int> cols;\n\tfor(int i=0; i<=hp; i++)\n\t{\n\t\tis_ok =true;\n\t\tfor(int j=0; j<5; j++)\n\t\t{\n\t\t\tif(F[i][j]==1) continue;\n\t\t\tis_ok = false;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(is_ok)\n\t\t{\n\t\t\tcols.push_back(i);\n\t\t}\n\t}\n\t\n\tif(cols.empty()) return;\n\t\n\tint c = 0;\n\tfor(int i=0; i<hp; i++)\n\t{\n\t\tif(cols[c]==i)\n\t\t{\n\t\t\tc++;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int j=0; j<5; j++)\n\t\t{\n\t\t\tF[i-c][j] = F[i][j];\n\t\t}\n\t}\n\t\n\tfor(int i=hp-cols.size(); i<hp; i++)\n\t{\n\t\tfor(int j=0; j<5; j++)\n\t\t{\n\t\t\tF[i][j] = 0;\n\t\t}\n\t}\n\t\n\tfor(int j=0; j<5; j++)\n\t{\n\t\tint max = -1;\n\t\tfor(int i=0; i<hp; i++)\n\t\t{\n\t\t\tif(F[i][j]==1)\n\t\t\t{\n\t\t\t\tmax = i;\n\t\t\t}\n\t\t}\n\t\tH[j] = max+1;\n\t}\n}\n\nvoid print()\n{\n\tfor(int i=0; i<10; i++)\n\t{\n\t\tfor(int j=0; j<5; j++)\n\t\t{\n\t\t\tcout << F[9-i][j] << \" \";\n\t\t}\n\t\tcout <<endl;\n\t}\n\tcout << endl;\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tcin >> blocks[i].d;\n\t\t\tcin >> blocks[i].p;\n\t\t\tcin >> blocks[i].q;\n\t\t\tblocks[i].q--;\n\t\t}\n\t\t\n\t\tmemset(&F[0][0], 0, sizeof(int)*25000);\n\t\tmemset(&H[0], 0, sizeof(int)*5);\n\t\t\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tif(blocks[i].d == 2)\n\t\t\t{\n\t\t\t\ttate_set(blocks[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tyoko_set(blocks[i]);\n\t\t\t}\n\t\t\t\n\t\t\tcol_clear();\n\t\t\t\n\t\t\t//print();\n\t\t}\n\t\t\n\t\tint hp = highest(0, 5);\n\t\tint c = 0;\n\t\tfor(int i=0; i<hp; i++)\n\t\t{\n\t\t\tfor(int j=0; j<5; j++)\n\t\t\t{\n\t\t\t\tif(F[i][j]==1) c++;\n\t\t\t}\n\t\t}\n\t\tcout << c<< endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint grid[5][5010];\nint n,d,p,q;\nll int ans = 0;\n\nint GetBottom(int x){\n\tREP(i,5000){\n\t\tif(grid[x][i]==-1) return i;\n\t}\n\treturn -1;\n}\n\nbool isallclear(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=-1) return false;\n\t}\n\treturn true;\n}\n\nbool isallblock(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n;\n\t\tREP(i,5) REP(j,5000) grid[i][j] = -1;\n\t\tREP(i,n){\n\t\t\tcin >> d >> p >> q;\n\t\t\tif(d==2){\n\t\t\t\tint tmp = GetBottom(q-1);\n\t\t\t\tFOR(j,tmp,tmp+p) grid[q-1][j] = 1;\n\t\t\t}else{\n\t\t\t\tint tmp = -1;\n\t\t\t\tFOR(j,q-1,q-1+p){\n\t\t\t\t\ttmp = max(tmp,GetBottom(j));\n\t\t\t\t}\n\t\t\t\tFOR(j,q-1,q-1+p) {\n\t\t\t\t\tgrid[j][tmp] = 1;\n\t\t\t\t\tREP(k,tmp) if(grid[j][k]==-1) grid[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowline = 0;\n\t\t\twhile(1){\n\t\t\t\tif(isallclear(nowline)) break;\n\t\t\t\tif(isallblock(nowline)){\n\t\t\t\t\tREP(j,5) {\n\t\t\t\t\t\t//grid[j][nowline] = 0;\n\t\t\t\t\t\tint nline = nowline+1;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tif(grid[j][nline]==-1) {\n\t\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\tnline++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tnowline++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tint line = 0;\n\t\twhile(1){\n\t\t\tif(isallclear(line)) break;\n\t\t\tREP(i,5){\n\t\t\t\tif(grid[i][line]==1) ans++;\n\t\t\t}\n\t\t\tline++;\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define N 10020\nusing namespace std;\nint main(){\n  while(true){\n    int n;\n    int ans=0;\n    scanf(\"%d\",&n);\n\n    if(n==0)break;\n    int row[N]={0,};\n    int h[5]={0,};\n    for(int i = 0; i < n; ++i){\n      int mh = 0;\n      int d,p,q;\n      scanf(\"%d%d%d\", &d, &p, &q);\n      --q;\n      \n      if(d==1){\n\tint maxh = 0;\n\tfor(int j = q; j < q + p; ++j){\n\t  maxh = max( maxh, h[j] );\n\t}\n\tfor(int j = q; j < q + p; ++j){\n\t  h[j] = maxh + 1;\n\t}\n\trow[maxh]+=p;\n      }else{\n\tfor(int j = h[q]; j < p + h[q]; ++j){\n\t  ++row[ j ];\n\t}\n\th[q]+=p;\n      }\n\n      // cout << \" DROPPED : \" << i << endl;\n      for(int j = 0; j < 5; ++j){\n\tmh = max( mh , h[j] );\n      }\n\n      for(int j = 0; j < mh; ++j){\n\t// cout << \" row[\"<<j<<\"] = \" << row[j] << endl;\n\tif( row[j] == 5 ){\n\t  for(int k = 0; k < 5; ++k){\n\t    --h[k];\n\t    if(h[k]<0)h[k]=0;\n\t  }\n\t  for(int k = j; k < mh+2; ++k){\n\t    row[k] = row[k + 1];\n\t  }\n\t  j = -1;\n\t  continue;\n\t}\n      }\n    }\n    for(int i = 0; i < N; ++i){\n      ans += row[i];\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define N 10020\nusing namespace std;\nint main(){\n  while(true){\n    int n;\n    int ans=0;\n    scanf(\"%d\",&n);\n\n    if(n==0)break;\n    int row[N]={0,};\n    int h[5]={0,};\n    short M[5][N]={{0,},};\n    \n    for(int i = 0; i < n; ++i){\n      int mh = 0;\n      int d,p,q;\n      scanf(\"%d%d%d\", &d, &p, &q);\n      --q;\n      \n      if(d==1){\n\tint maxh = 0;\n\tfor(int j = q; j < q + p; ++j){\n\t  maxh = max( maxh, h[j] );\n\t}\n\tfor(int j = q; j < q + p; ++j){\n\t  h[j]=maxh+1;\n\t  M[j][maxh]=1;\n\t}\n\trow[maxh]+=p;\n      }else{\n\tfor(int j = h[q]; j < p + h[q]; ++j){\n\t  ++row[ j ];\n\t  M[q][j]=1;\n\t}\n\th[q]+=p;\n      }\n\n      for(int j = 0; j < 5; ++j){\n\tmh = max( mh , h[j] );\n      }\n\n      /*\n      for(int j = mh; j >= 0; --j){\n\tfor(int k = 0; k < 5; ++k){\n\t  cout << M[k][j];\n\t}\n\tcout << endl;\n      }\n      cout << endl;\n      */\n      for(int j = 0; j < mh+1; ++j){\n\tif( row[j] == 5 ){\n\t  for(int k = j; k < mh+2; ++k){\n\t    row[k] = row[k+1];\n\t    for(int l = 0; l < 5; ++l){\n\t      M[l][k] = M[l][k+1];\n\t    }\n\t  }\n\t  j = -1;\n\t}\n      }\n\n      for(int j = 0; j < 5; ++j){\n\tfor(int k = 0; k < mh+3; ++k){\n\t  if( M[j][k] ){\n\t    h[j] = k+1;\n\t  }\n\t}\n      }\n      \n    }\n    for(int i = 0; i < 5; ++i){\n      for(int j = 0; j < N; ++j){\n\tif( M[i][j] )\n\t  ans++;\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar stage[2][5000][5];\n\nint main()\n{\n    int n;\n    \n    while (scanf(\"%d\", &n) && n){\n        int height[5] = {0};\n        int turn = 0;\n        int ct = 0;\n        memset(stage, 0, sizeof(stage));\n        for (int rep = 0; rep < n; rep++){\n            int d, p, q;\n            scanf(\"%d %d %d\", &d, &p, &q); --q;\n            if (d == 1){\n                int mh = *max_element(height + q, height + p + q);\n                for (int j = q; j < p + q; j++){\n                    stage[turn][mh][j] = 1;\n                    height[j] = mh + 1;\n                }\n            }\n            else {\n                for (int j = 0; j < p; j++){\n                    stage[turn][height[q]++][q] = 1;\n                }\n            }\n            \n            int look = *max_element(height, height + 5);\n            //memset(stage[1 - turn], 0, sizeof(stage[1 - turn]));\n            memset(height, 0, sizeof(height));\n            ct = 0;\n            int nh = 0;\n            for (int i = 0; i < look; i++){\n                bool ok = true;\n                for (int j = 0; j < 5; j++){\n                    if (stage[turn][i][j] == 0) ok = false;\n                }\n                if (!ok){\n                    for (int j = 0; j < 5; j++){\n                        stage[1 - turn][nh][j] = stage[turn][i][j];\n                        if (stage[1 - turn][nh][j]){\n                            height[j] = nh + 1;\n                            ct++;\n                        }\n                    }\n                    nh++;\n                }\n            }\n            turn = 1 - turn;\n        }\n        \n        printf(\"%d\\n\", ct);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\nusing namespace std;\n\nbool field[5000][5];\nint top[5];\n\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tmemset(field, 0, sizeof(field));\n\t\tmemset(top, 0, sizeof(top));\n\n\t\twhile (n--)\n\t\t{\n\t\t\tint d, p, q;\n\t\t\tscanf(\"%d %d %d\", &d, &p, &q);\n\t\t\t--q;\n\n\t\t\tint width = d == 1 ? p : 1;\n\t\t\tint pos = -1;\n\t\t\tfor (int i = 5000-1; pos == -1; --i)\n\t\t\t\tfor (int j = 0; j < width; ++j)\n\t\t\t\t\tif (field[i][q + j] || i == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tpos = i + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\tif (d == 1)\n\t\t\t\tfor (int i = 0; i < p; ++i)\n\t\t\t\t\tfield[pos][q + i] = true;\n\t\t\telse\n\t\t\t\tfor (int i = 0; i < p; ++i)\n\t\t\t\t\tfield[pos + i][q] = true;\n\n\t\t\twhile (true)\n\t\t\t{\n\t\t\t\tbool vanished = false;\n\t\t\t\tfor (int i = 0; i < 5000; ++i)\n\t\t\t\t{\n\t\t\t\t\tint j;\n\t\t\t\t\tfor (j = 0; j < 5 && field[i][j]; ++j)\n\t\t\t\t\t\t;\n\t\t\t\t\tif (j == 5)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (j = 0; j < 5; ++j)\n\t\t\t\t\t\t\tfield[i][j] = false;\n\t\t\t\t\t\tvanished |= true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!vanished)\n\t\t\t\t\tbreak;\n\n\t\t\t\tint diff = 0;\n\t\t\t\tfor (int i = 0; i < 5000; ++i)\n\t\t\t\t{\n\t\t\t\t\tint j;\n\t\t\t\t\tfor (j = 0; j < 5 && !field[i][j]; ++j)\n\t\t\t\t\t\t;\n\t\t\t\t\tif (j == 5)\n\t\t\t\t\t\t++diff;\n\t\t\t\t\telse if (diff)\n\t\t\t\t\t\tfor (int j = 0; j < 5; ++j)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfield[i - diff][j] = field[i][j];\n\t\t\t\t\t\t\tfield[i][j] = false;\n\t\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < 5000; ++i)\n\t\t\tfor (int j = 0; j < 5; ++j)\n\t\t\t\tif (field[i][j])\n\t\t\t\t\t++ans;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nint ban[5010][5];\nint d,p,q;\n\nvoid clear(int h){\n\tint i,j;\n\tbool no;\n\tfor(i=0;i<(d==1?1:p);i++){\n\t\tno=true;\n\t\tfor(j=0;j<5;j++){\n\t\t\tif(ban[h+i][j]==0)no=false;\n\t\t}\n\t\tif(no){\n\t\t\tint k;\n\t\t\tfor(k=h+i+1;k<5010;k++){\n\t\t\t\tfor(j=0;j<5;j++){\n\t\t\t\t\tban[k-1][j]=ban[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\ti--;\n\t\t}\n\t}\n}\n\nint fall(){\n\tint i,j;\n\tif(d==2){\n\t\tfor(i=5005;i>=0;i--){\n\t\t\tif(ban[i][q])break;\n\t\t}\n\t\ti++;\n\t\tfor(j=0;j<p;j++){\n\t\t\tban[i+j][q]=1;\n\t\t}\n\t}else{\n\t\tfor(i=5005;i>=0;i--){\n\t\t\tfor(j=0;j<p;j++){\n\t\t\t\tif(ban[i][q+j])goto aaa;\n\t\t\t}\n\t\t}\n\t\taaa:;\n\t\ti++;\n\t\tfor(j=0;j<p;j++){\n\t\t\tban[i][q+j]=1;\n\t\t}\t\t\n\t}\n\treturn i;\n}\n\nint main() {\n\tint n;\n\twhile(n=in()){\n\t\tmemset(ban,0,sizeof(ban));\n\t\tint i;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>d>>p>>q;\n\t\t\tq--;\n\t\t\tclear(fall());\n//\t\t\tint x,y;\n//\t\t\tfor(y=10;y>=0;y--){\n//\t\t\t\tfor(x=0;x<5;x++){\n//\t\t\t\t\tcout<<ban[y][x];\n//\t\t\t\t}\n//\t\t\t\tcout<<endl;\n//\t\t\t}\n//\t\t\tcout<<endl;\n\t\t}\n\t\tint j;\n\t\tint res=0;\n\t\tfor(i=0;i<5010;i++){\n\t\t\tfor(j=0;j<5;j++){\n\t\t\t\tif(ban[i][j])res++;\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint grid[5][5010];\nint n,d,p,q;\nll int ans = 0;\n\nint GetBottom(int x){\n\tREP(i,5000){\n\t\tif(grid[x][i]==-1) return i;\n\t}\n\treturn 0;\n}\n\nbool isallclear(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=-1) return false;\n\t}\n\treturn true;\n}\n\nbool isallblock(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n;\n\t\tREP(i,5) REP(j,5000) grid[i][j] = -1;\n\t\tREP(i,n){\n\t\t\tcin >> d >> p >> q;\n\t\t\tif(d==2){\n\t\t\t\tint tmp = GetBottom(q-1);\n\t\t\t\tFOR(j,tmp,tmp+p) grid[q-1][j] = 1;\n\t\t\t}else{\n\t\t\t\tint tmp = -1;\n\t\t\t\tFOR(j,q-1,q-1+p){\n\t\t\t\t\ttmp = max(tmp,GetBottom(j));\n\t\t\t\t}\n\t\t\t\tFOR(j,q-1,q-1+p) {\n\t\t\t\t\tgrid[j][tmp] = 1;\n\t\t\t\t\tREP(k,tmp) if(grid[j][k]==-1) grid[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowline = 0;\n\t\t\twhile(1){\n\t\t\t\tif(isallclear(nowline)) break;\n\t\t\t\tif(isallblock(nowline)){\n\t\t\t\t\tREP(j,5) {\n\t\t\t\t\t\tint nline = nowline+1;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tif(grid[j][nline]==-1) {\n\t\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\tnline++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tnowline++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tint line = 0;\n\t\twhile(1){\n\t\t\tif(isallclear(line)) break;\n\t\t\tREP(i,5){\n\t\t\t\tif(grid[i][line]==1) ans++;\n\t\t\t}\n\t\t\tline++;\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\nint main() {\n\tint i,j,n,a,b,c,d,e,f,g,m[10000];\n\twhile(cin >> n) {\n\t\tif (n==0) break;\n\t\tfor (j=0;j<10000;j++) m[j]=0; d=0;\n\t\tfor (i=0;i<n;i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tf=a >1 ? 1 << (c-1) : ((1 << b)-1)  << (c-1);  \n\t\t\tfor (j=d;j>=0;j--) if ( m[j]+f != (m[j] | f)) break;\n\t\t\te=g=j+1;\n\t\t\tif (a==1) { m[e]+=f; d++;}  else for (j=0;j<b;j++) { m[e+j]+=f; d+=b;}\n\t\t\tfor (j=g; j<g+d+1; j++) if (m[j]<31) m[e++]=m[j];\n\t\t}\n\t\tf=0;\n\t\tfor (i=0;i<5000;i++) for (j=0;j<5;j++) f+=(m[i] & ( 1 << j))>0;\n\t\tcout << f << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nvoid solve()\n{\n\tbool isUsed[5002][5];\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tfor (int i = 1; i < 5002; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 5; ++j)\n\t\t\t{\n\t\t\t\tisUsed[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 5; ++i)\n\t\t{\n\t\t\tisUsed[0][i] = true;\n\t\t}\n\t\tint highest = 1;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\t\t\t--q;\n\t\t\tint level = 0;\n\t\t\tif (d == 1)\n\t\t\t{\n\t\t\t\tbool isOK = true;\n\t\t\t\twhile (isOK)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < p; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (isUsed[highest - level][q + j])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tisOK = false;\n\t\t\t\t\t\t\t--level;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++level;\n\t\t\t\t}\n\t\t\t\t--level;\n\t\t\t\tfor (int j = 0; j < p; ++j)\n\t\t\t\t{\n\t\t\t\t\tisUsed[highest - level][q + j] = true;\n\t\t\t\t}\n\t\t\t\thighest = max(highest, highest - level + 1);\n\t\t\t}\n\t\t\telse if (d == 2)\n\t\t\t{\n\t\t\t\twhile (!isUsed[highest - level][q])\n\t\t\t\t{\n\t\t\t\t\t++level;\n\t\t\t\t}\n\t\t\t\t--level;\n\t\t\t\tfor (int j = 0; j < p; ++j)\n\t\t\t\t{\n\t\t\t\t\tisUsed[highest - level + j][q] = true;\n\t\t\t\t}\n\t\t\t\thighest = max(highest, highest - level + p);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 1; i < highest; ++i)\n\t\t{\n\t\t\tint rowCount = 0;\n\t\t\tfor (int j = 0; j < 5; ++j)\n\t\t\t{\n\t\t\t\tif (isUsed[i][j])\n\t\t\t\t{\n\t\t\t\t\t++ans;\n\t\t\t\t\t++rowCount;\n\t\t\t\t}\n\t\t\t\tif (rowCount == 5)\n\t\t\t\t{\n\t\t\t\t\tans -= 5;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\tflg &= board[h_max][j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tboard[h_max][j] = 0;\n\t\t\t\t\t\tfor(int k = h_max + 1; k < top[j]+10; k++) {\n\t\t\t\t\t\t\tboard[k - 1][j] = board[k][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\n\t\t\t\tint h = top[q - 1];\n\t\t\t\ttop[q - 1] += p;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tflg &= board[h + j][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++)\n\t\t\t\t\t\t\tboard[h + j - del][k] = board[h + j + 1][k];\n\t\t\t\t\t\tdel++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tfor(int k = h + p - del; k < top[j]; k++) {\n\t\t\t\t\t\tboard[k][j] = board[k + del][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 10; i >= 0; i--) {\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tcout << (board[i][j] ? '*' : '.');\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t// */\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\n\t\t\tfor(int j = 0; j < 6; j++) {\n\t\t\t\tans += board[i][j];\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nint n;\nint h[7];\nbool m[6010][7];\nint b[1010][5];\n\nint main()\n{\n    while (true)\n    {\n        cin >> n;\n        if (n == 0)\n            break;\n        for (int i = 0; i < 5500; i++)\n        {\n            for (int j = 0; j < 7; j++)\n                m[i][j] = false;\n        }\n        for (int i = 0; i <= 6; i++)\n        {\n            h[i] = 0;\n        }\n        int ans = 0;\n        for (int i = 0; i < n; i++)\n        {\n            for (int j = 0; j < 3; j++)\n            {\n                cin >> b[i][j];\n                if (j == 1)\n                {\n                    ans += b[i][j];\n                }\n            }\n        }\n        for(int i = 0;i < n;i++){\n            if(b[i][0] == 1){\n                int hmax = h[b[i][2]];\n                for(int j = 0;j < b[i][1];j++){\n                    hmax = max(hmax,h[b[i][2]+j]);\n                }\n                hmax++;\n                for(int j = 0;j < b[i][1];j++){\n                    h[b[i][2]+j] = hmax;\n                    m[hmax][b[i][2]+j] = true;\n                }\n            }else{\n                int hmax = h[b[i][2]];\n                for(int j = 1;j <= b[i][1];j++){\n                    m[hmax+j][b[i][2]] = true;\n                }\n                h[b[i][2]] = hmax + b[i][1];\n            }\n            int hmax = h[1];\n            for(int j = 1;j <= 5;j++) hmax = max(hmax,h[j]);\n            set<int> s;\n            for(int j = 1;j <= hmax;j++){\n                int count = 0;\n                for(int k = 1;k <= 5;k++)if(m[j][k] == true)count++;\n                if(count == 5){\n                    ans -= 5;\n                    s.insert(j);\n                }\n            }\n            int nj = 1;\n            for(int j = 1;j <= hmax;j++){\n                if( s.find(j) != s.end() )continue;\n                for(int k = 1;k <= 5;k++){\n                    m[nj][k] = m[j][k];\n                }\n                nj++;\n            }\n            for(int j = nj;j < 5050;j++){\n                for(int k = 1;k <= 5;k++)m[j][k] = false;\n            }\n            for(int j = 1;j <= 5;j++){\n                h[j] = 0;\n                for(int k = hmax;k >= 0;k--){\n                    if(m[k][j] == true){\n                        h[j] = k;\n                        break;\n                    }\n                }\n            }\n        }\n        int hmax = h[1];\n        for(int j = 1;j <= 5;j++) hmax = max(hmax,h[j]);\n        for(int j = hmax;j >= 1;j--){\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint main()\n{\n\tint n;\n\twhile(cin >> n && n)\n\t{\n\t\tvector<vector<int> > a;\n\t\trep(i,5001)\n\t\t{\n\t\t\tvector<int> temp(5);\n\t\t\trep(j,5) temp[j] = 0;\n\n\t\t\ta.push_back(temp);\n\t\t}\n\n\t\tint d,p,q,ans = 0;\n\t\t\n\t\trep(i,n)\n\t\t{\n\t\t\tcin >> d >> p >> q;\n\t\t\tq--;\n\t\t\tif(d == 1)\n\t\t\t{\n\t\t\t\tint ny = 5000;\n\t\t\t\t\n\t\t\t\twhile(true)\n\t\t\t\t{\n\t\t\t\t\tbool flag = true;\n\t\t\t\t\tREP(j,q,q+p)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a[ny][j] != 0) flag = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(flag) \n\t\t\t\t\t{\n\t\t\t\t\t\tif(ny == 0) break;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tbool flag_2 = true;\n\t\t\t\t\t\t\tREP(j,q,q+p)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(a[ny-1][j] != 0) flag_2 = false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(!flag_2) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tny--;\n\t\t\t\t}\n\n\t\t\t\tREP(j,q,q+p)\n\t\t\t\t{\n\t\t\t\t\ta[ny][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if(d == 2)\n\t\t\t{\n\t\t\t\tint ny = 5000;\n\n\t\t\t\twhile(true)\n\t\t\t\t{\n\t\t\t\t\tbool flag = true;\n\n\t\t\t\t\tfor(int j=ny;j>ny-p;j--)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(a[j][q] != 0) flag = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(flag) \n\t\t\t\t\t{\n\t\t\t\t\t\tif(ny-p+1 == 0) break;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\t\n\t\t\t\t\t\t\tbool flag_2 = true;\n\n\t\t\t\t\t\t\tfor(int j=ny-1;j>ny-1-p;j--)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(a[j][q] != 0) flag_2 = false;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif(!flag_2) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tny--;\n\t\t\t\t}\n\n\t\t\t\tfor(int j=ny;j>ny-p;j--)\n\t\t\t\t{\n\t\t\t\t\ta[j][q] = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trep(j,a.size())\n\t\t\t{\n\t\t\t\tbool flag = true;\n\n\t\t\t\trep(k,5)\n\t\t\t\t{\n\t\t\t\t\tif(a[j][k] != 1) flag = false;\n\t\t\t\t}\n\n\t\t\t\tif(flag) \n\t\t\t\t{\n\t\t\t\t\ta.erase(a.begin() + j);\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\trep(j,5001) rep(k,5) if(a[j][k] == 1) ans++;\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n\nusing namespace std;\n\nint MapData[5001][6];\nint N;\n\n\nvoid solveHori(int len, int pos) {\n\tbool findFirstSquare;\n\n\tfor (int row = 5000; row > -1; --row) {\n\t\tfindFirstSquare = false;\n\t\tfor (int j = 0; j < len; ++j) {\n\t\t\tif (MapData[row][pos+j] == 1) {\n\t\t\t\tfindFirstSquare = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (!findFirstSquare) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = 0; j < len; ++j) {\n\t\t\tMapData[row+1][pos + j] = 1;\n\t\t}\n\t\treturn;\n\t}\n\tfor (int j = 0; j < len; ++j) {\n\t\tMapData[0][pos + j] = 1;\n\t}\n}\n\nvoid solveVert(int len, int pos) {\n\tbool findFirstSquare;\n\n\tfor (int row = 5000; row > -1; --row) {\n\t\tfindFirstSquare = false;\n\t\tif (MapData[row][pos] == 1) {\n\t\t\tfindFirstSquare = true;\n\t\t}\n\t\tif (!findFirstSquare) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (int j = 0; j < len; ++j) {\n\t\t\tMapData[row + 1 + j][pos] = 1;\n\t\t}\n\t\treturn;\n\t}\n\tfor (int j = 0; j < len; ++j) {\n\t\tMapData[j][pos] = 1;\n\t}\n}\n\nvoid modifyMapData(int row) {\n\n\tfor (int i = row; i < 5000; i++) {\n\t\tfor (int j = 1; j < 6; j++) {\n\t\t\tMapData[i][j] = MapData[i + 1][j];\n\t\t}\n\t}\n\t\n}\n\nvoid earseMapdata() {\n\tint cntZero, cntOne;\n\t\n\tfor (int row = 0; row < 5001; ++row) {\n\t\tcntZero = cntOne = 0;\n\t\tfor (int col = 1; col < 6; ++col) {\n\t\t\tif (MapData[row][col] == 1) {\n\t\t\t\t++cntOne;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t++cntZero;\n\t\t\t}\n\t\t}\n\t\tif (cntZero == 5) {\n\t\t\treturn;\n\t\t}\n\t\tif (cntOne == 5) {\n\t\t\tmodifyMapData(row);\n\t\t\t--row;\n\t\t}\n\t}\n}\n\nint main() {\n\tint d, p, q, cnt;\n\n\twhile (cin >> N, N) {\n\t\tmemset(MapData, 0, sizeof(MapData));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif (d == 1) {\n\t\t\t\t//横向き\n\t\t\t\tsolveHori(p, q);\n\t\t\t}\n\t\t\telse if (d == 2) {\n\t\t\t\t//縦向き\n\t\t\t\tsolveVert(p, q);\n\t\t\t}\n\t\t\tearseMapdata();\n\t\t}\n\t\tcnt = 0;\n\t\tfor (int row = 0; row < 5000; ++row) {\n\t\t\tfor (int col = 1; col < 6; ++col) {\n\t\t\t\tif (MapData[row][col] == 1) {\n\t\t\t\t\t++cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\tflg = flg && board[h_max][j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tfor(int k = h_max; k < top[j]; k++) {\n\t\t\t\t\t\t\tboard[k][j] = board[k + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\n\t\t\t\tint h = top[q - 1];\n\t\t\t\ttop[q - 1] += p;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tflg = flg && board[h + j][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tboard[h + j - del][k] = board[h + j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdel++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tfor(int k = h + p - del; k < top[j] + 10; k++) {\n\t\t\t\t\t\tboard[k][j] = board[k + del][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\n\t\t\tfor(int j = 0; j < 6; j++) {\n\t\t\t\tans += board[i][j];\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 10; i >= 0; i--) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tcout << (board[i][j] ? '*' : '.');\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t// */\n\t\t/*\n\t\tfor(int i = 0; i < 5; i++)\n\t\t\tcout << top[i] << \" \";\n\t\tcout << endl;\n\t\t// */\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <ctime>\nusing namespace std;\n\nint main(){\n\tclock_t c1 = clock();\n\tint s = 0, n;\n\twhile(scanf(\"%d\", &n), n){\n\t\ts += n;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%*d%*d%*d\");\n\t\t}\n\t}\n\t\n\tclock_t c2 = c1 + CLOCKS_PER_SEC * (s / 100000.0);\n\twhile(clock() < c2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n  \nusing namespace std;\n  \nconst int Height = 5100;\nconst int Width = 5;\nchar field[Height][Width];\nint top,ans;\nint dx[] = {1,0};\nint dy[] = {0,-1};\n  \nvoid print(int h, int w){\n  \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl; \n}\n\nbool isInside(int h, int w){ return 0<=h&&h<Height&&0<=w&&w<Width;}\n\nint getH(int d, int len, int pos){\n  for(int i = top+10; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?' || !isInside(h,w)) return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n  return 0;\n}\n \nvoid down(int n){\n  \n  for(int i = n; i <= top+6; i++)\n    for(int j = 0; j < Width; j++) field[i][j] = field[i+1][j];\n  // top--;\n}\n \nvoid erase(){\n \n  for(int i = 0; i <= top+6; i++){\n    bool f = true;\n    for(int j = 0; j < Width; j++) if(field[i][j] == '?') f = false;\n    if(f){\n      ans -= 5;\n      down(i--);\n    }\n  }\n}\n  \nvoid put(int d, int len, int pos){\n  \n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n  \n  int h = nex;\n  int w = pos;\n  \n  for(int i = 0; i < len; i++){\n    field[h][w] = '.';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n  \nint main(){\n  \n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    ans = top = 0;\n     \n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      ans += len;\n      put(d-1,len,pos-1);\n      erase();\n    }\n    cout << ans << endl;\n    //  print(10,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\n//const int N = 6000;\nconst int N = 10;\nbool block[N][5];\n\n\nvoid output(){\n  cout <<\"Begin\"<<endl;\n  rep(i,10){\n    rep(j,5){\n      cout << block[9-i][j] << \" \";\n    }\n    cout << endl;\n  }\n  cout <<\"end\"<<endl;\n}\n\nvoid all_fall(int y){\n  rep(j,5)block[y][j]=false;\n\n  \n  REP(i,y,N-1){\n    rep(j,5)block[i][j]=block[i+1][j];\n\n  }\n  \n  rep(j,5)block[N-1][j]=false;\n}\n\nint getmax(int l,int r){\n  int ret=0;\n  REP(j,l,r){    \n    int tmp = N-1;\n    for(int i=N-1;i>=0;i--){\n      if (block[i][j])break;\n      tmp=i;\n    }\n    ret=max(ret,tmp);\n  }\n  return ret;\n}\n\nvoid fall(){\n  rep(i,N){\n    if (block[i][0]&block[i][1]&block[i][2]&block[i][3]&block[i][4]){\n      all_fall(i);\n      i--;\n    }\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    rep(i,N)rep(j,5)block[i][j]=false;\n    rep(i,n){\n      int d,p,q;\n      int wid=1,hei=1,pos;\n      cin>>d>>p>>q;\n      q--;\n      if (d == 1){//yoko\n\tpos = getmax(q,q+p);\t\n\twid=p;\n      }else if (d == 2){//tate\n\tpos = getmax(q,q+1);\n\thei=p;\n      }\n\n      rep(i,hei){\n\trep(j,wid){\n\t  block[pos+i][q+j]=true;\n\t}\n      }\n      fall();\n      //output();\n    }\n\n    cout << count(&block[0][0],&block[N][0],true) << endl;\n    //    cout << cnt << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint i,j,n,a,b,c,d,e,f,g,m[5050];\n\twhile(cin >> n) {\n\t\tif (n==0) break;\n\t\tfor (j=0;j<5050;j++) m[j]=0; d=1;\n\t\tfor (i=0;i<n;i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tf=a >1 ? 1 << (c-1) : ((1 << b)-1)  << (c-1);  \n\t\t\tfor (j=d;j>=0;j--) if ( m[j]+f != (m[j] | f)) break;\n\t\t\te=g=j+1; \n\t\t\tif (a==1) { m[e]+=f; d++;}  else for (j=0;j<b;j++) { m[e+j]+=f; d++;}\n\t\t\tfor (j=g; j<g+d+5; j++) if (m[j]<31) m[e++]=m[j]; \n\t\t}\n\t\tf=0;\n\t\tfor (i=0;i<5050;i++) for (j=0;j<5;j++) f+=(m[i] & ( 1 << j))>0;\n\t\tcout << f << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint d[1010], p[1010], q[1010];\nint f[5010][5];\n\nbool cant(int d, int p, int q, int r) {\n  if (d == 1) {\n    for (int i = 0; i < p; i++) {\n      if (f[r][q + i]) return true;\n    }\n  } else {\n    if (f[r][q]) return true;\n  }\n  return false;\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  int n;\n  while (cin >> n, n) {\n    memset(f, 0, sizeof(f));\n    for (int i = 0; i < n; i++) {\n      cin >> d[i] >> p[i] >> q[i];\n      q[i]--;\n    }\n    for (int i = 0; i < n; i++) {\n      for (int j = 4999; ; j--) {\n        if (j < 0 || cant(d[i], p[i], q[i], j)) {\n          if (d[i] == 1) {\n            for (int k = 0; k < p[i]; k++) {\n              f[j + 1][q[i] + k] = 1;\n            }\n          } else {\n            for (int k = 0; k < p[i]; k++) {\n              f[j + 1 + k][q[i]] = 1;\n            }\n          }\n          break;\n        }\n      }\n      bool update = true;\n      while (update) {\n        update = false;\n        for (int j = 0; j < 5000; j++) {\n          bool kieru = true;\n          for (int k = 0; k < 5; k++) {\n            kieru &= f[j][k];\n          }\n          if (kieru) {\n            update = true;\n            for (int k = 0; k < 5; k++) {\n              f[j][k] = 0;\n            }\n            for (int k = j; k < 5000; k++) {\n              for (int l = 0; l < 5; l++) {\n                swap(f[k][l], f[k + 1][l]);\n              }\n            }\n          }\n        }\n      }\n    }\n    int ans = 0;\n    for (int i = 0; i < 5000; i++) {\n      for (int j = 0; j < 5; j++) {\n        ans += f[i][j];\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n \nusing namespace std;\ntypedef pair<int,int> ii;\nint field[5010][5];\nint top[5];\nint n,d,p,q;\nvector<ii> input;\n \n \nvoid print()\n{\n  int st = 0;\n  rep(i,5)st = max(st,top[i]);\n  for(int y=st;y>=0;y--)\n    {\n      rep(x,5)\n    {\n      cout << field[y][x] << \" \";\n    }\n      cout << endl;\n    }\n}\n \nbool checkX(int y)\n{\n  rep(x,5)if(!field[y][x])return false;\n  return true;\n}\n \nvoid updateD(int x,int y)\n{\n  ii info = input[field[y][x]];\n  if(info.first == 1)\n    {//yoko\n      //while(true)\n\t//{\n      bool check = true;\n      rep(i,5)\n        {\n          if(field[y][x] != field[y][i])continue;\n          if(y-1 >= 0 && field[y-1][i] != 0)\n        {\n          check = false;\n          break;\n        }\n        }\n      if(!check)return;\n      int v = field[y][x];\n      rep(i,5)\n        {\n          if(v != field[y][i])continue;\n          assert(field[y-1][i] == 0);\n          field[y-1][i] = field[y][i];\n          field[y][i] = 0;\n        }\n      y = y-1;\n      if(y <= 0)return;\n      //}\n    }\n  else\n    {\n      int v = field[y][x];\n     \n      int bot = 0;\n      int py = y;\n      while(py-1 >= 0 && field[py-1][x] == 0)py--;\n      bot = y-py;\n \n      if(bot == 0)return;\n      bot = 1;//fewafaw\n      while(v == field[y][x])\n    {\n      assert(y-bot >= 0);\n      assert(field[y-bot][x] == 0);\n      field[y-bot][x] = field[y][x];\n      field[y][x] = 0;\n      y++;\n    }\n     \n    }\n}\n \nint main()\n{\n  while(cin >> n,n)\n    {\n      input.clear();\n      input.resize(1010,ii(-1,-1));\n      rep(i,5010)rep(j,5)field[i][j] = 0;\n      rep(i,5)top[i] = 0;\n      REP(i,1,n+1)\n    {\n      cin >> d >> p >> q;\n      if(d == 1 && p == 5)continue;\n      q--;\n      input[i] = ii(d,p);\n      int cyb,cyt;\n      if(d == 2)\n        {\n          cyb = top[q],cyt = top[q]+p;\n          REP(j,top[q],top[q]+p)field[j][q] = i;\n          top[q] += p;\n        }\n      else\n        {\n          int mexico = -inf;\n          REP(j,q,q+p)mexico = max(mexico,top[j]);\n          REP(j,q,q+p)field[mexico][j] = i;\n          cyb = cyt = mexico;\n          REP(j,q,q+p)top[j] = mexico+1;\n        }\n \n      bool update = true;\n      while(update)\n\t{\n\t  update = false;\n      vector<int> erasedY;\n      REP(y,cyb,cyt+1)\n        {\n          if(checkX(y))\n        {\n\t  update = true;\n          erasedY.push_back(y);\n          rep(x,5)field[y][x] = 0;\n        }\n        }\n \n      //print();\n      //down\n      if(!erasedY.empty())\n        {\n \n \n          int yt = 0;\n          rep(j,5)yt = max(yt,top[j]);\n          rep(j,erasedY.size())\n        {\n          REP(y,erasedY[j],yt)\n            {\n              int pre = -1;\n              rep(x,5)\n            {\n              if(field[y][x] == pre)continue;\n              if(field[y][x] == 0 || y-1 < 0)continue;\n \n              pre = field[y][x];\n              updateD(x,y);\n            }\n            }\n        }\n \n \n        }\n      //update top\n \n      rep(j,5)\n        {\n          int y = top[j];\n          while(y >= 0 && field[y][j] == 0)y--;\n          top[j] = y+1;\n        }\n      /*\n      cout << \"top = \";\n      rep(j,5)cout << top[j] << \" \";\n      cout << endl;\n      print();\n \n      cout << \"----------------\" << endl;\n      */\n\t}\n    }\n      int yt = 0;\n      rep(i,5)yt = max(yt,top[i]);\n      int ans = 0;\n      rep(y,yt)\n    rep(x,5)\n          if(field[y][x] != 0)ans++;    \n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint grid[5][5010];\nint n,d,p,q;\nll int ans = 0;\n\nint GetBottom(int x){\n\tREP(i,5000){\n\t\tif(grid[x][i]==-1) return i;\n\t}\n\treturn 0;\n}\n\nbool isallclear(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=-1) return false;\n\t}\n\treturn true;\n}\n\nbool isallblock(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(cin>>n,n){\n\t\tREP(i,5) REP(j,5010) grid[i][j] = -1;\n\t\tREP(i,n){\n\t\t\tcin >> d >> p >> q;\n\t\t\tif(d==2){\n\t\t\t\tint tmp = GetBottom(q-1);\n\t\t\t\tFOR(j,tmp,tmp+p) grid[q-1][j] = 1;\n\t\t\t}else{\n\t\t\t\tint tmp = -1;\n\t\t\t\tFOR(j,q-1,q-1+p){\n\t\t\t\t\ttmp = max(tmp,GetBottom(j));\n\t\t\t\t}\n\t\t\t\tFOR(j,q-1,q-1+p) {\n\t\t\t\t\tgrid[j][tmp] = 1;\n\t\t\t\t\tREP(k,tmp) if(grid[j][k]==-1) grid[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowline = 0;\n\t\t\twhile(1){\n\t\t\t\tif(isallclear(nowline)) break;\n\t\t\t\tif(isallblock(nowline)){\n\t\t\t\t\tREP(j,5) {\n\t\t\t\t\t\tint nline = nowline+1;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tif(grid[j][nline]==-1) {\n\t\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\tnline++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tnowline++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tint line = 0;\n\t\twhile(1){\n\t\t\tif(isallclear(line)) break;\n\t\t\tREP(i,5){\n\t\t\t\tif(grid[i][line]==1) ans++;\n\t\t\t}\n\t\t\tline++;\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> EMP(5, 0);\n\nclass TETORIS {\npublic:\n\tint N;\n\tvector<vector<int> > bd;\n\tTETORIS() : N(0) {}\n\tvoid put(int len, int pos) {\n\t\tint k = bd.size()-1;\n\t\tfor (; k>=0; --k) {\n\t\t\tfor (int i=0; i<len; ++i) {\n\t\t\t\tif (bd[k][pos+i]) goto brk;\n\t\t\t}\n\t\t} brk:;\n\t\t++k;\n\t\tif (bd.size() == k) bd.push_back(EMP);\n\t\tfor (int i=0; i<len; ++i) {\n\t\t\tbd[k][pos+i] = 1;\n\t\t}\n\t\tN += len;\n\t\tupdate();\n\t}\n\tvoid update() {\n\t\tfor (int i=bd.size()-1; i>=0; --i) {\n\t\t\tif (bd[i] == EMP) {\n\t\t\t\tbd.erase(bd.begin()+i);\n\t\t\t\tN -= 5;\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main() {\n\tint n, d, p, q;\n\twhile (cin >> n, n) {\n\t\tTETORIS tet;\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tcin >> d >> p >> q;\n\t\t\tif (d == 1) {\n\t\t\t\ttet.put(p, q-1);\n\t\t\t} else {\n\t\t\t\tfor (int j=0; j<p; ++j) tet.put(1, q-1);\n\t\t\t}\n\t\t}\n\t\tcout << tet.N << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n\nusing namespace std;\ntypedef pair<int,int> ii;\nint field[5010][5];\nint top[5];\nint n,d,p,q;\nvector<ii> input;\n\n\nvoid print()\n{\n  int st = 0;\n  rep(i,5)st = max(st,top[i]);\n  for(int y=st;y>=0;y--)\n    {\n      rep(x,5)\n\t{\n\t  cout << field[y][x] << \" \";\n\t}\n      cout << endl;\n    }\n}\n\nbool checkX(int y)\n{\n  rep(x,5)if(!field[y][x])return false;\n  return true;\n}\n\nvoid updateD(int x,int y)\n{\n  ii info = input[field[y][x]];\n  if(info.first == 1)\n    {//yoko\n      while(true)\n\t{\n\t  bool check = true;\n\t  rep(i,5)\n\t    {\n\t      if(field[y][x] != field[y][i])continue;\n\t      if(y-1 >= 0 && field[y-1][i] != 0)\n\t\t{\n\t\t  check = false;\n\t\t  break;\n\t\t}\n\t    }\n\t  if(!check)return;\n\t  int v = field[y][x];\n\t  rep(i,5)\n\t    {\n\t      if(v != field[y][i])continue;\n\t      assert(field[y-1][i] == 0);\n\t      field[y-1][i] = field[y][i];\n\t      field[y][i] = 0;\n\t    }\n\t  y = y-1;\n\t  if(y <= 0)return;\n\t}\n    }\n  else\n    {\n      int v = field[y][x];\n    \n      int bot = 0;\n      int py = y;\n      while(py-1 >= 0 && field[py-1][x] == 0)py--;\n      bot = y-py;\n\n      if(bot == 0)return;\n\n      while(v == field[y][x])\n\t{\n\t  assert(y-bot >= 0);\n\t  assert(field[y-bot][x] == 0);\n\t  field[y-bot][x] = field[y][x];\n\t  field[y][x] = 0;\n\t  y++;\n\t}\n\t\n    }\n}\n\nint main()\n{\n  while(cin >> n,n)\n    {\n      input.clear();\n      input.resize(1010,ii(-1,-1));\n      rep(i,5010)rep(j,5)field[i][j] = 0;\n      rep(i,5)top[i] = 0;\n      int cyb,cyt;\n      REP(i,1,n+1)\n\t{\n\t  cin >> d >> p >> q;\n\n\t  if(d == 1 && p == 5)continue;\n\t  q--;\n\t  input[i] = ii(d,p);\n\n\t  if(d == 2)\n\t    {\n\t      cyb = top[q],cyt = top[q]+p;\n\t      REP(j,top[q],top[q]+p)field[j][q] = i;\n\t      top[q] += p;\n\t    }\n\t  else\n\t    {\n\t      int mexico = -inf;\n\t      REP(j,q,q+p)mexico = max(mexico,top[j]);\n\t      REP(j,q,q+p)field[mexico][j] = i;\n\t      cyb = cyt = mexico;\n\t      REP(j,q,q+p)top[j] = mexico+1;\n\t    }\n\n\t  //update top\n\t  \n\t  rep(j,5)\n\t    {\n\t      int y = top[j];\n\t      while(y >= 0 && field[y][j] == 0)y--;\n\t      top[j] = y+1;\n\t    }\n  \n\n\t}\n      cyb = 0;\n      rep(i,5)cyt = max(cyt,top[i]);\n      \n\t  //check, this is teroris so do no need to check again and again\n\t  vector<int> erasedY;\n\t  REP(y,cyb,cyt+1)\n\t    {\n\t      if(checkX(y))\n\t\t{\n\t\t  erasedY.push_back(y);\n\t\t  rep(x,5)field[y][x] = 0;\n\t\t}\n\t    }\n\n\t  //print();\n\t  //down\n\t  if(!erasedY.empty())\n\t    {\n\n\n\t      int yt = 0;\n\t      rep(j,5)yt = max(yt,top[j]);\n\t      rep(j,erasedY.size())\n\t\t{\n\t\t  REP(y,erasedY[j],yt)\n\t\t    {\n\t\t      int pre = -1;\n\t\t      rep(x,5)\n\t\t\t{\n\t\t\t  if(field[y][x] == pre)continue;\n\t\t\t  if(field[y][x] == 0 || y-1 < 0)continue;\n\n\t\t\t  pre = field[y][x];\n\t\t\t  updateD(x,y);\n\t\t\t}\n\t\t    }\n\t\t}\n\n\n\t    }\n\t\n\t  //print();\n\t  /*\n\t\n\t  */\n\t\n      int yt = 0;\n      rep(i,5)yt = max(yt,top[i]);\n      int ans = 0;\n      rep(y,yt)\n\trep(x,5)\n       \t  if(field[y][x] != 0)ans++;\t\n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n  \nusing namespace std;\n  \nconst int Height = 5100;\nconst int Width = 5;\nchar field[Height][Width];\nint top,ans;\nint dx[] = {1,0};\nint dy[] = {0,-1};\n  \nvoid print(int h, int w){\n  \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl; \n}\n\nbool isInside(int h, int w){ return 0<=h&&h<Height&&0<=w&&w<Width;}\nint getH(int d, int len, int pos){\n  for(int i = top+6; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?' || !isInside(h,w)) return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n}\n \nvoid down(int n){\n  \n  for(int i = n; i <= top+6; i++)\n    for(int j = 0; j < Width; j++) field[i][j] = field[i+1][j];\n  // top--;\n}\n \nvoid erase(){\n \n  for(int i = 0; i <= top+6; i++){\n    bool f = true;\n    for(int j = 0; j < Width; j++) if(field[i][j] == '?') f = false;\n    if(f){\n      ans -= 5;\n      down(i--);\n    }\n  }\n}\n  \nvoid put(int d, int len, int pos){\n  \n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n  \n  int h = nex;\n  int w = pos;\n  \n  for(int i = 0; i < len; i++){\n    field[h][w] = '.';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n  \nint main(){\n  \n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    ans = top = 0;\n     \n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      ans += len;\n      put(d-1,len,pos-1);\n      erase();\n    }\n    cout << ans << endl;\n    // print(10,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n \nusing namespace std;\n \nconst int Height = 5010;\nconst int Width = 5;\nchar field[Height][Width];\nint top,ans;\nint dx[] = {1,0};\nint dy[] = {0,1};\n \n \nvoid print(int h, int w){\n \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl;\n     \n}\nbool isInside(int h, int w){return 0<=h&&h<Height&&0<=w&&w<Width;}\n \nint getH(int d, int len, int pos){\n  for(int i = top+1; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?' || !isInside(h,w)) return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n}\n\nvoid down(int n){\n \n  for(int i = n; i <= top+2; i++)\n    for(int j = 0; j < Width; j++) field[i][j] = field[i+1][j];\n  top--;\n}\n\nvoid erase(){\n\n  for(int i = 0; i <= top+2; i++){\n    bool f = true;\n    for(int j = 0; j < Width; j++) if(field[i][j] == '?') f = false;\n    if(f){\n      ans -= 5;\n      down(i--);\n    }\n  }\n}\n \nvoid put(int d, int len, int pos){\n \n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n \n  int h = nex;\n  int w = pos;\n \n  for(int i = 0; i < len; i++){\n    field[h][w] = '.';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n \nint main(){\n \n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    ans = top = 0;\n    \n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      ans += len;\n      put(d-1,len,pos-1);\n      erase();\n    }\n    cout << ans << endl;\n    //  print(5,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint n, d, p, q;\n\nint main()\n{\n    cin >> n;\n    \n    vector<vector<bool> > c(5000, vector<bool>(5, false));\n    \n    for(int i = 0; i < n; i++)\n    {\n        cin >> d >> p >> q;\n        \n        if(d == 1)\n        {\n            int maxh = -1;\n            \n            for(int j = p - 1; j < p + q - 1; j++)\n            {\n                int r = 5000;\n                \n                while(r--)\n                {\n                    if(c[r][j] == true)\n                    {\n                        break;\n                    }\n                }\n                \n                maxh = max(maxh, r + 1);\n            }\n            \n            for(int j = p - 1; j < p + q - 1; j++)\n            {\n                c[maxh][j] = true;\n            }\n        }\n        else\n        {\n            int r = 5000;\n            \n            while(r--)\n            {\n                if(c[r][p] == true)\n                {\n                    break;\n                }\n            }\n            \n            for(int j = r + 1; j < r + q + 1; j++)\n            {\n                c[j][p] = true;\n            }\n        }\n    }\n    \n    int sum = 0;\n    \n    for(int i = 0; i < 5000; i++)\n    {\n        for(int j = 0; j < 5; j++)\n        {\n            sum += (c[j][p] ? 1 : 0);\n        }\n    }\n    \n    cout << sum << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nint n;\n\ntypedef struct Block\n{\n\tint d;\n\tint p;\n\tint q;\n} B;\n\nint F[5000][5];\nint H[5];\n\nB blocks[1000];\n\nint highest(int r, int l)\n{\n\tint max = 0;\n\tfor(int i=r; i<l; i++)\n\t{\n\t\tif(max < H[i])\n\t\t{\n\t\t\tmax =H[i];\n\t\t}\n\t}\n\treturn max;\n}\n\nvoid yoko_set(B b)\n{\n\tint hp = highest(b.q, b.p+b.q);\n\tfor(int i=b.q; i<b.p+b.q; i++)\n\t{\n\t\tF[hp][i] =1;\n\t\tH[i] = hp+1;\n\t}\n}\n\nvoid tate_set(B b)\n{\n\tint hp = H[b.q];\n\tfor(int i=hp; i<hp+b.p; i++)\n\t{\n\t\tF[i][b.q] = 1;\n\t}\n\tH[b.q] = hp+b.p;\n}\n\nvoid col_clear()\n{\n\t\n\tint hp = highest(0, 5);\n\tbool is_ok = false;\n\tvector<int> cols;\n\tfor(int i=0; i<=hp; i++)\n\t{\n\t\tis_ok =true;\n\t\tfor(int j=0; j<5; j++)\n\t\t{\n\t\t\tif(F[i][j]==1) continue;\n\t\t\tis_ok = false;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(is_ok)\n\t\t{\n\t\t\tcols.push_back(i);\n\t\t}\n\t}\n\t\n\tif(cols.empty()) return;\n\t\n\tint c = 0;\n\tfor(int i=0; i<hp; i++)\n\t{\n\t\tif(cols[c]==i)\n\t\t{\n\t\t\tc++;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int j=0; j<5; j++)\n\t\t{\n\t\t\tF[i-c][j] = F[i][j];\n\t\t}\n\t}\n\t\n\tfor(int i=hp-cols.size(); i<hp; i++)\n\t{\n\t\tfor(int j=0; j<5; j++)\n\t\t{\n\t\t\tF[i][j] = 0;\n\t\t}\n\t}\n\t\n\tfor(int i=0; i<5; i++)\n\t{\n\t\tH[i] -= cols.size();\n\t}\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tcin >> blocks[i].d;\n\t\t\tcin >> blocks[i].p;\n\t\t\tcin >> blocks[i].q;\n\t\t\tblocks[i].q--;\n\t\t}\n\t\t\n\t\tmemset(&F[0][0], 0, sizeof(int)*25000);\n\t\tmemset(&H[0], 0, sizeof(int)*5);\n\t\t\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tif(blocks[i].d == 2)\n\t\t\t{\n\t\t\t\ttate_set(blocks[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tyoko_set(blocks[i]);\n\t\t\t}\n\t\t\t\n\t\t\tcol_clear();\n\t\t}\n\t\t\n\t\tint hp = highest(0, 5);\n\t\tint c = 0;\n\t\tfor(int i=0; i<hp; i++)\n\t\t{\n\t\t\tfor(int j=0; j<5; j++)\n\t\t\t{\n\t\t\t\tif(F[i][j]==1) c++;\n\t\t\t}\n\t\t}\n\t\tcout << c<< endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\tflg &= board[h_max][j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tfor(int k = h_max; k < top[j]; k++) {\n\t\t\t\t\t\t\tboard[k][j] = board[k + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\n\t\t\t\tint h = top[q - 1];\n\t\t\t\ttop[q - 1] += p;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tflg &= board[h + j][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tboard[h + j - del][k] = board[h + j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdel++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tfor(int k = h + p - del; k < top[j] + 10; k++) {\n\t\t\t\t\t\tboard[k][j] = board[k + del][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\n\t\t\tfor(int j = 0; j < 6; j++) {\n\t\t\t\tans += board[i][j]?1:0;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 10; i >= 0; i--) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tcout << (board[i][j] ? '*' : '.');\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t// */\n\t\t/*\n\t\tfor(int i = 0; i < 5; i++)\n\t\t\tcout << top[i] << \" \";\n\t\tcout << endl;\n\t\t// */\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint mp[10000000][5];\n//d<muki p<nagasa q<basyo\nint d,p,q;\nint ktflg = 0,th;\nint kesuflg =0;\n\nvoid deb() {\n  /*for(int i=0;i<10;i++) {\n    for(int j=0;j<5;j++)\n      cout << mp[i][j] << \" \";\n    cout << endl;\n  }\n  cout << \"----------------------------\" <<endl; */\n\n}\n\n\nvoid tumeru() { \n  \n  int c = 0;\n  for(int i=0;i<th;i++) {\n    int zero = 0;\n    for(int j=0;j<5;j++) if(mp[i][j] == 0) zero++;\n    \n    if(zero == 5) continue;\n    for(int j=0;j<5;j++) mp[c][j] = mp[i][j];\n    c++;\n  }\n\n  for(int i=c;i<th;i++) \n    for(int j=0;j<5;j++) \n      mp[i][j] = 0;\n\n\n}\n\nvoid kesu() {\n  kesuflg = 0;\n     int h = 0;\n  while(1) {\n    int flg =0;\n    for(int i=0;i<5;i++) {\n      if(mp[h][i] !=0) break;\n      if(i == 4) flg = 1;\n    }\n    if(flg == 1) break;\n    h++;\n  }\n  th = h;\n\n  h = 0;\n  while(1) {\n    int zero = 0;\n    int count = 0;\n    for(int i=0;i<5;i++) {\n      if(mp[h][i] == 0) zero++;\n      else count++;\n    }\n\n    if(zero == 5) break;\n    if(count == 5)\n      for(int i=0;i<5;i++)\n\tmp[h][i] = 0;\n    h++;\n    kesuflg = 1;\n  }\n  \n  \n}\n       \n\nvoid add(int c) {\n\n  int h = 0;\n  while(1) {\n    int flg =0;\n    for(int i=0;i<5;i++) {\n      if(mp[h][i] !=0) break;\n      if(i == 4) flg = 1;\n    }\n    if(flg == 1) break;\n    h++;\n  }\n  \n  if(d == 1) {\n    while(1) {\n      if(h <= 0)break;\n      int flg = 0;\n      for(int i=0;i<p;i++)\n\tif(mp[h-1][i+q-1] != 0) break;\n\telse if(i == p-1) h-- ,flg = 1;\n      if(flg == 0) break;\n    }\n  \n  \n    for(int i=0;i<p;i++)\n      mp[h][i+q-1] = c;\n  }\n  \n  if(d == 2) {\n\n    int t=1;\n    while(1) {\n      if(h-t >= 0 && mp[h-t][q-1] == 0){\n\th--;\n\tcontinue;\n      }\n      break;\n    }\n    for(int i=0;i<p;i++)mp[h+i][q-1] = c;\n  }\n\n  deb();\n}\n  \n\n\nint main() {\n\n  int ques;\n  while(1) {\n  cin >> ques;\n  if(ques == 0) break;\n  for(int i=0;i<50000;i++)\n    for(int j=0;j<5;j++)\n      mp[i][j] = 0;\n  \n  int c = 1;\n  for(int i=0;i<ques;i++) {\n    cin >> d >> p >>q;\n    //cout << d <<\" \" << p <<\" \"<<q<<endl;\n    add(c);\n    kesu();\n    tumeru();\n    c++;\n  }\n\n\n\n    \n  int h=0;\n  int ans = 0;\n  while(1) {\n    int zero = 0;\n    for(int i=0;i<5;i++){\n      if(mp[h][i] == 0) zero++;\n      else ans++;\n    }\n    if(zero == 5) break;\n    h++;\n  }\n  cout << ans << endl;\n\n  }\n    return 0;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF 1e9\n\nint field[5000][5],tmp[5000][5];\n\nvoid down(){\n  memset(tmp,0,sizeof(tmp));\n  for(int j = 0 ; j < 5 ; j++){\n    int p = 4999;\n    for(int i = 4999 ; i >= 0 ; i--){\n      if(field[i][j] == -1) continue;\n      tmp[p--][j] = field[i][j];\n    }\n  }\n  for(int i = 0 ; i < 5000 ; i++){\n    for(int j = 0 ; j < 5 ; j++){\n      field[i][j] = tmp[i][j];\n    }\n  }\n}\n\nvoid remove(){\n  bool flg = false;\n  for(int i = 0 ; i < 5000 ; i++){\n    int cnt = 0;\n    for(int j = 0 ; j < 5 ; j++,cnt++){\n      if(!field[i][j]) break;\n    }\n    if(cnt == 5){\n      flg = true;\n      for(int j = 0 ; j < 5 ; j++){\n        field[i][j] = -1;\n      }\n    }\n  }\n  \n  if(flg){\n    down();\n  }\n}\n\nint main(){\n  int N,d,p,q;\n\n  while(cin >> N,N){\n    memset(field,0,sizeof(field));\n    for(int i = 0 ; i < N ; i++){\n      cin >> d >> p >> q; q--;\n\n      if(d == 1){\n        int min = INF;\n        for(int j = q ; j < p+q ; j++){\n          for(int i = 0 ; i < 5000 ; i++){\n            if(i == 4999 || field[i+1][j] == 1){\n              min = std::min(min,i);\n              break;\n            }\n          }\n        }\n        for(int j = q ; j < p+q ; j++){\n          field[min][j] = 1;\n        }\n      }else{\n        for(int i = 0 ; i < 5000 ; i++){\n          if(i == 4999 || field[i+1][q] == 1){\n            for(int j = 0 ; j < p ; j++){\n              field[i-j][q] = 1;\n            }\n            break;\n          }\n        }\n      }\n      remove();\n    }\n    int ans = 0;\n    for(int i = 0 ; i < 5000 ; i++){\n      for(int j = 0 ; j < 5 ; j++){\n        if(field[i][j] == 1) ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\n#define W 5\n#define H 5100\n#define BLANK 0\n#define BLOCK 1\nint main()\n{\n  int n,d,p,q;\n  int field[H+2][W];\n  int i,j,k;\n  bool flag;\n  int count;\n  while(cin>>n,n){\n    for(i=0;i<H+1;i++)for(j=0;j<W;j++)field[i][j]=BLANK;\n    for(j=0;j<W;j++)field[i][j]=BLOCK;\n    while(n-->0){\n      cin>>d>>p>>q;\n      // ¡u«\n      if(d==1){\n\tj=q-1;\n\tflag=false;\n\tfor(i=0;i<H+2;i++){\n\t  for(k=0;k<p;k++)if(field[i][j+k]==BLOCK)flag=true;\n\t  if(flag){\n\t    for(k=0;k<p;k++)field[i-1][j+k]=BLOCK;\n\t    break;\n\t  }\n\t}\n      }\n      // cu«\n      if(d==2){\n\tj=q-1;\n\tfor(i=0;i<H+2;i++){\n\t  if(field[i][j]==BLOCK){\n\t    for(k=1;k<=p;k++)field[i-k][j]=BLOCK;\n\t    break;\n\t  }\n\t}\n      }\n      // Á\n      for(i=H;i>=0;i--){\n\tflag=true;\n\tfor(j=0;j<W;j++)if(field[i][j]==BLANK)flag=false;\n\tif(flag){\n\t  for(j=0;j<W;j++)field[i][j]=BLANK;\n\t  for(k=i;k>0;k--)for(j=0;j<W;j++)field[k][j]=field[k-1][j];\n\t  i++;\n\t}\n      }\n    }\n    // \\¦\n    /*\n    for(i=H-8;i<H+2;i++){\n      for(j=0;j<W;j++){\n\tcout<<field[i][j]<<\" \";\n      }\n      cout<<endl;\n    }\n    cout<<endl;\n    */\n    count=0;\n    for(i=H-8;i<H+1;i++)for(j=0;j<W;j++)if(field[i][j]==BLOCK)count++;\n    cout<<count<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n\nusing namespace std;\ntypedef pair<int,int> ii;\nint field[5010][5];\nint top[5];\nint n,d,p,q;\nvector<ii> input;\n\n\nvoid print()\n{\n  int st = 0;\n  rep(i,5)st = max(st,top[i]);\n  for(int y=st;y>=0;y--)\n    {\n      rep(x,5)\n\t{\n\t  cout << field[y][x] << \" \";\n\t}\n      cout << endl;\n    }\n}\n\nbool checkX(int y)\n{\n  rep(x,5)if(!field[y][x])return false;\n  return true;\n}\n\nvoid updateD(int x,int y)\n{\n  ii info = input[field[y][x]];\n  if(info.first == 1)\n    {//yoko\n      while(true)\n\t{\n\t  bool check = true;\n\t  rep(i,5)\n\t    {\n\t      if(field[y][x] != field[y][i])continue;\n\t      if(y-1 >= 0 && field[y-1][i] != 0)\n\t\t{\n\t\t  check = false;\n\t\t  break;\n\t\t}\n\t    }\n\t  if(!check)return;\n\t  int v = field[y][x];\n\t  rep(i,5)\n\t    {\n\t      if(v != field[y][i])continue;\n\t      assert(field[y-1][i] == 0);\n\t      field[y-1][i] = field[y][i];\n\t      field[y][i] = 0;\n\t    }\n\t  y = y-1;\n\t  if(y <= 0)return;\n\t}\n    }\n  else\n    {\n      int v = field[y][x];\n    \n      int bot = 0;\n      int py = y;\n      while(py-1 >= 0 && field[py-1][x] == 0)py--;\n      bot = y-py;\n\n      if(bot == 0)return;\n\n      while(v == field[y][x])\n\t{\n\t  assert(y-bot >= 0);\n\t  assert(field[y-bot][x] == 0);\n\t  field[y-bot][x] = field[y][x];\n\t  field[y][x] = 0;\n\t  y++;\n\t}\n\t\n    }\n}\n\nint main()\n{\n  while(cin >> n,n)\n    {\n      input.clear();\n      input.resize(1010,ii(-1,-1));\n      rep(i,5010)rep(j,5)field[i][j] = 0;\n      rep(i,5)top[i] = 0;\n      REP(i,1,n+1)\n\t{\n\t  cin >> d >> p >> q;\n\t  if(d == 1 && p == 5)continue;\n\t  q--;\n\t  input[i] = ii(d,p);\n\t  int cyb,cyt;\n\t  if(d == 2)\n\t    {\n\t      cyb = top[q],cyt = top[q]+p;\n\t      REP(j,top[q],top[q]+p)field[j][q] = i;\n\t      top[q] += p;\n\t    }\n\t  else\n\t    {\n\t      int mexico = -inf;\n\t      REP(j,q,q+p)mexico = max(mexico,top[j]);\n\t      REP(j,q,q+p)field[mexico][j] = i;\n\t      cyb = cyt = mexico;\n\t      REP(j,q,q+p)top[j] = mexico+1;\n\t    }\n\n\t  //check, this is teroris so do no need to check again and again\n\t  vector<int> erasedY;\n\t  REP(y,cyb,cyt+1)\n\t    {\n\t      if(checkX(y))\n\t\t{\n\t\t  erasedY.push_back(y);\n\t\t  rep(x,5)field[y][x] = 0;\n\t\t}\n\t    }\n\n\t  //print();\n\t  //down\n\t  if(!erasedY.empty())\n\t    {\n\n\n\t      int yt = 0;\n\t      rep(j,5)yt = max(yt,top[j]);\n\t      rep(j,erasedY.size())\n\t\t{\n\t\t  REP(y,erasedY[j],yt)\n\t\t    {\n\t\t      int pre = -1;\n\t\t      rep(x,5)\n\t\t\t{\n\t\t\t  if(field[y][x] == pre)continue;\n\t\t\t  if(field[y][x] == 0 || y-1 < 0)continue;\n\n\t\t\t  pre = field[y][x];\n\t\t\t  updateD(x,y);\n\t\t\t}\n\t\t    }\n\t\t}\n\n\n\t    }\n\t  //update top\n\n\t  rep(j,5)\n\t    {\n\t      int y = top[j];\n\t      while(y >= 0 && field[y][j] == 0)y--;\n\t      top[j] = y+1;\n\t    }\n\t  /*\n\t  cout << \"top = \";\n\t  rep(j,5)cout << top[j] << \" \";\n\t  cout << endl;\n\t  print();\n\n\t  cout << \"----------------\" << endl;\n\t  */\n\t}\n      int yt = 0;\n      rep(i,5)yt = max(yt,top[i]);\n      int ans = 0;\n      rep(y,yt)\n\trep(x,5)\n       \t  if(field[y][x] != 0)ans++;\t\n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\n\tint n;\n\tchar field[10][5];\n\twhile(cin>>n&&n!=0){\n\t\tfor(int i = 0; i < 10; i++)\n\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\tfield[i][j]='0';\n\t\tint d,p,q;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin>>d>>p>>q;\n\t\t\tif(d==1){\n\t\t\t\tint init=q-1;\n\t\t\t\tint at=10000000;\n\t\t\t\tfor(int j = init; j < p+init; j++){\n\t\t\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\t\t\tif(field[k][j]=='1'){\n\t\t\t\t\t\t\tat=min(at,k-1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(k==9){\n\t\t\t\t\t\t\tat=min(at,k);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// atÌÀWÌ³ÉubNð¨­\n\t\t\t\tfor(int j = init; j < p+init; j++){\n\t\t\t\t\tfield[at][j]='1';\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint at=10000000;\n\t\t\t\tfor(int k = 0; k < 10; k++){\n\t\t\t\t\tif(field[k][q-1]=='1'){\n\t\t\t\t\t\tat=k-1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if(k==9)\n\t\t\t\t\t\tat=k;\n\t\t\t\t}\n\t\t\t\t//ubNð¨­\n\t\t\t\tfor(int j = at; j!=at-p; j--){\n\t\t\t\t\tfield[j][q-1]='1';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// ubNÌÁ\n\t\t\tfor(int j = 0; j < 10; j++){\n\t\t\t\tbool f=false;\n\t\t\t\tfor(int k = 0; k < 5; k++){\n\t\t\t\t\tif(field[j][k]!='1'){\n\t\t\t\t\t\tf=true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!f){\n\t\t\t\t\tfor(int k = 0; k < 5; k++)\n\t\t\t\t\t\tfield[j][k]='0';\n\t\t\t\t\t// Á¦½sæèãÉ éubNðº\n\t\t\t\t\tfor(int k = j-1; k >= 0; k--){\n\t\t\t\t\t\tfor(int l = 0; l < 5; l++){\n\t\t\t\t\t\t\tfield[k+1][l]=field[k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//for(int j = 0; j < 10; j++){\n\t\t\t//\tfor(int k = 0; k < 5; k++){\n\t\t\t//\t\tcout<<field[j][k]<<flush;\n\t\t\t//\t}\n\t\t\t//\tcout<<endl;\n\t\t\t//}\n\t\t\t//cout<<endl;\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i = 0; i < 10; i++){\n\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\tif(field[i][j]=='1')\n\t\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tdeque<int>E[5];\n\t\trep(i, n) {\n\t\t\tint d, p, q; scanf(\"%d%d%d\", &d, &p, &q); q--;\n\t\t\tif (d == 1) {\n\t\t\t\tint Max = 0;\n\t\t\t\trep(i, p)Max = max(Max, (int)E[q + i].size());\n\t\t\t\trep(i, p) {\n\t\t\t\t\tint k = E[q + i].size();\n\t\t\t\t\trep(j, Max - k)E[q + i].push_back(0);\n\t\t\t\t\tE[q + i].push_back(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep(i, p)E[q].push_back(1);\n\t\t\t}\n\t\t\tint Min = INT_MAX;\n\t\t\trep(i, 5)Min = min(Min, (int)E[i].size());\n\t\t\trep(i, Min) {\n\t\t\t\tbool ok = true;\n\t\t\t\trep(j, 5)ok &= E[j][i];\n\t\t\t\tif(ok)rep(j, 5)E[j][i] = -1;\n\t\t\t}\n\t\t\trep(i, 5)E[i].erase(remove(E[i].begin(), E[i].end(), -1), E[i].end());\n\t\t\tprintf(\"\");\n\t\t}\n\t\tint sum = 0;\n\t\trep(i, 5)rep(j, E[i].size()) {\n\t\t\tif (E[i][j])sum++;\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define chmax(a,x) a=max(a,x)\n\nvector<bool> F[5];\n\nbool eraser(int idx) {\n  rep(i, 5) {\n    if((int)F[i].size() <= idx) { return false; }\n    if(!F[i][idx]) { return false; }\n  }\n  rep(i, 5) F[i].erase(F[i].begin()+idx);\n  rep(i, 5) {\n    while(1) {\n      if(!F[i].empty() && !F[i].back()) { F[i].pop_back(); }\n      else { break; }\n    }\n  }\n  return true;\n}\n\nint main() {\n  \n  for(int N; cin>>N && N;) {\n    rep(i, 5) F[i].clear();\n    rep(i, N) {\n      int type, len, pos; cin >> type >> len >> pos; pos --;\n      if(type == 1) {\n        int mx = -1;\n        REP(i, pos, pos+len) { chmax(mx, int(F[i].size())); }\n        REP(i, pos, pos+len) {\n          REP(j, F[i].size(), mx) {\n            F[i].push_back(false);\n          }\n          F[i].push_back(true);\n        }\n        eraser(mx);\n      }\n      else {\n        rep(i, len) { F[pos].push_back(true); }\n        int cnt = 0;\n        rep(i, len) { if(!eraser((int)F[pos].size()-1-cnt)) cnt++; }\n      }\n    }\n    int sum = 0;\n    rep(i, 5) rep(j, F[i].size()) sum += F[i][j];\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define MAX_N 1000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstatic const double eps = 1e-8;\n\nint gStage[6000][5];\n\nvoid putBlock(int dir,int len,int pos){\n\tif(dir == 1){\n\t\tfor(int i=6000-1;i>=0;i--){\n\t\t\tbool isok=true;\n\t\t\tfor(int j=pos;j<pos+len;j++){\n\t\t\t\tif(gStage[i][j]==1) isok=false;\n\t\t\t}\n\t\t\t\n\t\t\tif(!isok){\n\t\t\t\tfor(int j=pos;j<pos+len;j++){\n\t\t\t\t\tgStage[i+1][j] = 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\telse if(isok && i==0){\n\t\t\t\tfor(int j=pos;j<pos+len;j++){\n\t\t\t\t\tgStage[i+1][j] = 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=6000-1;i>=0;i--){\n\t\t\tbool isok=true;\n\t\t\tif(gStage[i][pos]==1) isok=false;\n\n\t\t\tif(!isok){\n\t\t\t\tfor(int j=i+1;j<i+1+len;j++){\n\t\t\t\t\tgStage[j][pos] = 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\telse if(isok && i==0){\n\t\t\t\tfor(int j=i;j<i+len;j++){\n\t\t\t\t\tgStage[j][pos] = 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint countBlock(){\n\tint res=0;\n\tfor(int i=0;i<6000;i++){\n\t\tfor(int j=0;j<5;j++){\n\t\t\tres += gStage[i][j];\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvoid eraseBlock(){\n\tfor(int i=0;i<6000;i++){\n\t\tbool isok=true;\n\t\tfor(int j=0;j<5;j++){\n\t\t\tif(gStage[i][j]==0) isok = false;\n\t\t}\n\n\t\tif(isok){\n\t\t\tfor(int j=i;j+1<6000;j++){\n\t\t\t\tfor(int k=0;k<5;k++){\n\t\t\t\t\tgStage[j][k] = gStage[j+1][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\ti--;\n\t\t}\n\t}\n}\n\nvoid printBlock(){\n\tfor(int i=0;i<50;i++){\n\t\tfor(int j=0;j<5;j++){\n\t\t\tprintf(\"%d\",gStage[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n}\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\n\t\tmemset(gStage,0,sizeof(gStage));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint dir,len,pos;\n\t\t\tscanf(\"%d %d %d\",&dir,&len,&pos);\n\t\t\tpos-=1;\n\t\t\tputBlock(dir,len,pos);\n\t\t\t//printBlock();\n\t\t\teraseBlock();\n\t\t\t//printBlock();\n\t\t}\n\n\t\tprintf(\"%d\\n\",countBlock());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\tflg = flg && board[h_max][j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tfor(int k = h_max; k < top[j]; k++) {\n\t\t\t\t\t\t\tboard[k][j] = board[k + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\n\t\t\t\tint h = top[q - 1];\n\t\t\t\ttop[q - 1] += p;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tflg = flg && board[h + j][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tboard[h + j - del][k] = board[h + j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdel++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tfor(int k = h + p - del; k < top[j] + 10; k++) {\n\t\t\t\t\t\tboard[k][j] = board[k + del][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\n\t\t\tbool flg = true;\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tans += board[i][j];\n\t\t\t\tflg = flg && (board[i][j] == 1);\n\t\t\t}\n\t\t\tif(flg)\n\t\t\t\tabort();\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 10; i >= 0; i--) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tcout << (board[i][j] ? '*' : '.');\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t// */\n\t\t/*\n\t\tfor(int i = 0; i < 5; i++)\n\t\t\tcout << top[i] << \" \";\n\t\tcout << endl;\n\t\t// */\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  Sample1:\n  9\n  1 1 1\n  1 2 1\n  1 3 1\n  1 4 1\n  1 3 1\n  1 2 1\n  1 1 1\n  2 5 5\n  2 5 4\n  0\n  Output:\n  11\n\n  Sample2:\n  10\n  1 4 1\n  1 1 1\n  1 4 1\n  1 1 2\n  1 4 1\n  1 1 3\n  1 4 1\n  1 1 4\n  2 5 5\n  2 5 5\n  0\n  Output:\n  10\n\n  memorandum:\n  テ」ツδ姪」ツδュテ」ツδε」ツつッテ」ツ?古ヲツカツ暗」ツ?暗」ツ?淌・ツセツ古」ツ?ォテヲツィツェテ」ツ?ォテッツシツ陛」ツ?、テ」ツ?敕」ツつ催」ツ?」テ」ツ?淌・ツ?エテ・ツ青暗」ツ?敕」ツつ古」ツつづヲツカツ暗」ツ?凖ッツシツ暗・ツョツ堙ァツ閉ェテッツシツ嘉」ツ??」ツ??」ツ??」ツ??\n  テヲツィツェテ」ツ?ョテ・ツ按療」ツ?古ヲツカツ暗」ツ?暗」ツ?淌・ツ?エテ・ツ青暗」ツ??ヲツカツ暗」ツ?暗」ツ?淌ィツ。ツ古」ツ?ョテ、ツクツ甘」ツ?ョテ」ツδ姪」ツδュテ」ツδε」ツつッテ」ツ?ッテ」ツ?敕」ツ?ョテ」ツ?セテ」ツ?セテ」ツ?ョテ・ツスツ「テ」ツ?ァテッツシツ妥ィツ。ツ古、ツクツ凝」ツ?ォテ」ツ?療」ツ?堙」ツつ?\n  ^^^^^\n  テ」ツ?、テ」ツ?」テ」ツ?凝」ツ?凝」ツつ凝」ツ?セテ」ツ?ァテ」ツ?イテ」ツ?淌」ツ?凖」ツつ嘉ィツ青ステ」ツ?ィテ」ツ?陛」ツ?ェテ」ツ??」ツつ暗」ツ??」ツ?ォテヲツウツィテヲツ??\n  テ・ツ?・テ・ツ環崚」ツ?古、ツクツ偲」ツ?暗」ツつ嘉」ツつ古」ツつ凝」ツ?淌」ツ?ウテ」ツ?ォテ」ツ?禿」ツつ古」ツつ嘉」ツ?ョテ・ツ?ヲテァツ青?」ツつ津」ツ?凖」ツつ?\n  Sample Inputテ」ツ?ョテッツシツ禿」ツ?、テ」ツつ?」ツ?古ッツシツ姪」ツ?ォテ」ツ?ェテ」ツつ凝」ツ?ョテ」ツ?ッテ」ツ?凖」ツ?ケテ」ツ?ヲティツ青ステ」ツ?。テ」ツ?淌・ツセツ古」ツ?ォテヲツカツ暗」ツ?凖・ツ?ヲテァツ青?」ツつ津」ツ?療」ツ?淌」ツ?凝」ツつ嘉」ツ?ァテ」ツ?ッテ」ツ?ェテ」ツ?湘」ツδ姪」ツδュテ」ツδε」ツつッテ」ツ?古ヲツイツ暗」ツつ?」ツ?ッテッツシツ妥ィツ。ツ古」ツ?ョテ」ツ?ソテ」ツ??」ツ?」テ」ツ?淌」ツ?淌」ツつ?\n*/\n\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n \nusing namespace std;\ntypedef pair<int,int> ii;\nint field[5010][5];\nint top[5];\nint n,d,p,q;\nvector<ii> input;\n \nbool checkX(int y)\n{\n  rep(x,5)if(!field[y][x])return false;\n  return true;\n}\n \nvoid updateD(int x,int y)\n{\n  ii info = input[field[y][x]];\n  if(info.first == 1)\n    {//yoko\n      //while(true)//テ」ツ?禿」ツ?禿」ツ?ョwhileテ」ツつ津」ツつづ」ツ?ゥテ」ツ?崚」ツ?ーテ」ツ?、テ」ツ?」テ」ツ?凝」ツ?凝」ツつ凝」ツ?セテ」ツ?ァティツ青ステ」ツ?。テ」ツつ?\n      //{\n      bool check = true;\n      rep(i,5)\n        {\n          if(field[y][x] != field[y][i])continue;\n          if(y-1 >= 0 && field[y-1][i] != 0)\n\t    {\n\t      check = false;\n\t      break;\n\t    }\n        }\n      if(!check)return;\n      int v = field[y][x];\n      rep(i,5)\n        {\n          if(v != field[y][i])continue;\n          assert(field[y-1][i] == 0);\n          field[y-1][i] = field[y][i];\n          field[y][i] = 0;\n        }\n      y = y-1;\n      if(y <= 0)return;\n      //}\n    }\n  else\n    {\n      int v = field[y][x];\n     \n      int bot = 0;\n      int py = y;\n      while(py-1 >= 0 && field[py-1][x] == 0)py--;\n      bot = y-py;\n \n      if(bot == 0)return;\n      bot = 1;//テ」ツ?禿」ツ?禿」ツつ鍛otテ」ツ?ョテ」ツ?セテ」ツ?セテ」ツ?ォテ」ツ?凖」ツつ古」ツ?ーテ」ツ?、テ」ツ?」テ」ツ?凝」ツ?凝」ツつ凝」ツ?セテ」ツ?ァテ」ツ?甘」ツ?。テ」ツつ?\n      while(v == field[y][x])\n\t{\n\t  assert(y-bot >= 0);\n\t  assert(field[y-bot][x] == 0);\n\t  field[y-bot][x] = field[y][x];\n\t  field[y][x] = 0;\n\t  y++;\n\t}\n     \n    }\n}\n \nint main()\n{\n  while(cin >> n,n)\n    {\n      input.clear();\n      input.resize(1010,ii(-1,-1));\n      rep(i,5010)rep(j,5)field[i][j] = 0;\n      rep(i,5)top[i] = 0;\n      REP(i,1,n+1)\n\t{\n\t  cin >> d >> p >> q;\n\t  if(d == 1 && p == 5)continue;\n\t  q--;\n\t  input[i] = ii(d,p);\n\t  int cyb,cyt;\n\t  if(d == 2)\n\t    {\n\t      cyb = top[q],cyt = top[q]+p;\n\t      REP(j,top[q],top[q]+p)field[j][q] = i;\n\t      top[q] += p;\n\t    }\n\t  else\n\t    {\n\t      int mexico = -inf;\n\t      REP(j,q,q+p)mexico = max(mexico,top[j]);\n\t      REP(j,q,q+p)field[mexico][j] = i;\n\t      cyb = cyt = mexico;\n\t      REP(j,q,q+p)top[j] = mexico+1;\n\t    }\n \n      bool update = true;\n      while(update)\n\t{\n\t  update = false;\n\t  vector<int> erasedY;\n\t  REP(y,cyb,cyt+1)\n\t    {\n\t      if(checkX(y))\n\t\t{\n\t\t  update = true;\n\t\t  erasedY.push_back(y);\n\t\t  rep(x,5)field[y][x] = 0;\n\t\t}\n\t    }\n \n\t  //down\n\t  if(!erasedY.empty())\n\t    {\n \n \n\t      int yt = 0;\n\t      rep(j,5)yt = max(yt,top[j]);\n\t      rep(j,erasedY.size())\n\t\t{\n\t\t  REP(y,erasedY[j],yt)\n\t\t    {\n\t\t      int pre = -1;\n\t\t      rep(x,5)\n\t\t\t{\n\t\t\t  if(field[y][x] == pre)continue;\n\t\t\t  if(field[y][x] == 0 || y-1 < 0)continue;\n \n\t\t\t  pre = field[y][x];\n\t\t\t  updateD(x,y);\n\t\t\t}\n\t\t    }\n\t\t}\n \n \n\t    }\n      \n\t  //update top\n\t  rep(j,5)\n\t    {\n\t      int y = top[j];\n\t      while(y >= 0 && field[y][j] == 0)y--;\n\t      top[j] = y+1;\n\t    }\n      \n\t}\n    }\n\n      int yt = 0;\n      rep(i,5)yt = max(yt,top[i]);\n      int ans = 0;\n      rep(y,yt)\n\trep(x,5)\n\tif(field[y][x] != 0)ans++;    \n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define H_MAX 10001\nusing namespace std;\n\nvoid breakLine(int data[H_MAX][5], int y) {\n  for(int i = y; i+1 < H_MAX; i++) {\n    for(int j = 0; j < 5; j++) {\n      data[i][j] = data[i+1][j];\n    }\n  }\n}\n\nvoid search(int data[H_MAX][5], int sy, int ey) {\n  for(int i = sy; i <= ey; i++) {\n    bool flag = true;\n    for(int j = 0; j < 5; j++) {\n      if(data[i][j] != 1) {\n\tflag = false;\n\tbreak;\n      }\n    }\n    if(flag) {\n      breakLine(data, i);\n      i--;\n    }\n  }\n}\n\nint main() {\n  while(1) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n\n    int data[H_MAX][5];\n\n    for(int i = 0; i < H_MAX; i++) {\n      for(int j = 0; j < 5; j++) {\n\tif(i == 0) data[i][j] = 1;\n\telse      data[i][j] = 0;\n      }\n    }\n\n    for(int i = 0; i < n; i++) {\n      int d, p, q, qy;\n      cin >> d >> p >> q;\n      q--;\n      for(int y = H_MAX-1; y >= 0; y--) {\n\tbool put = false;\n\tswitch(d) {\n\tcase 1:\n\t  for(int j = 0; j < p; j++) {\n\t    if(data[y][q+j] == 1) {\n\t      put = true;\n\t      y++;\n\t      qy = y;\n\t      for(int k = 0; k < p; k++) {\n\t\tdata[y][q+k] = 1;\n\t      }\n\t      break;\n\t    }\n\t  }\n\t  break;\n\tcase 2:\n\t  if(data[y][q] == 1) {\n\t    put = true;\n\t    y++;\n\t    qy = y;\n\t    for(int j = 0; j < p; j++) {\n\t      data[y+j][q] = 1;\n\t    }\n\t  }\n\t  break;\n\t}\n\tif(put) {\n\t  break;\n\t}\n      }\n\n      switch(d) {\n      case 1: search(data, qy, qy); break;\n      case 2: search(data, qy, qy+p-1); break;\n      }\n    }\n\n    int count = 0;\n    for(int i = 1; i < H_MAX; i++) {\n      for(int j = 0; j < 5; j++) {\n\tcount += data[i][j];\n      }\n    }\n    cout << count << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar field[5010][5];\n\nvoid add_block(bool const isPortrait, int const len, int const pos) {\n  if(isPortrait) {\n    for(int i=0; i<len; i++) {\n      field[5000+len-1-i][pos] = '*';\n    }\n  }\n  else {\n    for(int i=0; i<len; i++) {\n      field[5000][pos+i] = '*';\n    }\n  }\n}\n\nvoid simulate() {\n  for(int k=0; k<5005; k++) {\n    for(int j=0; j<5; j++) {\n      for(int i=0; i<5005; i++) {\n\tif(field[i][j] == '.' && field[i+1][j] == '*') {\n\t  field[i][j] = '*';\n\t  field[i+1][j] = '.';\n\t}\n      }\n    }\n  }\n}\n\nvoid erase_blocks() {\n  for(int i=0; i<5005; i++) {\n    bool ok = true;\n    for(int j=0; j<5; j++) {\n      ok = ok && field[i][j] == '*';\n    }\n    if(ok) {\n      for(int j=0; j<5; j++) {\n\tfield[i][j] = '.';\n      }\n    }\n    else {\n      break;\n    }\n  }\n}\n\nint main() {\n  \n  int N;\n  \n  while(cin >> N && N) {\n    \n    fill(field[0], field[0]+5010*5, '.');\n    \n    for(int i=0; i<N; i++) {\n      int d, p, q; cin >> d >> p >> q; d--; q--;\n      add_block((bool)d, p, q);\n      simulate();\n      erase_blocks();\n      simulate();\n    }\n    \n    int ans = 0;\n    for(int i=0; i<5000; i++) {\n      for(int j=0; j<5; j++) {\n\tans += field[i][j] == '*';\n      }\n    }\n    \n    cout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nconst int SIZE = 1001;\nconst int HEIGHT = 5001;\nint n;\nint D[SIZE], P[SIZE], Q[SIZE];\nbool B[HEIGHT][5];\n\nint solve() {\n    fill( (bool*)B, (bool*)B+HEIGHT*5, false );\n    \n    \n    for ( int i = 0; i < n; ++ i ) {\n        int d = D[i], p = P[i], q = Q[i];\n        if ( d == 1 ) {\n            bool flag2 = true;\n            for ( int j = HEIGHT - 1; j >= 0; -- j ) {\n                bool flag = false;\n                for ( int k = 0; k < p; ++ k ) {\n                    if ( B[j][q+k] ) flag = true;\n                }\n                if ( flag ) {\n                    for ( int k = 0; k < p; ++ k ) {\n                        B[j+1][q+k] = true;\n                    }\n                    flag2 = false;\n                    break;\n                }\n            }\n            if ( flag2 ) {\n                for ( int k = 0; k < p; ++ k ) {\n                    B[0][q+k] = true;\n                }\n            }\n        } else if ( d == 2 ) {\n            bool flag2 = true;\n            for ( int j = HEIGHT - 1; j >= 0; -- j ) {\n                bool flag = false;\n                for ( int k = 0; k < p; ++ k ) {\n                    if ( B[j+k][q] ) flag = true;\n                }\n                if ( flag ) {\n                    for ( int k = 0; k < p; ++ k ) {\n                        B[j+k+1][q] = true;\n                    }\n                    flag2 = false;\n                    break;\n                }\n            }\n            if ( flag2 ) {\n                for ( int k = 0; k < p; ++ k ) {\n                    B[k][q] = true;\n                }\n            }\n        }\n\n        \n        \n        for ( int j = HEIGHT - 1; j >= 0; -- j ) {\n            bool flag = true;\n            for ( int k = 0; k < 5; ++ k ) {\n                if ( ! B[j][k] ) flag = false;\n            }\n            if ( flag ) {\n                for ( int k = j + 1; k < HEIGHT; ++ k ) {\n                    for ( int l = 0; l < 5; ++ l ) {\n                        B[k-1][l] = B[k][l];\n                    }\n                    for ( int l = 0; l < 5; ++ l ) {\n                        B[k][l] = false;\n                    }\n                }\n            }\n        }\n\n        \n    }\n    int res = 0;\n    for ( int i = 0; i < HEIGHT; ++ i ) {\n        for ( int j = 0; j < 5; ++ j ) {\n            if ( B[i][j] ) res ++;\n        }\n    }\n    return res;\n}\n\nint main() {\n    while ( cin >> n && n ) {\n        for ( int i = 0; i < n; ++ i ) {\n            cin >> D[i] >> P[i] >> Q[i];\n            Q[i] --;\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\tflg = flg && board[h_max][j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tfor(int k = h_max; k < top[j]; k++) {\n\t\t\t\t\t\t\tboard[k][j] = board[k + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\n\t\t\t\tint h = top[q - 1];\n\t\t\t\ttop[q - 1] += p;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tflg = flg && board[h + j - del][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tdel++;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tboard[h + j + 1 - del][k] = board[h + j + 1][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tfor(int k = h + p - del; k < top[j] + 10; k++) {\n\t\t\t\t\t\tboard[k][j] = board[k + del][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tans += board[i][j];\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t   for(int i = 10; i >= 0; i--) {\n\t\t   for(int j = 0; j < 5; j++) {\n\t\t   cout << (board[i][j] ? '*' : '.');\n\t\t   }\n\t\t   cout << endl;\n\t\t   }\n\t\t   cout << endl;\n\t\t// */\n\t\t/*\n\t\t   for(int i = 0; i < 5; i++)\n\t\t   cout << top[i] << \" \";\n\t\t   cout << endl;\n\t\t// */\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/08/10 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0)\n\t\t\tbreak;\n\n\t\tint T[5000][5];\n\t\tfor(int i=0; i<5000; i++)\n\t\t\tfor(int j=0; j<5; j++)\n\t\t\t\tT[i][j] = 0;\n\t\tint I1 = 0;\n\t\tint I2 = 0;\n\n\t\tint N = 0;\n\n\t\tfor(int k=0; k<n; k++){\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d==1){\n\t\t\t\tint i;\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(i=I1-1; i>=I2; i--){\n\t\t\t\t\tfor(int j=0; j<p; j++){\n\t\t\t\t\t\tif(T[i][q-1+j]!=0){\n\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!flg)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int j=0; j<p; j++)\n\t\t\t\t\tT[i+1][q-1+j] = 1;\n\t\t\t\tif(I1<i+2)\n\t\t\t\t\tI1 = i+2;\n\t\t\t}\n\t\t\telse if(d==2){\n\t\t\t\tint i;\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(i=I1-1; i>=I2; i--){\n\t\t\t\t\tfor(int j=0; j<p; j++){\n\t\t\t\t\t\tif(T[i+j][q-1]!=0){\n\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!flg)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int j=0; j<p; j++)\n\t\t\t\t\tT[i+1+j][q-1] = 1;\n\t\t\t\tif(I1<i+1+p)\n\t\t\t\t\tI1 = i+1+p;\n\t\t\t}\n\n\t\t\tN += p;\n\n\t\t\tfor(int i=I2; i<I1; i++)\n\t\t\t\tif(T[i][0]==1&&T[i][1]==1&&T[i][2]==1&&T[i][3]==1&&T[i][4]==1){\n\t\t\t\t\tT[i][0] = 9;\n\t\t\t\t}\n\n\n\t\t\tfor(int i=I2; i<I1; i++)\n\t\t\t\tif(T[i][0]==9){\n\t\t\t\t\tN -= 5;\n\t\t\t\t\tfor(int j=i; j<I1-1; j++){\n\t\t\t\t\t\tT[j][0] = T[j+1][0];\n\t\t\t\t\t\tT[j][1] = T[j+1][1];\n\t\t\t\t\t\tT[j][2] = T[j+1][2];\n\t\t\t\t\t\tT[j][3] = T[j+1][3];\n\t\t\t\t\t\tT[j][4] = T[j+1][4];\n\t\t\t\t\t}\n\t\t\t\t\tI1--;\n\t\t\t\t\ti--;\n\t\t\t\t}\n\n\t\t}\n/*\n\t\tfor(int i=I2; i<I1; i++){\n\t\t\tfor(int j=0; j<5; j++)\n\t\t\t\tcout << T[i][j];\n\t\t\tcout << endl;\n\t\t}\t\t\t\t\n*/\n\t\tcout << N << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\n#define chmax(a,x) a=max(a,x)\n\nvector<bool> F[5];\n\nvoid dump() {\n  rep(j, 10) {\n    rep(i, 5) {\n      if(j>=int(F[i].size())) cout << 0;\n      else cout << F[i][j];\n    }\n    cout << endl;\n  }\n}\n\nbool eraser(int idx) {\n  \n  rep(i, 5) {\n    if((int)F[i].size() <= idx) { return false; }\n    if(!F[i][idx]) { return false; }\n  }\n  \n  rep(i, 5)\n    F[i].erase(F[i].begin()+idx);\n  \n  rep(i, 5) {\n    while(1) {\n      if(!F[i].empty() && !F[i].back()) { F[i].pop_back(); }\n      else { break; }\n    }\n  }\n  \n  return true;\n}\n\nint main() {\n  \n  for(int N; cin>>N && N;) {\n    rep(i, 5) F[i].clear();\n    rep(i, N) {\n      int type, len, pos; cin >> type >> len >> pos; pos --;\n      if(type == 1) {\n\tint mx = -1;\n\tREP(i, pos, pos+len) { chmax(mx, int(F[i].size())); }\n\tREP(i, pos, pos+len) {\n\t  REP(j, F[i].size(), mx) {\n\t    F[i].push_back(false);\n\t  }\n\t  F[i].push_back(true);\n\t}\n\teraser(mx);\n      }\n      else {\n\trep(i, len) { F[pos].push_back(true); }\n\tint cnt = 0;\n\trep(i, len) { if(!eraser((int)F[pos].size()-1-cnt)) cnt++; }\n      }\n    }\n    int sum = 0;\n    rep(i, 5) rep(j, F[i].size()) sum += F[i][j];\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/08/10 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0)\n\t\t\tbreak;\n\n\t\tint T[5000][5];\n\t\tfor(int i=0; i<5000; i++)\n\t\t\tfor(int j=0; j<5; j++)\n\t\t\t\tT[i][j] = 0;\n\t\tint I1 = 0;\n\t\tint I2 = 0;\n\n\t\tint N = 0;\n\n\t\tfor(int k=1; k<=n; k++){\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d==1){\n\t\t\t\tint i;\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(i=I1-1; i>=I2; i--){\n\t\t\t\t\tfor(int j=0; j<p; j++){\n\t\t\t\t\t\tif(T[i][q-1+j]!=0){\n\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!flg)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int j=0; j<p; j++)\n\t\t\t\t\tT[i+1][q-1+j] = k;\n\t\t\t\tif(I1<i+2)\n\t\t\t\t\tI1 = i+2;\n\t\t\t}\n\t\t\telse if(d==2){\n\t\t\t\tint i;\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(i=I1-1; i>=I2; i--){\n\t\t\t\t\tfor(int j=0; j<p; j++){\n\t\t\t\t\t\tif(T[i+j][q-1]!=0){\n\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!flg)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int j=0; j<p; j++)\n\t\t\t\t\tT[i+1+j][q-1] = k;\n\t\t\t\tif(I1<i+1+p)\n\t\t\t\t\tI1 = i+1+p;\n\t\t\t}\n\n\t\t\tN += p;\n\n\t\t\tfor(int i=I2; i<I1; i++)\n\t\t\t\tif(T[i][0]!=0&&T[i][1]!=0&&T[i][2]!=0&&T[i][3]!=0&&T[i][4]!=0){\n\t\t\t\t\tN -= 5;\n\t\t\t\t\tI2++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\tfor(int i=I2; i<I1; i++)\n\t\t\t\tif(T[i][0]!=0&&T[i][1]!=0&&T[i][2]!=0&&T[i][3]!=0&&T[i][4]!=0){\n\t\t\t\t\tN -= 5;\n\t\t\t\t\tfor(int j=i; j<I1-1; j++){\n\t\t\t\t\t\tT[j][0] = T[j+1][0];\n\t\t\t\t\t\tT[j][1] = T[j+1][1];\n\t\t\t\t\t\tT[j][2] = T[j+1][2];\n\t\t\t\t\t\tT[j][3] = T[j+1][3];\n\t\t\t\t\t\tT[j][4] = T[j+1][4];\n\t\t\t\t\t}\n\t\t\t\t\tI1--;\n/*\n\t\t\t\t\tfor(int j=I2+1; j<I1; j++){\n\t\t\t\t\t\tint j1, j2;\n\t\t\t\t\t\tfor(j1=0; j1<5; j1++){\n\t\t\t\t\t\t\tfor(j2=j1; j2<5; j2++)\n\t\t\t\t\t\t\t\tif(T[j][j2]!=T[j][j1])\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\tj2--;\n\t\t\t\t\t\t\tint flg2 = true;\n\t\t\t\t\t\t\tfor(int j3=j1; j3<=j2; j3++)\n\t\t\t\t\t\t\t\tif(T[j-1][j3]!=0){\n\t\t\t\t\t\t\t\t\tflg2 = false;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(flg2)\n\t\t\t\t\t\t\t\tfor(int j3=j1; j3<=j2; j3++){\n\t\t\t\t\t\t\t\t\tT[j-1][j3] = T[j][j3];\n\t\t\t\t\t\t\t\t\tT[j][j3] = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tj1 = j2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int j=I1-1; j>=I2; j--)\n\t\t\t\t\t\tif(T[j][0]==0&&T[j][1]==0&&T[j][2]==0&&T[j][3]==0&&T[j][4]==0)\n\t\t\t\t\t\t\tI1--;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tbreak;\n*/\n\t\t\t\t}\n\n\t\t}\n/*\n\t\tfor(int i=I2; i<I1; i++){\n\t\t\tfor(int j=0; j<5; j++)\n\t\t\t\tcout << T[i][j];\n\t\t\tcout << endl;\n\t\t}\t\t\t\t\n*/\n\t\tcout << N << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint n, d, p, q;\n\nint main()\n{\n    cin >> n;\n    \n    vector<vetcor<bool> > c(5000, vector<int>(5, false));\n    \n    for(int i = 0; i < n; i++)\n    {\n        cin >> d >> p >> q;\n        \n        if(d == 1)\n        {\n            int maxh = -1;\n            \n            for(int j = p - 1; j < p + q - 1; j++)\n            {\n                int r = 5000;\n                \n                while(r--)\n                {\n                    if(c[r][j] == true)\n                    {\n                        break;\n                    }\n                }\n                \n                maxh = max(maxh, r + 1);\n            }\n            \n            for(int j = p - 1; j < p + q - 1; j++)\n            {\n                c[maxh][j] = true;\n            }\n        }\n        else\n        {\n            int r = 5000;\n            \n            while(r--)\n            {\n                if(c[r][p] == true)\n                {\n                    break;\n                }\n            }\n            \n            for(int j = r + 1; j < r + q + 1; j++)\n            {\n                c[j][p] = true;\n            }\n        }\n    }\n    \n    int sum = 0;\n    \n    for(int i = 0; i < 5000; i++)\n    {\n        for(int j = 0; j < 5; j++)\n        {\n            sum += (c[j][p] ? 1 : 0);\n        }\n    }\n    \n    cout << sum << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dat[5000][5];\nint m[5];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<5000;i++)\n\t\t\tfor(int j=0;j<5;j++)dat[i][j]=0;\n\t\tfor(int i=0;i<5;i++)m[i]=0;\n\t\tint count=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b,c,d;\n\t\t\tscanf(\"%d%d%d\",&b,&c,&d);d--;\n\t\t\tcount+=c;\n\t\t\tif(b==2){\n\t\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\t\tdat[m[d]+i][d]=1;\n\t\t\t\t\tbool ok=true;\n\t\t\t\t\tfor(int j=0;j<5;j++)if(!dat[m[d]+i][j])ok=false;\n\t\t\t\t\tif(ok){\n\t\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\t\tdat[m[d]+i][j]=0;\n\t\t\t\t\t\t\tfor(int k=m[d]+i;k<4999;k++)dat[k][j]=dat[k+1][j];\n\t\t\t\t\t\t\tm[j]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount-=5;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tm[d]+=c;\n\t\t\t}else{\n\t\t\t\tint h=0;\n\t\t\t\tfor(int i=0;i<c;i++)h=max(h,m[i+d]);\n\t\t\t\tfor(int i=0;i<c;i++)dat[h][i+d]=1;\n\t\t\t\tfor(int i=0;i<c;i++)m[i+d]=h+1;\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int j=0;j<5;j++)if(!dat[h][j])ok=false;\n\t\t\t\tif(ok){\n\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\tdat[m[d]+i][j]=0;\n\t\t\t\t\t\tfor(int k=h;k<4999;k++)dat[k][j]=dat[k+1][j];\n\t\t\t\t\t\tm[j]--;\n\t\t\t\t\t}\n\t\t\t\t\tcount-=5;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint grid[5][6000];\nint n,d,p,q;\nll int ans = 0;\n\nint GetBottom(int x){\n\tREP(i,6000){\n\t\tif(grid[x][i]==-1) return i;\n\t}\n\treturn 0;\n}\n\nbool isallclear(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=-1) return false;\n\t}\n\treturn true;\n}\n\nbool isallblock(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(cin>>n,n){\n\t\tREP(i,5) REP(j,6000) grid[i][j] = -1;\n\t\tREP(i,n){\n\t\t\tcin >> d >> p >> q;\n\t\t\tif(d==2){\n\t\t\t\tint tmp = GetBottom(q-1);\n\t\t\t\tFOR(j,tmp,tmp+p) grid[q-1][j] = 1;\n\t\t\t}else{\n\t\t\t\tint tmp = -1;\n\t\t\t\tFOR(j,q-1,q-1+p){\n\t\t\t\t\ttmp = max(tmp,GetBottom(j));\n\t\t\t\t}\n\t\t\t\tFOR(j,q-1,q-1+p) {\n\t\t\t\t\tgrid[j][tmp] = 1;\n\t\t\t\t\tREP(k,tmp) if(grid[j][k]==-1) grid[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowline = 0;\n\t\t\twhile(1){\n\t\t\t\tif(isallclear(nowline)) break;\n\t\t\t\tif(isallblock(nowline)){\n\t\t\t\t\tREP(j,5) {\n\t\t\t\t\t\tint nline = nowline+1;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tif(grid[j][nline]==-1) {\n\t\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\tnline++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnowline = 0;\n\t\t\t\t}else{\n\t\t\t\t\tnowline++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tint line = 0;\n\t\twhile(1){\n\t\t\tif(isallclear(line)) break;\n\t\t\tREP(i,5){\n\t\t\t\tif(grid[i][line]==1) ans++;\n\t\t\t}\n\t\t\tline++;\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d==1&&q-1+p>5)\n\t\t\t\tabort();\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\tflg = flg && board[h_max][j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tfor(int k = h_max; k < top[j]; k++) {\n\t\t\t\t\t\t\tboard[k][j] = board[k + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\n\t\t\t\tint h = top[q - 1];\n\t\t\t\ttop[q - 1] += p;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tflg = flg && board[h + j][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tboard[h + j - del][k] = board[h + j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdel++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tfor(int k = h + p - del; k < top[j] + 10; k++) {\n\t\t\t\t\t\tboard[k][j] = board[k + del][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tans += board[i][j];\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t   for(int i = 10; i >= 0; i--) {\n\t\t   for(int j = 0; j < 5; j++) {\n\t\t   cout << (board[i][j] ? '*' : '.');\n\t\t   }\n\t\t   cout << endl;\n\t\t   }\n\t\t   cout << endl;\n\t\t// */\n\t\t/*\n\t\t   for(int i = 0; i < 5; i++)\n\t\t   cout << top[i] << \" \";\n\t\t   cout << endl;\n\t\t// */\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint x[10000][5], m[5], maxn, sum;\nint n;\nint a, b, c;\nint main() {\n\twhile (true) {\n\t\tsum = 0;\n\t\tmaxn = 0;\n\t\tmemset(x, 0, sizeof(x));\n\t\tmemset(m, 0, sizeof(m));\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int h = 0; h < n; h++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tc--;\n\t\t\tif (a == 1) {\n\t\t\t\tmaxn = 0;\n\t\t\t\tfor (int j = c; j < c + b; j++) {\n\t\t\t\t\tmaxn = max(maxn, m[j]);\n\t\t\t\t}\n\t\t\t\tfor (int j = c; j < c + b; j++) {\n\t\t\t\t\tx[maxn][j] = 1;\n\t\t\t\t\tm[j] = maxn + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\t\tx[m[c] + j][c] = 1;\n\t\t\t\t}\n\t\t\t\tm[c] += b;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 10000; i++) {\n\t\t\t\tif (x[i][0] + x[i][1] + x[i][2] + x[i][3] + x[i][4] == 5) {\n\t\t\t\t\tx[i][0] = 0; x[i][1] = 0; x[i][2] = 0; x[i][3] = 0; x[i][4] = 0;\n\t\t\t\t\tfor (int j = i; j < 9999; j++) {\n\t\t\t\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tx[j][k] = x[j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx[9999][0] = 0; x[9999][1] = 0; x[9999][2] = 0; x[9999][3] = 0; x[9999][4] = 0;\n\t\t\t\t\ti--;\n\t\t\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\t\t\tfor (int k = m[j]; k >= 0; k--) {\n\t\t\t\t\t\t\tif (x[k][j] == 1) {\n\t\t\t\t\t\t\t\tm[j] = k + 1; goto E;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tm[j] = 0;\n\t\t\t\t\tE:;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 10000; i++) {\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\tsum += x[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int LIMIT_HEIGHT = 5000;\n\nint main()\n{\n  int n;\n  bool grid[LIMIT_HEIGHT + 1][5];\n  bool killed[LIMIT_HEIGHT + 1];\n\n  while(cin >> n, n) {\n    fill_n(*grid, (LIMIT_HEIGHT + 1) * 5, false);\n\n\n    int d, p, q;\n    while(n--) {\n      cin >> d >> p >> q;\n      --q;\n      if(d == 1) { // 横向きのブロック\n        for(int i = LIMIT_HEIGHT; i >= 0; i--) {\n          bool flag = false;\n          for(int j = 0; j < p; j++) {\n            if(i == 0 || grid[i - 1][j + q]) {\n              flag = true;\n              for(int k = 0; k < p; k++) {\n                grid[i][k + q] = true;\n              }\n              break;\n            }\n          }\n          if(flag) break;\n        }\n        \n      } else { // 縦向きのブロック\n        for(int i = LIMIT_HEIGHT - p; i >= 0; i--) {\n          if(i == 0 || grid[i - 1][q]) {\n            for(int j = i; j < i + p; j++) {\n              grid[j][q] = true;\n            }\n            break;\n          }\n        }\n      }\n\n      for(int i = 0; i < LIMIT_HEIGHT; i++) {\n        bool flag = true;\n        for(int j = 0; j < 5; j++) {\n          flag &= grid[i][j];\n        }\n        killed[i] = flag;\n      }\n      int counter = 0;\n      for(int i = 0; i < LIMIT_HEIGHT; i++) {\n        while(i + counter < LIMIT_HEIGHT && killed[i + counter]) counter++;\n     \n        for(int j = 0; j < 5; j++) {\n          if(i + counter >= LIMIT_HEIGHT) grid[i][j] = false;\n          else grid[i][j] = grid[i + counter][j];\n        }\n      }\n    }\n    int ret = 0;\n    for(int i = 0; i < LIMIT_HEIGHT; i++) {\n      for(int j = 0; j < 5; j++) {\n        ret += grid[i][j];\n      }\n    }\n    cout << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n \nusing namespace std;\n \nconst int Height = 5500;\nconst int Width = 5;\nchar field[Height][Width];\nint top,ans;\nint dx[] = {1,0};\nint dy[] = {0,-1};\n \n \nvoid print(int h, int w){\n \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl;\n     \n}\nbool isInside(int h, int w){return 0<=h&&h<Height&&0<=w&&w<Width;}\n \nint getH(int d, int len, int pos){\n  for(int i = top+1; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?' || !isInside(h,w)) return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n}\n\nvoid down(int n){\n\n  for(int i = n; i <= top+5; i++)\n    for(int j = 0; j < Width; j++) field[i][j] = field[i+1][j];\n\n}\n\nvoid erase(){\n\n  for(int i = 0; i <= top; i++){\n    bool f = true;\n    for(int j = 0; j < Width; j++) if(field[i][j] == '?') f = false;\n    if(f){\n      for(int j = 0; j < Width; j++) field[i][j] = '?';\n      ans -= 5;\n      down(i--);\n    }\n  }\n}\n \nvoid put(int d, int len, int pos){\n \n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n \n  int h = nex;\n  int w = pos;\n \n  for(int i = 0; i < len; i++){\n    field[h][w] = '.';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n \nint main(){\n \n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    ans = top = 0;\n    \n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      ans += len;\n      put(d-1,len,pos-1);\n      erase();\n    }\n    cout << ans << endl;\n    //  print(10,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int LIMIT = 5001;\n\nint main()\n{\n\tint n;\n\n\twhile( cin >> n && n )\n\t{\n\t\tbool map[ LIMIT ][ 5 ] = {0};\n\t\tint h[ 5 ] = {0};\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\t\t\tq -= 1;\n\n\t\t\tint w = ( d == 1 ? p : 1 );\n\t\t\tint hh = 0;\n\t\t\tfor( int i = 0; i < w; ++i ){\n\t\t\t\thh = max( hh, h[ q + i ] );\n\t\t\t}\n\t\t\tif( d == 1 ){\n\t\t\t\tfor( int i = 0; i < w; ++i ){\n\t\t\t\t\tmap[ hh ][ q + i ] = true;\n\t\t\t\t\th[ q + i ] = hh + 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor( int i = 0; i < p; ++i ){\n\t\t\t\t\tmap[ hh + i ][ q ] = true;\n\t\t\t\t}\n\t\t\t\th[ q ] = hh + p;\n\t\t\t}\n\n\t\t\tfor( int i = 0; i < 5; ++i ){\n\t\t\t\thh = max( hh, h[ i ] );\n\t\t\t}\n\t\t\tfor( int i = 0; i < hh; ++i ){\n\t\t\t\tbool full = true;\n\t\t\t\tfor( int j = 0; j < 5; ++j ){\n\t\t\t\t\tif( !map[ i ][ j ] ){\n\t\t\t\t\t\tfull = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( full ){\n\t\t\t\t\tfor( int j = i; j < hh; ++j ){\n\t\t\t\t\t\tfor( int k = 0; k < 5; ++k ){\n\t\t\t\t\t\t\tmap[ j ][ k ] = map[ j + 1 ][ k ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor( int j = 0; j < 5; ++j ){\n\t\t\t\t\t\t--h[ j ];\n\t\t\t\t\t}\n\t\t\t\t\t--hh;\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint hh = 0;\n\t\tfor( int i = 0; i < 5; ++i ){\n\t\t\thh = max( hh, h[ i ] );\n\t\t}\n\t\tint ans = 0;\n\t\tfor( int i = 0; i < hh; ++i ){\n\t\t\tfor( int j = 0; j < 5; ++j ){\n\t\t\t\tif( map[ i ][ j ] ) ++ans;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint fall(vector<vector<int>>&field, vector<vector<int>>&pino,int l) {\n\tint y = 0;\n\tfor ( y = 0; y < field.size() - pino.size(); ++y) {\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < pino.size(); ++i) {\n\t\t\tfor (int j = 0; j < pino[i].size(); ++j) {\n\t\t\t\tif (pino[i][j]) {\n\t\t\t\t\tif (field[y + i+1][l + j])ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < pino.size(); ++i) {\n\t\tfor (int j = 0; j < pino[i].size(); ++j) {\n\t\t\tif (pino[i][j]) {\n\t\t\t\tassert(!field[y + i][l + j]);\n\t\t\t\tfield[y + i][l + j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint delline = 0;\n\tfor (int i = y + pino.size() - 1; i >= y; --i) {\n\t\twhile (all_of(field[i].begin(), field[i].end(), [](const int a) {return a == 1; })) {\n\t\t\ttransform(field[i].begin(), field[i].end(), field[i].begin(), [](const int a) {return false; });\n\t\t\tfor (int j = i- 1; j >= 0; --j) {\n\t\t\t\tswap(field[j], field[j + 1]);\n\t\t\t}\n\t\t\tdelline += 1;\n\t\t}\n\t}\n\treturn delline;\n}\n\nint main() {\n\tint N;\n\twhile (cin>>N,N) {\n\t\tint sum = 0;\n\t\tvector<vector<int>>field(5*N+1, vector<int>(5));\n\t\twhile(N--){\n\t\t\tint d, p, q; cin >> d >> p >> q; q--;\n\t\t\tsum += p;\n\t\t\tvector<vector<int>>pino(d == 1 ? 1 : p, vector<int>(d == 2 ? 1 : p, 1));\n\t\t\tsum -= fall(field, pino, q) * 5;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint grid[5][5010];\nint n,d,p,q;\nll int ans = 0;\n\nint GetBottom(int x){\n\tREP(i,5000){\n\t\tif(grid[x][i]==-1) return i;\n\t}\n\treturn 0;\n}\n\nbool isallclear(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=-1) return false;\n\t}\n\treturn true;\n}\n\nbool isallblock(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n;\n\t\tREP(i,5) REP(j,5000) grid[i][j] = -1;\n\t\tREP(i,n){\n\t\t\tcin >> d >> p >> q;\n\t\t\tif(d==2){\n\t\t\t\tint tmp = GetBottom(q-1);\n\t\t\t\tFOR(j,tmp,tmp+p) grid[q-1][j] = 1;\n\t\t\t}else{\n\t\t\t\tint tmp = -1;\n\t\t\t\tFOR(j,q-1,q-1+p){\n\t\t\t\t\ttmp = max(tmp,GetBottom(j));\n\t\t\t\t}\n\t\t\t\tFOR(j,q-1,q-1+p) {\n\t\t\t\t\tgrid[j][tmp] = 1;\n\t\t\t\t\tREP(k,tmp) if(grid[j][k]==-1) grid[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowline = 0;\n\t\t\twhile(1){\n\t\t\t\tif(isallclear(nowline)) break;\n\t\t\t\tif(isallblock(nowline)){\n\t\t\t\t\tREP(j,5) {\n\t\t\t\t\t\tint nline = nowline+1;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tif(grid[j][nline]==-1) {\n\t\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\tnline++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tnowline++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tint line = 0;\n\t\twhile(1){\n\t\t\tif(isallclear(line)) break;\n\t\t\tREP(i,5){\n\t\t\t\tif(grid[i][line]==1) ans++;\n\t\t\t}\n\t\t\tline++;\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int n,d,p,q;\n\n  for(;;){\n    cin >> n;\n    if(!n)break;\n\n    vector<string> board;\n    for(int z=0;z<n;z++){\n      cin >> d >> p >> q;\n\n      int x,y;\n      if(d==1){\n\tx = p;\n\ty = 1;\n      }else{\n\tx = 1;\n\ty = p;\n      }\n\n      int tmp = -1;\n      for(int i=0;i<x;i++){\n\tfor(int j=(int)board.size()-1;j>=0;j--){\n\t  if(board[j][q+i-1]=='#'){\n\t    tmp = max(tmp,j);\n\t    break;\n\t  }\n\t}\n      }\n      for(int i=tmp+1;i<(int)board.size();i++){\n\tfor(int j=0;j<x;j++)board[i][q+j-1] = '#';\n\ty--;\n\tif(!y)break;\n      }\n\n      string block;\n      for(int i=0;i<q-1;i++)block.push_back('.');\n      for(int i=0;i<x;i++)block.push_back('#');\n      while(block.size()<5)block.push_back('.');\n      while(y--)board.push_back(block);\n\n      for(int i=0;i<(int)board.size();i++){\n\tbool f = true;\n\tfor(int j=0;j<5;j++)\n\t  if(board[i][j] == '.')f = false;\n\tif(f){\n\t  board.erase(board.begin()+i);\n\t  i--;\n\t}\n      }\n      /*\n      for(int i=0;i<(int)board.size();i++)cout << board[i] << endl;\n      cout << endl;\n      */\n    }\n    int ans = 0;\n    for(int i=0;i<(int)board.size();i++)\n      for(int j=0;j<5;j++)\n\tif(board[i][j] == '#')ans++;\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define N 10020\nusing namespace std;\nint main(){\n  while(true){\n    int n;\n    int ans=0;\n    scanf(\"%d\",&n);\n\n    if(n==0)break;\n    int row[N]={0,};\n    int h[5]={0,};\n    for(int i = 0; i < n; ++i){\n      int mh = 0;\n      int d,p,q;\n      scanf(\"%d%d%d\", &d, &p, &q);\n      --q;\n      \n      if(d==1){\n\tint maxh = 0;\n\tfor(int j = q; j < q + p; ++j){\n\t  maxh = max( maxh, h[j] );\n\t}\n\tfor(int j = q; j < q + p; ++j){\n\t  h[j] = maxh + 1;\n\t}\n\trow[maxh]+=p;\n      }else{\n\tfor(int j = h[q]; j < p + h[q]; ++j){\n\t  ++row[ j ];\n\t}\n\th[q]+=p;\n      }\n\n      // cout << \" DROPPED : \" << i << endl;\n      for(int j = 0; j < 5; ++j){\n\tmh = max( mh , h[j] );\n      }\n\n      for(int j = 0; j < mh; ++j){\n\t// cout << \" row[\"<<j<<\"] = \" << row[j] << endl;\n\tif( row[j] == 5 ){\n\t  for(int k = 0; k < 5; ++k){\n\t    --h[k];\n\t    if(h[k]<0)=h[k]=0;\n\t  }\n\t  for(int k = j; k < mh+2; ++k){\n\t    row[k] = row[k + 1];\n\t  }\n\t  j = -1;\n\t  continue;\n\t}\n      }\n    }\n    for(int i = 0; i < N; ++i){\n      ans += row[i];\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n#define rep2(x,from,to) for(int x=(from);x<(to);++(x))\n#define rep(x,to) rep2(x,0,to)\nint main(){\n\tint n, d, p, q;\n\twhile(cin >> n, n) {\n\t\tbool b[5010][5] = {};\n\t\tint up = 0;\n\t\trep(i,n) {\n\t\t\tcin >> d >> p >> q;\n\t\t\t--q;\n\t\t\tbool f = 1;\n\t\t\tif(d == 1) {\n\t\t\t\tfor(int j=up-1;j>=0;--j) {\n\t\t\t\t\trep2(i,q,p+q) {\t\t\t\t\n\t\t\t\t\t\tif(b[j][i]) {\n\t\t\t\t\t\t\trep2(k,q,p+q) {\n\t\t\t\t\t\t\t\tb[j+1][k] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tup = j == up-1 ? up+1 : up;\n\t\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!f) break;\n\t\t\t\t}\n\t\t\t\tif(f) {\n\t\t\t\t\trep2(i,q,p+q) {\n\t\t\t\t\t\tb[0][i] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tup = up == 0 ? 1 : up;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tfor(int j=up-1;j>=0;--j) {\n\t\t\t\t\tif(b[j][q]) {\n\t\t\t\t\t\trep2(i,1,p+1) {\n\t\t\t\t\t\t\tb[j+i][q] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tup = up <= j+p+1 ? j+p+1 : up;\n\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(f) {\n\t\t\t\t\trep(i,p) {\n\t\t\t\t\t\tb[i][q] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tup = up < p ? p : up;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint cnt = 0;\n\t\t\trep(i,up) {\n\t\t\t\tbool c = 1;\n\t\t\t\trep(j,5) {\n\t\t\t\t\tif(!b[i][j]) {\n\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(c) {\n\t\t\t\t\trep2(j,i,up) {\n\t\t\t\t\t\trep(k,5) {\n\t\t\t\t\t\t\tb[j][k] = b[j+1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ti--;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tup -= cnt;\n\t\t}\n\t\tint ret = 0;\n\t\trep(i,up) {\n\t\t\trep(j,5) {\n\t\t\t\tif(b[i][j]) ret++;\n\t\t\t}\n\t\t}\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint n;\n\ntypedef struct Block\n{\n\tint d;\n\tint p;\n\tint q;\n} B;\n\nint F[5000][5];\nint H[5];\n\nB blocks[1000];\n\nint highest(int r, int l)\n{\n\tint max = 0;\n\tfor(int i=r; i<l; i++)\n\t{\n\t\tif(max < H[i])\n\t\t{\n\t\t\tmax =H[i];\n\t\t}\n\t}\n\treturn max;\n}\n\nvoid yoko_set(B b)\n{\n\tint hp = highest(b.q, b.p+b.q);\n\tfor(int i=b.q; i<b.p+b.q; i++)\n\t{\n\t\tF[hp][i] =1;\n\t\tH[i] = hp+1;\n\t}\n}\n\nvoid tate_set(B b)\n{\n\tint hp = H[b.q];\n\tfor(int i=hp; i<hp+b.p; i++)\n\t{\n\t\tF[i][b.q] = 1;\n\t}\n\tH[b.q] = hp+b.p;\n}\n\nvoid col_clear()\n{\n\t\n\tint hp = highest(0, 5);\n\tbool is_ok = false;\n\tvector<int> cols;\n\tfor(int i=0; i<=hp; i++)\n\t{\n\t\tis_ok =true;\n\t\tfor(int j=0; j<5; j++)\n\t\t{\n\t\t\tif(F[i][j]==1) continue;\n\t\t\tis_ok = false;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(is_ok)\n\t\t{\n\t\t\tcols.push_back(i);\n\t\t}\n\t}\n\t\n\tif(cols.empty()) return;\n\t\n\tint c = 0;\n\tfor(int i=0; i<hp; i++)\n\t{\n\t\tif(cols[c]==i)\n\t\t{\n\t\t\tc++;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int j=0; j<5; j++)\n\t\t{\n\t\t\tF[i-c][j] = F[i][j];\n\t\t}\n\t}\n\t\n\tfor(int i=hp-cols.size(); i<hp; i++)\n\t{\n\t\tfor(int j=0; j<5; j++)\n\t\t{\n\t\t\tF[i][j] = 0;\n\t\t}\n\t}\n\t\n\tfor(int j=0; j<5; j++)\n\t{\n\t\tint max = -1;\n\t\tfor(int i=0; i<hp; i++)\n\t\t{\n\t\t\tif(F[i][j]==1)\n\t\t\t{\n\t\t\t\tmax = i;\n\t\t\t}\n\t\t}\n\t\tH[j] = max+1;\n\t}\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tcin >> blocks[i].d;\n\t\t\tcin >> blocks[i].p;\n\t\t\tcin >> blocks[i].q;\n\t\t\tblocks[i].q--;\n\t\t}\n\t\t\n\t\tmemset(&F[0][0], 0, sizeof(int)*25000);\n\t\tmemset(&H[0], 0, sizeof(int)*5);\n\t\t\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tif(blocks[i].d == 2)\n\t\t\t{\n\t\t\t\ttate_set(blocks[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tyoko_set(blocks[i]);\n\t\t\t}\n\t\t\t\n\t\t\tcol_clear();\n\t\t}\n\t\t\n\t\tint hp = highest(0, 5);\n\t\tint c = 0;\n\t\tfor(int i=0; i<hp; i++)\n\t\t{\n\t\t\tfor(int j=0; j<5; j++)\n\t\t\t{\n\t\t\t\tif(F[i][j]==1) c++;\n\t\t\t}\n\t\t}\n\t\tcout << c<< endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cassert>\n#include <functional>\n#include <iostream>\n#include <iomanip>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long Long;\n#define Whole(xs) xs.begin(), xs.end()\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& vs) {\n    if (vs.empty()) return os << \"[]\";\n    os << \"[\" << vs[0];\n    for (int i = 0; i < vs.size(); i++) os << \" \" << vs[i];\n    return os << \"]\";\n}\nostream& operator<<(ostream& os, const vector<int>& vs) {\n    if (vs.empty()) return os << \"[]\";\n    bool flag = false;\n    os << \"[\";\n    for (int i = 0; i < vs.size(); i++) {\n        if (flag) {\n            os << \" \";\n        } else {\n            flag = true;\n        }\n        for (int j = 0; j < 5; j++) {\n            os << ( (vs[i] & (1 << j)) > 0 );\n        }\n    }\n    return os << \"]\";\n}\n\nconst int IINF = 1<<28;\nconst Long LINF = 1LL<<56;\n#define INF IINF\n\nint N;\nvector<int> F;\nbool Input() {\n    cin >> N;\n    F.clear();\n    return N != 0;\n}\n\nvoid WSet(int Q, int P) {\n    int R = 0;\n    for (int i = Q; i < Q + P; i++) {\n        R ^= (1 << i);\n    }\n    if (F.empty()) {\n        F.push_back(R);\n    } else{\n        if ((F.back() & R) == 0) {\n            F.back() ^= R;\n        } else {\n            F.push_back(R);\n        }\n    }\n}\n\nvoid HSet(int Q, int P) {   \n    if (F.empty()) {\n        for (int i = 0; i < P; i++) {\n            F.push_back(1 << Q);\n        }\n        return;\n    }\n    int Rem = P;\n    for (int i = F.size() - 1; i >= -1; i--) {\n        if (i < 0 || F[i] & (1 << Q)) {\n            for (int j = i + 1, c = 0; c < P && j < F.size(); c++, j++) {\n                Rem--;\n                F[j] ^= (1 << Q);\n            }\n            break;\n        }\n    }\n    for (int i = 0; i < Rem; i++) {\n        F.push_back(1 << Q);\n    }\n}\n\nvoid Fall() {\n    vector<int> nF;\n    for (int i = 0; i < F.size(); i++) {\n        if (F[i] != (1 << 5) - 1) {\n            nF.push_back(F[i]);\n        }\n    }\n    F = nF;\n}\n\nvoid Solve() {\n    for (int n = 0; n < N; n++) {\n        int D, P, Q; cin >> D >> P >> Q;\n        Q--;\n        if (D == 1) {\n            WSet(Q, P);\n        } else {\n            HSet(Q, P);\n        }\n        //cout << F << endl;\n        Fall();\n    }\n    //cout << F << endl;\n    int Ans = 0;\n    for (int i = 0; i < F.size(); i++) {\n        for (int j = 0; j < 5; j++) {\n            if (F[i] & (1 << j)) {\n                Ans++;\n            }\n        }\n    }\n    cout << Ans << endl;\n}\n\nint main() {\n    while (Input()) {\n        Solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nbool t[5001][5];\nint u[5];\nvoid init();\nvoid make_table();\nvoid move(int);\nint n;\nint d,p,q,cnt;\nint main(){\n\n  while(cin>>n&&n!=0){\n    init();\n    for(int i=0;i<n;i++){\n      cin>>d>>p>>q;\n      q--;\n      make_table();\n    }\n    cnt=0;\n    for(int i=0;i<5000;i++)for(int j=0;j<5;j++)if(t[i][j])cnt++;\n    cout<<cnt<<endl;\n  }  \n  return 0;\n}\n\nvoid init(){\n  for(int i=0;i<=5000;i++){\n    for(int j=0;j<5;j++){\n      t[i][j]=false;\n    }\n  }\n  for(int i=0;i<5;i++)u[i]=0;\n}\n\nvoid make_table(){\n  int h;\n  if(d==1){\n    h=0;\n    for(int j=q;j<q+p;j++)h=max(h,u[j]);\n    for(int j=q;j<q+p;j++){t[h][j]=true;u[j]=h+1;}\n  }else{\n    h=u[q];\n    for(int i=h;i<h+p;i++)t[i][q]=true;\n    u[q]+=p;\n  }\n\n\n\n\n\n  /*\n  h=0;\n  for(int j=0;j<5;j++)h=max(h,u[j]);\n\n  for(int i=0;i<h+1;i++){\n    if(t[i][0]&&t[i][1]&&t[i][2]&&t[i][3]&&t[i][4]){\n      for(int j=0;j<5;j++){\n\tt[i][j]=false;\n      }\n    }\n  }\n \n  \n\n\n      \n  int H=0;\n  for(int i=0;i<=5000;i++){\n    if(t[i][0]||t[i][1]||t[i][2]||t[i][3]||t[i][4]){\n      for(int j=0;j<5;j++){\n\tt[H][j]=t[i][j];\n\tif(H!=i)t[i][j]=false;\n      }\n      H++;\n    }\n  }\n  */\n  /*\n  for(int I=7;I>=0;I--){\n    for(int j=0;j<5;j++){\n      cout<<(int)t[I][j];\n    }\n    cout<<endl;\n  }\n  cout<<endl;\n  */\n  \n  for(int i=0;i<5000;i++){\n    while(1){\n      if(t[i][0]&&t[i][1]&&t[i][1]&&t[i][2]&&t[i][3]&&t[i][4]){\n\tmove(i);\n\t//cout<<i<<endl;\n\t/*\n\tfor(int I=7;I>=0;I--){\n\t  for(int j=0;j<5;j++){\n\t    cout<<(int)t[I][j];\n\t  }\n\t  cout<<endl;\n\t}\n\tcout<<endl;\n\t*/\n\n\n\t\n      }else{\n\tbreak;\n      }\n    }\n  }\n\n\n\n  \n\n  for(int j=0;j<5;j++){\n    u[j]=0;\n    for(int i=4999;i>=0;i--){\n      if(t[i][j]){\n\tu[j]=i+1;\n\tbreak;\n      }\n    }\n  }\n\n  //for(int i=0;i<5;i++)cout<<u[i]<<' ';cout<<endl;\n\n}\n\nvoid move(int x){\n  for(int j=0;j<5;j++){\n    for(int i=x;i<5000;i++){\n      t[i][j]=t[i+1][j];\n    }\n  }\n  for(int j=0;j<5;j++)t[5000][j]=false;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tdeque<int>E[5];\n\t\trep(i, n) {\n\t\t\tint d, p, q; scanf(\"%d%d%d\", &d, &p, &q); q--;\n\t\t\tif (d == 1) {\n\t\t\t\tint Max = 0;\n\t\t\t\trep(i, p)Max = max(Max, (int)E[q + i].size());\n\t\t\t\trep(i, p) {\n\t\t\t\t\tint k = E[q + i].size();\n\t\t\t\t\trep(j, Max - k)E[q + i].push_back(0);\n\t\t\t\t\tE[q + i].push_back(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep(i, p)E[q].push_back(1);\n\t\t\t}\n\t\t\tint Min = INT_MAX;\n\t\t\trep(i, 5)Min = min(Min, (int)E[i].size());\n\t\t\trep(i, Min) {\n\t\t\t\tbool ok = true;\n\t\t\t\trep(j, 5)ok &= E[j][i];\n\t\t\t\tif(ok)rep(j, 5)E[j][i] = -1;\n\t\t\t}\n\t\t\trep(i, 5)E[i].erase(remove(E[i].begin(), E[i].end(), -1), E[i].end());\n\t\t}\n\t\tint sum = 0;\n\t\trep(i, 5)rep(j, E[i].size()) {\n\t\t\tif (E[i][j])sum++;\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\nusing namespace std;\n#define W 5\n#define H 5000\n#define BLANK 0\n#define BLOCK 1\nint main()\n{\n  int n,d,p,q;\n  int field[H+2][W];\n  int i,j,k;\n  bool flag;\n  int count;\n  while(cin>>n,n){\n    for(i=0;i<H+1;i++)for(j=0;j<W;j++)field[i][j]=BLANK;\n    for(j=0;j<W;j++)field[i][j]=BLOCK;\n    while(n-->0){\n      cin>>d>>p>>q;\n      if(d==1){\n\tj=q-1;\n\tflag=false;\n\tfor(i=0;i<H+2;i++){\n\t  for(k=0;k<p;k++)if(field[i][j+k]==BLOCK)flag=true;\n\t  if(flag){\n\t    for(k=0;k<p;k++)field[i-1][j+k]=BLOCK;\n\t    break;\n\t  }\n\t}\n      }\n      if(d==2){\n\tj=q-1;\n\tfor(i=0;i<H+2;i++){\n\t  if(field[i][j]==BLOCK){\n\t    for(k=1;k<=p;k++)field[i-k][j]=BLOCK;\n\t    break;\n\t  }\n\t}\n      }\n      for(i=H;i>=0;i--){\n\tflag=true;\n\tfor(j=0;j<W;j++)if(field[i][j]==BLANK)flag=false;\n\tif(flag){\n\t  for(j=0;j<W;j++)field[i][j]=BLANK;\n\t  for(k=i;k>0;k--)for(j=0;j<W;j++)field[k][j]=field[k-1][j];\n\t  i++;\n\t}\n      }\n    }\n    count=0;\n    for(i=H-8;i<H+1;i++)for(j=0;j<W;j++)if(field[i][j]==BLOCK)count++;\n    cout<<count<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <string>\n#include <queue>\n#define MAX 200\nusing namespace std;\n\nint main(void){\n\tint i,j,k,n,ans;\n\tbool f[5][MAX];\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tfor(i=0;i<5;i++){\n\t\t\tfor(j=0;j<MAX;j++) f[i][j] = false;\n\t\t}\n\t\tans = 0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tint d,p,q;\n\t\t\tcin >> d >> p >> q;\n\t\t\tq--;\n\t\t\tans += p;\n\t\t\tif(d == 2){\n\t\t\t\tfor(j=MAX-1;j>=0;j--){\n\t\t\t\t\tif(j == 0 || f[q][j-1] == true){\n\t\t\t\t\t\tfor(k=j;k<j+p;k++) f[q][k] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(j=MAX-1;j>=0;j--){\n\t\t\t\t\tk=5;\n\t\t\t\t\tif(j != 0){\n\t\t\t\t\t\tfor(k=q;k<q+p;k++) if(f[k][j-1] == true) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(j == 0 || k != q+p){\n\t\t\t\t\t\tfor(k=q;k<q+p;k++) f[k][j] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<MAX;j++){\n\t\t\t\tfor(k=0;k<5;k++) if(f[k][j] == false) break;\n\t\t\t\tif(k == 5){\n\t\t\t\t\tans -= 5;\n\t\t\t\t\tfor(k=0;k<5;k++){\n\t\t\t\t\t\tfor(int t=j;t<MAX-1;t++) f[k][t] = f[k][t+1];\n\t\t\t\t\t\tf[k][MAX-1] = false;\n\t\t\t\t\t}\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t}\n\t\t//\t\t\tcout << endl;\n\t\t//\t\tfor(int ii=7;ii>=0;ii--){\n\t\t//\tfor(j=0;j<5;j++) cout << f[j][ii] << \" \";\n\t\t//\tcout << endl;\n\t\t//}\n\t\t//cout << endl;\n\t\t}\n\t\tcout << ans << endl;\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar stage[2][5000][5];\n\nint main()\n{\n    int n;\n    \n    while (scanf(\"%d\", &n) && n){\n        int height[5] = {0};\n        int turn = 0;\n        int ct = 0;\n        memset(stage, 0, sizeof(stage));\n        for (int rep = 0; rep < n; rep++){\n            int d, p, q;\n            scanf(\"%d %d %d\", &d, &p, &q); --q;\n            if (d == 1){\n                int mh = *max_element(height + q, height + p + q);\n                for (int j = q; j < p + q; j++){\n                    stage[turn][mh][j] = 1;\n                    height[j] = mh + 1;\n                }\n            }\n            else {\n                for (int j = 0; j < p; j++){\n                    stage[turn][height[q]++][q] = 1;\n                }\n            }\n            \n            int look = *max_element(height, height + 5);\n            memset(stage[1 - turn], 0, sizeof(stage[1 - turn]));\n            memset(height, 0, sizeof(height));\n            ct = 0;\n            int nh = 0;\n            for (int i = 0; i < look; i++){\n                bool ok = true;\n                for (int j = 0; j < 5; j++){\n                    if (stage[turn][i][j] == 0) ok = false;\n                }\n                if (!ok){\n                    for (int j = 0; j < 5; j++){\n                        stage[1 - turn][nh][j] = stage[turn][i][j];\n                        if (stage[1 - turn][nh][j]){\n                            height[j] = nh + 1;\n                            ct++;\n                        }\n                    }\n                    nh++;\n                }\n            }\n            turn = 1 - turn;\n        }\n        \n        printf(\"%d\\n\", ct);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint n, d, p, q;\n\nint main()\n{\n    cin >> n;\n    \n    vector<vector<bool> > c(5000, vector<int>(5, false));\n    \n    for(int i = 0; i < n; i++)\n    {\n        cin >> d >> p >> q;\n        \n        if(d == 1)\n        {\n            int maxh = -1;\n            \n            for(int j = p - 1; j < p + q - 1; j++)\n            {\n                int r = 5000;\n                \n                while(r--)\n                {\n                    if(c[r][j] == true)\n                    {\n                        break;\n                    }\n                }\n                \n                maxh = max(maxh, r + 1);\n            }\n            \n            for(int j = p - 1; j < p + q - 1; j++)\n            {\n                c[maxh][j] = true;\n            }\n        }\n        else\n        {\n            int r = 5000;\n            \n            while(r--)\n            {\n                if(c[r][p] == true)\n                {\n                    break;\n                }\n            }\n            \n            for(int j = r + 1; j < r + q + 1; j++)\n            {\n                c[j][p] = true;\n            }\n        }\n    }\n    \n    int sum = 0;\n    \n    for(int i = 0; i < 5000; i++)\n    {\n        for(int j = 0; j < 5; j++)\n        {\n            sum += (c[j][p] ? 1 : 0);\n        }\n    }\n    \n    cout << sum << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint fld[5005][5];\nvoid put1(int l,int p){\n    int curr=5000;\n    while(curr>=0){\n        bool flag=true;\n        for(int j=p;j<p+l;j++){\n            if(fld[curr][j])flag=false;\n        }\n        if(flag)curr--;\n        else break;\n    }\n\n    for(int j=p;j<p+l;j++)fld[curr+1][j]=1;\n}\nvoid put2(int l,int p){\n    int curr=5000;\n    while(curr>=0){\n        bool flag=true;\n        for(int i=curr;i<curr+l;i++)if(fld[i][p])flag=false;\n        if(flag)curr--;\n        else break;\n    }\n    for(int i=curr+1;i<curr+1+l;i++)fld[i][p]=1;\n}\n\nvoid del(){\n    int curr=0;\n    for(int i=0;i<5000;i++){\n        bool flag=true;\n        for(int j=0;j<5;j++)if(fld[i][j]==0)flag=false;\n        if(flag){\n            for(int j=0;j<5;j++)fld[i][j]=0;\n            continue;\n        }\n        for(int j=0;j<5;j++)fld[curr][j]=fld[i][j];\n        curr++;\n    }\n}\n\nvoid debug(int h){\n    for(int i=h;i>=0;i--){\n        for(int j=0;j<5;j++){\n            printf(\"%d\",fld[i][j]);\n        }\n        puts(\"\");\n    }\n}\n\nint main(){\n    int n;\n    while(scanf(\"%d\",&n),n){\n        fill_n(*fld,5005*5,0);\n        while(n--){\n            int d,l,p;\n            scanf(\"%d%d%d\",&d,&l,&p);\n            p--;\n            if(d==1)put1(l,p);\n            else put2(l,p);\n\n            del();\n\n\n            //debug(10);\n        }\n\n\n        int ans=0;\n        for(int i=0;i<5000;i++){\n            for(int j=0;j<5;j++)ans+=fld[i][j];\n        }\n\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nint ban[5010][5];\nint d,p,q;\n\nvoid clear(int h){\n\tint i,j;\n\tbool no;\n\tfor(i=0;i<(d==1?1:p);i++){\n\t\tno=true;\n\t\tfor(j=0;j<5;j++){\n\t\t\tif(ban[h+i][j]==0)no=false;\n\t\t}\n\t\tif(no){\n\t\t\tint k;\n\t\t\tfor(k=h+i+1;k<5010;k++){\n\t\t\t\tfor(j=0;j<5;j++){\n\t\t\t\t\tban[k-1][j]=ban[k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\ti--;\n\t\t}\n\t}\n}\n\nint fall(){\n\tint i,j;\n\tif(d==2){\n\t\tfor(i=5005;i>=0;i--){\n\t\t\tif(ban[i][q])break;\n\t\t}\n\t\ti++;\n\t\tfor(j=0;j<p;j++){\n\t\t\tban[i+j][q]=1;\n\t\t}\n\t}else{\n\t\tfor(i=5005;i>=0;i--){\n\t\t\tfor(j=0;j<p;j++){\n\t\t\t\tif(ban[i][q+j])goto aaa;\n\t\t\t}\n\t\t}\n\t\taaa:;\n\t\ti++;\n\t\tfor(j=0;j<p;j++){\n\t\t\tban[i][q+j]=1;\n\t\t}\t\t\n\t}\n\treturn i;\n}\n\nint main() {\n\tint n;\n\twhile(n=in()){\n\t\tmemset(ban,0,sizeof(ban));\n\t\tint i;\n\t\tfor(i=0;i<n;i++){\n\t\t\tcin>>d>>p>>q;\n\t\t\tq--;\n\t\t\tclear(fall());\n\t\t\t//int x,y;\n\t\t\t//for(y=10;y>=0;y--){\n\t\t\t//\tfor(x=0;x<5;x++){\n\t\t\t//\t\tcout<<ban[y][x];\n\t\t\t//\t}\n\t\t\t//\tcout<<endl;\n\t\t\t//}\n\t\t\t//cout<<endl;\n\t\t}\n\t\tint j;\n\t\tint res=0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;j<5;j++){\n\t\t\t\tif(ban[i][j])res++;\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dat[5000][5];\nint m[5];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<5000;i++)\n\t\t\tfor(int j=0;j<5;j++)dat[i][j]=0;\n\t\tfor(int i=0;i<5;i++)m[i]=0;\n\t\tint count=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b,c,d;\n\t\t\tscanf(\"%d%d%d\",&b,&c,&d);d--;\n\t\t\tcount+=c;\n\t\t\tif(b==2){\n\t\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\t\tdat[m[d]+i][d]=1;\n\t\t\t\t\tbool ok=true;\n\t\t\t\t\tfor(int j=0;j<5;j++)if(!dat[m[d]+i][j])ok=false;\n\t\t\t\t\tif(ok){\n\t\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\t\tdat[m[d]+i][j]=0;\n\t\t\t\t\t\t\tfor(int k=m[d]+i;k<4999;k++)dat[k][j]=dat[k+1][j];\n\t\t\t\t\t\t\tm[j]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount-=5;\n\t\t\t\t\t}\n\t\t\t\t//\tm[d]++;\n\t\t\t\t}\n\t\t\t\tm[d]+=c;\n\t\t\t}else{\n\t\t\t\tint h=0;\n\t\t\t\tfor(int i=0;i<c;i++)h=max(h,m[i+d]);\n\t\t\t\tfor(int i=0;i<c;i++)dat[h][i+d]=1;\n\t\t\t\tfor(int i=0;i<c;i++)m[i+d]=h+1;\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int j=0;j<5;j++)if(!dat[h][j])ok=false;\n\t\t\t\tif(ok){\n\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\tdat[h][j]=0;\n\t\t\t\t\t\tfor(int k=h;k<4999;k++)dat[k][j]=dat[k+1][j];\n\t\t\t\t\t\tm[j]--;\n\t\t\t\t\t}\n\t\t\t\t\tcount-=5;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint n, d, p, q;\n\nint main()\n{\n    while(true)\n    {\n        cin >> n;\n        \n        if(n == 0) { break; }\n        \n        vector<vector<bool> > c(5000, vector<bool>(5, false));\n        \n        for(int i = 0; i < n; i++)\n        {\n            cin >> d >> p >> q;\n            \n            if(d == 1)\n            {\n                int maxh = -1;\n                \n                for(int j = p - 1; j < p + q - 1; j++)\n                {\n                    int r = 5000;\n                    \n                    while(r--)\n                    {\n                        if(c[r][j] == true)\n                        {\n                            break;\n                        }\n                    }\n                    \n                    maxh = max(maxh, r + 1);\n                }\n                \n                for(int j = p - 1; j < p + q - 1; j++)\n                {\n                    c[maxh][j] = true;\n                }\n            }\n            else\n            {\n                int r = 5000;\n            \n                while(r--)\n                {\n                    if(c[r][p] == true)\n                    {\n                        break;\n                    }\n                }   \n                \n                for(int j = r + 1; j < r + q + 1; j++)\n                {\n                    c[j][p] = true;\n                }\n            }   \n            \n            for(int j = 0; j < 5000; i++)\n            {\n                if(c[j][0] == c[j][1] && c[j][1] == c[j][2] && c[j][2] == c[j][3] && c[j][3] == c[j][4])\n                {\n                    for(int k = j + 1; k < 5000; k++)\n                    {\n                        for(int l = 0; l < 5; l++)\n                        {\n                            c[k - 1][l] = c[k][l];\n                        }\n                    }\n                }\n            }\n        }    \n    \n        int sum = 0;\n    \n        for(int i = 0; i < 5000; i++)\n        {\n            for(int j = 0; j < 5; j++)\n            {\n                sum += (c[j][p] ? 1 : 0);\n            }\n        }\n        \n        cout << sum << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n\nusing namespace std;\n\n#define int long long\n\nlist<bool*> fld;\n\nlist<bool*>::iterator GetHeight(int l, int r)\n{\n\tlist<bool*>::iterator itr = fld.begin();\n\titr++;\n\tfor (; itr != fld.end(); itr++)\n\t{\n\t\tfor (int j = l; j < r; j++)\n\t\t{\n\t\t\tif ((*itr)[j] == true) return --itr;\n\t\t}\n\t}\n\treturn --itr;\n}\n\nbool IsFull(list<bool*>::iterator itr)\n{\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif ((*itr)[i] == false) return false;\n\t}\n\treturn true;\n}\n\nbool IsEmpty(list<bool*>::iterator itr)\n{\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif ((*itr)[i] == true) return false;\n\t}\n\treturn true;\n}\n\nvoid Drop(int d, int p, int q)\n{\n\tif (!IsEmpty(fld.begin())) fld.push_front((bool*)new bool[5]{});\n\tint l = q - 1, r = (d == 1) ? l + p : l + 1;\n\tlist<bool*>::iterator itr = GetHeight(l, r);\n\n\tint h = (d == 1) ? 1 : p;\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tif (itr == fld.begin()) fld.push_front((bool*)new bool[5]{});\n\t\tfor (int j = l; j < r; j++)\n\t\t{\n\t\t\t(*itr)[j] = true;\n\t\t}\n\t\tif (IsFull(itr))\n\t\t{\n\t\t\tdelete *itr;\n\t\t\titr = fld.erase(itr);\n\t\t}\n\t\titr--;\n\t}\n}\n\nsigned main()\n{\n\tint N;\n\twhile (cin >> N, N)\n\t{\n\t\tfld.clear();\n\t\tfor (int i = 0; i < 2; i++) fld.push_back((bool*)new bool[5]{});\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\t\t\tDrop(d, p, q);\n\t\t}\n\t\tint ans = 0;\n\t\tfor (list<bool*>::iterator itr = fld.begin(); itr != fld.end(); itr++)\n\t\t{\n\t\t\tfor (int i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tans += ((*itr)[i] == true);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint a[5000][5];\nint main() {\n\tint n;\n\twhile (cin >> n&&n != 0) {\n\t\tlong long sum = 0;\n\t\tint h = 0;\n\t\tfor (int i = 0; i < 5000; i++)\n\t\t\tfill(a[i], a[i] + 5, 0);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\t\t\tq--;\n\t\t\tif (d == 1) {\n\t\t\t\tint k = h;\n\t\t\t\tfor (int j = h; j >= 0; j--) {\n\t\t\t\t\tbool b = true;\n\t\t\t\t\tfor (int z = q; z < (p + q); z++) {\n\t\t\t\t\t\tif (a[j][z] == 1) b = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (b)\n\t\t\t\t\t\tk = j;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int z = q; z < (p + q); z++) {\n\t\t\t\t\ta[k][z] = 1;\n\t\t\t\t}\n\t\t\t\tif (k >= h) h = k+1;\n\t\t\t\tsum += p;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint k = h;\n\t\t\t\tfor (int j = h; j >= 0; j--) {\n\t\t\t\t\tbool b = true;\n\t\t\t\t\tfor (int z = 0; z < p; z++) {\n\t\t\t\t\t\tif (a[j + z][q] == 1) b = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (b)\n\t\t\t\t\t\tk = j;\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor (int z = 0; z < p; z++) {\n\t\t\t\t\ta[k + z][q] = 1;\n\t\t\t\t}\n\t\t\t\tif (k + p > h) h = k + p;\n\t\t\t\tsum += p;\n\t\t\t}\n\t\t\tfor (int i = h; i >= 0; i--) {\n\t\t\t\tbool b = true;\n\t\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\t\tif (a[i][j] == 0) b = false;\n\t\t\t\t}\n\t\t\t\tif (b) {\n\t\t\t\t\tfor (int j = i; j <= h+1; j++) {\n\t\t\t\t\t\tfor (int z = 0; z < 5; z++) {\n\t\t\t\t\t\t\ta[i][z] = a[i + 1][z];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\th--;\n\t\t\t\t\tsum -= 5;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tif (a[i][0] == 1 && a[i][1] == 1 && a[i][2] == 1 && a[i][3] == 1 && a[i][4] == 1)\n\t\t\t\tsum -= 5;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n\tint N;\n\twhile(scanf(\"%d\", &N), N)\n\t{\n\t\tint hei=0;\n\t\tbool f[5005][5]={0};\n\t\t\n\t\twhile(N--)\n\t\t{\n\t\t\tint d,p,q;\n\t\t\tscanf(\"%d%d%d\", &d,&p,&q);\n\t\t\tp--; q--;\n\t\t\t\n\t\t\tint h=hei+1;\n\t\t\twhile(1)\n\t\t\t{\n\t\t\t\tif(h==0) break;\n\t\t\t\tbool g=true;\n\t\t\t\tfor(int i=q; i<=q+(d==1?p:0); i++)\n\t\t\t\t{\n\t\t\t\t\tif(f[h-1][i]) \n\t\t\t\t\t{\n\t\t\t\t\t\tg=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!g) break;\n\t\t\t\th--;\n\t\t\t}\n\t\t\thei=max(hei, h+(d==1?0:p));\n\t\t\tfor(int i=h; i<=h+(d==1?0:p); i++)\n\t\t\tfor(int j=q; j<=q+(d==1?p:0); j++)\n\t\t\t{\n\t\t\t\tf[i][j]=1;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=h; i<=hei; i++)\n\t\t\t{\n\t\t\t\twhile(1)\n\t\t\t\t{\n\t\t\t\t\tbool g=true;\n\t\t\t\t\tfor(int j=0; j<5; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(f[i][j]==0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tg=false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!g) break;\n\t\t\t\t\t\n\t\t\t\t\tfor(int k=i; k<=hei+1; k++)\n\t\t\t\t\tfor(int j=0; j<5; j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tf[k][j]=f[k+1][j];\n\t\t\t\t\t\tf[k+1][j]=0;\n\t\t\t\t\t}\n\t\t\t\t\thei--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\n\t\t}\n\t\t\n\t\tint cnt=0;\n\t\tfor(int i=0; i<5; i++)\n\t\tfor(int j=0; j<=hei; j++)\n\t\t{\n\t\t\tif(f[j][i]) cnt++;\n\t\t}\n\t\t\t\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define MAX_N 1000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstatic const double eps = 1e-8;\n\nint gStage[3000][5];\n\nvoid putBlock(int dir,int len,int pos){\n\tif(dir == 1){\n\t\tfor(int i=3000-1;i>=0;i--){\n\t\t\tbool isok=true;\n\t\t\tfor(int j=pos;j<pos+len;j++){\n\t\t\t\tif(gStage[i][j]==1) isok=false;\n\t\t\t}\n\t\t\t\n\t\t\tif(!isok){\n\t\t\t\tfor(int j=pos;j<pos+len;j++){\n\t\t\t\t\tgStage[i+1][j] = 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\telse if(isok && i==0){\n\t\t\t\tfor(int j=pos;j<pos+len;j++){\n\t\t\t\t\tgStage[i+1][j] = 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=3000-1;i>=0;i--){\n\t\t\tbool isok=true;\n\t\t\tif(gStage[i][pos]==1) isok=false;\n\n\t\t\tif(!isok){\n\t\t\t\tfor(int j=i+1;j<i+1+len;j++){\n\t\t\t\t\tgStage[j][pos] = 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\telse if(isok && i==0){\n\t\t\t\tfor(int j=i;j<i+len;j++){\n\t\t\t\t\tgStage[j][pos] = 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint countBlock(){\n\tint res=0;\n\tfor(int i=0;i<3000;i++){\n\t\tfor(int j=0;j<5;j++){\n\t\t\tres += gStage[i][j];\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvoid eraseBlock(){\n\tfor(int i=0;i<3000;i++){\n\t\tbool isok=true;\n\t\tfor(int j=0;j<5;j++){\n\t\t\tif(gStage[i][j]==0) isok = false;\n\t\t}\n\n\t\tif(isok){\n\t\t\tfor(int j=i;j+1<3000;j++){\n\t\t\t\tfor(int k=0;k<5;k++){\n\t\t\t\t\tgStage[j][k] = gStage[j+1][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\ti--;\n\t\t}\n\t}\n}\n\nvoid printBlock(){\n\tfor(int i=0;i<50;i++){\n\t\tfor(int j=0;j<5;j++){\n\t\t\tprintf(\"%d\",gStage[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n}\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\n\t\tmemset(gStage,0,sizeof(gStage));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint dir,len,pos;\n\t\t\tscanf(\"%d %d %d\",&dir,&len,&pos);\n\t\t\tpos-=1;\n\t\t\tputBlock(dir,len,pos);\n\t\t\t//printBlock();\n\t\t\teraseBlock();\n\t\t\t//printBlock();\n\t\t}\n\n\t\tprintf(\"%d\\n\",countBlock());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint main(){\n  int N;\n  while(cin >> N && N){\n    const int H = 5010;\n    const int W = 5;\n    bool block[H][W] = {};\n    int height[W] = {};\n    int n_h = 0;\n    REP(iter, N){\n      int d, l, bx;\n      cin >> d >> l >> bx;\n      bx --;\n      if(d == 1){\n        // yoko\n        int h = 0;\n        for(int x = bx; x < bx + l; x++) h = max(h, height[x]);\n        for(int x = bx; x < bx + l; x++) block[h][x] = true;\n        bool line = true;\n        for(int x = 0; x < W; x++) if(!block[h][x]) line = false;\n        if(line){\n          for(int x = 0; x < W; x++) block[h][x] = false;\n        }\n      }else if(d == 2){\n        // tate\n        for(int y = height[bx]; y < height[bx] + l; y++)\n          block[y][bx] = true;\n        for(int y = height[bx]; y < height[bx] + l; y++){\n          bool line = true;\n          for(int x = 0; x < W; x++) if(!block[y][x]) line = false;\n          if(!line) continue;\n          for(int x = 0; x < W; x++) block[y][x] = false;\n        }\n      }\n      bool new_block[H][W] = {};\n      int new_height[W] = {};\n      int new_nh = 0;\n      int curr = 0;\n      /*\n      for(int y = n_h + 5; y >= 0; y--){\n        debug(block[y], block[y] + 5);\n      }\n      cout << endl;\n      */\n      for(int y = 0; y < n_h + 5; y++){\n        bool clear = true;\n        for(int x = 0; x < W; x++) if(block[y][x]) clear = false;\n        if(clear) continue;\n        for(int x = 0; x < W; x++)if(block[y][x]){\n          new_block[curr][x] = true;\n          new_height[x] = curr + 1;\n        }\n        new_nh = ++curr;\n      }\n      memcpy(block, new_block, sizeof(block));\n      memcpy(height, new_height, sizeof(height));\n      n_h = new_nh;\n    }\n    int ans = 0;\n    REP(y, H)REP(x, W) ans += block[y][x];\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar stage[2][5001][5];\n\nvoid place(int *height, int col, int d, int len, int pos, int turn)\n{\n    if (d == 1){\n        int mh = *max_element(height + pos, height + pos + len);\n        for (int j = pos; j < pos + len; j++){\n            stage[turn][mh][j] = col;\n            height[j] = mh + 1;\n        }\n    }\n    else {\n        for (int j = 0; j < len; j++){\n            stage[turn][height[pos]++][pos] = col;\n        }\n    }\n    return;\n}\n\nint main()\n{\n    int n;\n    \n    while (scanf(\"%d\", &n) && n){\n        int height[5] = {0};\n        int d[1001] = {0}, len[1001] = {0}, pos[1001] = {0};\n        \n        memset(stage, 0, sizeof(stage));\n        \n        for (int i = 1; i <= n; i++){\n            scanf(\"%d %d %d\", d + i, len + i, pos + i); --pos[i];\n            place(height, i, d[i], len[i], pos[i], 0);\n        }\n        \n        int turn = 0;\n        for (int i = 0; i < n; i++){\n            int ht = *max_element(height, height + 5);\n            \n            for (int j = 0; j < ht; j++){\n                bool ok = true;\n                for (int k = 0; k < 5; k++){\n                    stage[1 - turn][j][k] = 0;\n                    if (!stage[turn][j][k]) ok = false;\n                }\n                if (ok){\n                    for (int k = 0; k < 5; k++){\n                        len[stage[turn][j][k]]--;\n                    }\n                }\n            }\n            \n            memset(height, 0, sizeof(height));\n            for (int j = 1; j <= n; j++){\n                place(height, j, d[j], len[j], pos[j], 1 - turn);\n            }\n            turn = 1 - turn;\n        }\n        \n        int ret = 0;\n        int h = *max_element(height, height + 5);\n        for (int i = 0; i < h; i++){\n            for (int j = 0; j < 5; j++){\n                ret += !!stage[turn][i][j];\n            }\n        }\n        \n        printf(\"%d\\n\", ret);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n\nusing namespace std;\ntypedef pair<int,int> ii;\nint field[5010][5];\nint top[5];\nint n,d,p,q;\nvector<ii> input;\n\n\nvoid print()\n{\n  int st = 0;\n  rep(i,5)st = max(st,top[i]);\n  for(int y=st;y>=0;y--)\n    {\n      rep(x,5)\n\t{\n\t  cout << field[y][x] << \" \";\n\t}\n      cout << endl;\n    }\n}\n\nbool checkX(int y)\n{\n  rep(x,5)if(!field[y][x])return false;\n  return true;\n}\n\nvoid updateD(int x,int y)\n{\n  ii info = input[field[y][x]];\n  if(info.first == 1)\n    {//yoko\n      while(true)\n\t{\n\t  bool check = true;\n\t  rep(i,5)\n\t    {\n\t      if(field[y][x] != field[y][i])continue;\n\t      if(y-1 >= 0 && field[y-1][i] != 0)\n\t\t{\n\t\t  check = false;\n\t\t  break;\n\t\t}\n\t    }\n\t  if(!check)return;\n\t  int v = field[y][x];\n\t  rep(i,5)\n\t    {\n\t      if(v != field[y][i])continue;\n\t      assert(field[y-1][i] == 0);\n\t      field[y-1][i] = field[y][i];\n\t      field[y][i] = 0;\n\t    }\n\t  y = y-1;\n\t  if(y <= 0)return;\n\t}\n    }\n  else\n    {\n      int v = field[y][x];\n    \n      int bot = 0;\n      int py = y;\n      while(py-1 >= 0 && field[py-1][x] == 0)py--;\n      bot = y-py;\n\n      if(bot == 0)return;\n\n      while(v == field[y][x])\n\t{\n\t  assert(y-bot >= 0);\n\t  assert(field[y-bot][x] == 0);\n\t  field[y-bot][x] = field[y][x];\n\t  field[y][x] = 0;\n\t  y++;\n\t}\n\t\n    }\n}\n\nint main()\n{\n  while(cin >> n,n)\n    {\n      input.clear();\n      input.resize(1010,ii(-1,-1));\n      rep(i,5010)rep(j,5)field[i][j] = 0;\n      rep(i,5)top[i] = 0;\n      int cyb,cyt;\n      REP(i,1,n+1)\n\t{\n\t  cin >> d >> p >> q;\n\n\t  if(d == 1 && p == 5)continue;\n\t  q--;\n\t  input[i] = ii(d,p);\n\n\t  if(d == 2)\n\t    {\n\t      cyb = top[q],cyt = top[q]+p;\n\t      REP(j,top[q],top[q]+p)field[j][q] = i;\n\t      top[q] += p;\n\t    }\n\t  else\n\t    {\n\t      int mexico = -inf;\n\t      REP(j,q,q+p)mexico = max(mexico,top[j]);\n\t      REP(j,q,q+p)field[mexico][j] = i;\n\t      cyb = cyt = mexico;\n\t      REP(j,q,q+p)top[j] = mexico+1;\n\t    }\n\n\t  //update top\n\t  \n\t  rep(j,5)\n\t    {\n\t      int y = top[j];\n\t      while(y >= 0 && field[y][j] == 0)y--;\n\t      top[j] = y+1;\n\t    }\n\t  /*\n  cout << \"top = \";\n\t  rep(j,5)cout << top[j] << \" \";\n\t  cout << endl;\n\t  print();\n\n\t  cout << \"----------------\" << endl;\n\t  */\n\t}\n      cyb = 0;\n      rep(i,5)cyt = max(cyt,top[i]);\n      \n      bool update = true;\n      /*\n      while(update)\n\t{\n      */\n\t  update = false;\n\t  //check\n\t  vector<int> erasedY;\n\t  REP(y,cyb,cyt+1)\n\t    {\n\t      if(checkX(y))\n\t\t{\n\t\t  erasedY.push_back(y);\n\t\t  rep(x,5)field[y][x] = 0;\n\t\t}\n\t    }\n\n\t  //print();\n\t  //down\n\t  if(!erasedY.empty())\n\t    {\n\t      update = true;\n\n\t      int yt = 0;\n\t      rep(j,5)yt = max(yt,top[j]);\n\t      rep(j,erasedY.size())\n\t\t{\n\t\t  REP(y,erasedY[j],yt)\n\t\t    {\n\t\t      int pre = -1;\n\t\t      rep(x,5)\n\t\t\t{\n\t\t\t  if(field[y][x] == pre)continue;\n\t\t\t  if(field[y][x] == 0 || y-1 < 0)continue;\n\n\t\t\t  pre = field[y][x];\n\t\t\t  updateD(x,y);\n\t\t\t}\n\t\t    }\n\t\t}\n\n\n\t    }\n\t\n\t  // print();\n\t  /*\t  \n\t}\n\t  */\n\t  \n\t\n      int yt = 0;\n      rep(i,5)yt = max(yt,top[i]);\n      int ans = 0;\n      rep(y,yt)\n\trep(x,5)\n       \t  if(field[y][x] != 0)ans++;\t\n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int n;\n    while(cin>>n,n){\n        queue<int> que[6];\n        for(int i=0,num[3];i<n;i++){\n            for(int j=0;j<3;j++)cin>>num[j];\n            if(num[0]==1)for(int j=0;j<num[1];j++)que[num[2]+j].push(1);\n            else for(int j=0;j<num[1];j++)que[num[2]].push(1);\n            bool kawa=1;\n            while(kawa){\n                for(int j=1;j<6&&kawa;j++)if(que[j].empty())kawa=0;\n                if(kawa)for(int j=1;j<6;j++)que[j].pop();\n            }\n        }\n        int ans=0;\n        for(int i=1;i<6;i++)ans+=(int)que[i].size();\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n\n\nint main(void)\n{\n\tint result[1000], suffix = 0;\n\n\twhile (1) {\n\n\t\tint nblock, direct, len, posit, tetris[1000][6] = { 0 };\n\n\t\tscanf(\"%d\", &nblock);\n\t\tif (nblock == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\tfor (int n = 0; n < nblock; n++) {\n\t\t\tscanf(\"%d %d %d\", &direct, &len, &posit);\n\n\t\t\tint success;\n\t\t\tif (direct == 1) {\n\t\t\t\tfor (int i = 1; i < 1000; i++) {\n\t\t\t\t\tsuccess = 0;\n\t\t\t\t\tfor (int j = posit; j < posit + len; j++) {\n\t\t\t\t\t\tif (tetris[i][j] == 1) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int k = i; k <= i + 7; k++) {\n\t\t\t\t\t\t\tif (tetris[k][j] == 1) {\n\t\t\t\t\t\t\t\tsuccess = 2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (success == 2) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (j == posit + len - 1) {\n\t\t\t\t\t\t\tfor (int k = 0; k < len; k++) {\n\t\t\t\t\t\t\t\ttetris[i][k + posit] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsuccess = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (success == 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = 1; i < 1000; i++) {\n\t\t\t\t\tsuccess = 0;\n\t\t\t\t\tfor (int j = i; j < len + i; j++) {\n\t\t\t\t\t\tif (tetris[j][posit] == 1) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (int k = j; k <= 7; k++) {\n\t\t\t\t\t\t\tif (tetris[k][posit] == 1) {\n\t\t\t\t\t\t\t\tsuccess = 2;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (success == 2) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (j == len + i - 1) {\n\t\t\t\t\t\t\tfor (int k = 0; k < len; k++) {\n\t\t\t\t\t\t\t\ttetris[k + i][posit] = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsuccess = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (success == 1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\telse if (success == 2) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint sum = 0;\n\t\tfor (int i = 1; i <= 1000; i++) {\n\t\t\tint a = 0, b = 0;\n\t\t\tfor (int j = 1; j <= 5; j++) {\n\t\t\t\tif (tetris[i][j] == 0) {\n\t\t\t\t\ta++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tsum++;\n\t\t\t\t\tb++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (a == 5) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse if (b == 5) {\n\t\t\t\tsum -= 5;\n\t\t\t}\n\t\t}\n\n\t\tresult[suffix++] = sum;\n\t}\n\n\tfor (int i = 0; i < suffix; i++) {\n\t\tprintf(\"%d\\n\", result[i]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint grid[5][5010];\nint n,d,p,q;\nll int ans = 0;\n\nint GetBottom(int x){\n\tREP(i,5000){\n\t\tif(grid[x][i]==-1) return i;\n\t}\n\treturn 0;\n}\n\nbool isallclear(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=-1) return false;\n\t}\n\treturn true;\n}\n\nbool isallblock(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\tREP(i,5) REP(j,5000) grid[i][j] = -1;\n\t\tREP(i,n){\n\t\t\tcin >> d >> p >> q;\n\t\t\tif(d==2){\n\t\t\t\tint tmp = GetBottom(q-1);\n\t\t\t\tFOR(j,tmp,tmp+p) grid[q-1][j] = 1;\n\t\t\t}else{\n\t\t\t\tint tmp = -1;\n\t\t\t\tFOR(j,q-1,q-1+p){\n\t\t\t\t\ttmp = max(tmp,GetBottom(j));\n\t\t\t\t}\n\t\t\t\tFOR(j,q-1,q-1+p) {\n\t\t\t\t\tgrid[j][tmp] = 1;\n\t\t\t\t\tREP(k,tmp) if(grid[j][k]==-1) grid[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowline = 0;\n\t\t\twhile(1){\n\t\t\t\tif(isallclear(nowline)) break;\n\t\t\t\tif(isallblock(nowline)){\n\t\t\t\t\tREP(j,5) {\n\t\t\t\t\t\tint nline = nowline+1;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tif(grid[j][nline]==-1) {\n\t\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\tnline++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tnowline++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tint line = 0;\n\t\twhile(1){\n\t\t\tif(isallclear(line)) break;\n\t\t\tREP(i,5){\n\t\t\t\tif(grid[i][line]==1) ans++;\n\t\t\t}\n\t\t\tline++;\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n\nusing namespace std;\n\n#define int long long\n\nlist<bool*> fld;\n\nlist<bool*>::iterator GetHeight(int l, int r)\n{\n\tlist<bool*>::iterator itr = fld.begin();\n\tfor (; itr != fld.end(); itr++)\n\t{\n\t\tbool isAble = true;\n\t\tfor (int j = l; j < r; j++)\n\t\t{\n\t\t\tif ((*itr)[j] == true) isAble = false;\n\t\t}\n\t\tif (!isAble) return --itr;\n\t}\n\treturn --itr;\n}\n\nbool IsFull(list<bool*>::iterator itr)\n{\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif ((*itr)[i] == false) return false;\n\t}\n\treturn true;\n}\n\nbool IsEmpty(list<bool*>::iterator itr)\n{\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif ((*itr)[i] == true) return false;\n\t}\n\treturn true;\n}\n\nvoid Drop(int d, int p, int q)\n{\n\tint l = q - 1, r = (d == 1) ? l + p : l + 1;\n\tlist<bool*>::iterator itr = GetHeight(l, r);\n\n\tint h = (d == 1) ? 1 : p;\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tif (itr == fld.begin()) fld.push_front((bool*)new bool[5]{});\n\t\tfor (int j = l; j < r; j++)\n\t\t{\n\t\t\t(*itr)[j] = true;\n\t\t}\n\t\tif (IsFull(itr))\n\t\t{\n\t\t\tdelete *itr;\n\t\t\titr = fld.erase(itr);\n\t\t}\n\t\titr--;\n\t}\n\n\tif (!IsEmpty(fld.begin())) fld.push_front((bool*)new bool[5]{});\n}\n\nsigned main()\n{\n\tint N;\n\twhile (cin >> N, N)\n\t{\n\t\tfld.clear();\n\t\tfld.push_back((bool*)new bool[5]{});\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\t\t\tDrop(d, p, q);\n\t\t}\n\t\tint ans = 0;\n\t\tfor (list<bool*>::iterator itr = fld.begin(); itr != fld.end(); itr++)\n\t\t{\n\t\t\tfor (int i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tans += ((*itr)[i] == true);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar stage[2][5000][5];\n\nint main()\n{\n    int n;\n    \n    while (scanf(\"%d\", &n) && n){\n        int height[5] = {0};\n        int turn = 0;\n        memset(stage, 0, sizeof(stage));\n        for (int rep = 0; rep < n; rep++){\n            int d, p, q;\n            scanf(\"%d %d %d\", &d, &p, &q); --q;\n            if (d == 1){\n                int mh = *max_element(height + q, height + p + q);\n                for (int j = q; j < p + q; j++){\n                    stage[turn][mh][j] = 1;\n                    height[j] = mh + 1;\n                }\n            }\n            else {\n                for (int j = 0; j < p; j++){\n                    stage[turn][height[q]++][q] = 1;\n                }\n            }\n            \n            int look = *max_element(height, height + 5);\n            memset(height, 0, sizeof(height));\n            int nh = 0;\n            for (int i = 0; i < look; i++){\n                bool ok = true;\n                for (int j = 0; j < 5; j++){\n                    if (stage[turn][i][j] == 0) ok = false;\n                }\n                if (!ok){\n                    memcpy(stage[1 - turn][nh], stage[turn][i], sizeof(stage[turn][i]));\n                    for (int j = 0; j < 5; j++){\n                        if (stage[1 - turn][nh][j]) height[j] = nh + 1;\n                    }\n                    nh++;\n                }\n            }\n            turn = 1 - turn;\n        }\n        \n        int ret = 0;\n        int h = *max_element(height, height + 5);\n        for (int i = 0; i < h; i++){\n            for (int j = 0; j < 5; j++){\n                ret += stage[turn][i][j];\n            }\n        }\n        \n        printf(\"%d\\n\", ret);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n \nusing namespace std;\n \nconst int Height = 5500;\nconst int Width = 5;\nchar field[Height][Width];\nint top,ans;\nint dx[] = {1,0};\nint dy[] = {0,-1};\n \n \nvoid print(int h, int w){\n \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl;\n     \n}\nbool isInside(int h, int w){return 0<=h&&h<Height&&0<=w&&w<Width;}\n \nint getH(int d, int len, int pos){\n  for(int i = Height-1; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?' || !isInside(h,w)) return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n}\n\nvoid down(int n){\n\n  for(int i = n; i < Height; i++)\n    for(int j = 0; j < Width; j++) field[i][j] = field[i+1][j];\n\n}\n\nvoid erase(){\n\n  for(int i = 0; i <= top; i++){\n    bool f = true;\n    for(int j = 0; j < Width; j++) if(field[i][j] == '?') f = false;\n    if(f){\n      ans -= 5;\n      down(i);\n      i--;\n    }\n  }\n}\n \nvoid put(int d, int len, int pos){\n \n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n \n  int h = nex;\n  int w = pos;\n \n  for(int i = 0; i < len; i++){\n    field[h][w] = '.';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n \nint main(){\n \n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    ans = top = 0;\n    \n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      ans += len;\n      put(d-1,len,pos-1);\n      erase();\n    }\n    cout << ans << endl;\n    print(10,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n \nusing namespace std;\n \nconst int Height = 5010;\nconst int Width = 5;\nchar field[Height][Width];\nint top,ans;\nint dx[] = {1,0};\nint dy[] = {0,-1};\n \n \nvoid print(int h, int w){\n \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl;\n     \n}\nbool isInside(int h, int w){return 0<=h&&h<Height&&0<=w&&w<Width;}\n \nint getH(int d, int len, int pos){\n  for(int i = top+1; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?' || !isInside(h,w)) return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n}\n\nvoid down(int n){\n \n  for(int i = n; i <= top+2; i++)\n    for(int j = 0; j < Width; j++) field[i][j] = field[i+1][j];\n  top--;\n}\n\nvoid erase(){\n\n  for(int i = 0; i <= top+2; i++){\n    bool f = true;\n    for(int j = 0; j < Width; j++) if(field[i][j] == '?') f = false;\n    if(f){\n      ans -= 5;\n      down(i--);\n    }\n  }\n}\n \nvoid put(int d, int len, int pos){\n \n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n \n  int h = nex;\n  int w = pos;\n \n  for(int i = 0; i < len; i++){\n    field[h][w] = '.';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n \nint main(){\n \n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    ans = top = 0;\n    \n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      ans += len;\n      put(d-1,len,pos-1);\n      erase();\n    }\n    cout << ans << endl;\n    //  print(5,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass TETORIS {\npublic:\n    int N;\n    vector<vector<int> > bd;\n    TETORIS() : N(0) {}\n    void put(int len, int pos) {\n        int k;\n        for (k=bd.size()-1; k>=0; --k) {\n            for (int i=0; i<len; ++i) {\n                if (bd[k][pos+i]) goto brk;\n            }\n        } brk:;\n        ++k;\n        if ((int)bd.size() == k) bd.push_back(vector<int>(5, 0));\n        for (int i=0; i<len; ++i) {\n            bd[k][pos+i] = 1;\n        }\n        N += len;\n    }\n    void update() {\n        for (int i=bd.size()-1; i>=0; --i) {\n            if (bd[i][0] && bd[i][1] && bd[i][2] && bd[i][3] && bd[i][4]) {\n                bd.erase(bd.begin()+i);\n                N -= 5;\n            }\n        }\n    }\n};\n\nint main() {\n    int n;\n    while (cin >> n) {\n        TETORIS tet;\n        int d, p, q;\n        for (int i=0; i<n; ++i) {\n            cin >> d >> p >> q;\n            --q;\n            if (d == 1) {\n                tet.put(p, q);\n                tet.update();\n            } else {\n                for (int j=0; j<p; ++j) tet.put(1, q);\n                tet.update();\n            }\n        }\n        cout << tet.N << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define MAX 5000\n\nclass Tetoris{\n    public:\n    int stack[MAX+1], top;\n    Tetoris(){ stack[0] = 31; top = 0; }\n    \n    void insert( int o, int p, int q ){\n        int value = (o == 1 ? (((2 << p-1)-1) << (q-1)) : (1 << (q-1)));\n        int target = getTarget( value );\n        for ( int i = target;  i < target + ((o == 2) ? p : 1); i++ ){\n            if ( i > top ){\n                stack[i] = value;\n                top = i;\n            } else {\n                stack[i] += value;\n            }\n        }\n        \n        while( erase());\n    }\n    \n    bool erase(){\n        for ( int i = 1; i <= top; i++ ){\n            if ( stack[i] == 31 ){\n                for ( int j = i+1; j <= top; j++ ) stack[j-1] = stack[j];\n                top--; return true;\n            }\n        }\n        return false;\n    }\n    \n    int getResult(){\n        int sum = 0;\n        for ( int i = top; i >= 1; i-- ){\n            int val = stack[i];\n            while( val ){\n                if ( val%2 ) sum++;\n                val /= 2;\n            }\n        }\n        return sum;\n    }\n    \n    int getTarget( int value ){\n        int target = top;\n        while( (stack[target] & value) == 0 ) target--;\n        return target + 1;\n    }\n};\n\nint main(){\n    int n, o, p, q;\n    while( cin >> n && n ){\n        Tetoris tetoris;\n        for ( int i = 0; i < n; i++ ) {\n            cin >> o >> p >> q;\n            tetoris.insert(o, p, q);\n        }\n        cout << tetoris.getResult() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nconst int Height = 5500;\nconst int Width = 5;\nchar field[Height][Width];\nint top;\nint dx[] = {1,0};\nint dy[] = {0,-1};\n\n\nvoid print(int h, int w){\n\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl;\n    \n}\nbool isInside(int h, int w){return 0<=h&&h<Height&&0<=w&&w<Width;}\n\nint getH(int d, int len, int pos){\n  for(int i = Height-1; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?' || !isInside(h,w)) return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n}\n\nvoid put(int d, int len, int pos){\n\n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n\n  int h = nex;\n  int w = pos;\n\n  for(int i = 0; i < len; i++){\n    field[h][w] = '1';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n\nvoid count(){\n\n\n  int sum = 0;\n  \n  for(int i = 0; i < Height; i++){\n    int tmp = 0;\n    for(int j = 0; j < Width; j++){\n      if(field[i][j] != '?') tmp++;\n    }\n    if(tmp != 5) sum += tmp;\n  }\n  cout << sum << endl;\n}\n\nint main(){\n\n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    top = 0;\n\n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      put(d-1,len,pos-1);\n    }\n    count();\n    //    print(10,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\tflg &= board[h_max][j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tfor(int k = h_max; k < top[j]; k++) {\n\t\t\t\t\t\t\tboard[k][j] = board[k + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\n\t\t\t\tint h = top[q - 1];\n\t\t\t\ttop[q - 1] += p;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tflg &= board[h + j][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tboard[h + j - del][k] = board[h + j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdel++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tfor(int k = h + p - del; k < top[j] + 10; k++) {\n\t\t\t\t\t\tboard[k][j] = board[k + del][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\nbool flg = true;\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tans += board[i][j];\nflg &= board[i][j];\n\t\t\t}\nif(flg) ans -= 5;\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 10; i >= 0; i--) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tcout << (board[i][j] ? '*' : '.');\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t// */\n\t\t/*\n\t\tfor(int i = 0; i < 5; i++)\n\t\t\tcout << top[i] << \" \";\n\t\tcout << endl;\n\t\t// */\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nint W[10000];\nint H;\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  while (cin >> N) {\n    if (N == 0) break;\n    rep(i, 10000) W[i] = 0;\n\n    H = 1;\n    rep(i, N) {\n      int d, p, q;\n      cin >> d >> p >> q;\n      int mask = 1;\n      if (d == 1) {\n        mask = (1<<p)-1;\n        p = 1;\n      }\n      mask <<= (q-1);\n      rep(_, p) {\n        int h = H;\n        for (int y=H; y>=0; y--) {\n          if ((W[y] & mask) == 0) h = min(h, y);\n          else break;\n        }\n        if (h == H) H++;\n        W[h] |= mask;\n      }\n    }\n    int s = 0;\n    rep(i, 10000) {\n      //cout<<bitset<5>(W[i])<<\"\\n\";\n      if (W[i] == 31) continue;\n      s += __builtin_popcount(W[i]);\n    }\n    cout << s << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dat[5000][5];\nint m[5];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<5000;i++)\n\t\t\tfor(int j=0;j<5;j++)dat[i][j]=0;\n\t\tfor(int i=0;i<5;i++)m[i]=0;\n\t\tint count=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b,c,d;\n\t\t\tscanf(\"%d%d%d\",&b,&c,&d);d--;\n\t\t\tcount+=c;\n\t\t\tif(b==2){\n\t\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\t\tdat[m[d]+i][d]=1;\n\t\t\t\t\tbool ok=true;\n\t\t\t\t\tfor(int j=0;j<5;j++)if(!dat[m[d]+i][j])ok=false;\n\t\t\t\t\tif(ok){\n\t\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\t\tdat[m[d]+i][j]=0;\n\t\t\t\t\t\t\tfor(int k=m[d]+i;k<4999;k++)dat[k][j]=dat[k+1][j];\n\t\t\t\t\t\t\tm[j]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount-=5;\n\t\t\t\t\t}\n\t\t\t\t//\tm[d]++;\n\t\t\t\t}\n\t\t\t\tm[d]+=c;\n\t\t\t}else{\n\t\t\t\tint h=0;\n\t\t\t\tfor(int i=0;i<c;i++)h=max(h,m[i+d]);\n\t\t\t\tfor(int i=0;i<c;i++)dat[h][i+d]=1;\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int j=0;j<5;j++)if(!dat[h][j])ok=false;\n\t\t\t\tif(ok){\n\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\tdat[h][j]=0;\n\t\t\t\t\t\tfor(int k=h;k<4999;k++)dat[k][j]=dat[k+1][j];\n\t\t\t\t\t\tm[j]--;\n\t\t\t\t\t}\n\t\t\t\t\tcount-=5;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<c;i++)m[i+d]=h+1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tdeque<int>E[5];\n\t\trep(i, n) {\n\t\t\tint d, p, q; scanf(\"%d%d%d\", &d, &p, &q); q--;\n\t\t\tif (d == 1) {\n\t\t\t\tint Max = 0;\n\t\t\t\trep(i, p)Max = max(Max, (int)E[q + i].size());\n\t\t\t\trep(i, p) {\n\t\t\t\t\tint k = E[q + i].size();\n\t\t\t\t\trep(j, Max - k)E[q + i].push_back(0);\n\t\t\t\t\tE[q + i].push_back(1);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\trep(i, p)E[q].push_back(1);\n\t\t\t}\n\t\t\tbool update = true;\n\t\t\twhile (update) {\n\t\t\t\tupdate = false;\n\t\t\t\tint Min = INT_MAX;\n\t\t\t\trep(i, 5)Min = min(Min, (int)E[i].size());\n\t\t\t\trep(i, Min) {\n\t\t\t\t\tbool ok = true;\n\t\t\t\t\trep(j, 5)ok &= E[j][i];\n\t\t\t\t\tif (ok) {\n\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\trep(j, 5)E[j][i] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\trep(i, 5)E[i].erase(remove(E[i].begin(), E[i].end(), -1), E[i].end());\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\trep(i, 5)rep(j, E[i].size()) {\n\t\t\tif (E[i][j])sum++;\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n\nusing namespace std;\ntypedef pair<int,int> ii;\nint field[5010][5];\nint top[5];\nint n,d,p,q;\nvector<ii> input;\n\n\nvoid print()\n{\n  int st = 0;\n  rep(i,5)st = max(st,top[i]);\n  for(int y=st;y>=0;y--)\n    {\n      rep(x,5)\n\t{\n\t  cout << field[y][x] << \" \";\n\t}\n      cout << endl;\n    }\n}\n\nbool checkX(int y)\n{\n  rep(x,5)if(!field[y][x])return false;\n  return true;\n}\n\nvoid updateD(int x,int y)\n{\n  ii info = input[field[y][x]];\n  if(info.first == 1)\n    {//yoko\n      while(true)\n\t{\n\t  bool check = true;\n\t  rep(i,5)\n\t    {\n\t      if(field[y][x] != field[y][i])continue;\n\t      if(y-1 >= 0 && field[y-1][i] != 0)\n\t\t{\n\t\t  check = false;\n\t\t  break;\n\t\t}\n\t    }\n\t  if(!check)return;\n\t  int v = field[y][x];\n\t  rep(i,5)\n\t    {\n\t      if(v != field[y][i])continue;\n\t      assert(field[y-1][i] == 0);\n\t      field[y-1][i] = field[y][i];\n\t      field[y][i] = 0;\n\t    }\n\t  y = y-1;\n\t  if(y <= 0)return;\n\t}\n    }\n  else\n    {\n      int v = field[y][x];\n    \n      int bot = 0;\n      int py = y;\n      while(py-1 >= 0 && field[py-1][x] == 0)py--;\n      bot = y-py;\n\n      if(bot == 0)return;\n\n      while(v == field[y][x])\n\t{\n\t  assert(y-bot >= 0);\n\t  assert(field[y-bot][x] == 0);\n\t  field[y-bot][x] = field[y][x];\n\t  field[y][x] = 0;\n\t  y++;\n\t}\n\t\n    }\n}\n\nint main()\n{\n  while(cin >> n,n)\n    {\n      input.clear();\n      input.resize(1010,ii(-1,-1));\n      rep(i,5010)rep(j,5)field[i][j] = 0;\n      rep(i,5)top[i] = 0;\n      int cyb,cyt;\n      REP(i,1,n+1)\n\t{\n\t  cin >> d >> p >> q;\n\n\t  if(d == 1 && p == 5)continue;\n\t  q--;\n\t  input[i] = ii(d,p);\n\n\t  if(d == 2)\n\t    {\n\t      cyb = top[q],cyt = top[q]+p;\n\t      REP(j,top[q],top[q]+p)field[j][q] = i;\n\t      top[q] += p;\n\t    }\n\t  else\n\t    {\n\t      int mexico = -inf;\n\t      REP(j,q,q+p)mexico = max(mexico,top[j]);\n\t      REP(j,q,q+p)field[mexico][j] = i;\n\t      cyb = cyt = mexico;\n\t      REP(j,q,q+p)top[j] = mexico+1;\n\t    }\n\n\t  //update top\n\t  \n\t  rep(j,5)\n\t    {\n\t      int y = top[j];\n\t      while(y >= 0 && field[y][j] == 0)y--;\n\t      top[j] = y+1;\n\t    }\n\t  /*\n  cout << \"top = \";\n\t  rep(j,5)cout << top[j] << \" \";\n\t  cout << endl;\n\t  print();\n\n\t  cout << \"----------------\" << endl;\n\t  */\n\t}\n      cyb = 0;\n      rep(i,5)cyt = max(cyt,top[i]);\n      \n      bool update = true;\n      while(update)\n\t{\n\t  update = false;\n\t  //check\n\t  vector<int> erasedY;\n\t  REP(y,cyb,cyt+1)\n\t    {\n\t      if(checkX(y))\n\t\t{\n\t\t  erasedY.push_back(y);\n\t\t  rep(x,5)field[y][x] = 0;\n\t\t}\n\t    }\n\n\t  //print();\n\t  //down\n\t  if(!erasedY.empty())\n\t    {\n\t      update = true;\n\n\t      int yt = 0;\n\t      rep(j,5)yt = max(yt,top[j]);\n\t      rep(j,erasedY.size())\n\t\t{\n\t\t  REP(y,erasedY[j],yt)\n\t\t    {\n\t\t      int pre = -1;\n\t\t      rep(x,5)\n\t\t\t{\n\t\t\t  if(field[y][x] == pre)continue;\n\t\t\t  if(field[y][x] == 0 || y-1 < 0)continue;\n\n\t\t\t  pre = field[y][x];\n\t\t\t  updateD(x,y);\n\t\t\t}\n\t\t    }\n\t\t}\n\n\n\t    }\n\t\n\t  //print();\n\t  \n\t}\n\t\n\t  \n\t\n      int yt = 0;\n      rep(i,5)yt = max(yt,top[i]);\n      int ans = 0;\n      rep(y,yt)\n\trep(x,5)\n       \t  if(field[y][x] != 0)ans++;\t\n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<bitset>\n#include<list>\ntypedef std::list<std::bitset<5> >L;\ntypedef L::iterator I;\nvoid V(L&l,int p,int q)\n{\n\tl.insert(l.begin(),p,0);\n\tI i;\n\tfor(i=l.begin();i!=l.end();++i)\n\t\tif((*i)[q])\n\t\t\tbreak;\n\tint k;\n\tfor(k=0;k<p;++k)\n\t\t(*--i)[q]=1;\n\tfor(k=0;k<p;++k)\n\t{\n\t\tif(i->count()==5)i=l.erase(i);\n\t\telse++i;\n\t}\n}\nvoid H(L&l,int p,int q)\n{\n\tl.insert(l.begin(),1,0);\n\tI i;\n\tint k;\n\tfor(i=l.begin();i!=l.end();++i)\n\t\tfor(k=0;k<p;++k)\n\t\t\tif((*i)[k+q])\n\t\t\t\tgoto E;\nE:;\n\tfor(--i,k=0;k<p;++k)\n\t\t(*i)[k+q]=1;\n\tif(i->count()==5)l.erase(i);\n}\nint main()\n{\n\tint n,d,p,q;\n\tL l;\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\tl.clear();\n\t\twhile(n--)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&d,&p,&q);\n\t\t\tif(d>1)V(l,p,q-1);\n\t\t\telse H(l,p,q-1);\n\twhile(!l.empty()&&l.begin()->count()==0)l.pop_front();\n\t\t}\n\t\tint r=0;\n\t\tfor(I i=l.begin();i!=l.end();++i)r+=i->count();\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n \nusing namespace std;\n \nconst int Height = 5010;\nconst int Width = 5;\nchar field[Height][Width];\nint top,ans;\nint dx[] = {1,0};\nint dy[] = {0,-1};\n \n \nvoid print(int h, int w){\n \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl;\n     \n}\nbool isInside(int h, int w){return 0<=h&&h<Height&&0<=w&&w<Width;}\n \nint getH(int d, int len, int pos){\n  for(int i = top+1; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?' || !isInside(h,w)) return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n}\n\nvoid down(int n){\n \n  for(int i = n; i <= top+2; i++)\n    for(int j = 0; j < Width; j++) field[i][j] = field[i+1][j];\n  top--;\n}\n\nvoid erase(){\n\n  for(int i = 0; i <= top+2; i++){\n    bool f = true;\n    for(int j = 0; j < Width; j++) if(field[i][j] == '?') f = false;\n    if(f){\n      ans -= 5;\n      down(i--);\n    }\n  }\n}\n \nvoid put(int d, int len, int pos){\n \n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n \n  int h = nex;\n  int w = pos;\n \n  for(int i = 0; i < len; i++){\n    field[h][w] = '.';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n \nint main(){\n \n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    ans = top = 0;\n    \n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      ans += len;\n      put(d-1,len,pos-1);\n      erase();\n    }\n    cout << ans << endl;\n    print(5,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nbool m[5000][5];\nint h[5];\nint sum;\n\nbool check(int a) {\n  int i, j;\n  for (i=0; i<5; i++) {\n    if (!m[a][i]) break;\n  }\n  if (i != 5) return false;\n  for (i=0; i<5; i++) {\n    j = a;\n    while (j < h[i]) {\n      m[j][i] = m[j+1][i];\n      ++j;\n    }\n    j = h[i]-1;\n    while (j>=0 && !m[j][i]) {\n      --j;\n    }\n    h[i] = j+1;\n  }\n  return true;\n}\n\nint main() {\n  int n, d, p, q, mh;\n  while (1) {\n    cin >> n;\n    if (!n) break;\n    sum = 0;\n    for (int i=0; i<5*n; i++) {\n      for (int j=0; j<5; j++) {\n        m[i][j] = false;\n      }\n    }\n    for (int i=0; i<5; i++) {\n      h[i] = 0;\n    }\n    for (int i=0; i<n; i++) {\n      cin >> d >> p >> q;\n      --q;\n      sum += p;\n      if (d == 1) {\n        mh = 0;\n        for (int j=0; j<p; j++) {\n          if (mh < h[j+q]) {\n            mh = h[j+q];\n          }\n        }\n        for (int j=0; j<p; j++) {\n          m[mh][j+q] = true;\n          h[j+q] = mh+1;\n        }\n        if (check(mh)) sum -= 5;\n      } else {\n        mh = h[q];\n        for (int j=0; j<p; j++) {\n          m[j+mh][q] = true;\n        }\n        h[q] += p;\n        for (int j=p-1; j>=0; j--) {\n          if (check(j+mh)) sum -= 5;\n        }\n      }\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dat[5000][5];\nint m[5];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<5000;i++)\n\t\t\tfor(int j=0;j<5;j++)dat[i][j]=0;\n\t\tfor(int i=0;i<5;i++)m[i]=0;\n\t\tint count=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b,c,d;\n\t\t\tscanf(\"%d%d%d\",&b,&c,&d);d--;\n\t\t\tcount+=c;\n\t\t\tif(b==2){\n\t\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\t\tdat[m[d]+i][d]=1;\n\t\t\t\t\tbool ok=true;\n\t\t\t\t\tfor(int j=0;j<5;j++)if(!dat[m[d]+i][j])ok=false;\n\t\t\t\t\tif(ok){\n\t\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\t\tfor(int k=m[d]+i;k<m[j];k++)dat[k][j]=dat[k+1][j];\n\t\t\t\t\t\t\tdat[m[j]][j]=0;\n\t\t\t\t\t\t\tm[j]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount-=5;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tm[d]+=c;\n\t\t\t}else{\n\t\t\t\tint h=0;\n\t\t\t\tfor(int i=0;i<c;i++)h=max(h,m[i+d]);\n\t\t\t\tfor(int i=0;i<c;i++)dat[h][i+d]=1;\n\t\t\t\tfor(int i=0;i<c;i++)m[i+d]=h+1;\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int j=0;j<5;j++)if(!dat[h][j])ok=false;\n\t\t\t\tif(ok){\n\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\tfor(int k=h;k<m[j];k++)dat[k][j]=dat[k+1][j];\n\t\t\t\t\t\tdat[m[j]][j]=0;\n\t\t\t\t\t\tm[j]--;\n\t\t\t\t\t}\n\t\t\t\t\tcount-=5;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int LIMIT = 5001;\n\nint main()\n{\n\tint n;\n\n\twhile( cin >> n && n )\n\t{\n\t\tbool map[ LIMIT ][ 5 ] = {0};\n\t\tint h[ 5 ] = {0};\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\t\t\tq -= 1;\n\n\t\t\tint w = ( d == 1 ? p : 1 );\n\t\t\tint hh = 0;\n\t\t\tfor( int i = 0; i < w; ++i ){\n\t\t\t\thh = max( hh, h[ q + i ] );\n\t\t\t}\n\t\t\tif( d == 1 ){\n\t\t\t\tfor( int i = 0; i < w; ++i ){\n\t\t\t\t\tmap[ hh ][ q + i ] = true;\n\t\t\t\t\th[ q + i ] = hh + 1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tfor( int i = 0; i < p; ++i ){\n\t\t\t\t\tmap[ hh + i ][ q ] = true;\n\t\t\t\t}\n\t\t\t\th[ q ] = hh + p;\n\t\t\t}\n\n\t\t\tfor( int i = 0; i < 5; ++i ){\n\t\t\t\thh = max( hh, h[ i ] );\n\t\t\t}\n\t\t\tfor( int i = 0; i < hh; ++i ){\n\t\t\t\tbool full = true;\n\t\t\t\tfor( int j = 0; j < 5; ++j ){\n\t\t\t\t\tif( !map[ i ][ j ] ){\n\t\t\t\t\t\tfull = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( full ){\n\t\t\t\t\tfor( int j = i; j < hh; ++j ){\n\t\t\t\t\t\tfor( int k = 0; k < 5; ++k ){\n\t\t\t\t\t\t\tmap[ j ][ k ] = map[ j + 1 ][ k ];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor( int j = 0; j < 5; ++j ){\n\t\t\t\t\t\tint p = hh;\n\t\t\t\t\t\twhile( p >= 0 && !map[ p ][ j ] ){\n\t\t\t\t\t\t\t--p;\n\t\t\t\t\t\t}\n\t\t\t\t\t\th[ j ] = p + 1;\n\t\t\t\t\t}\n\t\t\t\t\t--hh;\n\t\t\t\t\t--i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint hh = 0;\n\t\tfor( int i = 0; i < 5; ++i ){\n\t\t\thh = max( hh, h[ i ] );\n\t\t}\n\t\tint ans = 0;\n\t\tfor( int i = 0; i < hh; ++i ){\n\t\t\tfor( int j = 0; j < 5; ++j ){\n\t\t\t\tif( map[ i ][ j ] ) ++ans;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nvoid solve(int n){\n    vector<vector<int>> grid(5, vector<int>(5*n+1));\n    for (int i = 0; i < 5; ++i) grid[i].back() = n+1;\n    vector<int> alive(5*n+1);\n    vector<int> cnt(5*n+1);\n    iota(alive.begin(),alive.end(), 0);\n    stack<int> X;\n    for (int _ = 0; _ < n; ++_) {\n        int d, p, q;\n        cin >> d >> p >> q; q--;\n        if(d == 1){\n            for (int i = 1; i < grid[0].size(); ++i) {\n                int ok = 1;\n                for (int j = q; j < q+p; ++j) {\n                    if(grid[j][alive[i]]) ok = 0;\n                }\n                if(!ok){\n                    for (int j = q; j < q+p; ++j) {\n                        int a = alive[i-1];\n                        grid[j][a] = _+1;\n                        cnt[a]++;\n                        if(cnt[a] == 5) X.emplace(a);\n                    }\n                    break;\n                }\n            }\n        }else {\n            for (int i = 1; i+p-1 < grid[0].size(); ++i) {\n                int ok = 1;\n                for (int j = i; j < i+p; ++j) {\n                    if(grid[q][alive[j]]) ok = 0;\n                }\n                if(!ok){\n                    for (int j = i; j < i+p; ++j) {\n                        int a = alive[j-1];\n                        grid[q][a] = _+1;\n                        cnt[a]++;\n                        if(cnt[a] == 5) X.emplace(a);\n                    }\n                    break;\n                }\n            }\n        }\n        while(!X.empty()){\n            alive.erase(lower_bound(alive.begin(),alive.end(), X.top())); X.pop();\n        }\n    }\n    int ans = 0;\n    for (auto &&j : alive) {\n        for (int i = 0; i < 5; ++i) {\n            if(grid[i][j] && grid[i][j] <= n) ans++;\n        }\n    }\n    cout << ans << \"\\n\";\n}\n\nint main() {\n    int n;\n    while(cin >> n, n){\n        solve(n);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define MAX 5000\n\nint t[MAX][5];\n\nvoid destroy(void){\n\tfor(int i=MAX-1;i>=0;i--){\n\t\tint count = 0;\n\t\tfor(int j=0;j<5;j++){\n\t\t\tcount += t[i][j];\n\t\t}\n\n\t\tif(count == 0) break;\n\n\t\telse if(count == 5){\n\t\t\tfor(int k=i;k>0;k--){\n\t\t\t\tcount = 0;\n\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\tt[k][j] = t[k-1][j];\n\t\t\t\t\tt[k-1][j] = 0;\n\t\t\t\t\tcount += t[k][j];\n\t\t\t\t}\n\t\t\t\tif(count == 0) break;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t}\n}\n\nvoid setBlock(int d,int p,int q){\n\tint sj = q - 1;\n\tint w = d == 1 ? p : 1;\n\tint h = -1;\n\n\tfor(int i=0;i<MAX-1;i++){\n\t\tfor(int j=sj;j<sj+w;j++){\n\t\t\tif(t[i+1][j]){\n\t\t\t\th = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(h != -1) break;\n\t}\n\n\tif(h == -1) h = MAX-1;\n\n\tif(d == 1){\n\t\tfor(int j=sj;j<sj+p;j++) t[h][j] = 1;\n\t}\n\telse{\n\t\tfor(int i=h;i>h-p;i--) t[i][sj] = 1;\n\t}\n}\n\nint countBlock(void){\n\tint res = 0;\n\tfor(int i=MAX-1;i>=0;i--){\n\t\tint count = 0;\n\t\tfor(int j=0;j<5;j++){\n\t\t\tcount += t[i][j];\n\t\t\tres += t[i][j];\n\t\t}\n\t\tif(count == 0) break;\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint n;\n\n\twhile(cin>>n && n){\n\t\tmemset(t,0,sizeof(t));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint d,p,q;\n\t\t\tcin>>d>>p>>q;\n\t\t\tsetBlock(d,p,q);\n\t\t\tdestroy();\n\t\t}\n\n\t\tcout<<countBlock()<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n \nusing namespace std;\n \nconst int Height = 5010;\nconst int Width = 5;\nchar field[Height][Width];\nint top,ans;\nint dx[] = {1,0};\nint dy[] = {0,-1};\n \nvoid print(int h, int w){\n \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl;\n     \n}\nbool isInside(int h, int w){return 0<=h&&h<Height&&0<=w&&w<Width;}\n \nint getH(int d, int len, int pos){\n  for(int i = top+6; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?' || !isInside(h,w)) return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n}\n\nvoid down(int n){\n \n  for(int i = n; i <= top+6; i++)\n    for(int j = 0; j < Width; j++) field[i][j] = field[i+1][j];\n  top--;\n}\n\nvoid erase(){\n \n  for(int i = 0; i <= top+6; i++){\n    bool f = true;\n    for(int j = 0; j < Width; j++) if(field[i][j] == '?') f = false;\n    if(f){\n      ans -= 5;\n      down(i--);\n    }\n  }\n}\n \nvoid put(int d, int len, int pos){\n \n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n \n  int h = nex;\n  int w = pos;\n \n  for(int i = 0; i < len; i++){\n    field[h][w] = '.';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n \nint main(){\n \n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    ans = top = 0;\n    \n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      ans += len;\n      put(d-1,len,pos-1);\n      erase();\n    }\n    cout << ans << endl;\n    //  print(5,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dat[5000][5];\nint m[5];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<5000;i++)\n\t\t\tfor(int j=0;j<5;j++)dat[i][j]=0;\n\t\tfor(int i=0;i<5;i++)m[i]=0;\n\t\tint count=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b,c,d;\n\t\t\tscanf(\"%d%d%d\",&b,&c,&d);d--;\n\t\t\tcount+=c;\n\t\t\tif(b==2){\n\t\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\t\tdat[m[d]+i][d]=1;\n\t\t\t\t\tbool ok=true;\n\t\t\t\t\tfor(int j=0;j<5;j++)if(!dat[m[d]+i][j])ok=false;\n\t\t\t\t\tif(ok){\n\t\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\t\tfor(int k=m[d]+i;k<m[j];k++)dat[k][j]=dat[k+1][j];\n\t\t\t\t\t\t\tm[j]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount-=5;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tm[d]+=c;\n\t\t\t}else{\n\t\t\t\tint h=0;\n\t\t\t\tfor(int i=0;i<c;i++)h=max(h,m[i+d]);\n\t\t\t\tfor(int i=0;i<c;i++)dat[h][i+d]=1;\n\t\t\t\tfor(int i=0;i<c;i++)m[i+d]=h+1;\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int j=0;j<5;j++)if(!dat[h][j])ok=false;\n\t\t\t\tif(ok){\n\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\tfor(int k=h;k<m[j];k++)dat[k][j]=dat[k+1][j];\n\t\t\t\t\t\tm[j]--;\n\t\t\t\t\t}\n\t\t\t\t\tcount-=5;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<5000;i++){\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<5;j++)if(!dat[i][j])ok=false;\n\t\t\tif(ok)count-=5;\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 2011/08/10 Tazoe\n\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n==0)\n\t\t\tbreak;\n\n\t\tint T[5000][5];\n\t\tfor(int i=0; i<5000; i++)\n\t\t\tfor(int j=0; j<5; j++)\n\t\t\t\tT[i][j] = 0;\n\t\tint I1 = 0;\n\t\tint I2 = 0;\n\n\t\tint N = 0;\n\n\t\tfor(int k=0; k<n; k++){\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d==1){\n\t\t\t\tint i;\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(i=I1-1; i>=I2; i--){\n\t\t\t\t\tfor(int j=0; j<p; j++){\n\t\t\t\t\t\tif(T[i][q-1+j]!=0){\n\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!flg)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int j=0; j<p; j++)\n\t\t\t\t\tT[i+1][q-1+j] = 1;\n\t\t\t\tif(I1<i+2)\n\t\t\t\t\tI1 = i+2;\n\t\t\t}\n\t\t\telse if(d==2){\n\t\t\t\tint i;\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(i=I1-1; i>=I2; i--){\n\t\t\t\t\tfor(int j=0; j<p; j++){\n\t\t\t\t\t\tif(T[i+j][q-1]!=0){\n\t\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!flg)\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tfor(int j=0; j<p; j++)\n\t\t\t\t\tT[i+1+j][q-1] = 1;\n\t\t\t\tif(I1<i+1+p)\n\t\t\t\t\tI1 = i+1+p;\n\t\t\t}\n\n\t\t\tN += p;\n\n\t\t\tfor(int i=I2; i<I1; i++)\n\t\t\t\tif(T[i][0]==1&&T[i][1]==1&&T[i][2]==1&&T[i][3]==1&&T[i][4]==1){\n\t\t\t\t\tN -= 5;\n\t\t\t\t\tI2++;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\n\t\t\tfor(int i=I2; i<I1; i++)\n\t\t\t\tif(T[i][0]==1&&T[i][1]==1&&T[i][2]==1&&T[i][3]==1&&T[i][4]==1){\n\t\t\t\t\tN -= 5;\n\t\t\t\t\tfor(int j=i; j<I1-1; j++){\n\t\t\t\t\t\tT[j][0] = T[j+1][0];\n\t\t\t\t\t\tT[j][1] = T[j+1][1];\n\t\t\t\t\t\tT[j][2] = T[j+1][2];\n\t\t\t\t\t\tT[j][3] = T[j+1][3];\n\t\t\t\t\t\tT[j][4] = T[j+1][4];\n\t\t\t\t\t}\n\t\t\t\t\tI1--;\n\t\t\t\t\ti--;\n\t\t\t\t}\n\n\t\t}\n/*\n\t\tfor(int i=I2; i<I1; i++){\n\t\t\tfor(int j=0; j<5; j++)\n\t\t\t\tcout << T[i][j];\n\t\t\tcout << endl;\n\t\t}\t\t\t\t\n*/\n\t\tcout << N << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\n//const int N = 6000;\nconst int N = 10;\nbool block[N][5];\n\n\nvoid output(){\n  cout <<\"Begin\"<<endl;\n  rep(i,10){\n    rep(j,5){\n      cout << block[9-i][j] << \" \";\n    }\n    cout << endl;\n  }\n  cout <<\"end\"<<endl;\n}\n\nvoid all_fall(int y,int x){\n  block[y][x]=false;\n  REP(i,y,N-1){\n    if (!block[i][x])continue;\n    for(int j=i;j>0;j--){\n      if (block[j-1][x])break;\n      else swap(block[j-1][x],block[j][x]);\n    }\n    //    output();\n  }\n  block[N-1][x]=false;\n}\n\nint getmax(int l,int r){\n  int ret=0;\n  REP(j,l,r){    \n    int tmp = N-1;\n    for(int i=N-1;i>=0;i--){\n      if (block[i][j])break;\n      tmp=i;\n    }\n    ret=max(ret,tmp);\n  }\n  return ret;\n}\n\nvoid fall(){\n  rep(i,N){\n    if (block[i][0]&block[i][1]&block[i][2]&block[i][3]&block[i][4]){\n      rep(j,5)all_fall(i,j);\n      i--;\n    }\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    rep(i,N)rep(j,5)block[i][j]=false;\n    rep(i,n){\n      int d,p,q;\n      int wid=1,hei=1,pos;\n      cin>>d>>p>>q;\n      q--;\n      if (d == 1){//yoko\n\tpos = getmax(q,q+p);\t\n\twid=p;\n      }else if (d == 2){//tate\n\tpos = getmax(q,q+1);\n\thei=p;\n      }\n\n      rep(i,hei){\n\trep(j,wid){\n\t  block[pos+i][q+j]=true;\n\t}\n      }\n      fall();\n      //output();\n    }\n\n    cout << count(&block[0][0],&block[N][0],true) << endl;\n    //    cout << cnt << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint fld[5005][5];\nvoid put1(int l,int p){\n    int curr=5000;\n    while(true){\n        bool flag=true;\n        for(int j=p;j<p+l;j++){\n            if(fld[curr][j])flag=false;\n        }\n        if(flag)curr--;\n        else break;\n    }\n\n    for(int j=p;j<p+l;j++)fld[curr+1][j]=1;\n}\nvoid put2(int l,int p){\n    int curr=5000;\n    while(true){\n        bool flag=true;\n        for(int i=curr;i<curr+l;i++)if(fld[i][p])flag=false;\n        if(flag)curr--;\n        else break;\n    }\n    for(int i=curr+1;i<curr+1+l;i++)fld[i][p]=1;\n}\n\nvoid del(){\n    int curr=0;\n    for(int i=0;i<5000;i++){\n        bool flag=true;\n        for(int j=0;j<5;j++)if(fld[i][j]==0)flag=false;\n        if(flag){\n            for(int j=0;j<5;j++)fld[i][j]=0;\n            continue;\n        }\n        for(int j=0;j<5;j++)fld[curr][j]=fld[i][j];\n        curr++;\n    }\n}\n\nvoid debug(int h){\n    for(int i=h;i>=0;i--){\n        for(int j=0;j<5;j++){\n            printf(\"%d\",fld[i][j]);\n        }\n        puts(\"\");\n    }\n}\n\nint main(){\n    int n;\n    while(scanf(\"%d\",&n),n){\n        fill_n(*fld,5005*5,0);\n        while(n--){\n            int d,l,p;\n            scanf(\"%d%d%d\",&d,&l,&p);\n            p--;\n            if(d==1)put1(l,p);\n            else put2(l,p);\n\n            del();\n\n\n            //debug(10);\n        }\n\n\n        int ans=0;\n        for(int i=0;i<5000;i++){\n            for(int j=0;j<5;j++)ans+=fld[i][j];\n        }\n\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "include <iostream>\n#include <math.h>\n\nusing namespace std;\n\nint main() {\n\tint i,j,n,a,b,c,d,e,f,g,m[10000];\n\twhile(cin >> n) {\n\t\tif (n==0) break;\n\t\tfor (j=0;j<10000;j++) m[j]=0; d=0;\n\t\tfor (i=0;i<n;i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tf=a >1 ? 1 << (c-1) : ((1 << b)-1)  << (c-1);  \n\t\t\tfor (j=d;j>=0;j--) if ( m[j]+f != (m[j] | f)) break;\n\t\t\te=g=j+1;\n\t\t\tif (a==1) { m[e]+=f; d++;}  else for (j=0;j<b;j++) { m[e+j]+=f; d+=b;}\n\t\t\tfor (j=g; j<g+d+1; j++) if (m[j]<31) m[e++]=m[j];\n\t\t}\n\t\tf=0;\n\t\tfor (i=0;i<5000;i++) for (j=0;j<5;j++) f+=(m[i] & ( 1 << j))>0;\n\t\tcout << f << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef tuple<int, int> duo;\n\n#define TT template<typename T>\n#define ET(T) typename T::value_type\nTT inline T sq(T x){return x*x;}\nTT inline T In(){T x;cin>>x;return x;}\nTT inline int ubnd(T&v,ET(T) x){return upper_bound(begin(v),end(v),x)-begin(v);}\nTT inline int lbnd(T&v,ET(T) x){return lower_bound(begin(v),end(v),x)-begin(v);}\nTT inline void sort(T&v){sort(begin(v),end(v));}\nTT inline void revs(T&v){reverse(begin(v),end(v));}\nTT inline void uniq(T&v){sort(v);v.erase(unique(begin(v),end(v)),end(v));}\nTT inline void inpt(T&v,int n,function<ET(T)()>f=In<ET(T)>){for(v.reserve(n);n--;v.emplace_back(f()));}\nTT inline void show(T&v,string d=\" \",string e=\"\\n\"){int i=0;for(auto&x:v)i++&&(cout<<d),cout<<x;cout<<e;}\n#undef TT\n#undef ET\n\ninline void fast_io(){ios::sync_with_stdio(0); cin.tie(0);}\ninline int in(){int x;scanf(\"%d\",&x);return x;}\ninline string instr(){string x;cin>>x;return x;}\ninline ll pow_mod(ll a, ll k, ll m){ll r=1;for(;k>0;a=a*a%m,k>>=1)if(k&1)r=r*a%m;return r;}\ninline ll mod_inv(ll a, ll p){return pow_mod(a,p-2,p);}\n\nconst int dx[] = {0, 0, 1, -1, 1, 1, -1, -1};\nconst int dy[] = {1, -1, 0, 0, 1, -1, 1, -1};\nconst int Mod = 1000000000;\n\nchar field[10000][8];\nint main()\n{\n  int n;\n  while (n = in()){\n    int height[8] = {};\n    memset(field, '.', sizeof(field));\n    for (int i = 0; i < 10000; i++) field[i][0] = '0', field[i][6] = 0;\n    for (int i = 0; i < n; i++){\n      int d, p, q;\n      cin >> d >> p >> q;\n      if (d == 1){\n        int h = 0;\n        for (int j = 0; j < p; j++) h = max(h, height[q + j]);\n        for (int j = 0; j < p; j++) field[h][q + j] = '#';\n        for (int j = 0; j < p; j++) height[q + j] = h + 1;\n        field[h][0] += p;\n      }\n      else {\n        int h = height[q];\n        for (int j = 0; j < p; j++){\n          field[h + j][q] = '#';\n          field[h + j][0]++;\n        }\n        height[q] += p;\n      }\n      bool line_delete = false;\n      for (int i = 0; i < 5000; i++){\n        if (field[i][0] == '0') break;\n        if (field[i][0] != '5') continue;\n        memmove(field[i], field[i + 1], 40000);\n        i--;\n        line_delete = true;\n      }\n      if (!line_delete) continue;\n      for (int i = 1; i <= 5; i++){\n        int h = height[i];\n        while (h >= 0 && field[h][i] != '#') h--;\n        height[i] = h + 1;\n      }\n    }\n    int tot = 0;\n    for (int i = 0; i < 5000; i++) tot += field[i][0] - '0';\n    cout << tot << \"\\n\";\n  }\n  return (0);\n}\n\n// priority_queue queue deque front top push pop map set stringstream max_element min_element insert count find get tie make_tuple"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define pb push_back\n#define rep(i, a, n) for(int i = (a); i < (n); i++)\n#define dep(i, a, n) for(int i = (a); i >= (n); i--)\n#define mod 1e9+7\n\n__attribute__((constructor))\nvoid initial() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n}\n\nint main() {\n  int n;\n  while(cin >> n) {\n    if(!n) return 0;\n    int m[5][5005] = {};\n    int gou = 0;\n    rep(i, 0, n) {\n      int d, p, q;\n      cin >> d >> p >> q;\n      gou += p;\n      if(d == 1) {\n        dep(j, 4998, 0) {\n          int f = 0;\n          rep(k, q - 1, p) {\n            if(m[k][j]) {\n              rep(l, q - 1, p) {\n                m[l][j + 1] = 1;\n              }\n              f = 1;\n              break;\n            }\n          }\n          if(f) break;\n          if(j == 0) {\n            rep(l, q - 1, p) {\n              m[l][j] = 1;\n            }\n            break;\n          }\n        }\n      }else {\n        dep(j, 4998, 0) {\n          int f = 0;\n          if(m[q - 1][j - (p - 1)]) {\n            rep(k, 0, p) {\n              m[q - 1][j + k] = 1;\n              f = 1;\n              break;\n            }\n          }\n          if(f) break;\n          if(j == 0) {\n            rep(l, 0, p) {\n              m[q - 1][j + l] = 1;\n            }\n            break;\n          }\n        }\n      }\n    }\n\n    rep(i, 0, 5005) {\n      int f = 0;\n      rep(j, 0, 5) {\n        if(!m[j][i]) {\n          f = 1;\n          break;\n        }\n      }\n      if(!f) gou -= 5;\n    }\n\n    rep(i, 0, 10) {\n      rep(j, 0, 5) {\n        cout << m[j][i];\n      }\n      cout << endl;\n    }\n\n    cout << gou << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n\nusing namespace std;\n\n#define int long long\n\nlist<bool*> fld;\n\nlist<bool*>::iterator GetHeight(int l, int r)\n{\n\tlist<bool*>::iterator itr = fld.begin();\n\t//fld.push_front((bool*)new bool[5]{});\n\tfor (; itr != fld.end(); itr++)\n\t{\n\t\tfor (int j = l; j < r; j++)\n\t\t{\n\t\t\tif ((*itr)[j] == true) return --itr;\n\t\t}\n\t}\n\treturn --itr;\n}\n\nbool IsFull(list<bool*>::iterator itr)\n{\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif ((*itr)[i] == false) return false;\n\t}\n\treturn true;\n}\n\nbool IsEmpty(list<bool*>::iterator itr)\n{\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif ((*itr)[i] == true) return false;\n\t}\n\treturn true;\n}\n\nvoid Drop(int d, int p, int q)\n{\n\tif (!IsEmpty(fld.begin())) fld.push_front((bool*)new bool[5]{});\n\tint l = q - 1, r = (d == 1) ? l + p : l + 1;\n\tlist<bool*>::iterator itr = GetHeight(l, r);\n\n\tint h = (d == 1) ? 1 : p;\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tif (itr == fld.begin()) fld.push_front((bool*)new bool[5]{});\n\t\tfor (int j = l; j < r; j++)\n\t\t{\n\t\t\t(*itr)[j] = true;\n\t\t}\n\t\tif (IsFull(itr))\n\t\t{\n\t\t\tdelete *itr;\n\t\t\titr = fld.erase(itr);\n\t\t}\n\t\titr--;\n\t}\n}\n\nsigned main()\n{\n\tint N;\n\twhile (cin >> N, N)\n\t{\n\t\tfld.clear();\n\t\tfld.push_back((bool*)new bool[5]{});\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\t\t\tDrop(d, p, q);\n\t\t}\n\t\tint ans = 0;\n\t\tfor (list<bool*>::iterator itr = fld.begin(); itr != fld.end(); itr++)\n\t\t{\n\t\t\tfor (int i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tans += ((*itr)[i] == true);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <math.h>\n\nusing namespace std;\n\nint main() {\n\tint i,j,n,a,b,c,d,e,f,g,m[5002];\n\twhile(cin >> n) {\n\t\tif (n==0) break;\n\t\tfor (j=0;j<5002;j++) m[j]=0; d=0;\n\t\tfor (i=0;i<n;i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tf=a >1 ? 1 << (c-1) : ((1 << b)-1)  << (c-1);  \n\t\t\tfor (j=d;j>=0;j--) if ( m[j]+f != (m[j] | f)) break;\n\t\t\te=g=j+1;\n\t\t\tif (a==1) { m[e]+=f; d++;}  else for (j=0;j<b;j++) { m[e+j]+=f; d+=b;}\n\t\t\tfor (j=g; j<g+d+1; j++) if (m[j]<31) m[e++]=m[j];\n\t\t}\n\t\tf=0;\n\t\tfor (i=0;i<5000;i++) for (j=0;j<5;j++) f+=(m[i] & ( 1 << j))>0;\n\t\tcout << f << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar stage[2][5000][5];\n\nint main()\n{\n    int n;\n    \n    while (scanf(\"%d\", &n) && n){\n        int height[5] = {0};\n        int turn = 0;\n        memset(stage, 0, sizeof(stage));\n        for (int rep = 0; rep < n; rep++){\n            int d, p, q;\n            scanf(\"%d %d %d\", &d, &p, &q); --q;\n            if (d == 1){\n                int mh = *max_element(height + q, height + p + q);\n                for (int j = q; j < p + q; j++){\n                    stage[turn][mh][j] = 1;\n                    height[j] = mh + 1;\n                }\n            }\n            else {\n                for (int j = 0; j < p; j++){\n                    stage[turn][height[q]++][q] = 1;\n                }\n            }\n            \n            int look = *max_element(height, height + 5);\n            memset(height, 0, sizeof(height));\n            int nh = 0;\n            for (int i = 0; i < look; i++){\n                bool ok = true;\n                for (int j = 0; j < 5; j++){\n                    if (stage[turn][i][j] == 0) ok = false;\n                }\n                if (!ok){\n                    bool has = false;\n                    memcpy(stage[1 - turn][nh], stage[turn][i], sizeof(stage[turn][i]));\n                    for (int j = 0; j < 5; j++){\n                        if (stage[1 - turn][nh][j]){\n                            height[j] = nh + 1;\n                            has = true;\n                        }\n                    }\n                    nh += has;\n                }\n            }\n            turn = 1 - turn;\n        }\n        \n        int ret = 0;\n        int h = *max_element(height, height + 5);\n        for (int i = 0; i < h; i++){\n            for (int j = 0; j < 5; j++){\n                ret += stage[turn][i][j];\n            }\n        }\n        \n        printf(\"%d\\n\", ret);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<string>\nusing namespace std;\n\nint ad,muki,pos,leng,hight[6],map1[6][6000];\n\nint main(){\n  while(true){\n    for(int raw=1;raw<6;raw++){\n      for(int high=0;high<6000;high++){\n\tmap1[raw][high]=0;\n      }\n      hight[raw]=0;\n    }\n    int blo=0; \n    int x=0;\n    cin>>ad;\n    if(ad==0){break;}\n    for(int i=0;i<ad;i++) {\n      cin>>muki;\n      cin>>leng;\n      cin>>pos;\n      blo+=leng;\n      for(int raw=1;raw<6;raw++){\n\tfor(int high=0;high<6000;high++){\n\t  if(map1[raw][high]==1){\n\t    hight[raw]=max(hight[raw],high);\n\t  }\n\t}\n\tif(map1[raw][hight[raw]]==1){\n\t  hight[raw]++;\n\t}\n\t///cout<<hight[raw]<<\" \";\n      }\n      ///cout<<endl;\n      if(muki==2){\n\tfor(int hhhh=0;hhhh<leng;hhhh++){\n\t  map1[pos][hight[pos]+hhhh]=1;\n\t}\n      }\n      if(muki==1){\n\tint hamu=0;\n\tfor(int raw=pos;raw<pos+leng;raw++){\n\t  hamu=max(hight[raw],hamu);\n\t}\n\tfor(int raw=pos;raw<pos+leng;raw++){\n\t  map1[raw][hamu]=1;\n\t}\n      }/*\n      for(int high=0;high<10;high++){\n\tfor(int raw=1;raw<6;raw++){\n\t  cout<<map1[raw][high]<<\" \";\n\t}\n\tcout<<endl;\n      }\n      cout<<\"-----------------------\"<<endl;\n       *///kesi\n      for(int high=0;high<6000;high++){\n\tint hantei=0;\n\tfor(int raw=1;raw<6;raw++){\n\t  if(map1[raw][high]==0){break;}\n\t  else{hantei++;}\n\t}\n\tif(hantei==5){\n\t  x++;\n\t  for(int j=1;j<6;j++){\n\t    hight[j]--;}\n\t  for(int a=1;a<6000-high;a++){\n\t    for(int raw=1;raw<6;raw++){\n\t      map1[raw][high+a-1]=map1[raw][high+a];\n\t    }\n\t  }\n\t  high--;\n\t}\n      }\n    }\n    int xxx=0;\n    xxx=blo-(5*x);\n    cout<<xxx<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<sstream>\n#include<numeric>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\n#define MAX 100100\n\nint b[25000][5];\n\nint main(){\n  int n;\n  while(scanf(\"%d\",&n), n){\n    int h[5] = {0};\n    REP(cc,n){\n      int d,p,q;\n      scanf(\"%d%d%d\",&d,&p,&q);\n      //printf(\"%d: d=%d, p=%d, q=%d\\n\",cc,d,p,q);\n      --q;\n      if(d == 1){\n\tint pos = *max_element(h+q, h+q+p);\n\tREP(i,p){\n\t  b[pos][q+i] = 1;\n\t  h[i] = pos+1;\n\t}\n\tif(accumulate(b[pos], b[pos]+5, 0) == 5){\n\t  REP(i,5) b[pos][i] = 0;\n\t}\n      }else{\n\tint pos = h[q];\n\tREP(i,p) b[pos + i][q] = 1;\n\th[q] += p;\n\tREP(i,p) if(accumulate(b[pos+i], b[pos+i]+5, 0) == 5)\n\t  REP(j,5) b[pos+i][j] = 0;\n\tint mx =*max_element(h, h+5);\n\t//printf(\"pos = %d\\n\",pos);\n\tfor(int i=pos; i<mx-1; i++) if(accumulate(b[i], b[i]+5, 0) == 0){\n\t    int t = 0;\n\t    while(i+t < mx && accumulate(b[i+t], b[i+t]+5, 0) == 0)\n\t      ++t;\n\t    for(int j=i; j<mx; j++)\n\t      REP(k,5){\n\t\tb[j][k] = b[j+t][k];\n\t\tb[j+t][k] = 0;\n\t      }\n\t    --mx;\n\t    REP(k,5) --h[k];\n\t  }\n      }\n      REP(i,5){\n\twhile(h[i] > 0 && b[h[i]-1][i] == 0)\n\t  h[i]--;\n      }\n      /*\n      int mx = *max_element(h, h+5);\n      for(int i=mx-1; i>=0; i--) { REP(j,5) printf(\"%d \",b[i][j]); puts(\"\"); }\n      printf(\"----------\\n\");\n      REP(i,5) printf(\"%d \",h[i]); puts(\"\");puts(\"\");\n      */\n    }\n    int mx = *max_element(h, h+5);\n    int ans = 0;\n    REP(i,mx) REP(j,5) if(b[i][j] == 1){\n      b[i][j] = 0;\n      ++ans;\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <ctime>\nusing namespace std;\n\nint main(){\n\tclock_t c1 = clock();\n\tint s = 0, n;\n\twhile(scanf(\"%d\", &n), n){\n\t\ts += n;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%*d%*d%*d\");\n\t\t}\n\t}\n\t\n\tclock_t c2 = c1 + CLOCKS_PER_SEC * (s / 1000000.0);\n\twhile(clock() < c2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n#define UNDER 1000\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint t[UNDER+10][5], n;\n\nint count(){\n  int res = 0;\n  rep(i, UNDER) rep(j, 5) if(t[i][j] == 1) res++;\n  return res;\n}\n\nvoid deleteblock(){\n  for(int y = UNDER-1; y >= 0; y--){\n    int f = 0;\n    rep(i, 5) if(t[y][i] == 0){ f = 1; break;}\n    if(f) continue;\n    rep(i, 5){\n      for(int c = y; c > 0; c--){\n\tt[c][i] = t[c-1][i];\n      }\n    }\n    t[0][0] = t[0][1] = t[0][2] = t[0][3] = t[0][4] = 0;\n    y++;\n  }\n  return;\n}\n\nint main(){\n  while(scanf(\"%d\", &n) && n){\n    int d, p, q;\n    memset(t, 0, sizeof(t));\n    rep(i, 5) t[UNDER][i] = 1;\n\n    rep(i, n){\n      scanf(\"%d%d%d\", &d, &p, &q); q--;\n      if(d == 1){\n\trep(y, UNDER+1){\n\t  int f = 0;\n\t  REP(x, q, q+p) if(t[y][x] == 1) f = 1;\n\t  if(!f) continue;\n\t  REP(x, q, q+p) t[y-1][x] = 1;\n\t  break;\n\t}\n      }else{\n\trep(y, UNDER+1){\n\t  if(!t[y][q]) continue;\n\t  for(int c = y-1; c > y-p-1; c--) t[c][q] = 1;\n\t  break;\n\t}\n      }\n      deleteblock();\n      /*      REP(i, 990, UNDER+1){\n\trep(j, 5) printf(\"%d \", t[i][j]); puts(\"\");\n\t}*/\n    }\n\n    printf(\"%d\\n\", count());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tint E[5]{};\n\t\trep(i, n) {\n\t\t\tint d, p, q; scanf(\"%d%d%d\", &d, &p, &q); q--;\n\t\t\tif (d == 1) {\n\t\t\t\trep(i, p)E[q + i]++;\n\t\t\t}\n\t\t\telse E[q] += p;\n\t\t\tint Min = *min_element(E, E + 5);\n\t\t\trep(i, 5)E[i] -= Min;\n\t\t}\n\t\tprintf(\"%d\\n\", accumulate(E, E + 5, 0));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, a, b, c;\nint main() {\n\twhile (cin >> n, n) {\n\t\tvector<vector<int> > d(5 * n + 1, vector<int>(5));\n\t\tvector<int> h(5);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> a >> b >> c; c--;\n\t\t\tif (a == 1) {\n\t\t\t\tint t = *max_element(h.begin() + c, h.begin() + c + b);\n\t\t\t\tfill(d[t].begin() + c, d[t].begin() + c + b, 1);\n\t\t\t\tfill(h.begin() + c, h.begin() + c + b, t + 1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int i = h[c]; i < h[c] + b; i++) d[i][c] = 1;\n\t\t\t\th[c] += b;\n\t\t\t}\n\t\t\tvector<int> w;\n\t\t\tfor (int i = 5 * n; i >= 0; i--) {\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int j = 0; j < 5; j++) sum += d[i][j];\n\t\t\t\tif (sum == 5) w.push_back(i);\n\t\t\t}\n\t\t\tfor (int i = 0; i < w.size(); i++) {\n\t\t\t\tfor (int j = 0; j < 5; j++) d[w[i]][j] = 0, h[j]--;\n\t\t\t\tfor (int j = w[i]; j < 5 * n; j++) {\n\t\t\t\t\tfor (int k = 0; k < 5; k++) d[j][k] = d[j + 1][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < 5 * n; i++) {\n\t\t\tfor (int j = 0; j < 5; j++) ret += d[i][j];\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//14\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    const int h=10000;\n    bool g[h][5]={{}};\n    fill(g[h-1],g[h],true);\n    while(n--){\n      int d,p,q;\n      cin>>d>>p>>q;\n      int y;\n      for(y=0;;y++){\n\tif(d==2){\n\t  if(g[y+1][q-1])break;\n\t}else{\n\t  int i;\n\t  for(i=0;i<p;i++){\n\t    if(g[y+1][q-1+i])break;\n\t  }\n\t  if(i<p)break;\n\t}\n      }\n      for(int i=0;i<p;i++){\n\tint dy=0,dx=0;\n\t((d==2)?dy:dx)=i;\n\tg[y-dy][q-1+dx]=true;\n      }\n      for(int i=0;i<h-1;i++){\n\tif(count(g[i],g[i+1],true)==5){\n\t  for(int j=i;j>=1;j--){\n\t    for(int x=0;x<5;x++){\n\t      g[j][x]=g[j-1][x];\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<count(g[0],g[h-1],true)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint x[10000][5], m[5], maxn, sum;\nint n;\nint a, b, c;\nint main() {\n\twhile (true) {\n\t\tsum = 0;\n\t\tmaxn = 0;\n\t\tmemset(x, 0, sizeof(x));\n\t\tmemset(m, 0, sizeof(m));\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int h = 0; h < n; h++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tc--;\n\t\t\tif (a == 1) {\n\t\t\t\tmaxn = 0;\n\t\t\t\tfor (int j = c; j < c + b; j++) {\n\t\t\t\t\tmaxn = max(maxn, m[j]);\n\t\t\t\t}\n\t\t\t\tfor (int j = c; j < c + b; j++) {\n\t\t\t\t\tx[maxn][j] = 1;\n\t\t\t\t\tm[j] = maxn + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\t\tx[m[c] + j][c] = 1;\n\t\t\t\t}\n\t\t\t\tm[c] += b;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 10000; i++) {\n\t\t\t\tif (x[i][0] + x[i][1] + x[i][2] + x[i][3] + x[i][4] == 5) {\n\t\t\t\t\tx[i][0] = 0; x[i][1] = 0; x[i][2] = 0; x[i][3] = 0; x[i][4] = 0;\n\t\t\t\t\tfor (int j = i; j < 9999; j++) {\n\t\t\t\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tx[j][k] = x[j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx[9999][0] = 0; x[9999][1] = 0; x[9999][2] = 0; x[9999][3] = 0; x[9999][4] = 0;\n\t\t\t\t\ti--;\n\t\t\t\t\tm[0]--; m[1]--; m[2]--; m[3]--; m[4]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 10000; i++) {\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\tsum += x[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <ctime>\nusing namespace std;\n\nint main(){\n\tclock_t c1 = clock();\n\tint s = 0, n;\n\twhile(scanf(\"%d\", &n), n){\n\t\ts += n;\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tscanf(\"%*d%*d%*d\");\n\t\t}\n\t}\n\t\n\tclock_t c2 = c1 + CLOCKS_PER_SEC * (s / 10000.0);\n\twhile(clock() < c2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint grid[5][6000];\nint n,d,p,q;\nll int ans = 0;\n\nint GetBottom(int x){\n\tREP(i,6000){\n\t\tif(grid[x][i]==-1) return i;\n\t}\n\treturn 0;\n}\n\nbool isallclear(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=-1) return false;\n\t}\n\treturn true;\n}\n\nbool isallblock(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(cin>>n,n){\n\t\tREP(i,5) REP(j,6000) grid[i][j] = -1;\n\t\tREP(i,n){\n\t\t\tcin >> d >> p >> q;\n\t\t\tif(d==2){\n\t\t\t\tint tmp = GetBottom(q-1);\n\t\t\t\tFOR(j,tmp,tmp+p) grid[q-1][j] = 1;\n\t\t\t}else{\n\t\t\t\tint tmp = -1;\n\t\t\t\tFOR(j,q-1,q-1+p){\n\t\t\t\t\ttmp = max(tmp,GetBottom(j));\n\t\t\t\t}\n\t\t\t\tFOR(j,q-1,q-1+p) {\n\t\t\t\t\tgrid[j][tmp] = 1;\n\t\t\t\t\tREP(k,tmp) if(grid[j][k]==-1) grid[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowline = 0;\n\t\t\twhile(1){\n\t\t\t\tif(isallclear(nowline)) break;\n\t\t\t\tif(isallblock(nowline)){\n\t\t\t\t\tREP(j,5) {\n\t\t\t\t\t\tint nline = nowline+1;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tif(grid[j][nline]==-1) {\n\t\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\tnline++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tnowline++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tint line = 0;\n\t\twhile(1){\n\t\t\tif(isallclear(line)) break;\n\t\t\tREP(i,5){\n\t\t\t\tif(grid[i][line]==1) ans++;\n\t\t\t}\n\t\t\tline++;\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nbool t[5001][5];\nint u[5];\nvoid init();\nvoid make_table();\nint n;\nint d,p,q,cnt;\nint main(){\n\n  while(cin>>n&&n!=0){\n    init();\n    for(int i=0;i<n;i++){\n\n      cin>>d>>p>>q;\n      q--;\n      make_table();\n\n\n\n    }\n    cnt=0;\n    for(int i=0;i<5000;i++)for(int j=0;j<5;j++)if(t[i][j])cnt++;\n    \n    cout<<cnt<<endl;\n  }  \n  return 0;\n}\n\nvoid init(){\n  for(int i=0;i<=5000;i++){\n    for(int j=0;j<5;j++){\n      t[i][j]=false;\n    }\n  }\n  for(int i=0;i<5;i++)u[i]=0;\n}\n\nvoid make_table(){\n  int h;\n  if(d==1){\n    h=0;\n    for(int j=q;j<q+p;j++)h=max(h,u[j]);\n    for(int j=q;j<q+p;j++){t[h][j]=true;u[j]=h+1;}\n  }else{\n    h=u[q];\n    for(int i=h;i<h+p;i++)t[i][q]=true;\n    u[q]+=p;\n  }\n\n\n\n\n\n\n  h=0;\n  for(int j=0;j<5;j++)h=max(h,u[j]);\n\n  for(int i=0;i<h;i++){\n    if(t[i][0]&&t[i][1]&&t[i][2]&&t[i][3]&&t[i][4]){\n      for(int j=0;j<5;j++){\n\tt[i][j]=false;\n\tu[j]--;\n      }\n    }\n  }\n \n  /*\n      for(int I=7;I>=0;I--){\n\tfor(int j=0;j<5;j++){\n\t  cout<<(int)t[I][j];\n\t}\n\tcout<<endl;\n      }\n      cout<<endl;\n\n  */\n  int H=0;\n  for(int i=0;i<h+1;i++){\n    if(t[i][0]||t[i][1]||t[i][2]||t[i][3]||t[i][4]){\n      for(int j=0;j<5;j++){\n\tt[H][j]=t[i][j];\n\tif(H!=i)t[i][j]=false;\n      }\n      H++;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nint n, hmax;\nbool maps[6000][5];\n\nint serch(int x, int l) {\n\tfor (int i = hmax; i >= 0; i--) {\n\t\tREP(j, l) if (maps[i][x + j]) return i + 1;\n\t}\n\treturn 0;\n}\n\nint check(int y, int l) {\n\tFOR(i, y, hmax) {\n\t\tbool flag = true;\n\t\tREP(j, 5) if (!maps[i][j]) flag = false;\n\t\tif (flag) return i;\n\t}\n\treturn -1;\n}\n\nvoid bset(int d, int p, int q) {\n\tint hl = d == 1 ? p : 1;\n\tint hpos = serch(q - 1, hl);\n\t\n\tif (d == 1) REP(i, p) maps[hpos][q + i - 1] = true;\n\telse REP(i, p) maps[hpos + i][q - 1] = true;\n\thmax += max(hmax, hpos + hl);\n\t\n\tint tmp;\n\twhile ((tmp = check(hpos, hl)) != -1) {\n\t\tREP(i, 5) maps[tmp][i] = false;\n\t\tFOR(i, tmp, hmax) {\n\t\t\tREP(j, 5) swap(maps[i][j], maps[i + 1][j]);\n\t\t}\n\t\thmax--;\n\t}\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tmemset(maps, 0, sizeof(maps));\n\t\thmax = 0;\n\t\t\n\t\twhile (n--) {\n\t\t\tint d, p, q;\n\t\t\tscanf(\"%d %d %d\", &d, &p, &q);\n\t\t\tbset(d, p, q);\n\t\t\t\n\t\t\tcout << count(maps[0], maps[6000], true) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <tuple>\n\nint const yoko = 1;\nint const tate = 2;\n\nvoid tetris(std::vector<std::vector<int>>& z) {\n  size_t m = z[0].size();\n  std::vector<std::vector<int>> y(5, std::vector<int>(m));\n\n  size_t i = 0;\n  for (size_t j = 0; j < m; ++j) {\n    int cur = 0;\n    for (size_t k = 0; k < 5; ++k) cur += z[k][j];\n    if (cur == 5) continue;\n    for (size_t k = 0; k < 5; ++k) y[k][i] = z[k][j];\n    ++i;\n  }\n  z = std::move(y);\n}\n\nint testcase_ends() {\n  size_t n;\n  scanf(\"%zu\", &n);\n  if (n == 0) return 1;\n\n  size_t m = 5*n+10;\n  std::vector<std::vector<int>> z(5, std::vector<int>(m));\n  for (size_t i = 0; i < n; ++i) {\n    size_t d, p, q;\n    scanf(\"%zu %zu %zu\", &d, &p, &q);\n    --q;\n\n    size_t l = q;\n    size_t r = q;\n    if (d == yoko) r += p-1;\n\n    size_t h = 0;\n    for (size_t j = l; j <= r; ++j) {\n      for (size_t k = m; k--;) {\n        if (z[j][k]) {\n          h = std::max(h, k+1);\n          break;\n        }\n      }\n    }\n\n    if (d == yoko) {\n      for (size_t i = l; i <= r; ++i) ++z[i][h];\n    } else if (d == tate) {\n      for (size_t i = 0; i < p; ++i) ++z[q][h+i];\n    }\n\n    tetris(z);\n  }\n  int res = 0;\n  for (auto const& zi: z)\n    res += std::accumulate(zi.begin(), zi.end(), 0);\n\n  printf(\"%d\\n\", res);\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n  \nusing namespace std;\n  \nconst int Height = 5100;\nconst int Width = 5;\nchar field[Height][Width];\nint top,ans;\nint dx[] = {1,0};\nint dy[] = {0,-1};\n  \nvoid print(int h, int w){\n  \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl; \n}\n\nbool isInside(int h, int w){ return 0<=h&&h<Height&&0<=w&&w<Width;}\n\nint getH(int d, int len, int pos){\n  for(int i = top+10; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?' || !isInside(h,w)) return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n}\n \nvoid down(int n){\n  \n  for(int i = n; i <= top+6; i++)\n    for(int j = 0; j < Width; j++) field[i][j] = field[i+1][j];\n  // top--;\n}\n \nvoid erase(){\n \n  for(int i = 0; i <= top+10; i++){\n    bool f = true;\n    for(int j = 0; j < Width; j++) if(field[i][j] == '?') f = false;\n    if(f){\n      ans -= 5;\n      down(i--);\n    }\n  }\n}\n  \nvoid put(int d, int len, int pos){\n  \n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n  \n  int h = nex;\n  int w = pos;\n  \n  for(int i = 0; i < len; i++){\n    field[h][w] = '.';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n  \nint main(){\n  \n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    ans = top = 0;\n     \n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      ans += len;\n      put(d-1,len,pos-1);\n      erase();\n    }\n    cout << ans << endl;\n    // print(10,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<30;\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    int height[5] = {}; // ツ各ツ療アツづ可堕カツ催敖つキツづゥツブツδ債ッツクツづ個暗ェツ氾板湘」ツづ個暗ェツ古つ湘」\n    bool ba[5][5010] = {};\n\n    while(n--) {\n      int d, p, q;\n      cin >> d >> p >> q;\n      q--;\n      if (d == 1) {\n        int ma = 0;\n        for (int i=q; i<p+q; ++i) {\n          ma = max(ma, height[i]);\n        }\n        for (int i=q; i<p+q; ++i) {\n          ba[i][ma] = 1;\n          height[i] = ma + 1;\n        }\n        bool f = 1;\n        REP(i,5)\n          if (!ba[i][ma])\n            f = 0;\n        if (f) {\n          REP(i,5) {\n            for (int j=ma+1; j<height[i]; ++j)\n              if (j>0)\n                ba[i][j-1] = ba[i][j];\n            ba[i][height[i]-1] = 0;\n            while(height[i] > 0 && !ba[i][height[i]-1])\n              height[i]--;\n          }\n        }\n      } else {\n        REP(i,p) {\n          ba[q][height[q]+i] = 1;\n        }\n        height[q] += p;\n        for (int k=height[q]-p; k<height[q]; ++k) {\n          bool f = 1;\n          REP(i,5)\n            if (!ba[i][k])\n              f = 0;\n          //    cout << k << \" \" << f << endl;\n          if (f) {\n            REP(i,5) {\n              for (int j=k+1; j<height[j]; ++j) {\n                if (j > 0)\n                  ba[i][j-1] = ba[i][j];\n              }\n              ba[i][height[i]-1] = 0;\n              while(height[i] > 0 && !ba[i][height[i]-1])\n                height[i]--;\n            }\n            // REP(i,10) {\n            //   REP(j,5) {\n            //     cout << ba[j][9-i];\n            //   }\n            //   cout << endl;\n            // }\n            // cout << endl;\n            k--;\n          }\n        }\n      }\n      // REP(i,10) {\n      //   REP(j,5) {\n      //     cout << ba[j][9-i];\n      //   }\n      //   cout << endl;\n      // }\n      // REP(i,5)\n      //   cout << height[i] << \" \";\n      // cout << endl << endl;;\n    }\n    int ans = 0;\n    REP(i,5)\n      REP(j,5010)\n        if (ba[i][j])\n          ans++;\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint grid[5][5010];\nint n,d,p,q;\nll int ans = 0;\n\nint GetBottom(int x){\n\tREP(i,5000){\n\t\tif(grid[x][i]==-1) return i;\n\t}\n\treturn 0;\n}\n\nbool isallclear(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=-1) return false;\n\t}\n\treturn true;\n}\n\nbool isallblock(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(cin>>n,n){\n\t\tREP(i,5) REP(j,5000) grid[i][j] = -1;\n\t\tREP(i,n){\n\t\t\tcin >> d >> p >> q;\n\t\t\tif(d==2){\n\t\t\t\tint tmp = GetBottom(q-1);\n\t\t\t\tFOR(j,tmp,tmp+p) grid[q-1][j] = 1;\n\t\t\t}else{\n\t\t\t\tint tmp = -1;\n\t\t\t\tFOR(j,q-1,q-1+p){\n\t\t\t\t\ttmp = max(tmp,GetBottom(j));\n\t\t\t\t}\n\t\t\t\tFOR(j,q-1,q-1+p) {\n\t\t\t\t\tgrid[j][tmp] = 1;\n\t\t\t\t\tREP(k,tmp) if(grid[j][k]==-1) grid[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowline = 0;\n\t\t\twhile(1){\n\t\t\t\tif(isallclear(nowline)) break;\n\t\t\t\tif(isallblock(nowline)){\n\t\t\t\t\tREP(j,5) {\n\t\t\t\t\t\tint nline = nowline+1;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tif(grid[j][nline]==-1) {\n\t\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\tnline++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tnowline++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tint line = 0;\n\t\twhile(1){\n\t\t\tif(isallclear(line)) break;\n\t\t\tREP(i,5){\n\t\t\t\tif(grid[i][line]==1) ans++;\n\t\t\t}\n\t\t\tline++;\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n\nusing namespace std;\n\n#define int long long\n\nlist<bool*> fld;\n\nlist<bool*>::iterator GetHeight(int l, int r)\n{\n\tlist<bool*>::iterator itr = fld.begin();\n\t//fld.push_front((bool*)new bool[5]{});\n\tfor (; itr != fld.end(); itr++)\n\t{\n\t\tfor (int j = l; j < r; j++)\n\t\t{\n\t\t\tif ((*itr)[j] == true) return --itr;\n\t\t}\n\t}\n\treturn --itr;\n}\n\nbool IsFull(list<bool*>::iterator itr)\n{\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif ((*itr)[i] == false) return false;\n\t}\n\treturn true;\n}\n\nbool IsEmpty(list<bool*>::iterator itr)\n{\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif ((*itr)[i] == true) return false;\n\t}\n\treturn true;\n}\n\nvoid Drop(int d, int p, int q)\n{\n\tif (!IsEmpty(fld.begin())) fld.push_front((bool*)new bool[5]{});\n\tint l = q - 1, r = (d == 1) ? l + p : l + 1;\n\tlist<bool*>::iterator itr = GetHeight(l, r);\n\n\tint h = (d == 1) ? 1 : p;\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tif (itr == fld.begin()) fld.push_front((bool*)new bool[5]{});\n\t\tfor (int j = l; j < r; j++)\n\t\t{\n\t\t\t(*itr)[j] = true;\n\t\t}\n\t\tif (IsFull(itr))\n\t\t{\n\t\t\tdelete *itr;\n\t\t\titr = fld.erase(itr);\n\t\t}\n\t\titr--;\n\t}\n}\n\nsigned main()\n{\n\tint N;\n\twhile (cin >> N, N)\n\t{\n\t\tfld.clear();\n\t\tfld.push_back((bool*)new bool[5]{});\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\t\t\tDrop(d, p, q);\n\t\t}\n\t\tint ans = 0;\n\t\tfor (list<bool*>::iterator itr = fld.begin(); itr != fld.end(); itr++)\n\t\t{\n\t\t\tfor (int i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tans += ((*itr)[i] == true);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define MH 5000\nusing namespace std;\nbool ck(int *f){\n\trep(i,5)if(!f[i])return 0;\n\treturn 1;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tint d,l,x,y,c=0;\n\t\tint field[MH][5]={0};\n\t\trep(i,n){\n\t\t\tcin>>d>>l>>x,y=MH,x--,d--;\n\t\t\tfor(;y>0;y--)rep(j,(d?1:l))if(field[y-1][x+j])goto END;\n\t\t\tEND:\n\t\t\trep(j,l)field[y+d*j][x+(1-d)*j]=1;\n\t\t\trep(i,5)while(ck(field[i])){\n\t\t\t\trep(j,MH-i-1)rep(k,5)field[j+i][k]=field[j+i+1][k];\n\t\t\t\trep(k,5)field[MH-1][k]=0;\n\t\t\t}\n\t\t}\n\t\trep(i,MH)rep(j,5)c+=field[i][j];\n\t\tcout<<c<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint grid[5][5010];\nint n,d,p,q;\nll int ans = 0;\n\nint GetBottom(int x){\n\tREP(i,5000){\n\t\tif(grid[x][i]==-1) return i;\n\t}\n\treturn -1;\n}\n\nbool isallclear(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=-1) return false;\n\t}\n\treturn true;\n}\n\nbool isallblock(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n;\n\t\tREP(i,5) REP(j,100000) grid[i][j] = -1;\n\t\tREP(i,n){\n\t\t\tcin >> d >> p >> q;\n\t\t\tif(d==2){\n\t\t\t\tint tmp = GetBottom(q-1);\n\t\t\t\tFOR(j,tmp,tmp+p) grid[q-1][j] = 1;\n\t\t\t}else{\n\t\t\t\tint tmp = -1;\n\t\t\t\tFOR(j,q-1,q-1+p){\n\t\t\t\t\ttmp = max(tmp,GetBottom(j));\n\t\t\t\t}\n\t\t\t\tFOR(j,q-1,q-1+p) {\n\t\t\t\t\tgrid[j][tmp] = 1;\n\t\t\t\t\tREP(k,tmp) if(grid[j][k]==-1) grid[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowline = 0;\n\t\t\twhile(1){\n\t\t\t\tif(isallclear(nowline)) break;\n\t\t\t\tif(isallblock(nowline)){\n\t\t\t\t\tREP(j,5) grid[j][nowline] = 0;\n\t\t\t\t}\n\t\t\t\tnowline++;\n\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tint line = 0;\n\t\twhile(1){\n\t\t\tif(isallclear(line)) break;\n\t\t\tREP(i,5){\n\t\t\t\tif(grid[i][line]==1) ans++;\n\t\t\t}\n\t\t\tline++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint n;\n\ntypedef struct Block\n{\n\tint d;\n\tint p;\n\tint q;\n} B;\n\nint F[5000][5];\nint H[5];\n\nB blocks[1000];\n\nint highest(int r, int l)\n{\n\tint max = 0;\n\tfor(int i=r; i<l; i++)\n\t{\n\t\tif(max < H[i])\n\t\t{\n\t\t\tmax =H[i];\n\t\t}\n\t}\n\treturn max;\n}\n\nvoid yoko_set(B b)\n{\n\tint hp = highest(b.q, b.p+b.q);\n\tfor(int i=b.q; i<b.p+b.q; i++)\n\t{\n\t\tF[hp][i] =1;\n\t\tH[i] = hp+1;\n\t}\n}\n\nvoid tate_set(B b)\n{\n\tint hp = H[b.q];\n\tfor(int i=hp; i<hp+b.p; i++)\n\t{\n\t\tF[i][b.q] = 1;\n\t}\n\tH[b.q] = hp+b.p;\n}\n\nvoid col_clear()\n{\n\t\n\tint hp = highest(0, 5);\n\tbool is_ok = false;\n\tvector<int> cols;\n\tfor(int i=0; i<=hp; i++)\n\t{\n\t\tis_ok =true;\n\t\tfor(int j=0; j<5; j++)\n\t\t{\n\t\t\tif(F[i][j]==1) continue;\n\t\t\tis_ok = false;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(is_ok)\n\t\t{\n\t\t\tcols.push_back(i);\n\t\t}\n\t}\n\t\n\tif(cols.empty()) return;\n\t\n\tint c = 0;\n\tfor(int i=0; i<hp; i++)\n\t{\n\t\tif(cols[c]==i)\n\t\t{\n\t\t\tc++;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int j=0; j<5; j++)\n\t\t{\n\t\t\tF[i-c][j] = F[i][j];\n\t\t}\n\t}\n\t\n\tfor(int i=hp-cols.size(); i<hp; i++)\n\t{\n\t\tfor(int j=0; j<5; j++)\n\t\t{\n\t\t\tF[i][j] = 0;\n\t\t}\n\t}\n\t\n\tfor(int j=0; j<5; j++)\n\t{\n\t\tint max = 0;\n\t\tfor(int i=0; i<hp; i++)\n\t\t{\n\t\t\tif(F[i][j]==1)\n\t\t\t{\n\t\t\t\tmax = i;\n\t\t\t}\n\t\t}\n\t\tH[j] =max+1;\n\t}\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tcin >> blocks[i].d;\n\t\t\tcin >> blocks[i].p;\n\t\t\tcin >> blocks[i].q;\n\t\t\tblocks[i].q--;\n\t\t}\n\t\t\n\t\tmemset(&F[0][0], 0, sizeof(int)*25000);\n\t\tmemset(&H[0], 0, sizeof(int)*5);\n\t\t\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tif(blocks[i].d == 2)\n\t\t\t{\n\t\t\t\ttate_set(blocks[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tyoko_set(blocks[i]);\n\t\t\t}\n\t\t\t\n\t\t\tcol_clear();\n\t\t}\n\t\t\n\t\tint hp = highest(0, 5);\n\t\tint c = 0;\n\t\tfor(int i=0; i<hp; i++)\n\t\t{\n\t\t\tfor(int j=0; j<5; j++)\n\t\t\t{\n\t\t\t\tif(F[i][j]==1) c++;\n\t\t\t}\n\t\t}\n\t\tcout << c<< endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n \nusing namespace std;\n \nconst int Height = 5500;\nconst int Width = 5;\nchar field[Height][Width];\nint top,ans;\nint dx[] = {1,0};\nint dy[] = {0,-1};\n \n \nvoid print(int h, int w){\n \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl;\n     \n}\nbool isInside(int h, int w){return 0<=h&&h<Height&&0<=w&&w<Width;}\n \nint getH(int d, int len, int pos){\n  for(int i = top+1; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?' || !isInside(h,w)) return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n}\n\nvoid down(int n){\n\n  for(int i = n; i <= top+5; i++)\n    for(int j = 0; j < Width; j++) field[i][j] = field[i+1][j];\n\n}\n\nvoid erase(){\n\n  for(int i = 0; i <= top; i++){\n    bool f = true;\n    for(int j = 0; j < Width; j++) if(field[i][j] == '?') f = false;\n    if(f){\n      for(int j = 0; j < Width; j++) field[i][j] = '?';\n      ans -= 5;\n      down(i--);\n    }\n  }\n}\n \nvoid put(int d, int len, int pos){\n \n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n \n  int h = nex;\n  int w = pos;\n \n  for(int i = 0; i < len; i++){\n    field[h][w] = '.';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n \nint main(){\n \n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    ans = top = 0;\n    \n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      ans += len;\n      put(d-1,len,pos-1);\n      erase();\n    }\n    cout << ans << endl;\n    print(10,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n\tint n, d, p, q, s, t;\n\t\n\twhile(cin>>n&&n){\n\t\tvector<bool> vec[5];\n\t\t\n\t\twhile(n--){\n\t\t\tcin >> d >> p >> q;\n\t\t\tq--;\n\t\t\tif(d == 1){\n\t\t\t\tt = -1;\n\t\t\t\tfor(int i = q; i < p; i++){\n\t\t\t\t\tfor(int j = vec[i].size()-1; j >= 0; j--){\n\t\t\t\t\t\tif(vec[i][j]){\n\t\t\t\t\t\t\tt = max(t, j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = q; i < p+q; i++){\n\t\t\t\t\twhile(vec[i].size() < (t+1)){\n\t\t\t\t\t\tvec[i].push_back(false);\n\t\t\t\t\t}\n\t\t\t\t\tvec[i].push_back(true);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tt = -1;\n\t\t\t\tfor(int i = vec[q].size()-1; i >= 0; i--){\n\t\t\t\t\tif(vec[q][i]){\n\t\t\t\t\t\tt = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ts = 0;\n\t\t\t\tfor(int i = t+1; i < vec[q].size() && s < p; i++, s++){\n\t\t\t\t\tvec[q][i] = true;\n\t\t\t\t}\n\t\t\t\tfor(;s < p; s++){\n\t\t\t\t\tvec[q].push_back(true);\n\t\t\t\t}\n\t\t\t}\n\t\t\tt = vec[0].size();\n\t\t\tfor(int i = 1; i < 5; i++){\n\t\t\t\ts = vec[i].size();\n\t\t\t\tt = min(s, t);\n\t\t\t}\n\n\t\t\tfor(int i = t-1; i >= 0; i--){\n\t\t\t\tbool f = true;\n\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\tif(!vec[j][i]){\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(f){\n\t\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\t\tvec[j].erase((vec[j].begin()+i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tt = 0;\n\t\tfor(int i = 0; i < 5; i++){\n\t\t\tfor(int j = 0; j < vec[i].size(); j++){\n\t\t\t\tif(vec[i][j]){\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << t << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        list<bitset<5> > board(1, (1<<5)-1);\n        while(--n >= 0){\n            int d, p, q;\n            cin >> d >> p >> q;\n            bitset<5> bs;\n            if(d == 1){\n                for(int i=q-1; i<q-1+p; ++i)\n                    bs[i] = true;\n                p = 1;\n            }else{\n                bs[q-1] = true;\n            }\n\n            list<bitset<5> >::iterator it = board.begin();\n            while(((*it) & bs).none())\n                ++ it;\n\n            while(--p >= 0){\n                if(it == board.begin())\n                    board.push_front(0);\n                -- it;\n                (*it) |= bs;\n                if((*it) == (1<<5)-1)\n                    it = board.erase(it);\n            }\n        }\n\n        int ret = -5;\n        list<bitset<5> >::iterator it;\n        for(it=board.begin(); it!=board.end(); ++it)\n            ret += it->count();\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nvector<int> EMP(5, 0), FULL(5, 1);\n\nclass TETORIS {\npublic:\n\tint N;\n\tvector<vector<int> > bd;\n\tTETORIS() : N(0) {}\n\tvoid put(int len, int pos) {\n\t\tint k = bd.size()-1;\n\t\tfor (; k>=0; --k) {\n\t\t\tfor (int i=0; i<len; ++i) {\n\t\t\t\tif (bd[k][pos+i]) goto brk;\n\t\t\t}\n\t\t} brk:;\n\t\t++k;\n\t\tif (bd.size() == k) bd.push_back(EMP);\n\t\tfor (int i=0; i<len; ++i) {\n\t\t\tbd[k][pos+i] = 1;\n\t\t}\n\t\tN += len;\n\t}\n\tvoid update() {\n\t\tfor (int i=bd.size()-1; i>=0; --i) {\n\t\t\tif (bd[i] == FULL) {\n\t\t\t\tbd.erase(bd.begin()+i);\n\t\t\t\tN -= 5;\n\t\t\t}\n\t\t}\n\t}\n};\n\nint main() {\n\tint n, d, p, q;\n\twhile (cin >> n, n) {\n\t\tTETORIS tet;\n\t\tfor (int i=0; i<n; ++i) {\n\t\t\tcin >> d >> p >> q;\n\t\t\tif (d == 1) {\n\t\t\t\ttet.put(p, q-1);\n\t\t\t\ttet.update();\n\t\t\t} else {\n\t\t\t\tfor (int j=0; j<p; ++j) tet.put(1, q-1);\n\t\t\t\ttet.update();\n\t\t\t}\n\t\t}\n\t\tcout << tet.N << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\n\n\n/* Header */\nenum Color{ CLEAR, BLACK };\nstruct Point;\nclass Block;\nclass Board;\n\nstruct Point\n{\n\tint x, y;\n\t\n\tPoint() : x(0), y(0) {}\n\tPoint(int v) : x(v), y(v) {}\n\tPoint(int x, int y) : x(x), y(y) {}\n};\n\nPoint operator + (const Point& left, const Point& right)\n{\treturn Point(left.x + right.x, left.y + right.y);\t}\n\nclass Block\n{\npublic:\n\n\tColor color;\n\t\n\t// points[0]ÌÝâÎÀWA»êÈOÍpoints[0]©çÌÎÀW\n\tvector<Point> points;\n\t\n\tBlock(vector<Point> points, Color color)\n\t\t: points(points), color(color) {}\n};\n\nclass Board\n{\n\tint width, height;\n\tvector<vector<Color> > board;\n\t\npublic:\n\t\n\tBoard(int width, int height);\n\t\n\tbool BoardRange(Point point);\n\t\t\n\tbool PutBlock(const Block& block, bool twice = false);\n\t\n\tbool RemoveBlock(const Block& block);\n\t\n\tbool DownBlock(Block *block);\n\t\n\tint DeleteLine();\n\t\n\tint CountBlock();\n};\n\n\n\n/* Implement */\nBoard::Board(int width, int height)\n\t: width(width), height(height)\n{\n\tboard = vector<vector<Color> >(height, vector<Color>(width, CLEAR));\n}\n\nbool Board::BoardRange(Point point)\n{\n\treturn 0 <= point.x && point.x < width && 0 <= point.y && point.y < height;\n}\n\nbool Board::PutBlock(const Block& block, bool twice)\n{\n\tfor(int i = 0; i < block.points.size(); i++)\n\t{\n\t\tPoint p = (i ? block.points[0] : Point(0, 0)) + block.points[i];\n\t\t\n\t\tif(twice) board[p.y][p.x] = block.color;\n\t\telse if(!BoardRange(p) || board[p.y][p.x] != CLEAR) return false;\n\t}\n\t\n\tif(!twice) PutBlock(block, true);\n\t\n\treturn true;\n}\n\nbool Board::RemoveBlock(const Block& block)\n{\n\tfor(int i = 0; i < block.points.size(); i++)\n\t{\n\t\tPoint p = (i ? block.points[0] : Point(0, 0)) + block.points[i];\n\t\t\n\t\tboard[p.y][p.x] = CLEAR;\n\t}\n}\n\nbool Board::DownBlock(Block *block)\n{\n\tRemoveBlock(*block);\n\t\n\tblock->points[0].y--;\n\t\n\tif(PutBlock(*block))\n\t{\n\t\treturn true;\n\t}\n\telse\n\t{\n\t\tblock->points[0].y++;\n\t\tPutBlock(*block);\n\t\t\n\t\treturn false;\n\t}\n}\n\nint Board::DeleteLine()\n{\n\tint ret = 0;\n\t\n\tfor(int i = height - 1; 0 <= i; i--)\n\t{\n\t\tif(count(board[i].begin(), board[i].end(), CLEAR) == 0)\n\t\t{\n\t\t\tboard[i] = vector<Color>(width, CLEAR);\n\t\t\t\n\t\t\tfor(int j = i; j < height - 1; j++)\n\t\t\t{\n\t\t\t\tboard[j] = board[j + 1];\n\t\t\t}\n\t\t\t\n\t\t\tret++;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\nint Board::CountBlock()\n{\n\tint ret = 0;\n\t\n\tfor(int y = 0; y < height; y++)\n\t{\n\t\tfor(int x = 0; x < width; x++)\n\t\t{\n\t\t\tret += board[y][x] != CLEAR;\n\t\t}\n\t}\n\t\n\treturn ret;\n}\n\n\n\n/* Entry */\nint main()\n{\n    int n;\n\twhile(cin >> n && n)\n\t{\t\t\n\t\tBoard board(5, 5048);\n\t\t\n\t\trep(i, n)\n\t\t{\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\t\t\t\n\t\t\tvector<Point> points; points.push_back(Point(q - 1, 5000));\n\t\t\tREP(j, 1, p)  points.push_back(Point((d == 1 ? j : 0), (d == 2 ? j : 0)));\n\t\t\t\n\t\t\tBlock block(points, BLACK);\n\t\t\twhile(board.DownBlock(&block));\n\t\t\tboard.DeleteLine();\n\t\t}\n\t\t\n\t\tcout << board.CountBlock() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nint W[10000];\nint H;\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  while (cin >> N) {\n    if (N == 0) break;\n    rep(i, 10000) W[i] = 0;\n\n    H = 0;\n    rep(i, N) {\n      int d, p, q;\n      cin >> d >> p >> q;\n      int mask = 1;\n      if (d == 1) {\n        mask = (1<<p)-1;\n        p = 1;\n      }\n      mask <<= (q-1);\n      rep(_, p) {\n        int h = H;\n        for (int y=H; y>=0; y--) {\n          if ((W[y] & mask) == 0) h = min(h, y);\n          else break;\n        }\n        if (h == H) H++;\n        W[h] |= mask;\n      }\n    }\n    int s = 0;\n    rep(i, H) {\n      //cout<<bitset<5>(W[i])<<\"\\n\";\n      if (W[i] == 31) continue;\n      s += __builtin_popcount(W[i]);\n    }\n    cout << s << \"\\n\";\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nbool t[5001][5];\nint u[5];\nvoid init();\nvoid make_table();\nint n;\nint d,p,q,cnt;\nint main(){\n\n  while(cin>>n&&n!=0){\n    init();\n    for(int i=0;i<n;i++){\n\n      cin>>d>>p>>q;\n      q--;\n      make_table();\n\n\n\n    }\n    cnt=0;\n    for(int i=0;i<5000;i++)for(int j=0;j<5;j++)if(t[i][j])cnt++;\n    \n    cout<<cnt<<endl;\n  }  \n  return 0;\n}\n\nvoid init(){\n  for(int i=0;i<=5000;i++){\n    for(int j=0;j<5;j++){\n      t[i][j]=false;\n    }\n  }\n  for(int i=0;i<5;i++)u[i]=0;\n}\n\nvoid make_table(){\n  int h;\n  if(d==1){\n    h=0;\n    for(int j=q;j<q+p;j++)h=max(h,u[j]);\n    for(int j=q;j<q+p;j++){t[h][j]=true;u[j]=h+1;}\n  }else{\n    h=u[q];\n    for(int i=h;i<h+p;i++)t[i][q]=true;\n    u[q]+=p;\n  }\n\n\n\n\n\n\n  h=0;\n  for(int j=0;j<5;j++)h=max(h,u[j]);\n\n  for(int i=0;i<h+1;i++){\n    if(t[i][0]&&t[i][1]&&t[i][2]&&t[i][3]&&t[i][4]){\n      for(int j=0;j<5;j++){\n\tt[i][j]=false;\n      }\n    }\n  }\n \n  /*\n      for(int I=7;I>=0;I--){\n\tfor(int j=0;j<5;j++){\n\t  cout<<(int)t[I][j];\n\t}\n\tcout<<endl;\n      }\n      cout<<endl;\n\n  */\n  int H=0;\n  for(int i=0;i<=5000;i++){\n    if(t[i][0]||t[i][1]||t[i][2]||t[i][3]||t[i][4]){\n      for(int j=0;j<5;j++){\n\tt[H][j]=t[i][j];\n\tif(H!=i)t[i][j]=false;\n      }\n      H++;\n    }\n  }\n\n  for(int j=0;j<5;j++){\n    for(int i=4999;i>=0;i--){\n      if(t[i][j]){\n\tu[j]=i+1;\n\tbreak;\n      }\n    }\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint main(){\n  int N;\n  while(cin >> N && N){\n    const int H = 5010;\n    const int W = 5;\n    bool block[H][W] = {};\n    int height[W] = {};\n    int n_h = 0;\n    REP(iter, N){\n      int d, l, bx;\n      cin >> d >> l >> bx;\n      bx --;\n      if(d == 1){\n        // yoko\n        int h = 0;\n        for(int x = bx; x < bx + l; x++) h = max(h, height[x]);\n        for(int x = bx; x < bx + l; x++) block[h][x] = true;\n        bool line = true;\n        for(int x = 0; x < W; x++) if(!block[h][x]) line = false;\n        if(line){\n          for(int x = 0; x < W; x++) block[h][x] = false;\n        }\n      }else if(d == 2){\n        // tate\n        for(int y = height[bx]; y < height[bx] + l; y++)\n          block[y][bx] = true;\n        for(int y = height[bx]; y < height[bx] + l; y++){\n          bool line = true;\n          for(int x = 0; x < W; x++) if(!block[y][x]) line = false;\n          if(!line) continue;\n          for(int x = 0; x < W; x++) block[y][x] = false;\n        }\n      }\n      bool new_block[H][W] = {};\n      int new_height[W] = {};\n      int new_nh = 0;\n      int curr = 0;\n      /*\n      for(int y = n_h + 5; y >= 0; y--){\n        debug(block[y], block[y] + 5);\n      }\n      cout << endl;\n      */\n      for(int y = 0; y < n_h + 5; y++){\n        bool clear = true;\n        for(int x = 0; x < W; x++) if(block[y][x]) clear = false;\n        if(clear) continue;\n        for(int x = 0; x < W; x++)if(block[y][x]){\n          block[y][x] = false;\n          block[curr][x] = true;\n          new_height[x] = curr + 1;\n        }\n        new_nh = ++curr;\n      }\n      //memcpy(block, new_block, sizeof(block));\n      memcpy(height, new_height, sizeof(height));\n      n_h = new_nh;\n    }\n    int ans = 0;\n    REP(y, H)REP(x, W) ans += block[y][x];\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <sstream>\n#include <climits>\n#include <cfloat>\n#include <complex>\n\nusing namespace std;\n\nbool field[5000][5];\nint top[5];\n\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tmemset(field, 0, sizeof(field));\n\t\tmemset(top, 0, sizeof(top));\n\n\t\twhile (n--)\n\t\t{\n\t\t\tint d, p, q;\n\t\t\tscanf(\"%d %d %d\", &d, &p, &q);\n\t\t\t--q;\n\t\t\tif (d == 1)\n\t\t\t{\n\t\t\t\tint maxTop = -1;\n\t\t\t\tfor (int i = 0; i < p; ++i)\n\t\t\t\t\tmaxTop = max(maxTop, top[q + i]);\n\t\t\t\tfor (int i = 0; i < p; ++i)\n\t\t\t\t\tfield[maxTop][q + i] = true;\n\t\t\t\tfor (int i = 0; i < p; ++i)\n\t\t\t\t\ttop[q + i] = maxTop + 1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor (int i = 0; i < p; ++i)\n\t\t\t\t\tfield[top[q] + i][q] = true;\n\t\t\t\ttop[q] += p;\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < 5000; ++i)\n\t\t{\n\t\t\tint s = 0;\n\t\t\tfor (int j = 0; j < 5; ++j)\n\t\t\t\tif (field[i][j])\n\t\t\t\t\t++s;\n\t\t\tif (s != 5)\n\t\t\t\tsum += s;\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int h,i,j,k,l,m;\n  int a[5002][5],n,d,p,q,c;\n  a[5001][0]=a[5001][1]=a[5001][2]=a[5001][3]=a[5001][4]=1;\n  for(;;){\n    cin>>n;\n    if(n==0)\n      break;\n    memset(a,0,5*5001*sizeof(int));\n    for(i=0;i<n;i++){\n      cin>>d>>p>>q;\n      for(j=0;j<5002;j++){\n\tif(d==1){\n\t  for(k=q-1;k<p+q-1;k++){\n\t    if(a[j][k])\n\t      break;\n\t  }\n\t  if(k!=p+q-1){\n\t    for(k=q-1;k<p+q-1;k++)\n\t      a[j-1][k]=1;\n\t    break;\n\t  }\n\t}else{\n\t  if(a[j][q-1]){\n\t    for(k=j-p;k<j;k++)\n\t      a[k][q-1]=1;\n\t    break;\n\t  }\n\t}\n      }\n      if(d==1){\n\tfor(k=0;k<5;k++){\n\t  if(a[j-1][k]==0)\n\t    break;\n\t}\n\tif(k==5){\n\t  for(k=2;;k++){\n\t    for(l=0;l<5;l++){\n\t      if(a[j-k][l])\n\t\tbreak;\n\t    }\n\t    memcpy(&a[j-k+1][0],&a[j-k][0],5*sizeof(int));\n\t    if(l==5)\n\t      break;\n\t  }\n\t}\n      }else{\n\th=0;\n\tfor(k=0;k<p;k++){\n\t  for(l=0;l<5;l++){\n\t    if(a[j-h-1][l]==0)\n\t      break;\n\t  }\n\t  if(l==5){\n\t    for(l=2;;l++){\n\t      for(m=0;m<5;m++){\n\t\tif(a[j-h-l][m])\n\t\t  break;\n\t      }\n\t      memcpy(&a[j-h-l+1][0],&a[j-h-l][0],5*sizeof(int));\n\t      if(m==5)\n\t\tbreak;\n\t    }\n\t  }else\n\t    h++;\n\t}\n      }\n    }\n    c=0;\n    for(i=1;i<5001;i++){\n      for(j=0;j<5;j++){\n\tif(a[i][j])\n\t  c++;\n      }\n    }\n    cout<<c<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar stage[2][5000][5];\n\nint main()\n{\n    int n;\n    \n    while (scanf(\"%d\", &n) && n){\n        int height[5] = {0};\n        int turn = 0;\n        memset(stage, 0, sizeof(stage));\n        for (int i = 0; i < n; i++){\n            int d, p, q;\n            scanf(\"%d %d %d\", &d, &p, &q); --q;\n            if (d == 1){\n                int mh = *max_element(height + q, height + p + q);\n                for (int j = q; j < p + q; j++){\n                    stage[turn][mh][j] = 1;\n                    height[j] = mh + 1;\n                }\n            }\n            else {\n                for (int j = 0; j < p; j++){\n                    stage[turn][height[q]++][q] = 1;\n                }\n            }\n            \n            int look = *max_element(height, height + 5);\n            memset(height, 0, sizeof(height));\n            int nh = 0;\n            for (int i = 0; i < look; i++){\n                bool ok = true;\n                for (int j = 0; j < 5; j++){\n                    if (stage[turn][i][j] == 0) ok = false;\n                }\n                if (!ok){\n                    memcpy(stage[1 - turn][nh], stage[turn][i], sizeof(stage[turn][i]));\n                    for (int j = 0; j < 5; j++){\n                        if (stage[1 - turn][nh][j]) height[j] = nh + 1;\n                    }\n                    nh++;\n                }\n            }\n            turn = 1 - turn;\n        }\n        \n        int ret = 0;\n        int h = *max_element(height, height + 5);\n        for (int i = 0; i < h; i++){\n            for (int j = 0; j < 5; j++){\n                ret += stage[turn][i][j];\n            }\n        }\n        \n        printf(\"%d\\n\", ret);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nconst int SIZE = 1001;\nconst int HEIGHT = 5001;\nint n;\nint D[SIZE+10], P[SIZE+10], Q[SIZE+10];\nbool B[HEIGHT+10][10];\n\nint solve() {\n    for ( int i = 0; i < HEIGHT; ++ i ) {\n        for ( int j = 0; j < 5; ++ j ) {\n            B[i][j] = false;\n        }\n    }\n    \n    \n    for ( int i = 0; i < n; ++ i ) {\n        int d = D[i], p = P[i], q = Q[i];\n        if ( d == 1 ) {\n            bool flag2 = true;\n            for ( int j = HEIGHT - 1; j >= 0; -- j ) {\n                bool flag = false;\n                for ( int k = 0; k < p; ++ k ) {\n                    if ( B[j][q+k] ) flag = true;\n                }\n                if ( flag ) {\n                    for ( int k = 0; k < p; ++ k ) {\n                        B[j+1][q+k] = true;\n                    }\n                    flag2 = false;\n                    break;\n                }\n            }\n            if ( flag2 ) {\n                for ( int k = 0; k < p; ++ k ) {\n                    B[0][q+k] = true;\n                }\n            }\n        } else if ( d == 2 ) {\n            bool flag2 = true;\n            for ( int j = HEIGHT - 1; j >= 0; -- j ) {\n                bool flag = false;\n                for ( int k = 0; k < p; ++ k ) {\n                    if ( B[j+k][q] ) flag = true;\n                }\n                if ( flag ) {\n                    for ( int k = 0; k < p; ++ k ) {\n                        B[j+k+1][q] = true;\n                    }\n                    flag2 = false;\n                    break;\n                }\n            }\n            if ( flag2 ) {\n                for ( int k = 0; k < p; ++ k ) {\n                    B[k][q] = true;\n                }\n            }\n        }\n\n        \n        \n        for ( int j = HEIGHT - 1; j >= 0; -- j ) {\n            bool flag = true;\n            for ( int k = 0; k < 5; ++ k ) {\n                if ( ! B[j][k] ) flag = false;\n            }\n            if ( flag ) {\n                for ( int k = j + 1; k < HEIGHT; ++ k ) {\n                    for ( int l = 0; l < 5; ++ l ) {\n                        B[k-1][l] = B[k][l];\n                    }\n                    for ( int l = 0; l < 5; ++ l ) {\n                        B[k][l] = false;\n                    }\n                }\n            }\n        }\n\n        \n    }\n    int res = 0;\n    for ( int i = 0; i < HEIGHT; ++ i ) {\n        for ( int j = 0; j < 5; ++ j ) {\n            if ( B[i][j] ) res ++;\n        }\n    }\n    return res;\n}\n\nint main() {\n    while ( cin >> n && n ) {\n        for ( int i = 0; i < n; ++ i ) {\n            cin >> D[i] >> P[i] >> Q[i];\n            Q[i] --;\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint n, d, p, q;\n\nint main()\n{\n    while(true)\n    {\n        cin >> n;\n        \n        if(n == 0) { break; }\n        \n        vector<vector<bool> > c(5000, vector<bool>(5, false));\n        \n        for(int i = 0; i < n; i++)\n        {\n            cin >> d >> p >> q;\n            \n            if(d == 1)\n            {\n                int maxh = -1;\n                \n                for(int j = p - 1; j < p + q - 1; j++)\n                {\n                    int r = 5000;\n                    \n                    while(r--)\n                    {\n                        if(c[r][j] == true)\n                        {\n                            break;\n                        }\n                    }\n                    \n                    maxh = max(maxh, r + 1);\n                }\n                \n                for(int j = p - 1; j < p + q - 1; j++)\n                {\n                    c[maxh][j] = true;\n                }\n            }\n            else\n            {\n                int r = 5000;\n            \n                while(r--)\n                {\n                    if(c[r][p] == true)\n                    {\n                        break;\n                    }\n                }   \n                \n                for(int j = r + 1; j < r + q + 1; j++)\n                {\n                    c[j][p] = true;\n                }\n            }   \n            \n            for(int j = 0; j < 5000; i++)\n            {\n                if(c[j][0] == c[j][1] && c[j][1] == c[j][2] && c[j][2] == c[j][3] && c[j][3] == c[j][4])\n                {\n                    for(int k = j + 1; k < 5000; k++)\n                    {\n                        for(int l = 0; l < 5; l++)\n                        {\n                            c[k - 1][l] = c[k][l];\n                        }\n                    }\n                }\n            }\n        }    \n    \n        int sum = 0;\n    \n        for(int i = 0; i < 5000; i++)\n        {\n            for(int j = 0; j < 5; j++)\n            {\n                sum += (c[j][p] ? 1 : 0);\n            }\n        }\n        \n        cout << sum << endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\ntemplate<class T> ostream& operator << ( ostream& os, vector<T> v ) {\n    for ( typename vector<T>::iterator it_i = v.begin(); it_i != v.end(); ++it_i ) {\n        os << *it_i << \", \";\n    }\n    return os;\n}\n\n\nconst int SIZE = 1001;\nconst int HEIGHT = 5001;\nint n;\nint D[SIZE], P[SIZE], Q[SIZE];\nbool B[HEIGHT][5];\n\nint solve() {\n    fill( (bool*)B, (bool*)B+HEIGHT*5, false );\n    \n    \n    for ( int i = 0; i < n; ++ i ) {\n        int d = D[i], p = P[i], q = Q[i];\n        if ( d == 1 ) {\n            bool flag2 = true;\n            for ( int j = HEIGHT - 1; j >= 0; -- j ) {\n                bool flag = false;\n                for ( int k = 0; k < p; ++ k ) {\n                    if ( B[j][q+k] ) flag = true;\n                }\n                if ( flag ) {\n                    for ( int k = 0; k < p; ++ k ) {\n                        B[j+1][q+k] = true;\n                    }\n                    flag2 = false;\n                    break;\n                }\n            }\n            if ( flag2 ) {\n                for ( int k = 0; k < p; ++ k ) {\n                    B[0][q+k] = true;\n                }\n            }\n        } else if ( d == 2 ) {\n            bool flag2 = true;\n            for ( int j = HEIGHT - 1; j >= 0; -- j ) {\n                bool flag = false;\n                for ( int k = 0; k < p; ++ k ) {\n                    if ( B[j+k][q] ) flag = true;\n                }\n                if ( flag ) {\n                    for ( int k = 0; k < p; ++ k ) {\n                        B[j+k+1][q] = true;\n                    }\n                    flag2 = false;\n                    break;\n                }\n            }\n            if ( flag2 ) {\n                for ( int k = 0; k < p; ++ k ) {\n                    B[k][q] = true;\n                }\n            }\n        }\n\n        \n        \n        for ( int j = HEIGHT - 1; j >= 0; -- j ) {\n            bool flag = true;\n            for ( int k = 0; k < 5; ++ k ) {\n                if ( ! B[j][k] ) flag = false;\n            }\n            if ( flag ) {\n                for ( int k = j + 1; k < HEIGHT; ++ k ) {\n                    for ( int l = 0; l < 5; ++ l ) {\n                        B[k-1][l] = B[k][l];\n                    }\n                    for ( int l = 0; l < 5; ++ l ) {\n                        B[k][l] = false;\n                    }\n                }\n            }\n        }\n\n        \n    }\n    int res = count( (bool*)B, (bool*)B+HEIGHT*5, true );\n    return res;\n}\n\nint main() {\n    while ( cin >> n && n ) {\n        for ( int i = 0; i < n; ++ i ) {\n            cin >> D[i] >> P[i] >> Q[i];\n            Q[i] --;\n        }\n        cout << solve() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint map[10000][10];\n\nvoid del(int y)\n{\n\tfor (; y < 9999; y++){\n\t\tfor (int i = 0; i < 5; i++){\n\t\t\tmap[y][i] = map[y + 1][i];\n\t\t}\n\t}\n}\n\nint main(void)\n{\n\tint n;\n\twhile (cin >> n, n){\n\t\tmemset(map, 0, sizeof(map));\n\t\t\n\t\tfor (int i = 1; i <= n; i++){\n\t\t\tint d, p, q;\n\t\t\t\n\t\t\tcin >> d;\n\t\t\tcin >> p;\n\t\t\tcin >> q;\n\t\t\tq--;\n\t\t\t\n\t\t\tif (d == 2){\n\t\t\t\tint y = 10000 - p;\n\t\t\t\twhile (map[y - 1][q] == 0 && y > 0){\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int j = y; j < y + p; j++){\n\t\t\t\t\tmap[j][q] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (d == 1){\n\t\t\t\tint y = 10000 - p;\n\t\t\t\twhile (1){\n\t\t\t\t\tint f = 0;\n\t\t\t\t\t\n\t\t\t\t\tfor (int j = q; j < 5; j++){\n\t\t\t\t\t\tif (map[y - 1][j] != 0){\n\t\t\t\t\t\t\tf = 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (f == 1 || y == 0){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor (int j = q; j < q + p; j++){\n\t\t\t\t\tmap[y][j] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint y = 0;\n\t\t\twhile (y < 10000){\n\t\t\t\tint cnt = 0;\n\t\t\t\t\n\t\t\t\tfor (int j = 0; j < 5; j++){\n\t\t\t\t\tcnt += !!map[y][j];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (cnt == 5){\n\t\t\t\t\tdel(y);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\ty++;\n\t\t\t\t}\n\t\t\t}\n/*\t\t\t\n\t\t\tfor (int y = 0; y < 20; y++){\n\t\t\t\tfor (int j = 0; j < 5; j++){\n\t\t\t\t\tprintf(\"%d \", map[y][j]);\n\t\t\t\t}\n\t\t\t\tputs(\"\");\n\t\t\t}\n*/\n\t\t}\n\t\t\n\t\tint cnt = 0;\n\t\tfor (int y = 0; y < 10000; y++){\n\t\t\tfor (int j = 0; j < 5; j++){\n//\t\t\t\tprintf(\"%d \", map[y][j]);\n\t\t\t\tcnt += !!map[y][j];\n\t\t\t}\n\t\t\t\n//\t\t\tputs(\"\");\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nint n, hmax;\nbool maps[5100][5];\n\nint serch(int x, int l) {\n\tfor (int i = hmax; i >= 0; i--) {\n\t\tREP(j, l) if (maps[i][x + j]) return i + 1;\n\t}\n\treturn 0;\n}\n\nint check(int y, int l) {\n\tFOR(i, y, hmax) {\n\t\tbool flag = true;\n\t\tREP(j, 5) if (!maps[i][j]) flag = false;\n\t\tif (flag) return i;\n\t}\n\treturn -1;\n}\n\nvoid bset(int d, int p, int q) {\n\tint hl = d == 1 ? p : 1;\n\tint hpos = serch(q - 1, hl);\n\t\n\tif (d == 1) REP(i, p) maps[hpos][q + i - 1] = true;\n\telse REP(i, p) maps[hpos + i][q - 1] = true;\n\thmax += max(hmax, hpos + hl);\n\t\n\tint tmp;\n\twhile ((tmp = check(hpos, hl)) != -1) {\n\t\tREP(i, 5) maps[tmp][i] = false;\n\t\tFOR(i, tmp, hmax) {\n\t\t\tREP(j, 5) swap(maps[i][j], maps[i + 1][j]);\n\t\t}\n\t\thmax--;\n\t}\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tmemset(maps, 0, sizeof(maps));\n\t\thmax = 0;\n\t\t\n\t\twhile (n--) {\n\t\t\tint d, p, q;\n\t\t\tscanf(\"%d %d %d\", &d, &p, &q);\n\t\t\tbset(d, p, q);\n\t\t\t\n\t\t\tcout << count(maps[0], maps[5100], true) << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(q-1+p>5)\n\t\t\t\tabort();\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\tflg = flg && board[h_max][j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tfor(int k = h_max; k < top[j]; k++) {\n\t\t\t\t\t\t\tboard[k][j] = board[k + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\n\t\t\t\tint h = top[q - 1];\n\t\t\t\ttop[q - 1] += p;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tflg = flg && board[h + j][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tboard[h + j - del][k] = board[h + j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdel++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tfor(int k = h + p - del; k < top[j] + 10; k++) {\n\t\t\t\t\t\tboard[k][j] = board[k + del][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tans += board[i][j];\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 10; i >= 0; i--) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tcout << (board[i][j] ? '*' : '.');\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t// */\n\t\t/*\n\t\tfor(int i = 0; i < 5; i++)\n\t\t\tcout << top[i] << \" \";\n\t\tcout << endl;\n\t\t// */\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint grid[5][5010];\nint n,d,p,q;\nll int ans = 0;\n\nint GetBottom(int x){\n\tREP(i,5000){\n\t\tif(grid[x][i]==-1) return i;\n\t}\n\treturn -1;\n}\n\nbool isallclear(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=-1) return false;\n\t}\n\treturn true;\n}\n\nbool isallblock(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n;\n\t\tREP(i,5) REP(j,5000) grid[i][j] = -1;\n\t\tREP(i,n){\n\t\t\tcin >> d >> p >> q;\n\t\t\tif(d==2){\n\t\t\t\tint tmp = GetBottom(q-1);\n\t\t\t\tFOR(j,tmp,tmp+p) grid[q-1][j] = 1;\n\t\t\t}else{\n\t\t\t\tint tmp = -1;\n\t\t\t\tFOR(j,q-1,q-1+p){\n\t\t\t\t\ttmp = max(tmp,GetBottom(j));\n\t\t\t\t}\n\t\t\t\tFOR(j,q-1,q-1+p) {\n\t\t\t\t\tgrid[j][tmp] = 1;\n\t\t\t\t\tREP(k,tmp) if(grid[j][k]==-1) grid[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowline = 0;\n\t\t\twhile(1){\n\t\t\t\tif(isallclear(nowline)) break;\n\t\t\t\tif(isallblock(nowline)){\n\t\t\t\t\tREP(j,5) grid[j][nowline] = 0;\n\t\t\t\t}\n\t\t\t\tnowline++;\n\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tint line = 0;\n\t\twhile(1){\n\t\t\tif(isallclear(line)) break;\n\t\t\tREP(i,5){\n\t\t\t\tif(grid[i][line]==1) ans++;\n\t\t\t}\n\t\t\tline++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\nusing namespace std;\n\nint di[2] = {0, 1};\nint dj[2] = {1, 0};\nint mat[5010][5];\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        memset(mat, 0, sizeof(mat));\n        int ma = 1;\n        for(int i = 0; i < n; i++){\n            int d, p, q;\n            cin >> d >> p >> q;\n            d--, q--;\n            int put;\n            for(put = 5000; put >= 0; put--){\n                bool ok = true;\n                for(int j = 0; j < p; j++){\n                    ok &= mat[put+j*di[d]][q+j*dj[d]] == 0;\n                }\n                if(!ok) break;\n            }\n            int h = put+1;\n            for(int j = 0; j < p; j++){\n                mat[h+j*di[d]][q+j*dj[d]] = 1;\n            }\n            int acc = 0;\n            for(int hh = h; hh < 5000; hh++){\n                int sum = 0;\n                for(int j = 0; j < 5; j++)  sum += mat[hh][j];\n                if(sum == 5){\n                    for(int j = 0; j < 5; j++)  mat[hh][j] = 0;\n                    acc++;\n                }else{\n                    for(int j = 0; j < 5; j++)  mat[hh-acc][j] = mat[hh][j];\n                }\n            }\n        }\n        int ans = 0;\n        for(int i = 0; i < 5000; i++){\n            for(int j = 0; j < 5; j++){\n                ans += mat[i][j];\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint grid[5][5000];\nint n,d,p,q;\nll int ans = 0;\n\nint GetBottom(int x){\n\tREP(i,5000){\n\t\tif(grid[x][i]==-1) return i;\n\t}\n\treturn -1;\n}\n\nbool isallclear(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=-1) return false;\n\t}\n\treturn true;\n}\n\nbool isallblock(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n;\n\t\tREP(i,5) REP(j,100000) grid[i][j] = -1;\n\t\tREP(i,n){\n\t\t\tcin >> d >> p >> q;\n\t\t\tif(d==2){\n\t\t\t\tint tmp = GetBottom(q-1);\n\t\t\t\tFOR(j,tmp,tmp+p) grid[q-1][j] = 1;\n\t\t\t}else{\n\t\t\t\tint tmp = -1;\n\t\t\t\tFOR(j,q-1,q-1+p){\n\t\t\t\t\ttmp = max(tmp,GetBottom(j));\n\t\t\t\t}\n\t\t\t\tFOR(j,q-1,q-1+p) {\n\t\t\t\t\tgrid[j][tmp] = 1;\n\t\t\t\t\tREP(k,tmp) if(grid[j][k]==-1) grid[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowline = 0;\n\t\t\twhile(1){\n\t\t\t\tif(isallclear(nowline)) break;\n\t\t\t\tif(isallblock(nowline)){\n\t\t\t\t\tREP(j,5) grid[j][nowline] = 0;\n\t\t\t\t}\n\t\t\t\tnowline++;\n\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tint line = 0;\n\t\twhile(1){\n\t\t\tif(isallclear(line)) break;\n\t\t\tREP(i,5){\n\t\t\t\tif(grid[i][line]==1) ans++;\n\t\t\t}\n\t\t\tline++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tvector<int>\tvi;\n\nchar field[5050];\n\nbool vanish(int u,int l){\n\tvi rem;\n\tfor(int i=l;i>=u;i--){\n\t\tif(field[i]!=31)\trem.pb(i);\n\t}\n\n\tint rnum=rem.size(),h=l-u+1;\n\tif(rnum!=l){\n\t\tfor(int i=0;i<rnum;i++)\tfield[l-i]=field[rem[i]];\n\t\tfor(int i=u-1;i>=0;i--)\tfield[h-rnum+i]=field[i];\n\t\tfor(int i=0;i<rnum;i++)\tfield[i]=0;\n\t}\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tfor(int i=0;i<5050;i++)\tfield[i]=0;\n\t\tfor(int t=0;t<n;t++){\n\t\t\tint type,len,p;\tscanf(\"%d%d%d\",&type,&len,&p);\n\t\t\tp--;\n\n\t\t\tchar blk;\n\t\t\tif(type==1)\tblk=((1<<len)-1)<<(5-p-len);\n\t\t\telse\t\tblk=1<<(4-p);\n\n\t\t\tfor(int i=0;i<=5050;i++){\n\t\t\t\tif(i==5050 || (field[i]&blk)!=0){\n\t\t\t\t\tif(type==1){\n\t\t\t\t\t\tfield[i-1]|=blk;\n\t\t\t\t\t\tvanish(i-1,i-1);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int j=1;j<=len;j++)\tfield[i-j]|=blk;\n\t\t\t\t\t\tvanish(i-len,i-1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint cnt=0;\n\t\tfor(int i=0;i<5050;i++){\n\t\t\tfor(int j=0;j<5;j++)\tif(field[i]&(1<<j))\tcnt++;\n\t\t}\n\t\tprintf(\"%d\\n\",cnt);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nint fall(vector<vector<int>>&field, vector<vector<int>>&pino,int l) {\n\t{\n\n\t}\n\tint y = 0;\n\tfor ( y = 0; y < field.size() - pino.size(); ++y) {\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < pino.size(); ++i) {\n\t\t\tfor (int j = 0; j < pino[i].size(); ++j) {\n\t\t\t\tif (pino[i][j]) {\n\t\t\t\t\tif (field[y + i+1][l + j])ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ok||y+pino.size()-1==field.size()) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < pino.size(); ++i) {\n\t\tfor (int j = 0; j < pino[i].size(); ++j) {\n\t\t\tif (pino[i][j]) {\n\t\t\t\tassert(!field[y + i][l + j]);\n\t\t\t\tfield[y + i][l + j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint delline = 0;\n\tfor (int i = y + pino.size() - 1; i >= y; --i) {\n\t\tif (all_of(field[i].begin(), field[i].end(), [](const int a) {return a == 1; })) {\n\t\t\ttransform(field[i].begin(), field[i].end(), field[i].begin(), [](const int a) {return false; });\n\t\t\tfor (int j = i- 1; j >= 0; --j) {\n\t\t\t\tswap(field[j], field[j + 1]);\n\t\t\t}\n\t\t\tdelline += 1;\n\t\t}\n\t}\n\treturn delline;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tint sum = 0;\n\t\tvector<vector<int>>field(5*N+10, vector<int>(5));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint d, p, q; cin >> d >> p >> q; q--;\n\t\t\tint w = d == 2 ? 1 : p;\n\t\t\tint h = d == 1 ? 1 : p;\n\t\t\tsum += p;\n\t\t\tvector<vector<int>>pino(h, vector<int>(w, 1));\n\t\t\tsum -= fall(field, pino, q) * 5;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint n;\n\ntypedef struct Block\n{\n\tint d;\n\tint p;\n\tint q;\n} B;\n\nint F[5000][5];\nint H[5];\n\nB blocks[1000];\n\nint highest(int r, int l)\n{\n\tint max = 0;\n\tfor(int i=r; i<l; i++)\n\t{\n\t\tif(max < H[i])\n\t\t{\n\t\t\tmax =H[i];\n\t\t}\n\t}\n\treturn max;\n}\n\nvoid yoko_set(B b)\n{\n\tint hp = highest(b.q, b.p+b.q);\n\tfor(int i=b.q; i<b.p+b.q; i++)\n\t{\n\t\tF[hp][i] =1;\n\t\tH[i] = hp+1;\n\t}\n}\n\nvoid tate_set(B b)\n{\n\tint hp = H[b.q];\n\tfor(int i=hp; i<hp+b.p; i++)\n\t{\n\t\tF[i][b.q] = 1;\n\t}\n\tH[b.q] = hp+b.p;\n}\n\nvoid col_clear()\n{\n\t\n\tint hp = highest(0, 5);\n\tbool is_ok = false;\n\tvector<int> cols;\n\tfor(int i=0; i<=hp; i++)\n\t{\n\t\tis_ok =true;\n\t\tfor(int j=0; j<5; j++)\n\t\t{\n\t\t\tif(F[i][j]==1) continue;\n\t\t\tis_ok = false;\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tif(is_ok)\n\t\t{\n\t\t\tcols.push_back(i);\n\t\t}\n\t}\n\t\n\tif(cols.empty()) return;\n\t\n\tint c = 0;\n\tfor(int i=0; i<hp; i++)\n\t{\n\t\tif(cols[c]==i)\n\t\t{\n\t\t\tc++;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int j=0; j<5; j++)\n\t\t{\n\t\t\tF[i-c][j] = F[i][j];\n\t\t}\n\t}\n\t\n\tfor(int i=hp-cols.size(); i<hp; i++)\n\t{\n\t\tfor(int j=0; j<5; j++)\n\t\t{\n\t\t\tF[i][j] = 0;\n\t\t}\n\t}\n\t\n\tfor(int i=0; i<5; i++)\n\t{\n\t\tH[i] -= cols.size();\n\t}\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tcin >> blocks[i].d;\n\t\t\tcin >> blocks[i].p;\n\t\t\tcin >> blocks[i].q;\n\t\t\tblocks[i].q--;\n\t\t}\n\t\t\n\t\tmemset(&F[0][0], 0, sizeof(int)*25000);\n\t\tmemset(&H[0], 0, sizeof(int)*5);\n\t\t\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tif(blocks[i].d == 2)\n\t\t\t{\n\t\t\t\ttate_set(blocks[i]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tyoko_set(blocks[i]);\n\t\t\t}\n\t\t\t\n\t\t\tcol_clear();\n\t\t}\n\t\t\n\t\tint hp = highest(0, 5);\n\t\tint c = 0;\n\t\tfor(int i=0; i<hp; i++)\n\t\t{\n\t\t\tfor(int j=0; j<5; j++)\n\t\t\t{\n\t\t\t\tif(F[i][j]==1) c++;\n\t\t\t}\n\t\t}\n\t\tcout << c<< endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nchar s[5010][5];\n\n// 初期化 (y == 0 のところを番兵でブロックにしておく)\nvoid ini(){\n\tfor(int y=0 ; y < 5010 ; y++ ){\n\t\tfor(int x=0 ; x < 5 ; x++ ){\n\t\t\ts[y][x] = y? '.' : '#' ;\n\t\t}\n\t}\n}\n\nvoid debug(int ay){\n\tcout << \"[debug]\" << endl;\n\tfor(int y=ay ; y > 0 ; y-- ){\n\t\tfor(int x=0 ; x < 5 ; x++ ){\n\t\t\tcout << s[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// ブロックの初期位置を返す.\nvector<P> block(int d, int p, int q, int y){\n\tvector<P> v;\n\tif( d == 1 ){ // 横向きのブロック\n\t\tfor(int i=0 ; i < p ; i++ ){\n\t\t\tint mx = q + i;\n\t\t\tint my = y;\n\t\t\tv.push_back( P(mx,my) );\n\t\t}\n\t}else{ // 縦向きのブロック\n\t\tfor(int i=0 ; i < p ; i++ ){\n\t\t\tint mx = q;\n\t\t\tint my = y + i;\n\t\t\tv.push_back( P(mx,my) );\n\t\t}\n\t}\n\treturn v;\n}\n\n// ブロックを落とす, ay := ブロックの一番高い位置 + 10\nvoid fall(vector<P> v, int& ay){\n\t// flag := ブロックが1マス落下できるかどうか\n\tbool flag = true;\n\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\tint x = v[i].first;\n\t\tint y = v[i].second;\n\t\tif( s[y-1][x] == '#' ){\n\t\t\tflag = false;\n\t\t}\n\t}\n\t\n\tif( flag ){ // 1マス落下させるとき\n\t\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\t\tv[i].second--;\n\t\t}\n\t\tfall( v , ay );\n\t}else{ // ブロックの落下位置が決まる\n\t\tint my = v[0].second;\n\t\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\t\tint x = v[i].first;\n\t\t\tint y = v[i].second;\n\t\t\ts[y][x] = '#';\n\t\t\tmy = max( my , y );\n\t\t}\n\t\tay = my + 10;\n\t}\n}\n\n// 高さ y が揃ったかどうか\nbool is_line(int y){\n\treturn (s[y][0] == '#' && s[y][1] == '#' && s[y][2] == '#' && s[y][3] == '#' && s[y][4] == '#');\n}\n\n// 高さ l の列を消す.\nvoid remove(int l, int ay){\n\tfor(int y=l ; y < ay ; y++ ){\n\t\ts[y][0] = s[y+1][0];\n\t\ts[y][1] = s[y+1][1];\n\t\ts[y][2] = s[y+1][2];\n\t\ts[y][3] = s[y+1][3];\n\t\ts[y][4] = s[y+1][4];\n\t}\n}\n\n// 揃った列があるか調べて消す.\nvoid check(int ay){\n\tfor(int y=1 ; y < ay ; y++ ){\n\t\tif( is_line(y) ){\n\t\t\tremove(y,ay);\n\t\t\ty--;\n\t\t}\n\t}\n}\n\nint block_count(int ay){\n\tint ans = 0;\n\tfor(int y=1 ; y < ay ; y++ ){\n\t\tfor(int x=0 ; x < 5 ; x++ ){\n\t\t\tif( s[y][x] == '#' ) ans++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint n;\n\twhile( cin >> n , n ){\n\t\tini();\n\t\tint y=10;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\t\t\tvector<P> v = block(d,p,q-1,y);\n\t\t\tfall(v,y);\n\t\t\tcheck(y);\n\t\t\t// debug(y);\n\t\t}\n\t\tint ans = block_count(y);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nint fall(vector<vector<int>>&field, vector<vector<int>>&pino,int l) {\n\t{\n\n\t}\n\tint y = 0;\n\tfor ( y = 0; y < field.size() - pino.size(); ++y) {\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < pino.size(); ++i) {\n\t\t\tfor (int j = 0; j < pino[i].size(); ++j) {\n\t\t\t\tif (pino[i][j]) {\n\t\t\t\t\tif (field[y + i+1][l + j])ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ok||y+pino.size()-1==field.size()) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < pino.size(); ++i) {\n\t\tfor (int j = 0; j < pino[i].size(); ++j) {\n\t\t\tif (pino[i][j]) {\n\t\t\t\tassert(!field[y + i][l + j]);\n\t\t\t\tfield[y + i][l + j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint delline = 0;\n\tfor (int i = y + pino.size() - 1; i >= y; --i) {\n\t\tif (all_of(field[i].begin(), field[i].end(), [](const int a) {return a == 1; })) {\n\t\t\ttransform(field[i].begin(), field[i].end(), field[i].begin(), [](const int a) {return false; });\n\t\t\tfor (int j = i- 1; j >= 0; --j) {\n\t\t\t\tswap(field[j], field[j + 1]);\n\t\t\t}\n\t\t\tdelline += 1;\n\t\t}\n\t}\n\treturn delline;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tint sum = 0;\n\t\tvector<vector<int>>field(5*N+10, vector<int>(5));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint d, p, q; cin >> d >> p >> q; q--;\n\t\t\tint w = d == 2 ? 1 : p;\n\t\t\tint h = d == 1 ? 1 : p;\n\t\t\tsum += p;\n\t\t\tvector<vector<int>>pino(h, vector<int>(w, 1));\n\t\t\tsum -= fall(field, pino, q) * 5;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <ctime>\nusing namespace std;\n\nint main(){\n\tclock_t c1 = clock();\n\tint s = 0, n;\n\twhile(scanf(\"%d\", &n), n){\n\t\ts += n;\n\t\tscanf(\"%*d%*d%*d\");\n\t}\n\t\n\tclock_t c2 = c1 + CLOCKS_PER_SEC * (s / 1000000.0);\n\twhile(clock() < c2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass TETORIS {\npublic:\n    int N;\n    vector<vector<int> > bd;\n    TETORIS() : N(0) {}\n    void put(int len, int pos) {\n        int k;\n        for (k=bd.size()-1; k>=0; --k) {\n            for (int i=0; i<len; ++i) {\n                if (bd[k][pos+i]) goto brk;\n            }\n        } brk:;\n        ++k;\n        if ((int)bd.size() == k) bd.push_back(vector<int>(5, 0));\n        for (int i=0; i<len; ++i) {\n            bd[k][pos+i] = 1;\n        }\n        N += len;\n    }\n    void update() {\n        for (int i=bd.size()-1; i>=0; --i) {\n            if (bd[i][0] && bd[i][1] && bd[i][2] && bd[i][3] && bd[i][4]) {\n                bd.erase(bd.begin()+i);\n                N -= 5;\n            }\n        }\n    }\n};\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        TETORIS tet;\n        int d, p, q;\n        for (int i=0; i<n; ++i) {\n            cin >> d >> p >> q;\n            --q;\n            if (d == 1) {\n                tet.put(p, q);\n                tet.update();\n            } else {\n                for (int j=0; j<p; ++j) tet.put(1, q);\n                tet.update();\n            }\n        }\n        cout << tet.N << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n\nusing namespace std;\ntypedef pair<int,int> ii;\nint field[5010][5];\nint top[5];\nint n,d,p,q;\nvector<ii> input;\n\n\nvoid print()\n{\n  int st = 0;\n  rep(i,5)st = max(st,top[i]);\n  for(int y=st;y>=0;y--)\n    {\n      rep(x,5)\n\t{\n\t  cout << field[y][x] << \" \";\n\t}\n      cout << endl;\n    }\n}\n\nbool checkX(int y)\n{\n  rep(x,5)if(!field[y][x])return false;\n  return true;\n}\n\nvoid updateD(int x,int y)\n{\n  ii info = input[field[y][x]];\n  if(info.first == 1)\n    {//yoko\n      while(true)\n\t{\n\t  bool check = true;\n\t  rep(i,5)\n\t    {\n\t      if(field[y][x] != field[y][i])continue;\n\t      if(y-1 >= 0 && field[y-1][i] != 0)\n\t\t{\n\t\t  check = false;\n\t\t  break;\n\t\t}\n\t    }\n\t  if(!check)return;\n\t  int v = field[y][x];\n\t  rep(i,5)\n\t    {\n\t      if(v != field[y][i])continue;\n\t      assert(field[y-1][i] == 0);\n\t      field[y-1][i] = field[y][i];\n\t      field[y][i] = 0;\n\t    }\n\t  y = y-1;\n\t  if(y <= 0)return;\n\t}\n    }\n  else\n    {\n      int v = field[y][x];\n    \n      int bot = 0;\n      int py = y;\n      while(py-1 >= 0 && field[py-1][x] == 0)py--;\n      bot = y-py;\n\n      if(bot == 0)return;\n\n      while(v == field[y][x])\n\t{\n\t  assert(y-bot >= 0);\n\t  assert(field[y-bot][x] == 0);\n\t  field[y-bot][x] = field[y][x];\n\t  field[y][x] = 0;\n\t  y++;\n\t}\n\t\n    }\n}\n\nint main()\n{\n  while(cin >> n,n)\n    {\n      input.clear();\n      input.resize(1010,ii(-1,-1));\n      rep(i,5010)rep(j,5)field[i][j] = 0;\n      rep(i,5)top[i] = 0;\n      int cyb,cyt;\n      REP(i,1,n+1)\n\t{\n\t  cin >> d >> p >> q;\n\n\t  if(d == 1 && p == 5)continue;\n\t  q--;\n\t  input[i] = ii(d,p);\n\n\t  if(d == 2)\n\t    {\n\t      cyb = top[q],cyt = top[q]+p;\n\t      REP(j,top[q],top[q]+p)field[j][q] = i;\n\t      top[q] += p;\n\t    }\n\t  else\n\t    {\n\t      int mexico = -inf;\n\t      REP(j,q,q+p)mexico = max(mexico,top[j]);\n\t      REP(j,q,q+p)field[mexico][j] = i;\n\t      cyb = cyt = mexico;\n\t      REP(j,q,q+p)top[j] = mexico+1;\n\t    }\n\n\t  //update top\n\t  \n\t  rep(j,5)\n\t    {\n\t      int y = top[j];\n\t      while(y >= 0 && field[y][j] == 0)y--;\n\t      top[j] = y+1;\n\t    }\n\t  /*\n  cout << \"top = \";\n\t  rep(j,5)cout << top[j] << \" \";\n\t  cout << endl;\n\t  print();\n\n\t  cout << \"----------------\" << endl;\n\t  */\n\t}\n      cyb = 0;\n      rep(i,5)cyt = max(cyt,top[i]);\n      \n      bool update = true;\n      int cnt = 0;\n      while(update)\n\t{\n\t  assert(cnt < 2);\n\t  cnt++;\n\t  update = false;\n\t  //check\n\t  vector<int> erasedY;\n\t  REP(y,cyb,cyt+1)\n\t    {\n\t      if(checkX(y))\n\t\t{\n\t\t  erasedY.push_back(y);\n\t\t  rep(x,5)field[y][x] = 0;\n\t\t}\n\t    }\n\n\t  //print();\n\t  //down\n\t  if(!erasedY.empty())\n\t    {\n\t      update = true;\n\n\t      int yt = 0;\n\t      rep(j,5)yt = max(yt,top[j]);\n\t      rep(j,erasedY.size())\n\t\t{\n\t\t  REP(y,erasedY[j],yt)\n\t\t    {\n\t\t      int pre = -1;\n\t\t      rep(x,5)\n\t\t\t{\n\t\t\t  if(field[y][x] == pre)continue;\n\t\t\t  if(field[y][x] == 0 || y-1 < 0)continue;\n\n\t\t\t  pre = field[y][x];\n\t\t\t  updateD(x,y);\n\t\t\t}\n\t\t    }\n\t\t}\n\n\n\t    }\n\t\n\t  // print();\n\t  \n\t}\n\t\n\t  \n\t\n      int yt = 0;\n      rep(i,5)yt = max(yt,top[i]);\n      int ans = 0;\n      rep(y,yt)\n\trep(x,5)\n       \t  if(field[y][x] != 0)ans++;\t\n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int N = 6000;\n//const int N = 10;\nbool block[N][5];\n\n\nvoid output(){\n  cout <<\"Begin\"<<endl;\n  rep(i,10){\n    rep(j,5){\n      cout << block[9-i][j] << \" \";\n    }\n    cout << endl;\n  }\n  cout <<\"end\"<<endl;\n}\n\nvoid all_fall(int y){\n  rep(j,5)block[y][j]=false;\n\n  \n  REP(i,y,N-1){\n    rep(j,5)block[i][j]=block[i+1][j];\n\n  }\n  \n  rep(j,5)block[N-1][j]=false;\n}\n\nint getmax(int l,int r){\n  int ret=0;\n  REP(j,l,r){    \n    int tmp = N-1;\n    for(int i=N-1;i>=0;i--){\n      if (block[i][j])break;\n      tmp=i;\n    }\n    ret=max(ret,tmp);\n  }\n  return ret;\n}\n\nvoid fall(){\n  rep(i,N){\n    if (block[i][0]&block[i][1]&block[i][2]&block[i][3]&block[i][4]){\n      all_fall(i);\n      i--;\n    }\n  }\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    rep(i,N)rep(j,5)block[i][j]=false;\n    rep(i,n){\n      int d,p,q;\n      int wid=1,hei=1,pos;\n      cin>>d>>p>>q;\n      q--;\n      if (d == 1){//yoko\n\tpos = getmax(q,q+p);\t\n\twid=p;\n      }else if (d == 2){//tate\n\tpos = getmax(q,q+1);\n\thei=p;\n      }\n\n      rep(i,hei){\n\trep(j,wid){\n\t  block[pos+i][q+j]=true;\n\t}\n      }\n      fall();\n      //output();\n    }\n\n    cout << count(&block[0][0],&block[N][0],true) << endl;\n    //    cout << cnt << endl;\n  }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int HORIZONTAL = 1;\nconst int VERTICAL   = 2;\nconst int MAX_H = 5000;\nconst int WIDTH = 5;\nconst int N_BLOCK_MAX = 1000;\n\nclass Block\n{\npublic:\n\tint d, p, q;\n\tBlock() {}\n};\n\nclass Row\n{\npublic:\n\tint i[5];\n\tRow()\n\t{\n\t\tfor(int m=0; m<5; m++) i[m] = 0;\n\t}\n};\n\nint n;\nvector<Row> field;\n\nbool isSetOk(Block b, int y)\n{\n\tif(b.d == HORIZONTAL)\n\t{\n\t\tfor(int dx=0; dx<b.p; dx++)\n\t\t{\n\t\t\tint xx = b.q + dx;\n\t\t\tif(field[y].i[xx]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\telse if(b.d == VERTICAL)\n\t{\n\t\tfor(int dy=0; dy<b.p; dy++)\n\t\t{\n\t\t\tint yy = y + dy;\n\t\t\tif(field[yy].i[b.q]) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nvoid setBlock(Block b, int y)\n{\n\tif(b.d == HORIZONTAL)\n\t{\n\t\tfor(int dx=0; dx<b.p; dx++)\n\t\t{\n\t\t\tint xx = b.q + dx;\n\t\t\tfield[y].i[xx] = 1;\n\t\t}\n\t}\n\telse if(b.d == VERTICAL)\n\t{\n\t\tfor(int dy=0; dy<b.p; dy++)\n\t\t{\n\t\t\tint yy = y + dy;\n\t\t\tfield[yy].i[b.q] = 1;\n\t\t}\n\t}\n}\n\nvoid checkErase()\n{\n\tvector<Row>::iterator iter = field.begin();\n\twhile(iter != field.end())\n\t{\n\t\tbool is_empty = true;\n\t\tbool is_fill = true;\n\t\tfor(int x=0; x<WIDTH; x++)\n\t\t{\n\t\t\tif((*iter).i[x] != 0) is_empty = false;\n\t\t\tif((*iter).i[x] == 0) is_fill = false;\n\t\t}\n\n\t\tif(is_fill)\n\t\t{\n\t\t\tfield.erase(iter);\n\t\t\tcontinue;\n\t\t}\n\t\t\t\n\t\tif(is_empty) return;\n\n\t\t++iter;\n\t}\n}\n\nint countBlock()\n{\n\tint retVal = 0;\n\tfor(int y=0; y<MAX_H; y++)\n\t{\n\t\tbool is_empty = true;\n\t\tfor(int x=0; x<WIDTH; x++)\n\t\t{\n\t\t\tif(field[y].i[x] != 0)\n\t\t\t{\n\t\t\t\tis_empty = false;\n\t\t\t\tretVal++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(is_empty) break;\n\t}\n\n\treturn retVal;\n}\n\nint main()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tfield = vector<Row>(MAX_H);\n\t\tfor(int i=0; i<n; i++)\n\t\t{\n\t\t\tBlock block;\n\t\t\tcin >> block.d;\n\t\t\tcin >> block.p;\n\t\t\tcin >> block.q;\n\t\t\tblock.q--;\n\n\t\t\tfor(int j=field.size()-1; j>=0; j--)\n\t\t\t{\n\t\t\t\tif(!isSetOk(block, j))\n\t\t\t\t{\n\t\t\t\t\tsetBlock(block, j+1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif(j==0)\n\t\t\t\t{\n\t\t\t\t\tsetBlock(block, 0);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcheckErase();\n\t\t\t\n/*\n\t\t\tfor(int y=9; y>=0; y--)\n\t\t\t{\n\t\t\t\tfor(int x=0; x<WIDTH; x++)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d \", field[y].i[x]);\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n*/\n\t\t}\t\n\t\tprintf(\"%d\\n\", countBlock());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define H_MAX 1001\nusing namespace std;\n\nvoid breakLine(int data[H_MAX][5], int y) {\n  for(int i = y; i+1 < H_MAX; i++) {\n    for(int j = 0; j < 5; j++) {\n      data[i][j] = data[i+1][j];\n    }\n  }\n}\n\nvoid search(int data[H_MAX][5], int sy, int ey) {\n  for(int i = sy; i <= ey; i++) {\n    bool flag = true;\n    for(int j = 0; j < 5; j++) {\n      if(data[i][j] != 1) {\n\tflag = false;\n\tbreak;\n      }\n    }\n    if(flag) {\n      breakLine(data, i);\n      i--;\n    }\n  }\n}\n\nint main() {\n  while(1) {\n    int n;\n    cin >> n;\n    if(n == 0) break;\n\n    int data[H_MAX][5];\n    fill(&data[0][0], &data[H_MAX-1][4] + 1, 0);\n    for(int i = 0; i < 5; i++) {\n      data[0][i] = 1;\n    }\n\n    for(int i = 0; i < n; i++) {\n      int d, p, q, qy;\n      cin >> d >> p >> q;\n      q--;\n      for(int y = H_MAX-1; y >= 0; y--) {\n\tbool put = false;\n\tswitch(d) {\n\tcase 1:\n\t  for(int j = 0; j < p; j++) {\n\t    if(data[y][q+j] == 1) {\n\t      put = true;\n\t      y++;\n\t      qy = y;\n\t      for(int k = 0; k < p; k++) {\n\t\tdata[y][q+k] = 1;\n\t      }\n\t      break;\n\t    }\n\t  }\n\t  break;\n\tcase 2:\n\t  if(data[y][q] == 1) {\n\t    put = true;\n\t    y++;\n\t    qy = y;\n\t    for(int j = 0; j < p; j++) {\n\t      data[y+j][q] = 1;\n\t    }\n\t  }\n\t  break;\n\t}\n\tif(put) {\n\t  break;\n\t}\n      }\n\n      switch(d) {\n      case 1: search(data, qy, qy); break;\n      case 2: search(data, qy, qy+p-1); break;\n      }\n    }\n\n    int count = 0;\n    for(int i = 1; i < H_MAX; i++) {\n      for(int j = 0; j < 5; j++) {\n\tcount += data[i][j];\n      }\n    }\n    cout << count << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n\nusing namespace std;\n\n#define int long long\n\nlist<bool*> fld;\n\nlist<bool*>::iterator GetHeight(int l, int r)\n{\n\tlist<bool*>::iterator itr = fld.begin();\n\tfld.push_front((bool*)new bool[5]{});\n\tfor (; itr != fld.end(); itr++)\n\t{\n\t\tfor (int j = l; j < r; j++)\n\t\t{\n\t\t\tif ((*itr)[j] == true) return --itr;\n\t\t}\n\t}\n\treturn --itr;\n}\n\nbool IsFull(list<bool*>::iterator itr)\n{\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif ((*itr)[i] == false) return false;\n\t}\n\treturn true;\n}\n\nbool IsEmpty(list<bool*>::iterator itr)\n{\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif ((*itr)[i] == true) return false;\n\t}\n\treturn true;\n}\n\nvoid Drop(int d, int p, int q)\n{\n\tif (!IsEmpty(fld.begin())) fld.push_front((bool*)new bool[5]{});\n\tint l = q - 1, r = (d == 1) ? l + p : l + 1;\n\tlist<bool*>::iterator itr = GetHeight(l, r);\n\n\tint h = (d == 1) ? 1 : p;\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tif (itr == fld.begin()) fld.push_front((bool*)new bool[5]{});\n\t\tfor (int j = l; j < r; j++)\n\t\t{\n\t\t\t(*itr)[j] = true;\n\t\t}\n\t\tif (IsFull(itr))\n\t\t{\n\t\t\tdelete *itr;\n\t\t\titr = fld.erase(itr);\n\t\t}\n\t\titr--;\n\t}\n}\n\nsigned main()\n{\n\tint N;\n\twhile (cin >> N, N)\n\t{\n\t\tfld.clear();\n\t\tfld.push_back((bool*)new bool[5]{});\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\t\t\tDrop(d, p, q);\n\t\t}\n\t\tint ans = 0;\n\t\tfor (list<bool*>::iterator itr = fld.begin(); itr != fld.end(); itr++)\n\t\t{\n\t\t\tfor (int i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tans += ((*itr)[i] == true);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define MH 5000\nusing namespace std;\nbool ck(int *f){\n\trep(i,5)if(!f[i])return 0;\n\treturn 1;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tint d,l,x,y,c=0;\n\t\tint field[MH][5]={0};\n\t\trep(i,n){\n\t\t\tcin>>d>>l>>x,y=MH,x--,d--;\n\t\t\tfor(;y>0;y--)rep(j,(d?1:l))if(field[y-1][x+j])goto END;\n\t\t\tEND:\n\t\t\trep(j,l)field[y+d*j][x+(1-d)*j]=1;\n\t\t\trep(i,MH)while(ck(field[i])){\n\t\t\t\trep(j,MH-i-1)rep(k,5)field[j+i][k]=field[j+i+1][k];\n\t\t\t\trep(k,5)field[MH-1][k]=0;\n\t\t\t}\n\t\t}\n\t\trep(i,MH)rep(j,5)c+=field[i][j];\n\t\tcout<<c<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\tflg &= board[h_max][j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tfor(int k = h_max; k < top[j]; k++) {\n\t\t\t\t\t\t\tboard[k][j] = board[k + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\n\t\t\t\tint h = top[q - 1];\n\t\t\t\ttop[q - 1] += p;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tflg &= board[h + j][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tboard[h + j - del][k] = board[h + j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdel++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tfor(int k = h + p - del; k < top[j] + 10; k++) {\n\t\t\t\t\t\tboard[k][j] = board[k + del][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\nbool flg = true;\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tans += board[i][j];\nflg &= board[i][j];\n\t\t\t}\nif(flg) abort();\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 10; i >= 0; i--) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tcout << (board[i][j] ? '*' : '.');\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t// */\n\t\t/*\n\t\tfor(int i = 0; i < 5; i++)\n\t\t\tcout << top[i] << \" \";\n\t\tcout << endl;\n\t\t// */\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nint n, hmax;\nbool maps[5000][5];\n\nint serch(int x, int l) {\n\tfor (int i = hmax; i >= 0; i--) {\n\t\tREP(j, l) if (maps[i][x + j]) return i + 1;\n\t}\n\treturn 0;\n}\n\nint check(int y, int l) {\n\tREP(i, l) {\n\t\tbool flag = true;\n\t\tREP(j, 5) if (!maps[y + i][j]) flag = false;\n\t\tif (flag) return y + i;\n\t}\n\treturn -1;\n}\n\nvoid bset(int d, int p, int q) {\n\tint hl = d == 2 ? p : 1;\n\tint xl = d == 1 ? p : 1;\n\tint hpos = serch(q - 1, xl);\n\t\n\tif (d == 1) REP(i, p) maps[hpos][q + i - 1] = true;\n\telse REP(i, p) maps[hpos + i][q - 1] = true;\n\thmax = max(hmax, hpos + hl);\n\t\n\tint tmp;\n\twhile ((tmp = check(hpos, hl)) != -1) {\n\t\tREP(i, 5) maps[tmp][i] = false;\n\t\tFOR(i, tmp, hmax) {\n\t\t\tREP(j, 5) swap(maps[i][j], maps[i + 1][j]);\n\t\t}\n\t\thmax--;\n\t}\n}\n\nint main() {\n\twhile (cin >> n, n) {\n\t\tmemset(maps, 0, sizeof(maps));\n\t\thmax = 0;\n\t\t\n\t\twhile (n--) {\n\t\t\tint d, p, q;\n\t\t\tscanf(\"%d %d %d\", &d, &p, &q);\n\t\t\tbset(d, p, q);\n\t\t}\n\t\tcout << count(maps[0], maps[5000], true) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint i,j,n,a,b,c,d,e,f,g,m[5050];\n\twhile(cin >> n) {\n\t\tif (n==0) break;\n\t\tfor (j=0;j<5050;j++) m[j]=0; d=1;\n\t\tfor (i=0;i<n;i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tf=a >1 ? 1 << (c-1) : ((1 << b)-1)  << (c-1);  \n\t\t\tfor (j=d;j>=0;j--) if ( m[j]+f != (m[j] | f)) break;\n\t\t\te=g=j+1; \n\t\t\tif (a==1) { m[e]+=f; d++;}  else for (j=0;j<b;j++) { m[e+j]+=f; d++;}\n\t\t\tfor (j=g; j<g+d+5; j++) if (m[j]<31) m[e++]=m[j]; else d--; \n\t\t}\n\t\tf=0;\n\t\tfor (i=0;i<5050;i++) for (j=0;j<5;j++) f+=(m[i] & ( 1 << j))>0;\n\t\tcout << f << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n \nusing namespace std;\n \nconst int Height = 5010;\nconst int Width = 5;\nchar field[Height][Width];\nint top,ans;\nint dx[] = {1,0};\nint dy[] = {0,-1};\n \nvoid print(int h, int w){\n \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl;\n     \n}\nbool isInside(int h, int w){return 0<=h&&h<Height&&0<=w&&w<Width;}\n \nint getH(int d, int len, int pos){\n  for(int i = top+6; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?' || !isInside(h,w)) return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n}\n\nvoid down(int n){\n \n  for(int i = n; i <= top+6; i++)\n    for(int j = 0; j < Width; j++) field[i][j] = field[i+1][j];\n  top--;\n}\n\nvoid erase(){\n \n  while(1){\n    bool update = false;\n    for(int i = 0; i <= top+6; i++){\n      bool f = true;\n      for(int j = 0; j < Width; j++) if(field[i][j] == '?') f = false;\n      if(f){\n\tans -= 5;\n\tdown(i--);\n\tupdate = true;\n      }\n    }\n    if(!update) break;\n  }\n}\n \nvoid put(int d, int len, int pos){\n \n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n \n  int h = nex;\n  int w = pos;\n \n  for(int i = 0; i < len; i++){\n    field[h][w] = '.';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n \nint main(){\n \n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    ans = top = 0;\n    \n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      ans += len;\n      put(d-1,len,pos-1);\n      erase();\n    }\n    cout << ans << endl;\n    //  print(5,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//14\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    const int h=5000;\n    bool g[h][5]={{}};\n    fill(g[h-1],g[h],true);\n    while(n--){\n      int d,p,q;\n      cin>>d>>p>>q;\n      int y;\n      for(y=0;;y++){\n\tif(d==2){\n\t  if(g[y+1][q-1])break;\n\t}else{\n\t  int i;\n\t  for(i=0;i<p;i++){\n\t    if(g[y+1][q-1+i])break;\n\t  }\n\t  if(i<p)break;\n\t}\n      }\n      for(int i=0;i<p;i++){\n\tint dy=0,dx=0;\n\t((d==2)?dy:dx)=i;\n\tg[y-dy][q-1+dx]=true;\n      }\n      for(int i=0;i<h-1;i++){\n\tif(count(g[i],g[i+1],true)==5){\n\t  for(int j=i;j>=1;j--){\n\t    for(int x=0;x<5;x++){\n\t      g[j][x]=g[j-1][x];\n\t    }\n\t  }\n\t}\n      }\n    }\n    cout<<count(g[0],g[h-1],true)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 1e9\n\nint field[5000][5],tmp[5000][5];\n\nvoid down(){\n  memset(tmp,0,sizeof(tmp));\n  for(int j = 0 ; j < 5 ; j++){\n    int p = 4999;\n    for(int i = 4999 ; i >= 0 ; i--){\n      if(field[i][j] == -1) continue;\n      tmp[p--][j] = field[i][j];\n    }\n  }\n  for(int i = 0 ; i < 5000 ; i++){\n    for(int j = 0 ; j < 5 ; j++){\n      field[i][j] = tmp[i][j];\n    }\n  }\n}\n\nvoid remove(){\n  bool flg = false;\n  for(int i = 0 ; i < 5000 ; i++){\n    int cnt = 0;\n    for(int j = 0 ; j < 5 ; j++,cnt++){\n      if(!field[i][j]) break;\n    }\n    if(cnt == 5){\n      flg = true;\n      for(int j = 0 ; j < 5 ; j++){\n        field[i][j] = -1;\n      }\n    }\n  }\n  \n  if(flg){\n    down();\n  }\n}\n\nint main(){\n  int N,d,p,q;\n\n  while(cin >> N,N){\n    memset(field,0,sizeof(field));\n    for(int i = 0 ; i < N ; i++){\n      cin >> d >> p >> q; q--;\n\n      if(d == 1){\n        int min = INF;\n        for(int j = q ; j < p+q ; j++){\n          for(int i = 0 ; i < 5000 ; i++){\n            if(i == 4999 || field[i+1][j] == 1){\n              min = std::min(min,i);\n              break;\n            }\n          }\n        }\n        for(int j = q ; j < p+q ; j++){\n          field[min][j] = 1;\n        }\n      }else{\n        for(int i = 0 ; i < 5000 ; i++){\n          if(i == 4999 || field[i+1][q] == 1){\n            for(int j = 0 ; j < p ; j++){\n              field[i-j][q] = 1;\n            }\n            break;\n          }\n        }\n      }\n      remove();\n    }\n    int ans = 0;\n    for(int i = 0 ; i < 5000 ; i++){\n      for(int j = 0 ; j < 5 ; j++){\n        if(field[i][j] == 1) ans++;\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint i,j,n,a,b,c,d,e,f,g,m[5050];\n\twhile(cin >> n) {\n\t\tif (n==0) break;\n\t\tfor (j=0;j<5050;j++) m[j]=0; d=1;\n\t\tfor (i=0;i<n;i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tf=a >1 ? 1 << (c-1) : ((1 << b)-1)  << (c-1);  \n\t\t\tfor (j=d;j>=0;j--) if ( m[j]+f != (m[j] | f)) break;\n\t\t\te=g=j+1; \n\t\t\tif (a==1) { m[e]+=f; d++;}  else for (j=0;j<b;j++) { m[e+j]+=f; d++;}\n\t\t\tfor (j=g; j<d+5; j++) if (m[j]<31) m[e++]=m[j]; \n\t\t}\n\t\tf=0;\n\t\tfor (i=0;i<5050;i++) for (j=0;j<5;j++) f+=(m[i] & ( 1 << j))>0;\n\t\tfor (i=10;i>=0;i--) {\n\t\t\tfor (j=4;j>=0;j--) if ((m[i] & (1 << j))>0) cout << '1'; else cout << '0';\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << f << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#define max(a,b) (a>b?a:b)\nchar B[6005][5];\nint N,d,p,q,res;\n\n\nint cnt(int y,int x,int c)\n{\n\tint t=0;\n\tfor(int i=0;i<c;i++)\n\t\tt+=B[y][x+i];\n\treturn t;\n}\n\nvoid dbg()\n{\n\tfor(int i=0;;i++,puts(\"\"))\n\t{\n\t\tint f=cnt(i,0,5);\n\t\tif(!f)break;\n\t\tfor(int j=0;j<5;j++)\n\t\t\tputchar(B[i][j]?'x':' ');\n\t}\n\tputs(\"\");\n}\n\n\nint sch(int h,int w,int p,int y)\n{\n\tint i;\n\tfor(i=y;i>=0;)\n\t{\n\t\tint l=cnt(i,p,w);\n\t\tif(!l)\n\t\t{\n\t\t\tif(i&&cnt(i-1,p,w)==0)\n\t\t\t\ti--;\n\t\t\telse\n\t\t\t\treturn i;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(cnt(i+1,p,w)==0)\n\t\t\t\ti++;\n\t\t\telse\n\t\t\t\treturn i;\n\t\t}\n\t}\n\treturn i;\n}\n\nvoid Tset(int y,int x,int h,int w)\n{\n\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\t\tB[y+i][x+j]=1;\n}\n\nvoid flsh()\n{\n\tfor(int i=0;;)\n\t{\n\t\tint j,f=cnt(i,0,5);\n\t\tif(!f)break;\n\t\tif(f==5)\n\t\t{\n\t\t\tint tmp=sizeof(char)*(6000*5-i*(5+1));\n\t\t\tmemmove(B,B+1,sizeof(char)*100);\n\t\t\tres-=5;\n\t\t}\n\t\telse\n\t\t\ti++;\n\t}\n}\n\nint r()\n{\n\tint res=0;\n\tfor(int i=0;;i++)\n\t{\n\t\tint t=cnt(i,0,5);\n\t\tif(t==0)break;\n\t\telse if(t==5)continue;\n\t\telse res+=t;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tint h=0,t;\n\t\tres=0;\n\t\tmemset(B,0,sizeof(B));\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&d,&p,&q);\n\t\t\tres+=p;\n\t\t\tq--;\n\t\t\tt=sch(d==1?1:p,d==1?p:1,q,h);\n\t\t\tTset(t,q,d==1?1:p,d==1?p:1);\n\t\t\tif(d==2)t+=p;\n\t\t\telse t++;\n\t\t\th=max(t,h);\n\t\t}\n\t\t//dbg();\n\t\tprintf(\"%d\\n\",r());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint fall(vector<vector<int>>&fi, vector<vector<int>>&pi,int fall_l) {\n\tint fall_u = 0;\n\tfor (; fall_u < fi.size() - pi.size(); ++fall_u) {\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < pi.size(); ++i) {\n\t\t\tfor (int j = 0; j < pi[i].size(); ++j) {\n\t\t\t\tif (pi[i][j]) {\n\t\t\t\t\tif (fi[fall_u + i+1][fall_l + j])ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < pi.size(); ++i) {\n\t\tfor (int j = 0; j < pi[i].size(); ++j) {\n\t\t\tif (pi[i][j]) {\n\t\t\t\tfi[fall_u + i][fall_l + j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint delline = 0;\n\tfor (int i = fall_u + pi.size() - 1; i >= fall_u; --i) {\n\t\twhile (all_of(fi[i].begin(), fi[i].end(), [](const int a) {return a == 1; })) {\n\t\t\ttransform(fi[i].begin(), fi[i].end(), fi[i].begin(), [](const int a) {return false; });\n\t\t\trotate(fi.begin(), fi.begin() + i, fi.begin() + i+1); \n\t\t\tdelline += 1;\n\t\t}\n\t}\n\treturn delline;\n}\n\nint main() {\n\tint N;\n\twhile (cin>>N,N) {\n\t\tint sum = 0;\n\t\tvector<vector<int>>field(5*N, vector<int>(5));\n\t\twhile(N--){\n\t\t\tint d, p, q; cin >> d >> p >> q; q--;\n\t\t\tsum += p;\n\t\t\tvector<vector<int>>pino(d == 1 ? 1 : p, vector<int>(d == 2 ? 1 : p, 1));\n\t\t\tsum -= fall(field, pino, q) * 5;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint grid[5][6000];\nint n,d,p,q;\nll int ans = 0;\n\nint GetBottom(int x){\n\tREP(i,6000){\n\t\tif(grid[x][i]==-1) return i;\n\t}\n\treturn 0;\n}\n\nbool isallclear(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=-1) return false;\n\t}\n\treturn true;\n}\n\nbool isallblock(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(cin>>n,n){\n\t\tREP(i,5) REP(j,6000) grid[i][j] = -1;\n\t\tREP(i,n){\n\t\t\tcin >> d >> p >> q;\n\t\t\tif(d==2){\n\t\t\t\tint tmp = GetBottom(q-1);\n\t\t\t\tFOR(j,tmp,tmp+p) grid[q-1][j] = 1;\n\t\t\t}else{\n\t\t\t\tint tmp = -1;\n\t\t\t\tFOR(j,q-1,q-1+p){\n\t\t\t\t\ttmp = max(tmp,GetBottom(j));\n\t\t\t\t}\n\t\t\t\tFOR(j,q-1,q-1+p) {\n\t\t\t\t\tgrid[j][tmp] = 1;\n\t\t\t\t\tREP(k,tmp) if(grid[j][k]==-1) grid[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowline = 0;\n\t\t\twhile(1){\n\t\t\t\tif(isallclear(nowline)) break;\n\t\t\t\tif(isallblock(nowline)){\n\t\t\t\t\tREP(j,5) {\n\t\t\t\t\t\tint nline = nowline+1;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tif(grid[j][nline]==-1) {\n\t\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\tnline++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tnowline++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tint line = 0;\n\t\twhile(1){\n\t\t\tif(isallclear(line)) break;\n\t\t\tREP(i,5){\n\t\t\t\tif(grid[i][line]==1) ans++;\n\t\t\t}\n\t\t\tline++;\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n\nusing namespace std;\n\n#define int long long\n\nlist<bool*> fld;\n\nlist<bool*>::iterator GetHeight(int l, int r)\n{\n\tlist<bool*>::iterator itr = fld.begin();\n\titr++;\n\tfor (; itr != fld.end(); itr++)\n\t{\n\t\tfor (int j = l; j < r; j++)\n\t\t{\n\t\t\tif ((*itr)[j] == true) return --itr;\n\t\t}\n\t}\n\treturn --itr;\n}\n\nbool IsFull(list<bool*>::iterator itr)\n{\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif ((*itr)[i] == false) return false;\n\t}\n\treturn true;\n}\n\nbool IsEmpty(list<bool*>::iterator itr)\n{\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif ((*itr)[i] == true) return false;\n\t}\n\treturn true;\n}\n\nvoid Drop(int d, int p, int q)\n{\n\tif (!IsEmpty(fld.begin())) fld.push_front((bool*)new bool[5]{});\n\tint l = q - 1, r = (d == 1) ? l + p : l + 1;\n\tlist<bool*>::iterator itr = GetHeight(l, r);\n\n\tint h = (d == 1) ? 1 : p;\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tif (itr == fld.begin()) fld.push_front((bool*)new bool[5]{});\n\t\tfor (int j = l; j < r; j++)\n\t\t{\n\t\t\t(*itr)[j] = true;\n\t\t}\n\t\tif (IsFull(itr))\n\t\t{\n\t\t\tdelete *itr;\n\t\t\titr = fld.erase(itr);\n\t\t}\n\t\titr--;\n\t}\n}\n\nsigned main()\n{\n\tint N;\n\twhile (cin >> N, N)\n\t{\n\t\tfld.clear();\n\t\tfld.push_back((bool*)new bool[5]{});\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\t\t\tDrop(d, p, q);\n\t\t}\n\t\tint ans = 0;\n\t\tfor (list<bool*>::iterator itr = fld.begin(); itr != fld.end(); itr++)\n\t\t{\n\t\t\tfor (int i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tans += ((*itr)[i] == true);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n\nint fall(vector<vector<int>>&field, vector<vector<int>>&pino,int l) {\n\t{\n\n\t}\n\tint y = 0;\n\tfor ( y = 0; y < field.size() - pino.size(); ++y) {\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < pino.size(); ++i) {\n\t\t\tfor (int j = 0; j < pino[i].size(); ++j) {\n\t\t\t\tif (pino[i][j]) {\n\t\t\t\t\tif (field[y + i+1][l + j])ok = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!ok) {\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor (int i = 0; i < pino.size(); ++i) {\n\t\tfor (int j = 0; j < pino[i].size(); ++j) {\n\t\t\tif (pino[i][j]) {\n\t\t\t\tassert(!field[y + i][l + j]);\n\t\t\t\tfield[y + i][l + j] = true;\n\t\t\t}\n\t\t}\n\t}\n\tint delline = 0;\n\tfor (int i = y + pino.size() - 1; i >= y; --i) {\n\t\twhile (all_of(field[i].begin(), field[i].end(), [](const int a) {return a == 1; })) {\n\t\t\ttransform(field[i].begin(), field[i].end(), field[i].begin(), [](const int a) {return false; });\n\t\t\tfor (int j = i- 1; j >= 0; --j) {\n\t\t\t\tswap(field[j], field[j + 1]);\n\t\t\t}\n\t\t\tdelline += 1;\n\t\t}\n\t}\n\treturn delline;\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tif (!N)break;\n\t\tint sum = 0;\n\t\tvector<vector<int>>field(5*N+10, vector<int>(5));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tint d, p, q; cin >> d >> p >> q; q--;\n\t\t\tint w = d == 2 ? 1 : p;\n\t\t\tint h = d == 1 ? 1 : p;\n\t\t\tsum += p;\n\t\t\tvector<vector<int>>pino(h, vector<int>(w, 1));\n\t\t\tsum -= fall(field, pino, q) * 5;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint t[5000][5];\n\nvoid destroy(void){\n\tfor(int i=4999;i>=0;i--){\n\t\tint count = 0;\n\t\tfor(int j=0;j<5;j++){\n\t\t\tcount += t[i][j];\n\t\t}\n\n\t\tif(count == 0) break;\n\n\t\telse if(count == 5){\n\t\t\tfor(int k=i;k>0;k--){\n\t\t\t\tcount = 0;\n\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\tt[k][j] = t[k-1][j];\n\t\t\t\t\tt[k-1][j] = 0;\n\t\t\t\t\tcount += t[k][j];\n\t\t\t\t}\n\t\t\t\tif(count == 0) break;\n\t\t\t}\n\t\t\ti--;\n\t\t}\n\t}\n}\n\nvoid setBlock(int d,int p,int q){\n\tint sj = q - 1;\n\tint w = d == 1 ? p : 1;\n\tint h = -1;\n\n\tfor(int i=0;i<4999;i++){\n\t\tfor(int j=sj;j<sj+w;j++){\n\t\t\tif(t[i+1][j]){\n\t\t\t\th = i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(h != -1) break;\n\t}\n\n\tif(h == -1) h = 4999;\n\n\tif(d == 1){\n\t\tfor(int j=sj;j<sj+p;j++) t[h][j] = 1;\n\t}\n\telse{\n\t\tfor(int i=h;i>h-p;i--) t[i][sj] = 1;\n\t}\n}\n\nint countBlock(void){\n\tint res = 0;\n\tfor(int i=4999;i>=0;i--){\n\t\tint count = 0;\n\t\tfor(int j=0;j<5;j++){\n\t\t\tcount += t[i][j];\n\t\t\tres += t[i][j];\n\t\t}\n\t\tif(count == 0) break;\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint n;\n\n\twhile(cin>>n && n){\n\t\tmemset(t,0,sizeof(t));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint d,p,q;\n\t\t\tcin>>d>>p>>q;\n\t\t\tsetBlock(d,p,q);\n\t\t\tdestroy();\n\t\t}\n\n\t\tdestroy();\n\t\tcout<<countBlock()<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dat[5000][5];\nint m[5];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<5000;i++)\n\t\t\tfor(int j=0;j<5;j++)dat[i][j]=0;\n\t\tfor(int i=0;i<5;i++)m[i]=0;\n\t\tint count=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint b,c,d;\n\t\t\tscanf(\"%d%d%d\",&b,&c,&d);d--;\n\t\t\tcount+=c;\n\t\t\tif(b==2){\n\t\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\t\tdat[m[d]+i][d]=1;\n\t\t\t\t\tbool ok=true;\n\t\t\t\t\tfor(int j=0;j<5;j++)if(!dat[m[d]+i][j])ok=false;\n\t\t\t\t\tif(ok){\n\t\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\t\tfor(int k=m[d]+i;k<4999;k++)dat[k][j]=dat[k+1][j];\n\t\t\t\t\t\t\tm[j]--;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount-=5;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tm[d]+=c;\n\t\t\t}else{\n\t\t\t\tint h=0;\n\t\t\t\tfor(int i=0;i<c;i++)h=max(h,m[i+d]);\n\t\t\t\tfor(int i=0;i<c;i++)dat[h][i+d]=1;\n\t\t\t\tfor(int i=0;i<c;i++)m[i+d]=h+1;\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int j=0;j<5;j++)if(!dat[h][j])ok=false;\n\t\t\t\tif(ok){\n\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\tfor(int k=h;k<4999;k++)dat[k][j]=dat[k+1][j];\n\t\t\t\t\t\tm[j]--;\n\t\t\t\t\t}\n\t\t\t\t\tcount-=5;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nvoid erase(bool(&field)[5000][5], int line){\n\n\tfor (int i = line; i < 4999; i++){\n\t\tfor (int j = 0; j < 5; j++){\n\t\t\tfield[i][j] = field[i + 1][j];\n\t\t}\n\t}\n}\n\nint main(){\n\n\tint n;\n\twhile (std::cin >> n, n){\n\n\t\tbool field[5000][5];\n\n\t\tfor (int i = 0; i < 5000; i++){\n\t\t\tfor (int j = 0; j < 5; j++){\n\t\t\t\tfield[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tint d, p, q;\n\t\t\tstd::cin >> d >> p >> q;\n\n\t\t\tq--;\n\n\t\t\tint height = 0;\n\n\t\t\tfor (int j = 4999; j >= 0; j--){\n\t\t\t\tif (d == 1){\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor (int k = 0; k < p; k++){\n\t\t\t\t\t\tif (field[j][q + k]) flg = false;\n\t\t\t\t\t}\n\t\t\t\t\tif (!flg){\n\t\t\t\t\t\theight = j + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tif (field[j][q]){\n\t\t\t\t\t\theight = j + 1;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tfor (int j = 0; j < p; j++){\n\t\t\t\tif (d == 1)field[height][q + j] = true;\n\t\t\t\telse field[height + j][q] = true;\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < 5000; i++){\n\t\t\t\tbool flg = true;\n\t\t\t\tfor (int j = 0; j < 5; j++){\n\t\t\t\t\tif (!field[i][j]){\n\t\t\t\t\t\tflg = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (flg){\n\t\t\t\t\terase(field, i);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < 5000; i++){\n\t\t\tfor (int j = 0; j < 5; j++){\n\t\t\t\tif (field[i][j] == 1)cnt++;\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << cnt << std::endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n\n#define\tpb\tpush_back\n\nusing namespace std;\n\ntypedef\tvector<int>\tvi;\n\nchar field[5000];\n\nbool vanish(int u,int l){\n\tvi rem;\n\tfor(int i=l;i>=u;i--){\n\t\tif(field[i]!=31)\trem.pb(i);\n\t}\n\n\tint rnum=rem.size(),h=l-u+1;\n\tif(rnum!=l){\n\t\tfor(int i=0;i<rnum;i++)\tfield[l-i]=field[rem[i]];\n\t\tfor(int i=u-1;i>=0;i--)\tfield[h-rnum+i]=field[i];\n\t\tfor(int i=0;i<rnum;i++)\tfield[i]=0;\n\t}\n}\n\nint main(){\n\tfor(int n;scanf(\"%d\",&n),n;){\n\t\tfor(int i=0;i<5000;i++)\tfield[i]=0;\n\t\tfor(int t=0;t<n;t++){\n\t\t\tint type,len,p;\tscanf(\"%d%d%d\",&type,&len,&p);\n\t\t\tp--;\n\n\t\t\tchar blk;\n\t\t\tif(type==1)\tblk=((1<<len)-1)<<(5-p-len);\n\t\t\telse\t\tblk=1<<(4-p);\n\n\t\t\tfor(int i=0;i<=5000;i++){\n\t\t\t\tif(i==5000 || (field[i]&blk)!=0){\n\t\t\t\t\tif(type==1){\n\t\t\t\t\t\tfield[i-1]|=blk;\n\t\t\t\t\t\tvanish(i-1,i-1);\n\t\t\t\t\t}\n\t\t\t\t\telse{\n\t\t\t\t\t\tfor(int j=1;j<=len;j++)\tfield[i-j]|=blk;\n\t\t\t\t\t\tvanish(i-len,i-1);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint cnt=0;\n\t\tfor(int i=0;i<5000;i++){\n\t\t\tfor(int j=0;j<5;j++)\tif(field[i]&(1<<j))\tcnt++;\n\t\t}\n\t\tprintf(\"%d\\n\",cnt);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdlib>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\nif(h_max<0) abort();\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\tflg &= board[h_max][j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tfor(int k = h_max; k < top[j]; k++) {\n\t\t\t\t\t\t\tboard[k][j] = board[k + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\n\t\t\t\tint h = top[q - 1];\n\t\t\t\ttop[q - 1] += p;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tflg &= board[h + j][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tboard[h + j - del][k] = board[h + j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdel++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tfor(int k = h + p - del; k < top[j] + 10; k++) {\n\t\t\t\t\t\tboard[k][j] = board[k + del][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tint tmp = top[j];\n\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\tfor(int k = tmp; k >= 0; k--) {\n\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\n\t\t\tfor(int j = 0; j < 6; j++) {\n\t\t\t\tans += board[i][j];\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 10; i >= 0; i--) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tcout << (board[i][j] ? '*' : '.');\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << endl;\n\t\t// */\n\t\t/*\n\t\tfor(int i = 0; i < 5; i++)\n\t\t\tcout << top[i] << \" \";\n\t\tcout << endl;\n\t\t// */\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nint main(){\n  int N;\n  while(cin >> N && N){\n    const int H = 5010;\n    const int W = 5;\n    bool block[H][W] = {};\n    int height[W] = {};\n    int n_h = 0;\n    REP(iter, N){\n      int d, l, bx;\n      cin >> d >> l >> bx;\n      bx --;\n      if(d == 1){\n        // yoko\n        int h = 0;\n        for(int x = bx; x < bx + l; x++) h = max(h, height[x]);\n        for(int x = bx; x < bx + l; x++) block[h][x] = true;\n        bool line = true;\n        for(int x = 0; x < W; x++) if(!block[h][x]) line = false;\n        if(line){\n          for(int x = 0; x < W; x++) block[h][x] = false;\n        }\n      }else if(d == 2){\n        // tate\n        for(int y = height[bx]; y < height[bx] + l; y++)\n          block[y][bx] = true;\n        for(int y = height[bx]; y < height[bx] + l; y++){\n          bool line = true;\n          for(int x = 0; x < W; x++) if(!block[y][x]) line = false;\n          if(!line) continue;\n          for(int x = 0; x < W; x++) block[y][x] = false;\n        }\n      }\n      //bool new_block[H][W] = {};\n      int new_height[W] = {};\n      int new_nh = 0;\n      int curr = 0;\n      /*\n      for(int y = n_h + 5; y >= 0; y--){\n        debug(block[y], block[y] + 5);\n      }\n      cout << endl;\n      */\n      for(int y = 0; y < n_h + 5; y++){\n        bool clear = true;\n        for(int x = 0; x < W; x++) if(block[y][x]) clear = false;\n        if(clear) continue;\n        for(int x = 0; x < W; x++)if(block[y][x]){\n          block[y][x] = false;\n          block[curr][x] = true;\n          new_height[x] = curr + 1;\n        }\n        new_nh = ++curr;\n      }\n      //memcpy(block, new_block, sizeof(block));\n      memcpy(height, new_height, sizeof(height));\n      n_h = new_nh;\n    }\n    int ans = 0;\n    REP(y, H)REP(x, W) ans += block[y][x];\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint o[5011][5];\n\nint yoko(int L,int R){\n\tfor(int i = 5010 ; i > 0 ; i--){\n\t\tint f = 0;\n\t\tfor(int j = L ; j <= R ; j++){\n\t\t\tif( o[i-1][j] ){\n\t\t\t\tf = 1;\n\t\t\t}\n\t\t}\n\t\tif( f ){\n\t\t\tfor(int k = L ; k <= R ; k++)\n\t\t\t\to[i][k] = 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tfor(int i = L ; i <= R ; i++)\n\t\to[0][i] = 1;\n}\nint tate(int x,int l){\n\tfor(int i = 5010 ; i > 0 ; i--){\n\t\tint f = o[i-1][x];\n\t\tif( f ){\n\t\t\tfor(int j = 0 ; j < l ; j++)\n\t\t\t\to[i+j][x] = 1;\n\t\t\treturn 0;\n\t\t}\n\t}\n\t\n\tfor(int i = 0 ; i < l ; i++) o[i][x] = 1;\n}\nint eraser(){\n\tvector<int> v[5];\n\tfor(int i = 0 ; i <= 5010 ; i++){\n\t\tif( o[i][0] && o[i][1] && o[i][2] && o[i][3] && o[i][4] ){\n\t\t\to[i][0] = o[i][1] = o[i][2] = o[i][3] = o[i][4] = 0;\n\t\t}\n\t\tif( o[i][0] || o[i][1] || o[i][2] || o[i][3] || o[i][4] ){\n\t\t\tfor(int j = 0 ; j < 5 ; j++)\n\t\t\t\tv[j].push_back(o[i][j]);\n\t\t}\n\t}\n\tfor(int i = 0 ; i < 5011 ; i++)\n\t\tfor(int j = 0 ; j < 5 ; j++)\n\t\t\to[i][j] = 0;\n\tfor(int i = 0 ; i < v[0].size() ; i++)\n\t\tfor(int j = 0 ; j < 5 ; j++){\n\t\t\to[i][j] = v[j][i];\n\t\t}\n\t\n}\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tfor(int i = 0 ; i < 5011 ; i++)\n\t\t\tfor(int j = 0 ; j < 5 ; j++)\n\t\t\t\to[i][j] = 0;\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tint d,l,x;\n\t\t\tcin >> d >> l >> x;\n\t\t\tx--;\n\t\t\tif( d == 1 ){\n\t\t\t\tyoko(x,x+l-1);\n\t\t\t}else{\n\t\t\t\ttate(x,l);\n\t\t\t}\n\t\t\teraser();\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int i = 0 ; i < 5011 ; i++)\n\t\t\tfor(int j = 0 ; j < 5 ; j++)\n\t\t\t\tans += o[i][j];\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// * template\n\n#include <bits/stdc++.h>\n#ifdef LOCAL\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\nusing namespace std;\n\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\n\ntemplate<class T, class U> inline void fill_array(T &e, const U &v) { e = v; }\ntemplate<class T, class U, size_t s> inline void fill_array(T (&a)[s], const U &v) {for(auto&e:a)fill_array(e,v);}\ntemplate<class T, class U, size_t s> inline void fill_array(array<T, s> &a, const U &v) {for(auto&e:a)fill_array(e,v);}\ntemplate<class T, class U> inline void fill_array(vector<T> &a, const U &v) {for(auto&e:a)fill_array(e,v);}\n\nstruct range {\n\ttypedef int Int;\n\tstruct iter {\n\t\tInt i;\n\t\tconst Int s;\n\t\tconstexpr iter(const Int &i_, const Int &s_):i(i_), s(s_) {}\n\t\tconstexpr bool operator!=(const iter &r) const { return s > 0 ? i < r.i : i > r.i; }\n\t\tconstexpr const Int &operator*() const { return i; }\n\t\titer &operator++() { i += s; return *this; }\n\t};\n\tconst Int f, l, s;\n\tconstexpr range(const Int &f_, const Int &l_, const Int &s_):f(f_), l(l_), s(s_) {}\n\tconstexpr range(const Int &f_, const Int &l_):f(f_), l(l_), s(1) {}\n\tconstexpr range(const Int &num):f(0), l(num), s(1) {}\n\tconstexpr iter begin() const { return iter(f, s); }\n\tconstexpr iter end() const { return iter(l, s); }\n};\n\n// * solve\n\nconstexpr int MAX_NUM_BLOCK = 1000;\nconstexpr int MAX_BLOCK_SIZE = 5;\nconstexpr int WIDTH = 5;\nconstexpr int HEIGHT = MAX_NUM_BLOCK * MAX_BLOCK_SIZE;\n\narray<array<bool, WIDTH>, HEIGHT> field;\n\nvoid drop_block() {\n\tstatic constexpr int dx[] = {0, 1, 0};\n\tstatic constexpr int dy[] = {0, 0, 1};\n\n\tint d, p, q;\n\tcin >> d >> p >> q;\n\n\tint x = q - 1;\n\tint y = 0;\n\tconst int w = (d == 1 ? p : 1);\n\n\tfor(int i : range(HEIGHT - 1, -1, -1)) {\n\t\tif(any_of(begin(field[i]) + x, begin(field[i]) + x + w, [](bool b) { return b; })) {\n\t\t\ty = i + 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdump(x, y, w);\n\n\tfor(int i : range(p)) {\n\t\tfield[y][x] = true;\n\n\t\tif(all_of(begin(field[y]), end(field[y]), [](bool b) { return b; })) {\n\t\t\tfield[y].fill(false);\n\t\t\trotate(begin(field) + y, begin(field) + y + 1, end(field));\n\t\t\t--y;\n\t\t}\n\n\t\tx += dx[d];\n\t\ty += dy[d];\n\t}\n\n\tdump(field[2]);\n\tdump(field[1]);\n\tdump(field[0]);\n}\n\nint calc_score() {\n\tint res = 0;\n\tfor(const auto &row : field) {\n\t\tres += count(begin(row), end(row), true);\n\t}\n\treturn res;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tfor(int n; cin >> n && n;) {\n\t\tfill_array(field, false);\n\n\t\tfor(int i : range(n)) {\n\t\t\tdrop_block();\n\t\t}\n\n\t\tcout << calc_score() << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nint t[5000][5];\n\nvoid disp(void){\n\tfor(int i=0;i<10;i++){\n\t\tfor(int j=0;j<5;j++){\n\t\t\tcout<<(int)t[5000-10+i][j];\n\t\t}\n\t\tcout<<endl;\n\t}\n\tcout<<\"---------------------\\n\";\n}\n\nbool stop(int ti,int tj,int d,int p){\n\tif(ti == 4999) return true;\n\n\tif(d == 1) REP(j,tj,tj+p){if(t[ti+1][j] == 1) return true;}\n\telse if(t[ti+1][tj]==1) return true;\n\n\treturn false;\n}\n\nvoid putBlock(int ti,int tj,int d,int p){\n\tif(d == 1) REP(j,tj,tj+p) t[ti][j] = 1;\n\telse for(int i=ti;i>ti-p;i--) t[i][tj] = 1;\n}\n\nvoid dropBlock(int ti){\n\tfor(int i=ti;i>0;i--){\n\t\tint sum = 0;\n\t\trep(j,5){\n\t\t\tif(t[i-1][j] == 1) sum++;\n\t\t\tt[i][j] = t[i-1][j];\n\t\t}\n\t\tif(sum == 0) return;\n\t}\n}\n\nvoid deleteLine(int from,int to){\n\tint repeat = from - to;\n\tint i = from;\n\trep(time,repeat){\n\t\tint sum = 0;\n\t\trep(j,5) if(t[i][j] == 1) sum++;\n\t\tif(sum == 5){\n\t\t\trep(j,5) t[i][j] = 0;\n\t\t\tdropBlock(i);\n\t\t}\n\t\telse{\n\t\t\ti--;\n\t\t}\n\t}\n}\n\nint main(void){\n\tint n;\n\twhile(cin>>n,n){\n\t\tmemset(t,0,sizeof(t));\n\t\trep(i,n){\n\t\t\tint d,p,q;\n\t\t\tcin>>d>>p>>q;\n\t\t\tq--;\n\t\t\tint row;\n\t\t\tfor(row=0;!stop(row,q,d,p);row++);\n\t\t\tputBlock(row,q,d,p);\n\t\t\t//disp();\n\t\t\tdeleteLine(row,d==1?row-1:row-p);\n\n\t\t\t//disp();\n\t\t}\n\n\t\tint ans = 0;\n\t\trep(i,5000) rep(j,5) if(t[i][j]==1) ans++;\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main() {\n\tint i,j,n,a,b,c,d,e,f,g,m[5050];\n\twhile(cin >> n) {\n\t\tif (n==0) break;\n\t\tfor (j=0;j<5050;j++) m[j]=0; d=1;\n\t\tfor (i=0;i<n;i++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tf=a >1 ? 1 << (c-1) : ((1 << b)-1)  << (c-1);  \n\t\t\tfor (j=d;j>=0;j--) if ( m[j]+f != (m[j] | f)) break;\n\t\t\te=g=j+1; \n\t\t\tif (a==1) { m[e]+=f; d++;}  else for (j=0;j<b;j++) { m[e+j]+=f; d++;}\n\t\t\tfor (j=g; j<d+5; j++) if (m[j]<31) m[e++]=m[j]; \n\t\t}\n\t\tf=0;\n\t\tfor (i=0;i<5050;i++) for (j=0;j<5;j++) f+=(m[i] & ( 1 << j))>0;\n\t\tcout << f << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  Sample1:\n  9\n  1 1 1\n  1 2 1\n  1 3 1\n  1 4 1\n  1 3 1\n  1 2 1\n  1 1 1\n  2 5 5\n  2 5 4\n  0\n  Output:\n  11\n\n  Sample2:\n  10\n  1 4 1\n  1 1 1\n  1 4 1\n  1 1 2\n  1 4 1\n  1 1 3\n  1 4 1\n  1 1 4\n  2 5 5\n  2 5 5\n  0\n  Output:\n  10\n\n  memorandum:\n  ブロックが消えた後に横に５つそろった場合それも消す（定番）　　　　 \n  横の列が消えた場合、消えた行の上のブロックはそのままの形で１行下にしずむ\n  ^^^^^\n  つっかかるまでひたすら落とさないように注意\n  入力が与えられるたびにこれらの処理をする\n  Sample Inputの３つめが６になるのはすべて落ちた後に消す処理をしたからではなくブロックが沈むは１行のみだったため\n*/\n\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cassert>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n \nusing namespace std;\ntypedef pair<int,int> ii;\nint field[5010][5];\nint top[5];\nint n,d,p,q;\nvector<ii> input;\n \nbool checkX(int y)\n{\n  rep(x,5)if(!field[y][x])return false;\n  return true;\n}\n \nvoid updateD(int x,int y)\n{\n  ii info = input[field[y][x]];\n  if(info.first == 1)\n    {//yoko\n      //while(true)//ここのwhileをもどせばつっかかるまで落ちる\n      //{\n      bool check = true;\n      rep(i,5)\n        {\n          if(field[y][x] != field[y][i])continue;\n          if(y-1 >= 0 && field[y-1][i] != 0)\n\t    {\n\t      check = false;\n\t      break;\n\t    }\n        }\n      if(!check)return;\n      int v = field[y][x];\n      rep(i,5)\n        {\n          if(v != field[y][i])continue;\n          assert(field[y-1][i] == 0);\n          field[y-1][i] = field[y][i];\n          field[y][i] = 0;\n        }\n      y = y-1;\n      if(y <= 0)return;\n      //}\n    }\n  else\n    {\n      int v = field[y][x];\n     \n      int bot = 0;\n      int py = y;\n      while(py-1 >= 0 && field[py-1][x] == 0)py--;\n      bot = y-py;\n \n      if(bot == 0)return;\n      bot = 1;//ここをbotのままにすればつっかかるまでおちる\n      while(v == field[y][x])\n\t{\n\t  assert(y-bot >= 0);\n\t  assert(field[y-bot][x] == 0);\n\t  field[y-bot][x] = field[y][x];\n\t  field[y][x] = 0;\n\t  y++;\n\t}\n     \n    }\n}\n \nint main()\n{\n  while(cin >> n,n)\n    {\n      input.clear();\n      input.resize(1010,ii(-1,-1));\n      rep(i,5010)rep(j,5)field[i][j] = 0;\n      rep(i,5)top[i] = 0;\n      REP(i,1,n+1)\n\t{\n\t  cin >> d >> p >> q;\n\t  if(d == 1 && p == 5)continue;\n\t  q--;\n\t  input[i] = ii(d,p);\n\t  int cyb,cyt;\n\t  if(d == 2)\n\t    {\n\t      cyb = top[q],cyt = top[q]+p;\n\t      REP(j,top[q],top[q]+p)field[j][q] = i;\n\t      top[q] += p;\n\t    }\n\t  else\n\t    {\n\t      int mexico = -inf;\n\t      REP(j,q,q+p)mexico = max(mexico,top[j]);\n\t      REP(j,q,q+p)field[mexico][j] = i;\n\t      cyb = cyt = mexico;\n\t      REP(j,q,q+p)top[j] = mexico+1;\n\t    }\n \n      bool update = true;\n      while(update)\n\t{\n\t  update = false;\n\t  vector<int> erasedY;\n\t  REP(y,cyb,cyt+1)\n\t    {\n\t      if(checkX(y))\n\t\t{\n\t\t  update = true;\n\t\t  erasedY.push_back(y);\n\t\t  rep(x,5)field[y][x] = 0;\n\t\t}\n\t    }\n \n\t  //down\n\t  if(!erasedY.empty())\n\t    {\n \n \n\t      int yt = 0;\n\t      rep(j,5)yt = max(yt,top[j]);\n\t      rep(j,erasedY.size())\n\t\t{\n\t\t  REP(y,erasedY[j],yt)\n\t\t    {\n\t\t      int pre = -1;\n\t\t      rep(x,5)\n\t\t\t{\n\t\t\t  if(field[y][x] == pre)continue;\n\t\t\t  if(field[y][x] == 0 || y-1 < 0)continue;\n \n\t\t\t  pre = field[y][x];\n\t\t\t  updateD(x,y);\n\t\t\t}\n\t\t    }\n\t\t}\n \n \n\t    }\n      \n\t  //update top\n\t  rep(j,5)\n\t    {\n\t      int y = top[j];\n\t      while(y >= 0 && field[y][j] == 0)y--;\n\t      top[j] = y+1;\n\t    }\n      \n\t}\n    }\n\n      int yt = 0;\n      rep(i,5)yt = max(yt,top[i]);\n      int ans = 0;\n      rep(y,yt)\n\trep(x,5)\n\tif(field[y][x] != 0)ans++;    \n      cout << ans << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\tflg &= board[h_max][j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tboard[h_max][j] = 0;\n\t\t\t\t\t\tfor(int k = h_max; k < top[j]; k++) {\n\t\t\t\t\t\t\tboard[k][j] = board[k + 1][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\t\tfor(int k = 5900; k >= 0; k--) {\n\t\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\n\t\t\t\tint h = top[q - 1];\n\t\t\t\ttop[q - 1] += p;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tflg &= board[h + j][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tboard[h + j - del][k] = board[h + j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdel++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tfor(int k = h + p - del; k < top[j] + 10; k++) {\n\t\t\t\t\t\tboard[k][j] = board[k + del][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\ttop[j] = 0;\n\t\t\t\t\tfor(int k = 5900; k >= 0; k--) {\n\t\t\t\t\t\tif(board[k][j]) {\n\t\t\t\t\t\t\ttop[j] = k + 1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 10; i >= 0; i--) {\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tcout << (board[i][j] ? '*' : '.');\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t// */\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\n\t\t\tfor(int j = 0; j < 6; j++) {\n\t\t\t\tans += board[i][j];\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\tfor(int i = 0; i < 5; i++)\n\t\t\tcout << top[i] << \" \";\n\t\tcout << endl;\n\t\t// */\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nchar s[5010][5];\n\n// 初期化 (y == 0 のところを番兵でブロックにしておく)\nvoid ini(){\n\tfor(int y=0 ; y < 5010 ; y++ ){\n\t\tfor(int x=0 ; x < 5 ; x++ ){\n\t\t\ts[y][x] = y? '.' : '#' ;\n\t\t}\n\t}\n}\n\nvoid debug(int ay){\n\tcout << \"[debug]\" << endl;\n\tfor(int y=ay ; y > 0 ; y-- ){\n\t\tfor(int x=0 ; x < 5 ; x++ ){\n\t\t\tcout << s[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// ブロックの初期位置を返す.\nvector<P> block(int d, int p, int q, int y){\n\tvector<P> v;\n\tif( d == 1 ){ // 横向きのブロック\n\t\tfor(int i=0 ; i < p ; i++ ){\n\t\t\tint mx = q + i;\n\t\t\tint my = y;\n\t\t\tv.push_back( P(mx,my) );\n\t\t}\n\t}else{ // 縦向きのブロック\n\t\tfor(int i=0 ; i < p ; i++ ){\n\t\t\tint mx = q;\n\t\t\tint my = y + i;\n\t\t\tv.push_back( P(mx,my) );\n\t\t}\n\t}\n\treturn v;\n}\n\n// ブロックを落とす, ay := ブロックの一番高い位置 + 10\nvoid fall(vector<P> v, int& ay){\n\t// flag := ブロックが1マス落下できるかどうか\n\tbool flag = true;\n\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\tint x = v[i].first;\n\t\tint y = v[i].second;\n\t\tif( s[y-1][x] == '#' ){\n\t\t\tflag = false;\n\t\t}\n\t}\n\t\n\tif( flag ){ // 1マス落下させるとき\n\t\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\t\tv[i].second--;\n\t\t}\n\t\tfall( v , ay );\n\t}else{ // ブロックの落下位置が決まる\n\t\tint my = v[0].second;\n\t\tfor(int i=0 ; i < v.size() ; i++ ){\n\t\t\tint x = v[i].first;\n\t\t\tint y = v[i].second;\n\t\t\ts[y][x] = '#';\n\t\t\tmy = max( my , y );\n\t\t}\n\t\tay = max( ay , my + 10);\n\t}\n}\n\n// 高さ y が揃ったかどうか\nbool is_line(int y){\n\treturn (s[y][0] == '#' && s[y][1] == '#' && s[y][2] == '#' && s[y][3] == '#' && s[y][4] == '#');\n}\n\n// 高さ l の列を消す.\nvoid remove(int l, int ay){\n\tfor(int y=l ; y < ay ; y++ ){\n\t\ts[y][0] = s[y+1][0];\n\t\ts[y][1] = s[y+1][1];\n\t\ts[y][2] = s[y+1][2];\n\t\ts[y][3] = s[y+1][3];\n\t\ts[y][4] = s[y+1][4];\n\t}\n}\n\n// 揃った列があるか調べて消す.\nvoid check(int ay){\n\tfor(int y=1 ; y < ay ; y++ ){\n\t\tif( is_line(y) ){\n\t\t\tremove(y,ay);\n\t\t\ty--;\n\t\t}\n\t}\n}\n\nint block_count(int ay){\n\tint ans = 0;\n\tfor(int y=1 ; y < ay ; y++ ){\n\t\tfor(int x=0 ; x < 5 ; x++ ){\n\t\t\tif( s[y][x] == '#' ) ans++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint n;\n\twhile( cin >> n , n ){\n\t\tini();\n\t\tint y=10;\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\t\t\tvector<P> v = block(d,p,q-1,y);\n\t\t\tfall(v,y);\n\t\t\tcheck(y);\n\t\t\t// debug(y);\n\t\t}\n\t\tint ans = block_count(y);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint A[5000][5];\nint x[5],y[5];\nmain()\n{\n\tint N;\n\twhile(cin>>N,N)\n\t{\n\t\tfor(int i=0;i<5000;i++)for(int j=0;j<5;j++)A[i][j]=0;\n\t\tfor(int i=0;i<N;i++)\n\t\t{\n\t\t\tint d,p,q;cin>>d>>p>>q;\n\t\t\tif(d==1)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<p;j++)\n\t\t\t\t{\n\t\t\t\t\tx[j]=4999;\n\t\t\t\t\ty[j]=q+j-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int j=0;j<p;j++)\n\t\t\t\t{\n\t\t\t\t\tx[j]=4999-j;\n\t\t\t\t\ty[j]=q-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(true)\n\t\t\t{\n\t\t\t\tfor(int j=0;j<p;j++)x[j]--;\n\t\t\t\tbool flag=false;\n\t\t\t\tfor(int j=0;j<p;j++)\n\t\t\t\t{\n\t\t\t\t\tif(x[j]<0||A[x[j]][y[j]])flag=true;\n\t\t\t\t}\n\t\t\t\tif(flag)break;\n\t\t\t}\n\t\t\tfor(int j=0;j<p;j++)A[++x[j]][y[j]]=1;\n\t\t\tfor(int j=0;j<p;j++)\n\t\t\t{\n\t\t\t\tint X=x[j];\n\t\t\t\tbool flag=true;\n\t\t\t\tfor(int k=0;k<5;k++)flag&=A[X][k];\n\t\t\t\tif(flag)\n\t\t\t\t{\n\t\t\t\t\tfor(int k=X+1;k<5000;k++)for(int l=0;l<5;l++)A[k-1][l]=A[k][l];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int i=0;i<5000;i++)for(int j=0;j<5;j++)ans+=A[i][j];\n\t\tcout<<ans<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n#define UI unsigned int\n\nstring getM(char mask){\n  string s;\n  for( int i=4;i>=0;i-- ){\n    if( mask & 1<<i ) s+=\"1\";\n    else s+=\"0\";\n  }\n  return s;\n}\nvoid pr(vector<char> v){\n  cout <<\" ***** \" << v.size() << endl;\n  for( int i=v.size()-1;i>=0;i-- )\n    cout << getM(v[i]) << endl;\n}\n\nint main(){\n  int n, d,p,q, index;\n  char ms[5], ful=0, mask;\n\n  for( int i=0;i<5;i++ )\n    ful += (ms[i]=1<<i);\n\n  while( cin>>n && n ){\n    vector<char> v;\n    for( int lp=0;lp<n;lp++ ){\n      //      cout << \"lp=\"<<lp<<endl;\n\n      cin >> d >> p >> q; // 向き・長さ・位置\n      q--;\n\n      if( d==1 ){ // 横向き\n\tmask=0;\n\tfor( int i=0;i<p;i++ )\t  mask |= ms[q+i];\n\n\tindex=v.size()-1;\n\tfor( ;index>=0;index-- )\n\t  if( v[index] & mask ) break;\n\tindex++;\n\tif( index>=(int)v.size() ) v.push_back(mask);\n\telse v[index] |= mask;\n      }else{ // 縦向き\n\tmask = ms[q];\n\tindex=v.size()-1;\n\tfor( ;index>=0;index-- )\n\t  if( v[index] & mask ) break;\n\tindex++;\n\tfor( int i=0;i<p;i++,index++ ){\n\t  if( index>=(int)v.size() )\n\t    v.push_back(mask);\n\t  else\n\t    v[index] |= mask;\n\t}\n      }\n      //      pr( v );\n\n      // 消去チェック\n      for( UI i=0;i<v.size();i++ ){\n\tif( v[i]==ful ){\n\t  v.erase( v.begin()+i );\n\t  i--;\n\t  //\t  cout << \"  ERASE\" << endl;\n\t  //\t  pr( v );\n\t}\n      }\n    }\n    int ans=0;\n    for( UI i=0;i<v.size();i++ ){\n      for( int j=0;j<5;j++ )if( v[i] & 1<<j ) ans++;\n    }\n    cout << ans << endl;\n\n    //    break;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint grid[5][5010];\nint n,d,p,q;\nll int ans = 0;\n\nint GetBottom(int x){\n\tREP(i,5010){\n\t\tif(grid[x][i]==-1) return i;\n\t}\n\treturn 0;\n}\n\nbool isallclear(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=-1) return false;\n\t}\n\treturn true;\n}\n\nbool isallblock(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(cin>>n,n){\n\t\tREP(i,5) REP(j,5010) grid[i][j] = -1;\n\t\tREP(i,n){\n\t\t\tcin >> d >> p >> q;\n\t\t\tif(d==2){\n\t\t\t\tint tmp = GetBottom(q-1);\n\t\t\t\tFOR(j,tmp,tmp+p) grid[q-1][j] = 1;\n\t\t\t}else{\n\t\t\t\tint tmp = -1;\n\t\t\t\tFOR(j,q-1,q-1+p){\n\t\t\t\t\ttmp = max(tmp,GetBottom(j));\n\t\t\t\t}\n\t\t\t\tFOR(j,q-1,q-1+p) {\n\t\t\t\t\tgrid[j][tmp] = 1;\n\t\t\t\t\tREP(k,tmp) if(grid[j][k]==-1) grid[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowline = 0;\n\t\t\twhile(1){\n\t\t\t\tif(isallclear(nowline)) break;\n\t\t\t\tif(isallblock(nowline)){\n\t\t\t\t\tREP(j,5) {\n\t\t\t\t\t\tint nline = nowline+1;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tif(grid[j][nline]==-1) {\n\t\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\tnline++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tnowline++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tint line = 0;\n\t\twhile(1){\n\t\t\tif(isallclear(line)) break;\n\t\t\tREP(i,5){\n\t\t\t\tif(grid[i][line]==1) ans++;\n\t\t\t}\n\t\t\tline++;\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int H = 6000;\nconst int W = 5;\nint G[H][W];\n\nint main() {\n  int n;\n  while(cin >> n && n) {\n    fill(G[0], G[H], 0);\n    while(n--) {\n      /*\n      for(int i = H-8; i < H; ++i) {\n        for(int j = 0; j < W; ++j) {\n          cout << G[i][j];\n        }\n        cout << endl;\n      }\n      cout << endl;\n      */\n      int d, p, q;\n      cin >> d >> p >> q;\n      --q;\n      vector<int> x;\n      if(d == 1) {\n        for(int j = 0; j < p; ++j) {\n          x.push_back(q+j);\n        }\n      } else {\n        x.push_back(q);\n      }\n      int y = H-1;\n      try {\n        for(int i = 0; i < H; ++i) {\n          for(int j = 0; j < x.size(); ++j) {\n            if(G[i][x[j]]) {\n              y = i-1;\n             throw 0;\n            }\n          }\n        }\n      } catch(...) {}\n      if(d == 1) {\n        for(int j = 0; j < x.size(); ++j) {\n          G[y][x[j]] = 1;\n        }\n      } else {\n        for(int j = 0; j < p; ++j) {\n          G[y-j][x[0]] = 1;\n        }\n      }\n      for(int i = H-1, y = H-1; i >= 0; --i, --y) {\n        bool allBlock = true;\n        for(int j = 0; j < W; ++j) {\n          if(!G[i][j]) {\n            allBlock = false;\n            break;\n          }\n        }\n        if(allBlock) {\n          ++y;\n        } else {\n          for(int j = 0; j < W; ++j) {\n            G[y][j] = G[i][j];\n            if(y != i) G[i][j] = 0;\n          }\n        }\n      }\n    }\n    int res = 0;\n    for(int i = 0; i < H; ++i) {\n      for(int j = 0; j < W; ++j) {\n        res += G[i][j];\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<map>\n#include<list>\n\nusing namespace std;\n\n#define int long long\n\nlist<bool*> fld;\n\nlist<bool*>::iterator GetHeight(int l, int r)\n{\n\tlist<bool*>::iterator itr = fld.begin();\n\tfor (; itr != fld.end(); itr++)\n\t{\n\t\tbool isAble = true;\n\t\tfor (int j = l; j < r; j++)\n\t\t{\n\t\t\tif ((*itr)[j] == true) isAble = false;\n\t\t}\n\t\tif (!isAble) return --itr;\n\t}\n\treturn --itr;\n}\n\nbool IsFull(list<bool*>::iterator itr)\n{\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif ((*itr)[i] == false) return false;\n\t}\n\treturn true;\n}\n\nbool IsEmpty(list<bool*>::iterator itr)\n{\n\tfor (int i = 0; i < 5; i++)\n\t{\n\t\tif ((*itr)[i] == true) return false;\n\t}\n\treturn true;\n}\n\nvoid Drop(int d, int p, int q)\n{\n\tif (!IsEmpty(fld.begin())) fld.push_front((bool*)new bool[5]{});\n\tint l = q - 1, r = (d == 1) ? l + p : l + 1;\n\tlist<bool*>::iterator itr = GetHeight(l, r);\n\n\tint h = (d == 1) ? 1 : p;\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tif (itr == fld.begin()) fld.push_front((bool*)new bool[5]{});\n\t\tfor (int j = l; j < r; j++)\n\t\t{\n\t\t\t(*itr)[j] = true;\n\t\t}\n\t\tif (IsFull(itr))\n\t\t{\n\t\t\tdelete *itr;\n\t\t\titr = fld.erase(itr);\n\t\t}\n\t\titr--;\n\t}\n}\n\nsigned main()\n{\n\tint N;\n\twhile (cin >> N, N)\n\t{\n\t\tfld.clear();\n\t\tfld.push_back((bool*)new bool[5]{});\n\t\tfor (int i = 0; i < N; i++)\n\t\t{\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\t\t\tDrop(d, p, q);\n\t\t}\n\t\tint ans = 0;\n\t\tfor (list<bool*>::iterator itr = fld.begin(); itr != fld.end(); itr++)\n\t\t{\n\t\t\tfor (int i = 0; i < 5; i++)\n\t\t\t{\n\t\t\t\tans += ((*itr)[i] == true);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "?1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677 #include <iostream> using namespace std;   int dir[5010];   void remove(){     int cnt = 0;     for(int i = 0 ; i < 5010 ; i++){         if( dir[i] == 31 ) dir[i] = 0,cnt++;     }     for(int k = 0 ; k <= cnt ; k++)     for(int i = 5009 ; i > 0 ; i--){         if( dir[i] && !dir[i-1] ){             swap(dir[i],dir[i-1]);         }     } }   void tate(int x,int l){     for(int i = 1 ; i <= l ; i++) dir[5010-i] |= (1<<x);           for(int _ = 0 ; _ < 10 ; _++)     for(int i = 5010-l+_ ; i > 0 ; i--){         if( (dir[i] >> x & 1) && (dir[i-1] >> x & 1) == 0 ){             dir[i] -= (1<<x);             dir[i-1] += (1<<x);         }else{             break;         }     }     remove(); }   void yoko(int x,int l){     int mask = ((1<<l)-1) << x;     dir[5009] = mask;     for(int i = 5009 ; i > 0 ; i--){         if( dir[i] && !(dir[i-1] & mask) ){             dir[i] -= mask;             dir[i-1] += mask;         }else{             break;         }     }     remove(); } int main(){     int n;     while(cin >> n && n){         for(int i = 0 ; i <= 5009 ; i++)             dir[i] = 0;                   for(int i = 0 ; i < n ; i++){             int d,l,x;             cin >> d >> l >> x;             x--;             if(d==1){                 yoko(x,l);             }else{                 tate(x,l);             }             int f = 0;             if( i == 10 ) continue;             for(    int j = 5009 ; j >= 0 ; j--){                 if(f||dir[j]){                     //cout << j << \" \" << (dir[j]&1) << (dir[j]&2) << (dir[j]&4) << (dir[j]&8) << (dir[j]&16) << endl; ;                     f=true;                 }             }         //  cout << endl;         }         int ans = 0;         for(int i = 0 ; i < 5010 ; i++)             ans += __builtin_popcount(dir[i]);         cout << ans << endl;     } } "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n  int n;\n  while (cin >> n) {\n    if (n == 0)\n      break;\n\n    vector<int> board(6000, 0);\n    board[0] = (1 << 5) - 1; // sentinel\n    while (n--) {\n      int d, p, q;\n      cin >> d >> p >> q;\n\n      --q;\n      for (int i = 6000-1; i > 0; --i) {\n\tif (d == 1) {\n\t  // hor\n\t  int block = 0;\n\t  for (int j = 0; j < p; ++j)\n\t    block |= (1 << (q+j));\n\t  \n\t  if (board[i-1] & block) {\n\t    board[i] |= block;\n\t    break;\n\t  }\n\t} else {\n\t  // ver\n\t  if (board[i-1] & (1 << q)) {\n\t    for (int j = 0; j < p; ++j)\n\t      board[i+j] |= (1 << q);\n\t    break;\n\t  }\n\t}\n      }\n    }\n\n    int ans = 0;\n    for (unsigned int i = 1; i < board.size(); ++i) {\n      int bit = __builtin_popcount(board[i]);\n      if (bit != 5)\n\tans += bit;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst double eps=1e-9;\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\nint N;\nint board[6005][6];//たて:1~5000,よこ:1~5;\nint mxcol[6];\n\nint setblock(int d,int p,int q)\n{\n  int setheight=0;\n  if(d==1)\n    {\n      for(int i=q;i<p+q;i++)\n\t{\n\t  setheight=max(setheight,mxcol[i]);\n\t}\n      //cout << setheight << endl;\n      for(int row=q;row<p+q;row++)\n\t{\n\t  board[setheight+1][row]=1;\n\t}\n      for(int i=q;i<p+q;i++) mxcol[i]=setheight+1;\n    }\n  else if(d==2)\n    {\n      setheight=mxcol[q];\n      for(int col=setheight;col<setheight+p;col++)\n\t{\n\t  board[col+1][q]=1;\n\t}\n      mxcol[q]=setheight+p;\n    }\n  return setheight+1;\n}\n\nvoid vanishcheck(int minheight,int p,vector<int> &vanishcol)\n{\n  bool vanish;\n  for(int col=minheight;col<minheight+p;col++)\n    {\n      vanish=true;\n      for(int row=1;row<=5;row++)\n\t{\n\t  if(board[col][row]==0) vanish=false;\n\t}\n      if(vanish)\n\t{\n\t  for(int row=1;row<=5;row++) board[col][row]=0;\n\t  vanishcol.push_back(col);\n\t}\n    }\n  return;\n}\n\nvoid aftervanish(vector<int> vanishcol)\n{\n  int mxrow=0;\n  for(int i=1;i<=5;i++)\n    {\n      mxrow=max(mxrow,mxcol[i]);\n    }\n  for(int i=0;i<int(vanishcol.size());i++)\n    {\n      for(int j=1;j<=5;j++) mxcol[j]--;\n      for(int row=vanishcol[i]-i;row<=mxrow;row++)\n\t{\n\t  for(int col=1;col<=5;col++)\n\t    {\n\t      swap(board[row][col],board[row+1][col]);\n\t    }\n\t}\n    }\n  for(int row=1;row<=5;row++)\n    {\n      for(int col=mxcol[row];col>=0;col--) \n\t{\n\t  if(board[col][row]==1 || col==0)\n\t    {\n\t      mxcol[row]=col;\n\t      break;\n\t    }\n\t}\n    }\n}\n\nint main(void)\n{\n  int minheight;\n  while(cin >> N && N)\n    {\n      int ans=0;\n      memset(board,0,sizeof(board));\n      memset(mxcol,0,sizeof(mxcol));\n      for(int i=0;i<N;i++)\n\t{\n\t  int d,p,q;\n\t  cin >> d >> p >> q;\n\t  minheight=setblock(d,p,q);\n\t  vector<int> vanishcol;\n\t  if(d==1)\n\t    {\n\t      vanishcheck(minheight,1,vanishcol);\n\t    }\n\t  else if(d==2)\n\t    {\n\t      vanishcheck(minheight,p,vanishcol);\n\t    }\n\t  if(int(vanishcol.size()!=0))\n\t    {\n\t      sort(vanishcol.begin(),vanishcol.end());\n\t      aftervanish(vanishcol);\n\t    }\n\t  /*\n\t  cout << \"NOWcol\" << endl;\n\t  for(int row=1;row<=5;row++)\n\t    {\n\t      cout << mxcol[row] << ' ';\n\t    }\n\t  cout << endl;\n\t  for(int col=10;col>=1;col--)\n\t    {\n\t      for(int row=1;row<=5;row++)\n\t\t{\n\t\t  cout << board[col][row];\n\t\t}\n\t      cout << endl;\n\t      }*/\n\t}\n      for(int i=1;i<=6000;i++)\n\t{\n\t  for(int j=1;j<=5;j++)\n\t    {\n\t      if(board[i][j]==1) ans++;\n\t    }\n\t}\n      cout << ans << endl;\n    }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n  int n;\n  while (cin >> n) {\n    if (n == 0)\n      break;\n\n    vector<int> board(6000, 0);\n    board[0] = (1 << 5) - 1; // sentinel\n    while (n--) {\n      int d, p, q;\n      cin >> d >> p >> q;\n\n      --q;\n      for (int i = 6000-1; i > 0; --i) {\n\tif (d == 1) {\n\t  // hor\n\t  int block = 0;\n\t  for (int j = 0; j < p; ++j)\n\t    block |= (1 << (q+j));\n\t  \n\t  if (board[i-1] & block) {\n\t    board[i] |= block;\n\t    break;\n\t  }\n\t} else {\n\t  // ver\n\t  if (board[i-1] & (1 << q)) {\n\t    for (int j = 0; j < p; ++j)\n\t      board[i+j] |= (1 << q);\n\t    break;\n\t  }\n\t}\n      }\n\n      int vanish = 0;\n      for (int i = 1; i < 6000; ++i) {\n\tif (board[i] == (1 << 5) -1) {\n\t  ++vanish;\n\t} else if (vanish > 0) {\n\t    board[i-vanish] = board[i];\n\t    board[i] = 0;\n\t}\n      }\n    }\n\n    int ans = 0;\n    for (unsigned int i = 1; i < board.size(); ++i)\n      ans += __builtin_popcount(board[i]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<30;\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    int height[5] = {}; // ツ各ツ療アツづ可堕カツ催敖つキツづゥツブツδ債ッツクツづ個暗ェツ氾板湘」ツづ個暗ェツ古つ湘」\n    bool ba[5][5010] = {};\n\n    while(n--) {\n      int d, p, q;\n      cin >> d >> p >> q;\n      q--;\n      if (d == 1) {\n        int ma = 0;\n        for (int i=q; i<p+q; ++i) {\n          ma = max(ma, height[i]);\n        }\n        for (int i=q; i<p+q; ++i) {\n          ba[i][ma] = 1;\n          height[i] = ma + 1;\n        }\n        bool f = 1;\n        REP(i,5)\n          if (!ba[i][ma])\n            f = 0;\n        if (f) {\n          REP(i,5) {\n            for (int j=ma+1; j<height[i]; ++j)\n              if (j>0)\n                ba[i][j-1] = ba[i][j];\n            ba[i][height[i]-1] = 0;\n            while(height[i] > 0 && !ba[i][height[i]-1])\n              height[i]--;\n          }\n        }\n      } else {\n        REP(i,p) {\n          ba[q][height[q]+i] = 1;\n        }\n        height[q] += p;\n        for (int k=height[q]-p; k<height[q]; ++k) {\n          bool f = 1;\n          REP(i,5)\n            if (!ba[i][k])\n              f = 0;\n          //    cout << k << \" \" << f << endl;\n          if (f) {\n            REP(i,5) {\n              for (int j=k+1; j<height[i]; ++j) {\n                if (j > 0)\n                  ba[i][j-1] = ba[i][j];\n              }\n              ba[i][height[i]-1] = 0;\n              while(height[i] > 0 && !ba[i][height[i]-1])\n                height[i]--;\n            }\n            // REP(i,10) {\n            //   REP(j,5) {\n            //     cout << ba[j][9-i];\n            //   }\n            //   cout << endl;\n            // }\n            // cout << endl;\n            k--;\n          }\n        }\n      }\n      // REP(i,10) {\n      //   REP(j,5) {\n      //     cout << ba[j][9-i];\n      //   }\n      //   cout << endl;\n      // }\n      // REP(i,5)\n      //   cout << height[i] << \" \";\n      // cout << endl << endl;;\n    }\n    int ans = 0;\n    REP(i,5)\n      REP(j,5010)\n        if (ba[i][j])\n          ans++;\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nchar stage[2][5001][5];\n\nvoid place(int *height, int col, int d, int len, int pos, int turn)\n{\n    if (len == 0) return;\n    if (d == 1){\n        int mh = *max_element(height + pos, height + pos + len);\n        for (int j = pos; j < pos + len; j++){\n            stage[turn][mh][j] = col;\n            height[j] = mh + 1;\n        }\n    }\n    else {\n        for (int j = 0; j < len; j++){\n            stage[turn][height[pos]++][pos] = col;\n        }\n    }\n    return;\n}\n\nint main()\n{\n    int n;\n    \n    while (scanf(\"%d\", &n) && n){\n        int height[5] = {0};\n        int d[1001] = {0}, len[1001] = {0}, pos[1001] = {0};\n        \n        memset(stage, 0, sizeof(stage));\n        \n        for (int i = 1; i <= n; i++){\n            scanf(\"%d %d %d\", d + i, len + i, pos + i); --pos[i];\n            place(height, i, d[i], len[i], pos[i], 0);\n        }\n        \n        int turn = 0;\n        for (int i = 0; i < n; i++){\n            int ht = *max_element(height, height + 5);\n            \n            for (int j = 0; j < ht; j++){\n                bool ok = true;\n                for (int k = 0; k < 5; k++){\n                    stage[1 - turn][j][k] = 0;\n                    if (!stage[turn][j][k]) ok = false;\n                }\n                if (ok){\n                    for (int k = 0; k < 5; k++){\n                        len[stage[turn][j][k]]--;\n                    }\n                }\n            }\n            \n            memset(height, 0, sizeof(height));\n            for (int j = 1; j <= n; j++){\n                place(height, j, d[j], len[j], pos[j], 1 - turn);\n            }\n            turn = 1 - turn;\n        }\n        \n        int ret = 0;\n        int h = *max_element(height, height + 5);\n        for (int i = 0; i < h; i++){\n            for (int j = 0; j < 5; j++){\n                ret += !!stage[turn][i][j];\n            }\n        }\n        \n        printf(\"%d\\n\", ret);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define F first\n#define S second\n#define INF 1 << 30\n#define UNDER 1000\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint t[UNDER+1][5], n;\n\nint count(){\n  int res = 0;\n  rep(i, UNDER) rep(j, 5) if(t[i][j] == 1) res++;\n  return res;\n}\n\nvoid deleteblock(){\n  for(int y = UNDER-1; y >= 0; y--){\n    int f = 0;\n    rep(i, 5) if(t[y][i] == 0){ f = 1; break;}\n    if(f) continue;\n    rep(i, 5){\n      for(int c = y; c > 0; c--){\n\tt[c][i] = t[c-1][i];\n      }\n    }\n    t[0][0] = t[0][1] = t[0][2] = t[0][3] = t[0][4] = 0;\n    y++;\n  }\n  return;\n}\n\nint main(){\n  while(scanf(\"%d\", &n) && n){\n    int d, p, q;\n    memset(t, 0, sizeof(t));\n    rep(i, 5) t[1000][i] = 1;\n\n    rep(i, n){\n      scanf(\"%d%d%d\", &d, &p, &q); q--;\n      if(d == 1){\n\trep(y, UNDER+1){\n\t  int f = 0;\n\t  REP(x, q, q+p) if(t[y][x] == 1) f = 1;\n\t  if(!f) continue;\n\t  REP(x, q, q+p) t[y-1][x] = 1;\n\t  break;\n\t}\n      }else{\n\trep(y, UNDER+1){\n\t  if(!t[y][q]) continue;\n\t  for(int c = y-1; c > y-p-1; c--) t[c][q] = 1;\n\t  break;\n\t}\n      }\n      deleteblock();\n      /*      REP(i, 990, UNDER+1){\n\trep(j, 5) printf(\"%d \", t[i][j]); puts(\"\");\n\t}*/\n    }\n\n    printf(\"%d\\n\", count());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint  hei;\nchar fld[5002];\n\nvoid typeW(int s, int l)\n{\n\tint line = 0;\n\tfor(int x=s; x<s+l; x++)\n\t{\n\t\tline |= (1<<x);\n\t}\n\n\tfor(int y=hei; y>=0; y--)\n\t{\n\t\tif(fld[y]&line)\n\t\t{\n\t\t\tfld [y+1] |= line;\n\t\t\thei = (y+1>hei?y+1:hei);\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid typeH(int s, int l)\n{\n\tint line = (1<<s);\n\tfor(int y=hei; y>=0; y--)\n\t{\n\t\tif(fld[y]&line)\n\t\t{\n\t\t\tfor(int y2=0; y2<l; y2++)\n\t\t\t{\n\t\t\t\tfld [y+y2+1] |= line;\n\t\t\t\thei = (y+y2+1>hei?y+y2+1:hei);\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\nvoid eraseline()\n{\n\tfor(int y=1; y<=hei; )\n\t{\n\t\tif(fld[y] == 31)\n\t\t{\n\t\t\thei--;\n\t\t\tfor(int y2=y; y2<=hei+1; y2++)\n\t\t\t{\n\t\t\t\tfld[y2] = fld[y2+1];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\ty++;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n,d,p,q,c;\n\twhile(cin >> n, n)\n\t{\n\t\thei = 0;\n\t\tfld[0] = 31;\n\t\tfor(int y=1; y<5002; y++)\n\t\t{\n\t\t\tfld[y] = 0;\n\t\t}\n\n\t\twhile(n--)\n\t\t{\n\t\t\tcin >> d >> p >> q;\t\t\n\t\t\tif(d==1) typeW(q-1,p);\n\t\t\tif(d==2) typeH(q-1,p);\n\t\t\teraseline();\n\t\t}\n\t\n\t\tc=0;\n\t\tfor(int y=1; y<=hei; y++)\n\t\tfor(int x=0; x<5;    x++)\n\t\t{\n\t\t\tif(fld[y]&(1<<x)) c++;\n\t\t}\n\n\t\tcout << c << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n \nusing namespace std;\n \nconst int Height = 5010;\nconst int Width = 5;\nchar field[Height][Width];\nint top,ans;\nint dx[] = {1,0};\nint dy[] = {0,-1};\n \nvoid print(int h, int w){\n \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl; \n}\n \nint getH(int d, int len, int pos){\n  for(int i = top+6; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?') return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n}\n\nvoid down(int n){\n \n  for(int i = n; i <= top+6; i++)\n    for(int j = 0; j < Width; j++) field[i][j] = field[i+1][j];\n  // top--;\n}\n\nvoid erase(){\n\n  for(int i = 0; i <= top+6; i++){\n    bool f = true;\n    for(int j = 0; j < Width; j++) if(field[i][j] == '?') f = false;\n    if(f){\n      ans -= 5;\n      down(i--);\n    }\n  }\n}\n \nvoid put(int d, int len, int pos){\n \n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n \n  int h = nex;\n  int w = pos;\n \n  for(int i = 0; i < len; i++){\n    field[h][w] = '.';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n \nint main(){\n \n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    ans = top = 0;\n    \n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      ans += len;\n      put(d-1,len,pos-1);\n      erase();\n    }\n    cout << ans << endl;\n    // print(10,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint x[5000][5], m[5], maxn, sum;\nint n;\nint a, b, c;\nint main() {\n\twhile (true) {\n\t\tsum = 0;\n\t\tmemset(x, 0, sizeof(x));\n\t\tmemset(m, 0, sizeof(m));\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int h = 0; h < n; h++) {\n\t\t\tcin >> a >> b >> c;\n\t\t\tc--;\n\t\t\tif (a == 1) {\n\t\t\t\tmaxn = 0;\n\t\t\t\tfor (int j = c; j < c + b; j++) {\n\t\t\t\t\tmaxn = max(maxn, m[j]);\n\t\t\t\t}\n\t\t\t\tfor (int j = c; j < c + b; j++) {\n\t\t\t\t\tx[maxn][j] = 1;\n\t\t\t\t\tm[j] = maxn + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfor (int j = 0; j < b; j++) {\n\t\t\t\t\tx[m[c] + j][c] = 1;\n\t\t\t\t}\n\t\t\t\tm[c] += b;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 5000; i++) {\n\t\t\t\tif (x[i][0] + x[i][1] + x[i][2] + x[i][3] + x[i][4] == 5) {\n\t\t\t\t\tx[i][0] = 0; x[i][1] = 0; x[i][2] = 0; x[i][3] = 0; x[i][4] = 0;\n\t\t\t\t\tfor (int j = i; j < 4999; j++) {\n\t\t\t\t\t\tfor (int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tx[j][k] = x[j + 1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx[4999][0] = 0; x[4999][1] = 0; x[4999][2] = 0; x[4999][3] = 0; x[4999][4] = 0;\n\t\t\t\t\ti--;\n\t\t\t\t\tm[0]--; m[1]--; m[2]--; m[3]--; m[4]--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 5000; i++) {\n\t\t\tfor (int j = 0; j < 5; j++) {\n\t\t\t\tsum += x[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define MAX_N 1000000\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstatic const double eps = 1e-8;\n\nint gStage[6000][5];\n\nvoid putBlock(int dir,int len,int pos){\n\tif(dir == 1){\n\t\tfor(int i=6000-1;i>=0;i--){\n\t\t\tbool isok=true;\n\t\t\tfor(int j=pos;j<pos+len;j++){\n\t\t\t\tif(gStage[i][j]==1) isok=false;\n\t\t\t}\n\t\t\t\n\t\t\tif(!isok){\n\t\t\t\tfor(int j=pos;j<pos+len;j++){\n\t\t\t\t\tgStage[i+1][j] = 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\telse if(isok && i==0){\n\t\t\t\tfor(int j=pos;j<pos+len;j++){\n\t\t\t\t\tgStage[i][j] = 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n\telse{\n\t\tfor(int i=6000-1;i>=0;i--){\n\t\t\tbool isok=true;\n\t\t\tif(gStage[i][pos]==1) isok=false;\n\n\t\t\tif(!isok){\n\t\t\t\tfor(int j=i+1;j<i+1+len;j++){\n\t\t\t\t\tgStage[j][pos] = 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\telse if(isok && i==0){\n\t\t\t\tfor(int j=i;j<i+len;j++){\n\t\t\t\t\tgStage[j][pos] = 1;\n\t\t\t\t}\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint countBlock(){\n\tint res=0;\n\tfor(int i=0;i<6000;i++){\n\t\tfor(int j=0;j<5;j++){\n\t\t\tres += gStage[i][j];\n\t\t}\n\t}\n\n\treturn res;\n}\n\nvoid eraseBlock(){\n\tfor(int i=0;i<6000;i++){\n\t\tbool isok=true;\n\t\tfor(int j=0;j<5;j++){\n\t\t\tif(gStage[i][j]==0) isok = false;\n\t\t}\n\n\t\tif(isok){\n\t\t\tfor(int j=i;j+1<6000;j++){\n\t\t\t\tfor(int k=0;k<5;k++){\n\t\t\t\t\tgStage[j][k] = gStage[j+1][k];\n\t\t\t\t}\n\t\t\t}\n\t\t\ti--;\n\t\t}\n\t}\n}\n\nvoid printBlock(){\n\tfor(int i=0;i<50;i++){\n\t\tfor(int j=0;j<5;j++){\n\t\t\tprintf(\"%d\",gStage[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n}\n\nint main(){\n\tint n;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\n\t\tmemset(gStage,0,sizeof(gStage));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tint dir,len,pos;\n\t\t\tscanf(\"%d %d %d\",&dir,&len,&pos);\n\t\t\tpos-=1;\n\t\t\tputBlock(dir,len,pos);\n\t\t\t//printBlock();\n\t\t\teraseBlock();\n\t\t\t//printBlock();\n\t\t}\n\n\t\tprintf(\"%d\\n\",countBlock());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <cstring>\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n  list<char *>::iterator itr, bef;\n  list<char *> space;\n  int n, b, p, q;\n  while (true) {\n    space.push_back(new char[5]);\n    itr = space.begin();\n    memset(*itr, 0, sizeof(char)*5);\n    cin >> n;\n    if (n == 0)\n      break;\n    for (int i = 0; i < n; i++) {\n      cin >> b >> p >> q;\n      itr = space.begin();\n      q--;\n      if (b == 1) {//yoko                                                                                                                                                                                                                                                                                                                           \n        while (true) {\n          bool avail = true;\n          for (int j = 0; j < p; j++)\n            if((*itr)[q+j])\n              avail = false;\n          if (avail) {\n            bef = itr;\n            itr++;\n            if (itr == space.end()) {\n              for (int j = 0; j < p; j++)\n                (*bef)[q+j] = 1;\n              break;\n            }\n          } else if (!avail && itr == space.begin()) {\n            space.push_front(new char[5]);\n            bef = space.begin();\n            memset(*bef, 0, sizeof(char)*5);\n          } else {\n            for (int j = 0; j < p; j++)\n              (*bef)[q+j] = 1;\n            break;\n          }\n        }\n      } else {//tate                                                                                                                                                                                                                                                                                                                                \n        bef = itr;\n        while (!(*itr)[q] && itr != space.end())\n          itr++;\n        list<char *>::iterator tmp = itr;\n        while (p > 0) {\n          if (itr == space.begin())\n            break;\n          itr--;\n          p--;\n          (*itr)[q] = 1;\n        }\n        for (int j = 0; j < p; j++) {\n          space.push_front(new char[5]);\n          bef = space.begin();\n          memset(*bef, 0, sizeof(char)*5);\n          (*bef)[q] = 1;\n        }\n        itr = tmp;\n      }\n      while (bef != itr) {\n        if ((*bef)[0] && (*bef)[1] && (*bef)[2] &&\n            (*bef)[3] && (*bef)[4]) {\n          list<char *>::iterator tmp = bef;\n          tmp++;\n          space.erase(bef);\n          bef = tmp;\n        } else {\n          bef++;\n        }\n      }\n    }\n    int result = 0;\n    for (list<char *>::iterator prt = space.begin();\n         prt != space.end(); prt++) {\n      for (int j = 0; j < 5; j++) {\n        //cout << (int)(*prt)[j];                                                                                                                                                                                                                                                                                                                   \n        if ((*prt)[j])\n          result++;\n      }\n      /*if (prt == bef)                                                                                                                                                                                                                                                                                                                             \n        cout << \"<-bef\";                                                                                                                                                                                                                                                                                                                            \n      else if (prt == itr)                                                                                                                                                                                                                                                                                                                          \n        cout << \"<-itr\";                                                                                                                                                                                                                                                                                                                            \n        cout << endl;*/\n    }\n    cout << result << endl;\n    space.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <complex>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <math.h>\n#include <numeric>\n#include <list>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <climits>\n#include <set>\n#include <memory.h>\n#include <memory>\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cassert>\n#include <map>\n#include <cassert>\n#include <time.h>\n#include <ctime>\n\nusing namespace std;\n\ntypedef complex<double> xy_t;\ntypedef pair<xy_t, xy_t> line;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int , P> PP;\ntypedef pair<int, string> Ps;\ntypedef vector<int> vec;\ntypedef vector<vec> mat;\nconst int INF = 1 << 30;\nconst double EPS = 1e-9;\nconst double PI = 3.1415926535897932384626433832795;\nconst int CLK = CLOCKS_PER_SEC;\n\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\n\nbool field[5005][5];\n\nint block(int d, int p, int q){\n\tint x, y;\n\tif(d == 1) { x = p; y = 1;}\n\telse {y = p; x = 1;}\n\tfor(int i = 5000; i >= 1; i--){\n\t\tbool f = false;\n\t\trep(j, x){\n\t\t\tif(field[i-1][q+j]) f = true;\n\t\t}\n\t\tif(f){\n\t\t\trep(j, y){\n\t\t\t\trep(k, x){\n\t\t\t\t\tfield[i+j][q+k] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn i;\n\t\t}\n\t}\n\trep(i, y)rep(j, x) field[i][q+j] = true;\n\treturn 0;\n}\n\nvoid mov(int pos){\n\trep(i, 5) field[pos][i] = false;\n\trep2(i, pos, 5000)rep(j, 5) swap(field[i+1][j], field[i][j]);\n}\n\nvoid update(int pos){\n\tint cnt = 0;\n\tfor(int i = 4; i >= 0; i--){\n\t\tbool f = true;\n\t\trep(j, 5){\n\t\t\tif(!field[pos+i][j]) f = false;\n\t\t}\n\t\tif(f) mov(pos + i);\n\t}\n}\n\nvoid drop(){\n\tint d, p, q;\n\tcin >> d >> p >> q;\n\tint pos = block(d, p, --q);\n\tupdate(pos);\n}\n\nint cnt(){\n\tint res = 0;\n\trep(i, 5000)rep(j, 5) if(field[i][j]) res++;\n\treturn res;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n){\n\t\tmemset(field, false, sizeof(field));\n\t\trep(i, n){\n\t\t\tdrop();\n\t//\t\tcout << i << \" \" << cnt() << endl;\n\t\t}\n\t\tcout << cnt() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n\nusing namespace std;\n\nconst int Height = 5010;\nconst int Width = 5;\nchar field[Height][Width];\nint top;\nint dx[] = {1,0};\nint dy[] = {0,-1};\n\n\nvoid print(int h, int w){\n\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl;\n    \n}\nbool isInside(int h, int w){return 0<=h&&h<Height&&0<=w&&w<Width;}\n\nint getH(int d, int len, int pos){\n  for(int i = top+6; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?' || !isInside(h,w)) return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n}\n\nvoid put(int d, int len, int pos){\n\n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n\n  int h = nex;\n  int w = pos;\n\n  for(int i = 0; i < len; i++){\n    field[h][w] = '1';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n\nvoid count(){\n\n\n  int sum = 0;\n  \n  for(int i = 0; i < Height; i++){\n    int tmp = 0;\n    for(int j = 0; j < Width; j++){\n      if(field[i][j] != '?') tmp++;\n    }\n    if(tmp != 5) sum += tmp;\n  }\n  cout << sum << endl;\n}\n\nint main(){\n\n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    top = 0;\n\n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      put(d-1,len,pos-1);\n    }\n    count();\n    // print(10,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint dat[5000][5];\nint m[5];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<5000;i++)\n\t\t\tfor(int j=0;j<5;j++)dat[i][j]=0;\n\t\tfor(int i=0;i<5;i++)m[i]=0;\n\t\tint count=0;\n\t\tfor(int p=0;p<a;p++){\n\t\t\tint b,c,d;\n\t\t\tscanf(\"%d%d%d\",&b,&c,&d);d--;\n\t\t\tcount+=c;\n\t\t\tif(b==2){\n\t\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\t\tdat[m[d]][d]=1;\n\t\t\t\t\tbool ok=true;\n\t\t\t\t\tfor(int j=0;j<5;j++)if(!dat[m[d]][j])ok=false;\n\t\t\t\t\tif(ok){\n\t\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\t\tdat[m[d]][j]=0;\n\t\t\t\t\t\t\tfor(int k=m[d];k<4999;k++)dat[k][j]=dat[k+1][j];\n\t\t\t\t\t\t\tfor(int k=4999;k>=0;k--){\n\t\t\t\t\t\t\t\tif(dat[k][j]){\n\t\t\t\t\t\t\t\t\tm[j]=k+1;break;}\n\t\t\t\t\t\t\t\tif(k==0)m[j]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount-=5;\n\t\t\t\t\t}else m[d]++;\n\t\t\t\t//\tm[d]++;\n\t\t\t\t}\n\t\t\t\t//m[d]+=c;\n\t\t\t}else{\n\t\t\t\tint h=0;\n\t\t\t\tfor(int i=0;i<c;i++)h=max(h,m[i+d]);\n\t\t\t\tfor(int i=0;i<c;i++)dat[h][i+d]=1;\n\t\t\t\tfor(int i=0;i<c;i++)m[i+d]=h+1;\n\t\t\t\tbool ok=true;\n\t\t\t\tfor(int j=0;j<5;j++)if(!dat[h][j])ok=false;\n\t\t\t\tif(ok){\n\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\tdat[h][j]=0;\n\t\t\t\t\t\tfor(int k=h;k<4999;k++)dat[k][j]=dat[k+1][j];\n\t\t\t\t\t\tfor(int k=4999;k>=0;k--){\n\t\t\t\t\t\t\tif(dat[k][j]){m[j]=k+1;break;}\n\t\t\t\t\t\t\tif(k==0)m[j]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcount-=5;\n\t\t\t\t}\n\t\t\t}\n\t//\t\tfor(int i=6;i>=0;i--,printf(\"\\n\"))for(int j=0;j<5;j++)printf(\"%d\",dat[i][j]);\n\t//\t\tprintf(\"\\n\");\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <iostream>\n#include <string>\n#include <queue>\n#define MAX 5000\nusing namespace std;\n\nint main(void){\n\tint i,j,k,n,ans;\n\tbool f[5][MAX];\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tfor(i=0;i<5;i++){\n\t\t\tfor(j=0;j<MAX;j++) f[i][j] = false;\n\t\t}\n\t\tans = 0;\n\t\tfor(i=0;i<n;i++){\n\t\t\tint d,p,q;\n\t\t\tcin >> d >> p >> q;\n\t\t\tq--;\n\t\t\tans += p;\n\t\t\tif(d == 2){\n\t\t\t\tfor(j=MAX-1;j>=0;j--){\n\t\t\t\t\tif(j == 0 || f[q][j-1] == true){\n\t\t\t\t\t\tfor(k=j;k<j+p;k++) f[q][k] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(j=MAX-1;j>=0;j--){\n\t\t\t\t\tk=5;\n\t\t\t\t\tif(j != 0){\n\t\t\t\t\t\tfor(k=q;k<q+p;k++) if(f[k][j-1] == true) break;\n\t\t\t\t\t}\n\t\t\t\t\tif(j == 0 || k != q+p){\n\t\t\t\t\t\tfor(k=q;k<q+p;k++) f[k][j] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(j=0;j<MAX;j++){\n\t\t\t\tfor(k=0;k<5;k++) if(f[k][j] == false) break;\n\t\t\t\tif(k == 5){\n\t\t\t\t\tans -= 5;\n\t\t\t\t\tfor(k=0;k<5;k++){\n\t\t\t\t\t\tfor(int t=j;t<MAX-1;t++) f[k][t] = f[k][t+1];\n\t\t\t\t\t\tf[k][MAX-1] = false;\n\t\t\t\t\t}\n\t\t\t\t\tj--;\n\t\t\t\t}\n\t\t\t}\n\t\t//\t\t\tcout << endl;\n\t\t//\t\tfor(int ii=7;ii>=0;ii--){\n\t\t//\tfor(j=0;j<5;j++) cout << f[j][ii] << \" \";\n\t\t//\tcout << endl;\n\t\t//}\n\t\t//cout << endl;\n\t\t}\n\t\tcout << ans << endl;\n\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define N 10020\nusing namespace std;\nint main(){\n  while(true){\n    int n;\n    int ans=0;\n    scanf(\"%d\",&n);\n\n    if(n==0)break;\n    int row[N]={0,};\n    int h[5]={0,};\n    short M[5][N]={{0,},};\n    \n    for(int i = 0; i < n; ++i){\n      int mh = 0;\n      int d,p,q;\n      scanf(\"%d%d%d\", &d, &p, &q);\n      --q;\n      \n      if(d==1){\n\tint maxh = 0;\n\tfor(int j = q; j < q + p; ++j){\n\t  maxh = max( maxh, h[j] );\n\t}\n\tfor(int j = q; j < q + p; ++j){\n\t  h[j]=maxh+1;\n\t  M[j][maxh]=1;\n\t}\n\trow[maxh]+=p;\n      }else{\n\tfor(int j = h[q]; j < p + h[q]; ++j){\n\t  ++row[ j ];\n\t  M[q][j]=1;\n\t}\n\th[q]+=p;\n      }\n\n      for(int j = 0; j < 5; ++j){\n\tmh = max( mh , h[j] );\n      }\n      /*\n      cout << \" STACKED : \" << endl;\n      for(int j = mh; j >= 0; --j){\n\tfor(int k = 0; k < 5; ++k){\n\t  cout << M[k][j];\n\t}\n\tcout << endl;\n      }\n      cout << endl;\n      */\n      for(int j = 0; j < mh+1; ++j){\n\tif( row[j] == 5 ){\n\t  for(int k = j; k < mh+2; ++k){\n\t    row[k] = row[k+1];\n\t    for(int l = 0; l < 5; ++l){\n\t      M[l][k] = M[l][k+1];\n\t    }\n\t  }\n\t  j = -1;\n\t}\n      }\n      /*\n      cout << \" ERASED : \" << endl;\n      for(int j = mh; j >= 0; --j){\n\tfor(int k = 0; k < 5; ++k){\n\t  cout << M[k][j];\n\t}\n\tcout << endl;\n      }\n      cout << endl;\n      */\n      for(int j = 0; j < 5; ++j){\n\th[j] = 0;\n      }\n      for(int j = 0; j < 5; ++j){\n\tfor(int k = 0; k < mh+3; ++k){\n\t  if( M[j][k] == 1 ){\n\t    h[j] = k+1;\n\t  }\n\t}\n      }\n      /*\n      cout << \" HEIGHTS : \" << endl;\n      for(int j = 0; j < 5; ++j){\n\tcout << ' ' << h[j] << endl;\n      }\n      */\n    }\n    for(int i = 0; i < 5; ++i){\n      for(int j = 0; j < N; ++j){\n\tif( M[i][j] )\n\t  ans++;\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nvoid solve()\n{\n\tbool isUsed[5002][5];\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tfor (int i = 1; i < 5002; ++i)\n\t\t{\n\t\t\tfor (int j = 0; j < 5; ++j)\n\t\t\t{\n\t\t\t\tisUsed[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 5; ++i)\n\t\t{\n\t\t\tisUsed[0][i] = true;\n\t\t}\n\t\tint highest = 1;\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\t\t\t--q;\n\t\t\tint level = 0;\n\t\t\tif (d == 1)\n\t\t\t{\n\t\t\t\tbool isOK = true;\n\t\t\t\twhile (isOK)\n\t\t\t\t{\n\t\t\t\t\tfor (int j = 0; j < p; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (isUsed[highest - level][q + j])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tisOK = false;\n\t\t\t\t\t\t\t--level;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t++level;\n\t\t\t\t}\n\t\t\t\t--level;\n\t\t\t\tfor (int j = 0; j < p; ++j)\n\t\t\t\t{\n\t\t\t\t\tisUsed[highest - level][q + j] = true;\n\t\t\t\t}\n\t\t\t\thighest = max(highest, highest - level + 2);\n\t\t\t}\n\t\t\telse if (d == 2)\n\t\t\t{\n\t\t\t\twhile (!isUsed[highest - level][q])\n\t\t\t\t{\n\t\t\t\t\t++level;\n\t\t\t\t}\n\t\t\t\t--level;\n\t\t\t\tfor (int j = 0; j < p; ++j)\n\t\t\t\t{\n\t\t\t\t\tisUsed[highest - level + j][q] = true;\n\t\t\t\t}\n\t\t\t\thighest = max(highest, highest - level + p + 1);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor (int i = 1; i < highest; ++i)\n\t\t{\n\t\t\tint rowCount = 0;\n\t\t\tfor (int j = 0; j < 5; ++j)\n\t\t\t{\n\t\t\t\tif (isUsed[i][j])\n\t\t\t\t{\n\t\t\t\t\t++ans;\n\t\t\t\t\t++rowCount;\n\t\t\t\t}\n\t\t\t\tif (rowCount == 5)\n\t\t\t\t{\n\t\t\t\t\tans -= 5;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nint board[6000][6];\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint top[8];\n\n\t\tfor(int i = 0; i < 6000; i++)\n\t\t\tfor(int j = 0; j < 6; j++)\n\t\t\t\tboard[i][j] = 0;\n\t\tfor(int i = 0; i < 8; i++)\n\t\t\ttop[i] = 0;\n\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tint d, p, q;\n\t\t\tcin >> d >> p >> q;\n\n\t\t\tif(d == 1) {\n\t\t\t\tint h_max = -1;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\th_max = max(top[q - 1 + j], h_max);\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[h_max][q - 1 + j] = 1;\n\t\t\t\t\ttop[q - 1 + j] = h_max + 1;\n\t\t\t\t}\n\n\t\t\t\tbool flg = true;\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\tflg &= board[h_max][j];\n\t\t\t\tif(flg) {\n\t\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\t\tboard[h_max][j] = 0;\n\t\t\t\t\t\tfor(int k = h_max + 1; k < top[j] + 10; k++) {\n\t\t\t\t\t\t\tboard[k - 1][j] = board[k][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse {\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tboard[top[q - 1] + j][q - 1] = 1;\n\t\t\t\t}\n\n\t\t\t\tint h = top[q - 1];\n\t\t\t\ttop[q - 1] += p;\n\t\t\t\tint del = 0;\n\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\tbool flg = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tflg &= board[h + j][k];\n\t\t\t\t\t}\n\t\t\t\t\tif(flg) {\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++)\n\t\t\t\t\t\t\tboard[h + j - del][k] = board[h + j + 1][k];\n\t\t\t\t\t\tdel++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tfor(int k = h + p - del; k < top[j]; k++) {\n\t\t\t\t\t\tboard[k][j] = board[k + del][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j = 0; j < 5; j++)\n\t\t\t\t\ttop[j] -= del;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(int i = 10; i >= 0; i--) {\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tcout << (board[i][j] ? '*' : '.');\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\t// */\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 6000; i++) {\n\t\t\tfor(int j = 0; j < 6; j++) {\n\t\t\t\tans += board[i][j];\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n \nusing namespace std;\n \nconst int Height = 5500;\nconst int Width = 5;\nchar field[Height][Width];\nint top,ans;\nint dx[] = {1,0};\nint dy[] = {0,-1};\n \n \nvoid print(int h, int w){\n \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl;\n     \n}\nbool isInside(int h, int w){return 0<=h&&h<Height&&0<=w&&w<Width;}\n \nint getH(int d, int len, int pos){\n  for(int i = top+1; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?' || !isInside(h,w)) return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n}\n\nvoid down(int n){\n\n  for(int i = n; i <= top; i++)\n    for(int j = 0; j < Width; j++) field[i][j] = field[i+1][j];\n\n}\n\nvoid erase(){\n\n  for(int i = 0; i <= top; i++){\n    bool f = true;\n    for(int j = 0; j < Width; j++){\n      if(field[i][j] == '?') f = false;\n    }\n    if(f){\n      ans -= 5;\n      down(i);\n      i--;\n    }\n  }\n}\n \nvoid put(int d, int len, int pos){\n \n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n \n  int h = nex;\n  int w = pos;\n \n  for(int i = 0; i < len; i++){\n    field[h][w] = '.';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n \nint main(){\n \n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    ans = top = 0;\n    \n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      ans += len;\n      put(d-1,len,pos-1);\n      erase();\n    }\n    cout << ans << endl;\n    //    print(10,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n \nusing namespace std;\n \nconst int Height = 5010;\nconst int Width = 5;\nchar field[Height][Width];\nint top,ans;\nint dx[] = {1,0};\nint dy[] = {0,-1};\n \nvoid print(int h, int w){\n \n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++) cout << field[i][j];\n    cout << endl;\n  }\n  cout << endl; \n}\n \nint getH(int d, int len, int pos){\n  for(int i = top+6; i>=0; i--){\n    int h = i;\n    int w = pos;\n    for(int j = 0; j < len; j++){\n      if(field[h][w] != '?') return i+1;\n      h += dy[d];\n      w += dx[d];\n    }\n  }\n}\n\nvoid down(int n){\n \n  for(int i = n; i <= top+6; i++)\n    for(int j = 0; j < Width; j++) field[i][j] = field[i+1][j];\n  top--;\n}\n\nvoid erase(){\n\n  for(int i = 0; i <= top+6; i++){\n    bool f = true;\n    for(int j = 0; j < Width; j++) if(field[i][j] == '?') f = false;\n    if(f){\n      ans -= 5;\n      down(i--);\n    }\n  }\n}\n \nvoid put(int d, int len, int pos){\n \n  int nex = getH(d,len,pos);\n  top = max(top,nex);\n \n  int h = nex;\n  int w = pos;\n \n  for(int i = 0; i < len; i++){\n    field[h][w] = '.';\n    h += dy[d];\n    w += dx[d];\n  }\n}\n \nint main(){\n \n  int n;\n  while(cin >> n && n){\n    memset(field,'?',sizeof(field));\n    ans = top = 0;\n    \n    while(n--){\n      int d, len, pos;\n      cin >> d >> len >> pos;\n      ans += len;\n      put(d-1,len,pos-1);\n      erase();\n    }\n    cout << ans << endl;\n    // print(10,5);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint grid[5][6000];\nint n,d,p,q;\nll int ans = 0;\n\nint GetBottom(int x){\n\tREP(i,6000){\n\t\tif(grid[x][i]==-1) return i;\n\t}\n\treturn 0;\n}\n\nbool isallclear(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=-1) return false;\n\t}\n\treturn true;\n}\n\nbool isallblock(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(cin>>n,n){\n\t\tREP(i,5) REP(j,6000) grid[i][j] = -1;\n\t\tREP(i,n){\n\t\t\tcin >> d >> p >> q;\n\t\t\tif(d==2){\n\t\t\t\tint tmp = GetBottom(q-1);\n\t\t\t\tFOR(j,tmp,tmp+p) grid[q-1][j] = 1;\n\t\t\t}else{\n\t\t\t\tint tmp = -1;\n\t\t\t\tFOR(j,q-1,q-1+p){\n\t\t\t\t\ttmp = max(tmp,GetBottom(j));\n\t\t\t\t}\n\t\t\t\tFOR(j,q-1,q-1+p) {\n\t\t\t\t\tgrid[j][tmp] = 1;\n\t\t\t\t\tREP(k,tmp) if(grid[j][k]==-1) grid[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowline = 0;\n\t\t\twhile(1){\n\t\t\t\tif(isallclear(nowline)) break;\n\t\t\t\tif(isallblock(nowline)){\n\t\t\t\t\tREP(j,5) {\n\t\t\t\t\t\tint nline = nowline+1;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tif(grid[j][nline]==-1) {\n\t\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\tnline++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tnowline = 0;\n\t\t\t\t}else{\n\t\t\t\t\tnowline++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tint line = 0;\n\t\twhile(1){\n\t\t\tif(isallclear(line)) break;\n\t\t\tREP(i,5){\n\t\t\t\tif(grid[i][line]==1) ans++;\n\t\t\t}\n\t\t\tline++;\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<iostream>\n#include<cstring>\n#include<string>\nusing namespace std;\n\nint ad,muki,pos,leng,hight[6],map1[6][6000];\n\nint main(){\n  while(true){\n    for(int raw=1;raw<6;raw++){\n      for(int high=0;high<6000;high++){\n\tmap1[raw][high]=0;\n      }\n    }\n    int blo=0; \n    int x=0;\n    cin>>ad;\n    if(ad==0){break;}\n    for(int i=0;i<ad;i++) {\n      for(int j=1;j<6;j++){\n\thight[j]=0;}\n\n      cin>>muki;\n      cin>>leng;\n      cin>>pos;\n      blo+=leng;\n      for(int raw=1;raw<6;raw++){\n\tfor(int high=0;high<6000;high++){\n\t  if(map1[raw][high]==1){\n\t    hight[raw]=max(hight[raw],high);\n\t  }\n\t}\n\tif(map1[raw][hight[raw]]==1){\n\t  hight[raw]++;\n\t}\n\t///cout<<hight[raw]<<\" \";\n      }\n      ///cout<<endl;\n      if(muki==2){\n\tfor(int hhhh=0;hhhh<leng;hhhh++){\n\t  map1[pos][hight[pos]+hhhh]=1;\n\t}\n      }\n      if(muki==1){\n\tint hamu=0;\n\tfor(int raw=pos;raw<pos+leng;raw++){\n\t  hamu=max(hight[raw],hamu);\n\t}\n\tfor(int raw=pos;raw<pos+leng;raw++){\n\t  map1[raw][hamu]=1;\n\t}\n      }/*\n      for(int high=0;high<10;high++){\n\tfor(int raw=1;raw<6;raw++){\n\t  cout<<map1[raw][high]<<\" \";\n\t}\n\tcout<<endl;\n      }\n      cout<<\"-----------------------\"<<endl;\n       *///kesi\n      for(int high=0;high<6000;high++){\n\tint hantei=0;\n\tfor(int raw=1;raw<6;raw++){\n\t  if(map1[raw][high]==0){break;}\n\t  else{hantei++;}\n\t}\n\tif(hantei==5){\n\t  x++;\n\t  for(int j=1;j<6;j++){\n\t    hight[j]--;}\n\t  for(int a=1;a<6000-high;a++){\n\t    for(int raw=1;raw<6;raw++){\n\t      map1[raw][high+a-1]=map1[raw][high+a];\n\t    }\n\t  }\n\t  high--;\n\t}\n      }\n    }\n    int xxx=0;\n    xxx=blo-(5*x);\n    cout<<xxx<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n#define HORIZONTAL 1\n#define VERTICAL 2\n#define ALL 1+2+4+8+16\nint main()\n{\n  int n,d,p,q;\n  int num,block;\n  while(cin>>n,n){\n    vector<int>field;\n    vector<int>::reverse_iterator it;\n    queue<int>next;\n\n    while(n-->0){\n      cin>>d>>p>>q;\n      if(d==HORIZONTAL){\n\tblock=0;\n\twhile(p-->0)block ^= 1<<(q+p-1);\n\tnext.push(block);\n      }else{\n\tblock=1<<(q-1);\n\twhile(p-->0)next.push(block);\n      }\n    }\n\n    block=ALL;\n    field.push_back(block);\n    while(next.size()){\n      block=next.front();\n      next.pop();\n\n      if(block==ALL)continue;\n\n      if(field.back()&block){\n\tfield.push_back(block);\n\tcontinue;\n      }\n\n      for(it=field.rbegin();it!=field.rend();it++){\n\tif(*it&block){\n\t  it--;\n\t  *it^=block;\n\t  if(*it==ALL){\n\t    it++;\n\t    field.erase(it.base());\n\t  }\n\t  break;\n\t}\n      }\n    }\n\n\n    num=-5;\n    for(it=field.rbegin();it!=field.rend();it++){\n      for(int i=1;i<=16;i=i<<1){\n\tif(*it&i)num++;\n      }\n    }\n    cout<<num<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < ((k)+(n)); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \ntemplate <class _Tv> inline string join(const _Tv &v,string sep=\" \"){\n    ostringstream s;FOREACH(it,v){if(it!=v.begin())s<<sep;s<<*it;};return s.str();\n}\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double D;\ntypedef complex<D> P;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define X real()\n#define Y imag()\n#define EPS (1e-9)\n#define DEQ(p1,p2) (abs((p1)-(p2)) < EPS)\n\n#ifdef _DEBUG\ntemplate<class _Tv> inline void _prfe(const char *_n,const _Tv _c,bool _p=false){\n    ITER(_c) _it=_c.begin();\n    if(_p){cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{cout<<_n<<\" = [ \";if(_c.size()){cout<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;}cout<<\" ]\"<<endl; }\n}\nostream &operator<<(ostream &os, const pair<int,int> &p){return(os<<\"(\"<<p.first<<\",\"<<p.second<<\")\");}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\nconst int WIDTH = 5;\nconst int fullbit = (1<<WIDTH)-1;\n\nint st[5010], mx[WIDTH];\n\nint main(){\n    int n;\n    while(cin >> n && n){\n        REP(i,WIDTH) mx[i] = 0;\n        REP(i,5010) st[i] = 0;\n        int d,l,p,b=0;\n        REP(i,n){\n            cin >> d >> l >> p; p--;\n            if(d==1){//yoko\n                int sp = 0;\n                REP(i,l) sp = MAX(sp, mx[p+i]);\n                REP(i,l) st[sp] |= 1<<(p+i), mx[p+i]=sp+1;\n            } else {//tate\n                int sp = mx[p];\n                REP(i,l) st[sp+i] |= 1<<(p);\n                mx[p] += l;\n            }\n            b += l;\n            int sp = 0;\n            REP(i,WIDTH) sp = MAX(sp, mx[i]);\n            int ci = 0;\n            REP(i,sp){\n                if(st[i] != fullbit){\n                    st[ci] = st[i]; ci++;\n                } else {\n                    b -= WIDTH;\n                }\n            }\n            while(ci < sp){ st[ci] = 0; ci++; }\n\n            REP(i,WIDTH){\n                int mask = 1<<i;\n                while(mx[i] > 0 && !(st[mx[i]-1]&mask)) mx[i]--;\n            }\n#ifdef _DEBUG\n            pf(\"-----\\n\");\n            REP(i,sp){\n                int d = st[sp-i-1];\n                REP(j,WIDTH){pf(\"%c\", (d&1)?'*':' '); d >>= 1;} pf(\"\\n\");\n            }\n            pf(\"-----\\n\");\n            REP(i,5)pf(\"%d \", mx[i]);pf(\"(%d)\\n\\n\", b);\n#endif\n        }\n        cout << b << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\nusing namespace std;\n\nconst int WIDTH = 5;\nconst int BLOCK_LENGTH_MAX = 5;\n\nclass Tetoris\n{\npublic:\n\tTetoris( int num ) :\n\t\tm_numBlocks( num ),\n\t\tm_pField( NULL ),\n\t\tm_heightMax( 0 ),\n\t\tm_cellCount( 0 )\n\t{\n\t\tmemset( m_heights, 0, sizeof(m_heights) );\n\t\tm_pField = new bool[ num * BLOCK_LENGTH_MAX * WIDTH ]();\n\t\tm_pFullLine = new bool[ num * BLOCK_LENGTH_MAX ]();\n\t}\n\t~Tetoris()\n\t{\n\t\tdelete[] m_pField;\n\t\tdelete[] m_pFullLine;\n\t}\n\tvoid dropBlock( int direction, int length, int position )\n\t{\n\t\tm_cellCount += length;\n\t\tint h = 0;\n\t\tif( direction == 1 ){\n\t\t\tfor( int i = 0; i < length; ++i ){\n\t\t\t\tif( h < m_heights[ i + position ] ) h = m_heights[ i + position ];\n\t\t\t}\n\t\t\tfor( int i = 0; i < length; ++i ){\n\t\t\t\tm_pField[ h * WIDTH + i + position ] = true;\n\t\t\t\tm_heights[ i + position ] = h + 1;\n\t\t\t}\n\t\t\tif( isFilled( h ) ){\n\t\t\t\tm_pFullLine[ h ] = true;\n\t\t\t}\n\t\t\tdetectHeights( h );\n\t\t}else{\n\t\t\th = m_heights[ position ];\n\t\t\tint up = 0;\n\t\t\tfor( int i = 0; i < length; ++i ){\n\t\t\t\twhile( m_pFullLine[ h + i + up ] ){\n\t\t\t\t\t++up;\n\t\t\t\t}\n\t\t\t\tm_pField[ ( h + i + up ) * WIDTH + position ] = true;\n\t\t\t}\n\t\t\tm_heights[ position ] += length + up;\n\t\t\tfor( int i = 0; i < length + up; ++i ){\n\t\t\t\tif( isFilled( h + i ) ){\n\t\t\t\t\tm_pFullLine[ h + i ] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tdetectHeights( h + length + up );\n\t\t}\n\t}\n\tbool isFilled( int h )\n\t{\n\t\tfor( int i = 0; i < WIDTH; ++i ){\n\t\t\tif( !m_pField[ h * WIDTH + i ] ){\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tvoid detectHeights( int h )\n\t{\n\t\tm_heightMax = 0;\n\t\tfor( int i = 0; i < WIDTH; ++i ){\n\t\t\tint p = h;\n\t\t\twhile( p >= 0 && ( !m_pField[ p * WIDTH + i ] || m_pFullLine[ p ] ) ){\n\t\t\t\t--p;\n\t\t\t}\n\t\t\tp += 1;\n\t\t\twhile( p < m_numBlocks * BLOCK_LENGTH_MAX && m_pField[ p * WIDTH + i ] ){\n\t\t\t\t++p;\n\t\t\t}\n\t\t\tm_heights[ i ] = p;\n\t\t\tif( m_heightMax < m_heights[ i ] ){\n\t\t\t\tm_heightMax = m_heights[ i ];\n\t\t\t}\n\t\t}\n\t}\n\tint getResult()\n\t{\n\t\tint countFilledLine = 0;\n\t\tfor( int i = 0; i < m_heightMax; ++i ){\n\t\t\tif( m_pFullLine[ i ] ) ++countFilledLine;\n\t\t}\n\t\treturn m_cellCount - countFilledLine * WIDTH;\n\t}\n\tvoid outputState()\n\t{\n\t\tfor( int i = m_heightMax - 1; i >= 0; --i ){\n\t\t\tfor( int j = 0; j < WIDTH; ++j ){\n\t\t\t\tcout << ( m_pField[ i * WIDTH + j ] ? 'o' : '.' );\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\tcout << \"heights:\" << endl;\n\t\tfor( int i = 0; i < WIDTH; ++i ){\n\t\t\tcout << m_heights[ i ] << ' ';\n\t\t}\n\t\tcout << endl;\n\t\tcout << \"heightMax : \" << m_heightMax << endl << endl;\n\t}\n\nprivate:\n\tint m_numBlocks;\n\tbool* m_pField;\n\tint m_heightMax;\n\tint m_heights[ WIDTH ];\n\tbool* m_pFullLine;\n\tint m_cellCount;\n};\n\nint main()\n{\n\tint n;\n\n\twhile( cin >> n && n )\n\t{\n\t\tTetoris t( n );\n\t\tfor( int i = 0; i < n; ++i ){\n\t\t\tint d, l, p;\n\t\t\tcin >> d >> l >> p;\n\t\t\tt.dropBlock( d, l, p - 1 );\n//\t\t\tt.outputState();\n\t\t}\n\t\tcout << t.getResult() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) cerr << #x << \"=\" << static_cast<bitset<16> >(x) << endl;\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\nconst int INF = 10000000;\nint dx[4]={1, 0, -1, 0}, dy[4]={0, 1, 0, -1};\nusing namespace std;\ntypedef long long  ll;\n\n/** Problem0178 : TETORIS **/\nbool board[5][5000];\n\nint main()\n{\n\tint n, d, p, q;\n\twhile (cin>>n, n) {\n\t\trep(x, 5) rep(y, 5000) board[x][y]=false;\n\t\trep(k, n) {\n\t\t\tcin >> d >> p >> q;\n\t\t\tq--;\n\t\t\t\n\t\t\tint dx=1, dy=0;\n\t\t\tif (d==2) {\n\t\t\t\tdx=0; dy=1;\n\t\t\t}\n\t\t\t\n\t\t\tvector<int> low;\n\t\t\tfor (int ii=0; ii<p; ii++) {\n\t\t\t\tfor (int i=4999; i>=0; i--) {\n\t\t\t\t\tif (board[q+ii][i]) {\n\t\t\t\t\t\tlow.push_back(i+1);\n\t\t\t\t\t\tgoto end;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlow.push_back(0);\n\t\t\tend:;\n\t\t\t\tif (d==2) break;\n\t\t\t}\n\n\t\t\tint m=0;\n\t\t\trep(j, low.size()) {\n\t\t\t\tm = max(m, low[j]);\n\t\t\t}\n\t\t\t\n\t\t\tboard[q][m]=true;\n\t\t\trep(j, p-1) {\n\t\t\t\tq+=dx;m+=dy;\n\t\t\t\tboard[q][m] = true;\n\t\t\t}\n\t\t\t\n\t\t\trep(y, 5000) {\n\t\t\t\tbool flg = true;\n\t\t\t\trep(x, 5) {\n\t\t\t\t\tflg &= board[x][y];\n\t\t\t\t}\n\t\t\t\tif (flg) {\n\t\t\t\t\tfor (int yy=y; yy<5000; yy++) {\n\t\t\t\t\t\tfor (int xx=0; xx<5; xx++) {\n\t\t\t\t\t\t\tboard[xx][yy] = board[xx][yy+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tfor (int xx=0; xx<5; xx++) {\n\t\t\t\t\t\tboard[xx][4999] = false;\n\t\t\t\t\t}\n\t\t\t\t\ty--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t/**\n\t\t\trep(y, 10) {\n\t\t\t\trep(x, 5) {\n\t\t\t\t\tcout << (board[x][9-y]?\"#\":\"0\");\n\t\t\t\t}\n\t\t\t\tcout << endl;\n\t\t\t}\n\t\t\tcout << endl; **/\n\t\t}\n\t\tint ans=0;\n\t\trep(y, 5000) {\n\t\t\trep(x, 5) {\n\t\t\t\tif (board[x][y])\n\t\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <cmath>\n#include <string>\n#include <sstream>\n#include <iomanip>\n#include <complex>\nusing namespace std;\n\n#define ll long long\n#define vvi vector< vector<int> >\n#define All(X) X.begin(),X.end()\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define pb push_back \nll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\nll lcm(ll a,ll b){return a/gcd(a,b)*b;}\n\nint grid[5][5010];\nint n,d,p,q;\nll int ans = 0;\n\nint GetBottom(int x){\n\tREP(i,5000){\n\t\tif(grid[x][i]==-1) return i;\n\t}\n\treturn 0;\n}\n\nbool isallclear(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=-1) return false;\n\t}\n\treturn true;\n}\n\nbool isallblock(int x){\n\tREP(i,5){\n\t\tif(grid[i][x]!=1) return false;\n\t}\n\treturn true;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n;\n\t\tREP(i,5) REP(j,5000) grid[i][j] = -1;\n\t\tREP(i,n){\n\t\t\tcin >> d >> p >> q;\n\t\t\tif(d==2){\n\t\t\t\tint tmp = GetBottom(q-1);\n\t\t\t\tFOR(j,tmp,tmp+p) grid[q-1][j] = 1;\n\t\t\t}else{\n\t\t\t\tint tmp = -1;\n\t\t\t\tFOR(j,q-1,q-1+p){\n\t\t\t\t\ttmp = max(tmp,GetBottom(j));\n\t\t\t\t}\n\t\t\t\tFOR(j,q-1,q-1+p) {\n\t\t\t\t\tgrid[j][tmp] = 1;\n\t\t\t\t\tREP(k,tmp) if(grid[j][k]==-1) grid[j][k] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint nowline = 0;\n\t\t\twhile(1){\n\t\t\t\tif(isallclear(nowline)) break;\n\t\t\t\tif(isallblock(nowline)){\n\t\t\t\t\tREP(j,5) {\n\t\t\t\t\t\tint nline = nowline+1;\n\t\t\t\t\t\twhile(1){\n\t\t\t\t\t\t\tif(grid[j][nline]==-1) {\n\t\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tgrid[j][nline-1] = grid[j][nline];\n\t\t\t\t\t\t\tnline++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tnowline++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tint line = 0;\n\t\twhile(1){\n\t\t\tif(isallclear(line)) break;\n\t\t\tREP(i,5){\n\t\t\t\tif(grid[i][line]==1) ans++;\n\t\t\t}\n\t\t\tline++;\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define H 99\nn,d,p,q,m[H];\nb,h;\nmain(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tmemset(m,0,sizeof(m));\n\t\tfor(;n--;){\n\t\t\tscanf(\"%d%d%d\",&d,&p,&q);\n\t\t\tif(d==1)\n\t\t\t\tb=((1<<p)-1)<<q;\n\t\t\telse\n\t\t\t\tb=1<<q;\n\t\t\tfor(h=H-1;h>=0;h--)\n\t\t\t\tif(m[h]&b)\n\t\t\t\t\tbreak;\n\t\t\th++;\n\t\t\tif(d==1)\n\t\t\t\tp=1;\n\t\t\tfor(;p--;){\n\t\t\t\tm[h]|=b;\n\t\t\t\tif(m[h]==0x3e)\n\t\t\t\t\tmemmove(m+h,m+h+1,H-h-1);\n\t\t\t\telse\n\t\t\t\t\th++;\n\t\t\t}\n\t\t}\n\t\tp=0;\n\t\tfor(h=0;h<H;h++){\n\t\t\tfor(;q=-m[h]&m[h];m[h]-=q)\n\t\t\t\tp++;\n\t\t}\n\t\tprintf(\"%d\\n\",p);\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#define H 10000\nn,d,p,q,m[H];\nb,h;\nmain(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tmemset(m,0,sizeof(m));\n\t\tfor(;n--;){\n\t\t\tscanf(\"%d%d%d\",&d,&p,&q);\n\t\t\tif(d==1)\n\t\t\t\tb=((1<<p)-1)<<q;\n\t\t\telse\n\t\t\t\tb=1<<q;\n\t\t\tfor(h=H-1;h>=0;h--)\n\t\t\t\tif(m[h]&b)\n\t\t\t\t\tbreak;\n\t\t\th++;\n\t\t\tif(d==1)\n\t\t\t\tp=1;\n\t\t\tfor(;p--;){\n\t\t\t\tm[h]|=b;\n\t\t\t\tif(m[h]==0x3e)\n\t\t\t\t\tmemmove(m+h,m+h+1,H-h-1);\n\t\t\t\telse\n\t\t\t\t\th++;\n\t\t\t}\n\t\t}\n\t\tp=0;\n\t\tfor(h=0;h<H;h++){\n\t\t\tfor(;q=-m[h]&m[h];m[h]-=q)\n\t\t\t\tp++;\n\t\t}\n\t\tprintf(\"%d\\n\",p);\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,k,block[500000][5],hhh,max[5],left,from,time;\nint n,d,l,x;\n\nvoid swap (int* x,int* y){\n\tint z;\n\tz=*x;\n\t*x=*y;\n\t*y=z;\n}\n\nint main(){\n\twhile(scanf(\"%d\",&n)*n){\n\t\thhh=0;left=0;\n\t\tfor(i=0;i<5;i++)max[i]=0;\n\n\t\tfor(;n>0;n--){\n\n\t\t\tscanf(\"%d %d %d\",&d,&l,&x); x--;\n\t\t\tleft+=l;\n\n\t\t\tif(d==1){\n\t\t\t\tk=0;j=0;\n\t\t\t\tfor(i=0;i<l;i++){if(max[x+i]>k){k=max[x+i];j=x+i;}}\n\t\t\t\tfor(i=0;i<l;i++){max[x+i]=k+1;block[k][x+i]=1;}\n\t\t\t\tfrom=k;time=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(i=0;i<l;i++)block[max[x]+i][x]=1;\n\t\t\t\tfrom=max[x];\n\t\t\t\tmax[x]+=l;\n\t\t\t\ttime=l;\n\t\t\t\tj=x;\n\t\t\t}\n\n\t\t\tif(hhh<max[j])hhh=max[j];\n\n\t\t\tfor(i=0;i<time;i++){\n\t\t\t\tif(block[from][0]==1 && block[from][1]==1 && block[from][2]==1 && block[from][3]==1 && block[from][4]==1){\n\t\t\t\t\tfor(j=0;j<5;j++){block[from][j]=0;}\n\t\t\t\t\tfor(k=from+1;k<hhh;k++){\n\t\t\t\t\t\tfor(j=0;j<5;j++){\n\t\t\t\t\t\t\tswap(&block[k][j],&block[k-1][j]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tleft-=5;hhh--;\n\t\t\t\t}\n\t\t\t\telse from++;\n\t\t\t}\n\n\t\t\tfor(j=0;j<5;j++){\n\t\t\t\tfor(k=max[j];k>=0;k--){\n\t\t\t\t\tif(block[k][j]==1)break;\n\t\t\t\t}\n\t\t\t\tmax[j]=k+1;\n\t\t\t}\n\t\t\t/*\n\t\t\tfor(i=hhh-1;i>=0;i--){\n\t\t\t\tfor(j=0;j<5;j++){\n\t\t\t\t\tprintf(\"%c\",block[i][j]==1 ? '*' : ' ');\n\t\t\t\t}\n\t\t\t\tprintf(\"\\n\");\n\t\t\t}\n\t\t\tfor(j=0;j<5;j++){printf(\"%d\",max[j]);}printf(\"\\n\");\n\t\t\tprintf(\"height:%d\\n\",hhh);\n\t\t\t*/\n\t\t}\n\n\t\tfor(i=0;i<hhh;i++){\n\t\t\tfor(j=0;j<5;j++){\n\t\t\t\tblock[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",left);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,k,block[500000][5],hhh,max[5],left,from,time;\nint n,d,l,x;\n\nint main(){\n\twhile(scanf(\"%d\",&n)*n){\n\t\thhh=0;left=0;\n\t\tfor(i=0;i<5;i++)max[i]=0;\n\n\t\tfor(;n>0;n--){\n\n\t\t\tscanf(\"%d %d %d\",&d,&l,&x); x--;\n\t\t\tleft+=l;\n\n\t\t\tif(d==1){\n\t\t\t\tk=0;j=0;\n\t\t\t\tfor(i=0;i<l;i++){if(max[x+i]>k){k=max[x+i];j=x+i;}}\n\t\t\t\tfor(i=0;i<l;i++){max[x+i]=k+1;block[k][x+i]=1;}\n\t\t\t\tfrom=k;time=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(i=0;i<l;i++)block[max[x]+i][x]=1;\n\t\t\t\tfrom=max[x];\n\t\t\t\tmax[x]+=l;\n\t\t\t\ttime=l;\n\t\t\t\tj=x;\n\t\t\t}\n\n\t\t\tif(hhh<max[j])hhh=max[j];\n\n\t\t\tfor(i=0;i<time;i++){\n\t\t\t\tif(block[from][0]==1 && block[from][1]==1 && block[from][2]==1 && block[from][3]==1 && block[from][4]==1){\n\t\t\t\t\tfor(j=0;j<5;j++){block[from][j]=0;}\n\t\t\t\t\tfor(k=from+1;k<hhh+1;k++){\n\t\t\t\t\t\tfor(j=0;j<5;j++){\n\t\t\t\t\t\t\t&block[k-1][j]=&block[k][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tleft-=5;hhh--;\n\t\t\t\t}\n\t\t\t\telse from++;\n\t\t\t}\n\n\t\t\tfor(j=0;j<5;j++){\n\t\t\t\tfor(k=max[j];k>=0;k--){\n\t\t\t\t\tif(block[k][j]==1)break;\n\t\t\t\t}\n\t\t\t\tmax[j]=k+1;\n\t\t\t}\n\t\t}\n\n\t\tfor(i=0;i<hhh;i++){\n\t\t\tfor(j=0;j<5;j++){\n\t\t\t\tblock[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",left);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ Volume 1 Problem 0178 TETORIS\n\n#include <stdio.h>\n#include <string.h>\n\n\nint field[5002][6];\n\nvoid print(void)\n{\n    int i, j;\n    \n    for (i = 10; i > 0; i--){\n        for (j = 1; j <= 5; j++){\n            if (field[i][j] == 0){\n                printf(\"-\");\n            }\n            else {\n                printf(\"#\");\n            }\n        }\n        printf(\":%d\\n\", field[i][0]);\n    }\n    for (j = 1; j <= 5; j++){\n        printf(\"<%d>\", field[0][j]);\n    }\n    printf(\"\\n\");\n}\n \nint main(void)\n{\n    int block;\n    int i, j;\n    int n, d, p, q;\n    int pos;\n    int cnt;\n\n    while (1){\n        scanf(\"%d\", &n);\n        \n        if (n == 0){\n            break;\n        }\n        \n        for (i = 0; i <= 5; i++){\n            for (j = 0; j <= 5001; j++){\n                field[j][i] = 0;\n            }\n        }\n        \n        for (block = 0; block < n; block++){\n            \n            scanf(\"%d%d%d\", &d, &p, &q);\n            \n            if (d == 2){\n                // ツ縦ツづ個ブツδ債ッツクツづーツ置ツつュ\n                for (i = field[0][q] + 1; i < field[0][q] + 1 + p; i++){\n                    field[i][q] = 1;\n                    field[i][0]++;\n                }\n                field[0][q] += p;\n            }\n            else {\n                // ツ可。ツブツδ債ッツクツづ個暗環置ツづーツ仰づ淞づゥ\n                pos = 0;\n                for (i = q; i < q + p; i++){\n                    if (pos < field[0][i]){\n                        pos = field[0][i];\n                    }\n                }\n                \n                // ツブツδ債ッツクツづーツ置ツつュ\n                for (i = q; i < q + p; i++){\n                    field[pos + 1][i] = 1;\n                    field[0][i] = pos + 1; // ツ暗環置ツ湘ョツ陛アツづ個更ツ新\n                }\n                field[pos + 1][0] += p;\n            }\n//    print();\n            // ツブツδ債ッツクツづーツ湘つキ\n            for (i = 5000; i >= 1; i--){\n                if (field[i][0] == 5){\n                    memcpy(&field[i][0], &field[i + 1][0], (5000 - i) * sizeof(int));\n                }\n            }\n            \n            // ツつサツづェツつシツづェツづ個療アツづ個暗ェツ氾板債つつ「ツ湘ェツ渉環づーツ仰づ淞づゥ\n            for (i = 1; i <= 5; i++){\n                for (j = 5000; j > 0 && field[j][i] == 0; j--);\n                field[0][i] = j;\n            }\n//    print();\n                \n        }\n        // ツ残ツづつスツブツδ債ッツクツづーツ青板つヲツづ表ツ篠ヲツつキツづゥ\n        cnt = 0;\n        for (i = 1; i <= 5000 && field[i][0] != 0; i++){\n            cnt += field[i][0];\n        }\n        printf(\"%d\\n\", cnt);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0178\nTitle\n*/\n#include <stdio.h>\n#include <string.h>\nchar ban[5000];\nint N;\n//\nint cnt5bits(int x) //0~31\n{\n  int i,s;\n  s=0;\n  for(i=0;i<5;i++)\n    if((1<<i)&x)\n      s++;\n  return(s);\n}\n\n\nvoid show()\n{\n  int i,s;\n  s=0;\n  for(i=0;i<20 && ban[i];i++)\n    {\n#ifdef DEBUG\n      printf(\"%d:\",ban[i]);\n#endif\n      s += cnt5bits(ban[i]);\n    }\n#ifdef DEBUG\n  printf(\"\\n\");\n#endif\n  printf(\"%d\\n\",s);\n}\nmain()\n{\n  int i,j,k,d,l,p,v,top;\n\n  while(EOF!=scanf(\"%d \",&N) && N)\n    {\n      memset(ban,0,1000);\n      for(i=0;i<N;i++)\n\t{\n\t  scanf(\"%d %d %d\",&d,&l,&p);\n\t  if(d==1)\n\t    v=((1<<l)-1)*(1<<(6-l-p));\n\t  else\n\t    v=(1<<(5-p));\n\n\t  top=0;                  //calc highest pos\n\t  while(ban[++top]);\n\t  j=top+1;\n\t  while((v & ban[j-1])==0 && j>0)\n\t    {  j--;\n\t    }\t  \n\t  ban[j]|=v;\n      \n\t  if(d==2)\n\t    for(k=1;k<l;k++)\n\t      ban[j+k]|=v;\n\n\t  top=0;\n\t  while(ban[++top]);\n\t  \n\n\t  for(k=top;k>=0;k--)\n\t    if(ban[k]==31)\n\t      {\n\t\tl=k;\n\t\tdo\n\t\t  {\n\t\t    ban[l]=ban[l+1];\n\t\t    l=l+1;\n\t\t  }\n\t\twhile(ban[l] && l<5000);\n\t      }\n\t  //show();\n\t}\n      show();\n    }     \nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0178: TETORIS\n// 2017.8.23 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 5002\ntypedef struct { int p, n; char w, f[6]; } T;\nT tbl[MAX+10];\nint top[6], tt;\n\nvoid adj(int x, int h)\n{\n\tint i, xx, lim;\n\tint prev, next;\n\n\tfor (xx = x, i = 0; i < h; i++, xx = tbl[xx].n); lim = xx;\n\tif (lim < tt ) lim = tt;\n\tfor (i = 0; i < h; i++, x = tbl[x].n) {\n\t\tif (tbl[x].w == 5) {\n\t\t\tprev = tbl[x].p, next = tbl[x].n;\n\t\t\ttbl[prev].n = next, tbl[next].p = prev;\n\t\t}\n\t}\n\tfor (xx = -1, i = 1; i <= 5; i++) {\n\t\tfor (h = 0, x = tbl[0].n; x != lim; x = tbl[x].n) if (tbl[x].f[i]) h = x;\n\t\tif ((top[i] = tbl[h].n) > xx) xx = top[i];\n\t}\n\ttt = xx;\n}\n\nint main()\n{\n\tint n, d, p, q;\n\tint i, j, h, x, ans;\n\n\twhile (scanf(\"%d\", &n) && n) {\n\t\tfor (i = 1; i < MAX; i++) {\n\t\t\ttbl[i].n = i+1, tbl[i].p = i-1, tbl[i].w = 0;\n\t\t\tfor (j = 1; j <= 5; j++) tbl[i].f[j] = 0;\n\t\t}\n\t\ttbl[0].n = 1, tt = 1; for (i = 1; i <= 5; i++) top[i] = 1;\n\t\twhile (n-- > 0) {\n\t\t\tscanf(\"%d%d%d\", &d, &p, &q);\n\t\t\tif (d == 1) {\t// yoko\n\t\t\t\tfor (h = -1, i = 0; i < p; i++) {\n\t\t\t\t\tif (top[q+i] > h) h = top[q+i];\n\t\t\t\t}\n\t\t\t\ttbl[h].w += p;\n\t\t\t\tfor (i = 0; i < p; i++) tbl[h].f[q+i] = 1;\n\t\t\t\tadj(h, 1);\n\t\t\t} else {\n\t\t\t\tx = h = top[q];\n\t\t\t\tfor (i = 0; i < p; i++, x = tbl[x].n) tbl[x].w++, tbl[x].f[q] = 1;\n\t\t\t\tadj(h, p);\n\t\t\t}\n\t\t}\n\t\tfor (ans = 0, x = tbl[0].n; x != tt; x = tbl[x].n) ans += tbl[x].w;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-1 0178: TETORIS\n// 2017.8.23 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 5002\ntypedef struct { int p, n; char w, f[6]; } T;\nT tbl[MAX+10];\nint top[6];\n\nvoid adj(int x, int h)\n{\n\tint i, xx, lim;\n\tint prev, next;\n\n\tfor (xx = x, i = 0; i <= h; i++, xx = tbl[xx].n); lim = xx;\n\tfor (i = 0; i < h; i++, x = tbl[x].n) {\n\t\tif (tbl[x].w == 5) {\n\t\t\tprev = tbl[x].p, next = tbl[x].n;\n\t\t\ttbl[prev].n = next, tbl[next].p = prev;\n\t\t}\n\t}\n\tfor (i = 1; i <= 5; i++) {\n\t\tfor (h = 0, x = tbl[0].n; x != lim; x = tbl[x].n) if (tbl[x].f[i]) h = x;\n\t\tif (!h) top[i] = 1; else top[i] = tbl[h].n;\n\t}\n}\n\nint main()\n{\n\tint n, d, p, q;\n\tint i, j, h, x, ans;\n\n\twhile (scanf(\"%d\", &n) && n) {\n\t\tfor (i = 1; i < MAX; i++) {\n\t\t\ttbl[i].n = i+1, tbl[i].p = i-1, tbl[i].w = 0;\n\t\t\tfor (j = 1; j <= 5; j++) tbl[i].f[j] = 0;\n\t\t}\n\t\ttbl[0].n = 1; for (i = 1; i <= 5; i++) top[i] = 1;\n\t\twhile (n-- > 0) {\n\t\t\tscanf(\"%d%d%d\", &d, &p, &q);\n\t\t\tif (d == 1) {\t// yoko\n\t\t\t\tfor (h = -1, i = 0; i < p; i++) {\n\t\t\t\t\tif (top[q+i] > h) h = top[q+i];\n\t\t\t\t}\n\t\t\t\ttbl[h].w += p;\n\t\t\t\tfor (i = 0; i < p; i++) tbl[h].f[q+i] = 1;\n\t\t\t\tadj(h, 1);\n\t\t\t} else {\n\t\t\t\tx = h = top[q];\n\t\t\t\tfor (i = 0; i < p; i++, x = tbl[x].n) tbl[x].w++, tbl[x].f[q] = 1;\n\t\t\t\tadj(h, p);\n\t\t\t}\n\t\t}\n\t\tfor (h = 1, i = 1; i <= 5; i++) { if (top[i] > h) h = top[i]; }\n\t\tif (h == 1) ans = 0;\n\t\telse for (ans = 0, x = tbl[0].n; x != h; x = tbl[x].n) ans += tbl[x].w;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "n,d,p,q,m[9999],h;main(b){for(;~scanf(\"%d\",&n),n;d&&printf(\"%d\\n\",p)){for(memset(m,d=0,39996);n--;){scanf(\"%d%d%d\",&d,&p,&q);b=(d-2?~-(1<<p):1)<<q;for(h=9998;~h&&!(m[h]&b);h--)d-2?p=1:0;for(h++;p--;m[h]-62?h++:memmove(m+h,m+h+1,9998-h))m[h]|=b;}for(p=0,h=9999;h--;)for(b=m[h];q=-b&b;b-=q)p++;}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint i,j,k,block[500000][5],hhh,max[5],left,from,time;\nint n,d,l,x;\n\nint main(){\n\twhile(scanf(\"%d\",&n)*n){\n\t\thhh=0;left=0;\n\t\tfor(i=0;i<5;i++)max[i]=0;\n\n\t\tfor(;n>0;n--){\n\n\t\t\tscanf(\"%d %d %d\",&d,&l,&x); x--;\n\t\t\tleft+=l;\n\n\t\t\tif(d==1){\n\t\t\t\tk=0;j=0;\n\t\t\t\tfor(i=0;i<l;i++){if(max[x+i]>k){k=max[x+i];j=x+i;}}\n\t\t\t\tfor(i=0;i<l;i++){max[x+i]=k+1;block[k][x+i]=1;}\n\t\t\t\tfrom=k;time=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tfor(i=0;i<l;i++)block[max[x]+i][x]=1;\n\t\t\t\tfrom=max[x];\n\t\t\t\tmax[x]+=l;\n\t\t\t\ttime=l;\n\t\t\t\tj=x;\n\t\t\t}\n\n\t\t\tif(hhh<max[j])hhh=max[j];\n\n\t\t\tfor(i=0;i<time;i++){\n\t\t\t\tif(block[from][0]==1 && block[from][1]==1 && block[from][2]==1 && block[from][3]==1 && block[from][4]==1){\n\t\t\t\t\tfor(j=0;j<5;j++){block[from][j]=0;}\n\t\t\t\t\tfor(k=from+1;k<hhh+1;k++){\n\t\t\t\t\t\tfor(j=0;j<5;j++){\n\t\t\t\t\t\t\tblock[k-1][j]=block[k][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tleft-=5;hhh--;\n\t\t\t\t}\n\t\t\t\telse from++;\n\t\t\t}\n\n\t\t\tfor(j=0;j<5;j++){\n\t\t\t\tfor(k=max[j];k>=0;k--){\n\t\t\t\t\tif(block[k][j]==1)break;\n\t\t\t\t}\n\t\t\t\tmax[j]=k+1;\n\t\t\t}\n\t\t}\n\n\t\tfor(i=0;i<hhh;i++){\n\t\t\tfor(j=0;j<5;j++){\n\t\t\t\tblock[i][j]=0;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",left);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nchar banmen[5000];\n\nconst int line_block_num[32]={\n\t0,\n\t1,\n\t1,2,\n\t1,2,2,3,\n\t1,2,2,3,2,3,3,4,\n\t1,2,2,3,2,3,3,4,2,3,3,4,3,4,4,5\n};\n\nint main(void) {\n\tint block_num;\n\tint i,j;\n\tint btype,blength,bpos;\n\tchar block;\n\tint nowpos;\n\tint result;\n\twhile(1) {\n\t\tscanf(\"%d\",&block_num);\n\t\tif(block_num==0)break;\n\t\tmemset(banmen,0,sizeof(banmen));\n\t\tfor(i=0;i<block_num;i++) {\n\t\t\tscanf(\"%d%d%d\",&btype,&blength,&bpos);\n\t\t\tif(btype==1) {\n\t\t\t\tblock=31>>(5-blength);\n\t\t\t\tblock<<=(4-(bpos-1))-(blength-1);\n\t\t\t} else {\n\t\t\t\tblock=1<<(4-(bpos-1));\n\t\t\t}\n\t\t\tfor(nowpos=1;nowpos<5000;nowpos++) {\n\t\t\t\tif(banmen[nowpos] & block)break;\n\t\t\t}\n\t\t\tif(btype==1) {\n\t\t\t\tbanmen[nowpos-1]|=block;\n\t\t\t} else {\n\t\t\t\tfor(j=0;j<blength;j++) {\n\t\t\t\t\tbanmen[nowpos-1-j]|=block;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(nowpos=5000-1;nowpos>=0;nowpos--) {\n\t\t\t\tif((banmen[nowpos] & 31)==31) {\n\t\t\t\t\tbanmen[nowpos]=0;\n\t\t\t\t\tfor(j=nowpos;j>0;j--) {\n\t\t\t\t\t\tbanmen[j]=banmen[j-1];\n\t\t\t\t\t}\n\t\t\t\t\tnowpos++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tresult=0;\n\t\tfor(i=0;i<5000;i++)result+=line_block_num[banmen[i]];\n\t\tprintf(\"%d\\n\",result);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#define H 999\nn,d,p,q,m[H];\nb,h;\nmain(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\tmemset(m,0,sizeof(m));\n\t\tfor(;n--;){\n\t\t\tscanf(\"%d%d%d\",&d,&p,&q);\n\t\t\tif(d==1)\n\t\t\t\tb=((1<<p)-1)<<q;\n\t\t\telse\n\t\t\t\tb=1<<q;\n\t\t\tfor(h=H-1;h>=0;h--)\n\t\t\t\tif(m[h]&b)\n\t\t\t\t\tbreak;\n\t\t\th++;\n\t\t\tif(d==1)\n\t\t\t\tp=1;\n\t\t\tfor(;p--;){\n\t\t\t\tm[h]|=b;\n\t\t\t\tif(m[h]==0x3e)\n\t\t\t\t\tmemmove(m+h,m+h+1,H-h-1);\n\t\t\t\telse\n\t\t\t\t\th++;\n\t\t\t}\n\t\t}\n\t\tp=0;\n\t\tfor(h=0;h<H;h++){\n\t\t\tfor(;q=-m[h]&m[h];m[h]-=q)\n\t\t\t\tp++;\n\t\t}\n\t\tprintf(\"%d\\n\",p);\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nint t[5005][5];\nint u[5005][5];\n\nvoid init(){\n  int i,j;\n  for(i=0;i<5005;i++){\n    for(j=0;j<5;j++){\n      if(i==0)t[i][j]=1;\n      else t[i][j]=0;\n    }\n  }\n}\n\nvoid Delete(){\n  int i,j;\n  for(i=0;i<5005;i++)\n    for(j=0;j<5;j++)\n      u[i][j]=t[i][j];\n  init();\n  \n  int H=1,cnt;\n  for(i=0;i<5005;i++){\n    cnt=0;\n    for(j=0;j<5;j++)cnt+=u[i][j];\n    if(cnt==5)continue;\n    for(j=0;j<5;j++)t[H][j]=u[i][j];\n    H++;\n  }\n}\n\nint check(int y,int x,int h,int w){\n  int i,j,flg=0;\n  \n  for(i=y;i<y+h;i++)\n    for(j=x;j<x+w;j++)\n      if(t[i][j]==1)flg=1;\n  \n  if(flg==0)return 0;\n\n  y++;\n  for(i=y;i<y+h;i++)\n    for(j=x;j<x+w;j++)\n      t[i][j]=1;\n  \n  return 1;\n}\n\nvoid Put(int pos,int h,int w){\n  int i;\n  for(i=5000;i>=0;i--)\n    if(check(i,pos,h,w)==1)break;\n}\n\nint main(){\n  int i,j;\n  int n,d,p,q,ans;\n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0)break;\n    \n    init();\n    for(i=0;i<n;i++){\n      scanf(\"%d %d %d\",&d,&p,&q);\n      q--;\n      if(d==1)Put(q,1,p);\n      else Put(q,p,1);\n      Delete();\n    }\n    \n    ans=0;\n    for(i=1;i<5005;i++)\n      for(j=0;j<5;j++)\n        ans+=t[i][j];\n    printf(\"%d\\n\",ans);\n  }\n      \n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tList<Boolean[]> list = new ArrayList<Boolean[]>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint a = scanner.nextInt();\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tif (a == 1) {\n\t\t\t\t\tint aa = -1;\n\t\t\t\t\tloop: for (int j = list.size() - 1; j >= 0; j--) {\n\t\t\t\t\t\tBoolean[] tmp = list.get(j);\n\t\t\t\t\t\tfor (int k = c; k < c + b; k++) {\n\t\t\t\t\t\t\tif (tmp[k]) {\n\t\t\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\taa = j;\n\n\t\t\t\t\t}\n\t\t\t\t\tif (aa == -1) {\n\t\t\t\t\t\tBoolean[] newMap = new Boolean[6];\n\t\t\t\t\t\tfor (int k = 0; k < 6; k++) {\n\t\t\t\t\t\t\tif (c <= k && k < c + b) {\n\t\t\t\t\t\t\t\tnewMap[k] = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnewMap[k] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.add(newMap);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tBoolean[] tmp = list.get(aa);\n\t\t\t\t\t\tfor (int k = c; k < c + b; k++) {\n\t\t\t\t\t\t\ttmp[k] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint bb = b;\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tfor (int j = list.size() - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (list.get(j)[c]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint cn = Math.max(list.size() - count, 0);\n\t\t\t\t\tfor (int j = cn; j < list.size() && j < cn + b; j++) {\n\t\t\t\t\t\tlist.get(j)[c] = true;\n\t\t\t\t\t\tbb--;\n\t\t\t\t\t}\n\t\t\t\t\tif (bb > 0) {\n\t\t\t\t\t\tfor (int j = 0; j < bb; j++) {\n\t\t\t\t\t\t\tBoolean[] boo = new Boolean[6];\n\t\t\t\t\t\t\tArrays.fill(boo, false);\n\t\t\t\t\t\t\tboo[c] = true;\n\t\t\t\t\t\t\tlist.add(boo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tfor (Iterator<Boolean[]> iterator = list.iterator(); iterator\n\t\t\t\t\t\t.hasNext();) {\n\t\t\t\t\tBoolean[] bools = iterator.next();\n\t\t\t\t\tint sum = 0;\n\t\t\t\t\tfor (Boolean bo : bools) {\n\t\t\t\t\t\tif (bo)\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t\tif (sum == 5)\n\t\t\t\t\t\titerator.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ret = 0;\n\t\t\tfor (Boolean[] ans : list) {\n\t\t\t\tfor (Boolean b : ans) {\n\t\t\t\t\tif (b) {\n\t\t\t\t\t\tret++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ret);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n;\n\tint[] d, p, q;\n\n\t// d:1¡C2c\n\t// p:1~5\n\t// q:¶[©ç1~5\n\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\td=new int[n];\n\t\t\tp=new int[n];\n\t\t\tq=new int[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\td[i]=sc.nextInt()-1;\n\t\t\t\tp[i]=sc.nextInt();\n\t\t\t\tq[i]=sc.nextInt()-1;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid solve(){\n\t\t// 1000ÂÈàCÅå·5\n\t\tint[][] a=new int[5000][5];\n\t\tfor(int k=0; k<n; k++){\n\t\t\t// ¶ãð(x,y)Æ·éD\n\t\t\tint[][] b=new int[p[k]][p[k]];\n\t\t\tfor(int i=0; i<p[k]; i++){\n\t\t\t\tb[i*d[k]][i*(1-d[k])]=1;\n\t\t\t}\n\t\t\tint x=q[k], y=0;\n\t\t\tfor(;; y++){\n\t\t\t\tboolean collision=false;\n\t\t\t\tfor(int j=0; j<p[k]; j++){\n\t\t\t\t\tfor(int i=0; i<p[k]; i++){\n\t\t\t\t\t\tif(b[j][i]==1){\n\t\t\t\t\t\t\tif(y+j>=a.length){\n\t\t\t\t\t\t\t\tcollision=true;\n\t\t\t\t\t\t\t}else if(a[y+j][x+i]==1){\n\t\t\t\t\t\t\t\tcollision=true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(collision){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ty--;\n\t\t\tfor(int j=0; j<p[k]; j++){\n\t\t\t\tfor(int i=0; i<p[k]; i++){\n\t\t\t\t\tif(b[j][i]==1){\n\t\t\t\t\t\ta[y+j][x+i]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int j=0; j<a.length; j++){\n\t\t\t\t// debug(a[j]);\n\t\t\t}\n\t\t\t// debug();\n\t\t}\n\n\t\tint ans=0;\n\t\tfor(int j=0; j<a.length; j++){\n\t\t\tint sum=a[j][0]+a[j][1]+a[j][2]+a[j][3]+a[j][4];\n\t\t\tans+=sum%5;\n\t\t}\n\t\tprintln(\"\"+ans);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.concurrent.LinkedBlockingDeque;\n\npublic class Main {\n\t\n\tpublic static int MAX = 5 * 1000 + 1;\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile (true) {\n\t\t\tfinal int n = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] data = new int[n][3];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < 3; j++){\n\t\t\t\t\tdata[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] map = new boolean[MAX+1][5];\n\t\t\t\n\t\t\tint height_ceil = 0;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfinal int dir = data[i][0];\n\t\t\t\tfinal int w_lenght = dir == 1 ? data[i][1] : 1;\n\t\t\t\tfinal int h_lenght = dir == 2 ? data[i][1] : 1;\n\t\t\t\tfinal int pos = data[i][2] - 1;\n\t\t\t\t\n\t\t\t\tint y = 0;\n\t\t\t\tLOOP:\n\t\t\t\tfor(int h = height_ceil - 1; h >= 0; h--){\n\t\t\t\t\tfor(int j = 0; j < w_lenght; j++){\n\t\t\t\t\t\tif(map[h][pos+j]){\n\t\t\t\t\t\t\ty = h + 1;\n\t\t\t\t\t\t\tbreak LOOP;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < h_lenght; j++){\n\t\t\t\t\tfor(int k = 0; k < w_lenght; k++){\n\t\t\t\t\t\tmap[y+j][pos+k] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\theight_ceil = Math.max(height_ceil, y + h_lenght);\n\t\t\t\t\n\t\t\t\tfor(int h = 0; h < height_ceil; h++){\n\t\t\t\t\tboolean flag = true;\n\t\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\t\tif(!map[h][j]){\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(flag){\n\t\t\t\t\t\tfor(int h_2 = h; h_2 < height_ceil; h_2++){\n\t\t\t\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\t\t\t\tmap[h_2][j] = map[h_2+1][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\th--;\n\t\t\t\t\t\theight_ceil--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\tfor(int h = height_ceil - 1; h >= 0; h--){\n\t\t\t\t\tfor(int j = 0; j < 5; j++){\n\t\t\t\t\t\tSystem.out.print(map[h][j] ? \"■\" : \" \");\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println();\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"------\");\n\t\t\t\t*/\n\t\t\t}\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tfor(boolean[] inner : map){\n\t\t\t\tfor(boolean in : inner){\n\t\t\t\t\t//System.out.print(in ? \"■\" : \" \");\n\t\t\t\t\tif(in){\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println();\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int[][] tetoris;\n    int[] height;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            tetoris = new int[5001][5];\n            height = new int[5];\n            Arrays.fill(height, -1);\n\n            int num = 1;\n            for(int i=0; i<n; i++){\n                int d = sc.nextInt();\n                int p = sc.nextInt();\n                int q = sc.nextInt()-1;\n                if(d==1){\n                    down(q, p, 1);\n                    num++;\n                }else{\n                    for(int j=0; j<p; j++){\n                        down(q, 1, 2);\n                        num++;\n                    }\n                }\n            }\n\n            int cnt = 0;\n            for(int i=0; i<5000; i++){\n                for(int j=0; j<5; j++){\n                    if(tetoris[i][j]>=1) cnt++;\n                }\n            }\n\n            System.out.println(cnt);\n        }\n    }\n\n    void down(int pos, int length, int num){\n        int maxHeight = height[pos];\n        for(int i=0; i<length; i++){\n            maxHeight = Math.max(maxHeight, height[pos+i]);\n        }\n        maxHeight++;\n        for(int i=0; i<length; i++){\n            tetoris[maxHeight][pos+i] = num;\n            height[pos+i] = maxHeight;\n        }\n\n        int maxH = 0;\n        for(int j=0; j<5; j++) maxH = Math.max(maxH, height[j]);\n\n        for(int i=0; i<=maxHeight; i++){\n            boolean boo = true;\n            for(int j=0; j<5; j++) if(tetoris[i][j]==0) boo = false;\n            \n            if(boo){\n                for(int j=i; j<=maxH+1; j++){\n                    for(int k=0; k<5; k++){\n                        tetoris[j][k] = tetoris[j+1][k];\n                    }\n                }\n                for(int j=0; j<5; j++){\n                    height[j]--;\n                    while(height[j]-1>=0 && tetoris[height[j]-1][j]==0) height[j]--;\n                }\n                maxHeight--;\n            }\n        }        \n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//TETORIS\npublic class Main{\n\n//\tstatic void p(boolean[][] m){\n//\t\tSystem.out.println();\n//\t\tfor(int i=10;i>=0;i--){\n//\t\t\tfor(int j=0;j<5;j++){\n//\t\t\t\tSystem.out.print(m[i][j]?\"1\":\"0\");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n//\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tboolean[][] m = new boolean[5000][5];\n\t\t\twhile(n--!=0){\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint q = sc.nextInt()-1;\n\t\t\t\tif(d==2){\n\t\t\t\t\tint k = 4999;\n\t\t\t\t\twhile(k>=0&&!m[k][q])k--;\n\t\t\t\t\tk++;\n\t\t\t\t\tfor(int i=k;i<k+p;i++)m[i][q]=true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint k = 4999;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tboolean f = true;\n\t\t\t\t\t\tif(k>=0){\n\t\t\t\t\t\t\tfor(int j=q;j<q+p;j++){\n\t\t\t\t\t\t\t\tif(m[k][j])f = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f||k==-1){\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\tfor(int j=q;j<q+p;j++)m[k][j]=true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean con = true;\n\t\t\t\tint k = 0;\n\t\t\t\twhile(k<5000&&con){\n\t\t\t\t\tcon = false;\n\t\t\t\t\tboolean t = true;\n\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\tif(m[k][j])con = true;\n\t\t\t\t\t\telse t = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(t){\n\t\t\t\t\t\tboolean f = true;\n\t\t\t\t\t\tint i = k;\n\t\t\t\t\t\twhile(i<5000&&f){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\t\t\tif(m[i][j])f = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(f){\n\t\t\t\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\t\t\t\tm[i][j] = m[i+1][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse k++;\n\t\t\t\t}\n//\t\t\t\tp(m);\n\t\t\t}\n\t\t\tint s = 0;\n\t\t\tfor(int i=0;i<5000;i++)for(int j=0;j<5;j++)s+=m[i][j]?1:0;\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tint h = 5*n+10;\n\t\t\tint[][] map = new int[h][5];\n\t\t\tint d, p, q, max, cnt;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td = sc.nextInt();\n\t\t\t\tp = sc.nextInt();\n\t\t\t\tq = sc.nextInt() - 1; \n\t\t\t\t\n\t\t\t\tif(d==1){\n\t\t\t\t\tmax = -1;\n\t\t\t\t\tfor(int j=q;j<q+p;j++){\n\t\t\t\t\t\tcnt = h-1;\n\t\t\t\t\t\twhile(map[cnt][j]==0){\n\t\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\t\tif(cnt==-1) break;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmax = Math.max(max, cnt);\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j=q;j<q+p;j++) map[max+1][j] = 1;\n\t\t\t\t}else{\n\t\t\t\t\tcnt = h-1;\n\t\t\t\t\twhile(map[cnt][q]==0){\n\t\t\t\t\t\tcnt--;\n\t\t\t\t\t\tif(cnt==-1) break;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j=cnt+1;j<cnt+1+p;j++) map[j][q] = 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tcnt = 0;\n\t\t\t\tfor(int j=0;j<h;j++){\n\t\t\t\t\tif(map[j][0]==1 && map[j][1]==1 && map[j][2]==1 && map[j][3]==1 && map[j][4]==1) continue;\n\t\t\t\t\tmap[cnt] = map[j];\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\tsum += map[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main {\n\tstatic boolean[][] map;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tmap = new boolean[5011][5];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint q = sc.nextInt();\n\t\t\t\t\n\t\t\t\tif(d == 1) {\n\t\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\t\tmap[5010][j + q -1] = true;\n\t\t\t\t\t}\n\t\t\t\t\tIN:for(int j = 5009; j >= 0; j--) {\n\t\t\t\t\t\tfor(int k = 0; k < p; k++) {\n\t\t\t\t\t\t\tif(map[j][k + q -1])break IN;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor(int k = 0; k < p; k++) {\n\t\t\t\t\t\t\tmap[j  ][k + q - 1] = true;\n\t\t\t\t\t\t\tmap[j+1][k + q - 1] = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\t\tmap[5010 - j][q-1] = true;\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j = 5010 - p; j >= 0; j--) {\n\t\t\t\t\t\tif(map[j][q-1]) break;\n\t\t\t\t\t\tmap[j][q-1] = true;\n\t\t\t\t\t\tmap[j + p][q-1] = false;\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\twhile(erase());\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < 5011; i++) {\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tif(map[i][j]) count++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tstatic boolean erase() {\n\t\tboolean ret = false;\n\t\tfor(int i = 0; i < 5010; i++) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tif(!map[i][j]) break;\n\t\t\t\tif(j == 4) {\n\t\t\t\t\tret = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tmap[i][k] = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(i != 5010) {\n\t\t\t\t\t\tfor(int l = i; l < 5009; l++)\n\t\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\t\tmap[l][k] = map[l+1][k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic void show() {\n\t\tfor(int i = 5; i >= 0; i--) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tSystem.out.print(\" \" + map[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main {\n\tstatic boolean[][] map;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tmap = new boolean[5011][5];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint q = sc.nextInt();\n\t\t\t\t\n\t\t\t\tif(d == 1) {\n\t\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\t\tmap[5010][j + q -1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\t\tmap[5010 - j][q-1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ta();\n\t\t\t\twhile(erase()) erase();\n\n\t\t\t\t//show();\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < 5011; i++) {\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tif(map[i][j]) count++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n\tstatic void a() {\n\t\tboolean ret = false;\n\t\tdo {\n\t\t\tret = false;\n\t\t\tfor(int i = 5010; i >= 1; i--) {\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tif(!map[i-1][j] && map[i][j]) {\n\t\t\t\t\t\tret = true;\n\t\t\t\t\t\tmap[i][j] = false;\n\t\t\t\t\t\tmap[i-1][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}while(ret);\n\t}\n\tstatic boolean erase() {\n\t\tboolean ret = false;\n\t\tfor(int i = 0; i < 5011; i++) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tif(!map[i][j]) break;\n\t\t\t\tif(j == 4) {\n\t\t\t\t\tret = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tmap[i][k] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic void show() {\n\t\tfor(int i = 5; i >= 0; i--) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tSystem.out.print(\" \" + map[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * @author yuichirw\n *\n */\nimport java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tstatic boolean[][] blocks;\n\tstatic Scanner sc = new Scanner(System.in);\n\t\n\tstatic boolean read() {\n\t\tint n, d, p, q, t, u;\n\t\tn = sc.nextInt();\n\t\tblocks = new boolean[10][7];\n\t\t\n\t\tif (n == 0) return false;\n\t\twhile(n-- > 0) {\n\t\t\td = sc.nextInt(); p = sc.nextInt(); q = sc.nextInt();\n\t\t\tif(d == 2) {\n\t\t\t\tfor(t = 9; t >= 0; t--) if(!blocks[t][q]) break;\n\t\t\t\tfor(int i = 0; i < p; i++) blocks[t-i][q] = true;\n\t\t\t} else {\n\t\t\t\tt = 9; u = 0;\n\t\t\t\tfor(int i = 0; i < p; i++) {\n\t\t\t\t\tfor(u = 9; u >= 0; u--) {\n\t\t\t\t\t\tif(!blocks[u][q+i]) break;\n\t\t\t\t\t}\n\t\t\t\t\tt = max(t, u);\n\t\t\t\t}\n\t\t\t\tfor(int i = 0; i < p; i++) blocks[t][q+i] = true;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tstatic int solve() {\n\t\tint ans;\n\t\tboolean tetris;\n\t\t\n\t\tans = 0;\n\t\tfor(int i = 0; i < 10; i++) {\n\t\t\ttetris = true;\n\t\t\tfor(int j = 1; j < 6; j++) {\n\t\t\t\tif(!blocks[i][j]) {\n\t\t\t\t\ttetris = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!tetris) {\n\t\t\t\tfor(int j = 1; j < 6; j++) {\n\t\t\t\t\tif(blocks[i][j]) ans++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ans;\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(read()) {\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main {\n\tstatic boolean[][] map;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tmap = new boolean[5011][5];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint q = sc.nextInt();\n\t\t\t\t\n\t\t\t\tif(d == 1) {\n\t\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\t\tmap[5010][j + q -1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\t\tmap[5010 - j][q-1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile(a() || erase());\n\n\t\t\t\t//show();\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < 5011; i++) {\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tif(map[i][j]) count++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n\tstatic boolean a() {\n\t\tboolean ret = false;\n\t\tfor(int i = 5010; i >= 1; i--) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tif(!map[i-1][j] && map[i][j]) {\n\t\t\t\t\tret = true;\n\t\t\t\t\tmap[i][j] = false;\n\t\t\t\t\tmap[i-1][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t\t\n\t}\n\tstatic boolean erase() {\n\t\tboolean ret = false;\n\t\tfor(int i = 0; i < 5011; i++) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tif(!map[i][j]) break;\n\t\t\t\tif(j == 4) {\n\t\t\t\t\tret = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tmap[i][k] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic void show() {\n\t\tfor(int i = 5; i >= 0; i--) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tSystem.out.print(\" \" + map[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int[][] tetoris;\n    int[] height;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            tetoris = new int[5001][5];\n            height = new int[5];\n            Arrays.fill(height, -1);\n\n            int num = 1;\n            for(int i=0; i<n; i++){\n                int d = sc.nextInt();\n                int p = sc.nextInt();\n                int q = sc.nextInt()-1;\n                if(d==1){\n                    down(q, p, 1);\n                    num++;\n                }else{\n                    for(int j=0; j<p; j++){\n                        down(q, 1, 2);\n                        num++;\n                    }\n                }\n            }\n\n            int cnt = 0;\n            for(int i=0; i<5000; i++){\n                for(int j=0; j<5; j++){\n                    if(tetoris[i][j]>=1) cnt++;\n                }\n            }\n\n            System.out.println(cnt);\n        }\n    }\n\n    void down(int pos, int length, int num){\n        int maxHeight = height[pos];\n        for(int i=0; i<length; i++){\n            maxHeight = Math.max(maxHeight, height[pos+i]);\n        }\n        maxHeight++;\n        for(int i=0; i<length; i++){\n            tetoris[maxHeight][pos+i] = num;\n            height[pos+i] = maxHeight;\n        }\n\n        for(int i=0; i<=maxHeight; i++){\n            boolean boo = true;\n            for(int j=0; j<5; j++){\n                if(tetoris[i][j]==0) boo = false;\n            }\n            if(boo){\n                int maxH = 0;\n                for(int j=0; j<5; j++) maxH = Math.max(maxH, height[j]);\n\n                for(int j=i; j<=maxH+1; j++){\n                    for(int k=0; k<5; k++){\n                        tetoris[j][k] = tetoris[j+1][k];\n                        if(j-1>=0 && tetoris[j][k]==2 && tetoris[j-1][k]==0){\n                            int idx = j-1;\n                            while(idx>=0 && tetoris[idx][k]==0){\n                                tetoris[idx][k] = 2;\n                                tetoris[idx+1][k] = 0;\n                                idx--;\n                            }\n                        }\n                    }\n                }\n                for(int j=0; j<5; j++) height[j]--;\n                maxHeight--;\n            }\n        }        \n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\t\n\t//1324 start\n\t\n\tint [][] field;\n\tint [] maxheight;\n\tint wid = 5;\n\tint height = 5000;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tfield = new int[height][wid];\n\t\t\tmaxheight = new int[wid];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint q = sc.nextInt();\n\t\t\t\tfall(d,p,q-1);\n\t\t\t\t//disp();\n\t\t\t}\n\t\t\tint ans = count();\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tprivate void disp() {\n\t\tfor(int i = height - 1; i >= 0; i--){\n\t\t\tfor(int j = 0; j < wid; j++){\n\t\t\t\tSystem.out.printf(\"%2d \",field[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tdebug(maxheight);\n\t\tSystem.out.println();\n\t\t\n\t}\n\tprivate void fall(int dir, int len, int pos) {\n\t\tif(dir == 1){\n\t\t\tint nowmaxheight = 0;\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tnowmaxheight = Math.max(maxheight[pos + i], nowmaxheight);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tfield[nowmaxheight][pos + i] = 1;\n\t\t\t\tmaxheight[pos + i] = nowmaxheight + 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tfield[maxheight[pos] + i][pos] = 1;\n\t\t\t}\n\t\t\tmaxheight[pos] += len;\n\t\t}\n\t\terase();\n\t}\n\tprivate void erase() {\n\t\tint nowmaxheight = 0;\n\t\tfor(int i = 0; i < wid; i++){\n\t\t\tnowmaxheight = Math.max(maxheight[i], nowmaxheight);\n\t\t}\n\t\tfor(int i = 0; i < nowmaxheight; i++){\n\t\t\tboolean flg = true;\n\t\t\tfor(int j = 0; j < wid; j++){\n\t\t\t\tif(field[i][j] == 0){\n\t\t\t\t\tflg = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg){\n\t\t\t\tfor(int j = 0; j < wid; j++){\n\t\t\t\t\tfield[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrays.fill(maxheight, 0);\n\t\tfor(int i = 0; i < wid; i++){\n\t\t\tint ind = 0;\n\t\t\tfor(int j = 0; j < height; j++){\n\t\t\t\tif(field[j][i] == -1){\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfield[ind++][i] = field[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(;ind < height; ind++){\n\t\t\t\tfield[ind][i] = 0;\n\t\t\t}\n\t\t\tfor(int j = height -1 ; j >= 0; j--){\n\t\t\t\tif(field[j][i] == 1){\n\t\t\t\t\tmaxheight[i] = j + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprivate int count() {\n\t\tint c = 0;\n\t\tfor(int i = 0; i < height; i++){\n\t\t\tfor(int j = 0; j < wid; j++){\n\t\t\t\tif(field[i][j] == 1){\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int[][] tetoris;\n    int[] height;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            tetoris = new int[5001][5];\n            height = new int[5];\n\n            int num = 1;\n            for(int i=0; i<n; i++){\n                int d = sc.nextInt();\n                int p = sc.nextInt();\n                int q = sc.nextInt()-1;\n                if(d==1) down(q, p);\n                else for(int j=0; j<p; j++) down(q, 1);\n            }\n\n            int cnt = 0;\n            for(int i=0; i<=5000; i++) for(int j=0; j<5; j++) if(tetoris[i][j]==1) cnt++;\n\n            System.out.println(cnt);\n        }\n    }\n\n    void down(int pos, int length){\n        int max = height[pos]+1;\n        for(int i=0; i<length; i++) max = Math.max(max, height[pos+i]+1);\n        \n        for(int i=0; i<length; i++){\n            tetoris[max][pos+i] = 1;\n            height[pos+i] = max;\n        }\n\n        int maxH = 0;\n        for(int j=0; j<5; j++) maxH = Math.max(maxH, height[j]);\n\n        for(int i=0; i<=max; i++){\n            boolean boo = true;\n            for(int j=0; j<5; j++) if(tetoris[i][j]==0) boo = false;\n            \n            if(boo){\n                for(int j=i; j<=maxH; j++) for(int k=0; k<5; k++) tetoris[j][k] = tetoris[j+1][k];\n\n                Arrays.fill(height, 0);\n                for(int j=0; j<5; j++){ \n                    for(int k=maxH; k>=0; k--){\n                        if(tetoris[k][j]==0) continue;\n                        height[j] = k;\n                        break;\n                    }\n                }\n                max--;\n            }\n        }        \n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int[][] tetoris;\n    int[] height;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            tetoris = new int[5001][5];\n            height = new int[5];\n            Arrays.fill(height, -1);\n\n            for(int i=0; i<n; i++){\n                int d = sc.nextInt();\n                int p = sc.nextInt();\n                int q = sc.nextInt()-1;\n                if(d==1) down(q, p);\n                else{\n                    for(int j=0; j<p; j++) down(q, 1);\n                }\n            }\n\n            int cnt = 0;\n            for(int i=0; i<5000; i++){\n                for(int j=0; j<5; j++){\n                    if(tetoris[i][j]==1) cnt++;\n                }\n            }\n\n            System.out.println(cnt);\n        }\n    }\n\n    void down(int pos, int length){\n        int maxHeight = height[pos];\n        for(int i=0; i<length; i++){\n            maxHeight = Math.max(maxHeight, height[pos+i]);\n        }\n        maxHeight++;\n        for(int i=0; i<length; i++){\n            tetoris[maxHeight][pos+i] = 1;\n            height[pos+i] = maxHeight;\n        }\n\n        for(int i=0; i<=maxHeight; i++){\n            boolean boo = true;\n            for(int j=0; j<5; j++){\n                if(tetoris[i][j]==0) boo = false;\n            }\n            if(boo){\n                int maxH = 0;\n                for(int j=0; j<5; j++) maxH = Math.max(maxH, height[j]);\n\n                for(int j=i; j<=maxH+1; j++){\n                    for(int k=0; k<5; k++){\n                        tetoris[j][k] = tetoris[j+1][k];\n                    }\n                }\n                for(int j=0; j<5; j++) height[j]--;\n                maxHeight--;\n            }\n        }        \n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int[][] tetoris;\n    int[] height;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            tetoris = new int[5001][5];\n            height = new int[5];\n\n            int num = 1;\n            for(int i=0; i<n; i++){\n                int d = sc.nextInt();\n                int p = sc.nextInt();\n                int q = sc.nextInt()-1;\n                if(d==1) down(q, p);\n                else for(int j=0; j<p; j++) down(q, 1);\n            }\n\n            int cnt = 0;\n            for(int i=0; i<5000; i++) for(int j=0; j<5; j++) if(tetoris[i][j]==1) cnt++;\n\n            System.out.println(cnt);\n        }\n    }\n\n    void down(int pos, int length){\n        int max = height[pos];\n        for(int i=0; i<length; i++) max = Math.max(max, height[pos+i]);\n        \n        max++;\n        for(int i=0; i<length; i++){\n            tetoris[max][pos+i] = 1;\n            height[pos+i] = max;\n        }\n\n        int maxH = 0;\n        for(int j=0; j<5; j++) maxH = Math.max(maxH, height[j]);\n\n        for(int i=0; i<=max; i++){\n            boolean boo = true;\n            for(int j=0; j<5; j++) if(tetoris[i][j]==0) boo = false;\n            \n            if(boo){\n                for(int j=i; j<=maxH; j++) for(int k=0; k<5; k++) tetoris[j][k] = tetoris[j+1][k];\n\n                Arrays.fill(height, 0);\n                for(int j=0; j<5; j++){ \n                    for(int k=maxH; k>=0; k--){\n                        if(tetoris[k][j]==0) continue;\n                        height[j] = k;\n                        break;\n                    }\n                }\n                \n                max--;\n            }\n        }        \n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\t\n\t//1324 start\n\t\n\tint [][] field;\n\tint [] maxheight;\n\tint wid = 5;\n\tint height = 10;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tfield = new int[height][wid];\n\t\t\tmaxheight = new int[wid];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint q = sc.nextInt();\n\t\t\t\tfall(d,p,q-1);\n\t\t\t\t//disp();\n\t\t\t}\n\t\t\tint ans = count();\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tprivate void disp() {\n\t\tfor(int i = height - 1; i >= 0; i--){\n\t\t\tfor(int j = 0; j < wid; j++){\n\t\t\t\tSystem.out.printf(\"%2d \",field[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tdebug(maxheight);\n\t\tSystem.out.println();\n\t\t\n\t}\n\tprivate void fall(int dir, int len, int pos) {\n\t\tif(dir == 1){\n\t\t\tint nowmaxheight = 0;\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tnowmaxheight = Math.max(maxheight[pos + i], nowmaxheight);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tfield[nowmaxheight][pos + i] = 1;\n\t\t\t\tmaxheight[pos + i] = nowmaxheight + 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tfield[maxheight[pos] + i][pos] = 1;\n\t\t\t}\n\t\t\tmaxheight[pos] += len;\n\t\t}\n\t\terase();\n\t}\n\tprivate void erase() {\n\t\tint nowmaxheight = 0;\n\t\tfor(int i = 0; i < wid; i++){\n\t\t\tnowmaxheight = Math.max(maxheight[i], nowmaxheight);\n\t\t}\n\t\tfor(int i = 0; i < nowmaxheight; i++){\n\t\t\tboolean flg = true;\n\t\t\tfor(int j = 0; j < wid; j++){\n\t\t\t\tif(field[i][j] == 0){\n\t\t\t\t\tflg = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg){\n\t\t\t\tfor(int j = 0; j < wid; j++){\n\t\t\t\t\tfield[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tArrays.fill(maxheight, 0);\n\t\tfor(int i = 0; i < wid; i++){\n\t\t\tint ind = 0;\n\t\t\tfor(int j = 0; j < height; j++){\n\t\t\t\tif(field[j][i] == -1){\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfield[ind++][i] = field[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(;ind < height; ind++){\n\t\t\t\tfield[ind][i] = 0;\n\t\t\t}\n\t\t\tfor(int j = height -1 ; j >= 0; j--){\n\t\t\t\tif(field[j][i] == 1){\n\t\t\t\t\tmaxheight[i] = j + 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprivate int count() {\n\t\tint c = 0;\n\t\tfor(int i = 0; i < height; i++){\n\t\t\tfor(int j = 0; j < wid; j++){\n\t\t\t\tif(field[i][j] == 1){\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn c;\n\t}\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int[][] tetoris;\n    int[] height;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            tetoris = new int[5001][5];\n            height = new int[5];\n            Arrays.fill(height, -1);\n\n            int num = 1;\n            for(int i=0; i<n; i++){\n                int d = sc.nextInt();\n                int p = sc.nextInt();\n                int q = sc.nextInt()-1;\n                if(d==1){\n                    down(q, p, 1);\n                    num++;\n                }else{\n                    for(int j=0; j<p; j++){\n                        down(q, 1, 2);\n                        num++;\n                    }\n                }\n                //System.out.println(Arrays.toString(height));\n            }\n\n            int cnt = 0;\n            for(int i=0; i<5000; i++){\n                for(int j=0; j<5; j++){\n                    if(tetoris[i][j]>=1) cnt++;\n                }\n            }\n\n            System.out.println(cnt);\n        }\n    }\n\n    void down(int pos, int length, int num){\n        int maxHeight = height[pos];\n        for(int i=0; i<length; i++){\n            maxHeight = Math.max(maxHeight, height[pos+i]);\n        }\n        maxHeight++;\n        for(int i=0; i<length; i++){\n            tetoris[maxHeight][pos+i] = num;\n            height[pos+i] = maxHeight;\n        }\n\n        int maxH = 0;\n        for(int j=0; j<5; j++) maxH = Math.max(maxH, height[j]);\n\n        for(int i=0; i<=maxHeight; i++){\n            boolean boo = true;\n            for(int j=0; j<5; j++) if(tetoris[i][j]==0) boo = false;\n            \n            if(boo){\n                for(int j=i; j<=maxH+1; j++){\n                    for(int k=0; k<5; k++){\n                        tetoris[j][k] = tetoris[j+1][k];\n                    }\n                }\n                for(int j=0; j<5; j++){\n                    height[j]--;\n                    while(height[j]-1>=0 && tetoris[height[j]-1][j]==0) height[j]--;\n                    if(height[j]==0 && tetoris[0][j]==0) height[j] = -1;\n                }\n                maxHeight--;\n            }\n        }        \n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int[][] tetoris;\n    int[] height;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            tetoris = new int[5001][5];\n            height = new int[5];\n\n            int num = 1;\n            for(int i=0; i<n; i++){\n                int d = sc.nextInt();\n                int p = sc.nextInt();\n                int q = sc.nextInt()-1;\n                if(d==1){\n                    down(q, p);\n                }else{\n                    for(int j=0; j<p; j++){\n                        down(q, 1);\n                    }\n                }\n            }\n\n            int cnt = 0;\n            for(int i=0; i<5000; i++){\n                for(int j=0; j<5; j++){\n                    if(tetoris[i][j]>=1) cnt++;\n                }\n            }\n\n            System.out.println(cnt);\n        }\n    }\n\n    void down(int pos, int length){\n        int maxHeight = height[pos];\n        for(int i=0; i<length; i++){\n            maxHeight = Math.max(maxHeight, height[pos+i]);\n        }\n        maxHeight++;\n        for(int i=0; i<length; i++){\n            tetoris[maxHeight][pos+i] = 1;\n            height[pos+i] = maxHeight;\n        }\n\n        int maxH = 0;\n        for(int j=0; j<5; j++) maxH = Math.max(maxH, height[j]);\n\n        for(int i=0; i<=maxHeight; i++){\n            boolean boo = true;\n            for(int j=0; j<5; j++) if(tetoris[i][j]==0) boo = false;\n            \n            if(boo){\n                for(int j=i; j<=maxH+1; j++){\n                    for(int k=0; k<5; k++){\n                        tetoris[j][k] = tetoris[j+1][k];\n                    }\n                }\n\n                Arrays.fill(height, -1);\n                for(int j=0; j<5; j++){\n                    for(int k=maxH; k>=0; k--){\n                        if(tetoris[k][j]!=0){\n                            height[j] = k;\n                            break;\n                        }\n                    }\n                }\n                maxHeight--;\n            }\n        }        \n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int[][] tetoris;\n    int[] height;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            tetoris = new int[5001][5];\n            height = new int[5];\n\n            int num = 1;\n            for(int i=0; i<n; i++){\n                int d = sc.nextInt();\n                int p = sc.nextInt();\n                int q = sc.nextInt()-1;\n                if(d==1){\n                    down(q, p);\n                }else{\n                    for(int j=0; j<p; j++){\n                        down(q, 1);\n                    }\n                }\n            }\n\n            int cnt = 0;\n            for(int i=0; i<5000; i++){\n                for(int j=0; j<5; j++){\n                    if(tetoris[i][j]>=1) cnt++;\n                }\n            }\n\n            System.out.println(cnt);\n        }\n    }\n\n    void down(int pos, int length){\n        int maxHeight = height[pos];\n        for(int i=0; i<length; i++){\n            maxHeight = Math.max(maxHeight, height[pos+i]);\n        }\n        maxHeight++;\n        for(int i=0; i<length; i++){\n            tetoris[maxHeight][pos+i] = 1;\n            height[pos+i] = maxHeight;\n        }\n\n        int maxH = 0;\n        for(int j=0; j<5; j++) maxH = Math.max(maxH, height[j]);\n\n        for(int i=0; i<=maxHeight; i++){\n            boolean boo = true;\n            for(int j=0; j<5; j++) if(tetoris[i][j]==0) boo = false;\n            \n            if(boo){\n                for(int j=i; j<=maxH+1; j++){\n                    for(int k=0; k<5; k++){\n                        tetoris[j][k] = tetoris[j+1][k];\n                    }\n                }\n\n                for(int j=0; j<5; j++){\n                    boolean booo = false;\n                    for(int k=maxH; k>=0; k--){\n                        if(tetoris[k][j]!=0){\n                            booo = true;\n                            height[j] = k;\n                            break;\n                        }\n                    }\n                    if(!booo) height[j] = 0;\n                }\n                maxHeight--;\n            }\n        }        \n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\t\n\t//1324 start\n\t\n\tint [][] field;\n\tint [] maxheight;\n\tint wid = 5;\n\tint height = 5000;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tfield = new int[height][wid];\n\t\t\tmaxheight = new int[wid];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint q = sc.nextInt();\n\t\t\t\tfall(d,p,q-1);\n\t\t\t\t//disp();\n\t\t\t}\n\t\t\tint ans = count();\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tprivate void disp() {\n\t\tfor(int i = height - 1; i >= 0; i--){\n\t\t\tfor(int j = 0; j < wid; j++){\n\t\t\t\tSystem.out.printf(\"%2d \",field[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t}\n\tprivate void fall(int dir, int len, int pos) {\n\t\tif(dir == 1){\n\t\t\tint nowmaxheight = 0;\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tnowmaxheight = Math.max(maxheight[pos + i], nowmaxheight);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tfield[nowmaxheight][pos + i] = 1;\n\t\t\t\tmaxheight[pos + i] = nowmaxheight + 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tfield[maxheight[pos] + i][pos] = 1;\n\t\t\t}\n\t\t\tmaxheight[pos] += len;\n\t\t}\n\t\terase();\n\t}\n\tprivate void erase() {\n\t\tint nowmaxheight = 0;\n\t\tfor(int i = 0; i < wid; i++){\n\t\t\tnowmaxheight = Math.max(maxheight[i], nowmaxheight);\n\t\t}\n\t\tfor(int i = 0; i < nowmaxheight; i++){\n\t\t\tboolean flg = true;\n\t\t\tfor(int j = 0; j < wid; j++){\n\t\t\t\tif(field[i][j] == 0){\n\t\t\t\t\tflg = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg){\n\t\t\t\tfor(int j = 0; j < wid; j++){\n\t\t\t\t\tmaxheight[j]--;\n\t\t\t\t\tfield[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < wid; i++){\n\t\t\tint ind = 0;\n\t\t\tfor(int j = 0; j < height; j++){\n\t\t\t\tif(field[j][i] == -1){\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfield[ind++][i] = field[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(;ind < height; ind++){\n\t\t\t\tfield[ind][i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tprivate int count() {\n\t\tint c = 0;\n\t\tfor(int i = 0; i < height; i++){\n\t\t\tint now = 0;\n\t\t\tfor(int j = 0; j < wid; j++){\n\t\t\t\tif(field[i][j] == 1){\n\t\t\t\t\tnow++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tc += now;\n\t\t}\n\t\treturn c;\n\t}\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tList<Boolean[]> list = new ArrayList<Boolean[]>();\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint a = scanner.nextInt();\n\t\t\t\tint b = scanner.nextInt();\n\t\t\t\tint c = scanner.nextInt();\n\t\t\t\tif (a == 1) {\n\t\t\t\t\tint aa = -1;\n\t\t\t\t\tloop: for (int j = list.size() - 1; j >= 0; j--) {\n\t\t\t\t\t\tBoolean[] tmp = list.get(j);\n\t\t\t\t\t\tfor (int k = c; k < c + b; k++) {\n\t\t\t\t\t\t\tif (tmp[k]) {\n\t\t\t\t\t\t\t\tbreak loop;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\taa = j;\n\n\t\t\t\t\t}\n\t\t\t\t\tif (aa == -1) {\n\t\t\t\t\t\tBoolean[] newMap = new Boolean[6];\n\t\t\t\t\t\tfor (int k = 0; k < 6; k++) {\n\t\t\t\t\t\t\tif (c <= k && k < c + b) {\n\t\t\t\t\t\t\t\tnewMap[k] = true;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnewMap[k] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tlist.add(newMap);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tBoolean[] tmp = list.get(aa);\n\t\t\t\t\t\tfor (int k = c; k < c + b; k++) {\n\t\t\t\t\t\t\ttmp[k] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tint bb = b;\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tfor (int j = list.size() - 1; j >= 0; j--) {\n\t\t\t\t\t\tif (list.get(j)[c]) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tint cn = Math.max(list.size() - count, 0);\n\t\t\t\t\tfor (int j = cn; j < list.size() && j < cn + b; j++) {\n\t\t\t\t\t\tlist.get(j)[c] = true;\n\t\t\t\t\t\tbb--;\n\t\t\t\t\t}\n\t\t\t\t\tif (bb > 0) {\n\t\t\t\t\t\tfor (int j = 0; j < bb; j++) {\n\t\t\t\t\t\t\tBoolean[] boo = new Boolean[6];\n\t\t\t\t\t\t\tArrays.fill(boo, false);\n\t\t\t\t\t\t\tboo[c] = true;\n\t\t\t\t\t\t\tlist.add(boo);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ret = 0;\n\t\t\tfor (Boolean[] ans : list) {\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (Boolean b : ans) {\n\t\t\t\t\tif (b) {\n\t\t\t\t\t\tsum++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret += (sum % 5);\n\t\t\t}\n\t\t\tSystem.out.println(ret);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main {\n\tstatic boolean[][] map;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tmap = new boolean[5011][5];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint q = sc.nextInt();\n\t\t\t\t\n\t\t\t\tif(d == 1) {\n\t\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\t\tmap[5010][j + q -1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\t\tmap[5010 - j][q-1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\twhile(a() || erase());\n\n\t\t\t\t//show();\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < 5011; i++) {\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tif(map[i][j]) count++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n\tstatic boolean a() {\n\t\tboolean ret = false;\n\t\tdo {\n\t\t\tret = false;\n\t\t\tfor(int i = 5010; i >= 1; i--) {\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tif(!map[i-1][j] && map[i][j]) {\n\t\t\t\t\t\tret = true;\n\t\t\t\t\t\tmap[i][j] = false;\n\t\t\t\t\t\tmap[i-1][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}while(ret);\n\t\treturn ret;\n\t\t\n\t}\n\tstatic boolean erase() {\n\t\tboolean ret = false;\n\t\tfor(int i = 0; i < 5011; i++) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tif(!map[i][j]) break;\n\t\t\t\tif(j == 4) {\n\t\t\t\t\tret = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tmap[i][k] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic void show() {\n\t\tfor(int i = 5; i >= 0; i--) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tSystem.out.print(\" \" + map[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int[][] tetoris;\n    int[] height;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            tetoris = new int[5001][5];\n            height = new int[5];\n            Arrays.fill(height, -1);\n\n            int num = 1;\n            for(int i=0; i<n; i++){\n                int d = sc.nextInt();\n                int p = sc.nextInt();\n                int q = sc.nextInt()-1;\n                if(d==1){\n                    down(q, p, 1);\n                    num++;\n                }else{\n                    for(int j=0; j<p; j++){\n                        down(q, 1, 2);\n                        num++;\n                    }\n                }\n                //System.out.println(Arrays.toString(height));\n            }\n\n            int cnt = 0;\n            for(int i=0; i<5000; i++){\n                for(int j=0; j<5; j++){\n                    if(tetoris[i][j]>=1) cnt++;\n                }\n            }\n\n            System.out.println(cnt);\n        }\n    }\n\n    void down(int pos, int length, int num){\n        int maxHeight = height[pos];\n        for(int i=0; i<length; i++){\n            maxHeight = Math.max(maxHeight, height[pos+i]);\n        }\n        maxHeight++;\n        for(int i=0; i<length; i++){\n            tetoris[maxHeight][pos+i] = num;\n            height[pos+i] = maxHeight;\n        }\n\n        int maxH = 0;\n        for(int j=0; j<5; j++) maxH = Math.max(maxH, height[j]);\n\n        for(int i=0; i<=maxHeight; i++){\n            boolean boo = true;\n            for(int j=0; j<5; j++) if(tetoris[i][j]==0) boo = false;\n            \n            if(boo){\n                for(int j=i; j<=maxH+1; j++){\n                    for(int k=0; k<5; k++){\n                        tetoris[j][k] = tetoris[j+1][k];\n                    }\n                }\n                for(int j=0; j<5; j++){\n                    height[j]--;\n                    while(height[j]-1>=0 && tetoris[height[j]][j]==0 && tetoris[height[j]-1][j]==0) height[j]--;\n                    if(height[j]==0 && tetoris[0][j]==0) height[j] = -1;\n                }\n                maxHeight--;\n            }\n        }        \n    }\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//TETORIS\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tboolean[][] m = new boolean[5000][5];\n\t\t\twhile(n--!=0){\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint q = sc.nextInt()-1;\n\t\t\t\tif(d==2){\n\t\t\t\t\tint k = 4999;\n\t\t\t\t\twhile(k>=0&&!m[k][q])k--;\n\t\t\t\t\tk++;\n\t\t\t\t\tfor(int i=k;i<k+p;i++)m[i][q]=true;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tint k = 4999;\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tboolean f = true;\n\t\t\t\t\t\tif(k>=0){\n\t\t\t\t\t\t\tfor(int j=q;j<q+p;j++){\n\t\t\t\t\t\t\t\tif(m[k][j])f = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(!f||k==-1){\n\t\t\t\t\t\t\tk++;\n\t\t\t\t\t\t\tfor(int j=q;j<q+p;j++)m[k][j]=true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tk--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tboolean con = true;\n\t\t\t\tint k = 0;\n\t\t\t\twhile(k<5000&&con){\n\t\t\t\t\tcon = false;\n\t\t\t\t\tboolean t = true;\n\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\tif(m[k][j])con = true;\n\t\t\t\t\t\telse t = false;\n\t\t\t\t\t}\n\t\t\t\t\tif(t){\n\t\t\t\t\t\tboolean f = true;\n\t\t\t\t\t\tint i = k;\n\t\t\t\t\t\twhile(i<5000&&f){\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\t\t\tif(m[i][j])f = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(f){\n\t\t\t\t\t\t\t\tfor(int j=0;j<5;j++){\n\t\t\t\t\t\t\t\t\tm[i][j] = m[i+1][j];\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ti++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse k++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint s = 0;\n\t\t\tfor(int i=0;i<5000;i++)for(int j=0;j<5;j++)s+=m[i][j]?1:0;\n\t\t\tSystem.out.println(s);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\t\n\t//1324 start\n\t\n\tint [][] field;\n\tint [] maxheight;\n\tint wid = 5;\n\tint height = 5000;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tfield = new int[height][wid];\n\t\t\tmaxheight = new int[wid];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint q = sc.nextInt();\n\t\t\t\tfall(d,p,q-1);\n\t\t\t\t//disp();\n\t\t\t}\n\t\t\tint ans = count();\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tprivate void disp() {\n\t\tfor(int i = height - 1; i >= 0; i--){\n\t\t\tfor(int j = 0; j < wid; j++){\n\t\t\t\tSystem.out.printf(\"%2d \",field[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t}\n\tprivate void fall(int dir, int len, int pos) {\n\t\tif(dir == 1){\n\t\t\tint nowmaxheight = 0;\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tnowmaxheight = Math.max(maxheight[pos + i], nowmaxheight);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tfield[nowmaxheight][pos + i] = 1;\n\t\t\t\tmaxheight[pos + i] = nowmaxheight + 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tfield[maxheight[pos] + i][pos] = 1;\n\t\t\t}\n\t\t\tmaxheight[pos] += len;\n\t\t}\n\t\terase();\n\t}\n\tprivate void erase() {\n\t\tint nowmaxheight = 0;\n\t\tfor(int i = 0; i < wid; i++){\n\t\t\tnowmaxheight = Math.max(maxheight[i], nowmaxheight);\n\t\t}\n\t\tfor(int i = 0; i < nowmaxheight; i++){\n\t\t\tboolean flg = true;\n\t\t\tfor(int j = 0; j < wid; j++){\n\t\t\t\tif(field[i][j] == 0){\n\t\t\t\t\tflg = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flg){\n\t\t\t\tfor(int j = 0; j < wid; j++){\n\t\t\t\t\tmaxheight[j]--;\n\t\t\t\t\tfield[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < wid; i++){\n\t\t\tint ind = 0;\n\t\t\tfor(int j = 0; j < height; j++){\n\t\t\t\tif(field[j][i] == -1){\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfield[ind++][i] = field[j][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(;ind < height; ind++){\n\t\t\t\tfield[ind][i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tprivate int count() {\n\t\tint c = 0;\n\t\tfor(int i = 0; i < height; i++){\n\t\t\tint now = 0;\n\t\t\tfor(int j = 0; j < wid; j++){\n\t\t\t\tif(field[i][j] == 1){\n\t\t\t\t\tnow++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(now == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tc += now;\n\t\t}\n\t\treturn c;\n\t}\n\tprivate void debug(Object... o) { System.out.println(\"debug = \" + Arrays.deepToString(o)); }\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main{\n\n    int[][] tetoris;\n    int[] height;\n\n    void solve(){\n        Scanner sc = new Scanner(System.in);\n\n        while(true){\n            int n = sc.nextInt();\n            if(n==0) break;\n\n            tetoris = new int[5001][5];\n            height = new int[5];\n            Arrays.fill(height, -1);\n\n            int num = 1;\n            for(int i=0; i<n; i++){\n                int d = sc.nextInt();\n                int p = sc.nextInt();\n                int q = sc.nextInt()-1;\n                if(d==1){\n                    down(q, p, 1);\n                    num++;\n                }else{\n                    for(int j=0; j<p; j++){\n                        down(q, 1, 2);\n                        num++;\n                    }\n                }\n            }\n\n            int cnt = 0;\n            for(int i=0; i<5000; i++){\n                for(int j=0; j<5; j++){\n                    if(tetoris[i][j]>=1) cnt++;\n                }\n            }\n\n            System.out.println(cnt);\n        }\n    }\n\n    void down(int pos, int length, int num){\n        int maxHeight = height[pos];\n        for(int i=0; i<length; i++){\n            maxHeight = Math.max(maxHeight, height[pos+i]);\n        }\n        maxHeight++;\n        for(int i=0; i<length; i++){\n            tetoris[maxHeight][pos+i] = num;\n            height[pos+i] = maxHeight;\n        }\n\n        int maxH = 0;\n        for(int j=0; j<5; j++) maxH = Math.max(maxH, height[j]);\n\n        for(int i=0; i<=maxHeight; i++){\n            boolean boo = true;\n            for(int j=0; j<5; j++) if(tetoris[i][j]==0) boo = false;\n            \n            if(boo){\n                for(int j=i; j<=maxH+1; j++){\n                    for(int k=0; k<5; k++){\n                        tetoris[j][k] = tetoris[j+1][k];\n                    }\n                }\n                for(int j=0; j<5; j++) height[j]--;\n                maxHeight--;\n            }\n        }        \n    }\n\n\n    public static void main(String[] args){\n        new Main().solve();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nclass Main {\n\tstatic boolean[][] map;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tmap = new boolean[5011][5];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tint p = sc.nextInt();\n\t\t\t\tint q = sc.nextInt();\n\t\t\t\t\n\t\t\t\tif(d == 1) {\n\t\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\t\tmap[5010][j + q -1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfor(int j = 0; j < p; j++) {\n\t\t\t\t\t\tmap[5010 - j][q-1] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ta();\n\t\t\t\twhile(erase()) a();\n\n\t\t\t\t//show();\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\t\n\t\t\tfor(int i = 0; i < 5011; i++) {\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tif(map[i][j]) count++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n\tstatic void a() {\n\t\tboolean ret = false;\n\t\tdo {\n\t\t\tret = false;\n\t\t\tfor(int i = 0; i < 5010; i++) {\n\t\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\t\tif(map[i+1][j] && !map[i][j]) {\n\t\t\t\t\t\tret = true;\n\t\t\t\t\t\tmap[i][j] = true;\n\t\t\t\t\t\tmap[i+1][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}while(ret);\n\t}\n\tstatic boolean erase() {\n\t\tboolean ret = false;\n\t\tfor(int i = 0; i < 5011; i++) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tif(!map[i][j]) break;\n\t\t\t\tif(j == 4) {\n\t\t\t\t\tret = true;\n\t\t\t\t\tfor(int k = 0; k < 5; k++) {\n\t\t\t\t\t\tmap[i][k] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n\tstatic void show() {\n\t\tfor(int i = 5; i >= 0; i--) {\n\t\t\tfor(int j = 0; j < 5; j++) {\n\t\t\t\tSystem.out.print(\" \" + map[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Hello\n{\n    static int BC;\n    public const int Height = 5000;\n\n    public static void Main()\n    {\n        while (true)\n        {\n            var n = int.Parse(Console.ReadLine().Trim());\n            if (n == 0) break;\n            BC = 0;\n            var map = new bool[5, Height];\n            for (int i = 0; i < n; i++)\n            {\n                string[] line = Console.ReadLine().Trim().Split(' ');\n                var d = int.Parse(line[0]);\n                var p = int.Parse(line[1]);\n                BC += p;\n                var q = int.Parse(line[2]) - 1;\n                if (d == 1) putH(map, p, q);\n                else putV(map, p, q);\n                var ret = eraseLine(map);\n                if (ret.Count() > 0)\n                    foreach (var x in ret) down(map, x);\n            }\n            Console.WriteLine(BC);\n        }\n    }\n    public static void down(bool[,] map, int a)\n    {\n        for (int i = a; i < Height - 1; i++)\n        {\n            map[0, i] = map[0, i + 1];\n            map[1, i] = map[1, i + 1];\n            map[2, i] = map[2, i + 1];\n            map[3, i] = map[3, i + 1];\n            map[4, i] = map[4, i + 1];\n        }\n    }\n    public static List<int> eraseLine(bool[,] map)\n    {\n        var ret = new List<int>();\n        var nexti = -1;\n        for (int i = 0; i < Height; i++)\n            if (canErase(map, i))\n            {\n                nexti = i + 1;\n                ret.Add(i);\n                map[0, i] = false; map[1, i] = false; map[2, i] = false; map[3, i] = false; map[4, i] = false;\n                BC -= 5;\n                break;\n            }\n        if (nexti != -1)\n            for (int i = nexti; i <= nexti + 4; i++)\n                if (canErase(map, i)) { map[0, i] = false; map[1, i] = false; map[2, i] = false; map[3, i] = false; map[4, i] = false; ret.Add(i); BC -= 5; }\n        ret.Reverse();\n        return ret;\n    }\n    public static bool canErase(bool[,] map, int a)\n    {\n        return map[0, a] && map[1, a] && map[2, a] && map[3, a] && map[4, a];\n    }\n    public static void putH(bool[,] map, int p, int q)\n    {\n        var hmax = -1;\n        for (int i = q; i < p + q; i++)\n            for (int j = Height - 1; j >= 0; j--)\n                if (map[i, j]) hmax = Math.Max(hmax, j);\n        for (int i = q; i < p + q; i++)\n            map[i, hmax + 1] = true;\n    }\n    public static void putV(bool[,] map, int p, int q)\n    {\n        var hmax = -1;\n        for (int i = Height - 1; i >= 0; i--)\n            if (map[q, i]) { hmax = i; break; }\n        for (int i = 0; i < p; i++)\n            map[q, hmax + 1 + i] = true;\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing System.Collections.Generic;\nusing System;\n\npublic class Hello\n{\n    static int BC;\n    public const int Height = 5000;\n\n    public static void Main()\n    {\n        while (true)\n        {\n            var n = int.Parse(Console.ReadLine().Trim());\n            if (n == 0) break;\n            BC = 0;\n            var map = new bool[5, Height];\n            for (int i = 0; i < n; i++)\n            {\n                string[] line = Console.ReadLine().Trim().Split(' ');\n                var d = int.Parse(line[0]);\n                var p = int.Parse(line[1]);\n                BC += p;\n                var q = int.Parse(line[2]) - 1;\n                if (d == 1) putH(map, p, q);\n                else putV(map, p, q);\n                var ret = eraseLine(map);\n                if (ret.Count() > 0)\n                    foreach (var x in ret) down(map, x);\n            }\n            Console.WriteLine(BC);\n        }\n    }\n    public static void down(bool[,] map, int a)\n    {\n        for (int i = 0; i < 5; i++)\n            for (int j = a; j < Height - 1; j++)\n                map[i, j] = map[i, j + 1];\n    }\n    public static List<int> eraseLine(bool[,] map)\n    {\n        var ret = new List<int>();\n        var nexti = -1;\n        for (int i = 0; i < Height; i++)\n            if (canErase(map, i))\n            {\n                nexti = i + 1;\n                ret.Add(i);\n                map[0, i] = false; map[1, i] = false; map[2, i] = false; map[3, i] = false; map[4, i] = false;\n                BC -= 5;\n                break;\n            }\n        if (nexti != -1)\n            for (int i = nexti; i <= nexti + 4; i++)\n                if (canErase(map, i)) { map[0, i] = false; map[1, i] = false; map[2, i] = false; map[3, i] = false; map[4, i] = false; ret.Add(i); BC -= 5; }\n        ret.Reverse();\n        return ret;\n    }\n    public static bool canErase(bool[,] map, int a)\n    {\n        return map[0, a] && map[1, a] && map[2, a] && map[3, a] && map[4, a];\n    }\n    public static void putH(bool[,] map, int p, int q)\n    {\n        var hmax = -1;\n        for (int i = q; i < p + q; i++)\n            for (int j = Height - 1; j >= 0; j--)\n                if (map[i, j]) hmax = Math.Max(hmax, j);\n        for (int i = q; i < p + q; i++)\n            map[i, hmax + 1] = true;\n    }\n    public static void putV(bool[,] map, int p, int q)\n    {\n        var hmax = -1;\n        for (int i = Height - 1; i >= 0; i--)\n            if (map[q, i]) { hmax = i; break; }\n        for (int i = 0; i < p; i++)\n            map[q, hmax + 1 + i] = true;\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0178\n{\n    public class Program\n\n    {\n        enum direction { Horizontal, Vertical }\n        static public List<int> field;\n        public const int COLCNT = 5;\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int n = RInt(); if (n == 0) break;\n\n                field = new List<int>();\n                field.Add((int)Math.Pow(2, COLCNT) - 1); //Sentinel\n\n                for (int k = 0 ; k < n ; k++)\n                {\n                    int[] items = RIntAr();\n                    direction dir = (direction)(items[0] - 1);\n                    int blockLength = items[1];\n                    int pos = items[2] - 1;\n\n                    int num = 0;\n                    int h = 0;\n\n                    switch (dir)\n                    {\n                        case direction.Horizontal:\n                            num = ((int)Math.Pow(2, blockLength) - 1) << pos;\n                            h = 1;\n                            break;\n                        case direction.Vertical:\n                            num = 1 << pos;\n                            h = blockLength;\n                            break;\n                    }\n\n                    for (int i = field.Count - 1 ; i >= 0 ; i--)\n                    {\n                        if ((num & field[i]) != 0)\n                        {\n                            int maxIdx = field.Count - 1;\n                            for (int j = i + h ; j > i ; j--) if (j > maxIdx) field.Add(num); else field[j] |= num;　//put\n                            for (int j = i + h ; j > i ; j--) if (field[j] == (int)Math.Pow(2, COLCNT) - 1) field.RemoveAt(j); //erase\n                            break;\n                        }\n                    }\n                }\n\n                Console.WriteLine(field.Skip(1).Sum(x => BitCount(x)));\n            }\n        }\n\n        public static int BitCount(int bits)\n        {\n            bits = (bits & 0x55555555) + (bits >> 1 & 0x55555555);    //  2bitごとに計算\n            bits = (bits & 0x33333333) + (bits >> 2 & 0x33333333);    //  4bitごとに計算\n            bits = (bits & 0x0f0f0f0f) + (bits >> 4 & 0x0f0f0f0f);    //  8bitごとに計算\n            bits = (bits & 0x00ff00ff) + (bits >> 8 & 0x00ff00ff);    //  16ビットごとに計算   \n            return (bits & 0x0000ffff) + (bits >> 16);    //  32ビット分を計算   \n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n}\n\n"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr = input.trim().split(\"\\n\");\nwhile (true) {\n   var n = arr.shift() - 0;\n   if (n == 0) break;\n   var base=[\"\",\"\",\"\",\"\",\"\"];\n   for(var i=0;i<n;i++){\n      var [d,p,q]=arr.shift().split(\" \").map(Number);\n      q--;\n      if(d==1){\n         var max=0;\n         for(var j=0;j<p;j++)max=Math.max(max,base[q+j].length);\n         for(var j=0;j<p;j++){\n            while(base[q+j].length<max)base[q+j]+=\"0\";\n            base[q+j]+=\"1\";\n         }\n      }else if(d==2){\n         for(var j=0;j<p;j++)base[q]+=\"1\";\n      }\n   }\n   var max=0;\n   for(var i=0;i<5;i++)max=Math.max(max,base[i].length);\n   for(var i=0;i<5;i++){\n      while(base[i].length<max)base[i]+=\"0\";\n   }\n   var cnt=0;\n   for(var i=0;i<max;i++){\n      var str=base.map(v=> v[i]).join(\"\");\n      str=str.replace(\"11111\",\"\").replace(/0/g,\"\");\n      cnt+=str.length;\n   }\n   console.log(cnt);\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "while(n=gets.to_i)>0\ns=[]\nn.times{d,p,q=gets.split.map &:to_i\nw=d<2?p:1\ny=(s.rindex{|l|l[q-1,w].any?}||-1)+1\n(y..(d<2?y:y+p-1)).map{|i|(s[i]||=[$,]*5)[q-1,w]=[1]*w}\ns-=[[1]*5]}\np s.flatten.count 1\nend"
  },
  {
    "language": "Ruby",
    "code": "## constant\n\nALL_ONE = [1] * 5\n\n### main\n\nwhile true\n  n = gets.strip.to_i\n  break if n == 0\n\n  bds = []\n\n  n.times.each do\n    d, p, q = gets.strip.split(' ').map{|s| s.to_i}\n\n    if d == 1\n      w = p\n      h = 1\n    else\n      w = 1\n      h = p\n    end\n\n    x = q - 1\n    y = bds.length\n\n    while y > 0\n      hl = bds[y - 1]\n      tf = true\n\n      for i in (0...w)\n        if hl[x + i] == 1\n          tf = false\n          break\n        end\n      end\n\n      break if ! tf\n\n      y -= 1\n    end\n\n    for y0 in (y...(y + h))\n      if y0 >= bds.length\n        bds << ([0] * 5)\n      end\n\n      for x0 in (x...(x + w))\n        bds[y0][x0] = 1\n      end\n    end\n    #p bds\n    #p '---'\n\n    bds.delete(ALL_ONE)\n  end\n  #p bds\n\n  puts bds.flatten.select{|i| i == 1}.length\nend"
  },
  {
    "language": "Ruby",
    "code": "W = 5\n\nuntil (n = $<.gets.to_i).zero?\n  field = []\n  \n  n.times do\n    d, p, q = $<.gets.split.map(&:to_i)\n    if d == 1\n      block = ((1 << p) - 1) << W + 1 - p - q\n      if field.empty?\n        field = [block]\n      else\n        i = field.size - 1\n        while (field[i] & block).zero?\n          i -= 1\n          break if i < 0\n        end\n        i += 1\n        field[i] ||= 0\n        field[i] |= block\n      end\n    else\n      block = 1 << W - q\n      if field.empty?\n        p.times {field.push(block)}\n      else\n        i = field.size - 1\n        while (field[i] & block).zero?\n          i -= 1\n          break if i < 0\n        end\n        p.times do\n          i += 1\n          field[i] ||= 0\n          field[i] |= block\n        end\n      end\n    end\n    \n    field.delete_at(i) while (i = field.index(31))\n  end\n  \n  puts field.map {|a| a.to_s(2)}.join.count(\"1\") \nend\n"
  },
  {
    "language": "Ruby",
    "code": "(s=[]\n$_.to_i.times{d,p,q=gets.split.map &:to_i\nw=d<2?p:1\ny=s.rindex{|l|l[q-1,w].any?}||-1\n(y+1..(d<2?y+1:y+p)).map{|i|(s[i]||=[$,]*5)[q-1,w]=[1]*w}\ns-=[[1]*5]}\np s.flatten.count 1)while gets[0]>?0"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"os\"\n\t\"strconv\"\n\t\"strings\"\n\t\"fmt\"\n)\n\nvar scanner = bufio.NewScanner(os.Stdin)\nvar (\n\tdat = [5000][5]int{}\n\tm = [5]int{}\n)\n\nfunc main() {\n\tfor scanner.Scan() {\n\t\tfor i := range dat {\n\t\t\tfor j := range dat[i] {\n\t\t\t\tdat[i][j] = 0\n\t\t\t}\n\t\t}\n\t\tfor i := range m {\n\t\t\tm[i] = 0\n\t\t}\n\t\tn, _ := strconv.Atoi(scanner.Text())\n\t\tif n == 0 {\n\t\t\tbreak\n\t\t}\n\t\tcount := 0\n\t\tfor i := 0; i < n; i++ {\n\t\t\tscanner.Scan()\n\t\t\tbuf := strings.Split(scanner.Text(), \" \")\n\t\t\td, _ := strconv.Atoi(buf[0])\n\t\t\tp, _ := strconv.Atoi(buf[1])\n\t\t\tq, _ := strconv.Atoi(buf[2])\n\t\t\tq--\n\t\t\tcount += p\n\t\t\tif d == 2 {\n\t\t\t\tfor j := 0; j < p; j++ {\n\t\t\t\t\tdat[m[q]][q] = 1\n\t\t\t\t\tok := true\n\t\t\t\t\tfor k := 0; k < 5; k++ {\n\t\t\t\t\t\tif dat[m[q]][k] == 0 {\n\t\t\t\t\t\t\tok = false\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ok {\n\t\t\t\t\t\tfor k := 0; k < 5; k++ {\n\t\t\t\t\t\t\tdat[m[q]][k] = 0\n\t\t\t\t\t\t\tfor l := m[q]; l < 4999; l++ {\n\t\t\t\t\t\t\t\tdat[l][k] = dat[l+1][k]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor l := 4999; l >= 0; l-- {\n\t\t\t\t\t\t\t\tif dat[l][k] != 0 {\n\t\t\t\t\t\t\t\t\tm[k] = l+1\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif l == 0 {\n\t\t\t\t\t\t\t\t\tm[k] = 0\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount -= 5\n\t\t\t\t\t} else {\n\t\t\t\t\t\tm[q]++\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\th := 0\n\t\t\t\tfor i := 0; i < p; i++ {\n\t\t\t\t\th = max(h, m[i+q])\n\t\t\t\t}\n\t\t\t\tfor i := 0; i < p; i++ {\n\t\t\t\t\tdat[h][i+q] = 1\n\t\t\t\t}\n\t\t\t\tfor i := 0; i < p; i++ {\n\t\t\t\t\tm[i+q] = h+1\n\t\t\t\t}\n\t\t\t\tok := true\n\t\t\t\tfor j := 0; j < 5; j++ {\n\t\t\t\t\tif dat[h][j] == 0 {\n\t\t\t\t\t\tok = false\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif ok {\n\t\t\t\t\tfor j := 0; j < 5; j++ {\n\t\t\t\t\t\tdat[h][j] = 0\n\t\t\t\t\t\tfor k := h; k < 4999; k++ {\n\t\t\t\t\t\t\tdat[k][j]=dat[k+1][j]\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor k := 4999; k>= 0; k-- {\n\t\t\t\t\t\t\tif dat[k][j] != 0 {\n\t\t\t\t\t\t\t\tm[j]=k+1\n\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif k == 0 {\n\t\t\t\t\t\t\t\tm[j] = 0\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tcount -= 5\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfmt.Println(count)\n\t}\n}\n\nfunc max(a, b int) int {\n\tif a < b {\n\t\treturn b\n\t}\n\treturn a\n}\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.algorithm;\n\nconst int Y = 5001;\n\nbool[5][Y+1] board;\nint n, d, p, q, count;\n\nvoid main(){\n\twhile (readf(\"%d\\n\", &n), n) {\n\t\tforeach (i; 0..Y) board[i] = false;\n\t\tboard[Y] = true;\n\t\tforeach (i; 0..n) {\n\t\t\treadf(\"%d %d %d\\n\", &d, &p, &q);\n\t\t\tq--;\n\t\t\tif (d == 1) putH();\n\t\t\telse putV();\n\t\t\tdel(Y-1);\n\t\t}\n\t\tcount = 0;\n\t\tforeach (y; 0..Y)\n\t\t\tforeach (x; 0..5)\n\t\t\t\tif(board[y][x]) count++;\n\t\twriteln(count);\n\t}\n}\n\nvoid putH(){\n\tint t = 0;\n\tbool f;\n\twhile (1) {\n\t\tf = false;\n\t\tforeach (i; 0..p) \n\t\t\tif (board[t][i+q]) f = true;\n\t\tif(f) break;\n\t\tt++;\n\t}\n\tforeach (i; 0..p) board[t-1][i+q] = true;\n}\n\nvoid putV(){\n\tint t = 0;\n\twhile (!board[t][q]) t++;\n\tforeach (i; 0..p) board[t-i-1][q] = true;\n}\n\nvoid del(int h){\n\tif (h < 0) return;\n\tauto range = array(filter!(\"a == true\")(board[h][]));\n\tif (range.length == 0) return;\n\tif (range.length == 5) {\n\t\tfor (int y = h; y > 0; y--) board[y] = board[y-1];\n\t\th++;\n\t}\n\tdel(h-1);\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.algorithm;\n\nvoid main() {\n    int n; \n    while (readf(\"%d\\n\", &n), n) {\n        int[] L = new int[5];\n        foreach (_; 0 .. n) {\n            int d, p, q; readf(\"%d %d %d\\n\", &d, &p, &q);\n            if (d == 1) {\n                foreach (i; q - 1 .. q - 1 + p) {\n                    L[i]++;\n                }\n            } else {\n                L[q - 1] += p;\n            }\n            while (L.all!\"a > 0\") {\n                foreach (ref l; L) {\n                    l--;\n                }\n            }\n        }\n        L.reduce!\"a + b\".writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\n\nconst int Y = 5001;\n\nint[5][Y+1] board;\nint n, d, p, q, count, height;\n\nvoid main(){\n\twhile (readf(\"%d\\n\", &n), n) {\n\t\tforeach (i; 0..Y) board[i] = 0;\n\t\tboard[Y] = 1;\n\t\tforeach (i; 0..n) {\n\t\t\treadf(\"%d %d %d\\n\", &d, &p, &q);\n\t\t\tq--;\n\t\t\tif (d == 1) putH();\n\t\t\telse putV();\n\t\t\tdel(Y-1);\n\t\t}\n\t\tcount = 0;\n\t\tforeach (y; 0..Y)\n\t\t\tforeach (x; 0..5)\n\t\t\t\tif(board[y][x]) count++;\n\t\twriteln(count);\n\t}\n}\n\nvoid putH(){\n\tint t = 0;\n\tbool f;\n\twhile (1) {\n\t\tf = false;\n\t\tforeach (i; 0..p) \n\t\t\tif (board[t][i+q]) f = true;\n\t\tif(f) break;\n\t\tt++;\n\t}\n\tforeach (i; 0..p) board[t-1][i+q] = 1;\n}\n\nvoid putV(){\n\tint t = 0;\n\twhile (!board[t][q]) t++;\n\tforeach (i; 0..p) board[t-i-1][q] = 1;\n}\n\nvoid del(int h){\n\tif (h < 0) return;\n\tint sum = 0;\n\tforeach(i; board[h]) sum += i;\n\tif (sum == 0) return;\n\tif (sum == 5) {\n\t\tfor (int y = h; y > 0; y--) {\n\t\t\tsum = 0;\n\t\t\tforeach(i; board[h]) sum += i;\n\t\t\tif (!sum) break;\n\t\t\tboard[y] = board[y-1];\n\t\t}\n\t\th++;\n\t}\n\tdel(h-1);\n}"
  },
  {
    "language": "D",
    "code": "import std.algorithm;\nimport std.array;\nimport std.ascii;\nimport std.bigint;\nimport std.complex;\nimport std.container;\nimport std.conv;\nimport std.functional;\nimport std.math;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nauto readInts() {\n\treturn array(map!(to!int)(readln().strip().split()));\n}\nauto readInt() {\n\treturn readInts()[0];\n}\nauto readLongs() {\n\treturn array(map!(to!long)(readln().strip().split()));\n}\nauto readLong() {\n\treturn readLongs()[0];\n}\n\nvoid readlnTo(T...)(ref T t) {\n    auto s = readln().split();\n    assert(s.length == t.length);\n    foreach(ref ti; t) {\n        ti = s[0].to!(typeof(ti));\n        s = s[1..$];\n    }\n}\n\nconst real eps = 1e-10;\n\nconst long p = 1_000_000_000 + 7;\n\n\nvoid main(){\n    while(true) {\n        auto n = readInt();\n        if(n == 0) {\n            return;\n        }\n        auto block = new bool[][](5001, 5);\n        foreach(i; iota(n)) {\n            int d, p, q;\n            readlnTo(d, p, q);\n            --q;\n            int l = -1;\n            foreach(j; iota(q, q + (d == 1 ? p: 1))) {\n                foreach(k; iota(5000)) {\n                    if(block[k][j]) {\n                        l = max(l, k);\n                    }\n                }\n            }\n            foreach(j; iota(p)) {\n                if(d == 1) {\n                    block[l+1][q+j] = true;\n                } else {\n                    block[l+1+j][q] = true;\n                }\n            }\n            foreach(j; iota(p).retro) {\n                if(block[l+1+j].all!(x => x)) {\n                    foreach(k; iota(l+1+j, 5000)) {\n                        foreach(m; iota(5)) {\n                            block[k][m] = block[k+1][m];\n                        }\n                    }\n                }\n            }\n        }\n        writeln(block.map!(a => a.count!(x => x)).sum);\n    }\n}"
  },
  {
    "language": "Python",
    "code": "def v_block():\n    block.insert(0, [' ']*5)\n    for l, line in enumerate(block):\n        if line[q-1:q+p-1] != [' ']*p:\n            break\n    else:\n        l += 1\n    block[l-1][q-1:q+p-1] = ['*']*p\n    return delete()\n\n\ndef h_block():\n    for _p in range(p):\n        block.insert(0, [' ']*5)\n    for l, line in enumerate(block):\n        if line[q-1] == '*':\n            break\n    else:\n        l += 1\n    for _l in range(l-1, l-p-1, -1):\n        block[_l][q-1] = '*'\n    return delete()\n                \n\ndef delete():\n    l = 0\n    while True:\n        if block[l] == [' ']*5 or block[l] == ['*']*5:\n            del block[l]\n        else:\n            l += 1\n        if len(block) == l:\n            return\n\n\ndef count():\n    x = 0\n    for line in block:\n        for b in line:\n            if b == '*':\n                x += 1\n    else:\n        print(x)\n\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    block = [[' ']*5]\n    for i in range(n):\n        d, p, q = map(int, input().split())\n        if d == 1:\n            v_block()\n        else:\n            h_block()\n    else:\n        count()"
  },
  {
    "language": "Python",
    "code": "#! /usr/bin/python\n# -*- coding: utf-8 -*-\n\nYOKO = 1\nTATE = 2\n\ndef main():\n    # input\n    while True:\n        N = int(raw_input())\n        if N == 0:\n            break\n\n        data = []\n        for x in xrange(N):\n            data.append(map(int, raw_input().split()))\n\n        print(restBlock(data))\n\ndef restBlock(data):\n    state = []\n    for x in data:\n        if x[0] == YOKO:\n            block = makeYokoBlock(x)\n            state = yokoBlock(state, block)\n        else:\n            blocks = makeTateBlocks(x)\n            state = tateBlock(state, blocks)\n\n        state = clearTetoris(state)\n    return countRestBlock(state)\n\ndef clearTetoris(state):\n    return filter(lambda x:sum(x) < 5, state)\n\n# Blockが重なっていたらFalse\ndef checkBlock(a, b):\n    if max([sum(x) for x in zip(a, b)]) > 1:\n        return False\n    else:\n        return True\n\ndef countRestBlock(state):\n    return sum([sum(x) for x in state])\n\ndef tateBlock(state, blocks):\n    for x in blocks:\n        state = yokoBlock(state, x)\n    return state\n\ndef makeTateBlocks(block_data):\n    sckellton = [0, 0, 0, 0, 0]\n    i = block_data[2] - 1\n    sckellton[i] = 1\n    return [sckellton for x in xrange(block_data[1])]\n\ndef yokoBlock(state, block):\n\n    if len(state) == 0:\n        state.append(block)\n        return state\n\n    for i, x in enumerate(state[::-1]):\n        if checkBlock(x, block):\n            pass\n        else:\n            if i == 0:\n                state.append(block)\n            else:\n                state[-i] = [sum(x) for x in zip(state[-i], block)]\n            break\n    else:\n        state[0] = [sum(x) for x in zip(state[0], block)]\n\n    return state\n\ndef makeYokoBlock(block_data):\n    block = [0, 0, 0, 0, 0]\n    i = block_data[2]\n    j = block_data[1]\n    for x in xrange(j):\n        block[i - 1 + x] = 1\n\n    return block\n\ndef test():\n    data = [[1,4,1],\n            [1,3,1],\n            [2,2,4],\n            [2,3,5]]\n\n    # print(makeYokoBlock([1,3,2]))\n    # print(checkBlock([1, 1, 0, 0, 0], [0, 0, 1, 1, 0]))\n    # state = [[1, 1, 1, 1, 0], [1, 1, 0, 0, 0], [1, 1, 0, 0, 0]]\n    # print(yokoBlock(state, [1, 0, 1, 0, 1]))\n    # state = []\n    # print(yokoBlock(state, [1, 0, 1, 0, 1]))\n    # state = [[1, 1, 1, 1, 0]]\n    # print(yokoBlock(state, [1, 0, 1, 0, 1]))\n    # state = [[1, 1, 1, 1, 1], [1, 1, 0, 0, 0], [1, 1, 1, 1, 1]]\n    # print(clearTetoris(state))\n    # print(makeTateBlocks([2, 3, 2]))\n    # state = [[1, 1, 0, 1, 1], [1, 1, 0, 0, 0], [1, 1, 0, 1, 1]]\n    # print(tateBlock(state, [[0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]]))\n    # print(countRestBlock(state))\n    # print(restBlock(data))\n\nif __name__=='__main__':\n    # test()\n    main()"
  },
  {
    "language": "Python",
    "code": "def yoko():\n    for h, line in enumerate(L):\n        if line[q-1:q-1+p] != [' ']*p:\n            h = h-1\n            break\n    for i in range(q-1, q-1+p):\n        L[h][i] = '#'\n    check(h, 1)\n    \ndef tate():\n    for h, line in enumerate(L):\n        if line[q-1] != ' ':\n            h = h-1\n            break\n    for i in range(h-p+1, h-p+1+p):\n        L[i][q-1] = '#'\n    check(h-p+1, p)\n\ndef check(h, c):\n    while 0 < c:\n        if L[h] == ['#']*5:\n            del L[h]\n        else:\n            h += 1\n        c -= 1\n     \ndef add():\n    c = 0\n    for line in L:\n        if line == [' ']*5:\n            c += 1\n        else:\n            break\n    for i in range(5-c):\n        L.insert(0, [' ']*5)\n        \ndef result():\n    ans = 0\n    for line in L:\n        for v in line:\n            if v == '#':\n                ans += 1\n    else:\n        print ans\n\nwhile True:\n    n = input()\n    if n == 0: break\n    L = [[' ']*5 for i in range(5)]\n    for line in L:\n        print line\n    for i in range(n):\n        d, p, q = map(int, raw_input().split())\n        if d == 1:\n            yoko()\n        else:\n            tate()\n        add()\n        for line in L:\n            print line\n    else:\n        result()"
  },
  {
    "language": "Python",
    "code": "while True:\n  n = int(input())\n  if n == 0:\n    break\n\n  mp = [[0] * 5 for _ in range(5000)]\n  depth = [0, 0, 0, 0, 0]\n  ans = 0\n  for _ in range(n):\n    d, p, q = map(int, input().split())\n    ans += p\n\n    if d == 1:\n      max_depth = max(depth[q-1:q-1+p])\n      for i in range(q - 1, q - 1 + p):\n        mp[max_depth][i] = 1\n        depth[i] = max_depth + 1\n    else:\n      max_depth = depth[q - 1]\n      for i in range(max_depth, max_depth + p):\n        mp[i][q - 1] = 1\n      depth[q - 1] = max_depth + p\n  \n  max_depth = max(depth)\n  cnt = 0\n  for depth in range(max_depth):\n    if mp[depth] == [1,1,1,1,1]:\n      cnt += 1\n  print(ans - 5 * cnt)\n"
  },
  {
    "language": "Python",
    "code": "def solve():\n    from bisect import bisect_left\n    from sys import stdin\n    f_i = stdin\n    \n    while True:\n        n = int(f_i.readline())\n        if n == 0:\n            break\n        \n        b = [[0] for i in range(5)]\n        for i in range(n):\n            d, p, q = map(int, f_i.readline().split())\n            q -= 1\n            if d == 1:\n                if p == 5:\n                    continue\n                \n                h = 0\n                for c in b[q:q+p]:\n                    if c[-1] > h:\n                        h = c[-1]\n                \n                h += 1\n                for c in b[:q] + b[q+p:]:\n                    if h not in c:\n                        for c in b[q:q+p]:\n                            c.append(h)\n                        break\n                else:\n                    for c in b[:q] + b[q+p:]:\n                        idx = bisect_left(c, h)\n                        c.pop(idx)\n                        for j in range(idx, len(c)):\n                            c[j] -= 1\n            else:\n                h = b[q][-1] + 1\n                b[q] += list(range(h, h + p))\n                diff = 0\n                for x in range(h, h + p):\n                    x += diff\n                    for c in b[:q] + b[q+1:]:\n                        if x not in c:\n                            break\n                    else:\n                        for c in b:\n                            idx = bisect_left(c, x)\n                            c.pop(idx)\n                            for j in range(idx, len(c)):\n                                c[j] -= 1\n                        diff -= 1\n        \n        print(sum(map(len, b)) - 5)\n\nsolve()\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tn=input()\n\tif n==0:break\n\thmax=1000\n\tblock=[map(int,raw_input().split()) for i in range(n)]\n\tfield=[[0]*5 for i in range(hmax)]\n\tfor d,p,q in block:\n\t\tif d==1:\n\t\t\tfor li in range(hmax-1,-1,-1):\n\t\t\t\tif field[li][q-1:q+p-1]!=[0]*p:\n\t\t\t\t\tfield[li+1][q-1:q+p-1]=[1]*p\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tfield[0][q-1:q+p-1]=[1]*p\n\t\telse:\n\t\t\tfor li in range(hmax-1,-1,-1):\n\t\t\t\tif field[li][q-1]!=0:\n\t\t\t\t\tfor i in range(p):\n\t\t\t\t\t\tfield[li+i+1][q-1]=1\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tfor i in range(p):\n\t\t\t\t\tfield[li+i][q-1]=1\n\t\ti=0\n\t\twhile 1:\n\t\t\tif field[i]==[1]*5:\n\t\t\t\tdel field[i]\n\t\t\t\thmax-=1\n\t\t\telif field[i]==[0]*5:\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\ti+=1\n\tprint sum([sum(field[li]) for li in range(hmax)])"
  },
  {
    "language": "Python",
    "code": "#!/usr/local/bin/python\n\nN = int(input())\n\nwhile True:\n    ls = [[None] * 5] * 5000\n    flwr = 0\n    for _ in xrange(N):\n        d, l, pos = map(int, raw_input().split())\n        # block\n        if d == 1:\n            for i in xrange(l):\n                ls[flwr][pos].append(1)\n        else:\n            tmp = 0\n            for i in xrange(l):\n                ls[flwr][pos+tmp].append(1)\n                tmp += 1\n        # up flower\n        if not None in ls[0]:\n            flwr += 1\n    ret = 0\n    for i in xrange(flwr):\n        ret += len([i for i in ls[i] if not None])\n\n    print ret\n\n    N = int(input())\n    # end condition\n    if not N:\n        break"
  },
  {
    "language": "Python",
    "code": "#!/usr/local/bin/python\n\n\ndef init():\n    return [[None] * 5] * 5000\n\n\nwhile True:\n    N = int(input())\n    if N == 0:\n        break\n    d, l, pos = [int(n) for n in raw_input().split()]\n    lst = init()\n    flwr = 0\n    pos -= 1\n    for _ in xrange(N):\n        if d == 1:\n            for i in xrange(l):\n                lst[flwr][pos + i] = 1\n        else:\n            tmp = 0\n            for i in xrange(l):\n                lst[flwr + tmp][pos] = 1\n                tmp += 1\n        if not None in lst[flwr]:\n            flwr += 1\n    print flwr\n    ret = 0\n    for i in xrange(flwr):\n        ret += len([i for i in lst[i] if not None])\n    print ret"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n=input()\n    if n==0:break\n    hmax=7500\n    block=[map(int,raw_input().split()) for i in range(n)]\n    field=[[0]*5 for i in range(hmax)]\n    h=0\n    for d,p,q in block:\n        if d==1:\n            for li in range(h,-2,-1):\n                if field[li][q-1:q+p-1]!=[0]*p or li==-1:\n                    field[li+1][q-1:q+p-1]=[1]*p\n                    h=max(h,li+2)\n                    break\n        else:\n            for li in range(h,-2,-1):\n                if field[li][q-1]!=0 or li==-1:\n                    for i in range(p):\n                        field[li+i+1][q-1]=1\n                    h=max(h,li+1+p)\n                    break\n    count=0\n    for i in range(h):\n        if field[i]==[1]*5:\n            count+=1\n    print sum([sum(field[li]) for li in range(h)])-5*count"
  },
  {
    "language": "Python",
    "code": "def yoko():\n    for h, line in enumerate(L):\n        if line[q-1:q-1+p] != [' ']*p:\n            h = h-1\n            break\n    for i in range(q-1, q-1+p):\n        L[h][i] = '#'\n    check(h, 1)\n    \ndef tate():\n    for h, line in enumerate(L):\n        if line[q-1] != ' ':\n            h = h-1\n            break\n    for i in range(h-p+1, h-p+1+p):\n        L[i][q-1] = '#'\n    check(h-p+1, p)\n\ndef check(h, c):\n    while 0 < c:\n        if L[h] == ['#']*5:\n            del L[h]\n        else:\n            h += 1\n        c -= 1\n     \ndef add():\n    c = 0\n    for line in L:\n        if line == [' ']*5:\n            c += 1\n        else:\n            break\n    for i in range(5-c):\n        L.insert(0, [' ']*5)\n        \ndef result():\n    ans = 0\n    for line in L:\n        for v in line:\n            if v == '#':\n                ans += 1\n    else:\n        print ans\n\nwhile True:\n    n = input()\n    if n == 0: break\n    L = [[' ']*5 for i in range(5)]\n    for line in L:\n        print line\n    for i in range(n):\n        d, p, q = map(int, raw_input().split())\n        if d == 1:\n            yoko()\n        else:\n            tate()\n        add()\n    else:\n        result()"
  },
  {
    "language": "Python",
    "code": "N = input()\n\nwhile True:\n    ls = [[None] * 5] * 5000\n    flwr = 0\n    for _ in xrange(N):\n        d, l, pos = raw_input.split()\n\n        # block\n        if d == 1:\n            for i in xrange(l):\n                ls[flwr][pos].append(1)\n        else:\n            tmp = 0\n            for i in xrange(l):\n                ls[flwr][pos+tmp].append(1)\n                tmp += 1\n\n        # up flower\n        if not None in ls[0]:\n            flwr += 1\n    N = input()\n\n    # end condition\n    if not N:\n        break"
  },
  {
    "language": "Python",
    "code": "def yoko():\n    for h, line in enumerate(L):\n        if line[q-1:q-1+p] != [' ']*p:\n            h = h-1\n            break\n    for w in range(q-1, (q-1+p-1)+1):\n        L[h][w] = '#'\n    check(h, 1)\n    \ndef tate():\n    for h, line in enumerate(L):\n        if line[q-1] != ' ':\n            h = h-1\n            break\n    for i in range(h-p+1, h-p+1+p):\n        L[i][q-1] = '#'\n    check(h-p+1, p)\n\ndef check(h, _h):\n    c = 0\n    while c < _h:\n        if L[h] == ['#']*5:\n            del L[h]\n        else:\n            h += 1\n        c += 1\n     \ndef add():\n    c = 0\n    for line in L:\n        if line == [' ']*5:\n            c += 1\n        else:\n            break\n    for i in range(5-c):\n        L.insert(0, [' ']*5)\n        \ndef result():\n    ans = 0\n    for line in L:\n        for v in line:\n            if v == '#':\n                ans += 1\n    else:\n        print ans\n\nwhile True:\n    n = input()\n    if n == 0: break\n    L = [[' ']*5 for i in range(5)]\n    for i in range(n):\n        d, p, q = map(int, raw_input().split())\n        if d == 1:\n            yoko()\n        else:\n            tate()\n        add()\n    else:\n        result()"
  },
  {
    "language": "Python",
    "code": "#!/usr/local/bin/python\nfrom itertools import islice\n\ndef init():\n    return [[None] * 5] * 5000\n\nN = 4\n\nwhile True:\n    #N = int(input())\n    if N == 0:\n        break\n    d, l, pos = [int(n) for n in raw_input().split()]\n    lst = init()\n    flwr = 0\n    for i in xrange(N):\n        print d, l, pos\n        # if d == 1:\n        #     for i in xrange(l):\n        #         lst[flwr][pos-1 + i] = 1\n        # else:\n        #     tmp = 0\n        #     for i in xrange(l):\n        #         lst[flwr + tmp][pos-1] = 1\n        #         tmp += 1\n        #print lst[flwr]\n        #print not None in lst[flwr]\n        if not None in lst[flwr]:\n            flwr += 1\n    ret = 0\n    for i in xrange(flwr):\n        ret += len([i for i in lst[i] if not None])\n    #print ret\n    N -= 1\n    break"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tn=input()\n\tif n==0:break\n\thmax=10000\n\tblock=[map(int,raw_input().split()) for i in range(n)]\n\tfield=[[0]*5 for i in range(hmax)]\n\th=0\n\tfor d,p,q in block:\n\t\tif d==1:\n\t\t\tfor li in range(h+1,-2,-1):\n\t\t\t\tif field[li][q-1:q+p-1]!=[0]*p or li==-1:\n\t\t\t\t\tfield[li+1][q-1:q+p-1]=[1]*p\n\t\t\t\t\th=max(h,li+1)\n\t\t\t\t\tbreak\n\t\telse:\n\t\t\tfor li in range(h+1,-2,-1):\n\t\t\t\tif field[li][q-1]!=0 or li==-1:\n\t\t\t\t\tfor i in range(p):\n\t\t\t\t\t\tfield[li+i+1][q-1]=1\n\t\t\t\t\th=max(h,li+1+q)\n\t\t\t\t\tbreak\n\t\ti=0\n\t\twhile 1:\n\t\t\tif field[i]==[1]*5:\n\t\t\t\tdel field[i]\n\t\t\t\th-=1\n\t\t\telif field[i]==[0]*5:\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\ti+=1\n\tprint sum([sum(field[li]) for li in range(hmax)])"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n\nd, l, p = raw_input().split()\nprint d, l, p"
  },
  {
    "language": "Python",
    "code": "def yoko():\n    for h, line in enumerate(L):\n        if line[q-1:q-1+p] != [' ']*p:\n            h = h-1\n            break\n    for i in range(q-1, q-1+p):\n        L[h][i] = '#'\n    check(h, 1)\n    \ndef tate():\n    for h, line in enumerate(L):\n        if line[q-1] != ' ':\n            h = h-1\n            break\n    for i in range(h-p+1, h-p+1+p):\n        L[i][q-1] = '#'\n    check(h-p+1, p)\n\ndef check(h, c):\n    while 0 < c:\n        if L[h] == ['#']*5:\n            del L[h]\n        else:\n            h += 1\n        c -= 1\n     \ndef add():\n    c = 0\n    for line in L:\n        if line == [' ']*5:\n            c += 1\n        else:\n            break\n    for i in range(5-c):\n        L.insert(0, [' ']*5)\n        \ndef result():\n    ans = 0\n    for line in L:\n        for v in line:\n            if v == '#':\n                ans += 1\n    else:\n        print ans\n\nwhile True:\n    n = input()\n    if n == 0: break\n    L = [[' ']*5 for i in range(5)]\n    for i in range(n):\n        d, p, q = map(int, raw_input().split())\n        if d == 1:\n            yoko()\n        else:\n            tate()\n        add()\n    else:\n        result()"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tn=input()\n\tif n==0:break\n\thmax=7500\n\tblock=[map(int,raw_input().split()) for i in range(n)]\n\tfield=[[0]*5 for i in range(hmax)]\n\ttop=[0]*5\n\tfor d,p,q in block:\n\t\tif d==1:\n\t\t\th=max(top[q-1:q-1+p])\n\t\t\tfield[h][q-1:q-1+p]=[1]*p\n\t\t\ttop[q-1:q-1+p]=[max(top)+1]*p\n\t\telse:\n\t\t\th=top[q-1]\n\t\t\tfor i in range(p):\n\t\t\t\tfield[h+i][q-1]=1\n\t\t\ttop[q-1]=h+p\n\tcount=0\n\tfor i in range(max(top)):\n\t\tif field[i]==[1]*5:\n\t\t\tcount+=1\n\tprint sum([sum(field[h]) for h in range(max(top))])-5*count"
  },
  {
    "language": "Python",
    "code": "N = int(input())\n\nwhile True:\n    ls = [[None] * 5] * 5000\n    flwr = 0\n    for _ in xrange(N):\n        d, l, pos = map(int, raw_input().split())\n        # block\n        if d == 1:\n            for i in xrange(l):\n                ls[flwr][pos].append(1)\n        else:\n            tmp = 0\n            for i in xrange(l):\n                ls[flwr][pos+tmp].append(1)\n                tmp += 1\n        # up flower\n        if not None in ls[0]:\n            flwr += 1\n    ret = 0\n    for i in xrange(flwr):\n        ret += len([i for i in ls[i] if not None])\n\n    N = int(input())\n    # end condition\n    if not N:\n        break"
  },
  {
    "language": "Python",
    "code": "N = input()\n\nwhile True:\n    ls = [[None] * 5] * 5000\n    flwr = 0\n    for _ in xrange(N):\n        d, l, pos = raw_input.split()\n        # block\n        if d == 1:\n            for i in xrange(l):\n                ls[flwr][pos].append(1)\n        else:\n            tmp = 0\n            for i in xrange(l):\n                ls[flwr][pos+tmp].append(1)\n                tmp += 1\n        # up flower\n        if not None in ls[0]:\n            flwr += 1\n    ret = 0\n    for i in xrange(flwr):\n        ret += len([i for i in ls[i] if not None])\n\n    N = input()\n    # end condition\n    if not N:\n        break"
  },
  {
    "language": "Python",
    "code": "MAXN=3000\ndef deleteBlocks():\n    i=MAXN-1\n    while i>=0 and set(L[i])!=set([False]):\n        if set(L[i])==set([True]):\n            del L[i]\n            L.insert(0,[False]*5)\n        else:\n            i-=1\n\ndef setBlocks(d,lng,pos):\n    if d==1:\n        for i in range(MAXN):\n            if set(L[i][pos:pos+lng])!=set([False]):\n                L[i-1][pos:pos+lng]=[True]*lng\n                break\n        else:\n            L[i][pos:pos+lng]=[True]*lng\n    elif d==2:\n        for i in range(MAXN):\n            if L[i][pos]:\n                for j in range(i-lng,i):\n                    L[j][pos]=True\n                break\n        else:\n            for j in range(i-lng+1,i+1):\n                L[j][pos]=True\n    deleteBlocks()\n\nwhile True:\n    n=input()\n    if n==0:break\n    L=[[False]*5 for i in range(MAXN)]\n    for i in range(n):\n        d,p,q=map(int,raw_input().split())\n        setBlocks(d,p,q-1)\n    print sum(sum(i) for i in L)"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tn=input()\n\tif n==0:break\n\thmax=7500\n\tblock=[map(int,raw_input().split()) for i in range(n)]\n\tfield=[[0]*5 for i in range(hmax)]\n\ttop=[0]*5\n\tfor d,p,q in block:\n\t\tif d==1:\n\t\t\th=max(top[q-1:q-1+p])\n\t\t\tfield[h][q-1:q-1+p]=[1]*p\n\t\t\ttop[q-1:q-1+p]=[max(top)+1]*p\n\t\telse:\n\t\t\th=top[q-1]\n\t\t\tfor i in range(p):\n\t\t\t\tfield[h+i][q-1]=1\n\t\t\ttop[q-1]=h+p\n\t\ti=0\n\t\twhile 1:\n\t\t\tif field[i]==[1]*5:\n\t\t\t\tdel field[i]\n\t\t\t\ttop=[x-1 for x in top if x>i]\n\t\t\telif field[i]==[0]*5:\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\ti+=1\n\tprint sum([sum(field[h]) for h in range(max(top))])"
  },
  {
    "language": "Python",
    "code": "end = [1,1,1,1,1]\nwhile True:\n  n = int(input())\n  if n == 0:\n    break\n  mp = [[0] * 5 for _ in range(6000)]\n  height = [0] * 5\n  cnt = 0\n  for i in range(n):\n    d, p, q = map(int, input().split())\n    q -= 1\n    cnt += p\n    if d == 1:\n      pos = max(height[q:q + p])\n      mp[pos][q:q + p] = [1] * p\n      if mp[pos] == end:\n        cnt -= 5\n        mp.pop(pos)\n        mp.append([0] * 5)\n        for x in range(5):\n          for y in range(i * 5 - 1, -1, -1):\n            if mp[y][x] == 1:\n              height[x] = y + 1\n              break\n          else:\n            height[x] = 0\n      else:\n        height[q:q + p] = [pos + 1] * p\n\n    if d == 2:\n      pop_flag = False\n      pos = height[q]\n      for y in range(pos, pos + p):\n        mp[y][q] = 1\n      for y in range(pos + p - 1, pos - 1, -1):\n        if mp[y] == end:\n          cnt -= 5\n          mp.pop(y)\n          mp.append([0] * 5)\n          pop_flag = True\n      \n      if pop_flag:\n        for x in range(5):\n          for y in range(i * 5 - 1, -1, -1):\n            if mp[y][x] == 1:\n              height[x] = y + 1\n              break\n          else:\n            height[x] = 0\n      else:\n        height[q] += p\n  \n  print(cnt)\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tn=input()\n\tif n==0:break\n\thmax=7500\n\tblock=[map(int,raw_input().split()) for i in range(n)]\n\tfield=[[0]*5 for i in range(hmax)]\n\ttop=[0]*5\n\tfor d,p,q in block:\n\t\tif d==1:\n\t\t\th=max(top[q-1:q-1+p])\n\t\t\tfield[h][q-1:q-1+p]=[1]*p\n\t\t\ttop[q-1:q-1+p]=[max(top)+1]*p\n\t\telse:\n\t\t\th=top[q-1]\n\t\t\tfor i in range(p):\n\t\t\t\tfield[h+i][q-1]=1\n\t\t\ttop[q-1]=h+p\n\t\ti=0\n\t\twhile 1:\n\t\t\tif field[i]==[1]*5:\n\t\t\t\tdel field[i]\n\t\t\t\ttop=[x-1 for x in top if x>=i]\n\t\t\telif field[i]==[0]*5:\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\ti+=1\n\tprint sum([sum(field[h]) for h in range(max(top))])"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tn=input()\n\tif n==0:break\n\thmax=10000\n\tblock=[map(int,raw_input().split()) for i in range(n)]\n\tfield=[[0]*5 for i in range(hmax)]\n\th=0\n\tfor d,p,q in block:\n\t\tif d==1:\n\t\t\tfor li in range(h+2,-2,-1):\n\t\t\t\tif field[li][q-1:q+p-1]!=[0]*p or li==-1:\n\t\t\t\t\tfield[li+1][q-1:q+p-1]=[1]*p\n\t\t\t\t\th=max(h,li+1+1)\n\t\t\t\t\tbreak\n\t\telse:\n\t\t\tfor li in range(h+2,-2,-1):\n\t\t\t\tif field[li][q-1]!=0 or li==-1:\n\t\t\t\t\tfor i in range(p):\n\t\t\t\t\t\tfield[li+i+1][q-1]=1\n\t\t\t\t\th=max(h,li+1+p)\n\t\t\t\t\tbreak\n\t\ti=0\n\t\twhile 1:\n\t\t\tif field[i]==[1]*5:\n\t\t\t\tdel field[i]\n\t\t\t\th-=1\n\t\t\telif field[i]==[0]*5:\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\ti+=1\n\tprint sum([sum(field[li]) for li in range(len(field))])"
  },
  {
    "language": "Python",
    "code": "def v_block():\n    block.insert(0, [' ']*5)\n    for l, line in enumerate(block):\n        if line[q-1:q+p-1] != [' ']*p:\n            break\n    else:\n        l += 1\n    block[l-1][q-1:q+p-1] = ['*']*p\n    return delete()\n\n\ndef h_block():\n    for _p in range(p):\n        block.insert(0, [' ']*5)\n    for l, line in enumerate(block):\n        if line[q-1] == '*':\n            break\n    else:\n        l += 1\n    for _l in range(l-1, l-p-1, -1):\n        block[_l][q-1] = '*'\n    return delete()\n                \n\ndef delete():\n    b = len(block)\n    l = 0\n    while 0 < b:\n        if block[l] == [' ']*5 or block[l] == ['*']*5:\n            del block[l]\n        else:\n            l += 1\n        b -= 1\n\n\ndef count():\n    x = 0\n    for line in block:\n        for b in line:\n            if b == '*':\n                x += 1\n    else:\n        print(x)\n\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    block = [[' ']*5]\n    for i in range(n):\n        d, p, q = map(int, input().split())\n        if d == 1:\n            v_block()\n        else:\n            h_block()\n    else:\n        count()"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tn=input()\n\tif n==0:break\n\thmax=5000\n\tblock=[map(int,raw_input().split()) for i in range(n)]\n\tfield=[[0]*5 for i in range(hmax)]\n\th=0\n\tfor d,p,q in block:\n\t\tif d==1:\n\t\t\tfor li in range(h,-2,-1):\n\t\t\t\tif field[li][q-1:q+p-1]!=[0]*p or li==-1:\n\t\t\t\t\tfield[li+1][q-1:q+p-1]=[1]*p\n\t\t\t\t\th=max(h,li+2)\n\t\t\t\t\tbreak\n\t\telse:\n\t\t\tfor li in range(h,-2,-1):\n\t\t\t\tif field[li][q-1]!=0 or li==-1:\n\t\t\t\t\tfor i in range(p):\n\t\t\t\t\t\tfield[li+i+1][q-1]=1\n\t\t\t\t\th=max(h,li+1+p)\n\t\t\t\t\tbreak\n\t\ti=0\n\t\twhile 1:\n\t\t\tif field[i]==[1]*5:\n\t\t\t\tdel field[i]\n\t\t\t\th-=1\n\t\t\telif field[i]==[0]*5:\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\ti+=1\n\tprint sum([sum(field[li]) for li in range(h)])"
  },
  {
    "language": "Python",
    "code": "MAXN=5000\ndef setBlocks(d,lng,pos):\n    if d==1:\n        for i in range(MAXN):\n            if set(L[i][pos:pos+lng])!=set([False]):\n                L[i-1][pos:pos+lng]=[True]*lng\n                if set(L[i-1])==set([True]):\n                    del L[i-1]\n                    L.insert(0,[False]*5)\n                break\n        else:\n            L[i][pos:pos+lng]=[True]*lng\n            if set(L[i])==set([True]):\n                del L[i]\n                L.insert(0,[False]*5)\n    elif d==2:\n        for i in range(MAXN):\n            if L[i][pos]:\n                for j in range(i-lng,i):\n                    L[j][pos]=True\n                for j in range(i-lng,i):\n                    if set(L[j])==set([True]):\n                        del L[j]\n                        L.insert(0,[False]*5)\n                break\n        else:\n            for j in range(i-lng+1,i+1):\n                L[j][pos]=True\n            for j in range(i-lng+1,i+1):\n                if set(L[j])==set([True]):\n                    del L[j]\n                    L.insert(0,[False]*5)\n\nwhile True:\n    n=input()\n    if n==0:break\n    L=[[False]*5 for i in range(MAXN)]\n    for i in range(n):\n        d,p,q=map(int,raw_input().split())\n        setBlocks(d,p,q-1)\n    print sum(sum(i) for i in L)"
  },
  {
    "language": "Python",
    "code": "while True:\n    N = int(input())\n    if N == 0:\n        break\n\n    table = [[0 for i in range(5)] for j in range(6000)]\n    blocks = [0 for i in range(5)]\n    for l in range(N):\n        d,p,q = [int(i) for i in input().split()]\n        q -= 1\n        if d == 1:\n            maxtop = 0\n            for i in range(q, q+p):\n                cnt = 0\n                t = 0\n                if blocks[i] > 0:\n                    for j in range(5000):\n                        cnt += table[j][i]\n                        if cnt == blocks[i]:\n                            t = j+1\n                            break\n\n                maxtop = max(maxtop, t)\n            for i in range(q, q+p):\n                table[maxtop][i] = 1\n                blocks[i] += 1\n            if table[maxtop][0]*table[maxtop][1]*table[maxtop][2]*table[maxtop][3]*table[maxtop][4] == 1:\n                del table[maxtop]\n                for i in range(5):\n                    blocks[i] -= 1\n\n        else:\n            maxtop = 0\n            cnt = 0\n            if blocks[q] > 0:\n                t = 0\n                for i in range(5000):\n                    cnt += table[i][q]\n                    if cnt == blocks[q]:\n                        t = i + 1\n                        break\n                maxtop = t\n\n            for i in range(p):\n                table[maxtop + i][q] = 1\n            blocks[q] += p\n\n            for i in range(p-1, -1, -1):\n                k = maxtop + i\n                if table[k][0]*table[k][1]*table[k][2]*table[k][3]*table[k][4] == 1:\n                    del table[k]\n                    for j in range(5):\n                        blocks[j] -= 1\n\n    ans = 0\n#    for i in range(9,-1,-1):\n#        for j in range(5):\n#            print(table[i][j], end = \"\")\n#        print(\"\")\n\n    for i in range(5000):\n        for j in range(5):\n            ans += table[i][j]\n\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "MAXN=5000\ndef deleteBlocks():\n    i=MAXN-1\n    while i>=0 and set(L[i])!=set([False]):\n        if set(L[i])==set([True]):\n            del L[i]\n            L.insert(0,[False]*5)\n        else:\n            i-=1\n\ndef setBlocks(d,lng,pos):\n    if d==1:\n        for i in range(MAXN):\n            if set(L[i][pos:pos+lng])!=set([False]):\n                L[i-1][pos:pos+lng]=[True]*lng\n                break\n        else:\n            L[i][pos:pos+lng]=[True]*lng\n    elif d==2:\n        for i in range(MAXN):\n            if L[i][pos]:\n                for j in range(i-lng,i):\n                    L[j][pos]=True\n                break\n        else:\n            for j in range(i-lng+1,i+1):\n                L[j][pos]=True\n    deleteBlocks()\n\nwhile True:\n    n=input()\n    if n==0:break\n    L=[[False]*5 for i in range(MAXN)]\n    for i in range(n):\n        d,p,q=map(int,raw_input().split())\n        setBlocks(d,p,q-1)\n    print sum(sum(i) for i in L)"
  },
  {
    "language": "Python",
    "code": "end = [1,1,1,1,1]\nwhile True:\n  n = int(input())\n  if n == 0:\n    break\n  mp = [[0] * 5 for _ in range(4000)]\n  height = [0] * 5\n  cnt = 0\n  for i in range(n):\n    d, p, q = map(int, input().split())\n    q -= 1\n    cnt += p\n    if d == 1:\n      pos = max(height[q:q + p])\n      mp[pos][q:q + p] = [1] * p\n      if mp[pos] == end:\n        cnt -= 5\n        mp.pop(pos)\n        mp.append([0] * 5)\n        for x in range(5):\n          for y in range(i * 5 - 1, -1, -1):\n            if mp[y][x] == 1:\n              height[x] = y + 1\n              break\n          else:\n            height[x] = 0\n      else:\n        height[q:q + p] = [pos + 1] * p\n\n    if d == 2:\n      pop_flag = False\n      pos = height[q]\n      for y in range(pos, pos + p):\n        mp[y][q] = 1\n      for y in range(pos + p - 1, pos - 1, -1):\n        if mp[y] == end:\n          cnt -= 5\n          mp.pop(y)\n          mp.append([0] * 5)\n          pop_flag = True\n      \n      if pop_flag:\n        for x in range(5):\n          for y in range(i * 5 - 1, -1, -1):\n            if mp[y][x] == 1:\n              height[x] = y + 1\n              break\n          else:\n            height[x] = 0\n      else:\n        height[q] += p\n  \n  print(cnt)\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tn=input()\n\tif n==0:break\n\thmax=10000\n\tblock=[map(int,raw_input().split()) for i in range(n)]\n\tfield=[[0]*5 for i in range(hmax)]\n\th=0\n\tfor d,p,q in block:\n\t\tif d==1:\n\t\t\tfor li in range(h+2,-2,-1):\n\t\t\t\tif field[li][q-1:q+p-1]!=[0]*p or li==-1:\n\t\t\t\t\tfield[li+1][q-1:q+p-1]=[1]*p\n\t\t\t\t\th=max(h,li+1)\n\t\t\t\t\tbreak\n\t\telse:\n\t\t\tfor li in range(h+2,-2,-1):\n\t\t\t\tif field[li][q-1]!=0 or li==-1:\n\t\t\t\t\tfor i in range(p):\n\t\t\t\t\t\tfield[li+i+1][q-1]=1\n\t\t\t\t\th=max(h,li+1+q)\n\t\t\t\t\tbreak\n\t\ti=0\n\t\twhile 1:\n\t\t\tif field[i]==[1]*5:\n\t\t\t\tdel field[i]\n\t\t\t\th-=1\n\t\t\telif field[i]==[0]*5:\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\ti+=1\n\tprint sum([sum(field[li]) for li in range(len(field))])"
  },
  {
    "language": "Python",
    "code": "while 1:\n    N = int(input())\n    if N == 0:\n        break\n    L = 5000\n    MP = [[0]*L for i in range(5)]\n    cs = [L]*5\n    us = []\n    U = [0]*L\n    for i in range(N):\n        d, p, q = map(int, input().split()); q -= 1\n        if d == 1:\n            y = L\n            for j in range(p):\n                y = min(y, cs[q+j])\n            y -= 1\n            for j in range(p):\n                MP[q+j][y] = 1\n                cs[q+j] = y\n\n            if all(MP[j][y] for j in range(5)):\n                us.append(y)\n        else:\n            y = cs[q] - p\n            for j in range(p):\n                MP[q][y+j] = 1\n            cs[q] = y\n            for j in range(p):\n                if all(MP[k][y+j] for k in range(5)):\n                    us.append(y+j)\n        if us:\n            y0 = us[-1]\n            for y in us:\n                U[y] = 1\n            for j in range(5):\n                cur = y0\n                for k in range(y0, cs[j]-1, -1):\n                    if U[k]:\n                        continue\n                    MP[j][cur] = MP[j][k]\n                    cur -= 1\n                for k in range(cur, cs[j]-1, -1):\n                    MP[j][k] = 0\n                while cur < L and MP[j][cur] == 0:\n                    cur += 1\n                cs[j] = cur\n            for y in us:\n                U[y] = 0\n            us = []\n    ans = 0\n    for j in range(5):\n        for k in range(cs[j], L):\n            ans += MP[j][k]\n    print(ans)\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tn=input()\n\tif n==0:break\n\thmax=10000\n\tblock=[map(int,raw_input().split()) for i in range(n)]\n\tfield=[[0]*5 for i in range(hmax)]\n\th=0\n\tfor d,p,q in block:\n\t\tif d==1:\n\t\t\tfor li in range(h+1,-2,-1):\n\t\t\t\tif field[li][q-1:q+p-1]!=[0]*p or li==-1:\n\t\t\t\t\tfield[li+1][q-1:q+p-1]=[1]*p\n\t\t\t\t\th=max(h,li+1)\n\t\t\t\t\tbreak\n\t\telse:\n\t\t\tfor li in range(h+1,-2,-1):\n\t\t\t\tif field[li][q-1]!=0 or li==-1:\n\t\t\t\t\tfor i in range(p):\n\t\t\t\t\t\tfield[li+i+1][q-1]=1\n\t\t\t\t\th=max(h,li+1+q)\n\t\t\t\t\tbreak\n\t\ti=0\n\t\twhile 1:\n\t\t\tif field[i]==[1]*5:\n\t\t\t\tdel field[i]\n\t\t\t\th-=1\n\t\t\telif field[i]==[0]*5:\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\ti+=1\n\tprint sum([sum(field[li]) for li in range(h)])"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tn=input()\n\tif n==0:break\n\thmax=10000\n\tblock=[map(int,raw_input().split()) for i in range(n)]\n\tfield=[[0]*5 for i in range(hmax)]\n\th=0\n\tfor d,p,q in block:\n\t\tif d==1:\n\t\t\tfor li in range(h+1,-2,-1):\n\t\t\t\tif field[li][q-1:q+p-1]!=[0]*p or li==-1:\n\t\t\t\t\tfield[li+1][q-1:q+p-1]=[1]*p\n\t\t\t\t\th=max(h,li+1)\n\t\t\t\t\tbreak\n\t\telse:\n\t\t\tfor li in range(h+1,-2,-1):\n\t\t\t\tif field[li][q-1]!=0 or li==-1:\n\t\t\t\t\tfor i in range(p):\n\t\t\t\t\t\tfield[li+i+1][q-1]=1\n\t\t\t\t\th=max(h,li+1+q)\n\t\t\t\t\tbreak\n\t\ti=0\n\t\twhile 1:\n\t\t\tif field[i]==[1]*5:\n\t\t\t\tdel field[i]\n\t\t\t\th-=1\n\t\t\telif field[i]==[0]*5:\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\ti+=1\n\tprint sum([sum(field[li]) for li in range(len(field))])"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tn=input()\n\tif n==0:break\n\thmax=7500\n\tblock=[map(int,raw_input().split()) for i in range(n)]\n\tfield=[[0]*5 for i in range(hmax)]\n\th=0\n\tfor d,p,q in block:\n\t\tif d==1:\n\t\t\tfor li in range(h,-2,-1):\n\t\t\t\tif field[li][q-1:q+p-1]!=[0]*p or li==-1:\n\t\t\t\t\tfield[li+1][q-1:q+p-1]=[1]*p\n\t\t\t\t\th=max(h,li+2)\n\t\t\t\t\tbreak\n\t\telse:\n\t\t\tfor li in range(h,-2,-1):\n\t\t\t\tif field[li][q-1]!=0 or li==-1:\n\t\t\t\t\tfor i in range(p):\n\t\t\t\t\t\tfield[li+i+1][q-1]=1\n\t\t\t\t\th=max(h,li+1+p)\n\t\t\t\t\tbreak\n\t\ti=0\n\t\twhile 1:\n\t\t\tif field[i]==[1]*5:\n\t\t\t\tdel field[i]\n\t\t\t\th-=1\n\t\t\telif field[i]==[0]*5:\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\ti+=1\n\tprint sum([sum(field[li]) for li in range(h)])"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tn=input()\n\tif n==0:break\n\thmax=7500\n\tblock=[map(int,raw_input().split()) for i in range(n)]\n\tfield=[[0]*5 for i in range(hmax)]\n\ttop=[0]*5\n\tfor d,p,q in block:\n\t\tif d==1:\n\t\t\th=max(top[q-1:q-1+p])\n\t\t\tfield[h][q-1:q-1+p]=[1]*p\n\t\t\ttop[q-1:q-1+p]=[max(top)+1]*p\n\t\telse:\n\t\t\th=top[q-1]\n\t\t\tfor i in range(p):\n\t\t\t\tfield[h+i][q-1]=1\n\t\t\ttop[q-1]=h+p\n\t\th=0\n\t\twhile 1:\n\t\t\tif field[h]==[1]*5:\n\t\t\t\tdel field[h]\n\t\t\t\ttop=[x-1 for x in top]\n\t\t\telif field[h]==[0]*5:\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\th+=1\n\t\tfor w in range(5):\n\t\t\tfor h in range(top[w]-1,-2,-1):\n\t\t\t\tif field[h][w]==1 or h==-1:\n\t\t\t\t\ttop[w]=h+1\n\t\t\t\t\tbreak\n\tprint sum([sum(field[h]) for h in range(max(top))])"
  },
  {
    "language": "Python",
    "code": "N = raw_input()\n\nwhile True:\n    ls = [[None] * 5] * 5000\n    flwr = 0\n    for _ in xrange(N):\n        d, l, pos = raw_input.split()\n\n        # block\n        if d == 1:\n            for i in xrange(l):\n                ls[flwr][pos].append(1)\n        else:\n            tmp = 0\n            for i in xrange(l):\n                ls[flwr][pos+tmp].append(1)\n                tmp += 1\n\n        # up flower\n        if not None in ls[0]:\n            flwr += 1\n    N = raw_input()\n\n    # end condition\n    if not N:\n        break"
  },
  {
    "language": "Python",
    "code": "def yoko():\n    for h, line in enumerate(L):\n        if line[q-1:q-1+p] != [' ']*p:\n            h = h-1\n            for w in range(q-1, q-1+p):\n                L[h][w] = '#'\n            break\n    else:\n        for w in range(q-1, (q-1+p-1)+1):\n            L[h][w] = '#'\n    \n    check(h, 1)\n    \ndef tate():\n    for h, line in enumerate(L):\n        if line[q-1] != ' ':\n            h = h-1\n            for i in range(h-p+1, h-p+1+p):\n                L[i][q-1] = '#'\n            break\n    else:\n        for i in range(h-p+1, h-p+1+p):\n            L[i][q-1] = '#'\n    \n    check(h-p+1, p)\n\ndef check(h, _h):\n    c = 0\n    while c < _h:\n        if L[h] == ['#']*5:\n            del L[h]\n        else:\n            h += 1\n        c += 1\n     \ndef add():\n    c = 0\n    for line in L:\n        if line == [' ']*5:\n            c += 1\n        else:\n            break\n    for i in range(5-c):\n        L.insert(0, [' ']*5)\n        \ndef result():\n    ans = 0\n    for line in L:\n        for v in line:\n            if v == '#':\n                ans += 1\n    else:\n        print ans\n\nwhile True:\n    n = input()\n    if n == 0: break\n    L = [[' ']*5 for i in range(5)]\n    for i in range(n):\n        d, p, q = map(int, raw_input().split())\n        if d == 1:\n            yoko()\n        else:\n            tate()\n        add()\n    else:\n        result()"
  },
  {
    "language": "Python",
    "code": "def yoko():\n    for h, line in enumerate(L):\n        if line[q-1:q-1+p] != [' ']*p:\n            h = h-1\n            break\n    for i in range(q-1, (q-1+p-1)+1):\n        L[h][i] = '#'\n    check(h, 1)\n    \ndef tate():\n    for h, line in enumerate(L):\n        if line[q-1] != ' ':\n            h = h-1\n            break\n    for i in range(h-p+1, h-p+1+p):\n        L[i][q-1] = '#'\n    check(h-p+1, p)\n\ndef check(h, c):\n    while 0 < c:\n        if L[h] == ['#']*5:\n            del L[h]\n        else:\n            h += 1\n        c -= 1\n     \ndef add():\n    c = 0\n    for line in L:\n        if line == [' ']*5:\n            c += 1\n        else:\n            break\n    for i in range(5-c):\n        L.insert(0, [' ']*5)\n        \ndef result():\n    ans = 0\n    for line in L:\n        for v in line:\n            if v == '#':\n                ans += 1\n    else:\n        print ans\n\nwhile True:\n    n = input()\n    if n == 0: break\n    L = [[' ']*5 for i in range(5)]\n    for i in range(n):\n        d, p, q = map(int, raw_input().split())\n        if d == 1:\n            yoko()\n        else:\n            tate()\n        add()\n    else:\n        result()"
  },
  {
    "language": "Python",
    "code": "MAXN=5000\ndef deleteBlocks():\n    i=MAXN-1\n    while i>=0 and set(L[i])!=set([False]):\n        if set(L[i])==set([True]):\n            del L[i]\n            L.insert(0,[False]*5)\n        else:\n            i-=1\n\ndef setBlocks(d,lng,pos):\n    if d==1:\n        for i in range(MAXN):\n            if set(L[i][pos:pos+lng])!=set([False]):\n                L[i-1][pos:pos+lng]=[True]*lng\n                break\n        else:\n            L[i][pos:pos+lng]=[True]*lng\n    elif d==2:\n        for i in range(MAXN):\n            if L[i][pos]:\n                for j in range(i-lng,i):\n                    L[j][pos]=True\n                break\n        else:\n            for j in range(i-lng+1,i+1):\n                L[j][pos]=True\n    deleteBlocks()\n\nwhile True:\n    n=input()\n    if n==0:break\n    L=[[False]*5 for i in range(MAXN)]\n    for i in range(n):\n        d,p,q=map(int,raw_input().split())\n        setBlocks(d,p,q-1)\n    cnt,i=0,MAXN-1\n    while i>=0 and set(L[i])!=set([False]):\n        cnt+=sum(L[i])\n        i-=1\n    print cnt"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tn=input()\n\tif n==0:break\n\thmax=7500\n\tblock=[map(int,raw_input().split()) for i in range(n)]\n\tfield=[[0]*5 for i in range(hmax)]\n\ttop=[0]*5\n\tfor d,p,q in block:\n\t\tif d==1:\n\t\t\th=max(top[q-1:q-1+p])\n\t\t\tfield[h][q-1:q-1+p]=[1]*p\n\t\t\ttop[q-1:q-1+p]=[max(top)+1]*p\n\t\telse:\n\t\t\th=top[q-1]\n\t\t\tfor i in range(p):\n\t\t\t\tfield[h+i][q-1]=1\n\t\t\ttop[q-1]=h+p\n\t\ti=0\n\t\twhile 1:\n\t\t\tif field[i]==[1]*5:\n\t\t\t\tdel field[i]\n\t\t\t\ttop=[x-1 for x in top]\n\t\t\telif field[i]==[0]*5:\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\ti+=1\n\tprint sum([sum(field[h]) for h in range(max(top))])"
  },
  {
    "language": "Python",
    "code": "while 1:\n\tn=input()\n\tif n==0:break\n\thmax=10000\n\tblock=[map(int,raw_input().split()) for i in range(n)]\n\tfield=[[0]*5 for i in range(hmax)]\n\tfor d,p,q in block:\n\t\tif d==1:\n\t\t\tfor li in range(hmax-1,-1,-1):\n\t\t\t\tif field[li][q-1:q+p-1]!=[0]*p:\n\t\t\t\t\tfield[li+1][q-1:q+p-1]=[1]*p\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tfield[0][q-1:q+p-1]=[1]*p\n\t\telse:\n\t\t\tfor li in range(hmax-1,-1,-1):\n\t\t\t\tif field[li][q-1]!=0:\n\t\t\t\t\tfor i in range(p):\n\t\t\t\t\t\tfield[li+i+1][q-1]=1\n\t\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\tfor i in range(p):\n\t\t\t\t\tfield[li+i][q-1]=1\n\t\ti=0\n\t\twhile 1:\n\t\t\tif field[i]==[1]*5:\n\t\t\t\tdel field[i]\n\t\t\t\thmax-=1\n\t\t\telif field[i]==[0]*5:\n\t\t\t\tbreak\n\t\t\telse:\n\t\t\t\ti+=1\n\tprint sum([sum(field[li]) for li in range(hmax)])"
  },
  {
    "language": "Rust",
    "code": "fn main(){\n  loop {\n    let n: u32 = read();\n\n    if n == 0 { break; }\n  \n    let mut fld: Vec<Vec<usize>> = vec![vec![0; 5]; 5000];\n    let mut pa: Vec<usize> = vec![0; 5];\n    \n    for _ in 0 .. n {\n      let tv: Vec<usize> = read_vec();\n      let d = tv[0];\n      let p = tv[1];\n      let q = tv[2] - 1;\n\n      put_block(&mut fld, &mut pa, d, p, q);\n    }\n\n    let cnt: usize = count_block(&fld, &pa);\n\n    println!(\"{}\", cnt);\n  }\n}\n\nfn read<T>() -> T\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.trim().parse().unwrap()\n}\n\nfn read_vec<T>() -> Vec<T>\n  where T: std::str::FromStr,\n        T::Err: std::fmt::Debug\n{\n  let mut buf = String::new();\n  std::io::stdin().read_line(&mut buf).expect(\"failed to read\");\n  buf.split_whitespace().map(|e| e.parse().unwrap()).collect()\n}\n\n// fn print_field(fld: &Vec<Vec<usize>>, pa: &Vec<usize>){\n//   let mp: &usize = pa.iter().max().unwrap();\n\n//   println!(\"----------\");\n//   for i in (0..*mp).rev() {\n//     println!(\"{:04}:{}{}{}{}{}\", i, fld[i][0], fld[i][1], fld[i][2], fld[i][3], fld[i][4])\n//   }\n//   println!(\"----------\");\n// }\n\nfn put_block(fld: &mut Vec<Vec<usize>>, pa: &mut Vec<usize>, d: usize, p: usize, q: usize) {\n  if d == 1 {\n    let mx: usize = (q..q+p).map(|i| pa[i]).max().unwrap();\n\n    for i in q .. q + p {\n      fld[mx][i] = 1;\n      pa[i] = mx + 1;\n    }\n\n    if fld[mx].iter().all(|i| *i == 1) {\n      let tp: usize = (0..5).map(|i| pa[i]).max().unwrap();\n\n      for i in mx .. tp {\n        for j in 0 .. 5 {\n          fld[i][j] = fld[i+1][j];\n        }\n      }\n      \n      for j in 0 .. 5 {\n        for i in (0 .. pa[j]).rev() {\n          if fld[i][j] == 1 { break; }\n          else { pa[j] = i; }\n        }\n      }\n    }\n  } else {\n    for i in pa[q] .. pa[q] + p {\n      fld[i][q] = 1;\n    }\n    pa[q] = pa[q] + p;\n\n    for i in (pa[q]-p .. pa[q]).rev() {\n      if fld[i].iter().all(|i| *i == 1) {\n        let tp: usize = (0..5).map(|i| pa[i]).max().unwrap();\n\n        for j in i .. tp {\n          for k in 0 .. 5 {\n            fld[j][k] = fld[j+1][k];\n          }\n        }\n      }\n    }\n    \n    for j in 0 .. 5 {\n      for i in (0 .. pa[j]).rev() {\n        if fld[i][j] == 1 { break; }\n        else { pa[j] = i; }\n      }\n    }\n  }\n}\n\nfn count_block(fld: &Vec<Vec<usize>>, pa: &Vec<usize>) -> usize {\n  let mut cnt: usize = 0;\n\n  for j in 0 .. 5 {\n    for i in 0 .. pa[j] {\n      if fld[i][j] == 1 { cnt += 1; }\n    }\n  }\n  cnt\n}\n\n"
  }
]