[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define WIDTH 5\n#define MAX_HEIGHT 1000\n#define MAX_BLOCKS 1000\n\nint board[MAX_HEIGHT + 10][WIDTH];\nint top = 0;\n\nvoid drop(int type, int pos) {\n    int height = 0;\n    if (type == 1) { // vertical\n        for (; height < top; height++) {\n            if (board[height][pos]) {\n                break;\n            }\n        }\n        for (int i = 0; i < type; i++) {\n            board[height - 1][pos] = 1;\n        }\n        if (height - 1 + 1 > top) {\n            top = height - 1 + 1;\n        }\n    } else { // horizontal\n        for (; height < top; height++) {\n            bool canPlace = true;\n            for (int j = pos; j < pos + type; j++) {\n                if (board[height][j]) {\n                    canPlace = false;\n                    break;\n                }\n            }\n            if (!canPlace) break;\n        }\n        for (int j = pos; j < pos + type; j++) {\n            board[height - 1][j] = 1;\n        }\n        if (height - 1 + 1 > top) {\n            top = height - 1 + 1;\n        }\n    }\n\n    // Check for full rows\n    for (int i = 0; i < top; i++) {\n        bool full = true;\n        for (int j = 0; j < WIDTH; j++) {\n            if (!board[i][j]) {\n                full = false;\n                break;\n            }\n        }\n        if (full) {\n            // Shift rows above down\n            for (int k = i; k < top - 1; k++) {\n                for (int j = 0; j < WIDTH; j++) {\n                    board[k][j] = board[k + 1][j];\n                }\n            }\n            // Clear top row\n            for (int j = 0; j < WIDTH; j++) {\n                board[top - 1][j] = 0;\n            }\n            top--;\n            i--; // Recheck this row\n        }\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        int type, pos;\n        scanf(\"%d %d\", &type, &pos);\n        drop(type, pos - 1); // convert to 0-based\n    }\n\n    int count = 0;\n    for (int i = 0; i < top; i++) {\n        for (int j = 0; j < WIDTH; j++) {\n            if (board[i][j]) {\n                count++;\n            }\n        }\n    }\n    printf(\"%d\\n\", count);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:33:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class TetrisBlockStacking {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt();\n        int[][] board = new int[1001][5];\n        int blockCount = 0;\n\n        for (int i = 0; i < N; i++) {\n            int length = scanner.nextInt();\n            int direction = scanner.nextInt();\n            \n            if (direction == 0) {  // horizontal block\n                int col = scanner.nextInt();\n                int lowestRow = findLowestRow(board, col, length);\n                \n                for (int j = col; j < col + length; j++) {\n                    board[lowestRow][j] = 1;\n                }\n                \n                checkAndRemoveFullRows(board);\n                blockCount += length;\n            } else {  // vertical block\n                int col = scanner.nextInt();\n                int lowestRow = findLowestRow(board, col, 1);\n                \n                for (int j = lowestRow; j < lowestRow + length; j++) {\n                    board[j][col] = 1;\n                }\n                \n                checkAndRemoveFullRows(board);\n                blockCount += length;\n            }\n        }\n        \n        System.out.println(blockCount);\n        scanner.close();\n    }\n    \n    private static int findLowestRow(int[][] board, int col, int length) {\n        int lowestRow = 0;\n        \n        for (int row = 0; row < board.length; row++) {\n            boolean canPlace = true;\n            \n            for (int j = col; j < col + length; j++) {\n                if (board[row][j] == 1) {\n                    canPlace = false;\n                    break;\n                }\n            }\n            \n            if (!canPlace) {\n                return row - 1;\n            }\n        }\n        \n        return board.length - 1;\n    }\n    \n    private static void checkAndRemoveFullRows(int[][] board) {\n        for (int row = 0; row < board.length; row++) {\n            boolean isFullRow = true;\n            \n            for (int col = 0; col < 5; col++) {\n                if (board[row][col] == 0) {\n                    isFullRow = false;\n                    break;\n                }\n            }\n            \n            if (isFullRow) {\n                removeRow(board, row);\n            }\n        }\n    }\n    \n    private static void removeRow(int[][] board, int rowToRemove) {\n        for (int row = rowToRemove; row > 0; row--) {\n            for (int col = 0; col < 5; col++) {\n                board[row][col] = board[row - 1][col];\n            }\n        }\n        \n        for (int col = 0; col < 5; col++) {\n            board[0][col] = 0;\n        }\n    }\n}",
    "timestamp": "2025-08-05 18:34:06"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int WIDTH = 5;\n\nvoid removeFullRows(vector<vector<bool>>& board) {\n    for (int i = 0; i < board.size(); ) {\n        bool full = true;\n        for (int j = 0; j < WIDTH; ++j) {\n            if (!board[i][j]) {\n                full = false;\n                break;\n            }\n        }\n        if (full) {\n            board.erase(board.begin() + i);\n        } else {\n            ++i;\n        }\n    }\n}\n\nint main() {\n    vector<vector<bool>> board;\n    int N;\n    cin >> N;\n    \n    for (int k = 0; k < N; ++k) {\n        int D, C;\n        cin >> D >> C;\n        C -= 1; // convert to 0-based\n        \n        int landingRow = board.size();\n        if (D == 1) { // vertical block\n            for (int i = 0; i < board.size(); ++i) {\n                if (board[i][C]) {\n                    landingRow = i;\n                    break;\n                }\n            }\n            for (int i = 0; i < 1; ++i) {\n                if (landingRow - i - 1 < 0) {\n                    vector<bool> newRow(WIDTH, false);\n                    newRow[C] = true;\n                    board.insert(board.begin(), newRow);\n                    landingRow++;\n                } else {\n                    board[landingRow - i - 1][C] = true;\n                }\n            }\n        } else { // horizontal block\n            int end = C + D;\n            for (int i = 0; i < board.size(); ++i) {\n                for (int j = C; j < end; ++j) {\n                    if (board[i][j]) {\n                        landingRow = min(landingRow, i);\n                        break;\n                    }\n                }\n            }\n            for (int i = 0; i < 1; ++i) {\n                if (landingRow - i - 1 < 0) {\n                    vector<bool> newRow(WIDTH, false);\n                    for (int j = C; j < end; ++j) {\n                        newRow[j] = true;\n                    }\n                    board.insert(board.begin(), newRow);\n                    landingRow++;\n                } else {\n                    for (int j = C; j < end; ++j) {\n                        board[landingRow - i - 1][j] = true;\n                    }\n                }\n            }\n        }\n        removeFullRows(board);\n    }\n    \n    int totalBlocks = 0;\n    for (const auto& row : board) {\n        for (bool cell : row) {\n            if (cell) totalBlocks++;\n        }\n    }\n    cout << totalBlocks << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:34:34"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define WIDTH 5\n#define MAX_HEIGHT 1000\n\nint board[MAX_HEIGHT][WIDTH];\nint height = 0;\n\nint drop_block(int length, int orientation) {\n    if (orientation == 0) {  // horizontal\n        int lowest_row = 0;\n        int best_column = 0;\n        \n        for (int col = 0; col <= WIDTH - length; col++) {\n            int max_height = 0;\n            for (int i = 0; i < length; i++) {\n                int h = 0;\n                while (h < height && board[h][col + i] == 0) {\n                    h++;\n                }\n                max_height = (h > max_height) ? h : max_height;\n            }\n            \n            if (max_height > lowest_row) {\n                lowest_row = max_height;\n                best_column = col;\n            }\n        }\n        \n        for (int i = 0; i < length; i++) {\n            board[lowest_row][best_column + i] = 1;\n        }\n        \n        height = (lowest_row + 1 > height) ? lowest_row + 1 : height;\n        return lowest_row;\n    }\n    else {  // vertical\n        int lowest_row = 0;\n        int column = 0;\n        \n        for (int col = 0; col < WIDTH; col++) {\n            int h = 0;\n            while (h < height && board[h][col] == 0) {\n                h++;\n            }\n            \n            if (h > lowest_row) {\n                lowest_row = h;\n                column = col;\n            }\n        }\n        \n        for (int i = 0; i < length; i++) {\n            board[lowest_row + i][column] = 1;\n        }\n        \n        height = (lowest_row + length > height) ? lowest_row + length : height;\n        return lowest_row;\n    }\n}\n\nvoid remove_rows() {\n    int write_row = 0;\n    for (int row = 0; row < height; row++) {\n        int is_full = 1;\n        for (int col = 0; col < WIDTH; col++) {\n            if (board[row][col] == 0) {\n                is_full = 0;\n                break;\n            }\n        }\n        \n        if (!is_full) {\n            if (write_row != row) {\n                for (int col = 0; col < WIDTH; col++) {\n                    board[write_row][col] = board[row][col];\n                }\n            }\n            write_row++;\n        }\n    }\n    \n    height = write_row;\n}\n\nint count_blocks() {\n    int total = 0;\n    for (int row = 0; row < height; row++) {\n        for (int col = 0; col < WIDTH; col++) {\n            total += board[row][col];\n        }\n    }\n    return total;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    for (int i = 0; i < N; i++) {\n        int length, orientation;\n        scanf(\"%d %d\", &length, &orientation);\n        \n        drop_block(length, orientation);\n        remove_rows();\n    }\n    \n    printf(\"%d\\n\", count_blocks());\n    return 0;\n}",
    "timestamp": "2025-08-05 18:34:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<vector<bool>> board(1000, vector<bool>(5, false));\n    int height = 0;\n\n    for (int i = 0; i < N; i++) {\n        int L, D, X;\n        cin >> L >> D >> X;\n\n        // Determine starting column and direction\n        vector<pair<int, int>> blockPositions;\n        if (D == 0) {  // Horizontal block\n            for (int j = 0; j < L; j++) {\n                blockPositions.push_back({X-1+j, 0});\n            }\n        } else {  // Vertical block\n            for (int j = 0; j < L; j++) {\n                blockPositions.push_back({X-1, j});\n            }\n        }\n\n        // Find lowest drop point\n        int maxHeight = 0;\n        for (auto& pos : blockPositions) {\n            int col = pos.first;\n            int row = 0;\n            while (row < 1000 && !board[row][col]) {\n                row++;\n            }\n            maxHeight = max(maxHeight, row);\n        }\n\n        // Place block\n        maxHeight--;\n        for (auto& pos : blockPositions) {\n            board[maxHeight + pos.second][pos.first] = true;\n        }\n\n        // Remove full rows\n        for (int row = 0; row < 1000; row++) {\n            bool fullRow = true;\n            for (int col = 0; col < 5; col++) {\n                if (!board[row][col]) {\n                    fullRow = false;\n                    break;\n                }\n            }\n            if (fullRow) {\n                for (int r = row; r > 0; r--) {\n                    for (int col = 0; col < 5; col++) {\n                        board[r][col] = board[r-1][col];\n                    }\n                }\n                for (int col = 0; col < 5; col++) {\n                    board[0][col] = false;\n                }\n                row--;\n            }\n        }\n    }\n\n    // Count remaining blocks\n    int blockCount = 0;\n    for (int row = 0; row < 1000; row++) {\n        for (int col = 0; col < 5; col++) {\n            if (board[row][col]) blockCount++;\n        }\n    }\n\n    cout << blockCount << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:34:55"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Tetris {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int[][] board = new int[1000][5]; // Assuming max height is 1000\n        int top = 0; // Tracks the highest occupied row\n        int blockCount = 0;\n\n        int N = scanner.nextInt();\n        for (int i = 0; i < N; i++) {\n            int L = scanner.nextInt();\n            int R = scanner.nextInt();\n            int C = scanner.nextInt();\n\n            int dropRow = top;\n            if (C == 0) { // Horizontal block\n                int maxBelow = 0;\n                for (int j = R; j < R + L; j++) {\n                    for (int k = top; k >= 0; k--) {\n                        if (board[k][j] == 1) {\n                            if (k + 1 > maxBelow) {\n                                maxBelow = k + 1;\n                            }\n                            break;\n                        }\n                    }\n                }\n                dropRow = maxBelow;\n                for (int j = R; j < R + L; j++) {\n                    board[dropRow][j] = 1;\n                }\n            } else { // Vertical block\n                for (int k = top; k >= 0; k--) {\n                    if (board[k][R] == 1) {\n                        dropRow = k + 1;\n                        break;\n                    }\n                }\n                for (int j = 0; j < L; j++) {\n                    board[dropRow + j][R] = 1;\n                }\n                dropRow += L - 1;\n            }\n\n            if (dropRow + (C == 1 ? L : 0) > top) {\n                top = dropRow + (C == 1 ? L - 1 : 0);\n            }\n\n            // Check for full rows\n            for (int row = top; row >= 0; row--) {\n                boolean full = true;\n                for (int col = 0; col < 5; col++) {\n                    if (board[row][col] != 1) {\n                        full = false;\n                        break;\n                    }\n                }\n                if (full) {\n                    // Remove the row and shift down\n                    for (int r = row; r < top; r++) {\n                        System.arraycopy(board[r + 1], 0, board[r], 0, 5);\n                    }\n                    for (int col = 0; col < 5; col++) {\n                        board[top][col] = 0;\n                    }\n                    top--;\n                    row = top + 1; // Recheck current row after shift\n                }\n            }\n        }\n\n        // Count all blocks\n        for (int i = 0; i <= top; i++) {\n            for (int j = 0; j < 5; j++) {\n                if (board[i][j] == 1) {\n                    blockCount++;\n                }\n            }\n        }\n        System.out.println(blockCount);\n    }\n}",
    "timestamp": "2025-08-05 18:35:26"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def tetris(blocks):\n    width = 5\n    board = []\n\n    for block in blocks:\n        orientation, length = block\n        if orientation == 'H':\n            # Determine the position the horizontal block will stop\n            stop_row = 0\n            while stop_row < len(board) and any(board[stop_row][i] for i in range(length)):\n                stop_row += 1\n            # If new rows need to be added\n            while len(board) <= stop_row:\n                board.append([0] * width)\n            # Place the horizontal block\n            for i in range(length):\n                board[stop_row][i] = 1\n        elif orientation == 'V':\n            # Place a vertical block, column is always 0 as per problem statement\n            stop_row = -1\n            for row in range(len(board)):\n                if any(board[row][col] for col in range(length)):\n                    stop_row = row - 1\n                    break\n            if stop_row == -1:\n                stop_row = len(board) - 1\n            # If new rows need to be added\n            while len(board) <= stop_row + 1:\n                board.append([0] * width)\n            # Place the vertical block\n            for i in range(length):\n                if stop_row - i >= 0:\n                    board[stop_row - i][0] = 1\n\n        # Check for full rows and remove them\n        board = [row for row in board if any(cell == 0 for cell in row)]\n\n    # Count remaining blocks\n    remaining_blocks = sum(sum(row) for row in board)\n    return remaining_blocks\n\n# Example list of blocks for demonstration purposes\nblocks = [('H', 3), ('V', 4), ('H', 5), ('V', 2), ('H', 4), ('V', 1)]\nprint(tetris(blocks))",
    "timestamp": "2025-08-12 23:51:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class TetrisGame {\n    private static final int BOARD_WIDTH = 5;\n    private static int boardHeight = 0;\n    private static List<boolean[]> board = new ArrayList<>();\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        for (int i = 0; i < n; i++) {\n            String orientation = scanner.next();\n            int length = scanner.nextInt();\n            int position = scanner.nextInt();\n            dropBlock(orientation.equals(\"H\"), length, position);\n        }\n        scanner.close();\n        System.out.println(countRemainingBlocks());\n    }\n\n    private static void dropBlock(boolean isHorizontal, int length, int position) {\n        if (isHorizontal) {\n            int dropHeight = findDropHeightHorizontal(position, length);\n            placeHorizontalBlock(dropHeight, position, length);\n        } else {\n            int dropHeight = findDropHeightVertical(position);\n            placeVerticalBlock(dropHeight, position, length);\n        }\n        removeFullRows();\n    }\n\n    private static int findDropHeightHorizontal(int position, int length) {\n        int maxHeight = 0;\n        for (int i = position; i < position + length; i++) {\n            int height = 0;\n            for (int j = 0; j < boardHeight; j++) {\n                if (board.get(j)[i]) {\n                    height = j + 1;\n                }\n            }\n            maxHeight = Math.max(maxHeight, height);\n        }\n        return maxHeight;\n    }\n\n    private static int findDropHeightVertical(int position) {\n        int height = 0;\n        for (int j = 0; j < boardHeight; j++) {\n            if (board.get(j)[position]) {\n                height = j + 1;\n            }\n        }\n        return height;\n    }\n\n    private static void placeHorizontalBlock(int dropHeight, int position, int length) {\n        while (boardHeight <= dropHeight) {\n            board.add(new boolean[BOARD_WIDTH]);\n            boardHeight++;\n        }\n        for (int i = position; i < position + length; i++) {\n            board.get(dropHeight)[i] = true;\n        }\n    }\n\n    private static void placeVerticalBlock(int dropHeight, int position, int length) {\n        while (boardHeight <= dropHeight + length - 1) {\n            board.add(new boolean[BOARD_WIDTH]);\n            boardHeight++;\n        }\n        for (int j = dropHeight; j < dropHeight + length; j++) {\n            board.get(j)[position] = true;\n        }\n    }\n\n    private static void removeFullRows() {\n        for (int j = 0; j < boardHeight; ) {\n            if (isFullRow(j)) {\n                board.remove(j);\n                boardHeight--;\n            } else {\n                j++;\n            }\n        }\n    }\n\n    private static boolean isFullRow(int row) {\n        for (int i = 0; i < BOARD_WIDTH; i++) {\n            if (!board.get(row)[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static int countRemainingBlocks() {\n        int count = 0;\n        for (int j = 0; j < boardHeight; j++) {\n            for (int i = 0; i < BOARD_WIDTH; i++) {\n                if (board.get(j)[i]) {\n                    count++;\n                }\n            }\n        }\n        return count;\n    }\n}",
    "timestamp": "2025-08-12 23:51:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define WIDTH 5\n#define MAX_HEIGHT 5000\n\nvoid process_block(int board[MAX_HEIGHT][WIDTH], int *current_height, int length, int position, int is_horizontal) {\n    if (is_horizontal) {\n        // Find the lowest position where the horizontal block can be placed.\n        int drop_pos = 0;\n        while (1) {\n            int can_place = 1;\n            for (int i = position; i < position + length; i++) {\n                if (board[drop_pos][i] != 0) {\n                    can_place = 0;\n                    break;\n                }\n            }\n            if (!can_place || drop_pos == *current_height) break;\n            drop_pos++;\n        }\n        // Place the block\n        for (int i = position; i < position + length; i++) {\n            board[drop_pos - 1][i] = 1;\n        }\n    } else {\n        // Find the lowest position where the vertical block can be placed.\n        int drop_pos = *current_height;\n        for (int i = 0; i < length; i++) {\n            if (position < WIDTH && board[*current_height - i - 1][position] != 0) {\n                drop_pos = *current_height - i;\n                break;\n            }\n        }\n        // Place the block\n        for (int i = 0; i < length; i++) {\n            board[drop_pos - i - 1][position] = 1;\n        }\n        if (drop_pos > *current_height) {\n            *current_height = drop_pos;\n        }\n    }\n\n    // Check for filled rows\n    while (1) {\n        int row_removed = 0;\n        for (int i = 0; i < *current_height; i++) {\n            int full_row = 1;\n            for (int j = 0; j < WIDTH; j++) {\n                if (board[i][j] == 0) {\n                    full_row = 0;\n                    break;\n                }\n            }\n            if (full_row) {\n                // Remove the row and drop down the above rows\n                for (int k = i; k < *current_height - 1; k++) {\n                    for (int j = 0; j < WIDTH; j++) {\n                        board[k][j] = board[k + 1][j];\n                    }\n                }\n                for (int j = 0; j < WIDTH; j++) {\n                    board[*current_height - 1][j] = 0;\n                }\n                (*current_height)--;\n                row_removed = 1;\n                break;\n            }\n        }\n        if (!row_removed) break;\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    int board[MAX_HEIGHT][WIDTH];\n    memset(board, 0, sizeof(board));\n    int current_height = 0;\n\n    for (int i = 0; i < n; i++) {\n        char orientation;\n        int length, position;\n        scanf(\" %c %d %d\", &orientation, &length, &position);\n\n        if (orientation == 'H') {\n            process_block(board, &current_height, length, position, 1);\n        } else {\n            process_block(board, &current_height, length, position, 0);\n        }\n    }\n\n    // Count remaining blocks\n    int remaining_blocks = 0;\n    for (int i = 0; i < current_height; i++) {\n        for (int j = 0; j < WIDTH; j++) {\n            if (board[i][j] == 1) {\n                remaining_blocks++;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", remaining_blocks);\n    return 0;\n}",
    "timestamp": "2025-08-12 23:51:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve_tetris():\n    board = [[0] * 5 for _ in range(1000)]\n    board_height = 0\n\n    def drop_block(block):\n        nonlocal board_height\n        length, direction = block\n\n        if direction == 0:  # Horizontal block\n            candidates = []\n            for col in range(5 - length + 1):\n                max_height = 0\n                valid = True\n                for c in range(col, col + length):\n                    height = find_height(c)\n                    max_height = max(max_height, height)\n                    if not valid_placement(c, max_height):\n                        valid = False\n                        break\n                \n                if valid:\n                    candidates.append(max_height)\n                else:\n                    candidates.append(float('inf'))\n            \n            landing_height = min(candidates)\n            landing_col = candidates.index(landing_height)\n            \n            for c in range(landing_col, landing_col + length):\n                board[landing_height][c] = 1\n            \n            board_height = max(board_height, landing_height + 1)\n            remove_full_rows(landing_height)\n\n        else:  # Vertical block\n            col = block[1]\n            height = find_height(col)\n            \n            for r in range(height, height + length):\n                board[r][col] = 1\n            \n            board_height = max(board_height, height + length)\n            remove_full_rows(height)\n\n    def find_height(col):\n        for r in range(board_height + 1):\n            if board[r][col] == 1:\n                return r\n        return 0\n\n    def valid_placement(col, height):\n        return board[height][col] == 0\n\n    def remove_full_rows(start_row):\n        nonlocal board_height\n        row = start_row\n        while row < board_height:\n            if all(board[row][c] == 1 for c in range(5)):\n                # Remove full row\n                for r in range(row, board_height - 1):\n                    board[r] = board[r + 1][:]\n                board[board_height - 1] = [0] * 5\n                board_height -= 1\n            else:\n                row += 1\n\n    # Read input\n    N = int(input())\n    for _ in range(N):\n        block_info = list(map(int, input().split()))\n        \n        if len(block_info) == 2:  # Horizontal block\n            drop_block((block_info[1], 0))\n        else:  # Vertical block\n            drop_block((block_info[1], block_info[0]))\n\n    # Count remaining blocks\n    total_blocks = sum(sum(row) for row in board)\n    print(total_blocks)\n\nsolve_tetris()",
    "timestamp": "2025-08-12 23:51:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    width = 5\n    board = []\n    n = int(input())\n    blocks = []\n    for _ in range(n):\n        parts = input().split()\n        l = int(parts[0])\n        s = parts[1]\n        blocks.append((l, s))\n    \n    for l, s in blocks:\n        if s == 'L':\n            # Left-aligned horizontal block\n            col = 0\n            row = 0\n            # Find the highest row where any of the l columns is occupied\n            for r in range(len(board) + 1):\n                if r == len(board):\n                    break\n                for c in range(col, col + l):\n                    if c < width and board[r][c] == 1:\n                        row = r\n                        break\n                else:\n                    continue\n                break\n            # Place the block\n            for _ in range(len(board), row + l - 1 + 1):\n                board.append([0] * width)\n            for c in range(col, col + l):\n                if c < width:\n                    board[row][c] = 1\n        elif s == 'R':\n            # Right-aligned horizontal block\n            col = width - l\n            row = 0\n            for r in range(len(board) + 1):\n                if r == len(board):\n                    break\n                for c in range(col, col + l):\n                    if c >= 0 and board[r][c] == 1:\n                        row = r\n                        break\n                else:\n                    continue\n                break\n            for _ in range(len(board), row + l - 1 + 1):\n                board.append([0] * width)\n            for c in range(col, col + l):\n                if c >= 0:\n                    board[row][c] = 1\n        elif s == 'C':\n            # Centered horizontal block\n            col = (width - l) // 2\n            row = 0\n            for r in range(len(board) + 1):\n                if r == len(board):\n                    break\n                for c in range(col, col + l):\n                    if 0 <= c < width and board[r][c] == 1:\n                        row = r\n                        break\n                else:\n                    continue\n                break\n            for _ in range(len(board), row + l - 1 + 1):\n                board.append([0] * width)\n            for c in range(col, col + l):\n                if 0 <= c < width:\n                    board[row][c] = 1\n        else:  # vertical\n            col = int(s) - 1\n            row = 0\n            for r in range(len(board) + 1):\n                if r == len(board):\n                    break\n                if board[r][col] == 1:\n                    row = r\n                    break\n            for _ in range(len(board), row + l):\n                board.append([0] * width)\n            for r in range(row, row + l):\n                board[r][col] = 1\n        \n        # Check for full rows\n        full_rows = []\n        for r in range(len(board)):\n            if all(cell == 1 for cell in board[r]):\n                full_rows.append(r)\n        # Remove full rows and shift above rows down\n        for r in sorted(full_rows, reverse=True):\n            del board[r]\n    \n    total_blocks = 0\n    for row in board:\n        total_blocks += sum(row)\n    print(total_blocks)\n\nsolve()",
    "timestamp": "2025-08-12 23:52:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nconst int WIDTH = 5;\nconst int MAX_HEIGHT = 1000;\n\nvoid dropBlock(vector<vector<int>>& board, int type, int length, int position) {\n    int height = board.size();\n    \n    if (type == 0) { // Horizontal\n        int rowToDrop = height;\n        \n        for (int i = 0; i < height; ++i) {\n            bool canDrop = true;\n            for (int j = position; j < position + length; ++j) {\n                if (board[i][j] == 1) {\n                    canDrop = false;\n                    break;\n                }\n            }\n            if (!canDrop) {\n                rowToDrop = i;\n                break;\n            }\n        }\n        \n        if (rowToDrop == height) {\n            board.push_back(vector<int>(WIDTH, 0));\n        }\n        \n        for (int j = position; j < position + length; ++j) {\n            board[rowToDrop][j] = 1;\n        }\n    } else { // Vertical\n        int rowToDrop = height - length;\n        for (int i = rowToDrop; i < height; ++i) {\n            if (board[i][position] == 1) {\n                rowToDrop = i - length;\n                break;\n            }\n        }\n\n        for (int i = 0; i < length; ++i) {\n            if (rowToDrop + i >= height) {\n                board.push_back(vector<int>(WIDTH, 0));\n            }\n            board[rowToDrop + i][position] = 1;\n        }\n    }\n    \n    // Remove fully occupied rows\n    vector<vector<int>> newBoard;\n    for (int i = 0; i < board.size(); ++i) {\n        bool fullRow = true;\n        for (int j = 0; j < WIDTH; ++j) {\n            if (board[i][j] == 0) {\n                fullRow = false;\n                break;\n            }\n        }\n        if (!fullRow) {\n            newBoard.push_back(board[i]);\n        }\n    }\n    board = newBoard;\n}\n\nint main() {\n    int numBlocks;\n    cin >> numBlocks;\n    vector<vector<int>> board;\n    \n    for (int i = 0; i < numBlocks; ++i) {\n        int type, length, position;\n        cin >> type >> length >> position;\n        dropBlock(board, type, length, position);\n    }\n    \n    int remainingBlocks = 0;\n    for (const auto& row : board) {\n        for (int j = 0; j < WIDTH; ++j) {\n            if (row[j] == 1) {\n                remainingBlocks++;\n            }\n        }\n    }\n\n    cout << remainingBlocks << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 10:51:37"
  }
]