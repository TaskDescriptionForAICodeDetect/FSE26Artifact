[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    int initial[N][N];\n    int order[N * N];\n    int position[N * N + 1];\n    \n    // Read initial seating arrangement\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &initial[i][j]);\n            position[initial[i][j]] = i * N + j;\n        }\n    }\n    \n    // Read exit order\n    for (int i = 0; i < N * N; i++) {\n        scanf(\"%d\", &order[i]);\n    }\n    \n    int hate_count = 0;\n    int occupied[N * N + 1] = {0};\n    \n    for (int k = 0; k < N * N; k++) {\n        int x = order[k];\n        int x_row = position[x] / N;\n        int x_col = position[x] % N;\n        \n        for (int i = 0; i < N * N; i++) {\n            if (occupied[i] && i != x) {\n                int y_row = position[i] / N;\n                int y_col = position[i] % N;\n                \n                if ((x_row < y_row) || \n                    (x_row == y_row && x_col < y_col)) {\n                    hate_count++;\n                }\n            }\n        }\n        \n        occupied[x] = 1;\n    }\n    \n    printf(\"%d\\n\", hate_count);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:32:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    int **grid = (int **)malloc(N * sizeof(int *));\n    for (int i = 0; i < N; i++) {\n        grid[i] = (int *)malloc(N * sizeof(int));\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n    \n    int *exitOrder = (int *)malloc(N * N * sizeof(int));\n    for (int i = 0; i < N * N; i++) {\n        scanf(\"%d\", &exitOrder[i]);\n    }\n    \n    int *rowPos = (int *)malloc((N * N + 1) * sizeof(int));\n    int *colPos = (int *)malloc((N * N + 1) * sizeof(int));\n    \n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            rowPos[grid[i][j]] = i;\n            colPos[grid[i][j]] = j;\n        }\n    }\n    \n    int *hateCount = (int *)calloc(N * N + 1, sizeof(int));\n    int totalHate = 0;\n    \n    for (int i = 0; i < N * N; i++) {\n        int x = exitOrder[i];\n        int xRow = rowPos[x];\n        int xCol = colPos[x];\n        \n        for (int j = i + 1; j < N * N; j++) {\n            int y = exitOrder[j];\n            int yRow = rowPos[y];\n            int yCol = colPos[y];\n            \n            if ((yRow == xRow && yCol < xCol) || (yCol == xCol && yRow < xRow)) {\n                hateCount[x]++;\n                totalHate++;\n            }\n        }\n    }\n    \n    printf(\"%d\\n\", totalHate);\n    \n    for (int i = 0; i < N; i++) {\n        free(grid[i]);\n    }\n    free(grid);\n    free(exitOrder);\n    free(rowPos);\n    free(colPos);\n    free(hateCount);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:32:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> cinema(N, vector<int>(N));\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> cinema[i][j];\n        }\n    }\n\n    vector<int> exit_order(N * N);\n    for (int i = 0; i < N * N; ++i) {\n        cin >> exit_order[i];\n    }\n\n    vector<pair<int, int>> positions(N * N + 1);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            positions[cinema[i][j]] = {i, j};\n        }\n    }\n\n    unordered_set<int> exited;\n    int hate_pairs = 0;\n\n    for (int x : exit_order) {\n        auto [x_row, x_col] = positions[x];\n        for (int y : exited) {\n            auto [y_row, y_col] = positions[y];\n            if ((y_row == x_row && y_col < x_col) || (y_col == x_col && y_row < x_row)) {\n                hate_pairs++;\n            }\n        }\n        exited.insert(x);\n    }\n\n    cout << hate_pairs << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:32:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CinemaHatePairs {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[][] cinema = new int[N][N];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                cinema[i][j] = scanner.nextInt();\n            }\n        }\n        int[] exitOrder = new int[N * N];\n        for (int i = 0; i < N * N; i++) {\n            exitOrder[i] = scanner.nextInt();\n        }\n        scanner.close();\n\n        Map<Integer, int[]> positionMap = new HashMap<>();\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                positionMap.put(cinema[i][j], new int[]{i, j});\n            }\n        }\n\n        Set<Integer> exited = new HashSet<>();\n        int hatePairs = 0;\n\n        for (int x : exitOrder) {\n            int[] pos = positionMap.get(x);\n            int xRow = pos[0];\n            int xCol = pos[1];\n            for (int i = xRow - 1; i >= 0; i--) {\n                int y = cinema[i][xCol];\n                if (!exited.contains(y)) {\n                    hatePairs++;\n                }\n            }\n            for (int i = xRow + 1; i < N; i++) {\n                int y = cinema[i][xCol];\n                if (!exited.contains(y)) {\n                    hatePairs++;\n                }\n            }\n            for (int j = xCol - 1; j >= 0; j--) {\n                int y = cinema[xRow][j];\n                if (!exited.contains(y)) {\n                    hatePairs++;\n                }\n            }\n            for (int j = xCol + 1; j < N; j++) {\n                int y = cinema[xRow][j];\n                if (!exited.contains(y)) {\n                    hatePairs++;\n                }\n            }\n            exited.add(x);\n        }\n\n        System.out.println(hatePairs);\n    }\n}",
    "timestamp": "2025-08-05 22:33:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CinemaHatred {\n    public static int countHatredPairs(int N, int[] initialArrangement, int[] exitOrder) {\n        int[] position = new int[N * N + 1];\n        int[] currentRow = new int[N + 1];\n        int hatredPairs = 0;\n\n        // Initialize positions\n        for (int i = 0; i < N * N; i++) {\n            position[initialArrangement[i]] = i;\n            currentRow[i / N + 1] |= 1 << (i % N);\n        }\n\n        for (int x : exitOrder) {\n            int xPos = position[x];\n            int xRow = xPos / N + 1;\n            int xCol = xPos % N;\n\n            // Check for hatred pairs in the same row\n            for (int y = 1; y <= N * N; y++) {\n                if (x == y) continue;\n                int yPos = position[y];\n                int yRow = yPos / N + 1;\n                int yCol = yPos % N;\n\n                if (yRow == xRow && \n                    ((currentRow[xRow] & (1 << xCol)) != 0) && \n                    ((currentRow[xRow] & (1 << yCol)) != 0) &&\n                    ((xCol < yCol && x > y) || (xCol > yCol && x < y))) {\n                    hatredPairs++;\n                }\n            }\n\n            // Remove x from current row\n            currentRow[xRow] &= ~(1 << xCol);\n        }\n\n        return hatredPairs;\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        int N = 3;\n        int[] initialArrangement = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n        int[] exitOrder = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n        System.out.println(countHatredPairs(N, initialArrangement, exitOrder));\n    }\n}",
    "timestamp": "2025-08-05 22:33:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<vector<int>> seats(N, vector<int>(N));\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            cin >> seats[i][j];\n        }\n    }\n    \n    vector<int> exit_order(N * N);\n    for (int i = 0; i < N * N; i++) {\n        cin >> exit_order[i];\n    }\n    \n    unordered_set<int> seated;\n    int hate_count = 0;\n    \n    for (int person : exit_order) {\n        int row = -1, col = -1;\n        \n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (seats[i][j] == person) {\n                    row = i;\n                    col = j;\n                    break;\n                }\n            }\n            if (row != -1) break;\n        }\n        \n        for (int occupant : seated) {\n            int orow = -1, ocol = -1;\n            \n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    if (seats[i][j] == occupant) {\n                        orow = i;\n                        ocol = j;\n                        break;\n                    }\n                }\n                if (orow != -1) break;\n            }\n            \n            if ((row < orow) || (row == orow && col < ocol)) {\n                hate_count++;\n            }\n        }\n        \n        seated.insert(person);\n    }\n    \n    cout << hate_count << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:33:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def compute_hate_pairs(N, arrangement, exit_order):\n    seat_position = {}\n    for i in range(N):\n        for j in range(N):\n            seat_position[arrangement[i][j]] = (i, j)\n    \n    hate_pairs = 0\n    exited = set()\n    for x in exit_order:\n        x_i, x_j = seat_position[x]\n        for y in exited:\n            y_i, y_j = seat_position[y]\n            if (x_i > y_i and x_j == y_j) or (x_j > y_j and x_i == y_i):\n                hate_pairs += 1\n        exited.add(x)\n    \n    return hate_pairs\n\n# Example usage:\n# N = 3\n# arrangement = [\n#     [1, 2, 3],\n#     [4, 5, 6],\n#     [7, 8, 9]\n# ]\n# exit_order = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n# print(compute_hate_pairs(N, arrangement, exit_order))  # Output: 12",
    "timestamp": "2025-08-13 11:12:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class CinemaHatePairs {\n    public static void main(String[] args) {\n        // Example Input\n        int N = 3;\n        int[][] seating = {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        };\n        int[] leaveOrder = {9, 8, 7, 4, 5, 6, 1, 2, 3};\n\n        System.out.println(countHatePairs(N, seating, leaveOrder));\n    }\n\n    private static int countHatePairs(int N, int[][] seating, int[] leaveOrder) {\n        Map<Integer, Position> positions = new HashMap<>();\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                positions.put(seating[i][j], new Position(i, j));\n            }\n        }\n\n        Set<Integer> seen = new HashSet<>();\n        int hatePairs = 0;\n        \n        for (int viewer : leaveOrder) {\n            Position pos = positions.get(viewer);\n            int viewerRow = pos.row;\n            int viewerCol = pos.col;\n            \n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    if (seen.contains(seating[i][j]) && \n                        (i - viewerRow) * (j - viewerCol) > 0) { // diagonal towards where x is headed\n                        hatePairs++;\n                    }\n                }\n            }\n\n            seen.add(viewer);\n        }\n        \n        return hatePairs;\n    }\n    \n    private static class Position {\n        int row, col;\n        \n        Position(int row, int col) {\n            this.row = row;\n            this.col = col;\n        }\n    }\n}",
    "timestamp": "2025-08-13 11:12:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 1000\n\ntypedef struct {\n    int row;\n    int seat;\n} Viewer;\n\nint main() {\n    int N;\n    int arrangement[MAX_N][MAX_N];\n    int exitOrder[MAX_N * MAX_N];\n    Viewer viewers[MAX_N * MAX_N];\n\n    // Read size N and cinema arrangement\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d\", &arrangement[i][j]);\n            viewers[arrangement[i][j] - 1] = (Viewer){i, j};\n        }\n    }\n    \n    // Read exit order\n    for (int i = 0; i < N * N; i++) {\n        scanf(\"%d\", &exitOrder[i]);\n    }\n\n    int hate_count = 0;\n\n    // Iterate over exit order and calculate hate pairs\n    for (int i = 0; i < N * N; i++) {\n        int current_viewer_id = exitOrder[i] - 1;\n        Viewer current_viewer = viewers[current_viewer_id];\n        for (int j = i + 1; j < N * N; j++) {\n            int passing_viewer_id = exitOrder[j] - 1;\n            Viewer passing_viewer = viewers[passing_viewer_id];\n\n            if (passing_viewer.row < current_viewer.row && passing_viewer.seat == current_viewer.seat) {\n                hate_count++;\n            }\n        }\n    }\n\n    printf(\"%d\\n\", hate_count);\n    return 0;\n}",
    "timestamp": "2025-08-13 11:13:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countHatePairs(N, arrangement, exitOrder) {\n    const exitIndex = {};\n    for (let i = 0; i < exitOrder.length; ++i) {\n        exitIndex[exitOrder[i]] = i;\n    }\n    \n    let hateCount = 0;\n    for (let row = 0; row < N; ++row) {\n        for (let seat = 0; seat < N; ++seat) {\n            const viewer = arrangement[row][seat];\n            const viewerExitIdx = exitIndex[viewer];\n            for (let r = row + 1; r < N; ++r) {\n                for (let s = seat + 1; s < N; ++s) {\n                    const y = arrangement[r][s];\n                    const yExitIdx = exitIndex[y];\n                    if (yExitIdx < viewerExitIdx) {\n                        hateCount++;\n                    }\n                }\n            }\n        }\n    }\n\n    return hateCount;\n}",
    "timestamp": "2025-08-13 11:13:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_hated_pairs(N, initial_arrangement, exit_order):\n    # Create a mapping of seat positions to viewers\n    seat_map = {}\n    for row in range(N):\n        for seat in range(N):\n            seat_map[(row, seat)] = initial_arrangement[row][seat]\n\n    # Reverse mapping to track viewer's initial seat\n    viewer_initial_seat = {}\n    for (row, seat), viewer in seat_map.items():\n        viewer_initial_seat[viewer] = (row, seat)\n\n    # Track current seat occupancy\n    current_seats = set(seat_map.values())\n\n    # Track hated pairs\n    hated_pairs = set()\n\n    # Process exit order\n    for exiting_viewer in exit_order:\n        # Find current seat of exiting viewer\n        exiting_seat = None\n        for pos, viewer in seat_map.items():\n            if viewer == exiting_viewer:\n                exiting_seat = pos\n                break\n\n        # Check who the exiting viewer passes over\n        initial_seat = viewer_initial_seat[exiting_viewer]\n        for (row, seat), viewer in seat_map.items():\n            if viewer in current_seats and viewer != exiting_viewer:\n                # Check if this viewer is on the path\n                if is_between(initial_seat, exiting_seat, (row, seat)):\n                    hated_pairs.add((exiting_viewer, viewer))\n\n        # Remove exiting viewer from current seats\n        current_seats.remove(exiting_viewer)\n\n    return len(hated_pairs)\n\ndef is_between(start, end, point):\n    start_row, start_seat = start\n    end_row, end_seat = end\n    point_row, point_seat = point\n\n    # Horizontal movement\n    if start_row == end_row:\n        return (start_row == point_row and \n                min(start_seat, end_seat) <= point_seat <= max(start_seat, end_seat))\n    \n    # Vertical movement\n    if start_seat == end_seat:\n        return (start_seat == point_seat and \n                min(start_row, end_row) <= point_row <= max(start_row, end_row))\n    \n    return False",
    "timestamp": "2025-08-13 11:13:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function calculateHatePairs(N, initialArrangement, exitOrder) {\n    let seatMap = new Map();\n    let hatePairs = 0;\n    \n    // Create initial seat mapping\n    for (let row = 0; row < N; row++) {\n        for (let seat = 0; seat < N; seat++) {\n            seatMap.set(initialArrangement[row][seat], [row, seat]);\n        }\n    }\n    \n    let occupiedSeats = new Set(initialArrangement.flat());\n    \n    for (let viewer of exitOrder) {\n        let [currentRow, currentSeat] = seatMap.get(viewer);\n        \n        // Check pairs who will hate this viewer\n        for (let occupiedViewer of occupiedSeats) {\n            if (occupiedViewer === viewer) continue;\n            \n            let [occupiedRow, occupiedSeat] = seatMap.get(occupiedViewer);\n            \n            // Check if current viewer passes over other viewer\n            if ((occupiedRow < currentRow) || \n                (occupiedRow === currentRow && occupiedSeat < currentSeat)) {\n                hatePairs++;\n            }\n        }\n        \n        occupiedSeats.delete(viewer);\n    }\n    \n    return hatePairs;\n}",
    "timestamp": "2025-08-13 11:13:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    \n    N = int(data[0])\n    grid = []\n    index = 1\n    for _ in range(N):\n        row = list(map(int, data[index:index+N]))\n        grid.append(row)\n        index += N\n    \n    exit_order = list(map(int, data[index:index+N*N]))\n    \n    pos = {}\n    for i in range(N):\n        for j in range(N):\n            viewer = grid[i][j]\n            pos[viewer] = (i, j)\n    \n    hate_count = 0\n    exited = set()\n    \n    for x in exit_order:\n        x_row, x_col = pos[x]\n        for y in exited:\n            y_row, y_col = pos[y]\n            if (y_row == x_row and y_col < x_col) or (y_col == x_col and y_row < x_row):\n                hate_count += 1\n        exited.add(x)\n    \n    print(hate_count)\n\nsolve()",
    "timestamp": "2025-08-13 11:13:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countHatePairs(N, arrangement, exitOrder) {\n    let hatePairs = 0;\n    let occupied = new Array(N).fill().map(() => new Array(N).fill(false));\n    let positions = new Map();\n    \n    // Initialize positions and occupied seats\n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++) {\n            const viewer = arrangement[i][j];\n            positions.set(viewer, { row: i, col: j });\n            occupied[i][j] = true;\n        }\n    }\n    \n    for (const x of exitOrder) {\n        const { row, col } = positions.get(x);\n        occupied[row][col] = false;\n        \n        // Check all seats to the right in the same row\n        for (let j = col + 1; j < N; j++) {\n            if (occupied[row][j]) {\n                hatePairs++;\n            }\n        }\n    }\n    \n    return hatePairs;\n}",
    "timestamp": "2025-08-13 11:13:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> cinema(N, vector<int>(N));\n    unordered_map<int, pair<int, int>> viewerPosition;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> cinema[i][j];\n            viewerPosition[cinema[i][j]] = {i, j};\n        }\n    }\n\n    vector<int> exitOrder(N * N);\n    for (int i = 0; i < N * N; ++i) {\n        cin >> exitOrder[i];\n    }\n\n    int hatePairs = 0;\n    vector<vector<bool>> occupied(N, vector<bool>(N, true));\n\n    for (int e = 0; e < N * N; ++e) {\n        int leavingViewer = exitOrder[e];\n        auto [row, col] = viewerPosition[leavingViewer];\n        for (int r = 0; r <= row; ++r) {\n            for (int c = 0; c <= col; ++c) {\n                if (occupied[r][c]) {\n                    int currentViewer = cinema[r][c];\n                    if (currentViewer != leavingViewer) {\n                        ++hatePairs;\n                    }\n                }\n            }\n        }\n        occupied[row][col] = false;\n    }\n\n    cout << hatePairs << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:02:51"
  }
]