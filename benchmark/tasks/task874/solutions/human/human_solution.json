[
  {
    "language": "Fortran",
    "code": "module mod_segment_tree\n  implicit none\n  integer(8), parameter :: DEFAULT = -100000000000000000_8\n  type segment_tree\n    integer :: n, p\n    integer(8), pointer :: arr(:) => null()\n  end type segment_tree\n  private\n  public :: segment_tree, init_segtree, update, query, DEFAULT\ncontains\n  integer(8) function op(x,y)\n    implicit none\n    integer(8) :: x, y\n    op = max(x,y)\n    return\n  end function op\n  subroutine init_segtree(st,n)\n    implicit none\n    type(segment_tree) :: st\n    integer, intent(in) :: n\n    integer :: p\n    p = 1\n    do while (p.lt.n)\n      p = 2*p\n    end do\n    st%n = n\n    st%p = p\n    allocate(st%arr(2*p-1))\n    st%arr = DEFAULT\n    return\n  end subroutine init_segtree\n  subroutine update(st,i,v)\n    implicit none\n    type(segment_tree) :: st\n    integer, intent(in) :: i\n    integer(8), intent(in) :: v\n    integer :: x\n    x = i+st%p-1\n    st%arr(x) = v\n    do while (x > 1)\n      x = x/2\n      st%arr(x) = op(st%arr(2*x),st%arr(2*x+1))\n    end do\n    return\n  end subroutine update\n  integer(8) function query(st,a,b)\n    type(segment_tree) :: st\n    integer, intent(in) :: a, b\n    integer :: l, r\n    query = DEFAULT\n    l = a+st%p-1\n    r = b+st%p-1\n    do while (l <= r)\n      if (mod(l,2) == 1) then\n        query = op(query,st%arr(l))\n        l = l+1\n      end if\n      if (mod(r,2) == 0) then\n        query = op(query,st%arr(r))\n        r = r-1\n      end if\n      l = l/2\n      r = r/2\n    end do\n    return\n  end function query\nend module mod_segment_tree\nprogram paired_parentheses\n  use mod_segment_tree\n  implicit none\n  type(segment_tree) :: st1, st2\n  integer :: n, q, p, pnum = 0, i\n  integer(8) :: a(200000) = 0_8, b(200000) = 0_8, x, y\n  integer(8) :: atot, ptot = 0_8\n  read(*,*) n, q\n  read(*,*) a(1:2*n)\n  read(*,*) b(1:2*n)\n  call init_segtree(st1,2*n)\n  call init_segtree(st2,2*n)\n  atot = sum(a(1:2*n))\n  do i = 2, 2*n-1\n    if (b(i) >= a(i)) then\n      ptot = ptot+b(i)-a(i)\n      pnum = pnum+1\n      call update(st1,i,a(i)-b(i))\n    else\n      call update(st2,i,b(i)-a(i))\n    end if\n  end do\n  do i = 1, q\n    read(*,*) p, x, y\n    atot = atot-a(p)\n    if ((.not.(p == 1 .or. p == 2*n)).and.(b(p) >= a(p))) then\n      ptot = ptot-b(p)+a(p)\n      pnum = pnum-1\n    end if\n    a(p) = x\n    b(p) = y\n    atot = atot+a(p)\n    if ((.not.(p == 1 .or. p == 2*n)).and.(b(p) >= a(p))) then\n      ptot = ptot+b(p)-a(p)\n      pnum = pnum+1\n    end if\n    if (.not.(p == 1 .or. p == 2*n)) then\n      if (b(p) >= a(p)) then\n        call update(st1,p,DEFAULT)\n        call update(st2,p,a(p)-b(p))\n      else\n        call update(st1,p,b(p)-a(p))\n        call update(st2,p,DEFAULT)\n      end if\n    end if\n    if (mod(pnum,2) == 0) then\n      write(*,'(i0)') atot+ptot\n    else\n      write(*,'(i0)') atot+ptot+max(query(st1,2,2*n-1),query(st2,2,2*n-1))\n    end if\n  end do\n  stop\nend program paired_parentheses"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\n#define int ll\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = 1e18;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nsigned main() {\n  int n, q;\n  cin >> n >> q;\n  n *= 2;\n  vl a(n), b(n);\n  rep (i, n) {\n    cin >> a[i];\n  }\n  rep (i, n) {\n    cin >> b[i];\n  }\n  set<pii> aa, bb;\n  ll ans = 0;\n  rep (i, n) {\n    if (i == 0) {\n      ans += a[i];\n      continue;\n    }\n    if (i == n - 1) {\n      ans += a[i];\n      continue;\n    }\n    if (a[i] >= b[i]) {\n      ans += a[i];\n      aa.insert(pii(a[i] - b[i], i));\n    }\n    else {\n      ans += b[i];\n      bb.insert(pii(b[i] - a[i], i));\n    }\n  }\n  if ((int)aa.size() % 2) {\n    auto itra = aa.begin();\n    auto itrb = bb.begin();\n    pii a_s = *itra, b_s = *itrb;\n    if (a_s.first >= b_s.first) {\n      bb.erase(b_s);\n      int idx = b_s.second;\n      ans -= b[idx];\n      ans += a[idx];\n      aa.insert(pii(a[idx] - b[idx], idx));\n    }\n    else {\n      aa.erase(a_s);\n      int idx = a_s.second;\n      ans -= a[idx];\n      ans += b[idx];\n      bb.insert(pii(b[idx] - a[idx], idx));\n    }\n  }\n  while (q--) {\n    /*\n    cout << \"aa \";\n    for (auto itr = aa.begin(); itr != aa.end(); itr++) {\n      cout << *itr << \" \";\n    }\n    cout << endl;\n    cout << \"bb \";\n    for (auto itr = bb.begin(); itr != bb.end(); itr++) {\n      cout << *itr << \" \";\n    }\n    //*/\n    int p, x, y;\n    cin >> p >> x >> y;\n    p--;\n    if (p == 0 || p == n - 1) {\n      ans -= a[p];\n      a[p] = x;\n      b[p] = y;\n      ans += a[p];\n      cout << ans << endl;\n      continue;\n    }\n    if (aa.count(pii(a[p] - b[p], p))) {\n      aa.erase(pii(a[p] - b[p], p));\n      ans -= a[p];\n    }\n    else if (bb.count(pii(b[p] - a[p], p))) {\n      bb.erase(pii(b[p] - a[p], p));\n      ans -= b[p];\n    }\n    else {\n      assert(false);\n    }\n    a[p] = x;\n    b[p] = y;\n    if (a[p] >= b[p]) {\n      ans += a[p];\n      aa.insert(pii(a[p] - b[p], p));\n    }\n    else {\n      ans += b[p];\n      bb.insert(pii(b[p] - a[p], p));\n    }\n    if ((int)aa.size() % 2) {\n      auto itra = aa.begin();\n      auto itrb = bb.begin();\n      pii a_s = *itra, b_s = *itrb;\n      if (a_s.first >= b_s.first) {\n        bb.erase(b_s);\n        int idx = b_s.second;\n        ans -= b[idx];\n        ans += a[idx];\n        aa.insert(pii(a[idx] - b[idx], idx));\n      }\n      else {\n        aa.erase(a_s);\n        int idx = a_s.second;\n        ans -= a[idx];\n        ans += b[idx];\n        bb.insert(pii(b[idx] - a[idx], idx));\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define regsiter register\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\n#include<set>\nint a[211111];\nint v[211111];\nstd::multiset<int> pos,neg;\nlong long sp;\nint main()\n{\n\tint n=io::F()<<1,Q=io::F();\n\tlong long ans=0;\n\tfor(register int i=1;i<=n;++i)ans+=a[i]=io::F();\n\tio::F();\n\tfor(register int i=2;i<n;++i)v[i]=io::F()-a[i];\n\tio::F();\n\tfor(register int i=2;i<n;++i)v[i]>=0?sp+=v[i],pos.insert(v[i]):neg.insert(v[i]);\n\tfor(register int i=1;i<=Q;++i)\n\t{\n\t\tint p=io::F(),x=io::F(),y=io::F();\n\t\tans-=a[p];\n\t\tans+=a[p]=x;\n\t\tif(p==1||p==n)goto skip;\n\t\tv[p]>=0?sp-=v[p],pos.erase(pos.find(v[p])):neg.erase(neg.find(v[p]));\n\t\tv[p]=y-x;\n\t\t//for(std::multiset<int>::iterator it=pos.begin();it!=pos.end();++it)printf(\"%d\\n\",*it);\n\t\tv[p]>=0?sp+=v[p],pos.insert(v[p]):neg.insert(v[p]);\n\t\tskip:;\n\t\tif(pos.size()&1)\n\t\t{\n\t\t\tif(*pos.begin()>-*neg.rbegin())printf(\"%lld\\n\",ans+sp+*neg.rbegin());\n\t\t\t\telse printf(\"%lld\\n\",ans+sp-*pos.begin());\n\t\t}\n\t\telse printf(\"%lld\\n\",ans+sp);\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, Q, pos, x, y, a[200009], b[200009]; map<int, int> d;\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcin >> N >> Q;\n\tfor (int i = 0; i < 2 * N; i++) cin >> a[i];\n\tfor (int i = 0; i < 2 * N; i++) cin >> b[i];\n\tlong long s = 0; int c = 0;\n\tfor (int i = 0; i < 2 * N; i++) {\n\t\tif (i == 0 || i == 2 * N - 1) s += a[i];\n\t\telse {\n\t\t\tif (a[i] > b[i]) c++;\n\t\t\ts += max(a[i], b[i]);\n\t\t\td[abs(a[i] - b[i])]++;\n\t\t}\n\t}\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> pos >> x >> y; pos--;\n\t\tif (pos == 0 || pos == 2 * N - 1) {\n\t\t\ts -= a[pos];\n\t\t\ta[pos] = x; b[pos] = y;\n\t\t\ts += a[pos];\n\t\t}\n\t\telse {\n\t\t\tif (a[pos] > b[pos]) c--;\n\t\t\ts -= max(a[pos], b[pos]);\n\t\t\td[abs(a[pos] - b[pos])]--;\n\t\t\tif (d[abs(a[pos] - b[pos])] == 0) d.erase(abs(a[pos] - b[pos]));\n\t\t\ta[pos] = x; b[pos] = y;\n\t\t\tif (a[pos] > b[pos]) c++;\n\t\t\ts += max(a[pos], b[pos]);\n\t\t\td[abs(a[pos] - b[pos])]++;\n\t\t}\n\t\tcout << s - (c & 1 ? d.begin()->first : 0) << '\\n';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\n\nint main(){\n    int n,q;\n    cin>>n>>q;\n    n*=2;\n    ll a[n],b[n];\n    rep(i,n)cin>>a[i];\n    rep(i,n)cin>>b[i];\n    ll ans=a[0]+a[n-1];\n    int posi=0,ze=0;\n    multiset<ll> st;\n    rep(i,n-2){\n        ans+=max(a[i+1],b[i+1]);\n        if(a[i+1]>b[i+1])posi++;\n        st.insert(abs(a[i+1]-b[i+1]));\n    }\n    rep(i,q){\n        ll p,x,y;\n        cin>>p>>x>>y;\n        p--;\n        if(p==0||p==n-1){\n            ans+=(ll)(x-a[p]);\n            a[p]=x;\n            cout<<ans<<endl;\n            continue;\n        }\n        ans+=max(x,y);\n        ans-=max(a[p],b[p]);\n        auto it=st.find(abs(a[p]-b[p]));\n        st.erase(it);\n        st.insert(abs(x-y));\n        if(a[p]>b[p])posi--;\n        if(x>y)posi++;\n        a[p]=x;\n        b[p]=y;\n        it=st.begin();\n        if(posi%2==0)cout<<ans<<endl;\n        else cout<<ans-*it<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\nclass LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}};\nvpii factor(int N){vpii r;for(int i=2;i*i<=N;++i){if(N%i==0){r<<pii{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pii{N,1};}return r;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N,Q;cin>>N>>Q;\n\tvi A(2*N);cin>>A;\n\tvi B(2*N);cin>>B;\n\tmultiset<int>po,ne;\n\tll z=sum(A);\n\tfoor(i,1,2*N-2){\n\t\tif(B[i]>=A[i]){\n\t\t\tpo<<B[i]-A[i];\n\t\t\tz+=B[i]-A[i];\n\t\t}else{\n\t\t\tne<<B[i]-A[i];\n\t\t}\n\t}\n\tfr(q,Q){\n\t\tint p,x,y;cin>>p>>x>>y;\n\t\t--p;\n\t\tz+=x-A[p];\n\t\tif(1<=p&&p<=2*N-2){\n\t\t\tif(B[p]>=A[p]){\n\t\t\t\tpo.erase(po.lower_bound(B[p]-A[p]));\n\t\t\t\tz-=B[p]-A[p];\n\t\t\t}else{\n\t\t\t\tne.erase(ne.lower_bound(B[p]-A[p]));\n\t\t\t}\n\t\t\tif(y>=x){\n\t\t\t\tpo<<y-x;\n\t\t\t\tz+=y-x;\n\t\t\t}else{\n\t\t\t\tne<<y-x;\n\t\t\t}\n\t\t}\n\t\tA[p]=x,B[p]=y;\n\t\tif(po.size()%2){\n\t\t\tprint(z+max(-*po.begin(),*--ne.end()));\n\t\t}else{\n\t\t\tprint(z);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<long, int> P;\npriority_queue<P, vector<P>, greater<P>> que_pos;\npriority_queue<P, vector<P>> que_neg;\n\nint main(){\n    long N, Q;\n    long a[200000], b[200000];\n    cin >> N >> Q;\n    for(int i = 0; i < 2*N ; i++){\n        cin >> a[i];\n    }\n    for(int i = 0; i < 2*N ; i++){\n        cin >> b[i];\n    }\n    long sum_a = a[0] + a[2*N-1];\n    long sum_b = 0;\n    int cnt_pos = 0;\n    for(int i = 1; i <= 2*N-2; i++){\n        if(a[i] < b[i]){\n            cnt_pos++;\n            que_pos.push(P(b[i]-a[i], i));\n            sum_b += b[i];\n        }else{\n            que_neg.push(P(b[i]-a[i], i));\n            sum_a += a[i];\n        }\n    }\n    //cout << cnt_pos << endl;\n    //cout << sum_a << ' ' << sum_b << endl;\n    for(int i = 0; i < Q; i++){\n        int p, x, y;\n        cin >> p >> x >> y;\n        p--;\n        if(b[p] > a[p]) {\n            if(p != 0 && p != 2*N-1){\n                cnt_pos--;\n                sum_b -= b[p];\n            }else{\n                sum_a -= a[p];\n            }\n        }else{\n            sum_a -= a[p];\n        }\n        a[p] = x;\n        b[p] = y;\n        if(b[p] > a[p]) {\n            if(p != 0 && p != 2*N-1){\n                cnt_pos++;\n                sum_b += b[p];\n                que_pos.push(P(b[p]-a[p], p));\n            }else{\n                sum_a += a[p];\n            }\n        }else{\n            if(p != 0 && p != 2*N-1){\n                sum_a += a[p];\n                que_neg.push(P(b[p]-a[p], p));\n            }else{\n                sum_a += a[p];\n            }\n        }\n        //cout << sum_a << ' ' << sum_b << endl;        \n        if(cnt_pos%2 == 0){\n            //cout << 'H' << endl;\n            cout << sum_a+sum_b << endl;\n        }else{\n            while(!que_pos.empty()){\n                P top = que_pos.top();\n                int idx = top.second;\n                if(top.first != (b[idx]-a[idx])) que_pos.pop();\n                else break;\n            }\n            while(!que_neg.empty()){\n                P top = que_neg.top();\n                int idx = top.second;\n                if(top.first != (b[idx]-a[idx])) que_neg.pop();\n                else break;\n            }\n            //if(que_neg.empty()) cout << \"neg empty\\n\";\n            //if(que_pos.empty()) cout << \"pos empty\\n\";\n            if(que_neg.top().first+que_pos.top().first >= 0){\n                cout  << sum_a + sum_b + que_neg.top().first << endl;\n            }else{\n                cout  << sum_a + sum_b - que_pos.top().first << endl; \n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\nconst int limit = 100010;\nll a[limit], b[limit];\nconst ll inf = 1LL << 60;\n\n\nmultiset<ll> positive, negative;\nll a_total = 0LL, p_total = 0LL;\n\nint n, q;\n\ninline void add(int i) {\n\ta_total += a[i];\n\tif (i == 0 or i == 2 * n - 1) return;\n\tconst ll val = b[i] - a[i];\n\tif (val >= 0) {\n\t\tpositive.insert(val);\n\t\tp_total += val;\n\t} else {\n\t\tnegative.insert(val);\n\t}\n}\n\ninline void del(int i) {\n\ta_total -= a[i];\n\tif (i == 0 or i == 2 * n - 1) return;\n\tconst ll val = b[i] - a[i];\n\tif (val >= 0) {\n\t\tpositive.erase(val);\n\t\tp_total -= val;\n\t} else {\n\t\tnegative.erase(val);\n\t}\n}\n\nint main(void) {\n\tcin >> n >> q;\n\n\trep(i, 2 * n) cin >> a[i];\n\trep(i, 2 * n) cin >> b[i];\n\n\trep(i, 2 * n) a_total += a[i];\n\n\trep(i, 1, 2 * n - 1) {\n\t\tconst ll val = b[i] - a[i];\n\t\tif (val >= 0) {\n\t\t\tpositive.insert(val);\n\t\t\tp_total += val;\n\t\t} else {\n\t\t\tnegative.insert(val);\n\t\t}\n\t}\n\n\n\trep(loop, q) {\n\t\tll p, x, y;\n\t\tcin >> p >> x >> y;\n\n\t\tdel(p - 1);\n\t\ta[p - 1] = x, b[p - 1] = y;\n\t\tadd(p - 1);\n\n\t\tll ans = -inf;\n\t\tif (positive.size() % 2 == 0) {\n\t\t\tchmax(ans, a_total + p_total);\n\t\t} else {\n\t\t\tconst ll mmax = *prev(end(negative));\n\t\t\tconst ll pmin = *begin(positive);\n\t\t\tchmax(ans, a_total + p_total + mmax);\n\t\t\tchmax(ans, a_total + p_total - pmin);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(LL i=0;i<(LL)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n#define LL long long\n#define pii pair<LL,LL>\n#define pll pair<LL,LL>\n\nusing namespace std;\n\nstruct SegmentTree{\n\n    LL n;\n    vector<LL> data;\n    vector<LL> num;\n    vector<LL> minusmax;\n    vector<LL> plusmin;\n\n    SegmentTree(LL _n){\n        n = 2;\n        while(n<_n)n*=2;\n        data.resize(2*n-1, INT_MIN);\n        num.resize(2*n-1, 0);\n        minusmax.resize(2*n-1, INT_MIN);\n        plusmin.resize(2*n-1, INT_MAX);\n    }\n\n    void set(LL pos, LL x){\n        pos += n-1;\n        data[pos]=x;\n        if(x > 0){\n            num[pos] = 1;\n            plusmin[pos] = x;\n            minusmax[pos] = INT_MIN;\n        }else{\n            num[pos]=0;\n            minusmax[pos] = x;\n            plusmin[pos] = INT_MAX;\n        }\n        while(pos > 0){\n            pos = (pos-1)/2;\n            data[pos] = (max(0LL, data[2*pos +1]) + max(0LL, data[2*pos +2]));\n            num[pos] = num[2*pos +1] + num[2*pos + 2];\n            minusmax[pos] = max(minusmax[2*pos + 1], minusmax[2*pos + 2]);\n            plusmin[pos] = min(plusmin[2*pos + 1], plusmin[2*pos + 2]);\n        }\n    }\n\n    LL getSum(LL l, LL r, LL a=0, LL b=-1, LL pos=0){\n        if(b<0)b=n;\n        if(l>=b || r <= a)return 0;\n        if(l<=a && r <= b)return max(0LL,data[pos]);\n        return getSum(l, r, a, (a+b)/2, pos*2+1) + getSum(l, r, (a+b)/2, b, pos*2+2);\n    }\n    LL getNum(LL l,LL r, LL a=0, LL b=-1, LL pos=0){\n        if(b<0)b=n;\n        if(l>=b || r <= a)return 0;\n        if(l<=a && r <= b)return num[pos];\n        return getNum(l, r, a, (a+b)/2, pos*2+1) + getNum(l, r, (a+b)/2, b, pos*2+2);\n    }\n    LL getMinusMax(LL l,LL r,LL a=0, LL b=-1, LL pos=0){\n        if(b<0)b=n;\n        if(l>=b || r <= a)return INT_MIN;\n        if(l<=a && r <= b)return minusmax[pos];\n        return max(getMinusMax(l, r, a, (a+b)/2, pos*2+1) ,getMinusMax(l, r, (a+b)/2, b, pos*2+2));\n    }\n    LL getPlusMin(LL l,LL r,LL a=0, LL b=-1, LL pos=0){\n        if(b<0)b=n;\n        if(l>=b || r <= a)return INT_MAX;\n        if(l<=a && r <= b)return plusmin[pos];\n        return min(getPlusMin(l, r, a, (a+b)/2, pos*2+1) ,getPlusMin(l, r, (a+b)/2, b, pos*2+2));\n    }\n\n    void printData(){\n        cout<<endl;\n        REP(i,n)cout<<n-1+i<<\" \"<<data[n-1+i]<<endl;\n        cout<<endl;\n    }\n};\n\n\nint main(){\n\n    LL N,Q;cin>>N>>Q;\n    LL ans=0;\n    LL a[2*N], b[2*N];\n\n    REP(i,2*N)cin>>a[i];\n    REP(i,2*N)cin>>b[i];\n\n    if(N==1){\n        while(Q--){\n            LL p,x,y;cin>>p>>x>>y;\n            a[--p]=x;\n            ans = a[0]+a[1];\n            cout<<ans<<endl;\n        }\n    }else{\n        REP(i,2*N)ans += a[i];\n        SegmentTree st(2*N-2);\n        REP(i,2*N-2)st.set(i, b[i+1]-a[i+1]);\n\n        while(Q--){\n            LL p,x,y;cin>>p>>x>>y;\n            ans -= a[--p];\n            a[p]=x;\n            b[p]=y;\n            ans += a[p];\n            if(p != 0 && p != 2*N-1)st.set(p-1, y-x);\n\n            LL res = ans + st.getSum(0,2*N-2);\n            if(st.getNum(0,2*N-2)%2==1){\n                res = max(res - st.getPlusMin(0,2*N-2), res + st.getMinusMax(0,2*N-2));\n            }\n\n\n            cout<<res<<endl;\n\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\ntypedef long long ll;\n\nusing namespace std;\n\nint N, Q;\nll A[200010], B[200010];\nmultiset<ll> S;\n\nint main() {\n\tcin >> N >> Q;\n\trep(i, 0, 2 * N) cin >> A[i];\n\trep(i, 0, 2 * N) cin >> B[i];\n\n\tll ans = 0; bool odd = false;\n\tans += A[0] + A[2 * N - 1];\n\trep(i, 1, 2 * N - 1) {\n\t\tans += max(A[i], B[i]);\n\t\todd ^= (A[i] > B[i]);\n\t\tS.insert(abs(A[i] - B[i]));\n\t}\n\twhile(Q--) {\n\t\tll a, x, y;\n\t\tcin >> a >> x >> y; a--;\n\t\tif(a == 0 || a == 2 * N - 1) {\n\t\t\tans += x - A[a];\n\t\t\tA[a] = x;\n\t\t}\n\t\telse {\n\t\t\todd ^= (A[a] > B[a]);\n\t\t\todd ^= (x > y);\n\t\t\tans += max(x, y) - max(A[a], B[a]);\n\t\t\tS.erase(S.lower_bound(abs(A[a] - B[a])));\n\t\t\tS.insert(abs(x - y));\n\t\t\tA[a] = x; B[a] = y;\n\t\t}\n\t\tcout << (!odd ? ans : ans - (*S.begin())) << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <functional>\n#include <vector>\nusing namespace std;\n\nlong long N, Q, a[200009], b[200009], c[200009], ne[200009], s = 0, T1 = 0, T2 = 0; bool I[600009];\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> posi;\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, less<pair<long long, long long>>>nega;\n\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 1; i <= 2 * N; i++)cin >> a[i];\n\tfor (int i = 1; i <= 2 * N; i++)cin >> b[i];\n\tfor (int i = 1; i <= 2 * N; i++) {\n\t\tc[i] = b[i] - a[i]; s += a[i]; I[i] = true; ne[i] = i;\n\t\tif (i >= 2 && i <= 2 * N - 1) {\n\t\t\tif (c[i] >= 0) { posi.push(make_pair(c[i], i)); T1++; T2 += c[i]; }\n\t\t\telse nega.push(make_pair(c[i], i));\n\t\t}\n\t}\n\tfor (int i = 1; i <= Q; i++) {\n\t\tint p1, p2, p3; cin >> p1 >> p2 >> p3;\n\t\tlong long to = p3 - p2; if (c[p1] >= 0) { T2 -= c[p1]; T1--; }I[ne[p1]] = false;\n\t\t\n\t\twhile (!posi.empty() && I[posi.top().second] == false)posi.pop();\n\t\twhile (!nega.empty() && I[nega.top().second] == false)nega.pop();\n\t\t\n\t\tif (to >= 0) { posi.push(make_pair(to, 2 * N + i)); T2 += to; T1++; }\n\t\telse nega.push(make_pair(to, 2 * N + i));\n\t\ts += (p2 - a[p1]); a[p1] = p2; b[p1] = p3; c[p1] = to; I[2 * N + i] = true;\n\t\tif (T1 % 2 == 0) { cout << T2 + s << endl; }\n\t\telse {\n\t\t\tlong long V1 = T2 - posi.top().first;\n\t\t\tlong long V2 = -(1LL << 60); if (!nega.empty())V2 = T2 + nega.top().first;\n\t\t\tcout << max(V1, V2) + s << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) GET_MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint main(){\n  int n,q;\n  cin>>n>>q;\n  n *= 2;\n  vector<int> a(n),b(n);\n  rep(i,n) cin>>a[i];\n  rep(i,n) cin>>b[i];\n\n  vector<int> d(n);\n  rep(i,n) d[i] = b[i]-a[i];\n\n  long acc = accumulate(all(a), 0L);\n  long plus_sum = 0;\n\n  multiset<int> plus, minus;\n  rep(i,1,n-1){\n    if(d[i]>=0) plus.insert(d[i]);\n    else minus.insert(d[i]);\n  }\n\n  for(auto x : plus) plus_sum += x;\n\n  rep(i,q){\n    int p,x,y;\n    cin>>p>>x>>y;\n    p--;\n\n    if(p==0 || p == n-1){\n      acc -= a[p];\n      a[p] = x;\n      b[p] = y;\n      acc += a[p];\n    }\n\n    else {\n      acc -= a[p];\n      int old_d = b[p] - a[p];\n      if(old_d >= 0){\n        plus.erase(plus.lower_bound(old_d));\n        plus_sum -= old_d;\n      }\n      else minus.erase(minus.lower_bound(old_d));\n\n      a[p] = x;\n      b[p] = y;\n      acc += a[p];\n      int new_d = b[p] - a[p];\n      if(new_d >= 0){\n        plus.insert(new_d);\n        plus_sum += new_d;\n      }\n      else minus.insert(new_d);\n    }\n\n    if(plus.size()%2==0) cout << acc + plus_sum << \"\\n\";\n    else {\n      // 奇数なのでどっちも1以上ある\n      long c1 = acc + plus_sum - *plus.begin();\n      long c2 = acc + plus_sum + *minus.begin();\n\n      cout << max(c1, c2) << \"\\n\";\n    }\n    // dbg(vector<int>(all(plus)));\n    // dbg(vector<int>(all(minus)));\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<int, lint> pil;\ntypedef pair<lint, int> pli;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nint main(){\n    int n, q;\n    scanf(\"%d%d\", &n, &q);\n    lint a[2*n], b[2*n];\n    rep(i, 2*n) scanf(\"%lld\", &a[i]);\n    rep(i, 2*n) scanf(\"%lld\", &b[i]);\n    int cnt = 2;\n    lint sum = a[0] + a[2*n-1];\n    set<pli> S;\n    For(i, 1, 2*n-1){\n        if(a[i] >= b[i]){\n            sum += a[i];\n            ++cnt;\n        }\n        else sum += b[i];\n        S.emplace(abs(a[i]-b[i]), i);\n    }\n\n    rep(_, q){\n        int p;\n        lint x, y;\n        scanf(\"%d%lld%lld\", &p, &x, &y);\n        --p;\n        if(p == 0 || p == 2*n-1){\n            sum -= a[p];\n            sum += x;\n        }\n        else{\n            S.erase({abs(a[p]-b[p]), p});\n            S.insert({abs(x-y), p});\n            sum -= (a[p]>=b[p] ? a[p] : b[p]);\n            if(x >= y){\n                sum += x;\n                if(a[p] < b[p]) ++cnt;\n            }\n            else{\n                sum += y;\n                if(a[p] >= b[p]) --cnt;\n            }\n        }\n        a[p] = x; b[p] = y;\n        printf(\"%lld\\n\", cnt % 2 == 0 ? sum : sum-S.begin()->fi);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sp ' '\n#define mkp make_pair\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define lP pair<ll,ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\nconst int mod = 1000000007, mod998 = 998244353;\nconst string nyan(\"(=^・ω・^=)\");\n\nint N, Q, a[200000], b[200000], p, x, y;\nbool u[200000];\nset<pair<int, int>>st[2];\nll res;\n\nint main() {\n\tcin >> N >> Q;\n\t--Q;\n\tN *= 2;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> b[i];\n\t}\n\tcin >> p >> x >> y;\n\t--p;\n\ta[p] = x;\n\tb[p] = y;\n\tres = a[0] + a[N - 1];\n\tfor (int i = 1; i < N - 1; ++i) {\n\t\tif (a[i] >= b[i]) {\n\t\t\tu[i] = true;\n\t\t\tres += a[i];\n\t\t\tst[1].insert(mkp(a[i] - b[i], i));\n\t\t}\n\t\telse {\n\t\t\tres += b[i];\n\t\t\tst[0].insert(mkp(b[i] - a[i], i));\n\t\t}\n\t}\n\tif (st[0].size() & 1) {\n\t\tpair<int, int>p1, p2;\n\t\tp1 = *st[0].begin();\n\t\tp2 = *st[1].begin();\n\t\tif (p1.first > p2.first) {\n\t\t\tres -= p2.first;\n\t\t\tu[p2.second] ^= true;\n\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\tst[1].erase(p2);\n\t\t}\n\t\telse {\n\t\t\tres -= p1.first;\n\t\t\tu[p1.second] ^= true;\n\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\tst[0].erase(p1);\n\t\t}\n\t}\n\tcout << res << endl;\n\twhile (Q--) {\n\t\tcin >> p >> x >> y;\n\t\t--p;\n\t\tif (p == 0 || p == N - 1) {\n\t\t\tres += x - a[p];\n\t\t\ta[p] = x;\n\t\t}\n\t\telse {\n\t\t\tif (u[p]) {\n\t\t\t\tres += x - a[p];\n\t\t\t\tst[1].erase(mkp(a[p] - b[p], p));\n\t\t\t\tst[1].insert(mkp(x - y, p));\n\t\t\t\tauto it = st[1].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0 || (!st[0].empty() && p1.first + p2.first < 0 && p2.first < st[0].begin()->first)) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[0].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[1].erase(p1);\n\t\t\t\t\tst[1].erase(p2);\n\t\t\t\t}\n\t\t\t\tif (!st[0].empty()) {\n\t\t\t\t\tauto it = st[0].begin();\n\t\t\t\t\tauto it2 = it;\n\t\t\t\t\t++it2;\n\t\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\t\tif (p1.first < 0 && p2.first < 0 || (!st[1].empty() && p1.first + p2.first < 0 && p2.first < st[1].begin()->first)) {\n\t\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\t\tst[1].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\t\tst[0].erase(p1);\n\t\t\t\t\t\tst[0].erase(p2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres += y - b[p];\n\t\t\t\tst[0].erase(mkp(b[p] - a[p], p));\n\t\t\t\tst[0].insert(mkp(y - x, p));\n\t\t\t\tauto it = st[0].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0 || (!st[1].empty() && p1.first + p2.first < 0 && p2.first < st[1].begin()->first)) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[1].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[0].erase(p1);\n\t\t\t\t\tst[0].erase(p2);\n\t\t\t\t}\n\t\t\t\tif (!st[1].empty()) {\n\t\t\t\t\tauto it = st[1].begin();\n\t\t\t\t\tauto it2 = it;\n\t\t\t\t\t++it2;\n\t\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\t\tif (p1.first < 0 && p2.first < 0 || (!st[0].empty() && p1.first + p2.first < 0 && p2.first < st[0].begin()->first)) {\n\t\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\t\tst[0].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\t\tst[1].erase(p1);\n\t\t\t\t\t\tst[1].erase(p2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!st[0].empty() && !st[1].empty() && st[0].begin()->first + st[1].begin()->first < 0) {\n\t\t\t\tpair<int, int> p1 = *st[0].begin();\n\t\t\t\tpair<int, int> p2 = *st[1].begin();\n\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\tu[p1.second] ^= true;\n\t\t\t\tu[p2.second] ^= true;\n\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\tst[0].erase(p1);\n\t\t\t\tst[1].erase(p2);\n\t\t\t}\n\t\t\ta[p] = x;\n\t\t\tb[p] = y;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nlong long bit[400010],a[200010],b[200010],p[100010],x[100010],y[100010],n,q,inv[300010],m;\nvector<long long> v;\nmap<long long,long long> mp;\nint sum(int i){\n\tint s = 0;\n\twhile(i>0){\n\t\ts += bit[i];\n\t\ti -= i&-i;\n\t}\n\treturn s;\n}\n\nvoid add(int i, int x){\n\twhile(i<=m){\n\t\tbit[i] += x;\n\t\ti += i&-i;\n\t}\n}\nint main(){\n\tint z,ans = 0;\n\tcin >> n >> q;\n\tint i;\n\tfor(i=0;i<2*n;i++){\n\t\tcin >> a[i];\n\t}\n\tfor(i=0;i<2*n;i++){\n\t\tcin >> b[i];\n\t}\n\tfor(i=1;i<2*n-1;i++){\n\t\tv.push_back(a[i]-b[i]);\n\t}\n\tfor(i=0;i<q;i++){\n\t\tcin >> p[i] ;\n\t\tp[i]--;\n\t\tcin>> x[i] >> y[i];\n\t\tif(p[i]!=0 && p[i]!=2*n-1){\n\t\t\tv.push_back(x[i]-y[i]);\n\t\t}\n\t}\n\tm = v.size()+1;\n\tv.push_back(0);\n\tsort(v.begin(),v.end());\n\tint now = 1;\n\tmp[v[0]] = 1;\n\tinv[1] = v[0];\n\tif(v[0]==0){\n\t\tz = 1;\n\t}\n\tfor(i=1;i<v.size();i++){\n\t\tif(v[i]>v[i-1]){\n\t\t\tnow++;\n\t\t}\n\t\tmp[v[i]] = now;\n\t\tinv[now] = v[i];\n\t\tif(v[i]==0){\n\t\t\tz = now;\n\t\t}\n\t}\n\tnow++;\n\tint cnt = 0;\n\tfor(i=1;i<2*n-1;i++){\n\t\tadd(mp[a[i]-b[i]],1);\n\t\tif(a[i]>=b[i]){\n\t\t\tans += a[i];\n\t\t\tcnt += 1;\n\t\t}else{\n\t\t\tans += b[i];\n\t\t}\n\t}\n\tfor(i=1;i<now;i++){\n\t\t//cout << i << \" \" << sum(i) << endl;\n\t}\n\tfor(i=0;i<now;i++){\n\t\t//cout << i << \" \" << inv[i] << endl;\n\t}\n\tfor(i=0;i<now;i++){\n\t\t//cout << i << \" \" << sum(i) << endl;\n\t}\n\tans += a[0]+a[2*n-1];\n\tfor(i=0;i<q;i++){\n\t\tif(p[i]==0 || p[i]==2*n-1){\n\t\t\t//cout << ans << endl;\n\t\t\tans -= a[p[i]];\n\t\t\tans += x[i];\n\t\t\t//cout << p[i] << \" \" << a[p[i]] << \" \" << x[i] << endl;\n\t\t\ta[p[i]] = x[i];\n\t\t\tb[p[i]] = y[i];\n\t\t}else{\n\t\t\tans -= max(a[p[i]],b[p[i]]);\n\t\t\tans += max(x[i],y[i]);\n\t\t\t//cout << a[p[i]] << \" \" << b[p[i]] << \" \" << x[i] << \" \" << y[i] << \" \" << ans <<\" \" << cnt<< endl;\n\t\t\tfor(int j=0;j<now;j++){\n\t\t\t\t//cout << j << \" \" << sum(j) << endl;\n\t\t\t}\n\t\t\tadd(mp[a[p[i]] - b[p[i]]],-1);\n\t\t\tadd(mp[x[i] - y[i]],1);\n\t\t\tif(a[p[i]]-b[p[i]]>0 ^ x[i]-y[i]>0){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\ta[p[i]] = x[i];\n\t\t\tb[p[i]] = y[i];\n\t\t}\n\t\t//cout << ans << \" \" << cnt << endl;\n\t\tif(cnt%2==0){\n\t\t\tcout << ans << endl;\n\t\t}else{\n\t\t\tlong long l=0,r=now,mid;\n\t\t\tint s = sum(z);\n\t\t\t//cout << i << \" \"  << p[i] << \" \" << x[i] << \" \" << y[i] << endl;\n\t\t\t//cout << l << \" \" << r << \" \" << z << endl;\n\t\t\t//cout << s << endl;\n\t\t\twhile(r - l>1){\n\t\t\t\t//cout << l << \" \" << r << \" \" << endl;\n\t\t\t\tmid = (l+r)/2;\n\t\t\t\tif(sum(mid)>=s+1){\n\t\t\t\t\tr = mid;\n\t\t\t\t}else{\n\t\t\t\t\tl = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << r << endl;\n\t\t\tlong long m1 = inv[r];\n\t\t\tl=0,r=now;\n\t\t\twhile(r - l>1){\n\t\t\t\t//cout << l << \" \" << r << endl;\n\t\t\t\tmid = (l+r)/2;\n\t\t\t\tif(sum(mid)<s){\n\t\t\t\t\tl = mid;\n\t\t\t\t}else{\n\t\t\t\t\tr = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << r << endl;\n\t\t\tlong long m2 = inv[r];\n\t\t\t//cout << m1 << \" \" << m2 << \" \" << endl;\n\t\t\tcout << max(ans - m1,ans + m2) << endl;\n\t\t}\n\t}\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr long double EPS = 1e-8;\n\nlong long int N, M, K, L, R, H, W;\n//int N, M, K, L, R, H, W;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tN <<= 1;\n\tvector<long long int>v(N);\n\tvector<long long int>w(N);\n\tfor (auto &i : v)cin >> i;\n\tfor (auto &i : w)cin >> i;\n\tlong long int ans = v.front() + v.back();\n\tset<pair<long long int, int>>in;\n\tset<pair<long long int, int>>out;\n\tlong long int insum = 0;\n\tvector<long long int>num(N);\n\tfor (int i = 1; i < N - 1; i++) {\n\t\tans += v[i];\n\t\tnum[i] = w[i] - v[i];\n\t\tif (v[i] < w[i]) {\n\t\t\tin.insert({ num[i],i });\n\t\t\tans += num[i];\n\t\t}\n\t\telse {\n\t\t\tout.insert({ -num[i],i });\n\t\t}\n\t}\n\twhile (in.size() && in.begin()->first < 0) {\n\t\tint n = in.begin()->second;\n\t\tans -= num[n];\n\t\tout.insert({ -in.begin()->first, in.begin()->second });\n\t\tin.erase(in.begin());\n\t}\n\twhile (out.size() && out.begin()->first < 0) {\n\t\tint n = out.begin()->second;\n\t\tans += num[n];\n\t\tin.insert({ -out.begin()->first, out.begin()->second });\n\t\tout.erase(out.begin());\n\t}\n\tif (in.size() & 1) {\n\t\tif (in.begin()->first > out.begin()->first) {\n\t\t\tin.insert({ -out.begin()->first,out.begin()->second });\n\t\t\tans += num[out.begin()->second];\n\t\t\tout.erase(out.begin());\n\t\t}\n\t\telse {\n\t\t\tout.insert({ -in.begin()->first,in.begin()->second });\n\t\t\tans -= num[in.begin()->second];\n\t\t\tin.erase(in.begin());\n\t\t}\n\t}\n\twhile (M--) {\n\t\tcin >> K >> L >> R;\n\t\tK--;\n\t\tans -= v[K];\n\t\tv[K] = L, w[K] = R;\n\t\tif (K == 0 || K == N - 1) {\n\t\t\tans += v[K];\n\t\t\tcontinue;\n\t\t}\n\t\tif (in.find({ num[K],K }) != in.end()) {\n\t\t\tans -= num[K];\n\t\t\tin.erase({ num[K],K });\n\t\t}\n\t\telse {\n\t\t\tout.erase({ -num[K],K });\n\t\t}\n\t\tnum[K] = w[K] - v[K];\n\t\tans += L;\n\t\tif (num[K] > 0) {\n\t\t\tin.insert({ num[K],K });\n\t\t\tans += num[K];\n\t\t}\n\t\telse {\n\t\t\tout.insert({ -num[K],K });\n\t\t}\n\t\twhile (in.size() && in.begin()->first < 0) {\n\t\t\tint n = in.begin()->second;\n\t\t\tans -= num[n];\n\t\t\tout.insert({ -in.begin()->first, in.begin()->second });\n\t\t\tin.erase(in.begin());\n\t\t}\n\t\twhile (out.size() && out.begin()->first < 0) {\n\t\t\tint n = out.begin()->second;\n\t\t\tans += num[n];\n\t\t\tin.insert({ -out.begin()->first, out.begin()->second });\n\t\t\tout.erase(out.begin());\n\t\t}\n\t\tif (in.size() & 1) {\n\t\t\tif (in.begin()->first > out.begin()->first) {\n\t\t\t\tin.insert({ -out.begin()->first,out.begin()->second });\n\t\t\t\tans += num[out.begin()->second];\n\t\t\t\tout.erase(out.begin());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout.insert({ -in.begin()->first,in.begin()->second });\n\t\t\t\tans -= num[in.begin()->second];\n\t\t\t\tin.erase(in.begin());\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define long long long\n\nconst int N = 11;\nconst long INF = 1e18;\n\nint n, q;\nlong a[N], b[N];\n\nvoid Solve()\n{\n    while (q--)\n    {\n        int p; long x, y;\n        cin >> p >> x >> y;\n        a[p] = x, b[p] = y;\n\n        long ans = -INF;\n        for (int mask = 0; mask < 1 << (n - 2); ++mask)\n            if (!(__builtin_popcount(mask) & 1))\n            {\n                long sum = 0;\n                for (int i = 0; i < n - 2; ++i)\n                    if ((mask >> i) & 1) sum += b[i + 2];\n                    else sum += a[i + 2];\n                ans = max(ans, sum);\n            }\n        cout << ans + a[1] + a[n] << '\\n';\n    }\n}\n\nint main()\n{\n    cin >> n >> q;\n    assert(n <= 5);\n    n *= 2;\n    for (int i = 1; i <= n; ++i) cin >> a[i];\n    for (int i = 1; i <= n; ++i) cin >> b[i];\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define VARNAME(x) #x\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const multiset<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\ntemplate <typename S, typename T>\nostream& operator<<(ostream& os, const pair<S, T>& p)\n{\n    os << \"(\" << p.first << \",\" << p.second\n       << \")\";\n    return os;\n}\n\n\nconstexpr ll MOD = (ll)1e9 + 7LL;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 10;\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, Q;\n    cin >> N >> Q;\n    vector<ll> a(2 * N);\n    vector<ll> b(2 * N);\n    vector<ll> sa(2 * N);\n    ll sum = 0;\n    for (int i = 0; i < 2 * N; i++) {\n        cin >> a[i];\n        sum += a[i];\n    }\n    for (int i = 0; i < 2 * N; i++) {\n        cin >> b[i];\n    }\n    ll psum = 0;\n    multiset<ll> pos;\n    multiset<ll> neg;\n    for (int i = 0; i < 2 * N; i++) {\n        sa[i] = b[i] - a[i];\n    }\n    for (int i = 1; i < 2 * N - 1; i++) {\n        if (sa[i] > 0) {\n            psum += sa[i];\n            pos.insert(sa[i]);\n        } else {\n            neg.insert(sa[i]);\n        }\n    }\n    for (int q = 0; q < Q; q++) {\n        int p;\n        ll x, y;\n        cin >> p >> x >> y;\n        p--;\n        const ll old = sa[p];\n        sum += x - a[p];\n        a[p] = x;\n        b[p] = y;\n        sa[p] = y - x;\n\n        if (p > 0 and p < 2 * N - 1) {\n            if (old > 0) {\n                auto it = pos.find(old);\n                pos.erase(it);\n                psum -= old;\n            } else {\n                auto it = neg.find(old);\n                neg.erase(it);\n            }\n            if (sa[p] > 0) {\n                pos.insert(sa[p]);\n                psum += sa[p];\n            } else {\n                neg.insert(sa[p]);\n            }\n        }\n\n        const int pnum = pos.size();\n        if (pnum % 2 == 0) {\n            cout << sum + psum << endl;\n        } else {\n            const ll pback = *pos.cbegin();\n            if (neg.size() == 0) {\n                cout << sum + psum - pback << endl;\n            } else {\n                const ll ntop = *neg.crbegin();\n                cout << max(sum + psum + ntop, sum + psum - pback) << endl;\n            }\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(),vec.end()\n#define mp make_pair\nusing namespace std;\nusing ll=long long;\nusing P=pair<ll,ll>;\nconst ll INF=1LL<<30;\nconst ll LINF=1LL<<60;\nconst double eps=1e-5;\nconst ll MOD=1000000007LL;\ntemplate<typename T>void chmin(T &a,T b){a=min(a,b);};\ntemplate<typename T>void chmax(T &a,T b){a=max(a,b);};\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint main(){\n    int n,q;cin>>n>>q;n*=2;\n    vector<ll> a(n),b(n);\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n    }\n    multiset<ll> st;\n    int c=0;\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        cin>>b[i];\n        if(i==0||i==n-1){\n            ans+=a[i];\n        }else{\n            st.insert(abs(a[i]-b[i]));\n            ans+=max(a[i],b[i]);\n            if(a[i]>b[i])c^=1;\n        }\n    }\n    while(q--){\n        ll p,x,y;cin>>p>>x>>y;--p;\n        if(p==0||p==2*n-1){\n            ans+=x-a[p];\n            a[p]=x;\n        }else{\n            if(a[p]>b[p])c^=1;\n            if(x>y)c^=1;\n            ans+=max(x,y)-max(a[p],b[p]);\n            st.erase(st.lower_bound(abs(a[p]-b[p])));\n            st.insert(abs(x-y));\n            a[p]=x,b[p]=y;\n        }\n        if(c){\n            cout<<ans-(*st.begin())<<endl;\n        }else{\n            cout<<ans<<endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define REP(e,v) for(auto e:v)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\n#define MAX_V 400010\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\nll MOD=1e9+7;\n#define N 1055050\n\nll n,m,k;\nll a[N],b[N];\ntemplate< typename Monoid >\nstruct SegmentTree {\n  using F = function< Monoid(Monoid, Monoid) >;\n \n  int sz;\n  vector< Monoid > seg;\n \n  const F f;\n  const Monoid M1;\n \n  SegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1) {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz, M1);\n  }\n \n  void set(int k, const Monoid &x) {\n    seg[k + sz] = x;\n  }\n \n  void build() {\n    for(int k = sz - 1; k > 0; k--) {\n      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n    }\n  }\n \n  void update(int k, const Monoid &x) {\n    k += sz;\n    seg[k] = x;\n    while(k >>= 1) {\n      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n    }\n  }\n \n  Monoid query(int a, int b) {\n    Monoid L = M1, R = M1;\n    for(a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n      if(a & 1) L = f(L, seg[a++]);\n      if(b & 1) R = f(seg[--b], R);\n    }\n    return f(L, R);\n  }\n \n  Monoid operator[](const int &k) const {\n    return seg[k + sz];\n  }\n};\n//SegmentTree(n,f,M1) nで初期化　fは二項演算　M1は単位元\n//set(k,x) 要素k = x\n//build() 構築\n//query 区間[a,b)に二項演算\n//update(k,x) kをxに\n//operator[k] k番目の要素\n// SegmentTree< int > seg(N,[](int a,int b){return min(a,b);},INF);\n//みたいに使う\nmain(){\n    n=in();\n    int q=in();\n    SegmentTree<ll> seg(n*2+1,[](ll a,ll b){return min(a,b);},INF),seg2(n*2+1,[](ll a,ll b){return min(a,b);},INF);\n    ll sum=0;\n    rep(i,n*2){\n        a[i]=in();\n        sum+=a[i];\n    }\n    int count=0;\n    ll dif=0;\n    rep(i,n*2){\n        b[i]=in();\n        if(i==0||i==n*2-1)continue;\n        if(b[i]>a[i]){\n            seg.set(i,b[i]-a[i]);\n            dif+=b[i]-a[i];\n            count++;\n        }\n        else{\n            seg2.set(i,a[i]-b[i]);\n        }\n    }\n    seg.build();seg2.build();\n    rep(iii,q){\n        int p=in();p--;\n        ll prea=a[p],preb=b[p];\n        a[p]=lin();b[p]=in();\n        sum+=a[p]-prea;\n        if(p==0||p==n*2-1){\n            goto G;\n        }\n        if(preb>prea){\n            count--;\n            dif-=preb-prea;\n        }\n        else{\n            seg2.update(p,INF);\n        }\n        if(b[p]>a[p]){\n            count++;\n            seg.update(p,b[p]-a[p]);\n            dif+=b[p]-a[p];\n        }\n        else{\n            seg2.update(p,a[p]-b[p]);\n        }\n        G:\n        if(count%2){\n            ll ans=sum+dif;\n            ans+=max(-seg.query(0,2*n),-seg2.query(0,2*n));\n            cout<<ans<<endl;\n        }\n        else cout<<sum+dif<<endl;\n    }\n}\n/*1 4 7 3\n4 6 3 3\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint main() {\n        int n, q;\n        scanf(\"%d%d\", &n, &q);\n        n = 2 * n;\n        vector<long long> a(n), b(n);\n        for (int i = 0; i < n; i ++) scanf(\"%lld\", &a[i]);\n        for (int i = 0; i < n; i ++) scanf(\"%lld\", &b[i]);\n        multiset<long long> positive, negative;\n        int psum = 0, nsum = 0;\n        for (int i = 0; i < n; i ++) {\n                if (i == 0 || i == n - 1) {\n                        psum += a[i];\n                        continue;\n                }\n                int c = a[i] - b[i];\n                if (c >= 0) { \n                        positive.insert(c);\n                        psum += a[i];\n                } else { \n                        negative.insert(- c);\n                        nsum += b[i];\n                }\n        }\n        while (q --) {\n                int p;\n                long long x, y;\n                scanf(\"%d%lld%lld\", &p, &x, &y);\n                p --;\n                long long z = x - y;\n                if (p == 0 || p == n - 1) {\n                        psum -= a[p];\n                        psum += x;\n                        a[p] = x;\n                        continue;\n                }\n                int c = a[p] - b[p];\n                if (c >= 0) {\n                        positive.erase(positive.find(c));\n                        psum -= a[p];\n                } else {\n                        negative.erase(negative.find(-c));\n                        nsum -= b[p];\n                }\n                if (z >= 0) {\n                        positive.insert(z);\n                        psum += x;\n                } else {\n                        negative.insert(-z);\n                        nsum += y;\n                }\n                a[p] = x;\n                b[p] = y;\n                long long ans;\n                if (positive.size() % 2 == 0) ans = psum + nsum;\n                else ans = psum + nsum - min(*positive.begin(), *negative.begin());\n                printf(\"%lld\\n\", ans);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<complex>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\n#define N 200010\nll n,q,a[N],b[N];\nmap<ll,ll> mp;\nvoid Erase(ll x){\n    mp[x]--;\n    if(mp[x]==0)mp.erase(x);\n}\nint main(){\n    cin>>n>>q;\n    lol(i,2*n)cin>>a[i];\n    lol(i,2*n)cin>>b[i];\n    \n    ll sum=a[0]+a[2*n-1];\n    ll cnt=0;\n    for(int i=1;i<=2*n-2;i++){\n\tsum+=max(a[i],b[i]);\n\tif(a[i]>b[i])cnt++;\n\tmp[abs(a[i]-b[i])]++;\n    }\n    \n    lol(u,q){\n\tll p,x,y;\n\tcin>>p>>x>>y;\n\tp--;\n\tif(p==0||p==2*n-1){\n\t    sum=sum-a[p]+x;\n\t}\n\telse{\n\t    sum-=max(a[p],b[p]);\n\t    sum+=max(x,y);\n\t    \n\t    if(a[p]>b[p])cnt--;\n\t    Erase(abs(a[p]-b[p]));\n\t    \n\t    if(x>y)cnt++;\n\t    else mp[abs(x-y)]++;\n\t}\n\ta[p]=x,b[p]=y;\n\tll ans=sum;\n\tif(cnt%2==1){\n\t    ans-=mp.begin()->first;\n\t}\n\tcout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\nclass LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}};\nvpii factor(int N){vpii r;for(int i=2;i*i<=N;++i){if(N%i==0){r<<pii{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pii{N,1};}return r;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N,Q;cin>>N>>Q;\n\tvi A(2*N);cin>>A;\n\tvi B(2*N);cin>>B;\n\tmultiset<int>po,ne;\n\tll z=sum(A);\n\tfoor(i,1,2*N-2){\n\t\tif(B[i]>=A[i]){\n\t\t\tpo<<B[i]-A[i];\n\t\t\tz+=B[i]-A[i];\n\t\t}else{\n\t\t\tne<<A[i]-B[i];\n\t\t}\n\t}\n\tfr(q,Q){\n\t\tint p,x,y;cin>>p>>x>>y;\n\t\t--p;\n\t\tz+=x-A[p];\n\t\tif(1<=p&&p<=2*N-2){\n\t\t\tif(B[p]>=A[p]){\n\t\t\t\tpo.erase(po.lower_bound(B[p]-A[p]));\n\t\t\t\tz-=B[p]-A[p];\n\t\t\t}else{\n\t\t\t\tne.erase(ne.lower_bound(A[p]-B[p]));\n\t\t\t}\n\t\t\tif(y>=x){\n\t\t\t\tpo<<y-x;\n\t\t\t\tz+=y-x;\n\t\t\t}else{\n\t\t\t\tne<<x-y;\n\t\t\t}\n\t\t}\n\t\tA[p]=x,B[p]=y;\n\t\tif(po.size()%2){\n\t\t\tprint(z-min(*po.begin(),*ne.begin()));\n\t\t}else{\n\t\t\tprint(z);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\ntypedef long long ll;\n\nusing namespace std;\n\nint N, Q;\nll A[200010], B[200010]; //[0, 2 * N) !!\nmultiset<ll> S;\n\nvoid solve() {\n\tcin >> N >> Q;\n\trep(i, 0, 2 * N) cin >> A[i];\n\trep(i, 0, 2 * N) cin >> B[i];\n\n\tll ans = 0; bool odd = false;\n\tans += A[0] + A[2 * N - 1];\n\trep(i, 1, 2 * N - 1) {\n\t\tans += max(A[i], B[i]);\n\t\todd ^= (A[i] > B[i]);\n\t\tS.insert(abs(A[i] - B[i]));\n\t}\n\twhile(Q--) {\n\t\tll a, x, y;\n\t\tcin >> a >> x >> y; a--;\n\t\tif(a == 0 || a == 2 * N - 1) {\n\t\t\tans += x - A[a];\n\t\t\tA[a] = x;\n\t\t}\n\t\telse {\n\t\t\todd ^= (A[a] > B[a]);\n\t\t\todd ^= (x > y);\n\t\t\tans += max(x, y) - max(A[a], B[a]);\n\t\t\tS.erase(S.lower_bound(abs(A[a] - B[a])));\n\t\t\tS.insert(abs(x - y));\n\t\t\tA[a] = x; B[a] = y;\n\t\t}\n\t\tcout << (!odd ? ans : ans - (*S.begin())) << \"\\n\";\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n\tsolve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <functional>\nusing namespace std;\n\nlong long N, Q, a[200009], b[200009];\nlong long solve() {\n\tvector<long long>Z; long long sum = 0;\n\tfor (int i = 1; i < 2 * N - 1; i++) {\n\t\tsum += a[i];\n\t\tZ.push_back(b[i] - a[i]);\n\t}\n\tsum += a[0] + a[2 * N - 1];\n\tsort(Z.begin(), Z.end(), greater<long long>());\n\tlong long maxn = 0, S = 0;\n\tfor (int i = 0; i < Z.size(); i += 2) {\n\t\tS += Z[i] + Z[i + 1];\n\t\tmaxn = max(maxn, S);\n\t}\n\treturn sum + maxn;\n}\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 0; i < 2 * N; i++)cin >> a[i];\n\tfor (int i = 0; i < 2 * N; i++)cin >> b[i];\n\tfor (int i = 0; i < Q; i++) {\n\t\tlong long p1, p2, p3; cin >> p1 >> p2 >> p3; p1--;\n\t\ta[p1] = p2; b[p1] = p3;\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst int maxn = 111;\nconst long long inf = 1ll<<55;\nint n, q;\nint x[maxn], y[maxn];\nbool vis[maxn][maxn][maxn];\nlong long dp[maxn][maxn][maxn];\nlong long solve(int c, int a, int b){\n    // cerr << c << \" \" << a << \" \" << b << endl;\n    if(c == n){\n        if(a == 0 && b == 0) return 0;\n        return -inf;\n    }\n    if(a < 0) return -inf;\n    if(b < 0) return -inf;\n    if(vis[c][a][b]) return dp[c][a][b];\n    long long ans = -inf;\n    ans = max(ans, x[c] + solve(c + 1, a + 1, b + 1));\n    ans = max(ans, x[c] + solve(c + 1, a - 1, b - 1));\n    ans = max(ans, y[c] + solve(c + 1, a + 1, b - 1));\n    ans = max(ans, y[c] + solve(c + 1, a - 1, b + 1));\n    vis[c][a][b] = 1;\n    return dp[c][a][b] = ans;\n}\nint main(){\n    scanf(\"%d %d\", &n, &q); n *= 2;\n    if(n > 50) return 0;\n    for(int e = 0; e < n; e++) scanf(\"%d\", x + e);\n    for(int e = 0; e < n; e++) scanf(\"%d\", y + e);\n    while(q--){\n        int t, a, b;\n        scanf(\"%d %d %d\", &t, &a, &b);\n        t--;\n        x[t] = a;\n        y[t] = b;\n        memset(vis, false, sizeof(vis));\n        cout << solve(0, 0, 0) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nconst long long mod = 1000000007;\nconst int maxn = 222222;\nlong long a[maxn], b[maxn];\nlong long tr[2][maxn<<2];\nint n;\nvoid modify(int id, int l, int r, int x, int aa, int bb){\n    if(l == r){\n        if(l == 1 || l == n){\n            tr[0][id] = aa;\n            tr[1][id] = -(1ll<<60);\n        } else {\n            tr[0][id] = aa;\n            tr[1][id] = bb;\n        }\n    } else {\n        int mid = (l + r)>>1;\n        if(x <= mid) modify(id<<1, l, mid, x, aa, bb);\n        else modify(id<<1|1, mid + 1, r, x, aa, bb);\n        tr[0][id] = max(tr[0][id<<1] + tr[0][id<<1|1], tr[1][id<<1] + tr[1][id<<1|1]);\n        tr[1][id] = max(tr[1][id<<1] + tr[0][id<<1|1], tr[0][id<<1] + tr[1][id<<1|1]);\n    }\n}\nint main(){\n    int q;\n    scanf(\"%d %d\", &n, &q);\n    n *= 2;\n    for(int e = 1; e <= n; e++){\n        scanf(\"%lld\", a + e);\n    }\n    for(int e = 1; e <= n; e++){\n        scanf(\"%lld\", b + e);\n    }\n    for(int e = 1; e <= n; e++){\n        modify(1, 1, n, e, a[e], b[e]);\n    }\n    while(q--){\n        int x, aa, bb;\n        scanf(\"%d %d %d\", &x, &aa, &bb);\n        modify(1, 1, n, x, aa, bb);\n        printf(\"%lld\\n\", tr[0][1]);\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\n\nvector<int> v[1010];\nint a[1010];\npint dfs(int x){\n    if(v[x].empty())return {0,a[x]};\n    bitset<5050> b=1;\n    int sum=0;\n    for(auto to:v[x]){\n        pint p=dfs(to);\n        if(p.first==-1)return {-1,-1};\n        b=(b<<p.first|b<<p.second);\n        sum+=p.first+p.second;\n    }\n    for(int i=a[x];i>=0;i--){\n        if(b[i])return {a[x],sum-i};\n    }\n    return {-1,-1};\n}\n\nint main(){\n    int n,q;\n    cin>>n>>q;\n    n*=2;\n    ll a[n],b[n];\n    rep(i,n)cin>>a[i];\n    rep(i,n)cin>>b[i];\n    ll ans=a[0]+a[n-1];\n    int posi=0,zero=0;\n    multiset<ll> st;\n    rep(i,n-2){\n        ans+=max(a[i+1],b[i+1]);\n        if(a[i+1]>b[i+1])posi++;\n        if(a[i+1]==b[i+1])zero++;\n        st.insert(abs(a[i+1]-b[i+1]));\n    }\n    rep(i,q){\n        int p,x,y;\n        cin>>p>>x>>y;\n        if(p==1||p==n){\n            cout<<ans<<endl;\n            continue;\n        }\n        p--;\n        ans+=max(x,y)-max(a[p],b[p]);\n        auto it=st.lower_bound(abs(a[p]-b[p]));\n        st.erase(it);\n        st.insert(abs(x-y));\n        if(a[p]-b[p]>0)posi--;\n        if(a[p]-b[p]==0)zero--;\n        if(x-y>0)posi++;\n        if(x-y==0)zero++;\n        a[p]=x;b[p]=y;\n        if(zero>0||posi%2==0)cout<<ans<<endl;\n        else cout<<ans-*st.begin()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint N, Q; cin >> N >> Q; \n\tlong long A[200010], B[200010]; \n\tfor(int i = 0; i < N*2; i++) cin >> A[i]; \n\tfor(int i = 0; i < N*2; i++) cin >> B[i]; \n\tlong long sumA = 0; // 全部Aだった場合\n\tlong long sumP = 0; // 変えた方が得なものを全部Bに変えたときの得\n\tmultiset<long long> P, M; \n\tfor(int i = 0; i < N*2; i++) sumA += A[i]; \n\tfor(int i = 1; i < N*2-1; i++){\n\t\tif(A[i] <= B[i]){\n\t\t\tP.insert(B[i] - A[i]); sumP += B[i] - A[i]; \n\t\t}\n\t\telse M.insert(A[i] - B[i]); \n\t}\n\twhile(Q--){\n\t\tint p; long long x, y; \n\t\tcin >> p >> x >> y; p--; \n\t\tif(A[p] <= B[p]){\n\t\t\tP.erase(*P.find(B[p] - A[p])); \n\t\t\tsumP -= B[p] - A[p]; \n\t\t\tsumA -= A[p]; \n\t\t\tA[p] = x; B[p] = y; \n\t\t}else{\n\t\t\tM.erase(*M.find(A[p] - B[p])); \n\t\t\tsumA -= A[p]; \n\t\t\tA[p] = x; B[p] = y; \n\t\t}\n\t\tsumA += A[p]; \n\t\tif(A[p] <= B[p]){\n\t\t\tP.insert(B[p] - A[p]); sumP += B[p] - A[p]; \n\t\t}\n\t\telse M.insert(A[p] - B[p]); \n\t\tlong long ans = sumA + sumP; \n\t\tint s = (int) P.size(); \n\t\tif(s & 1){\n\t\t\tlong long d = *P.begin(); \n\t\t\tlong long e = *M.begin(); \n\t\t\tans -= min(d, e); \n\t\t}\n\t\tcout << ans << \"\\n\"; \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\n\nint main(){\n    int n,q;\n    cin>>n>>q;\n    n*=2;\n    ll a[n],b[n];\n    rep(i,n)cin>>a[i];\n    rep(i,n)cin>>b[i];\n    ll ans=a[0]+a[n-1];\n    int posi=0,ze=0;\n    set<pli> st;\n    rep(i,n-2){\n        ans+=max(a[i+1],b[i+1]);\n        if(a[i+1]>b[i+1])posi++;\n        st.insert({abs(a[i+1]-b[i+1]),i+1});\n    }\n    rep(i,q){\n        ll p,x,y;\n        cin>>p>>x>>y;\n        p--;\n        if(p==0||p==n-1){\n            ans+=(ll)(x-a[p]);\n            a[p]=x;\n            cout<<ans<<endl;\n            continue;\n        }\n        ans+=max(x,y);\n        ans-=max(a[p],b[p]);\n        auto it=st.find({abs(a[p]-b[p]),p});\n        st.erase(it);\n        st.insert({abs(x-y),p});\n        if(a[p]>b[p])posi--;\n        if(x>y)posi++;\n        a[p]=x;\n        b[p]=y;\n        it=st.begin();\n        if(posi%2==0)cout<<ans<<endl;\n        else cout<<ans-(it->first)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nint a[200000],d[200000];\nint *dp[200000];\nint const INF = 1000000007;\nbool comp(const int* a,const int* b){\n    return *a<*b;\n}\nint main(void){\n    int n,q,i,j,tmp;\n    long long sum=0,ans;\n    scanf(\"%d %d\",&n,&q);\n    for(i=0;i<2*n;i++){\n        scanf(\"%d\",&a[i]);\n        sum+=a[i];\n    }\n    for(i=0;i<2*n;i++){\n        scanf(\"%d\",&tmp);\n        d[i]=tmp-a[i];\n        dp[i]=&d[i];\n    }\n    int p,x,y;\n    for(i=0;i<q;i++){\n        scanf(\"%d%d%d\",&p,&x,&y);\n        sum=sum+x-a[p-1];\n        a[p-1]=x;\n        d[p-1]=y-x;\n        d[0]=-INF;\n        d[2*n-1]=-INF;\n        std::sort(dp,dp+2*n,comp);\n        //printf(\"%lld,\",sum);\n        ans=sum;\n        for(j=2*n-1;j>0 && *(dp[j-1])>0;j-=2){\n            ans=ans+(*(dp[j]))+(*(dp[j-1]));\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<iostream>\n#define rep(i,a,b)for(int i=a;i<b;++i)\ntypedef long long ll;\nusing namespace std;\nint N,Q;\nll A[200001],B[200001];\nmultiset<ll>S;\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>N>>Q;\n\trep(i,0,N<<1)cin>>A[i];\n\trep(i,0,N<<1)cin>>B[i];\n\tll ans=0;\n\tbool odd=0;\n\tans+=A[0]+A[(n<<1)-1];\n\trep(i,1,(N<<1)-1){\n\t\tans+=max(A[i],B[i]);\n\t\todd^=(A[i]>B[i]);\n\t\tS.insert(abs(A[i]-B[i]));\n\t}\n\twhile(Q--){\n\t\tll a,x,y;\n\t\tcin>>a>>x>>y;\n\t\tif(--a==0||a==(N<<1)-1){\n\t\t\tans+=x-A[a];\n\t\t\tA[a]=x;\n\t\t}else{\n\t\t\todd^=(A[a]>B[a]);\n\t\t\todd^=(x>y);\n\t\t\tans+=max(x, y)-max(A[a],B[a]);\n\t\t\tint*p=S.lower_bound(abs(A[a]-B[a]));\n\t\t\tS.erase();\n\t\t\tS.insert(abs(x-y));\n\t\t\tA[a]=x;\n\t\t\tB[a]=y;\n\t\t}\n\t\tcout<<(!odd?ans:ans-(*S.begin()))<<\"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200005;\n\nint n, q;\nint a[N], b[N];\nmultiset < pair<long long, int> > sa, sb; // (b - a, p)\nlong long sum;\n\nvoid reset() {\n\twhile(sa.size() >= 2) {\n\t\tmultiset < pair<long long, int> > :: iterator it;\n\t\tit = sa.end();\n\t\t--it;\n\t\tpair<long long, int> x = (*it);\n\t\t--it;\n\t\tpair<long long, int> y = (*it);\n\n\t\tif (x.first + y.first > 0) {\n\t\t\tsb.insert(x);\n\t\t\tsb.insert(y);\n\t\t\tsum -= a[x.second]; sum += b[x.second];\n\t\t\tsum -= a[y.second]; sum += b[y.second];\n\n\t\t\tsa.erase(sa.find(x));\n\t\t\tsa.erase(sa.find(y));\n\t\t}\n\t\telse break;\n\t}\n}\n\nvoid debug(multiset< pair<long long, int> > &s) {\n\tfor (auto &e : s) printf(\"[%lld, %d] \", e.first, e.second); printf(\"\\n\");\n}\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\n\tcin >> n >> q;\n\n\tfor (int i = 1; i <= 2 * n; ++i) cin >> a[i];\n\tfor (int i = 1; i <= 2 * n; ++i) cin >> b[i];\n\n\tfor (int i = 1; i <= 2 * n; ++i) {\n\t\tsum += a[i];\n\t\tif (i != 1 && i != 2 * n) {\n\t\t\tsa.insert(make_pair(b[i] - a[i], i));\n\t\t}\n\t}\n\n\treset();\n\n\twhile(q--) {\n\t\tint p, x, y; cin >> p >> x >> y;\n\t\tif (p != 1 && p != 2 * n) {\n\t\t\tif (sb.find(make_pair(b[p] - a[p], p)) != sb.end()) {\n\t\t\t\tsb.erase(sb.find(make_pair(b[p] - a[p], p)));\n\t\t\t\tsum -= b[p];\n\t\t\t}\n\t\t\telse if (sa.find(make_pair(b[p] - a[p], p)) != sa.end()) {\n\t\t\t\tsa.erase(sa.find(make_pair(b[p] - a[p], p)));\n\t\t\t\tsum -= a[p];\n\t\t\t}\n\t\t} else {\n\t\t\tsum -= a[p];\n\t\t}\n\n\t\ta[p] = x;\n\t\tb[p] = y;\n\t\tsum += a[p];\n\n\t\tif (p != 1 && p != 2 * n) sa.insert(make_pair(y - x, p));\n\n\t\t//printf(\"sa \"); debug(sa);\n\t\t//printf(\"sb \"); debug(sb);\n\n\t\tint ndel = 0;\n\t\twhile(!sb.empty()) {\n\t\t\tif (ndel >= 2 && sb.size() % 2 == 0) break;\n\t\t\t++ndel;\n\t\t\tsum -= b[(*sb.begin()).second];\n\t\t\tsum += a[(*sb.begin()).second];\n\t\t\tsa.insert(*sb.begin());\n\t\t\tsb.erase(sb.begin());\n\t\t}\n\n\t\treset();\n\n\t\t//printf(\"sa \"); debug(sa);\n\t\t//printf(\"sb \"); debug(sb);\n\n\t\tprintf(\"%lld\\n\", sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(...) overload_rep(__VA_ARGS__, rep_1, rep_0)(__VA_ARGS__)\n#define rep_0(i, end) for(int i = 0; i < (end); ++i)\n#define rep_1(i, fr, ba) for(int i = (fr); i <= (ba); ++i)\n#define overload_rep(arg0, arg1, arg2, name, ...) name\n#define all(box) box.begin(), box.end()\n\ntemplate <class T> inline bool chmax(T& lhs, const T& rhs) { if(lhs < rhs) { lhs = rhs; return 1; } return 0; }\ntemplate <class T> inline bool chmin(T& lhs, const T& rhs) { if(lhs > rhs) { lhs = rhs; return 1; } return 0; }\n\ntypedef long long lint;\nconstexpr int MX = 200000;\nconstexpr lint inf = 1ll << 60;\n\nint N, Q;\nint A[MX], B[MX];\nlint dp[MX][2];\n\nint main() {\n\n    cin >> N >> Q;\n    rep(i, 2 * N) cin >> A[i];\n    rep(i, 2 * N) cin >> B[i];\n\n    while(Q--) {\n\n        int p, a, b;\n        cin >> p >> a >> b;\n        A[p - 1] = a, B[p - 1] = b;\n\n        rep(i, 2 * N) rep(j, 2)\n            dp[i][j] = -inf;\n        dp[1][0] = A[0] + A[2 * N - 1];\n\n        rep(i, 1, 2 * N - 2) {\n            chmax(dp[i + 1][0], dp[i][1] + B[i]);\n            chmax(dp[i + 1][0], dp[i][0] + A[i]);\n            chmax(dp[i + 1][1], dp[i][0] + B[i]);\n            chmax(dp[i + 1][1], dp[i][1] + A[i]);\n        }\n\n        cout << dp[2 * N - 1][0] << '\\n';\n\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n\n#define ll long long\nusing namespace std;\nll bit[400010],a[200010],b[200010],p[100010],x[100010],y[100010],n,q,inv[300010],m;\nvector<ll> v;\nmap<ll,ll> mp;\nll sum(ll i){\n\tll s = 0;\n\twhile(i>0){\n\t\ts += bit[i];\n\t\ti -= i&-i;\n\t}\n\treturn s;\n}\n\nvoid add(ll i, ll x){\n\twhile(i<=m){\n\t\tbit[i] += x;\n\t\ti += i&-i;\n\t}\n}\nint main(){\n\tll z,ans=0,i;\n\tcin >> n >> q;\n\tfor(i=0;i<2*n;i++){\n\t\tcin >> a[i];\n\t}\n\tfor(i=0;i<2*n;i++){\n\t\tcin >> b[i];\n\t}\n\tfor(i=1;i<2*n-1;i++){\n\t\tv.push_back(a[i]-b[i]);\n\t}\n\tfor(i=0;i<q;i++){\n\t\tcin >> p[i] ;\n\t\tp[i]--;\n\t\tcin>> x[i] >> y[i];\n\t\tif(p[i]!=0 && p[i]!=2*n-1){\n\t\t\tv.push_back(x[i]-y[i]);\n\t\t}\n\t}\n\tv.push_back(0);\n\tsort(v.begin(),v.end());\n\tm = v.size()+1;\n\tint now = 1;\n\tmp[v[0]] = 1;\n\tinv[1] = v[0];\n\tif(v[0]==0){\n\t\tz = 1;\n\t}\n\tfor(i=1;i<v.size();i++){\n\t\tif(v[i]>v[i-1]){\n\t\t\tnow++;\n\t\t}\n\t\tmp[v[i]] = now;\n\t\tinv[now] = v[i];\n\t\tif(v[i]==0){\n\t\t\tz = now;\n\t\t}\n\t}\n\tnow++;\n\tll cnt = 0;\n\tfor(i=1;i<2*n-1;i++){\n\t\tadd(mp[a[i]-b[i]],1);\n\t\tif(a[i]>=b[i]){\n\t\t\tans += a[i];\n\t\t\tcnt += 1;\n\t\t}else{\n\t\t\tans += b[i];\n\t\t}\n\t}\n\tans += a[0]+a[2*n-1];\n\tfor(i=0;i<q;i++){\n\t\tif(p[i]==0 || p[i]==2*n-1){\n\t\t\tans -= a[p[i]];\n\t\t\tans += x[i];\n\t\t\ta[p[i]] = x[i];\n\t\t\tb[p[i]] = y[i];\n\t\t}else{\n\t\t\tans -= max(a[p[i]],b[p[i]]);\n\t\t\tans += max(x[i],y[i]);\n\t\t\tadd(mp[a[p[i]] - b[p[i]]],-1);\n\t\t\tadd(mp[x[i] - y[i]],1);\n\t\t\tif(a[p[i]]-b[p[i]]>0 ^ x[i]-y[i]>0){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\ta[p[i]] = x[i];\n\t\t\tb[p[i]] = y[i];\n\t\t}\n\t\tif(cnt%2==0){\n\t\t\tcout << ans << endl;\n\t\t}else{\n\t\t\tlong long l=0,r=now,mid;\n\t\t\tint s = sum(z);\n\t\t\twhile(r - l>1){\n\t\t\t\tmid = (l+r)/2;\n\t\t\t\tif(sum(mid)>=s+1){\n\t\t\t\t\tr = mid;\n\t\t\t\t}else{\n\t\t\t\t\tl = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong long m1 = inv[r];\n\t\t\tl=0,r=now;\n\t\t\twhile(r - l>1){\n\t\t\t\tmid = (l+r)/2;\n\t\t\t\tif(sum(mid)<s){\n\t\t\t\t\tl = mid;\n\t\t\t\t}else{\n\t\t\t\t\tr = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong long m2 = inv[r];\n\t\t\tcout << max(ans - m1,ans + m2) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sp ' '\n#define mkp make_pair\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define lP pair<ll,ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\nconst int mod = 1000000007, mod998 = 998244353;\nconst string nyan(\"(=^・ω・^=)\");\n\nint N, Q, a[100000], b[100000], p, x, y;\nbool u[100000];\nset<pair<int, int>>st[2];\nll res;\n\nint main() {\n\tcin >> N >> Q;\n\tN <<= 1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> b[i];\n\t}\n\t--Q;\n\tcin >> p >> x >> y;\n\t--p;\n\ta[p] = x;\n\tb[p] = y;\n\tres = a[0] + a[N - 1];\n\tfor (int i = 1; i < N - 1; ++i) {\n\t\tif (a[i] >= b[i]) {\n\t\t\tu[i] = true;\n\t\t\tres += a[i];\n\t\t\tst[1].insert(mkp(a[i] - b[i], i));\n\t\t}\n\t\telse {\n\t\t\tres += b[i];\n\t\t\tst[0].insert(mkp(b[i] - a[i], i));\n\t\t}\n\t}\n\tif (st[0].size() & 1) {\n\t\tif (st[0].begin()->first > st[1].begin()->first) {\n\t\t\tres -= st[1].begin()->first;\n\t\t\tu[st[1].begin()->second] ^= true;\n\t\t\tst[0].insert(mkp(-st[1].begin()->first, st[1].begin()->second));\n\t\t\tst[1].erase(st[1].begin());\n\t\t}\n\t\telse {\n\t\t\tres -= st[0].begin()->first;\n\t\t\tu[st[0].begin()->second] ^= true;\n\t\t\tst[1].insert(mkp(-st[0].begin()->first, st[0].begin()->second));\n\t\t\tst[0].erase(st[0].begin());\n\t\t}\n\t}\n\tcout << res << endl;\n\twhile (Q--) {\n\t\tcin >> p >> x >> y;\n\t\t--p;\n\t\tif (p == 0 || p == N - 1) {\n\t\t\tres += x - a[p];\n\t\t\ta[p] = x;\n\t\t}\n\t\telse {\n\t\t\tif (u[p]) {\n\t\t\t\tres += x - a[p];\n\t\t\t\tst[1].erase(mkp(a[p] - b[p], p));\n\t\t\t\tst[1].insert(mkp(x - y, p));\n\t\t\t\tauto it = st[1].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[0].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[1].erase(p1);\n\t\t\t\t\tst[1].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres += y - b[p];\n\t\t\t\tst[0].erase(mkp(b[p] - a[p], p));\n\t\t\t\tst[0].insert(mkp(y - x, p));\n\t\t\t\tauto it = st[0].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[1].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[0].erase(p1);\n\t\t\t\t\tst[0].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!st[0].empty() && !st[1].empty() && st[0].begin()->first + st[1].begin()->first < 0) {\n\t\t\t\tpair<int, int> p1 = *st[0].begin();\n\t\t\t\tpair<int, int> p2 = *st[1].begin();\n\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\tu[p1.second] ^= true;\n\t\t\t\tu[p2.second] ^= true;\n\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\tst[0].erase(p1);\n\t\t\t\tst[1].erase(p2);\n\t\t\t}\n\t\t\ta[p] = x;\n\t\t\tb[p] = y;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define inf 1000000000000000000\n\nusing namespace std;\n\nllint N, Q;\nllint a[200005], b[200005];\nllint dif[200005];\n\nllint pseg[1<<19];\nvoid pinit()\n{\n\tfor(int i = 0; i < (1<<19); i++) pseg[i] = inf;\n}\nvoid pupdate(llint k, llint val)\n{\n\tk += 1<<18;\n\tpseg[k] = val;\n\twhile(k > 1){\n\t\tk /= 2;\n\t\tpseg[k] = min(pseg[2*k], pseg[2*k+1]);\n\t}\n}\nllint pquery(llint a, llint b, llint k, llint l, llint r)\n{\n\tif(r < a || b < l) return inf;\n\tif(a <= l && r <= b) return pseg[k];\n\tllint lval = pquery(a, b, k*2, l, (l+r)/2);\n\tllint rval = pquery(a, b, k*2+1, (l+r)/2+1, r);\n\treturn min(lval, rval);\n}\n\nllint nseg[1<<19];\nvoid ninit()\n{\n\tfor(int i = 0; i < (1<<19); i++) nseg[i] = -inf;\n}\nvoid nupdate(llint k, llint val)\n{\n\tk += 1<<18;\n\tnseg[k] = val;\n\twhile(k > 1){\n\t\tk /= 2;\n\t\tnseg[k] = max(nseg[2*k], nseg[2*k+1]);\n\t}\n}\nllint nquery(llint a, llint b, llint k, llint l, llint r)\n{\n\tif(r < a || b < l) return -inf;\n\tif(a <= l && r <= b) return nseg[k];\n\tllint lval = nquery(a, b, k*2, l, (l+r)/2);\n\tllint rval = nquery(a, b, k*2+1, (l+r)/2+1, r);\n\treturn max(lval, rval);\n}\n\n\nint main(void)\n{\n\tpinit(), ninit();\n\t\n\tcin >> N >> Q;\n\tfor(int i = 1; i <= 2*N; i++) cin >> a[i];\n\tfor(int i = 1; i <= 2*N; i++) cin >> b[i];\n\t\n\tllint asum = 0;\n\tfor(int i = 1; i <= 2*N; i++){\n\t\tasum += a[i];\n\t\tdif[i] = b[i] - a[i];\n\t}\n\t\n\tllint pcnt = 0, psum = 0;\n\tfor(int i = 2; i <= 2*N-1; i++){\n\t\tif(dif[i] >= 0){\n\t\t\tpupdate(i, dif[i]);\n\t\t\tpcnt++;\n\t\t\tpsum += dif[i];\n\t\t}\n\t\telse nupdate(i, dif[i]);\n\t}\n\t\n\tllint p, x, y;\n\tfor(int q = 0; q < Q; q++){\n\t\tcin >> p >> x >> y;\n\t\tif(p == 1 || p == 2*N){\n\t\t\tasum = asum - a[p] + x;\n\t\t\tgoto end;\n\t\t}\n\t\tif(dif[p] >= 0 && y - x < 0) pcnt--;\n\t\tif(dif[p] < 0 && y - x >= 0) pcnt++;\n\t\tasum = asum - a[p] + x;\n\t\ta[p] = x;\n\t\t\n\t\tif(dif[p] >= 0){\n\t\t\tpupdate(p, inf);\n\t\t\tpsum -= dif[p];\n\t\t}\n\t\telse nupdate(p, -inf);\n\t\t\n\t\tdif[p] = y - x;\n\t\tif(dif[p] >= 0){\n\t\t\tpupdate(p, dif[p]);\n\t\t\tpsum += dif[p];\n\t\t}\n\t\telse nupdate(p, dif[p]);\n\t\t\n\t\tend:;\n\t\t\n\t\tllint ans;\n\t\tif(pcnt % 2 == 0) ans = asum + psum;\n\t\telse{\n\t\t\tans = max(asum + psum + nquery(2, 2*N-1, 1, 0, (1<<18)-1),\n\t\t\t\tasum + psum - pquery(2, 2*N-1, 1, 0, (1<<18)-1));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\n// use 2^i size by yourself\n// otherwise, maybe, it needs exchange law\n/// --- SegmentTree Library {{{ ///\n\n/*\n   struct Monoid {\n   using T = _underlying_set_;\n   static T op(const T& a, const T& b) { return _a_op_b_; }\n   static constexpr T identity() { return _identity_element_; }\n   };\n   */\n\ntemplate<class Monoid>\nstruct SegTree {\n  private:\n    using T = typename Monoid::T;\n    const int n;\n    vector<T> data;\n    void propTo(int i) { data[i] = Monoid::op(data[2 * i], data[2 * i + 1]); }\n\n  public:\n    SegTree(int n, const T& v = Monoid::identity())\n      : n(n),data(2 * n, v) {}\n\n    template <class InputIt>\n      SegTree(InputIt first, InputIt last)\n      : n(distance(first, last)), data(2 * n, Monoid::identity()) {\n        copy(first, last, begin(data) + n);\n        // たぶん深いところから更新するため\n        for(int i = n - 1; i > 0; i--) propTo(i);\n      }\n\n    void set(int i, const T& v) {\n      data[i += n] = v;\n      while(i >>= 1) propTo(i);\n    }\n\n    T get(int i) { return data[i + n]; }\n\n    T query(int l, int r) {\n      l = max(0, l); r = min(r, n);\n      T tmpL = Monoid::identity(), tmpR = Monoid::identity();\n      for(l += n, r += n; l < r; l >>= 1, r >>= 1) {\n        if(l & 1) tmpL = Monoid::op(tmpL, data[l++]);\n        if(r & 1) tmpR = Monoid::op(data[--r], tmpR);\n      }\n      return Monoid::op(tmpL, tmpR);\n    }\n};\n\nstruct RMQMonoid {\n  using T = long long;\n  static T op(const T& a, const T& b) { return std::min(a, b); }\n  static constexpr T identity() { return numeric_limits<T>::max(); }\n};\nstruct RSQMonoid {\n  using T = long long;\n  static T op(const T& a, const T& b) { return a + b; }\n  static constexpr T identity() { return 0; }\n};\nstruct RMaxQMonoid {\n  using T = long long;\n  static T op(const T& a, const T& b) { return std::max(a, b); }\n  static constexpr T identity() { return numeric_limits<T>::min(); }\n};\n\nusing RMQ = SegTree<RMQMonoid>;\nusing RSQ = SegTree<RSQMonoid>;\nusing RMaxQ = SegTree<RMaxQMonoid>;\n\n/// }}}--- ///\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n, q; cin >> n >> q;\n  n <<= 1;\n  int m = 1;\n  while(m < n) m <<= 1;\n  vector<ll> a(n), b(n);\n  RMaxQ treeone(m);\n  for(int i = 0; i < n; i++) cin >> a[i];\n  for(int i = 0; i < n; i++) cin >> b[i];\n  int use = 0;\n  ll now = 0;\n  for(int i = 1; i < n - 1; i++) {\n    now += max(a[i], b[i]);\n    if(a[i] < b[i]) use ^= 1;\n    treeone.set(i, -abs(a[i] - b[i]));\n  }\n\n  while(q--) {\n    int i, x, y; cin >> i >> x >> y;\n    i--;\n    if(i == 0 || i == n - 1) {\n    } else {\n      now -= max(a[i], b[i]);\n      if(a[i] < b[i]) use ^= 1;\n      now += max(x, y);\n      if(x < y) use ^= 1;\n      treeone.set(i, -abs(y - x));\n    }\n    a[i] = x; b[i] = y;\n    ll ans = a[0] + a[n - 1];\n    ans += now;\n    if(use) ans += treeone.query(1, n - 1);\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<long, int> P;\npriority_queue<P, vector<P>, greater<P>> que_pos;\npriority_queue<P, vector<P>> que_neg;\n\nint main(){\n    long N, Q;\n    long a[200000], b[200000];\n    cin >> N >> Q;\n    for(int i = 0; i < 2*N ; i++){\n        cin >> a[i];\n    }\n    for(int i = 0; i < 2*N ; i++){\n        cin >> b[i];\n    }\n    long sum_a = a[0] + a[2*N-1];\n    long sum_b = 0;\n    int cnt_pos = 0;\n    for(int i = 1; i <= 2*N-2; i++){\n        if(a[i] < b[i]){\n            cnt_pos++;\n            que_pos.push(P(b[i]-a[i], i));\n            sum_b += b[i];\n        }else{\n            que_neg.push(P(b[i]-a[i], i));\n            sum_a += a[i];\n        }\n    }\n    for(int i = 0; i < Q; i++){\n        int p, x, y;\n        cin >> p >> x >> y;\n        p--;\n        if(b[p] > a[p]) {\n            cnt_pos--;\n            sum_b -= b[p];\n        }else{\n            sum_a -= a[p];\n        }\n        a[p] = x;\n        b[p] = y;\n        if(b[p] > a[p]) {\n            cnt_pos++;\n            sum_b += b[p];\n            que_pos.push(P(b[p]-a[p], p));\n        }else{\n            sum_a += a[p];\n            que_neg.push(P(b[p]-a[p], p));\n        }\n        \n        if(cnt_pos%2 == 0){\n            //cout << 'H' << endl;\n            cout << sum_a+sum_b << endl;\n        }else{\n            while(!que_pos.empty()){\n                P top = que_pos.top();\n                int idx = top.second;\n                if(top.first != (b[idx]-a[idx])) que_pos.pop();\n                else break;\n            }\n            while(!que_neg.empty()){\n                P top = que_neg.top();\n                int idx = top.second;\n                if(top.first != (b[idx]-a[idx])) que_neg.pop();\n                else break;\n            }\n            \n            if(que_neg.top().first+que_pos.top().first >= 0){\n                cout  << sum_a + sum_b + que_neg.top().first << endl;\n            }else{\n                cout  << sum_a + sum_b - que_pos.top().first << endl; \n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int&x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char&x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char*x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf&x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf&x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint&x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull&x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char*x){while(*x)P(*x++);RT}\nI Fw&OP()(const char*x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\ntypedef std::pair<ll,ll>pll;\n\nconst int N=200007;\n\npll f[1<<19];\nint n,m,a[N],b[N];\n\ninline void pu(int x)\n{\n\tf[x]=mp(max(f[x<<1].xx+f[x<<1|1].xx,f[x<<1].yy+f[x<<1|1].yy),max(f[x<<1].xx+f[x<<1|1].yy,f[x<<1].yy+f[x<<1|1].xx));\n}\n\ninline void set(int x,int p)\n{\n\tf[x]=mp(b[p],a[p]);\n}\n\ninline void build(int x,int l,int r)\n{\n\tif(l==r)set(x,l);\n\telse\n\t{\n\t\tint t=(l+r)>>1;\n\t\tbuild(x<<1,l,t);\n\t\tbuild(x<<1|1,t+1,r);\n\t\tpu(x);\n\t}\n}\n\ninline void modify(int x,int l,int r,int p)\n{\n\tif(l==r)set(x,l);\n\telse\n\t{\n\t\tint t=(l+r)>>1;\n\t\tif(p<=t)modify(x<<1,l,t,p);\n\t\telse modify(x<<1|1,t+1,r,p);\n\t\tpu(x);\n\t}\n}\n\nint main()\n{\n\tin,n,m;\n\tfo1(i,n*2)in,a[i];\n\tfo1(i,n*2)in,b[i];\n\tbuild(1,2,n*2-1);\n\twhile(m--)\n\t{\n\t\tint p,x,y;\n\t\tin,p,x,y;\n\t\ta[p]=x,b[p]=y;\n\t\tmodify(1,2,n*2-1,p);\n\t\tout,f[1].xx+a[1]+a[n*2],'\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int&x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char&x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char*x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf&x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf&x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint&x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull&x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char*x){while(*x)P(*x++);RT}\nI Fw&OP()(const char*x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\ntypedef std::pair<ll,ll>pll;\n\nconst int N=200007;\n\npll f[1<<19];\nint n,m,a[N],b[N];\n\ninline void pu(int x)\n{\n\tf[x]=mp(max(f[x<<1].xx+f[x<<1|1].xx,f[x<<1].yy+f[x<<1|1].yy),max(f[x<<1].xx+f[x<<1|1].yy,f[x<<1].yy+f[x<<1|1].xx));\n}\n\ninline void set(int x,int p)\n{\n\tf[x]=mp(b[p],a[p]);\n}\n\ninline void build(int x,int l,int r)\n{\n\tif(l==r)set(x,l);\n\telse\n\t{\n\t\tint t=(l+r)>>1;\n\t\tbuild(x<<1,l,t);\n\t\tbuild(x<<1|1,t+1,r);\n\t\tpu(x);\n\t}\n}\n\ninline void modify(int x,int l,int r,int p)\n{\n\tif(l==r)set(x,l);\n\telse\n\t{\n\t\tint t=(l+r)>>1;\n\t\tif(p<=t)modify(x<<1,l,t,p);\n\t\telse modify(x<<1|1,t+1,r,p);\n\t\tpu(x);\n\t}\n}\n\nint main()\n{\n\tin,n,m;\n\tfo1(i,n*2)in,a[i];\n\tfo1(i,n*2)in,b[i];\n\tif(n>1)build(1,2,n*2-1);\n\twhile(m--)\n\t{\n\t\tint p,x,y;\n\t\tin,p,x,y;\n\t\ta[p]=x,b[p]=y;\n\t\tif(p!=1&&p!=n*2&&n>1)modify(1,2,n*2-1,p);\n\t\tout,f[1].xx+a[1]+a[n*2],'\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nll a[411111];\nll b[411111];\nmultiset<ll> pos;\nmultiset<ll> neg;\nll sumpos;\n\nvoid add(ll x)\n{\n\tif(x>0)\n\t{\n\t\tpos.insert(x);\n\t\tsumpos+=x;\n\t}\n\telse\n\t{\n\t\tneg.insert(-x);\n\t}\n}\n\nvoid del(ll x)\n{\n\tif(x>0)\n\t{\n\t\tauto it = pos.lower_bound(x);\n\t\tpos.erase(it);\n\t\tsumpos-=x;\n\t}\n\telse\n\t{\n\t\tauto it = neg.lower_bound(-x);\n\t\tneg.erase(it);\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tsumpos=0;\n\tint n,q; cin>>n>>q; n*=2;\n\tll sum=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i];\n\t\tsum+=a[i];\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>b[i];\n\t\tb[i]-=a[i];\n\t\tif(i>=1&&i+1<n) add(b[i]);\n\t}\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tint p,u,v;\n\t\tcin>>p>>u>>v;\n\t\tp--;\n\t\tsum-=a[p]; sum+=u;\n\t\tif(p>=1&&p+1<n)\n\t\t{\n\t\t\tdel(b[p]); add(v-u);\n\t\t}\n\t\ta[p]=u; b[p]=v-u;\n\t\tif(pos.size()%2==0)\n\t\t{\n\t\t\tcout<<sum+sumpos<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(neg.empty())\n\t\t\t{\n\t\t\t\tcout<<sum+sumpos-(*pos.begin())<<'\\n';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout<<sum+max(sumpos-(*pos.begin()), sumpos-(*neg.begin()))<<'\\n';\n\t\t\t}\n\t\t}\n\t}\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint main() {\n        int n, q;\n        scanf(\"%d%d\", &n, &q);\n        n = 2 * n;\n        vector<long long> a(n), b(n);\n        for (int i = 0; i < n; i ++) scanf(\"%lld\", &a[i]);\n        for (int i = 0; i < n; i ++) scanf(\"%lld\", &b[i]);\n        multiset<long long> positive, negative;\n        long long psum = 0, nsum = 0;\n        for (int i = 0; i < n; i ++) {\n                if (i == 0 || i == n - 1) psum += a[i];\n                else {\n                        long long c = a[i] - b[i];\n                        if (c >= 0) positive.insert(c), psum += a[i];\n                        else negative.insert(- c), nsum += b[i];\n                }\n        }\n        while (q --) {\n                long long p, x, y;\n                scanf(\"%lld%lld%lld\", &p, &x, &y); p --;\n                if (p == 0 || p == n - 1) psum -= a[p], psum += x;\n                else {\n                        long long c = a[p] - b[p];\n                        if (c >= 0) positive.erase(positive.find(c)), psum -= a[p];\n                        else negative.erase(negative.find(-c)), nsum -= b[p];\n                        long long z = x - y;\n                        if (z >= 0) positive.insert(z), psum += x;\n                        else negative.insert(-z), nsum += y;\n                }\n                a[p] = x, b[p] = y;\n                long long ans;\n                if (positive.size() % 2 == 0) ans = psum + nsum;\n                else ans = psum + nsum - min(*positive.begin(), *negative.begin());\n                printf(\"%lld\\n\", ans);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll, int> P;\n\nint main()\n{\n\tint n, q;\n  cin>>n>>q;\n  ll a[200001], b[200001];\n  for(int i=1; i<=2*n; i++){\n    cin>>a[i];\n  }\n  for(int i=1; i<=2*n; i++){\n    cin>>b[i];\n  }\n  multiset<ll> st;\n  ll ans=a[1]+a[2*n];\n  for(int i=2; i<2*n; i++){\n    if(b[i]>=a[i]) st.insert(b[i]-a[i]);\n    ans+=max(a[i], b[i]);\n  }\n  for(int i=0; i<q; i++){\n    int p; ll x, y;\n    cin>>p>>x>>y;\n    if(p==1 || p==2*n){\n      ans=ans-a[p]+x;\n    }else{\n      if(b[p]>=a[p]) st.erase(st.lower_bound(b[p]-a[p]));\n      ans=ans-max(a[p], b[p])+max(x, y);\n    }\n    a[p]=x; b[p]=y;\n    if(y>=x) st.insert(y-x);\n    if((st.size())%2==0){\n      cout<<ans<<endl;\n    }else{\n      cout<<ans-*(st.begin())<<endl;\n    }\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst int N = 200005, SZ = 262144;\nconst ll INF = ll(1e18);\n\nint n, q;\nll a[N], b[N];\n\nstruct Seg{\n  ll d[2*SZ][2];\n  void m(ll *a, ll *b, ll *r){\n    ll c[2] = {-INF, -INF};\n    for(int i = 0; i < 2; i++) for(int j = 0; j < 2; j++){\n      c[i^j] = max(c[i^j], a[i] + b[j]);\n    }\n    r[0] = c[0];\n    r[1] = c[1];\n  }\n  void u(int x, int a, int b){\n    x += SZ;\n    d[x][0] = a;\n    d[x][1] = b;\n    for(x /= 2; x; x /= 2) m(d[2*x], d[2*x+1], d[x]);\n  }\n  ll g(int s, int e){\n    ll r[2] = {0, -INF};\n    for(s += SZ, e += SZ; s <= e; s /= 2, e /= 2){\n      if(s % 2 == 1) m(r, d[s++], r);\n      if(e % 2 == 0) m(r, d[e--], r);\n    }\n    return r[0];\n  }\n} S;\n\nint main(){\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n\n  cin >> n >> q;\n  n *= 2;\n  for(int i = 1; i <= n; i++) cin >> a[i];\n  for(int i = 1; i <= n; i++) cin >> b[i];\n\n  for(int i = 1; i <= n; i++) S.u(i, a[i], b[i]);\n\n  for(; q--; ){\n    int x;\n    ll y, z;\n    cin >> x >> y >> z;\n    S.u(x, y, z);\n    cout << S.d[1+SZ][0] + S.g(2, n - 1) + S.d[n+SZ][0] << '\\n';\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 200100\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> par;\npar s[maxn<<2];\nint n,a[maxn],b[maxn],q;\nvoid upd(int o){\n\ts[o].first=max(s[o<<1].first+s[o<<1|1].first,s[o<<1].second+s[o<<1|1].second);\n\ts[o].second=max(s[o<<1].second+s[o<<1|1].first,s[o<<1].first+s[o<<1|1].second); \n}\nvoid build(int o,int l,int r){\n\tif(l==r){\n\t\ts[o]=par(b[l],a[l]);\n\t\treturn ;\n\t}\n\tint mid=l+r>>1;\n\tbuild(o<<1,l,mid);\n\tbuild(o<<1|1,mid+1,r);\n\tupd(o);\n}\nvoid mdy(int o,int l,int r,int k,par p){\n\tif(l==r){\n\t\ts[o]=p;\n\t\treturn ;\n\t}\n\tint mid=l+r>>1;\n\tif(k<=mid)mdy(o<<1,l,mid,k,p);\n\telse mdy(o<<1|1,mid+1,r,k,p);\n\tupd(o);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=2*n;++i)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=2*n;++i)scanf(\"%d\",&b[i]);\n\tbuild(1,2,2*n-1);\n\tfor(int i=1,p,x,y;i<=n;++i){\n\t\tscanf(\"%d%d%d\",&p,&x,&y);\n\t\tif(2<=p&&p<=2*n-1)mdy(1,2,2*n-1,p,par(y,x));\n\t\telse a[p]=x,b[p]=y;\n\t\tprintf(\"%lld\\n\",a[1]+a[2*n]+s[1].first); \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=1e9+7;\nconst llint big=1e15+100;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){return a/gcd(a,b)*b;}\nint main(void){\n\tint i,n,q;cin>>n>>q;\n\tllint gen=0,gu=0;\n\tvector<llint>a(2*n);for(auto &it:a){cin>>it;}\n\tvector<llint>b(2*n);for(auto &it:b){cin>>it;}\n\tmultiset<int>aki;\n\tgen=a[0]+a[2*n-1];\n\tfor(i=1;i<2*n-1;i++){\n\t\tgen+=max(a[i],b[i]);\n\t\taki.ins(abs(a[i]-b[i]));\n\t\tif(a[i]>b[i]){gu++;}\n\t}\n\twhile(q--){\n\t\tint p,x,y;cin>>p>>x>>y;p--;\n\t\tif(p==0||p==2*n-1){gen-=a[p];a[p]=x;b[p]=y;gen+=a[p];}\n\t\telse{\n\t\t\tif(a[p]>b[p]){gu++;}\n\t\t\taki.erase(aki.lower_bound(abs(a[p]-b[p])));\n\t\t\tgen-=max(a[p],b[p]);\n\t\t\ta[p]=x;b[p]=y;\n\t\t\tif(a[p]>b[p]){gu++;}\n\t\t\taki.ins(abs(a[p]-b[p]));\n\t\t\tgen+=max(a[p],b[p]);\n\t\t}\n\t\tif(gu%2==0){cout<<gen<<endl;}\n\t\telse{cout<<gen-(*aki.begin())<<endl;}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint N, Q;\n \nsigned main() {\n    cin >> N >> Q;\n\n    int L = 2*N;\n    vector<int> A(L), B(L);\n    for(int i=0; i<L; i++) cin >> A[i];\n    for(int i=0; i<L; i++) cin >> B[i];\n\n    int asum = accumulate(A.begin(), A.end(), 0LL);\n    set< pair<int, int> > more, less;\n\n    // B - A >= 0 全部取った時の和\n    int cur_max = 0;\n    for(int i=1; i<L-1; i++) {\n        int diff = B[i] - A[i];\n        if(diff >= 0) {\n            more.insert(make_pair(diff, i));\n            cur_max += diff;\n        }\n        else {\n            less.insert(make_pair(-diff, i));\n        }\n    }\n\n    for(int i=0; i<Q; i++) {\n        int p, x, y; cin >> p >> x >> y; p--;\n        asum -= A[p];\n\n        if(p != 0 && p != L-1) {\n            pair<int, int> elem_more = make_pair(B[p] - A[p], p);\n            pair<int, int> elem_less = make_pair(A[p] - B[p], p);\n            if(more.count(elem_more)) {\n                more.erase(elem_more);\n                cur_max -= B[p] - A[p];\n            }\n            if(less.count(elem_less)) {\n                less.erase(elem_less);\n            }\n        }\n\n        A[p] = x, B[p] = y;\n        asum += A[p];\n\n        if(p != 0 && p != L-1) {\n            int diff = B[p] - A[p];\n            if(diff >= 0) {\n                more.insert(make_pair(diff, p));\n                cur_max += diff;\n            }\n            else {\n                less.insert(make_pair(-diff, p));\n            }\n        }\n\n        int sz = more.size(), tmp_max = cur_max;\n        for(auto it=more.begin(); it!=more.end(); it++) {\n            if(sz % 2 == 0) break;\n            sz--;\n            // printf(\"reduce: %lld\\n\", it -> first);\n            tmp_max -= it -> first;\n        }\n        if(more.size() % 2 == 1 && less.size()) chmax(tmp_max, cur_max - less.begin()->first);\n\n        // printf(\"asum = %lld, tmp_max = %lld\\n\", asum, tmp_max);\n        cout << asum + tmp_max << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nstruct Query\n{\n    using type = P;\n    static type id() { return P(0, -1e15); }\n    static type op(const type &l, const type &r) { return P(max(l.first + r.first, l.second + r.second), max(l.first + r.second, l.second + r.first)); }\n};\n\ntemplate <typename M>\nclass SegmentTree\n{\n    using T = typename M::type;\n    int n;\n    std::vector<T> node;\n\n  public:\n    // v を基に初期化\n    SegmentTree(const std::vector<T> &v)\n    {\n        // n は v.size() 以上の最小の2冪\n        n = 1;\n        while (n < int(v.size()))\n            n *= 2;\n        node.resize(2 * n - 1, M::id());\n\n        // i の子 -> 2*i+1, 2*i+2 , 親 -> (i-1)/2\n        for (int i = 0; i < int(v.size()); i++)\n            node[i + n - 1] = v[i];\n        for (int i = n - 2; i >= 0; i--)\n            node[i] = M::op(node[2 * i + 1], node[2 * i + 2]);\n    }\n    // Monoid::id 初期化\n    SegmentTree(int _n)\n    {\n        // n は v.size() 以上の最小の2冪\n        n = 1;\n        while (n < _n)\n            n *= 2;\n        node.resize(2 * n - 1, M::id());\n    }\n    // x 番目を val に更新\n    void update(int x, T val)\n    {\n        x += n - 1;\n        node[x] = val;\n        while (x > 0)\n        {\n            x = (x - 1) / 2;\n            node[x] = M::op(node[2 * x + 1], node[2 * x + 2]);\n        }\n    }\n    // v[x] を M::op(v[x], val) に更新\n    void add(int x, T val)\n    {\n        x += n - 1;\n        node[x] = M::op(node[x], val);\n        while (x > 0)\n        {\n            x = (x - 1) / 2;\n            node[x] = M::op(node[2 * x + 1], node[2 * x + 2]);\n        }\n    }\n    // [a, b) の op\n    // k := 今居るノード\n    T query(int a, int b, int k = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n            r = n;\n        if (r <= a || b <= l)\n            return M::id();\n        if (a <= l && r <= b)\n            return node[k];\n\n        T vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        T vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return M::op(vl, vr);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, q;\n    cin >> n >> q;\n    assert(n * q <= 100000);\n    vector<ll> a(2 * n), b(2 * n);\n    vector<P> v;\n    for (int i = 0; i < 2 * n; i++)\n        cin >> a[i];\n    for (int i = 0; i < 2 * n; i++)\n    {\n        cin >> b[i];\n        v.emplace_back(P(a[i], b[i]));\n    }\n    SegmentTree<Query> st(v);\n    while (q--)\n    {\n        ll p, x, y;\n        cin >> p >> x >> y;\n        p--;\n        a[p] = x;\n        b[p] = y;\n        st.update(p, P(x, y));\n        ll ret = a[0] + a[2 * n - 1] + st.query(1, 2 * n - 1).first;\n        cout << ret << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INT long long\n#define MOD (INT)(1e16)\nusing namespace std;\nINT x, n, q, a[200020], b[200020], ans, p, y, t1, t2;\nINT f(int k, int w, int e)\n{\n    if( w < 0 or e < 0 ) return -MOD;\n    if( k == 2*n ) return ((w==0 and e==0) ? 0 : -MOD);\n    INT ret = -MOD;\n    ret = f(k+1, w+1, e+1) + a[k];\n    ret = max( ret, f(k+1, w+1, e-1) + b[k]);\n    ret = max( ret, f(k+1, w-1, e+1) + b[k]);\n    ret = max( ret, f(k+1, w-1, e-1) + a[k]);\n    return ret;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin>>n>>q;\n    for(int i = 0 ; i < 2*n ; i++ ) cin>>a[i];\n    for(int i = 0 ; i < 2*n ; i++ ) cin>>b[i];\n    while( q-- )\n    {\n        cin>>p>>x>>y; p--;\n        a[p] = x, b[p] = y;\n        cout<<f(0, 0, 0)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n    Problem: Given two sequences a and b, find two balance sequences of brackets (s, t) of the same length\n        such that their cost is maximized.\n    The cost is calculated as followed: with position i, cost += a[i] if s[i] == t[i]; cost += b[i] otherwise.\n*/\n\n#include <cstdio>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\n#define long long long\n\nconst int N = 2e5 + 2;\n\nint n, q, a[N], b[N];\nset<pair<int, int> > s[2];\nlong cost = 0, sum[2] = {0, 0};\n\nvoid Solve()\n{\n    while (q--)\n    {\n        int p, x, y; long cur = 0;\n        scanf(\"%d %d %d\", &p, &x, &y); --p;\n        if (p == 0 || p == n - 1) cost += x - a[p], a[p] = x;\n        else\n        {\n            cost += x - a[p];\n            int old_sign = b[p] - a[p] >= 0;\n            int new_sign = y - x >= 0;\n            sum[old_sign] -= b[p] - a[p];\n            sum[new_sign] += y - x;\n            s[old_sign].erase({b[p] - a[p], p});\n            s[new_sign].insert({y - x, p});\n            a[p] = x, b[p] = y;\n            if (s[1].size() & 1)\n                cur = cost + max(sum[1] + (--s[0].end())->first, sum[1] - s[1].begin()->first);\n            else cur = cost + sum[1];\n        }\n        printf(\"%lld\\n\", cur);\n    }\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &q);\n    n *= 2;\n    for (int i = 0; i < n; ++i) scanf(\"%d\", &a[i]), cost += a[i];\n    for (int i = 0; i < n; ++i)\n    {\n        scanf(\"%d\", &b[i]);\n        if (i != 0 && i != n - 1)\n        {\n            int x = b[i] - a[i];\n            int sign = x >= 0;\n            sum[sign] += x;\n            s[sign].insert({x, i});\n        }\n    }\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\n\nll solve(const VL &a, const VL& b) {\n  ll x = 0;\n  int n=a.size() / 2;\n  VL pool(2 * n - 2);\n  ll tot = 0;\n  REP(i, 0, 2 * n) {\n    if (i >= 1 && i < 2 * n - 1) {\n      pool[i - 1] = b[i] - a[i];\n    }\n    tot += a[i];\n  }\n  sort(pool.rbegin(), pool.rend());\n  for (int i = 0; i <= 2 * n - 4; i += 2) {\n    ll u = pool[i] + pool[i + 1];\n    if (u > 0) {\n      tot += u;\n    } else {\n      break;\n    }\n  }\n  return tot;\n}\n\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, q;\n  cin >> n >> q;\n  VL a(2 * n), b(2 * n);\n  REP(i, 0, 2 * n) {\n    cin >> a[i];\n  }\n  REP(i, 0, 2 * n) {\n    cin >> b[i];\n  }\n  assert (n * q <= 100000);\n  REP(i, 0, q) {\n    int p, x, y;\n    cin >> p >> x >> y;\n    p--;\n    a[p] = x;\n    b[p] = y;\n    cout << solve(a, b) << \"\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nusing ll = long long;\nusing P = pair<ll,ll>;\nint N,Q;\nconst int MN = 200010;\nll a[MN],b[MN];\nset<P> stplus,stminus;\nint main(){\n\tcin>>N>>Q;\n\tN*=2;\n\trep(i,N) cin>>a[i];\n\trep(i,N) cin>>b[i];\n\n\tll suma = 0;\n\tll sump = 0;\n\n\trep(i,N){\n\t\tif(i==0 || i==N-1) continue;\n\t\tsuma += a[i];\n\t\tif(b[i]-a[i]>=0){\n\t\t\tstplus.insert(P(b[i]-a[i],i));\n\t\t\tsump += b[i]-a[i];\n\t\t}else{\n\t\t\tstminus.insert(P(b[i]-a[i],i));\n\t\t}\n\t}\n\trep(qt,Q){\n\t\tint i;\n\t\tll x,y;\n\t\tcin>>i>>x>>y;\n\t\ti--;\n\t\tif(i==0 || i==N-1){\n\t\t\ta[i] = x;\n\t\t\tb[i] = y;\n\t\t}else{\n\t\t\tif(b[i]-a[i]>=0){\n\t\t\t\tstplus.erase(P(b[i]-a[i],i));\n\t\t\t\tsump -= b[i]-a[i];\n\t\t\t}else{\n\t\t\t\tstminus.erase(P(b[i]-a[i],i));\n\t\t\t}\n\t\t\tsuma -= a[i];\n\t\t\ta[i] = x, b[i] = y;\n\t\t\tif(b[i]-a[i]>=0){\n\t\t\t\tstplus.insert(P(b[i]-a[i],i));\n\t\t\t\tsump += b[i]-a[i];\n\t\t\t}else{\n\t\t\t\tstminus.insert(P(b[i]-a[i],i));\n\t\t\t}\n\t\t\tsuma += a[i];\n\t\t}\n\n\t\tif(stplus.size()%2 == 0){\n\t\t\tcout<<suma+sump+a[0]+a[N-1]<<endl;\n\t\t}else{\n\t\t\tll tmp = max(- (stplus.begin()->fs) , stminus.rbegin()->fs);\n\t\t\tcout<<suma+sump+a[0]+a[N-1]+tmp<<endl;\n\t\t}\n\t}\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,Q;\nint A[222222],B[222222];\n\nsigned main(){\n    scanf(\"%lld%lld\",&N,&Q);\n    N*=2;\n    rep(i,N)scanf(\"%lld\",&A[i]);\n    rep(i,N)scanf(\"%lld\",&B[i]);\n\n    multiset<int>x,y;\n    int sumx=0;\n    int base=accumulate(A,A+N,0ll);\n    for(int i=1;i+1<N;i++){\n        if(A[i]<=B[i]){\n            x.insert(B[i]-A[i]);\n            sumx+=B[i]-A[i];\n        }\n        else{\n            y.insert(B[i]-A[i]);\n        }\n    }\n\n    while(Q--){\n        int p,a,b;\n        scanf(\"%lld%lld%lld\",&p,&a,&b);\n        p--;\n\n        base-=A[p];\n        if(1<=p&&p+1<N){\n            if(A[p]<=B[p]){\n                sumx-=B[p]-A[p];\n                auto it=x.find(B[p]-A[p]);\n                x.erase(it);\n            }\n            else{\n                auto it=y.find(B[p]-A[p]);\n                y.erase(it);\n            }\n        }\n\n        A[p]=a;B[p]=b;\n        base+=A[p];\n        if(1<=p&&p+1<N){\n            if(A[p]<=B[p]){\n                x.insert(B[p]-A[p]);\n                sumx+=B[p]-A[p];\n            }\n            else{\n                y.insert(B[p]-A[p]);\n            }\n        }\n\n        int ans=0;\n        if(x.size()%2==0){\n            ans=sumx;\n        }\n        else{\n            ans=sumx-*x.begin();\n            chmax(ans,sumx+*y.rbegin());\n        }\n        printf(\"%lld\\n\",ans+base);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n#ifdef _DEBUG\n#define _GLIBCXX_DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define ll long long\n#define ll1 1ll\n#define ONE 1ll\n#define DBG 1\n#define rep(i, a, b) for (int i = (a); i < (b); i++)\n#define rrep(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define loop(n) rep(loop, (0), (n))\n#define all(c) begin(c), end(c)\nconst int INF =\nsizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\nconst double PI = acos(-1);\nconst double EPS = 1e-9;\n#define fi first\n#define se second\n#define pb push_back\n#define eb emplace_back\nusing pii = pair<int, int>;\n// template<class T> ostream &operator<<(ostream &os,T &t){dump(t);return os;}\ntemplate <typename T, typename S>\nistream &operator>>(istream &is, pair<T, S> &p) {\n\tis >> p.first >> p.second;\n\treturn is;\n}\ntemplate <typename T, typename S>\nostream &operator<<(ostream &os, pair<T, S> &p) {\n\tos << p.first << \" \" << p.second;\n\treturn os;\n}\n\ntemplate <typename T> void printvv(const vector<vector<T>> &v) {\n\tcerr << endl;\n\trep(i, 0, v.size()) rep(j, 0, v[i].size()) {\n\t\tif (typeid(v[i][j]).name() == typeid(INF).name() and v[i][j] == INF) {\n\t\t\tcerr << \"INF\";\n\t\t}\n\t\telse\n\t\t\tcerr << v[i][j];\n\t\tcerr << (j == v[i].size() - 1 ? '\\n' : ' ');\n\t}\n\tcerr << endl;\n}\n/*\ntypedef __int128_t Int;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\nstd::ostream::sentry s(dest);\n  if (s) {\n\t__uint128_t tmp = value < 0 ? -value : value;\n\tchar buffer[128];\n\tchar *d = std::end(buffer);\n\tdo {\n\t  --d;\n\t  *d = \"0123456789\"[tmp % 10];\n\t  tmp /= 10;\n\t} while (tmp != 0);\n\tif (value < 0) {\n\t  --d;\n\t  *d = '-';\n\t}\n\tint len = std::end(buffer) - d;\n\tif (dest.rdbuf()->sputn(d, len) != len) {\n\t  dest.setstate(std::ios_base::badbit);\n\t}\n  }\n  return dest;\n}\n\n__int128 parse(string &s) {\n  __int128 ret = 0;\n  for (int i = 0; i < s.length(); i++)\n\tif ('0' <= s[i] && s[i] <= '9')\n\t  ret = 10 * ret + s[i] - '0';\n  return ret;\n}\n*/\n\n#ifndef _DEBUG\n#define printvv(...)\n#endif\nvoid YES(bool f) { cout << (f ? \"YES\" : \"NO\") << endl; }\nvoid Yes(bool f) { cout << (f ? \"Yes\" : \"No\") << endl; }\ntemplate <class T> bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate <class T> bool chmin(T &a, const T &b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate< typename Monoid >\nstruct SegmentTree {\n\tusing F = function< Monoid(Monoid, Monoid) >;\n\n\tint sz;\n\tvector< Monoid > seg;\n\n\tconst F f;\n\tconst Monoid e;\n\n\tSegmentTree(int n, const F f, const Monoid &e) : f(f), e(e) {\n\t\tsz = 1;\n\t\twhile (sz < n) sz <<= 1;\n\t\tseg.assign(2 * sz, e);\n\t}\n\t// k:=[0,sz)\n\tvoid set(int k, const Monoid &x) {\n\t\tseg[k + sz] = x;\n\t}\n\n\tvoid build() {\n\t\tfor (int k = sz - 1; k > 0; k--) {\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\t// k:=[0,sz)\n\tvoid update(int k, const Monoid &x) {\n\t\tk += sz;\n\t\tseg[k] = x;\n\t\twhile (k >>= 1) {\n\t\t\tseg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n\t\t}\n\t}\n\t// [a,b)\n\tMonoid query(int a, int b) {\n\t\tMonoid L = e, R = e;\n\t\tfor (a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n\t\t\tif (a & 1) L = f(L, seg[a++]);\n\t\t\tif (b & 1) R = f(seg[--b], R);\n\t\t}\n\t\treturn f(L, R);\n\t}\n\t// k:=[0,sz)\n\tMonoid operator[](const int &k) const {\n\t\treturn seg[k + sz];\n\t}\n};\n\n\nsigned main(signed argc, char *argv[]) {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed << setprecision(12);\n\n\tint N, Q; cin >> N >> Q;\n\tvector<int>a(2 * N); rep(i, 0, 2 * N) { cin >> a[i]; }\n\tvector<int>b(2 * N); rep(i, 0, 2 * N) { cin >> b[i]; }\n\tSegmentTree<pii> seg(2 * N,\n\t\t[](pii x, pii y) {return pii(max(x.first + y.first, x.second + y.second), max(x.first + y.second, x.second + y.first)); },\n\t\tpii(0,-INF));\n\trep(i, 0, 2 * N) {\n\t\tseg.set(i, pii(b[i], a[i]));\n\t}\n\tseg.build();\n\n\tloop(Q) {\n\t\tint p, x, y; cin >> p >> x >> y;\n\t\tp--;\n\t\ta[p] = x;\n\t\tb[p] = y;\n\t\tseg.update(p, pii(y, x));\n\t\tcout << a[0] + seg.query(1, 2 * N - 1).first + a[2 * N - 1] << endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nint main() {\n        int n, q;\n        scanf(\"%d%d\", &n, &q);\n        n = 2 * n;\n        assert(n <= 5 && q <= 10);\n        vector<int> a(n), b(n);\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &a[i]);\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &b[i]);\n        set<string> ok;\n        vector<int> s(n - 2);\n        for (int i = 0; i < n - 2; i ++) s[i] = i;\n        do {\n                string tmp = \"\";\n                for (int i = 0; i < n - 2; i ++) {\n                        if (s[i] & 1) tmp += \")\";\n                        else tmp += \"(\";\n                }\n                stack<char> st;\n                st.push('(');\n                for (int i = 0; i < n - 2; i ++) {\n                        if (!st.empty() && st.top() == '(' && tmp[i] == ')') st.pop();\n                        else st.push(tmp[i]);\n                }\n                if (st.top() == '(') st.pop();\n                if (st.empty()) ok.insert(\"(\" + tmp + \")\");\n        } while (next_permutation(s.begin(), s.end()));\n        vector<string> yes;\n        for (auto it : ok) yes.push_back(it);\n        while (q --) {\n                int p, x, y;\n                scanf(\"%d%d%d\", &p, &x, &y);\n                p --;\n                a[p] = x;\n                b[p] = y;\n                long long ans = - (1LL << 60);\n                for (int i = 0; i < yes.size(); i ++) {\n                        for (int j = i; j < yes.size(); j ++) {\n                                string fi = yes[i], se = yes[j];\n                                long long res = 0;\n                                for (int i = 0; i < n; i ++) {\n                                        if (fi[i] == se[i]) res += a[i];\n                                        else res += b[i];\n                                }\n                                ans = max(ans, res);\n                        }\n                }\n                printf(\"%lld\\n\", ans);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n\nconst int MC = 200010;\nint N,Q;\nint a[MC] , b[MC];\nset<P2> S,T;\nLL ans;\n\nint main(){\n\tcin >> N >> Q;\n\trepp(i,1,2*N+1) cin >> a[i];\n\trepp(i,1,2*N+1){\n\t\tcin >> b[i];\n\t\tans += a[i];\n\t\tif(i==1 || i==2*N) continue;\n\t\tif(b[i]-a[i]>0){\n\t\t\tans += b[i] - a[i];\n\t\t\tT.insert(MP(b[i]-a[i],i));\n\t\t} else {\n\t\t\tS.insert(MP(b[i]-a[i],i));\n\t\t}\n\t}\n\trepp(i,0,Q){\n\t\tint p,x,y;\n\t\tcin >> p >> x >> y;\n\t\tif(p == 1 || p == 2*N){\n\t\t\tans += x - a[p];\n\t\t} else {\n\t\t\tif(b[p]-a[p]>0){\n\t\t\t\tT.erase(MP(b[p]-a[p],p));\n\t\t\t\tans -= b[p];\n\t\t\t} else {\n\t\t\t\tS.erase(MP(b[p]-a[p],p));\n\t\t\t\tans -= a[p];\n\t\t\t}\n\t\t\tif(y-x>0){\n\t\t\t\tT.insert(MP(y-x,p));\n\t\t\t\tans += y;\n\t\t\t} else {\n\t\t\t\tS.insert(MP(y-x,p));\n\t\t\t\tans += x;\n\t\t\t}\n\t\t}\n\t\ta[p] = x;\n\t\tb[p] = y;\n\t\tLL z = 0;\n\t\tif(T.size()%2){\n\t\t\tz = max(-(*T.begin()).first,(*S.rbegin()).first);\n\t\t}\n\t\tcout << ans + z << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(...) overload_rep(__VA_ARGS__, rep_1, rep_0)(__VA_ARGS__)\n#define rep_0(i, end) for(int i = 0; i < (end); ++i)\n#define rep_1(i, fr, ba) for(int i = (fr); i <= (ba); ++i)\n#define overload_rep(arg0, arg1, arg2, name, ...) name\n#define all(box) box.begin(), box.end()\n\ntemplate <class T> inline bool chmax(T& lhs, const T& rhs) { if(lhs < rhs) { lhs = rhs; return 1; } return 0; }\ntemplate <class T> inline bool chmin(T& lhs, const T& rhs) { if(lhs > rhs) { lhs = rhs; return 1; } return 0; }\n\ntypedef long long lint;\ntypedef pair<lint, lint> paris;\nconstexpr int MX = 200000;\nconstexpr lint inf = 1ll << 60;\n\ntemplate <class Mn, class Op>\nstruct SegmentTree {\nprivate:\n\n    int size;\n    std::vector<Mn> node;\n    const Mn unit;\n    const Op oper;\n\npublic:\n\n    SegmentTree(const Mn& unit_, const Op& oper_)\n        : unit(unit_), oper(oper_) { }\n    SegmentTree(const int& size_, const Mn& unit_, const Op& oper_)\n        : unit(unit_), oper(oper_) { init(size_); }\n    SegmentTree(const std::vector<Mn>& node_, const Mn& unit_, const Op& oper_)\n        : unit(unit_), oper(oper_) { build(node_); }\n\n    void fill() {\n        fill(node.begin(), node.end(), unit);\n    }\n\n    void init(const int& size_) {\n        for(size = 1; size < size_; size <<= 1);\n        node.assign(size << 1, unit);\n    }\n\n    void build(const std::vector<Mn>& node_) {\n        init(node_.size());\n        for(int i = 0; i < node_.size(); ++i) \n            node[i + size] = node_[i];\n        for(int i = size - 1; i > 0; --i) \n            node[i] = oper(node[i << 1], node[i << 1 | 1]);\n    }\n\n    void set_value(const int& idx, const Mn& value) {\n        int i = idx + size;\n        for(node[i] = value; (i >>= 1) > 0;)\n            node[i] = oper(node[i << 1], node[i << 1 | 1]);\n    }\n\n    void add_value(const int& idx, const Mn& plus) {\n        int i = idx + size;\n        for(node[i] += plus; (i >>= 1) > 0;)\n            node[i] = oper(node[i << 1], node[i << 1 | 1]);\n    }\n\n    Mn fold(const int& l, const int& r) const {\n        Mn result_l = unit, result_r = unit;\n        for(int tl = l + size, tr = r + size; tl < tr; tl >>= 1, tr >>= 1) {\n            if(tl & 1) result_l = oper(result_l, node[tl++]);\n            if(tr & 1) result_r = oper(node[--tr], result_r);\n        }\n        return oper(result_l, result_r);\n    }\n\n    Mn operator () (const int& l, const int& r) const {\n        return fold(l, r);\n    }\n\n    Mn operator [] (const int& idx) const {\n        return node[idx + size];\n    }\n\n};\n\nint main() {\n\n    int N, Q;\n    cin >> N >> Q;\n\n    lint fa, fb, la, lb;\n    vector<pair<lint, lint>> vec(2 * N - 2);\n    cin >> fa;\n    rep(i, 2 * N - 2) cin >> vec[i].first;\n    cin >> la;\n    cin >> fb;\n    rep(i, 2 * N - 2) cin >> vec[i].second;\n    cin >> lb;\n\n    const auto func = [](paris l, paris r) {\n        if(l.first == -inf && l.second == -inf) return r;\n        if(r.first == -inf && r.second == -inf) return l;\n        return make_pair(max(l.first + r.first, l.second + r.second), max(l.first + r.second, l.second + r.first));\n    };\n    SegmentTree<paris, decltype(func)> seg(vec, make_pair(-inf, -inf), func);\n\n    while(Q--) {\n        int p;\n        lint a, b;\n        cin >> p >> a >> b;\n        if(p == 1) fa = a;\n        else if(p == 2 * N) la = a;\n        else seg.set_value(p - 2, make_pair(a, b));\n        cout << fa + seg(0, 2 * N - 2).first + la << '\\n';\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\n\nint main(){\n    int n,q;\n    cin>>n>>q;\n    n*=2;\n    ll a[n],b[n];\n    rep(i,n)cin>>a[i];\n    rep(i,n)cin>>b[i];\n    ll ans=a[0]+a[n-1];\n    int posi=0,ze=0;\n    multiset<ll> st;\n    rep(i,n-2){\n        ans+=max(a[i+1],b[i+1]);\n        if(a[i+1]>b[i+1])posi++;\n        if(a[i+1]==b[i+1])ze++;\n        st.insert(abs(a[i+1]-b[i+1]));\n    }\n    rep(i,q){\n        ll p,x,y;\n        cin>>p>>x>>y;\n        p--;\n        if(p==0||p==n-1){\n            ans+=(ll)(x-a[p]);\n            a[p]=x;\n            cout<<ans<<endl;\n            continue;\n        }\n        ans+=max(x,y);\n        ans-=max(a[p],b[p]);\n        auto it=st.find(abs(a[p]-b[p]));\n        st.erase(it);\n        st.insert(abs(x-y));\n        if(a[p]>b[p])posi--;\n        if(a[p]==b[p])ze--;\n        if(x>y)posi++;\n        if(x==y)ze++;\n        a[p]=x;\n        b[p]=y;\n        it=st.begin();\n        if(ze>0||posi%2==0)cout<<ans<<endl;\n        else cout<<ans-*it<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint N, Q;\nll A[100010], B[100010];\nll ans;\nint cnt;\nmultiset<ll> ms;\n\nint main()\n{\n    cin >> N >> Q;\n    for(int i = 0; i < N * 2; i++)cin >> A[i];\n    for(int i = 0; i < N * 2; i++)cin >> B[i];\n\n    for(int i = 1; i < N * 2 - 1; i++)\n    {\n        if(A[i] > B[i])\n        {\n            ans += A[i];\n            cnt++;\n        }\n        else\n        {\n            ans += B[i];\n        }\n        ms.insert(abs(A[i] - B[i]));\n    }\n\n    for(int i = 0; i < Q; i++)\n    {\n        int id;\n        ll a, b;\n        cin >> id >> a >> b;\n        if(id == 1 || id == 2 * N)\n        {\n            A[id - 1] = a;\n            B[id - 1] = b;\n        }\n        else\n        {\n            cnt -= (A[id - 1] > B[id - 1]);\n            cnt += (a > b);\n            ans += -max(A[id - 1], B[id - 1]) + max(a, b);\n            ms.erase(ms.lower_bound(abs(A[id - 1] - B[id - 1])));\n            ms.insert(abs(a - b));\n            A[id - 1] = a;\n            B[id - 1] = b;\n        }\n        if(cnt % 2 == 0)cout << ans + A[0] + A[N * 2 - 1] << endl;\n        else cout << ans - (*ms.begin()) + A[0] + A[2 * N - 1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\n\nint main(){\n    int n,q;\n    cin>>n>>q;\n    n*=2;\n    ll a[n],b[n];\n    rep(i,n)cin>>a[i];\n    rep(i,n)cin>>b[i];\n    ll ans=a[0]+a[n-1];\n    int posi=0,zero=0;\n    multiset<ll> st;\n    rep(i,n-2){\n        ans+=max(a[i+1],b[i+1]);\n        if(a[i+1]>b[i+1])posi++;\n        if(a[i+1]==b[i+1])zero++;\n        st.insert(abs(a[i+1]-b[i+1]));\n    }\n    rep(i,q){\n        ll p,x,y;\n        cin>>p>>x>>y;\n        p--;\n        if(p==0||p==n-1){\n            ans+=(ll)(x-a[p]);\n            a[p]=x;\n            cout<<ans<<endl;\n            continue;\n        }\n        ans+=(ll)(max(x,y)-max(a[p],b[p]));\n        auto it=st.lower_bound(abs(a[p]-b[p]));\n        st.erase(it);\n        st.insert(abs(x-y));\n        if(a[p]-b[p]>0)posi--;\n        if(a[p]-b[p]==0)zero--;\n        if(x-y>0)posi++;\n        if(x-y==0)zero++;\n        a[p]=x;b[p]=y;\n        if(zero>0||posi%2==0)cout<<ans<<endl;\n        else cout<<ans-(*st.begin())<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<ll, ll>;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, q;\n\tcin >> n >> q;\n\tn *= 2;\n\tvector<int> a(n), b(n);\n\tfor(int i = 0; i < n; ++i){ cin >> a[i]; }\n\tfor(int i = 0; i < n; ++i){ cin >> b[i]; }\n\tset<pii> eq, ne;\n\tll base = 0, sum = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tconst int d = a[i] - b[i];\n\t\tbase += b[i];\n\t\tif(i == 0 || i + 1 == n){\n\t\t\tsum += d;\n\t\t}else if(d > 0){\n\t\t\teq.emplace(d, i);\n\t\t\tsum += d;\n\t\t}else{\n\t\t\tne.emplace(d, i);\n\t\t}\n\t}\n\twhile(q--){\n\t\tint p, x, y;\n\t\tcin >> p >> x >> y;\n\t\t--p;\n\t\tif(p == 0 || p + 1 == n){\n\t\t\tconst int before_d = a[p] - b[p];\n\t\t\tconst int after_d = x - y;\n\t\t\tbase -= b[p];\n\t\t\tbase += y;\n\t\t\ta[p] = x; b[p] = y;\n\t\t\tsum -= before_d;\n\t\t\tsum += after_d;\n\t\t}else{\n\t\t\tconst int before_d = a[p] - b[p];\n\t\t\tconst int after_d = x - y;\n\t\t\tconst auto eq_it = eq.find(pii(before_d, p));\n\t\t\tconst auto ne_it = ne.find(pii(before_d, p));\n\t\t\tif(eq_it != eq.end()){\n\t\t\t\tsum -= before_d;\n\t\t\t\teq.erase(eq_it);\n\t\t\t}else{\n\t\t\t\tne.erase(ne_it);\n\t\t\t}\n\t\t\tbase -= b[p];\n\t\t\tbase += y;\n\t\t\ta[p] = x; b[p] = y;\n\t\t\tif(after_d > 0){\n\t\t\t\tsum += after_d;\n\t\t\t\teq.emplace(after_d, p);\n\t\t\t}else{\n\t\t\t\tne.emplace(after_d, p);\n\t\t\t}\n\t\t}\t\n\t\tif(eq.size() % 2 != 0){\n\t\t\tconst auto x = *(eq.begin());\n\t\t\tconst auto y = *(ne.rbegin());\n\t\t\tif(x.first >= -y.first){\n\t\t\t\tne.erase(y);\n\t\t\t\teq.insert(y);\n\t\t\t\tsum += y.first;\n\t\t\t}else{\n\t\t\t\teq.erase(x);\n\t\t\t\tne.insert(x);\n\t\t\t\tsum -= x.first;\n\t\t\t}\n\t\t}\n\t\tcout << base + sum << endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint a[200000], b[200000];\n//dp[0][i]=(1番目からi番目まででbを偶数個選んだ時の値の総和の最大値)\n//dp[1][i]=(1番目からi番目まででbを奇数個選んだ時の値の総和の最大値)\nlong long dp[2][200000];\n\nlong long max(long long a, long long b){\n\treturn a < b ? b : a;\n}\n\n//O(nq)\nint main() {\n\tint n, q, i, j, p, x, y;\n\tscanf(\"%d%d\", &n, &q);\n\tfor (i = 0; i < 2 * n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tdp[0][0] += a[i];\n\t}\n\tfor (i = 0; i < 2 * n; i++) {\n\t\tscanf(\"%d\", &b[i]);\n\t}\n\tfor (i = 0; i < q; i++) {\n\t\tscanf(\"%d%d%d\", &p,&x,&y);\n\t\tdp[0][0] += x - a[p - 1];\n\t\ta[p - 1] = x;\n\t\tb[p - 1] = y;\n\t\tdp[0][1] = dp[0][0];\n\t\tdp[1][1] = dp[0][1] + b[1] - a[1];\n\t\tfor (j = 2; j <= 2 * n - 2; j++) {\n\t\t\tdp[0][j] = max(dp[0][j - 1], dp[1][j - 1] + b[j] - a[j]);\n\t\t\tdp[1][j] = max(dp[1][j - 1], dp[0][j - 1] + b[j] - a[j]);\n\t\t}\n\t\tprintf(\"%lld\\n\", dp[0][2 * n - 2]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    long long i, j, k;\n    long long N, Q;\n    cin >> N >> Q;\n    vector<long long> a(2*N), b(2*N);\n    for(i=0; i<2*N; i++) cin >> a[i];\n    for(i=0; i<2*N; i++) cin >> b[i];\n    long long asum = 0;\n    for(i=0; i<2*N; i++) asum += a[i];\n    priority_queue<long long> neg;\n    priority_queue<long long, vector<long long>, greater<long long>> pos;\n    long long psum = 0, np = 0;\n    for(i=1; i<2*N-1; i++){\n        if(a[i] < b[i]){\n            pos.push(b[i] - a[i]);\n            psum += b[i] - a[i];\n            np += 1;\n        }else{\n            neg.push(b[i] - a[i]);\n        }\n    }\n    map<long long, long long> del;\n\n    for(i=0; i<Q; i++){\n        long long p, x, y;\n        cin >> p >> x >> y;\n        p -= 1;\n        asum += x - a[p];\n        long long prev = b[p] - a[p];\n        long long now = y - x;\n        a[p] = x;\n        b[p] = y;\n\n        if(0 < p && p < 2*N-1){\n            if(prev > 0){\n                psum -= prev;\n                np -= 1;\n            }\n            if(now > 0){\n                psum += now;\n                np += 1;\n                pos.push(now);\n            }else{\n                neg.push(now);\n            }\n            if(prev == pos.top()){\n                pos.pop();\n                while(!pos.empty() && del[pos.top()] > 0){\n                    del[pos.top()] -= 1;\n                    pos.pop();\n                }\n            }else if(prev == neg.top()){\n                neg.pop();\n                while(!neg.empty() && del[neg.top()] > 0){\n                    del[neg.top()] -= 1;\n                    neg.pop();\n                }\n            }else{\n                del[prev] += 1;\n            }\n        }\n        \n        long long ans;\n        if(np % 2 == 0){\n            ans = asum + psum;\n        }else{\n            ans = asum + psum + max(-pos.top(), neg.top());\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define inf 1000000000000000000\n\nusing namespace std;\n\nllint N, Q;\nllint a[200005], b[200005];\nllint dif[200005];\n\nllint pseg[1<<19];\nvoid pinit()\n{\n\tfor(int i = 0; i < (1<<19); i++) pseg[i] = inf;\n}\nvoid pupdate(llint k, llint val)\n{\n\tk += 1<<18;\n\tpseg[k] = val;\n\twhile(k > 1){\n\t\tk /= 2;\n\t\tpseg[k] = min(pseg[2*k], pseg[2*k+1]);\n\t}\n}\nllint pquery(llint a, llint b, llint k, llint l, llint r)\n{\n\tif(r < a || b < l) return inf;\n\tif(a <= l && r <= b) return pseg[k];\n\tllint lval = pquery(a, b, k*2, l, (l+r)/2);\n\tllint rval = pquery(a, b, k*2+1, (l+r)/2+1, r);\n\treturn min(lval, rval);\n}\n\nllint nseg[1<<19];\nvoid ninit()\n{\n\tfor(int i = 0; i < (1<<19); i++) nseg[i] = -inf;\n}\nvoid nupdate(llint k, llint val)\n{\n\tk += 1<<18;\n\tnseg[k] = val;\n\twhile(k > 1){\n\t\tk /= 2;\n\t\tnseg[k] = max(nseg[2*k], nseg[2*k+1]);\n\t}\n}\nllint nquery(llint a, llint b, llint k, llint l, llint r)\n{\n\tif(r < a || b < l) return -inf;\n\tif(a <= l && r <= b) return nseg[k];\n\tllint lval = nquery(a, b, k*2, l, (l+r)/2);\n\tllint rval = nquery(a, b, k*2+1, (l+r)/2+1, r);\n\treturn max(lval, rval);\n}\n\n\nint main(void)\n{\n\tpinit(), ninit();\n\t\n\tcin >> N >> Q;\n\tfor(int i = 1; i <= 2*N; i++) cin >> a[i];\n\tfor(int i = 1; i <= 2*N; i++) cin >> b[i];\n\t\n\tllint asum = 0;\n\tfor(int i = 1; i <= 2*N; i++){\n\t\tasum += a[i];\n\t\tdif[i] = b[i] - a[i];\n\t}\n\t\n\tllint pcnt = 0, psum = 0;\n\tfor(int i = 2; i <= 2*N-1; i++){\n\t\tif(dif[i] >= 0){\n\t\t\tpupdate(i, dif[i]);\n\t\t\tpcnt++;\n\t\t\tpsum += dif[i];\n\t\t}\n\t\telse nupdate(i, dif[i]);\n\t}\n\t\n\tllint p, x, y;\n\tfor(int q = 0; q < Q; q++){\n\t\tcin >> p >> x >> y;\n\t\tif(p == 1 || p == 2*N){\n\t\t\tasum = asum - a[p] + x;\n\t\t\tcontinue;\n\t\t}\n\t\tif(dif[p] >= 0 && y - x < 0) pcnt--;\n\t\tif(dif[p] < 0 && y - x >= 0) pcnt++;\n\t\tasum = asum - a[p] + x;\n\t\ta[p] = x;\n\t\t\n\t\tif(dif[p] >= 0){\n\t\t\tpupdate(p, inf);\n\t\t\tpsum -= dif[p];\n\t\t}\n\t\telse nupdate(p, -inf);\n\t\t\n\t\tdif[p] = y - x;\n\t\tif(dif[p] >= 0){\n\t\t\tpupdate(p, dif[p]);\n\t\t\tpsum += dif[p];\n\t\t}\n\t\telse nupdate(p, dif[p]);\n\t\t\n\t\tllint ans;\n\t\tif(pcnt % 2 == 0) ans = asum + psum;\n\t\telse{\n\t\t\tans = max(asum + psum + nquery(2, 2*N-1, 1, 0, (1<<18)-1),\n\t\t\t\tasum + psum - pquery(2, 2*N-1, 1, 0, (1<<18)-1));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint N, Q;\n \nsigned main() {\n    cin >> N >> Q;\n\n    int L = 2*N;\n    vector<int> A(L), B(L);\n    for(int i=0; i<L; i++) cin >> A[i];\n    for(int i=0; i<L; i++) cin >> B[i];\n\n    int base = A[0] + A[L-1];\n    int asum = accumulate(A.begin(), A.end(), 0LL);\n\n    set< pair<int, int> > S;\n\n    // B - A >= 0 全部取った時の和\n    int cur_max = 0;\n    for(int i=1; i<L-1; i++) {\n        int diff = B[i] - A[i];\n        if(diff >= 0) {\n            S.insert(make_pair(i, diff));\n            cur_max += diff;\n        }\n    }\n\n    for(int i=0; i<Q; i++) {\n        int p, x, y; cin >> p >> x >> y; p--;\n        asum -= A[p];\n\n        if(p != 0 && p != L-1) {\n            pair<int, int> elem = make_pair(p, B[p] - A[p]);\n            if(S.count(elem)) {\n                S.erase(elem);\n                cur_max -= B[p] - A[p];\n            }\n        }\n\n        A[p] = x, B[p] = y;\n        asum += A[p];\n\n        if(p != 0 && p != L-1) {\n            pair<int, int> n_elem = make_pair(p, B[p] - A[p]);\n            if(n_elem.second >= 0) {\n                S.insert(n_elem);\n                cur_max += n_elem.second;\n            }\n        }\n\n        int sz = S.size(), tmp_max = cur_max;\n        for(auto it=S.begin(); it!=S.end(); it++) {\n            if(sz % 2 == 0) break;\n            sz--;\n            tmp_max -= it -> second;\n        }\n\n        // printf(\"asum = %lld, tmp_max = %lld\\n\", asum, tmp_max);\n        cout << asum + tmp_max << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i, n, m) for(int i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = std::int_fast64_t;\nusing ld = long double;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 1000000007;\nconstexpr long double eps = 1e-15;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n\tos << to_string(p.first) << \" \" << to_string(p.second);\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n\tREP(i, v.size()) {\n\t\tif(i) os << \" \";\n\t\tos << to_string(v[i]);\n\t}\n\treturn os;\n}\n\n/*\ntemplate<typename T>\nstruct Treap {\n\tdouble drand() { // random number in [0, 1]\n\t\tstatic random_device rd;\n\t\tstatic mt19937 mt(rd());\n\t\treturn (unsigned)mt() / (double)numeric_limits<unsigned>::max();\n\t}\n\tT v;\n\tdouble p;\n\tint cnt;\n\tTreap* lch;\n\tTreap* rch;\n\tTreap(T v) : v(v), p(drand()), cnt(1), lch(NULL), rch(NULL) { }\n\tTreap* update() {\n\t\tthis->size = size(this->lch) + size(this->rch) + 1;\n\t\treturn this;\n\t}\n\tstatic int size(Treap* t) {\n\t\tif(!t) return 0;\n\t\telse return t->cnt;\n\t}\n\tstatic Treap* merge(Treap* l, Treap* r) {\n\t\tif(!l || !r) {\n\t\t\tif(!l) return r;\n\t\t\telse return l;\n\t\t}\n\t\tif(l->p >= r->p) {\n\t\t\tl->rch = merge(l->rch, r);\n\t\t\treturn l->update();\n\t\t} else {\n\t\t\tr->lch = merge(r->lch, l);\n\t\t\treturn r->update();\n\t\t}\n\t}\n\tstatic pair<Treap*, Treap*> split(Treap* t, int k) {\n\t\t// split [0, k) and [k, n)\n\t\tif(k == 0) return {NULL, t};\n\t\tif(!(t->l)) {\n\t\t\tauto tmp = split(t->r, k - 1);\n\t\t\tt->r = tmp.first;\n\t\t\treturn {t->update(), tmp.second};\n\t\t} else if(!(t->r)) {\n\t\t\tauto tmp = split(t->r, k - 1);\n\t\t\tt->r = tmp.first;\n\t\t\treturn {t->update(), tmp.second};\n\t\t} else {\n\n\t\t}\n\t}\n\tTreap* insert() {\n\t}\n\tTreap* erase() {\n\t}\n\tT operator[](int k) {\n\t}\n};\n*/\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q;\n\tcin >> n >> q;\n\tvector<ll> a(2 * n), b(2 * n);\n\tREP(i, 2 * n) cin >> a[i];\n\tREP(i, 2 * n) cin >> b[i];\n\tll sum1 = 0, sum2 = 0;\n\tREP(i, 2 * n) sum1 += a[i];\n\tset<pair<ll, ll>> st;\n\tFOR(i, 1, 2 * n - 1) {\n\t\tif(b[i] - a[i] >= 0) {\n\t\t\tst.insert({b[i] - a[i], i});\n\t\t\tsum2 += b[i] - a[i];\n\t\t}\n\t}\n\tREP(i, q) {\n\t\tll p, x, y;\n\t\tcin >> p >> x >> y;\n\t\tp--;\n\t\tsum1 -= a[p]; sum1 += x;\n\t\tif(p != 0 && p != 2 * n - 1) {\n\t\t\tif(b[p] - a[p] >= 0) {\n\t\t\t\tst.erase({b[p] - a[p], p});\n\t\t\t\tsum2 -= (b[p] - a[p]);\n\t\t\t}\n\t\t\tif(y - x >= 0) {\n\t\t\t\tst.insert({y - x, p});\n\t\t\t\tsum2 += y - x;\n\t\t\t}\n\t\t}\n\t\ta[p] = x; b[p] = y;\n\t\tif(st.empty() || (int)st.size() % 2 == 0) {\n\t\t\tcout << sum1 + sum2 << endl;\n\t\t} else {\n\t\t\tcout << sum1 + sum2 - st.begin()->first << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n// ---------------------------------------\n"
  },
  {
    "language": "C++",
    "code": "/**\n    Problem: Given two sequences a and b, find two balance sequences of brackets (s, t) of the same length\n        such that their cost is maximized.\n    The cost is calculated as followed: with position i, cost += a[i] if s[i] == t[i]; cost += b[i] otherwise.\n*/\n\n#include <cstdio>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\n#define long long long\n\nconst int N = 2e5 + 2;\n\nint n, q, a[N], b[N];\nset<pair<int, int> > s[2];\nlong cost = 0, sum[2] = {0, 0};\n\nvoid Solve()\n{\n    while (q--)\n    {\n        int p, x, y; long cur = 0;\n        scanf(\"%d %d %d\", &p, &x, &y); --p;\n        if (p == 0 || p == n - 1) cost += x - a[p], a[p] = x;\n        else\n        {\n            cost += x - a[p];\n            int old_sign = b[p] - a[p] >= 0;\n            int new_sign = y - x >= 0;\n            sum[old_sign] -= b[p] - a[p];\n            sum[new_sign] += y - x;\n            s[old_sign].erase({b[p] - a[p], p});\n            s[new_sign].insert({y - x, p});\n            a[p] = x, b[p] = y;\n        }\n        if (s[1].size() & 1)\n            cur = cost + max(sum[1] + (--s[0].end())->first, sum[1] - s[1].begin()->first);\n        else cur = cost + sum[1];\n        printf(\"%lld\\n\", cur);\n    }\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &q);\n    n *= 2;\n    for (int i = 0; i < n; ++i) scanf(\"%d\", &a[i]), cost += a[i];\n    for (int i = 0; i < n; ++i)\n    {\n        scanf(\"%d\", &b[i]);\n        if (i != 0 && i != n - 1)\n        {\n            int x = b[i] - a[i];\n            int sign = x >= 0;\n            sum[sign] += x;\n            s[sign].insert({x, i});\n        }\n    }\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<class ValueMonoid, template<class...> class Container=::std::vector>\nclass SegTree{\npublic:\n    using value_structure = ValueMonoid;\n    using value_type = typename value_structure::value_type;\n    using const_reference = const value_type &;\n    using container_type = Container<value_type>;\n    using size_type = typename container_type::size_type;\n\nprivate:\n    ::std::vector<value_type> tree;\n    size_type size_;\n\n    static size_type getsize(const size_type x){\n        size_type ret = 1;\n        while(ret < x)\n            ret <<= 1;\n        return ret;\n    }\n\n    inline value_type calc(const value_type a, const value_type b){\n        return value_structure::operation(a, b);\n    }\n\n    inline void calc_node(const size_type index){\n        if(tree.size() <= (index << 1 | 1)) return;\n        tree[index] = value_structure::operation(tree[index<<1], tree[index<<1 | 1]);\n    }\npublic:\n    SegTree() : size_(0), tree(){}\n    SegTree(const size_type size)\n            : size_(size), tree(size << 1, value_structure::identity()){}\n    template<class InputIterator>\n    SegTree(InputIterator first, InputIterator last)\n            : size_(::std::distance(first, last)){\n        tree = container_type(size_, value_structure::identity());\n        tree.insert(tree.end(), first, last);\n        for(size_type i = size_;i > 0;i--){\n            calc_node(i);\n        }\n    }\n\n    size_type size() const { return size_; }\n    const_reference operator[](const size_type k) const {\n        assert(k < size_);\n        return tree[k+size_];\n    }\n\n    value_type query(size_type l, size_type r){\n        assert(l <= r);\n        assert(0 <= l && l < size_);\n        assert(0 <= r && r <= size_);\n        value_type retl = value_structure::identity(), retr = value_structure::identity();\n        for(l += size_, r += size_; l < r ; l >>= 1, r >>= 1){\n            if(l&1) retl = calc(retl, tree[l++]);\n            if(r&1) retr = calc(tree[--r], retr);\n        }\n        return calc(retl, retr);\n    }\n\n    template<class F>\n    void update(size_type index, const F& f){\n        assert(0 <= index && index < size());\n        index += size_;\n        tree[index] = f(::std::move(tree[index]));\n        while(index >>= 1)\n            calc_node(index);\n    }\n\n    /*\n    template<class F>\n    size_type search(const F& f) const { // [0, result) is True and [0, result-1) is not.\n        if(f(value_structure::identity()))\n            return 0;\n        if(!f(tree[1]))\n            return size_+1;\n        value_type acc = value_structure::identity();\n        size_type i = 1;\n        while(i <\n    }\n    */\n};\n\nclass v_monoid {\npublic:\n    using value_type = PLL;\n    static value_type identity() { return PLL(-INF_LL, -INF_LL); }\n    static value_type initializer() { return {-INF_LL, -INF_LL}; }\n    static value_type operation(const value_type& a, const value_type& b) {\n        if (a == identity()) return b;\n        if (b == identity()) return a;\n        return {max(a.fs+b.fs, a.sc+b.sc), max(a.fs+b.sc, a.sc+b.fs)};\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree{\n    using F = function<T(T,T)>;\n    int n;\n    F f;\n    T ti;\n    vector<T> dat;\n    SegmentTree(){};\n    SegmentTree(F f,T ti):f(f),ti(ti){}\n    void init(int n_){\n        n=1;\n        while(n<n_) n<<=1;\n        dat.assign(n<<1,ti);\n    }\n    void build(const vector<T> &v){\n        int n_=v.size();\n        init(n_);\n        for(int i=0;i<n_;i++) dat[n+i]=v[i];\n        for(int i=n-1;i;i--)\n            dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n    }\n    void set_val(int k,T x){\n        dat[k+=n]=x;\n        while(k>>=1)\n            dat[k]=f(dat[(k<<1)|0],dat[(k<<1)|1]);\n    }\n    T query(int a,int b){\n        T vl=ti,vr=ti;\n        for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n            if(l&1) vl=f(vl,dat[l++]);\n            if(r&1) vr=f(dat[--r],vr);\n        }\n        return f(vl,vr);\n    }\n    template<typename C>\n    int find(int st,C &check,T &acc,int k,int l,int r){\n        if(l+1==r){\n            acc=f(acc,dat[k]);\n            return check(acc)?k-n:-1;\n        }\n        int m=(l+r)>>1;\n        if(m<=st) return find(st,check,acc,(k<<1)|1,m,r);\n        if(st<=l&&!check(f(acc,dat[k]))){\n            acc=f(acc,dat[k]);\n            return -1;\n        }\n        int vl=find(st,check,acc,(k<<1)|0,l,m);\n        if(~vl) return vl;\n        return find(st,check,acc,(k<<1)|1,m,r);\n    }\n    template<typename C>\n    int find(int st,C &check){\n        T acc=ti;\n        return find(st,check,acc,1,0,n);\n    }\n};\n\n\nint main(void) {\n    int64 N, Q;\n    cin >> N >> Q;\n    N *= 2;\n    vector<int64> a(N), b(N);\n    REP(i, N) cin >> a[i];\n    REP(i, N) cin >> b[i];\n    int64 res = a[0] + a.back();\n    SegTree<v_monoid> sg(N);\n    SegmentTree<v_monoid::value_type> sgg(v_monoid::operation, v_monoid::identity());\n    sgg.init(N);\n    vector<PLL> v(N, PLL(-INF_LL, -INF_LL));\n    FOR(i, 1, N-1) {\n        sg.update(i, [&](const PLL x) { return PLL(a[i], b[i]); });\n        v[i] = PLL(a[i], b[i]);\n    }\n    sgg.build(v);\n    REP(i, Q) {\n        int64 p, x, y;\n        cin >> p >> x >> y; p--;\n        if (p == 0 || p == N-1) {\n            res -= a[p]; res += x;\n            a[p] = x;\n        } else {\n            sg.update(p, [&](const PLL alskdj) { return PLL(x, y); });\n            sgg.set_val(p, PLL(x, y));\n        }\n        cout << res + sgg.query(1, N).fs << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint N, Q;\n \nsigned main() {\n    cin >> N >> Q;\n\n    int L = 2*N;\n    vector<int> A(L), B(L);\n    for(int i=0; i<L; i++) cin >> A[i];\n    for(int i=0; i<L; i++) cin >> B[i];\n\n    int base = A[0] + A[L-1];\n    int asum = accumulate(A.begin(), A.end(), 0LL);\n\n    set< pair<int, int> > S;\n\n    // B - A >= 0 全部取った時の和\n    int cur_max = 0;\n    for(int i=1; i<L-1; i++) {\n        int diff = B[i] - A[i];\n        if(diff >= 0) {\n            S.insert(make_pair(diff, i));\n            cur_max += diff;\n        }\n    }\n\n    for(int i=0; i<Q; i++) {\n        int p, x, y; cin >> p >> x >> y; p--;\n        asum -= A[p];\n\n        if(p != 0 && p != L-1) {\n            pair<int, int> elem = make_pair(B[p] - A[p], p);\n            if(S.count(elem)) {\n                S.erase(elem);\n                cur_max -= B[p] - A[p];\n            }\n        }\n\n        A[p] = x, B[p] = y;\n        asum += A[p];\n\n        if(p != 0 && p != L-1) {\n            pair<int, int> n_elem = make_pair(B[p] - A[p], p);\n            if(n_elem.first >= 0) {\n                S.insert(n_elem);\n                cur_max += n_elem.first;\n            }\n        }\n\n        int sz = S.size(), tmp_max = cur_max;\n        for(auto it=S.begin(); it!=S.end(); it++) {\n            if(sz % 2 == 0) break;\n            sz--;\n            // printf(\"reduce: %lld\\n\", it -> first);\n            tmp_max -= it -> first;\n        }\n\n        /*\n        for(auto x : S) {\n            printf(\"elem: %lld\\n\", x.first);\n        }\n        */\n\n        // printf(\"asum = %lld, tmp_max = %lld\\n\", asum, tmp_max);\n        cout << asum + tmp_max << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  LL N, Q;\n  cin >> N >> Q;\n\n  VL as(N*2), bs(N*2);\n  cin >> as >> bs;\n\n  if(N == 1){\n    while(Q--){\n    int p, x, y;\n    cin >> p >> x >> y;\n    --p;\n    as[p] = x;\n    bs[p] = y;\n    cout<<as[0]+as[1]<<endl;      \n    }\n    return 0;\n  }\n\n  int par = 0;\n  LL sum = as[0] + as.back();\n  multiset<LL> dels;\n  FOR(i,1,2*N-1){\n    LL mx = max(as[i], bs[i]);\n    LL mn = min(as[i], bs[i]);\n    sum += mx;\n    if(mx == as[i]) par ^= 1;\n    dels.insert(mn - mx);\n  }\n\n  while(Q--){\n    LL p, x, y;\n    cin >> p >> x >> y;\n    --p;\nif(p==0||p==2*N-1){\nsum-=as[p]-x;as[p]=x;\ncout<<sum<<endl;continue;\n}\n    LL mx = max(as[p], bs[p]);\n    LL mn = min(as[p], bs[p]);\n    sum -= mx;\n    if(mx == as[p]) par ^= 1;\n    auto it = dels.find(mn - mx);\n    dels.erase(it);\n\n    as[p] = x;\n    bs[p] = y;\n    LL mx2 = max(as[p], bs[p]);\n    LL mn2 = min(as[p], bs[p]);\n    sum += mx2;\n    if(mx2 == as[p]) par ^= 1;\n    dels.insert(mn2 - mx2);\n\n    LL ans = 0;\n    if(par == 0){\n      ans = sum;\n    }\n    else{\n      auto it = dels.rbegin();\n      assert(it != dels.rend());\n      ans = sum + *it;\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#include<vector>\n#include<functional>\n#include<limits>\ntemplate<typename T>\nstruct segtree{\n\tusing F=function<T(T,T)>;\n\tconst F calcfn,updatefn;\n\tint n;\n\tT defvalue;\n\tvector<T>dat;\n\tsegtree(int n_=0,T defvalue_=numeric_limits<T>::max(),\n\t\tconst F calcfn_=[](T a,T b){return a<b?a:b;},\n\t\tconst F updatefn_=[](T a,T b){return b;}\n\t):defvalue(defvalue_),calcfn(calcfn_),updatefn(updatefn_)\n\t{\n\t\tn=1;\n\t\twhile(n<n_)n<<=1;\n\t\tdat.assign(2*n-1,defvalue);\n\t}\n\tvoid copy(const vector<T>&v)\n\t{\n\t\tfor(int i=0;i<v.size();i++)dat[i+n-1]=v[i];\n\t\tfor(int i=n-2;i>=0;i--)dat[i]=calcfn(dat[i*2+1],dat[i*2+2]);\n\t}\n\tvoid update(int i,T a)\n\t{\n\t\ti+=n-1;\n\t\tdat[i]=updatefn(dat[i],a);\n\t\twhile(i>0)\n\t\t{\n\t\t\ti=(i-1)/2;\n\t\t\tdat[i]=calcfn(dat[2*i+1],dat[2*i+2]);\n\t\t}\n\t}\n\tT query(int a,int b)//[a,b)\n\t{\n\t\tint L=(a<0?0:a>n?n:a)+n-1;\n\t\tint R=(b<0?0:b>n?n:b)+n-1;\n\t\tT lret=defvalue,rret=defvalue;\n\t\tfor(;L<R;L>>=1,R>>=1)\n\t\t{\n\t\t\tif(!(L&1))lret=calcfn(lret,dat[L]);\n\t\t\tif(!(R&1))rret=calcfn(dat[--R],rret);\n\t\t}\n\t\treturn calcfn(lret,rret);\n\t}\n};\nint N,Q;\nint A[2<<17],B[2<<17];\nmain()\n{\n\tcin>>N>>Q;\n\tN*=2;\n\tfor(int i=0;i<N;i++)cin>>A[i];\n\tfor(int i=0;i<N;i++)cin>>B[i];\n\tint bc=0;\n\tlong sum=0;\n\tvector<int>init(N);\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tif(i==0||i==N-1||A[i]>=B[i])\n\t\t{\n\t\t\tsum+=A[i];\n\t\t\tinit[i]=A[i]-B[i];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum+=B[i];\n\t\t\tinit[i]=B[i]-A[i];\n\t\t\tbc++;\n\t\t}\n\t}\n\tsegtree<int>P(N);\n\tP.copy(init);\n\tfor(;Q--;)\n\t{\n\t\tint p,x,y;cin>>p>>x>>y;p--;\n\t\tif(p==0||p==N-1||A[p]>=B[p])\n\t\t{\n\t\t\tsum-=A[p];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum-=B[p];\n\t\t\tbc--;\n\t\t}\n\t\tA[p]=x;B[p]=y;\n\t\tif(p==0||p==N-1||A[p]>=B[p])\n\t\t{\n\t\t\tsum+=A[p];\n\t\t\tP.update(p,A[p]-B[p]);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsum+=B[p];\n\t\t\tP.update(p,B[p]-A[p]);\n\t\t\tbc++;\n\t\t}\n\t\tlong now=sum;\n\t\tif(bc%2)now-=P.query(1,N-1);\n\t\tcout<<now<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define FOR(i,n) for(int i = 0; i < (n); i++)\n#define sz(c) ((int)c.size())\n#define ten(n) ((int)1e##n)\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing Pll = pair<ll, ll>;\n\ntemplate<typename ...> static inline int getchar_unlocked(void) { return getchar(); }\ntemplate<typename ...> static inline void putchar_unlocked(int c) { putchar(c); }\n#define mygc(c) (c)=getchar_unlocked()\n#define mypc(c) putchar_unlocked(c)\nvoid reader(int& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nvoid reader(ll& x) { int k, m = 0; x = 0; for (;;) { mygc(k); if (k == '-') { m = 1; break; }if ('0' <= k&&k <= '9') { x = k - '0'; break; } }for (;;) { mygc(k); if (k<'0' || k>'9')break; x = x * 10 + k - '0'; }if (m) x = -x; }\nint reader(char c[]) { int i, s = 0; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c[s++] = i; for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c[s++] = i; }c[s] = '\\0'; return s; }\nint reader(string& c) { int i; for (;;) { mygc(i); if (i != ' '&&i != '\\n'&&i != '\\r'&&i != '\\t'&&i != EOF) break; }c.push_back(i); for (;;) { mygc(i); if (i == ' ' || i == '\\n' || i == '\\r' || i == '\\t' || i == EOF) break; c.push_back(i); }; return sz(c); }\ntemplate <class T, class S> void reader(T& x, S& y) { reader(x); reader(y); }\ntemplate <class T, class S, class U> void reader(T& x, S& y, U& z) { reader(x); reader(y); reader(z); }\ntemplate <class T, class S, class U, class V> void reader(T& x, S& y, U& z, V & w) { reader(x); reader(y); reader(z); reader(w); }\nvoid writer(int x, char c) { int s = 0, m = 0; char f[10]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(ll x, char c) { int s = 0, m = 0; char f[20]; if (x<0)m = 1, x = -x; while (x)f[s++] = x % 10, x /= 10; if (!s)f[s++] = 0; if (m)mypc('-'); while (s--)mypc(f[s] + '0'); mypc(c); }\nvoid writer(const char c[]) { int i; for (i = 0; c[i] != '\\0'; i++)mypc(c[i]); }\nvoid writer(const string& x, char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\nvoid writer(const char x[], char c) { int i; for (i = 0; x[i] != '\\0'; i++)mypc(x[i]); mypc(c); }\ntemplate<class T> void writerLn(T x) { writer(x, '\\n'); }\ntemplate<class T, class S> void writerLn(T x, S y) { writer(x, ' '); writer(y, '\\n'); }\ntemplate<class T, class S, class U> void writerLn(T x, S y, U z) { writer(x, ' '); writer(y, ' '); writer(z, '\\n'); }\ntemplate<class T> void writerArr(T x[], int n) { if (!n) { mypc('\\n'); return; }FOR(i, n - 1)writer(x[i], ' '); writer(x[n - 1], '\\n'); }\ntemplate<class T> void writerArr(vector<T>& x) { writerArr(x.data(), (int)x.size()); }\n\ntemplate<class T> void chmin(T& a, const T& b) { if (a > b) a = b; }\ntemplate<class T> void chmax(T& a, const T& b) { if (a < b) a = b; }\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\ntemplate<class T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\nll mod_pow(ll a, ll n, ll mod) {\n\tll ret = 1;\n\tll p = a % mod;\n\twhile (n) {\n\t\tif (n & 1) ret = ret * p % mod;\n\t\tp = p * p % mod;\n\t\tn >>= 1;\n\t}\n\treturn ret;\n}\ntemplate<class T> T extgcd(T a, T b, T& x, T& y) { for (T u = y = 1, v = x = 0; a;) { T q = b / a; swap(x -= q * u, u); swap(y -= q * v, v); swap(b -= q * a, a); } return b; }\ntemplate<class T> T mod_inv(T a, T m) { T x, y; extgcd(a, m, x, y); return (m + x % m) % m; }\n\nint main() {\n\tint n, q; reader(n, q);\n\tvector<ll> a(2 * n), b(2 * n);\n\tFOR(i, 2 * n) reader(a[i]);\n\tFOR(i, 2 * n) reader(b[i]);\n\n\tll special = 0;\n\tll asum = 0;\n\tll missum = 0;\n\tmultiset<ll> mat, mis;\n\n\tauto add_val = [&](int i) {\n\t\tasum += a[i];\n\t\tll diff = a[i] - b[i];\n\t\tif (diff >= 0) mat.insert(diff);\n\t\telse mis.insert(diff), missum += diff;\n\t};\n\n\tFOR(i, 2 * n) {\n\t\tif (i == 0 || i == 2 * n - 1) {\n\t\t\tspecial += a[i];\n\t\t\tcontinue;\n\t\t}\n\t\tadd_val(i);\n\t}\n\n\tFOR(i, q) {\n\t\tint p, x, y; reader(p, x, y);\n\t\t--p;\n\n\t\tif (p == 0 || p == 2 * n - 1) {\n\t\t\tspecial -= a[p];\n\n\t\t\ta[p] = x;\n\t\t\tb[p] = y;\n\n\t\t\tspecial += a[p];\n\t\t} else {\n\t\t\tll pvdiff = a[p] - b[p];\n\t\t\tasum -= a[p];\n\t\t\tif (pvdiff >= 0) {\n\t\t\t\tmat.erase(mat.find(pvdiff));\n\t\t\t} else {\n\t\t\t\tmis.erase(mis.find(pvdiff));\n\t\t\t\tmissum -= pvdiff;\n\t\t\t}\n\n\t\t\ta[p] = x;\n\t\t\tb[p] = y;\n\n\t\t\tadd_val(p);\n\t\t}\n\n\t\tll ans = special + asum - missum;\n\t\tif (sz(mis) % 2 == 1) {\n\t\t\tauto ait = mat.begin();\n\t\t\tauto bit = prev(mis.end());\n\t\t\tif (*ait < -*bit) {\n\t\t\t\tans -= *ait;\n\t\t\t} else {\n\t\t\t\tans += *bit;\n\t\t\t}\n\t\t}\n\n\t\twriterLn(ans);\n\t}\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <class T, class F>\nstruct segment_tree{\n    int sz;\n    vector<T> seg;\n    const F f;\n    const T M;\n    segment_tree(int n, const F f, const T &M) : f(f), M(M) {\n        sz = 1;\n        while(sz < n) sz <<= 1;\n        seg.assign(2*sz, M);\n    }\n\n    void set(int k, const T &x){\n        seg[k + sz] = x;\n    }\n\n    void build(){\n        for (int i = sz-1; i > 0; --i) seg[i] = f(seg[2*i], seg[2*i+1]);\n    }\n\n    void update(int k, const T &x){ // 0-indexed\n        k += sz;\n        seg[k] = x;\n        while (k >>= 1){\n            seg[k] = f(seg[2*k], seg[2*k+1]);\n        }\n    }\n\n    T query(int a, int b){ // 0-indexed\n        T l = M, r = M;\n        for(a += sz, b += sz; a < b; a >>=1, b>>=1){\n            if(a & 1) l = f(l, seg[a++]);\n            if(b & 1) r = f(seg[--b], r);\n        }\n        return f(l, r);\n    }\n\n    T operator[](const int &k) const { // 0-indexed\n        return seg[k + sz];\n    }\n};\n\nstruct tup{\n    ll s, p, abs;\n    tup (ll s, ll p, ll n) : s(s), p(p), abs(n) {};\n};\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    n *= 2;\n    vector<int> a(n), b(n);\n    for (auto &&i : a) scanf(\"%d\", &i);\n    for (auto &&j : b) scanf(\"%d\", &j);\n    auto f = [](tup a, tup b){\n        return tup(a.s+b.s, a.p+b.p, min(a.abs, b.abs));\n    };\n    segment_tree<tup, decltype(f)> seg(n, f, tup(0, 0, INF<int>));\n    ll s = 0;\n    for (int i = 0; i < n; ++i) {\n        s += a[i];\n        int d = b[i]-a[i];\n        seg.set(i,\n                tup(max(0, d), d >= 0, abs(d))\n                );\n    }\n    seg.build();\n    for (int i = 0; i < q; ++i) {\n        int p, x, y;\n        scanf(\"%d %d %d\", &p, &x, &y);\n        p--;\n        s += x - a[p];\n        int d = y-x;\n        a[p] = x, b[p] = y;\n        seg.update(p,\n                tup(max(0, d), d >= 0, abs(d))\n        );\n        auto ret = seg.query(1, n-1);\n        ll ans = s + ret.s - ((ret.p)&1 ? ret.abs : 0);\n        printf(\"%lli\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 2e5 + 5;\n\nint N, Q;\nint a[MAXN], b[MAXN];\nint diff[MAXN];\nmultiset <int> pos, neg;\nll sum;\n\nvoid in(int x) {\n\tdiff[x] = b[x] - a[x];\n\tsum += a[x];\n\tif (x == 1 || x == N)\n\t\treturn;\n\tif (diff[x] < 0)\n\t\tneg.insert(diff[x]);\n\telse {\n\t\tpos.insert(diff[x]);\n\t\tsum += diff[x];\n\t}\n}\n\nvoid out(int x) {\n\tsum -= a[x];\n\tif (x == 1 || x == N)\n\t\treturn;\n\tif (diff[x] < 0)\n\t\tneg.erase(neg.find(diff[x]));\n\telse {\n\t\tpos.erase(pos.find(diff[x]));\n\t\tsum -= diff[x];\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tN *= 2;\n\tfor (int i = 1; i <= N; i++)\n\t\tscanf(\"%d\", a + i);\n\tfor (int i = 1; i <= N; i++)\n\t\tscanf(\"%d\", b + i);\n\n\tfor (int i = 1; i <= N; i++) \n\t\tin(i);\n\t\n\twhile (Q--) {\n\t\tint p, x, y;\n\t\tscanf(\"%d%d%d\", &p, &x, &y);\n\t\tout(p);\n\t\ta[p] = x;\n\t\tb[p] = y;\n\t\tin(p);\n\t\tprintf(\"%lld\\n\", sum + (pos.size() % 2 ? max(-*pos.begin(), *neg.rbegin()) : 0));   \n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll, int> P;\n\nint main()\n{\n\tint n, q;\n  cin>>n>>q;\n  ll a[200001], b[200001];\n  for(int i=1; i<=2*n; i++){\n    cin>>a[i];\n  }\n  for(int i=1; i<=2*n; i++){\n    cin>>b[i];\n  }\n  multiset<ll> st;\n  ll ans=a[1]+a[2*n];\n  for(int i=2; i<2*n; i++){\n    if(b[i]>=a[i]) st.insert(b[i]-a[i]);\n    ans+=max(a[i], b[i]);\n  }\n  for(int i=0; i<q; i++){\n    int p; ll x, y;\n    cin>>p>>x>>y;\n    if(p==1 || p==2*n){\n      ans=ans-a[p]+x;\n      a[p]=x; b[p]=y;\n    }else{\n      if(b[p]>=a[p]) st.erase(st.lower_bound(b[p]-a[p]));\n      ans=ans-max(a[p], b[p])+max(x, y);\n      a[p]=x; b[p]=y;\n      if(y>=x) st.insert(y-x);\n    }\n    if((st.size())%2==0){\n      cout<<ans<<endl;\n    }else{\n      cout<<ans-*(st.begin())<<endl;\n    }\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e16)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstruct SegmentTree {\nprivate:\n    int n;\n    vector<ll> node_plus;\n    vector<ll> node_minus;\n \npublic:\n    SegmentTree() {\n        int sz = 200005;\n        n = 1; while(n < sz) n *= 2;\n        node_plus.resize(2*n-1, INF);\n        node_minus.resize(2*n-1, -INF);\n        for(int i = 0; i < node_plus.size(); i++){\n            node_plus[i] = INF;\n            node_minus[i] = -INF;\n        }\n    }\n \n    void update(int x, ll val) {\n        x += (n - 1);\n        if(val > 0){\n            node_minus[x] = -INF;\n            node_plus[x] = val;\n        } else {\n            node_minus[x] = val;\n            node_plus[x] = INF;\n        }\n        if(val == 0){\n            node_minus[x] = 0;\n            node_plus[x] = 0;\n        }\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node_minus[x] = max(node_minus[2*x+1], node_minus[2*x+2]);\n            node_plus[x] = min(node_plus[2*x+1], node_plus[2*x+2]);\n            //node[x] = min(node[2*x+1], node[2*x+2]);\n        }\n    }\n    // hannkaikukann \n    ll getminus(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return -INF;\n        if(a <= l && r <= b) return node_minus[k];\n \n        ll vl = getminus(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getminus(a, b, 2*k+2, (l+r)/2, r);\n        return max(vl, vr);\n    }\n    ll getplus(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return INF;\n        if(a <= l && r <= b) return node_plus[k];\n \n        ll vl = getplus(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getplus(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n};\n\n\nint main() {\n    //cout.precision(10);\n    SegmentTree seg;\n    int n, q;\n    cin >> n >> q;\n    ll a[200500];\n    ll b[200500];\n    ll asum = 0;\n    for(int i = 1; i <= 2 * n; i++){\n        cin >> a[i];\n        asum += a[i];\n    }\n    for(int i = 1; i <= 2 * n; i++){\n        cin >> b[i];\n    }\n    ll ans = asum;\n    ll checker = 0;\n    for(int i = 2; i < 2 * n; i++){\n        ll delta = b[i] - a[i];\n        if(delta > 0){\n            ans += delta;\n            checker++;\n        }\n        seg.update(i, delta);\n    }\n    for(int time = 0; time < q; time++){\n        int p;\n        ll x, y;\n        cin >> p >> x >> y;\n        ans = ans - a[p] + x;\n        ll before = b[p] - a[p];\n        ll after = y - x;\n        a[p] = x;\n        b[p] = y;\n        if((p == 1) || (p == (2 * n))){\n            cout << ans << endl;\n            continue;\n        }\n        ans = ans - max((ll)0, before) + max((ll)0, after);\n        if((before > 0) && (after <= 0)){\n            checker--;\n        }\n        if((before <= 0) && (after > 0)){\n            checker++;\n        }\n        seg.update(p, after);\n        if((checker % 2) == 0){\n            cout << ans << endl;\n            continue;\n        }\n        cout << ans - min(-seg.getminus(2, 2 * n), seg.getplus(2, 2 * n)) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<class ValueMonoid, template<class...> class Container=::std::vector>\nclass SegTree{\npublic:\n    using value_structure = ValueMonoid;\n    using value_type = typename value_structure::value_type;\n    using const_reference = const value_type &;\n    using container_type = Container<value_type>;\n    using size_type = typename container_type::size_type;\n\nprivate:\n    ::std::vector<value_type> tree;\n    size_type size_;\n\n    static size_type getsize(const size_type x){\n        size_type ret = 1;\n        while(ret < x)\n            ret <<= 1;\n        return ret;\n    }\n\n    inline value_type calc(const value_type a, const value_type b){\n        return value_structure::operation(a, b);\n    }\n\n    inline void calc_node(const size_type index){\n        if(tree.size() <= (index << 1 | 1)) return;\n        tree[index] = value_structure::operation(tree[index<<1], tree[index<<1 | 1]);\n    }\npublic:\n    SegTree() : size_(0), tree(){}\n    SegTree(const size_type size)\n            : size_(size), tree(size << 1, value_structure::identity()){}\n    template<class InputIterator>\n    SegTree(InputIterator first, InputIterator last)\n            : size_(::std::distance(first, last)){\n        tree = container_type(size_, value_structure::identity());\n        tree.insert(tree.end(), first, last);\n        for(size_type i = size_;i > 0;i--){\n            calc_node(i);\n        }\n    }\n\n    size_type size() const { return size_; }\n    const_reference operator[](const size_type k) const {\n        assert(k < size_);\n        return tree[k+size_];\n    }\n\n    value_type query(size_type l, size_type r){\n        assert(l <= r);\n        assert(0 <= l && l < size_);\n        assert(0 <= r && r <= size_);\n        value_type retl = value_structure::identity(), retr = value_structure::identity();\n        for(l += size_, r += size_; l < r ; l >>= 1, r >>= 1){\n            if(l&1) retl = calc(retl, tree[l++]);\n            if(r&1) retr = calc(tree[--r], retr);\n        }\n        return calc(retl, retr);\n    }\n\n    template<class F>\n    void update(size_type index, const F& f){\n        assert(0 <= index && index < size());\n        index += size_;\n        tree[index] = f(::std::move(tree[index]));\n        while(index >>= 1)\n            calc_node(index);\n    }\n\n    /*\n    template<class F>\n    size_type search(const F& f) const { // [0, result) is True and [0, result-1) is not.\n        if(f(value_structure::identity()))\n            return 0;\n        if(!f(tree[1]))\n            return size_+1;\n        value_type acc = value_structure::identity();\n        size_type i = 1;\n        while(i <\n    }\n    */\n};\n\nclass v_monoid {\npublic:\n    using value_type = PLL;\n    static value_type identity() { return PLL(-INF_LL, -INF_LL); }\n    static value_type initializer() { return {-INF_LL, -INF_LL}; }\n    static value_type operation(const value_type& a, const value_type& b) {\n        if (a == identity()) return b;\n        if (b == identity()) return a;\n        return {max(a.fs+b.fs, a.sc+b.sc), max(a.fs+b.sc, a.sc+b.fs)};\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree{\n    using F = function<T(T,T)>;\n    int n;\n    F f;\n    T ti;\n    vector<T> dat;\n    SegmentTree(){};\n    SegmentTree(F f,T ti):f(f),ti(ti){}\n    void init(int n_){\n        n=1;\n        while(n<n_) n<<=1;\n        dat.assign(n<<1,ti);\n    }\n    void build(const vector<T> &v){\n        int n_=v.size();\n        init(n_);\n        for(int i=0;i<n_;i++) dat[n+i]=v[i];\n        for(int i=n-1;i;i--)\n            dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n    }\n    void set_val(int k,T x){\n        dat[k+=n]=x;\n        while(k>>=1)\n            dat[k]=f(dat[(k<<1)|0],dat[(k<<1)|1]);\n    }\n    T query(int a,int b){\n        T vl=ti,vr=ti;\n        for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n            if(l&1) vl=f(vl,dat[l++]);\n            if(r&1) vr=f(dat[--r],vr);\n        }\n        return f(vl,vr);\n    }\n    template<typename C>\n    int find(int st,C &check,T &acc,int k,int l,int r){\n        if(l+1==r){\n            acc=f(acc,dat[k]);\n            return check(acc)?k-n:-1;\n        }\n        int m=(l+r)>>1;\n        if(m<=st) return find(st,check,acc,(k<<1)|1,m,r);\n        if(st<=l&&!check(f(acc,dat[k]))){\n            acc=f(acc,dat[k]);\n            return -1;\n        }\n        int vl=find(st,check,acc,(k<<1)|0,l,m);\n        if(~vl) return vl;\n        return find(st,check,acc,(k<<1)|1,m,r);\n    }\n    template<typename C>\n    int find(int st,C &check){\n        T acc=ti;\n        return find(st,check,acc,1,0,n);\n    }\n};\n\n\nint main(void) {\n    int64 N, Q;\n    cin >> N >> Q;\n    N *= 2;\n    vector<int64> a(N), b(N);\n    REP(i, N) cin >> a[i];\n    REP(i, N) cin >> b[i];\n    int64 res = a[0] + a.back();\n    SegTree<v_monoid> sg(N);\n    FOR(i, 1, N-1) {\n        sg.update(i, [&](const PLL x) { return PLL(a[i], b[i]); });\n    }\n    REP(i, Q) {\n        int64 p, x, y;\n        cin >> p >> x >> y; p--;\n        if (p == 0 || p == N-1) {\n            res -= a[p]; res += x;\n            a[p] = x;\n        } else {\n            sg.update(p, [&](const PLL alskdj) { return PLL(x, y); });\n        }\n        cout << res + (N > 2 ? sg.query(1, N).fs : 0)<< endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,Q;\nint A[101010];\nint B[101010];\nmultiset<int> p,n;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>Q;\n\tll S=0,T=0;\n\tFOR(i,2*N) cin>>A[i], S+=A[i];\n\tFOR(i,2*N) {\n\t\tcin>>B[i];\n\t\tB[i]-=A[i];\n\t\tif(i!=0 && i!=2*N-1) {\n\t\t\tif(B[i]>0) {\n\t\t\t\tp.insert(B[i]);\n\t\t\t\tT+=B[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tn.insert(-B[i]);\n\t\t\t}\n\t\t}\n\t}\n\twhile(Q--) {\n\t\tcin>>i>>x>>y;\n\t\ti--;\n\t\tS-=A[i];\n\t\tif(B[i]>0) {\n\t\t\tp.erase(p.find(B[i]));\n\t\t\tT-=B[i];\n\t\t}\n\t\telse {\n\t\t\tn.erase(n.find(-B[i]));\n\t\t}\n\t\t\n\t\tA[i]=x;\n\t\tS+=x;\n\t\tB[i]=y-A[i];\n\t\tif(i!=0 && i!=2*N-1) {\n\t\t\tif(B[i]>0) {\n\t\t\t\tp.insert(B[i]);\n\t\t\t\tT+=B[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tn.insert(-B[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tll ma=0;\n\t\tif(p.size()%2==0) ma=S+T;\n\t\telse ma=S+max(T-*p.begin(),T-*n.begin());\n\t\tcout<<ma<<endl;\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n    Problem: Given two sequences a and b, find two balance sequences of brackets (s, t) of the same length\n        such that their cost is maximized.\n    The cost is calculated as followed: with position i, cost += a[i] if s[i] == t[i]; cost += b[i] otherwise.\n*/\n\n#include <cstdio>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\n#define long long long\n\nconst int N = 2e5 + 2;\n\nint n, q, a[N], b[N];\nset<pair<int, int> > s[2];\nlong cost = 0, sum[2] = {0, 0};\n\nvoid Solve()\n{\n    while (q--)\n    {\n        int p, x, y; long cur = 0;\n        scanf(\"%d %d %d\", &p, &x, &y); --p;\n        if (p == 0 || p == n - 1) cost += x - a[p], a[p] = x;\n        else\n        {\n            cost += x - a[p];\n            int old_sign = b[p] - a[p] >= 0;\n            int new_sign = y - x >= 0;\n            sum[old_sign] -= b[p] - a[p];\n            sum[new_sign] += y - x;\n            s[old_sign].erase({b[p] - a[p], p});\n            s[new_sign].insert({y - x, p});\n            a[p] = x, b[p] = y;\n            if (s[1].size() & 1)\n                cur = cost + max(sum[1] + (--s[0].begin())->first, sum[1] - s[1].begin()->first);\n            else cur = cost + sum[1];\n        }\n        printf(\"%lld\\n\", cur);\n    }\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &q);\n    n *= 2;\n    for (int i = 0; i < n; ++i) scanf(\"%d\", &a[i]), cost += a[i];\n    for (int i = 0; i < n; ++i)\n    {\n        scanf(\"%d\", &b[i]);\n        if (i != 0 && i != n - 1)\n        {\n            int x = b[i] - a[i];\n            int sign = x >= 0;\n            sum[sign] += x;\n            s[sign].insert({x, i});\n        }\n    }\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nmap<int,int>mp1,mp2;\nint n,T,a[202000],b[202000];\nll sum=0,bas=0;\n\nvoid add(int x){\n\tif (x>=0) ++mp1[x], sum+=x;\n\telse ++mp2[-x];\n}\nvoid del(int x){\n\tif (x>=0){\n\t\tsum-=x;\n\t\tif (!(--mp1[x])) mp1.erase(x);\n\t}else{\n\t\tif (!(--mp2[-x])) mp2.erase(-x);\n\t}\n}\n\nll doit(){\n\tif (!(mp1.size()&1)) return sum;\n\treturn sum+max(-mp1.begin()->first,-mp2.begin()->first);\n}\n\nint main(){\n\tcin>>n>>T; n<<=1;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&b[i]);\n\tfor (int i=2;i<n;i++) add(a[i]-b[i]), bas+=b[i];\n\tfor (int p,x,y;T--;){\n\t\tscanf(\"%d%d%d\",&p,&x,&y);\n\t\tif (p!=1&&p!=n){\n\t\t\tdel(a[p]-b[p]); bas-=b[p];\n\t\t\tadd((a[p]=x)-(b[p]=y));\tbas+=b[p];\n\t\t}\n\t\tprintf(\"%lld\\n\",bas+a[1]+a[n]+doit());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef long long int LL;\nconst LL INF=(LL)1<<32;\ntypedef pair<LL,int> P;\npriority_queue<P,vector<P>,greater<P> > q1,q2;\nLL t[100005][2];\nLL s[100005];\nint main(){\n\tint n,m;\n\tint i,j,k;\n\tLL a,b,c;\n\tint equ=0,big=0;\n\tLL st;\n\tcin>>n>>m;\n\tfor(i=0;i<2;i++){\n\t\tfor(j=0;j<2*n;j++){\n\t\t\tcin>>t[j][i];\n\t\t}\n\t}\n\tst=t[0][0]+t[2*n-1][0];\n\tfor(i=1;i<2*n-1;i++){\n\t\tif(t[i][0]==t[i][1])equ++,st+=t[i][0];\n\t\telse if(t[i][0]>t[i][1])big++,st+=t[i][0],q1.push(make_pair(t[i][0]-t[i][1],i));\n\t\telse st+=t[i][1],q2.push(make_pair(t[i][1]-t[i][0],i));\n\t}\n\tfor(i=0;i<m;i++){\n\t\tcin>>a>>b>>c;\n\t\ta--;\n\t\tif(a==0 || a==2*n-1){\n\t\t\tst+=b-t[a][0];\n\t\t\tt[a][0]=b,t[a][1]=c;\n\t\t\ts[i]=st;\n\t\t\tcontinue;\n\t\t}\n\t\tif(t[a][0]==t[a][1])equ--,st-=t[a][0];\n\t\telse if(t[a][0]>t[a][1])big--,st-=t[a][0];\n\t\telse st-=t[a][1];\n\t\tt[a][0]=b,t[a][1]=c;\n\t\tif(t[a][0]==t[a][1])equ++,st+=t[a][0];\n\t\telse if(t[a][0]>t[a][1])big++,st+=t[a][0],q1.push(make_pair(t[a][0]-t[a][1],a));\n\t\telse st+=t[a][1],q2.push(make_pair(t[a][1]-t[a][0],a));\n\t\t\n\t\tif(equ>0 || big%2==0){\n\t\t\ts[i]=st;\n\t\t\tcontinue;\n\t\t}\n\t\ta=INF,b=INF;\n\t\twhile(!q1.empty()){\n\t\t\tc=q1.top().second;\n\t\t\tif(t[c][0]-t[c][1]==q1.top().first){\n\t\t\t\ta=t[c][0]-t[c][1];\n\t\t\t\tbreak;\n\t\t\t}else q1.pop();\n\t\t}\n\t\twhile(!q2.empty()){\n\t\t\tc=q2.top().second;\n\t\t\tif(t[c][1]-t[c][0]==q2.top().first){\n\t\t\t\tb=t[c][1]-t[c][0];\n\t\t\t\tbreak;\n\t\t\t}else q2.pop();\n\t\t}\n\t\tif(a>b)a=b;\n\t\ts[i]=st-a;\n\t}\n\tfor(i=0;i<m;i++){\n\t\tcout<<s[i]<<endl;\n\t}\n\treturn 0;\n}\n\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nlong long bit[400010],a[200010],b[200010],p[100010],x[100010],y[100010],n,q,inv[300010],m;\nvector<long long> v;\nmap<int,int> mp;\nint sum(int i){\n\tint s = 0;\n\twhile(i>0){\n\t\ts += bit[i];\n\t\ti -= i&-i;\n\t}\n\treturn s;\n}\n\nvoid add(int i, int x){\n\twhile(i<=m){\n\t\tbit[i] += x;\n\t\ti += i&-i;\n\t}\n}\nint main(){\n\tint z,ans = 0;\n\tcin >> n >> q;\n\tint i;\n\tfor(i=0;i<2*n;i++){\n\t\tcin >> a[i];\n\t}\n\tfor(i=0;i<2*n;i++){\n\t\tcin >> b[i];\n\t}\n\tfor(i=1;i<2*n-1;i++){\n\t\tv.push_back(a[i]-b[i]);\n\t}\n\tfor(i=0;i<q;i++){\n\t\tcin >> p[i] ;\n\t\tp[i]--;\n\t\tif(p[i]!=0 && p[i]!=2*n-1){\n\t\t\tcin>> x[i] >> y[i];\n\t\t\tv.push_back(x[i]-y[i]);\n\t\t}\n\t}\n\tm = v.size()+1;\n\tv.push_back(0);\n\tsort(v.begin(),v.end());\n\tint now = 1;\n\tmp[v[0]] = 1;\n\tinv[1] = v[0];\n\tif(v[0]==0){\n\t\tz = 1;\n\t}\n\tfor(i=1;i<v.size();i++){\n\t\tif(v[i]>v[i-1]){\n\t\t\tnow++;\n\t\t}\n\t\tmp[v[i]] = now;\n\t\tinv[now] = v[i];\n\t\tif(v[i]==0){\n\t\t\tz = now;\n\t\t}\n\t}\n\tnow++;\n\tint cnt = 0;\n\tfor(i=1;i<2*n-1;i++){\n\t\tadd(mp[a[i]-b[i]],1);\n\t\tif(a[i]>=b[i]){\n\t\t\tans += a[i];\n\t\t\tcnt += 1;\n\t\t}else{\n\t\t\tans += b[i];\n\t\t}\n\t}\n\tfor(i=1;i<now;i++){\n\t\t//cout << i << \" \" << sum(i) << endl;\n\t}\n\tfor(i=0;i<now;i++){\n\t\t//cout << i << \" \" << inv[i] << endl;\n\t}\n\tfor(i=0;i<now;i++){\n\t\t//cout << i << \" \" << sum(i) << endl;\n\t}\n\tans += a[0]+a[2*n-1];\n\tfor(i=0;i<q;i++){\n\t\tans -= max(a[p[i]],b[p[i]]);\n\t\tans += max(x[i],y[i]);\n\t\t//cout << a[p[i]] << \" \" << b[p[i]] << \" \" << x[i] << \" \" << y[i] << \" \" << ans <<\" \" << cnt<< endl;\n\t\tfor(int j=0;j<now;j++){\n\t\t\t//cout << j << \" \" << sum(j) << endl;\n\t\t}\n\t\tif(p[i]==0 || p[i]==2*n-1){\n\t\t\ta[p[i]] = x[i];\n\t\t\tb[p[i]] = y[i];\n\t\t\tcout << ans << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tadd(mp[a[p[i]] - b[p[i]]],-1);\n\t\tadd(mp[x[i] - y[i]],1);\n\t\tif(a[p[i]]-b[p[i]]>=0 ^ x[i]-y[i]>=0){\n\t\t\tcnt++;\n\t\t}\n\t\ta[p[i]] = x[i];\n\t\tb[p[i]] = y[i];\n\t\tif(cnt%2==0){\n\t\t\tcout << ans << endl;\n\t\t}else{\n\t\t\tlong long l=0,r=now,mid;\n\t\t\tint s = sum(z);\n\t\t\t//cout << l << \" \" << r << \" \" << z << endl;\n\t\t\t//cout << s << endl;\n\t\t\twhile(r - l>1){\n\t\t\t\t//cout << l << \" \" << r << \" \" << endl;\n\t\t\t\tmid = (l+r)/2;\n\t\t\t\tif(sum(mid)>=s+1){\n\t\t\t\t\tr = mid;\n\t\t\t\t}else{\n\t\t\t\t\tl = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << r << endl;\n\t\t\tlong long m1 = inv[r];\n\t\t\tl=0,r=now;\n\t\t\twhile(r - l>1){\n\t\t\t\t//cout << l << \" \" << r << endl;\n\t\t\t\tmid = (l+r)/2;\n\t\t\t\tif(sum(mid)<s){\n\t\t\t\t\tl = mid;\n\t\t\t\t}else{\n\t\t\t\t\tr = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << r << endl;\n\t\t\tlong long m2 = inv[r];\n\t\t\t//cout << m1 << \" \" << m2 << \" \" << endl;\n\t\t\tcout << max(ans - m1,ans + m2) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr long double EPS = 1e-8;\n\nlong long int N, M, K, L, R, H, W;\n//int N, M, K, L, R, H, W;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tN <<= 1;\n\tvector<long long int>v(N);\n\tvector<long long int>w(N);\n\tfor (auto &i : v)cin >> i;\n\tfor (auto &i : w)cin >> i;\n\tlong long int ans = v.front() + v.back();\n\tset<pair<long long int, int>>in;\n\tset<pair<long long int, int>>out;\n\tlong long int insum = 0;\n\tvector<long long int>num(N);\n\tfor (int i = 1; i < N - 1; i++) {\n\t\tans += v[i];\n\t\tnum[i] = w[i] - v[i];\n\t\tif (v[i] < w[i]) {\n\t\t\tin.insert({ num[i],i });\n\t\t\tans += num[i];\n\t\t}\n\t\telse {\n\t\t\tout.insert({ -num[i],i });\n\t\t}\n\t}\n\twhile (in.size() && in.begin()->first < 0) {\n\t\tint n = in.begin()->second;\n\t\tans -= num[n];\n\t\tout.insert({ -in.begin()->first, in.begin()->second });\n\t\tin.erase(in.begin());\n\t}\n\twhile (out.size() && out.begin()->first < 0) {\n\t\tint n = out.begin()->second;\n\t\tans += num[n];\n\t\tin.insert({ -out.begin()->first, out.begin()->second });\n\t\tout.erase(out.begin());\n\t}\n\tif (in.size() & 1) {\n\t\tif (in.begin()->first > out.begin()->first) {\n\t\t\tin.insert({ -out.begin()->first,out.begin()->second });\n\t\t\tans += num[out.begin()->second];\n\t\t\tout.erase(out.begin());\n\t\t}\n\t\telse {\n\t\t\tout.insert({ -in.begin()->first,in.begin()->second });\n\t\t\tans -= num[in.begin()->second];\n\t\t\tin.erase(in.begin());\n\t\t}\n\t}\n\twhile (M--) {\n\t\tcin >> K >> L >> R;\n\t\tK--;\n\t\tans -= v[K];\n\t\tv[K] = L, w[K] = R;\n\t\tif (K == 0 || K == N - 1) {\n\t\t\tans += v[K];\n\t\t\tcout << ans << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tif (in.find({ num[K],K }) != in.end()) {\n\t\t\tans -= num[K];\n\t\t\tin.erase({ num[K],K });\n\t\t}\n\t\telse {\n\t\t\tout.erase({ -num[K],K });\n\t\t}\n\t\tnum[K] = w[K] - v[K];\n\t\tans += L;\n\t\tif (num[K] > 0) {\n\t\t\tin.insert({ num[K],K });\n\t\t\tans += num[K];\n\t\t}\n\t\telse {\n\t\t\tout.insert({ -num[K],K });\n\t\t}\n\t\twhile (in.size() && in.begin()->first < 0) {\n\t\t\tint n = in.begin()->second;\n\t\t\tans -= num[n];\n\t\t\tout.insert({ -in.begin()->first, in.begin()->second });\n\t\t\tin.erase(in.begin());\n\t\t}\n\t\twhile (out.size() && out.begin()->first < 0) {\n\t\t\tint n = out.begin()->second;\n\t\t\tans += num[n];\n\t\t\tin.insert({ -out.begin()->first, out.begin()->second });\n\t\t\tout.erase(out.begin());\n\t\t}\n\t\tif (in.size() & 1) {\n\t\t\tif (in.begin()->first > out.begin()->first) {\n\t\t\t\tin.insert({ -out.begin()->first,out.begin()->second });\n\t\t\t\tans += num[out.begin()->second];\n\t\t\t\tout.erase(out.begin());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout.insert({ -in.begin()->first,in.begin()->second });\n\t\t\t\tans -= num[in.begin()->second];\n\t\t\t\tin.erase(in.begin());\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n\n#define INF_LL (ll)1e18\n#define INF (int)1e9\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\nusing ll = long long;\nusing PII = pair<int, int>;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nusing PLL = pair<ll, ll>;\n#define fs first\n#define sc second\n\nclass RMQ{\nprivate:\n\tint n;\n\tvector<PLL> node, lazy;\n\tvector<bool> lazyFlag;\npublic:\n\tRMQ(vector<ll> v){\n\t\tint sz = v.size();\n\t\tn = 1; while(n < sz) n *= 2;\n\t\tnode.resize(2*n-1, {-INF_LL, -1} );\n\t\tlazy.resize(2*n-1, {0, -1} );\n\t\tlazyFlag.resize(2*n-1, false);\n\t\tREP(i, sz) node[i+n-1] = {v[i], i};\n\t\tfor(int i = n-2;i >= 0;i--) node[i] = max(node[2*i+1], node[2*i+2]);\n\t}\n\n\tvoid eval(int k, int l, int r){\n\t\tif(lazyFlag[k]){\n\t\t\tnode[k] = {lazy[k].fs, l};\n\t\t\tif(r-l > 1){\n\t\t\t\tlazy[2*k+1] = lazy[k];\n\t\t\t\tlazy[2*k+2] = lazy[k];\n\t\t\t\tlazyFlag[2*k+1] = lazyFlag[2*k+2] = true;\n\t\t\t}\n\t\t\tlazy[k] = {0, -1};\n\t\t\tlazyFlag[k] = false;\n\t\t}\n\t}\n\n\tvoid update(int a, int b, PLL x, int k=0, int l=0, int r=-1){\n\t\tif(r < 0) r = n;\n\t\teval(k, l, r);\n\t\tif(b <= l || r <= a) return;\n\n\t\tif(a <= l && r <= b){\n\t\t\tlazy[k] = x;\n\t\t\tlazyFlag[k] = true;\n\t\t\teval(k, l, r);\n\t\t}else{\n\t\t\tupdate(a, b, x, k*2+1, l, (l+r)/2);\n\t\t\tupdate(a, b, x, k*2+2, (l+r)/2, r);\n\t\t\tnode[k] = max(node[k*2+1], node[k*2+2]);\n\t\t}\n\t}\n\n\tPLL query(int a, int b, int k=0, int l=0, int r=-1){\n\t\tif(r < 0) r = n;\n\t\teval(k, l, r);\n\n\t\tif(b <= l || r <= a) return {-INF_LL, -1};\n\t\tif(a <= l && r <= b) return node[k];\n\n\t\treturn max(query(a, b, k*2+1, l, (l+r)/2), query(a, b, k*2+2, (l+r)/2, r));\n\t}\n};\n\n\nll a[214514], b[214514];\nll res = 0;\npriority_queue<PII, vector<PII> > pq;\n\nint main(void){\n\tint N, Q;\n\tbool used[214514] = {};\ncin >> N >> Q;\n\tRMQ rmq(vector<ll>(2*N));\n\tREP(i, 2*N)\n\t\tcin >> a[i];\n\tREP(i, 2*N)\n\t\tcin >> b[i];\n\tFOR(i, 1, 2*N-1){\n\t\tpq.push({b[i]-a[i], i});\n\t}\n\twhile(pq.size() && pq.top().fs > 0){\n\t\tint v = pq.top().fs, in = pq.top().sc;\n\t\tpq.pop();\n\t\tif(v+pq.top().fs > 0){\n\t\t\tused[in] = 1;\n\t\t\tused[pq.top().sc] = 1;\n\t\t\tpq.pop();\n\t\t}\n\t}\n\tres += a[0] + a[2*N-1];\n\tFOR(i, 1, 2*N-1){\n\t\tif(used[i]){\n\t\t\tres += b[i];\n\t\t\trmq.update(i, i+1, {a[i]-b[i], i});\n\t\t}else{\n\t\t\tres += a[i];\n\t\t\trmq.update(i, i+1, {b[i]-a[i], i});\n\t\t}\n\t}\n\tREP(i, Q){\n\t\tll p, x, y;\n\t\tcin >> p >> x >> y; p--;\n\t\tif(p == 0 || p == 2*N-1){\n\t\t\tres = res-a[i]+x;\n\t\t\ta[i] = x; b[i] = y;\n\t\t\tcontinue;\n\t\t}\n\t\tres += used[p] ? -b[p] : -a[p];\n\t\tused[p] = 1-used[p];\n\t\ta[p] = x; b[p] = y;\n\t\tif(used[p]){\n\t\t\trmq.update(p, p+1, {x-y, p});\n\t\t\tres += y;\n\t\t}else{\n\t\t\trmq.update(p, p+1, {y-x, p});\n\t\t\tres += x;\n\t\t}\n\t\tPLL pl = rmq.query(1, 2*N-1);\n\t\tres += pl.fs;\n\t\trmq.update(pl.sc, pl.sc+1, {-pl.fs, pl.sc});\n\t\tcout << res << endl;\n\t\tused[pl.sc] = 1-used[pl.sc];\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#define ll long long\nusing namespace std;\n\nconst int N=100005;\n\nstruct ST{\n\tint l,r;\n\tll a,b;\n}t[N<<2];\nint n,T,p,x,y;\nint a[N],b[N];\n\nvoid update(int k){\n\tt[k].a=max(t[k<<1].a+t[k<<1|1].a,t[k<<1].b+t[k<<1|1].b);\n\tt[k].b=max(t[k<<1].a+t[k<<1|1].b,t[k<<1].b+t[k<<1|1].a);\n}\n\nvoid build(int k,int l,int r){\n\tt[k].l=l; t[k].r=r;\n\tif (l==r){\n\t\tt[k].a=1ll*a[l];\n\t\tt[k].b=1ll*b[l];\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(k<<1,l,mid);\n\tbuild(k<<1|1,mid+1,r);\n\tupdate(k);\n}\n\nvoid modify(int k,int p){\n\tif (t[k].l==t[k].r){\n\t\tt[k].a=1ll*a[p];\n\t\tt[k].b=1ll*b[p];\n\t\treturn;\n\t}\n\tint mid=(t[k].l+t[k].r)>>1;\n\tif (p<=mid) modify(k<<1,p);\n\telse modify(k<<1|1,p);\n\tupdate(k);\n}\n\nint main(){\n\tint i;\n\tscanf(\"%d%d\",&n,&T);\n\tn<<=1;\n\tfor (i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor (i=1;i<=n;i++) scanf(\"%d\",&b[i]);\n\tif (n==2){\n\t\twhile (T--){\n\t\t\tscanf(\"%d%d%d\",&p,&x,&y);\n\t\t\ta[p]=x; b[p]=y;\n\t\t\tprintf(\"%d\\n\",a[1]+a[2]);\n\t\t}\n\t\treturn 0;\n\t}\n\tbuild(1,2,n-1);\n\twhile (T--){\n\t\tscanf(\"%d%d%d\",&p,&x,&y);\n\t\ta[p]=x; b[p]=y;\n\t\tmodify(1,p);\n\t\tprintf(\"%lld\\n\",t[1].a+1ll*(a[1]+a[n]));\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\n#define REP(i,n) for(long long i = 0; i < (n); i++)\n#define FOR(i, m, n) for(long long i = (m);i < (n); ++i)\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQR = priority_queue<T,vector<T>,greater<T>>;\n\nconstexpr long long MOD = (long long)1e9 + 7;\nconstexpr long long MOD2 = 998244353;\nconstexpr long long HIGHINF = (long long)1e18;\nconstexpr long long LOWINF = (long long)1e15;\nconstexpr long double PI = 3.1415926535897932384626433;\n\ntemplate <class T> vector<T> make_v(size_t N,T init){return vector<T>(N,init);}\ntemplate <class... T> auto make_v(size_t N,T... t){return vector<decltype(make_v(t...))>(N,make_v(t...));}\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const multiset<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\ntemplate <template <class tmp>  class T, class U> ostream &operator<<(ostream &o, const T<U> &obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr)o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min(a,b);}\nvoid YN(bool flg) {cout << (flg ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << (flg ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << (flg ? \"yes\" : \"no\") << endl;}\n\nint main() {\n\tSPEED\n\tint N,Q; cin >> N >> Q;\n\tvector<ll> a(2*N),b(2*N);\n\tfor(int i = 0; i < 2*N; ++i) cin >> a[i];\n\tfor(int i = 0; i < 2*N; ++i) cin >> b[i];\n\tll sum = accumulate(ALL(a),0LL), diff = 0;;\n\tmultiset<ll> l,r;\n\tfor(int i = 1; i < 2*N - 1; ++i) {\n\t\tll c = b[i]-a[i];\n\t\tif(c>=0) {\n\t\t\tdiff += c;\n\t\t\tr.insert(c);\n\t\t}\n\t\telse {\n\t\t\tl.insert(c);\n\t\t}\n\t}\n\tfor(int i = 0; i < Q; ++i) {\n\t\tll p,x,y; cin >> p >> x >> y;\n\t\tp--;\n\t\tif(0 < p && p < 2*N-1) {\n\t\t\tll c = b[p] - a[p],d = y - x;\n\t\t\tif(c>=0) {\n\t\t\t\tdiff -= c;\n\t\t\t\tr.erase(r.find(c));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl.erase(l.find(c));\n\t\t\t}\t\t\n\t\t\tif(d>=0) {\n\t\t\t\tdiff += d;\n\t\t\t\tr.insert(d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl.insert(d);\n\t\t\t}\n\t\t}\n\t\tsum -= a[p];\n\t\ta[p] = x;\n\t\tsum += a[p];\n\t\tb[p] = y;\n\t\tll e = 0;\n\t\tif(r.size()%2) {\n\t\t\tif(*l.rbegin() + *r.begin() >= 0) e = *l.begin();\n\t\t\telse e = -*r.begin();\n\t\t}\n//\t\tprint(i,l,r);\n\t\tcout << sum + diff + e << endl;\n\t} \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n                                                #include<iostream>\n                                                #include<cstdio>\n                                                #include<vector>\n                                                #include<queue>\n                                                #include<map>\n                                                #include<cstring>\n                                                #include<string>\n                                                #include <math.h>\n                                                #include<algorithm>\n                                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                                #include<functional>\n                                       #define int long long\n                                                #define inf  1000000007\n                                                #define pa pair<int,int>\n                                                #define ll long long\n                                                #define pal pair<double,double>\n                                                #define ppap pair<pa,int>\n                                          #define PI 3.14159265358979323846\n                                                #define paa pair<int,char>\n                                                #define  mp make_pair\n                                                #define  pb push_back\n                                                #define EPS (1e-10)\n                                                #define equals(a,b) (fabs((a)-(b))<EPS)\n        int dx[4]={0,-1,0,1};\n        int dy[4]={1,0,-1,0};\n                                                using namespace std;\n                                       \t\t\tclass pa3{\n                                                \tpublic:\n                                                \tint x,y,z;\n                                                \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                                \tbool operator < (const pa3 &p) const{\n                                                \t\tif(x!=p.x) return x<p.x;\n                                                \t\tif(y!=p.y) return y<p.y;\n                                                \t\t return z<p.z;\n                                                \t\t//return x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                       \t\t\t\tbool operator > (const pa3 &p) const{\n                                                \t\tif(x!=p.x) return x>p.x;\n                                                \t\tif(y!=p.y) return y>p.y;\n                                                \t\t return z>p.z;\n                                                \t\t//return x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator == (const pa3 &p) const{\n                                                \t\treturn x==p.x && y==p.y && z==p.z;\n                                                \t}\n                                                \t\tbool operator != (const pa3 &p) const{\n                                                \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                                \t}\n                                                \n                                                };\n                                                \n                                                class pa4{\n                                                \tpublic:\n                                                \tint x;\n                                                \tint y,z,w;\n                                                \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                                \tbool operator < (const pa4 &p) const{\n                                                \t\tif(x!=p.x) return x<p.x;\n                                                \t\tif(y!=p.y) return y<p.y;\n                                                \t\tif(z!=p.z)return z<p.z;\n                                                \t\treturn w<p.w;\n                                                \t\t//return x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator > (const pa4 &p) const{\n                                                \t\tif(x!=p.x) return x>p.x;\n                                                \t\tif(y!=p.y) return y>p.y;\n                                                \t\tif(z!=p.z)return z>p.z;\n                                                \t\treturn w>p.w;\n                                                \t\t//return x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator == (const pa4 &p) const{\n                                                \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                                \t}\n                                                \t\n                                                \tbool operator != (const pa4 &p) const{\n                                                \t\treturn !(x==p.x && y==p.y && z==p.z &&w==p.w);\n                                                \t}\n                                                \t\t\n                                                \n                                                };\n                                                class pa2{\n                                                \tpublic:\n                                                \tint x,y;\n                                                \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                                \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                                \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                                \tbool operator < (const pa2 &p) const{\n                                                \t\treturn x!= p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator > (const pa2 &p) const{\n                                                \t\treturn x != p.x ? x>p.x: y>p.y;\n                                                \t}\n                                                \tbool operator == (const pa2 &p) const{\n                                                \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                                \t}\n                                                \tbool operator != (const pa2 &p) const{\n                                                \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                                \t}\n                                                \t\t\n                                                \n                                                };\n                                                \n                                                       #define ppa pair<int,pas>\n                                                class Point{\n                                                \tpublic:\n                                                \tdouble x,y;\n                                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                                \tdouble absv() {return sqrt(norm());}\n                                                \tdouble norm() {return x*x+y*y;}\n                                                \tbool operator < (const Point &p) const{\n                                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator == (const Point &p) const{\n                                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                                \t}\n                                                };\n                                                typedef Point Vector;\n                                         #define pl pair<int,pas>\n                                                struct Segment{\n                                                Point p1,p2;\n                                                };\n                                                 double dot(Vector a,Vector b){\n                                                \treturn a.x*b.x+a.y*b.y;\n                                                }\n                                                double cross(Vector a,Vector b){\n                                                \treturn a.x*b.y-a.y*b.x;\n                                                }\n                                            \n                    bool parareru(Point a,Point b,Point c,Point d){\n                    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                    \treturn abs(cross(a-b,d-c))<EPS;\n                    }\n                    double distance_ls_p(Point a, Point b, Point c) {\n                      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                      return abs(cross(b-a, c-a)) / (b-a).absv();\n                    }\n                    bool is_intersected_ls(Segment a,Segment b) {\n                    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                    //\t\tcout<<\"sss\"<<endl;\n                    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                    \t\treturn false;\n                    \t}\n                      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                    }\n                     \n                    double segment_dis(Segment a,Segment b){\n                    \tif(is_intersected_ls(a,b))return 0;\n                    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                    \treturn r;\n                    }\n                    Point intersection_ls(Segment a, Segment b) {\n                      Point ba = b.p2-b.p1;\n                      double d1 = abs(cross(ba, a.p1-b.p1));\n                      double d2 = abs(cross(ba, a.p2-b.p1));\n                      double t = d1 / (d1 + d2);\n                     \n                      return a.p1 + (a.p2-a.p1) * t;\n                    }\n                     \n                                    string itos( int i ) {\n                                    ostringstream s ;\n                                    s << i ;\n                                    return s.str() ;\n                                    }\n                                     \n                                    int gcd(int v,int b){\n                                    \tif(v>b) return gcd(b,v);\n                                    \tif(v==b) return b;\n                                    \tif(b%v==0) return v;\n                                    \treturn gcd(v,b%v);\n                                    }\n                     \n                                    double distans(double x1,double y1,double x2,double y2){\n                                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                    \treturn sqrt(rr);\n                                    \t\n                                    }\n                                    int mod;\n                    int pr[2010];\n                    int inv[2010];\n                   \n                    int beki(int wa,int rr,int warukazu){\n                    \tif(rr==0) return 1%warukazu;\n                    \tif(rr==1) return wa%warukazu;\n                    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n                    \tint zx=beki(wa,rr/2,warukazu);\n                    \treturn (zx*zx)%warukazu;\n                    }\n                    /*\n        double bekid(double w,int r){\n        \tif(r==0) return 1.0;\n        \tif(r==1) return w;\n        \tif(r%2) return bekid(w,r-1)*w;\n        \tdouble f=bekid(w,r/2);\n        \treturn f*f;\n        }*/\n            /*        \n        \t\t\tint comb(int nn,int rr){\n        \t\t\t\tint r=pr[nn]*inv[rr];\n        \t\t\t\tr%=mod;\n        \t\t\t\tr*=inv[nn-rr];\n        \t\t\t\tr%=mod;\n        \t\t\t\treturn r;\n        \t\t\t}\n              */      \n                    void gya(int ert){\n                    \tpr[0]=1;\n                    \tfor(int i=1;i<ert;i++){\n                    \t\tpr[i]=(pr[i-1]*i)%mod;\n                    \t}\n                    \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                    \t\n                    }\n                    \n                  //   cin.tie(0);\n        \t\t//\tios::sync_with_stdio(false);\n        \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                     //sort(ve.begin(),ve.end(),greater<int>());\n                                             //----------------kokomade tenpure------------\nint a[200020],b[200020];\nint n;\n\tvoid solve(){\n\t\tint ans=0;\n\t\tvector<int> ve;\n\t\tfor(int i=0;i<2*n;i++)ans+=a[i];\n\t\t\n\t\tfor(int i=1;i<2*n-1;i++) ve.pb(b[i]-a[i]);\n\t\tsort(ve.begin(),ve.end(),greater<int>());\n\t\tint cn=0,r=0;\n\t\tfor(int i=0;i<ve.size();i+=2){\n\t\tr+=ve[i]+ve[i+1];\n\t\t\tcn=max(cn,r);\n\t\t}\n\t\tcout<<ans+cn<<endl;\n\t\t\n\t\t\n\t}\n        signed main(){\n                   cin.tie(0);\n        \t\tios::sync_with_stdio(false);\nint q;\n        \tcin>>n>>q;\n        \tfor(int i=0;i<2*n;i++)cin>>a[i];\n        \tfor(int i=0;i<2*n;i++)cin>>b[i];\n        \t\n        \tfor(int i=0;i<q;i++){\n        \t\tint p,x,y;\n        \t\tcin>>p>>x>>y;\n        \t\tp--;\n        \t\ta[p]=x;\n        \t\tb[p]=y;\n        \t\tsolve();\n        \t}\n        \treturn 0;\n                }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    int n, q;\n    cin >> n >> q;\n    n *= 2;\n    VL a(n), b(n);\n    REP(i,n) scanf(\"%lld\", &a[i]);\n    REP(i,n) scanf(\"%lld\", &b[i]);\n\n    ll suma = 0;\n    REP(i,n) suma += a[i];\n\n    multiset<ll> st;\n    ll pos = 0;\n    int c = 0;\n    FOR(i,1,n-2){\n        st.insert(b[i] - a[i]);\n        if (b[i] > a[i]){\n            pos += b[i] - a[i];\n            c++;\n        }\n    }\n\n    while (q--){\n        int i;\n        ll x, y;\n        scanf(\"%d %lld %lld\", &i, &x, &y);\n        i--;\n        if (i == 0 || i == n-1){\n            suma += x - a[i];\n        }else{\n            suma += x - a[i];\n            ll od = b[i] - a[i];\n            ll nw = y - x;\n            st.erase(st.find(od));\n            st.insert(nw);\n            if (od > 0){\n                c--;\n                pos -= od;\n            }\n            if (nw > 0){\n                c++;\n                pos += nw;\n            }\n        }\n        a[i] = x;\n        b[i] = y;\n\n        // cout << \"suma \" << suma << endl;\n        // cout << \"c \" << c << \"  sumpos \" << pos << endl;\n        // for (ll x : st) cout << x << \" \";\n        // cout << endl;\n\n        ll ans = suma;\n        if (c % 2 == 0){\n            ans += pos;\n        }else{\n            ll p, q;\n            auto itr = st.upper_bound(0);\n            p = *itr;\n            itr--;\n            q = *itr;\n            ans += max(pos - p, pos + q);\n        }\n        printf(\"%lld\\n\", ans);\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef double lld;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<double> vdl;\ntypedef vector<vector<lli>> mat;\ntypedef vector<vdl> mad;\ntypedef unordered_map<lli,unordered_map<lli,lli>> graph;\ntypedef complex<double> cmp;\ntypedef vector<cmp> vcl;\n\nlli n,q;\nvll a,b,c;\nmultiset<lli> l,r;\nlli ans = 0;\nlli p,x,y;\n\nint main(){\n  cin >> n >> q;\n  a = vll(2*n);\n  b = vll(2*n);\n  c = vll(2*n);\n  for(lli i = 0;i < 2*n;i++) cin >> a[i];\n  for(lli i = 0;i < 2*n;i++) cin >> b[i];\n  for(lli i = 0;i < 2*n;i++) c[i] = a[i]-b[i];\n  ans = accumulate(a.begin(),a.end(),0ll);\n  for(lli i = 1;i < 2*n-1;i++){\n    if(c[i] < 0){\n      r.insert(c[i]);\n    }else{\n      l.insert(c[i]);\n    }\n  }\n\n  for(lli x : r){\n    ans -= x;\n  }\n  for(lli i = 0;i < q;i++){\n    cin >> p >> x >> y;\n    p--;\n    if(p >= 1 && p < 2*n-1){\n      if(l.find(c[p]) != l.end()) l.erase(l.find(c[p]));\n      else if(r.find(c[p]) != r.end()){\n        r.erase(r.find(c[p]));\n        ans += c[p];\n      }\n    }\n    ans -= a[p];\n    a[p] = x;\n    b[p] = y;\n    c[p] = a[p]-b[p];\n    ans += a[p];\n    if(p >= 1 && p < 2*n-1){\n      if(c[p] < 0){\n        r.insert(c[p]);\n        ans -= c[p];\n      } else l.insert(c[p]);\n    }\n    if(r.size()%2 == 1 && *r.rbegin()+*l.begin() < 0) cout << ans-*l.begin() << endl;\n    else if(r.size()%2 == 1 && *r.rbegin()+*l.begin() >= 0) cout << ans+*r.rbegin() << endl;\n    else cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace std::chrono;\n#define int long long\n#define ll long long\nauto start_time = system_clock::now();\n\n//@formatter:off\n#ifdef _DEBUG\n//区間削除は出来ない\ntemplate<class T> struct my_pbds_tree {    set<T> s;    auto begin() { return s.begin(); }    auto end() { return s.end(); }    auto rbegin() { return s.rbegin(); }    auto rend() { return s.rend(); }    auto empty() { return s.empty(); }    auto size() { return s.size(); }    void clear() { s.clear(); }    template<class U> void insert(U v) { s.insert(v); }template<class U> void operator+=(U v) { insert(v); }    template<class F> auto erase(F v) { return s.erase(v); }    template<class U> auto find(U v) { return s.find(v); }    template<class U> auto lower_bound(U v) { return s.lower_bound(v); }    template<class U> auto upper_bound(U v) { return s.upper_bound(v); }    auto find_by_order(ll k) {        auto it = s.begin();        for (ll i = 0; i < k; i++)it++;        return it;    }    auto order_of_key(ll v) {        auto it = s.begin();        ll i=0;        for (;it != s.end() && *it <v ; i++)it++;        return i;    }};\n#define pbds(T) my_pbds_tree<T>\n#else\n#define unordered_map __gnu_pbds::gp_hash_table\n//find_by_order(k) k番目のイテレーター\n//order_of_key(k)  k以上が前から何番目か\n#define pbds(U) __gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>\n#endif\nstruct xorshift {    static uint64_t splitmix64(uint64_t x) {        x += 0x9e3779b97f4a7c15;        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;        return x ^ (x >> 31);    }    size_t operator()(uint64_t x) const {        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(x + FIXED_RANDOM);    }    size_t operator()(std::pair<ll, ll> x) const {        ll v=((x.first) << 32) | x.second;        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(v + FIXED_RANDOM);    }};\ntemplate<class U, class L> void operator+=(__gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> &s, L v) { s.insert(v); }\n//衝突対策\n#define ws wszzzz\n\ntemplate<class A, class B, class C>struct T2 {A f;B s;C t;T2() { f = 0, s = 0, t = 0; }T2(A f, B s, C t) : f(f), s(s), t(t) {}bool operator<(const T2 &r) const {        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;        /*return f != r.f ? f > r.f : s != r.s ?n s > r.s : t > r.t; 大きい順 */   }    bool operator>(const T2 &r) const {        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;        /*return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順 */   }    bool operator==(const T2 &r) const {        return f == r.f && s == r.s && t == r.t;    }    bool operator!=(const T2 &r) const {        return f != r.f || s != r.s || t != r.t;    }};\ntemplate<class A, class B, class C, class D> struct F2 {    A a;    B b;    C c;    D d;    F2() { a = 0, b = 0, c = 0, d = 0; }    F2(A a, B b, C c, D d) : a(a), b(b), c(c), d(d) {}    bool operator<(const F2 &r) const {        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;    /*    return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;*/    }    bool operator>(const F2 &r) const {        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;/*        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;*/    }    bool operator==(const F2 &r) const {        return a == r.a && b == r.b && c == r.c && d == r.d;    }    bool operator!=(const F2 &r) const {        return a != r.a || b != r.b || c != r.c || d != r.d;    }    ll operator[](ll i) {        assert(i < 4);        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;    }};\ntypedef T2<ll, ll, ll> T;\ntypedef F2<ll, ll, ll, ll> F;\nT mt(ll a, ll b, ll c) {return T(a, b, c);}\n\n//@マクロ省略系 型,構造\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\nusing pd =pair<dou, dou>;\n#define fi first\n#define se second\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define el else\n#define elf else if\n#define wh while\n\n#define maxq 1\n#define minq -1\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MALLOC(type, len) (type*)malloc((len) * sizeof(type))\n#define lam(right) [&](ll& p){return p right;}\n\n//マクロ省略系 コンテナ\nusing vi = vector<ll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vp = vector<P>;\nusing vt = vector<T>;\n\n#define V vector\n#define o_vvt(o1, o2, o3, o4, name, ...) name\n#define vvt0(t) V<V<t>>\n#define vvt1(t,a) V<V<t>>a\n#define vvt2(t,a, b) V<V<t>>a(b)\n#define vvt3(t,a, b, c) V<V<t>> a(b,V<t>(c))\n#define vvt4(t,a, b, c, d) V<V<t>> a(b,V<t>(c,d))\n\n#define vvi(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));}\n#define vni(name, ...) auto name = make_v<ll>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<ll, ll>;\nusing mapp = map<P, ll>;\nusing mapd = map<dou, ll>;\nusing mapc = map<char, ll>;\nusing maps = map<str, ll>;\nusing seti = set<ll>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<ll>;\n#define bset bitset\n#define uset unordered_set\n#define useti unordered_set<ll,ll,xorshift>\n#define mset multiset\n#define mseti multiset<ll>\n#define umap unordered_map\n#define umapi unordered_map<ll,ll,xorshift>\n#define umapp unordered_map<P,ll,xorshift>\n#define mmap multimap\n\ntemplate<class T> struct pq {    priority_queue<T, vector<T>, greater<T> > q;/*小さい順*/    T su = 0;    void clear() {q = priority_queue<T, vector<T>, greater<T> >();su = 0;}    void operator+=(T v) {su += v;q.push(v);}    T sum() {return su;}    T top() {return q.top();}    void pop() {su -= q.top();q.pop();}    T poll() {T ret = q.top();su -= ret;q.pop();return ret;}    ll size() {return q.size();}};\ntemplate<class T> struct pqg {    priority_queue<T> q;/*大きい順*/    T su = 0;    void clear() {q = priority_queue<T>();su = 0;}    void operator+=(T v) {su += v;q.push(v);}    T sum() {return su;}    T top() {return q.top();}    void pop() {su -= q.top();q.pop();}    T poll() {T ret = q.top();su -= ret;q.pop();return ret;}    ll size() {return q.size();}};\n#define pqi pq<ll>\n#define pqgi pqg<ll>\n//マクロ 繰り返し\n#define o_rep(o1, o2, o3, o4, name, ...) name\n# define rep1(n) for(ll rep1i = 0,rep1lim=n; rep1i < rep1lim ; ++rep1i)\n# define rep2(i, n) for(ll i = 0,rep2lim=n; i < rep2lim ; ++i)\n#define rep3(i, m, n) for(ll i = m,rep3lim=n; i < rep3lim ; ++i)\n#define rep4(i, m, n, ad) for(ll i = m,rep4lim=n; i < rep4lim ; i+= ad)\n#define rep(...) o_rep(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n\n#define rer2(i, n) for(ll i = n; i >= 0 ; i--)\n#define rer3(i, m, n) for(ll i = m,rer3lim=n; i >= rer3lim ; i--)\n#define rer4(i, m, n, dec) for(ll i = m,rer4lim=n; i >= rer4lim ; i-=dec)\n#define rer(...) o_rep(__VA_ARGS__,rer4,rer3,rer2,)(__VA_ARGS__)\n\n#define reps2(i, j, n) for(ll i = 0,reps2lim=n; i < reps2lim ;++i)for(ll j = 0; j < reps2lim ; ++j)\n#define reps3(i, j, k, n) for(ll i = 0,reps3lim=n; i < reps3lim ; ++i)for(ll j = 0; j < reps3lim ; ++j)for(ll k = 0; k < reps3lim ; ++k)\n#define reps4(i, j, k, l, n) for(ll i = 0,reps4lim=n; i < reps4lim ; ++i)for(ll j = 0; j < reps4lim ; ++j)for(ll k = 0; k < reps4lim ; ++k)for(ll l = 0; l < reps4lim ; ++l)\n#define o_reps(o1, o2, o3, o4, o5, name, ...) name\n#define reps(...) o_reps(__VA_ARGS__,reps4,reps3,reps2,rep2,)(__VA_ARGS__)\n\n#define repss(i, j, k, a, b, c) for(ll i = 0; i < a ; ++i)for(ll j = 0; j < b ; ++j)for(ll k = 0; k < c ; ++k)\n\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) for (ll gi = 0,forglim = ve.size(), f, t, c; gi < forglim && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); ++gi)\n#define fort(gi, ve) for (ll gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); ++gi)if(t!=p)\n\n#define form(st, l, r) for (auto &&it = st.lower_bound(l); it != st.end() && (*it).fi < r; ++it)\n#define forit(st, l, r) for (auto &&it = st.lower_bound(l); it != st.end() && (*it) < r;)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst ll inf = (ll) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst char infc = '{';\nconst string infs = \"{\";\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((ll)(a).size())\n#define mp make_pair\n#define pb pop_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconstexpr bool ev(ll a) { return !(a & 1); }\nconstexpr bool od(ll a) { return (a & 1); }\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\n//@formatter:on\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> { public:size_t operator()(const std::pair<signed, signed> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n    template<> class hash<std::pair<ll, ll>> { public:/*大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断*/size_t operator()(const std::pair<ll, ll> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n}\n//@formatter:off\n//stream まとめ\nistream &operator>>(istream &iss, P &a) {    iss >> a.first >> a.second;    return iss;}template<typename T> istream &operator>>(istream &iss, vector<T> &vec) {    for (T &x: vec) iss >> x;    return iss;}template<class T, class U> ostream &operator<<(ostream &os, pair<T, U> p) {    os << p.fi << \" \" << p.se << endl;    return os;}ostream &operator<<(ostream &os, T p) {    os << p.f << \" \" << p.s << \" \" << p.t;    return os;}ostream &operator<<(ostream &os, F p) {    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;    return os;}template<typename T> ostream &operator<<(ostream &os, vector<T> &vec) {    for (ll i = 0; i < vec.size(); ++i)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");    return os;}template<typename T> ostream &operator<<(ostream &os, vector<vector<T>> &vec) {    for (ll i = 0; i < vec.size(); ++i) {        for (ll j = 0; j < vec[i].size(); ++j) { os << vec[i][j] << \" \"; }        os << endl;    }    return os;}template<typename T, typename U> ostream &operator<<(ostream &os, map<T, U> &m) {    for (auto &&v:m) os << v;    return os;}\ntemplate<typename W, typename H> void resize(vector<W> &vec, const H head) { vec.resize(head); }template<typename W, typename H, typename ... T> void resize(vector<W> &vec, const H &head, const T ... tail) {vec.resize(head);for (auto &v: vec)resize(v, tail...);}\ntemplate<typename T, typename F> bool all_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool all_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (!all_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool any_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool any_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (any_of2(v[i], f))return true; }    return false;}\ntemplate<typename T, typename F> bool none_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool none_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (none_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool find_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll find_if2(vector<T> &v, F f) {    rep(i, sz(v)) { if (find_if2(v[i], f))return i; }    return sz(v);}\ntemplate<typename T, typename F> bool rfind_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll rfind_if2(vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (rfind_if2(v[i], f))return i; }    return -1;}\ntemplate<class T> bool contains(string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> ll count_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll count_if2(vector<T> &vec, F f) {    ll ret = 0;    fora(v, vec)ret += count_if2(v, f);    return ret;}\ntemplate<typename T, typename F> void for_each2(T &v, F f) { f(v); }\ntemplate<typename T, typename F> void for_each2(vector<T> &vec, F f) { fora(v, vec)for_each2(v, f); }\ntemplate<typename W> ll count_od(vector<W> &a) {return count_if2(a,[](ll v){return v&1 ;});}\ntemplate<typename W> ll count_ev(vector<W> &a) {return count_if2(a,[](ll v){return !(v&1) ;});}\n#define all_of(a,right) all_of2(a,lam(right))\n#define any_of(a,right) any_of2(a,lam(right))\n#define none_of(a,right) none_of2(a,lam(right))\n#define find_if(a,right) find_if2(a,lam(right))\n#define rfind_if(a,right) rfind_if2(a,lam(right))\n#define contains_if(a,right) contains_if2(a,lam(right))\n#define count_if(a, right) count_if2(a,lam(right))\n#define for_each(a, right) do{fora(v,a){v right;}}while(0)\n\n\ntemplate<class T, class U> void replace(vector<T> &a, T key, U v) { replace(a.begin(), a.end(), key, v); }\nvoid replace(str &a, char key, str v) { if (v == \"\")a.erase(remove(all(a), key), a.end()); }\nvoid replace(str &a, char key, char v) { replace(all(a), key, v); }\n//keyと同じかどうか01で置き換える\ntemplate<class T, class U> void replace(vector<T> &a, U k) { rep(i, sz(a)) a[i] = a[i] == k; }\ntemplate<class T, class U> void replace(vector<vector<T >> &a, U k) { rep(i, sz(a))rep(j, sz(a[0])) a[i][j] = a[i][j] == k; }\ntemplate<class T> void replace(T &a) { replace(a, '#'); }\nvoid replace(str &a, str key, str v) {stringstream t;ll kn = sz(key);std::string::size_type Pos(a.find(key));ll l = 0;while (Pos != std::string::npos) {t << a.substr(l, Pos - l);t << v;l = Pos + kn;Pos = a.find(key, Pos + kn);}t << a.substr(l, sz(a) - l);a = t.str();}\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {vi c = a;vi d = b;sort(all(c));sort(all(d));return includes(all(c), all(d));}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\nvoid iota(vector<ll> &ve, ll s, ll n) {ve.resize(n);iota(all(ve), s);}\nvi iota(ll s, ll len) {vi ve(len);iota(all(ve), s);return ve;}\ntemplate<class A, class B> auto vtop(vector<A> &a, vector<B> &b) {    assert(sz(a) == sz(b));    /*stringを0で初期化できない  */  vector<pair<A, B>> res;    rep(i, sz(a))res.eb(a[i], b[i]);return res;}\ntemplate<class A, class B> void ptov(vector<pair<A, B>> &p, vector<A> &a, vector<B> &b) {    a.resize(sz(p)), b.resize(sz(p));    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;}\ntemplate<class A, class B, class C> auto vtot(vector<A> &a, vector<B> &b, vector<C> &c) {    assert(sz(a) == sz(b) && sz(b) == sz(c));    vector<T2<A, B, C>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i]);    return res;}\ntemplate<class A, class B, class C, class D> auto vtof(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    assert(sz(a) == sz(b) && sz(b) == sz(c) && sz(c) == sz(d));    vector<F2<A, B, C, D>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i], d[i]);    return res;}\nenum pcomparator { fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd };\nenum tcomparator {    fisiti, fisitd, fisdti, fisdtd, fdsiti, fdsitd, fdsdti, fdsdtd,    fitisi, fitisd, fitdsi, fitdsd, fdtisi, fdtisd, fdtdsi, fdtdsd,    sifiti, sifitd, sifdti, sifdtd, sdfiti, sdfitd, sdfdti, sdfdtd,    sitifi, sitifd, sitdfi, sitdfd, sdtifi, sdtifd, sdtdfi, sdfdfd,    tifisi, tifisd, tifdsi, tifdsd, tdfisi, tdfisd, tdfdsi, tdfdsd,    tisifi, tisifd, tisdfi, tisdfd, tdsifi, tdsifd, tdsdfi, tdsdfd};\ntemplate<class A, class B> void sort(vector<pair<A, B>> &a, pcomparator type) {    typedef pair<A, B> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });};template<class U> void sort(vector<U> &a, pcomparator type) {    if (type == fisi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });};template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D> > &a, pcomparator type) {    typedef F2<A, B, C, D> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a > r.a; });};template<class U> void sort(vector<U> &a, tcomparator type) {    if (type == 0) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });}template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D>> &a, tcomparator type) {    typedef F2<A, B, C, D> U;    if (type == 0) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });}\n\nvoid sort(string &a) { sort(all(a)); }\ntemplate<class T> void sort(vector<T> &a) { sort(all(a)); }\n//P l, P rで f(P) の形で渡す\ntemplate<class U, class F> void sort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) < f(r); }); };\ntemplate<class T> void rsort(vector<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class U, class F> void rsort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) > f(r); }); };\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class A, class B> void sortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    sort(c);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B, class F> void sortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    sort(c, f);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B> void rsortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    rsort(c);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}template<class A, class B, class F> void rsortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    rsort(c, f);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C> void sortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    sort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void sortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    sort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    rsort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    rsort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class D> void sortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    sort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\ntemplate<class A, class B, class C, class D> void rsortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    rsort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\n//sortindex 元のvectorはソートしない\ntemplate<class T> vi sorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind);    return ind;}/*indexの分で型が変わるためpcomparatorが必要*/template<class T> vi sorti(vector<T> &a, pcomparator f) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind, f);    return ind;}template<class T, class F> vi sorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) < f(a[y]); });    return ind;}template<class T> vi rsorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    rsortp(b, ind);    return ind;}template<class T, class F> vi rsorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) > f(a[y]); });    return ind;}template<class A, class B, class F> vi sortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) < f(c[y]); });    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b, pcomparator f) {    vi ind = iota(0, sz(a));    auto c = a;    auto d = b;    sortt(c, d, ind, f);    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fisi); };template<class A, class B, class F> vi rsortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) > f(c[y]); });    return ind;}template<class A, class B> vi rsortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fdsd); };template<class A, class B, class C, class F> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) < f(d[y]); });    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, pcomparator f) {    vi ind = iota(0, sz(a));    auto d = vtof(a, b, c, ind);    sort(d, f);    rep(i, sz(a))ind[i] = d[i].d;    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] < c[y];            else return b[x] < b[y];        } else {            return a[x] < a[y];        }    });    return ind;}template<class A, class B, class C, class F> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) > f(d[y]); });    return ind;}template<class A, class B, class C> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] > c[y];            else return b[x] > b[y];        } else {            return a[x] > a[y];        }    });    return ind;}\ntemplate<class T> void sort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)sort(a[i]); }\ntemplate<class T> void rsort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)rsort(a[i]); }\n\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }template<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }template<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename W, typename T>void fill(W &xx, const T vall) {    xx = vall;}template<typename W, typename T>void fill(vector<W> &vecc, const T vall) {    for (auto &&vx     : vecc)fill(vx, vall);}\ntemplate<typename W,typename T>void fill(vector<W> &xx,const T v,ll len) {rep(i, len)xx[i]=v;}\ntemplate<typename W,typename T>void fill(vector<vector<W>> &xx,const T v,ll lh,ll lw) {rep(i, lh)rep(j,lw)xx[i][j]=v;}\ntemplate<class T,class U>void fill(vector<T> &a,U val,vi& ind) {fora(v,ind)a[v]=val;}\n\ntemplate<typename A, size_t N> A sum(A (&a)[N]) {    A res = 0;    rep(i, N)res += a[i];    return res;}template<typename A, size_t N, size_t O> A sum(A (&a)[N][O]) {    A res = 0;    rep(i, N)rep(j, O)res += a[i][j];    return res;}template<typename A, size_t N, size_t O, size_t P> A sum(A (&a)[N][O][P]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)res += a[i][j][k];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A sum(A (&a)[N][O][P][Q]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)res += a[i][j][k][l];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A sum(A (&a)[N][O][P][Q][R]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)res += a[i][j][k][l][m];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A sum(A (&a)[N][O][P][Q][R][S]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)res += a[i][j][k][l][m][n];    return res;}\n//@汎用便利関数 入力\nll in() {ll ret;cin >> ret;return ret;}\nstring sin() {string ret;cin >> ret;return ret;}\ntemplate<class T>  void in(T &head) { cin >> head; }template<class T, class... U>  void in(T &head, U &... tail) {cin >> head;in(tail...);}\n\n#define o_din(o1, o2, o3, o4, o5, o6, name, ...) name\n#define din1(a) ll a;cin>>a\n#define din2(a, b) ll a,b;cin>>a>> b\n#define din3(a, b, c) ll a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) ll a,b,c,d;cin>>a>>b>>c>>d\n#define din5(a, b, c, d, e) ll a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define din6(a, b, c, d, e, f) ll a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define din(...) o_din(__VA_ARGS__,din6,din5,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define o_dind(o1, o2, o3, o4, name, ...) name\n#define din1d(a) din1(a);a--\n#define din2d(a, b) din2(a,b);a--,b--\n#define din3d(a, b, c) din3(a,b,c);a--,b--,c--\n#define din4d(a, b, c, d) din4(a,b,c,d);a--,b--,c--,d--\n#define dind(...) o_dind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\ntemplate<class T> void out2(T &&head) { cout << head; }\ntemplate<class T, class... U> void out2(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);    cout << \"\" << endl;}\ntemplate<class T> void out(T &&head) {    cout << head  << endl;}\ntemplate<class T> void outv(vector<T> &a, ll W) {    rep(i, W) { cout << a[i] << \" \"; }    cout << \"\" << endl;}template<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf) {    rep(h, min(H, sz(a))) {        rep(w, min(W, sz(a[0]))) { if (a[h][w] == linf) cout << \"e\" << \" \"; else cout << a[h][w] << \" \"; }        cout << \"\" << endl;    }}\ntemplate<class T> void outl(vector<T> &a) { fora(v, a)cout << v << endl; }\ntemplate<class T> void na(vector<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i];}\n#define dna(a, n) vi a(n); rep(dnai,n) cin >> a[dnai];\ntemplate<class T> void nao(vector<T> &a, ll n) {    a.resize(n + 1);    a[0] = 0;    rep(i, n)cin >> a[i + 1];}\ntemplate<class T> void naod(vector<T> &a, ll n) {    a.resize(n + 1);    a[0] = 0;    rep(i, n)cin >> a[i + 1],a[i+1]--;}\ntemplate<class T> void nad(vector<T> &a, ll n) {    a.resize(n);    rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T, class U> void na2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i];}\n#define dna2(a, b, n) vi a(n),b(n);rep(dna2i, n)cin >> a[dna2i] >> b[dna2i];\ntemplate<class T, class U> void nao2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n + 1);    b.resize(n + 1);    a[0] = b[0] = 0;    rep(i, n)cin >> a[i + 1] >> b[i + 1];}\n#define dna2d(a, b, n) vi a(n),b(n);rep(dna2di, n){cin >> a[dna2di] >> b[dna2di];a[dna2di]--,b[dna2di]--;}\ntemplate<class T, class U> void na2d(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i], a[i]--, b[i]--;}\ntemplate<class T, class U, class W> void na3(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {    a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define dna3(a, b, c, n) vi a(n),b(n),c(n);   rep(dna3i, n)cin >> a[dna3i] >> b[dna3i] >> c[dna3i];\ntemplate<class T, class U, class W> void na3d(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {    a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i], a[i]--, b[i]--, c[i]--;}\n#define dna3d(a, b, c, n) vi a(n),b(n),c(n);  rep(dna3di, n){cin >> a[dna3di] >> b[dna3di] >> c[dna3di];a[dna3di]--,b[dna3di]--,c[dna3di]--;}\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n//デバッグ\n#define sp << \" \" <<\n\n#define debugName(VariableName) # VariableName\n\n#define deb1(x)  debugName(x)<<\" = \"<<x\n#define deb2(x, ...) deb1(x) <<\", \"<< deb1(__VA_ARGS__)\n#define deb3(x, ...) deb1(x) <<\", \"<< deb2(__VA_ARGS__)\n#define deb4(x, ...) deb1(x) <<\", \"<< deb3(__VA_ARGS__)\n#define deb5(x, ...) deb1(x) <<\", \"<< deb4(__VA_ARGS__)\n#define deb6(x, ...) deb1(x) <<\", \"<< deb5(__VA_ARGS__)\n#define deb7(x, ...) deb1(x) <<\", \"<< deb6(__VA_ARGS__)\n#define deb8(x, ...) deb1(x) <<\", \"<< deb7(__VA_ARGS__)\n#define deb9(x, ...) deb1(x) <<\", \"<< deb8(__VA_ARGS__)\n#define deb10(x, ...) deb1(x) <<\", \"<< deb9(__VA_ARGS__)\n\n#define o_ebug(o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, name, ...) name\n\n#ifdef _DEBUG\n#define deb(...)  cerr<< o_ebug(__VA_ARGS__,deb10,deb9,deb8,deb7,deb6,deb5,deb4,deb3,deb2,deb1)(__VA_ARGS__) <<endl\n#else\n#define deb(...) ;\n#endif\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\n//@formatter:off\n//よく使うクラス、構造体\nstruct unionfind {\n    vector<ll> par;\n    vector<ll> siz;\n    vector<ll> es;\n    ll n, trees;//連結グループの数(親の種類)\n    unionfind(ll n) : n(n), trees(n) {        par.resize(n);        siz.resize(n);        es.resize(n);        for (ll i = 0; i < n; i++) {            par[i] = i;            siz[i] = 1;        }    }\n    ll root(ll x) { if (par[x] == x) { return x; } else { return par[x] = root(par[x]); }}\n    void unite(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        es[x]++;\n        if (x == y) return;\n        if (siz[x] > siz[y]) swap(x, y);\n        trees--;\n        par[x] = y;\n        siz[y] += siz[x];\n        es[y] += es[x];\n    }\n    bool same(ll x, ll y) { return root(x) == root(y); }\n    ll size(ll x) { return siz[root(x)]; }\n    ll esize(ll x) { return es[root(x)]; }\n    vi sizes(){        vi cou(n);        vi ret;        ret.reserve(n);        rep(i, n){            cou[root (i)]++;        }        rep(i, n){            if(cou[i])ret.push_back(cou[i]);        }        return ret;    }\n    //つながりを無向グラフと見なし、xが閉路に含まれるか判定\n    bool close(ll x) { return esize(x) >= size(x); }\n    V<vi> sets() {        vi ind(n, -1);        ll i = 0;        vvi(res, trees);        rep(j, n) {            ll r = root(j);            if (ind[r] == -1)ind[r] = i++;            res[ind[r]].push_back(j);        }        rep(i, trees) {            ll r = root(res[i][0]);            if (res[i][0] == r)continue;            rep(j, 1, sz(res[i])) {                if (res[i][j] == r) {                    swap(res[i][0], res[i][j]);                    break;                }            }        }        return res;    }\n};//@formatter:off\n\n\nusing bll =__int128;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing u128 = __uint128_t;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {    std::ostream::sentry s(dest);    if (s) {        __uint128_t tmp = value < 0 ? -value : value;        char buffer[128];        char *d = std::end(buffer);        do {            --d;            *d = \"0123456789\"[tmp % 10];            tmp /= 10;        } while (tmp != 0);        if (value < 0) {            --d;            *d = '-';        }        ll len = std::end(buffer) - d;        if (dest.rdbuf()->sputn(d, len) != len) { dest.setstate(std::ios_base::badbit); }    }    return dest;}\n//__int128 toi128(string &s) {    __int128 ret = 0;    for (ll i = 0; i < s.length(); ++i)        if ('0' <= s[i] && s[i] <= '9')            ret = 10 * ret + s[i] - '0';    return ret;}\n\n\n//エラー\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");    exit(0);\n#endif\n    string a = \"a\";    rep(i, 30)a += a;    rep(i, 1 << 17)cout << a << endl;    cout << \"OLE 出力長制限超過\" << endl;    exit(0);}\nvoid re() {    assert(0 == 1);    exit(0);}\nvoid tle() { while (inf)cout << inf << endl; }\n\n//便利関数\n\n//テスト用\nchar ranc() { return (char) ('a' + rand() % 26); }\nll rand(ll min, ll max) {    assert(min <= max);    if (min >= 0 && max >= 0) { return rand() % (max + 1 - min) + min; } else if (max < 0) { return -rand(-max, -min); } else { if (rand() % 2) { return rand(0, max); } else { return -rand(0, -min); }}}\nvi ranv(ll n, ll min, ll max) {    vi v(n);    rep(i, n)v[i] = rand(min, max);    return v;}\nstr ransu(ll n) {    str s;    rep(i, n)s += (char) rand('A', 'Z');    return s;}\nstr ransl(ll n) {    str s;    rep(i, n)s += (char) rand('a', 'z');    return s;}\n//単調増加\nvi ranvinc(ll n, ll min, ll max) {    vi v(n);    bool bad = 1;    while (bad) {        bad = 0;        v.resize(n);        rep(i, n) {            if (i && min > max - v[i - 1]) {                bad = 1;                break;            }            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]); else v[i] = rand(min, max);        }    }    return v;}\n//便利 汎用\nvoid ranvlr(ll n, ll min, ll max, vi &l, vi &r) {    l.resize(n);    r.resize(n);    rep(i, n) {        l[i] = rand(min, max);        r[i] = l[i] + rand(0, max - l[i]);    }}\nvp run_length(vi &a) {    vp ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\nvector<pair<char, ll>> run_length(string &a) {    vector<pair<char, ll>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\ntemplate<class F> ll mgr(ll ok, ll ng, F f) {    if (ok < ng)        while (ng - ok > 1) {            ll mid = (ok + ng) / 2;            if (f(mid))ok = mid; else ng = mid;        }    else        while (ok - ng > 1) {            ll mid = (ok + ng) / 2;            if (f(mid))ok = mid; else ng = mid;        }    return ok;}\n//strを整数として比較\nstring smax(str &a, str b) {    if (sz(a) < sz(b)) { return b; } else if (sz(a) > sz(b)) { return a; } else { rep(i, sz(a)) { if (a[i] < b[i]) { return b; } else if (a[i] > b[i])return a; }}    return a;}\n//strを整数として比較\nstring smin(str &a, str b) {    if (sz(a) < sz(b)) { return a; } else if (sz(a) > sz(b)) { return b; } else { rep(i, sz(a)) { if (a[i] < b[i]) { return a; } else if (a[i] > b[i])return b; }}    return a;}\ntemplate<typename W, typename T> ll find(vector<W> &a, const T key) {    rep(i, sz(a))if (a[i] == key)return i;    return -1;}\ntemplate<typename W, typename T> P find(vector<vector<W >> &a, const T key) {    rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);    return mp(-1, -1);}\ntemplate<typename W, typename U> T find(vector<vector<vector<W >>> &a, const U key) {    rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);    return mt(-1, -1, -1);}\n\n\ntemplate<typename W, typename T> ll count2(W &a, const T k) { return a == k; }\ntemplate<typename W, typename T> ll count2(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\ntemplate<typename W, typename T> ll count(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\nll count(str &a, str k) {    ll ret = 0, len = k.length();    auto pos = a.find(k);    while (pos != string::npos)pos = a.find(k, pos + len), ++ret;    return ret;}\nvi count(str &a) {    vi cou(26);    char c = 'a';    if ('A' <= a[0] && a[0] <= 'Z')c = 'A';    rep(i, sz(a))++cou[a[i] - c];    return cou;}\n#define couif count_if\n//algorythm\n\n\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    return res;}\ntemplate<class T> void rev(vector<T> &a) { reverse(all(a)); }\ntemplate<class U> void rev(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[h][w];    a = b;}\nvoid  rev(string &a) { reverse(all(a)); }\nconstexpr ll p10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000ll, 100000000000ll, 1000000000000ll, 10000000000000ll, 100000000000000ll, 1000000000000000ll, 10000000000000000ll, 100000000000000000ll, 1000000000000000000ll};\n\nll get(ll a, ll keta) { return (a / (ll) pow(10, keta)) % 10; }\nll keta(ll v) { if (v < p10[9]) { if (v < p10[4]) { if (v < p10[2]) { if (v < p10[1]) return 1; else return 2; } else { if (v < p10[3]) return 3; else return 4; }} else { if (v < p10[7]) { if (v < p10[5]) return 5; else if (v < p10[6])return 6; else return 7; } else { if (v < p10[8])return 8; else return 9; }}} else { if (v < p10[13]) { if (v < p10[11]) { if (v < p10[10]) return 10; else return 11; } else { if (v < p10[12]) return 12; else return 13; }} else { if (v < p10[15]) { if (v < p10[14]) return 14; else if (v < p10[15])return 15; else return 16; } else { if (v < p10[17])return 17; else return 18; }}}}\nll dsum(ll v,ll sin=10) {    ll ret = 0;    for (; v; v /= sin)ret += v % sin;    return ret;}\n\nstruct sint {\n    ll v;\n    sint(ll v) : v(v) {}\n    operator ll() { return v; }\n    //下からi番目\n    ll operator[](ll i) { return (v / p10[i]) % 10; }\n    ll back(ll i) { return operator[](i); }\n    //上からi番目\n    ll top(ll i) {\n        ll len = keta(v);\n        return operator[](len - 1 - i);\n    }\n    //先頭からi番目にセット\n    ll settop(ll i, ll k) {\n        ll len = keta(v);\n        return set(len - 1 - i, k);\n    }\n    ll set(ll i, ll k) {\n        if (i < 0)return settop(abs(i) - 1, k);\n        return v += p10[i] * (k - (v / p10[i]) % 10);\n    }\n    ll add(ll i, ll k = 1) { return v += p10[i] * k; }\n    ll addtop(ll i, ll k = 1) { return v += p10[keta(v) - i - 1] * k; }\n    ll dec(ll i, ll k = 1) { return v -= p10[i] * k; }\n    ll dectop(ll i, ll k = 1) { return v -= p10[keta(v) - i - 1] * k; }\n#define op(t, o)template<class T> t operator o(T r){return v o r;}\n    op(ll, +=);    op(ll, -=);    op(ll, *=);    op(ll, /=);    op(ll, %=);    op(ll, +);    op(ll, -);    op(ll, *);    op(ll, /);    op(ll, %);    op(bool, ==);    op(bool, !=);    op(bool, <);    op(bool, <=);    op(bool, >);    op(bool, >=);\n#undef op\n    template<class T>  ll operator<<=(T r) { return v *= p10[r]; }\n    template<class T>  ll operator<<(T r) { return v * p10[r]; }\n    template<class T>  ll operator>>=(T r) { return v /= p10[r]; }\n    template<class T>  ll operator>>(T r) { return v / p10[r]; }\n};\nll mask10(ll v) { return p10[v] - 1; }\n//変換系\ntemplate<class T> auto keys(T a) {    vector<decltype((a.begin())->fi)> res;    for (auto &&k :a)res.push_back(k.fi);    return res;}\ntemplate<class T> auto values(T a) {    vector<decltype((a.begin())->se)> res;    for (auto &&k :a)res.push_back(k.se);    return res;}\ntemplate<class T, class U>  bool chma(T &a, const U &b) {    if (a < b) {        a = b;        return true;    }    return false;}\ntemplate<class U>  bool chma(const U &b) { return chma(ma, b); }\ntemplate<class T, class U>  bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        return true;    }    return false;}\ntemplate<class U>  bool chmi(const U &b) { return chmi(mi, b); }\ntemplate<class T>  T min(T a, signed b) { return a < b ? a : b; }\ntemplate<class T>  T max(T a, signed b) { return a < b ? b : a; }\ntemplate<class T>  T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T>  T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T>  T min(vector<T>& a) { return *min_element(all(a)); }\ntemplate<class T>  T mini(vector<T>& a) { return min_element(all(a)) - a.begin(); }\ntemplate<class T>  T min(vector<T>& a, ll n) { return *min_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T>  T min(vector<T>& a, ll s, ll n) { return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T>  T max(vector<T>& a) { return *max_element(all(a)); }\ntemplate<class T,class U>  T max(vector<T>& a,vector<U>& b) { return max(*max_element(all(a)),*max_element(all(b))); }\ntemplate<class T>  T maxi(vector<T>& a) { return max_element(all(a)) - a.begin(); }\ntemplate<class T>  T max(vector<T>& a, ll n) { return *max_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T>  T max(vector<T>& a, ll s, ll n) { return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<typename A, size_t N>  A max(A (&a)[N]) {    A res = a[0];    rep(i, N)res = max(res, a[i]);    return res;}template<typename A, size_t N, size_t O>  A max(A (&a)[N][O]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P>  A max(A (&a)[N][O][P]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q>  A max(A (&a)[N][O][P][Q], const T &v) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R>  A max(A (&a)[N][O][P][Q][R]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S>  A max(A (&a)[N][O][P][Q][R][S]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}\ntemplate<typename A, size_t N>  A min(A (&a)[N]) {    A res = a[0];    rep(i, N)res = min(res, a[i]);    return res;}template<typename A, size_t N, size_t O>  A min(A (&a)[N][O]) {    A res = min(a[0]);    rep(i, N)res = min(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P>  A min(A (&a)[N][O][P]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q>  A min(A (&a)[N][O][P][Q], const T &v) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R>  A min(A (&a)[N][O][P][Q][R]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S>  A min(A (&a)[N][O][P][Q][R][S]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}\ntemplate<class T> T sum(vector<T> &v, ll s = 0, ll t = inf) {    T ret = 0;    rep(i, s, min(sz(v), t))ret += v[i];    return ret;}template<class T> T sum(vector<vector<T> > &v) {    T ret = 0;    rep(i, sz(v))ret += sum(v[i]);    return ret;}template<class T> T sum(vector<vector<vector<T> > > &v) {    T ret = 0;    rep(i, sz(v))ret += sum(v[i]);    return ret;}template<class T> T sum(vector<vector<vector<vector<T> > > > &v) {    T ret = 0;    rep(i, sz(v))ret += sum(v[i]);    return ret;}template<class T> T sum(vector<vector<vector<vector<vector<T> > > > > &v) {    T ret = 0;    rep(i, sz(v))ret += sum(v[i]);    return ret;}template<class T> auto sum(priority_queue<T, vector<T>, greater<T> > &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}template<class T> auto sum(priority_queue<T> &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}\n//template<class T, class U, class... W>  auto sumn(vector<T> &v, U head, W... tail) {    auto ret = sum(v[0], tail...);    rep(i, 1, min(sz(v), head))ret += sum(v[i], tail...);    return ret;}\nvoid clear(PQ &q) { q = PQ(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(ll size) {    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));    return body + size;}\ntemplate<class T> T *negarr2(ll h, ll w) {    double **dummy1 = new double *[2 * h + 1];    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];    dummy1[0] = dummy2 + w;    for (ll i = 1; i <= 2 * h + 1; ++i) { dummy1[i] = dummy1[i - 1] + 2 * w + 1; }    double **a = dummy1 + h;    return a;}\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\n//kと同じものの数\ntemplate<class T, class U> vi imo(vector<T> &a, U k) {vector<T> ret = a;rep(i, sz(ret))ret[i] = a[i] == k;rep(i, sz(ret) - 1)ret[i + 1] += ret[i];return ret;}\ntemplate<class T> vector<T> imox(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] ^= ret[i];    return ret;}\n//漸化的に最小を持つ\ntemplate<class T> vector<T> imi(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chmi(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> struct ruiC {    const vector<T> rui;    ruiC(vector<T> &ru) : rui(ru) {}    T operator()(ll l, ll r) {        if (l > r) {            cerr<<\"ruic \";deb(l, r);assert(0);        }        return rui[r] - rui[l];    }    T operator[](ll i) { return rui[i]; }    T back() { return rui.back(); }    ll size() { return rui.size(); }};\ntemplate<class T> struct rruic {    const T *rrui;    rruic(T *ru) : rrui(ru) {}     T operator()(ll l, ll r) {        assert(l >= r);        return rrui[r] - rrui[l];    }     T operator[](ll i) { return rrui[i]; }};\ntemplate<class T> vector<T> ruiv(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    return ret;}\ntemplate<class T> ruiC<T> ruic(vector<T> &a) {    vector<T> ret = ruiv(a);    return ruiC<T>(ret);}\nvector<ll> ruiv(string &a) {    if (sz(a) == 0)return vi(1);    ll dec = ('0' <= a[0] && a[0] <= '9') ? '0' : 0;    vector<ll> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i] - dec;    return ret;}\nruiC<ll> ruic(string &a) {    vector<ll> ret = ruiv(a);    return ruiC<ll>(ret);}\n//kと同じものの数\ntemplate<class T, class U> vi ruiv(T &a, U k) {    vi ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + (a[i] == k);    return ret;}\ntemplate<class T, class U> ruiC<ll> ruic(T &a, U k) {    vi ret = ruiv(a, k);    return ruiC<ll>(ret);}\n//xor\ntemplate<class T> vector<T> ruix(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];    return ret;}\ntemplate<class T> vector<T> ruim(vector<T> &a) {    vector<T> res(a.size() + 1, 1);    rep(i, a.size())res[i + 1] = res[i] * a[i];    return res;}\n//漸化的に最小を1indexで持つ\ntemplate<class T> vector<T> ruimi(vector<T> &a) {    ll n = sz(a);    vector<T> ret(n + 1);    rep(i, 1, n) {        ret[i] = a[i - 1];        chmi(ret[i + 1], ret[i]);    }    return ret;}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> rruic<T> rrui(vector<T> &a) {    ll len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    rer(i, len - 1)res[i - 1] = res[i] + a[i];    return rruic<T>(res);}\n//掛け算\ntemplate<class T> T *rruim(vector<T> &a) {    ll len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    res[len - 1] = 1;    rer(i, len - 1)res[i - 1] = res[i] * a[i];    return res;}\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void inc(vector<T> &a, U v = 1) { for (auto &u:a)inc(u, v); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class U> void dec(string &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T> void dec(vector<T> &a) { for (auto &u :a)dec(u, 1); }\nbool ins(ll h, ll w, ll H, ll W) { return h >= 0 && w >= 0 && h < H && w < W; }\nbool ins(ll l, ll v, ll r) { return l <= v && v < r; }\ntemplate<class T> bool ins(vector<T> &a, ll i, ll j = 0) { return ins(0, i, sz(a)) && ins(0, j, sz(a)); }\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {    vector<T> ret = a;    fora(v, ret)v = u(v);    return ret;}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\ntemplate<class F> ll goldd_l(ll left, ll right, F calc) {    double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    ll minScore = MAX(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (minScore > score) {            minScore = score;            resIndex = i;        }    }    return resIndex;}\ntemplate<class F> ll goldt_l(ll left, ll right, F calc) {        double GRATIO = 1.6180339887498948482045868343656;        ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));        ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));        ll fl = calc(lm);        ll fr = calc(rm);        while (right - left > 10) {            if (fl > fr) {                right = rm;                rm = lm;                fr = fl;                lm = left + (ll) ((right - left) / (GRATIO + 1.0));                fl = calc(lm);            } else {                left = lm;                lm = rm;                fl = fr;                rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));                fr = calc(rm);            }        }    if (left > right) {        ll l = left;        left = right;        right = l;    }    ll maxScore = MIN(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (maxScore < score) {            maxScore = score;            resIndex = i;        }    }    return resIndex;}\n/*loopは200にすればおそらく大丈夫 余裕なら300に*/\ntemplate<class F> dou goldd_d(dou left, dou right, F calc, ll loop = 140) {    dou GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    /*200にすればおそらく大丈夫*/    /*余裕なら300に*/    ll k = 141;    loop++;    while (--loop) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\ntemplate<class F> dou goldt_d(dou left, dou right, F calc, ll loop = 140) {    double GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    loop++;    while (--loop) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\n//l ~ rを複数の区間に分割し、極致を与えるiを返す time-20 msまで探索\ntemplate<class F> ll goldd_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll mini = 0, minv = MAX(ll);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldd_l(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> ll goldt_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll maxi = 0, maxv = MIN(ll);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldt_l(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class F> dou goldd_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を持つ*/    auto lim = milliseconds(time - 20);    dou mini = 0, minv = MAX(dou);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldd_d(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> dou goldt_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を残している*/    auto lim = milliseconds(time - 20);    dou maxi = 0, maxv = MIN(dou);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldt_d(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class T> T min(vector<vector<T >> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, *min_element(all(a[i])));    return res;}\ntemplate<class T> T max(vector<vector<T >> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, *max_element(all(a[i])));    return res;}\nconstexpr bool bget(ll m, ll keta) { return (m >> keta) & 1; }\nll bget(ll m, ll keta, ll sinsuu) {    m /= (ll) pow(sinsuu, keta);    return m % sinsuu;}\nll bit(ll n) { return (1LL << (n)); }\nll bit(ll n, ll sinsuu) { return (ll) pow(sinsuu, n); }\nll mask(ll n) { return (1ll << n) - 1; }\n#define bcou __builtin_popcountll\n//最下位ビット\nll lbit(ll n) { return n & -n; }\n//最上位ビット\nll hbit(ll n) {    n |= (n >> 1);    n |= (n >> 2);    n |= (n >> 4);    n |= (n >> 8);    n |= (n >> 16);    n |= (n >> 32);    return n - (n >> 1);}\nll hbitk(ll n) {    ll k = 0;    rer(i, 5) {        ll a = k + (1ll << i);        ll b = 1ll << a;        if (b <= n)k += 1ll << i;    }    return k;}\n//初期化は0を渡す\nll nextComb(ll &mask, ll n, ll r) {    if (!mask)return mask = (1LL << r) - 1;    ll x = mask & -mask; /*最下位の1*/    ll y = mask + x; /*連続した下の1を繰り上がらせる*/    ll res = ((mask & ~y) / x >> 1) | y;    if (bget(res, n))return mask = 0; else return mask = res;}\n//n桁以下でビットがr個立っているもののvectorを返す\nvi bitCombList(ll n, ll r) {    vi res;    ll m = 0;    while (nextComb(m, n, r)) { res.push_back(m); }    return res;}\nchar itoal(ll i) { return 'a' + i; }\nchar itoaL(ll i) { return 'A' + i; }\nll altoi(char c) {    if ('A' <= c && c <= 'Z')return c - 'A';    return c - 'a';}\nll ctoi(char c) { return c - '0'; }\nchar itoc(ll i) { return i + '0'; }\nll vtoi(vi &v) {    ll res = 0;    if (sz(v) > 18) {        debugline(\"vtoi\");        deb(sz(v));        ole();    }    rep(i, sz(v)) {        res *= 10;        res += v[i];    }    return res;}\nvi itov(ll i) {    vi res;    while (i) {        res.push_back(i % 10);        i /= 10;    }    rev(res);    return res;}\nvi stov(string &a) {    ll n = sz(a);    vi ret(n);    rep(i, n) { ret[i] = a[i] - '0'; }    return ret;}\n//基準を満たさないものは0になる\nvi stov(string &a, char one) {    ll n = sz(a);    vi ret(n);    rep(i, n)ret[i] = a[i] == one;    return ret;}\nvector<vector<ll>> ctoi(vector<vector<char>> s, char c) {    ll n = sz(s), m = sz(s[0]);    vector<vector<ll>> res(n, vector<ll>(m));    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;    return res;}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n//[i] := i番として圧縮されたものを返す\nvi compress(vi &a) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, umap<ll, ll> &map) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) {        ll v = a[i];        a[i] = lower_bound(all(b), a[i]) - b.begin();        map[v] = a[i];    }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r, vi &s) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    fora(v, s)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    for (ll i = 0; i < sz(s); ++i) r[i] = lower_bound(all(b), s[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(V<vi> &a) {    vi b;    fora(vv, a)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vv, a)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vector<vi >> &a) {    vi b;    fora(vvv, a)fora(vv, vvv)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vvv, a)fora(vv, vvv)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvoid compress(ll a[], ll len) {    vi b;    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define lowerBound(a, v) (*lower_bound(all(a),v))\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define upperBound(a, v) (*upper_bound(all(a),v))\ntemplate<class T> void fin(T s) { cout << s << endl, exit(0); }\n\n//便利 数学 math\nll mod(ll a, ll m) { return (a % m + m) % m; }\nll pow(ll a) { return a * a; };\nll fact(ll v) { return v <= 1 ? 1 : v * fact(v - 1); }\n\nll comi(ll n, ll r) {    assert(n < 100);    static vvi(pas, 100, 100);    if (pas[0][0])return pas[n][r];    pas[0][0] = 1;    rep(i, 1, 100) {        pas[i][0] = 1;        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];    }    return pas[n][r];}\ndouble comd(ll n, ll r) {    assert(n < 2020);    static vvd(comb, 2020, 2020);    if (comb[0][0] == 0) {        comb[0][0] = 1;        rep(i, 2000) {            comb[i + 1][0] = 1;            rep(j, 1, i + 2) {                comb[i + 1][j] = comb[i][j] + comb[i][j - 1];            }        }    }    return comb[n][r];}\nll gcd(ll a, ll b) {while (b) a %= b, swap(a, b);return abs(a);}\nll gcd(vi b) {ll res = b[0];rep(i, 1, sz(b))res = gcd(b[i], res);return res;}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll lcm(vi a) {ll res = a[0];rep(i, 1, sz(a))res = lcm(a[i], res);return res;}\nll ceil(ll a, ll b) {if (b == 0) {debugline(\"ceil\");deb(a, b);ole();return -1;} else if (a < 0) { return 0; } else { return (a + b - 1) / b; }}\nll lower_remi__bx_a(ll kei, ll rem, ll x) {if (rem >= x) return 0;return (x - rem + kei - 1) / kei;}\nll lower_remv__bx_a(ll kei, ll rem, ll x) {if (rem >= x) return rem;return (x - rem + kei - 1) / kei * kei + rem;}\nll upper_remi__bx_a(ll kei, ll rem, ll x) {if (rem > x) return 0;return (x - rem + kei) / kei;}\nll upper_remv__bx_a(ll kei, ll rem, ll x) {if (rem > x) return rem;return (x - rem + kei) / kei * kei + rem;}\n//v * v >= aとなる最小のvを返す\nll sqrt(ll a) {if (a < 0) {debugline(\"sqrt\");deb(a);ole();}ll res = (ll) std::sqrt(a);while (res * res < a)++res;return res;}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return ((1 + t) * t) >> 1; }\nll sig(ll s, ll t) { return ((s + t) * (t - s + 1)) >> 1; }\n\n\n//幾何 Pをcomplexとして扱う\ntemplate<class T, class U> bool eq(T a, U b) { return fabs(a - b) < eps; }\ndou atan2(pd a) { return atan2(a.se, a.fi); }\ndou angle(pd f, pd t) { return atan2(t.se - f.se, t.fi - f.fi); }\ndou distance(pd a, pd b) { return hypot(a.fi - b.fi, a.se - b.se); }\n//bを中心とするabcのtheta aからcにかけて時計回り\ndou angle(pd a, pd b, pd c) {    dou ax = a.fi - b.fi;    dou ay = a.se - b.se;    dou cx = c.fi - b.fi;    dou cy = c.se - b.se;    double ret = atan2(cy, cx) - atan2(ay, ax);    if (ret < 0) ret += 2 * PI;    return ret;}\n\ndou dot(pd a, pd b) { return a.fi * b.fi + a.se + b.se; }\ndou cro(pd a, pd b) { return a.fi * b.se - a.se + b.fi; }\n\n//機能拡張\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) { a.push(v); }template<class T, class U> void operator+=(deque<T> &a, U v) { a.push_back(v); }template<class T> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, vector<T> &v) {    fora(d, v)a.push(d);    return a;}template<class T, class U> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {    a.push(v);    return a;}template<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {    a.push(v);    return a;}template<class T> set<T> &operator+=(set<T> &a, vector<T> v) {    fora(d, v)a.insert(d);    return a;}template<class T, class U> auto operator+=(set<T> &a, U v) { return    a.insert(v);}template<class T, class U> auto operator-=(set<T> &a, U v) { return    a.erase(v);}template<class T, class U> auto operator+=(mset<T> &a, U v) { return a.insert(v); }template<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {    a.insert(v);    return a;}template<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {    a.push_back(v);    return a;}template<class T, class U> vector<T> operator+(const vector<T> &a, U v) {    vector<T> ret = a;    ret += v;    return ret;}template<class T, class U> vector<T> operator+(U v, const vector<T> &a) {    vector<T> ret = a;    ret.insert(ret.begin(), v);    return ret;}template<class T> vector<T> operator+(vector<T> a, vector<T> b) {    vector<T> ret;    ret = a;    fora(v, b)ret += v;    return ret;}template<class T> vector<T> &operator+=(vector<T> &a, vector<T> &b) {    fora(v, b)a += v;    return a;}template<class T> vector<T> &operator-=(vector<T> &a, vector<T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-=\");        deb(a);        deb(b);        exit(0);    }    rep(i, sz(a))a[i] -= b[i];    return a;}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector<T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-\");        deb(a);        deb(b);        ole();    }    vector<T> res(sz(a));    rep(i, sz(a))res[i] = a[i] - b[i];    return res;}\ntemplate<class T, class U> vector<T> operator*(vector<T> &a, U b) {    vector<T> ret;    fora(v, a)ret += v * b;    return ret;}\ntemplate<class T, class U> vector<T> operator/(vector<T> &a, U b) {    vector<T> ret;    fora(v, a)ret += v / b;    return ret;}\ntemplate<class T, class U> vector<T> operator*=(vector<T> &a, U b) {    fora(v, a)v *= b;    return a;}\ntemplate<class T, class U> vector<T> operator/=(vector<T> &a, U b) {    fora(v, a)v /= b;    return a;}\ntemplate<typename T> void erase(vector<T> &v, unsigned ll i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned ll s, unsigned ll e) { v.erase(v.begin() + s, v.begin() + e); }\ntemplate<class T, class U> void erase(map<T, U> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<class T> void erase(set<T> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<typename T> void erasen(vector<T> &v, unsigned ll s, unsigned ll n) { v.erase(v.begin() + s, v.begin() + s + n); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, vector<T> list) { for (auto &&va:list)v.insert(v.begin() + i++, va); }\ntemplate<typename T> void insert(set<T> &v, vector<T> list) { for (auto &&va :list)v.insert(va); }\nvector<string> split(const string a, const char deli) {    string b = a + deli;    ll l = 0, r = 0, n = b.size();    vector<string> res;    rep(i, n) {        if (b[i] == deli) {            r = i;            if (l < r)res.push_back(b.substr(l, r - l));            l = i + 1;        }    }    return res;}\nvector<string> split(const string a, const string deli) {    vector<string> res;    ll kn = sz(deli);    std::string::size_type Pos(a.find(deli));    ll l = 0;    while (Pos != std::string::npos) {        if (Pos - l)res.push_back(a.substr(l, Pos - l));        l = Pos + kn;        Pos = a.find(deli, Pos + kn);    }    if (sz(a) - l)res.push_back(a.substr(l, sz(a) - l));    return res;}\nvoid yn(bool a) { if (a)cout << \"yes\" << endl; else cout << \"no\" << endl; }\nvoid Yn(bool a) { if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl; }\nvoid YN(bool a) { if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl; }\nvoid fyn(bool a) {    if (a)cout << \"yes\" << endl; else cout << \"no\" << endl;    exit(0);}\nvoid fYn(bool a) {    if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl;    exit(0);}\nvoid fYN(bool a) {    if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl;    exit(0);}\nvoid Possible(bool a) {    if (a)cout << \"Possible\" << endl; else cout << \"Impossible\" << endl;    exit(0);}\nvoid POSSIBLE(bool a) {    if (a)cout << \"POSSIBLE\" << endl; else cout << \"IMPOSSIBLE\" << endl;    exit(0);}\n//@formatter:off\ntemplate<typename T> T minv(T a, T m);\ntemplate<typename T> T minv(T a);\n\ntemplate<typename T>\nclass Modular {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;    constexpr Modular() : value() {}    template<typename U>    Modular(const U &x) {        value = normalize(x);    }    template<typename U>    static Type normalize(const U &x) {        Type v;        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);        else v = static_cast<Type>(x % mod());        if (v < 0) v += mod();        return v;    }    const Type &operator()() const { return value; }    template<typename U>explicit operator U() const { return static_cast<U>(value); }    constexpr static Type mod() { return T::value; }    Modular &operator+=(const Modular &other) {        if ((value += other.value) >= mod()) value -= mod();        return *this;    }    Modular &operator-=(const Modular &other) {        if ((value -= other.value) < 0) value += mod();        return *this;    }    template<typename U> Modular &operator+=(const U &other) { return *this += Modular(other); }    template<typename U> Modular &operator-=(const U &other) { return *this -= Modular(other); }    Modular &operator++() { return *this += 1; }    Modular &operator--() { return *this -= 1; }    Modular operator++(signed) {        Modular result(*this);        *this += 1;        return result;    }    Modular operator--(signed) {        Modular result(*this);        *this -= 1;        return result;    }    Modular operator-() const { return Modular(-value); }\n    template<typename U = T>typename enable_if<is_same<typename Modular<U>::Type, signed>::value, Modular>::type &operator*=(const Modular &rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;asm(\"divl %4; \\n\\t\": \"=a\" (d), \"=d\" (m): \"d\" (xh), \"a\" (xl), \"r\" (mod()));value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template<typename U = T>    typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &operator*=(const Modular &rhs) {        int64_t q = static_cast<int64_t>(static_cast<double>(value) * rhs.value / mod());        value = normalize(value * rhs.value - q * mod());        return *this;    }    template<typename U = T>    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {        value = normalize(value * rhs.value);        return *this;    }    Modular &operator/=(const Modular &other) { return *this *= Modular(minv(other.value)); }    template<typename U> friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);    template<typename U> friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);    template<typename U> friend std::istream &operator>>(std::istream &stream, Modular<U> &number);    operator int() { return value; }private:    Type value;\n};\ntemplate<typename T> bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }template<typename T, typename U> bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }template<typename T, typename U> bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }template<typename T> bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }template<typename T, typename U> bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }template<typename T, typename U> bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }template<typename T> bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }template<typename T> Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }template<typename T, typename U> Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }template<typename T, typename U> Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }template<typename T> Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }template<typename T, typename U> Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }template<typename T, typename U> Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }template<typename T> Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }template<typename T, typename U> Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }template<typename T, typename U> Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }template<typename T> Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }template<typename T, typename U> Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }template<typename T, typename U> Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\nconstexpr signed MOD =\n//        998244353;\n1e9 + 7;//MOD\nusing mint = Modular<std::integral_constant<decay<decltype(MOD)>::type, MOD>>;\nconstexpr int mint_len = 1400001;\nvi fac, finv, inv;\nvi p2;\nmint com(int n, int r) {    if (r < 0 || r > n) return 0;    return mint(finv[r] * fac[n] % MOD * finv[n - r]);}\nmint pom(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;    return mint(fac[n] * finv[n - 1]);}\nmint npr(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;    return mint(fac[n] * finv[n - r]);}\nint nprin(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;    return fac[n] * finv[n - r] % MOD;}\nint icom(int n, int r) {    const int NUM_ = 1400001;    static ll fac[NUM_ + 1], finv[NUM_ + 1], inv[NUM_ + 1];    if (fac[0] == 0) {        inv[1] = fac[0] = finv[0] = 1;        for (int i = 2; i <= NUM_; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;        for (int i = 1; i <= NUM_; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;    }    if (r < 0 || r > n) return 0;    return ((finv[r] * fac[n] % MOD) * finv[n - r]) % MOD;}\n#define ncr com\n#define ncri icom\n//n個の場所にr個の物を置く\nmint nhr(int n, int r) { return com(n + r - 1, r); }\nmint hom(int n, int r) { return com(n + r - 1, r); }\nint nhri(int n, int r) { return icom(n + r - 1, r); }\ntemplate<typename T> T minv(T a, T m) {    T u = 0, v = 1;    while (a != 0) {        T t = m / a;        m -= t * a;        swap(a, m);        u -= t * v;        swap(u, v);    }    assert(m == 1);    return u;}\ntemplate<typename T> T minv(T a) {    if (a < mint_len)return inv[a];    T u = 0, v = 1;    T m = MOD;    while (a != 0) {        T t = m / a;        m -= t * a;        swap(a, m);        u -= t * v;        swap(u, v);    }    assert(m == 1);    return u;}\ntemplate<typename T, typename U> Modular<T> mpow(const Modular<T> &a, const U &b) {    assert(b >= 0);    int x = a(), res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= MOD;        (x *= x) %= MOD;        p >>= 1;    }    return res;}\ntemplate<typename T, typename U, typename V> mint mpow(const T a, const U b, const V m = MOD) {    assert(b >= 0);    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= m;        (x *= x) %= m;        p >>= 1;    }    return res;}\ntemplate<typename T, typename U> mint mpow(const T a, const U b) {    assert(b >= 0);    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= MOD;        (x *= x) %= MOD;        p >>= 1;    }    return res;}\ntemplate<typename T, typename U, typename V> int mpowi(const T &a, const U &b, const V &m = MOD) {    assert(b >= 0);    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= m;        (x *= x) %= m;        p >>= 1;    }    return res;}\ntemplate<typename T> string to_string(const Modular<T> &number) {    return to_string(number());}\nstring yuri(const mint &a) {    stringstream st;    rep(i, 300) {rep(j, 300) {if ((mint) i / j == a) {st << i << \" / \" << j;return st.str();}}}    rep(i, 1000) {rep(j, 1000) {if ((mint) i / j == a) {st << i << \" / \" << j;return st.str();}}}    return st.str();}\ntemplate<typename T> std::ostream &operator<<(std::ostream &stream, const Modular<T> &number) {stream << number();\n#ifdef _DEBUG\n//    stream << \" -> \" << yuri(number);\n#endif\n    return stream;\n}\n//@formatter:off\ntemplate<typename T> std::istream &operator>>(std::istream &stream, Modular<T> &number) {    typename common_type<typename Modular<T>::Type, int64_t>::type x;    stream >> x;    number.value = Modular<T>::normalize(x);    return stream;}\nusing PM = pair<mint, mint>;\nusing vm = vector<mint>;\nusing mapm = map<int, mint>;\nusing umapm = umap<int, mint>;\n#define vvm(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(mint,__VA_ARGS__)\n#define vnm(name, ...) auto name = make_v<mint>(__VA_ARGS__)\n\nstruct setmod{\n    setmod() {\n//    p2.resize(mint_len);p2[0] = 1; for (int i = 1; i < mint_len; ++i) p2[i] = p2[i - 1] * 2 % MOD;\n        fac.resize(mint_len);    finv.resize(mint_len);    inv.resize(mint_len);    inv[1] = fac[0] = finv[0] = 1;    for (int i = 2; i < mint_len; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;    for (int i = 1; i < mint_len; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}setmodv;\n//@formatter:on\n//nhr n個の場所にr個の物を分ける\n\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} initonv;//@formatter:on\n\n//gra mll pr\n//上下左右\nconst string udlr = \"udlr\";\nstring UDLR = \"UDLR\";//x4と連動 UDLR.find('U') := x4[0]\n//右、上が正\nconstexpr ll y4[] = {1, -1, 0, 0};\nconstexpr ll x4[] = {0, 0, -1, 1};\nconstexpr ll y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n\nll n, m, k, d, H, W, x, y, z, q;\nll cou;\nvi t, a, b, c;\n//vvi (s, 0, 0);\nvvc (ba, 0, 0);\nvp p;\nstr s;\nstruct pbds_sum {\n    //@formatter:off\n    template<typename T = int> class BIT {\n    public:\n        int n;        vector<T> dat;        BIT(int n) : n(n) { dat.assign(n, 0); }        T sum(int k) {            if (k >= n) k = n - 1;            T ret = 0;            for (int x = k - 1; x >= 0; x = (x & (x + 1)) - 1) { ret += dat[x]; }            return ret;        }        T sum(int l, int r) { return sum(r) - sum(l); }        T get(int l, int r) { return sum(r) - sum(l); }        T get(int k) { return sum(k); }        T operator[](int k) {            assert(0 <= k && k < n);            return sum(k + 1) - sum(k);        }        T operator()(int k) { return sum(k); }        T operator()(int l, int r) { return sum(l, r); }        void add(int k, T val = 1) { for (int x = k; x < n; x |= x + 1)dat[x] += val; }        void update(int k, T val = 0) { add(k, -operator[](k) + val); }        void del(int k) { update(k, 0); }        void clear() { fill(dat, 0); }        void debu() {\n#ifdef _DEBUG\n            vi res;            rep(i, min(10ll, n)) { res.push_back(operator[](i)); }            deb(res);\n#endif\n        }\n        int lower_bound(int w) {            if (w <= 0) return -1;            int x = 0;            int k = 1;            while ((k << 1) <= n) k <<= 1;            for (; k > 0; k >>= 1) {                if (x + k <= n && dat[x + k - 1] < w) {                    w -= dat[x + k - 1];                    x += k;                }            }            return x;        }\n    };\n    BIT<int> bco, bsu;\n    umapi v_i;\n    vi i_v;\n    int count = 0;\n    //クエリの順番が分かってる場合の高速化はとりあえずしない(十分高速なため)\n    //クエリの順番が入れ替わってもいいようにする\n    pbds_sum(vi &a) : bco(sz(a) + 3), bsu(sz(a) + 3) {        vi b = a;        b.push_back(linf + 100);        i_v = compress(b);        rep(i, sz(a)) { v_i[a[i]] = b[i]; }    }\n    pbds_sum(vi &a, vi &b) : bco(sz(a) + sz(b) + 3), bsu(sz(a) + sz(b) + 3) {        vi c = a;        vi d = b;        c.push_back(linf + 100);        d.push_back(linf + 100);        i_v = compress(c, d);        rep(i, sz(a)) {            v_i[a[i]] = c[i];            v_i[b[i]] = d[i];        }    }\n    pbds_sum(vi &a, vi &b, vi &c) : bco(sz(a) + sz(b) + sz(c) + 3), bsu(sz(a) + sz(b) + sz(c) + 3) {        vi d = a;        vi e = b;        vi f = c;        d.push_back(linf + 100);        e.push_back(linf + 100);        f.push_back(linf + 100);        i_v = compress(d, e, f);        rep(i, sz(a)) {            v_i[a[i]] = d[i];            v_i[b[i]] = e[i];            v_i[c[i]] = f[i];        }    }\n    void add(int v, int c = 1) {count += c;        int ind = v_i[v];        bco.add(ind, c);        bsu.add(ind, v * c);    }\n    void operator+=(int v){int c=1;        count += c;        int ind = v_i[v];        bco.add(ind, c);        bsu.add(ind, v * c);    }\n    //開区間\n    int sum() {return bsu.sum(inf);    }\n    int sum(int rv) {        int i = (std::lower_bound(all(i_v), rv) - i_v.begin());        return bsu.sum(i);    }\n    //半開区間 l rは存在しない値でもいい\n    int sum(int l, int r) { return sum(r) - sum(l); }\n    //クエリ候補全ての中でのi\n    int sum_it(int li, int ri) {return bsu.sum(ri) - bsu.sum(li);}\n    //[l番目からr)番目の合計(種類数ではなく重複込みの番号)\n    //r個の合計\n    int sum_order(int r) {        int rti = bco.lower_bound(r + 1);        int res = bsu.sum(rti);        if (rti != bco.n) {            int l = bco.sum(rti);            res += (r - l) * i_v[rti];        }        return res;    }\n    //右からr個の合計\n    int sum_order_r(int r) {        int a = bsu.sum(0, inf);        int b = sum_order(count - r);        return a - b;    }\n    /*@formatter:off*/\n    int sum_order(int l,int r){return sum_order(r)-sum_order(l);}\n    int cou(int rv) {int i = (std::lower_bound(all(i_v), rv) - i_v.begin());return bco.sum(i);}\n    //半開区間 l rは存在しない値でもいい\n    int cou(int l, int r) { return cou(r) - cou(l); }\n    int cou_it(int ri) {        return bco.sum(ri);    }\n    int cou_it(int li, int ri) {        return bco.sum(ri) - bco.sum(li);    }\n    //k番目の要素を返す\n    int find_by_order(int k) {        int i = bco.lower_bound(k + 1);        if (i >= sz(i_v)) {            cerr << \"find_by_order(\" << k << \") k >=\" << sz(i_v) << endl;            exit(0);        }        return i_v[i];    }\n    //vは何番目に入るか\n    int order_of_key(int v) {        v = *std::lower_bound(all(i_v), v);        int i = v_i[v];        return bco.sum(i);    }\n    //中央値を返す (左寄り)\n    int mid() { return find_by_order((count - 1) >> 1); }\n    int mid(int lv, int rv) {        int lcou = cou(lv);        int rcou = cou(rv);        int wantk = lcou + ((rcou - lcou - 1) >> 1);        return find_by_order(wantk);    }\n    int mid_it(int li, int ri) {        int lcou = bco.sum(li );        int rcou = bco.sum(ri );        int wantk = lcou + ((rcou - lcou - 1) >> 1);        return find_by_order(wantk);    }\n    int mid_it(int ri) {        return mid_it(0, ri);    }\n    //全要素との 最小の差の和をかえす (全要素の中央値との差の和)\n    int min_dis() {        int mv = mid();        int mi = v_i[mv];        int lcou = bco.sum(mi);        int rcou = bco.sum(mi + 1, linf);        int lsum = mv * lcou - bsu.sum(mi);        int rsum = bsu.sum(mi + 1, linf) - mv * rcou;        return lsum + rsum;    }\n    int min_dis(int lv, int rv) {        int li = (std::lower_bound(all(i_v), lv) - i_v.begin());        int ri = (std::lower_bound(all(i_v), rv) - i_v.begin());        int mv = mid_it(li, ri);        int mi = v_i[mv];        int lcou = cou_it(li, mi);        int rcou = cou_it(mi, ri);        return mv * lcou - sum_it(li, mi) + sum_it(mi, ri) - mv * rcou;    }\n    int min_dis_i(int li, int ri) {        int mv = mid_it(li, ri);        int mi = v_i[mv];        int lcou = cou_it(li, mi);        int rcou = cou_it(mi, ri);        return mv * lcou - sum_it(li, mi) + sum_it(mi, ri) - mv * rcou;    }\n    //vをc個消す\n    void erase(int v, int c = 1) {        int ind = v_i[v];        if(bco[ind] < c){            if(count ==0){                cerr<<\"all is empty. count == 0\"<< endl;            }            assert(bco[ind] < c);        }        count -= c;        bco.add(ind, -c);        bsu.add(ind, v * -c);    }\n    void operator-=(int v){erase(v);}\n    int lower_bound(int v) {        v = *std::lower_bound(all(i_v), v);        int i = v_i[v];        int needc = bco.sum(i) + 1;        i = bco.lower_bound(needc);        return i_v[i];    }\n    int upper_bound(int v) { return lower_bound(v + 1); }\n    void debu(){        bsu.debu();        bco.debu();        cerr<<\"\"<<endl;    }\n    //@formatter:on\n};\n\n//固定された要素に使う場合は\n//pbds_con\n//itは圧縮後のインデックスであり\n//自然に使おうとするとおかしくなるため\n\n\nvoid solve() {\n    in(n, q);\n    n *= 2;\n    na(a, n);\n    na(b, n);\n    \n    dna3(p, x, y, q);\n    vi c = a - b;\n    vi d = c + (x - y);\n    pbds_sum s(d);\n    int base = a[0] + a[n - 1];\n    rep(i, 1, n - 1) {\n        base += b[i];\n        s += c[i];\n    }\n    rep(i, q) {\n        int pp = p[i] - 1;\n        int xx = x[i];\n        int yy = y[i];\n        if (pp == 0 || pp == n - 1) {\n            base -= a[pp];\n            a[pp] = xx;\n            b[pp] = yy;\n            base += a[pp];\n        } else {\n            base -= b[pp];\n            s -= a[pp] - b[pp];\n            a[pp] = xx;\n            b[pp] = yy;\n            s += a[pp] - b[pp];\n            base += b[pp];\n        }\n        auto cal = [&](int k) {\n            return s.sum_order_r(k * 2);\n        };\n        int k = goldt_l(0, n / 2 - 1, cal);\n        cout <<base+ s.sum_order_r(k * 2) << endl;;\n    }\n\n}\nauto my(ll n, vi &a) {\n    return 0;\n}\nauto sister(ll n, vi &a) {\n    ll ret = 0;\n    return ret;\n}\n\nsigned main() {\n    solve();\n\n#define arg n,a\n#ifdef _DEBUG\n    bool bad = 0;\n    for (ll i = 0, ok = 1; i < k5 && ok; ++i) {\n        ll n = rand(1, 8);\n        vi a = ranv(n, 1, 10);\n        auto myres = my(arg);\n        auto res = sister(arg);\n        ok = myres == res;\n        if (!ok) {\n            out(arg);\n            cerr << \"AC : \" << res << endl;\n            cerr << \"MY  : \" << myres << endl;\n            bad = 1;\n            break;\n        }\n    }\n    if (!bad) {\n//        cout << \"完璧 : solveを書き直そう\" << endl;\n//        cout << \"     : そして、solve()を呼び出すのだ\" << endl;\n//        cout << \"     : cin>>n; na(a,n);も忘れるな\" << endl;\n    }\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nll n,q;\nll a[101010],b[101010];\n\nint main(){\n  cin>>n>>q;\n  n*=2;\n  rep(i,n)cin>>a[i];\n  rep(i,n)cin>>b[i];\n  vector<ll> v;\n  ll score=0;\n  if(q!=1)return 0;\n  ll p,pa,pb;\n  cin>>p>>pa>>pb;\n  p--;\n  a[p]=pa; b[p]=pb;\n  repl(i,1,n-1){\n    v.push_back(b[i]-a[i]);\n  }\n  sort(all(v));\n  rep(i,n)score+=a[i];\n  //dbg(score);\n  rep(i,v.size()-1){\n    if(v[i]+v[i+1]>0){\n      score+=v[i]+v[i+1];\n      i++;\n    }else break;\n  }\n  cout<<score<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr long double EPS = 1e-8;\n\nlong long int N, M, K, L, R, H, W;\n//int N, M, K, L, R, H, W;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tN <<= 1;\n\tvector<long long int>v(N);\n\tvector<long long int>w(N);\n\tfor (auto &i : v)cin >> i;\n\tfor (auto &i : w)cin >> i;\n\tlong long int ans = v.front() + v.back();\n\tset<pair<long long int, int>>in;\n\tset<pair<long long int, int>>out;\n\tlong long int insum = 0;\n\tvector<long long int>num(N);\n\tfor (int i = 1; i < N - 1; i++) {\n\t\tans += v[i];\n\t\tnum[i] = w[i] - v[i];\n\t\tif (v[i] < w[i]) {\n\t\t\tin.insert({ w[i] - v[i],i });\n\t\t\tans += w[i] - v[i];\n\t\t}\n\t\telse {\n\t\t\tout.insert({ v[i] - w[i],i });\n\t\t}\n\t}\n\twhile (in.size() && in.begin()->first < 0) {\n\t\tans += in.begin()->first;\n\t\tout.insert({ -in.begin()->first, in.begin()->second });\n\t\tin.erase(in.begin());\n\t}\n\twhile (out.size() && out.begin()->first < 0) {\n\t\tans -= out.begin()->first;\n\t\tin.insert({ -out.begin()->first, out.begin()->second });\n\t\tout.erase(out.begin());\n\t}\n\tif (in.size() & 1) {\n\t\tif (in.begin()->first > out.begin()->first) {\n\t\t\tin.insert({ -out.begin()->first,out.begin()->second });\n\t\t\tans += num[out.begin()->second];\n\t\t\tout.erase(out.begin());\n\t\t}\n\t\telse {\n\t\t\tout.insert({ -in.begin()->first,in.begin()->second });\n\t\t\tans -= num[in.begin()->second];\n\t\t\tin.erase(in.begin());\n\t\t}\n\t}\n\twhile (M--) {\n\t\tcin >> K >> L >> R;\n\t\tK--;\n\t\tans -= v[K];\n\t\tv[K] = L, w[K] = R;\n\t\tif (K == 0 || K == N - 1) {\n\t\t\tans += v[K];\n\t\t\tcontinue;\n\t\t}\n\t\tif (in.find({ num[K],K }) != in.end()) {\n\t\t\tans -= num[K];\n\t\t\tin.erase({ num[K],K });\n\t\t}\n\t\telse {\n\t\t\tout.erase({ -num[K],K });\n\t\t}\n\t\tnum[K] = w[K] - v[K];\n\t\tans += L;\n\t\tif (num[K] > 0) {\n\t\t\tin.insert({ num[K],K });\n\t\t\tans += num[K];\n\t\t}\n\t\telse {\n\t\t\tout.insert({ -num[K],K });\n\t\t}\n\t\twhile (in.size() && in.begin()->first < 0) {\n\t\t\tans += in.begin()->first;\n\t\t\tout.insert({ -in.begin()->first, in.begin()->second });\n\t\t\tin.erase(in.begin());\n\t\t}\n\t\twhile (out.size() && out.begin()->first < 0) {\n\t\t\tans -= out.begin()->first;\n\t\t\tin.insert({ -out.begin()->first, out.begin()->second });\n\t\t\tout.erase(out.begin());\n\t\t}\n\t\tif (in.size() & 1) {\n\t\t\tif (in.begin()->first > out.begin()->first) {\n\t\t\t\tin.insert({ -out.begin()->first,out.begin()->second });\n\t\t\t\tans += num[out.begin()->second];\n\t\t\t\tout.erase(out.begin());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tout.insert({ -in.begin()->first,in.begin()->second });\n\t\t\t\tans -= num[in.begin()->second];\n\t\t\t\tin.erase(in.begin());\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t\t//cout << in.size() << \" \" << out.size() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}\n}star;\n#define DEBUG if(0)\n#endif\n\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\n\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\n\nset<pair<LL, int>> pl, mi;\nLL sum = 0;\nLL a[212345];\nLL b[212345];\nvoid ins(int i) {\n\tLL x = b[i] - a[i];\n\tif (x >= 0) {\n\t\tpl.insert({ x,i });\n\t\tsum += x;\n\t}\n\telse mi.insert({ x,i });\n}\nvoid ers(int i){\n\tLL x = b[i] - a[i];\n\tif (x >= 0) {\n\t\tpl.erase({ x,i });\n\t\tsum -= x;\n\t}\n\telse mi.erase({ x,i });\n}\n\nint main() {\n\tint N, Q;\n\tcin >> N >> Q;\n\tN *= 2;\n\tfor (int i : range(N)) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i : range(N)) {\n\t\tcin >> b[i];\n\t}\n\tLL base = 0;\n\tfor (int i : range(N)) {\n\t\tbase += a[i];\n\t}\n\tfor (int i : range(1,N-1)) {\n\t\tLL x = b[i] - a[i];\n\t\tins(i);\n\t}\n\tfor (int _ : range(Q)) {\n\t\tint p; LL x, y;\n\t\tcin >> p >> x >> y;\n\t\tp--;\n\t\tbase -= a[p]; ers(p);\n\t\ta[p] = x;\n\t\tb[p] = y;\n\t\tbase += a[p]; ins(p);\n\t\tif (pl.size() % 2 == 0) {\n\t\t\tcout << base + sum << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << base + sum + max(mi.rbegin()->first, -pl.begin()->first)<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\n\nint main(){\n    int n,q;\n    cin>>n>>q;\n    n*=2;\n    ll a[n],b[n];\n    rep(i,n)cin>>a[i];\n    rep(i,n)cin>>b[i];\n    ll ans=a[0]+a[n-1];\n    int posi=0,zero=0;\n    multiset<ll> st;\n    rep(i,n-2){\n        ans+=max(a[i+1],b[i+1]);\n        if(a[i+1]>b[i+1])posi++;\n        if(a[i+1]==b[i+1])zero++;\n        st.insert(abs(a[i+1]-b[i+1]));\n    }\n    rep(i,q){\n        int p,x,y;\n        cin>>p>>x>>y;\n        p--;\n        if(p==0||p==n-1){\n            ans+=x-a[p];\n            a[p]=x;\n            cout<<ans<<endl;\n            continue;\n        }\n        ans+=max(x,y)-max(a[p],b[p]);\n        auto it=st.lower_bound(abs(a[p]-b[p]));\n        st.erase(it);\n        st.insert(abs(x-y));\n        if(a[p]-b[p]>0)posi--;\n        if(a[p]-b[p]==0)zero--;\n        if(x-y>0)posi++;\n        if(x-y==0)zero++;\n        a[p]=x;b[p]=y;\n        if(zero>0||posi%2==0)cout<<ans<<endl;\n        else cout<<ans-*st.begin()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define GET_MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) GET_MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp(a,b) make_pair((a),(b))\n#define pb(a) push_back((a))\n#define all(x) (x).begin(),(x).end()\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cout<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cout<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint main(){\n  int n,q;\n  cin>>n>>q;\n  n *= 2;\n  vector<int> a(n),b(n);\n  rep(i,n) cin>>a[i];\n  rep(i,n) cin>>b[i];\n\n  vector<int> d(n);\n  rep(i,n) d[i] = b[i]-a[i];\n\n  long acc = accumulate(all(a), 0L);\n  long plus_sum = 0;\n\n  multiset<int> plus, minus;\n  rep(i,1,n-1){\n    if(d[i]>=0) plus.insert(d[i]);\n    else minus.insert(d[i]);\n  }\n\n  for(auto x : plus) plus_sum += x;\n\n  rep(i,q){\n    int p,x,y;\n    cin>>p>>x>>y;\n    p--;\n\n    if(p==0 || p == n-1){\n      acc -= a[p];\n      a[p] = x;\n      b[p] = y;\n      acc += a[p];\n    }\n\n    else {\n      acc -= a[p];\n      int old_d = b[p] - a[p];\n      if(old_d >= 0){\n        plus.erase(plus.lower_bound(old_d));\n        plus_sum -= old_d;\n      }\n      else minus.erase(minus.lower_bound(old_d));\n\n      a[p] = x;\n      b[p] = y;\n      acc += a[p];\n      int new_d = b[p] - a[p];\n      if(new_d >= 0){\n        plus.insert(new_d);\n        plus_sum += new_d;\n      }\n      else minus.insert(new_d);\n    }\n\n    if(plus.size()%2==0) cout << acc + plus_sum << \"\\n\";\n    else {\n      // 奇数なのでどっちも1以上ある\n      long c1 = acc + plus_sum - *plus.begin();\n      long c2 = acc + plus_sum + *minus.rbegin();\n\n      cout << max(c1, c2) << \"\\n\";\n    }\n    // dbg(vector<int>(all(plus)));\n    // dbg(vector<int>(all(minus)));\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,m,n) for(int i = (m); i < (n); i++)\n#define rrep(i,m,n) for(int i = (m); i >= (n); i--)\n#define print(x) cout << (x) << endl;\n#define print2(x,y) cout << (x) << \" \" << (y) << endl;\n#define printa(x,n) for(int i = 0; i < n; i++){ cout << (x[i]) << \" \\n\"[i == n-1];}\n#define printp(x,n) for(int i = 0; i < n; i++){ cout << \"(\" << x[i].first << \", \" << x[i].second << \") \"; } cout << endl;\n#define INF (1e18)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\ntypedef pair<ll, ll> lpair;\nbool check(string s){\n    bool ok = true;\n    ll N = s.size();\n    ll lv = 0, rv = 0;\n    rep(i,0,N){\n        if(s[i] == '('){\n            lv++;\n        }else{\n            if(lv > 0){\n                lv--;\n            }else{\n                return false;\n            }\n        }\n    }\n    if(lv == 0){\n        return true;\n    }else{\n        return false;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N,Q;\n    ll a[200010], b[200010];\n    ll p[100010], x[100010], y[100010];\n    cin >> N >> Q;\n    rep(i,0,2*N) cin >> a[i];\n    rep(i,0,2*N) cin >> b[i];\n    rep(i,0,Q) cin >> p[i] >> x[i] >> y[i];\n    if(N > 5 || Q > 10) return 0;\n    rep(i,0,Q){\n        p[i]--;\n        ll a1 = a[p[i]]; ll b1 = b[p[i]];\n        a[p[i]] = x[i]; b[p[i]] = y[i];\n        ll ans = 0;\n        rep(i,0,pow(2,2*N)){\n            rep(j,0,pow(2,2*N)){\n                ll ans_tmp = 0;\n                string s = \"\", t = \"\";\n                rep(k,0,2*N){\n                    if((i>>k) & 1){\n                        s += '(';\n                    }else{\n                        s += ')';\n                    }\n                }\n                rep(k,0,2*N){\n                    if((j>>k) & 1){\n                        t += '(';\n                    }else{\n                        t += ')';\n                    }\n                }\n                if(!check(s) || !check(t)) continue;\n                rep(k,0,2*N){\n                    if(s[k] == t[k]){\n                        ans_tmp += a[k];\n                    }else{\n                        ans_tmp += b[k];\n                    }\n                }\n                ans = max(ans, ans_tmp); \n            }\n        }\n        print(ans);\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\n\nint main(){\n    int n,q;\n    cin>>n>>q;\n    n*=2;\n    ll a[n],b[n];\n    rep(i,n)cin>>a[i];\n    rep(i,n)cin>>b[i];\n    ll ans=a[0]+a[n-1];\n    int posi=0,zero=0;\n    multiset<ll> st;\n    rep(i,n-2){\n        ans+=max(a[i+1],b[i+1]);\n        if(a[i+1]>b[i+1])posi++;\n        if(a[i+1]==b[i+1])zero++;\n        st.insert(abs(a[i+1]-b[i+1]));\n    }\n    rep(i,q){\n        ll p,x,y;\n        cin>>p>>x>>y;\n        p--;\n        if(p==0||p==n-1){\n            ans+=(ll)(x-a[p]);\n            a[p]=x;\n            cout<<ans<<endl;\n            continue;\n        }\n        ans+=(ll)(max(x,y)-max(a[p],b[p]));\n        auto it=st.lower_bound(abs(a[p]-b[p]));\n        st.erase(it);\n        st.insert(abs(x-y));\n        if(a[p]-b[p]>0)posi--;\n        if(a[p]-b[p]==0)zero--;\n        if(x-y>0)posi++;\n        if(x-y==0)zero++;\n        a[p]=x;b[p]=y;\n        if(zero>0||posi%2==0)cout<<ans<<endl;\n        else cout<<ans-*st.begin()<<endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\nconst ll MOD = 998244353;\nconst ll INF = (ll)1000000007 * 1000000007;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\ntypedef pair<ll, ll> LP;\ntypedef pair<ld, ld> LDP;\nconst int MAX_N = (1 << 18);\nint t; ll dat[2 * MAX_N - 1][2];\nint n;\nvoid init() {\n\tt = 1;\n\twhile(t < 2*n)t *= 2;\n\trep(i, 2 * t - 1) {\n\t\trep(j, 2) {\n\t\t\tdat[i][j] = -INF;\n\t\t}\n\t}\n}\nvoid update(int k, int j, ll a) {\n\tk += t - 1;\n\tdat[k][j] = a;\n\twhile (k > 0) {\n\t\tk = (k - 1) / 2;\n\t\tint le = k * 2 + 1; int ri = k * 2 + 2;\n\t\tif (dat[ri][0] != -INF || dat[ri][1] != -INF) {\n\t\t\tdat[k][0] = max(dat[le][0] + dat[ri][0], dat[le][1] + dat[ri][1]);\n\t\t\tdat[k][1] = max(dat[le][0] + dat[ri][1], dat[le][1] + dat[ri][0]);\n\t\t}\n\t\telse {\n\t\t\tdat[k][0] = dat[le][0];\n\t\t\tdat[k][1] = dat[le][1];\n\t\t}\n\t}\n}\nint main(){\n\tint q; cin >> n >> q; init();\n\trep(i, 2 * n) {\n\t\tint a; cin >> a;\n\t\tupdate(i, 0, a);\n\t}\n\trep(i, 2 * n) {\n\t\tint b; cin >> b;\n\t\tif (i > 0 && i < 2 * n - 1) {\n\t\t\tupdate(i, 1, b);\n\t\t}\n\t}\n\trep(i, q) {\n\t\tint p; ll x, y; cin >> p >> x >> y; p--;\n\t\tupdate(p, 0, x);\n\t\tif (p > 0 && p < 2 * n - 1) {\n\t\t\tupdate(p, 1, y);\n\t\t}\n\t\tcout << dat[0][0] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define fst first\n#define snd second\n\nusing namespace std;\n\ntypedef int32_t i32;\ntypedef uint32_t u32;\ntypedef int64_t i64;\ntypedef uint64_t u64;\ntypedef pair<int,int> pii;\ntypedef pair<i64,int> pli;\ntypedef pair<int,i64> pil;\ntypedef pair<i64,i64> pll;\ntypedef vector<int> vi;\ntypedef vector<i64> vl;\n\ntemplate <typename T>\nT id(T b) {return b;};\ntemplate <class It>\nbool all(It f,It l){return std::all_of(f,l,id<bool>);}\ntemplate <class It>\nbool any(It f,It l){return std::any_of(f,l,id<bool>);}\n\nconst int MAX_N = 100000;\nint n,q;\ni64 a[2*MAX_N], b[2*MAX_N];\ni64 dp[2*MAX_N][2];\n\nint main()\n{\n  cin >> n >> q;\n  for (int i = 0; i < 2*n; ++i) {\n    cin >> a[i];\n  }\n\n  for (int i = 0; i < 2*n; ++i) {\n    cin >> b[i];\n  }\n\n  i64 p,x,y;\n  while (q--) {\n    cin >> p >> x >> y;\n    p--;\n    a[p] = x; b[p] = y;\n\n    dp[0][0] = a[0]; dp[0][1] = INT_MIN;\n    for (int i = 1; i < 2*n-1; i++) {\n      dp[i][0] = max(dp[i-1][0] + b[i], dp[i-1][1] + a[i]);\n      dp[i][1] = max(dp[i-1][0] + a[i], dp[i-1][1] + b[i]);\n    }\n\n    cout << dp[2*n-2][0] + a[2*n-1] << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll inf=1000000000000000000;\nll dat[800010];\nll u;\nvoid seginit(ll n){\n  for(int i=0;;i++){\n    ll y=pow(2,i);\n    if(y>=n){\n      u=y;\n      break;\n    }\n  }\n  fill(dat,dat+2*u,inf);\n}\nvoid add(ll n,ll x){\n  ll i=n+u-1;\n  dat[i]=x;\n  while(i>0){\n    i=(i-1)/2;\n    dat[i]=min(dat[2*i+1],dat[i*2+2]);\n  }\n}\nll que(ll a,ll b,ll k,ll l,ll r){\n  if(a>=r||b<=l)return inf;\n  if(a<=l&&b>=r)return dat[k];\n  ll m1=que(a,b,2*k+1,l,(l+r)/2);\n  ll m2=que(a,b,2*k+2,(l+r)/2,r);\n  return min(m1,m2);\n}\n\nint main(){\n  ll n,q;cin>>n>>q;\n  seginit(2*n);\n  ll a[2*n],b[2*n];\n  for(int i=0;i<2*n;i++)cin>>a[i];\n  ll sum=0;\n  ll c=0;\n  for(int i=0;i<2*n;i++){\n    cin>>b[i];\n    if(i==0||i==2*n-1){\n      sum+=a[i];\n    }\n    else{\n      if(a[i]>=b[i]){\n        sum+=a[i];\n        add(i,a[i]-b[i]);\n      }\n      else{\n        c=(c+1)%2;\n        sum+=b[i];\n        add(i,b[i]-a[i]);\n      }\n    }\n  }\n  for(int i=0;i<q;i++){\n    ll p,x,y;cin>>p>>x>>y;\n    p--;\n    if(p==0||p==2*n-1){\n      sum+=-a[p]+x;\n      cout<<sum<<endl;\n      continue;\n    }\n    if(((a[p]-b[p])>=0&&x<y)||((a[p]-b[p])<0&&x>=y)){\n      c=(c+1)%2;\n    }\n    //cout<<c<<endl;\n    sum+=-max(a[p],b[p])+max(x,y);\n    add(p,abs(x-y));\n    ll f=0;\n    if(c==1){\n      f=que(1,2*n-1,0,0,2*n);\n    }\n    a[p]=x;\n    b[p]=y;\n    cout<<sum-f<<endl;\n  }\n}\n        \n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nmap<int,int>mp1,mp2;\nint n,T,a[202000],b[202000];\nll sum,bas;\n\nvoid add(int x){\n\tif (x>=0) ++mp1[x], sum+=x;\n\telse ++mp2[-x];\n}\nvoid del(int x){\n\tif (x>=0){\n\t\tsum-=x;\n\t\tif (!--mp1[x]) mp1.erase(x);\n\t}else{\n\t\tif (!--mp2[-x]) mp2.erase(-x);\n\t}\n}\n\nll doit(){\n\tif (!(mp1.size()&1)) return sum;\n\treturn sum+max(-mp1.begin()->first,-mp2.begin()->first);\n}\n\nint main(){\n\tcin>>n>>T; n<<=1;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&b[i]);\n\tfor (int i=2;i<n;i++) add(a[i]-b[i]), bas+=b[i];\n\tfor (int p,x,y;T--;){\n\t\tscanf(\"%d%d%d\",&p,&x,&y);\n\t\tif (p!=1&&p!=n){\n\t\t\tdel(a[p]-b[p]); bas-=b[p];\n\t\t\tadd((a[p]=x)-(b[p]=y));\tbas+=b[p];\n\t\t}\n\t\tprintf(\"%lld\\n\",bas+a[1]+a[n]+doit());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\n\nll a[411111];\nll b[411111];\nmultiset<ll> pos;\nmultiset<ll> neg;\nll sumpos;\n\nvoid add(ll x)\n{\n\tif(x>0)\n\t{\n\t\tpos.insert(x);\n\t\tsumpos+=x;\n\t}\n\telse\n\t{\n\t\tneg.insert(-x);\n\t}\n}\n\nvoid del(ll x)\n{\n\tif(x>0)\n\t{\n\t\tauto it = pos.lower_bound(x);\n\t\tpos.erase(it);\n\t\tsumpos-=x;\n\t}\n\telse\n\t{\n\t\tauto it = neg.lower_bound(-x);\n\t\tneg.erase(it);\n\t}\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tsumpos=0;\n\tint n,q; cin>>n>>q; n*=2;\n\tll sum=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>a[i];\n\t\tsum+=a[i];\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>b[i];\n\t\tb[i]-=a[i];\n\t\tif(i>=1&&i+1<n) add(b[i]);\n\t}\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tint p,u,v;\n\t\tcin>>p>>u>>v;\n\t\tp--;\n\t\tsum-=a[p]; sum+=u;\n\t\t//b[i] becomes v-u\n\t\tif(p>=1&&p+1<n)\n\t\t{\n\t\t\tdel(b[p]); add(v-u);\n\t\t}\n\t\ta[p]=u; b[p]=v-u;\n\t\tif(pos.size()%2==0)\n\t\t{\n\t\t\tcout<<sum+sumpos<<'\\n';\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(neg.empty())\n\t\t\t{\n\t\t\t\tcout<<sum+sumpos-(*pos.begin())<<'\\n';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcout<<sum+max(sumpos-(*pos.begin()), sumpos-(*neg.begin()))<<'\\n';\n\t\t\t}\n\t\t}\n\t}\n}\t\n"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint N, Q;\n\tcin >> N >> Q;\n\tvector<int> A(2 * N), B(2 * N);\n\tfor (int i = 0; i < 2 * N; ++i) cin >> A[i];\n\tfor (int i = 0; i < 2 * N; ++i) cin >> B[i];\n\tlong long sum = 0;\n\tvector<int> diff(2 * N);\n\tint bcnt = 0;\n\tfor (int i = 0; i < 2 * N; ++i) {\n\t\tif (i == 0 || i == 2 * N - 1) {\n\t\t\tsum += A[i];\n\t\t}\n\t\telse {\n\t\t\tsum += max(A[i], B[i]);\n\t\t\tdiff[i] = abs(A[i] - B[i]);\n\t\t\tif (A[i] < B[i]) bcnt ^= 1;\n\t\t}\n\t}\n\tpriority_queue<pair<int, int> > que;\n\tfor (int i = 1; i < 2 * N - 1; ++i) {\n\t\tque.push(make_pair(-diff[i], i));\n\t}\n\tfor (int i = 0; i < Q; ++i) {\n\t\tint P, X, Y;\n\t\tcin >> P >> X >> Y; --P;\n\t\tif (P == 0 || P == 2 * N - 1) {\n\t\t\tsum -= A[P];\n\t\t\tA[P] = X;\n\t\t\tB[P] = Y;\n\t\t\tsum += A[P];\n\t\t}\n\t\telse {\n\t\t\tsum -= max(A[P], B[P]);\n\t\t\tif (A[P] < B[P]) bcnt ^= 1;\n\t\t\tA[P] = X;\n\t\t\tB[P] = Y;\n\t\t\tdiff[P] = abs(A[P] - B[P]);\n\t\t\tsum += max(A[P], B[P]);\n\t\t\tif (A[P] < B[P]) bcnt ^= 1;\n\t\t\tque.push(make_pair(-diff[P], P));\n\t\t}\n\t\tlong long ans = sum;\n\t\tif (bcnt == 1) {\n\t\t\twhile (diff[que.top().second] != -que.top().first) {\n\t\t\t\tque.pop();\n\t\t\t}\n\t\t\tans += que.top().first;\n\t\t}\n\t\tcout << ans << '\\n';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const auto& a = T()) { v.assign(n, a); }\ntemplate<class T, class... U> void assign(V<T>& v, int n, const U&... u) { v.resize(n); for (auto&& i : v) assign(i, u...); }\n\nstruct M {\n  using T = array<lint, 3>;\n  static T op(const T& a, const T& b) { return {min(a[0], b[0]), max(a[1], b[1]), a[2] + b[2]}; }\n  static constexpr T e() { return {numeric_limits<lint>::max(), numeric_limits<lint>::min(), 0}; }\n  static T mk(lint a) { return {a, a, a}; }\n};\n\ntemplate<class M> struct ST {\n  using T = typename M::T;\n  int n;\n  V<T> t;\n\n  ST(int n) : n(n) {\n    t.assign(2 * n, M::e());\n  }\n\n  void build() {\n    for (int i = n - 1; i; i--) t[i] = M::op(t[2 * i], t[2 * i + 1]);\n  }\n\n  T get(int l, int r) {\n    T resl = M::e(), resr = M::e();\n    for (l += n, r += n; l < r; l >>= 1, r >>= 1) { \n      if (l & 1) resl = M::op(resl, t[l++]); \n      if (r & 1) resr = M::op(t[--r], resr);\n    }\n    return M::op(resl, resr);\n  }\n\n  T get(int i) { return t[i + n]; };\n\n  void set(int i, const T& a) {\n    for (t[i += n] = a; i >>= 1;) t[i] = M::op(t[2 * i], t[2 * i + 1]);\n  }\n};\n\nint main() {\n  cin.tie(NULL); ios::sync_with_stdio(false);\n  int n, q; cin >> n >> q;\n  V<> a(2 * n); for (int i = 0; i < 2 * n; i++) cin >> a[i];\n  V<> b(2 * n); for (int i = 0; i < 2 * n; i++) cin >> b[i];\n  lint sa = accumulate(a.begin(), a.end(), 0LL);\n  ST<M> pos(2 * n), neg(2 * n);\n  int cp = 0;\n  for (int i = 1; i < 2 * n - 1; i++) (b[i] - a[i] >= 0 ? cp++, pos : neg).t[i + 2 * n] = M::mk(b[i] - a[i]);\n  pos.build(), neg.build();\n  for (int iq = 0; iq < q; iq++) {\n    int p, x, y; cin >> p >> x >> y, p--;\n    if (y - x >= 0) {\n      pos.set(p, M::mk(y - x));\n      neg.set(p, M::e());\n      cp += (b[p] - a[p] < 0);\n    } else {\n      neg.set(p, M::mk(y - x));\n      pos.set(p, M::e());\n      cp -= (b[p] - a[p] >= 0);\n    }\n    sa += x - a[p];\n    a[p] = x, b[p] = y;\n    lint s = pos.get(1, 2 * n - 1)[2];\n    if (cp & 1) {\n      s -= min(pos.get(1, 2 * n - 1)[0], -neg.get(1, 2 * n - 1)[1]);\n    }\n    cout << sa + s << '\\n';\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  int n, q; cin >> n >> q;\n  n <<= 1;\n  vector<ll> a(n), b(n);\n  multiset<ll> treeone;\n  for(int i = 0; i < n; i++) cin >> a[i];\n  for(int i = 0; i < n; i++) cin >> b[i];\n  int use = 0;\n  ll now = 0;\n  for(int i = 1; i < n - 1; i++) {\n    now += max(a[i], b[i]);\n    if(a[i] < b[i]) use ^= 1;\n    treeone.emplace(abs(a[i] - b[i]));\n  }\n\n  while(q--) {\n    int i, x, y; cin >> i >> x >> y;\n    i--;\n    if(i == 0 || i == n - 1) {\n    } else {\n      now -= max(a[i], b[i]);\n      if(a[i] < b[i]) use ^= 1;\n      treeone.erase(treeone.lower_bound(abs(a[i] - b[i])));\n      now += max(x, y);\n      if(x < y) use ^= 1;\n      treeone.emplace(abs(x - y));\n    }\n    a[i] = x; b[i] = y;\n    ll ans = a[0] + a[n - 1];\n    ans += now;\n    if(use) ans -= *(treeone.begin());\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i, n, m) for(int i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = std::int_fast64_t;\nusing ld = long double;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 1000000007;\nconstexpr long double eps = 1e-15;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n\tos << to_string(p.first) << \" \" << to_string(p.second);\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n\tREP(i, v.size()) {\n\t\tif(i) os << \" \";\n\t\tos << to_string(v[i]);\n\t}\n\treturn os;\n}\n\n/*\ntemplate<typename T>\nstruct Treap {\n\tdouble drand() { // random number in [0, 1]\n\t\tstatic random_device rd;\n\t\tstatic mt19937 mt(rd());\n\t\treturn (unsigned)mt() / (double)numeric_limits<unsigned>::max();\n\t}\n\tT v;\n\tdouble p;\n\tint cnt;\n\tTreap* lch;\n\tTreap* rch;\n\tTreap(T v) : v(v), p(drand()), cnt(1), lch(NULL), rch(NULL) { }\n\tTreap* update() {\n\t\tthis->size = size(this->lch) + size(this->rch) + 1;\n\t\treturn this;\n\t}\n\tstatic int size(Treap* t) {\n\t\tif(!t) return 0;\n\t\telse return t->cnt;\n\t}\n\tstatic Treap* merge(Treap* l, Treap* r) {\n\t\tif(!l || !r) {\n\t\t\tif(!l) return r;\n\t\t\telse return l;\n\t\t}\n\t\tif(l->p >= r->p) {\n\t\t\tl->rch = merge(l->rch, r);\n\t\t\treturn l->update();\n\t\t} else {\n\t\t\tr->lch = merge(r->lch, l);\n\t\t\treturn r->update();\n\t\t}\n\t}\n\tstatic pair<Treap*, Treap*> split(Treap* t, int k) {\n\t\t// split [0, k) and [k, n)\n\t\tif(k == 0) return {NULL, t};\n\t\tif(!(t->l)) {\n\t\t\tauto tmp = split(t->r, k - 1);\n\t\t\tt->r = tmp.first;\n\t\t\treturn {t->update(), tmp.second};\n\t\t} else if(!(t->r)) {\n\t\t\tauto tmp = split(t->r, k - 1);\n\t\t\tt->r = tmp.first;\n\t\t\treturn {t->update(), tmp.second};\n\t\t} else {\n\n\t\t}\n\t}\n\tTreap* insert() {\n\t}\n\tTreap* erase() {\n\t}\n\tT operator[](int k) {\n\t}\n};\n*/\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q;\n\tcin >> n >> q;\n\tvector<int> a(2 * n), b(2 * n);\n\tREP(i, 2 * n) cin >> a[i];\n\tREP(i, 2 * n) cin >> b[i];\n\tll sum1 = 0, sum2 = 0;\n\tREP(i, 2 * n) sum1 += a[i];\n\tset<pair<ll, int>> st;\n\tFOR(i, 1, 2 * n - 1) {\n\t\tif(b[i] - a[i] >= 0) {\n\t\t\tst.insert({b[i] - a[i], i});\n\t\t\tsum2 += b[i] - a[i];\n\t\t}\n\t}\n\tREP(i, q) {\n\t\tint p, x, y;\n\t\tcin >> p >> x >> y;\n\t\tp--;\n\t\tsum1 -= a[p]; sum1 += x;\n\t\tif(p != 0 && p != 2 * n - 1) {\n\t\t\tif(b[p] - a[p] >= 0) {\n\t\t\t\tst.erase({b[p] - a[p], p});\n\t\t\t\tsum2 -= (b[p] - a[p]);\n\t\t\t}\n\t\t\tif(y - x >= 0) {\n\t\t\t\tst.insert({y - x, p});\n\t\t\t\tsum2 += y - x;\n\t\t\t}\n\t\t}\n\t\ta[p] = x; b[p] = y;\n\t\tif((int)st.size() % 2 == 0) {\n\t\t\tcout << sum1 + sum2 << endl;\n\t\t} else {\n\t\t\tcout << sum1 + sum2 - st.begin()->first << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n// ---------------------------------------\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<::std::uint_fast64_t mod>\nclass ModInt{\nprivate:\n    using value_type = ::std::uint_fast64_t;\n    value_type n;\npublic:\n    ModInt() : n(0) {}\n    ModInt(value_type n_) : n(n_ % mod) {}\n    ModInt(const ModInt& m) : n(m.n) {}\n\n    template<typename T>\n    explicit operator T() const { return static_cast<T>(n); }\n    value_type get() const { return n; }\n\n    friend ::std::ostream& operator<<(::std::ostream &os, const ModInt<mod> &a) {\n        return os << a.n;\n    }\n\n    friend ::std::istream& operator>>(::std::istream &is, ModInt<mod> &a) {\n        value_type x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return is;\n    }\n\n    bool operator==(const ModInt& m) const { return n == m.n; }\n    bool operator!=(const ModInt& m) const { return n != m.n; }\n    ModInt& operator*=(const ModInt& m){ n = n * m.n % mod; return *this; }\n\n    ModInt pow(value_type b) const{\n        ModInt ans = 1, m = ModInt(*this);\n        while(b){\n            if(b & 1) ans *= m;\n            m *= m;\n            b >>= 1;\n        }\n        return ans;\n    }\n\n    ModInt inv() const { return (*this).pow(mod-2); }\n    ModInt& operator+=(const ModInt& m){ n += m.n; n = (n < mod ? n : n - mod); return *this; }\n    ModInt& operator-=(const ModInt& m){ n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n    ModInt& operator/=(const ModInt& m){ *this *= m.inv(); return *this; }\n    ModInt operator+(const ModInt& m) const { return ModInt(*this) += m; }\n    ModInt operator-(const ModInt& m) const { return ModInt(*this) -= m; }\n    ModInt operator*(const ModInt& m) const { return ModInt(*this) *= m; }\n    ModInt operator/(const ModInt& m) const { return ModInt(*this) /= m; }\n    ModInt& operator++(){ n += 1; return *this; }\n    ModInt& operator--(){ n -= 1; return *this; }\n    ModInt operator++(int){\n        ModInt old(n);\n        n += 1;\n        return old;\n    }\n    ModInt operator--(int){\n        ModInt old(n);\n        n -= 1;\n        return old;\n    }\n    ModInt operator-() const { return ModInt(mod-n); }\n};\n\nclass UnionFind{\nprivate:\n    ::std::vector<int_fast32_t> par;\n    vector<int64> sum;\n    size_t n;\n\npublic:\n    UnionFind(){}\n    UnionFind(size_t n):n(n){\n        par.resize(n, -1);\n        sum.resize(n, 0);\n    }\n\n    void set_sum(const vector<int64>& s) {\n        sum = s;\n    }\n\n    uint_fast32_t find(uint_fast32_t x){\n        return par[x] < 0 ? x : par[x] = find(par[x]);\n    }\n\n    size_t size(uint_fast32_t x){\n        return -par[find(x)];\n    }\n\n    int64 sum_v(int64 x) {\n        return sum[find(x)];\n    }\n\n    bool unite(uint_fast32_t x, uint_fast32_t y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return false;\n        if(size(x) < size(y)) std::swap(x, y);\n        par[x] += par[y];\n        sum[x] += sum[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool same(uint_fast32_t x, uint_fast32_t y){\n        return find(x) == find(y);\n    }\n};\n\n\n\nint main(void) {\n    int64 N, Q;\n    cin >> N >> Q;\n    N *= 2;\n    vector<int64> a(N), b(N);\n    REP(i, N) cin >> a[i];\n    REP(i, N) cin >> b[i];\n    multiset<int64> as, bs;\n    int64 res = a[0] + a.back();\n    FOR(i, 1, N-1) {\n        if (a[i] >= b[i]) {\n            as.insert(a[i]-b[i]);\n            res += a[i];\n        } else {\n            bs.insert(b[i]-a[i]);\n            res += b[i];\n        }\n    }\n    REP(i, Q) {\n        int64 p, x, y;\n        cin >> p >> x >> y; p--;\n        if (p == 0 || p == N-1) {\n            res -= a[p]; res += x;\n            a[p] = x;\n        } else {\n            if (a[p] >= b[p]) {\n                res -= a[p];\n                as.erase(as.find(a[p]-b[p]));\n            } else {\n                res -= b[p];\n                bs.erase(bs.find(b[p]-a[p]));\n            }\n            a[p] = x; b[p] = y;\n            if (a[p] >= b[p]) {\n                res += a[p];\n                as.insert(a[p]-b[p]);\n            } else {\n                res += b[p];\n                bs.insert(b[p]-a[p]);\n            }\n        }\n        cout << res - (as.size() % 2 ? min(*as.begin(), *bs.begin()) : 0) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <set>\n#include <iostream>\nusing namespace std;\nint main() {\n    int n, q; cin >> n >> q;\n    int a[2*n], b[2*n];\n    long long asum = 0;\n    for (int i = 0; i < 2*n; i++) cin >> a[i], asum += a[i];\n    multiset<int> ds;\n    for (int i = 0; i < 2*n; i++) {\n        cin >> b[i];\n        if (0 < i && i < 2*n-1) ds.insert(b[i] - a[i]);\n    }\n    long long dsum = 0;\n    auto it = ds.lower_bound(1);\n    int c = 0;\n    for (auto it2 = it; it2 != ds.end(); it2++) {\n        c++;\n        dsum += *it2;\n    }\n    while (q--) {\n        int i, x, y; cin >> i >> x >> y;\n        i--;\n        if (0 < i && i < 2*n-1) {\n            ds.erase(ds.find(b[i] - a[i]));\n            if (b[i] - a[i] > 0) { dsum -= b[i] - a[i]; c--; }\n        }\n        asum += x - a[i];\n        a[i] = x; b[i] = y;\n        if (0 < i && i < 2*n-1) {\n            ds.insert(b[i] - a[i]);\n            if (b[i] - a[i] > 0) { dsum += b[i] - a[i]; c++; }\n        }\n        long long ans = asum + dsum;\n        if (c % 2) {\n            it = ds.lower_bound(1);\n            if (it != ds.begin() && *it + *prev(it) > 0)\n                ans += *prev(it);\n            else\n                ans -= *it;\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\n\nusing namespace std;\nconst ll MAX_N=1e5;\nll N,Q,A[MAX_N*2],B[MAX_N*2],c[MAX_N*2];\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>N>>Q;\n\tREP(i,N*2)cin>>A[i];\n\tREP(i,N*2)cin>>B[i];\n\tREP(i,N*2)c[i]=A[i]-B[i];\n\tll bsm,mx;\n\tbsm=mx=0;\n\tmultiset<ll> st[2];\n\tREP(i,N*2-2){\n\t\tint inx;\n\t\tif(c[i+1]>=0){\n\t\t\tinx=0;\n\t\t\tmx+=c[i+1];\n\t\t}else{\n\t\t\tinx=1;\n\t\t}\n\t\tst[inx].insert(c[i+1]);\n\t}\n\tREP(i,N*2)bsm+=B[i];\n\tREP(q,Q){\n\t\tll p,x,y;\n\t\tcin>>p>>x>>y;\n\t\tp--;\n\t\tbsm-=B[p];\n\t\tint inx;\n\t\tmultiset<ll>::iterator ite;\n\t\tif(0<p && p<N*2-1){\n\t\t\tif(c[p]>=0){\n\t\t\t\tinx=0;\n\t\t\t\tmx-=c[p];\n\t\t\t}else{\n\t\t\t\tinx=1;\n\t\t\t}\n\t\t\tite=st[inx].find(c[p]);\n\t\t\tst[inx].erase(ite);\n\t\t}\n\t\tA[p]=x;\n\t\tB[p]=y;\n\t\tc[p]=x-y;\n\t\tbsm+=y;\n\t\tif(0<p && p<N*2-1){\n\t\t\tif(c[p]>=0){\n\t\t\t\tinx=0;\n\t\t\t\tmx+=c[p];\n\t\t\t}else{\n\t\t\t\tinx=1;\n\t\t\t}\n\t\t\tst[inx].insert(c[p]);\n\t\t}\n\t\tll ans;\n\t\tif(st[0].size()%2==0){\n\t\t\tans=mx;\n\t\t}else{\n\t\t\tite=st[0].begin();\n\t\t\tans=mx-*ite;\n\t\t\tite=st[1].end();\n\t\t\tite--;\n\t\t\tans=max(ans,mx+*ite);\n\t\t}\n\t\tcout<<ans+bsm+c[0]+c[N*2-1]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint N, Q; cin >> N >> Q; \n\tlong long A[200010], B[200010]; \n\tfor(int i = 0; i < N*2; i++) cin >> A[i]; \n\tfor(int i = 0; i < N*2; i++) cin >> B[i]; \n\tlong long sumA = 0; // 全部Aだった場合\n\tlong long sumP = 0; // 変えた方が得なものを全部Bに変えたときの得\n\tmultiset<long long> P, M; \n\tfor(int i = 0; i < N*2; i++) sumA += A[i]; \n\tfor(int i = 1; i < N*2-1; i++){\n\t\tif(A[i] <= B[i]){\n\t\t\tP.insert(B[i] - A[i]); sumP += B[i] - A[i]; \n\t\t}\n\t\telse M.insert(A[i] - B[i]); \n\t}\n\twhile(Q--){\n\t\tint p; long long x, y; \n\t\tcin >> p >> x >> y; p--; \n\t\tif(p == 0 || p == N*2 - 1){\n\t\t\tsumA += x - A[p]; \n\t\t\tA[p] = x; \n\t\t}else{\n\t\t\tif(A[p] <= B[p]){\n\t\t\t\tP.erase(P.find(B[p] - A[p])); \n\t\t\t\tsumP -= B[p] - A[p]; \n\t\t\t\tsumA -= A[p]; \n\t\t\t\tA[p] = x; B[p] = y; \n\t\t\t}else{\n\t\t\t\tM.erase(M.find(A[p] - B[p])); \n\t\t\t\tsumA -= A[p]; \n\t\t\t\tA[p] = x; B[p] = y; \n\t\t\t}\n\t\t\tsumA += A[p]; \n\t\t\tif(A[p] <= B[p]){\n\t\t\t\tP.insert(B[p] - A[p]); sumP += B[p] - A[p]; \n\t\t\t}\n\t\t\telse M.insert(A[p] - B[p]); \n\t\t}\n\t\tlong long ans = sumA + sumP; \n\t\tint s = (int) P.size(); \n\t\tif(s & 1){\n\t\t\tlong long d = *P.begin(); \n\t\t\tlong long e = *M.begin(); \n\t\t\tans -= min(d, e); \n\t\t}\n\t\tcout << ans << \"\\n\"; \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = 1e18;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  assert(n == 1);\n  n *= 2;\n  vl a(n), b(n);\n  rep (i, n) {\n    cin >> a[i];\n  }\n  rep (i, n) {\n    cin >> b[i];\n  }\n  set<pii> aa, bb;\n  ll ans = 0;\n  rep (i, n) {\n    if (i == 0) {\n      ans += a[i];\n      continue;\n    }\n    if (i == n - 1) {\n      ans += a[i];\n      continue;\n    }\n    if (a[i] >= b[i]) {\n      ans += a[i];\n      aa.insert(pii(a[i] - b[i], i));\n    }\n    else {\n      ans += b[i];\n      bb.insert(pii(b[i] - a[i], i));\n    }\n  }\n  if ((int)aa.size() % 2) {\n    auto itra = aa.begin();\n    auto itrb = bb.begin();\n    pii a_s = *itra, b_s = *itrb;\n    if (a_s.first >= b_s.first) {\n      bb.erase(b_s);\n      int idx = b_s.second;\n      ans -= b[idx];\n      ans += a[idx];\n      aa.insert(pii(a[idx] - b[idx], idx));\n    }\n    else {\n      aa.erase(a_s);\n      int idx = a_s.second;\n      ans -= a[idx];\n      ans += b[idx];\n      bb.insert(pii(b[idx] - a[idx], idx));\n    }\n  }\n  while (q--) {\n    /*\n    cout << \"aa \";\n    for (auto itr = aa.begin(); itr != aa.end(); itr++) {\n      cout << *itr << \" \";\n    }\n    cout << endl;\n    cout << \"bb \";\n    for (auto itr = bb.begin(); itr != bb.end(); itr++) {\n      cout << *itr << \" \";\n    }\n    //*/\n    int p, x, y;\n    cin >> p >> x >> y;\n    p--;\n    if (p == 0 || p == n - 1) {\n      ans -= a[p];\n      a[p] = x;\n      b[p] = y;\n      ans += a[p];\n      cout << ans << endl;\n      continue;\n    }\n    if (aa.count(pii(a[p] - b[p], p))) {\n      aa.erase(pii(a[p] - b[p], p));\n      ans -= a[p];\n    }\n    else if (bb.count(pii(b[p] - a[p], p))) {\n      bb.erase(pii(b[p] - a[p], p));\n      ans -= b[p];\n    }\n    else {\n      assert(false);\n    }\n    a[p] = x;\n    b[p] = y;\n    if (a[p] >= b[p]) {\n      ans += a[p];\n      aa.insert(pii(a[p] - b[p], p));\n    }\n    else {\n      ans += b[p];\n      bb.insert(pii(b[p] - a[p], p));\n    }\n    if ((int)aa.size() % 2) {\n      auto itra = aa.begin();\n      auto itrb = bb.begin();\n      pii a_s = *itra, b_s = *itrb;\n      if (a_s.first >= b_s.first) {\n        bb.erase(b_s);\n        int idx = b_s.second;\n        ans -= b[idx];\n        ans += a[idx];\n        aa.insert(pii(a[idx] - b[idx], idx));\n      }\n      else {\n        aa.erase(a_s);\n        int idx = a_s.second;\n        ans -= a[idx];\n        ans += b[idx];\n        bb.insert(pii(b[idx] - a[idx], idx));\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = 1e18;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  n *= 2;\n  vl a(n), b(n);\n  rep (i, n) {\n    cin >> a[i];\n  }\n  rep (i, n) {\n    cin >> b[i];\n  }\n  set<pii> aa, bb;\n  ll ans = 0;\n  rep (i, n) {\n    if (i == 0) {\n      ans += a[i];\n      continue;\n    }\n    if (i == n - 1) {\n      ans += a[i];\n      continue;\n    }\n    if (a[i] >= b[i]) {\n      ans += a[i];\n      aa.insert(pii(a[i] - b[i], i));\n    }\n    else {\n      ans += b[i];\n      bb.insert(pii(b[i] - a[i], i));\n    }\n  }\n  if ((int)aa.size() % 2) {\n    auto itra = aa.begin();\n    auto itrb = bb.begin();\n    pii a_s = *itra, b_s = *itrb;\n    if (a_s.first >= b_s.first) {\n      bb.erase(b_s);\n      int idx = b_s.second;\n      ans -= b[idx];\n      ans += a[idx];\n      aa.insert(pii(a[idx] - b[idx], idx));\n    }\n    else {\n      aa.erase(a_s);\n      int idx = a_s.second;\n      ans -= a[idx];\n      ans += b[idx];\n      bb.insert(pii(b[idx] - a[idx], idx));\n    }\n  }\n  while (q--) {\n    /*\n    cout << \"aa \";\n    for (auto itr = aa.begin(); itr != aa.end(); itr++) {\n      cout << *itr << \" \";\n    }\n    cout << endl;\n    cout << \"bb \";\n    for (auto itr = bb.begin(); itr != bb.end(); itr++) {\n      cout << *itr << \" \";\n    }\n    //*/\n    int p, x, y;\n    cin >> p >> x >> y;\n    p--;\n    if (p == 0 || p == n - 1) {\n      ans -= a[p];\n      a[p] = x;\n      b[p] = y;\n      ans += a[p];\n      cout << ans << endl;\n      continue;\n    }\n    if (aa.count(pii(a[p] - b[p], p))) {\n      aa.erase(pii(a[p] - b[p], p));\n      ans -= a[p];\n    }\n    else if (bb.count(pii(b[p] - a[p], p))) {\n      bb.erase(pii(b[p] - a[p], p));\n      ans -= b[p];\n    }\n    else {\n      assert(false);\n    }\n    a[p] = x;\n    b[p] = y;\n    if (a[p] >= b[p]) {\n      ans += a[p];\n      aa.insert(pii(a[p] - b[p], p));\n    }\n    else {\n      ans += b[p];\n      bb.insert(pii(b[p] - a[p], p));\n    }\n    if ((int)aa.size() % 2) {\n      auto itra = aa.begin();\n      auto itrb = bb.begin();\n      pii a_s = *itra, b_s = *itrb;\n      if (a_s.first >= b_s.first) {\n        bb.erase(b_s);\n        int idx = b_s.second;\n        ans -= b[idx];\n        ans += a[idx];\n        aa.insert(pii(a[idx] - b[idx], idx));\n      }\n      else {\n        aa.erase(a_s);\n        int idx = a_s.second;\n        ans -= a[idx];\n        ans += b[idx];\n        bb.insert(pii(b[idx] - a[idx], idx));\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  LL N, Q;\n  cin >> N >> Q;\n\n  VL as(N*2), bs(N*2);\n  cin >> as >> bs;\n\n  if(N == 1){\n    while(Q--){\n    int p, x, y;\n    cin >> p >> x >> y;\n    --p;\n    as[p] = x;\n    bs[p] = y;\n    cout<<as[0]+as[1]<<endl;      \n    }\n    return 0;\n  }\n\n  int par = 0;\n  LL sum = as[0] + as.back();\n  multiset<LL> dels;\n  FOR(i,1,2*N-1){\n    LL mx = max(as[i], bs[i]);\n    LL mn = min(as[i], bs[i]);\n    sum += mx;\n    if(mx == as[i]) par ^= 1;\n    dels.insert(mn - mx);\n  }\n\n  while(Q--){\n    LL p, x, y;\n    cin >> p >> x >> y;\n    --p;\nif(p==0||p==2*N-1){\nsum-=as[p]-x;as[p]=x;\ncout<<sum-(par?*dels.rbegin():0ll)<<endl;continue;\n}\n    LL mx = max(as[p], bs[p]);\n    LL mn = min(as[p], bs[p]);\n    sum -= mx;\n    if(mx == as[p]) par ^= 1;\n    auto it = dels.find(mn - mx);\n    dels.erase(it);\n\n    as[p] = x;\n    bs[p] = y;\n    LL mx2 = max(as[p], bs[p]);\n    LL mn2 = min(as[p], bs[p]);\n    sum += mx2;\n    if(mx2 == as[p]) par ^= 1;\n    dels.insert(mn2 - mx2);\n\n    LL ans = 0;\n    if(par == 0){\n      ans = sum;\n    }\n    else{\n      auto it = dels.rbegin();\n      assert(it != dels.rend());\n      ans = sum + *it;\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n    Problem: Given two sequences a and b, find two balance sequences of brackets (s, t) of the same length\n        such that their cost is maximized.\n    The cost is calculated as followed: with position i, cost += a[i] if s[i] == t[i]; cost += b[i] otherwise.\n*/\n\n#include <cstdio>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\n#define long long long\n\nconst int N = 1e5 + 2;\n\nint n, q, a[N], b[N];\nset<pair<int, int> > s[2];\nlong cost = 0, sum[2] = {0, 0};\n\nvoid Solve()\n{\n    while (q--)\n    {\n        int p, x, y; long cur = 0;\n        scanf(\"%d %d %d\", &p, &x, &y); --p;\n        if (p == 0 || p == n - 1) cost += x - a[p], a[p] = x;\n        else\n        {\n            cost += x - a[p];\n            int old_sign = b[p] - a[p] >= 0;\n            int new_sign = y - x >= 0;\n            sum[old_sign] -= b[p] - a[p];\n            sum[new_sign] += y - x;\n            s[old_sign].erase({b[p] - a[p], p});\n            s[new_sign].insert({y - x, p});\n            a[p] = x, b[p] = y;\n            if (s[1].size() & 1)\n                cur = cost + max(sum[1] + s[0].begin()->first, sum[1] - s[1].begin()->first);\n            else cur = cost + sum[1];\n        }\n        printf(\"%lld\\n\", cur);\n    }\n}\n\nint main()\n{\n    scanf(\"%d %d\", &n, &q);\n    n *= 2;\n    for (int i = 0; i < n; ++i) scanf(\"%d\", &a[i]), cost += a[i];\n    for (int i = 0; i < n; ++i)\n    {\n        scanf(\"%d\", &b[i]);\n        if (i != 0 && i != n - 1)\n        {\n            int x = b[i] - a[i];\n            int sign = x >= 0;\n            sum[sign] += x;\n            s[sign].insert({x, i});\n        }\n    }\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nvector<tuple<int,long,int,int>> G[100000];\nlong S[100000];\nint child[100000];\nlong ans[99999];\nlong sumcost[100000];\nvoid Calc(){\n\tint N = rei();\n\tfor(int i=0;i<N-1;i++){\n\t\tint a = rei()-1;\n\t\tint b = rei()-1;\n\t\tG[a].push_back({b,0,i,G[b].size()});\n\t\tG[b].push_back({a,0,i,G[a].size()-1});\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tS[i] = rel();\n\t}\n\tstack<pair<int,int>> sp;\n\tsp.push({0,-1});\n\twhile(!sp.empty()){\n\t\tint v = sp.top().first;\n\t\tint f = sp.top().second;\n\t\tsp.pop();\n\t\tif(v >= N){\n\t\t\tv -= N;\n\t\t\tchild[v] = 1;\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tint t = get<0>(G[v][i]);\n\t\t\t\tif(t != f){\n\t\t\t\t\tchild[v] += child[t];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tsp.push({v+N,f});\n\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\tint t = get<0>(G[v][i]);\n\t\t\t\tif(t != f){\n\t\t\t\t\tsp.push({t,v});\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint halfchild1 = -1;\n\tint halfchild2 = -1;\n\tint halfedge = -1;\n\tstack<tuple<int,int,int>> sp2;\n\tsp2.push({0,-1,-1});\n\twhile(!sp2.empty()){\n\t\tint v = get<0>(sp2.top());\n\t\tint f = get<1>(sp2.top());\n\t\tint fe = get<2>(sp2.top());\n\t\tsp2.pop();\n\t\tif(f != -1){\n\t\t\tif(child[v]*2 == N){\n\t\t\t\thalfchild1 = f;\n\t\t\t\thalfchild2 = v;\n\t\t\t\thalfedge = get<2>(G[f][fe]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlong cost = (S[v] - S[f]) / (N - child[v]*2);\n\t\t\t\tans[get<2>(G[f][fe])] = cost;\n\t\t\t\tG[f][fe] = {get<0>(G[f][fe]),cost,get<2>(G[f][fe]),get<3>(G[f][fe])};\n\t\t\t\tint fe2 = get<3>(G[f][fe]);\n\t\t\t\tG[v][fe2] = {get<0>(G[v][fe2]),cost,get<2>(G[v][fe2]),get<3>(G[v][fe2])};\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint t = get<0>(G[v][i]);\n\t\t\tif(t != f){\n\t\t\t\tsp2.push({t,v,i});\n\t\t\t}\n\t\t}\n\t}\n\tif(halfchild1 != -1){\n\t\tsp.push({halfchild1,-1});\n\t\twhile(!sp.empty()){\n\t\t\tint v = sp.top().first;\n\t\t\tint f = sp.top().second;\n\t\t\tsp.pop();\n\t\t\tif(v >= N){\n\t\t\t\tv -= N;\n\t\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\t\tint t = get<0>(G[v][i]);\n\t\t\t\t\tif(t != f){\n\t\t\t\t\t\tsumcost[v] += sumcost[t] + get<1>(G[v][i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsp.push({v+N,f});\n\t\t\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\t\t\tint t = get<0>(G[v][i]);\n\t\t\t\t\tif(t != f){\n\t\t\t\t\t\tsp.push({t,v});\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans[halfedge] = (S[halfchild1]-sumcost[halfchild1]) / (child[halfchild1] - 1);\n\t}\n\tfor(int i=0;i<N-1;i++){\n\t\tcout << ans[i] << endl;\n\t}\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN = 100000;\n\nint n, nq;\nint a[2 * MAXN], b[2 * MAXN];\n\nll now;\nbool same[2 * MAXN];\nset<pair<int,int> > same2diff;\nset<pair<int,int> > diff2same;\n\nvoid change(set<pair<int, int> > &s, int idx, int oval, int nval) {\n\ts.erase(MP(oval, idx)); s.insert(MP(nval, idx));\n}\n\nvoid update() {\n\twhile (true) {\n\t\tbool change = false;\n\t\twhile (SZ(same2diff) >= 2) {\n\t\t\tauto a = same2diff.end(); --a; auto b = a; --b;\n\t\t\tif (a->first + b->first <= 0) break;\n\t\t\tnow += a->first + b->first;\n\t\t\tsame[a->second] = same[b->second] = false;\n\t\t\tdiff2same.insert(MP(-a->first, a->second));\n\t\t\tdiff2same.insert(MP(-b->first, b->second));\n\t\t\tsame2diff.erase(a);\n\t\t\tsame2diff.erase(b);\n\t\t\tchange = true;\n\t\t}\n\t\twhile (SZ(diff2same) >= 2) {\n\t\t\tauto a = diff2same.end(); --a; auto b = a; --b;\n\t\t\tif (a->first + b->first <= 0) break;\n\t\t\tnow += a->first + b->first;\n\t\t\tsame[a->second] = same[b->second] = true;\n\t\t\tsame2diff.insert(MP(-a->first, a->second));\n\t\t\tsame2diff.insert(MP(-b->first, b->second));\n\t\t\tdiff2same.erase(a);\n\t\t\tdiff2same.erase(b);\n\t\t\tchange = true;\n\t\t}\n\t\tif (!change) break;\n\t}\n}\n\nvoid run() {\n\tscanf(\"%d%d\", &n, &nq); REP(i, 2 * n) scanf(\"%d\", &a[i]); REP(i, 2 * n) scanf(\"%d\", &b[i]);\n\tnow = 0; same2diff.clear(); diff2same.clear();\n\tREP(i, 2 * n) {\n\t\tnow += a[i]; same[i] = true;\n\t\tif (i != 0 && i != 2 * n - 1) same2diff.insert(MP(b[i] - a[i], i));\n\t}\n\tREP(qi, nq) {\n\t\tint idx, aval, bval; scanf(\"%d%d%d\", &idx, &aval, &bval); --idx;\n\t\tif (same[idx]) now += aval - a[idx];\n\t\telse now += bval - b[idx];\n\t\tif (idx != 0 && idx != 2 * n - 1) {\n\t\t\tif (same[idx]) change(same2diff, idx, b[idx] - a[idx], bval - aval);\n\t\t\telse change(diff2same, idx, a[idx] - b[idx], aval - bval);\n\t\t}\n\t\ta[idx] = aval, b[idx] = bval;\n\t\tupdate();\n\t\tprintf(\"%lld\\n\", now);\n\t}\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<class ValueMonoid, template<class...> class Container=::std::vector>\nclass SegTree{\npublic:\n    using value_structure = ValueMonoid;\n    using value_type = typename value_structure::value_type;\n    using const_reference = const value_type &;\n    using container_type = Container<value_type>;\n    using size_type = typename container_type::size_type;\n\nprivate:\n    ::std::vector<value_type> tree;\n    size_type size_;\n\n    static size_type getsize(const size_type x){\n        size_type ret = 1;\n        while(ret < x)\n            ret <<= 1;\n        return ret;\n    }\n\n    inline value_type calc(const value_type a, const value_type b){\n        return value_structure::operation(a, b);\n    }\n\n    inline void calc_node(const size_type index){\n        if(tree.size() <= (index << 1 | 1)) return;\n        tree[index] = value_structure::operation(tree[index<<1], tree[index<<1 | 1]);\n    }\npublic:\n    SegTree() : size_(0), tree(){}\n    SegTree(const size_type size)\n            : size_(size), tree(size << 1, value_structure::identity()){}\n    template<class InputIterator>\n    SegTree(InputIterator first, InputIterator last)\n            : size_(::std::distance(first, last)){\n        tree = container_type(size_, value_structure::identity());\n        tree.insert(tree.end(), first, last);\n        for(size_type i = size_;i > 0;i--){\n            calc_node(i);\n        }\n    }\n\n    size_type size() const { return size_; }\n    const_reference operator[](const size_type k) const {\n        assert(k < size_);\n        return tree[k+size_];\n    }\n\n    value_type query(size_type l, size_type r){\n        assert(l <= r);\n        assert(0 <= l && l < size_);\n        assert(0 <= r && r <= size_);\n        value_type retl = value_structure::identity(), retr = value_structure::identity();\n        for(l += size_, r += size_; l < r ; l >>= 1, r >>= 1){\n            if(l&1) retl = calc(retl, tree[l++]);\n            if(r&1) retr = calc(tree[--r], retr);\n        }\n        return calc(retl, retr);\n    }\n\n    template<class F>\n    void update(size_type index, const F& f){\n        assert(0 <= index && index < size());\n        index += size_;\n        tree[index] = f(::std::move(tree[index]));\n        while(index >>= 1)\n            calc_node(index);\n    }\n\n    /*\n    template<class F>\n    size_type search(const F& f) const { // [0, result) is True and [0, result-1) is not.\n        if(f(value_structure::identity()))\n            return 0;\n        if(!f(tree[1]))\n            return size_+1;\n        value_type acc = value_structure::identity();\n        size_type i = 1;\n        while(i <\n    }\n    */\n};\n\nclass v_monoid {\npublic:\n    using value_type = PLL;\n    static value_type identity() { return PLL(-INF_LL, -INF_LL); }\n    static value_type initializer() { return {0, 0}; }\n    static value_type operation(const value_type& a, const value_type& b) {\n        if (a == identity()) return b;\n        if (b == identity()) return a;\n        return {max(a.fs+b.fs, a.sc+b.sc), max(a.fs+b.sc, a.sc+b.fs)};\n    }\n};\n\nint main(void) {\n    int64 N, Q;\n    cin >> N >> Q;\n    N *= 2;\n    vector<int64> a(N), b(N);\n    REP(i, N) cin >> a[i];\n    REP(i, N) cin >> b[i];\n    multiset<int64> as, bs;\n    int64 res = a[0] + a.back();\n    SegTree<v_monoid> sg(N);\n    FOR(i, 1, N-1) {\n        sg.update(i, [&](const PLL x) { return PLL(a[i], b[i]); });\n    }\n    REP(i, Q) {\n        int64 p, x, y;\n        cin >> p >> x >> y; p--;\n        if (p == 0 || p == N-1) {\n            res -= a[p]; res += x;\n            a[p] = x;\n        } else {\n            sg.update(p, [&](const PLL alskdj) { return PLL(x, y); });\n        }\n        cout << res + sg.query(1, N-1).fs << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define REP(e,v) for(auto e:v)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\n#define MAX_V 400010\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\nll MOD=1e9+7;\n#define N 1055050\n\nll n,m,k;\nll a[N],b[N];\ntemplate< typename Monoid >\nstruct SegmentTree {\n  using F = function< Monoid(Monoid, Monoid) >;\n \n  int sz;\n  vector< Monoid > seg;\n \n  const F f;\n  const Monoid M1;\n \n  SegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1) {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz, M1);\n  }\n \n  void set(int k, const Monoid &x) {\n    seg[k + sz] = x;\n  }\n \n  void build() {\n    for(int k = sz - 1; k > 0; k--) {\n      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n    }\n  }\n \n  void update(int k, const Monoid &x) {\n    k += sz;\n    seg[k] = x;\n    while(k >>= 1) {\n      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n    }\n  }\n \n  Monoid query(int a, int b) {\n    Monoid L = M1, R = M1;\n    for(a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n      if(a & 1) L = f(L, seg[a++]);\n      if(b & 1) R = f(seg[--b], R);\n    }\n    return f(L, R);\n  }\n \n  Monoid operator[](const int &k) const {\n    return seg[k + sz];\n  }\n};\n//SegmentTree(n,f,M1) nで初期化　fは二項演算　M1は単位元\n//set(k,x) 要素k = x\n//build() 構築\n//query 区間[a,b)に二項演算\n//update(k,x) kをxに\n//operator[k] k番目の要素\n// SegmentTree< int > seg(N,[](int a,int b){return min(a,b);},INF);\n//みたいに使う\nmain(){\n    n=in();\n    int q=in();\n    SegmentTree<ll> seg(n*2+1,[](ll a,ll b){return min(a,b);},LLINF),seg2(n*2+1,[](ll a,ll b){return min(a,b);},LLINF);\n    ll sum=0;\n    rep(i,n*2){\n        a[i]=in();\n        sum+=a[i];\n    }\n    int count=0;\n    ll dif=0;\n    rep(i,n*2){\n        b[i]=in();\n        if(i==0||i==n*2-1)continue;\n        if(b[i]>a[i]){\n            seg.set(i,b[i]-a[i]);\n            dif+=b[i]-a[i];\n            count++;\n        }\n        else{\n            seg2.set(i,a[i]-b[i]);\n        }\n    }\n    seg.build();seg2.build();\n    rep(iii,q){\n        int p=in();p--;\n        ll prea=a[p],preb=b[p];\n        a[p]=lin();b[p]=in();\n        sum+=a[p]-prea;\n        if(p==0||p==n*2-1){\n            goto G;\n        }\n        if(preb>prea){\n            count--;\n            dif-=preb-prea;\n        }\n        else{\n            seg2.update(p,LLINF);\n        }\n        if(b[p]>a[p]){\n            count++;\n            seg.update(p,b[p]-a[p]);\n            dif+=b[p]-a[p];\n        }\n        else{\n            seg2.update(p,a[p]-b[p]);\n        }\n        G:\n        if(count%2){\n            ll ans=sum+dif;\n            ans+=max(-seg.query(0,2*n),-seg2.query(0,2*n));\n            cout<<ans<<endl;\n        }\n        else cout<<sum+dif<<endl;\n    }\n}\n/*1 4 7 3\n4 6 3 3\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  Int n;\n  F f;\n  G g;\n  T ti;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(Int n_,F f,G g,T ti):\n    f(f),g(g),ti(ti){\n    init(n_);\n  }\n  void init(Int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.assign(2*n-1,ti);\n  }\n  void build(Int n_, vector<T> v){\n    for(Int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(Int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(Int k,E a){\n    k+=n-1;\n    dat[k]=g(dat[k],a);\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  \n  inline T query(Int a,Int b){\n    T vl=ti,vr=ti;\n    for(Int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[(l++)-1]);\n      if(r&1) vr=f(dat[(--r)-1],vr);\n    }\n    return f(vl,vr);\n  }\n\n  Int find(Int a,Int b,function<bool(T)> &check,Int k,Int l,Int r){\n    if(!check(dat[k])||r<=a||b<=l) return -1;\n    if(k>=n-1) return k-(n-1);\n    Int m=(l+r)>>1;\n    Int vl=find(a,b,check,k*2+1,l,m);\n    if(~vl) return vl;\n    return find(a,b,check,k*2+2,m,r);\n  }\n  \n  Int find(Int a,Int b,function<bool(T)> &check){\n    return find(a,b,check,0,0,n);\n  }\n  \n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,q;\n  cin>>n>>q;\n  n*=2;\n  vector<Int> a(n),b(n);\n  for(Int i=0;i<n;i++) cin>>a[i];\n  for(Int i=0;i<n;i++) cin>>b[i];\n  \n  using P = pair<Int, Int>;\n  auto f=[](P a,P b){return P(max(a.first+b.first ,a.second+b.second),\n\t\t\t      max(a.first+b.second,a.second+b.first));};\n  auto g=[](P a,P b){return b;};\n\n  const Int INF = 1e15;\n  SegmentTree<P, P> seg(n,f,g,P(0,-INF));\n  vector<P> v(n);\n  for(Int i=0;i<n;i++) v[i]=P(a[i],b[i]);\n  seg.build(n,v);\n  \n  for(Int i=0;i<q;i++){\n    Int p,x,y;\n    cin>>p>>x>>y;\n    p--;\n    a[p]=x;b[p]=y;\n    seg.update(p,P(a[p],b[p]));\n    Int ans=a[0]+a[n-1]+seg.query(1,n-1).first;\n    cout<<ans<<endl;\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, q;\n    cin >> n >> q;\n    assert(n * q <= 100000);\n    vector<ll> a(2 * n), b(2 * n);\n    for (int i = 0; i < 2 * n; i++)\n        cin >> a[i];\n    for (int i = 0; i < 2 * n; i++)\n        cin >> b[i];\n    while (q--)\n    {\n        ll p, x, y;\n        cin >> p >> x >> y;\n        p--;\n        a[p] = x;\n        b[p] = y;\n        vector<vector<ll>> dp(2 * n, vector<ll>(2, -1e15));\n        dp[0][0] = a[0];\n        for (int i = 1; i < 2 * n - 1; i++)\n        {\n            dp[i][0] = max(dp[i - 1][0] + a[i], dp[i - 1][1] + b[i]);\n            dp[i][1] = max(dp[i - 1][0] + b[i], dp[i - 1][1] + a[i]);\n        }\n        dp[2 * n - 1][0] = dp[2 * n - 2][0] + a[2 * n - 1];\n        cout << dp[2 * n - 1][0] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n\n#define ll long long\nusing namespace std;\nll bit[400010],a[200010],b[200010],p[100010],x[100010],y[100010],n,q,inv[300010],m;\nvector<ll> v;\nmap<ll,ll> mp;\nll sum(ll i){\n\tll s = 0;\n\twhile(i>0){\n\t\ts += bit[i];\n\t\ti -= i&-i;\n\t}\n\treturn s;\n}\n\nvoid add(ll i, ll x){\n\twhile(i<=m){\n\t\tbit[i] += x;\n\t\ti += i&-i;\n\t}\n}\nint main(){\n\tll z,ans=0,i;\n\tcin >> n >> q;\n\tfor(i=0;i<2*n;i++){\n\t\tcin >> a[i];\n\t}\n\tfor(i=0;i<2*n;i++){\n\t\tcin >> b[i];\n\t}\n\tfor(i=1;i<2*n-1;i++){\n\t\tv.push_back(a[i]-b[i]);\n\t}\n\tfor(i=0;i<q;i++){\n\t\tcin >> p[i] ;\n\t\tp[i]--;\n\t\tcin>> x[i] >> y[i];\n\t\tif(p[i]!=0 && p[i]!=2*n-1){\n\t\t\tv.push_back(x[i]-y[i]);\n\t\t}\n\t}\n\tv.push_back(0);\n\tsort(v.begin(),v.end());\n\tm = v.size()+1;\n\tint now = 1;\n\tmp[v[0]] = 1;\n\tinv[1] = v[0];\n\tif(v[0]==0){\n\t\tz = 1;\n\t}\n\tfor(i=1;i<v.size();i++){\n\t\tif(v[i]>v[i-1]){\n\t\t\tnow++;\n\t\t}\n\t\tmp[v[i]] = now;\n\t\tinv[now] = v[i];\n\t\tif(v[i]==0){\n\t\t\tz = now;\n\t\t}\n\t}\n\tnow++;\n\tll cnt = 0;\n\tfor(i=1;i<2*n-1;i++){\n\t\tadd(mp[a[i]-b[i]],1);\n\t\tif(a[i]>=b[i]){\n\t\t\tans += a[i];\n\t\t\tcnt += 1;\n\t\t}else{\n\t\t\tans += b[i];\n\t\t}\n\t}\n\tfor(i=1;i<now;i++){\n\t\t//cout << i << \" \" << sum(i) << endl;\n\t}\n\tfor(i=0;i<now;i++){\n\t\t//cout << i << \" \" << inv[i] << endl;\n\t}\n\tfor(i=0;i<now;i++){\n\t\t//cout << i << \" \" << sum(i) << endl;\n\t}\n\tans += a[0]+a[2*n-1];\n\tfor(i=0;i<q;i++){\n\t\tif(p[i]==0 || p[i]==2*n-1){\n\t\t\t//cout << ans << endl;\n\t\t\tans -= a[p[i]];\n\t\t\tans += x[i];\n\t\t\t//cout << p[i] << \" \" << a[p[i]] << \" \" << x[i] << endl;\n\t\t\ta[p[i]] = x[i];\n\t\t\tb[p[i]] = y[i];\n\t\t}else{\n\t\t\tans -= max(a[p[i]],b[p[i]]);\n\t\t\tans += max(x[i],y[i]);\n\t\t\t//cout << a[p[i]] << \" \" << b[p[i]] << \" \" << x[i] << \" \" << y[i] << \" \" << ans <<\" \" << cnt<< endl;\n\t\t\tfor(int j=0;j<now;j++){\n\t\t\t\t//cout << j << \" \" << sum(j) << endl;\n\t\t\t}\n\t\t\tadd(mp[a[p[i]] - b[p[i]]],-1);\n\t\t\tadd(mp[x[i] - y[i]],1);\n\t\t\tif(a[p[i]]-b[p[i]]>0 ^ x[i]-y[i]>0){\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\ta[p[i]] = x[i];\n\t\t\tb[p[i]] = y[i];\n\t\t}\n\t\t//cout << ans << \" \" << cnt << endl;\n\t\tif(cnt%2==0){\n\t\t\tcout << ans << endl;\n\t\t}else{\n\t\t\tlong long l=0,r=now,mid;\n\t\t\tint s = sum(z);\n\t\t\t//cout << i << \" \"  << p[i] << \" \" << x[i] << \" \" << y[i] << endl;\n\t\t\t//cout << l << \" \" << r << \" \" << z << endl;\n\t\t\t//cout << s << endl;\n\t\t\twhile(r - l>1){\n\t\t\t\t//cout << l << \" \" << r << \" \" << endl;\n\t\t\t\tmid = (l+r)/2;\n\t\t\t\tif(sum(mid)>=s+1){\n\t\t\t\t\tr = mid;\n\t\t\t\t}else{\n\t\t\t\t\tl = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << r << endl;\n\t\t\tlong long m1 = inv[r];\n\t\t\tl=0,r=now;\n\t\t\twhile(r - l>1){\n\t\t\t\t//cout << l << \" \" << r << endl;\n\t\t\t\tmid = (l+r)/2;\n\t\t\t\tif(sum(mid)<s){\n\t\t\t\t\tl = mid;\n\t\t\t\t}else{\n\t\t\t\t\tr = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << r << endl;\n\t\t\tlong long m2 = inv[r];\n\t\t\t//cout << m1 << \" \" << m2 << \" \" << endl;\n\t\t\tcout << max(ans - m1,ans + m2) << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nstruct Query\n{\n    using type = P;\n    static type id() { return P(0, -1e15); }\n    static type op(const type &l, const type &r) { return P(max(l.first + r.first, l.second + r.second), max(l.first + r.second, l.second + r.first)); }\n};\n\ntemplate <typename M>\nclass SegmentTree\n{\n    using T = typename M::type;\n    int n;\n    std::vector<T> node;\n\n  public:\n    // v を基に初期化\n    SegmentTree(const std::vector<T> &v)\n    {\n        // n は v.size() 以上の最小の2冪\n        n = 1;\n        while (n < int(v.size()))\n            n *= 2;\n        node.resize(2 * n - 1, M::id());\n\n        // i の子 -> 2*i+1, 2*i+2 , 親 -> (i-1)/2\n        for (int i = 0; i < int(v.size()); i++)\n            node[i + n - 1] = v[i];\n        for (int i = n - 2; i >= 0; i--)\n            node[i] = M::op(node[2 * i + 1], node[2 * i + 2]);\n    }\n    // Monoid::id 初期化\n    SegmentTree(int _n)\n    {\n        // n は v.size() 以上の最小の2冪\n        n = 1;\n        while (n < _n)\n            n *= 2;\n        node.resize(2 * n - 1, M::id());\n    }\n    // x 番目を val に更新\n    void update(int x, T val)\n    {\n        x += n - 1;\n        node[x] = val;\n        while (x > 0)\n        {\n            x = (x - 1) / 2;\n            node[x] = M::op(node[2 * x + 1], node[2 * x + 2]);\n        }\n    }\n    // v[x] を M::op(v[x], val) に更新\n    void add(int x, T val)\n    {\n        x += n - 1;\n        node[x] = M::op(node[x], val);\n        while (x > 0)\n        {\n            x = (x - 1) / 2;\n            node[x] = M::op(node[2 * x + 1], node[2 * x + 2]);\n        }\n    }\n    // [a, b) の op\n    // k := 今居るノード\n    T query(int a, int b, int k = 0, int l = 0, int r = -1)\n    {\n        if (r < 0)\n            r = n;\n        if (r <= a || b <= l)\n            return M::id();\n        if (a <= l && r <= b)\n            return node[k];\n\n        T vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n        T vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n        return M::op(vl, vr);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, q;\n    cin >> n >> q;\n    vector<ll> a(2 * n), b(2 * n);\n    vector<P> v;\n    for (int i = 0; i < 2 * n; i++)\n        cin >> a[i];\n    for (int i = 0; i < 2 * n; i++)\n    {\n        cin >> b[i];\n        v.emplace_back(P(a[i], b[i]));\n    }\n    SegmentTree<Query> st(v);\n    while (q--)\n    {\n        ll p, x, y;\n        cin >> p >> x >> y;\n        p--;\n        a[p] = x;\n        b[p] = y;\n        st.update(p, P(x, y));\n        ll ret = a[0] + a[2 * n - 1] + st.query(1, 2 * n - 1).first;\n        cout << ret << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(LL i=0;i<(LL)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n#define LL long long\n#define pii pair<LL,LL>\n#define pll pair<LL,LL>\n\nusing namespace std;\n\nstruct SegmentTree{\n\n    LL n;\n    vector<LL> data;\n    vector<LL> num;\n    vector<LL> minusmax;\n    vector<LL> plusmin;\n\n    SegmentTree(LL _n){\n        n = 2;\n        while(n<_n)n*=2;\n        data.resize(2*n-1, INT_MIN);\n        num.resize(2*n-1, 0);\n        minusmax.resize(2*n-1, INT_MIN);\n        plusmin.resize(2*n-1, INT_MAX);\n    }\n\n    void set(LL pos, LL x){\n        pos += n-1;\n        data[pos]=x;\n        if(x > 0){\n            num[pos] = 1;\n            plusmin[pos] = x;\n            minusmax[pos] = INT_MIN;\n        }else{\n            num[pos]=0;\n            minusmax[pos] = x;\n            plusmin[pos] = INT_MAX;\n        }\n        while(pos > 0){\n            pos = (pos-1)/2;\n            data[pos] = (max(0LL, data[2*pos +1]) + max(0LL, data[2*pos +2]));\n            num[pos] = num[2*pos +1] + num[2*pos + 2];\n            minusmax[pos] = max(minusmax[2*pos + 1], minusmax[2*pos + 2]);\n            plusmin[pos] = min(plusmin[2*pos + 1], plusmin[2*pos + 2]);\n        }\n    }\n\n    LL getSum(LL l, LL r, LL a=0, LL b=-1, LL pos=0){\n        if(b<0)b=n;\n        if(l>=b || r <= a)return 0;\n        if(l<=a && r <= b)return max(0LL,data[pos]);\n        return getSum(l, r, a, (a+b)/2, pos*2+1) + getSum(l, r, (a+b)/2, b, pos*2+2);\n    }\n    LL getNum(LL l,LL r, LL a=0, LL b=-1, LL pos=0){\n        if(b<0)b=n;\n        if(l>=b || r <= a)return 0;\n        if(l<=a && r <= b)return num[pos];\n        return getNum(l, r, a, (a+b)/2, pos*2+1) + getNum(l, r, (a+b)/2, b, pos*2+2);\n    }\n    LL getMinusMax(LL l,LL r,LL a=0, LL b=-1, LL pos=0){\n        if(b<0)b=n;\n        if(l>=b || r <= a)return INT_MIN;\n        if(l<=a && r <= b)return minusmax[pos];\n        return max(getMinusMax(l, r, a, (a+b)/2, pos*2+1) ,getMinusMax(l, r, (a+b)/2, b, pos*2+2));\n    }\n    LL getPlusMin(LL l,LL r,LL a=0, LL b=-1, LL pos=0){\n        if(b<0)b=n;\n        if(l>=b || r <= a)return INT_MAX;\n        if(l<=a && r <= b)return plusmin[pos];\n        return min(getPlusMin(l, r, a, (a+b)/2, pos*2+1) ,getPlusMin(l, r, (a+b)/2, b, pos*2+2));\n    }\n\n    void printData(){\n        cout<<endl;\n        REP(i,n)cout<<n-1+i<<\" \"<<data[n-1+i]<<endl;\n        cout<<endl;\n    }\n};\n\n\nint main(){\n\n    LL N,Q;cin>>N>>Q;\n    LL ans=0;\n    LL a[2*N], b[2*N];\n\n    REP(i,2*N)cin>>a[i];\n    REP(i,2*N)cin>>b[i];\n\n    if(N==1){\n        while(Q--){\n            LL p,x,y;cin>>p>>x>>y;\n            a[--p]=x;\n            ans = a[0]+a[1];\n            cout<<ans<<endl;\n        }\n    }else{\n        REP(i,2*N)ans += a[i];\n        SegmentTree st(2*N-2);\n        REP(i,2*N-2)st.set(i, b[i+1]-a[i+1]);\n\n        while(Q--){\n            LL p,x,y;cin>>p>>x>>y;\n            ans -= a[--p];\n            a[p]=x;\n            b[p]=y;\n            ans += a[p];\n            st.set(p-1, y-x);\n\n            LL res = ans + st.getSum(0,2*N-2);\n            if(st.getNum(0,2*N-2)%2==1){\n                res = max(res - st.getPlusMin(0,2*N-2), res + st.getMinusMax(0,2*N-2));\n            }\n\n\n            cout<<res<<endl;\n\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll inf=1000000000000000000;\nll dat[800010];\nll u;\nvoid seginit(ll n){\n  for(int i=0;;i++){\n    ll y=pow(2,i);\n    if(y>=n){\n      u=y;\n      break;\n    }\n  }\n  fill(dat,dat+2*u,inf);\n}\nvoid add(ll n,ll x){\n  ll i=n+u-1;\n  dat[i]=x;\n  while(i>0){\n    i=(i-1)/2;\n    dat[i]=min(dat[2*i+1],dat[i*2+2]);\n  }\n}\nll que(ll a,ll b,ll k,ll l,ll r){\n  if(a>=r||b<=l)return inf;\n  if(a<=l&&b>=r)return dat[k];\n  ll m1=que(a,b,2*k+1,l,(l+r)/2);\n  ll m2=que(a,b,2*k+2,(l+r)/2,r);\n  return min(m1,m2);\n}\n\nint main(){\n  ll n,q;cin>>n>>q;\n  seginit(2*n);\n  ll a[2*n],b[2*n];\n  for(int i=0;i<2*n;i++)cin>>a[i];\n  ll sum=0;\n  ll c=0;\n  for(int i=0;i<2*n;i++){\n    cin>>b[i];\n    if(i==0||i==2*n-1){\n      sum+=a[i];\n    }\n    else{\n      if(a[i]>=b[i]){\n        sum+=a[i];\n        add(i,a[i]-b[i]);\n      }\n      else{\n        c=(c+1)%2;\n        sum+=b[i];\n        add(i,b[i]-a[i]);\n      }\n    }\n  }\n  for(int i=0;i<q;i++){\n    ll p,x,y;cin>>p>>x>>y;\n    p--;\n    if(p==0||p==2*n-1){\n      sum+=-a[p]+x;\n      cout<<sum<<endl;\n      continue;\n    }\n    if((a[p]-b[p])*(x-y)<0){\n      c=(c+1)%2;\n    }\n    //cout<<c<<endl;\n    sum+=-max(a[p],b[p])+max(x,y);\n    add(p,abs(x-y));\n    ll f=0;\n    if(c==1){\n      f=que(1,2*n-1,0,0,2*n);\n    }\n    a[p]=x;\n    b[p]=y;\n    cout<<sum-f<<endl;\n  }\n}\n        \n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint N, Q;\nll A[MAX_N], B[MAX_N]; //[0, 2 * N) !!\nmultiset<ll> S;\n\nvoid solve() {\n\tcin >> N >> Q;\n\trep(i, 0, 2 * N) cin >> A[i];\n\trep(i, 0, 2 * N) cin >> B[i];\n\n\tll ans = 0; bool odd = false;\n\tans += A[0] + A[2 * N - 1];\n\trep(i, 1, 2 * N - 1) {\n\t\tans += max(A[i], B[i]);\n\t\todd ^= (A[i] > B[i]);\n\t\tS.insert(abs(A[i] - B[i]));\n\t}\n\twhile(Q--) {\n\t\tll a, x, y;\n\t\tcin >> a >> x >> y; a--;\n\t\tif(a == 0 || a == 2 * N - 1) {\n\t\t\tans += x - A[a];\n\t\t\tA[a] = x;\n\t\t}\n\t\telse {\n\t\t\todd ^= (A[a] > B[a]);\n\t\t\todd ^= (x > y);\n\t\t\tans += max(x, y) - max(A[a], B[a]);\n\t\t\tS.erase(S.lower_bound(abs(A[a] - B[a])));\n\t\t\tS.insert(abs(x - y));\n\t\t\tA[a] = x; B[a] = y;\n\t\t}\n\t\tcout << (!odd ? ans : ans - (*S.begin())) << \"\\n\";\n\t}\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  LL N, Q;\n  cin >> N >> Q;\n\n  VL as(N*2), bs(N*2);\n  cin >> as >> bs;\n\n  if(N == 1){\n    while(Q--){\n    int p, x, y;\n    cin >> p >> x >> y;\n    --p;\n    as[p] = x;\n    bs[p] = y;\n    cout<<as[0]+as[1]<<endl;      \n    }\n    return 0;\n  }\n\n  int par = 0;\n  LL sum = as[0] + as.back();\n  multiset<LL> dels;\n  FOR(i,1,2*N-1){\n    LL mx = max(as[i], bs[i]);\n    LL mn = min(as[i], bs[i]);\n    sum += mx;\n    if(mx == as[i]) par ^= 1;\n    dels.insert(mn - mx);\n  }\n\n  while(Q--){\n    LL p, x, y;\n    cin >> p >> x >> y;\n    --p;\nif(p==0||p==2*N-1){\nsum-=as[p]-x;\ncout<<sum<<endl;continue;\n}\n    LL mx = max(as[p], bs[p]);\n    LL mn = min(as[p], bs[p]);\n    sum -= mx;\n    if(mx == as[p]) par ^= 1;\n    auto it = dels.find(mn - mx);\n    dels.erase(it);\n\n    as[p] = x;\n    bs[p] = y;\n    LL mx2 = max(as[p], bs[p]);\n    LL mn2 = min(as[p], bs[p]);\n    sum += mx2;\n    if(mx2 == as[p]) par ^= 1;\n    dels.insert(mn2 - mx2);\n\n    LL ans = 0;\n    if(par == 0){\n      ans = sum;\n    }\n    else{\n      auto it = dels.rbegin();\n      assert(it != dels.rend());\n      ans = sum + *it;\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 200100\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> par;\npar s[maxn<<2];\nint n,a[maxn],b[maxn],q;\nvoid upd(int o){\n\ts[o].first=max(s[o<<1].first+s[o<<1|1].first,s[o<<1].second+s[o<<1|1].second);\n\ts[o].second=max(s[o<<1].second+s[o<<1|1].first,s[o<<1].first+s[o<<1|1].second); \n}\nvoid build(int o,int l,int r){\n\tif(l==r){\n\t\ts[o]=par(b[l],a[l]);\n\t\treturn ;\n\t}\n\tint mid=l+r>>1;\n\tbuild(o<<1,l,mid);\n\tbuild(o<<1|1,mid+1,r);\n\tupd(o);\n}\nvoid mdy(int o,int l,int r,int k,par p){\n\tif(l==r){\n\t\ts[o]=p;\n\t\treturn ;\n\t}\n\tint mid=l+r>>1;\n\tif(k<=mid)mdy(o<<1,l,mid,k,p);\n\telse mdy(o<<1|1,mid+1,r,k,p);\n\tupd(o);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=2*n;++i)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=2*n;++i)scanf(\"%d\",&b[i]);\n\tif(n>1)build(1,2,2*n-1);\n\tfor(int i=1,p,x,y;i<=q;++i){\n\t\tscanf(\"%d%d%d\",&p,&x,&y);\n\t\tif(2<=p&&p<=2*n-1)mdy(1,2,2*n-1,p,par(y,x));\n\t\telse a[p]=x,b[p]=y;\n\t\tprintf(\"%lld\\n\",a[1]+a[2*n]+s[1].first); \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,a) for(int i=0;i<(a);i++)\nconst ll MOD=1000000007;\n\nll A[202020], B[202020];\n\nint main(){\n  int N,Q; cin>>N>>Q;\n  ll S=0;\n  rep(i,2*N){\n    cin>>A[i];\n    S+=A[i];\n  }\n  map<ll,int> p,m;\n  ll T=0;\n  rep(i,2*N){\n    cin>>B[i];\n    B[i]-=A[i];\n    if(i!=0&&i!=2*N-1){\n      if(B[i]>0){\n        p[B[i]]++;\n        T+=B[i];\n      }else{\n        m[-B[i]]++;\n      }\n    }\n  }\n  while(Q--){\n    ll i,x,y; cin>>i>>x>>y; i--;\n    S-=A[i];\n    if(i!=0&&i!=2*N-1){\n      if(B[i]>0){\n        p[B[i]]--;\n        if(p[B[i]]==0) p.erase(B[i]);\n        T-=B[i];\n      }else{\n        m[-B[i]]--;\n        if(m[B[i]]==0) m.erase(B[i]);\n      }\n    }\n\n    A[i]=x;\n    S+=A[i];\n    B[i]=y-x;\n    if(i!=0&&i!=2*N-1){\n      if(B[i]>0){\n        p[B[i]]++;\n        T+=B[i];\n      }else{\n        m[-B[i]]++;\n      }\n    }\n\n    ll ans;\n    if(p.size()%2==0) ans=S+T;\n    else{\n      auto pp=p.begin(), mm=m.begin();\n      ans=S+max(T-pp->first,T-mm->first);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tint N, Q;\n\twhile(cin >> N >> Q){\n\t\tlong long res = 0;\n\t\tvector<long long> a(2*N), dif(2*N);\n\t\tfor(auto& t : a) cin >> t;\n\t\tfor(int i=0;i<2*N;i++){\n\t\t\tres += a[i];\n\t\t\tcin >> dif[i];\n\t\t\tdif[i] -= a[i];\n\t\t}\n\t\tvector<pair<long long, int>> v;\n\t\tfor(int i=1;i<2*N-1;i++){\n\t\t\tv.emplace_back(dif[i], i);\n\t\t}\n\t\tsort(v.rbegin(), v.rend());\n\t\tusing Data = pair<long long, pair<int,int>>;\n\t\tpriority_queue<Data> no_use;\n\t\tpriority_queue<Data, vector<Data>, greater<Data>> use;\n\t\tvector<int> type(2*N, 0);\n\t\tvector<int> update(2*N, -1);\n\t\tvector<int> typeCnt(2, 0);\n\t\ttypeCnt[0] = 2*N-2;\n\t\tfor(int i=0;i+1<v.size();i+=2){\n\t\t\tif(v[i].first + v[i+1].first >= 0){\n\t\t\t\tres += v[i].first + v[i+1].first;\n\t\t\t\ttype[v[i].second] = 1;\n\t\t\t\ttype[v[i+1].second] = 1;\n\t\t\t\ttypeCnt[0] -= 2;\n\t\t\t\ttypeCnt[1] += 2;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<2*N-1;i++){\n\t\t\tif(type[i]==0) no_use.emplace(dif[i], make_pair(i, -1));\n\t\t\tif(type[i]==1) use.emplace(dif[i], make_pair(i, -1));\n\t\t}\n\t\tauto removeOld = [&](auto& qu, int useType){\n\t\t\twhile(!qu.empty()){\n\t\t\t\tauto data = qu.top();\n\t\t\t\tauto idx = data.second.first;\n\t\t\t\tif(type[idx] == useType && update[idx] == data.second.second) break;\n\t\t\t\tqu.pop();\n\t\t\t}\n\t\t};\n\t\tauto removeOldUse = [&](){ removeOld(use, 1); };\n\t\tauto removeOldNoUse = [&](){ removeOld(no_use, 0); };\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tlong long p, x, y; cin >> p >> x >> y;\n\t\t\t--p;\n\t\t\tres += x - a[p];\n\t\t\tif(0 < p && p < 2*N-1){\n\t\t\t\tif(type[p] == 1){\n\t\t\t\t\tres += y - x - dif[p];\n\t\t\t\t\tuse.emplace(y-x, make_pair(p, i));\n\t\t\t\t} else {\n\t\t\t\t\tno_use.emplace(y-x, make_pair(p, i));\n\t\t\t\t}\n\t\t\t}\n\t\t\ta[p] = x;\n\t\t\tdif[p] = y - x;\n\t\t\tupdate[p] = i;\n\t\t\tif(0 < p && p < 2*N-1){\n\t\t\t\tremoveOldUse();\n\t\t\t\tremoveOldNoUse();\n\t\t\t\tif(typeCnt[0] > 0 && typeCnt[1] > 0 && use.top().first < no_use.top().first){\n\t\t\t\t\tauto d1 = use.top(); use.pop();\n\t\t\t\t\tauto d2 = no_use.top(); no_use.pop();\n\t\t\t\t\tres += d2.first - d1.first;\n\t\t\t\t\tuse.push(d2);\n\t\t\t\t\tno_use.push(d1);\n\t\t\t\t\ttype[d2.second.first] = 1;\n\t\t\t\t\ttype[d1.second.first] = 0;\n\t\t\t\t}\n\t\t\t\tif(typeCnt[1] > 0){\n\t\t\t\t\tremoveOldUse();\n\t\t\t\t\tauto d1 = use.top(); use.pop();\n\t\t\t\t\tremoveOldUse();\n\t\t\t\t\tauto d2 = use.top(); use.pop();\n\t\t\t\t\tif(d1.first + d2.first < 0){\n\t\t\t\t\t\tres -= d1.first + d2.first;\n\t\t\t\t\t\ttype[d1.second.first] = 0;\n\t\t\t\t\t\ttype[d2.second.first] = 0;\n\t\t\t\t\t\ttypeCnt[0] += 2;\n\t\t\t\t\t\ttypeCnt[1] -= 2;\n\t\t\t\t\t\tno_use.emplace(d1);\n\t\t\t\t\t\tno_use.emplace(d2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tuse.emplace(d1);\n\t\t\t\t\t\tuse.emplace(d2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(typeCnt[0] > 0){\n\t\t\t\t\tremoveOldNoUse();\n\t\t\t\t\tauto d1 = no_use.top(); no_use.pop();\n\t\t\t\t\tremoveOldNoUse();\n\t\t\t\t\tauto d2 = no_use.top(); no_use.pop();\n\t\t\t\t\tif(d1.first + d2.first >= 0){\n\t\t\t\t\t\tres += d1.first + d2.first;\n\t\t\t\t\t\ttype[d1.second.first] = 1;\n\t\t\t\t\t\ttype[d2.second.first] = 1;\n\t\t\t\t\t\ttypeCnt[0] -= 2;\n\t\t\t\t\t\ttypeCnt[1] += 2;\n\t\t\t\t\t\tuse.emplace(d1);\n\t\t\t\t\t\tuse.emplace(d2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tno_use.emplace(d1);\n\t\t\t\t\t\tno_use.emplace(d2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200005;\n\nint n, q;\nint a[N], b[N];\nmultiset<long long> ms;\nlong long sum;\n\nint main() {\n\tios_base::sync_with_stdio(false); cin.tie(0);\n\n\tcin >> n >> q;\n\n\tfor (int i = 1; i <= 2 * n; ++i) cin >> a[i];\n\tfor (int i = 1; i <= 2 * n; ++i) cin >> b[i];\n\n\tfor (int i = 1; i <= 2 * n; ++i) {\n\t\tsum += a[i];\n\t\tif (i != 1 && i != 2 * n) ms.insert(b[i] - a[i]);\n\t}\n\n\twhile(q--) {\n\t\tint p, x, y; cin >> p >> x >> y;\n\t\tsum -= a[p];\n\t\tsum += x;\n\t\tif (p != 1 && p != 2 * n) {\n\t\t\tms.erase(ms.find(b[p] - a[p]));\n\t\t\tms.insert(y - x);\n\t\t}\n\t\ta[p] = x;\n\t\tb[p] = y;\n\n\t\tmultiset<long long> ns = ms;\n\t\tlong long nsum = sum;\n\t\twhile(ns.size() > 1) {\n\t\t\tlong long k = (*ns.rbegin()); ns.erase(--ns.end());\n\t\t\tlong long l = (*ns.rbegin()); ns.erase(--ns.end());\n\n\t\t\tif (k + l > 0) {\n\t\t\t\tnsum += k + l;\n\t\t\t} else break;\n\t\t}\n\n\t\tprintf(\"%lld\\n\", nsum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <functional>\n#include <vector>\nusing namespace std;\n\nlong long N, Q, a[200009], b[200009], c[200009], ne[200009], s = 0, T1 = 0, T2 = 0; bool I[600009];\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> posi;\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, less<pair<long long, long long>>>nega;\n\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 1; i <= 2 * N; i++)cin >> a[i];\n\tfor (int i = 1; i <= 2 * N; i++)cin >> b[i];\n\tfor (int i = 1; i <= 2 * N; i++) {\n\t\tc[i] = b[i] - a[i]; s += a[i]; I[i] = true; ne[i] = i;\n\t\tif (i >= 2 && i <= 2 * N - 1) {\n\t\t\tif (c[i] >= 0) { posi.push(make_pair(c[i], i)); T1++; T2 += c[i]; }\n\t\t\telse nega.push(make_pair(c[i], i));\n\t\t}\n\t}\n\tfor (int i = 1; i <= Q; i++) {\n\t\tint p1, p2, p3; cin >> p1 >> p2 >> p3;\n\t\tlong long to = p3 - p2; if (c[p1] >= 0) { T2 -= c[p1]; T1--; }I[ne[p1]] = false;\n\t\twhile (!posi.empty() && I[posi.top().second] == false)posi.pop();\n\t\twhile (!nega.empty() && I[nega.top().second] == false)nega.pop();\n\t\tif (to >= 0) { posi.push(make_pair(to, 2 * N + i)); T2 += to; T1++; }\n\t\telse nega.push(make_pair(to, 2 * N + i));\n\t\ts += (p2 - a[p1]); a[p1] = p2; b[p1] = p3; c[p1] = to;\n\t\tif (T1 % 2 == 0) { cout << T2 + s << endl; }\n\t\telse {\n\t\t\tlong long V1 = T2 - posi.top().first;\n\t\t\tlong long V2 = -(1LL << 60); if (!nega.empty())V2 = T2 + nega.top().first;\n\t\t\tcout << max(V1, V2) + s << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  LL N, Q;\n  cin >> N >> Q;\n\n  VL as(N*2), bs(N*2);\n  cin >> as >> bs;\n\n  if(N == 1){\n    while(Q--){\n    int p, x, y;\n    cin >> p >> x >> y;\n    --p;\n    as[p] = x;\n    bs[p] = y;\n    cout<<as[0]+as[1]<<endl;      \n    }\n    return 0;\n  }\n\n  int par = 0;\n  LL sum = as[0] + as.back();\n  multiset<LL> dels;\n  FOR(i,1,2*N-1){\n    LL mx = max(as[i], bs[i]);\n    LL mn = min(as[i], bs[i]);\n    sum += mx;\n    if(mx == as[i]) par ^= 1;\n    dels.insert(mn - mx);\n  }\n\n  while(Q--){\n    LL p, x, y;\n    cin >> p >> x >> y;\n    --p;\nif(p==0||p==2*N-1){\nsum-=as[p]-x;as[p]=x;\ncout<<sum-(par?*dels.rbegin()?0ll)<<endl;continue;\n}\n    LL mx = max(as[p], bs[p]);\n    LL mn = min(as[p], bs[p]);\n    sum -= mx;\n    if(mx == as[p]) par ^= 1;\n    auto it = dels.find(mn - mx);\n    dels.erase(it);\n\n    as[p] = x;\n    bs[p] = y;\n    LL mx2 = max(as[p], bs[p]);\n    LL mn2 = min(as[p], bs[p]);\n    sum += mx2;\n    if(mx2 == as[p]) par ^= 1;\n    dels.insert(mn2 - mx2);\n\n    LL ans = 0;\n    if(par == 0){\n      ans = sum;\n    }\n    else{\n      auto it = dels.rbegin();\n      assert(it != dels.rend());\n      ans = sum + *it;\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nint main() {\n        int n, q;\n        scanf(\"%d%d\", &n, &q);\n        assert(n <= 5 && q <= 10);\n        n = 2 * n;\n        vector<int> a(n), b(n);\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &a[i]);\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &b[i]);\n        set<string> ok;\n        vector<int> s(n);\n        for (int i = 0; i < n; i ++) s[i] = i;\n        do {\n                string tmp = \"\";\n                for (int i = 0; i < n; i ++) {\n                        if (s[i] & 1) tmp += \")\";\n                        else tmp += \"(\";\n                }\n                stack<char> st;\n                for (int i = 0; i < n; i ++) {\n                        if (!st.empty() && st.top() == '(' && tmp[i] == ')') st.pop();\n                        else st.push(tmp[i]);\n                }\n                if (st.empty()) ok.insert(tmp);\n        } while (next_permutation(s.begin(), s.end()));\n        vector<string> yes;\n        for (auto it : ok) yes.push_back(it);\n        while (q --) {\n                int p, x, y;\n                scanf(\"%d%d%d\", &p, &x, &y);\n                p --;\n                a[p] = x;\n                b[p] = y;\n                long long ans = 0;\n                for (int i = 0; i < yes.size(); i ++) {\n                        for (int j = i; j < yes.size(); j ++) {\n                                string fi = yes[i], se = yes[j];\n                                long long res = 0;\n                                for (int i = 0; i < n; i ++) {\n                                        if (fi[i] == se[i]) res += a[i];\n                                        else res += b[i];\n                                }\n                                ans = max(ans, res);\n                        }\n                }\n                printf(\"%lld\\n\", ans);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sp ' '\n#define mkp make_pair\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define lP pair<ll,ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\nconst int mod = 1000000007, mod998 = 998244353;\nconst string nyan(\"(=^・ω・^=)\");\n\nint N, Q, a[200000], b[200000], p, x, y;\nbool u[200000];\nset<pair<int, int>>st[2];\nll res;\n\nint main() {\n\tcin >> N >> Q;\n\t--Q;\n\tN *= 2;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> b[i];\n\t}\n\tcin >> p >> x >> y;\n\t--p;\n\ta[p] = x;\n\tb[p] = y;\n\tres = a[0] + a[N - 1];\n\tfor (int i = 1; i < N - 1; ++i) {\n\t\tif (a[i] >= b[i]) {\n\t\t\tu[i] = true;\n\t\t\tres += a[i];\n\t\t\tst[1].insert(mkp(a[i] - b[i], i));\n\t\t}\n\t\telse {\n\t\t\tres += b[i];\n\t\t\tst[0].insert(mkp(b[i] - a[i], i));\n\t\t}\n\t}\n\tif (st[0].size() & 1) {\n\t\tpair<int, int>p1, p2;\n\t\tp1 = *st[0].begin();\n\t\tp2 = *st[1].begin();\n\t\tif (p1.first > p2.first) {\n\t\t\tres -= p2.first;\n\t\t\tu[p2.second] ^= true;\n\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\tst[1].erase(p2);\n\t\t}\n\t\telse {\n\t\t\tres -= p1.first;\n\t\t\tu[p1.second] ^= true;\n\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\tst[0].erase(p1);\n\t\t}\n\t}\n\tcout << res << endl;\n\twhile (Q--) {\n\t\tcin >> p >> x >> y;\n\t\t--p;\n\t\tif (p == 0 || p == N - 1) {\n\t\t\tres += x - a[p];\n\t\t\ta[p] = x;\n\t\t}\n\t\telse {\n\t\t\tif (u[p]) {\n\t\t\t\tres += x - a[p];\n\t\t\t\tst[1].erase(mkp(a[p] - b[p], p));\n\t\t\t\tst[1].insert(mkp(x - y, p));\n\t\t\t\tauto it = st[1].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[0].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[1].erase(p1);\n\t\t\t\t\tst[1].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres += y - b[p];\n\t\t\t\tst[0].erase(mkp(b[p] - a[p], p));\n\t\t\t\tst[0].insert(mkp(y - x, p));\n\t\t\t\tauto it = st[0].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[1].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[0].erase(p1);\n\t\t\t\t\tst[0].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!st[0].empty() && !st[1].empty() && st[0].begin()->first + st[1].begin()->first < 0) {\n\t\t\t\tpair<int, int> p1 = *st[0].begin();\n\t\t\t\tpair<int, int> p2 = *st[1].begin();\n\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\tu[p1.second] ^= true;\n\t\t\t\tu[p2.second] ^= true;\n\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\tst[0].erase(p1);\n\t\t\t\tst[1].erase(p2);\n\t\t\t}\n\t\t\ta[p] = x;\n\t\t\tb[p] = y;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef double lld;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<double> vdl;\ntypedef vector<vector<lli>> mat;\ntypedef vector<vdl> mad;\ntypedef unordered_map<lli,unordered_map<lli,lli>> graph;\ntypedef complex<double> cmp;\ntypedef vector<cmp> vcl;\n\nlli n,q;\nvll a,b,c;\nmultiset<lli> l,r;\nlli ans = 0;\nlli p,x,y;\n\nint main(){\n  cin >> n >> q;\n  a = vll(2*n);\n  b = vll(2*n);\n  c = vll(2*n);\n  for(lli i = 0;i < 2*n;i++) cin >> a[i];\n  for(lli i = 0;i < 2*n;i++) cin >> b[i];\n  for(lli i = 0;i < 2*n;i++) c[i] = a[i]-b[i];\n  ans = accumulate(a.begin(),a.end(),0ll);\n  for(lli i = 1;i < 2*n-1;i++){\n    if(c[i] < 0){\n      r.insert(c[i]);\n    }else{\n      l.insert(c[i]);\n    }\n  }\n\n  for(lli x : r){\n    ans -= x;\n  }\n  for(lli i = 0;i < q;i++){\n    cin >> p >> x >> y;\n    p--;\n    if(p >= 1 && p < 2*n-1){\n      if(l.find(c[p]) != l.end()) l.erase(l.find(c[p]));\n      else if(r.find(c[p]) != r.end()){\n        r.erase(r.find(c[p]));\n        ans += c[p];\n      }\n    }\n    ans -= a[p];\n    a[p] = x;\n    b[p] = y;\n    c[p] = a[p]-b[p];\n    ans += a[p];\n    if(p >= 1 && p < 2*n-1){\n      if(c[p] < 0){\n        r.insert(c[p]);\n        ans -= c[p];\n      } else l.insert(c[p]);\n    }\n    if(r.size()%2 == 1 && *r.rbegin()+*l.begin() < 0) cout << ans+*l.begin() << endl;\n    if(r.size()%2 == 1 && *r.rbegin()+*l.begin() >= 0) cout << ans+*r.rbegin() << endl;\n    else cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define DEBUG_MODE\n#define endl '\\n'\n#ifdef DEBUG_MODE\n#define DEBUG(...) debug_func_mult(split_names(#__VA_ARGS__), __VA_ARGS__)\n#define DEBUG_ENDL endl << flush\n#define DEBUG_SEPARATOR_LINE cout<<\"=================\\n\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_ENDL 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\n#define DEBUG_ENDL_S(S) ((S).size() ? \"\\n\" : \"\") << flush;\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T, typename U> using P = pair<T, U>;\nusing ll = int64_t;\nusing PLL = P<ll, ll>;\n\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename Head, typename... Tail> const Head& var_min(const Head &head, const Tail&... tail) { return min(head, var_min(tail...)); }\ntemplate <typename Head, typename... Tail> const Head& var_max(const Head &head, const Tail&... tail) { return max(head, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\n\nstring to_string(const string &s) { return s; }\n\ntemplate <typename T, typename U>\nstring to_string(const P<T, U> &p) {\n    string ret = \"(\";\n    ret += to_string(p.first);\n    ret += \", \";\n    ret += to_string(p.second);\n    ret += \")\";\n    return move(ret);\n}\n\ntemplate <typename T>\nstring to_string(const V<T> &v) {\n    string ret = \"{\";\n    for(const T &t : v) {\n        ret += to_string(t);\n        ret += \", \";\n    }\n    ret += \"}\";\n    return move(ret);\n}\n\ntemplate <typename T>\nvoid debug_func(const T &t, const string &s = \"\") {\n    if(s.size()) cout << s << \" = \";\n    cout << to_string(t) << DEBUG_ENDL_S(s);\n}\n\ntemplate <typename T>\nvoid debug_func_mult(int idx, const V<string> &names, const T &t) {\n    debug_func(t, names[idx]);\n}\n\ntemplate <typename T>\nvoid debug_func_mult(const V<string> &names, const T &t) {\n    debug_func(t, names[0]);\n}\n\ntemplate <typename Head, typename... Tail>\nvoid debug_func_mult(int idx, const V<string> &names, const Head &head, const Tail&... args) {\n    debug_func(head, names[idx]);\n    debug_func_mult(idx + 1, names, args...);\n}\n\ntemplate <typename Head, typename... Tail>\nvoid debug_func_mult(const V<string> &names, const Head &head, const Tail&... args) {\n    debug_func(head, names[0]);\n    debug_func_mult(1, names, args...);\n}\n\nV<string> split_names(string &&s) {\n    replace(ALL(s), ' ', ',');\n    V<string> ret;\n    istringstream ss(s);\n    string t;\n    while(getline(ss, t, ',')) if(t.size()) ret.push_back(move(t));\n    return move(ret);\n}\n\nvoid init_io() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(30);\n}\n\nusing TLL = tuple<ll, ll, ll>;\nconst ll INF = 5e15;\n\nint main() {\n    init_io();\n    ll N, Q;\n    cin >> N >> Q;\n    V<ll> A(2 * N), B(2 * N);\n    for(ll &e : A) cin >> e;\n    for(ll &e : B) cin >> e;\n    ll sum = accumulate(ALL(A), 0ll);\n    ll pcnt = 0;\n    ll psum = 0;\n    map<ll, ll> plus, minus;\n    for(ll i = 1; i < 2 * N - 1; i++) {\n        ll dic = B[i] - A[i];\n        if(dic >= 0) {\n            pcnt++;\n            psum += dic;\n            plus[dic]++;\n        } else {\n            minus[-dic]++;\n        }\n    }\n\n    auto update_query = [&](ll dic, bool addq) {\n        auto &mp = (dic < 0 ? minus : plus);\n        dic = abs(dic);\n        if(addq) {\n            mp[dic]++;\n        } else {\n            auto ite = mp.find(dic);\n            ite->second--;\n            if(ite->second == 0) mp.erase(ite);\n        }\n    };\n\n    auto adjust = [&] {\n        if(pcnt % 2 == 0) return psum;\n        auto itep = plus.lower_bound(0);\n        auto item = minus.lower_bound(0);\n        ll mval = min(itep->first, item->first);\n        return psum - mval;\n    };\n\n    for(ll QQ = 0; QQ < Q; QQ++) {\n        ll p, a, b;\n        cin >> p >> a >> b;\n        p--;\n        ll pre_dic = B[p] - A[p];\n        ll new_dic = b - a;\n        sum = sum - A[p] + a;\n        A[p] = a;\n        B[p] = b;\n        if(p == 0 || p == 2 * N - 1) {\n            cout << sum << endl;\n            continue;\n        }\n        if(pre_dic >= 0) {\n            pcnt--;\n            psum -= pre_dic;\n        }\n        if(new_dic >= 0) {\n            pcnt++;\n            psum += new_dic;\n        }\n        update_query(pre_dic, false);\n        update_query(new_dic, true);\n        ll addv = adjust();\n        cout << sum + addv << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<ll, int>;\n\nll calc(ll base, ll sum, set<P>& s, set<P>& s2) {\n    ll v1 = base + sum;\n    if (s.size() % 2 == 0 || s2.empty()) return v1;\n    v1 -= s.begin()->first;\n    \n    ll v2 = base + sum - s2.begin()->first;\n    return max(v1, v2);\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, q;\n    cin >> n >> q;\n    int m = 2 * n;\n    vector<ll> a(m), b(m);\n    for (int i = 0; i < m; i++) cin >> a[i];\n    for (int i = 0; i < m; i++) cin >> b[i];\n\n    vector<int> p(q);\n    vector<ll> x(q), y(q);\n    for (int i = 0; i < q; i++) {\n        cin >> p[i] >> x[i] >> y[i];\n        p[i]--;\n    }\n\n    ll base = 0;\n    ll sum = 0;\n    set<P> s, s2;\n    for (int i = 0; i < m; i++) {\n        base += a[i];\n        if (i > 0 && i < m - 1) {\n            if (a[i] <= b[i]) {\n                sum += b[i] - a[i];\n                s.emplace(b[i] - a[i], i);\n            } else {\n                s2.emplace(-b[i] + a[i], i);\n            }\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        base += x[i] - a[p[i]];\n        if (p[i] == 0 || p[i] == m - 1) {\n            cout << calc(base, sum, s, s2) << endl;\n        } else {\n            if (b[p[i]] >= a[p[i]]) {\n                s.erase(P(b[p[i]] - a[p[i]], p[i]));\n                sum -= b[p[i]] - a[p[i]];\n            } else{\n                s2.erase(P(-b[p[i]] + a[p[i]], p[i]));\n            }\n            if (y[i] >= x[i]) {\n                s.emplace(y[i] - x[i], p[i]);\n                sum += y[i] - x[i]; \n            } else {\n                s2.emplace(-y[i] + x[i], p[i]);\n            }\n            cout << calc(base, sum, s, s2) << endl;\n        }\n        a[p[i]] = x[i];\n        b[p[i]] = y[i];\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tint N, Q;\n\twhile(cin >> N >> Q){\n\t\tlong long res = 0;\n\t\tvector<long long> a(2*N), dif(2*N);\n\t\tfor(auto& t : a) cin >> t;\n\t\tfor(int i=0;i<2*N;i++){\n\t\t\tres += a[i];\n\t\t\tcin >> dif[i];\n\t\t\tdif[i] -= a[i];\n\t\t}\n\t\tvector<pair<long long, int>> v;\n\t\tfor(int i=1;i<2*N-1;i++){\n\t\t\tv.emplace_back(dif[i], i);\n\t\t}\n\t\tsort(v.rbegin(), v.rend());\n\t\tusing Data = pair<long long, pair<int,int>>;\n\t\tpriority_queue<Data> no_use;\n\t\tpriority_queue<Data, vector<Data>, greater<Data>> use;\n\t\tvector<int> type(2*N, 0);\n\t\tvector<int> update(2*N, -1);\n\t\tvector<int> typeCnt(2, 0);\n\t\ttypeCnt[0] = 2*N-2;\n\t\tfor(int i=0;i+1<v.size();i+=2){\n\t\t\tif(v[i].first + v[i+1].first >= 0){\n\t\t\t\tres += v[i].first + v[i+1].first;\n\t\t\t\ttype[v[i].second] = 1;\n\t\t\t\ttype[v[i+1].second] = 1;\n\t\t\t\ttypeCnt[0] -= 2;\n\t\t\t\ttypeCnt[1] += 2;\n\t\t\t}\n\t\t}\n\t\tfor(int i=1;i<2*N-1;i++){\n\t\t\tif(type[i]==0) no_use.emplace(dif[i], make_pair(i, -1));\n\t\t\tif(type[i]==1) use.emplace(dif[i], make_pair(i, -1));\n\t\t}\n\t\tauto removeOld = [&](auto& qu, int useType){\n\t\t\twhile(!qu.empty()){\n\t\t\t\tauto data = qu.top();\n\t\t\t\tauto idx = data.second.first;\n\t\t\t\tif(type[idx] == useType && update[idx] == data.second.second) break;\n\t\t\t\tqu.pop();\n\t\t\t}\n\t\t};\n\t\tauto removeOldUse = [&](){ removeOld(use, 1); };\n\t\tauto removeOldNoUse = [&](){ removeOld(no_use, 0); };\n\t\tfor(int i=0;i<Q;i++){\n\t\t\tlong long p, x, y; cin >> p >> x >> y;\n\t\t\t--p;\n\t\t\tres += x - a[p];\n\t\t\tif(0 < p && p < 2*N-1){\n\t\t\t\tif(type[p] == 1){\n\t\t\t\t\tres += y - x - dif[p];\n\t\t\t\t\tuse.emplace(y-x, make_pair(p, i));\n\t\t\t\t} else {\n\t\t\t\t\tno_use.emplace(y-x, make_pair(p, i));\n\t\t\t\t}\n\t\t\t}\n\t\t\t// cout << \"chg\" <<  i << \":\" << res << endl;\n\t\t\t// cout << typeCnt[0] << \" \" << typeCnt[1] << endl;\n\t\t\t// cout << use.size() << \" \" << no_use.size() << endl;\n\t\t\ta[p] = x;\n\t\t\tdif[p] = y - x;\n\t\t\tupdate[p] = i;\n\t\t\tif(0 < p && p < 2*N-1){\n\t\t\t\tremoveOldUse();\n\t\t\t\tremoveOldNoUse();\n\t\t\t\tif(typeCnt[0] > 0 && typeCnt[1] > 0 && use.top().first < no_use.top().first){\n\t\t\t\t\tauto d1 = use.top(); use.pop();\n\t\t\t\t\tauto d2 = no_use.top(); no_use.pop();\n\t\t\t\t\tres += d2.first - d1.first;\n\t\t\t\t\tuse.push(d2);\n\t\t\t\t\tno_use.push(d1);\n\t\t\t\t\ttype[d2.second.first] = 1;\n\t\t\t\t\ttype[d1.second.first] = 0;\n\t\t\t\t\t// cout << \"swap\" <<  i << \":\" << res << endl;\n\t\t\t\t}\n\t\t\t\tif(typeCnt[1] > 0){\n\t\t\t\t\tremoveOldUse();\n\t\t\t\t\tauto d1 = use.top(); use.pop();\n\t\t\t\t\tremoveOldUse();\n\t\t\t\t\tauto d2 = use.top(); use.pop();\n\t\t\t\t\tif(d1.first + d2.first < 0){\n\t\t\t\t\t\tres -= d1.first + d2.first;\n\t\t\t\t\t\t// cout << \"remove\" <<  i << \":\" << res << endl;\n\t\t\t\t\t\ttype[d1.second.first] = 0;\n\t\t\t\t\t\ttype[d2.second.first] = 0;\n\t\t\t\t\t\ttypeCnt[0] += 2;\n\t\t\t\t\t\ttypeCnt[1] -= 2;\n\t\t\t\t\t\tno_use.emplace(d1);\n\t\t\t\t\t\tno_use.emplace(d2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tuse.emplace(d1);\n\t\t\t\t\t\tuse.emplace(d2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(typeCnt[0] > 0){\n\t\t\t\t\tremoveOldNoUse();\n\t\t\t\t\tauto d1 = no_use.top(); no_use.pop();\n\t\t\t\t\tremoveOldNoUse();\n\t\t\t\t\tauto d2 = no_use.top(); no_use.pop();\n\t\t\t\t\tif(d1.first + d2.first >= 0){\n\t\t\t\t\t\tres += d1.first + d2.first;\n\t\t\t\t\t\t// cout << \"add\" <<  i << \":\" << res << endl;\n\t\t\t\t\t\ttype[d1.second.first] = 1;\n\t\t\t\t\t\ttype[d2.second.first] = 1;\n\t\t\t\t\t\ttypeCnt[0] -= 2;\n\t\t\t\t\t\ttypeCnt[1] += 2;\n\t\t\t\t\t\tuse.emplace(d1);\n\t\t\t\t\t\tuse.emplace(d2);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tno_use.emplace(d1);\n\t\t\t\t\t\tno_use.emplace(d2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\tif(type[p] == 1){\n\t\t\t\t\tremoveOld(use);\n\t\t\t\t\tauto data = use.top();\n\t\t\t\t\tif(data.first + y - x < 0){\n\t\t\t\t\t\tcout << \"A\" << endl;\n\t\t\t\t\t\tres -= data.first + dif[p];\n\t\t\t\t\t\tuse.pop();\n\t\t\t\t\t\tno_use.push(data);\n\t\t\t\t\t\tno_use.emplace(y-x, make_pair(p, i));\n\t\t\t\t\t\ttype[data.second.first] = 0;\n\t\t\t\t\t\ttype[p] = 0;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcout << \"B\" << endl;\n\t\t\t\t\t\tres += y - x - dif[p];\n\t\t\t\t\t\tuse.emplace(y-x, make_pair(p, i));\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tremoveOld(no_use);\n\t\t\t\t\tauto data = no_use.top();\n\t\t\t\t\tif(data.first + y - x >= 0){\n\t\t\t\t\t\tcout << \"C\" << \" \" << data.first + y - x << endl;\n\t\t\t\t\t\tres += data.first + y - x;\n\t\t\t\t\t\tno_use.pop();\n\t\t\t\t\t\tuse.push(data);\n\t\t\t\t\t\tuse.emplace(y-x, make_pair(p, i));\n\t\t\t\t\t\ttype[data.second.first] = 1;\n\t\t\t\t\t\ttype[p] = 1;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcout << \"D\" << endl;\n\t\t\t\t\t\tno_use.emplace(y-x, make_pair(p, i));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t*/\t\t\t\n\t\t\t}\n\t\t\ta[p] = x;\n\t\t\tdif[p] = y - x;\n\t\t\tupdate[p] = i;\n\t\t\tcout << res << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define in(x,y,h,w) x >= 0 && x < h && y >= 0 && y < w\nusing namespace std;\n\n#define int long long\n//typedef    long long          ll;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n \nconst int INF=1e+15;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nclass RMQ{\n\tint n,seg,init;\n\tvector<int> dat;\npublic:\n\tRMQ(int siz,int def) : n(siz),init(def),seg(1){\n\t\twhile(seg < n) seg *= 2;\n\t\tdat.resize(seg * 2 - 1);\n\t\tfor(int i = 0;i < seg * 2 - 1;i++) dat[i] = init;\n\t}\n\tvoid update(int i,int x){\n\t\ti += seg - 1;\n\t\tdat[i] = x;\n\t\twhile(i){\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1],dat[i * 2 + 2]); //do\n\t\t}\n\t}\n\tint get(int a = 0,int b = -1,int k = 0,int l = 0,int r = -1){\n\t\tif(b == -1) b = seg;\n\t\tif(r == -1) r = seg;\n\t\tif(b <= l || r <= a) return init;\n\t\tif(a <= l && r <= b) return dat[k];\n\t\treturn min(get(a,b,k * 2 + 1,l,(l + r) / 2),get(a,b,k * 2 + 2,(l + r) / 2,r)); //do\n\t}\n};\n\nsigned main(){\n\tint n,q,a[200000],b[200000],sum = 0,pos = 0,add = 0;\n\tcin >> n >> q;\n\tvector<RMQ> rmq(2,RMQ(n * 2,INF));\n\tfor(int i = 0;i < n * 2;i++){\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\tfor(int i = 0;i < n * 2;i++){\n\t\tcin >> b[i];\n\t\tb[i] -= a[i];\n\t\tif(!i || i == n * 2 - 1) continue;\n\t\tif(b[i] >= 0){\n\t\t\trmq[0].update(i,b[i]);\n\t\t\tpos++;\n\t\t\tadd += b[i];\n\t\t}\n\t\telse rmq[1].update(i,-b[i]);\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tint p,x,y;\n\t\tcin >> p >> x >> y; p--;\n\t\tsum += x - a[p];\n\t\ta[p] = x;\n\t\tif(!(!p || p == n * 2 - 1)){\n\t\t\tint nb = y - x;\n\t\t\tif(nb >= 0){\n\t\t\t\trmq[0].update(p,nb);\n\t\t\t\trmq[1].update(p,INF);\n\t\t\t\tif(b[p] < 0){\n\t\t\t\t\tpos++;\n\t\t\t\t\tadd += nb;\n\t\t\t\t}else add += nb - b[p];\n\t\t\t}else{\n\t\t\t\trmq[0].update(p,INF);\n\t\t\t\trmq[1].update(p,-nb);\n\t\t\t\tif(b[p] >= 0){\n\t\t\t\t\tpos--;\n\t\t\t\t\tadd -= b[p];\n\t\t\t\t}\n\t\t\t}\n\t\t\tb[p] = nb;\n\t\t}\n\t\tif(pos % 2 == 0) cout << sum + add << endl;\n\t\telse cout << sum + max(add - rmq[0].get(0,n * 2),add + rmq[0].get(0,n * 2) - rmq[1].get(0,n * 2)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN = 100000;\n\nint n, nq;\nint a[2 * MAXN], b[2 * MAXN];\n\nll now;\nbool same[2 * MAXN];\nset<pair<int,int> > same2diff;\nset<pair<int,int> > diff2same;\n\nvoid change(set<pair<int, int> > &s, int idx, int oval, int nval) {\n\ts.erase(MP(oval, idx)); s.insert(MP(nval, idx));\n}\n\nvoid update() {\n\twhile (true) {\n\t\tbool change = false;\n\t\twhile (SZ(same2diff) >= 2) {\n\t\t\tauto a = same2diff.end(); --a; auto b = a; --b;\n\t\t\tif ((ll)a->first + b->first <= 0) break;\n\t\t\tnow += (ll)a->first + b->first;\n\t\t\tsame[a->second] = same[b->second] = false;\n\t\t\tdiff2same.insert(MP(-a->first, a->second));\n\t\t\tdiff2same.insert(MP(-b->first, b->second));\n\t\t\tsame2diff.erase(a);\n\t\t\tsame2diff.erase(b);\n\t\t\tchange = true;\n\t\t}\n\t\twhile (SZ(diff2same) >= 2) {\n\t\t\tauto a = diff2same.end(); --a; auto b = a; --b;\n\t\t\tif ((ll)a->first + b->first <= 0) break;\n\t\t\tnow += (ll)a->first + b->first;\n\t\t\tsame[a->second] = same[b->second] = true;\n\t\t\tsame2diff.insert(MP(-a->first, a->second));\n\t\t\tsame2diff.insert(MP(-b->first, b->second));\n\t\t\tdiff2same.erase(a);\n\t\t\tdiff2same.erase(b);\n\t\t\tchange = true;\n\t\t}\n\t\twhile (SZ(same2diff) >= 1 && SZ(diff2same) >= 1) {\n\t\t\tauto a = same2diff.end(); --a; auto b = diff2same.end(); --b;\n\t\t\tif ((ll)a->first + b->first <= 0) break;\n\t\t\tnow += (ll)a->first + b->first;\n\t\t\tsame[a->second] = false, same[b->second] = true;\n\t\t\tdiff2same.insert(MP(-a->first, a->second));\n\t\t\tsame2diff.insert(MP(-b->first, b->second));\n\t\t\tsame2diff.erase(a);\n\t\t\tdiff2same.erase(b);\n\t\t\tchange = true;\n\t\t}\n\t\tif (!change) break;\n\t}\n}\n\nvoid run() {\n\tscanf(\"%d%d\", &n, &nq); REP(i, 2 * n) scanf(\"%d\", &a[i]); REP(i, 2 * n) scanf(\"%d\", &b[i]);\n\tnow = 0; same2diff.clear(); diff2same.clear();\n\tREP(i, 2 * n) {\n\t\tnow += a[i]; same[i] = true;\n\t\tif (i != 0 && i != 2 * n - 1) same2diff.insert(MP(b[i] - a[i], i));\n\t}\n\tREP(qi, nq) {\n\t\tint idx, aval, bval; scanf(\"%d%d%d\", &idx, &aval, &bval); --idx;\n\t\tif (same[idx]) now += aval - a[idx];\n\t\telse now += bval - b[idx];\n\t\tif (idx != 0 && idx != 2 * n - 1) {\n\t\t\tif (same[idx]) change(same2diff, idx, b[idx] - a[idx], bval - aval);\n\t\t\telse change(diff2same, idx, a[idx] - b[idx], aval - bval);\n\t\t}\n\t\ta[idx] = aval, b[idx] = bval;\n\t\tupdate();\n\t\tprintf(\"%lld\\n\", now);\n\t}\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PL;\nconst ll mod = 1e9 + 7;\n\nconst int N = 200000;\n\nint n;\n\nll a[N], d[N]; // b[i] = a[i] + d[i]\nll asum;\n\nset<PL> neg, pos;\nll possum;\n\nvoid add_d(int x, ll y) {\n  d[x] = y;\n  if (x == 0 || x == 2 * n - 1) return;\n  if (y >= 0) {\n    possum += y;\n    pos.insert(PL(y, x));\n  } else {\n    neg.insert(PL(y, x));\n  }\n}\n\nvoid rm_d(int x) {\n  ll y = d[x];\n  if (x == 0 || x == 2 * n - 1) return;\n  if (y >= 0) {\n    possum -= y;\n    pos.erase(PL(y, x));\n  } else {\n    neg.erase(PL(y, x));\n  }\n}\n\nll solve() {\n  ll tot = possum;\n  if (pos.size() % 2 == 1) {\n    tot += max(-pos.begin()->first, neg.rbegin()->first);\n  }\n  return tot + asum;\n}\n\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int q;\n  cin >> n >> q;\n  VL a(2 * n), b(2 * n);\n  REP(i, 0, 2 * n) {\n    cin >> a[i];\n    asum += a[i];\n  }\n  REP(i, 0, 2 * n) {\n    ll b;\n    cin >> b;\n    add_d(i, b - a[i]);\n  }\n  REP(i, 0, q) {\n    int p, x, y;\n    cin >> p >> x >> y;\n    p--;\n    asum += x - a[p];\n    a[p] = x;\n    rm_d(p);\n    add_d(p, y - x);\n    cout << solve() << \"\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\nclass LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}};\nvpii factor(int N){vpii r;for(int i=2;i*i<=N;++i){if(N%i==0){r<<pii{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pii{N,1};}return r;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N,Q;cin>>N>>Q;\n\tvi A(2*N);cin>>A;\n\tvi B(2*N);cin>>B;\n\tmii po,ne;\n\tll z=sum(A);\n\tbool c=false;\n\tfoor(i,1,2*N-2){\n\t\tif(B[i]>=A[i]){\n\t\t\t++po[B[i]-A[i]];\n\t\t\tz+=B[i]-A[i];\n\t\t\tc=!c;\n\t\t}else{\n\t\t\t++ne[A[i]-B[i]];\n\t\t}\n\t}\n\tfr(q,Q){\n\t\tint p,x,y;cin>>p>>x>>y;\n\t\t--p;\n\t\tz+=x-A[p];\n\t\tif(1<=p&&p<=2*N-2){\n\t\t\tif(y>=x){\n\t\t\t\t++po[y-x];\n\t\t\t\tz+=y-x;\n\t\t\t\tc=!c;\n\t\t\t}else{\n\t\t\t\t++ne[x-y];\n\t\t\t}\n\t\t\tif(B[p]>=A[p]){\n\t\t\t\t--po[B[p]-A[p]];\n\t\t\t\tif(po[B[p]-A[p]]==0)po.erase(B[p]-A[p]);\n\t\t\t\tz-=B[p]-A[p];\n\t\t\t\tc=!c;\n\t\t\t}else{\n\t\t\t\t--ne[A[p]-B[p]];\n\t\t\t\tif(ne[A[p]-B[p]]==0)po.erase(A[p]-B[p]);\n\t\t\t}\n\t\t}\n\t\tA[p]=x,B[p]=y;\n\t\tif(c){\n\t\t\tprint(z-min(*po.begin(),*ne.begin()).first);\n\t\t}else{\n\t\t\tprint(z);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = 1e18;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  assert(n == 3);\n  n *= 2;\n  vl a(n), b(n);\n  rep (i, n) {\n    cin >> a[i];\n  }\n  rep (i, n) {\n    cin >> b[i];\n  }\n  set<pii> aa, bb;\n  ll ans = 0;\n  rep (i, n) {\n    if (i == 0) {\n      ans += a[i];\n      continue;\n    }\n    if (i == n - 1) {\n      ans += a[i];\n      continue;\n    }\n    if (a[i] >= b[i]) {\n      ans += a[i];\n      aa.insert(pii(a[i] - b[i], i));\n    }\n    else {\n      ans += b[i];\n      bb.insert(pii(b[i] - a[i], i));\n    }\n  }\n  if ((int)aa.size() % 2) {\n    auto itra = aa.begin();\n    auto itrb = bb.begin();\n    pii a_s = *itra, b_s = *itrb;\n    if (a_s.first >= b_s.first) {\n      bb.erase(b_s);\n      int idx = b_s.second;\n      ans -= b[idx];\n      ans += a[idx];\n      aa.insert(pii(a[idx] - b[idx], idx));\n    }\n    else {\n      aa.erase(a_s);\n      int idx = a_s.second;\n      ans -= a[idx];\n      ans += b[idx];\n      bb.insert(pii(b[idx] - a[idx], idx));\n    }\n  }\n  while (q--) {\n    /*\n    cout << \"aa \";\n    for (auto itr = aa.begin(); itr != aa.end(); itr++) {\n      cout << *itr << \" \";\n    }\n    cout << endl;\n    cout << \"bb \";\n    for (auto itr = bb.begin(); itr != bb.end(); itr++) {\n      cout << *itr << \" \";\n    }\n    //*/\n    int p, x, y;\n    cin >> p >> x >> y;\n    p--;\n    if (p == 0 || p == n - 1) {\n      ans -= a[p];\n      a[p] = x;\n      b[p] = y;\n      ans += a[p];\n      cout << ans << endl;\n      continue;\n    }\n    if (aa.count(pii(a[p] - b[p], p))) {\n      aa.erase(pii(a[p] - b[p], p));\n      ans -= a[p];\n    }\n    else if (bb.count(pii(b[p] - a[p], p))) {\n      bb.erase(pii(b[p] - a[p], p));\n      ans -= b[p];\n    }\n    else {\n      assert(false);\n    }\n    a[p] = x;\n    b[p] = y;\n    if (a[p] >= b[p]) {\n      ans += a[p];\n      aa.insert(pii(a[p] - b[p], p));\n    }\n    else {\n      ans += b[p];\n      bb.insert(pii(b[p] - a[p], p));\n    }\n    if ((int)aa.size() % 2) {\n      auto itra = aa.begin();\n      auto itrb = bb.begin();\n      pii a_s = *itra, b_s = *itrb;\n      if (a_s.first >= b_s.first) {\n        bb.erase(b_s);\n        int idx = b_s.second;\n        ans -= b[idx];\n        ans += a[idx];\n        aa.insert(pii(a[idx] - b[idx], idx));\n      }\n      else {\n        aa.erase(a_s);\n        int idx = a_s.second;\n        ans -= a[idx];\n        ans += b[idx];\n        bb.insert(pii(b[idx] - a[idx], idx));\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\n\nint main(){\n    int n,q;\n    cin>>n>>q;\n    n*=2;\n    ll a[n],b[n];\n    rep(i,n)cin>>a[i];\n    rep(i,n)cin>>b[i];\n    ll ans=a[0]+a[n-1];\n    int posi=0,zero=0;\n    multiset<ll> st;\n    rep(i,n-2){\n        ans+=max(a[i+1],b[i+1]);\n        if(a[i+1]>b[i+1])posi++;\n        if(a[i+1]==b[i+1])zero++;\n        st.insert(abs(a[i+1]-b[i+1]));\n    }\n    rep(i,q){\n        ll p,x,y;\n        cin>>p>>x>>y;\n        p--;\n        if(p==0||p==n-1){\n            ans+=(ll)(x-a[p]);\n            a[p]=x;\n            cout<<ans<<endl;\n            continue;\n        }\n        ans+=max(x,y);\n        ans-=max(a[p],b[p]);\n        auto it=st.find(abs(a[p]-b[p]));\n        st.erase(it);\n        st.insert(abs(x-y));\n        if(a[p]>b[p])posi--;\n        if(a[p]==b[p])zero--;\n        if(x>y)posi++;\n        if(x==y)zero++;\n        a[p]=x;\n        b[p]=y;\n        it=st.begin();\n        if(zero>0||posi%2==0)cout<<ans<<endl;\n        else cout<<ans-*it<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\nclass LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}};\nvpii factor(int N){vpii r;for(int i=2;i*i<=N;++i){if(N%i==0){r<<pii{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pii{N,1};}return r;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N,Q;cin>>N>>Q;\n\tvi A(2*N);cin>>A;\n\tvi B(2*N);cin>>B;\n\tmii po,ne;\n\tll z=sum(A);\n\tfoor(i,1,2*N-2){\n\t\tif(B[i]>=A[i]){\n\t\t\t++po[B[i]-A[i]];\n\t\t\tz+=B[i]-A[i];\n\t\t}else{\n\t\t\t++ne[A[i]-B[i]];\n\t\t}\n\t}\n\tfr(q,Q){\n\t\tint p,x,y;cin>>p>>x>>y;\n\t\t--p;\n\t\tz+=x-A[p];\n\t\tif(1<=p&&p<=2*N-2){\n\t\t\tif(y>=x){\n\t\t\t\t++po[y-x];\n\t\t\t\tz+=y-x;\n\t\t\t}else{\n\t\t\t\t++ne[x-y];\n\t\t\t}\n\t\t\tif(B[p]>=A[p]){\n\t\t\t\t--po[B[p]-A[p]];\n\t\t\t\tif(po[B[p]-A[p]]==0)po.erase(B[p]-A[p]);\n\t\t\t\tz-=B[p]-A[p];\n\t\t\t}else{\n\t\t\t\t--ne[A[p]-B[p]];\n\t\t\t\tif(ne[A[p]-B[p]]==0)po.erase(A[p]-B[p]);\n\t\t\t}\n\t\t}\n\t\tA[p]=x,B[p]=y;\n\t\tif(po.size()%2){\n\t\t\tprint(z-min(*po.begin(),*ne.begin()).first);\n\t\t}else{\n\t\t\tprint(z);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n#define MAXN 200000\n#define ll long long\n#define INFLL 0x3f3f3f3f3f3f3f3fll\n#define rint register int\n#define gc() getchar()\ninline int read(rint ans = 0, rint sgn = ' ', rint ch = gc())\n{\n\tfor(; ch < '0' || ch > '9'; sgn = ch, ch = gc());\n\tfor(; ch >='0' && ch <='9';(ans*=10)+=ch-'0', ch = gc());\n\treturn sgn-'-'?ans:-ans;\n}\n#define BUF_SIZE 1000000\n#define _END fwrite(_Ob,1,_O-_Ob,stdout), _O = _Ob\n#define Outc(a) (*_O++ = a)\nchar _Ob[BUF_SIZE+5], *_O = _Ob, _Os[25], *_Ot;\ntemplate <typename T> inline void Out(T x)\n{\n\tif(!x){Outc('0'); return;} if(x < 0) Outc('-'), x = -x;\n\tfor(_Ot = _Os; x; *_Ot++ = x%10+'0', x /= 10);\n\tfor(; _Ot != _Os; Outc(*--_Ot)); if(_O-_Ob >= BUF_SIZE-50) _END;\n}\nint n, q, a[MAXN+5], b[MAXN+5]; multiset<int> Pos, Neg; multiset<int>::iterator it; ll base, sum;\nint main()\n{\n\tn = read()<<1, q = read(); for(rint i = 1; i <= n; base += (a[i++]=read())); for(rint i = 1; i <= n; b[i++] = read());\n\tfor(rint i = 2; i < n; b[i]>=a[i] ? sum += b[i]-a[i], Pos.insert(b[i]-a[i]) : Neg.insert(b[i]-a[i]), i++);\n\tfor(rint p; q--; Out(base+(Pos.size()&1?max(sum+(Neg.size()?*--Neg.end():INFLL),sum-*Pos.begin()):sum)), Outc('\\n'))\n\t{\n\t\tp = read(), base -= a[p], p>1&&p<n ? it = (b[p]>=a[p] ? sum -= b[p]-a[p], Pos.find(b[p]-a[p]) : Neg.find(b[p]-a[p])), (b[p]>=a[p]?Pos:Neg).erase(it),0 : 0;\n\t\ta[p] = read(), b[p] = read(), base += a[p], p>1&&p<n ? b[p]>=a[p] ? sum += b[p]-a[p], Pos.insert(b[p]-a[p]) : Neg.insert(b[p]-a[p]),0 : 0;\n\t}\t_END; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}\n}star;\n#define DEBUG if(0)\n#endif\n\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\n\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\n\nset<pair<LL, int>> pl, mi;\nint N, Q;\nLL sum = 0;\nLL a[212345];\nLL b[212345];\nvoid ins(int i) {\n\tif (i == 0 || i == N - 1)return;\n\tLL x = b[i] - a[i];\n\tif (x >= 0) {\n\t\tpl.insert({ x,i });\n\t\tsum += x;\n\t}\n\telse mi.insert({ x,i });\n}\nvoid ers(int i){\n\tif (i == 0 || i == N - 1)return;\n\tLL x = b[i] - a[i];\n\tif (x >= 0) {\n\t\tpl.erase({ x,i });\n\t\tsum -= x;\n\t}\n\telse mi.erase({ x,i });\n}\n\nint main() {\n\tcin >> N >> Q;\n\tN *= 2;\n\tfor (int i : range(N)) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i : range(N)) {\n\t\tcin >> b[i];\n\t}\n\tLL base = 0;\n\tfor (int i : range(N)) {\n\t\tbase += a[i];\n\t}\n\tfor (int i : range(1,N-1)) {\n\t\tLL x = b[i] - a[i];\n\t\tins(i);\n\t}\n\tfor (int _ : range(Q)) {\n\t\tint p; LL x, y;\n\t\tcin >> p >> x >> y;\n\t\tp--;\n\t\tbase -= a[p]; ers(p);\n\t\ta[p] = x;\n\t\tb[p] = y;\n\t\tbase += a[p]; ins(p);\n\t\tif (pl.size() % 2 == 0) {\n\t\t\tcout << base + sum << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << base + sum + max(mi.rbegin()->first, -pl.begin()->first)<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sp ' '\n#define mkp make_pair\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define lP pair<ll,ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\nconst int mod = 1000000007, mod998 = 998244353;\nconst string nyan(\"(=^・ω・^=)\");\n\nint N, Q, a[100000], b[100000], p, x, y;\nbool u[100000];\nset<pair<int, int>>st[2];\nll res;\n\nint main() {\n\tcin >> N >> Q;\n\tN <<= 1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> b[i];\n\t}\n\t--Q;\n\tcin >> p >> x >> y;\n\t--p;\n\ta[p] = x;\n\tb[p] = y;\n\tres = a[0] + a[N - 1];\n\tfor (int i = 1; i < N - 1; ++i) {\n\t\tif (a[i] >= b[i]) {\n\t\t\tu[i] = true;\n\t\t\tres += a[i];\n\t\t\tst[1].insert(mkp(a[i] - b[i], i));\n\t\t}\n\t\telse {\n\t\t\tres += b[i];\n\t\t\tst[0].insert(mkp(b[i] - a[i], i));\n\t\t}\n\t}\n\tif (st[0].size() & 1) {\n\t\tpair<int, int>p1, p2;\n\t\tp1 = *st[0].begin();\n\t\tp2 = *st[1].begin();\n\t\tif (p1.first > p2.first) {\n\t\t\tres -= p2.first;\n\t\t\tu[p2.second] ^= true;\n\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\tst[1].erase(p2);\n\t\t}\n\t\telse {\n\t\t\tres -= p1.first;\n\t\t\tu[p1.second] ^= true;\n\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\tst[0].erase(p1);\n\t\t}\n\t}\n\tcout << res << endl;\n\twhile (Q--) {\n\t\tcin >> p >> x >> y;\n\t\t--p;\n\t\tif (p == 0 || p == N - 1) {\n\t\t\tres += x - a[p];\n\t\t\ta[p] = x;\n\t\t}\n\t\telse {\n\t\t\tif (u[p]) {\n\t\t\t\tres += x - a[p];\n\t\t\t\tst[1].erase(mkp(a[p] - b[p], p));\n\t\t\t\tst[1].insert(mkp(x - y, p));\n\t\t\t\tauto it = st[1].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[0].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[1].erase(p1);\n\t\t\t\t\tst[1].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres += y - b[p];\n\t\t\t\tst[0].erase(mkp(b[p] - a[p], p));\n\t\t\t\tst[0].insert(mkp(y - x, p));\n\t\t\t\tauto it = st[0].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[1].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[0].erase(p1);\n\t\t\t\t\tst[0].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!st[0].empty() && !st[1].empty() && st[0].begin()->first + st[1].begin()->first < 0) {\n\t\t\t\tpair<int, int> p1 = *st[0].begin();\n\t\t\t\tpair<int, int> p2 = *st[1].begin();\n\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\tu[p1.second] ^= true;\n\t\t\t\tu[p2.second] ^= true;\n\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\tst[0].erase(p1);\n\t\t\t\tst[1].erase(p2);\n\t\t\t}\n\t\t\ta[p] = x;\n\t\t\tb[p] = y;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define DEBUG_MODE\n#define endl '\\n'\n#ifdef DEBUG_MODE\n#define DEBUG(...) debug_func_mult(split_names(#__VA_ARGS__), __VA_ARGS__)\n#define DEBUG_ENDL endl << flush\n#define DEBUG_SEPARATOR_LINE cout<<\"=================\\n\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_ENDL 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\n#define DEBUG_ENDL_S(S) ((S).size() ? \"\\n\" : \"\") << flush;\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T, typename U> using P = pair<T, U>;\nusing ll = int64_t;\nusing PLL = P<ll, ll>;\n\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename Head, typename... Tail> const Head& var_min(const Head &head, const Tail&... tail) { return min(head, var_min(tail...)); }\ntemplate <typename Head, typename... Tail> const Head& var_max(const Head &head, const Tail&... tail) { return max(head, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\n\nstring to_string(const string &s) { return s; }\n\ntemplate <typename T, typename U>\nstring to_string(const P<T, U> &p) {\n    string ret = \"(\";\n    ret += to_string(p.first);\n    ret += \", \";\n    ret += to_string(p.second);\n    ret += \")\";\n    return move(ret);\n}\n\ntemplate <typename T>\nstring to_string(const V<T> &v) {\n    string ret = \"{\";\n    for(const T &t : v) {\n        ret += to_string(t);\n        ret += \", \";\n    }\n    ret += \"}\";\n    return move(ret);\n}\n\ntemplate <typename T>\nvoid debug_func(const T &t, const string &s = \"\") {\n    if(s.size()) cout << s << \" = \";\n    cout << to_string(t) << DEBUG_ENDL_S(s);\n}\n\ntemplate <typename T>\nvoid debug_func_mult(int idx, const V<string> &names, const T &t) {\n    debug_func(t, names[idx]);\n}\n\ntemplate <typename T>\nvoid debug_func_mult(const V<string> &names, const T &t) {\n    debug_func(t, names[0]);\n}\n\ntemplate <typename Head, typename... Tail>\nvoid debug_func_mult(int idx, const V<string> &names, const Head &head, const Tail&... args) {\n    debug_func(head, names[idx]);\n    debug_func_mult(idx + 1, names, args...);\n}\n\ntemplate <typename Head, typename... Tail>\nvoid debug_func_mult(const V<string> &names, const Head &head, const Tail&... args) {\n    debug_func(head, names[0]);\n    debug_func_mult(1, names, args...);\n}\n\nV<string> split_names(string &&s) {\n    replace(ALL(s), ' ', ',');\n    V<string> ret;\n    istringstream ss(s);\n    string t;\n    while(getline(ss, t, ',')) if(t.size()) ret.push_back(move(t));\n    return move(ret);\n}\n\nvoid init_io() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(30);\n}\n\nusing TLL = tuple<ll, ll, ll>;\nconst ll INF = 5e15;\n\nint main() {\n    init_io();\n    ll N, Q;\n    cin >> N >> Q;\n    V<ll> A(2 * N), B(2 * N);\n    for(ll &e : A) cin >> e;\n    for(ll &e : B) cin >> e;\n    ll sum = accumulate(ALL(A), 0ll);\n    ll pcnt = 0;\n    ll psum = 0;\n    map<ll, ll> plus, minus;\n    for(ll i = 1; i < 2 * N - 1; i++) {\n        ll dic = B[i] - A[i];\n        if(dic >= 0) {\n            pcnt++;\n            psum += dic;\n            plus[dic]++;\n        } else {\n            minus[-dic]++;\n        }\n    }\n\n    auto update_query = [&](ll dic, bool addq) {\n        auto &mp = (dic < 0 ? minus : plus);\n        dic = abs(dic);\n        if(addq) {\n            mp[dic]++;\n        } else {\n            auto ite = mp.find(dic);\n            ite->second--;\n            if(ite->second == 0) mp.erase(ite);\n        }\n    };\n\n    auto adjust = [&] {\n        if(pcnt % 2 == 0) return psum;\n        auto itep = plus.lower_bound(0);\n        auto item = minus.lower_bound(0);\n        ll mval = min(itep->first, item->first);\n        return psum - mval;\n    };\n\n    for(ll QQ = 0; QQ < Q; QQ++) {\n        ll p, a, b;\n        cin >> p >> a >> b;\n        p--;\n        ll pre_dic = B[p] - A[p];\n        ll new_dic = b - a;\n        sum = sum - A[p] + a;\n        A[p] = a;\n        B[p] = b;\n        if(p != 0 && p != 2 * N - 1) {\n            if(pre_dic >= 0) {\n                pcnt--;\n                psum -= pre_dic;\n            }\n            if(new_dic >= 0) {\n                pcnt++;\n                psum += new_dic;\n            }\n            update_query(pre_dic, false);\n            update_query(new_dic, true);\n        }\n        ll addv = adjust();\n        cout << sum + addv << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\n\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntemplate<typename T>inline void upmin(T &x,T y) { y<x?x=y:0; }\ntemplate<typename T>inline void upmax(T &x,T y) { x<y?x=y:0; }\n\ntypedef unsigned int u32;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst LL OO=1e18;\n\nconst int N=1e6;\n\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\n\nLL a[N],b[N];\nLL f[N],g[N];\n#define lc (i<<1)\n#define rc (lc|1)\ninline void modify(int i,int l,int r,int k) {\n\tif (l==r) f[i]=a[l],g[i]=b[l];\n\telse {\n\t\tint mid=(l+r)>>1;\n\t\tk<=mid?modify(lc,l,mid,k):modify(rc,mid+1,r,k);\n\t\tf[i]=max(f[lc]+f[rc],g[lc]+g[rc]);\n\t\tg[i]=max(f[lc]+g[rc],g[lc]+f[rc]);\n\t}\n}\nint main()\n{\n\tint n=gi()*2,m=gi(),i,k;\n\tfor (i=1;i<=n;i++) a[i]=gi();\n\tfor (i=1;i<=n;i++) b[i]=gi();\n\tb[1]=b[n]=-OO;\n\tfor (i=1;i<=n;i++) modify(1,1,n,i);\n\twhile (m--) {\n\t\tk=gi(),a[k]=gi(),b[k]=gi();\n\t\tb[1]=b[n]=-OO;\n\t\tmodify(1,1,n,k);\n\t\tprintf(\"%lld\\n\",f[1]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define INF 100000000\n#define YJ 1145141919\n#define INF_INT_MAX 2147483647\n#define INF_LL 9223372036854775\n#define INF_LL_MAX 9223372036854775807\n#define EPS 1e-10\n#define MOD 1000000007\n#define Pi acos(-1)\n#define LL long long\n#define ULL unsigned long long\n#define LD long double\n\n#define int long long\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a)  begin((a)), end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n\nconst int MAX_N = 200005;\nconst int MAX_Q = 200005;\n\nint N;\nint Q;\nint A[MAX_N];\nint B[MAX_N];\nint P[MAX_Q], X[MAX_Q], Y[MAX_Q];\n\n//l:偶数個　r:奇数個\nclass Node {\npublic:\n    Node(LL v = unitValue, LL v2 = unitValue) : l(v), r(v2) {\n\n    }\n\n    Node operator + (const Node& monoid) const {\n        Node node;\n        if(l != -INF_LL && monoid.l != -INF_LL) {\n            node.l = max(node.l, l + monoid.l);\n        }\n        if(r != -INF_LL && monoid.r != -INF_LL) {\n            node.l = max(node.l, r + monoid.r);\n        }\n\n        if(l != -INF_LL && monoid.r != -INF_LL) {\n            node.r = max(node.r, l + monoid.r);\n        }\n        if(r != -INF_LL && monoid.l != -INF_LL) {\n            node.r = max(node.r, r + monoid.l);\n        }\n        \n        if(l == -INF_LL && r == -INF_LL) {\n            node.l = max(node.l, monoid.l);\n            node.r = max(node.r, monoid.r);\n        }\n        if(monoid.l == -INF_LL && monoid.r == -INF_LL) {\n            node.l = max(node.l, l);\n            node.r = max(node.r, r);\n        }\n\n        return node;\n    }\n\n    static Node unit() {\n        return Node(unitValue);\n    }\n\n    LL getL() const {\n        return this->l;\n    }\n\n    LL getR() const {\n        return this->r;\n    }\n\n    void print() {\n        cerr << l << \",\" << r << endl;\n    }\n\nprivate:\n    LL l, r;\n    static const LL unitValue = -INF_LL;\n};\n\ntemplate <class T>\nclass SegmentTree {\npublic:\n    SegmentTree(int size) {\n        init(size);\n    }\n\n    void init(int size) {\n        vec.clear();\n        k = 1;\n        while(k < size) {\n            k *= 2;\n        }\n        for(int i = 0; i < 2*k; i++) {\n            vec.push_back(T::unit());\n        }\n    }\n\n    void update(int i, T x) { //iをxに変更する\n        i += k-1;\n        vec[i] = x;\n        while(i > 0) {\n            i = (i-1)/2;\n            vec[i] = vec[i*2+1] + vec[i*2+2];\n        }\n    }\n\n    T find(int l, int r) {\n        return _find(l, r, 0, 0, k);\n    }\n\n    void print() {\n        REP(i,vec.size()) {\n            T t = vec[i];\n            cerr << i << \": \"; t.print();\n        }\n    }\n\nprivate:\n    vector<T> vec;\n    int k;\n\n    T _find(int l, int r, int k, int x, int y) {\n        if (r <= x || y <= l) { //重なってない場合\n            return T::unit();\n        } else if (l <= x && y <= r) { //完全にかぶってる場合\n            return vec[k];\n        } else { //中途半端にかぶってる場合\n            int mid = (x+y)/2;\n            T lNode = _find(l, r, 2*k+1, x, mid);\n            T rNode = _find(l, r, 2*k+2, mid, y);\n            return lNode + rNode;\n        }\n    }\n};\n\nsigned main()\n{\n    cin >> N >> Q;\n    REP(i,2*N) {\n        cin >> A[i];\n    }\n    REP(i,2*N) {\n        cin >> B[i];\n    }\n    REP(q,Q) {\n        cin >> P[q] >> X[q] >> Y[q];\n        P[q]--;\n    }\n\n    SegmentTree<Node> seg(2*N);\n\n    int ans = A[0] + A[2*N-1];\n    seg.update(0,Node(-INF_LL, A[0]));\n    seg.update(2*N-1,Node(-INF_LL, A[2*N-1]));\n    FOR(i,1,2*N-1) {\n        // cerr << i << endl;\n        seg.update(i,Node(B[i], A[i]));\n    }\n\n\n    // Node n1 = seg.find(0,2*N);\n    // cerr << \"Debug: \" << n1.getL() << \" \" << n1.getR() << endl;\n    // seg.print();\n\n    REP(q,Q) {\n        if(P[q] == 0 || P[q] == 2*N-1) {\n            seg.update(P[q], Node(-INF_LL, X[q]));\n        } else {\n            seg.update(P[q], Node(Y[q], X[q]));\n        }\n        // cerr << \"*** \" << endl;\n        // seg.print();\n        cout << seg.find(0,2*N).getL() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nll n,q;\nll a[201010],b[201010];\n\nint main(){\n  cin>>n>>q;\n  n*=2;\n  rep(i,n)cin>>a[i];\n  rep(i,n)cin>>b[i];\n  vector<ll> v;\n  ll score=0;\n  if(q!=1)return 0;\n  ll p,pa,pb;\n  cin>>p>>pa>>pb;\n  p--;\n  a[p]=pa; b[p]=pb;\n  repl(i,1,n-1){\n    v.push_back(b[i]-a[i]);\n  }\n  sort(all(v));\n  rep(i,n)score+=a[i];\n  //dbg(score);\n  rep(i,v.size()-1){\n    if(v[i]+v[i+1]>0){\n      score+=v[i]+v[i+1];\n      i++;\n    }else break;\n  }\n  cout<<score<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n//#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, q);\n\tVEC(int, a, 2 * n);\n\tVEC(int, b, 2 * n);\n\n\tint sum = 0;\n\tREP(i, 2 * n) sum += a[i];\n\n\tstd::multiset<int> A, B;\n\tint tsum = 0;\n\tREP(i, 2 * n) {\n\t\tif (i == 0 || i == 2 * n - 1) continue;\n\t\tint t = b[i] - a[i];\n\t\tif (t >= 0) B.insert(t), tsum += t;\n\t\telse A.insert(t);\n\t}\n\n\tauto norm = [&] {\n\t\twhile (!A.empty() && *A.rbegin() >= 0) {\n\t\t\tint t = *A.rbegin();\n\t\t\tA.erase(A.find(t));\n\t\t\tB.insert(t); tsum += t;\n\t\t}\n\t\twhile (!B.empty() && *B.begin() < 0) {\n\t\t\tint t = *B.begin();\n\t\t\tB.erase(B.find(t));\n\t\t\tA.insert(t); tsum -= t;\n\t\t}\n\n\t\tif (A.size() % 2 == 1) {\n\t\t\tint aa = *A.rbegin();\n\t\t\tint bb = *B.begin();\n\t\t\tif (-aa < bb) {\n\t\t\t\tA.erase(A.find(aa));\n\t\t\t\tB.insert(aa); tsum += aa;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tB.erase(B.find(bb));\n\t\t\t\tA.insert(bb); tsum -= bb;\n\t\t\t}\n\t\t}\n\t};\n\n\tREP(_, q) {\n\t\tVAR(int, p, x, y);\n\t\t--p;\n\t\tsum += x - a[p];\n\t\tint pre = b[p] - a[p];\n\t\ta[p] = x;\n\t\tb[p] = y;\n\t\tif (p > 0 && p < 2 * n - 1) {\n\t\t\tint t = y - x;\n\t\t\tif (A.count(pre)) {\n\t\t\t\tA.erase(A.find(pre));\n\t\t\t}\n\t\t\telse if (B.count(pre)) {\n\t\t\t\tB.erase(B.find(pre)); tsum -= pre;\n\t\t\t}\n\t\t\tA.insert(t);\n\t\t}\n\t\tnorm();\n\t\tOUT(sum + tsum)BR;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  LL N, Q;\n  cin >> N >> Q;\n\n  VL as(N*2), bs(N*2);\n  cin >> as >> bs;\n\n  if(N == 1){\n    while(Q--){\n    int p, x, y;\n    cin >> p >> x >> y;\n    --p;\n    as[p] = x;\n    bs[p] = y;\n    cout<<as[0]+as[1]<<endl;      \n    }\n    return 0;\n  }\n\n  int par = 0;\n  LL sum = as[0] + as.back();\n  multiset<LL> dels;\n  FOR(i,1,2*N-1){\n    LL mx = max(as[i], bs[i]);\n    LL mn = min(as[i], bs[i]);\n    sum += mx;\n    if(mx == as[i]) par ^= 1;\n    dels.insert(mn - mx);\n  }\n\n  while(Q--){\n    int p, x, y;\n    cin >> p >> x >> y;\n    --p;\n\n    LL mx = max(as[p], bs[p]);\n    LL mn = min(as[p], bs[p]);\n    sum -= mx;\n    if(mx == as[p]) par ^= 1;\n    auto it = dels.find(mn - mx);\n    dels.erase(it);\n\n    as[p] = x;\n    bs[p] = y;\n    LL mx2 = max(as[p], bs[p]);\n    LL mn2 = min(as[p], bs[p]);\n    sum += mx2;\n    if(mx2 == as[p]) par ^= 1;\n    dels.insert(mn2 - mx2);\n\n    LL ans = 0;\n    if(par == 0){\n      ans = sum;\n    }\n    else{\n      ans = sum + *(dels.rbegin());\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nset< P > A,B;\nll sumA=0;\n\nll N,Q;\n\nll a[100005];\nll b[100005];\nll tmp=0;\n\nll funcA(){\n  if(A.empty())return 0;\n  return A.begin()->first;\n}\n\nll funcB(){\n  if(B.empty())return 0;\n  auto it=B.end();\n  it--;\n  return it->first;\n}\n\nint main(){\n  cin>>N>>Q;\n  N*=2;\n  for(int i=0;i<N;i++){\n    cin>>a[i];\n    tmp+=a[i];\n  }\n  for(int i=0;i<N;i++)cin>>b[i];\n\n  for(int i=1;i+1<N;i++){\n    P p=P(b[i]-a[i],i);\n    if(p.first>0){\n      A.insert(p);\n      sumA += p.first;\n    }else{\n      B.insert(p);\n    }\n  }\n\n  for(int i=0;i<Q;i++){\n    ll id,na,nb;\n    cin>>id>>na>>nb;\n    id--;\n    \n    if( id == 0 || id == N-1 ){\n      tmp -= a[id];\n      a[id]=na;\n      tmp += a[id];\n    }else{\n      tmp -= a[id];\n      tmp += na;\n      P p=P(b[id]-a[id],id);\n      a[id]=na;\n      b[id]=nb;\n      P np=P(b[id]-a[id],id);\n\n      if(A.count(p)){\n        A.erase(p);\n        sumA-=p.first;\n      }else{\n        B.erase(p);\n      }\n    \n      if(np.first>0){\n        A.insert(np);\n        sumA+=np.first;\n      }else{\n        B.insert(np);\n      }\n    }\n    /*\n    cout<<\"////\"<<endl;\n    for(auto p : A)cout<<p.first<<' '<<p.second<<endl;\n    cout<<\"////\"<<endl;\n    */\n    if(A.size()%2==0){\n      cout<<tmp+sumA<<endl;\n    }else if(!A.empty()&&!B.empty()&&funcA()+funcB()>=0){\n      //      cout<<\"X\"<<endl;\n      cout<<tmp+sumA+funcB()<<endl;      \n    }else{\n      //      cout<<\"Y\"<<endl;\n      cout<<tmp+sumA-funcA()<<endl;\n    }\n    \n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nset< P > A,B;\nll sumA=0;\n\nll N,Q;\n\nll a[200005];\nll b[200005];\nll tmp=0;\n\nll funcA(){\n  if(A.empty())return 0;\n  return A.begin()->first;\n}\n\nll funcB(){\n  if(B.empty())return 0;\n  auto it=B.end();\n  it--;\n  return it->first;\n}\n\nint main(){\n  cin>>N>>Q;\n  N*=2;\n  for(int i=0;i<N;i++){\n    cin>>a[i];\n    tmp+=a[i];\n  }\n  for(int i=0;i<N;i++)cin>>b[i];\n\n  for(int i=1;i+1<N;i++){\n    P p=P(b[i]-a[i],i);\n    if(p.first>0){\n      A.insert(p);\n      sumA += p.first;\n    }else{\n      B.insert(p);\n    }\n  }\n\n  for(int i=0;i<Q;i++){\n    ll id,na,nb;\n    cin>>id>>na>>nb;\n    id--;\n    \n    if( id == 0 || id == N-1 ){\n      tmp -= a[id];\n      a[id]=na;\n      tmp += a[id];\n    }else{\n      tmp -= a[id];\n      tmp += na;\n      P p=P(b[id]-a[id],id);\n      a[id]=na;\n      b[id]=nb;\n      P np=P(b[id]-a[id],id);\n\n      if(A.count(p)){\n        A.erase(p);\n        sumA-=p.first;\n      }else{\n        B.erase(p);\n      }\n    \n      if(np.first>0){\n        A.insert(np);\n        sumA+=np.first;\n      }else{\n        B.insert(np);\n      }\n    }\n    /*\n    cout<<\"////\"<<endl;\n    for(auto p : A)cout<<p.first<<' '<<p.second<<endl;\n    cout<<\"////\"<<endl;\n    */\n    if(A.size()%2==0){\n      cout<<tmp+sumA<<endl;\n    }else if(!A.empty()&&!B.empty()&&funcA()+funcB()>=0){\n      //      cout<<\"X\"<<endl;\n      cout<<tmp+sumA+funcB()<<endl;      \n    }else{\n      //      cout<<\"Y\"<<endl;\n      cout<<tmp+sumA-funcA()<<endl;\n    }\n    \n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,Q;\nint A[201010];\nint B[201010];\nmultiset<int> p,n;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>Q;\n\tll S=0,T=0;\n\tFOR(i,2*N) cin>>A[i], S+=A[i];\n\tFOR(i,2*N) {\n\t\tcin>>B[i];\n\t\tB[i]-=A[i];\n\t\tif(i!=0 && i!=2*N-1) {\n\t\t\tif(B[i]>0) {\n\t\t\t\tp.insert(B[i]);\n\t\t\t\tT+=B[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tn.insert(-B[i]);\n\t\t\t}\n\t\t}\n\t}\n\twhile(Q--) {\n\t\tcin>>i>>x>>y;\n\t\ti--;\n\t\tS-=A[i];\n\t\tif(i!=0 && i!=2*N-1) {\n\t\t\tif(B[i]>0) {\n\t\t\t\tp.erase(p.find(B[i]));\n\t\t\t\tT-=B[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tn.erase(n.find(-B[i]));\n\t\t\t}\n\t\t}\n\t\t\n\t\tA[i]=x;\n\t\tS+=x;\n\t\tB[i]=y-A[i];\n\t\tif(i!=0 && i!=2*N-1) {\n\t\t\tif(B[i]>0) {\n\t\t\t\tp.insert(B[i]);\n\t\t\t\tT+=B[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tn.insert(-B[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tll ma=0;\n\t\tif(p.size()%2==0) ma=S+T;\n\t\telse ma=S+max(T-*p.begin(),T-*n.begin());\n\t\tcout<<ma<<endl;\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'[';\n    for(const T &i: a) out<<i<<',';\n    out<<']';\n    return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out, const set<T>& a) {\n    out<<'{';\n    for(const T &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out, const multiset<T>& a) {\n    out<<'{';\n    for(const T &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\ntemplate<class T, class S>\nostream &operator <<(ostream& out, const map<T,S>& a) {\n    out<<'{';\n    for(auto &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n, q;\n    cin >> n >> q;\n    n *= 2;\n    vector<ll> a(n), b(n);\n    REP(i, n) cin >> a[i];\n    REP(i, n) cin >> b[i];\n\n    ll suma = 0;\n    REP(i, n) suma += a[i];\n\n    ll sum = 0, cnt = 0;\n    multiset<ll> st1, st2;\n    FOR(i, 1, n-1) {\n        if(b[i]-a[i] > 0) {\n            sum += b[i]-a[i];\n            cnt++;\n            st1.insert(b[i]-a[i]);\n        } else {\n            st2.insert(b[i]-a[i]);\n        }\n    }\n\n    REP(i, q) {\n        ll p, x, y;\n        cin >> p >> x >> y; p--;\n\n        if(0 < p && p < n-1) {\n            if(b[p]-a[p] > 0) {\n                sum -= b[p]-a[p];\n                cnt--;\n                auto itr = st1.find(b[p]-a[p]);\n                st1.erase(itr);\n            } else {\n                auto itr = st2.find(b[p]-a[p]);\n                st2.erase(itr);\n            }\n        }\n        suma -= a[p];\n\n        a[p] = x;\n        b[p] = y;\n        if(0 < p && p < n-1) {\n            if(b[p]-a[p] > 0) {\n                sum += b[p]-a[p];\n                cnt++;\n                st1.insert(b[p]-a[p]);\n            } else {\n                st2.insert(b[p]-a[p]);\n            }\n        }\n        suma += a[p];\n\n        // cout << suma << \" \" << sum << \" \" << cnt << \" \" << st1 << \" \" << st2 << endl;\n        if(cnt%2==0) cout << suma + sum << endl;\n        else cout << max(suma + sum + *st2.rbegin(), suma + sum - *st1.begin()) << endl;\n    }\n\n    // ll n;\n    // cin >> n;\n    //\n    // vector<ll> a;\n    // REP(i, 1LL<<n) {\n    //     bool flag = true;\n    //     ll sum = 0;\n    //     REP(j, n) {\n    //         sum += (i&1LL<<j)?1:-1;\n    //         if(sum < 0) {\n    //             flag = false;\n    //             break;\n    //         }\n    //     }\n    //     if(sum != 0) flag = false;\n    //     if(flag) a.push_back(i);\n    // }\n    // // cout << a << endl;\n    //\n    // ll m = a.size();\n    // set<vector<ll>> st;\n    // REP(i, m) FOR(j, i+1, m) {\n    //     vector<ll> diff;\n    //     REP(k, n) {\n    //         if((a[i]&1LL<<k) != (a[j]&1LL<<k)) {\n    //             diff.push_back(k);\n    //         }\n    //     }\n    //     st.insert(diff);\n    // }\n    // cout << st << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<59;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e5;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n,q;\nvl a,b;\n\nint main(){\n\tcin>>n>>q;\n\tn*=2;\n\ta=b=vl(n);\n\tfor(int i=0;i<n;i++) cin>>a[i];\n\tfor(int i=0;i<n;i++) cin>>b[i];\n\tll sum=0,tmp=0;\n\tmultiset<ll> st1,st2;\n\tfor(int i=1;i<n-1;i++){\n\t\tll t=a[i]-b[i];\n\t\ttmp+=b[i];\n\t\tif(t>0){\n\t\t\tst1.insert(t);\n\t\t\tsum+=t;\n\t\t}\n\t\telse st2.insert(t);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tll p,x,y;\n\t\tcin>>p>>x>>y;\n\t\tp--;\n\t\tll t=a[p]-b[p];\n\t\tif(t>0){\n\t\t\tst1.erase(st1.lower_bound(t));\n\t\t\tsum-=t;\n\t\t}\n\t\telse st2.erase(st2.lower_bound(t));\n\t\ttmp+=y-b[p];\n\t\ta[p]=x;b[p]=y;\n\t\tt=a[p]-b[p];\n\t\tif(t>0){\n\t\t\tst1.insert(t);\n\t\t\tsum+=t;\n\t\t}\n\t\telse st2.insert(t);\n\t\tif(st1.size()%2==0) cout<<sum+tmp+a[0]+a[n-1]<<endl;\n\t\telse{\n\t\t\tcout<<max(-*st1.begin(),(st2.empty()?-INF:*(--st2.end())))+sum+tmp+a[0]+a[n-1]<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  LL N, Q;\n  cin >> N >> Q;\n\n  VL as(N*2), bs(N*2);\n  cin >> as >> bs;\n\n  if(N == 1){\n    while(Q--){\n    int p, x, y;\n    cin >> p >> x >> y;\n    --p;\n    as[p] = x;\n    bs[p] = y;\n    cout<<as[0]+as[1]<<endl;      \n    }\n    return 0;\n  }\n\n  int par = 0;\n  LL sum = as[0] + as.back();\n  multiset<LL> dels;\n  FOR(i,1,2*N-1){\n    LL mx = max(as[i], bs[i]);\n    LL mn = min(as[i], bs[i]);\n    sum += mx;\n    if(mx == as[i]) par ^= 1;\n    dels.insert(mn - mx);\n  }\n\n  while(Q--){\n    LL p, x, y;\n    cin >> p >> x >> y;\n    --p;\nif(p==0||p==2*N-1){\nsum-=as[p]-x;as[p]=x;\ncout<<sum+(par?*dels.rbegin():0ll)<<endl;continue;\n}\n    LL mx = max(as[p], bs[p]);\n    LL mn = min(as[p], bs[p]);\n    sum -= mx;\n    if(mx == as[p]) par ^= 1;\n    auto it = dels.find(mn - mx);\n    dels.erase(it);\n\n    as[p] = x;\n    bs[p] = y;\n    LL mx2 = max(as[p], bs[p]);\n    LL mn2 = min(as[p], bs[p]);\n    sum += mx2;\n    if(mx2 == as[p]) par ^= 1;\n    dels.insert(mn2 - mx2);\n\n    LL ans = 0;\n    if(par == 0){\n      ans = sum;\n    }\n    else{\n      auto it = dels.rbegin();\n      assert(it != dels.rend());\n      ans = sum + *it;\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = 1e18;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  n *= 2;\n  assert(q <= 10);\n  vl a(n), b(n);\n  rep (i, n) {\n    cin >> a[i];\n  }\n  rep (i, n) {\n    cin >> b[i];\n  }\n  cout << endl;\n  while (q--) {\n    int p, x, y;\n    cin >> p >> x >> y;\n    p--;\n    a[p] = x;\n    b[p] = y;\n    vector<vll> dp(n + 1, vll(3, vl(2, -INF)));\n    dp[0][0][0] = 0;\n    rep (i, n - 1) {\n      rep (j, 3) {\n        rep (k, 2) {\n          if (dp[i][j][k] <= -INF/2) continue;\n          if (j == 0) {\n            chmax(dp[i + 1][1][k], dp[i][j][k] + a[i]);\n          }\n          else if (j == 1) {\n            chmax(dp[i + 1][2][k], dp[i][j][k] + a[i]);\n            chmax(dp[i + 1][1][1 - k], dp[i][j][k] + b[i]);\n          }\n          else {\n            chmax(dp[i + 1][2][k], dp[i][j][k] + a[i]);\n            chmax(dp[i + 1][2][1 - k], dp[i][j][k] + b[i]);\n          }\n        }\n      }\n    }\n    ll ans = max(dp[n - 1][1][0], dp[n - 1][2][0]) + a[n - 1];\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N,Q;\nvi a,b;\nmultiset<int> X,Y;\nll ans;\n\nint main() {\n    setIO(); re(N,Q); a.rsz(2*N), b.rsz(2*N); re(a,b);\n    F0R(i,2*N) {\n        if (i == 0 || i == 2*N-1) ans += a[i];\n        else {\n            ans += max(a[i],b[i]);\n            if (a[i] > b[i]) X.insert(a[i]-b[i]);\n            else Y.insert(b[i]-a[i]);\n        }\n    }\n    F0R(i,Q) {\n        int p,x,y; re(p,x,y); p--;\n        if (p == 0 || p == 2*N-1) {\n            ans -= a[p];\n            a[p] = x;\n            ans += a[p];\n        } else {\n            if (a[p] > b[p]) X.erase(X.find(a[p]-b[p]));\n            else Y.erase(Y.find(b[p]-a[p]));\n            ans -= max(a[p],b[p]);\n            a[p] = x, b[p] = y;\n            ans += max(a[p],b[p]);\n            if (a[p] > b[p]) X.insert(a[p]-b[p]);\n            else Y.insert(b[p]-a[p]);\n        }\n        if (sz(X)%2 == 0) ps(ans);\n        else ps(ans-min(*X.begin(),*Y.begin()));\n    }\n}\n\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nll n,q;\nll a[201010],b[201010];\nmultiset<ll> ps,ms;\nll asum,psum;\n\nint main(){\n  cin>>n>>q;\n  n*=2;\n  rep(i,n)cin>>a[i];\n  rep(i,n)cin>>b[i];\n  rep(i,n){\n    asum+=a[i];\n  }\n\n  repl(i,1,n-1){\n    if(b[i]-a[i]>=0){\n      ps.insert(b[i]-a[i]);\n      psum+=b[i]-a[i];\n    }else ms.insert(b[i]-a[i]);\n  }\n\n  while(q--){\n    ll p,x,y;\n    cin>>p>>x>>y;\n    p--;\n    if(p==0||p==n-1){\n      asum-=a[p];\n      a[p]=x; b[p]=y;\n      asum+=a[p];\n    }else{\n      if(b[p]-a[p]>=0){\n        ps.erase(ps.lower_bound(b[p]-a[p]));\n        psum-=b[p]-a[p];\n\n        asum-=a[p];\n        a[p]=x; b[p]=y;\n        asum+=a[p];\n\n        if(b[p]-a[p]>=0){\n          ps.insert(b[p]-a[p]);\n          psum+=b[p]-a[p];\n        }else{\n          ms.insert(b[p]-a[p]);\n        }\n      }else{\n        ms.erase(ms.lower_bound(b[p]-a[p]));\n\n        asum-=a[p];\n        a[p]=x; b[p]=y;\n        asum+=a[p];\n\n        if(b[p]-a[p]>=0){\n          ps.insert(b[p]-a[p]);\n          psum+=b[p]-a[p];\n        }else{\n          ms.insert(b[p]-a[p]);\n        }\n      }\n    }\n\n    if(ps.size()%2==0)cout<<asum+psum<<endl;\n    else{\n      ll hoge=asum+psum+(*ms.rbegin());\n      ll fuga=asum+psum-(*ps.begin());\n      cout<<max(hoge,fuga)<<endl;\n    }\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define MT make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define RT return\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\n/*\nセグメント木\n\nint _query(int a, int b, int k, int l, int r)\n[a,b)\nl,rは今見ている範囲\n内部で呼ぶだけ\nコンストラクタ\n要素数、初期値, 隣接要素を引数とする関数\nquery(int a, int b)\nクエリ[a,b), 0Origin\nint cal(int a, int b)\n*/\ntemplate<class Value>\nclass SegmentTree {\n    int n;\n    Value e;\n    vector<Value> dat;\n    function<Value(Value, Value)> f;\n\n    inline Value query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return e;\n        if (a <= l && r <= b) return dat[k];\n        else {\n            Value vl, vr;\n            vl = query(a, b, k << 1, l, (l + r) >> 1);\n            vr = query(a, b, (k << 1) | 1, (l + r) >> 1, r);\n            return f(vl, vr);\n        }\n    }\n\npublic:\n    SegmentTree() {}\n\n    SegmentTree(int n_, Value init_, function<Value(Value, Value)> f_)\n        :n(1), e(init_), f(f_) {\n        for (; n<n_; n <<= 1);\n        dat = vector<Value>(n << 1, e);\n    }\n\n    void update(int k, Value a) {\n        k += n;\n        dat[k] = a;\n        while (k>1) {\n            k >>= 1;\n            dat[k] = f(dat[k << 1], dat[(k << 1) | 1]);\n        }\n    }\n\n    Value query(int a, int b) {\n        return query(a, b, 1, 0, n);\n    }\n};\n\nusing P = array<ll, 2>;\nP f(P p, P q) {\n    P r;\n    r[0] = max(p[0] + q[0], p[1] + q[1]);\n    r[1] = max(p[0] + q[1], p[1] + q[0]);\n    return r;\n}\nconst ll MI = LLONG_MIN / 3;\nusing ST = SegmentTree<P>;\n\nvoid solve() {\n    int N, Q;\n    cin >> N >> Q;\n\n    vi A(2*N), B(2*N);\n    rep(i, 2 * N) cin >> A[i];\n    rep(i, 2 * N) cin >> B[i];\n\n    P e{ 0, MI};\n    ST st(2 * N, e, f);\n\n    rep(i, 2 * N) {\n        st.update(i, P{ A[i], B[i] });\n    }\n    rep(i, Q) {\n        int p, x, y;\n        cin >> p >> x >> y;\n        p--;\n        A[p] = x;\n        B[p] = y;\n        st.update(p, P{ x, y });\n        ll ans = A[0] + A[2 * N - 1] + st.query(1, 2 * N - 1)[0];\n        cout<<ans<<endl;\n    }\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(15);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef double lld;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<double> vdl;\ntypedef vector<vector<lli>> mat;\ntypedef vector<vdl> mad;\ntypedef unordered_map<lli,unordered_map<lli,lli>> graph;\ntypedef complex<double> cmp;\ntypedef vector<cmp> vcl;\n\nlli n,q;\nvll a,b,c;\nmultiset<lli> l,r;\nlli ans = 0;\nlli p,x,y;\n\nint main(){\n  cin >> n >> q;\n  a = vll(2*n);\n  b = vll(2*n);\n  c = vll(2*n);\n  for(lli i = 0;i < 2*n;i++) cin >> a[i];\n  for(lli i = 0;i < 2*n;i++) cin >> b[i];\n  for(lli i = 0;i < 2*n;i++) c[i] = a[i]-b[i];\n  ans = accumulate(a.begin(),a.end(),0ll);\n  for(lli i = 1;i < 2*n-1;i++){\n    if(c[i] < 0){\n      r.insert(c[i]);\n    }else{\n      l.insert(c[i]);\n    }\n  }\n\n  for(lli x : r){\n    ans -= x;\n  }\n  for(lli i = 0;i < q;i++){\n    cin >> p >> x >> y;\n    p--;\n    if(p >= 1 && p < 2*n-1){\n      if(l.find(c[p]) != l.end()) l.erase(l.find(c[p]));\n      else if(r.find(c[p]) != r.end()){\n        r.erase(r.find(c[p]));\n        ans += c[p];\n      }\n    }\n    ans -= a[p];\n    a[p] = x;\n    b[p] = y;\n    c[p] = a[p]-b[p];\n    ans += a[p];\n    if(p >= 1 && p < 2*n-1){\n      if(c[p] < 0){\n        r.insert(c[p]);\n        ans -= c[p];\n      } else l.insert(c[p]);\n    }\n    if(r.size()%2 == 1 && *r.rbegin()+*l.begin() < 0) cout << ans+*l.begin() << endl;\n    else if(r.size()%2 == 1 && *r.rbegin()+*l.begin() >= 0) cout << ans+*r.rbegin() << endl;\n    else cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e16)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstruct SegmentTree {\nprivate:\n    int n;\n    vector<ll> node_plus;\n    vector<ll> node_minus;\n \npublic:\n    SegmentTree() {\n        int sz = 200005;\n        n = 1; while(n < sz) n *= 2;\n        node_plus.resize(2*n-1, INF);\n        node_minus.resize(2*n-1, -INF);\n        for(int i = 0; i < node_plus.size(); i++){\n            node_plus[i] = INF;\n            node_minus[i] = -INF;\n        }\n    }\n \n    void update(int x, ll val) {\n        x += (n - 1);\n        if(val > 0){\n            node_minus[x] = -INF;\n            node_plus[x] = val;\n        } else {\n            node_minus[x] = val;\n            node_plus[x] = INF;\n        }\n        if(val == 0){\n            node_minus[x] = 0;\n            node_plus[x] = 0;\n        }\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node_minus[x] = max(node_minus[2*x+1], node_minus[2*x+2]);\n            node_plus[x] = min(node_plus[2*x+1], node_plus[2*x+2]);\n            //node[x] = min(node[2*x+1], node[2*x+2]);\n        }\n    }\n    // hannkaikukann \n    ll getminus(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return -INF;\n        if(a <= l && r <= b) return node_minus[k];\n \n        ll vl = getminus(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getminus(a, b, 2*k+2, (l+r)/2, r);\n        return max(vl, vr);\n    }\n    ll getplus(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return INF;\n        if(a <= l && r <= b) return node_plus[k];\n \n        ll vl = getplus(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getplus(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n};\n\n\nint main() {\n    //cout.precision(10);\n    SegmentTree seg;\n    int n, q;\n    cin >> n >> q;\n    ll a[200500];\n    ll b[200500];\n    ll asum = 0;\n    for(int i = 1; i <= 2 * n; i++){\n        cin >> a[i];\n        asum += a[i];\n    }\n    for(int i = 1; i <= 2 * n; i++){\n        cin >> b[i];\n    }\n    ll ans = asum;\n    ll checker = 0;\n    for(int i = 2; i < 2 * n; i++){\n        ll delta = b[i] - a[i];\n        if(delta > 0){\n            ans += delta;\n            checker++;\n        }\n        seg.update(i, delta);\n    }\n    for(int time = 0; time < q; time++){\n        int p;\n        ll x, y;\n        cin >> p >> x >> y;\n        ans = ans - a[p] + x;\n        ll before = b[p] - a[p];\n        ll after = y - x;\n        //cout << time << \" \" << a[p] << \" \" << x << endl;\n        a[p] = x;\n        b[p] = y;\n        if((p == 1) || (p == (2 * n))){\n            if((checker % 2) == 0){\n                cout << ans << endl;\n                continue;\n            } else {\n                cout << ans - min(-seg.getminus(2, 2 * n), seg.getplus(2, 2 * n)) << endl;\n            }\n            //cout << ans << endl;\n            continue;\n        }\n        ans = ans - max((ll)0, before) + max((ll)0, after);\n        if((before > 0) && (after <= 0)){\n            checker--;\n        }\n        if((before <= 0) && (after > 0)){\n            checker++;\n        }\n        seg.update(p, after);\n        if((checker % 2) == 0){\n            cout << ans << endl;\n            continue;\n        }\n        cout << ans - min(-seg.getminus(2, 2 * n), seg.getplus(2, 2 * n)) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint main(){\n  int N,Q;\n  cin>>N>>Q;\n  vector<ll> a(2*N),b(2*N);\n  for(int i=0;i<2*N;i++) cin>>a[i];\n  for(int i=0;i<2*N;i++) cin>>b[i];\n\n  multiset<ll> se;\n  ll ans=a[0]+a[2*N-1];\n  int odd=0;\n  for(int i=1;i<2*N-1;i++){\n      se.insert(abs(a[i]-b[i]));\n      ans+=max(a[i],b[i]);\n      if(a[i]<b[i]) odd^=1;\n  }\n\n  for(int i=0;i<Q;i++){\n      int p,x,y;\n      cin>>p>>x>>y;\n      p--;\n      ll res=ans;\n      if(p==0||p==2*N-1){\n          res=res-a[p]+x;\n      }else{\n          res-=max(a[p],b[p]);\n          res+=max(x,y);\n          if(a[p]<b[p]) odd^=1;\n          if(x<y) odd^=1;\n          se.erase(se.find(abs(a[p]-b[p])));\n          se.insert(abs(x-y));\n      }\n      a[p]=x;\n      b[p]=y;\n      \n      if(odd==1) cout<<res-*(se.begin())<<endl;\n      else cout<<res<<endl;\n      ans=res;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\nconst int limit = 200010;\nll a[limit], b[limit];\nconst ll inf = 1LL << 60;\n\n\nmultiset<ll> positive, negative;\nll a_total = 0LL, p_total = 0LL;\n\nint n, q;\n\ninline void add(int i) {\n\ta_total += a[i];\n\tif (i == 0 or i == 2 * n - 1) return;\n\tconst ll val = b[i] - a[i];\n\tif (val >= 0) {\n\t\tpositive.insert(val);\n\t\tp_total += val;\n\t} else {\n\t\tnegative.insert(val);\n\t}\n}\n\ninline void del(int i) {\n\ta_total -= a[i];\n\tif (i == 0 or i == 2 * n - 1) return;\n\tconst ll val = b[i] - a[i];\n\tif (val >= 0) {\n\t\tpositive.erase(val);\n\t\tp_total -= val;\n\t} else {\n\t\tnegative.erase(val);\n\t}\n}\n\nint main(void) {\n\tcin >> n >> q;\n\n\trep(i, 2 * n) cin >> a[i];\n\trep(i, 2 * n) cin >> b[i];\n\n\trep(i, 2 * n) a_total += a[i];\n\n\trep(i, 1, 2 * n - 1) {\n\t\tconst ll val = b[i] - a[i];\n\t\tif (val >= 0) {\n\t\t\tpositive.insert(val);\n\t\t\tp_total += val;\n\t\t} else {\n\t\t\tnegative.insert(val);\n\t\t}\n\t}\n\n\n\trep(loop, q) {\n\t\tint p;\n\t\tll x, y;\n\t\tcin >> p >> x >> y;\n\n\t\tdel(p - 1);\n\t\ta[p - 1] = x, b[p - 1] = y;\n\t\tadd(p - 1);\n\n\t\tll ans = -inf;\n\t\tif (positive.size() % 2 == 0) {\n\t\t\tchmax(ans, a_total + p_total);\n\t\t} else {\n\t\t\tconst ll mmax = *prev(end(negative));\n\t\t\tconst ll pmin = *begin(positive);\n\t\t\tchmax(ans, a_total + p_total + mmax);\n\t\t\tchmax(ans, a_total + p_total - pmin);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,q;\n    cin >> n >> q;\n    ll res = 0, sm = 0;\n    vl a(2*n),b(2*n);\n    multiset<int> x,y;\n    rep(i,2*n){\n        cin >> a[i];\n        res += a[i];\n    }\n    rep(i,2*n){\n        cin >> b[i];\n        b[i] -= a[i];\n        if(i > 0 && i < 2*n-1){\n            if(b[i] > 0){\n                x.insert(b[i]);\n                sm += b[i];\n            }else{\n                y.insert(-b[i]);\n            }\n        }\n    }\n    rep(i,q){\n        int p,q,r;\n        cin >> p >> q >> r;\n        --p;\n        res -= a[p];\n        if(p > 0 && p < 2*n-1){\n            if(b[p] > 0){\n                x.erase(x.find(b[p]));\n                sm -= b[p];\n            }else{\n                y.erase(y.find(-b[p]));\n            }\n        }\n        a[p] = q;\n        res += q;\n        b[p] = r - q;\n        if(p > 0 && p < 2*n-1){\n            if(b[p] > 0){\n                x.insert(b[p]);\n                sm += b[p];\n            }else{\n                y.insert(-b[p]);\n            }\n        }\n        ll ans = 0;\n        if(len(x)%2){\n            ans = res + max(sm-*x.begin(), sm-*y.begin());\n        }else{\n            ans = res+sm;\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define in(x,y,h,w) x >= 0 && x < h && y >= 0 && y < w\nusing namespace std;\n\n#define int long long\n//typedef    long long          ll;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n \nconst int INF=1e+9;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nclass RMQ{\n\tint n,seg,init;\n\tvector<int> dat;\npublic:\n\tRMQ(int siz,int def) : n(siz),init(def),seg(1){\n\t\twhile(seg < n) seg *= 2;\n\t\tdat.resize(seg * 2 - 1);\n\t\tfor(int i = 0;i < seg * 2 - 1;i++) dat[i] = init;\n\t}\n\tvoid update(int i,int x){\n\t\ti += seg - 1;\n\t\tdat[i] = x;\n\t\twhile(i){\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1],dat[i * 2 + 2]); //do\n\t\t}\n\t}\n\tint get(int a = 0,int b = -1,int k = 0,int l = 0,int r = -1){\n\t\tif(b == -1) b = seg;\n\t\tif(r == -1) r = seg;\n\t\tif(b <= l || r <= a) return init;\n\t\tif(a <= l && r <= b) return dat[k];\n\t\treturn min(get(a,b,k * 2 + 1,l,(l + r) / 2),get(a,b,k * 2 + 2,(l + r) / 2,r)); //do\n\t}\n};\n\nsigned main(){\n\tint n,q,a[200000],b[200000],sum = 0,pos = 0,add = 0;\n\tcin >> n >> q;\n\tvector<RMQ> rmq(2,RMQ(n * 2,INF));\n\tfor(int i = 0;i < n * 2;i++){\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\tfor(int i = 0;i < n * 2;i++){\n\t\tcin >> b[i];\n\t\tb[i] -= a[i];\n\t\tif(!i || i == n * 2 - 1) continue;\n\t\tif(b[i] >= 0){\n\t\t\trmq[0].update(i,b[i]);\n\t\t\tpos++;\n\t\t\tadd += b[i];\n\t\t}\n\t\telse rmq[1].update(i,-b[i]);\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tint p,x,y;\n\t\tcin >> p >> x >> y; p--;\n\t\tsum += x - a[p];\n\t\ta[p] = x;\n\t\tif(!(!p || p == n * 2 - 1)){\n\t\t\tint nb = y - x;\n\t\t\tif(nb >= 0){\n\t\t\t\trmq[0].update(p,nb);\n\t\t\t\trmq[1].update(p,INF);\n\t\t\t\tif(b[p] < 0){\n\t\t\t\t\tpos++;\n\t\t\t\t\tadd += nb;\n\t\t\t\t}else add += nb - b[p];\n\t\t\t}else{\n\t\t\t\trmq[0].update(p,INF);\n\t\t\t\trmq[1].update(p,-nb);\n\t\t\t\tif(b[p] >= 0){\n\t\t\t\t\tpos--;\n\t\t\t\t\tadd -= b[p];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(pos % 2 == 0) cout << sum + add << endl;\n\t\telse cout << sum + max(add - rmq[0].get(0,n),add + rmq[0].get(0,n) - rmq[1].get(0,n)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\n\nint main(){\n    int n,q;\n    cin>>n>>q;\n    n*=2;\n    ll a[n],b[n];\n    rep(i,n)cin>>a[i];\n    rep(i,n)cin>>b[i];\n    ll ans=a[0]+a[n-1];\n    int posi=0,ze=0;\n    set<pli> st;\n    rep(i,n-2){\n        ans+=max(a[i+1],b[i+1]);\n        if(a[i+1]<b[i+1])posi++;\n        st.insert({abs(a[i+1]-b[i+1]),i+1});\n    }\n    rep(i,q){\n        ll p,x,y;\n        cin>>p>>x>>y;\n        p--;\n        if(p==0||p==n-1){\n            ans+=(ll)(x-a[p]);\n            a[p]=x;\n            cout<<ans<<endl;\n            continue;\n        }\n        ans+=max(x,y);\n        ans-=max(a[p],b[p]);\n        auto it=st.find({abs(a[p]-b[p]),p});\n        st.erase(it);\n        st.insert({abs(x-y),p});\n        if(a[p]<b[p])posi--;\n        if(x<y)posi++;\n        a[p]=x;\n        b[p]=y;\n        it=st.begin();\n        if(posi%2==0)cout<<ans<<endl;\n        else cout<<ans-(it->first)<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define FOR(i,j,k) for(int (i)=(j);(i)<(int)(k);++(i))\n#define rep(i,j) FOR(i,0,j)\n#define each(x,y) for(auto &(x):(y))\n#define mp make_pair\n#define MT make_tuple\n#define all(x) (x).begin(),(x).end()\n#define debug(x) cout<<#x<<\": \"<<(x)<<endl\n#define smax(x,y) (x)=max((x),(y))\n#define smin(x,y) (x)=min((x),(y))\n#define MEM(x,y) memset((x),(y),sizeof (x))\n#define sz(x) (int)(x).size()\n#define RT return\nusing ll = long long;\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing vll = vector<ll>;\n\n/*\nセグメント木\n\nint _query(int a, int b, int k, int l, int r)\n[a,b)\nl,rは今見ている範囲\n内部で呼ぶだけ\nコンストラクタ\n要素数、初期値, 隣接要素を引数とする関数\nquery(int a, int b)\nクエリ[a,b), 0Origin\nint cal(int a, int b)\n*/\ntemplate<class Value>\nclass SegmentTree {\n    int n;\n    Value e;\n    vector<Value> dat;\n    function<Value(Value, Value)> f;\n\n    inline Value query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return e;\n        if (a <= l && r <= b) return dat[k];\n        else {\n            Value vl, vr;\n            vl = query(a, b, k << 1, l, (l + r) >> 1);\n            vr = query(a, b, (k << 1) | 1, (l + r) >> 1, r);\n            return f(vl, vr);\n        }\n    }\n\npublic:\n    SegmentTree() {}\n\n    SegmentTree(int n_, Value init_, function<Value(Value, Value)> f_)\n        :n(1), e(init_), f(f_) {\n        for (; n<n_; n <<= 1);\n        dat = vector<Value>(n << 1, e);\n    }\n\n    void update(int k, Value a) {\n        k += n;\n        dat[k] = a;\n        while (k>1) {\n            k >>= 1;\n            dat[k] = f(dat[k << 1], dat[(k << 1) | 1]);\n        }\n    }\n\n    Value query(int a, int b) {\n        return query(a, b, 1, 0, n);\n    }\n};\n\nusing P = array<ll, 2>;\nP f(P p, P q) {\n    P r;\n    r[0] = max(p[0] + q[0], p[1] + q[1]);\n    r[1] = max(p[0] + q[1], p[1] + q[0]);\n    return r;\n}\nconst ll MI = LLONG_MIN / 3;\nusing ST = SegmentTree<P>;\n\nvoid solve() {\n    int N, Q;\n    cin >> N >> Q;\n\n    vi A(N), B(N);\n    rep(i, 2 * N) cin >> A[i];\n    rep(i, 2 * N) cin >> B[i];\n\n    P e{ 0, MI};\n    ST st(2 * N, e, f);\n\n    rep(i, 2 * N) {\n        st.update(i, P{ A[i], B[i] });\n    }\n    rep(i, Q) {\n        int p, x, y;\n        cin >> p >> x >> y;\n        p--;\n        A[p] = x;\n        B[p] = y;\n        st.update(p, P{ x, y });\n        ll ans = A[0] + A[2 * N - 1] + st.query(1, 2 * N - 1)[0];\n        cout<<ans<<endl;\n    }\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(15);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <set>\nusing namespace std;\n\nint main() {\n        int n, q;\n        scanf(\"%d%d\", &n, &q);\n        n = 2 * n;\n        vector<int> a(n), b(n);\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &a[i]);\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &b[i]);\n        if (n > 10 || q > 10) return 0;\n        set<string> ok;\n        vector<int> s(n);\n        for (int i = 0; i < n; i ++) s[i] = i;\n        do {\n                string tmp = \"\";\n                for (int i = 0; i < n; i ++) {\n                        if (s[i] & 1) tmp += \")\";\n                        else tmp += \"(\";\n                }\n                stack<char> st;\n                for (int i = 0; i < n; i ++) {\n                        if (!st.empty() && st.top() == '(' && tmp[i] == ')') st.pop();\n                        else st.push(tmp[i]);\n                }\n                if (st.empty()) ok.insert(tmp);\n        } while (next_permutation(s.begin(), s.end()));\n        vector<string> yes;\n        for (auto it : ok) yes.push_back(it);\n        while (q --) {\n                int p, x, y;\n                scanf(\"%d%d%d\", &p, &x, &y);\n                p --;\n                a[p] = x;\n                b[p] = y;\n                long long ans = 0;\n                for (int i = 0; i < yes.size(); i ++) {\n                        for (int j = i; j < yes.size(); j ++) {\n                                string fi = yes[i], se = yes[j];\n                                long long res = 0;\n                                for (int i = 0; i < n; i ++) {\n                                        if (fi[i] == se[i]) res += a[i];\n                                        else res += b[i];\n                                }\n                                ans = max(ans, res);\n                        }\n                }\n                printf(\"%lld\\n\", ans);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN = 100000;\n\nint n, nq;\nint a[2 * MAXN], b[2 * MAXN];\n\nll now;\nbool same[2 * MAXN];\nset<pair<int,int> > same2diff;\nset<pair<int,int> > diff2same;\n\nvoid change(set<pair<int, int> > &s, int idx, int oval, int nval) {\n\ts.erase(MP(oval, idx)); s.insert(MP(nval, idx));\n}\n\nvoid update() {\n\twhile (true) {\n\t\tbool change = false;\n\t\twhile (SZ(same2diff) >= 2) {\n\t\t\tauto a = same2diff.end(); --a; auto b = a; --b;\n\t\t\tif (a->first + b->first <= 0) break;\n\t\t\tnow += a->first + b->first;\n\t\t\tsame[a->second] = same[b->second] = false;\n\t\t\tdiff2same.insert(MP(-a->first, a->second));\n\t\t\tdiff2same.insert(MP(-b->first, b->second));\n\t\t\tsame2diff.erase(a);\n\t\t\tsame2diff.erase(b);\n\t\t\tchange = true;\n\t\t}\n\t\twhile (SZ(diff2same) >= 2) {\n\t\t\tauto a = diff2same.end(); --a; auto b = a; --b;\n\t\t\tif (a->first + b->first <= 0) break;\n\t\t\tnow += a->first + b->first;\n\t\t\tsame[a->second] = same[b->second] = true;\n\t\t\tsame2diff.insert(MP(-a->first, a->second));\n\t\t\tsame2diff.insert(MP(-b->first, b->second));\n\t\t\tdiff2same.erase(a);\n\t\t\tdiff2same.erase(b);\n\t\t\tchange = true;\n\t\t}\n\t\twhile (SZ(same2diff) >= 1 && SZ(diff2same) >= 1) {\n\t\t\tauto a = same2diff.end(); --a; auto b = diff2same.end(); --b;\n\t\t\tif (a->first + b->first <= 0) break;\n\t\t\tnow += a->first + b->first;\n\t\t\tsame[a->second] = false, same[b->second] = true;\n\t\t\tdiff2same.insert(MP(-a->first, a->second));\n\t\t\tsame2diff.insert(MP(-b->first, b->second));\n\t\t\tsame2diff.erase(a);\n\t\t\tdiff2same.erase(b);\n\t\t\tchange = true;\n\t\t}\n\t\tif (!change) break;\n\t}\n}\n\nvoid run() {\n\tscanf(\"%d%d\", &n, &nq); REP(i, 2 * n) scanf(\"%d\", &a[i]); REP(i, 2 * n) scanf(\"%d\", &b[i]);\n\tnow = 0; same2diff.clear(); diff2same.clear();\n\tREP(i, 2 * n) {\n\t\tnow += a[i]; same[i] = true;\n\t\tif (i != 0 && i != 2 * n - 1) same2diff.insert(MP(b[i] - a[i], i));\n\t}\n\tREP(qi, nq) {\n\t\tint idx, aval, bval; scanf(\"%d%d%d\", &idx, &aval, &bval); --idx;\n\t\tif (same[idx]) now += aval - a[idx];\n\t\telse now += bval - b[idx];\n\t\tif (idx != 0 && idx != 2 * n - 1) {\n\t\t\tif (same[idx]) change(same2diff, idx, b[idx] - a[idx], bval - aval);\n\t\t\telse change(diff2same, idx, a[idx] - b[idx], aval - bval);\n\t\t}\n\t\ta[idx] = aval, b[idx] = bval;\n\t\tupdate();\n\t\tprintf(\"%lld\\n\", now);\n\t}\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define SZ 131072\nusing namespace std;\nstruct Tree {\n\tlong long S, Mn, Mx;\n\tint C;\n}IT[SZ+SZ];\nvoid Ins(int a, int b) {\n\ta += SZ;\n\tIT[a].S = max(0, b);\n\tIT[a].Mn = -1e18, IT[a].Mx = 1e18;\n\tif (b >= 0) {\n\t\tIT[a].C = 1;\n\t\tIT[a].Mx = b;\n\t}\n\telse {\n\t\tIT[a].C = 0;\n\t\tIT[a].Mn = b;\n\t}\n\twhile (a != 1) {\n\t\ta >>= 1;\n\t\tIT[a].Mx = min(IT[a * 2].Mx, IT[a * 2 + 1].Mx);\n\t\tIT[a].Mn = max(IT[a * 2].Mn, IT[a * 2 + 1].Mn);\n\t\tIT[a].S = IT[a * 2].S + IT[a * 2 + 1].S;\n\t\tIT[a].C = IT[a * 2].C + IT[a * 2 + 1].C;\n\t}\n}\nlong long SA;\nint n, A[101000], B[101000];\nint main() {\n\tint i, Q, t, a, b;\n\tscanf(\"%d%d\", &n,&Q);\n\tn *= 2;\n\tfor (i = 1; i < SZ+SZ; i++) {\n\t\tIT[i].Mn = -1e18, IT[i].Mx = 1e18;\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tSA += A[i];\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &B[i]);\n\t\tif(i!=1 && i!=n) Ins(i, B[i] - A[i]);\n\t}\n\twhile (Q--) {\n\t\tscanf(\"%d%d%d\", &t, &a, &b);\n\t\tSA = SA - A[t] + a;\n\t\tA[t] = a, B[t] = b;\n\t\tif(t!=1 && t!=n)Ins(t, B[t] - A[t]);\n\t\tlong long r = 0;\n\t\tif (IT[1].C % 2 == 0) r = SA + IT[1].S;\n\t\telse {\n\t\t\tif (IT[1].C) {\n\t\t\t\tr = max(r, SA + IT[1].S - IT[1].Mx);\n\t\t\t}\n\t\t\tif (IT[1].C != n) {\n\t\t\t\tr = max(r, SA + IT[1].S + IT[1].Mn);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", r);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define long long long\n\nconst int N = 10;\nconst long INF = 1e18;\n\nint n, q;\nlong a[N], b[N];\n\nvoid Solve()\n{\n    while (q--)\n    {\n        int p; long x, y;\n        cin >> p >> x >> y;\n        a[p] = x, b[p] = y;\n\n        long ans = -INF;\n        for (int mask = 0; mask < 1 << (n - 2); ++mask)\n            if (!(__builtin_popcount(mask) & 1))\n            {\n                long sum = 0;\n                for (int i = 0; i < n - 2; ++i)\n                    if ((mask >> i) & 1) sum += b[i + 2];\n                    else sum += a[i + 2];\n                ans = max(ans, sum);\n            }\n        cout << ans + a[1] + a[n] << '\\n';\n    }\n}\n\nint main()\n{\n    cin >> n >> q;\n    n *= 2;\n    for (int i = 1; i <= n; ++i) cin >> a[i];\n    for (int i = 1; i <= n; ++i) cin >> b[i];\n    Solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\n\nint main(){\n    int n,q;\n    cin>>n>>q;\n    n*=2;\n    ll a[n],b[n];\n    rep(i,n)cin>>a[i];\n    rep(i,n)cin>>b[i];\n    ll ans=a[0]+a[n-1];\n    int posi=0,zero=0;\n    multiset<ll> st;\n    rep(i,n-2){\n        ans+=max(a[i+1],b[i+1]);\n        if(a[i+1]>b[i+1])posi++;\n        if(a[i+1]==b[i+1])zero++;\n        st.insert(abs(a[i+1]-b[i+1]));\n    }\n    rep(i,q){\n        ll p,x,y;\n        cin>>p>>x>>y;\n        p--;\n        if(p==0||p==n-1){\n            ans+=x-a[p];\n            a[p]=x;\n            cout<<ans<<endl;\n            continue;\n        }\n        ans+=max(x,y)-max(a[p],b[p]);\n        auto it=st.lower_bound(abs(a[p]-b[p]));\n        st.erase(it);\n        st.insert(abs(x-y));\n        if(a[p]-b[p]>0)posi--;\n        if(a[p]-b[p]==0)zero--;\n        if(x-y>0)posi++;\n        if(x-y==0)zero++;\n        a[p]=x;b[p]=y;\n        if(zero>0||posi%2==0)cout<<ans<<endl;\n        else cout<<ans-*st.begin()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  LL N, Q;\n  cin >> N >> Q;\n\n  VL as(N*2), bs(N*2);\n  cin >> as >> bs;\n\n  if(N == 1){\n    while(Q--){\n    int p, x, y;\n    cin >> p >> x >> y;\n    --p;\n    as[p] = x;\n    bs[p] = y;\n    cout<<as[0]+as[1]<<endl;      \n    }\n    return 0;\n  }\n\n  int par = 0;\n  LL sum = as[0] + as.back();\n  multiset<LL> dels;\n  FOR(i,1,2*N-1){\n    LL mx = max(as[i], bs[i]);\n    LL mn = min(as[i], bs[i]);\n    sum += mx;\n    if(mx == as[i]) par ^= 1;\n    dels.insert(mn - mx);\n  }\n\n  while(Q--){\n    LL p, x, y;\n    cin >> p >> x >> y;\n    --p;\n\n    LL mx = max(as[p], bs[p]);\n    LL mn = min(as[p], bs[p]);\n    sum -= mx;\n    if(mx == as[p]) par ^= 1;\n    auto it = dels.find(mn - mx);\n    dels.erase(it);\n\n    as[p] = x;\n    bs[p] = y;\n    LL mx2 = max(as[p], bs[p]);\n    LL mn2 = min(as[p], bs[p]);\n    sum += mx2;\n    if(mx2 == as[p]) par ^= 1;\n    dels.insert(mn2 - mx2);\n\n    LL ans = 0;\n    if(par == 0){\n      ans = sum;\n    }\n    else{\n      auto it = dels.rbegin();\n      assert(it != dels.rend());\n      ans = sum + *it;\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define index(xs, x) (int)(lower_bound(all(xs), x) - xs.begin())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF (1LL<<60)\n#define MOD 1000000007\n#define MAX_N (1<<18)\ntypedef pair<long long, long long> Node;\nNode seg[MAX_N*2-1];\nNode op(Node a, Node b) {\n  return Node(max(a._1+b._1, a._2+b._2), max(a._1+b._2, a._2+b._1));\n}\nvoid update(int k, int v) {\n  k += MAX_N-1;\n  seg[k] = Node(0, v);\n  while (k > 0) {\n    k = (k-1)/2;\n    seg[k] = op(seg[k*2+1], seg[k*2+2]);\n  }\n}\nNode query(int a, int b, int k=0, int l=0, int r=MAX_N) {\n  if (b <= l || r <= a) return Node(0, -INF);\n  if (a <= l && b <= r) return seg[k];\n  return op(query(a, b, k*2+1, l, (l+r)/2), query(a, b, k*2+2, (l+r)/2, r));\n}\n\nint N, Q;\nint A[200000], B[200000];\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  rep(i, MAX_N*2-1) seg[i] = Node(0, -INF);\n\n  cin >> N >> Q;\n  N *= 2;\n  rep(i, N) cin >> A[i];\n  rep(i, N) cin >> B[i];\n  long long base = 0;\n  rep(i, N) {\n    if (i > 0 && i < N-1) update(i-1, B[i]-A[i]);\n    base += A[i];\n  }\n  rep(i, Q) {\n    int p, a, b;\n    cin >> p >> a >> b;\n    p--;\n    base -= A[p];\n    A[p] = a, B[p] = b;\n    base += A[p];\n    if (p > 0 && p < N-1) update(p-1, B[p]-A[p]);\n    cout << base+query(0, MAX_N)._1 << \"\\n\";\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tif(a<0LL)return 0;\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\n// ここから編集しろ\nlong long A[210000];\nlong long B[210000];\nint main(){\n\tint a,b;scanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<2*a;i++)scanf(\"%lld\",A+i);\n\tfor(int i=0;i<a*2;i++)scanf(\"%lld\",B+i);\n\tset<pair<long long,int> > S;\n\tfor(int i=1;i<a*2-1;i++)S.insert(make_pair(A[i]-B[i],i));\n\tint neg=0;\n\tlong long ret=0;\n\tfor(set<pair<long long,int> >::iterator it=S.begin();it!=S.end();it++){\n\t\tif(it->first<0)neg++;\n\t\tret+=max(A[it->second],B[it->second]);\n\t}\n\n\tfor(int i=0;i<b;i++){\n\t\tint p;\n\t\tlong long q,r;scanf(\"%d%lld%lld\",&p,&q,&r);p--;\n\t\tif(p==0||p==a*2-1){\n\t\t\tA[p]=q;\n\t\t\tB[p]=r;\n\t\t}else{\n\t\t\tlong long tmp=q-r;\n\t\t\tif(A[p]-B[p]<0)neg--;\n\t\t\tif(tmp<0)neg++;\n\n\t\t\tS.erase(make_pair(A[p]-B[p],p));\n\t\t\tS.insert(make_pair(tmp,p));\n\t\t\tret-=max(A[p],B[p]);\n\t\t\tret+=max(q,r);\n\t\t\tA[p]=q;\n\t\t\tB[p]=r;\n\t\t}\n\t\tlong long ans=ret;\n\t\tif(neg%2){\n\t\t\tset<pair<long long,int> >::iterator it=S.lower_bound(make_pair(0,0));\n\t\t\tlong long to=inf;\n\t\t\tif(it!=S.end())to=min(to,it->first);\n\t\t\tif(it!=S.begin()){\n\t\t\t\tit--;\n\t\t\t\tto=min(to,-(it->first));\n\t\t\t}\n\t\t\tans-=to;\n\t\t}\n\t\tprintf(\"%lld\\n\",ans+A[0]+A[a*2-1]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sp ' '\n#define mkp make_pair\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define lP pair<ll,ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\nconst int mod = 1000000007, mod998 = 998244353;\nconst string nyan(\"(=^・ω・^=)\");\n\nint N, Q, a[200000], b[200000], p, x, y;\nbool u[200000];\nset<pair<int, int>>st[2];\nll res;\n\nint main() {\n\tcin >> N >> Q;\n\t--Q;\n\tN *= 2;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> b[i];\n\t}\n\tcin >> p >> x >> y;\n\t--p;\n\ta[p] = x;\n\tb[p] = y;\n\tres = a[0] + a[N - 1];\n\tfor (int i = 1; i < N - 1; ++i) {\n\t\tif (a[i] >= b[i]) {\n\t\t\tu[i] = true;\n\t\t\tres += a[i];\n\t\t\tst[1].insert(mkp(a[i] - b[i], i));\n\t\t}\n\t\telse {\n\t\t\tres += b[i];\n\t\t\tst[0].insert(mkp(b[i] - a[i], i));\n\t\t}\n\t}\n\tif (st[0].size() & 1) {\n\t\tpair<int, int>p1, p2;\n\t\tp1 = *st[0].begin();\n\t\tp2 = *st[1].begin();\n\t\tif (p1.first > p2.first) {\n\t\t\tres -= p2.first;\n\t\t\tu[p2.second] ^= true;\n\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\tst[1].erase(p2);\n\t\t}\n\t\telse {\n\t\t\tres -= p1.first;\n\t\t\tu[p1.second] ^= true;\n\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\tst[0].erase(p1);\n\t\t}\n\t}\n\tcout << res << endl;\n\twhile (Q--) {\n\t\tcin >> p >> x >> y;\n\t\t--p;\n\t\tif (p == 0 || p == N - 1) {\n\t\t\tres += x - a[p];\n\t\t\ta[p] = x;\n\t\t}\n\t\telse {\n\t\t\tif (u[p]) {\n\t\t\t\tres += x - a[p];\n\t\t\t\tst[1].erase(mkp(a[p] - b[p], p));\n\t\t\t\tst[1].insert(mkp(x - y, p));\n\t\t\t\tauto it = st[1].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first <= 0 && p2.first <= 0 || (!st[0].empty() && p1.first + p2.first <= 0 && p2.first <= st[0].begin()->first)) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[0].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[1].erase(p1);\n\t\t\t\t\tst[1].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres += y - b[p];\n\t\t\t\tst[0].erase(mkp(b[p] - a[p], p));\n\t\t\t\tst[0].insert(mkp(y - x, p));\n\t\t\t\tauto it = st[0].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first <= 0 && p2.first <= 0 || (!st[1].empty() && p1.first + p2.first <= 0 && p2.first < st[1].begin()->first)) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[1].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[0].erase(p1);\n\t\t\t\t\tst[0].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!st[0].empty() && !st[1].empty() && st[0].begin()->first + st[1].begin()->first <= 0) {\n\t\t\t\tpair<int, int> p1 = *st[0].begin();\n\t\t\t\tpair<int, int> p2 = *st[1].begin();\n\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\tu[p1.second] ^= true;\n\t\t\t\tu[p2.second] ^= true;\n\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\tst[0].erase(p1);\n\t\t\t\tst[1].erase(p2);\n\t\t\t}\n\t\t\ta[p] = x;\n\t\t\tb[p] = y;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define SZ 262144\nusing namespace std;\nstruct Tree {\n\tlong long S, Mn, Mx;\n\tint C;\n}IT[SZ+SZ];\nvoid Ins(int a, int b) {\n\ta += SZ;\n\tIT[a].S = max(0, b);\n\tIT[a].Mn = -1e18, IT[a].Mx = 1e18;\n\tif (b >= 0) {\n\t\tIT[a].C = 1;\n\t\tIT[a].Mx = b;\n\t}\n\telse {\n\t\tIT[a].C = 0;\n\t\tIT[a].Mn = b;\n\t}\n\twhile (a != 1) {\n\t\ta >>= 1;\n\t\tIT[a].Mx = min(IT[a * 2].Mx, IT[a * 2 + 1].Mx);\n\t\tIT[a].Mn = max(IT[a * 2].Mn, IT[a * 2 + 1].Mn);\n\t\tIT[a].S = IT[a * 2].S + IT[a * 2 + 1].S;\n\t\tIT[a].C = IT[a * 2].C + IT[a * 2 + 1].C;\n\t}\n}\nlong long SA;\nint n, A[201000], B[201000];\nint main() {\n\tint i, Q, t, a, b;\n\tscanf(\"%d%d\", &n,&Q);\n\tn *= 2;\n\tfor (i = 1; i < SZ+SZ; i++) {\n\t\tIT[i].Mn = -1e18, IT[i].Mx = 1e18;\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tSA += A[i];\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &B[i]);\n\t\tif(i!=1 && i!=n) Ins(i, B[i] - A[i]);\n\t}\n\twhile (Q--) {\n\t\tscanf(\"%d%d%d\", &t, &a, &b);\n\t\tSA = SA - A[t] + a;\n\t\tA[t] = a, B[t] = b;\n\t\tif(t!=1 && t!=n)Ins(t, B[t] - A[t]);\n\t\tlong long r = 0;\n\t\tif (IT[1].C % 2 == 0) r = SA + IT[1].S;\n\t\telse {\n\t\t\tr = max(SA + IT[1].S - IT[1].Mx, SA + IT[1].S + IT[1].Mn);\n\t\t}\n\t\tprintf(\"%lld\\n\", r);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint a[200000], b[200000];\n//dp[0][i]=(1番目からi番目まででbを偶数個選んだ時の値の総和の最大値)\n//dp[1][i]=(1番目からi番目まででbを奇数個選んだ時の値の総和の最大値)\nlong long dp[2][200000];\n\nlong long max(long long a, long long b){\n\treturn a < b ? b : a;\n}\n\n//O(nq)\nint main() {\n\tint n, q, i, j, p, x, y;\n\tscanf(\"%d%d\", &n, &q);\n\tfor (i = 0; i < 2 * n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tdp[0][1] += a[i];\n\t}\n\tfor (i = 0; i < 2 * n; i++) {\n\t\tscanf(\"%d\", &b[i]);\n\t}\n\tfor (i = 0; i < q; i++) {\n\t\tscanf(\"%d%d%d\", &p,&x,&y);\n\t\tdp[0][1] += x - a[p - 1];\n\t\ta[p - 1] = x;\n\t\tb[p - 1] = y;\n\t\tdp[1][1] = dp[0][1] + b[1] - a[1];\n\t\tfor (j = 2; j <= 2 * n - 2; j++) {\n\t\t\tdp[0][j] = max(dp[0][j - 1], dp[1][j - 1] + b[j] - a[j]);\n\t\t\tdp[1][j] = max(dp[1][j - 1], dp[0][j - 1] + b[j] - a[j]);\n\t\t}\n\t\tprintf(\"%lld\\n\", dp[0][2 * n - 2]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\n\nint main(){\n    int n,q;\n    cin>>n>>q;\n    n*=2;\n    ll a[n],b[n];\n    rep(i,n)cin>>a[i];\n    rep(i,n)cin>>b[i];\n    ll ans=a[0]+a[n-1];\n    int posi=0,ze=0;\n    set<pli> st;\n    rep(i,n-2){\n        ans+=max(a[i+1],b[i+1]);\n        if(a[i+1]>b[i+1])posi++;\n        st.insert({abs(a[i+1]-b[i+1]),i});\n    }\n    rep(i,q){\n        ll p,x,y;\n        cin>>p>>x>>y;\n        p--;\n        if(p==0||p==n-1){\n            ans+=(ll)(x-a[p]);\n            a[p]=x;\n            cout<<ans<<endl;\n            continue;\n        }\n        ans+=max(x,y);\n        ans-=max(a[p],b[p]);\n        auto it=st.find({abs(a[p]-b[p]),p});\n        st.erase(it);\n        st.insert({abs(x-y),p});\n        if(a[p]>b[p])posi--;\n        if(x>y)posi++;\n        a[p]=x;\n        b[p]=y;\n        it=st.begin();\n        if(posi%2==0)cout<<ans<<endl;\n        else cout<<ans-it->first<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sp ' '\n#define mkp make_pair\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define lP pair<ll,ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\nconst int mod = 1000000007, mod998 = 998244353;\nconst string nyan(\"(=^・ω・^=)\");\n\nint N, Q, a[200000], b[200000], p, x, y;\nbool u[200000];\nset<pair<int, int>>st[2];\nll res;\n\nint main() {\n\tcin >> N >> Q;\n\t--Q;\n\tN *= 2;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> b[i];\n\t}\n\tcin >> p >> x >> y;\n\t--p;\n\ta[p] = x;\n\tb[p] = y;\n\tres = a[0] + a[N - 1];\n\tfor (int i = 1; i < N - 1; ++i) {\n\t\tif (a[i] >= b[i]) {\n\t\t\tu[i] = true;\n\t\t\tres += a[i];\n\t\t\tst[1].insert(mkp(a[i] - b[i], i));\n\t\t}\n\t\telse {\n\t\t\tres += b[i];\n\t\t\tst[0].insert(mkp(b[i] - a[i], i));\n\t\t}\n\t}\n\tif (st[0].size() & 1) {\n\t\tpair<int, int>p1, p2;\n\t\tp1 = *st[0].begin();\n\t\tp2 = *st[1].begin();\n\t\tif (p1.first > p2.first) {\n\t\t\tres -= p2.first;\n\t\t\tu[p2.second] ^= true;\n\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\tst[1].erase(p2);\n\t\t}\n\t\telse {\n\t\t\tres -= p1.first;\n\t\t\tu[p1.second] ^= true;\n\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\tst[0].erase(p1);\n\t\t}\n\t}\n\tcout << res << endl;\n\twhile (Q--) {\n\t\tcin >> p >> x >> y;\n\t\t--p;\n\t\tif (p == 0 || p == N - 1) {\n\t\t\tres += x - a[p];\n\t\t\ta[p] = x;\n\t\t}\n\t\telse {\n\t\t\tif (u[p]) {\n\t\t\t\tres += x - a[p];\n\t\t\t\tst[1].erase(mkp(a[p] - b[p], p));\n\t\t\t\tst[1].insert(mkp(x - y, p));\n\t\t\t\tauto it = st[1].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0 || (!st[0].empty() && p1.first + p2.first < 0 && p2.first < st[0].begin()->first)) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[0].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[1].erase(p1);\n\t\t\t\t\tst[1].erase(p2);\n\t\t\t\t}\n\t\t\t\tif (!st[0].empty()) {\n\t\t\t\t\tauto it = st[0].begin();\n\t\t\t\t\tauto it2 = it;\n\t\t\t\t\t++it2;\n\t\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\t\tif (p1.first < 0 && p2.first < 0 || (!st[1].empty() && p1.first + p2.first < 0 && p2.first < st[1].begin()->first)) {\n\t\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\t\tst[1].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\t\tst[0].erase(p1);\n\t\t\t\t\t\tst[0].erase(p2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres += y - b[p];\n\t\t\t\tst[0].erase(mkp(b[p] - a[p], p));\n\t\t\t\tst[0].insert(mkp(y - x, p));\n\t\t\t\tauto it = st[0].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0 || (!st[1].empty() && p1.first + p2.first < 0 && p2.first < st[1].begin()->first)) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[1].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[0].erase(p1);\n\t\t\t\t\tst[0].erase(p2);\n\t\t\t\t}\n\t\t\t\tif (!st[1].empty()) {\n\t\t\t\t\tauto it = st[1].begin();\n\t\t\t\t\tauto it2 = it;\n\t\t\t\t\t++it2;\n\t\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\t\tif (p1.first < 0 && p2.first < 0 || (!st[0].empty() && p1.first + p2.first < 0 && p2.first < st[0].begin()->first)) {\n\t\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\t\tst[0].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\t\tst[1].erase(p1);\n\t\t\t\t\t\tst[1].erase(p2);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!st[0].empty() && !st[1].empty() && st[0].begin()->first + st[1].begin()->first < 0) {\n\t\t\t\tpair<int, int> p1 = *st[0].begin();\n\t\t\t\tpair<int, int> p2 = *st[1].begin();\n\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\tu[p1.second] ^= true;\n\t\t\t\tu[p2.second] ^= true;\n\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\tst[0].erase(p1);\n\t\t\t\tst[1].erase(p2);\n\t\t\t}\n\t\t\ta[p] = x;\n\t\t\tb[p] = y;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for (int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\ntypedef long long LL;\n\nint N,Q;\nLL a[200001];\nLL b[200001];\nbool update[200001];\n\ntypedef pair<LL,int>P;\npriority_queue<LL>que;\npriority_queue<LL,vector<LL>,greater<LL> >que2;\nmap<LL,int>m;\nmap<LL,int>m2;\n\nint main(){\n    cin>>N>>Q;\n    REP(i,2*N){\n        cin>>a[i];\n    }\n    REP(i,2*N){\n        cin>>b[i];\n    }\n    REP(i,2*N){\n        if((i==0)||(i==(2*N-1)))continue;\n        //update[i]=false;\n        que.push(b[i]-a[i]);\n        m[(b[i]-a[i])]++;\n    }\n    LL ans=0;\n    REP(i,2*N){\n        ans+=a[i];\n    }\n    REP(i,N-1){\n        LL t1=que.top();que.pop();\n        LL t2=que.top();que.pop();\n        if(t1+t2>=0){\n           que2.push(t1);\n           que2.push(t2);\n           m2[t1]++;\n           m2[t2]++;\n           m[t1]--;\n           m[t2]--;\n           ans+=(t1+t2);\n        }else{\n           que.push(t1);\n           que.push(t2);\n        }\n    }\n    //cout<<ans<<endl;\n    \n    REP(i,Q){\n        int p;\n        LL x,y;\n        cin>>p>>x>>y;\n        p--;\n        if((p==0)||(p==2*N-1)){\n            ans-=a[p];\n            ans+=x;\n            a[p]=x;\n            cout<<ans<<endl;\n            continue;\n        }\n        \n        LL t=b[p]-a[p];\n      //  cout<<\"p\"<<p<<\" \"<<t<<\" \"<<m[t]<<\" \"<<m2[t]<<endl;\n        if((m[t]==0)||((t<=0)&&(m2[t]>=1))){\n     //      cout<<\"aaa\"<<endl;\n           m2[t]--;\n           ans-=t;\n           LL u=que2.top();que2.pop();\n           while(m2[u]==0){\n              u=que2.top();que2.pop();\n           }\n           m2[u]--;\n           que.push(u);\n           ans-=u;\n           m[u]++;\n        }else{\n       //    cout<<\"bbbb\"<<endl;\n           m[t]--;\n           if(!que2.empty()){\n               LL t1=que2.top();que2.pop();\n               bool c=false;\n               while(m2[t1]==0){\n                  if(que2.empty()){\n                     c=true;\n                     break;\n                  }\n                  t1=que2.top();que2.pop();\n               }\n               m2[t1]--;\n               LL t2=que2.top();que2.pop();\n               while(m2[t2]==0){\n                  if(que2.empty()){\n                     c=true;\n                     break;\n                  }\n                  t2=que2.top();que2.pop();\n               }\n               m2[t2]--;\n               if(c==false){\n                  ans-=t1;\n                  ans-=t2;\n                  que.push(t1);\n                  que.push(t2);\n                  m[t1]++;\n                  m[t2]++;\n               }\n           }\n           \n        }\n        ans-=a[p];\n        ans+=x;\n        a[p]=x;\n        b[p]=y;\n        que.push(y-x);\n        m[y-x]++;\n        //cout<<que.size()<<endl;\n        REP(i,2){\n          //  cout<<\"me\"<<endl;\n            if(que.empty())break;\n            LL t1=que.top();que.pop();\n            bool c=false;\n            while(m[t1]==0){\n               if(que.empty()){\n                  c=true;\n                  break;\n               }\n               t1=que.top();que.pop();\n            }\n            m[t1]--;\n            LL t2=que.top();que.pop();\n            while(m[t2]==0){\n               if(que.empty()){\n                  c=true;\n                  break;\n               }\n               t2=que.top();que.pop();\n            }\n            m[t2]--;\n            if(c)break;\n            \n            if(t1+t2>=0){\n              que2.push(t1);\n              que2.push(t2);\n              m2[t1]++;\n              m2[t2]++;\n              ans+=(t1+t2);\n           }else{\n              que.push(t1);\n              que.push(t2);\n              m[t1]++;\n              m[t2]++;\n           }\n        }\n        cout<<ans<<endl;\n    }\n\n    \n    return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INT long long\n#define MOD (INT)(1e9+7)\nusing namespace std;\nINT x, n, q, a[200020], b[200020], ans, p, y, t1, t2;\nINT f(int k, int w, int e)\n{\n    if( w < 0 or e < 0 ) return -MOD;\n    if( k == 2*n ) return ((w==0 and e==0) ? 0 : -MOD);\n    INT ret = 0;\n    ret = f(k+1, w+1, e+1) + a[k];\n    ret = max( ret, f(k+1, w+1, e-1) + b[k]);\n    ret = max( ret, f(k+1, w-1, e+1) + b[k]);\n    ret = max( ret, f(k+1, w-1, e-1) + a[k]);\n    return ret;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin>>n>>q;\n    for(int i = 0 ; i < 2*n ; i++ ) cin>>a[i];\n    for(int i = 0 ; i < 2*n ; i++ ) cin>>b[i];\n    while( q-- )\n    {\n        cin>>p>>x>>y; p--;\n        a[p] = x, b[p] = y;\n        cout<<f(0, 0, 0)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint N, Q;\nll A[200010], B[200010];\nll ans;\nint cnt;\nmultiset<ll> ms;\n\nint main()\n{\n    cin >> N >> Q;\n    for(int i = 0; i < N * 2; i++)cin >> A[i];\n    for(int i = 0; i < N * 2; i++)cin >> B[i];\n\n    for(int i = 1; i < N * 2 - 1; i++)\n    {\n        if(A[i] > B[i])\n        {\n            ans += A[i];\n            cnt++;\n        }\n        else\n        {\n            ans += B[i];\n        }\n        ms.insert(abs(A[i] - B[i]));\n    }\n\n    for(int i = 0; i < Q; i++)\n    {\n        int id;\n        ll a, b;\n        cin >> id >> a >> b;\n        if(id == 1 || id == 2 * N)\n        {\n            A[id - 1] = a;\n            B[id - 1] = b;\n        }\n        else\n        {\n            cnt -= (A[id - 1] > B[id - 1]);\n            cnt += (a > b);\n            ans += -max(A[id - 1], B[id - 1]) + max(a, b);\n            ms.erase(ms.lower_bound(abs(A[id - 1] - B[id - 1])));\n            ms.insert(abs(a - b));\n            A[id - 1] = a;\n            B[id - 1] = b;\n        }\n        if(cnt % 2 == 0)cout << ans + A[0] + A[N * 2 - 1] << endl;\n        else cout << ans - (*ms.begin()) + A[0] + A[2 * N - 1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 26.11.2019 11:07:03       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, tt;\n  cin >> n >> tt;\n  n *= 2;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<int> b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> b[i];\n  }\n  multiset<pair<int, int>> pos;\n  multiset<pair<int, int>> neg;\n  long long sum_pos = 0;\n  long long sum_neg = 0;\n  for (int i = 1; i < n - 1; i++) {\n    if (a[i] > b[i]) {\n      pos.emplace(a[i] - b[i], a[i]);\n      sum_pos += a[i];\n    } else {\n      neg.emplace(b[i] - a[i], b[i]);\n      sum_neg += b[i];\n    }\n  }\n  while (tt--) {\n    int i;\n    cin >> i;\n    --i;\n    if (a[i] > b[i]) {\n      pos.erase(pos.find({a[i] - b[i], a[i]}));\n      sum_pos -= a[i];\n    } else {\n      neg.erase(neg.find({b[i] - a[i], b[i]}));\n      sum_neg -= b[i];\n    }\n    cin >> a[i] >> b[i];\n    if (a[i] > b[i]) {\n      pos.emplace(a[i] - b[i], a[i]);\n      sum_pos += a[i];\n    } else {\n      neg.emplace(b[i] - a[i], b[i]);\n      sum_neg += b[i];\n    }\n    long long ans = a[0] + a[n - 1] + sum_pos + sum_neg;\n    if (pos.size() % 2 == 1) {\n      ans -= min(pos.begin()->first, neg.begin()->first);\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\n\nvector<int> v[1010];\nint a[1010];\npint dfs(int x){\n    if(v[x].empty())return {0,a[x]};\n    bitset<5050> b=1;\n    int sum=0;\n    for(auto to:v[x]){\n        pint p=dfs(to);\n        if(p.first==-1)return {-1,-1};\n        b=(b<<p.first|b<<p.second);\n        sum+=p.first+p.second;\n    }\n    for(int i=a[x];i>=0;i--){\n        if(b[i])return {a[x],sum-i};\n    }\n    return {-1,-1};\n}\n\nint main(){\n    int n,q;\n    cin>>n>>q;\n    n*=2;\n    ll a[n],b[n];\n    rep(i,n)cin>>a[i];\n    rep(i,n)cin>>b[i];\n    ll ans=a[0]+a[n-1];\n    int posi=0;\n    multiset<ll> st;\n    rep(i,n-2){\n        ans+=max(a[i+1],b[i+1]);\n        if(a[i+1]>b[i+1])posi++;\n        st.insert(abs(a[i+1]-b[i+1]));\n    }\n    rep(i,q){\n        int p,x,y;\n        cin>>p>>x>>y;\n        if(p==1||p==n){\n            cout<<ans<<endl;\n            continue;\n        }\n        p--;\n        ans+=max(x,y)-max(a[p],b[p]);\n        auto it=st.lower_bound(abs(a[p]-b[p]));\n        st.erase(it);\n        st.insert(abs(x-y));\n        if(a[p]-b[p]>0||x-y>0)posi++;\n        a[p]=x;b[p]=y;\n        if(posi%2)cout<<ans-*st.begin()<<endl;\n        else cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#define SZ 262144\nusing namespace std;\nstruct Tree {\n\tlong long S, Mn, Mx;\n\tint C;\n}IT[SZ+SZ];\nvoid Ins(int a, int b) {\n\ta += SZ;\n\tIT[a].S = max(0, b);\n\tIT[a].Mn = -1e18, IT[a].Mx = 1e18;\n\tif (b >= 0) {\n\t\tIT[a].C = 1;\n\t\tIT[a].Mx = b;\n\t}\n\telse {\n\t\tIT[a].C = 0;\n\t\tIT[a].Mn = b;\n\t}\n\twhile (a != 1) {\n\t\ta >>= 1;\n\t\tIT[a].Mx = min(IT[a * 2].Mx, IT[a * 2 + 1].Mx);\n\t\tIT[a].Mn = max(IT[a * 2].Mn, IT[a * 2 + 1].Mn);\n\t\tIT[a].S = IT[a * 2].S + IT[a * 2 + 1].S;\n\t\tIT[a].C = IT[a * 2].C + IT[a * 2 + 1].C;\n\t}\n}\nlong long SA;\nint n, A[201000], B[201000];\nint main() {\n\tint i, Q, t, a, b;\n\tscanf(\"%d%d\", &n,&Q);\n\tn *= 2;\n\tfor (i = 1; i < SZ+SZ; i++) {\n\t\tIT[i].Mn = -1e18, IT[i].Mx = 1e18;\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &A[i]);\n\t\tSA += A[i];\n\t}\n\tfor (i = 1; i <= n; i++) {\n\t\tscanf(\"%d\", &B[i]);\n\t\tif(i!=1 && i!=n) Ins(i, B[i] - A[i]);\n\t}\n\twhile (Q--) {\n\t\tscanf(\"%d%d%d\", &t, &a, &b);\n\t\tSA = SA - A[t] + a;\n\t\tA[t] = a, B[t] = b;\n\t\tif(t!=1 && t!=n)Ins(t, B[t] - A[t]);\n\t\tlong long r = 0;\n\t\tif (IT[1].C % 2 == 0) r = SA + IT[1].S;\n\t\telse {\n\t\t\tif (IT[1].C) {\n\t\t\t\tr = max(r, SA + IT[1].S - IT[1].Mx);\n\t\t\t}\n\t\t\tif (IT[1].C != n) {\n\t\t\t\tr = max(r, SA + IT[1].S + IT[1].Mn);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", r);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<unordered_map>\nusing namespace std;\nint p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(long long i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\n#define end_pr(s) cout << s <<endl;return 0\n#define itn int\n#define bs bitset<5001>\nint kai_size = 1000001;\nvel kai(kai_size, 1);\nvel ink(kai_size, 1);\nvel dist;\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4); \n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a, p - 2);\n}\nvoid make_kai() {\n\trep(i, kai_size-1) { kai[i + 1] = (kai[i] * (i + 1)) % p; }\n\trep(i, kai_size) { ink[i] = inv(kai[i]); }\n}\nint com(int n, int r) {\n\tif (r < 0 || n < r) { return 0; }\n\tint ans = kai[n] * ink[r];\n\tans %= p; ans *= ink[n - r]; ans %= p;\n\treturn ans;\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\n\nint per(int a, int b) {\n\tint ans = a % b;\n\tif (ans < 0) { ans += b; }\n\treturn ans;\n}\nvel uni(vel v) {\n\tsor(v);\n\tvel ans(1, v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tif (v[i] != v[i-1]) { ans.push_back(v[i]); }\n\t}\n\treturn ans;\n}\nint s_gcd(int a, int b) {\n\tif (b == 0) { return a; }\n\treturn s_gcd(b, a%b);\n}\nint gcd(int a, int b) {\n\tif (a < b) { swap(a, b); }\n\treturn s_gcd(a, b);\n}\nbool is_prime(int i) {\n\tfor (int j = 2; j*j <= i; j++) {\n\t\tif (i%j == 0) { return false; }\n\t}\n\treturn true;\n}\nint get(int i, int j, vvel &ans) {\n\tint n = ans.size();\n\tif (i < 0 || n <= i || j < 0 || n <= j) { return 1; }\n\treturn ans[i][j];\n}\nint lcm(int a, int b) {\n\treturn a * b / gcd(a, b);\n}\nvoid del(vel &v, int a) {\n\tvel ans;\n\tfor (auto x : v) {\n\t\tif (x != a) { ans.push_back(x); }\n\t}\n\tv = ans;\n}\nvoid sz_tree(int ce0, V<V<pin>> &chi,vel &sz) {\n\tfor (auto x : chi[ce0]) {\n\t\tsz_tree(x.first, chi, sz);\n\t\tsz[ce0] += sz[x.first];\n\t}\n}\nint ord(int n) {\n\tif (n % 2 == 1) { return 0; }\n\treturn 1 + ord(n / 2);\n}\nint get(int st_val, int dif_val, int st_pla, int to_pla, vel &sum,vel &dsum) {\n\tint ans = st_val * (sum[to_pla] - sum[st_pla]);\n\tint pl = dsum[to_pla] - dsum[st_pla] - st_pla * (sum[to_pla] - sum[st_pla]);\n\tpl *= dif_val;\n\treturn ans + pl;\n}\nsigned main() {\n\tint n; cin >> n; n*=2;\n\tint q; cin >> q;\n\tvel a(n), b(n);\n\tint sum_a = 0;\n\tset<pin> set_pl; int sum_pl = 0;\n\tset<pin> set_mi;\n\trep(i, n) { cin >> a[i]; }\n\trep(i, n) { cin >> b[i]; }\n\trep(i, n) { \n\t\tsum_a += a[i];\n\t\tif (0 < i and i < n-1) {\n\t\t\tint diff = b[i] - a[i];\n\t\t\tif (diff >= 0) { set_pl.insert(mkp(diff, i)); sum_pl += diff; }\n\t\t\telse { set_mi.insert(mkp(diff, i)); }\n\t\t}\n\t}\n\trep(i, q) {\n\t\tint x; cin >> x; x--;\n\t\tint diff_old = b[x] - a[x];\n\t\tif (0 < x and x < n - 1) {\n\t\t\tif (diff_old >= 0) { set_pl.erase(mkp(diff_old, x)); sum_pl -= diff_old; }\n\t\t\telse { set_mi.erase(mkp(diff_old, x)); }\n\t\t}\n\t\tsum_a -= a[x];\n\t\tcin >> a[x] >> b[x];\n\t\tint new_diff = b[x] - a[x];\n\t\tif (0 < x and x < n - 1) {\n\t\t\tif (new_diff >= 0) { set_pl.insert(mkp(new_diff, x)); sum_pl += new_diff; }\n\t\t\telse { set_mi.insert(mkp(new_diff, x)); }\n\t\t}\n\t\tsum_a += a[x];\n\t\tint ans = sum_pl;\n\t\tif (set_pl.size() % 2 != 0) {\n\t\t\tint pl1 = (*set_pl.begin()).first;\n\t\t\tauto itr = set_mi.end(); itr--;\n\t\t\tint mi1 = (*itr).first;\n\t\t\tans = max(ans - pl1, ans + mi1);\n\t\t}\n\t\tcout << sum_a+ans << endl;\n\t}\n\treturn 0;\n}\n/*3:00+30:00~ */"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nint main() {\n        int n, q;\n        scanf(\"%d%d\", &n, &q);\n        assert(n <= 5 && q <= 10);\n        n = 2 * n;\n        vector<int> a(n), b(n);\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &a[i]);\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &b[i]);\n        set<string> ok;\n        vector<int> s(n - 2);\n        for (int i = 0; i < n - 2; i ++) s[i] = i;\n        do {\n                string tmp = \"\";\n                for (int i = 0; i < n - 2; i ++) {\n                        if (s[i] & 1) tmp += \")\";\n                        else tmp += \"(\";\n                }\n                stack<char> st;\n                st.push('(');\n                for (int i = 0; i < n - 2; i ++) {\n                        if (!st.empty() && st.top() == '(' && tmp[i] == ')') st.pop();\n                        else st.push(tmp[i]);\n                }\n                if (st.top() == '(') st.pop();\n                if (st.empty()) ok.insert(\"(\" + tmp + \")\");\n        } while (next_permutation(s.begin(), s.end()));\n        vector<string> yes;\n        for (auto it : ok) yes.push_back(it);\n        while (q --) {\n                int p, x, y;\n                scanf(\"%d%d%d\", &p, &x, &y);\n                p --;\n                a[p] = x;\n                b[p] = y;\n                long long ans = - (1LL << 60);\n                for (int i = 0; i < yes.size(); i ++) {\n                        for (int j = i; j < yes.size(); j ++) {\n                                string fi = yes[i], se = yes[j];\n                                long long res = 0;\n                                for (int i = 0; i < n; i ++) {\n                                        if (fi[i] == se[i]) res += a[i];\n                                        else res += b[i];\n                                }\n                                ans = max(ans, res);\n                        }\n                }\n                printf(\"%lld\\n\", ans);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint main() {\n        int n, q;\n        scanf(\"%d%d\", &n, &q);\n        n = 2 * n;\n        vector<long long> a(n), b(n);\n        for (int i = 0; i < n; i ++) scanf(\"%lld\", &a[i]);\n        for (int i = 0; i < n; i ++) scanf(\"%lld\", &b[i]);\n        multiset<long long> positive, negative;\n        int psum = 0, nsum = 0;\n        for (int i = 0; i < n; i ++) {\n                if (i == 0 || i == n - 1) {\n                        psum += a[i];\n                        continue;\n                }\n                long long c = a[i] - b[i];\n                if (c >= 0) { \n                        positive.insert(c);\n                        psum += a[i];\n                } else { \n                        negative.insert(- c);\n                        nsum += b[i];\n                }\n        }\n        while (q --) {\n                int p;\n                long long x, y;\n                scanf(\"%d%lld%lld\", &p, &x, &y);\n                p --;\n                long long z = x - y;\n                if (p == 0 || p == n - 1) {\n                        psum -= a[p];\n                        psum += x;\n                        a[p] = x;\n                        continue;\n                }\n                int c = a[p] - b[p];\n                if (c >= 0) {\n                        positive.erase(positive.find(c));\n                        psum -= a[p];\n                } else {\n                        negative.erase(negative.find(-c));\n                        nsum -= b[p];\n                }\n                if (z >= 0) {\n                        positive.insert(z);\n                        psum += x;\n                } else {\n                        negative.insert(-z);\n                        nsum += y;\n                }\n                a[p] = x;\n                b[p] = y;\n                long long ans;\n                if (positive.size() % 2 == 0) ans = psum + nsum;\n                else ans = psum + nsum - min(*positive.begin(), *negative.begin());\n                printf(\"%lld\\n\", ans);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//todo 文字数を少なくする\n\n//#pragma GCC optimize (\"-O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\n\n//@必須構造\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    bool operator==(const T &r) const {\n        return f == r.f && s == r.s && t == r.t;\n    }\n    bool operator!=(const T &r) const {\n        return f != r.f || s != r.s || t != r.t;\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\nstruct F {\n    int a, b, c, d;\n    F() { a = -1, b = -1, c = -1, d = -1; }\n    F(int a, int b, int c, int d) : a(a), b(b), c(c), d(d) {}\n    bool operator<(const F &r) const {\n        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;\n//        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;\n    }\n    bool operator>(const F &r) const {\n        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;\n//        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;\n    }\n    bool operator==(const F &r) const {\n        return a == r.a && b == r.b && c == r.c && d == r.d;\n    }\n    bool operator!=(const F &r) const {\n        return a != r.a || b != r.b || c != r.c || d != r.d;\n    }\n    int operator[](int i) {\n        assert(i < 4);\n        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;\n    }\n};\n\nT mt(int a, int b, int c) {\n    return T(a, b, c);\n}\n//@マクロ省略系 型,構造\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec vector\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n\n#define minq 0\n#define maxq 1\n\n//マクロ省略系 コンテナ\n\nusing vi = vector<int>;\n#define _overloadvvi(_1, _2, _3, _4, name, ...) name\n#define vvi0() vec<vi>\n#define vvi1(a) vec<vi> a\n#define vvi2(a, b) vec<vi> a(b)\n#define vvi3(a, b, c) vec<vi> a(b,vi(c))\n#define vvi4(a, b, c, d) vec<vi> a(b,vi(c,d))\n#define vvi(...) _overloadvvi(__VA_ARGS__,vvi4,vvi3,vvi2 ,vvi1,vvi0)(__VA_ARGS__)\n\n\nusing vl = vector<ll>;\n#define _overloadvvl(_1, _2, _3, _4, name, ...) name\n#define vvl1(a) vec<vl> a\n#define vvl2(a, b) vec<vl> a(b)\n#define vvl3(a, b, c) vec<vl> a(b,vl(c))\n#define vvl4(a, b, c, d) vec<vl> a(b,vl(c,d))\n#define vvl(...) _overloadvvl(__VA_ARGS__,vvl4,vvl3,vvl2 ,vvl1)(__VA_ARGS__)\n\nusing vb = vector<bool>;\n#define _overloadvvb(_1, _2, _3, _4, name, ...) name\n#define vvb1(a) vec<vb> a\n#define vvb2(a, b) vec<vb> a(b)\n#define vvb3(a, b, c) vec<vb> a(b,vb(c))\n#define vvb4(a, b, c, d) vec<vb> a(b,vb(c,d))\n#define vvb(...) _overloadvvb(__VA_ARGS__,vvb4,vvb3,vvb2 ,vvb1)(__VA_ARGS__)\n\nusing vs = vector<string>;\n#define _overloadvvs(_1, _2, _3, _4, name, ...) name\n#define vvs1(a) vec<vs> a\n#define vvs2(a, b) vec<vs> a(b)\n#define vvs3(a, b, c) vec<vs> a(b,vs(c))\n#define vvs4(a, b, c, d) vec<vs> a(b,vs(c,d))\n#define vvs(...) _overloadvvs(__VA_ARGS__,vvs4,vvs3,vvs2 ,vvs1)(__VA_ARGS__)\n\nusing vd = vector<double>;\n#define _overloadvvd(_1, _2, _3, _4, name, ...) name\n#define vvd1(a) vec<vd> a\n#define vvd2(a, b) vec<vd> a(b)\n#define vvd3(a, b, c) vec<vd> a(b,vd(c))\n#define vvd4(a, b, c, d) vec<vd> a(b,vd(c,d))\n#define vvd(...) _overloadvvd(__VA_ARGS__,vvd4,vvd3,vvd2 ,vvd1)(__VA_ARGS__)\n\nusing vc=vector<char>;\n#define _overloadvvc(_1, _2, _3, _4, name, ...) name\n#define vvc1(a) vec<vc> a\n#define vvc2(a, b) vec<vc> a(b)\n#define vvc3(a, b, c) vec<vc> a(b,vc(c))\n#define vvc4(a, b, c, d) vec<vc> a(b,vc(c,d))\n#define vvc(...) _overloadvvc(__VA_ARGS__,vvc4,vvc3,vvc2 ,vvc1)(__VA_ARGS__)\n\nusing vp = vector<P>;\n#define _overloadvvp(_1, _2, _3, _4, name, ...) name\n#define vvp1(a) vec<vp> a\n#define vvp2(a, b) vec<vp> a(b)\n#define vvp3(a, b, c) vec<vp> a(b,vp(c))\n#define vvp4(a, b, c, d) vec<vp> a(b,vp(c,d))\n#define vvp(...) _overloadvvp(__VA_ARGS__,vvp4,vvp3,vvp2 ,vvp1)(__VA_ARGS__)\n\nusing vt = vector<T>;\n#define _overloadvvt(_1, _2, _3, _4, name, ...) name\n#define vvt1(a) vec<vt> a\n#define vvt2(a, b) vec<vt> a(b)\n#define vvt3(a, b, c) vec<vt> a(b,vt(c))\n#define vvt4(a, b, c, d) vec<vt> a(b,vt(c,d))\n#define vvt(...) _overloadvvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1)(__VA_ARGS__)\n\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n\n#define _vvi vector<vi>\n#define _vvl vector<vl>\n#define _vvb vector<vb>\n#define _vvs vector<vs>\n#define _vvd vector<vd>\n#define _vvc vector<vc>\n#define _vvp vector<vp>\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n#define vni(name, ...) auto name = make_v<int>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); gi++)\n#define fort(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); gi++)if(t!=p)\n//#define fort(gi, ve) for (int gi = 0, f, t, c;gi<ve.size()&& (gi+= (ve[gi].t==p))< ve.size() && (f = ve[gi].f,t=ve[gi].t, c = ve[gi].c,true); gi++)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> {\n    public:\n        size_t operator()(const std::pair<signed, signed> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n    template<> class hash<std::pair<ll, ll>> {\n    public:\n        //大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断\n        size_t operator()(const std::pair<ll, ll> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n}\nistream &operator>>(istream &iss, P &a) {\n    iss >> a.first >> a.second;\n    return iss;\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\nostream &operator<<(ostream &os, P p) {\n    os << p.fi << \" \" << p.se << endl;\n    return os;\n}\n\nostream &operator<<(ostream &os, T p) {\n    os << p.f << \" \" << p.s << \" \" << p.t;\n    return os;\n}\nostream &operator<<(ostream &os, F p) {\n    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <T> &vec) {\n    for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <vector<T>> &vec) {\n    for (int i = 0; i < vec.size(); i++) {\n        for (int j = 0; j < vec[0].size(); j++) {\n            os << vec[i][j];\n        }\n        os << endl;\n    }\n    return os;\n}\ntemplate<typename V, typename H> void resize(vector<V> &vec, const H head) { vec.resize(head); }\ntemplate<typename V, typename H, typename ... T> void resize(vector<V> &vec, const H &head, const T ... tail) {\n    vec.resize(head);\n    for (auto &v: vec) resize(v, tail...);\n}\ntemplate<typename T, typename _Pr> bool all_of(const vector<T> &vec, _Pr pred) { return std::all_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> bool any_of(const vector<T> &vec, _Pr pred) { return std::any_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> bool none_of(const vector<T> &vec, _Pr pred) { return std::none_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> const typename vector<T>::const_iterator find_if(const vector<T> &vec, _Pr pred) { return std::find_if(vec.begin(), vec.end(), pred); }\ntemplate<typename T> bool contains(const vector<T> &vec, const T &val) { return std::find(vec.begin(), vec.end(), val) != vec.end(); }\ntemplate<typename T, typename _Pr> bool contains_if(const vector<T> &vec, _Pr pred) { return std::find_if(vec.begin(), vec.end(), pred) != vec.end(); }\ntemplate<class T> void replace(vector<T> &a, T key, T v) { replace(a.begin(), a.end(), key, v); }\ntemplate<class T> void replace(str &a, T key, T v) { replace(a.begin(), a.end(), key, v); }\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {\n    vi c = a;\n    vi d = b;\n    sort(all(c));\n    sort(all(d));\n    return includes(all(c), all(d));\n}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\n\ntemplate<class T> T pop(set<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T pop(mset<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(set<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(mset<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ninline void sort(string &a) { sort(a.begin(), a.end()); }\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T, class F> inline void sort(vector<T> &a, F f) { sort(a.begin(), a.end(), [&](T l, T r) { return f(l) < f(r); }); };\nenum ___pcomparator {\n    fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd\n};\ninline void sort(vector<P> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });\n            break;\n        case fisd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });\n            break;\n        case fdsi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });\n            break;\n        case fdsd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });\n            break;\n        case sifi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });\n            break;\n        case sifd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });\n            break;\n        case sdfi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });\n            break;\n        case sdfd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });\n            break;\n    }\n};\ninline void sort(vector<T> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });\n            break;\n        case\n            fisd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });\n            break;\n        case\n            fdsi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });\n            break;\n        case\n            fdsd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });\n            break;\n        case\n            sifi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });\n            break;\n        case\n            sifd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });\n            break;\n        case\n            sdfi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });\n            break;\n        case\n            sdfd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });\n            break;\n    }\n};\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class U, class F> inline void rsort(vector<U> &a, F f) { sort(a.begin(), a.end(), [&](U l, U r) { return f(l) > f(r); }); };\ntemplate<class U> inline void sortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;;\n    }\n};\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, char type) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, type);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void rsortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void rsortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void rsortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    rsort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\n\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {\n    xx = vall;\n}\ntemplate<typename V, typename T>\nvoid fill(vector<V> &vecc, const T vall) {\n    for (auto &&vx: vecc) fill(vx, vall);\n}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {\n    T x;\n    cin >> x;\n    return (x);\n}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\n#define _overloadout(_1, _2, _3, _4, name, ...) name\n#define out1(a) cout<<a<<endl\n#define out2(a, b) cout<<a<<\" \"<< b<<endl\n#define out3(a, b, c) cout<<a<<\" \"<<b<<\" \"<<c<<endl\n#define out4(a, b, c, d) cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl\n#define out(...) _overloadout(__VA_ARGS__,out4,out3,out2,out1)(__VA_ARGS__)\n\n#define _overloadoutl(_1, _2, _3, _4, name, ...) name\n#define outl1(a) cout<<a<<endl\n#define outl2(a, b) cout<<a<<endl;cout<<b<<endl\n#define outl3(a, b, c) cout<<a<<endl;cout<<b<<endl;cout<<c<<endl\n#define outl4(a, b, c, d) cout<<a<<endl;cout<<b<<endl;cout<<c<<endl;cout<<d<<endl\n#define outl(...) _overloadout(__VA_ARGS__,outl4,outl3,outl2,outl1)(__VA_ARGS__)\n\nstring sin() { return _in<string>(); }\nll lin() { return _in<ll>(); }\n#define na(a, n) a.resize(n); rep(i,n) cin >> a[i];\n#define nao(a, n) a.resize(n+1); rep(i,n) cin >> a[i+1];\n#define nad(a, n) a.resize(n); rep(i,n){ cin >> a[i]; a[i]--;}\n#define na2(a, b, n) a.resize(n),b.resize(n);rep(i, n)cin >> a[i] >> b[i];\n#define nao2(a, b, n) a.resize(n+1),b.resize(n+1);rep(i, n)cin >> a[i+1] >> b[i+1];\n#define na2d(a, b, n) a.resize(n),b.resize(n);rep(i, n){cin >> a[i] >> b[i];a[i]--,b[i]--;}\n#define na3(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define na3d(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n){cin >> a[i] >> b[i] >> c[i];a[i]--,b[i]--,c[i]--;}\n#define nt(a, h, w) resize(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rs(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n\n//デバッグ\n#define sp << \" \" <<\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<x << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<x<<\", \"<< debugName(y)<<\" = \"<<y<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<x  << \", \" <<  debugName(y)<<\" = \"<<y <<\", \" debugName(z)<<\" = \"<<z <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<\", \" <<  debugName(b)<<\" = \"<<b<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n\n#ifdef _DEBUG\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#else\n#define deb(...) ;\n#endif\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n//よく使うクラス、構造体\nclass UnionFind {\npublic:\n    vi par, rank, sizes;\n    int n, trees;\n    UnionFind(int n) : n(n), trees(n) {\n        par.resize(n), rank.resize(n), sizes.resize(n);\n        rep(i, n)par[i] = i, sizes[i] = 1;\n    }\n    int root(int x) {\n        if (par[x] == x)return x;\n        else return par[x] = root(par[x]);\n    }\n    int find(int x) { return root(x); }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y)return;\n        if (rank[x] < rank[y])swap(x, y);\n        trees--;\n        par[y] = x;\n        sizes[x] += sizes[y];\n        if (rank[x] == rank[y])rank[x]++;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return sizes[root(x)]; }\n    //順不同 umapなので\n    vec<vi> sets() {\n        vec<vi> res(trees);\n        umap<int, vi> map;\n        rep(i, n) map[root(i)].push_back(i);\n        int i = 0;\n        for (auto &&p:map) {\n            int r = p.fi;\n            res[i].push_back(r);\n            for (auto &&v:p.se) {\n                if (r == v)continue;\n                res[i].push_back(v);\n            }\n            i++;\n        }\n        return res;\n    }\n};\n\nusing bint =__int128;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n    std::ostream::sentry s(dest);\n    if (s) {\n        __uint128_t tmp = value < 0 ? -value : value;\n        char buffer[128];\n        char *d = std::end(buffer);\n        do {\n            --d;\n            *d = \"0123456789\"[tmp % 10];\n            tmp /= 10;\n        } while (tmp != 0);\n        if (value < 0) {\n            --d;\n            *d = '-';\n        }\n        int len = std::end(buffer) - d;\n        if (dest.rdbuf()->sputn(d, len) != len) {\n            dest.setstate(std::ios_base::badbit);\n        }\n    }\n    return dest;\n}\n\n__int128 toi128(string &s) {\n    __int128 ret = 0;\n    for (int i = 0; i < s.length(); i++)\n        if ('0' <= s[i] && s[i] <= '9')\n            ret = 10 * ret + s[i] - '0';\n    return ret;\n}\n\n\ntemplate<typename T> T minv(T a, T m);\n\ntemplate<typename T>\nclass Modular {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;\n\n    constexpr Modular() : value() {}\n    template<typename U>\n    Modular(const U &x) {\n        value = normalize(x);\n    }\n\n    template<typename U>\n    static Type normalize(const U &x) {\n        Type v;\n        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n        else v = static_cast<Type>(x % mod());\n        if (v < 0) v += mod();\n        return v;\n    }\n\n    const Type &operator()() const { return value; }\n    template<typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static Type mod() { return T::value; }\n\n    Modular &operator+=(const Modular &other) {\n        if ((value += other.value) >= mod()) value -= mod();\n        return *this;\n    }\n    Modular &operator-=(const Modular &other) {\n        if ((value -= other.value) < 0) value += mod();\n        return *this;\n    }\n    template<typename U> Modular &operator+=(const U &other) { return *this += Modular(other); }\n    template<typename U> Modular &operator-=(const U &other) { return *this -= Modular(other); }\n    Modular &operator++() { return *this += 1; }\n    Modular &operator--() { return *this -= 1; }\n    Modular operator++(signed) {\n        Modular result(*this);\n        *this += 1;\n        return result;\n    }\n    Modular operator--(signed) {\n        Modular result(*this);\n        *this -= 1;\n        return result;\n    }\n    Modular operator-() const { return Modular(-value); }\n\n    template<typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, signed>::value, Modular>::type &operator*=(const Modular &rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n        asm(\n        \"divl %4; \\n\\t\"\n        : \"=a\" (d), \"=d\" (m)\n        : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n        );\n        value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template<typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &operator*=(const Modular &rhs) {\n        int64_t q = static_cast<int64_t>(static_cast<double>(value) * rhs.value / mod());\n        value = normalize(value * rhs.value - q * mod());\n        return *this;\n    }\n    template<typename U = T>\n    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {\n        value = normalize(value * rhs.value);\n        return *this;\n    }\n\n    Modular &operator/=(const Modular &other) { return *this *= Modular(minv(other.value, mod())); }\n\n    template<typename U>\n    friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);\n\n    template<typename U>\n    friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);\n\n    template<typename U>\n    friend std::istream &operator>>(std::istream &stream, Modular<U> &number);\n\nprivate:\n    Type value;\n};\n\ntemplate<typename T> bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }\ntemplate<typename T, typename U> bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate<typename T, typename U> bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate<typename T> bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\ntemplate<typename T> bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }\n\ntemplate<typename T> Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\ntemplate<typename T, typename U> Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate<typename T, typename U> Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate<typename T> Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate<typename T> Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate<typename T> Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\nconstexpr signed MOD = 1000000007;\nusing mint = Modular<std::integral_constant<decay<decltype(MOD)>::type, MOD>>;\n\nmint com(int n, int r) {\n    const int NUM_ = 1400001;\n    static ll fac[NUM_ + 1], finv[NUM_ + 1], inv[NUM_ + 1];\n    if (fac[0] == 0) {\n        inv[1] = fac[0] = finv[0] = 1;\n        for (int i = 2; i <= NUM_; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n        for (int i = 1; i <= NUM_; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n    if (r < 0 || r > n) return 0;\n    return mint(finv[r] * fac[n] % MOD * finv[n - r]);\n}\nmint ncr(int n, int r) { return com(n, r); }\nmint nhr(int n, int r) { return com(n + r - 1, r); }\n\n\ntemplate<typename T> T minv(T a, T m) {\n    T u = 0, v = 1;\n    while (a != 0) {\n        T t = m / a;\n        m -= t * a;\n        swap(a, m);\n        u -= t * v;\n        swap(u, v);\n    }\n    assert(m == 1);\n    return u;\n}\n\ntemplate<typename T, typename U> Modular<T> mpow(const Modular<T> &a, const U &b) {\n    assert(b >= 0);\n    int x = a(), res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) (res *= x) %= MOD;\n        (x *= x) %= MOD;\n        p >>= 1;\n    }\n    return res;\n}\ntemplate<typename T, typename U> Modular<T> mpow(const T &a, const U &b) {\n    assert(b >= 0);\n    int x = a, res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) (res *= x) %= MOD;\n        (x *= x) %= MOD;\n        p >>= 1;\n    }\n    return res;\n}\ntemplate<typename T> string to_string(const Modular<T> &number) {\n    return to_string(number());\n}\n\ntemplate<typename T> std::ostream &operator<<(std::ostream &stream, const Modular<T> &number) {\n    return stream << number();\n}\n\ntemplate<typename T> std::istream &operator>>(std::istream &stream, Modular<T> &number) {\n    typename common_type<typename Modular<T>::Type, int64_t>::type x;\n    stream >> x;\n    number.value = Modular<T>::normalize(x);\n    return stream;\n}\n\nusing PM = pair<mint, mint>;\nusing vm = vector<mint>;\n#define _overloadvvm(_1, _2, _3, _4, name, ...) name\n\n\n#define vvm1(a) vec<vm> a\n#define vvm2(a, b) vec<vm> a(b)\n#define vvm3(a, b, c) vec<vm> a(b,vm(c))\n#define vvm4(a, b, c, d) vec<vm> a(b,vm(c,d))\n#define vvm(...) _overloadvvm(__VA_ARGS__,vvm4,vvm3,vvm2 ,vvm1)(__VA_ARGS__)\n\nvb isPrime;\nvi primes;\n\nvoid setPrime() {\n    int len = 4010101;\n    isPrime.resize(4010101);\n    fill(isPrime, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i <= sqrt(len) + 5; ++i) {\n        if (!isPrime[i])continue;\n        for (int j = 2; i * j < len; ++j) {\n            isPrime[i * j] = false;\n        }\n    }\n    rep(i, len)if (isPrime[i])primes.pb(i);\n}\n//幾何 Pをcomplexとして扱う\nbool eq(double a, double b) { return fabs(a - b) < eps; }\nusing C =complex<double>;\nC rot(C &a, dou th) { return a * C(cos(th), sin(th)); }\ndou inpro(C &a, C &b) { return real(a * conj(b)); }\n\n//90度回転させて内積が0なら平行\nbool line(C a, C b, C c) {\n    C ab = b - a;\n    C ac = c - a;\n    //複素数の掛け算は回転\n    ab *= C(0, 1);\n    return eq(inpro(ab, ac), 0);\n}\nbool line(P a, P b, P c) { return line(C(a.fi, a.se), C(b.fi, b.se), C(c.fi, c.se)); }\n\nbool line(int xa, int ya, int xb, int yb, int xc, int yc) {\n    C a = C(xa, ya);\n    C b = C(xb, yb);\n    C c = C(xc, yc);\n    return line(a, b, c);\n}\n//便利関数\n\n//テスト用\nchar ranc() {\n    return (char) ('a' + rand() % 26);\n}\nint rand(int min, int max) {\n    assert(min <= max);\n    if (min >= 0 && max >= 0) {\n        return rand() % (max + 1 - min) + min;\n    } else if (max < 0) {\n        return -rand(-max, -min);\n    } else {\n        //+\n        if (rand() % 2) {\n            return rand(0, max);\n            //-\n        } else {\n            return -rand(0, -min);\n        }\n    }\n}\nvi ranv(int n, int min, int max) {\n    vi v(n);\n    rep(i, n)v[i] = rand(min, max);\n    return v;\n}\n//単調増加\nvi ranvi(int n, int min, int max) {\n    vi v(n);\n    bool bad = 1;\n    while (bad) {\n        bad = 0;\n        v.resize(n);\n        rep(i, n) {\n            if (i && min > max - v[i - 1]) {\n                bad = 1;\n                break;\n            }\n            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]);\n            else v[i] = rand(min, max);\n        }\n    }\n    return v;\n}\nvoid ranvlr(int n, int min, int max, vi &l, vi &r) {\n    l.resize(n);\n    r.resize(n);\n    rep(i, n) {\n        l[i] = rand(min, max);\n        r[i] = l[i] + rand(0, max - l[i]);\n    }\n}\n//便利 汎用\n//strを整数として比較\nstring smax(str &a, str b) {\n    if (sz(a) < sz(b)) {\n        return b;\n    } else if (sz(a) > sz(b)) {\n        return a;\n    } else {\n        rep(i, sz(a)) {\n            if (a[i] < b[i]) {\n                return b;\n            } else if (a[i] > b[i])return a;\n        }\n    }\n    return a;\n}\n//strを整数として比較\nstring smin(str &a, str b) {\n    if (sz(a) < sz(b)) {\n        return a;\n    } else if (sz(a) > sz(b)) {\n        return b;\n    } else {\n        rep(i, sz(a)) {\n            if (a[i] < b[i]) {\n                return a;\n            } else if (a[i] > b[i])return b;\n        }\n    }\n    return a;\n}\ntemplate<typename V, typename T> int find(vector<V> &a, const T key) {\n    rep(i, sz(a))if (a[i] == key)return i;\n    return -1;\n}\ntemplate<typename V, typename T> P find(vector<vector<V>> &a, const T key) {\n    rep(i, sz(a)) rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);\n    return mp(-1, -1);\n}\ntemplate<typename V, typename U> T find(vector<vector<vector<V>>> &a, const U key) {\n    rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);\n    return mt(-1, -1, -1);\n}\n\ntemplate<typename V, typename T> int count(V &a, const T k) { return a == k; }\ntemplate<typename V, typename T> int count(vector<V> &a, const T k) {\n    int ret = 0;\n    fora(v, a)ret += count(v, k);\n    return ret;\n}\ntemplate<typename V> int count_odd(V &a) { return a % 2; }\ntemplate<typename V> int count_odd(vector<V> &a) {\n    int ret = 0;\n    fora(v, a)ret += count_odd(v);\n    return ret;\n}\ntemplate<typename V> int count_even(V &a) { return a % 2 == 0; }\ntemplate<typename V> int count_even(vector<V> &a) {\n    int ret = 0;\n    fora(v, a)ret += count_even(v);\n    return ret;\n}\n//algorythm\nvoid iota(vector<int> &ve, int s, int n) {\n    ve.resize(n);\n    iota(all(ve), s);\n}\nvi iota(int s, int n) {\n    vi ve(n);\n    iota(all(ve), s);\n    return ve;\n}\n//便利 数学\nint mod(int a, int m) { return (a % m + m) % m; }\nint pow(int a) { return a * a; };\nll fact(int v) { return v <= 1 ? 1 : v * fact(v - 1); }\nll comi(int n, int r) {\n    assert(n < 100);\n    static vvi(pas, 100, 100);\n    if (pas[0][0])return pas[n][r];\n    pas[0][0] = 1;\n    rep(i, 1, 100) {\n        pas[i][0] = 1;\n        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];\n    }\n    return pas[n][r];\n}\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");\n    exit(0);\n#endif\n    string a = \"a\";\n    rep(i, 30)a += a;\n    rep(i, 1 << 17)cout << a << endl;\n    cout << \"OLE 出力長制限超過\" << endl;\n    exit(0);\n}\nvoid tle() { while (inf)cout << inf << endl; }\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll gcd(vi b) {\n    ll res = b[0];\n    for (auto &&v :b)res = gcd(v, res);\n    return res;\n}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll rev(ll a) {\n    ll res = 0;\n    while (a) {\n        res *= 10;\n        res += a % 10;\n        a /= 10;\n    }\n    return res;\n}\ntemplate<class T> void rev(vector<T> &a) {\n    reverse(all(a));\n}\nvoid rev(string &a) {\n    reverse(all(a));\n}\nll ceil(ll a, ll b) {\n    if (b == 0) {\n        debugline(\"ceil\");\n        deb(a, b);\n        ole();\n        return -1;\n    } else if (a < 0) {\n        return 0;\n    } else {\n        return (a + b - 1) / b;\n    }\n}\nll sqrt(ll a) {\n    if (a < 0) {\n        debugline(\"sqrt\");\n        deb(a);\n        ole();\n    }\n    ll res = (ll) std::sqrt(a);\n    while (res * res < a)res++;\n    return res;\n}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {\n    vi res;\n    double lim = std::sqrt(v);\n    for (int i = 1; i <= lim; ++i) {\n        if (v % i == 0) {\n            res.pb(i);\n            if (i != v / i)res.pb(v / i);\n        }\n    }\n    return res;\n}\n\nvi factorization(int v) {\n    int tv = v;\n    vi res;\n    if (isPrime.size() == 0)setPrime();\n    for (auto &&p :primes) {\n        if (v % p == 0)res.push_back(p);\n        while (v % p == 0) {\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res.pb(v);\n    return res;\n}\n\nunordered_map<int, int> factorizationMap(int v) {\n    int tv = v;\n    unordered_map<int, int> res;\n    if (isPrime.size() == 0)setPrime();\n    for (auto &&p :primes) {\n        while (v % p == 0) {\n            res[p]++;\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res[v]++;\n    return res;\n}\nint get(int a, int keta) { return (a / (int) pow(10, keta)) % 10; }\nint keta(int v) {\n    int cou = 0;\n    while (v) { cou++, v %= 10; }\n    return cou;\n}\nint dsum(int v) {\n    int ret = 0;\n    for (; v; v /= 10)ret += v % 10;\n    return ret;\n}\nint sumd(int v) { return dsum(v); }\n//変換系\ntemplate<class T, class U> vector<T> keys(vector<pair<T, U>> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\ntemplate<class T, class U> vector<U> keys(map<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\n\ntemplate<class T, class U> vector<U> keys(umap<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\n\ntemplate<class T, class U> vector<U> values(vector<pair<T, U>> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(map<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(umap<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\nvi list(int a) {\n    vi res;\n    while (a) {\n        res.insert(res.begin(), a % 10);\n        a /= 10;\n    }\n    return res;\n}\n\ntemplate<class T, class U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> bool chmax(const U &b) { return chmax(ma, b); }\ntemplate<class T, class U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> bool chmin(const U &b) { return chmin(mi, b); }\n#define chmi chmin\n#define chma chmax\ntemplate<class T> T min(T a, signed b) { return a < b ? a : b; }\ntemplate<class T> T max(T a, signed b) { return a < b ? b : a; }\ntemplate<class T> T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T> T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T> T min(vector<T> a) { return *min_element(all(a)); }\ntemplate<class T> T min(vector<T> a, int n) { return *min_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T> T min(vector<T> a, int s, int n) { return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T> T max(vector<T> a) { return *max_element(all(a)); }\ntemplate<class T> T max(vector<T> a, int n) { return *max_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T> T max(vector<T> a, int s, int n) { return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<typename A, size_t N> A max(A (&a)[N]) {\n    A res = a[0];\n    rep(i, N)res = max(res, a[i]);\n    return res;\n}\ntemplate<typename A, size_t N, size_t O> A max(A (&a)[N][O]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P> A max(A (&a)[N][O][P]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q> A max(A (&a)[N][O][P][Q], const T &v) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A max(A (&a)[N][O][P][Q][R]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A max(A (&a)[N][O][P][Q][R][S]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N> A min(A (&a)[N]) {\n    A res = a[0];\n    rep(i, N)res = min(res, a[i]);\n    return res;\n}\ntemplate<typename A, size_t N, size_t O> A min(A (&a)[N][O]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P> A min(A (&a)[N][O][P]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q> A min(A (&a)[N][O][P][Q], const T &v) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A min(A (&a)[N][O][P][Q][R]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A min(A (&a)[N][O][P][Q][R][S]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\n\n\ntemplate<class T> T sum(vector<T> v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 0;\n    chmin(len, v.size());\n    rep(i, len)res += v[i];\n    return res;\n}\ntemplate<class T> T sum(vector<vector<T>> &v, int h = -1, int w = -1) {\n    if (h == -1)h = v.size();\n    if (w == -1)w = v[0].size();\n    T res = 0;\n    chmin(h, v.size());\n    chmin(w, v[0].size());\n    rep(i, h)rep(j, w)res += v[i][j];\n    return res;\n}\n\nP sump(vp &v, int len = -1) {\n    if (len == -1)len = v.size();\n    P res = {0, 0};\n    chmin(len, v.size());\n    rep(i, len) {\n        res.fi += v[i].fi;\n        res.se += v[i].se;\n    }\n    return res;\n}\n\n///要素が0の時、返り値は0か1か\ntemplate<class T> T mul(vector<T> &v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 1;\n    chmin(len, v.size());\n    rep(i, len)res *= v[i];\n    return res;\n}\nvoid clear(PQ &q) { while (q.size())q.pop(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(int size) {\n    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));\n    return body + size;\n}\ntemplate<class T> T *negarr2(int h, int w) {\n    double **dummy1 = new double *[2 * h + 1];\n    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];\n    dummy1[0] = dummy2 + w;\n    for (int i = 1; i <= 2 * h + 1; i++) {\n        dummy1[i] = dummy1[i - 1] + 2 * w + 1;\n    }\n    double **a = dummy1 + h;\n}\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {\n    vector<T> ret = v;\n    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];\n    return ret;\n}\ntemplate<class T> vector<T> imomi(vector<T> &v) {\n    vector<T> ret = v;\n    rep(i, sz(ret) - 1)chmin(ret[i + 1], ret[i]);\n    return ret;\n}\ntemplate<class T> struct ruiC {\n    const vector<T> rui;\n    ruiC(vector<T> &ru) : rui(ru) {}\n    T operator()(int l, int r) {\n        assert(l <= r);\n        return rui[r] - rui[l];\n    }\n    T operator[](int i) {\n        return rui[i];\n    }\n};\n\ntemplate<class T> struct rruic {\n    const T *rrui;\n    rruic(T *ru) : rrui(ru) {}\n    //n-1から-1へ\n    T operator()(int l, int r) {\n        assert(l >= r);\n        return rrui[r] - rrui[l];\n    }\n    T operator[](int i) {\n        return rrui[i];\n    }\n};\ntemplate<class T> vector<T> ruiv(vector<T> &a) {\n    vector<T> ret(a.size() + 1);\n    rep(i, a.size())ret[i + 1] = ret[i] + a[i];\n    return ret;\n}\ntemplate<class T> ruiC<T> ruic(vector<T> &a) {\n    vector<T> ret = ruiv(a);\n    return ruiC<T>(ret);\n}\n//xor\ntemplate<class T> vector<T> ruix(vector<T> &a) {\n    vector<T> ret(a.size() + 1);\n    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];\n    return ret;\n}\ntemplate<class T> vector<T> ruim(vector<T> &a) {\n    vector<T> res(a.size() + 1, 1);\n    rep(i, a.size())res[i + 1] = res[i] * a[i];\n    return res;\n}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> rruic<T> rrui(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    rer(i, len - 1)res[i - 1] = res[i] + a[i];\n    return rruic<T>(res);\n}\n//掛け算\ntemplate<class T> T *rruim(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    res[len - 1] = 1;\n    rer(i, len - 1)res[i - 1] = res[i] * a[i];\n    return res;\n}\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void inc(vector<T> &a, U v = 1) { for (auto &u :a)inc(u, v); }\ntemplate<class T> void inc(vector<T> &a) { for (auto &u :a)inc(u, 1); }\ntemplate<class T, class U> void plus(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void plus(vector<T> &a, U v = 1) { for (auto &u :a)inc(u, v); }\ntemplate<class T> void plus(vector<T> &a) { for (auto &u :a)inc(u, 1); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T> void dec(vector<T> &a) { for (auto &u :a)dec(u, 1); }\ntemplate<class T, class U> void minu(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void minu(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T> void minu(vector<T> &a) { for (auto &u :a)dec(u, 1); }\ninline bool inside(int h, int w, int H, int W) { return h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { return l <= v && v < r; }\n#define ins inside\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {\n    vector<T> ret = a;\n    fora(v, ret)v = u(v);\n    return ret;\n}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\nll goldd(ll left, ll right, function<ll(ll)> calc) {\n    double GRATIO = 1.6180339887498948482045868343656;\n    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n    ll fl = calc(lm);\n    ll fr = calc(rm);\n    while (right - left > 10) {\n        if (fl < fr) {\n            right = rm;\n            rm = lm;\n            fr = fl;\n            lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n            fl = calc(lm);\n        } else {\n            left = lm;\n            lm = rm;\n            fl = fr;\n            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n            fr = calc(rm);\n        }\n    }\n    ll minScore = MAX(ll);\n    ll resIndex = left;\n    for (ll i = left; i < right + 1; i++) {\n        ll score = calc(i);\n        if (minScore > score) {\n            minScore = score;\n            resIndex = i;\n        }\n    }\n    return resIndex;\n}\nll goldt(ll left, ll right, function<ll(ll)> calc) {\n    double GRATIO = 1.6180339887498948482045868343656;\n    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n    ll fl = calc(lm);\n    ll fr = calc(rm);\n    while (right - left > 10) {\n        if (fl > fr) {\n            right = rm;\n            rm = lm;\n            fr = fl;\n            lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n            fl = calc(lm);\n        } else {\n            left = lm;\n            lm = rm;\n            fl = fr;\n            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n            fr = calc(rm);\n        }\n    }\n    if (left > right) {\n        ll l = left;\n        left = right;\n        right = l;\n    }\n    ll maxScore = MIN(ll);\n    ll resIndex = left;\n    for (ll i = left; i < right + 1; i++) {\n        ll score = calc(i);\n        if (maxScore < score) {\n            maxScore = score;\n            resIndex = i;\n        }\n    }\n    return resIndex;\n}\ntemplate<class T> T min(vector<vector<T>> &a) {\n    T res = MAX(T);\n    rep(i, a.size())chmin(res, *min_element(all(a[i])));\n    return res;\n}\ntemplate<class T> T max(vector<vector<T>> &a) {\n    T res = MIN(T);\n    rep(i, a.size())chmax(res, *max_element(all(a[i])));\n    return res;\n}\n\nbool bget(ll m, int keta) { return (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {\n    m /= (ll) pow(sinsuu, keta);\n    return m % sinsuu;\n}\ninline ll bit(int n) { return (1LL << (n)); }\ninline ll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\n//int bcou(ll m) { return __builtin_popcount(m & 0xFFFFFFFF) + __builtin_popcount(m >> 32); }\n#define bcou __builtin_popcountll\n//最下位ビット\nint lbit(int n) {\n    return n & -n;\n}\n//最上位ビット\nint hbit(int n) {\n    n |= (n >> 1);\n    n |= (n >> 2);\n    n |= (n >> 4);\n    n |= (n >> 8);\n    n |= (n >> 16);\n    n |= (n >> 32);\n    return n - (n >> 1);\n}\n//初期化は0を渡す\nll nextComb(ll &mask, int n, int r) {\n    if (!mask)return mask = (1LL << r) - 1;\n    ll x = mask & -mask; //最下位の1\n    ll y = mask + x; //連続した下の1を繰り上がらせる\n    ll res = ((mask & ~y) / x >> 1) | y;\n    if (bget(res, n))return mask = 0;\n    else return mask = res;\n}\n\n//n桁以下でビットがr個立っているもののvectorを返す\nvl bitCombList(int n, int r) {\n    vl res;\n    int m = 0;\n    while (nextComb(m, n, r)) {\n        res.pb(m);\n    }\n    return res;\n}\n//大文字小文字を区別する\nint altoiaZ(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a' + 26;\n}\nchar itoalaZ(int i) {\n    if (i < 26)return 'A' + i;\n    return 'a' + i - 26;\n}\n//aもAも0を返す 基本小文字\nint altoi(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a';\n}\nchar itoal(int i) {\n    return 'a' + i;\n}\nint ctoi(char c) { return c - '0'; }\nchar itoc(int i) { return i + '0'; }\nint vtoi(vi &v) {\n    int res = 0;\n    if (sz(v) > 18) {\n        debugline(\"vtoi\");\n        deb(sz(v));\n        ole();\n    }\n    rep(i, sz(v)) {\n        res *= 10;\n        res += v[i];\n    }\n    return res;\n}\nvi itov(int i) {\n    vi res;\n    while (i) {\n        res.pb(i % 10);\n        i /= 10;\n    }\n    rev(res);\n    return res;\n}\nvector<vector<int>> ctoi(vector<vector<char>> s, char c) {\n    int n = sz(s), m = sz(s[0]);\n    vector<vector<int>> res(n, vector<int>(m));\n    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;\n    return res;\n}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\nvoid compress(vi &a) {\n    vi b;\n    int len = a.size();\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    unique(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n\nvoid compress(int a[], int len) {\n    vi b;\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    unique(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define lowerBound(a, v) (*lower_bound(all(a),v))\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define upperBound(a, v) (*upper_bound(all(a),v))\n#define ans(a) cout<<a<<endl;continue;\n#define poll(a) q.front();q.pop()\n#define dpoll(a) q.front();q.pop_front()\n#define pollLast(a) q.back();q.pop_back()\n#define pollBack(a) q.back();q.pop_back()\ntemplate<class T> inline void fin(T s) { cout << s << endl, exit(0); }\n\ntemplate<class T> struct edge {\n    int f, t;\n    T c;\n    int id;\n    int type;\n    edge(int f, int t, T c = 1, int id = -1, int ty = -1) : f(f), t(t), c(c), id(id), type(ty) {}\n    bool operator<(const edge &b) const { return c < b.c; }\n    bool operator>(const edge &b) const { return c > b.c; }\n};\ntemplate<class T> ostream &operator<<(ostream &os, edge<T> &e) {\n    os << e.f << \" \" << e.t << \" \" << e.c;\n    return os;\n}\ntemplate<typename T> class graph {\nprotected:\n    vector<bool> _used;\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n;\n    graph(int n) : n(n) { g.resize(n), _used.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {\n        this->n = n;\n        g.resize(n);\n        _used.resize(n);\n    }\n    int size() { return g.size(); }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int f, int t, T c, int id, int ty) = 0;\n    virtual bool used(edge<T> &e) = 0;\n    virtual bool used(int id) = 0;\n    virtual void del(edge<T> &e) = 0;\n    virtual void del(int id) = 0;\n    virtual void set_edges() = 0;\n};\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    int eid = 0;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"digraph add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        if (id == -1)id = eid++;\n        g[f].emplace_back(f, t, c, id, ty);\n//        edges.emplace_back(f, t, c, id, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n    void set_edges() {\n        rep(i, n)fora(e, g[i])edges.pb(e);\n    }\n};\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    int eid = 0;\n    undigraph(int n) : graph<T>(n) {\n    }\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"undigraph add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        if (id == -1)id = eid, eid += 2;\n        g[f].emplace_back(f, t, c, id, ty);\n        g[t].emplace_back(t, f, c, id + 1, ty);\n//        edges.emplace_back(f, t, c, id, ty);\n//        edges.emplace_back(t, f, c, id + 1, ty);\n    }\n    void add(edge<T> &e) {\n        int f = e.f, t = e.t, ty = e.type;\n        T c = e.c;\n        add(f, t, c, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n    void set_edges() {\n        rep(i, n)fora(e, g[i])edges.pb(e);\n    }\n};\ntemplate<class T> vector<T> dijkstra(const graph<T> &g, int s, int cant_arrive = -1) {\n    if (!(0 <= s && s < g.n)) {\n        debugline(\"dijkstra\");\n        deb(s, g.n);\n        ole();\n    }\n    T initValue = MAX(T);\n    vector<T> dis(g.n, initValue);\n    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;\n    dis[s] = 0;\n    q.emplace(0, s);\n    while (q.size()) {\n        T nowc = q.top().fi;\n        int i = q.top().se;\n        q.pop();\n        if (dis[i] != nowc)continue;\n        for (auto &&e  : g.g[i]) {\n            int to = e.t;\n            T c = nowc + e.c;\n            if (dis[to] > c) {\n                dis[to] = c;\n                q.emplace(dis[to], to);\n            }\n        }\n    }\n    //基本、たどり着かないなら-1\n    if (cant_arrive == -1)for (auto &&d :dis) if (d == initValue)d = -1;\n    return dis;\n}\ntemplate<class T> vector<vector<T>> warshall(const graph<T> &g, int cant_arrive = -1) {\n    int n = g.n;\n    vector<vector<T> > dis(n, vector<T>(n, linf));\n    rep(i, n)fora(e, g.g[i])chmin(dis[e.f][e.t], e.c);\n    rep(i, n)dis[i][i] = 0;\n    rep(k, n)rep(i, n)rep(j, n)chmin(dis[i][j], dis[i][k] + dis[k][j]);\n    //基本、たどり着かないなら-1\n    if (cant_arrive == -1)rep(i, n)rep(j, n) if (dis[i][j] == linf)dis[i][j] = -1;\n    return dis;\n}\n\ntemplate<class T=int> class tree : public undigraph<T> {\npublic:\n    using undigraph<T>::g;\n    using undigraph<T>::n;\n    using undigraph<T>::edges;\n    using undigraph<T>::_used;\n    vi dep;\n    vi disv;\nprivate:\n    bool never = 1;\n    int root = -1;\n    vector<vector<int>> par;\n    bool costallone;\n    void dfs(int v, int p, int d) {\n        dep[v] = d;\n        par[0][v] = p;\n        int lim = (*this)[v].size();\n        for (int i = 0; i < lim; i++) {\n            int t = g[v][i].t;\n            if (t == p)con;\n            dfs(t, v, d + 1);\n        }\n    }\n    void built() {\n        never = 0;\n        n = g.size();\n        par.assign(30, vi(n));\n        dep.resize(n);\n        costallone = 1;\n        rep(i, n)fora(e, g[i])if (e.c != 1)costallone = 0;\n        dfs(root, -1, 0);\n        rep(k, par.size() - 1) {\n            rep(i, n) {\n                if (par[k][i] == -1)par[k + 1][i] = -1;\n                else par[k + 1][i] = par[k][par[k][i]];\n            }\n        }\n        if (costallone)disv = dep;\n        else disv = dijkstra(*this, root);\n    }\n    int _lca(int u, int v) {\n        if (dep[u] > dep[v])swap(u, v);\n        rep(k, par.size()) {\n            if ((dep[u] - dep[v]) >> k & 1) {\n                v = par[k][v];\n            }\n        }\n        if (u == v)return u;\n        rer(k, par.size() - 1) {\n            if (par[k][u] != par[k][v]) {\n                u = par[k][u];\n                v = par[k][v];\n            }\n        }\n        return par[0][u];\n    }\n    int _dis(int u, int v) {\n        int p = _lca(u, v);\n        return disv[u] + disv[v] - disv[p] * 2;\n    }\npublic:\n    tree(int n, int root = 0) : undigraph<T>(n), root(root) {}\n    bool leaf(int v) {\n        return sz(g[v]) == 1 && v != root;\n    }\n    int dis(int u, int v) {\n        if (never) {\n            built();\n        }\n        return _dis(u, v);\n    }\n    int lca(int u, int v) {\n        if (never) {\n            built();\n        }\n        return _lca(u, v);\n    }\n};\n//辺によりメモリを大量消費\n// よってedgesを消している\n//頂点10^6でメモリを190MB(制限の8割)使う\n\n//軽量化のため、辺を持たないbig gridクラスがあってもいいかもしれない\n//\ntemplate<class T=int> class grid_k6 : public undigraph<T> {\npublic:\n    using undigraph<T>::g;\n    using undigraph<T>::n;\n    using undigraph<T>::edges;\n    using undigraph<T>::_used;\n    int H, W;\n    int eid = 0;\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"grid_k6 add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        g[f].emplace_back(f, t, c, eid++, ty);\n        g[t].emplace_back(t, f, c, eid++, ty);\n    }\n    int getid(int h, int w) {\n        if (!inside(h, w, H, W))return -1;\n        return W * h + w;\n    }\n    P get2(int id) {\n        return mp(id / W, id % W);\n    }\n    P operator()(int id) {\n        return get2(id);\n    }\n    int operator()(int h, int w) {\n        return getid(h, w);\n    }\n    grid_k6(int H, int W) : H(H), W(W), undigraph<T>(H * W) {\n        rep(h, H) {\n            rep(w, W) {\n                int f = getid(h, w);\n                if (w + 1 < W) add(f, getid(h, w + 1));\n                if (h + 1 < H)add(f, getid(h + 1, w));\n            }\n        }\n    }\n    grid_k6(_vvc ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), undigraph<T>(sz(ba) * sz(ba[0])) {\n        rep(h, H) {\n            rep(w, W) {\n                if (ba[h][w] == wall)con;\n                int f = getid(h, w);\n                if (w + 1 < W && ba[h][w + 1] != wall) {\n                    add(f, getid(h, w + 1));\n                }\n                if (h + 1 < H && ba[h + 1][w] != wall) {\n                    add(f, getid(h + 1, w));\n                }\n            }\n        }\n    }\n    void add(int fh, int fw, int th, int tw) {\n        add(getid(fh, fw), getid(th, tw));\n    }\n    void set_edges() {\n        rep(i, n)fora(e, g[i])edges.pb(e);\n    }\n};\n//左上から右下に移動できる\ntemplate<class T=int> class digrid_k6 : public digraph<T> {\npublic:\n    using digraph<T>::g;\n    using digraph<T>::n;\n    using digraph<T>::edges;\n    using digraph<T>::_used;\n    int H, W;\n    int eid = 0;\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"digrid_k6 add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        g[f].emplace_back(f, t, c, eid++, ty);\n    }\n    int getid(int h, int w) {\n        if (!inside(h, w, H, W))return -1;\n        return W * h + w;\n    }\n    P get2(int id) {\n        return mp(id / W, id % W);\n    }\n    P operator()(int id) {\n        return get2(id);\n    }\n    int operator()(int h, int w) {\n        return getid(h, w);\n    }\n    digrid_k6(int H, int W) : H(H), W(W), digraph<T>(H * W) {\n        rep(h, H) {\n            rep(w, W) {\n                int f = getid(h, w);\n                if (w + 1 < W) add(f, getid(h, w + 1));\n                if (h + 1 < H)add(f, getid(h + 1, w));\n            }\n        }\n    }\n    digrid_k6(_vvc ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), digraph<T>(sz(ba) * sz(ba[0])) {\n        rep(h, H) {\n            rep(w, W) {\n                if (ba[h][w] == wall)con;\n                int f = getid(h, w);\n                if (w + 1 < W && ba[h][w + 1] != wall) {\n                    add(f, getid(h, w + 1));\n                }\n                if (h + 1 < H && ba[h + 1][w] != wall) {\n                    add(f, getid(h + 1, w));\n                }\n            }\n        }\n    }\n    void add(int fh, int fw, int th, int tw) {\n        add(getid(fh, fw), getid(th, tw));\n    }\n    void set_edges() {\n        rep(i, n)fora(e, g[i])edges.pb(e);\n    }\n};\ntemplate<class T> bool nibu(const graph<T> &g) {\n    int size = 0;\n    rep(i, g.n)size += sz(g.g[i]);\n    if (size == 0)return true;\n\n    UnionFind uf(g.n * 2);\n    rep(i, g.n)fora(e, g.g[i])uf.unite(e.f, e.t + g.n), uf.unite(e.f + g.n, e.t);\n    rep(i, g.n)if (uf.same(i, i + g.n))return 0;\n    return 1;\n}\n//二部グラフを色分けした際の頂点数を返す\ntemplate<class T> vp nibug(graph<T> &g) {\n    vp cg;\n    if (!nibu(g)) {\n        debugline(\"nibu\");\n        ole();\n    }\n    int _n = g.size();\n    vb _was(_n);\n    queue<P> q;\n    rep(i, _n) {\n        if (_was[i])continue;\n        q.push(mp(i, 1));\n        _was[i] = 1;\n        int red = 0;\n        int coun = 0;\n        while (q.size()) {\n            int now = q.front().fi;\n            int col = q.front().se;\n            red += col;\n            coun++;\n            q.pop();\n            forg(gi, g[now]) {\n                if (_was[t])continue;\n                q.push(mp(t, col ^ 1));\n                _was[t] = 1;\n            }\n        }\n        cg.push_back(mp(red, coun - red));\n    }\n    return cg;\n\n}\ntemplate<class T> ostream &operator<<(ostream &os, graph<T> &g) {\n    rep(i, sz(g)) {\n        forg(gi, g[i]) {\n            os << f << \" \" << t << \" \" << c << endl;\n        }\n    }\n    return os;\n}\n\n//機能拡張\nvp vtop(vi &a, vi &b) {\n    vp res(sz(a));\n    rep(i, sz(a))res[i] = mp(a[i], b[i]);\n    return res;\n}\nvoid ptov(vp &p, vi &a, vi &b) {\n    a.resize(sz(p));\n    b.resize(sz(p));\n    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nbasic_string<_CharT, _Traits, _Alloc>\noperator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const int __rv) {\n    basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n    __str.append(to_string(__rv));\n    return __str;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nvoid operator+=(basic_string<_CharT, _Traits, _Alloc> &__lhs, const int __rv) {\n    __lhs += to_string(__rv);\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nbasic_string<_CharT, _Traits, _Alloc>\noperator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const signed __rv) {\n    basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n    __str.append(to_string(__rv));\n    return __str;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nvoid operator+=(basic_string<_CharT, _Traits, _Alloc> &__lhs, const signed __rv) {\n    __lhs += to_string(__rv);\n}\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) {\n    a.push(v);\n}\ntemplate<class T, class U> void operator+=(deque<T> &a, U v) {\n    a.push_back(v);\n}\ntemplate<class T, class U>\npriority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {\n    a.push(v);\n    return a;\n}\ntemplate<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {\n    a.push(v);\n    return a;\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {\n    a.pb(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> operator+(const vector <T> &a, U v) {\n    vector<T> ret = a;\n    ret += v;\n    return ret;\n}\ntemplate<class T, class U> vector<T> operator+(U v, const vector <T> &a) {\n    vector<T> ret = a;\n    ret.insert(ret.begin(), v);\n    return ret;\n}\ntemplate<class T> vector<T> &operator+=(vector<T> &a, vector <T> &b) {\n    fora(v, b)a += v;\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, initializer_list<U> v) {\n    for (auto &&va :v)a.pb(va);\n    return a;\n}\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {\n    if (sz(a) != sz(b)) {\n        debugline(\"vector<T> operator-=\");\n        deb(a);\n        deb(b);\n        ole();\n    }\n    rep(i, sz(a))a[i] -= b[i];\n    return a;\n}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector <T> &b) {\n    if (sz(a) != sz(b)) {\n        debugline(\"vector<T> operator-\");\n        deb(a);\n        deb(b);\n        ole();\n    }\n    vector<T> res(sz(a));\n    rep(i, sz(a))res[i] = a[i] - b[i];\n    return res;\n}\n\n\ntemplate<typename T> void remove(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\ntemplate<typename T> void remove(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\ntemplate<typename T> void removen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\ntemplate<typename T> void erase(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\ntemplate<typename T> void erasen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, vector<T> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, initializer_list<U> list) {\n    for (auto &&va :list)v.pb(va);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, initializer_list<U> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\ntemplate<typename T> void insert(set<T> &v, vector<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\ntemplate<typename T> void insert(set<T> &v, initializer_list<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\n\n\n//閉路がなければtrue\nbool topo(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.t]++;\n    queue<int> st;\n    rep(i, n)if (nyu[i] == 0)st.push(i);\n    while (st.size()) {\n        int v = st.front();\n        st.pop();\n        res.pb(v);\n        fora(e, g[v]) if (--nyu[e.t] == 0)st.push(e.t);\n    }\n    return res.size() == n;\n}\n//辞書順最小トポロジカルソート\nbool topos(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.t]++;\n    //小さい順\n    priority_queue<int, vector<int>, greater<int> > q;\n    rep(i, n)if (nyu[i] == 0)q.push(i);\n    while (q.size()) {\n        int i = q.top();\n        q.pop();\n        res.pb(i);\n        fora(e, g[i])if (--nyu[e.t] == 0)q.push(e.t);\n    }\n    return res.size() == n;\n}\nvector<string> split(const string a, const char deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size();\n    vector<string> res;\n    rep(i, n) {\n        if (b[i] == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            l = i + 1;\n        }\n    }\n    return res;\n}\nvector<string> split(const string a, const string deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size(), dn = deli.size();\n    vector<string> res;\n    rep(i, n) {\n        if (i + dn <= n && b.substr(i, i + dn) == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            i += dn - 1;\n            l = i + 1;\n        }\n    }\n    return res;\n}\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\n\nint n, m, k, d, H, W, x, y, z, q;\nint cou;\nvi a, b, c;\nvvi (s, 0, 0);\nvvc (ba, 0, 0);\nvp p;\nstruct Monoid {\n    ll i, v;\n    Monoid(ll i, ll v) : i(i), v(v) {}\n};\n#define segMinl [](Monoid a,Monoid b){return a.v <= b.v ? a : b;} , Monoid(-1,MAX(ll))\n#define segMinr [](Monoid a,Monoid b){return a.v < b.v ? a : b;} , Monoid(-1,MAX(ll))\n#define segMaxl [](Monoid a,Monoid b){return a.v >= b.v ? a : b;} , Monoid(-1,MIN(ll))\n#define segMaxr [](Monoid a,Monoid b){return a.v > b.v ? a : b;} , Monoid(-1,MIN(ll))\n#define segSum  [](Monoid a,Monoid b){return Monoid(a.i+b.i,a.v+b.v);} , Monoid(0,0)\n\nstruct SegmentTree {\n    using func=function<Monoid(Monoid, Monoid)>;\n    int n;\n    vector<Monoid> seg;\n    const func f;\n    const Monoid e;\n    SegmentTree(int len, func f, const Monoid e) : f(f), e(e) {\n        n = 1;\n        while (n < len)n *= 2;\n        seg.assign(2 * n - 1, e);\n    }\n    SegmentTree(vi dat, const func f, const Monoid e) : f(f), e(e) {\n        n = 1;\n        int asz = dat.size();\n        while (n < asz)n *= 2;\n        seg.assign(2 * n - 1, e);\n        rep(i, asz) seg[i + n - 1] = Monoid(i, dat[i]);\n        rer(i, n - 2)seg[i] = f(seg[i * 2 + 1], seg[i * 2 + 2]);\n    }\n    void update(int k, int v) {\n        seg[k + n - 1] = Monoid(k, v);\n        k += n - 1;\n        while (k) {\n            k = (k - 1) / 2;\n            seg[k] = f(seg[k * 2 + 1], seg[k * 2 + 2]);\n        }\n    }\n    void del(int k) {\n        update(k, e.v);\n    }\n    void add(int k, int v) {\n        update(k, v + seg[k + n - 1].v);\n    }\n    Monoid query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l)return e;\n        else if (a <= l && r <= b)return seg[k];\n        else {\n            Monoid sl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n            Monoid sr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n            return f(sl, sr);\n        }\n    }\n    Monoid get(int a = 0, int b = -1) {\n        if (b == -1)b = n;\n        return query(a, b, 0, 0, n);\n    }\n    int geti(int a = 0, int b = -1) {\n        return get(a, b).i;\n    }\n    ll getv(int a = 0, int b = -1) {\n        return get(a, b).v;\n    }\n    int operator()(int a = 0, int b = -1) {\n        return get(a, b).v;\n    }\n    Monoid operator[](int k) const {\n        return seg[k + n - 1];\n    }\n};\n\nvoid solve() {\n    cin >> n >> q;\n    n *= 2;\n    na(a, n);\n    na(b, n);\n    //基本b\n    rep(i, n)c += a[i] - b[i];\n    SegmentTree minu(k5*2, segMaxl);\n    SegmentTree plu(k5*2, segMinl);\n    int pc = 0;\n    int base = 0;\n    int pad = 0;\n    int add = 0;\n    add = a[0] + a[n - 1];\n    rep(i, 1, n - 1) {\n        base += b[i];\n        if (c[i] < 0)minu.update(i, c[i]);\n        else {\n            plu.update(i, c[i]);\n            pc++;\n            pad += c[i];\n        }\n    }\n    while (q--) {\n        din(p, x, y);\n        p--;\n        if (p == 0 || p == n - 1) {\n            add -= a[p];\n            a[p] = x;\n            b[p] = y;\n            add += a[p];\n        } else {\n            base -= b[p];\n            a[p] = x;\n            b[p] = y;\n            base += b[p];\n            int nc = a[p] - b[p];\n            //-に入ってる\n            if (c[p] < 0) {\n                //-から消す\n                if (nc >= 0) {\n                    pad += nc;\n                    plu.update(p, nc);\n                    minu.del(p);\n                    pc++;\n                } else {\n                    minu.update(p, nc);\n                }\n            } else {\n                pad -= c[p];\n                if (nc < 0) {\n                    minu.update(p, nc);\n                    plu.del(p);\n                    pc--;\n                } else {\n                    plu.update(p, nc);\n                    pad += nc;\n                }\n            }\n            c[p] = a[p] - b[p];\n        }\n        if (pc % 2 == 0) {\n            cout << add + pad + base << endl;\n        } else {\n            int res = -linf;\n            //+を一つ消す\n            chma(res, add + pad - plu() + base);\n            //-を一つ取る\n            chma(res, add + pad + minu() + base);\n            cout << res << endl;\n        }\n    }\n\n}\n\nint my(int n, vi a) {\n\n    return 0;\n}\n\nint sister(int n, vi a) {\n\n    return 0;\n}\n\nsigned main() {\n    solve();\n//\n#define _arg n,a\n\n#ifdef _DEBUG\n    bool bad = 0;\n    for (int i = 0, ok = 1; i < k5 && ok; i++) {\n        int n = rand(1, 4);\n        vi a = ranv(m, 1, 10);\n        int myres = my(_arg);\n        int res = sister(_arg);\n        ok = myres == res;\n        if (!ok) {\n            outl(_arg);\n            cout << \"正解 : \" << res << endl;\n            cout << \"自分 : \" << myres << endl;\n            bad = 1;\n            break;\n        }\n    }\n    if (!bad) {\n//        cout << \"完璧です。\" << endl;\n    }\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define llint long long\n#define inf 1e18\n#define rep(x, s, t) for(llint (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(llint (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n#define mod 998244353\nusing namespace std;\ntypedef pair<llint, llint> P;\ntypedef pair<llint, P> E;\n\nllint n, Q;\nllint a[200005], b[200005];\nmultiset<llint> posS, negS;\nllint psum;\n\nllint del(multiset<llint> &S, llint x)\n{\n\tauto it = S.lower_bound(x);\n\tif(it == S.end() || *it != x) return 0;\n\tS.erase(it);\n\treturn x;\n}\n\nllint calc()\n{\n\tif(posS.size() % 2 == 0) return psum;\n\tllint ret = psum - *posS.begin();\n\tret = max(ret, psum + *negS.rbegin());\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> n >> Q;\n\tfor(int i = 1; i <= 2*n; i++) cin >> a[i];\n\tfor(int i = 1; i <= 2*n; i++) cin >> b[i];\n\t\n\tllint ans = 0;\n\tfor(int i = 1; i <= 2*n; i++){\n\t\tans += a[i];\n\t\tif(i > 1 && i < 2*n){\n\t\t\tif(b[i]-a[i] >= 0) posS.insert(b[i]-a[i]), psum += b[i]-a[i];\n\t\t\telse negS.insert(b[i]-a[i]);\n\t\t}\n\t}\n\t\n\tllint p, x, y;\n\tfor(int q = 1; q <= Q; q++){\n\t\tcin >> p >> x >> y;\n\t\tans -= a[p];\n\t\tif(p > 1 && p < 2*n){\n\t\t\tpsum -= del(posS, b[p]-a[p]);\n\t\t\tdel(negS, b[p]-a[p]);\n\t\t}\n\t\ta[p] = x, b[p] = y;\n\t\tans += a[p];\n\t\tif(b[p]-a[p] >= 0) posS.insert(b[p]-a[p]), psum += b[p]-a[p];\n\t\telse negS.insert(b[p]-a[p]);\n\t\t\n\t\tcout << ans + calc() << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef double lf;\ntypedef long double llf;\ntypedef std::pair<int,int> pii;\n\n#define xx first\n#define yy second\n\ntemplate<typename T> inline T max(T a,T b){return a>b?a:b;}\ntemplate<typename T> inline T min(T a,T b){return a<b?a:b;}\ntemplate<typename T> inline T abs(T a){return a>0?a:-a;}\ntemplate<typename T> inline bool repr(T &a,T b){return a<b?a=b,1:0;}\ntemplate<typename T> inline bool repl(T &a,T b){return a>b?a=b,1:0;}\ntemplate<typename T> inline T gcd(T a,T b){T t;if(a<b){while(a){t=a;a=b%a;b=t;}return b;}else{while(b){t=b;b=a%b;a=t;}return a;}}\ntemplate<typename T> inline T sqr(T x){return x*x;}\n#define mp(a,b) std::make_pair(a,b)\n#define pb push_back\n#define I inline\n#define mset(a,b) memset(a,b,sizeof(a))\n#define mcpy(a,b) memcpy(a,b,sizeof(a))\n\n#define fo0(i,n) for(int i=0,i##end=n;i<i##end;i++)\n#define fo1(i,n) for(int i=1,i##end=n;i<=i##end;i++)\n#define fo(i,a,b) for(int i=a,i##end=b;i<=i##end;i++)\n#define fd0(i,n) for(int i=(n)-1;~i;i--)\n#define fd1(i,n) for(int i=n;i;i--)\n#define fd(i,a,b) for(int i=a,i##end=b;i>=i##end;i--)\n#define foe(i,x)for(__typeof(x.end())i=x.begin();i!=x.end();++i)\n\nstruct Cg{I char operator()(){return getchar();}};\nstruct Cp{I void operator()(char x){putchar(x);}};\n#define OP operator\n#define RT return *this;\n#define RX x=0;char t=P();while((t<'0'||t>'9')&&t!='-')t=P();bool f=0;\\\nif(t=='-')t=P(),f=1;x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define RL if(t=='.'){lf u=0.1;for(t=P();t>='0'&&t<='9';t=P(),u*=0.1)x+=u*(t-'0');}if(f)x=-x\n#define RU x=0;char t=P();while(t<'0'||t>'9')t=P();x=t-'0';for(t=P();t>='0'&&t<='9';t=P())x=x*10+t-'0'\n#define TR *this,x;return x;\nI bool IS(char x){return x==10||x==13||x==' ';}template<typename T>struct Fr{T P;I Fr&OP,(int&x)\n{RX;if(f)x=-x;RT}I OP int(){int x;TR}I Fr&OP,(ll &x){RX;if(f)x=-x;RT}I OP ll(){ll x;TR}I Fr&OP,(char&x)\n{for(x=P();IS(x);x=P());RT}I OP char(){char x;TR}I Fr&OP,(char*x){char t=P();for(;IS(t);t=P());if(~t){for(;!IS\n(t)&&~t;t=P())*x++=t;}*x++=0;RT}I Fr&OP,(lf&x){RX;RL;RT}I OP lf(){lf x;TR}I Fr&OP,(llf&x){RX;RL;RT}I OP llf()\n{llf x;TR}I Fr&OP,(uint&x){RU;RT}I OP uint(){uint x;TR}I Fr&OP,(ull&x){RU;RT}I OP ull(){ull x;TR}};Fr<Cg>in;\n#define WI(S) if(x){if(x<0)P('-'),x=-x;char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\n#define WL if(y){lf t=0.5;for(int i=y;i--;)t*=0.1;if(x>=0)x+=t;else x-=t,P('-');*this,(ll)(abs(x));P('.');if(x<0)\\\nx=-x;while(y--){x*=10;x-=floor(x*0.1)*10;P(((int)x)%10+'0');}}else if(x>=0)*this,(ll)(x+0.5);else *this,(ll)(x-0.5);\n#define WU(S) if(x){char s[S],c=0;while(x)s[c++]=x%10+'0',x/=10;while(c--)P(s[c]);}else P('0')\ntemplate<typename T>struct Fw{T P;I Fw&OP,(int x){WI(10);RT}I Fw&OP()(int x){WI(10);RT}I Fw&OP,(uint x){WU(10);RT}\nI Fw&OP()(uint x){WU(10);RT}I Fw&OP,(ll x){WI(19);RT}I Fw&OP()(ll x){WI(19);RT}I Fw&OP,(ull x){WU(20);RT}I Fw&OP()\n(ull x){WU(20);RT}I Fw&OP,(char x){P(x);RT}I Fw&OP()(char x){P(x);RT}I Fw&OP,(const char*x){while(*x)P(*x++);RT}\nI Fw&OP()(const char*x){while(*x)P(*x++);RT}I Fw&OP()(lf x,int y){WL;RT}I Fw&OP()(llf x,int y){WL;RT}};Fw<Cp>out;\n\ntypedef std::pair<ll,ll>pll;\n\nconst int N=200007;\n\npll f[1<<19];\nint n,m,a[N],b[N];\n\ninline void pu(int x)\n{\n\tf[x]=mp(max(f[x<<1].xx+f[x<<1|1].xx,f[x<<1].yy+f[x<<1|1].yy),max(f[x<<1].xx+f[x<<1|1].yy,f[x<<1].yy+f[x<<1|1].xx));\n}\n\ninline void set(int x,int p)\n{\n\tf[x]=mp(b[p],a[p]);\n}\n\ninline void build(int x,int l,int r)\n{\n\tif(l==r)set(x,l);\n\telse\n\t{\n\t\tint t=(l+r)>>1;\n\t\tbuild(x<<1,l,t);\n\t\tbuild(x<<1|1,t+1,r);\n\t\tpu(x);\n\t}\n}\n\ninline void modify(int x,int l,int r,int p)\n{\n\tif(l==r)set(x,l);\n\telse\n\t{\n\t\tint t=(l+r)>>1;\n\t\tif(p<=t)modify(x<<1,l,t,p);\n\t\telse modify(x<<1|1,t+1,r,p);\n\t\tpu(x);\n\t}\n}\n\nint main()\n{\n\tin,n,m;\n\tfo1(i,n*2)in,a[i];\n\tfo1(i,n*2)in,b[i];\n\tbuild(1,2,n*2-1);\n\twhile(m--)\n\t{\n\t\tint p,x,y;\n\t\tin,p,x,y;\n\t\ta[p]=x,b[p]=y;\n\t\tif(p!=1&&p!=n*2)modify(1,2,n*2-1,p);\n\t\tout,f[1].xx+a[1]+a[n*2],'\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  LL N, Q;\n  cin >> N >> Q;\n\n  VL as(N*2), bs(N*2);\n  cin >> as >> bs;\n\n  int par = 0;\n  LL sum = as[0] + as.back();\n  multiset<LL> dels;\n  FOR(i,1,2*N-1){\n    LL mx = max(as[i], bs[i]);\n    LL mn = min(as[i], bs[i]);\n    sum += mx;\n    if(mx == as[i]) par ^= 1;\n    dels.insert(mn - mx);\n  }\n\n  while(Q--){\n    int p, x, y;\n    cin >> p >> x >> y;\n    --p;\n\n    LL mx = max(as[p], bs[p]);\n    LL mn = min(as[p], bs[p]);\n    sum -= mx;\n    if(mx == as[p]) par ^= 1;\n    auto it = dels.find(mn - mx);\n    dels.erase(it);\n\n    as[p] = x;\n    bs[p] = y;\n    LL mx2 = max(as[p], bs[p]);\n    LL mn2 = min(as[p], bs[p]);\n    sum += mx2;\n    if(mx2 == as[p]) par ^= 1;\n    dels.insert(mn2 - mx2);\n\n    LL ans = 0;\n    if(par == 0){\n      ans = sum;\n    }\n    else{\n      ans = sum + *(dels.rbegin());\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(),vec.end()\n#define mp make_pair\nusing namespace std;\nusing ll=long long;\nusing P=pair<ll,ll>;\nconst ll INF=1LL<<30;\nconst ll LINF=1LL<<60;\nconst double eps=1e-5;\nconst ll MOD=1000000007LL;\ntemplate<typename T>void chmin(T &a,T b){a=min(a,b);};\ntemplate<typename T>void chmax(T &a,T b){a=max(a,b);};\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\nint main(){\n    int n,q;cin>>n>>q;n*=2;\n    vector<ll> a(n),b(n);\n    for(int i=0;i<n;i++){\n        cin>>a[i];\n    }\n    multiset<ll> st;\n    int c=0;\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        cin>>b[i];\n        if(i==0||i==n-1){\n            ans+=a[i];\n        }else{\n            st.insert(abs(a[i]-b[i]));\n            ans+=max(a[i],b[i]);\n            if(a[i]>b[i])c^=1;\n        }\n    }\n    while(q--){\n        ll p,x,y;cin>>p>>x>>y;--p;\n        if(p==0||p==n-1){\n            ans+=x-a[p];\n            a[p]=x;\n        }else{\n            if(a[p]>b[p])c^=1;\n            if(x>y)c^=1;\n            ans+=max(x,y)-max(a[p],b[p]);\n            st.erase(st.lower_bound(abs(a[p]-b[p])));\n            st.insert(abs(x-y));\n            a[p]=x,b[p]=y;\n        }\n        if(c){\n            cout<<ans-(*st.begin())<<endl;\n        }else{\n            cout<<ans<<endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<::std::uint_fast64_t mod>\nclass ModInt{\nprivate:\n    using value_type = ::std::uint_fast64_t;\n    value_type n;\npublic:\n    ModInt() : n(0) {}\n    ModInt(value_type n_) : n(n_ % mod) {}\n    ModInt(const ModInt& m) : n(m.n) {}\n\n    template<typename T>\n    explicit operator T() const { return static_cast<T>(n); }\n    value_type get() const { return n; }\n\n    friend ::std::ostream& operator<<(::std::ostream &os, const ModInt<mod> &a) {\n        return os << a.n;\n    }\n\n    friend ::std::istream& operator>>(::std::istream &is, ModInt<mod> &a) {\n        value_type x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return is;\n    }\n\n    bool operator==(const ModInt& m) const { return n == m.n; }\n    bool operator!=(const ModInt& m) const { return n != m.n; }\n    ModInt& operator*=(const ModInt& m){ n = n * m.n % mod; return *this; }\n\n    ModInt pow(value_type b) const{\n        ModInt ans = 1, m = ModInt(*this);\n        while(b){\n            if(b & 1) ans *= m;\n            m *= m;\n            b >>= 1;\n        }\n        return ans;\n    }\n\n    ModInt inv() const { return (*this).pow(mod-2); }\n    ModInt& operator+=(const ModInt& m){ n += m.n; n = (n < mod ? n : n - mod); return *this; }\n    ModInt& operator-=(const ModInt& m){ n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n    ModInt& operator/=(const ModInt& m){ *this *= m.inv(); return *this; }\n    ModInt operator+(const ModInt& m) const { return ModInt(*this) += m; }\n    ModInt operator-(const ModInt& m) const { return ModInt(*this) -= m; }\n    ModInt operator*(const ModInt& m) const { return ModInt(*this) *= m; }\n    ModInt operator/(const ModInt& m) const { return ModInt(*this) /= m; }\n    ModInt& operator++(){ n += 1; return *this; }\n    ModInt& operator--(){ n -= 1; return *this; }\n    ModInt operator++(int){\n        ModInt old(n);\n        n += 1;\n        return old;\n    }\n    ModInt operator--(int){\n        ModInt old(n);\n        n -= 1;\n        return old;\n    }\n    ModInt operator-() const { return ModInt(mod-n); }\n};\n\nclass UnionFind{\nprivate:\n    ::std::vector<int_fast32_t> par;\n    vector<int64> sum;\n    size_t n;\n\npublic:\n    UnionFind(){}\n    UnionFind(size_t n):n(n){\n        par.resize(n, -1);\n        sum.resize(n, 0);\n    }\n\n    void set_sum(const vector<int64>& s) {\n        sum = s;\n    }\n\n    uint_fast32_t find(uint_fast32_t x){\n        return par[x] < 0 ? x : par[x] = find(par[x]);\n    }\n\n    size_t size(uint_fast32_t x){\n        return -par[find(x)];\n    }\n\n    int64 sum_v(int64 x) {\n        return sum[find(x)];\n    }\n\n    bool unite(uint_fast32_t x, uint_fast32_t y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return false;\n        if(size(x) < size(y)) std::swap(x, y);\n        par[x] += par[y];\n        sum[x] += sum[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool same(uint_fast32_t x, uint_fast32_t y){\n        return find(x) == find(y);\n    }\n};\n\n\n\nint main(void) {\n    int64 N, Q;\n    cin >> N >> Q;\n    N*=2;\n    vector<int64> a(N), b(N);\n    REP(i, N) cin >> a[i];\n    REP(i, N) cin >> b[i];\n    multiset<PLL> as, bs;\n    vector<int64> wh(N);\n    int64 res = a[0] + a.back();\n    FOR(i, 1, N-1) {\n        if (a[i] >= b[i]) {\n            as.insert(PLL(a[i]-b[i], i));\n            res += a[i];\n            wh[i] = 0;\n        } else {\n            bs.insert(PLL(b[i]-a[i], i));\n            res += b[i];\n            wh[i] = 1;\n        }\n    }\n    REP(i, Q) {\n//        cout << endl;\n        int64 p, x, y;\n        cin >> p >> x >> y; p--;\n        bool atob = 0, btoa = 0;\n        PLL mv;\n        if (p == 0 || p == N-1) {\n            res -= a[p];\n            a[p] = x; b[p] = y;\n            res += a[p];\n        } else {\n            if (wh[p] == 0) {\n                res -= a[p];\n                as.erase(as.lower_bound(PLL(a[p]-b[p], p)));\n            } else {\n                res -= b[p];\n                bs.erase(bs.lower_bound(PLL(b[p]-a[p], p)));\n            }\n            a[p] = x; b[p] = y;\n            if (a[p] >= b[p]) {\n                res += a[p];\n                wh[p] = 0;\n                as.insert(PLL(a[p]-b[p], p));\n            } else {\n                res += b[p];\n                wh[p] = 1;\n                bs.insert(PLL(b[p]-a[p], p));\n            }\n//            cout << res << endl;\n            if (as.size() % 2) {\n                auto ia = *as.begin(), ib = *bs.begin();\n                if (ia.fs >= ib.fs) {\n                    res -= ib.fs;\n                    wh[ib.sc] = 0;\n                    as.insert(PLL(-ib.fs, ib.sc));\n                    bs.erase(bs.begin());\n                    mv = ib;\n                    mv.fs *= -1;\n                    btoa = 1;\n                } else {\n                    res -= ia.fs;\n                    mv = PLL(-ia.fs, ia.sc);\n                    wh[ia.sc] = 1;\n                    bs.insert(PLL(-ia.fs, ia.sc));\n                    as.erase(as.begin());\n                    atob = 1;\n                }\n            }\n        }\n//        for (auto x : as) {\n//            cout << x.fs << \" \";\n//        }\n//        cout << endl;\n//        for (auto x : bs) {\n//            cout << x.fs << \" \";\n//        }\n//        cout << endl;\n        cout << res << endl;\n        if (atob) {\n            wh[mv.sc] = 0;\n            res -= mv.fs;\n            as.insert(PLL(-mv.fs, mv.sc));\n            bs.erase(mv);\n        } else if (btoa) {\n            wh[mv.sc] = 1;\n            res -= mv.fs;\n            bs.insert(PLL(-mv.fs, mv.sc));\n            as.erase(mv);\n        }\n//        for (auto x : as) {\n//            cout << x.fs << \" \";\n//        }\n//        cout << endl;\n//        for (auto x : bs) {\n//            cout << x.fs << \" \";\n//        }\n//        cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = 1e18;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  n *= 2;\n  vl a(n), b(n);\n  rep (i, n) {\n    cin >> a[i];\n  }\n  rep (i, n) {\n    cin >> b[i];\n  }\n  set<pii> aa, bb;\n  ll ans = 0;\n  rep (i, n) {\n    if (i == 0) {\n      ans += a[i];\n      continue;\n    }\n    if (i == n - 1) {\n      ans += a[i];\n      continue;\n    }\n    if (a[i] >= b[i]) {\n      ans += a[i];\n      aa.insert(pii(a[i] - b[i], i));\n    }\n    else {\n      ans += b[i];\n      bb.insert(pii(b[i] - a[i], i));\n    }\n  }\n  if ((int)aa.size() % 2) {\n    assert(aa.begin()->first >= 0 || bb.begin()->first >= 0);\n    auto itra = aa.begin();\n    auto itrb = bb.begin();\n    pii a_s = *itra, b_s = *itrb;\n    if (a_s.first >= b_s.first) {\n      bb.erase(b_s);\n      int idx = b_s.second;\n      ans -= b[idx];\n      ans += a[idx];\n      aa.insert(pii(a[idx] - b[idx], idx));\n    }\n    else {\n      aa.erase(a_s);\n      int idx = a_s.second;\n      ans -= a[idx];\n      ans += b[idx];\n      bb.insert(pii(b[idx] - a[idx], idx));\n    }\n  }\n  while (q--) {\n    /*\n    cout << \"aa \";\n    for (auto itr = aa.begin(); itr != aa.end(); itr++) {\n      cout << *itr << \" \";\n    }\n    cout << endl;\n    cout << \"bb \";\n    for (auto itr = bb.begin(); itr != bb.end(); itr++) {\n      cout << *itr << \" \";\n    }\n    //*/\n    int p, x, y;\n    cin >> p >> x >> y;\n    p--;\n    if (p == 0 || p == n - 1) {\n      ans -= a[p];\n      a[p] = x;\n      b[p] = y;\n      ans += a[p];\n      cout << ans << endl;\n      continue;\n    }\n    if (aa.count(pii(a[p] - b[p], p))) {\n      aa.erase(pii(a[p] - b[p], p));\n      ans -= a[p];\n    }\n    else if (bb.count(pii(b[p] - a[p], p))) {\n      bb.erase(pii(b[p] - a[p], p));\n      ans -= b[p];\n    }\n    else {\n      assert(false);\n    }\n    a[p] = x;\n    b[p] = y;\n    if (a[p] >= b[p]) {\n      ans += a[p];\n      aa.insert(pii(a[p] - b[p], p));\n    }\n    else {\n      ans += b[p];\n      bb.insert(pii(b[p] - a[p], p));\n    }\n    if ((int)aa.size() % 2) {\n      auto itra = aa.begin();\n      auto itrb = bb.begin();\n      pii a_s = *itra, b_s = *itrb;\n      if (a_s.first >= b_s.first) {\n        bb.erase(b_s);\n        int idx = b_s.second;\n        ans -= b[idx];\n        ans += a[idx];\n        aa.insert(pii(a[idx] - b[idx], idx));\n      }\n      else {\n        aa.erase(a_s);\n        int idx = a_s.second;\n        ans -= a[idx];\n        ans += b[idx];\n        bb.insert(pii(b[idx] - a[idx], idx));\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "//todo 文字数を少なくする\n\n//#pragma GCC optimize (\"-O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\n\n//@必須構造\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    bool operator==(const T &r) const {\n        return f == r.f && s == r.s && t == r.t;\n    }\n    bool operator!=(const T &r) const {\n        return f != r.f || s != r.s || t != r.t;\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\nstruct F {\n    int a, b, c, d;\n    F() { a = -1, b = -1, c = -1, d = -1; }\n    F(int a, int b, int c, int d) : a(a), b(b), c(c), d(d) {}\n    bool operator<(const F &r) const {\n        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;\n//        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;\n    }\n    bool operator>(const F &r) const {\n        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;\n//        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;\n    }\n    bool operator==(const F &r) const {\n        return a == r.a && b == r.b && c == r.c && d == r.d;\n    }\n    bool operator!=(const F &r) const {\n        return a != r.a || b != r.b || c != r.c || d != r.d;\n    }\n    int operator[](int i) {\n        assert(i < 4);\n        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;\n    }\n};\n\nT mt(int a, int b, int c) {\n    return T(a, b, c);\n}\n//@マクロ省略系 型,構造\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec vector\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n\n#define minq 0\n#define maxq 1\n\n//マクロ省略系 コンテナ\n\nusing vi = vector<int>;\n#define _overloadvvi(_1, _2, _3, _4, name, ...) name\n#define vvi0() vec<vi>\n#define vvi1(a) vec<vi> a\n#define vvi2(a, b) vec<vi> a(b)\n#define vvi3(a, b, c) vec<vi> a(b,vi(c))\n#define vvi4(a, b, c, d) vec<vi> a(b,vi(c,d))\n#define vvi(...) _overloadvvi(__VA_ARGS__,vvi4,vvi3,vvi2 ,vvi1,vvi0)(__VA_ARGS__)\n\n\nusing vl = vector<ll>;\n#define _overloadvvl(_1, _2, _3, _4, name, ...) name\n#define vvl1(a) vec<vl> a\n#define vvl2(a, b) vec<vl> a(b)\n#define vvl3(a, b, c) vec<vl> a(b,vl(c))\n#define vvl4(a, b, c, d) vec<vl> a(b,vl(c,d))\n#define vvl(...) _overloadvvl(__VA_ARGS__,vvl4,vvl3,vvl2 ,vvl1)(__VA_ARGS__)\n\nusing vb = vector<bool>;\n#define _overloadvvb(_1, _2, _3, _4, name, ...) name\n#define vvb1(a) vec<vb> a\n#define vvb2(a, b) vec<vb> a(b)\n#define vvb3(a, b, c) vec<vb> a(b,vb(c))\n#define vvb4(a, b, c, d) vec<vb> a(b,vb(c,d))\n#define vvb(...) _overloadvvb(__VA_ARGS__,vvb4,vvb3,vvb2 ,vvb1)(__VA_ARGS__)\n\nusing vs = vector<string>;\n#define _overloadvvs(_1, _2, _3, _4, name, ...) name\n#define vvs1(a) vec<vs> a\n#define vvs2(a, b) vec<vs> a(b)\n#define vvs3(a, b, c) vec<vs> a(b,vs(c))\n#define vvs4(a, b, c, d) vec<vs> a(b,vs(c,d))\n#define vvs(...) _overloadvvs(__VA_ARGS__,vvs4,vvs3,vvs2 ,vvs1)(__VA_ARGS__)\n\nusing vd = vector<double>;\n#define _overloadvvd(_1, _2, _3, _4, name, ...) name\n#define vvd1(a) vec<vd> a\n#define vvd2(a, b) vec<vd> a(b)\n#define vvd3(a, b, c) vec<vd> a(b,vd(c))\n#define vvd4(a, b, c, d) vec<vd> a(b,vd(c,d))\n#define vvd(...) _overloadvvd(__VA_ARGS__,vvd4,vvd3,vvd2 ,vvd1)(__VA_ARGS__)\n\nusing vc=vector<char>;\n#define _overloadvvc(_1, _2, _3, _4, name, ...) name\n#define vvc1(a) vec<vc> a\n#define vvc2(a, b) vec<vc> a(b)\n#define vvc3(a, b, c) vec<vc> a(b,vc(c))\n#define vvc4(a, b, c, d) vec<vc> a(b,vc(c,d))\n#define vvc(...) _overloadvvc(__VA_ARGS__,vvc4,vvc3,vvc2 ,vvc1)(__VA_ARGS__)\n\nusing vp = vector<P>;\n#define _overloadvvp(_1, _2, _3, _4, name, ...) name\n#define vvp1(a) vec<vp> a\n#define vvp2(a, b) vec<vp> a(b)\n#define vvp3(a, b, c) vec<vp> a(b,vp(c))\n#define vvp4(a, b, c, d) vec<vp> a(b,vp(c,d))\n#define vvp(...) _overloadvvp(__VA_ARGS__,vvp4,vvp3,vvp2 ,vvp1)(__VA_ARGS__)\n\nusing vt = vector<T>;\n#define _overloadvvt(_1, _2, _3, _4, name, ...) name\n#define vvt1(a) vec<vt> a\n#define vvt2(a, b) vec<vt> a(b)\n#define vvt3(a, b, c) vec<vt> a(b,vt(c))\n#define vvt4(a, b, c, d) vec<vt> a(b,vt(c,d))\n#define vvt(...) _overloadvvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1)(__VA_ARGS__)\n\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n\n#define _vvi vector<vi>\n#define _vvl vector<vl>\n#define _vvb vector<vb>\n#define _vvs vector<vs>\n#define _vvd vector<vd>\n#define _vvc vector<vc>\n#define _vvp vector<vp>\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n#define vni(name, ...) auto name = make_v<int>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); gi++)\n#define fort(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); gi++)if(t!=p)\n//#define fort(gi, ve) for (int gi = 0, f, t, c;gi<ve.size()&& (gi+= (ve[gi].t==p))< ve.size() && (f = ve[gi].f,t=ve[gi].t, c = ve[gi].c,true); gi++)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> {\n    public:\n        size_t operator()(const std::pair<signed, signed> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n    template<> class hash<std::pair<ll, ll>> {\n    public:\n        //大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断\n        size_t operator()(const std::pair<ll, ll> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n}\nistream &operator>>(istream &iss, P &a) {\n    iss >> a.first >> a.second;\n    return iss;\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\nostream &operator<<(ostream &os, P p) {\n    os << p.fi << \" \" << p.se << endl;\n    return os;\n}\n\nostream &operator<<(ostream &os, T p) {\n    os << p.f << \" \" << p.s << \" \" << p.t;\n    return os;\n}\nostream &operator<<(ostream &os, F p) {\n    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <T> &vec) {\n    for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <vector<T>> &vec) {\n    for (int i = 0; i < vec.size(); i++) {\n        for (int j = 0; j < vec[0].size(); j++) {\n            os << vec[i][j];\n        }\n        os << endl;\n    }\n    return os;\n}\ntemplate<typename V, typename H> void resize(vector<V> &vec, const H head) { vec.resize(head); }\ntemplate<typename V, typename H, typename ... T> void resize(vector<V> &vec, const H &head, const T ... tail) {\n    vec.resize(head);\n    for (auto &v: vec) resize(v, tail...);\n}\ntemplate<typename T, typename _Pr> bool all_of(const vector<T> &vec, _Pr pred) { return std::all_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> bool any_of(const vector<T> &vec, _Pr pred) { return std::any_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> bool none_of(const vector<T> &vec, _Pr pred) { return std::none_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> const typename vector<T>::const_iterator find_if(const vector<T> &vec, _Pr pred) { return std::find_if(vec.begin(), vec.end(), pred); }\ntemplate<typename T> bool contains(const vector<T> &vec, const T &val) { return std::find(vec.begin(), vec.end(), val) != vec.end(); }\ntemplate<typename T, typename _Pr> bool contains_if(const vector<T> &vec, _Pr pred) { return std::find_if(vec.begin(), vec.end(), pred) != vec.end(); }\ntemplate<class T> void replace(vector<T> &a, T key, T v) { replace(a.begin(), a.end(), key, v); }\ntemplate<class T> void replace(str &a, T key, T v) { replace(a.begin(), a.end(), key, v); }\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {\n    vi c = a;\n    vi d = b;\n    sort(all(c));\n    sort(all(d));\n    return includes(all(c), all(d));\n}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\n\ntemplate<class T> T pop(set<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T pop(mset<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(set<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(mset<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ninline void sort(string &a) { sort(a.begin(), a.end()); }\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T, class F> inline void sort(vector<T> &a, F f) { sort(a.begin(), a.end(), [&](T l, T r) { return f(l) < f(r); }); };\nenum ___pcomparator {\n    fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd\n};\ninline void sort(vector<P> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });\n            break;\n        case fisd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });\n            break;\n        case fdsi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });\n            break;\n        case fdsd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });\n            break;\n        case sifi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });\n            break;\n        case sifd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });\n            break;\n        case sdfi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });\n            break;\n        case sdfd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });\n            break;\n    }\n};\ninline void sort(vector<T> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });\n            break;\n        case\n            fisd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });\n            break;\n        case\n            fdsi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });\n            break;\n        case\n            fdsd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });\n            break;\n        case\n            sifi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });\n            break;\n        case\n            sifd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });\n            break;\n        case\n            sdfi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });\n            break;\n        case\n            sdfd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });\n            break;\n    }\n};\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class U, class F> inline void rsort(vector<U> &a, F f) { sort(a.begin(), a.end(), [&](U l, U r) { return f(l) > f(r); }); };\ntemplate<class U> inline void sortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;;\n    }\n};\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, char type) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, type);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void rsortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void rsortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void rsortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    rsort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\n\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {\n    xx = vall;\n}\ntemplate<typename V, typename T>\nvoid fill(vector<V> &vecc, const T vall) {\n    for (auto &&vx: vecc) fill(vx, vall);\n}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {\n    T x;\n    cin >> x;\n    return (x);\n}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\n#define _overloadout(_1, _2, _3, _4, name, ...) name\n#define out1(a) cout<<a<<endl\n#define out2(a, b) cout<<a<<\" \"<< b<<endl\n#define out3(a, b, c) cout<<a<<\" \"<<b<<\" \"<<c<<endl\n#define out4(a, b, c, d) cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl\n#define out(...) _overloadout(__VA_ARGS__,out4,out3,out2,out1)(__VA_ARGS__)\n\n#define _overloadoutl(_1, _2, _3, _4, name, ...) name\n#define outl1(a) cout<<a<<endl\n#define outl2(a, b) cout<<a<<endl;cout<<b<<endl\n#define outl3(a, b, c) cout<<a<<endl;cout<<b<<endl;cout<<c<<endl\n#define outl4(a, b, c, d) cout<<a<<endl;cout<<b<<endl;cout<<c<<endl;cout<<d<<endl\n#define outl(...) _overloadout(__VA_ARGS__,outl4,outl3,outl2,outl1)(__VA_ARGS__)\n\nstring sin() { return _in<string>(); }\nll lin() { return _in<ll>(); }\n#define na(a, n) a.resize(n); rep(i,n) cin >> a[i];\n#define nao(a, n) a.resize(n+1); rep(i,n) cin >> a[i+1];\n#define nad(a, n) a.resize(n); rep(i,n){ cin >> a[i]; a[i]--;}\n#define na2(a, b, n) a.resize(n),b.resize(n);rep(i, n)cin >> a[i] >> b[i];\n#define nao2(a, b, n) a.resize(n+1),b.resize(n+1);rep(i, n)cin >> a[i+1] >> b[i+1];\n#define na2d(a, b, n) a.resize(n),b.resize(n);rep(i, n){cin >> a[i] >> b[i];a[i]--,b[i]--;}\n#define na3(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define na3d(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n){cin >> a[i] >> b[i] >> c[i];a[i]--,b[i]--,c[i]--;}\n#define nt(a, h, w) resize(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rs(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n\n//デバッグ\n#define sp << \" \" <<\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<x << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<x<<\", \"<< debugName(y)<<\" = \"<<y<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<x  << \", \" <<  debugName(y)<<\" = \"<<y <<\", \" debugName(z)<<\" = \"<<z <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<\", \" <<  debugName(b)<<\" = \"<<b<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n\n#ifdef _DEBUG\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#else\n#define deb(...) ;\n#endif\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n//よく使うクラス、構造体\nclass UnionFind {\npublic:\n    vi par, rank, sizes;\n    int n, trees;\n    UnionFind(int n) : n(n), trees(n) {\n        par.resize(n), rank.resize(n), sizes.resize(n);\n        rep(i, n)par[i] = i, sizes[i] = 1;\n    }\n    int root(int x) {\n        if (par[x] == x)return x;\n        else return par[x] = root(par[x]);\n    }\n    int find(int x) { return root(x); }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y)return;\n        if (rank[x] < rank[y])swap(x, y);\n        trees--;\n        par[y] = x;\n        sizes[x] += sizes[y];\n        if (rank[x] == rank[y])rank[x]++;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return sizes[root(x)]; }\n    //順不同 umapなので\n    vec<vi> sets() {\n        vec<vi> res(trees);\n        umap<int, vi> map;\n        rep(i, n) map[root(i)].push_back(i);\n        int i = 0;\n        for (auto &&p:map) {\n            int r = p.fi;\n            res[i].push_back(r);\n            for (auto &&v:p.se) {\n                if (r == v)continue;\n                res[i].push_back(v);\n            }\n            i++;\n        }\n        return res;\n    }\n};\n\nusing bint =__int128;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n    std::ostream::sentry s(dest);\n    if (s) {\n        __uint128_t tmp = value < 0 ? -value : value;\n        char buffer[128];\n        char *d = std::end(buffer);\n        do {\n            --d;\n            *d = \"0123456789\"[tmp % 10];\n            tmp /= 10;\n        } while (tmp != 0);\n        if (value < 0) {\n            --d;\n            *d = '-';\n        }\n        int len = std::end(buffer) - d;\n        if (dest.rdbuf()->sputn(d, len) != len) {\n            dest.setstate(std::ios_base::badbit);\n        }\n    }\n    return dest;\n}\n\n__int128 toi128(string &s) {\n    __int128 ret = 0;\n    for (int i = 0; i < s.length(); i++)\n        if ('0' <= s[i] && s[i] <= '9')\n            ret = 10 * ret + s[i] - '0';\n    return ret;\n}\n\n\ntemplate<typename T> T minv(T a, T m);\n\ntemplate<typename T>\nclass Modular {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;\n\n    constexpr Modular() : value() {}\n    template<typename U>\n    Modular(const U &x) {\n        value = normalize(x);\n    }\n\n    template<typename U>\n    static Type normalize(const U &x) {\n        Type v;\n        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n        else v = static_cast<Type>(x % mod());\n        if (v < 0) v += mod();\n        return v;\n    }\n\n    const Type &operator()() const { return value; }\n    template<typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static Type mod() { return T::value; }\n\n    Modular &operator+=(const Modular &other) {\n        if ((value += other.value) >= mod()) value -= mod();\n        return *this;\n    }\n    Modular &operator-=(const Modular &other) {\n        if ((value -= other.value) < 0) value += mod();\n        return *this;\n    }\n    template<typename U> Modular &operator+=(const U &other) { return *this += Modular(other); }\n    template<typename U> Modular &operator-=(const U &other) { return *this -= Modular(other); }\n    Modular &operator++() { return *this += 1; }\n    Modular &operator--() { return *this -= 1; }\n    Modular operator++(signed) {\n        Modular result(*this);\n        *this += 1;\n        return result;\n    }\n    Modular operator--(signed) {\n        Modular result(*this);\n        *this -= 1;\n        return result;\n    }\n    Modular operator-() const { return Modular(-value); }\n\n    template<typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, signed>::value, Modular>::type &operator*=(const Modular &rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n        asm(\n        \"divl %4; \\n\\t\"\n        : \"=a\" (d), \"=d\" (m)\n        : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n        );\n        value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template<typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &operator*=(const Modular &rhs) {\n        int64_t q = static_cast<int64_t>(static_cast<double>(value) * rhs.value / mod());\n        value = normalize(value * rhs.value - q * mod());\n        return *this;\n    }\n    template<typename U = T>\n    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {\n        value = normalize(value * rhs.value);\n        return *this;\n    }\n\n    Modular &operator/=(const Modular &other) { return *this *= Modular(minv(other.value, mod())); }\n\n    template<typename U>\n    friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);\n\n    template<typename U>\n    friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);\n\n    template<typename U>\n    friend std::istream &operator>>(std::istream &stream, Modular<U> &number);\n\nprivate:\n    Type value;\n};\n\ntemplate<typename T> bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }\ntemplate<typename T, typename U> bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate<typename T, typename U> bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate<typename T> bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\ntemplate<typename T> bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }\n\ntemplate<typename T> Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\ntemplate<typename T, typename U> Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate<typename T, typename U> Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate<typename T> Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate<typename T> Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate<typename T> Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\nconstexpr signed MOD = 1000000007;\nusing mint = Modular<std::integral_constant<decay<decltype(MOD)>::type, MOD>>;\n\nmint com(int n, int r) {\n    const int NUM_ = 1400001;\n    static ll fac[NUM_ + 1], finv[NUM_ + 1], inv[NUM_ + 1];\n    if (fac[0] == 0) {\n        inv[1] = fac[0] = finv[0] = 1;\n        for (int i = 2; i <= NUM_; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n        for (int i = 1; i <= NUM_; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n    if (r < 0 || r > n) return 0;\n    return mint(finv[r] * fac[n] % MOD * finv[n - r]);\n}\nmint ncr(int n, int r) { return com(n, r); }\nmint nhr(int n, int r) { return com(n + r - 1, r); }\n\n\ntemplate<typename T> T minv(T a, T m) {\n    T u = 0, v = 1;\n    while (a != 0) {\n        T t = m / a;\n        m -= t * a;\n        swap(a, m);\n        u -= t * v;\n        swap(u, v);\n    }\n    assert(m == 1);\n    return u;\n}\n\ntemplate<typename T, typename U> Modular<T> mpow(const Modular<T> &a, const U &b) {\n    assert(b >= 0);\n    int x = a(), res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) (res *= x) %= MOD;\n        (x *= x) %= MOD;\n        p >>= 1;\n    }\n    return res;\n}\ntemplate<typename T, typename U> Modular<T> mpow(const T &a, const U &b) {\n    assert(b >= 0);\n    int x = a, res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) (res *= x) %= MOD;\n        (x *= x) %= MOD;\n        p >>= 1;\n    }\n    return res;\n}\ntemplate<typename T> string to_string(const Modular<T> &number) {\n    return to_string(number());\n}\n\ntemplate<typename T> std::ostream &operator<<(std::ostream &stream, const Modular<T> &number) {\n    return stream << number();\n}\n\ntemplate<typename T> std::istream &operator>>(std::istream &stream, Modular<T> &number) {\n    typename common_type<typename Modular<T>::Type, int64_t>::type x;\n    stream >> x;\n    number.value = Modular<T>::normalize(x);\n    return stream;\n}\n\nusing PM = pair<mint, mint>;\nusing vm = vector<mint>;\n#define _overloadvvm(_1, _2, _3, _4, name, ...) name\n\n\n#define vvm1(a) vec<vm> a\n#define vvm2(a, b) vec<vm> a(b)\n#define vvm3(a, b, c) vec<vm> a(b,vm(c))\n#define vvm4(a, b, c, d) vec<vm> a(b,vm(c,d))\n#define vvm(...) _overloadvvm(__VA_ARGS__,vvm4,vvm3,vvm2 ,vvm1)(__VA_ARGS__)\n\nvb isPrime;\nvi primes;\n\nvoid setPrime() {\n    int len = 4010101;\n    isPrime.resize(4010101);\n    fill(isPrime, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i <= sqrt(len) + 5; ++i) {\n        if (!isPrime[i])continue;\n        for (int j = 2; i * j < len; ++j) {\n            isPrime[i * j] = false;\n        }\n    }\n    rep(i, len)if (isPrime[i])primes.pb(i);\n}\n//幾何 Pをcomplexとして扱う\nbool eq(double a, double b) { return fabs(a - b) < eps; }\nusing C =complex<double>;\nC rot(C &a, dou th) { return a * C(cos(th), sin(th)); }\ndou inpro(C &a, C &b) { return real(a * conj(b)); }\n\n//90度回転させて内積が0なら平行\nbool line(C a, C b, C c) {\n    C ab = b - a;\n    C ac = c - a;\n    //複素数の掛け算は回転\n    ab *= C(0, 1);\n    return eq(inpro(ab, ac), 0);\n}\nbool line(P a, P b, P c) { return line(C(a.fi, a.se), C(b.fi, b.se), C(c.fi, c.se)); }\n\nbool line(int xa, int ya, int xb, int yb, int xc, int yc) {\n    C a = C(xa, ya);\n    C b = C(xb, yb);\n    C c = C(xc, yc);\n    return line(a, b, c);\n}\n//便利関数\n\n//テスト用\nchar ranc() {\n    return (char) ('a' + rand() % 26);\n}\nint rand(int min, int max) {\n    assert(min <= max);\n    if (min >= 0 && max >= 0) {\n        return rand() % (max + 1 - min) + min;\n    } else if (max < 0) {\n        return -rand(-max, -min);\n    } else {\n        //+\n        if (rand() % 2) {\n            return rand(0, max);\n            //-\n        } else {\n            return -rand(0, -min);\n        }\n    }\n}\nvi ranv(int n, int min, int max) {\n    vi v(n);\n    rep(i, n)v[i] = rand(min, max);\n    return v;\n}\n//単調増加\nvi ranvi(int n, int min, int max) {\n    vi v(n);\n    bool bad = 1;\n    while (bad) {\n        bad = 0;\n        v.resize(n);\n        rep(i, n) {\n            if (i && min > max - v[i - 1]) {\n                bad = 1;\n                break;\n            }\n            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]);\n            else v[i] = rand(min, max);\n        }\n    }\n    return v;\n}\nvoid ranvlr(int n, int min, int max, vi &l, vi &r) {\n    l.resize(n);\n    r.resize(n);\n    rep(i, n) {\n        l[i] = rand(min, max);\n        r[i] = l[i] + rand(0, max - l[i]);\n    }\n}\n//便利 汎用\n//strを整数として比較\nstring smax(str &a, str b) {\n    if (sz(a) < sz(b)) {\n        return b;\n    } else if (sz(a) > sz(b)) {\n        return a;\n    } else {\n        rep(i, sz(a)) {\n            if (a[i] < b[i]) {\n                return b;\n            } else if (a[i] > b[i])return a;\n        }\n    }\n    return a;\n}\n//strを整数として比較\nstring smin(str &a, str b) {\n    if (sz(a) < sz(b)) {\n        return a;\n    } else if (sz(a) > sz(b)) {\n        return b;\n    } else {\n        rep(i, sz(a)) {\n            if (a[i] < b[i]) {\n                return a;\n            } else if (a[i] > b[i])return b;\n        }\n    }\n    return a;\n}\ntemplate<typename V, typename T> int find(vector<V> &a, const T key) {\n    rep(i, sz(a))if (a[i] == key)return i;\n    return -1;\n}\ntemplate<typename V, typename T> P find(vector<vector<V>> &a, const T key) {\n    rep(i, sz(a)) rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);\n    return mp(-1, -1);\n}\ntemplate<typename V, typename U> T find(vector<vector<vector<V>>> &a, const U key) {\n    rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);\n    return mt(-1, -1, -1);\n}\n\ntemplate<typename V, typename T> int count(V &a, const T k) { return a == k; }\ntemplate<typename V, typename T> int count(vector<V> &a, const T k) {\n    int ret = 0;\n    fora(v, a)ret += count(v, k);\n    return ret;\n}\ntemplate<typename V> int count_odd(V &a) { return a % 2; }\ntemplate<typename V> int count_odd(vector<V> &a) {\n    int ret = 0;\n    fora(v, a)ret += count_odd(v);\n    return ret;\n}\ntemplate<typename V> int count_even(V &a) { return a % 2 == 0; }\ntemplate<typename V> int count_even(vector<V> &a) {\n    int ret = 0;\n    fora(v, a)ret += count_even(v);\n    return ret;\n}\n//algorythm\nvoid iota(vector<int> &ve, int s, int n) {\n    ve.resize(n);\n    iota(all(ve), s);\n}\nvi iota(int s, int n) {\n    vi ve(n);\n    iota(all(ve), s);\n    return ve;\n}\n//便利 数学\nint mod(int a, int m) { return (a % m + m) % m; }\nint pow(int a) { return a * a; };\nll fact(int v) { return v <= 1 ? 1 : v * fact(v - 1); }\nll comi(int n, int r) {\n    assert(n < 100);\n    static vvi(pas, 100, 100);\n    if (pas[0][0])return pas[n][r];\n    pas[0][0] = 1;\n    rep(i, 1, 100) {\n        pas[i][0] = 1;\n        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];\n    }\n    return pas[n][r];\n}\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");\n    exit(0);\n#endif\n    string a = \"a\";\n    rep(i, 30)a += a;\n    rep(i, 1 << 17)cout << a << endl;\n    cout << \"OLE 出力長制限超過\" << endl;\n    exit(0);\n}\nvoid tle() { while (inf)cout << inf << endl; }\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll gcd(vi b) {\n    ll res = b[0];\n    for (auto &&v :b)res = gcd(v, res);\n    return res;\n}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll rev(ll a) {\n    ll res = 0;\n    while (a) {\n        res *= 10;\n        res += a % 10;\n        a /= 10;\n    }\n    return res;\n}\ntemplate<class T> void rev(vector<T> &a) {\n    reverse(all(a));\n}\nvoid rev(string &a) {\n    reverse(all(a));\n}\nll ceil(ll a, ll b) {\n    if (b == 0) {\n        debugline(\"ceil\");\n        deb(a, b);\n        ole();\n        return -1;\n    } else if (a < 0) {\n        return 0;\n    } else {\n        return (a + b - 1) / b;\n    }\n}\nll sqrt(ll a) {\n    if (a < 0) {\n        debugline(\"sqrt\");\n        deb(a);\n        ole();\n    }\n    ll res = (ll) std::sqrt(a);\n    while (res * res < a)res++;\n    return res;\n}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {\n    vi res;\n    double lim = std::sqrt(v);\n    for (int i = 1; i <= lim; ++i) {\n        if (v % i == 0) {\n            res.pb(i);\n            if (i != v / i)res.pb(v / i);\n        }\n    }\n    return res;\n}\n\nvi factorization(int v) {\n    int tv = v;\n    vi res;\n    if (isPrime.size() == 0)setPrime();\n    for (auto &&p :primes) {\n        if (v % p == 0)res.push_back(p);\n        while (v % p == 0) {\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res.pb(v);\n    return res;\n}\n\nunordered_map<int, int> factorizationMap(int v) {\n    int tv = v;\n    unordered_map<int, int> res;\n    if (isPrime.size() == 0)setPrime();\n    for (auto &&p :primes) {\n        while (v % p == 0) {\n            res[p]++;\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res[v]++;\n    return res;\n}\nint get(int a, int keta) { return (a / (int) pow(10, keta)) % 10; }\nint keta(int v) {\n    int cou = 0;\n    while (v) { cou++, v %= 10; }\n    return cou;\n}\nint dsum(int v) {\n    int ret = 0;\n    for (; v; v /= 10)ret += v % 10;\n    return ret;\n}\nint sumd(int v) { return dsum(v); }\n//変換系\ntemplate<class T, class U> vector<T> keys(vector<pair<T, U>> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\ntemplate<class T, class U> vector<U> keys(map<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\n\ntemplate<class T, class U> vector<U> keys(umap<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\n\ntemplate<class T, class U> vector<U> values(vector<pair<T, U>> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(map<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(umap<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\nvi list(int a) {\n    vi res;\n    while (a) {\n        res.insert(res.begin(), a % 10);\n        a /= 10;\n    }\n    return res;\n}\n\ntemplate<class T, class U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> bool chmax(const U &b) { return chmax(ma, b); }\ntemplate<class T, class U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> bool chmin(const U &b) { return chmin(mi, b); }\n#define chmi chmin\n#define chma chmax\ntemplate<class T> T min(T a, signed b) { return a < b ? a : b; }\ntemplate<class T> T max(T a, signed b) { return a < b ? b : a; }\ntemplate<class T> T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T> T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T> T min(vector<T> a) { return *min_element(all(a)); }\ntemplate<class T> T min(vector<T> a, int n) { return *min_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T> T min(vector<T> a, int s, int n) { return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T> T max(vector<T> a) { return *max_element(all(a)); }\ntemplate<class T> T max(vector<T> a, int n) { return *max_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T> T max(vector<T> a, int s, int n) { return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<typename A, size_t N> A max(A (&a)[N]) {\n    A res = a[0];\n    rep(i, N)res = max(res, a[i]);\n    return res;\n}\ntemplate<typename A, size_t N, size_t O> A max(A (&a)[N][O]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P> A max(A (&a)[N][O][P]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q> A max(A (&a)[N][O][P][Q], const T &v) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A max(A (&a)[N][O][P][Q][R]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A max(A (&a)[N][O][P][Q][R][S]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N> A min(A (&a)[N]) {\n    A res = a[0];\n    rep(i, N)res = min(res, a[i]);\n    return res;\n}\ntemplate<typename A, size_t N, size_t O> A min(A (&a)[N][O]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P> A min(A (&a)[N][O][P]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q> A min(A (&a)[N][O][P][Q], const T &v) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A min(A (&a)[N][O][P][Q][R]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A min(A (&a)[N][O][P][Q][R][S]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\n\n\ntemplate<class T> T sum(vector<T> v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 0;\n    chmin(len, v.size());\n    rep(i, len)res += v[i];\n    return res;\n}\ntemplate<class T> T sum(vector<vector<T>> &v, int h = -1, int w = -1) {\n    if (h == -1)h = v.size();\n    if (w == -1)w = v[0].size();\n    T res = 0;\n    chmin(h, v.size());\n    chmin(w, v[0].size());\n    rep(i, h)rep(j, w)res += v[i][j];\n    return res;\n}\n\nP sump(vp &v, int len = -1) {\n    if (len == -1)len = v.size();\n    P res = {0, 0};\n    chmin(len, v.size());\n    rep(i, len) {\n        res.fi += v[i].fi;\n        res.se += v[i].se;\n    }\n    return res;\n}\n\n///要素が0の時、返り値は0か1か\ntemplate<class T> T mul(vector<T> &v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 1;\n    chmin(len, v.size());\n    rep(i, len)res *= v[i];\n    return res;\n}\nvoid clear(PQ &q) { while (q.size())q.pop(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(int size) {\n    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));\n    return body + size;\n}\ntemplate<class T> T *negarr2(int h, int w) {\n    double **dummy1 = new double *[2 * h + 1];\n    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];\n    dummy1[0] = dummy2 + w;\n    for (int i = 1; i <= 2 * h + 1; i++) {\n        dummy1[i] = dummy1[i - 1] + 2 * w + 1;\n    }\n    double **a = dummy1 + h;\n}\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {\n    vector<T> ret = v;\n    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];\n    return ret;\n}\ntemplate<class T> vector<T> imomi(vector<T> &v) {\n    vector<T> ret = v;\n    rep(i, sz(ret) - 1)chmin(ret[i + 1], ret[i]);\n    return ret;\n}\ntemplate<class T> struct ruiC {\n    const vector<T> rui;\n    ruiC(vector<T> &ru) : rui(ru) {}\n    T operator()(int l, int r) {\n        assert(l <= r);\n        return rui[r] - rui[l];\n    }\n    T operator[](int i) {\n        return rui[i];\n    }\n};\n\ntemplate<class T> struct rruic {\n    const T *rrui;\n    rruic(T *ru) : rrui(ru) {}\n    //n-1から-1へ\n    T operator()(int l, int r) {\n        assert(l >= r);\n        return rrui[r] - rrui[l];\n    }\n    T operator[](int i) {\n        return rrui[i];\n    }\n};\ntemplate<class T> vector<T> ruiv(vector<T> &a) {\n    vector<T> ret(a.size() + 1);\n    rep(i, a.size())ret[i + 1] = ret[i] + a[i];\n    return ret;\n}\ntemplate<class T> ruiC<T> ruic(vector<T> &a) {\n    vector<T> ret = ruiv(a);\n    return ruiC<T>(ret);\n}\n//xor\ntemplate<class T> vector<T> ruix(vector<T> &a) {\n    vector<T> ret(a.size() + 1);\n    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];\n    return ret;\n}\ntemplate<class T> vector<T> ruim(vector<T> &a) {\n    vector<T> res(a.size() + 1, 1);\n    rep(i, a.size())res[i + 1] = res[i] * a[i];\n    return res;\n}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> rruic<T> rrui(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    rer(i, len - 1)res[i - 1] = res[i] + a[i];\n    return rruic<T>(res);\n}\n//掛け算\ntemplate<class T> T *rruim(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    res[len - 1] = 1;\n    rer(i, len - 1)res[i - 1] = res[i] * a[i];\n    return res;\n}\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void inc(vector<T> &a, U v = 1) { for (auto &u :a)inc(u, v); }\ntemplate<class T> void inc(vector<T> &a) { for (auto &u :a)inc(u, 1); }\ntemplate<class T, class U> void plus(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void plus(vector<T> &a, U v = 1) { for (auto &u :a)inc(u, v); }\ntemplate<class T> void plus(vector<T> &a) { for (auto &u :a)inc(u, 1); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T> void dec(vector<T> &a) { for (auto &u :a)dec(u, 1); }\ntemplate<class T, class U> void minu(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void minu(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T> void minu(vector<T> &a) { for (auto &u :a)dec(u, 1); }\ninline bool inside(int h, int w, int H, int W) { return h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { return l <= v && v < r; }\n#define ins inside\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {\n    vector<T> ret = a;\n    fora(v, ret)v = u(v);\n    return ret;\n}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\nll goldd(ll left, ll right, function<ll(ll)> calc) {\n    double GRATIO = 1.6180339887498948482045868343656;\n    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n    ll fl = calc(lm);\n    ll fr = calc(rm);\n    while (right - left > 10) {\n        if (fl < fr) {\n            right = rm;\n            rm = lm;\n            fr = fl;\n            lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n            fl = calc(lm);\n        } else {\n            left = lm;\n            lm = rm;\n            fl = fr;\n            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n            fr = calc(rm);\n        }\n    }\n    ll minScore = MAX(ll);\n    ll resIndex = left;\n    for (ll i = left; i < right + 1; i++) {\n        ll score = calc(i);\n        if (minScore > score) {\n            minScore = score;\n            resIndex = i;\n        }\n    }\n    return resIndex;\n}\nll goldt(ll left, ll right, function<ll(ll)> calc) {\n    double GRATIO = 1.6180339887498948482045868343656;\n    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n    ll fl = calc(lm);\n    ll fr = calc(rm);\n    while (right - left > 10) {\n        if (fl > fr) {\n            right = rm;\n            rm = lm;\n            fr = fl;\n            lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n            fl = calc(lm);\n        } else {\n            left = lm;\n            lm = rm;\n            fl = fr;\n            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n            fr = calc(rm);\n        }\n    }\n    if (left > right) {\n        ll l = left;\n        left = right;\n        right = l;\n    }\n    ll maxScore = MIN(ll);\n    ll resIndex = left;\n    for (ll i = left; i < right + 1; i++) {\n        ll score = calc(i);\n        if (maxScore < score) {\n            maxScore = score;\n            resIndex = i;\n        }\n    }\n    return resIndex;\n}\ntemplate<class T> T min(vector<vector<T>> &a) {\n    T res = MAX(T);\n    rep(i, a.size())chmin(res, *min_element(all(a[i])));\n    return res;\n}\ntemplate<class T> T max(vector<vector<T>> &a) {\n    T res = MIN(T);\n    rep(i, a.size())chmax(res, *max_element(all(a[i])));\n    return res;\n}\n\nbool bget(ll m, int keta) { return (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {\n    m /= (ll) pow(sinsuu, keta);\n    return m % sinsuu;\n}\ninline ll bit(int n) { return (1LL << (n)); }\ninline ll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\n//int bcou(ll m) { return __builtin_popcount(m & 0xFFFFFFFF) + __builtin_popcount(m >> 32); }\n#define bcou __builtin_popcountll\n//最下位ビット\nint lbit(int n) {\n    return n & -n;\n}\n//最上位ビット\nint hbit(int n) {\n    n |= (n >> 1);\n    n |= (n >> 2);\n    n |= (n >> 4);\n    n |= (n >> 8);\n    n |= (n >> 16);\n    n |= (n >> 32);\n    return n - (n >> 1);\n}\n//初期化は0を渡す\nll nextComb(ll &mask, int n, int r) {\n    if (!mask)return mask = (1LL << r) - 1;\n    ll x = mask & -mask; //最下位の1\n    ll y = mask + x; //連続した下の1を繰り上がらせる\n    ll res = ((mask & ~y) / x >> 1) | y;\n    if (bget(res, n))return mask = 0;\n    else return mask = res;\n}\n\n//n桁以下でビットがr個立っているもののvectorを返す\nvl bitCombList(int n, int r) {\n    vl res;\n    int m = 0;\n    while (nextComb(m, n, r)) {\n        res.pb(m);\n    }\n    return res;\n}\n//大文字小文字を区別する\nint altoiaZ(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a' + 26;\n}\nchar itoalaZ(int i) {\n    if (i < 26)return 'A' + i;\n    return 'a' + i - 26;\n}\n//aもAも0を返す 基本小文字\nint altoi(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a';\n}\nchar itoal(int i) {\n    return 'a' + i;\n}\nint ctoi(char c) { return c - '0'; }\nchar itoc(int i) { return i + '0'; }\nint vtoi(vi &v) {\n    int res = 0;\n    if (sz(v) > 18) {\n        debugline(\"vtoi\");\n        deb(sz(v));\n        ole();\n    }\n    rep(i, sz(v)) {\n        res *= 10;\n        res += v[i];\n    }\n    return res;\n}\nvi itov(int i) {\n    vi res;\n    while (i) {\n        res.pb(i % 10);\n        i /= 10;\n    }\n    rev(res);\n    return res;\n}\nvector<vector<int>> ctoi(vector<vector<char>> s, char c) {\n    int n = sz(s), m = sz(s[0]);\n    vector<vector<int>> res(n, vector<int>(m));\n    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;\n    return res;\n}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\nvoid compress(vi &a) {\n    vi b;\n    int len = a.size();\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    unique(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n\nvoid compress(int a[], int len) {\n    vi b;\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    unique(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define lowerBound(a, v) (*lower_bound(all(a),v))\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define upperBound(a, v) (*upper_bound(all(a),v))\n#define ans(a) cout<<a<<endl;continue;\n#define poll(a) q.front();q.pop()\n#define dpoll(a) q.front();q.pop_front()\n#define pollLast(a) q.back();q.pop_back()\n#define pollBack(a) q.back();q.pop_back()\ntemplate<class T> inline void fin(T s) { cout << s << endl, exit(0); }\n\ntemplate<class T> struct edge {\n    int f, t;\n    T c;\n    int id;\n    int type;\n    edge(int f, int t, T c = 1, int id = -1, int ty = -1) : f(f), t(t), c(c), id(id), type(ty) {}\n    bool operator<(const edge &b) const { return c < b.c; }\n    bool operator>(const edge &b) const { return c > b.c; }\n};\ntemplate<class T> ostream &operator<<(ostream &os, edge<T> &e) {\n    os << e.f << \" \" << e.t << \" \" << e.c;\n    return os;\n}\ntemplate<typename T> class graph {\nprotected:\n    vector<bool> _used;\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n;\n    graph(int n) : n(n) { g.resize(n), _used.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {\n        this->n = n;\n        g.resize(n);\n        _used.resize(n);\n    }\n    int size() { return g.size(); }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int f, int t, T c, int id, int ty) = 0;\n    virtual bool used(edge<T> &e) = 0;\n    virtual bool used(int id) = 0;\n    virtual void del(edge<T> &e) = 0;\n    virtual void del(int id) = 0;\n    virtual void set_edges() = 0;\n};\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    int eid = 0;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"digraph add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        if (id == -1)id = eid++;\n        g[f].emplace_back(f, t, c, id, ty);\n//        edges.emplace_back(f, t, c, id, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n    void set_edges() {\n        rep(i, n)fora(e, g[i])edges.pb(e);\n    }\n};\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    int eid = 0;\n    undigraph(int n) : graph<T>(n) {\n    }\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"undigraph add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        if (id == -1)id = eid, eid += 2;\n        g[f].emplace_back(f, t, c, id, ty);\n        g[t].emplace_back(t, f, c, id + 1, ty);\n//        edges.emplace_back(f, t, c, id, ty);\n//        edges.emplace_back(t, f, c, id + 1, ty);\n    }\n    void add(edge<T> &e) {\n        int f = e.f, t = e.t, ty = e.type;\n        T c = e.c;\n        add(f, t, c, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n    void set_edges() {\n        rep(i, n)fora(e, g[i])edges.pb(e);\n    }\n};\ntemplate<class T> vector<T> dijkstra(const graph<T> &g, int s, int cant_arrive = -1) {\n    if (!(0 <= s && s < g.n)) {\n        debugline(\"dijkstra\");\n        deb(s, g.n);\n        ole();\n    }\n    T initValue = MAX(T);\n    vector<T> dis(g.n, initValue);\n    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;\n    dis[s] = 0;\n    q.emplace(0, s);\n    while (q.size()) {\n        T nowc = q.top().fi;\n        int i = q.top().se;\n        q.pop();\n        if (dis[i] != nowc)continue;\n        for (auto &&e  : g.g[i]) {\n            int to = e.t;\n            T c = nowc + e.c;\n            if (dis[to] > c) {\n                dis[to] = c;\n                q.emplace(dis[to], to);\n            }\n        }\n    }\n    //基本、たどり着かないなら-1\n    if (cant_arrive == -1)for (auto &&d :dis) if (d == initValue)d = -1;\n    return dis;\n}\ntemplate<class T> vector<vector<T>> warshall(const graph<T> &g, int cant_arrive = -1) {\n    int n = g.n;\n    vector<vector<T> > dis(n, vector<T>(n, linf));\n    rep(i, n)fora(e, g.g[i])chmin(dis[e.f][e.t], e.c);\n    rep(i, n)dis[i][i] = 0;\n    rep(k, n)rep(i, n)rep(j, n)chmin(dis[i][j], dis[i][k] + dis[k][j]);\n    //基本、たどり着かないなら-1\n    if (cant_arrive == -1)rep(i, n)rep(j, n) if (dis[i][j] == linf)dis[i][j] = -1;\n    return dis;\n}\n\ntemplate<class T=int> class tree : public undigraph<T> {\npublic:\n    using undigraph<T>::g;\n    using undigraph<T>::n;\n    using undigraph<T>::edges;\n    using undigraph<T>::_used;\n    vi dep;\n    vi disv;\nprivate:\n    bool never = 1;\n    int root = -1;\n    vector<vector<int>> par;\n    bool costallone;\n    void dfs(int v, int p, int d) {\n        dep[v] = d;\n        par[0][v] = p;\n        int lim = (*this)[v].size();\n        for (int i = 0; i < lim; i++) {\n            int t = g[v][i].t;\n            if (t == p)con;\n            dfs(t, v, d + 1);\n        }\n    }\n    void built() {\n        never = 0;\n        n = g.size();\n        par.assign(30, vi(n));\n        dep.resize(n);\n        costallone = 1;\n        rep(i, n)fora(e, g[i])if (e.c != 1)costallone = 0;\n        dfs(root, -1, 0);\n        rep(k, par.size() - 1) {\n            rep(i, n) {\n                if (par[k][i] == -1)par[k + 1][i] = -1;\n                else par[k + 1][i] = par[k][par[k][i]];\n            }\n        }\n        if (costallone)disv = dep;\n        else disv = dijkstra(*this, root);\n    }\n    int _lca(int u, int v) {\n        if (dep[u] > dep[v])swap(u, v);\n        rep(k, par.size()) {\n            if ((dep[u] - dep[v]) >> k & 1) {\n                v = par[k][v];\n            }\n        }\n        if (u == v)return u;\n        rer(k, par.size() - 1) {\n            if (par[k][u] != par[k][v]) {\n                u = par[k][u];\n                v = par[k][v];\n            }\n        }\n        return par[0][u];\n    }\n    int _dis(int u, int v) {\n        int p = _lca(u, v);\n        return disv[u] + disv[v] - disv[p] * 2;\n    }\npublic:\n    tree(int n, int root = 0) : undigraph<T>(n), root(root) {}\n    bool leaf(int v) {\n        return sz(g[v]) == 1 && v != root;\n    }\n    int dis(int u, int v) {\n        if (never) {\n            built();\n        }\n        return _dis(u, v);\n    }\n    int lca(int u, int v) {\n        if (never) {\n            built();\n        }\n        return _lca(u, v);\n    }\n};\n//辺によりメモリを大量消費\n// よってedgesを消している\n//頂点10^6でメモリを190MB(制限の8割)使う\n\n//軽量化のため、辺を持たないbig gridクラスがあってもいいかもしれない\n//\ntemplate<class T=int> class grid_k6 : public undigraph<T> {\npublic:\n    using undigraph<T>::g;\n    using undigraph<T>::n;\n    using undigraph<T>::edges;\n    using undigraph<T>::_used;\n    int H, W;\n    int eid = 0;\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"grid_k6 add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        g[f].emplace_back(f, t, c, eid++, ty);\n        g[t].emplace_back(t, f, c, eid++, ty);\n    }\n    int getid(int h, int w) {\n        if (!inside(h, w, H, W))return -1;\n        return W * h + w;\n    }\n    P get2(int id) {\n        return mp(id / W, id % W);\n    }\n    P operator()(int id) {\n        return get2(id);\n    }\n    int operator()(int h, int w) {\n        return getid(h, w);\n    }\n    grid_k6(int H, int W) : H(H), W(W), undigraph<T>(H * W) {\n        rep(h, H) {\n            rep(w, W) {\n                int f = getid(h, w);\n                if (w + 1 < W) add(f, getid(h, w + 1));\n                if (h + 1 < H)add(f, getid(h + 1, w));\n            }\n        }\n    }\n    grid_k6(_vvc ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), undigraph<T>(sz(ba) * sz(ba[0])) {\n        rep(h, H) {\n            rep(w, W) {\n                if (ba[h][w] == wall)con;\n                int f = getid(h, w);\n                if (w + 1 < W && ba[h][w + 1] != wall) {\n                    add(f, getid(h, w + 1));\n                }\n                if (h + 1 < H && ba[h + 1][w] != wall) {\n                    add(f, getid(h + 1, w));\n                }\n            }\n        }\n    }\n    void add(int fh, int fw, int th, int tw) {\n        add(getid(fh, fw), getid(th, tw));\n    }\n    void set_edges() {\n        rep(i, n)fora(e, g[i])edges.pb(e);\n    }\n};\n//左上から右下に移動できる\ntemplate<class T=int> class digrid_k6 : public digraph<T> {\npublic:\n    using digraph<T>::g;\n    using digraph<T>::n;\n    using digraph<T>::edges;\n    using digraph<T>::_used;\n    int H, W;\n    int eid = 0;\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"digrid_k6 add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        g[f].emplace_back(f, t, c, eid++, ty);\n    }\n    int getid(int h, int w) {\n        if (!inside(h, w, H, W))return -1;\n        return W * h + w;\n    }\n    P get2(int id) {\n        return mp(id / W, id % W);\n    }\n    P operator()(int id) {\n        return get2(id);\n    }\n    int operator()(int h, int w) {\n        return getid(h, w);\n    }\n    digrid_k6(int H, int W) : H(H), W(W), digraph<T>(H * W) {\n        rep(h, H) {\n            rep(w, W) {\n                int f = getid(h, w);\n                if (w + 1 < W) add(f, getid(h, w + 1));\n                if (h + 1 < H)add(f, getid(h + 1, w));\n            }\n        }\n    }\n    digrid_k6(_vvc ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), digraph<T>(sz(ba) * sz(ba[0])) {\n        rep(h, H) {\n            rep(w, W) {\n                if (ba[h][w] == wall)con;\n                int f = getid(h, w);\n                if (w + 1 < W && ba[h][w + 1] != wall) {\n                    add(f, getid(h, w + 1));\n                }\n                if (h + 1 < H && ba[h + 1][w] != wall) {\n                    add(f, getid(h + 1, w));\n                }\n            }\n        }\n    }\n    void add(int fh, int fw, int th, int tw) {\n        add(getid(fh, fw), getid(th, tw));\n    }\n    void set_edges() {\n        rep(i, n)fora(e, g[i])edges.pb(e);\n    }\n};\ntemplate<class T> bool nibu(const graph<T> &g) {\n    int size = 0;\n    rep(i, g.n)size += sz(g.g[i]);\n    if (size == 0)return true;\n\n    UnionFind uf(g.n * 2);\n    rep(i, g.n)fora(e, g.g[i])uf.unite(e.f, e.t + g.n), uf.unite(e.f + g.n, e.t);\n    rep(i, g.n)if (uf.same(i, i + g.n))return 0;\n    return 1;\n}\n//二部グラフを色分けした際の頂点数を返す\ntemplate<class T> vp nibug(graph<T> &g) {\n    vp cg;\n    if (!nibu(g)) {\n        debugline(\"nibu\");\n        ole();\n    }\n    int _n = g.size();\n    vb _was(_n);\n    queue<P> q;\n    rep(i, _n) {\n        if (_was[i])continue;\n        q.push(mp(i, 1));\n        _was[i] = 1;\n        int red = 0;\n        int coun = 0;\n        while (q.size()) {\n            int now = q.front().fi;\n            int col = q.front().se;\n            red += col;\n            coun++;\n            q.pop();\n            forg(gi, g[now]) {\n                if (_was[t])continue;\n                q.push(mp(t, col ^ 1));\n                _was[t] = 1;\n            }\n        }\n        cg.push_back(mp(red, coun - red));\n    }\n    return cg;\n\n}\ntemplate<class T> ostream &operator<<(ostream &os, graph<T> &g) {\n    rep(i, sz(g)) {\n        forg(gi, g[i]) {\n            os << f << \" \" << t << \" \" << c << endl;\n        }\n    }\n    return os;\n}\n\n//機能拡張\nvp vtop(vi &a, vi &b) {\n    vp res(sz(a));\n    rep(i, sz(a))res[i] = mp(a[i], b[i]);\n    return res;\n}\nvoid ptov(vp &p, vi &a, vi &b) {\n    a.resize(sz(p));\n    b.resize(sz(p));\n    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nbasic_string<_CharT, _Traits, _Alloc>\noperator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const int __rv) {\n    basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n    __str.append(to_string(__rv));\n    return __str;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nvoid operator+=(basic_string<_CharT, _Traits, _Alloc> &__lhs, const int __rv) {\n    __lhs += to_string(__rv);\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nbasic_string<_CharT, _Traits, _Alloc>\noperator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const signed __rv) {\n    basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n    __str.append(to_string(__rv));\n    return __str;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nvoid operator+=(basic_string<_CharT, _Traits, _Alloc> &__lhs, const signed __rv) {\n    __lhs += to_string(__rv);\n}\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) {\n    a.push(v);\n}\ntemplate<class T, class U> void operator+=(deque<T> &a, U v) {\n    a.push_back(v);\n}\ntemplate<class T, class U>\npriority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {\n    a.push(v);\n    return a;\n}\ntemplate<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {\n    a.push(v);\n    return a;\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {\n    a.pb(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> operator+(const vector <T> &a, U v) {\n    vector<T> ret = a;\n    ret += v;\n    return ret;\n}\ntemplate<class T, class U> vector<T> operator+(U v, const vector <T> &a) {\n    vector<T> ret = a;\n    ret.insert(ret.begin(), v);\n    return ret;\n}\ntemplate<class T> vector<T> &operator+=(vector<T> &a, vector <T> &b) {\n    fora(v, b)a += v;\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, initializer_list<U> v) {\n    for (auto &&va :v)a.pb(va);\n    return a;\n}\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {\n    if (sz(a) != sz(b)) {\n        debugline(\"vector<T> operator-=\");\n        deb(a);\n        deb(b);\n        ole();\n    }\n    rep(i, sz(a))a[i] -= b[i];\n    return a;\n}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector <T> &b) {\n    if (sz(a) != sz(b)) {\n        debugline(\"vector<T> operator-\");\n        deb(a);\n        deb(b);\n        ole();\n    }\n    vector<T> res(sz(a));\n    rep(i, sz(a))res[i] = a[i] - b[i];\n    return res;\n}\n\n\ntemplate<typename T> void remove(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\ntemplate<typename T> void remove(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\ntemplate<typename T> void removen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\ntemplate<typename T> void erase(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\ntemplate<typename T> void erasen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, vector<T> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, initializer_list<U> list) {\n    for (auto &&va :list)v.pb(va);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, initializer_list<U> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\ntemplate<typename T> void insert(set<T> &v, vector<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\ntemplate<typename T> void insert(set<T> &v, initializer_list<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\n\n\n//閉路がなければtrue\nbool topo(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.t]++;\n    queue<int> st;\n    rep(i, n)if (nyu[i] == 0)st.push(i);\n    while (st.size()) {\n        int v = st.front();\n        st.pop();\n        res.pb(v);\n        fora(e, g[v]) if (--nyu[e.t] == 0)st.push(e.t);\n    }\n    return res.size() == n;\n}\n//辞書順最小トポロジカルソート\nbool topos(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.t]++;\n    //小さい順\n    priority_queue<int, vector<int>, greater<int> > q;\n    rep(i, n)if (nyu[i] == 0)q.push(i);\n    while (q.size()) {\n        int i = q.top();\n        q.pop();\n        res.pb(i);\n        fora(e, g[i])if (--nyu[e.t] == 0)q.push(e.t);\n    }\n    return res.size() == n;\n}\nvector<string> split(const string a, const char deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size();\n    vector<string> res;\n    rep(i, n) {\n        if (b[i] == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            l = i + 1;\n        }\n    }\n    return res;\n}\nvector<string> split(const string a, const string deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size(), dn = deli.size();\n    vector<string> res;\n    rep(i, n) {\n        if (i + dn <= n && b.substr(i, i + dn) == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            i += dn - 1;\n            l = i + 1;\n        }\n    }\n    return res;\n}\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\n\nint n, m, k, d, H, W, x, y, z, q;\nint cou;\nvi a, b, c;\nvvi (s, 0, 0);\nvvc (ba, 0, 0);\nvp p;\nstruct Monoid {\n    ll i, v;\n    Monoid(ll i, ll v) : i(i), v(v) {}\n};\n#define segMinl [](Monoid a,Monoid b){return a.v <= b.v ? a : b;} , Monoid(-1,MAX(ll))\n#define segMinr [](Monoid a,Monoid b){return a.v < b.v ? a : b;} , Monoid(-1,MAX(ll))\n#define segMaxl [](Monoid a,Monoid b){return a.v >= b.v ? a : b;} , Monoid(-1,MIN(ll))\n#define segMaxr [](Monoid a,Monoid b){return a.v > b.v ? a : b;} , Monoid(-1,MIN(ll))\n#define segSum  [](Monoid a,Monoid b){return Monoid(a.i+b.i,a.v+b.v);} , Monoid(0,0)\n\nstruct SegmentTree {\n    using func=function<Monoid(Monoid, Monoid)>;\n    int n;\n    vector<Monoid> seg;\n    const func f;\n    const Monoid e;\n    SegmentTree(int len, func f, const Monoid e) : f(f), e(e) {\n        n = 1;\n        while (n < len)n *= 2;\n        seg.assign(2 * n - 1, e);\n    }\n    SegmentTree(vi dat, const func f, const Monoid e) : f(f), e(e) {\n        n = 1;\n        int asz = dat.size();\n        while (n < asz)n *= 2;\n        seg.assign(2 * n - 1, e);\n        rep(i, asz) seg[i + n - 1] = Monoid(i, dat[i]);\n        rer(i, n - 2)seg[i] = f(seg[i * 2 + 1], seg[i * 2 + 2]);\n    }\n    void update(int k, int v) {\n        seg[k + n - 1] = Monoid(k, v);\n        k += n - 1;\n        while (k) {\n            k = (k - 1) / 2;\n            seg[k] = f(seg[k * 2 + 1], seg[k * 2 + 2]);\n        }\n    }\n    void del(int k) {\n        update(k, e.v);\n    }\n    void add(int k, int v) {\n        update(k, v + seg[k + n - 1].v);\n    }\n    Monoid query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l)return e;\n        else if (a <= l && r <= b)return seg[k];\n        else {\n            Monoid sl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n            Monoid sr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n            return f(sl, sr);\n        }\n    }\n    Monoid get(int a = 0, int b = -1) {\n        if (b == -1)b = n;\n        return query(a, b, 0, 0, n);\n    }\n    int geti(int a = 0, int b = -1) {\n        return get(a, b).i;\n    }\n    ll getv(int a = 0, int b = -1) {\n        return get(a, b).v;\n    }\n    int operator()(int a = 0, int b = -1) {\n        return get(a, b).v;\n    }\n    Monoid operator[](int k) const {\n        return seg[k + n - 1];\n    }\n};\n\nvoid solve() {\n    cin >> n >> q;\n    n *= 2;\n    na(a, n);\n    na(b, n);\n    //基本b\n    rep(i, n)c += a[i] - b[i];\n    SegmentTree minu(k5, segMaxl);\n    SegmentTree plu(k5, segMinl);\n    int pc = 0;\n    int base = 0;\n    int pad = 0;\n    int add = 0;\n    add = a[0] + a[n - 1];\n    rep(i, 1, n - 1) {\n        base += b[i];\n        if (c[i] < 0)minu.update(i, c[i]);\n        else {\n            plu.update(i, c[i]);\n            pc++;\n            pad += c[i];\n        }\n    }\n    while (q--) {\n        din(p, x, y);\n        p--;\n        if (p == 0 || p == n - 1) {\n            add -= a[p];\n            a[p] = x;\n            b[p] = y;\n            add += a[p];\n        } else {\n            base -= b[p];\n            a[p] = x;\n            b[p] = y;\n            base += b[p];\n            int nc = a[p] - b[p];\n            //-に入ってる\n            if (c[p] < 0) {\n                //-から消す\n                if (nc >= 0) {\n                    pad += nc;\n                    plu.update(p, nc);\n                    minu.del(p);\n                    pc++;\n                } else {\n                    minu.update(p, nc);\n                }\n            } else {\n                pad -= c[p];\n                if (nc < 0) {\n                    minu.update(p, nc);\n                    plu.del(p);\n                    pc--;\n                } else {\n                    plu.update(p, nc);\n                    pad += nc;\n                }\n            }\n            c[p] = a[p] - b[p];\n        }\n        if (pc % 2 == 0) {\n            cout << add + pad + base << endl;\n        } else {\n            int res = -linf;\n            //+を一つ消す\n            chma(res, add + pad - plu() + base);\n            //-を一つ取る\n            chma(res, add + pad + minu() + base);\n            cout << res << endl;\n        }\n    }\n\n}\n\nint my(int n, vi a) {\n\n    return 0;\n}\n\nint sister(int n, vi a) {\n\n    return 0;\n}\n\nsigned main() {\n    solve();\n//\n#define _arg n,a\n\n#ifdef _DEBUG\n    bool bad = 0;\n    for (int i = 0, ok = 1; i < k5 && ok; i++) {\n        int n = rand(1, 4);\n        vi a = ranv(m, 1, 10);\n        int myres = my(_arg);\n        int res = sister(_arg);\n        ok = myres == res;\n        if (!ok) {\n            outl(_arg);\n            cout << \"正解 : \" << res << endl;\n            cout << \"自分 : \" << myres << endl;\n            bad = 1;\n            break;\n        }\n    }\n    if (!bad) {\n//        cout << \"完璧です。\" << endl;\n    }\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace std::chrono;\n#define int long long\n#define ll long long\nauto start_time = system_clock::now();\n\n//@formatter:off\n#ifdef _DEBUG\n//区間削除は出来ない\ntemplate<class T> struct my_pbds_tree {    set<T> s;    auto begin() { return s.begin(); }    auto end() { return s.end(); }    auto rbegin() { return s.rbegin(); }    auto rend() { return s.rend(); }    auto empty() { return s.empty(); }    auto size() { return s.size(); }    void clear() { s.clear(); }    template<class U> void insert(U v) { s.insert(v); }template<class U> void operator+=(U v) { insert(v); }    template<class F> auto erase(F v) { return s.erase(v); }    template<class U> auto find(U v) { return s.find(v); }    template<class U> auto lower_bound(U v) { return s.lower_bound(v); }    template<class U> auto upper_bound(U v) { return s.upper_bound(v); }    auto find_by_order(ll k) {        auto it = s.begin();        for (ll i = 0; i < k; i++)it++;        return it;    }    auto order_of_key(ll v) {        auto it = s.begin();        ll i=0;        for (;it != s.end() && *it <v ; i++)it++;        return i;    }};\n#define pbds(T) my_pbds_tree<T>\n#else\n#define unordered_map __gnu_pbds::gp_hash_table\n//find_by_order(k) k番目のイテレーター\n//order_of_key(k)  k以上が前から何番目か\n#define pbds(U) __gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>\n#endif\nstruct xorshift {    static uint64_t splitmix64(uint64_t x) {        x += 0x9e3779b97f4a7c15;        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;        return x ^ (x >> 31);    }    size_t operator()(uint64_t x) const {        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(x + FIXED_RANDOM);    }    size_t operator()(std::pair<ll, ll> x) const {        ll v=((x.first) << 32) | x.second;        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(v + FIXED_RANDOM);    }};\ntemplate<class U, class L> void operator+=(__gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> &s, L v) { s.insert(v); }\n//衝突対策\n#define ws wszzzz\n\ntemplate<class A, class B, class C>struct T2 {A f;B s;C t;T2() { f = 0, s = 0, t = 0; }T2(A f, B s, C t) : f(f), s(s), t(t) {}bool operator<(const T2 &r) const {        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;        /*return f != r.f ? f > r.f : s != r.s ?n s > r.s : t > r.t; 大きい順 */   }    bool operator>(const T2 &r) const {        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;        /*return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順 */   }    bool operator==(const T2 &r) const {        return f == r.f && s == r.s && t == r.t;    }    bool operator!=(const T2 &r) const {        return f != r.f || s != r.s || t != r.t;    }};\ntemplate<class A, class B, class C, class D> struct F2 {    A a;    B b;    C c;    D d;    F2() { a = 0, b = 0, c = 0, d = 0; }    F2(A a, B b, C c, D d) : a(a), b(b), c(c), d(d) {}    bool operator<(const F2 &r) const {        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;    /*    return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;*/    }    bool operator>(const F2 &r) const {        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;/*        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;*/    }    bool operator==(const F2 &r) const {        return a == r.a && b == r.b && c == r.c && d == r.d;    }    bool operator!=(const F2 &r) const {        return a != r.a || b != r.b || c != r.c || d != r.d;    }    ll operator[](ll i) {        assert(i < 4);        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;    }};\ntypedef T2<ll, ll, ll> T;\ntypedef F2<ll, ll, ll, ll> F;\nT mt(ll a, ll b, ll c) {return T(a, b, c);}\n\n//@マクロ省略系 型,構造\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\nusing pd =pair<dou, dou>;\n#define fi first\n#define se second\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define el else\n#define elf else if\n#define wh while\n\n#define maxq 1\n#define minq -1\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MALLOC(type, len) (type*)malloc((len) * sizeof(type))\n#define lam(right) [&](ll& p){return p right;}\n\n//マクロ省略系 コンテナ\nusing vi = vector<ll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vp = vector<P>;\nusing vt = vector<T>;\n\n#define V vector\n#define o_vvt(o1, o2, o3, o4, name, ...) name\n#define vvt0(t) V<V<t>>\n#define vvt1(t,a) V<V<t>>a\n#define vvt2(t,a, b) V<V<t>>a(b)\n#define vvt3(t,a, b, c) V<V<t>> a(b,V<t>(c))\n#define vvt4(t,a, b, c, d) V<V<t>> a(b,V<t>(c,d))\n\n#define vvi(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));}\n#define vni(name, ...) auto name = make_v<ll>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<ll, ll>;\nusing mapp = map<P, ll>;\nusing mapd = map<dou, ll>;\nusing mapc = map<char, ll>;\nusing maps = map<str, ll>;\nusing seti = set<ll>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<ll>;\n#define bset bitset\n#define uset unordered_set\n#define useti unordered_set<ll,ll,xorshift>\n#define mset multiset\n#define mseti multiset<ll>\n#define umap unordered_map\n#define umapi unordered_map<ll,ll,xorshift>\n#define umapp unordered_map<P,ll,xorshift>\n#define mmap multimap\n\ntemplate<class T> struct pq {    priority_queue<T, vector<T>, greater<T> > q;/*小さい順*/    T su = 0;    void clear() {q = priority_queue<T, vector<T>, greater<T> >();su = 0;}    void operator+=(T v) {su += v;q.push(v);}    T sum() {return su;}    T top() {return q.top();}    void pop() {su -= q.top();q.pop();}    T poll() {T ret = q.top();su -= ret;q.pop();return ret;}    ll size() {return q.size();}};\ntemplate<class T> struct pqg {    priority_queue<T> q;/*大きい順*/    T su = 0;    void clear() {q = priority_queue<T>();su = 0;}    void operator+=(T v) {su += v;q.push(v);}    T sum() {return su;}    T top() {return q.top();}    void pop() {su -= q.top();q.pop();}    T poll() {T ret = q.top();su -= ret;q.pop();return ret;}    ll size() {return q.size();}};\n#define pqi pq<ll>\n#define pqgi pqg<ll>\n//マクロ 繰り返し\n#define o_rep(o1, o2, o3, o4, name, ...) name\n# define rep1(n) for(ll rep1i = 0,rep1lim=n; rep1i < rep1lim ; ++rep1i)\n# define rep2(i, n) for(ll i = 0,rep2lim=n; i < rep2lim ; ++i)\n#define rep3(i, m, n) for(ll i = m,rep3lim=n; i < rep3lim ; ++i)\n#define rep4(i, m, n, ad) for(ll i = m,rep4lim=n; i < rep4lim ; i+= ad)\n#define rep(...) o_rep(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n\n#define rer2(i, n) for(ll i = n; i >= 0 ; i--)\n#define rer3(i, m, n) for(ll i = m,rer3lim=n; i >= rer3lim ; i--)\n#define rer4(i, m, n, dec) for(ll i = m,rer4lim=n; i >= rer4lim ; i-=dec)\n#define rer(...) o_rep(__VA_ARGS__,rer4,rer3,rer2,)(__VA_ARGS__)\n\n#define reps2(i, j, n) for(ll i = 0,reps2lim=n; i < reps2lim ;++i)for(ll j = 0; j < reps2lim ; ++j)\n#define reps3(i, j, k, n) for(ll i = 0,reps3lim=n; i < reps3lim ; ++i)for(ll j = 0; j < reps3lim ; ++j)for(ll k = 0; k < reps3lim ; ++k)\n#define reps4(i, j, k, l, n) for(ll i = 0,reps4lim=n; i < reps4lim ; ++i)for(ll j = 0; j < reps4lim ; ++j)for(ll k = 0; k < reps4lim ; ++k)for(ll l = 0; l < reps4lim ; ++l)\n#define o_reps(o1, o2, o3, o4, o5, name, ...) name\n#define reps(...) o_reps(__VA_ARGS__,reps4,reps3,reps2,rep2,)(__VA_ARGS__)\n\n#define repss(i, j, k, a, b, c) for(ll i = 0; i < a ; ++i)for(ll j = 0; j < b ; ++j)for(ll k = 0; k < c ; ++k)\n\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) for (ll gi = 0,forglim = ve.size(), f, t, c; gi < forglim && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); ++gi)\n#define fort(gi, ve) for (ll gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); ++gi)if(t!=p)\n\n#define form(st, l, r) for (auto &&it = st.lower_bound(l); it != st.end() && (*it).fi < r; ++it)\n#define forit(st, l, r) for (auto &&it = st.lower_bound(l); it != st.end() && (*it) < r;)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst ll inf = (ll) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst char infc = '{';\nconst string infs = \"{\";\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((ll)(a).size())\n#define mp make_pair\n#define pb pop_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconstexpr bool ev(ll a) { return !(a & 1); }\nconstexpr bool od(ll a) { return (a & 1); }\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\n//@formatter:on\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> { public:size_t operator()(const std::pair<signed, signed> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n    template<> class hash<std::pair<ll, ll>> { public:/*大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断*/size_t operator()(const std::pair<ll, ll> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n}\n//@formatter:off\n//stream まとめ\nistream &operator>>(istream &iss, P &a) {    iss >> a.first >> a.second;    return iss;}template<typename T> istream &operator>>(istream &iss, vector<T> &vec) {    for (T &x: vec) iss >> x;    return iss;}template<class T, class U> ostream &operator<<(ostream &os, pair<T, U> p) {    os << p.fi << \" \" << p.se << endl;    return os;}ostream &operator<<(ostream &os, T p) {    os << p.f << \" \" << p.s << \" \" << p.t;    return os;}ostream &operator<<(ostream &os, F p) {    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;    return os;}template<typename T> ostream &operator<<(ostream &os, vector<T> &vec) {    for (ll i = 0; i < vec.size(); ++i)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");    return os;}template<typename T> ostream &operator<<(ostream &os, vector<vector<T>> &vec) {    for (ll i = 0; i < vec.size(); ++i) {        for (ll j = 0; j < vec[i].size(); ++j) { os << vec[i][j] << \" \"; }        os << endl;    }    return os;}template<typename T, typename U> ostream &operator<<(ostream &os, map<T, U> &m) {    for (auto &&v:m) os << v;    return os;}\ntemplate<typename W, typename H> void resize(vector<W> &vec, const H head) { vec.resize(head); }template<typename W, typename H, typename ... T> void resize(vector<W> &vec, const H &head, const T ... tail) {vec.resize(head);for (auto &v: vec)resize(v, tail...);}\ntemplate<typename T, typename F> bool all_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool all_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (!all_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool any_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool any_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (any_of2(v[i], f))return true; }    return false;}\ntemplate<typename T, typename F> bool none_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool none_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (none_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool find_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll find_if2(vector<T> &v, F f) {    rep(i, sz(v)) { if (find_if2(v[i], f))return i; }    return sz(v);}\ntemplate<typename T, typename F> bool rfind_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll rfind_if2(vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (rfind_if2(v[i], f))return i; }    return -1;}\ntemplate<class T> bool contains(string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> ll count_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll count_if2(vector<T> &vec, F f) {    ll ret = 0;    fora(v, vec)ret += count_if2(v, f);    return ret;}\ntemplate<typename T, typename F> void for_each2(T &v, F f) { f(v); }\ntemplate<typename T, typename F> void for_each2(vector<T> &vec, F f) { fora(v, vec)for_each2(v, f); }\ntemplate<typename W> ll count_od(vector<W> &a) {return count_if2(a,[](ll v){return v&1 ;});}\ntemplate<typename W> ll count_ev(vector<W> &a) {return count_if2(a,[](ll v){return !(v&1) ;});}\n#define all_of(a,right) all_of2(a,lam(right))\n#define any_of(a,right) any_of2(a,lam(right))\n#define none_of(a,right) none_of2(a,lam(right))\n#define find_if(a,right) find_if2(a,lam(right))\n#define rfind_if(a,right) rfind_if2(a,lam(right))\n#define contains_if(a,right) contains_if2(a,lam(right))\n#define count_if(a, right) count_if2(a,lam(right))\n#define for_each(a, right) do{fora(v,a){v right;}}while(0)\n\n\ntemplate<class T, class U> void replace(vector<T> &a, T key, U v) { replace(a.begin(), a.end(), key, v); }\nvoid replace(str &a, char key, str v) { if (v == \"\")a.erase(remove(all(a), key), a.end()); }\nvoid replace(str &a, char key, char v) { replace(all(a), key, v); }\n//keyと同じかどうか01で置き換える\ntemplate<class T, class U> void replace(vector<T> &a, U k) { rep(i, sz(a)) a[i] = a[i] == k; }\ntemplate<class T, class U> void replace(vector<vector<T >> &a, U k) { rep(i, sz(a))rep(j, sz(a[0])) a[i][j] = a[i][j] == k; }\ntemplate<class T> void replace(T &a) { replace(a, '#'); }\nvoid replace(str &a, str key, str v) {stringstream t;ll kn = sz(key);std::string::size_type Pos(a.find(key));ll l = 0;while (Pos != std::string::npos) {t << a.substr(l, Pos - l);t << v;l = Pos + kn;Pos = a.find(key, Pos + kn);}t << a.substr(l, sz(a) - l);a = t.str();}\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {vi c = a;vi d = b;sort(all(c));sort(all(d));return includes(all(c), all(d));}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\nvoid iota(vector<ll> &ve, ll s, ll n) {ve.resize(n);iota(all(ve), s);}\nvi iota(ll s, ll len) {vi ve(len);iota(all(ve), s);return ve;}\ntemplate<class A, class B> auto vtop(vector<A> &a, vector<B> &b) {    assert(sz(a) == sz(b));    /*stringを0で初期化できない  */  vector<pair<A, B>> res;    rep(i, sz(a))res.eb(a[i], b[i]);return res;}\ntemplate<class A, class B> void ptov(vector<pair<A, B>> &p, vector<A> &a, vector<B> &b) {    a.resize(sz(p)), b.resize(sz(p));    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;}\ntemplate<class A, class B, class C> auto vtot(vector<A> &a, vector<B> &b, vector<C> &c) {    assert(sz(a) == sz(b) && sz(b) == sz(c));    vector<T2<A, B, C>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i]);    return res;}\ntemplate<class A, class B, class C, class D> auto vtof(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    assert(sz(a) == sz(b) && sz(b) == sz(c) && sz(c) == sz(d));    vector<F2<A, B, C, D>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i], d[i]);    return res;}\nenum pcomparator { fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd };\nenum tcomparator {    fisiti, fisitd, fisdti, fisdtd, fdsiti, fdsitd, fdsdti, fdsdtd,    fitisi, fitisd, fitdsi, fitdsd, fdtisi, fdtisd, fdtdsi, fdtdsd,    sifiti, sifitd, sifdti, sifdtd, sdfiti, sdfitd, sdfdti, sdfdtd,    sitifi, sitifd, sitdfi, sitdfd, sdtifi, sdtifd, sdtdfi, sdfdfd,    tifisi, tifisd, tifdsi, tifdsd, tdfisi, tdfisd, tdfdsi, tdfdsd,    tisifi, tisifd, tisdfi, tisdfd, tdsifi, tdsifd, tdsdfi, tdsdfd};\ntemplate<class A, class B> void sort(vector<pair<A, B>> &a, pcomparator type) {    typedef pair<A, B> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });};template<class U> void sort(vector<U> &a, pcomparator type) {    if (type == fisi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });};template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D> > &a, pcomparator type) {    typedef F2<A, B, C, D> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a > r.a; });};template<class U> void sort(vector<U> &a, tcomparator type) {    if (type == 0) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });}template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D>> &a, tcomparator type) {    typedef F2<A, B, C, D> U;    if (type == 0) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });}\n\nvoid sort(string &a) { sort(all(a)); }\ntemplate<class T> void sort(vector<T> &a) { sort(all(a)); }\n//P l, P rで f(P) の形で渡す\ntemplate<class U, class F> void sort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) < f(r); }); };\ntemplate<class T> void rsort(vector<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class U, class F> void rsort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) > f(r); }); };\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class A, class B> void sortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    sort(c);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B, class F> void sortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    sort(c, f);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B> void rsortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    rsort(c);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}template<class A, class B, class F> void rsortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    rsort(c, f);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C> void sortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    sort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void sortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    sort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    rsort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    rsort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class D> void sortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    sort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\ntemplate<class A, class B, class C, class D> void rsortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    rsort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\n//sortindex 元のvectorはソートしない\ntemplate<class T> vi sorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind);    return ind;}/*indexの分で型が変わるためpcomparatorが必要*/template<class T> vi sorti(vector<T> &a, pcomparator f) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind, f);    return ind;}template<class T, class F> vi sorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) < f(a[y]); });    return ind;}template<class T> vi rsorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    rsortp(b, ind);    return ind;}template<class T, class F> vi rsorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) > f(a[y]); });    return ind;}template<class A, class B, class F> vi sortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) < f(c[y]); });    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b, pcomparator f) {    vi ind = iota(0, sz(a));    auto c = a;    auto d = b;    sortt(c, d, ind, f);    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fisi); };template<class A, class B, class F> vi rsortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) > f(c[y]); });    return ind;}template<class A, class B> vi rsortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fdsd); };template<class A, class B, class C, class F> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) < f(d[y]); });    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, pcomparator f) {    vi ind = iota(0, sz(a));    auto d = vtof(a, b, c, ind);    sort(d, f);    rep(i, sz(a))ind[i] = d[i].d;    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] < c[y];            else return b[x] < b[y];        } else {            return a[x] < a[y];        }    });    return ind;}template<class A, class B, class C, class F> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) > f(d[y]); });    return ind;}template<class A, class B, class C> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] > c[y];            else return b[x] > b[y];        } else {            return a[x] > a[y];        }    });    return ind;}\ntemplate<class T> void sort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)sort(a[i]); }\ntemplate<class T> void rsort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)rsort(a[i]); }\n\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }template<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }template<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename W, typename T>void fill(W &xx, const T vall) {    xx = vall;}template<typename W, typename T>void fill(vector<W> &vecc, const T vall) {    for (auto &&vx     : vecc)fill(vx, vall);}\ntemplate<typename W,typename T>void fill(vector<W> &xx,const T v,ll len) {rep(i, len)xx[i]=v;}\ntemplate<typename W,typename T>void fill(vector<vector<W>> &xx,const T v,ll lh,ll lw) {rep(i, lh)rep(j,lw)xx[i][j]=v;}\ntemplate<class T,class U>void fill(vector<T> &a,U val,vi& ind) {fora(v,ind)a[v]=val;}\n\ntemplate<typename A, size_t N> A sum(A (&a)[N]) {    A res = 0;    rep(i, N)res += a[i];    return res;}template<typename A, size_t N, size_t O> A sum(A (&a)[N][O]) {    A res = 0;    rep(i, N)rep(j, O)res += a[i][j];    return res;}template<typename A, size_t N, size_t O, size_t P> A sum(A (&a)[N][O][P]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)res += a[i][j][k];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A sum(A (&a)[N][O][P][Q]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)res += a[i][j][k][l];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A sum(A (&a)[N][O][P][Q][R]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)res += a[i][j][k][l][m];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A sum(A (&a)[N][O][P][Q][R][S]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)res += a[i][j][k][l][m][n];    return res;}\n//@汎用便利関数 入力\nll in() {ll ret;cin >> ret;return ret;}\nstring sin() {string ret;cin >> ret;return ret;}\ntemplate<class T>  void in(T &head) { cin >> head; }template<class T, class... U>  void in(T &head, U &... tail) {cin >> head;in(tail...);}\n\n#define o_din(o1, o2, o3, o4, o5, o6, name, ...) name\n#define din1(a) ll a;cin>>a\n#define din2(a, b) ll a,b;cin>>a>> b\n#define din3(a, b, c) ll a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) ll a,b,c,d;cin>>a>>b>>c>>d\n#define din5(a, b, c, d, e) ll a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define din6(a, b, c, d, e, f) ll a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define din(...) o_din(__VA_ARGS__,din6,din5,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define o_dind(o1, o2, o3, o4, name, ...) name\n#define din1d(a) din1(a);a--\n#define din2d(a, b) din2(a,b);a--,b--\n#define din3d(a, b, c) din3(a,b,c);a--,b--,c--\n#define din4d(a, b, c, d) din4(a,b,c,d);a--,b--,c--,d--\n#define dind(...) o_dind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\ntemplate<class T> void out2(T &&head) { cout << head; }\ntemplate<class T, class... U> void out2(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);    cout << \"\" << endl;}\ntemplate<class T> void out(T &&head) {    cout << head  << endl;}\ntemplate<class T> void outv(vector<T> &a, ll W) {    rep(i, W) { cout << a[i] << \" \"; }    cout << \"\" << endl;}template<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf) {    rep(h, min(H, sz(a))) {        rep(w, min(W, sz(a[0]))) { if (a[h][w] == linf) cout << \"e\" << \" \"; else cout << a[h][w] << \" \"; }        cout << \"\" << endl;    }}\ntemplate<class T> void outl(vector<T> &a) { fora(v, a)cout << v << endl; }\ntemplate<class T> void na(vector<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i];}\n#define dna(a, n) vi a(n); rep(dnai,n) cin >> a[dnai];\ntemplate<class T> void nao(vector<T> &a, ll n) {    a.resize(n + 1);    a[0] = 0;    rep(i, n)cin >> a[i + 1];}\ntemplate<class T> void naod(vector<T> &a, ll n) {    a.resize(n + 1);    a[0] = 0;    rep(i, n)cin >> a[i + 1],a[i+1]--;}\ntemplate<class T> void nad(vector<T> &a, ll n) {    a.resize(n);    rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T, class U> void na2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i];}\n#define dna2(a, b, n) vi a(n),b(n);rep(dna2i, n)cin >> a[dna2i] >> b[dna2i];\ntemplate<class T, class U> void nao2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n + 1);    b.resize(n + 1);    a[0] = b[0] = 0;    rep(i, n)cin >> a[i + 1] >> b[i + 1];}\n#define dna2d(a, b, n) vi a(n),b(n);rep(dna2di, n){cin >> a[dna2di] >> b[dna2di];a[dna2di]--,b[dna2di]--;}\ntemplate<class T, class U> void na2d(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i], a[i]--, b[i]--;}\ntemplate<class T, class U, class W> void na3(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {    a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define dna3(a, b, c, n) vi a(n),b(n),c(n);   rep(dna3i, n)cin >> a[dna3i] >> b[dna3i] >> c[dna3i];\ntemplate<class T, class U, class W> void na3d(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {    a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i], a[i]--, b[i]--, c[i]--;}\n#define dna3d(a, b, c, n) vi a(n),b(n),c(n);  rep(dna3di, n){cin >> a[dna3di] >> b[dna3di] >> c[dna3di];a[dna3di]--,b[dna3di]--,c[dna3di]--;}\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n//デバッグ\n#define sp << \" \" <<\n\n#define debugName(VariableName) # VariableName\n\n#define deb1(x)  debugName(x)<<\" = \"<<x\n#define deb2(x, ...) deb1(x) <<\", \"<< deb1(__VA_ARGS__)\n#define deb3(x, ...) deb1(x) <<\", \"<< deb2(__VA_ARGS__)\n#define deb4(x, ...) deb1(x) <<\", \"<< deb3(__VA_ARGS__)\n#define deb5(x, ...) deb1(x) <<\", \"<< deb4(__VA_ARGS__)\n#define deb6(x, ...) deb1(x) <<\", \"<< deb5(__VA_ARGS__)\n#define deb7(x, ...) deb1(x) <<\", \"<< deb6(__VA_ARGS__)\n#define deb8(x, ...) deb1(x) <<\", \"<< deb7(__VA_ARGS__)\n#define deb9(x, ...) deb1(x) <<\", \"<< deb8(__VA_ARGS__)\n#define deb10(x, ...) deb1(x) <<\", \"<< deb9(__VA_ARGS__)\n\n#define o_ebug(o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, name, ...) name\n\n#ifdef _DEBUG\n#define deb(...)  cerr<< o_ebug(__VA_ARGS__,deb10,deb9,deb8,deb7,deb6,deb5,deb4,deb3,deb2,deb1)(__VA_ARGS__) <<endl\n#else\n#define deb(...) ;\n#endif\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\n//@formatter:off\n//よく使うクラス、構造体\nstruct unionfind {\n    vector<ll> par;\n    vector<ll> siz;\n    vector<ll> es;\n    ll n, trees;//連結グループの数(親の種類)\n    unionfind(ll n) : n(n), trees(n) {        par.resize(n);        siz.resize(n);        es.resize(n);        for (ll i = 0; i < n; i++) {            par[i] = i;            siz[i] = 1;        }    }\n    ll root(ll x) { if (par[x] == x) { return x; } else { return par[x] = root(par[x]); }}\n    void unite(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        es[x]++;\n        if (x == y) return;\n        if (siz[x] > siz[y]) swap(x, y);\n        trees--;\n        par[x] = y;\n        siz[y] += siz[x];\n        es[y] += es[x];\n    }\n    bool same(ll x, ll y) { return root(x) == root(y); }\n    ll size(ll x) { return siz[root(x)]; }\n    ll esize(ll x) { return es[root(x)]; }\n    vi sizes(){        vi cou(n);        vi ret;        ret.reserve(n);        rep(i, n){            cou[root (i)]++;        }        rep(i, n){            if(cou[i])ret.push_back(cou[i]);        }        return ret;    }\n    //つながりを無向グラフと見なし、xが閉路に含まれるか判定\n    bool close(ll x) { return esize(x) >= size(x); }\n    V<vi> sets() {        vi ind(n, -1);        ll i = 0;        vvi(res, trees);        rep(j, n) {            ll r = root(j);            if (ind[r] == -1)ind[r] = i++;            res[ind[r]].push_back(j);        }        rep(i, trees) {            ll r = root(res[i][0]);            if (res[i][0] == r)continue;            rep(j, 1, sz(res[i])) {                if (res[i][j] == r) {                    swap(res[i][0], res[i][j]);                    break;                }            }        }        return res;    }\n};//@formatter:off\n\n\nusing bll =__int128;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing u128 = __uint128_t;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {    std::ostream::sentry s(dest);    if (s) {        __uint128_t tmp = value < 0 ? -value : value;        char buffer[128];        char *d = std::end(buffer);        do {            --d;            *d = \"0123456789\"[tmp % 10];            tmp /= 10;        } while (tmp != 0);        if (value < 0) {            --d;            *d = '-';        }        ll len = std::end(buffer) - d;        if (dest.rdbuf()->sputn(d, len) != len) { dest.setstate(std::ios_base::badbit); }    }    return dest;}\n//__int128 toi128(string &s) {    __int128 ret = 0;    for (ll i = 0; i < s.length(); ++i)        if ('0' <= s[i] && s[i] <= '9')            ret = 10 * ret + s[i] - '0';    return ret;}\n\n\n//エラー\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");    exit(0);\n#endif\n    string a = \"a\";    rep(i, 30)a += a;    rep(i, 1 << 17)cout << a << endl;    cout << \"OLE 出力長制限超過\" << endl;    exit(0);}\nvoid re() {    assert(0 == 1);    exit(0);}\nvoid tle() { while (inf)cout << inf << endl; }\n\n//便利関数\n\n//テスト用\nchar ranc() { return (char) ('a' + rand() % 26); }\nll rand(ll min, ll max) {    assert(min <= max);    if (min >= 0 && max >= 0) { return rand() % (max + 1 - min) + min; } else if (max < 0) { return -rand(-max, -min); } else { if (rand() % 2) { return rand(0, max); } else { return -rand(0, -min); }}}\nvi ranv(ll n, ll min, ll max) {    vi v(n);    rep(i, n)v[i] = rand(min, max);    return v;}\nstr ransu(ll n) {    str s;    rep(i, n)s += (char) rand('A', 'Z');    return s;}\nstr ransl(ll n) {    str s;    rep(i, n)s += (char) rand('a', 'z');    return s;}\n//単調増加\nvi ranvinc(ll n, ll min, ll max) {    vi v(n);    bool bad = 1;    while (bad) {        bad = 0;        v.resize(n);        rep(i, n) {            if (i && min > max - v[i - 1]) {                bad = 1;                break;            }            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]); else v[i] = rand(min, max);        }    }    return v;}\n//便利 汎用\nvoid ranvlr(ll n, ll min, ll max, vi &l, vi &r) {    l.resize(n);    r.resize(n);    rep(i, n) {        l[i] = rand(min, max);        r[i] = l[i] + rand(0, max - l[i]);    }}\nvp run_length(vi &a) {    vp ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\nvector<pair<char, ll>> run_length(string &a) {    vector<pair<char, ll>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\ntemplate<class F> ll mgr(ll ok, ll ng, F f) {    if (ok < ng)        while (ng - ok > 1) {            ll mid = (ok + ng) / 2;            if (f(mid))ok = mid; else ng = mid;        }    else        while (ok - ng > 1) {            ll mid = (ok + ng) / 2;            if (f(mid))ok = mid; else ng = mid;        }    return ok;}\n//strを整数として比較\nstring smax(str &a, str b) {    if (sz(a) < sz(b)) { return b; } else if (sz(a) > sz(b)) { return a; } else { rep(i, sz(a)) { if (a[i] < b[i]) { return b; } else if (a[i] > b[i])return a; }}    return a;}\n//strを整数として比較\nstring smin(str &a, str b) {    if (sz(a) < sz(b)) { return a; } else if (sz(a) > sz(b)) { return b; } else { rep(i, sz(a)) { if (a[i] < b[i]) { return a; } else if (a[i] > b[i])return b; }}    return a;}\ntemplate<typename W, typename T> ll find(vector<W> &a, const T key) {    rep(i, sz(a))if (a[i] == key)return i;    return -1;}\ntemplate<typename W, typename T> P find(vector<vector<W >> &a, const T key) {    rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);    return mp(-1, -1);}\ntemplate<typename W, typename U> T find(vector<vector<vector<W >>> &a, const U key) {    rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);    return mt(-1, -1, -1);}\n\n\ntemplate<typename W, typename T> ll count2(W &a, const T k) { return a == k; }\ntemplate<typename W, typename T> ll count2(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\ntemplate<typename W, typename T> ll count(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\nll count(str &a, str k) {    ll ret = 0, len = k.length();    auto pos = a.find(k);    while (pos != string::npos)pos = a.find(k, pos + len), ++ret;    return ret;}\nvi count(str &a) {    vi cou(26);    char c = 'a';    if ('A' <= a[0] && a[0] <= 'Z')c = 'A';    rep(i, sz(a))++cou[a[i] - c];    return cou;}\n#define couif count_if\n//algorythm\n\n\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    return res;}\ntemplate<class T> void rev(vector<T> &a) { reverse(all(a)); }\ntemplate<class U> void rev(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[h][w];    a = b;}\nvoid  rev(string &a) { reverse(all(a)); }\nconstexpr ll p10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000ll, 100000000000ll, 1000000000000ll, 10000000000000ll, 100000000000000ll, 1000000000000000ll, 10000000000000000ll, 100000000000000000ll, 1000000000000000000ll};\n\nll get(ll a, ll keta) { return (a / (ll) pow(10, keta)) % 10; }\nll keta(ll v) { if (v < p10[9]) { if (v < p10[4]) { if (v < p10[2]) { if (v < p10[1]) return 1; else return 2; } else { if (v < p10[3]) return 3; else return 4; }} else { if (v < p10[7]) { if (v < p10[5]) return 5; else if (v < p10[6])return 6; else return 7; } else { if (v < p10[8])return 8; else return 9; }}} else { if (v < p10[13]) { if (v < p10[11]) { if (v < p10[10]) return 10; else return 11; } else { if (v < p10[12]) return 12; else return 13; }} else { if (v < p10[15]) { if (v < p10[14]) return 14; else if (v < p10[15])return 15; else return 16; } else { if (v < p10[17])return 17; else return 18; }}}}\nll dsum(ll v,ll sin=10) {    ll ret = 0;    for (; v; v /= sin)ret += v % sin;    return ret;}\n\nstruct sint {\n    ll v;\n    sint(ll v) : v(v) {}\n    operator ll() { return v; }\n    //下からi番目\n    ll operator[](ll i) { return (v / p10[i]) % 10; }\n    ll back(ll i) { return operator[](i); }\n    //上からi番目\n    ll top(ll i) {\n        ll len = keta(v);\n        return operator[](len - 1 - i);\n    }\n    //先頭からi番目にセット\n    ll settop(ll i, ll k) {\n        ll len = keta(v);\n        return set(len - 1 - i, k);\n    }\n    ll set(ll i, ll k) {\n        if (i < 0)return settop(abs(i) - 1, k);\n        return v += p10[i] * (k - (v / p10[i]) % 10);\n    }\n    ll add(ll i, ll k = 1) { return v += p10[i] * k; }\n    ll addtop(ll i, ll k = 1) { return v += p10[keta(v) - i - 1] * k; }\n    ll dec(ll i, ll k = 1) { return v -= p10[i] * k; }\n    ll dectop(ll i, ll k = 1) { return v -= p10[keta(v) - i - 1] * k; }\n#define op(t, o)template<class T> t operator o(T r){return v o r;}\n    op(ll, +=);    op(ll, -=);    op(ll, *=);    op(ll, /=);    op(ll, %=);    op(ll, +);    op(ll, -);    op(ll, *);    op(ll, /);    op(ll, %);    op(bool, ==);    op(bool, !=);    op(bool, <);    op(bool, <=);    op(bool, >);    op(bool, >=);\n#undef op\n    template<class T>  ll operator<<=(T r) { return v *= p10[r]; }\n    template<class T>  ll operator<<(T r) { return v * p10[r]; }\n    template<class T>  ll operator>>=(T r) { return v /= p10[r]; }\n    template<class T>  ll operator>>(T r) { return v / p10[r]; }\n};\nll mask10(ll v) { return p10[v] - 1; }\n//変換系\ntemplate<class T> auto keys(T a) {    vector<decltype((a.begin())->fi)> res;    for (auto &&k :a)res.push_back(k.fi);    return res;}\ntemplate<class T> auto values(T a) {    vector<decltype((a.begin())->se)> res;    for (auto &&k :a)res.push_back(k.se);    return res;}\ntemplate<class T, class U>  bool chma(T &a, const U &b) {    if (a < b) {        a = b;        return true;    }    return false;}\ntemplate<class U>  bool chma(const U &b) { return chma(ma, b); }\ntemplate<class T, class U>  bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        return true;    }    return false;}\ntemplate<class U>  bool chmi(const U &b) { return chmi(mi, b); }\ntemplate<class T>  T min(T a, signed b) { return a < b ? a : b; }\ntemplate<class T>  T max(T a, signed b) { return a < b ? b : a; }\ntemplate<class T>  T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T>  T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T>  T min(vector<T>& a) { return *min_element(all(a)); }\ntemplate<class T>  T mini(vector<T>& a) { return min_element(all(a)) - a.begin(); }\ntemplate<class T>  T min(vector<T>& a, ll n) { return *min_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T>  T min(vector<T>& a, ll s, ll n) { return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T>  T max(vector<T>& a) { return *max_element(all(a)); }\ntemplate<class T,class U>  T max(vector<T>& a,vector<U>& b) { return max(*max_element(all(a)),*max_element(all(b))); }\ntemplate<class T>  T maxi(vector<T>& a) { return max_element(all(a)) - a.begin(); }\ntemplate<class T>  T max(vector<T>& a, ll n) { return *max_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T>  T max(vector<T>& a, ll s, ll n) { return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<typename A, size_t N>  A max(A (&a)[N]) {    A res = a[0];    rep(i, N)res = max(res, a[i]);    return res;}template<typename A, size_t N, size_t O>  A max(A (&a)[N][O]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P>  A max(A (&a)[N][O][P]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q>  A max(A (&a)[N][O][P][Q], const T &v) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R>  A max(A (&a)[N][O][P][Q][R]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S>  A max(A (&a)[N][O][P][Q][R][S]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}\ntemplate<typename A, size_t N>  A min(A (&a)[N]) {    A res = a[0];    rep(i, N)res = min(res, a[i]);    return res;}template<typename A, size_t N, size_t O>  A min(A (&a)[N][O]) {    A res = min(a[0]);    rep(i, N)res = min(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P>  A min(A (&a)[N][O][P]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q>  A min(A (&a)[N][O][P][Q], const T &v) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R>  A min(A (&a)[N][O][P][Q][R]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S>  A min(A (&a)[N][O][P][Q][R][S]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}\ntemplate<class T> T sum(vector<T> &v, ll s = 0, ll t = inf) {    T ret = 0;    rep(i, s, min(sz(v), t))ret += v[i];    return ret;}template<class T> T sum(vector<vector<T> > &v) {    T ret = 0;    rep(i, sz(v))ret += sum(v[i]);    return ret;}template<class T> T sum(vector<vector<vector<T> > > &v) {    T ret = 0;    rep(i, sz(v))ret += sum(v[i]);    return ret;}template<class T> T sum(vector<vector<vector<vector<T> > > > &v) {    T ret = 0;    rep(i, sz(v))ret += sum(v[i]);    return ret;}template<class T> T sum(vector<vector<vector<vector<vector<T> > > > > &v) {    T ret = 0;    rep(i, sz(v))ret += sum(v[i]);    return ret;}template<class T> auto sum(priority_queue<T, vector<T>, greater<T> > &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}template<class T> auto sum(priority_queue<T> &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}\n//template<class T, class U, class... W>  auto sumn(vector<T> &v, U head, W... tail) {    auto ret = sum(v[0], tail...);    rep(i, 1, min(sz(v), head))ret += sum(v[i], tail...);    return ret;}\nvoid clear(PQ &q) { q = PQ(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(ll size) {    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));    return body + size;}\ntemplate<class T> T *negarr2(ll h, ll w) {    double **dummy1 = new double *[2 * h + 1];    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];    dummy1[0] = dummy2 + w;    for (ll i = 1; i <= 2 * h + 1; ++i) { dummy1[i] = dummy1[i - 1] + 2 * w + 1; }    double **a = dummy1 + h;    return a;}\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\n//kと同じものの数\ntemplate<class T, class U> vi imo(vector<T> &a, U k) {vector<T> ret = a;rep(i, sz(ret))ret[i] = a[i] == k;rep(i, sz(ret) - 1)ret[i + 1] += ret[i];return ret;}\ntemplate<class T> vector<T> imox(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] ^= ret[i];    return ret;}\n//漸化的に最小を持つ\ntemplate<class T> vector<T> imi(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chmi(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> struct ruiC {    const vector<T> rui;    ruiC(vector<T> &ru) : rui(ru) {}    T operator()(ll l, ll r) {        if (l > r) {            cerr<<\"ruic \";deb(l, r);assert(0);        }        return rui[r] - rui[l];    }    T operator[](ll i) { return rui[i]; }    T back() { return rui.back(); }    ll size() { return rui.size(); }};\ntemplate<class T> struct rruic {    const T *rrui;    rruic(T *ru) : rrui(ru) {}     T operator()(ll l, ll r) {        assert(l >= r);        return rrui[r] - rrui[l];    }     T operator[](ll i) { return rrui[i]; }};\ntemplate<class T> vector<T> ruiv(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    return ret;}\ntemplate<class T> ruiC<T> ruic(vector<T> &a) {    vector<T> ret = ruiv(a);    return ruiC<T>(ret);}\nvector<ll> ruiv(string &a) {    if (sz(a) == 0)return vi(1);    ll dec = ('0' <= a[0] && a[0] <= '9') ? '0' : 0;    vector<ll> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i] - dec;    return ret;}\nruiC<ll> ruic(string &a) {    vector<ll> ret = ruiv(a);    return ruiC<ll>(ret);}\n//kと同じものの数\ntemplate<class T, class U> vi ruiv(T &a, U k) {    vi ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + (a[i] == k);    return ret;}\ntemplate<class T, class U> ruiC<ll> ruic(T &a, U k) {    vi ret = ruiv(a, k);    return ruiC<ll>(ret);}\n//xor\ntemplate<class T> vector<T> ruix(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];    return ret;}\ntemplate<class T> vector<T> ruim(vector<T> &a) {    vector<T> res(a.size() + 1, 1);    rep(i, a.size())res[i + 1] = res[i] * a[i];    return res;}\n//漸化的に最小を1indexで持つ\ntemplate<class T> vector<T> ruimi(vector<T> &a) {    ll n = sz(a);    vector<T> ret(n + 1);    rep(i, 1, n) {        ret[i] = a[i - 1];        chmi(ret[i + 1], ret[i]);    }    return ret;}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> rruic<T> rrui(vector<T> &a) {    ll len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    rer(i, len - 1)res[i - 1] = res[i] + a[i];    return rruic<T>(res);}\n//掛け算\ntemplate<class T> T *rruim(vector<T> &a) {    ll len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    res[len - 1] = 1;    rer(i, len - 1)res[i - 1] = res[i] * a[i];    return res;}\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void inc(vector<T> &a, U v = 1) { for (auto &u:a)inc(u, v); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class U> void dec(string &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T> void dec(vector<T> &a) { for (auto &u :a)dec(u, 1); }\nbool ins(ll h, ll w, ll H, ll W) { return h >= 0 && w >= 0 && h < H && w < W; }\nbool ins(ll l, ll v, ll r) { return l <= v && v < r; }\ntemplate<class T> bool ins(vector<T> &a, ll i, ll j = 0) { return ins(0, i, sz(a)) && ins(0, j, sz(a)); }\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {    vector<T> ret = a;    fora(v, ret)v = u(v);    return ret;}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\ntemplate<class F> ll goldd_l(ll left, ll right, F calc) {    double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    ll minScore = MAX(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (minScore > score) {            minScore = score;            resIndex = i;        }    }    return resIndex;}\ntemplate<class F> ll goldt_l(ll left, ll right, F calc) {        double GRATIO = 1.6180339887498948482045868343656;        ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));        ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));        ll fl = calc(lm);        ll fr = calc(rm);        while (right - left > 10) {            if (fl > fr) {                right = rm;                rm = lm;                fr = fl;                lm = left + (ll) ((right - left) / (GRATIO + 1.0));                fl = calc(lm);            } else {                left = lm;                lm = rm;                fl = fr;                rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));                fr = calc(rm);            }        }    if (left > right) {        ll l = left;        left = right;        right = l;    }    ll maxScore = MIN(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (maxScore < score) {            maxScore = score;            resIndex = i;        }    }    return resIndex;}\n/*loopは200にすればおそらく大丈夫 余裕なら300に*/\ntemplate<class F> dou goldd_d(dou left, dou right, F calc, ll loop = 140) {    dou GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    /*200にすればおそらく大丈夫*/    /*余裕なら300に*/    ll k = 141;    loop++;    while (--loop) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\ntemplate<class F> dou goldt_d(dou left, dou right, F calc, ll loop = 140) {    double GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    loop++;    while (--loop) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\n//l ~ rを複数の区間に分割し、極致を与えるiを返す time-20 msまで探索\ntemplate<class F> ll goldd_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll mini = 0, minv = MAX(ll);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldd_l(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> ll goldt_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll maxi = 0, maxv = MIN(ll);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldt_l(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class F> dou goldd_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を持つ*/    auto lim = milliseconds(time - 20);    dou mini = 0, minv = MAX(dou);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldd_d(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> dou goldt_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を残している*/    auto lim = milliseconds(time - 20);    dou maxi = 0, maxv = MIN(dou);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldt_d(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class T> T min(vector<vector<T >> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, *min_element(all(a[i])));    return res;}\ntemplate<class T> T max(vector<vector<T >> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, *max_element(all(a[i])));    return res;}\nconstexpr bool bget(ll m, ll keta) { return (m >> keta) & 1; }\nll bget(ll m, ll keta, ll sinsuu) {    m /= (ll) pow(sinsuu, keta);    return m % sinsuu;}\nll bit(ll n) { return (1LL << (n)); }\nll bit(ll n, ll sinsuu) { return (ll) pow(sinsuu, n); }\nll mask(ll n) { return (1ll << n) - 1; }\n#define bcou __builtin_popcountll\n//最下位ビット\nll lbit(ll n) { return n & -n; }\n//最上位ビット\nll hbit(ll n) {    n |= (n >> 1);    n |= (n >> 2);    n |= (n >> 4);    n |= (n >> 8);    n |= (n >> 16);    n |= (n >> 32);    return n - (n >> 1);}\nll hbitk(ll n) {    ll k = 0;    rer(i, 5) {        ll a = k + (1ll << i);        ll b = 1ll << a;        if (b <= n)k += 1ll << i;    }    return k;}\n//初期化は0を渡す\nll nextComb(ll &mask, ll n, ll r) {    if (!mask)return mask = (1LL << r) - 1;    ll x = mask & -mask; /*最下位の1*/    ll y = mask + x; /*連続した下の1を繰り上がらせる*/    ll res = ((mask & ~y) / x >> 1) | y;    if (bget(res, n))return mask = 0; else return mask = res;}\n//n桁以下でビットがr個立っているもののvectorを返す\nvi bitCombList(ll n, ll r) {    vi res;    ll m = 0;    while (nextComb(m, n, r)) { res.push_back(m); }    return res;}\nchar itoal(ll i) { return 'a' + i; }\nchar itoaL(ll i) { return 'A' + i; }\nll altoi(char c) {    if ('A' <= c && c <= 'Z')return c - 'A';    return c - 'a';}\nll ctoi(char c) { return c - '0'; }\nchar itoc(ll i) { return i + '0'; }\nll vtoi(vi &v) {    ll res = 0;    if (sz(v) > 18) {        debugline(\"vtoi\");        deb(sz(v));        ole();    }    rep(i, sz(v)) {        res *= 10;        res += v[i];    }    return res;}\nvi itov(ll i) {    vi res;    while (i) {        res.push_back(i % 10);        i /= 10;    }    rev(res);    return res;}\nvi stov(string &a) {    ll n = sz(a);    vi ret(n);    rep(i, n) { ret[i] = a[i] - '0'; }    return ret;}\n//基準を満たさないものは0になる\nvi stov(string &a, char one) {    ll n = sz(a);    vi ret(n);    rep(i, n)ret[i] = a[i] == one;    return ret;}\nvector<vector<ll>> ctoi(vector<vector<char>> s, char c) {    ll n = sz(s), m = sz(s[0]);    vector<vector<ll>> res(n, vector<ll>(m));    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;    return res;}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n//[i] := i番として圧縮されたものを返す\nvi compress(vi &a) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, umap<ll, ll> &map) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) {        ll v = a[i];        a[i] = lower_bound(all(b), a[i]) - b.begin();        map[v] = a[i];    }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r, vi &s) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    fora(v, s)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    for (ll i = 0; i < sz(s); ++i) r[i] = lower_bound(all(b), s[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(V<vi> &a) {    vi b;    fora(vv, a)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vv, a)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vector<vi >> &a) {    vi b;    fora(vvv, a)fora(vv, vvv)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vvv, a)fora(vv, vvv)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvoid compress(ll a[], ll len) {    vi b;    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define lowerBound(a, v) (*lower_bound(all(a),v))\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define upperBound(a, v) (*upper_bound(all(a),v))\ntemplate<class T> void fin(T s) { cout << s << endl, exit(0); }\n\n//便利 数学 math\nll mod(ll a, ll m) { return (a % m + m) % m; }\nll pow(ll a) { return a * a; };\nll fact(ll v) { return v <= 1 ? 1 : v * fact(v - 1); }\n\nll comi(ll n, ll r) {    assert(n < 100);    static vvi(pas, 100, 100);    if (pas[0][0])return pas[n][r];    pas[0][0] = 1;    rep(i, 1, 100) {        pas[i][0] = 1;        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];    }    return pas[n][r];}\ndouble comd(ll n, ll r) {    assert(n < 2020);    static vvd(comb, 2020, 2020);    if (comb[0][0] == 0) {        comb[0][0] = 1;        rep(i, 2000) {            comb[i + 1][0] = 1;            rep(j, 1, i + 2) {                comb[i + 1][j] = comb[i][j] + comb[i][j - 1];            }        }    }    return comb[n][r];}\nll gcd(ll a, ll b) {while (b) a %= b, swap(a, b);return abs(a);}\nll gcd(vi b) {ll res = b[0];rep(i, 1, sz(b))res = gcd(b[i], res);return res;}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll lcm(vi a) {ll res = a[0];rep(i, 1, sz(a))res = lcm(a[i], res);return res;}\nll ceil(ll a, ll b) {if (b == 0) {debugline(\"ceil\");deb(a, b);ole();return -1;} else if (a < 0) { return 0; } else { return (a + b - 1) / b; }}\nll lower_remi__bx_a(ll kei, ll rem, ll x) {if (rem >= x) return 0;return (x - rem + kei - 1) / kei;}\nll lower_remv__bx_a(ll kei, ll rem, ll x) {if (rem >= x) return rem;return (x - rem + kei - 1) / kei * kei + rem;}\nll upper_remi__bx_a(ll kei, ll rem, ll x) {if (rem > x) return 0;return (x - rem + kei) / kei;}\nll upper_remv__bx_a(ll kei, ll rem, ll x) {if (rem > x) return rem;return (x - rem + kei) / kei * kei + rem;}\n//v * v >= aとなる最小のvを返す\nll sqrt(ll a) {if (a < 0) {debugline(\"sqrt\");deb(a);ole();}ll res = (ll) std::sqrt(a);while (res * res < a)++res;return res;}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return ((1 + t) * t) >> 1; }\nll sig(ll s, ll t) { return ((s + t) * (t - s + 1)) >> 1; }\n\n\n//幾何 Pをcomplexとして扱う\ntemplate<class T, class U> bool eq(T a, U b) { return fabs(a - b) < eps; }\ndou atan2(pd a) { return atan2(a.se, a.fi); }\ndou angle(pd f, pd t) { return atan2(t.se - f.se, t.fi - f.fi); }\ndou distance(pd a, pd b) { return hypot(a.fi - b.fi, a.se - b.se); }\n//bを中心とするabcのtheta aからcにかけて時計回り\ndou angle(pd a, pd b, pd c) {    dou ax = a.fi - b.fi;    dou ay = a.se - b.se;    dou cx = c.fi - b.fi;    dou cy = c.se - b.se;    double ret = atan2(cy, cx) - atan2(ay, ax);    if (ret < 0) ret += 2 * PI;    return ret;}\n\ndou dot(pd a, pd b) { return a.fi * b.fi + a.se + b.se; }\ndou cro(pd a, pd b) { return a.fi * b.se - a.se + b.fi; }\n\n//機能拡張\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) { a.push(v); }template<class T, class U> void operator+=(deque<T> &a, U v) { a.push_back(v); }template<class T> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, vector<T> &v) {    fora(d, v)a.push(d);    return a;}template<class T, class U> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {    a.push(v);    return a;}template<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {    a.push(v);    return a;}template<class T> set<T> &operator+=(set<T> &a, vector<T> v) {    fora(d, v)a.insert(d);    return a;}template<class T, class U> auto operator+=(set<T> &a, U v) { return    a.insert(v);}template<class T, class U> auto operator-=(set<T> &a, U v) { return    a.erase(v);}template<class T, class U> auto operator+=(mset<T> &a, U v) { return a.insert(v); }template<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {    a.insert(v);    return a;}template<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {    a.push_back(v);    return a;}template<class T, class U> vector<T> operator+(const vector<T> &a, U v) {    vector<T> ret = a;    ret += v;    return ret;}template<class T, class U> vector<T> operator+(U v, const vector<T> &a) {    vector<T> ret = a;    ret.insert(ret.begin(), v);    return ret;}template<class T> vector<T> operator+(vector<T> a, vector<T> b) {    vector<T> ret;    ret = a;    fora(v, b)ret += v;    return ret;}template<class T> vector<T> &operator+=(vector<T> &a, vector<T> &b) {    fora(v, b)a += v;    return a;}template<class T> vector<T> &operator-=(vector<T> &a, vector<T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-=\");        deb(a);        deb(b);        exit(0);    }    rep(i, sz(a))a[i] -= b[i];    return a;}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector<T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-\");        deb(a);        deb(b);        ole();    }    vector<T> res(sz(a));    rep(i, sz(a))res[i] = a[i] - b[i];    return res;}\ntemplate<class T, class U> vector<T> operator*(vector<T> &a, U b) {    vector<T> ret;    fora(v, a)ret += v * b;    return ret;}\ntemplate<class T, class U> vector<T> operator/(vector<T> &a, U b) {    vector<T> ret;    fora(v, a)ret += v / b;    return ret;}\ntemplate<class T, class U> vector<T> operator*=(vector<T> &a, U b) {    fora(v, a)v *= b;    return a;}\ntemplate<class T, class U> vector<T> operator/=(vector<T> &a, U b) {    fora(v, a)v /= b;    return a;}\ntemplate<typename T> void erase(vector<T> &v, unsigned ll i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned ll s, unsigned ll e) { v.erase(v.begin() + s, v.begin() + e); }\ntemplate<class T, class U> void erase(map<T, U> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<class T> void erase(set<T> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<typename T> void erasen(vector<T> &v, unsigned ll s, unsigned ll n) { v.erase(v.begin() + s, v.begin() + s + n); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, vector<T> list) { for (auto &&va:list)v.insert(v.begin() + i++, va); }\ntemplate<typename T> void insert(set<T> &v, vector<T> list) { for (auto &&va :list)v.insert(va); }\nvector<string> split(const string a, const char deli) {    string b = a + deli;    ll l = 0, r = 0, n = b.size();    vector<string> res;    rep(i, n) {        if (b[i] == deli) {            r = i;            if (l < r)res.push_back(b.substr(l, r - l));            l = i + 1;        }    }    return res;}\nvector<string> split(const string a, const string deli) {    vector<string> res;    ll kn = sz(deli);    std::string::size_type Pos(a.find(deli));    ll l = 0;    while (Pos != std::string::npos) {        if (Pos - l)res.push_back(a.substr(l, Pos - l));        l = Pos + kn;        Pos = a.find(deli, Pos + kn);    }    if (sz(a) - l)res.push_back(a.substr(l, sz(a) - l));    return res;}\nvoid yn(bool a) { if (a)cout << \"yes\" << endl; else cout << \"no\" << endl; }\nvoid Yn(bool a) { if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl; }\nvoid YN(bool a) { if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl; }\nvoid fyn(bool a) {    if (a)cout << \"yes\" << endl; else cout << \"no\" << endl;    exit(0);}\nvoid fYn(bool a) {    if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl;    exit(0);}\nvoid fYN(bool a) {    if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl;    exit(0);}\nvoid Possible(bool a) {    if (a)cout << \"Possible\" << endl; else cout << \"Impossible\" << endl;    exit(0);}\nvoid POSSIBLE(bool a) {    if (a)cout << \"POSSIBLE\" << endl; else cout << \"IMPOSSIBLE\" << endl;    exit(0);}\n//@formatter:off\ntemplate<typename T> T minv(T a, T m);\ntemplate<typename T> T minv(T a);\n\ntemplate<typename T>\nclass Modular {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;    constexpr Modular() : value() {}    template<typename U>    Modular(const U &x) {        value = normalize(x);    }    template<typename U>    static Type normalize(const U &x) {        Type v;        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);        else v = static_cast<Type>(x % mod());        if (v < 0) v += mod();        return v;    }    const Type &operator()() const { return value; }    template<typename U>explicit operator U() const { return static_cast<U>(value); }    constexpr static Type mod() { return T::value; }    Modular &operator+=(const Modular &other) {        if ((value += other.value) >= mod()) value -= mod();        return *this;    }    Modular &operator-=(const Modular &other) {        if ((value -= other.value) < 0) value += mod();        return *this;    }    template<typename U> Modular &operator+=(const U &other) { return *this += Modular(other); }    template<typename U> Modular &operator-=(const U &other) { return *this -= Modular(other); }    Modular &operator++() { return *this += 1; }    Modular &operator--() { return *this -= 1; }    Modular operator++(signed) {        Modular result(*this);        *this += 1;        return result;    }    Modular operator--(signed) {        Modular result(*this);        *this -= 1;        return result;    }    Modular operator-() const { return Modular(-value); }\n    template<typename U = T>typename enable_if<is_same<typename Modular<U>::Type, signed>::value, Modular>::type &operator*=(const Modular &rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;asm(\"divl %4; \\n\\t\": \"=a\" (d), \"=d\" (m): \"d\" (xh), \"a\" (xl), \"r\" (mod()));value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template<typename U = T>    typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &operator*=(const Modular &rhs) {        int64_t q = static_cast<int64_t>(static_cast<double>(value) * rhs.value / mod());        value = normalize(value * rhs.value - q * mod());        return *this;    }    template<typename U = T>    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {        value = normalize(value * rhs.value);        return *this;    }    Modular &operator/=(const Modular &other) { return *this *= Modular(minv(other.value)); }    template<typename U> friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);    template<typename U> friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);    template<typename U> friend std::istream &operator>>(std::istream &stream, Modular<U> &number);    operator int() { return value; }private:    Type value;\n};\ntemplate<typename T> bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }template<typename T, typename U> bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }template<typename T, typename U> bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }template<typename T> bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }template<typename T, typename U> bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }template<typename T, typename U> bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }template<typename T> bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }template<typename T> Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }template<typename T, typename U> Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }template<typename T, typename U> Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }template<typename T> Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }template<typename T, typename U> Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }template<typename T, typename U> Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }template<typename T> Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }template<typename T, typename U> Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }template<typename T, typename U> Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }template<typename T> Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }template<typename T, typename U> Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }template<typename T, typename U> Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\nconstexpr signed MOD =\n//        998244353;\n1e9 + 7;//MOD\nusing mint = Modular<std::integral_constant<decay<decltype(MOD)>::type, MOD>>;\nconstexpr int mint_len = 1400001;\nvi fac, finv, inv;\nvi p2;\nmint com(int n, int r) {    if (r < 0 || r > n) return 0;    return mint(finv[r] * fac[n] % MOD * finv[n - r]);}\nmint pom(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;    return mint(fac[n] * finv[n - 1]);}\nmint npr(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;    return mint(fac[n] * finv[n - r]);}\nint nprin(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;    return fac[n] * finv[n - r] % MOD;}\nint icom(int n, int r) {    const int NUM_ = 1400001;    static ll fac[NUM_ + 1], finv[NUM_ + 1], inv[NUM_ + 1];    if (fac[0] == 0) {        inv[1] = fac[0] = finv[0] = 1;        for (int i = 2; i <= NUM_; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;        for (int i = 1; i <= NUM_; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;    }    if (r < 0 || r > n) return 0;    return ((finv[r] * fac[n] % MOD) * finv[n - r]) % MOD;}\n#define ncr com\n#define ncri icom\n//n個の場所にr個の物を置く\nmint nhr(int n, int r) { return com(n + r - 1, r); }\nmint hom(int n, int r) { return com(n + r - 1, r); }\nint nhri(int n, int r) { return icom(n + r - 1, r); }\ntemplate<typename T> T minv(T a, T m) {    T u = 0, v = 1;    while (a != 0) {        T t = m / a;        m -= t * a;        swap(a, m);        u -= t * v;        swap(u, v);    }    assert(m == 1);    return u;}\ntemplate<typename T> T minv(T a) {    if (a < mint_len)return inv[a];    T u = 0, v = 1;    T m = MOD;    while (a != 0) {        T t = m / a;        m -= t * a;        swap(a, m);        u -= t * v;        swap(u, v);    }    assert(m == 1);    return u;}\ntemplate<typename T, typename U> Modular<T> mpow(const Modular<T> &a, const U &b) {    assert(b >= 0);    int x = a(), res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= MOD;        (x *= x) %= MOD;        p >>= 1;    }    return res;}\ntemplate<typename T, typename U, typename V> mint mpow(const T a, const U b, const V m = MOD) {    assert(b >= 0);    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= m;        (x *= x) %= m;        p >>= 1;    }    return res;}\ntemplate<typename T, typename U> mint mpow(const T a, const U b) {    assert(b >= 0);    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= MOD;        (x *= x) %= MOD;        p >>= 1;    }    return res;}\ntemplate<typename T, typename U, typename V> int mpowi(const T &a, const U &b, const V &m = MOD) {    assert(b >= 0);    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= m;        (x *= x) %= m;        p >>= 1;    }    return res;}\ntemplate<typename T> string to_string(const Modular<T> &number) {    return to_string(number());}\nstring yuri(const mint &a) {    stringstream st;    rep(i, 300) {rep(j, 300) {if ((mint) i / j == a) {st << i << \" / \" << j;return st.str();}}}    rep(i, 1000) {rep(j, 1000) {if ((mint) i / j == a) {st << i << \" / \" << j;return st.str();}}}    return st.str();}\ntemplate<typename T> std::ostream &operator<<(std::ostream &stream, const Modular<T> &number) {stream << number();\n#ifdef _DEBUG\n//    stream << \" -> \" << yuri(number);\n#endif\n    return stream;\n}\n//@formatter:off\ntemplate<typename T> std::istream &operator>>(std::istream &stream, Modular<T> &number) {    typename common_type<typename Modular<T>::Type, int64_t>::type x;    stream >> x;    number.value = Modular<T>::normalize(x);    return stream;}\nusing PM = pair<mint, mint>;\nusing vm = vector<mint>;\nusing mapm = map<int, mint>;\nusing umapm = umap<int, mint>;\n#define vvm(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(mint,__VA_ARGS__)\n#define vnm(name, ...) auto name = make_v<mint>(__VA_ARGS__)\n\nstruct setmod{\n    setmod() {\n//    p2.resize(mint_len);p2[0] = 1; for (int i = 1; i < mint_len; ++i) p2[i] = p2[i - 1] * 2 % MOD;\n        fac.resize(mint_len);    finv.resize(mint_len);    inv.resize(mint_len);    inv[1] = fac[0] = finv[0] = 1;    for (int i = 2; i < mint_len; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;    for (int i = 1; i < mint_len; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}setmodv;\n//@formatter:on\n//nhr n個の場所にr個の物を分ける\n\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} initonv;//@formatter:on\n\n//gra mll pr\n//上下左右\nconst string udlr = \"udlr\";\nstring UDLR = \"UDLR\";//x4と連動 UDLR.find('U') := x4[0]\n//右、上が正\nconstexpr ll y4[] = {1, -1, 0, 0};\nconstexpr ll x4[] = {0, 0, -1, 1};\nconstexpr ll y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n\nll n, m, k, d, H, W, x, y, z, q;\nll cou;\nvi t, a, b, c;\n//vvi (s, 0, 0);\nvvc (ba, 0, 0);\nvp p;\nstr s;\nstruct pbds_sum {\n    //@formatter:off\n    template<typename T = int> class BIT {\n    public:\n        int n;        vector<T> dat;        BIT(int n) : n(n) { dat.assign(n, 0); }        T sum(int k) {            if (k >= n) k = n - 1;            T ret = 0;            for (int x = k - 1; x >= 0; x = (x & (x + 1)) - 1) { ret += dat[x]; }            return ret;        }        T sum(int l, int r) { return sum(r) - sum(l); }        T get(int l, int r) { return sum(r) - sum(l); }        T get(int k) { return sum(k); }        T operator[](int k) {            assert(0 <= k && k < n);            return sum(k + 1) - sum(k);        }        T operator()(int k) { return sum(k); }        T operator()(int l, int r) { return sum(l, r); }        void add(int k, T val = 1) { for (int x = k; x < n; x |= x + 1)dat[x] += val; }        void update(int k, T val = 0) { add(k, -operator[](k) + val); }        void del(int k) { update(k, 0); }        void clear() { fill(dat, 0); }        void debu() {\n#ifdef _DEBUG\n            vi res;            rep(i, min(10ll, n)) { res.push_back(operator[](i)); }            deb(res);\n#endif\n        }\n        int lower_bound(int w) {            if (w <= 0) return -1;            int x = 0;            int k = 1;            while ((k << 1) <= n) k <<= 1;            for (; k > 0; k >>= 1) {                if (x + k <= n && dat[x + k - 1] < w) {                    w -= dat[x + k - 1];                    x += k;                }            }            return x;        }\n    };\n    BIT<int> bco, bsu;\n    umapi v_i;\n    vi i_v;\n    int count = 0;\n    //クエリの順番が分かってる場合の高速化はとりあえずしない(十分高速なため)\n    //クエリの順番が入れ替わってもいいようにする\n    pbds_sum(vi &a) : bco(sz(a) + 3), bsu(sz(a) + 3) {        vi b = a;        b.push_back(linf + 100);        i_v = compress(b);        rep(i, sz(a)) { v_i[a[i]] = b[i]; }    }\n    pbds_sum(vi &a, vi &b) : bco(sz(a) + sz(b) + 3), bsu(sz(a) + sz(b) + 3) {        vi c = a;        vi d = b;        c.push_back(linf + 100);        d.push_back(linf + 100);        i_v = compress(c, d);        rep(i, sz(a)) {            v_i[a[i]] = c[i];            v_i[b[i]] = d[i];        }    }\n    pbds_sum(vi &a, vi &b, vi &c) : bco(sz(a) + sz(b) + sz(c) + 3), bsu(sz(a) + sz(b) + sz(c) + 3) {        vi d = a;        vi e = b;        vi f = c;        d.push_back(linf + 100);        e.push_back(linf + 100);        f.push_back(linf + 100);        i_v = compress(d, e, f);        rep(i, sz(a)) {            v_i[a[i]] = d[i];            v_i[b[i]] = e[i];            v_i[c[i]] = f[i];        }    }\n    void add(int v, int c = 1) {count += c;        int ind = v_i[v];        bco.add(ind, c);        bsu.add(ind, v * c);    }\n    void operator+=(int v){int c=1;        count += c;        int ind = v_i[v];        bco.add(ind, c);        bsu.add(ind, v * c);    }\n    //開区間\n    int sum() {return bsu.sum(inf);    }\n    int sum(int rv) {        int i = (std::lower_bound(all(i_v), rv) - i_v.begin());        return bsu.sum(i);    }\n    //半開区間 l rは存在しない値でもいい\n    int sum(int l, int r) { return sum(r) - sum(l); }\n    //クエリ候補全ての中でのi\n    int sum_it(int li, int ri) {return bsu.sum(ri) - bsu.sum(li);}\n    //[l番目からr)番目の合計(種類数ではなく重複込みの番号)\n    //r個の合計\n    /*@formatter:on*/\n    int sum_order(int r) {\n        int rti = bco.lower_bound(r + 1);\n        int res = bsu.sum(rti);\n        if (rti != bco.n) {\n            int l = bco.sum(rti);\n            res += (r - l) * i_v[rti];\n        }\n        return res;\n    }\n    //右からr個の合計\n    /*@formatter:on*/\n    int sum_order_r(int r) {\n        int a = bsu.sum(0, inf);\n        int b = sum_order(count - r);\n        return a - b;\n    }\n    /*@formatter:off*/\n    int sum_order(int l,int r){return sum_order(r)-sum_order(l);}\n    int cou(int rv) {int i = (std::lower_bound(all(i_v), rv) - i_v.begin());return bco.sum(i);}\n    //半開区間 l rは存在しない値でもいい\n    int cou(int l, int r) { return cou(r) - cou(l); }\n    int cou_it(int ri) {        return bco.sum(ri);    }\n    int cou_it(int li, int ri) {        return bco.sum(ri) - bco.sum(li);    }\n    //k番目の要素を返す\n    int find_by_order(int k) {        int i = bco.lower_bound(k + 1);        if (i >= sz(i_v)) {            cerr << \"find_by_order(\" << k << \") k >=\" << sz(i_v) << endl;            exit(0);        }        return i_v[i];    }\n    //vは何番目に入るか\n    int order_of_key(int v) {        v = *std::lower_bound(all(i_v), v);        int i = v_i[v];        return bco.sum(i);    }\n    //中央値を返す (左寄り)\n    int mid() { return find_by_order((count - 1) >> 1); }\n    int mid(int lv, int rv) {        int lcou = cou(lv);        int rcou = cou(rv);        int wantk = lcou + ((rcou - lcou - 1) >> 1);        return find_by_order(wantk);    }\n    int mid_it(int li, int ri) {        int lcou = bco.sum(li );        int rcou = bco.sum(ri );        int wantk = lcou + ((rcou - lcou - 1) >> 1);        return find_by_order(wantk);    }\n    int mid_it(int ri) {        return mid_it(0, ri);    }\n    //全要素との 最小の差の和をかえす (全要素の中央値との差の和)\n    int min_dis() {        int mv = mid();        int mi = v_i[mv];        int lcou = bco.sum(mi);        int rcou = bco.sum(mi + 1, linf);        int lsum = mv * lcou - bsu.sum(mi);        int rsum = bsu.sum(mi + 1, linf) - mv * rcou;        return lsum + rsum;    }\n    int min_dis(int lv, int rv) {        int li = (std::lower_bound(all(i_v), lv) - i_v.begin());        int ri = (std::lower_bound(all(i_v), rv) - i_v.begin());        int mv = mid_it(li, ri);        int mi = v_i[mv];        int lcou = cou_it(li, mi);        int rcou = cou_it(mi, ri);        return mv * lcou - sum_it(li, mi) + sum_it(mi, ri) - mv * rcou;    }\n    int min_dis_i(int li, int ri) {        int mv = mid_it(li, ri);        int mi = v_i[mv];        int lcou = cou_it(li, mi);        int rcou = cou_it(mi, ri);        return mv * lcou - sum_it(li, mi) + sum_it(mi, ri) - mv * rcou;    }\n    //vをc個消す\n    void erase(int v, int c = 1) {        int ind = v_i[v];        assert(bco[ind] >= c);        count -= c;        bco.add(ind, -c);        bsu.add(ind, v * -c);    }\n    void operator-=(int v){erase(v);}\n    int lower_bound(int v) {        v = *std::lower_bound(all(i_v), v);        int i = v_i[v];        int needc = bco.sum(i) + 1;        i = bco.lower_bound(needc);        return i_v[i];    }\n    int upper_bound(int v) { return lower_bound(v + 1); }\n    void debu(){\n        bsu.debu();\n        bco.debu();\n        cerr<<\"\"<<endl;\n    }\n    //@formatter:on\n};\n\n//固定された要素に使う場合は\n//pbds_con\n//itは圧縮後のインデックスであり\n//自然に使おうとするとおかしくなるため\n\n\nvoid solve() {\n    in(n, q);\n    n *= 2;\n    na(a, n);\n    na(b, n);\n    vi c = a - b;\n    int base = sum(b) - b[0] - b[n - 1] + a[0] + a[n - 1];\n    dna3(p, x, y, q);\n    vi d = c + (x - y);\n    pbds_sum s(d);\n    rep(i, 1, n - 1) {\n        s += c[i];\n    }\n    rep(i, q) {\n//        s.debu();\n        int pp = p[i] - 1, xx = x[i], yy = y[i];\n        s -= c[pp];\n        base -= b[pp];\n        c[pp] = xx - yy;\n        a[pp] = xx;\n        b[pp] = yy;\n        s += c[pp];\n        base += b[pp];\n        auto cal = [&](int k) {\n            int v = s.sum_order_r(k*2);\n            return v;\n        };\n        int k = goldt_l(0, (n) / 2 - 1, cal);\n        cout << base + s.sum_order_r(k*2) << endl;\n//        s.debu();\n    }\n}\nll my(ll n, vi &a) {\n    return 0;\n}\nll sister(ll n, vi &a) {\n    ll ret = 0;\n    return ret;\n}\n\nsigned main() {\n    solve();\n\n#define arg n,a\n#ifdef _DEBUG\n    bool bad = 0;\n    for (ll i = 0, ok = 1; i < k5 && ok; ++i) {\n        ll n = rand(1, 8);\n        vi a = ranv(n, 1, 10);\n        ll myres = my(arg);\n        ll res = sister(arg);\n        ok = myres == res;\n        if (!ok) {\n            out(arg);\n            cerr << \"AC : \" << res << endl;\n            cerr << \"MY  : \" << myres << endl;\n            bad = 1;\n            break;\n        }\n    }\n    if (!bad) {\n//        cout << \"完璧 : solveを書き直そう\" << endl;\n//        cout << \"     : そして、solve()を呼び出すのだ\" << endl;\n//        cout << \"     : cin>>n; na(a,n);も忘れるな\" << endl;\n    }\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i, n, m) for(int i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = std::int_fast64_t;\nusing ld = long double;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 1000000007;\nconstexpr long double eps = 1e-15;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n\tos << to_string(p.first) << \" \" << to_string(p.second);\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n\tREP(i, v.size()) {\n\t\tif(i) os << \" \";\n\t\tos << to_string(v[i]);\n\t}\n\treturn os;\n}\n\n/*\ntemplate<typename T>\nstruct Treap {\n\tdouble drand() { // random number in [0, 1]\n\t\tstatic random_device rd;\n\t\tstatic mt19937 mt(rd());\n\t\treturn (unsigned)mt() / (double)numeric_limits<unsigned>::max();\n\t}\n\tT v;\n\tdouble p;\n\tint cnt;\n\tTreap* lch;\n\tTreap* rch;\n\tTreap(T v) : v(v), p(drand()), cnt(1), lch(NULL), rch(NULL) { }\n\tTreap* update() {\n\t\tthis->size = size(this->lch) + size(this->rch) + 1;\n\t\treturn this;\n\t}\n\tstatic int size(Treap* t) {\n\t\tif(!t) return 0;\n\t\telse return t->cnt;\n\t}\n\tstatic Treap* merge(Treap* l, Treap* r) {\n\t\tif(!l || !r) {\n\t\t\tif(!l) return r;\n\t\t\telse return l;\n\t\t}\n\t\tif(l->p >= r->p) {\n\t\t\tl->rch = merge(l->rch, r);\n\t\t\treturn l->update();\n\t\t} else {\n\t\t\tr->lch = merge(r->lch, l);\n\t\t\treturn r->update();\n\t\t}\n\t}\n\tstatic pair<Treap*, Treap*> split(Treap* t, int k) {\n\t\t// split [0, k) and [k, n)\n\t\tif(k == 0) return {NULL, t};\n\t\tif(!(t->l)) {\n\t\t\tauto tmp = split(t->r, k - 1);\n\t\t\tt->r = tmp.first;\n\t\t\treturn {t->update(), tmp.second};\n\t\t} else if(!(t->r)) {\n\t\t\tauto tmp = split(t->r, k - 1);\n\t\t\tt->r = tmp.first;\n\t\t\treturn {t->update(), tmp.second};\n\t\t} else {\n\n\t\t}\n\t}\n\tTreap* insert() {\n\t}\n\tTreap* erase() {\n\t}\n\tT operator[](int k) {\n\t}\n};\n*/\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q;\n\tcin >> n >> q;\n\tvector<ll> a(2 * n), b(2 * n);\n\tREP(i, 2 * n) cin >> a[i];\n\tREP(i, 2 * n) cin >> b[i];\n\tll sum1 = 0, sum2 = 0;\n\tREP(i, 2 * n) sum1 += a[i];\n\tset<pair<ll, ll>> st;\n\tFOR(i, 1, 2 * n - 1) {\n\t\tif(b[i] - a[i] >= 0) {\n\t\t\tst.insert({b[i] - a[i], i});\n\t\t\tsum2 += b[i] - a[i];\n\t\t}\n\t}\n\tREP(i, q) {\n\t\tll p, x, y;\n\t\tcin >> p >> x >> y;\n\t\tp--;\n\t\tsum1 -= a[p]; sum1 += x;\n\t\tif(p != 0 && p != 2 * n - 1) {\n\t\t\tif(b[p] - a[p] >= 0) {\n\t\t\t\tst.erase({b[p] - a[p], p});\n\t\t\t\tsum2 -= (b[p] - a[p]);\n\t\t\t}\n\t\t\tif(y - x >= 0) {\n\t\t\t\tst.insert({y - x, p});\n\t\t\t\tsum2 += y - x;\n\t\t\t}\n\t\t}\n\t\ta[p] = x; b[p] = y;\n\t\tif((int)st.size() % 2 == 0) {\n\t\t\tcout << sum1 + sum2 << endl;\n\t\t} else {\n\t\t\tcout << sum1 + sum2 - st.begin()->first << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n// ---------------------------------------\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\nusing namespace std;\ntypedef long long int LL;\nconst LL INF=(LL)1<<32;\ntypedef pair<LL,int> P;\npriority_queue<P,vector<P>,greater<P> > q1,q2;\nLL t[200005][2];\nLL s[200005];\nint main(){\n\tint n,m;\n\tint i,j,k;\n\tLL a,b,c;\n\tint equ=0,big=0;\n\tLL st;\n\tcin>>n>>m;\n\tfor(i=0;i<2;i++){\n\t\tfor(j=0;j<2*n;j++){\n\t\t\tcin>>t[j][i];\n\t\t}\n\t}\n\tst=t[0][0]+t[2*n-1][0];\n\tfor(i=1;i<2*n-1;i++){\n\t\tif(t[i][0]==t[i][1])equ++,st+=t[i][0];\n\t\telse if(t[i][0]>t[i][1])big++,st+=t[i][0],q1.push(make_pair(t[i][0]-t[i][1],i));\n\t\telse st+=t[i][1],q2.push(make_pair(t[i][1]-t[i][0],i));\n\t}\n\tfor(i=0;i<m;i++){\n\t\tcin>>a>>b>>c;\n\t\ta--;\n\t\tif(a==0 || a==2*n-1){\n\t\t\tst+=b-t[a][0];\n\t\t\tt[a][0]=b,t[a][1]=c;\n\t\t\ts[i]=st;\n\t\t\tcontinue;\n\t\t}\n\t\tif(t[a][0]==t[a][1])equ--,st-=t[a][0];\n\t\telse if(t[a][0]>t[a][1])big--,st-=t[a][0];\n\t\telse st-=t[a][1];\n\t\tt[a][0]=b,t[a][1]=c;\n\t\tif(t[a][0]==t[a][1])equ++,st+=t[a][0];\n\t\telse if(t[a][0]>t[a][1])big++,st+=t[a][0],q1.push(make_pair(t[a][0]-t[a][1],a));\n\t\telse st+=t[a][1],q2.push(make_pair(t[a][1]-t[a][0],a));\n\t\t\n\t\tif(equ>0 || big%2==0){\n\t\t\ts[i]=st;\n\t\t\tcontinue;\n\t\t}\n\t\ta=INF,b=INF;\n\t\twhile(!q1.empty()){\n\t\t\tc=q1.top().second;\n\t\t\tif(t[c][0]-t[c][1]==q1.top().first){\n\t\t\t\ta=t[c][0]-t[c][1];\n\t\t\t\tbreak;\n\t\t\t}else q1.pop();\n\t\t}\n\t\twhile(!q2.empty()){\n\t\t\tc=q2.top().second;\n\t\t\tif(t[c][1]-t[c][0]==q2.top().first){\n\t\t\t\tb=t[c][1]-t[c][0];\n\t\t\t\tbreak;\n\t\t\t}else q2.pop();\n\t\t}\n\t\tif(a>b)a=b;\n\t\ts[i]=st-a;\n\t}\n\tfor(i=0;i<m;i++){\n\t\tcout<<s[i]<<endl;\n\t}\n\treturn 0;\n}\n\t\t\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb push_back\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF INT_MAX/3\n\nll n,q;\nll a[201010],b[201010];\n\nint main(){\n  cin>>n>>q;\n  n*=2;\n  rep(i,n)cin>>a[i];\n  rep(i,n)cin>>b[i];\n  vector<ll> v;\n  ll score=0;\n  if(q!=1)return 0;\n  ll p,pa,pb;\n  cin>>p>>pa>>pb;\n  p--;\n  a[p]=pa; b[p]=pb;\n  repl(i,1,n-1){\n    v.push_back(b[i]-a[i]);\n  }\n  sort(all(v),greater<ll>());\n  rep(i,n)score+=a[i];\n  rep(i,v.size()-1){\n    if(v[i]+v[i+1]>0){\n      score+=v[i]+v[i+1];\n      i++;\n    }else break;\n  }\n  cout<<score<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint main() {\n        int n, q;\n        scanf(\"%d%d\", &n, &q);\n        n = 2 * n;\n        vector<long long> a(n), b(n);\n        for (int i = 0; i < n; i ++) scanf(\"%lld\", &a[i]);\n        for (int i = 0; i < n; i ++) scanf(\"%lld\", &b[i]);\n        multiset<long long> positive, negative;\n        long long psum = 0, nsum = 0;\n        for (int i = 0; i < n; i ++) {\n                if (i == 0 || i == n - 1) {\n                        psum += a[i];\n                        continue;\n                }\n                long long c = a[i] - b[i];\n                if (c >= 0) { \n                        positive.insert(c);\n                        psum += a[i];\n                } else { \n                        negative.insert(- c);\n                        nsum += b[i];\n                }\n        }\n        while (q --) {\n                int p;\n                long long x, y;\n                scanf(\"%d%lld%lld\", &p, &x, &y);\n                p --;\n                if (p == 0 || p == n - 1) {\n                        psum -= a[p];\n                        psum += x;\n                        a[p] = x;\n                } else {\n                        //remove\n                        long long c = a[p] - b[p];\n                        if (c >= 0) {\n                                positive.erase(positive.find(c));\n                                psum -= a[p];\n                        } else {\n                                negative.erase(negative.find(-c));\n                                nsum -= b[p];\n                        }\n                        //insert\n                        long long z = x - y;\n                        if (z >= 0) {\n                                positive.insert(z);\n                                psum += x;\n                        } else {\n                                negative.insert(-z);\n                                nsum += y;\n                        }\n                }\n                a[p] = x;\n                b[p] = y;\n                long long ans;\n                if (positive.size() % 2 == 0) ans = psum + nsum;\n                else ans = psum + nsum - min(*positive.begin(), *negative.begin());\n                printf(\"%lld\\n\", ans);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nlong long bit[400010],a[200010],b[200010],p[100010],x[100010],y[100010],n,q,inv[300010],m;\nvector<long long> v;\nmap<long long,long long> mp;\nint sum(int i){\n\tint s = 0;\n\twhile(i>0){\n\t\ts += bit[i];\n\t\ti -= i&-i;\n\t}\n\treturn s;\n}\n\nvoid add(int i, int x){\n\twhile(i<=m){\n\t\tbit[i] += x;\n\t\ti += i&-i;\n\t}\n}\nint main(){\n\tint z,ans = 0;\n\tcin >> n >> q;\n\tint i;\n\tfor(i=0;i<2*n;i++){\n\t\tcin >> a[i];\n\t}\n\tfor(i=0;i<2*n;i++){\n\t\tcin >> b[i];\n\t}\n\tfor(i=1;i<2*n-1;i++){\n\t\tv.push_back(a[i]-b[i]);\n\t}\n\tfor(i=0;i<q;i++){\n\t\tcin >> p[i] ;\n\t\tp[i]--;\n\t\tif(p[i]!=0 && p[i]!=2*n-1){\n\t\t\tcin>> x[i] >> y[i];\n\t\t\tv.push_back(x[i]-y[i]);\n\t\t}\n\t}\n\tm = v.size()+1;\n\tv.push_back(0);\n\tsort(v.begin(),v.end());\n\tint now = 1;\n\tmp[v[0]] = 1;\n\tinv[1] = v[0];\n\tif(v[0]==0){\n\t\tz = 1;\n\t}\n\tfor(i=1;i<v.size();i++){\n\t\tif(v[i]>v[i-1]){\n\t\t\tnow++;\n\t\t}\n\t\tmp[v[i]] = now;\n\t\tinv[now] = v[i];\n\t\tif(v[i]==0){\n\t\t\tz = now;\n\t\t}\n\t}\n\tnow++;\n\tint cnt = 0;\n\tfor(i=1;i<2*n-1;i++){\n\t\tadd(mp[a[i]-b[i]],1);\n\t\tif(a[i]>=b[i]){\n\t\t\tans += a[i];\n\t\t\tcnt += 1;\n\t\t}else{\n\t\t\tans += b[i];\n\t\t}\n\t}\n\tfor(i=1;i<now;i++){\n\t\t//cout << i << \" \" << sum(i) << endl;\n\t}\n\tfor(i=0;i<now;i++){\n\t\t//cout << i << \" \" << inv[i] << endl;\n\t}\n\tfor(i=0;i<now;i++){\n\t\t//cout << i << \" \" << sum(i) << endl;\n\t}\n\tans += a[0]+a[2*n-1];\n\tfor(i=0;i<q;i++){\n\t\tans -= max(a[p[i]],b[p[i]]);\n\t\tans += max(x[i],y[i]);\n\t\t//cout << a[p[i]] << \" \" << b[p[i]] << \" \" << x[i] << \" \" << y[i] << \" \" << ans <<\" \" << cnt<< endl;\n\t\tfor(int j=0;j<now;j++){\n\t\t\t//cout << j << \" \" << sum(j) << endl;\n\t\t}\n\t\tif(p[i]==0 || p[i]==2*n-1){\n\t\t\ta[p[i]] = x[i];\n\t\t\tb[p[i]] = y[i];\n\t\t\tcout << ans << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tadd(mp[a[p[i]] - b[p[i]]],-1);\n\t\tadd(mp[x[i] - y[i]],1);\n\t\tif(a[p[i]]-b[p[i]]>0 ^ x[i]-y[i]>0){\n\t\t\tcnt++;\n\t\t}\n\t\ta[p[i]] = x[i];\n\t\tb[p[i]] = y[i];\n\t\tif(cnt%2==0){\n\t\t\tcout << ans << endl;\n\t\t}else{\n\t\t\tlong long l=0,r=now,mid;\n\t\t\tint s = sum(z);\n\t\t\t//cout << l << \" \" << r << \" \" << z << endl;\n\t\t\t//cout << s << endl;\n\t\t\twhile(r - l>1){\n\t\t\t\t//cout << l << \" \" << r << \" \" << endl;\n\t\t\t\tmid = (l+r)/2;\n\t\t\t\tif(sum(mid)>=s+1){\n\t\t\t\t\tr = mid;\n\t\t\t\t}else{\n\t\t\t\t\tl = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << r << endl;\n\t\t\tlong long m1 = inv[r];\n\t\t\tl=0,r=now;\n\t\t\twhile(r - l>1){\n\t\t\t\t//cout << l << \" \" << r << endl;\n\t\t\t\tmid = (l+r)/2;\n\t\t\t\tif(sum(mid)<s){\n\t\t\t\t\tl = mid;\n\t\t\t\t}else{\n\t\t\t\t\tr = mid;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << r << endl;\n\t\t\tlong long m2 = inv[r];\n\t\t\t//cout << m1 << \" \" << m2 << \" \" << endl;\n\t\t\tcout << max(ans - m1,ans + m2) << endl;\n\t\t}\n\t}\n}\n\t\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nmap<int,int>mp1,mp2;\nint n,T,a[202000],b[202000],cnt;\nll sum=0,bas=0;\n\nvoid add(int x){\n\tif (x>=0) ++mp1[x], sum+=x, ++cnt;\n\telse ++mp2[-x];\n}\nvoid del(int x){\n\tif (x>=0){\n\t\tsum-=x, --cnt;\n\t\tif (!(--mp1[x])) mp1.erase(x);\n\t}else{\n\t\tif (!(--mp2[-x])) mp2.erase(-x);\n\t}\n}\n\nll doit(){\n\tif (!(cnt&1)) return sum;\n\treturn sum+max(-mp1.begin()->first,-mp2.begin()->first);\n}\n\nint main(){\n\tcin>>n>>T; n<<=1;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&b[i]);\n\tfor (int i=2;i<n;i++) add(a[i]-b[i]), bas+=b[i];\n\tfor (int p,x,y;T--;){\n\t\tscanf(\"%d%d%d\",&p,&x,&y);\n\t\tif (p!=1&&p!=n){\n\t\t\tdel(a[p]-b[p]); bas-=b[p];\n\t\t\tadd((a[p]=x)-(b[p]=y));\tbas+=b[p];\n\t\t}\n\t\ta[p]=x, b[p]=y;\n\t\tprintf(\"%lld\\n\",bas+a[1]+a[n]+doit());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\nll ugauss(ll a, ll b) { if (!a) return 0; if (a>0^b>0) return a/b; else return (a+(a>0?-1:1))/b+1; }\nll lgauss(ll a, ll b) { if (!a) return 0; if (a>0^b>0) return (a+(a>0?-1:1))/b-1; else return a/b; }\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; o << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const deque<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const multiset<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const unordered_set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U, typename V>  ostream &operator<<(ostream &o, const unordered_map<T, U, V> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvector<int> range(const int x, const int y) { vector<int> v(y - x + 1); iota(v.begin(), v.end(), x); return v; }\ntemplate <typename T> istream& operator>>(istream& i, vector<T>& o) { rep(j, o.size()) i >> o[j]; return i;}\ntemplate <typename T, typename S, typename U> ostream &operator<<(ostream &o, const priority_queue<T, S, U> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const queue<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.front(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const stack<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} return o; }\ntemplate <typename T> unordered_map<T, ll> counter(vector<T> vec){unordered_map<T, ll> ret; for (auto&& x : vec) ret[x]++; return ret;};\nvoid vizGraph(vvll& g, int mode = 0, string filename = \"out.png\") { ofstream ofs(\"./out.dot\"); ofs << \"digraph graph_name {\" << endl; set<P> memo; rep(i, g.size())  rep(j, g[i].size()) { if (mode && (memo.count(P(i, g[i][j])) || memo.count(P(g[i][j], i)))) continue; memo.insert(P(i, g[i][j])); ofs << \"    \" << i << \" -> \" << g[i][j] << (mode ? \" [arrowhead = none]\" : \"\")<< endl;  } ofs << \"}\" << endl; ofs.close(); system(((string)\"dot -T png out.dot >\" + filename).c_str()); }\nstruct timeval start; double sec() { struct timeval tv; gettimeofday(&tv, NULL); return (tv.tv_sec - start.tv_sec) + (tv.tv_usec - start.tv_usec) * 1e-6; }\nsize_t random_seed; struct init_{init_(){ ios::sync_with_stdio(false); cin.tie(0); gettimeofday(&start, NULL); struct timeval myTime; struct tm *time_st; gettimeofday(&myTime, NULL); time_st = localtime(&myTime.tv_sec); srand(myTime.tv_usec); random_seed = RAND_MAX / 2 + rand() / 2; }} init__;\n#define ldout fixed << setprecision(40) \n\n#define EPS (double)1e-14\n#define INF (ll)1e18\n#define mo  (ll)(1e9+7)\n\n// sの括弧列の全列挙\n// O(2^n), n = 32までは現実的な時間で終わる\n// 0 1 // 2 1 // 4 2 // 6 5 // 8 14 // 10 42 // 12 132 // 14 429 // 16 1430 // 18 4862 // 20 16796\n// 22 58786 // 24 208012 // 26 742900 // 28 2674440 // 30 9694845 // 32 35357670 // 34 129644790\nvoid numerateParentheses(int n, vector<ll>& q_next) {\n    q_next.clear();\n    if (n < 0 || n % 2) return;\n    vector<ll> q;\n    q_next.pb(0);\n    ll t = 0;\n    while (t < n && !q_next.empty()) {\n        q.swap(q_next);\n        while (!q.empty()) {\n            ll tmp = q.back(); q.pop_back();\n            if (__builtin_popcount(tmp) > t / 2) // if 011->2,3/2=1 ->OK, 0011->2, 4/2=2->NG\n                q_next.pb(tmp); // Down\n            if (__builtin_popcount(tmp) < n / 2)\n                q_next.pb(tmp | (1ll << t)); // Up\n        }\n        t++;\n    }\n}\n\n\nint main(void) {\n    ll n, q; cin >> n >> q;\n    n *= 2;\n    vll a(n); cin >> a;\n    vll b(n); cin >> b;\n    vll d(n); rep(i, n) d[i] = b[i] - a[i];\n    ll asum = accumulate(all(a), 0ll);\n    multiset<ll> pos, neg;\n    repi(i, 1, n-1) {\n        (d[i] >= 0 ? pos : neg).insert(d[i]);\n    }\n    ll possum = 0;\n    for (auto x : pos) possum += x;\n    rep(_, q) {\n        ll p, x, y; cin >> p >> x >> y; p--;\n        asum += x - a[p];\n        if (!(p == 0 || p == n-1)) {\n\n            if (b[p] - a[p] >= 0) possum -= (b[p] - a[p]);\n            auto& target = (b[p] - a[p] >= 0 ? pos : neg);\n\n            target.erase(target.find(b[p] - a[p]));\n            (y - x >= 0 ? pos : neg).insert(y - x);\n            if (y - x >= 0) possum += y - x;\n\n\n        }\n            a[p] = x;\n            b[p] = y;\n            d[p] = y - x;\n\n            /*\n        cout << asum << endl;\n        cout << pos << endl;\n        cout << neg << endl;\n        cout << possum << endl;\n        */\n        if (pos.size() % 2 == 0) {\n            cout << asum + possum << endl;\n        } else {\n            cout << max(asum + possum - *pos.begin(), asum + possum + *neg.rbegin()) << endl;\n        }\n    }\n\n    /*\n       const ll n = 8;\n       vll p;\n       numerateParentheses(n, p);\n       set<ll> s;\n       for (auto x : p) for (auto y : p) {\n       auto tmp = (bitset<n>(x) ^ bitset<n>(y));\n       s.insert(tmp.to_ulong());\n       cout << tmp << endl;\n       }\n       cout << s << endl;\n       cout << s.size() << endl;\n       */\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\nusing namespace std;\n\nmap<int,int>mp1,mp2;\nint n,T,a[202000],b[202000],cnt;\nll sum=0,bas=0;\n\nvoid add(int x){\n\tif (x>=0) ++mp1[x], sum+=x, ++cnt;\n\telse ++mp2[-x];\n}\nvoid del(int x){\n\tif (x>=0){\n\t\tsum-=x, --cnt;\n\t\tif (!(--mp1[x])) mp1.erase(x);\n\t}else{\n\t\tif (!(--mp2[-x])) mp2.erase(-x);\n\t}\n}\n\nll doit(){\n\tif (!(cnt&1)) return sum;\n\treturn sum+max(-mp1.begin()->first,-mp2.begin()->first);\n}\n\nint main(){\n\tcin>>n>>T; n<<=1;\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor (int i=1;i<=n;i++) scanf(\"%d\",&b[i]);\n\tfor (int i=2;i<n;i++) add(a[i]-b[i]), bas+=b[i];\n\tfor (int p,x,y;T--;){\n\t\tscanf(\"%d%d%d\",&p,&x,&y);\n\t\tif (p!=1&&p!=n){\n\t\t\tdel(a[p]-b[p]); bas-=b[p];\n\t\t\tadd((a[p]=x)-(b[p]=y));\tbas+=b[p];\n\t\t}\n\t\tprintf(\"%lld\\n\",bas+a[1]+a[n]+doit());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e16)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstruct SegmentTree {\nprivate:\n    int n;\n    vector<ll> node_plus;\n    vector<ll> node_minus;\n \npublic:\n    SegmentTree() {\n        int sz = 200005;\n        n = 1; while(n < sz) n *= 2;\n        node_plus.resize(2*n-1, INF);\n        node_minus.resize(2*n-1, -INF);\n        for(int i = 0; i < node_plus.size(); i++){\n            node_plus[i] = INF;\n            node_minus[i] = -INF;\n        }\n    }\n \n    void update(int x, ll val) {\n        x += (n - 1);\n        if(val >= 0){\n            node_minus[x] = -INF;\n            node_plus[x] = val;\n        } else {\n            node_minus[x] = val;\n            node_plus[x] = INF;\n        }\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node_minus[x] = max(node_minus[2*x+1], node_minus[2*x+2]);\n            node_plus[x] = min(node_plus[2*x+1], node_plus[2*x+2]);\n            //node[x] = min(node[2*x+1], node[2*x+2]);\n        }\n    }\n    // hannkaikukann \n    ll getminus(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return -INF;\n        if(a <= l && r <= b) return node_minus[k];\n \n        ll vl = getminus(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getminus(a, b, 2*k+2, (l+r)/2, r);\n        return max(vl, vr);\n    }\n    ll getplus(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return INF;\n        if(a <= l && r <= b) return node_plus[k];\n \n        ll vl = getplus(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getplus(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n};\n\n\nint main() {\n    //cout.precision(10);\n    SegmentTree seg;\n    int n, q;\n    cin >> n >> q;\n    ll a[200500];\n    ll b[200500];\n    ll asum = 0;\n    for(int i = 1; i <= 2 * n; i++){\n        cin >> a[i];\n        asum += a[i];\n    }\n    for(int i = 1; i <= 2 * n; i++){\n        cin >> b[i];\n    }\n    ll ans = asum;\n    ll checker = 0;\n    for(int i = 2; i < 2 * n; i++){\n        ll delta = b[i] - a[i];\n        if(delta > 0){\n            ans += delta;\n            checker++;\n        }\n        \n        seg.update(i, delta);\n    }\n    for(int time = 0; time < q; time++){\n        int p;\n        ll x, y;\n        cin >> p >> x >> y;\n        ans = ans - a[p] + x;\n        ll before = b[p] - a[p];\n        ll after = y - x;\n        a[p] = x;\n        b[p] = y;\n        if((p == 1) || (p == 2 * n)){\n            cout << ans << endl;\n            continue;\n        }\n        ans = ans - max((ll)0, before) + max((ll)0, after);\n        if((before > 0) && (after <= 0)){\n            checker--;\n        }\n        if((before <= 0) && (after > 0)){\n            checker++;\n        }\n        seg.update(p, after);\n        if(checker % 2 == 0){\n            cout << ans << endl;\n            continue;\n        }\n        cout << ans - min(-seg.getminus(1, 2 * n), seg.getplus(1, 2 * n)) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<long, int> P;\npriority_queue<P, vector<P>, greater<P>> que_pos;\npriority_queue<P, vector<P>> que_neg;\n\nint main(){\n    long N, Q;\n    long a[200000], b[200000];\n    cin >> N >> Q;\n    for(int i = 0; i < 2*N ; i++){\n        cin >> a[i];\n    }\n    for(int i = 0; i < 2*N ; i++){\n        cin >> b[i];\n    }\n    long sum_a = a[0] + a[2*N-1];\n    long sum_b = 0;\n    int cnt_pos = 0;\n    for(int i = 1; i <= 2*N-2; i++){\n        if(a[i] < b[i]){\n            cnt_pos++;\n            que_pos.push(P(b[i]-a[i], i));\n            sum_b += b[i];\n        }else{\n            que_neg.push(P(b[i]-a[i], i));\n            sum_a += a[i];\n        }\n    }\n    for(int i = 0; i < Q; i++){\n        int p, x, y;\n        cin >> p >> x >> y;\n        p--;\n        //if(p != 0 && p != 2*N-1){\n            if(b[p] > a[p]) {\n                cnt_pos--;\n                sum_b -= b[p];\n            }else{\n                sum_a -= a[p];\n            }\n        //}\n        a[p] = x;\n        b[p] = y;\n        if(b[p] > a[p]) {\n            cnt_pos++;\n            sum_b += b[p];\n            que_pos.push(P(b[p]-a[p], p));\n        }else{\n            sum_a += a[p];\n            que_neg.push(P(b[p]-a[p], p));\n        }\n        \n        if(cnt_pos%2 == 0){\n            //cout << 'H' << endl;\n            cout << sum_a+sum_b << endl;\n        }else{\n            while(!que_pos.empty()){\n                P top = que_pos.top();\n                int idx = top.second;\n                if(top.first != (b[idx]-a[idx])) que_pos.pop();\n                else break;\n            }\n            while(!que_neg.empty()){\n                P top = que_neg.top();\n                int idx = top.second;\n                if(top.first != (b[idx]-a[idx])) que_neg.pop();\n                else break;\n            }\n            //if(que_neg.empty()) cout << \"neg empty\\n\";\n            //if(que_pos.empty()) cout << \"pos empty\\n\";\n            if(que_neg.top().first+que_pos.top().first >= 0){\n                cout  << sum_a + sum_b + que_neg.top().first << endl;\n            }else{\n                cout  << sum_a + sum_b - que_pos.top().first << endl; \n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <functional>\n#include <vector>\nusing namespace std;\n\nlong long N, Q, a[200009], b[200009], c[200009], ne[200009], s = 0, T1 = 0, T2 = 0; bool I[600009];\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long>>> posi;\npriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, less<pair<long long, long long>>>nega;\n\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 1; i <= 2 * N; i++)cin >> a[i];\n\tfor (int i = 1; i <= 2 * N; i++)cin >> b[i];\n\tfor (int i = 1; i <= 2 * N; i++) {\n\t\tc[i] = b[i] - a[i]; s += a[i]; I[i] = true; ne[i] = i;\n\t\tif (i >= 2 && i <= 2 * N - 1) {\n\t\t\tif (c[i] >= 0) { posi.push(make_pair(c[i], i)); T1++; T2 += c[i]; }\n\t\t\telse nega.push(make_pair(c[i], i));\n\t\t}\n\t}\n\tfor (int i = 1; i <= Q; i++) {\n\t\tint p1, p2, p3; cin >> p1 >> p2 >> p3;\n\t\tlong long to = p3 - p2; if (c[p1] >= 0) { T2 -= c[p1]; T1--; }I[ne[p1]] = false;\n\t\t\n\t\twhile (!posi.empty() && I[posi.top().second] == false)posi.pop();\n\t\twhile (!nega.empty() && I[nega.top().second] == false)nega.pop();\n\t\t\n\t\tif (to >= 0) { posi.push(make_pair(to, 2 * N + i)); T2 += to; T1++; }\n\t\telse nega.push(make_pair(to, 2 * N + i));\n\t\ts += (p2 - a[p1]); a[p1] = p2; b[p1] = p3; c[p1] = to; I[2 * N + i] = true; ne[p1] = 2 * N + i;\n\t\tif (T1 % 2 == 0) { cout << T2 + s << endl; }\n\t\telse {\n\t\t\tlong long V1 = T2 - posi.top().first;\n\t\t\tlong long V2 = -(1LL << 60); if (!nega.empty())V2 = T2 + nega.top().first;\n\t\t\tcout << max(V1, V2) + s << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n\nint N,Q;\nint A[201010];\nint B[201010];\nmultiset<int> p,n;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>Q;\n\tll S=0,T=0;\n\tFOR(i,2*N) cin>>A[i], S+=A[i];\n\tFOR(i,2*N) {\n\t\tcin>>B[i];\n\t\tB[i]-=A[i];\n\t\tif(i!=0 && i!=2*N-1) {\n\t\t\tif(B[i]>0) {\n\t\t\t\tp.insert(B[i]);\n\t\t\t\tT+=B[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tn.insert(-B[i]);\n\t\t\t}\n\t\t}\n\t}\n\twhile(Q--) {\n\t\tcin>>i>>x>>y;\n\t\ti--;\n\t\tS-=A[i];\n\t\tif(i!=0 && i!=2*N-1) {\n\t\t\tif(B[i]>0) {\n\t\t\t\tp.erase(p.find(B[i]));\n\t\t\t\tT-=B[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tn.erase(n.find(-B[i]));\n\t\t\t}\n\t\t}\n\t\t\n\t\tA[i]=x;\n\t\tS+=x;\n\t\tB[i]=y-A[i];\n\t\tif(i!=0 && i!=2*N-1) {\n\t\t\tif(B[i]>0) {\n\t\t\t\tp.insert(B[i]);\n\t\t\t\tT+=B[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tn.insert(-B[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tll ma=0;\n\t\tif(p.size()%2==0) ma=S+T;\n\t\telse ma=S+max(T-*p.begin(),T-*n.begin());\n\t\tcout<<ma<<endl;\n\t}\n}\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<long, int> P;\npriority_queue<P, vector<P>, greater<P>> que_pos;\npriority_queue<P, vector<P>> que_neg;\n\nint main(){\n    long N, Q;\n    long a[200000], b[200000];\n    cin >> N >> Q;\n    for(int i = 0; i < 2*N ; i++){\n        cin >> a[i];\n    }\n    for(int i = 0; i < 2*N ; i++){\n        cin >> b[i];\n    }\n    long sum_a = a[0] + a[2*N-1];\n    long sum_b = 0;\n    int cnt_pos = 0;\n    for(int i = 1; i <= 2*N-2; i++){\n        if(a[i] < b[i]){\n            cnt_pos++;\n            que_pos.push(P(b[i]-a[i], i));\n            sum_b += b[i];\n        }else{\n            que_neg.push(P(b[i]-a[i], i));\n            sum_a += a[i];\n        }\n    }\n    //cout << cnt_pos << endl;\n    //cout << sum_a << ' ' << sum_b << endl;\n    for(int i = 0; i < Q; i++){\n        int p, x, y;\n        cin >> p >> x >> y;\n        p--;\n        if(b[p] > a[p]) {\n            if(p != 0 && p != 2*N-1) cnt_pos--;\n            sum_b -= b[p];\n        }else{\n            sum_a -= a[p];\n        }\n        a[p] = x;\n        b[p] = y;\n        if(b[p] > a[p]) {\n            if(p != 0 && p != 2*N-1) cnt_pos++;\n            sum_b += b[p];\n            if(p != 0 && p != 2*N-1) que_pos.push(P(b[p]-a[p], p));\n        }else{\n            sum_a += a[p];\n            if(p != 0 && p != 2*N-1) que_neg.push(P(b[p]-a[p], p));\n        }\n        //cout << sum_a << ' ' << sum_b << endl;        \n        if(cnt_pos%2 == 0){\n            //cout << 'H' << endl;\n            cout << sum_a+sum_b << endl;\n        }else{\n            while(!que_pos.empty()){\n                P top = que_pos.top();\n                int idx = top.second;\n                if(top.first != (b[idx]-a[idx])) que_pos.pop();\n                else break;\n            }\n            while(!que_neg.empty()){\n                P top = que_neg.top();\n                int idx = top.second;\n                if(top.first != (b[idx]-a[idx])) que_neg.pop();\n                else break;\n            }\n            //if(que_neg.empty()) cout << \"neg empty\\n\";\n            //if(que_pos.empty()) cout << \"pos empty\\n\";\n            if(que_neg.top().first+que_pos.top().first >= 0){\n                cout  << sum_a + sum_b + que_neg.top().first << endl;\n            }else{\n                cout  << sum_a + sum_b - que_pos.top().first << endl; \n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\n\nclass segtree{\npublic:\n\tstatic const int N=1<<19;\n\tll dp[2][1<<20];\n\tsegtree(){\n\t\tmemset(dp,0,sizeof(dp));\n\t}\n\tvoid update(int lv,int k,ll v){\n\t\tk+=N-1;\n\t\tdp[lv][k]+=v;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdp[lv][k]=dp[lv][k*2+1]+dp[lv][k*2+2];\n\t\t}\n\t}\n\n\tll query(int lv,int a,int b,int k=0,int l=0,int r=N){\n\t\tif(b<=l || r<=a)return 0;\n\t\tif(a<=l && r<=b)return dp[lv][k];\n\t\tint mid=(l+r)/2;\n\t\tll vl=query(lv,a,b,k*2+1,l,mid);\n\t\tll vr=query(lv,a,b,k*2+2,mid,r);\n\t\treturn vl+vr;\n\t}\n\n\tll get(int v){\n\t\tint l=0,r=N,k=0;\n\t\tint cnt=0;\n\t\twhile(l+1<r){\n\t\t\tif(dp[0][k*2+2]+cnt<v){\n\t\t\t\tcnt+=dp[0][k*2+2];\n\t\t\t\tk=k*2+1;\n\t\t\t\tr=(l+r)/2;\n\t\t\t}else{\n\t\t\t\tk=k*2+2;\n\t\t\t\tl=(l+r)/2;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d %d %lld\\n\",v,r,query(1,r,N));\n\t\treturn query(1,r-1,N);\n\t}\n\n\tll find(){\n\t\tint vl=0,vr=n;\n\t\tfor(int i=0;i<50;i++){\n\t\t\tint midl=(vl*2+vr)/3;\n\t\t\tint midr=(vl+vr*2)/3;\n\t\t\tif(get(midl*2)<=get(midr*2)){\n\t\t\t\tvl=midl;\n\t\t\t}else{\n\t\t\t\tvr=midr;\n\t\t\t}\n\t\t}\n\t\tll maxi=0;\n\t\tfor(int i=vl;i<vr;i++){\n\t\t\tmaxi=max(maxi,get(i*2));\n\t\t}\n\t\treturn maxi;\n\t}\n};\n\nsegtree seg;\n\nint q;\nll a[200005],b[200005];\nint p[200005];\nll x[200005],y[200005];\nvector<ll> vec;\n\nint main(void){\n\tscanf(\"%d%d\",&n,&q);\n\tll ans=0;\n\tfor(int i=0;i<n*2;i++){\n\t\tscanf(\"%lld\",&a[i]);\n\t\tans+=a[i];\n\t}\n\tfor(int i=0;i<n*2;i++){\n\t\tscanf(\"%lld\",&b[i]);\n\t}\n\tfor(int i=0;i<n*2;i++){\n\t\tvec.push_back(b[i]-a[i]);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d%lld%lld\",&p[i],&x[i],&y[i]);\n\t\tp[i]--;\n\t\tvec.push_back(y[i]-x[i]);\n\t}\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end());\n\tfor(int i=1;i<n*2-1;i++){\n\t\tint lv=lower_bound(vec.begin(),vec.end(),b[i]-a[i])-vec.begin();\n\t\tseg.update(0,lv,1);\n\t\tseg.update(1,lv,b[i]-a[i]);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint lv=lower_bound(vec.begin(),vec.end(),b[p[i]]-a[p[i]])-vec.begin();\n\t\tif(p[i]!=0 && p[i]!=(n*2-1))seg.update(0,lv,-1);\n\t\tif(p[i]!=0 && p[i]!=(n*2-1))seg.update(1,lv,a[p[i]]-b[p[i]]);\n\t\tb[p[i]]=y[i];\n\t\tans-=a[p[i]];\n\t\ta[p[i]]=x[i];\n\t\tans+=a[p[i]];\n\t\tlv=lower_bound(vec.begin(),vec.end(),b[p[i]]-a[p[i]])-vec.begin();\n\t\tif(p[i]!=0 && p[i]!=(n*2-1))seg.update(0,lv,1);\n\t\tif(p[i]!=0 && p[i]!=(n*2-1))seg.update(1,lv,b[p[i]]-a[p[i]]);\n\t\tprintf(\"%lld\\n\",ans+seg.find());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sp ' '\n#define mkp make_pair\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define lP pair<ll,ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\nconst int mod = 1000000007, mod998 = 998244353;\nconst string nyan(\"(=^・ω・^=)\");\n\nint N, Q, a[200000], b[200000], p, x, y;\nbool u[200000];\nset<pair<int, int>>st[2];\nll res;\n\nint main() {\n\tcin >> N >> Q;\n\t--Q;\n\tN *= 2;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> b[i];\n\t}\n\tcin >> p >> x >> y;\n\t--p;\n\ta[p] = x;\n\tb[p] = y;\n\tres = a[0] + a[N - 1];\n\tfor (int i = 1; i < N - 1; ++i) {\n\t\tif (a[i] >= b[i]) {\n\t\t\tu[i] = true;\n\t\t\tres += a[i];\n\t\t\tst[1].insert(mkp(a[i] - b[i], i));\n\t\t}\n\t\telse {\n\t\t\tres += b[i];\n\t\t\tst[0].insert(mkp(b[i] - a[i], i));\n\t\t}\n\t}\n\tif (st[0].size() & 1) {\n\t\tpair<int, int>p1, p2;\n\t\tp1 = *st[0].begin();\n\t\tp2 = *st[1].begin();\n\t\tif (p1.first > p2.first) {\n\t\t\tres -= p2.first;\n\t\t\tu[p2.second] ^= true;\n\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\tst[1].erase(p2);\n\t\t}\n\t\telse {\n\t\t\tres -= p1.first;\n\t\t\tu[p1.second] ^= true;\n\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\tst[0].erase(p1);\n\t\t}\n\t}\n\tcout << res << endl;\n\twhile (Q--) {\n\t\tcin >> p >> x >> y;\n\t\t--p;\n\t\tif (p == 0 || p == N - 1) {\n\t\t\tres += x - a[p];\n\t\t\ta[p] = x;\n\t\t}\n\t\telse {\n\t\t\tif (u[p]) {\n\t\t\t\tres += x - a[p];\n\t\t\t\tst[1].erase(mkp(a[p] - b[p], p));\n\t\t\t\tst[1].insert(mkp(x - y, p));\n\t\t\t\tauto it = st[1].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0 || (!st[0].empty() && p1.first + p2.first < 0 && p2.first < st[0].begin()->first)) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[0].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[1].erase(p1);\n\t\t\t\t\tst[1].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres += y - b[p];\n\t\t\t\tst[0].erase(mkp(b[p] - a[p], p));\n\t\t\t\tst[0].insert(mkp(y - x, p));\n\t\t\t\tauto it = st[0].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0 || (!st[1].empty() && p1.first + p2.first < 0 && p2.first < st[1].begin()->first)) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[1].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[0].erase(p1);\n\t\t\t\t\tst[0].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!st[0].empty() && !st[1].empty() && st[0].begin()->first + st[1].begin()->first < 0) {\n\t\t\t\tpair<int, int> p1 = *st[0].begin();\n\t\t\t\tpair<int, int> p2 = *st[1].begin();\n\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\tu[p1.second] ^= true;\n\t\t\t\tu[p2.second] ^= true;\n\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\tst[0].erase(p1);\n\t\t\t\tst[1].erase(p2);\n\t\t\t}\n\t\t\ta[p] = x;\n\t\t\tb[p] = y;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, Q, p, x, y, a[200009], b[200009];\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 0; i < 2 * N; i++) cin >> a[i];\n\tfor (int i = 0; i < 2 * N; i++) cin >> b[i];\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> p >> x >> y; p--;\n\t\ta[p] = x;\n\t\tb[p] = y;\n\t\tint bc = 0, bm = 1012345678;\n\t\tlong long ret = a[0] + a[2 * N - 1];\n\t\tfor (int j = 1; j < 2 * N - 1; j++) {\n\t\t\tret += max(a[j], b[j]);\n\t\t\tif (a[j] < b[j]) {\n\t\t\t\tbc++;\n\t\t\t\tbm = min(bm, b[j] - a[j]);\n\t\t\t}\n\t\t}\n\t\tcout << ret - (bc & 1 ? bm : 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//todo 文字数を少なくする\n\n//#pragma GCC optimize (\"-O3\")\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n//衝突対策\n#define ws ___ws\n\n//@必須構造\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    bool operator==(const T &r) const {\n        return f == r.f && s == r.s && t == r.t;\n    }\n    bool operator!=(const T &r) const {\n        return f != r.f || s != r.s || t != r.t;\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\nstruct F {\n    int a, b, c, d;\n    F() { a = -1, b = -1, c = -1, d = -1; }\n    F(int a, int b, int c, int d) : a(a), b(b), c(c), d(d) {}\n    bool operator<(const F &r) const {\n        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;\n//        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;\n    }\n    bool operator>(const F &r) const {\n        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;\n//        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;\n    }\n    bool operator==(const F &r) const {\n        return a == r.a && b == r.b && c == r.c && d == r.d;\n    }\n    bool operator!=(const F &r) const {\n        return a != r.a || b != r.b || c != r.c || d != r.d;\n    }\n    int operator[](int i) {\n        assert(i < 4);\n        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;\n    }\n};\n\nT mt(int a, int b, int c) {\n    return T(a, b, c);\n}\n//@マクロ省略系 型,構造\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\n\n#define fi first\n#define se second\n#define vec vector\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n\n#define minq 0\n#define maxq 1\n\n//マクロ省略系 コンテナ\n\nusing vi = vector<int>;\n#define _overloadvvi(_1, _2, _3, _4, name, ...) name\n#define vvi0() vec<vi>\n#define vvi1(a) vec<vi> a\n#define vvi2(a, b) vec<vi> a(b)\n#define vvi3(a, b, c) vec<vi> a(b,vi(c))\n#define vvi4(a, b, c, d) vec<vi> a(b,vi(c,d))\n#define vvi(...) _overloadvvi(__VA_ARGS__,vvi4,vvi3,vvi2 ,vvi1,vvi0)(__VA_ARGS__)\n\n\nusing vl = vector<ll>;\n#define _overloadvvl(_1, _2, _3, _4, name, ...) name\n#define vvl1(a) vec<vl> a\n#define vvl2(a, b) vec<vl> a(b)\n#define vvl3(a, b, c) vec<vl> a(b,vl(c))\n#define vvl4(a, b, c, d) vec<vl> a(b,vl(c,d))\n#define vvl(...) _overloadvvl(__VA_ARGS__,vvl4,vvl3,vvl2 ,vvl1)(__VA_ARGS__)\n\nusing vb = vector<bool>;\n#define _overloadvvb(_1, _2, _3, _4, name, ...) name\n#define vvb1(a) vec<vb> a\n#define vvb2(a, b) vec<vb> a(b)\n#define vvb3(a, b, c) vec<vb> a(b,vb(c))\n#define vvb4(a, b, c, d) vec<vb> a(b,vb(c,d))\n#define vvb(...) _overloadvvb(__VA_ARGS__,vvb4,vvb3,vvb2 ,vvb1)(__VA_ARGS__)\n\nusing vs = vector<string>;\n#define _overloadvvs(_1, _2, _3, _4, name, ...) name\n#define vvs1(a) vec<vs> a\n#define vvs2(a, b) vec<vs> a(b)\n#define vvs3(a, b, c) vec<vs> a(b,vs(c))\n#define vvs4(a, b, c, d) vec<vs> a(b,vs(c,d))\n#define vvs(...) _overloadvvs(__VA_ARGS__,vvs4,vvs3,vvs2 ,vvs1)(__VA_ARGS__)\n\nusing vd = vector<double>;\n#define _overloadvvd(_1, _2, _3, _4, name, ...) name\n#define vvd1(a) vec<vd> a\n#define vvd2(a, b) vec<vd> a(b)\n#define vvd3(a, b, c) vec<vd> a(b,vd(c))\n#define vvd4(a, b, c, d) vec<vd> a(b,vd(c,d))\n#define vvd(...) _overloadvvd(__VA_ARGS__,vvd4,vvd3,vvd2 ,vvd1)(__VA_ARGS__)\n\nusing vc=vector<char>;\n#define _overloadvvc(_1, _2, _3, _4, name, ...) name\n#define vvc1(a) vec<vc> a\n#define vvc2(a, b) vec<vc> a(b)\n#define vvc3(a, b, c) vec<vc> a(b,vc(c))\n#define vvc4(a, b, c, d) vec<vc> a(b,vc(c,d))\n#define vvc(...) _overloadvvc(__VA_ARGS__,vvc4,vvc3,vvc2 ,vvc1)(__VA_ARGS__)\n\nusing vp = vector<P>;\n#define _overloadvvp(_1, _2, _3, _4, name, ...) name\n#define vvp1(a) vec<vp> a\n#define vvp2(a, b) vec<vp> a(b)\n#define vvp3(a, b, c) vec<vp> a(b,vp(c))\n#define vvp4(a, b, c, d) vec<vp> a(b,vp(c,d))\n#define vvp(...) _overloadvvp(__VA_ARGS__,vvp4,vvp3,vvp2 ,vvp1)(__VA_ARGS__)\n\nusing vt = vector<T>;\n#define _overloadvvt(_1, _2, _3, _4, name, ...) name\n#define vvt1(a) vec<vt> a\n#define vvt2(a, b) vec<vt> a(b)\n#define vvt3(a, b, c) vec<vt> a(b,vt(c))\n#define vvt4(a, b, c, d) vec<vt> a(b,vt(c,d))\n#define vvt(...) _overloadvvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1)(__VA_ARGS__)\n\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n\n#define _vvi vector<vi>\n#define _vvl vector<vl>\n#define _vvb vector<vb>\n#define _vvs vector<vs>\n#define _vvd vector<vd>\n#define _vvc vector<vc>\n#define _vvp vector<vp>\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n#define vni(name, ...) auto name = make_v<int>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<int, int>;\nusing mapd = map<dou, int>;\nusing mapc = map<char, int>;\nusing maps = map<str, int>;\nusing seti = set<int>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<int>;\n#define bset bitset\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define umapi unordered_map<int,int>\n#define umapp unordered_map<P,int>\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, _4, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define repadd(i, m, n, ad) for(int i = m,_lim=n; i < _lim ; i+= ad)\n#define rep(...) _overloadrep(__VA_ARGS__,repadd,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rerdec(i, m, n, dec) for(int i = m,_lim=n; i >= _lim ; i-=dec)\n#define rer(...) _overloadrep(__VA_ARGS__,rerdec,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); gi++)\n#define fort(gi, ve) for (int gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); gi++)if(t!=p)\n//#define fort(gi, ve) for (int gi = 0, f, t, c;gi<ve.size()&& (gi+= (ve[gi].t==p))< ve.size() && (f = ve[gi].f,t=ve[gi].t, c = ve[gi].c,true); gi++)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((int)(a).size())\n#define rs resize\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> {\n    public:\n        size_t operator()(const std::pair<signed, signed> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n    template<> class hash<std::pair<ll, ll>> {\n    public:\n        //大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断\n        size_t operator()(const std::pair<ll, ll> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n}\nistream &operator>>(istream &iss, P &a) {\n    iss >> a.first >> a.second;\n    return iss;\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\nostream &operator<<(ostream &os, P p) {\n    os << p.fi << \" \" << p.se << endl;\n    return os;\n}\n\nostream &operator<<(ostream &os, T p) {\n    os << p.f << \" \" << p.s << \" \" << p.t;\n    return os;\n}\nostream &operator<<(ostream &os, F p) {\n    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <T> &vec) {\n    for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <vector<T>> &vec) {\n    for (int i = 0; i < vec.size(); i++) {\n        for (int j = 0; j < vec[0].size(); j++) {\n            os << vec[i][j];\n        }\n        os << endl;\n    }\n    return os;\n}\ntemplate<typename V, typename H> void resize(vector<V> &vec, const H head) { vec.resize(head); }\ntemplate<typename V, typename H, typename ... T> void resize(vector<V> &vec, const H &head, const T ... tail) {\n    vec.resize(head);\n    for (auto &v: vec) resize(v, tail...);\n}\ntemplate<typename T, typename _Pr> bool all_of(const vector<T> &vec, _Pr pred) { return std::all_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> bool any_of(const vector<T> &vec, _Pr pred) { return std::any_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> bool none_of(const vector<T> &vec, _Pr pred) { return std::none_of(vec.begin(), vec.end(), pred); }\ntemplate<typename T, typename _Pr> const typename vector<T>::const_iterator find_if(const vector<T> &vec, _Pr pred) { return std::find_if(vec.begin(), vec.end(), pred); }\ntemplate<typename T> bool contains(const vector<T> &vec, const T &val) { return std::find(vec.begin(), vec.end(), val) != vec.end(); }\ntemplate<typename T, typename _Pr> bool contains_if(const vector<T> &vec, _Pr pred) { return std::find_if(vec.begin(), vec.end(), pred) != vec.end(); }\ntemplate<class T> void replace(vector<T> &a, T key, T v) { replace(a.begin(), a.end(), key, v); }\ntemplate<class T> void replace(str &a, T key, T v) { replace(a.begin(), a.end(), key, v); }\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {\n    vi c = a;\n    vi d = b;\n    sort(all(c));\n    sort(all(d));\n    return includes(all(c), all(d));\n}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\n\ntemplate<class T> T pop(set<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T pop(mset<T> &set) {\n    T res = *set.begin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(set<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ntemplate<class T> T popBack(mset<T> &set) {\n    T res = *set.rbegin();\n    set.erase(set.find(res));\n    return res;\n}\ninline void sort(string &a) { sort(a.begin(), a.end()); }\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T, class F> inline void sort(vector<T> &a, F f) { sort(a.begin(), a.end(), [&](T l, T r) { return f(l) < f(r); }); };\nenum ___pcomparator {\n    fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd\n};\ninline void sort(vector<P> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });\n            break;\n        case fisd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });\n            break;\n        case fdsi:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });\n            break;\n        case fdsd:\n            sort(all(a), [&](P l, P r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });\n            break;\n        case sifi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });\n            break;\n        case sifd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });\n            break;\n        case sdfi:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });\n            break;\n        case sdfd:\n            sort(all(a), [&](P l, P r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });\n            break;\n    }\n};\ninline void sort(vector<T> &a, ___pcomparator type) {\n    switch (type) {\n        case fisi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });\n            break;\n        case\n            fisd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });\n            break;\n        case\n            fdsi:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });\n            break;\n        case\n            fdsd:\n            sort(all(a), [&](T l, T r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });\n            break;\n        case\n            sifi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });\n            break;\n        case\n            sifd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });\n            break;\n        case\n            sdfi:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });\n            break;\n        case\n            sdfd:\n            sort(all(a), [&](T l, T r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });\n            break;\n    }\n};\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class U, class F> inline void rsort(vector<U> &a, F f) { sort(a.begin(), a.end(), [&](U l, U r) { return f(l) > f(r); }); };\ntemplate<class U> inline void sortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;;\n    }\n};\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void sortp(vector<U> &a, vector<U> &b, char type) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c, type);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void rsortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U, class F> inline void rsortp(vector<U> &a, vector<U> &b, F f) {\n    vp c;\n    int n = sz(a);\n    assert(n == sz(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c, f);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void sortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    sort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class U, class F> inline void rsortt(vector<U> &a, vector<U> &b, vector<U> &c, F f) {\n    vt r;\n    int n = sz(a);\n    assert(n == sz(b));\n    assert(n == sz(c));\n    rep(i, n)r.eb(a[i], b[i], c[i]);\n    rsort(r, f);\n    rep(i, n) {\n        a[i] = r[i].f;\n        b[i] = r[i].s;\n        c[i] = r[i].t;\n    }\n};\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\n\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T vall) {\n    xx = vall;\n}\ntemplate<typename V, typename T>\nvoid fill(vector<V> &vecc, const T vall) {\n    for (auto &&vx: vecc) fill(vx, vall);\n}\n\n//@汎用便利関数 入力\ntemplate<typename T = int> T _in() {\n    T x;\n    cin >> x;\n    return (x);\n}\n#define _overloadin(_1, _2, _3, _4, name, ...) name\n#define in0() _in()\n#define in1(a) cin>>a\n#define in2(a, b) cin>>a>>b\n#define in3(a, b, c) cin>>a>>b>>c\n#define in4(a, b, c, d) cin>>a>>b>>c>>d\n#define in(...) _overloadin(__VA_ARGS__,in4,in3,in2 ,in1,in0)(__VA_ARGS__)\n\n#define _overloaddin(_1, _2, _3, _4, name, ...) name\n#define din1(a) int a;cin>>a\n#define din2(a, b) int a,b;cin>>a>>b\n#define din3(a, b, c) int a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d\n#define din(...) _overloadin(__VA_ARGS__,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define _overloaddind(_1, _2, _3, _4, name, ...) name\n#define din1d(a) int a;cin>>a;a--\n#define din2d(a, b) int a,b;cin>>a>>b;a--,b--\n#define din3d(a, b, c) int a,b,c;cin>>a>>b>>c;a--,b--,c--\n#define din4d(a, b, c, d) int a,b,c,d;cin>>a>>b>>c>>d;;a--,b--,c--,d--\n#define dind(...) _overloaddind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\n\n#define _overloadout(_1, _2, _3, _4, name, ...) name\n#define out1(a) cout<<a<<endl\n#define out2(a, b) cout<<a<<\" \"<< b<<endl\n#define out3(a, b, c) cout<<a<<\" \"<<b<<\" \"<<c<<endl\n#define out4(a, b, c, d) cout<<a<<\" \"<<b<<\" \"<<c<<\" \"<<d<<endl\n#define out(...) _overloadout(__VA_ARGS__,out4,out3,out2,out1)(__VA_ARGS__)\n\n#define _overloadoutl(_1, _2, _3, _4, name, ...) name\n#define outl1(a) cout<<a<<endl\n#define outl2(a, b) cout<<a<<endl;cout<<b<<endl\n#define outl3(a, b, c) cout<<a<<endl;cout<<b<<endl;cout<<c<<endl\n#define outl4(a, b, c, d) cout<<a<<endl;cout<<b<<endl;cout<<c<<endl;cout<<d<<endl\n#define outl(...) _overloadout(__VA_ARGS__,outl4,outl3,outl2,outl1)(__VA_ARGS__)\n\nstring sin() { return _in<string>(); }\nll lin() { return _in<ll>(); }\n#define na(a, n) a.resize(n); rep(i,n) cin >> a[i];\n#define nao(a, n) a.resize(n+1); rep(i,n) cin >> a[i+1];\n#define nad(a, n) a.resize(n); rep(i,n){ cin >> a[i]; a[i]--;}\n#define na2(a, b, n) a.resize(n),b.resize(n);rep(i, n)cin >> a[i] >> b[i];\n#define nao2(a, b, n) a.resize(n+1),b.resize(n+1);rep(i, n)cin >> a[i+1] >> b[i+1];\n#define na2d(a, b, n) a.resize(n),b.resize(n);rep(i, n){cin >> a[i] >> b[i];a[i]--,b[i]--;}\n#define na3(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define na3d(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n){cin >> a[i] >> b[i] >> c[i];a[i]--,b[i]--,c[i]--;}\n#define nt(a, h, w) resize(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rs(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n\n//デバッグ\n#define sp << \" \" <<\n\n#define debugName(VariableName) # VariableName\n\n#define _deb1(x) cerr <<  debugName(x)<<\" = \"<<x << endl\n#define _deb2(x, y) cerr <<  debugName(x)<<\" = \"<<x<<\", \"<< debugName(y)<<\" = \"<<y<< endl\n#define _deb3(x, y, z) cerr <<  debugName(x)<<\" = \"<<x  << \", \" <<  debugName(y)<<\" = \"<<y <<\", \" debugName(z)<<\" = \"<<z <<endl\n#define _deb4(x, y, z, a) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<endl\n#define _deb5(x, y, z, a, b) cerr <<  debugName(x)<<\" = \"<<x <<\", \" <<   debugName(y)<<\" = \"<<y <<\", \" <<  debugName(z)<<\" = \"<<z <<\", \" <<  debugName(a)<<\" = \"<<a<<\", \" <<  debugName(b)<<\" = \"<<b<<endl\n\n\n#define _overloadebug(_1, _2, _3, _4, _5, name, ...) name\n#define debug(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n\n#ifdef _DEBUG\n#define deb(...) _overloadebug(__VA_ARGS__,_deb5,_deb4,_deb3,_deb2,_deb1)(__VA_ARGS__)\n#else\n#define deb(...) ;\n#endif\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n//よく使うクラス、構造体\nclass UnionFind {\npublic:\n    vi par, rank, sizes;\n    int n, trees;\n    UnionFind(int n) : n(n), trees(n) {\n        par.resize(n), rank.resize(n), sizes.resize(n);\n        rep(i, n)par[i] = i, sizes[i] = 1;\n    }\n    int root(int x) {\n        if (par[x] == x)return x;\n        else return par[x] = root(par[x]);\n    }\n    int find(int x) { return root(x); }\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y)return;\n        if (rank[x] < rank[y])swap(x, y);\n        trees--;\n        par[y] = x;\n        sizes[x] += sizes[y];\n        if (rank[x] == rank[y])rank[x]++;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return sizes[root(x)]; }\n    //順不同 umapなので\n    vec<vi> sets() {\n        vec<vi> res(trees);\n        umap<int, vi> map;\n        rep(i, n) map[root(i)].push_back(i);\n        int i = 0;\n        for (auto &&p:map) {\n            int r = p.fi;\n            res[i].push_back(r);\n            for (auto &&v:p.se) {\n                if (r == v)continue;\n                res[i].push_back(v);\n            }\n            i++;\n        }\n        return res;\n    }\n};\n\nusing bint =__int128;\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {\n    std::ostream::sentry s(dest);\n    if (s) {\n        __uint128_t tmp = value < 0 ? -value : value;\n        char buffer[128];\n        char *d = std::end(buffer);\n        do {\n            --d;\n            *d = \"0123456789\"[tmp % 10];\n            tmp /= 10;\n        } while (tmp != 0);\n        if (value < 0) {\n            --d;\n            *d = '-';\n        }\n        int len = std::end(buffer) - d;\n        if (dest.rdbuf()->sputn(d, len) != len) {\n            dest.setstate(std::ios_base::badbit);\n        }\n    }\n    return dest;\n}\n\n__int128 toi128(string &s) {\n    __int128 ret = 0;\n    for (int i = 0; i < s.length(); i++)\n        if ('0' <= s[i] && s[i] <= '9')\n            ret = 10 * ret + s[i] - '0';\n    return ret;\n}\n\n\ntemplate<typename T> T minv(T a, T m);\n\ntemplate<typename T>\nclass Modular {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;\n\n    constexpr Modular() : value() {}\n    template<typename U>\n    Modular(const U &x) {\n        value = normalize(x);\n    }\n\n    template<typename U>\n    static Type normalize(const U &x) {\n        Type v;\n        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n        else v = static_cast<Type>(x % mod());\n        if (v < 0) v += mod();\n        return v;\n    }\n\n    const Type &operator()() const { return value; }\n    template<typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static Type mod() { return T::value; }\n\n    Modular &operator+=(const Modular &other) {\n        if ((value += other.value) >= mod()) value -= mod();\n        return *this;\n    }\n    Modular &operator-=(const Modular &other) {\n        if ((value -= other.value) < 0) value += mod();\n        return *this;\n    }\n    template<typename U> Modular &operator+=(const U &other) { return *this += Modular(other); }\n    template<typename U> Modular &operator-=(const U &other) { return *this -= Modular(other); }\n    Modular &operator++() { return *this += 1; }\n    Modular &operator--() { return *this -= 1; }\n    Modular operator++(signed) {\n        Modular result(*this);\n        *this += 1;\n        return result;\n    }\n    Modular operator--(signed) {\n        Modular result(*this);\n        *this -= 1;\n        return result;\n    }\n    Modular operator-() const { return Modular(-value); }\n\n    template<typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, signed>::value, Modular>::type &operator*=(const Modular &rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n        asm(\n        \"divl %4; \\n\\t\"\n        : \"=a\" (d), \"=d\" (m)\n        : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n        );\n        value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template<typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &operator*=(const Modular &rhs) {\n        int64_t q = static_cast<int64_t>(static_cast<double>(value) * rhs.value / mod());\n        value = normalize(value * rhs.value - q * mod());\n        return *this;\n    }\n    template<typename U = T>\n    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {\n        value = normalize(value * rhs.value);\n        return *this;\n    }\n\n    Modular &operator/=(const Modular &other) { return *this *= Modular(minv(other.value, mod())); }\n\n    template<typename U>\n    friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);\n\n    template<typename U>\n    friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);\n\n    template<typename U>\n    friend std::istream &operator>>(std::istream &stream, Modular<U> &number);\n\nprivate:\n    Type value;\n};\n\ntemplate<typename T> bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }\ntemplate<typename T, typename U> bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate<typename T, typename U> bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate<typename T> bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }\ntemplate<typename T, typename U> bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }\n\ntemplate<typename T> bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }\n\ntemplate<typename T> Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\ntemplate<typename T, typename U> Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate<typename T, typename U> Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate<typename T> Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate<typename T, typename U> Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate<typename T> Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate<typename T, typename U> Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate<typename T> Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate<typename T, typename U> Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\nconstexpr signed MOD = 1000000007;\nusing mint = Modular<std::integral_constant<decay<decltype(MOD)>::type, MOD>>;\n\nmint com(int n, int r) {\n    const int NUM_ = 1400001;\n    static ll fac[NUM_ + 1], finv[NUM_ + 1], inv[NUM_ + 1];\n    if (fac[0] == 0) {\n        inv[1] = fac[0] = finv[0] = 1;\n        for (int i = 2; i <= NUM_; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;\n        for (int i = 1; i <= NUM_; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n    if (r < 0 || r > n) return 0;\n    return mint(finv[r] * fac[n] % MOD * finv[n - r]);\n}\nmint ncr(int n, int r) { return com(n, r); }\nmint nhr(int n, int r) { return com(n + r - 1, r); }\n\n\ntemplate<typename T> T minv(T a, T m) {\n    T u = 0, v = 1;\n    while (a != 0) {\n        T t = m / a;\n        m -= t * a;\n        swap(a, m);\n        u -= t * v;\n        swap(u, v);\n    }\n    assert(m == 1);\n    return u;\n}\n\ntemplate<typename T, typename U> Modular<T> mpow(const Modular<T> &a, const U &b) {\n    assert(b >= 0);\n    int x = a(), res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) (res *= x) %= MOD;\n        (x *= x) %= MOD;\n        p >>= 1;\n    }\n    return res;\n}\ntemplate<typename T, typename U> Modular<T> mpow(const T &a, const U &b) {\n    assert(b >= 0);\n    int x = a, res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) (res *= x) %= MOD;\n        (x *= x) %= MOD;\n        p >>= 1;\n    }\n    return res;\n}\ntemplate<typename T> string to_string(const Modular<T> &number) {\n    return to_string(number());\n}\n\ntemplate<typename T> std::ostream &operator<<(std::ostream &stream, const Modular<T> &number) {\n    return stream << number();\n}\n\ntemplate<typename T> std::istream &operator>>(std::istream &stream, Modular<T> &number) {\n    typename common_type<typename Modular<T>::Type, int64_t>::type x;\n    stream >> x;\n    number.value = Modular<T>::normalize(x);\n    return stream;\n}\n\nusing PM = pair<mint, mint>;\nusing vm = vector<mint>;\n#define _overloadvvm(_1, _2, _3, _4, name, ...) name\n\n\n#define vvm1(a) vec<vm> a\n#define vvm2(a, b) vec<vm> a(b)\n#define vvm3(a, b, c) vec<vm> a(b,vm(c))\n#define vvm4(a, b, c, d) vec<vm> a(b,vm(c,d))\n#define vvm(...) _overloadvvm(__VA_ARGS__,vvm4,vvm3,vvm2 ,vvm1)(__VA_ARGS__)\n\nvb isPrime;\nvi primes;\n\nvoid setPrime() {\n    int len = 4010101;\n    isPrime.resize(4010101);\n    fill(isPrime, true);\n    isPrime[0] = isPrime[1] = false;\n    for (int i = 2; i <= sqrt(len) + 5; ++i) {\n        if (!isPrime[i])continue;\n        for (int j = 2; i * j < len; ++j) {\n            isPrime[i * j] = false;\n        }\n    }\n    rep(i, len)if (isPrime[i])primes.pb(i);\n}\n//幾何 Pをcomplexとして扱う\nbool eq(double a, double b) { return fabs(a - b) < eps; }\nusing C =complex<double>;\nC rot(C &a, dou th) { return a * C(cos(th), sin(th)); }\ndou inpro(C &a, C &b) { return real(a * conj(b)); }\n\n//90度回転させて内積が0なら平行\nbool line(C a, C b, C c) {\n    C ab = b - a;\n    C ac = c - a;\n    //複素数の掛け算は回転\n    ab *= C(0, 1);\n    return eq(inpro(ab, ac), 0);\n}\nbool line(P a, P b, P c) { return line(C(a.fi, a.se), C(b.fi, b.se), C(c.fi, c.se)); }\n\nbool line(int xa, int ya, int xb, int yb, int xc, int yc) {\n    C a = C(xa, ya);\n    C b = C(xb, yb);\n    C c = C(xc, yc);\n    return line(a, b, c);\n}\n//便利関数\n\n//テスト用\nchar ranc() {\n    return (char) ('a' + rand() % 26);\n}\nint rand(int min, int max) {\n    assert(min <= max);\n    if (min >= 0 && max >= 0) {\n        return rand() % (max + 1 - min) + min;\n    } else if (max < 0) {\n        return -rand(-max, -min);\n    } else {\n        //+\n        if (rand() % 2) {\n            return rand(0, max);\n            //-\n        } else {\n            return -rand(0, -min);\n        }\n    }\n}\nvi ranv(int n, int min, int max) {\n    vi v(n);\n    rep(i, n)v[i] = rand(min, max);\n    return v;\n}\n//単調増加\nvi ranvi(int n, int min, int max) {\n    vi v(n);\n    bool bad = 1;\n    while (bad) {\n        bad = 0;\n        v.resize(n);\n        rep(i, n) {\n            if (i && min > max - v[i - 1]) {\n                bad = 1;\n                break;\n            }\n            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]);\n            else v[i] = rand(min, max);\n        }\n    }\n    return v;\n}\nvoid ranvlr(int n, int min, int max, vi &l, vi &r) {\n    l.resize(n);\n    r.resize(n);\n    rep(i, n) {\n        l[i] = rand(min, max);\n        r[i] = l[i] + rand(0, max - l[i]);\n    }\n}\n//便利 汎用\n//strを整数として比較\nstring smax(str &a, str b) {\n    if (sz(a) < sz(b)) {\n        return b;\n    } else if (sz(a) > sz(b)) {\n        return a;\n    } else {\n        rep(i, sz(a)) {\n            if (a[i] < b[i]) {\n                return b;\n            } else if (a[i] > b[i])return a;\n        }\n    }\n    return a;\n}\n//strを整数として比較\nstring smin(str &a, str b) {\n    if (sz(a) < sz(b)) {\n        return a;\n    } else if (sz(a) > sz(b)) {\n        return b;\n    } else {\n        rep(i, sz(a)) {\n            if (a[i] < b[i]) {\n                return a;\n            } else if (a[i] > b[i])return b;\n        }\n    }\n    return a;\n}\ntemplate<typename V, typename T> int find(vector<V> &a, const T key) {\n    rep(i, sz(a))if (a[i] == key)return i;\n    return -1;\n}\ntemplate<typename V, typename T> P find(vector<vector<V>> &a, const T key) {\n    rep(i, sz(a)) rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);\n    return mp(-1, -1);\n}\ntemplate<typename V, typename U> T find(vector<vector<vector<V>>> &a, const U key) {\n    rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);\n    return mt(-1, -1, -1);\n}\n\ntemplate<typename V, typename T> int count(V &a, const T k) { return a == k; }\ntemplate<typename V, typename T> int count(vector<V> &a, const T k) {\n    int ret = 0;\n    fora(v, a)ret += count(v, k);\n    return ret;\n}\ntemplate<typename V> int count_odd(V &a) { return a % 2; }\ntemplate<typename V> int count_odd(vector<V> &a) {\n    int ret = 0;\n    fora(v, a)ret += count_odd(v);\n    return ret;\n}\ntemplate<typename V> int count_even(V &a) { return a % 2 == 0; }\ntemplate<typename V> int count_even(vector<V> &a) {\n    int ret = 0;\n    fora(v, a)ret += count_even(v);\n    return ret;\n}\n//algorythm\nvoid iota(vector<int> &ve, int s, int n) {\n    ve.resize(n);\n    iota(all(ve), s);\n}\nvi iota(int s, int n) {\n    vi ve(n);\n    iota(all(ve), s);\n    return ve;\n}\n//便利 数学\nint mod(int a, int m) { return (a % m + m) % m; }\nint pow(int a) { return a * a; };\nll fact(int v) { return v <= 1 ? 1 : v * fact(v - 1); }\nll comi(int n, int r) {\n    assert(n < 100);\n    static vvi(pas, 100, 100);\n    if (pas[0][0])return pas[n][r];\n    pas[0][0] = 1;\n    rep(i, 1, 100) {\n        pas[i][0] = 1;\n        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];\n    }\n    return pas[n][r];\n}\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");\n    exit(0);\n#endif\n    string a = \"a\";\n    rep(i, 30)a += a;\n    rep(i, 1 << 17)cout << a << endl;\n    cout << \"OLE 出力長制限超過\" << endl;\n    exit(0);\n}\nvoid tle() { while (inf)cout << inf << endl; }\nll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\nll gcd(vi b) {\n    ll res = b[0];\n    for (auto &&v :b)res = gcd(v, res);\n    return res;\n}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll rev(ll a) {\n    ll res = 0;\n    while (a) {\n        res *= 10;\n        res += a % 10;\n        a /= 10;\n    }\n    return res;\n}\ntemplate<class T> void rev(vector<T> &a) {\n    reverse(all(a));\n}\nvoid rev(string &a) {\n    reverse(all(a));\n}\nll ceil(ll a, ll b) {\n    if (b == 0) {\n        debugline(\"ceil\");\n        deb(a, b);\n        ole();\n        return -1;\n    } else if (a < 0) {\n        return 0;\n    } else {\n        return (a + b - 1) / b;\n    }\n}\nll sqrt(ll a) {\n    if (a < 0) {\n        debugline(\"sqrt\");\n        deb(a);\n        ole();\n    }\n    ll res = (ll) std::sqrt(a);\n    while (res * res < a)res++;\n    return res;\n}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\nvi divisors(int v) {\n    vi res;\n    double lim = std::sqrt(v);\n    for (int i = 1; i <= lim; ++i) {\n        if (v % i == 0) {\n            res.pb(i);\n            if (i != v / i)res.pb(v / i);\n        }\n    }\n    return res;\n}\n\nvi factorization(int v) {\n    int tv = v;\n    vi res;\n    if (isPrime.size() == 0)setPrime();\n    for (auto &&p :primes) {\n        if (v % p == 0)res.push_back(p);\n        while (v % p == 0) {\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res.pb(v);\n    return res;\n}\n\nunordered_map<int, int> factorizationMap(int v) {\n    int tv = v;\n    unordered_map<int, int> res;\n    if (isPrime.size() == 0)setPrime();\n    for (auto &&p :primes) {\n        while (v % p == 0) {\n            res[p]++;\n            v /= p;\n        }\n        if (v == 1 || p * p > tv)break;\n    }\n    if (v > 1)res[v]++;\n    return res;\n}\nint get(int a, int keta) { return (a / (int) pow(10, keta)) % 10; }\nint keta(int v) {\n    int cou = 0;\n    while (v) { cou++, v %= 10; }\n    return cou;\n}\nint dsum(int v) {\n    int ret = 0;\n    for (; v; v /= 10)ret += v % 10;\n    return ret;\n}\nint sumd(int v) { return dsum(v); }\n//変換系\ntemplate<class T, class U> vector<T> keys(vector<pair<T, U>> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\ntemplate<class T, class U> vector<U> keys(map<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\n\ntemplate<class T, class U> vector<U> keys(umap<T, U> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.fi);\n    return res;\n}\n\ntemplate<class T, class U> vector<U> values(vector<pair<T, U>> a) {\n    vector<U> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(map<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\ntemplate<class T, class U> vector<T> values(umap<T, U> a) {\n    vector<T> res;\n    for (auto &&k :a)res.pb(k.se);\n    return res;\n}\n\nvi list(int a) {\n    vi res;\n    while (a) {\n        res.insert(res.begin(), a % 10);\n        a /= 10;\n    }\n    return res;\n}\n\ntemplate<class T, class U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> bool chmax(const U &b) { return chmax(ma, b); }\ntemplate<class T, class U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class U> bool chmin(const U &b) { return chmin(mi, b); }\n#define chmi chmin\n#define chma chmax\ntemplate<class T> T min(T a, signed b) { return a < b ? a : b; }\ntemplate<class T> T max(T a, signed b) { return a < b ? b : a; }\ntemplate<class T> T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T> T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T> T min(vector<T> a) { return *min_element(all(a)); }\ntemplate<class T> T min(vector<T> a, int n) { return *min_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T> T min(vector<T> a, int s, int n) { return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T> T max(vector<T> a) { return *max_element(all(a)); }\ntemplate<class T> T max(vector<T> a, int n) { return *max_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T> T max(vector<T> a, int s, int n) { return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<typename A, size_t N> A max(A (&a)[N]) {\n    A res = a[0];\n    rep(i, N)res = max(res, a[i]);\n    return res;\n}\ntemplate<typename A, size_t N, size_t O> A max(A (&a)[N][O]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P> A max(A (&a)[N][O][P]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q> A max(A (&a)[N][O][P][Q], const T &v) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A max(A (&a)[N][O][P][Q][R]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A max(A (&a)[N][O][P][Q][R][S]) {\n    A res = max(a[0]);\n    rep(i, N)res = max(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N> A min(A (&a)[N]) {\n    A res = a[0];\n    rep(i, N)res = min(res, a[i]);\n    return res;\n}\ntemplate<typename A, size_t N, size_t O> A min(A (&a)[N][O]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, max(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P> A min(A (&a)[N][O][P]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q> A min(A (&a)[N][O][P][Q], const T &v) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A min(A (&a)[N][O][P][Q][R]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A min(A (&a)[N][O][P][Q][R][S]) {\n    A res = min(a[0]);\n    rep(i, N)res = min(res, min(a[i]));\n    return res;\n}\n\n\ntemplate<class T> T sum(vector<T> v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 0;\n    chmin(len, v.size());\n    rep(i, len)res += v[i];\n    return res;\n}\ntemplate<class T> T sum(vector<vector<T>> &v, int h = -1, int w = -1) {\n    if (h == -1)h = v.size();\n    if (w == -1)w = v[0].size();\n    T res = 0;\n    chmin(h, v.size());\n    chmin(w, v[0].size());\n    rep(i, h)rep(j, w)res += v[i][j];\n    return res;\n}\n\nP sump(vp &v, int len = -1) {\n    if (len == -1)len = v.size();\n    P res = {0, 0};\n    chmin(len, v.size());\n    rep(i, len) {\n        res.fi += v[i].fi;\n        res.se += v[i].se;\n    }\n    return res;\n}\n\n///要素が0の時、返り値は0か1か\ntemplate<class T> T mul(vector<T> &v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 1;\n    chmin(len, v.size());\n    rep(i, len)res *= v[i];\n    return res;\n}\nvoid clear(PQ &q) { while (q.size())q.pop(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(int size) {\n    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));\n    return body + size;\n}\ntemplate<class T> T *negarr2(int h, int w) {\n    double **dummy1 = new double *[2 * h + 1];\n    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];\n    dummy1[0] = dummy2 + w;\n    for (int i = 1; i <= 2 * h + 1; i++) {\n        dummy1[i] = dummy1[i - 1] + 2 * w + 1;\n    }\n    double **a = dummy1 + h;\n}\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {\n    vector<T> ret = v;\n    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];\n    return ret;\n}\ntemplate<class T> vector<T> imomi(vector<T> &v) {\n    vector<T> ret = v;\n    rep(i, sz(ret) - 1)chmin(ret[i + 1], ret[i]);\n    return ret;\n}\ntemplate<class T> struct ruiC {\n    const vector<T> rui;\n    ruiC(vector<T> &ru) : rui(ru) {}\n    T operator()(int l, int r) {\n        assert(l <= r);\n        return rui[r] - rui[l];\n    }\n    T operator[](int i) {\n        return rui[i];\n    }\n};\n\ntemplate<class T> struct rruic {\n    const T *rrui;\n    rruic(T *ru) : rrui(ru) {}\n    //n-1から-1へ\n    T operator()(int l, int r) {\n        assert(l >= r);\n        return rrui[r] - rrui[l];\n    }\n    T operator[](int i) {\n        return rrui[i];\n    }\n};\ntemplate<class T> vector<T> ruiv(vector<T> &a) {\n    vector<T> ret(a.size() + 1);\n    rep(i, a.size())ret[i + 1] = ret[i] + a[i];\n    return ret;\n}\ntemplate<class T> ruiC<T> ruic(vector<T> &a) {\n    vector<T> ret = ruiv(a);\n    return ruiC<T>(ret);\n}\n//xor\ntemplate<class T> vector<T> ruix(vector<T> &a) {\n    vector<T> ret(a.size() + 1);\n    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];\n    return ret;\n}\ntemplate<class T> vector<T> ruim(vector<T> &a) {\n    vector<T> res(a.size() + 1, 1);\n    rep(i, a.size())res[i + 1] = res[i] * a[i];\n    return res;\n}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> rruic<T> rrui(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    rer(i, len - 1)res[i - 1] = res[i] + a[i];\n    return rruic<T>(res);\n}\n//掛け算\ntemplate<class T> T *rruim(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    res[len - 1] = 1;\n    rer(i, len - 1)res[i - 1] = res[i] * a[i];\n    return res;\n}\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void inc(vector<T> &a, U v = 1) { for (auto &u :a)inc(u, v); }\ntemplate<class T> void inc(vector<T> &a) { for (auto &u :a)inc(u, 1); }\ntemplate<class T, class U> void plus(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void plus(vector<T> &a, U v = 1) { for (auto &u :a)inc(u, v); }\ntemplate<class T> void plus(vector<T> &a) { for (auto &u :a)inc(u, 1); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T> void dec(vector<T> &a) { for (auto &u :a)dec(u, 1); }\ntemplate<class T, class U> void minu(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void minu(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T> void minu(vector<T> &a) { for (auto &u :a)dec(u, 1); }\ninline bool inside(int h, int w, int H, int W) { return h >= 0 && w >= 0 && h < H && w < W; }\ninline bool inside(int v, int l, int r) { return l <= v && v < r; }\n#define ins inside\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {\n    vector<T> ret = a;\n    fora(v, ret)v = u(v);\n    return ret;\n}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\nll goldd(ll left, ll right, function<ll(ll)> calc) {\n    double GRATIO = 1.6180339887498948482045868343656;\n    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n    ll fl = calc(lm);\n    ll fr = calc(rm);\n    while (right - left > 10) {\n        if (fl < fr) {\n            right = rm;\n            rm = lm;\n            fr = fl;\n            lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n            fl = calc(lm);\n        } else {\n            left = lm;\n            lm = rm;\n            fl = fr;\n            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n            fr = calc(rm);\n        }\n    }\n    ll minScore = MAX(ll);\n    ll resIndex = left;\n    for (ll i = left; i < right + 1; i++) {\n        ll score = calc(i);\n        if (minScore > score) {\n            minScore = score;\n            resIndex = i;\n        }\n    }\n    return resIndex;\n}\nll goldt(ll left, ll right, function<ll(ll)> calc) {\n    double GRATIO = 1.6180339887498948482045868343656;\n    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n    ll fl = calc(lm);\n    ll fr = calc(rm);\n    while (right - left > 10) {\n        if (fl > fr) {\n            right = rm;\n            rm = lm;\n            fr = fl;\n            lm = left + (ll) ((right - left) / (GRATIO + 1.0));\n            fl = calc(lm);\n        } else {\n            left = lm;\n            lm = rm;\n            fl = fr;\n            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));\n            fr = calc(rm);\n        }\n    }\n    if (left > right) {\n        ll l = left;\n        left = right;\n        right = l;\n    }\n    ll maxScore = MIN(ll);\n    ll resIndex = left;\n    for (ll i = left; i < right + 1; i++) {\n        ll score = calc(i);\n        if (maxScore < score) {\n            maxScore = score;\n            resIndex = i;\n        }\n    }\n    return resIndex;\n}\ntemplate<class T> T min(vector<vector<T>> &a) {\n    T res = MAX(T);\n    rep(i, a.size())chmin(res, *min_element(all(a[i])));\n    return res;\n}\ntemplate<class T> T max(vector<vector<T>> &a) {\n    T res = MIN(T);\n    rep(i, a.size())chmax(res, *max_element(all(a[i])));\n    return res;\n}\n\nbool bget(ll m, int keta) { return (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {\n    m /= (ll) pow(sinsuu, keta);\n    return m % sinsuu;\n}\ninline ll bit(int n) { return (1LL << (n)); }\ninline ll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\n//int bcou(ll m) { return __builtin_popcount(m & 0xFFFFFFFF) + __builtin_popcount(m >> 32); }\n#define bcou __builtin_popcountll\n//最下位ビット\nint lbit(int n) {\n    return n & -n;\n}\n//最上位ビット\nint hbit(int n) {\n    n |= (n >> 1);\n    n |= (n >> 2);\n    n |= (n >> 4);\n    n |= (n >> 8);\n    n |= (n >> 16);\n    n |= (n >> 32);\n    return n - (n >> 1);\n}\n//初期化は0を渡す\nll nextComb(ll &mask, int n, int r) {\n    if (!mask)return mask = (1LL << r) - 1;\n    ll x = mask & -mask; //最下位の1\n    ll y = mask + x; //連続した下の1を繰り上がらせる\n    ll res = ((mask & ~y) / x >> 1) | y;\n    if (bget(res, n))return mask = 0;\n    else return mask = res;\n}\n\n//n桁以下でビットがr個立っているもののvectorを返す\nvl bitCombList(int n, int r) {\n    vl res;\n    int m = 0;\n    while (nextComb(m, n, r)) {\n        res.pb(m);\n    }\n    return res;\n}\n//大文字小文字を区別する\nint altoiaZ(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a' + 26;\n}\nchar itoalaZ(int i) {\n    if (i < 26)return 'A' + i;\n    return 'a' + i - 26;\n}\n//aもAも0を返す 基本小文字\nint altoi(char c) {\n    if ('A' <= c && c <= 'Z')return c - 'A';\n    return c - 'a';\n}\nchar itoal(int i) {\n    return 'a' + i;\n}\nint ctoi(char c) { return c - '0'; }\nchar itoc(int i) { return i + '0'; }\nint vtoi(vi &v) {\n    int res = 0;\n    if (sz(v) > 18) {\n        debugline(\"vtoi\");\n        deb(sz(v));\n        ole();\n    }\n    rep(i, sz(v)) {\n        res *= 10;\n        res += v[i];\n    }\n    return res;\n}\nvi itov(int i) {\n    vi res;\n    while (i) {\n        res.pb(i % 10);\n        i /= 10;\n    }\n    rev(res);\n    return res;\n}\nvector<vector<int>> ctoi(vector<vector<char>> s, char c) {\n    int n = sz(s), m = sz(s[0]);\n    vector<vector<int>> res(n, vector<int>(m));\n    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;\n    return res;\n}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\nvoid compress(vi &a) {\n    vi b;\n    int len = a.size();\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    unique(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n\nvoid compress(int a[], int len) {\n    vi b;\n    for (int i = 0; i < len; ++i) {\n        b.push_back(a[i]);\n    }\n    sort(b);\n    unique(b);\n    for (int i = 0; i < len; ++i) {\n        a[i] = lower_bound(all(b), a[i]) - b.begin();\n    }\n}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define lowerBound(a, v) (*lower_bound(all(a),v))\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define upperBound(a, v) (*upper_bound(all(a),v))\n#define ans(a) cout<<a<<endl;continue;\n#define poll(a) q.front();q.pop()\n#define dpoll(a) q.front();q.pop_front()\n#define pollLast(a) q.back();q.pop_back()\n#define pollBack(a) q.back();q.pop_back()\ntemplate<class T> inline void fin(T s) { cout << s << endl, exit(0); }\n\ntemplate<class T> struct edge {\n    int f, t;\n    T c;\n    int id;\n    int type;\n    edge(int f, int t, T c = 1, int id = -1, int ty = -1) : f(f), t(t), c(c), id(id), type(ty) {}\n    bool operator<(const edge &b) const { return c < b.c; }\n    bool operator>(const edge &b) const { return c > b.c; }\n};\ntemplate<class T> ostream &operator<<(ostream &os, edge<T> &e) {\n    os << e.f << \" \" << e.t << \" \" << e.c;\n    return os;\n}\ntemplate<typename T> class graph {\nprotected:\n    vector<bool> _used;\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n;\n    graph(int n) : n(n) { g.resize(n), _used.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {\n        this->n = n;\n        g.resize(n);\n        _used.resize(n);\n    }\n    int size() { return g.size(); }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int f, int t, T c, int id, int ty) = 0;\n    virtual bool used(edge<T> &e) = 0;\n    virtual bool used(int id) = 0;\n    virtual void del(edge<T> &e) = 0;\n    virtual void del(int id) = 0;\n    virtual void set_edges() = 0;\n};\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    int eid = 0;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"digraph add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        if (id == -1)id = eid++;\n        g[f].emplace_back(f, t, c, id, ty);\n//        edges.emplace_back(f, t, c, id, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n    void set_edges() {\n        rep(i, n)fora(e, g[i])edges.pb(e);\n    }\n};\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    int eid = 0;\n    undigraph(int n) : graph<T>(n) {\n    }\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"undigraph add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        if (id == -1)id = eid, eid += 2;\n        g[f].emplace_back(f, t, c, id, ty);\n        g[t].emplace_back(t, f, c, id + 1, ty);\n//        edges.emplace_back(f, t, c, id, ty);\n//        edges.emplace_back(t, f, c, id + 1, ty);\n    }\n    void add(edge<T> &e) {\n        int f = e.f, t = e.t, ty = e.type;\n        T c = e.c;\n        add(f, t, c, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n    void set_edges() {\n        rep(i, n)fora(e, g[i])edges.pb(e);\n    }\n};\ntemplate<class T> vector<T> dijkstra(const graph<T> &g, int s, int cant_arrive = -1) {\n    if (!(0 <= s && s < g.n)) {\n        debugline(\"dijkstra\");\n        deb(s, g.n);\n        ole();\n    }\n    T initValue = MAX(T);\n    vector<T> dis(g.n, initValue);\n    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;\n    dis[s] = 0;\n    q.emplace(0, s);\n    while (q.size()) {\n        T nowc = q.top().fi;\n        int i = q.top().se;\n        q.pop();\n        if (dis[i] != nowc)continue;\n        for (auto &&e  : g.g[i]) {\n            int to = e.t;\n            T c = nowc + e.c;\n            if (dis[to] > c) {\n                dis[to] = c;\n                q.emplace(dis[to], to);\n            }\n        }\n    }\n    //基本、たどり着かないなら-1\n    if (cant_arrive == -1)for (auto &&d :dis) if (d == initValue)d = -1;\n    return dis;\n}\ntemplate<class T> vector<vector<T>> warshall(const graph<T> &g, int cant_arrive = -1) {\n    int n = g.n;\n    vector<vector<T> > dis(n, vector<T>(n, linf));\n    rep(i, n)fora(e, g.g[i])chmin(dis[e.f][e.t], e.c);\n    rep(i, n)dis[i][i] = 0;\n    rep(k, n)rep(i, n)rep(j, n)chmin(dis[i][j], dis[i][k] + dis[k][j]);\n    //基本、たどり着かないなら-1\n    if (cant_arrive == -1)rep(i, n)rep(j, n) if (dis[i][j] == linf)dis[i][j] = -1;\n    return dis;\n}\n\ntemplate<class T=int> class tree : public undigraph<T> {\npublic:\n    using undigraph<T>::g;\n    using undigraph<T>::n;\n    using undigraph<T>::edges;\n    using undigraph<T>::_used;\n    vi dep;\n    vi disv;\nprivate:\n    bool never = 1;\n    int root = -1;\n    vector<vector<int>> par;\n    bool costallone;\n    void dfs(int v, int p, int d) {\n        dep[v] = d;\n        par[0][v] = p;\n        int lim = (*this)[v].size();\n        for (int i = 0; i < lim; i++) {\n            int t = g[v][i].t;\n            if (t == p)con;\n            dfs(t, v, d + 1);\n        }\n    }\n    void built() {\n        never = 0;\n        n = g.size();\n        par.assign(30, vi(n));\n        dep.resize(n);\n        costallone = 1;\n        rep(i, n)fora(e, g[i])if (e.c != 1)costallone = 0;\n        dfs(root, -1, 0);\n        rep(k, par.size() - 1) {\n            rep(i, n) {\n                if (par[k][i] == -1)par[k + 1][i] = -1;\n                else par[k + 1][i] = par[k][par[k][i]];\n            }\n        }\n        if (costallone)disv = dep;\n        else disv = dijkstra(*this, root);\n    }\n    int _lca(int u, int v) {\n        if (dep[u] > dep[v])swap(u, v);\n        rep(k, par.size()) {\n            if ((dep[u] - dep[v]) >> k & 1) {\n                v = par[k][v];\n            }\n        }\n        if (u == v)return u;\n        rer(k, par.size() - 1) {\n            if (par[k][u] != par[k][v]) {\n                u = par[k][u];\n                v = par[k][v];\n            }\n        }\n        return par[0][u];\n    }\n    int _dis(int u, int v) {\n        int p = _lca(u, v);\n        return disv[u] + disv[v] - disv[p] * 2;\n    }\npublic:\n    tree(int n, int root = 0) : undigraph<T>(n), root(root) {}\n    bool leaf(int v) {\n        return sz(g[v]) == 1 && v != root;\n    }\n    int dis(int u, int v) {\n        if (never) {\n            built();\n        }\n        return _dis(u, v);\n    }\n    int lca(int u, int v) {\n        if (never) {\n            built();\n        }\n        return _lca(u, v);\n    }\n};\n//辺によりメモリを大量消費\n// よってedgesを消している\n//頂点10^6でメモリを190MB(制限の8割)使う\n\n//軽量化のため、辺を持たないbig gridクラスがあってもいいかもしれない\n//\ntemplate<class T=int> class grid_k6 : public undigraph<T> {\npublic:\n    using undigraph<T>::g;\n    using undigraph<T>::n;\n    using undigraph<T>::edges;\n    using undigraph<T>::_used;\n    int H, W;\n    int eid = 0;\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"grid_k6 add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        g[f].emplace_back(f, t, c, eid++, ty);\n        g[t].emplace_back(t, f, c, eid++, ty);\n    }\n    int getid(int h, int w) {\n        if (!inside(h, w, H, W))return -1;\n        return W * h + w;\n    }\n    P get2(int id) {\n        return mp(id / W, id % W);\n    }\n    P operator()(int id) {\n        return get2(id);\n    }\n    int operator()(int h, int w) {\n        return getid(h, w);\n    }\n    grid_k6(int H, int W) : H(H), W(W), undigraph<T>(H * W) {\n        rep(h, H) {\n            rep(w, W) {\n                int f = getid(h, w);\n                if (w + 1 < W) add(f, getid(h, w + 1));\n                if (h + 1 < H)add(f, getid(h + 1, w));\n            }\n        }\n    }\n    grid_k6(_vvc ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), undigraph<T>(sz(ba) * sz(ba[0])) {\n        rep(h, H) {\n            rep(w, W) {\n                if (ba[h][w] == wall)con;\n                int f = getid(h, w);\n                if (w + 1 < W && ba[h][w + 1] != wall) {\n                    add(f, getid(h, w + 1));\n                }\n                if (h + 1 < H && ba[h + 1][w] != wall) {\n                    add(f, getid(h + 1, w));\n                }\n            }\n        }\n    }\n    void add(int fh, int fw, int th, int tw) {\n        add(getid(fh, fw), getid(th, tw));\n    }\n    void set_edges() {\n        rep(i, n)fora(e, g[i])edges.pb(e);\n    }\n};\n//左上から右下に移動できる\ntemplate<class T=int> class digrid_k6 : public digraph<T> {\npublic:\n    using digraph<T>::g;\n    using digraph<T>::n;\n    using digraph<T>::edges;\n    using digraph<T>::_used;\n    int H, W;\n    int eid = 0;\n    void add(int f, int t, T c = 1, int id = -1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n)) {\n            debugline(\"digrid_k6 add\");\n            deb(f, t, c, id, ty);\n            ole();\n        }\n        g[f].emplace_back(f, t, c, eid++, ty);\n    }\n    int getid(int h, int w) {\n        if (!inside(h, w, H, W))return -1;\n        return W * h + w;\n    }\n    P get2(int id) {\n        return mp(id / W, id % W);\n    }\n    P operator()(int id) {\n        return get2(id);\n    }\n    int operator()(int h, int w) {\n        return getid(h, w);\n    }\n    digrid_k6(int H, int W) : H(H), W(W), digraph<T>(H * W) {\n        rep(h, H) {\n            rep(w, W) {\n                int f = getid(h, w);\n                if (w + 1 < W) add(f, getid(h, w + 1));\n                if (h + 1 < H)add(f, getid(h + 1, w));\n            }\n        }\n    }\n    digrid_k6(_vvc ba, char wall = '#') : H(sz(ba)), W(sz(ba[0])), digraph<T>(sz(ba) * sz(ba[0])) {\n        rep(h, H) {\n            rep(w, W) {\n                if (ba[h][w] == wall)con;\n                int f = getid(h, w);\n                if (w + 1 < W && ba[h][w + 1] != wall) {\n                    add(f, getid(h, w + 1));\n                }\n                if (h + 1 < H && ba[h + 1][w] != wall) {\n                    add(f, getid(h + 1, w));\n                }\n            }\n        }\n    }\n    void add(int fh, int fw, int th, int tw) {\n        add(getid(fh, fw), getid(th, tw));\n    }\n    void set_edges() {\n        rep(i, n)fora(e, g[i])edges.pb(e);\n    }\n};\ntemplate<class T> bool nibu(const graph<T> &g) {\n    int size = 0;\n    rep(i, g.n)size += sz(g.g[i]);\n    if (size == 0)return true;\n\n    UnionFind uf(g.n * 2);\n    rep(i, g.n)fora(e, g.g[i])uf.unite(e.f, e.t + g.n), uf.unite(e.f + g.n, e.t);\n    rep(i, g.n)if (uf.same(i, i + g.n))return 0;\n    return 1;\n}\n//二部グラフを色分けした際の頂点数を返す\ntemplate<class T> vp nibug(graph<T> &g) {\n    vp cg;\n    if (!nibu(g)) {\n        debugline(\"nibu\");\n        ole();\n    }\n    int _n = g.size();\n    vb _was(_n);\n    queue<P> q;\n    rep(i, _n) {\n        if (_was[i])continue;\n        q.push(mp(i, 1));\n        _was[i] = 1;\n        int red = 0;\n        int coun = 0;\n        while (q.size()) {\n            int now = q.front().fi;\n            int col = q.front().se;\n            red += col;\n            coun++;\n            q.pop();\n            forg(gi, g[now]) {\n                if (_was[t])continue;\n                q.push(mp(t, col ^ 1));\n                _was[t] = 1;\n            }\n        }\n        cg.push_back(mp(red, coun - red));\n    }\n    return cg;\n\n}\ntemplate<class T> ostream &operator<<(ostream &os, graph<T> &g) {\n    rep(i, sz(g)) {\n        forg(gi, g[i]) {\n            os << f << \" \" << t << \" \" << c << endl;\n        }\n    }\n    return os;\n}\n\n//機能拡張\nvp vtop(vi &a, vi &b) {\n    vp res(sz(a));\n    rep(i, sz(a))res[i] = mp(a[i], b[i]);\n    return res;\n}\nvoid ptov(vp &p, vi &a, vi &b) {\n    a.resize(sz(p));\n    b.resize(sz(p));\n    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nbasic_string<_CharT, _Traits, _Alloc>\noperator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const int __rv) {\n    basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n    __str.append(to_string(__rv));\n    return __str;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nvoid operator+=(basic_string<_CharT, _Traits, _Alloc> &__lhs, const int __rv) {\n    __lhs += to_string(__rv);\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nbasic_string<_CharT, _Traits, _Alloc>\noperator+(const basic_string<_CharT, _Traits, _Alloc> &__lhs, const signed __rv) {\n    basic_string<_CharT, _Traits, _Alloc> __str(__lhs);\n    __str.append(to_string(__rv));\n    return __str;\n}\ntemplate<typename _CharT, typename _Traits, typename _Alloc>\nvoid operator+=(basic_string<_CharT, _Traits, _Alloc> &__lhs, const signed __rv) {\n    __lhs += to_string(__rv);\n}\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) {\n    a.push(v);\n}\ntemplate<class T, class U> void operator+=(deque<T> &a, U v) {\n    a.push_back(v);\n}\ntemplate<class T, class U>\npriority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {\n    a.push(v);\n    return a;\n}\ntemplate<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {\n    a.push(v);\n    return a;\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {\n    a.pb(v);\n    return a;\n}\ntemplate<class T, class U> vector<T> operator+(const vector <T> &a, U v) {\n    vector<T> ret = a;\n    ret += v;\n    return ret;\n}\ntemplate<class T, class U> vector<T> operator+(U v, const vector <T> &a) {\n    vector<T> ret = a;\n    ret.insert(ret.begin(), v);\n    return ret;\n}\ntemplate<class T> vector<T> &operator+=(vector<T> &a, vector <T> &b) {\n    fora(v, b)a += v;\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, initializer_list<U> v) {\n    for (auto &&va :v)a.pb(va);\n    return a;\n}\ntemplate<class T> vector<T> &operator-=(vector<T> &a, vector <T> &b) {\n    if (sz(a) != sz(b)) {\n        debugline(\"vector<T> operator-=\");\n        deb(a);\n        deb(b);\n        ole();\n    }\n    rep(i, sz(a))a[i] -= b[i];\n    return a;\n}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector <T> &b) {\n    if (sz(a) != sz(b)) {\n        debugline(\"vector<T> operator-\");\n        deb(a);\n        deb(b);\n        ole();\n    }\n    vector<T> res(sz(a));\n    rep(i, sz(a))res[i] = a[i] - b[i];\n    return res;\n}\n\n\ntemplate<typename T> void remove(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\ntemplate<typename T> void remove(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\ntemplate<typename T> void removen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\ntemplate<typename T> void erase(vector<T> &v, unsigned int i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned int s, unsigned int e) {\n    v.erase(v.begin() + s, v.begin() + e);\n}\ntemplate<typename T> void erasen(vector<T> &v, unsigned int s, unsigned int n) {\n    v.erase(v.begin() + s, v.begin() + s + n);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, vector<T> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, initializer_list<U> list) {\n    for (auto &&va :list)v.pb(va);\n}\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned int i, initializer_list<U> list) {\n    for (auto &&va :list)v.insert(v.begin() + i++, va);\n}\ntemplate<typename T> void insert(set<T> &v, vector<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\ntemplate<typename T> void insert(set<T> &v, initializer_list<T> list) {\n    for (auto &&va :list)v.insert(va);\n}\n\n\n//閉路がなければtrue\nbool topo(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.t]++;\n    queue<int> st;\n    rep(i, n)if (nyu[i] == 0)st.push(i);\n    while (st.size()) {\n        int v = st.front();\n        st.pop();\n        res.pb(v);\n        fora(e, g[v]) if (--nyu[e.t] == 0)st.push(e.t);\n    }\n    return res.size() == n;\n}\n//辞書順最小トポロジカルソート\nbool topos(vi &res, digraph<int> &g) {\n    int n = g.g.size();\n    vi nyu(n);\n    rep(i, n)for (auto &&e :g[i])nyu[e.t]++;\n    //小さい順\n    priority_queue<int, vector<int>, greater<int> > q;\n    rep(i, n)if (nyu[i] == 0)q.push(i);\n    while (q.size()) {\n        int i = q.top();\n        q.pop();\n        res.pb(i);\n        fora(e, g[i])if (--nyu[e.t] == 0)q.push(e.t);\n    }\n    return res.size() == n;\n}\nvector<string> split(const string a, const char deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size();\n    vector<string> res;\n    rep(i, n) {\n        if (b[i] == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            l = i + 1;\n        }\n    }\n    return res;\n}\nvector<string> split(const string a, const string deli) {\n    string b = a + deli;\n    int l = 0, r = 0, n = b.size(), dn = deli.size();\n    vector<string> res;\n    rep(i, n) {\n        if (i + dn <= n && b.substr(i, i + dn) == deli) {\n            r = i;\n            if (l < r)res.push_back(b.substr(l, r - l));\n            i += dn - 1;\n            l = i + 1;\n        }\n    }\n    return res;\n}\nvoid yn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n}\nvoid Yn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n}\nvoid YN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n}\nvoid fyn(bool a) {\n    if (a)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n    exit(0);\n}\nvoid fYn(bool a) {\n    if (a)cout << \"Yes\" << endl;\n    else cout << \"No\" << endl;\n    exit(0);\n}\nvoid fYN(bool a) {\n    if (a)cout << \"YES\" << endl;\n    else cout << \"NO\" << endl;\n    exit(0);\n}\nvoid Possible(bool a) {\n    if (a)cout << \"Possible\" << endl;\n    else cout << \"Impossible\" << endl;\n    exit(0);\n}\n\nint n, m, k, d, H, W, x, y, z, q;\nint cou;\nvi a, b, c;\nvvi (s, 0, 0);\nvvc (ba, 0, 0);\nvp p;\n\nstruct Monoid {\n    ll i, v;\n    Monoid(ll i, ll v) : i(i), v(v) {}\n};\n#define segMinl [](Monoid a,Monoid b){return a.v <= b.v ? a : b;} , Monoid(-1,MAX(ll))\n#define segMinr [](Monoid a,Monoid b){return a.v < b.v ? a : b;} , Monoid(-1,MAX(ll))\n#define segMaxl [](Monoid a,Monoid b){return a.v >= b.v ? a : b;} , Monoid(-1,MIN(ll))\n#define segMaxr [](Monoid a,Monoid b){return a.v > b.v ? a : b;} , Monoid(-1,MIN(ll))\n#define segSum  [](Monoid a,Monoid b){return Monoid(a.i+b.i,a.v+b.v);} , Monoid(0,0)\n\nstruct SegmentTree {\n    using func=function<Monoid(Monoid, Monoid)>;\n    int n;\n    vector<Monoid> seg;\n    const func f;\n    const Monoid e;\n    SegmentTree(int len, func f, const Monoid e) : f(f), e(e) {\n        n = 1;\n        while (n < len)n *= 2;\n        seg.assign(2 * n - 1, e);\n    }\n    SegmentTree(vi dat, const func f, const Monoid e) : f(f), e(e) {\n        n = 1;\n        int asz = dat.size();\n        while (n < asz)n *= 2;\n        seg.assign(2 * n - 1, e);\n        rep(i, asz) seg[i + n - 1] = Monoid(i, dat[i]);\n        rer(i, n - 2)seg[i] = f(seg[i * 2 + 1], seg[i * 2 + 2]);\n    }\n    void update(int k, int v) {\n        seg[k + n - 1] = Monoid(k, v);\n        k += n - 1;\n        while (k) {\n            k = (k - 1) / 2;\n            seg[k] = f(seg[k * 2 + 1], seg[k * 2 + 2]);\n        }\n    }\n    void del(int k) {\n        update(k, e.v);\n    }\n    void add(int k, int v) {\n        update(k, v + seg[k + n - 1].v);\n    }\n    Monoid query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l)return e;\n        else if (a <= l && r <= b)return seg[k];\n        else {\n            Monoid sl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n            Monoid sr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n            return f(sl, sr);\n        }\n    }\n    Monoid get(int a = 0, int b = -1) {\n        if (b == -1)b = n;\n        return query(a, b, 0, 0, n);\n    }\n    int geti(int a = 0, int b = -1) {\n        return get(a, b).i;\n    }\n    ll getv(int a = 0, int b = -1) {\n        return get(a, b).v;\n    }\n    int operator()(int a = 0, int b = -1) {\n        return get(a, b).v;\n    }\n    Monoid operator[](int k) const {\n        return seg[k + n - 1];\n    }\n#ifdef _DEBUG\n    void debu() {\n//        cerr << endl << \"i : \";\n//        rep(i, n) {\n//            cerr << operator[](i).i << \" \";\n//        }\n//        cerr << \"\" << endl;\n//        cerr << \"v : \";\n        cerr << endl;\n        rep(i, min(n, 10)) {\n            int v = operator[](i).v;\n            if (v == MIN(ll) || v == MAX(ll)) {\n                cerr << \"e \";\n            } else {\n                cerr << v << \" \";\n            }\n        }\n        cerr << \"\" << endl;\n    }\n#else\n    void debu(){;}\n#endif\n};\n\nvoid solve() {\n    cin >> n >> q;\n    n *= 2;\n    na(a, n);\n    na(b, n);\n    //基本b\n    rep(i, n)c += a[i] - b[i];\n    SegmentTree minu(k5*2, segMaxl);\n    SegmentTree plu(k5*2, segMinl);\n    int pc = 0;\n    int base = 0;\n    int pad = 0;\n    int add = 0;\n    add = a[0] + a[n - 1];\n    rep(i, 1, n - 1) {\n        base += b[i];\n        if (c[i] < 0)minu.update(i, c[i]);\n        else {\n            plu.update(i, c[i]);\n            pc++;\n            pad += c[i];\n        }\n    }\n    while (q--) {\n        din(p, x, y);\n        p--;\n        if (p == 0 || p == n - 1) {\n            add -= a[p];\n            a[p] = x;\n            b[p] = y;\n            add += a[p];\n        } else {\n            base -= b[p];\n            a[p] = x;\n            b[p] = y;\n            base += b[p];\n            int nc = a[p] - b[p];\n            //-に入ってる\n            if (c[p] < 0) {\n                //-から消す\n                if (nc >= 0) {\n                    pad += nc;\n                    plu.update(p, nc);\n                    minu.del(p);\n                    pc++;\n                } else {\n                    minu.update(p, nc);\n                }\n            } else {\n                pad -= c[p];\n                if (nc < 0) {\n                    minu.update(p, nc);\n                    plu.del(p);\n                    pc--;\n                } else {\n                    plu.update(p, nc);\n                    pad += nc;\n                }\n            }\n            c[p] = a[p] - b[p];\n        }\n        plu.debu();\n        if (pc % 2 == 0) {\n            cout << add + pad + base << endl;\n        } else {\n            int res = -linf;\n            //+を一つ消す\n            chma(res, add + pad - plu() + base);\n            //-を一つ取る\n            chma(res, add + pad + minu() + base);\n            cout << res << endl;\n        }\n    }\n\n}\n\nint my(int n, vi a) {\n\n    return 0;\n}\n\nint sister(int n, vi a) {\n\n    return 0;\n}\n\nsigned main() {\n    solve();\n//\n#define _arg n,a\n\n#ifdef _DEBUG\n    bool bad = 0;\n    for (int i = 0, ok = 1; i < k5 && ok; i++) {\n        int n = rand(1, 4);\n        vi a = ranv(m, 1, 10);\n        int myres = my(_arg);\n        int res = sister(_arg);\n        ok = myres == res;\n        if (!ok) {\n            outl(_arg);\n            cout << \"正解 : \" << res << endl;\n            cout << \"自分 : \" << myres << endl;\n            bad = 1;\n            break;\n        }\n    }\n    if (!bad) {\n//        cout << \"完璧です。\" << endl;\n    }\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define llint long long\n#define inf 1000000000000000000\n\nusing namespace std;\n\nllint N, Q;\nllint a[200005], b[200005];\nllint dif[200005];\n\nllint pseg[1<<19];\nvoid pinit()\n{\n\tfor(int i = 0; i < (1<<19); i++) pseg[i] = inf;\n}\nvoid pupdate(llint k, llint val)\n{\n\tk += 1<<18;\n\tpseg[k] = val;\n\twhile(k > 1){\n\t\tk /= 2;\n\t\tpseg[k] = min(pseg[2*k], pseg[2*k+1]);\n\t}\n}\nllint pquery(llint a, llint b, llint k, llint l, llint r)\n{\n\tif(r < a || b < l) return inf;\n\tif(a <= l && r <= b) return pseg[k];\n\tllint lval = pquery(a, b, k*2, l, (l+r)/2);\n\tllint rval = pquery(a, b, k*2+1, (l+r)/2+1, r);\n\treturn min(lval, rval);\n}\n\nllint nseg[1<<19];\nvoid ninit()\n{\n\tfor(int i = 0; i < (1<<19); i++) nseg[i] = -inf;\n}\nvoid nupdate(llint k, llint val)\n{\n\tk += 1<<18;\n\tnseg[k] = val;\n\twhile(k > 1){\n\t\tk /= 2;\n\t\tnseg[k] = max(nseg[2*k], nseg[2*k+1]);\n\t}\n}\nllint nquery(llint a, llint b, llint k, llint l, llint r)\n{\n\tif(r < a || b < l) return -inf;\n\tif(a <= l && r <= b) return nseg[k];\n\tllint lval = nquery(a, b, k*2, l, (l+r)/2);\n\tllint rval = nquery(a, b, k*2+1, (l+r)/2+1, r);\n\treturn max(lval, rval);\n}\n\n\nint main(void)\n{\n\tpinit(), ninit();\n\t\n\tcin >> N >> Q;\n\tfor(int i = 1; i <= 2*N; i++) cin >> a[i];\n\tfor(int i = 1; i <= 2*N; i++) cin >> b[i];\n\t\n\tllint asum = 0;\n\tfor(int i = 1; i <= 2*N; i++){\n\t\tasum += a[i];\n\t\tdif[i] = b[i] - a[i];\n\t}\n\t\n\tllint pcnt = 0, psum = 0;\n\tfor(int i = 2; i <= 2*N-1; i++){\n\t\tif(dif[i] >= 0){\n\t\t\tpupdate(i, dif[i]);\n\t\t\tpcnt++;\n\t\t\tpsum += dif[i];\n\t\t}\n\t\telse nupdate(i, dif[i]);\n\t}\n\t\n\tllint p, x, y;\n\tfor(int q = 0; q < Q; q++){\n\t\tcin >> p >> x >> y;\n\t\tif(p == 1 || p == 2*N){\n\t\t\tasum = asum - a[p] + x;\n\t\t\ta[p] = x;\n\t\t\tgoto end;\n\t\t}\n\t\tif(dif[p] >= 0 && y - x < 0) pcnt--;\n\t\tif(dif[p] < 0 && y - x >= 0) pcnt++;\n\t\tasum = asum - a[p] + x;\n\t\ta[p] = x;\n\t\t\n\t\tif(dif[p] >= 0){\n\t\t\tpupdate(p, inf);\n\t\t\tpsum -= dif[p];\n\t\t}\n\t\telse nupdate(p, -inf);\n\t\t\n\t\tdif[p] = y - x;\n\t\tif(dif[p] >= 0){\n\t\t\tpupdate(p, dif[p]);\n\t\t\tpsum += dif[p];\n\t\t}\n\t\telse nupdate(p, dif[p]);\n\t\t\n\t\tend:;\n\t\t\n\t\tllint ans;\n\t\tif(pcnt % 2 == 0) ans = asum + psum;\n\t\telse{\n\t\t\tans = max(asum + psum + nquery(2, 2*N-1, 1, 0, (1<<18)-1),\n\t\t\t\tasum + psum - pquery(2, 2*N-1, 1, 0, (1<<18)-1));\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<long, int> P;\npriority_queue<P, vector<P>, greater<P>> que_pos;\npriority_queue<P, vector<P>> que_neg;\n\nint main(){\n    long N, Q;\n    long a[200000], b[200000];\n    cin >> N >> Q;\n    for(int i = 0; i < 2*N ; i++){\n        cin >> a[i];\n    }\n    for(int i = 0; i < 2*N ; i++){\n        cin >> b[i];\n    }\n    long sum_a = a[0] + a[2*N-1];\n    long sum_b = 0;\n    int cnt_pos = 0;\n    for(int i = 1; i <= 2*N-2; i++){\n        if(a[i] < b[i]){\n            cnt_pos++;\n            que_pos.push(P(b[i]-a[i], i));\n            sum_b += b[i];\n        }else{\n            que_neg.push(P(b[i]-a[i], i));\n            sum_a += a[i];\n        }\n    }\n    for(int i = 0; i < Q; i++){\n        int p, x, y;\n        cin >> p >> x >> y;\n        p--;\n        if(p != 0 && p != 2*N-1){\n            if(b[p] > a[p]) {\n                cnt_pos--;\n                sum_b -= b[p];\n            }else{\n                sum_a -= a[p];\n            }\n        }\n        a[p] = x;\n        b[p] = y;\n        if(b[p] > a[p]) {\n            cnt_pos++;\n            sum_b += b[p];\n            que_pos.push(P(b[p]-a[p], p));\n        }else{\n            sum_a += a[p];\n            que_neg.push(P(b[p]-a[p], p));\n        }\n        \n        if(cnt_pos%2 == 0){\n            //cout << 'H' << endl;\n            cout << sum_a+sum_b << endl;\n        }else{\n            while(!que_pos.empty()){\n                P top = que_pos.top();\n                int idx = top.second;\n                if(top.first != (b[idx]-a[idx])) que_pos.pop();\n                else break;\n            }\n            while(!que_neg.empty()){\n                P top = que_neg.top();\n                int idx = top.second;\n                if(top.first != (b[idx]-a[idx])) que_neg.pop();\n                else break;\n            }\n            //if(que_neg.empty()) cout << \"neg empty\\n\";\n            //if(que_pos.empty()) cout << \"pos empty\\n\";\n            if(que_neg.top().first+que_pos.top().first >= 0){\n                cout  << sum_a + sum_b + que_neg.top().first << endl;\n            }else{\n                cout  << sum_a + sum_b - que_pos.top().first << endl; \n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define in(x,y,h,w) x >= 0 && x < h && y >= 0 && y < w\nusing namespace std;\n\n#define int long long\n//typedef    long long          ll;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n \nconst int INF=1e+9;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n \nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nclass RMQ{\n\tint n,seg,init;\n\tvector<int> dat;\npublic:\n\tRMQ(int siz,int def) : n(siz),init(def),seg(1){\n\t\twhile(seg < n) seg *= 2;\n\t\tdat.resize(seg * 2 - 1);\n\t\tfor(int i = 0;i < seg * 2 - 1;i++) dat[i] = init;\n\t}\n\tvoid update(int i,int x){\n\t\ti += seg - 1;\n\t\tdat[i] = x;\n\t\twhile(i){\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1],dat[i * 2 + 2]); //do\n\t\t}\n\t}\n\tint get(int a = 0,int b = -1,int k = 0,int l = 0,int r = -1){\n\t\tif(b == -1) b = seg;\n\t\tif(r == -1) r = seg;\n\t\tif(b <= l || r <= a) return init;\n\t\tif(a <= l && r <= b) return dat[k];\n\t\treturn min(get(a,b,k * 2 + 1,l,(l + r) / 2),get(a,b,k * 2 + 2,(l + r) / 2,r)); //do\n\t}\n};\n\nsigned main(){\n\tint n,q,a[200000],b[200000],sum = 0,pos = 0,add = 0;\n\tcin >> n >> q;\n\tvector<RMQ> rmq(2,RMQ(n * 2,INF));\n\tfor(int i = 0;i < n * 2;i++){\n\t\tcin >> a[i];\n\t\tsum += a[i];\n\t}\n\tfor(int i = 0;i < n * 2;i++){\n\t\tcin >> b[i];\n\t\tb[i] -= a[i];\n\t\tif(!i || i == n * 2 - 1) continue;\n\t\tif(b[i] >= 0){\n\t\t\trmq[0].update(i,b[i]);\n\t\t\tpos++;\n\t\t\tadd += b[i];\n\t\t}\n\t\telse rmq[1].update(i,-b[i]);\n\t}\n\tfor(int i = 0;i < q;i++){\n\t\tint p,x,y;\n\t\tcin >> p >> x >> y; p--;\n\t\tsum += x - a[p];\n\t\ta[p] = x;\n\t\tif(!(!p || p == n * 2 - 1)){\n\t\t\tint nb = y - x;\n\t\t\tif(nb >= 0){\n\t\t\t\trmq[0].update(p,nb);\n\t\t\t\trmq[1].update(p,INF);\n\t\t\t\tif(b[p] < 0){\n\t\t\t\t\tpos++;\n\t\t\t\t\tadd += nb;\n\t\t\t\t}else add += nb - b[p];\n\t\t\t}else{\n\t\t\t\trmq[0].update(p,INF);\n\t\t\t\trmq[1].update(p,-nb);\n\t\t\t\tif(b[p] >= 0){\n\t\t\t\t\tpos--;\n\t\t\t\t\tadd -= b[p];\n\t\t\t\t}\n\t\t\t}\n\t\t\tb[p] = nb;\n\t\t}\n\t\tif(pos % 2 == 0) cout << sum + add << endl;\n\t\telse cout << sum + max(add - rmq[0].get(0,n * 2),add + rmq[0].get(0,n * 2) - rmq[1].get(0,n * 2)) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\npair<long long, long long> datas[500000];\nint erased[500000];\nint itr[500000];\nint main() {\n\tiostream::sync_with_stdio(false);\n#define int long long\n\tint n, query;\n\tcin >> n >> query;\n\tREP(i, 2 * n) {\n\t\tcin >> datas[i].first;\n\t}\n\tREP(i, 2 * n) {\n\t\tcin >> datas[i].second;\n\t}\n\tREP(i, 2 * n) {\n\t\titr[i] = i;\n\t}\n\tpriority_queue<pair<long long,long long>> next_loser;\n\tpriority_queue<pair<long long, long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>> next_winner;\n\tlong long now_ans = 0;\n\tnow_ans += datas[0].first;\n\tnow_ans += datas[2 * n - 1].first;\n\tlong long now_cnt = 0;\n\tfor (int i = 1; i < 2 * n - 1; ++i) {\n\t\tnow_ans += datas[i].second;\n\t\tlong long geko = datas[i].first - datas[i].second;\n\t\tif (geko >= 0) {\n\t\t\tnow_cnt++;\n\t\t\tnext_winner.push(make_pair(geko, i));\n\t\t\tnow_ans += geko;\n\t\t}\n\t\telse {\n\t\t\tnext_loser.push(make_pair(geko, i));\n\t\t}\n\t}\n\tint next_move = 2 * n;\n\tREP(i, query) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;\n\t\tif (a == 0 || a == 2 * n - 1) {\n\t\t\tnow_ans -= datas[a].first;\n\t\t\tnow_ans += b;\n\t\t\tdatas[a] = make_pair(b, c);\n\t\t\tcontinue;\n\t\t}\n\t\t//First We need To remove\n\t\tint data_itr = itr[a];\n\t\terased[data_itr] = 1;\n\t\tnow_ans -= datas[data_itr].second;\n\t\tint diff = datas[data_itr].first - datas[data_itr].second;\n\t\tif (diff >= 0) {\n\t\t\tnow_cnt--;\n\t\t\tnow_ans -= diff;\n\t\t}\n\t\telse {\n\t\t\t//nothing\n\t\t}\n\t\twhile (next_winner.empty() == false && erased[next_winner.top().second] == true) {\n\t\t\tnext_winner.pop();\n\t\t}\n\t\twhile (next_loser.empty() == false && erased[next_loser.top().second] == true) {\n\t\t\tnext_loser.pop();\n\t\t}\n\t\tdata_itr = next_move;\n\t\tnext_move++;\n\t\titr[a] = data_itr;\n\t\tdatas[data_itr] = make_pair(b, c);\n\t\tnow_ans += datas[data_itr].second;\n\t\tdiff = datas[data_itr].first - datas[data_itr].second;\n\t\tif (diff >= 0) {\n\t\t\tnow_cnt++;\n\t\t\tnow_ans += diff;\n\t\t\tnext_winner.push(make_pair(diff, data_itr));\n\t\t}\n\t\telse {\n\t\t\t//nothing\n\t\t\tnext_loser.push(make_pair(diff, data_itr));\n\t\t}\n\t\t//OK!\n\t\tif (now_cnt % 2 == 0) {\n\t\t\tcout << now_ans << endl;\n\t\t}\n\t\telse {\n\t\t\tassert(0 == 1);\n\t\t\tlong long geko = now_ans - next_winner.top().first;\n\t\t\tif (next_loser.empty() == false) {\n\t\t\t\tgeko = max(geko, now_ans + next_loser.top().first);\n\t\t\t}\n\t\t\tcout << geko << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<class ValueMonoid, template<class...> class Container=::std::vector>\nclass SegTree{\npublic:\n    using value_structure = ValueMonoid;\n    using value_type = typename value_structure::value_type;\n    using const_reference = const value_type &;\n    using container_type = Container<value_type>;\n    using size_type = typename container_type::size_type;\n\nprivate:\n    ::std::vector<value_type> tree;\n    size_type size_;\n\n    static size_type getsize(const size_type x){\n        size_type ret = 1;\n        while(ret < x)\n            ret <<= 1;\n        return ret;\n    }\n\n    inline value_type calc(const value_type a, const value_type b){\n        return value_structure::operation(a, b);\n    }\n\n    inline void calc_node(const size_type index){\n        if(tree.size() <= (index << 1 | 1)) return;\n        tree[index] = value_structure::operation(tree[index<<1], tree[index<<1 | 1]);\n    }\npublic:\n    SegTree() : size_(0), tree(){}\n    SegTree(const size_type size)\n            : size_(size), tree(size << 1, value_structure::identity()){}\n    template<class InputIterator>\n    SegTree(InputIterator first, InputIterator last)\n            : size_(::std::distance(first, last)){\n        tree = container_type(size_, value_structure::identity());\n        tree.insert(tree.end(), first, last);\n        for(size_type i = size_;i > 0;i--){\n            calc_node(i);\n        }\n    }\n\n    size_type size() const { return size_; }\n    const_reference operator[](const size_type k) const {\n        assert(k < size_);\n        return tree[k+size_];\n    }\n\n    value_type query(size_type l, size_type r){\n        assert(l <= r);\n        assert(0 <= l && l < size_);\n        assert(0 <= r && r <= size_);\n        value_type retl = value_structure::identity(), retr = value_structure::identity();\n        for(l += size_, r += size_; l < r ; l >>= 1, r >>= 1){\n            if(l&1) retl = calc(retl, tree[l++]);\n            if(r&1) retr = calc(tree[--r], retr);\n        }\n        return calc(retl, retr);\n    }\n\n    template<class F>\n    void update(size_type index, const F& f){\n        assert(0 <= index && index < size());\n        index += size_;\n        tree[index] = f(::std::move(tree[index]));\n        while(index >>= 1)\n            calc_node(index);\n    }\n\n    /*\n    template<class F>\n    size_type search(const F& f) const { // [0, result) is True and [0, result-1) is not.\n        if(f(value_structure::identity()))\n            return 0;\n        if(!f(tree[1]))\n            return size_+1;\n        value_type acc = value_structure::identity();\n        size_type i = 1;\n        while(i <\n    }\n    */\n};\n\nclass v_monoid {\npublic:\n    using value_type = PLL;\n    static value_type identity() { return PLL(-INF_LL, -INF_LL); }\n    static value_type initializer() { return {-INF_LL, -INF_LL}; }\n    static value_type operation(const value_type& a, const value_type& b) {\n        if (a == identity()) return b;\n        if (b == identity()) return a;\n        return {max(a.fs+b.fs, a.sc+b.sc), max(a.fs+b.sc, a.sc+b.fs)};\n    }\n};\n\nint main(void) {\n    int64 N, Q;\n    cin >> N >> Q;\n    N *= 2;\n    vector<int64> a(N), b(N);\n    REP(i, N) cin >> a[i];\n    REP(i, N) cin >> b[i];\n    multiset<int64> as, bs;\n    int64 res = a[0] + a.back();\n    SegTree<v_monoid> sg(N);\n    FOR(i, 1, N-1) {\n        sg.update(i, [&](const PLL x) { return PLL(a[i], b[i]); });\n    }\n    REP(i, Q) {\n        int64 p, x, y;\n        cin >> p >> x >> y; p--;\n        if (p == 0 || p == N-1) {\n            res -= a[p]; res += x;\n            a[p] = x;\n        } else {\n            sg.update(p, [&](const PLL alskdj) { return PLL(x, y); });\n        }\n        cout << res + sg.query(1, N).fs << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<59;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e5;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n,q;\nvl a,b;\n\nint main(){\n\tcin>>n>>q;\n\tn*=2;\n\ta=b=vl(n);\n\tfor(int i=0;i<n;i++) cin>>a[i];\n\tfor(int i=0;i<n;i++) cin>>b[i];\n\tll sum=0,tmp=0;\n\tmultiset<ll> st1,st2;\n\tfor(int i=1;i<n-1;i++){\n\t\tll t=a[i]-b[i];\n\t\ttmp+=b[i];\n\t\tif(t>0){\n\t\t\tst1.insert(t);\n\t\t\tsum+=t;\n\t\t}\n\t\telse st2.insert(t);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tll p,x,y;\n\t\tcin>>p>>x>>y;\n\t\tp--;\n\t\tll t=a[p]-b[p];\n\t\tif(0<p&&p<n-1){\n\t\t\tif(t>0){\n\t\t\t\tst1.erase(st1.lower_bound(t));\n\t\t\t\tsum-=t;\n\t\t\t}\n\t\t\telse st2.erase(st2.lower_bound(t));\n\t\t\ttmp+=y-b[p];\n\t\t\ta[p]=x;b[p]=y;\n\t\t\tt=a[p]-b[p];\n\t\t\tif(t>0){\n\t\t\t\tst1.insert(t);\n\t\t\t\tsum+=t;\n\t\t\t}\n\t\t\telse st2.insert(t);\n\t\t}\n\t\tif(st1.size()%2==0) cout<<sum+tmp+a[0]+a[n-1]<<endl;\n\t\telse{\n\t\t\tcout<<max(-*st1.begin(),(st2.empty()?-INF:*(--st2.end())))+sum+tmp+a[0]+a[n-1]<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\n#define ZERO(a) memset(a,0,sizeof(a))\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n#define exists find_if\n#define forall all_of\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\nusing ld = long double;  using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>; vll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\n\ninline void input(int &v){ v=0;char c=0;int p=1; while(c<'0' || c>'9'){if(c=='-')p=-1;c=getchar();} while(c>='0' && c<='9'){v=(v<<3)+(v<<1)+c-'0';c=getchar();} v*=p; }\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; o << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const unordered_set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U, typename V>  ostream &operator<<(ostream &o, const unordered_map<T, U, V> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvector<int> range(const int x, const int y) { vector<int> v(y - x + 1); iota(v.begin(), v.end(), x); return v; }\ntemplate <typename T> istream& operator>>(istream& i, vector<T>& o) { rep(j, o.size()) i >> o[j]; return i;}\nstring bits_to_string(ll input, ll n=64) { string s; rep(i, n) s += '0' + !!(input & (1ll << i)); reverse(all(s)); return s; }\ntemplate <typename T> ostream &operator<<(ostream &o, const priority_queue<T> &v) { auto tmp = v; while (tmp.size()) { auto x = tmp.top(); tmp.pop(); o << x << \" \";} o << endl; return o; }\n\ntemplate <typename T> unordered_map<T, ll> counter(vector<T> vec){unordered_map<T, ll> ret; for (auto&& x : vec) ret[x]++; return ret;};\nstring substr(string s, P x) {return s.substr(x.fi, x.se - x.fi); }\nvoid vizGraph(vvll& g, int mode = 0, string filename = \"out.png\") { ofstream ofs(\"./out.dot\"); ofs << \"digraph graph_name {\" << endl; set<P> memo; rep(i, g.size())  rep(j, g[i].size()) { if (mode && (memo.count(P(i, g[i][j])) || memo.count(P(g[i][j], i)))) continue; memo.insert(P(i, g[i][j])); ofs << \"    \" << i << \" -> \" << g[i][j] << (mode ? \" [arrowhead = none]\" : \"\")<< endl;  } ofs << \"}\" << endl; ofs.close(); system(((string)\"dot -T png out.dot >\" + filename).c_str()); }\n\nsize_t random_seed; namespace std { using argument_type = P; template<> struct hash<argument_type> { size_t operator()(argument_type const& x) const { size_t seed = random_seed; seed ^= hash<ll>{}(x.fi); seed ^= (hash<ll>{}(x.se) << 1); return seed; } }; }; // hash for various class\nnamespace myhash{ const int Bsizes[]={3,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81}; const int xor_nums[]={0x100007d1,0x5ff049c9,0x14560859,0x07087fef,0x3e277d49,0x4dba1f17,0x709c5988,0x05904258,0x1aa71872,0x238819b3,0x7b002bb7,0x1cf91302,0x0012290a,0x1083576b,0x76473e49,0x3d86295b,0x20536814,0x08634f4d,0x115405e8,0x0e6359f2}; const int hash_key=xor_nums[rand()%20]; const int mod_key=xor_nums[rand()%20]; template <typename T> struct myhash{ std::size_t operator()(const T& val) const { return (hash<T>{}(val)%mod_key)^hash_key; } }; };\ntemplate <typename T> class uset:public std::unordered_set<T,myhash::myhash<T>> { using SET=std::unordered_set<T,myhash::myhash<T>>; public: uset():SET(){SET::rehash(myhash::Bsizes[rand()%20]);} };\nuint32_t randxor() { static uint32_t x=1+(uint32_t)random_seed,y=362436069,z=521288629,w=88675123; uint32_t t; t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) ); }\nstruct timeval start; double sec() { struct timeval tv; gettimeofday(&tv, NULL); return (tv.tv_sec - start.tv_sec) + (tv.tv_usec - start.tv_usec) * 1e-6; }\nstruct init_{init_(){ gettimeofday(&start, NULL); ios::sync_with_stdio(false); cin.tie(0); struct timeval myTime; struct tm *time_st; gettimeofday(&myTime, NULL); time_st = localtime(&myTime.tv_sec); srand(myTime.tv_usec); random_seed = RAND_MAX / 2 + rand() / 2; }} init__;\n#define rand randxor\n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n#define ldout fixed << setprecision(40) \n\n// 対応する括弧列を出力する。対応する閉括弧が異常なら-1, 開括弧が異常なら-2\n// O(n^2)\n// もう少しどうにかなると思うけど…しかも、できれば深さも知りたい\n//  ) ) ( ) (\n// -1-1 3 2-2\nvector<ll> correspondingParentheses(string& s) {\n    vector<ll> ret(s.length(), -1);\n    rep(i, s.length()) {\n        if (ret[i] >= 0) continue;\n        ll j;\n        ll sum = 0;\n        for (j = i; j < s.length(); j++) {\n            sum += (s[j] == '(' ? 1 : -1);\n            if (sum < 0) { ret[i] = -1; break; }\n            if (sum == 0) { ret[i] = j, ret[j] = i; break; }\n        }\n        if (j == s.length()) \n            ret[i] = -2;\n    }\n    return ret;\n}\n// sが正しい括弧列かを判別する\n// O(n)\nbool isValidParentheses(string& s) {\n    ll counter = 0; \n    rep(i, s.length()) \n        if ((counter += (s[i] == '(' ? 1 : -1)) < 0)\n            return false;\n    return counter == 0;\n}\n// sの括弧数を求める\n// O(n)\nll countOpenParentheses(string& s) { ll sum = 0; rep(i, s.length()) sum += s[i] == ')'; return sum; }\nll countClosingParentheses(string& s) { ll sum = 0; rep(i, s.length()) sum += s[i] == '('; return sum; }\n\n// sの括弧列の全列挙\n// O(2^n), n = 32までは現実的な時間で終わる\n// 0 1 // 2 1 // 4 2 // 6 5 // 8 14 // 10 42 // 12 132 // 14 429 // 16 1430 // 18 4862 // 20 16796\n// 22 58786 // 24 208012 // 26 742900 // 28 2674440 // 30 9694845 // 32 35357670 // 34 129644790\nvoid numerateParentheses(int n, vector<ll>& q_next) {\n    q_next.clear();\n    if (n < 0 || n % 2) return;\n    vector<ll> q;\n    q_next.pb(0);\n    ll t = 0;\n    while (t < n && !q_next.empty()) {\n        q.swap(q_next);\n        while (!q.empty()) {\n            ll tmp = q.back(); q.pop_back();\n            if (__builtin_popcount(tmp) > t / 2) // if 011->2,3/2=1 ->OK, 0011->2, 4/2=2->NG\n                q_next.pb(tmp); // Down\n            if (__builtin_popcount(tmp) < n / 2)\n                q_next.pb(tmp | (1ll << t)); // Up\n        }\n        t++;\n    }\n}\n\nP getNeededParentheseNum(string& t) {\n    ll balance = 0;\n    ll open = 0, close = 0;\n    rep(i, t.size()) {\n        if (t[i] == '(') {\n            if (balance + i >= t.size() - 1)  // (では降りきれない\n                close++, balance--;\n            else \n                balance++;\n        } else {\n            if (balance <= 0)  // )ではもう降りれない\n                open++, balance++;\n            else \n                balance--;\n        }\n    }\n    return P(open, close);\n}\n\n\nint main(void) {\n    ll n, q; cin >> n >> q;\n    assert(n <= 5);\n    assert(q <= 10);\n    n *= 2;\n    vector<string> ss;\n    rep(mask1, 1ll<<(n)) {\n        string s;\n        rep(i, n) s += (mask1 & (1ll << i)) ? '(' : ')';\n        if (!isValidParentheses(s)) continue;\n        ss.pb(s);\n    }\n    ll m = ss.size();\n    vll a(n), b(n); cin >> a >> b;\n\n    rep(_, q) {\n        ll p; cin >> p; p--;\n        cin >> a[p] >> b[p];\n\n        ll ret = -INF;\n        rep(i, m) rep(j, m) {\n            ll score = 0;\n            string& s = ss[i]; \n            string& t = ss[j]; \n            rep(k, n) {\n                if (s[k] == t[k]) {\n                    score += a[k];\n                } else {\n                    score += b[k];\n                }\n            }\n            if (ret < score) {\n                ret = score;\n//                cout << s << \" \"<<t<<endl;\n//                cout << ret << endl;\n            }\n            chmax(ret, score);\n        }\n        cout << ret << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=1e9+7;\nconst llint big=1e15+100;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){return a/gcd(a,b)*b;}\nint main(void){\n\tint i,n,q;cin>>n>>q;\n\tllint gen=0,gu=0;\n\tvector<llint>a(2*n);for(auto &it:a){cin>>it;}\n\tvector<llint>b(2*n);for(auto &it:b){cin>>it;}\n\tmultiset<int>aki;\n\tgen=a[0]+a[2*n-1];\n\tfor(i=1;i<2*n-1;i++){\n\t\tgen+=max(a[i],b[i]);\n\t\taki.ins(abs(a[i]-b[i]));\n\t\tif(a[i]>b[i]){gu++;}\n\t}\n\twhile(q--){\n\t\tint p,x,y;cin>>p>>x>>y;p--;\n\t\tif(p==0||p==2*n-1){gen-=a[p];a[p]=x;b[p]=y;gen+=a[p];}\n\t\telse{\n\t\t\tif(a[p]>b[p]){gu++;}\n\t\t\taki.erase(aki.lower_bound(abs(a[p]-b[p])));\n\t\t\tgen-=max(a[p],b[p]);\n\t\t\ta[p]=x;b[p]=y;\n\t\t\tif(a[p]>b[p]){gu++;}\n\t\t\taki.ins(abs(a[p]-b[p]));\n\t\t\tgen+=max(a[p],b[p]);\n\t\t}\n\t\tif(gu%2==0){cout<<gen<<endl;}\n\t\telse{cout<<gen-(*aki.begin())<<endl;}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N, Q;\nint A[200011], B[200011];\nmultiset<int> L, R;\nLL sum, sumL, sumR;\n\nvoid add(LL x) {\n    if (x < 0) {\n\tL.insert(x);\n\tsumL += x;\n    } else {\n\tR.insert(x);\n\tsumR += x;\n    }\n}\n\nvoid del(LL x) {\n    if (x < 0) {\n\tL.erase(L.find(x));\n\tsumL -= x;\n    } else {\n\tR.erase(R.find(x));\n\tsumR -= x;\n    }\n}\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &Q);\n    REP (i, N*2) scanf(\"%d\", A+i);\n    REP (i, N*2) scanf(\"%d\", B+i);\n\n    for (int i=1; i+1<N*2; i++) {\n\tadd(B[i] - A[i]);\n    }\n\n    REP (i, N*2) sum += A[i];\n\n    REP ($, Q) {\n\tint p, x, y;\n\tscanf(\"%d%d%d\", &p, &x, &y);\n\tp--;\n\tsum -= A[p];\n\tif (0 < p && p < N*2-1) {\n\t    del(B[p] - A[p]);\n\t}\n\tA[p] = x;\n\tB[p] = y;\n\tif (0 < p && p < N*2-1) {\n\t    add(B[p] - A[p]);\n\t}\n\tsum += A[p];\n\n\tLL ans = sum;\n\n\tif (R.size() & 1) {\n\t    amax(ans, sum + sumR - *R.begin());\n\t    amax(ans, sum + sumR + *L.rbegin());\n\t} else {\n\t    amax(ans, sum + sumR);\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n    }\n\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n#define MAXN 200000\n#define ll long long\n#define INFLL 0x3f3f3f3f3f3f3f3fll\n#define rint register int\n#define gc() getchar()\ninline int read(rint ans = 0, rint sgn = ' ', rint ch = gc())\n{\n\tfor(; ch < '0' || ch > '9'; sgn = ch, ch = gc());\n\tfor(; ch >='0' && ch <='9';(ans*=10)+=ch-'0', ch = gc());\n\treturn sgn-'-'?ans:-ans;\n}\n#define BUF_SIZE 1000000\n#define _END fwrite(_Ob,1,_O-_Ob,stdout), _O = _Ob\n#define Outc(a) (*_O++ = a)\nchar _Ob[BUF_SIZE+5], *_O = _Ob, _Os[25], *_Ot;\ntemplate <typename T> inline void Out(T x)\n{\n\tif(!x){Outc('0'); return;} if(x < 0) Outc('-'), x = -x;\n\tfor(_Ot = _Os; x; *_Ot++ = x%10+'0', x /= 10);\n\tfor(; _Ot != _Os; Outc(*--_Ot)); if(_O-_Ob >= BUF_SIZE-50) _END;\n}\nint n, q, a[MAXN+5], b[MAXN+5]; multiset<int> Pos, Neg; multiset<int>::iterator it; ll base, sum;\nint main()\n{\n\tn = read()<<1, q = read(); for(rint i = 1; i <= n; base += (a[i++]=read())); for(rint i = 1; i <= n; b[i++] = read());\n\tfor(rint i = 2; i < n; b[i]>=a[i] ? sum += b[i]-a[i], Pos.insert(b[i]-a[i]) : Neg.insert(b[i]-a[i]), i++);\n\tfor(rint p; q--; Out(base+(Pos.size()&1?max(sum+(Neg.size()?*--Neg.end():INFLL),sum-*Pos.begin()):sum)), Outc('\\n'))\n\t{\n\t\tp = read(), base -= a[p], p>1&&p<n ? it = (b[p]>=a[p] ? sum -= b[p]-a[p], Pos.find(b[p]-a[p]) : Neg.find(b[p]-a[p])), (b[p]>=a[p]?Pos:Neg).erase(it),0 : 0;\n\t\ta[p] = read(), b[p] = read(), base += a[p], p>1&&p<n ? b[p]>=a[p] ? sum += b[p]-a[p], Pos.insert(b[p]-a[p]) : Neg.insert(b[p]-a[p]),0 : 0;\n\t}\t_END; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint N, Q;\n \nsigned main() {\n    cin >> N >> Q;\n\n    int L = 2*N;\n    vector<int> A(L), B(L);\n    for(int i=0; i<L; i++) cin >> A[i];\n    for(int i=0; i<L; i++) cin >> B[i];\n\n    int sum = 0, use = 0;\n    set< pair<int, int> > S;\n    for(int i=1; i<L-1; i++) {\n        sum += max(A[i], B[i]);\n        if(A[i] < B[i]) use ^= 1;\n        S.insert(make_pair(abs(A[i] - B[i]), i));\n    }\n\n    while(Q--) {\n        int i, x, y; cin >> i >> x >> y; i--;\n        if(i != 0 && i != L-1) {\n            sum -= max(A[i], B[i]);\n            if(A[i] < B[i]) use ^= 1;\n            S.erase(make_pair(abs(A[i] - B[i]), i));\n\n            sum += max(x, y);\n            if(x < y) use ^= 1;\n            S.insert(make_pair(abs(x - y), i));\n        }\n\n        A[i] = x, B[i] = y;\n        int ans = sum + A[0] + A[L-1];\n        if(use) ans -= S.begin() -> first;\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<::std::uint_fast64_t mod>\nclass ModInt{\nprivate:\n    using value_type = ::std::uint_fast64_t;\n    value_type n;\npublic:\n    ModInt() : n(0) {}\n    ModInt(value_type n_) : n(n_ % mod) {}\n    ModInt(const ModInt& m) : n(m.n) {}\n\n    template<typename T>\n    explicit operator T() const { return static_cast<T>(n); }\n    value_type get() const { return n; }\n\n    friend ::std::ostream& operator<<(::std::ostream &os, const ModInt<mod> &a) {\n        return os << a.n;\n    }\n\n    friend ::std::istream& operator>>(::std::istream &is, ModInt<mod> &a) {\n        value_type x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return is;\n    }\n\n    bool operator==(const ModInt& m) const { return n == m.n; }\n    bool operator!=(const ModInt& m) const { return n != m.n; }\n    ModInt& operator*=(const ModInt& m){ n = n * m.n % mod; return *this; }\n\n    ModInt pow(value_type b) const{\n        ModInt ans = 1, m = ModInt(*this);\n        while(b){\n            if(b & 1) ans *= m;\n            m *= m;\n            b >>= 1;\n        }\n        return ans;\n    }\n\n    ModInt inv() const { return (*this).pow(mod-2); }\n    ModInt& operator+=(const ModInt& m){ n += m.n; n = (n < mod ? n : n - mod); return *this; }\n    ModInt& operator-=(const ModInt& m){ n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n    ModInt& operator/=(const ModInt& m){ *this *= m.inv(); return *this; }\n    ModInt operator+(const ModInt& m) const { return ModInt(*this) += m; }\n    ModInt operator-(const ModInt& m) const { return ModInt(*this) -= m; }\n    ModInt operator*(const ModInt& m) const { return ModInt(*this) *= m; }\n    ModInt operator/(const ModInt& m) const { return ModInt(*this) /= m; }\n    ModInt& operator++(){ n += 1; return *this; }\n    ModInt& operator--(){ n -= 1; return *this; }\n    ModInt operator++(int){\n        ModInt old(n);\n        n += 1;\n        return old;\n    }\n    ModInt operator--(int){\n        ModInt old(n);\n        n -= 1;\n        return old;\n    }\n    ModInt operator-() const { return ModInt(mod-n); }\n};\n\nclass UnionFind{\nprivate:\n    ::std::vector<int_fast32_t> par;\n    vector<int64> sum;\n    size_t n;\n\npublic:\n    UnionFind(){}\n    UnionFind(size_t n):n(n){\n        par.resize(n, -1);\n        sum.resize(n, 0);\n    }\n\n    void set_sum(const vector<int64>& s) {\n        sum = s;\n    }\n\n    uint_fast32_t find(uint_fast32_t x){\n        return par[x] < 0 ? x : par[x] = find(par[x]);\n    }\n\n    size_t size(uint_fast32_t x){\n        return -par[find(x)];\n    }\n\n    int64 sum_v(int64 x) {\n        return sum[find(x)];\n    }\n\n    bool unite(uint_fast32_t x, uint_fast32_t y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return false;\n        if(size(x) < size(y)) std::swap(x, y);\n        par[x] += par[y];\n        sum[x] += sum[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool same(uint_fast32_t x, uint_fast32_t y){\n        return find(x) == find(y);\n    }\n};\n\n\n\nint main(void) {\n    int64 N, Q;\n    cin >> N >> Q;\n    N*=2;\n    vector<int64> a(N), b(N);\n    REP(i, N) cin >> a[i];\n    REP(i, N) cin >> b[i];\n    multiset<PLL> as, bs;\n    vector<int64> wh(N);\n    int64 res = a[0] + a.back();\n    FOR(i, 1, N-1) {\n        if (a[i] >= b[i]) {\n            as.insert(PLL(a[i]-b[i], i));\n            res += a[i];\n            wh[i] = 0;\n        } else {\n            bs.insert(PLL(b[i]-a[i], i));\n            res += b[i];\n            wh[i] = 1;\n        }\n    }\n    REP(i, Q) {\n//        cout << endl;\n        int64 p, x, y;\n        cin >> p >> x >> y; p--;\n        if (p == 0 || p == N-1) {\n            res -= a[p];\n            a[p] = x; b[p] = y;\n            res += a[p];\n        } else {\n            if (wh[p] == 0) {\n                res -= a[p];\n                as.erase(as.lower_bound(PLL(a[p]-b[p], p)));\n            } else {\n                res -= b[p];\n                bs.erase(bs.lower_bound(PLL(b[p]-a[p], p)));\n            }\n            a[p] = x; b[p] = y;\n            if (a[p] >= b[p]) {\n                res += a[p];\n                wh[p] = 0;\n                as.insert(PLL(a[p]-b[p], i));\n            } else {\n                res += b[p];\n                wh[p] = 1;\n                bs.insert(PLL(b[p]-a[p], i));\n            }\n//            cout << res << endl;\n            if (as.size() % 2) {\n                auto ia = *as.begin(), ib = *bs.begin();\n                if (ia.fs >= ib.fs) {\n                    res -= ib.fs;\n                    wh[ib.sc] = 0;\n                    as.insert(PLL(-ib.fs, ib.sc));\n                    bs.erase(bs.begin());\n                } else {\n                    res -= ia.fs;\n                    wh[ia.sc] = 1;\n                    bs.insert(PLL(-ia.fs, ia.sc));\n                    as.erase(as.begin());\n                }\n            }\n        }\n//        for (auto x : as) {\n//            cout << x.fs << \" \";\n//        }\n//        cout << endl;\n//        for (auto x : bs) {\n//            cout << x.fs << \" \";\n//        }\n//        cout << endl;\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define DEBUG_MODE\n#define endl '\\n'\n#ifdef DEBUG_MODE\n#define DEBUG(...) debug_func_mult(split_names(#__VA_ARGS__), __VA_ARGS__)\n#define DEBUG_ENDL endl << flush\n#define DEBUG_SEPARATOR_LINE cout<<\"=================\\n\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_ENDL 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\n#define DEBUG_ENDL_S(S) ((S).size() ? \"\\n\" : \"\") << flush;\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\ntemplate <typename T, typename U> using P = pair<T, U>;\nusing ll = int64_t;\nusing PLL = P<ll, ll>;\n\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename Head, typename... Tail> const Head& var_min(const Head &head, const Tail&... tail) { return min(head, var_min(tail...)); }\ntemplate <typename Head, typename... Tail> const Head& var_max(const Head &head, const Tail&... tail) { return max(head, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\n\nstring to_string(const string &s) { return s; }\n\ntemplate <typename T, typename U>\nstring to_string(const P<T, U> &p) {\n    string ret = \"(\";\n    ret += to_string(p.first);\n    ret += \", \";\n    ret += to_string(p.second);\n    ret += \")\";\n    return move(ret);\n}\n\ntemplate <typename T>\nstring to_string(const V<T> &v) {\n    string ret = \"{\";\n    for(const T &t : v) {\n        ret += to_string(t);\n        ret += \", \";\n    }\n    ret += \"}\";\n    return move(ret);\n}\n\ntemplate <typename T>\nvoid debug_func(const T &t, const string &s = \"\") {\n    if(s.size()) cout << s << \" = \";\n    cout << to_string(t) << DEBUG_ENDL_S(s);\n}\n\ntemplate <typename T>\nvoid debug_func_mult(int idx, const V<string> &names, const T &t) {\n    debug_func(t, names[idx]);\n}\n\ntemplate <typename T>\nvoid debug_func_mult(const V<string> &names, const T &t) {\n    debug_func(t, names[0]);\n}\n\ntemplate <typename Head, typename... Tail>\nvoid debug_func_mult(int idx, const V<string> &names, const Head &head, const Tail&... args) {\n    debug_func(head, names[idx]);\n    debug_func_mult(idx + 1, names, args...);\n}\n\ntemplate <typename Head, typename... Tail>\nvoid debug_func_mult(const V<string> &names, const Head &head, const Tail&... args) {\n    debug_func(head, names[0]);\n    debug_func_mult(1, names, args...);\n}\n\nV<string> split_names(string &&s) {\n    replace(ALL(s), ' ', ',');\n    V<string> ret;\n    istringstream ss(s);\n    string t;\n    while(getline(ss, t, ',')) if(t.size()) ret.push_back(move(t));\n    return move(ret);\n}\n\nvoid init_io() {\n    cin.tie(0);\n    ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(30);\n}\n\nusing TLL = tuple<ll, ll, ll>;\nconst ll INF = 5e15;\n\nint main() {\n    init_io();\n    ll N, Q;\n    cin >> N >> Q;\n    V<ll> A(2 * N), B(2 * N);\n    for(ll &e : A) cin >> e;\n    for(ll &e : B) cin >> e;\n    ll sum = accumulate(ALL(A), 0ll);\n    ll pcnt = 0;\n    ll psum = 0;\n    map<ll, ll> plus, minus;\n    for(ll i = 1; i < 2 * N - 1; i++) {\n        ll dic = B[i] - A[i];\n        if(dic >= 0) {\n            pcnt++;\n            psum += dic;\n            plus[dic]++;\n        } else {\n            minus[-dic]++;\n        }\n    }\n\n    auto update_query = [&](ll dic, bool addq) {\n        auto &mp = (dic < 0 ? minus : plus);\n        dic = abs(dic);\n        if(addq) {\n            mp[dic]++;\n        } else {\n            auto ite = mp.find(dic);\n            ite->second--;\n            if(ite->second == 0) mp.erase(ite);\n        }\n    };\n\n    auto adjust = [&] {\n        if(pcnt % 2 == 0) return psum;\n        auto itep = plus.lower_bound(0);\n        auto item = minus.lower_bound(0);\n        ll mval = min(itep->first, item->first);\n        return psum - mval;\n    };\n\n    for(ll QQ = 0; QQ < Q; QQ++) {\n        ll p, a, b;\n        cin >> p >> a >> b;\n        p--;\n        ll pre_dic = B[p] - A[p];\n        ll new_dic = b - a;\n        sum = sum - A[p] + a;\n        A[p] = a;\n        B[p] = b;\n        if(pre_dic >= 0) {\n            pcnt--;\n            psum -= pre_dic;\n        }\n        if(new_dic >= 0) {\n            pcnt++;\n            psum += new_dic;\n        }\n        update_query(pre_dic, false);\n        update_query(new_dic, true);\n        ll addv = adjust();\n        cout << sum + addv << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main(){\n    long long i, j, k;\n    long long N, Q;\n    cin >> N >> Q;\n    vector<long long> a(2*N), b(2*N);\n    for(i=0; i<2*N; i++) cin >> a[i];\n    for(i=0; i<2*N; i++) cin >> b[i];\n    long long asum = 0;\n    for(i=0; i<2*N; i++) asum += a[i];\n    priority_queue<long long> neg;\n    priority_queue<long long, vector<long long>, greater<long long>> pos;\n    long long psum = 0, np = 0;\n    for(i=1; i<2*N-1; i++){\n        if(a[i] < b[i]){\n            pos.push(b[i] - a[i]);\n            psum += b[i] - a[i];\n            np += 1;\n        }else{\n            neg.push(b[i] - a[i]);\n        }\n    }\n    map<long long, long long> del;\n\n    for(i=0; i<Q; i++){\n        long long p, x, y;\n        cin >> p >> x >> y;\n        p -= 1;\n        asum += x - a[p];\n        long long prev = b[p] - a[p];\n        long long now = y - x;\n        a[p] = x;\n        b[p] = y;\n\n        if(0 < p && p < 2*N-1){\n            if(prev > 0){\n                psum -= prev;\n                np -= 1;\n            }\n            if(now > 0){\n                psum += now;\n                np += 1;\n                pos.push(now);\n            }else{\n                neg.push(now);\n            }\n            if(!pos.empty() && prev == pos.top()){\n                pos.pop();\n                while(!pos.empty() && del[pos.top()] > 0){\n                    del[pos.top()] -= 1;\n                    pos.pop();\n                }\n            }else if(!neg.empty() && prev == neg.top()){\n                neg.pop();\n                while(!neg.empty() && del[neg.top()] > 0){\n                    del[neg.top()] -= 1;\n                    neg.pop();\n                }\n            }else{\n                del[prev] += 1;\n            }\n        }\n\n        long long ans;\n        if(np % 2 == 0){\n            ans = asum + psum;\n        }else{\n            ans = asum + psum + max(-pos.top(), neg.top());\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\npair<long long, long long> datas[500000];\nint erased[500000];\nint itr[500000];\nint main() {\n\tiostream::sync_with_stdio(false);\n#define int long long\n\tint n, query;\n\tcin >> n >> query;\n\tREP(i, 2 * n) {\n\t\tcin >> datas[i].first;\n\t}\n\tREP(i, 2 * n) {\n\t\tcin >> datas[i].second;\n\t}\n\tREP(i, 2 * n) {\n\t\titr[i] = i;\n\t}\n\tpriority_queue<pair<long long,long long>> next_loser;\n\tpriority_queue<pair<long long, long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>> next_winner;\n\tlong long now_ans = 0;\n\tnow_ans += datas[0].first;\n\tnow_ans += datas[2 * n - 1].first;\n\tlong long now_cnt = 0;\n\tfor (int i = 1; i < 2 * n - 1; ++i) {\n\t\tnow_ans += datas[i].second;\n\t\tlong long geko = datas[i].first - datas[i].second;\n\t\tif (geko >= 0) {\n\t\t\tnow_cnt++;\n\t\t\tnext_winner.push(make_pair(geko, i));\n\t\t\tnow_ans += geko;\n\t\t}\n\t\telse {\n\t\t\tnext_loser.push(make_pair(geko, i));\n\t\t}\n\t}\n\tint next_move = 2 * n;\n\tREP(i, query) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;\n\t\tif (a == 0 || a == 2 * n - 1) {\n\t\t\tnow_ans -= datas[a].first;\n\t\t\tnow_ans += b;\n\t\t\tdatas[a] = make_pair(b, c);\n\t\t\tcontinue;\n\t\t}\n\t\t//First We need To remove\n\t\tint data_itr = itr[a];\n\t\terased[data_itr] = 1;\n\t\tnow_ans -= datas[data_itr].second;\n\t\tint diff = datas[data_itr].first - datas[data_itr].second;\n\t\tif (diff >= 0) {\n\t\t\tnow_cnt--;\n\t\t\tnow_ans -= diff;\n\t\t}\n\t\telse {\n\t\t\t//nothing\n\t\t}\n\t\twhile (next_winner.empty() == false && erased[next_winner.top().second] == true) {\n\t\t\tnext_winner.pop();\n\t\t}\n\t\twhile (next_loser.empty() == false && erased[next_loser.top().second] == true) {\n\t\t\tnext_loser.pop();\n\t\t}\n\t\tdata_itr = next_move;\n\t\tnext_move++;\n\t\titr[a] = data_itr;\n\t\tdatas[data_itr] = make_pair(b, c);\n\t\tnow_ans += datas[data_itr].second;\n\t\tdiff = datas[data_itr].first - datas[data_itr].second;\n\t\tif (diff >= 0) {\n\t\t\tnow_cnt++;\n\t\t\tnow_ans += diff;\n\t\t\tnext_winner.push(make_pair(diff, data_itr));\n\t\t}\n\t\telse {\n\t\t\t//nothing\n\t\t\tnext_loser.push(make_pair(diff, data_itr));\n\t\t}\n\t\t//OK!\n\t\tif (now_cnt % 2 == 0) {\n\t\t\tcout << now_ans << endl;\n\t\t}\n\t\telse {\n\t\t\tlong long geko = now_ans - next_winner.top().first;\n\t\t\tif (next_loser.empty() == false) {\n\t\t\t\tgeko = max(geko, now_ans + next_loser.top().first);\n\t\t\t}\n\t\t\tcout << geko << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\nclass LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}};\nvpii factor(int N){vpii r;for(int i=2;i*i<=N;++i){if(N%i==0){r<<pii{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pii{N,1};}return r;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N,Q;cin>>N>>Q;\n\tvi A(2*N);cin>>A;\n\tvi B(2*N);cin>>B;\n\tmultiset<int>po,ne;\n\tll sa=sum(A),sp=0;\n\tfoor(i,1,2*N-2){\n\t\tif(B[i]>=A[i]){\n\t\t\tpo<<B[i]-A[i];\n\t\t\tsp+=B[i]-A[i];\n\t\t}else{\n\t\t\tne<<B[i]-A[i];\n\t\t}\n\t}\n\tfr(q,Q){\n\t\tint p,x,y;cin>>p>>x>>y;\n\t\t--p;\n\t\tsa+=x-A[p];\n\t\tif(1<=p&&p<=2*N-2){\n\t\t\tif(B[p]>=A[p]){\n\t\t\t\tpo.erase(po.lower_bound(B[p]-A[p]));\n\t\t\t\tsp-=B[p]-A[p];\n\t\t\t}else{\n\t\t\t\tne.erase(ne.lower_bound(B[p]-A[p]));\n\t\t\t}\n\t\t\tif(y>=x){\n\t\t\t\tpo<<y-x;\n\t\t\t\tsp+=y-x;\n\t\t\t}else{\n\t\t\t\tne<<y-x;\n\t\t\t}\n\t\t}\n\t\tA[p]=x,B[p]=y;\n\t\tif(po.size()%2){\n\t\t\tprint(sa+sp+max(-*po.begin(),*--ne.end()));\n\t\t}else{\n\t\t\tprint(sa+sp);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nint N, Q;\nint A[200011], B[200011];\nmultiset<int> L, R;\nLL sum, sumL, sumR;\n\nvoid add(LL x) {\n    if (x < 0) {\n\tL.insert(x);\n\tsumL += x;\n    } else {\n\tR.insert(x);\n\tsumR += x;\n    }\n}\n\nvoid del(LL x) {\n    if (x < 0) {\n\tL.erase(L.find(x));\n\tsumL -= x;\n    } else {\n\tR.erase(R.find(x));\n\tsumR -= x;\n    }\n}\n\nvoid MAIN() {\n    scanf(\"%d%d\", &N, &Q);\n    REP (i, N*2) scanf(\"%d\", A+i);\n    REP (i, N*2) scanf(\"%d\", B+i);\n\n    for (int i=1; i+1<N*2; i++) {\n\tadd(B[i] - A[i]);\n    }\n\n    REP (i, N*2) sum += A[i];\n\n    REP ($, Q) {\n\tint p, x, y;\n\tscanf(\"%d%d%d\", &p, &x, &y);\n\tp--;\n\tsum -= A[p];\n\tif (0 < p && p < N*2-1) {\n\t    del(B[p] - A[p]);\n\t    A[p] = x;\n\t    B[p] = y;\n\t    add(B[p] - A[p]);\n\t}\n\tsum += A[p];\n\n\tLL ans = sum;\n\n\tif (R.size() & 1) {\n\t    amax(ans, sum + sumR - *R.begin());\n\t    amax(ans, sum + sumR + *L.rbegin());\n\t} else {\n\t    amax(ans, sum + sumR);\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n    }\n\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,m,n) for(int i = (m); i < (n); i++)\n#define rrep(i,m,n) for(int i = (m); i >= (n); i--)\n#define print(x) cout << (x) << endl;\n#define print2(x,y) cout << (x) << \" \" << (y) << endl;\n#define printa(x,n) for(int i = 0; i < n; i++){ cout << (x[i]) << \" \\n\"[i == n-1];}\n#define printp(x,n) for(int i = 0; i < n; i++){ cout << \"(\" << x[i].first << \", \" << x[i].second << \") \"; } cout << endl;\n#define INF (1e18)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\ntypedef pair<ll, ll> lpair;\nbool check(string s){\n    bool ok = true;\n    ll N = s.size();\n    ll lv = 0, rv = 0;\n    rep(i,0,N){\n        if(s[i] == '('){\n            lv++;\n        }else{\n            if(lv > 0){\n                lv--;\n            }else{\n                return false;\n            }\n        }\n    }\n    if(lv == 0){\n        return true;\n    }else{\n        return false;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N,Q;\n    ll a[200010], b[200010];\n    ll p[100010], x[100010], y[100010];\n    cin >> N >> Q;\n    rep(i,0,2*N) cin >> a[i];\n    rep(i,0,2*N) cin >> b[i];\n    rep(i,0,Q) cin >> p[i] >> x[i] >> y[i];\n    if(N > 5 || Q > 10) return 0;\n    rep(t,0,Q){\n        p[t]--;\n        ll a1 = a[p[t]]; ll b1 = b[p[t]];\n        a[p[t]] = x[t]; b[p[t]] = y[t];\n        ll ans = 0;\n        rep(i,0,pow(2,2*N)){\n            rep(j,0,pow(2,2*N)){\n                ll ans_tmp = 0;\n                string s = \"\", t = \"\";\n                rep(k,0,2*N){\n                    if((i>>k) & 1){\n                        s += '(';\n                    }else{\n                        s += ')';\n                    }\n                }\n                rep(k,0,2*N){\n                    if((j>>k) & 1){\n                        t += '(';\n                    }else{\n                        t += ')';\n                    }\n                }\n                if(!check(s) || !check(t)) continue;\n                rep(k,0,2*N){\n                    if(s[k] == t[k]){\n                        ans_tmp += a[k];\n                    }else{\n                        ans_tmp += b[k];\n                    }\n                }\n                ans = max(ans, ans_tmp); \n            }\n        }\n        print(ans);\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace std::chrono;\n#define int long long\n#define ll long long\nauto start_time = system_clock::now();\n\n//@formatter:off\n#ifdef _DEBUG\n//区間削除は出来ない\ntemplate<class T> struct my_pbds_tree {    set<T> s;    auto begin() { return s.begin(); }    auto end() { return s.end(); }    auto rbegin() { return s.rbegin(); }    auto rend() { return s.rend(); }    auto empty() { return s.empty(); }    auto size() { return s.size(); }    void clear() { s.clear(); }    template<class U> void insert(U v) { s.insert(v); }template<class U> void operator+=(U v) { insert(v); }    template<class F> auto erase(F v) { return s.erase(v); }    template<class U> auto find(U v) { return s.find(v); }    template<class U> auto lower_bound(U v) { return s.lower_bound(v); }    template<class U> auto upper_bound(U v) { return s.upper_bound(v); }    auto find_by_order(ll k) {        auto it = s.begin();        for (ll i = 0; i < k; i++)it++;        return it;    }    auto order_of_key(ll v) {        auto it = s.begin();        ll i=0;        for (;it != s.end() && *it <v ; i++)it++;        return i;    }};\n#define pbds(T) my_pbds_tree<T>\n#else\n#define unordered_map __gnu_pbds::gp_hash_table\n//find_by_order(k) k番目のイテレーター\n//order_of_key(k)  k以上が前から何番目か\n#define pbds(U) __gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>\n#endif\nstruct xorshift {    static uint64_t splitmix64(uint64_t x) {        x += 0x9e3779b97f4a7c15;        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;        return x ^ (x >> 31);    }    size_t operator()(uint64_t x) const {        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(x + FIXED_RANDOM);    }    size_t operator()(std::pair<ll, ll> x) const {        ll v=((x.first) << 32) | x.second;        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(v + FIXED_RANDOM);    }};\ntemplate<class U, class L> void operator+=(__gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> &s, L v) { s.insert(v); }\n//衝突対策\n#define ws wszzzz\n\ntemplate<class A, class B, class C>struct T2 {A f;B s;C t;T2() { f = 0, s = 0, t = 0; }T2(A f, B s, C t) : f(f), s(s), t(t) {}bool operator<(const T2 &r) const {        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;        /*return f != r.f ? f > r.f : s != r.s ?n s > r.s : t > r.t; 大きい順 */   }    bool operator>(const T2 &r) const {        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;        /*return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順 */   }    bool operator==(const T2 &r) const {        return f == r.f && s == r.s && t == r.t;    }    bool operator!=(const T2 &r) const {        return f != r.f || s != r.s || t != r.t;    }};\ntemplate<class A, class B, class C, class D> struct F2 {    A a;    B b;    C c;    D d;    F2() { a = 0, b = 0, c = 0, d = 0; }    F2(A a, B b, C c, D d) : a(a), b(b), c(c), d(d) {}    bool operator<(const F2 &r) const {        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;    /*    return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;*/    }    bool operator>(const F2 &r) const {        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;/*        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;*/    }    bool operator==(const F2 &r) const {        return a == r.a && b == r.b && c == r.c && d == r.d;    }    bool operator!=(const F2 &r) const {        return a != r.a || b != r.b || c != r.c || d != r.d;    }    ll operator[](ll i) {        assert(i < 4);        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;    }};\ntypedef T2<ll, ll, ll> T;\ntypedef F2<ll, ll, ll, ll> F;\nT mt(ll a, ll b, ll c) {return T(a, b, c);}\n\n//@マクロ省略系 型,構造\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\nusing pd =pair<dou, dou>;\n#define fi first\n#define se second\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define el else\n#define elf else if\n#define wh while\n\n#define maxq 1\n#define minq -1\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MALLOC(type, len) (type*)malloc((len) * sizeof(type))\n#define lam(right) [&](ll& p){return p right;}\n\n//マクロ省略系 コンテナ\nusing vi = vector<ll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vp = vector<P>;\nusing vt = vector<T>;\n\n#define V vector\n#define o_vvt(o1, o2, o3, o4, name, ...) name\n#define vvt0(t) V<V<t>>\n#define vvt1(t,a) V<V<t>>a\n#define vvt2(t,a, b) V<V<t>>a(b)\n#define vvt3(t,a, b, c) V<V<t>> a(b,V<t>(c))\n#define vvt4(t,a, b, c, d) V<V<t>> a(b,V<t>(c,d))\n\n#define vvi(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));}\n#define vni(name, ...) auto name = make_v<ll>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<ll, ll>;\nusing mapp = map<P, ll>;\nusing mapd = map<dou, ll>;\nusing mapc = map<char, ll>;\nusing maps = map<str, ll>;\nusing seti = set<ll>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<ll>;\n#define bset bitset\n#define uset unordered_set\n#define useti unordered_set<ll,ll,xorshift>\n#define mset multiset\n#define mseti multiset<ll>\n#define umap unordered_map\n#define umapi unordered_map<ll,ll,xorshift>\n#define umapp unordered_map<P,ll,xorshift>\n#define mmap multimap\n\ntemplate<class T> struct pq {    priority_queue<T, vector<T>, greater<T> > q;/*小さい順*/    T su = 0;    void clear() {q = priority_queue<T, vector<T>, greater<T> >();su = 0;}    void operator+=(T v) {su += v;q.push(v);}    T sum() {return su;}    T top() {return q.top();}    void pop() {su -= q.top();q.pop();}    T poll() {T ret = q.top();su -= ret;q.pop();return ret;}    ll size() {return q.size();}};\ntemplate<class T> struct pqg {    priority_queue<T> q;/*大きい順*/    T su = 0;    void clear() {q = priority_queue<T>();su = 0;}    void operator+=(T v) {su += v;q.push(v);}    T sum() {return su;}    T top() {return q.top();}    void pop() {su -= q.top();q.pop();}    T poll() {T ret = q.top();su -= ret;q.pop();return ret;}    ll size() {return q.size();}};\n#define pqi pq<ll>\n#define pqgi pqg<ll>\n//マクロ 繰り返し\n#define o_rep(o1, o2, o3, o4, name, ...) name\n# define rep1(n) for(ll rep1i = 0,rep1lim=n; rep1i < rep1lim ; ++rep1i)\n# define rep2(i, n) for(ll i = 0,rep2lim=n; i < rep2lim ; ++i)\n#define rep3(i, m, n) for(ll i = m,rep3lim=n; i < rep3lim ; ++i)\n#define rep4(i, m, n, ad) for(ll i = m,rep4lim=n; i < rep4lim ; i+= ad)\n#define rep(...) o_rep(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n\n#define rer2(i, n) for(ll i = n; i >= 0 ; i--)\n#define rer3(i, m, n) for(ll i = m,rer3lim=n; i >= rer3lim ; i--)\n#define rer4(i, m, n, dec) for(ll i = m,rer4lim=n; i >= rer4lim ; i-=dec)\n#define rer(...) o_rep(__VA_ARGS__,rer4,rer3,rer2,)(__VA_ARGS__)\n\n#define reps2(i, j, n) for(ll i = 0,reps2lim=n; i < reps2lim ;++i)for(ll j = 0; j < reps2lim ; ++j)\n#define reps3(i, j, k, n) for(ll i = 0,reps3lim=n; i < reps3lim ; ++i)for(ll j = 0; j < reps3lim ; ++j)for(ll k = 0; k < reps3lim ; ++k)\n#define reps4(i, j, k, l, n) for(ll i = 0,reps4lim=n; i < reps4lim ; ++i)for(ll j = 0; j < reps4lim ; ++j)for(ll k = 0; k < reps4lim ; ++k)for(ll l = 0; l < reps4lim ; ++l)\n#define o_reps(o1, o2, o3, o4, o5, name, ...) name\n#define reps(...) o_reps(__VA_ARGS__,reps4,reps3,reps2,rep2,)(__VA_ARGS__)\n\n#define repss(i, j, k, a, b, c) for(ll i = 0; i < a ; ++i)for(ll j = 0; j < b ; ++j)for(ll k = 0; k < c ; ++k)\n\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) for (ll gi = 0,forglim = ve.size(), f, t, c; gi < forglim && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); ++gi)\n#define fort(gi, ve) for (ll gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); ++gi)if(t!=p)\n\n#define form(st, l, r) for (auto &&it = st.lower_bound(l); it != st.end() && (*it).fi < r; ++it)\n#define forit(st, l, r) for (auto &&it = st.lower_bound(l); it != st.end() && (*it) < r;)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst ll inf = (ll) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst char infc = '{';\nconst string infs = \"{\";\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((ll)(a).size())\n#define mp make_pair\n#define pb pop_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconstexpr bool ev(ll a) { return !(a & 1); }\nconstexpr bool od(ll a) { return (a & 1); }\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\n//@formatter:on\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> { public:size_t operator()(const std::pair<signed, signed> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n    template<> class hash<std::pair<ll, ll>> { public:/*大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断*/size_t operator()(const std::pair<ll, ll> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n}\n//@formatter:off\n//stream まとめ\nistream &operator>>(istream &iss, P &a) {    iss >> a.first >> a.second;    return iss;}template<typename T> istream &operator>>(istream &iss, vector<T> &vec) {    for (T &x: vec) iss >> x;    return iss;}template<class T, class U> ostream &operator<<(ostream &os, pair<T, U> p) {    os << p.fi << \" \" << p.se << endl;    return os;}ostream &operator<<(ostream &os, T p) {    os << p.f << \" \" << p.s << \" \" << p.t;    return os;}ostream &operator<<(ostream &os, F p) {    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;    return os;}template<typename T> ostream &operator<<(ostream &os, vector<T> &vec) {    for (ll i = 0; i < vec.size(); ++i)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");    return os;}template<typename T> ostream &operator<<(ostream &os, vector<vector<T>> &vec) {    for (ll i = 0; i < vec.size(); ++i) {        for (ll j = 0; j < vec[i].size(); ++j) { os << vec[i][j] << \" \"; }        os << endl;    }    return os;}template<typename T, typename U> ostream &operator<<(ostream &os, map<T, U> &m) {    for (auto &&v:m) os << v;    return os;}\ntemplate<typename W, typename H> void resize(vector<W> &vec, const H head) { vec.resize(head); }template<typename W, typename H, typename ... T> void resize(vector<W> &vec, const H &head, const T ... tail) {vec.resize(head);for (auto &v: vec)resize(v, tail...);}\ntemplate<typename T, typename F> bool all_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool all_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (!all_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool any_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool any_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (any_of2(v[i], f))return true; }    return false;}\ntemplate<typename T, typename F> bool none_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool none_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (none_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool find_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll find_if2(vector<T> &v, F f) {    rep(i, sz(v)) { if (find_if2(v[i], f))return i; }    return sz(v);}\ntemplate<typename T, typename F> bool rfind_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll rfind_if2(vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (rfind_if2(v[i], f))return i; }    return -1;}\ntemplate<class T> bool contains(string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> ll count_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll count_if2(vector<T> &vec, F f) {    ll ret = 0;    fora(v, vec)ret += count_if2(v, f);    return ret;}\ntemplate<typename T, typename F> void for_each2(T &v, F f) { f(v); }\ntemplate<typename T, typename F> void for_each2(vector<T> &vec, F f) { fora(v, vec)for_each2(v, f); }\ntemplate<typename W> ll count_od(vector<W> &a) {return count_if2(a,[](ll v){return v&1 ;});}\ntemplate<typename W> ll count_ev(vector<W> &a) {return count_if2(a,[](ll v){return !(v&1) ;});}\n#define all_of(a,right) all_of2(a,lam(right))\n#define any_of(a,right) any_of2(a,lam(right))\n#define none_of(a,right) none_of2(a,lam(right))\n#define find_if(a,right) find_if2(a,lam(right))\n#define rfind_if(a,right) rfind_if2(a,lam(right))\n#define contains_if(a,right) contains_if2(a,lam(right))\n#define count_if(a, right) count_if2(a,lam(right))\n#define for_each(a, right) do{fora(v,a){v right;}}while(0)\n\n\ntemplate<class T, class U> void replace(vector<T> &a, T key, U v) { replace(a.begin(), a.end(), key, v); }\nvoid replace(str &a, char key, str v) { if (v == \"\")a.erase(remove(all(a), key), a.end()); }\nvoid replace(str &a, char key, char v) { replace(all(a), key, v); }\n//keyと同じかどうか01で置き換える\ntemplate<class T, class U> void replace(vector<T> &a, U k) { rep(i, sz(a)) a[i] = a[i] == k; }\ntemplate<class T, class U> void replace(vector<vector<T >> &a, U k) { rep(i, sz(a))rep(j, sz(a[0])) a[i][j] = a[i][j] == k; }\ntemplate<class T> void replace(T &a) { replace(a, '#'); }\nvoid replace(str &a, str key, str v) {stringstream t;ll kn = sz(key);std::string::size_type Pos(a.find(key));ll l = 0;while (Pos != std::string::npos) {t << a.substr(l, Pos - l);t << v;l = Pos + kn;Pos = a.find(key, Pos + kn);}t << a.substr(l, sz(a) - l);a = t.str();}\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {vi c = a;vi d = b;sort(all(c));sort(all(d));return includes(all(c), all(d));}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\nvoid iota(vector<ll> &ve, ll s, ll n) {ve.resize(n);iota(all(ve), s);}\nvi iota(ll s, ll len) {vi ve(len);iota(all(ve), s);return ve;}\ntemplate<class A, class B> auto vtop(vector<A> &a, vector<B> &b) {    assert(sz(a) == sz(b));    /*stringを0で初期化できない  */  vector<pair<A, B>> res;    rep(i, sz(a))res.eb(a[i], b[i]);return res;}\ntemplate<class A, class B> void ptov(vector<pair<A, B>> &p, vector<A> &a, vector<B> &b) {    a.resize(sz(p)), b.resize(sz(p));    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;}\ntemplate<class A, class B, class C> auto vtot(vector<A> &a, vector<B> &b, vector<C> &c) {    assert(sz(a) == sz(b) && sz(b) == sz(c));    vector<T2<A, B, C>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i]);    return res;}\ntemplate<class A, class B, class C, class D> auto vtof(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    assert(sz(a) == sz(b) && sz(b) == sz(c) && sz(c) == sz(d));    vector<F2<A, B, C, D>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i], d[i]);    return res;}\nenum pcomparator { fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd };\nenum tcomparator {    fisiti, fisitd, fisdti, fisdtd, fdsiti, fdsitd, fdsdti, fdsdtd,    fitisi, fitisd, fitdsi, fitdsd, fdtisi, fdtisd, fdtdsi, fdtdsd,    sifiti, sifitd, sifdti, sifdtd, sdfiti, sdfitd, sdfdti, sdfdtd,    sitifi, sitifd, sitdfi, sitdfd, sdtifi, sdtifd, sdtdfi, sdfdfd,    tifisi, tifisd, tifdsi, tifdsd, tdfisi, tdfisd, tdfdsi, tdfdsd,    tisifi, tisifd, tisdfi, tisdfd, tdsifi, tdsifd, tdsdfi, tdsdfd};\ntemplate<class A, class B> void sort(vector<pair<A, B>> &a, pcomparator type) {    typedef pair<A, B> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });};template<class U> void sort(vector<U> &a, pcomparator type) {    if (type == fisi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });};template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D> > &a, pcomparator type) {    typedef F2<A, B, C, D> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a > r.a; });};template<class U> void sort(vector<U> &a, tcomparator type) {    if (type == 0) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });}template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D>> &a, tcomparator type) {    typedef F2<A, B, C, D> U;    if (type == 0) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });}\n\nvoid sort(string &a) { sort(all(a)); }\ntemplate<class T> void sort(vector<T> &a) { sort(all(a)); }\n//P l, P rで f(P) の形で渡す\ntemplate<class U, class F> void sort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) < f(r); }); };\ntemplate<class T> void rsort(vector<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class U, class F> void rsort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) > f(r); }); };\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class A, class B> void sortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    sort(c);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B, class F> void sortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    sort(c, f);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B> void rsortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    rsort(c);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}template<class A, class B, class F> void rsortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    rsort(c, f);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C> void sortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    sort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void sortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    sort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    rsort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    rsort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class D> void sortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    sort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\ntemplate<class A, class B, class C, class D> void rsortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    rsort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\n//sortindex 元のvectorはソートしない\ntemplate<class T> vi sorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind);    return ind;}/*indexの分で型が変わるためpcomparatorが必要*/template<class T> vi sorti(vector<T> &a, pcomparator f) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind, f);    return ind;}template<class T, class F> vi sorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) < f(a[y]); });    return ind;}template<class T> vi rsorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    rsortp(b, ind);    return ind;}template<class T, class F> vi rsorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) > f(a[y]); });    return ind;}template<class A, class B, class F> vi sortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) < f(c[y]); });    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b, pcomparator f) {    vi ind = iota(0, sz(a));    auto c = a;    auto d = b;    sortt(c, d, ind, f);    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fisi); };template<class A, class B, class F> vi rsortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) > f(c[y]); });    return ind;}template<class A, class B> vi rsortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fdsd); };template<class A, class B, class C, class F> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) < f(d[y]); });    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, pcomparator f) {    vi ind = iota(0, sz(a));    auto d = vtof(a, b, c, ind);    sort(d, f);    rep(i, sz(a))ind[i] = d[i].d;    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] < c[y];            else return b[x] < b[y];        } else {            return a[x] < a[y];        }    });    return ind;}template<class A, class B, class C, class F> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) > f(d[y]); });    return ind;}template<class A, class B, class C> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] > c[y];            else return b[x] > b[y];        } else {            return a[x] > a[y];        }    });    return ind;}\ntemplate<class T> void sort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)sort(a[i]); }\ntemplate<class T> void rsort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)rsort(a[i]); }\n\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }template<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }template<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename W, typename T>void fill(W &xx, const T vall) {    xx = vall;}template<typename W, typename T>void fill(vector<W> &vecc, const T vall) {    for (auto &&vx     : vecc)fill(vx, vall);}\ntemplate<typename W,typename T>void fill(vector<W> &xx,const T v,ll len) {rep(i, len)xx[i]=v;}\ntemplate<typename W,typename T>void fill(vector<vector<W>> &xx,const T v,ll lh,ll lw) {rep(i, lh)rep(j,lw)xx[i][j]=v;}\ntemplate<class T,class U>void fill(vector<T> &a,U val,vi& ind) {fora(v,ind)a[v]=val;}\n\ntemplate<typename A, size_t N> A sum(A (&a)[N]) {    A res = 0;    rep(i, N)res += a[i];    return res;}template<typename A, size_t N, size_t O> A sum(A (&a)[N][O]) {    A res = 0;    rep(i, N)rep(j, O)res += a[i][j];    return res;}template<typename A, size_t N, size_t O, size_t P> A sum(A (&a)[N][O][P]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)res += a[i][j][k];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A sum(A (&a)[N][O][P][Q]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)res += a[i][j][k][l];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A sum(A (&a)[N][O][P][Q][R]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)res += a[i][j][k][l][m];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A sum(A (&a)[N][O][P][Q][R][S]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)res += a[i][j][k][l][m][n];    return res;}\n//@汎用便利関数 入力\nll in() {ll ret;cin >> ret;return ret;}\nstring sin() {string ret;cin >> ret;return ret;}\ntemplate<class T>  void in(T &head) { cin >> head; }template<class T, class... U>  void in(T &head, U &... tail) {cin >> head;in(tail...);}\n\n#define o_din(o1, o2, o3, o4, o5, o6, name, ...) name\n#define din1(a) ll a;cin>>a\n#define din2(a, b) ll a,b;cin>>a>> b\n#define din3(a, b, c) ll a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) ll a,b,c,d;cin>>a>>b>>c>>d\n#define din5(a, b, c, d, e) ll a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define din6(a, b, c, d, e, f) ll a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define din(...) o_din(__VA_ARGS__,din6,din5,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define o_dind(o1, o2, o3, o4, name, ...) name\n#define din1d(a) din1(a);a--\n#define din2d(a, b) din2(a,b);a--,b--\n#define din3d(a, b, c) din3(a,b,c);a--,b--,c--\n#define din4d(a, b, c, d) din4(a,b,c,d);a--,b--,c--,d--\n#define dind(...) o_dind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\ntemplate<class T> void out2(T &&head) { cout << head; }\ntemplate<class T, class... U> void out2(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);    cout << \"\" << endl;}\ntemplate<class T> void out(T &&head) {    cout << head  << endl;}\ntemplate<class T> void outv(vector<T> &a, ll W) {    rep(i, W) { cout << a[i] << \" \"; }    cout << \"\" << endl;}template<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf) {    rep(h, min(H, sz(a))) {        rep(w, min(W, sz(a[0]))) { if (a[h][w] == linf) cout << \"e\" << \" \"; else cout << a[h][w] << \" \"; }        cout << \"\" << endl;    }}\ntemplate<class T> void outl(vector<T> &a) { fora(v, a)cout << v << endl; }\ntemplate<class T> void na(vector<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i];}\n#define dna(a, n) vi a(n); rep(dnai,n) cin >> a[dnai];\ntemplate<class T> void nao(vector<T> &a, ll n) {    a.resize(n + 1);    a[0] = 0;    rep(i, n)cin >> a[i + 1];}\ntemplate<class T> void naod(vector<T> &a, ll n) {    a.resize(n + 1);    a[0] = 0;    rep(i, n)cin >> a[i + 1],a[i+1]--;}\ntemplate<class T> void nad(vector<T> &a, ll n) {    a.resize(n);    rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T, class U> void na2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i];}\n#define dna2(a, b, n) vi a(n),b(n);rep(dna2i, n)cin >> a[dna2i] >> b[dna2i];\ntemplate<class T, class U> void nao2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n + 1);    b.resize(n + 1);    a[0] = b[0] = 0;    rep(i, n)cin >> a[i + 1] >> b[i + 1];}\n#define dna2d(a, b, n) vi a(n),b(n);rep(dna2di, n){cin >> a[dna2di] >> b[dna2di];a[dna2di]--,b[dna2di]--;}\ntemplate<class T, class U> void na2d(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i], a[i]--, b[i]--;}\ntemplate<class T, class U, class W> void na3(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {    a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define dna3(a, b, c, n) vi a(n),b(n),c(n);   rep(dna3i, n)cin >> a[dna3i] >> b[dna3i] >> c[dna3i];\ntemplate<class T, class U, class W> void na3d(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {    a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i], a[i]--, b[i]--, c[i]--;}\n#define dna3d(a, b, c, n) vi a(n),b(n),c(n);  rep(dna3di, n){cin >> a[dna3di] >> b[dna3di] >> c[dna3di];a[dna3di]--,b[dna3di]--,c[dna3di]--;}\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n//デバッグ\n#define sp << \" \" <<\n\n#define debugName(VariableName) # VariableName\n\n#define deb1(x)  debugName(x)<<\" = \"<<x\n#define deb2(x, ...) deb1(x) <<\", \"<< deb1(__VA_ARGS__)\n#define deb3(x, ...) deb1(x) <<\", \"<< deb2(__VA_ARGS__)\n#define deb4(x, ...) deb1(x) <<\", \"<< deb3(__VA_ARGS__)\n#define deb5(x, ...) deb1(x) <<\", \"<< deb4(__VA_ARGS__)\n#define deb6(x, ...) deb1(x) <<\", \"<< deb5(__VA_ARGS__)\n#define deb7(x, ...) deb1(x) <<\", \"<< deb6(__VA_ARGS__)\n#define deb8(x, ...) deb1(x) <<\", \"<< deb7(__VA_ARGS__)\n#define deb9(x, ...) deb1(x) <<\", \"<< deb8(__VA_ARGS__)\n#define deb10(x, ...) deb1(x) <<\", \"<< deb9(__VA_ARGS__)\n\n#define o_ebug(o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, name, ...) name\n\n#ifdef _DEBUG\n#define deb(...)  cerr<< o_ebug(__VA_ARGS__,deb10,deb9,deb8,deb7,deb6,deb5,deb4,deb3,deb2,deb1)(__VA_ARGS__) <<endl\n#else\n#define deb(...) ;\n#endif\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\n//@formatter:off\n//よく使うクラス、構造体\nstruct unionfind {\n    vector<ll> par;\n    vector<ll> siz;\n    vector<ll> es;\n    ll n, trees;//連結グループの数(親の種類)\n    unionfind(ll n) : n(n), trees(n) {        par.resize(n);        siz.resize(n);        es.resize(n);        for (ll i = 0; i < n; i++) {            par[i] = i;            siz[i] = 1;        }    }\n    ll root(ll x) { if (par[x] == x) { return x; } else { return par[x] = root(par[x]); }}\n    void unite(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        es[x]++;\n        if (x == y) return;\n        if (siz[x] > siz[y]) swap(x, y);\n        trees--;\n        par[x] = y;\n        siz[y] += siz[x];\n        es[y] += es[x];\n    }\n    bool same(ll x, ll y) { return root(x) == root(y); }\n    ll size(ll x) { return siz[root(x)]; }\n    ll esize(ll x) { return es[root(x)]; }\n    vi sizes(){        vi cou(n);        vi ret;        ret.reserve(n);        rep(i, n){            cou[root (i)]++;        }        rep(i, n){            if(cou[i])ret.push_back(cou[i]);        }        return ret;    }\n    //つながりを無向グラフと見なし、xが閉路に含まれるか判定\n    bool close(ll x) { return esize(x) >= size(x); }\n    V<vi> sets() {        vi ind(n, -1);        ll i = 0;        vvi(res, trees);        rep(j, n) {            ll r = root(j);            if (ind[r] == -1)ind[r] = i++;            res[ind[r]].push_back(j);        }        rep(i, trees) {            ll r = root(res[i][0]);            if (res[i][0] == r)continue;            rep(j, 1, sz(res[i])) {                if (res[i][j] == r) {                    swap(res[i][0], res[i][j]);                    break;                }            }        }        return res;    }\n};//@formatter:off\n\n\nusing bll =__int128;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing u128 = __uint128_t;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {    std::ostream::sentry s(dest);    if (s) {        __uint128_t tmp = value < 0 ? -value : value;        char buffer[128];        char *d = std::end(buffer);        do {            --d;            *d = \"0123456789\"[tmp % 10];            tmp /= 10;        } while (tmp != 0);        if (value < 0) {            --d;            *d = '-';        }        ll len = std::end(buffer) - d;        if (dest.rdbuf()->sputn(d, len) != len) { dest.setstate(std::ios_base::badbit); }    }    return dest;}\n//__int128 toi128(string &s) {    __int128 ret = 0;    for (ll i = 0; i < s.length(); ++i)        if ('0' <= s[i] && s[i] <= '9')            ret = 10 * ret + s[i] - '0';    return ret;}\n\n\n//エラー\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");    exit(0);\n#endif\n    string a = \"a\";    rep(i, 30)a += a;    rep(i, 1 << 17)cout << a << endl;    cout << \"OLE 出力長制限超過\" << endl;    exit(0);}\nvoid re() {    assert(0 == 1);    exit(0);}\nvoid tle() { while (inf)cout << inf << endl; }\n\n//便利関数\n\n//テスト用\nchar ranc() { return (char) ('a' + rand() % 26); }\nll rand(ll min, ll max) {    assert(min <= max);    if (min >= 0 && max >= 0) { return rand() % (max + 1 - min) + min; } else if (max < 0) { return -rand(-max, -min); } else { if (rand() % 2) { return rand(0, max); } else { return -rand(0, -min); }}}\nvi ranv(ll n, ll min, ll max) {    vi v(n);    rep(i, n)v[i] = rand(min, max);    return v;}\nstr ransu(ll n) {    str s;    rep(i, n)s += (char) rand('A', 'Z');    return s;}\nstr ransl(ll n) {    str s;    rep(i, n)s += (char) rand('a', 'z');    return s;}\n//単調増加\nvi ranvinc(ll n, ll min, ll max) {    vi v(n);    bool bad = 1;    while (bad) {        bad = 0;        v.resize(n);        rep(i, n) {            if (i && min > max - v[i - 1]) {                bad = 1;                break;            }            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]); else v[i] = rand(min, max);        }    }    return v;}\n//便利 汎用\nvoid ranvlr(ll n, ll min, ll max, vi &l, vi &r) {    l.resize(n);    r.resize(n);    rep(i, n) {        l[i] = rand(min, max);        r[i] = l[i] + rand(0, max - l[i]);    }}\nvp run_length(vi &a) {    vp ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\nvector<pair<char, ll>> run_length(string &a) {    vector<pair<char, ll>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\ntemplate<class F> ll mgr(ll ok, ll ng, F f) {    if (ok < ng)        while (ng - ok > 1) {            ll mid = (ok + ng) / 2;            if (f(mid))ok = mid; else ng = mid;        }    else        while (ok - ng > 1) {            ll mid = (ok + ng) / 2;            if (f(mid))ok = mid; else ng = mid;        }    return ok;}\n//strを整数として比較\nstring smax(str &a, str b) {    if (sz(a) < sz(b)) { return b; } else if (sz(a) > sz(b)) { return a; } else { rep(i, sz(a)) { if (a[i] < b[i]) { return b; } else if (a[i] > b[i])return a; }}    return a;}\n//strを整数として比較\nstring smin(str &a, str b) {    if (sz(a) < sz(b)) { return a; } else if (sz(a) > sz(b)) { return b; } else { rep(i, sz(a)) { if (a[i] < b[i]) { return a; } else if (a[i] > b[i])return b; }}    return a;}\ntemplate<typename W, typename T> ll find(vector<W> &a, const T key) {    rep(i, sz(a))if (a[i] == key)return i;    return -1;}\ntemplate<typename W, typename T> P find(vector<vector<W >> &a, const T key) {    rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);    return mp(-1, -1);}\ntemplate<typename W, typename U> T find(vector<vector<vector<W >>> &a, const U key) {    rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);    return mt(-1, -1, -1);}\n\n\ntemplate<typename W, typename T> ll count2(W &a, const T k) { return a == k; }\ntemplate<typename W, typename T> ll count2(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\ntemplate<typename W, typename T> ll count(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\nll count(str &a, str k) {    ll ret = 0, len = k.length();    auto pos = a.find(k);    while (pos != string::npos)pos = a.find(k, pos + len), ++ret;    return ret;}\nvi count(str &a) {    vi cou(26);    char c = 'a';    if ('A' <= a[0] && a[0] <= 'Z')c = 'A';    rep(i, sz(a))++cou[a[i] - c];    return cou;}\n#define couif count_if\n//algorythm\n\n\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    return res;}\ntemplate<class T> void rev(vector<T> &a) { reverse(all(a)); }\ntemplate<class U> void rev(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[h][w];    a = b;}\nvoid  rev(string &a) { reverse(all(a)); }\nconstexpr ll p10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000ll, 100000000000ll, 1000000000000ll, 10000000000000ll, 100000000000000ll, 1000000000000000ll, 10000000000000000ll, 100000000000000000ll, 1000000000000000000ll};\n\nll get(ll a, ll keta) { return (a / (ll) pow(10, keta)) % 10; }\nll keta(ll v) { if (v < p10[9]) { if (v < p10[4]) { if (v < p10[2]) { if (v < p10[1]) return 1; else return 2; } else { if (v < p10[3]) return 3; else return 4; }} else { if (v < p10[7]) { if (v < p10[5]) return 5; else if (v < p10[6])return 6; else return 7; } else { if (v < p10[8])return 8; else return 9; }}} else { if (v < p10[13]) { if (v < p10[11]) { if (v < p10[10]) return 10; else return 11; } else { if (v < p10[12]) return 12; else return 13; }} else { if (v < p10[15]) { if (v < p10[14]) return 14; else if (v < p10[15])return 15; else return 16; } else { if (v < p10[17])return 17; else return 18; }}}}\nll dsum(ll v,ll sin=10) {    ll ret = 0;    for (; v; v /= sin)ret += v % sin;    return ret;}\n\nstruct sint {\n    ll v;\n    sint(ll v) : v(v) {}\n    operator ll() { return v; }\n    //下からi番目\n    ll operator[](ll i) { return (v / p10[i]) % 10; }\n    ll back(ll i) { return operator[](i); }\n    //上からi番目\n    ll top(ll i) {\n        ll len = keta(v);\n        return operator[](len - 1 - i);\n    }\n    //先頭からi番目にセット\n    ll settop(ll i, ll k) {\n        ll len = keta(v);\n        return set(len - 1 - i, k);\n    }\n    ll set(ll i, ll k) {\n        if (i < 0)return settop(abs(i) - 1, k);\n        return v += p10[i] * (k - (v / p10[i]) % 10);\n    }\n    ll add(ll i, ll k = 1) { return v += p10[i] * k; }\n    ll addtop(ll i, ll k = 1) { return v += p10[keta(v) - i - 1] * k; }\n    ll dec(ll i, ll k = 1) { return v -= p10[i] * k; }\n    ll dectop(ll i, ll k = 1) { return v -= p10[keta(v) - i - 1] * k; }\n#define op(t, o)template<class T> t operator o(T r){return v o r;}\n    op(ll, +=);    op(ll, -=);    op(ll, *=);    op(ll, /=);    op(ll, %=);    op(ll, +);    op(ll, -);    op(ll, *);    op(ll, /);    op(ll, %);    op(bool, ==);    op(bool, !=);    op(bool, <);    op(bool, <=);    op(bool, >);    op(bool, >=);\n#undef op\n    template<class T>  ll operator<<=(T r) { return v *= p10[r]; }\n    template<class T>  ll operator<<(T r) { return v * p10[r]; }\n    template<class T>  ll operator>>=(T r) { return v /= p10[r]; }\n    template<class T>  ll operator>>(T r) { return v / p10[r]; }\n};\nll mask10(ll v) { return p10[v] - 1; }\n//変換系\ntemplate<class T> auto keys(T a) {    vector<decltype((a.begin())->fi)> res;    for (auto &&k :a)res.push_back(k.fi);    return res;}\ntemplate<class T> auto values(T a) {    vector<decltype((a.begin())->se)> res;    for (auto &&k :a)res.push_back(k.se);    return res;}\ntemplate<class T, class U>  bool chma(T &a, const U &b) {    if (a < b) {        a = b;        return true;    }    return false;}\ntemplate<class U>  bool chma(const U &b) { return chma(ma, b); }\ntemplate<class T, class U>  bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        return true;    }    return false;}\ntemplate<class U>  bool chmi(const U &b) { return chmi(mi, b); }\ntemplate<class T>  T min(T a, signed b) { return a < b ? a : b; }\ntemplate<class T>  T max(T a, signed b) { return a < b ? b : a; }\ntemplate<class T>  T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T>  T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T>  T min(vector<T>& a) { return *min_element(all(a)); }\ntemplate<class T>  T mini(vector<T>& a) { return min_element(all(a)) - a.begin(); }\ntemplate<class T>  T min(vector<T>& a, ll n) { return *min_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T>  T min(vector<T>& a, ll s, ll n) { return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T>  T max(vector<T>& a) { return *max_element(all(a)); }\ntemplate<class T,class U>  T max(vector<T>& a,vector<U>& b) { return max(*max_element(all(a)),*max_element(all(b))); }\ntemplate<class T>  T maxi(vector<T>& a) { return max_element(all(a)) - a.begin(); }\ntemplate<class T>  T max(vector<T>& a, ll n) { return *max_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T>  T max(vector<T>& a, ll s, ll n) { return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<typename A, size_t N>  A max(A (&a)[N]) {    A res = a[0];    rep(i, N)res = max(res, a[i]);    return res;}template<typename A, size_t N, size_t O>  A max(A (&a)[N][O]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P>  A max(A (&a)[N][O][P]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q>  A max(A (&a)[N][O][P][Q], const T &v) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R>  A max(A (&a)[N][O][P][Q][R]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S>  A max(A (&a)[N][O][P][Q][R][S]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}\ntemplate<typename A, size_t N>  A min(A (&a)[N]) {    A res = a[0];    rep(i, N)res = min(res, a[i]);    return res;}template<typename A, size_t N, size_t O>  A min(A (&a)[N][O]) {    A res = min(a[0]);    rep(i, N)res = min(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P>  A min(A (&a)[N][O][P]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q>  A min(A (&a)[N][O][P][Q], const T &v) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R>  A min(A (&a)[N][O][P][Q][R]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S>  A min(A (&a)[N][O][P][Q][R][S]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}\ntemplate<class T> T sum(vector<T> &v, ll s = 0, ll t = inf) {    T ret = 0;    rep(i, s, min(sz(v), t))ret += v[i];    return ret;}template<class T> T sum(vector<vector<T> > &v) {    T ret = 0;    rep(i, sz(v))ret += sum(v[i]);    return ret;}template<class T> T sum(vector<vector<vector<T> > > &v) {    T ret = 0;    rep(i, sz(v))ret += sum(v[i]);    return ret;}template<class T> T sum(vector<vector<vector<vector<T> > > > &v) {    T ret = 0;    rep(i, sz(v))ret += sum(v[i]);    return ret;}template<class T> T sum(vector<vector<vector<vector<vector<T> > > > > &v) {    T ret = 0;    rep(i, sz(v))ret += sum(v[i]);    return ret;}template<class T> auto sum(priority_queue<T, vector<T>, greater<T> > &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}template<class T> auto sum(priority_queue<T> &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}\n//template<class T, class U, class... W>  auto sumn(vector<T> &v, U head, W... tail) {    auto ret = sum(v[0], tail...);    rep(i, 1, min(sz(v), head))ret += sum(v[i], tail...);    return ret;}\nvoid clear(PQ &q) { q = PQ(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(ll size) {    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));    return body + size;}\ntemplate<class T> T *negarr2(ll h, ll w) {    double **dummy1 = new double *[2 * h + 1];    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];    dummy1[0] = dummy2 + w;    for (ll i = 1; i <= 2 * h + 1; ++i) { dummy1[i] = dummy1[i - 1] + 2 * w + 1; }    double **a = dummy1 + h;    return a;}\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\n//kと同じものの数\ntemplate<class T, class U> vi imo(vector<T> &a, U k) {vector<T> ret = a;rep(i, sz(ret))ret[i] = a[i] == k;rep(i, sz(ret) - 1)ret[i + 1] += ret[i];return ret;}\ntemplate<class T> vector<T> imox(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] ^= ret[i];    return ret;}\n//漸化的に最小を持つ\ntemplate<class T> vector<T> imi(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chmi(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> struct ruiC {    const vector<T> rui;    ruiC(vector<T> &ru) : rui(ru) {}    T operator()(ll l, ll r) {        if (l > r) {            cerr<<\"ruic \";deb(l, r);assert(0);        }        return rui[r] - rui[l];    }    T operator[](ll i) { return rui[i]; }    T back() { return rui.back(); }    ll size() { return rui.size(); }};\ntemplate<class T> struct rruic {    const T *rrui;    rruic(T *ru) : rrui(ru) {}     T operator()(ll l, ll r) {        assert(l >= r);        return rrui[r] - rrui[l];    }     T operator[](ll i) { return rrui[i]; }};\ntemplate<class T> vector<T> ruiv(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    return ret;}\ntemplate<class T> ruiC<T> ruic(vector<T> &a) {    vector<T> ret = ruiv(a);    return ruiC<T>(ret);}\nvector<ll> ruiv(string &a) {    if (sz(a) == 0)return vi(1);    ll dec = ('0' <= a[0] && a[0] <= '9') ? '0' : 0;    vector<ll> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i] - dec;    return ret;}\nruiC<ll> ruic(string &a) {    vector<ll> ret = ruiv(a);    return ruiC<ll>(ret);}\n//kと同じものの数\ntemplate<class T, class U> vi ruiv(T &a, U k) {    vi ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + (a[i] == k);    return ret;}\ntemplate<class T, class U> ruiC<ll> ruic(T &a, U k) {    vi ret = ruiv(a, k);    return ruiC<ll>(ret);}\n//xor\ntemplate<class T> vector<T> ruix(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];    return ret;}\ntemplate<class T> vector<T> ruim(vector<T> &a) {    vector<T> res(a.size() + 1, 1);    rep(i, a.size())res[i + 1] = res[i] * a[i];    return res;}\n//漸化的に最小を1indexで持つ\ntemplate<class T> vector<T> ruimi(vector<T> &a) {    ll n = sz(a);    vector<T> ret(n + 1);    rep(i, 1, n) {        ret[i] = a[i - 1];        chmi(ret[i + 1], ret[i]);    }    return ret;}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> rruic<T> rrui(vector<T> &a) {    ll len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    rer(i, len - 1)res[i - 1] = res[i] + a[i];    return rruic<T>(res);}\n//掛け算\ntemplate<class T> T *rruim(vector<T> &a) {    ll len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    res[len - 1] = 1;    rer(i, len - 1)res[i - 1] = res[i] * a[i];    return res;}\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void inc(vector<T> &a, U v = 1) { for (auto &u:a)inc(u, v); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class U> void dec(string &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T> void dec(vector<T> &a) { for (auto &u :a)dec(u, 1); }\nbool ins(ll h, ll w, ll H, ll W) { return h >= 0 && w >= 0 && h < H && w < W; }\nbool ins(ll l, ll v, ll r) { return l <= v && v < r; }\ntemplate<class T> bool ins(vector<T> &a, ll i, ll j = 0) { return ins(0, i, sz(a)) && ins(0, j, sz(a)); }\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {    vector<T> ret = a;    fora(v, ret)v = u(v);    return ret;}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\ntemplate<class F> ll goldd_l(ll left, ll right, F calc) {    double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    ll minScore = MAX(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (minScore > score) {            minScore = score;            resIndex = i;        }    }    return resIndex;}\ntemplate<class F> ll goldt_l(ll left, ll right, F calc) {        double GRATIO = 1.6180339887498948482045868343656;        ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));        ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));        ll fl = calc(lm);        ll fr = calc(rm);        while (right - left > 10) {            if (fl > fr) {                right = rm;                rm = lm;                fr = fl;                lm = left + (ll) ((right - left) / (GRATIO + 1.0));                fl = calc(lm);            } else {                left = lm;                lm = rm;                fl = fr;                rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));                fr = calc(rm);            }        }    if (left > right) {        ll l = left;        left = right;        right = l;    }    ll maxScore = MIN(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (maxScore < score) {            maxScore = score;            resIndex = i;        }    }    return resIndex;}\n/*loopは200にすればおそらく大丈夫 余裕なら300に*/\ntemplate<class F> dou goldd_d(dou left, dou right, F calc, ll loop = 140) {    dou GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    /*200にすればおそらく大丈夫*/    /*余裕なら300に*/    ll k = 141;    loop++;    while (--loop) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\ntemplate<class F> dou goldt_d(dou left, dou right, F calc, ll loop = 140) {    double GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    loop++;    while (--loop) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\n//l ~ rを複数の区間に分割し、極致を与えるiを返す time-20 msまで探索\ntemplate<class F> ll goldd_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll mini = 0, minv = MAX(ll);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldd_l(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> ll goldt_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll maxi = 0, maxv = MIN(ll);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldt_l(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class F> dou goldd_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を持つ*/    auto lim = milliseconds(time - 20);    dou mini = 0, minv = MAX(dou);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldd_d(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> dou goldt_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を残している*/    auto lim = milliseconds(time - 20);    dou maxi = 0, maxv = MIN(dou);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldt_d(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class T> T min(vector<vector<T >> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, *min_element(all(a[i])));    return res;}\ntemplate<class T> T max(vector<vector<T >> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, *max_element(all(a[i])));    return res;}\nconstexpr bool bget(ll m, ll keta) { return (m >> keta) & 1; }\nll bget(ll m, ll keta, ll sinsuu) {    m /= (ll) pow(sinsuu, keta);    return m % sinsuu;}\nll bit(ll n) { return (1LL << (n)); }\nll bit(ll n, ll sinsuu) { return (ll) pow(sinsuu, n); }\nll mask(ll n) { return (1ll << n) - 1; }\n#define bcou __builtin_popcountll\n//最下位ビット\nll lbit(ll n) { return n & -n; }\n//最上位ビット\nll hbit(ll n) {    n |= (n >> 1);    n |= (n >> 2);    n |= (n >> 4);    n |= (n >> 8);    n |= (n >> 16);    n |= (n >> 32);    return n - (n >> 1);}\nll hbitk(ll n) {    ll k = 0;    rer(i, 5) {        ll a = k + (1ll << i);        ll b = 1ll << a;        if (b <= n)k += 1ll << i;    }    return k;}\n//初期化は0を渡す\nll nextComb(ll &mask, ll n, ll r) {    if (!mask)return mask = (1LL << r) - 1;    ll x = mask & -mask; /*最下位の1*/    ll y = mask + x; /*連続した下の1を繰り上がらせる*/    ll res = ((mask & ~y) / x >> 1) | y;    if (bget(res, n))return mask = 0; else return mask = res;}\n//n桁以下でビットがr個立っているもののvectorを返す\nvi bitCombList(ll n, ll r) {    vi res;    ll m = 0;    while (nextComb(m, n, r)) { res.push_back(m); }    return res;}\nchar itoal(ll i) { return 'a' + i; }\nchar itoaL(ll i) { return 'A' + i; }\nll altoi(char c) {    if ('A' <= c && c <= 'Z')return c - 'A';    return c - 'a';}\nll ctoi(char c) { return c - '0'; }\nchar itoc(ll i) { return i + '0'; }\nll vtoi(vi &v) {    ll res = 0;    if (sz(v) > 18) {        debugline(\"vtoi\");        deb(sz(v));        ole();    }    rep(i, sz(v)) {        res *= 10;        res += v[i];    }    return res;}\nvi itov(ll i) {    vi res;    while (i) {        res.push_back(i % 10);        i /= 10;    }    rev(res);    return res;}\nvi stov(string &a) {    ll n = sz(a);    vi ret(n);    rep(i, n) { ret[i] = a[i] - '0'; }    return ret;}\n//基準を満たさないものは0になる\nvi stov(string &a, char one) {    ll n = sz(a);    vi ret(n);    rep(i, n)ret[i] = a[i] == one;    return ret;}\nvector<vector<ll>> ctoi(vector<vector<char>> s, char c) {    ll n = sz(s), m = sz(s[0]);    vector<vector<ll>> res(n, vector<ll>(m));    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;    return res;}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n//[i] := i番として圧縮されたものを返す\nvi compress(vi &a) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, umap<ll, ll> &map) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) {        ll v = a[i];        a[i] = lower_bound(all(b), a[i]) - b.begin();        map[v] = a[i];    }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r, vi &s) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    fora(v, s)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    for (ll i = 0; i < sz(s); ++i) r[i] = lower_bound(all(b), s[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(V<vi> &a) {    vi b;    fora(vv, a)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vv, a)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vector<vi >> &a) {    vi b;    fora(vvv, a)fora(vv, vvv)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vvv, a)fora(vv, vvv)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvoid compress(ll a[], ll len) {    vi b;    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define lowerBound(a, v) (*lower_bound(all(a),v))\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define upperBound(a, v) (*upper_bound(all(a),v))\ntemplate<class T> void fin(T s) { cout << s << endl, exit(0); }\n\n//便利 数学 math\nll mod(ll a, ll m) { return (a % m + m) % m; }\nll pow(ll a) { return a * a; };\nll fact(ll v) { return v <= 1 ? 1 : v * fact(v - 1); }\n\nll comi(ll n, ll r) {    assert(n < 100);    static vvi(pas, 100, 100);    if (pas[0][0])return pas[n][r];    pas[0][0] = 1;    rep(i, 1, 100) {        pas[i][0] = 1;        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];    }    return pas[n][r];}\ndouble comd(ll n, ll r) {    assert(n < 2020);    static vvd(comb, 2020, 2020);    if (comb[0][0] == 0) {        comb[0][0] = 1;        rep(i, 2000) {            comb[i + 1][0] = 1;            rep(j, 1, i + 2) {                comb[i + 1][j] = comb[i][j] + comb[i][j - 1];            }        }    }    return comb[n][r];}\nll gcd(ll a, ll b) {while (b) a %= b, swap(a, b);return abs(a);}\nll gcd(vi b) {ll res = b[0];rep(i, 1, sz(b))res = gcd(b[i], res);return res;}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll lcm(vi a) {ll res = a[0];rep(i, 1, sz(a))res = lcm(a[i], res);return res;}\nll ceil(ll a, ll b) {if (b == 0) {debugline(\"ceil\");deb(a, b);ole();return -1;} else if (a < 0) { return 0; } else { return (a + b - 1) / b; }}\nll lower_remi__bx_a(ll kei, ll rem, ll x) {if (rem >= x) return 0;return (x - rem + kei - 1) / kei;}\nll lower_remv__bx_a(ll kei, ll rem, ll x) {if (rem >= x) return rem;return (x - rem + kei - 1) / kei * kei + rem;}\nll upper_remi__bx_a(ll kei, ll rem, ll x) {if (rem > x) return 0;return (x - rem + kei) / kei;}\nll upper_remv__bx_a(ll kei, ll rem, ll x) {if (rem > x) return rem;return (x - rem + kei) / kei * kei + rem;}\n//v * v >= aとなる最小のvを返す\nll sqrt(ll a) {if (a < 0) {debugline(\"sqrt\");deb(a);ole();}ll res = (ll) std::sqrt(a);while (res * res < a)++res;return res;}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return ((1 + t) * t) >> 1; }\nll sig(ll s, ll t) { return ((s + t) * (t - s + 1)) >> 1; }\n\n\n//幾何 Pをcomplexとして扱う\ntemplate<class T, class U> bool eq(T a, U b) { return fabs(a - b) < eps; }\ndou atan2(pd a) { return atan2(a.se, a.fi); }\ndou angle(pd f, pd t) { return atan2(t.se - f.se, t.fi - f.fi); }\ndou distance(pd a, pd b) { return hypot(a.fi - b.fi, a.se - b.se); }\n//bを中心とするabcのtheta aからcにかけて時計回り\ndou angle(pd a, pd b, pd c) {    dou ax = a.fi - b.fi;    dou ay = a.se - b.se;    dou cx = c.fi - b.fi;    dou cy = c.se - b.se;    double ret = atan2(cy, cx) - atan2(ay, ax);    if (ret < 0) ret += 2 * PI;    return ret;}\n\ndou dot(pd a, pd b) { return a.fi * b.fi + a.se + b.se; }\ndou cro(pd a, pd b) { return a.fi * b.se - a.se + b.fi; }\n\n//機能拡張\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) { a.push(v); }template<class T, class U> void operator+=(deque<T> &a, U v) { a.push_back(v); }template<class T> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, vector<T> &v) {    fora(d, v)a.push(d);    return a;}template<class T, class U> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {    a.push(v);    return a;}template<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {    a.push(v);    return a;}template<class T> set<T> &operator+=(set<T> &a, vector<T> v) {    fora(d, v)a.insert(d);    return a;}template<class T, class U> auto operator+=(set<T> &a, U v) { return    a.insert(v);}template<class T, class U> auto operator-=(set<T> &a, U v) { return    a.erase(v);}template<class T, class U> auto operator+=(mset<T> &a, U v) { return a.insert(v); }template<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {    a.insert(v);    return a;}template<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {    a.push_back(v);    return a;}template<class T, class U> vector<T> operator+(const vector<T> &a, U v) {    vector<T> ret = a;    ret += v;    return ret;}template<class T, class U> vector<T> operator+(U v, const vector<T> &a) {    vector<T> ret = a;    ret.insert(ret.begin(), v);    return ret;}template<class T> vector<T> operator+(vector<T> a, vector<T> b) {    vector<T> ret;    ret = a;    fora(v, b)ret += v;    return ret;}template<class T> vector<T> &operator+=(vector<T> &a, vector<T> &b) {    fora(v, b)a += v;    return a;}template<class T> vector<T> &operator-=(vector<T> &a, vector<T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-=\");        deb(a);        deb(b);        exit(0);    }    rep(i, sz(a))a[i] -= b[i];    return a;}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector<T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-\");        deb(a);        deb(b);        ole();    }    vector<T> res(sz(a));    rep(i, sz(a))res[i] = a[i] - b[i];    return res;}\ntemplate<class T, class U> vector<T> operator*(vector<T> &a, U b) {    vector<T> ret;    fora(v, a)ret += v * b;    return ret;}\ntemplate<class T, class U> vector<T> operator/(vector<T> &a, U b) {    vector<T> ret;    fora(v, a)ret += v / b;    return ret;}\ntemplate<class T, class U> vector<T> operator*=(vector<T> &a, U b) {    fora(v, a)v *= b;    return a;}\ntemplate<class T, class U> vector<T> operator/=(vector<T> &a, U b) {    fora(v, a)v /= b;    return a;}\ntemplate<typename T> void erase(vector<T> &v, unsigned ll i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned ll s, unsigned ll e) { v.erase(v.begin() + s, v.begin() + e); }\ntemplate<class T, class U> void erase(map<T, U> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<class T> void erase(set<T> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<typename T> void erasen(vector<T> &v, unsigned ll s, unsigned ll n) { v.erase(v.begin() + s, v.begin() + s + n); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, vector<T> list) { for (auto &&va:list)v.insert(v.begin() + i++, va); }\ntemplate<typename T> void insert(set<T> &v, vector<T> list) { for (auto &&va :list)v.insert(va); }\nvector<string> split(const string a, const char deli) {    string b = a + deli;    ll l = 0, r = 0, n = b.size();    vector<string> res;    rep(i, n) {        if (b[i] == deli) {            r = i;            if (l < r)res.push_back(b.substr(l, r - l));            l = i + 1;        }    }    return res;}\nvector<string> split(const string a, const string deli) {    vector<string> res;    ll kn = sz(deli);    std::string::size_type Pos(a.find(deli));    ll l = 0;    while (Pos != std::string::npos) {        if (Pos - l)res.push_back(a.substr(l, Pos - l));        l = Pos + kn;        Pos = a.find(deli, Pos + kn);    }    if (sz(a) - l)res.push_back(a.substr(l, sz(a) - l));    return res;}\nvoid yn(bool a) { if (a)cout << \"yes\" << endl; else cout << \"no\" << endl; }\nvoid Yn(bool a) { if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl; }\nvoid YN(bool a) { if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl; }\nvoid fyn(bool a) {    if (a)cout << \"yes\" << endl; else cout << \"no\" << endl;    exit(0);}\nvoid fYn(bool a) {    if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl;    exit(0);}\nvoid fYN(bool a) {    if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl;    exit(0);}\nvoid Possible(bool a) {    if (a)cout << \"Possible\" << endl; else cout << \"Impossible\" << endl;    exit(0);}\nvoid POSSIBLE(bool a) {    if (a)cout << \"POSSIBLE\" << endl; else cout << \"IMPOSSIBLE\" << endl;    exit(0);}\n//@formatter:off\ntemplate<typename T> T minv(T a, T m);\ntemplate<typename T> T minv(T a);\n\ntemplate<typename T>\nclass Modular {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;    constexpr Modular() : value() {}    template<typename U>    Modular(const U &x) {        value = normalize(x);    }    template<typename U>    static Type normalize(const U &x) {        Type v;        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);        else v = static_cast<Type>(x % mod());        if (v < 0) v += mod();        return v;    }    const Type &operator()() const { return value; }    template<typename U>explicit operator U() const { return static_cast<U>(value); }    constexpr static Type mod() { return T::value; }    Modular &operator+=(const Modular &other) {        if ((value += other.value) >= mod()) value -= mod();        return *this;    }    Modular &operator-=(const Modular &other) {        if ((value -= other.value) < 0) value += mod();        return *this;    }    template<typename U> Modular &operator+=(const U &other) { return *this += Modular(other); }    template<typename U> Modular &operator-=(const U &other) { return *this -= Modular(other); }    Modular &operator++() { return *this += 1; }    Modular &operator--() { return *this -= 1; }    Modular operator++(signed) {        Modular result(*this);        *this += 1;        return result;    }    Modular operator--(signed) {        Modular result(*this);        *this -= 1;        return result;    }    Modular operator-() const { return Modular(-value); }\n    template<typename U = T>typename enable_if<is_same<typename Modular<U>::Type, signed>::value, Modular>::type &operator*=(const Modular &rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;asm(\"divl %4; \\n\\t\": \"=a\" (d), \"=d\" (m): \"d\" (xh), \"a\" (xl), \"r\" (mod()));value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template<typename U = T>    typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &operator*=(const Modular &rhs) {        int64_t q = static_cast<int64_t>(static_cast<double>(value) * rhs.value / mod());        value = normalize(value * rhs.value - q * mod());        return *this;    }    template<typename U = T>    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {        value = normalize(value * rhs.value);        return *this;    }    Modular &operator/=(const Modular &other) { return *this *= Modular(minv(other.value)); }    template<typename U> friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);    template<typename U> friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);    template<typename U> friend std::istream &operator>>(std::istream &stream, Modular<U> &number);    operator int() { return value; }private:    Type value;\n};\ntemplate<typename T> bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }template<typename T, typename U> bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }template<typename T, typename U> bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }template<typename T> bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }template<typename T, typename U> bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }template<typename T, typename U> bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }template<typename T> bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }template<typename T> Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }template<typename T, typename U> Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }template<typename T, typename U> Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }template<typename T> Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }template<typename T, typename U> Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }template<typename T, typename U> Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }template<typename T> Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }template<typename T, typename U> Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }template<typename T, typename U> Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }template<typename T> Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }template<typename T, typename U> Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }template<typename T, typename U> Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\nconstexpr signed MOD =\n//        998244353;\n1e9 + 7;//MOD\nusing mint = Modular<std::integral_constant<decay<decltype(MOD)>::type, MOD>>;\nconstexpr int mint_len = 1400001;\nvi fac, finv, inv;\nvi p2;\nmint com(int n, int r) {    if (r < 0 || r > n) return 0;    return mint(finv[r] * fac[n] % MOD * finv[n - r]);}\nmint pom(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;    return mint(fac[n] * finv[n - 1]);}\nmint npr(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;    return mint(fac[n] * finv[n - r]);}\nint nprin(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;    return fac[n] * finv[n - r] % MOD;}\nint icom(int n, int r) {    const int NUM_ = 1400001;    static ll fac[NUM_ + 1], finv[NUM_ + 1], inv[NUM_ + 1];    if (fac[0] == 0) {        inv[1] = fac[0] = finv[0] = 1;        for (int i = 2; i <= NUM_; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;        for (int i = 1; i <= NUM_; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;    }    if (r < 0 || r > n) return 0;    return ((finv[r] * fac[n] % MOD) * finv[n - r]) % MOD;}\n#define ncr com\n#define ncri icom\n//n個の場所にr個の物を置く\nmint nhr(int n, int r) { return com(n + r - 1, r); }\nmint hom(int n, int r) { return com(n + r - 1, r); }\nint nhri(int n, int r) { return icom(n + r - 1, r); }\ntemplate<typename T> T minv(T a, T m) {    T u = 0, v = 1;    while (a != 0) {        T t = m / a;        m -= t * a;        swap(a, m);        u -= t * v;        swap(u, v);    }    assert(m == 1);    return u;}\ntemplate<typename T> T minv(T a) {    if (a < mint_len)return inv[a];    T u = 0, v = 1;    T m = MOD;    while (a != 0) {        T t = m / a;        m -= t * a;        swap(a, m);        u -= t * v;        swap(u, v);    }    assert(m == 1);    return u;}\ntemplate<typename T, typename U> Modular<T> mpow(const Modular<T> &a, const U &b) {    assert(b >= 0);    int x = a(), res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= MOD;        (x *= x) %= MOD;        p >>= 1;    }    return res;}\ntemplate<typename T, typename U, typename V> mint mpow(const T a, const U b, const V m = MOD) {    assert(b >= 0);    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= m;        (x *= x) %= m;        p >>= 1;    }    return res;}\ntemplate<typename T, typename U> mint mpow(const T a, const U b) {    assert(b >= 0);    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= MOD;        (x *= x) %= MOD;        p >>= 1;    }    return res;}\ntemplate<typename T, typename U, typename V> int mpowi(const T &a, const U &b, const V &m = MOD) {    assert(b >= 0);    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= m;        (x *= x) %= m;        p >>= 1;    }    return res;}\ntemplate<typename T> string to_string(const Modular<T> &number) {    return to_string(number());}\nstring yuri(const mint &a) {    stringstream st;    rep(i, 300) {rep(j, 300) {if ((mint) i / j == a) {st << i << \" / \" << j;return st.str();}}}    rep(i, 1000) {rep(j, 1000) {if ((mint) i / j == a) {st << i << \" / \" << j;return st.str();}}}    return st.str();}\ntemplate<typename T> std::ostream &operator<<(std::ostream &stream, const Modular<T> &number) {stream << number();\n#ifdef _DEBUG\n//    stream << \" -> \" << yuri(number);\n#endif\n    return stream;\n}\n//@formatter:off\ntemplate<typename T> std::istream &operator>>(std::istream &stream, Modular<T> &number) {    typename common_type<typename Modular<T>::Type, int64_t>::type x;    stream >> x;    number.value = Modular<T>::normalize(x);    return stream;}\nusing PM = pair<mint, mint>;\nusing vm = vector<mint>;\nusing mapm = map<int, mint>;\nusing umapm = umap<int, mint>;\n#define vvm(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(mint,__VA_ARGS__)\n#define vnm(name, ...) auto name = make_v<mint>(__VA_ARGS__)\n\nstruct setmod{\n    setmod() {\n//    p2.resize(mint_len);p2[0] = 1; for (int i = 1; i < mint_len; ++i) p2[i] = p2[i - 1] * 2 % MOD;\n        fac.resize(mint_len);    finv.resize(mint_len);    inv.resize(mint_len);    inv[1] = fac[0] = finv[0] = 1;    for (int i = 2; i < mint_len; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;    for (int i = 1; i < mint_len; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}setmodv;\n//@formatter:on\n//nhr n個の場所にr個の物を分ける\n\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} initonv;//@formatter:on\n\n//gra mll pr\n//上下左右\nconst string udlr = \"udlr\";\nstring UDLR = \"UDLR\";//x4と連動 UDLR.find('U') := x4[0]\n//右、上が正\nconstexpr ll y4[] = {1, -1, 0, 0};\nconstexpr ll x4[] = {0, 0, -1, 1};\nconstexpr ll y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n\nll n, m, k, d, H, W, x, y, z, q;\nll cou;\nvi t, a, b, c;\n//vvi (s, 0, 0);\nvvc (ba, 0, 0);\nvp p;\nstr s;\nstruct pbds_sum {\n    //@formatter:off\n    template<typename T = int> class BIT {\n    public:\n        int n;        vector<T> dat;        BIT(int n) : n(n) { dat.assign(n, 0); }        T sum(int k) {            if (k >= n) k = n - 1;            T ret = 0;            for (int x = k - 1; x >= 0; x = (x & (x + 1)) - 1) { ret += dat[x]; }            return ret;        }        T sum(int l, int r) { return sum(r) - sum(l); }        T get(int l, int r) { return sum(r) - sum(l); }        T get(int k) { return sum(k); }        T operator[](int k) {            assert(0 <= k && k < n);            return sum(k + 1) - sum(k);        }        T operator()(int k) { return sum(k); }        T operator()(int l, int r) { return sum(l, r); }        void add(int k, T val = 1) { for (int x = k; x < n; x |= x + 1)dat[x] += val; }        void update(int k, T val = 0) { add(k, -operator[](k) + val); }        void del(int k) { update(k, 0); }        void clear() { fill(dat, 0); }        void debu() {\n#ifdef _DEBUG\n            vi res;            rep(i, min(10ll, n)) { res.push_back(operator[](i)); }            deb(res);\n#endif\n        }\n        int lower_bound(int w) {            if (w <= 0) return -1;            int x = 0;            int k = 1;            while ((k << 1) <= n) k <<= 1;            for (; k > 0; k >>= 1) {                if (x + k <= n && dat[x + k - 1] < w) {                    w -= dat[x + k - 1];                    x += k;                }            }            return x;        }\n    };\n    BIT<int> bco, bsu;\n    umapi v_i;\n    vi i_v;\n    int count = 0;\n    //クエリの順番が分かってる場合の高速化はとりあえずしない(十分高速なため)\n    //クエリの順番が入れ替わってもいいようにする\n    pbds_sum(vi &a) : bco(sz(a) + 3), bsu(sz(a) + 3) {        vi b = a;        b.push_back(linf + 100);        i_v = compress(b);        rep(i, sz(a)) { v_i[a[i]] = b[i]; }    }\n    pbds_sum(vi &a, vi &b) : bco(sz(a) + sz(b) + 3), bsu(sz(a) + sz(b) + 3) {        vi c = a;        vi d = b;        c.push_back(linf + 100);        d.push_back(linf + 100);        i_v = compress(c, d);        rep(i, sz(a)) {            v_i[a[i]] = c[i];            v_i[b[i]] = d[i];        }    }\n    pbds_sum(vi &a, vi &b, vi &c) : bco(sz(a) + sz(b) + sz(c) + 3), bsu(sz(a) + sz(b) + sz(c) + 3) {        vi d = a;        vi e = b;        vi f = c;        d.push_back(linf + 100);        e.push_back(linf + 100);        f.push_back(linf + 100);        i_v = compress(d, e, f);        rep(i, sz(a)) {            v_i[a[i]] = d[i];            v_i[b[i]] = e[i];            v_i[c[i]] = f[i];        }    }\n    void add(int v, int c = 1) {count += c;        int ind = v_i[v];        bco.add(ind, c);        bsu.add(ind, v * c);    }\n    void operator+=(int v){int c=1;        count += c;        int ind = v_i[v];        bco.add(ind, c);        bsu.add(ind, v * c);    }\n    //開区間\n    int sum() {return bsu.sum(inf);    }\n    int sum(int rv) {        int i = (std::lower_bound(all(i_v), rv) - i_v.begin());        return bsu.sum(i);    }\n    //半開区間 l rは存在しない値でもいい\n    int sum(int l, int r) { return sum(r) - sum(l); }\n    //クエリ候補全ての中でのi\n    int sum_it(int li, int ri) {return bsu.sum(ri) - bsu.sum(li);}\n    //[l番目からr)番目の合計(種類数ではなく重複込みの番号)\n    //r個の合計\n    /*@formatter:on*/\n    int sum_order(int r) {\n        int rti = bco.lower_bound(r + 1);\n        int res = bsu.sum(rti);\n        if (rti != bco.n) {\n            int l = bco.sum(rti);\n            res += (r - l) * i_v[rti];\n        }\n        return res;\n    }\n    //右からr個の合計\n    /*@formatter:on*/\n    int sum_order_r(int r) {\n        int a = bsu.sum(0, inf);\n        int b = sum_order(count - r);\n        return a - b;\n    }\n    /*@formatter:off*/\n    int sum_order(int l,int r){return sum_order(r)-sum_order(l);}\n    int cou(int rv) {int i = (std::lower_bound(all(i_v), rv) - i_v.begin());return bco.sum(i);}\n    //半開区間 l rは存在しない値でもいい\n    int cou(int l, int r) { return cou(r) - cou(l); }\n    int cou_it(int ri) {        return bco.sum(ri);    }\n    int cou_it(int li, int ri) {        return bco.sum(ri) - bco.sum(li);    }\n    //k番目の要素を返す\n    int find_by_order(int k) {        int i = bco.lower_bound(k + 1);        if (i >= sz(i_v)) {            cerr << \"find_by_order(\" << k << \") k >=\" << sz(i_v) << endl;            exit(0);        }        return i_v[i];    }\n    //vは何番目に入るか\n    int order_of_key(int v) {        v = *std::lower_bound(all(i_v), v);        int i = v_i[v];        return bco.sum(i);    }\n    //中央値を返す (左寄り)\n    int mid() { return find_by_order((count - 1) >> 1); }\n    int mid(int lv, int rv) {        int lcou = cou(lv);        int rcou = cou(rv);        int wantk = lcou + ((rcou - lcou - 1) >> 1);        return find_by_order(wantk);    }\n    int mid_it(int li, int ri) {        int lcou = bco.sum(li );        int rcou = bco.sum(ri );        int wantk = lcou + ((rcou - lcou - 1) >> 1);        return find_by_order(wantk);    }\n    int mid_it(int ri) {        return mid_it(0, ri);    }\n    //全要素との 最小の差の和をかえす (全要素の中央値との差の和)\n    int min_dis() {        int mv = mid();        int mi = v_i[mv];        int lcou = bco.sum(mi);        int rcou = bco.sum(mi + 1, linf);        int lsum = mv * lcou - bsu.sum(mi);        int rsum = bsu.sum(mi + 1, linf) - mv * rcou;        return lsum + rsum;    }\n    int min_dis(int lv, int rv) {        int li = (std::lower_bound(all(i_v), lv) - i_v.begin());        int ri = (std::lower_bound(all(i_v), rv) - i_v.begin());        int mv = mid_it(li, ri);        int mi = v_i[mv];        int lcou = cou_it(li, mi);        int rcou = cou_it(mi, ri);        return mv * lcou - sum_it(li, mi) + sum_it(mi, ri) - mv * rcou;    }\n    int min_dis_i(int li, int ri) {        int mv = mid_it(li, ri);        int mi = v_i[mv];        int lcou = cou_it(li, mi);        int rcou = cou_it(mi, ri);        return mv * lcou - sum_it(li, mi) + sum_it(mi, ri) - mv * rcou;    }\n    //vをc個消す\n    void erase(int v, int c = 1) {        int ind = v_i[v];        assert(bco[ind] >= c);        count -= c;        bco.add(ind, -c);        bsu.add(ind, v * -c);    }\n    void operator-=(int v){erase(v);}\n    int lower_bound(int v) {        v = *std::lower_bound(all(i_v), v);        int i = v_i[v];        int needc = bco.sum(i) + 1;        i = bco.lower_bound(needc);        return i_v[i];    }\n    int upper_bound(int v) { return lower_bound(v + 1); }\n    void debu(){\n        bsu.debu();\n        bco.debu();\n        cerr<<\"\"<<endl;\n    }\n    //@formatter:on\n};\n\n//固定された要素に使う場合は\n//pbds_con\n//itは圧縮後のインデックスであり\n//自然に使おうとするとおかしくなるため\n\n\nvoid solve() {\n    in(n, q);\n    n *= 2;\n    na(a, n);\n    na(b, n);\n    vi c = a - b;\n    int base = sum(b) - b[0] - b[n - 1] + a[0] + a[n - 1];\n    dna3(p, x, y, q);\n    vi d = c + (x - y);\n    pbds_sum s(d);\n    rep(i, 1, n - 1) {\n        s += c[i];\n    }\n    rep(i, q) {\n//        s.debu();\n        int pp = p[i] - 1, xx = x[i], yy = y[i];\n        s -= c[pp];\n        base -= b[pp];\n        c[pp] = xx - yy;\n        a[pp] = xx;\n        b[pp] = yy;\n        s += c[pp];\n        base += b[pp];\n        auto cal = [&](int k) {\n            int v = s.sum_order_r(k * 2);\n            return v;\n        };\n        int k = goldt_l(0, (n) / 2 - 1, cal);\n        cout << base + s.sum_order_r(k * 2) << endl;\n//        s.debu();\n    }\n}\nvi my(ll n, int q, vi a, vi b, vi p, vi x, vi y) {\n//    in(n, q);\n    n *= 2;\n//    na(a, n);\n//    na(b, n);\n    vi c = a - b;\n    int base = sum(b) - b[0] - b[n - 1] + a[0] + a[n - 1];\n//    dna3(p, x, y, q);\n    vi d = c + (x - y);\n    pbds_sum s(d);\n    rep(i, 1, n - 1) {\n        s += c[i];\n    }\n    vi res;\n    rep(i, q) {\n//        s.debu();\n        int pp = p[i] - 1, xx = x[i], yy = y[i];\n        if (pp != 0 && pp != n - 1) {\n            s -= c[pp];\n            base -= b[pp];\n            c[pp] = xx - yy;\n            a[pp] = xx;\n            b[pp] = yy;\n            s += c[pp];\n            base += b[pp];\n        } else {\n            base -= a[pp];\n            c[pp] = xx - yy;\n            a[pp] = xx;\n            b[pp] = yy;\n            base += a[pp];\n        }\n        auto cal = [&](int k) {\n            int v = s.sum_order_r(k * 2);\n            return v;\n        };\n        int k = goldt_l(0, (n) / 2 - 1, cal);\n//        cout << base + s.sum_order_r(k*2) << endl;\n        res += base + s.sum_order_r(k * 2);\n//        s.debu();\n    }\n    return res;\n}\nauto sister(ll n, int q, vi a, vi b, vi p, vi x, vi y) {\n    vi ret;\n    n *= 2;\n    rep(i, q) {\n        a[p[i] - 1] = x[i];\n        b[p[i] - 1] = y[i];\n        vi c;\n        int base = a[0] + a[n - 1];\n        rep(i, 1, n - 1) {\n            base += b[i];\n            c += a[i] - b[i];\n        }\n        rsort(c);\n        auto rc = ruiv(c);\n        int ma = base;\n        rep(i, n + 3) {\n            if (i * 2 >= sz(rc))break;\n            chma(ma, base + rc[i * 2]);\n        }\n        ret += ma;\n    }\n    return ret;\n}\n\nsigned main() {\n//    solve();\n//    int n = 4;\n//    int q = 1;\n//    vi a = {1, 9, 5, 10, 6, 4, 8, 7};\n//    vi b = {9, 6, 6, 10, 8, 3, 3, 8};\n//    vi p = {8};/**/\n//    vi x = {9};\n//    vi y = {6};\n    int n, q;\n    vi a, b, p, x, y;\n    in(n, q);\n    na(a, n * 2);\n    na(b, n * 2);\n    na3(p, x, y, q);\n#define arg n,q,a,b,p,x,y\n    auto r = my(arg);\n    outl(r);\n\n#ifdef _DEBUG\n    bool bad = 0;\n    for (ll i = 0, ok = 1; i < k5 && ok; ++i) {\n        ll n = rand(1, 4);\n        ll q = rand(1, 1);\n        vi a = ranv(n * 2, 1, 10);\n        vi b = ranv(n * 2, 1, 10);\n        vi p = ranv(q, 1, n * 2);\n        vi x = ranv(q, 1, 10);\n        vi y = ranv(q, 1, 10);\n\n        auto myres = my(arg);\n        auto res = sister(arg);\n        ok = myres == res;\n        if (!ok) {\n//            out(arg);\n            out(n, q);\n            out(a);\n            out(b);\n            out(p);\n            out(x);\n            out(y);\n\n            cerr << \"AC : \" << res << endl;\n            cerr << \"MY  : \" << myres << endl;\n            bad = 1;\n            break;\n        }\n    }\n    if (!bad) {\n//        cout << \"完璧 : solveを書き直そう\" << endl;\n//        cout << \"     : そして、solve()を呼び出すのだ\" << endl;\n//        cout << \"     : cin>>n; na(a,n);も忘れるな\" << endl;\n    }\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n#define MAXN 100000\n#define ll long long\n#define INFLL 0x3f3f3f3f3f3f3f3fll\n#define rint register int\n#define gc() getchar()\ninline int read(rint ans = 0, rint sgn = ' ', rint ch = gc())\n{\n\tfor(; ch < '0' || ch > '9'; sgn = ch, ch = gc());\n\tfor(; ch >='0' && ch <='9';(ans*=10)+=ch-'0', ch = gc());\n\treturn sgn-'-'?ans:-ans;\n}\n#define BUF_SIZE 1000000\n#define _END fwrite(_Ob,1,_O-_Ob,stdout), _O = _Ob\n#define Outc(a) (*_O++ = a)\nchar _Ob[BUF_SIZE+5], *_O = _Ob, _Os[25], *_Ot;\ntemplate <typename T> inline void Out(T x)\n{\n\tif(!x){Outc('0'); return;} if(x < 0) Outc('-'), x = -x;\n\tfor(_Ot = _Os; x; *_Ot++ = x%10+'0', x /= 10);\n\tfor(; _Ot != _Os; Outc(*--_Ot)); if(_O-_Ob >= BUF_SIZE-50) _END;\n}\nint n, q, a[MAXN+5], b[MAXN+5]; multiset<int> Pos, Neg; multiset<int>::iterator it; ll base, sum;\nint main()\n{\n\tn = read()<<1, q = read(); for(rint i = 1; i <= n; base += (a[i++]=read())); for(rint i = 1; i <= n; b[i++] = read());\n\tfor(rint i = 2; i < n; b[i]>=a[i] ? sum += b[i]-a[i], Pos.insert(b[i]-a[i]) : Neg.insert(b[i]-a[i]), i++);\n\tfor(rint p; q--; Out(base+(Pos.size()&1?max(sum+(Neg.size()?*--Neg.end():INFLL),sum-*Pos.begin()):sum)), Outc('\\n'))\n\t{\n\t\tp = read(), base -= a[p], p>1&&p<n ? it = (b[p]>=a[p] ? sum -= b[p]-a[p], Pos.find(b[p]-a[p]) : Neg.find(b[p]-a[p])), (b[p]>=a[p]?Pos:Neg).erase(it),0 : 0;\n\t\ta[p] = read(), b[p] = read(), base += a[p], p>1&&p<n ? b[p]>=a[p] ? sum += b[p]-a[p], Pos.insert(b[p]-a[p]) : Neg.insert(b[p]-a[p]),0 : 0;\n\t}\t_END; return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint a[200000], b[200000];\n\nint main() {\n\tint n, q;\n\tscanf(\"%d %d\", &n, &q);\n\tint i;\n\tlong long suma=0;\n\tfor (i = 0; i < 2 * n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tsuma += a[i];\n\t}\n\tfor (i = 0; i < 2 * n; i++) {\n\t\tscanf(\"%d\", &b[i]);\n\t}\n\tint p, x, y;\n\tint l, r;\n\tlong long sum;\n\tfor (i = 0; i < q; i++) {\n\t\tscanf(\"%d %d %d\", &p, &x, &y);\n\t\tsuma = suma + (long long)x - (long long)a[p - 1];\n\t\ta[p - 1] = x;\n\t\tb[p - 1] = y;\n\t\tl = 1;\n\t\tr = 2 * n - 2;\n\t\tsum = suma;\n\t\twhile (true) {\n\t\t\twhile (l<2*n&&a[l] >= b[l]) {\n\t\t\t\tl++;\n\t\t\t}\n\t\t\twhile (r>=0&&a[r] >= b[r]) {\n\t\t\t\tr--;\n\t\t\t}\n\t\t\tif (l >= r) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsum = sum - a[l] + b[l] - a[r] + b[r];\n\t\t\tl++;\n\t\t\tr--;\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = 1e18;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  n *= 2;\n  assert(q <= 10);\n  vl a(n), b(n);\n  rep (i, n) {\n    cin >> a[i];\n  }\n  rep (i, n) {\n    cin >> b[i];\n  }\n  set<pii> aa, bb;\n  ll ans = 0;\n  rep (i, n) {\n    if (i == 0) {\n      ans += a[i];\n      continue;\n    }\n    if (i == n - 1) {\n      ans += a[i];\n      continue;\n    }\n    if (a[i] >= b[i]) {\n      ans += a[i];\n      aa.insert(pii(a[i] - b[i], i));\n    }\n    else {\n      ans += b[i];\n      bb.insert(pii(b[i] - a[i], i));\n    }\n  }\n  if ((int)aa.size() % 2) {\n    auto itra = aa.begin();\n    auto itrb = bb.begin();\n    pii a_s = *itra, b_s = *itrb;\n    if (a_s.first >= b_s.first) {\n      bb.erase(b_s);\n      int idx = b_s.second;\n      ans -= b[idx];\n      ans += a[idx];\n      aa.insert(pii(a[idx] - b[idx], idx));\n    }\n    else {\n      aa.erase(a_s);\n      int idx = a_s.second;\n      ans -= a[idx];\n      ans += b[idx];\n      bb.insert(pii(b[idx] - a[idx], idx));\n    }\n  }\n  while (q--) {\n    /*\n    cout << \"aa \";\n    for (auto itr = aa.begin(); itr != aa.end(); itr++) {\n      cout << *itr << \" \";\n    }\n    cout << endl;\n    cout << \"bb \";\n    for (auto itr = bb.begin(); itr != bb.end(); itr++) {\n      cout << *itr << \" \";\n    }\n    //*/\n    int p, x, y;\n    cin >> p >> x >> y;\n    p--;\n    if (p == 0 || p == n - 1) {\n      ans -= a[p];\n      a[p] = x;\n      b[p] = y;\n      ans += a[p];\n      continue;\n    }\n    if (aa.count(pii(a[p] - b[p], p))) {\n      aa.erase(pii(a[p] - b[p], p));\n      ans -= a[p];\n    }\n    else if (bb.count(pii(b[p] - a[p], p))) {\n      bb.erase(pii(b[p] - a[p], p));\n      ans -= b[p];\n    }\n    else {\n      assert(false);\n    }\n    a[p] = x;\n    b[p] = y;\n    if (a[p] >= b[p]) {\n      ans += a[p];\n      aa.insert(pii(a[p] - b[p], p));\n    }\n    else {\n      ans += b[p];\n      bb.insert(pii(b[p] - a[p], p));\n    }\n    if ((int)aa.size() % 2) {\n      auto itra = aa.begin();\n      auto itrb = bb.begin();\n      pii a_s = *itra, b_s = *itrb;\n      if (a_s.first >= b_s.first) {\n        bb.erase(b_s);\n        int idx = b_s.second;\n        ans -= b[idx];\n        ans += a[idx];\n        aa.insert(pii(a[idx] - b[idx], idx));\n      }\n      else {\n        aa.erase(a_s);\n        int idx = a_s.second;\n        ans -= a[idx];\n        ans += b[idx];\n        bb.insert(pii(b[idx] - a[idx], idx));\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nlong long a[200000], b[200000];\n//dp[0][i]=(1番目からi番目まででbを偶数個選んだ時の値の総和の最大値)\n//dp[1][i]=(1番目からi番目まででbを奇数個選んだ時の値の総和の最大値)\nlong long dp[2][200000];\n\nlong long max(long long a, long long b){\n\treturn a < b ? b : a;\n}\n\n//O(nq)\nint main() {\n\tint n, q, i, j, p;\n\tlong long x, y;\n\tscanf(\"%d%d\", &n, &q);\n\tfor (i = 0; i < 2 * n; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t\tdp[0][1] += a[i];\n\t}\n\tfor (i = 0; i < 2 * n; i++) {\n\t\tscanf(\"%lld\", &b[i]);\n\t}\n\tfor (i = 0; i < q; i++) {\n\t\tscanf(\"%d%lld%lld\", &p,&x,&y);\n\t\tdp[0][1] += x - a[p - 1];\n\t\ta[p - 1] = x;\n\t\tb[p - 1] = y;\n\t\tdp[1][1] = dp[0][1] + b[1] - a[1];\n\t\tfor (j = 2; j <= 2 * n - 2; j++) {\n\t\t\tdp[0][j] = max(dp[0][j - 1], dp[1][j - 1] + b[j] - a[j]);\n\t\t\tdp[1][j] = max(dp[1][j - 1], dp[0][j - 1] + b[j] - a[j]);\n\t\t}\n\t\tprintf(\"%lld\\n\", dp[0][2 * n - 2]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define maxn 200100\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> par;\npar s[maxn<<2];\nint n,a[maxn],b[maxn],q;\nvoid upd(int o){\n\ts[o].first=max(s[o<<1].first+s[o<<1|1].first,s[o<<1].second+s[o<<1|1].second);\n\ts[o].second=max(s[o<<1].second+s[o<<1|1].first,s[o<<1].first+s[o<<1|1].second); \n}\nvoid build(int o,int l,int r){\n\tif(l==r){\n\t\ts[o]=par(b[l],a[l]);\n\t\treturn ;\n\t}\n\tint mid=l+r>>1;\n\tbuild(o<<1,l,mid);\n\tbuild(o<<1|1,mid+1,r);\n\tupd(o);\n}\nvoid mdy(int o,int l,int r,int k,par p){\n\tif(l==r){\n\t\ts[o]=p;\n\t\treturn ;\n\t}\n\tint mid=l+r>>1;\n\tif(k<=mid)mdy(o<<1,l,mid,k,p);\n\telse mdy(o<<1|1,mid+1,r,k,p);\n\tupd(o);\n}\nint main(){\n\tscanf(\"%d%d\",&n,&q);\n\tfor(int i=1;i<=2*n;++i)scanf(\"%d\",&a[i]);\n\tfor(int i=1;i<=2*n;++i)scanf(\"%d\",&b[i]);\n\tbuild(1,2,2*n-1);\n\tfor(int i=1,p,x,y;i<=q;++i){\n\t\tscanf(\"%d%d%d\",&p,&x,&y);\n\t\tif(2<=p&&p<=2*n-1)mdy(1,2,2*n-1,p,par(y,x));\n\t\telse a[p]=x,b[p]=y;\n\t\tprintf(\"%lld\\n\",a[1]+a[2*n]+s[1].first); \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\npair<long long, long long> datas[500000];\nlong long erased[500000];\nlong long itr[500000];\nint main() {\n\tiostream::sync_with_stdio(false);\n#define int long long\n\tint n, query;\n\tcin >> n >> query;\n\tREP(i, 2 * n) {\n\t\tcin >> datas[i].first;\n\t}\n\tREP(i, 2 * n) {\n\t\tcin >> datas[i].second;\n\t}\n\tREP(i, 2 * n) {\n\t\titr[i] = i;\n\t}\n\tpriority_queue<pair<long long,long long>> next_loser;\n\tpriority_queue<pair<long long, long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>> next_winner;\n\tlong long now_ans = 0;\n\tnow_ans += datas[0].first;\n\tnow_ans += datas[2 * n - 1].first;\n\tlong long now_cnt = 0;\n\tfor (int i = 1; i < 2 * n - 1; ++i) {\n\t\tnow_ans += datas[i].second;\n\t\tlong long geko = datas[i].first - datas[i].second;\n\t\tif (geko >= 0) {\n\t\t\tnow_cnt++;\n\t\t\tnext_winner.push(make_pair(geko, i));\n\t\t\tnow_ans += geko;\n\t\t}\n\t\telse {\n\t\t\tnext_loser.push(make_pair(geko, i));\n\t\t}\n\t}\n\tint next_move = 2 * n;\n\tREP(i, query) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;\n\t\tif (a == 0 || a == 2 * n - 1) {\n\t\t\tnow_ans -= datas[a].first;\n\t\t\tnow_ans += b;\n\t\t\tdatas[a] = make_pair(b, c);\n\n\t\t}\n\t\telse {\n\t\t\t//First We need To remove\n\t\t\t{\n\t\t\t\tint data_itr = itr[a];\n\t\t\t\terased[data_itr] = 1;\n\t\t\t\tnow_ans -= datas[data_itr].second;\n\t\t\t\tint diff = datas[data_itr].first - datas[data_itr].second;\n\t\t\t\tif (diff >= 0) {\n\t\t\t\t\tnow_cnt--;\n\t\t\t\t\tnow_ans -= diff;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//nothing\n\t\t\t\t}\n\t\t\t\tdatas[data_itr] = make_pair(0, 0);\n\t\t\t\twhile (next_winner.empty() == false && erased[next_winner.top().second] == 1) {\n\t\t\t\t\tnext_winner.pop();\n\t\t\t\t}\n\t\t\t\twhile (next_loser.empty() == false && erased[next_loser.top().second] == 1) {\n\t\t\t\t\tnext_loser.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tlong long data_itr = next_move;\n\t\t\t\tnext_move++;\n\t\t\t\titr[a] = data_itr;\n\t\t\t\tdatas[data_itr] = make_pair(b, c);\n\t\t\t\tnow_ans += datas[data_itr].second;\n\t\t\t\tlong long diff = datas[data_itr].first - datas[data_itr].second;\n\t\t\t\tif (diff >= 0) {\n\t\t\t\t\tnow_cnt++;\n\t\t\t\t\tnow_ans += diff;\n\t\t\t\t\tnext_winner.push(make_pair(diff, data_itr));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//nothing\n\t\t\t\t\tnext_loser.push(make_pair(diff, data_itr));\n\t\t\t\t}\n\t\t\t\t//OK!\n\t\t\t}\n\t\t}\n\t\tif (now_cnt % 2 == 0) {\n\t\t\tcout << now_ans << endl;\n\t\t}\n\t\telse {\n\t\t\tlong long geko = now_ans - next_winner.top().first;\n\t\t\tif (next_loser.empty() == false) {\n\t\t\t\tgeko = max(geko, now_ans + next_loser.top().first);\n\t\t\t}\n\t\t\tcout << geko << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nlong A[200000];\nlong B[200000];\nvoid Calc(){\n\tint N = rei()*2;\n\tint Q = rei();\n\tfor(int i=0;i<N;i++){\n\t\tA[i] = rel();\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tB[i] = rel();\n\t}\n\tpriority_queue<long,vector<long>,greater<long>> Abigger;\n\tpriority_queue<long,vector<long>,greater<long>> Abiggerdelete;\n\tpriority_queue<long,vector<long>,greater<long>> Bbigger;\n\tpriority_queue<long,vector<long>,greater<long>> Bbiggerdelete;\n\tint Anum = 0;\n\tint Bnum = 0;\n\tlong sum = A[0] + A[N-1];\n\tfor(int i=1;i<N-1;i++){\n\t\tif(A[i] >= B[i]){\n\t\t\tAbigger.push(A[i]-B[i]);\n\t\t\tAnum++;\n\t\t\tsum += A[i];\n\t\t}\n\t\telse{\n\t\t\tBbigger.push(B[i]-A[i]);\n\t\t\tBnum++;\n\t\t\tsum += B[i];\n\t\t}\n\t}\n\tfor(int query=0;query<Q;query++){\n\t\tint p = rei()-1;\n\t\tif(p == 0 || p == N-1){\n\t\t\tsum -= A[p];\n\t\t}\n\t\telse{\n\t\t\tif(A[p] >= B[p]){\n\t\t\t\tsum -= A[p];\n\t\t\t\tAbiggerdelete.push(A[p]-B[p]);\n\t\t\t\tAnum--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum -= B[p];\n\t\t\t\tBbiggerdelete.push(B[p]-A[p]);\n\t\t\t\tBnum--;\n\t\t\t}\n\t\t}\n\t\tA[p] = rel();\n\t\tB[p] = rel();\n\t\tif(p == 0 || p == N-1){\n\t\t\tsum += A[p];\n\t\t}\n\t\telse{\n\t\t\tif(A[p] >= B[p]){\n\t\t\t\tAbigger.push(A[p]-B[p]);\n\t\t\t\tAnum++;\n\t\t\t\tsum += A[p];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tBbigger.push(B[p]-A[p]);\n\t\t\t\tBnum++;\n\t\t\t\tsum += B[p];\n\t\t\t}\n\t\t}\n\t\tlong ans = sum;\n\t\tif(Anum % 2){\n\t\t\twhile(!Abiggerdelete.empty() && Abigger.top() == Abiggerdelete.top()){\n\t\t\t\tAbigger.pop();\n\t\t\t\tAbiggerdelete.pop();\n\t\t\t}\n\t\t\twhile(!Bbiggerdelete.empty() && Bbigger.top() == Bbiggerdelete.top()){\n\t\t\t\tBbigger.pop();\n\t\t\t\tBbiggerdelete.pop();\n\t\t\t}\n\t\t\tans -= min(Abigger.top(),Bbigger.top());\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint main() {\n        int n, q;\n        scanf(\"%d%d\", &n, &q);\n        n = 2 * n;\n        vector<long long> a(n), b(n);\n        for (int i = 0; i < n; i ++) scanf(\"%lld\", &a[i]);\n        for (int i = 0; i < n; i ++) scanf(\"%lld\", &b[i]);\n        multiset<long long> positive, negative;\n        long long psum = 0, nsum = 0;\n        for (int i = 0; i < n; i ++) {\n                if (i == 0 || i == n - 1) {\n                        psum += a[i];\n                        continue;\n                }\n                long long c = a[i] - b[i];\n                if (c >= 0) { \n                        positive.insert(c);\n                        psum += a[i];\n                } else { \n                        negative.insert(- c);\n                        nsum += b[i];\n                }\n        }\n        while (q --) {\n                int p;\n                long long x, y;\n                scanf(\"%d%lld%lld\", &p, &x, &y);\n                p --;\n                long long z = x - y;\n                if (p == 0 || p == n - 1) {\n                        psum -= a[p];\n                        psum += x;\n                        a[p] = x;\n                        continue;\n                }\n                int c = a[p] - b[p];\n                //remove\n                if (c >= 0) {\n                        positive.erase(positive.find(c));\n                        psum -= a[p];\n                } else {\n                        negative.erase(negative.find(-c));\n                        nsum -= b[p];\n                }\n                //insert\n                if (z >= 0) {\n                        positive.insert(z);\n                        psum += x;\n                } else {\n                        negative.insert(-z);\n                        nsum += y;\n                }\n                a[p] = x;\n                b[p] = y;\n                long long ans;\n                if (positive.size() % 2 == 0) ans = psum + nsum;\n                else ans = psum + nsum - min(*positive.begin(), *negative.begin());\n                printf(\"%lld\\n\", ans);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\n\nint main(){\n    int n,q;\n    cin>>n>>q;\n    n*=2;\n    ll a[n],b[n];\n    rep(i,n)cin>>a[i];\n    rep(i,n)cin>>b[i];\n    ll ans=a[0]+a[n-1];\n    int posi=0,ze=0;\n    multiset<ll> st;\n    rep(i,n-2){\n        ans+=max(a[i+1],b[i+1]);\n        if(a[i+1]<b[i+1])posi++;\n        st.insert(abs(a[i+1]-b[i+1]));\n    }\n    rep(i,q){\n        ll p,x,y;\n        cin>>p>>x>>y;\n        p--;\n        if(p==0||p==n-1)ans+=(ll)(x-a[p]);\n        else{\n        ans+=max(x,y);\n        ans-=max(a[p],b[p]);\n        auto it=st.find(abs(a[p]-b[p]));\n        st.erase(it);\n        st.insert(abs(x-y));\n        if(a[p]<b[p])posi--;\n        if(x<y)posi++;\n        }\n        a[p]=x;\n        b[p]=y;\n        if(posi%2==0)cout<<ans<<endl;\n        else cout<<ans-*st.begin()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const auto& a = T()) { v.assign(n, a); }\ntemplate<class T, class... U> void assign(V<T>& v, int n, const U&... u) { v.resize(n); for (auto&& i : v) assign(i, u...); }\n\nstruct M {\n  using T = array<lint, 3>;\n  static T op(const T& a, const T& b) { return {min(a[0], b[0]), max(a[1], b[1]), a[2] + b[2]}; }\n  static constexpr T e() { return {numeric_limits<lint>::max(), numeric_limits<lint>::min(), 0}; }\n  static T mk(lint a) { return {a, a, a}; }\n};\n\ntemplate<class M> struct ST {\n  using T = typename M::T;\n  int n;\n  V<T> t;\n\n  ST(int n) : n(n) {\n    t.assign(2 * n, M::e());\n  }\n\n  void build() {\n    for (int i = n - 1; i; i--) t[i] = M::op(t[2 * i], t[2 * i + 1]);\n  }\n\n  T get(int l, int r) {\n    T resl = M::e(), resr = M::e();\n    for (l += n, r += n; l < r; l >>= 1, r >>= 1) { \n      if (l & 1) resl = M::op(resl, t[l++]); \n      if (r & 1) resr = M::op(t[--r], resr);\n    }\n    return M::op(resl, resr);\n  }\n\n  T get(int i) { return t[i + n]; };\n\n  void set(int i, const T& a) {\n    for (t[i += n] = a; i >>= 1;) t[i] = M::op(t[2 * i], t[2 * i + 1]);\n  }\n};\n\nint main() {\n  cin.tie(NULL); ios::sync_with_stdio(false);\n  int n, q; cin >> n >> q;\n  V<> a(2 * n); for (int i = 0; i < 2 * n; i++) cin >> a[i];\n  V<> b(2 * n); for (int i = 0; i < 2 * n; i++) cin >> b[i];\n  lint sa = accumulate(a.begin(), a.end(), 0LL);\n  ST<M> pos(2 * n), neg(2 * n);\n  int cp = 0;\n  for (int i = 1; i < 2 * n - 1; i++) (b[i] - a[i] >= 0 ? cp++, pos : neg).t[i + 2 * n] = M::mk(b[i] - a[i]);\n  pos.build(), neg.build();\n  for (int iq = 0; iq < q; iq++) {\n    int p, x, y; cin >> p >> x >> y, p--;\n    if (p and p < 2 * n - 1) {\n      if (y - x >= 0) {\n        pos.set(p, M::mk(y - x));\n        neg.set(p, M::e());\n        cp += (b[p] - a[p] < 0);\n      } else {\n        neg.set(p, M::mk(y - x));\n        pos.set(p, M::e());\n        cp -= (b[p] - a[p] >= 0);\n      }\n    }\n    sa += x - a[p];\n    a[p] = x, b[p] = y;\n    lint s = pos.get(1, 2 * n - 1)[2];\n    if (cp & 1) {\n      s -= min(pos.get(1, 2 * n - 1)[0], -neg.get(1, 2 * n - 1)[1]);\n    }\n    cout << sa + s << '\\n';\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<map>\n#include<set>\n#include<bitset>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nint dx[4]={1,0,-1,0} , dy[4]={0,1,0,-1} ;\n\n\nint main(){\n    int n,q;\n    cin>>n>>q;\n    n*=2;\n    ll a[n],b[n];\n    rep(i,n)cin>>a[i];\n    rep(i,n)cin>>b[i];\n    ll ans=a[0]+a[n-1];\n    int posi=0,zero=0;\n    multiset<ll> st;\n    rep(i,n-2){\n        ans+=max(a[i+1],b[i+1]);\n        if(a[i+1]>b[i+1])posi++;\n        if(a[i+1]==b[i+1])zero++;\n        st.insert(abs(a[i+1]-b[i+1]));\n    }\n    rep(i,q){\n        int p,x,y;\n        cin>>p>>x>>y;\n        p--;\n        if(p==1||p==n){\n            ans+=x-a[p];\n            a[p]=x;\n            cout<<ans<<endl;\n            continue;\n        }\n        ans+=max(x,y)-max(a[p],b[p]);\n        auto it=st.lower_bound(abs(a[p]-b[p]));\n        st.erase(it);\n        st.insert(abs(x-y));\n        if(a[p]-b[p]>0)posi--;\n        if(a[p]-b[p]==0)zero--;\n        if(x-y>0)posi++;\n        if(x-y==0)zero++;\n        a[p]=x;b[p]=y;\n        if(zero>0||posi%2==0)cout<<ans<<endl;\n        else cout<<ans-*st.begin()<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define REP(e,v) for(auto e:v)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\n#define MAX_V 400010\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\nll MOD=1e9+7;\n#define N 1055050\n\nll n,m,k;\nll a[N],b[N];\ntemplate< typename Monoid >\nstruct SegmentTree {\n  using F = function< Monoid(Monoid, Monoid) >;\n \n  int sz;\n  vector< Monoid > seg;\n \n  const F f;\n  const Monoid M1;\n \n  SegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1) {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz, M1);\n  }\n \n  void set(int k, const Monoid &x) {\n    seg[k + sz] = x;\n  }\n \n  void build() {\n    for(int k = sz - 1; k > 0; k--) {\n      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n    }\n  }\n \n  void update(int k, const Monoid &x) {\n    k += sz;\n    seg[k] = x;\n    while(k >>= 1) {\n      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n    }\n  }\n \n  Monoid query(int a, int b) {\n    Monoid L = M1, R = M1;\n    for(a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n      if(a & 1) L = f(L, seg[a++]);\n      if(b & 1) R = f(seg[--b], R);\n    }\n    return f(L, R);\n  }\n \n  Monoid operator[](const int &k) const {\n    return seg[k + sz];\n  }\n};\n//SegmentTree(n,f,M1) nで初期化　fは二項演算　M1は単位元\n//set(k,x) 要素k = x\n//build() 構築\n//query 区間[a,b)に二項演算\n//update(k,x) kをxに\n//operator[k] k番目の要素\n// SegmentTree< int > seg(N,[](int a,int b){return min(a,b);},INF);\n//みたいに使う\nmain(){\n    n=in();\n    int q=in();\n    SegmentTree<ll> seg(n*2+1,[](ll a,ll b){return min(a,b);},INF);\n    ll sum=0;\n    rep(i,n*2){\n        a[i]=in();\n        sum+=a[i];\n    }\n    int count=0;\n    ll dif=0;\n    rep(i,n*2){\n        b[i]=in();\n        if(i==0||i==n*2-1)continue;\n        if(b[i]>a[i]){\n            seg.set(i,b[i]-a[i]);\n            dif+=b[i]-a[i];\n            count++;\n        }\n    }\n    seg.build();\n    rep(iii,q){\n        int p=in();p--;\n        ll prea=a[p],preb=b[p];\n        a[p]=lin();b[p]=in();\n        sum+=a[p]-prea;\n        if(p==0||p==n*2-1){\n            goto G;\n        }\n        if(preb>prea){\n            count--;\n            dif-=preb-prea;\n        }\n        if(b[p]>a[p]){\n            count++;\n            seg.update(p,b[p]-a[p]);\n            dif+=b[p]-a[p];\n        }\n        G:\n        if(count%2){\n            cout<<sum+dif-seg.query(0,2*n)<<endl;\n        }\n        else cout<<sum+dif<<endl;\n    }\n}\n/*1 4 7 3\n4 6 3 3\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\n#define REP(i,n) for(long long i = 0; i < (n); i++)\n#define FOR(i, m, n) for(long long i = (m);i < (n); ++i)\n#define ALL(obj) (obj).begin(),(obj).end()\n#define SPEED cin.tie(0);ios::sync_with_stdio(false);\n\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\ntemplate<class T> using PQ = priority_queue<T>;\ntemplate<class T> using PQR = priority_queue<T,vector<T>,greater<T>>;\n\nconstexpr long long MOD = (long long)1e9 + 7;\nconstexpr long long MOD2 = 998244353;\nconstexpr long long HIGHINF = (long long)1e18;\nconstexpr long long LOWINF = (long long)1e15;\nconstexpr long double PI = 3.1415926535897932384626433;\n\ntemplate <class T> vector<T> make_v(size_t N,T init){return vector<T>(N,init);}\ntemplate <class... T> auto make_v(size_t N,T... t){return vector<decltype(make_v(t...))>(N,make_v(t...));}\ntemplate <class T> void corner(bool flg, T hoge) {if (flg) {cout << hoge << endl; exit(0);}}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const map<T, U>&obj) {o << \"{\"; for (auto &x : obj) o << \" {\" << x.first << \" : \" << x.second << \"}\" << \",\"; o << \" }\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const set<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const multiset<T>&obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr) o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\ntemplate <class T>ostream &operator<<(ostream &o, const vector<T>&obj) {o << \"{\"; for (int i = 0; i < (int)obj.size(); ++i)o << (i > 0 ? \", \" : \"\") << obj[i]; o << \"}\"; return o;}\ntemplate <class T, class U>ostream &operator<<(ostream &o, const pair<T, U>&obj) {o << \"{\" << obj.first << \", \" << obj.second << \"}\"; return o;}\ntemplate <template <class tmp>  class T, class U> ostream &operator<<(ostream &o, const T<U> &obj) {o << \"{\"; for (auto itr = obj.begin(); itr != obj.end(); ++itr)o << (itr != obj.begin() ? \", \" : \"\") << *itr; o << \"}\"; return o;}\nvoid print(void) {cout << endl;}\ntemplate <class Head> void print(Head&& head) {cout << head;print();}\ntemplate <class Head, class... Tail> void print(Head&& head, Tail&&... tail) {cout << head << \" \";print(forward<Tail>(tail)...);}\ntemplate <class T> void chmax(T& a, const T b){a=max(a,b);}\ntemplate <class T> void chmin(T& a, const T b){a=min(a,b);}\nvoid YN(bool flg) {cout << (flg ? \"YES\" : \"NO\") << endl;}\nvoid Yn(bool flg) {cout << (flg ? \"Yes\" : \"No\") << endl;}\nvoid yn(bool flg) {cout << (flg ? \"yes\" : \"no\") << endl;}\n\nint main() {\n\tSPEED\n\tint N,Q; cin >> N >> Q;\n\tvector<ll> a(2*N),b(2*N);\n\tfor(int i = 0; i < 2*N; ++i) cin >> a[i];\n\tfor(int i = 0; i < 2*N; ++i) cin >> b[i];\n\tll sum = accumulate(ALL(a),0LL), diff = 0;;\n\tmultiset<ll> l,r;\n\tfor(int i = 1; i < 2*N - 1; ++i) {\n\t\tll c = b[i]-a[i];\n\t\tif(c>=0) {\n\t\t\tdiff += c;\n\t\t\tr.insert(c);\n\t\t}\n\t\telse {\n\t\t\tl.insert(c);\n\t\t}\n\t}\n\tfor(int i = 0; i < Q; ++i) {\n\t\tll p,x,y; cin >> p >> x >> y;\n\t\tp--;\n\t\tif(0 < p && p < 2*N-1) {\n\t\t\tll c = b[p] - a[p],d = y - x;\n\t\t\tif(c>=0) {\n\t\t\t\tdiff -= c;\n\t\t\t\tr.erase(r.find(c));\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl.erase(l.find(c));\n\t\t\t}\t\t\n\t\t\tif(d>=0) {\n\t\t\t\tdiff += d;\n\t\t\t\tr.insert(d);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tl.insert(d);\n\t\t\t}\n\t\t}\n\t\tsum -= a[p];\n\t\ta[p] = x;\n\t\tsum += a[p];\n\t\tb[p] = y;\n\t\tll e = 0;\n\t\tif(r.size()%2) {\n\t\t\tif(*l.rbegin() + *r.begin() >= 0) e = *l.rbegin();\n\t\t\telse e = -*r.begin();\n\t\t}\n\t\tcout << sum + diff + e << endl;\n\t} \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<iostream>\n#define rep(i,a,b)for(int i=a;i<b;++i)\ntypedef long long ll;\nusing namespace std;\nint N,Q;\nll A[200001],B[200001];\nmultiset<ll>S;\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin>>N>>Q;\n\trep(i,0,N<<1)cin>>A[i];\n\trep(i,0,N<<1)cin>>B[i];\n\tll ans=0;\n\tbool odd=0;\n\tans+=A[0]+A[(n<<1)-1];\n\trep(i,1,(N<<1)-1){\n\t\tans+=max(A[i],B[i]);\n\t\todd^=(A[i]>B[i]);\n\t\tS.insert(abs(A[i]-B[i]));\n\t}\n\twhile(Q--){\n\t\tll a,x,y;\n\t\tcin>>a>>x>>y;\n\t\tif(--a==0||a==(N<<1)-1){\n\t\t\tans+=x-A[a];\n\t\t\tA[a]=x;\n\t\t}else{\n\t\t\todd^=(A[a]>B[a]);\n\t\t\todd^=(x>y);\n\t\t\tans+=max(x, y)-max(A[a],B[a]);\n\t\t\tint*p=S.lower_bound(abs(A[a]-B[a]));\n\t\t\tS.erase();\n\t\t\tS.insert(abs(x-y));\n\t\t\tA[a]=x;\n\t\t\tB[a]=y;\n\t\t}\n\t\tcout<<(!odd?ans:ans-(*S.begin()))<<\"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\npair<long long, long long> datas[500000];\nint erased[500000];\nint itr[500000];\nint main() {\n#define int long long\n\tint n, query;\n\tcin >> n >> query;\n\tREP(i, 2 * n) {\n\t\tcin >> datas[i].first;\n\t}\n\tREP(i, 2 * n) {\n\t\tcin >> datas[i].second;\n\t}\n\tREP(i, 2 * n) {\n\t\titr[i] = i;\n\t}\n\tpriority_queue<pair<long long,long long>> next_loser;\n\tpriority_queue<pair<long long, long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>> next_winner;\n\tlong long now_ans = 0;\n\tREP(i, 2 * n) {\n\t\tnow_ans += datas[i].second;\n\t}\n\tnow_ans += datas[0].first - datas[0].second;\n\tnow_ans += datas[2 * n - 1].first - datas[2 * n - 1].second;\n\tlong long now_cnt = 0;\n\tfor (int i = 1; i < 2 * n - 1; ++i) {\n\t\tlong long geko = datas[i].first - datas[i].second;\n\t\tif (geko >= 0) {\n\t\t\tnow_cnt++;\n\t\t\tnext_winner.push(make_pair(geko, i));\n\t\t\tnow_ans += geko;\n\t\t}\n\t\telse {\n\t\t\tnext_loser.push(make_pair(geko, i));\n\t\t}\n\t}\n\tint next_move = 2 * n;\n\tREP(i, query) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;\n\t\tif (a == 0 || a == 2 * n - 1) {\n\t\t\tnow_ans -= datas[a].first;\n\t\t\tnow_ans += b;\n\t\t\tdatas[a] = make_pair(b, c);\n\t\t\tcontinue;\n\t\t}\n\t\t//First We need To remove\n\t\tint data_itr = itr[a];\n\t\terased[data_itr] = 1;\n\t\tnow_ans -= datas[data_itr].second;\n\t\tint diff = datas[data_itr].first - datas[data_itr].second;\n\t\tif (diff >= 0) {\n\t\t\tnow_cnt--;\n\t\t\tnow_ans -= diff;\n\t\t}\n\t\telse {\n\t\t\t//nothing\n\t\t}\n\t\twhile (next_winner.empty() == false && erased[next_winner.top().second] == true) {\n\t\t\tnext_winner.pop();\n\t\t}\n\t\twhile (next_loser.empty() == false && erased[next_loser.top().second] == true) {\n\t\t\tnext_loser.pop();\n\t\t}\n\t\tdata_itr = next_move;\n\t\tnext_move++;\n\t\titr[a] = data_itr;\n\t\tdatas[data_itr] = make_pair(b, c);\n\t\tnow_ans += datas[data_itr].second;\n\t\tdiff = datas[data_itr].first - datas[data_itr].second;\n\t\tif (diff >= 0) {\n\t\t\tnow_cnt++;\n\t\t\tnow_ans += diff;\n\t\t\tnext_winner.push(make_pair(diff, data_itr));\n\t\t}\n\t\telse {\n\t\t\t//nothing\n\t\t\tnext_loser.push(make_pair(diff, data_itr));\n\t\t}\n\t\t//OK!\n\t\tif (now_cnt % 2 == 0) {\n\t\t\tcout << now_ans << endl;\n\t\t}\n\t\telse {\n\t\t\tlong long geko = now_ans - next_winner.top().first;\n\t\t\tif (next_loser.empty() == false) {\n\t\t\t\tgeko = max(geko, now_ans + next_loser.top().first);\n\t\t\t}\n\t\t\tcout << geko << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sp ' '\n#define mkp make_pair\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define lP pair<ll,ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\nconst int mod = 1000000007, mod998 = 998244353;\nconst string nyan(\"(=^・ω・^=)\");\n\nint N, Q, a[100000], b[100000], p, x, y;\nbool u[100000];\nset<pair<int, int>>st[2];\nll res;\n\nint main() {\n\tcin >> N >> Q;\n\tN <<= 1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> b[i];\n\t}\n\t--Q;\n\tcin >> p >> x >> y;\n\t--p;\n\ta[p] = x;\n\tb[p] = y;\n\tres = a[0] + a[N - 1];\n\tfor (int i = 1; i < N - 1; ++i) {\n\t\tif (a[i] >= b[i]) {\n\t\t\tu[i] = true;\n\t\t\tres += a[i];\n\t\t\tst[1].insert(mkp(a[i] - b[i], i));\n\t\t}\n\t\telse {\n\t\t\tres += b[i];\n\t\t\tst[0].insert(mkp(b[i] - a[i], i));\n\t\t}\n\t}\n\tif (st[0].size() & 1) {\n\t\tif (st[0].begin()->first > st[1].begin()->first) {\n\t\t\tres -= st[1].begin()->first;\n\t\t\tu[st[1].begin()->second] ^= true;\n\t\t\tst[0].insert(mkp(-st[1].begin()->first, st[1].begin()->second));\n\t\t\tst[1].erase(st[1].begin());\n\t\t}\n\t\telse {\n\t\t\tres -= st[0].begin()->first;\n\t\t\tu[st[0].begin()->second] ^= true;\n\t\t\tst[1].insert(mkp(-st[0].begin()->first, st[0].begin()->second));\n\t\t\tst[0].erase(st[0].begin());\n\t\t}\n\t}\n\tcout << res << endl;\n\twhile (Q--) {\n\t\tcin >> p >> x >> y;\n\t\t--p;\n\t\tif (p == 0 || p == N - 1) {\n\t\t\tres += x - a[p];\n\t\t\ta[p] = x;\n\t\t}\n\t\telse {\n\t\t\tif (u[p]) {\n\t\t\t\tres += x - a[p];\n\t\t\t\tst[1].erase(mkp(a[p] - b[p], p));\n\t\t\t\tst[1].insert(mkp(x - y, p));\n\t\t\t\tauto it = st[1].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tif (it->first < 0 && it2->first < 0) {\n\t\t\t\t\tres -= it->first + it2->first;\n\t\t\t\t\tst[0].insert(mkp(-it->first, it->second));\n\t\t\t\t\tst[0].insert(mkp(-it2->first, it2->second));\n\t\t\t\t\tu[it->second] ^= true;\n\t\t\t\t\tu[it2->second] ^= true;\n\t\t\t\t\tst[1].erase(it2);\n\t\t\t\t\tst[1].erase(it);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres += y - b[p];\n\t\t\t\tst[0].erase(mkp(b[p] - a[p], p));\n\t\t\t\tst[0].insert(mkp(y - x, p));\n\t\t\t\tauto it = st[0].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tif (it->first < 0 && it2->first < 0) {\n\t\t\t\t\tres -= it->first + it2->first;\n\t\t\t\t\tst[1].insert(mkp(-it->first, it->second));\n\t\t\t\t\tst[1].insert(mkp(-it2->first, it2->second));\n\t\t\t\t\tu[it->second] ^= true;\n\t\t\t\t\tu[it2->second] ^= true;\n\t\t\t\t\tst[0].erase(it2);\n\t\t\t\t\tst[0].erase(it);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!st[0].empty() && !st[1].empty() && st[0].begin()->first + st[1].begin()->first < 0) {\n\t\t\t\tauto it = st[0].begin();\n\t\t\t\tauto it2 = st[1].begin();\n\t\t\t\tres -= it->first + it2->first;\n\t\t\t\tu[it->second] ^= true;\n\t\t\t\tu[it2->second] ^= true;\n\t\t\t\tst[0].insert(mkp(-it2->first, it2->second));\n\t\t\t\tst[1].insert(mkp(-it->first, it->second));\n\t\t\t\tst[0].erase(it);\n\t\t\t\tst[1].erase(it2);\n\t\t\t}\n\t\t\ta[p] = x;\n\t\t\tb[p] = y;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=998244353,MAX=1003,INF=1<<29;\n\nint main(){\n    \n    int N,Q;cin>>N>>Q;\n    multiset<ll> minus,plus;\n    vector<ll> A(2*N),B(2*N);\n    \n    ll ans=0;\n    \n    for(int i=0;i<2*N;i++) cin>>A[i];\n    for(int i=0;i<2*N;i++) cin>>B[i];\n    \n    for(int i=0;i<2*N;i++){\n        ll a,b;\n        a=A[i];\n        b=B[i];\n        if(i==0||i==2*N-1){\n            ans+=a;\n        }else{\n            if(a>b){\n                plus.insert(a-b);\n                ans+=(a-b);\n            }\n            else minus.insert(a-b);\n            \n            ans+=b;\n        }\n    }\n    \n    while(Q){\n        ll p,a,b;cin>>p>>a>>b;\n        p--;\n        if(p==0||p==2*N-1){\n            ans-=A[p];\n            ans+=a;\n            A[p]=a;\n        }else{\n            if(A[p]>B[p]){\n                ans-=A[p];\n                ans+=b;\n                auto it=plus.lower_bound(A[p]-B[p]);\n                plus.erase(it);\n                \n                A[p]=a;B[p]=b;\n                if(a>b){\n                    plus.insert(a-b);\n                    ans+=(a-b);\n                }\n                else minus.insert(a-b);\n            }else{\n                ans-=B[p];\n                ans+=b;\n                auto it=minus.lower_bound(A[p]-B[p]);\n                minus.erase(it);\n                \n                A[p]=a;B[p]=b;\n                if(a>b){\n                    plus.insert(a-b);\n                    ans+=(a-b);\n                }\n                else minus.insert(a-b);\n            }\n        }\n        \n        if(int(plus.size())%2==1){\n            ll ans1=ans,ans2=ans;\n            ans1-=*plus.begin();\n            ans2+=*minus.rbegin();\n            \n            cout<<max(ans1,ans2)<<endl;\n        }else cout<<ans<<endl;\n        \n        Q--;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n#define EPS (1e-7)\n#define INF (1e16)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstruct SegmentTree {\nprivate:\n    int n;\n    vector<ll> node_plus;\n    vector<ll> node_minus;\n \npublic:\n    SegmentTree() {\n        int sz = 200005;\n        n = 1; while(n < sz) n *= 2;\n        node_plus.resize(2*n-1, INF);\n        node_minus.resize(2*n-1, -INF);\n        for(int i = 0; i < node_plus.size(); i++){\n            node_plus[i] = INF;\n            node_minus[i] = -INF;\n        }\n    }\n \n    void update(int x, ll val) {\n        x += (n - 1);\n        if(val >= 0){\n            node_minus[x] = -INF;\n            node_plus[x] = val;\n        } else {\n            node_minus[x] = val;\n            node_plus[x] = INF;\n        }\n        while(x > 0) {\n            x = (x - 1) / 2;\n            node_minus[x] = max(node_minus[2*x+1], node_minus[2*x+2]);\n            node_plus[x] = min(node_plus[2*x+1], node_plus[2*x+2]);\n            //node[x] = min(node[2*x+1], node[2*x+2]);\n        }\n    }\n    // hannkaikukann \n    ll getminus(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return -INF;\n        if(a <= l && r <= b) return node_minus[k];\n \n        ll vl = getminus(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getminus(a, b, 2*k+2, (l+r)/2, r);\n        return max(vl, vr);\n    }\n    ll getplus(int a, int b, int k=0, int l=0, int r=-1) {\n        if(r < 0) r = n;\n        if(r <= a || b <= l) return INF;\n        if(a <= l && r <= b) return node_plus[k];\n \n        ll vl = getplus(a, b, 2*k+1, l, (l+r)/2);\n        ll vr = getplus(a, b, 2*k+2, (l+r)/2, r);\n        return min(vl, vr);\n    }\n};\n\n\nint main() {\n    //cout.precision(10);\n    SegmentTree seg;\n    int n, q;\n    cin >> n >> q;\n    ll a[200500];\n    ll b[200500];\n    ll asum = 0;\n    for(int i = 1; i <= 2 * n; i++){\n        cin >> a[i];\n        asum += a[i];\n    }\n    for(int i = 1; i <= 2 * n; i++){\n        cin >> b[i];\n    }\n    ll ans = asum;\n    ll checker = 0;\n    for(int i = 2; i < 2 * n; i++){\n        ll delta = b[i] - a[i];\n        if(delta > 0){\n            ans += delta;\n            checker++;\n        }\n        \n        seg.update(i, delta);\n    }\n    for(int time = 0; time < q; time++){\n        int p;\n        ll x, y;\n        cin >> p >> x >> y;\n        ans = ans - a[p] + x;\n        ll before = b[p] - a[p];\n        ll after = y - x;\n        a[p] = x;\n        b[p] = y;\n        ans = ans - max((ll)0, before) + max((ll)0, after);\n        if((before > 0) && (after <= 0)){\n            checker--;\n        }\n        if((before <= 0) && (after > 0)){\n            checker++;\n        }\n        seg.update(p, after);\n        if(checker % 2 == 0){\n            cout << ans << endl;\n            continue;\n        }\n        cout << ans - min(-seg.getminus(1, 2 * n), seg.getplus(1, 2 * n)) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,m,n) for(int i = (m); i < (n); i++)\n#define rrep(i,m,n) for(int i = (m); i >= (n); i--)\n#define print(x) cout << (x) << endl;\n#define print2(x,y) cout << (x) << \" \" << (y) << endl;\n#define printa(x,n) for(int i = 0; i < n; i++){ cout << (x[i]) << \" \\n\"[i == n-1];}\n#define printp(x,n) for(int i = 0; i < n; i++){ cout << \"(\" << x[i].first << \", \" << x[i].second << \") \"; } cout << endl;\n#define INF (1e18)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\ntypedef pair<ll, ll> lpair;\nbool check(string s){\n    bool ok = true;\n    ll N = s.size();\n    ll lv = 0, rv = 0;\n    rep(i,0,N){\n        if(s[i] == '('){\n            lv++;\n        }else{\n            if(lv > 0){\n                lv--;\n            }else{\n                return false;\n            }\n        }\n    }\n    if(lv == 0){\n        return true;\n    }else{\n        return false;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N,Q;\n    ll a[200010], b[200010];\n    ll p[100010], x[100010], y[100010];\n    cin >> N >> Q;\n    rep(i,0,2*N) cin >> a[i];\n    rep(i,0,2*N) cin >> b[i];\n    rep(i,0,Q) cin >> p[i] >> x[i] >> y[i];\n    if(N > 5 || Q > 10) return 0;\n    rep(tt,0,Q){\n        p[tt]--;\n        ll a1 = a[p[tt]]; ll b1 = b[p[tt]];\n        a[p[tt]] = x[tt]; b[p[tt]] = y[tt];\n        ll ans = 0;\n        rep(i,0,pow(2,2*N)){\n            rep(j,0,pow(2,2*N)){\n                ll ans_tmp = 0;\n                string s = \"\", t = \"\";\n                rep(k,0,2*N){\n                    if((i>>k) & 1){\n                        s += '(';\n                    }else{\n                        s += ')';\n                    }\n                }\n                rep(k,0,2*N){\n                    if((j>>k) & 1){\n                        t += '(';\n                    }else{\n                        t += ')';\n                    }\n                }\n                if(!check(s) || !check(t)) continue;\n                rep(k,0,2*N){\n                    if(s[k] == t[k]){\n                        ans_tmp += a[k];\n                    }else{\n                        ans_tmp += b[k];\n                    }\n                }\n                ans = max(ans, ans_tmp); \n            }\n        }\n        print(ans);\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<cstdlib>\n#define ll long long\nusing namespace std;\n\nconst int N=200005;\n\nstruct ST{\n\tint l,r;\n\tll a,b;\n}t[N<<2];\nint n,T,p,x,y;\nint a[N],b[N];\n\nvoid update(int k){\n\tt[k].a=max(t[k<<1].a+t[k<<1|1].a,t[k<<1].b+t[k<<1|1].b);\n\tt[k].b=max(t[k<<1].a+t[k<<1|1].b,t[k<<1].b+t[k<<1|1].a);\n}\n\nvoid build(int k,int l,int r){\n\tt[k].l=l; t[k].r=r;\n\tif (l==r){\n\t\tt[k].a=1ll*a[l];\n\t\tt[k].b=1ll*b[l];\n\t\treturn;\n\t}\n\tint mid=(l+r)>>1;\n\tbuild(k<<1,l,mid);\n\tbuild(k<<1|1,mid+1,r);\n\tupdate(k);\n}\n\nvoid modify(int k,int p){\n\tif (t[k].l==t[k].r){\n\t\tt[k].a=1ll*a[p];\n\t\tt[k].b=1ll*b[p];\n\t\treturn;\n\t}\n\tint mid=(t[k].l+t[k].r)>>1;\n\tif (p<=mid) modify(k<<1,p);\n\telse modify(k<<1|1,p);\n\tupdate(k);\n}\n\nint main(){\n\tint i;\n\tscanf(\"%d%d\",&n,&T);\n\tn<<=1;\n\tfor (i=1;i<=n;i++) scanf(\"%d\",&a[i]);\n\tfor (i=1;i<=n;i++) scanf(\"%d\",&b[i]);\n\tif (n==2){\n\t\twhile (T--){\n\t\t\tscanf(\"%d%d%d\",&p,&x,&y);\n\t\t\ta[p]=x; b[p]=y;\n\t\t\tprintf(\"%d\\n\",a[1]+a[2]);\n\t\t}\n\t\treturn 0;\n\t}\n\tbuild(1,2,n-1);\n\twhile (T--){\n\t\tscanf(\"%d%d%d\",&p,&x,&y);\n\t\ta[p]=x; b[p]=y;\n\t\tif (p>1&&p<n) modify(1,p);\n\t\tprintf(\"%lld\\n\",t[1].a+1ll*(a[1]+a[n]));\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, Q, p, x, y, a[200009], b[200009];\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 0; i < 2 * N; i++) cin >> a[i];\n\tfor (int i = 0; i < 2 * N; i++) cin >> b[i];\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> p >> x >> y; p--;\n\t\ta[p] = x;\n\t\tb[p] = y;\n\t\tint bc = 0, bm = 2012345678;\n\t\tlong long ret = a[0] + a[2 * N - 1];\n\t\tfor (int j = 1; j < 2 * N - 1; j++) {\n\t\t\tret += max(a[j], b[j]);\n\t\t\tif (a[j] < b[j]) {\n\t\t\t\tbc++;\n\t\t\t\tbm = min(bm, b[j] - a[j]);\n\t\t\t}\n\t\t}\n\t\tcout << ret - (bc & 1 ? bm : 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\n//segment tree size==2^0+...+2^18==524287\nlong long a[200000], st[524287], d[524287];\n\nlong long max(long long a, long long b){\n\treturn a < b ? b : a;\n}\n\n//O(n+qlogn)...stを作るのにdpの2倍ほど時間がかかる\nint main() {\n\t\n\tint n, q, i, j, p;\n\tlong long x, y;\n\tlong long suma=0;\n\n\tscanf(\"%d%d\", &n, &q);\n\n\t//start=segment treeの最下段の始まる位置=segment treeの最下段の長さ-1\n\tint start = 2;\n\tfor (i = n - 2; i > 0; i = i / 2) {\n\t\tstart = start * 2;\n\t}\n\tstart--;\n\t\n\t//初期値の代入\n\tfor (i = 0; i < 2 * n; i++) {\n\t\tscanf(\"%lld\", &a[i]);\n\t\tsuma += a[i];\n\t}\n\tscanf(\"%lld\", &y);\n\tfor (i = start; i < start + 2 * n - 2; i++) {\n\t\tscanf(\"%lld\", &y);\n\t\td[i] = y - a[i - start + 1];\n\t}\n\tscanf(\"%lld\", &y);\n\tfor (i = start + 2 * n - 2; i <= 2 * start; i++) {\n\t\td[i] = -1000000000000000;\n\t}\n\tfor (i = start; i <= start + 2 * n - 1; i++) {\n\t\tst[i] = 0;\n\t}\n\n\t//segment treeの作成\n\tfor (i = start - 1; i >= 0; i--) {\n\t\tst[i] = max(st[2 * i + 1] + st[2 * i + 2], d[2 * i + 1] + d[2 * i + 2]);\n\t\td[i] = max(st[2 * i + 1] + d[2 * i + 2], st[2 * i + 2] + d[2 * i + 1]);\n\t}\n\t\n\tfor (i = 0; i < q; i++) {\n\t\tscanf(\"%d%lld%lld\", &p, &x, &y);\n\t\tsuma += x - a[p - 1];\n\t\ta[p - 1] = x;\n\t\tif (p != 1 && p != 2 * n) {\n\t\t\tj = start + p - 2;\n\t\t\td[j] = y - x;\n\t\t\tdo {\n\t\t\t\tj = (j - 1) / 2;\n\t\t\t\tst[j] = max(st[2 * j + 1] + st[2 * j + 2], d[2 * j + 1] + d[2 * j + 2]);\n\t\t\t\td[j] = max(st[2 * j + 1] + d[2 * j + 2], st[2 * j + 2] + d[2 * j + 1]);\n\t\t\t} while (j > 0);\n\t\t}\n\t\tprintf(\"%lld\\n\", suma + st[0]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<::std::uint_fast64_t mod>\nclass ModInt{\nprivate:\n    using value_type = ::std::uint_fast64_t;\n    value_type n;\npublic:\n    ModInt() : n(0) {}\n    ModInt(value_type n_) : n(n_ % mod) {}\n    ModInt(const ModInt& m) : n(m.n) {}\n\n    template<typename T>\n    explicit operator T() const { return static_cast<T>(n); }\n    value_type get() const { return n; }\n\n    friend ::std::ostream& operator<<(::std::ostream &os, const ModInt<mod> &a) {\n        return os << a.n;\n    }\n\n    friend ::std::istream& operator>>(::std::istream &is, ModInt<mod> &a) {\n        value_type x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return is;\n    }\n\n    bool operator==(const ModInt& m) const { return n == m.n; }\n    bool operator!=(const ModInt& m) const { return n != m.n; }\n    ModInt& operator*=(const ModInt& m){ n = n * m.n % mod; return *this; }\n\n    ModInt pow(value_type b) const{\n        ModInt ans = 1, m = ModInt(*this);\n        while(b){\n            if(b & 1) ans *= m;\n            m *= m;\n            b >>= 1;\n        }\n        return ans;\n    }\n\n    ModInt inv() const { return (*this).pow(mod-2); }\n    ModInt& operator+=(const ModInt& m){ n += m.n; n = (n < mod ? n : n - mod); return *this; }\n    ModInt& operator-=(const ModInt& m){ n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n    ModInt& operator/=(const ModInt& m){ *this *= m.inv(); return *this; }\n    ModInt operator+(const ModInt& m) const { return ModInt(*this) += m; }\n    ModInt operator-(const ModInt& m) const { return ModInt(*this) -= m; }\n    ModInt operator*(const ModInt& m) const { return ModInt(*this) *= m; }\n    ModInt operator/(const ModInt& m) const { return ModInt(*this) /= m; }\n    ModInt& operator++(){ n += 1; return *this; }\n    ModInt& operator--(){ n -= 1; return *this; }\n    ModInt operator++(int){\n        ModInt old(n);\n        n += 1;\n        return old;\n    }\n    ModInt operator--(int){\n        ModInt old(n);\n        n -= 1;\n        return old;\n    }\n    ModInt operator-() const { return ModInt(mod-n); }\n};\n\nclass UnionFind{\nprivate:\n    ::std::vector<int_fast32_t> par;\n    vector<int64> sum;\n    size_t n;\n\npublic:\n    UnionFind(){}\n    UnionFind(size_t n):n(n){\n        par.resize(n, -1);\n        sum.resize(n, 0);\n    }\n\n    void set_sum(const vector<int64>& s) {\n        sum = s;\n    }\n\n    uint_fast32_t find(uint_fast32_t x){\n        return par[x] < 0 ? x : par[x] = find(par[x]);\n    }\n\n    size_t size(uint_fast32_t x){\n        return -par[find(x)];\n    }\n\n    int64 sum_v(int64 x) {\n        return sum[find(x)];\n    }\n\n    bool unite(uint_fast32_t x, uint_fast32_t y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return false;\n        if(size(x) < size(y)) std::swap(x, y);\n        par[x] += par[y];\n        sum[x] += sum[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool same(uint_fast32_t x, uint_fast32_t y){\n        return find(x) == find(y);\n    }\n};\n\n\n\nint main(void) {\n    int64 N, Q;\n    cin >> N >> Q;\n    N*=2;\n    vector<int64> a(N), b(N);\n    REP(i, N) cin >> a[i];\n    REP(i, N) cin >> b[i];\n    multiset<PLL> as, bs;\n    vector<int64> wh(N);\n    int64 res = a[0] + a.back();\n    FOR(i, 1, N-1) {\n        if (a[i] >= b[i]) {\n            as.insert(PLL(a[i]-b[i], i));\n            res += a[i];\n            wh[i] = 0;\n        } else {\n            bs.insert(PLL(b[i]-a[i], i));\n            res += b[i];\n            wh[i] = 1;\n        }\n    }\n    REP(i, Q) {\n//        cout << endl;\n        int64 p, x, y;\n        cin >> p >> x >> y; p--;\n        bool atob = 0, btoa = 0;\n        if (p == 0 || p == N-1) {\n            res -= a[p];\n            a[p] = x; b[p] = y;\n            res += a[p];\n        } else {\n            if (wh[p] == 0) {\n                res -= a[p];\n                as.erase(as.lower_bound(PLL(a[p]-b[p], p)));\n            } else {\n                res -= b[p];\n                bs.erase(bs.lower_bound(PLL(b[p]-a[p], p)));\n            }\n            a[p] = x; b[p] = y;\n            if (a[p] >= b[p]) {\n                res += a[p];\n                wh[p] = 0;\n                as.insert(PLL(a[p]-b[p], p));\n            } else {\n                res += b[p];\n                wh[p] = 1;\n                bs.insert(PLL(b[p]-a[p], p));\n            }\n//            cout << res << endl;\n            if (as.size() % 2) {\n                auto ia = *as.begin(), ib = *bs.begin();\n                if (ia.fs >= ib.fs) {\n                    res -= ib.fs;\n                    wh[ib.sc] = 0;\n                    as.insert(PLL(-ib.fs, ib.sc));\n                    bs.erase(bs.begin());\n                    btoa = 1;\n                } else {\n                    res -= ia.fs;\n                    wh[ia.sc] = 1;\n                    bs.insert(PLL(-ia.fs, ia.sc));\n                    as.erase(as.begin());\n                    atob = 1;\n                }\n            }\n        }\n//        for (auto x : as) {\n//            cout << x.fs << \" \";\n//        }\n//        cout << endl;\n//        for (auto x : bs) {\n//            cout << x.fs << \" \";\n//        }\n//        cout << endl;\n        cout << res << endl;\n        if (atob) {\n            auto b = *bs.begin();\n            wh[b.sc] = 0;\n            res -= b.fs;\n            as.insert(PLL(-b.fs, b.sc));\n            bs.erase(bs.begin());\n        } else if (btoa) {\n            auto b = *as.begin();\n            wh[b.sc] = 1;\n            res -= b.fs;\n            bs.insert(PLL(-b.fs, b.sc));\n            as.erase(as.begin());\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'[';\n    for(const T &i: a) out<<i<<',';\n    out<<']';\n    return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out, const set<T>& a) {\n    out<<'{';\n    for(const T &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\ntemplate<class T, class S>\nostream &operator <<(ostream& out, const map<T,S>& a) {\n    out<<'{';\n    for(auto &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n, q;\n    cin >> n >> q;\n    n *= 2;\n    vector<ll> a(n), b(n);\n    REP(i, n) cin >> a[i];\n    REP(i, n) cin >> b[i];\n\n    ll suma = 0;\n    REP(i, n) suma += a[i];\n\n    ll sum = 0, cnt = 0;\n    multiset<ll> st1, st2;\n    FOR(i, 1, n-1) {\n        if(b[i]-a[i] > 0) {\n            sum += b[i]-a[i];\n            cnt++;\n            st1.insert(b[i]-a[i]);\n        } else {\n            st2.insert(b[i]-a[i]);\n        }\n    }\n    // cout << sum << \" \" << cnt << \" \" << st1 << \" \" << st2 << endl;\n\n    REP(i, q) {\n        ll p, x, y;\n        cin >> p >> x >> y; p--;\n\n        if(0 < p && p < n-1) {\n            if(b[p]-a[p] > 0) {\n                sum -= b[p]-a[p];\n                cnt--;\n                auto itr = st1.find(b[p]-a[p]);\n                st1.erase(itr);\n            } else {\n                auto itr = st2.find(b[p]-a[p]);\n                st2.erase(itr);\n            }\n        }\n        suma -= a[p];\n\n        a[p] = x;\n        b[p] = y;\n        if(0 < p && p < n-1) {\n            if(b[p]-a[p] > 0) {\n                sum += b[p]-a[p];\n                cnt++;\n                st1.insert(b[p]-a[p]);\n            } else {\n                st2.insert(b[p]-a[p]);\n            }\n        }\n        suma += a[p];\n\n        if(cnt%2==0) cout << suma + sum << endl;\n        else cout << max(suma + sum + *st2.begin(), suma + sum - *st1.begin()) << endl;\n    }\n\n    // ll n;\n    // cin >> n;\n    //\n    // vector<ll> a;\n    // REP(i, 1LL<<n) {\n    //     bool flag = true;\n    //     ll sum = 0;\n    //     REP(j, n) {\n    //         sum += (i&1LL<<j)?1:-1;\n    //         if(sum < 0) {\n    //             flag = false;\n    //             break;\n    //         }\n    //     }\n    //     if(sum != 0) flag = false;\n    //     if(flag) a.push_back(i);\n    // }\n    // // cout << a << endl;\n    //\n    // ll m = a.size();\n    // set<vector<ll>> st;\n    // REP(i, m) FOR(j, i+1, m) {\n    //     vector<ll> diff;\n    //     REP(k, n) {\n    //         if((a[i]&1LL<<k) != (a[j]&1LL<<k)) {\n    //             diff.push_back(k);\n    //         }\n    //     }\n    //     st.insert(diff);\n    // }\n    // cout << st << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n\nint main(){\n    int n;\n    int q;\n    cin>>n>>q;\n\n    vector<ll> a(2*n),b(2*n);\n    for(int i=0;i<2*n;i++) cin>>a[i];\n    for(int i=0;i<2*n;i++) cin>>b[i];\n    \n    ll psum=0;\n    ll bsum=0;\n    multiset<ll> ps;\n    multiset<ll> ns;\n    for(int i=1;i<2*n-1;i++){\n        bsum+=b[i];\n        if(a[i]-b[i]>=0){\n            ps.insert(a[i]-b[i]);\n            psum+=a[i]-b[i];\n        }\n        else ns.insert(a[i]-b[i]);\n    }\n    \n    while(q--){\n        int p;\n        ll ax,bx;\n        cin>>p>>ax>>bx;\n        p--;\n        if(p==0 || p==2*n-1){\n            a[p]=ax;\n            b[p]=bx;\n        }\n        else{\n            bsum+=bx-b[p];\n            if(a[p]-b[p]>=0){\n                ps.erase(ps.find(a[p]-b[p]));\n                psum-=a[p]-b[p];\n            }\n            else{\n                ns.erase(ns.find(a[p]-b[p]));\n            }\n            a[p]=ax,b[p]=bx;\n            if(a[p]-b[p]>=0){\n                ps.insert(a[p]-b[p]);\n                psum+=a[p]-b[p];\n            }\n            else ns.insert(a[p]-b[p]);\n        }\n        if(n==1){\n            cout<<a[0]+a[1]<<endl;\n        }\n        else if(ns.size()%2){\n            ll vp=*ps.begin();\n            ll vn=*(--ns.end());\n            cout<<a[0]+a[2*n-1]+bsum+psum+max(-vp,vn)<<endl;\n        }   \n        else{\n            cout<<a[0]+a[2*n-1]+psum+bsum<<endl;\n        }                 \n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sp ' '\n#define mkp make_pair\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define lP pair<ll,ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\nconst int mod = 1000000007, mod998 = 998244353;\nconst string nyan(\"(=^・ω・^=)\");\n\nint N, Q, a[100000], b[100000], p, x, y;\nbool u[100000];\nset<pair<int, int>>st[2];\nll res;\n\nint main() {\n\tcin >> N >> Q;\n\tN <<= 1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> b[i];\n\t}\n\t--Q;\n\tcin >> p >> x >> y;\n\t--p;\n\ta[p] = x;\n\tb[p] = y;\n\tres = a[0] + a[N - 1];\n\tfor (int i = 1; i < N - 1; ++i) {\n\t\tif (a[i] >= b[i]) {\n\t\t\tu[i] = true;\n\t\t\tres += a[i];\n\t\t\tst[1].insert(mkp(a[i] - b[i], i));\n\t\t}\n\t\telse {\n\t\t\tres += b[i];\n\t\t\tst[0].insert(mkp(b[i] - a[i], i));\n\t\t}\n\t}\n\tif (st[0].size() & 1) {\n\t\tif (st[0].begin()->first > st[1].begin()->first) {\n\t\t\tres -= st[1].begin()->first;\n\t\t\tu[st[1].begin()->second] ^= true;\n\t\t\tst[0].insert(mkp(-st[1].begin()->first, st[1].begin()->second));\n\t\t\tst[1].erase(st[1].begin());\n\t\t}\n\t\telse {\n\t\t\tres -= st[0].begin()->first;\n\t\t\tu[st[0].begin()->second] ^= true;\n\t\t\tst[1].insert(mkp(-st[0].begin()->first, st[0].begin()->second));\n\t\t\tst[0].erase(st[0].begin());\n\t\t}\n\t}\n\tcout << res << endl;\n\twhile (Q--) {\n\t\tcin >> p >> x >> y;\n\t\t--p;\n\t\tif (p == 0 || p == N - 1) {\n\t\t\tres += x - a[p];\n\t\t\ta[p] = x;\n\t\t}\n\t\telse {\n\t\t\tif (u[p]) {\n\t\t\t\tres += x - a[p];\n\t\t\t\tst[1].erase(mkp(a[p] - b[p], p));\n\t\t\t\tst[1].insert(mkp(x - y, p));\n\t\t\t\tauto it = st[1].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[0].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[1].erase(p1);\n\t\t\t\t\tst[1].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres += y - b[p];\n\t\t\t\tst[0].erase(mkp(b[p] - a[p], p));\n\t\t\t\tst[0].insert(mkp(y - x, p));\n\t\t\t\tauto it = st[0].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[1].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tst[0].erase(p1);\n\t\t\t\t\tst[0].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!st[0].empty() && !st[1].empty() && st[0].begin()->first + st[1].begin()->first < 0) {\n\t\t\t\tpair<int, int> p1 = *st[0].begin();\n\t\t\t\tpair<int, int> p2 = *st[1].begin();\n\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\tu[p1.second] ^= true;\n\t\t\t\tu[p2.second] ^= true;\n\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\tst[0].erase(p1);\n\t\t\t\tst[1].erase(p2);\n\t\t\t}\n\t\t\ta[p] = x;\n\t\t\tb[p] = y;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sp ' '\n#define mkp make_pair\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define lP pair<ll,ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\nconst int mod = 1000000007, mod998 = 998244353;\nconst string nyan(\"(=^・ω・^=)\");\n\nint N, Q, a[200000], b[200000], p, x, y;\nbool u[200000];\nset<pair<int, int>>st[2];\nll res;\n\nint main() {\n\tcin >> N >> Q;\n\t--Q;\n\tN *= 2;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> b[i];\n\t}\n\tcin >> p >> x >> y;\n\t--p;\n\ta[p] = x;\n\tb[p] = y;\n\tres = a[0] + a[N - 1];\n\tfor (int i = 1; i < N - 1; ++i) {\n\t\tif (a[i] >= b[i]) {\n\t\t\tu[i] = true;\n\t\t\tres += a[i];\n\t\t\tst[1].insert(mkp(a[i] - b[i], i));\n\t\t}\n\t\telse {\n\t\t\tres += b[i];\n\t\t\tst[0].insert(mkp(b[i] - a[i], i));\n\t\t}\n\t}\n\tif (st[0].size() & 1) {\n\t\tpair<int, int>p1, p2;\n\t\tp1 = *st[0].begin();\n\t\tp2 = *st[1].begin();\n\t\tif (p1.first > p2.first) {\n\t\t\tres -= p2.first;\n\t\t\tu[p2.second] ^= true;\n\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\tst[1].erase(p2);\n\t\t}\n\t\telse {\n\t\t\tres -= p1.first;\n\t\t\tu[p1.second] ^= true;\n\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\tst[0].erase(p1);\n\t\t}\n\t}\n\tcout << res << endl;\n\twhile (Q--) {\n\t\tcin >> p >> x >> y;\n\t\t--p;\n\t\tif (p == 0 || p == N - 1) {\n\t\t\tres += x - a[p];\n\t\t\ta[p] = x;\n\t\t}\n\t\telse {\n\t\t\tif (u[p]) {\n\t\t\t\tres += x - a[p];\n\t\t\t\tst[1].erase(mkp(a[p] - b[p], p));\n\t\t\t\tst[1].insert(mkp(x - y, p));\n\t\t\t\tauto it = st[1].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[0].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[1].erase(p1);\n\t\t\t\t\tst[1].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres += y - b[p];\n\t\t\t\tst[0].erase(mkp(b[p] - a[p], p));\n\t\t\t\tst[0].insert(mkp(y - x, p));\n\t\t\t\tauto it = st[0].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[1].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[0].erase(p1);\n\t\t\t\t\tst[0].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!st[0].empty() && !st[1].empty() && st[0].begin()->first + st[1].begin()->first < 0) {\n\t\t\t\tpair<int, int> p1 = *st[0].begin();\n\t\t\t\tpair<int, int> p2 = *st[1].begin();\n\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\tu[p1.second] ^= true;\n\t\t\t\tu[p2.second] ^= true;\n\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\tst[0].erase(p1);\n\t\t\t\tst[1].erase(p2);\n\t\t\t}\n\t\t\ta[p] = x;\n\t\t\tb[p] = y;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<class ValueMonoid, template<class...> class Container=::std::vector>\nclass SegTree{\npublic:\n    using value_structure = ValueMonoid;\n    using value_type = typename value_structure::value_type;\n    using const_reference = const value_type &;\n    using container_type = Container<value_type>;\n    using size_type = typename container_type::size_type;\n\nprivate:\n    ::std::vector<value_type> tree;\n    size_type size_;\n\n    static size_type getsize(const size_type x){\n        size_type ret = 1;\n        while(ret < x)\n            ret <<= 1;\n        return ret;\n    }\n\n    inline value_type calc(const value_type a, const value_type b){\n        return value_structure::operation(a, b);\n    }\n\n    inline void calc_node(const size_type index){\n        if(tree.size() <= (index << 1 | 1)) return;\n        tree[index] = value_structure::operation(tree[index<<1], tree[index<<1 | 1]);\n    }\npublic:\n    SegTree() : size_(0), tree(){}\n    SegTree(const size_type size)\n            : size_(size), tree(size << 1, value_structure::identity()){}\n    template<class InputIterator>\n    SegTree(InputIterator first, InputIterator last)\n            : size_(::std::distance(first, last)){\n        tree = container_type(size_, value_structure::identity());\n        tree.insert(tree.end(), first, last);\n        for(size_type i = size_;i > 0;i--){\n            calc_node(i);\n        }\n    }\n\n    size_type size() const { return size_; }\n    const_reference operator[](const size_type k) const {\n        assert(k < size_);\n        return tree[k+size_];\n    }\n\n    value_type query(size_type l, size_type r){\n        assert(l <= r);\n        assert(0 <= l && l < size_);\n        assert(0 <= r && r <= size_);\n        value_type retl = value_structure::identity(), retr = value_structure::identity();\n        for(l += size_, r += size_; l < r ; l >>= 1, r >>= 1){\n            if(l&1) retl = calc(retl, tree[l++]);\n            if(r&1) retr = calc(tree[--r], retr);\n        }\n        return calc(retl, retr);\n    }\n\n    template<class F>\n    void update(size_type index, const F& f){\n        assert(0 <= index && index < size());\n        index += size_;\n        tree[index] = f(::std::move(tree[index]));\n        while(index >>= 1)\n            calc_node(index);\n    }\n\n    /*\n    template<class F>\n    size_type search(const F& f) const { // [0, result) is True and [0, result-1) is not.\n        if(f(value_structure::identity()))\n            return 0;\n        if(!f(tree[1]))\n            return size_+1;\n        value_type acc = value_structure::identity();\n        size_type i = 1;\n        while(i <\n    }\n    */\n};\n\nclass v_monoid {\npublic:\n    using value_type = PLL;\n    static value_type identity() { return PLL(-INF_LL, -INF_LL); }\n    static value_type initializer() { return {-INF_LL, -INF_LL}; }\n    static value_type operation(const value_type& a, const value_type& b) {\n        if (a == identity()) return b;\n        if (b == identity()) return a;\n        return {max(a.fs+b.fs, a.sc+b.sc), max(a.fs+b.sc, a.sc+b.fs)};\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree{\n    using F = function<T(T,T)>;\n    int n;\n    F f;\n    T ti;\n    vector<T> dat;\n    SegmentTree(){};\n    SegmentTree(F f,T ti):f(f),ti(ti){}\n    void init(int n_){\n        n=1;\n        while(n<n_) n<<=1;\n        dat.assign(n<<1,ti);\n    }\n    void build(const vector<T> &v){\n        int n_=v.size();\n        init(n_);\n        for(int i=0;i<n_;i++) dat[n+i]=v[i];\n        for(int i=n-1;i;i--)\n            dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n    }\n    void set_val(int k,T x){\n        dat[k+=n]=x;\n        while(k>>=1)\n            dat[k]=f(dat[(k<<1)|0],dat[(k<<1)|1]);\n    }\n    T query(int a,int b){\n        T vl=ti,vr=ti;\n        for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n            if(l&1) vl=f(vl,dat[l++]);\n            if(r&1) vr=f(dat[--r],vr);\n        }\n        return f(vl,vr);\n    }\n    template<typename C>\n    int find(int st,C &check,T &acc,int k,int l,int r){\n        if(l+1==r){\n            acc=f(acc,dat[k]);\n            return check(acc)?k-n:-1;\n        }\n        int m=(l+r)>>1;\n        if(m<=st) return find(st,check,acc,(k<<1)|1,m,r);\n        if(st<=l&&!check(f(acc,dat[k]))){\n            acc=f(acc,dat[k]);\n            return -1;\n        }\n        int vl=find(st,check,acc,(k<<1)|0,l,m);\n        if(~vl) return vl;\n        return find(st,check,acc,(k<<1)|1,m,r);\n    }\n    template<typename C>\n    int find(int st,C &check){\n        T acc=ti;\n        return find(st,check,acc,1,0,n);\n    }\n};\n\n\nint main(void) {\n    int64 N, Q;\n    cin >> N >> Q;\n    N *= 2;\n    vector<int64> a(N), b(N);\n    REP(i, N) cin >> a[i];\n    REP(i, N) cin >> b[i];\n    int64 res = a[0] + a.back();\n    SegTree<v_monoid> sg(N);\n    FOR(i, 1, N-1) {\n        sg.update(i, [&](const PLL x) { return PLL(a[i], b[i]); });\n    }\n    REP(i, Q) {\n        int64 p, x, y;\n        cin >> p >> x >> y; p--;\n        assert(p != 0 && p != N-1);\n        if (p == 0 || p == N-1) {\n            res -= a[p]; res += x;\n            a[p] = x;\n        } else {\n            sg.update(p, [&](const PLL alskdj) { return PLL(x, y); });\n        }\n        cout << res + sg.query(1, N).fs << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\npair<long long, long long> datas[500000];\nlong long erased[500000];\nlong long itr[500000];\nint main() {\n\tiostream::sync_with_stdio(false);\n#define int long long\n\tint n, query;\n\tcin >> n >> query;\n\tREP(i, 2 * n) {\n\t\tcin >> datas[i].first;\n\t}\n\tREP(i, 2 * n) {\n\t\tcin >> datas[i].second;\n\t}\n\tREP(i, 2 * n) {\n\t\titr[i] = i;\n\t}\n\tpriority_queue<pair<long long,long long>> next_loser;\n\tpriority_queue<pair<long long, long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>> next_winner;\n\tlong long now_ans = 0;\n\tnow_ans += datas[0].first;\n\tnow_ans += datas[2 * n - 1].first;\n\tlong long now_cnt = 0;\n\tfor (int i = 1; i < 2 * n - 1; ++i) {\n\t\tnow_ans += datas[i].second;\n\t\tlong long geko = datas[i].first - datas[i].second;\n\t\tif (geko >= 0) {\n\t\t\tnow_cnt++;\n\t\t\tnext_winner.push(make_pair(geko, i));\n\t\t\tnow_ans += geko;\n\t\t}\n\t\telse {\n\t\t\tnext_loser.push(make_pair(geko, i));\n\t\t}\n\t}\n\tint next_move = 2 * n;\n\tREP(i, query) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;\n\t\tif (a == 0 || a == 2 * n - 1) {\n\t\t\tnow_ans -= datas[a].first;\n\t\t\tnow_ans += b;\n\t\t\tdatas[a] = make_pair(b, c);\n\n\t\t}\n\t\telse {\n\t\t\t//First We need To remove\n\t\t\t{\n\t\t\t\tint data_itr = itr[a];\n\t\t\t\terased[data_itr] = 1;\n\t\t\t\tnow_ans -= datas[data_itr].second;\n\t\t\t\tint diff = datas[data_itr].first - datas[data_itr].second;\n\t\t\t\tif (diff >= 0) {\n\t\t\t\t\tnow_cnt--;\n\t\t\t\t\tnow_ans -= diff;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//nothing\n\t\t\t\t}\n\t\t\t\tdatas[data_itr] = make_pair(0, 0);\n\t\t\t\twhile (next_winner.empty() == false && erased[next_winner.top().second] == 1) {\n\t\t\t\t\tnext_winner.pop();\n\t\t\t\t}\n\t\t\t\twhile (next_loser.empty() == false && erased[next_loser.top().second] == 1) {\n\t\t\t\t\tnext_loser.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tlong long data_itr = next_move;\n\t\t\t\tnext_move++;\n\t\t\t\titr[a] = data_itr;\n\t\t\t\tdatas[data_itr] = make_pair(b, c);\n\t\t\t\tnow_ans += datas[data_itr].second;\n\t\t\t\tlong long diff = datas[data_itr].first - datas[data_itr].second;\n\t\t\t\tif (diff >= 0) {\n\t\t\t\t\tnow_cnt++;\n\t\t\t\t\tnow_ans += diff;\n\t\t\t\t\tnext_winner.push(make_pair(diff, data_itr));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t//nothing\n\t\t\t\t\tnext_loser.push(make_pair(diff, data_itr));\n\t\t\t\t}\n\t\t\t\t//OK!\n\t\t\t}\n\t\t}\n\t\tif (now_cnt % 2 == 0) {\n\t\t\tcout << now_ans << endl;\n\t\t}\n\t\telse {\n\t\t\tlong long geko = now_ans - next_winner.top().first;\n\t\t\tif (next_loser.empty() == false) {\n\t\t\t\tgeko = max(geko, now_ans + next_loser.top().first);\n\t\t\t}\n\t\t\tcout << geko << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N,Q;\nint A[111111],B[111111];\n\nsigned main(){\n    scanf(\"%lld%lld\",&N,&Q);\n    N*=2;\n    rep(i,N)scanf(\"%lld\",&A[i]);\n    rep(i,N)scanf(\"%lld\",&B[i]);\n\n    multiset<int>x,y;\n    int sumx=0;\n    int base=accumulate(A,A+N,0ll);\n    for(int i=1;i+1<N;i++){\n        if(A[i]<=B[i]){\n            x.insert(B[i]-A[i]);\n            sumx+=B[i]-A[i];\n        }\n        else{\n            y.insert(B[i]-A[i]);\n        }\n    }\n\n    while(Q--){\n        int p,a,b;\n        scanf(\"%lld%lld%lld\",&p,&a,&b);\n        p--;\n\n        base-=A[p];\n        if(1<=p&&p+1<N){\n            if(A[p]<=B[p]){\n                sumx-=B[p]-A[p];\n                auto it=x.find(B[p]-A[p]);\n                x.erase(it);\n            }\n            else{\n                auto it=y.find(B[p]-A[p]);\n                y.erase(it);\n            }\n        }\n\n        A[p]=a;B[p]=b;\n        base+=A[p];\n        if(1<=p&&p+1<N){\n            if(A[p]<=B[p]){\n                x.insert(B[p]-A[p]);\n                sumx+=B[p]-A[p];\n            }\n            else{\n                y.insert(B[p]-A[p]);\n            }\n        }\n\n        int ans=0;\n        if(x.size()%2==0){\n            ans=sumx;\n        }\n        else{\n            ans=sumx-*x.begin();\n            chmax(ans,sumx+*y.rbegin());\n        }\n        printf(\"%lld\\n\",ans+base);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define FOR(i, n, m) for(int i = n; i < (int)m; i++)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define pb push_back\nusing namespace std;\nusing ll = std::int_fast64_t;\nusing ld = long double;\nusing P = pair<ll, ll>;\nconstexpr ll inf = 1000000000;\nconstexpr ll mod = 1000000007;\nconstexpr long double eps = 1e-15;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& os, pair<T1, T2> p) {\n\tos << to_string(p.first) << \" \" << to_string(p.second);\n\treturn os;\n}\ntemplate<typename T>\nostream& operator<<(ostream& os, vector<T>& v) {\n\tREP(i, v.size()) {\n\t\tif(i) os << \" \";\n\t\tos << to_string(v[i]);\n\t}\n\treturn os;\n}\n\n/*\ntemplate<typename T>\nstruct Treap {\n\tdouble drand() { // random number in [0, 1]\n\t\tstatic random_device rd;\n\t\tstatic mt19937 mt(rd());\n\t\treturn (unsigned)mt() / (double)numeric_limits<unsigned>::max();\n\t}\n\tT v;\n\tdouble p;\n\tint cnt;\n\tTreap* lch;\n\tTreap* rch;\n\tTreap(T v) : v(v), p(drand()), cnt(1), lch(NULL), rch(NULL) { }\n\tTreap* update() {\n\t\tthis->size = size(this->lch) + size(this->rch) + 1;\n\t\treturn this;\n\t}\n\tstatic int size(Treap* t) {\n\t\tif(!t) return 0;\n\t\telse return t->cnt;\n\t}\n\tstatic Treap* merge(Treap* l, Treap* r) {\n\t\tif(!l || !r) {\n\t\t\tif(!l) return r;\n\t\t\telse return l;\n\t\t}\n\t\tif(l->p >= r->p) {\n\t\t\tl->rch = merge(l->rch, r);\n\t\t\treturn l->update();\n\t\t} else {\n\t\t\tr->lch = merge(r->lch, l);\n\t\t\treturn r->update();\n\t\t}\n\t}\n\tstatic pair<Treap*, Treap*> split(Treap* t, int k) {\n\t\t// split [0, k) and [k, n)\n\t\tif(k == 0) return {NULL, t};\n\t\tif(!(t->l)) {\n\t\t\tauto tmp = split(t->r, k - 1);\n\t\t\tt->r = tmp.first;\n\t\t\treturn {t->update(), tmp.second};\n\t\t} else if(!(t->r)) {\n\t\t\tauto tmp = split(t->r, k - 1);\n\t\t\tt->r = tmp.first;\n\t\t\treturn {t->update(), tmp.second};\n\t\t} else {\n\n\t\t}\n\t}\n\tTreap* insert() {\n\t}\n\tTreap* erase() {\n\t}\n\tT operator[](int k) {\n\t}\n};\n*/\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, q;\n\tcin >> n >> q;\n\tvector<ll> a(2 * n), b(2 * n);\n\tREP(i, 2 * n) cin >> a[i];\n\tREP(i, 2 * n) cin >> b[i];\n\tll sum1 = 0, sum2 = 0;\n\tREP(i, 2 * n) sum1 += a[i];\n\tset<pair<ll, ll>> st1;\n\tset<pair<ll, ll>> st2;\n\tFOR(i, 1, 2 * n - 1) {\n\t\tif(b[i] - a[i] >= 0) {\n\t\t\tst1.insert({b[i] - a[i], i});\n\t\t\tsum2 += b[i] - a[i];\n\t\t} else {\n\t\t\tst2.insert({b[i] - a[i], i});\n\t\t}\n\t}\n\tst2.insert({-inf*inf, 0});\n\tREP(i, q) {\n\t\tll p, x, y;\n\t\tcin >> p >> x >> y;\n\t\tp--;\n\t\tsum1 -= a[p]; sum1 += x;\n\t\tif(p != 0 && p != 2 * n - 1) {\n\t\t\tif(b[p] - a[p] >= 0) {\n\t\t\t\tst1.erase({b[p] - a[p], p});\n\t\t\t\tsum2 -= (b[p] - a[p]);\n\t\t\t} else {\n\t\t\t\tst2.erase({b[p] - a[p], p});\n\t\t\t}\n\t\t\tif(y - x >= 0) {\n\t\t\t\tst1.insert({y - x, p});\n\t\t\t\tsum2 += y - x;\n\t\t\t} else {\n\t\t\t\tst2.insert({y - x, p});\n\t\t\t}\n\t\t}\n\t\ta[p] = x; b[p] = y;\n\t\tif((int)st1.size() % 2 == 0) {\n\t\t\tcout << sum1 + sum2 << endl;\n\t\t} else {\n\t\t\tcout << max(sum1 + sum2 - st1.begin()->first,\n\t\t\t\t\t\tsum1 + sum2 + (--st2.end())->first) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n// ---------------------------------------\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <set>\n#include <iostream>\nusing namespace std;\nint main() {\n    int n, q; cin >> n >> q;\n    int a[2*n], b[2*n];\n    long long asum = 0;\n    for (int i = 0; i < 2*n; i++) cin >> a[i], asum += a[i];\n    multiset<int> ds;\n    for (int i = 0; i < 2*n; i++) {\n        cin >> b[i];\n        if (0 < i && i < 2*n-1) ds.insert(b[i] - a[i]);\n    }\n    long long dsum = 0;\n    auto it = ds.lower_bound(1);\n    int c = 0;\n    for (auto it2 = it; it2 != ds.end(); it2++) {\n        c++;\n        dsum += *it2;\n    }\n    while (q--) {\n        int i, x, y; cin >> i >> x >> y;\n        i--;\n        if (0 < i && i < 2*n-1) ds.erase(ds.find(b[i] - a[i]));\n        if (b[i] - a[i] > 0) { dsum -= b[i] - a[i]; c--; }\n        asum += x - a[i];\n        a[i] = x; b[i] = y;\n        if (0 < i && i < 2*n-1) ds.insert(b[i] - a[i]);\n        if (b[i] - a[i] > 0) { dsum += b[i] - a[i]; c++; }\n        long long ans = asum + dsum;\n        if (c % 2) {\n            it = ds.lower_bound(1);\n            if (it != ds.begin() && *it + *prev(it) > 0)\n                ans += *prev(it);\n            else\n                ans -= *it;\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, Q, pos, x, y, a[200009], b[200009]; map<int, int> d;\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcin >> N >> Q;\n\tfor (int i = 0; i < 2 * N; i++) cin >> a[i];\n\tfor (int i = 0; i < 2 * N; i++) cin >> b[i];\n\tlong long s = 0; int c = 0;\n\tfor (int i = 0; i < 2 * N; i++) {\n\t\tif (i == 0 || i == 2 * N - 1) s += a[i];\n\t\telse {\n\t\t\tif (a[i] > b[i]) c++;\n\t\t\ts += max(a[i], b[i]);\n\t\t\td[abs(a[i] - b[i])]++;\n\t\t}\n\t}\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> pos >> x >> y; pos--;\n\t\tif (a[pos] > b[pos]) c--;\n\t\ts -= max(a[pos], b[pos]);\n\t\td[abs(a[pos] - b[pos])]--;\n\t\tif (d[abs(a[pos] - b[pos])] == 0) d.erase(abs(a[pos] - b[pos]));\n\t\ta[pos] = x; b[pos] = y;\n\t\tif (a[pos] > b[pos]) c++;\n\t\ts += max(a[pos], b[pos]);\n\t\td[abs(a[pos] - b[pos])]++;\n\t\tcout << s - (c & 1 ? d.begin()->first : 0) << '\\n';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <functional>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\nlong long n, q, p1, p2, p3, a[200009], b[200009], sum, cnt;\npriority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>>Q;\n\nint main() {\n\tcin >> n >> q;\n\tfor (int i = 1; i <= 2 * n; i++) cin >> a[i];\n\tfor (int i = 1; i <= 2 * n; i++) cin >> b[i];\n\tfor (int i = 1; i <= 2 * n; i++) {\n\t\tif (i == 1)b[i] = -(1LL << 60); if (i == 2 * n) b[i] = -(1LL << 60);\n\t\tsum += max(a[i], b[i]);\n\t\tif (a[i] < b[i]) cnt++;\n\t\tQ.push(make_pair(max(a[i], b[i]) - min(a[i], b[i]), i));\n\t}\n\tfor (int i = 1; i <= q; i++) {\n\t\tcin >> p1 >> p2 >> p3; if (p1 == 1) p3 = -(1LL << 60); if (p1 == 2 * n) p3 = -(1LL << 60);\n\t\tif (a[p1] < b[p1]) cnt--;\n\t\tsum -= max(a[p1], b[p1]);\n\t\ta[p1] = p2; b[p1] = p3;\n\t\tif (a[p1] < b[p1]) cnt++;\n\t\tsum += max(a[p1], b[p1]);\n\t\tQ.push(make_pair(abs(a[p1] - b[p1]), p1));\n\t\twhile (!Q.empty()) {\n\t\t\tlong long cost = Q.top().first, to = Q.top().second;\n\t\t\tlong long V = abs(a[to] - b[to]);\n\t\t\tif (V != cost) Q.pop();\n\t\t\telse break;\n\t\t}\n\t\tif (cnt % 2 == 0) cout << sum << endl;\n\t\telse cout << sum - Q.top().first << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <set>\n#define SIZE 200005\n\nusing namespace std;\ntypedef long long int ll;\n\nll A[SIZE],B[SIZE];\nll sum,all;\nint cnt;\nmultiset <ll> st;\nmultiset <ll>::iterator it;\nint n,q;\n\nvoid ins(int k)\n{\n\tif(k==0||k==n-1)\n\t{\n\t\tall+=A[k];\n\t}\n\telse\n\t{\n\t\tall+=A[k];\n\t\tif(A[k]<B[k])\n\t\t{\n\t\t\tcnt++;\n\t\t\tsum+=B[k]-A[k];\n\t\t}\n\t\tst.insert(B[k]-A[k]);\n\t}\n}\nvoid rem(int k)\n{\n\tif(k==0||k==n-1)\n\t{\n\t\tall-=A[k];\n\t}\n\telse\n\t{\n\t\tall-=A[k];\n\t\tif(A[k]<B[k])\n\t\t{\n\t\t\tcnt--;\n\t\t\tsum-=B[k]-A[k];\n\t\t}\n\t\tit=st.lower_bound(B[k]-A[k]);\n\t\tst.erase(it);\n\t}\n}\nll get_ans()\n{\n\tif(cnt%2==0) return all+sum;\n\telse\n\t{\n\t\tit=st.upper_bound(0);\n\t\tll mx=-(*it);\n\t\tit--;\n\t\tmx=max(mx,(*it));\n\t\treturn all+sum+mx;\n\t}\n}\nint main()\n{\n\tscanf(\"%d %d\",&n,&q);\n\tn*=2;\n\tfor(int i=0;i<n;i++) scanf(\"%lld\",&A[i]);\n\tfor(int i=0;i<n;i++) scanf(\"%lld\",&B[i]);\n\tfor(int i=0;i<n;i++) ins(i);\n\tfor(int i=0;i<q;i++)\n\t{\n\t\tint p;\n\t\tll x,y;\n\t\tscanf(\"%d %lld %lld\",&p,&x,&y);p--;\n\t\trem(p);\n\t\tA[p]=x,B[p]=y;\n\t\tins(p);\n\t\tprintf(\"%lld\\n\",get_ans());\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n\nint const INF = 1000000007;\n\nint a[200000], b[200000];\n//dp[0][i]=(1番目からi番目まででbを偶数個選んだ時の値の総和の最大値)\n//dp[1][i]=(1番目からi番目まででbを奇数個選んだ時の値の総和の最大値)\nlong long dp[2][200000];\n\nlong long max(long long a, long long b){\n\treturn a < b ? b : a;\n}\n\n//O(nq)\nint main() {\n\tint n, q;\n\tscanf(\"%d%d\", &n, &q);\n\tint i,j;\n\tfor (i = 0; i < 2 * n; i++) {\n\t\tscanf(\"%d\", &a[i]);\n\t\tdp[0][1] += a[i];\n\t}\n\tfor (i = 0; i < 2 * n; i++) {\n\t\tscanf(\"%d\", &b[i]);\n\t}\n\tint p,x,y;\n\tfor (i = 0; i < q; i++) {\n\t\tscanf(\"%d%d%d\", &p,&x,&y);\n\t\tdp[0][1] += x - a[p - 1];\n\t\ta[p - 1] = x;\n\t\tb[p - 1] = y;\n\t\tdp[1][1] = dp[0][1] + b[1] - a[1];\n\t\tfor (j = 2; j <= 2 * n - 2; j++) {\n\t\t\tdp[0][j] = max(dp[0][j - 1], dp[1][j - 1] + b[j] - a[j]);\n\t\t\tdp[1][j] = max(dp[1][j - 1], dp[0][j - 1] + b[j] - a[j]);\n\t\t}\n\t\tprintf(\"%d\\n\", dp[0][2 * n - 2]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nint main() {\n        int n, q;\n        scanf(\"%d%d\", &n, &q);\n        assert(n <= 5 && q <= 10);\n        n = 2 * n;\n        vector<int> a(n), b(n);\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &a[i]);\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &b[i]);\n        set<string> ok;\n        vector<int> s(n - 2);\n        for (int i = 0; i < n - 2; i ++) s[i] = i;\n        do {\n                string tmp = \"\";\n                for (int i = 0; i < n - 2; i ++) {\n                        if (s[i] & 1) tmp += \")\";\n                        else tmp += \"(\";\n                }\n                stack<char> st;\n                st.push('(');\n                for (int i = 0; i < n - 2; i ++) {\n                        if (!st.empty() && st.top() == '(' && tmp[i] == ')') st.pop();\n                        else st.push(tmp[i]);\n                }\n                if (st.top() == '(') st.pop();\n                if (st.empty()) ok.insert(\"(\" + tmp + \")\");\n        } while (next_permutation(s.begin(), s.end()));\n        vector<string> yes;\n        for (auto it : ok) yes.push_back(it);\n        while (q --) {\n                int p, x, y;\n                scanf(\"%d%d%d\", &p, &x, &y);\n                p --;\n                a[p] = x;\n                b[p] = y;\n                long long ans = 0;\n                for (int i = 0; i < yes.size(); i ++) {\n                        for (int j = i; j < yes.size(); j ++) {\n                                string fi = yes[i], se = yes[j];\n                                long long res = 0;\n                                for (int i = 0; i < n; i ++) {\n                                        if (fi[i] == se[i]) res += a[i];\n                                        else res += b[i];\n                                }\n                                ans = max(ans, res);\n                        }\n                }\n                printf(\"%lld\\n\", ans);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n\nusing namespace std;\n\ntypedef pair<long, int> P;\npriority_queue<P, vector<P>, greater<P>> que_pos;\npriority_queue<P, vector<P>> que_neg;\n\nint main(){\n    long N, Q;\n    long a[200000], b[200000];\n    cin >> N >> Q;\n    for(int i = 0; i < 2*N ; i++){\n        cin >> a[i];\n    }\n    for(int i = 0; i < 2*N ; i++){\n        cin >> b[i];\n    }\n    long sum_a = a[0] + a[2*N-1];\n    long sum_b = 0;\n    int cnt_pos = 0;\n    for(int i = 1; i <= 2*N-2; i++){\n        if(a[i] < b[i]){\n            cnt_pos++;\n            que_pos.push(P(b[i]-a[i], i));\n            sum_b += b[i];\n        }else{\n            que_neg.push(P(b[i]-a[i], i));\n            sum_a += a[i];\n        }\n    }\n    for(int i = 0; i < Q; i++){\n        int p, x, y;\n        cin >> p >> x >> y;\n        p--;\n        if(p != 0 && p != 2*N-1){\n            if(b[p] > a[p]) {\n                cnt_pos--;\n                sum_b -= b[p];\n            }else{\n                sum_a -= a[p];\n            }\n        }\n        a[p] = x;\n        b[p] = y;\n        if(b[p] > a[p]) {\n            cnt_pos++;\n            sum_b += b[p];\n            que_pos.push(P(b[p]-a[p], p));\n        }else{\n            sum_a += a[p];\n            que_neg.push(P(b[p]-a[p], p));\n        }\n        \n        if(cnt_pos%2 == 0){\n            //cout << 'H' << endl;\n            cout << sum_a+sum_b << endl;\n        }else{\n            while(!que_pos.empty()){\n                P top = que_pos.top();\n                int idx = top.second;\n                if(top.first != (b[idx]-a[idx])) que_pos.pop();\n                else break;\n            }\n            while(!que_neg.empty()){\n                P top = que_neg.top();\n                int idx = top.second;\n                if(top.first != (b[idx]-a[idx])) que_neg.pop();\n                else break;\n            }\n            if(que_neg.empty()) cout << \"neg empty\\n\";\n            if(que_pos.empty()) cout << \"pos empty\\n\";\n            if(que_neg.top().first+que_pos.top().first >= 0){\n                cout  << sum_a + sum_b + que_neg.top().first << endl;\n            }else{\n                cout  << sum_a + sum_b - que_pos.top().first << endl; \n            }\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<set>\n#include<map>\n#include<string>\n#include<vector>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll, int> pli;\n \nconst int MX = 1<<19;\n \nstruct Tree{\n\tint t[MX*2];\n\tvoid update(int x, int v){\n\t\tx += MX; t[x] = v;\n\t\twhile(x > 1){\n\t\t\tx /= 2;\n\t\t\tt[x] = min(t[x*2], t[x*2+1]);\n\t\t}\n\t}\n\tint read(int s, int e){\n\t\ts += MX, e += MX;\n\t\tint ans = 2e9;\n\t\twhile(s <= e){\n\t\t\tif( s&1 ) ans = min(ans, t[s++]);\n\t\t\tif( ~e&1 ) ans = min(ans, t[e--]);\n\t\t\ts /= 2, e /= 2;\n\t\t}\n\t\treturn ans;\n\t}\n}mn;\n \nstruct BIT{\n\tll t[MX];\n\tint read(int x){\n\t\tll ans = 0;\n\t\twhile(x){\n\t\t\tans += t[x];\n\t\t\tx -= x&-x;\n\t\t}\n\t\treturn ans;\n\t}\n\tvoid update(int x, int v){\n\t\twhile(x < MX){\n\t\t\tt[x] += v; x += x&-x;\n\t\t}\n\t}\n}sum;\n \nint A[MX], B[MX];\n \nint main()\n{\n\tint N, Q, cnt = 0;\n\tll ans = 0;\n\tscanf(\"%d%d\", &N, &Q);\n\tfor(int i = 1; i <= 2*N; i++) scanf(\"%d\", A+i);\n\tfor(int i = 1; i <= 2*N; i++) scanf(\"%d\", B+i);\n\tfor(int i = 2; i <= 2*N-1; i++) if( A[i] > B[i] ) cnt++;\n\tans += A[1] + A[2*N];\n\tfor(int i = 2; i <= 2*N-1; i++){\n\t\tmn.update(i, max(A[i], B[i]) - min(A[i], B[i]));\n\t\tans += max(A[i], B[i]);\n\t}\n \n\tfor(int i = 1; i <= Q; i++){\n\t\tint x, a, b;\n\t\tscanf(\"%d%d%d\", &x, &a, &b);\n\t\tif( x == 1 || x == 2*N ) ans -= A[x];\n\t\telse{\n\t\t\tif( A[x] > B[x] ) cnt--;\n\t\t\tans -= max(A[x], B[x]);\n\t\t}\n\t\tA[x] = a; B[x] = b;\n\t\tmn.update(x, max(a, b) - min(a, b));\n\t\tif( x == 1 || x == 2*N ) ans += A[x];\n\t\telse{\n\t\t\tif( A[x] > B[x] ) cnt++;\n\t\t\tans += max(A[x], B[x]);\n\t\t}\n\t\tif( cnt%2 == 1 ) printf(\"%lld\\n\", ans - mn.read(2, 2*N-1));\n\t\telse printf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <functional>\nusing namespace std;\n\nlong long N, Q, a[100009], b[100009];\nlong long solve() {\n\tvector<int>Z; long long sum = 0;\n\tfor (int i = 1; i < 2 * N - 1; i++) {\n\t\tsum += a[i];\n\t\tZ.push_back(b[i] - a[i]);\n\t}\n\tsum += a[0] + a[2 * N - 1];\n\tsort(Z.begin(), Z.end(), greater<int>());\n\tlong long maxn = 0, S = 0;\n\tfor (int i = 0; i < Z.size(); i += 2) {\n\t\tS += Z[i] + Z[i + 1];\n\t\tmaxn = max(maxn, S);\n\t}\n\treturn sum + maxn;\n}\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 0; i < 2 * N; i++)cin >> a[i];\n\tfor (int i = 0; i < 2 * N; i++)cin >> b[i];\n\tfor (int i = 0; i < Q; i++) {\n\t\tint p1, p2, p3; cin >> p1 >> p2 >> p3; p1--;\n\t\ta[p1] = p2; b[p1] = p3;\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define endl '\\n'\n#define lfs cout<<fixed<<setprecision(10)\n#define ALL(a)  (a).begin(),(a).end()\n#define ALLR(a)  (a).rbegin(),(a).rend()\n#define spa << \" \" <<\n#define fi first\n#define se second\n#define MP make_pair\n#define MT make_tuple\n#define PB push_back\n#define EB emplace_back\n#define rep(i,n,m) for(ll i = (n); i < (ll)(m); i++)\n#define rrep(i,n,m) for(ll i = (ll)(m) - 1; i >= (ll)(n); i--)\nusing ll = long long;\nusing ld = long double;\nconst ll MOD1 = 1e9+7;\nconst ll MOD9 = 998244353;\nconst ll INF = 1e18;\nusing P = pair<ll, ll>;\ntemplate<typename T1, typename T2>\nbool chmin(T1 &a,T2 b){if(a>b){a=b;return true;}else return false;}\ntemplate<typename T1, typename T2>\nbool chmax(T1 &a,T2 b){if(a<b){a=b;return true;}else return false;}\nll median(ll a,ll b, ll c){return a+b+c-max({a,b,c})-min({a,b,c});}\nvoid ans1(bool x){if(x) cout<<\"Yes\"<<endl;else cout<<\"No\"<<endl;}\nvoid ans2(bool x){if(x) cout<<\"YES\"<<endl;else cout<<\"NO\"<<endl;}\nvoid ans3(bool x){if(x) cout<<\"Yay!\"<<endl;else cout<<\":(\"<<endl;}\ntemplate<typename T1,typename T2>\nvoid ans(bool x,T1 y,T2 z){if(x)cout<<y<<endl;else cout<<z<<endl;}  \ntemplate<typename T>\nvoid debug(vector<vector<T>>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{cout<<v[i][0];for(ll j=1;j<w;j++)cout spa v[i][j];cout<<endl;}};\nvoid debug(vector<string>&v,ll h,ll w){for(ll i=0;i<h;i++)\n{for(ll j=0;j<w;j++)cout<<v[i][j];cout<<endl;}};\ntemplate<typename T>\nvoid debug(vector<T>&v,ll n){if(n!=0)cout<<v[0];\nfor(ll i=1;i<n;i++)cout spa v[i];cout<<endl;};\ntemplate<typename T>\nvector<vector<T>>vec(ll x, ll y, T w){\n  vector<vector<T>>v(x,vector<T>(y,w));return v;}\nll gcd(ll x,ll y){ll r;while(y!=0&&(r=x%y)!=0){x=y;y=r;}return y==0?x:y;}\nvector<ll>dx={1,-1,0,0,1,1,-1,-1};\nvector<ll>dy={0,0,1,-1,1,-1,1,-1};\ntemplate<typename T>\nvector<T> make_v(size_t a,T b){return vector<T>(a,b);}\ntemplate<typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v(ts...))>(a,make_v(ts...));\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2>&p){\n  return os << p.first << \" \" << p.second;\n}\n//mt19937 mt(chrono::steady_clock::now().time_since_epoch().count());\ntemplate< typename Monoid ,typename F>\nstruct SegmentTree {\n  int sz, n;\n  vector< Monoid > seg;\n  const F f;\n  const Monoid M1;\n\n  SegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1), n(n){\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz, M1);\n  }\n\n  void set(int k, const Monoid &x) {\n    seg[k + sz] = x;\n  }\n\n  void build() {\n    for(int k = sz - 1; k > 0; k--) {\n      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n    }\n  }\n\n  void update(int k, const Monoid &x) {\n    k += sz;\n    seg[k] = x;\n    while(k >>= 1) {\n      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n    }\n  }\n\n  Monoid query(int a, int b) {\n\t  if(a>=b)return M1;\n    Monoid L = M1, R = M1;\n    for(a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n      if(a & 1) L = f(L, seg[a++]);\n      if(b & 1) R = f(seg[--b], R);\n    }\n    return f(L, R);\n  }\n\n  Monoid operator[](const int &k) const {\n    return seg[k + sz];\n  }\n\n  template< typename C >\n  int find_subtree(int a, const C &check, Monoid &M, bool type) {\n    while(a < sz) {\n      Monoid nxt = type ? f(seg[2 * a + type], M) : f(M, seg[2 * a + type]);\n      if(check(nxt)) a = 2 * a + type;\n      else M = nxt, a = 2 * a + 1 - type;\n    }\n    return a - sz;\n  }\n\n\n  template< typename C >\n  int find_first(int a, const C &check) {\n    Monoid L = M1;\n    if(a <= 0) {\n      if(check(f(L, seg[1]))) return find_subtree(1, check, L, false);\n      return -1;\n    }\n    int b = sz;\n    for(a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n      if(a & 1) {\n        Monoid nxt = f(L, seg[a]);\n        if(check(nxt)) return find_subtree(a, check, L, false);\n        L = nxt;\n        ++a;\n      }\n    }\n    return -1;\n  }\n\n  template< typename C >\n  int find_last(int b, const C &check) {\n    Monoid R = M1;\n    if(b >= sz) {\n      if(check(f(seg[1], R))) return find_subtree(1, check, R, true);\n      return -1;\n    }\n    int a = sz;\n    for(b += sz; a < b; a >>= 1, b >>= 1) {\n      if(b & 1) {\n        Monoid nxt = f(seg[--b], R);\n        if(check(nxt)) return find_subtree(b, check, R, true);\n        R = nxt;\n      }\n    }\n    return -1;\n  }\n  void print(){\n    for(ll i=0;i<n;i++)if((*this)[i]==M1)cout<<\"x \";else cout<<(*this)[i]<<\" \";\n    cout<<endl;\n  }\n};\nint main(){\n  cin.tie(nullptr);\n  ios_base::sync_with_stdio(false);\n  ll res=0,buf=0;\n  bool judge = true;\n  ll n,q;cin>>n>>q;\n\n  auto f=[&](P x,P y){\n    return MP(max(x.fi+y.fi,x.se+y.se),max(x.fi+y.se,x.se+y.fi));\n  };\n  SegmentTree<P,decltype(f)>seg(2*n,f,MP(0,-INF));\n  vector<ll>a(2*n),b(2*n);\n  rep(i,0,2*n)cin>>a[i];\n  rep(i,0,2*n)cin>>b[i];\n  rep(i,0,2*n){\n    if(i==0||i==2*n-1)seg.set(i,MP(a[i],-INF));\n    else seg.set(i,MP(a[i],b[i]));\n  }\n  seg.build();\n  while(q--){\n    ll p,x,y;cin>>p>>x>>y;p--;\n    if(p==0||p==2*n-1)seg.update(p,MP(x,-INF));\n    else seg.update(p,MP(x,y));\n    //seg.print();\n    //debug(seg.seg,seg.seg.size());\n    cout<<seg.query(0,2*n).fi<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0); cout.tie(0);\n\tint N, Q; cin >> N >> Q; \n\tlong long A[200010], B[200010]; \n\tfor(int i = 0; i < N*2; i++) cin >> A[i]; \n\tfor(int i = 0; i < N*2; i++) cin >> B[i]; \n\tlong long sumA = 0; // 全部Aだった場合\n\tlong long sumP = 0; // 変えた方が得なものを全部Bに変えたときの得\n\tmultiset<long long> P, M; \n\tfor(int i = 0; i < N*2; i++) sumA += A[i]; \n\tfor(int i = 1; i < N*2-1; i++){\n\t\tif(A[i] <= B[i]){\n\t\t\tP.insert(B[i] - A[i]); sumP += B[i] - A[i]; \n\t\t}\n\t\telse M.insert(A[i] - B[i]); \n\t}\n\twhile(Q--){\n\t\tint p; long long x, y; \n\t\tcin >> p >> x >> y; p--; \n\t\tif(p == 0 || p == N*2 - 1){\n\t\t\tsumA += x - A[p]; \n\t\t\tA[p] = x; \n\t\t}else{\n\t\t\tif(A[p] <= B[p]){\n\t\t\t\tP.erase(*P.find(B[p] - A[p])); \n\t\t\t\tsumP -= B[p] - A[p]; \n\t\t\t\tsumA -= A[p]; \n\t\t\t\tA[p] = x; B[p] = y; \n\t\t\t}else{\n\t\t\t\tM.erase(*M.find(A[p] - B[p])); \n\t\t\t\tsumA -= A[p]; \n\t\t\t\tA[p] = x; B[p] = y; \n\t\t\t}\n\t\t\tsumA += A[p]; \n\t\t\tif(A[p] <= B[p]){\n\t\t\t\tP.insert(B[p] - A[p]); sumP += B[p] - A[p]; \n\t\t\t}\n\t\t\telse M.insert(A[p] - B[p]); \n\t\t}\n\t\tlong long ans = sumA + sumP; \n\t\tint s = (int) P.size(); \n\t\tif(s & 1){\n\t\t\tlong long d = *P.begin(); \n\t\t\tlong long e = *M.begin(); \n\t\t\tans -= min(d, e); \n\t\t}\n\t\tcout << ans << \"\\n\"; \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long lli;\ntypedef double lld;\ntypedef vector<lli> vll;\ntypedef vector<bool> vbl;\ntypedef vector<double> vdl;\ntypedef vector<vector<lli>> mat;\ntypedef vector<vdl> mad;\ntypedef unordered_map<lli,unordered_map<lli,lli>> graph;\ntypedef complex<double> cmp;\ntypedef vector<cmp> vcl;\n\nlli n,q;\nvll a,b,c;\nmultiset<lli> l,r;\nlli ans = 0;\nlli p,x,y;\n\nint main(){\n  cin >> n >> q;\n  a = vll(2*n);\n  b = vll(2*n);\n  c = vll(2*n);\n  for(lli i = 0;i < 2*n;i++) cin >> a[i];\n  for(lli i = 0;i < 2*n;i++) cin >> b[i];\n  for(lli i = 0;i < 2*n;i++) c[i] = a[i]-b[i];\n  ans = accumulate(a.begin(),a.end(),0ll);\n  for(lli i = 1;i < 2*n-1;i++){\n    if(c[i] < 0){\n      r.insert(c[i]);\n    }else{\n      l.insert(c[i]);\n    }\n  }\n  if(r.size()%2 == 1){\n    if(*r.rbegin()+*l.begin() < 0){\n      r.insert(*l.begin());\n      l.erase(l.begin());\n    }else{\n      l.insert(*r.rbegin());\n      r.erase(--r.end());\n    }\n  }\n  for(lli x : r){\n    ans -= x;\n  }\n  for(lli i = 0;i < q;i++){\n    cin >> p >> x >> y;\n    p--;\n    if(p >= 1 && p < 2*n-1){\n      if(l.find(c[p]) != l.end()) l.erase(l.find(c[p]));\n      else{\n        r.erase(r.find(c[p]));\n        ans += c[p];\n      }\n    }\n    ans -= a[p];\n\n    a[p] = x;\n    b[p] = y;\n    c[p] = a[p]-b[p];\n    ans += a[p];\n    if(p >= 1 && p < 2*n-1){\n      if(c[p] < 0){\n        r.insert(c[p]);\n        ans -= c[p];\n      } else l.insert(c[p]);\n      if(r.size()%2 == 1){\n        if(*r.rbegin()+*l.begin() < 0){\n          ans -= *l.begin();\n          r.insert(*l.begin());\n          l.erase(l.begin());\n        }else{\n          ans += *r.rbegin();\n          l.insert(*r.rbegin());\n          r.erase(--r.end());\n        }\n      }\n    }\n\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\ntypedef pair<ll, ll> PL;\nconst ll mod = 1e9 + 7;\n\nconst int N = 200000;\n\nint n;\n\nll a[N], d[N]; // b[i] = a[i] + d[i]\nll asum;\n\nset<PL> neg, pos;\nll possum;\n\nvoid add_d(int x, ll y) {\n  d[x] = y;\n  if (x == 0 || x == 2 * n - 1) return;\n  if (y >= 0) {\n    possum += y;\n    pos.insert(PL(y, x));\n  } else {\n    neg.insert(PL(y, x));\n  }\n}\n\nvoid rm_d(int x) {\n  ll y = d[x];\n  if (x == 0 || x == 2 * n - 1) return;\n  if (y >= 0) {\n    possum -= y;\n    pos.erase(PL(y, x));\n  } else {\n    neg.erase(PL(y, x));\n  }\n}\n\nll solve() {\n  if (0) {\n    cerr << \"possum = \" << possum << endl;\n    for (auto n: neg) {\n      cerr << \" \" << n.first;\n    }\n    cerr << endl;\n    for (auto p: pos) {\n      cerr << \" \" << p.first;\n    }\n    cerr << endl;\n  }\n  ll tot = possum;\n  if (pos.size() % 2 == 1) {\n    tot += max(-pos.begin()->first, neg.rbegin()->first);\n  }\n  return tot + asum;\n}\n\n\nint main(void) {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int q;\n  cin >> n >> q;\n  VL a(2 * n), b(2 * n);\n  REP(i, 0, 2 * n) {\n    cin >> a[i];\n    asum += a[i];\n  }\n  REP(i, 0, 2 * n) {\n    ll b;\n    cin >> b;\n    add_d(i, b - a[i]);\n  }\n  REP(i, 0, q) {\n    int p, x, y;\n    cin >> p >> x >> y;\n    p--;\n    asum += x - a[p];\n    a[p] = x;\n    rm_d(p);\n    add_d(p, y - x);\n    cout << solve() << \"\\n\";\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=1e9+7;\nconst int big=1e9+100;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nint main(void){\n\tint n,q,i,j;cin>>n>>q;\n\tvector<llint>A(2*n);\n\tvector<llint>B(2*n);\n\tllint ans=0,ki=0;\n\tfor(i=0;i<2*n;i++){cin>>A[i];}\n\tfor(i=0;i<2*n;i++){cin>>B[i];}\n\tmultiset<llint>osi;\n\tans+=A[0]+A[2*n-1];\n\tfor(i=1;i<2*n-1;i++){\n\t\tans+=max(A[i],B[i]);\n\t\tif(B[i]>A[i]){ki++;}\n\t\tosi.ins(abs(A[i]-B[i]));\n\t}\n\twhile(q--){\n\t\tint p;llint x,y;cin>>p>>x>>y;p--;\n\t\tif(p==0||p==2*n-1){ans-=A[p];ans+=x;A[p]=x;B[p]=y;}\n\t\telse{\n\t\t\tans-=max(A[p],B[p]);\n\t\t\tif(B[p]>A[p]){ki--;}\n\t\t\tosi.era(osi.lower_bound(abs(A[p]-B[p])));\n\t\t\tA[p]=x;B[p]=y;\n\t\t\tans+=max(A[p],B[p]);\n\t\t\tif(B[p]>A[p]){ki++;}\n\t\t\tosi.ins(abs(A[p]-B[p]));\n\t\t}\n\t\tif(ki%2==1){cout<<ans-(*osi.begin())<<endl;}\n\t\telse{cout<<ans<<endl;}\n\t}\n\tRE;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = a; i < b; i++)\ntypedef long long ll;\n\nusing namespace std;\n\nint N, Q;\nll A[200010], B[200010];\nmultiset<ll> S;\n\nint main() {\n\tcin >> N >> Q;\n\trep(i, 0, 2 * N) cin >> A[i];\n\trep(i, 0, 2 * N) cin >> B[i];\n\tll ans = 0; bool odd = false;\n\tans += A[0] + A[2 * N - 1];\n\trep(i, 1, 2 * N - 1) {\n\t\tans += max(A[i], B[i]);\n\t\todd ^= (A[i] > B[i]);\n\t\tS.insert(abs(A[i] - B[i]));\n\t}\n\twhile(Q--) {\n\t\tll a, x, y;\n\t\tcin >> a >> x >> y; a--;\n\t\tif(a == 0 || a == 2 * N - 1) {\n\t\t\tans += x - A[a];\n\t\t\tA[a] = x;\n\t\t}\n\t\telse {\n\t\t\todd ^= (A[a] > B[a]);\n\t\t\todd ^= (x > y);\n\t\t\tans += max(x, y) - max(A[a], B[a]);\n\t\t\tS.erase(S.lower_bound(abs(A[a] - B[a])));\n\t\t\tS.insert(abs(x - y));\n\t\t\tA[a] = x; B[a] = y;\n\t\t}\n\t\tcout << (!odd ? ans : ans - (*S.begin())) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(...) overload_rep(__VA_ARGS__, rep_1, rep_0)(__VA_ARGS__)\n#define rep_0(i, end) for(int i = 0; i < (end); ++i)\n#define rep_1(i, fr, ba) for(int i = (fr); i <= (ba); ++i)\n#define overload_rep(arg0, arg1, arg2, name, ...) name\n#define all(box) box.begin(), box.end()\n\ntemplate <class T> inline bool chmax(T& lhs, const T& rhs) { if(lhs < rhs) { lhs = rhs; return 1; } return 0; }\ntemplate <class T> inline bool chmin(T& lhs, const T& rhs) { if(lhs > rhs) { lhs = rhs; return 1; } return 0; }\n\ntypedef long long lint;\ntypedef pair<lint, lint> paris;\nconstexpr lint inf = 1ll << 60;\n\ntemplate <class Mn, class Op>\nstruct SegmentTree {\nprivate:\n\n    int size;\n    std::vector<Mn> node;\n    const Mn unit;\n    const Op oper;\n\npublic:\n\n    SegmentTree(const Mn& unit_, const Op& oper_)\n        : unit(unit_), oper(oper_) { }\n    SegmentTree(const int& size_, const Mn& unit_, const Op& oper_)\n        : unit(unit_), oper(oper_) { init(size_); }\n    SegmentTree(const std::vector<Mn>& node_, const Mn& unit_, const Op& oper_)\n        : unit(unit_), oper(oper_) { build(node_); }\n\n    void fill() {\n        fill(node.begin(), node.end(), unit);\n    }\n\n    void init(const int& size_) {\n        for(size = 1; size < size_; size <<= 1);\n        node.assign(size << 1, unit);\n    }\n\n    void build(const std::vector<Mn>& node_) {\n        init(node_.size());\n        for(int i = 0; i < node_.size(); ++i) \n            node[i + size] = node_[i];\n        for(int i = size - 1; i > 0; --i) \n            node[i] = oper(node[i << 1], node[i << 1 | 1]);\n    }\n\n    void set_value(const int& idx, const Mn& value) {\n        int i = idx + size;\n        for(node[i] = value; (i >>= 1) > 0;)\n            node[i] = oper(node[i << 1], node[i << 1 | 1]);\n    }\n\n    void add_value(const int& idx, const Mn& plus) {\n        int i = idx + size;\n        for(node[i] += plus; (i >>= 1) > 0;)\n            node[i] = oper(node[i << 1], node[i << 1 | 1]);\n    }\n\n    Mn fold(const int& l, const int& r) const {\n        Mn result_l = unit, result_r = unit;\n        for(int tl = l + size, tr = r + size; tl < tr; tl >>= 1, tr >>= 1) {\n            if(tl & 1) result_l = oper(result_l, node[tl++]);\n            if(tr & 1) result_r = oper(node[--tr], result_r);\n        }\n        return oper(result_l, result_r);\n    }\n\n    Mn operator () (const int& l, const int& r) const {\n        return fold(l, r);\n    }\n\n    Mn operator [] (const int& idx) const {\n        return node[idx + size];\n    }\n\n};\n\nint main() {\n\n    int N, Q;\n    cin >> N >> Q;\n\n    lint fa, fb, la, lb;\n    vector<pair<lint, lint>> vec(2 * N - 2);\n    cin >> fa;\n    rep(i, 2 * N - 2) cin >> vec[i].first;\n    cin >> la;\n    cin >> fb;\n    rep(i, 2 * N - 2) cin >> vec[i].second;\n    cin >> lb;\n\n    const auto func = [](paris l, paris r) {\n        if(l.first == -inf && l.second == -inf) return r;\n        if(r.first == -inf && r.second == -inf) return l;\n        return make_pair(max(l.first + r.first, l.second + r.second), max(l.first + r.second, l.second + r.first));\n    };\n    SegmentTree<paris, decltype(func)> seg(vec, make_pair(-inf, -inf), func);\n\n    while(Q--) {\n        int p;\n        lint a, b;\n        cin >> p >> a >> b;\n        if(p == 1) fa = a;\n        else if(p == 2 * N) la = a;\n        else seg.set_value(p - 2, make_pair(a, b));\n        if(N > 1) cout << fa + seg(0, 2 * N - 2).first + la << '\\n';\n        else cout << fa + la << '\\n';\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n\n// stream\n//#include <istream>\n//#include <sstream>\n//#include <ostream>\n#include <fstream>\n\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest&...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int i=0; i<n; ++i){MACRO_VEC_ROW_Scan(i, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest&...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest&...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& r:c)for(auto& i:r)std::cin>>i;\n\n// output\n#define OUT(d) std::cout<<(d);\n#define FOUT(n, d) std::cout<<std::fixed<<std::setprecision(n)<<(d);\n#define SOUT(n, c, d) std::cout<<std::setw(n)<<std::setfill(c)<<(d);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(i, n) std::cout<<(i + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(d) {std::cerr << #d << \"\\t:\" << (d) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RFOR(i, a, b) for(int i=(b)-1;i>=(a);--i)\n#define REP(i, n) for(int i=0;i<int(n);++i)\n#define RREP(i, n) for(int i=int(n)-1;i>=0;--i)\n#define FORLL(i, a, b) for(ll i=ll(a);i<ll(b);++i)\n#define RFORLL(i, a, b) for(ll i=ll(b)-1;i>=ll(a);--i)\n#define REPLL(i, n) for(ll i=0;i<ll(n);++i)\n#define RREPLL(i, n) for(ll i=ll(n)-1;i>=0;--i)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<typename T> inline T CHMAX(T& a, const T b) { return a = (a < b) ? b : a; }\ntemplate<typename T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n#define EXCEPTION(msg) throw std::string(\"Exception : \" msg \" [ in \") + __func__ + \" : \" + std::to_string(__LINE__) + \" lines ]\"\n#define TRY(cond, msg) try {if (cond) EXCEPTION(msg);}catch (std::string s) {std::cerr << s << std::endl;}\nvoid CHECKTIME(std::function<void()> f) { auto start = std::chrono::system_clock::now(); f(); auto end = std::chrono::system_clock::now(); auto res = std::chrono::duration_cast<std::chrono::nanoseconds>((end - start)).count(); std::cerr << \"[Time:\" << res << \"ns  (\" << res / (1.0e9) << \"s)]\\n\"; }\n\n// test\ntemplate<class T> std::vector<std::vector<T>> VV(int n, int m, T init = T()) {\n\treturn std::vector<std::vector<T>>(n, std::vector<T>(m, init));\n}\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = 1 << 30;                          // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-9;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\n\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T& val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T>& a, const T& val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>>& a, const T& val) { for (auto& b : a) FILL(b, val); }\n\n// ------------>8------------------------------------->8------------\n\n\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, q);\n\tVEC(int, a, 2 * n);\n\tVEC(int, b, 2 * n);\n\n\tint sum = 0;\n\tREP(i, 2 * n) sum += a[i];\n\n\tstd::multiset<int> A, B;\n\tint tsum = 0;\n\tREP(i, 2 * n) {\n\t\tif (i == 0 || i == 2 * n - 1) continue;\n\t\tint t = b[i] - a[i];\n\t\tif (t >= 0) B.insert(t), tsum += t;\n\t\telse A.insert(t);\n\t}\n\n\tauto norm = [&] {\n\t\twhile (!A.empty() && *A.rbegin() >= 0) {\n\t\t\tint t = *A.rbegin();\n\t\t\tA.erase(A.find(t));\n\t\t\tB.insert(t); tsum += t;\n\t\t}\n\t\twhile (!B.empty() && *B.begin() < 0) {\n\t\t\tint t = *B.begin();\n\t\t\tB.erase(B.find(t));\n\t\t\tA.insert(t); tsum -= t;\n\t\t}\n\n\t\tif (A.size() % 2 == 1) {\n\t\t\tint aa = *A.rbegin();\n\t\t\tint bb = *B.begin();\n\t\t\tif (-aa < bb) {\n\t\t\t\tA.erase(A.find(aa));\n\t\t\t\tB.insert(aa); tsum += aa;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tB.erase(B.find(bb));\n\t\t\t\tA.insert(bb); tsum -= bb;\n\t\t\t}\n\t\t}\n\t};\n\n\tREP(_, q) {\n\t\tVAR(int, p, x, y);\n\t\t--p;\n\t\tsum += x - a[p];\n\t\tint pre = b[p] - a[p];\n\t\ta[p] = x;\n\t\tb[p] = y;\n\t\tif (p > 0 && p < 2 * n - 1) {\n\t\t\tint t = y - x;\n\t\t\tif (A.count(pre)) {\n\t\t\t\tA.erase(A.find(pre));\n\t\t\t}\n\t\t\telse if (B.count(pre)) {\n\t\t\t\tB.erase(B.find(pre)); tsum -= pre;\n\t\t\t}\n\t\t\tA.insert(t);\n\t\t}\n\t\tnorm();\n\t\tOUT(sum + tsum)BR;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\npair<long long, long long> datas[500000];\nint erased[500000];\nint itr[500000];\nint main() {\n\tiostream::sync_with_stdio(false);\n#define int long long\n\tint n, query;\n\tcin >> n >> query;\n\tREP(i, 2 * n) {\n\t\tcin >> datas[i].first;\n\t}\n\tREP(i, 2 * n) {\n\t\tcin >> datas[i].second;\n\t}\n\tREP(i, 2 * n) {\n\t\titr[i] = i;\n\t}\n\tint aa, bb, cc;\n\tcin >> aa >> bb >> cc;\n\tdatas[aa - 1] = make_pair(bb, cc);\n\tpriority_queue<pair<long long,long long>> next_loser;\n\tpriority_queue<pair<long long, long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>> next_winner;\n\tlong long now_ans = 0;\n\tnow_ans += datas[0].first;\n\tnow_ans += datas[2 * n - 1].first;\n\tlong long now_cnt = 0;\n\tfor (int i = 1; i < 2 * n - 1; ++i) {\n\t\tnow_ans += datas[i].second;\n\t\tlong long geko = datas[i].first - datas[i].second;\n\t\tif (geko >= 0) {\n\t\t\tnow_cnt++;\n\t\t\tnext_winner.push(make_pair(geko, i));\n\t\t\tnow_ans += geko;\n\t\t}\n\t\telse {\n\t\t\tnext_loser.push(make_pair(geko, i));\n\t\t}\n\t}\n\tif (now_cnt % 2 == 0) {\n\t\tcout << now_ans << endl;\n\t}\n\telse {\n\t\tlong long geko = now_ans - next_winner.top().first;\n\t\tif (next_loser.empty() == false) {\n\t\t\tgeko = max(geko, now_ans + next_loser.top().first);\n\t\t}\n\t\tcout << geko << endl;\n\t}\n\treturn 0;\n\tint next_move = 2 * n;\n\tREP(i, query) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;\n\t\tif (a == 0 || a == 2 * n - 1) {\n\t\t\tnow_ans -= datas[a].first;\n\t\t\tnow_ans += b;\n\t\t\tdatas[a] = make_pair(b, c);\n\t\t\tcontinue;\n\t\t}\n\t\t//First We need To remove\n\t\tint data_itr = itr[a];\n\t\terased[data_itr] = 1;\n\t\tnow_ans -= datas[data_itr].second;\n\t\tint diff = datas[data_itr].first - datas[data_itr].second;\n\t\tif (diff >= 0) {\n\t\t\tnow_cnt--;\n\t\t\tnow_ans -= diff;\n\t\t}\n\t\telse {\n\t\t\t//nothing\n\t\t}\n\t\twhile (next_winner.empty() == false && erased[next_winner.top().second] == true) {\n\t\t\tnext_winner.pop();\n\t\t}\n\t\twhile (next_loser.empty() == false && erased[next_loser.top().second] == true) {\n\t\t\tnext_loser.pop();\n\t\t}\n\t\tdata_itr = next_move;\n\t\tnext_move++;\n\t\titr[a] = data_itr;\n\t\tdatas[data_itr] = make_pair(b, c);\n\t\tnow_ans += datas[data_itr].second;\n\t\tdiff = datas[data_itr].first - datas[data_itr].second;\n\t\tif (diff >= 0) {\n\t\t\tnow_cnt++;\n\t\t\tnow_ans += diff;\n\t\t\tnext_winner.push(make_pair(diff, data_itr));\n\t\t}\n\t\telse {\n\t\t\t//nothing\n\t\t\tnext_loser.push(make_pair(diff, data_itr));\n\t\t}\n\t\t//OK!\n\t\tif (now_cnt % 2 == 0) {\n\t\t\tcout << now_ans << endl;\n\t\t}\n\t\telse {\n\t\t\tassert(0 == 1);\n\t\t\tlong long geko = now_ans - next_winner.top().first;\n\t\t\tif (next_loser.empty() == false) {\n\t\t\t\tgeko = max(geko, now_ans + next_loser.top().first);\n\t\t\t}\n\t\t\tcout << geko << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, Q, p, x, y, a[200009], b[200009];\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 0; i < 2 * N; i++) cin >> a[i];\n\tfor (int i = 0; i < 2 * N; i++) cin >> b[i];\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> p >> x >> y; p--;\n\t\ta[p] = x;\n\t\tb[p] = y;\n\t\tint bc = 0, bm = 2012345678;\n\t\tlong long ret = a[0] + a[2 * N - 1];\n\t\tfor (int j = 1; j < 2 * N - 1; j++) {\n\t\t\tret += max(a[j], b[j]);\n\t\t\tif (a[j] < b[j]) {\n\t\t\t\tbc++;\n\t\t\t\tbm = min(bm, b[j] - a[j]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbm = min(bm, a[j] - b[j]);\n\t\t\t}\n\t\t}\n\t\tcout << ret - (bc & 1 ? bm : 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<59;\nconst double pi=acos(-1);\nconst double eps=1e-7;\nconst ll mod=1e5;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n,q;\nvl a,b;\n\nint main(){\n\tcin>>n>>q;\n\tn*=2;\n\ta=b=vl(n);\n\tfor(int i=0;i<n;i++) cin>>a[i];\n\tfor(int i=0;i<n;i++) cin>>b[i];\n\tll sum=0,tmp=0;\n\tmultiset<ll> st1,st2;\n\tfor(int i=1;i<n-1;i++){\n\t\tll t=a[i]-b[i];\n\t\ttmp+=b[i];\n\t\tif(t>0){\n\t\t\tst1.insert(t);\n\t\t\tsum+=t;\n\t\t}\n\t\telse st2.insert(t);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tll p,x,y;\n\t\tcin>>p>>x>>y;\n\t\tp--;\n\t\tif(0<p&&p<n-1){\n\t\t\tll t=a[p]-b[p];\n\t\t\tif(t>0){\n\t\t\t\tst1.erase(st1.lower_bound(t));\n\t\t\t\tsum-=t;\n\t\t\t}\n\t\t\telse st2.erase(st2.lower_bound(t));\n\t\t\ttmp+=y-b[p];\n\t\t\tt=x-y;\n\t\t\tif(t>0){\n\t\t\t\tst1.insert(t);\n\t\t\t\tsum+=t;\n\t\t\t}\n\t\t\telse st2.insert(t);\n\t\t}\n\t\ta[p]=x;b[p]=y;\n\t\tif(st1.size()%2==0) cout<<sum+tmp+a[0]+a[n-1]<<endl;\n\t\telse{\n\t\t\tcout<<max(-*st1.begin(),(st2.empty()?-INF:*(--st2.end())))+sum+tmp+a[0]+a[n-1]<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<queue>\n#include<set>\n#include<map>\n#include<stack>\n#include<bitset>\n\n#define pb push_back\n#define mp make_pair\n\nusing namespace std;\n\ntemplate<typename T>inline void upmin(T &x,T y) { y<x?x=y:0; }\ntemplate<typename T>inline void upmax(T &x,T y) { x<y?x=y:0; }\n\ntypedef unsigned int u32;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst LL OO=1e18;\n\nconst int N=1e6;\n\nint gi() {\n\tint w=0;bool q=1;char c=getchar();\n\twhile ((c<'0'||c>'9') && c!='-') c=getchar();\n\tif (c=='-') q=0,c=getchar();\n\twhile (c>='0'&&c <= '9') w=w*10+c-'0',c=getchar();\n\treturn q? w:-w;\n}\n\nLL a[N],b[N];\nLL f[N],g[N];\n#define lc (i<<1)\n#define rc (lc|1)\ninline void modify(int i,int l,int r,int k) {\n\tif (l==r) f[i]=a[l],g[i]=b[l];\n\telse {\n\t\tint mid=(l+r)>>1;\n\t\tk<=mid?modify(lc,l,mid,k):modify(rc,mid+1,r,k);\n\t\tf[i]=max(f[lc]+f[rc],g[lc]+g[rc]);\n\t\tg[i]=max(f[lc]+g[rc],g[lc]+f[rc]);\n\t}\n}\nint main()\n{\n\tint n=gi()*2,m=gi(),i,k;\n\tfor (i=1;i<=n;i++) a[i]=gi();\n\tfor (i=1;i<=n;i++) b[i]=gi();\n\tb[1]=b[n]=-OO;\n\tfor (i=1;i<=n;i++) modify(1,1,n,i);\n\twhile (m--) {\n\t\tk=gi(),a[k]=gi();\n\t\tif (1<k&&k<n) b[k]=gi();\n\t\tmodify(1,1,n,k);\n\t\tprintf(\"%lld\\n\",f[1]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(LL i=0;i<(LL)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n#define LL long long\n#define pii pair<LL,LL>\n#define pll pair<LL,LL>\n\nusing namespace std;\n\nstruct SegmentTree{\n\n    LL n=2;\n    vector<LL> data;\n    vector<LL> num;\n    vector<LL> minusmax;\n    vector<LL> plusmin;\n\n    SegmentTree(LL _n){\n        n = 2;\n        while(n<_n)n*=2;\n        data.resize(2*n-1, INT_MIN);\n        num.resize(2*n-1, 0);\n        minusmax.resize(2*n-1, INT_MIN);\n        plusmin.resize(2*n-1, INT_MAX);\n    }\n\n    void set(LL pos, LL x){\n        pos += n-1;\n        data[pos]=x;\n        if(x > 0){\n            num[pos] = 1;\n            plusmin[pos] = x;\n            minusmax[pos] = INT_MIN;\n        }else{\n            num[pos]=0;\n            minusmax[pos] = x;\n            plusmin[pos] = INT_MAX;\n        }\n        while(pos > 0){\n            pos = (pos-1)/2;\n            data[pos] = (max(0LL, data[2*pos +1]) + max(0LL, data[2*pos +2]));\n            num[pos] = num[2*pos +1] + num[2*pos + 2];\n            minusmax[pos] = max(minusmax[2*pos + 1], minusmax[2*pos + 2]);\n            plusmin[pos] = min(plusmin[2*pos + 1], plusmin[2*pos + 2]);\n        }\n    }\n\n    LL getSum(LL l, LL r, LL a=0, LL b=-1, LL pos=0){\n        if(b<0)b=n;\n        if(l>=b || r <= a)return 0;\n        if(l<=a && r <= b)return data[pos];\n        return getSum(l, r, a, (a+b)/2, pos*2+1) + getSum(l, r, (a+b)/2, b, pos*2+2);\n    }\n    LL getNum(LL l,LL r, LL a=0, LL b=-1, LL pos=0){\n        if(b<0)b=n;\n        if(l>=b || r <= a)return 0;\n        if(l<=a && r <= b)return num[pos];\n        return getNum(l, r, a, (a+b)/2, pos*2+1) + getNum(l, r, (a+b)/2, b, pos*2+2);\n    }\n    LL getMinusMax(LL l,LL r,LL a=0, LL b=-1, LL pos=0){\n        if(b<0)b=n;\n        if(l>=b || r <= a)return INT_MIN;\n        if(l<=a && r <= b)return minusmax[pos];\n        return max(getMinusMax(l, r, a, (a+b)/2, pos*2+1) ,getMinusMax(l, r, (a+b)/2, b, pos*2+2));\n    }\n    LL getPlusMin(LL l,LL r,LL a=0, LL b=-1, LL pos=0){\n        if(b<0)b=n;\n        if(l>=b || r <= a)return INT_MAX;\n        if(l<=a && r <= b)return plusmin[pos];\n        return min(getPlusMin(l, r, a, (a+b)/2, pos*2+1) ,getPlusMin(l, r, (a+b)/2, b, pos*2+2));\n    }\n\n    void printData(){\n        cout<<endl;\n        REP(i,n)cout<<n-1+i<<\" \"<<data[n-1+i]<<endl;\n        cout<<endl;\n    }\n};\n\n\nint main(){\n\n    LL N,Q;cin>>N>>Q;\n    LL ans=0;\n    LL a[2*N], b[2*N];\n\n    REP(i,2*N)cin>>a[i];\n    REP(i,2*N)cin>>b[i];\n\n    if(N==1){\n        while(Q--){\n            LL p,x,y;cin>>p>>x>>y;\n            a[--p]=x;\n            ans = a[0]+a[1];\n            cout<<ans<<endl;\n        }\n    }else{\n    REP(i,2*N)ans += a[i];\n    SegmentTree st(2*N-2);\n    REP(i,2*N-2)st.set(i, b[i+1]-a[i+1]);\n\n    while(Q--){\n        LL p,x,y;cin>>p>>x>>y;\n        ans -= a[--p];\n        a[p]=x;\n        b[p]=y;\n        ans += a[p];\n        st.set(p-1, y-x);\n\n        LL res = ans + st.getSum(0,2*N-2);\n        if(st.getNum(0,2*N-2)%2==1){\n            res = max(res - st.getPlusMin(0,2*N-2), res + st.getMinusMax(0,2*N-2));\n        }\n\n\n        cout<<res<<endl;\n\n    }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007\ntypedef long long ll;\nusing namespace std;\n#define N 200010\nll n,q,a[N],b[N];\nmap<ll,ll> mp;\nvoid Erase(ll x){\n    mp[x]--;\n    if(mp[x]==0)mp.erase(x);\n}\nint main(){\n    cin>>n>>q;\n    lol(i,2*n)cin>>a[i];\n    lol(i,2*n)cin>>b[i];\n    \n    ll sum=a[0]+a[2*n-1];\n    ll cnt=0;\n    for(int i=1;i<=2*n-2;i++){\n\tsum+=max(a[i],b[i]);\n\tif(a[i]>b[i]){\n\t    mp[a[i]-b[i]]++;\n\t    cnt++;\n\t}\n\telse mp[b[i]-a[i]]++;\n    }\n    \n    lol(u,q){\n\tll p,x,y;\n\tcin>>p>>x>>y;\n\tp--;\n\tif(p==0||p==2*n-1){\n\t    sum=sum-a[0]+x;\n\t}\n\telse{\n\t    sum-=max(a[p],b[p]);\n\t    sum+=max(x,y);\n\t    \n\t    if(a[p]>b[p]){\n\t\tErase(a[p]-b[p]);\n\t\tcnt--;\n\t    }\n\t    else Erase(b[p]-a[p]);\n\t    \n\t    if(x>y){\n\t\tmp[x-y]++;\n\t\tcnt++;\n\t    }\n\t    else mp[y-x]++;\n\t}\n\ta[p]=x,b[p]=y;\n\tll ans=sum;\n\tif(cnt%2==1){\n\t    ans-=mp.begin()->first;\n\t}\n\tcout<<ans<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace std::chrono;\n#define int long long\n#define ll long long\nauto start_time = system_clock::now();\n\n//@formatter:off\n#ifdef _DEBUG\n//区間削除は出来ない\ntemplate<class T> struct my_pbds_tree {    set<T> s;    auto begin() { return s.begin(); }    auto end() { return s.end(); }    auto rbegin() { return s.rbegin(); }    auto rend() { return s.rend(); }    auto empty() { return s.empty(); }    auto size() { return s.size(); }    void clear() { s.clear(); }    template<class U> void insert(U v) { s.insert(v); }template<class U> void operator+=(U v) { insert(v); }    template<class F> auto erase(F v) { return s.erase(v); }    template<class U> auto find(U v) { return s.find(v); }    template<class U> auto lower_bound(U v) { return s.lower_bound(v); }    template<class U> auto upper_bound(U v) { return s.upper_bound(v); }    auto find_by_order(ll k) {        auto it = s.begin();        for (ll i = 0; i < k; i++)it++;        return it;    }    auto order_of_key(ll v) {        auto it = s.begin();        ll i=0;        for (;it != s.end() && *it <v ; i++)it++;        return i;    }};\n#define pbds(T) my_pbds_tree<T>\n#else\n#define unordered_map __gnu_pbds::gp_hash_table\n//find_by_order(k) k番目のイテレーター\n//order_of_key(k)  k以上が前から何番目か\n#define pbds(U) __gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>\n#endif\nstruct xorshift {    static uint64_t splitmix64(uint64_t x) {        x += 0x9e3779b97f4a7c15;        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;        return x ^ (x >> 31);    }    size_t operator()(uint64_t x) const {        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(x + FIXED_RANDOM);    }    size_t operator()(std::pair<ll, ll> x) const {        ll v=((x.first) << 32) | x.second;        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();        return splitmix64(v + FIXED_RANDOM);    }};\ntemplate<class U, class L> void operator+=(__gnu_pbds::tree<U, __gnu_pbds::null_type, less<U>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> &s, L v) { s.insert(v); }\n//衝突対策\n#define ws wszzzz\n\ntemplate<class A, class B, class C>struct T2 {A f;B s;C t;T2() { f = 0, s = 0, t = 0; }T2(A f, B s, C t) : f(f), s(s), t(t) {}bool operator<(const T2 &r) const {        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;        /*return f != r.f ? f > r.f : s != r.s ?n s > r.s : t > r.t; 大きい順 */   }    bool operator>(const T2 &r) const {        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;        /*return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順 */   }    bool operator==(const T2 &r) const {        return f == r.f && s == r.s && t == r.t;    }    bool operator!=(const T2 &r) const {        return f != r.f || s != r.s || t != r.t;    }};\ntemplate<class A, class B, class C, class D> struct F2 {    A a;    B b;    C c;    D d;    F2() { a = 0, b = 0, c = 0, d = 0; }    F2(A a, B b, C c, D d) : a(a), b(b), c(c), d(d) {}    bool operator<(const F2 &r) const {        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;    /*    return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;*/    }    bool operator>(const F2 &r) const {        return a != r.a ? a > r.a : b != r.b ? b > r.b : c != r.c ? c > r.c : d > r.d;/*        return a != r.a ? a < r.a : b != r.b ? b < r.b : c != r.c ? c < r.c : d < r.d;*/    }    bool operator==(const F2 &r) const {        return a == r.a && b == r.b && c == r.c && d == r.d;    }    bool operator!=(const F2 &r) const {        return a != r.a || b != r.b || c != r.c || d != r.d;    }    ll operator[](ll i) {        assert(i < 4);        return i == 0 ? a : i == 1 ? b : i == 2 ? c : d;    }};\ntypedef T2<ll, ll, ll> T;\ntypedef F2<ll, ll, ll, ll> F;\nT mt(ll a, ll b, ll c) {return T(a, b, c);}\n\n//@マクロ省略系 型,構造\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\n#define au auto\nusing P = pair<ll, ll>;\nusing pd =pair<dou, dou>;\n#define fi first\n#define se second\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n#define el else\n#define elf else if\n#define wh while\n\n#define maxq 1\n#define minq -1\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MALLOC(type, len) (type*)malloc((len) * sizeof(type))\n#define lam(right) [&](ll& p){return p right;}\n\n//マクロ省略系 コンテナ\nusing vi = vector<ll>;\nusing vb = vector<bool>;\nusing vs = vector<string>;\nusing vd = vector<double>;\nusing vc = vector<char>;\nusing vp = vector<P>;\nusing vt = vector<T>;\n\n#define V vector\n#define o_vvt(o1, o2, o3, o4, name, ...) name\n#define vvt0(t) V<V<t>>\n#define vvt1(t,a) V<V<t>>a\n#define vvt2(t,a, b) V<V<t>>a(b)\n#define vvt3(t,a, b, c) V<V<t>> a(b,V<t>(c))\n#define vvt4(t,a, b, c, d) V<V<t>> a(b,V<t>(c,d))\n\n#define vvi(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(ll,__VA_ARGS__)\n#define vvb(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(bool,__VA_ARGS__)\n#define vvs(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(string,__VA_ARGS__)\n#define vvd(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(double,__VA_ARGS__)\n#define vvc(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(char,__VA_ARGS__)\n#define vvp(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(P,__VA_ARGS__)\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts> auto make_v(size_t a, Ts... ts) {return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));}\n#define vni(name, ...) auto name = make_v<ll>(__VA_ARGS__)\n#define vnb(name, ...) auto name = make_v<bool>(__VA_ARGS__)\n#define vns(name, ...) auto name = make_v<string>(__VA_ARGS__)\n#define vnd(name, ...) auto name = make_v<double>(__VA_ARGS__)\n#define vnc(name, ...) auto name = make_v<char>(__VA_ARGS__)\n#define vnp(name, ...) auto name = make_v<P>(__VA_ARGS__)\n\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\n#define tos to_string\nusing mapi = map<ll, ll>;\nusing mapp = map<P, ll>;\nusing mapd = map<dou, ll>;\nusing mapc = map<char, ll>;\nusing maps = map<str, ll>;\nusing seti = set<ll>;\nusing setd = set<dou>;\nusing setc = set<char>;\nusing sets = set<str>;\nusing qui = queue<ll>;\n#define bset bitset\n#define uset unordered_set\n#define useti unordered_set<ll,ll,xorshift>\n#define mset multiset\n#define mseti multiset<ll>\n#define umap unordered_map\n#define umapi unordered_map<ll,ll,xorshift>\n#define umapp unordered_map<P,ll,xorshift>\n#define mmap multimap\n\ntemplate<class T> struct pq {    priority_queue<T, vector<T>, greater<T> > q;/*小さい順*/    T su = 0;    void clear() {q = priority_queue<T, vector<T>, greater<T> >();su = 0;}    void operator+=(T v) {su += v;q.push(v);}    T sum() {return su;}    T top() {return q.top();}    void pop() {su -= q.top();q.pop();}    T poll() {T ret = q.top();su -= ret;q.pop();return ret;}    ll size() {return q.size();}};\ntemplate<class T> struct pqg {    priority_queue<T> q;/*大きい順*/    T su = 0;    void clear() {q = priority_queue<T>();su = 0;}    void operator+=(T v) {su += v;q.push(v);}    T sum() {return su;}    T top() {return q.top();}    void pop() {su -= q.top();q.pop();}    T poll() {T ret = q.top();su -= ret;q.pop();return ret;}    ll size() {return q.size();}};\n#define pqi pq<ll>\n#define pqgi pqg<ll>\n//マクロ 繰り返し\n#define o_rep(o1, o2, o3, o4, name, ...) name\n# define rep1(n) for(ll rep1i = 0,rep1lim=n; rep1i < rep1lim ; ++rep1i)\n# define rep2(i, n) for(ll i = 0,rep2lim=n; i < rep2lim ; ++i)\n#define rep3(i, m, n) for(ll i = m,rep3lim=n; i < rep3lim ; ++i)\n#define rep4(i, m, n, ad) for(ll i = m,rep4lim=n; i < rep4lim ; i+= ad)\n#define rep(...) o_rep(__VA_ARGS__,rep4,rep3,rep2,rep1)(__VA_ARGS__)\n\n#define rer2(i, n) for(ll i = n; i >= 0 ; i--)\n#define rer3(i, m, n) for(ll i = m,rer3lim=n; i >= rer3lim ; i--)\n#define rer4(i, m, n, dec) for(ll i = m,rer4lim=n; i >= rer4lim ; i-=dec)\n#define rer(...) o_rep(__VA_ARGS__,rer4,rer3,rer2,)(__VA_ARGS__)\n\n#define reps2(i, j, n) for(ll i = 0,reps2lim=n; i < reps2lim ;++i)for(ll j = 0; j < reps2lim ; ++j)\n#define reps3(i, j, k, n) for(ll i = 0,reps3lim=n; i < reps3lim ; ++i)for(ll j = 0; j < reps3lim ; ++j)for(ll k = 0; k < reps3lim ; ++k)\n#define reps4(i, j, k, l, n) for(ll i = 0,reps4lim=n; i < reps4lim ; ++i)for(ll j = 0; j < reps4lim ; ++j)for(ll k = 0; k < reps4lim ; ++k)for(ll l = 0; l < reps4lim ; ++l)\n#define o_reps(o1, o2, o3, o4, o5, name, ...) name\n#define reps(...) o_reps(__VA_ARGS__,reps4,reps3,reps2,rep2,)(__VA_ARGS__)\n\n#define repss(i, j, k, a, b, c) for(ll i = 0; i < a ; ++i)for(ll j = 0; j < b ; ++j)for(ll k = 0; k < c ; ++k)\n\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) for (ll gi = 0,forglim = ve.size(), f, t, c; gi < forglim && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); ++gi)\n#define fort(gi, ve) for (ll gi = 0, f, t, c; gi < ve.size() && (f = ve[gi].f, t = ve[gi].t, c = ve[gi].c, true); ++gi)if(t!=p)\n\n#define form(st, l, r) for (auto &&it = st.lower_bound(l); it != st.end() && (*it).fi < r; ++it)\n#define forit(st, l, r) for (auto &&it = st.lower_bound(l); it != st.end() && (*it) < r;)\n\n//マクロ 定数\n#define k3 1010\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst ll inf = (ll) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst char infc = '{';\nconst string infs = \"{\";\nconst double eps = 1e-9;\nconst double PI = 3.1415926535897932384626433832795029L;\nll ma = numeric_limits<ll>::min();\nll mi = numeric_limits<ll>::max();\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define sz(a) ((ll)(a).size())\n#define mp make_pair\n#define pb pop_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\nconstexpr bool ev(ll a) { return !(a & 1); }\nconstexpr bool od(ll a) { return (a & 1); }\n//@拡張系 こう出来るべきというもの\n\n//埋め込み 存在を意識せずに機能を増やされているもの\n//@formatter:on\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> { public:size_t operator()(const std::pair<signed, signed> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n    template<> class hash<std::pair<ll, ll>> { public:/*大きいllが渡されると、<<32でオーバーフローするがとりあえず問題ないと判断*/size_t operator()(const std::pair<ll, ll> &x) const { return hash<ll>()(((ll) x.first << 32) | x.second); }};\n}\n//@formatter:off\n//stream まとめ\nistream &operator>>(istream &iss, P &a) {    iss >> a.first >> a.second;    return iss;}template<typename T> istream &operator>>(istream &iss, vector<T> &vec) {    for (T &x: vec) iss >> x;    return iss;}template<class T, class U> ostream &operator<<(ostream &os, pair<T, U> p) {    os << p.fi << \" \" << p.se << endl;    return os;}ostream &operator<<(ostream &os, T p) {    os << p.f << \" \" << p.s << \" \" << p.t;    return os;}ostream &operator<<(ostream &os, F p) {    os << p.a << \" \" << p.b << \" \" << p.c << \" \" << p.d;    return os;}template<typename T> ostream &operator<<(ostream &os, vector<T> &vec) {    for (ll i = 0; i < vec.size(); ++i)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");    return os;}template<typename T> ostream &operator<<(ostream &os, vector<vector<T>> &vec) {    for (ll i = 0; i < vec.size(); ++i) {        for (ll j = 0; j < vec[i].size(); ++j) { os << vec[i][j] << \" \"; }        os << endl;    }    return os;}template<typename T, typename U> ostream &operator<<(ostream &os, map<T, U> &m) {    for (auto &&v:m) os << v;    return os;}\ntemplate<typename W, typename H> void resize(vector<W> &vec, const H head) { vec.resize(head); }template<typename W, typename H, typename ... T> void resize(vector<W> &vec, const H &head, const T ... tail) {vec.resize(head);for (auto &v: vec)resize(v, tail...);}\ntemplate<typename T, typename F> bool all_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool all_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (!all_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool any_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool any_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (any_of2(v[i], f))return true; }    return false;}\ntemplate<typename T, typename F> bool none_of2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> bool none_of2(vector<T> &v, F f) {    rep(i, sz(v)) { if (none_of2(v[i], f))return false; }    return true;}\ntemplate<typename T, typename F> bool find_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll find_if2(vector<T> &v, F f) {    rep(i, sz(v)) { if (find_if2(v[i], f))return i; }    return sz(v);}\ntemplate<typename T, typename F> bool rfind_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll rfind_if2(vector<T> &v, F f) {    rer(i, sz(v) - 1) { if (rfind_if2(v[i], f))return i; }    return -1;}\ntemplate<class T> bool contains(string &s, const T &v) { return s.find(v) != string::npos; }\ntemplate<typename T> bool contains(vector<T> &v, const T &val) { return std::find(v.begin(), v.end(), val) != v.end(); }\ntemplate<typename T, typename F> bool contains_if2(vector<T> &v, F f) { return find_if(v.begin(), v.end(), f) != v.end(); }\ntemplate<typename T, typename F> ll count_if2(T &v, F f) { return f(v); }\ntemplate<typename T, typename F> ll count_if2(vector<T> &vec, F f) {    ll ret = 0;    fora(v, vec)ret += count_if2(v, f);    return ret;}\ntemplate<typename T, typename F> void for_each2(T &v, F f) { f(v); }\ntemplate<typename T, typename F> void for_each2(vector<T> &vec, F f) { fora(v, vec)for_each2(v, f); }\ntemplate<typename W> ll count_od(vector<W> &a) {return count_if2(a,[](ll v){return v&1 ;});}\ntemplate<typename W> ll count_ev(vector<W> &a) {return count_if2(a,[](ll v){return !(v&1) ;});}\n#define all_of(a,right) all_of2(a,lam(right))\n#define any_of(a,right) any_of2(a,lam(right))\n#define none_of(a,right) none_of2(a,lam(right))\n#define find_if(a,right) find_if2(a,lam(right))\n#define rfind_if(a,right) rfind_if2(a,lam(right))\n#define contains_if(a,right) contains_if2(a,lam(right))\n#define count_if(a, right) count_if2(a,lam(right))\n#define for_each(a, right) do{fora(v,a){v right;}}while(0)\n\n\ntemplate<class T, class U> void replace(vector<T> &a, T key, U v) { replace(a.begin(), a.end(), key, v); }\nvoid replace(str &a, char key, str v) { if (v == \"\")a.erase(remove(all(a), key), a.end()); }\nvoid replace(str &a, char key, char v) { replace(all(a), key, v); }\n//keyと同じかどうか01で置き換える\ntemplate<class T, class U> void replace(vector<T> &a, U k) { rep(i, sz(a)) a[i] = a[i] == k; }\ntemplate<class T, class U> void replace(vector<vector<T >> &a, U k) { rep(i, sz(a))rep(j, sz(a[0])) a[i][j] = a[i][j] == k; }\ntemplate<class T> void replace(T &a) { replace(a, '#'); }\nvoid replace(str &a, str key, str v) {stringstream t;ll kn = sz(key);std::string::size_type Pos(a.find(key));ll l = 0;while (Pos != std::string::npos) {t << a.substr(l, Pos - l);t << v;l = Pos + kn;Pos = a.find(key, Pos + kn);}t << a.substr(l, sz(a) - l);a = t.str();}\ntemplate<class T> bool includes(vector<T> &a, vector<T> &b) {vi c = a;vi d = b;sort(all(c));sort(all(d));return includes(all(c), all(d));}\ntemplate<class T> bool is_permutation(vector<T> &a, vector<T> &b) { return is_permutation(all(a), all(b)); }\ntemplate<class T> bool next_permutation(vector<T> &a) { return next_permutation(all(a)); }\nvoid iota(vector<ll> &ve, ll s, ll n) {ve.resize(n);iota(all(ve), s);}\nvi iota(ll s, ll len) {vi ve(len);iota(all(ve), s);return ve;}\ntemplate<class A, class B> auto vtop(vector<A> &a, vector<B> &b) {    assert(sz(a) == sz(b));    /*stringを0で初期化できない  */  vector<pair<A, B>> res;    rep(i, sz(a))res.eb(a[i], b[i]);return res;}\ntemplate<class A, class B> void ptov(vector<pair<A, B>> &p, vector<A> &a, vector<B> &b) {    a.resize(sz(p)), b.resize(sz(p));    rep(i, sz(p))a[i] = p[i].fi, b[i] = p[i].se;}\ntemplate<class A, class B, class C> auto vtot(vector<A> &a, vector<B> &b, vector<C> &c) {    assert(sz(a) == sz(b) && sz(b) == sz(c));    vector<T2<A, B, C>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i]);    return res;}\ntemplate<class A, class B, class C, class D> auto vtof(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    assert(sz(a) == sz(b) && sz(b) == sz(c) && sz(c) == sz(d));    vector<F2<A, B, C, D>> res;    rep(i, sz(a))res.eb(a[i], b[i], c[i], d[i]);    return res;}\nenum pcomparator { fisi, fisd, fdsi, fdsd, sifi, sifd, sdfi, sdfd };\nenum tcomparator {    fisiti, fisitd, fisdti, fisdtd, fdsiti, fdsitd, fdsdti, fdsdtd,    fitisi, fitisd, fitdsi, fitdsd, fdtisi, fdtisd, fdtdsi, fdtdsd,    sifiti, sifitd, sifdti, sifdtd, sdfiti, sdfitd, sdfdti, sdfdtd,    sitifi, sitifd, sitdfi, sitdfd, sdtifi, sdtifd, sdtdfi, sdfdfd,    tifisi, tifisd, tifdsi, tifdsd, tdfisi, tdfisd, tdfdsi, tdfdsd,    tisifi, tisifd, tisdfi, tisdfd, tdsifi, tdsifd, tdsdfi, tdsdfd};\ntemplate<class A, class B> void sort(vector<pair<A, B>> &a, pcomparator type) {    typedef pair<A, B> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se < r.se; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi < r.fi : l.se > r.se; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se < r.se; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.fi != r.fi ? l.fi > r.fi : l.se > r.se; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi < r.fi; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se < r.se : l.fi > r.fi; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi < r.fi; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.se != r.se ? l.se > r.se : l.fi > r.fi; });};template<class U> void sort(vector<U> &a, pcomparator type) {    if (type == fisi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f > r.f; });};template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D> > &a, pcomparator type) {    typedef F2<A, B, C, D> U;    if (type == fisi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == fisd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == fdsi) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == fdsd) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == sifi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == sifd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == sdfi) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == sdfd) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a > r.a; });};template<class U> void sort(vector<U> &a, tcomparator type) {    if (type == 0) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t < r.t; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s < r.s : l.t > r.t; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t < r.t; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.s != r.s ? l.s > r.s : l.t > r.t; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f < r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s < r.s; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t < r.t : l.s > r.s; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s < r.s; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.f != r.f ? l.f > r.f : l.t != r.t ? l.t > r.t : l.s > r.s; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t < r.t; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f < r.f : l.t > r.t; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t < r.t; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.f != r.f ? l.f > r.f : l.t > r.t; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s < r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f < r.f; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t < r.t : l.f > r.f; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f < r.f; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.s != r.s ? l.s > r.s : l.t != r.t ? l.t > r.t : l.f > r.f; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s < r.s; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f < r.f : l.s > r.s; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s < r.s; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.f != r.f ? l.f > r.f : l.s > r.s; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t < r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f < r.f; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s < r.s : l.f > r.f; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f < r.f; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.t != r.t ? l.t > r.t : l.s != r.s ? l.s > r.s : l.f > r.f; });}template<class A, class B, class C, class D> void sort(vector<F2<A, B, C, D>> &a, tcomparator type) {    typedef F2<A, B, C, D> U;    if (type == 0) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 1) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 2) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 3) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 4) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c < r.c; });    else if (type == 5) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b < r.b : l.c > r.c; });    else if (type == 6) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c < r.c; });    else if (type == 7) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.b != r.b ? l.b > r.b : l.c > r.c; });    else if (type == 8) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 9) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 10) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 11) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a < r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 12) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b < r.b; });    else if (type == 13) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c < r.c : l.b > r.b; });    else if (type == 14) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b < r.b; });    else if (type == 15) sort(all(a), [&](U l, U r) { return l.a != r.a ? l.a > r.a : l.c != r.c ? l.c > r.c : l.b > r.b; });    else if (type == 16) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 17) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 18) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 19) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 20) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c < r.c; });    else if (type == 21) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a < r.a : l.c > r.c; });    else if (type == 22) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c < r.c; });    else if (type == 23) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.a != r.a ? l.a > r.a : l.c > r.c; });    else if (type == 24) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 25) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 26) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 27) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b < r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 28) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a < r.a; });    else if (type == 29) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c < r.c : l.a > r.a; });    else if (type == 30) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a < r.a; });    else if (type == 31) sort(all(a), [&](U l, U r) { return l.b != r.b ? l.b > r.b : l.c != r.c ? l.c > r.c : l.a > r.a; });    else if (type == 32) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 33) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 34) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 35) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 36) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b < r.b; });    else if (type == 37) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a < r.a : l.b > r.b; });    else if (type == 38) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b < r.b; });    else if (type == 39) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.a != r.a ? l.a > r.a : l.b > r.b; });    else if (type == 40) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 41) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 42) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 43) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c < r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });    else if (type == 44) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a < r.a; });    else if (type == 45) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b < r.b : l.a > r.a; });    else if (type == 46) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a < r.a; });    else if (type == 47) sort(all(a), [&](U l, U r) { return l.c != r.c ? l.c > r.c : l.b != r.b ? l.b > r.b : l.a > r.a; });}\n\nvoid sort(string &a) { sort(all(a)); }\ntemplate<class T> void sort(vector<T> &a) { sort(all(a)); }\n//P l, P rで f(P) の形で渡す\ntemplate<class U, class F> void sort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) < f(r); }); };\ntemplate<class T> void rsort(vector<T> &a) { sort(all(a), greater<T>()); };\ntemplate<class U, class F> void rsort(vector<U> &a, F f) { sort(all(a), [&](U l, U r) { return f(l) > f(r); }); };\n//F = T<T>\n//例えばreturn p.fi + p.se;\ntemplate<class A, class B> void sortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    sort(c);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B, class F> void sortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    sort(c, f);    rep(i, sz(a)) a[i] = c[i].fi, b[i] = c[i].se;}template<class A, class B> void rsortp(vector<A> &a, vector<B> &b) {    auto c = vtop(a, b);    rsort(c);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}template<class A, class B, class F> void rsortp(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    rsort(c, f);    rep(i, sz(a))a[i] = c[i].first, b[i] = c[i].second;}\ntemplate<class A, class B, class C> void sortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    sort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void sortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    sort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c) {    auto d = vtot(a, b, c);    rsort(d);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class F> void rsortt(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    rsort(d, f);    rep(i, sz(a)) a[i] = d[i].f, b[i] = d[i].s, c[i] = d[i].t;}\ntemplate<class A, class B, class C, class D> void sortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    sort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\ntemplate<class A, class B, class C, class D> void rsortf(vector<A> &a, vector<B> &b, vector<C> &c, vector<D> &d) {    auto e = vtof(a, b, c, d);    rsort(e);    rep(i, sz(a)) a[i] = e[i].a, b[i] = e[i].b, c[i] = e[i].c, d[i] = e[i].d;}\n//sortindex 元のvectorはソートしない\ntemplate<class T> vi sorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind);    return ind;}/*indexの分で型が変わるためpcomparatorが必要*/template<class T> vi sorti(vector<T> &a, pcomparator f) {    auto b = a;    vi ind = iota(0, sz(a));    sortp(b, ind, f);    return ind;}template<class T, class F> vi sorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) < f(a[y]); });    return ind;}template<class T> vi rsorti(vector<T> &a) {    auto b = a;    vi ind = iota(0, sz(a));    rsortp(b, ind);    return ind;}template<class T, class F> vi rsorti(vector<T> &a, F f) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(a[x]) > f(a[y]); });    return ind;}template<class A, class B, class F> vi sortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) < f(c[y]); });    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b, pcomparator f) {    vi ind = iota(0, sz(a));    auto c = a;    auto d = b;    sortt(c, d, ind, f);    return ind;}template<class A, class B> vi sortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fisi); };template<class A, class B, class F> vi rsortpi(vector<A> &a, vector<B> &b, F f) {    auto c = vtop(a, b);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(c[x]) > f(c[y]); });    return ind;}template<class A, class B> vi rsortpi(vector<A> &a, vector<B> &b) { return sortpi(a, b, fdsd); };template<class A, class B, class C, class F> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) < f(d[y]); });    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c, pcomparator f) {    vi ind = iota(0, sz(a));    auto d = vtof(a, b, c, ind);    sort(d, f);    rep(i, sz(a))ind[i] = d[i].d;    return ind;}template<class A, class B, class C> vi sortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] < c[y];            else return b[x] < b[y];        } else {            return a[x] < a[y];        }    });    return ind;}template<class A, class B, class C, class F> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c, F f) {    auto d = vtot(a, b, c);    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) { return f(d[x]) > f(d[y]); });    return ind;}template<class A, class B, class C> vi rsortti(vector<A> &a, vector<B> &b, vector<C> &c) {    vi ind = iota(0, sz(a));    sort(all(ind), [&](ll x, ll y) {        if (a[x] == a[y]) {            if (b[x] == b[y])return c[x] > c[y];            else return b[x] > b[y];        } else {            return a[x] > a[y];        }    });    return ind;}\ntemplate<class T> void sort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)sort(a[i]); }\ntemplate<class T> void rsort2(vector<vector<T >> &a) { for (ll i = 0, n = a.size(); i < n; ++i)rsort(a[i]); }\n\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }template<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }template<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\ntemplate<typename W, typename T>void fill(W &xx, const T vall) {    xx = vall;}template<typename W, typename T>void fill(vector<W> &vecc, const T vall) {    for (auto &&vx     : vecc)fill(vx, vall);}\ntemplate<typename W,typename T>void fill(vector<W> &xx,const T v,ll len) {rep(i, len)xx[i]=v;}\ntemplate<typename W,typename T>void fill(vector<vector<W>> &xx,const T v,ll lh,ll lw) {rep(i, lh)rep(j,lw)xx[i][j]=v;}\ntemplate<class T,class U>void fill(vector<T> &a,U val,vi& ind) {fora(v,ind)a[v]=val;}\n\ntemplate<typename A, size_t N> A sum(A (&a)[N]) {    A res = 0;    rep(i, N)res += a[i];    return res;}template<typename A, size_t N, size_t O> A sum(A (&a)[N][O]) {    A res = 0;    rep(i, N)rep(j, O)res += a[i][j];    return res;}template<typename A, size_t N, size_t O, size_t P> A sum(A (&a)[N][O][P]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)res += a[i][j][k];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q> A sum(A (&a)[N][O][P][Q]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)res += a[i][j][k][l];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R> A sum(A (&a)[N][O][P][Q][R]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)res += a[i][j][k][l][m];    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S> A sum(A (&a)[N][O][P][Q][R][S]) {    A res = 0;    rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)res += a[i][j][k][l][m][n];    return res;}\n//@汎用便利関数 入力\nll in() {ll ret;cin >> ret;return ret;}\nstring sin() {string ret;cin >> ret;return ret;}\ntemplate<class T>  void in(T &head) { cin >> head; }template<class T, class... U>  void in(T &head, U &... tail) {cin >> head;in(tail...);}\n\n#define o_din(o1, o2, o3, o4, o5, o6, name, ...) name\n#define din1(a) ll a;cin>>a\n#define din2(a, b) ll a,b;cin>>a>> b\n#define din3(a, b, c) ll a,b,c;cin>>a>>b>>c\n#define din4(a, b, c, d) ll a,b,c,d;cin>>a>>b>>c>>d\n#define din5(a, b, c, d, e) ll a,b,c,d,e;cin>>a>>b>>c>>d>>e\n#define din6(a, b, c, d, e, f) ll a,b,c,d,e,f;cin>>a>>b>>c>>d>>e>>f\n#define din(...) o_din(__VA_ARGS__,din6,din5,din4,din3,din2 ,din1)(__VA_ARGS__)\n\n#define o_dind(o1, o2, o3, o4, name, ...) name\n#define din1d(a) din1(a);a--\n#define din2d(a, b) din2(a,b);a--,b--\n#define din3d(a, b, c) din3(a,b,c);a--,b--,c--\n#define din4d(a, b, c, d) din4(a,b,c,d);a--,b--,c--,d--\n#define dind(...) o_dind(__VA_ARGS__,din4d,din3d,din2d ,din1d)(__VA_ARGS__)\n\ntemplate<class T> void out2(T &&head) { cout << head; }\ntemplate<class T, class... U> void out2(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);}\ntemplate<class T, class... U> void out(T &&head, U &&... tail) {    cout << head << \" \";    out2(tail...);    cout << \"\" << endl;}\ntemplate<class T> void out(T &&head) {    cout << head  << endl;}\ntemplate<class T> void outv(vector<T> &a, ll W) {    rep(i, W) { cout << a[i] << \" \"; }    cout << \"\" << endl;}template<class T> void outv(vector<vector<T> > &a, ll H = linf, ll W = linf) {    rep(h, min(H, sz(a))) {        rep(w, min(W, sz(a[0]))) { if (a[h][w] == linf) cout << \"e\" << \" \"; else cout << a[h][w] << \" \"; }        cout << \"\" << endl;    }}\ntemplate<class T> void outl(vector<T> &a) { fora(v, a)cout << v << endl; }\ntemplate<class T> void na(vector<T> &a, ll n) {a.resize(n);rep(i, n)cin >> a[i];}\n#define dna(a, n) vi a(n); rep(dnai,n) cin >> a[dnai];\ntemplate<class T> void nao(vector<T> &a, ll n) {    a.resize(n + 1);    a[0] = 0;    rep(i, n)cin >> a[i + 1];}\ntemplate<class T> void naod(vector<T> &a, ll n) {    a.resize(n + 1);    a[0] = 0;    rep(i, n)cin >> a[i + 1],a[i+1]--;}\ntemplate<class T> void nad(vector<T> &a, ll n) {    a.resize(n);    rep(i, n)cin >> a[i], a[i]--;}\ntemplate<class T, class U> void na2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i];}\n#define dna2(a, b, n) vi a(n),b(n);rep(dna2i, n)cin >> a[dna2i] >> b[dna2i];\ntemplate<class T, class U> void nao2(vector<T> &a, vector<U> &b, ll n) {    a.resize(n + 1);    b.resize(n + 1);    a[0] = b[0] = 0;    rep(i, n)cin >> a[i + 1] >> b[i + 1];}\n#define dna2d(a, b, n) vi a(n),b(n);rep(dna2di, n){cin >> a[dna2di] >> b[dna2di];a[dna2di]--,b[dna2di]--;}\ntemplate<class T, class U> void na2d(vector<T> &a, vector<U> &b, ll n) {    a.resize(n);    b.resize(n);    rep(i, n)cin >> a[i] >> b[i], a[i]--, b[i]--;}\ntemplate<class T, class U, class W> void na3(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {    a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i];}\n#define dna3(a, b, c, n) vi a(n),b(n),c(n);   rep(dna3i, n)cin >> a[dna3i] >> b[dna3i] >> c[dna3i];\ntemplate<class T, class U, class W> void na3d(vector<T> &a, vector<U> &b, vector<W> &c, ll n) {    a.resize(n);    b.resize(n);    c.resize(n);    rep(i, n)cin >> a[i] >> b[i] >> c[i], a[i]--, b[i]--, c[i]--;}\n#define dna3d(a, b, c, n) vi a(n),b(n),c(n);  rep(dna3di, n){cin >> a[dna3di] >> b[dna3di] >> c[dna3di];a[dna3di]--,b[dna3di]--,c[dna3di]--;}\n#define nt(a, h, w) resize(a,h,w);rep(nthi,h)rep(ntwi,w) cin >> a[nthi][ntwi];\n#define ntd(a, h, w) resize(a,h,w);rep(ntdhi,h)rep(ntdwi,w) cin >> a[ntdhi][ntdwi], a[ntdhi][ntdwi]--;\n#define ntp(a, h, w) resize(a,h+2,w+2);fill(a,'#');rep(ntphi,1,h+1)rep(ntpwi,1,w+1) cin >> a[ntphi][ntpwi];\n//デバッグ\n#define sp << \" \" <<\n\n#define debugName(VariableName) # VariableName\n\n#define deb1(x)  debugName(x)<<\" = \"<<x\n#define deb2(x, ...) deb1(x) <<\", \"<< deb1(__VA_ARGS__)\n#define deb3(x, ...) deb1(x) <<\", \"<< deb2(__VA_ARGS__)\n#define deb4(x, ...) deb1(x) <<\", \"<< deb3(__VA_ARGS__)\n#define deb5(x, ...) deb1(x) <<\", \"<< deb4(__VA_ARGS__)\n#define deb6(x, ...) deb1(x) <<\", \"<< deb5(__VA_ARGS__)\n#define deb7(x, ...) deb1(x) <<\", \"<< deb6(__VA_ARGS__)\n#define deb8(x, ...) deb1(x) <<\", \"<< deb7(__VA_ARGS__)\n#define deb9(x, ...) deb1(x) <<\", \"<< deb8(__VA_ARGS__)\n#define deb10(x, ...) deb1(x) <<\", \"<< deb9(__VA_ARGS__)\n\n#define o_ebug(o1, o2, o3, o4, o5, o6, o7, o8, o9, o10, name, ...) name\n\n#ifdef _DEBUG\n#define deb(...)  cerr<< o_ebug(__VA_ARGS__,deb10,deb9,deb8,deb7,deb6,deb5,deb4,deb3,deb2,deb1)(__VA_ARGS__) <<endl\n#else\n#define deb(...) ;\n#endif\n\n#define debugline(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n'\n\n\n//@formatter:off\n//よく使うクラス、構造体\nstruct unionfind {\n    vector<ll> par;\n    vector<ll> siz;\n    vector<ll> es;\n    ll n, trees;//連結グループの数(親の種類)\n    unionfind(ll n) : n(n), trees(n) {        par.resize(n);        siz.resize(n);        es.resize(n);        for (ll i = 0; i < n; i++) {            par[i] = i;            siz[i] = 1;        }    }\n    ll root(ll x) { if (par[x] == x) { return x; } else { return par[x] = root(par[x]); }}\n    void unite(ll x, ll y) {\n        x = root(x);\n        y = root(y);\n        es[x]++;\n        if (x == y) return;\n        if (siz[x] > siz[y]) swap(x, y);\n        trees--;\n        par[x] = y;\n        siz[y] += siz[x];\n        es[y] += es[x];\n    }\n    bool same(ll x, ll y) { return root(x) == root(y); }\n    ll size(ll x) { return siz[root(x)]; }\n    ll esize(ll x) { return es[root(x)]; }\n    vi sizes(){        vi cou(n);        vi ret;        ret.reserve(n);        rep(i, n){            cou[root (i)]++;        }        rep(i, n){            if(cou[i])ret.push_back(cou[i]);        }        return ret;    }\n    //つながりを無向グラフと見なし、xが閉路に含まれるか判定\n    bool close(ll x) { return esize(x) >= size(x); }\n    V<vi> sets() {        vi ind(n, -1);        ll i = 0;        vvi(res, trees);        rep(j, n) {            ll r = root(j);            if (ind[r] == -1)ind[r] = i++;            res[ind[r]].push_back(j);        }        rep(i, trees) {            ll r = root(res[i][0]);            if (res[i][0] == r)continue;            rep(j, 1, sz(res[i])) {                if (res[i][j] == r) {                    swap(res[i][0], res[i][j]);                    break;                }            }        }        return res;    }\n};//@formatter:off\n\n\nusing bll =__int128;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing u128 = __uint128_t;\n\nstd::ostream &operator<<(std::ostream &dest, __int128_t value) {    std::ostream::sentry s(dest);    if (s) {        __uint128_t tmp = value < 0 ? -value : value;        char buffer[128];        char *d = std::end(buffer);        do {            --d;            *d = \"0123456789\"[tmp % 10];            tmp /= 10;        } while (tmp != 0);        if (value < 0) {            --d;            *d = '-';        }        ll len = std::end(buffer) - d;        if (dest.rdbuf()->sputn(d, len) != len) { dest.setstate(std::ios_base::badbit); }    }    return dest;}\n//__int128 toi128(string &s) {    __int128 ret = 0;    for (ll i = 0; i < s.length(); ++i)        if ('0' <= s[i] && s[i] <= '9')            ret = 10 * ret + s[i] - '0';    return ret;}\n\n\n//エラー\nvoid ole() {\n#ifdef _DEBUG\n    debugline(\"ole\");    exit(0);\n#endif\n    string a = \"a\";    rep(i, 30)a += a;    rep(i, 1 << 17)cout << a << endl;    cout << \"OLE 出力長制限超過\" << endl;    exit(0);}\nvoid re() {    assert(0 == 1);    exit(0);}\nvoid tle() { while (inf)cout << inf << endl; }\n\n//便利関数\n\n//テスト用\nchar ranc() { return (char) ('a' + rand() % 26); }\nll rand(ll min, ll max) {    assert(min <= max);    if (min >= 0 && max >= 0) { return rand() % (max + 1 - min) + min; } else if (max < 0) { return -rand(-max, -min); } else { if (rand() % 2) { return rand(0, max); } else { return -rand(0, -min); }}}\nvi ranv(ll n, ll min, ll max) {    vi v(n);    rep(i, n)v[i] = rand(min, max);    return v;}\nstr ransu(ll n) {    str s;    rep(i, n)s += (char) rand('A', 'Z');    return s;}\nstr ransl(ll n) {    str s;    rep(i, n)s += (char) rand('a', 'z');    return s;}\n//単調増加\nvi ranvinc(ll n, ll min, ll max) {    vi v(n);    bool bad = 1;    while (bad) {        bad = 0;        v.resize(n);        rep(i, n) {            if (i && min > max - v[i - 1]) {                bad = 1;                break;            }            if (i)v[i] = v[i - 1] + rand(min, max - v[i - 1]); else v[i] = rand(min, max);        }    }    return v;}\n//便利 汎用\nvoid ranvlr(ll n, ll min, ll max, vi &l, vi &r) {    l.resize(n);    r.resize(n);    rep(i, n) {        l[i] = rand(min, max);        r[i] = l[i] + rand(0, max - l[i]);    }}\nvp run_length(vi &a) {    vp ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\nvector<pair<char, ll>> run_length(string &a) {    vector<pair<char, ll>> ret;    ret.eb(a[0], 1);    rep(i, 1, sz(a)) { if (ret.back().fi == a[i]) { ret.back().se++; } else { ret.eb(a[i], 1); }}    return ret;}\ntemplate<class F> ll mgr(ll ok, ll ng, F f) {    if (ok < ng)        while (ng - ok > 1) {            ll mid = (ok + ng) / 2;            if (f(mid))ok = mid; else ng = mid;        }    else        while (ok - ng > 1) {            ll mid = (ok + ng) / 2;            if (f(mid))ok = mid; else ng = mid;        }    return ok;}\n//strを整数として比較\nstring smax(str &a, str b) {    if (sz(a) < sz(b)) { return b; } else if (sz(a) > sz(b)) { return a; } else { rep(i, sz(a)) { if (a[i] < b[i]) { return b; } else if (a[i] > b[i])return a; }}    return a;}\n//strを整数として比較\nstring smin(str &a, str b) {    if (sz(a) < sz(b)) { return a; } else if (sz(a) > sz(b)) { return b; } else { rep(i, sz(a)) { if (a[i] < b[i]) { return a; } else if (a[i] > b[i])return b; }}    return a;}\ntemplate<typename W, typename T> ll find(vector<W> &a, const T key) {    rep(i, sz(a))if (a[i] == key)return i;    return -1;}\ntemplate<typename W, typename T> P find(vector<vector<W >> &a, const T key) {    rep(i, sz(a))rep(j, sz(a[0]))if (a[i][j] == key)return mp(i, j);    return mp(-1, -1);}\ntemplate<typename W, typename U> T find(vector<vector<vector<W >>> &a, const U key) {    rep(i, sz(a))rep(j, sz(a[0]))rep(k, sz(a[0][0]))if (a[i][j][k] == key)return mt(i, j, k);    return mt(-1, -1, -1);}\n\n\ntemplate<typename W, typename T> ll count2(W &a, const T k) { return a == k; }\ntemplate<typename W, typename T> ll count2(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\ntemplate<typename W, typename T> ll count(vector<W> &a, const T k) {    ll ret = 0;    fora(v, a)ret += count2(v, k);    return ret;}\nll count(str &a, str k) {    ll ret = 0, len = k.length();    auto pos = a.find(k);    while (pos != string::npos)pos = a.find(k, pos + len), ++ret;    return ret;}\nvi count(str &a) {    vi cou(26);    char c = 'a';    if ('A' <= a[0] && a[0] <= 'Z')c = 'A';    rep(i, sz(a))++cou[a[i] - c];    return cou;}\n#define couif count_if\n//algorythm\n\n\nll rev(ll a) {    ll res = 0;    while (a) {        res *= 10;        res += a % 10;        a /= 10;    }    return res;}\ntemplate<class T> void rev(vector<T> &a) { reverse(all(a)); }\ntemplate<class U> void rev(vector<vector<U>> &a) {    vector<vector<U> > b(sz(a[0]), vector<U>(sz(a)));    rep(h, sz(a)) rep(w, sz(a[0]))b[w][h] = a[h][w];    a = b;}\nvoid  rev(string &a) { reverse(all(a)); }\nconstexpr ll p10[] = {1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000, 10000000000ll, 100000000000ll, 1000000000000ll, 10000000000000ll, 100000000000000ll, 1000000000000000ll, 10000000000000000ll, 100000000000000000ll, 1000000000000000000ll};\n\nll get(ll a, ll keta) { return (a / (ll) pow(10, keta)) % 10; }\nll keta(ll v) { if (v < p10[9]) { if (v < p10[4]) { if (v < p10[2]) { if (v < p10[1]) return 1; else return 2; } else { if (v < p10[3]) return 3; else return 4; }} else { if (v < p10[7]) { if (v < p10[5]) return 5; else if (v < p10[6])return 6; else return 7; } else { if (v < p10[8])return 8; else return 9; }}} else { if (v < p10[13]) { if (v < p10[11]) { if (v < p10[10]) return 10; else return 11; } else { if (v < p10[12]) return 12; else return 13; }} else { if (v < p10[15]) { if (v < p10[14]) return 14; else if (v < p10[15])return 15; else return 16; } else { if (v < p10[17])return 17; else return 18; }}}}\nll dsum(ll v,ll sin=10) {    ll ret = 0;    for (; v; v /= sin)ret += v % sin;    return ret;}\n\nstruct sint {\n    ll v;\n    sint(ll v) : v(v) {}\n    operator ll() { return v; }\n    //下からi番目\n    ll operator[](ll i) { return (v / p10[i]) % 10; }\n    ll back(ll i) { return operator[](i); }\n    //上からi番目\n    ll top(ll i) {\n        ll len = keta(v);\n        return operator[](len - 1 - i);\n    }\n    //先頭からi番目にセット\n    ll settop(ll i, ll k) {\n        ll len = keta(v);\n        return set(len - 1 - i, k);\n    }\n    ll set(ll i, ll k) {\n        if (i < 0)return settop(abs(i) - 1, k);\n        return v += p10[i] * (k - (v / p10[i]) % 10);\n    }\n    ll add(ll i, ll k = 1) { return v += p10[i] * k; }\n    ll addtop(ll i, ll k = 1) { return v += p10[keta(v) - i - 1] * k; }\n    ll dec(ll i, ll k = 1) { return v -= p10[i] * k; }\n    ll dectop(ll i, ll k = 1) { return v -= p10[keta(v) - i - 1] * k; }\n#define op(t, o)template<class T> t operator o(T r){return v o r;}\n    op(ll, +=);    op(ll, -=);    op(ll, *=);    op(ll, /=);    op(ll, %=);    op(ll, +);    op(ll, -);    op(ll, *);    op(ll, /);    op(ll, %);    op(bool, ==);    op(bool, !=);    op(bool, <);    op(bool, <=);    op(bool, >);    op(bool, >=);\n#undef op\n    template<class T>  ll operator<<=(T r) { return v *= p10[r]; }\n    template<class T>  ll operator<<(T r) { return v * p10[r]; }\n    template<class T>  ll operator>>=(T r) { return v /= p10[r]; }\n    template<class T>  ll operator>>(T r) { return v / p10[r]; }\n};\nll mask10(ll v) { return p10[v] - 1; }\n//変換系\ntemplate<class T> auto keys(T a) {    vector<decltype((a.begin())->fi)> res;    for (auto &&k :a)res.push_back(k.fi);    return res;}\ntemplate<class T> auto values(T a) {    vector<decltype((a.begin())->se)> res;    for (auto &&k :a)res.push_back(k.se);    return res;}\ntemplate<class T, class U>  bool chma(T &a, const U &b) {    if (a < b) {        a = b;        return true;    }    return false;}\ntemplate<class U>  bool chma(const U &b) { return chma(ma, b); }\ntemplate<class T, class U>  bool chmi(T &a, const U &b) {    if (b < a) {        a = b;        return true;    }    return false;}\ntemplate<class U>  bool chmi(const U &b) { return chmi(mi, b); }\ntemplate<class T>  T min(T a, signed b) { return a < b ? a : b; }\ntemplate<class T>  T max(T a, signed b) { return a < b ? b : a; }\ntemplate<class T>  T min(T a, T b, T c) { return a >= b ? b >= c ? c : b : a >= c ? c : a; }\ntemplate<class T>  T max(T a, T b, T c) { return a <= b ? b <= c ? c : b : a <= c ? c : a; }\ntemplate<class T>  T min(vector<T>& a) { return *min_element(all(a)); }\ntemplate<class T>  T mini(vector<T>& a) { return min_element(all(a)) - a.begin(); }\ntemplate<class T>  T min(vector<T>& a, ll n) { return *min_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T>  T min(vector<T>& a, ll s, ll n) { return *min_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<class T>  T max(vector<T>& a) { return *max_element(all(a)); }\ntemplate<class T,class U>  T max(vector<T>& a,vector<U>& b) { return max(*max_element(all(a)),*max_element(all(b))); }\ntemplate<class T>  T maxi(vector<T>& a) { return max_element(all(a)) - a.begin(); }\ntemplate<class T>  T max(vector<T>& a, ll n) { return *max_element(a.begin(), a.begin() + min(n, sz(a))); }\ntemplate<class T>  T max(vector<T>& a, ll s, ll n) { return *max_element(a.begin() + s, a.begin() + min(n, sz(a))); }\ntemplate<typename A, size_t N>  A max(A (&a)[N]) {    A res = a[0];    rep(i, N)res = max(res, a[i]);    return res;}template<typename A, size_t N, size_t O>  A max(A (&a)[N][O]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P>  A max(A (&a)[N][O][P]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q>  A max(A (&a)[N][O][P][Q], const T &v) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R>  A max(A (&a)[N][O][P][Q][R]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S>  A max(A (&a)[N][O][P][Q][R][S]) {    A res = max(a[0]);    rep(i, N)res = max(res, max(a[i]));    return res;}\ntemplate<typename A, size_t N>  A min(A (&a)[N]) {    A res = a[0];    rep(i, N)res = min(res, a[i]);    return res;}template<typename A, size_t N, size_t O>  A min(A (&a)[N][O]) {    A res = min(a[0]);    rep(i, N)res = min(res, max(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P>  A min(A (&a)[N][O][P]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q>  A min(A (&a)[N][O][P][Q], const T &v) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R>  A min(A (&a)[N][O][P][Q][R]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}template<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S>  A min(A (&a)[N][O][P][Q][R][S]) {    A res = min(a[0]);    rep(i, N)res = min(res, min(a[i]));    return res;}\ntemplate<class T> T sum(vector<T> &v, ll s = 0, ll t = inf) {    T ret = 0;    rep(i, s, min(sz(v), t))ret += v[i];    return ret;}template<class T> T sum(vector<vector<T> > &v) {    T ret = 0;    rep(i, sz(v))ret += sum(v[i]);    return ret;}template<class T> T sum(vector<vector<vector<T> > > &v) {    T ret = 0;    rep(i, sz(v))ret += sum(v[i]);    return ret;}template<class T> T sum(vector<vector<vector<vector<T> > > > &v) {    T ret = 0;    rep(i, sz(v))ret += sum(v[i]);    return ret;}template<class T> T sum(vector<vector<vector<vector<vector<T> > > > > &v) {    T ret = 0;    rep(i, sz(v))ret += sum(v[i]);    return ret;}template<class T> auto sum(priority_queue<T, vector<T>, greater<T> > &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}template<class T> auto sum(priority_queue<T> &r) {    auto q = r;    T ret = 0;    while (sz(q)) {        ret += q.top();        q.pop();    }    return ret;}\n//template<class T, class U, class... W>  auto sumn(vector<T> &v, U head, W... tail) {    auto ret = sum(v[0], tail...);    rep(i, 1, min(sz(v), head))ret += sum(v[i], tail...);    return ret;}\nvoid clear(PQ &q) { q = PQ(); }\ntemplate<class T> void clear(queue<T> &q) { while (q.size())q.pop(); }\ntemplate<class T> T *negarr(ll size) {    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));    return body + size;}\ntemplate<class T> T *negarr2(ll h, ll w) {    double **dummy1 = new double *[2 * h + 1];    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];    dummy1[0] = dummy2 + w;    for (ll i = 1; i <= 2 * h + 1; ++i) { dummy1[i] = dummy1[i - 1] + 2 * w + 1; }    double **a = dummy1 + h;    return a;}\n//imoは0-indexed\n//ruiは1-indexed\ntemplate<class T> vector<T> imo(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] += ret[i];    return ret;}\n//kと同じものの数\ntemplate<class T, class U> vi imo(vector<T> &a, U k) {vector<T> ret = a;rep(i, sz(ret))ret[i] = a[i] == k;rep(i, sz(ret) - 1)ret[i + 1] += ret[i];return ret;}\ntemplate<class T> vector<T> imox(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)ret[i + 1] ^= ret[i];    return ret;}\n//漸化的に最小を持つ\ntemplate<class T> vector<T> imi(vector<T> &v) {    vector<T> ret = v;    rep(i, sz(ret) - 1)chmi(ret[i + 1], ret[i]);    return ret;}\ntemplate<class T> struct ruiC {    const vector<T> rui;    ruiC(vector<T> &ru) : rui(ru) {}    T operator()(ll l, ll r) {        if (l > r) {            cerr<<\"ruic \";deb(l, r);assert(0);        }        return rui[r] - rui[l];    }    T operator[](ll i) { return rui[i]; }    T back() { return rui.back(); }    ll size() { return rui.size(); }};\ntemplate<class T> struct rruic {    const T *rrui;    rruic(T *ru) : rrui(ru) {}     T operator()(ll l, ll r) {        assert(l >= r);        return rrui[r] - rrui[l];    }     T operator[](ll i) { return rrui[i]; }};\ntemplate<class T> vector<T> ruiv(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i];    return ret;}\ntemplate<class T> ruiC<T> ruic(vector<T> &a) {    vector<T> ret = ruiv(a);    return ruiC<T>(ret);}\nvector<ll> ruiv(string &a) {    if (sz(a) == 0)return vi(1);    ll dec = ('0' <= a[0] && a[0] <= '9') ? '0' : 0;    vector<ll> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + a[i] - dec;    return ret;}\nruiC<ll> ruic(string &a) {    vector<ll> ret = ruiv(a);    return ruiC<ll>(ret);}\n//kと同じものの数\ntemplate<class T, class U> vi ruiv(T &a, U k) {    vi ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] + (a[i] == k);    return ret;}\ntemplate<class T, class U> ruiC<ll> ruic(T &a, U k) {    vi ret = ruiv(a, k);    return ruiC<ll>(ret);}\n//xor\ntemplate<class T> vector<T> ruix(vector<T> &a) {    vector<T> ret(a.size() + 1);    rep(i, a.size())ret[i + 1] = ret[i] ^ a[i];    return ret;}\ntemplate<class T> vector<T> ruim(vector<T> &a) {    vector<T> res(a.size() + 1, 1);    rep(i, a.size())res[i + 1] = res[i] * a[i];    return res;}\n//漸化的に最小を1indexで持つ\ntemplate<class T> vector<T> ruimi(vector<T> &a) {    ll n = sz(a);    vector<T> ret(n + 1);    rep(i, 1, n) {        ret[i] = a[i - 1];        chmi(ret[i + 1], ret[i]);    }    return ret;}\n//template<class T> T *rrui(vector<T> &a) {\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> rruic<T> rrui(vector<T> &a) {    ll len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    rer(i, len - 1)res[i - 1] = res[i] + a[i];    return rruic<T>(res);}\n//掛け算\ntemplate<class T> T *rruim(vector<T> &a) {    ll len = a.size();    T *body = (T *) malloc((len + 1) * sizeof(T));    T *res = body + 1;    res[len - 1] = 1;    rer(i, len - 1)res[i - 1] = res[i] * a[i];    return res;}\ntemplate<class T, class U> void inc(T &a, U v = 1) { a += v; }\ntemplate<class T, class U> void inc(vector<T> &a, U v = 1) { for (auto &u:a)inc(u, v); }\ntemplate<class T, class U> void dec(T &a, U v = 1) { a -= v; }\ntemplate<class T, class U> void dec(vector<T> &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class U> void dec(string &a, U v = 1) { for (auto &u :a)dec(u, v); }\ntemplate<class T> void dec(vector<T> &a) { for (auto &u :a)dec(u, 1); }\nbool ins(ll h, ll w, ll H, ll W) { return h >= 0 && w >= 0 && h < H && w < W; }\nbool ins(ll l, ll v, ll r) { return l <= v && v < r; }\ntemplate<class T> bool ins(vector<T> &a, ll i, ll j = 0) { return ins(0, i, sz(a)) && ins(0, j, sz(a)); }\nll u(ll a) { return a < 0 ? 0 : a; }\ntemplate<class T> vector<T> u(const vector<T> &a) {    vector<T> ret = a;    fora(v, ret)v = u(v);    return ret;}\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\ntemplate<class F> ll goldd_l(ll left, ll right, F calc) {    double GRATIO = 1.6180339887498948482045868343656;    ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));    ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));    ll fl = calc(lm);    ll fr = calc(rm);    while (right - left > 10) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + (ll) ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    ll minScore = MAX(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (minScore > score) {            minScore = score;            resIndex = i;        }    }    return resIndex;}\ntemplate<class F> ll goldt_l(ll left, ll right, F calc) {        double GRATIO = 1.6180339887498948482045868343656;        ll lm = left + (ll) ((right - left) / (GRATIO + 1.0));        ll rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));        ll fl = calc(lm);        ll fr = calc(rm);        while (right - left > 10) {            if (fl > fr) {                right = rm;                rm = lm;                fr = fl;                lm = left + (ll) ((right - left) / (GRATIO + 1.0));                fl = calc(lm);            } else {                left = lm;                lm = rm;                fl = fr;                rm = lm + (ll) ((right - lm) / (GRATIO + 1.0));                fr = calc(rm);            }        }    if (left > right) {        ll l = left;        left = right;        right = l;    }    ll maxScore = MIN(ll);    ll resIndex = left;    for (ll i = left; i < right + 1; ++i) {        ll score = calc(i);        if (maxScore < score) {            maxScore = score;            resIndex = i;        }    }    return resIndex;}\n/*loopは200にすればおそらく大丈夫 余裕なら300に*/\ntemplate<class F> dou goldd_d(dou left, dou right, F calc, ll loop = 140) {    dou GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    /*200にすればおそらく大丈夫*/    /*余裕なら300に*/    ll k = 141;    loop++;    while (--loop) {        if (fl < fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\ntemplate<class F> dou goldt_d(dou left, dou right, F calc, ll loop = 140) {    double GRATIO = 1.6180339887498948482045868343656;    dou lm = left + ((right - left) / (GRATIO + 1.0));    dou rm = lm + ((right - lm) / (GRATIO + 1.0));    dou fl = calc(lm);    dou fr = calc(rm);    loop++;    while (--loop) {        if (fl > fr) {            right = rm;            rm = lm;            fr = fl;            lm = left + ((right - left) / (GRATIO + 1.0));            fl = calc(lm);        } else {            left = lm;            lm = rm;            fl = fr;            rm = lm + ((right - lm) / (GRATIO + 1.0));            fr = calc(rm);        }    }    return left;}\n//l ~ rを複数の区間に分割し、極致を与えるiを返す time-20 msまで探索\ntemplate<class F> ll goldd_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll mini = 0, minv = MAX(ll);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldd_l(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> ll goldt_ls(ll l, ll r, F calc, ll time = 2000) {    auto lim = milliseconds(time - 20);    ll maxi = 0, maxv = MIN(ll);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        ll haba = (r - l + k) / k;/*((r-l+1) + k-1) /k*/        ll nl = l;        ll nr = l + haba;        rep(i, k) {            ll ni = goldt_l(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class F> dou goldd_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を持つ*/    auto lim = milliseconds(time - 20);    dou mini = 0, minv = MAX(dou);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldd_d(nl, nr, calc);            if (chmi(minv, calc(ni))) mini = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return mini;}\ntemplate<class F> dou goldt_d_s(dou l, dou r, F calc, ll time = 2000) {    /*20ms余裕を残している*/    auto lim = milliseconds(time - 20);    dou maxi = 0, maxv = MIN(dou);    /*区間をk分割する*/    rep(k, 1, inf) {        auto s = system_clock::now();        dou haba = (r - l) / k;        dou nl = l;        dou nr = l + haba;        rep(i, k) {            dou ni = goldt_d(nl, nr, calc);            if (chma(maxv, calc(ni))) maxi = ni;            nl = nr;            nr = nl + haba;        }        auto end = system_clock::now();        auto part = duration_cast<milliseconds>(end - s);        auto elapsed = duration_cast<milliseconds>(end - start_time);        if (elapsed + part * 2 >= lim) { break; }    }    return maxi;}\ntemplate<class T> T min(vector<vector<T >> &a) {    T res = MAX(T);    rep(i, a.size())chmi(res, *min_element(all(a[i])));    return res;}\ntemplate<class T> T max(vector<vector<T >> &a) {    T res = MIN(T);    rep(i, a.size())chma(res, *max_element(all(a[i])));    return res;}\nconstexpr bool bget(ll m, ll keta) { return (m >> keta) & 1; }\nll bget(ll m, ll keta, ll sinsuu) {    m /= (ll) pow(sinsuu, keta);    return m % sinsuu;}\nll bit(ll n) { return (1LL << (n)); }\nll bit(ll n, ll sinsuu) { return (ll) pow(sinsuu, n); }\nll mask(ll n) { return (1ll << n) - 1; }\n#define bcou __builtin_popcountll\n//最下位ビット\nll lbit(ll n) { return n & -n; }\n//最上位ビット\nll hbit(ll n) {    n |= (n >> 1);    n |= (n >> 2);    n |= (n >> 4);    n |= (n >> 8);    n |= (n >> 16);    n |= (n >> 32);    return n - (n >> 1);}\nll hbitk(ll n) {    ll k = 0;    rer(i, 5) {        ll a = k + (1ll << i);        ll b = 1ll << a;        if (b <= n)k += 1ll << i;    }    return k;}\n//初期化は0を渡す\nll nextComb(ll &mask, ll n, ll r) {    if (!mask)return mask = (1LL << r) - 1;    ll x = mask & -mask; /*最下位の1*/    ll y = mask + x; /*連続した下の1を繰り上がらせる*/    ll res = ((mask & ~y) / x >> 1) | y;    if (bget(res, n))return mask = 0; else return mask = res;}\n//n桁以下でビットがr個立っているもののvectorを返す\nvi bitCombList(ll n, ll r) {    vi res;    ll m = 0;    while (nextComb(m, n, r)) { res.push_back(m); }    return res;}\nchar itoal(ll i) { return 'a' + i; }\nchar itoaL(ll i) { return 'A' + i; }\nll altoi(char c) {    if ('A' <= c && c <= 'Z')return c - 'A';    return c - 'a';}\nll ctoi(char c) { return c - '0'; }\nchar itoc(ll i) { return i + '0'; }\nll vtoi(vi &v) {    ll res = 0;    if (sz(v) > 18) {        debugline(\"vtoi\");        deb(sz(v));        ole();    }    rep(i, sz(v)) {        res *= 10;        res += v[i];    }    return res;}\nvi itov(ll i) {    vi res;    while (i) {        res.push_back(i % 10);        i /= 10;    }    rev(res);    return res;}\nvi stov(string &a) {    ll n = sz(a);    vi ret(n);    rep(i, n) { ret[i] = a[i] - '0'; }    return ret;}\n//基準を満たさないものは0になる\nvi stov(string &a, char one) {    ll n = sz(a);    vi ret(n);    rep(i, n)ret[i] = a[i] == one;    return ret;}\nvector<vector<ll>> ctoi(vector<vector<char>> s, char c) {    ll n = sz(s), m = sz(s[0]);    vector<vector<ll>> res(n, vector<ll>(m));    rep(i, n)rep(j, m)res[i][j] = s[i][j] == c;    return res;}\n#define unique(v) v.erase( unique(v.begin(), v.end()), v.end() );\n//[i] := i番として圧縮されたものを返す\nvi compress(vi &a) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, umap<ll, ll> &map) {    vi b;    ll len = a.size();    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) {        ll v = a[i];        a[i] = lower_bound(all(b), a[i]) - b.begin();        map[v] = a[i];    }    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vi &a, vi &r, vi &s) {    vi b;    ll len = a.size();    fora(v, a)b.push_back(v);    fora(v, r)b.push_back(v);    fora(v, s)b.push_back(v);    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) a[i] = lower_bound(all(b), a[i]) - b.begin();    for (ll i = 0; i < sz(r); ++i) r[i] = lower_bound(all(b), r[i]) - b.begin();    for (ll i = 0; i < sz(s); ++i) r[i] = lower_bound(all(b), s[i]) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(V<vi> &a) {    vi b;    fora(vv, a)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vv, a)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvi compress(vector<vector<vi >> &a) {    vi b;    fora(vvv, a)fora(vv, vvv)fora(v, vv)b.push_back(v);    sort(b);    unique(b);    fora(vvv, a)fora(vv, vvv)fora(v, vv)v = lower_bound(all(b), v) - b.begin();    ll blen = sz(b);    vi ret(blen);    rep(i, blen) { ret[i] = b[i]; }    return ret;}\nvoid compress(ll a[], ll len) {    vi b;    for (ll i = 0; i < len; ++i) { b.push_back(a[i]); }    sort(b);    unique(b);    for (ll i = 0; i < len; ++i) { a[i] = lower_bound(all(b), a[i]) - b.begin(); }}\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define lowerBound(a, v) (*lower_bound(all(a),v))\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define upperBound(a, v) (*upper_bound(all(a),v))\ntemplate<class T> void fin(T s) { cout << s << endl, exit(0); }\n\n//便利 数学 math\nll mod(ll a, ll m) { return (a % m + m) % m; }\nll pow(ll a) { return a * a; };\nll fact(ll v) { return v <= 1 ? 1 : v * fact(v - 1); }\n\nll comi(ll n, ll r) {    assert(n < 100);    static vvi(pas, 100, 100);    if (pas[0][0])return pas[n][r];    pas[0][0] = 1;    rep(i, 1, 100) {        pas[i][0] = 1;        rep(j, 1, i + 1)pas[i][j] = pas[i - 1][j - 1] + pas[i - 1][j];    }    return pas[n][r];}\ndouble comd(ll n, ll r) {    assert(n < 2020);    static vvd(comb, 2020, 2020);    if (comb[0][0] == 0) {        comb[0][0] = 1;        rep(i, 2000) {            comb[i + 1][0] = 1;            rep(j, 1, i + 2) {                comb[i + 1][j] = comb[i][j] + comb[i][j - 1];            }        }    }    return comb[n][r];}\nll gcd(ll a, ll b) {while (b) a %= b, swap(a, b);return abs(a);}\nll gcd(vi b) {ll res = b[0];rep(i, 1, sz(b))res = gcd(b[i], res);return res;}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\nll lcm(vi a) {ll res = a[0];rep(i, 1, sz(a))res = lcm(a[i], res);return res;}\nll ceil(ll a, ll b) {if (b == 0) {debugline(\"ceil\");deb(a, b);ole();return -1;} else if (a < 0) { return 0; } else { return (a + b - 1) / b; }}\nll lower_remi__bx_a(ll kei, ll rem, ll x) {if (rem >= x) return 0;return (x - rem + kei - 1) / kei;}\nll lower_remv__bx_a(ll kei, ll rem, ll x) {if (rem >= x) return rem;return (x - rem + kei - 1) / kei * kei + rem;}\nll upper_remi__bx_a(ll kei, ll rem, ll x) {if (rem > x) return 0;return (x - rem + kei) / kei;}\nll upper_remv__bx_a(ll kei, ll rem, ll x) {if (rem > x) return rem;return (x - rem + kei) / kei * kei + rem;}\n//v * v >= aとなる最小のvを返す\nll sqrt(ll a) {if (a < 0) {debugline(\"sqrt\");deb(a);ole();}ll res = (ll) std::sqrt(a);while (res * res < a)++res;return res;}\ndouble log(double e, double x) { return log(x) / log(e); }\nll sig(ll t) { return ((1 + t) * t) >> 1; }\nll sig(ll s, ll t) { return ((s + t) * (t - s + 1)) >> 1; }\n\n\n//幾何 Pをcomplexとして扱う\ntemplate<class T, class U> bool eq(T a, U b) { return fabs(a - b) < eps; }\ndou atan2(pd a) { return atan2(a.se, a.fi); }\ndou angle(pd f, pd t) { return atan2(t.se - f.se, t.fi - f.fi); }\ndou distance(pd a, pd b) { return hypot(a.fi - b.fi, a.se - b.se); }\n//bを中心とするabcのtheta aからcにかけて時計回り\ndou angle(pd a, pd b, pd c) {    dou ax = a.fi - b.fi;    dou ay = a.se - b.se;    dou cx = c.fi - b.fi;    dou cy = c.se - b.se;    double ret = atan2(cy, cx) - atan2(ay, ax);    if (ret < 0) ret += 2 * PI;    return ret;}\n\ndou dot(pd a, pd b) { return a.fi * b.fi + a.se + b.se; }\ndou cro(pd a, pd b) { return a.fi * b.se - a.se + b.fi; }\n\n//機能拡張\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) { a.push(v); }template<class T, class U> void operator+=(deque<T> &a, U v) { a.push_back(v); }template<class T> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, vector<T> &v) {    fora(d, v)a.push(d);    return a;}template<class T, class U> priority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {    a.push(v);    return a;}template<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {    a.push(v);    return a;}template<class T> set<T> &operator+=(set<T> &a, vector<T> v) {    fora(d, v)a.insert(d);    return a;}template<class T, class U> auto operator+=(set<T> &a, U v) { return    a.insert(v);}template<class T, class U> auto operator-=(set<T> &a, U v) { return    a.erase(v);}template<class T, class U> auto operator+=(mset<T> &a, U v) { return a.insert(v); }template<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {    a.insert(v);    return a;}template<class T, class U> vector<T> &operator+=(vector<T> &a, U v) {    a.push_back(v);    return a;}template<class T, class U> vector<T> operator+(const vector<T> &a, U v) {    vector<T> ret = a;    ret += v;    return ret;}template<class T, class U> vector<T> operator+(U v, const vector<T> &a) {    vector<T> ret = a;    ret.insert(ret.begin(), v);    return ret;}template<class T> vector<T> operator+(vector<T> a, vector<T> b) {    vector<T> ret;    ret = a;    fora(v, b)ret += v;    return ret;}template<class T> vector<T> &operator+=(vector<T> &a, vector<T> &b) {    fora(v, b)a += v;    return a;}template<class T> vector<T> &operator-=(vector<T> &a, vector<T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-=\");        deb(a);        deb(b);        exit(0);    }    rep(i, sz(a))a[i] -= b[i];    return a;}\ntemplate<class T> vector<T> operator-(vector<T> &a, vector<T> &b) {    if (sz(a) != sz(b)) {        debugline(\"vector<T> operator-\");        deb(a);        deb(b);        ole();    }    vector<T> res(sz(a));    rep(i, sz(a))res[i] = a[i] - b[i];    return res;}\ntemplate<class T, class U> vector<T> operator*(vector<T> &a, U b) {    vector<T> ret;    fora(v, a)ret += v * b;    return ret;}\ntemplate<class T, class U> vector<T> operator/(vector<T> &a, U b) {    vector<T> ret;    fora(v, a)ret += v / b;    return ret;}\ntemplate<class T, class U> vector<T> operator*=(vector<T> &a, U b) {    fora(v, a)v *= b;    return a;}\ntemplate<class T, class U> vector<T> operator/=(vector<T> &a, U b) {    fora(v, a)v /= b;    return a;}\ntemplate<typename T> void erase(vector<T> &v, unsigned ll i) { v.erase(v.begin() + i); }\ntemplate<typename T> void erase(vector<T> &v, unsigned ll s, unsigned ll e) { v.erase(v.begin() + s, v.begin() + e); }\ntemplate<class T, class U> void erase(map<T, U> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<class T> void erase(set<T> &m, ll okl, ll ngr) { m.erase(m.lower_bound(okl), m.lower_bound(ngr)); }\ntemplate<typename T> void erasen(vector<T> &v, unsigned ll s, unsigned ll n) { v.erase(v.begin() + s, v.begin() + s + n); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, U t) { v.insert(v.begin() + i, t); }\ntemplate<typename T, typename U> void push_front(vector<T> &v, U t) { v.insert(v.begin(), t); }\ntemplate<typename T, typename U> void insert(vector<T> &v, unsigned ll i, vector<T> list) { for (auto &&va:list)v.insert(v.begin() + i++, va); }\ntemplate<typename T> void insert(set<T> &v, vector<T> list) { for (auto &&va :list)v.insert(va); }\nvector<string> split(const string a, const char deli) {    string b = a + deli;    ll l = 0, r = 0, n = b.size();    vector<string> res;    rep(i, n) {        if (b[i] == deli) {            r = i;            if (l < r)res.push_back(b.substr(l, r - l));            l = i + 1;        }    }    return res;}\nvector<string> split(const string a, const string deli) {    vector<string> res;    ll kn = sz(deli);    std::string::size_type Pos(a.find(deli));    ll l = 0;    while (Pos != std::string::npos) {        if (Pos - l)res.push_back(a.substr(l, Pos - l));        l = Pos + kn;        Pos = a.find(deli, Pos + kn);    }    if (sz(a) - l)res.push_back(a.substr(l, sz(a) - l));    return res;}\nvoid yn(bool a) { if (a)cout << \"yes\" << endl; else cout << \"no\" << endl; }\nvoid Yn(bool a) { if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl; }\nvoid YN(bool a) { if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl; }\nvoid fyn(bool a) {    if (a)cout << \"yes\" << endl; else cout << \"no\" << endl;    exit(0);}\nvoid fYn(bool a) {    if (a)cout << \"Yes\" << endl; else cout << \"No\" << endl;    exit(0);}\nvoid fYN(bool a) {    if (a)cout << \"YES\" << endl; else cout << \"NO\" << endl;    exit(0);}\nvoid Possible(bool a) {    if (a)cout << \"Possible\" << endl; else cout << \"Impossible\" << endl;    exit(0);}\nvoid POSSIBLE(bool a) {    if (a)cout << \"POSSIBLE\" << endl; else cout << \"IMPOSSIBLE\" << endl;    exit(0);}\n//@formatter:off\ntemplate<typename T> T minv(T a, T m);\ntemplate<typename T> T minv(T a);\n\ntemplate<typename T>\nclass Modular {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;    constexpr Modular() : value() {}    template<typename U>    Modular(const U &x) {        value = normalize(x);    }    template<typename U>    static Type normalize(const U &x) {        Type v;        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);        else v = static_cast<Type>(x % mod());        if (v < 0) v += mod();        return v;    }    const Type &operator()() const { return value; }    template<typename U>explicit operator U() const { return static_cast<U>(value); }    constexpr static Type mod() { return T::value; }    Modular &operator+=(const Modular &other) {        if ((value += other.value) >= mod()) value -= mod();        return *this;    }    Modular &operator-=(const Modular &other) {        if ((value -= other.value) < 0) value += mod();        return *this;    }    template<typename U> Modular &operator+=(const U &other) { return *this += Modular(other); }    template<typename U> Modular &operator-=(const U &other) { return *this -= Modular(other); }    Modular &operator++() { return *this += 1; }    Modular &operator--() { return *this -= 1; }    Modular operator++(signed) {        Modular result(*this);        *this += 1;        return result;    }    Modular operator--(signed) {        Modular result(*this);        *this -= 1;        return result;    }    Modular operator-() const { return Modular(-value); }\n    template<typename U = T>typename enable_if<is_same<typename Modular<U>::Type, signed>::value, Modular>::type &operator*=(const Modular &rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;asm(\"divl %4; \\n\\t\": \"=a\" (d), \"=d\" (m): \"d\" (xh), \"a\" (xl), \"r\" (mod()));value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template<typename U = T>    typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type &operator*=(const Modular &rhs) {        int64_t q = static_cast<int64_t>(static_cast<double>(value) * rhs.value / mod());        value = normalize(value * rhs.value - q * mod());        return *this;    }    template<typename U = T>    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type &operator*=(const Modular &rhs) {        value = normalize(value * rhs.value);        return *this;    }    Modular &operator/=(const Modular &other) { return *this *= Modular(minv(other.value)); }    template<typename U> friend bool operator==(const Modular<U> &lhs, const Modular<U> &rhs);    template<typename U> friend bool operator<(const Modular<U> &lhs, const Modular<U> &rhs);    template<typename U> friend std::istream &operator>>(std::istream &stream, Modular<U> &number);    operator int() { return value; }private:    Type value;\n};\ntemplate<typename T> bool operator==(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value == rhs.value; }template<typename T, typename U> bool operator==(const Modular<T> &lhs, U rhs) { return lhs == Modular<T>(rhs); }template<typename T, typename U> bool operator==(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) == rhs; }template<typename T> bool operator!=(const Modular<T> &lhs, const Modular<T> &rhs) { return !(lhs == rhs); }template<typename T, typename U> bool operator!=(const Modular<T> &lhs, U rhs) { return !(lhs == rhs); }template<typename T, typename U> bool operator!=(U lhs, const Modular<T> &rhs) { return !(lhs == rhs); }template<typename T> bool operator<(const Modular<T> &lhs, const Modular<T> &rhs) { return lhs.value < rhs.value; }template<typename T> Modular<T> operator+(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }template<typename T, typename U> Modular<T> operator+(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) += rhs; }template<typename T, typename U> Modular<T> operator+(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) += rhs; }template<typename T> Modular<T> operator-(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }template<typename T, typename U> Modular<T> operator-(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) -= rhs; }template<typename T, typename U> Modular<T> operator-(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) -= rhs; }template<typename T> Modular<T> operator*(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }template<typename T, typename U> Modular<T> operator*(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) *= rhs; }template<typename T, typename U> Modular<T> operator*(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) *= rhs; }template<typename T> Modular<T> operator/(const Modular<T> &lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }template<typename T, typename U> Modular<T> operator/(const Modular<T> &lhs, U rhs) { return Modular<T>(lhs) /= rhs; }template<typename T, typename U> Modular<T> operator/(U lhs, const Modular<T> &rhs) { return Modular<T>(lhs) /= rhs; }\n\nconstexpr signed MOD =\n//        998244353;\n1e9 + 7;//MOD\nusing mint = Modular<std::integral_constant<decay<decltype(MOD)>::type, MOD>>;\nconstexpr int mint_len = 1400001;\nvi fac, finv, inv;\nvi p2;\nmint com(int n, int r) {    if (r < 0 || r > n) return 0;    return mint(finv[r] * fac[n] % MOD * finv[n - r]);}\nmint pom(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;    return mint(fac[n] * finv[n - 1]);}\nmint npr(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;    return mint(fac[n] * finv[n - r]);}\nint nprin(int n, int r) {/*    if (!sz(fac)) com(0, -1);*/    if (r < 0 || r > n) return 0;    return fac[n] * finv[n - r] % MOD;}\nint icom(int n, int r) {    const int NUM_ = 1400001;    static ll fac[NUM_ + 1], finv[NUM_ + 1], inv[NUM_ + 1];    if (fac[0] == 0) {        inv[1] = fac[0] = finv[0] = 1;        for (int i = 2; i <= NUM_; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;        for (int i = 1; i <= NUM_; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;    }    if (r < 0 || r > n) return 0;    return ((finv[r] * fac[n] % MOD) * finv[n - r]) % MOD;}\n#define ncr com\n#define ncri icom\n//n個の場所にr個の物を置く\nmint nhr(int n, int r) { return com(n + r - 1, r); }\nmint hom(int n, int r) { return com(n + r - 1, r); }\nint nhri(int n, int r) { return icom(n + r - 1, r); }\ntemplate<typename T> T minv(T a, T m) {    T u = 0, v = 1;    while (a != 0) {        T t = m / a;        m -= t * a;        swap(a, m);        u -= t * v;        swap(u, v);    }    assert(m == 1);    return u;}\ntemplate<typename T> T minv(T a) {    if (a < mint_len)return inv[a];    T u = 0, v = 1;    T m = MOD;    while (a != 0) {        T t = m / a;        m -= t * a;        swap(a, m);        u -= t * v;        swap(u, v);    }    assert(m == 1);    return u;}\ntemplate<typename T, typename U> Modular<T> mpow(const Modular<T> &a, const U &b) {    assert(b >= 0);    int x = a(), res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= MOD;        (x *= x) %= MOD;        p >>= 1;    }    return res;}\ntemplate<typename T, typename U, typename V> mint mpow(const T a, const U b, const V m = MOD) {    assert(b >= 0);    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= m;        (x *= x) %= m;        p >>= 1;    }    return res;}\ntemplate<typename T, typename U> mint mpow(const T a, const U b) {    assert(b >= 0);    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= MOD;        (x *= x) %= MOD;        p >>= 1;    }    return res;}\ntemplate<typename T, typename U, typename V> int mpowi(const T &a, const U &b, const V &m = MOD) {    assert(b >= 0);    int x = a, res = 1;    U p = b;    while (p > 0) {        if (p & 1) (res *= x) %= m;        (x *= x) %= m;        p >>= 1;    }    return res;}\ntemplate<typename T> string to_string(const Modular<T> &number) {    return to_string(number());}\nstring yuri(const mint &a) {    stringstream st;    rep(i, 300) {rep(j, 300) {if ((mint) i / j == a) {st << i << \" / \" << j;return st.str();}}}    rep(i, 1000) {rep(j, 1000) {if ((mint) i / j == a) {st << i << \" / \" << j;return st.str();}}}    return st.str();}\ntemplate<typename T> std::ostream &operator<<(std::ostream &stream, const Modular<T> &number) {stream << number();\n#ifdef _DEBUG\n//    stream << \" -> \" << yuri(number);\n#endif\n    return stream;\n}\n//@formatter:off\ntemplate<typename T> std::istream &operator>>(std::istream &stream, Modular<T> &number) {    typename common_type<typename Modular<T>::Type, int64_t>::type x;    stream >> x;    number.value = Modular<T>::normalize(x);    return stream;}\nusing PM = pair<mint, mint>;\nusing vm = vector<mint>;\nusing mapm = map<int, mint>;\nusing umapm = umap<int, mint>;\n#define vvm(...) o_vvt(__VA_ARGS__,vvt4,vvt3,vvt2 ,vvt1,vvt0)(mint,__VA_ARGS__)\n#define vnm(name, ...) auto name = make_v<mint>(__VA_ARGS__)\n\nstruct setmod{\n    setmod() {\n//    p2.resize(mint_len);p2[0] = 1; for (int i = 1; i < mint_len; ++i) p2[i] = p2[i - 1] * 2 % MOD;\n        fac.resize(mint_len);    finv.resize(mint_len);    inv.resize(mint_len);    inv[1] = fac[0] = finv[0] = 1;    for (int i = 2; i < mint_len; ++i) inv[i] = inv[MOD % i] * (MOD - MOD / i) % MOD;    for (int i = 1; i < mint_len; ++i) fac[i] = fac[i - 1] * i % MOD, finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}setmodv;\n//@formatter:on\n//nhr n個の場所にr個の物を分ける\n\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} initonv;//@formatter:on\n\n//gra mll pr\n//上下左右\nconst string udlr = \"udlr\";\nstring UDLR = \"UDLR\";//x4と連動 UDLR.find('U') := x4[0]\n//右、上が正\nconstexpr ll y4[] = {1, -1, 0, 0};\nconstexpr ll x4[] = {0, 0, -1, 1};\nconstexpr ll y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconstexpr ll x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n\nll n, m, k, d, H, W, x, y, z, q;\nll cou;\nvi t, a, b, c;\n//vvi (s, 0, 0);\nvvc (ba, 0, 0);\nvp p;\nstr s;\nstruct pbds_sum {\n    //@formatter:off\n    template<typename T = int> class BIT {\n    public:\n        int n;        vector<T> dat;        BIT(int n) : n(n) { dat.assign(n, 0); }        T sum(int k) {            if (k >= n) k = n - 1;            T ret = 0;            for (int x = k - 1; x >= 0; x = (x & (x + 1)) - 1) { ret += dat[x]; }            return ret;        }        T sum(int l, int r) { return sum(r) - sum(l); }        T get(int l, int r) { return sum(r) - sum(l); }        T get(int k) { return sum(k); }        T operator[](int k) {            assert(0 <= k && k < n);            return sum(k + 1) - sum(k);        }        T operator()(int k) { return sum(k); }        T operator()(int l, int r) { return sum(l, r); }        void add(int k, T val = 1) { for (int x = k; x < n; x |= x + 1)dat[x] += val; }        void update(int k, T val = 0) { add(k, -operator[](k) + val); }        void del(int k) { update(k, 0); }        void clear() { fill(dat, 0); }        void debu() {\n#ifdef _DEBUG\n            vi res;            rep(i, min(10ll, n)) { res.push_back(operator[](i)); }            deb(res);\n#endif\n        }\n        int lower_bound(int w) {            if (w <= 0) return -1;            int x = 0;            int k = 1;            while ((k << 1) <= n) k <<= 1;            for (; k > 0; k >>= 1) {                if (x + k <= n && dat[x + k - 1] < w) {                    w -= dat[x + k - 1];                    x += k;                }            }            return x;        }\n    };\n    BIT<int> bco, bsu;\n    umapi v_i;\n    vi i_v;\n    int count = 0;\n    //クエリの順番が分かってる場合の高速化はとりあえずしない(十分高速なため)\n    //クエリの順番が入れ替わってもいいようにする\n    pbds_sum(vi &a) : bco(sz(a) + 3), bsu(sz(a) + 3) {        vi b = a;        b.push_back(linf + 100);        i_v = compress(b);        rep(i, sz(a)) { v_i[a[i]] = b[i]; }    }\n    pbds_sum(vi &a, vi &b) : bco(sz(a) + sz(b) + 3), bsu(sz(a) + sz(b) + 3) {        vi c = a;        vi d = b;        c.push_back(linf + 100);        d.push_back(linf + 100);        i_v = compress(c, d);        rep(i, sz(a)) {            v_i[a[i]] = c[i];            v_i[b[i]] = d[i];        }    }\n    pbds_sum(vi &a, vi &b, vi &c) : bco(sz(a) + sz(b) + sz(c) + 3), bsu(sz(a) + sz(b) + sz(c) + 3) {        vi d = a;        vi e = b;        vi f = c;        d.push_back(linf + 100);        e.push_back(linf + 100);        f.push_back(linf + 100);        i_v = compress(d, e, f);        rep(i, sz(a)) {            v_i[a[i]] = d[i];            v_i[b[i]] = e[i];            v_i[c[i]] = f[i];        }    }\n    void add(int v, int c = 1) {count += c;        int ind = v_i[v];        bco.add(ind, c);        bsu.add(ind, v * c);    }\n    void operator+=(int v){int c=1;        count += c;        int ind = v_i[v];        bco.add(ind, c);        bsu.add(ind, v * c);    }\n    //開区間\n    int sum() {return bsu.sum(inf);    }\n    int sum(int rv) {        int i = (std::lower_bound(all(i_v), rv) - i_v.begin());        return bsu.sum(i);    }\n    //半開区間 l rは存在しない値でもいい\n    int sum(int l, int r) { return sum(r) - sum(l); }\n    //クエリ候補全ての中でのi\n    int sum_it(int li, int ri) {return bsu.sum(ri) - bsu.sum(li);}\n    //[l番目からr)番目の合計(種類数ではなく重複込みの番号)\n    //r個の合計\n    int sum_order(int r) {        int rti = bco.lower_bound(r + 1);        int res = bsu.sum(rti);        if (rti != bco.n) {            int l = bco.sum(rti);            res += (r - l) * i_v[rti];        }        return res;    }\n    //右からr個の合計\n    int sum_order_r(int r) {        int a = bsu.sum(0, inf);        int b = sum_order(count - r);        return a - b;    }\n    /*@formatter:off*/\n    int sum_order(int l,int r){return sum_order(r)-sum_order(l);}\n    int cou(int rv) {int i = (std::lower_bound(all(i_v), rv) - i_v.begin());return bco.sum(i);}\n    //半開区間 l rは存在しない値でもいい\n    int cou(int l, int r) { return cou(r) - cou(l); }\n    int cou_it(int ri) {        return bco.sum(ri);    }\n    int cou_it(int li, int ri) {        return bco.sum(ri) - bco.sum(li);    }\n    //k番目の要素を返す\n    int find_by_order(int k) {        int i = bco.lower_bound(k + 1);        if (i >= sz(i_v)) {            cerr << \"find_by_order(\" << k << \") k >=\" << sz(i_v) << endl;            exit(0);        }        return i_v[i];    }\n    //vは何番目に入るか\n    int order_of_key(int v) {        v = *std::lower_bound(all(i_v), v);        int i = v_i[v];        return bco.sum(i);    }\n    //中央値を返す (左寄り)\n    int mid() { return find_by_order((count - 1) >> 1); }\n    int mid(int lv, int rv) {        int lcou = cou(lv);        int rcou = cou(rv);        int wantk = lcou + ((rcou - lcou - 1) >> 1);        return find_by_order(wantk);    }\n    int mid_it(int li, int ri) {        int lcou = bco.sum(li );        int rcou = bco.sum(ri );        int wantk = lcou + ((rcou - lcou - 1) >> 1);        return find_by_order(wantk);    }\n    int mid_it(int ri) {        return mid_it(0, ri);    }\n    //全要素との 最小の差の和をかえす (全要素の中央値との差の和)\n    int min_dis() {        int mv = mid();        int mi = v_i[mv];        int lcou = bco.sum(mi);        int rcou = bco.sum(mi + 1, linf);        int lsum = mv * lcou - bsu.sum(mi);        int rsum = bsu.sum(mi + 1, linf) - mv * rcou;        return lsum + rsum;    }\n    int min_dis(int lv, int rv) {        int li = (std::lower_bound(all(i_v), lv) - i_v.begin());        int ri = (std::lower_bound(all(i_v), rv) - i_v.begin());        int mv = mid_it(li, ri);        int mi = v_i[mv];        int lcou = cou_it(li, mi);        int rcou = cou_it(mi, ri);        return mv * lcou - sum_it(li, mi) + sum_it(mi, ri) - mv * rcou;    }\n    int min_dis_i(int li, int ri) {        int mv = mid_it(li, ri);        int mi = v_i[mv];        int lcou = cou_it(li, mi);        int rcou = cou_it(mi, ri);        return mv * lcou - sum_it(li, mi) + sum_it(mi, ri) - mv * rcou;    }\n    //vをc個消す\n    void erase(int v, int c = 1) {        int ind = v_i[v];        if(bco[ind] < c){            if(count ==0){                cerr<<\"all is empty. count == 0\"<< endl;            }            assert(bco[ind] < c);        }        count -= c;        bco.add(ind, -c);        bsu.add(ind, v * -c);    }\n    void operator-=(int v){erase(v);}\n    int lower_bound(int v) {        v = *std::lower_bound(all(i_v), v);        int i = v_i[v];        int needc = bco.sum(i) + 1;        i = bco.lower_bound(needc);        return i_v[i];    }\n    int upper_bound(int v) { return lower_bound(v + 1); }\n    void debu(){        bsu.debu();        bco.debu();        cerr<<\"\"<<endl;    }\n    //@formatter:on\n};\n\n//固定された要素に使う場合は\n//pbds_con\n//itは圧縮後のインデックスであり\n//自然に使おうとするとおかしくなるため\n\n\nvoid solve() {\n    in(n, q);\n    n *= 2;\n    na(a, n);\n    na(b, n);\n    dna3(p, x, y, q);\n    vi c = a - b;\n    vi d = c + (x - y);\n    pbds_sum s(d);\n    int base = a[0] + a[n - 1];\n    rep(i, 1, n - 1) {\n        base += b[i];\n        s += c[i];\n    }\n    rep(i, q) {\n        int pp = p[i] - 1;\n        int xx = x[i];\n        int yy = y[i];\n        if (pp == 0 || pp == n - 1) {\n            base -= a[pp];\n            a[pp] = xx;\n            b[pp] = yy;\n            base += a[pp];\n        } else {\n            base -= b[pp];\n            s -= a[pp] - b[pp];\n            a[pp] = xx;\n            b[pp] = yy;\n            s += a[pp] - b[pp];\n            base += b[pp];\n        }\n        auto cal = [&](int k) {\n            return s.sum_order_r(k * 2);\n        };\n        int k = goldt_l(0, n / 2 - 1, cal);\n        cout <<base+ s.sum_order_r(k * 2) << endl;;\n    }\n\n}\nauto my(ll n, vi &a) {\n    return 0;\n}\nauto sister(ll n, vi &a) {\n    ll ret = 0;\n    return ret;\n}\n\nsigned main() {\n    solve();\n\n#define arg n,a\n#ifdef _DEBUG\n    bool bad = 0;\n    for (ll i = 0, ok = 1; i < k5 && ok; ++i) {\n        ll n = rand(1, 8);\n        vi a = ranv(n, 1, 10);\n        auto myres = my(arg);\n        auto res = sister(arg);\n        ok = myres == res;\n        if (!ok) {\n            out(arg);\n            cerr << \"AC : \" << res << endl;\n            cerr << \"MY  : \" << myres << endl;\n            bad = 1;\n            break;\n        }\n    }\n    if (!bad) {\n//        cout << \"完璧 : solveを書き直そう\" << endl;\n//        cout << \"     : そして、solve()を呼び出すのだ\" << endl;\n//        cout << \"     : cin>>n; na(a,n);も忘れるな\" << endl;\n    }\n#endif\n    return 0;\n};\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint N, Q, pos, x, y, a[200009], b[200009]; map<int, int> d;\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tcin >> N >> Q;\n\tfor (int i = 0; i < 2 * N; i++) cin >> a[i];\n\tfor (int i = 0; i < 2 * N; i++) cin >> b[i];\n\tlong long s = 0; int c = 0;\n\tfor (int i = 0; i < 2 * N; i++) {\n\t\tif (i == 0 || i == 2 * N - 1) s += a[i];\n\t\telse {\n\t\t\tif (a[i] > b[i]) c++;\n\t\t\ts += max(a[i], b[i]);\n\t\t\td[abs(a[i] - b[i])]++;\n\t\t}\n\t}\n\tfor (int i = 0; i < Q; i++) {\n\t\tcin >> pos >> x >> y; pos--;\n\t\tif (pos == 0 || pos == N - 1) {\n\t\t\ts -= a[pos];\n\t\t\ta[pos] = x; b[pos] = y;\n\t\t\ts += a[pos];\n\t\t}\n\t\telse {\n\t\t\tif (a[pos] > b[pos]) c--;\n\t\t\ts -= max(a[pos], b[pos]);\n\t\t\td[abs(a[pos] - b[pos])]--;\n\t\t\tif (d[abs(a[pos] - b[pos])] == 0) d.erase(abs(a[pos] - b[pos]));\n\t\t\ta[pos] = x; b[pos] = y;\n\t\t\tif (a[pos] > b[pos]) c++;\n\t\t\ts += max(a[pos], b[pos]);\n\t\t\td[abs(a[pos] - b[pos])]++;\n\t\t}\n\t\tcout << s - (c & 1 ? d.begin()->first : 0) << '\\n';\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int> ii;\ntypedef long long ll;\n#define X first \n#define Y second\n\nset <ii> mse;\n\nconst int N=2e5+10;\n\nint n,m,a[2][N];\n\nll ans;\nvoid remove_pos(int pos){\n   if (pos==1||pos==n){\n       ans-=a[0][pos];\n       return;\n   }\n   int type=(a[1][pos]>a[0][pos]);\n   ans-=a[type][pos];\n   if (type==1) \n       mse.erase(ii(a[1][pos]-a[0][pos],pos));\n} \nvoid insert_pos(int pos){\n   if (pos==1||pos==n){\n      ans+=a[0][pos];\n      return;\n   }\n   int type=a[1][pos]>a[0][pos];\n   if (type==1)\n      mse.insert(ii(a[1][pos]-a[0][pos],pos));\n   ans+=a[type][pos];\n}        \nll getans(){\n   ll cans=ans;\n   if (mse.size()&1)\n      cans-=mse.begin()->X;\n\n   return cans;\n}\nint main(){\n   cin>>n>>m;\n   n<<=1;\n   for(int i=1;i<=n;i++) cin>>a[0][i];\n   for(int i=1;i<=n;i++) cin>>a[1][i];\n   for(int i=1;i<=n;i++) insert_pos(i); \n   while (m--){\n      int pos,v1,v2;\n      cin>>pos>>v1>>v2;\n      remove_pos(pos);\n      a[0][pos]=v1;a[1][pos]=v2;\n      insert_pos(pos);\n      cout<<getans()<<'\\n';\n   }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define llint long long\n#define inf 1e18\n#define rep(x, s, t) for(llint (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(llint (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n#define mod 998244353\nusing namespace std;\ntypedef pair<llint, llint> P;\ntypedef pair<llint, P> E;\n\nllint n, Q;\nllint a[200005], b[200005];\nmultiset<llint> posS, negS;\nllint psum;\n\nllint del(multiset<llint> &S, llint x)\n{\n\tauto it = S.lower_bound(x);\n\tif(it == S.end() || *it != x) return 0;\n\tS.erase(it);\n\treturn x;\n}\n\nllint calc()\n{\n\tif(posS.size() % 2 == 0) return psum;\n\tllint ret = psum - *posS.begin();\n\tret = max(ret, psum + *negS.rbegin());\n\treturn ret;\n}\n\nint main(void)\n{\n\tcin >> n >> Q;\n\tfor(int i = 1; i <= 2*n; i++) cin >> a[i];\n\tfor(int i = 1; i <= 2*n; i++) cin >> b[i];\n\t\n\tllint ans = 0;\n\tfor(int i = 1; i <= 2*n; i++){\n\t\tans += a[i];\n\t\tif(i > 1 && i < 2*n){\n\t\t\tif(b[i]-a[i] >= 0) posS.insert(b[i]-a[i]), psum += b[i]-a[i];\n\t\t\telse negS.insert(b[i]-a[i]);\n\t\t}\n\t}\n\t\n\tllint p, x, y;\n\tfor(int q = 1; q <= Q; q++){\n\t\tcin >> p >> x >> y;\n\t\tans -= a[p];\n\t\tif(p > 1 && p < 2*n){\n\t\t\tpsum -= del(posS, b[p]-a[p]);\n\t\t\tdel(negS, b[p]-a[p]);\n\t\t}\n\t\ta[p] = x, b[p] = y;\n\t\tans += a[p];\n\t\tif(p > 1 && p < 2*n){\n\t\t\tif(b[p]-a[p] >= 0) posS.insert(b[p]-a[p]), psum += b[p]-a[p];\n\t\t\telse negS.insert(b[p]-a[p]);\n\t\t}\n\t\tcout << ans + calc() << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll inf=1000000000000000000;\nll dat[800010];\nll u;\nvoid seginit(ll n){\n  for(int i=0;;i++){\n    ll y=pow(2,i);\n    if(y>=n){\n      u=y;\n      break;\n    }\n  }\n  fill(dat,dat+2*u,inf);\n}\nvoid add(ll n,ll x){\n  ll i=n+u-1;\n  dat[i]=x;\n  while(i>0){\n    i=(i-1)/2;\n    dat[i]=min(dat[2*i+1],dat[i*2+2]);\n  }\n}\nll que(ll a,ll b,ll k,ll l,ll r){\n  if(a>=r||b<=l)return inf;\n  if(a<=l&&b>=r)return dat[k];\n  ll m1=que(a,b,2*k+1,l,(l+r)/2);\n  ll m2=que(a,b,2*k+2,(l+r)/2,r);\n  return min(m1,m2);\n}\n\nint main(){\n  ll n,q;cin>>n>>q;\n  seginit(2*n);\n  ll a[2*n],b[2*n];\n  for(int i=0;i<2*n;i++)cin>>a[i];\n  ll sum=0;\n  ll c=0;\n  ll z=0;\n  for(int i=0;i<2*n;i++){\n    cin>>b[i];\n    if(i==0||i==2*n-1){\n      sum+=a[i];\n    }\n    else{\n      if(a[i]>=b[i]){\n        sum+=a[i];\n        add(i,a[i]-b[i]);\n        if(a[i]==b[i])z++;\n      }\n      else{\n        c=(c+1)%2;\n        sum+=b[i];\n        add(i,b[i]-a[i]);\n      }\n    }\n  }\n  for(int i=0;i<q;i++){\n    ll p,x,y;cin>>p>>x>>y;\n    p--;\n    if(p==0||p==2*n-1){\n      sum+=-a[p]+x;\n      ll g=0;\n      if(c==1){\n        g=que(1,2*n-1,0,0,2*n);\n      }\n      cout<<sum-g<<endl;\n      continue;\n    }\n    if(((a[p]-b[p])>=0&&x<y)||((a[p]-b[p])<0&&x>=y)){\n      c=(c+1)%2;\n    }\n    //cout<<c<<endl;\n    sum+=-max(a[p],b[p])+max(x,y);\n    add(p,abs(x-y));\n    if(a[p]==b[p])z--;\n    if(x==y)z++;\n    a[p]=x;\n    b[p]=y;\n    if(z>0){\n      cout<<sum<<endl;\n      c=0;\n      continue;\n    }\n    ll f=0;\n    if(c==1){\n      f=que(1,2*n-1,0,0,2*n);\n    }\n    cout<<sum-f<<endl;\n  }\n}\n        \n  "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sp ' '\n#define mkp make_pair\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define lP pair<ll,ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\nconst int mod = 1000000007, mod998 = 998244353;\nconst string nyan(\"(=^・ω・^=)\");\n\nint N, Q, a[200000], b[200000], p, x, y;\nbool u[200000];\nset<pair<int, int>>st[2];\nll res;\n\nint main() {\n\tcin >> N >> Q;\n\tN <<= 1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> b[i];\n\t}\n\t--Q;\n\tcin >> p >> x >> y;\n\t--p;\n\ta[p] = x;\n\tb[p] = y;\n\tres = a[0] + a[N - 1];\n\tfor (int i = 1; i < N - 1; ++i) {\n\t\tif (a[i] >= b[i]) {\n\t\t\tu[i] = true;\n\t\t\tres += a[i];\n\t\t\tst[1].insert(mkp(a[i] - b[i], i));\n\t\t}\n\t\telse {\n\t\t\tres += b[i];\n\t\t\tst[0].insert(mkp(b[i] - a[i], i));\n\t\t}\n\t}\n\tif (st[0].size() & 1) {\n\t\tif (st[0].begin()->first > st[1].begin()->first) {\n\t\t\tres -= st[1].begin()->first;\n\t\t\tu[st[1].begin()->second] ^= true;\n\t\t\tst[0].insert(mkp(-st[1].begin()->first, st[1].begin()->second));\n\t\t\tst[1].erase(st[1].begin());\n\t\t}\n\t\telse {\n\t\t\tres -= st[0].begin()->first;\n\t\t\tu[st[0].begin()->second] ^= true;\n\t\t\tst[1].insert(mkp(-st[0].begin()->first, st[0].begin()->second));\n\t\t\tst[0].erase(st[0].begin());\n\t\t}\n\t}\n\tcout << res << endl;\n\twhile (Q--) {\n\t\tcin >> p >> x >> y;\n\t\t--p;\n\t\tif (p == 0 || p == N - 1) {\n\t\t\tres += x - a[p];\n\t\t\ta[p] = x;\n\t\t}\n\t\telse {\n\t\t\tif (u[p]) {\n\t\t\t\tres += x - a[p];\n\t\t\t\tst[1].erase(mkp(a[p] - b[p], p));\n\t\t\t\tst[1].insert(mkp(x - y, p));\n\t\t\t\tauto it = st[1].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[0].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[1].erase(p1);\n\t\t\t\t\tst[1].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres += y - b[p];\n\t\t\t\tst[0].erase(mkp(b[p] - a[p], p));\n\t\t\t\tst[0].insert(mkp(y - x, p));\n\t\t\t\tauto it = st[0].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[1].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[0].erase(p1);\n\t\t\t\t\tst[0].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!st[0].empty() && !st[1].empty() && st[0].begin()->first + st[1].begin()->first < 0) {\n\t\t\t\tpair<int, int> p1 = *st[0].begin();\n\t\t\t\tpair<int, int> p2 = *st[1].begin();\n\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\tu[p1.second] ^= true;\n\t\t\t\tu[p2.second] ^= true;\n\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\tst[0].erase(p1);\n\t\t\t\tst[1].erase(p2);\n\t\t\t}\n\t\t\ta[p] = x;\n\t\t\tb[p] = y;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll, int> P;\n\nint main()\n{\n\tint n, q;\n  cin>>n>>q;\n  ll a[200001], b[200001];\n  for(int i=1; i<=2*n; i++){\n    cin>>a[i];\n  }\n  for(int i=1; i<=2*n; i++){\n    cin>>b[i];\n  }\n  multiset<ll> st;\n  ll ans=a[1]+a[2*n];\n  int ct0=0, ct1=0;\n  for(int i=2; i<2*n; i++){\n    if(b[i]>a[i]){\n      ct1++;\n    }else if(b[i]==a[i]){\n      ct0++;\n    }\n    st.insert(abs(b[i]-a[i]));\n    ans+=max(a[i], b[i]);\n  }\n  for(int i=0; i<q; i++){\n    int p; ll x, y;\n    cin>>p>>x>>y;\n    if(p==1 || p==2*n){\n      ans=ans-a[p]+x;\n      a[p]=x; b[p]=y;\n    }else{\n      if(b[p]>a[p]){\n        ct1--;\n      }else if(b[p]==a[p]){\n        ct0--;\n      }\n      st.erase(st.lower_bound(abs(b[p]-a[p])));\n      ans=ans-max(a[p], b[p])+max(x, y);\n      a[p]=x; b[p]=y;\n      st.insert(abs(y-x));\n      if(y>x){\n        ct1++;\n      }else if(y==x){\n        ct0++;\n      }\n    }\n    if(ct0>0 || ct1%2==0){\n      cout<<ans<<endl;\n    }else{\n      cout<<ans-*(st.begin())<<endl;\n    }\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define foor(i,a,b) for(int i=(a);i<=(b);++i)\n#define rf(i,n) for(int i=(n);i--;)\n#define roof(i,b,a) for(int i=(b);i>=(a);--i)\n#define elsif else if\n#define all(x) x.begin(),x.end()\n#define Sort(x) sort(all(x))\n#define Reverse(x) reverse(all(x))\n#define PQ priority_queue\n#define NP(x) next_permutation(all(x))\n#define M_PI 3.14159265358979323846\n#define popcount __builtin_popcount\nusing namespace std;            typedef vector<bool> vb; typedef vector<vb>  vvb;\n                                typedef vector<int>  vi; typedef vector<vi>  vvi;\ntypedef long long ll;           typedef vector< ll>  vl; typedef vector<vl>  vvl;\ntypedef unsigned long long ull; typedef vector<ull>  vu; typedef vector<vu>  vvu;\ntypedef double dbl;             typedef vector<dbl>  vd; typedef vector<vd>  vvd;\ntypedef string str;             typedef vector<str>  vs; typedef vector<vs>  vvs;\ntypedef pair<int,int>pii;       typedef vector<pii>vpii; typedef map<int,int>mii;\ntypedef pair< ll, ll>pll;       typedef vector<pll>vpll; typedef map< ll, ll>mll;\ntypedef pair<dbl,dbl>pdd;       typedef vector<pdd>vpdd; typedef map<dbl,dbl>mdd;\ntypedef pair<str,str>pss;       typedef vector<pss>vpss; typedef map<str,str>mss;\ntypedef pair<int, ll>pil;       typedef vector<pil>vpil; typedef map<int, ll>mil;\ntypedef pair< ll,int>pli;       typedef vector<pli>vpli; typedef map< ll,int>mli;\ntypedef pair<dbl,int>pdi;       typedef vector<pdi>vpdi; typedef map<dbl,int>mdi;\ntemplate<typename T>vector<T>&operator<<(vector<T>&v,const T t){v.push_back(t);return v;}\ntemplate<typename T>multiset<T>&operator<<(multiset<T>&m,const T t){m.insert(t);return m;}\ntemplate<typename T>set<T>&operator<<(set<T>&s,const T t){s.insert(t);return s;}\ntemplate<typename T>stack<T>&operator<<(stack<T>&s,const T t){s.push(t);return s;}\ntemplate<typename T>stack<T>&operator>>(stack<T>&s,T&t){t=s.top();s.pop();return s;}\ntemplate<typename T>queue<T>&operator<<(queue<T>&q,const T t){q.push(t);return q;}\ntemplate<typename T>queue<T>&operator>>(queue<T>&q,T&t){t=q.front();q.pop();return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator<<(PQ<T,vector<T>,U>&q,const T t){q.push(t);return q;}\ntemplate<typename T,typename U>PQ<T,vector<T>,U>&operator>>(PQ<T,vector<T>,U>&q,T&t){t=q.top();q.pop();return q;}\ntemplate<typename T,typename U>istream&operator>>(istream&s,pair<T,U>&p){return s>>p.first>>p.second;}\nistream&operator>>(istream&s,_Bit_reference b){int a;s>>a;assert(a==0||a==1);b=a;return s;}\ntemplate<typename T>istream&operator>>(istream&s,vector<T>&v){fr(i,v.size()){s>>v[i];}return s;}\ntemplate<typename T,typename U>ostream&operator<<(ostream&s,const pair<T,U>p){return s<<p.first<<\" \"<<p.second;}\n//template<typename T>ostream&operator<<(ostream&s,const vector<T>v){for(auto a:v){s<<a<<\"\\n\";}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const vector<T>v){fr(i,v.size()){i?s<<\" \"<<v[i]:s<<v[i];}return s;}\ntemplate<typename T>ostream&operator<<(ostream&s,const deque<T>d){fr(i,d.size()){i?s<<\" \"<<d[i]:s<<d[i];}return s;}\ntemplate<typename T>_Bit_reference operator&=(_Bit_reference b,T t){return b=b&t;}\ntemplate<typename T>_Bit_reference operator^=(_Bit_reference b,T t){return b=b^t;}\ntemplate<typename T>_Bit_reference operator|=(_Bit_reference b,T t){return b=b|t;}\ntemplate<typename T,typename U>pair<T,U>operator+(pair<T,U>a,pair<T,U>b){return {a.first+b.first,a.second+b.second};}\ntemplate<typename T,typename U>pair<T,U>operator-(pair<T,U>a,pair<T,U>b){return {a.first-b.first,a.second-b.second};}\ntemplate<typename T,typename U>pair<T,U>&operator+=(pair<T,U>&a,pair<T,U>b){return a=a+b;}\ntemplate<typename T,typename U>pair<T,U>&operator-=(pair<T,U>&a,pair<T,U>b){return a=a-b;}\nvoid print(void){cout<<\"\\n\";}\nvoid Print(void){cout<<endl;}\ntemplate<typename T>void print(T t){cout<<t<<\"\\n\";}\ntemplate<typename T>void Print(T t){cout<<t<<endl;}\ntemplate<typename T,typename...U>void print(T&&t,U&&...u){cout<<t<<\" \";print(forward<U>(u)...);}\ntemplate<typename T,typename...U>void Print(T&&t,U&&...u){cout<<t<<\" \";Print(forward<U>(u)...);}\nbool YN(bool b){print(b?\"YES\":\"NO\");return b;}bool PI(bool b){print(b?\"POSSIBLE\":\"IMPOSSIBLE\");return b;}\nbool Yn(bool b){print(b?\"Yes\":\"No\");return b;}bool Pi(bool b){print(b?\"Possible\":\"Impossible\");return b;}\nbool yn(bool b){print(b?\"yes\":\"no\");return b;}bool pi(bool b){print(b?\"possible\":\"impossible\");return b;}\nconst int e5=1e5;\nconst int e9=1e9;\nconst int MD=1e9+7;\nconst ll e18=1e18;\ntemplate<typename T>str to_string(const T&n){ostringstream s;s<<n;return s.str();}\ntemplate<typename T>T&chmax(T&a,T b){return a=max(a,b);}\ntemplate<typename T>T&chmin(T&a,T b){return a=min(a,b);}\ntemplate<typename T,typename U>vector<pair<T,U>>dijkstra(const vector<vector<pair<T,U>>>&E,const U s,const T inf){using P=pair<T,U>;vector<P>d;fr(i,E.size()){d<<P{inf,i};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\ntemplate<typename T,typename U>map<U,pair<T,U>>dijkstra(map<U,vector<pair<T,U>>>E,const U s,const T inf){using P=pair<T,U>;map<U,P>d;for(pair<U,vector<P>>e:E){d[e.first]=P{inf,e.first};}PQ<P,vector<P>,greater<P>>pq;pq<<(d[s]=P{0,s});while(pq.size()){P a=pq.top();pq.pop();U v=a.second;if(d[v].first>=a.first){for(P e:E[v]){if(d[v].first+e.first<d[e.second].first){d[e.second]=P{d[v].first+e.first,v};pq<<P{d[v].first+e.first,e.second};}}}}return d;}\nll maxflow(vector<mil>&E,int s,int t){ll z=0;vi b(E.size(),-1);for(int i=0;;++i){static auto dfs=[&](int v,ll f,auto&dfs)->ll{if(v==t)return f;b[v]=i;for(auto&p:E[v]){if(b[p.first]<i&&p.second){if(ll r=dfs(p.first,min(f,p.second),dfs)){p.second-=r;E[p.first][v]+=r;return r;}}}return 0;};ll x=dfs(s,ll(1e18),dfs);z+=x;if(x==0)return z;}}\ntemplate<typename T>T distsq(pair<T,T>a,pair<T,T>b){return (a.first-b.first)*(a.first-b.first)+(a.second-b.second)*(a.second-b.second);}\ntemplate<typename T>T max(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=max(m,e);}return m;}\ntemplate<typename T>T min(const vector<T>a){assert(a.size());T m=a[0];for(T e:a){m=min(m,e);}return m;}\ntemplate<typename T>T gcd(const T a,const T b){return a?gcd(b%a,a):b;}\ntemplate<typename T>T gcd(const vector<T>a){T g=a[0];for(T e:a){g=gcd(g,e);}return g;}\ntemplate<typename T>vector<T>LIS(const vector<T>A){vector<T>B;for(T a:A){auto it=lower_bound(all(B),a);if(it==B.end()){B<<a;}else{*it=a;}}return B;}\ntemplate<typename T>vector<T>LCS(vector<T>A,vector<T>B){int N=A.size(),M=B.size();vector<vector<pair<int,pii>>>d(N+1,vector<pair<int,pii>>(M+1));fr(i,N){fr(j,M){if(A[i]==B[j]){d[i+1][j+1]={d[i][j].first+1,{i,j}};}else{d[i+1][j+1]=max(d[i][j+1],d[i+1][j]);}}}vector<T>r;for(pii p={N,M};d[p.first][p.second].first;p=d[p.first][p.second].second){r<<A[d[p.first][p.second].second.first];}Reverse(r);return r;}\nstr LCS(str S,str T){vector<char>s=LCS(vector<char>(S.begin(),S.end()),vector<char>(T.begin(),T.end()));return str(s.begin(),s.end());}\ntemplate<typename T>vector<pair<T,T>>ConvexHull(vector<pair<T,T>>V){if(V.size()<=3){return V;}Sort(V);rf(i,V.size()-1)V<<V[i];vector<pair<T,T>>r;for(pair<T,T>p:V){int s=r.size();while(s>=2&&(p.second-r[s-1].second)*(p.first-r[s-2].first)<(p.second-r[s-2].second)*(p.first-r[s-1].first)){r.pop_back();--s;}r<<p;}r.pop_back();return r;}\nclass UnionFind{vi p,s;void extend(int N){foor(i,p.size(),N){p<<i;s<<1;}}public:UnionFind(void){}UnionFind(int N){extend(N-1);}int find(int i){extend(i);return p[i]=p[i]==i?i:find(p[i]);}void unite(int a,int b){extend(a);extend(b);if((a=find(a))!=(b=find(b))){if(s[a]>s[b]){swap(a,b);}s[b]+=s[a];p[a]=b;}}void unite(pii p){return unite(p.first,p.second);}bool same(int a,int b){extend(a);extend(b);return find(a)==find(b);}bool same(pii p){return same(p.first,p.second);}int size(int x){extend(x);return s[find(x)];}};\nll MST(vector<pair<ll,pii>>&E){Sort(E);UnionFind uf;ll z=0;for(auto&e:E){if(!uf.same(e.second)){z+=e.first;uf.unite(e.second);}}return z;}\nll strmod(const str&s,const int m){ll x=0;fr(i,s.size()){x=(x*10+s[i]-48)%m;}return x;}\nvvl mul(const vvl&A,const vvl&B,const int m){vvl C;fr(y,A.size()){C<<vl(B[y].size());}fr(y,C.size()){fr(x,C[y].size()){fr(i,A[0].size()){(C[y][x]+=A[y][i]*B[i][x])%=m;}}}return C;}\nvvl pow(const vvl&A,const ll n,const int m){vvl B;fr(y,A.size()){B<<vl(A.size());}if(n==0){fr(i,B.size()){B[i][i]=1;}}elsif(n%2){B=mul(A,pow(A,n-1,m),m);}else{vvl C=pow(A,n/2,m);B=mul(C,C,m);}return B;}\nll pow(const ll a,const ll n,const int m){ll t;return n?(n&1?a>=0?a%m:(m-(-a%m))%m:1)*(t=pow(a,n>>1,m),t*t%m)%m:!!a;}\nll inv(const ll x,const int p){assert(x!=0);return pow(x,p-2,p);}\nll inv(const ll x){return inv(x,MD);}\nvpll fact(const int n,const int p){assert(n<p);vpll v(n+1);v[0].first=1;foor(i,1,n){v[i].first=v[i-1].first*i%p;}v[n].second=inv(v[n].first,p);roof(i,n,1){v[i-1].second=v[i].second*i%p;}return v;}\nclass Combination{const vpll f;const int M;public:Combination(int n,int m):f(fact(n,m)),M(m){}Combination(int n):Combination(n,MD){}ll P(int n,int k){return n<0||k<0||n<k?0ll:f[n].first*f[n-k].second%M;}ll C(int n,int k){return k<0?0:P(n,k)*f[k].second%M;}ll H(int n,int k){return n==0&&k==0?1ll:C(n+k-1,k);}ll F(int n){return n<0?0:f[n].first;}};\nll C2(const int n){return(ll)n*~-n/2;}\nll sum(const vi a){ll s=0;for(int e:a){s+=e;}return s;}\nll sum(const vl a){ll s=0;for(ll e:a){s+=e;}return s;}\ntemplate<typename T>int MSB(T N){int r=-1;for(;N>0;N/=2){++r;}return r;}\ntemplate<typename T>class SegmentTree{vector<T>S;T(*const op)(T a,T b);const T zero;const int B;public:SegmentTree(int N,T(*f)(T a,T b),const T zero):S(1<<MSB(N-1)+2,zero),op(f),zero(zero),B(1<<MSB(N-1)+1){}SegmentTree(vector<T>v,T(*f)(T a,T b),const T zero):SegmentTree(v.size(),f,zero){fr(i,v.size()){S[S.size()/2+i]=v[i];}roof(i,S.size()/2-1,1){S[i]=op(S[i*2],S[i*2+1]);}}T calc(int l,int r){l+=B;r+=B;if(l>r){return zero;}if(l==r){return S[l];}T L=S[l],R=S[r];for(;l/2<r/2;l/=2,r/=2){if(l%2==0){L=op(L,S[l+1]);}if(r%2==1){R=op(S[r-1],R);}}return op(L,R);}void replace(int i,T x){for(S[i+=B]=x;i!=1;i/=2){if(i%2){S[i/2]=op(S[i-1],S[i]);}else{S[i/2]=op(S[i],S[i+1]);}}}void add(int i,T x){replace(i,op(S[B+i],x));}T top(){return S[1];}};\nll BITsum(vl&B,int i){ll z=0;while(i>0){z+=B[i];i-=i&-i;}return z;}\nvoid BITadd(vl&B,int i,ll x){while(i<B.size()){B[i]+=x;i+=i&-i;}}\nll fib(const ll n,const int m){ll a,b,c,d,A,B,C,D;a=1;b=0;c=0;d=1;rf(i,63){A=a*a+b*c;B=a*b+b*d;C=c*a+d*c;D=c*b+d*d;if(n>>i&1){a=A;b=B;c=C;d=D;A=a+b;B=a;C=c+d;D=c;}a=A%m;b=B%m;c=C%m;d=D%m;}return b;}\nvi primes(int n){vb b(n+1);vi p;foor(i,2,n){if(!b[i]){p<<i;for(int j=2*i;j<=n;j+=i){b[j]=true;}}}return p;}\nvb isprime(const int n){vb v(n+1,true);v[0]=v[1]=false;foor(i,2,n){if(v[i]){for(int j=2*i;j<=n;j+=i){v[j]=false;}}}return v;}\nclass LCA{vvi par;vi dep;public:LCA(vvi&E,int root):par(MSB(E.size())+1,vi(E.size())),dep(E.size()){function<void(int,int)>dfs=[&](int i,int p){for(int j:E[i])if(j!=p){par[0][j]=i;dep[j]=dep[i]+1;dfs(j,i);}};par[0][root]=root;dfs(root,root);fr(i,par.size()-1){fr(j,par[0].size()){par[i+1][j]=par[i][par[i][j]];}}}int operator()(int a,int b){if(dep[a]>dep[b])swap(a,b);for(int t=dep[b]-dep[a],i=0;t;t>>=1,++i){if(t&1){b=par[i][b];}}if(a==b)return a;rf(i,par.size()){if(par[i][a]!=par[i][b]){a=par[i][a];b=par[i][b];}}return par[0][a];}};\nvpii factor(int N){vpii r;for(int i=2;i*i<=N;++i){if(N%i==0){r<<pii{i,0};while(N%i==0){N/=i;++r.back().second;}}}if(N>1){r<<pii{N,1};}return r;}\n\nint main(){cin.tie(0);ios::sync_with_stdio(false);\n\tint N,Q;cin>>N>>Q;\n\tvi A(2*N);cin>>A;\n\tvi B(2*N);cin>>B;\n\tmultiset<int>m;\n\tll z=sum(A);\n\tbool c=false;\n\tfoor(i,1,2*N-2){\n\t\tm<<B[i]-A[i];\n\t\tif(B[i]>=A[i]){\n\t\t\tz+=B[i]-A[i];\n\t\t\tc=!c;\n\t\t}\n\t}\n\tfr(q,Q){\n\t\tint p,x,y;cin>>p>>x>>y;\n\t\t--p;\n\t\tz+=x-A[p];\n\t\tif(1<=p&&p<=2*N-2){\n\t\t\tm.erase(m.lower_bound(B[p]-A[p]));\n\t\t\tif(B[p]>=A[p]){\n\t\t\t\tz-=B[p]-A[p];\n\t\t\t\tc=!c;\n\t\t\t}\n\t\t\tm<<y-x;\n\t\t\tif(y>=x){\n\t\t\t\tz+=y-x;\n\t\t\t\tc=!c;\n\t\t\t}\n\t\t}\n\t\tA[p]=x,B[p]=y;\n\t\tif(c){\n\t\t\tauto it=m.lower_bound(0);\n\t\t\tint t=*it--;\n\t\t\tprint(z+max(-t,*it));\n\t\t}else{\n\t\t\tprint(z);\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,m,n) for(int i = (m); i < (n); i++)\n#define rrep(i,m,n) for(int i = (m); i >= (n); i--)\n#define print(x) cout << (x) << endl;\n#define print2(x,y) cout << (x) << \" \" << (y) << endl;\n#define printa(x,n) for(int i = 0; i < n; i++){ cout << (x[i]) << \" \\n\"[i == n-1];}\n#define printp(x,n) for(int i = 0; i < n; i++){ cout << \"(\" << x[i].first << \", \" << x[i].second << \") \"; } cout << endl;\n#define INF (1e18)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\ntypedef pair<ll, ll> lpair;\nbool check(string s){\n    bool ok = true;\n    ll N = s.size();\n    ll lv = 0, rv = 0;\n    rep(i,0,N){\n        if(s[i] == '('){\n            lv++;\n        }else{\n            if(lv > 0){\n                lv--;\n            }else{\n                return false;\n            }\n        }\n    }\n    if(lv == 0){\n        return true;\n    }else{\n        return false;\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N,Q;\n    ll a[200010], b[200010];\n    ll p[100010], x[100010], y[100010];\n    cin >> N >> Q;\n    rep(i,0,2*N) cin >> a[i];\n    rep(i,0,2*N) cin >> b[i];\n    rep(i,0,Q) cin >> p[i] >> x[i] >> y[i];\n    if(N > 5 || Q > 10) return 0;\n    rep(i,0,Q){\n        p[i]--;\n        ll a1 = a[p[i]]; ll b1 = b[p[i]];\n        a[p[i]] = x[i]; b[p[i]] = y[i];\n        ll ans = 0;\n        rep(i,0,pow(2,2*N)){\n            rep(j,0,pow(2,N)){\n                ll ans_tmp = 0;\n                string s = \"\", t = \"\";\n                rep(k,0,2*N){\n                    if((i>>k) & 1){\n                        s += '(';\n                    }else{\n                        s += ')';\n                    }\n                }\n                rep(k,0,2*N){\n                    if((j>>k) & 1){\n                        t += '(';\n                    }else{\n                        t += ')';\n                    }\n                }\n                if(!check(s) || !check(t)) continue;\n                rep(k,0,2*N){\n                    if(s[k] == t[k]){\n                        ans_tmp += a[k];\n                    }else{\n                        ans_tmp += b[k];\n                    }\n                }\n                ans = max(ans, ans_tmp); \n            }\n        }\n        print(ans);\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll inf=1000000000000000000;\nll dat[800010];\nll u;\nvoid seginit(ll n){\n  for(int i=0;;i++){\n    ll y=pow(2,i);\n    if(y>=n){\n      u=y;\n      break;\n    }\n  }\n  fill(dat,dat+2*u,inf);\n}\nvoid add(ll n,ll x){\n  ll i=n+u-1;\n  dat[i]=x;\n  while(i>0){\n    i=(i-1)/2;\n    dat[i]=min(dat[2*i+1],dat[i*2+2]);\n  }\n}\nll que(ll a,ll b,ll k,ll l,ll r){\n  if(a>=r||b<=l)return inf;\n  if(a<=l&&b>=r)return dat[k];\n  ll m1=que(a,b,2*k+1,l,(l+r)/2);\n  ll m2=que(a,b,2*k+2,(l+r)/2,r);\n  return min(m1,m2);\n}\n\nint main(){\n  ll n,q;cin>>n>>q;\n  seginit(2*n);\n  ll a[2*n],b[2*n];\n  for(int i=0;i<2*n;i++)cin>>a[i];\n  ll sum=0;\n  ll c=0;\n  ll z=0;\n  for(int i=0;i<2*n;i++){\n    cin>>b[i];\n    if(i==0||i==2*n-1){\n      sum+=a[i];\n    }\n    else{\n      if(a[i]>=b[i]){\n        sum+=a[i];\n        add(i,a[i]-b[i]);\n        if(a[i]==b[i])z++;\n      }\n      else{\n        c=(c+1)%2;\n        sum+=b[i];\n        add(i,b[i]-a[i]);\n      }\n    }\n  }\n  for(int i=0;i<q;i++){\n    ll p,x,y;cin>>p>>x>>y;\n    p--;\n    if(p==0||p==2*n-1){\n      sum+=-a[p]+x;\n      a[p]=x;\n      b[p]=y;\n      ll g=0;\n      if(c==1){\n        g=que(1,2*n-1,0,0,2*n);\n      }\n      cout<<sum-g<<endl;\n      continue;\n    }\n    if(((a[p]-b[p])>=0&&x<y)||((a[p]-b[p])<0&&x>=y)){\n      c=(c+1)%2;\n    }\n    //cout<<c<<endl;\n    sum+=-max(a[p],b[p])+max(x,y);\n    add(p,abs(x-y));\n    if(a[p]==b[p])z--;\n    if(x==y)z++;\n    a[p]=x;\n    b[p]=y;\n    if(z>0){\n      cout<<sum<<endl;\n      c=0;\n      continue;\n    }\n    ll f=0;\n    if(c==1){\n      f=que(1,2*n-1,0,0,2*n);\n    }\n    cout<<sum-f<<endl;\n  }\n}\n        \n  \n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<cmath>\n#include<ctime>\n#include<cstdlib>\n#define cmax(a,b) (a<(b)?a=(b),1:0)\n#define cmin(a,b) (a>(b)?a=(b),1:0)\n#define dmin(a,b) ((a)<(b)?(a):(b))\n#define dmax(a,b) ((a)>(b)?(a):(b))\n#define regsiter register\n#define CL fclose(stdin),fclose(stdout)\nnamespace io\n{\n\tint F()\n\t{\n\t\tint n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n\tlong long G()\n\t{\n\t\tlong long n=0,F=1;\n\t\tchar ch;\n\t\twhile((ch=getchar())!='-'&&(ch<'0'||ch>'9'));\n\t\tch=='-'?F=0:n=ch-'0';\n\t\twhile((ch=getchar())>='0'&&ch<='9')n=(n<<1)+(n<<3)+ch-'0';\n\t\treturn F?n:-n;\n\t}\n}\n#include<set>\nint a[111111];\nint v[111111];\nstd::multiset<int> pos,neg;\nlong long sp;\nint main()\n{\n\t#define register \n\tint n=io::F()<<1,Q=io::F();\n\tlong long ans=0;\n\tfor(register int i=1;i<=n;++i)ans+=a[i]=io::F();\n\tio::F();\n\tfor(register int i=2;i<n;++i)v[i]=io::F()-a[i];\n\tio::F();\n\tfor(register int i=2;i<n;++i)v[i]>=0?sp+=v[i],pos.insert(v[i]):neg.insert(v[i]);\n\tfor(register int i=1;i<=Q;++i)\n\t{\n\t\tint p=io::F(),x=io::F(),y=io::F();\n\t\tans-=a[p];\n\t\tans+=a[p]=x;\n\t\tif(p==1||p==n)goto skip;\n\t\tv[p]>=0?sp-=v[p],pos.erase(pos.find(v[p])):neg.erase(neg.find(v[p]));\n\t\tv[p]=y-x;\n\t\t//for(std::multiset<int>::iterator it=pos.begin();it!=pos.end();++it)printf(\"%d\\n\",*it);\n\t\tv[p]>=0?sp+=v[p],pos.insert(v[p]):neg.insert(v[p]);\n\t\tskip:;\n\t\tif(pos.size()&1)\n\t\t{\n\t\t\tif(*pos.begin()>-*neg.rbegin())printf(\"%lld\\n\",ans+sp+*neg.rbegin());\n\t\t\t\telse printf(\"%lld\\n\",ans+sp-*pos.begin());\n\t\t}\n\t\telse printf(\"%lld\\n\",ans+sp);\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nll inf=1000000000000000000;\nll dat[800010];\nll u;\nvoid seginit(ll n){\n  for(int i=0;;i++){\n    ll y=pow(2,i);\n    if(y>=n){\n      u=y;\n      break;\n    }\n  }\n  fill(dat,dat+2*u,inf);\n}\nvoid add(ll n,ll x){\n  ll i=n+u-1;\n  dat[i]=x;\n  while(i>0){\n    i=(i-1)/2;\n    dat[i]=min(dat[2*i+1],dat[i*2+2]);\n  }\n}\nll que(ll a,ll b,ll k,ll l,ll r){\n  if(a>=r||b<=l)return inf;\n  if(a<=l&&b>=r)return dat[k];\n  ll m1=que(a,b,2*k+1,l,(l+r)/2);\n  ll m2=que(a,b,2*k+2,(l+r)/2,r);\n  return min(m1,m2);\n}\n\nint main(){\n  ll n,q;cin>>n>>q;\n  seginit(2*n);\n  ll a[2*n],b[2*n];\n  for(int i=0;i<2*n;i++)cin>>a[i];\n  ll sum=0;\n  ll c=0;\n  ll z=0;\n  for(int i=0;i<2*n;i++){\n    cin>>b[i];\n    if(i==0||i==2*n-1){\n      sum+=a[i];\n    }\n    else{\n      if(a[i]>=b[i]){\n        sum+=a[i];\n        add(i,a[i]-b[i]);\n        if(a[i]==b[i])z++;\n      }\n      else{\n        c=(c+1)%2;\n        sum+=b[i];\n        add(i,b[i]-a[i]);\n      }\n    }\n  }\n  for(int i=0;i<q;i++){\n    ll p,x,y;cin>>p>>x>>y;\n    p--;\n    if(p==0||p==2*n-1){\n      sum+=-a[p]+x;\n      cout<<sum<<endl;\n      continue;\n    }\n    if(((a[p]-b[p])>=0&&x<y)||((a[p]-b[p])<0&&x>=y)){\n      c=(c+1)%2;\n    }\n    //cout<<c<<endl;\n    sum+=-max(a[p],b[p])+max(x,y);\n    add(p,abs(x-y));\n    if(a[p]==b[p])z--;\n    if(x==y)z++;\n    a[p]=x;\n    b[p]=y;\n    if(z>0){\n      cout<<sum<<endl;\n      c=0;\n      continue;\n    }\n    ll f=0;\n    if(c==1){\n      f=que(1,2*n-1,0,0,2*n);\n    }\n    cout<<sum-f<<endl;\n  }\n}\n        \n  "
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 26.11.2019 11:07:03       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n, tt;\n  cin >> n >> tt;\n  n *= 2;\n  vector<int> a(n);\n  for (int i = 0; i < n; i++) {\n    cin >> a[i];\n  }\n  vector<int> b(n);\n  for (int i = 0; i < n; i++) {\n    cin >> b[i];\n  }\n  multiset<pair<int, int>> pos;\n  multiset<pair<int, int>> neg;\n  long long sum_pos = 0;\n  long long sum_neg = 0;\n  for (int i = 1; i < n - 1; i++) {\n    if (a[i] > b[i]) {\n      pos.emplace(a[i] - b[i], a[i]);\n      sum_pos += a[i];\n    } else {\n      neg.emplace(b[i] - a[i], b[i]);\n      sum_neg += b[i];\n    }\n  }\n  while (tt--) {\n    int i;\n    cin >> i;\n    --i;\n    if (i > 0 && i < n - 1) {\n      if (a[i] > b[i]) {\n        pos.erase(pos.find({a[i] - b[i], a[i]}));\n        sum_pos -= a[i];\n      } else {\n        neg.erase(neg.find({b[i] - a[i], b[i]}));\n        sum_neg -= b[i];\n      }\n      cin >> a[i] >> b[i];\n      if (a[i] > b[i]) {\n        pos.emplace(a[i] - b[i], a[i]);\n        sum_pos += a[i];\n      } else {\n        neg.emplace(b[i] - a[i], b[i]);\n        sum_neg += b[i];\n      }\n    } else {\n      cin >> a[i] >> b[i];\n    }\n    long long ans = a[0] + a[n - 1] + sum_pos + sum_neg;\n    if (pos.size() % 2 == 1) {\n      ans -= min(pos.begin()->first, neg.begin()->first);\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <set>\nusing namespace std;\n\nint main() {\n        int n, q;\n        scanf(\"%d%d\", &n, &q);\n        n = 2 * n;\n        vector<long long> a(n), b(n);\n        for (int i = 0; i < n; i ++) scanf(\"%lld\", &a[i]);\n        for (int i = 0; i < n; i ++) scanf(\"%lld\", &b[i]);\n        multiset<long long> positive, negative;\n        long long psum = 0, nsum = 0;\n        for (int i = 0; i < n; i ++) {\n                if (i == 0 || i == n - 1) {\n                        psum += a[i];\n                        continue;\n                }\n                long long c = a[i] - b[i];\n                if (c >= 0) { \n                        positive.insert(c);\n                        psum += a[i];\n                } else { \n                        negative.insert(- c);\n                        nsum += b[i];\n                }\n        }\n        while (q --) {\n                int p;\n                long long x, y;\n                scanf(\"%d%lld%lld\", &p, &x, &y);\n                p --;\n                long long z = x - y;\n                if (p == 0 || p == n - 1) {\n                        psum -= a[p];\n                        psum += x;\n                        a[p] = x;\n                        continue;\n                }\n                long long c = a[p] - b[p];\n                //remove\n                if (c >= 0) {\n                        positive.erase(positive.find(c));\n                        psum -= a[p];\n                } else {\n                        negative.erase(negative.find(-c));\n                        nsum -= b[p];\n                }\n                //insert\n                if (z >= 0) {\n                        positive.insert(z);\n                        psum += x;\n                } else {\n                        negative.insert(-z);\n                        nsum += y;\n                }\n                a[p] = x;\n                b[p] = y;\n                long long ans;\n                if (positive.size() % 2 == 0) ans = psum + nsum;\n                else ans = psum + nsum - min(*positive.begin(), *negative.begin());\n                printf(\"%lld\\n\", ans);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sp ' '\n#define mkp make_pair\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define lP pair<ll,ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\nconst int mod = 1000000007, mod998 = 998244353;\nconst string nyan(\"(=^・ω・^=)\");\n#define int long long\nint N, Q, a[200000], b[200000], p, x, y;\nbool u[200000];\nset<pair<int, int>>st[2];\nll res;\n\nsigned main() {\n\tcin >> N >> Q;\n\t--Q;\n\tN *= 2;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> b[i];\n\t}\n\tcin >> p >> x >> y;\n\t--p;\n\ta[p] = x;\n\tb[p] = y;\n\tres = a[0] + a[N - 1];\n\tfor (int i = 1; i < N - 1; ++i) {\n\t\tif (a[i] >= b[i]) {\n\t\t\tu[i] = true;\n\t\t\tres += a[i];\n\t\t\tst[1].insert(mkp(a[i] - b[i], i));\n\t\t}\n\t\telse {\n\t\t\tres += b[i];\n\t\t\tst[0].insert(mkp(b[i] - a[i], i));\n\t\t}\n\t}\n\tif (st[0].size() & 1) {\n\t\tpair<int, int>p1, p2;\n\t\tp1 = *st[0].begin();\n\t\tp2 = *st[1].begin();\n\t\tif (p1.first > p2.first) {\n\t\t\tres -= p2.first;\n\t\t\tu[p2.second] ^= true;\n\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\tst[1].erase(p2);\n\t\t}\n\t\telse {\n\t\t\tres -= p1.first;\n\t\t\tu[p1.second] ^= true;\n\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\tst[0].erase(p1);\n\t\t}\n\t}\n\tcout << res << endl;\n\twhile (Q--) {\n\t\tcin >> p >> x >> y;\n\t\t--p;\n\t\tif (p == 0 || p == N - 1) {\n\t\t\tres += x - a[p];\n\t\t\ta[p] = x;\n\t\t}\n\t\telse {\n\t\t\tif (u[p]) {\n\t\t\t\tres += x - a[p];\n\t\t\t\tst[1].erase(mkp(a[p] - b[p], p));\n\t\t\t\tst[1].insert(mkp(x - y, p));\n\t\t\t\tauto it = st[1].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0 || (!st[0].empty() && p1.first + p2.first < 0 && p2.first < st[0].begin()->first)) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[0].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[1].erase(p1);\n\t\t\t\t\tst[1].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres += y - b[p];\n\t\t\t\tst[0].erase(mkp(b[p] - a[p], p));\n\t\t\t\tst[0].insert(mkp(y - x, p));\n\t\t\t\tauto it = st[0].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0 || (!st[1].empty() && p1.first + p2.first < 0 && p2.first < st[1].begin()->first)) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[1].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[0].erase(p1);\n\t\t\t\t\tst[0].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!st[0].empty() && !st[1].empty() && st[0].begin()->first + st[1].begin()->first < 0) {\n\t\t\t\tpair<int, int> p1 = *st[0].begin();\n\t\t\t\tpair<int, int> p2 = *st[1].begin();\n\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\tu[p1.second] ^= true;\n\t\t\t\tu[p2.second] ^= true;\n\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\tst[0].erase(p1);\n\t\t\t\tst[1].erase(p2);\n\t\t\t}\n\t\t\ta[p] = x;\n\t\t\tb[p] = y;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = 1e18;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  assert(n == 2);\n  n *= 2;\n  vl a(n), b(n);\n  rep (i, n) {\n    cin >> a[i];\n  }\n  rep (i, n) {\n    cin >> b[i];\n  }\n  set<pii> aa, bb;\n  ll ans = 0;\n  rep (i, n) {\n    if (i == 0) {\n      ans += a[i];\n      continue;\n    }\n    if (i == n - 1) {\n      ans += a[i];\n      continue;\n    }\n    if (a[i] >= b[i]) {\n      ans += a[i];\n      aa.insert(pii(a[i] - b[i], i));\n    }\n    else {\n      ans += b[i];\n      bb.insert(pii(b[i] - a[i], i));\n    }\n  }\n  if ((int)aa.size() % 2) {\n    auto itra = aa.begin();\n    auto itrb = bb.begin();\n    pii a_s = *itra, b_s = *itrb;\n    if (a_s.first >= b_s.first) {\n      bb.erase(b_s);\n      int idx = b_s.second;\n      ans -= b[idx];\n      ans += a[idx];\n      aa.insert(pii(a[idx] - b[idx], idx));\n    }\n    else {\n      aa.erase(a_s);\n      int idx = a_s.second;\n      ans -= a[idx];\n      ans += b[idx];\n      bb.insert(pii(b[idx] - a[idx], idx));\n    }\n  }\n  while (q--) {\n    /*\n    cout << \"aa \";\n    for (auto itr = aa.begin(); itr != aa.end(); itr++) {\n      cout << *itr << \" \";\n    }\n    cout << endl;\n    cout << \"bb \";\n    for (auto itr = bb.begin(); itr != bb.end(); itr++) {\n      cout << *itr << \" \";\n    }\n    //*/\n    int p, x, y;\n    cin >> p >> x >> y;\n    p--;\n    if (p == 0 || p == n - 1) {\n      ans -= a[p];\n      a[p] = x;\n      b[p] = y;\n      ans += a[p];\n      cout << ans << endl;\n      continue;\n    }\n    if (aa.count(pii(a[p] - b[p], p))) {\n      aa.erase(pii(a[p] - b[p], p));\n      ans -= a[p];\n    }\n    else if (bb.count(pii(b[p] - a[p], p))) {\n      bb.erase(pii(b[p] - a[p], p));\n      ans -= b[p];\n    }\n    else {\n      assert(false);\n    }\n    a[p] = x;\n    b[p] = y;\n    if (a[p] >= b[p]) {\n      ans += a[p];\n      aa.insert(pii(a[p] - b[p], p));\n    }\n    else {\n      ans += b[p];\n      bb.insert(pii(b[p] - a[p], p));\n    }\n    if ((int)aa.size() % 2) {\n      auto itra = aa.begin();\n      auto itrb = bb.begin();\n      pii a_s = *itra, b_s = *itrb;\n      if (a_s.first >= b_s.first) {\n        bb.erase(b_s);\n        int idx = b_s.second;\n        ans -= b[idx];\n        ans += a[idx];\n        aa.insert(pii(a[idx] - b[idx], idx));\n      }\n      else {\n        aa.erase(a_s);\n        int idx = a_s.second;\n        ans -= a[idx];\n        ans += b[idx];\n        bb.insert(pii(b[idx] - a[idx], idx));\n      }\n    }\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INT long long\n#define MOD (INT)(1e9+7)\nusing namespace std;\nINT x, n, q, a[200020], b[200020], ans, p, y, t1, t2;\nINT f(int k, int w, int e)\n{\n    if( w < 0 or e < 0 ) return -MOD;\n    if( k == 2*n ) return ((w==0 and e==0) ? 0 : -MOD);\n    INT ret = -MOD;\n    ret = f(k+1, w+1, e+1) + a[k];\n    ret = max( ret, f(k+1, w+1, e-1) + b[k]);\n    ret = max( ret, f(k+1, w-1, e+1) + b[k]);\n    ret = max( ret, f(k+1, w-1, e-1) + a[k]);\n    return ret;\n}\nint main()\n{\n    ios::sync_with_stdio(false);\n    cin>>n>>q;\n    for(int i = 0 ; i < 2*n ; i++ ) cin>>a[i];\n    for(int i = 0 ; i < 2*n ; i++ ) cin>>b[i];\n    while( q-- )\n    {\n        cin>>p>>x>>y; p--;\n        a[p] = x, b[p] = y;\n        cout<<f(0, 0, 0)<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "    #include <bits/stdc++.h>\n                                                #include<iostream>\n                                                #include<cstdio>\n                                                #include<vector>\n                                                #include<queue>\n                                                #include<map>\n                                                #include<cstring>\n                                                #include<string>\n                                                #include <math.h>\n                                                #include<algorithm>\n                                            //    #include <boost/multiprecision/cpp_int.hpp>\n                                                #include<functional>\n                                       #define int long long\n                                                #define inf  1000000007\n                                                #define pa pair<int,int>\n                                                #define ll long long\n                                                #define pal pair<double,double>\n                                                #define ppap pair<pa,int>\n                                          #define PI 3.14159265358979323846\n                                                #define paa pair<int,char>\n                                                #define  mp make_pair\n                                                #define  pb push_back\n                                                #define EPS (1e-10)\n                                                #define equals(a,b) (fabs((a)-(b))<EPS)\n        int dx[4]={0,-1,0,1};\n        int dy[4]={1,0,-1,0};\n                                                using namespace std;\n                                       \t\t\tclass pa3{\n                                                \tpublic:\n                                                \tint x,y,z;\n                                                \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                                \tbool operator < (const pa3 &p) const{\n                                                \t\tif(x!=p.x) return x<p.x;\n                                                \t\tif(y!=p.y) return y<p.y;\n                                                \t\t return z<p.z;\n                                                \t\t//return x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                       \t\t\t\tbool operator > (const pa3 &p) const{\n                                                \t\tif(x!=p.x) return x>p.x;\n                                                \t\tif(y!=p.y) return y>p.y;\n                                                \t\t return z>p.z;\n                                                \t\t//return x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator == (const pa3 &p) const{\n                                                \t\treturn x==p.x && y==p.y && z==p.z;\n                                                \t}\n                                                \t\tbool operator != (const pa3 &p) const{\n                                                \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                                \t}\n                                                \n                                                };\n                                                \n                                                class pa4{\n                                                \tpublic:\n                                                \tint x;\n                                                \tint y,z,w;\n                                                \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                                \tbool operator < (const pa4 &p) const{\n                                                \t\tif(x!=p.x) return x<p.x;\n                                                \t\tif(y!=p.y) return y<p.y;\n                                                \t\tif(z!=p.z)return z<p.z;\n                                                \t\treturn w<p.w;\n                                                \t\t//return x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator > (const pa4 &p) const{\n                                                \t\tif(x!=p.x) return x>p.x;\n                                                \t\tif(y!=p.y) return y>p.y;\n                                                \t\tif(z!=p.z)return z>p.z;\n                                                \t\treturn w>p.w;\n                                                \t\t//return x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator == (const pa4 &p) const{\n                                                \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                                \t}\n                                                \t\n                                                \tbool operator != (const pa4 &p) const{\n                                                \t\treturn !(x==p.x && y==p.y && z==p.z &&w==p.w);\n                                                \t}\n                                                \t\t\n                                                \n                                                };\n                                                class pa2{\n                                                \tpublic:\n                                                \tint x,y;\n                                                \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                                \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                                \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                                \tbool operator < (const pa2 &p) const{\n                                                \t\treturn x!= p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator > (const pa2 &p) const{\n                                                \t\treturn x != p.x ? x>p.x: y>p.y;\n                                                \t}\n                                                \tbool operator == (const pa2 &p) const{\n                                                \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                                \t}\n                                                \tbool operator != (const pa2 &p) const{\n                                                \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                                \t}\n                                                \t\t\n                                                \n                                                };\n                                                \n                                                       #define ppa pair<int,pas>\n                                                class Point{\n                                                \tpublic:\n                                                \tdouble x,y;\n                                                \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                                \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                                \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                                \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                                \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                                \tdouble absv() {return sqrt(norm());}\n                                                \tdouble norm() {return x*x+y*y;}\n                                                \tbool operator < (const Point &p) const{\n                                                \t\treturn x != p.x ? x<p.x: y<p.y;\n                                                \t}\n                                                \tbool operator == (const Point &p) const{\n                                                \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                                \t}\n                                                };\n                                                typedef Point Vector;\n                                         #define pl pair<int,pas>\n                                                struct Segment{\n                                                Point p1,p2;\n                                                };\n                                                 double dot(Vector a,Vector b){\n                                                \treturn a.x*b.x+a.y*b.y;\n                                                }\n                                                double cross(Vector a,Vector b){\n                                                \treturn a.x*b.y-a.y*b.x;\n                                                }\n                                            \n                    bool parareru(Point a,Point b,Point c,Point d){\n                    //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n                    \treturn abs(cross(a-b,d-c))<EPS;\n                    }\n                    double distance_ls_p(Point a, Point b, Point c) {\n                      if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n                      if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n                      return abs(cross(b-a, c-a)) / (b-a).absv();\n                    }\n                    bool is_intersected_ls(Segment a,Segment b) {\n                    \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n                    \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n                    //\t\tcout<<\"sss\"<<endl;\n                    \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n                    \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n                    \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n                    \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n                    \t\treturn false;\n                    \t}\n                      else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n                    }\n                     \n                    double segment_dis(Segment a,Segment b){\n                    \tif(is_intersected_ls(a,b))return 0;\n                    \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n                    \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n                    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n                    \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n                    \treturn r;\n                    }\n                    Point intersection_ls(Segment a, Segment b) {\n                      Point ba = b.p2-b.p1;\n                      double d1 = abs(cross(ba, a.p1-b.p1));\n                      double d2 = abs(cross(ba, a.p2-b.p1));\n                      double t = d1 / (d1 + d2);\n                     \n                      return a.p1 + (a.p2-a.p1) * t;\n                    }\n                     \n                                    string itos( int i ) {\n                                    ostringstream s ;\n                                    s << i ;\n                                    return s.str() ;\n                                    }\n                                     \n                                    int gcd(int v,int b){\n                                    \tif(v>b) return gcd(b,v);\n                                    \tif(v==b) return b;\n                                    \tif(b%v==0) return v;\n                                    \treturn gcd(v,b%v);\n                                    }\n                     \n                                    double distans(double x1,double y1,double x2,double y2){\n                                    \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                                    \treturn sqrt(rr);\n                                    \t\n                                    }\n                                    int mod;\n                    int pr[2010];\n                    int inv[2010];\n                   \n                    int beki(int wa,int rr,int warukazu){\n                    \tif(rr==0) return 1%warukazu;\n                    \tif(rr==1) return wa%warukazu;\n                    \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n                    \tint zx=beki(wa,rr/2,warukazu);\n                    \treturn (zx*zx)%warukazu;\n                    }\n                    /*\n        double bekid(double w,int r){\n        \tif(r==0) return 1.0;\n        \tif(r==1) return w;\n        \tif(r%2) return bekid(w,r-1)*w;\n        \tdouble f=bekid(w,r/2);\n        \treturn f*f;\n        }*/\n            /*        \n        \t\t\tint comb(int nn,int rr){\n        \t\t\t\tint r=pr[nn]*inv[rr];\n        \t\t\t\tr%=mod;\n        \t\t\t\tr*=inv[nn-rr];\n        \t\t\t\tr%=mod;\n        \t\t\t\treturn r;\n        \t\t\t}\n              */      \n                    void gya(int ert){\n                    \tpr[0]=1;\n                    \tfor(int i=1;i<ert;i++){\n                    \t\tpr[i]=(pr[i-1]*i)%mod;\n                    \t}\n                    \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],mod-2,mod);\n                    \t\n                    }\n                    \n                  //   cin.tie(0);\n        \t\t//\tios::sync_with_stdio(false);\n        \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                     //sort(ve.begin(),ve.end(),greater<int>());\n                                             //----------------kokomade tenpure------------\nint a[200020],b[200020];\nint n;\nint ans;\nmultiset<int>s1,s2;\nint pos=0,neg=0;\n\tvoid solve(){\n\t\t        \t\tint p,x,y;\n        \t\tcin>>p>>x>>y;\n        \t\tp--;\n\tcout<<endl;\n\t\tif(p==0){\n\t\t\tans+=x-a[0];\n\t\t}\n\t\telse if(p==2*n-1){\n\t\t\tans+=x-a[2*n-1];\n\t\t}\n\t\telse{\n\t\t\tans-=a[p];\n\t\t\tans+=x;\n\t\t\tint sa=b[p]-a[p];\n\t\n\t\t\tif(sa>=0){\n\t\t\t\tpos-=sa;\n\t\t\t\ts1.erase(s1.find(sa));\n\t\t\t}\n\t\t\telse{\n\t\t\t\tneg+=sa;\n\t\t\t\t\n\t\t\t\ts2.erase(s2.find(-sa));\n\t\t\t}\n\t\t\n\t\t\tsa=y-x;\n\t\t\tif(sa>=0){\n\t\t\tpos+=sa;\n\t\t\t\ts1.insert(sa);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tneg-=sa;\n\t\t\t\ts2.insert(-sa);\n\t\t\t}\n\t\t}\n\t\t\n        \t\ta[p]=x;\n        \t\tb[p]=y;\n\t\tint as;\n\t\tif(s1.size()%2==0){\n\t\t\tas=pos;\n\t\t}\n\t\telse{\n\t\t\tas=pos;\n\t\t\tint minpos=*(s1.begin());\n\t\t\tint maxneg=-*(s2.begin());\n\t\t\tif(minpos+maxneg>=0) as=pos+maxneg;\n\t\t\telse as=pos-minpos;\n\t\t}\n\t\tcout<<ans+as<<endl;\n\t}\n        signed main(){\n                   cin.tie(0);\n        \t\tios::sync_with_stdio(false);\nint q;\n        \tcin>>n>>q;\n        \tfor(int i=0;i<2*n;i++){\n        \t\tcin>>a[i];\n        \tans+=a[i];\n        \t}\n        \tfor(int i=0;i<2*n;i++)cin>>b[i];\n        \tfor(int i=1;i<2*n-1;i++){\n        \t\t\n        \t\tif(b[i]-a[i]>=0) s1.insert(b[i]-a[i]),pos+=b[i]-a[i];\n        \t\telse s2.insert(a[i]-b[i]),neg+=a[i]-b[i];\n        \t}\n        \t\n        \tfor(int i=0;i<q;i++){\n\n        \t\tsolve();\n        \t}\n        \treturn 0;\n                }"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<unordered_map>\n#include<array>\n#include<map>\n#include<bitset>\n#include<iomanip>\n#include<list>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n#define RE return 0\n//ios::sync_with_stdio(false);\n//std::cin.tie(0);\n//<< setprecision(20)\nconst int mod=1e9+7;\nconst int big=1e9+100;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double ena=2.71828182845904523536;\nconst long double eps=1e-7;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\ntemplate <class T> void soun(T& ar)\n{sort(ar.begin(),ar.end());ar.erase(unique(ar.begin(),ar.end()),ar.end());}\nint main(void){\n\tint n,q,i,j;cin>>n>>q;\n\tvector<llint>A(2*n);\n\tvector<llint>B(2*n);\n\tllint ans=0,ki=0;\n\tfor(i=0;i<2*n;i++){cin>>A[i];}\n\tfor(i=0;i<2*n;i++){cin>>B[i];}\n\tmultiset<llint>osi;\n\tans+=A[0]+A[2*n-1];\n\tfor(i=1;i<2*n-1;i++){\n\t\tans+=max(A[i],B[i]);\n\t\tif(B[i]>A[i]){ki++;}\n\t\tosi.ins(abs(A[i]-B[i]));\n\t}\n\twhile(q--){\n\t\tint p;llint x,y;cin>>p>>x>>y;p--;\n\t\tif(p==0||p==2*n-1){ans-=A[p];ans+=x;A[p]=x;B[p]=y;}\n\t\telse{\n\t\t\tans-=max(A[p],B[p]);\n\t\t\tif(B[p]>A[p]){ki--;}\n\t\t\tosi.era(osi.lower_bound(abs(A[p]-B[p])));\n\t\t\tA[p]=x;B[p]=y;\n\t\t\tans+=max(A[p],B[p]);\n\t\t\tif(B[p]>A[p]){ki++;}\n\t\t\tosi.ins(abs(A[p]-B[p]));\n\t\t}\n\t\tif(ki%2==1){cout<<ans-(*osi.begin())<<endl;}\n\t\telse{cout<<ans<<endl;}\n\t}\n\tRE;\n}//もやし動物園でログインしていた..."
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sp ' '\n#define mkp make_pair\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define lP pair<ll,ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\nconst int mod = 1000000007, mod998 = 998244353;\nconst string nyan(\"(=^・ω・^=)\");\n\nint N, Q, a[200000], b[200000], p, x, y;\nbool u[200000];\nset<pair<int, int>>st[2];\nll res;\n\nint main() {\n\tcin >> N >> Q;\n\t--Q;\n\tN *= 2;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> b[i];\n\t}\n\tcin >> p >> x >> y;\n\t--p;\n\ta[p] = x;\n\tb[p] = y;\n\tres = a[0] + a[N - 1];\n\tfor (int i = 1; i < N - 1; ++i) {\n\t\tif (a[i] >= b[i]) {\n\t\t\tu[i] = true;\n\t\t\tres += a[i];\n\t\t\tst[1].insert(mkp(a[i] - b[i], i));\n\t\t}\n\t\telse {\n\t\t\tres += b[i];\n\t\t\tst[0].insert(mkp(b[i] - a[i], i));\n\t\t}\n\t}\n\tif (st[0].size() & 1) {\n\t\tpair<int, int>p1, p2;\n\t\tp1 = *st[0].begin();\n\t\tp2 = *st[1].begin();\n\t\tif (p1.first > p2.first) {\n\t\t\tres -= p2.first;\n\t\t\tu[p2.second] ^= true;\n\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\tst[1].erase(p2);\n\t\t}\n\t\telse {\n\t\t\tres -= p1.first;\n\t\t\tu[p1.second] ^= true;\n\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\tst[0].erase(p1);\n\t\t}\n\t}\n\tcout << res << endl;\n\twhile (Q--) {\n\t\tcin >> p >> x >> y;\n\t\t--p;\n\t\tif (p == 0 || p == N - 1) {\n\t\t\tres += x - a[p];\n\t\t\ta[p] = x;\n\t\t}\n\t\telse {\n\t\t\tif (u[p]) {\n\t\t\t\tres += x - a[p];\n\t\t\t\tst[1].erase(mkp(a[p] - b[p], p));\n\t\t\t\tst[1].insert(mkp(x - y, p));\n\t\t\t\tauto it = st[1].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0 || (!st[0].empty() && p1.first + p2.first < 0 && p2.first < st[0].begin()->first) || (!st[0].empty() && it->first + it2->first < 0)) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[0].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[1].erase(p1);\n\t\t\t\t\tst[1].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres += y - b[p];\n\t\t\t\tst[0].erase(mkp(b[p] - a[p], p));\n\t\t\t\tst[0].insert(mkp(y - x, p));\n\t\t\t\tauto it = st[0].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0 || (!st[1].empty() && p1.first + p2.first < 0 && p2.first < st[1].begin()->first) || (st[1].empty() && p1.first + p2.first < 0)) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[1].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[0].erase(p1);\n\t\t\t\t\tst[0].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!st[0].empty() && !st[1].empty() && st[0].begin()->first + st[1].begin()->first < 0) {\n\t\t\t\tpair<int, int> p1 = *st[0].begin();\n\t\t\t\tpair<int, int> p2 = *st[1].begin();\n\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\tu[p1.second] ^= true;\n\t\t\t\tu[p2.second] ^= true;\n\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\tst[0].erase(p1);\n\t\t\t\tst[1].erase(p2);\n\t\t\t}\n\t\t\ta[p] = x;\n\t\t\tb[p] = y;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<::std::uint_fast64_t mod>\nclass ModInt{\nprivate:\n    using value_type = ::std::uint_fast64_t;\n    value_type n;\npublic:\n    ModInt() : n(0) {}\n    ModInt(value_type n_) : n(n_ % mod) {}\n    ModInt(const ModInt& m) : n(m.n) {}\n\n    template<typename T>\n    explicit operator T() const { return static_cast<T>(n); }\n    value_type get() const { return n; }\n\n    friend ::std::ostream& operator<<(::std::ostream &os, const ModInt<mod> &a) {\n        return os << a.n;\n    }\n\n    friend ::std::istream& operator>>(::std::istream &is, ModInt<mod> &a) {\n        value_type x;\n        is >> x;\n        a = ModInt<mod>(x);\n        return is;\n    }\n\n    bool operator==(const ModInt& m) const { return n == m.n; }\n    bool operator!=(const ModInt& m) const { return n != m.n; }\n    ModInt& operator*=(const ModInt& m){ n = n * m.n % mod; return *this; }\n\n    ModInt pow(value_type b) const{\n        ModInt ans = 1, m = ModInt(*this);\n        while(b){\n            if(b & 1) ans *= m;\n            m *= m;\n            b >>= 1;\n        }\n        return ans;\n    }\n\n    ModInt inv() const { return (*this).pow(mod-2); }\n    ModInt& operator+=(const ModInt& m){ n += m.n; n = (n < mod ? n : n - mod); return *this; }\n    ModInt& operator-=(const ModInt& m){ n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n    ModInt& operator/=(const ModInt& m){ *this *= m.inv(); return *this; }\n    ModInt operator+(const ModInt& m) const { return ModInt(*this) += m; }\n    ModInt operator-(const ModInt& m) const { return ModInt(*this) -= m; }\n    ModInt operator*(const ModInt& m) const { return ModInt(*this) *= m; }\n    ModInt operator/(const ModInt& m) const { return ModInt(*this) /= m; }\n    ModInt& operator++(){ n += 1; return *this; }\n    ModInt& operator--(){ n -= 1; return *this; }\n    ModInt operator++(int){\n        ModInt old(n);\n        n += 1;\n        return old;\n    }\n    ModInt operator--(int){\n        ModInt old(n);\n        n -= 1;\n        return old;\n    }\n    ModInt operator-() const { return ModInt(mod-n); }\n};\n\nclass UnionFind{\nprivate:\n    ::std::vector<int_fast32_t> par;\n    vector<int64> sum;\n    size_t n;\n\npublic:\n    UnionFind(){}\n    UnionFind(size_t n):n(n){\n        par.resize(n, -1);\n        sum.resize(n, 0);\n    }\n\n    void set_sum(const vector<int64>& s) {\n        sum = s;\n    }\n\n    uint_fast32_t find(uint_fast32_t x){\n        return par[x] < 0 ? x : par[x] = find(par[x]);\n    }\n\n    size_t size(uint_fast32_t x){\n        return -par[find(x)];\n    }\n\n    int64 sum_v(int64 x) {\n        return sum[find(x)];\n    }\n\n    bool unite(uint_fast32_t x, uint_fast32_t y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return false;\n        if(size(x) < size(y)) std::swap(x, y);\n        par[x] += par[y];\n        sum[x] += sum[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool same(uint_fast32_t x, uint_fast32_t y){\n        return find(x) == find(y);\n    }\n};\n\n\n\nint main(void) {\n    int64 N, Q;\n    cin >> N >> Q;\n    N*=2;\n    vector<int64> a(N), b(N);\n    REP(i, N) cin >> a[i];\n    REP(i, N) cin >> b[i];\n    multiset<PLL> as, bs;\n    vector<int64> wh(N);\n    int64 res = a[0] + a.back();\n    FOR(i, 1, N-1) {\n        if (a[i] >= b[i]) {\n            as.insert(PLL(a[i]-b[i], i));\n            res += a[i];\n            wh[i] = 0;\n        } else {\n            bs.insert(PLL(b[i]-a[i], i));\n            res += b[i];\n            wh[i] = 1;\n        }\n    }\n    REP(i, Q) {\n//        cout << endl;\n        int64 p, x, y;\n        cin >> p >> x >> y; p--;\n        if (p == 0 || p == N-1) {\n            res -= a[p];\n            a[p] = x; b[p] = y;\n            res += a[p];\n        } else {\n            if (wh[p] == 0) {\n                res -= a[p];\n                as.erase(as.lower_bound(PLL(a[p]-b[p], p)));\n            } else {\n                res -= b[p];\n                bs.erase(bs.lower_bound(PLL(b[p]-a[p], p)));\n            }\n            a[p] = x; b[p] = y;\n            if (a[p] >= b[p]) {\n                res += a[p];\n                wh[p] = 0;\n                as.insert(PLL(a[p]-b[p], p));\n            } else {\n                res += b[p];\n                wh[p] = 1;\n                bs.insert(PLL(b[p]-a[p], p));\n            }\n//            cout << res << endl;\n            if (as.size() % 2) {\n                auto ia = *as.begin(), ib = *bs.begin();\n                if (ia.fs >= ib.fs) {\n                    res -= ib.fs;\n                    wh[ib.sc] = 0;\n                    as.insert(PLL(-ib.fs, ib.sc));\n                    bs.erase(bs.begin());\n                } else {\n                    res -= ia.fs;\n                    wh[ia.sc] = 1;\n                    bs.insert(PLL(-ia.fs, ia.sc));\n                    as.erase(as.begin());\n                }\n            }\n        }\n//        for (auto x : as) {\n//            cout << x.fs << \" \";\n//        }\n//        cout << endl;\n//        for (auto x : bs) {\n//            cout << x.fs << \" \";\n//        }\n//        cout << endl;\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\ntypedef long long ll;\n\nusing namespace std;\n\nint N, Q;\nll A[200010], B[200010]; //[0, 2 * N) !!\nmultiset<ll> S;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin >> N >> Q;\n\trep(i, 0, 2 * N) cin >> A[i];\n\trep(i, 0, 2 * N) cin >> B[i];\n\n\tll ans = 0; bool odd = false;\n\tans += A[0] + A[2 * N - 1];\n\trep(i, 1, 2 * N - 1) {\n\t\tans += max(A[i], B[i]);\n\t\todd ^= (A[i] > B[i]);\n\t\tS.insert(abs(A[i] - B[i]));\n\t}\n\twhile(Q--) {\n\t\tll a, x, y;\n\t\tcin >> a >> x >> y; a--;\n\t\tif(a == 0 || a == 2 * N - 1) {\n\t\t\tans += x - A[a];\n\t\t\tA[a] = x;\n\t\t}\n\t\telse {\n\t\t\todd ^= (A[a] > B[a]);\n\t\t\todd ^= (x > y);\n\t\t\tans += max(x, y) - max(A[a], B[a]);\n\t\t\tS.erase(S.lower_bound(abs(A[a] - B[a])));\n\t\t\tS.insert(abs(x - y));\n\t\t\tA[a] = x; B[a] = y;\n\t\t}\n\t\tcout << (!odd ? ans : ans - (*S.begin())) << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n\ntypedef long long ll;\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = 1e18;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { 1,0, -1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n//#define mp make_pair\n\nint main() {\n  int n, q;\n  cin >> n >> q;\n  n *= 2;\n  vl a(n), b(n);\n  rep (i, n) {\n    cin >> a[i];\n  }\n  rep (i, n) {\n    cin >> b[i];\n  }\n  set<pii> aa, bb;\n  ll ans = 0;\n  rep (i, n) {\n    if (i == 0) {\n      ans += a[i];\n      continue;\n    }\n    if (i == n - 1) {\n      ans += a[i];\n      continue;\n    }\n    if (a[i] >= b[i]) {\n      ans += a[i];\n      aa.insert(pii(a[i] - b[i], i));\n    }\n    else {\n      ans += b[i];\n      bb.insert(pii(b[i] - a[i], i));\n    }\n  }\n  if ((int)aa.size() % 2) {\n    assert(aa.begin()->first >= 0 || bb.begin()->first >= 0);\n    auto itra = aa.begin();\n    auto itrb = bb.begin();\n    pii a_s = *itra, b_s = *itrb;\n    if (a_s.first >= b_s.first) {\n      bb.erase(b_s);\n      int idx = b_s.second;\n      ans -= b[idx];\n      ans += a[idx];\n      aa.insert(pii(a[idx] - b[idx], idx));\n    }\n    else {\n      aa.erase(a_s);\n      int idx = a_s.second;\n      ans -= a[idx];\n      ans += b[idx];\n      bb.insert(pii(b[idx] - a[idx], idx));\n    }\n  }\n  while (q--) {\n    /*\n    DEBUG(ans);\n    cout << \"aa \";\n    for (auto itr = aa.begin(); itr != aa.end(); itr++) {\n      cout << *itr << \" \";\n    }\n    cout << endl;\n    cout << \"bb \";\n    for (auto itr = bb.begin(); itr != bb.end(); itr++) {\n      cout << *itr << \" \";\n    }\n    //*/\n    int p, x, y;\n    cin >> p >> x >> y;\n    p--;\n    if (p == 0 || p == n - 1) {\n      ans -= a[p];\n      a[p] = x;\n      b[p] = y;\n      ans += a[p];\n      cout << ans << endl;\n      continue;\n    }\n    if (aa.count(pii(a[p] - b[p], p))) {\n      aa.erase(pii(a[p] - b[p], p));\n      ans -= a[p];\n    }\n    else if (bb.count(pii(b[p] - a[p], p))) {\n      bb.erase(pii(b[p] - a[p], p));\n      ans -= b[p];\n    }\n    else {\n      assert(false);\n    }\n    a[p] = x;\n    b[p] = y;\n    if (a[p] >= b[p]) {\n      ans += a[p];\n      aa.insert(pii(a[p] - b[p], p));\n    }\n    else {\n      ans += b[p];\n      bb.insert(pii(b[p] - a[p], p));\n    }\n    if ((int)aa.size() % 2) {\n      auto itra = aa.begin();\n      auto itrb = bb.begin();\n      pii a_s = *itra, b_s = *itrb;\n      if (a_s.first >= b_s.first) {\n        bb.erase(b_s);\n        int idx = b_s.second;\n        ans -= b[idx];\n        ans += a[idx];\n        aa.insert(pii(a[idx] - b[idx], idx));\n      }\n      else {\n        aa.erase(a_s);\n        int idx = a_s.second;\n        ans -= a[idx];\n        ans += b[idx];\n        bb.insert(pii(b[idx] - a[idx], idx));\n      }\n    }\n    if (aa.size() > 0 && bb.size() > 0) {\n      pii a_s = *aa.begin(), b_s = *bb.begin();\n      if (a_s.first + b_s.first < 0) {\n        aa.erase(a_s);\n        bb.erase(b_s);\n        b_s.first *= -1;\n        a_s.first *= -1;\n        ans += b_s.first + a_s.first;\n        aa.insert(b_s);\n        bb.insert(a_s);\n      }\n    }\n        \n        \n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(LL i=0;i<(LL)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n#define LL long long\n#define pii pair<LL,LL>\n#define pll pair<LL,LL>\n\nusing namespace std;\n\nstruct SegmentTree{\n\n    LL n=2;\n    vector<LL> data;\n    vector<LL> num;\n    vector<LL> minusmax;\n    vector<LL> plusmin;\n\n    SegmentTree(LL _n){\n        n = 2;\n        while(n<_n)n*=2;\n        data.resize(2*n-1, INT_MIN);\n        num.resize(2*n-1, 0);\n        minusmax.resize(2*n-1, INT_MIN);\n        plusmin.resize(2*n-1, INT_MAX);\n    }\n\n    void set(LL pos, LL x){\n        pos += n-1;\n        data[pos]=x;\n        if(x > 0){\n            num[pos] = 1;\n            plusmin[pos] = x;\n            minusmax[pos] = INT_MIN;\n        }else{\n            num[pos]=0;\n            minusmax[pos] = x;\n            plusmin[pos] = INT_MAX;\n        }\n        while(pos > 0){\n            pos = (pos-1)/2;\n            data[pos] = (max(0LL, data[2*pos +1]) + max(0LL, data[2*pos +2]));\n            num[pos] = num[2*pos +1] + num[2*pos + 2];\n            minusmax[pos] = max(minusmax[2*pos + 1], minusmax[2*pos + 2]);\n            plusmin[pos] = min(plusmin[2*pos + 1], plusmin[2*pos + 2]);\n        }\n    }\n\n    LL getSum(LL l, LL r, LL a=0, LL b=-1, LL pos=0){\n        if(b<0)b=n;\n        if(l>=b || r <= a)return 0;\n        if(l<=a && r <= b)return data[pos];\n        return getSum(l, r, a, (a+b)/2, pos*2+1) + getSum(l, r, (a+b)/2, b, pos*2+2);\n    }\n    LL getNum(LL l,LL r, LL a=0, LL b=-1, LL pos=0){\n        if(b<0)b=n;\n        if(l>=b || r <= a)return 0;\n        if(l<=a && r <= b)return num[pos];\n        return getNum(l, r, a, (a+b)/2, pos*2+1) + getNum(l, r, (a+b)/2, b, pos*2+2);\n    }\n    LL getMinusMax(LL l,LL r,LL a=0, LL b=-1, LL pos=0){\n        if(b<0)b=n;\n        if(l>=b || r <= a)return INT_MIN;\n        if(l<=a && r <= b)return minusmax[pos];\n        return max(getMinusMax(l, r, a, (a+b)/2, pos*2+1) ,getMinusMax(l, r, (a+b)/2, b, pos*2+2));\n    }\n    LL getPlusMin(LL l,LL r,LL a=0, LL b=-1, LL pos=0){\n        if(b<0)b=n;\n        if(l>=b || r <= a)return INT_MAX;\n        if(l<=a && r <= b)return plusmin[pos];\n        return min(getPlusMin(l, r, a, (a+b)/2, pos*2+1) ,getPlusMin(l, r, (a+b)/2, b, pos*2+2));\n    }\n\n};\n\n\nint main(){\n\n    LL N,Q;cin>>N>>Q;\n    LL ans=0;\n    LL a[2*N], b[2*N];\n\n    REP(i,2*N)cin>>a[i];\n    REP(i,2*N)cin>>b[i];\n\n    REP(i,2*N)ans += a[i];\n    SegmentTree st(2*N-2);\n    REP(i,2*N-2)st.set(i, b[i+1]-a[i+1]);\n\n    while(Q--){\n        LL p,x,y;cin>>p>>x>>y;\n        ans -= a[--p];\n        a[p]=x;\n        b[p]=y;\n        ans += a[p];\n        st.set(p-1, y-x);\n        LL res = ans + st.getSum(0,2*N-2);\n        if(st.getNum(0,2*N-2)%2==1){\n            res = max(res - st.getPlusMin(0,2*N-2), res + st.getMinusMax(0,2*N-2));\n        }\n\n\n        cout<<res<<endl;\n\n    }\n\n\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,a) for(int i=0;i<(a);i++)\nconst ll MOD=1000000007;\n\nint A[202020], B[202020];\nmultiset<int> p,m;\n\nint main(){\n  int N,Q; cin>>N>>Q;\n  ll S=0;\n  rep(i,2*N){\n    cin>>A[i];\n    S+=A[i];\n  }\n\n  ll T=0;\n  rep(i,2*N){\n    cin>>B[i];\n    B[i]-=A[i];\n    if(i!=0&&i!=2*N-1){\n      if(B[i]>0){\n        p.insert(B[i]);\n        T+=B[i];\n      }else{\n        m.insert(-B[i]);\n      }\n    }\n  }\n  while(Q--){\n    ll i,x,y; cin>>i>>x>>y; i--;\n    S-=A[i];\n    if(i!=0&&i!=2*N-1){\n      if(B[i]>0){\n        p.erase(p.find(B[i]));\n        T-=B[i];\n      }else{\n        m.erase(m.find(-B[i]));\n      }\n    }\n\n    A[i]=x;\n    S+=A[i];\n    B[i]=y-x;\n    if(i!=0&&i!=2*N-1){\n      if(B[i]>0){\n        p.insert(B[i]);\n        T+=B[i];\n      }else{\n        m.insert(-B[i]);\n      }\n    }\n\n    ll ans;\n    if(p.size()%2==0) ans=S+T;\n    else ans=S+T-min(*p.begin(),*m.begin());\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<class ValueMonoid, template<class...> class Container=::std::vector>\nclass SegTree{\npublic:\n    using value_structure = ValueMonoid;\n    using value_type = typename value_structure::value_type;\n    using const_reference = const value_type &;\n    using container_type = Container<value_type>;\n    using size_type = typename container_type::size_type;\n\nprivate:\n    ::std::vector<value_type> tree;\n    size_type size_;\n\n    static size_type getsize(const size_type x){\n        size_type ret = 1;\n        while(ret < x)\n            ret <<= 1;\n        return ret;\n    }\n\n    inline value_type calc(const value_type a, const value_type b){\n        return value_structure::operation(a, b);\n    }\n\n    inline void calc_node(const size_type index){\n        if(tree.size() <= (index << 1 | 1)) return;\n        tree[index] = value_structure::operation(tree[index<<1], tree[index<<1 | 1]);\n    }\npublic:\n    SegTree() : size_(0), tree(){}\n    SegTree(const size_type size)\n            : size_(size), tree(size << 1, value_structure::identity()){}\n    template<class InputIterator>\n    SegTree(InputIterator first, InputIterator last)\n            : size_(::std::distance(first, last)){\n        tree = container_type(size_, value_structure::identity());\n        tree.insert(tree.end(), first, last);\n        for(size_type i = size_;i > 0;i--){\n            calc_node(i);\n        }\n    }\n\n    size_type size() const { return size_; }\n    const_reference operator[](const size_type k) const {\n        assert(k < size_);\n        return tree[k+size_];\n    }\n\n    value_type query(size_type l, size_type r){\n        assert(l <= r);\n        assert(0 <= l && l < size_);\n        assert(0 <= r && r <= size_);\n        value_type retl = value_structure::identity(), retr = value_structure::identity();\n        for(l += size_, r += size_; l < r ; l >>= 1, r >>= 1){\n            if(l&1) retl = calc(retl, tree[l++]);\n            if(r&1) retr = calc(tree[--r], retr);\n        }\n        return calc(retl, retr);\n    }\n\n    template<class F>\n    void update(size_type index, const F& f){\n        assert(0 <= index && index < size());\n        index += size_;\n        tree[index] = f(::std::move(tree[index]));\n        while(index >>= 1)\n            calc_node(index);\n    }\n\n    /*\n    template<class F>\n    size_type search(const F& f) const { // [0, result) is True and [0, result-1) is not.\n        if(f(value_structure::identity()))\n            return 0;\n        if(!f(tree[1]))\n            return size_+1;\n        value_type acc = value_structure::identity();\n        size_type i = 1;\n        while(i <\n    }\n    */\n};\n\nclass v_monoid {\npublic:\n    using value_type = PLL;\n    static value_type identity() { return PLL(-INF_LL, -INF_LL); }\n    static value_type initializer() { return {-INF_LL, -INF_LL}; }\n    static value_type operation(const value_type& a, const value_type& b) {\n        if (a == identity()) return b;\n        if (b == identity()) return a;\n        return {max(a.fs+b.fs, a.sc+b.sc), max(a.fs+b.sc, a.sc+b.fs)};\n    }\n};\n\nint main(void) {\n    int64 N, Q;\n    cin >> N >> Q;\n    N *= 2;\n    vector<int64> a(N), b(N);\n    REP(i, N) cin >> a[i];\n    REP(i, N) cin >> b[i];\n    int64 res = a[0] + a.back();\n    SegTree<v_monoid> sg(N);\n    FOR(i, 1, N-1) {\n        sg.update(i, [&](const PLL x) { return PLL(a[i], b[i]); });\n    }\n    REP(i, Q) {\n        int64 p, x, y;\n        cin >> p >> x >> y; p--;\n        if (p == 0 || p == N-1) {\n            res -= a[p]; res += x;\n            a[p] = x;\n        } else {\n            sg.update(p, [&](const PLL alskdj) { return PLL(x, y); });\n        }\n        cout << res + sg.query(1, N).fs << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define REP(e,v) for(auto e:v)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define tii tuple<int,int,int>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define edge(v,a,b) v[a].pb(b);v[b].pb(a);\n#define MAX_V 400010\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n#define INF 1e9+7\n#define LLINF 1e18+7\nll MOD=1e9+7;\n#define N 1055050\n\nll n,m,k;\nll a[N],b[N];\ntemplate< typename Monoid >\nstruct SegmentTree {\n  using F = function< Monoid(Monoid, Monoid) >;\n \n  int sz;\n  vector< Monoid > seg;\n \n  const F f;\n  const Monoid M1;\n \n  SegmentTree(int n, const F f, const Monoid &M1) : f(f), M1(M1) {\n    sz = 1;\n    while(sz < n) sz <<= 1;\n    seg.assign(2 * sz, M1);\n  }\n \n  void set(int k, const Monoid &x) {\n    seg[k + sz] = x;\n  }\n \n  void build() {\n    for(int k = sz - 1; k > 0; k--) {\n      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n    }\n  }\n \n  void update(int k, const Monoid &x) {\n    k += sz;\n    seg[k] = x;\n    while(k >>= 1) {\n      seg[k] = f(seg[2 * k + 0], seg[2 * k + 1]);\n    }\n  }\n \n  Monoid query(int a, int b) {\n    Monoid L = M1, R = M1;\n    for(a += sz, b += sz; a < b; a >>= 1, b >>= 1) {\n      if(a & 1) L = f(L, seg[a++]);\n      if(b & 1) R = f(seg[--b], R);\n    }\n    return f(L, R);\n  }\n \n  Monoid operator[](const int &k) const {\n    return seg[k + sz];\n  }\n};\n//SegmentTree(n,f,M1) nで初期化　fは二項演算　M1は単位元\n//set(k,x) 要素k = x\n//build() 構築\n//query 区間[a,b)に二項演算\n//update(k,x) kをxに\n//operator[k] k番目の要素\n// SegmentTree< int > seg(N,[](int a,int b){return min(a,b);},INF);\n//みたいに使う\nmain(){\n    n=in();\n    int q=in();\n    SegmentTree<ll> seg(n*2+3,[](ll a,ll b){return min(a,b);},LLINF),seg2(n*2+3,[](ll a,ll b){return min(a,b);},LLINF);\n    ll sum=0;\n    rep(i,n*2){\n        a[i]=in();\n        sum+=a[i];\n    }\n    int count=0;\n    ll dif=0;\n    rep(i,n*2){\n        b[i]=in();\n        if(i==0||i==n*2-1)continue;\n        if(b[i]>a[i]){\n            seg.set(i,b[i]-a[i]);\n            dif+=b[i]-a[i];\n            count++;\n        }\n        else{\n            seg2.set(i,a[i]-b[i]);\n        }\n    }\n    seg.build();seg2.build();\n    rep(iii,q){\n        int p=in();p--;\n        ll prea=a[p],preb=b[p];\n        a[p]=in();b[p]=in();\n        sum+=a[p]-prea;\n        if(p==0||p==n*2-1){\n            goto G;\n        }\n        if(preb>prea){\n            count--;\n            dif-=preb-prea;\n            seg.update(p,LLINF);\n        }\n        else{\n            seg2.update(p,LLINF);\n        }\n        if(b[p]>a[p]){\n            count++;\n            seg.update(p,b[p]-a[p]);\n            dif+=b[p]-a[p];\n        }\n        else{\n            seg2.update(p,a[p]-b[p]);\n        }\n        G:\n        if(count%2){\n            ll ans=sum+dif;\n            ans+=max(-seg.query(0,2*n),-seg2.query(0,2*n));\n            cout<<ans<<endl;\n        }\n        else cout<<sum+dif<<endl;\n    }\n}\n/*1 4 7 3\n4 6 3 3\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\n\nclass segtree{\npublic:\n\tstatic const int N=1<<19;\n\tll dp[2][1<<20];\n\tsegtree(){\n\t\tmemset(dp,0,sizeof(dp));\n\t}\n\tvoid update(int lv,int k,ll v){\n\t\tk+=N-1;\n\t\tdp[lv][k]+=v;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tdp[lv][k]=dp[lv][k*2+1]+dp[lv][k*2+2];\n\t\t}\n\t}\n\n\tll query(int lv,int a,int b,int k=0,int l=0,int r=N){\n\t\tif(b<=l || r<=a)return 0;\n\t\tif(a<=l && r<=b)return dp[lv][k];\n\t\tint mid=(l+r)/2;\n\t\tll vl=query(lv,a,b,k*2+1,l,mid);\n\t\tll vr=query(lv,a,b,k*2+2,mid,r);\n\t\treturn vl+vr;\n\t}\n\n\tll get(int v){\n\t\tint l=0,r=N,k=0;\n\t\tint cnt=0;\n\t\twhile(l+1<r){\n\t\t\tif(dp[0][k*2+2]+cnt<=v){\n\t\t\t\tcnt+=dp[0][k*2+2];\n\t\t\t\tk=k*2+1;\n\t\t\t\tr=(l+r)/2;\n\t\t\t}else{\n\t\t\t\tk=k*2+2;\n\t\t\t\tl=(l+r)/2;\n\t\t\t}\n\t\t}\n\t\t//printf(\"%d %d %lld\\n\",v,r,query(1,r-1,N));\n\t\treturn query(1,r,N);\n\t}\n\n\tll find(){\n\t\tint vl=0,vr=n-1;\n\t\tfor(int i=0;i<100;i++){\n\t\t\tint midl=(vl*2+vr)/3;\n\t\t\tint midr=(vl+vr*2)/3;\n\t\t\tif(get(midl*2)<=get(midr*2)){\n\t\t\t\tvl=midl;\n\t\t\t}else{\n\t\t\t\tvr=midr;\n\t\t\t}\n\t\t}\n\t\tll maxi=0;\n\t\tfor(int i=vl;i<=vr;i++){\n\t\t\tmaxi=max(maxi,get(i*2));\n\t\t}\n\t\treturn maxi;\n\t}\n};\n\nsegtree seg;\n\nint q;\nll a[200005],b[200005];\nint p[200005];\nll x[200005],y[200005];\nvector<ll> vec;\n\nint main(void){\n\tscanf(\"%d%d\",&n,&q);\n\tll ans=0;\n\tfor(int i=0;i<n*2;i++){\n\t\tscanf(\"%lld\",&a[i]);\n\t\tans+=a[i];\n\t}\n\tfor(int i=0;i<n*2;i++){\n\t\tscanf(\"%lld\",&b[i]);\n\t}\n\tfor(int i=0;i<n*2;i++){\n\t\tvec.push_back(b[i]-a[i]);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tscanf(\"%d%lld%lld\",&p[i],&x[i],&y[i]);\n\t\tp[i]--;\n\t\tvec.push_back(y[i]-x[i]);\n\t}\n\tsort(vec.begin(),vec.end());\n\tvec.erase(unique(vec.begin(),vec.end()),vec.end());\n\tfor(int i=1;i<n*2-1;i++){\n\t\tint lv=lower_bound(vec.begin(),vec.end(),b[i]-a[i])-vec.begin();\n\t\tseg.update(0,lv,1);\n\t\tseg.update(1,lv,b[i]-a[i]);\n\t}\n\tfor(int i=0;i<q;i++){\n\t\tint lv=lower_bound(vec.begin(),vec.end(),b[p[i]]-a[p[i]])-vec.begin();\n\t\tif(p[i]!=0 && p[i]!=n*2-1)seg.update(0,lv,-1);\n\t\tif(p[i]!=0 && p[i]!=n*2-1)seg.update(1,lv,a[p[i]]-b[p[i]]);\n\t\tb[p[i]]=y[i];\n\t\tans-=a[p[i]];\n\t\ta[p[i]]=x[i];\n\t\tans+=a[p[i]];\n\t\tlv=lower_bound(vec.begin(),vec.end(),b[p[i]]-a[p[i]])-vec.begin();\n\t\tif(p[i]!=0 && p[i]!=n*2-1)seg.update(0,lv,1);\n\t\tif(p[i]!=0 && p[i]!=n*2-1)seg.update(1,lv,b[p[i]]-a[p[i]]);\n\t\tprintf(\"%lld\\n\",ans+seg.find());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sp ' '\n#define mkp make_pair\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define lP pair<ll,ll>\n#define iP pair<int,int>\ntypedef long long ll;\nusing namespace std;\nconst int mod = 1000000007, mod998 = 998244353;\nconst string nyan(\"(=^・ω・^=)\");\n\nint N, Q, a[200000], b[200000], p, x, y;\nbool u[200000];\nset<pair<int, int>>st[2];\nll res;\n\nint main() {\n\tcin >> N >> Q;\n\t--Q;\n\tN *= 2;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> a[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> b[i];\n\t}\n\tcin >> p >> x >> y;\n\t--p;\n\ta[p] = x;\n\tb[p] = y;\n\tres = a[0] + a[N - 1];\n\tfor (int i = 1; i < N - 1; ++i) {\n\t\tif (a[i] >= b[i]) {\n\t\t\tu[i] = true;\n\t\t\tres += a[i];\n\t\t\tst[1].insert(mkp(a[i] - b[i], i));\n\t\t}\n\t\telse {\n\t\t\tres += b[i];\n\t\t\tst[0].insert(mkp(b[i] - a[i], i));\n\t\t}\n\t}\n\tif (st[0].size() & 1) {\n\t\tpair<int, int>p1, p2;\n\t\tp1 = *st[0].begin();\n\t\tp2 = *st[1].begin();\n\t\tif (p1.first > p2.first) {\n\t\t\tres -= p2.first;\n\t\t\tu[p2.second] ^= true;\n\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\tst[1].erase(p2);\n\t\t}\n\t\telse {\n\t\t\tres -= p1.first;\n\t\t\tu[p1.second] ^= true;\n\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\tst[0].erase(p1);\n\t\t}\n\t}\n\tcout << res << endl;\n\twhile (Q--) {\n\t\tcin >> p >> x >> y;\n\t\t--p;\n\t\tif (p == 0 || p == N - 1) {\n\t\t\tres += x - a[p];\n\t\t\ta[p] = x;\n\t\t}\n\t\telse {\n\t\t\tif (u[p]) {\n\t\t\t\tres += x - a[p];\n\t\t\t\tst[1].erase(mkp(a[p] - b[p], p));\n\t\t\t\tst[1].insert(mkp(x - y, p));\n\t\t\t\tauto it = st[1].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0 || (!st[0].empty() && p1.first + p2.first < 0 && p2.first < st[0].begin()->first) || (st[0].empty() && it->first + it2->first < 0)) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[0].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[1].erase(p1);\n\t\t\t\t\tst[1].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tres += y - b[p];\n\t\t\t\tst[0].erase(mkp(b[p] - a[p], p));\n\t\t\t\tst[0].insert(mkp(y - x, p));\n\t\t\t\tauto it = st[0].begin();\n\t\t\t\tauto it2 = it;\n\t\t\t\t++it2;\n\t\t\t\tpair<int, int> p1 = *it;\n\t\t\t\tpair<int, int> p2 = *it2;\n\t\t\t\tif (p1.first < 0 && p2.first < 0 || (!st[1].empty() && p1.first + p2.first < 0 && p2.first < st[1].begin()->first) || (st[1].empty() && p1.first + p2.first < 0)) {\n\t\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\t\tst[1].insert(mkp(-p2.first, p2.second));\n\t\t\t\t\tu[p1.second] ^= true;\n\t\t\t\t\tu[p2.second] ^= true;\n\t\t\t\t\tst[0].erase(p1);\n\t\t\t\t\tst[0].erase(p2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!st[0].empty() && !st[1].empty() && st[0].begin()->first + st[1].begin()->first < 0) {\n\t\t\t\tpair<int, int> p1 = *st[0].begin();\n\t\t\t\tpair<int, int> p2 = *st[1].begin();\n\t\t\t\tres -= p1.first + p2.first;\n\t\t\t\tu[p1.second] ^= true;\n\t\t\t\tu[p2.second] ^= true;\n\t\t\t\tst[0].insert(mkp(-p2.first, p2.second));\n\t\t\t\tst[1].insert(mkp(-p1.first, p1.second));\n\t\t\t\tst[0].erase(p1);\n\t\t\t\tst[1].erase(p2);\n\t\t\t}\n\t\t\ta[p] = x;\n\t\t\tb[p] = y;\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>  \n#include <iostream>  \n#include <sstream>  \n#include <string>  \n#include <cstring>\n#include <vector>  \n#include <queue>  \n#include <set>  \n#include <map>  \n#include <cstdio>  \n#include <cstdlib>  \n#include <cctype>  \n#include <cmath>  \n#include <list>  \n#include <cassert>\n#include <ctime>\n#include <climits>\nusing namespace std;  \n\n#define PB push_back  \n#define MP make_pair  \n#define SZ(v) ((int)(v).size())  \n#define FOR(i,a,b) for(int i=(a);i<(b);++i)  \n#define REP(i,n) FOR(i,0,n)  \n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)  \n#define REPE(i,n) FORE(i,0,n)  \n#define FORSZ(i,a,v) FOR(i,a,SZ(v))  \n#define REPSZ(i,v) REP(i,SZ(v))  \ntypedef long long ll;\ntypedef unsigned long long ull;\nll gcd(ll a,ll b) { return b==0?a:gcd(b,a%b); }\n\nconst int MAXN = 100000;\n\nint n, nq;\nint a[MAXN], b[MAXN];\n\nll now;\nbool same[2 * MAXN];\nset<pair<int,int> > same2diff;\nset<pair<int,int> > diff2same;\n\nvoid change(set<pair<int, int> > &s, int idx, int oval, int nval) {\n\ts.erase(MP(oval, idx)); s.insert(MP(nval, idx));\n}\n\nvoid update() {\n\twhile (SZ(same2diff) >= 2) {\n\t\tauto a = same2diff.end(); --a; auto b = a; --b;\n\t\tif (a->first + b->first <= 0) break;\n\t\tnow += a->first + b->first;\n\t\tsame[a->second] = same[b->second] = false;\n\t\tdiff2same.insert(MP(-a->first, a->second));\n\t\tdiff2same.insert(MP(-b->first, b->second));\n\t\tsame2diff.erase(a);\n\t\tsame2diff.erase(b);\n\t}\n\twhile (SZ(diff2same) >= 2) {\n\t\tauto a = diff2same.end(); --a; auto b = a; --b;\n\t\tif (a->first + b->first <= 0) break;\n\t\tnow += a->first + b->first;\n\t\tsame[a->second] = same[b->second] = true;\n\t\tsame2diff.insert(MP(-a->first, a->second));\n\t\tsame2diff.insert(MP(-b->first, b->second));\n\t\tdiff2same.erase(a);\n\t\tdiff2same.erase(b);\n\t}\n}\n\nvoid run() {\n\tscanf(\"%d%d\", &n, &nq); REP(i, 2 * n) scanf(\"%d\", &a[i]); REP(i, 2 * n) scanf(\"%d\", &b[i]);\n\tnow = 0; same2diff.clear(); diff2same.clear();\n\tREP(i, 2 * n) {\n\t\tnow += a[i]; same[i] = true;\n\t\tif (i != 0 && i != 2 * n - 1) same2diff.insert(MP(b[i] - a[i], i));\n\t}\n\tREP(qi, nq) {\n\t\tint idx, aval, bval; scanf(\"%d%d%d\", &idx, &aval, &bval); --idx;\n\t\tif (same[idx]) now += aval - a[idx];\n\t\telse now += bval - b[idx];\n\t\tif (idx != 0 && idx != 2 * n - 1) {\n\t\t\tif (same[idx]) change(same2diff, idx, b[idx] - a[idx], bval - aval);\n\t\t\telse change(diff2same, idx, a[idx] - b[idx], aval - bval);\n\t\t}\n\t\ta[idx] = aval, b[idx] = bval;\n\t\tupdate();\n\t\tprintf(\"%lld\\n\", now);\n\t}\n}\n\nint main() {\n\trun();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <functional>\nusing namespace std;\n\nlong long N, Q, a[200009], b[200009];\nlong long solve() {\n\tvector<int>Z; long long sum = 0;\n\tfor (int i = 1; i < 2 * N - 1; i++) {\n\t\tsum += a[i];\n\t\tZ.push_back(b[i] - a[i]);\n\t}\n\tsum += a[0] + a[2 * N - 1];\n\tsort(Z.begin(), Z.end(), greater<int>());\n\tlong long maxn = 0, S = 0;\n\tfor (int i = 0; i < Z.size(); i += 2) {\n\t\tS += Z[i] + Z[i + 1];\n\t\tmaxn = max(maxn, S);\n\t}\n\treturn sum + maxn;\n}\nint main() {\n\tcin >> N >> Q;\n\tfor (int i = 0; i < 2 * N; i++)cin >> a[i];\n\tfor (int i = 0; i < 2 * N; i++)cin >> b[i];\n\tfor (int i = 0; i < Q; i++) {\n\t\tint p1, p2, p3; cin >> p1 >> p2 >> p3; p1--;\n\t\ta[p1] = p2; b[p1] = p3;\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing P = pair<ll, int>;\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, q;\n    cin >> n >> q;\n    int m = 2 * n;\n    vector<ll> a(m), b(m);\n    for (int i = 0; i < m; i++) cin >> a[i];\n    for (int i = 0; i < m; i++) cin >> b[i];\n\n    vector<int> p(q);\n    vector<ll> x(q), y(q);\n    for (int i = 0; i < q; i++) {\n        cin >> p[i] >> x[i] >> y[i];\n        p[i]--;\n    }\n\n    ll base = 0;\n    ll sum = 0;\n    set<P> s;\n    for (int i = 0; i < m; i++) {\n        base += a[i];\n        if (i > 0 && i < m - 1 && a[i] <= b[i]) {\n            sum += b[i] - a[i];\n            s.emplace(b[i] - a[i], i);\n        }\n    }\n\n    for (int i = 0; i < q; i++) {\n        base += x[i] - a[p[i]];\n        if (p[i] == 0 || p[i] == m - 1) {\n            if (s.size() % 2 == 1) {\n                cout << base + sum - s.begin()->first << endl;\n            } else {\n                cout << base + sum << endl;\n            }\n        } else {\n            if (b[p[i]] >= a[p[i]]) {\n                s.erase(P(b[p[i]] - a[p[i]], p[i]));\n                sum -= b[p[i]] - a[p[i]];\n            }\n            if (y[i] >= x[i]) {\n                s.emplace(y[i] - x[i], p[i]);\n                sum += y[i] - x[i]; \n            }\n            if (s.size() % 2 == 1) {\n                cout << base + sum - s.begin()->first << endl;\n            } else {\n                cout << base + sum << endl;\n            }\n        }\n        a[p[i]] = x[i];\n        b[p[i]] = y[i];\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <stack>\n#include <set>\n#include <cassert>\nusing namespace std;\n\nint main() {\n        int n, q;\n        scanf(\"%d%d\", &n, &q);\n        assert(n <= 5 && q <= 10);\n        n = 2 * n;\n        vector<int> a(n), b(n);\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &a[i]);\n        for (int i = 0; i < n; i ++) scanf(\"%d\", &b[i]);\n        set<string> ok;\n        vector<int> s(n - 2);\n        for (int i = 0; i < n - 2; i ++) s[i] = i;\n        do {\n                string tmp = \"\";\n                for (int i = 0; i < n - 2; i ++) {\n                        if (s[i] & 1) tmp += \")\";\n                        else tmp += \"(\";\n                }\n                stack<char> st;\n                st.push('(');\n                for (int i = 0; i < n - 2; i ++) {\n                        if (!st.empty() && st.top() == '(' && tmp[i] == ')') st.pop();\n                        else st.push(tmp[i]);\n                }\n                if (st.top() == '(') st.pop();\n                if (st.empty()) ok.insert(\"(\" + tmp + \")\");\n        } while (next_permutation(s.begin(), s.end()));\n        vector<string> yes;\n        for (auto it : ok) yes.push_back(it);\n        while (q --) {\n                int p, x, y;\n                scanf(\"%d%d%d\", &p, &x, &y);\n                p --;\n                a[p] = x;\n                b[p] = y;\n                long long ans = - (1LL << 60);\n                for (int i = 0; i < yes.size(); i ++) {\n                        for (int j = i; j < yes.size(); j ++) {\n                                string fi = yes[i], se = yes[j];\n                                long long res = 0;\n                                for (int i = 0; i < n; i ++) {\n                                        if (fi[i] == se[i]) res += a[i];\n                                        else res += b[i];\n                                }\n                                ans = max(ans, res);\n                        }\n                }\n                printf(\"%lld\\n\", ans);\n        }\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<class ValueMonoid, template<class...> class Container=::std::vector>\nclass SegTree{\npublic:\n    using value_structure = ValueMonoid;\n    using value_type = typename value_structure::value_type;\n    using const_reference = const value_type &;\n    using container_type = Container<value_type>;\n    using size_type = typename container_type::size_type;\n\nprivate:\n    ::std::vector<value_type> tree;\n    size_type size_;\n\n    static size_type getsize(const size_type x){\n        size_type ret = 1;\n        while(ret < x)\n            ret <<= 1;\n        return ret;\n    }\n\n    inline value_type calc(const value_type a, const value_type b){\n        return value_structure::operation(a, b);\n    }\n\n    inline void calc_node(const size_type index){\n        if(tree.size() <= (index << 1 | 1)) return;\n        tree[index] = value_structure::operation(tree[index<<1], tree[index<<1 | 1]);\n    }\npublic:\n    SegTree() : size_(0), tree(){}\n    SegTree(const size_type size)\n            : size_(size), tree(size << 1, value_structure::identity()){}\n    template<class InputIterator>\n    SegTree(InputIterator first, InputIterator last)\n            : size_(::std::distance(first, last)){\n        tree = container_type(size_, value_structure::identity());\n        tree.insert(tree.end(), first, last);\n        for(size_type i = size_;i > 0;i--){\n            calc_node(i);\n        }\n    }\n\n    size_type size() const { return size_; }\n    const_reference operator[](const size_type k) const {\n        assert(k < size_);\n        return tree[k+size_];\n    }\n\n    value_type query(size_type l, size_type r){\n        assert(l <= r);\n        assert(0 <= l && l < size_);\n        assert(0 <= r && r <= size_);\n        value_type retl = value_structure::identity(), retr = value_structure::identity();\n        for(l += size_, r += size_; l < r ; l >>= 1, r >>= 1){\n            if(l&1) retl = calc(retl, tree[l++]);\n            if(r&1) retr = calc(tree[--r], retr);\n        }\n        return calc(retl, retr);\n    }\n\n    template<class F>\n    void update(size_type index, const F& f){\n        assert(0 <= index && index < size());\n        index += size_;\n        tree[index] = f(::std::move(tree[index]));\n        while(index >>= 1)\n            calc_node(index);\n    }\n\n    /*\n    template<class F>\n    size_type search(const F& f) const { // [0, result) is True and [0, result-1) is not.\n        if(f(value_structure::identity()))\n            return 0;\n        if(!f(tree[1]))\n            return size_+1;\n        value_type acc = value_structure::identity();\n        size_type i = 1;\n        while(i <\n    }\n    */\n};\n\nclass v_monoid {\npublic:\n    using value_type = PLL;\n    static value_type identity() { return PLL(-INF_LL, -INF_LL); }\n    static value_type initializer() { return {-INF_LL, -INF_LL}; }\n    static value_type operation(const value_type& a, const value_type& b) {\n        if (a == identity()) return b;\n        if (b == identity()) return a;\n        return {max(a.fs+b.fs, a.sc+b.sc), max(a.fs+b.sc, a.sc+b.fs)};\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree{\n    using F = function<T(T,T)>;\n    int n;\n    F f;\n    T ti;\n    vector<T> dat;\n    SegmentTree(){};\n    SegmentTree(F f,T ti):f(f),ti(ti){}\n    void init(int n_){\n        n=1;\n        while(n<n_) n<<=1;\n        dat.assign(n<<1,ti);\n    }\n    void build(const vector<T> &v){\n        int n_=v.size();\n        init(n_);\n        for(int i=0;i<n_;i++) dat[n+i]=v[i];\n        for(int i=n-1;i;i--)\n            dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n    }\n    void set_val(int k,T x){\n        dat[k+=n]=x;\n        while(k>>=1)\n            dat[k]=f(dat[(k<<1)|0],dat[(k<<1)|1]);\n    }\n    T query(int a,int b){\n        T vl=ti,vr=ti;\n        for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n            if(l&1) vl=f(vl,dat[l++]);\n            if(r&1) vr=f(dat[--r],vr);\n        }\n        return f(vl,vr);\n    }\n    template<typename C>\n    int find(int st,C &check,T &acc,int k,int l,int r){\n        if(l+1==r){\n            acc=f(acc,dat[k]);\n            return check(acc)?k-n:-1;\n        }\n        int m=(l+r)>>1;\n        if(m<=st) return find(st,check,acc,(k<<1)|1,m,r);\n        if(st<=l&&!check(f(acc,dat[k]))){\n            acc=f(acc,dat[k]);\n            return -1;\n        }\n        int vl=find(st,check,acc,(k<<1)|0,l,m);\n        if(~vl) return vl;\n        return find(st,check,acc,(k<<1)|1,m,r);\n    }\n    template<typename C>\n    int find(int st,C &check){\n        T acc=ti;\n        return find(st,check,acc,1,0,n);\n    }\n};\n\n\nint main(void) {\n    int64 N, Q;\n    cin >> N >> Q;\n    N *= 2;\n    vector<int64> a(N), b(N);\n    REP(i, N) cin >> a[i];\n    REP(i, N) cin >> b[i];\n    int64 res = a[0] + a.back();\n    SegTree<v_monoid> sg(N);\n    FOR(i, 1, N-1) {\n        sg.update(i, [&](const PLL x) { return PLL(a[i], b[i]); });\n    }\n    REP(i, Q) {\n        int64 p, x, y;\n        cin >> p >> x >> y; p--;\n        if (p == 0 || p == N-1) {\n            res -= a[p]; res += x;\n            a[p] = x;\n        } else {\n            sg.update(p, [&](const PLL alskdj) { return PLL(x, y); });\n        }\n        cout << res + (N > 1 ? sg.query(1, N).fs : 0)<< endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\nconst int limit = 200010;\nll a[limit], b[limit];\nconst ll inf = 1LL << 60;\n\n\nmultiset<ll> positive, negative;\nll a_total = 0LL, p_total = 0LL;\n\nint n, q;\n\ninline void add(int i) {\n\ta_total += a[i];\n\tif (i == 0 or i == 2 * n - 1) return;\n\tconst ll val = b[i] - a[i];\n\tif (val >= 0) {\n\t\tpositive.insert(val);\n\t\tp_total += val;\n\t} else {\n\t\tnegative.insert(val);\n\t}\n}\n\ninline void del(int i) {\n\ta_total -= a[i];\n\tif (i == 0 or i == 2 * n - 1) return;\n\tconst ll val = b[i] - a[i];\n\tif (val >= 0) {\n\t\tauto it = positive.find(val);\n\t\tpositive.erase(it);\n\t\tp_total -= val;\n\t} else {\n\t\tauto it = negative.find(val);\n\t\tnegative.erase(it);\n\t}\n}\n\nint main(void) {\n\tcin >> n >> q;\n\n\trep(i, 2 * n) cin >> a[i];\n\trep(i, 2 * n) cin >> b[i];\n\n\trep(i, 2 * n) a_total += a[i];\n\n\trep(i, 1, 2 * n - 1) {\n\t\tconst ll val = b[i] - a[i];\n\t\tif (val >= 0) {\n\t\t\tpositive.insert(val);\n\t\t\tp_total += val;\n\t\t} else {\n\t\t\tnegative.insert(val);\n\t\t}\n\t}\n\n\n\trep(loop, q) {\n\t\tint p;\n\t\tll x, y;\n\t\tcin >> p >> x >> y;\n\n\t\tdel(p - 1);\n\t\ta[p - 1] = x, b[p - 1] = y;\n\t\tadd(p - 1);\n\n\t\tll ans = -inf;\n\t\tif (positive.size() % 2 == 0) {\n\t\t\tchmax(ans, a_total + p_total);\n\t\t} else {\n\t\t\tconst ll mmax = *prev(end(negative));\n\t\t\tconst ll pmin = *begin(positive);\n\t\t\tchmax(ans, a_total + p_total + mmax);\n\t\t\tchmax(ans, a_total + p_total - pmin);\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,Q;\nint A[201010];\nint B[201010];\nmultiset<int> p,n;\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>Q;\n\tll S=0,T=0;\n\tFOR(i,2*N) cin>>A[i], S+=A[i];\n\tFOR(i,2*N) {\n\t\tcin>>B[i];\n\t\tB[i]-=A[i];\n\t\tif(i!=0 && i!=2*N-1) {\n\t\t\tif(B[i]>0) {\n\t\t\t\tp.insert(B[i]);\n\t\t\t\tT+=B[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tn.insert(-B[i]);\n\t\t\t}\n\t\t}\n\t}\n\twhile(Q--) {\n\t\tcin>>i>>x>>y;\n\t\ti--;\n\t\tS-=A[i];\n\t\tif(B[i]>0) {\n\t\t\tp.erase(p.find(B[i]));\n\t\t\tT-=B[i];\n\t\t}\n\t\telse {\n\t\t\tn.erase(n.find(-B[i]));\n\t\t}\n\t\t\n\t\tA[i]=x;\n\t\tS+=x;\n\t\tB[i]=y-A[i];\n\t\tif(i!=0 && i!=2*N-1) {\n\t\t\tif(B[i]>0) {\n\t\t\t\tp.insert(B[i]);\n\t\t\t\tT+=B[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tn.insert(-B[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tll ma=0;\n\t\tif(p.size()%2==0) ma=S+T;\n\t\telse ma=S+max(T-*p.begin(),T-*n.begin());\n\t\tcout<<ma<<endl;\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define xx first\n#define yy second\n#define mp make_pair\n#define pb push_back\n#define mset(x, y) memset(x, y, sizeof x)\n#define mcpy(x, y) memcpy(x, y, sizeof x)\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair <int, int> pii;\n\ninline int Read()\n{\n\tint x = 0, f = 1, c = getchar();\n\tfor (; !isdigit(c); c = getchar())\n\t\tif (c == '-')\n\t\t\tf = -1;\n\tfor (;  isdigit(c); c = getchar())\n\t\tx = x * 10 + c - '0';\n\treturn x * f;\n}\n\nconst int MAXN = 200005;\n\nLL val_a[MAXN << 2], val_b[MAXN << 2];\nint n, m, a[MAXN], b[MAXN];\n\ninline void Build(int x, int l, int r)\n{\n\tif (l == r)\n\t\treturn (void)(val_a[x] = a[l], val_b[x] = b[l]);\n\tint mid = l + r >> 1;\n\tBuild(x << 1, l, mid), Build(x << 1 | 1, mid + 1, r);\n\tval_a[x] = max(val_a[x << 1] + val_a[x << 1 | 1], val_b[x << 1] + val_b[x << 1 | 1]);\n\tval_b[x] = max(val_b[x << 1] + val_a[x << 1 | 1], val_a[x << 1] + val_b[x << 1 | 1]);\n}\n\ninline void Modify(int x, int l, int r, int p)\n{\n\tif (l == r)\n\t\treturn (void)(val_a[x] = a[l], val_b[x] = b[l]);\n\tint mid = l + r >> 1;\n\tif (p <= mid)\n\t\tModify(x << 1, l, mid, p);\n\telse\n\t\tModify(x << 1 | 1, mid + 1, r, p);\n\tval_a[x] = max(val_a[x << 1] + val_a[x << 1 | 1], val_b[x << 1] + val_b[x << 1 | 1]);\n\tval_b[x] = max(val_b[x << 1] + val_a[x << 1 | 1], val_a[x << 1] + val_b[x << 1 | 1]);\n}\n\nint main()\n{\n#ifdef wxh010910\n\tfreopen(\"data.in\", \"r\", stdin);\n#endif\n\tn = Read(), m = Read();\n\tfor (int i = 1; i <= n << 1; i ++)\n\t\ta[i] = Read();\n\tfor (int i = 1; i <= n << 1; i ++)\n\t\tb[i] = Read();\n\tif (n == 1)\n\t{\n\t\twhile (m --)\n\t\t{\n\t\t\tint p = Read(), x = Read(), y = Read();\n\t\t\ta[p] = x, b[p] = y;\n\t\t\tprintf(\"%d\\n\", a[1] + a[n << 1]);\n\t\t}\n\t\treturn 0;\n\t}\n\tBuild(1, 2, (n << 1) - 1);\n\twhile (m --)\n\t{\n\t\tint p = Read(), x = Read(), y = Read();\n\t\ta[p] = x, b[p] = y;\n\t\tif (p > 1 && p < n << 1)\n\t\t\tModify(1, 2, (n << 1) - 1, p);\n\t\tprintf(\"%lld\\n\", a[1] + a[n << 1] + val_a[1]);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007\n#define MOD 998244353\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\npair<long long, long long> datas[500000];\nint erased[500000];\nint itr[500000];\nint main() {\n\tiostream::sync_with_stdio(false);\n#define int long long\n\tint n, query;\n\tcin >> n >> query;\n\tREP(i, 2 * n) {\n\t\tcin >> datas[i].first;\n\t}\n\tREP(i, 2 * n) {\n\t\tcin >> datas[i].second;\n\t}\n\tREP(i, 2 * n) {\n\t\titr[i] = i;\n\t}\n\tint aa, bb, cc;\n\tcin >> aa >> bb >> cc;\n\tdatas[aa - 1] = make_pair(bb, cc);\n\tpriority_queue<pair<long long,long long>> next_loser;\n\tpriority_queue<pair<long long, long long>,vector<pair<long long,long long>>,greater<pair<long long,long long>>> next_winner;\n\tlong long now_ans = 0;\n\tnow_ans += datas[0].first;\n\tnow_ans += datas[2 * n - 1].first;\n\tlong long now_cnt = 0;\n\tfor (int i = 1; i < 2 * n - 1; ++i) {\n\t\tnow_ans += datas[i].second;\n\t\tlong long geko = datas[i].first - datas[i].second;\n\t\tif (geko >= 0) {\n\t\t\tnow_cnt++;\n\t\t\tnext_winner.push(make_pair(geko, i));\n\t\t\tnow_ans += geko;\n\t\t}\n\t\telse {\n\t\t\tnext_loser.push(make_pair(geko, i));\n\t\t}\n\t}\n\tif (now_cnt % 2 == 0) {\n\t\tcout << now_ans << endl;\n\t}\n\telse {\n\t\tassert(0 == 1);\n\t\tlong long geko = now_ans - next_winner.top().first;\n\t\tif (next_loser.empty() == false) {\n\t\t\tgeko = max(geko, now_ans + next_loser.top().first);\n\t\t}\n\t\tcout << geko << endl;\n\t}\n\treturn 0;\n\tint next_move = 2 * n;\n\tREP(i, query) {\n\t\tint a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;\n\t\tif (a == 0 || a == 2 * n - 1) {\n\t\t\tnow_ans -= datas[a].first;\n\t\t\tnow_ans += b;\n\t\t\tdatas[a] = make_pair(b, c);\n\t\t\tcontinue;\n\t\t}\n\t\t//First We need To remove\n\t\tint data_itr = itr[a];\n\t\terased[data_itr] = 1;\n\t\tnow_ans -= datas[data_itr].second;\n\t\tint diff = datas[data_itr].first - datas[data_itr].second;\n\t\tif (diff >= 0) {\n\t\t\tnow_cnt--;\n\t\t\tnow_ans -= diff;\n\t\t}\n\t\telse {\n\t\t\t//nothing\n\t\t}\n\t\twhile (next_winner.empty() == false && erased[next_winner.top().second] == true) {\n\t\t\tnext_winner.pop();\n\t\t}\n\t\twhile (next_loser.empty() == false && erased[next_loser.top().second] == true) {\n\t\t\tnext_loser.pop();\n\t\t}\n\t\tdata_itr = next_move;\n\t\tnext_move++;\n\t\titr[a] = data_itr;\n\t\tdatas[data_itr] = make_pair(b, c);\n\t\tnow_ans += datas[data_itr].second;\n\t\tdiff = datas[data_itr].first - datas[data_itr].second;\n\t\tif (diff >= 0) {\n\t\t\tnow_cnt++;\n\t\t\tnow_ans += diff;\n\t\t\tnext_winner.push(make_pair(diff, data_itr));\n\t\t}\n\t\telse {\n\t\t\t//nothing\n\t\t\tnext_loser.push(make_pair(diff, data_itr));\n\t\t}\n\t\t//OK!\n\t\tif (now_cnt % 2 == 0) {\n\t\t\tcout << now_ans << endl;\n\t\t}\n\t\telse {\n\t\t\tassert(0 == 1);\n\t\t\tlong long geko = now_ans - next_winner.top().first;\n\t\t\tif (next_loser.empty() == false) {\n\t\t\t\tgeko = max(geko, now_ans + next_loser.top().first);\n\t\t\t}\n\t\t\tcout << geko << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<class ValueMonoid, template<class...> class Container=::std::vector>\nclass SegTree{\npublic:\n    using value_structure = ValueMonoid;\n    using value_type = typename value_structure::value_type;\n    using const_reference = const value_type &;\n    using container_type = Container<value_type>;\n    using size_type = typename container_type::size_type;\n\nprivate:\n    ::std::vector<value_type> tree;\n    size_type size_;\n\n    static size_type getsize(const size_type x){\n        size_type ret = 1;\n        while(ret < x)\n            ret <<= 1;\n        return ret;\n    }\n\n    inline value_type calc(const value_type a, const value_type b){\n        return value_structure::operation(a, b);\n    }\n\n    inline void calc_node(const size_type index){\n        if(tree.size() <= (index << 1 | 1)) return;\n        tree[index] = value_structure::operation(tree[index<<1], tree[index<<1 | 1]);\n    }\npublic:\n    SegTree() : size_(0), tree(){}\n    SegTree(const size_type size)\n            : size_(size), tree(size << 1, value_structure::identity()){}\n    template<class InputIterator>\n    SegTree(InputIterator first, InputIterator last)\n            : size_(::std::distance(first, last)){\n        tree = container_type(size_, value_structure::identity());\n        tree.insert(tree.end(), first, last);\n        for(size_type i = size_;i > 0;i--){\n            calc_node(i);\n        }\n    }\n\n    size_type size() const { return size_; }\n    const_reference operator[](const size_type k) const {\n        assert(k < size_);\n        return tree[k+size_];\n    }\n\n    value_type query(size_type l, size_type r){\n        assert(l <= r);\n        assert(0 <= l && l < size_);\n        assert(0 <= r && r <= size_);\n        value_type retl = value_structure::identity(), retr = value_structure::identity();\n        for(l += size_, r += size_; l < r ; l >>= 1, r >>= 1){\n            if(l&1) retl = calc(retl, tree[l++]);\n            if(r&1) retr = calc(tree[--r], retr);\n        }\n        return calc(retl, retr);\n    }\n\n    template<class F>\n    void update(size_type index, const F& f){\n        assert(0 <= index && index < size());\n        index += size_;\n        tree[index] = f(::std::move(tree[index]));\n        while(index >>= 1)\n            calc_node(index);\n    }\n\n    /*\n    template<class F>\n    size_type search(const F& f) const { // [0, result) is True and [0, result-1) is not.\n        if(f(value_structure::identity()))\n            return 0;\n        if(!f(tree[1]))\n            return size_+1;\n        value_type acc = value_structure::identity();\n        size_type i = 1;\n        while(i <\n    }\n    */\n};\n\nclass v_monoid {\npublic:\n    using value_type = PLL;\n    static value_type identity() { return PLL(-INF_LL, -INF_LL); }\n    static value_type initializer() { return {-INF_LL, -INF_LL}; }\n    static value_type operation(const value_type& a, const value_type& b) {\n        if (a == identity()) return b;\n        if (b == identity()) return a;\n        return {max(a.fs+b.fs, a.sc+b.sc), max(a.fs+b.sc, a.sc+b.fs)};\n    }\n};\n\nint main(void) {\n    int64 N, Q;\n    cin >> N >> Q;\n    N *= 2;\n    vector<int64> a(N), b(N);\n    REP(i, N) cin >> a[i];\n    REP(i, N) cin >> b[i];\n    multiset<int64> as, bs;\n    int64 res = a[0] + a.back();\n    SegTree<v_monoid> sg(N);\n    FOR(i, 1, N-1) {\n        sg.update(i, [&](const PLL x) { return PLL(a[i], b[i]); });\n    }\n    REP(i, Q) {\n        int64 p, x, y;\n        cin >> p >> x >> y; p--;\n        if (p == 0 || p == N-1) {\n            res -= a[p]; res += x;\n            a[p] = x;\n        } else {\n            sg.update(p, [&](const PLL alskdj) { return PLL(x, y); });\n        }\n        cout << res + sg.query(1, N-1).fs << endl;\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define AVL_keytype int\n#define AVL_valtype int\n\n\n//static int malloc_cont;\n//static int free_cont;\n\ntypedef struct AVL_node_sub{\n\tAVL_keytype key; //添え字\n\tAVL_valtype val; //値\n\tint ele_num; //木に含まれる要素数\n\tint height; //木の高さ\n\tstruct AVL_node_sub *left; //左の子へのポインタ\n\tstruct AVL_node_sub *right; //右の子へのポインタ\n}AVL_node;\n\ntypedef struct {\n\tAVL_node *root;\n}AVL_tree;\n\nint max(int a, int b){\n\treturn a >= b ? a : b;\n}\n\n//比較関数\n//a < b なら負の値\n//a = b なら0\n//a > b なら正の値\nint compare_AVL(AVL_keytype a, AVL_keytype b){\n\treturn a - b;\n}\n\nint ele_num(AVL_node *r){\n\tif(r == NULL){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn r->ele_num;\n\t}\n}\n\nint height(AVL_node *r){\n\tif(r == NULL){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn r->height;\n\t}\n}\n\n//tの指すノードを開放する\n//AVL_valtypeなどがポインタ型の時はそれもfreeする\nvoid release_AVL_node(AVL_node *r){\n\tfree(r);\n//\tfree_cont++;\n}\n\nAVL_node *build_AVL_node(AVL_keytype key, AVL_valtype val, AVL_node *left, AVL_node *right){\n\tAVL_node *newr;\n\tint left_h = height(left);\n\tint right_h = height(right);\n\tif(left_h > right_h + 1){\n\t\tAVL_node *ll = left->left;\n\t\tAVL_node *lr = left->right;\n\t\tif(height(ll) < height(lr)){\n\t\t\tnewr = build_AVL_node(lr->key, lr->val, build_AVL_node(left->key, left->val, ll, lr->left), build_AVL_node(key, val, lr->right, right));\n\t\t\trelease_AVL_node(lr);\n\t\t}\n\t\telse{\n\t\t\tnewr = build_AVL_node(left->key, left->val, ll, build_AVL_node(key, val, lr, right));\n\t\t}\n\t\trelease_AVL_node(left);\n\t}\n\telse if(right_h > left_h + 1){\n\t\tAVL_node *rr = right->right;\n\t\tAVL_node *rl = right->left;\n\t\tif(height(rr) < height(rl)){\n\t\t\tnewr = build_AVL_node(rl->key, rl->val, build_AVL_node(key, val, left, rl->left), build_AVL_node(right->key, right->val, rl->right, rr));\n\t\t\trelease_AVL_node(rl);\n\t\t}\n\t\telse{\n\t\t\tnewr = build_AVL_node(right->key, right->val, build_AVL_node(key, val, left, rl), rr);\n\t\t}\n\t\trelease_AVL_node(right);\n\t}\n\telse{\n//\t\tmalloc_cont++;\n\t\tnewr = (AVL_node *)malloc(sizeof(AVL_node));\n\t\tnewr->key = key;\n\t\tnewr->val = val;\n\t\tnewr->ele_num = ele_num(left) + ele_num(right) + 1;\n\t\tnewr->height = max(left_h, right_h) + 1;\n\t\tnewr->left = left;\n\t\tnewr->right = right;\n\t}\n\treturn newr;\n}\n\nAVL_node *find_AVL_sub(AVL_keytype key, AVL_node *r){\n\tif(r == NULL){\n\t\treturn NULL;\n\t}\n\tint comp = compare_AVL(key, r->key);\n\tif(comp == 0){\n\t\treturn r;\n\t}\n\telse if(comp < 0){\n\t\treturn find_AVL_sub(key, r->left);\n\t}\n\telse{\n\t\treturn find_AVL_sub(key, r->right);\n\t}\n}\n\nAVL_node *kth_smallest_AVL_sub(int k, AVL_node *r){\n\tif(r == NULL || k < 1){\n\t\tprintf(\"In function 'kth_smallest_AVL_sub':\\nargument 'k' is out of range\\n\");\n\t\treturn NULL;\n\t}\n\telse if(r->ele_num < k){\n\t\tprintf(\"In function 'kth_smallest_AVL_sub':\\nargument 'k' is out of range\\n\");\n\t\treturn NULL;\n\t}\n\telse if(ele_num(r->left) == k - 1){\n\t\treturn r;\n\t}\n\telse if(ele_num(r->left) > k - 1){\n\t\treturn kth_smallest_AVL_sub(k, r->left);\n\t}\n\telse{\n\t\treturn kth_smallest_AVL_sub(k - ele_num(r->left) - 1, r->right);\n\t}\n}\n\nint num_less_than_AVL_sub(AVL_keytype key, AVL_node *r){\n\tif(r == NULL){\n\t\treturn 0;\n\t}\n\telse if(compare_AVL(key, r->key) < 0){\n\t\treturn num_less_than_AVL_sub(key, r->left);\n\t}\n\telse{\n\t\treturn ele_num(r->left) + num_less_than_AVL_sub(key, r->right) + 1;\n\t}\n}\n\nAVL_node *next_largest_AVL_sub(AVL_keytype key, AVL_node *r){\n\tif(r == NULL){\n\t\treturn NULL;\n\t}\n\telse if(compare_AVL(key, r->key) <= 0){\n\t\treturn next_largest_AVL_sub(key, r->left);\n\t}\n\telse{\n\t\tAVL_node *candidate = next_largest_AVL_sub(key, r->right);\n\t\tif(candidate == NULL){\n\t\t\treturn r;\n\t\t}\n\t\telse{\n\t\t\treturn candidate;\n\t\t}\n\t}\n}\n\nAVL_node *next_smallest_AVL_sub(AVL_keytype key, AVL_node *r){\n\tif(r == NULL){\n\t\treturn NULL;\n\t}\n\telse if(compare_AVL(key, r->key) >= 0){\n\t\treturn next_smallest_AVL_sub(key, r->right);\n\t}\n\telse{\n\t\tAVL_node *candidate = next_smallest_AVL_sub(key, r->left);\n\t\tif(candidate == NULL){\n\t\t\treturn r;\n\t\t}\n\t\telse{\n\t\t\treturn candidate;\n\t\t}\n\t}\n}\n\nAVL_node *insert_AVL_sub(AVL_keytype key, AVL_valtype val, AVL_node *r){\n\tAVL_node *newr;\n\tif(r == NULL){\n\t\tnewr = build_AVL_node(key, val, NULL, NULL);\n\t}\n\telse{\n\t\tint comp = compare_AVL(key, r->key);\n\t\t/*if(comp == 0){\n\t\t\tprintf(\"In function 'insert_AVL_sub':\\nkey '%d' already exists\\n\", key);\n\t\t\tnewr = build_AVL_node(r->key, val, r->left, r->right);\n\t\t}\n\t\telse*/ if(comp < 0){\n\t\t\tnewr = build_AVL_node(r->key, r->val, insert_AVL_sub(key, val, r->left), r->right);\n\t\t}\n\t\telse{\n\t\t\tnewr = build_AVL_node(r->key, r->val, r->left, insert_AVL_sub(key, val, r->right));\n\t\t}\n\t\trelease_AVL_node(r);\n\t}\n\treturn newr;\n}\n\nAVL_node *erase_AVL_sub_sub(AVL_node *r){\n\tif(r->left == NULL){\n\t\treturn r->right;\n\t}\n\telse{\n\t\treturn build_AVL_node(r->key, r->val, erase_AVL_sub_sub(r->left), r->right);\n\t}\n}\n\nAVL_node *erase_AVL_sub(AVL_keytype key, AVL_node *r, AVL_node **ans){\n\tAVL_node *newr;\n\tif(r == NULL){\n\t\tnewr = NULL;\n\t}\n\telse{\n\t\tint comp = compare_AVL(key, r->key);\n\t\tif(comp == 0){\n\t\t\t*ans = r;\n\t\t\tif(r->left == NULL && r->right == NULL){\n\t\t\t\tnewr = NULL;\n\t\t\t}\n\t\t\telse if(r->right == NULL){\n\t\t\t\tnewr = r->left;\n\t\t\t}\n\t\t\telse if(r->left == NULL){\n\t\t\t\tnewr = r->right;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tAVL_node *next_larger = kth_smallest_AVL_sub(1, r->right);\n\t\t\t\tnewr = build_AVL_node(next_larger->key, next_larger->val, r->left, erase_AVL_sub_sub(r->right));\n\t\t\t\trelease_AVL_node(next_larger);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(comp < 0){\n\t\t\t\tnewr = build_AVL_node(r->key, r->val, erase_AVL_sub(key, r->left, ans), r->right);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnewr = build_AVL_node(r->key, r->val, r->left, erase_AVL_sub(key, r->right, ans));\n\t\t\t}\n\t\t\trelease_AVL_node(r);\n\t\t}\n\t}\n\treturn newr;\n}\n\nvoid storeall_AVL_sub(AVL_keytype *array, int k, AVL_node *r){\n\tif(r != NULL){\n\t\tstoreall_AVL_sub(array, k, r->left);\n\t\tarray[k + ele_num(r->left)] = r->key;\n\t\tstoreall_AVL_sub(array, k + ele_num(r->left) + 1, r->right);\n\t}\n}\n\nvoid outall_AVL_sub(AVL_node *r){\n\tif(r != NULL){\n\t\toutall_AVL_sub(r->left);\n\t\tprintf(\"(key, val, ele_num, height) = (%d, %d, %d, %d)\\n\", r->key, r->val, r->ele_num, r->height);\n\t\toutall_AVL_sub(r->right);\n\t}\n}\n\n//AVL_treeを生成する\nAVL_tree *make_AVL_tree(){\n\tAVL_tree *t = (AVL_tree *)malloc(sizeof(AVL_tree));\n\tt->root = NULL;\n\treturn t;\n}\n\n//tに含まれるノードの数を返す\nint element_num_AVL(AVL_tree *t){\n\treturn ele_num(t->root);\n}\n\n//添え字がkeyのノードへのポインタを返す\n//なければNULLを返す\nAVL_node *find_AVL(AVL_keytype key, AVL_tree *t){\n\treturn find_AVL_sub(key, t->root);\n}\n\n//小さい順にk番目のkeyのノードへのポインタを返す\n//1 ≦ k ≦ ele_num(t->root) を満たさない場合はNULLを返す(メッセージが出る)\nAVL_node *kth_smallest_AVL(int k, AVL_tree *t){\n\treturn kth_smallest_AVL_sub(k, t->root);\n}\n\n//添え字がkey以下のノードの数を返す\nint num_less_than_AVL(AVL_keytype key, AVL_tree *t){\n\treturn num_less_than_AVL_sub(key, t->root);\n}\n\n//keyよりも小さい中で最大の添え字のノードへのポインタを返す\n//なければNULLを返す\nAVL_node *next_largest_AVL(AVL_keytype key, AVL_tree *t){\n\treturn next_largest_AVL_sub(key, t->root);\n}\n\n//keyよりも大きい中で最小の添え字のノードへのポインタを返す\n//なければNULLを返す\nAVL_node *next_smallest_AVL(AVL_keytype key, AVL_tree *t){\n\treturn next_smallest_AVL_sub(key, t->root);\n}\n\n//添え字key, 値valのノードを挿入する\n//既に存在する場合は値が上書きされる(メッセージが出る)\nvoid insert_AVL(AVL_keytype key, AVL_valtype val, AVL_tree *t){\n\tt->root = insert_AVL_sub(key, val, t->root);\n}\n\n//添え字keyのノードを削除しそれを返す\n//存在しない場合はNULLを返す\nAVL_node *erase_AVL(AVL_keytype key, AVL_tree *t){\n\tAVL_node *ans = NULL;\n\tt->root = erase_AVL_sub(key, t->root, &ans);\n\treturn ans;\n}\n\n//全ノードのkeyを小さい順に格納した配列を返す\nAVL_keytype *storeall_AVL(AVL_tree *t){\n\tAVL_keytype *array = (AVL_keytype *)malloc(sizeof(AVL_keytype) * element_num_AVL(t));\n\tstoreall_AVL_sub(array, 0, t->root);\n\treturn array;\n}\n\n//全ノードの中身をkeyの小さい順に出力する\nvoid outall_AVL(AVL_tree *t){\n\toutall_AVL_sub(t->root);\n}\n\nsigned main(){\n\tint N, Q, i;\n\tscanf(\"%lld%lld\", &N, &Q);\n\tint *a = (int *)malloc(sizeof(int) * (2 * N));\n\tint *b = (int *)malloc(sizeof(int) * (2 * N));\n\tint *b_sub_a = (int *)malloc(sizeof(int) * (2 * N));\n\tfor(i = 0; i < 2 * N; i++){\n\t\tscanf(\"%lld\", &a[i]);\n\t}\n\tfor(i = 0; i < 2 * N; i++){\n\t\tscanf(\"%lld\", &b[i]);\n\t}\n\tint suma = 0, sum_p = 0,sum_m = 0, num_p = 0;\n\tfor(i = 0; i < 2 * N; i++){\n\t\tb_sub_a[i] = b[i] - a[i];\n\t\tsuma += a[i];\n\t}\n\tAVL_tree *t = make_AVL_tree();\n\tfor(i = 1; i < 2 * N - 1; i++){\n\t\tif(b_sub_a[i] >= 0){\n\t\t\tsum_p += b_sub_a[i];\n\t\t\tnum_p++;\n\t\t}\n\t\telse{\n\t\t\tsum_m += b_sub_a[i];\n\t\t}\n\t\tinsert_AVL(b_sub_a[i], 1, t);\n\t}\n\tAVL_node *r;\n\tint p, x, y, y_sub_x, ans;\n\tfor(i = 0; i < Q; i++){\n\t\tscanf(\"%lld%lld%lld\", &p, &x, &y);\n\t\tp--;\n\t\ty_sub_x = y - x;\n\t\tsuma += x - a[p];\n\t\tif (0 < p && p < 2 * N - 1){\n\t\t\tif(b_sub_a[p] >= 0){\n\t\t\t\tsum_p -= b_sub_a[p];\n\t\t\t\tnum_p--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum_m -= b_sub_a[p];\n\t\t\t}\n\t\t\tif(y_sub_x >= 0){\n\t\t\t\tsum_p += y_sub_x;\n\t\t\t\tnum_p++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum_m += y_sub_x;\n\t\t\t}\n\t\t\tr = erase_AVL(b_sub_a[p], t);\n\t\t\tinsert_AVL(y_sub_x, 1, t);\n\t\t}\n\t\ta[p] = x;\n\t\tb[p] = y;\n\t\tb_sub_a[p] = y_sub_x;\n\t\tif(num_p % 2 == 0){\n\t\t\tans = suma + sum_p;\n\t\t}\n\t\telse{\n\t\t\tif(num_p < N - 2){\n\t\t\t\tans = suma + sum_p + max(-next_smallest_AVL(-1, t)->key, next_largest_AVL(0, t)->key);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans = suma + sum_p - next_smallest_AVL(-1, t)->key;\n\t\t\t}\n\t\t}\n/*\t\tprintf(\"i = %lld\\n\", i);\n\t\tint j;\n\t\tprintf(\"a:\");\n\t\tfor(j = 0; j < 2 * N; j++){\n\t\t\tprintf(\"%lld \", a[j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tprintf(\"b:\");\n\t\tfor(j = 0; j < 2 * N; j++){\n\t\t\tprintf(\"%lld \", b[j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tprintf(\"suma = %lld\\n\", suma);\n\t\tprintf(\"sum_p = %lld\\n\", sum_p);\n\t\tprintf(\"num_p = %lld\\n\", num_p);\n*/\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define int long long\n#define AVL_keytype int\n#define AVL_valtype int\n\n\n//static int malloc_cont;\n//static int free_cont;\n\ntypedef struct AVL_node_sub{\n\tAVL_keytype key; //添え字\n\tAVL_valtype val; //値\n\tint ele_num; //木に含まれる要素数\n\tint height; //木の高さ\n\tstruct AVL_node_sub *left; //左の子へのポインタ\n\tstruct AVL_node_sub *right; //右の子へのポインタ\n}AVL_node;\n\ntypedef struct {\n\tAVL_node *root;\n}AVL_tree;\n\nint max(int a, int b){\n\treturn a >= b ? a : b;\n}\n\n//比較関数\n//a < b なら負の値\n//a = b なら0\n//a > b なら正の値\nint compare_AVL(AVL_keytype a, AVL_keytype b){\n\treturn a - b;\n}\n\nint ele_num(AVL_node *r){\n\tif(r == NULL){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn r->ele_num;\n\t}\n}\n\nint height(AVL_node *r){\n\tif(r == NULL){\n\t\treturn 0;\n\t}\n\telse{\n\t\treturn r->height;\n\t}\n}\n\n//tの指すノードを開放する\n//AVL_valtypeなどがポインタ型の時はそれもfreeする\nvoid release_AVL_node(AVL_node *r){\n\tfree(r);\n//\tfree_cont++;\n}\n\nAVL_node *build_AVL_node(AVL_keytype key, AVL_valtype val, AVL_node *left, AVL_node *right){\n\tAVL_node *newr;\n\tint left_h = height(left);\n\tint right_h = height(right);\n\tif(left_h > right_h + 1){\n\t\tAVL_node *ll = left->left;\n\t\tAVL_node *lr = left->right;\n\t\tif(height(ll) < height(lr)){\n\t\t\tnewr = build_AVL_node(lr->key, lr->val, build_AVL_node(left->key, left->val, ll, lr->left), build_AVL_node(key, val, lr->right, right));\n\t\t\trelease_AVL_node(lr);\n\t\t}\n\t\telse{\n\t\t\tnewr = build_AVL_node(left->key, left->val, ll, build_AVL_node(key, val, lr, right));\n\t\t}\n\t\trelease_AVL_node(left);\n\t}\n\telse if(right_h > left_h + 1){\n\t\tAVL_node *rr = right->right;\n\t\tAVL_node *rl = right->left;\n\t\tif(height(rr) < height(rl)){\n\t\t\tnewr = build_AVL_node(rl->key, rl->val, build_AVL_node(key, val, left, rl->left), build_AVL_node(right->key, right->val, rl->right, rr));\n\t\t\trelease_AVL_node(rl);\n\t\t}\n\t\telse{\n\t\t\tnewr = build_AVL_node(right->key, right->val, build_AVL_node(key, val, left, rl), rr);\n\t\t}\n\t\trelease_AVL_node(right);\n\t}\n\telse{\n//\t\tmalloc_cont++;\n\t\tnewr = (AVL_node *)malloc(sizeof(AVL_node));\n\t\tnewr->key = key;\n\t\tnewr->val = val;\n\t\tnewr->ele_num = ele_num(left) + ele_num(right) + 1;\n\t\tnewr->height = max(left_h, right_h) + 1;\n\t\tnewr->left = left;\n\t\tnewr->right = right;\n\t}\n\treturn newr;\n}\n\nAVL_node *find_AVL_sub(AVL_keytype key, AVL_node *r){\n\tif(r == NULL){\n\t\treturn NULL;\n\t}\n\tint comp = compare_AVL(key, r->key);\n\tif(comp == 0){\n\t\treturn r;\n\t}\n\telse if(comp < 0){\n\t\treturn find_AVL_sub(key, r->left);\n\t}\n\telse{\n\t\treturn find_AVL_sub(key, r->right);\n\t}\n}\n\nAVL_node *kth_smallest_AVL_sub(int k, AVL_node *r){\n\tif(r == NULL || k < 1){\n\t\tprintf(\"In function 'kth_smallest_AVL_sub':\\nargument 'k' is out of range\\n\");\n\t\treturn NULL;\n\t}\n\telse if(r->ele_num < k){\n\t\tprintf(\"In function 'kth_smallest_AVL_sub':\\nargument 'k' is out of range\\n\");\n\t\treturn NULL;\n\t}\n\telse if(ele_num(r->left) == k - 1){\n\t\treturn r;\n\t}\n\telse if(ele_num(r->left) > k - 1){\n\t\treturn kth_smallest_AVL_sub(k, r->left);\n\t}\n\telse{\n\t\treturn kth_smallest_AVL_sub(k - ele_num(r->left) - 1, r->right);\n\t}\n}\n\nint num_less_than_AVL_sub(AVL_keytype key, AVL_node *r){\n\tif(r == NULL){\n\t\treturn 0;\n\t}\n\telse if(compare_AVL(key, r->key) < 0){\n\t\treturn num_less_than_AVL_sub(key, r->left);\n\t}\n\telse{\n\t\treturn ele_num(r->left) + num_less_than_AVL_sub(key, r->right) + 1;\n\t}\n}\n\nAVL_node *next_largest_AVL_sub(AVL_keytype key, AVL_node *r){\n\tif(r == NULL){\n\t\treturn NULL;\n\t}\n\telse if(compare_AVL(key, r->key) <= 0){\n\t\treturn next_largest_AVL_sub(key, r->left);\n\t}\n\telse{\n\t\tAVL_node *candidate = next_largest_AVL_sub(key, r->right);\n\t\tif(candidate == NULL){\n\t\t\treturn r;\n\t\t}\n\t\telse{\n\t\t\treturn candidate;\n\t\t}\n\t}\n}\n\nAVL_node *next_smallest_AVL_sub(AVL_keytype key, AVL_node *r){\n\tif(r == NULL){\n\t\treturn NULL;\n\t}\n\telse if(compare_AVL(key, r->key) >= 0){\n\t\treturn next_smallest_AVL_sub(key, r->right);\n\t}\n\telse{\n\t\tAVL_node *candidate = next_smallest_AVL_sub(key, r->left);\n\t\tif(candidate == NULL){\n\t\t\treturn r;\n\t\t}\n\t\telse{\n\t\t\treturn candidate;\n\t\t}\n\t}\n}\n\nAVL_node *insert_AVL_sub(AVL_keytype key, AVL_valtype val, AVL_node *r){\n\tAVL_node *newr;\n\tif(r == NULL){\n\t\tnewr = build_AVL_node(key, val, NULL, NULL);\n\t}\n\telse{\n\t\tint comp = compare_AVL(key, r->key);\n\t\t/*if(comp == 0){\n\t\t\tprintf(\"In function 'insert_AVL_sub':\\nkey '%d' already exists\\n\", key);\n\t\t\tnewr = build_AVL_node(r->key, val, r->left, r->right);\n\t\t}\n\t\telse*/ if(comp < 0){\n\t\t\tnewr = build_AVL_node(r->key, r->val, insert_AVL_sub(key, val, r->left), r->right);\n\t\t}\n\t\telse{\n\t\t\tnewr = build_AVL_node(r->key, r->val, r->left, insert_AVL_sub(key, val, r->right));\n\t\t}\n\t\trelease_AVL_node(r);\n\t}\n\treturn newr;\n}\n\nAVL_node *erase_AVL_sub_sub(AVL_node *r){\n\tif(r->left == NULL){\n\t\treturn r->right;\n\t}\n\telse{\n\t\treturn build_AVL_node(r->key, r->val, erase_AVL_sub_sub(r->left), r->right);\n\t}\n}\n\nAVL_node *erase_AVL_sub(AVL_keytype key, AVL_node *r, AVL_node **ans){\n\tAVL_node *newr;\n\tif(r == NULL){\n\t\tnewr = NULL;\n\t}\n\telse{\n\t\tint comp = compare_AVL(key, r->key);\n\t\tif(comp == 0){\n\t\t\t*ans = r;\n\t\t\tif(r->left == NULL && r->right == NULL){\n\t\t\t\tnewr = NULL;\n\t\t\t}\n\t\t\telse if(r->right == NULL){\n\t\t\t\tnewr = r->left;\n\t\t\t}\n\t\t\telse if(r->left == NULL){\n\t\t\t\tnewr = r->right;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tAVL_node *next_larger = kth_smallest_AVL_sub(1, r->right);\n\t\t\t\tnewr = build_AVL_node(next_larger->key, next_larger->val, r->left, erase_AVL_sub_sub(r->right));\n\t\t\t\trelease_AVL_node(next_larger);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(comp < 0){\n\t\t\t\tnewr = build_AVL_node(r->key, r->val, erase_AVL_sub(key, r->left, ans), r->right);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnewr = build_AVL_node(r->key, r->val, r->left, erase_AVL_sub(key, r->right, ans));\n\t\t\t}\n\t\t\trelease_AVL_node(r);\n\t\t}\n\t}\n\treturn newr;\n}\n\nvoid storeall_AVL_sub(AVL_keytype *array, int k, AVL_node *r){\n\tif(r != NULL){\n\t\tstoreall_AVL_sub(array, k, r->left);\n\t\tarray[k + ele_num(r->left)] = r->key;\n\t\tstoreall_AVL_sub(array, k + ele_num(r->left) + 1, r->right);\n\t}\n}\n\nvoid outall_AVL_sub(AVL_node *r){\n\tif(r != NULL){\n\t\toutall_AVL_sub(r->left);\n\t\tprintf(\"(key, val, ele_num, height) = (%d, %d, %d, %d)\\n\", r->key, r->val, r->ele_num, r->height);\n\t\toutall_AVL_sub(r->right);\n\t}\n}\n\n//AVL_treeを生成する\nAVL_tree *make_AVL_tree(){\n\tAVL_tree *t = (AVL_tree *)malloc(sizeof(AVL_tree));\n\tt->root = NULL;\n\treturn t;\n}\n\n//tに含まれるノードの数を返す\nint element_num_AVL(AVL_tree *t){\n\treturn ele_num(t->root);\n}\n\n//添え字がkeyのノードへのポインタを返す\n//なければNULLを返す\nAVL_node *find_AVL(AVL_keytype key, AVL_tree *t){\n\treturn find_AVL_sub(key, t->root);\n}\n\n//小さい順にk番目のkeyのノードへのポインタを返す\n//1 ≦ k ≦ ele_num(t->root) を満たさない場合はNULLを返す(メッセージが出る)\nAVL_node *kth_smallest_AVL(int k, AVL_tree *t){\n\treturn kth_smallest_AVL_sub(k, t->root);\n}\n\n//添え字がkey以下のノードの数を返す\nint num_less_than_AVL(AVL_keytype key, AVL_tree *t){\n\treturn num_less_than_AVL_sub(key, t->root);\n}\n\n//keyよりも小さい中で最大の添え字のノードへのポインタを返す\n//なければNULLを返す\nAVL_node *next_largest_AVL(AVL_keytype key, AVL_tree *t){\n\treturn next_largest_AVL_sub(key, t->root);\n}\n\n//keyよりも大きい中で最小の添え字のノードへのポインタを返す\n//なければNULLを返す\nAVL_node *next_smallest_AVL(AVL_keytype key, AVL_tree *t){\n\treturn next_smallest_AVL_sub(key, t->root);\n}\n\n//添え字key, 値valのノードを挿入する\n//既に存在する場合は値が上書きされる(メッセージが出る)\nvoid insert_AVL(AVL_keytype key, AVL_valtype val, AVL_tree *t){\n\tt->root = insert_AVL_sub(key, val, t->root);\n}\n\n//添え字keyのノードを削除しそれを返す\n//存在しない場合はNULLを返す\nAVL_node *erase_AVL(AVL_keytype key, AVL_tree *t){\n\tAVL_node *ans = NULL;\n\tt->root = erase_AVL_sub(key, t->root, &ans);\n\treturn ans;\n}\n\n//全ノードのkeyを小さい順に格納した配列を返す\nAVL_keytype *storeall_AVL(AVL_tree *t){\n\tAVL_keytype *array = (AVL_keytype *)malloc(sizeof(AVL_keytype) * element_num_AVL(t));\n\tstoreall_AVL_sub(array, 0, t->root);\n\treturn array;\n}\n\n//全ノードの中身をkeyの小さい順に出力する\nvoid outall_AVL(AVL_tree *t){\n\toutall_AVL_sub(t->root);\n}\n\nsigned main(){\n\tint N, Q, i;\n\tscanf(\"%lld%lld\", &N, &Q);\n\tint *a = (int *)malloc(sizeof(int) * (2 * N));\n\tint *b = (int *)malloc(sizeof(int) * (2 * N));\n\tint *b_sub_a = (int *)malloc(sizeof(int) * (2 * N));\n\tfor(i = 0; i < 2 * N; i++){\n\t\tscanf(\"%lld\", &a[i]);\n\t}\n\tfor(i = 0; i < 2 * N; i++){\n\t\tscanf(\"%lld\", &b[i]);\n\t}\n\tint suma = 0, sum_p = 0,sum_m = 0, num_p = 0;\n\tfor(i = 0; i < 2 * N; i++){\n\t\tb_sub_a[i] = b[i] - a[i];\n\t\tsuma += a[i];\n\t}\n\tAVL_tree *t = make_AVL_tree();\n\tfor(i = 1; i < 2 * N - 1; i++){\n\t\tif(b_sub_a[i] >= 0){\n\t\t\tsum_p += b_sub_a[i];\n\t\t\tnum_p++;\n\t\t}\n\t\telse{\n\t\t\tsum_m += b_sub_a[i];\n\t\t}\n\t\tinsert_AVL(b_sub_a[i], 1, t);\n\t}\n\tAVL_node *r;\n\tint p, x, y, y_sub_x, ans;\n\tfor(i = 0; i < Q; i++){\n\t\tscanf(\"%lld%lld%lld\", &p, &x, &y);\n\t\tp--;\n\t\ty_sub_x = y - x;\n\t\tsuma += x - a[p];\n\t\tif (0 < p && p < 2 * N - 1){\n\t\t\tif(b_sub_a[p] >= 0){\n\t\t\t\tsum_p -= b_sub_a[p];\n\t\t\t\tnum_p--;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum_m -= b_sub_a[p];\n\t\t\t}\n\t\t\tif(y_sub_x >= 0){\n\t\t\t\tsum_p += y_sub_x;\n\t\t\t\tnum_p++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tsum_m += y_sub_x;\n\t\t\t}\n\t\t\tr = erase_AVL(b_sub_a[p], t);\n\t\t\tinsert_AVL(y_sub_x, 1, t);\n\t\t}\n\t\ta[p] = x;\n\t\tb[p] = y;\n\t\tb_sub_a[p] = y_sub_x;\n\t\tif(num_p % 2 == 0){\n\t\t\tans = suma + sum_p;\n\t\t}\n\t\telse{\n\t\t\tif(num_p < 2 * N - 2){\n\t\t\t\tans = suma + sum_p + max(-next_smallest_AVL(-1, t)->key, next_largest_AVL(0, t)->key);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans = suma + sum_p - next_smallest_AVL(-1, t)->key;\n\t\t\t}\n\t\t}\n/*\t\tprintf(\"i = %lld\\n\", i);\n\t\tint j;\n\t\tprintf(\"a:\");\n\t\tfor(j = 0; j < 2 * N; j++){\n\t\t\tprintf(\"%lld \", a[j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tprintf(\"b:\");\n\t\tfor(j = 0; j < 2 * N; j++){\n\t\t\tprintf(\"%lld \", b[j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t\tprintf(\"suma = %lld\\n\", suma);\n\t\tprintf(\"sum_p = %lld\\n\", sum_p);\n\t\tprintf(\"num_p = %lld\\n\", num_p);\n*/\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#if 0\ncat <<EOF >mistaken-paste\n#endif\n// thanks for @rsk0315_h4x\n\n#pragma GCC diagnostic ignored \"-Wincompatible-pointer-types\"\n#define _USE_MATH_DEFINES\n\n#include <stdio.h>\n#include <stdint.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <math.h>\n#include <time.h>\n\n#define BIG 2000000007\n#define VERYBIG 2000000000000007LL\n\n#define MOD 1000000007\n#define FOD  998244353\ntypedef uint64_t ull;\ntypedef  int64_t sll;\n\n#define N_MAX 1000000\n\n#ifdef __cplusplus\n#include <queue>\n#include <stack>\n#include <tuple>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <array>\n\nusing std::queue;\nusing std::priority_queue;\nusing std::stack;\nusing std::tuple;\nusing std::set;\nusing std::map;\nusing std::vector;\nusing std::greater;\nusing std::pair;\nusing std::string;\nusing std::get;\n\ntemplate <typename T, typename U>\npair<T, U> operator+(pair<T, U> l, pair<T, U> r) {\n\treturn pair<T, U>(l.first + r.first, l.second + r.second);\n}\n\n#endif\n\ntypedef struct {\n\tint32_t a;\n\tint32_t b;\n} hw;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n} hwll;\n\ntypedef struct {\n\tsll a;\n\tsll b;\n\tsll c;\n} hwllc;\n\ntypedef struct {\n\thwll a;\n\thwll b;\n} linell;\n\null n, m;\null h, w;\null k;\null q;\nsll va, vb, vc, vd, ve, vf;\null ua, ub, uc, ud, ue, uf;\nlong double vra, vrb, vrc;\ndouble vda, vdb, vdc;\nchar ch, dh;\n\null umin (ull x, ull y) {\n\treturn (x < y) ? x : y;\n}\n\null umax (ull x, ull y) {\n\treturn (x > y) ? x : y;\n}\n\nsll smin (sll x, sll y) {\n\treturn (x < y) ? x : y;\n}\n\nsll smax (sll x, sll y) {\n\treturn (x > y) ? x : y;\n}\n\null gcd (ull x, ull y) {\n\tif (x < y) {\n\t\treturn gcd(y, x);\n\t} else if (y == 0) {\n\t\treturn x;\n\t} else {\n\t\treturn gcd(y, x % y);\n\t}\n}\n\null bitpow (ull a, ull x, ull modulo) {\n\tull result = 1;\n\twhile (x) {\n\t\tif (x & 1) {\n\t\t\tresult *= a;\n\t\t\tresult %= modulo;\n\t\t}\n\t\tx /= 2;\n\t\ta = (a * a) % modulo;\n\t}\n\treturn result;\n}\n\null divide (ull a, ull b, ull modulo) {\n\treturn (a * bitpow(b, modulo - 2, modulo)) % modulo;\n}\n\null udiff (ull a, ull b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nsll sdiff (sll a, sll b) {\n\tif (a >= b) {\n\t\treturn a - b;\n\t} else {\n\t\treturn b - a;\n\t}\n}\n\nint bitcount (ull n) {\n\tint result = 0;\n\twhile (n) {\n\t\tif (n & 1) result++;\n\t\tn /= 2;\n\t}\n\treturn result;\n}\n\n#define BEGCMP(NAME) int32_t NAME (const void *left, const void *right)\n#define DEFLR(TYPE) TYPE l=*(TYPE*)left,r=*(TYPE*)right\n#define CMPRET(L, R) if((L)<(R))return-1;if((L)>(R))return+1\n\n// int32_t pullcomp (const void *left, const void *right) {\n// \tull l = *(ull*)left;\n// \tull r = *(ull*)right;\n// \tif (l < r) {\n// \t\treturn -1;\n// \t}\n// \tif (l > r) {\n// \t\treturn +1;\n// \t}\n// \treturn 0;\n// }\nBEGCMP(pullcomp){\n\tDEFLR(ull);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(prevcomp){\n\tDEFLR(ull);\n\tCMPRET(r, l);\n\treturn 0;\n}\nBEGCMP(psllcomp){\n\tDEFLR(sll);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pcharcomp){\n\tDEFLR(char);\n\tCMPRET(l, r);\n\treturn 0;\n}\nBEGCMP(pdoublecomp){\n\tDEFLR(double);\n\tCMPRET(l, r);\n\treturn 0;\n}\n\nint32_t pstrcomp (const void *left, const void *right) {\n\tchar* l = *(char**)left;\n\tchar* r = *(char**)right;\n\n\treturn strcmp(l, r);\n}\n\nBEGCMP(phwllABcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\treturn 0;\n}\nBEGCMP(phwllREVcomp){\n\tDEFLR(hwll);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\treturn 0;\n}\nBEGCMP(ptriplecomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\nBEGCMP(ptripleREVcomp){\n\tDEFLR(hwllc);\n\tCMPRET(l.b, r.b);\n\tCMPRET(l.a, r.a);\n\tCMPRET(l.c, r.c);\n\treturn 0;\n}\n\nint32_t pquadcomp (const void *left, const void *right) {\n\tlinell l = *(linell*)left;\n\tlinell r = *(linell*)right;\n\n\tsll ac = phwllABcomp(&(l.a), &(r.a));\n\tif (ac) return ac;\n\tsll bc = phwllABcomp(&(l.b), &(r.b));\n\tif (bc) return bc;\n\n\treturn 0;\n}\n\nbool isinrange (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right);\n}\n\nbool isinrange_soft (sll left, sll x, sll right) {\n\treturn (left <= x && x <= right) || (left >= x && x >= right);\n}\n\nsll a[N_MAX + 5];\n// ull a[N_MAX + 5];\n// sll a[3001][3001];\nsll b[N_MAX + 5];\n// ull b[N_MAX + 5];\n// sll b[3001][3001];\null c[N_MAX + 5];\null d[N_MAX + 5];\nsll e[N_MAX];\nchar s[N_MAX + 1];\n// char s[3010][3010];\nchar t[N_MAX + 1];\n// char t[3010][3010];\n// char u[N_MAX + 1];\nhwll xy[N_MAX + 5];\nhwllc tup[N_MAX + 5];\nsll table[3005][3005];\n// here we go\n\nsll seg1[524288], seg2[524288], base = 262144;\n\null upset (ull i, sll x, sll seg[]) {\n\ti += base;\n\tseg[i] = x;\n\twhile (i /= 2) {\n\t\tseg[i] = umin(seg[i * 2], seg[i * 2 + 1]);\n\t}\n\treturn seg[1];\n}\n\null solve () {\n\tsll i, j, ki, li;\n\t// ull result = 0;\n\tsll result = 0;\n\tdouble dresult = 0;\n\t// ull maybe = 0;\n\tsll maybe = 0;\n\t// ull sum = 0;\n\tsll sum = 0;\n\tsll item;\n\tull *dpcell;\n\n\ti = base * 2;\n\twhile (--i) {\n\t\tseg1[i] = seg2[i] = VERYBIG;\n\t}\n\n\tsll asum = 0, bplsum = 0;\n\tull pluscnt = 0;\n\tfor (i = 0; i < n * 2; i++) {\n\t\tasum += a[i];\n\t\tif (i > 0 && i < n * 2 - 1) {\n\t\t\tif (b[i] > a[i]) {\n\t\t\t\tpluscnt++;\n\t\t\t\tbplsum += (b[i] - a[i]);\n\t\t\t\tupset(i, b[i] - a[i], seg1);\n\t\t\t} else {\n\t\t\t\tupset(i, a[i] - b[i], seg2);\n\t\t\t}\n\t\t}\n\t}\n\n\twhile (q--) {\n\t\tsll p, x, y;\n\t\tscanf(\"%lld%lld%lld\", &p, &x, &y);\n\t\tp--;\n\n\t\tif (p == 0 || p == n * 2 - 1) {\n\t\t\tasum -= a[p];\n\t\t\ta[p] = x;\n\t\t\tb[p] = y;\n\t\t\tasum += a[p];\n\t\t} else {\n\t\t\tasum -= a[p];\n\t\t\tif (b[p] > a[p]) {\n\t\t\t\tpluscnt--;\n\t\t\t\tbplsum -= (b[p] - a[p]);\n\t\t\t\tupset(p, VERYBIG, seg1);\n\t\t\t} else {\n\t\t\t\tupset(p, VERYBIG, seg2);\n\t\t\t}\n\t\t\ta[p] = x;\n\t\t\tb[p] = y;\n\t\t\tasum += a[p];\n\t\t\tif (b[p] > a[p]) {\n\t\t\t\tpluscnt++;\n\t\t\t\tbplsum += (b[p] - a[p]);\n\t\t\t\tupset(p, b[p] - a[p], seg1);\n\t\t\t} else {\n\t\t\t\tupset(p, a[p] - b[p], seg2);\n\t\t\t}\n\t\t}\n\n\t\tif (pluscnt % 2) {\n\t\t\tresult = asum + bplsum - smin(seg1[1], seg2[1]);\n\t\t} else {\n\t\t\tresult = asum + bplsum;\n\t\t}\n\t\tprintf(\"%lld\\n\", result);\n\t}\n\n\t// printf(\"%lld\\n\", result);\n\t// printf(\"%.15lf\\n\", dresult);\n\t// puts(s);\n\n\treturn 0;\n\n\tsuccess:\n\tputs(\"YES\");\n\t// puts(\"Yes\");\n\t// printf(\"%llu\\n\", result);\n\t// puts(\"0\");\n\t// puts(\"Yay!\");\n\treturn 0;\n\n\tfail:\n\tputs(\"NO\");\n\t// puts(\"No\");\n\t// puts(\"0\");\n\t// puts(\"-1\");\n\t// puts(\"-1 -1 -1\");\n\t// puts(\"Impossible\");\n\treturn 1;\n}\n\nint32_t main (void) {\n\tint32_t i, j;\n\tint32_t x, y;\n\n\n\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &n, &m);\n\t// scanf(\"%llu%llu\", &k, &n, &m);\n\t// scanf(\"%llu%llu\", &h, &w);\n\tscanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\t// scanf(\"%lld%lld\", &va, &vb, &vc, &vd);\n\t// scanf(\"%llu%llu%llu\", &ua, &ub, &uc, &ud);\n\t// scanf(\"%s\", t);\n\t// scanf(\"%lld\", &m);\n\tfor (i = 0; i < n * 2; i++) {\n\t\t// scanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t\t// scanf(\"%lld%lld%lld\", &tup[i].a, &tup[i].b, &tup[i].c);\n\t\tscanf(\"%lld\", &a[i]);\n\t\t// scanf(\"%lld\", &b[i]);\n\t\t// scanf(\"%lld\", &c[i]);\n\t\t// scanf(\"%lld\", &d[i]);\n\t\t// a[i]--;\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t\t// d[i]--;\n\t\t// xy[i].a--;\n\t\t// xy[i].b--;\n\t\t// tup[i].a--;\n\t\t// tup[i].b--;\n\t}\n\t// scanf(\"%llu\", &m, &k);\n\t// scanf(\"%llu\", &q);\n\t// scanf(\"%s\", s);\n\tfor (i = 0; i < n * 2; i++) {\n\t\tscanf(\"%lld\", &b[i]);\n\t\t// b[i]--;\n\t\t// c[i]--;\n\t}\n\t// scanf(\"%llu\", &q);\n\n\t// for (i = 0; i < q; i++) {\n\t// \tscanf(\"%lld%lld\", &xy[i].a, &xy[i].b);\n\t// \txy[i].a--;\n\t// \txy[i].b--;\n\t// }\n\n\t// for (i = 0; i < h; i++) {\n\t// \tfor (j = 0; j < w; j++) {\n\t// \t\tscanf(\"%lld\", &table[i][j]);\n\t// \t\t// table[i][j]--;\n\t// \t}\n\t// }\n\t// for (i = 0; i < h; i++) {\n\t// \tscanf(\"%s\", s[i]);\n\t// }\n\t// scanf(\"%llu\", &q);\n\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n  static int n;\n  private static void solve() {\n    n = ni() * 2;\n    if (n > 15) {\n      return;\n    }\n    int Q = ni();\n    long[] a = nal(n);\n    long[] b = nal(n);\n    int[][] query = ntable(Q, 3);\n    \n    \n    for (int[] q : query) {\n      a[q[0] - 1] = q[1];\n      b[q[0] - 1] = q[2];\n\n      long max = Long.MIN_VALUE;\n      for (int i = 0; i < (1 << n); i ++) {\n        if (!check(i)) continue;\n        for (int j = i; j < (1 << n); j ++) {\n          if (!check(j)) continue;\n          \n          long score = 0;\n          for (int k = 0; k < n; k ++) {\n            int b1 = (i >> k) & 1;\n            int b2 = (j >> k) & 1;\n            score += b1 == b2 ? a[k] : b[k];\n          }\n          max = Math.max(max, score);\n        }\n      }\n      System.out.println(max);\n    }\n    \n  }\n  \n  private static boolean check(int x) {\n    int level = 0;\n    for (int i = 0; i < n; i ++) {\n      if (((x >> i) & 1) == 0) {\n        level ++;\n      } else {\n        level --;\n        if (level < 0) {\n          return false;\n        }\n      }\n    }\n    return level == 0;\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n  static int n;\n  private static void solve() {\n    n = ni() * 2;\n    if (n > 15) {\n      return;\n    }\n    int Q = ni();\n    long[] a = nal(n);\n    long[] b = nal(n);\n    int[][] query = ntable(Q, 3);\n    \n    \n    for (int[] q : query) {\n      a[q[0] - 1] = q[1];\n      b[q[0] - 1] = q[2];\n\n      long max = 0;\n      for (int i = 0; i < (1 << n); i ++) {\n        if (!check(i)) continue;\n        for (int j = i; j < (1 << n); j ++) {\n          if (!check(j)) continue;\n          \n          long score = 0;\n          for (int k = 0; k < n; k ++) {\n            int b1 = (i >> k) & 1;\n            int b2 = (j >> k) & 1;\n            score += b1 == b2 ? a[k] : b[k];\n          }\n          max = Math.max(max, score);\n        }\n      }\n      System.out.println(max);\n    }\n    \n  }\n  \n  private static boolean check(int x) {\n    int level = 0;\n    for (int i = 0; i < n; i ++) {\n      if (((x >> i) & 1) == 0) {\n        level ++;\n      } else {\n        level --;\n        if (level < 0) {\n          return false;\n        }\n      }\n    }\n    return level == 0;\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    static final long I=1L<<40;\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int n=Integer.parseInt(scan.next());\n        int q=Integer.parseInt(scan.next());\n        long[]a=new long[2*n],b=new long[2*n];\n        for(int i=0;i<2*n;++i)a[i]=Integer.parseInt(scan.next());\n        for(int i=0;i<2*n;++i)b[i]=Integer.parseInt(scan.next());\n        long t=0;\n        MaxSegmentTree sd=new MaxSegmentTree();\n        MaxSegmentTree sdp=new MaxSegmentTree();\n        long tpos=0;\n        int cpos=0;\n        for(int i=0;i<2*n;++i)t+=a[i];\n        for(int i=1;i<2*n-1;++i){\n            long c=b[i]-a[i];\n            tpos+=Math.max(c,0);\n            if(c>=0)cpos++;\n            sd.update(i,c>=0?-I:c);\n            sdp.update(i,c<0?-I:-c);\n        }\n        for(int i=0;i<q;++i){\n            int p=Integer.parseInt(scan.next())-1;\n            long x=Integer.parseInt(scan.next());\n            long y=Integer.parseInt(scan.next());\n            long c=b[p]-a[p];\n            t-=a[p];\n            if(1<=p&&p<=2*n-2&&c>=0){\n                tpos-=c;\n                cpos--;\n            }\n            a[p]=x;\n            b[p]=y;\n            c=b[p]-a[p];\n            t+=a[p];\n            if(1<=p&&p<=2*n-2&&c>=0){\n                tpos+=c;\n                cpos++;\n            }\n            if(1<=p&&p<=2*n-2) {\n                sd.update(p,c>=0?-I:c);\n                sdp.update(p,c<0?-I:-c);\n            }\n            long ans;\n            if(cpos%2==0)\n                ans=tpos;\n            else{\n                ans=Math.max(tpos+sd.query(1,2*n-1),tpos+sdp.query(1,2*n-1));\n            }\n            System.out.println(ans+t);\n        }\n    }\n}\nclass MaxSegmentTree {\n    static final int SIZE = 1 << 18;\n    static final long INFINITY = (1L << 62) - 1;\n    long[] seg;\n    MaxSegmentTree() {\n\tthis.seg = new long[2 * SIZE];\n    }\n    void update(int x, long value) {\n\tx += SIZE - 1;\n\tthis.seg[x] = value;\n\twhile (x > 0) {\n\t    x = (x - 1) / 2;\n\t    this.seg[x] = Math.max(this.seg[2 * x + 1], this.seg[2 * x + 2]);\n\t}\n    }\n    long query(int l, int r) {\n\tl += SIZE - 1;\n\tr += SIZE - 1;\n        long y = -INFINITY;\n\twhile (l < r) {\n\t    if ((l & 1) == 0) {\n\t\ty = Math.max(y, this.seg[l]);\n\t    }\n\t    if ((r & 1) == 0) {\n\t\ty = Math.max(y, this.seg[r - 1]);\n\t    }\n\t    l /= 2;\n\t    r = (r - 1) / 2;\n\t}\n\treturn y;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n  static int n;\n  private static void solve() {\n    n = ni() * 2;\n    int Q = ni();\n    int[] a = na(n);\n    int[] b = na(n);\n    int[][] query = ntable(Q, 3);\n    \n    \n    for (int[] q : query) {\n      a[q[0] - 1] = q[1];\n      b[q[0] - 1] = q[2];\n\n      int max = 0;\n      for (int i = 0; i < (1 << n); i ++) {\n        if (!check(i)) continue;\n        for (int j = i; j < (1 << n); j ++) {\n          if (!check(j)) continue;\n          \n          int score = 0;\n          for (int k = 0; k < n; k ++) {\n            int b1 = (i >> k) & 1;\n            int b2 = (j >> k) & 1;\n            score += b1 == b2 ? a[k] : b[k];\n          }\n          max = Math.max(max, score);\n        }\n      }\n      System.out.println(max);\n    }\n    \n  }\n  \n  private static boolean check(int x) {\n    int level = 0;\n    for (int i = 0; i < n; i ++) {\n      if (((x >> i) & 1) == 0) {\n        level ++;\n      } else {\n        level --;\n        if (level < 0) {\n          return false;\n        }\n      }\n    }\n    return level == 0;\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    static int mod = 1_000_000_007;\n    // int mod = 998244353;\n    long inf = Long.MAX_VALUE/2;\n\n    void solve(){\n        int n = ni();\n        int q = ni();\n        long[] a = new long[2*n];\n        long[] b = new long[2*n];\n        long S = 0;\n        long T = 0;\n        for(int i = 0; i < 2*n; i++){\n            a[i] = nl();\n            S += a[i];\n        }\n        for(int i = 0; i < 2*n; i++){\n            b[i] = nl();\n            b[i] -= a[i];\n        }\n        TreeSet<Long> pos = new TreeSet<>();\n        TreeSet<Long> neg = new TreeSet<>();\n        for(int i = 0; i < 2*n; i++){\n            if(i==0||i==2*n-1) continue;\n            if(b[i]>0){\n                pos.add(b[i]);\n                T += b[i];\n            }\n            else{\n                neg.add(-b[i]);\n            }\n        }\n        neg.add(inf);\n        for(int i = 0; i < q; i++){\n            int p = ni()-1;\n            long x = nl();\n            long y = nl();\n            if(p!=0 && p!=2*n-1){\n                if(b[p]>0){\n                    pos.remove(b[p]);\n                    T -= b[p];\n                }\n                else{\n                    neg.remove(-b[p]);\n                }\n            }\n            S = S - a[p] + x;\n            b[p] = y-x;\n            a[p] = x;\n            if(p!=0 && p!=2*n-1){\n                if(b[p]>0){\n                    pos.add(b[p]);\n                    T += b[p];\n                }\n                else{\n                    neg.add(-b[p]);\n                }\n            }\n            long ans = 0;\n            if(pos.size()%2==0){\n                ans = S + T;\n            }\n            else{\n                ans = S + Math.max(T - pos.first(), T - neg.first());\n            }\n            out.println(ans);\n        }\n\n    }\n\n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static int N, Q;\n    static int[] A, B;\n    static int[] P, X, Y;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextInt() * 2;\n        Q = sc.nextInt();\n        A = sc.nextIntArray(N);\n        B = sc.nextIntArray(N);\n        P = new int[Q];\n        X = new int[Q];\n        Y = new int[Q];\n        for (int i = 0; i < Q; i++) {\n            P[i] = sc.nextInt()-1;\n            X[i] = sc.nextInt();\n            Y[i] = sc.nextInt();\n        }\n\n        writeLines(solve());\n    }\n\n    static long[] solve() {\n        long total = 0;\n        Multiset<Integer> ma = new Multiset<>();\n        Multiset<Integer> mb = new Multiset<>();\n        for (int i = 0; i < N; i++) {\n            if( i == 0 || i == N-1 ) {\n                total += A[i];\n\n            } else {\n                if( A[i] >= B[i] ) {\n                    ma.add(A[i] - B[i]);\n                    total += A[i];\n                } else {\n                    mb.add(B[i] - A[i]);\n                    total += B[i];\n                }\n            }\n        }\n\n        long[] ans = new long[Q];\n\n        for (int i = 0; i < Q; i++) {\n            int p = P[i];\n            int x = X[i];\n            int y = Y[i];\n\n            if( p == 0 || p == N-1 ) {\n                // Aを使う他ない\n                total -= A[p];\n                A[p] = x;\n                total += x;\n\n            } else {\n                if( A[p] >= B[p] ) {\n                    ma.remove(A[p] - B[p]);\n                    total -= A[p];\n                } else {\n                    mb.remove(B[p] - A[p]);\n                    total -= B[p];\n                }\n                if( x >= y ) {\n                    ma.add( x - y );\n                    total += x;\n                } else {\n                    mb.add( y - x );\n                    total += y;\n                }\n                A[p] = x;\n                B[p] = y;\n            }\n\n            long r = total;\n            if( ma.size() % 2 == 1 ) {\n                int a = ma.peek();\n                int b = mb.peek();\n\n                if( a > b ) {\n                    r -= b;\n                } else {\n                    r -= a;\n                }\n            }\n            ans[i] = r;\n        }\n\n        return ans;\n    }\n\n    static class Multiset<A> {\n\n        private TreeSet<A> set = new TreeSet<>();\n        private Map<A, Integer> cnt = new HashMap<>();\n        private int size;\n\n        public void add(A a) {\n            size++;\n            if (cnt.containsKey(a)) {\n                cnt.put(a, cnt.get(a) + 1);\n\n            } else {\n                set.add(a);\n                cnt.put(a, 1);\n            }\n        }\n\n        public boolean isEmpty() {\n            return size == 0;\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public A pollLast() {\n            if (isEmpty()) return null;\n\n            size--;\n            A last = set.last();\n            if (cnt.get(last) == 1) {\n                cnt.remove(last);\n                return set.pollLast();\n\n            } else {\n                cnt.put(last, cnt.get(last) - 1);\n                return last;\n            }\n        }\n\n        public A peek() {\n            if (isEmpty()) return null;\n            return set.first();\n        }\n\n        public A poll() {\n            if (isEmpty()) return null;\n\n            size--;\n            A first = set.first();\n            if (cnt.get(first) == 1) {\n                cnt.remove(first);\n                return set.pollFirst();\n\n            } else {\n                cnt.put(first, cnt.get(first) - 1);\n                return first;\n            }\n        }\n\n        public void remove(A a) {\n            size--;\n            if( cnt.get(a) == 1 ) {\n                cnt.remove(a);\n                set.remove(a);\n\n            } else {\n                cnt.put(a, cnt.get(a)-1);\n            }\n        }\n\n        public String toString() {\n            List<A> list = new ArrayList<>();\n            for (A k : set) {\n                for (int i = 0; i < cnt.get(k); i++) {\n                    list.add(k);\n                }\n            }\n            return list.toString();\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    static final long I=1L<<40;\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int n=Integer.parseInt(scan.next());\n        int q=Integer.parseInt(scan.next());\n        long[]a=new long[2*n],b=new long[2*n];\n        for(int i=0;i<2*n;++i)a[i]=Integer.parseInt(scan.next());\n        for(int i=0;i<2*n;++i)b[i]=Integer.parseInt(scan.next());\n        long t=0;\n        MaxSegmentTree sd=new MaxSegmentTree();\n        MaxSegmentTree sdp=new MaxSegmentTree();\n        long[]d=new long[2*n];\n        long tpos=0;\n        int cpos=0;\n        for(int i=0;i<2*n;++i)t+=a[i];\n        for(int i=1;i<2*n-1;++i){\n            long c=b[i]-a[i];\n            d[i]=c;\n            tpos+=Math.max(c,0);\n            if(c>=0)cpos++;\n            sd.update(i,c>=0?-I:c);\n            sdp.update(i,c<0?-I:-c);\n        }\n        for(int i=0;i<q;++i){\n            int p=Integer.parseInt(scan.next())-1;\n            long x=Integer.parseInt(scan.next());\n            long y=Integer.parseInt(scan.next());\n            long c=b[p]-a[p];\n            t-=a[p];\n            if(c>=0){\n                tpos-=c;\n                cpos--;\n            }\n            a[p]=x;\n            b[p]=y;\n            c=b[p]-a[p];\n            t+=a[p];\n            if(c>=0){\n                tpos+=c;\n                cpos++;\n            }\n            sd.update(p,c>=0?-I:c);\n            sdp.update(p,c<0?-I:-c);\n            long ans;\n            if(cpos%2==0)\n                ans=tpos;\n            else{\n                ans=Math.max(tpos+sd.query(1,2*n-1),tpos+sdp.query(1,2*n-1));\n            }\n            System.out.println(ans+t);\n        }\n    }\n}\nclass MaxSegmentTree {\n    static final int SIZE = 1 << 18;\n    static final long INFINITY = (1L << 62) - 1;\n    long[] seg;\n    MaxSegmentTree() {\n\tthis.seg = new long[2 * SIZE];\n    }\n    void update(int x, long value) {\n\tx += SIZE - 1;\n\tthis.seg[x] = value;\n\twhile (x > 0) {\n\t    x = (x - 1) / 2;\n\t    this.seg[x] = Math.max(this.seg[2 * x + 1], this.seg[2 * x + 2]);\n\t}\n    }\n    long query(int l, int r) {\n\tl += SIZE - 1;\n\tr += SIZE - 1;\n        long y = -INFINITY;\n\twhile (l < r) {\n\t    if ((l & 1) == 0) {\n\t\ty = Math.max(y, this.seg[l]);\n\t    }\n\t    if ((r & 1) == 0) {\n\t\ty = Math.max(y, this.seg[r - 1]);\n\t    }\n\t    l /= 2;\n\t    r = (r - 1) / 2;\n\t}\n\treturn y;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static int N, Q;\n    static int[] A, B;\n    static int[] P, X, Y;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextInt() * 2;\n        Q = sc.nextInt();\n        A = sc.nextIntArray(N);\n        B = sc.nextIntArray(N);\n        P = new int[Q];\n        X = new int[Q];\n        Y = new int[Q];\n        for (int i = 0; i < Q; i++) {\n            P[i] = sc.nextInt()-1;\n            X[i] = sc.nextInt();\n            Y[i] = sc.nextInt();\n        }\n\n        writeLines(solve());\n    }\n\n    static long[] solve() {\n        long total = 0;\n        Multiset<Integer> ma = new Multiset<>();\n        Multiset<Integer> mb = new Multiset<>();\n        for (int i = 0; i < N; i++) {\n            if( i == 0 || i == N-1 ) {\n                total += A[i];\n\n            } else {\n                if( A[i] >= B[i] ) {\n                    ma.add(A[i] - B[i]);\n                    total += A[i];\n                } else {\n                    mb.add(B[i] - A[i]);\n                    total += B[i];\n                }\n            }\n        }\n\n        long[] ans = new long[Q];\n\n        for (int i = 0; i < Q; i++) {\n            int p = P[i];\n            int x = X[i];\n            int y = Y[i];\n\n            if( p == 0 || p == N-1 ) {\n                // Aを使う他ない\n                total -= A[p];\n                A[p] = x;\n                total += x;\n                ans[i] = total;\n                continue;\n            }\n\n            if( A[p] > B[p] ) {\n                ma.remove(A[p] - B[p]);\n                total -= A[p];\n            } else {\n                mb.remove(B[p] - A[p]);\n                total -= B[p];\n            }\n            if( x > y ) {\n                ma.add( x - y );\n                total += x;\n            } else {\n                mb.add( y - x );\n                total += y;\n            }\n            A[p] = x;\n            B[p] = y;\n\n            long r = total;\n            if( ma.size() % 2 == 1 ) {\n                int a = ma.peek();\n                int b = mb.peek();\n\n                if( a > b ) {\n                    r -= b;\n                } else {\n                    r -= a;\n                }\n            }\n            ans[i] = r;\n        }\n\n        return ans;\n    }\n\n    static class Multiset<A> {\n\n        private TreeSet<A> set = new TreeSet<>();\n        private Map<A, Integer> cnt = new HashMap<>();\n        private int size;\n\n        public void add(A a) {\n            size++;\n            if (cnt.containsKey(a)) {\n                cnt.put(a, cnt.get(a) + 1);\n\n            } else {\n                set.add(a);\n                cnt.put(a, 1);\n            }\n        }\n\n        public boolean isEmpty() {\n            return size == 0;\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public A pollLast() {\n            if (isEmpty()) return null;\n\n            size--;\n            A last = set.last();\n            if (cnt.get(last) == 1) {\n                cnt.remove(last);\n                return set.pollLast();\n\n            } else {\n                cnt.put(last, cnt.get(last) - 1);\n                return last;\n            }\n        }\n\n        public A peek() {\n            if (isEmpty()) return null;\n            return set.first();\n        }\n\n        public A poll() {\n            if (isEmpty()) return null;\n\n            size--;\n            A first = set.first();\n            if (cnt.get(first) == 1) {\n                cnt.remove(first);\n                return set.pollFirst();\n\n            } else {\n                cnt.put(first, cnt.get(first) - 1);\n                return first;\n            }\n        }\n\n        public void remove(A a) {\n            size--;\n            if( cnt.get(a) == 1 ) {\n                cnt.remove(a);\n                set.remove(a);\n\n            } else {\n                cnt.put(a, cnt.get(a)-1);\n            }\n        }\n\n        public String toString() {\n            List<A> list = new ArrayList<>();\n            for (A k : set) {\n                for (int i = 0; i < cnt.get(k); i++) {\n                    list.add(k);\n                }\n            }\n            return list.toString();\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    static final long I=1L<<40;\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        int n=Integer.parseInt(scan.next());\n        int q=Integer.parseInt(scan.next());\n        long[]a=new long[2*n],b=new long[2*n];\n        for(int i=0;i<2*n;++i)a[i]=Integer.parseInt(scan.next());\n        for(int i=0;i<2*n;++i)b[i]=Integer.parseInt(scan.next());\n        long t=0;\n        MaxSegmentTree sd=new MaxSegmentTree();\n        MaxSegmentTree sdp=new MaxSegmentTree();\n        long tpos=0;\n        int cpos=0;\n        for(int i=0;i<2*n;++i)t+=a[i];\n        for(int i=1;i<2*n-1;++i){\n            long c=b[i]-a[i];\n            tpos+=Math.max(c,0);\n            if(c>=0)cpos++;\n            sd.update(i,c>=0?-I:c);\n            sdp.update(i,c<0?-I:-c);\n        }\n        for(int i=0;i<q;++i){\n            int p=Integer.parseInt(scan.next())-1;\n            long x=Integer.parseInt(scan.next());\n            long y=Integer.parseInt(scan.next());\n            long c=b[p]-a[p];\n            t-=a[p];\n            if(1<=p<=2*n-2&&c>=0){\n                tpos-=c;\n                cpos--;\n            }\n            a[p]=x;\n            b[p]=y;\n            c=b[p]-a[p];\n            t+=a[p];\n            if(1<=p<=2*n-2&&c>=0){\n                tpos+=c;\n                cpos++;\n            }\n            if(1<=p<=2*n-2) {\n                sd.update(p,c>=0?-I:c);\n                sdp.update(p,c<0?-I:-c);\n            }\n            long ans;\n            if(cpos%2==0)\n                ans=tpos;\n            else{\n                ans=Math.max(tpos+sd.query(1,2*n-1),tpos+sdp.query(1,2*n-1));\n            }\n            System.out.println(ans+t);\n        }\n    }\n}\nclass MaxSegmentTree {\n    static final int SIZE = 1 << 18;\n    static final long INFINITY = (1L << 62) - 1;\n    long[] seg;\n    MaxSegmentTree() {\n\tthis.seg = new long[2 * SIZE];\n    }\n    void update(int x, long value) {\n\tx += SIZE - 1;\n\tthis.seg[x] = value;\n\twhile (x > 0) {\n\t    x = (x - 1) / 2;\n\t    this.seg[x] = Math.max(this.seg[2 * x + 1], this.seg[2 * x + 2]);\n\t}\n    }\n    long query(int l, int r) {\n\tl += SIZE - 1;\n\tr += SIZE - 1;\n        long y = -INFINITY;\n\twhile (l < r) {\n\t    if ((l & 1) == 0) {\n\t\ty = Math.max(y, this.seg[l]);\n\t    }\n\t    if ((r & 1) == 0) {\n\t\ty = Math.max(y, this.seg[r - 1]);\n\t    }\n\t    l /= 2;\n\t    r = (r - 1) / 2;\n\t}\n\treturn y;\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static int N, Q;\n    static int[] A, B;\n    static int[] P, X, Y;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextInt() * 2;\n        Q = sc.nextInt();\n        A = sc.nextIntArray(N);\n        B = sc.nextIntArray(N);\n        P = new int[Q];\n        X = new int[Q];\n        Y = new int[Q];\n        for (int i = 0; i < Q; i++) {\n            P[i] = sc.nextInt()-1;\n            X[i] = sc.nextInt();\n            Y[i] = sc.nextInt();\n        }\n\n        writeLines(solve());\n    }\n\n    static long[] solve() {\n        long total = 0;\n        Multiset<Integer> ma = new Multiset<>();\n        Multiset<Integer> mb = new Multiset<>();\n        for (int i = 0; i < N; i++) {\n            if( i == 0 || i == N-1 ) {\n                total += A[i];\n\n            } else {\n                if( A[i] >= B[i] ) {\n                    ma.add(A[i] - B[i]);\n                    total += A[i];\n                } else {\n                    mb.add(B[i] - A[i]);\n                    total += B[i];\n                }\n            }\n        }\n\n        long[] ans = new long[Q];\n\n        for (int i = 0; i < Q; i++) {\n            int p = P[i];\n            int x = X[i];\n            int y = Y[i];\n\n            if( p == 0 || p == N-1 ) {\n                // Aを使う他ない\n                total -= A[p];\n                A[p] = x;\n                total += x;\n\n            } else {\n                if( A[p] > B[p] ) {\n                    ma.remove(A[p] - B[p]);\n                    total -= A[p];\n                } else {\n                    mb.remove(B[p] - A[p]);\n                    total -= B[p];\n                }\n                if( x > y ) {\n                    ma.add( x - y );\n                    total += x;\n                } else {\n                    mb.add( y - x );\n                    total += y;\n                }\n                A[p] = x;\n                B[p] = y;\n            }\n\n            long r = total;\n            if( ma.size() % 2 == 1 ) {\n                int a = ma.peek();\n                int b = mb.peek();\n\n                if( a > b ) {\n                    r -= b;\n                } else {\n                    r -= a;\n                }\n            }\n            ans[i] = r;\n        }\n\n        return ans;\n    }\n\n    static class Multiset<A> {\n\n        private TreeSet<A> set = new TreeSet<>();\n        private Map<A, Integer> cnt = new HashMap<>();\n        private int size;\n\n        public void add(A a) {\n            size++;\n            if (cnt.containsKey(a)) {\n                cnt.put(a, cnt.get(a) + 1);\n\n            } else {\n                set.add(a);\n                cnt.put(a, 1);\n            }\n        }\n\n        public boolean isEmpty() {\n            return size == 0;\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public A pollLast() {\n            if (isEmpty()) return null;\n\n            size--;\n            A last = set.last();\n            if (cnt.get(last) == 1) {\n                cnt.remove(last);\n                return set.pollLast();\n\n            } else {\n                cnt.put(last, cnt.get(last) - 1);\n                return last;\n            }\n        }\n\n        public A peek() {\n            if (isEmpty()) return null;\n            return set.first();\n        }\n\n        public A poll() {\n            if (isEmpty()) return null;\n\n            size--;\n            A first = set.first();\n            if (cnt.get(first) == 1) {\n                cnt.remove(first);\n                return set.pollFirst();\n\n            } else {\n                cnt.put(first, cnt.get(first) - 1);\n                return first;\n            }\n        }\n\n        public void remove(A a) {\n            size--;\n            if( cnt.get(a) == 1 ) {\n                cnt.remove(a);\n                set.remove(a);\n\n            } else {\n                cnt.put(a, cnt.get(a)-1);\n            }\n        }\n\n        public String toString() {\n            List<A> list = new ArrayList<>();\n            for (A k : set) {\n                for (int i = 0; i < cnt.get(k); i++) {\n                    list.add(k);\n                }\n            }\n            return list.toString();\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    static int mod = 1_000_000_007;\n    // int mod = 998244353;\n    long inf = Long.MAX_VALUE/2;\n\n    void solve(){\n        int n = ni();\n        int q = ni();\n        int[] a = new int[2*n];\n        int[] b = new int[2*n];\n        int S = 0;\n        int T = 0;\n        for(int i = 0; i < 2*n; i++){\n            a[i] = ni();\n            S += a[i];\n        }\n        for(int i = 0; i < 2*n; i++){\n            b[i] = ni();\n            b[i] -= a[i];\n        }\n        TreeSet<Integer> pos = new TreeSet<>();\n        TreeSet<Integer> neg = new TreeSet<>();\n        for(int i = 0; i < 2*n; i++){\n            if(i==0||i==2*n-1) continue;\n            if(b[i]>0){\n                pos.add(b[i]);\n                T += b[i];\n            }\n            else{\n                neg.add(-b[i]);\n            }\n        }\n        for(int i = 0; i < q; i++){\n            int p = ni()-1;\n            int x = ni();\n            int y = ni();\n            if(p!=0 && p!=2*n-1){\n                if(b[p]>0){\n                    pos.remove(b[p]);\n                    T -= b[p];\n                }\n                else{\n                    neg.remove(-b[p]);\n                }\n            }\n            S = S - a[p] + x;\n            b[p] = y-x;\n            a[p] = x;\n            if(p!=0 && p!=2*n-1){\n                if(b[p]>0){\n                    pos.add(b[p]);\n                    T += b[p];\n                }\n                else{\n                    neg.add(-b[p]);\n                }\n            }\n            long ans = 0;\n            if(pos.size()%2==0){\n                ans = S + T;\n            }\n            else{\n                ans = S + Math.max(T - pos.first(), T - neg.first());\n            }\n            out.println(ans);\n        }\n\n    }\n\n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\nimport java.math.*;\n// import java.awt.Point;\n \npublic class Main {\n    InputStream is;\n    PrintWriter out;\n    String INPUT = \"\";\n \n    static int mod = 1_000_000_007;\n    // int mod = 998244353;\n    long inf = Long.MAX_VALUE/2;\n\n    void solve(){\n        int n = ni();\n        int q = ni();\n        long[] a = new long[2*n];\n        long[] b = new long[2*n];\n        long S = 0;\n        long T = 0;\n        for(int i = 0; i < 2*n; i++){\n            a[i] = nl();\n            S += a[i];\n        }\n        for(int i = 0; i < 2*n; i++){\n            b[i] = nl();\n            b[i] -= a[i];\n        }\n        Multiset<Long> pos = new Multiset<>();\n        Multiset<Long> neg = new Multiset<>();\n        for(int i = 0; i < 2*n; i++){\n            if(i==0||i==2*n-1) continue;\n            if(b[i]>0){\n                pos.add(b[i]);\n                T += b[i];\n            }\n            else{\n                neg.add(-b[i]);\n            }\n        }\n        neg.add(inf);\n        for(int i = 0; i < q; i++){\n            int p = ni()-1;\n            long x = nl();\n            long y = nl();\n            if(p!=0 && p!=2*n-1){\n                if(b[p]>0){\n                    pos.remove(b[p]);\n                    T -= b[p];\n                }\n                else{\n                    neg.remove(-b[p]);\n                }\n            }\n            S = S - a[p] + x;\n            b[p] = y-x;\n            a[p] = x;\n            if(p!=0 && p!=2*n-1){\n                if(b[p]>0){\n                    pos.add(b[p]);\n                    T += b[p];\n                }\n                else{\n                    neg.add(-b[p]);\n                }\n            }\n            long ans = 0;\n            if(pos.size()%2==0){\n                ans = S + T;\n            }\n            else{\n                ans = S + Math.max(T - pos.peek(), T - neg.peek());\n            }\n            out.println(ans);\n        }\n\n    }\n\n    static class Multiset<A> {\n\n        private TreeSet<A> set = new TreeSet<>();\n        private Map<A, Integer> cnt = new HashMap<>();\n        private int size;\n\n        public void add(A a) {\n            size++;\n            if (cnt.containsKey(a)) {\n                cnt.put(a, cnt.get(a) + 1);\n\n            } else {\n                set.add(a);\n                cnt.put(a, 1);\n            }\n        }\n\n        public boolean isEmpty() {\n            return size == 0;\n        }\n\n        public int size() {\n            return size;\n        }\n\n        public A pollLast() {\n            if (isEmpty()) return null;\n\n            size--;\n            A last = set.last();\n            if (cnt.get(last) == 1) {\n                cnt.remove(last);\n                return set.pollLast();\n\n            } else {\n                cnt.put(last, cnt.get(last) - 1);\n                return last;\n            }\n        }\n\n        public A peek() {\n            if (isEmpty()) return null;\n            return set.first();\n        }\n\n        public A poll() {\n            if (isEmpty()) return null;\n\n            size--;\n            A first = set.first();\n            if (cnt.get(first) == 1) {\n                cnt.remove(first);\n                return set.pollFirst();\n\n            } else {\n                cnt.put(first, cnt.get(first) - 1);\n                return first;\n            }\n        }\n\n        public void remove(A a) {\n            size--;\n            if( cnt.get(a) == 1 ) {\n                cnt.remove(a);\n                set.remove(a);\n\n            } else {\n                cnt.put(a, cnt.get(a)-1);\n            }\n        }\n\n        public String toString() {\n            List<A> list = new ArrayList<>();\n            for (A k : set) {\n                for (int i = 0; i < cnt.get(k); i++) {\n                    list.add(k);\n                }\n            }\n            return list.toString();\n        }\n    }\n\n\n    void run() throws Exception\n    {\n        is = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n        out = new PrintWriter(System.out);\n        long s = System.currentTimeMillis();\n        solve();\n        out.flush();\n        if(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n    }\n    \n    public static void main(String[] args) throws Exception { new Main().run(); }\n    \n    private byte[] inbuf = new byte[1024];\n    private int lenbuf = 0, ptrbuf = 0;\n    \n    private int readByte()\n    {\n        if(lenbuf == -1)throw new InputMismatchException();\n        if(ptrbuf >= lenbuf){\n            ptrbuf = 0;\n            try { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n            if(lenbuf <= 0)return -1;\n        }\n        return inbuf[ptrbuf++];\n    }\n    \n    private boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n    private int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n    \n    private double nd() { return Double.parseDouble(ns()); }\n    private char nc() { return (char)skip(); }\n    \n    private String ns()\n    {\n        int b = skip();\n        StringBuilder sb = new StringBuilder();\n        while(!(isSpaceChar(b) && b != ' ')){\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    \n    private char[] ns(int n)\n    {\n        char[] buf = new char[n];\n        int b = skip(), p = 0;\n        while(p < n && !(isSpaceChar(b))){\n            buf[p++] = (char)b;\n            b = readByte();\n        }\n        return n == p ? buf : Arrays.copyOf(buf, p);\n    }\n    \n    private char[][] nm(int n, int m)\n    {\n        char[][] map = new char[n][];\n        for(int i = 0;i < n;i++)map[i] = ns(m);\n        return map;\n    }\n    \n    private int[] na(int n)\n    {\n        int[] a = new int[n];\n        for(int i = 0;i < n;i++)a[i] = ni();\n        return a;\n    }\n    \n    private int ni()\n    {\n        int num = 0, b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private long nl()\n    {\n        long num = 0;\n        int b;\n        boolean minus = false;\n        while((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n        if(b == '-'){\n            minus = true;\n            b = readByte();\n        }\n        \n        while(true){\n            if(b >= '0' && b <= '9'){\n                num = num * 10 + (b - '0');\n            }else{\n                return minus ? -num : num;\n            }\n            b = readByte();\n        }\n    }\n    \n    private static void tr(Object... o) { System.out.println(Arrays.deepToString(o)); }\n \n}\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main {\n  static int n;\n  private static void solve() {\n    n = ni() * 2;\n    if (n > 15) {\n      return;\n    }\n    int Q = ni();\n    int[] a = na(n);\n    int[] b = na(n);\n    int[][] query = ntable(Q, 3);\n    \n    \n    for (int[] q : query) {\n      a[q[0] - 1] = q[1];\n      b[q[0] - 1] = q[2];\n\n      long max = 0;\n      for (int i = 0; i < (1 << n); i ++) {\n        if (!check(i)) continue;\n        for (int j = i; j < (1 << n); j ++) {\n          if (!check(j)) continue;\n          \n          long score = 0;\n          for (int k = 0; k < n; k ++) {\n            int b1 = (i >> k) & 1;\n            int b2 = (j >> k) & 1;\n            score += b1 == b2 ? a[k] : b[k];\n          }\n          max = Math.max(max, score);\n        }\n      }\n      System.out.println(max);\n    }\n    \n  }\n  \n  private static boolean check(int x) {\n    int level = 0;\n    for (int i = 0; i < n; i ++) {\n      if (((x >> i) & 1) == 0) {\n        level ++;\n      } else {\n        level --;\n        if (level < 0) {\n          return false;\n        }\n      }\n    }\n    return level == 0;\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Threading;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Diagnostics;\nusing static util;\nusing P = pair<int, int>;\n\nclass Program {\n    static void Main(string[] args) {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        var solver = new Solver(sw);\n        // var t = new Thread(solver.solve, 1 << 26); // 64 MB\n        // t.Start();\n        // t.Join();\n        solver.solve();\n        sw.Flush();\n    }\n}\n\nclass Solver {\n    StreamWriter sw;\n    Scan sc;\n    void Prt(string a) => sw.WriteLine(a);\n    void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    void Prt(params object[] a) => Prt(string.Join(\" \", a));\n    public Solver(StreamWriter sw) {\n        this.sw = sw;\n        this.sc = new Scan();\n    }\n\n    public void solve() {\n        int n, q;\n        sc.Multi(out n, out q);\n        n *= 2;\n        var a = sc.IntArr;\n        var b = sc.IntArr;\n        long sum = 0;\n        foreach (var item in a)\n        {\n            sum += item;\n        }\n        var pls = new SortedSet<P>();\n        var mns = new SortedSet<P>();\n        for (int i = 1; i < n - 1; i++)\n        {\n            int d = b[i] - a[i];\n            if (d >= 0) {\n                pls.Add(new P(d, i));\n                sum += d;\n            }\n            else {\n                mns.Add(new P(-d, i));\n            }\n        }\n        for (int _ = 0; _ < q; _++)\n        {\n            int i, x, y;\n            sc.Multi(out i, out x, out y);\n            --i;\n            if (i > 0 && i < n - 1) {\n                {\n                    int d = b[i] - a[i];\n                    if (d >= 0) {\n                        pls.Remove(new P(d, i));\n                        sum -= d;\n                    }\n                    else {\n                        mns.Remove(new P(-d, i));\n                    }\n                }\n                {\n                    int d = y - x;\n                    if (d >= 0) {\n                        pls.Add(new P(d, i));\n                        sum += d;\n                    }\n                    else {\n                        mns.Add(new P(-d, i));\n                    }\n                }\n            }\n            sum += x - a[i];\n            a[i] = x;\n            b[i] = y;\n            if (pls.Count % 2 == 0) {\n                Prt(sum);\n            }\n            else {\n                Prt(sum - Math.Min(pls.Min.v1, mns.Min.v1));\n            }\n        }\n\n    }\n}\n\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n}\nstatic class util {\n    public static readonly int M = 1000000007;\n    // public static readonly int M = 998244353;\n    public static readonly long LM = 1L << 60;\n    public static readonly double eps = 1e-11;\n    public static void DBG(string a) => Console.Error.WriteLine(a);\n    public static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    public static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    public static void Assert(params bool[] conds) {\n        if (conds.Any(x => !x)) throw new Exception();\n    }\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static int CompareList<T>(IList<T> a, IList<T> b) where T : IComparable<T> {\n        for (int i = 0; i < a.Count && i < b.Count; i++)\n            if (a[i].CompareTo(b[i]) != 0) return a[i].CompareTo(b[i]);\n        return a.Count.CompareTo(b.Count);\n    }\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    static readonly int[] dd = { 0, 1, 0, -1 };\n    // static readonly string dstring = \"RDLU\";\n    public static P[] adjacents(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).ToArray();\n    public static P[] adjacents(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1]))\n                                         .Where(p => inside(p.v1, p.v2, h, w)).ToArray();\n    public static P[] adjacents(this P p) => adjacents(p.v1, p.v2);\n    public static P[] adjacents(this P p, int h, int w) => adjacents(p.v1, p.v2, h, w);\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static T[] inv<T>(this Dictionary<T, int> dic) {\n        var res = new T[dic.Count];\n        foreach (var item in dic) res[item.Value] = item.Key;\n        return res;\n    }\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a) {\n        a = v[0];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b) {\n        a = v[0]; b = v[1];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c) {\n        a = v[0]; b = v[1]; c = v[2];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c, out T d) {\n        a = v[0]; b = v[1]; c = v[2]; d = v[3];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c, out T d, out T e) {\n        a = v[0]; b = v[1]; c = v[2]; d = v[3]; e = v[4];\n    }\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]);\n    }\n    public void Multi<T, U, V>(out T a, out U b, out V c) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]);\n    }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]);\n    }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]);\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass TEST{\n\tstatic void Main(){\n\t\tSol mySol =new Sol();\n\t\tmySol.Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tint NN = 2 * N;\n\t\tlong suma = 0, sumb = 0;\n\t\tint cnta = 0, cntb = 0;\n\t\tvar STa = new SegTreeMin(NN);\n\t\tvar STb = new SegTreeMin(NN);\n\t\t\n\t\tfor(int i=0;i<NN;i++){\n\t\t\tif(i == 0 || i == NN - 1 || A[i] >= B[i]){\n\t\t\t\tsuma += A[i];\n\t\t\t\tcnta++;\n\t\t\t\tif(!(i == 0 || i == NN - 1)) STa.Update(i,A[i] - B[i]);\n\t\t\t} else {\n\t\t\t\tsumb += B[i];\n\t\t\t\tcntb++;\n\t\t\t\tSTb.Update(i,B[i] - A[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong[] ans = new long[Q];\n\t\tfor(int q=0;q<Q;q++){\n\t\t\tint p = P[q];\n\t\t\tlong x = X[q];\n\t\t\tlong y = Y[q];\n\t\t\t\n\t\t\tSTa.Disable(p);\n\t\t\tSTb.Disable(p);\n\t\t\tif(p == 0 || p == NN - 1 || A[p] >= B[p]){\n\t\t\t\tsuma -= A[p];\n\t\t\t\tcnta--;\n\t\t\t} else {\n\t\t\t\tsumb -= B[p];\n\t\t\t\tcntb--;\n\t\t\t}\n\t\t\t\n\t\t\tA[p] = x;\n\t\t\tB[p] = y;\n\t\t\tif(p == 0 || p == NN - 1 || A[p] >= B[p]){\n\t\t\t\tsuma += A[p];\n\t\t\t\tcnta++;\n\t\t\t\tif(!(p == 0 || p == NN - 1)) STa.Update(p,A[p] - B[p]);\n\t\t\t} else {\n\t\t\t\tsumb += B[p];\n\t\t\t\tcntb++;\n\t\t\t\tSTb.Update(p,B[p] - A[p]);\n\t\t\t}\n\t\t\t\n\t\t\tlong maxSum = suma + sumb;\n\t\t\tif(cnta % 2 != 0){\n\t\t\t\tmaxSum -= Math.Min(STa.QueryMin(0,NN),STb.QueryMin(0,NN));\n\t\t\t}\n\t\t\t\n\t\t\tans[q] = maxSum;\n\t\t}\n\t\t\n\t\tConsole.WriteLine(String.Join(\"\\n\",ans));\n\t\t\n\t}\n\tint N,Q;\n\tlong[] A,B;\n\tlong[] X,Y;\n\tint[] P;\n\tpublic Sol(){\n\t\t\n\t\tvar d = ria();\n\t\tN = d[0]; Q = d[1];\n\t\tA = rla();\n\t\tB = rla();\n\t\tP = new int[Q];\n\t\tX = new long[Q];\n\t\tY = new long[Q];\n\t\tfor(int i=0;i<Q;i++){\n\t\t\td = ria();\n\t\t\tP[i] = d[0] - 1;\n\t\t\tX[i] = d[1];\n\t\t\tY[i] = d[2];\n\t\t}\n\t\t\n\t\t\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(char sep=' '){return Console.ReadLine().Split(sep);}\n\tstatic int[] ria(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>int.Parse(e));}\n\tstatic long[] rla(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>long.Parse(e));}\n\tstatic double[] rda(char sep=' '){return Array.ConvertAll(Console.ReadLine().Split(sep),e=>double.Parse(e));}\n}\n\n\nclass SegTreeMin{\n\t//segment Tree \n\t// 0-origin\n\tprotected long[] Data;\t\n\tprotected long Inf;\t\n\tprotected int N;\t\t\n\tprotected int n;\t\t\n\t\n\tpublic SegTreeMin(int n_){\n\t\tN = n_; Inf = (long)1e18;\n\t\tn = 1;\n\t\twhile(n < n_) n *= 2;\n\t\tData = new long[2 * n - 1];\n\t\tfor(int i=0; i < 2 * n - 1; i++) Data[i] = Inf;\n\t}\n\t\n\t//\t   0\n\t//\t 1   2\n\t//\t3 4 5 6\n\tpublic void Update(int k,long a){\n\t\tk+=n-1;\t\n\t\tData[k]=a;\n\t\twhile(k>0){\n\t\t\tk=(k-1)/2;\n\t\t\tData[k]=Math.Min(Data[k*2+1],Data[k*2+2]);\n\t\t}\n\t}\n\t\n\t\n\tpublic long QueryMin(int a, int b){\n\t\treturn Query(a, b, 0, 0, n);\n\t}\n\t//RMQ; [a,b)\n\tpublic long Query(int a,int b,int k,int l,int r){\n\t\tif(r <= a || b <= l) return Inf;\n\t\tif(a <= l && r <= b) return Data[k];\n\t\t\n\t\tvar vl = Query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tvar vr = Query(a ,b, k * 2 + 2, (l + r) / 2, r);\n\t\treturn Math.Min(vl, vr);\n\t}\n\t\n\tpublic void Disable(int k){\n\t\tUpdate(k, Inf);\n\t}\n\tpublic bool IsDisabled(int k){\n\t\treturn Data[k + n - 1] == Inf;\n\t}\n\t\n\tpublic long Min{\n\t\tget{ return Data[0];}\n\t}\n\t\n\t\n\tpublic void Dump(){\n\t\tConsole.WriteLine();\n\t\tint h = 0;\n\t\tint cnt = 0;\n\t\tfor(int i=0;i<Data.Length;i++){\n\t\t\tConsole.Write(\"{0} \", Data[i]);\n\t\t\tcnt++;\n\t\t\tif(cnt == 1 << h){\n\t\t\t\tcnt = 0;\n\t\t\t\th++;\n\t\t\t\tConsole.WriteLine();\n\t\t\t}\n\t\t}\n\t}\n\t\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Threading;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing System.Diagnostics;\nusing static util;\nusing P = pair<int, int>;\n\nclass Program {\n    static void Main(string[] args) {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        var solver = new Solver(sw);\n        // var t = new Thread(solver.solve, 1 << 26); // 64 MB\n        // t.Start();\n        // t.Join();\n        solver.solve();\n        sw.Flush();\n    }\n}\n\nclass Solver {\n    StreamWriter sw;\n    Scan sc;\n    void Prt(string a) => sw.WriteLine(a);\n    void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    void Prt(params object[] a) => Prt(string.Join(\" \", a));\n    public Solver(StreamWriter sw) {\n        this.sw = sw;\n        this.sc = new Scan();\n    }\n\n    public void solve() {\n        int n, q;\n        sc.Multi(out n, out q);\n        n += n - 2;\n        var a = sc.IntArr;\n        var b = sc.IntArr;\n        var sg = new Segtree<pair<long, long>>(n, (x, y) => new pair<long, long>(Math.Max(x.v1 + y.v2, x.v2 + y.v1), Math.Max(x.v1 + y.v1, x.v2 + y.v2)), new pair<long, long>(-LM, 0));\n        int fir = a[0], las = a.Last();\n        for (int i = 0; i < n; i++)\n        {\n            sg.assign(i, new pair<long, long>(a[i + 1], b[i + 1]));\n        }\n        sg.all_update();\n        for (int _ = 0; _ < q; _++)\n        {\n            int i, x, y;\n            sc.Multi(out i, out x, out y);\n            i -= 2;\n            if (i == -1) {\n                fir = x;\n            }\n            else if (i == n) {\n                las = x;\n            }\n            else {\n                sg.update(i, new pair<long, long>(x, y));\n            }\n            Prt(fir + las + sg.run(0, n).v2);\n        }\n\n    }\n}\n\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n}\nstatic class util {\n    public static readonly int M = 1000000007;\n    // public static readonly int M = 998244353;\n    public static readonly long LM = 1L << 60;\n    public static readonly double eps = 1e-11;\n    public static void DBG(string a) => Console.Error.WriteLine(a);\n    public static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    public static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    public static void Assert(params bool[] conds) {\n        if (conds.Any(x => !x)) throw new Exception();\n    }\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static int CompareList<T>(IList<T> a, IList<T> b) where T : IComparable<T> {\n        for (int i = 0; i < a.Count && i < b.Count; i++)\n            if (a[i].CompareTo(b[i]) != 0) return a[i].CompareTo(b[i]);\n        return a.Count.CompareTo(b.Count);\n    }\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    static readonly int[] dd = { 0, 1, 0, -1 };\n    // static readonly string dstring = \"RDLU\";\n    public static P[] adjacents(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).ToArray();\n    public static P[] adjacents(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1]))\n                                         .Where(p => inside(p.v1, p.v2, h, w)).ToArray();\n    public static P[] adjacents(this P p) => adjacents(p.v1, p.v2);\n    public static P[] adjacents(this P p, int h, int w) => adjacents(p.v1, p.v2, h, w);\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static T[] inv<T>(this Dictionary<T, int> dic) {\n        var res = new T[dic.Count];\n        foreach (var item in dic) res[item.Value] = item.Key;\n        return res;\n    }\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a) {\n        a = v[0];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b) {\n        a = v[0]; b = v[1];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c) {\n        a = v[0]; b = v[1]; c = v[2];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c, out T d) {\n        a = v[0]; b = v[1]; c = v[2]; d = v[3];\n    }\n    public static void Deconstruct<T>(this IList<T> v, out T a, out T b, out T c, out T d, out T e) {\n        a = v[0]; b = v[1]; c = v[2]; d = v[3]; e = v[4];\n    }\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]);\n    }\n    public void Multi<T, U, V>(out T a, out U b, out V c) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]);\n    }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]);\n    }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e) {\n        var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]);\n    }\n}\n\nclass Segtree<T> {\n    int n;\n    T[] data;\n    Func<T, T, T> f;\n    T identity;\n\n    public Segtree(int m, Func<T, T, T> f, T identity) {\n        this.f = f;\n        this.identity = identity;\n        n = 1;\n        while (n < m) n <<= 1;\n        data = new T[(n << 1) - 1];\n        for (int i = 0; i < data.Length; i++) data[i] = identity;\n    }\n    public Segtree(int m, IList<T> ini, Func<T, T, T> f, T identity) : this(m, f, identity) {\n        for (int i = 0; i < m; ++i) assign(i, ini[i]);\n        all_update();\n    }\n    public void assign(int j, T x) => data[j + n - 1] = x;\n    public void update(int j, T x) {\n        assign(j, x);\n        update(j);\n    }\n    public void update(int j) {\n        int i = j + n - 1;\n        while (i > 0) {\n            i = i - 1 >> 1;\n            data[i] = f(data[i << 1 | 1], data[i + 1 << 1]);\n        }\n    }\n    public void all_update() {\n        for (int i = n - 2; i >= 0; i--)\n            data[i] = f(data[i << 1 | 1], data[i + 1 << 1]);\n    }\n    public T at(int i) => data[i + n - 1];\n\n    // [s, t)\n    public T run(int s, int t) => run(s, t, 0, 0, n);\n    T run(int s, int t, int k, int l, int r) => r <= s || t <= l ? identity : s <= l && r <= t ? data[k]\n            : f(run(s, t, k << 1 | 1, l, l + r >> 1), run(s, t, k + 1 << 1, l + r >> 1, r));\n}\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"fmt\"\n  \"os\"\n  \"strconv\"\n  \"strings\"\n)\nconst INF = 1<<31-1\n\nfunc main() {\n  input := Input{bufio.NewReaderSize(os.Stdin,10000)}\n  n,q := input.Next2Ints()\n  a := input.NextIntArray()\n  b := input.NextIntArray()\n  tot := int64(a[0]+a[2*n-1])\n  ma := NewMultiSet()\n  mb := NewMultiSet()\n  for i:=1;i<2*n-1;i++ {\n    if a[i] >= b[i] {\n      tot += int64(a[i])\n      ma.Add(a[i]-b[i])\n    } else {\n      tot += int64(b[i])\n      mb.Add(b[i]-a[i])\n    }\n  }\n  for i:=0;i<q;i++ {\n    p,x,y := input.Next3Ints()\n    p--\n    if p == 0 || p == 2*n-1 {\n      tot -= int64(a[p])\n      a[p] = x\n      tot += int64(a[p])\n    } else {\n      if a[p] >= b[p] {\n        tot -= int64(a[p])\n        ma.Remove(a[p]-b[p])\n      } else {\n        tot -= int64(b[p])\n        mb.Remove(b[p]-a[p])\n      }\n      a[p] = x\n      b[p] = y\n      if a[p] >= b[p] {\n        tot += int64(a[p])\n        ma.Add(a[p]-b[p])\n      } else {\n        tot += int64(b[p])\n        mb.Add(b[p]-a[p])\n      }\n    }\n    ex := 0\n    if ma.size%2 == 1 { ex = min(ma.PeekFirst(),mb.PeekFirst()) }\n    fmt.Println(tot-int64(ex))\n  }\n}\nfunc min(n,m int) int {\n  if n < m { return n }\n  return m\n}\n\ntype Entry struct { key,val int }\nfunc NewEntry(key,val int) *Entry { return &Entry{key,val} }\nfunc(e *Entry) CompareTo(o *Entry) int { return e.key-o.key }\ntype Node struct {\n  left,right *Node\n  level int\n  entry *Entry\n}\nfunc NewNode(entry *Entry) *Node { return &Node{nil,nil,1,entry} }\nfunc(n *Node) IsLeaf() bool {\n  return n != nil && n.left == nil && n.right == nil\n}\nfunc(n *Node) Size() int {\n  if n == nil { return 0 }\n  return n.left.Size()+n.right.Size()+1\n}\nfunc(n *Node) Output() {\n  if n == nil { return }\n  n.left.Output()\n  fmt.Print(n.entry,\" \")\n  n.right.Output()\n}\nfunc(n *Node) Skew() *Node {\n  if n == nil || n.left == nil || n.left.level != n.level { return n }\n  l := n.left\n  n.left = l.right\n  l.right = n\n  return l\n}\nfunc(n *Node) Split() *Node {\n  if n == nil || n.right == nil || n.right.right == nil ||\n  n.right.right.level != n.level { return n }\n  r := n.right\n  n.right = r.left\n  r.left = n\n  r.level++\n  return r\n}\nfunc(n *Node) Insert(entry *Entry) *Node {\n  if n == nil { return NewNode(entry) }\n  if entry.CompareTo(n.entry) < 0 {\n    n.left = n.left.Insert(entry)\n  } else if entry.CompareTo(n.entry) > 0 {\n    n.right = n.right.Insert(entry)\n  } else {\n    n.entry = entry\n  }\n  n = n.Skew()\n  n = n.Split()\n  return n\n}\nfunc(n *Node) Delete(entry *Entry) *Node {\n  if n == nil { return n }\n  if entry.CompareTo(n.entry) < 0 {\n    n.left = n.left.Delete(entry)\n  } else if entry.CompareTo(n.entry) > 0 {\n    n.right = n.right.Delete(entry)\n  } else {\n    if n.IsLeaf() {\n      return nil\n    } else if n.left == nil {\n      tmp := n.right\n      for tmp.left != nil { tmp = tmp.left }\n      n.right = n.right.Delete(tmp.entry)\n      n.entry = tmp.entry\n    } else {\n      tmp := n.left\n      for tmp.right != nil { tmp = tmp.right }\n      n.left = n.left.Delete(tmp.entry)\n      n.entry = tmp.entry\n    }\n  }\n  n = n.DecreaseLevel()\n  n = n.Skew()\n  n.right = n.right.Skew()\n  if n.right != nil { n.right.right = n.right.right.Skew() }\n  n = n.Split()\n  n.right = n.right.Split()\n  return n\n}\nfunc(n *Node) DecreaseLevel() *Node {\n  level := 0\n  if n.left != nil { level = n.left.level }\n  if n.right != nil && level > n.right.level { level = n.right.level }\n  level++\n  if n.level > level {\n    n.level = level\n    if n.right != nil && n.right.level > level { n.right.level = level }\n  }\n  return n\n}\ntype TreeMap struct { root *Node }\nfunc NewTreeMap() *TreeMap { return &TreeMap{nil} }\nfunc(m *TreeMap) Size() int { return m.root.Size() }\nfunc(m *TreeMap) PutEntry(entry *Entry) { m.root = m.root.Insert(entry) }\nfunc(m *TreeMap) RemoveEntry(entry *Entry) { m.root = m.root.Delete(entry) }\nfunc(m *TreeMap) GetEntry(entry *Entry) *Entry {\n  n := m.root\n  for n != nil {\n    if entry.CompareTo(n.entry) < 0 {\n      n = n.left\n    } else if entry.CompareTo(n.entry) > 0 {\n      n = n.right\n    } else {\n      return n.entry\n    }\n  }\n  return nil\n}\nfunc(m *TreeMap) ContainsEntry(entry *Entry) bool {\n  n := m.root\n  for n != nil {\n    if entry.CompareTo(n.entry) < 0 {\n      n = n.left\n    } else if entry.CompareTo(n.entry) > 0 {\n      n = n.right\n    } else {\n      return true\n    }\n  }\n  return false\n}\nfunc(m *TreeMap) FirstEntry() *Entry {\n  n := m.root\n  if n == nil { return nil }\n  for n.left != nil { n = n.left }\n  return n.entry\n}\nfunc(m *TreeMap) LastEntry() *Entry {\n  n := m.root\n  if n == nil { return nil }\n  for n.right != nil { n = n.right }\n  return n.entry\n}\nfunc(m *TreeMap) PollFirstEntry() *Entry {\n  entry := m.FirstEntry()\n  m.root.Delete(entry)\n  return entry\n}\nfunc(m *TreeMap) PollLastEntry() *Entry {\n  entry := m.LastEntry()\n  m.root.Delete(entry)\n  return entry\n}\nfunc(m *TreeMap) Put(key,val int) { m.PutEntry(NewEntry(key,val)) }\nfunc(m *TreeMap) Remove(key int) { m.RemoveEntry(NewEntry(key,0)) }\nfunc(m *TreeMap) Get(key int) int { return m.GetEntry(NewEntry(key,0)).val }\nfunc(m *TreeMap) Contains(key int) bool { return m.ContainsEntry(NewEntry(key,0)) }\nfunc(m *TreeMap) First() (int,int) { e := m.FirstEntry();return e.key,e.val }\nfunc(m *TreeMap) Last() (int,int) { e := m.LastEntry();return e.key,e.val }\nfunc(m *TreeMap) PollFirst() (int,int) { e := m.PollFirstEntry();return e.key,e.val }\nfunc(m *TreeMap) PollLast() (int,int) { e := m.PollLastEntry();return e.key,e.val }\ntype MultiSet struct {\n  tm *TreeMap\n  cnt map[int]int\n  size int\n}\nfunc NewMultiSet() *MultiSet { return &MultiSet{NewTreeMap(),make(map[int]int),0} }\nfunc(m *MultiSet) Add(e int) {\n  m.size++\n  if _,ok := m.cnt[e];!ok { m.tm.Put(e,0) }\n  m.cnt[e]++\n}\nfunc(m *MultiSet) IsEmpty() bool { return m.size == 0 }\nfunc(m *MultiSet) PollFirst() int {\n  if m.IsEmpty() { return INF }\n  m.size--\n  first := m.tm.FirstEntry().key\n  if m.cnt[first] == 1 {\n    delete(m.cnt,first)\n    return m.tm.PollFirstEntry().key\n  } else {\n    m.cnt[first]--\n    return first\n  }\n}\nfunc(m *MultiSet) PollLast() int {\n  if m.IsEmpty() { return INF }\n  m.size--\n  last := m.tm.LastEntry().key\n  if m.cnt[last] == 1 {\n    delete(m.cnt,last)\n    return m.tm.PollLastEntry().key\n  } else {\n    m.cnt[last]--\n    return last\n  }\n}\nfunc(m *MultiSet) Remove(e int) {\n  if _,ok := m.cnt[e];!ok { return }\n  m.size--\n  if m.cnt[e] == 1 {\n    delete(m.cnt,e)\n    m.tm.Remove(e)\n  } else {\n    m.cnt[e]--\n  }\n}\nfunc(m *MultiSet) PeekFirst() int {\n  if m.IsEmpty() { return INF }\n  return m.tm.FirstEntry().key\n}\nfunc(m *MultiSet) PeekLast() int {\n  if m.IsEmpty() { return INF }\n  return m.tm.LastEntry().key\n}\n\ntype Input struct { reader *bufio.Reader }\nfunc(i *Input) NextLine() string {\n  var buffer []byte\n  for {\n    line,isPrefix,err := i.reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer,line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc(i *Input) Next2Ints() (int,int) {\n  s := strings.Fields(i.NextLine())\n  x,_ := strconv.Atoi(s[0])\n  y,_ := strconv.Atoi(s[1])\n  return x,y\n}\nfunc(i *Input) Next3Ints() (int,int,int) {\n  s := strings.Fields(i.NextLine())\n  x,_ := strconv.Atoi(s[0])\n  y,_ := strconv.Atoi(s[1])\n  z,_ := strconv.Atoi(s[2])\n  return x,y,z\n}\nfunc(i *Input) NextIntArray() []int {\n  s := strings.Fields(i.NextLine())\n  a := make([]int,len(s))\n  for i:=0;i<len(s);i++ { a[i],_ = strconv.Atoi(s[i]) }\n  return a\n}"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"D\"\n    dependency \"dcomp\" version=\">=0.7.4\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dcomp.foundation, dcomp.scanner;\n\nimport std.container.rbtree;\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n\n    int n, q;\n    sc.read(n, q); n*=2;\n    long[] a, b;\n    sc.read(a, b);\n\n    auto tr1 = new RedBlackTree!(long, \"a<b\", true);\n    auto tr2 = new RedBlackTree!(long, \"a<b\", true);\n    \n    long sm = a[0] + a[$-1];\n    foreach (i; 1..n-1) {\n        sm += max(a[i], b[i]);\n        if (a[i] >= b[i]) {\n            tr1.insert(a[i] - b[i]);\n        } else {\n            tr2.insert(b[i] - a[i]);\n        }\n    }\n    \n    foreach (i; 0..q) {\n        int p; long x, y;\n        sc.read(p, x, y); p--;\n        if (p == 0 || p == n-1) {\n            sm -= a[p];\n        } else {\n            sm -= max(a[p], b[p]);\n            if (a[p] >= b[p]) {\n                tr1.removeKey(a[p] - b[p]);\n            } else {\n                tr2.removeKey(b[p] - a[p]);\n            }\n        }\n        a[p] = x; b[p] = y;\n        if (p == 0 || p == n-1) {\n            sm += a[p];\n        } else {\n            sm += max(a[p], b[p]);\n            if (a[p] >= b[p]) {\n                tr1.insert(a[p] - b[p]);\n            } else {\n                tr2.insert(b[p] - a[p]);\n            }\n        }\n//        writeln(\"fi \", sm, \" \", tr1, \" \", tr2);\n        long sm2 = sm;\n        if (tr1.length % 2) {\n            sm2 -= min(tr1.front(), tr2.front());\n        }\n        writeln(sm2);\n    }\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n\nimport core.bitop : popcnt;\nstatic if (!__traits(compiles, popcnt(ulong.max))) {\n    public import core.bitop : popcnt;\n    int popcnt(ulong v) {\n        return popcnt(cast(uint)(v)) + popcnt(cast(uint)(v>>32));\n    }\n}\n\nbool poppar(ulong v) {\n    v^=v>>1;\n    v^=v>>2;\n    v&=0x1111111111111111UL;\n    v*=0x1111111111111111UL;\n    return ((v>>60) & 1) != 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\n// import dcomp.array;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                FastAppender!(E[]) buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/array.d */\n// module dcomp.array;\n\n \nT[N] fixed(T, size_t N)(T[N] a) {return a;}\n\n \n \n\n \nstruct FastAppender(A, size_t MIN = 4) {\n    import std.algorithm : max;\n    import std.conv;\n    import std.range.primitives : ElementEncodingType;\n    import core.stdc.string : memcpy;\n\n    private alias T = ElementEncodingType!A;\n    private T* _data;\n    private uint len, cap;\n     \n    @property size_t length() const {return len;}\n    bool empty() const { return len == 0; }\n     \n    void reserve(size_t nlen) {\n        import core.memory : GC;\n        if (nlen <= cap) return;\n        \n        void* nx = GC.malloc(nlen * T.sizeof);\n\n        cap = nlen.to!uint;\n        if (len) memcpy(nx, _data, len * T.sizeof);\n        _data = cast(T*)(nx);\n    }\n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }\n     \n    void opOpAssign(string op : \"~\")(T item) {\n        if (len == cap) {\n            reserve(max(MIN, cap*2));\n        }\n        _data[len++] = item;\n    }\n     \n    void insertBack(T item) {\n        this ~= item;\n    }\n     \n    void removeBack() {\n        len--;\n    }\n     \n    void clear() {\n        len = 0;\n    }\n    ref inout(T) back() inout { assert(len); return _data[len-1]; }\n    ref inout(T) opIndex(size_t i) inout { return _data[i]; }\n     \n    T[] data() {\n        return (_data) ? _data[0..len] : null;\n    }\n}\n\n \n \n\n/*\nThis source code generated by dcomp and include dcomp's source code.\ndcomp's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dcomp)\ndcomp's License: MIT License(https://github.com/yosupo06/dcomp/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"D\"\n    dependency \"dcomp\" version=\">=0.7.4\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\n// import dcomp.foundation, dcomp.scanner;\n\n// import dcomp.tree.avl, dcomp.tree.primitive;\nimport std.container.rbtree;\n\nint main() {\n    Scanner sc = new Scanner(stdin);\n\n    int n, q;\n    sc.read(n, q); n*=2;\n    long[] a, b;\n    sc.read(a, b);\n\n//    auto tr1 = new RedBlackTree!(long, \"a<b\", true);\n//    auto tr2 = new RedBlackTree!(long, \"a<b\", true);\n    auto tr1 = Tree!(AVLNode, long, max, long.min)();\n    auto tr2 = Tree!(AVLNode, long, max, long.min)();\n    void Ins(TR)(ref TR tr, long x) {\n        tr.insert(tr.binSearchLeft!(y => x <= y)(0, tr.length), x);\n    }\n    void Rem(TR)(ref TR tr, long x) {\n        tr.removeAt(tr.binSearchLeft!(y => x <= y)(0, tr.length));\n    }\n    long sm = a[0] + a[$-1];\n    foreach (i; 1..n-1) {\n        sm += max(a[i], b[i]);\n        if (a[i] >= b[i]) {\n//            tr1.insert(a[i] - b[i]);\n            Ins(tr1, a[i] - b[i]);\n        } else {\n//            tr2.insert(b[i] - a[i]);\n            Ins(tr2, b[i] - a[i]);\n        }\n    }\n    \n    foreach (i; 0..q) {\n        int p; long x, y;\n        sc.read(p, x, y); p--;\n        if (p == 0 || p == n-1) {\n            sm -= a[p];\n        } else {\n            sm -= max(a[p], b[p]);\n            if (a[p] >= b[p]) {\n//                tr1.removeKey(a[p] - b[p]);\n                Rem(tr1, a[p] - b[p]);\n            } else {\n//                tr2.removeKey(b[p] - a[p]);\n                Rem(tr2, b[p] - a[p]);\n            }\n        }\n        a[p] = x; b[p] = y;\n        if (p == 0 || p == n-1) {\n            sm += a[p];\n        } else {\n            sm += max(a[p], b[p]);\n            if (a[p] >= b[p]) {\n                // tr1.insert(a[p] - b[p]);\n                Ins(tr1, a[p] - b[p]);\n            } else {\n//                tr2.insert(b[p] - a[p]);\n                Ins(tr2, b[p] - a[p]);\n            }\n        }\n//        writeln(\"fi \", sm, \" \", tr1, \" \", tr2);\n        long sm2 = sm;\n        if (tr1.length % 2) {\n            sm2 -= min(tr1[0], tr2[0]);\n        }\n        writeln(sm2);\n    }\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/tree/avl.d */\n// module dcomp.tree.avl;\n\n// import dcomp.tree.primitive;\n\nstruct AVLNode(T, alias op, T e) {\n    alias Node = typeof(this);\n    import std.algorithm : max;\n    import std.math : abs;\n    Node*[2] ch;\n    uint length; int lv;\n    T v;\n    this(in T v) {\n        length = 1;\n        this.v = v;\n    }\n    this(Node* l, Node* r) {\n        ch = [l, r];\n        update();\n    }\n    void update() {\n        length = ch[0].length + ch[1].length;\n        lv = max(ch[0].lv, ch[1].lv) + 1;\n        v = op(ch[0].v, ch[1].v);\n    }\n     \n     \n    Node* rot(uint type) {\n        assert(type == 0 || type == 1);\n        auto buf = ch[type];\n        ch[type] = buf.ch[1-type];\n        buf.ch[1-type] = &this;\n        update();\n        buf.update();\n        return buf;\n    }\n    Node* insert(uint k, in T v) {\n        assert(0 <= k && k <= length);\n        if (length == 1) {\n            if (k == 0) {\n                return new Node(new Node(v), &this);\n            } else {\n                return new Node(&this, new Node(v));\n            }\n        }\n\n        int type;\n        if (k < ch[0].length) {\n            ch[0] = ch[0].insert(k, v);\n            type = 0;\n        } else {\n            ch[1] = ch[1].insert(k-ch[0].length, v);\n            type = 1;\n        }\n        update();\n        if (abs(ch[0].lv - ch[1].lv) <= 1) return &this;\n        if (lv - ch[type].ch[1-type].lv == 2 && lv - ch[type].ch[type].lv == 3) {\n            ch[type] = ch[type].rot(1-type);\n            update();\n        }\n        return rot(type);\n    }\n    Node* removeAt(uint k) {\n        assert(0 <= k && k < length);\n        if (length == 1) {\n            return null;\n        }\n        int type;\n        if (k < ch[0].length) {\n            type = 0;\n            ch[0] = ch[0].removeAt(k);\n            if (ch[0] is null) return ch[1];\n        } else {\n            type = 1;\n            ch[1] = ch[1].removeAt(k-ch[0].length);\n            if (ch[1] is null) return ch[0];\n        }\n        update();\n        if (abs(ch[0].lv - ch[1].lv) <= 1) return &this;\n        if (lv - ch[1-type].ch[type].lv == 2 && lv - ch[1-type].ch[1-type].lv == 3) {\n            ch[1-type] = ch[1-type].rot(type);\n            update();\n        }\n        return rot(1-type);\n    }\n     \n    const(T) at(uint k) const {\n        assert(0 <= k && k < length);\n        if (length == 1) return v;\n        if (k < ch[0].length) return ch[0].at(k);\n        return ch[1].at(k-ch[0].length);\n    }\n    const(T) sum(int a, int b) const {\n        if (b <= 0 || length <= a) return e;\n        if (a <= 0 && length <= b) return v;\n        return op(ch[0].sum(a, b), ch[1].sum(a - ch[0].length, b - ch[0].length));\n    }\n}\n\nimport std.traits;\n\nint binSearch(bool rev, alias pred, N)(N* r, int a, int b)\nif (isInstanceOf!(AVLNode, N)) {\n    alias args = TemplateArgsOf!N;\n    alias opTT = args[1];\n    auto x = args[2];\n    with (r) {\n        static if (!rev) {\n             \n            if (pred(x)) return a-1;\n            int pos = a;\n            void f(N* n, int a, int b, int offset) {\n                if (b <= offset || offset + n.length <= a) return;\n                if (a <= offset && offset + n.length <= b && !pred(opTT(x, n.v))) {\n                    x = opTT(x, n.v);\n                    pos = offset + n.length;\n                    return;\n                }\n                if (n.length == 1) return;\n                f(n.ch[0], a, b, offset);\n                if (pos >= offset + n.ch[0].length) {\n                    f(n.ch[1], a, b, offset + n.ch[0].length);\n                }\n            }\n\n            f(r, a, b, 0);\n            return pos;\n        } else {\n             \n\n            if (pred(x)) return b;\n            int pos = b-1;\n            void f(N* n, int a, int b, int offset) {\n                if (b <= offset || offset + n.length <= a) return;\n                if (a <= offset && offset + n.length <= b && !pred(opTT(n.v, x))) {\n                    x = opTT(n.v, x);\n                    pos = offset - 1;\n                    return;\n                }\n                if (n.length == 1) return;\n                f(n.ch[1], a, b, offset + n.ch[0].length);\n                if (pos < offset + n.ch[0].length) {\n                    f(n.ch[0], a, b, offset);\n                }\n            }\n\n            f(r, a, b, 0);\n            return pos;\n        }\n    }\n}\n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n \nstatic if (__VERSION__ <= 2070) {\n    /*\n    Copied by https://github.com/dlang/phobos/blob/master/std/algorithm/iteration.d\n    Copyright: Andrei Alexandrescu 2008-.\n    License: $(HTTP boost.org/LICENSE_1_0.txt, Boost License 1.0).\n    */\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n     \n}\n\nimport core.bitop : popcnt;\nstatic if (!__traits(compiles, popcnt(ulong.max))) {\n    public import core.bitop : popcnt;\n    int popcnt(ulong v) {\n        return popcnt(cast(uint)(v)) + popcnt(cast(uint)(v>>32));\n    }\n}\n\nbool poppar(ulong v) {\n    v^=v>>1;\n    v^=v>>2;\n    v&=0x1111111111111111UL;\n    v*=0x1111111111111111UL;\n    return ((v>>60) & 1) != 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\n// import dcomp.array;\n\n \nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succW() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (!line.empty && line.front.isWhite) {\n            line.popFront;\n        }\n        return !line.empty;\n    }\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            line = lineBuf[];\n            f.readln(line);\n            if (!line.length) return false;\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                 \n                 \n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else static if (isStaticArray!T) {\n                foreach (i; 0..T.length) {\n                    bool f = succW();\n                    assert(f);\n                    x[i] = line.parse!E;\n                }\n            } else {\n                FastAppender!(E[]) buf;\n                while (succW()) {\n                    buf ~= line.parse!E;\n                }\n                x = buf.data;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n \n \n\n \n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/tree/primitive.d */\n// module dcomp.tree.primitive;\n\nstruct Tree(alias E, T, alias opTT, T _e) {\n    immutable static T e = _e;\n    import std.functional : binaryFun;\n    import std.conv : to;\n    import std.math : abs;    \n    alias Engine = E!(T, binaryFun!opTT, e);\n    Engine* tr;\n\n    this(T v) {\n        tr = new Engine(v);\n    }\n\n    @property size_t length() const { return (!tr ? 0 : tr.length); }\n    alias opDollar = length;\n    \n    void insert(size_t k, in T v) {\n        assert(0 <= k && k <= length);\n        if (tr is null) {\n            tr = new Engine(v);\n            return;\n        }\n        tr = tr.insert(k.to!int, v);\n    }\n    void removeAt(size_t k) {\n        assert(0 <= k && k < length);\n        tr = tr.removeAt(k.to!int);\n    }\n    const(T) opIndex(size_t k) {\n        assert(0 <= k && k < length);\n        return tr.at(k.to!int);\n    }\n    struct Range {\n        Tree* eng;\n        size_t start, end;\n        @property T sum() {\n            return eng.tr.sum(start.to!uint, end.to!uint);\n        }\n    }\n    size_t[2] opSlice(size_t dim)(size_t start, size_t end) {\n        assert(0 <= start && start <= end && end <= length());\n        return [start, end];\n    }\n    Range opIndex(size_t[2] rng) {\n        return Range(&this, rng[0].to!uint, rng[1].to!uint);\n    }\n    string toString() {\n         \n        import std.range : iota;\n        import std.algorithm : map;\n        import std.conv : to;\n        import std.string : join;\n        string s;\n        s ~= \"Tree(\";\n        s ~= iota(length).map!(i => this[i]).to!string;\n        s ~= \")\";\n        return s;\n    }\n}\n\nimport std.traits : isInstanceOf;\nimport std.conv : to;\n\nptrdiff_t binSearchLeft(alias pred, T)(T t, ptrdiff_t a, ptrdiff_t b)\nif(isInstanceOf!(Tree, T)) {\n    if (t.tr is null) {\n        if (pred(T.e)) return -1;\n        return 0;\n    }\n//     import dcomp.tree.avl;\n    return t.tr.binSearch!(false, pred)(a.to!int, b.to!int);\n}\n\nptrdiff_t binSearchRight(alias pred, T)(T t, ptrdiff_t a, ptrdiff_t b)\nif(isInstanceOf!(Tree, T)) {\n    if (t.tr is null) {\n        if (pred(T.e)) return 0;\n        return -1;\n    }\n//     import dcomp.tree.avl;\n    return t.tr.binSearch!(true, pred)(a.to!int, b.to!int);\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/array.d */\n// module dcomp.array;\n\n \nT[N] fixed(T, size_t N)(T[N] a) {return a;}\n\n \n \n\n \nstruct FastAppender(A, size_t MIN = 4) {\n    import std.algorithm : max;\n    import std.conv;\n    import std.range.primitives : ElementEncodingType;\n    import core.stdc.string : memcpy;\n\n    private alias T = ElementEncodingType!A;\n    private T* _data;\n    private uint len, cap;\n     \n    @property size_t length() const {return len;}\n    bool empty() const { return len == 0; }\n     \n    void reserve(size_t nlen) {\n        import core.memory : GC;\n        if (nlen <= cap) return;\n        \n        void* nx = GC.malloc(nlen * T.sizeof);\n\n        cap = nlen.to!uint;\n        if (len) memcpy(nx, _data, len * T.sizeof);\n        _data = cast(T*)(nx);\n    }\n    void free() {\n        import core.memory : GC;\n        GC.free(_data);\n    }\n     \n    void opOpAssign(string op : \"~\")(T item) {\n        if (len == cap) {\n            reserve(max(MIN, cap*2));\n        }\n        _data[len++] = item;\n    }\n     \n    void insertBack(T item) {\n        this ~= item;\n    }\n     \n    void removeBack() {\n        len--;\n    }\n     \n    void clear() {\n        len = 0;\n    }\n    ref inout(T) back() inout { assert(len); return _data[len-1]; }\n    ref inout(T) opIndex(size_t i) inout { return _data[i]; }\n     \n    T[] data() {\n        return (_data) ? _data[0..len] : null;\n    }\n}\n\n \n \n\n/*\nThis source code generated by dcomp and include dcomp's source code.\ndcomp's Copyright: Copyright (c) 2016- Kohei Morita. (https://github.com/yosupo06/dcomp)\ndcomp's License: MIT License(https://github.com/yosupo06/dcomp/blob/master/LICENSE.txt)\n*/\n"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.array, std.string, std.conv, std.algorithm;\nimport std.typecons, std.range, std.random, std.math, std.container;\nimport std.numeric, std.bigint, core.bitop, std.bitmanip;\n\nvoid main() {\n    auto s = readln.split.map!(to!int);\n    auto N = s[0] * 2;\n    auto Q = s[1];\n    auto A = readln.split.map!(to!long).array;\n    auto B = readln.split.map!(to!long).array;\n    \n    auto rbt = new RedBlackTree!(long, \"a > b\", true)();\n    long sm = 0;\n    int cnt = 0;\n    foreach (i; 0..N) {\n        if (i == 0 || i == N-1) {\n            sm += A[i];\n        } else if (A[i] >= B[i]) {\n            sm += A[i];\n            rbt.insert(B[i] - A[i]);\n        } else {\n            sm += B[i];\n            cnt += 1;\n            rbt.insert(A[i] - B[i]);\n        }\n    }\n\n    while (Q--) {\n        s = readln.split.map!(to!int);\n        auto p = s[0] - 1;\n        auto x = s[1].to!long;\n        auto y = s[2].to!long;\n        if (p == 0 || p == N - 1) {\n            sm = sm - A[p] + x;\n            A[p] = x;\n            B[p] = y;\n        } else {\n            sm = sm - max(A[p], B[p]) + max(x, y);\n            rbt.removeKey(-abs(A[p] - B[p]));\n            rbt.insert(-abs(x - y));\n            if (A[p] < B[p]) cnt -= 1;\n            if (x < y) cnt += 1;\n            A[p] = x;\n            B[p] = y;\n        }\n        writeln(cnt % 2 ? sm + rbt.front : sm);\n    }\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int MAXN = 101010 * 3;\nstruct node{\n    int l, r, len;\n    int stu;\n    node(bool s = true, int lc = 0, int rc = 0, int l = 0): stu(s), l(lc), r(rc), len(l){}\n}tree[MAXN * 4], poin[MAXN];\n\nstruct question{\n    int l, r;\n    bool stu;\n    question(int lc = 0, int rc = 0, bool s = true): l(lc), r(rc), stu(s){}\n}que[MAXN];\nint n, q, tem, lef;\nint arr[MAXN], len;\n\nvoid build(int o, int l, int r){\n    if(l == r){\n        tree[o] = poin[l];\n        return ;\n    }\n    int m = (l + r) >> 1;\n    build(o<<1, l, m);\n    build(o*2+1, m+1, r);\n    poin[o].l = poin[o*2].l;\n    poin[o].r = poin[o*2+1].r;\n    poin[o].len = poin[o].r - poin[o].l;\n}\n\nvoid puin(){\n    scanf(\"%d%d\", &n, &q);\n    for(int i = 1; i <= q; i ++){\n        scanf(\"%d%d%d\", &que[i].l, &que[i].r, &tem);\n        que[i].stu = tem - 1;\n        arr[i*2-1] = que[i].l - 1;\n        arr[i*2] = que[i].r;\n    }\n    arr[q*2+1] = n;\n    sort(arr+1, arr+1+2*q+1);\n    int len = unique(arr, arr+1+2*q+1) - arr - 1;\n    for(int i = 1; i <= len; i ++){\n        poin[i].l = arr[i-1];\n        poin[i].r = arr[i];\n        poin[i].len = arr[i] - arr[i-1];\n    }\n    \n    build(1, 1, len);\n}\n\nint ql, qr, stu;\n\nvoid pushdown(int o, int l, int r){\n    int lc = o*2, rc = o*2 + 1;\n    if(tree[o].stu >= 0){\n        tree[lc].stu = tree[rc].stu = tree[o].stu;\n        tree[o].stu = -1;\n    }\n}\n\nvoid maintain(int o, int l, int r){\n    if(tree[o].stu != -1){\n        tree[o].len = (tree[o].r - tree[o].l) * tree[o].stu;\n        return ;\n    }\n    int lc = o*2, rc = o*2+1;\n    tree[o].len = tree[lc].len + tree[rc].len;\n    return ;\n}\n\nvoid deal(int o, int l, int r){\n    if(ql <= tree[o].l && tree[o].r <= qr){\n        tree[o].stu = stu;\n        tree[o].len = (tree[o].r - tree[o].l) * tree[o].stu;\n        return ;\n    }\n    pushdown(o, l, r);\n    int m = (l + r) >> 1;\n    int len = 0, lc = o*2, rc = o*2+1;\n    if(tree[m].l < qr)\n         deal(lc, l, m);\n    else\n        maintain(lc, l, m);\n    if(ql <= tree[m].r)\n        deal(rc, m+1, r);\n    else\n        maintain(rc, m+1, r);\n    maintain(o, l, r);\n    //return tree[o].len;\n}\n\nvoid proc(){\n    for(int i = 1; i <= q; i ++){\n        ql = que[i].l - 1;\n        qr = que[i].r;\n        stu = que[i].stu - 1;\n        //printf(\"test: %d %d %d\\n\", ql, qr, stu);\n        deal(1, 1, len);\n        printf(\"%d\\n\", tree[1].len);\n    }\n}\n\nint main(){\n    puin();\n    proc();\n    return 0;\n}"
  },
  {
    "language": "Nim",
    "code": "import strutils\nimport sequtils\nimport algorithm\nimport math\nimport queues\nimport tables\nimport sets\nimport logging\nimport future\n\nconst INF* = int(1e18 + 373)\n\nproc readLine*(): string =\n  stdin.readLine()\nproc readSeq*(): seq[string] =\n  readLine().strip().split()\nproc readSeq*(n: Natural): seq[string] =\n  result = newSeq[string](n)\n  for i in 0..<n:\n    result[i] = readLine().strip()\nproc readInt1*(): int =\n  readSeq().map(parseInt)[0]\nproc readInt2*(): (int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1])\nproc readInt3*(): (int, int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1], a[2])\nproc readInt4*(): (int, int, int, int) =\n  let a = readSeq().map(parseInt)\n  return (a[0], a[1], a[2], a[3])\ntype seq2*[T] = seq[seq[T]]\nproc newSeq2*[T](n1, n2: Natural): seq2[T] =\n  newSeqWith(n1, newSeq[T](n2))\ntype seq3*[T] = seq[seq[seq[T]]]\nproc newSeq3*[T](n1, n2, n3: Natural): seq3[T] =\n  newSeqWith(n1, newSeqWith(n2, newSeq[T](n3)))\n\n#------------------------------------------------------------------------------#\ntype Op2[T] = proc(a, b: T): T\ntype SegmentTree[T] = tuple[ n: int, a: seq[T], e: T, f: Op2[T] ]\n\nproc initSegmentTree[T](n: int, e: T, f: Op2[T]): SegmentTree[T] =\n    var m = 1\n    while m < n:\n        m *= 2\n\n    var a = newSeq[T](2 * m)\n    a.fill(e)\n    return (m, a, e, f)\n\nproc update[T](this: var SegmentTree[T], i: int, x: T) =\n    this.a[this.n + i] = x\n    var j = (this.n + i) div 2\n    while j > 0:\n        this.a[j] = this.f(this.a[j * 2], this.a[j * 2 + 1])\n        j = j div 2\n\nproc query[T](this: SegmentTree[T], s, t, i, ll, hh: int): T =\n    if t <= ll or hh <= s:\n        return this.e\n    if s <= ll and hh <= t:\n        return this.a[i]\n\n    let m = (ll + hh) div 2\n    let vl = this.query(s, t, i * 2, ll, m)\n    let vh = this.query(s, t, i * 2 + 1, m, hh)\n    return this.f(vl, vh)\n\nproc query[T](this: SegmentTree[T], s, t: int): T = query(this, s, t, 1, 0, this.n)\n\n#------------------------------------------------------------------------------#\n\nproc main() =\n  let (n, q) = readInt2()\n  var a = readSeq().map(parseInt)\n  var b = readSeq().map(parseInt)\n\n  var qs = newSeq[(int, int, int)](q)\n  for i in 0..<q:\n    let (p, x, y) = readInt3()\n    qs[i] = (p - 1, x, y)\n\n  let n2 = n + n\n  var segtree = initSegmentTree[int](n2, INF, (x1: int, x2: int) => min(x1, x2))\n  for i in 1..<n2 - 1:\n    segtree.update(i, abs(b[i] - a[i]))\n\n  var midSum = 0\n  var ltCnt = 0\n  var eqCnt = 0\n  var gtCnt = 0\n  for i in 1..<n2 - 1:\n    midSum += max(a[i], b[i])\n    if b[i] - a[i] > 0:\n      gtCnt += 1\n    if b[i] - a[i] == 0:\n      eqCnt += 1\n    if b[i] - a[i] < 0:\n      ltCnt += 1\n\n  for i in 0..<q:\n    let (p, x, y) = qs[i]\n\n    if p in 1..<n2 - 1:\n      midSum -= max(a[p], b[p])\n      if b[p] - a[p] > 0:\n        gtCnt -= 1\n      if b[p] - a[p] == 0:\n        eqCnt -= 1\n      if b[p] - a[p] < 0:\n        ltCnt -= 1\n\n      a[p] = x\n      b[p] = y\n\n      midSum += max(a[p], b[p])\n      if b[p] - a[p] > 0:\n        gtCnt += 1\n      if b[p] - a[p] == 0:\n        eqCnt += 1\n      if b[p] - a[p] < 0:\n        ltCnt += 1\n      segtree.update(p, abs(b[p] - a[p]))\n    else:\n      a[p] = x\n      b[p] = y\n\n    var ans = -1\n    if eqCnt > 0 or gtCnt mod 2 == 0 and ltCnt mod 2 == 0:\n      ans = a[0] + midSum + a[n2 - 1]\n    else:\n      ans = a[0] + midSum + a[n2 - 1] - segtree.query(0, n2)\n    echo ans\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import heappop, heappush, heapify\n\ndef main():\n    input = sys.stdin.readline\n    \n    N, Q = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    \n    ls = [b-a for a, b in zip(A, B)]\n    st = set(ls[1:-1])\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapify(q_m)\n    heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    Ans = []\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    for _ in range(Q):\n        p, x, y = map(int, input().split())\n        p -= 1\n        v = y-x\n        sum_A += x - A[p]\n        if p==0 or p==2*N-1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heappush(q_p, v)\n        else:\n            heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                heappop(q_p)\n            while q_m[0] in to_remove:\n                heappop(q_m)\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    print(\"\\n\".join(map(str, Ans)))\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import heappop, heappush, heapify\n\ndef main():\n    input = sys.stdin.readline\n    \n    N, Q = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    \n    ls = [b-a for a, b in zip(A, B)]\n    st = set(ls[1:-1])\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapify(q_m)\n    heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    Ans = []\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    for _ in range(Q):\n        p, x, y = map(int, input().split())\n        p -= 1\n        v = y-x\n        sum_A += x - A[p]\n        if p==0 or p==2*N-1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heappush(q_p, v)\n        else:\n            heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                heappop(q_p)\n            while -q_m[0] in to_remove:\n                heappop(q_m)\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    print(\"\\n\".join(map(str, Ans)))\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "\nN,Q =list(map(int,input().split()))\na= list(map(int,input().split()))\nb=list(map(int,input().split()))\n\n\nINF=-1E10\n\ndef calc(s,t):\n    X=0\n    for i in range(2*N):\n        if s[i]==t[i]:\n            X+=a[i]\n        else:\n            X+=b[i]\n\n    return X\nfor p,x,y in [list(map(int,input().split())) for _ in range(Q)]:\n    a[p-1]=x\n    b[p-1]=y\n    def get_dp(i,j):\n        if 0<=i<2*N and 0 <=j<=i:\n            return dp[i][j]\n        return INF\n    dp = [-INF for _ in range(2*N)]\n    dp[0]=a[0]\n    flag=False\n    tmp=0\n    X =a[0]+a[-1]\n    for i in range(1,2*N-1):\n        X+=max(a[i],b[i])\n        if a[i]>b[i]:\n            tmp+=1\n        if a[i]==b[i]:\n            flag=True\n\n    if flag or tmp%2==0:\n        print(X)\n    else:\n        print(X- min(abs(a[i]-b[i]) for i in range(1,2*N-1)))\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import heappop, heappush, heapify\n\ndef main():\n    input = sys.stdin.readline\n    \n    N, Q = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    \n    ls = [b-a for a, b in zip(A, B)]\n    q_m = [-v for v in ls[1:-1] if v < 0]\n    q_p = [v for v in ls[1:-1] if v >= 0]\n    heapify(q_m)\n    heapify(q_p)\n    sum_A = sum(A)\n    sum_q_p = sum(q_p)\n    to_remove = set()\n    odd = len(q_p) % 2\n    Ans = []\n    ans = sum_A + sum_q_p - (min(q_p[0], q_m[0]) if odd else 0)\n    for _ in range(Q):\n        p, x, y = map(int, input().split())\n        p -= 1\n        v = y-x\n        sum_A += x - A[p]\n        if p==0 or p==2*N-1:\n            ans += x - A[p]\n            Ans.append(ans)\n            A[p] = x\n            continue\n        A[p] = x\n        odd ^= (ls[p] >= 0) ^ (v >= 0)\n        if v >= 0:\n            sum_q_p += v\n        if ls[p] >= 0:\n            sum_q_p -= ls[p]\n        to_remove.add(ls[p])\n        ls[p] = v\n        if v >= 0:\n            heappush(q_p, v)\n        else:\n            heappush(q_m, -v)\n        ans = sum_q_p + sum_A\n        if odd:\n            while q_p[0] in to_remove:\n                to_remove.remove(heappop(q_p))\n            while -q_m[0] in to_remove:\n                to_remove.remove(-heappop(q_m))\n            ans -= min(q_p[0], q_m[0])\n        Ans.append(ans)\n    print(\"\\n\".join(map(str, Ans)))\n\nmain()\n"
  },
  {
    "language": "Rust",
    "code": "//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 より\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n//\n\nuse std::io::Write;\n\nfn run() {\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    input! {\n        n: usize,\n        q: usize,\n        a: [i64; 2 * n],\n        b: [i64; 2 * n],\n        p: [(usize1, i64, i64); q],\n    }\n    let mut a = a;\n    let mut b = b;\n    assert!(q <= 10);\n    for (p, x, y) in p {\n        a[p] = x;\n        b[p] = y;\n        let mut c = vec![];\n        for i in 1..(2 * n - 1) {\n            c.push(b[i] - a[i]);\n        }\n        c.sort();\n        let mut sum = a.iter().fold(0, |s, a| s + *a);\n        let mut ans = sum;\n        for (i, c) in c.iter().rev().enumerate() {\n            sum += c;\n            if i % 2 == 1 {\n                ans = std::cmp::max(ans, sum);\n            }\n        }\n        writeln!(out, \"{}\", ans).ok();\n    }\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "//---------- begin SegmentTree Point update Range query ----------\nmod segment_tree {\n    pub struct PURQ<T: Clone, F: Fn(T, T) -> T> {\n        n: usize,\n        a: Vec<T>,\n        id: T,\n        op: F,\n    }\n    #[allow(dead_code)]\n    impl<T: Clone, F: Fn(T, T) -> T> PURQ<T, F> {\n        pub fn new(n: usize, id: T, op: F) -> PURQ<T, F> {\n            let mut k = 1;\n            while k < n {\n                k *= 2;\n            }\n            PURQ {\n                n: k,\n                a: vec![id.clone(); 2 * k],\n                id: id,\n                op: op,\n            }\n        }\n        pub fn update(&mut self, x: usize, v: T) {\n            let mut k = self.n + x;\n            let a = &mut self.a;\n            a[k] = v;\n            k >>= 1;\n            while k > 0 {\n                a[k] = (self.op)(a[2 * k].clone(), a[2 * k + 1].clone());\n                k >>= 1;\n            }\n        }\n        pub fn update_tmp(&mut self, x: usize, v: T) {\n            self.a[x + self.n] = v;\n        }\n        pub fn update_all(&mut self) {\n            for k in (1..(self.n)).rev() {\n                self.a[k] = (self.op)(self.a[2 * k].clone(), self.a[2 * k + 1].clone());\n            }\n        }\n        pub fn find(&self, mut l: usize, mut r: usize) -> T {\n            let mut p = self.id.clone();\n            let mut q = self.id.clone();\n            l += self.n;\n            r += self.n;\n            while l < r {\n                if (l & 1) == 1 {\n                    p = (self.op)(p, self.a[l].clone());\n                    l += 1;\n                }\n                if (r & 1) == 1 {\n                    r -= 1;\n                    q = (self.op)(self.a[r].clone(), q);\n                }\n                l >>= 1;\n                r >>= 1;\n            }\n            (self.op)(p, q)\n        }\n    }\n}\n//---------- end SegmentTree Point update Range query ----------\n//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 より\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n//\n\nuse std::io::Write;\n\nfn run() {\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    input! {\n        n: usize,\n        q: usize,\n        a: [i64; 2 * n],\n        b: [i64; 2 * n],\n        p: [(usize1, i64, i64); q],\n    }\n    type T = (i64, i64);\n    let f = |a: T, b: T| (std::cmp::max(a.0 + b.0, a.1 + b.1), std::cmp::max(a.0 + b.1, a.1 + b.0));\n    let mut s = segment_tree::PURQ::new(2 * n, (0, std::i64::MIN / 4), f);\n    for i in 1..(2 * n - 1) {\n        s.update_tmp(i, (a[i], b[i]));\n    }\n    s.update_all();\n    let mut a = a;\n    let mut b = b;\n    for (p, x, y) in p {\n        if 0 < p && p < 2 * n - 1 {\n            s.update(p, (x, y));\n        }\n        a[p] = x;\n        b[p] = y;\n        let mut ans = a[0] + a[2 * n - 1];\n        if n > 1 {\n            ans += s.find(1, 2 * n - 1).0;\n        }\n        writeln!(out, \"{}\", ans).ok();\n    }\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 より\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n//\n\nuse std::io::Write;\nuse std::collections::BinaryHeap;\n\nfn delete(h: &mut BinaryHeap<i64>, del: &mut BinaryHeap<i64>) {\n    while !del.is_empty() {\n        let a = *h.peek().unwrap();\n        let b = *del.peek().unwrap();\n        if a == b {\n            h.pop();\n            del.pop();\n        } else {\n            break;\n        }\n    }\n}\n\nfn run() {\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    input! {\n        n: usize,\n        q: usize,\n        a: [i64; 2 * n],\n        b: [i64; 2 * n],\n        p: [(usize1, i64, i64); q],\n    }\n    let mut a = a;\n    let mut b = b;\n    let mut sum = a.iter().fold(0, |s, a| s + *a);\n    let mut small = BinaryHeap::new();\n    let mut small_del = BinaryHeap::new();\n    let mut large = BinaryHeap::new();\n    let mut large_del = BinaryHeap::new();\n    let mut large_sum = 0;\n    for i in 1..(2 * n - 1) {\n        let v = b[i] - a[i];\n        if v <= 0 {\n            small.push(v);\n        } else {\n            large.push(-v);\n            large_sum += v;\n        }\n    }\n    for (p, x, y) in p {\n        if 0 < p && p < 2 * n - 1 {\n            let v = b[p] - a[p];\n            if v <= 0 {\n                small_del.push(v);\n            } else {\n                large_del.push(-v);\n                large_sum -= v;\n            }\n            let v = y - x;\n            if v <= 0 {\n                small.push(v);\n            } else {\n                large.push(-v);\n                large_sum += v;\n            }\n        }\n        sum -= a[p];\n        sum += x;\n        a[p] = x;\n        b[p] = y;\n        delete(&mut small, &mut small_del);\n        delete(&mut large, &mut large_del);\n        let ans = if (large.len() - large_del.len()) % 2 == 0 {\n            sum + large_sum\n        } else {\n            let a = *small.peek().unwrap();\n            let b = -*large.peek().unwrap();\n            sum + large_sum + std::cmp::max(-b, a + b)\n        };\n        writeln!(out, \"{}\", ans).ok();\n    }\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 より\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n//\n\nuse std::io::Write;\nuse std::collections::BinaryHeap;\n\nfn delete(h: &mut BinaryHeap<i64>, del: &mut BinaryHeap<i64>) {\n    while !del.is_empty() {\n        let a = *h.peek().unwrap();\n        let b = *del.peek().unwrap();\n        if a == b {\n            h.pop();\n            del.pop();\n        } else {\n            break;\n        }\n    }\n}\n\nfn run() {\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    input! {\n        n: usize,\n        q: usize,\n        a: [i64; 2 * n],\n        b: [i64; 2 * n],\n        p: [(usize1, i64, i64); q],\n    }\n    let mut a = a;\n    let mut b = b;\n    let mut sum = a.iter().fold(0, |s, a| s + *a);\n    let mut small = BinaryHeap::new();\n    let mut small_del = BinaryHeap::new();\n    let mut large = BinaryHeap::new();\n    let mut large_del = BinaryHeap::new();\n    let mut large_sum = 0;\n    for i in 1..(2 * n - 1) {\n        let v = b[i] - a[i];\n        if v <= 0 {\n            small.push(v);\n        } else {\n            large.push(-v);\n            large_sum += v;\n        }\n    }\n    for (p, x, y) in p {\n        if 0 < p && p < 2 * n - 1 {\n            let v = b[p] - a[p];\n            if v <= 0 {\n                small_del.push(v);\n            } else {\n                large_del.push(-v);\n                large_sum -= v;\n            }\n            let v = y - x;\n            if v <= 0 {\n                small.push(v);\n            } else {\n                large.push(-v);\n                large_sum += v;\n            }\n        }\n        sum -= a[p];\n        sum += x;\n        a[p] = x;\n        b[p] = y;\n        delete(&mut small, &mut small_del);\n        delete(&mut large, &mut large_del);\n        let ans = if (large.len() - large_del.len()) % 2 == 0 {\n            sum + large_sum\n        } else {\n            let a = *small.peek().unwrap();\n            let b = -*large.peek().unwrap();\n            sum + (large_sum - b) + std::cmp::max(0, a + b)\n        };\n        writeln!(out, \"{}\", ans).ok();\n    }\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 より\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n//\n\nuse std::io::Write;\n\nfn run() {\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    input! {\n        n: usize,\n        q: usize,\n        a: [i64; 2 * n],\n        b: [i64; 2 * n],\n        p: [(usize1, i64, i64); q],\n    }\n    let mut a = a;\n    let mut b = b;\n    assert!(q <= 10);\n    for (p, x, y) in p {\n        a[p] = x;\n        b[p] = y;\n        let mut c = vec![];\n        for i in 1..(2 * n - 1) {\n            c.push(b[i] - a[i]);\n        }\n        c.sort();\n        let mut sum = a.iter().fold(0, |s, a| s + *a);\n        let mut ans = sum;\n        for (i, c) in c.iter().rev().enumerate() {\n            sum += *c;\n            if i % 2 == 1 {\n                ans = std::cmp::max(ans, sum);\n            }\n        }\n        writeln!(out, \"{}\", ans).ok();\n    }\n}\n\nfn main() {\n    run();\n}\n"
  }
]