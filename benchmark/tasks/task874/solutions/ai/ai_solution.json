[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAX_N 300\n#define MAX_Q 300000\n\nint N, Q;\nint a[2 * MAX_N + 1], b[2 * MAX_N + 1];\n\nint is_valid_parenthesis(char *s) {\n    int balance = 0;\n    for (int i = 0; i < 2 * N; i++) {\n        if (s[i] == '(') balance++;\n        else balance--;\n        if (balance < 0) return 0;\n    }\n    return balance == 0;\n}\n\nint calculate_beauty(char *s, char *t) {\n    int beauty = 0;\n    for (int i = 0; i < 2 * N; i++) {\n        if (s[i] == t[i]) beauty += (s[i] == '(') ? a[i] : b[i];\n    }\n    return beauty;\n}\n\nint generate_max_beauty() {\n    int max_beauty = 0;\n    char s[2 * MAX_N + 1], t[2 * MAX_N + 1];\n    \n    // Try all possible balanced parenthesis combinations\n    for (int mask = 0; mask < (1 << (2 * N)); mask++) {\n        for (int j = 0; j < 2 * N; j++) {\n            s[j] = (mask & (1 << j)) ? '(' : ')';\n            t[j] = (mask & (1 << j)) ? ')' : '(';\n        }\n        s[2 * N] = t[2 * N] = '\\0';\n        \n        if (is_valid_parenthesis(s) && is_valid_parenthesis(t)) {\n            max_beauty = fmax(max_beauty, calculate_beauty(s, t));\n        }\n    }\n    \n    return max_beauty;\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &Q);\n    \n    for (int i = 0; i < 2 * N; i++) {\n        scanf(\"%d\", &a[i]);\n    }\n    \n    for (int i = 0; i < 2 * N; i++) {\n        scanf(\"%d\", &b[i]);\n    }\n    \n    for (int q = 0; q < Q; q++) {\n        int idx, val;\n        char seq;\n        scanf(\" %c %d %d\", &seq, &idx, &val);\n        \n        if (seq == 'a') {\n            a[idx - 1] = val;\n        } else {\n            b[idx - 1] = val;\n        }\n        \n        printf(\"%d\\n\", generate_max_beauty());\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:11:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 100000\n#define INF 1LL << 60\n\ntypedef long long ll;\n\nint N, Q;\nll a[MAXN * 2], b[MAXN * 2];\nll dp[MAXN * 2][2][2];\n\nvoid update_dp(int l, int r) {\n    for (int i = l; i <= r; ++i) {\n        for (int sl = 0; sl < 2; ++sl) {\n            for (int sr = 0; sr < 2; ++sr) {\n                dp[i][sl][sr] = -INF;\n            }\n        }\n    }\n    for (int i = l; i <= r; ++i) {\n        if (i == 0) {\n            dp[i][0][0] = 0;\n            continue;\n        }\n        for (int sl = 0; sl < 2; ++sl) {\n            for (int sr = 0; sr < 2; ++sr) {\n                if (dp[i - 1][sl][sr] == -INF) continue;\n                for (int nl = 0; nl < 2; ++nl) {\n                    for (int nr = 0; nr < 2; ++nr) {\n                        if (nl == nr) continue;\n                        ll add = (nl == 0) ? a[i - 1] : b[i - 1];\n                        if (nr == 0) add += a[i - 1];\n                        else add += b[i - 1];\n                        if (dp[i][nl][nr] < dp[i - 1][sl][sr] + add) {\n                            dp[i][nl][nr] = dp[i - 1][sl][sr] + add;\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &Q);\n    for (int i = 0; i < 2 * N; ++i) {\n        scanf(\"%lld\", &a[i]);\n    }\n    for (int i = 0; i < 2 * N; ++i) {\n        scanf(\"%lld\", &b[i]);\n    }\n    update_dp(0, 2 * N);\n    printf(\"%lld\\n\", dp[2 * N][0][1]);\n    while (Q--) {\n        int idx;\n        ll va, vb;\n        scanf(\"%d %lld %lld\", &idx, &va, &vb);\n        idx--;\n        a[idx] = va;\n        b[idx] = vb;\n        update_dp(idx + 1, idx + 1);\n        printf(\"%lld\\n\", dp[2 * N][0][1]);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 23:12:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Node {\n    int max_beauty;\n    int open_diff;\n    int close_diff;\n    int prefix_min;\n    int prefix_max;\n    int suffix_min;\n    int suffix_max;\n};\n\nclass SegmentTree {\nprivate:\n    int size;\n    vector<Node> tree;\n\n    Node merge(const Node &left, const Node &right) {\n        Node res;\n        res.open_diff = left.open_diff + right.open_diff;\n        res.close_diff = left.close_diff + right.close_diff;\n\n        int left_part = left.prefix_min;\n        int right_part = left.open_diff + right.prefix_min;\n        res.prefix_min = min(left_part, right_part);\n\n        left_part = left.prefix_max;\n        right_part = left.open_diff + right.prefix_max;\n        res.prefix_max = max(left_part, right_part);\n\n        left_part = right.suffix_min;\n        right_part = right.close_diff + left.suffix_min;\n        res.suffix_min = min(left_part, right_part);\n\n        left_part = right.suffix_max;\n        right_part = right.close_diff + left.suffix_max;\n        res.suffix_max = max(left_part, right_part);\n\n        int cross1 = left.suffix_max + right.prefix_min;\n        int cross2 = left.suffix_min + right.prefix_max;\n        res.max_beauty = max({left.max_beauty, right.max_beauty, cross1, cross2});\n\n        return res;\n    }\n\npublic:\n    SegmentTree(int n) {\n        size = 1;\n        while (size < n) size <<= 1;\n        tree.resize(2 * size);\n    }\n\n    void update(int pos, int a_val, int b_val) {\n        pos += size;\n        tree[pos] = {0, 1, -1, 0, 1, -1, 0};\n        tree[pos].max_beauty = max(a_val, b_val);\n        tree[pos].prefix_min = min(0, -b_val);\n        tree[pos].prefix_max = max(0, a_val);\n        tree[pos].suffix_min = min(0, -b_val);\n        tree[pos].suffix_max = max(0, a_val);\n\n        for (pos >>= 1; pos >= 1; pos >>= 1) {\n            tree[pos] = merge(tree[2 * pos], tree[2 * pos + 1]);\n        }\n    }\n\n    int getMaxBeauty() {\n        return tree[1].max_beauty;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int N, Q;\n    cin >> N >> Q;\n    vector<int> a(2 * N), b(2 * N);\n    for (int i = 0; i < 2 * N; ++i) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < 2 * N; ++i) {\n        cin >> b[i];\n    }\n\n    SegmentTree st(2 * N);\n    for (int i = 0; i < 2 * N; ++i) {\n        st.update(i, a[i], b[i]);\n    }\n\n    while (Q--) {\n        int type, pos, val;\n        cin >> type >> pos >> val;\n        pos--;\n        if (type == 1) {\n            a[pos] = val;\n        } else {\n            b[pos] = val;\n        }\n        st.update(pos, a[pos], b[pos]);\n        cout << st.getMaxBeauty() << '\\n';\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:13:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    static class Node {\n        int minOpen, maxOpen;\n        long sumA, sumB;\n        long maxBeauty;\n\n        Node() {\n            this.minOpen = 0;\n            this.maxOpen = 0;\n            this.sumA = 0;\n            this.sumB = 0;\n            this.maxBeauty = 0;\n        }\n\n        Node(int minOpen, int maxOpen, long sumA, long sumB, long maxBeauty) {\n            this.minOpen = minOpen;\n            this.maxOpen = maxOpen;\n            this.sumA = sumA;\n            this.sumB = sumB;\n            this.maxBeauty = maxBeauty;\n        }\n    }\n\n    static Node merge(Node left, Node right) {\n        Node res = new Node();\n        res.minOpen = Math.min(left.minOpen, left.sumA - left.sumB + right.minOpen);\n        res.maxOpen = Math.max(left.maxOpen, left.sumA - left.sumB + right.maxOpen);\n        res.sumA = left.sumA + right.sumA;\n        res.sumB = left.sumB + right.sumB;\n        res.maxBeauty = Math.max(left.maxBeauty, right.maxBeauty);\n        res.maxBeauty = Math.max(res.maxBeauty, left.sumA + right.sumB + right.maxOpen);\n        res.maxBeauty = Math.max(res.maxBeauty, left.sumA - left.sumB + right.sumA + right.maxBeauty);\n        return res;\n    }\n\n    static int N, Q;\n    static long[] a, b;\n    static Node[] segTree;\n\n    static void build(int node, int start, int end) {\n        if (start == end) {\n            int idx = start - 1;\n            segTree[node] = new Node(0, 0, a[idx], b[idx], a[idx] + b[idx]);\n            return;\n        }\n        int mid = (start + end) / 2;\n        build(2 * node, start, mid);\n        build(2 * node + 1, mid + 1, end);\n        segTree[node] = merge(segTree[2 * node], segTree[2 * node + 1]);\n    }\n\n    static void update(int node, int start, int end, int pos) {\n        if (start == end) {\n            int idx = start - 1;\n            segTree[node] = new Node(0, 0, a[idx], b[idx], a[idx] + b[idx]);\n            return;\n        }\n        int mid = (start + end) / 2;\n        if (pos <= mid) {\n            update(2 * node, start, mid, pos);\n        } else {\n            update(2 * node + 1, mid + 1, end, pos);\n        }\n        segTree[node] = merge(segTree[2 * node], segTree[2 * node + 1]);\n    }\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(System.out);\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        N = Integer.parseInt(st.nextToken());\n        Q = Integer.parseInt(st.nextToken());\n        a = new long[2 * N];\n        b = new long[2 * N];\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < 2 * N; i++) {\n            a[i] = Long.parseLong(st.nextToken());\n        }\n        st = new StringTokenizer(br.readLine());\n        for (int i = 0; i < 2 * N; i++) {\n            b[i] = Long.parseLong(st.nextToken());\n        }\n        segTree = new Node[4 * 2 * N];\n        build(1, 1, 2 * N);\n        while (Q-- > 0) {\n            st = new StringTokenizer(br.readLine());\n            int type = Integer.parseInt(st.nextToken());\n            int pos = Integer.parseInt(st.nextToken());\n            long val = Long.parseLong(st.nextToken());\n            if (type == 1) {\n                a[pos - 1] = val;\n            } else {\n                b[pos - 1] = val;\n            }\n            update(1, 1, 2 * N, pos);\n            out.println(segTree[1].maxBeauty);\n        }\n        out.flush();\n    }\n}",
    "timestamp": "2025-08-05 23:13:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class ParenthesesBeauty {\n    static final int MAX_N = 200;\n    static int N, Q;\n    static int[] a = new int[2 * MAX_N + 1];\n    static int[] b = new int[2 * MAX_N + 1];\n    static int[][] dp = new int[2 * MAX_N + 1][2 * MAX_N + 1];\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        \n        String[] input = br.readLine().split(\" \");\n        N = Integer.parseInt(input[0]);\n        Q = Integer.parseInt(input[1]);\n\n        input = br.readLine().split(\" \");\n        for (int i = 1; i <= 2 * N; i++) {\n            a[i] = Integer.parseInt(input[i - 1]);\n        }\n\n        input = br.readLine().split(\" \");\n        for (int i = 1; i <= 2 * N; i++) {\n            b[i] = Integer.parseInt(input[i - 1]);\n        }\n\n        for (int q = 0; q < Q; q++) {\n            input = br.readLine().split(\" \");\n            int type = Integer.parseInt(input[0]);\n            int index = Integer.parseInt(input[1]);\n            int value = Integer.parseInt(input[2]);\n\n            if (type == 1) {\n                a[index] = value;\n            } else {\n                b[index] = value;\n            }\n\n            int maxBeauty = findMaxBeauty();\n            bw.write(maxBeauty + \"\\n\");\n        }\n\n        bw.flush();\n        bw.close();\n        br.close();\n    }\n\n    static int findMaxBeauty() {\n        for (int[] row : dp) {\n            Arrays.fill(row, Integer.MIN_VALUE);\n        }\n        return solve(1, 2 * N);\n    }\n\n    static int solve(int l, int r) {\n        if (l > r) return 0;\n        if (dp[l][r] != Integer.MIN_VALUE) return dp[l][r];\n\n        int maxBeauty = Integer.MIN_VALUE;\n        for (int i = l; i <= r; i += 2) {\n            for (int j = i; j <= r; j += 2) {\n                if (isValidPair(l, i, j, r)) {\n                    int currentBeauty = calcBeauty(l, i, j, r);\n                    int leftBeauty = solve(l, i - 1);\n                    int rightBeauty = solve(j + 1, r);\n                    maxBeauty = Math.max(maxBeauty, currentBeauty + leftBeauty + rightBeauty);\n                }\n            }\n        }\n\n        return dp[l][r] = maxBeauty;\n    }\n\n    static boolean isValidPair(int l, int i, int j, int r) {\n        return (i - l + 1 == j - l + 1) && \n               (r - j == r - i) && \n               (i % 2 == l % 2) && \n               (j % 2 == r % 2);\n    }\n\n    static int calcBeauty(int l, int i, int j, int r) {\n        int beauty = 0;\n        for (int k = l; k <= i; k++) {\n            beauty += (a[k] == b[j - k + l]) ? 1 : 0;\n        }\n        return beauty;\n    }\n}",
    "timestamp": "2025-08-05 23:14:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\n\nclass Solution {\nprivate:\n    int N, Q;\n    vector<int> a, b;\n    \n    bool isBalanced(const string& s) {\n        int balance = 0;\n        for (char c : s) {\n            if (c == '(') balance++;\n            else balance--;\n            if (balance < 0) return false;\n        }\n        return balance == 0;\n    }\n    \n    int calculateBeauty(const string& s, const string& t) {\n        int beauty = 0;\n        for (int i = 0; i < 2*N; i++) {\n            if (s[i] == t[i]) {\n                beauty += (s[i] == '(') ? a[i] : b[i];\n            }\n        }\n        return beauty;\n    }\n    \n    vector<string> generateBalancedSequences() {\n        vector<string> sequences;\n        function<void(string, int, int)> backtrack = \n            [&](string current, int open, int closed) {\n                if (current.length() == 2*N) {\n                    if (isBalanced(current)) {\n                        sequences.push_back(current);\n                    }\n                    return;\n                }\n                \n                if (open < N) {\n                    backtrack(current + \"(\", open + 1, closed);\n                }\n                \n                if (closed < open) {\n                    backtrack(current + \")\", open, closed + 1);\n                }\n            };\n        \n        backtrack(\"\", 0, 0);\n        return sequences;\n    }\n    \npublic:\n    Solution() {\n        cin >> N >> Q;\n        a.resize(2*N);\n        b.resize(2*N);\n        \n        for (int i = 0; i < 2*N; i++) {\n            cin >> a[i];\n        }\n        \n        for (int i = 0; i < 2*N; i++) {\n            cin >> b[i];\n        }\n    }\n    \n    void solve() {\n        vector<string> balancedSequences = generateBalancedSequences();\n        \n        while (Q--) {\n            int type, idx, val;\n            cin >> type >> idx >> val;\n            idx--;\n            \n            if (type == 1) {\n                a[idx] = val;\n            } else {\n                b[idx] = val;\n            }\n            \n            int maxBeauty = 0;\n            for (int i = 0; i < balancedSequences.size(); i++) {\n                for (int j = 0; j < balancedSequences.size(); j++) {\n                    maxBeauty = max(maxBeauty, calculateBeauty(balancedSequences[i], balancedSequences[j]));\n                }\n            }\n            \n            cout << maxBeauty << endl;\n        }\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n    \n    Solution solution;\n    solution.solve();\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:14:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_beauty(a, b, n):\n    dp = [[-float('inf')] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n    \n    for i in range(2 * n):\n        new_dp = [[-float('inf')] * (n + 1) for _ in range(n + 1)]\n        for open_count in range(n + 1):\n            for close_count in range(n + 1):\n                if dp[open_count][close_count] == -float('inf'):\n                    continue\n                # Case 1: add '('\n                if open_count < n:\n                    new_dp[open_count + 1][close_count] = max(\n                        new_dp[open_count + 1][close_count], dp[open_count][close_count])\n                # Case 2: add ')'\n                if close_count < open_count:\n                    new_dp[open_count][close_count + 1] = max(\n                        new_dp[open_count][close_count + 1],\n                        dp[open_count][close_count] + (a[i] if (open_count + close_count) % 2 == 0 else 0) +\n                                                          (b[i] if (open_count + close_count) % 2 == 1 else 0))\n        dp = new_dp\n    \n    return dp[n][n]\n\nimport sys\n\ninput = sys.stdin.readline\n\ndef main():\n    n, q = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    \n    for _ in range(q):\n        query = list(map(int, input().split()))\n        t, i, x = query[0], query[1] - 1, query[2]\n        if t == 1:\n            a[i] = x\n        else:\n            b[i] = x\n        print(max_beauty(a, b, n))\n\nmain()",
    "timestamp": "2025-08-13 14:05:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class BalancedParenthesesBeauty {\n    private static int N;\n    private static int[] a, b;\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        a = new int[2 * N];\n        b = new int[2 * N];\n\n        for (int i = 0; i < 2 * N; i++) a[i] = scanner.nextInt();\n        for (int i = 0; i < 2 * N; i++) b[i] = scanner.nextInt();\n\n        int Q = scanner.nextInt();\n\n        while (Q-- > 0) {\n            int idx = scanner.nextInt();\n            int seq = scanner.nextInt();\n            int val = scanner.nextInt();\n\n            if (seq == 0) a[idx] = val;\n            else b[idx] = val;\n\n            System.out.println(maxBeauty());\n        }\n        scanner.close();\n    }\n\n    private static int maxBeauty() {\n        Deque<Integer> stack = new ArrayDeque<>();\n        int[][] dp = new int[2 * N + 1][2 * N + 1];\n\n        for (int i = 0; i <= 2 * N; i++) {\n            Arrays.fill(dp[i], Integer.MIN_VALUE);\n        }\n        \n        dp[0][0] = 0;\n        \n        for (int i = 1; i <= 2 * N; i++) {\n            for (int j = 0; j <= 2 * N; j++) {\n                if (j > 0) dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1]);\n                if (j < 2 * N) dp[i][j] = Math.max(dp[i][j], dp[i - 1][j + 1] + ((j > 0) ? (a[i - 1] == b[j - 1] ? 1 : 0) : 0));\n            }\n        }\n        \n        int maxBeauty = 0;\n        for (int i = 0; i <= 2 * N; i++) {\n            maxBeauty = Math.max(maxBeauty, dp[2 * N][i]);\n        }\n        return maxBeauty;\n    }\n}",
    "timestamp": "2025-08-13 14:05:15"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n#define MAXN 100005\n\nint a[MAXN], b[MAXN], N, Q;\n\nint calculateBeauty(int *a, int *b, int N) {\n    int dp[N+1][N+1];\n    memset(dp, 0, sizeof(dp));\n\n    for (int i = 1; i <= N; ++i) {\n        for (int j = 1; j <= N; ++j) {\n            dp[i][j] = dp[i-1][j-1] + (a[i-1] == b[j-1] ? 1 : 0);\n            if (i > 1) dp[i][j] = dp[i][j] > dp[i-2][j] ? dp[i][j] : dp[i-2][j];\n            if (j > 1) dp[i][j] = dp[i][j] > dp[i][j-2] ? dp[i][j] : dp[i][j-2];\n        }\n    }\n    return dp[N][N];\n}\n\nint main() {\n    scanf(\"%d %d\", &N, &Q);\n    for (int i = 0; i < 2 * N; ++i) scanf(\"%d\", &a[i]);\n    for (int i = 0; i < 2 * N; ++i) scanf(\"%d\", &b[i]);\n\n    for (int q = 0; q < Q; ++q) {\n        int index, value;\n        char seq;\n        scanf(\" %c %d %d\", &seq, &index, &value);\n        if (seq == 'a') a[index-1] = value;\n        else b[index-1] = value;\n\n        printf(\"%d\\n\", calculateBeauty(a, b, 2 * N));\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:05:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxBeautyAfterQueries(n, a, b, queries) {\n    // Helper function to check if a sequence is a balanced parentheses sequence\n    function isBalanced(parens) {\n        let balance = 0;\n        for (let p of parens) {\n            if (p === '(') balance++;\n            else balance--;\n            if (balance < 0) return false;\n        }\n        return balance === 0;\n    }\n\n    // Generate all balanced parentheses of length 2N\n    function generateBalancedParens(n) {\n        let result = [];\n        function backtrack(open, close, parens) {\n            if (parens.length === 2 * n) {\n                if (isBalanced(parens)) {\n                    result.push(parens.join(''));\n                }\n                return;\n            }\n            if (open < n) {\n                parens.push('(');\n                backtrack(open + 1, close, parens);\n                parens.pop();\n            }\n            if (close < open) {\n                parens.push(')');\n                backtrack(open, close + 1, parens);\n                parens.pop();\n            }\n        }\n        backtrack(0, 0, []);\n        return result;\n    }\n\n    // Calculate the beauty for a given pair of sequences\n    function calculateBeauty(seq1, seq2, a, b, n) {\n        let beauty = 0;\n        for (let i = 0; i < 2 * n; i++) {\n            if (seq1[i] === seq2[i]) beauty += a[i];\n            else beauty += b[i];\n        }\n        return beauty;\n    }\n\n    // Generate all possible balanced sequences once\n    const balancedParens = generateBalancedParens(n);\n\n    for (let query of queries) {\n        // Update sequences\n        const [index, newValueA, newValueB] = query;\n        a[index] = newValueA;\n        b[index] = newValueB;\n\n        // Find the maximum possible beauty with updated sequences\n        let maxBeauty = -Infinity;\n        for (let seq1 of balancedParens) {\n            for (let seq2 of balancedParens) {\n                const beauty = calculateBeauty(seq1, seq2, a, b, n);\n                if (beauty > maxBeauty) {\n                    maxBeauty = beauty;\n                }\n            }\n        }\n        console.log(maxBeauty);\n    }\n}\n\n// Example usage:\n// const n = 2;\n// const a = [1, 2, 3, 4];\n// const b = [4, 3, 2, 1];\n// const queries = [[1, 10, 0], [2, 5, 5]];\n// maxBeautyAfterQueries(n, a, b, queries);",
    "timestamp": "2025-08-13 14:05:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "class Solution:\n    def solve(self, N, Q, a, b):\n        def is_valid_parenthesis(s):\n            count = 0\n            for char in s:\n                if char == '(':\n                    count += 1\n                else:\n                    count -= 1\n                if count < 0:\n                    return False\n            return count == 0\n\n        def calculate_beauty(s, t):\n            beauty = 0\n            for i in range(len(s)):\n                if s[i] == t[i]:\n                    beauty += a[i]\n                else:\n                    beauty += b[i]\n            return beauty\n\n        def generate_balanced_parenthesis(n):\n            def backtrack(s, open_count, close_count):\n                if len(s) == 2*n:\n                    result.append(s)\n                    return\n                \n                if open_count < n:\n                    backtrack(s + '(', open_count + 1, close_count)\n                \n                if close_count < open_count:\n                    backtrack(s + ')', open_count, close_count + 1)\n\n            result = []\n            backtrack('', 0, 0)\n            return result\n\n        result = []\n        balanced_sequences = generate_balanced_parenthesis(N)\n        \n        for _ in range(Q):\n            max_beauty = 0\n            for s in balanced_sequences:\n                for t in balanced_sequences:\n                    max_beauty = max(max_beauty, calculate_beauty(s, t))\n            result.append(max_beauty)\n            \n            # Update a or b (query modification)\n            query_type = input().split()\n            idx = int(query_type[1]) - 1\n            val = int(query_type[2])\n            \n            if query_type[0] == 'a':\n                a[idx] = val\n            else:\n                b[idx] = val\n        \n        return result",
    "timestamp": "2025-08-13 14:05:56"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(N, Q, a, b) {\n    const dp = Array.from({ length: 2 * N + 1 }, () => \n        Array(2 * N + 1).fill(-Infinity));\n    dp[0][0] = 0;\n\n    for (let i = 0; i < 2 * N; i++) {\n        for (let j = 0; j <= i; j++) {\n            if (dp[i][j] === -Infinity) continue;\n\n            // Open parenthesis\n            if (j < N) {\n                dp[i + 1][j + 1] = Math.max(dp[i + 1][j + 1], dp[i][j]);\n            }\n\n            // Close parenthesis\n            if (j > 0) {\n                let beauty = dp[i][j];\n                if (i < 2 * N - 1) {\n                    beauty += a[i] * b[i];\n                }\n                dp[i + 1][j - 1] = Math.max(dp[i + 1][j - 1], beauty);\n            }\n        }\n    }\n\n    return dp[2 * N][0];\n}\n\nfunction main() {\n    const readline = require('readline');\n    const rl = readline.createInterface({\n        input: process.stdin,\n        output: process.stdout\n    });\n\n    let input = [];\n    rl.on('line', (line) => {\n        input.push(line);\n        if (input.length === 1) {\n            const [N, Q] = input[0].split(' ').map(Number);\n            input.push(null);\n            input.push(null);\n        } else if (input.length === 3) {\n            const a = input[1].split(' ').map(Number);\n            const b = input[2].split(' ').map(Number);\n            input.push({ N, Q, a, b });\n        }\n    });\n\n    rl.on('close', () => {\n        const { N, Q, a, b } = input[3];\n        let result = [];\n        \n        result.push(solve(N, Q, a, b));\n\n        rl.close();\n        process.stdout.write(result.join('\\n'));\n    });\n}\n\nmain();",
    "timestamp": "2025-08-13 14:06:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    a = list(map(int, input[ptr:ptr+2*N]))\n    ptr += 2*N\n    b = list(map(int, input[ptr:ptr+2*N]))\n    ptr += 2*N\n    Q = int(input[ptr])\n    ptr += 1\n    \n    # Precompute the maximum beauty\n    # The maximum beauty is sum_{i} max(a_i, b_i)\n    total = 0\n    for i in range(2*N):\n        total += max(a[i], b[i])\n    \n    for _ in range(Q):\n        # Process each query\n        t = int(input[ptr])\n        ptr += 1\n        i = int(input[ptr]) - 1  # converting to 0-based\n        ptr += 1\n        x = int(input[ptr])\n        ptr += 1\n        \n        if t == 1:\n            # Update a_i to x\n            total -= max(a[i], b[i])\n            a[i] = x\n            total += max(a[i], b[i])\n        else:\n            # Update b_i to x\n            total -= max(a[i], b[i])\n            b[i] = x\n            total += max(a[i], b[i])\n        \n        print(total)\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 14:06:18"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nlet N, Q;\nlet a = [], b = [];\nlet segTree = [];\n\nfunction build(node, l, r) {\n    if (l === r) {\n        segTree[node] = {\n            min: 0,\n            max: 0,\n            diff: 0,\n            beauty: 0\n        };\n        return;\n    }\n    const mid = Math.floor((l + r) / 2);\n    build(2 * node, l, mid);\n    build(2 * node + 1, mid + 1, r);\n    segTree[node] = {\n        min: 0,\n        max: 0,\n        diff: 0,\n        beauty: 0\n    };\n}\n\nfunction updateVal(node, l, r, idx, aVal, bVal) {\n    if (l === r) {\n        segTree[node] = {\n            min: 0,\n            max: 0,\n            diff: 0,\n            beauty: Math.max(aVal, bVal)\n        };\n        return;\n    }\n    const mid = Math.floor((l + r) / 2);\n    if (idx <= mid) {\n        updateVal(2 * node, l, mid, idx, aVal, bVal);\n    } else {\n        updateVal(2 * node + 1, mid + 1, r, idx, aVal, bVal);\n    }\n    const left = segTree[2 * node];\n    const right = segTree[2 * node + 1];\n    const min = Math.min(left.min, left.diff + right.min);\n    const max = Math.max(left.max, left.diff + right.max);\n    const diff = left.diff + right.diff;\n    const beauty = Math.max(\n        left.beauty,\n        right.beauty,\n        left.max + right.max,\n        left.min + right.min\n    );\n    segTree[node] = { min, max, diff, beauty };\n}\n\nfunction main() {\n    let lineCount = 0;\n    rl.on('line', (line) => {\n        if (lineCount === 0) {\n            [N, Q] = line.trim().split(' ').map(Number);\n            lineCount++;\n        } else if (lineCount === 1) {\n            a = line.trim().split(' ').map(Number);\n            lineCount++;\n        } else if (lineCount === 2) {\n            b = line.trim().split(' ').map(Number);\n            lineCount++;\n            const size = 2 * N;\n            segTree = new Array(4 * size);\n            build(1, 0, size - 1);\n            for (let i = 0; i < size; i++) {\n                updateVal(1, 0, size - 1, i, a[i], b[i]);\n            }\n        } else {\n            const [type, x, y] = line.trim().split(' ').map(Number);\n            if (type === 1) {\n                a[x - 1] = y;\n            } else if (type === 2) {\n                b[x - 1] = y;\n            }\n            updateVal(1, 0, 2 * N - 1, x - 1, a[x - 1], b[x - 1]);\n            console.log(segTree[1].beauty);\n        }\n    });\n}\n\nmain();",
    "timestamp": "2025-08-13 14:06:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n// Function to update the sequences a and b\nvoid update_sequence(vector<int>& sequence, int index, int value) {\n    sequence[index] = value;\n}\n\n// Function to calculate the maximum beauty of balanced parenthesis pairs\nint max_beauty(int N, const vector<int>& a, const vector<int>& b) {\n    vector<int> dp(N+1, 0);\n    vector<int> dp_temp(N+1, 0);\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j <= i; ++j) {\n            dp_temp[j] = dp[j];\n\n            if (a[i*2] == b[i*2]) {\n                dp_temp[j] = max(dp_temp[j], dp[j]+1);\n            }\n\n            if (a[i*2+1] == b[i*2+1]) {\n                dp_temp[j+1] = max(dp_temp[j+1], dp[j]+1);\n            }\n        }\n\n        dp = dp_temp;\n    }\n\n    int max_beauty_value = *max_element(dp.begin(), dp.end());\n    return max_beauty_value;\n}\n\nint main() {\n    int N, Q;\n    cin >> N >> Q;\n    vector<int> a(2*N), b(2*N);\n\n    for (int i = 0; i < 2*N; ++i) {\n        cin >> a[i];\n    }\n    for (int i = 0; i < 2*N; ++i) {\n        cin >> b[i];\n    }\n\n    while (Q--) {\n        int type, index, value;\n        cin >> type >> index >> value;\n        if (type == 1) {\n            update_sequence(a, index, value);\n        } else {\n            update_sequence(b, index, value);\n        }\n        cout << max_beauty(N, a, b) << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:42:14"
  }
]