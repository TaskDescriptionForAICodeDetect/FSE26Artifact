[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble distance_point_to_point(Point p1, Point p2) {\n    return sqrt(pow(p1.x - p2.x, 2) + pow(p1.y - p2.y, 2));\n}\n\ndouble dot_product(Point v1, Point v2) {\n    return v1.x * v2.x + v1.y * v2.y;\n}\n\ndouble distance_point_to_line_segment(Point p, Point a, Point b) {\n    Point ab = {b.x - a.x, b.y - a.y};\n    Point ap = {p.x - a.x, p.y - a.y};\n    \n    double t = dot_product(ap, ab) / dot_product(ab, ab);\n    \n    if (t <= 0) return distance_point_to_point(p, a);\n    if (t >= 1) return distance_point_to_point(p, b);\n    \n    Point closest = {\n        a.x + t * ab.x,\n        a.y + t * ab.y\n    };\n    \n    return distance_point_to_point(p, closest);\n}\n\ndouble distance_line_segments(Point p0, Point p1, Point p2, Point p3) {\n    double d1 = distance_point_to_line_segment(p0, p2, p3);\n    double d2 = distance_point_to_line_segment(p1, p2, p3);\n    double d3 = distance_point_to_line_segment(p2, p0, p1);\n    double d4 = distance_point_to_line_segment(p3, p0, p1);\n    \n    return fmin(fmin(d1, d2), fmin(d3, d4));\n}\n\nint main() {\n    Point p0, p1, p2, p3;\n    scanf(\"%lf %lf %lf %lf %lf %lf %lf %lf\", \n          &p0.x, &p0.y, &p1.x, &p1.y, \n          &p2.x, &p2.y, &p3.x, &p3.y);\n    \n    printf(\"%.10f\\n\", distance_line_segments(p0, p1, p2, p3));\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:14:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y, z;\n} Point;\n\ndouble dot(Point a, Point b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nPoint cross(Point a, Point b) {\n    Point c = {\n        a.y * b.z - a.z * b.y,\n        a.z * b.x - a.x * b.z,\n        a.x * b.y - a.y * b.x\n    };\n    return c;\n}\n\nPoint subtract(Point a, Point b) {\n    Point c = {a.x - b.x, a.y - b.y, a.z - b.z};\n    return c;\n}\n\ndouble norm(Point a) {\n    return sqrt(dot(a, a));\n}\n\ndouble distance_between_segments(Point p0, Point p1, Point p2, Point p3) {\n    Point d1 = subtract(p1, p0);\n    Point d2 = subtract(p3, p2);\n    Point r = subtract(p0, p2);\n    \n    double a = dot(d1, d1);\n    double b = dot(d1, d2);\n    double c = dot(d2, d2);\n    double d = dot(d1, r);\n    double e = dot(d2, r);\n    double f = dot(r, r);\n    \n    double det = a * c - b * b;\n    double s, t;\n    \n    if (det < 1e-10) {\n        s = 0.0;\n        t = d / b;\n        t = fmax(0.0, fmin(1.0, t));\n    } else {\n        s = (b * e - c * d) / det;\n        t = (a * e - b * d) / det;\n        s = fmax(0.0, fmin(1.0, s));\n        t = fmax(0.0, fmin(1.0, t));\n    }\n    \n    Point closest1 = {p0.x + s * d1.x, p0.y + s * d1.y, p0.z + s * d1.z};\n    Point closest2 = {p2.x + t * d2.x, p2.y + t * d2.y, p2.z + t * d2.z};\n    Point diff = subtract(closest1, closest2);\n    \n    return norm(diff);\n}\n\nint main() {\n    Point p0, p1, p2, p3;\n    scanf(\"%lf %lf %lf\", &p0.x, &p0.y, &p0.z);\n    scanf(\"%lf %lf %lf\", &p1.x, &p1.y, &p1.z);\n    scanf(\"%lf %lf %lf\", &p2.x, &p2.y, &p2.z);\n    scanf(\"%lf %lf %lf\", &p3.x, &p3.y, &p3.z);\n    \n    double distance = distance_between_segments(p0, p1, p2, p3);\n    printf(\"%.10f\\n\", distance);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:14:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <limits>\n\nusing namespace std;\n\nstruct Point {\n    double x, y, z;\n    Point(double x = 0, double y = 0, double z = 0) : x(x), y(y), z(z) {}\n};\n\nPoint operator-(const Point& a, const Point& b) {\n    return Point(a.x - b.x, a.y - b.y, a.z - b.z);\n}\n\nPoint operator+(const Point& a, const Point& b) {\n    return Point(a.x + b.x, a.y + b.y, a.z + b.z);\n}\n\nPoint operator*(double t, const Point& p) {\n    return Point(t * p.x, t * p.y, t * p.z);\n}\n\ndouble dot(const Point& a, const Point& b) {\n    return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\nPoint cross(const Point& a, const Point& b) {\n    return Point(a.y * b.z - a.z * b.y,\n                 a.z * b.x - a.x * b.z,\n                 a.x * b.y - a.y * b.x);\n}\n\ndouble norm(const Point& p) {\n    return sqrt(dot(p, p));\n}\n\ndouble distance_point_to_segment(const Point& p, const Point& a, const Point& b) {\n    Point ab = b - a;\n    Point ap = p - a;\n    double t = dot(ap, ab) / dot(ab, ab);\n    t = max(0.0, min(1.0, t));\n    Point closest = a + t * ab;\n    return norm(p - closest);\n}\n\ndouble distance_segment_to_segment(const Point& p0, const Point& p1,\n                                  const Point& p2, const Point& p3) {\n    Point u = p1 - p0;\n    Point v = p3 - p2;\n    Point w = p0 - p2;\n    double a = dot(u, u);\n    double b = dot(u, v);\n    double c = dot(v, v);\n    double d = dot(u, w);\n    double e = dot(v, w);\n    double D = a * c - b * b;\n    double sc, sN, sD = D;\n    double tc, tN, tD = D;\n\n    if (D < 1e-6) {\n        sN = 0.0;\n        sD = 1.0;\n        tN = e;\n        tD = c;\n    } else {\n        sN = b * e - c * d;\n        tN = a * e - b * d;\n        if (sN < 0.0) {\n            sN = 0.0;\n            tN = e;\n            tD = c;\n        } else if (sN > sD) {\n            sN = sD;\n            tN = e + b;\n            tD = c;\n        }\n    }\n\n    if (tN < 0.0) {\n        tN = 0.0;\n        if (-d < 0.0)\n            sN = 0.0;\n        else if (-d > a)\n            sN = sD;\n        else {\n            sN = -d;\n            sD = a;\n        }\n    } else if (tN > tD) {\n        tN = tD;\n        if ((-d + b) < 0.0)\n            sN = 0.0;\n        else if ((-d + b) > a)\n            sN = sD;\n        else {\n            sN = -d + b;\n            sD = a;\n        }\n    }\n\n    sc = (abs(sN) < 1e-6 ? 0.0 : sN / sD);\n    tc = (abs(tN) < 1e-6 ? 0.0 : tN / tD);\n\n    Point dP = w + sc * u - tc * v;\n    return norm(dP);\n}\n\nint main() {\n    Point p0, p1, p2, p3;\n    cin >> p0.x >> p0.y >> p0.z;\n    cin >> p1.x >> p1.y >> p1.z;\n    cin >> p2.x >> p2.y >> p2.z;\n    cin >> p3.x >> p3.y >> p3.z;\n\n    double dist = distance_segment_to_segment(p0, p1, p2, p3);\n    cout.precision(10);\n    cout << fixed << dist << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:15:39"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class SegmentDistance {\n    static class Point {\n        double x, y, z;\n        Point(double x, double y, double z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n    }\n\n    static class Vector {\n        double x, y, z;\n        Vector(double x, double y, double z) {\n            this.x = x;\n            this.y = y;\n            this.z = z;\n        }\n    }\n\n    static Vector subtract(Point a, Point b) {\n        return new Vector(a.x - b.x, a.y - b.y, a.z - b.z);\n    }\n\n    static Vector cross(Vector a, Vector b) {\n        return new Vector(\n            a.y * b.z - a.z * b.y,\n            a.z * b.x - a.x * b.z,\n            a.x * b.y - a.y * b.x\n        );\n    }\n\n    static double dot(Vector a, Vector b) {\n        return a.x * b.x + a.y * b.y + a.z * b.z;\n    }\n\n    static double norm(Vector a) {\n        return Math.sqrt(dot(a, a));\n    }\n\n    static double distancePointToSegment(Point p, Point a, Point b) {\n        Vector ap = subtract(p, a);\n        Vector ab = subtract(b, a);\n        double t = dot(ap, ab) / dot(ab, ab);\n        t = Math.max(0, Math.min(1, t));\n        Point projection = new Point(a.x + ab.x * t, a.y + ab.y * t, a.z + ab.z * t);\n        Vector dist = subtract(p, projection);\n        return norm(dist);\n    }\n\n    static double distanceBetweenSegments(Point p0, Point p1, Point p2, Point p3) {\n        Vector u = subtract(p1, p0);\n        Vector v = subtract(p3, p2);\n        Vector w = subtract(p0, p2);\n        double a = dot(u, u);\n        double b = dot(u, v);\n        double c = dot(v, v);\n        double d = dot(u, w);\n        double e = dot(v, w);\n        double D = a * c - b * b;\n        double sc, sN, sD = D;\n        double tc, tN, tD = D;\n\n        if (D < 1e-8) {\n            sN = 0.0;\n            sD = 1.0;\n            tN = e;\n            tD = c;\n        } else {\n            sN = (b * e - c * d);\n            tN = (a * e - b * d);\n            if (sN < 0.0) {\n                sN = 0.0;\n                tN = e;\n                tD = c;\n            } else if (sN > sD) {\n                sN = sD;\n                tN = e + b;\n                tD = c;\n            }\n        }\n\n        if (tN < 0.0) {\n            tN = 0.0;\n            if (-d < 0.0)\n                sN = 0.0;\n            else if (-d > a)\n                sN = sD;\n            else {\n                sN = -d;\n                sD = a;\n            }\n        } else if (tN > tD) {\n            tN = tD;\n            if ((-d + b) < 0.0)\n                sN = 0;\n            else if ((-d + b) > a)\n                sN = sD;\n            else {\n                sN = -d + b;\n                sD = a;\n            }\n        }\n\n        sc = (Math.abs(sN) < 1e-8 ? 0.0 : sN / sD);\n        tc = (Math.abs(tN) < 1e-8 ? 0.0 : tN / tD);\n\n        Vector dP = new Vector(\n            w.x + (u.x * sc) - (v.x * tc),\n            w.y + (u.y * sc) - (v.y * tc),\n            w.z + (u.z * sc) - (v.z * tc)\n        );\n        return norm(dP);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        Point p0 = new Point(scanner.nextDouble(), scanner.nextDouble(), scanner.nextDouble());\n        Point p1 = new Point(scanner.nextDouble(), scanner.nextDouble(), scanner.nextDouble());\n        Point p2 = new Point(scanner.nextDouble(), scanner.nextDouble(), scanner.nextDouble());\n        Point p3 = new Point(scanner.nextDouble(), scanner.nextDouble(), scanner.nextDouble());\n\n        double distance = distanceBetweenSegments(p0, p1, p2, p3);\n        System.out.printf(\"%.6f\\n\", distance);\n    }\n}",
    "timestamp": "2025-08-05 22:16:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class LineSegmentDistance {\n    public static double distance(double[] p0, double[] p1, double[] p2, double[] p3) {\n        // If line segments intersect, distance is 0\n        if (doIntersect(p0, p1, p2, p3)) \n            return 0;\n\n        // Compute minimum distances between points and line segments\n        double dist1 = Math.min(\n            pointToLineSegmentDistance(p0, p2, p3),\n            pointToLineSegmentDistance(p1, p2, p3)\n        );\n        \n        double dist2 = Math.min(\n            pointToLineSegmentDistance(p2, p0, p1),\n            pointToLineSegmentDistance(p3, p0, p1)\n        );\n        \n        return Math.min(dist1, dist2);\n    }\n\n    private static double pointToLineSegmentDistance(double[] p, double[] a, double[] b) {\n        double[] lineVec = {b[0] - a[0], b[1] - a[1]};\n        double[] pointVec = {p[0] - a[0], p[1] - a[1]};\n\n        double lineLen = lineVec[0]*lineVec[0] + lineVec[1]*lineVec[1];\n        double t = Math.max(0, Math.min(1, \n            (pointVec[0]*lineVec[0] + pointVec[1]*lineVec[1]) / lineLen\n        ));\n\n        double[] proj = {\n            a[0] + t * lineVec[0],\n            a[1] + t * lineVec[1]\n        };\n\n        return Math.sqrt(\n            (p[0] - proj[0]) * (p[0] - proj[0]) + \n            (p[1] - proj[1]) * (p[1] - proj[1])\n        );\n    }\n\n    private static int orientation(double[] p, double[] q, double[] r) {\n        double val = (q[1] - p[1]) * (r[0] - q[0]) - \n                     (q[0] - p[0]) * (r[1] - q[1]);\n        \n        if (val == 0) return 0;\n        return val > 0 ? 1 : 2;\n    }\n\n    private static boolean onSegment(double[] p, double[] q, double[] r) {\n        return q[0] <= Math.max(p[0], r[0]) && q[0] >= Math.min(p[0], r[0]) &&\n               q[1] <= Math.max(p[1], r[1]) && q[1] >= Math.min(p[1], r[1]);\n    }\n\n    private static boolean doIntersect(double[] p1, double[] q1, double[] p2, double[] q2) {\n        int o1 = orientation(p1, q1, p2);\n        int o2 = orientation(p1, q1, q2);\n        int o3 = orientation(p2, q2, p1);\n        int o4 = orientation(p2, q2, q1);\n\n        if (o1 != o2 && o3 != o4) return true;\n        \n        if (o1 == 0 && onSegment(p1, p2, q1)) return true;\n        if (o2 == 0 && onSegment(p1, q2, q1)) return true;\n        if (o3 == 0 && onSegment(p2, p1, q2)) return true;\n        if (o4 == 0 && onSegment(p2, q1, q2)) return true;\n\n        return false;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        double[] p0 = new double[2];\n        double[] p1 = new double[2];\n        double[] p2 = new double[2];\n        double[] p3 = new double[2];\n        \n        for (int i = 0; i < 2; i++) p0[i] = sc.nextDouble();\n        for (int i = 0; i < 2; i++) p1[i] = sc.nextDouble();\n        for (int i = 0; i < 2; i++) p2[i] = sc.nextDouble();\n        for (int i = 0; i < 2; i++) p3[i] = sc.nextDouble();\n        \n        System.out.printf(\"%.4f\\n\", distance(p0, p1, p2, p3));\n        \n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 22:16:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\ndouble dist(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble dot(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.x - a.x) + (b.y - a.y) * (c.y - a.y);\n}\n\ndouble cross(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\ndouble segmentDistance(Point p0, Point p1, Point p2, Point p3) {\n    double d1 = cross(p0, p1, p2);\n    double d2 = cross(p0, p1, p3);\n    double d3 = cross(p2, p3, p0);\n    double d4 = cross(p2, p3, p1);\n\n    if (d1 * d2 < 0 && d3 * d4 < 0) {\n        return 0.0;\n    }\n\n    double dist1 = min({\n        dist(p0, p2), \n        dist(p0, p3), \n        dist(p1, p2), \n        dist(p1, p3)\n    });\n\n    return dist1;\n}\n\nint main() {\n    Point p0, p1, p2, p3;\n    cin >> p0.x >> p0.y >> p1.x >> p1.y >> p2.x >> p2.y >> p3.x >> p3.y;\n    \n    cout << fixed << setprecision(10) << segmentDistance(p0, p1, p2, p3) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:17:05"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import numpy as np\n\ndef vector_subtract(v1, v2):\n    return (v1[0] - v2[0], v1[1] - v2[1])\n\ndef dot_product(v1, v2):\n    return v1[0] * v2[0] + v1[1] * v2[1]\n\ndef magnitude_squared(v):\n    return dot_product(v, v)\n\ndef closest_point_on_segment(p, a, b):\n    ab = vector_subtract(b, a)\n    ap = vector_subtract(p, a)\n    t = dot_product(ap, ab) / magnitude_squared(ab)\n    t = max(0, min(1, t))\n    return (a[0] + t * ab[0], a[1] + t * ab[1])\n\ndef squared_distance(p1, p2):\n    return (p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2\n\ndef distance_between_segments(p0, p1, p2, p3):\n    points = [closest_point_on_segment(p0, p2, p3),\n              closest_point_on_segment(p1, p2, p3),\n              closest_point_on_segment(p2, p0, p1),\n              closest_point_on_segment(p3, p0, p1)]\n    \n    min_distance = float('inf')\n    \n    for point, refer in zip(points, [p0, p1, p2, p3]):\n        min_distance = min(min_distance, squared_distance(point, refer))\n    \n    return np.sqrt(min_distance)\n\n# Example usage:\np0, p1 = (0, 0), (1, 1)\np2, p3 = (1, 0), (0, 1)\nprint(distance_between_segments(p0, p1, p2, p3))",
    "timestamp": "2025-08-13 09:40:02"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "public class LineSegmentDistance {\n\n    public static class Point {\n        double x, y;\n\n        public Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    public static class LineSegment {\n        Point start, end;\n\n        public LineSegment(Point start, Point end) {\n            this.start = start;\n            this.end = end;\n        }\n    }\n\n    public static double distance(Point p1, Point p2) {\n        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n    }\n\n    public static double pointToSegmentDistance(Point p, LineSegment seg) {\n        Point v = new Point(seg.end.x - seg.start.x, seg.end.y - seg.start.y);\n        Point w = new Point(p.x - seg.start.x, p.y - seg.start.y);\n\n        double c1 = w.x * v.x + w.y * v.y;\n        double c2 = v.x * v.x + v.y * v.y;\n        double b = c1 / c2;\n\n        Point pb = new Point(seg.start.x + b * v.x, seg.start.y + b * v.y);\n        if (b < 0) pb = seg.start;\n        else if (b > 1) pb = seg.end;\n\n        return distance(p, pb);\n    }\n\n    public static double segmentsDistance(LineSegment s1, LineSegment s2) {\n        double d1 = pointToSegmentDistance(s2.start, s1);\n        double d2 = pointToSegmentDistance(s2.end, s1);\n        double d3 = pointToSegmentDistance(s1.start, s2);\n        double d4 = pointToSegmentDistance(s1.end, s2);\n\n        return Math.min(Math.min(d1, d2), Math.min(d3, d4));\n    }\n\n    public static void main(String[] args) {\n        Point p0 = new Point(0, 0); // Example points\n        Point p1 = new Point(4, 4);\n        Point p2 = new Point(1, 1);\n        Point p3 = new Point(5, 5);\n\n        LineSegment s1 = new LineSegment(p0, p1);\n        LineSegment s2 = new LineSegment(p2, p3);\n\n        double distance = segmentsDistance(s1, s2);\n        System.out.println(\"Distance between segments: \" + distance);\n    }\n}",
    "timestamp": "2025-08-13 09:40:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n\n// Function to find the squared norm of a vector\ndouble normSq(double x, double y, double z) {\n    return x * x + y * y + z * z;\n}\n\n// Function to compute the distance between two line segments\ndouble segmentsDistance(double p0[], double p1[], double p2[], double p3[]) {\n    double u[3], v[3], w[3], a, b, c, d, e, sc, sN, sD, tc, tN, tD;\n    \n    for (int i = 0; i < 3; i++) {\n        u[i] = p1[i] - p0[i];\n        v[i] = p3[i] - p2[i];\n        w[i] = p0[i] - p2[i];\n    }\n    \n    a = normSq(u[0], u[1], u[2]);\n    b = u[0] * v[0] + u[1] * v[1] + u[2] * v[2];\n    c = normSq(v[0], v[1], v[2]);\n    d = u[0] * w[0] + u[1] * w[1] + u[2] * w[2];\n    e = v[0] * w[0] + v[1] * w[1] + v[2] * w[2];\n    sD = tD = a * c - b * b;\n\n    if (sD < 1e-8) {\n        sN = 0.0;\n        sD = 1.0;\n        tN = e;\n        tD = c;\n    } else {\n        sN = (b * e - c * d);\n        tN = (a * e - b * d);\n        if (sN < 0.0) {\n            sN = 0.0;\n            tN = e;\n            tD = c;\n        } else if (sN > sD) {\n            sN = sD;\n            tN = e + b;\n            tD = c;\n        }\n    }\n\n    if (tN < 0.0) {\n        tN = 0.0;\n        if (-d < 0.0)\n            sN = 0.0;\n        else if (-d > a)\n            sN = sD;\n        else {\n            sN = -d;\n            sD = a;\n        }\n    } else if (tN > tD) {\n        tN = tD;\n        if ((-d + b) < 0.0)\n            sN = 0;\n        else if ((-d + b) > a)\n            sN = sD;\n        else {\n            sN = (-d + b);\n            sD = a;\n        }\n    }\n\n    sc = (fabs(sN) < 1e-8 ? 0.0 : sN / sD);\n    tc = (fabs(tN) < 1e-8 ? 0.0 : tN / tD);\n\n    double dP[3];\n    for (int i = 0; i < 3; i++)\n        dP[i] = w[i] + (sc * u[i]) - (tc * v[i]);\n\n    return sqrt(normSq(dP[0], dP[1], dP[2]));\n}\n\nint main() {\n    double p0[3] = {0.0, 0.0, 0.0};\n    double p1[3] = {1.0, 0.0, 0.0};\n    double p2[3] = {0.0, 1.0, 0.0};\n    double p3[3] = {1.0, 1.0, 0.0};\n    \n    double distance = segmentsDistance(p0, p1, p2, p3);\n    printf(\"Distance: %lf\\n\", distance);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 09:40:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef point_line_distance(point, line_start, line_end):\n    line_vec = [line_end[0] - line_start[0], line_end[1] - line_start[1]]\n    point_vec = [point[0] - line_start[0], point[1] - line_start[1]]\n    \n    line_len_sq = line_vec[0]**2 + line_vec[1]**2\n    if line_len_sq == 0:\n        return math.sqrt(point_vec[0]**2 + point_vec[1]**2)\n    \n    t = max(0, min(1, (point_vec[0]*line_vec[0] + point_vec[1]*line_vec[1]) / line_len_sq))\n    \n    proj = [line_start[0] + t*line_vec[0], line_start[1] + t*line_vec[1]]\n    return math.sqrt((point[0]-proj[0])**2 + (point[1]-proj[1])**2)\n\ndef line_segments_distance(p0, p1, p2, p3):\n    dist1 = point_line_distance(p0, p2, p3)\n    dist2 = point_line_distance(p1, p2, p3)\n    dist3 = point_line_distance(p2, p0, p1)\n    dist4 = point_line_distance(p3, p0, p1)\n    \n    return min(dist1, dist2, dist3, dist4)\n\n# Input\np0 = list(map(float, input().split()))\np1 = list(map(float, input().split()))\np2 = list(map(float, input().split()))\np3 = list(map(float, input().split()))\n\n# Output\nprint(\"{:.4f}\".format(line_segments_distance(p0, p1, p2, p3)))",
    "timestamp": "2025-08-13 09:40:45"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\nclass Point:\n    def __init__(self, x, y, z):\n        self.x = x\n        self.y = y\n        self.z = z\n\ndef dot_product(a, b):\n    return a.x * b.x + a.y * b.y + a.z * b.z\n\ndef cross_product(a, b):\n    return Point(a.y * b.z - a.z * b.y,\n                 a.z * b.x - a.x * b.z,\n                 a.x * b.y - a.y * b.x)\n\ndef vector_subtract(a, b):\n    return Point(a.x - b.x, a.y - b.y, a.z - b.z)\n\ndef vector_length(v):\n    return math.sqrt(v.x**2 + v.y**2 + v.z**2)\n\ndef distance_between_segments(p0, p1, p2, p3):\n    u = vector_subtract(p1, p0)\n    v = vector_subtract(p3, p2)\n    w = vector_subtract(p0, p2)\n    \n    a = dot_product(u, u)\n    b = dot_product(u, v)\n    c = dot_product(v, v)\n    d = dot_product(u, w)\n    e = dot_product(v, w)\n    D = a * c - b * b\n    \n    sc, sN, sD = 0, 0, D\n    tc, tN, tD = 0, 0, D\n    \n    if D < 1e-6:\n        sN = 0\n        sD = 1\n        tN = e\n        tD = c\n    else:\n        sN = b * e - c * d\n        tN = a * e - b * d\n        if sN < 0:\n            sN = 0\n            tN = e\n            tD = c\n        elif sN > sD:\n            sN = sD\n            tN = e + b\n            tD = c\n    \n    if tN < 0:\n        tN = 0\n        if -d < 0:\n            sN = 0\n        elif -d > a:\n            sN = sD\n        else:\n            sN = -d\n            sD = a\n    elif tN > tD:\n        tN = tD\n        if (-d + b) < 0:\n            sN = 0\n        elif (-d + b) > a:\n            sN = sD\n        else:\n            sN = -d + b\n            sD = a\n    \n    sc = 0 if abs(sN) < 1e-6 else sN / sD\n    tc = 0 if abs(tN) < 1e-6 else tN / tD\n    \n    dP = Point(w.x + (sc * u.x) - (tc * v.x),\n               w.y + (sc * u.y) - (tc * v.y),\n               w.z + (sc * u.z) - (tc * v.z))\n    \n    return vector_length(dP)\n\np0 = Point(*map(float, input().split()))\np1 = Point(*map(float, input().split()))\np2 = Point(*map(float, input().split()))\np3 = Point(*map(float, input().split()))\n\nprint(\"{:.6f}\".format(distance_between_segments(p0, p1, p2, p3)))",
    "timestamp": "2025-08-13 09:41:11"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n\nstruct Point {\n    double x, y;\n};\n\ndouble dist(Point a, Point b) {\n    return std::sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble dot(Point a, Point b) {\n    return a.x * b.x + a.y * b.y;\n}\n\ndouble cross(Point a, Point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nPoint subtract(Point a, Point b) {\n    return {a.x - b.x, a.y - b.y};\n}\n\ndouble pointToLineDistance(Point a, Point b, Point p) {\n    Point ap = subtract(p, a), ab = subtract(b, a);\n    double u = dot(ap, ab) / dot(ab, ab);\n    if (u < 0) {\n        return dist(p, a);\n    } else if (u > 1) {\n        return dist(p, b);\n    }\n    Point c = {a.x + u * ab.x, a.y + u * ab.y};\n    return dist(p, c);\n}\n\ndouble segmentToSegmentDistance(Point p0, Point p1, Point p2, Point p3) {\n    if (cross(subtract(p1, p0), subtract(p3, p2)) == 0) {\n        return std::min({pointToLineDistance(p0, p1, p2),\n                         pointToLineDistance(p0, p1, p3),\n                         pointToLineDistance(p2, p3, p0),\n                         pointToLineDistance(p2, p3, p1)});\n    } else {\n        Point v0 = subtract(p1, p0), v1 = subtract(p3, p2), v2 = subtract(p0, p2);\n        double d00 = dot(v0, v0), d01 = dot(v0, v1), d11 = dot(v1, v1);\n        double d20 = dot(v2, v0), d21 = dot(v2, v1);\n        double denom = d00 * d11 - d01 * d01;\n        if (denom == 0) return dist(p0, p2);\n        double v = (d11 * d20 - d01 * d21) / denom;\n        double w = (d00 * d21 - d01 * d20) / denom;\n        \n        if (v >= 0 && v <= 1 && w >= 0 && w <= 1) return 0;\n        \n        return std::min({pointToLineDistance(p0, p1, p2),\n                         pointToLineDistance(p0, p1, p3),\n                         pointToLineDistance(p2, p3, p0),\n                         pointToLineDistance(p2, p3, p1)});\n    }\n}\n\nint main() {\n    Point p0, p1, p2, p3;\n    std::cin >> p0.x >> p0.y >> p1.x >> p1.y;\n    std::cin >> p2.x >> p2.y >> p3.x >> p3.y;\n    \n    double distance = segmentToSegmentDistance(p0, p1, p2, p3);\n    std::cout << distance << std::endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:53:34"
  }
]