[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nvector<int>G[1<<17];\nint n,m;\nbool used[1<<17];\nbool ans;\nvoid dfs(int u,int p)\n{\n    used[u]=1;\n    if(G[u].size()>2)\n    {\n        ans=false;\n        return;\n    }\n    for(int i=0;i<G[u].size();i++)\n    {\n        if(p==G[u][i])continue;\n        else if(used[G[u][i]])\n        {\n            ans=false;\n            break;\n        }\n        else dfs(G[u][i],u);\n    }\n}\nmain()\n{\n    while(cin>>n>>m,n)\n    {\n        for(int i=0;i<n;i++)G[i].clear(),used[i]=0;\n        for(int i=0;i<m;i++)\n        {\n            int a,b;cin>>a>>b;a--,b--;\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n        ans=true;\n        for(int i=0;i<n;i++)\n        {\n            if(!used[i])dfs(i,-1);\n        }\n        cout<<(ans?\"yes\":\"no\")<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint s[1000010],ans;\nint n,m;\n\nint visit(int a){\n  bool used[1000001]={};\n  used[a]=1;\n  for(int i=0;i<m;i++){\n    if(used[s[a]]) return 0;\n    a=s[a];\n    used[a]=1;\n  }\n  return 1;\n}\n\nint main(){\n  while(1){\n\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<1000010;i++)s[i]=0;\n    for(int i=0,a,b;i<m;i++)cin>>a>>b,s[a]=b,s[b]=a;\n    ans=0;\n    for(int i=0;i<=n&&!ans;i++)ans=visit(i); \n    cout <<(ans? \"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint deg[110000];\nint UF[110000];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;\n\tUF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<a;i++)deg[i]=0;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint p,q;\n\t\t\tscanf(\"%d%d\",&p,&q);\n\t\t\tp--;q--;\n\t\t\tUNION(p,q);\n\t\t\tdeg[p]++;\n\t\t\tdeg[q]++;\n\t\t}\n\t\tbool ok=true;\n\t\tfor(int i=0;i<a;i++)if(deg[i]>2)ok=false;\n\t\t\n\t\tint rk=0;\n\t\tfor(int i=0;i<a;i++)if(UF[i]<0)rk++;\n\t\tif(rk!=a-b)ok=false;\n\t\tif(ok)printf(\"yes\\n\");\n\t\telse printf(\"no\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int n,m;\n  while(cin>>n>>m&&n){\n    int a[100001]={},c,d,an=1,an2=0;\n    while(m--){\n      cin>>c>>d;\n      if(++a[c]>2||++a[d]>2)an=0;\n      if(a[c]==2)an2++;\n      if(a[d]==2)an2++;\n    }\n    if(an&&an2<n-1)cout<<\"yes\"<<endl;\n    else cout<<\"no\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint d[1000001][2];\n\nint ans(int a) {\n\tint i,b=0,t=1,h;\n\td[a][1]=-2;\n\tif (d[a][0]==0) return 1;\n\twhile(d[a][1]!=0) {\n\t\tfor (i=0;i<2;i++) { h=d[a][b]; if (d[h][i]==a) { a=h; b=1-i; break;}}\n\t\tt++;\n\t\t}\n\td[a][1]=-2;\t \n    return t;\n}\nint main() {\n  int n,m,i,j,k,f,t,s[2];\n  while(cin >> n >> m) {\n\t  if (n==0 && m==0) break;\n\tfor (i=0;i<=n;i++) d[i][0]=d[i][1]=0; f=0;\n\tfor (i=0;i<m;i++) {\n\t\tcin >> s[0] >> s[1]; \n\t\tfor (j=0;j<2 && f==0;j++) { f=1; for  (k=0; k<2; k++) if (d[s[j]][k]==0) { f=0; d[s[j]][k]=s[1-j]; break;}}}\n\t\tif (f==1) { cout << \"no\" << endl; } else  {     \n\tt=0;\n\tfor (i=1;i<=n;i++) if (d[i][1]==0) t+=ans(i);\n\tif (t==n) cout << \"yes\" << endl; else cout << \"no\" << endl;\n\t}\n   }\t    \n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\nstring s;\nint par[100005],ran[100005];\nvoid init(){ for(int i=0;i<100005;i++)par[i]=i,ran[i]=0;}\nint find(int x){\n\tif(x == par[x]) return x;\n\telse return par[x] = find(par[x]);\n}\nvoid unite(int x,int y){\n\tx = find(x); y = find(y); if(x==y) return;\n\tif(ran[x] < ran[y]) par[x] = y;\n\telse{\n\t\tpar[y] = x;\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){ return find(x) == find(y);}\nint x[100005];\nint main() {\n\twhile(1){\n\t\tint n,m; scanf(\"%d%d\",&n,&m);\n\t\tif(n+m==0) return 0;\n\t\tinit();\n\t\tmemset(x,0,sizeof(x)); int out = 0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b; scanf(\"%d%d\",&a,&b);\n\t\t\tif(same(a,b)) out = 1;\n\t\t\tunite(a,b);\n\t\t\tx[a]++; x[b]++;\n\t\t\tif(x[a]>2 || x[b]>2) out=1;\n\t\t}\n\t\tputs(out?\"no\":\"yes\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n\nclass UnionFind {\n    std::vector<int> p;\n\npublic:\n    UnionFind(int n) : p(n, -1) {}\n\n    int root(int x) { return p[x] < 0 ? x : p[x] = root(p[x]); }\n\n    bool same(int x, int y) { return root(x) == root(y); }\n\n    bool unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (p[y] < p[x]) std::swap(x, y);\n        if (p[x] == p[y]) --p[x];\n        p[y] = x;\n        return true;\n    }\n};\n\nint main() {\n    int n, m;\n    while (cin >> n >> m && n) {\n        UnionFind uf(n);\n        bool hasLoop = false;\n        vector<int> deg(n, 0);\n        for (int i = 0; i < m; i++) {\n            int a, b;\n            cin >> a >> b;\n            --a, --b;\n            deg[a]++;\n            deg[b]++;\n            hasLoop |= !uf.unite(a, b);\n        }\n        if( *max_element(deg.begin(), deg.end()) > 2 || hasLoop ){\n            cout << \"no\" << endl;\n        }else{\n            cout << \"yes\" << endl;\n        }\n    }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\nconst ll MOD = 1000000007;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e5 + 5);\nconst double EPS = 1e-8;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nstruct UnionFindTree {\n    vector<int> par;\n    vector<int> rank;\n    vector<int> siz;\n\n    void init(int n) {\n        par.resize(n);\n        rank.resize(n);\n        siz.resize(n);\n        for (int i = 0; i < n; i++) {\n            par[i] = i;\n            rank[i] = 0;\n            siz[i] = 1;\n        }\n    }\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if (x == y) return;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) rank[x]++;\n        par[y] = x;\n        siz[x] += siz[y];\n    }\n    bool is_same(int x, int y) {\n        return find(x) == find(y);\n    }\n    int size(int x) {\n        x = find(x);\n        return siz[x];\n    }\n};\n\nint main() {\n    while(1){\n        int n, m;\n        cin >> n >> m;\n        if(n==0)break;\n        vector<P> v(m);\n        bool ok = true;\n        REP(i,m){\n            cin >> v[i].first >> v[i].second;\n            if(v[i].first==v[i].second)ok=false;\n        }\n        SORT(v);\n        UnionFindTree g;\n        g.init(n+1);\n        vector<int> cnt(n+1,0);\n        REP(i,m){\n            int a = v[i].first, b=v[i].second;\n            if(!g.is_same(a,b) && cnt[a]<2 && cnt[b]<2){\n                g.unite(a,b);\n                cnt[a]++;\n                cnt[b]++;\n            }\n            else {\n                ok = false;\n                break;\n            }\n        }\n        cout << (ok?\"yes\":\"no\") << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tint n, m;\n\twhile(cin >> n >> m, n){\n\t\tvi p(n, -1);\n\t\tvi deg(n);\n\t\tfunction<int(int)> root = [&](int x){\n\t\t\tif(p[x] < 0) return x;\n\t\t\treturn p[x] = root(p[x]);\n\t\t};\n\t\tbool ans = 1;\n\t\trep(i, m){\n\t\t\tint a, b; cin >> a >> b; a--; b--;\n\t\t\tdeg[a]++;\n\t\t\tdeg[b]++;\n\t\t\ta = root(a); b = root(b);\n\t\t\tif(a == b) ans = 0;\n\t\t\telse p[b] = a;\n\t\t}\n\t\trep(i, n) if(deg[i] > 2) ans = 0;\n\t\tcout << (ans ? \"yes\" : \"no\") << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind{\n    vector<int> tree;\n\n    UnionFind(int n): tree(n+1, -1) {};\n    int root(int i) {return tree[i] < 0 ? i : tree[i] = root(tree[i]); }\n\n    bool unite(int i, int j){\n        i = root(i), j = root(j);\n        if(i == j) return false;\n        tree[i] += tree[j], tree[j] = i;\n        return true;\n    }\n};\n\n\nint main(){\n    int n, m;\n\n    while(cin >> n >> m, n != 0){\n        vector<vector<int> > graph(n);\n\n        bool flag = true;\n        UnionFind uf(n);\n\n        for(int i = 0;i < m;i++){\n            int a, b;\n            cin >> a >> b;\n            a--;\n            b--;\n            graph[a].push_back(b);\n            graph[b].push_back(a);\n            flag = (flag && uf.unite(a, b));\n        }\n\n        for(int i = 0;i < n;i++){\n            if(graph[i].size() >= 3){\n                flag = false;\n                break;\n            }\n        }\n\n        if(flag){\n            cout << \"yes\" << endl;\n        }else{\n            cout << \"no\" << endl;\n        }\n\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> P;\nint ans,used[1000010];\nvector<P>in[1000010];\nint n,m;\n\nvoid check(int pos){\n  if(used[pos]||ans)return;\n  used[pos]=1;\n  for(int i=0;i<in[pos].size();i++){\n    int nx=in[pos][i].first,idx=in[pos][i].second;\n    if(used[nx])ans=0;\n    in[pos].erase(in[pos].begin()+i);\n    in[nx].erase(in[nx].begin()+idx);\n    check(nx);\n    i=-1;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<=n;i++)in[i].clear(),used[i]=0;\n\n    ans=1;\n    for(int i=0,a,b;i<m;i++){\n      cin>>a>>b;\n      in[a].push_back(P(b,in[b].size()));\n      in[b].push_back(P(a,in[a].size()-1));\n      if(in[a].size()/3||in[b].size()/3) ans=0;\n    }\n    \n    for(int i=1;i<=n;i++) check(i);\n    cout <<(ans? \"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\nusing namespace std;\ntypedef long long ll;\nconst int INF = 1<<30;\nconst int MOD = 1e9 + 7;\nconst int MAX_N = 1e5 + 10;\nbool check(vector<pair<int, int>> &edge)\n{\n    bool used[MAX_N] = {};\n    for(int i = 0; i < edge.size(); i++)\n    {\n        int from = edge[i].first, to = edge[i].second;\n        for(int j = from; j < to; j++)\n        {\n            if(used[j]) return false;\n            used[j] = true;\n        }\n    }\n    return true;\n}\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, m;\n    while(cin >> n >> m, n | m)\n    {\n        vector<int> used(n + 1, 0);\n        vector<pair<int, int>> edge;\n        for(int i = 0; i < m; i++)\n        {\n            int u, v; cin >> u >> v;\n            if(u > v) swap(u, v);\n            edge.push_back(make_pair(u, v));\n        }\n        cout << (check(edge) ? \"yes\" : \"no\") << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n#define int long long\n\nconst int SIZE=100010;\nbool used[SIZE];\n\nbool bfs(int s,vector<vector<int> >& G)\n{\n   used[s]=true;\n   queue<int> Q;\n   Q.push(s);\n\n   bool ok=true;\n   bool all2=true;\n   while(!Q.empty()){\n      int v=Q.front(); Q.pop();\n      //check\n      if((int)G[v].size()>=3) ok=false;\n      if((int)G[v].size()<2) all2=false;\n\n      for(int u:G[v]){\n         if(!used[u]){\n            used[u]=true;\n            Q.push(u);\n         }\n      }\n   }\n   return (ok and !all2);\n}\n\nsigned main()\n{\n   while(true){\n      int N,M; cin>>N>>M;\n      if(N==0 and M==0) break;\n\n      vector<vector<int> > G;\n      G.resize(N);\n      REP(i,M){\n         int a,b; cin>>a>>b;\n         a--; b--;\n         G[a].push_back(b);\n         G[b].push_back(a);\n      }\n\n      REP(i,N) used[i]=false;\n      bool ok=true;\n      REP(i,N){\n         if(!used[i]){\n            if(!bfs(i,G)) ok=false;\n         }\n      }\n      cout<<(ok? \"yes\":\"no\")<<endl;\n   }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool ContainLoop( int c, int p, const vector< vector<int> >& g, vector<int>& visit ) {\n\n    visit[c] = true;\n    \n    for ( int dst : g[c] ) {\n\tif ( dst == p ) continue;\n\tif ( visit[dst] ) return true;\n\tif ( ContainLoop( dst, c, g, visit ) ) return true;\n    }\n\n    return false;\n}\n\nint main() {\n    int n, m;\n    while ( cin >> n >> m ) {\n\n\tif ( !n && !m ) break;\n\n\tvector<int> cnt( n );\n\tvector< vector<int> > g( n );\n\tvector<int> visit( n );\n\n\tbool ok = true;\n\tint s, t;\n\tfor ( int i=0; i<m; ++i ) {\n\t    cin >> s >> t;\n\t    --s, --t;\n\t    ++cnt[s];\n\t    ++cnt[t];\n\t    if ( cnt[s] > 2 || cnt[t] > 2 ) ok = false;\n\t    g[s].push_back( t );\n\t    g[t].push_back( s );\n\t}\n\n\tif ( !ok ) cout << \"no\" << endl;\n\telse {\n\t    int i = 0;\n\t    for ( ; i<n; ++i ) {\n\t\tif ( !visit[i] && ContainLoop( i, -1, g, visit ) ) break;;\n\t    }\n\t    if ( i == n ) cout << \"yes\" << endl;\n\t    else cout << \"no\" << endl;\n\t    \n\t}\n\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n#define F first\n#define S second\n\nvector<int>v[100009];\nint used[100009];\nint n,m;\n\nint dfs(int x,int t){\n  used[x]=t;\n  r(i,v[x].size()){\n    int nex=v[x][i];\n    if(used[nex]==-1){\n      if(dfs(nex,t^1))return 1;\n    }\n    else{\n      if(used[nex]==t){\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nbool FALSE(){\n  r(i,n){\n    if(v[i].size()>=3){\n      return false;\n    }\n  }\n  r(i,n)if(used[i]==-1){\n    int x=dfs(i,0);\n    if(x)return false;\n  }\n  return true;\n}\n\nsigned main(){\n\n  while(cin>>n>>m,n){\n    r(i,n+1)v[i].clear();\n    memset(used,-1,sizeof(used));\n    r(i,m){\n      int a,b;\n      cin>>a>>b;\n      v[b].push_back(a);\n      v[a].push_back(b);\n    }\n\n    if(!FALSE())cout<<\"no\"<<endl;\n    else cout<<\"yes\"<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint par[100001];\n\nvoid init(int n)\n{\n\tfor (int i = 1; i <= n; i++) par[i] = i;\n}\n\nint find(int x)\n{\n\treturn (x == par[x] ? x : par[x] = find(par[x]));\n}\n\nvoid merge(int x, int y)\n{\n\tx = find(x); y = find(y);\n\n\tpar[y] = x;\n}\n\nbool same(int x, int y)\n{\n\treturn (find(x) == find(y));\n}\n\nint main()\n{\n\tint n, m;\n\n\twhile (scanf(\"%d %d\", &n, &m) && n){\n\t\tinit(n);\n\t\tint deg[100001] = {0};\n\t\tset< pair<int, int> > s;\n\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tif (a == b) ok = false;\n\t\t\tif (s.count(make_pair(a, b))) ok = false;\n\t\t\tif (same(a, b)) ok = false;\n\t\t\tdeg[a]++; deg[b]++;\n\t\t\tif (deg[a] > 2 || deg[b] > 2) ok = false;\n\t\t\ts.insert(make_pair(a, b));\n\t\t\ts.insert(make_pair(b, a));\n\t\t}\n\n\t\tprintf(\"%s\\n\", ok ? \"yes\" : \"no\");\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint n,m,p[2000000];\nbool f;\n\nint main(){\n\twhile(scanf(\"%d%d\",&n,&m), n != 0){\n\t\tfor(int i = 0; i < m*2; i++){\n\t\t\tscanf(\"%d\",&p[i]);\n\t\t}\n\t\tsort(p,p+m*2);\n\t\tf = true;\n\t\tfor(int i = 0; i < m*2 - 2; i++){\n\t\t\tif(p[i] == p[i+2]){\n\t\t\t\tf = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\", f ? \"yes\" : \"no\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint par[100001];\n\nvoid init(int n)\n{\n\tfor (int i = 1; i <= n; i++) par[i] = i;\n}\n\nint find(int x)\n{\n\treturn (x == par[x] ? x : par[x] = find(par[x]));\n}\n\nvoid merge(int x, int y)\n{\n\tx = find(x); y = find(y);\n\n\tpar[y] = x;\n}\n\nbool same(int x, int y)\n{\n\treturn (find(x) == find(y));\n}\n\nint main()\n{\n\tint n, m;\n\n\twhile (scanf(\"%d %d\", &n, &m) && n){\n\t\tinit(n);\n\t\tint deg[100001] = {0};\n\t\tset< pair<int, int> > s;\n\n\t\tbool ok = true;\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint a, b;\n\t\t\tscanf(\"%d %d\", &a, &b);\n\t\t\tif (a == b) ok = false;\n\t\t\tif (s.count(make_pair(a, b))) ok = false;\n\t\t\tif (same(a, b)) ok = false;\n\t\t\tmerge(a, b);\n\t\t\tdeg[a]++; deg[b]++;\n\t\t\tif (deg[a] > 2 || deg[b] > 2) ok = false;\n\t\t\ts.insert(make_pair(a, b));\n\t\t\ts.insert(make_pair(b, a));\n\t\t}\n\n\t\tprintf(\"%s\\n\", ok ? \"yes\" : \"no\");\n\t}\n\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint main(){\n  int n,m;\n  while(cin>>n>>m&&n){\n    int a[100001]={},c,d,an=1;\n    while(m--){\n      cin>>c>>d;\n      if(++a[c]>2||++a[d]>2)an=0;\n    }\n    if(an)cout<<\"yes\"<<endl;\n    else cout<<\"no\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100000\nint n,m;\nvector<int> G[MAX_N];\nbool visited[MAX_N];\n\nbool dfs(int pos,int prev){\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(prev==to)continue;\n    if(visited[to])return true;\n    visited[to]=true;\n    if(dfs(to,pos))return true;\n  }\n  return false;\n}\n\nbool solve(){\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    visited[i]=true;\n    if(dfs(i,-1))return false;\n  }\n  return true;\n}\n\nvoid init(){\n  for(int i=0;i<MAX_N;i++){\n    G[i].clear();\n    visited[i]=false;\n  }\n}\n\nint main(){\n  while(1){\n    scanf(\"%d %d\",&n,&m);\n    if(n==0&&m==0)break;\n    init();\n    for(int i=0;i<m;i++){\n      int a,b;\n      scanf(\"%d %d\",&a,&b);\n      a--,b--;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n    printf(solve()?\"yes\\n\":\"no\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct union_find {\n    vector<int> par;\n\n    union_find(int n) : par(n) {\n        for(int i = 0; i < n; ++i) {\n            par[i] = i;\n        }\n    }\n\n    void unite(int a, int b) {\n        a = find(a);\n        b = find(b);\n        if(a > b) {\n            swap(a, b);\n        }\n        par[b] = a;\n    }\n\n    int find(int a) {\n        if(par[a] == a) {\n            return a;\n        } else {\n            return par[a] = find(par[a]);\n        }\n    }\n\n    bool same(int a, int b) {\n        return find(a) == find(b);\n    }\n\n    int size(void) {\n        return par.size();\n    }\n};\n\nint main() {\n\n    int n, m;\n    int u, v;\n\n    while(cin >> n >> m, n || m) {\n\n        bool is_touched = false;\n        union_find uf(n);\n        int cnt[n];\n\n        fill(cnt, cnt + n, 0);\n\n        for(int i = 0; i < m; ++i) {\n            cin >> u >> v;\n            --u;\n            --v;\n            is_touched = is_touched || uf.same(u, v);\n            uf.unite(u, v);\n            ++cnt[u];\n            ++cnt[v];\n        }\n\n        for(int i = 0; i < n; ++i) {\n            is_touched = is_touched || cnt[i] >= 3;\n        }\n\n        if(is_touched) {\n            cout << \"no\" << endl;\n        } else {\n            cout << \"yes\" << endl;\n        }\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\n\nint main(){\n    int n, m, u, v;\n    while(cin >> n >> m, n+m){\n        vector<int> path[n+1], deg(n+1);\n        vector<bool> visit(n+1, 0);\n        while(m-- > 0){\n            cin >> u >> v;\n            deg[u]++; deg[v]++;\n            path[u].push_back(v);\n            path[v].push_back(u);\n        }\n\n        bool valid = true;\n        for(int i = 1; i <= n; i++){\n            if(!visit[i]){\n                queue<int> q;\n                q.push(i);\n                int one = 0, two = 0, more = 0;\n                while(!q.empty()){\n                    int x = q.front();  q.pop();\n                    if(visit[x])    continue;\n                    if(deg[x] == 1) one++;\n                    if(deg[x] == 2) two++;\n                    if(deg[x] > 2)  more++;\n                    visit[x] = true;\n                    for(int next : path[x]){\n                        if(!visit[next])    q.push(next);\n                    }\n                }\n                if(one+two+more == 0 || (one == 2 && more == 0))  continue;\n                else valid = false;\n            }\n        }\n\n        if(valid)   cout << \"yes\" << endl;\n        else        cout << \"no\" << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool dfs(int node, int prenode, vector< vector< int > > &becky, vector<bool> &used){\n  bool res = true;\n  used[node] = 1;\n  for(int i=0; i < (signed int)becky[node].size(); i++){\n    if(becky[node][i] != prenode && used[becky[node][i]]){\n      return false;\n    }\n    if(used[becky[node][i]] == false)\n      res = dfs(becky[node][i], node, becky, used);\n  }\n  return res;\n}\n\nint main(void){\n  int n, m;\n  while(cin >> n >> m, n | m){\n    vector< vector< int > > becky(n);\n    vector<bool> used(n, 0);\n    for(int i=0; i < m; i++){\n      int a, b; cin >> a >> b;\n      a--; b--;\n      becky[a].push_back(b);\n      becky[b].push_back(a);\n    }\n    bool ans = true;\n    for(int i=0; i < n; i++){\n      if(used[i] == false){\n\tans = dfs(i, -1, becky, used);\n      }\n    }\n    if(ans) cout << \"yes\" << endl;\n    else    cout << \"no\"  << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t\treturn true;\n\t}\n};\n\nint n, m;\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n){\n\t\tbool res = true;\n\t\t\n\t\tUnionFind uf(n);\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tif (!uf.unite(--u, --v)){\n\t\t\t\tres = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\tputs(res ? \"yes\" : \"no\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#define N 100000\nusing namespace std;\nint par[N],ran[N];\n\nint find(int x){\n  if(par[x]==x) return x;\n  else return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  if(x<y) swap(x,y);\n  x=find(x);\n  y=find(y);\n  if(x==y) return;\n  if(ran[x]<ran[y]) par[x]=y;\n  else{\n    par[y]=x;\n    if(ran[x]==ran[y]) ran[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nint main(){\n  int n,m,u,v,flag,f2;\n  vector<int> edge[N];\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m) break;\n    for(int i=0;i<m;i++){\n      cin>>u>>v;\n      edge[u-1].push_back(v-1);\n      edge[v-1].push_back(u-1);\n    }\n    flag=f2=0;\n    for(int i=0;i<n;i++){\n      if(edge[i].size()>=3) flag=1;\n      if(edge[i].size()==2) f2=1;\n    }\n    if(f2&&!flag){\n      for(int i=0;i<n;i++) par[i]=i,ran[i]=0;\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<edge[i].size();j++){\n\t  unite(i,edge[i][j]);\n\t  if(j==1&&same(edge[i][0],edge[i][1])) flag=1;\n\t}\n      }\n    }\n    if(flag) cout<<\"no\"<<endl;\n    else cout<<\"yes\"<<endl;\n    for(int i=0;i<n;i++) edge[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool dfs(int node, int prenode, vector< vector< int > > &becky, vector<bool> &used){\n  bool res = true;\n  used[node] = 1;\n  for(int i=0; i < (signed int)becky[node].size(); i++){\n    if(becky[node][i] != prenode && used[becky[node][i]]){\n      return false;\n    }\n    if(used[becky[node][i]] == false)\n      res = dfs(becky[node][i], node, becky, used);\n  }\n  return res;\n}\n\nint main(void){\n  int n, m;\n  while(cin >> n >> m, n | m){\n    vector< vector< int > > becky(n);\n    vector<bool> used(n, 0);\n    for(int i=0; i < m; i++){\n      int a, b; cin >> a >> b;\n      a--; b--;\n      becky[a].push_back(b);\n      becky[b].push_back(a);\n    }\n    bool ans = true;\n    for(int i=0; i < n; i++){\n      if(ans && used[i] == false){\n\tans = dfs(i, -1, becky, used);\n      }\n    }\n    if(ans) cout << \"yes\" << endl;\n    else    cout << \"no\"  << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nvector<int>G[10000];\nbool used[100000];\n\nbool dfs(int v,int p){\n    used[v]=true;\n    bool ret=true;\n\n    for(int i=0;i<G[v].size();i++){\n        int to=G[v][i];\n        if(to==p)continue;\n        if(used[to])return false;\n        ret&=dfs(to,v);\n    }\n    return ret;\n}\n\nint main(){\n    while(cin>>N>>M,N||M){\n        fill_n(G,N,vector<int>());\n        for(int i=0;i<M;i++){\n            int a,b;cin>>a>>b;\n            a--;b--;\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n        if(M>=N){\n            cout<<\"no\"<<endl;\n            continue;\n        }\n        fill_n(used,N,false);\n        bool ret=true;\n\n        for(int i=0;i<N;i++)if(!used[i]&&G[i].size()<=1){\n            ret&=dfs(i,-1);\n        }\n\n        for(int i=0;i<N;i++)if(!used[i])ret=false;\n        if(ret)cout<<\"yes\"<<endl;\n        else cout<<\"no\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n#define int long long\n\nsigned main()\n{\n   while(true){\n      int N,M; cin>>N>>M;\n      if(N==0 and M==0) break;\n      vector<int> deg(N);\n      REP(i,M){\n         int a,b; cin>>a>>b;\n         a--; b--;\n         deg[a]++; deg[b]++;\n      }\n      bool ok=true;\n      bool all2=true;\n      REP(i,N){\n         if(deg[i]>=3) ok=false;\n         if(deg[i]<2) all2=false;\n      }\n      if(ok and !all2) cout<<\"yes\"<<endl;\n      else cout<<\"no\"<<endl;\n   }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int, int> pii;\n\n#define reps(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reps(i,0,n)\n\n\nbool solve(int n, int m)\n{\n    vector<vi> G(n);\n    rep(i, m){\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    \n    for(vi& u : G){\n        if(u.size() >= 3) return false;\n    }\n        \n    vector<bool> finished(n, false);\n    rep(i, n){\n        if(G[i].size() == 1){\n            int p = i;\n            int u = G[i][0];\n            finished[i] = finished[u] = true;\n            while(G[u].size() == 2){\n                int next = G[u][0] == p ? G[u][1] : G[u][0];\n                p = u;\n                u = next;\n                finished[u] = true;\n            }\n        }\n        else if(G[i].size() == 0){\n            finished[i] = true;\n        }\n    }\n    \n    return all_of(finished.begin(), finished.end(), [](bool a){ return a; });\n}\n\nint main()\n{\n    int n, m;\n    while(cin >> n >> m, n){\n        cout << (solve(n, m) ? \"yes\" : \"no\") << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#define N 100000\nusing namespace std;\nvoid func(int);\nbool visited[N];\nint n,m,u,v,flag,f2,cnt[N];\nvector<int> edge[N];\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m) break;\n    for(int i=0;i<m;i++){\n      cin>>u>>v;\n      edge[u-1].push_back(v-1);\n      edge[v-1].push_back(u-1);\n    }\n    flag=f2=0;\n    for(int i=0;i<n;i++){\n      if(edge[i].size()>=3) flag=1;\n      if(edge[i].size()==2) f2=1;\n    }\n    if(f2&&!flag){\n      for(int i=0;i<n;i++) visited[i]=false,cnt[i]=0;\n      for(int i=0;i<n;i++)\n\tif(!visited[i]) func(i);\n      for(int i=0;i<n;i++)\n\tif(cnt[i]>=2) flag=1;\n    }\n    if(flag) cout<<\"no\"<<endl;\n    else cout<<\"yes\"<<endl;\n    for(int i=0;i<n;i++) edge[i].clear();\n  }\n  return 0;\n}\n\nvoid func(int x){\n  visited[x]=true;\n  for(int i=0;i<edge[x].size();i++)\n    if(!visited[edge[x][i]]) cnt[edge[x][i]]++;\n  for(int i=0;i<edge[x].size();i++)\n    if(!visited[edge[x][i]]) func(edge[x][i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_V = 100010;\nconst string YES = \"yes\";\nconst string NO  = \"no\";\n\nint V,E;\nint degree[MAX_V];\nint par[MAX_V],ones[MAX_V],two[MAX_V];\n\nint find(int x) { \n  if( x == par[x] ) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nvoid compute(){\n  if( E >= V ) { cout << NO << endl; return; }\n  rep(i,V) if( degree[i] >= 3 ) { cout << NO << endl; return; }\n  rep(i,V) {\n    int group_index = find(i);\n    if( degree[i] == 1 ) ++ones[group_index];\n    else if( degree[i] == 2 ) ++two[group_index];\n  }\n  rep(i,V) if( ones[i] >= 3 ) { cout << NO << endl; return; }\n  cout << YES << endl;\n}\n\nint main(){\n  int u,v;\n  while( scanf(\"%d %d\",&V,&E), V|E ){\n    rep(i,V) degree[i] = ones[i] = two[i] = 0, par[i] = i;\n    typedef pair<int,int> ii;\n    set<ii> S;\n    bool success = true;\n    rep(i,E){\n      scanf(\"%d %d\",&u,&v);\n      --u, --v;\n      if( u > v ) swap(u,v);\n      ++degree[u], ++degree[v];\n      if( u == v ) success = false;\n      if( S.count(ii(u,v)) ) success = false;\n      S.insert(ii(u,v));\n      unit(u,v);\n    }\n    if( !success ) { cout << NO << endl; continue; }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100000\nint n,m;\nvector<int> G[MAX_N];\nbool visited[MAX_N];\n\nbool dfs(int pos,int prev){\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(prev==to)continue;\n    if(visited[to])return true;\n    visited[to]=true;\n    if(dfs(to,pos))return true;\n  }\n  return false;\n}\n\nbool solve(){\n  for(int i=0;i<n;i++){\n    if(visited[i])continue;\n    visited[i]=true;\n    if(dfs(i,-1))return false;\n    if(G[i].size()>2)return false;\n  }\n\n  return true;\n}\n\nvoid init(){\n  for(int i=0;i<MAX_N;i++){\n    G[i].clear();\n    visited[i]=false;\n  }\n}\n\nint main(){\n  while(1){\n    scanf(\"%d %d\",&n,&m);\n    if(n==0&&m==0)break;\n    init();\n    for(int i=0;i<m;i++){\n      int a,b;\n      scanf(\"%d %d\",&a,&b);\n      a--,b--;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n    printf(solve()?\"yes\\n\":\"no\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nbool used[100000];\nvector<int> G[100000];\nbool flag;\n\nvoid dfs(int v,int prev){\n\tused[v] = true;\n\tif(G[v].size() >= 3) flag = false;\n\tfor(int to : G[v]){\n\t\tif(to == prev) continue;\n\t\tif(used[to]) flag = false;\n\t\telse dfs(to,v);\n\t}\n}\n\nint main(){\n\tint n,m;\n\twhile(cin >> n >> m,n){\n\t\tflag = true;\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b; a--;b--;\n\t\t\tG[a].push_back(b);\n\t\t\tG[b].push_back(a);\n\t\t}\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tif(!used[i]) dfs(i,-1);\n\t\t}\n\t\tif(flag) cout << \"yes\" << endl;\n\t\telse cout << \"no\" << endl;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tG[i].clear();\n\t\t\tused[i] = false;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> parent;\n\t\n\tUnionFind(int n){\n\t\tparent.resize(n);\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\t\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n\t\n\tbool unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return false;\n\t\tparent[x] = y;\n\t\treturn true;\n\t}\n};\n\nint n, m;\n\nint main()\n{\n\twhile (scanf(\"%d %d\", &n, &m), n){\n\t\tbool res = true;\n\t\t\n\t\tUnionFind uf(n);\n\t\tvector<int> deg(n, 0);\n\t\t\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint u, v;\n\t\t\tscanf(\"%d %d\", &u, &v);\n\t\t\tif (!uf.unite(--u, --v)){\n\t\t\t\tres = false;\n\t\t\t}\n\t\t\tif (++deg[u] >= 3) res = false;\n\t\t\tif (++deg[v] >= 3) res = false;\n\t\t}\n\t\t\n\t\tputs(res ? \"yes\" : \"no\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define N 100000\nusing namespace std;\nint par[N],ran[N];\n\nint find(int x){\n  if(par[x]==x) return x;\n  else return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y) return;\n  if(ran[x]<ran[y]) par[x]=y;\n  else{\n    par[y]=x;\n    if(ran[x]==ran[y]) ran[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nint main(){\n  int n,m,u,v,flag,f2;\n  vector<int> edge[N];\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m) break;\n    for(int i=0;i<m;i++){\n      cin>>u>>v;\n      edge[u-1].push_back(v-1);\n      edge[v-1].push_back(u-1);\n    }\n    flag=f2=0;\n    for(int i=0;i<n;i++){\n      if(edge[i].size()>=3) flag=1;\n      if(edge[i].size()==2) f2=1;\n    }\n    if(f2&&!flag){\n      for(int i=0;i<n;i++) par[i]=i,ran[i]=0;\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<edge[i].size();j++){\n\t  if(j==1&&same(i,edge[i][j])) flag=1;\n\t  else unite(i,edge[i][j]);\n\t}\n      }\n    }\n    if(flag) cout<<\"no\"<<endl;\n    else cout<<\"yes\"<<endl;\n    for(int i=0;i<n;i++) edge[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct union_find {\n    vector<int> par;\n\n    union_find(int n) : par(n) {\n        for(int i = 0; i < n; ++i) {\n            par[i] = i;\n        }\n    }\n\n    void unite(int a, int b) {\n        a = find(a);\n        b = find(b);\n        if(a > b) {\n            swap(a, b);\n        }\n        par[b] = a;\n    }\n\n    int find(int a) {\n        if(par[a] == a) {\n            return a;\n        } else {\n            return par[a] = find(par[a]);\n        }\n    }\n\n    bool same(int a, int b) {\n        return find(a) == find(b);\n    }\n};\n\nint main() {\n\n    int n, m;\n    int u, v;\n\n    while(cin >> n >> m, n || m) {\n\n        bool is_loop = false;\n        union_find uf(n);\n\n        for(int i = 0; i < m; ++i) {\n            cin >> u >> v;\n            --u;\n            --v;\n            is_loop = is_loop || uf.same(u, v);\n            uf.unite(u, v);\n        }\n\n        if(is_loop) {\n            cout << \"no\" << endl;\n        } else {\n            cout << \"yes\" << endl;\n        }\n\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_V = 100010;\nconst string YES = \"yes\";\nconst string NO  = \"no\";\n\nint V,E;\nvector<int> G[MAX_V];\nint degree[MAX_V];\nint par[MAX_V],ones[MAX_V],two[MAX_V];\nbool visited[MAX_V];\n\nint find(int x) { \n  if( x == par[x] ) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nvoid compute(){\n  if( E >= V ) { cout << NO << endl; return; }\n  rep(i,V) if( degree[i] >= 3 ) { cout << NO << endl; return; }\n  rep(i,V) {\n    int group_index = find(i);\n    if( degree[i] == 1 ) ++ones[group_index];\n    else if( degree[i] == 2 ) ++two[group_index];\n  }\n  rep(i,V) if( ones[i] >= 3 ) { cout << NO << endl; return; }\n  cout << YES << endl;\n}\n\nint main(){\n  int u,v;\n  while( scanf(\"%d %d\",&V,&E), V|E ){\n    rep(i,V) G[i].clear(), degree[i] = 0, par[i] = i, ones[i] = two[i] = 0, visited[i] = false;\n    rep(i,E){\n      scanf(\"%d %d\",&u,&v);\n      --u, --v;\n      ++degree[u], ++degree[v];\n      G[u].push_back(v);\n      G[v].push_back(u);\n      unit(u,v);\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld =long double;\nconst ld eps = 1e-9;\n\nbool check(const vector<vector<pair<int, int>>>&humans, int x, int y) {\n\tfor (int i = 0; i < 4; ++i) {\n\t\tauto it=find(humans[i].begin(),humans[i].end(),make_pair(x,y));\n\t\tif(it!=humans[i].end())return false;\n\t}\n\treturn true;\n}\nint dx[] = { -1,0,1,0,0 };\nint dy[] = { 0,1,0,-1,0 };\n\ntemplate<typename T> struct Compress {\n\tmap<T, int>mp;\n\tmap<int, T>revmp;\n\n\tCompress(vector<T>vs) {\n\t\tsetmp(vs);\n\t}\n\n\tCompress() :mp(), revmp() {\n\n\t}\n\tvoid setmp(vector<T>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < static_cast<int>(vs.size()); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\n};\nstruct sale {\n\tint id;\n\tint d;\n\tint s;\n\tint e;\n};\n\nstruct aa {\n\tint flag;\n\tint x;\n\tint y;\n\tint cost;\n};\n\nbool operator <(const vector<int>&l, const vector<int>&r) {\n\tfor (int i = 0; i < l.size(); ++i) {\n\t\tif(l[i]<r[i])return true;\n\t\telse if(l[i]>r[i])return false;\n\t}\n\treturn false;\n}\nint solve(vector<int>haves, vector<int>nums) {\n\tmap<pair<vector<int>,int>,int>mp;\n\tmp[make_pair(nums,0)]=1;\n\n\tint ans=1;\n\tqueue<pair<vector<int>,int>>que;\n\tque.push(make_pair(nums,0));\n\twhile (!que.empty()) {\n\t\tauto atop(que.front());\n\t\tque.pop();\n\n\t\tint x=atop.second;\n\t\tvector<int>v(atop.first);\n\n\t\tint cost=mp[make_pair(atop.first,atop.second)];\n\t\tans=max(ans,cost);\n\t\tfor (int i = 0; i < haves.size(); ++i) {\n\t\t\tif (v[i]){\n\t\t\t\tif (x+haves[i] >= 11) {\n\n\t\t\t\t}\n\t\t\t\telse if (x + haves[i] == 10) {\n\t\t\t\t\tv[i]--;\n\t\t\t\t\tauto np=make_pair(v,0);\n\t\t\t\t\tif (mp[np] < cost + 1) {\n\t\t\t\t\t\tmp[np]=cost+1;\n\t\t\t\t\t\tque.push(np);\n\t\t\t\t\t}\n\t\t\t\t\tv[i]++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv[i]--;\n\t\t\t\t\tauto np=make_pair(v,x+haves[i]);\n\t\t\t\t\tif (mp[np] < cost) {\n\t\t\t\t\t\tmp[np]=cost;\n\t\t\t\t\t\tque.push(np);\n\t\t\t\t\t}\n\t\t\t\t\tv[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans-1;\n}\nint dfs(const int now, const int pre,const vector<vector<int>>&edges, vector<int>&memo) {\n\tif(memo[now])return false;\n\telse {\n\t\tmemo[now]=true;\n\t\tfor (auto e : edges[now]) {\n\t\t\tif (e != pre) {\n\t\t\t\tint k=dfs(e,now,edges,memo);\n\t\t\t\tif(!k)return false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nint main()\n{\n\twhile (true) {\n\t\tint N,M;cin>>N>>M;\n\t\tif(!N)break;\n\t\tvector<vector<int>>edges(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a,b;cin>>a>>b;\n\t\t\tedges[a-1].push_back(b);\n\t\t\tedges[b-1].push_back(a);\n\t\t}\n\t\tbool ok = all_of(edges.begin(), edges.end(), [](const vector<int>&v) {return v.size() <= 2; });\n\n\t\tvector<int>memo(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (!memo[i]) {\n\t\t\t\tint k=dfs(i,-1,edges,memo);\n\t\t\t\tif(!k)ok=false;\n\t\t\t}\n\t\t}\n\t\tif(ok)cout<<\"yes\"<<endl;\n\t\telse cout<<\"no\"<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#define N 100000\nusing namespace std;\nint par[N],ran[N];\n\nint find(int x){\n  if(par[x]==x) return x;\n  else return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  if(x<y) swap(x,y);\n  x=find(x);\n  y=find(y);\n  if(x==y) return;\n  if(ran[x]<ran[y]) par[x]=y;\n  else{\n    par[y]=x;\n    if(ran[x]==ran[y]) ran[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nint main(){\n  int n,m,u,v,flag,f2;\n  vector<int> edge[N];\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m) break;\n    for(int i=0;i<m;i++){\n      cin>>u>>v;\n      edge[u-1].push_back(v-1);\n      edge[v-1].push_back(u-1);\n    }\n    flag=f2=0;\n    for(int i=0;i<n;i++){\n      if(edge[i].size()>=3) flag=1;\n      if(edge[i].size()==2) f2=1;\n    }\n    if(f2&&!flag){\n      for(int i=0;i<n;i++) par[i]=i,ran[i]=0;\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<edge[i].size();j++){\n\t  if(j==1&&same(edge[i][0],edge[i][1])) flag=1;\n\t  else unite(i,edge[i][j]);\n\t}\n      }      \n    }\n    if(flag) cout<<\"no\"<<endl;\n    else cout<<\"yes\"<<endl;\n    for(int i=0;i<n;i++) edge[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n\nint done[100010];\nint answer;\nvector<int> g[100010];\nint dfs(int a,int p=-1){\n\tif( done[a]++ ) return 0;\n\tif( g[a].size() > 2 ) answer = false;\n\tfor( auto e : g[a] )\n\t\tif( e != p ) dfs(e,a);\n}\nint main(){\n\tint n,m;\n\twhile( cin >> n >> m && n){\n\t\tfor(int i = 0 ; i < n ; i++) g[i].clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b;\n\t\t\tcin >> a >> b;\n\t\t\t--a,--b;\n\t\t\tg[a].push_back(b);\n\t\t\tg[b].push_back(a);\n\t\t}\n\t\tmemset(done,0,sizeof(done));\n\t\tanswer = true;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tif( !done[i] ){\n\t\t\t\tdfs(i);\n\t\t\t}\n\t\t}\n\t\tcout << (answer?\"yes\":\"no\") << endl;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define N 100000\nusing namespace std;\nint par[N],ran[N];\n\nint find(int x){\n  if(par[x]==x) return x;\n  else return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y) return;\n  if(ran[x]<ran[y]) par[x]=y;\n  else{\n    par[y]=x;\n    if(ran[x]==ran[y]) ran[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nint main(){\n  int n,m,u,v,flag;\n  vector<int> edge[N];\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m) break;\n    for(int i=0;i<m;i++){\n      cin>>u>>v;\n      edge[u-1].push_back(v-1);\n      edge[v-1].push_back(u-1);\n    }\n    flag=0;\n    for(int i=0;i<n;i++)\n      if(edge[i].size()>=3) flag=1;\n    if(!flag){\n      for(int i=0;i<n;i++) par[i]=i,ran[i]=0;\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<edge[i].size();j++){\n\t  if(j==1&&same(i,edge[i][j])) flag=1;\n\t  else unite(i,edge[i][j]);\n\t}\n      }\n    }\n    if(flag) cout<<\"no\"<<endl;\n    else cout<<\"yes\"<<endl;\n    for(int i=0;i<n;i++) edge[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> P;\nint ans,used[100010];\nvector<P>in[100010];\nint n,m;\n \nvoid check(int pos){\n  if(used[pos]||!ans)return;\n  used[pos]=1;\n  for(int i=0;i<in[pos].size();i++){\n    int nx=in[pos][i].first,idx=in[pos][i].second;\n    if(used[nx])ans=0;\n    in[pos].erase(in[pos].begin()+i);\n    in[nx].erase(in[nx].begin()+idx);\n    check(nx);\n    i=-1;\n  }\n}\n \nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<=n;i++)in[i].clear(),used[i]=0;\n \n    ans=1;\n    for(int i=0,a,b;i<m;i++){\n      cin>>a>>b;\n      in[a].push_back(P(b,in[b].size()));\n      in[b].push_back(P(a,in[a].size()-1));\n      if(in[a].size()/3||in[b].size()/3) ans=0;\n    }\n     \n    for(int i=1;i<=n;i++) check(i);\n    cout <<(ans? \"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstruct unionfind{\n\tvector<int> data;\n\tvoid use(int n){ data.assign(n, -1); }\n  void reset(void){ data.clear(); }\n\tbool unionset(int x, int y){\n\t\tx = root(x); y = root(y);\n\t\tif(x != y){\n\t\t\tif(data[y] < data[x])swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findset(int x, int y){ return root(x) == root(y); }\n\tint root(int x){ return (data[x] < 0) ? x : data[x] = root(data[x]); }\n\tint size(int x){ return -data[root(x)]; }\n};\n\nsigned main(void){\n  int i, j;\n  unionfind U;\n  int x[1001001], y[1001001], cnt[1001001];\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int2(n, m);\n    if(!(n | m))break;\n\n    rep(i, n)cnt[i] = 0;\n    rep(i, m)scanf(\"%d%d\", &x[i], &y[i]);\n    U.use(n);\n    rep(i, m){\n      --x[i]; --y[i];\n      ++cnt[x[i]]; ++cnt[y[i]];\n      if(U.findset(x[i], y[i])){\n        puts(\"no\");\n        break;\n      }else{\n        U.unionset(x[i], y[i]);\n      }\n    }\n    if(i == m){\n      bool is = true;\n      rep(j, n)if(cnt[j] > 2)is = false;\n      puts(is ? \"yes\" : \"no\");\n    }\n    U.reset();\n\n//*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool dfs(int node, int prenode, vector< vector< int > > &becky, vector<bool> &used){\n  bool res = true;\n  used[node] = 1;\n  for(int i=0; i < (signed int)becky[node].size(); i++){\n    if(becky[node][i] != prenode && used[becky[node][i]]){\n      return false;\n    }\n    if(used[becky[node][i]] == false)\n      res = dfs(becky[node][i], node, becky, used);\n    if(res == false) break;\n  }\n  return res;\n}\n\nint main(void){\n  int n, m;\n  while(cin >> n >> m, n | m){\n    vector< vector< int > > becky(n);\n    vector<bool> used(n, 0);\n    for(int i=0; i < m; i++){\n      int a, b; cin >> a >> b;\n      a--; b--;\n      becky[a].push_back(b);\n      becky[b].push_back(a);\n    }\n    bool ans = true;\n    for(int i=0; i < n; i++){\n      if(ans && used[i] == false){\n\tans = dfs(i, -1, becky, used);\n      }\n    }\n    if(ans) cout << \"yes\" << endl;\n    else    cout << \"no\"  << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#define N 100000\nusing namespace std;\nint par[N],ran[N];\n\nint find(int x){\n  if(par[x]==x) return x;\n  else return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  if(x<y) swap(x,y);\n  x=find(x);\n  y=find(y);\n  if(x==y) return;\n  if(ran[x]<ran[y]) par[x]=y;\n  else{\n    par[y]=x;\n    if(ran[x]==ran[y]) ran[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nint main(){\n  int n,m,u,v,flag,f2;\n  vector<int> edge[N];\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m) break;\n    for(int i=0;i<m;i++){\n      cin>>u>>v;\n      edge[u-1].push_back(v-1);\n      edge[v-1].push_back(u-1);\n    }\n    flag=f2=0;\n    for(int i=0;i<n;i++){\n      if(edge[i].size()>=3) flag=1;\n      if(edge[i].size()==2) f2=1;\n    }\n    if(f2&&!flag){\n      for(int i=0;i<n;i++) par[i]=i,ran[i]=0;\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<edge[i].size();j++){\n\t  if(j==1&&same(edge[i][0],edge[i][1])) flag=1;\n\t  unite(i,edge[i][j]);\n\t}\n      }\n    }\n    if(flag) cout<<\"no\"<<endl;\n    else cout<<\"yes\"<<endl;\n    for(int i=0;i<n;i++) edge[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint ans,used[1000010];\ntypedef pair<int,int> P;\nvector<P>in[1000010];\nint n,m;\n\nvoid check(int pos){\n  if(used[pos])return;\n  used[pos]=1;\n  for(int i=0;i<in[pos].size();i++){\n    int nx=in[pos][i].first,idx=in[pos][i].second;\n    in[pos].erase(in[pos].begin()+i);\n    in[nx].erase(in[nx].begin()+idx);\n    check(nx);\n    i=-1;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<1000010;i++)in[i].clear(),used[i]=0;\n\n    ans=0;\n    for(int i=0,a,b;i<m;i++){\n      cin>>a>>b;\n      in[a].push_back(P(b,in[b].size()));\n      in[b].push_back(P(a,in[a].size()-1));\n      if(in[a].size()>=3||in[b].size()>=3) ans=1;\n    }\n\n \n    for(int i=1;i<=n;i++) check(i);\n    for(int i=0;i<n;i++) ans=max(ans,(int)in[i].size());\n    cout <<(!ans? \"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#define N 100000\nusing namespace std;\nint par[N],ran[N];\n\nint find(int x){\n  if(par[x]==x) return x;\n  else return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  if(x<y) swap(x,y);\n  x=find(x);\n  y=find(y);\n  if(x==y) return;\n  if(ran[x]<ran[y]) par[x]=y;\n  else{\n    par[y]=x;\n    if(ran[x]==ran[y]) ran[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nint main(){\n  int n,m,u,v,flag,f2;\n  vector<int> edge[N];\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m) break;\n    for(int i=0;i<m;i++){\n      cin>>u>>v;\n      edge[u-1].push_back(v-1);\n      edge[v-1].push_back(u-1);\n    }\n    flag=f2=0;\n    for(int i=0;i<n;i++){\n      if(edge[i].size()>=3) flag=1;\n      if(edge[i].size()==2) f2=1;\n    }\n    if(f2&&!flag){\n      for(int i=0;i<n;i++) par[i]=i,ran[i]=0;\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<edge[i].size();j++){\n\t  if(j==1&&same(i,edge[i][j])) flag=1;\n\t  else unite(i,edge[i][j]);\n\t}\n      }\n    }\n    if(flag) cout<<\"no\"<<endl;\n    else cout<<\"yes\"<<endl;\n    for(int i=0;i<n;i++) edge[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define REPR(i,n) for (int i=(int)(n)-1;i>=0;--i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\n#define tpl(...) make_tuple(__VA_ARGS__)\nconst int INF = 0x3f3f3f3f;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>basic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>&os,\nconst C& c){os<<'[';for(auto i=begin(c);i!=end(c);++i)os<<(i==begin(c)?\"\":\" \")<<*i;return os<<']';}\ntemplate<class S,class T>ostream&operator<<(ostream &o,const pair<S,T>&t){return o<<'('<<t.first<<','<<t.second<<')';}\ntemplate<int N,class Tp>void output(ostream&,const Tp&){}\ntemplate<int N,class Tp,class,class ...Ts>void output(ostream &o,const Tp&t){if(N)o<<',';o<<get<N>(t);output<N+1,Tp,Ts...>(o,t);}\ntemplate<class ...Ts>ostream&operator<<(ostream&o,const tuple<Ts...>&t){o<<'(';output<0,tuple<Ts...>,Ts...>(o,t);return o<<')';}\ntemplate<class T>void output(T t,char z=10){if(t<0)t=-t,putchar(45);int c[20];\nint k=0;while(t)c[k++]=t%10,t/=10;for(k||(c[k++]=0);k;)putchar(c[--k]^48);putchar(z);}\ntemplate<class T>void outputs(T t){output(t);}\ntemplate<class S,class ...T>void outputs(S a,T...t){output(a,32);outputs(t...);}\ntemplate<class T>void output(T *a,int n){REP(i,n)cout<<a[i]<<(i!=n-1?',':'\\n');}\ntemplate<class T>void output(T *a,int n,int m){REP(i,n)output(a[i],m);}\ntemplate<class T>bool input(T &t){int n=1,c;for(t=0;!isdigit(c=getchar())&&~c&&c-45;);\nif(!~c)return 0;for(c-45&&(n=0,t=c^48);isdigit(c=getchar());)t=10*t+c-48;t=n?-t:t;return 1;}\ntemplate<class S,class ...T>bool input(S&a,T&...t){input(a);return input(t...);}\ntemplate<class T>bool inputs(T *a, int n) { REP(i,n) if(!input(a[i])) return 0; return 1;}\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nint main() {\n  int n, m;\n  while(input(n,m), n || m) {\n    vector<int> num(n);\n    UnionFind uf(n);\n    bool ok = 1;\n    REP(i,m) {\n      int a, b;\n      input(a,b);\n      a--;b--;\n      if (uf.findSet(a,b)) ok = 0;\n      uf.unionSet(a,b);\n      if (num[a]++ == 2) ok = 0;\n      if (num[b]++ == 2) ok = 0;\n    }\n    cout << (ok ? \"yes\" : \"no\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define REPR(i,n) for (int i=(int)(n)-1;i>=0;--i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\n#define tpl(...) make_tuple(__VA_ARGS__)\nconst int INF = 0x3f3f3f3f;\nconst double EPS = 1e-8;\nconst double PI = acos(-1);\nconst int dy[] = {-1,0,1,0};\nconst int dx[] = {0,1,0,-1};\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>basic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>&os,\nconst C& c){os<<'[';for(auto i=begin(c);i!=end(c);++i)os<<(i==begin(c)?\"\":\" \")<<*i;return os<<']';}\ntemplate<class S,class T>ostream&operator<<(ostream &o,const pair<S,T>&t){return o<<'('<<t.first<<','<<t.second<<')';}\ntemplate<int N,class Tp>void output(ostream&,const Tp&){}\ntemplate<int N,class Tp,class,class ...Ts>void output(ostream &o,const Tp&t){if(N)o<<',';o<<get<N>(t);output<N+1,Tp,Ts...>(o,t);}\ntemplate<class ...Ts>ostream&operator<<(ostream&o,const tuple<Ts...>&t){o<<'(';output<0,tuple<Ts...>,Ts...>(o,t);return o<<')';}\ntemplate<class T>void output(T t,char z=10){if(t<0)t=-t,putchar(45);int c[20];\nint k=0;while(t)c[k++]=t%10,t/=10;for(k||(c[k++]=0);k;)putchar(c[--k]^48);putchar(z);}\ntemplate<class T>void outputs(T t){output(t);}\ntemplate<class S,class ...T>void outputs(S a,T...t){output(a,32);outputs(t...);}\ntemplate<class T>void output(T *a,int n){REP(i,n)cout<<a[i]<<(i!=n-1?',':'\\n');}\ntemplate<class T>void output(T *a,int n,int m){REP(i,n)output(a[i],m);}\ntemplate<class T>bool input(T &t){int n=1,c;for(t=0;!isdigit(c=getchar())&&~c&&c-45;);\nif(!~c)return 0;for(c-45&&(n=0,t=c^48);isdigit(c=getchar());)t=10*t+c-48;t=n?-t:t;return 1;}\ntemplate<class S,class ...T>bool input(S&a,T&...t){input(a);return input(t...);}\ntemplate<class T>bool inputs(T *a, int n) { REP(i,n) if(!input(a[i])) return 0; return 1;}\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nint main() {\n  int n, m;\n  while(input(n,m), n || m) {\n    UnionFind uf(n);\n    bool ok = 1;\n    REP(i,m) {\n      int a, b;\n      input(a,b);\n      a--;b--;\n      if (uf.findSet(a,b)) ok = 0;\n      uf.unionSet(a,b);\n    }\n    cout << (ok ? \"yes\" : \"no\") << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct P{\n\tint u,v;\n\tbool operator<(const P &r){\n\t\treturn u < r.u;\n\t}\n\tvoid swap(){\n\t\tif(u <= v) return;\n\t\tint t = u;\n\t\tu = v;\n\t\tv = t;\n\t}\n}P;\n\nint n,m;\nbool f;\nP p[1000000];\n\nint main(){\n\twhile(scanf(\"%d%d\",&n,&m), n != 0){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tscanf(\"%d%d\",&p[i].u,&p[i].v);\n\t\t\tp[i].swap();\n\t\t}\n\t\tsort(p,p+m);\n\t\tf = true;\n\t\tfor(int i = 1; i < m; i++){\n\t\t\tif(p[i-1].v >= p[i].u || p[i-1].u == p[i].u){\n\t\t\t\tf = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\", f ? \"yes\" : \"no\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_V = 100010;\nconst string YES = \"yes\";\nconst string NO  = \"no\";\n\nint V,E;\nint degree[MAX_V];\nint par[MAX_V],ones[MAX_V],two[MAX_V];\n\nint find(int x) { \n  if( x == par[x] ) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nvoid compute(){\n\n  rep(i,V) if( degree[i] >= 3 ) { cout << NO << endl; return; }\n  rep(i,V) {\n    int group_index = find(i);\n    if( degree[i] == 1 ) ++ones[group_index];\n    else if( degree[i] == 2 ) ++two[group_index];\n  }\n  rep(i,V) if( ones[i] >= 3 ) { cout << NO << endl; return; }\n  cout << YES << endl;\n}\n\nint main(){\n  int u,v;\n  while( scanf(\"%d %d\",&V,&E), V|E ){\n    rep(i,V) degree[i] = ones[i] = two[i] = 0, par[i] = i;\n    typedef pair<int,int> ii;\n    set<ii> S;\n    bool success = true;\n    rep(i,E){\n      scanf(\"%d %d\",&u,&v);\n      --u, --v;\n      if( u > v ) swap(u,v);\n      ++degree[u], ++degree[v];\n      if( u == v ) success = false;\n      if( S.count(ii(u,v)) ) success = false;\n      S.insert(ii(u,v));\n      unit(u,v);\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\ntypedef struct P{\n\tint u,v;\n\tbool operator<(const P &r){\n\t\treturn u < r.u;\n\t}\n\tvoid swap(){\n\t\tif(u <= v) return;\n\t\tint t = u;\n\t\tu = v;\n\t\tv = t;\n\t}\n}P;\n\nint n,m;\nbool f;\nP p[1000000];\n\nint main(){\n\twhile(scanf(\"%d%d\",&n,&m), n != 0){\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tscanf(\"%d%d\",&p[i].u,&p[i].v);\n\t\t\tp[i].swap();\n\t\t}\n\t\tsort(p,p+m);\n\t\tf = true;\n\t\tfor(int i = 1; i < m; i++){\n\t\t\tif(p[i-1].v > p[i].u || p[i-1].u == p[i].u){\n\t\t\t\tf = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\", f ? \"yes\" : \"no\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n#define F first\n#define S second\n\nvector<int>v[100009];\nint used[100009];\nint n,m;\n\nint dfs(int x,int t,int par){\n  used[x]=t;\n  r(i,v[x].size()){\n    int nex=v[x][i];\n    if(nex==par)continue;\n    if(used[nex]==-1){\n      if(dfs(nex,t,x))return 1;\n    }\n    else{\n      if(used[nex]==t){\n        return 1;\n      }\n    }\n  }\n  return 0;\n}\n\nbool FALSE(){\n  r(i,n){\n    if(v[i].size()>=3){\n      return false;\n    }\n  }\n  r(i,n)if(used[i]==-1){\n    int x=dfs(i,1,-1);\n    if(x)return false;\n  }\n  return true;\n}\n\nsigned main(){\n\n  while(cin>>n>>m,n){\n    r(i,n+1)v[i].clear();\n    memset(used,-1,sizeof(used));\n    r(i,m){\n      int a,b;\n      cin>>a>>b;\n      v[b].push_back(a);\n      v[a].push_back(b);\n    }\n\n    if(!FALSE())cout<<\"no\"<<endl;\n    else cout<<\"yes\"<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> P;\nint ans,used[1000010];\nvector<P>in[1000010];\nint n,m;\n\nvoid check(int pos){\n  if(used[pos]||!ans)return;\n  used[pos]=1;\n  for(int i=0;i<in[pos].size();i++){\n    int nx=in[pos][i].first,idx=in[pos][i].second;\n    if(used[nx])ans=0;\n    in[pos].erase(in[pos].begin()+i);\n    in[nx].erase(in[nx].begin()+idx);\n    check(nx);\n    i=-1;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<=n;i++)in[i].clear(),used[i]=0;\n\n    ans=1;\n    for(int i=0,a,b;i<m;i++){\n      cin>>a>>b;\n      in[a].push_back(P(b,in[b].size()));\n      in[b].push_back(P(a,in[a].size()-1));\n      if(in[a].size()/3||in[b].size()/3) ans=0;\n    }\n    \n    for(int i=1;i<=n;i++) check(i);\n    cout <<(ans? \"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> P;\nint ans,used[1000010];\nvector<P>in[1000010];\nint n,m;\n\nvoid check(int pos){\n  if(used[pos])return;\n  used[pos]=1;\n  for(int i=0;i<in[pos].size();i++){\n    int nx=in[pos][i].first,idx=in[pos][i].second;\n    if(used[nx])continue;\n    in[pos].erase(in[pos].begin()+i);\n    in[nx].erase(in[nx].begin()+idx);\n    check(nx);\n    i=-1;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<=n;i++)in[i].clear(),used[i]=0;\n\n    ans=0;\n    for(int i=0,a,b;i<m;i++){\n      cin>>a>>b;\n      in[a].push_back(P(b,in[b].size()));\n      in[b].push_back(P(a,in[a].size()-1));\n      //  if(in[a].size()>=3||in[b].size()>=3) ans=1;\n    }\n\n \n    for(int i=1;i<=n;i++) check(i);\n    for(int i=1;i<=n;i++) ans=max(ans,(int)in[i].size());\n    cout <<(!ans? \"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 100000\nint n,m;\nvector<int> G[MAX_N];\nbool visited[MAX_N];\n\nbool dfs(int pos,int prev){\n  for(int i=0;i<(int)G[pos].size();i++){\n    int to=G[pos][i];\n    if(prev==to)continue;\n    if(visited[to])return true;\n    visited[to]=true;\n    if(dfs(to,pos))return true;\n  }\n  return false;\n}\n\nbool solve(){\n  for(int i=0;i<n;i++){\n    if(G[i].size()>2)return false;\n    if(visited[i])continue;\n    visited[i]=true;\n    if(dfs(i,-1))return false;\n  }\n\n  return true;\n}\n\nvoid init(){\n  for(int i=0;i<MAX_N;i++){\n    G[i].clear();\n    visited[i]=false;\n  }\n}\n\nint main(){\n  while(1){\n    scanf(\"%d %d\",&n,&m);\n    if(n==0&&m==0)break;\n    init();\n    for(int i=0;i<m;i++){\n      int a,b;\n      scanf(\"%d %d\",&a,&b);\n      a--,b--;\n      G[a].push_back(b);\n      G[b].push_back(a);\n    }\n    printf(solve()?\"yes\\n\":\"no\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100000\n\nint N,E;\nint height[NUM],boss[NUM];\nint in_num[NUM];\n\nint get_boss(int id){\n\tif(id == boss[id])return id;\n\telse{\n\t\treturn boss[id] = get_boss(boss[id]);\n\t}\n}\n\nvoid unite(int x,int y){\n\n\tint x_boss_id = get_boss(x);\n\tint y_boss_id = get_boss(y);\n\n\tif(x_boss_id == y_boss_id)return;\n\n\tif(height[x_boss_id] < height[y_boss_id]){\n\n\t\tboss[x_boss_id] = y_boss_id;\n\n\t}else{\n\t\tboss[y_boss_id] = x_boss_id;\n\t\tif(height[x_boss_id] == height[y_boss_id])height[x_boss_id]++;\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tboss[i] = i;\n\t\theight[i] = 0;\n\t\tin_num[i] = 0;\n\t}\n\n\tint from,to;\n\tfor(int loop = 0; loop < E; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tunite(from,to);\n\t\tin_num[from]++;\n\t\tin_num[to]++;\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tif(in_num[i] > 2){\n\t\t\tprintf(\"no\\n\"); //次数が3以上のノードがあればfalse\n\t\t\treturn;\n\t\t}\n\t}\n\n\tint group_num = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tif(i == get_boss(i))group_num++;\n\t}\n\n\t/*\n\t * 1本辺を引く(1回uniteする)毎にbossが1つ減るので、\n\t * 辺の両端に重複がなければ、group_numはN-Eになるはず\n\t * */\n\tif(group_num == N-E){\n\t\tprintf(\"yes\\n\");\n\t}else{\n\t\tprintf(\"no\\n\");\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&N,&E);\n\t\tif(N == 0 && E == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_V = 100010;\nconst int MAX_E = 1000010;\nconst string YES = \"yes\";\nconst string NO  = \"no\";\n\nint V,E;\nint degree[MAX_V],us[MAX_E],vs[MAX_E],V_sub[MAX_V],E_sub[MAX_V];\nint par[MAX_V],ones[MAX_V],two[MAX_V];\n\nint find(int x) { \n  if( x == par[x] ) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nvoid compute(){\n  if( E >= V ) { cout << NO << endl; return; }\n  rep(i,V) if( degree[i] >= 3 ) { cout << NO << endl; return; }\n  rep(i,V) ++V_sub[find(i)];\n  rep(i,E) ++E_sub[find(vs[i])];\n  rep(i,V) if( V_sub[i] && E_sub[i] != V_sub[i]-1 )  { cout << NO << endl; return; }\n\n  \n  rep(i,V) {\n    int group_index = find(i);\n    if( degree[i] == 1 ) ++ones[group_index];\n    else if( degree[i] == 2 ) ++two[group_index];\n  }\n  rep(i,V) if( ones[i] >= 3 ) { cout << NO << endl; return; }\n  cout << YES << endl;\n}\n\nint main(){\n  int u,v;\n  while( scanf(\"%d %d\",&V,&E), V|E ){\n    rep(i,V) degree[i] = ones[i] = two[i] = V_sub[i] = E_sub[i] = 0, par[i] = i;\n    typedef pair<int,int> ii;\n    set<ii> S;\n    bool success = true;\n    rep(i,E){\n      scanf(\"%d %d\",&us[i],&vs[i]);\n      --us[i], --vs[i];\n      if( us[i] > vs[i] ) swap(us[i],vs[i]);\n      ++degree[us[i]], ++degree[vs[i]];\n      if( us[i] == vs[i] ) success = false;\n      if( S.count(ii(us[i],vs[i])) ) success = false;\n      S.insert(ii(us[i],vs[i]));\n      unit(us[i],vs[i]);\n    }\n    if( !success ) { cout << NO << endl; continue; }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_V = 100010;\nconst string YES = \"yes\";\nconst string NO  = \"no\";\n\nint V,E;\nvector<int> G[MAX_V];\nint degree[MAX_V];\nint par[MAX_V],ones[MAX_V],two[MAX_V];\nbool visited[MAX_V];\n\nint find(int x) { \n  if( x == par[x] ) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nvoid compute(){\n  if( E >= V ) { cout << NO << endl; return; }\n  rep(i,V) if( degree[i] >= 3 ) { cout << NO << endl; return; }\n  rep(i,V) {\n    int group_index = find(i);\n    if( degree[i] == 1 ) ++ones[group_index];\n    else if( degree[i] == 2 ) ++two[group_index];\n  }\n  rep(i,V) if( ones[i] >= 3 ) { cout << NO << endl; return; }\n  cout << YES << endl;\n}\n\nint main(){\n  int u,v;\n  while( scanf(\"%d %d\",&V,&E), V|E ){\n    rep(i,V) G[i].clear(), degree[i] = 0, par[i] = i, ones[i] = two[i] = 0, visited[i] = false;\n\n    typedef pair<int,int> ii;\n    set<ii> S;\n    rep(i,E){\n      scanf(\"%d %d\",&u,&v);\n      assert( u != v );\n      if( u > v ) swap(u,v);\n      assert( !S.count(ii(u,v)) );\n      S.insert(ii(u,v));\n      --u, --v;\n      ++degree[u], ++degree[v];\n      G[u].push_back(v);\n      G[v].push_back(u);\n      unit(u,v);\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint deg[110000];\nint UF[110000];\nint FIND(int a){\n    if(UF[a]<0)return a;\n    return UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n    a=FIND(a);b=FIND(b);if(a==b)return;\n    UF[a]+=UF[b];UF[b]=a;\n}\nint main(){\n    int a,b;\n    while(scanf(\"%d%d\",&a,&b),a){\n        for(int i=0;i<a;i++)UF[i]=-1;\n        for(int i=0;i<a;i++)deg[i]=0;\n        for(int i=0;i<b;i++){\n            int p,q;\n            scanf(\"%d%d\",&p,&q);\n            p--;q--;\n            UNION(p,q);\n            deg[p]++;\n            deg[q]++;\n        }\n        bool ok=true;\n        for(int i=0;i<a;i++)if(deg[i]>2)ok=false;\n\n        int rk=0;\n        for(int i=0;i<a;i++)if(UF[i]<0)rk++;\n        if(rk!=a-b)ok=false;\n        if(ok)printf(\"yes\\n\");\n        else printf(\"no\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define N 100000\nusing namespace std;\n\nint main(){\n  int n,m,u,v,flag;\n  vector<int> edge[N];\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m) break;\n    for(int i=0;i<m;i++){\n      cin>>u>>v;\n      edge[u-1].push_back(v-1);\n      edge[v-1].push_back(u-1);\n    }\n    flag=0;\n    for(int i=0;i<n;i++)\n      if(edge[i].size()>=3) flag=1;\n    if(flag) cout<<\"no\"<<endl;\n    else cout<<\"yes\"<<endl;\n    for(int i=0;i<n;i++) edge[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nint n,m,p[2000000];\nbool f;\n\nint main(){\n\twhile(scanf(\"%d%d\",&n,&m), n != 0){\n\t\tfor(int i = 0; i < m*2; i++){\n\t\t\tscanf(\"%d\",&p[i]);\n\t\t}\n\t\tsort(p,p+m*2);\n\t\tf = true;\n\t\tint tmp = p[0];\n\t\tfor(int i = 1; i < m*2 - 2; i++){\n\t\t\tif(p[i] == p[i+2]){\n\t\t\t\tf = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%s\\n\", f ? \"yes\" : \"no\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n\nvector<vector<int> > e;\nbool check[100100];\n\nbool foo(int n, int pre) {\n\tif(check[n])\n\t\treturn false;\n\tcheck[n] = true;\n\n\tif(e[n].size() > 2)\n\t\treturn false;\n\tbool res = true;\n\tfor(int i = 0; i < e[n].size(); i++) {\n\t\tif(e[n][i] != pre)\n\t\t\tres &= foo(e[n][i], n);\n\t}\n\treturn res;\n}\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n || m) {\n\t\te.clear();\n\t\te.resize(n);\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\te[a].push_back(b);\n\t\t\te[b].push_back(a);\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcheck[i] = false;\n\t\tbool flg = true;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(!check[i])\n\t\t\t\tflg &= foo(i, -1);\n\t\t}\n\t\tcout << (flg ? \"yes\" : \"no\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n,m;\n\nvector<vector<int> > vl;\n\nbool findEndPoint(int idx,vector<bool> &v,int pre=-1){\n\tif(v[idx]){\n\t\treturn false;\n\t}\n\tv[idx] = true;\n\tif(pre != -1 && vl[idx].size() == 1){\n\t\treturn true;\n\t}\n\n\tif(vl[idx][0] == pre){\n\t\treturn findEndPoint(vl[idx][1],v,idx);\n\t}\n\telse{\n\t\treturn findEndPoint(vl[idx][0],v,idx);\n\t}\n}\nbool loopNotExist(int idx,vector<bool> &v){\n\tif(vl[idx].size() == 0){\n\t\treturn true;\n\t}\n\tif(vl[idx].size() == 1){\n\t\treturn findEndPoint(idx,v);\n\t}\n\tbool b1 = findEndPoint(vl[idx][0],v,idx);\n\tbool b2 = findEndPoint(vl[idx][1],v,idx);\n\treturn b1 && b2;\n}\n\n// no branch, no loop\nint main(){\n\twhile(scanf(\"%d%d\",&n,&m), !(n==0 && m==0)){\n\t\tvl = vector<vector<int> >(n); // adj list\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tvl[i] = vector<int>();\n\t\t}\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint u,v;\n\t\t\tscanf(\"%d%d\",&u,&v);\n\t\t\tu--;\n\t\t\tv--;\n\t\t\tvl[u].push_back(v);\n\t\t\tvl[v].push_back(u);\n\t\t}\n\t\tif(m >= n){\n\t\t\tcout << \"no\" << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\t// check branch\n\t\tbool ok = true;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(vl[i].size() > 2){\n\t\t\t\tok = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!ok){\n\t\t\tcout << \"no\" << endl;\n\t\t\tcontinue;\n\t\t}\n\n\n\t\t// check loop\n\t\tvector<bool> visited = vector<bool>(n,false);\n\t\tint idx = 0;\n\t\twhile(idx < n){\n\t\t\tif(!visited[idx]){\n\t\t\t\tok = loopNotExist(idx,visited);\n\t\t\t\tif(!ok){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tidx++;\n\t\t}\n\t\tif(ok){\n\t\t\tcout << \"yes\" << endl;\n\t\t}\n\t\telse{\n\t\t\tcout << \"no\" << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define REP(i,N) for(int i=0;i<(N);++i)\nusing namespace std;\nbool check(vector<vector<int> >&map, vector<char> &used,int place,int bplace){\n  bool res = true;\n  REP(i,map[place].size()){\n    if(map[place][i] == bplace)continue;\n    if(used[map[place][i]])return false;\n    used[map[place][i]] = true;\n    res &= check(map,used,map[place][i],place);\n  }\n  return res;\n}\nint main(){\n  int n,m;\n  while(cin>>n>>m&&n!=0){\n    vector<vector<int> > count(n,vector<int>());\n    vector<char> used(n,false);\n    REP(i,m){\n      int a,b;\n      cin>>a>>b;\n      --a;--b;\n      count[a].push_back(b);\n      count[b].push_back(a);\n    }\n    bool flag = true;\n    REP(i,n){\n      if(count[i].size()>=3){\n        flag=false;\n        continue;\n      }\n    }\n    if(!flag){\n      cout << \"no\" << endl;\n      continue;\n    }\n    REP(i,count.size()){\n      if(used[i])continue;\n      flag &= check(count,used,i,-1);\n    }\n    cout << (flag?\"yes\":\"no\") << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n,m;\n  while(cin>>n>>m,n){\n    vector<vector<int> > G(n);\n    for(int i=0;i<m;i++){\n      int x,y;\n      cin>>x>>y;\n      x--;y--;\n      G[x].emplace_back(y);\n      G[y].emplace_back(x);\n    }\n    int flg=0;\n    for(int i=0;i<n;i++){\n      if(G[i].size()>2u){\n        cout<<\"no\"<<endl;\n        flg=1;\n        break;\n      }\n    }\n    if(flg) continue;\n    \n    vector<int> used(n,0);\n    function<void(int, int)> dfs=\n      [&](int v,int p){\n        for(int u:G[v]){\n          if(u==p) continue;\n          if(used[u]){\n            flg=1;\n            break;\n          }\n          used[u]=1;\n          dfs(u,v);\n        }\n      };\n    \n    for(int i=0;i<n;i++){\n      if(used[i]) continue;\n      used[i]=1;\n      dfs(i,-1);\n    }\n    cout<<(flg?\"no\":\"yes\")<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define INF ((long long)1e18)\n#define MOD ((int)1e9+7)\n#define endl \"\\n\"\n\n#define yn(f) ((f)?\"yes\":\"no\")\n#define YN(f) ((f)?\"YES\":\"NO\")\n\n#define MAX\n\nsigned main(){\n\t// cin.tie(0);\n\t// ios::sync_with_stdio(false);\n\t// cout<<fixed<<setprecision(10);\n\t\n\twhile(true){\n\t\tint n, m, u, v;\n\t\tbool flag = true;\n\t\tvector<vector<int>> graph;\n\t\tvector<int> used;\n\t\t\n\t\tcin>>n>>m;\n\t\t\n\t\tif(!n && !m) break;\n\t\t\n\t\tgraph.resize(n+1);\n\t\tused.resize(n+1);\n\t\t// for(int y : used){\n\t\t\t// cout<<\"used \"<<y<<endl;\n\t\t// }\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin>>u>>v;\n\t\t\tgraph[u].push_back(v);\n\t\t\tgraph[v].push_back(u);\n\t\t}\n\t\t\n\t\tfor(int i = 1; i <= n; i++){//cout<<i<<endl;\n\t\t\tif(graph[i].size() > 2){\n\t\t\t\tflag = false;\n\t\t\t\tbreak;\n\t\t\t} else if(graph[i].size() == 1 && used[i] == false){\n\t\t\t\tint n = graph[i][0];\n\t\t\t\tused[i] = true;\n\t\t\t\t\n\t\t\t\t// cout<<\" AA \"<<i<<endl;\n\t\t\t\twhile(true){\n\t\t\t\t\t// cout<<\" BB \"<<n<<endl;\n\t\t\t\t\tif(graph[n].size() > 2){\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else if(graph[n].size() == 2){\n\t\t\t\t\t\tif(used[graph[n][0]] == false){\n\t\t\t\t\t\t\tused[n] = true;\n\t\t\t\t\t\t\tn = graph[n][0];\n\t\t\t\t\t\t} else if(used[graph[n][1]] == false){\n\t\t\t\t\t\t\tused[n] = true;\n\t\t\t\t\t\t\tn = graph[n][1];\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if(graph[n].size() == 1){\n\t\t\t\t\t\tused[n] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(flag == false) break;\n\t\t\t}\n\t\t}\n\t\t// cout<<\"END\"<<endl;\n\t\t\n\t\tfor(int i = 1; i <= n && flag; i++){\n\t\t\t// cout<<i<<endl;\n\t\t\tif(graph[i].size() && used[i] == false){\n\t\t\t\tflag = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tcout<<yn(flag)<<endl;\n\t}\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\nint ans,used[1000010];\ntypedef pair<int,int> P;\nvector<P>in[1000010];\nint n,m;\n\nvoid check(int pos){\n  if(used[pos])return;\n  used[pos]=1;\n  for(int i=0;i<in[pos].size();i++){\n    int nx=in[pos][i].first,idx=in[pos][i].second;\n    if(used[nx])continue;\n    in[pos].erase(in[pos].begin()+i);\n    in[nx].erase(in[nx].begin()+idx);\n    check(nx);\n    i=-1;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<1000010;i++)in[i].clear(),used[i]=0;\n\n    ans=0;\n    for(int i=0,a,b;i<m;i++){\n      cin>>a>>b;\n      in[a].push_back(P(b,in[b].size()));\n      in[b].push_back(P(a,in[a].size()-1));\n      if(in[a].size()>=3||in[b].size()>=3) ans=1;\n    }\n\n \n    for(int i=1;i<=n;i++) check(i);\n    for(int i=0;i<=n;i++) ans=max(ans,(int)in[i].size());\n    cout <<(!ans? \"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld =long double;\nconst ld eps = 1e-9;\n\nbool check(const vector<vector<pair<int, int>>>&humans, int x, int y) {\n\tfor (int i = 0; i < 4; ++i) {\n\t\tauto it=find(humans[i].begin(),humans[i].end(),make_pair(x,y));\n\t\tif(it!=humans[i].end())return false;\n\t}\n\treturn true;\n}\nint dx[] = { -1,0,1,0,0 };\nint dy[] = { 0,1,0,-1,0 };\n\ntemplate<typename T> struct Compress {\n\tmap<T, int>mp;\n\tmap<int, T>revmp;\n\n\tCompress(vector<T>vs) {\n\t\tsetmp(vs);\n\t}\n\n\tCompress() :mp(), revmp() {\n\n\t}\n\tvoid setmp(vector<T>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < static_cast<int>(vs.size()); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\n};\nstruct sale {\n\tint id;\n\tint d;\n\tint s;\n\tint e;\n};\n\nstruct aa {\n\tint flag;\n\tint x;\n\tint y;\n\tint cost;\n};\n\nbool operator <(const vector<int>&l, const vector<int>&r) {\n\tfor (int i = 0; i < l.size(); ++i) {\n\t\tif(l[i]<r[i])return true;\n\t\telse if(l[i]>r[i])return false;\n\t}\n\treturn false;\n}\nint solve(vector<int>haves, vector<int>nums) {\n\tmap<pair<vector<int>,int>,int>mp;\n\tmp[make_pair(nums,0)]=1;\n\n\tint ans=1;\n\tqueue<pair<vector<int>,int>>que;\n\tque.push(make_pair(nums,0));\n\twhile (!que.empty()) {\n\t\tauto atop(que.front());\n\t\tque.pop();\n\n\t\tint x=atop.second;\n\t\tvector<int>v(atop.first);\n\n\t\tint cost=mp[make_pair(atop.first,atop.second)];\n\t\tans=max(ans,cost);\n\t\tfor (int i = 0; i < haves.size(); ++i) {\n\t\t\tif (v[i]){\n\t\t\t\tif (x+haves[i] >= 11) {\n\n\t\t\t\t}\n\t\t\t\telse if (x + haves[i] == 10) {\n\t\t\t\t\tv[i]--;\n\t\t\t\t\tauto np=make_pair(v,0);\n\t\t\t\t\tif (mp[np] < cost + 1) {\n\t\t\t\t\t\tmp[np]=cost+1;\n\t\t\t\t\t\tque.push(np);\n\t\t\t\t\t}\n\t\t\t\t\tv[i]++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv[i]--;\n\t\t\t\t\tauto np=make_pair(v,x+haves[i]);\n\t\t\t\t\tif (mp[np] < cost) {\n\t\t\t\t\t\tmp[np]=cost;\n\t\t\t\t\t\tque.push(np);\n\t\t\t\t\t}\n\t\t\t\t\tv[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans-1;\n}\n\nint main()\n{\n\twhile (true) {\n\t\tint N,M;cin>>N>>M;\n\t\tif(!N)break;\n\t\tvector<vector<int>>edges(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a,b;cin>>a>>b;\n\t\t\tedges[a-1].push_back(b);\n\t\t\tedges[b-1].push_back(a);\n\t\t}\n\t\tbool ok = all_of(edges.begin(), edges.end(), [](const vector<int>&v) {return v.size() <= 2; });\n\t\tif(ok)cout<<\"yes\"<<endl;\n\t\telse cout<<\"no\"<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_V = 100010;\nconst string YES = \"yes\";\nconst string NO  = \"no\";\n\nint V,E;\nint degree[MAX_V];\nint par[MAX_V],ones[MAX_V],two[MAX_V];\n\nint find(int x) { \n  if( x == par[x] ) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nvoid compute(){\n  if( E >= V ) { cout << NO << endl; return; }\n  rep(i,V) if( degree[i] >= 3 ) { cout << NO << endl; return; }\n  rep(i,V) {\n    int group_index = find(i);\n    if( degree[i] == 1 ) ++ones[group_index];\n    else if( degree[i] == 2 ) ++two[group_index];\n  }\n  rep(i,V) if( ones[i] >= 3 ) { cout << NO << endl; return; }\n  cout << YES << endl;\n}\n\nint main(){\n  int u,v;\n  while( scanf(\"%d %d\",&V,&E), V|E ){\n    rep(i,V) degree[i] = ones[i] = two[i] = 0, par[i] = i;\n    typedef pair<int,int> ii;\n    set<ii> S;\n    bool success = true;\n    rep(i,E){\n      scanf(\"%d %d\",&u,&v);\n      --u, --v;\n      if( u > v ) swap(u,v);\n      ++degree[u], ++degree[v];\n      if( u == v ) success = false;\n      if( S.count(ii(u,v)) ) success = false;\n      S.insert(ii(u,v));\n      unit(u,v);\n    }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nbool dfs(int node, int prenode, vector< vector< int > > &becky, vector<bool> &used){\n  bool res = true;\n  used[node] = 1;\n  for(int i=0; i < (signed int)becky[node].size(); i++){\n    if(becky[node][i] != prenode && used[becky[node][i]]){\n      return false;\n    }\n    if(used[becky[node][i]] == false)\n      res = dfs(becky[node][i], node, becky, used);\n    if(res == false) break;\n  }\n  return res;\n}\n\nint main(void){\n  int n, m;\n  while(cin >> n >> m, n | m){\n    vector< vector< int > > becky(n);\n    vector<bool> used(n, 0);\n    for(int i=0; i < m; i++){\n      int a, b; cin >> a >> b;\n      a--; b--;\n      becky[a].push_back(b);\n      becky[b].push_back(a);\n    }\n\n    bool ans = true;\n    for(int i=0; i < n; i++){\n      if(becky[i].size() >= 3){\n\tans = false;\n\tbreak;\n      }\n    }\n\n\n    for(int i=0; i < n; i++){\n      if(ans && used[i] == false){\n\tans = dfs(i, -1, becky, used);\n      }\n    }\n    if(ans) cout << \"yes\" << endl;\n    else    cout << \"no\"  << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int MAX_V = 100010;\nconst string YES = \"yes\";\nconst string NO  = \"no\";\n\nint V,E;\nint degree[MAX_V];\nint par[MAX_V],ones[MAX_V],two[MAX_V];\n\nint find(int x) { \n  if( x == par[x] ) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nvoid compute(){\n  //if( E >= V ) { cout << NO << endl; return; }\n  rep(i,V) if( degree[i] >= 3 ) { cout << NO << endl; return; }\n  rep(i,V) {\n    int group_index = find(i);\n    if( degree[i] == 1 ) ++ones[group_index];\n    else if( degree[i] == 2 ) ++two[group_index];\n  }\n  rep(i,V) if( ones[i] >= 3 ) { cout << NO << endl; return; }\n  cout << YES << endl;\n}\n\nint main(){\n  int u,v;\n  while( scanf(\"%d %d\",&V,&E), V|E ){\nassert( V < MAX_V );\n    rep(i,V) degree[i] = ones[i] = two[i] = 0, par[i] = i;\n    typedef pair<int,int> ii;\n    set<ii> S;\n    bool success = true;\n    rep(i,E){\n      scanf(\"%d %d\",&u,&v);\n      --u, --v;\n      if( u > v ) swap(u,v);\n      ++degree[u], ++degree[v];\n      if( u == v ) success = false;\n      if( S.count(ii(u,v)) ) success = false;\n      S.insert(ii(u,v));\n      unit(u,v);\n    }\n    if( !success ) { cout << NO << endl; continue; }\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n#define int long long\n\nconst int SIZE=100010;\nbool used[SIZE];\n\nbool bfs(int s,vector<vector<int> >& G)\n{\n   used[s]=true;\n   queue<int> Q;\n   Q.push(s);\n\n   bool ok=true;\n   bool all2=true;\n   while(!Q.empty()){\n      int v=Q.front(); Q.pop();\n      //check\n      if((int)G[v].size()>=3) ok=false;\n      if((int)G[v].size()<2) all2=false;\n\n      for(int u:G[v]){\n         if(!used[u]){\n            used[u]=true;\n            Q.push(u);\n         }\n      }\n   }\n   return (ok and !all2);\n}\n\nsigned main()\n{\n   while(true){\n      int N,M; cin>>N>>M;\n      if(N==0 and M==0) break;\n\n      vector<vector<int> > G;\n      G.resize(N);\n      REP(i,M){\n         int a,b; cin>>a>>b;\n         a--; b--;\n         G[a].push_back(b);\n         G[b].push_back(a);\n      }\n\n      REP(i,N) used[i]=false;\n      bool ok=true;\n      REP(i,N){\n         if(!used[i]){\n            if(!bfs(i,G)) ok=false;\n         }\n      }\n      cout<<(ok? \"yes\":\"no\")<<endl;\n   }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define check(a) if(!(a)){f = false;}\nusing namespace std;\ntypedef vector<int> vi;\n\nclass UnionFind{\n  vi p,r;\npublic:\n  UnionFind(int n):p(n,-1),r(n,0){ }\n  int find(int x){ return (p[x]<0)?x:(p[x] = find(p[x])); }\n  bool same(int x,int y){return find(x)==find(y);}\n  void unite(int x,int y){\n    x = find(x); y = find(y);\n    if(x==y)return;\n\n    if(r[x] < r[y])p[x] = y;\n    else p[y] = x;\n    if(r[x] == r[y])r[x]++;\n  }\n};\n\nint main(){\n  int n,m;\n  while(scanf(\"%d%d\",&n,&m), n){\n    vi deg(n,0);\n    UnionFind uf(n);\n\n    bool f = true;\n    rep(i,m){\n      int a,b;\n      scanf(\"%d%d\",&a,&b); a--; b--;\n      check(++deg[a]<=2);\n      check(++deg[b]<=2);\n      check(!uf.same(a,b));\n      uf.unite(a,b);\n    }\n\n    if(f)puts(\"yes\");\n    else puts(\"no\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define int4(v, x, y, z) int v, x, y, z; scanf(\"%d%d%d%d\", &v, &x, &y, &z)\n#define int5(v, w, x, y, z) int v, w, x, y, z; scanf(\"%d%d%d%d%d\", &v, &w, &x, &y, &z)\n#define ll2(x, y) ll x, y; cin >> x >> y;\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << (x) << \"\\n\"\n#define pri2(x, y) cout << (x) << \" \" << (y) << \"\\n\"\n#define pri3(x, y, z) cout << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define endl \"\\n\"\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << (x) << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << (x) << \" \" << (y) << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << (x) << \" \" << (y) << \" \" << (z) << \"\\n\"\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstruct unionfind{\n\tvector<int> data;\n\tvoid use(int n){ data.assign(n, -1); }\n  void reset(void){ data.clear(); }\n\tbool unionset(int x, int y){\n\t\tx = root(x); y = root(y);\n\t\tif(x != y){\n\t\t\tif(data[y] < data[x])swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findset(int x, int y){ return root(x) == root(y); }\n\tint root(int x){ return (data[x] < 0) ? x : data[x] = root(data[x]); }\n\tint size(int x){ return -data[root(x)]; }\n};\n\nsigned main(void){\n  int i, j;\n  unionfind U;\n  int x[1000000], y[1000000];\n  for(int testcase = 0;testcase >= 0;testcase++){\n    int2(n, m);\n    if(!(n | m))break;\n\n    rep(i, m)scanf(\"%d%d\", &x[i], &y[i]);\n    U.use(n);\n    rep(i, m){\n      --x[i]; --y[i];\n      if(U.findset(x[i], y[i])){\n        puts(\"no\");\n        break;\n      }else{\n        U.unionset(x[i], y[i]);\n      }\n    }\n    if(i == m)puts(\"yes\");\n    U.reset();\n\n//*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\nvector<int> par;\nint root(int x) {\n\tif (x == par[x]) return x;\n\treturn par[x] = root(par[x]);\n}\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(false);\n\tint N, M;\n\twhile (cin >> N >> M, N) {\n\t\tvector<int> deg(N, 0);\n\t\tpar.resize(N);\n\t\tfor (int i = 0; i < N; ++i) par[i] = i;\n\t\tbool ans = true;\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b; --a, --b;\n\t\t\tif (++deg[a] >= 3 || ++deg[b] >= 3 || root(a) == root(b)) ans = false;\n\t\t\tpar[root(a)] = root(b);\n\t\t}\n\t\tcout << (ans ? \"yes\\n\" : \"no\\n\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#define N 100000\nusing namespace std;\nint par[N],ran[N];\nbool visited[N];\n\nint find(int x){\n  if(par[x]==x) return x;\n  else return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  if(x<y) swap(x,y);\n  x=find(x);\n  y=find(y);\n  if(x==y) return;\n  if(ran[x]<ran[y]) par[x]=y;\n  else{\n    par[y]=x;\n    if(ran[x]==ran[y]) ran[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nint main(){\n  int n,m,u,v,flag,f2;\n  vector<int> edge[N];\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m) break;\n    for(int i=0;i<m;i++){\n      cin>>u>>v;\n      edge[u-1].push_back(v-1);\n      edge[v-1].push_back(u-1);\n    }\n    flag=f2=0;\n    for(int i=0;i<n;i++){\n      if(edge[i].size()>=3) flag=1;\n      if(edge[i].size()==2) f2=1;\n    }\n    if(f2&&!flag){\n      for(int i=0;i<n;i++) par[i]=i,ran[i]=0;\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<edge[i].size();j++){\n\t  if(visited[edge[i][0]]&&visited[edge[i][1]]&&j==1&&same(edge[i][0],edge[i][1])) flag=1;\n\t}\n\tif(flag==0){\n\t  for(int j=0;j<edge[i].size();j++) unite(i,edge[i][j]);\n\t}\n\tvisited[i]=true;\n      }\n    }\n    if(flag) cout<<\"no\"<<endl;\n    else cout<<\"yes\"<<endl;\n    for(int i=0;i<n;i++) edge[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint s[1000010];\nint main(){\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<1000010;i++)s[i]=0;\n    for(int i=0;i<m;i++){\n      int a,b;\n      cin>>a>>b;\n      if(a>b) swap(a,b);\n      s[a+1]++,s[b]--;\n    }\n    for(int i=1;i<=n;i++) s[i]+=s[i-1];\n    int ans=1;\n    for(int i=0;i<=n;i++)if(s[i]>=2)ans=0;\n    cout <<(ans? \"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint ans,used[1000010];\ntypedef pair<int,int> P;\nvector<P>in[1000010];\nint n,m;\n\nvoid check(int pos){\n  if(used[pos])return;\n  used[pos]=1;\n  if(in[pos].size()>=3)ans=1;\n  for(int i=0;i<in[pos].size();i++){\n    int nx=in[pos][i].first,idx=in[pos][i].second;\n    in[pos].erase(in[pos].begin()+i);\n    in[nx].erase(in[nx].begin()+idx);\n    check(nx);\n    i--;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<1000010;i++)in[i].clear(),used[i]=0;\n    ans=0;\n    for(int i=0,a,b;i<m;i++){\n      cin>>a>>b;\n      if(a>b) swap(a,b);\n      in[a].push_back(P(b,in[b].size()));\n      in[b].push_back(P(a,in[a].size()-1));\n      if(in[a].size()>=3||in[b].size()) ans=1;\n    }\n\n \n    for(int i=1;i<=n;i++) check(i);\n    for(int i=0;i<n;i++) ans=max(ans,(int)in[i].size());\n    cout <<(!ans? \"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nclass UnionFindTree\n{\nprivate:\n    const int n;\n    int groupNum;       // ??°??????????????°\n    vector<int> parent; // ????????????\n    vector<int> rank;   // ??¨??????????????????\n    vector<int> num;    // ??°????????????????´???°\n    int find(int i){\n        if(parent[i] == i)\n            return i;\n        else\n            return parent[i] = find(parent[i]);\n    }\npublic:\n    UnionFindTree(int n) : n(n){ // ?????????????????????\n        groupNum = n;\n        parent.resize(n);\n        for(int i=0; i<n; ++i)\n            parent[i] = i;\n        rank.assign(n, 0);\n        num.assign(n, 1);\n    }\n    void unite(int a, int b){ // a??¨b?????°??????????????????\n        if((a = find(a)) != (b = find(b))){\n            if(rank[a] < rank[b]){\n                parent[a] = b;\n                num[b] += num[a];\n            }\n            else{\n                parent[b] = a;\n                if(rank[a] == rank[b])\n                    ++ rank[a];\n                num[a] += num[b];\n            }\n            -- groupNum;\n        }\n    }\n    bool same(int a, int b){ // a??¨b?????°?????????????????????????????????\n        return find(a) == find(b);\n    }\n    int getNum(){ // ??°??????????????°?????????\n        return groupNum;\n    }\n    int getNum(int a){ // a?????°????????????????´???°?????????\n        return num[find(a)];\n    }\n};\n\nbool solve(const vector<vector<int> >& edges)\n{\n    int n = edges.size();\n\n    UnionFindTree uft(n);\n    for(int a=0; a<n; ++a){\n        if(edges[a].size() > 2)\n            return false;\n        for(int b : edges[a]){\n            if(a < b){\n                if(uft.same(a, b))\n                    return false;\n                uft.unite(a, b);\n            }\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > edges(n);\n        for(int i=0; i<m; ++i){\n            int u, v;\n            cin >> u >> v;\n            -- u;\n            -- v;\n            edges[u].push_back(v);\n            edges[v].push_back(u);\n        }\n\n        if(solve(edges))\n            cout << \"yes\" << endl;\n        else\n            cout << \"no\" << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define REP(i,N) for(int i=0;i<(N);++i)\nusing namespace std;\nint main(){\n  int n,m;\n  while(cin>>n>>m&&n!=0){\n    vector<int> count(n);\n    REP(i,m){\n      int a,b;\n      cin>>a>>b;\n      ++count[a];\n      ++count[b];\n    }\n    int check[3]={0};\n    bool flag = true;\n    REP(i,n){\n      if(count[i]>=3){\n        flag=false;\n        continue;\n      }\n      ++check[count[i]];\n    }\n    if(check[1]>2){\n      flag=false;\n    }\n    cout << (flag?\"yes\":\"no\") << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nvector<int>G[10000];\nbool used[100000];\n\nbool dfs(int v,int p){\n    used[v]=true;\n    bool ret=true;\n\n    for(int i=0;i<G[v].size();i++){\n        int to=G[v][i];\n        if(to==p)continue;\n        if(used[to])return false;\n        ret&=dfs(to,v);\n    }\n    return ret;\n}\n\nint main(){\n    while(cin>>N>>M,N||M){\n        fill_n(G,N,vector<int>());\n        for(int i=0;i<M;i++){\n            int a,b;cin>>a>>b;\n            a--;b--;\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n        fill_n(used,N,false);\n        bool ret=true;\n\n        for(int i=0;i<N;i++)if(!used[i]&&G[i].size()<=1){\n            ret&=dfs(i,-1);\n        }\n\n        for(int i=0;i<N;i++)if(!used[i])ret=false;\n        if(ret)cout<<\"yes\"<<endl;\n        else cout<<\"no\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> P;\nint ans,used[100010];\nvector<P>in[100010];\nint n,m;\n\nvoid check(int pos){\n  if(used[pos]||!ans)return;\n  used[pos]=1;\n  for(int i=0;i<in[pos].size();i++){\n    int nx=in[pos][i].first,idx=in[pos][i].second;\n    if(used[nx])ans=0;\n    in[pos].erase(in[pos].begin()+i);\n    in[nx].erase(in[nx].begin()+idx);\n    check(nx);\n    i=-1;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<=n;i++)in[i].clear(),used[i]=0;\n\n    ans=1;\n    for(int i=0,a,b;i<m;i++){\n      cin>>a>>b;\n      in[a].push_back(P(b,in[b].size()));\n      in[b].push_back(P(a,in[a].size()-1));\n      if(in[a].size()/3||in[b].size()/3) ans=0;\n    }\n    \n    for(int i=1;i<=n;i++) check(i);\n    cout <<(ans? \"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nvector<int>G[10000];\nbool used[100000];\n\nbool dfs(int v,int p){\n    used[v]=true;\n    bool ret=true;\n\n    for(int i=0;i<G[v].size();i++){\n        int to=G[v][i];\n        if(to==p)continue;\n        if(used[to])return false;\n        ret&=dfs(to,v);\n    }\n    return ret;\n}\n\nint main(){\n    while(cin>>N>>M,N||M){\n        fill_n(G,N,vector<int>());\n        for(int i=0;i<M;i++){\n            int a,b;cin>>a>>b;\n            a--;b--;\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n        if(M>=N){\n            cout<<\"no\"<<endl;\n            continue;\n        }\n        fill_n(used,N,false);\n        bool ret=true;\n\n        for(int i=0;i<N;i++){\n            if(G[i].size()>2)ret=false;\n            if(G[i].size()>=2)continue;\n            if(used[i])continue;\n            ret&=dfs(i,-1);\n        }\n\n        for(int i=0;i<N;i++)if(!used[i])ret=false;\n        if(ret)cout<<\"yes\"<<endl;\n        else cout<<\"no\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 100000\n\nvector<int> G[MAX];\nbool visited[MAX];\n\nvoid init()\n{\n    for (int i = 0; i < MAX; i++) {\n        G[i].clear();\n        visited[i] = 0;\n    }\n}\n\nvoid dfs(int v)\n{\n    for (int i = 0; i < (int)G[v].size(); i++) {\n        int to = G[v][i];\n        if (!visited[to]) {\n            visited[to] = 1;\n            dfs(to);\n        }\n    }\n}\n\nbool check(int N)\n{\n    for (int i = 0; i < N; i++) {\n        if (G[i].size() >= 3) return 0;\n        if (!visited[i] && G[i].size() <= 1) {\n            visited[i] = 1;\n            dfs(i);\n        }        \n    }\n    return (count(visited, visited + N, 0) == 0);\n}\n\nint main()\n{\n    int N, M;\n    while (cin >> N >> M, N) {\n        int a, b;\n        init();\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b;\n            a--; b--;\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n        cout << (check(N) ? \"yes\" : \"no\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\nclass UnionFind {\n    int n;\n    vector<int> uni;\n    int forest_size;\npublic:\n    explicit UnionFind(int n) : n(n), uni(static_cast<u32>(n), -1), forest_size(n) {};\n\n    int root(int a){\n        if (uni[a] < 0) return a;\n        else return (uni[a] = root(uni[a]));\n    }\n\n    bool unite(int a, int b) {\n        a = root(a);\n        b = root(b);\n        if(a == b) return false;\n        if(uni[a] > uni[b]) swap(a, b);\n        uni[a] += uni[b];\n        uni[b] = a;\n        forest_size--;\n        return true;\n    }\n    int size(){ return forest_size; }\n    int size(int i){ return -uni[root(i)]; }\n    bool same(int a, int b) { return root(a) == root(b); }\n};\n\nvoid solve(int n, int m){\n    vector<int> deg(n);\n    UnionFind uf(n);\n    int ok = 1;\n    for (int i = 0; i < m; ++i) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        a--; b--;\n        if(!uf.unite(a, b)) ok = 0;\n\n        deg[a]++; deg[b]++;\n    }\n    for (int i = 0; i < n; ++i) {\n        if(deg[i] > 2) ok = 0;\n    }\n    puts(ok ? \"yes\" : \"no\");\n};\n\nint main() {\n    int n, m;\n    while(cin >> n >> m, n) solve(n, m);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint s[1000010];\nint main(){\n  while(1){\n    int n,m;\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<1000010;i++)s[i]=0;\n    for(int i=0;i<m;i++){\n      int a,b;\n      cin>>a>>b;\n      s[a+1]++,s[b]--;\n    }\n    for(int i=1;i<=n;i++) s[i]+=s[i-1];\n    int ans=1;\n    for(int i=0;i<=n;i++)if(s[i]>=2)ans=0;\n    cout <<(ans? \"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef pair<int,int> P;\nint ans,used[1000010];\nvector<P>in[1000010];\nint n,m;\n\nvoid check(int pos){\n  if(used[pos])return;\n  used[pos]=1;\n  for(int i=0;i<in[pos].size();i++){\n    int nx=in[pos][i].first,idx=in[pos][i].second;\n    if(used[nx])ans=1;\n    in[pos].erase(in[pos].begin()+i);\n    in[nx].erase(in[nx].begin()+idx);\n    check(nx);\n    i=-1;\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<=n;i++)in[i].clear(),used[i]=0;\n\n    ans=0;\n    for(int i=0,a,b;i<m;i++){\n      cin>>a>>b;\n      in[a].push_back(P(b,in[b].size()));\n      in[b].push_back(P(a,in[a].size()-1));\n      if(in[a].size()/3||in[b].size()/3) ans=1;\n    }\n    \n    for(int i=1;i<=n;i++) check(i);\n    //    for(int i=1;i<=n;i++) ans+=in[i].size();\n    cout <<(ans? \"no\":\"yes\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld =long double;\nconst ld eps = 1e-9;\n\nbool check(const vector<vector<pair<int, int>>>&humans, int x, int y) {\n\tfor (int i = 0; i < 4; ++i) {\n\t\tauto it=find(humans[i].begin(),humans[i].end(),make_pair(x,y));\n\t\tif(it!=humans[i].end())return false;\n\t}\n\treturn true;\n}\nint dx[] = { -1,0,1,0,0 };\nint dy[] = { 0,1,0,-1,0 };\n\ntemplate<typename T> struct Compress {\n\tmap<T, int>mp;\n\tmap<int, T>revmp;\n\n\tCompress(vector<T>vs) {\n\t\tsetmp(vs);\n\t}\n\n\tCompress() :mp(), revmp() {\n\n\t}\n\tvoid setmp(vector<T>vs) {\n\t\tsort(vs.begin(), vs.end());\n\t\tvs.erase(unique(vs.begin(), vs.end()), vs.end());\n\t\tfor (int i = 0; i < static_cast<int>(vs.size()); ++i) {\n\t\t\tmp[vs[i]] = i;\n\t\t\trevmp[i] = vs[i];\n\t\t}\n\t}\n\n};\nstruct sale {\n\tint id;\n\tint d;\n\tint s;\n\tint e;\n};\n\nstruct aa {\n\tint flag;\n\tint x;\n\tint y;\n\tint cost;\n};\n\nbool operator <(const vector<int>&l, const vector<int>&r) {\n\tfor (int i = 0; i < l.size(); ++i) {\n\t\tif(l[i]<r[i])return true;\n\t\telse if(l[i]>r[i])return false;\n\t}\n\treturn false;\n}\nint solve(vector<int>haves, vector<int>nums) {\n\tmap<pair<vector<int>,int>,int>mp;\n\tmp[make_pair(nums,0)]=1;\n\n\tint ans=1;\n\tqueue<pair<vector<int>,int>>que;\n\tque.push(make_pair(nums,0));\n\twhile (!que.empty()) {\n\t\tauto atop(que.front());\n\t\tque.pop();\n\n\t\tint x=atop.second;\n\t\tvector<int>v(atop.first);\n\n\t\tint cost=mp[make_pair(atop.first,atop.second)];\n\t\tans=max(ans,cost);\n\t\tfor (int i = 0; i < haves.size(); ++i) {\n\t\t\tif (v[i]){\n\t\t\t\tif (x+haves[i] >= 11) {\n\n\t\t\t\t}\n\t\t\t\telse if (x + haves[i] == 10) {\n\t\t\t\t\tv[i]--;\n\t\t\t\t\tauto np=make_pair(v,0);\n\t\t\t\t\tif (mp[np] < cost + 1) {\n\t\t\t\t\t\tmp[np]=cost+1;\n\t\t\t\t\t\tque.push(np);\n\t\t\t\t\t}\n\t\t\t\t\tv[i]++;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv[i]--;\n\t\t\t\t\tauto np=make_pair(v,x+haves[i]);\n\t\t\t\t\tif (mp[np] < cost) {\n\t\t\t\t\t\tmp[np]=cost;\n\t\t\t\t\t\tque.push(np);\n\t\t\t\t\t}\n\t\t\t\t\tv[i]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans-1;\n}\nint dfs(const int now, const int pre,const vector<vector<int>>&edges, vector<int>&memo) {\n\tif(memo[now])return false;\n\telse {\n\t\tmemo[now]=true;\n\t\tfor (auto e : edges[now]) {\n\t\t\tif (e != pre) {\n\t\t\t\tint k=dfs(e,now,edges,memo);\n\t\t\t\tif(!k)return false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\nint main()\n{\n\twhile (true) {\n\t\tint N,M;cin>>N>>M;\n\t\tif(!N)break;\n\t\tvector<vector<int>>edges(N);\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint a,b;cin>>a>>b;\n\t\t\tedges[a-1].push_back(b-1);\n\t\t\tedges[b-1].push_back(a-1);\n\t\t}\n\t\tbool ok = all_of(edges.begin(), edges.end(), [](const vector<int>&v) {return v.size() <= 2; });\n\n\t\tvector<int>memo(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tif (!memo[i]) {\n\t\t\t\tint k=dfs(i,-1,edges,memo);\n\t\t\t\tif(!k)ok=false;\n\t\t\t}\n\t\t}\n\t\tif(ok)cout<<\"yes\"<<endl;\n\t\telse cout<<\"no\"<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n\nvector<vector<int> > e;\nbool check[100100];\n\nbool foo(int n, int pre) {\n\tif(check[n])\n\t\treturn false;\n\tcheck[n] = true;\n\tif(e[n].size() > 2)\n\t\treturn false;\n\tfor(int i = 0; i < e[n].size(); i++) {\n\t\tif(e[n][i] != pre)\n\t\t\treturn foo(e[n][i], n);\n\t}\n\treturn true;\n}\n\nint main() {\n\tint n, m;\n\twhile(cin >> n >> m, n || m) {\n\t\te.clear();\n\t\te.resize(n);\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint a, b;\n\t\t\tcin >> a >> b;\n\t\t\ta--; b--;\n\t\t\te[a].push_back(b);\n\t\t\te[b].push_back(a);\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tcheck[i] = false;\n\t\tbool flg = true;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(!check[i])\n\t\t\t\tflg &= foo(i, -1);\n\t\t}\n\t\tcout << (flg ? \"yes\" : \"no\") << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint ans,used[1000010];\nvector<int>in[1000010];\nint n,m;\n\nint check(int pos){\n  if(used[pos]) return 0;\n  used[pos]=1;\n  while(1){\n    int f=1;\n    for(int i=1;i<=n;i++) \n      for(int j=0;j<in[i].size();j++) {\n\tf=0,in[i].erase(in[i].begin()+j);\n\tif(!check(in[i][j]))return 0;\n      }\n    if(f)return 1;\n  }\n  return -1;\n}\n\nint main(){\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m)break;\n    for(int i=0;i<1000010;i++)in[i].clear(),used[i]=0;\n    for(int i=0,a,b;i<m;i++){\n      cin>>a>>b;\n      if(a>b) swap(a,b);\n      in[a].push_back(b);\n    }\n    cout <<(check(1)? \"yes\":\"no\")<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#define N 100000\nusing namespace std;\nint par[N],ran[N];\nbool visited[N];\n\nint find(int x){\n  if(par[x]==x) return x;\n  else return par[x]=find(par[x]);\n}\n\nvoid unite(int x,int y){\n  if(x<y) swap(x,y);\n  x=find(x);\n  y=find(y);\n  if(x==y) return;\n  if(ran[x]<ran[y]) par[x]=y;\n  else{\n    par[y]=x;\n    if(ran[x]==ran[y]) ran[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nint main(){\n  int n,m,u,v,flag,f2;\n  vector<int> edge[N];\n  while(1){\n    cin>>n>>m;\n    if(!n&&!m) break;\n    for(int i=0;i<m;i++){\n      cin>>u>>v;\n      edge[u-1].push_back(v-1);\n      edge[v-1].push_back(u-1);\n    }\n    flag=f2=0;\n    for(int i=0;i<n;i++){\n      if(edge[i].size()>=3) flag=1;\n      if(edge[i].size()==2) f2=1;\n    }\n    if(f2&&!flag){\n      for(int i=0;i<n;i++) par[i]=i,ran[i]=0;\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<edge[i].size();j++){\n\t  if(visited[edge[i][0]]&&visited[edge[i][1]]&&j==1&&same(edge[i][0],edge[i][1])) flag=1;\n\t  else unite(i,edge[i][j]);\n\t}\n\tvisited[i]=true;\n      }\n    }\n    if(flag) cout<<\"no\"<<endl;\n    else cout<<\"yes\"<<endl;\n    for(int i=0;i<n;i++) edge[i].clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\nvector<int>G[100000];\nbool used[100000];\n\nbool dfs(int v,int p){\n    used[v]=true;\n    bool ret=true;\n\n    for(int i=0;i<G[v].size();i++){\n        int to=G[v][i];\n        if(to==p)continue;\n        if(used[to])return false;\n        ret&=dfs(to,v);\n    }\n    return ret;\n}\n\nint main(){\n    while(cin>>N>>M,N||M){\n        fill_n(G,N,vector<int>());\n        for(int i=0;i<M;i++){\n            int a,b;cin>>a>>b;\n            a--;b--;\n            G[a].push_back(b);\n            G[b].push_back(a);\n        }\n        if(M>=N){\n            cout<<\"no\"<<endl;\n            continue;\n        }\n        fill_n(used,N,false);\n        bool ret=true;\n\n        for(int i=0;i<N;i++){\n            if(G[i].size()>2)ret=false;\n            if(G[i].size()>=2)continue;\n            if(used[i])continue;\n            ret&=dfs(i,-1);\n        }\n\n        for(int i=0;i<N;i++)if(!used[i])ret=false;\n        if(ret)cout<<\"yes\"<<endl;\n        else cout<<\"no\"<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define check(a) if(!(a)){f = false;}\nusing namespace std;\ntypedef vector<int> vi;\n\nclass UnionFind{\n  vi p,r;\npublic:\n  UnionFind(int n):p(n,-1),r(n,0){ }\n  int find(int x){ return (p[x]<0)?x:(p[x] = find(p[x])); }\n  bool same(int x,int y){return find(x)==find(y);}\n  void unite(int x,int y){\n    x = find(x); y = find(y);\n    if(x==y)return;\n\n    if(r[x] < r[y])p[x] = y;\n    else p[y] = x;\n    if(r[x] == r[y])r[x]++;\n  }\n};\n\nint main(){\n  int n,m;\n  while(cin >> n >> m, n){\n    vi deg(n,0);\n    UnionFind uf(n);\n\n    bool f = true;\n    rep(i,m){\n      int a,b;\n      cin >> a >> b; a--; b--;\n      check(++deg[a]<=2);\n      check(++deg[b]<=2);\n      check(!uf.same(a,b));\n      uf.unite(a,b);\n    }\n\n    if(f)cout << \"yes\" << endl;\n    else cout << \"no\" << endl;\n  }\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0251: Magic Square\n// 2017.12.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 100002\n\n/* UNION-FIND library */\nint p[MAX], rank[MAX];\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1;\t}\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n\nchar f[MAX];\nchar buf[20], *bp;\n\nint in()\n{\n\tint n = 0;\n\twhile (*bp >= '0') n = (n<<3)+(n<<1) + (*bp++ & 0xf);\n\tbp++;\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, a, b, ans;\n\n\twhile (fgets(bp=buf, 20, stdin) && *bp != '0') {\n\t\tn = in(), m = in();\n\n\t\tmemset(rank, 0, sizeof(int)*(n+1));\n\t\tfor (a = 1; a <= n; a++) p[a] = a;\n\t\tmemset(f, 0, n+1);\n\n\t\tans = 1;\n\t\twhile (m--) {\n\t\t\tfgets(bp=buf, 20, stdin);\n\t\t\ta = in(), b = in();\n\t\t\tif (++f[a] > 2) ans = 0;\n\t\t\tif (++f[b] > 2) ans = 0;\n\t\t\tif (find_set(a) == find_set(b)) ans = 0;\n\t\t\tunion_set(a, b);\n\t\t\tif (!ans) break;\n\t\t}\n\t\tif (m > 0) while (m--) fgets(bp=buf, 20, stdin);\n\t\tputs(ans ? \"yes\" : \"no\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdbool.h>\n\n#define REP(i,s,n) for(i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define MAX_V 100001\n\nint V,E;\nint par[MAX_V],degree[MAX_V];\n\nint find(int x) {\n  if( x == par[x] ) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y){\n  x = find(x), y = find(y);\n  if( x != y ) par[x] = y;\n}\n\nvoid swap(int *x,int *y){\n  int temp = *x;\n  *x = *y;\n  *y = temp;\n}\n\nint main(){\n  int i,j,u,v;\n  while( scanf(\"%d %d\",&V,&E), V|E ){\n    rep(i,V) par[i] = i, degree[i] = 0;\n    bool success = true;\n    rep(i,E){\n      scanf(\"%d %d\",&u,&v);\n      --u, --v;\n      if( u > v ) swap(&u,&v);\n      ++degree[u], ++degree[v];\n      if( degree[u] > 2 || degree[v] > 2 ) success = false;\n      if( find(u) == find(v) ) success = false;\n      unit(u,v);\n    }\n    puts(success?\"yes\":\"no\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0251: Magic Square\n// 2017.12.16 bal4u@uu\n// 2018.1.19\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 100002\n\n/* UNION-FIND library */\nint p[MAX], rank[MAX];\n\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1;\t}\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n\nchar f[MAX];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint n, n1, m, a, b, ans;\n\n\twhile (n = in()) {\n\t\tn1 = n + 1, m = in();\n\n\t\tmemset(rank, 0, n1 << 2);\n\t\tfor (a = 1; a <= n; a++) p[a] = a;\n\t\tmemset(f, 0, n1);\n\n\t\tans = 1;\n\t\twhile (m--) {\n\t\t\ta = in(), b = in();\n\t\t\tif (ans) {\t\n\t\t\t\tif (++f[a] > 2) ans = 0;\n\t\t\t\tif (++f[b] > 2) ans = 0;\n\t\t\t\tif (find_set(a) == find_set(b)) ans = 0;\n\t\t\t\tunion_set(a, b);\n\t\t\t}\n\t\t}\n\t\tputs(ans? \"yes\": \"no\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint uf[131072];\n\nvoid resuf(){\n  int i;\n  for(i=0;i<131072;i++){uf[i]=i;}\n}\n\nint find(int v){\n  if(uf[v]==v){return v;}\n  uf[v]=find(uf[v]);\n  return uf[v];\n}\n\nvoid uni(int a,int b){\n  if(find(a)==find(b)){return;}\n  if(rand()%2){\n    uf[find(a)]=find(b);\n  }\n  else{\n    uf[find(b)]=find(a);\n  }\n}\n\nint main(){\n  int n,m,a,b,c[131072],d[131072],e[131072],i,fl;\n  while(scanf(\"%d%d\",&n,&m),n!=0){\n    resuf();\n    fl=1;\n    for(i=1;i<=n;i++){c[i]=0;d[i]=0;e[i]=0;}\n    for(i=0;i<m;i++){\n      scanf(\"%d%d\",&a,&b);\n      if(a<=0 || a>n || b<=0 || b>n){fl=0;continue;}\n      c[a]++;c[b]++;\n      uni(a,b);\n    }\n    for(i=1;i<=n;i++){\n      //printf(\"%d\\n\",find(i));\n      if(c[i]>=3){fl=0;break;}\n      d[find(i)]++;\n      e[find(i)]+=c[i];\n    }\n    for(i=1;i<=n;i++){\n      //printf(\"%d : <%d %d>\\n\",i,d[i],e[i]);\n      if(d[i]==0){continue;}\n      if(e[i]!=2*d[i]-2){fl=0;}\n    }\n    if(fl==1){printf(\"yes\\n\");}\n    else{printf(\"no\\n\");}\n  }\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0251: Magic Square\n// 2017.12.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define HASHSIZ 2000081\ntypedef struct { int a, b; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\n\nint insert(int a, int b)\n{\n\tHASH *p = hash + (((long long)a << 20) | b) % HASHSIZ;\n\twhile (p->a) {\n\t\tif (p->a == a && p->b == b) return 1;\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->a = a, p->b = b;\n\treturn 0;\n}\n\nchar f[100002];\nchar buf[20], *bp;\n\nint in()\n{\n\tint n = 0;\n\twhile (*bp >= '0') n = (n<<3)+(n<<1) + (*bp++ & 0xf);\n\tbp++;\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, a, b, t, ans;\n\n\twhile (fgets(bp=buf, 20, stdin) && *bp != '0') {\n\t\tn = in(), m = in();\n\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tmemset(f, 0, n+1);\n\n\t\tans = 1;\n\t\twhile (m--) {\n\t\t\tfgets(bp=buf, 20, stdin);\n\t\t\ta = in(), b = in();\n\t\t\tif (a == b) ans = 0;\n\t\t\tif (a > b) t = a, a = b, b = a;\n\t\t\tif (++f[a] > 2) ans = 0;\n\t\t\tif (++f[b] > 2) ans = 0;\n\t\t\tif (insert(a, b)) ans = 0;\n\t\t\tif (!ans) break;\n\t\t}\n\t\tif (m > 0) while (m--) fgets(bp=buf, 20, stdin);\n\t\tputs(ans ? \"yes\" : \"no\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0251: Magic Square\n// 2017.12.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 100002\n\n/* UNION-FIND library */\nint p[MAX], rank[MAX];\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1;\t}\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n\nchar f[MAX];\nchar buf[20], *bp;\n\nint in()\n{\n\tint n = 0;\n\twhile (*bp >= '0') n = 10*n + (*bp++ & 0xf);\n\tbp++;\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, a, b, ans;\n\n\twhile (fgets(bp=buf, 20, stdin) && *bp != '0') {\n\t\tn = in(), m = in();\n\n\t\tmemset(rank, 0, sizeof(int)*(n+1));\n\t\tfor (a = 1; a <= n; a++) p[a] = a;\n\t\tmemset(f, 0, n+1);\n\n\t\tans = 1;\n\t\twhile (m--) {\n\t\t\tfgets(bp=buf, 20, stdin);\n\t\t\tif (ans) {\n\t\t\t\ta = in(), b = in();\n\t\t\t\tif (++f[a] > 2) ans = 0;\n\t\t\t\tif (++f[b] > 2) ans = 0;\n\t\t\t\tif (find_set(a) == find_set(b)) ans = 0;\n\t\t\t\tunion_set(a, b);\n\t\t\t}\n\t\t}\n\t\tputs(ans ? \"yes\" : \"no\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0251: Magic Square\n// 2017.12.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define HASHSIZ 2000081\ntypedef struct { int a, b; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash+HASHSIZ;\n\nint insert(int a, int b)\n{\n\tHASH *p = hash + (((long long)a << 20) | b) % HASHSIZ;\n\twhile (p->a) {\n\t\tif (p->a == a && p->b == b) return 1;\n\t\tif (++p == hashend) p = hash;\n\t}\n\tp->a = a, p->b = b;\n\treturn 0;\n}\n\nchar f[100002];\nchar buf[20], *bp;\n\nint in()\n{\n\tint n = 0;\n\twhile (*bp >= '0') n = (n<<3)+(n<<1) + (*bp++ & 0xf);\n\tbp++;\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, a, b, t, ans;\n\n\twhile (fgets(bp=buf, 20, stdin) && *bp != '0') {\n\t\tn = in(), m = in();\n\n\t\tmemset(hash, 0, sizeof(hash));\n\t\tmemset(f, 0, n+1);\n\n\t\tans = 1;\n\t\twhile (m--) {\n\t\t\tfgets(bp=buf, 20, stdin);\n\t\t\ta = in(), b = in();\n\t\t\tif (a == b) ans = 0;\n\t\t\tif (a > b) t = a, a = b, b = t;\n\t\t\tif (++f[a] > 2) ans = 0;\n\t\t\tif (++f[b] > 2) ans = 0;\n\t\t\tif (insert(a, b)) ans = 0;\n\t\t\tif (!ans) break;\n\t\t}\n\t\tif (m > 0) while (m--) fgets(bp=buf, 20, stdin);\n\t\tputs(ans ? \"yes\" : \"no\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0251: Magic Square\n// 2017.12.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\nint a[100001];\nchar buf[20], *p;\n\nint in()\n{\n\tint n = 0;\n\twhile (*p >= '0') n = 10*n + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, i, ans;\n\n\twhile (fgets(p=buf, 20, stdin) && *p != '0') {\n\t\tn = in(), m = in();\n\t\tmemset(a, 0, sizeof(a));\n\t\twhile (m--) {\n\t\t\tfgets(p=buf, 20, stdin);\n\t\t\ta[in()]++, a[in()]++;\n\t\t}\n\n\t\tans = 1;\n\t\tfor (i = 1; i <= n; i++) {\n\t\t\tif (a[i] > 2) { ans = 0; break; }\n\t\t}\n\t\tputs(ans ? \"yes\" : \"no\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0251: Magic Square\n// 2017.12.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 100002\n\n/* UNION-FIND library */\nint p[MAX], rank[MAX];\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1;\t}\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n\nchar f[MAX];\nchar buf[20], *bp;\n\nint in()\n{\n\tint n = 0;\n\twhile (*bp >= '0') n = 10*n + (*bp++ & 0xf);\n\tbp++;\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, a, b, ans;\n\n\twhile (fgets(bp=buf, 20, stdin) && *bp != '0') {\n\t\tn = in(), m = in();\n\n\t\tmemset(rank, 0, sizeof(rank));\n\t\tfor (a = 1; a <= n; a++) p[a] = a;\n\t\tmemset(f, 0, sizeof(f));\n\n\t\tans = 1;\n\t\twhile (m--) {\n\t\t\tfgets(bp=buf, 20, stdin);\n\t\t\tif (ans) {\n\t\t\t\ta = in(), b = in();\n\t\t\t\tif      (f[a] > 1) ans = 0;\n\t\t\t\telse if (f[b] > 1) ans = 0;\n\t\t\t\telse if (find_set(a) == find_set(b)) ans = 0;\n\t\t\t\tif (ans) union_set(a, b), f[a]++, f[b]++;\n\t\t\t}\n\t\t}\n\t\tputs(ans ? \"yes\" : \"no\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 0251: Magic Square\n// 2017.12.16 bal4u@uu\n// 2018.1.19\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 100002\n\n/* UNION-FIND library */\nint id[MAX], size[MAX];\n\nvoid init(int n)\n{\n\tint i;\n\tfor (i = 0; i < n; i++) id[i] = i, size[i] = 1;\n}\n\nint root(int i)\n{\n\twhile (i != id[i]) id[i] = id[id[i]], i = id[i];\n\treturn i;\n}\n\nint connected(int p, int q) { return root(p) == root(q); }\n\nvoid unite(int p, int q)\n{\n    int i = root(p), j = root(q);\n\tif (i == j) return;\n    if (size[i] < size[j]) id[i] = j, size[j] += size[i];\n    else                   id[j] = i, size[i] += size[j];\n}\n\nchar f[MAX];\n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = (n<<3)+(n<<1) + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, a, b, ans;\n\n\twhile (n = in()) {\n\t\tm = in();\n\n\t\tinit(n);\n\t\tmemset(f, 0, n+1);\n\n\t\tans = 1;\n\t\twhile (m--) {\n\t\t\ta = in(), b = in();\n\t\t\tif (ans) {\t\n\t\t\t\tif (++f[a] > 2) ans = 0;\n\t\t\t\tif (++f[b] > 2) ans = 0;\n\t\t\t\tif (connected(a, b)) ans = 0;\n\t\t\t\tunite(a, b);\n\t\t\t}\n\t\t}\n\t\tputs(ans? \"yes\": \"no\");\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 0251: Magic Square\n// 2017.12.16 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX 100001\n\n/* UNION-FIND library */\nint p[MAX], rank[MAX];\nvoid link(int x, int y) {\n\tif (rank[x] > rank[y]) p[y] = x;\n\telse { p[x] = y; if (rank[x] == rank[y]) rank[y] = rank[y] + 1;\t}\n}\nint find_set(int x) { if (x != p[x]) p[x] = find_set(p[x]);\treturn p[x]; }\nvoid union_set(int x, int y) { link(find_set(x), find_set(y)); }\n\nchar f[MAX];\nchar buf[20], *bp;\n\nint in()\n{\n\tint n = 0;\n\twhile (*bp >= '0') n = 10*n + (*bp++ & 0xf);\n\tbp++;\n\treturn n;\n}\n\nint main()\n{\n\tint n, m, i, a, b, ans;\n\n\twhile (fgets(bp=buf, 20, stdin) && *bp != '0') {\n\t\tn = in(), m = in();\n\t\tmemset(rank, 0, sizeof(rank));\n\t\tfor (i = 1; i <= n; i++) p[i] = i;\n\t\tmemset(f, 0, sizeof(f));\n\n\t\tans = 1;\n\t\twhile (m--) {\n\t\t\tfgets(bp=buf, 20, stdin);\n\t\t\tif (ans) {\n\t\t\t\ta = in(), b = in();\n\t\t\t\tif      (f[a] > 2) ans = 0;\n\t\t\t\telse if (f[b] > 2) ans = 0;\n\t\t\t\telse if (find_set(a) == find_set(b)) ans = 0;\n\t\t\t\tif (ans) union_set(a, b), f[a]++, f[b]++;\n\t\t\t}\n\t\t}\n\t\tputs(ans ? \"yes\" : \"no\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,a[100010],b[100010],r[100010],i,d[100010][2],f[100010],s;\n  while(scanf(\"%d %d\",&n,&m),n){\n    for(i=0;i<m;i++)scanf(\"%d %d\",&a[i],&b[i]);\n    if(n<=m)goto END;\n    for(i=0;i<=n;i++)r[i]=f[i]=0;\n    for(i=0;i<m;i++){\n      d[a[i]][r[a[i]]++]=b[i];\n      d[b[i]][r[b[i]]++]=a[i];\n      if(r[a[i]]==3||r[b[i]]==3)goto END;\n    }\n    for(i=1;i<=n;i++){\n      if(r[i]%2==0)continue;\n      r[i]=2;\n      s=i;\n      while(r[s]==2){\n\tr[s]=0;\n\tf[s]=1;\n\tif(f[d[s][0]])s=d[s][1];\n\telse          s=d[s][0];\n      }\n      r[s]=0;\n      f[s]=1;\n    }\n    for(i=0;i<n&&r[i+1]==0;i++);\n    printf(\"%s\\n\",i-n?\"no\":\"yes\");\n    continue;\n  END:;\n    printf(\"no\\n\");\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "Kotlin",
    "code": "\n\nfun main(args:Array<String>):Unit {\n    while (true) {\n        val (n, m) = readLine()!!.trim().split(' ').map(String::toInt)\n        if (n == 0 && m == 0) return\n        val stone = Array(n) { UnionFindTree() }\n        val edgeCount = Array(n){0}\n        var canMake = true\n        repeat(m) {\n            val (u, v) = readLine()!!.trim().split(' ').map(String::toInt)\n            canMake = canMake && !stone[u - 1].isSameUnion(stone[v - 1])\n            stone[u - 1].merge(stone[v - 1])\n            edgeCount[u - 1]++\n            edgeCount[v - 1]++\n        }\n        println(if (canMake && edgeCount.none{it > 2}) \"yes\" else \"no\")\n    }\n}\nclass UnionFindTree{\n    private var mParent:UnionFindTree? = null\n    private fun parent():UnionFindTree {\n        return when(mParent){\n            null -> this\n            else -> {\n                mParent = mParent?.parent()\n                mParent !!\n            }\n        }\n    }\n    fun isSameUnion(other:UnionFindTree):Boolean {\n        return parent() == other.parent()\n    }\n    fun merge(other:UnionFindTree):Unit {\n        if (!isSameUnion(other)){\n            parent().mParent = other.parent()\n        }\n    }\n}\n"
  },
  {
    "language": "Kotlin",
    "code": "\n\nfun main(args:Array<String>):Unit {\n    while (true) {\n        val (n, m) = readLine()!!.trim().split(' ').map(String::toInt)\n        if (n == 0 && m == 0) return\n        val stone = Array(n) { UnionFindTree() }\n        var canMake = true\n        repeat(m) {\n            val (u, v) = readLine()!!.trim().split(' ').map(String::toInt)\n            canMake = canMake && !stone[u - 1].isSameUnion(stone[v - 1])\n            stone[u - 1].merge(stone[v - 1])\n        }\n        println(if (canMake) \"yes\" else \"no\")\n    }\n}\nclass UnionFindTree{\n    private var mParent:UnionFindTree? = null\n    private fun parent():UnionFindTree {\n        return when(mParent){\n            null -> this\n            else -> {\n                mParent = mParent?.parent()\n                mParent !!\n            }\n        }\n    }\n    fun isSameUnion(other:UnionFindTree):Boolean {\n        return parent() == other.parent()\n    }\n    fun merge(other:UnionFindTree):Unit {\n        if (!isSameUnion(other)){\n            parent().mParent = other.parent()\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\n\nnamespace _0251\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] x = Console.ReadLine().Split().Select(int.Parse).ToArray();\n                if (x[0] == 0 && x[1] == 0) break;\n                int[] used = new int[x[0]];\n                for (int i = 0; i < x[1]; i++)\n                {\n                    int[] n = Console.ReadLine().Split().Select(int.Parse).ToArray();\n                    used[n[0] - 1]++; used[n[1] - 1]++;\n                }\n                if (used.Max() < 3)\n                {\n                    int two = 0;\n                    for (int i = 0; i < x[0]; i++)\n                    {\n                        if (used[i] == 2) two++;\n                    }\n                    Console.WriteLine(x[0] - two >= 2 ? \"yes\" : \"no\");\n                }\n                else Console.WriteLine(\"no\");\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0251\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] nm = RArInt();\n                if (nm.Sum() == 0) break;\n                UnionFind uf = new UnionFind(nm[0]);\n                Console.WriteLine(CanDraw(uf, nm) ? \"yes\" : \"no\");\n            }\n\n        }\n\n        private static bool CanDraw(UnionFind uf, int[] nm)\n        {\n            bool res = true;\n            int[] degree = new int[nm[0]];\n            for (int i = 0; i < nm[1]; i++)\n            {\n                int[] vs = RArInt();\n\n                if (res)\n                {\n                    int u = vs[0] - 1;\n                    int v = vs[1] - 1;\n\n                    if (uf.IsSameGroup(u, v)) res = false;\n                    degree[u]++;\n                    degree[v]++;\n                    if (degree[u] >= 3 || degree[v] >= 3) res = false;\n                }\n            }\n            return res;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    class UnionFind\n    {\n        private readonly int[] parents;\n        private readonly int[] rank;\n\n        public UnionFind(int n)\n        {\n            parents = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) parents[i] = i;\n        }\n\n        public int Find(int x)\n        {\n            if (parents[x] == x) return x;\n            else return parents[x] = Find(parents[x]);\n        }\n\n        public void Unite(int x, int y)\n        {\n            x = Find(x);\n            y = Find(y);\n            if (x == y) return;\n\n            if (rank[x] < rank[y])\n            {\n                parents[x] = y;\n            }\n            else\n            {\n                parents[y] = x;\n                if (rank[x] == rank[y]) rank[x]++;\n            }\n        }\n\n        public bool IsSameGroup(int x, int y)\n        {\n            return Find(x) == Find(y);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0251\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int[] nm = RArInt();\n                if (nm.Sum() == 0) break;\n                UnionFind uf = new UnionFind(nm[0]);\n                Console.WriteLine(CanDraw(uf, nm) ? \"yes\" : \"no\");\n            }\n\n        }\n\n        private static bool CanDraw(UnionFind uf, int[] nm)\n        {\n            bool res = true;\n            int[] degree = new int[nm[0]];\n            for (int i = 0; i < nm[1]; i++)\n            {\n                int[] vs = RArInt();\n\n                if (res)\n                {\n                    int u = vs[0] - 1;\n                    int v = vs[1] - 1;\n\n                    if (uf.IsSameGroup(u, v)) res = false;\n                    degree[u]++;\n                    degree[v]++;\n                    if (degree[u] >= 3 || degree[v] >= 3) res = false;\n                    uf.Unite(u, v);\n                }\n            }\n            return res;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RArSt(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RArInt(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RArLong(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RArDouble(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    class UnionFind\n    {\n        private readonly int[] parents;\n        private readonly int[] rank;\n\n        public UnionFind(int n)\n        {\n            parents = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) parents[i] = i;\n        }\n\n        public int Find(int x)\n        {\n            if (parents[x] == x) return x;\n            else return parents[x] = Find(parents[x]);\n        }\n\n        public void Unite(int x, int y)\n        {\n            x = Find(x);\n            y = Find(y);\n            if (x == y) return;\n\n            if (rank[x] < rank[y])\n            {\n                parents[x] = y;\n            }\n            else\n            {\n                parents[y] = x;\n                if (rank[x] == rank[y]) rank[x]++;\n            }\n        }\n\n        public bool IsSameGroup(int x, int y)\n        {\n            return Find(x) == Find(y);\n        }\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "until (n, m = gets.split.map(&:to_i)).all?(&:zero?)\n  degree = Array.new(n, 0)\n  m.times do\n    u, v = gets.split.map{|i| i.to_i - 1}\n    degree[u] += 1\n    degree[v] += 1\n  end\n  puts degree.all?{|i| i <= 2} ? \"yes\" : \"no\"\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n  n, m = gets.split.map(&:to_i)\n  break if n==0 and m==0\n  es = Array.new(n+1){[]}\n  m.times{\n    a, b = gets.split.map(&:to_i)\n    es[a] << b\n    es[b] << a\n  }\n  if m>=n or es.any?{|a| a.size>2}\n    puts \"no\"\n    next\n  end\n  visited = Array.new(n+1){false}\n  dfs = ->x{\n    es[x].each{|y|\n      if not visited[y]\n        visited[y] = true\n        dfs[y]\n      end\n    }\n  }\n  (1..n).each{|i|\n    if es[i].size==0\n      visited[i] = true\n    elsif es[i].size==1\n      visited[i] = true\n      dfs[i]\n    end\n  }\n  visited[0] = true\n  if visited.all?\n    puts \"yes\"\n  else\n    puts \"no\"\n  end\nend\n"
  },
  {
    "language": "Ruby",
    "code": "class UnionFind\n  attr :parent, :rank\n  def initialize\n    @parent = Hash.new\n    @rank = Hash.new\n  end\n  def make(x)\n    @parent[x] = x\n    @rank[x] = 0\n  end\n  def union(a, b)\n    x, y = find(a), find(b)\n    x, y = y, x if @rank[x] < @rank[y]\n    @parent[y] = x\n    @rank[x] += 1 if @rank[x] == @rank[y]\n  end\n  def find(x)\n    @parent[x] == x ? x : @parent[x] = find(@parent[x])\n  end\n  def size\n    @parent.keys.map{|k| find(k)}.sort.uniq.size\n  end\nend\n\nuntil (n, m = gets.split.map(&:to_i)).all?(&:zero?)\n  degree = Array.new(n, 0)\n  set = UnionFind.new\n  n.times do |i| set.make(i) end\n  m.times do\n    u, v = gets.split.map{|i| i.to_i - 1}\n    degree[u] += 1\n    degree[v] += 1\n    set.union(u, v)\n  end\n  puts (degree.all?{|i| i <= 2} && (degree.count{|i| i == 0} + degree.count{|i| i == 1} / 2) == set.size) ? \"yes\" : \"no\"\nend"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\ndef get_par(x, par_lst):\n  if x == par_lst[x]:\n    return x\n  ret = get_par(par_lst[x], par_lst)\n  par_lst[x] = ret\n  return ret\n\ndef main():\n  while True:\n    n, m = map(int, input().split())\n    if n == 0:\n      break\n    par_lst = [i for i in range(n)]\n    counter = Counter()\n    flag = False\n    if m == 0:\n      print(\"yes\")\n      continue\n    for _ in range(m):\n      u, v = map(int, input().split())\n      u -= 1\n      v -= 1\n      counter[u] += 1\n      counter[v] += 1\n      pu, pv = get_par(u, par_lst), get_par(v, par_lst)\n      if pu == pv:\n        flag = True\n      else:\n        par_lst[pu] = pv\n    \n    if counter.most_common()[0][1] > 2:\n      flag = True\n    if flag:\n      print(\"no\")\n    else:\n      print(\"yes\")\nmain()\n"
  },
  {
    "language": "Python",
    "code": "while(1):\n    [n,m]=map(int,raw_input().split())\n    if n==0:    break\n    D=[[] for i in range(n+1)]\n    D[0]=range(1,n+1)\n    nflg=0\n    for i in range(m):\n        [u,v]=map(int,raw_input().split())\n        D[u].append(v)\n        D[v].append(u)\n        if len(D[u])>2 or len(D[v])>2:\n            nflg=1\n    if nflg:\n        print 'no'\n    else:\n        bkf=0\n        while (len(D[0])>0):\n            st=D[0].pop()\n            st0=st\n            while len(D[st])!=0:\n               nxt=D[st].pop()\n               if nxt!=st0:\n                   D[0].remove(nxt)\n                   D[nxt].remove(st)\n                   st=nxt\n               else:\n                   print 'no'\n                   bkf=1\n                   break\n            if bkf:    break\n        else:\n            print 'yes'\n            "
  },
  {
    "language": "Python",
    "code": "from collections import Counter\ndef get_par(x, par_lst):\n  if x == par_lst[x]:\n    return x\n  ret = get_par(par_lst[x], par_lst)\n  par_lst[x] = ret\n  return ret\n\ndef main():\n  while True:\n    n, m = map(int, input().split())\n    if n == 0:\n      break\n    par_lst = [i for i in range(n)]\n    counter = [0] * n\n    flag = False\n    for _ in range(m):\n      u, v = map(int, input().split())\n      u -= 1\n      v -= 1\n      counter[u] += 1\n      counter[v] += 1\n      pu, pv = get_par(u, par_lst), get_par(v, par_lst)\n      if pu == pv:\n        flag = True\n      else:\n        par_lst[pu] = pv\n    \n    if max(counter) > 2:\n      flag = True\n    if flag:\n      print(\"no\")\n    else:\n      print(\"yes\")\nmain()\n"
  },
  {
    "language": "Python",
    "code": "# AOJ 0251: Magic Square\n# Python3 2018.6.25 bal4u\n\n# UNION-FIND library\nclass UnionSet:\n\tdef __init__(self, nmax):\n\t\tself.size = [1]*nmax\n\t\tself.id = [i for i in range(nmax+1)]\n\tdef root(self, i):\n\t\twhile i != self.id[i]:\n\t\t\tself.id[i] = self.id[self.id[i]]\n\t\t\ti = self.id[i]\n\t\treturn i\n\tdef connected(self, p, q): return self.root(p) == self.root(q)\n\tdef unite(self, p, q):\n\t\ti, j = self.root(p), self.root(q)\n\t\tif i == j: return\n\t\tif self.size[i] < self.size[j]:\n\t\t\tself.id[i] = j\n\t\t\tself.size[j] += self.size[i]\n\t\telse:\n\t\t\tself.id[j] = i\n\t\t\tself.size[i] += self.size[j]\n# UNION-FIND library\n\nwhile True:\n\tn, m = map(int, input().split())\n\tif n == 0: break\n\tn += 1\n\tu = UnionSet(n)\n\tf = [0]*n\n\tans = True\n\tfor i in range(m):\n\t\tif ans:\n\t\t\ta, b = map(int, input().split())\n\t\t\tf[a] += 1\n\t\t\tf[b] += 1\n\t\t\tif f[a] > 2: ans = False\n\t\t\tif f[b] > 2: ans = False\n\t\t\tif u.connected(a, b): ans = False\n\t\t\tu.unite(a, b)\n\t\telse: input()\n\tprint(\"yes\" if ans else \"no\")\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import Counter\ndef get_par(x, par_lst):\n  if x == par_lst[x]:\n    return x\n  ret = get_par(par_lst[x], par_lst)\n  #par_lst[x] = ret\n  return ret\n\ndef main():\n  while True:\n    n, m = map(int, input().split())\n    if n == 0:\n      break\n    par_lst = [i for i in range(n)]\n    counter = Counter()\n    flag = False\n    if m == 0:\n      print(\"yes\")\n      continue\n    for _ in range(m):\n      u, v = map(int, input().split())\n      u -= 1\n      v -= 1\n      counter[u] += 1\n      counter[v] += 1\n      pu, pv = get_par(u, par_lst), get_par(v, par_lst)\n      if pu == pv:\n        flag = True\n      else:\n        par_lst[pu] = pv\n    \n    if counter.most_common()[0][1] > 2:\n      flag = True\n    if flag:\n      print(\"no\")\n    else:\n      print(\"yes\")\nmain()\n"
  },
  {
    "language": "Python",
    "code": "while(1):\n    [n,m]=map(int,raw_input().split())\n    if n==0:    break\n    D=[[] for i in range(n+1)]\n    D[0]=range(1,n+1)\n    nflg=0\n    for i in range(m):\n        [u,v]=map(int,raw_input().split())\n        D[u].append(v)\n        D[v].append(u)\n        if len(D[u])>2 or len(D[v])>2:\n            nflg=1\n    if nflg:\n        print 'no'\n    else:\n        bkf=0\n        while (len(D[0])>0):\n            st=D[0].pop()\n            if len(D[st])==2:\n                D[0].append(st)\n            st0=st\n            while len(D[st])!=0:\n               nxt=D[st].pop()\n               if nxt!=st0:\n                   D[0].remove(nxt)\n                   D[nxt].remove(st)\n                   st=nxt\n               else:\n                   print 'no'\n                   bkf=1\n                   break\n            if bkf:    break\n        else:\n            print 'yes'\n            "
  }
]