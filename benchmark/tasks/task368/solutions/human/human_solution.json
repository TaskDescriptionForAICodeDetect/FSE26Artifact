[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nbool dfs(int si, int sj, int i, int j, vector<vector<pair<int, int> > > a, vector<vector<bool> >& used, vector<vector<bool> > & used2){\n\n    \n    if(i == si && j == sj) return true;\n\n    int nexti = a[i][j].first;\n    int nextj = a[i][j].second;\n\n    if(nexti == si && nextj == sj) {\n        used[nexti][nextj] = true;\n        return true;\n    }\n\n    used2[i][j] = true;\n    if(used[nexti][nextj]) return false;\n    if(used2[nexti][nextj]) return false;\n\n    bool flag = dfs(si, sj, nexti, nextj, a, used, used2);\n\n    if(flag){\n        used[i][j] = true;\n    }\n\n    return flag;\n}\n\nint main(){\n    \n    while(1){\n        int n; cin >> n;\n        if(!n) break;\n        vector<vector<pair<int, int> > > a(n, vector<pair<int, int> > (n));\n\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                int x, y; cin >> x >> y;\n                a[i][j].first = y;\n                a[i][j].second = x;\n            }\n        }\n\n        vector<vector<bool> > used(n, vector<bool> (n, false));\n\n        int ans = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(!used[i][j]){\n                    int nexti = a[i][j].first;\n                    int nextj = a[i][j].second;\n                    if(used[nexti][nextj]) continue;\n                    vector<vector<bool> > used2(n, vector<bool> (n, false));\n                    used2[i][j] = true;\n                    if(dfs(i, j, nexti, nextj, a, used, used2)){\n                        ans++;\n                        //cout << i << \" \" << j << endl;\n                    }\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\n#define MAX 100\n\nint tx, ty, ans;\nint n, X[MAX][MAX], Y[MAX][MAX];\nbool visited[MAX][MAX], found[MAX][MAX];\nbool used[MAX][MAX], flg;\n\nvoid rec(int x, int y){\n  if(visited[x][y]){\n    if(!found[x][y] && tx == x && ty == y){\n      found[x][y] = flg = true;\n      ans++;\n    } \n    return;\n  }\n  visited[x][y] = true;\n  rec(X[x][y],Y[x][y]);\n}\n\nvoid draw(int x,int y){\n  if(tx == x && ty == y){\n    return;\n  }\n  used[x][y] = true;\n  draw(X[x][y],Y[x][y]);\n}\n\nint main(){\n  while(cin >> n ,n){\n    for(int i = 0 ; i < n ; i++){\n      for(int j = 0 ; j < n ; j++){\n\tcin >> X[j][i] >> Y[j][i];\n      }\n    }\n\n    ans = 0;\n    memset(found,false,sizeof(found));\n    memset(used,false,sizeof(used));\n    for(int i = 0 ; i < n ; i++){ \n      for(int j = 0 ; j < n ; j++){\n\tmemset(visited,false,sizeof(visited));\n\tif(!used[i][j]){\n\t  flg = false;\n\t  visited[i][j] = true;\n\t  tx = i, ty = j;\n\t  rec(X[i][j], Y[i][j]);\n\t  if(flg){\n\t    draw(X[i][j], Y[i][j]);\n\t  }\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); it++)\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nvoid visit(const vvi &g, int v, vvi& scc,\n           stack<int> &S, vector<bool> &inS,\n           vector<int> &low, vector<int> &num, int& time) {\n    low[v] = num[v] = ++time;\n    S.push(v); inS[v] = true;\n    iter(e, g[v]) {\n        int w = *e;\n        if (num[w] == 0) {\n            visit(g, w, scc, S, inS, low, num, time);\n            low[v] = min(low[v], low[w]);\n        } else if (inS[w])\n            low[v] = min(low[v], num[w]);\n    }\n    if (low[v] == num[v]){\n        scc.push_back(vi());\n        while (1) {\n            int w = S.top(); S.pop(); inS[w] = false;\n            scc.back().push_back(w);\n            if (v == w) break;\n        }\n    }\n}\n\nvoid scc(vvi const& g, vvi& res) {\n    int const n = g.size();\n    vi num(n), low(n);\n    stack<int> S;\n    vector<bool> inS(n);\n    int time = 0;\n    rep(u,n)if(num[u]==0) visit(g, u, res, S, inS, low, num, time);\n}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vvi g(n*n);\n        rep(i,n)rep(j,n){\n            int x,y; cin>>x>>y;\n            int u=i*n+j;\n            int v=y*n+x;\n            g[u].push_back(v);\n        }\n        vvi ans;\n        scc(g,ans);\n        int c=0;\n        rep(i,ans.size()){\n            if(ans[i].size()==1){\n                if(g[ans[i][0]][0]!=ans[i][0]) c++;\n            }\n        }\n        cout << ans.size()-c << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\nusing namespace std;\ntypedef pair<int,int> mypair;\nvoid jump(int x,int y,int acc,int n,vector<vector<bool> >&map,vector<vector<mypair> > &map2){\n\tif(map[x][y]){\nint sx=map2[x][y].first;\nint sy=map2[x][y].second;\nif(acc==n*n+1)map[x][y]=false;\nacc++;\njump(sx,sy,acc,n,map,map2);\n}\n}\n\nint main(void){\nint n;\nwhile(1){\ncin>>n;\nif(n==0)break;\nvector<vector<bool> >map(n,vector<bool>(n,true));\nvector<vector<mypair> >map2(n,vector<mypair>(n));\nfor(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t\tcin>>map2[j][i].first>>map2[j][i].second;\n\t}\n}int t=0;\nfor(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\njump(i,j,0,n,map,map2);\n\t}\n}\nfor(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\nif(map[i][j]==false)t++;\n\t}\n}\ncout<<t<<endl;\n}\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#define X first\n#define Y second\nusing namespace std;\nenum STATE{NON, NORMAL, LOOP};\n\nstruct node{\n\tnode():state(NON), pos(pair<int, int>(-1, -1)){}\n\tSTATE state;\n\tpair<int, int> pos;\n};\n\nSTATE stateChange(STATE current){\n\tswitch(current){\n\tcase NON:\n\t\tcurrent = NORMAL;\n\t\tbreak;\n\tcase NORMAL:\n\t\tcurrent = LOOP;\n\t\tbreak;\n\tcase LOOP:\n\t\tbreak;\n\tdefault:\n\t\tbreak;\n\t}\n\treturn current;\n}\n\nvoid clear(vector<vector<node> > &pos){\n\tfor(int i = 0; i < pos.size(); i++){\n\t\tfor(int j = 0; j < pos[i].size(); j++){\n\t\t\tif(pos[i][j].state!=LOOP) pos[i][j].state = NON;\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n && n != 0){\n\t\tvector<vector<node> > pos(n, vector<node>(n, node()));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin >> pos[i][j].pos.X>> pos[i][j].pos.Y;\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tbool f = false;\n\t\t\t\tint x=j, y=i;\n\t\t\t\twhile(pos[y][x].state!=LOOP){\n\t\t\t\t\tpos[y][x].state = stateChange(pos[y][x].state);\n\t\t\t\t\tif(pos[y][x].state==LOOP) f = true;\n\t\t\t\t\tint tmpx=x, tmpy=y;\n\t\t\t\t\tx = pos[tmpy][tmpx].pos.X;\n\t\t\t\t\ty = pos[tmpy][tmpx].pos.Y;\n\t\t\t\t}\n\t\t\t\tif(f) count++;\n\t\t\t\tclear(pos);\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\ntypedef pair<int,int> P;\nint N;\nint map[100][100];\nP edge[100][100];\nbool rec(int c,int x,int y){\n     if(c==map[x][y])return true;\n     if(map[x][y]>0)return false;\n     map[x][y]=c;\n     return rec(c,edge[x][y].second,edge[x][y].first);\n}\nint main(){\n     while(cin>>N,N){\n\t  for(int i=0;i<N;i++){\n\t       for(int j=0;j<N;j++){\n\t\t    map[i][j]=0;\n\t       }\n\t  }\n\t  for(int i=0;i<N;i++){\n\t       for(int j=0;j<N;j++){\n\t\t    P t;\n\t\t    cin>>t.first>>t.second;\n\t\t    edge[i][j]=t;\n\t       }\n\t  }\n\t  int c=1,ans=0;\n\t  for(int i=0;i<N;i++){\n\t       for(int j=0;j<N;j++){\n\t\t    if(rec(c,i,j))ans++;\n\t\t    c++;\n\t       }\n\t  }\n\t  /*for(int i=0;i<N;i++){\n\t       for(int j=0;j<N;j++){\n\t\t    cout<<map[i][j];\n\t       }\n\t       cout<<endl;\n\t       }*/\n\t  cout<<ans<<endl;\n     }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint co;\nint cou;\nvector<vector<pair<int,int> > > a;\nvector<vector<int> > gr;\nvoid saiki(int,int);\nint fl[10000];\nint main(){\n  while(1){\n    int n;\n    cin >> n;\n    if(!n)break;\n    a=vector<vector<pair<int,int> > >(n,vector<pair<int,int> >(n));\n    gr=vector<vector<int> >(n,vector<int> (n,-1) );\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tcin >> a[i][j].first >> a[i][j].second;\n      }\n    }\n    for(int i=0;i<10000;i++){\n      fl[i]=-1;\n    }\n    \n    co=0;\n    cou=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(gr[i][j]==-1){\n\t  cou++;\n\t  saiki(i,j);\n\t}\n\t//\tcout << gr[i][j] << \" \";//\n      }\n      //cout << endl;\n\t\n    }\n    cout << co << endl;\n  }\n  return 0;\n}\nvoid saiki(int I,int J){\n  if(gr[I][J]==cou){\n    co++;\n    return;\n  }\n  if(gr[I][J]==-1){\n    gr[I][J]=cou;\n    saiki(a[I][J].second,a[I][J].first);\n  }\n  else return;\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nstruct Point\n{\n  int x;\n  int y;\n};\n\nclass Room\n{\n  public:\n    Room(int n);\n    ~Room();\n\n  public:\n    int LoopNum();\n    bool isLoop(Point& p, bool** this_loop_passed);\n\n  private:\n    bool** MakeAlreadyPass();\n    void KillAlreadyPass(bool** ptrptr);\n\n  private:\n    int m_size;\n    Point** m_room;\n    bool** m_already_pass; \n};\n\nRoom::Room(int n)\n{\n  m_size = n;\n  m_room = new Point*[m_size];\n  for (int i = 0; i < m_size; ++i)\n  {\n    m_room[i] = new Point[m_size];\n  }\n\n  for (int i = 0; i < m_size; ++i)\n  {\n    for (int j = 0; j < m_size; ++j)\n    {\n      cin >> m_room[i][j].x >> m_room[i][j].y;\n    }\n  }\n  m_already_pass = MakeAlreadyPass();\n}\n\nRoom::~Room()\n{\n  for (int i = 0; i < m_size; ++i)\n  {\n    delete[] m_room[i];\n  }\n  delete[] m_room;\n\n  KillAlreadyPass(m_already_pass);\n}\n\nint Room::LoopNum()\n{\n  int result = 0;\n  for (int i = 0; i < m_size; ++i)\n  {\n    for (int j = 0; j < m_size; ++j)\n    {\n      bool** this_loop_passed = MakeAlreadyPass();\n      Point p = { i, j };\n      if (isLoop(p, this_loop_passed) )\n      {\n        ++result;\n      }\n      KillAlreadyPass(this_loop_passed);\n    }\n  }\n  return result;\n}\n\nbool Room::isLoop(Point& p, bool** this_loop_passed)\n{\n  if (this_loop_passed[p.x][p.y])\n  {\n    return true;\n  }\n  if (m_already_pass[p.x][p.y])\n  {\n    return false;\n  }\n  m_already_pass[p.x][p.y] = this_loop_passed[p.x][p.y] = true;\n  return isLoop(m_room[p.y][p.x], this_loop_passed);\n}\n\nbool** Room::MakeAlreadyPass()\n{\n  bool** buf = new bool*[m_size];\n  for (int i = 0; i < m_size; ++i)\n  {\n    buf[i] = new bool[m_size];\n  }\n  //fill_n(buf[0], m_size * m_size, false);\n  for (int i = 0; i < m_size; ++i)\n  {\n    for (int j = 0; j < m_size; ++j)\n    {\n      buf[i][j] = false;\n    }\n  }\n  return buf;\n}\n\nvoid Room::KillAlreadyPass(bool** ptrptr)\n{\n  for (int i = 0; i < m_size; ++i)\n  {\n    delete[] ptrptr[i];\n  }\n  delete[] ptrptr;\n}\n\nint main(void)\n{\n  int n;\n  while (true)\n  {\n    cin >> n;\n    if (n == 0) break;\n\n    Room room(n);\n    cout << room.LoopNum() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#define X first\n#define Y second\nusing namespace std;\n\nstruct UnionFindTree{\n\tUnionFindTree():pos(pair<int, int>(-1, -1)), root(NULL), next(NULL){}\n\tpair<int, int> pos;\n\tUnionFindTree *root;\n\tUnionFindTree *next; //この問題で入れる意味は多分ない\n};\n\nvoid dfs(int x, int y, int &count, vector<vector<UnionFindTree> > &pos){\n\tint tmp = count;\n\tif(pos[pos[y][x].pos.Y][pos[y][x].pos.X].root==NULL){\n\t\tif(pos[y][x].root==NULL) pos[pos[y][x].pos.Y][pos[y][x].pos.X].root = &pos[y][x];\n\t\telse pos[pos[y][x].pos.Y][pos[y][x].pos.X].root = pos[y][x].root;\n\t\tdfs(pos[y][x].pos.X, pos[y][x].pos.Y, count, pos);\n\t}\n\telse if(pos[y][x].root == pos[pos[y][x].pos.Y][pos[y][x].pos.X].root){\n\t\tcount++;\n\t}\n\tif(tmp == count) pos[y][x].root = NULL;\n\treturn;\n}\n\nint main(){\n\tint n = 0;\n\twhile(cin >> n && n != 0){\n\t\tvector<vector<UnionFindTree> > pos(n, vector<UnionFindTree>(n, UnionFindTree()));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin >> pos[i][j].pos.X >> pos[i][j].pos.Y;\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(pos[i][j].root != NULL) continue;\n\t\t\t\tdfs(j, i, count, pos);\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nint x[110][110];\nint y[110][110];\nint v[110][110];\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tscanf(\"%d%d\",&y[i][j],&x[i][j]);\n\t\tint ret=0;\n\t\tfor(int i=0;i<a;i++)\n\t\t\tfor(int j=0;j<a;j++)\n\t\t\t\tv[i][j]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tint row=i;\n\t\t\t\tint col=j;\n\t\t\t\tint s,t;\n\n\t\t\t\twhile(!v[row][col]){\n\t\t\t\t\tv[row][col]=1;\n\t\t\t\t\ts=x[row][col];\n\t\t\t\t\tt=y[row][col];\n\t\t\t\t\trow=s;col=t;\n\t\t\t\t}\n\t\t\t\tif(v[row][col]==1)ret++;\n\t\t\t\trow=i;col=j;\n\t\t\t\twhile(v[row][col]!=2){\n\t\t\t\t\tv[row][col]=2;\n\t\t\t\t\ts=x[row][col];\n\t\t\t\t\tt=y[row][col];\n\t\t\t\t\trow=s;col=t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint x[10000], a, b, n, c[10000], d[10000];\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 10000; i++) { d[i] = 0; }\n\t\tcin >> n; if (n == 0) { break; }\n\t\tfor (int i = 0; i < n*n; i++) {\n\t\t\tcin >> a >> b;\n\t\t\tx[i] = a * 100 + b;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n*n; i++) {\n\t\t\tfor (int j = 0; j < 10000; j++) { c[i] = 0; }\n\t\t\tint cx = i;\n\t\t\twhile (true) {\n\t\t\t\tc[cx] = 1;\n\t\t\t\tcx = x[cx];\n\t\t\t\tif (c[cx] == 1) { break; }\n\t\t\t}\n\t\t\tint C = 0;\n\t\t\tfor (int j = 0; j < 10000; j++) {\n\t\t\t\tif (c[j] == 1 && d[j] >= 1) {\n\t\t\t\t\tC = d[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (C == 0) {\n\t\t\t\tcnt++; C = cnt;\n\t\t\t}\n\t\t\tfor (int j = 0; j < 10000; j++) {\n\t\t\t\tif (c[cx] == 1) { d[cx] = C; }\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <set>\nusing namespace std;\nstruct P { int x, y; };\nint n;\nint cnt[100][100];\nP map[100][100];\nint dfs(int y, int x, int c) {\n    if (cnt[x][y]!=-1&&cnt[x][y]!=c) return cnt[x][y];\n    if (cnt[x][y]==c) return cnt[x][y];\n    cnt[x][y]=c;\n    return cnt[x][y]=dfs(map[x][y].x,map[x][y].y,cnt[x][y]);\n}\nint main() {\n    while (scanf(\"%d\",&n)) {\n        if (!n) break;\n        for (int i=0; i<n; i++) {\n            for (int j=0; j<n; j++) scanf(\"%d%d\",&map[i][j].x,&map[i][j].y);\n        }\n        memset(cnt,-1,sizeof(cnt));\n        int x=0;\n        set<int> res;\n        for (int i=0; i<n; i++) {\n            for (int j=0; j<n; j++) {\n                if (cnt[i][j]==-1) {\n                    cnt[i][j]=++x;\n                    cnt[i][j]=dfs(map[i][j].x,map[i][j].y,cnt[i][j]);\n                    res.insert(cnt[i][j]);\n                }\n            }\n        }\n        printf(\"%d\\n\",res.size());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nvoid solve()\n{\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\t\tvector<vector<P> > field(N, N);\n\t\tfor(int i = 0; i < N; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tcin >> field[i][j].first >> field[i][j].second;\n\t\t\t}\n\t\t}\n\t\tbool isVisited[101][101];\n\t\tbool roopStart[101][101];\n\t\tfor(int i = 0; i < N; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tisVisited[i][j] = false;\n\t\t\t\troopStart[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < N; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tint x = field[i][j].first;\n\t\t\t\tint y = field[i][j].second;\n\t\t\t\tbool roopFlag = false;\n\t\t\t\twhile(isVisited[x][y] == false)\n\t\t\t\t{\n\t\t\t\t\troopFlag = true;\n\t\t\t\t\tif(roopStart[x][y] == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tisVisited[x][y] = true;\n\t\t\t\t\tx = field[x][y].first;\n\t\t\t\t\ty = field[x][y].second;\n\t\t\t\t}\n\t\t\t\tif(roopFlag)\n\t\t\t\t{\n\t\t\t\t\troopStart[x][y] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < N; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tif(roopStart[i][j] == true)\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define\tmp\tmake_pair\n#define\tY\tfirst\n#define\tX\tsecond\n\ntypedef\tpair<int,int>\tpii;\n\npii floor[100][100];\nint visited[100][100];\n\nint main(){\n\tfor(int n;cin>>n,n;){\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\tcin>>floor[i][j].X>>floor[i][j].Y;\n\t\t\tvisited[i][j]=-1;\n\t\t}\n\n\t\tint cnt=0,loops=0;\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++){\n\t\t\tif(visited[i][j]==-1){\n\t\t\t\tint y=i,x=j;\n\t\t\t\tdo{\n\t\t\t\t\tvisited[y][x]=loops;\n\t\t\t\t\tpii nxt=floor[y][x];\n\t\t\t\t\ty=nxt.Y;\n\t\t\t\t\tx=nxt.X;\n\t\t\t\t}while(visited[y][x]==-1);\n\t\t\t\tif(visited[y][x]==loops)\tcnt++;\n\t\t\t\tloops++;\n\t\t\t}\n\t\t}\n\n\t\tcout<<cnt<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n;\nchar warp[100000],map[100000];\n\nvoid solve(int pos, int& ans ,vector<int>& path){\n\tif( count( path.begin() , path.end() , pos ) ){\n\t\tans++;\n\t\tfor(vector<int>::iterator it = path.begin() ; it != path.end() ; ++it ){\n\t\t\tmap[ *it ] = 1;\n\t\t}\n\t\treturn ;\n\t}\n\tif( map[pos] == 0 ){\n\t\tpath.push_back( pos );\n\t\tsolve( warp[pos] , ans , path );\n\t}\n}\n\nint main(){\n\n\twhile( cin >> n , n ){\n\t\tfor(int y=0 ; y<n ; ++y ){\n\t\t\tfor(int x=0 ; x<n ; ++x ){\n\t\t\t\tint mx,my;\n\t\t\t\tcin >> mx >> my;\n\t\t\t\twarp[y*n+x] = my*n + mx;\n\t\t\t\tmap[y*n+x]  = 0;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int pos=0 ; pos<n*n ; ++pos ){\n\t\t\tif( map[pos] == 0 ){\n\t\t\t\tvector<int> path;\n\t\t\t\tsolve( pos , ans , path );\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\ntypedef long long LL;\nstatic const double EPS = 1e-9;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nint nx[100][100],ny[100][100];\nbool check[100][100];\nbool check2[100][100];\nint N;\nbool loop(int x, int y){\n  if(check2[x][y]){\n    bool ret=true;\n    REP(dx,N)REP(dy,N){\n      if(check2[dx][dy]){\n        if(check[dx][dy]) ret = false;\n        else check[dx][dy] = true;\n      }\n    }\n    return ret;\n  }\n  check2[x][y] = true;\n  return loop(nx[x][y],ny[x][y]);\n}\n  \nint main(void){\n  while(cin>>N){\n    if(!N) break;\n    int count = 0;\n    memset(check,0,sizeof(check));\n    REP(y,N)\n      REP(x,N)\n        cin>>nx[x][y]>>ny[x][y];\n    REP(y,N)\n      REP(x,N)\n        if(!check[x][y]){\n          memset(check2,0,sizeof(check2));\n          if(loop(x,y)) count++;\n        }\n    cout << count << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nstatic const int INF = 999999999;\ntypedef pair<int, int> P;\n\n\nvoid solve()\n{\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\t\tvector< vector<P> > field(N, vector<P>(N));\n\t\tvector< vector<int> > data(N, vector<int>(N));\n\t\tfor(int i = 0; i < N; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tcin >> field[i][j].first >> field[i][j].second;\n\t\t\t\tdata[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tint count = 0;\n\t\tfor(int i = 0; i < N; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tif(data[i][j] == INF)\n\t\t\t\t{\n\t\t\t\t\tint x = j;\n\t\t\t\t\tint y = i;\n\t\t\t\t\twhile(data[y][x] == INF)\n\t\t\t\t\t{\n\t\t\t\t\t\tdata[y][x] = count;\n\t\t\t\t\t\tint ny = field[y][x].second;\n\t\t\t\t\t\tint nx = field[y][x].first;\n\t\t\t\t\t\ty = ny;\n\t\t\t\t\t\tx = nx;\n\t\t\t\t\t}\n\t\t\t\t\tif(data[y][x] == count)\n\t\t\t\t\t{\n\t\t\t\t\t\t++ans;\n\t\t\t\t\t}\n\t\t\t\t\t++count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++ )\nstatic const int MAX = 100;\n\nint N, V[MAX][MAX], ans;\npair<int, int> G[MAX][MAX];\n\nvoid dfs( int y , int x , int id ){\n    V[y][x] = id;\n    int nx = G[y][x].first;\n    int ny = G[y][x].second;\n    if ( V[ny][nx] == id ) ans++;\n    if ( V[ny][nx] == 0 ) dfs(ny, nx, id);\n}\n\nvoid solve(){\n    rep(i, N) rep(j, N) V[i][j] = 0;\n    int ncomp = 0;\n    ans = 0;\n\n    rep(i, N) rep(j, N){\n\tif ( V[i][j] == 0 ){\n\t    ncomp++;\n\t    dfs(i, j, ncomp);\n\t}\n    }\n    cout << ans << endl;\n}\n\nmain(){\n    int px, py;\n    while( cin >> N && N ){\n\trep(y, N) rep(x, N){\n\t    cin >> px >> py;\n\t    G[y][x] = make_pair(px, py);\n\t}\n\tsolve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define loop(i,a,b) for(ull i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n#define iter(i,c) for(auto i=(c).begin(); i!=(c).end(); ++i)\n#define riter(i,c) for(auto i=(c).rbegin(); i!=(c).rend(); ++i)\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\nnamespace std {\n    template<typename T>ostream&operator<<(ostream&os, vector<T>const&v){\n        iter(it,v) os<<*it<<(it+1==v.end()?\"\":\",\");\n        return os;\n    }\n    template<typename T, typename U>ostream&operator<<(ostream&os,const pair<T,U>&p){\n        return os << \"[\" << p.dirst << \",\" << p.second << \"]\";\n    }\n}\n\nvoid visit(const vvi &g, int v, vvi& scc,\n           stack<int> &S, vector<bool> &inS,\n           vector<int> &low, vector<int> &num, int& time) {\n    low[v] = num[v] = ++time;\n    S.push(v); inS[v] = true;\n    iter(e, g[v]) {\n        int w = *e;\n        if (num[w] == 0) {\n            visit(g, w, scc, S, inS, low, num, time);\n            low[v] = min(low[v], low[w]);\n        } else if (inS[w])\n            low[v] = min(low[v], num[w]);\n    }\n    if (low[v] == num[v]){\n        scc.push_back(vi());\n        while (1) {\n            int w = S.top(); S.pop(); inS[w] = false;\n            scc.back().push_back(w);\n            if (v == w) break;\n        }\n    }\n}\n \nvoid scc(vvi const& g, vvi& res) {\n    int const n = g.size();\n    vi num(n), low(n);\n    stack<int> S;\n    vector<bool> inS(n);\n    int time = 0;\n    rep(u,n)if(num[u]==0) visit(g, u, res, S, inS, low, num, time);\n}\n \nint main(){\n    int n;\n    while(cin>>n,n){\n        vvi g(n*n);\n        rep(i,n)rep(j,n){\n            int x,y; cin>>x>>y;\n            int u=i*n+j;\n            int v=y*n+x;\n            g[u].push_back(v);\n        }\n        vvi ans;\n        scc(g,ans);\n        int c=0;\n        rep(i,ans.size()){\n            if(ans[i].size()==1){\n                if(g[ans[i][0]][0]!=ans[i][0]) c++;\n            }\n        }\n        cout << ans.size()-c << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\n\n\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n)\n\t{\n\t\tint tx[128][128], ty[128][128];\n\t\trep (i, n)\n\t\t\trep (j, n)\n\t\t\t\tscanf(\"%d%d\", &tx[i][j], &ty[i][j]);\n\n\t\tint visit[128][128];\n\t\tmemset(visit, -1, sizeof(visit));\n\n\t\tint res = 0;\n\t\tfor (int y = 0; y < n; ++y)\n\t\t{\n\t\t\tfor (int x = 0; x < n; ++x)\n\t\t\t{\n\t\t\t\tint mark = n * y + x;\n\t\t\t\tif (visit[y][x] == -1)\n\t\t\t\t{\n\t\t\t\t\tint cx = x, cy = y;\n\t\t\t\t\twhile (visit[cy][cx] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tvisit[cy][cx] = mark;\n\t\t\t\t\t\tint xx = cx, yy = cy;\n\t\t\t\t\t\tcx = tx[yy][xx];\n\t\t\t\t\t\tcy = ty[yy][xx];\n\n\t\t\t\t\t\tif (visit[cy][cx] == mark)\n\t\t\t\t\t\t\t++res;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntypedef std::pair<int, int> pii;\ntypedef std::vector<int> vi;\ntypedef std::vector<double> vd;\ntypedef std::vector<std::string> vs;\ntypedef std::vector<pii> vpii;\ntypedef std::vector<vi> vvi;\ntypedef std::vector<vpii> vvpii;\nconst int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconst int MOD = 1000000007;\nconst double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { rep(i,v.size()) is >> v[i]; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nclass UFTree {\n  std::vector<int> data, rank, _size;\n\npublic:\n  UFTree(const int &n) : data(n), rank(n), _size(n, 1) { iota(all(data), 0); }\n\n  int root(const int &x) { return data[x] == x ? x : data[x] = root(data[x]); }\n\n  bool same(const int &a, const int &b) { return root(a) == root(b); }\n\n  void unite(int a, int b) {\n    a = root(a), b = root(b);\n    if (a == b) return;\n    if (rank[a] < rank[b]) std::swap(a, b);\n    data[b] = a;\n    _size[a] += _size[b];\n    if (rank[a] == rank[b]) rank[a]++;\n  }\n\n  int sizeOf(int x) { return _size[root(x)]; }\n\n  int size() { return data.size(); }\n};\n\nmain {\n  int n;\n  while (cin >> n, n) {\n    UFTree uf(n * n);\n    vvpii v(n, vpii(n));\n    cin >> v;\n    rep(i, n) rep(j, n) uf.unite(i * n + j, v[i][j].second * n + v[i][j].first);\n    int c = 0;\n    rep(i, uf.size()) c += i == uf.root(i);\n    cout << c << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <utility>\nusing namespace std;\n\n#define SIZE 100\n\nint field[SIZE][SIZE][3];\n\nint main() {\n    while (true) {\n        int n;\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n        memset(field, 0, sizeof(field));\n        for (int y = 0; y < n; y++) {\n            for (int x = 0; x < n; x++) {\n                cin >> field[y][x][2] >> field[y][x][1];\n            }\n        }\n        int result = 0, num = 0;\n        for (int y = 0; y < n; y++) {\n            for (int x = 0; x < n; x++) {\n                if (field[y][x][0] > 0) {\n                    continue;\n                }\n                num++;\n                pair<int, int> next(y, x);\n                while (true) {\n                    if (field[next.first][next.second][0] == 0) {\n                        field[next.first][next.second][0] = num;\n                        next = make_pair(field[next.first][next.second][1], field[next.first][next.second][2]);\n                        continue;\n                    } else if (field[next.first][next.second][0] == num) {\n                        result++;\n                    }\n                    break;\n                }\n            }\n        }\n        cout << result << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 105\nusing namespace std;\n\nint n,ans,cnt,flag;\nint nx[N][N],ny[N][N];\nint used[N][N];\n\n\nvoid dfs(int y,int x){\n  \n  if(used[y][x]!=-1){\n    \n    if(used[y][x]!=cnt) flag=1;\n    \n    return ;\n    \n  }\n\n  used[y][x]=cnt;\n  \n  dfs(ny[y][x],nx[y][x]);\n  \n}\n\nint main(){\n\n  while(1){\n    \n    cin>>n;\n\n    if(!n) break;\n\n    for(int i=0;i<n;i++)\n\n      for(int j=0;j<n;j++) cin>>nx[i][j]>>ny[i][j];\n\t\n    memset(used,-1,sizeof(used));\n\n    ans=0;\n    cnt=0;\n    \n    for(int i=0;i<n;i++){\n      \n      for(int j=0;j<n;j++){\n\n\tif(used[i][j]!=-1) continue;\n\t\n\tflag=0;\n\t\n\tdfs(i,j);\n\t\n\tif(!flag) ans++;\n\t\n\tcnt++;\n\n      }\n      \n    }\n    \n    cout<<ans<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nclass DisjointSet{\nprivate:\n  vector< int > rank, p;\n  size_t sz;\n  void link(int x,int y){\n    if(rank[x] > rank[y]){\n      p[y] = x;\n    } else {\n      p[x] = y;\n      if(rank[x] == rank[y]) rank[y]++;\n    }\n  }\npublic:\n  DisjointSet(int size):sz(size){\n    rank.resize(size,0);\n    p.resize(size,0);\n    for(int i = 0; i < size; i++) p[i] = i, rank[i] = 0;\n  }\n  void Union(int x,int y){\n    if(Find(x) != Find(y)) link(Find(x),Find(y)), --sz;\n  }\n  int Find(int x){\n    return( x != p[x] ? p[x] = Find(p[x]) : p[x]);\n  }\n  size_t Size(){\n    return sz;\n  }\n};\n\nint main()\n{\n  int N;\n  while(scanf(\"%d\", &N), N){\n    DisjointSet UnionFind(N * N);\n    for(int i = 0; i < N; i++){\n      for(int j = 0; j < N; j++){\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        UnionFind.Union( i * N + j, y * N + x);\n      }\n    }\n    printf(\"%d\\n\", UnionFind.Size());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nbool used[100][100];\nint n,p[2][100][100],sx,sy;\nbool dfs(int x,int y){\n  if(sx==x&&sy==y)return 1;\n  if(used[y][x])return 0;\n  used[y][x]=1;\n  return used[y][x]=dfs(p[0][y][x],p[1][y][x]);\n}\nint main(){\n  while(cin>>n&&n){\n    int c=0;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tcin>>p[0][i][j]>>p[1][i][j],used[i][j]=0;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)if(!used[i][j])sx=j,sy=i,c+=dfs(p[0][i][j],p[1][i][j]);\n    cout<<c<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint n;\nint x[100][100], y[100][100];\nint used[100][100];\n\nint dfs(int i, int j){\n\tif(used[i][j] == 1){\n\t\tused[i][j] = 2;\n\t\treturn 1;\n\t}\n\tif(used[i][j] == 2) return 0;\n\tused[i][j] = 1;\n\tint res = dfs(y[i][j], x[i][j]);\n\tused[i][j] = 2;\n\treturn res;\n}\n\nint solve(){\n\tint res = 0;\n\tmemset(used, 0, sizeof(used));\n\tfor(int i=0; i<n; i++){\n\t\tfor(int j=0; j<n; j++){\n\t\t\tif(used[i][j]) continue;\n\t\t\tres += dfs(i, j);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n==0) break;\n\t\t\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tcin >> x[i][j] >> y[i][j];\n\t\t\t}\n\t\t}\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#ifdef Debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#else\n#define dump(x)\n#endif\n\n\nint par[100];\nint Rank[100];\n\nvoid init(int n){\n    rep(i,n){\n        par[i]=i;\n        Rank[i]=0;\n    }\n}\n\nint find(int x){\n    if(par[x]==x) {\n        return x;\n    }else{\n        return par[x]=find(par[x]);\n    }\n}\n\nvoid unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y) return;\n    \n    if(Rank[x]<Rank[y]){\n        par[x]=y;\n    }else{\n        par[y]=x;\n        if(Rank[x]==Rank[y])Rank[x]++;\n    }\n}\n\n\n\n\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(n==0)break;\n\t\tpii data[110][110]={};\n\t\trep(i,n)\n\t\t\trep(j,n)\n\t\t\t\tcin>>data[i][j].first>>data[i][j].second;\n\n\t\tinit(n*n);\n\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tunite(n*i+j,n*data[i][j].second+data[i][j].first);\n\t\t\t}\n\t\t}\n\t\tbool used[10000]={};\n\t\tint sum=0;\n\t\trep(i,n*n){\n\t\t\tint aa=find(i);\n\t\t\tif( used[ aa ]==false ){\n\t\t\t\tsum++;\n\t\t\t\tused[aa]=true;\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int> P;\nP matrix[102][102];\nbool used[102][102];\nint imap[102][102];\nint index,cnt;\nstatic const int dx[4] = {0,1,0,-1};\nstatic const int dy[4] = {1,0,-1,0};\n\nvoid rec(int x,int y){\n  used[y][x] = true;\n  imap[y][x] = index;\n  P p = matrix[y][x];\n  if(used[p.S][p.F]){\n    if(imap[p.S][p.F]==index || imap[p.S][p.F] == 0)cnt++;\n    return;\n  }\n  rec(p.F,p.S);  \n}\n\nint main(){\n  int N;\n  while(true){\n    cin >> N;\n    if(N == 0)break;\n    index = 1;\n    cnt = 0;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n\tint x,y;\n\tused[i][j] = false;\n\timap[i][j] = 0;\n\tcin >> x >> y;\n\tmatrix[i][j] = P(x,y);\n      }\n    }\n    for(int i=0;i<N;i++){\n      for(int j=0;j<N;j++){\n\tif(!used[i][j]){\n\t  rec(j,i);\n\t  index++;\n\t}\n      }\n    }\n\n    cout << cnt << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n\nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n\nstatic const double EPS = 1e-8;\n\nclass Data{\npublic:\n\tint mX;\n\tint mY;\n\tData(int _x,int _y){\n\t\tmX = _x;\n\t\tmY = _y;\n\t}\n\tData():mX(0),mY(0){}\n};\n\nData path[100][100];\nbool visited[100][100];\n\nint main(){\n\n\tint W;\n\twhile(~scanf(\"%d\",&W)){\n\t\tif(W==0) break;\n\n\t\tmemset(visited,0,sizeof(visited));\n\t\tfor(int y=0;y<W;y++){\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tint nx,ny;\n\t\t\t\tcin >> nx >> ny;\n\t\t\t\tpath[y][x] = Data(nx,ny);\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tfor(int y=0;y<W;y++){\n\t\t\tfor(int x=0;x<W;x++){\n\t\t\t\tif(visited[y][x]) continue;\n\n\t\t\t\tbool tmp[100][100];\n\t\t\t\tmemcpy(tmp,visited,sizeof(bool)*100*100);\n\n\t\t\t\tint sx = x;\n\t\t\t\tint sy = y;\n\t\t\t\ttmp[sy][sx] = true;\n\n\t\t\t\tint nx = sx;\n\t\t\t\tint ny = sy;\n\t\t\t\tfor(int i=0;i<=W*W;i++){\n\t\t\t\t\tint prev_x = nx;\n\t\t\t\t\tint prev_y = ny;\n\t\t\t\t\tnx = path[prev_y][prev_x].mX;\n\t\t\t\t\tny = path[prev_y][prev_x].mY;\n\t\t\t\t\ttmp[ny][nx] = true;\n\n\t\t\t\t\tif(nx==sx && ny==sy){\n\t\t\t\t\t\tres++;\n\t\t\t\t\t\tmemcpy(visited,tmp,sizeof(bool)*100*100);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <utility>\n\nusing namespace std;\n\nint p[100][100];\npair<int,int> f[100][100];\n\nint dfs(int x,int y){\n\tp[x][y] = 1;\n\tif(p[f[x][y].first][f[x][y].second] == 1) return 1;\n\telse if(p[f[x][y].first][f[x][y].second] == 0) return 0;\n\telse return dfs(f[x][y].first,f[x][y].second);\n}\n\nint main(void){\n\tint i, j, k, l, n, c;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(!n) break;\n\t\tc = 0;\n\t\tmemset(p,-1,sizeof(p));\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tscanf(\"%d%d\",&f[j][i].first,&f[j][i].second);\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tif(p[j][i] == -1 && dfs(j,i)) c++;\n\t\t\t\tfor(k = 0;k < n;k++){\n\t\t\t\t\tfor(l = 0;l < n;l++) if(p[k][l] == 1) p[k][l] = 0;\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#define N 110\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nint n,a,b,temp;\t\nstruct nex{\n\tint x,y;\n};\nnex next[N][N];\nint used[N][N];\nint func(int p/*y*/,int q/*x*/){\n\tif(used[p][q]==1)\n\t\treturn 0;\n\tif(used[p][q]==2)\n\t\treturn 1;\n\tused[p][q]=2;\n\tnex pre=next[p][q];\n\treturn func(pre.y,pre.x);\n}\nint main(){\n\twhile(cin>>n,n){\n\t\ttemp=0;\n\t\trep(i,n)\n\t\trep(j,n){\n\t\t\tused[i][j]=0;\n\t\t\tcin>>a>>b;\n\t\t\tnext[i][j].x=a;\n\t\t\tnext[i][j].y=b;\n\t\t}\n\t\trep(i,n)\n\t\trep(j,n){\n\t\t\tif(used[i][j]==0){\n\t\t\t\tif(func(i,j)){\n\t\t\t\t\ttemp++;\n\t\t\t\t}\n\t\t\t\trep(h,n)\n\t\t\t\t\t\trep(k,n)\n\t\t\t\t\t\tif(used[h][k]==2)\n\t\t\t\t\t\t\tused[h][k]=1;\n\t\t\t}\n\t\t}\n\t\tcout<<temp<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\nint N, x, y;\n\nint G[10100];\n\nint res;\nbool seen[10100], used[10100];\nvoid dfs(int v) {\n    if (used[v]) return;\n    if (seen[v]) {\n        ++res;\n        return;\n    }\n    seen[v] = true;\n    int to = G[v];\n    dfs(to);\n    \n    used[v] = true;\n}\n\n\nint main() {\n    while (cin >> N) {\n        if (N == 0) break;\n        \n        for (int i = 0; i < N; ++i) {\n            for (int j = 0; j < N; ++j) {\n                cin >> x >> y;\n                int to = N*x+y;\n                int from = N*j+i;\n                \n                G[from] = to;\n            }\n        }\n        res = 0;\n        memset(seen, 0, sizeof(seen));\n        memset(used, 0, sizeof(used));\n        \n        for (int i = 0; i < N*N; ++i) {\n            if (!used[i]) dfs(i);\n        }\n        \n        cout << res << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    int x[n][n],y[n][n];\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tcin>>x[j][i]>>y[j][i];\n    bool used[n][n];\n    bool visit[n][n];\n    memset(used,0,sizeof(used));\n    int ans=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(used[i][j]) continue;\n\tmemset(visit,0,sizeof(visit));\n\tint tx=i,ty=j;\n\tbool f=1;\n\twhile(!visit[tx][ty]){\n\t  //cout<<tx<<\" \"<<ty<<endl;\n\t  if(used[tx][ty]){\n\t    f=0;\n\t    break;\n\t  }\n\t  visit[tx][ty]=1;\n\t  int py=ty,px=tx;\n\t  tx=x[px][py];\n\t  ty=y[px][py];\n\t}\n\tif(f){\n\t  ans++;\n\t  while(!used[tx][ty]){\n\t    used[tx][ty]=1;\n\t    int py=ty,px=tx;\n\t    tx=x[px][py];\n\t    ty=y[px][py];\n\t  }\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#define X first\n#define Y second\nusing namespace std;\n\nstruct UnionFindTree{\n\tUnionFindTree():pos(pair<int, int>(-1, -1)), root(NULL){}\n\tpair<int, int> pos;\n\tUnionFindTree *root;\n};\n\nvoid dfs(int x, int y, int &count, vector<vector<UnionFindTree> > &pos){\n\tint tmp = count;\n\tif(pos[pos[y][x].pos.Y][pos[y][x].pos.X].root==NULL){\n\t\tif(pos[y][x].root==NULL) pos[pos[y][x].pos.Y][pos[y][x].pos.X].root = &pos[y][x];\n\t\telse pos[pos[y][x].pos.Y][pos[y][x].pos.X].root = pos[y][x].root;\n\t\tdfs(pos[y][x].pos.X, pos[y][x].pos.Y, count, pos);\n\t}\n\telse if(pos[y][x].root == pos[pos[y][x].pos.Y][pos[y][x].pos.X].root){\n\t\tcount++;\n\t}\n\tif(tmp == count) pos[y][x].root = NULL;\n\treturn;\n}\n\nint main(){\n\tint n = 0;\n\twhile(cin >> n && n != 0){\n\t\tvector<vector<UnionFindTree> > pos(n, vector<UnionFindTree>(n, UnionFindTree()));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin >> pos[i][j].pos.X >> pos[i][j].pos.Y;\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(pos[i][j].root != NULL) continue;\n\t\t\t\tdfs(j, i, count, pos);\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//34\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint nx[100][100];\nint ny[100][100];\nint c[100][100];\n\nint dfs(int y,int x){\n  if(c[y][x]==2){\n    return 0;\n  }else if(c[y][x]==1){\n    return 1;\n  }else{\n    int r;\n    c[y][x]=1;\n    r=dfs(ny[y][x],nx[y][x]);\n    c[y][x]=2;\n    return r;\n  }\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    for(int y=0;y<n;y++){\n      for(int x=0;x<n;x++){\n\tcin>>nx[y][x]>>ny[y][x];\n      }\n    }\n    fill(c[0],c[100],0);\n    int ans=0;\n    for(int y=0;y<n;y++){\n      for(int x=0;x<n;x++){\n\tans+=dfs(y,x);\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n  while (true) {\n    int n;\n    cin >> n;\n    if (n == 0)\n      break;\n\n    vector< pair<int, int> > tile;\n    for (int i = 0; i < n * n; i++) {\n      int x, y;\n      cin >> x >> y;\n      tile.push_back(pair<int, int>(y, x));\n    }\n\n    int count = 0;\n    vector < vector<int> > root;\n    for (int i = 0; i < n * n; i++) {\n      vector<int> hoge;\n      int j = i;\n      while (true) {\n        hoge.push_back(j);\n        //cout << j << '(' << tile[j].first << ',' << tile[j].second << ')' << endl;                                                                                      \n        j = tile[j].first * n + tile[j].second;\n        bool found = false;\n        for (int k = 0; k < root.size(); k++) {\n        vector<int> piyo = root[k];\n        if (find(piyo.begin(), piyo.end(), j) != piyo.end())\n          found = true;\n        }\n        if (found == true) {\n          //cout << \"found root : \" << j << endl;                                                                                                                         \n          break;\n        }\n        if (find(hoge.begin(), hoge.end(), j) != hoge.end()) {\n          //cout << \"wryyyyyyyy : \" << j << endl;                                                                                                                         \n          root.push_back(hoge);\n          count++;\n        break;\n        }\n      }\n    }\n\n    cout << count << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <stack>\n#include <set>\n#include <stdio.h>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<pair<int,int> > vp;\nvector<pair<double,int> > member;\nconst double eps=1e-9;\ntypedef pair<int,int> p;\nbool loop[105][105];\nint board[105][205];\nvector<p> a;\nint main()\n{\n  int n;\n  while(1)\n    {\n      int ans=0;\n      cin >> n;\n      if(!n) break;\n      memset(loop,false,sizeof(loop));\n      for(int i=0;i<n;i++)\n\t{\n\t  for(int j=0;j<n;j++)\n\t    {\n\t      int x,y;\n\t      cin >> x >> y;\n\t      board[i][2*j]=x;\n\t      board[i][2*j+1]=y;\n\t    }\n\t}\n      for(int i=0;i<n;i++)\n\t{\n\t  for(int j=0;j<n;j++)\n\t    {\n\t      set<p> st;\n\t      st.clear();\n\t      int nowx=j;\n\t      int nowy=i;\n\t      if(loop[i][j]) continue;\n\t      vector<p> tmp;\n\t      while(1)\n\t\t{\n\t\t  //cout << \" nowy nowx (\" << nowy << ' ' << nowx << \" )\" << endl;\n\t\t  auto it=st.find(p(nowx,nowy));\n\t\t  if(it!=st.end())\n\t\t    {\n\t\t      bool forg=false;\n\t\t      for(int k=0;k<tmp.size();k++)\n\t\t\t{\n\t\t\t  if(!loop[tmp[k].second][tmp[k].first]) loop[tmp[k].second][tmp[k].first]=true;\n\t\t\t  else \n\t\t\t    {\n\t\t\t      forg=true;\n\t\t\t    }\n\t\t\t}\n\t\t      if(!forg) ans++;\n\t\t      break;\n\t\t    }\n\t\t  else\n\t\t    {\n\t\t      // cout << nowy << ' ' << nowx << endl;\n\t\t      st.insert(p(nowx,nowy));\n\t\t      tmp.push_back(p(nowx,nowy));\n\t\t      int newnowx=board[nowy][nowx*2];\n\t\t      int newnowy=board[nowy][(nowx*2)+1];\n\t\t      nowx=newnowx;\n\t\t      nowy=newnowy;\n\t\t    }\n\t\t}\n\t    }\n\t}\n      cout << ans << endl;\n    }\n  return 0;\n}\n      \n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\n#include <set>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int n;\n  while(cin>>n,n) {\n    int bax[n][n], bay[n][n];\n    REP(i,n) {\n      REP(j,n) {\n        cin >> bax[j][i] >> bay[j][i];\n      }\n    }\n    int res = 0;\n    int visited[n][n];\n    memset(visited,0,sizeof(visited));\n    int cnt = 1;\n    REP(y,n) {\n      REP(x,n) {\n        if (visited[x][y]) continue;\n        int xx = x, yy = y;\n        while(!visited[xx][yy]) {\n          visited[xx][yy] = cnt;\n          int tmp = bax[xx][yy];\n          yy = bay[xx][yy];\n          xx = tmp;\n        }\n        if (visited[xx][yy] == cnt) {\n          //  cout << xx <<\" \" << yy << endl;\n          res++;\n        }\n        cnt++;\n      }\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <queue>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <stack>\n#define vi vector<int>\n#define vvi vector<vector<int> >\n#define ll long long int\n#define vl vector<ll>\n#define vvl vector<vector<ll>>\n#define vb vector<bool>\n#define vc vector<char>\n#define vs vector<string>\n#define ld long double\n#define INF 1e9\n#define EPS 0.0000000001\n#define rep(i,n) for(int i=0;i<n;i++)\n#define loop(i,s,n) for(int i=s;i<n;i++)\n#define all(in) in.begin(), in.end()\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define MAX 9999999\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<double,double>pdd;\ntypedef pair<ll,ll>pll;\n\nclass unionfind {\n    vector<int> par, rank, size_;\npublic:\n    unionfind(int n) :par(n), rank(n), size_(n, 1) {\n        iota(all(par), 0);\n    }\n    int find(int x) {\n        if (par[x] == x)return x;\n        return par[x] = find(par[x]);\n    }\n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if (x == y)return;\n        if (rank[x] < rank[y])swap(x, y);\n        par[y] = x;\n        size_[x] += size_[y];\n        if (rank[x] == rank[y])rank[x]++;\n    }\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n    int size(int x) {\n        return size_[find(x)];\n    }\n};\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        int ans=0;\n        vector<vector<pii>>graph(n,vector<pii>(n,pii(0,0)));\n        rep(i,n)rep(j,n)cin>>graph[i][j].second>>graph[i][j].first;\n        vector<vector<bool>>flag(n,vector<bool>(n,true));\n        rep(i,n)rep(j,n){\n            if(!flag[i][j])continue;\n            vector<vector<bool>>temp=flag;\n            map<pii,int>mp;\n            bool IsHeyro=false;\n            pii now=pii(i,j);\n            while(1){\n                if(mp[now]!=0){ans++; IsHeyro=true;;break;}\n                if(flag[now.first][now.second]==false)break;\n                mp[now]++;\n                now=graph[now.first][now.second];\n            }\n            if(IsHeyro)for(auto itr=mp.begin(); itr!=mp.end();itr++)flag[itr->first.first][itr->first.second]=false;\n        \n        }\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nvoid solve(const vector<vector<vector<pair<int, int> > > >& jump, vector<vector<int> >& visited, int x, int y)\n{\n\tvisited[y][x] = 1;\n\tfor (int i = 0; i < jump[y][x].size(); ++i) {\n\t\tconst pair<int, int>& p = jump[y][x][i];\n\t\tif (!visited[p.second][p.first])\n\t\t\tsolve(jump, visited, p.first, p.second);\n\t}\n}\n\nint main()\n{\n\tint N;\n\twhile (~scanf(\"%d\", &N)) {\n\t\tif (N == 0)\n\t\t\tbreak;\n\t\tvector<vector<vector<pair<int, int> > > > jump(N, vector<vector<pair<int, int> > >(N));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tint x, y;\n\t\t\t\tscanf(\"%d %d\", &x, &y);\n\t\t\t\tjump[i][j].push_back(pair<int, int>(x, y));\n\t\t\t\tjump[y][x].push_back(pair<int, int>(j, i));\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tvector<vector<int> > visited(N, vector<int>(N, 0));\n\t\tfor (int y = 0; y < N; ++y) {\n\t\t\tfor (int x = 0; x < N; ++x) {\n\t\t\t\tif (visited[y][x])\n\t\t\t\t\tcontinue;\n\t\t\t\tsolve(jump, visited, x, y);\n\t\t\t\t++ans;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint w[101][101],h[101][101];\nbool b[101][101];\n\nint dfs(int x,int y)\n{\n    \n    if(x == -1 || y == -1) return 0;\n    if(b[x][y]){\n        w[x][y] = -1;\n        h[x][y] = -1;\n        return 1;\n    }\n    \n    b[x][y] = true;\n    \n    int rec;\n    rec = dfs(w[x][y],h[x][y]);\n    b[x][y] = false;\n    return rec;\n}\n\nint main()\n{\n    int n,sum;\n    \n    while(cin >> n,n!=0){\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                cin >> w[j][i] >> h[j][i];\n            }\n        }\n    \n        int sum = 0;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                sum += dfs(i,j);\n            }\n        }\n    \n        cout << sum << endl;\n    }\n        \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define pb emplace_back\n\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing lint = long long;\n\nconst int inf = 1001001001;\nconst lint linf = 1001001001001001001ll;\nconst int mod = 1e9 + 7;\nconst int dx[]{0, 1, 0, -1, -1, -1, 1, 1}, dy[]{1, 0, -1, 0, -1, 1, -1, 1};\n\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; } return a > b; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; } return a < b; }\ntemplate<typename T> inline void print(const T &x, string s = \"\\n\") { cout << x << s; }\ntemplate<typename T> inline void print(const vector<T> &v, string s = \" \") \n{ rep(i, v.size()) cout << v[i] << (i + 1 == v.size() ? \"\\n\" : s); }\ninline bool inside(int y, int x, int H, int W) { return 0 <= y && y < H && 0 <= x && x < W; }\ninline lint in() { lint x; std::cin>>x; return x; }\n\nstruct UnionFind {\n\tvector<int> p, r;\n\n\tUnionFind() {}\n\tUnionFind(int size) { init(size); }\n\n\tvoid init(int size) {\n\t\tp.resize(size);\n\t\tr.resize(size);\n\t\tfor (int i = 0; i < size; ++i) {\n\t\t\tp[i] = i; r[i] = 1;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\tif (p[x] == x) return x;\n\t\telse return p[x] = find(p[x]);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\n\t\tif (x == y) return;\n\n\t\tif (r[x] > r[y]) swap(x, y);\n\t\tr[x] += r[y];\n\t\tp[y] = x;\n\t}\n\n\tbool is_root(int x) {\n\t\treturn find(x) == x;\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tint element_count(int x) {\n\t\tx = find(x);\n\t\treturn r[x];\n\t}\n};\n\nint main() {\n\tint n;\n\n\twhile (cin >> n, n) {\n\t\tUnionFind uf(n * n);\n\t\trep(i, n) rep(j, n) {\n\t\t\tint x = in(), y = in();\n\t\t\t\n\t\t\tint u = y * n + x;\n\t\t\tint v = i * n + j;\n\n\t\t\tuf.unite(u, v);\n\t\t}\n\n\t\tint ans = 0;\n\t\tbool f[10000] = {false};\n\t\trep(i, n * n) {\n\t\t\tif (f[uf.find(i)]) continue;\n\t\t\tf[uf.find(i)] = true;\n\t\t\tans++;\n\t\t}\n\n\t\tprint(ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nstruct P{int x,y;}p[100][100];\nint F(int x,int y)\n{\n\tP&r=p[y][x];\n\tif(r.x==-2)return 0;\n\tif(r.x==-1)return 1;\n\tx=r.x;\n\tr.x=-1;\n\ty=F(x,r.y);\n\tr.x=-2;\n\treturn y;\n}\nint main()\n{\n\tint N,i,j,s;\n\twhile(scanf(\"%d\",&N),N)\n\t{\n\t\tfor(i=0;i<N;++i)for(j=0;j<N;++j)scanf(\"%d%d\",&p[i][j].x,&p[i][j].y);\n\t\tfor(s=i=0;i<N;++i)for(j=0;j<N;++j)s+=F(j,i);\n\t\tprintf(\"%d\\n\",s);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <vector>\nusing namespace std;\n\n\nclass Point{\npublic:\n  int x, y;\n};\n\nint cnt;\nPoint data[100][100];\nbool visited[100][100];\nbool loop[100][100];\n\n\nvoid rec(int x, int y, int sx, int sy) {\n  if(loop[y][x]) return;\n  if(visited[y][x]) {\n    if(x == sx && y == sy) {\n      cnt++;\n      loop[sy][sx] = true;\n    }\n    return;\n  }\n  visited[y][x] = true;\n  rec(data[y][x].x, data[y][x].y, sx, sy);\n}\n\nint main() {\n  while(1) {\n    int N;\n    cin >> N;\n    if(N == 0) break;\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) {\n\tcin >> data[i][j].x >> data[i][j].y;\n      }\n    }\n\n    cnt = 0;\n\n    fill(&loop[0][0], &loop[N-1][N-1]+1, false);\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) {\n\tif(!visited[i][j]) {\n\t  fill(&visited[0][0], &visited[N-1][N-1]+1, false);\n\t  rec(j, i, j, i);\n\t}\n      }\n    }\n\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\n#define f first\n#define s second\n#define rep(i, n) for(int i = 0 ; i < n ; i++)\n\ntypedef pair<int, int> P;\n\nP field[110][110];\nint N;\n\nint main(){\n  while(cin >> N, N){\n    set<set<P> > ans;\n    \n    rep(i, N)\n      rep(j, N) cin >> field[i][j].f >> field[i][j].s;\n    \n    rep(i, N){\n      rep(j, N){\n\tset<P> tmp, t;\n\tint x = j, y = i;\n\twhile(true){\n\t  if(tmp.find(P(x, y)) != tmp.end()){\n\t    while(true){\n\t      if(t.find(P(x, y)) != t.end()) goto F;\n\t      t.insert(P(x, y));\n\t      int xx = x, yy = y;\n\t      x = field[yy][xx].f, y = field[yy][xx].s;\n\t    }\n\t  }\n\t  \n\t  else{\n\t    tmp.insert(P(x, y));\n\t    int xx = x, yy = y;\n\t    x = field[yy][xx].f, y = field[yy][xx].s;\n\t  }\n\t}\n      F:;\n\tans.insert(t);\n      }\n    }\n    \n    cout << ans.size() << endl;    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\nint par[200];\nint Rank[200];\n\nvoid init(int n){\n    rep(i,n){\n        par[i]=i;\n        Rank[i]=0;\n    }\n}\n\nint find(int x){\n    if(par[x]==x) {\n        return x;\n    }else{\n        return par[x]=find(par[x]);\n    }\n}\n\nvoid unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y) return;\n    \n    if(Rank[x]<Rank[y]){\n        par[x]=y;\n    }else{\n        par[y]=x;\n        if(Rank[x]==Rank[y])Rank[x]++;\n    }\n}\n\n\n\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(n==0)break;\n\n\t\tpii data[200][200];\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tint a,b;\n\t\t\t\tcin>>a>>b;\n\t\t\t\tdata[i][j]=make_pair(a,b);\n\t\t\t}\n\t\t}\n\n\t\tinit(200);\n\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tunite( n*i+j , n*data[i][j].second+data[i][j].first );\n\t\t\t}\n\t\t}\n\t\tbool used[200]={};\n\t\tint c=0;\n\t\trep(i,n)rep(j,n)used[ find(n*i+j) ]=true;\n\t\trep(i,200)if(used[i])c++;\n\t\tcout<<c<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P > PP;\n \nint tx[] = {0,1,0,-1};\nint ty[] = {-1,0,1,0};\n \nstatic const double EPS = 1e-8;\n \nclass Data{\npublic:\n  int mX;\n  int mY;\n  Data(int _x,int _y){\n    mX = _x;\n    mY = _y;\n  }\n  Data():mX(0),mY(0){}\n};\n \nData path[100][100];\nbool visited[100][100];\n \nint main(){\n \n  int W;\n  while(~scanf(\"%d\",&W)){\n    if(W==0) break;\n \n    memset(visited,0,sizeof(visited));\n    for(int y=0;y<W;y++){\n      for(int x=0;x<W;x++){\n\tint nx,ny;\n\tcin >> nx >> ny;\n\tpath[y][x] = Data(nx,ny);\n      }\n    }\n \n    int res = 0;\n    for(int y=0;y<W;y++){\n      for(int x=0;x<W;x++){\n\tif(visited[y][x]) continue;\n \n\tbool tmp[100][100];\n\tmemcpy(tmp,visited,sizeof(bool)*100*100);\n \n\tint sx = x;\n\tint sy = y;\n\ttmp[sy][sx] = true;\n \n\tint nx = sx;\n\tint ny = sy;\n\tfor(int i=0;i<=W*W;i++){\n\t  int prev_x = nx;\n\t  int prev_y = ny;\n\t  nx = path[prev_y][prev_x].mX;\n\t  ny = path[prev_y][prev_x].mY;\n\t  tmp[ny][nx] = true;\n \n\t  if(nx==sx && ny==sy){\n\t    res++;\n\t    memcpy(visited,tmp,sizeof(bool)*100*100);\n\t    break;\n\t  }\n\t}\n      }\n    }\n \n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nconst int N = 100;\n\nint x[N][N];\nint y[N][N];\nint vis[N][N];\n\n\nint ans;\nvoid dfs(int yy,int xx,int sy,int sx,int now){\n  if (vis[yy][xx]){\n    if (vis[yy][xx]== now)ans++;\n    return;\n  }\n  vis[yy][xx]=now;\n  dfs(y[yy][xx],x[yy][xx],sy,sx,now);\n}\n\nmain(){\n  int n;\n  while(cin>>n && n){\n    ans=0;\n    rep(i,n){\n      rep(j,n)cin>>x[i][j]>>y[i][j];\n    }\n    rep(i,n)rep(j,n)vis[i][j]=false;\n\n    int now=1;\n    rep(i,n){\n      rep(j,n)if (!vis[i][j]){\n\tdfs(i,j,i,j,now++);\n      }\n    }\n    cout << ans << endl;\n\n  }\n  return false;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass UnionFind\n{\npublic:\n\t\tvector<int> data;\n\t\tUnionFind(int size):data(size, -1){}\n\n\t\tbool unionSet(int x, int y)\n\t\t{\n\t\t\tx = root(x); y=root(y);\n\t\t\tif(x != y)\n\t\t\t{\n\t\t\t\tif(data[y] < data[x]) swap(x, y);\n\t\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\t\tint root(int x)\n\t\t{\n\t\t\treturn data[x] < 0 ? x:data[x]=root(data[x]);\n\t\t}\n\n};\n\n\nint main()\n{\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\t\tUnionFind uf(N*N);\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t{\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tuf.unionSet(i*N+j, y*N+x);\n\t\t}\n\t\t\n\t\tbool used[10000]={0};\n\t\tint ret=0;\n\t\tfor(int i=0; i<N; i++)\n\t\tfor(int j=0; j<N; j++)\n\t\t{\n\t\t\tif(used[uf.root(i*N+j)]) continue;\n\t\t\tused[uf.root(i*N+j)]=1;\n\t\t\tret++;\n\t\t}\n\t\t\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\nint par[20000];\nint Rank[20000];\n\nvoid init(int n){\n    rep(i,n){\n        par[i]=i;\n        Rank[i]=0;\n    }\n}\n\nint find(int x){\n    if(par[x]==x) {\n        return x;\n    }else{\n        return par[x]=find(par[x]);\n    }\n}\n\nvoid unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y) return;\n    \n    if(Rank[x]<Rank[y]){\n        par[x]=y;\n    }else{\n        par[y]=x;\n        if(Rank[x]==Rank[y])Rank[x]++;\n    }\n}\n\n\n\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(n==0)break;\n\n\t\tpii data[200][200];\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tint a,b;\n\t\t\t\tcin>>a>>b;\n\t\t\t\tdata[i][j]=make_pair(a,b);\n\t\t\t}\n\t\t}\n\n\t\tinit(20000);\n\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tunite( n*i+j , n*data[i][j].second+data[i][j].first );\n\t\t\t}\n\t\t}\n\t\tbool used[20000]={};\n\t\tint c=0;\n\t\trep(i,n)rep(j,n)used[ find(n*i+j) ]=true;\n\t\trep(i,20000)if(used[i])c++;\n\t\tcout<<c<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define pb emplace_back\n\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing lint = long long;\n\nconst int inf = 1001001001;\nconst lint linf = 1001001001001001001ll;\nconst int mod = 1e9 + 7;\nconst int dx[]{0, 1, 0, -1, -1, -1, 1, 1}, dy[]{1, 0, -1, 0, -1, 1, -1, 1};\n\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; } return a > b; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; } return a < b; }\ntemplate<typename T> inline void print(const T &x, string s = \"\\n\") { cout << x << s; }\ntemplate<typename T> inline void print(const vector<T> &v, string s = \" \") \n{ rep(i, v.size()) cout << v[i] << (i + 1 == v.size() ? \"\\n\" : s); }\ninline bool inside(int y, int x, int H, int W) { return 0 <= y && y < H && 0 <= x && x < W; }\ninline lint in() { lint x; std::cin>>x; return x; }\n\nstruct UnionFind {\n\tvector<int> p, r;\n\n\tUnionFind() {}\n\tUnionFind(int size) { init(size); }\n\n\tvoid init(int size) {\n\t\tp.resize(size);\n\t\tr.resize(size);\n\t\tfor (int i = 0; i < size; ++i) {\n\t\t\tp[i] = i; r[i] = 1;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\tif (p[x] == x) return x;\n\t\telse return p[x] = find(p[x]);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\n\t\tif (x == y) return;\n\n\t\tif (r[x] > r[y]) swap(x, y);\n\t\tr[x] += r[y];\n\t\tp[y] = x;\n\t}\n\n\tbool is_root(int x) {\n\t\treturn find(x) == x;\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tint element_count(int x) {\n\t\tx = find(x);\n\t\treturn r[x];\n\t}\n};\n\nint main() {\n\tint n;\n\n\twhile (cin >> n, n) {\n\t\tUnionFind uf(n * n);\n\t\trep(i, n) rep(j, n) {\n\t\t\tint x = in(), y = in();\n\t\t\t\n\t\t\tint u = y * n + x;\n\t\t\tint v = i * n + j;\n\n\t\t\tuf.unite(u, v);\n\t\t}\n\n\t\tint ans = 0;\n\t\tbool f[10000] = {false};\n\t\trep(i, n * n) {\n\t\t\tif (f[uf.find(i)]) continue;\n\t\t\tf[uf.find(i)] = true;\n\t\t\tans++;\n\t\t}\n\n\t\tprint(ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > x(n, vector<int>(n)), y(n, vector<int>(n));\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<n; ++j){\n                cin >> x[i][j] >> y[i][j];\n            }\n        }\n\n        int ret = 0;\n        for(int i=0; i<n; ++i){\n            for(int j=0; j<n; ++j){\n                if(y[i][j] == -1)\n                    continue;\n                int y1 = i;\n                int x1 = j;\n                while(y[y1][x1] >= 0){\n                    int y2 = y[y1][x1];\n                    int x2 = x[y1][x1];\n                    y[y1][x1] = x[y1][x1] = -i*n-j-1;\n                    y1 = y2;\n                    x1 = x2;\n                    if(y[y1][x1] == -i*n-j-1)\n                        ++ ret;\n                }\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\nstruct P{int x,y;}p[100][100];\nint F(int x,int y)\n{\n\tP&r=p[y][x];\n\tif(r.x<0)return r.x+2;\n\tx=r.x;\n\tr.x=-1;\n\ty=F(x,r.y);\n\tr.x=-2;\n\treturn y;\n}\nint main()\n{\n\tint N,i,j,s;\n\twhile(scanf(\"%d\",&N),N)\n\t{\n\t\tfor(i=0;i<N;++i)for(j=0;j<N;++j)scanf(\"%d%d\",&p[i][j].x,&p[i][j].y);\n\t\tfor(s=i=0;i<N;++i)for(j=0;j<N;++j)s+=F(j,i);\n\t\tprintf(\"%d\\n\",s);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\n\nclass jump{\npublic:\n  int x,y;\n};\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    jump ju[n][n];\n    rep(i,n){\n      rep(j,n){\n\tcin>>ju[i][j].x>>ju[i][j].y;\n      }\n    }\n    vector<jump> ans;\n    rep(i,n){\n      rep(j,n){\n\tint px=j,py=i;\n\tint nx=-1,ny=-1;\n\tint cnt=0;\n\twhile(nx!=j && ny!=i){\n\t  int alt2=px;\n\t  if(cnt>n*n+1)break;\n\t  nx=ju[py][px].x;\n\t  ny=ju[py][px].y;\n\t  px=nx;\n\t  py=ny;\n\t  cnt++;\n\t}\n\tif(nx==j && ny==i){\n\t  jump alt;\n\t  alt.x=j;\n\t  alt.y=i;\n\t  ans.push_back(alt);\n\t}\n      }\n    };\n    for(int k=0;k<ans.size();k++){\n      int ax=ans[k].x,ay=ans[k].y;\n      int bx,by;\n      for(int i=0;i<n*n;i++){\n\tbx=ju[ay][ax].x;\n\tby=ju[ay][ax].y;\n\tfor(int j=0;j<ans.size();j++){\n\t  if(k!=j && bx==ans[j].x && by==ans[j].y){\n\t    ans.erase(ans.begin()+j,ans.begin()+j+1);\n\t  }\n\t}\n      }\n    }\n    cout<<ans.size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#define P pair<int,int>\n#define U 1000\nusing namespace std;\n\nint n;\nP p[200][200];\n\nbool solve(int x,int y, P org){\n  if( p[x][y].first==U )\n    return false;\n  if( p[x][y].first==org.first && p[x][y].second==org.second )\n    return true;\n  //  cout << \"  s\"<<x<<\",\"<<y<< endl;\n\n  int nx=p[x][y].first, ny=p[x][y].second;\n  return solve( nx,ny,org );\n}\nvoid loop(int x,int y){\n  if( p[x][y].first==U ) return;\n  int nx=p[x][y].first, ny=p[x][y].second;\n  p[x][y].first = U;\n  p[x][y].second = U;\n  loop( nx,ny );\n}\n\nvoid pr(){\n  for( int i=0;i<n;i++ ){\n    for( int j=0;j<n;j++ ){\n      if( p[i][j].first==U )\n\tcout << \" *,*\";\n      else \n\tcout << \" \" << p[i][j].first << \",\" << p[i][j].second;\n    }\n    cout << endl;\n  }\n}\n\nint main(){\n\n  while( cin>>n,n ){\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ )\n\tcin >> p[j][i].first >> p[j][i].second;\n    }\n    //    cout << \"------------------------------\" << endl;\n    //    pr(); cout << endl;\n\n    int ans=0;\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( p[i][j].first==U ) continue;\n\n\tif( solve( p[i][j].first,p[i][j].second,p[i][j] ) ){\n\t  loop(i,j); // erase loop\n\t  //\t  pr();cout << \" ans++ by \" << i << \" \" << j << endl;\n\t  ans++;\n\t}else{\n\t  p[i][j].first=U; p[i][j].second=U;\n\t}\n\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\nusing namespace std;\nint N, G[10009], vis[10009], x, y;\nint rec(int pos, int e) {\n\tif (vis[pos] == e) return 1;\n\tif (vis[pos] != -1) return 0;\n\treturn rec(G[pos], vis[pos] = e);\n}\nint main() {\n\twhile (cin >> N, N) {\n\t\tfor (int i = 0; i < N * N; i++) {\n\t\t\tcin >> x >> y;\n\t\t\tG[i] = y * N + x;\n\t\t\tvis[i] = -1;\n\t\t}\n\t\tint ret = 0;\n\t\tfor (int i = 0; i < N * N; i++) ret += rec(i, i);\n\t\tcout << ret << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n\nusing namespace std;\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tint nx[n][n],ny[n][n];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tcin>>nx[i][j]>>ny[i][j];\n\t\t\n\t\tint vis[n][n];\n\t\tmemset(vis,0,sizeof(vis));\n\t\t\n\t\tint cur=0,res=0;\n\t\tfor(int i=0;i<n;i++) for(int j=0;j<n;j++) if(!vis[i][j]){\n\t\t\tcur++;\n\t\t\tfor(int x=j,y=i;;){\n\t\t\t\tif(vis[y][x]){\n\t\t\t\t\tif(vis[y][x]==cur)\n\t\t\t\t\t\tres++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tvis[y][x]=cur;\n\t\t\t\tint tx=nx[y][x],ty=ny[y][x];\n\t\t\t\tx=tx,y=ty;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<res<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint N, ans, tmp;\nint x[100][100], y[100][100], d[100][100];\n\nvoid dfs(int Y, int X)\n{\n\tif (d[Y][X] == tmp)\n\t{\n\t\tans++;\n\t\ttmp++;\n\t\treturn;\n\t}\n\n\tif (d[Y][X]>=0 && d[Y][X]<tmp)\n\t{\n\t\ttmp++;\n\t\treturn;\n\t}\n\n\td[Y][X] = tmp;\n\tdfs(y[Y][X], x[Y][X]);\n}\n\nint main()\n{\n\twhile (cin >> N, N)\n\t{\n\t\tfor (int i=0; i<N; i++)\n\t\tfor (int k=0; k<N; k++)\n\t\t\tcin >> x[i][k] >> y[i][k];\n\n\t\tans = 0; tmp=0;\n\t\tmemset(d, 0xff, sizeof(d));\n\t\tfor (int i=0; i<N; i++)\n\t\tfor (int k=0; k<N; k++)\n\t\t\tif(d[i][k] == -1)\n\t\t\t\tdfs(i,k);\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nvoid solve()\n{\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\t\tP field[101][101];\n\t\tfor(int i = 0; i < N; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tcin >> field[i][j].first >> field[i][j].second;\n\t\t\t}\n\t\t}\n\t\tbool isVisited[101][101];\n\t\tbool roopStart[101][101];\n\t\tfor(int i = 0; i < N; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tisVisited[i][j] = false;\n\t\t\t\troopStart[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < N; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tint x = field[i][j].first;\n\t\t\t\tint y = field[i][j].second;\n\t\t\t\tbool roopFlag = false;\n\t\t\t\twhile(isVisited[x][y] == false)\n\t\t\t\t{\n\t\t\t\t\troopFlag = true;\n\t\t\t\t\tif(roopStart[x][y] == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tisVisited[x][y] = true;\n\t\t\t\t\tx = field[x][y].first;\n\t\t\t\t\ty = field[x][y].second;\n\t\t\t\t}\n\t\t\t\tif(roopFlag)\n\t\t\t\t{\n\t\t\t\t\troopStart[x][y] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < N; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tif(roopStart[i][j] == true)\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\npair<int, int> field[128][128];\nint v[128][128];\n\nint dfs(int x, int y, int now){\n    while(v[y][x] == 0){\n        v[y][x] = now;\n        int nx = field[y][x].first; int ny = field[y][x].second;\n        x = nx; y = ny;\n    }\n    if(v[y][x] == now) return 1;\n    return 0;\n}\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        memset(v, 0, sizeof(v));\n        for(int i=0; i < n; i++){\n            for(int j=0; j < n; j++){\n                int x, y;\n                cin >> x >> y;\n                field[i][j].first = x; field[i][j].second = y;\n            }\n        }\n\n        int ans = 0, now = 1;\n        for(int i=0; i < n; i++){\n            for(int j=0; j < n; j++){\n                if(v[i][j] == 0){\n                    ans += dfs(j, i, now);\n                    now++;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint x[10000], a, b, n, c[10000], d[10000];\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 10000; i++) { d[i] = 0; }\n\t\tcin >> n; if (n == 0) { break; }\n\t\tfor (int i = 0; i < n*n; i++) {\n\t\t\tcin >> a >> b;\n\t\t\tx[i] = b * n + a;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n*n; i++) {\n\t\t\tif(d[i]==0)\n\t\t\tfor (int j = 0; j < 10000; j++) { c[j] = 0; }\n\t\t\tint cx = i;\n\t\t\twhile (true) {\n\t\t\t\tc[cx] = 1;\n\t\t\t\tcx = x[cx];\n\t\t\t\tif (c[cx] == 1) { break; }\n\t\t\t}\n\t\t\tint C = 0;\n\t\t\tfor (int j = 0; j < 10000; j++) {\n\t\t\t\tif (c[j] == 1 && d[j] >= 1) {\n\t\t\t\t\tC = d[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (C == 0) {\n\t\t\t\tcnt++; C = cnt;\n\t\t\t}\n\t\t\tfor (int j = 0; j < 10000; j++) {\n\t\t\t\tif (c[j] == 1) { d[j] = C; }\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\n\n\nbool visited1[100][100];\nbool visited2[100][100];\nint dx[100][100];\nint dy[100][100];\n\n\nbool f(int y,int x){\n\tif(visited1[y][x]){\n\t\treturn visited2[y][x];\n\t}\n\tvisited1[y][x]=true;\n\tvisited2[y][x]=true;\n\tbool res=f(dy[y][x],dx[y][x]);\n\tvisited2[y][x]=false;\n\treturn res;\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n&&n){\n\t\tmemset(visited1,false,sizeof(visited1));\n\t\tfor(int y=0;y<n;y++){\n\t\t\tfor(int x=0;x<n;x++){\n\t\t\t\tcin>>dx[y][x]>>dy[y][x];\n\t\t\t}\n\t\t}\n\t\tint ans=0;\n\t\tfor(int y=0;y<n;y++){\n\t\t\tfor(int x=0;x<n;x++){\n\t\t\t\tif(!visited1[y][x])ans+=f(y,x);\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb(in,tmp) in.push_back(tmp)\n#define all(in) in.begin(),in.end()\n#define PI acos(-1)\nusing namespace std;\nint tile[100][200]={0};\nint co=100;\nvoid ride(int i,int j,int tile[100][200],int& count){\n  int tmp=tile[i][2*j];\n  tile[i][2*j]=co;\n  if(tile[tile[i][2*j+1]][2*tmp]==co){count++;return;}\n  else if(tile[tile[i][2*j+1]][2*tmp]>100&&tile[tile[i][2*j+1]][2*tmp]<co)return;\n  else ride(tile[i][2*j+1],tmp,tile,count);\n\n}\nint main(){\n  int n;\n  while(cin>>n,n){\n    int count=0;\n    rep(i,n){\n      rep(j,2*n){\n\tcin>>tile[i][j];\n      }\n    }\n    rep(i,n){\n      rep(j,n){\n\tco++;\n\tif(tile[i][2*j]>100)continue;\n\tride(i,j,tile,count);\n      }\n    } \n    cout<<count<<endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nstruct Pt{\n\tint x,y;\n\tPt(){}\n\tPt(int x,int y):x(x),y(y){}\n};\n\nint checked[110][110];\n\nint main() {\n\tint n;\n\tPt mp[110][110];\n\tfor(;n=in();){\n\t\tint x,y;\n\t\tfor(y=0;y<110;y++){\n\t\t\tfor(x=0;x<110;x++){\n\t\t\t\tmp[y][x].x=0;\n\t\t\t\tmp[y][x].y=0;\n\t\t\t}\n\t\t}for(y=0;y<n;y++){\n\t\t\tfor(x=0;x<n;x++){\n\t\t\t\tmp[y][x].x=in();\n\t\t\t\tmp[y][x].y=in();\n\t\t\t}\n\t\t}\n\t\tPt pt;\n\t\tmemset(checked,0,sizeof(checked));\n\t\tint res=0;\n\t\tfor(y=0;y<n;y++){\n\t\t\tfor(x=0;x<n;x++){\n\t\t\t\tif(checked[y][x])continue;\n\t\t\t\tint i;\n\t\t\t\tpt=mp[y][x];\n\t\t\t\tfor(i=0;i<110;i++){\n\t\t\t\t\tpt=mp[pt.y][pt.x];\n\t\t\t\t\tif(pt.x==x&&pt.y==y)break;\n\t\t\t\t}\n\t\t\t\t//cout<<pt.x<<\" \"<<pt.y<<\" \"<<x<<\" \"<<y<<endl;\n\t\t\t\tif(i<110){\n\t\t\t\t\tres++;\n\t\t\t\t\tfor(i=0;i<110;i++){\n\t\t\t\t\t\tchecked[pt.y][pt.x]=1;\n\t\t\t\t\t\tpt=mp[pt.y][pt.x];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t/*int xx,yy;\n\t\t\t\tfor(yy=0;yy<n;yy++){\n\t\t\t\t\tfor(xx=0;xx<n;xx++){\n\t\t\t\t\t\tcout<<checked[yy][xx];\n\t\t\t\t\t}\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t\tcout<<endl;*/\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<sstream>\n#include<set>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int> P;\n#define x first\n#define y second\nint main(){\n\tint table[] = {1000,500,100};\n\tint n;\n\twhile(cin >> n , n){\n\t\tset< set<P> > ret;\n\t\tvector< vector<P> > d(n,vector<P>(n));\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tcin >> d[i][j].x >> d[i][j].y;\n\t\t\t}\n\t\t}\n\t\trep(i,n)rep(j,n){\n\t\t\n\t\t\tP add = make_pair(i,j);\n\t\t\t\n\t\t\tset<P> lp;\n\t\t\t\n\t\t\twhile(lp.find(add) == lp.end() ){\n\t\t\t\tlp.insert(add);\n\t\t\t\tadd = d[add.y][add.x];\n\t\t\t}\n\t\t\tif(add == make_pair(i,j) )ret.insert(lp);\n\t\t\t\n\t\t}\n\t\tcout << ret.size() << endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint main()\n{\n  int n;\n  for(;cin>>n,n;)\n    {\n      pair<int,int> maps[n][n];\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  {\n\t    pair<int,int> tmp;\n\t    cin>>tmp.first>>tmp.second;\n\t    maps[i][j]=tmp;\n\t  }\n\n      int cnt=0;\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  {\n\t    if(maps[i][j].first>=0)\n\t      {\n\t\tint x,y;\n\t\ty=maps[i][j].first;\n\t\tx=maps[i][j].second;\n\t\tmaps[i][j].first=((-cnt)-1);\n\t\twhile(maps[x][y].first>=0)\n\t\t  {\n\t\t    int xx,yy;\n\t\t    yy=maps[x][y].first;\n\t\t    xx=maps[x][y].second; \t\t    \n\t\t    maps[x][y].first=((-cnt)-1);\n\t\t    x=xx;\n\t\t    y=yy;\n\t\t    //\t\t    cout<<y<<\" \"<<x<<endl;\n\t\t  }\n\t\tif(maps[y][x].first==((-cnt)-1))\n\t\t  {\n\t\t    cnt++;\n\t\t    /*\n\t\t      cout<<\"cnt:\"<<cnt<<endl;\n\t\t      for(int i=0;i<n;i++,cout<<endl)\n\t\t      for(int j=0;j<n;j++)\n\t\t      {\n\t\t      cout<<\"(\"<<maps[i][j].first<<\",\"<<maps[i][j].second<<\")\";\n\t\t      }\n\t\t    */\n\t\t  }\n\t      }\n\t  }\n      cout<<cnt<<endl;\n      /*\n      for(int i=0;i<n;i++,cout<<endl)\n\tfor(int j=0;j<n;j++)\n\t  {\n\t    cout<<\"(\"<<maps[i][j].first<<\",\"<<maps[i][j].second<<\")\";\n\t  }\n      */\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vbb;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\npii field[125][125];\nint c[125][125];\n\nint dfs(int x, int y, int check){\n    while(c[x][y] == 0){\n        c[x][y] = check;\n        int nx = field[x][y].first, ny = field[x][y].second;\n        x = nx; y = ny;\n    }\n    if(c[x][y] == check) return 1;\n    else return 0;\n}\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        rep(i, 125) rep(j, 125) c[i][j] = 0;\n        rep(i, n){\n            rep(j, n){\n                int x, y;\n                cin >> x >> y;\n                field[i][j] = mp(y, x);\n            }\n        }\n        int ans = 0;\n        rep(i, n){\n            rep(j, n){\n                if(c[i][j] == 0){\n                    ans += dfs(i, j, i+j+1);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint a[128][128];\nint b[128][128];\nint v[128][128];\n\nbool dfs(int y, int x, int c)\n{\n\tif(v[y][x] == c) return true;\n\tif(v[y][x] != 0) return false;\n\n\tv[y][x] = c;\n\treturn dfs(b[y][x], a[y][x], c);\n}\n\nint main()\n{\n\tint N;\n\twhile(cin>>N, N)\n\t{\n\t\tfor(int y=0; y<N; y++)\n\t\tfor(int x=0; x<N; x++)\n\t\t{\n\t\t\tv[y][x] = 0;\n\t\t\tcin >> a[y][x] >> b[y][x];\n\t\t}\n\n\t\tint col=0,cnt=0;\n\t\tfor(int y=0; y<N; y++)\n\t\tfor(int x=0; x<N; x++)\n\t\t{\n\t\t\tif(dfs(y,x,++col))\n\t\t\t{\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t}\n\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint n;\nint x[150][150];\nint y[150][150];\nint done[150][150];\nint sx, sy;\n\nbool dfs(int nx, int ny, int id){\n  // cout << nx << \" \" << ny << endl;\n  if(done[ny][nx] == id) return true;\n  if(done[ny][nx] != -1) return false;\n  done[ny][nx] = id;\n  return dfs(x[ny][nx], y[ny][nx], id);\n}\n\nint main(){\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n\tcin >> x[i][j] >> y[i][j];\n\tdone[i][j] = -1;\n      }\n    }\n    int cnt = 0;\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n\tsy = j;\n\tsx = i;\n\t//cout << endl;\n\n\tif(dfs(i, j, i*n+j)) {\n\t  cnt++;\n\t  //cout << \"A \" << i << \" \"<< j << endl;\n\t}\n      }\n    }\n    cout << cnt << endl;\n    \n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint n;\nint x[102][102], y[102][102];\nint t[102][102];\n\nvoid solve(){\n  memset(t, -1, sizeof(t));\n\n  int now = 0;\n  int res = 0;\n\n  for(int i = 0; i < n; i++){\n    for(int j = 0; j < n; j++){\n      if(t[i][j] != -1) continue;\n\n      int now_x = j;\n      int now_y = i;\n\n      while(t[now_y][now_x] == -1){\n        t[now_y][now_x] = now;\n        int nx = x[now_y][now_x];\n        int ny = y[now_y][now_x];\n        now_x = nx;\n        now_y = ny;\n      }\n\n      if(t[now_y][now_x] == now){\n        res++;\n      }\n\n      now++;\n    }\n  }\n\n  cout << res << endl;\n}\n\nint main(){\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++){\n      for(int j = 0; j < n; j++){\n        cin >> x[i][j] >> y[i][j];\n      }\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint x[100][100], y[100][100], z[100][100];\nint main() {\n\tint n;\n\twhile (true) {\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\tx[i][j] = 0; y[i][j] = 0; z[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tcin >> n; if (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tcin >> x[i][j] >> y[i][j];\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (z[i][j] == 0) {\n\t\t\t\t\tcnt++; int C = cnt;\n\t\t\t\t\tint cx = j, cy = i;\n\t\t\t\t\tz[cy][cx] = C;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tint cx1 = x[cy][cx], cy1 = y[cy][cx];\n\t\t\t\t\t\tcx = cx1; cy = cy1;\n\t\t\t\t\t\tif (z[cy][cx] >= 1) {\n\t\t\t\t\t\t\tC = z[cy][cx];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tz[cy][cx] = C;\n\t\t\t\t\t}\n\t\t\t\t\tcx = i, cy = j;\n\t\t\t\t\tz[cy][cx] = C;\n\t\t\t\t\tif (C != cnt) { cnt--; }\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tint cx1 = x[cy][cx], cy1 = y[cy][cx];\n\t\t\t\t\t\tcx = cx1; cy = cy1;\n\t\t\t\t\t\tif (z[cy][cx] >= 1) {\n\t\t\t\t\t\t\tC = z[cy][cx];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx[cy][cx] = C;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb(in,tmp) in.push_back(tmp)\n#define all(in) in.begin(),in.end()\n#define PI acos(-1)\nusing namespace std;\nint tile[100][200]={0};\nint co=100;\nvoid ride(int i,int j,int tile[100][200],int& count){\n  int tmp=tile[i][2*j];\n  tile[i][2*j]=co;\n  if(tile[tile[i][2*j+1]][2*tmp]==co){count++;return;}\n  else if(tile[tile[i][2*j+1]][2*tmp]>100&&tile[tile[i][2*j+1]][2*tmp]<co)return;\n  else ride(tile[i][2*j+1],tmp,tile,count);\n\n}\nint main(){\n  int n;\n  while(cin>>n,n){\n    int count=0;\n    rep(i,n){\n      rep(j,2*n){\n\tcin>>tile[i][j];\n      }\n    }\n    rep(i,n){\n      rep(j,n){\n\tco++;\n\tif(tile[i][2*j]>100)continue;\n\tride(i,j,tile,count);\n      }\n    } \n    cout<<count;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nstruct Pt{\n\tint x,y;\n\tPt(){}\n\tPt(int x,int y):x(x),y(y){}\n};\n\nint checked[110][110];\n\nint main() {\n\tint n;\n\tPt mp[110][110];\n\tfor(;n=in();){\n\t\tint x,y;\n\t\tfor(y=0;y<110;y++){\n\t\t\tfor(x=0;x<110;x++){\n\t\t\t\tmp[y][x].x=0;\n\t\t\t\tmp[y][x].y=0;\n\t\t\t}\n\t\t}for(y=0;y<n;y++){\n\t\t\tfor(x=0;x<n;x++){\n\t\t\t\tmp[y][x].x=in();\n\t\t\t\tmp[y][x].y=in();\n\t\t\t}\n\t\t}\n\t\tPt pt;\n\t\tmemset(checked,0,sizeof(checked));\n\t\tint res=0;\n\t\tfor(y=0;y<n;y++){\n\t\t\tfor(x=0;x<n;x++){\n\t\t\t\tif(checked[y][x])continue;\n\t\t\t\tint i;\n\t\t\t\tpt=mp[y][x];\n\t\t\t\tfor(i=0;i<110;i++){\n\t\t\t\t\tpt=mp[pt.y][pt.x];\n\t\t\t\t\tif(pt.x==x&&pt.y==y)break;\n\t\t\t\t}\n\t\t\t\t//cout<<pt.x<<\" \"<<pt.y<<\" \"<<x<<\" \"<<y<<endl;\n\t\t\t\tif(i<110){\n\t\t\t\t\tres++;\n\t\t\t\t\tfor(i=0;i<110;i++){\n\t\t\t\t\t\tchecked[pt.y][pt.x]=1;\n\t\t\t\t\t\tpt=mp[pt.y][pt.x];\n\t\t\t\t\t\tif(pt.x==x&&pt.y==y)break;\n\t\t\t\t\t}\n\t\t\t\t}else checked[y][x]=1;\n\t\t\t\tint xx,yy;\n\t\t\t\t/*for(yy=0;yy<n;yy++){\n\t\t\t\t\tfor(xx=0;xx<n;xx++){\n\t\t\t\t\t\tcout<<checked[yy][xx];\n\t\t\t\t\t}\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t\tcout<<endl;*/\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\nusing namespace std;\n\nclass jump{\npublic:\n  int x,y;\n};\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    jump ju[n][n];\n    rep(i,n){\n      rep(j,n){\n\tcin>>ju[i][j].x>>ju[i][j].y;\n      }\n    }\n    vector<jump> ans;\n    rep(i,n){\n      rep(j,n){\n\tint px=j,py=i;\n\tint nx=-1,ny=-1;\n\tint cnt=0;\n\twhile(nx!=j || ny!=i){\n\t  int alt2=px;\n\t  if(cnt>n*n+1)break;\n\t  nx=ju[py][px].x;\n\t  ny=ju[py][px].y;\n\t  px=nx;\n\t  py=ny;\n\t  cnt++;\n\t}\n\tif(nx==j && ny==i){\n\t  jump alt;\n\t  alt.x=j;\n\t  alt.y=i;\n\t  ans.push_back(alt);\n\t}\n      }\n    };\n    for(int k=0;k<ans.size();k++){\n      int ax=ans[k].x,ay=ans[k].y;\n      int bx,by;\n      for(int i=0;i<n*n;i++){\n\tbx=ju[ay][ax].x;\n\tby=ju[ay][ax].y;\n\tfor(int j=0;j<ans.size();j++){\n\t  if(k!=j && bx==ans[j].x && by==ans[j].y){\n\t    ans.erase(ans.begin()+j,ans.begin()+j+1);\n\t  }\n\t}\n      }\n    }\n    cout<<ans.size()<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string.h>\n#include<queue>\n#include<map>\nusing namespace std;\n\nint visited[100][100];\npair<int,int> jumpto[100][100];\n\nint main() {\n  int N,x,y;\n  while(cin>>N, N) {\n\n    for(int i=0; i<N; ++i)\n      for(int j=0; j<N; ++j) {\n    cin>>x>>y;\n    jumpto[i][j] = pair<int,int>(x,y);\n    visited[i][j] = 0;\n      }\n\n    int ans = 0;\n    for(int i=0; i<N; ++i) {\n      for(int j=0; j<N; ++j) {\n    if(visited[i][j] == 0) {\n      ans++;\n      queue< pair<int,int> > Q;\n      Q.push(pair<int,int>(j,i));\n      visited[i][j] = ans;\n      while(!Q.empty()) {\n        pair<int,int> pos = Q.front(); Q.pop();\n        int nx = jumpto[pos.second][pos.first].first;\n        int ny = jumpto[pos.second][pos.first].second;\n        if(visited[ny][nx] == ans) break;\n        if(visited[ny][nx] != 0) {\n          for(int i=0; i<N; ++i)\n        for(int j=0; j<N; ++j)\n          if(visited[i][j] == ans) visited[i][j] = visited[ny][nx];\n          ans--;\n          break;\n        }\n        Q.push(pair<int,int>(nx,ny));\n        visited[ny][nx] = ans;\n      }\n    }\n      }\n    }\n\n    cout<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100;\nconst int MAX_NN = MAX_N * MAX_N;\n\n/* typedef */\n\ntypedef vector<int> vi;\n\n/* global variables */\n\nint n, nn;\nint flds[MAX_NN], ids[MAX_NN];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n    nn = n * n;\n\n    for (int pos = 0; pos < nn; pos++) {\n      int x, y;\n      cin >> x >> y;\n      flds[pos] = y * n + x;\n    }\n\n    memset(ids, 0, sizeof(ids));\n\n    int id = 0;\n    vi fs;\n\n    for (int pos0 = 0; pos0 < nn; pos0++) {\n      if (ids[pos0] > 0) continue;\n\n      ids[pos0] = ++id;\n      fs.clear();\n      fs.push_back(pos0);\n      \n      int pos = flds[pos0];\n      while (! ids[pos]) {\n\tids[pos] = id;\n\tfs.push_back(pos);\n\tpos = flds[pos];\n      }\n\n      int id0 = ids[pos];\n      if (id0 != id) {\n\tfor (vi::iterator vit = fs.begin(); vit != fs.end(); vit++)\n\t  ids[*vit] = id0;\n\t--id;\n      }\n    }\n\n    cout << id << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nvoid dfs()\n{\n\t\n}\n\nvoid solve()\n{\n\tint N;\n\twhile(cin >> N, N)\n\t{\n\t\tvector<vector<P> > field(N, N);\n\t\tfor(int i = 0; i < N; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tcin >> field[i][j].first >> field[i][j].second;\n\t\t\t}\n\t\t}\n\t\tdeque<deque<bool> > isVisited(N, N);\n\t\tdeque<deque<bool> > roopStart(N, N);\n\t\tfor(int i = 0; i < N; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tisVisited[i][j] = false;\n\t\t\t\troopStart[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < N; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tint x = field[i][j].first;\n\t\t\t\tint y = field[i][j].second;\n\t\t\t\tbool roopFlag = false;\n\t\t\t\twhile(isVisited[x][y] == false)\n\t\t\t\t{\n\t\t\t\t\troopFlag = true;\n\t\t\t\t\tif(roopStart[x][y] == true)\n\t\t\t\t\t{\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tisVisited[x][y] = true;\n\t\t\t\t\tx = field[x][y].first;\n\t\t\t\t\ty = field[x][y].second;\n\t\t\t\t}\n\t\t\t\tif(roopFlag)\n\t\t\t\t{\n\t\t\t\t\troopStart[x][y] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < N; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < N; ++j)\n\t\t\t{\n\t\t\t\tif(roopStart[i][j] == true)\n\t\t\t\t{\n\t\t\t\t\t++count;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\nint ans=0;\nvoid dfs(const int now, vector<int>&comes,vector<int>&colors,const vector<int>&tos) {\n\tif (find(comes.begin(), comes.end(), now) != comes.end()) {\n\t\tauto it=find(comes.begin(),comes.end(),now);\n\t\tfor (auto tt = it; tt != comes.end(); ++tt) {\n\t\t\tcolors[*tt]=-1;\n\t\t}\n\t\tans++;\n\t\treturn;\n\t}\n\tif (colors[now] == -1) {\n\t\treturn ;\n\t}\n\telse {\n\t\tcomes.push_back(now);\n\t\tdfs(tos[now],comes,colors,tos);\n\t}\n}\n\nint main() {\n\twhile (true) {\n\t\tans=0;\n\t\tint N;cin>>N;\n\t\tif(!N)break;\n\t\tvector<int>tos(N*N);\n\t\tfor (int i = 0; i < N*N; ++i) {\n\t\t\tint x,y;cin>>x>>y;\n\t\t\ttos[i]=y*N+x;\n\t\t}\n\t\tvector<int>colors(N*N);\n\t\tfor (int i = 0; i <N* N; ++i) {\n\t\t\tvector<int>comes;\n\t\t\tdfs(i,comes,colors,tos);\n\t\t}\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint const N = 100;\nstruct coord { int x, y; };\n\nint main()\n{\n  int n;\n  while( cin >> n ) {\n    if ( n == 0 )\n      break;\n\n    bool pre[N][N] = {};\n    bool vst[N][N] = {};\n    coord table[N][N] = {};\n\n    for( int yy=0; yy<n; ++yy ) {\n      for( int xx=0; xx<n; ++xx ) {\n\tcoord p;\n\tcin >> p.x >> p.y;\n\ttable[xx][yy] = p;\n      }\n    }\n\n    int loops = 0;\n    for( int yy=0; yy<n; ++yy ) {\n      for( int xx=0; xx<n; ++xx ) {\n\tcoord p = { xx, yy };\n\tfor(;;) {\n\t  if ( pre[p.x][p.y] ) {\n\t    coord pm = p;\n\t    do {\n\t      if ( vst[pm.x][pm.y] )\n\t\tgoto owari;\n\t      pre[pm.x][pm.y] = false;\n\t      vst[pm.x][pm.y] = true;\n\t      pm = table[pm.x][pm.y];\n\t    } while( !( pm.x == p.x && pm.y == p.y ) );\n\t    ++loops;\n\t  owari:\n\t    break;\n\t  }\n\t  pre[p.x][p.y] = true;\n\t  p = table[p.x][p.y];\n\t}\n      }\n    }\n    cout << loops << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <set>\n\nusing namespace std;\n\nint f[101][101];\nint chk[101][101];\n\nint main(){\n    int n;\n    \n    while(cin >> n && n){\n        int x,y,ret=0,tmp;\n        set<int> s;\n\n        memset(chk, -1, sizeof(chk));\n\n        for(int j=0;j<n;j++){\n            for(int i=0;i<n;i++){\n                cin >> x >> y;\n                f[i][j] = x * 1000 + y;\n            }\n        }\n        \n        for(int j=0;j<n;j++){\n            for(int i=0;i<n;i++){\n                x = i;\n                y = j;\n                while(chk[x][y] == -1){\n                    s.insert(x*1000+y);\n                    chk[x][y] = f[x][y];\n                    tmp = f[x][y];\n                    x = tmp / 1000;\n                    y = tmp % 1000;\n                }\n                if(s.find(x*1000+y) != s.end()){\n                    ret++;\n                }\n                s.clear();\n            }\n        }\n        cout << ret << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb(in,tmp) in.push_back(tmp)\n#define all(in) in.begin(),in.end()\n#define PI acos(-1)\nusing namespace std;\nint tile[100][200]={0};\nint co=100;\nvoid ride(int i,int j,int tile[100][200],int& count){\n  int tmp=tile[i][2*j];\n  tile[i][2*j]=co;\n  if(tile[tile[i][2*j+1]][2*tmp]==co){count++;return;}\n  else if(tile[tile[i][2*j+1]][2*tmp]>100&&tile[tile[i][2*j+1]][2*tmp]<co)return;\n  else ride(tile[i][2*j+1],tmp,tile,count);\n\n}\nint main(){\n  int n;\n  while(cin>>n,n){\n    int count=0;\n    rep(i,n){\n      rep(j,2*n){\n\tcin>>tile[i][j];\n      }\n    }\n    rep(i,n){\n      rep(j,n){\n\tco++;\n\tif(tile[i][2*j]>100)continue;\n\tride(i,j,tile,count);\n      }\n    } \n    cout<<count<<endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint const N = 100;\nstruct coord { int x, y; };\n\nint main()\n{\n  int n;\n  while( cin >> n ) {\n    if ( n == 0 )\n      break;\n\n    bool pre[N][N] = {};\n    bool vst[N][N] = {};\n    coord table[N][N] = {};\n\n    for( int yy=0; yy<n; ++yy ) {\n      for( int xx=0; xx<n; ++xx ) {\n\tcoord p;\n\tcin >> p.x >> p.y;\n\ttable[xx][yy] = p;\n      }\n    }\n\n    int loops = 0;\n    for( int yy=0; yy<n; ++yy ) {\n      for( int xx=0; xx<n; ++xx ) {\n\tcoord p = { xx, yy };\n\tfor(;;) {\n\t  if ( pre[p.x][p.y] ) {\n\t    coord pm = p;\n\t    do {\n\t      if ( vst[pm.x][pm.y] )\n\t\tgoto owari;\n\t      pre[pm.x][pm.y] = false;\n\t      vst[pm.x][pm.y] = true;\n\t      pm = table[pm.x][pm.y];\n\t    } while( !( pm.x == p.x && pm.y == p.y ) );\n\t    ++loops;\n\t  owari:\n\t    break;\n\t  }\n\t  pre[p.x][p.y] = true;\n\t  p = table[p.x][p.y];\n\t}\n      }\n    }\n    cout << loops << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <limits>\n#include <cmath>\n#include <cassert>\n#include <map>\n#include <queue>\n#include <set>\n\nusing namespace std;\nusing ll = long long;\n\nconst int INF = 1<<30;\nconst int MOD = (int)1e9 + 7;\nconst int MAX_N = (int)1e5 + 5;\n#define debug(x) cout << #x << \": \" << x << endl\n\nint N;\npair<int, int> table[110][110];\nbool used[110][110];\nint memo[110][110];\n\nint color;\nint dfs(int y, int x)\n{\n    if(memo[y][x]) return memo[y][x];\n    pair<int ,int> p = table[y][x];\n    int res;\n    if(used[p.first][p.second]) res = color++;\n    else\n    {\n        used[p.first][p.second] = true;\n        res = dfs(p.first, p.second);\n        used[p.first][p.second] = false;\n    }\n    return memo[y][x] = res;\n}\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N, N)\n    {\n        memset(used, 0, sizeof(used));\n        memset(memo, 0, sizeof(memo));\n        memset(table, 0, sizeof(table));\n        for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < N; j++)\n            {\n                int x, y; cin >> x >> y;\n                table[i][j] = make_pair(y, x);\n            }\n        }\n\n        int ans = 0;\n        color = 1;\n        set<int> st;\n        for(int i = 0; i < N; i++)\n        {\n            for(int j = 0; j < N; j++)\n            {\n                if(memo[i][j]) continue;\n                used[i][j] = true;\n                int res = dfs(i, j);\n                if(st.count(res) == 0)\n                {\n                    st.insert(res);\n                    ans++;\n                }\n                used[i][j] = false;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n\nusing namespace std;\n\nstruct Info{\n\tInfo(){\n\t\tdir_x = dir_y = -1;\n\t\ttmp = used = false;\n\t}\n\tint dir_x,dir_y;\n\tbool used,tmp;\n\n};\n\nvoid func(int N){\n\tInfo info[N][N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++)scanf(\"%d %d\",&info[i][k].dir_x,&info[i][k].dir_y);\n\t}\n\n\tint count = 0,x,y,new_x,new_y;\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\t\t\tif(info[i][k].used == false){\n\t\t\t\tinfo[i][k].tmp = true;\n\t\t\t\tx = info[i][k].dir_x,y = info[i][k].dir_y;\n\t\t\t\twhile(info[y][x].used == false && info[y][x].tmp == false){\n\t\t\t\t\tinfo[y][x].tmp = true;\n\t\t\t\t\tnew_x = info[y][x].dir_x;\n\t\t\t\t\tnew_y = info[y][x].dir_y;\n\t\t\t\t\tx = new_x;\n\t\t\t\t\ty = new_y;\n\t\t\t\t}\n\t\t\t\tif(y == i && x == k){\n\t\t\t\t\tcount++;\n\n\t\t\t\t\tinfo[i][k].used = true;\n\t\t\t\t\tx = info[i][k].dir_x,y = info[i][k].dir_y;\n\t\t\t\t\twhile(info[y][x].used == false){\n\t\t\t\t\t\tinfo[y][x].used = true;\n\t\t\t\t\t\tnew_x = info[y][x].dir_x;\n\t\t\t\t\t\tnew_y = info[y][x].dir_y;\n\t\t\t\t\t\tx = new_x;\n\t\t\t\t\t\ty = new_y;\n\t\t\t\t\t}\n\n\t\t\t\t}else{\n\n\t\t\t\t\tinfo[i][k].tmp = false;\n\t\t\t\t\tx = info[i][k].dir_x,y = info[i][k].dir_y;\n\t\t\t\t\twhile(info[y][x].used == false && info[y][x].tmp == true){\n\t\t\t\t\t\tinfo[y][x].tmp = false;\n\t\t\t\t\t\tnew_x = info[y][x].dir_x;\n\t\t\t\t\t\tnew_y = info[y][x].dir_y;\n\t\t\t\t\t\tx = new_x;\n\t\t\t\t\t\ty = new_y;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",count);\n}\n\n\nint main(){\n\n\tint N;\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc(N);\n\t}\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace tree {\nstruct union_find {\n  vector<int> par, rank, size;\n  int compnum;\n\n  union_find(int N) {\n    compnum = N;\n    par.resize(N), rank.resize(N), size.resize(N);\n    for(int i=0; i<N; i++) {\n      par[i] = i;\n      rank[i] = 0;\n      size[i] = 1;\n    }\n  }\n\n  int root(int x) {\n    return par[x] == x ? x : par[x] = root(par[x]);\n  }\n\n  void unite(int x, int y) {\n    x = root(x), y = root(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) {\n      par[x] = y, size[y] += size[x];\n    } else {\n      par[y] = x, size[x] += size[y];\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n    compnum--;\n  }\n\n  int operator[](int x) { return root(x); }\n  void operator()(int x, int y) { return unite(x, y); }\n\n  bool same(int x, int y) { return root(x) == root(y); }\n  int size_of(int x) { return size[root(x)]; }\n  int num_of_comps() { return compnum; }\n};\n}\n\nint main() {\n\n  for(int N; cin >> N && N;) {\n    int toy[N][N], tox[N][N];\n    rep(i, N) {\n      rep(j, N) {\n        int x, y; cin >> x >> y;\n        toy[i][j] = y;\n        tox[i][j] = x;\n      }\n    }\n\n    tree::union_find uf(N * N);\n    rep(_i, N) rep(_j, N) {\n      int i = _i, j = _j;\n      if((i == toy[i][j] && j == tox[i][j]) || !uf.same(i * N + j, toy[i][j] * N + tox[i][j])) {\n        while(!uf.same(i * N + j, toy[i][j] * N + tox[i][j])) {\n          uf(i * N + j, toy[i][j] * N + tox[i][j]);\n          tie(i, j) = make_pair(toy[i][j], tox[i][j]);\n        }\n      }\n    }\n    cout << uf.num_of_comps() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n\nusing namespace std;\n\nint N;\nint x[100][100];\nint y[100][100];\nint f[100][100];\nint cnt;\n\nbool input() {\n  int i, j;\n\n  scanf(\"%d\", &N);\n  if (!N) return false;\n  for (i = 0; i < N; i++) {\n    for (j = 0; j < N; j++) {\n      scanf(\"%d %d\", &x[i][j], &y[i][j]);\n    }\n  }\n\n  return true;\n}\n\nint main(){\n  int i, j, a, b, tmp, k, l;\n\n  while(input()){\n    cnt = 0;\n    fill(f[0], f[0] + 100 * 100, 0);\n\n    for (i = 0; i < N; i++) {\n      for (j = 0; j < N; j++) {\n        if (f[i][j] != 0) continue;\n        f[i][j]++;\n        a = x[i][j];\n        b = y[i][j];\n        while (true) {\n          if (f[b][a] == -1 || f[b][a] == 2) break;\n          f[b][a]++;\n          if (f[b][a] == 2) {\n            cnt++;\n            break;\n          }\n          tmp = x[b][a];\n          b   = y[b][a];\n          a   = tmp;\n        }\n\n        for (k = 0; k < N; k++) {\n          for (l = 0; l < N; l++) {\n            if (f[k][l] == 1) f[k][l] = -1;\n          }\n        }\n\n      }\n    }\n\n    printf(\"%d\\n\", cnt);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n\nusing namespace std;\n\nint p;\nbool check(int *a, int n)\n{\n  for(int i = 0; i < n; i++){\n    if(a[i] >= 0){\n      p = i;\n      return true;\n    }\n  }\n\n  return false;\n}\n\nint main(int argc, char **argv)\n{\n  int *a, n, s, t, q;\n\n  while(1){\n    cin >> n;\n    if(n == 0){\n      break;\n    }\n    \n    a = (int *)calloc((n+1)*(n+1), sizeof(int));\n    for(int i = 0; i < n*n; i++){\n      cin >> s >> t;\n      a[i] = s + t*n;\n    }\n\n    s = 0;\n    t = -1;\n    while(check(a, n*n)){\n      q = a[p];\n      a[p] = t;\n      p = q;\n      while(1){\n\tif(a[p] == t){\n\t  s++;\n\t  break;\n\t} else if(a[p] < 0 && a[p] > t){\n\t  break;\n\t}\n\tq = a[p];\n\ta[p] = t;\n\tp = q;\n      }\n      t--;\n    }\n    cout << s << endl;\n    free(a);\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nP t[101][101];\nint loop[101][101];\n\nint solve(int x,int y,int now){\n\twhile(loop[y][x] == 0){\n\t\tloop[y][x] = now;\n\t\tint nx = t[y][x].first;\n\t\tint ny = t[y][x].second;\n\t\tx = nx;\n\t\ty = ny;\n\t}\n\n\tif(loop[y][x] == now) return 1;\n\treturn 0;\n}\n\nint main(void){\n\tint n;\n\n\twhile(cin>>n && n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcin>>t[i][j].first>>t[i][j].second;\n\t\t\t}\n\t\t}\n\n\t\tmemset(loop,0,sizeof(loop));\n\t\tint now = 1;\n\t\tint ans = 0;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(loop[i][j] == 0){\n\t\t\t\t\tans += solve(j,i,now);\n\t\t\t\t\tnow++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout<<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\nint nxt_x[110][110], nxt_y[110][110], checked[110][110];\n\nint main() {\n  int N;\n  while(cin >> N, N) {\n    memset(nxt_x, 0, sizeof(nxt_x));\n    memset(nxt_y, 0, sizeof(nxt_y));\n    memset(checked, 0, sizeof(checked));\n    \n    for(int i=0; i<N; i++) {\n      for(int j=0; j<N; j++) {\n        int col, row; cin >> col >> row;\n        nxt_x[i][j] = row;\n        nxt_y[i][j] = col;\n      }\n    }\n\n    int ans = 0;\n    for(int i=0; i<N; i++) {\n      for(int j=0; j<N; j++) {\n        if(checked[i][j]) continue;\n        int id = ans + 1, res = -1;\n        int x = i, y = j;\n\n        while(1) {\n          int nx = nxt_x[x][y];\n          int ny = nxt_y[x][y];\n\n          // printf(\"(x, y) = %d, (nx, ny) = %d, id = %d\\n\", x, y, nx, ny, checked[nx][ny]);\n          if(checked[nx][ny] == 0) {\n            checked[nx][ny] = id;\n          }\n          else {\n            if(checked[nx][ny] == id) {\n              ans++;\n            }\n            res = checked[nx][ny];\n            break;\n          }\n\n          x = nx, y = ny;\n        }\n\n        x = i, y = j;\n        while(1) {\n          if(checked[x][y] == res) break;\n          checked[x][y] = res;\n          int nx = nxt_x[x][y], ny = nxt_y[x][y];\n          x = nx, y = ny;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <vector>\nusing namespace std;\n\n\nclass Point{\npublic:\n  int x, y;\n};\n\nint cnt;\nPoint data[100][100];\nbool visited[100][100];\nbool loop[100][100];\n\n\nvoid rec(int x, int y, int sx, int sy) {\n  if(loop[y][x]) return;\n  if(visited[y][x]) {\n    if(x == sx && y == sy) {\n      cnt++;\n      loop[y][x] = true;\n    }\n    return;\n  }\n  visited[y][x] = true;\n  rec(data[y][x].x, data[y][x].y, sx, sy);\n}\n\nint main() {\n  while(1) {\n    int N;\n    cin >> N;\n    if(N == 0) break;\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) {\n\tcin >> data[i][j].x >> data[i][j].y;\n      }\n    }\n\n    cnt = 0;\n\n    fill(&loop[0][0], &loop[N-1][N-1]+1, false);\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) {\n\tif(!visited[i][j]) {\n\t  fill(&visited[0][0], &visited[N-1][N-1]+1, false);\n\t  rec(j, i, j, i);\n\t}\n      }\n    }\n\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\n#include<cstring>\nusing namespace std;\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        int toi[n][n], toj[n][n];\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                cin >> toj[i][j] >> toi[i][j];\n            }\n        }\n        bool visit[n][n];\n        memset(visit, 0, sizeof(visit));\n        int ans = 0;\n        for(int i = 0; i < n; i++){\n            for(int j = 0; j < n; j++){\n                if(visit[i][j]) continue;\n                set<pair<int,int>> used;\n                int ni = i, nj = j;\n                while(!visit[ni][nj]){\n                    used.insert({ni,nj});\n                    visit[ni][nj] = true;\n                    int nni = toi[ni][nj], nnj = toj[ni][nj];\n                    ni = nni, nj = nnj;\n                }\n                if(used.count({ni,nj})) ans++;\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nsigned main(){\n  int n;\n  while(cin>>n,n){\n    int x[n][n],y[n][n];\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n\tcin>>x[j][i]>>y[j][i];\n    bool used[n][n];\n    bool visit[n][n];\n    memset(used,0,sizeof(used));\n    int ans=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(used[i][j]) continue;\n\tmemset(visit,0,sizeof(visit));\n\tint tx=i,ty=j;\n\tbool f=1;\n\twhile(!visit[tx][ty]){\n\t  //cout<<tx<<\" \"<<ty<<endl;\n\t  if(used[tx][ty]){\n\t    f=0;\n\t    break;\n\t  }\n\t  visit[tx][ty]=1;\n\t  int py=ty,px=tx;\n\t  tx=x[px][py];\n\t  ty=y[px][py];\n\t}\n\tif(f){\n\t  ans++;\n\t  while(!used[tx][ty]){\n\t    used[tx][ty]=1;\n\t    int py=ty,px=tx;\n\t    tx=x[px][py];\n\t    ty=y[px][py];\n\t  }\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nint n;\nint floor[100][100];\nint x[100][100],y[100][100];\n\nbool rec(int h,int w, int c){\n\n  floor[h][w] = c;\n\n  int tmp = floor[y[h][w]][x[h][w]];\n  if(tmp == c)return true;\n  else if(tmp < c){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(floor[i][j] == c)floor[i][j] = tmp;\n      }\n    }\n    return false;\n  }else{\n    return rec(y[h][w],x[h][w],c);\n  }\n}\n\nint main(){\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tcin >> x[i][j] >> y[i][j];\n\tfloor[i][j] = 10000;\n      }\n    }\n\n    int ans = 0;\n\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(floor[i][j] > ans){\n\t  if(rec(i,j,ans))ans++;\n\t}\n      }\n    }\n\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint main(){\n    int n;\n    while(cin >> n , n){\n        int px[n][n] , py[n][n];\n        int x , y;\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < n; j++)\n                cin >> px[i][j] >> py[i][j];\n        int visited[n][n] = {};\n        int ans = 0;\n        for(int i = 0; i < n; i++)\n            for(int j = 0; j < n; j++){\n                stack <pair <int , int> > st;\n                if(visited[i][j] == 2)continue;\n                visited[i][j] = 1;\n                st.push(make_pair(i,j));\n                int y = py[i][j] , x = px[i][j];\n                while(1){\n                    if(visited[y][x] != 0){\n                        if(visited[y][x] == 1){\n                            ans++;\n                            visited[y][x] = 2;\n                        }\n                        while(!st.empty()){\n                            if(visited[st.top().first][st.top().second] != 2)\n                                visited[st.top().first][st.top().second] = 0;\n                            st.pop();\n                        }\n                        break;\n                    }\n                    else{\n                        visited[y][x] = 1;\n                        st.push(make_pair(y,x));\n                    }\n                    int kari = y;\n                    y = py[y][x];\n                    x = px[kari][x];\n                    kari = y;\n                }\n            }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define x second\n#define y first\nusing namespace std;\npair<int,int>a[101][101];\nint col[101][101];\nint n;\nvoid dfs(int y1,int x1){\n  col[y1][x1]=1;\n  if(!col[a[y1][x1].y][a[y1][x1].x])dfs(a[y1][x1].y,a[y1][x1].x);\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      if(!col[i][j]&&a[i][j].y==y1&&a[i][j].x==x1)\n        dfs(i,j);\n}\nint main(){\n  while(cin>>n,n){\n    memset(col,0,sizeof(col));\n    memset(a,0,sizeof(a));\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n        cin>>a[i][j].x>>a[i][j].y;\n    int sum=0;\n    for(int i=0;i<n;i++)\n      for(int j=0;j<n;j++)\n        if(!col[i][j])dfs(i,j),sum++;\n    cout<<sum<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define popcount __builtin_popcount\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double PI = acos(-1.0);\n\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tint tx[128][128], ty[128][128];\n\t\trep (i, n)\n\t\t\trep (j, n)\n\t\t\t\tcin >> tx[i][j] >> ty[i][j];\n\n\t\tint visit[128][128];\n\t\tmemset(visit, -1, sizeof(visit));\n\n\t\tint res = 0;\n\t\tfor (int y = 0; y < n; ++y)\n\t\t{\n\t\t\tfor (int x = 0; x < n; ++x)\n\t\t\t{\n\t\t\t\tint mark = n * y + x;\n\t\t\t\tif (visit[y][x] == -1)\n\t\t\t\t{\n\t\t\t\t\tint cx = x, cy = y;\n\t\t\t\t\twhile (visit[cy][cx] == -1)\n\t\t\t\t\t{\n\t\t\t\t\t\tvisit[cy][cx] = mark;\n\t\t\t\t\t\tint xx = cx, yy = cy;\n\t\t\t\t\t\tcx = tx[yy][xx];\n\t\t\t\t\t\tcy = ty[yy][xx];\n\n\t\t\t\t\t\tif (visit[cy][cx] == mark)\n\t\t\t\t\t\t\t++res;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cctype>\nusing namespace std;\n\ntypedef long long ll;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n\nint n;\nint x[102][102],y[102][102];\nint used[102][102];\n\nbool draw(int xx,int yy,int id){\n  while(1){\n    used[yy][xx] = id;\n    int nx = x[yy][xx];\n    int ny = y[yy][xx];\n\n    if(used[ny][nx] != -1){\n      return used[ny][nx] == id;\n    }\n\n    xx = nx;\n    yy = ny;\n  }\n\n  return false;\n}\n\nint main(){\n  while(scanf(\"%d\",&n),n){\n    rep(i,n){\n      rep(j,n){\n        scanf(\"%d%d\",&x[i][j],&y[i][j]);\n      }\n    }\n\n    int id = 0, ans = 0;\n    memset(used,-1,sizeof(used));\n\n    rep(i,n){\n      rep(j,n){\n        if(used[i][j] != -1) continue;\n        ans += draw(j,i,id);\n        id++;\n      }\n    }\n\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\nusing namespace std;\nint c,x[100][100],y[100][100];\nbool G[100][100],d[100][100];\n\nvoid fs(int i,int j){\n  if(G[i][j]){\n    if(d[i][j]) c++;\n  }\n  else{\n    G[i][j] = true;\n    d[i][j] = true;\n    fs(x[i][j],y[i][j]);\n  }\n}\n\nint main(){\n  int i,j,n;\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n    c = 0;\n    for(j=0;j<n;j++){\n      for(i=0;i<n;i++){\n\tcin >> x[i][j] >> y[i][j];\n\tG[i][j] = false;\n      }\n    }\n\n    for(j=0;j<n;j++){\n      for(i=0;i<n;i++){\n\tif(!G[i][j]){\n\t  for(int k=0;k<n;k++){\n\t    for(int l=0;l<n;l++) d[k][l] = 0;\n\t  }\n\t  fs(i,j);\n\t}\n      }\n    }\n    cout << c << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define Y first\n#define X second\n#define INF 1 << 30\n\ntypedef pair<int, int> pi;\ntypedef pair<int, pi> pii;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint cnt[101][101];\nvector<vector<pi> >flr(101, vector<pi>(101));\n\nint func(int y, int x, int now){\n  while(cnt[y][x] == 0){\n    cnt[y][x] = now;\n    int ny = flr[y][x].Y;\n    int nx = flr[y][x].X;\n    y = ny;\n    x = nx;\n  }\n\n  if(cnt[y][x] == now) return 1;\n  return 0;\n}\n\nint main(){\n  int N, x, y;\n  while(scanf(\"%d\", &N) && N){\n    rep(i, N) rep(j, N){\n      scanf(\"%d%d\", &x, &y);\n      flr[i][j] = make_pair(y, x);\n    }\n\n    rep(i, 100) rep(j, 100) cnt[i][j] = 0;\n    int res = 0;\n    int loop = 1;\n    rep(i, N) rep(j, N){\n      if(cnt[i][j] == 0){\n\tres += func(i, j, loop);\n\tloop++;\n      }\n    }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\n\nusing namespace std;\n\nint n,vis[101][101];\nstruct point{int x,y;};\npoint grid[101][101];\n\nint dfs(int x,int y,int fg){\n\n\tvis[y][x]=fg;\n\tpoint nx=grid[y][x];\n\tint res=vis[nx.y][nx.x];\n\t\n\tif(vis[nx.y][nx.x]==0)res=dfs(nx.x,nx.y,fg);\n\tvis[y][x]=res;\n\t\n\treturn res;\n}\n\nint main(void){\n\n\tpoint p;\n\t\n\twhile(cin >> n,n){\n\t\tfill(vis[0],vis[101],0);\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcin >> p.x >> p.y;\n\t\t\t\tgrid[i][j]=p;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(!vis[i][j]){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tint tmp=dfs(j,i,cnt);\n\t\t\t\t\tif(tmp!=cnt)cnt--;\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << cnt-1 << endl;\n\t}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint n,x[100][100],y[100][100];\nint v[100][100],nv;\n\nint rec(int cy,int cx)\n{\n\tint &c=v[cy][cx];\n\tif(c==-2)return nv++,-2;\n\tif(c>=0)return c;\n\tc=-2;\n\t\n\tint ny=y[cy][cx],nx=x[cy][cx],r=rec(ny,nx);\n\tc=r==-2?nv-1:r;\n\treturn r;\n}\n\nint main()\n{\n\twhile(scanf(\"%d\",&n),n)\n\t{\n\t\trep(i,n)rep(j,n)scanf(\"%d%d\",x[i]+j,y[i]+j),v[i][j]=-1;\n\t\tnv=0;\n\t\trep(i,n)rep(j,n)if(v[i][j]<0)rec(i,j);\n\t\tprintf(\"%d\\n\",nv);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\n#define iter(it,c) for(auto it=c.begin(); it!=c.end(); it++)\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nvoid visit(const vvi &g, int v, vvi& scc,\n           stack<int> &S, vector<bool> &inS,\n           vector<int> &low, vector<int> &num, int& time) {\n    low[v] = num[v] = ++time;\n    S.push(v); inS[v] = true;\n    iter(e, g[v]) {\n        int w = *e;\n        if (num[w] == 0) {\n            visit(g, w, scc, S, inS, low, num, time);\n            low[v] = min(low[v], low[w]);\n        } else if (inS[w])\n            low[v] = min(low[v], num[w]);\n    }\n    if (low[v] == num[v]){\n        scc.push_back(vi());\n        while (1) {\n            int w = S.top(); S.pop(); inS[w] = false;\n            scc.back().push_back(w);\n            if (v == w) break;\n        }\n    }\n}\n\nvoid scc(vvi const& g, vvi& res) {\n    int const n = g.size();\n    vi num(n), low(n);\n    stack<int> S;\n    vector<bool> inS(n);\n    int time = 0;\n    rep(u,n)if(num[u]==0) visit(g, u, res, S, inS, low, num, time);\n}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vvi g(n*n);\n        rep(i,n)rep(j,n){\n            int x,y; cin>>x>>y;\n            int u=i*n+j;\n            int v=y*n+x;\n            g[u].push_back(v);\n        }\n        vvi ans;\n        scc(g,ans);\n        int c=0;\n        rep(i,ans.size()){\n            if(ans[i].size()==1){\n                if(g[ans[i][0]][0]!=ans[i][0]) c++;\n            }\n        }\n        cout << ans.size()-c << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <list>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <complex>\n#include <cstdlib>\n#include <cstring>\n#include <numeric>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint n;\npii board[110][110];\nint visit[110][110];\n\nbool check(int px,int py,int level){\n\tint nx,ny;\n\twhile(visit[py][px] == 0){\n\t\tvisit[py][px] = level;\n\t\tnx = board[py][px].first;\n\t\tny = board[py][px].second;\n\t\tpx = nx;\n\t\tpy = ny;\n\t}\n\tif(visit[py][px] == level)return true;\n\treturn false;\n}\n\nint main(){\n\twhile(cin>>n,n){\n\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tcin>>board[i][j].first>>board[i][j].second;\n\t\t\t}\n\t\t}\n\t\tmemset(visit, 0, sizeof(visit));\n\t\tint level = 0;\n\t\tint ans = 0;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\tif(visit[i][j] == 0){\n\t\t\t\t\tlevel++;\n\t\t\t\t\tif(check(j, i, level)){\n\t\t\t\t\t\tans++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout <<ans<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint x[100][100],y[100][100],d[100][100];\nint counter;\nint ans;\nvoid cal(int X,int Y){\n\tif(d[X][Y]==-1){\n\t\td[X][Y]=counter;\n\t\tcal(x[X][Y],y[X][Y]);\n\t}\n\telse if(d[X][Y]==counter){\n\t\tans++;\n\t}\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tans=counter=0;\n\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)cin>>x[j][i]>>y[j][i],d[j][i]=-1;;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(d[i][j]==-1){\n\t\t\t\t\tcounter++;\n\t\t\t\t\tcal(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint x[10000], n, c[10000], d[10000];\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 10000; i++) { d[i] = 0; }\n\t\tcin >> n; if (n == 0) { break; }\n\t\tfor (int i = 0; i < n*n; i++) {\n\t\t\tcin >> x[i];\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n*n; i++) {\n\t\t\tfor (int j = 0; j < 10000; j++) { c[i] = 0; }\n\t\t\tint cx = i;\n\t\t\twhile (true) {\n\t\t\t\tc[cx] = 1;\n\t\t\t\tcx = x[cx];\n\t\t\t\tif (c[cx] == 1) { break; }\n\t\t\t}\n\t\t\tint C = 0;\n\t\t\tfor (int j = 0; j < 10000; j++) {\n\t\t\t\tif (c[j] == 1 && d[j] >= 1) {\n\t\t\t\t\tC = d[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (C == 0) {\n\t\t\t\tcnt++; C = cnt;\n\t\t\t}\n\t\t\tfor (int j = 0; j < 10000; j++) {\n\t\t\t\tif (c[cx] == 1) { d[cx] = C; }\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <string.h>\n#include <string>\n#include <cmath>\n#include <complex>\n#include <map>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<int(n);++i)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> P;\nstatic const int INF=1<<24;\n\n\nint main(){\n\tint n;\n\tP m[110][110];\n\tint vi[110][110];\n\twhile(cin>>n,n){\n\t\trep(i,110){\n\t\t\trep(j,110){\n\t\t\t\tm[i][j].F=0;\n\t\t\t\tm[i][j].S=0;\n\t\t\t\tvi[i][j]=0;\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tcin>>m[i][j].F>>m[i][j].S;\n\t\t\t}\n\t\t}\n\t\tint x,y;\n\t\tint res=0;\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tx=j;\n\t\t\t\ty=i;\n\t\t\t\trep(k,n*n){\n\t\t\t\t\tP tmp=m[y][x];\n\t\t\t\t\tx=tmp.F;\n\t\t\t\t\ty=tmp.S;\n\t\t\t\t}\n\t\t\t\tif(vi[y][x]==0){\n\t\t\t\t\tres++;\n\t\t\t\t\trep(k,n*n+10){\n\t\t\t\t\t\tif(vi[y][x]==1){\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvi[y][x]=1;\n\t\t\t\t\t\tP tmp=m[y][x];\n\t\t\t\t\t\tx=tmp.F;\n\t\t\t\t\t\ty=tmp.S;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <vector>\nusing namespace std;\n\n\nclass Point{\npublic:\n  int x, y;\n};\n\nint cnt;\nPoint data[100][100];\nbool visited[100][100];\nbool loop[100][100];\n\n\nvoid rec(int x, int y, int sx, int sy) {\n  if(loop[y][x]) return;\n  if(visited[y][x]) {\n    if(x == sx && y == sy) {\n      cnt++;\n      loop[y][x] = true;\n    }\n    return;\n  }\n  visited[y][x] = true;\n  rec(data[y][x].x, data[y][x].y, sx, sy);\n}\n\nint main() {\n  while(1) {\n    int N;\n    cin >> N;\n    if(N == 0) break;\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) {\n\tcin >> data[i][j].x >> data[i][j].y;\n      }\n    }\n\n    cnt = 0;\n\n    fill(&loop[0][0], &loop[N-1][N-1]+1, false);\n    for(int i = 0; i < N; i++) {\n      for(int j = 0; j < N; j++) {\n\tfill(&visited[0][0], &visited[N-1][N-1]+1, false);\n\trec(j, i, j, i);\n      }\n    }\n\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\ntypedef pair<int,int> P;\n\nint u[111][111],n,ans,k;\nP a[111][111];\n\nvoid dfs(int x,int y) {\n  if(u[x][y]!=-1) {\n    if(u[x][y]==k) ans++;\n    return;\n  }\n  u[x][y]=k;\n  dfs(a[x][y].F,a[x][y].S);\n}\n\nint main() {\n  int n;\n  while(cin >> n && n) {\n    ans=k=0;\n    memset(u,-1,sizeof(u));\n    for(int i=0; i<n; i++) for(int j=0; j<n; j++) cin >> a[i][j].S >> a[i][j].F;\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<n; j++) {\n        if(u[i][j]==-1) {\n          dfs(i,j);\n          k++;\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<vector>\n#include<set>\n#include<algorithm>\n\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int MAX = 100;\nbool come[MAX][MAX];\nP field[MAX][MAX];\nint N;\n\nvoid init(){\n  memset(come,false,sizeof(come));\n}\n\nvoid input(){\n  for(int i = 0; i < N; i++)\n    for(int j = 0; j < N; j++) cin >> field[i][j].X >> field[i][j].Y;\n}\n\nbool find(vector<P>& v, P p){\n  for(int i = 0; i < (int)v.size(); i++)\n    if(p == v[i]) return true;\n  return false;\n}\nvoid solve(){\n\n  int ans = 0;\n\n  for(int i = 0; i < N; i++)\n    for(int j = 0; j < N; j++){\n      if(come[i][j]) continue;\n      P now = P(j,i);\n      vector<P> V;\n      V.push_back(now);\n      while(1){\n\tP nex;\n\tnex.X = field[now.Y][now.X].X;\n\tnex.Y = field[now.Y][now.X].Y;\n\tif(V[0] == nex) break;\n\tif(find(V,nex) || come[nex.Y][nex.X]){\n\t  V.clear();\n\t  break;\n\t}\n\tV.push_back(nex);\n\tnow = nex;\n      }\n      if(!V.empty()){\n\tans++;\n\tfor(int i = 0; i < (int)V.size(); i++)\n\t  come[V[i].Y][V[i].X] = true;\n      }\n    }\n  cout << ans << endl;\n}\n\nint main(){\n  while(cin >> N && N){\n    init();\n    input();\n    solve();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n;\nint x[110][110],y[110][110];\nint visited[110][110];\n\nint main(void){\n\twhile(cin >> n,n){\n\t\tint ans=0;\n\t\trep(i,n)rep(j,n)  visited[i][j]=0;\n\t\trep(i,n)rep(j,n) cin >> x[i][j] >> y[i][j];\n\t\trep(yy,n)rep(xx,n){\n\t\t\tif(visited[yy][xx]) continue;\n\t\t\tvisited[yy][xx]=-1;\n\t\t\tint cx=x[yy][xx],cy=y[yy][xx];\n\t\t\twhile(visited[cy][cx]==0){\n\t\t\t\tvisited[cy][cx]=-1;\n\t\t\t\tint nx=x[cy][cx],ny=y[cy][cx];\n\t\t\t\tswap(cx,nx),swap(cy,ny);\n\t\t\t}\n\n\t\t\tint cur=visited[cy][cx];\n\t\t\tif(cur==-1) cur=++ans;\n\t\t\tcx=xx,cy=yy;\n\t\t\twhile(visited[cy][cx]==-1){\n\t\t\t\tvisited[cy][cx]=cur;\n\t\t\t\tint nx=x[cy][cx],ny=y[cy][cx];\n\t\t\t\tswap(cx,nx),swap(cy,ny);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nint main()\n{\n  int N;\n  while (cin >> N && N != 0) {\n    vector<vector<int> > g(N*N);\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        int x, y;\n        cin >> x >> y;\n        g[i*N+j].push_back(y*N+x);\n        g[y*N+x].push_back(i*N+j);\n      }\n    }\n    vector<bool> visited(N*N, false);\n    int ans = 0;\n    for (int i = 0; i < N*N; i++) {\n      if (!visited[i]) {\n        visited[i] = true;\n        queue<int> q;\n        q.push(i);\n        ++ans;\n        while (!q.empty()) {\n          const int n = q.front();\n          q.pop();\n          for (vector<int>::const_iterator it(g[n].begin()); it != g[n].end(); ++it) {\n            if (!visited[*it]) {\n              visited[*it] = true;\n              q.push(*it);\n            }\n          }\n        }\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#define X first\n#define Y second\nusing namespace std;\n\nstruct UnionFindTree{\n\tUnionFindTree():pos(pair<int, int>(-1, -1)), root(NULL), next(NULL){}\n\tpair<int, int> pos;\n\tUnionFindTree *root;\n\tUnionFindTree *next; //この問題で入れる意味は多分ない\n};\n\nvoid dfs(int x, int y, int &count, vector<vector<UnionFindTree> > &pos){\n\tif(pos[pos[y][x].pos.Y][pos[y][x].pos.X].root==NULL){\n\t\tif(pos[y][x].root==NULL) pos[pos[y][x].pos.Y][pos[y][x].pos.X].root = &pos[y][x];\n\t\telse pos[pos[y][x].pos.Y][pos[y][x].pos.X].root = pos[y][x].root;\n\t\tdfs(pos[y][x].pos.X, pos[y][x].pos.Y, count, pos);\n\t}\n\telse if(pos[y][x].root == pos[pos[y][x].pos.Y][pos[y][x].pos.X].root){\n\t\tcount++;\n\t\treturn;\n\t}\n\telse return;\n}\n\nint main(){\n\tint n = 0;\n\twhile(cin >> n && n != 0){\n\t\tvector<vector<UnionFindTree> > pos(n, vector<UnionFindTree>(n, UnionFindTree()));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin >> pos[i][j].pos.X >> pos[i][j].pos.Y;\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(pos[i][j].root != NULL) continue;\n\t\t\t\tdfs(j, i, count, pos);\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nnamespace tree {\nstruct union_find {\n  static const int Max = 22;\n  int par[Max], rank[Max], size[Max], compnum;\n\n  union_find(int N) {\n    compnum = N;\n    for(int i=0; i<N; i++) {\n      par[i] = i;\n      rank[i] = 0;\n      size[i] = 1;\n    }\n  }\n\n  int root(int x) {\n    return par[x] == x ? x : par[x] = root(par[x]);\n  }\n\n  void unite(int x, int y) {\n    x = root(x), y = root(y);\n    if(x == y) return;\n    if(rank[x] < rank[y]) {\n      par[x] = y, size[y] += size[x];\n    } else {\n      par[y] = x, size[x] += size[y];\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n    compnum--;\n  }\n\n  int operator[](int x) { return root(x); }\n  void operator()(int x, int y) { return unite(x, y); }\n\n  bool same(int x, int y) { return root(x) == root(y); }\n  int size_of(int x) { return size[root(x)]; }\n  int num_of_comps() { return compnum; }\n};\n}\n\nint main() {\n\n  for(int N; cin >> N && N;) {\n    int toy[N][N], tox[N][N];\n    rep(i, N) {\n      rep(j, N) {\n        int x, y; cin >> x >> y;\n        toy[i][j] = y;\n        tox[i][j] = x;\n      }\n    }\n\n    tree::union_find uf(N * N);\n    rep(_i, N) rep(_j, N) {\n      int i = _i, j = _j;\n      if((i == toy[i][j] && j == tox[i][j]) || !uf.same(i * N + j, toy[i][j] * N + tox[i][j])) {\n        while(!uf.same(i * N + j, toy[i][j] * N + tox[i][j])) {\n          uf(i * N + j, toy[i][j] * N + tox[i][j]);\n          tie(i, j) = make_pair(toy[i][j], tox[i][j]);\n        }\n      }\n    }\n    cout << uf.num_of_comps() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vbb;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n\n#define loop(i,a,b) for(int i=(a);i<ull(b);++i)\n#define rep(i,n) loop(i,0,n)\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst double inf = (int)1e8;\n\npii field[125][125];\nint c[125][125];\n\nint dfs(int x, int y, int check){\n    while(c[x][y] == 0){\n        c[x][y] = check;\n        int nx = field[x][y].first, ny = field[x][y].second;\n        x = nx; y = ny;\n    }\n    if(c[x][y] == check) return 1;\n    else return 0;\n}\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        rep(i, 125) rep(j, 125) c[i][j] = 0;\n        rep(i, n){\n            rep(j, n){\n                int x, y;\n                cin >> x >> y;\n                field[i][j] = mp(y, x);\n            }\n        }\n        int ans = 0;\n        int check = 1;\n        rep(i, n){\n            rep(j, n){\n                if(c[i][j] == 0){\n                    ans += dfs(i, j, check);\n                    check++;\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nstruct Pt{\n\tint x,y;\n\tPt(){}\n\tPt(int x,int y):x(x),y(y){}\n};\n\nint checked[110][110];\n\nint main() {\n\tint n;\n\tPt mp[110][110];\n\tfor(;n=in();){\n\t\tint x,y;\n\t\tfor(y=0;y<110;y++){\n\t\t\tfor(x=0;x<110;x++){\n\t\t\t\tmp[y][x].x=0;\n\t\t\t\tmp[y][x].y=0;\n\t\t\t}\n\t\t}for(y=0;y<n;y++){\n\t\t\tfor(x=0;x<n;x++){\n\t\t\t\tmp[y][x].x=in();\n\t\t\t\tmp[y][x].y=in();\n\t\t\t}\n\t\t}\n\t\tPt pt;\n\t\tmemset(checked,0,sizeof(checked));\n\t\tint res=0;\n\t\tfor(y=0;y<n;y++){\n\t\t\tfor(x=0;x<n;x++){\n\t\t\t\tif(checked[y][x])continue;\n\t\t\t\tint i;\n\t\t\t\tpt=mp[y][x];\n\t\t\t\tfor(i=0;i<10010;i++){\n\t\t\t\t\tpt=mp[pt.y][pt.x];\n\t\t\t\t\tif(pt.x==x&&pt.y==y)break;\n\t\t\t\t}\n\t\t\t\t//cout<<pt.x<<\" \"<<pt.y<<\" \"<<x<<\" \"<<y<<endl;\n\t\t\t\tif(i<10010){\n\t\t\t\t\tres++;\n\t\t\t\t\tfor(i=0;i<10010;i++){\n\t\t\t\t\t\tchecked[pt.y][pt.x]=1;\n\t\t\t\t\t\tpt=mp[pt.y][pt.x];\n\t\t\t\t\t\tif(pt.x==x&&pt.y==y)break;\n\t\t\t\t\t}\n\t\t\t\t}else checked[y][x]=1;\n\t\t\t\t//int xx,yy;\n\t\t\t\t/*for(yy=0;yy<n;yy++){\n\t\t\t\t\tfor(xx=0;xx<n;xx++){\n\t\t\t\t\t\tcout<<checked[yy][xx];\n\t\t\t\t\t}\n\t\t\t\t\tcout<<endl;\n\t\t\t\t}\n\t\t\t\tcout<<endl;*/\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//34\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint nx[100][100];\nint ny[100][100];\nint c[100][100];\n\nint dfs(int y,int x){\n  if(c[y][x]==2){\n    return 0;\n  }else if(c[y][x]==1){\n    return 1;\n  }else{\n    int r;\n    c[y][x]=1;\n    r=dfs(ny[y][x],nx[y][x]);\n    c[y][x]=2;\n    return r;\n  }\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    for(int y=0;y<n;y++){\n      for(int x=0;x<n;x++){\n\tcin>>nx[y][x]>>ny[y][x];\n      }\n    }\n    fill(c[0],c[100],0);\n    int ans=0;\n    for(int y=0;y<n;y++){\n      for(int x=0;x<n;x++){\n\tans+=dfs(y,x);\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n\nusing namespace std;\n\ntypedef\tpair<int,int> P;\n\nbool passed[101][101];\nint cnt;\nP mt[101][101];\nint n;\nset<int> s;\nbool ok=false;\n\nvoid dfs(int x,int y){\n\tif(passed[y][x])\n\t\treturn;\n\tif(s.find(y*n+x)!=s.end()){\n\t\tok=true;\n\t\treturn;\n\t}\n\ts.insert(y*n+x);\n\tpassed[y][x]=true;\n\tdfs(mt[y][x].second,mt[y][x].first);\n}\n\nint main(){\n\n\twhile(cin>>n&&n!=0){\n\t\tcnt=0;\n\t\ts.clear();\n\t\tok=false;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tP to;\n\t\t\t\tcin>>to.second>>to.first;\n\t\t\t\tmt[i][j]=to;\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(s.find(i*n+j)!=s.end()){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tfor(int k= 0; k < 101; k++)\n\t\t\t\t\t\tfill(passed[k],passed[k]+101,false);\n\t\t\t\t\tcnt++;\n\t\t\t\t\tok=false;\n\t\t\t\t\tdfs(j,i);\n\t\t\t\t\tif(ok==true)\n\t\t\t\t\t\tcnt--;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<cnt<<endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\n\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nint dx[4] = {-1, 0, 1, 0};\nint dy[4] = {0, -1, 0, 1};\n\nint field[110][110];\nPII p[110][110];\n\nint dfs(int x, int y, int num) {\n  while(field[x][y] == 0) {\n    field[x][y] = num;\n    int nx = p[x][y].first, ny = p[x][y].second;\n    x = nx, y = ny;\n  }\n\n  if(field[x][y] == num) return 1;\n  else return 0;\n}\n\nint main() {\n  int n;  \n\n  while(cin >> n, n) {\n\n   REP(i, n) {\n      REP(j, n) {\n\tint x, y;\n\tcin >> x >> y;\n\tp[i][j] = MP(y, x);\n\tfield[i][j] = 0;\n      }\n    }\n\n   int ans = 0;\n   int cnt = 1;\n   REP(i, n) {\n     REP(j,n) {\n       if(field[i][j] == 0) {\n\t ans += dfs(i, j, cnt);\n\t cnt++;\n       }\n     }\n   }\n   cout << ans << endl;\n  }\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#define X first\n#define Y second\nusing namespace std;\n\nstruct UnionFindTree{\n\tUnionFindTree():pos(pair<int, int>(-1, -1)), root(NULL){}\n\tpair<int, int> pos;\n\tUnionFindTree *root;\n};\n\nvoid dfs(int x, int y, int &count, vector<vector<UnionFindTree> > &pos){\n\tif(pos[pos[y][x].pos.Y][pos[y][x].pos.X].root==NULL){\n\t\tif(pos[y][x].root==NULL) pos[pos[y][x].pos.Y][pos[y][x].pos.X].root = &pos[y][x];\n\t\telse pos[pos[y][x].pos.Y][pos[y][x].pos.X].root = pos[y][x].root;\n\t\tdfs(pos[y][x].pos.X, pos[y][x].pos.Y, count, pos);\n\t}\n\telse if(pos[y][x].root == pos[pos[y][x].pos.Y][pos[y][x].pos.X].root){\n\t\tcount++;\n\t}\n\tpos[y][x].root = pos[pos[y][x].pos.Y][pos[y][x].pos.X].root;\n\treturn;\n}\n\nint main(){\n\tint n = 0;\n\twhile(cin >> n && n != 0){\n\t\tvector<vector<UnionFindTree> > pos(n, vector<UnionFindTree>(n, UnionFindTree()));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin >> pos[i][j].pos.X >> pos[i][j].pos.Y;\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(pos[i][j].root != NULL) continue;\n\t\t\t\tdfs(j, i, count, pos);\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint x[100][100];\nint y[100][100];\nint loop[100][100];\n\nint check(int yy,int xx, int a){\n  if(loop[yy][xx] == a) return 1;\n  if(loop[yy][xx] == 0){\n    loop[yy][xx] = a;\n    return check(y[yy][xx],x[yy][xx],a);\n  }\n  return 0;\n}\n\nint main(){\n  int n;\n  while(n = getInt()){\n    int ans = 0;\n    int tmp = 1;\n\n    REP(i,n) REP(j,n){\n      x[i][j] = getInt();\n      y[i][j] = getInt();\n      loop[i][j] = 0;\n    }\n\n    REP(i,n) REP(j,n) if(loop[i][j] == 0){\n      ans += check(i,j,tmp++);\n    }\n\n    print(ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#ifdef Debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#else\n#define dump(x)\n#endif\n\n\nint par[10000];\nint Rank[10000];\n\nvoid init(int n){\n    rep(i,n){\n        par[i]=i;\n        Rank[i]=0;\n    }\n}\n\nint find(int x){\n    if(par[x]==x) {\n        return x;\n    }else{\n        return par[x]=find(par[x]);\n    }\n}\n\nvoid unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y) return;\n    \n    if(Rank[x]<Rank[y]){\n        par[x]=y;\n    }else{\n        par[y]=x;\n        if(Rank[x]==Rank[y])Rank[x]++;\n    }\n}\n\n\n\n\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(n==0)break;\n\t\tpii data[110][110]={};\n\t\trep(i,n)\n\t\t\trep(j,n)\n\t\t\t\tcin>>data[i][j].first>>data[i][j].second;\n\n\t\tinit(n*n);\n\n\t\trep(i,n){\n\t\t\trep(j,n){\n\t\t\t\tunite(n*i+j,n*data[i][j].second+data[i][j].first);\n\t\t\t}\n\t\t}\n\t\tbool used[10000]={};\n\t\tint sum=0;\n\t\trep(i,n*n){\n\t\t\tint aa=find(i);\n\t\t\tif( used[ aa ]==false ){\n\t\t\t\tsum++;\n\t\t\t\tused[aa]=true;\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint x[10000], a, b, n, c[10000], d[10000];\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 10000; i++) { d[i] = 0; }\n\t\tcin >> n; if (n == 0) { break; }\n\t\tfor (int i = 0; i < n*n; i++) {\n\t\t\tcin >> a >> b;\n\t\t\tx[i] = a * n + b;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n*n; i++) {\n\t\t\tfor (int j = 0; j < 10000; j++) { c[i] = 0; }\n\t\t\tint cx = i;\n\t\t\twhile (true) {\n\t\t\t\tc[cx] = 1;\n\t\t\t\tcx = x[cx];\n\t\t\t\tif (c[cx] == 1) { break; }\n\t\t\t}\n\t\t\tint C = 0;\n\t\t\tfor (int j = 0; j < 10000; j++) {\n\t\t\t\tif (c[j] == 1 && d[j] >= 1) {\n\t\t\t\t\tC = d[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (C == 0) {\n\t\t\t\tcnt++; C = cnt;\n\t\t\t}\n\t\t\tfor (int j = 0; j < 10000; j++) {\n\t\t\t\tif (c[j] == 1) { d[j] = C; }\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint par[10000], cnt;\n\nint find(int x) {\n\tif (x == par[x])return x;\n\treturn par[x] = find(par[x]);\n}\nvoid unite(int x, int y) {\n\tx = find(x); y = find(y);\n\tif (x == y)return;\n\tcnt--; par[x] = y;\n}\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\trep(i, n*n)par[i] = i;\n\t\tcnt = n*n;\n\t\trep(i, n*n) {\n\t\t\tint x, y; scanf(\"%d%d\", &y, &x);\n\t\t\tunite(i, x*n + y);\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint f(int a[][100],int x[][100],int y[][100],int p,int q,int r){  \n  if(0){\n  }else if(a[p][q]==-1){\n    a[p][q]=r;\n    if(f(a,x,y,x[p][q],y[p][q],r))\n      return 1;\n    else\n      return 0;\n  }else if(a[p][q]==r){\n    return 1;\n  }else{\n    return 0;\n  }\n}\nint main(){\n  int i,j,k;\n  int a[100][100],x[100][100],y[100][100],n;\n  while(cin>>n&&n){\n    for(i=0;i<n;i++)\n      for(j=0;j<n;j++)\n\tcin>>x[j][i]>>y[j][i];\n    memset(a,-1,sizeof(a));\n    k=0;\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n\tif(f(a,x,y,j,i,n*i+j))\n\t  k++;\n      }\n    }\n    cout<<k<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\n#include <cstring>\n#include <cstdio>\n#include <algorithm>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#define REP(i,a,n) for(int i=(a); i<(int)(n); ++i)\n#define rep(i,n) REP(i,0,n)\n#define DEB 0\n\n/*\n  êxsÁ½Æ±ëÍ¢©È¢H\n  ³µ¢[v@@X^[gÆIªê\n  (x,y)©çX^[gµÄA³µ¢[vÉÈçÈ©Á½\n  @ÙÈé}X©ç(x,y)É«½êÍA²×éKv è\n  (x,y)©çX^[gµÄA³µ¢[vÉÈÁ½\n  @²×éKvÍÈ¢AâÎÉÙÈé\n */\n\nint n;\npair<int,int> jump[110][110];\nbool used[110][110];\nint memo[110][110];\n\nint dfs(int x, int y, int sx, int sy){\n  if( memo[y][x]==1 ) return 2;\n  if( used[y][x] ){\n    if( x==sx && y==sy ) return 1;\n    return 2;\n  }\n  used[y][x] = true;\n  return dfs(jump[y][x].first, jump[y][x].second, sx, sy);\n}\nint main(){\n  while(cin>>n,n){\n    rep(i,n){\n      rep(j,n){\n\tint x,y; cin>>x>>y;\n\tjump[i][j].first = x;\n\tjump[i][j].second = y;\n      }\n    }\n#if DEB\n    rep(i,n){\n      rep(j,n){\n\tprintf(\"%d,%d \",jump[i][j].first, jump[i][j].second);\n      }\n      puts(\"\");\n    }\n    puts(\"\");\n#endif\t\n\n    int ret = 0;\n    memset(memo,0,sizeof(memo));\n\n    rep(i,n)rep(j,n)if( !memo[i][j] ){\n      memset(used,false,sizeof(used));\n      if( dfs(j,i,j,i)==1 ){\n\tmemo[i][j] = 1;\n\tret++;\n      }\n    }\n    cout << ret << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cmath>\n#include <set>\n#include <cstdio>\n#include <iomanip>\n\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define RREP(i,n) for(int (i)=(int)(n)-1;(i)>=0;(i)--)\n#define REMOVE(Itr,n) (Itr).erase(remove((Itr).begin(),(Itr).end(),n),(Itr).end())\n#define PB_VEC(Itr1,Itr2) (Itr1).insert((Itr1).end(),(Itr2).begin(),(Itr2).end())\n#define UNIQUE(Itr) sort((Itr).begin(),(Itr).end()); (Itr).erase(unique((Itr).begin(),(Itr).end()),(Itr).end())\n\ntypedef long long ll;\n\nbool used[101][101];\n\ntypedef struct{\n    int x;\n    int y;\n}Coodinate;\n\nCoodinate xy[101][101];\n\nint main(){\n    \n    while(true){\n        \n        int N;\n        cin>>N;\n        if(N==0)break;\n        \n        REP(i,N)REP(j,N)cin>>xy[i][j].x>>xy[i][j].y;\n        REP(i,101)REP(j,101)used[i][j]=false;\n    \n        int ans=0;\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                if(!used[i][j]){\n                /*    REP(k,N){\n                        REP(l,N)cout<<used[i][j];\n                        cout<<endl;\n                    }\n*/                    int xt=i,yt=j;\n                   // cout<<i<<\" \"<<j<<\";i,j\"<<endl;\n                    while(!used[xt][yt]){\n                        used[xt][yt]=true;\n                        int xtt=xt,ytt=yt;\n                        xt=xy[xtt][ytt].x;\n                        yt=xy[xtt][ytt].y;\n                    }\n                  //  cout<<xt<<\":\"<<i<<\" \"<<yt<<\":\"<<j<<endl;\n                    if(xt==i&&yt==j)ans++;\n                }\n            }\n        \n        }\n\n        cout<<ans<<endl;\n        \n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\nusing namespace std;\nint main(){\n  \n  pair <int,int> tile[100][100];\n  int n,hata[100][100],i,j,x,y,result,a;\n  \n  while(cin>>n,n){\n  \n  for(i=0;i<n;i++) for(j=0;j<n;j++){\n      cin>>x>>y;\n      tile[i][j]=make_pair(x,y);\n    }\n   for(i=0;i<n;i++) for(j=0;j<n;j++) hata[i][j]=20000;\n  \n  result=0;\n  a=0;\n  for(i=0;i<n;i++) for(j=0;j<n;j++){\n      if(hata[i][j]==20000){\n        a++;\n        //cout<<a<<endl;\n        y=i;\n        x=j;\n        result++;\n        while(1){\n          if(hata[y][x]<a){\n            result--;\n            break;\n          } else if(hata[y][x]==a) break;\n          hata[y][x]=a;\n          int y1=y,x1=x;\n          y=tile[y1][x1].second;\n          x=tile[y1][x1].first;\n        \n        }\n      }\n    }\n  cout<<result<<endl;\n  }\n  \n  return 0;\n  \n}\n\n  "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, n) FOR(i, 0, n)\n#define MP make_pair\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\n\nconst int N = 101;\nP to[N][N];\nmap<P, P> par;\n\nvoid init(){\n\trep(i, N) rep(j, N) par[MP(i, j)] = MP(i, j);\n}\n\nP find(P p){\n\tif(par[p] == p) return p;\n\treturn par[p] = find(par[p]);\n}\n\nvoid unite(P p, P q){\n\tp = find(p);\n\tq = find(q);\n\tpar[p] = q;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n, n){\n\t\tinit();\n\t\trep(i, n){\n\t\t\trep(j, n){\n\t\t\t\tint x, y;\n\t\t\t\tcin >> x >> y;\n\t\t\t\tunite(MP(i, j), MP(y, x));\n\t\t\t}\n\t\t}\n\t\tset<P> s;\n\t\trep(i, n) rep(j, n){\n\t\t\ts.insert(find(MP(i, j)));\n\t\t}\n\t\tcout << s.size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\nint x[10000], a, b, n, c[10000], d[10000];\nint main() {\n\twhile (true) {\n\t\tfor (int i = 0; i < 10000; i++) { d[i] = 0; }\n\t\tcin >> n; if (n == 0) { break; }\n\t\tfor (int i = 0; i < n*n; i++) {\n\t\t\tcin >> a >> b;\n\t\t\tx[i] = a * 100 + b;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n*n; i++) {\n\t\t\tfor (int j = 0; j < 10000; j++) { c[i] = 0; }\n\t\t\tint cx = i;\n\t\t\twhile (true) {\n\t\t\t\tc[cx] = 1;\n\t\t\t\tcx = x[cx];\n\t\t\t\tif (c[cx] == 1) { break; }\n\t\t\t}\n\t\t\tint C = 0;\n\t\t\tfor (int j = 0; j < 10000; j++) {\n\t\t\t\tif (c[j] == 1 && d[j] >= 1) {\n\t\t\t\t\tC = d[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (C == 0) {\n\t\t\t\tcnt++; C = cnt;\n\t\t\t}\n\t\t\tfor (int j = 0; j < 10000; j++) {\n\t\t\t\tif (c[cx] == 1) { d[cx] = C; }\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <cstring>\nusing namespace std;\ntypedef pair<int,int> pos;\npos map[100][100];\nint memo[100][100];\nint search(int i,int j,int count)\n{\n  if(memo[i][j] != 0) return count;\n  set<pos> list;\n  list.insert(make_pair<int,int>(i,j));\n  int number;\n  for(;;){\n    int ni,nj;\n    ni = map[i][j].first;\n    nj = map[i][j].second;\n    if(memo[ni][nj] != 0){\n      number = memo[ni][nj];\n      break;\n    }\n    if(!list.insert(make_pair<int,int>(ni,nj)).second){\n      number = ++count;\n      break;\n    }\n    i = ni;\n    j = nj;\n  }\n  for(set<pos>::iterator it = list.begin(); it != list.end(); it++){\n    memo[(*it).first][(*it).second] = number;\n  }\n  return count;\n}\nint main()\n{\n  for(;;){\n    int n;\n    cin >> n;\n    if(n==0) break;\n    memset(map,0,sizeof(map));\n    memset(memo,0,sizeof(memo));\n    for(int i=0; i<n; i++){\n      for(int j=0; j<n; j++){\n        cin >> map[i][j].second >> map[i][j].first;\n      }\n    }\n    int count = 0;\n    for(int i=0; i<n; i++){\n      for(int j=0; j<n; j++){\n        count = search(i,j,count);\n      }\n    }\n    cout << count << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <utility>\n\nusing namespace std;\n\nint p[100][100];\npair<int,int> f[100][100];\n\nint dfs(int x,int y){\n\tp[x][y] = 1;\n\tif(p[f[x][y].first][f[x][y].second] == 1) return 1;\n\telse if(p[f[x][y].first][f[x][y].second] == 0) return 0;\n\telse return dfs(f[x][y].first,f[x][y].second);\n}\n\nint main(void){\n\tint i, j, k, l, n, c;\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(!n) break;\n\t\tc = 0;\n\t\tmemset(p,-1,sizeof(p));\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tscanf(\"%d%d\",&f[j][i].first,&f[j][i].second);\n\t\t\t}\n\t\t}\n\t\tfor(i = 0;i < n;i++){\n\t\t\tfor(j = 0;j < n;j++){\n\t\t\t\tif(p[j][i] == -1 && dfs(j,i)) c++;\n\t\t\t\tfor(k = 0;k < n;k++){\n\t\t\t\t\tfor(l = 0;l < n;l++) if(p[k][l] == 1) p[k][l] = 0;\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",c);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint cnt,ans;\nint n,tx[100][100],ty[100][100],vd[100][100];\nvoid dfs(int y,int x){\n  vd[y][x]=cnt;\n  if(vd[ty[y][x]][tx[y][x]]==cnt)cnt++;\n  else if(vd[ty[y][x]][tx[y][x]]==-1)dfs(ty[y][x],tx[y][x]);\n  else ans--;\n}\nint main(){\n  while(cin>>n&&n){\n    cnt=ans=0;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tcin>>tx[i][j]>>ty[i][j];\n\tvd[i][j]=-1;\n      }\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tif(vd[i][j]==-1){\n\t  ans++;\n\t  cnt++;\n\t  dfs(i,j);\n\t}\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N, nxt[10004];\n\nint getID(int x, int y) { return y * N + x; }\n\nvoid solve() {\n\tint ans = 0;\n\tvector< bool > visited(N * N, false);\n\tfor (int v=0; v<N*N; ++v) {\n\t\tif (visited[v]) continue;\n\t\tint p = v;\n\t\tset< int > tmp;\n\t\twhile (!visited[p]) {\n\t\t\ttmp.insert(p);\n\t\t\tvisited[p] = true;\n\t\t\tp = nxt[p];\n\t\t}\n\t\tif (tmp.count(p)) ++ans;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\twhile (cin >> N, N) {\n\t\tfor (int i=0; i<N; ++i) for (int j=0; j<N; ++j) {\n\t\t\tint x, y;\n\t\t\tcin >> x >> y;\n\t\t\tnxt[getID(j,i)] = getID(x,y);\n\t\t}\n\t\tsolve();\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\n\nusing namespace std;\n\nint n,vis[101][101];\nstruct point{int x,y;};\npoint grid[101][101];\n\nint dfs(int x,int y,int fg){\n\n\tvis[y][x]=fg;\n\tpoint nx=grid[y][x];\n\tint res=vis[nx.y][nx.x];\n\t\n\tif(vis[nx.y][nx.x]==0)res=dfs(nx.x,nx.y,fg);\n\tvis[y][x]=res;\n\t\n\treturn res;\n}\n\nint main(void){\n\n\tpoint p;\n\t\n\twhile(cin >> n,n){\n\t\tfill(vis[0],vis[101],0);\n\t\t\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcin >> p.x >> p.y;\n\t\t\t\tgrid[i][j]=p;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(!vis[i][j]){\n\t\t\t\t\tcnt++;\n\t\t\t\t\tint tmp=dfs(j,i,cnt);\n\t\t\t\t\tif(tmp!=cnt)cnt--;\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << cnt-1 << endl;\n\t}\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define mp(a,b) make_pair((a),(b))\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int INF=1<<30;\nconst long long int INF_=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\npii grid[100][100];\nbool done[100][100];\nint num[100][100];\nint cnt;\n\nint DFS(int x,int y){\n\tif(done[x][y]){\n\t\tif(num[x][y]==0) return ++cnt;\n\t\treturn num[x][y];\n\t}\n\n\tdone[x][y]=true;\n\treturn num[x][y]=DFS(grid[x][y].first,grid[x][y].second);\n}\n\nvoid Solve(){\n\tint n;\n\twhile(true){\n\t\tcnt=0;\n\t\tfill_n((bool*)done,100*100,false);\n\t\tfill_n((int*)num,100*100,0);\n\t\tcin >> n;\n\t\tif(n==0) break;\n\n\t\t\n\t\trep(i,0,n) rep(j,0,n){\n\t\t\tint x,y;\n\t\t\tcin >> x >> y;\n\t\t\tgrid[j][i]=mp(x,y);\n\t\t}\n\n\t\trep(i,0,n){\n\t\t\trep(j,0,n){\n\t\t\t\tif(!done[i][j]) DFS(i,j);\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nint main(){\n    int n;\n    while(cin >>n,n){\n        auto f = [&](int y, int x){\n            return y*n+x;\n        };\n\n        const int V = n*n;\n        vector<vector<int>> G(V);\n        rep(i,n)rep(j,n){\n            int x,y;\n            cin >>x >>y;\n\n            int u = f(i,j), v = f(y,x);\n            G[u].pb(v);\n            G[v].pb(u);\n        }\n\n        int ans = 0;\n        vector<bool> vis(V);\n        rep(i,V)if(!vis[i]){\n            vis[i] = true;\n            ++ans;\n            queue<int> que({i});\n            while(!que.empty()){\n                int v = que.front();\n                que.pop();\n                for(int e:G[v])if(!vis[e]){\n                    vis[e] = true;\n                    que.push(e);\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n;\nchar warp[10000],map[10000];\n\nvoid solve(int pos, int& ans ,vector<int>& path){\n\tif( count( path.begin() , path.end() , pos ) ){\n\t\tans++;\n\t\tfor(vector<int>::iterator it = path.begin() ; it != path.end() ; ++it ){\n\t\t\tmap[ *it ] = 1;\n\t\t}\n\t\treturn ;\n\t}\n\tif( map[pos] == 0 ){\n\t\tpath.push_back( pos );\n\t\tsolve( warp[pos] , ans , path );\n\t}\n}\n\nint main(){\n\n\twhile( cin >> n , n ){\n\t\tfor(int y=0 ; y<n ; ++y ){\n\t\t\tfor(int x=0 ; x<n ; ++x ){\n\t\t\t\tint mx,my;\n\t\t\t\tcin >> mx >> my;\n\t\t\t\twarp[y*n+x] = my*n + mx;\n\t\t\t\tmap[y*n+x]  = 0;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int pos=0 ; pos<n*n ; ++pos ){\n\t\t\tif( map[pos] == 0 ){\n\t\t\t\tvector<int> path;\n\t\t\t\tsolve( pos , ans , path );\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\nusing namespace std;\n#define MAX 100\nint main()\n{\n  while(true){\n    int N;\n    pair<int,int> M[MAX][MAX];\n    set< set< pair<int, int > > > ans;\n    cin >> N;\n    if( N == 0 ) break;\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < N; ++j){\n\tint X, Y;\n\tcin >> X >> Y;\n\tM[i][j] = make_pair(X,Y);\n      }\n    }\n\n    /*\n    for(int x=0;x<N;++x){\n      for(int y=0;y<N;++y){\n\tcout << x << ' ' << y << \" GOTO \" << M[y][x].first << ' ' << M[y][x].second << endl;\n      }\n    }\n    cout << endl;\n//    continue;\n*/\n\n    for(int x = 0; x < N; ++x){\n      for(int y = 0; y < N; ++y){\n\t\n\tint vis[MAX][MAX];\n\tfor(int k = 0; k < MAX; ++k){\n\t  for(int l = 0; l < MAX; ++l){\n\t    vis[k][l] = -1;\n\t  }\n\t}\n\tvector<pair<int,int> > hist;\n\t\n\tint nx = x;\n\tint ny = y;\n\tint step = 0;\n\twhile( true ){\n\t  if( vis[ny][nx] >= 0 ){  \n\t    set< pair<int,int> > s;\n\n\t    //cout << \"END : \" << nx << ' ' << ny << endl;\n\t    //cout << \"START AT : \" << x << ' ' << y << endl;\n\t    if( vis[ny][nx] > 0 ){\n\t      hist.erase( hist.begin(), hist.begin() + vis[ny][nx] );\n\t    }\n\t    for(int k = 0; k < hist.size(); ++k){\n\t      s.insert( hist[k] );\n\t      //cout << hist[k].first << ' ' << hist[k].second << endl;\n\t    }\n\t    //cout << endl;\n\t    ans.insert( s );\n\t    break;\n\t  }else{\n\t    hist.push_back( make_pair(nx,ny) );\n\t    vis[ny][nx] = step;\n\t    step++;\n\t  }\n\t  //cout << \" NOW : \" << nx << ' ' << ny << \" NEXT : \";\n\t  int tx = nx, ty = ny;\n\t  nx = M[ty][tx].first;\n\t  ny = M[ty][tx].second;\n\t  //cout << nx << ' ' << ny << endl;\n\t}\n\t\n      }\n    }\n    /*\n    for(set< set< pair<int,int> > >::iterator its = ans.begin();\n\tits != ans.end(); ++its){\n      for(set< pair<int,int> >::iterator its2 = its->begin();\n\t  its2 != its->end(); ++its2){\n\tcout << its2->first << ' ' << its2->second << endl;\n      }\n      cout << endl;\n    }\n    */\n    cout << ans.size() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\n\nint par[10000], cnt;\n\nint find(int x) {\n\tif (x == par[x])return x;\n\treturn par[x] = find(par[x]);\n}\nvoid unite(int x, int y) {\n\tx = find(x); y = find(y);\n\tif (x == y)return;\n\tcnt--; par[x] = y;\n}\nint main() {\n\tint n;\n\twhile (scanf(\"%d\", &n), n) {\n\t\trep(i, n*n)par[i] = i;\n\t\tcnt = n*n;\n\t\trep(i, n)rep(j, n) {\n\t\t\tint x, y; scanf(\"%d%d\", &y, &x);\n\t\t\tunite(i*n + j, x*n + y);\n\t\t}\n\t\tprintf(\"%d\\n\", cnt);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\n\n\ntypedef struct t{\n\tint x,y;\n\tint loop;\n\tint scanned;\n}za;\n\nza gyou[100][100];\n\nint loop;\n\nint tansaku(int x,int y){\n\tif(gyou[x][y].scanned&&gyou[x][y].loop){\n\t\treturn gyou[x][y].loop;\n\t}else if(gyou[x][y].scanned){\n\t\t++loop;\n\t\tgyou[x][y].loop=loop;\n\t\treturn gyou[x][y].loop;\n\t}else{\n\t\tgyou[x][y].scanned=1;\n\t\tgyou[x][y].loop=tansaku(gyou[x][y].x,gyou[x][y].y);\n\t}\n\treturn gyou[x][y].loop;\n}\n\nmain(){\n\tint N;\n\twhile(cin>>N){\n\t\tif(N==0)break;\n\t\t\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tint x,y;\n\t\t\t\tcin>>x>>y;\n\t\t\t\tgyou[j][i].x=x;\n\t\t\t\tgyou[j][i].y=y;\n\t\t\t\tgyou[j][i].loop=0;\n\t\t\t\tgyou[j][i].scanned=0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tloop=0;\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tif(gyou[i][j].scanned==0){\n\t\t\t\t\tgyou[i][j].loop=tansaku(i,j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<loop<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 100\n \nint tx, ty, ans;\nint n, X[MAX][MAX], Y[MAX][MAX];\nbool visited[MAX][MAX], found[MAX][MAX];\nbool used[MAX][MAX], flg;\n \nvoid rec(int x, int y){\n    if(visited[x][y]){\n\tif(!found[x][y] && tx == x && ty == y){\n\t    found[x][y] = flg = true;\n\t    ans++;\n\t} \n\treturn;\n    }\n    visited[x][y] = true;\n    rec(X[x][y],Y[x][y]);\n}\n \nvoid draw(int x,int y){\n    if(tx == x && ty == y){\n\treturn;\n    }\n    used[x][y] = true;\n    draw(X[x][y],Y[x][y]);\n}\n \nint main(){\n    while(cin >> n ,n){\n\tfor(int i = 0 ; i < n ; i++){\n\t    for(int j = 0 ; j < n ; j++){\n\t\tcin >> X[j][i] >> Y[j][i];\n\t    }\n\t}\n \n\tans = 0;\n\tmemset(found,false,sizeof(found));\n\tmemset(used,false,sizeof(used));\n\tfor(int i = 0 ; i < n ; i++){ \n\t    for(int j = 0 ; j < n ; j++){\n\t\tmemset(visited,false,sizeof(visited));\n\t\tif(!used[i][j]){\n\t\t    flg = false;\n\t\t    visited[i][j] = true;\n\t\t    tx = i, ty = j;\n\t\t    rec(X[i][j], Y[i][j]);\n\t\t    if(flg){\n\t\t\tdraw(X[i][j], Y[i][j]);\n\t\t    }\n\t\t}\n\t    }\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ALL(v) (v).begin(), (v).end()\n\nclass DisjointSet{\nprivate:\n  vector<int> rank, p;\n  void link(int x,int y){\n    if(rank[x] > rank[y]){\n      p[y] = x;\n    }else{\n      p[x] = y;\n      if(rank[x] == rank[y]) rank[y]++;\n    }\n  }\npublic:\n  DisjointSet(int size){\n    rank.resize(size,0);\n    p.resize(size,0);\n    for(int i = 0; i < size; i++){\n      makeSet(i);\n    }\n  }\n  void makeSet(int x){\n    p[x] = x, rank[x] = 0;\n  }\n  void Union(int x,int y){\n    link(findSet(x),findSet(y));\n  }\n  int findSet(int x){\n    return( x != p[x] ? p[x] = findSet(p[x]) : p[x]);\n  }\n};\n\nint main()\n{\n  int N;\n  while(cin >> N, N){\n    DisjointSet UnionFind(N * N);\n    for(int i = 0; i < N; i++){\n      for(int j = 0; j < N; j++){\n        int x, y;\n        cin >> x >> y;\n        UnionFind.Union( i * N + j, y * N + x);\n      }\n    }\n    vector< bool > size(N * N, false);\n    for(int i = 0; i < N * N; i++){\n      size[UnionFind.findSet(i)] = true;\n    }\n    cout << count(ALL(size), true) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\npair<int, int> field[100][100];\nint visit[100][100];\n\nint dfs(int x, int y) {\n  if (visit[y][x] == 1) { return 1; }\n  if (visit[y][x] == 2) { return 0; }\n  visit[y][x] = 1;\n  int ret = dfs(field[y][x].first, field[y][x].second);\n  visit[y][x] = 2;\n  return ret;\n}\n\nchar str[1000];\n\nint main() {\n  int n;\n  while (scanf(\"%d\", &n), n) {\n    assert(1 <= n && n <= 100);\n    MEMSET(visit, 0);\n    REP(y, n) {\n      REP(x, n) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        assert(0 <= a && a < n);\n        assert(0 <= b && b < n);\n        field[y][x] = make_pair(a, b);\n      }\n    }\n    int ans = 0;\n    REP(y, n) {\n      REP(x, n) {\n        if (!visit[y][x]) {\n          ans += dfs(x, y);\n        }\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  assert(scanf(\"%s\", str) == EOF);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <cstdio>\n\n#define X first\n#define Y second\nusing namespace std;\n\nstruct UnionFindTree{\n\tUnionFindTree():pos(pair<int, int>(-1, -1)), root(NULL){}\n\tpair<int, int> pos;\n\tUnionFindTree *root;\n};\n\nvoid dfs(int x, int y, int &count, vector<vector<UnionFindTree> > &pos){\n\tif(pos[pos[y][x].pos.Y][pos[y][x].pos.X].root==NULL){\n\t\tif(pos[y][x].root==NULL) pos[pos[y][x].pos.Y][pos[y][x].pos.X].root = &pos[y][x];\n\t\telse pos[pos[y][x].pos.Y][pos[y][x].pos.X].root = pos[y][x].root;\n\t\tdfs(pos[y][x].pos.X, pos[y][x].pos.Y, count, pos);\n\t}\n\telse if(pos[y][x].root == pos[pos[y][x].pos.Y][pos[y][x].pos.X].root){\n\t\tcount++;\n\t}\n\tpos[y][x].root = pos[pos[y][x].pos.Y][pos[y][x].pos.X].root;\n\treturn;\n}\n\nint main(){\n\tint n = 0;\n\twhile(cin >> n && n != 0){\n\t\tvector<vector<UnionFindTree> > pos(n, vector<UnionFindTree>(n, UnionFindTree()));\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tcin >> pos[i][j].pos.X >> pos[i][j].pos.Y;\n\t\t\t}\n\t\t}\n\t\tint count = 0;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(pos[i][j].root != NULL) continue;\n\t\t\t\tdfs(j, i, count, pos);\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint warp[10001];\nchar map[10001];\n\nvoid solve(int pos, int& ans ,vector<int>& path){\n\tif( count( path.begin() , path.end() , pos ) ){\n\t\tans++;\n\t\tfor(vector<int>::iterator it = path.begin() ; it != path.end() ; ++it ){\n\t\t\tmap[ *it ] = 1;\n\t\t}\n\t\treturn ;\n\t}\n\tif( map[pos] == 0 ){\n\t\tpath.push_back( pos );\n\t\tsolve( warp[pos] , ans , path );\n\t}\n}\n\nint main(){\n\n\twhile( cin >> n , n ){\n\t\tfor(int y=0 ; y<n ; ++y ){\n\t\t\tfor(int x=0 ; x<n ; ++x ){\n\t\t\t\tint mx,my;\n\t\t\t\tcin >> mx >> my;\n\t\t\t\twarp[y*n+x] = my*n + mx;\n\t\t\t\tmap[y*n+x]  = 0;\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tfor(int pos=0 ; pos<n*n ; ++pos ){\n\t\t\tif( map[pos] == 0 ){\n\t\t\t\tvector<int> path;\n\t\t\t\tsolve( pos , ans , path );\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#define P pair<int,int>\n#define U 1000\nusing namespace std;\n\nint n;\nP p[200][200];\n\nbool solve(int x,int y, P org){\n  if( p[x][y].first==U )\n    return false;\n  if( p[x][y].first==org.first && p[x][y].second==org.second )\n    return true;\n  int nx=p[x][y].first, ny=p[x][y].second;\n  return solve( nx,ny,org );\n}\nvoid loop(int x,int y){\n  if( p[x][y].first==U ) return;\n  int nx=p[x][y].first, ny=p[x][y].second;\n  p[x][y].first = U;\n  p[x][y].second = U;\n  loop( nx,ny );\n}\n\nint main(){\n\n  while( cin>>n,n ){\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ )\n\tcin >> p[j][i].first >> p[j][i].second;\n    }\n\n    int ans=0;\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( p[i][j].first==U ) continue;\n\n\tif( solve( p[i][j].first,p[i][j].second,p[i][j] ) ){\n\t  loop(i,j); // erase loop\n\t  ans++;\n\t}\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n \n \nusing namespace std;\n \nint n,vis[101][101];\nstruct point{int x,y;};\npoint grid[101][101];\n \nint dfs(int x,int y,int fg){\n \n    vis[y][x]=fg;\n    point nx=grid[y][x];\n    int res=vis[nx.y][nx.x];\n     \n    if(vis[nx.y][nx.x]==0)res=dfs(nx.x,nx.y,fg);\n    vis[y][x]=res;\n     \n    return res;\n}\n \nint main(void){\n \n    point p;\n     \n    while(cin >> n,n){\n        fill(vis[0],vis[101],0);\n         \n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                cin >> p.x >> p.y;\n                grid[i][j]=p;\n            }\n        }\n         \n        int cnt=1;\n        for(int i=0;i<n;i++){\n            for(int j=0;j<n;j++){\n                if(!vis[i][j]){\n                    if(dfs(j,i,cnt)==cnt)cnt++;  \n                }\n            }\n        }\n \n        cout << cnt-1 << endl;\n    }\n \nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<string>\n#include<iostream>\n#include<cmath>\n#include<map>\n#include<set>\n#include<climits>\nusing namespace std;\ntypedef vector<string>vs;\ntypedef vector<int>vi;\ntypedef vector<vi>vvi;\ntypedef vector<double>vd;\ntypedef pair<int,int>pii;\ntypedef long long ll;\ntypedef pair<ll,ll>pll;\ntypedef vector<ll>vl;\n#define rrep(i,x,n) for(int i=(x);i<(n);++i)\n#define rep(i,x) rrep(i,0,(x))\n#define fi first\n#define se second\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\n#define pb push_back\n#define maxs(a,b) (a)=max(a,b)\n#define mins(a,b) (a)=min(a,b)\n\nint main(){\n    int N;\n    while(scanf(\"%d\",&N),N){\n        vi V(N*N);\n        rep(i,N*N){\n            int x,y;\n            scanf(\"%d%d\",&x,&y);\n            V[i]=y*N+x;\n        }\n        int cnt=0;\n        bool used[10000]={0};\n        rep(i,N*N){\n            if(used[i])continue;\n            int pos=i;\n            bool u[10000]={0};\n            while(!u[pos]){\n                u[pos]=true;\n                pos=V[pos];\n            }\n            if(pos!=i)continue;\n            cnt++;\n            rep(i,N*N)used[i]|=u[i];\n        }\n        printf(\"%d\\n\",cnt);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint x[100][100], y[100][100], z[100][100];\nint main() {\n\tint n;\n\twhile (true) {\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tfor (int j = 0; j < 100; j++) {\n\t\t\t\tx[i][j] = 0; y[i][j] = 0; z[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tcin >> n; if (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tcin >> x[i][j] >> y[i][j];\n\t\t\t}\n\t\t}\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (z[i][j] == 0) {\n\t\t\t\t\tcnt++; int C = cnt;\n\t\t\t\t\tint cx = i, cy = j;\n\t\t\t\t\tz[cy][cx] = C;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tint cx1 = x[cy][cx], cy1 = y[cy][cx];\n\t\t\t\t\t\tcx = cx1; cy = cy1;\n\t\t\t\t\t\tif (z[cy][cx] >= 1) {\n\t\t\t\t\t\t\tC = z[cy][cx];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tz[cy][cx] = C;\n\t\t\t\t\t}\n\t\t\t\t\tcx = i, cy = j;\n\t\t\t\t\tz[cy][cx] = C;\n\t\t\t\t\tif (C != cnt) { cnt--; }\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tint cx1 = x[cy][cx], cy1 = y[cy][cx];\n\t\t\t\t\t\tcx = cx1; cy = cy1;\n\t\t\t\t\t\tif (z[cy][cx] >= 1) {\n\t\t\t\t\t\t\tC = z[cy][cx];\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tx[cy][cx] = C;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define REPR(i,b,n) for(int i=n-1;i>=b;i--)\n#define CLR(mat) memset(mat, 0, sizeof(mat))\n#define NCLR(mat) memset(mat, -1, sizeof(mat))\n#define EACH(i, c) for(typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define BIT(n, b) ((n>>b) & 1)\n#define PI acos(-1.0)\n\nusing namespace std;\n\nstatic const double EPS = 1e-9;\ntypedef long long ll;\ntypedef pair<int, int> paii;\n\nint N;\npaii flo[128][128];\nint vis[128][128];\n\nint dfs(int x, int y, int id){\n\t\n\tif(vis[y][x] != 0){\n\t\treturn vis[y][x];\n\t}\n\telse{\n\t\tvis[y][x] = id;\n\t\treturn vis[y][x] = dfs(flo[y][x].first, flo[y][x].second, id);\n\t}\n}\n\nint solve(){\n\t\n\tint res = 0, id = 1;\n\tCLR(vis);\n\t\n\tfor(int y=0; y<N; ++y){\n\t\tfor(int x=0; x<N; ++x){\n\t\t\t\n\t\t\tif(vis[y][x]==0)\n\t\t\t\tres += (id == dfs(x, y, id));\n\t\t\t\n\t\t\tid++;\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main(){\n\t\n\twhile(cin >> N, N){\n\t\t\n\t\tfor(int y=0; y<N; ++y){\n\t\t\tfor(int x=0; x<N; ++x){\n\t\t\t\tcin >> flo[y][x].first >> flo[y][x].second;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << solve() << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define all(v) v.begin(), v.end()\n#define rall(v) v.rbegin(), v.rend()\n#define rep(i, n) for (int i = 0; i < n; ++i)\n#define pb emplace_back\n\nusing pii = pair<int, int>;\nusing vi = vector<int>;\nusing lint = long long;\n\nconst int inf = 1001001001;\nconst lint linf = 1001001001001001001ll;\nconst int mod = 1e9 + 7;\nconst int dx[]{0, 1, 0, -1, -1, -1, 1, 1}, dy[]{1, 0, -1, 0, -1, 1, -1, 1};\n\ntemplate<typename T> inline bool chmin(T &a, T b) { if (a > b) { a = b; } return a > b; }\ntemplate<typename T> inline bool chmax(T &a, T b) { if (a < b) { a = b; } return a < b; }\ntemplate<typename T> inline void print(const T &x, string s = \"\\n\") { cout << x << s; }\ntemplate<typename T> inline void print(const vector<T> &v, string s = \" \") \n{ rep(i, v.size()) cout << v[i] << (i + 1 == v.size() ? \"\\n\" : s); }\ninline bool inside(int y, int x, int H, int W) { return 0 <= y && y < H && 0 <= x && x < W; }\ninline lint in() { lint x; std::cin>>x; return x; }\n\nstruct UnionFind {\n\tvector<int> p, r;\n\n\tUnionFind() {}\n\tUnionFind(int size) { init(size); }\n\n\tvoid init(int size) {\n\t\tp.resize(size);\n\t\tr.resize(size);\n\t\tfor (int i = 0; i < size; ++i) {\n\t\t\tp[i] = i; r[i] = 1;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\tif (p[x] == x) return x;\n\t\telse return p[x] = find(p[x]);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = find(x); y = find(y);\n\n\t\tif (x == y) return;\n\n\t\tif (r[x] > r[y]) swap(x, y);\n\t\tr[x] += r[y];\n\t\tp[y] = x;\n\t}\n\n\tbool is_root(int x) {\n\t\treturn find(x) == x;\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tint element_count(int x) {\n\t\tx = find(x);\n\t\treturn r[x];\n\t}\n};\n\nint main() {\n\tint n;\n\n\twhile (cin >> n, n) {\n\t\tUnionFind uf(n * n);\n\t\trep(i, n) rep(j, n) {\n\t\t\tint x = in(), y = in();\n\t\t\t\n\t\t\tint u = y * n + x;\n\t\t\tint v = i * n + j;\n\n\t\t\tuf.unite(u, v);\n\t\t}\n\n\t\tint ans = 0;\n\t\tbool f[10000] = {false};\n\t\trep(i, n * n) {\n\t\t\tif (f[uf.find(i)]) continue;\n\t\t\tf[uf.find(i)] = true;\n\t\t\tans++;\n\t\t}\n\n\t\tprint(ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#define P pair<int,int>\n#define U 1000\nusing namespace std;\n\nint n;\nP p[200][200];\n\nbool solve(int x,int y, P org, int k){\n  if( k> n*n ) return false;\n  if( p[x][y].first==U )\n    return false;\n  if( p[x][y].first==org.first && p[x][y].second==org.second )\n    return true;\n  //  cout << \"  s\"<<x<<\",\"<<y<< endl;\n\n  int nx=p[x][y].first, ny=p[x][y].second;\n  return solve( nx,ny,org,k+1 );\n}\nvoid loop(int x,int y){\n  if( p[x][y].first==U ) return;\n  int nx=p[x][y].first, ny=p[x][y].second;\n  p[x][y].first = U;\n  p[x][y].second = U;\n  loop( nx,ny );\n}\n\nvoid pr(){\n  for( int i=0;i<n;i++ ){\n    for( int j=0;j<n;j++ ){\n      if( p[i][j].first==U )\n\tcout << \" *,*\";\n      else \n\tcout << \" \" << p[i][j].first << \",\" << p[i][j].second;\n    }\n    cout << endl;\n  }\n}\n\nint main(){\n\n  while( cin>>n,n ){\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ )\n\tcin >> p[j][i].first >> p[j][i].second;\n    }\n    //    cout << \"------------------------------\" << endl;\n    //    pr(); cout << endl;\n\n    int ans=0;\n    for( int i=0;i<n;i++ ){\n      for( int j=0;j<n;j++ ){\n\tif( p[i][j].first==U ) continue;\n\n\tif( solve( p[i][j].first,p[i][j].second,p[i][j],0 ) ){\n\t  loop(i,j); // erase loop\n\t  //\t  pr();cout << \" ans++ by \" << i << \" \" << j << endl;\n\t  ans++;\n\t}else{\n\t  p[i][j].first=U; p[i][j].second=U;\n\t}\n\n      }\n    }\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define ALL(v) (v).begin(), (v).end()\n\nclass DisjointSet{\nprivate:\n  vector< int > rank, p;\n  void link(int x,int y){\n    if(rank[x] > rank[y]){\n      p[y] = x;\n    }else{\n      p[x] = y;\n      if(rank[x] == rank[y]) rank[y]++;\n    }\n  }\npublic:\n  DisjointSet(int size){\n    rank.resize(size,0);\n    p.resize(size,0);\n    for(int i = 0; i < size; i++){\n      makeSet(i);\n    }\n  }\n  void makeSet(int x){\n    p[x] = x, rank[x] = 0;\n  }\n  void Union(int x,int y){\n    link(findSet(x),findSet(y));\n  }\n  int findSet(int x){\n    return( x != p[x] ? p[x] = findSet(p[x]) : p[x]);\n  }\n};\n\nint main()\n{\n  int N;\n  while(scanf(\"%d\", &N), N){\n    DisjointSet UnionFind(N * N);\n    for(int i = 0; i < N; i++){\n      for(int j = 0; j < N; j++){\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        UnionFind.Union( i * N + j, y * N + x);\n      }\n    }\n    vector< bool > size(N * N, false);\n    for(int i = 0; i < N * N; i++){\n      size[UnionFind.findSet(i)] = true;\n    }\n    cout << count(ALL(size), true) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n// @snippet<sh19910711/contest:headers.cpp>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <limits>\n#include <complex>\n#include <functional>\n#include <iterator>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n\n// @snippet<sh19910711/contest:solution/typedef.cpp>\nnamespace solution {\n    typedef std::istringstream ISS;\n    typedef std::ostringstream OSS;\n    typedef std::vector<std::string> VS;\n    typedef long long LL;\n    typedef int INT;\n    typedef std::vector<INT> VI;\n    typedef std::vector<VI> VVI;\n    typedef std::pair<INT,INT> II;\n    typedef std::vector<II> VII;\n}\n\n// @snippet<sh19910711/contest:solution/interface.cpp>\nnamespace solution {\n    class ISolution {\n    public:\n        virtual void init() {};\n        virtual bool input() { return false; };\n        virtual void output() {};\n        virtual int run() = 0;\n    };\n}\n\n// @snippet<sh19910711/contest:solution/solution.cpp>\nnamespace solution {\n    using namespace std;\n\n    const int SIZE = 100 + 11;\n    const int NONE = -1;\n\n    int n;\n    int X[SIZE][SIZE];\n    int Y[SIZE][SIZE];\n    bool V[SIZE][SIZE];\n    bool filled[SIZE][SIZE];\n\n    void check_init() {\n        for ( int i = 0; i < SIZE; ++ i )\n            for ( int j = 0; j < SIZE; ++ j )\n                V[i][j] = false;\n    }\n\n    bool check( int x, int y, int sx, int sy ) {\n        if ( V[x][y] )\n            return x == sx && y == sy;\n        V[x][y] = true;\n        int nx = X[x][y];\n        int ny = Y[x][y];\n        return check(nx, ny, sx, sy);\n    }\n\n    void fill( int x, int y ) {\n        if ( filled[x][y] )\n            return;\n        filled[x][y] = true;\n        int nx = X[x][y];\n        int ny = Y[x][y];\n        fill(nx, ny);\n    }\n\n    int solve() {\n        int res = 0;\n        for ( int y = 0; y < n; ++ y ) {\n            for ( int x = 0; x < n; ++ x ) {\n                check_init();\n                if ( ! filled[x][y] && check(x, y, x, y) ) {\n                    res ++;\n                    fill(x, y);\n                }\n            }\n        }\n        return res;\n    }\n    \n    class Solution: public ISolution {\n    public:\n\n        void init() {\n            for ( int i = 0; i < SIZE; ++ i )\n                for ( int j = 0; j < SIZE; ++ j )\n                    filled[i][j] = false;\n        }\n        \n        bool input() {\n            if ( ! ( cin >> n ) )\n                return false;\n            if ( n == 0 )\n                return false;\n            for ( int y = 0; y < n; ++ y ) {\n                for ( int x = 0; x < n; ++ x ) {\n                    cin >> X[x][y] >> Y[x][y];\n                }\n            }\n            return true;\n        }\n\n        void output( int result ) {\n            cout << result << endl;\n        }\n        \n        int run() {\n            while ( init(), input() ) {\n                output(solve());\n            }\n            return 0;\n        }\n        \n    };\n}\n\n// @snippet<sh19910711/contest:main.cpp>\nint main() {\n    return solution::Solution().run();\n}"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative\nimport Control.Monad\nimport Data.List\nimport Data.Vector.Unboxed (Vector, (!), (//))\nimport qualified Data.Vector.Unboxed as V\n\nmain :: IO ()\nmain = do\n  n <- readLn\n  unless (n == 0) $ do\n    solve n <$> replicateM n f >>= print\n    main\n  where\n    f = map read <$> words <$> getLine\n\nsolve :: Int -> [[Int]] -> Int\nsolve n xs = let tm = V.fromList . concat $ map f xs\n                 cm = V.replicate (n * n) (-1) :: Vector Int\n             in fst $ foldl' (g tm []) (0, cm) [0 .. n*n-1]\n  where\n    f (x:y:rs) = n * y + x : f rs\n    f [] = []\n    g tm ac (c, m) i\n      | m ! i == (-1) = g tm (i:ac) (c, m // [(i, c)]) (tm ! i)\n      | m ! i == c = (c + 1, m)\n      | otherwise = (c, m // (map (\\j -> (j, m ! i)) ac))\n\n"
  },
  {
    "language": "C",
    "code": "// Aizu 2217: Let's JUMPSTYLE\n// 2017.9.23 bal4u@uu\n\n#include <stdio.h>\n\nint jump[100][100][2];  // [0]:?????£????????????r, [1]:?????£????????????c\nint mark[100][100];\n\nint main()\n{\n\tint n, r, c, r0, c0, r1, c1;   // x, y??§????????????r,c???????????????y,x????????±???\n\tint new, ans;\t\t// new: ??°???????????????, ans: ???????????????\n\n\twhile (scanf(\"%d\", &n) && n > 0) {\n\t\tfor (r = 0; r < n; r++) for (c = 0; c < n; c++) {\n\t\t\tscanf(\"%d%d\", &c1, &r1);\n\t\t\tjump[r][c][0] = r1, jump[r][c][1] = c1;\n\t\t\tmark[r][c] = 0;\t\t// ?????????????????¨???????????????\n\t\t}\n\t\tans = new = 0;\n\t\tfor (r = 0; r < n; r++) for (c = 0; c < n; c++) {\n\t\t\tif (!mark[r][c]) {\t\t// ??????????????????????????????\n\t\t\t\tnew++;\t\t\t\t// ??°?????????????????¨??????????????????\n\t\t\t\tmark[r][c] = new;\t// ?????????\n\t\t\t\tfor (r0 = r, c0 = c; ; r0 = r1, c0 = c1) {\n\t\t\t\t\tr1 = jump[r0][c0][0], c1 = jump[r0][c0][1];\n\t\t\t\t\tif (mark[r1][c1] > 0) {\t\t\t// ???????????????????????\\??£???\n\t\t\t\t\t\tif (mark[r1][c1] == new)\t// ??°??????????????????????????????\n\t\t\t\t\t\t\tans++;\n\t\t\t\t\t\tbreak;\t\t\t\t\t\t// ?????????????????????????????????????????????\n\t\t\t\t\t}\n\t\t\t\t\tmark[r1][c1] = new;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\t// ????????????????????????????????????????????§????¨???????o(n^2)\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "G[10000],v[10000];i,a,b;main(N){for(;scanf(\"%d\",&N)*N;printf(\"%d\\n\",b)){for(i=0;b=i<N*N;G[i++]=a+b*N)v[i]=scanf(\"%d%d\",&a,&b)-3;for(;i--;b+=v[a]==i)for(a=i;!~v[a];a=G[a])v[a]=i;}}"
  },
  {
    "language": "C",
    "code": "G[10000],v[10000];\ni,a,b,C;\nmain(N){\n\tfor(;scanf(\"%d\",&N)*N;){\n\t\tfor(i=0;i<N*N;i++){\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\tG[i]=a+b*N;\n\t\t\tv[i]=-1;\n\t\t}\n\t\tC=0;\n\t\tfor(i=0;i<N*N;i++){\n\t\t\tfor(a=i;;){\n\t\t\t\tif(~v[a]){\n\t\t\t\t\tif(v[a]==i){\n\t\t\t\t\t\tC++;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tv[a]=i;\n\t\t\t\ta=G[a];\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",C);\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint n,vis[101][101];\n\nstruct point{int x,y;};\nstruct point grid[101][101];\n\nint dfs(int x,int y,int fg){\n  \n  vis[y][x]=fg;\n  struct point nx=grid[y][x];\n  int res=vis[nx.y][nx.x];\n  \n  if(vis[nx.y][nx.x]==0)res=dfs(nx.x,nx.y,fg);\n  \n  return vis[y][x]=res;\n}\n\nint main(void){\n  \n  struct point p;\n  int i,j,cnt;  \n\n  while(scanf(\"%d\",&n),n){\n    memset(vis,0,sizeof(vis));\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n\tscanf(\"%d %d\",&p.x,&p.y);\n\tgrid[i][j]=p;\n      }\n    }\n    \n    for(i=0,cnt=1;i<n;i++)\n      for(j=0;j<n;j++)\n\tif(!vis[i][j] && dfs(j,i,cnt)==cnt)cnt++;  \n\n    printf(\"%d\\n\",cnt-1);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,i,j,gx,gy,ny,nx,c,b;\n  int x[101][101],y[101][101];\n  while(scanf(\"%d\",&n),n){\n    int f[101][101]={0};\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n\tscanf(\"%d %d\",&x[i][j],&y[i][j]);\n      }\n    }\n    for(i=c=b=0;i<n;i++){\n      for(j=0;j<n;j++){\n\tif(f[i][j])continue;\n\tgy=i;\n\tgx=j;\n\tc++;\n\twhile(f[gy][gx]==0){\n\t  nx=x[gy][gx];\n\t  ny=y[gy][gx];\n\t  f[gy][gx]=c;\n\t  gx=nx;\n\t  gy=ny;\n\t}\n\tif(f[gy][gx]!=c)b++;\n      }\n    }\n    printf(\"%d\\n\",c-b);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "G[9999],v[9999],i,a,b;main(N){for(;scanf(\"%d\",&N)*N;printf(\"%d\\n\",b)){for(i=0;b=i<N*N;G[i++]=a+b*N)v[i]=-scanf(\"%d%d\",&a,&b);for(;i--;b+=v[a]==i)for(a=i;v[a]<0;a=G[a])v[a]=i;}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint N,M[101][101][2],i,j,F[101][101],c,R;\n\nint dfs(int x,int y,int f)\n{\n\tif(F[y][x]==f)return 1;\n\tif(F[y][x]==0)\n\t{\n\t\tF[y][x]=f;\n\t\treturn dfs(M[y][x][0],M[y][x][1],f);\n\t}\n\treturn 0;\n}\n\nint main()\n{\n\tfor(;scanf(\"%d\",&N),N;)\n\t{\n\t\tmemset(F,0,sizeof(F));\n\t\tfor(i=0;i<N;i++)\n\t\t\tfor(j=0;j<N;j++)\n\t\t\t\tscanf(\"%d%d\",&M[i][j][0],&M[i][j][1]);\n\t\tfor(i=R=0,c=1;i<N;i++)\n\t\t\tfor(j=0;j<N;j++)\n\t\t\t\tif(F[i][j]==0)\n\t\t\t\t{\n\t\t\t\t\tR+=dfs(j,i,c++);\n\t\t\t\t}\n\t\tprintf(\"%d\\n\",R);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2217\n  Title:Let's JUMPSTYLE\n  @kankichi573\n*/\n#include <stdio.h>\n\nint N;\nint jump_x[100][100];\nint jump_y[100][100];\nint loop[100][100];\nint find(int *x,int *y)\n{\n    int i,j;\n    for(i=0;i<N;i++)\n      for(j=0;j<N;j++)\n\tif(loop[i][j]==0)\n\t  {\n\t    *x=i;*y=j;\n\t    return(-1);\n\t  }\n    return(0);\n}\nint solve()\n{\n  int n_loop,count,x,y,xn,yn;\n\n  n_loop=count=1;\n  while(find(&x,&y))\n    {\n      //printf(\"%d %d\\n\",x,y);\n      while(loop[x][y]==0)\n\t{\n\t  loop[x][y]=n_loop;\n\t  xn=jump_x[x][y];\n\t  yn=jump_y[x][y];\n\t  x=xn;y=yn;\n\t  //printf(\">%d %d\\n\",x,y);\n\t}\n      if(loop[x][y]==n_loop)\n\t{\n\t  //printf(\"*\\n\");\n\t  count++;\n\t}\n      n_loop++;      \n    }\n  return(count-1);\n}\nvoid clear()\n{\n  int i,j;\n  for(i=0;i<N;i++)\n    for(j=0;j<N;j++)\n      loop[i][j]=0;\n}\nmain()\n{\n  int i,j,ret;\n\n  while(scanf(\"%d\",&N) && N)\n    {\n      for(i=0;i<N;i++)\n\tfor(j=0;j<N;j++)\n\t  scanf(\"%d %d\",&jump_x[j][i],&jump_y[j][i]);\n      clear();\n      ret=solve();\n      printf(\"%d\\n\",ret);\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n\tint x,y;\n} xy_t;\n\nint width;\nchar visited[100][100];\nxy_t floor_map[100][100];\n\nint main(void) {\n\tint i,j,k,l;\n\tint x,y,nx,ny;\n\tint count;\n\twhile(1) {\n\t\tscanf(\"%d\",&width);\n\t\tif(width==0)break;\n\t\tfor(i=0;i<width;i++) {\n\t\t\tfor(j=0;j<width;j++) {\n\t\t\t\tscanf(\"%d%d\",&floor_map[i][j].x,&floor_map[i][j].y);\n\t\t\t\tvisited[i][j]=0;\n\t\t\t}\n\t\t}\n\t\tcount=0;\n\t\tfor(i=0;i<width;i++) {\n\t\t\tfor(j=0;j<width;j++) {\n\t\t\t\tif(!visited[i][j]) {\n\t\t\t\t\tx=j;y=i;\n\t\t\t\t\twhile(!visited[y][x]) {\n\t\t\t\t\t\tvisited[y][x]=2;\n\t\t\t\t\t\tnx=floor_map[y][x].x;\n\t\t\t\t\t\tny=floor_map[y][x].y;\n\t\t\t\t\t\tx=nx;y=ny;\n\t\t\t\t\t}\n\t\t\t\t\tif(visited[y][x]==2)count++;\n\t\t\t\t\tfor(k=0;k<width;k++) {\n\t\t\t\t\t\tfor(l=0;l<width;l++) {\n\t\t\t\t\t\t\tif(visited[k][l]==2)visited[k][l]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint n,vis[101][101];\n\nstruct point{int x,y;};\nstruct point grid[101][101];\n\nint dfs(int x,int y,int fg){\n  \n  vis[y][x]=fg;\n  struct point nx=grid[y][x];\n  int res=vis[nx.y][nx.x];\n  \n  if(vis[nx.y][nx.x]==0)res=dfs(nx.x,nx.y,fg);\n  \n  return vis[y][x]=res;\n}\n\nint main(void){\n  \n  struct point p;\n  int i,j,cnt;  \n\n  while(scanf(\"%d\",&n),n){\n    memset(vis,0,sizeof(vis));\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n\tscanf(\"%d %d\",&p.x,&p.y);\n\tgrid[i][j]=p;\n      }\n    }\n    \n    for(i=0,cnt=1;i<n;i++)\n      for(j=0;j<n;j++)\n\tif(!vis[i][j] && dfs(j,i,cnt)==cnt)cnt++;  \n\n    printf(\"%d\\n\",cnt-1);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "1\n0 0\n2\n1 1 0 1\n1 0 0 0\n2\n1 1 0 1\n1 1 1 0\n3\n0 1 2 2 2 1\n0 2 1 2 2 1\n0 0 0 1 1 1\n4\n3 2 2 0 3 2 2 1\n1 1 0 3 1 1 3 1\n0 3 2 3 3 0 2 3\n1 1 1 1 3 2 1 3\n0"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,a,b,i,j,x,y,c;\n  while(scanf(\"%d\",&n),n){\n    int p[10001]={0};\n    int d[10001]={0};\n    for(i=c=0;i<n;i++){\n      for(j=0;j<n;j++){\n\tscanf(\"%d %d\",&x,&y);\n\tfor(a=i*100+j+1;p[a];a=p[a]);\n\tfor(b=y*100+x+1;p[b];b=p[b]);\n\tif(a-b){\n\t  if(d[b]< d[a])p[b]=a;\n\t  if(d[b]>=d[a])p[a]=b;\n\t  if(d[a]==d[b])d[b]++;\n\t  c++;\n\t}\n      }\n    }\n    printf(\"%d\\n\",n*n-c);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "m[10000],c[10000];\nint D(n){if(c[n]>=0)return c[n];c[n]=1;int r=D(m[n]);c[n]=0;return r;}\nmain(n,x,y,r,s){for(;scanf(\"%d\",&n),n;printf(\"%d\\n\",r)){\n\tmemset(c,255,sizeof(m));\n\tfor(y=0;y<n;y++)for(x=0;x<n;x++)scanf(\"%d%d\",&r,&s),m[y*n+x]=s*n+r;\n\tfor(r=x=0;x<n*n;x++)r+=D(x);\n}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n\nint n,vis[101][101];\n\nstruct point{int x,y;};\nstruct point grid[101][101];\n\nint dfs(int x,int y,int fg){\n  \n  vis[y][x]=fg;\n  struct point nx=grid[y][x];\n  int res=vis[nx.y][nx.x];\n  \n  if(vis[nx.y][nx.x]==0)res=dfs(nx.x,nx.y,fg);\n  \n  return vis[y][x]=res;\n}\n\nint main(void){\n  \n  struct point p;\n  int i,j,cnt;  \n\n  while(scanf(\"%d\",&n),n){\n    memset(vis,0,sizeof(vis));\n    \n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n\tscanf(\"%d %d\",&p.x,&p.y);\n\tgrid[i][j]=p;\n      }\n    }\n    \n    for(i=0,cnt=1;i<n;i++){\n      for(j=0;j<n;j++){\n\tif(!vis[i][j]){\n\t  if(dfs(j,i,cnt)==cnt)cnt++;  \n\t}\n      }\n    }\n    \n    printf(\"%d\\n\",cnt-1);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\nint main(void) {\n    int num,floor[100][100][3],i,j,k,jump[2],count;\n    while (1) {\n        scanf(\"%d\",&num);\n        if (num==0) break;\n        for (i=0; i<num; i++) {\n            for (j=0; j<num; j++) {\n                scanf(\"%d %d\",&floor[j][i][0],&floor[j][i][1]);\n                floor[j][i][2]=0;\n            }\n        }\n        int check[num*num][2],sp;\n        count=0;\n        for (i=0; i<num; i++) {\n            for (j=0; j<num; j++) {\n                jump[0]=j,jump[1]=i,sp=0;\n                if (floor[jump[0]][jump[1]][2]==0) {\n                    while (floor[jump[0]][jump[1]][2]==0) {\n                        floor[jump[0]][jump[1]][2]=1;\n                        check[sp][0]=jump[0];\n                        check[sp][1]=jump[1];\n                        sp++;\n                        jump[0] = floor[check[sp-1][0]][check[sp-1][1]][0];\n                        jump[1] = floor[check[sp-1][0]][check[sp-1][1]][1];\n                    }\n                    for (k=0; k<sp; k++) {\n                        if (check[k][0]==jump[0]&&check[k][1]==jump[1]) {\n                            count++;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n        printf(\"%d\\n\",count);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nstruct data{\n  int x, y;\n}map[100][100];\n\nint keisan(int, int,int);\nint hantei[100][100];\nint n, ans;\nmain(){\n  int i, j, ans;\n\n  while(1){\n    scanf(\"%d\", &n);\n    if(n==0) break;\n\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n\tscanf(\"%d%d\", &map[i][j].x, &map[i][j].y);\n      }\n    }\n    \n    ans=0;\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n\thantei[i][j]=0;\n      }\n    }\n\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n\tif(hantei[i][j]==0){\n\t  ans=keisan(i,j, ans);\n\t}\n      }\n    }\n\n     printf(\"%d\\n\", ans);\n  }\n  return 0;\n}\n\nint keisan(int y, int x, int ans){\n  int i, j, tx, ty, f=0, a, b;\n  int hantei2[100][100];\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      hantei2[i][j]=0;\n    }\n  }\n  while(1){\n    if(y==0 && x==3){\n    }\n    if(hantei[y][x]==1 && hantei2[y][x]==1){\n      f=1;\n      hantei[y][x]=2;\n    }\n    else if(hantei[y][x]==1 && hantei2[y][x]==0){\n      f=0;\n      break;\n    }\n    else if(hantei[y][x]==2){ \n      break;\n    }\n    else{\n      if(y==0 && x==3){\n    }\n      hantei[y][x]=1;\n      hantei2[y][x]=1;\n    }\n    tx = map[y][x].x;\n    ty = map[y][x].y;      \n    x=tx;\n    y=ty;\n  }\n  if(f){\n    ans++;\n  }\n  return ans;\n}"
  },
  {
    "language": "C",
    "code": "X[100][100],Y[100][100],v[100][100];\nmain(N){\n\tint x,y,a,b,t,C;\n\tfor(;scanf(\"%d\",&N)*N;){\n\t\tmemset(v,-1,sizeof(v));\n\t\tfor(y=0;y<N;y++)\n\t\t\tfor(x=0;x<N;x++)\n\t\t\t\tscanf(\"%d%d\",&X[x][y],&Y[x][y]);\n\t\tC=0;\n\t\tfor(y=0;y<N;y++)\n\t\t\tfor(x=0;x<N;x++){\n\t\t\t\tfor(a=x,b=y;;){\n\t\t\t\t\tif(~v[a][b]){\n\t\t\t\t\t\tif(v[a][b]==x+y*N){\n\t\t\t\t\t\t\tC++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tv[a][b]=x+y*N;\n\t\t\t\t\tt=X[a][b],b=Y[a][b],a=t;\n\t\t\t\t}\n\t\t\t}\n\t\tprintf(\"%d \\n\",C);\n\t}\n}"
  },
  {
    "language": "Kotlin",
    "code": "import java.util.*\n\nfun main(args:Array<String>):Unit {\n    while(true){\n        val n = readLine()!!.trim().toInt()\n        if (n == 0) return\n        val floor = Floor(Array(n){\n            val a = readLine()!!.trim().split(' ').map(String::toInt).toIntArray()\n            (0 until n).map{\n                Point(a[it * 2], a[it * 2 + 1])\n            }.toTypedArray()\n        })\n        var loopCount = 0\n        val isLooped = Array(n){Array(n){false}}\n        for (x in 0 until n) for (y in 0 until n){\n            if (!isLooped[y][x]){\n                var single = Point(x, y)\n                var double = floor[Point(x, y)]\n                while (single != double){\n                    single = floor[single]\n                    double = floor[floor[double]]\n                }\n                if (!isLooped[single.y][single.x]){\n                    ++loopCount\n                    do{\n                        isLooped[single.y][single.x] = true\n                        single = floor[single]\n                    }while(single != double)\n                }\n            }\n        }\n        println(loopCount)\n    }\n}\ndata class Point(val x:Int, val y:Int)\nclass Floor(private val mFloorState:Array<Array<Point>>){\n    operator fun get(point:Point):Point = mFloorState[point.y][point.x]\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Problem B: Let's JUMPSTYLE\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint N = parseInt(line);\n\t\t\tif (N == 0) break;\n\n\t\t\tint[][][] G = new int[N][N][2];\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tG[j][i][0] = parseInt(st.nextToken());\n\t\t\t\t\tG[j][i][1] = parseInt(st.nextToken());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[][] check = new int[N][N];\n\t\t\tint timestamp = 0;\n\t\t\tint count = 0;\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (check[i][j] == 0) {\n\t\t\t\t\t\tcheck[i][j] = ++timestamp;\n\t\t\t\t\t\tint _j = G[i][j][0];\n\t\t\t\t\t\tint _i = G[i][j][1];\n\t\t\t\t\t\twhile (check[_j][_i] == 0) {\n\t\t\t\t\t\t\tcheck[_j][_i] = timestamp;\n\t\t\t\t\t\t\t_j = G[_j][_i][0];\n\t\t\t\t\t\t\t_i = G[_j][_i][1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (check[_j][_i] == timestamp) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int N = sc.nextInt();\n\t\t\t\n\t\t\tif(N == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] is_visited = new boolean[N][N];\n\t\t\tboolean[][] tmp = new boolean[N][N];\n\t\t\t\n\t\t\tint[][] x_pos = new int[N][N];\n\t\t\tint[][] y_pos = new int[N][N];\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\t\tx_pos[i][j] = sc.nextInt();\n\t\t\t\t\ty_pos[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\t\tif(is_visited[i][j]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tint x_p = j;\n\t\t\t\t\tint y_p = i;\n\t\t\t\t\t\n\t\t\t\t\twhile(!is_visited[y_p][x_p] && !tmp[y_p][x_p]){\n\t\t\t\t\t\ttmp[y_p][x_p] = true;\n\t\t\t\t\t\tint x_o = x_p, y_o = y_p;\n\t\t\t\t\t\t\n\t\t\t\t\t\tx_p = x_pos[y_o][x_o];\n\t\t\t\t\t\ty_p = y_pos[y_o][x_o];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (!is_visited[y_p][x_p]) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor (int k = 0; k < N; k++) {\n\t\t\t\t\t\tfor (int l = 0; l < N; l++) {\n\t\t\t\t\t\t\tif (tmp[k][l]) {\n\t\t\t\t\t\t\t\tis_visited[k][l] = true;\n\t\t\t\t\t\t\t\ttmp[k][l] = false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(count);\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tboolean[][] visited = new boolean[n][n];\n\t\t\tPoint[][] dist = new Point[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tdist[i][j] = new Point(sc.nextInt(), sc.nextInt());\n\t\t\t\t}\n\t\t\t}\n\t\t\tint loopCount = 0;\n\t\t\tSet<Point> currentLoopLocs = new HashSet<Point>();\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (visited[i][j]) {\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tcurrentLoopLocs.clear();\n\t\t\t\t\tcurrentLoopLocs.add(new Point(j, i));\n\t\t\t\t\tPoint nextPoint = dist[i][j];\n\t\t\t\t\t\n\t\t\t\t\twhile (!visited[nextPoint.y][nextPoint.x]) {\n\t\t\t\t\t\tvisited[nextPoint.y][nextPoint.x] = true;\n\t\t\t\t\t\tcurrentLoopLocs.add(nextPoint);\n\t\t\t\t\t\tnextPoint = dist[nextPoint.y][nextPoint.x];\n\t\t\t\t\t\tif(currentLoopLocs.contains(nextPoint)) {\n\t\t\t\t\t\t\tloopCount++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\tvisited[i][j] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(loopCount);\n\n\t\t}\n\n\t}\n\n\tstatic class Point {\n\t\tfinal int x;\n\t\tfinal int y;\n\n\t\tpublic Point(int x, int y) {\n\t\t\tsuper();\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\n\n\t\t@Override\n\t\tpublic int hashCode() {\n\t\t\tfinal int prime = 31;\n\t\t\tint result = 1;\n\t\t\tresult = prime * result + x;\n\t\t\tresult = prime * result + y;\n\t\t\treturn result;\n\t\t}\n\n\n\t\t@Override\n\t\tpublic boolean equals(Object obj) {\n\t\t\tif (this == obj)\n\t\t\t\treturn true;\n\t\t\tif (obj == null)\n\t\t\t\treturn false;\n\t\t\tif (getClass() != obj.getClass())\n\t\t\t\treturn false;\n\t\t\tPoint other = (Point) obj;\n\t\t\tif (x != other.x)\n\t\t\t\treturn false;\n\t\t\tif (y != other.y)\n\t\t\t\treturn false;\n\t\t\treturn true;\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.util.Arrays.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N, M;\n\tstatic int[][][] flr = new int[100][100][2];\n\tstatic boolean read() {\n\t\tN = sc.nextInt();\n\t\tif (N == 0) return false;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\tflr[i][j][0] = sc.nextInt();\n\t\t\t\tflr[i][j][1] = sc.nextInt();\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\n\tstatic int[][] step = new int[100][100];\n\tstatic int sol;\n\tstatic void solve() {\n\t\tsol = 0;\n\t\tfor (int i = 0; i < N; i++) fill(step[i], -1);\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\trec(j, i, i * N + j);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(sol);\n\t}\n\t\n\tstatic void rec(int x, int y, int s) {\n\t\tif (step[y][x] == s) {\n\t\t\tsol++;\n\t\t} else if (step[y][x] == -1) {\n\t\t\tstep[y][x] = s;\n\t\t\trec(flr[y][x][0], flr[y][x][1], s);\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\twhile (read())\n\t\t\tsolve();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tint N=in.nextInt();\n\t\t\tif(N==0)\n\t\t\t\treturn;\n\t\t\tjump a[][]=new jump[N][N];\n\t\t\tArrayList<jump>AL=new ArrayList<jump>();\n\t\t\tint field[][]=new int[N][N];\n\t\t\tboolean judge[][]=new boolean[N][N];\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\t{\n\t\t\t\t\tjump b=new jump();\n\t\t\t\t\tb.x=in.nextInt();\n\t\t\t\t\tb.y=in.nextInt();\n\t\t\t\t\ta[j][i]=b;\n\t\t\t\t}\n\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\t{\n\t\t\t\t\tint xx=j;\n\t\t\t\t\tint yy=i;\n\t\t\t\t\tif(field[j][i]==0)\n\t\t\t\t\t\tfor(;;)\t\t\t\t\t\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(field[xx][yy]==2)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(judge[xx][yy]==false)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\t\tjudge[xx][yy]=true;\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfield[xx][yy]=2;\n\t\t\t\t\t\t\tjump b=new jump();\n\t\t\t\t\t\t\tb.x=xx;\n\t\t\t\t\t\t\tb.y=yy;\n\t\t\t\t\t\t\tAL.add(b);\n\t\t\t\t\t\t\tint tx=a[xx][yy].x;\n\t\t\t\t\t\t\tint ty=a[xx][yy].y;\n\t\t\t\t\t\t\txx=tx;\n\t\t\t\t\t\t\tyy=ty;\n\t\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<AL.size();k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint rex=AL.get(k).x;\n\t\t\t\t\t\tint rey=AL.get(k).y;\n\t\t\t\t\t\tjudge[rex][rey]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n}\nclass jump\n{\n\tint x;\n\tint y;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/*\n * 何回目の探索で来たのかを入れておく\n * 同じ回数目の探索ならループで、違うならもう既にそのループはカウント済み\n */\nclass E{\n\tint loop;\n\tint x;\n\tint y;\n\t\n\tE(int a,int b){\n\t\tloop=0;\n\t\tx=a;\n\t\ty=b;\n\t}\n\t\n}\npublic class Main {\n\tE map[][];\n\tint count,sx,sy;\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tmap=new E[n][n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tint a=sc.nextInt();\n\t\t\t\t\tint b=sc.nextInt();\n\t\t\t\t\tmap[j][i]= new E(a,b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c=1;\n\t\t\tcount=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(map[j][i].loop==0){\n\t\t\t\t\t\tsx=j;sy=i;\n//\t\t\t\t\t\tSystem.out.println(\"!\");\n\t\t\t\t\t\tsolve(j, i, c);\n\t\t\t\t\t\tc++;\n\t\t\t\t\t\t//count++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n\tvoid solve(int mx,int my,int c){\n//\t\tSystem.out.println(mx+\" \"+my+\"  \"+map[mx][my].x+\" \"+map[mx][my].y);\n\t\t\n\t\tif(0<map[mx][my].loop){\n\t\t\tif(c==map[mx][my].loop){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\t\treturn;\n\t\t}\n\t\t\n\t\tint a=map[mx][my].x;\n\t\tint b=map[mx][my].y;\n\t\t\n\t\tmap[mx][my].loop=c;\n\t\t\n\t\tsolve(a, b, c);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tnx = new int[n][n];\n\t\t\tny = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tnx[i][j] = scanner.nextInt();\n\t\t\t\t\tny[i][j] = scanner.nextInt();\n\t\t\t\t}\n\t\t\tmap = new int[n][n];\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (map[i][j] == 2)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tans += dfs(i, j);\n\t\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate int dfs(int y, int x) {\n\t\tif (map[y][x] == 1)\n\t\t\treturn 1;\n\t\tif (map[y][x] == 2)\n\t\t\treturn 0;\n\t\tint ret = 0;\n\t\tint hx = nx[y][x];\n\t\tint hy = ny[y][x];\n\t\tmap[y][x] = 1;\n\t\tret = dfs(hy, hx);\n\t\tmap[y][x] = 2;\n\t\treturn ret;\n\t}\n\n\tint n, nx[][], ny[][];\n\tint[][] map;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n        public static int check[][];\n        public static int map[][][];\n\n        public static void main(String args[]) {\n                Scanner sc =new Scanner(System.in);\n                while( true ){\n                        int n = sc.nextInt();\n                        if (n == 0) {\n                                break;\n                        }\n                        map = new int[n][n][2];\n                        check = new int[n][n];\n                        for (int j = 0; j < n; j++) {\n                                for (int i = 0; i < n; i++) {\n                                        for (int k = 0; k < 2; k++) {\n                                                map[i][j][k] = sc.nextInt();\n                                        }\n                                }\n                        }\n                        int num = 1;\n                        for (int i = 0; i < n; i++) {\n                                for (int j = 0; j < n; j++) {\n                                        if (check[i][j] == 0) {\n                                                int pair[] = new int[2];\n                                                pair[0] = i;\n                                                pair[1] = j;\n                                                if(num == func(pair, num)){\n                                                        num++;\n                                                }\n                                        }\n                                }\n                        }\n                        System.out.println(num - 1);\n                }\n        }\n\n        public static int func(int now[], int num){\n                if (check[now[0]][now[1]] == 0) {\n                        check[now[0]][now[1]] = num;\n                        return check[now[0]][now[1]] = func(map[now[0]][now[1]], num);\n                } else {\n                        return check[now[0]][now[1]];\n                }\n        }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\nclass P{\n\tint x;\n\tint y;\n\n\tP(int _x, int _y){\n\t\tthis.x = _x;\n\t\tthis.y = _y;\n\t}\n}\n\npublic class Main {\n\n\tstatic int[][] checked;\n\tstatic int n;\n\n\tpublic static void main(String[] args) {\n\t\tScanner stdIn = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tn = stdIn.nextInt();\n\t\t\tif(n==0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tP[][] pos = new P[n][n];\n\t\t\tchecked = new int[n][n];\n\t\t\tint loopCnt = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tint x = stdIn.nextInt();\n\t\t\t\t\tint y = stdIn.nextInt();\n\t\t\t\t\tpos[i][j] = new P(x,y);\n\t\t\t\t}\n\t\t\t}\n\n//\t\t\tfor(int i=0;i<n;i++){\n//\t\t\t\tfor(int j=0;j<n;j++){\n//\t\t\t\t\tSystem.out.print(pos[i][j].x+\" \"+pos[i][j].y);\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\n\t\t\t// Process\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tTwotoOne();\n//\t\t\t\t\tSystem.err.println(\"テゥツ??\"+i+\" \"+j);\n\t\t\t\t\tif(checked[i][j]==0){\n\t\t\t\t\t\t// テ・ツコツァテヲツィツ?i,j)テ」ツ?凝」ツつ嘉」ツδォテ」ツδシテ」ツδ療」ツ?ォテ」ツ?ェテ」ツつ凝ヲツ篠「テァツエツ「テ」ツつケテ」ツつソテ」ツδシテ」ツδ?\n//\t\t\t\t\t\tSystem.err.println(\"テ」ツδォテ」ツδシテ」ツδ療ヲツ篠「テァツエツ「テ」ツつケテ」ツつソテ」ツδシテ」ツδ?\"+i+\" \"+j);\n\t\t\t\t\t\tint x = j;\n\t\t\t\t\t\tint y = i;\n\t\t\t\t\t\tboolean inc = true; // テ」ツつ、テ」ツδウテ」ツつッテ」ツδェテ」ツδ。テ」ツδウテ」ツδ暗」ツ?療」ツ?ヲテ」ツつ暗」ツ??」ツ??\n\t\t\t\t\t\twhile(true){\n\t\t\t\t\t\t\tif(checked[y][x]==0){\n\t\t\t\t\t\t\t\t// テ」ツ?セテ」ツ??・ツ按ーテゥツ?氾」ツ?療」ツ?ヲテ」ツ?ェテ」ツ??」ツ?ョテ」ツ?ァテァツカツ堙」ツ?妥」ツつ?\n\t\t\t\t\t\t\t\t// ティツカツウティツキツ。テ」ツ?、テ」ツ?妥」ツつ?\n\t\t\t\t\t\t\t\tchecked[y][x] = 2;\n\t\t\t\t\t\t\t\t// テヲツャツ。テ」ツ?ョテ・ツコツァテヲツィツ凖」ツつ津ヲツ崢エテヲツ鳴ーテ」ツ?凖」ツつ?\n//\t\t\t\t\t\t\t\tSystem.err.print(x+\" \"+y+\"=>\");\n\t\t\t\t\t\t\t\tint zx = x;\n\t\t\t\t\t\t\t\tint zy = y;\n\t\t\t\t\t\t\t\tx = pos[zy][zx].x;\n\t\t\t\t\t\t\t\ty = pos[zy][zx].y;\n//\t\t\t\t\t\t\t\tSystem.err.println(\"\"+x+\" \"+y);\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(checked[y][x]==1){\n\t\t\t\t\t\t\t\t// テゥツ?偲・ツ篠サテ」ツ?ョテ」ツδォテ」ツδシテ」ツδ療」ツ?ォテァツェツ?・ツ?・テ」ツ?療」ツ??\n//\t\t\t\t\t\t\t\tSystem.err.println(\"テゥツ?偲・ツ篠サテ」ツ?ョテ」ツδォテ」ツδシテ」ツδ療ァツェツ?・ツ?・テ」ツ?ァテ」ツ?療」ツ??/ テ」ツ?、テ」ツ?・テ」ツ?妥」ツ?セテ」ツ??);\n\t\t\t\t\t\t\t\tchecked[y][x] = 2;\n\t\t\t\t\t\t\t\tinc = false;\t// テゥツ?偲・ツ篠サテ」ツδォテ」ツδシテ」ツδ療」ツδ陛」ツδゥテ」ツつー\n//\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(checked[y][x]==2){\n\t\t\t\t\t\t\t\t// テヲツ篠「テァツエツ「テ・ツ慊ーテァツつケテ」ツ?セテ」ツ?ァテヲツ按サテ」ツつ?\n//\t\t\t\t\t\t\t\tSystem.err.println(\"テァツオツづ、ツコツ?);\n\t\t\t\t\t\t\t\tif(inc) {\n\t\t\t\t\t\t\t\t\t// テヲツ篠津、ツサツ姪」ツδォテ」ツδシテ」ツδ療」ツ?ョテァツ卍コティツヲツ?\n//\t\t\t\t\t\t\t\t\tSystem.err.println(\"テヲツ篠津、ツサツ姪」ツδォテ」ツδシテ」ツδ療」ツ?ョテァツ卍コティツヲツ?);\n\t\t\t\t\t\t\t\t\tloopCnt++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;  // while(true)テ」ツ?ョbreak\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(loopCnt);\n\t\t}\n\t}\n\n\tprivate static void TwotoOne() {\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(checked[i][j]==2){\n\t\t\t\t\tchecked[i][j] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tint[][] x = new int[n][n];\n\t\t\tint[][] y = new int[n][n];\n\t\t\tint[][] loop = new int[n][n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tx[i][j] = sc.nextInt();\n\t\t\t\t\ty[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint cnt = 1;\n\t\t\tint p, q, r, u, v;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(loop[i][j]==0){\n\t\t\t\t\t\tp = i;\n\t\t\t\t\t\tq = j;\n\t\t\t\t\t\twhile(true){\n\n\t\t\t\t\t\t\tif(loop[p][q]==cnt){\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}else if(loop[p][q]==0){\n\t\t\t\t\t\t\t\tloop[p][q] = cnt;\n\t\t\t\t\t\t\t\tu = p;\n\t\t\t\t\t\t\t\tv = q;\n\t\t\t\t\t\t\t\tp = y[u][v];\n\t\t\t\t\t\t\t\tq = x[u][v];\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tr = loop[p][q];\n\t\t\t\t\t\t\t\tfor(int a=0;a<n;a++){\n\t\t\t\t\t\t\t\t\tfor(int b=0;b<n;b++){\n\t\t\t\t\t\t\t\t\t\tif(loop[a][b]==cnt) loop[a][b] = r;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\t\n\t\t\t}\n\n\t\t\tSystem.out.println(cnt-1);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic int N;\n\tstatic int[][][] field;\n\tstatic int[][] already;\n\tstatic boolean[][] isLoop;\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN=cin.nextInt();\n\t\t\tif(N==0)break;\n\t\t\tfield=new int[N][N][2];\n\t\t\talready=new int[N][N];\n\t\t\tisLoop=new  boolean[N][N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tfield[j][i][0]=cin.nextInt();\n\t\t\t\t\tfield[j][i][1]=cin.nextInt();\n\t\t\t\t}\n\t\t\t}int ans=0,cnt=1;;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tint[] a=a(j,i,cnt++);\n//\t\t\t\t\tSystem.out.println(j+\" \"+i+\" \"+a[0]+\" \"+a[1]);\n\t\t\t\t\tif(a[0]==j&&a[1]==i&&!isLoop[j][i]){\n\t\t\t\t\t\tans++;\n//\t\t\t\t\t\tSystem.out.println(\"aaaaaa\"+j+\" \"+i);\n\t\t\t\t\t\tb(j,i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic void b(int y,int x){\n\t\tif(isLoop[y][x])return;\n\t\tisLoop[y][x]=true;\n\t\tint a=field[y][x][0];\n\t\tint b=field[y][x][1];\n\t\tb(a,b);\n\t}\n\tstatic int[] a(int y,int x,int cnt){\n//\t\tSystem.out.println(\"   \"+y+\" \"+x);\n\t\t//field[y][x]\n\t\tint a=field[y][x][0];\n\t\tint b=field[y][x][1];\n\t\tif(already[y][x]==cnt)return new int[]{y,x};\n\t\talready[y][x]=cnt;\n\t\t\n\t\treturn a(a,b,cnt);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/*\n * テ、ツスツ陛・ツ崢榲ァツ崢ョテ」ツ?ョテヲツ篠「テァツエツ「テ」ツ?ァテヲツ敖・テ」ツ?淌」ツ?ョテ」ツ?凝」ツつ津・ツ?・テ」ツつ古」ツ?ヲテ」ツ?甘」ツ??\n * テ・ツ青古」ツ?佚・ツ崢榲ヲツ閉ーテァツ崢ョテ」ツ?ョテヲツ篠「テァツエツ「テ」ツ?ェテ」ツつ嘉」ツδォテ」ツδシテ」ツδ療」ツ?ァテ」ツ??ゥツ?陛」ツ??」ツ?ェテ」ツつ嘉」ツつづ」ツ??ヲツ猟「テ」ツ?ォテ」ツ?敕」ツ?ョテ」ツδォテ」ツδシテ」ツδ療」ツ?ッテ」ツつォテ」ツつヲテ」ツδウテ」ツδ暗ヲツクツ暗」ツ?ソ\n */\nclass E{\n\tint loop;\n\tint x;\n\tint y;\n\t\n\tE(int a,int b){\n\t\tloop=0;\n\t\tx=a;\n\t\ty=b;\n\t}\n}\npublic class AOJ2217 {\n\tE map[][];\n\tint count;//,sx,sy;\n\tpublic static void main(String[] args) {\n\t\tnew AOJ2217().run();\n\t}\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tmap=new E[n][n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tint a=sc.nextInt();\n\t\t\t\t\tint b=sc.nextInt();\n\t\t\t\t\tmap[j][i]= new E(a,b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c=1;//loop number\n\t\t\tcount=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(map[j][i].loop==0){\n\t\t\t\t\t\t//sx=j;sy=i;\n\t\t\t\t\t\tsolve(j, i, c);\n\t\t\t\t\t\tc++;//loop number\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n\tvoid solve(int mx,int my,int c){\n//\t\tSystem.out.println(mx+\" \"+my+\"  \"+map[mx][my].x+\" \"+map[mx][my].y);\n\t\t\n\t\tif(0<map[mx][my].loop){//テ」ツ?ゥテ」ツ?」テ」ツ?凝」ツ?ョテヲツ篠「テァツエツ「テ」ツ?ァテヲツ敖・テ」ツ?淌」ツ?禿」ツ?ィテ」ツ?古」ツ?づ」ツつ?\n\t\t\tif(c==map[mx][my].loop){//テ、ツサツ甘・ツ崢榲」ツ?ョloopテ」ツ??」ツ?」テ」ツ?淌」ツつ嘉」ツ??ヲツ鳴ーテ」ツ?療」ツ??oopテ」ツつ津ィツヲツ凝」ツ?、テ」ツ?妥」ツ?淌」ツ?ョテ」ツ?ァテ・ツ「ツ療」ツつ?」ツ??\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\t\treturn;//テ」ツ?凖」ツ?ァテ」ツ?ォティツヲツ凝」ツ?、テ」ツ?妥」ツ?殕oopテ」ツ??」ツ?」テ」ツ?淌」ツつ嘉」ツ?ェテ」ツ?ォテ」ツつづ」ツ?療」ツ?ェテ」ツ??\n\t\t}\n\t\t\n\t\tint a=map[mx][my].x;//テァツァツサテ・ツ仰陛・ツ?暗」ツつ津」ツ??」ツつ古」ツつ?\n\t\tint b=map[mx][my].y;\n\t\t\n\t\tmap[mx][my].loop=c;//テ、ツサツ甘・ツ崢榲」ツ?ョloop numberテ」ツつ津」ツ??」ツつ古」ツつ?\n\t\t\n\t\tsolve(a, b, c);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tint N=in.nextInt();\n\t\t\tif(N==0)\n\t\t\t\treturn;\n\t\t\tjump a[][]=new jump[N][N];\n\t\t\tArrayList<jump>AL=new ArrayList<jump>();\n\t\t\tint field[][]=new int[N][N];\n\t\t\tboolean judge[][]=new boolean[N][N];\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\t{\n\t\t\t\t\tjump b=new jump(in.nextInt(),in.nextInt());\n\t\t\t\t\ta[j][i]=b;\n\t\t\t\t}\n\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\t{\n\t\t\t\t\tint xx=j;\n\t\t\t\t\tint yy=i;\n\t\t\t\t\tif(field[j][i]==0)\n\t\t\t\t\t\tfor(;;)\t\t\t\t\t\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(field[xx][yy]==2)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(judge[xx][yy]==false)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\t\tjudge[xx][yy]=true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfield[xx][yy]=2;\n\t\t\t\t\t\t\tjump b=new jump(xx, yy);\n\t\t\t\t\t\t\tAL.add(b);\n\t\t\t\t\t\t\tint tx=a[xx][yy].x;\n\t\t\t\t\t\t\tint ty=a[xx][yy].y;\n\t\t\t\t\t\t\txx=tx;\n\t\t\t\t\t\t\tyy=ty;\n\t\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<AL.size();k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint rex=AL.get(k).x;\n\t\t\t\t\t\tint rey=AL.get(k).y;\n\t\t\t\t\t\tjudge[rex][rey]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n}\nclass jump\n{\n\tint x;\n\tint y;\n\tpublic jump(int a,int b) \n\t{\n\t\tx=a;\n\t\ty=b;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\tvoid run() {\n\t\tfor (;;) {\n\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint map[][][] = new int[n][n][2];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tmap[i][j][0] = sc.nextInt();\n\t\t\t\t\tmap[i][j][1] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tUnionFind uf = new UnionFind(n * n);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tint pos = pos(j, i, n);\n\t\t\t\t\tint jump_x = map[i][j][0];\n\t\t\t\t\tint jump_y = map[i][j][1];\n\t\t\t\t\tint jump = pos(jump_x, jump_y, n);\n\t\t\t\t\tuf.unite(pos, jump);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSet<Integer> set = new HashSet<Integer>();\n\t\t\tfor (int i = 0; i < uf.par.length; i++) {\n\t\t\t\tuf.find(i);\n\t\t\t\tset.add(uf.par[i]);\n\t\t\t}\n\t\t\tSystem.out.println(set.size());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\n\t}\n\n\tint pos(int x, int y, int w) {\n\t\treturn x + y * w;\n\t}\n}\n\nclass UnionFind {\n\tpublic int par[];\n\tpublic int rank[];\n\n\tUnionFind(int n) {\n\t\tpar = new int[n];\n\t\trank = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\n\tpublic int find(int x) {\n\t\tif (par[x] == x)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn par[x] = find(par[x]);\n\t}\n\n\tpublic void unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)\n\t\t\treturn;\n\n\t\tif (rank[x] < rank[y]) {\n\t\t\tpar[x] = y;\n\t\t} else {\n\t\t\tpar[y] = x;\n\t\t\tif (rank[x] == rank[y])\n\t\t\t\trank[x]++;\n\t\t}\n\t}\n\n\tpublic boolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//Let's JUMPSTYLE\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint[][][] m = new int[n][n][2];\n\t\t\tfor(int i=0;i<n;i++)for(int j=0;j<n;j++)for(int k=0;k<2;k++)m[i][j][k]=sc.nextInt();\n\t\t\tboolean[][] u = new boolean[n][n];\n\t\t\tint c = 0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(u[i][j])continue;\n\t\t\t\t\tu[i][j] = true;\n\t\t\t\t\tSet<Integer> set = new HashSet<Integer>();\n\t\t\t\t\tset.add(i*n+j);\n\t\t\t\t\tint nj = m[i][j][0];\n\t\t\t\t\tint ni = m[i][j][1];\n\t\t\t\t\twhile(true){\n\t\t\t\t\t\tif(u[ni][nj]){\n\t\t\t\t\t\t\tif(set.contains(ni*n+nj))c++;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tu[ni][nj] = true;\n\t\t\t\t\t\tset.add(ni*n+nj);\n\t\t\t\t\t\tint ti = ni;\n\t\t\t\t\t\tint tj = nj;\n\t\t\t\t\t\tnj = m[ti][tj][0];\n\t\t\t\t\t\tni = m[ti][tj][1];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic int[][] R, C;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tR = new int[N][N];\n\t\t\tC = new int[N][N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tC[i][j] = sc.nextInt();\n\t\t\t\t\tR[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] visited = new int[N][N];\n\t\t\tint ans = 0;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\tif (visited[i][j] == 2) continue;\n\t\t\t\t\tint cr = i;\n\t\t\t\t\tint cc = j;\n\t\t\t\t\tboolean loop = false;\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tif (visited[cr][cc] == 2) break;\n\t\t\t\t\t\tif (visited[cr][cc] == 1) {\n\t\t\t\t\t\t\tloop = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvisited[cr][cc] = 1;\n\t\t\t\t\t\tint nr = R[cr][cc];\n\t\t\t\t\t\tint nc = C[cr][cc];\n\t\t\t\t\t\tcr = nr;\n\t\t\t\t\t\tcc = nc;\n\t\t\t\t\t}\n\t\t\t\t\tif (loop) ++ans;\n\t\t\t\t\tcr = i;\n\t\t\t\t\tcc = j;\n\t\t\t\t\twhile (visited[cr][cc] == 1) {\n\t\t\t\t\t\tvisited[cr][cc] = 2;\n\t\t\t\t\t\tint nr = R[cr][cc];\n\t\t\t\t\t\tint nc = C[cr][cc];\n\t\t\t\t\t\tcr = nr;\n\t\t\t\t\t\tcc = nc;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n/*\n * テ、ツスツ陛・ツ崢榲ァツ崢ョテ」ツ?ョテヲツ篠「テァツエツ「テ」ツ?ァテヲツ敖・テ」ツ?淌」ツ?ョテ」ツ?凝」ツつ津・ツ?・テ」ツつ古」ツ?ヲテ」ツ?甘」ツ??\n * テ・ツ青古」ツ?佚・ツ崢榲ヲツ閉ーテァツ崢ョテ」ツ?ョテヲツ篠「テァツエツ「テ」ツ?ェテ」ツつ嘉」ツδォテ」ツδシテ」ツδ療」ツ?ァテ」ツ??ゥツ?陛」ツ??」ツ?ェテ」ツつ嘉」ツつづ」ツ??ヲツ猟「テ」ツ?ォテ」ツ?敕」ツ?ョテ」ツδォテ」ツδシテ」ツδ療」ツ?ッテ」ツつォテ」ツつヲテ」ツδウテ」ツδ暗ヲツクツ暗」ツ?ソ\n */\nclass E{\n\tint loop;\n\tint x;\n\tint y;\n\t\n\tE(int a,int b){\n\t\tloop=0;\n\t\tx=a;\n\t\ty=b;\n\t}\n}\npublic class Main {\n\tE map[][];\n\tint count;//,sx,sy;\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\tvoid run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tmap=new E[n][n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tint a=sc.nextInt();\n\t\t\t\t\tint b=sc.nextInt();\n\t\t\t\t\tmap[j][i]= new E(a,b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint c=1;//loop number\n\t\t\tcount=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(map[j][i].loop==0){\n\t\t\t\t\t\t//sx=j;sy=i;\n\t\t\t\t\t\tsolve(j, i, c);\n\t\t\t\t\t\tc++;//loop number\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\t\n\tvoid solve(int mx,int my,int c){\n//\t\tSystem.out.println(mx+\" \"+my+\"  \"+map[mx][my].x+\" \"+map[mx][my].y);\n\t\t\n\t\tif(0<map[mx][my].loop){//テ」ツ?ゥテ」ツ?」テ」ツ?凝」ツ?ョテヲツ篠「テァツエツ「テ」ツ?ァテヲツ敖・テ」ツ?淌」ツ?禿」ツ?ィテ」ツ?古」ツ?づ」ツつ?\n\t\t\tif(c==map[mx][my].loop){//テ、ツサツ甘・ツ崢榲」ツ?ョloopテ」ツ??」ツ?」テ」ツ?淌」ツつ嘉」ツ??ヲツ鳴ーテ」ツ?療」ツ??oopテ」ツつ津ィツヲツ凝」ツ?、テ」ツ?妥」ツ?淌」ツ?ョテ」ツ?ァテ・ツ「ツ療」ツつ?」ツ??\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\t\treturn;//テ」ツ?凖」ツ?ァテ」ツ?ォティツヲツ凝」ツ?、テ」ツ?妥」ツ?殕oopテ」ツ??」ツ?」テ」ツ?淌」ツつ嘉」ツ?ェテ」ツ?ォテ」ツつづ」ツ?療」ツ?ェテ」ツ??\n\t\t}\n\t\t\n\t\tint a=map[mx][my].x;//テァツァツサテ・ツ仰陛・ツ?暗」ツつ津」ツ??」ツつ古」ツつ?\n\t\tint b=map[mx][my].y;\n\t\t\n\t\tmap[mx][my].loop=c;//テ、ツサツ甘・ツ崢榲」ツ?ョloop numberテ」ツつ津」ツ??」ツつ古」ツつ?\n\t\t\n\t\tsolve(a, b, c);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.StringTokenizer;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Problem B: Let's JUMPSTYLE\n */\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\twhile ((line = br.readLine()) != null && !line.isEmpty()) {\n\n\t\t\tint N = parseInt(line);\n\t\t\tif (N == 0) break;\n\n\t\t\tint[][][] G = new int[N][N][2];\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tStringTokenizer st = new StringTokenizer(br.readLine());\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tG[j][i][0] = parseInt(st.nextToken());\n\t\t\t\t\tG[j][i][1] = parseInt(st.nextToken());\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint[][] check = new int[N][N];\n\t\t\tint timestamp = 0;\n\t\t\tint count = 0;\n\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (check[i][j] == 0) {\n\t\t\t\t\t\tcheck[i][j] = ++timestamp;\n\t\t\t\t\t\tint _i = G[i][j][0];\n\t\t\t\t\t\tint _j = G[i][j][1];\n\t\t\t\t\t\twhile (check[_i][_j] == 0) {\n\t\t\t\t\t\t\tcheck[_i][_j] = timestamp;\n\t\t\t\t\t\t\t_i = G[_i][_j][0];\n\t\t\t\t\t\t\t_j = G[_i][_j][1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (check[_i][_j] == timestamp) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate static final int Y = 1;\n\tprivate static final int X = 0;\n\n\tpublic static void main(String[] args) {\n\t\tScanner in = new Scanner(System.in);\n\t\tint[][][] t = new int[100][100][2];\n\t\tint n;\n\t\twhile ((n = in.nextInt()) > 0) {\n\t\t\t// System.out.println(\"n=\" + n);\n\t\t\tfor (int y = 0; y < n; y++) {\n\t\t\t\tfor (int x = 0; x < n; x++) {\n\t\t\t\t\tt[x][y][X] = in.nextInt();\n\t\t\t\t\tt[x][y][Y] = in.nextInt();\n\t\t\t\t}\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tint stepNum = 0;\n\t\t\tfor (int startX = 0; startX < n; startX++) {\n\t\t\t\tfor (int startY = 0; startY < n; startY++) {\n\t\t\t\t\tstepNum -= 1;\n\t\t\t\t\tint posiX = startX, posiY = startY;\n\t\t\t\t\tint nextX = t[posiX][posiY][X], nextY = t[posiX][posiY][Y];\n\t\t\t\t\twhile (nextX >= 0) {\n\t\t\t\t\t\tt[posiX][posiY][X] = stepNum;\n\t\t\t\t\t\tposiX = nextX;\n\t\t\t\t\t\tposiY = nextY;\n\t\t\t\t\t\tnextX = t[posiX][posiY][X];\n\t\t\t\t\t\tnextY = t[posiX][posiY][Y];\n\t\t\t\t\t\tif (nextX == stepNum) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t// for (int x = 0; x < n; x++) {\n\t\t\t// for (int y = 0; y < n; y++) {\n\t\t\t// System.out.print(t[x][y][X] + \" \");\n\t\t\t// }\n\t\t\t// System.out.println();\n\t\t\t// }\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int n;\n\tstatic int pre[][];\n\tstatic int jpx[][];\n\tstatic int jpy[][];\n\n\tpublic static boolean mark(int x, int y, int mark) {\n\t\tif (0 < pre[y][x]) {\n\t\t\tif (pre[y][x] == mark) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tpre[y][x] = mark;\n\t\tint nx = jpx[y][x];\n\t\tint ny = jpy[y][x];\n\t\treturn mark(nx, ny, mark);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile (true) {\n\t\t\tn = sc.nextInt();\n\t\t\tif (n == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tpre = new int[n][n];\n\t\t\tjpx = new int[n][n];\n\t\t\tjpy = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tjpx[i][j] = sc.nextInt();\n\t\t\t\t\tjpy[i][j] = sc.nextInt();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint cnt = 0;\n\t\t\tint mark = 1;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (pre[i][j] == 0) {\n\t\t\t\t\t\tif (mark(j, i, mark)) {\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmark++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tfor(;;)\n\t\t{\n\t\t\tint N=in.nextInt();\n\t\t\tif(N==0)\n\t\t\t\treturn;\n\t\t\tjump a[][]=new jump[N][N];\n\t\t\tArrayList<jump>AL=new ArrayList<jump>();\n\t\t\tint field[][]=new int[N][N];\n\t\t\tboolean judge[][]=new boolean[N][N];\n\t\t\tint cnt=0;\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\t\ta[j][i]=new jump(in.nextInt(),in.nextInt());\n\n\t\t\tfor(int i=0;i<N;i++)\n\t\t\t\tfor(int j=0;j<N;j++)\n\t\t\t\t{\n\t\t\t\t\tint xx=j;\n\t\t\t\t\tint yy=i;\n\t\t\t\t\tif(field[j][i]==0)\n\t\t\t\t\t\tfor(;;)\t\t\t\t\t\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(field[xx][yy]==2)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif(judge[xx][yy]==false)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\t\tjudge[xx][yy]=true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfield[xx][yy]=2;\n\t\t\t\t\t\t\tAL.add(new jump(xx, yy));\n\t\t\t\t\t\t\tint tx=a[xx][yy].x;\n\t\t\t\t\t\t\tint ty=a[xx][yy].y;\n\t\t\t\t\t\t\txx=tx;\n\t\t\t\t\t\t\tyy=ty;\n\t\t\t\t\t\t}\n\t\t\t\t\tfor(int k=0;k<AL.size();k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint rex=AL.get(k).x;\n\t\t\t\t\t\tint rey=AL.get(k).y;\n\t\t\t\t\t\tjudge[rex][rey]=true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n}\nclass jump\n{\n\tint x;\n\tint y;\n\tpublic jump(int a,int b) \n\t{\n\t\tx=a;\n\t\ty=b;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);for(int n,c,i;(n=s.nextInt())>0;System.out.println(c-1)){for(a=new int[n*n],l=a.clone(),i=0;i<n*n;)a[i++]=s.nextInt()+s.nextInt()*n;for(c=1;i-->0;)if(f(a[i],c)==c)l[i]=f(a[i],c++);}}static int[]l,a;static int f(int x,int c){return l[x]>0?l[x]:(l[x]=f(a[x],l[x]=c));}}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic class P\n{\n    public int x { get; set; }\n    public int y { get; set; }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            var n = int.Parse(Console.ReadLine().Trim());\n            if (n == 0) break;\n            var map = new P[n, n];\n            var used = new int[n, n];\n            for (int i = 0; i < n; i++)\n            {\n                string[] line = Console.ReadLine().Trim().Split(' ');\n                for (int j = 0; j < n; j++)\n                {\n                    var wx = int.Parse(line[2 * j]);\n                    var wy = int.Parse(line[2 * j + 1]);\n                    map[j, i] = new P { x = wx, y = wy };\n                }\n            }\n            var count = 0;\n            var mark = 1;\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                {\n                    if (used[j, i] == 0)\n                    {\n                        used[j, i] = mark;\n                        var nx = j;\n                        var ny = i;\n                        while (true)\n                        {\n                            var nx2 = map[nx, ny].x;\n                            var ny2 = map[nx, ny].y;\n                            var w = used[nx2, ny2];\n                            if (w != 0 && w != mark) { mark++; break; }\n                            else if (w == mark) { count++; mark++; break; }\n                            used[nx2, ny2] = mark;\n                            nx = nx2;\n                            ny = ny2;\n                        }\n                    }\n                }\n            Console.WriteLine(count);\n        }\n    }\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "function bomb(y,x){\n   var Y=yx[y][x][1];\n   var X=yx[y][x][0];\n   if(ring.hasOwnProperty(Y+\",\"+X)){\n      var flag=true;\n      for(var k in ring){\n         if(obj.hasOwnProperty(k))flag=false;\n         obj[k]=true;     \n      } \n      if(flag)cnt++;\n   }else{\n      ring[Y+\",\"+X]=true;\n      bomb(Y,X);\n   }\n}\nvar input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar arr=input.trim().split(\"\\n\");\nwhile(true){\n   var n=arr.shift()-0;\n   if(n==0)break;\n   var yx=[];\n   for(var i=0;i<n;i++){\n      var tile=arr.shift().split(\" \").map(Number);\n      var t=[];\n      for(var j=0;j<n;j++)t[j]=[tile.shift(),tile.shift()];\n      yx.push(t);\n   }\n   var obj={};\n   var cnt=0;\n   for(var i=0;i<n;i++){\n      for(var j=0;j<n;j++){\n         if(obj.hasOwnProperty(i+\",\"+j))continue;\n         var ring={};\n         ring[i+\",\"+j]=true;\n         bomb(i,j);\n      }\n   }\n   console.log(cnt);\n}"
  },
  {
    "language": "Ruby",
    "code": "while n = gets.to_i\n  break if n == 0\n  tile = n.times.map{ gets.split.map(&:to_i).each_slice(2).to_a.map{ |x, y| y * n + x } }.flatten(1)\n  visit = [-1] * (n * n)\n  cnt = 0\n  m = 0\n  while pos = visit.index{ |t| t == -1 }\n    loop do\n      visit[pos] = m\n      pos = tile[pos]\n      if visit[pos] != -1\n        if visit[pos] == m\n          cnt += 1\n        end\n        break\n      end\n    end\n    m += 1\n  end\n  p cnt\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n \nvoid main() {\n    struct P { int x, y; }\n    int N; \n    P[][] F;\n    bool input() {\n        scanf(\"%d\\n\", &N);\n        if (N == 0) return false;\n        F = new P[][](N, N);\n        foreach (i; 0 .. N) {\n            foreach (j; 0 .. N) {\n                P p; scanf(\"%d %d\", &p.x, &p.y);\n                F[i][j] = p;\n            }\n        }\n        return true;\n    }\n\n    void solve() {\n        auto used = new bool[][](N, N);\n        auto loop = new bool[][](N, N);\n        bool dfs(int oy, int ox, int y, int x) {\n            if (y == oy && x == ox) return true;\n            if (used[y][x]) return false;\n            if (loop[y][x]) return false;\n            used[y][x] = true;\n            return dfs(oy, ox, F[y][x].y, F[y][x].x);\n        }\n        void fillLoop(int y, int x) {\n            if (loop[y][x]) return;\n            loop[y][x] = true;\n            fillLoop(F[y][x].y, F[y][x].x);\n        }\n        int C = 0;\n        foreach (i; 0 .. N) {\n            foreach (j; 0 .. N) {\n                foreach (k; 0 .. N) used[k][] = false;\n                if (dfs(i, j, F[i][j].y, F[i][j].x)) {\n                    C++;\n                    fillLoop(i, j);\n                }\n            }\n        }\n        writeln(C);\n    }\n\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "while True:\n  n = int(input())\n  if n == 0:break\n  to = []\n  for i in range(n):\n    line = list(map(int, input().split()))\n    for j in range(n):\n      x, y = line[2 * j:2 * j + 2]\n      to.append(y * n + x)\n  \n  order = []\n  used = [False] * (n * n)\n  def dfs(x):\n    if used[x]:return\n    used[x] = True\n    dfs(to[x])\n    order.append(x)\n  \n  for i in range(n * n):\n    dfs(i)\n  order.reverse()\n  \n  def dfs2(x, used, group):\n    if x in group:return True\n    if used[x]:return False\n    group.add(x)\n    used[x] = True\n    return dfs2(to[x], used, group)\n  \n  used = [False] * (n * n)\n  ans = 0\n  for i in order:\n    group = set()\n    if not used[i]:\n      if dfs2(i, used, group):ans += 1\n  print(ans)\n  \n"
  },
  {
    "language": "Python",
    "code": "while True:\n  n = int(input())\n  if n == 0:break\n  to = []\n  fr = [[] for _ in range(n * n)]\n  for i in range(n):\n    line = list(map(int, input().split()))\n    for j in range(n):\n      x, y = line[2 * j:2 * j + 2]\n      to.append(y * n + x)\n      fr[y * n + x].append(i * n + j)\n  \n  order = []\n  used = [False] * (n * n)\n  def dfs(x):\n    if used[x]:return\n    used[x] = True\n    dfs(to[x])\n    order.append(x)\n  \n  for i in range(n * n):\n    dfs(i)\n  \n  def dfs2(x, used, group):\n    if used[x]:return\n    used[x] = True\n    for f in fr[x]:\n      dfs2(f, used, group)\n    group.append(x)\n  \n  used = [False] * (n * n)\n  ans = 0\n  for i in order:\n    group = []\n    if not used[i]:\n      dfs2(i, used, group)\n    if len(group) >= 1:\n      ans += 1\n  print(ans)\n  \n"
  },
  {
    "language": "Python",
    "code": "while True:\n  N = int(raw_input())\n\n  if N == 0:\n    break\n\n  field = [[(0, 0) for x in xrange(N)] for y in xrange(N)]\n\n  for y in xrange(N):\n    line = map(int, raw_input().split())\n\n    for x in xrange(N):\n      field[y][x] = (line[2 * x + 1], line[2 * x])\n\n  vis = set()\n\n  cnt = 0\n\n  for y in xrange(N):\n    for x in xrange(N):\n\n      cur = (y, x)\n\n      if cur in vis: continue\n\n      loop = set()\n      loop.add(cur)\n\n      while True:\n        cur = field[cur[0]][cur[1]]\n\n        if cur in vis:\n          loop.add(cur)\n          vis = vis | loop\n          break\n\n        if cur in loop:\n          loop.add(cur)\n          cnt += 1\n          vis = vis | loop\n          break\n\n        loop.add(cur)\n  print cnt"
  },
  {
    "language": "Python",
    "code": "while True:\n  n = int(input())\n  if n == 0:break\n  to = []\n  fr = [[] for _ in range(n * n)]\n  for i in range(n):\n    line = list(map(int, input().split()))\n    for j in range(n):\n      x, y = line[2 * j:2 * j + 2]\n      to.append(y * n + x)\n      fr[y * n + x].append(i * n + j)\n  \n  order = []\n  used = [False] * (n * n)\n  def dfs(x):\n    if used[x]:return\n    used[x] = True\n    dfs(to[x])\n    order.append(x)\n  \n  for i in range(n * n):\n    dfs(i)\n  order.reverse()\n  \n  def dfs2(x, used, group):\n    if used[x]:return False\n    if x in group:return True\n    group.append(x)\n    ret = False\n    ret = ret or dfs2(to[x], used, group)\n    return ret\n  \n  used = [False] * (n * n)\n  ans = 0\n  for i in order:\n    group = []\n    if not used[i]:\n      if dfs2(i, used, group):ans += 1\n    for g in group:used[g] = True\n  print(ans)\n  \n"
  },
  {
    "language": "Python",
    "code": "while True:\n  n = int(input())\n  if n == 0:break\n  to = []\n  for i in range(n):\n    line = list(map(int, input().split()))\n    for j in range(n):\n      x, y = line[2 * j:2 * j + 2]\n      to.append(y * n + x)\n  \n  order = []\n  used = [False] * (n * n)\n  def dfs(x):\n    if used[x]:return\n    used[x] = True\n    dfs(to[x])\n    order.append(x)\n  \n  for i in range(n * n):\n    dfs(i)\n  order.reverse()\n  \n  def dfs2(x, used, group):\n    if used[x]:return False\n    if x in group:return True\n    group.add(x)\n    return dfs2(to[x], used, group)\n  \n  used = [False] * (n * n)\n  ans = 0\n  for i in order:\n    group = set()\n    if not used[i]:\n      if dfs2(i, used, group):ans += 1\n    for g in group:used[g] = True\n  print(ans)\n  \n"
  }
]