[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 1000\n\ntypedef struct {\n    int x, y;\n} Tile;\n\nint N;\nTile grid[MAX_N][MAX_N];\nint visited[MAX_N][MAX_N];\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            scanf(\"%d %d\", &grid[i][j].x, &grid[i][j].y);\n            visited[i][j] = 0;\n        }\n    }\n\n    int loop_count = 0;\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j < N; j++) {\n            if (!visited[i][j]) {\n                int x = i, y = j;\n                while (!visited[x][y]) {\n                    visited[x][y] = 1;\n                    Tile next = grid[x][y];\n                    x = next.x;\n                    y = next.y;\n                }\n                // Check if we're back to the starting point of a new loop\n                int start_x = i, start_y = j;\n                if (x == start_x && y == start_y) {\n                    loop_count++;\n                }\n            }\n        }\n    }\n\n    printf(\"%d\\n\", loop_count);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:14:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\nint main() {\n    int N;\n    cin >> N;\n    \n    vector<vector<pair<int, int>>> grid(N, vector<pair<int, int>>(N));\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            cin >> grid[i][j].first >> grid[i][j].second;\n            grid[i][j].first--; // Convert to 0-based index\n            grid[i][j].second--;\n        }\n    }\n    \n    vector<vector<bool>> visited(N, vector<bool>(N, false));\n    int loopCount = 0;\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (!visited[i][j]) {\n                int x = i, y = j;\n                vector<pair<int, int>> path;\n                \n                while (true) {\n                    if (visited[x][y]) {\n                        bool isLoop = false;\n                        for (size_t k = 0; k < path.size(); ++k) {\n                            if (path[k].first == x && path[k].second == y) {\n                                isLoop = true;\n                                break;\n                            }\n                        }\n                        if (isLoop) {\n                            loopCount++;\n                        }\n                        break;\n                    }\n                    visited[x][y] = true;\n                    path.emplace_back(x, y);\n                    int nextX = grid[x][y].first;\n                    int nextY = grid[x][y].second;\n                    x = nextX;\n                    y = nextY;\n                }\n            }\n        }\n    }\n    \n    cout << loopCount << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:15:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class JumpStyle {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int[][] grid = new int[N][N];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                grid[i][j] = scanner.nextInt();\n            }\n        }\n\n        boolean[][] visited = new boolean[N][N];\n        int loopCount = 0;\n\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                if (!visited[i][j]) {\n                    Set<Integer> path = new HashSet<>();\n                    int currentX = i;\n                    int currentY = j;\n                    while (true) {\n                        int pos = currentX * N + currentY;\n                        if (path.contains(pos)) {\n                            loopCount++;\n                            break;\n                        }\n                        if (visited[currentX][currentY]) {\n                            break;\n                        }\n                        visited[currentX][currentY] = true;\n                        path.add(pos);\n                        int next = grid[currentX][currentY];\n                        currentX = next / N;\n                        currentY = next % N;\n                    }\n                }\n            }\n        }\n        System.out.println(loopCount);\n    }\n}",
    "timestamp": "2025-08-05 21:15:22"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class JumpStyleDance {\n    public static int countLoops(int[][] floor) {\n        int n = floor.length;\n        boolean[] visited = new boolean[n * n];\n        int loopCount = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i * n + j]) {\n                    int current = i * n + j;\n                    Set<Integer> currentPath = new HashSet<>();\n\n                    while (!visited[current]) {\n                        visited[current] = true;\n                        currentPath.add(current);\n                        int nextRow = floor[current / n][current % n] / n;\n                        int nextCol = floor[current / n][current % n] % n;\n                        current = nextRow * n + nextCol;\n                    }\n\n                    if (currentPath.contains(current)) {\n                        loopCount++;\n                    }\n                }\n            }\n        }\n\n        return loopCount;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[][] floor = new int[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                floor[i][j] = scanner.nextInt();\n            }\n        }\n\n        System.out.println(countLoops(floor));\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 21:15:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAX_N 100\n\nint grid[MAX_N][MAX_N];\nint visited[MAX_N][MAX_N];\nint loops[MAX_N * MAX_N];\nint loop_count = 0;\n\nvoid dfs(int x, int y, int n, int current_loop) {\n    if (x < 0 || x >= n || y < 0 || y >= n || visited[x][y] == current_loop)\n        return;\n\n    if (visited[x][y] > 0) {\n        loops[loop_count++] = current_loop;\n        return;\n    }\n\n    visited[x][y] = current_loop;\n    int next_x = grid[x][y] / n;\n    int next_y = grid[x][y] % n;\n    dfs(next_x, next_y, n, current_loop);\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            scanf(\"%d\", &grid[i][j]);\n        }\n    }\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (visited[i][j] == 0) {\n                dfs(i, j, n, loop_count + 1);\n            }\n        }\n    }\n\n    printf(\"%d\\n\", loop_count);\n    return 0;\n}",
    "timestamp": "2025-08-05 21:15:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <unordered_set>\n\nusing namespace std;\n\nint findLoops(vector<vector<int>>& grid) {\n    int n = grid.size();\n    vector<bool> visited(n * n, false);\n    int loopCount = 0;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (!visited[i * n + j]) {\n                unordered_set<int> currentLoop;\n                int current = i * n + j;\n\n                while (!visited[current]) {\n                    visited[current] = true;\n                    currentLoop.insert(current);\n                    int nextRow = grid[current / n][current % n] / n;\n                    int nextCol = grid[current / n][current % n] % n;\n                    current = nextRow * n + nextCol;\n                }\n\n                if (currentLoop.count(current)) {\n                    loopCount++;\n                }\n            }\n        }\n    }\n\n    return loopCount;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<vector<int>> grid(n, vector<int>(n));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            cin >> grid[i][j];\n            grid[i][j]--;\n        }\n    }\n\n    cout << findLoops(grid) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 21:15:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def find_loops_in_floor(N, grid):\n    def dfs(x, y, visited, path):\n        if visited[x][y]:\n            loop_length = len(path) - path.index((x, y))\n            loops.add(tuple(path[path.index((x, y)):]))\n            return\n        visited[x][y] = True\n        path.append((x, y))\n        next_x, next_y = grid[x][y]\n        dfs(next_x, next_y, visited, path)\n        path.pop()\n\n    visited = [[False] * N for _ in range(N)]\n    loops = set()\n    \n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                dfs(i, j, visited, [])\n    \n    return len(loops)\n\n# Example usage:\nN = 4\ngrid = [\n    [(1, 1), (3, 0), (1, 2), (1, 3)],\n    [(0, 1), (2, 2), (0, 3), (2, 0)],\n    [(3, 3), (3, 2), (1, 0), (0, 0)],\n    [(0, 0), (2, 3), (2, 1), (2, 2)]\n]\n\nprint(find_loops_in_floor(N, grid))",
    "timestamp": "2025-08-13 05:40:51"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\n\npublic class JumpstyleLoops {\n    static int[][] directions;\n    static boolean[][] visited;\n    static int n;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        n = scanner.nextInt();\n        directions = new int[n][n][2];\n        visited = new boolean[n][n];\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                directions[i][j][0] = scanner.nextInt() - 1;\n                directions[i][j][1] = scanner.nextInt() - 1;\n            }\n        }\n\n        int loopCount = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (!visited[i][j] && isCycle(i, j)) {\n                    loopCount++;\n                }\n            }\n        }\n\n        System.out.println(loopCount);\n    }\n\n    private static boolean isCycle(int x, int y) {\n        boolean[][] inPath = new boolean[n][n];\n        while (!visited[x][y]) {\n            if (inPath[x][y]) {\n                markVisited(x, y);\n                return true;\n            }\n            inPath[x][y] = true;\n            int newX = directions[x][y][0];\n            int newY = directions[x][y][1];\n            x = newX;\n            y = newY;\n        }\n        return false;\n    }\n\n    private static void markVisited(int startX, int startY) {\n        int x = startX, y = startY;\n        boolean[][] path = new boolean[n][n];\n        do {\n            visited[x][y] = true;\n            path[x][y] = true;\n            int nextX = directions[x][y][0];\n            int nextY = directions[x][y][1];\n            x = nextX;\n            y = nextY;\n        } while (!path[x][y]);\n    }\n}",
    "timestamp": "2025-08-13 05:40:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\n#define MAX 1000\n\nint N, grid[MAX][MAX][2];\nbool visited[MAX][MAX], inStack[MAX][MAX];\n\nint direction(int x, int y) {\n    return x * N + y;\n}\n\nvoid reset_visited() {\n    for (int i = 0; i < N; ++i)\n        for (int j = 0; j < N; ++j)\n            visited[i][j] = false;\n}\n\nvoid reset_inStack() {\n    for (int i = 0; i < N; ++i)\n        for (int j = 0; j < N; ++j)\n            inStack[i][j] = false;\n}\n\nbool dfs(int x, int y, bool *foundCycle) {\n    if (visited[x][y]) {\n        if (inStack[x][y]) {\n            *foundCycle = true;\n            return true;\n        }\n        return false;\n    }\n    visited[x][y] = true;\n    inStack[x][y] = true;\n    \n    int nx = grid[x][y][0], ny = grid[x][y][1];\n    if (dfs(nx, ny, foundCycle))\n        return true;\n    \n    inStack[x][y] = false;\n    return false;\n}\n\nint count_cycles() {\n    int cycleCount = 0;\n    reset_visited();\n    \n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (!visited[i][j]) {\n                bool foundCycle = false;\n                reset_inStack();\n                dfs(i, j, &foundCycle);\n                if (foundCycle)\n                    cycleCount++;\n            }\n        }\n    }\n    return cycleCount;\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            scanf(\"%d %d\", &grid[i][j][0], &grid[i][j][1]);\n            grid[i][j][0]--;  // to convert 1-based input index to 0-based\n            grid[i][j][1]--;\n        }\n    }\n    \n    int result = count_cycles();\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 05:41:07"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def count_dance_floor_loops(grid):\n    n = len(grid)\n    visited = [[False] * n for _ in range(n)]\n    loop_count = 0\n\n    def explore_loop(x, y):\n        current_path = set()\n        while 0 <= x < n and 0 <= y < n and not visited[x][y]:\n            current_path.add((x, y))\n            visited[x][y] = True\n            x, y = grid[x][y]\n\n        if (x, y) in current_path:\n            return 1\n        return 0\n\n    for i in range(n):\n        for j in range(n):\n            if not visited[i][j]:\n                loop_count += explore_loop(i, j)\n\n    return loop_count\n\ndef main():\n    n = int(input())\n    grid = []\n    for _ in range(n):\n        grid.append(list(map(lambda x: tuple(map(int, x.split(','))), input().split())))\n    \n    print(count_dance_floor_loops(grid))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:41:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    sys.setrecursionlimit(1 << 25)\n    N = int(sys.stdin.readline())\n    grid = []\n    for _ in range(N):\n        row = list(map(int, sys.stdin.readline().split()))\n        grid.append(row)\n    \n    visited = [[False for _ in range(N)] for __ in range(N)]\n    loop_count = 0\n    \n    for i in range(N):\n        for j in range(N):\n            if not visited[i][j]:\n                path = []\n                x, y = i, j\n                while True:\n                    if visited[x][y]:\n                        if (x, y) in path:\n                            idx = path.index((x, y))\n                            loop_count += 1\n                        break\n                    visited[x][y] = True\n                    path.append((x, y))\n                    nx, ny = grid[x][y] // N, grid[x][y] % N\n                    if nx == N:\n                        nx -= 1\n                    x, y = nx, ny\n    print(loop_count)\n\nsolve()",
    "timestamp": "2025-08-13 05:41:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n\nusing namespace std;\n\nvoid dfs(int x, int y, vector<vector<pair<int, int>>> &grid, vector<vector<bool>> &visited, set<pair<int, int>> &currentPath, bool &foundCycle) {\n    if (visited[x][y]) {\n        if (currentPath.count({x, y})) {\n            foundCycle = true;\n        }\n        return;\n    }\n    visited[x][y] = true;\n    currentPath.insert({x, y});\n\n    int nx = grid[x][y].first;\n    int ny = grid[x][y].second;\n    dfs(nx, ny, grid, visited, currentPath, foundCycle);\n\n    currentPath.erase({x, y});\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<pair<int, int>>> grid(N, vector<pair<int, int>>(N));\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            int nx, ny;\n            cin >> nx >> ny;\n            grid[i][j] = {nx - 1, ny - 1}; // adjust for 0-based index\n        }\n    }\n\n    vector<vector<bool>> visited(N, vector<bool>(N, false));\n    int numberOfCycles = 0;\n\n    for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < N; ++j) {\n            if (!visited[i][j]) {\n                set<pair<int, int>> currentPath;\n                bool foundCycle = false;\n                dfs(i, j, grid, visited, currentPath, foundCycle);\n                if (foundCycle) {\n                    ++numberOfCycles;\n                }\n            }\n        }\n    }\n\n    cout << numberOfCycles << endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:26:52"
  }
]