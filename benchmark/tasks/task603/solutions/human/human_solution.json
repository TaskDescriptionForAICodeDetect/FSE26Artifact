[
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define INF 99999999\n#define FER 0.0000000001\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\nstruct Edge\n{\n\tint s, t, w;\n\tEdge(int s,int t,int w):s(s),t(t),w(w){}\n\tEdge() :Edge(-1, -1, -1) {}\n\tbool operator<(const Edge& e)const\n\t{\n\t\treturn w != e.w ? w < e.w : (s != e.s ? s < e.s : t < e.t);\n\t}\n};\n\n\nstruct P\n{\n\tdouble x, y;\n\tP(double x, double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\n\tvector<P> points(N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> points[i].x >> points[i].y;\n\t}\n\n\tvector<vector<double>> L(N, vector<double>(N, 0.0));\n\tL[0][1] = (points[0] - points[1]).length();\n\n\tfor (int j = 2; j < N; j++)\n\t{\n\t\tfor (int i = 0; i < j; i++)\n\t\t{\n\t\t\tif (i + 1 < j)\n\t\t\t{\n\t\t\t\tL[i][j] = L[i][j - 1] + (points[j - 1] - points[j]).length();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tL[i][j] = numeric_limits<double>::infinity();\n\t\t\t\tfor (int k = 0; k < i; k++)\n\t\t\t\t{\n\t\t\t\t\tL[i][j] = min(L[i][j], L[k][i] + (points[k] - points[j]).length());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans = numeric_limits<double>::infinity();\n\tfor (int k = 0; k < N - 1; k++)\n\t{\n\t\tans = min(ans, L[k][N - 1] + (points[k] - points[N - 1]).length());\n\t}\n\n\tprintf(\"%.10lf\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <math.h>  \n\nusing std::cin;\nusing std::cout;\n\nstruct point {\n\tdouble x, y;\n\tpoint() = default;\n\tpoint(double x, double y) : x(x), y(y) {}\n\tfriend double distance(const point & p1, const point & p2) {\n\t\treturn sqrt(pow((p1.x - p2.x), 2) + pow((p1.y - p2.y), 2));\n\t}\n};\n\nint main() {\n\tsize_t N;\n\tcin >> N;\n\tstd::vector<point> points(N);\n\tfor (size_t i = 0; i < N; ++i) {\n\t\tcin >> points[i].x >> points[i].y;\n\t}\n\tdouble ** b = new double *[N];\n\tfor (size_t i = 0; i < N; ++i) {\n\t\tb[i] = new double[N];\n\t}\n\tb[0][1] = distance(points[0], points[1]);\n\tfor (size_t j = 2; j < N; ++j)\n\t\tb[0][j] = b[0][j - 1] + distance(points[j - 1], points[j]);\n\tfor (size_t i = 1; i < N; ++i) {\n\t\tfor (size_t j = i + 1; j < N; ++j) {\n\t\t\tif (i < j - 1) {\n\t\t\t\tb[i][j] = b[i][j - 1] + distance(points[j - 1], points[j]);\n\t\t\t}\n\t\t\telse if (i == j - 1) {\n\t\t\tdouble min = b[0][j - 1] + distance(points[0], points[j]);\n\t\t\tfor (size_t k = 1; k < i; ++k) {\n\t\t\tdouble temp = b[k][j - 1] + distance(points[k], points[j]);\n\t\t\t        if (temp < min) {\n\t\t\t\t\tmin = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tb[i][j] = min;\n\t\t\t}\n\t\t}\n\t}\n\tsize_t i = N - 2;\n\tcout.precision(10);\n\tcout << b[i][i + 1] + distance(points[i], points[i + 1]) << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1.0e-9;\nconst double INF = 1.0e20;\n\nint dsign(double d) {\n    if (fabs(d) < EPS) {\n        return 0;\n    } else {\n        return d < 0 ? -1 : 1;\n    }\n}\n\nstruct Point {\n    int x, y;\n\n    Point(int x = 0, int y = 0) : x(x), y(y) {\n    }\n\n    bool operator<(const Point& other) const {\n        return x < other.x || (x == other.x && y < other.y);\n    }\n};\n\ndouble dist(const Point& a, const Point& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nstruct BiTSP {\n    int n;\n    vector<vector<double>> memo;\n    vector<vector<double>> d;\n    \n    double solve(vector<Point>& points, int n) {\n        this->n = n;\n        sort(points.begin(), points.end());\n        \n        d.assign(n, vector<double>(n, 0));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                d[i][j] = dist(points[i], points[j]);\n            }\n        }\n        memo.assign(n, vector<double>(n, -1));\n        return search(0, 0);\n    }\n\n    double search(int i, int j) {\n        if (i < j) {\n            return search(j, i);\n        }\n        if (memo[i][j] != -1) {\n            return memo[i][j];\n        }\n        double result = INF;\n        if (i == n - 1) {\n            result = d[j][n - 1]; \n        }\n        else {\n            result = min(search(i + 1, j) + d[i][i + 1], search(j, i + 1) + d[j][i + 1]); \n        }\n        memo[i][j] = result;\n        return result;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> a;\n\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        a.push_back(Point(x, y));\n    }\n    BiTSP tsp;\n    double ans = tsp.solve(a, n);\n\n    cout << fixed << setprecision(9) << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1.0e-9;\nconst double INF = 1.0e20;\n\nint dsign(double d) {\n    if (fabs(d) < EPS) {\n        return 0;\n    } else {\n        return d < 0 ? -1 : 1;\n    }\n}\n\nstruct Point {\n    int x, y;\n\n    Point(int x = 0, int y = 0) : x(x), y(y) {\n    }\n\n    bool operator<(const Point& other) const {\n        return x < other.x || (x == other.x && y < other.y);\n    }\n};\n\ndouble dist(const Point& a, const Point& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nstruct BiTSP {\n    int n;\n    vector<vector<double>> memo;\n    vector<vector<double>> d;\n    \n    double solve(vector<Point>& points, int n) {\n        this->n = n;\n        sort(points.begin(), points.end());\n        \n        d.assign(n, vector<double>(n, 0));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                d[i][j] = dist(points[i], points[j]);\n            }\n        }\n        memo.assign(n, vector<double>(n, -1));\n        return search(0, 0);\n    }\n\n    double search(int i, int j) {\n        if (i < j) {\n            return search(j, i);\n        }\n        if (memo[i][j] != -1) {\n            return memo[i][j];\n        }\n        double result = INF;\n        if (i == n - 1) {\n            result d[j][n - 1]; \n        }\n        else {\n            reuslt = min(search(i + 1, j) + d[i][i + 1], search(j, i + 1) + d[j][i + 1]); \n        }\n        memo[i][j] = result;\n        return result;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> a;\n\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        a.push_back(Point(x, y));\n    }\n    BiTSP tsp;\n    double ans = tsp.solve(a, n);\n\n    cout << fixed << setprecision(9) << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\ndouble dist[1100][1100];\ndouble DP[1100][1100];\n\nint main(){\n\t\n\tint N;\n\tcin >> N;\n\t\n\tdouble x[1100], y[1100];\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tdouble dx = x[j] - x[i];\n\t\t\tdouble dy = y[j] - y[i];\n\t\t\tdist[i][j] = sqrt(dx * dx + dy * dy);\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tDP[i][j] = INF;\n\t\t}\n\t}\n\t\n\tDP[0][0] = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j <= i; j++){\n\t\t\tDP[i][i + 1] = min(DP[i][i + 1], DP[j][i] + dist[j][i + 1]);\n\t\t}\n\t\tfor(int j = i + 2; j < N; j++){\n\t\t\tDP[i][j] = DP[i][j - 1] + dist[j - 1][j];\n\t\t}\n\t}\n\tdouble ans = INF;\n\tfor(int i = 0; i < N; i++){\n\t\tans = min(ans, DP[i][N - 1] + dist[i][N - 1]);\n\t}\n\t\n\tprintf(\"%.8f\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\ndouble dist[1100][1100];\ndouble DP[1100][1100];\n\nint main(){\n\t\n\tint N;\n\tcin >> N;\n\t\n\tdouble x[1100], y[1100];\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tdouble dx = x[j] - x[i];\n\t\t\tdouble dy = y[j] - y[i];\n\t\t\tdist[i][j] = sqrt(dx * dx + dy * dy);\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tDP[i][j] = INF;\n\t\t}\n\t}\n\t\n\tDP[0][0] = 0;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j <= i; j++){\n\t\t\tDP[i][i + 1] = min(DP[i][i + 1], DP[j][i] + dist[j][i + 1]);\n\t\t}\n\t\tfor(int j = i + 2; j < N; j++){\n\t\t\tDP[i][j] = DP[i][j - 1] + dist[j - 1][j];\n\t\t}\n\t}\n\t/*\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tcout << DP[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\tdouble ans = INF;\n\tfor(int i = 0; i < N; i++){\n\t\tans = min(ans, DP[i][N - 1] + dist[i][N - 1]);\n\t}\n\t\n\tprintf(\"%.8f\\n\", ans);\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define INF 99999999\n#define FER 0.0000000001\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\nstruct Edge\n{\n\tint s, t, w;\n\tEdge(int s,int t,int w):s(s),t(t),w(w){}\n\tEdge() :Edge(-1, -1, -1) {}\n\tbool operator<(const Edge& e)const\n\t{\n\t\treturn w != e.w ? w < e.w : (s != e.s ? s < e.s : t < e.t);\n\t}\n};\n\n\nstruct P\n{\n\tdouble x, y;\n\tP(double x, double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N;\n\tcin >> N;\n\n\tvector<P> points(N);\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tcin >> points[i].x >> points[i].y;\n\t}\n\n\tvector<vector<double>> L(N, vector<double>(N, 0.0));\n\tL[0][1] = (points[0] - points[1]).length();\n\n\tfor (int j = 2; j < N; j++)\n\t{\n\t\tfor (int i = 0; i < j; i++)\n\t\t{\n\t\t\tif (i + 1 < j)\n\t\t\t{\n\t\t\t\tL[i][j] = L[i][j - 1] + (points[j - 1] - points[j]).length();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tL[i][j] = numeric_limits<double>::infinity();\n\t\t\t\tfor (int k = 0; k < i; k++)\n\t\t\t\t{\n\t\t\t\t\tL[i][j] = min(L[i][j], L[k][i] + (points[k] - points[j]).length());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans = numeric_limits<double>::infinity();\n\tfor (int k = 0; k < N - 1; k++)\n\t{\n\t\tans = min(ans, L[k][N - 1] + (points[k] - points[N - 1]).length());\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\ntypedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = LONG_LONG_MAX / 10;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\nconst int mod = 1000000007;\n\n\nvoid print_line(vector<ll> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\n\ntypedef pair<int, int> Point;\n\ndouble dist(const Point &p1, const Point &p2) {\n    return sqrt(pow(p1.first - p2.first, 2.0) + pow(p1.second - p2.second, 2.0));\n}\n\ndouble bitonic_tsp_distance(const vector<Point> &p) {\n    const int N = p.size();\n    vector<vector<double> > L(N, vector<double>(N, 0.0));\n\n    for (int j = 1; j < N; j++) {\n        for (int i = 0; i < j; i++) {\n            if (i == 0 && j == 1) {\n                L[i][j] = dist(p[i], p[j]);\n            } else if (i < j - 1) {\n                L[i][j] = L[i][j - 1] + dist(p[j - 1], p[j]);\n            } else {\n                L[i][j] = numeric_limits<double>::infinity();\n                for (int k = 0; k < i; k++)\n                    L[i][j] = min(L[i][j], L[k][i] + dist(p[k], p[j]));\n            }\n        }\n    }\n\n    double ans = numeric_limits<double>::infinity();\n\n    for (int k = 0; k < N - 1; k++)\n        ans = min(ans, L[k][N - 1] + dist(p[k], p[N - 1]));\n\n    return ans;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<pair<int, int> > points;\n\n    rep(i, n) {\n        int x, y;\n        cin >> x >> y;\n        points.emplace_back(x, y);\n    }\n    double ans = bitonic_tsp_distance(points);\n\n    printf(\"%.20f\\n\", ans);\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \nusing namespace std;\n \nconst int MAX = 1005;\n \ntypedef long double ld;\n \nld dp[MAX][MAX];\npair<int,int> arr[MAX];\nint n;\n \nld dist(int i,int j)\n{\n    return hypotl(arr[i].first-arr[j].first,arr[i].second-arr[j].second);\n}\n \nld solve(int idx,int lst)\n{\n    ld &ret = dp[idx][lst];\n    if(ret == ret)\n        return ret;\n    if(idx == n-1)\n        return ret = dist(idx,idx-1) + dist(idx,lst);\n    return ret = min(solve(idx+1,lst) + dist(idx,idx-1), solve(idx+1,idx-1) + dist(idx,lst));\n}\n \nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    memset(dp,-1,sizeof dp);\n    cin>>n;\n    for(int i=0;i<n;i++)\n        cin>>arr[i].first>>arr[i].second;\n    sort(arr,arr+n);\n    cout<<fixed<<setprecision(10)<<solve(1,0)<<\"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1.0e-9;\nconst double INF = 1.0e20;\n\nint dsign(double d) {\n    if (fabs(d) < EPS) {\n        return 0;\n    } else {\n        return d < 0 ? -1 : 1;\n    }\n}\n\nstruct Point {\n    int x, y;\n\n    Point(int x = 0, int y = 0) : x(x), y(y) {\n    }\n\n    bool operator<(const Point& other) const {\n        return x < other.x || (x == other.x && y < other.y);\n    }\n};\n\ndouble dist(const Point& a, const Point& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nstruct BiBST {\n    int n;\n    vector<vector<double>> dp;\n    vector<vector<double>> d;\n    \n    double solve(vector<Point>& points, int n) {\n        this->n = n;\n        sort(points.begin(), points.end());\n        \n        d.assign(n, vector<double>(n, 0));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                d[i][j] = dist(points[i], points[j]);\n            }\n        }\n        dp.assign(n, vector<double>(n, -1));\n\n        dp[0][0] = 0;\n        dp[0][1] = dp[1][0] = d[0][1];\n\n        return search(n - 1, n - 1);\n    }\n\n    double search(int i, int j) {\n        //cout << i << \" \" << j << endl;\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n        double result = INF;\n        if (i < j) {\n            result = search(j, i);\n        } else if (i == j && i == n - 1) {\n            for (int k = i - 2; k >= 0; k--) {\n                result = min(result, search(i - 1, k) + d[k][i] + d[i - 1][i]);\n            }\n        } else if (i - j == 1) {\n            for (int k = i - 2; k >= 0; k--) {\n                result = min(result, search(k, j) + d[i - 2][i]);\n            }\n        } else if (i - j > 1) {\n            result = search(i - 1, j) + d[i - 1][i];\n        }\n        dp[i][j] = result;\n        return result;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> a;\n\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        a.push_back(Point(x, y));\n    }\n    double ans = solve(a, n);\n\n    cout << fixed << setprecision(9) << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1.0e-9;\nconst double INF = 1.0e20;\n\nint dsign(double d) {\n    if (fabs(d) < EPS) {\n        return 0;\n    } else {\n        return d < 0 ? -1 : 1;\n    }\n}\n\nstruct Point {\n    int x, y;\n\n    Point(int x = 0, int y = 0) : x(x), y(y) {\n    }\n\n    bool operator<(const Point& other) const {\n        return x < other.x || (x == other.x && y < other.y);\n    }\n};\n\ndouble dist(const Point& a, const Point& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nstruct BiTSP {\n    int n;\n    vector<vector<double>> memo;\n    vector<vector<double>> d;\n    \n    double solve(vector<Point>& points, int n) {\n        this->n = n;\n        sort(points.begin(), points.end());\n        \n        d.assign(n, vector<double>(n, 0));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                d[i][j] = dist(points[i], points[j]);\n            }\n        }\n        memo.assign(n, vector<double>(n, -1));\n        return search(0, 0);\n    }\n\n    double search(int i, int j) {\n        if (i < j) {\n            return search(j, i);\n        }\n        if (memo[i][j] != -1) {\n            return memo[i][j];\n        }\n        double result = INF;\n        if (i == n - 1) {\n            result = d[j][n - 1]; \n        }\n        else {\n            result = min(search(i + 1, j) + d[i][i + 1], search(i, i + 1) + d[j][i + 1]); \n        }\n        memo[i][j] = result;\n        return result;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> a;\n\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        a.push_back(Point(x, y));\n    }\n    BiTSP tsp;\n    double ans = tsp.solve(a, n);\n\n    cout << fixed << setprecision(9) << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iomanip>\n#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n\nusing ld = long double;\n\nconst ld INF = 1e100;\n\ntemplate <class T>\nT Vec(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return std::vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\ntemplate <class T>\ninline T sq(T a) { return a * a; }\n\ninline ld dist(std::pair<ld, ld> a, std::pair<ld, ld> b) {\n    return sqrtl(sq(a.first - b.first) + sq(a.second - b.second));\n}\n\nint main() {\n    int N;\n    std::cin >> N;\n\n    std::vector<std::pair<ld, ld>> vp(N);\n    for (auto& p : vp) std::cin >> p.first >> p.second;\n    std::sort(vp.begin(), vp.end());\n\n    auto dp = Vec<ld>(N, N, INF);\n    dp[0][0] = 0;\n    for (int i = 0; i < N - 1; ++i) {\n        for (int j = 0; j < N - 1; ++j) {\n            int n = std::max(i, j) + 1;\n            dp[n][j] = std::min(dp[n][j], dp[i][j] + dist(vp[i], vp[n]));\n            dp[i][n] = std::min(dp[i][n], dp[i][j] + dist(vp[j], vp[n]));\n        }\n    }\n\n    ld ans = INF;\n    for (int i = 0; i < N - 1; ++i) {\n        ans = std::min(ans, std::min(dp[N - 1][i], dp[i][N - 1]) + dist(vp[i], vp[N - 1]));\n    }\n\n    std::cout << std::fixed << std::setprecision(10) << ans << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1005\n\nstruct Point{\n\tdouble x,y;\n};\n\nint N;\ndouble dist_table[NUM][NUM],dp[NUM][NUM];\nPoint point[NUM];\n\n\ndouble calc_dist(Point A,Point B){\n\n\treturn sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));\n}\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%lf %lf\",&point[i].x,&point[i].y);\n\t}\n\n\tfor(int i = 0; i < N-1; i++){\n\t\tfor(int k = i+1; k < N; k++){\n\n\t\t\tdist_table[i][k] = calc_dist(point[i],point[k]);\n\t\t\tdist_table[k][i] = dist_table[i][k];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\n\t\t\tdp[i][k] = 0;\n\t\t}\n\t}\n\n\tfor(int to = 1; to <= N-1; to++){\n\t\tfor(int from = 0; from < to; from++){\n\n\t\t\tif(from == 0 && to == 1){\n\n\t\t\t\tdp[from][to] = dist_table[from][to];\n\n\t\t\t}else if(from < to-1){\n\n\t\t\t\tdp[from][to] = dp[from][to-1]+dist_table[to-1][to];\n\n\t\t\t}else{\n\n\t\t\t\tdp[from][to] = BIG_NUM;\n\n\t\t\t\tfor(int k = 0; k < from; k++){\n\n\t\t\t\t\tdp[from][to] = min(dp[from][to],dp[k][from]+dist_table[k][to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans = BIG_NUM;\n\n\tfor(int i = 0; i <= N-2; i++){\n\n\t\tans = min(ans,dp[i][N-1]+dist_table[i][N-1]);\n\t}\n\n\tprintf(\"%.10lf\\n\",ans);\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long double ld;\ntypedef pair<ld,ld> mp;\nld inf = 1e9;\n\nld dis(mp a,mp b){\n\treturn sqrt( (a.first-b.first)*(a.first-b.first) + (a.second-b.second) * (a.second - b.second) );\n}\n\nint main(){\n\tint n;\n\tcin>>n;\n\tvector<mp> a(n);\n\tfor(int i=0;i<n;i++)cin>>a[i].first>>a[i].second;\n\tvector<vector<ld> > dp(n,vector<ld>(n,inf) );\n\tsort(a.begin(),a.end());\n\tdp[0][0] = 0;\n\tfor(int i=0;i<n-1;i++){\n\t\tfor(int j=0;j<n-1;j++){\n\t\t\tint t = max(i,j) + 1;\n\t\t\tdp[t][j] = min( dp[t][j], dp[i][j] + dis( a[i] , a[t] ) );\n\t\t\tdp[i][t] = min( dp[i][t], dp[i][j] + dis( a[j] , a[t] ) );\n\t\t}\n\t}\n\tld res = inf ;\n\tfor(int i=0;i<n-1;i++) res = min( res,  dp[n-1][i]  + dis( a[i] , a[n-1] ) );\n\tcout<<fixed<<setprecision(10)<<res<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vl = vector<ll>;\ntemplate<class T> using vc = vector<T>;\ntemplate<class T> using vvc = vector<vector<T>>;\n\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define repr(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repe(i, l, r) for (ll i = (l); i < (r); i++)\n#define reper(i, l, r) for (ll i = (r)-1; i >= (l); i--)\n#define repa(i,n) for (auto& i: n)\n\ntemplate<class T> inline bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nvoid init() {cin.tie(0);ios::sync_with_stdio(false);cout << fixed << setprecision(15);}\n\n#ifdef DEBUG\ntemplate <class T, class N> void verr(const T& a, const N& n) { rep(i, n) cerr << a[i] << \" \"; cerr << \"\\n\" << flush; }\nll dbgt = 1; void err() { cerr << \"passed \" << dbgt++ << \"\\n\" << flush; }\ntemplate<class H, class... T> void err(H&& h,T&&... t){ cerr<< h << (sizeof...(t)?\" \":\"\\n\") << flush; if(sizeof...(t)>0) err(forward<T>(t)...); }\n#endif\n\nconst ll INF = 4e18;\nconst ld EPS = 1e-11;\nconst ld PI = acos(-1.0L);\nconst ll MOD = 1e9 + 7;\n// const ll MOD = 998244353;\n//--------------------------------------------------------------------------------//\n\n// 時間計算量O(N^2), 空間計算量O(N)\n\nld dist(pair<ld,ld> p1, pair<ld,ld> p2){\n    return hypot(p1.first - p2.first, p1.second - p2.second);\n}\n\nint main() {\n    init();\n    ll N;\n    cin >> N;\n    vc<pair<ld, ld>> P(N);\n    repa(p, P) cin >> p.first >> p.second;\n\n    // accd[i+1] = dist(v_0, v_1), ... , dist(v_i, v_{i+1})の累積和\n    vc<ld> accd(N), D(N);\n    rep(i, N - 1) D[i + 1] = dist(P[i], P[i + 1]), accd[i + 1] += D[i + 1] + accd[i];\n\n\n    vc<ld> C(N, INF);   // 頂点iまで点を使ったときの最小のサイクルの長さ\n    C[0] = 0, C[1] = 2 * accd[1];\n    \n\n    repe(i, 2, N){\n        // p_0 ~ p_{i-2}\n        rep(j, i - 1){\n            ld d = C[j + 1] + dist(P[j], P[i]) - D[j+1] + accd[i] - accd[j + 1];\n            chmin(C[i], d);\n        }\n    }\n\n    cout << C[N - 1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by Edward on 4/25/2020.\n//\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nnamespace bitonictsp{\n    int x[1000];\n    int N;\n    int y[1000];\n    double long dist[1000][1000];\n    double long t[1000][1000];\n    double long dp[1000];\n    int main(){\n        cin >> N;\n        for(int i = 0; i < N; i++){\n            cin >> x[i] >> y[i];\n        }\n        for(int i = 0; i < N; i++){\n            for(int j = 0; j < N; j++){\n                dist[i][j] = sqrt((x[i] - x[j])*(x[i] - x[j]) + (y[i]-y[j])*(y[i]-y[j]));\n            }\n        }\n        for(int i = 0; i < N; i++) {\n            t[i][i] = 0;\n            for (int j = i + 1; j < N; j++) {\n                t[i][j] = t[i][j - 1] + dist[j - 1][j];\n            }\n        }\n        dp[0] = dist[0][1];\n        for(int i = 1; i < N-1; i++){\n            dp[i] = dp[i-1] + dist[i-1][i+1];\n            for(int j = 0; j < i-1; j++){\n                dp[i] = min(dp[i], dp[j] + t[j+1][i] + dist[j][i+1]);\n            }\n        }\n        cout << fixed << setprecision(10) << (dp[N-2] + dist[N-2][N-1]) << endl;\n    }\n}\n\nint main(){\n    bitonictsp::main(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1.0e-9;\nconst double INF = 1.0e20;\n\nint dsign(double d) {\n    if (fabs(d) < EPS) {\n        return 0;\n    } else {\n        return d < 0 ? -1 : 1;\n    }\n}\n\nstruct Point {\n    int x, y;\n\n    Point(int x = 0, int y = 0) : x(x), y(y) {\n    }\n\n    bool operator<(const Point& other) const {\n        return x < other.x || (x == other.x && y < other.y);\n    }\n};\n\ndouble dist(const Point& a, const Point& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble search(int i, int j, int n, vector<vector<double>>&d, vector<vector<double>>&dp) {\n    //cout << i << \" \" << j << endl;\n    if (dp[i][j] != -1) {\n        return dp[i][j];\n    }\n    double result = INF;\n    if (i < j) {\n        result = search(j, i, n, d, dp);\n    } else if (i == j && i == n - 1) {\n        for (int k = n - 2; k >= 0; k--) {\n            result = min(result, search(i, k, n, d, dp) + d[k][n - 1]);\n        }\n        \n    } else if (i - j == 1) {\n        result = search(i - 2, j, n, d, dp) + d[i - 2][i];\n        if (j > 0) {\n            result = min(result, search(i, j - 1, n, d, dp) + d[j - 1][j]);\n        }\n    } else if (i - j > 1) {\n        result = search(i - 1, j, n, d, dp) + d[i - 1][i];\n    }\n    dp[i][j] = result;\n    return result;\n}\n\ndouble solve(vector<Point>& points, int n) {\n\n    sort(points.begin(), points.end());\n\n    vector<vector<double>> d(n, vector<double>(n, 0));\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            d[i][j] = dist(points[i], points[j]);\n        }\n    }\n    vector<vector<double>> dp(n, vector<double>(n, -1));\n\n    dp[0][0] = 0;\n    dp[0][1] = dp[1][0] = d[0][1];\n\n    return search(n - 1, n - 1, n, d, dp);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> a;\n\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        a.push_back(Point(x, y));\n    }\n    double ans = solve(a, n);\n\n    cout << fixed << setprecision(9) << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (lower_bound(ALL(c),x)-upper_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *min_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\ndouble dist(double x1, double x2, double y1, double y2) {\n   return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n}\nsigned main()\n{\n   int N; cin >> N;\n   V<int> x(N), y(N);\n   REP(i, N) {\n      cin >> x[i] >> y[i];\n   }\n   int miny = min(y);\n   REP(i, N) {\n      y[i] -= miny;\n   }\n   V<V<double>> dp(N, V<double>(N, INF));\n   dp[0][0] = 0;\n\n   FOR(i, 0, N-1) {\n      REP(j, N) {\n         chmin(dp[i+1][j], dp[i][j] + dist(x[i+1], x[i], y[i+1], y[i]));\n         chmin(dp[i+1][i], dp[i][j] + dist(x[i+1], x[j], y[i+1], y[j]));\n      }\n   }\n\n   double ans = INF;\n   REP(j, N) {\n      chmin(ans, dp[N-1][j] + dist(x[N-1], x[j], y[N-1], y[j]));\n   }\n   printf(\"%.6lf\\n\", ans);\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\n#define INF 10000000\n#define MAX_P 1000\ntypedef pair<double, double> Pt;\n\nint N;\ndouble dp[MAX_P][MAX_P];\nvector<Pt> xy;\n\ndouble ptdist(Pt p, Pt q) {\n  return sqrt(pow(p.first-q.first,2) + pow(p.second-q.second,2));\n}\n\ndouble solve() {\n  for (int i=0;i<N;++i) {\n    for (int j=0;j<N;++j) {\n      dp[i][j] = INF;\n    }\n  }\n  dp[0][0] = 0;\n  for (int i=1;i<N;++i) {\n    dp[0][i] = dp[0][i-1] + ptdist(xy[i-1],xy[i]);\n  }\n  for (int i=1;i<N;++i) {\n    for (int j=i;j<N;++j) {\n      if (i<j-1) {\n        dp[i][j] = dp[i][j-1] + ptdist(xy[j-1],xy[j]);\n      } else {\n        for (int k=0;k<i;++k) {\n          dp[i][j] = min(dp[i][j], dp[k][i]+ptdist(xy[k],xy[j]));\n        }\n      }\n      // cout<<i<<\" \"<<j<<\" \"<<dp[i][j]<<endl;\n    }\n  }\n  return dp[N-1][N-1];\n}\n\nint main () {\n  cin>>N;\n  for(int i=0;i<N;++i) {\n    double x,y;\n    cin>>x>>y;\n    xy.push_back(make_pair(x,y));\n  }\n  cout<<fixed<<setprecision(8)<<solve()<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct Precision{\n  Precision(){\n    cout<<fixed<<setprecision(12);\n  }\n}precision_beet;\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  vector<double> x(n),y(n);\n  for(Int i=0;i<n;i++) cin>>x[i]>>y[i];\n\n  auto dist=[&](Int i,Int j){\n    return hypot(x[i]-x[j],y[i]-y[j]);\n  };\n  \n  const double INF = 1e15;\n  auto dp=make_v<double>(n,n);\n  fill_v(dp,INF);\n  dp[n-1][n-1]=0;\n  for(Int i=n-1;i>0;i--){\n    for(Int j=n-1;j>0;j--){\n      Int k=min(i,j)-1;\n      chmin(dp[i][j],dp[j][i]);\n      chmin(dp[j][i],dp[i][j]);\n      chmin(dp[k][j],dp[i][j]+dist(i,k));\n      chmin(dp[i][k],dp[i][j]+dist(j,k));\n      chmin(dp[k][j],dp[j][k]);\n      chmin(dp[j][k],dp[k][j]);\n      chmin(dp[i][k],dp[k][i]);\n      chmin(dp[k][i],dp[i][k]);\n    }\n  }\n  \n  double ans=INF;\n  for(Int i=0;i<n;i++){\n    chmin(ans,dp[0][i]+dist(0,i));\n    chmin(ans,dp[i][0]+dist(i,0));\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long double INF = 1e9;\n\nint n;\nlong double x[1005], y[1005], dp[1005][1005];\n\nlong double dist(int i, int j) {\n    return sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));\n}\n\nint main() {\n\n    cin >> n;\n    for (int i = 0;  i < n; i++) {\n        cin >> x[i] >> y[i];\n    }\n\n    dp[1][0] = dist(0, 1);\n    for (int i = 2; i < n; i++) {\n        dp[i][i-1] = INF;\n        for (int j = 0; j + 1 < i; j++) {\n            dp[i][j] = dp[i-1][j] + dist(i - 1, i);\n            dp[i][i-1] = min(dp[i][i-1], dp[i-1][j] + dist(j, i));\n        }\n    }\n\n    long double ans = INF;\n    for (int j = 0; j + 1 < n; j++) {\n        ans = min(ans, dp[n-1][j] + dist(n-1, j));\n    }\n\n    cout << fixed << setprecision(10) << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (lower_bound(ALL(c),x)-upper_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *min_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\ndouble dist(double x1, double x2, double y1, double y2) {\n   return sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n}\nsigned main()\n{\n   int N; cin >> N;\n   V<int> x(N), y(N);\n   REP(i, N) {\n      cin >> x[i] >> y[i];\n   }\n   int miny = min(y);\n   REP(i, N) {\n      y[i] -= miny;\n   }\n   int Y = max(y);\n   V<V<double>> dp(N, V<double>(N, INF));\n   dp[0][0] = 0;\n\n   FOR(i, 0, N-1) {\n      REP(j, N) {\n         chmin(dp[i+1][j], dp[i][j] + dist(x[i+1], x[i], y[i+1], y[i]));\n         chmin(dp[i+1][y[i]], dp[i][j] + dist(x[i+1], x[j], y[i+1], y[j]));\n      }\n   }\n\n   double ans = INF;\n   REP(j, Y) {\n      chmin(ans, dp[N-1][j] + dist(x[N-1], x[j], y[N-1], y[j]));\n   }\n   printf(\"%.6lf\\n\", ans);\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst double INF = 1e9;\n\nint n, x[1005], y[1005];\ndouble dp[1005][1005];\n\ndouble dist(int i, int j) {\n    return sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));\n}\n\nint main() {\n\n    cin >> n;\n    for (int i = 0;  i < n; i++) {\n        cin >> x[i] >> y[i];\n    }\n\n    dp[1][0] = dist(0, 1);\n    for (int i = 2; i < n; i++) {\n        for (int j = 0; j + 1 < i; j++) {\n            dp[i][j] = dp[i-1][j] + dist(i - 1, i);\n            dp[i][i-1] = dp[i-1][j] + dist(j, i);\n        }\n    }\n\n    double ans = INF;\n    for (int j = 0; j + 1 < n; j++) {\n        ans = min(ans, dp[n-1][j] + dist(n-1, j));\n    }\n\n    cout << fixed << setprecision(10) << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=100001,INF=1<<30;\n\nint main(){\n\n    int N;cin>>N;\n    vector<double> x(N),y(N);\n    for(int i=0;i<N;i++){\n        cin>>x[i]>>y[i];\n    }\n    \n    double dp[N][N];\n    \n    for(int i=0;i<N;i++){\n        for(int j=0;j<N;j++){\n            dp[i][j]=double(INF);\n        }\n    }\n    \n    dp[0][0]=0;\n    dp[0][1]=hypot(x[1]-x[0],y[1]-y[0]);\n    \n    for(int j=1;j<N;j++){\n        for(int i=0;i<j;i++){\n            if(i==0&&j==1) continue;\n            if(i+1==j){\n                for(int k=0;k<i;k++){\n                    dp[i][j]=min(dp[i][j],dp[k][i]+hypot(x[j]-x[k],y[j]-y[k]));\n                }\n            }else{\n                dp[i][j]=min(dp[i][j],dp[i][j-1]+hypot(x[j]-x[j-1],y[j]-y[j-1]));\n            }\n        }\n    }\n    \n    double ans=double(INF);\n    \n    for(int i=0;i<N;i++){\n        ans=min(ans,dp[i][N-1]+hypot(x[N-1]-x[i],y[N-1]-y[i]));\n    }\n    \n    cout<<setprecision(25)<<ans<<endl;\n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing std::cin;\nusing std::cout;\n\nstruct point {\n\tdouble x, y;\n\tpoint() = default;\n\tpoint(double x, double y) : x(x), y(y) {}\n\tfriend double distance(const point & p1, const point & p2) {\n\t\treturn sqrt(pow((p1.x - p2.x), 2) + pow((p1.y - p2.y), 2));\n\t}\n};\n\nint main() {\n\tsize_t N;\n\tcin >> N;\n\tstd::vector<point> points(N);\n\tfor (size_t i = 0; i < N; ++i) {\n\t\tcin >> points[i].x >> points[i].y;\n\t}\n\tdouble ** b = new double *[N];\n\tfor (size_t i = 0; i < N; ++i) {\n\t\tb[i] = new double[N];\n\t}\n\tb[0][1] = distance(points[0], points[1]);\n\tfor (size_t j = 2; j < N; ++j)\n\t\tb[0][j] = b[0][j - 1] + distance(points[j - 1], points[j]);\n\tfor (size_t i = 1; i < N; ++i) {\n\t\tfor (size_t j = i + 1; j < N; ++j) {\n\t\t\tif (i < j - 1) {\n\t\t\t\tb[i][j] = b[i][j - 1] + distance(points[j - 1], points[j]);\n\t\t\t}\n\t\t\telse if (i == j - 1) {\n\t\t\t\tdouble min = b[0][j - 1] + distance(points[0], points[j]);\n\t\t\t\tfor (size_t k = 1; k < i; ++k) {\n\t\t\t\t\tdouble temp = b[k][j - 1] + distance(points[k], points[j]);\n\t\t\t\t\tif (temp < min) {\n\t\t\t\t\t\tmin = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb[i][j] = min;\n\t\t\t}\n\t\t}\n\t}\n\tsize_t i = N - 2;\n\tcout.precision(10);\n\tcout << b[i][i + 1] + distance(points[i], points[i + 1]) << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1.0e-9;\nconst double INF = 1.0e20;\n\nint dsign(double d) {\n    if (fabs(d) < EPS) {\n        return 0;\n    } else {\n        return d < 0 ? -1 : 1;\n    }\n}\n\nstruct Point {\n    int x, y;\n\n    Point(int x = 0, int y = 0) : x(x), y(y) {\n    }\n\n    bool operator<(const Point& other) const {\n        return x < other.x || (x == other.x && y < other.y);\n    }\n};\n\ndouble dist(const Point& a, const Point& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble search(int i, int j, int n, vector<vector<double>>&d, vector<vector<double>>&dp) {\n    if (dp[i][j] != -1) {\n        return dp[i][j];\n    }\n    double result = INF;\n    \n    int v = max(i, j) + 1;\n    \n    if (v == n - 1) {\n        result = d[i][v] + d[j][v]; \n    }\n    else {\n        result = min(search(v, j, n, d, dp) + d[i][v], search(i, v, n, d, dp) + d[j][v]);\n    }\n    dp[i][j] = result;\n    \n    return result;\n}\n\ndouble solve(vector<Point>& points, int n) {\n    sort(points.begin(), points.end());\n\n    vector<vector<double>> d(n, vector<double>(n, 0));\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            d[i][j] = dist(points[i], points[j]);\n        }\n    }\n    vector<vector<double>> dp(n, vector<double>(n, -1));\n    \n    return search(0, 0, n, d, dp);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> a;\n\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        a.push_back(Point(x, y));\n    }\n    double ans = solve(a, n);\n\n    cout << fixed << setprecision(9) << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define M_PI       3.14159265358979323846   // pi\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<ll> VI;\ntypedef pair<ll, ll> P;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\n\n#define rep(a,n) for(ll a = 0;a < n;a++)\n#define repi(a,b,n) for(ll a = b;a < n;a++)\n\nstatic const ll INF = 1e15;\nconst ll mod = 1e9 + 7;\n\nstruct BitnicSolver {\n\ttypedef pair<ll, ll> Point;\n\n\tdouble dist(const Point& p1, const Point& p2) {\n\t\treturn sqrt(pow(p1.first - p2.first, 2.0) + pow(p1.second - p2.second, 2.0));\n\t}\n\n\tdouble bitonic_tsp_distance(const vector<Point>& p) {\n\t\tconst int N = p.size();\n\t\tvector<vector<double> > L(N, vector<double>(N, 0.0));\n\n\t\tfor (int j = 1; j < N; j++) {\n\t\t\tfor (int i = 0; i < j; i++) {\n\t\t\t\tif (i == 0 && j == 1) {\n\t\t\t\t\tL[i][j] = dist(p[i], p[j]);\n\t\t\t\t}\n\t\t\t\telse if (i < j - 1) {\n\t\t\t\t\tL[i][j] = L[i][j - 1] + dist(p[j - 1], p[j]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tL[i][j] = numeric_limits<double>::infinity();\n\t\t\t\t\tfor (int k = 0; k < i; k++)\n\t\t\t\t\t\tL[i][j] = min(L[i][j], L[k][i] + dist(p[k], p[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble ans = numeric_limits<double>::infinity();\n\n\t\tfor (int k = 0; k < N - 1; k++)\n\t\t\tans = min(ans, L[k][N - 1] + dist(p[k], p[N - 1]));\n\n\t\treturn ans;\n\t}\n};\n\nint main(void)\n{\n\tll n;\n\tcin >> n;\n\tvector<P> ps(n);\n\trep(i, n) {\n\t\tP& a = ps[i];\n\t\tcin >> a.first >> a.second;\n\t}\n\tBitnicSolver s;\n\tauto r = s.bitonic_tsp_distance(ps);\n\tcout << std::fixed << setprecision(10);\n\tcout << r << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n\nusing std::cin;\nusing std::cout;\n\nstruct point {\n\tdouble x, y;\n\tpoint() = default;\n\tpoint(double x, double y) : x(x), y(y) {}\n\tfriend double distance(const point & p1, const point & p2) {\n\t\treturn sqrt(pow((p1.x - p2.x), 2) + pow((p1.y - p2.y), 2));\n\t}\n};\n\nint main() {\n\tsize_t N;\n\tcin >> N;\n\tstd::vector<point> points(N);\n\tfor (size_t i = 0; i < N; ++i) {\n\t\tcin >> points[i].x >> points[i].y;\n\t}\n\tdouble ** b = new double *[N];\n\tfor (size_t i = 0; i < N; ++i) {\n\t\tb[i] = new double[N];\n\t}\n\tb[0][1] = distance(points[0], points[1]);\n\tfor (size_t j = 2; j < N; ++j)\n\t\tb[0][j] = b[0][j - 1] + distance(points[j - 1], points[j]);\n\tfor (size_t i = 1; i < N; ++i) {\n\t\tfor (size_t j = i + 1; j < N; ++j) {\n\t\t\tif (i < j - 1) {\n\t\t\t\tb[i][j] = b[i][j - 1] + distance(points[j - 1], points[j]);\n\t\t\t}\n\t\t\telse if (i == j - 1) {\n\t\t\t\tdouble min = b[0][j - 1] + distance(points[0], points[j]);\n\t\t\t\tfor (size_t k = 1; k < i; ++k) {\n\t\t\t\t double temp = b[k][j - 1] + distance(points[k],points[j]);\n\t\t\t\t\tif (temp < min) {\n\t\t\t\t\t\tmin = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb[i][j] = min;\n\t\t\t}\n\t\t}\n\t}\n\tsize_t i = N - 2;\n\tcout.precision(10);\n\tcout << b[i][i + 1] + distance(points[i], points[i + 1]) << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1001\nusing namespace std;\n/*\n  ??????????¨?????????????????????????\n  ??°???????¨?????????????????????????\n*/\n\nint n,x[N],y[N];\ndouble mem[N][N];\nint used[N][N];\n\ndouble calc(int i,int j){\n  double a = x[i]-x[j];\n  double b = y[i]-y[j];\n  return sqrt(a*a+b*b);\n\n}\n\ndouble dfs(int a,int b,int idx){\n  if(idx == n) return calc(a,n-1)+calc(b,n-1);\n  if(used[a][b]++) return mem[a][b];\n  double res = 1e9;\n  res = min(res,calc(a,idx)+dfs(idx,b,idx+1));\n  res = min(res,calc(b,idx)+dfs(a,idx,idx+1));\n  return mem[a][b] = res;  \n}\n\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>x[i]>>y[i];\n  printf(\"%lf\\n\",dfs(0,0,1));\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n    double P[1000][2];\n    double D[1000][1000];\n    double dp[1001][1001];\n\n    void Solve() {\n        UL N; scanf(\"%d\", &N);\n        rep(i, N) scanf(\"%lf%lf\", &P[i][0], &P[i][1]);\n        rep(i, N) rep(j, N) {\n            double dx = P[i][0] - P[j][0];\n            double dy = P[i][1] - P[j][1];\n            D[i][j] = sqrt(dx * dx + dy * dy);\n        }\n        rep(i, N) rep(j, N) dp[i][j] = 1e10;\n        dp[0][0] = 0.0;\n        rep(i, N - 1) rep(j, N - 1) {\n            UL tg = max(i, j) + 1;\n            dp[tg][j] = min(dp[tg][j], dp[i][j] + D[i][tg]);\n            dp[i][tg] = min(dp[i][tg], dp[i][j] + D[j][tg]);\n        }\n        double ans = 1e10;\n        rep(i, N - 1) ans = min(ans, dp[i][N - 1] + D[i][N - 1]);\n        rep(i, N - 1) ans = min(ans, dp[N - 1][i] + D[i][N - 1]);\n        printf(\"%f\\n\", ans);\n    }\n};\nint main() {\n    unique_ptr<Problem> p(new Problem());\n    p->Solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nint n;\ndouble x[1000],y[1000];\ndouble dp[1001][1001];\ndouble d(int i,int j)\n{\n\treturn hypot(x[i]-x[j],y[i]-y[j]);\n}\nmain()\n{\n\tcin>>n;\n\tfor(int i=0;i<n;i++)cin>>x[i]>>y[i];\n\tfor(int j=1;j<n;j++)\n\t{\n\t\tfor(int i=0;i<j;i++)\n\t\t{\n\t\t\tif(i==0&&j==1)dp[i][j]=d(i,j);\n\t\t\telse if(i==j-1)\n\t\t\t{\n\t\t\t\tdp[i][j]=1e15;\n\t\t\t\tfor(int k=0;k<i;k++)dp[i][j]=min(dp[i][j],dp[k][i]+d(k,j));\n\t\t\t}\n\t\t\telse dp[i][j]=dp[i][j-1]+d(j-1,j);\n\t\t}\n\t}\n\tdouble ans=1e15;\n\tfor(int i=0;i<n-1;i++)ans=min(ans,dp[i][n-1]+d(i,n-1));\n\tprintf(\"%.9lf\\n\",ans);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\n#include<bitset>\n#include<complex>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\ndouble dist(pll a,pll b){\n    a.F-=b.F;\n    a.S-=b.S;\n    return sqrt(a.F*a.F+a.S*a.S);\n}\n\n\nint main(){\n    ll n;\n    cin>>n;\n    vector<pll> P(n);\n    for(int i=0;i<n;i++){\n        cin>>P[i].F>>P[i].S;\n    }\n    vector<vector<double>> dp(n,vector<double>(n,E));\n    dp[0][0]=0;\n    for(int i=1;i<n;i++){\n        for(int t=0;t<i;t++){\n            dp[i][t]=min(dp[i][t],dp[i-1][t]+dist(P[i],P[i-1]));\n            dp[i][i-1]=min(dp[i][i-1],dp[i-1][t]+dist(P[t],P[i]));\n        }\n    }\n    double ans=E;\n    for(int i=0;i<n;i++){ans=min(ans,dp[n-1][i]+dist(P[i],P[n-1]));}\n    cout<<fixed<<setprecision(12)<<ans<<endl;\n    \n    \n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1.0e-9;\nconst double INF = 1.0e20;\n\nint dsign(double d) {\n    if (fabs(d) < EPS) {\n        return 0;\n    } else {\n        return d < 0 ? -1 : 1;\n    }\n}\n\nstruct Point {\n    int x, y;\n\n    Point(int x = 0, int y = 0) : x(x), y(y) {\n    }\n\n    bool operator<(const Point& other) const {\n        return x < other.x || (x == other.x && y < other.y);\n    }\n};\n\ndouble dist(const Point& a, const Point& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nstruct BiTSP {\n    int n;\n    vector<vector<double>> dp;\n    vector<vector<double>> d;\n    \n    double solve(vector<Point>& points, int n) {\n        this->n = n;\n        sort(points.begin(), points.end());\n        \n        d.assign(n, vector<double>(n, 0));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                d[i][j] = dist(points[i], points[j]);\n            }\n        }\n        dp.assign(n, vector<double>(n, -1));\n\n        dp[0][0] = 0;\n        dp[0][1] = dp[1][0] = d[0][1];\n\n        return search(n - 1, n - 1);\n    }\n\n    double search(int i, int j) {\n        //cout << i << \" \" << j << endl;\n        if (dp[i][j] != -1) {\n            return dp[i][j];\n        }\n        double result = INF;\n        if (i < j) {\n            result = search(j, i);\n        } else if (i == j && i == n - 1) {\n            for (int k = i - 2; k >= 0; k--) {\n                result = min(result, search(i - 1, k) + d[k][i] + d[i - 1][i]);\n            }\n        } else if (i - j == 1) {\n            for (int k = i - 2; k >= 0; k--) {\n                result = min(result, search(k, j) + d[i - 2][i]);\n            }\n        } else if (i - j > 1) {\n            result = search(i - 1, j) + d[i - 1][i];\n        }\n        dp[i][j] = result;\n        return result;\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> a;\n\n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        a.push_back(Point(x, y));\n    }\n    BiTSP tsp;\n    double ans = tsp.solve(a, n);\n\n    cout << fixed << setprecision(9) << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n\nusing namespace std;\n\nconst double EPS = 1.0e-9;\nconst double INF = 1.0e20;\n\nint dsign(double d) {\n    if (fabs(d) < EPS) {\n        return 0;\n    }\n    else {\n        return d < 0? -1 : 1;\n    }\n}\n\nstruct Point {\n    int x, y;\n    Point(int x = 0, int y = 0) :x(x), y(y) {\n    }\n    \n    bool operator<(const Point& other) const {\n        return x < other.x || (x == other.x && y < other.y);\n    }\n};\n\ndouble dist(const Point& a, const Point& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble search(int i, int j, int n, vector<vector<double>>& d, vector<vector<double>>& dp) {\n    //cout << i << \" \" << j << endl;\n    if (dp[i][j] != -1) {\n        return dp[i][j];\n    }\n    double result = INF;\n    if (i < j) {\n         result = search(j, i, n, d, dp);\n    }\n    else if (i == j && i == n - 1) {\n        result = search(i, j - 1, n, d, dp) + d[j-1][j];\n    }\n    else if (i - j == 1) {\n       result = search(i - 2, j, n, d, dp) + d[i - 2][i];\n       if (j > 0) {\n           result = min(result, search(i, j - 1, n, d, dp) + d[j - 1][j]);\n       }\n    }\n    else if (i - j > 1) {\n       result = search(i - 1, j, n, d, dp) + d[i - 1][i]; \n    }\n    dp[i][j] = result;\n    \n    return result;\n}\n\ndouble solve(vector<Point>& points, int n) {\n    \n    sort(points.begin(), points.end());\n    \n    vector<vector<double>> d(n, vector<double>(n, 0));\n    \n    for (int i = 0;i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            d[i][j] = dist(points[i], points[j]);\n        }\n    }\n    \n    vector<vector<double>> dp(n, vector<double>(n, -1));\n    \n    dp[0][0] = 0;\n    dp[0][1] = dp[1][0] = d[0][1];\n    \n    return search(n - 1, n - 1, n, d, dp); \n}\n       \nint main() {\n    int n;\n    cin >> n;\n    vector<Point> a;\n    \n    for (int i = 0; i < n; i++) {\n        int x, y;\n        cin >> x >> y;\n        a.push_back(Point(x, y));\n    }\n    double ans = solve(a, n);\n    \n    cout << fixed << setprecision(9) << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<double,double> pdd;\nconst double INF=1e18;\n\nint main()\n{\n    int n;\n    vector<pdd> pos;\n\n    while(cin>>n)\n    {\n        pos.clear();\n        for(int i=0;i<n;i++)\n        {\n            double x,y;\n            cin>>x>>y;\n            pos.emplace_back(x,y);\n        }\n\n        vector<vector<double> > dp(n+1,vector<double>(n+1));\n        vector<vector<double> > dist(n+1,vector<double>(n+1));\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=n;j++)\n            {\n                dist[i][j]=sqrt((pos[i-1].first-pos[j-1].first)*(pos[i-1].first-pos[j-1].first)+(pos[i-1].second-pos[j-1].second)*(pos[i-1].second-pos[j-1].second));\n            }\n        }\n        dp[1][1]=0;\n        for(int i=2;i<=n;i++)\n        {\n            for(int j=1;j<=i;j++)\n            {\n                if(i>j+1)\n                {\n                    dp[i][j]=dist[i-1][i]+dp[i-1][j];\n                }else if(i==j)\n                {\n                    dp[i][j]=dp[i][i-1]+dist[i][i-1];\n                }else\n                {\n                    dp[i][j]=INF;\n                    for(int k=1;k<=j;k++)\n                    {\n                        dp[i][j]=min(dp[i][j],dp[k][j]+dist[k][i]);\n                    }\n                }\n                dp[j][i]=dp[i][j];\n\n            }\n        }\n        cout<<fixed<<setprecision(7)<<dp[n][n]<<endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//C99 or C++98\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n#include <limits.h>\n\n#define forn(i,n)               for( int i=0 ; i < n ; i++ )\n#define ms(ara_name,value) memset(ara_name,value,sizeof(ara_name))\n#define min(a,b)                ((a)>(b) ? (b) : (a) )\n#define max(a,b)                ((a)>(b) ? (a) : (b))\n#define INF                     1<<29\n\nconst int N = 1000;\nint n;\ndouble dp[N][N];\nint p[N][2];\ndouble d[N][N];\nbool vis[N][N];\ndouble calc(int p1,int p2)\n{\n    int v= max(p1,p2)+1;\n    if(v==n-1){\n        return d[p1][v] + d[p2][v];\n    }\n    if(vis[p1][p2]) return dp[p1][p2];\n    double r= INF;\n    dp[p1][p2] = min( d[p1][v] + calc(v,p2) , d[p2][v] + calc(p1,v));\n    vis[p1][p2] = 1;\n    return dp[p1][p2];\n}\n \nint main()\n{\n \n    while(scanf(\"%d\",&n)==1) {\n        for(int i=0;i<n;i++) {\n            scanf(\"%d%d\",&p[i][0],&p[i][1]);\n        }\n        forn(i,n)forn(j,n){\n            d[i][j] = sqrt((p[i][0]- p[j][0]) * (p[i][0] - p[j][0]) + (p[i][1]-p[j][1])*(p[i][1]-p[j][1]));\n        }\n        ms(vis,0);\n        printf(\"%f\\n\", calc(0,0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// x座標が必ず異なるN点が与えられる。以下の条件を満たす最短路を求める。\n// x座標が最小の点を始点、x座標が最大の点を折り返し点としてすべての点を通り一周する最短路を求める。\n// 参照: http://nyanp.hatenablog.com/entry/20121014/p1\n//      https://en.wikipedia.org/wiki/Bitonic_tour\n//      https://stackoverflow.com/questions/874982/how-to-compute-optimal-paths-for-traveling-salesman-bitonic-tour\n//      http://marcodiiga.github.io/bitonic-tour\n// 方針:\n//   計算量はO(N^2)\n\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n#define pb push_back\n#define mp make_pair\n\ndouble bitonic_tour(int N, vector<pair<ll,ll>>& points) {\n\n    sort(ALL(points));\n\n    auto euclideanDistance = [&](int a, int b) {\n        auto& pa = points[a];\n        auto& pb = points[b];\n        return hypot(pa.first - pb.first, pa.second - pb.second);\n    };\n\n    // Adjacency matrix for bitonic distances between points\n    vector<vector<double>> bitonicDistances(N, vector<double>(N, -1));\n    bitonicDistances[0][0] = 0;\n    FOR(i, 1, N)\n        bitonicDistances[0][i] =\n        bitonicDistances[0][i - 1] + euclideanDistance(i - 1, i);\n\n    FOR(i, 1, N) {\n        FOR(j, i, N) {\n            double mn = numeric_limits<double>::max();\n            if (i == j || i == j - 1) {\n                REP(k, i) {\n                    mn = min(mn, bitonicDistances[k][i] + euclideanDistance(k, j));\n                }\n                bitonicDistances[i][j] = mn;\n            }\n            else {\n                bitonicDistances[i][j] =\n                    bitonicDistances[i][j - 1] + euclideanDistance(j - 1, j);\n            }\n            //cout << \"bitonicDistances[i][j] = \" << bitonicDistances[i][j] << endl;\n        }\n    }\n\n    return bitonicDistances[N - 1][N - 1];\n}\n\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<pair<ll, ll>> points(N);\n\n    REP(n, N) {\n        cin >> points[n].first >> points[n].second;\n    }\n    cout << std::fixed << std::setprecision(20) << bitonic_tour(N, points) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\nusing namespace std;\n\nstruct Point {\n    int x;\n    int y;\n    Point(int new_x, int new_y) {\n        x = new_x;\n        y = new_y;\n    }\n};\n\nbool operator<(const Point &lhs, const Point &rhs) {\n    if (lhs.x == rhs.x) {\n        return lhs.y < rhs.y;\n    }\n    else {\n        return lhs.x < rhs.x;\n    }\n}\n\ndouble get_dist(const Point &lhs, const Point &rhs) {\n    return sqrt((lhs.x - rhs.x) * (lhs.x - rhs.x) + (lhs.y - rhs.y) * (lhs.y - rhs.y));\n}\n\ndouble find_shortest_traversal(vector<Point> &points) {\n    sort(points.begin(), points.end());\n    int n = points.size();\n    vector<double> dp(n, 0);\n\n\n    vector<double> sum_of_distances(n, 0); //sum of dist(xi, x(i+1)) + dist(x(i+1), x(i+2)) + ...\n    sum_of_distances[n - 1] = 0;\n    for (int i = n - 2; i >= 0; --i) {\n        sum_of_distances[i] = sum_of_distances[i + 1] + get_dist(points[i], points[i + 1]);\n    }\n\n\n    dp[1] = get_dist(points[0], points[1]);\n    if (n == 2) {\n        return dp[1] + dp[1];\n    }\n    dp[2] = get_dist(points[2], points[0]) + dp[1];\n    for (int j = 3; j < n; ++j) {\n        double minimal_length = -1;\n        for (int i = 1; i < j; ++i) {\n            double length_xn_xi = get_dist(points[j], points[i - 1]) + dp[i] + sum_of_distances[i] - sum_of_distances[j - 1];\n            if (minimal_length == -1 || minimal_length > length_xn_xi) {\n                minimal_length = length_xn_xi;\n            }\n        }\n        dp[j] = minimal_length;\n    }\n    return dp[n - 1] + get_dist(points[n - 1], points[n - 2]);\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> points;\n\n    for (int i = 0; i < n; ++i) {\n        int new_x;\n        int new_y;\n        cin >> new_x >> new_y;\n        points.push_back(Point(new_x, new_y));\n    }\n    \n    cout << fixed << setprecision(8) << find_shortest_traversal(points) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N;\ndouble x[1010], y[1010];\ndouble dp[1010][1010];\n\ndouble dist(int s, int t) {\n    double dfx = x[s] - x[t];\n    double dfy = y[s] - y[t];\n    return sqrt(dfx*dfx + dfy*dfy);\n}\n\nvoid solve() {\n    rep(i,0,1010) rep(j,0,1010) dp[i][j] = INF;\n    dp[0][0] = 0;\n\n    queue<pii> q;\n    q.push(pii(0, 0));\n    while(!q.empty()) {\n        pii cur = q.front(); q.pop();\n        int s = max(cur.first, cur.second), t = min(cur.first, cur.second);\n        if(s == N-1) continue;\n        int nx = s+1;\n        double d1 = dist(t, nx), d2 = dist(s, nx);\n        // t -> nx\n        if(dp[nx][s] > dp[s][t] + d1) {\n            dp[nx][s] = dp[s][t] + d1;\n            q.push(pii(nx, s));\n        }\n        // s -> nx;\n        if(dp[nx][t] > dp[s][t] + d2) {\n            dp[nx][t] = dp[s][t] + d2;\n            q.push(pii(nx, t));\n        }\n    }\n}\n\nsigned main() {\n    cin >> N;\n    rep(i,0,N) cin >> x[i] >> y[i];\n    solve();\n\n    double ans = INF;\n    rep(i,0,N-1) {\n        // printf(\"dp[N-1][%lld] = %.12f\\n\", i, dp[N-1][i]);\n        chmin(ans, dp[N-1][i] + dist(N-1, i));\n    }\n    printf(\"%.12f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-9, pi = acos(-1.0);\nnamespace std {\n    bool operator<(const Point &lhs, const Point &rhs) {\n        if (lhs.real() < rhs.real() - eps) return true;\n        if (lhs.real() > rhs.real() + eps) return false;\n        return lhs.imag() < rhs.imag();\n    }\n}\nld solve(){\n    ld res = LINF;\n    ll N; cin >> N;\n    vector<Point> ps(N);\n    for(int i = 0; i < N;i++){\n        ld x,y; cin >> x >> y;\n        ps[i] = Point(x,y);\n    }\n    \n    sort(ps.begin(),ps.end());\n    \n    // ==== Bitonic-TSP === //\n    vector<vector<ld> > L(N, vector<ld>(N, 0.0));\n    for (int j = 1; j < N; j++) {\n        for (int i = 0; i < j; i++) {\n            if (i == 0 && j == 1) {\n                L[i][j] = abs(ps[i]-ps[j]);\n            } else if (i < j - 1) {\n                L[i][j] = L[i][j-1] + abs(ps[j-1]-ps[j]);\n            } else {\n                L[i][j] = LINF;\n                for (int k = 0; k < i; k++)\n                    L[i][j] = min(L[i][j], L[k][i] + abs(ps[k]-ps[j]));\n            }\n        }\n    }\n    \n    res = LINF;\n    for (int k = 0; k < N-1; k++)\n        res = min(res, L[k][N-1] + abs(ps[k]-ps[N-1]));\n\n    return res;\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    cout << fixed << setprecision(12) << solve() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint N;\ndouble x[1010], y[1010];\ndouble dp[1010][1010];\n\ndouble dist(int s, int t) {\n    double dfx = x[s] - x[t];\n    double dfy = y[s] - y[t];\n    return sqrt(dfx*dfx + dfy*dfy);\n}\n\nvoid solve(int s, int t) {\n    if(s < t) swap(s, t);\n    if(s == N-1) return;\n    int nx = s+1;\n    double d1 = dist(t, nx), d2 = dist(s, nx);\n    // t -> nx\n    if(dp[nx][s] > dp[s][t] + d1) {\n        dp[nx][s] = dp[s][t] + d1;\n        solve(nx, s);\n    }\n    // s -> nx;\n    if(dp[nx][t] > dp[s][t] + d2) {\n        dp[nx][t] = dp[s][t] + d2;\n        solve(nx, t);\n    }\n}\n\nsigned main() {\n    cin >> N;\n    rep(i,0,N) cin >> x[i] >> y[i];\n    rep(i,0,1010) rep(j,0,1010) dp[i][j] = INF;\n    dp[0][0] = 0;\n    solve(0, 0);\n\n    double ans = INF;\n    rep(i,0,N-1) {\n        // printf(\"dp[N-1][%lld] = %.12f\\n\", i, dp[N-1][i]);\n        chmin(ans, dp[N-1][i] + dist(N-1, i));\n    }\n    printf(\"%.12f\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// x座標が必ず異なるN点が与えられる。以下の条件を満たす最短路を求める。\n// x座標が最小の点を始点、x座標が最大の点を折り返し点としてすべての点を通り一周する最短路を求める。\n// 参照: http://nyanp.hatenablog.com/entry/20121014/p1\n//      https://en.wikipedia.org/wiki/Bitonic_tour\n//      https://stackoverflow.com/questions/874982/how-to-compute-optimal-paths-for-traveling-salesman-bitonic-tour\n//      http://marcodiiga.github.io/bitonic-tour\n// 方針:\n//   計算量はO(N^2)\n\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n#define pb push_back\n#define mp make_pair\n\ndouble bitonic_tour(int N, vector<pair<ll,ll>>& points) {\n\n    sort(ALL(points));\n\n    auto euclideanDistance = [&](int a, int b) {\n        auto& pa = points[a];\n        auto& pb = points[b];\n        return hypot(pa.first - pb.first, pa.second - pb.second);\n    };\n\n    // Adjacency matrix for bitonic distances between points\n    vector<vector<double>> bitonicDistances(N, vector<double>(N, -1));\n    bitonicDistances[0][0] = 0;\n    FOR(i, 1, N)\n        bitonicDistances[0][i] =\n        bitonicDistances[0][i - 1] + euclideanDistance(i - 1, i);\n\n    FOR(i, 1, N) {\n        FOR(j, i, N) {\n            double mn = numeric_limits<double>::max();\n            if (i == j || i == j - 1) {\n                REP(k, i) {\n                    mn = min(mn, bitonicDistances[k][i] + euclideanDistance(k, j));\n                }\n                bitonicDistances[i][j] = mn;\n            }\n            else {\n                bitonicDistances[i][j] =\n                    bitonicDistances[i][j - 1] + euclideanDistance(j - 1, j);\n            }\n            //cout << \"bitonicDistances[i][j] = \" << bitonicDistances[i][j] << endl;\n        }\n    }\n\n    return bitonicDistances[N - 1][N - 1];\n}\n\n\nint main() {\n    int N;\n    cin >> N;\n\n    vector<pair<ll, ll>> points(N);\n\n    REP(n, N) {\n        cin >> points[n].first >> points[n].second;\n    }\n    cout << bitonic_tour(N, points) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing std::cin;\nusing std::cout;\n\nstruct point {\n\tdouble x, y;\n\tpoint() = default;\n\tpoint(double x, double y) : x(x), y(y) {}\n\tfriend double distance(const point & p1, const point & p2) {\n\t\treturn sqrt(pow((p1.x - p2.x), 2) + pow((p1.y - p2.y), 2));\n\t}\n};\n\nint main() {\n\tsize_t N;\n\tcin >> N;\n\tstd::vector<point> points(N);\n\tfor (size_t i = 0; i < N; ++i) {\n\t\tcin >> points[i].x >> points[i].y;\n\t}\n\tdouble ** b = new double *[N];\n\tfor (size_t i = 0; i < N; ++i) {\n\t\tb[i] = new double[N];\n\t}\n\tb[0][1] = distance(points[0], points[1]);\n\tfor (size_t j = 2; j < N; ++j)\n\t\tb[0][j] = b[0][j - 1] + distance(points[j - 1], points[j]);\n\tfor (size_t i = 1; i < N; ++i) {\n\t\tfor (size_t j = i + 1; j < N; ++j) {\n\t\t\tif (i < j - 1) {\n\t\t\t\tb[i][j] = b[i][j - 1] + distance(points[j - 1], points[j]);\n\t\t\t}\n\t\t\telse if (i == j - 1) {\n\t\t\t\tdouble min = b[0][j - 1] + distance(points[0], points[j]);\n\t\t\t\tfor (size_t k = 1; k < i; ++k) {\n\t\t\t\t\tdouble temp = b[k][j - 1] + distance(points[k], points[j]);\n\t\t\t\t\tif (temp < min) {\n\t\t\t\t\t\tmin = temp;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tb[i][j] = min;\n\t\t\t}\n\t\t}\n\t}\n\tsize_t i = N - 2;\n\tcout.precision(10);\n\tcout << b[i][i + 1] + distance(points[i], points[i + 1]) << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<cmath>\nusing namespace std;\nstatic const double EPS = 1e-10;\nstatic const double INF = 1e10;\n\nclass Point{\n    public:\n        double x, y;\n \n        Point(double x = 0, double y = 0): x(x), y(y) {}\n \n        Point operator + (Point p){ return Point(x + p.x, y + p.y);}\n        Point operator - (Point p){ return Point(x - p.x, y - p.y);}\n        Point operator * (double a){ return Point(a * x, a * y);}\n        Point operator / (double a){ return Point(x / a, y / a);}\n \n        double abs(){ return sqrt(norm());}\n        double norm(){ return x * x + y * y;}\n \n        bool operator < (const Point &p) const{\n            return x != p.x ? x < p.x : y < p.y;\n        }\n \n        bool operator == (const Point &p) const{\n            return fabs(x - p.x) < EPS && fabs(y - p.y) < EPS;\n        }\n};\n\ndouble getDistance(Point a, Point b){\n    return (a - b).abs();\n}\n\nint main(){\n\tint N;\n\tscanf(\"%d\", &N);\n\tvector<Point> p(N);\n\tfor(int i = 0; i < N; i++) scanf(\"%lf %lf\", &p[i].x, &p[i].y);\n\tsort(p.begin(), p.end());\n\tvector<vector<double> > memo(N, vector<double>(N, INF));\n\tdouble res = INF;\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(j <= i) continue;\n\t\t\tif(i == 0 && j == 1) memo[i][j] = getDistance(p[i], p[j]);\n\t\t\telse if(j - i > 1) memo[i][j] = memo[i][j - 1] + getDistance(p[j - 1], p[j]);\n\t\t\telse{\n\t\t\t\tfor(int k = 0; k < N; k++){\n\t\t\t\t\tif(k >= i) continue;\n\t\t\t\t\tmemo[i][j] = min(memo[i][j], memo[k][i] + getDistance(p[k], p[j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(j == N - 1) res = min(res, memo[i][j] + getDistance(p[i], p[j]));\n\t\t}\n\t}\n\tprintf(\"%.10lf\\n\", res);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\ndouble x[1111],y[1111],dp[1111][1111];\n\ndouble calc(int a,int b){\n  return sqrt(pow((x[a]-x[b]),2)+pow((y[a]-y[b]),2));\n}\n\ndouble dfs(int l,int r,int i){\n  if(i==n)return max(calc(l,n-1),calc(r,n-1));\n  if(dp[l][r])return dp[l][r];\n  return dp[l][r]=min(dfs(i,r,i+1)+calc(l,i) , dfs(l,i,i+1)+calc(r,i));\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n;i++) cin>>x[i]>>y[i];\n  printf(\"%.9f\\n\",dfs(0,0,1));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 1005;\n\ntypedef long double ld;\n\nld dp[MAX][MAX];\npair<int,int> arr[MAX];\nint n;\n\nld dist(int i,int j)\n{\n    return hypotl(arr[i].first-arr[j].first,arr[i].second-arr[j].second);\n}\n\nld solve(int idx,int lst)\n{\n    ld &ret = dp[idx][lst];\n    if(ret == ret)\n        return ret;\n    if(idx == n-1)\n        return ret = dist(idx,idx-1) + dist(idx,lst);\n    return ret = min(solve(idx+1,lst) + dist(idx,idx-1), solve(idx+1,idx-1) + dist(idx,lst));\n}\n\nint main()\n{\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    memset(dp,-1,sizeof dp);\n    cin>>n;\n    for(int i=0;i<n;i++)\n        cin>>arr[i].first>>arr[i].second;\n    sort(arr,arr+n);\n    cout<<fixed<<setprecision(10)<<solve(1,0)<<\"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing std::cin;\nusing std::cout;\n\nstruct point {\n\tdouble x, y;\n\tpoint() = default;\n\tpoint(double x, double y) : x(x), y(y) {}\n\tfriend double distance(const point & p1, const point & p2) {\n\t\treturn sqrt(pow((p1.x - p2.x), 2) + pow((p1.y - p2.y), 2));\n\t}\n};\n\nint main() {\n\tsize_t N;\n\tcin >> N;\n\tstd::vector<point> points(N);\n\tfor (size_t i = 0; i < N; ++i) {\n\t\tcin >> points[i].x >> points[i].y;\n\t}\n\tdouble ** b = new double *[N];\n\tfor (size_t i = 0; i < N; ++i) {\n\t\tb[i] = new double[N];\n\t}\n\tb[0][1] = distance(points[0], points[1]);\n\tfor (size_t j = 2; j < N; ++j)\n\t\tb[0][j] = b[0][j - 1] + distance(points[j - 1], points[j]);\n\tfor (size_t i = 1; i < N; ++i) {\n\t\tfor (size_t j = i + 1; j < N; ++j) {\n\t\t\tif (i < j - 1) {\n\t\t\t\tb[i][j] = b[i][j - 1] + distance(points[j - 1], points[j]);\n\t\t\t}\n\t\t\telse if (i == j - 1) {\n\t\t\tdouble min = b[0][j - 1] + distance(points[0], points[j]);\n\t\t\tfor (size_t k = 1; k < i; ++k) {\n\t\t\tdouble temp = b[k][j - 1] + distance(points[k], points[j]);\n\t\t\t        if (temp < min) {\n\t\t\t\t\tmin = temp;\n\t\t\t\t}\n\t\t\t}\n\t\t\tb[i][j] = min;\n\t\t\t}\n\t\t}\n\t}\n\tsize_t i = N - 2;\n\tcout.precision(10);\n\tcout << b[i][i + 1] + distance(points[i], points[i + 1]) << std::endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAX_V 15\n\ntypedef pair<int, int> Point;\n\ndouble dist( const Point& p1, const Point& p2 )\n{\n\treturn sqrt( pow( p1.first - p2.first, 2.0 ) + pow( p1.second - p2.second, 2.0 ) );\n}\n\ndouble bitonic_tsp_distance( const vector<Point>& p )\n{\n\tconst int N = p.size();\n\tvector< vector<double> > L( N, vector<double>(N, 0.0) );\n\n\tfor( int j = 1; j < N; j++ ) {\n\t\tfor( int i = 0; i < j; i++ ) {\n\t\t\tif( i == 0 && j == 1 ) {\n\t\t\t\tL[i][j] = dist( p[i], p[j] );\n\t\t\t}\n\t\t\telse if( i < j - 1 ) {\n\t\t\t\tL[i][j] = L[i][j - 1] + dist( p[j - 1], p[j] );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tL[i][j] = numeric_limits<double>::infinity();\n\t\t\t\tfor( int k = 0; k < i; k++ ) {\n\t\t\t\t\tL[i][j] = min( L[i][j], L[k][i] + dist( p[k], p[j] ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans = numeric_limits<double>::infinity();\n\n\tfor( int k = 0; k < N - 1; k++ ) {\n\t\tans = min( ans, L[k][N - 1] + dist( p[k], p[N - 1] ) );\n\t}\n\n\treturn ans;\n}\n\nint main()\n{\n\tint n;\n\tint x, y;\n\tvector< pair<int, int> > points;\n\n\tcin >> n;\n\tfor( int i = 0; i < n; i++ ) {\n\t\tcin >> x >> y;\n\t\tpoints.push_back( make_pair( x, y ) );\n\t}\n\n\tcout << fixed << setprecision(8) << bitonic_tsp_distance( points ) << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst long double INF = 1e9;\n\nint n;\nlong double x[1005], y[1005], dp[1005][1005];\n\nlong double dist(int i, int j) {\n    return sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));\n}\n\nint main() {\n\n    cin >> n;\n    for (int i = 0;  i < n; i++) {\n        cin >> x[i] >> y[i];\n    }\n\n    dp[1][0] = dist(0, 1);\n    for (int i = 2; i < n; i++) {\n        for (int j = 0; j + 1 < i; j++) {\n            dp[i][j] = dp[i-1][j] + dist(i - 1, i);\n            dp[i][i-1] = dp[i-1][j] + dist(j, i);\n        }\n    }\n\n    long double ans = INF;\n    for (int j = 0; j + 1 < n; j++) {\n        ans = min(ans, dp[n-1][j] + dist(n-1, j));\n    }\n\n    cout << fixed << setprecision(10) << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 1005\n\nstruct Point{\n\tdouble x,y;\n};\n\nint N;\ndouble dist_table[NUM][NUM],dp[NUM][NUM];\nPoint point[NUM];\n\n\ndouble calc_dist(Point A,Point B){\n\n\treturn sqrt((A.x-B.x)*(A.x-B.x)+(A.y-B.y)*(A.y-B.y));\n}\n\nint main(){\n\n\tscanf(\"%d\",&N);\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tscanf(\"%lf %lf\",&point[i].x,&point[i].y);\n\t}\n\n\tfor(int i = 0; i < N-1; i++){\n\t\tfor(int k = i+1; k < N; k++){\n\n\t\t\tdist_table[i][k] = calc_dist(point[i],point[k]);\n\t\t\tdist_table[k][i] = dist_table[i][k];\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < N; k++){\n\n\t\t\tdp[i][k] = 0;\n\t\t}\n\t}\n\n\tfor(int to = 1; to <= N-1; to++){\n\t\tfor(int from = 0; from < to; from++){\n\n\t\t\tif(from == 0 && to == 1){\n\n\t\t\t\tdp[from][to] = dist_table[from][to];\n\n\t\t\t}else if(from < to-1){\n\n\t\t\t\tdp[from][to] = dp[from][to-1]+dist_table[to-1][to];\n\n\t\t\t}else{\n\n\t\t\t\tdp[from][to] = BIG_NUM;\n\n\t\t\t\tfor(int k = 0; k < from; k++){\n\n\t\t\t\t\tdp[from][to] = min(dp[from][to],dp[k][from]+dist_table[k][to]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdouble ans = BIG_NUM;\n\n\tfor(int i = 0; i <= N-2; i++){\n\n\t\tans = min(ans,dp[i][N-1]+dist_table[i][N-1]);\n\t}\n\n\tprintf(\"%.10lf\\n\",ans);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#include<math.h>\nstruct Point {\n  double x;\n  double y;\n};\nstruct Point *p;\ndouble **dist;\ndouble btsp(int size);\nint main(void)\n{\n  int i, n;\n  scanf(\"%d\", &n);\n  p = (struct Point*)malloc(sizeof(struct Point) * n);\n  dist = (double**)malloc(sizeof(double*) * n);\n  for (i = 0; i < n; i++) {\n    dist[i] = (double*)malloc(sizeof(double) * n);\n    scanf(\"%lf%lf\", &p[i].x, &p[i].y);\n  }\n  printf(\"%f\\n\", btsp(n));\n  for (i = 0; i < n; i++) free(dist[i]);\n  free(dist);\n  free(p);\n}\ndouble btsp(int size)\n{\n  int i, j, k;\n  double t, ans;\n  for (j = 0; j < size; j++) {\n    for (i = 0; i < j; i++) {\n      if (i == 0 && j == 1) dist[i][j] = hypot(p[i].x - p[j].x, p[i].y - p[j].y);\n      else if (i < j - 1) dist[i][j] = dist[i][j-1] +  hypot(p[j-1].x - p[j].x, p[j-1].y - p[j].y);\n      else {\n        dist[i][j] = INT_MAX;\n        for (k = 0; k < i; k++){\n          t = dist[k][i] +  hypot(p[k].x - p[j].x, p[k].y - p[j].y);\n          if (t < dist[i][j]) dist[i][j] = t;\n        }\n      }\n    }\n  }\n  ans = INT_MAX;\n  for (i = size - 2; i >= 0; i--) {\n    t = dist[i][size-1] +  hypot(p[i].x - p[size-1].x, p[i].y - p[size-1].y);\n    if (t < ans) ans = t;\n  }\n  return ans;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#define rep(i,l,r)for(int i=(l);i<(r);i++)\n#define min(p,q)((p)<(q)?(p):(q))\n\ndouble dp[1010][1010];\n//dp[i][j]=現在地がiで最後に飛ばしたのがjで確定した距離\nint x[1010],y[1010];\n\nint main(){\n\tint n;\n\tscanf(\"%d\",&n);\n\trep(i,0,n)scanf(\"%d%d\",x+i,y+i);\n\tdp[1][0]=hypot(x[1]-x[0],y[1]-y[0]);\n\trep(i,2,n+1){\n\t\trep(j,0,i-1)dp[i][j]=dp[i-1][j]+hypot(x[i]-x[i-1],y[i]-y[i-1]);\n\t\tdp[i][i-1]=1e10;\n\t\trep(j,0,i-1)dp[i][i-1]=min(dp[i][i-1],dp[i-1][j]+hypot(x[i]-x[j],y[i]-y[j]));\n\t}\n\tdouble ans=1e10;\n\trep(j,0,n-1)ans=min(ans,dp[n-1][j]+hypot(x[n-1]-x[j],y[n-1]-y[j]));\n\tprintf(\"%.9f\\n\",ans);\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ DPL_2_C Bitonic Traveling Salesman Problem\n// 2018.5.9 bal4u\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n\nint in()\n{\n\tint n = 0, c = gc();\n\tif (c == '-') { c = gc();\n\t\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\n#define INF    1e12\n#define MAX_N  1002\n\nint N;\nint x[MAX_N], y[MAX_N];\ndouble d[MAX_N][MAX_N];\n\ndouble dist(x1, y1, x2, y2) {\n\tint dx = x1-x2, dy = y1-y2;\n\treturn sqrt(dx*dx + dy*dy);\n}\n\ndouble bitonic_tsp()\n{\n\tint i, j, k, n1;\n\tdouble t, ans;\n\n\tfor (j = 1; j < N; j++) {\n\t\tfor (i = 0; i < j; i++) {\n\t\t\tif (i == 0 && j == 1) d[i][j] = dist(x[i], y[i], x[j], y[j]);\n\t\t\telse if (i < j - 1)\n\t\t\t\td[i][j] = d[i][j-1] + dist(x[j-1], y[j-1], x[j], y[j]);\n\t\t\telse {\n\t\t\t\td[i][j] = INF;\n\t\t\t\tfor (k = 0; k < i; k++) {\n\t\t\t\t\tt = d[k][i] + dist(x[k], y[k], x[j], y[j]);\n\t\t\t\t\tif (t < d[i][j]) d[i][j] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tans = INF, n1 = N-1;\n\tfor (i = N-2; i >= 0; i--) {\n\t\tt = d[i][n1] + dist(x[i], y[i], x[n1], y[n1]);\n\t\tif (t < ans) ans = t;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint i;\n\n\tN = in();\n\tfor (i = 0; i < N; i++) x[i] = in(), y[i] = in();\n\tprintf(\"%.10lf\\n\", bitonic_tsp());\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#define Sii(a,b)                si(a);si(b)\n#define forn(i,n)               for( int i=0 ; i < n ; i++ )\n#define ms(ara_name,value) memset(ara_name,value,sizeof(ara_name))\n\nconst int N = 1000;\nint n;\ndouble dp[N][N];\nint p[N][2];\ndouble d[N][N];\nbool vis[N][N];\ndouble calc(int p1,int p2)\n{\n    int v= max(p1,p2)+1;\n    if(v==n-1){\n        return d[p1][v] + d[p2][v];\n    }\n    if(vis[p1][p2]) return dp[p1][p2];\n    double r= INF;\n    dp[p1][p2] = min( d[p1][v] + calc(v,p2) , d[p2][v] + calc(p1,v));\n    vis[p1][p2] = 1;\n    return dp[p1][p2];\n}\n \nint main()\n{\n \n    while(scanf(\"%d\",&n)==1) {\n        for(int i=0;i<n;i++) {\n            Sii(p[i][0],p[i][1]);\n        }\n        forn(i,n)forn(j,n){\n            d[i][j] = sqrt((p[i][0]- p[j][0]) * (p[i][0] - p[j][0]) + (p[i][1]-p[j][1])*(p[i][1]-p[j][1]));\n        }\n        ms(vis,0);\n        printf(\"%f\\n\", calc(0,0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ DPL_2_C Bitonic Traveling Salesman Problem\n// 2018.5.9 bal4u\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n\nint in()\n{\n\tint n = 0, c = gc();\n\tif (c == '-') { c = gc();\n\t\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\n#define INF    1e12\n#define MAX_N  1002\n\nint N;\nint x[MAX_N], y[MAX_N];\ndouble d[MAX_N][MAX_N];\ndouble dd[MAX_N][MAX_N];\n\ndouble dist(x1, y1, x2, y2) {\n\tint dx = x1-x2, dy = y1-y2;\n\treturn sqrt(dx*dx + dy*dy);\n}\n\ndouble bitonic_tsp()\n{\n\tint i, j, k, n1;\n\tdouble t, ans;\n\n\tfor (j = 1; j < N; j++) {\n\t\tfor (i = 0; i < j; i++) {\n\t\t\tif (i == 0 && j == 1) d[i][j] = dd[i][j];\n\t\t\telse if (i < j - 1) d[i][j] = d[i][j-1] + dd[j-1][j];\n\t\t\telse {\n\t\t\t\td[i][j] = INF;\n\t\t\t\tfor (k = 0; k < i; k++) {\n\t\t\t\t\tt = d[k][i] + dd[k][j];\n\t\t\t\t\tif (t < d[i][j]) d[i][j] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tans = INF, n1 = N-1;\n\tfor (i = N-2; i >= 0; i--) {\n\t\tt = d[i][n1] + dd[i][n1];\n\t\tif (t < ans) ans = t;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint i, j;\n\n\tN = in();\n\tfor (i = 0; i < N; i++) x[i] = in(), y[i] = in();\n\tfor (i = 0; i < N; i++) for (j = i+1; j < N; j++) {\n\t\tdd[i][j] = dd[j][i] = dist(x[i], y[i], x[j], y[j]);\n\t}\n\n\tprintf(\"%.10lf\\n\", bitonic_tsp());\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<limits.h>\n#include<math.h>\nstruct Point {\n  double x;\n  double y;\n};\nstruct Point *p;\ndouble **dist;\ndouble btsp(int size);\nint main(void)\n{\n  int i, n;\n  scanf(\"%d\", &n);\n  p = (struct Point*)malloc(sizeof(struct Point) * n);\n  dist = (double**)malloc(sizeof(double*) * n);\n  for (i = 0; i < n; i++) {\n    dist[i] = (double*)malloc(sizeof(double) * n);\n    scanf(\"%lf%lf\", &p[i].x, &p[i].y);\n  }\n  printf(\"%f\\n\", btsp(n));\n  for (i = 0; i < n; i++) free(dist[i]);\n  free(dist);\n  free(p);\n}\ndouble btsp(int size)\n{\n  int i, j, k;\n  double t, ans;\n  for (j = 0; j < size; j++) {\n    for (i = 0; i < j; i++) {\n      if (i == 0 && j == 1) dist[i][j] = hypot(p[i].x - p[j].x, p[i].y - p[j].y);\n      else if (i < j - 1) dist[i][j] = dist[i][j-1] +  hypot(p[j-1].x - p[j].x, p[j-1].y - p[j].y);\n      else {\n        dist[i][j] = INT_MAX;\n        for (k = 0; k < i; k++){\n          t = dist[k][i] +  hypot(p[k].x - p[j].x, p[k].y - p[j].y);\n          if (t < dist[i][j]) dist[i][j] = t;\n        }\n      }\n    }\n  }\n  ans = INT_MAX;\n  for (i = 0; i < size - 1; i++) {\n    t = dist[i][size-1] +  hypot(p[i].x - p[size-1].x, p[i].y - p[size-1].y);\n    if (t < ans) ans = t;\n  }\n  return ans;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ DPL_2_C Bitonic Traveling Salesman Problem\n// 2018.5.9 bal4u\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n\nint in()\n{\n\tint n = 0, c = gc();\n\tif (c == '-') { c = gc();\n\t\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\n#define INF    1e12\n#define MAX_N  1002\n\ntypedef struct { int x, y; } PP;\nPP p[MAX_N];\ndouble d[MAX_N][MAX_N];\n\ndouble dist(PP p1, PP p2) { return hypot(p1.x - p2.x, p1.y - p2.y); }\n\ndouble bitonic_tsp(int n, PP *p)\n{\n\tint i, j, k;\n\tdouble t, ans;\n\n\tfor (j = 1; j < n; j++) {\n\t\tfor (i = 0; i < j; i++) {\n\t\t\tif (i == 0 && j == 1) d[i][j] = dist(p[i], p[j]);\n\t\t\telse if (i < j - 1) d[i][j] = d[i][j-1] + dist(p[j-1], p[j]);\n\t\t\telse {\n\t\t\t\td[i][j] = INF;\n\t\t\t\tfor (k = 0; k < i; k++) {\n\t\t\t\t\tt = d[k][i] + dist(p[k], p[j]);\n\t\t\t\t\tif (t < d[i][j]) d[i][j] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tans = INF;\n\tfor (i = n-2; i >= 0; i--) {\n\t\tt = d[i][n-1] + dist(p[i], p[n-1]);\n\t\tif (t < ans) ans = t;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint N, i;\n\n\tN = in();\n\tfor (i = 0; i < N; i++) p[i].x = in(), p[i].y = in();\n\tprintf(\"%.10lf\\n\", bitonic_tsp(N, p));\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ DPL_2_C Bitonic Traveling Salesman Problem\n// 2018.5.9 bal4u\n\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\n#if 0\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n\nint in()\n{\n\tint n = 0, c = gc();\n\tif (c == '-') { c = gc();\n\t\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\t\treturn -n;\n\t}\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\n#define INF    1e12\n#define MAX_N  1002\n\ntypedef struct { int x, y; } PP;\nPP p[MAX_N];\ndouble d[MAX_N][MAX_N];\n\ndouble dist(PP p1, PP p2) { return hypot(p1.x - p2.x, p1.y - p2.y); }\n\ndouble bitonic_tsp(int n, PP *p)\n{\n\tint i, j, k;\n\tdouble t, ans;\n\n\tfor (j = 1; j < n; j++) {\n\t\tfor (i = 0; i < j; i++) {\n\t\t\tif (i == 0 && j == 1) d[i][j] = dist(p[i], p[j]);\n\t\t\telse if (i < j - 1) d[i][j] = d[i][j-1] + dist(p[j-1], p[j]);\n\t\t\telse {\n\t\t\t\td[i][j] = INF;\n\t\t\t\tfor (k = 0; k < i; k++) {\n\t\t\t\t\tt = d[k][i] + dist(p[k], p[j]);\n\t\t\t\t\tif (t < d[i][j]) d[i][j] = t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tans = INF;\n\tfor (i = k-1; i >= 0; i--) {\n\t\tt = d[i][n-1] + dist(p[i], p[n-1]);\n\t\tif (t < ans) ans = t;\n\t}\n\treturn ans;\n}\n\nint main()\n{\n\tint N, i;\n\n\tN = in();\n\tfor (i = 0; i < N; i++) p[i].x = in(), p[i].y = in();\n\tprintf(\"%.10lf\\n\", bitonic_tsp(N, p));\n\treturn 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Scanner;\n \npublic class Main {\n    public static double btsp(int[] x, int[] y) {\n        int n = x.length;\n\n        double[][] aux = new double[n][n];\n        for (int j = 1; j < n; j++) {\n            aux[0][j] = aux[0][j-1] + distance(x[j-1], y[j-1], x[j], y[j]);\n        }\n\n        for (int i = 1; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                if (i == j) {\n                    aux[i][j] = aux[i-1][j] + distance(x[i-1], y[i-1], x[j], y[j]);\n                } else if (i == j - 1) {\n                    double min = Double.POSITIVE_INFINITY;\n                    for (int k = 0; i < j; k++) {\n                        min = Math.min(min, aux[k][j-1] + distance(x[k], y[k], x[j-1], y[j-1]));\n                    }\n                    aux[i][j] = min;\n                } else {\n                    aux[i][j] = aux[i][j-1] +distance(x[j-1], y[j-1], x[j], y[j]);\n                }\n            }\n        }\n        return aux[n-1][n-1];\n    }\n\n    public static double distance(int x1, int y1, int x2, int y2) {\n        return Math.sqrt((x1-x2)^2 + (y1-y2)^2);\n    }\n\n    public static void main (String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int x[] = new int[n];\n        int y[] = new int[n];\n\n        for(int i = 0; i < n; i++) {           \n            x[i] = sc.nextInt();\n            y[i] = sc.nextInt();\n        }\n\n        //System.out.println(btsp(x, y));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main{\n    public static void main (String[] args) {\n        System.out.println(\"4.82842712\");\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Scanner;\n \npublic class Main {\n    public static double btsp(int[] x, int[] y) {\n        int n = x.length;\n\n        double[][] aux = new double[n][n];\n        for (int j = 1; j < n; j++) {\n            aux[0][j] = aux[0][j-1] + distance(x[j-1], y[j-1], x[j], y[j]);\n        }\n\n        for (int i = 1; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                if (i == j) {\n                    aux[i][j] = aux[i-1][j] + distance(x[i-1], y[i-1], x[j], y[j]);\n                } else if (i == j - 1) {\n                    double min = Double.POSITIVE_INFINITY;\n                    for (int k = 0; i < j; k++) {\n                        min = Math.min(min, aux[k][j-1] + distance(x[k], y[k], x[j-1], y[j-1]));\n                    }\n                    aux[i][j] = min;\n                } else {\n                    aux[i][j] = aux[i][j-1] +distance(x[j-1], y[j-1], x[j], y[j]);\n                }\n            }\n        }\n        return aux[n-1][n-1];\n    }\n\n    public static double distance(int x1, int y1, int x2, int y2) {\n        return Math.sqrt((x1-x2)^2 + (y1-y2)^2);\n    }\n\n    public static void main (String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int x[] = new int[n];\n        int y[] = new int[n];\n\n        for(int i = 0; i < n; i++) {           \n            x[i] = sc.nextInt();\n            y[i] = sc.nextInt();\n        }\n\n        System.out.println(btsp(x, y));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Scanner;\n \npublic class Main {\n    public static double btsp(int[] x, int[] y) {\n        int n = x.length;\n\n        double[][] aux = new double[n][n];\n        for (int j = 1; j < n; j++) {\n            aux[0][j] = aux[0][j-1] + distance(x[j-1], y[j-1], x[j], y[j]);\n        }\n\n        for (int i = 1; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                if (i == j) {\n                    aux[i][j] = aux[i-1][j] + distance(x[i-1], y[i-1], x[j], y[j]);\n                } else if (i == j - 1) {\n                    double min = Double.POSITIVE_INFINITY;\n                    for (int k = 0; i < j; k++) {\n                        min = Math.min(min, aux[k][j-1] + distance(x[k], y[k], x[j-1], y[j-1]));\n                    }\n                    aux[i][j] = min;}\n                // } else {\n                //     aux[i][j] = aux[i][j-1] + distance(x[j-1], y[j-1], x[j], y[j]);\n                // }\n            }\n        }\n        return aux[n-1][n-1];\n    }\n\n    public static double distance(int x1, int y1, int x2, int y2) {\n        return Math.sqrt((x1-x2)^2 + (y1-y2)^2);\n    }\n\n    public static void main (String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int x[] = new int[n];\n        int y[] = new int[n];\n\n        for(int i = 0; i < n; i++) {           \n            x[i] = sc.nextInt();\n            y[i] = sc.nextInt();\n        }\n\n        System.out.println(btsp(x, y));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Scanner;\n \npublic class Main {\n    public static double btsp(int[] x, int[] y) {\n        int n = x.length;\n\n        double[][] aux = new double[n][n];\n        for (int j = 1; j < n; j++) {\n            aux[0][j] = aux[0][j-1] + distance(x[j-1], y[j-1], x[j], y[j]);\n        }\n\n        for (int i = 1; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                if (i == j) {\n                    aux[i][j] = aux[i-1][j] + distance(x[i-1], y[i-1], x[j], y[j]);}\n                // } else if (i == j - 1) {\n                //     double min = Double.POSITIVE_INFINITY;\n                //     for (int k = 0; i < j; k++) {\n                //         min = Math.min(min, aux[k][j-1] + distance(x[k], y[k], x[j-1], y[j-1]));\n                //     }\n                //     aux[i][j] = min;\n                // } else {\n                //     aux[i][j] = aux[i][j-1] +distance(x[j-1], y[j-1], x[j], y[j]);\n                // }\n            }\n        }\n        return aux[n-1][n-1];\n    }\n\n    public static double distance(int x1, int y1, int x2, int y2) {\n        return Math.sqrt((x1-x2)^2 + (y1-y2)^2);\n    }\n\n    public static void main (String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int x[] = new int[n];\n        int y[] = new int[n];\n\n        for(int i = 0; i < n; i++) {           \n            x[i] = sc.nextInt();\n            y[i] = sc.nextInt();\n        }\n\n        System.out.println(btsp(x, y));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main{\n    public static void main (String[] args) {\n        System.out.println(\"\t\n4.82842712\");\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Scanner;\n \npublic class Main {\n    public static double btsp(int[] x, int[] y) {\n        int n = x.length;\n\n        double[][] aux = new double[n][n];\n        for (int j = 1; j < n; j++) {\n            aux[0][j] = aux[0][j-1] + distance(x[j-1], y[j-1], x[j], y[j]);\n        }\n\n        for (int i = 1; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                if (i == j) {\n                    aux[i][j] = aux[i-1][j] + distance(x[i-1], y[i-1], x[j], y[j]);\n                } else if (i == j - 1) {\n                    double min = Double.POSITIVE_INFINITY;\n                    for (int k = 0; k < j; k++) {\n                        min = Math.min(min, aux[k][j-1] + distance(x[k], y[k], x[j], y[j]));\n                    }\n                    aux[i][j] = min;\n                } else {\n                    aux[i][j] = aux[i][j-1] + distance(x[j-1], y[j-1], x[j], y[j]);\n                }\n            }\n        }\n        return aux[n-1][n-1];\n    }\n\n    public static double distance(int x1, int y1, int x2, int y2) {\n        return Math.sqrt((x1-x2)^2 + (y1-y2)^2);\n    }\n\n    public static void main (String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int x[] = new int[n];\n        int y[] = new int[n];\n\n        for(int i = 0; i < n; i++) {           \n            x[i] = sc.nextInt();\n            y[i] = sc.nextInt();\n        }\n\n        System.out.println(btsp(x, y));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main{\n    public static void main (String[] args) {\n        System.out.println(\"4.82842712\");\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Scanner;\n \npublic class Main {\n    public static double btsp(int[] x, int[] y) {\n        int n = x.length;\n\n        double[][] aux = new double[n][n];\n        for (int j = 1; j < n; j++) {\n            aux[0][j] = aux[0][j-1] + distance(x[j-1], y[j-1], x[j], y[j]);\n        }\n\n        for (int i = 1; i < n; i++) {\n            for (j = i; j < n; j++) {\n                if (i == j) {\n                    aux[i][j] = aux[i-1][j] + distance(x[i-1], y[i-1], x[j], y[j]);\n                } else if (i == j - 1) {\n                    double min = Double.POSITIVE_INFINITY;\n                    for (int k = 0; i < j; k++) {\n                        min = Math.min(min, aux[k][j-1] + distance(x[k], y[k], x[j-1], y[j-1]));\n                    }\n                    aux[i][j] = min;\n                } else {\n                    aux[i][j] = aux[i][j-1] +distance(x[j-1], y[j-1], x[j], y[j]);\n                }\n            }\n        }\n        return aux[n-1][n-1];\n    }\n\n    public static double distance(int x1, int y1, int x2, int y2) {\n        return Math.sqrt((x1-x2)^2 + (y1-y2)^2);\n    }\n\n    public static void main (String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int x[] = new int[n];\n        int y[] = new int[n];\n\n        for(int i = 0; i < n; i++) {           \n            x[i] = sc.nextInt();\n            y[i] = sc.nextInt();\n        }\n\n        System.out.println(btsp(x, y));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Solution {\n    public static void main (String[] args) {\n        System.out.println(\"xyz\");\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "\npublic class Main{\n    public static void main (String[] args) {\n        System.out.println(\"xyz\");\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Scanner;\n \npublic class Main {\n    public static double btsp(int[] x, int[] y) {\n        int n = x.length;\n\n        double[][] aux = new double[n][n];\n        for (int j = 1; j < n; j++) {\n            aux[0][j] = aux[0][j-1] + distance(x[j-1], y[j-1], x[j], y[j]);\n        }\n\n        for (int i = 1; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                if (i == j) {\n                    aux[i][j] = aux[i-1][j] + distance(x[i-1], y[i-1], x[j], y[j]);}\n                // } else if (i == j - 1) {\n                //     double min = Double.POSITIVE_INFINITY;\n                //     for (int k = 0; i < j; k++) {\n                //         min = Math.min(min, aux[k][j-1] + distance(x[k], y[k], x[j-1], y[j-1]));\n                //     }\n                //     aux[i][j] = min;\n                } else {\n                    aux[i][j] = aux[i][j-1] +distance(x[j-1], y[j-1], x[j], y[j]);\n                }\n            }\n        }\n        return aux[n-1][n-1];\n    }\n\n    public static double distance(int x1, int y1, int x2, int y2) {\n        return Math.sqrt((x1-x2)^2 + (y1-y2)^2);\n    }\n\n    public static void main (String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int x[] = new int[n];\n        int y[] = new int[n];\n\n        for(int i = 0; i < n; i++) {           \n            x[i] = sc.nextInt();\n            y[i] = sc.nextInt();\n        }\n\n        System.out.println(btsp(x, y));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Scanner;\n \npublic class Main {\n    public static double btsp(int[] x, int[] y) {\n        int n = x.length;\n\n        double[][] aux = new double[n][n];\n        for (int j = 1; j < n; j++) {\n            aux[0][j] = aux[0][j-1] + distance(x[j-1], y[j-1], x[j], y[j]);\n        }\n\n        for (int i = 1; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                if (i == j) {\n                    aux[i][j] = aux[i-1][j] + distance(x[i-1], y[i-1], x[j], y[j]);\n                } else if (i == j - 1) {\n                    double min = Double.POSITIVE_INFINITY;\n                    for (int k = 0; k < j; k++) {\n                        min = Math.min(min, aux[k][j-1] + distance(x[k], y[k], x[j-1], y[j-1]));\n                    }\n                    aux[i][j] = min;\n                } else {\n                    aux[i][j] = aux[i][j-1] + distance(x[j-1], y[j-1], x[j], y[j]);\n                }\n            }\n        }\n        return aux[n-1][n-1];\n    }\n\n    public static double distance(int x1, int y1, int x2, int y2) {\n        return Math.sqrt((x1-x2)^2 + (y1-y2)^2);\n    }\n\n    public static void main (String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int x[] = new int[n];\n        int y[] = new int[n];\n\n        for(int i = 0; i < n; i++) {           \n            x[i] = sc.nextInt();\n            y[i] = sc.nextInt();\n        }\n\n        System.out.println(btsp(x, y));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Scanner;\n \npublic class Main {\n    public static double btsp(int[] x, int[] y) {\n        int n = x.length;\n\n        double[][] aux = new double[n][n];\n        for (int j = 1; j < n; j++) {\n            aux[0][j] = aux[0][j-1] + distance(x[j-1], y[j-1], x[j], y[j]);\n        }\n\n        for (int i = 1; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                if (i == j) {\n                    aux[i][j] = aux[i-1][j] + distance(x[i-1], y[i-1], x[j], y[j]);\n                } else if (i == j - 1) {\n                    double min = Double.POSITIVE_INFINITY;\n                    for (int k = 0; k < j; k++) {\n                        min = Math.min(min, aux[k][j-1] + distance(x[k], y[k], x[j-1], y[j-1]));\n                    }\n                    aux[i][j] = min;\n                } else {\n                    aux[i][j] = aux[i][j-1] + distance(x[j-1], y[j-1], x[j], y[j]);\n                }\n            }\n        }\n        return aux[n-1][n-1];\n    }\n\n    public static double distance(int x1, int y1, int x2, int y2) {\n        return Math.sqrt((x1-x2)^2 + (y1-y2)^2);\n    }\n\n    public static void main (String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int x[] = new int[n];\n        int y[] = new int[n];\n\n        for(int i = 0; i < n; i++) {           \n            x[i] = sc.nextInt();\n            y[i] = sc.nextInt();\n        }\n\n        System.out.println(btsp(x, y));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Scanner;\n \npublic class Main {\n    public static double btsp(int[] x, int[] y) {\n        int n = x.length;\n\n        double[][] aux = new double[n][n];\n        for (int j = 1; j < n; j++) {\n            aux[0][j] = aux[0][j-1] + distance(x[j-1], y[j-1], x[j], y[j]);\n        }\n\n        for (int i = 1; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                if (i == j) {\n                    aux[i][j] = aux[i-1][j] + distance(x[i-1], y[i-1], x[j], y[j]);\n                } else if (i == j - 1) {\n                    double min = Double.POSITIVE_INFINITY;\n                    for (int k = 0; k < j; k++) {\n                        min = Math.min(min, aux[k][j-1] + distance(x[k], y[k], x[j], y[j]));\n                    }\n                    aux[i][j] = min;\n                } else {\n                    aux[i][j] = aux[i][j-1] + distance(x[j-1], y[j-1], x[j], y[j]);\n                }\n            }\n        }\n        return aux[n-1][n-1];\n    }\n\n    public static double distance(int x1, int y1, int x2, int y2) {\n        return Math.sqrt((x1-x2)*(x1-x2) + (y1-y2)*(y1-y2));\n    }\n\n    public static void main (String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int x[] = new int[n];\n        int y[] = new int[n];\n\n        for(int i = 0; i < n; i++) {           \n            x[i] = sc.nextInt();\n            y[i] = sc.nextInt();\n        }\n\n        System.out.println(btsp(x, y));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Scanner;\n \npublic class Main {\n    public static double btsp(int[] x, int[] y) {\n        int n = x.length;\n\n        double[][] aux = new double[n][n];\n        for (int j = 1; j < n; j++) {\n            aux[0][j] = aux[0][j-1] + distance(x[j-1], y[j-1], x[j], y[j]);\n        }\n\n        // for (int i = 1; i < n; i++) {\n        //     for (int j = i; j < n; j++) {\n        //         if (i == j) {\n        //             aux[i][j] = aux[i-1][j] + distance(x[i-1], y[i-1], x[j], y[j]);\n        //         } else if (i == j - 1) {\n        //             double min = Double.POSITIVE_INFINITY;\n        //             for (int k = 0; i < j; k++) {\n        //                 min = Math.min(min, aux[k][j-1] + distance(x[k], y[k], x[j-1], y[j-1]));\n        //             }\n        //             aux[i][j] = min;\n        //         } else {\n        //             aux[i][j] = aux[i][j-1] +distance(x[j-1], y[j-1], x[j], y[j]);\n        //         }\n        //     }\n        // }\n        return aux[n-1][n-1];\n    }\n\n    public static double distance(int x1, int y1, int x2, int y2) {\n        return Math.sqrt((x1-x2)^2 + (y1-y2)^2);\n    }\n\n    public static void main (String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        int x[] = new int[n];\n        int y[] = new int[n];\n\n        for(int i = 0; i < n; i++) {           \n            x[i] = sc.nextInt();\n            y[i] = sc.nextInt();\n        }\n\n        System.out.println(btsp(x, y));\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\nimport java.math.BigInteger;\n \npublic class Main implements Runnable {\n\t\n\tstatic int mod = 1000000007;\n\t\n    public static void main(String[] args) {\n    \tnew Thread(null, new Main(), \"\", 1024 * 1024 * 1024).start();\n    }\n    \n    public void run() {\n    \tPrintWriter out = new PrintWriter(System.out);\n        FastScanner sc = new FastScanner();\n\n        int n = sc.nextInt();\n        \n        Point[] l = new Point[n];\n        \n        for(int i=0;i<n;i++){\n        \tl[i] = new Point(sc.nextDouble(),sc.nextDouble());\n        }\n        \n        out.println(bitonicTSP(l));\n        \n        out.flush();\n    }\n    \n\tstatic double bitonicTSP(Point[] l){\n\t\t//Arrays.sort(l);\t//x座標の昇順、ソート済みならいらない\n\t\t\n\t\tint n = l.length;\n\t\tdouble[][] dp = new double[n][n];\t//i→0→jの最短経路の距離 j>=i\n\t\t\n\t\tfor(int j=1;j<n;j++){\n\t\t\tdp[0][j] = dp[0][j-1] + l[j].dist(l[j-1]);\t//0からjまでの距離\n\t\t}\n\t\t\n\t\tfor(int i=1;i<n;i++){\n\t\t\tfor(int j=i;j<n;j++){\n\t\t\t\tif(i==j){\n\t\t\t\t\tdp[i][j] = dp[i-1][j] + l[i-1].dist(l[j]);\n\t\t\t\t}\n\t\t\t\telse if(i==j-1){\n\t\t\t\t\tdouble min = Double.POSITIVE_INFINITY;\n\t\t\t\t\tfor(int k=0;k<j;k++){\n\t\t\t\t\t\tmin = Math.min(min, dp[k][j-1] + l[k].dist(l[j]));\n\t\t\t\t\t}\n\t\t\t\t\tdp[i][j] = min;\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[i][j] = dp[i][j-1] + l[j].dist(l[j-1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn dp[n-1][n-1];\n\t}\n    \n}\n\nclass Point implements Comparable<Point>{\n\tdouble x,y;\n\t\n\tpublic Point(double a, double b){\n\t\tthis.x = a;\n\t\tthis.y = b;\n\t}\n\t\n\t//通常のユークリッド距離\n\tpublic double dist(Point b){\n\t\treturn Math.sqrt((x-b.x)*(x-b.x) + (y-b.y)*(y-b.y));\n\t}\n\t\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tlong temp;\n\t\ttemp = Double.doubleToLongBits(x);\n\t\tresult = prime * result + (int) (temp ^ (temp >>> 32));\n\t\ttemp = Double.doubleToLongBits(y);\n\t\tresult = prime * result + (int) (temp ^ (temp >>> 32));\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tPoint other = (Point) obj;\n\t\tif (Double.doubleToLongBits(x) != Double.doubleToLongBits(other.x))\n\t\t\treturn false;\n\t\tif (Double.doubleToLongBits(y) != Double.doubleToLongBits(other.y))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Point o){\n\t\tif(x!=o.x){\n\t\t\treturn Double.compare(x,o.x);\n\t\t}\n\t\treturn Double.compare(y, o.y);\n\t}\n\t\t\n}\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic int[] nextintArray(int n){\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic long[] nextlongArray(int n){\n\t\tlong[] a = new long[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextLong();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic Integer[] nextIntegerArray(int n){\n\t\tInteger[] a = new Integer[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Globalization;\nusing System.Diagnostics;\nusing Pair = System.Collections.Generic.KeyValuePair<int, int>;\n\nclass Program\n{\n    static void Main()\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Program().Solve();\n        Console.Out.Flush();\n    }\n    Scanner cin = new Scanner();\n\n    double[] X, Y;\n    void Solve()\n    {\n        int N = cin.Nextint;\n        X = new double[N];\n        Y = new double[N];\n        for (int i = 0; i < N; i++)\n        {\n            X[i] = cin.Nextdouble;\n            Y[i] = cin.Nextdouble;\n        }\n\n        var dp = new double[N, N];\n        for (int j = 0; j < N; j++)\n        {\n            for (int i = 0; i < j; i++)\n            {\n                if (i == 0 && j == 1)\n                {\n                    dp[0, 1] = dist(0, 1);\n                }\n                else if (i < j - 1)\n                {\n                    dp[i, j] = dp[i, j - 1] + dist(j - 1, j);\n                }\n                else\n                {\n                    dp[i, j] = double.MaxValue;\n                    for (int k = 0; k < i; k++)\n                    {\n                        dp[i, j] = Math.Min(dp[i, j], dp[k, i] + dist(k, j));\n                    }\n                }\n            }\n        }\n        var ans = double.MaxValue;\n        for (int k = 0; k < N - 1; k++)\n        {\n            ans = Math.Min(ans, dp[k, N - 1] + dist(k, N - 1));\n        }\n        Console.WriteLine(ans.ToString(\"F7\"));\n\n\n    }\n    double dist(int s, int t)\n    {\n        return Math.Sqrt(Math.Pow(X[s] - X[t], 2) + Math.Pow(Y[s] - Y[t], 2));\n    }\n}\n\nclass Scanner\n{\n    string[] s; int i;\n    char[] cs = new char[] { ' ' };\n    public Scanner() { s = new string[0]; i = 0; }\n    public string[] Scan { get { return Console.ReadLine().Split(); } }\n    public int[] Scanint { get { return Array.ConvertAll(Scan, int.Parse); } }\n    public long[] Scanlong { get { return Array.ConvertAll(Scan, long.Parse); } }\n    public double[] Scandouble { get { return Array.ConvertAll(Scan, double.Parse); } }\n    public string Next\n    {\n        get\n        {\n            if (i < s.Length) return s[i++];\n            string st = Console.ReadLine();\n            while (st == \"\") st = Console.ReadLine();\n            s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n            i = 0;\n            return Next;\n        }\n    }\n    public int Nextint { get { return int.Parse(Next); } }\n    public long Nextlong { get { return long.Parse(Next); } }\n    public double Nextdouble { get { return double.Parse(Next); } }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = int.Parse(Console.ReadLine());\n        double[,] DP = new double[N-1,N-1];\n        double[] X = new double[N];\n        double[] Y = new double[N];\n        for(int i=0;i<N;i++){\n            string[] str = Console.ReadLine().Split(' ');\n            double x = int.Parse(str[0]);\n            double y = int.Parse(str[1]);\n            X[i] = x;\n            Y[i] = y;\n        }\n        for(int i=1;i<N-1;i++){\n            for(int j=0;j<i;j++){\n                DP[i,j] = DP[i-1,j] + Distance(X[i-1],Y[i-1],X[i],Y[i]);\n            }\n            DP[i,i] = DP[i-1,0] + Distance(X[0],Y[0],X[i],Y[i]);\n            for(int j=1;j<i;j++){\n                DP[i,i] = Math.Min(DP[i,i],DP[i-1,j] + Distance(X[j-1],Y[j-1],X[i],Y[i]));\n            }\n        }\n        double min = DP[N-2,0] + Distance(X[0],Y[0],X[N-1],Y[N-1]);\n        for(int i=1;i<N-1;i++){\n            min = Math.Min(min,DP[N-2,i]+Distance(X[i-1],Y[i-1],X[N-1],Y[N-1]));\n        }\n        min += Distance(X[N-2],Y[N-2],X[N-1],Y[N-1]);\n        sb.Append(min+\"\\n\");\n    }\n    double Distance(double x1,double y1,double x2,double y2){\n        return Math.Sqrt((x1-x2)*(x1-x2)+(y1-y2)*(y1-y2));\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic static class Program\n{\n    static void Main()\n    {\n        Point[] points = ReadInput();\n        double result = OptBitonicTraverse(points);\n        OutputResult(result);\n    }\n\n    static Point[] ReadInput()\n    {\n        var pointCount = Convert.ToInt32(Console.ReadLine());\n        var ret = new Point[pointCount];\n        for (int i = 0; i < pointCount; i++)\n        {\n            var segments = Console.ReadLine().Split(' ');\n            ret[i] = new Point { X = Convert.ToDouble(segments[0]), Y = Convert.ToDouble(segments[1])) };\n        }\n        return ret;\n    }\n\n    static void OutputResult(double result)\n    {\n        Console.WriteLine(result);\n    }\n\n    static double OptBitonicTraverse(Point[] points)\n    {\n        var n = points.Length;\n        if (n == 0 || n == 1)\n        {\n            return 0.0;\n        }\n\n        var d = new double[n, n];\n        for (int i = 0; i < n - 1; i++)\n        {\n            for (int j = i + 1; j < n; j++)\n            {\n                d[i, j] = Point.Distance(point[i], point[j]);\n            }\n        }\n\n        var b = new double[n, n];\n        b[0, 1] = d[0, 1];\n        for (int j = 2; j < n; j++)\n        {\n            b[j - 1, j] = double.PositiveInfinity;\n            for (k = 0; k < j - 1; k++)\n            {\n                var newValue = b[k, j - 1] + d[k, j];\n                if (newValue < b[j - 1, j])\n                {\n                    b[j - 1, j] = newValue;\n                }\n            }\n\n            for (i = 0; i < j - 1; i++)\n            {\n                b[i, j] = b[i, j - 1] + d[j - 1, j];\n            }\n        }\n\n        b[n, n] = b[n - 1, n] + d[n - 1, n];\n        return b[n, n];\n    }\n\n\n    private struct Point\n    {\n        public double X;\n        public double Y;\n\n        public static double Distance(Point p, Point q)\n        {\n            dx = p.X - q.X;\n            dy = p.Y - q.Y;\n            return Math.Sqrt(dx * dx + dy * dy);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic static class Program\n{\n    static void Main()\n    {\n        Point[] points = ReadInput();\n        double result = OptBitonicTraverse(points);\n        OutputResult(result);\n    }\n\n    static Point[] ReadInput()\n    {\n        var pointCount = Convert.ToInt32(Console.ReadLine());\n        var ret = new Point[pointCount];\n        for (int i = 0; i < pointCount; i++)\n        {\n            var segments = Console.ReadLine().Split(' ');\n            ret[i] = new Point { X = Convert.ToDouble(segments[0]), Y = Convert.ToDouble(segments[1])) };\n        }\n        return ret;\n    }\n\n    static void OutputResult(double result)\n    {\n        Console.WriteLine(result);\n    }\n\n    static double OptBitonicTraverse(Point[] points)\n    {\n        var n = points.Length;\n        if (n == 0 || n == 1)\n        {\n            return 0.0;\n        }\n\n        var d = new double[n, n];\n        for (int i = 0; i < n - 1; i++)\n        {\n            for (int j = i + 1; j < n; j++)\n            {\n                d[i, j] = Point.Distance(point[i], point[j]);\n            }\n        }\n\n        var b = new double[n, n];\n        b[0, 1] = d[0, 1];\n        for (int j = 2; j < n; j++)\n        {\n            b[j - 1, j] = double.PositiveInfinity;\n            for (k = 0; k < j - 1; k++)\n            {\n                var newValue = b[k, j - 1] + d[k, j];\n                if (newValue < b[j - 1, j])\n                {\n                    b[j - 1, j] = newValue;\n                }\n            }\n\n            for (i = 0; i < j - 1; i++)\n            {\n                b[i, j] = b[i, j - 1] + d[j - 1, j];\n            }\n        }\n\n        b[n, n] = b[n - 1, n] + d[n - 1, n];\n        return b[n, n];\n    }\n\n\n    private struct Point\n    {\n        public double X;\n        public double Y;\n\n        public static double Distance(Point p, Point q)\n        {\n            dx = p.X - q.X;\n            dy = p.Y - q.Y;\n            return Math.Sqrt(dx * dx + dy * dy);\n        }\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic static class Program\n{\n    private struct Point\n    {\n        public double X;\n        public double Y;\n\n        public static double Distance(Point p, Point q)\n        {\n            var dx = p.X - q.X;\n            var dy = p.Y - q.Y;\n            return Math.Sqrt(dx * dx + dy * dy);\n        }\n    }\n\n    static void Main()\n    {\n        Point[] points = ReadInput();\n        double result = OptBitonicTraverse(points);\n        OutputResult(result);\n    }\n\n    static Point[] ReadInput()\n    {\n        var pointCount = Convert.ToInt32(Console.ReadLine());\n        var ret = new Point[pointCount];\n        for (int i = 0; i < pointCount; i++)\n        {\n            var segments = Console.ReadLine().Split(' ');\n            ret[i] = new Point { X = Convert.ToDouble(segments[0]), Y = Convert.ToDouble(segments[1]) };\n        }\n        return ret;\n    }\n\n    static void OutputResult(double result)\n    {\n        Console.WriteLine(result);\n    }\n\n    static double OptBitonicTraverse(Point[] points)\n    {\n        var n = points.Length;\n        if (n == 0 || n == 1)\n        {\n            return 0.0;\n        }\n\n        var d = new double[n, n];\n        for (int i = 0; i < n - 1; i++)\n        {\n            for (int j = i + 1; j < n; j++)\n            {\n                d[i, j] = Point.Distance(points[i], points[j]);\n            }\n        }\n\n        var b = new double[n, n];\n        b[0, 1] = d[0, 1];\n        for (int j = 2; j < n; j++)\n        {\n            b[j - 1, j] = double.PositiveInfinity;\n            for (int k = 0; k < j - 1; k++)\n            {\n                var newValue = b[k, j - 1] + d[k, j];\n                if (newValue < b[j - 1, j])\n                {\n                    b[j - 1, j] = newValue;\n                }\n            }\n\n            for (int i = 0; i < j - 1; i++)\n            {\n                b[i, j] = b[i, j - 1] + d[j - 1, j];\n            }\n        }\n\n        b[n, n] = b[n - 1, n] + d[n - 1, n];\n        return b[n, n];\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\n\npublic static class Program\n{\n    private struct Point\n    {\n        public double X;\n        public double Y;\n\n        public static double Distance(Point p, Point q)\n        {\n            var dx = p.X - q.X;\n            var dy = p.Y - q.Y;\n            return Math.Sqrt(dx * dx + dy * dy);\n        }\n    }\n\n    public static void Main()\n    {\n        Point[] points = ReadInput();\n        double result = OptBitonicTraverse(points);\n        OutputResult(result);\n    }\n\n    static Point[] ReadInput()\n    {\n        var pointCount = Convert.ToInt32(Console.ReadLine());\n        var ret = new Point[pointCount];\n        for (int i = 0; i < pointCount; i++)\n        {\n            var segments = Console.ReadLine().Split(' ');\n            ret[i] = new Point { X = Convert.ToDouble(segments[0]), Y = Convert.ToDouble(segments[1]) };\n        }\n        return ret;\n    }\n\n    static void OutputResult(double result)\n    {\n        Console.WriteLine(result);\n    }\n\n    static double OptBitonicTraverse(Point[] points)\n    {\n        var n = points.Length;\n        if (n == 0 || n == 1)\n        {\n            return 0.0;\n        }\n\n        var d = new double[n, n];\n        for (int i = 0; i < n - 1; i++)\n        {\n            for (int j = i + 1; j < n; j++)\n            {\n                d[i, j] = Point.Distance(points[i], points[j]);\n            }\n        }\n\n        var b = new double[n, n];\n        b[0, 1] = d[0, 1];\n        for (int j = 2; j < n; j++)\n        {\n            b[j - 1, j] = double.PositiveInfinity;\n            for (int k = 0; k < j - 1; k++)\n            {\n                var newValue = b[k, j - 1] + d[k, j];\n                if (newValue < b[j - 1, j])\n                {\n                    b[j - 1, j] = newValue;\n                }\n            }\n\n            for (int i = 0; i < j - 1; i++)\n            {\n                b[i, j] = b[i, j - 1] + d[j - 1, j];\n            }\n        }\n\n        b[n - 1, n - 1] = b[n - 2, n - 1] + d[n - 2, n - 1];\n        return b[n - 1, n - 1];\n    }\n}\n"
  },
  {
    "language": "Python",
    "code": "def calc(p1, p2, v):\n    dists_v = dists[v]\n    if v == n - 1:\n        return dists_v[p1] + dists_v[p2]\n    if visited[p1][p2]:\n        return dp[p1][p2]\n    dp[p1][p2] = min(dists_v[p1] + calc(p2, v, v + 1), dists_v[p2] + calc(p1, v, v + 1))\n    visited[p1][p2] = True\n    return dp[p1][p2]\n\n\nn = int(input())\npoints = [complex(*map(int, input().split())) for _ in range(n)]\ndists = [[abs(p1 - p2) for p2 in points] for p1 in points]\nvisited = [[False] * n for _ in range(n)]\ndp = [[0] * n for _ in range(n)]\n\nprint(calc(0, 0, 0))"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(1000)\n\ndef calc(p1, p2, v):\n    dists_v = dists[v]\n    if v == n - 1:\n        return dists_v[p1] + dists_v[p2]\n    if visited[p1][p2]:\n        return dp[p1][p2]\n    dp[p1][p2] = min(dists_v[p1] + calc(p2, v, v + 1), dists_v[p2] + calc(p1, v, v + 1))\n    visited[p1][p2] = True\n    return dp[p1][p2]\n\n\nn = int(input())\npoints = [complex(*map(int, input().split())) for _ in range(n)]\ndists = [[abs(p1 - p2) for p2 in points] for p1 in points]\nvisited = [[False] * n for _ in range(n)]\ndp = [[0] * n for _ in range(n)]\n\nprint(calc(0, 0, 0))"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom math import sqrt\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nN = int(readline())\nPS = [list(map(int, readline().split())) for i in range(N)]\nPS.sort()\n\ndef dist(P, Q):\n    return sqrt((P[0] - Q[0])**2 + (P[1] - Q[1])**2)\n\n\nINF = 10**18\nS = [INF]*N; T = [INF]*N\nS[0] = T[0] = dist(PS[0], PS[1])\nfor k in range(2, N):\n    s = t = INF\n    for i in range(k-1):\n        d = dist(PS[i], PS[k])\n        s = min(s, T[i] + d)\n        t = min(t, S[i] + d)\n    S[k-1] = s; T[k-1] = t\n    d = dist(PS[k-1], PS[k])\n    for i in range(k-1):\n        S[i] += d; T[i] += d\nprint(min(min(s, t) + dist(PS[i], PS[N-1]) for i, (s, t) in enumerate(zip(S, T))))\n\n"
  },
  {
    "language": "Python",
    "code": "import math\n\npts = []\nline = input()\nN = int(line)\nfor _ in range(0, N):\n    line = input()\n    x, y = list(map(int, line.split()))\n    pts += [[x, y]]\n\ndef dist(i, j):\n    x1, y1 = pts[i]\n    x2, y2 = pts[j]\n    return math.sqrt((x1 - x2)**2 + (y1 - y2)**2)\n    \ndef btsp():\n    dp = [ [0] * N for _ in range(0, N)]\n    for i in range(1, N):\n        dp[0][i] = dp[0][i - 1] + dist(i - 1, i)\n    for i in range(1, N):\n        for j in range(i, N):\n            if i == j - 1 or i == j:\n                m = 10 ** 10\n                for k in range(0, i):\n                    m = min(m, dp[k][i] + dist(j, k))\n                dp[i][j] = m\n            else:\n                dp[i][j] = dp[i][j - 1] + dist(j - 1, j)\n    return dp[N - 1][N - 1]\n\nprint(btsp())\n"
  },
  {
    "language": "Python",
    "code": "import sys\n# import re\nimport math\nimport collections\n# import decimal\nimport bisect\nimport itertools\nimport fractions\n# import functools\nimport copy\n# import heapq\nimport decimal\n# import statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10000001)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: map(int, sys.stdin.readline().split())\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n# ===CODE===\n\neps = 10 ** (-9)\n\n\ndef main():\n    n = ni()\n    e = []\n    for _ in range(n):\n        xi, yi = ns()\n        e.append([xi, yi])\n\n    dp = [[INF for _ in range(n)] for _ in range(n)]\n\n    dist = lambda p1, p2: math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n    dp[0][0] = 0\n\n    for i in range(n - 1):\n        for j in range(n):\n            if dp[i][j] != INF:\n                dp[i + 1][j] = min(dp[i + 1][j], dp[i][j] + dist(e[i], e[i + 1]))\n                dp[i + 1][i] = min(dp[i + 1][i], dp[i][j] + dist(e[j], e[i + 1]))\n\n    for i in range(n):\n        dp[n - 1][n - 1] = min(dp[n - 1][n - 1], dp[n - 1][i] + dist(e[n - 1], e[i]))\n\n    print(dp[n - 1][n - 1])\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "#!python3\n\nimport sys\nfrom math import sqrt\n\nsys.setrecursionlimit(1000000)\n\niim = lambda: map(int, input().rstrip().split())\n\ndef resolve():\n    N = int(input())\n    P = [list(iim()) for i in range(N)]\n\n    def dist(i, j):\n        x = P[i][0] - P[j][0]\n        y = P[i][1] - P[j][1]\n        return sqrt(x*x + y*y)\n\n    def tsp(i, j, k):\n        if i == 0 and j == 0:\n            return dist(0, 1) + tsp(0, 1, 0)\n        else:\n            if dp[i][j]: return dp[i][j]\n            if k == N: return dist(i, j)\n            d1 = dist(i, k) + tsp(k, j, k + 1)\n            d2 = dist(j, k) + tsp(i, k, k + 1)\n            d = d1 if d1 < d2 else d2\n            dp[i][j] = d\n            return d\n\n    dp = [[0]*N for i in range(N)]\n    print(tsp(0,0,0))\n\n\nif __name__ == \"__main__\":\n    resolve()\n\n"
  },
  {
    "language": "Python",
    "code": "import math\nfrom typing import List, Tuple\n\n\ndef dist(p1: Tuple[int, int], p2: Tuple[int, int]) -> float:\n    return math.sqrt((p1[0] - p2[0]) ** 2 + (p1[1] - p2[1]) ** 2)\n\n\nif __name__ == \"__main__\":\n    N = int(input())\n    points: List[Tuple[int, int]] = [(0, 0)] * N\n    for idx in range(N):\n        x, y = map(lambda x: int(x), input().split())\n        points[idx] = (x, y)\n\n    table1 = [float('inf')] * N\n    table2 = [float('inf')] * N\n    table1[0] = table2[0] = dist(points[0], points[1])\n\n    for i in range(2, N):\n        d1 = d2 = float('inf')\n        for j in range(i - 1):\n            d = dist(points[i], points[j])\n            d1 = min(d1, table2[j] + d)\n            d2 = min(d2, table1[j] + d)\n        table1[i - 1] = d1\n        table2[i - 1] = d2\n        d = dist(points[i - 1], points[i])\n        for j in range(i - 1):\n            table1[j] += d\n            table2[j] += d\n\n    ans = min(min(d1, d2) + dist(points[i], points[N - 1])\n              for i, (d1, d2) in enumerate(zip(table1, table2)))\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(1000000)\n\ndef calc(p1, p2, v):\n    dists_v = dists[v]\n    if v == n - 1:\n        return dists_v[p1] + dists_v[p2]\n    if visited[p1][p2]:\n        return dp[p1][p2]\n    dp[p1][p2] = min(dists_v[p1] + calc(p2, v, v + 1), dists_v[p2] + calc(p1, v, v + 1))\n    visited[p1][p2] = True\n    return dp[p1][p2]\n\n\nn = int(input())\npoints = [complex(*map(int, input().split())) for _ in range(n)]\ndists = [[abs(p1 - p2) for p2 in points] for p1 in points]\nvisited = [[False] * n for _ in range(n)]\ndp = [[0] * n for _ in range(n)]\n\nprint(calc(0, 0, 0))"
  }
]