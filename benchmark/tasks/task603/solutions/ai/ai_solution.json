[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <float.h>\n\n#define MAX_POINTS 1000\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble distance(Point p1, Point p2) {\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\ndouble bitonic_tsp(Point points[], int n) {\n    double dp[MAX_POINTS][MAX_POINTS];\n    for (int i = 0; i < n; i++)\n        for (int j = 0; j < n; j++)\n            dp[i][j] = DBL_MAX;\n\n    dp[0][1] = distance(points[0], points[1]);\n\n    for (int j = 2; j < n; j++) {\n        for (int i = 0; i < j - 1; i++) {\n            double path_dist = dp[i][j-1] + distance(points[i], points[j]);\n            dp[i][j] = fmin(dp[i][j], path_dist);\n\n            for (int k = 0; k < i; k++) {\n                path_dist = dp[k][i] + distance(points[k], points[j]);\n                dp[k][j] = fmin(dp[k][j], path_dist);\n            }\n        }\n    }\n\n    double min_dist = DBL_MAX;\n    for (int i = 0; i < n - 1; i++) {\n        min_dist = fmin(min_dist, dp[i][n-1] + distance(points[i], points[n-1]));\n    }\n\n    return min_dist;\n}\n\nint main() {\n    int n;\n    Point points[MAX_POINTS];\n\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n    }\n\n    double result = bitonic_tsp(points, n);\n    printf(\"%.2f\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:17:15"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <float.h>\n#include <stdlib.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\nint compare_points(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    if (p1->x < p2->x) return -1;\n    if (p1->x > p2->x) return 1;\n    return 0;\n}\n\ndouble distance(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble bitonic_tsp(Point points[], int n) {\n    qsort(points, n, sizeof(Point), compare_points);\n\n    double dp[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j] = DBL_MAX;\n        }\n    }\n    dp[0][0] = 0.0;\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (i == j + 1) {\n                for (int k = 0; k <= j; k++) {\n                    double dist = dp[j][k] + distance(points[k], points[i]);\n                    if (dist < dp[i][j]) {\n                        dp[i][j] = dist;\n                    }\n                }\n            } else {\n                dp[i][j] = dp[i-1][j] + distance(points[i-1], points[i]);\n            }\n        }\n    }\n\n    double min_distance = DBL_MAX;\n    for (int j = 0; j < n-1; j++) {\n        double dist = dp[n-1][j] + distance(points[j], points[n-1]);\n        if (dist < min_distance) {\n            min_distance = dist;\n        }\n    }\n\n    return min_distance;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Point points[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n    }\n\n    double result = bitonic_tsp(points, n);\n    printf(\"%.2f\\n\", result);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:17:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n#include <limits>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\nbool comparePoints(const Point &a, const Point &b) {\n    return a.x < b.x;\n}\n\ndouble distance(const Point &a, const Point &b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble bitonicTSP(vector<Point> &points) {\n    int n = points.size();\n    if (n < 2) return 0.0;\n\n    sort(points.begin(), points.end(), comparePoints);\n\n    vector<vector<double>> dp(n, vector<double>(n, numeric_limits<double>::max()));\n    dp[0][0] = 0.0;\n\n    for (int j = 1; j < n; ++j) {\n        for (int i = 0; i < j; ++i) {\n            if (i == j - 1) {\n                for (int k = 0; k < j - 1; ++k) {\n                    dp[i][j] = min(dp[i][j], dp[k][i] + distance(points[k], points[j]));\n                }\n            } else {\n                dp[i][j] = dp[i][j - 1] + distance(points[j - 1], points[j]);\n            }\n        }\n    }\n\n    double minDist = numeric_limits<double>::max();\n    for (int i = 0; i < n - 1; ++i) {\n        minDist = min(minDist, dp[i][n - 1] + distance(points[i], points[n - 1]));\n    }\n\n    return minDist;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> points(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> points[i].x >> points[i].y;\n    }\n\n    double result = bitonicTSP(points);\n    cout << fixed << setprecision(2) << result << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:18:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class BitonicTSP {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    public static double bitonicTSP(Point[] points) {\n        int n = points.length;\n        if (n == 0) return 0;\n\n        Arrays.sort(points, Comparator.comparingDouble(p -> p.x));\n\n        double[][] dp = new double[n][n];\n        dp[0][1] = distance(points[0], points[1]);\n\n        for (int j = 2; j < n; j++) {\n            for (int i = 0; i < j - 1; i++) {\n                dp[i][j] = dp[i][j - 1] + distance(points[j - 1], points[j]);\n            }\n            dp[j - 1][j] = Double.MAX_VALUE;\n            for (int k = 0; k < j - 1; k++) {\n                double temp = dp[k][j - 1] + distance(points[k], points[j]);\n                if (temp < dp[j - 1][j]) {\n                    dp[j - 1][j] = temp;\n                }\n            }\n        }\n\n        dp[n - 1][n - 1] = dp[n - 2][n - 1] + distance(points[n - 2], points[n - 1]);\n        return dp[n - 1][n - 1];\n    }\n\n    private static double distance(Point a, Point b) {\n        return Math.sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n    }\n\n    public static void main(String[] args) {\n        Point[] points = new Point[]{\n            new Point(0, 0),\n            new Point(1, 1),\n            new Point(2, 0),\n            new Point(3, 1)\n        };\n        System.out.println(bitonicTSP(points));\n    }\n}",
    "timestamp": "2025-08-05 22:18:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class BitonicTSP {\n    public static double solve(Point[] points) {\n        int n = points.length;\n        Arrays.sort(points, Comparator.comparingDouble(p -> p.x));\n        \n        double[][] dp = new double[n][n];\n        int[][] path = new int[n][n];\n        \n        for (int j = 1; j < n; j++) {\n            for (int i = 0; i < j; i++) {\n                dp[i][j] = Double.MAX_VALUE;\n                for (int k = 0; k < i; k++) {\n                    double dist = dp[k][i] + distance(points[k], points[j]);\n                    if (dist < dp[i][j]) {\n                        dp[i][j] = dist;\n                        path[i][j] = k;\n                    }\n                }\n            }\n        }\n        \n        double minDist = Double.MAX_VALUE;\n        int lastPoint = 0;\n        for (int i = 0; i < n - 1; i++) {\n            double totalDist = dp[i][n-1] + distance(points[i], points[n-1]);\n            if (totalDist < minDist) {\n                minDist = totalDist;\n                lastPoint = i;\n            }\n        }\n        \n        return minDist;\n    }\n    \n    private static double distance(Point p1, Point p2) {\n        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));\n    }\n    \n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Point[] points = {\n            new Point(0, 0),\n            new Point(1, 5),\n            new Point(2, 3),\n            new Point(5, 1),\n            new Point(6, 4)\n        };\n        System.out.println(solve(points));\n    }\n}",
    "timestamp": "2025-08-05 22:18:32"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n#include <iomanip>\n#include <limits>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\ndouble distance(const Point& p1, const Point& p2) {\n    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));\n}\n\ndouble bitonicTSP(vector<Point>& points) {\n    int n = points.size();\n    \n    sort(points.begin(), points.end(), [](const Point& a, const Point& b) {\n        return a.x < b.x;\n    });\n    \n    vector<vector<double>> dp(n, vector<double>(n, numeric_limits<double>::max()));\n    \n    dp[0][1] = distance(points[0], points[1]);\n    \n    for (int j = 2; j < n; j++) {\n        for (int i = 0; i < j - 1; i++) {\n            double dist = distance(points[i], points[j]);\n            \n            for (int k = 0; k < i; k++) {\n                dp[i][j] = min(dp[i][j], dp[k][i] + dist);\n            }\n        }\n    }\n    \n    double minDist = numeric_limits<double>::max();\n    for (int i = 0; i < n - 1; i++) {\n        minDist = min(minDist, dp[i][n-1] + distance(points[i], points[n-1]));\n    }\n    \n    return minDist;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<Point> points(n);\n    for (int i = 0; i < n; i++) {\n        cin >> points[i].x >> points[i].y;\n    }\n    \n    cout << fixed << setprecision(2) << bitonicTSP(points) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:18:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef euclidean_distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef bitonic_tsp(points):\n    points.sort()  # sort by x-coordinate\n    n = len(points)\n    dp = [[0] * n for _ in range(n)]  # DP table for minimum distances\n    # Base cases: direct route between the first two points\n    for i in range(1, n):\n        dp[i][i] = dp[i - 1][i - 1] + euclidean_distance(points[i - 1], points[i])\n    for j in range(n - 2, -1, -1):\n        dp[j][n - 1] = dp[j + 1][n - 1] + euclidean_distance(points[j], points[j + 1])\n\n    for j in range(n - 2, 0, -1):\n        for i in range(j):\n            dp[i][j] = math.inf\n            for k in range(i, j):\n                dp[i][j] = min(dp[i][j], dp[i][k] + euclidean_distance(points[k], points[j]))\n\n    min_path_cost = math.inf\n    for k in range(n - 1):\n        min_path_cost = min(min_path_cost, dp[k][n - 1] + euclidean_distance(points[n - 1], points[k]) + dp[0][k])\n\n    return min_path_cost\n\n# Example usage:\npoints = [(0, 0), (1, 2), (2, 3), (3, 5), (7, 8)]\nresult = bitonic_tsp(points)\nprint(f\"The shortest bitonic TSP tour distance is: {result}\")",
    "timestamp": "2025-08-13 09:51:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\n\npublic class BitonicTSP {\n\n    public static void main(String[] args) {\n        double[][] points = {\n            {0, 0},\n            {1, 5},\n            {2, 3},\n            {5, 4},\n            {6, 1},\n            {7, 3}\n        };\n        \n        System.out.println(\"Shortest Bitonic Tour Distance: \" + bitonicTSP(points));\n    }\n\n    public static double bitonicTSP(double[][] points) {\n        int n = points.length;\n        Arrays.sort(points, Comparator.comparingDouble(p -> p[0]));\n        double[][] dp = new double[n][n];\n\n        for (double[] row : dp) {\n            Arrays.fill(row, Double.POSITIVE_INFINITY);\n        }\n\n        dp[0][0] = 0;\n\n        for (int i = 1; i < n; i++) {\n            dp[i][0] = dp[i - 1][0] + dist(points[i - 1], points[i]);\n        }\n\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < i; j++) {\n                dp[i][j] = dp[i - 1][j] + dist(points[i - 1], points[i]);\n                dp[i][i] = Math.min(dp[i][i], dp[i - 1][j] + dist(points[j], points[i]));\n            }\n        }\n        \n        double minDist = Double.POSITIVE_INFINITY;\n        for (int j = 0; j < n - 1; j++) {\n            minDist = Math.min(minDist, dp[n - 1][j] + dist(points[j], points[n - 1]));\n        }\n\n        return minDist;\n    }\n\n    private static double dist(double[] p1, double[] p2) {\n        return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n    }\n}",
    "timestamp": "2025-08-13 09:51:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <math.h>\n#include <stdlib.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble distance(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nint comparePoints(const void *a, const void *b) {\n    Point *pointA = (Point *)a;\n    Point *pointB = (Point *)b;\n    if (pointA->x < pointB->x) return -1;\n    if (pointA->x > pointB->x) return 1;\n    return 0;\n}\n\ndouble bitonicTSP(Point points[], int n) {\n    qsort(points, n, sizeof(Point), comparePoints);\n\n    double dp[n][n];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j] = INFINITY;\n        }\n    }\n    \n    dp[0][1] = distance(points[0], points[1]);\n    \n    for (int j = 2; j < n; j++) {\n        for (int i = 0; i < j - 1; i++) {\n            dp[i][j] = dp[i][j - 1] + distance(points[j - 1], points[j]);\n        }\n        for (int k = 0; k < j - 1; k++) {\n            dp[j - 1][j] = fmin(dp[j - 1][j], dp[k][j - 1] + distance(points[k], points[j]));\n        }\n    }\n    \n    double minTour = INFINITY;\n    for (int i = 0; i < n - 1; i++) {\n        minTour = fmin(minTour, dp[i][n - 1] + distance(points[i], points[n - 1]));\n    }\n    return minTour;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Point points[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n    }\n    printf(\"%.6lf\\n\", bitonicTSP(points, n));\n    return 0;\n}",
    "timestamp": "2025-08-13 09:51:51"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef distance(p1, p2):\n    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)\n\ndef bitonic_tsp(points):\n    n = len(points)\n    points.sort()  # Sort points from left to right\n    \n    # Initialize DP table\n    dp = [[float('inf')] * n for _ in range(n)]\n    dp[0][1] = distance(points[0], points[1])\n    \n    # Compute DP table\n    for j in range(2, n):\n        for i in range(j-1):\n            # Direct path from i to j\n            dp[i][j] = dp[i][j-1] + distance(points[j-1], points[j])\n            \n            # Path through intermediate points\n            for k in range(i):\n                dp[k][j] = min(dp[k][j], dp[k][i] + distance(points[i], points[j]))\n    \n    # Find minimum total distance\n    min_distance = float('inf')\n    for i in range(n-1):\n        min_distance = min(min_distance, dp[i][n-1] + distance(points[i], points[-1]))\n    \n    return min_distance\n\n# Example usage\npoints = [(0, 6), (1, 4), (2, 5), (3, 3), (4, 1), (5, 2), (6, 0)]\nprint(bitonic_tsp(points))",
    "timestamp": "2025-08-13 09:52:05"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import math\n\ndef bitonic_tsp(points):\n    # Sort points by x-coordinate\n    points.sort()\n    n = len(points)\n    \n    if n == 0:\n        return 0.0\n    \n    # Initialize dp tables\n    dp = [[0.0 for _ in range(n)] for __ in range(n)]\n    \n    # Base case: distance between first two points\n    if n >= 2:\n        dp[0][1] = math.dist(points[0], points[1])\n    \n    for j in range(2, n):\n        # Fill dp[i][j] for all i < j\n        for i in range(j - 1):\n            if i == 0 and j == i + 1:\n                continue  # already set\n            if i < j - 1:\n                dp[i][j] = dp[i][j - 1] + math.dist(points[j - 1], points[j])\n            else:\n                min_val = float('inf')\n                for k in range(j - 1):\n                    dist = dp[k][j - 1] + math.dist(points[k], points[j])\n                    if dist < min_val:\n                        min_val = dist\n                dp[i][j] = min_val\n    \n        # Fill dp[j-1][j]\n        min_val = float('inf')\n        for k in range(j - 1):\n            dist = dp[k][j - 1] + math.dist(points[k], points[j])\n            if dist < min_val:\n                min_val = dist\n        dp[j - 1][j] = min_val\n    \n    # The minimal tour distance is dp[n-1][n-1] + dist(points[n-1], points[0])\n    return dp[n - 2][n - 1] + math.dist(points[n - 1], points[0])\n\n# Example usage:\n# points = [(0, 0), (1, 1), (2, 0), (3, 1), (4, 0)]\n# print(bitonic_tsp(points))",
    "timestamp": "2025-08-13 09:52:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <limits>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n};\n\ndouble distance(const Point& a, const Point& b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\ndouble bitonicTSP(vector<Point>& points) {\n    int n = points.size();\n    sort(points.begin(), points.end(), [](const Point& a, const Point& b) {\n        return a.x < b.x;\n    });\n\n    vector<vector<double>> dp(n, vector<double>(n, numeric_limits<double>::infinity()));\n\n    dp[0][0] = 0;\n    for (int j = 1; j < n; ++j) {\n        for (int i = 0; i < j; ++i) {\n            if (i < j - 1) {\n                dp[j][i] = dp[j - 1][i] + distance(points[j - 1], points[j]);\n            } else {\n                dp[j][i] = numeric_limits<double>::infinity();\n                for (int k = 0; k < j; ++k) {\n                    dp[j][i] = min(dp[j][i], dp[j - 1][k] + distance(points[k], points[j]));\n                }\n            }\n        }\n    }\n\n    double result = numeric_limits<double>::infinity();\n    for (int i = 0; i < n - 1; ++i) {\n        result = min(result, dp[n - 1][i] + distance(points[i], points[n - 1]));\n    }\n\n    return result;\n}\n\nint main() {\n    int N;\n    cout << \"Enter number of points: \";\n    cin >> N;\n\n    vector<Point> points(N);\n    cout << \"Enter points (x y):\" << endl;\n    for (int i = 0; i < N; ++i) {\n        cin >> points[i].x >> points[i].y;\n    }\n\n    double shortestTour = bitonicTSP(points);\n    cout << \"Shortest Bitonic Tour Length: \" << shortestTour << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:55:15"
  }
]