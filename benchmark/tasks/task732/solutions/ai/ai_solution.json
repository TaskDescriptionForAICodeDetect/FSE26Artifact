[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_N 200\n#define MAX_H 200\n#define MAX_W 200\n\nint solve(int N, int H, int W, int A[MAX_N], int R[MAX_N], int C[MAX_N]) {\n    int grid[MAX_H][MAX_W] = {0};\n    int rowUsed[MAX_H] = {0};\n    int colUsed[MAX_W] = {0};\n    int maxSum = 0;\n\n    // Mark cards on grid\n    for (int i = 0; i < N; i++) {\n        grid[R[i]-1][C[i]-1] = A[i];\n    }\n\n    // Try all subsets of cards\n    for (int mask = 0; mask < (1 << N); mask++) {\n        memset(rowUsed, 0, sizeof(rowUsed));\n        memset(colUsed, 0, sizeof(colUsed));\n        int currentSum = 0;\n\n        for (int i = 0; i < N; i++) {\n            if (mask & (1 << i)) {\n                int r = R[i] - 1;\n                int c = C[i] - 1;\n\n                if (!rowUsed[r] && !colUsed[c]) {\n                    currentSum += A[i];\n                    rowUsed[r] = 1;\n                    colUsed[c] = 1;\n                }\n            }\n        }\n\n        maxSum = (currentSum > maxSum) ? currentSum : maxSum;\n    }\n\n    return maxSum;\n}\n\nint main() {\n    int N, H, W;\n    int A[MAX_N], R[MAX_N], C[MAX_N];\n\n    scanf(\"%d %d %d\", &N, &H, &W);\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d\", &A[i], &R[i], &C[i]);\n    }\n\n    printf(\"%d\\n\", solve(N, H, W, A, R, C));\n    return 0;\n}",
    "timestamp": "2025-08-05 22:43:37"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int r, c, a;\n} Card;\n\nint compare(const void *a, const void *b) {\n    return ((Card *)b)->a - ((Card *)a)->a;\n}\n\nint main() {\n    int H, W, N;\n    scanf(\"%d %d %d\", &H, &W, &N);\n    Card cards[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d %d %d\", &cards[i].r, &cards[i].c, &cards[i].a);\n        cards[i].r--;\n        cards[i].c--;\n    }\n\n    qsort(cards, N, sizeof(Card), compare);\n\n    int *row_max = (int *)malloc(H * sizeof(int));\n    int *col_max = (int *)malloc(W * sizeof(int));\n    memset(row_max, 0, H * sizeof(int));\n    memset(col_max, 0, W * sizeof(int));\n\n    int *ans = (int *)malloc(N * sizeof(int));\n    memset(ans, 0, N * sizeof(int));\n\n    int i = 0;\n    while (i < N) {\n        int j = i;\n        while (j < N && cards[j].a == cards[i].a) {\n            int r = cards[j].r;\n            int c = cards[j].c;\n            int max_val = (row_max[r] > col_max[c]) ? row_max[r] : col_max[c];\n            ans[j] = max_val + 1;\n            j++;\n        }\n\n        for (int k = i; k < j; k++) {\n            int r = cards[k].r;\n            int c = cards[k].c;\n            if (ans[k] > row_max[r]) {\n                row_max[r] = ans[k];\n            }\n            if (ans[k] > col_max[c]) {\n                col_max[c] = ans[k];\n            }\n        }\n\n        i = j;\n    }\n\n    for (int i = 0; i < N; i++) {\n        printf(\"%d\\n\", ans[i] - 1);\n    }\n\n    free(row_max);\n    free(col_max);\n    free(ans);\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:43:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <climits>\n\nusing namespace std;\n\nstruct Card {\n    int r, c, a;\n    bool operator<(const Card& other) const {\n        return a > other.a;\n    }\n};\n\nint main() {\n    int H, W, N;\n    cin >> H >> W >> N;\n    vector<Card> cards(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> cards[i].r >> cards[i].c >> cards[i].a;\n        cards[i].r--;\n        cards[i].c--;\n    }\n    \n    sort(cards.begin(), cards.end());\n    \n    map<int, int> row_max;\n    map<int, int> col_max;\n    vector<int> res(N);\n    \n    for (int i = 0; i < N; ) {\n        int current_a = cards[i].a;\n        vector<Card> batch;\n        while (i < N && cards[i].a == current_a) {\n            batch.push_back(cards[i]);\n            i++;\n        }\n        \n        vector<int> temp_res;\n        for (const auto& card : batch) {\n            int max_val = 0;\n            if (row_max.count(card.r)) {\n                max_val = max(max_val, row_max[card.r] + 1);\n            }\n            if (col_max.count(card.c)) {\n                max_val = max(max_val, col_max[card.c] + 1);\n            }\n            temp_res.push_back(max_val);\n        }\n        \n        for (int j = 0; j < batch.size(); ++j) {\n            const auto& card = batch[j];\n            int val = temp_res[j];\n            if (row_max.count(card.r)) {\n                row_max[card.r] = max(row_max[card.r], val);\n            } else {\n                row_max[card.r] = val;\n            }\n            if (col_max.count(card.c)) {\n                col_max[card.c] = max(col_max[card.c], val);\n            } else {\n                col_max[card.c] = val;\n            }\n        }\n    }\n    \n    int max_sum = 0;\n    for (const auto& entry : row_max) {\n        max_sum = max(max_sum, entry.second);\n    }\n    for (const auto& entry : col_max) {\n        max_sum = max(max_sum, entry.second);\n    }\n    \n    cout << max_sum << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:44:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int H = scanner.nextInt();\n        int W = scanner.nextInt();\n        int N = scanner.nextInt();\n        \n        List<Card> cards = new ArrayList<>();\n        for (int i = 0; i < N; i++) {\n            int R = scanner.nextInt() - 1;\n            int C = scanner.nextInt() - 1;\n            int A = scanner.nextInt();\n            cards.add(new Card(R, C, A));\n        }\n        \n        Collections.sort(cards, (a, b) -> b.A - a.A);\n        \n        int[] rowMax = new int[H];\n        int[] colMax = new int[W];\n        Arrays.fill(rowMax, -1);\n        Arrays.fill(colMax, -1);\n        \n        Map<Integer, List<Card>> groups = new HashMap<>();\n        for (int i = 0; i < N; ) {\n            int currentA = cards.get(i).A;\n            List<Card> group = new ArrayList<>();\n            while (i < N && cards.get(i).A == currentA) {\n                group.add(cards.get(i));\n                i++;\n            }\n            groups.put(currentA, group);\n        }\n        \n        int[] result = new int[N];\n        for (int i = 0; i < N; ) {\n            int currentA = cards.get(i).A;\n            List<Card> group = groups.get(currentA);\n            \n            for (Card card : group) {\n                int max = 0;\n                if (rowMax[card.R] != -1) {\n                    max = Math.max(max, rowMax[card.R] + 1);\n                }\n                if (colMax[card.C] != -1) {\n                    max = Math.max(max, colMax[card.C] + 1);\n                }\n                result[card.idx] = max;\n            }\n            \n            for (Card card : group) {\n                if (rowMax[card.R] < result[card.idx]) {\n                    rowMax[card.R] = result[card.idx];\n                }\n                if (colMax[card.C] < result[card.idx]) {\n                    colMax[card.C] = result[card.idx];\n                }\n            }\n            \n            i += group.size();\n        }\n        \n        int maxSum = 0;\n        for (int val : result) {\n            maxSum = Math.max(maxSum, val);\n        }\n        System.out.println(maxSum);\n    }\n    \n    static class Card {\n        int R, C, A, idx;\n        static int counter = 0;\n        \n        Card(int R, int C, int A) {\n            this.R = R;\n            this.C = C;\n            this.A = A;\n            this.idx = counter++;\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:44:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MaxCardSum {\n    public static int maxCardSum(int H, int W, int[] A, int[] R, int[] C) {\n        int[][] grid = new int[H][W];\n        for (int i = 0; i < A.length; i++) {\n            grid[R[i]][C[i]] = A[i];\n        }\n        \n        return maxSumHelper(grid, 0, new boolean[H], new boolean[W]);\n    }\n    \n    private static int maxSumHelper(int[][] grid, int row, boolean[] rowUsed, boolean[] colUsed) {\n        if (row == grid.length) {\n            return 0;\n        }\n        \n        int maxSum = maxSumHelper(grid, row + 1, rowUsed, colUsed);\n        \n        for (int col = 0; col < grid[row].length; col++) {\n            if (!rowUsed[row] && !colUsed[col]) {\n                rowUsed[row] = true;\n                colUsed[col] = true;\n                \n                int currentSum = grid[row][col] + maxSumHelper(grid, row + 1, rowUsed, colUsed);\n                maxSum = Math.max(maxSum, currentSum);\n                \n                rowUsed[row] = false;\n                colUsed[col] = false;\n            }\n        }\n        \n        return maxSum;\n    }\n}",
    "timestamp": "2025-08-05 22:44:53"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint solve(int H, int W, vector<int>& A, vector<int>& R, vector<int>& C) {\n    vector<vector<int>> grid(H, vector<int>(W, 0));\n    \n    for (int i = 0; i < A.size(); i++) {\n        grid[R[i]-1][C[i]-1] = A[i];\n    }\n    \n    vector<vector<int>> dp(1 << H, vector<int>(1 << W, 0));\n    \n    for (int row_mask = 0; row_mask < (1 << H); row_mask++) {\n        for (int col_mask = 0; col_mask < (1 << W); col_mask++) {\n            for (int r = 0; r < H; r++) {\n                if (row_mask & (1 << r)) continue;\n                \n                for (int c = 0; c < W; c++) {\n                    if (col_mask & (1 << c)) continue;\n                    \n                    dp[row_mask | (1 << r)][col_mask | (1 << c)] = \n                        max(dp[row_mask | (1 << r)][col_mask | (1 << c)], \n                            dp[row_mask][col_mask] + grid[r][c]);\n                }\n            }\n        }\n    }\n    \n    return dp[(1 << H) - 1][(1 << W) - 1];\n}\n\nint main() {\n    int H, W, N;\n    cin >> H >> W >> N;\n    \n    vector<int> A(N), R(N), C(N);\n    \n    for (int i = 0; i < N; i++) {\n        cin >> A[i] >> R[i] >> C[i];\n    }\n    \n    cout << solve(H, W, A, R, C) << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:45:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_card_sum(N, H, W, cards):\n    from collections import defaultdict\n    from itertools import chain\n\n    # Create adjacency list for each row and column with card values\n    row_cards = defaultdict(list)\n    col_cards = defaultdict(list)\n    \n    for A_i, R_i, C_i in cards:\n        row_cards[R_i].append((A_i, R_i, C_i))\n        col_cards[C_i].append((A_i, R_i, C_i))\n\n    # Function to calculate maximum sum using brute force within row-card and col-card constraints\n    def calculate_max_sum(row_cards, col_cards):\n        # Keep track of used rows and columns\n        used_rows = set()\n        used_cols = set()\n        \n        all_cards = sorted(chain.from_iterable(row_cards.values()), reverse=True, key=lambda x: x[0])\n\n        total_sum = 0\n        for A_i, R_i, C_i in all_cards:\n            # Only consider card if row and column not yet used\n            if R_i not in used_rows and C_i not in used_cols:\n                total_sum += A_i\n                used_rows.add(R_i)\n                used_cols.add(C_i)\n\n        return total_sum\n    \n    return calculate_max_sum(row_cards, col_cards)\n\n# Example usage\nN = 5\nH = 3\nW = 3\ncards = [(8, 1, 1), (9, 1, 2), (7, 2, 1), (6, 2, 2), (5, 3, 3)]\nprint(max_card_sum(N, H, W, cards))  # Example output: 22",
    "timestamp": "2025-08-13 12:19:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MaxCardSum {\n    public static int maxCardSum(int N, int H, int W, int[] A, int[] R, int[] C) {\n        Map<Integer, PriorityQueue<Integer>> rowMap = new HashMap<>();\n        Map<Integer, PriorityQueue<Integer>> colMap = new HashMap<>();\n\n        for (int i = 0; i < N; i++) {\n            rowMap.computeIfAbsent(R[i], k -> new PriorityQueue<>(Collections.reverseOrder())).offer(A[i]);\n            colMap.computeIfAbsent(C[i], k -> new PriorityQueue<>(Collections.reverseOrder())).offer(A[i]);\n        }\n\n        boolean[] usedRows = new boolean[H + 1];\n        boolean[] usedCols = new boolean[W + 1];\n        int maxSum = 0;\n\n        while (true) {\n            int maxRowValue = 0;\n            int maxRowIndex = -1;\n\n            for (int row : rowMap.keySet()) {\n                if (!usedRows[row] && rowMap.get(row).peek() != null && rowMap.get(row).peek() > maxRowValue) {\n                    maxRowValue = rowMap.get(row).peek();\n                    maxRowIndex = row;\n                }\n            }\n\n            int maxColValue = 0;\n            int maxColIndex = -1;\n\n            for (int col : colMap.keySet()) {\n                if (!usedCols[col] && colMap.get(col).peek() != null && colMap.get(col).peek() > maxColValue) {\n                    maxColValue = colMap.get(col).peek();\n                    maxColIndex = col;\n                }\n            }\n\n            if (maxRowValue == 0 && maxColValue == 0) {\n                break;\n            }\n\n            if (maxRowValue >= maxColValue) {\n                maxSum += maxRowValue;\n                usedRows[maxRowIndex] = true;\n                rowMap.get(maxRowIndex).poll();\n            } else {\n                maxSum += maxColValue;\n                usedCols[maxColIndex] = true;\n                colMap.get(maxColIndex).poll();\n            }\n        }\n\n        return maxSum;\n    }\n\n    public static void main(String[] args) {\n        int N = 5;\n        int H = 3;\n        int W = 3;\n        int[] A = {6, 9, 7, 5, 1};\n        int[] R = {1, 1, 2, 3, 3};\n        int[] C = {1, 2, 3, 1, 3};\n        System.out.println(maxCardSum(N, H, W, A, R, C)); // Example usage\n    }\n}",
    "timestamp": "2025-08-13 12:19:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_H 50\n#define MAX_W 50\n#define MAX_N 50\n\ntypedef struct {\n    int a;\n    int r;\n    int c;\n} card;\n\nint cmp(const void* a, const void* b) {\n    card* ca = (card*)a;\n    card* cb = (card*)b;\n    return cb->a - ca->a;\n}\n\nint main() {\n    int H, W, N;\n    scanf(\"%d %d %d\", &H, &W, &N);\n\n    card cards[MAX_N];\n    for (int i = 0; i < N; ++i) {\n        scanf(\"%d %d %d\", &cards[i].r, &cards[i].c, &cards[i].a);\n    }\n    \n    qsort(cards, N, sizeof(card), cmp);\n\n    int rowPicked[MAX_H + 1];\n    int colPicked[MAX_W + 1];\n    memset(rowPicked, 0, sizeof(rowPicked));\n    memset(colPicked, 0, sizeof(colPicked));\n\n    int maxSum = 0;\n    for (int i = 0; i < N; ++i) {\n        int r = cards[i].r;\n        int c = cards[i].c;\n        \n        if (!rowPicked[r] && !colPicked[c]) {\n            maxSum += cards[i].a;\n            rowPicked[r] = 1;\n            colPicked[c] = 1;\n        }\n    }\n\n    printf(\"%d\\n\", maxSum);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:19:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxSum(N, H, W, cards) {\n    const dp = Array.from({ length: H }, () => Array(W).fill(0));\n    const maxRow = Array(H).fill(0);\n    const maxCol = Array(W).fill(0);\n    \n    for (let i = 0; i < N; i++) {\n        const [r, c, a] = cards[i];\n        dp[r][c] = a;\n        maxRow[r] = Math.max(maxRow[r], a);\n        maxCol[c] = Math.max(maxCol[c], a);\n    }\n    \n    let pickedRow = new Array(H).fill(false);\n    let pickedCol = new Array(W).fill(false);\n    let totalSum = 0;\n    \n    for (let i = 0; i < H; i++) {\n        for (let j = 0; j < W; j++) {\n            if (dp[i][j] > 0 && !pickedRow[i] && !pickedCol[j] &&\n                dp[i][j] === maxRow[i] && dp[i][j] === maxCol[j]) {\n                totalSum += dp[i][j];\n                pickedRow[i] = true;\n                pickedCol[j] = true;\n            }\n        }\n    }\n    \n    return totalSum;\n}",
    "timestamp": "2025-08-13 12:19:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_card_sum(H, W, N, cards):\n    # Create a 2D grid to represent card values\n    grid = [[0] * W for _ in range(H)]\n    \n    # Populate the grid with card values\n    for card in cards:\n        grid[card[0]-1][card[1]-1] = card[2]\n    \n    # Use Hungarian algorithm (maximum weighted matching)\n    from scipy.optimize import linear_sum_assignment\n    import numpy as np\n    \n    # Negate values for maximum sum problem\n    cost_matrix = -np.array(grid)\n    \n    # Solve assignment problem\n    row_ind, col_ind = linear_sum_assignment(cost_matrix)\n    \n    # Calculate maximum sum\n    max_sum = sum(grid[r][c] for r, c in zip(row_ind, col_ind))\n    \n    return max_sum",
    "timestamp": "2025-08-13 12:19:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function maxCardSum(H, W, cards) {\n    const dp = Array.from({ length: H }, () => Array(1 << W).fill(-Infinity));\n    dp[0] = Array(1 << W).fill(0);\n\n    for (let row = 0; row < H; row++) {\n        const rowCards = cards.filter(card => card[0] === row);\n\n        for (let prevState = 0; prevState < (1 << W); prevState++) {\n            if (dp[row][prevState] === -Infinity) continue;\n\n            for (const card of rowCards) {\n                const col = card[1];\n                const value = card[2];\n\n                if (!(prevState & (1 << col))) {\n                    const newState = prevState | (1 << col);\n                    dp[row + 1][newState] = Math.max(\n                        dp[row + 1][newState],\n                        dp[row][prevState] + value\n                    );\n                }\n            }\n\n            dp[row + 1][prevState] = Math.max(\n                dp[row + 1][prevState] || -Infinity,\n                dp[row][prevState]\n            );\n        }\n    }\n\n    return Math.max(...dp[H]);\n}",
    "timestamp": "2025-08-13 12:19:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    H, W, N = map(int, data[idx:idx+3])\n    idx +=3\n    \n    rows = [[] for _ in range(H+1)]\n    cols = [[] for _ in range(W+1)]\n    cards = []\n    \n    for _ in range(N):\n        r, c, a = map(int, data[idx:idx+3])\n        idx +=3\n        rows[r].append((a, c))\n        cols[c].append((a, r))\n        cards.append((a, r, c))\n    \n    # Sort each row and column in descending order\n    for r in range(1, H+1):\n        rows[r].sort(reverse=True)\n    for c in range(1, W+1):\n        cols[c].sort(reverse=True)\n    \n    # Sort all cards in descending order\n    cards.sort(reverse=True)\n    \n    max_row = [0]*(H+1)\n    max_col = [0]*(W+1)\n    dp = {}\n    \n    for a, r, c in cards:\n        current = 0\n        # Check row's best\n        if rows[r] and rows[r][0][0] > a:\n            current = max_row[r] + 1\n        # Check column's best\n        if cols[c] and cols[c][0][0] > a:\n            current = max(current, max_col[c] + 1)\n        # Default is 0 if no larger neighbors\n        dp[(r, c)] = current\n        # Update row and column max\n        if current > max_row[r]:\n            max_row[r] = current\n        if current > max_col[c]:\n            max_col[c] = current\n    \n    # The answer is the maximum value in dp plus 1 (since we start from 0)\n    max_value = max(dp.values()) if dp else 0\n    print(max_value + 1)\n\nsolve()",
    "timestamp": "2025-08-13 12:20:04"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve() {\n    const input = require('fs').readFileSync(0, 'utf8').trim().split('\\n');\n    let ptr = 0;\n    const [H, W, N] = input[ptr++].split(' ').map(Number);\n    const cards = [];\n    for (let i = 0; i < N; i++) {\n        const [R, C, A] = input[ptr++].split(' ').map(Number);\n        cards.push({ r: R - 1, c: C - 1, a: A });\n    }\n\n    // Sort cards in descending order of A\n    cards.sort((a, b) => b.a - a.a);\n\n    const rowMax = new Array(H).fill(0);\n    const colMax = new Array(W).fill(0);\n    const res = new Map();\n\n    let i = 0;\n    while (i < N) {\n        let j = i;\n        const batch = [];\n        while (j < N && cards[j].a === cards[i].a) {\n            const { r, c } = cards[j];\n            const max = Math.max(rowMax[r], colMax[c]) + 1;\n            res.set(`${r},${c}`, max - 1);\n            batch.push({ r, c, val: max - 1 });\n            j++;\n        }\n\n        for (const { r, c, val } of batch) {\n            rowMax[r] = Math.max(rowMax[r], val);\n            colMax[c] = Math.max(colMax[c], val);\n        }\n\n        i = j;\n    }\n\n    let maxSum = 0;\n    for (const [key, val] of res) {\n        maxSum += val;\n    }\n    console.log(maxSum);\n}\n\nsolve();",
    "timestamp": "2025-08-13 12:20:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\nstruct Card {\n    int value;\n    int row;\n    int col;\n};\n\nint main() {\n    int H, W, N;\n    cin >> H >> W >> N;\n    \n    vector<Card> cards(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> cards[i].row >> cards[i].col >> cards[i].value;\n    }\n\n    // Sort cards by value in descending order\n    sort(cards.begin(), cards.end(), [](const Card& a, const Card& b) {\n        return a.value > b.value;\n    });\n\n    // Track used rows and columns\n    vector<bool> used_rows(H+1, false);\n    vector<bool> used_cols(W+1, false);\n\n    // Calculate maximum sum\n    int max_sum = 0;\n    for (const auto& card : cards) {\n        if (!used_rows[card.row] && !used_cols[card.col]) {\n            max_sum += card.value;\n            used_rows[card.row] = true;\n            used_cols[card.col] = true;\n        }\n    }\n\n    cout << max_sum << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 14:34:08"
  }
]