[
  {
    "language": "Crystal",
    "code": "class Card\n  property :r, :c, :n, :used\n\n  def initialize(@r : Int32, @c : Int32, @n : Int32)\n    @used = false\n  end\nend\n\nn, h, w = read_line.split.map(&.to_i)\nrs = Array.new(h + 1) { [] of Card }\ncs = Array.new(w + 1) { [] of Card }\nn.times do\n  r, c, a = read_line.split.map(&.to_i)\n  card = Card.new(r, c, a)\n  rs[r] << card\n  cs[c] << card\nend\ntake = [] of {Int32, Int32}\n1.upto(h) do |i|\n  next if rs[i].empty?\n  max = rs[i].max_of { |card| card.n }\n  take << {max, i}\nend\n1.upto(w) do |i|\n  next if cs[i].empty?\n  max = cs[i].max_of { |card| card.n }\n  take << {max, -i}\nend\nans = 0i64\ntake.sort.each do |t|\n  if t[1] > 0\n    c = rs[t[1]].select { |card| !card.used }.max_by { |card| card.n }\n    if c\n      c.used = true\n      ans += c.n\n    end\n  else\n    c = cs[-t[1]].select { |card| !card.used }.max_by { |card| card.n }\n    if c\n      c.used = true\n      ans += c.n\n    end\n  end\nend\nputs ans\n"
  },
  {
    "language": "Crystal",
    "code": "class Card\n  property :r, :c, :n, :used\n\n  def initialize(@r : Int32, @c : Int32, @n : Int32)\n    @used = false\n  end\nend\n\nn, h, w = read_line.split.map(&.to_i)\nrs = Array.new(h + 1) { [] of Card }\ncs = Array.new(w + 1) { [] of Card }\nn.times do\n  r, c, a = read_line.split.map(&.to_i)\n  card = Card.new(r, c, a)\n  rs[r] << card\n  cs[c] << card\nend\nq = PriorityQueue({Int32, Int32, Int32}).new(n)\nused_r = Array.new(h + 1, false)\nused_c = Array.new(w + 1, false)\n1.upto(h) do |i|\n  row = rs[i]\n  next if row.empty?\n  row.sort_by! { |card| card.n }\n  q.add({-row[-1].n, row.size == 1 ? 1 : -row[row.size - 2].n, i})\nend\n1.upto(w) do |i|\n  col = cs[i]\n  next if col.empty?\n  col.sort_by! { |card| card.n }\n  q.add({-col[-1].n, col.size == 1 ? 1 : -col[col.size - 2].n, -i})\nend\nans = 0i64\nwhile q.size > 0\n  t = q.pop\n  if t[2] > 0\n    next if used_r[t[2]]\n    used_r[t[2]] = true\n    c = rs[t[2]].select { |card| !card.used }.max_by? { |card| card.n }\n    if c\n      c.used = true\n      ans += c.n\n      if !used_c[c.c]\n        col = cs[c.c]\n        col.delete(c)\n        if !col.empty?\n          q.add({-col[-1].n, col.size == 1 ? 1 : -col[col.size - 2].n, -c.c})\n        end\n      end\n    end\n  else\n    next if used_c[-t[2]]\n    used_c[-t[2]] = true\n    c = cs[-t[2]].select { |card| !card.used }.max_by? { |card| card.n }\n    if c\n      c.used = true\n      ans += c.n\n      if !used_r[c.r]\n        row = rs[c.r]\n        row.delete(c)\n        if !row.empty?\n          q.add({-row[-1].n, row.size == 1 ? 1 : -row[row.size - 2].n, c.r})\n        end\n      end\n    end\n  end\nend\nputs ans\n\nclass PriorityQueue(T)\n  def initialize(capacity : Int32)\n    @elem = Array(T).new(capacity)\n  end\n\n  def initialize(list : Enumerable(T))\n    @elem = list.to_a\n    1.upto(size - 1) { |i| fixup(i) }\n  end\n\n  def size\n    @elem.size\n  end\n\n  def add(v)\n    @elem << v\n    fixup(size - 1)\n  end\n\n  def top\n    @elem[0]\n  end\n\n  def pop\n    ret = @elem[0]\n    last = @elem.pop\n    if size > 0\n      @elem[0] = last\n      fixdown(0)\n    end\n    ret\n  end\n\n  def decrease_top(new_value : T)\n    @elem[0] = new_value\n    fixdown(0)\n  end\n\n  def to_s(io : IO)\n    io << @elem\n  end\n\n  private def fixup(index : Int32)\n    while index > 0\n      parent = (index - 1) / 2\n      break if @elem[parent] >= @elem[index]\n      @elem[parent], @elem[index] = @elem[index], @elem[parent]\n      index = parent\n    end\n  end\n\n  private def fixdown(index : Int32)\n    while true\n      left = index * 2 + 1\n      break if left >= size\n      right = index * 2 + 2\n      child = right >= size || @elem[left] > @elem[right] ? left : right\n      if @elem[child] > @elem[index]\n        @elem[child], @elem[index] = @elem[index], @elem[child]\n        index = child\n      else\n        break\n      end\n    end\n  end\nend\n"
  },
  {
    "language": "Crystal",
    "code": "class Card\n  property :r, :c, :n, :used\n\n  def initialize(@r : Int32, @c : Int32, @n : Int32)\n    @used = false\n  end\nend\n\nn, h, w = read_line.split.map(&.to_i)\nrs = Array.new(h + 1) { [] of Card }\ncs = Array.new(w + 1) { [] of Card }\nn.times do\n  r, c, a = read_line.split.map(&.to_i)\n  card = Card.new(r, c, a)\n  rs[r] << card\n  cs[c] << card\nend\nq = PriorityQueue({Int32, Int32, Int32}).new(n)\nused_r = Array.new(h + 1, false)\nused_c = Array.new(w + 1, false)\n1.upto(h) do |i|\n  next if rs[i].empty?\n  rs[i].sort_by! { |card| card.n }\n  q.add({rs[i][-1].n, rs.size == 1 ? -1 : rs[i][rs[i].size - 2].n, i})\nend\n1.upto(w) do |i|\n  next if cs[i].empty?\n  cs[i].sort_by! { |card| card.n }\n  q.add({cs[i][-1].n, cs.size == 1 ? -1 : cs[i][cs[i].size - 2].n, -i})\nend\nans = 0i64\nwhile q.size > 0\n  t = q.pop\n  if t[2] > 0\n    c = rs[t[2]].select { |card| !card.used }.max_by? { |card| card.n }\n    if c\n      c.used = true\n      ans += c.n\n    end\n  else\n    c = cs[-t[2]].select { |card| !card.used }.max_by? { |card| card.n }\n    if c\n      c.used = true\n      ans += c.n\n    end\n  end\nend\nputs ans\n\nclass PriorityQueue(T)\n  def initialize(capacity : Int32)\n    @elem = Array(T).new(capacity)\n  end\n\n  def initialize(list : Enumerable(T))\n    @elem = list.to_a\n    1.upto(size - 1) { |i| fixup(i) }\n  end\n\n  def size\n    @elem.size\n  end\n\n  def add(v)\n    @elem << v\n    fixup(size - 1)\n  end\n\n  def top\n    @elem[0]\n  end\n\n  def pop\n    ret = @elem[0]\n    last = @elem.pop\n    if size > 0\n      @elem[0] = last\n      fixdown(0)\n    end\n    ret\n  end\n\n  def decrease_top(new_value : T)\n    @elem[0] = new_value\n    fixdown(0)\n  end\n\n  def to_s(io : IO)\n    io << @elem\n  end\n\n  private def fixup(index : Int32)\n    while index > 0\n      parent = (index - 1) / 2\n      break if @elem[parent] >= @elem[index]\n      @elem[parent], @elem[index] = @elem[index], @elem[parent]\n      index = parent\n    end\n  end\n\n  private def fixdown(index : Int32)\n    while true\n      left = index * 2 + 1\n      break if left >= size\n      right = index * 2 + 2\n      child = right >= size || @elem[left] > @elem[right] ? left : right\n      if @elem[child] > @elem[index]\n        @elem[child], @elem[index] = @elem[index], @elem[child]\n        index = child\n      else\n        break\n      end\n    end\n  end\nend\n"
  },
  {
    "language": "Crystal",
    "code": "class Card\n  property :r, :c, :n, :used\n\n  def initialize(@r : Int32, @c : Int32, @n : Int32)\n    @used = false\n  end\nend\n\nn, h, w = read_line.split.map(&.to_i)\nrs = Array.new(h + 1) { [] of Card }\ncs = Array.new(w + 1) { [] of Card }\nn.times do\n  r, c, a = read_line.split.map(&.to_i)\n  card = Card.new(r, c, a)\n  rs[r] << card\n  cs[c] << card\nend\ntake = [] of {Int32, Int32}\n1.upto(h) do |i|\n  next if rs[i].empty?\n  max = rs[i].max_of { |card| card.n }\n  take << {max, i}\nend\n1.upto(w) do |i|\n  next if cs[i].empty?\n  max = cs[i].max_of { |card| card.n }\n  take << {max, -i}\nend\nans = 0i64\ntake.sort.each do |t|\n  if t[1] > 0\n    c = rs[t[1]].select { |card| !card.used }.max_by? { |card| card.n }\n    if c\n      c.used = true\n      ans += c.n\n    end\n  else\n    c = cs[-t[1]].select { |card| !card.used }.max_by? { |card| card.n }\n    if c\n      c.used = true\n      ans += c.n\n    end\n  end\nend\nputs ans\n"
  },
  {
    "language": "Fortran",
    "code": "\n\n  module UnionFind\n    implicit none\n    public\n        type :: Union_Find\n            integer(8),allocatable,dimension(:) :: par\n        end type Union_Find\n    contains\n        subroutine init(p,n)\n            implicit none\n            type(Union_Find)  p\n            integer(8) n,i\n            allocate( p%par(n) )\n            do i=1,n\n                p%par(i) = i\n            enddo\n        end subroutine init\n        recursive function root(p,n) result(ret)\n            implicit none\n            type(Union_Find) p\n            integer(8) ret,n\n            if(p%par(n)==n)then\n                ret = n\n                return\n            else\n                p%par(n) = root(p,p%par(n))\n                ret = p%par(n)\n                return\n            endif\n        end\n        subroutine unite(p,a,b)\n            implicit none\n            type(Union_Find) p\n            integer(8) a,b\n            a = root(p,a)\n            b = root(p,b)\n            if(a/=b)then\n                p%par(a) = b\n            endif\n        end\nend module UnionFind\n\n\n\n\n\n\n\n\nprogram atcoder\n    use UnionFind\n    implicit none\n    type(Union_Find) uf\n    integer(8) :: n,k,i,ans=0_8,j,h,w\n    integer(8),allocatable,dimension(:) :: a1,a2,ind,r,c\n    read*,n,h,w\n    call init(uf,h+w+5)\n    allocate( a1(n),a2(n),ind(n),r(n),c(n) )\n    do i=1,n\n        read(*,*)r(i),c(i),a1(i)\n        ind(i) = i;\n        a2(i) = a1(i);\n    enddo\n    call sort(a1,ind)\n    a1 = a2\n    call sort(a1,r)\n    a1 = a2\n    call sort(a1,c)\n\n    do i = n,1,-1\n        if(root(uf,r(i))/=root(uf,c(i)+h))then\n            call unite(uf,r(i),c(i)+h)\n            ans = ans + a1(i)\n        else if(root(uf,r(i))/=root(uf,h+w+3))then\n            ans = ans + a1(i)\n            call unite(uf,r(i),h+w+3)\n        endif\n    enddo\n    write(*,'(I0)')ans\n\n\n  !----------------------functions--------------------------\n  contains\n  recursive subroutine mergesort(a, p, r, b,ia,ib)\n  integer(8) a(:), b(:),ia(:),ib(:)\n  integer(8) p, r\n  integer(8) q\n  if (p < r) then\n    q = (p+r)/2\n    call mergesort(a, p, q, b,ia,ib)\n    call mergesort(a, q+1, r, b,ia,ib)\n    call merge(a, p, q, r, b, ia,ib)\n  end if\n  end subroutine mergesort\n  subroutine merge(a, p, q, r, b, ia,ib)\n    integer(8) a(:), b(:),ia(:),ib(:)\n    integer(8) p, r, q, i, j, k\n    integer(8) t,ti\n    k = p;   i = p;   j = q+1\n    do\n      if (.not. (k <= r)) exit\n      if (j > r) then\n        t = a(i); ti = ia(i); i = i+1\n      else if (i > q) then\n        t = a(j); ti = ia(j); j = j+1\n        \n      else if (a(i) <= a(j)) then\n        t = a(i); ti = ia(i); i = i+1\n      else\n        t = a(j); ti = ia(j); j = j+1\n      end if\n      b(k) = t; ib(k) = ti; k = k+1\n\n    end do\n    do i = p, r\n      a(i) = b(i)\n      ia(i) = ib(i)\n    end do\n  end subroutine merge\n  subroutine sort(a,ia)\n    integer(8) a(:), b(size(a)),n,ia(:),ib(size(a))\n    n = size(a)\n    call mergesort(a,1_8,n,b,ia,ib)\n  end subroutine sort\n  end program atcoder\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pl = pair<ll, ll>;\n\nint root[200002];\nint vsz[200002], esz[200002];\nint n, h, w;\nint get_root(int x)\n{\n    return root[x] = (root[x] == x ? x : get_root(root[x]));\n}\nint merge(int x, int y)\n{\n    x = get_root(x);\n    y = get_root(y);\n    if(x != y && vsz[x] + vsz[y] >= esz[x] + esz[y] + 1)\n    {\n        root[y] = x;\n        vsz[x] += vsz[y];\n        esz[x] += esz[y] + 1;\n        return 1;\n    }\n    if(x == y && vsz[x] > esz[x])\n    {\n        esz[x]++;\n        return 1;\n    }\n    return 0;\n}\nstruct edge{\n    int x, a, b;\n};\n\nvector<edge> v;\nint main(){\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    cin >> n >> h >> w;\n    for(int i=1;i<=h+w;i++)\n        root[i] = i, vsz[i] = 1;\n    for(int i=0;i<n;i++)\n    {\n        int x,a,b;\n        cin >> a >> b >> x;\n        v.push_back({x, a, h+b});\n    }\n    sort(v.begin(), v.end(), [] (edge& A, edge& B){\n        return A.x > B.x;\n    });\n\n    ll ans = 0;\n    for(edge& e : v)\n    {\n        if(merge(e.a, e.b))\n        {\n            ans += e.x;\n        }\n    }\n    cout << ans;\n}"
  },
  {
    "language": "C++",
    "code": "//Utkarsh.25dec\n#include <bits/stdc++.h>\n#include <chrono>\n#include <random>\n#define ll long long int\n#define ull unsigned long long int\n#define pb push_back\n#define mp make_pair\n#define mod 1000000007\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define loop(i,a,b) for(ll i=a;i<=b;i++)\n#define vi vector <int>\n#define vs vector <string>\n#define vc vector <char>\n#define vl vector <ll>\n#define all(c) (c).begin(),(c).end()\n#define max3(a,b,c) max(max(a,b),c)\n#define min3(a,b,c) min(min(a,b),c)\n#define deb(x) cerr<<#x<<' '<<'='<<' '<<x<<'\\n'\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\n// ordered_set s ; s.order_of_key(val)  no. of elements strictly less than val\n// s.find_by_order(i)  itertor to ith element (0 indexed)\ntypedef vector<vector<ll>> matrix;\nll power(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll modInverse(ll a){return power(a,mod-2);}\nconst int N=500023;\nbool vis[N];\nvector <int> adj[N];\nll par[N];\nll sz[N];\nll find(ll curr)\n{\n    while(curr!=par[curr])\n        curr=par[curr];\n    return curr;\n}\nvoid merge(ll x,ll y)\n{\n    if(sz[x]>=sz[y])\n    {\n        par[y]=x;\n        sz[x]+=sz[y];\n    }\n    else\n    {\n        par[x]=y;\n        sz[y]+=sz[x];\n    }\n}\nvoid solve()\n{\n    ll n,h,w;\n    cin>>n>>h>>w;\n    vector <tuple<ll,ll,ll>> v;\n    for(int i=0;i<n;i++)\n    {\n        ll a,b,c;\n        cin>>a>>b>>c;\n        v.pb(make_tuple(c,a,b));\n    }\n    for(int i=1;i<N;i++)\n    {\n        sz[i]=1;\n        par[i]=i;\n    }\n    sort(all(v));\n    reverse(all(v));\n    ll ans=0;\n    for(auto t:v)\n    {\n        ll add=get<0>(t);\n        ll r=get<1>(t);\n        ll c=get<2>(t);\n        r+=1e5;\n        r=find(r);\n        c=find(c);\n        if(vis[r] && vis[c])\n            continue;\n        if(r==c)\n        {\n            if(vis[r]==0)\n            {\n                vis[r]=1;\n                ans+=add;\n                continue;\n            }\n            else\n                continue;\n        }\n        else\n        {\n            merge(r,c);\n            ans+=add;\n        }\n    }\n    cout<<ans<<'\\n';\n}\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int T=1;\n    //cin>>T;\n    int t=0;\n    while(t++<T)\n    {\n        //cout<<\"Case #\"<<t<<\":\"<<' ';\n        solve();\n        //cout<<'\\n';\n    }\n    cerr << \"Time : \" << 1000 * ((double)clock()) / (double)CLOCKS_PER_SEC << \"ms\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tusing T = tuple<int,int,int>;\n\t\n\tint n, h, w; cin >> n >> h >> w;\n\tvector<T> v;\n\trep(i, n){\n\t\tint r, c, a; cin >> r >> c >> a;\n\t\tv.emplace_back(r, c, a);\n\t}\n\t\n\tauto process = [&](function<int(T)> f){\n\t\tll res = 0;\n\t\tmap<int,int> m;\n\t\tfor(T i : v) m[f(i)] = max(m[f(i)], get<2>(i));\n\t\tfor(auto i : m) res += i.second;\n\t\t\n\t\tvector<T> nv;\n\t\tfor(T i : v) if(m.count(f(i)) && m[f(i)] == get<2>(i)) m.erase(f(i));\n\t\telse nv.emplace_back(i);\n\t\tv = nv;\n\t\treturn res;\n\t};\n\tfor(T i : v) dbg(get<0>(i), get<1>(i), get<2>(i)); cerr<<endl;\n\tll ans = process([](T t){ return get<0>(t); });\n\tfor(T i : v) dbg(get<0>(i), get<1>(i), get<2>(i));\n\tans += process([](T t){ return get<1>(t); });\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define ii pair <int, int>\n#define app push_back\n#define all(a) a.begin(), a.end()\n#define bp __builtin_popcountll\n#define ll long long\n#define mp make_pair\n#define f first\n#define s second\n#define Time (double)clock()/CLOCKS_PER_SEC\n\nconst int N = 1e6 + 7;\n\nstruct Edge {\n    int u, v, c;\n    bool operator < (Edge e) {\n        return c < e.c;\n    }   \n};  \n\nint par[N];\nbool cyc[N];\n\nint root(int u) {\n    if (u == par[u])\n        return u;\n    else\n        return par[u] = root(par[u]);\n}   \n\nsigned main() {\n    #ifdef HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    #else\n    #define endl '\\n'\n    ios_base::sync_with_stdio(0); cin.tie(0);\n    #endif\n\n    int k, n, m;\n    cin >> k >> n >> m;\n    vector <Edge> a(k);\n    for (int i = 0; i < k; ++i) {\n        cin >> a[i].u >> a[i].v >> a[i].c;\n        a[i].v += n;                \n    }   \n\n    sort(all(a));\n    reverse(all(a));\n\n    for (int i = 0; i < N; ++i)\n        par[i] = i;\n    int ans = 0;\n    for (auto e : a) {\n        int u = root(e.u), v = root(e.v);\n        if (u == v) {\n            if (cyc[u])\n                continue;\n            ans += e.c;\n            cyc[u] = 1;\n\n            //cout << \"add \" << e.u << ' ' << e.v << ' ' << e.c << endl;\n\n        }   \n        else {\n            if (cyc[u] && cyc[v]) {\n                continue;\n            }   \n            ans += e.c;\n            par[u] = v;\n            cyc[v] |= cyc[u];\n\n            //cout << \"add \" << e.u << ' ' << e.v << ' ' << e.c << endl;\n\n        }   \n    }   \n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n\nconst int N = 200200;\nconst long long mod = 1e9 + 7;\n\nusing namespace std;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint n;\nint m;\nint q;\nint p[N];\nvector < int > v[N], backup;\nbool used[N];\n\nbool dfs(int x)\n{\n        used[x] = true;\n        backup.push_back(x);\n        for(int y: v[x]){\n                if(p[y] == -1){\n                        p[y] = x;\n                        return true;\n                } else if(!used[p[y]] && dfs(p[y])){\n                        p[y] = x;\n                        return true;\n                }\n        }\n        return false;\n}\n\nint main()\n{\n        ios_base::sync_with_stdio(0);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        cin >> q >> n >> m;\n        for(int i = 1; i <= n + m; i++){\n                p[i] = -1;\n        }\n        vector < pair < int, int > > qu;\n        for(int i = 1; i <= q; i++){\n                int x, y, w;\n                cin >> x >> y >> w;\n                v[i].push_back(x);\n                v[i].push_back(y + n);\n                qu.push_back({w, i});\n\n                shuffle(v[i].begin(), v[i].end(), rng);\n        }\n        sort(qu.begin(), qu.end());\n        reverse(qu.begin(), qu.end());\n        long long res = 0;\n        for(auto g: qu){\n                if(dfs(g.se)){\n                        res += g.fi;\n                        while(!backup.empty()){\n                                used[backup.back()] = false;\n                                backup.pop_back();\n                        }\n                }\n        }\n        cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = ll(A); I < ll(B); ++I)\n#define FORR(I,A,B) for(ll I = ll((B)-1); I >= ll(A); --I)\n#define TO(x,t,f) ((x)?(t):(f))\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //xi>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //xi>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\nll gcd(ll a,ll b){if(a%b==0)return b;return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nconst ll INF=ll(1e18)+ll(7);\nconst ll MOD=1000000007LL;\n#define out(a) cout<<fixed<<setprecision((a))\n\nclass UnionFind{\npublic:\n\tvector<int> par;\n\t//0-indexed\n\tUnionFind(int n){init(n);}\n\tvoid init(int n = 1) {\n\t\tpar.resize(n);\n\t\tfor (int i = 0; i < n; ++i) par[i] = i;\n\t}\n\tint root(int x = 1){\n\t\tif(par[x]==x)return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n\tvoid unite(int x = 1,int y = 1){\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif(x==y)return;\n\t\tpar[x] = y;\n\t}\n\tbool same(int x,int y){\n\t\treturn root(x)==root(y);\n\t}\n};\n\n\n// なもりグラフ\n// https://www.hamayanhamayan.com/entry/2019/08/25/090415\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint N,H,W;\n\tll ans = 0;\n\tcin >> N >> H >> W;\n\tUnionFind uf(H+W+6);\n\tpriority_queue< pair<ll,P> > pq;\n\tFOR(i,0,N){\n\t\tint r,c,a;\n\t\tcin >> r >> c >> a;\n\t\tpq.push({a,{r,c}});\n\t}\n\tFOR(i,0,N){\n\t\tauto X = pq.top();\n\t\tint h = X.second.first;\n\t\tint w = X.second.second;\n\t\tint a = X.first;\n\t\tpq.pop();\n\t\tif(not uf.same(h,w+H)){\n\t\t\tans += a;\n\t\t\tuf.unite(h,w+H);\n\t\t}else if(not uf.same(h,H+W+2)){\n\t\t\tans += a;\n\t\t\tuf.unite(h,H+W+2);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\ntypedef long long ll;\nstruct dat {\n    int a,r,c;\n    bool operator<(const dat x)const {\n        return a>x.a;\n    }\n}p[N];\nint n,h,w,fa[N<<1],vl[N<<1];\nll ans;\nint find(int u) {\n    return fa[u]==u?u:fa[u]=find(fa[u]);\n}\nvoid ut(int u,int v) {\n    int fu=find(u),fv=find(v);\n    if(fu!=fv) {\n        fa[fu]=fv;\n        vl[fv]+=vl[fu];\n    }\n}\nint main() {\n    scanf(\"%d%d%d\",&n,&h,&w);\n    for(int i=1;i<=h+w;i++) fa[i]=i,vl[i]=1;\n    for(int i=1;i<=n;i++) {\n        scanf(\"%d%d%d\",&p[i].r,&p[i].c,&p[i].a);\n        p[i].c+=h;\n    }\n    sort(p+1,p+n+1);\n    for(int i=1;i<=n;i++) {\n        ut(p[i].c,p[i].r);\n        int f=find(p[i].c);\n        // printf(\"fa[%d]=%d %d\\n\",f,vl[f],p[i].a);\n        if(vl[f]>=1) {\n            vl[f]--;\n            ans+=(ll)p[i].a;\n        }\n    }\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#define debug(x)  cerr << #x << \" = \" << x << endl\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair <ll, ll> pll;\ntypedef pair <int, int> pii;\n\nconst int maxN = 2e5 + 5;\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\n\nll gcd(ll a, ll b) {return !b ? a : gcd(b, a % b);}\nll sq(ll x) {return (x * x) % MOD;}\nll modP(ll a, ll b) {return (!b ? 1 : (sq(modP(a, b / 2)) * (b % 2 ? a : 1)) % MOD);}\n\nbool mark[maxN];\nll ans = 0;\nint par[maxN];\npair <ll, pii> E[maxN];\n\nint getpar(int v){\n\tif (par[v] == v) return v;\n\treturn par[v] = getpar(par[v]);\n}\n\nvoid join(int u, int v, ll w){\n\tv = getpar(v);\n\tu = getpar(u);\n\tif (u == v){\n\t\tif (mark[u]) return;\n\t\tmark[u] = true;\n\t\tans += w;\n\t\treturn;\n\t}\n\tif (mark[u] && mark[v]) return;\n\tpar[u] = v;\n\tans += w;\n\tmark[v] |= mark[u];\n\treturn;\t\n}\n\nint main(){\n\tios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tfor (int i = 0; i < maxN; i++){\n\t\tpar[i] = i;\n\t}\n\tint n; cin >> n;\n\tint h, w; cin >> h >> w;\n\tfor (int i = 0; i < n; i++){\n\t\tll r, c, w;\n\t\tcin >> r >> c >> w;\n\t\tc += h;\n\t\tE[i] = {w, {r, c}};\n\t}\n\tsort(E, E + n);\n\treverse(E, E + n);\n\tfor (int i = 0; i < n; i++){\n\t\tjoin(E[i].second.first, E[i].second.second, E[i].first);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f(i,a,b) for(int i=a;i<=b;i++)\n#define fd(i,a,b) for(int i=a;i>=b;i--)\n#define ll long long\n#define maxn 100005\n#define name \"bai5\"\n#define mod 1000000007\n\nusing namespace std;\nll n,h,w,r[maxn],c[maxn],res;\nstruct data\n{\n    ll r,c,a;\n    bool operator < (const data &x) const\n    {\n        return a<x.a;\n    }\n};\ndata l[maxn];\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    //freopen(name\".inp\",\"r\",stdin);\n    //freopen(name\".out\",\"w\",stdout);\n\n    cin>>n>>h>>w;\n    f(i,1,n)\n    {\n        cin>>l[i].r>>l[i].c>>l[i].a;\n    }\n    sort(l+1,l+n+1);\n    fd(i,n,1)\n    {\n        if(r[l[i].r]==0)\n        {\n            res+=l[i].a;\n            res%=mod;\n            r[l[i].r]=1;\n        }\n        else if(c[l[i].c]==0)\n        {\n            res+=l[i].a;\n            res%=mod;\n            c[l[i].c]=1;\n        }\n    }\n    cout<<res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1 };\nvel dy = { 1,-1,0,0 };\nvoid fi(int i, vel& dp, vvel& nex) {\n\tdp[i] = 0;\n\tfor (auto ne : nex[i]) { mmax(dp[i], dp[ne]); }\n}\nvoid sol(int i, vel& dp, vvel& nex, vel& cnt) {\n\tif (cnt[i] == 0) {\n\t\tcnt[i]++;\n\t\tfi(i, dp, nex);\n\t}\n\tif (nex[i].size() == 0) {\n\t\treturn;\n\t}\n\tfor (auto ne : nex[i]) {\n\t\tif (dp[i] == dp[ne]) {\n\t\t\tsol(ne, dp, nex, cnt);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfi(i, dp, nex);\n\treturn;\n}\nsigned main() {\n\tomajinai;\n\tint n, h, w; cin >> n >> h >> w;\n\tvvel cxy(n);\n\tvvel y_i(w);\n\tvvel x_i(h);\n\trep(i, n) {\n\t\tint c, x, y; cin >> x >> y >> c; x--; y--;\n\t\tcxy[i] = { c,x,y };\n\t}\n\tsor(cxy);\n\trep(i, n) {\n\t\tint x = cxy[i][1];\n\t\tint y = cxy[i][2];\n\t\ty_i[y].push_back(i);\n\t\tx_i[x].push_back(i);\n\t}\n\tvel cnt(n, 0);\n\tvvel nex(n);\n\trep(i, w) { \n\t\tsor(y_i[i]);\n\t\tint sz = y_i[i].size();\n\t\tif (sz != 0) {\n\t\t\tcnt[y_i[i].back()]++;\n\t\t\trep(j, sz - 1) {\n\t\t\t\tnex[y_i[i][j + 1]].push_back(y_i[i][j]);\n\t\t\t}\n\t\t}\n\n\t}\n\trep(i, h) { \n\t\tsor(x_i[i]);\n\t\tint sz = x_i[i].size();\n\t\tif (sz != 0) {\n\t\t\tcnt[x_i[i].back()]++;\n\t\t\trep(j, sz - 1) {\n\t\t\t\tnex[x_i[i][j + 1]].push_back(x_i[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tvel dp(n);\n\tint ans = 0;\n\trep(i, n) {\n\t\tif (cnt[i] >= 1) {\n\t\t\tans += cxy[i][0];\n\t\t\tif (cnt[i] >= 2) {\n\t\t\t\tsol(i, dp, nex, cnt);\n\t\t\t\tans += dp[i];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tfi(i, dp, nex);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdp[i] = cxy[i][0];\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <type_traits>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std;\nusing namespace placeholders;\n\nusing LL = long long;\nusing ULL = unsigned long long;\nusing VI = vector< int >;\nusing VVI = vector< vector< int > >;\nusing VS = vector< string >;\nusing ISS = istringstream;\nusing OSS = ostringstream;\nusing PII = pair< int, int >;\nusing VPII = vector< pair< int, int > >;\ntemplate < typename T = int > using VT = vector< T >;\ntemplate < typename T = int > using VVT = vector< vector< T > >;\ntemplate < typename T = int > using LIM = numeric_limits< T >;\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\n\nvoid in_impl(){};\ntemplate < typename T, typename... TS > void in_impl( T &head, TS &... tail ){ cin >> head; in_impl( tail ... ); }\n#define IN( T, ... ) T __VA_ARGS__; in_impl( __VA_ARGS__ );\n\ntemplate < typename T > struct getv_fmt;\ntemplate <> struct getv_fmt<       int >{ static constexpr const char *fmt = \"%d\"; };\ntemplate <> struct getv_fmt< long long >{ static constexpr const char *fmt = \"%lld\"; };\ntemplate < typename T > void getv( std::vector< T > &v ){ for_each( begin( v ), end( v ), []( T &a ){ scanf( getv_fmt< T >::fmt, &a ); } ); };\n\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; }\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); }\n\n#define NUMBERED( name, number ) NUMBERED2( name, number )\n#define NUMBERED2( name, number ) name ## _ ## number\n#define REP1( n ) REP2( NUMBERED( REP_COUNTER, __LINE__ ), n )\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2, REP1 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &&e : c )\n#define ALL( c ) begin( c ), end( c )\n#define AALL( a ) ( remove_all_extents< decltype( a ) >::type * )a, ( remove_all_extents< decltype( a ) >::type * )a + sizeof( a ) / sizeof( remove_all_extents< decltype( a ) >::type )\n#define DRANGE( c, p ) begin( c ), begin( c ) + ( p ), end( c )\n\n#define SZ( v ) ( (int)( v ).size() )\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\ntemplate < typename T > inline bool chmin( T &a, const T &b ){ if ( b < a ) { a = b; return true; } return false; }\ntemplate < typename T > inline bool chmax( T &a, const T &b ){ if ( a < b ) { a = b; return true; } return false; }\n\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\n// 最小費用流 O( F |E| log |V| )\nclass MinimumCostFlow\n{\nprivate:\n\tstruct Edge\n\t{\n\t\tint to, cap, cost, rev;\n\t\tEdge( int t, int c, int d, int r ) : to( t ), cap( c ), cost( d ), rev( r ) {}\n\t};\n\n\tconst int V;\n\tvector< vector<Edge> > G;\n\npublic:\n\tMinimumCostFlow( int v ) : V( v ), G( V ) {};\n\n\tvoid connect( int from, int to, int cap, int cost )\n\t{\n\t\tG[ from ].push_back( Edge( to, cap, cost, G[ to ].size() ) );\n\t\tG[ to ].push_back( Edge( from, 0, -cost, G[ from ].size() - 1 ) );\n\t\treturn;\n\t}\n\n\tint solve( int s, int t, int f )\n\t{\n\t\tint res = 0;\n\t\tvector<int> h( V, 0 ), prevv( V ), preve( V );\n\n\t\twhile ( 0 < f )\n\t\t{\n\t\t\tvector<int> distance( V, INT_MAX );\n\t\t\tdistance[s] = 0;\n\n\t\t\tpriority_queue< pair<int,int>, vector< pair<int,int> >, greater< pair<int,int> > > que;\n\t\t\tque.push( make_pair( 0, s ) );\n\t\t\t\n\t\t\twhile ( !que.empty() )\n\t\t\t{\n\t\t\t\tint d = que.top().first;\n\t\t\t\tint v = que.top().second;\n\t\t\t\tque.pop();\n\n\t\t\t\tif ( distance[v] < d )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor ( int i = 0; i < (int)G[v].size(); ++i )\n\t\t\t\t{\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif ( 0 < e.cap && distance[v] + e.cost + h[v] - h[ e.to ] < distance[ e.to ] )\n\t\t\t\t\t{\n\t\t\t\t\t\tdistance[ e.to ] = distance[v] + e.cost + h[v] - h[ e.to ];\n\t\t\t\t\t\tprevv[ e.to ] = v;\n\t\t\t\t\t\tpreve[ e.to ] = i;\n\t\t\t\t\t\tque.push( make_pair( distance[ e.to ], e.to ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( distance[t] == INT_MAX )\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tfor ( int i = 0; i < V; ++i )\n\t\t\t{\n\t\t\t\th[i] += distance[i];\n\t\t\t}\n\n\t\t\tint d = f;\n\t\t\tfor ( int v = t; v != s; v = prevv[v] )\n\t\t\t{\n\t\t\t\td = min( d, G[ prevv[v] ][ preve[v] ].cap );\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor ( int v = t; v != s; v = prevv[v] )\n\t\t\t{\n\t\t\t\tEdge &e = G[ prevv[v] ][ preve[v] ];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][ e.rev ].cap += d;\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tint solve2( const int s, const int t, int f )\n\t{\n\t\tconst int INF = INT_MAX / 2;\n\t\tint res = 0;\n\n\t\twhile ( f > 0 )\n\t\t{\n\t\t\tvector<int> dist( V, INF );\n\t\t\tdist[s] = 0;\n\t\t\tvector<int> prevv( V ), preve( V );\n\n\t\t\tbool update = true;\n\t\t\twhile ( update )\n\t\t\t{\n\t\t\t\tupdate = false;\n\n\t\t\t\tfor ( int v = 0; v < V; v++ )\n\t\t\t\t{\n\t\t\t\t\tif ( dist[v] == INF )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( int i = 0; i < (int)G[v].size(); i++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\t\tif ( e.cap > 0 && dist[ e.to ] > dist[v] + e.cost )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdist[ e.to ] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[ e.to ] = v;\n\t\t\t\t\t\t\tpreve[ e.to ] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( dist[t] == INF )\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tint d = f;\n\t\t\tfor ( int v = t; v != s; v = prevv[v] )\n\t\t\t{\n\t\t\t\td = min( d, G[ prevv[v] ][ preve[v] ].cap );\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * dist[t];\n\t\t\tfor ( int v = t; v != s; v = prevv[v] )\n\t\t\t{\n\t\t\t\tEdge &e = G[ prevv[v] ][ preve[v] ];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][ e.rev ].cap += d;\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n};\n// MinimumCostFlow( |V| )\n// connect( from, to, cap, cost )\n// solve( s, t, f ) :  Primal-Dual O( F |E| log |V| )\n// solve2( s, t, f ) : Bellman-Ford O( F |E| |V| )\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\tcout << setprecision( 12 ) << fixed;\n\n\tIN( int, N, H, W );\n\tVI R( N ), C( N ), A( N );\n\tREP( i, N )\n\t{\n\t\tcin >> R[i] >> C[i] >> A[i];\n\t\t--R[i], --C[i];\n\t}\n\n\tMinimumCostFlow mincostflow( N * 2 + H + W + 2 );\n\t// [ 0, N ) := cards (src)\n\t// [ N, 2N ) := cards (sink)\n\t// [ 2N, 2N + H ) := rows\n\t// [ 2N + H, 2N + H + W ) := columns\n\tconst int SRC = 2 * N + H + W;\n\tconst int SINK = SRC + 1;\n\n\tREP( i, N )\n\t{\n\t\tmincostflow.connect( SRC, i, 1, 0 );\n\t\tmincostflow.connect( i, N + i, 1, 0 );\n\t\tmincostflow.connect( N + i, 2 * N + R[i], 1, -A[i] );\n\t\tmincostflow.connect( N + i, 2 * N + H + C[i], 1, -A[i] );\n\t}\n\tREP( i, H )\n\t{\n\t\tmincostflow.connect( 2 * N + i, SINK, 1, 0 );\n\t}\n\tREP( j, W )\n\t{\n\t\tmincostflow.connect( 2 * N + H + j, SINK, 1, 0 );\n\t}\n\tmincostflow.connect( SRC, SINK, H * W, 0 );\n\n\tcout << -mincostflow.solve( SRC, SINK, H * W ) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}\nnamespace IO{\n    char nc(){ static char bf[100000],*p1=bf,*p2=bf; return p1==p2&&(p2=(p1=bf)+ fread(bf,1,100000,stdin),p1==p2)?EOF:*p1++; }\n    int rd(){ int res=0; char c=getchar(); while(!isdigit(c))c=getchar(); while(isdigit(c))res=res*10+c-'0',c=getchar(); return res; }\n}/*}}}*/\n/******************heading******************/\n\nconst int N=1e6+6;const lld INF=0x3f3f3f3f3f3f3f3f;\n\nnamespace NET{\n    struct qxx{int nex,t,v;lld c;};\n    qxx e[N*5];\n    int h[N],cnt=1;\n    void add_path(int f,int t,int v,lld c){\n        e[++cnt]=(qxx){h[f],t,v,c}, h[f]=cnt;\n    }\n    void add_flow(int f,int t,int v,lld c){\n        add_path(f,t,v,c), add_path(t,f,0,-c);\n    }\n    int s, t;lld d[N];\n    bool spfa(){\n        bool vising[N]={0};\n        queue<int> q;\n        memset(d,0x3f,sizeof(d));\n        d[s]=0, q.push(s);\n        while(q.size()){\n            int u = q.front();\n            q.pop(),vising[u] = 0;\n            for(int i = h[u]; i; i = e[i].nex){\n                const int &v= e[i].t, &w= e[i].v;const lld &c= e[i].c;\n                if(!w||d[v]<=d[u]+c)continue;\n                d[v]=d[u]+c;\n                if(!vising[v])q.push(v),vising[v]=1;\n            }\n        }\n        return d[t]!=INF;\n    }\n    lld mincost;int maxflow;\n    bool vis[N];\n    int dfs(int u,int flow){\n        vis[u]=1;\n        if(u==t)return flow;\n        int rest=flow;\n        for(int i=h[u];i&&rest;i=e[i].nex){\n            const int &v=e[i].t, &w=e[i].v;const lld &c=e[i].c;\n            if(vis[v]&&v!=t ||!w||d[v]!=d[u]+c)continue;\n            int k=dfs(v,min(rest,w));\n            if(k)mincost+=k*c, e[i].v-=k, e[i^1].v+=k, rest-=k;\n            else d[v]=0;\n        }\n        return flow-rest;\n    }\n\n    void go(){\n        while(spfa()){\n            vis[t]=1;\n            while(vis[t]){\n                memset(vis,0,sizeof(vis));\n                maxflow+=dfs(s,0x3f3f3f3f);\n            }\n        }\n    }\n}\nint n,h,w;\nvoid add_card(int r,int c,int v,int id){\n    NET::add_flow(id,id+n,1,-v);\n    NET::add_flow(id+n,NET::t,1,0);\n    NET::add_flow(n+n+r,id,1,0);\n    NET::add_flow(n+n+h+c,id,1,0);\n}\nint main(){\n    scanf(\"%d%d%d\",&n,&h,&w);\n    NET::s=0,NET::t=n+n+h+w+1;\n    FOR(i,1,n){\n        int x,y,z;\n        scanf(\"%d%d%d\",&x,&y,&z);\n        add_card(x,y,z,i);\n    }\n    FOR(i,1,h)NET::add_flow(NET::s,n+n+i,1,0);\n    FOR(i,1,w)NET::add_flow(NET::s,n+n+h+i,1,0);\n    NET::go();\n    printf(\"%lld\",-NET::mincost);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,h,w;\nint a[100005],xx[100005],yy[100005];\nset<pair<int,pair<int,int> > >S;\nvector<int>g[2][100005];\nstruct ssss{\n\tint par[200005];\n\tssss(){for(int i=1;i<=200000;i++)par[i]=i;}\n\tint find(int x){\n\t\treturn par[x]==x?x:par[x]=find(par[x]);\n\t}\n\tvoid merge(int x,int y){\n\t\tint nx=find(x),ny=find(y);\n\t\tpar[nx]=ny;\n\t}\n}uf;\nbool dead[2][100005];\n#define kill ffweifnweoifnweoif\nvoid kill(int op,int x){\n//\tcerr<<op<<\" \"<<x<<endl;\n\tdead[op][x]=1;\n\tfor(int i=0;i<g[op][x].size();i++){\n\t\tif(dead[op^1][g[op][x][i]])continue;\n\t\tkill(op^1,g[op][x][i]);\n\t}\n}\nbool can(int x,int y,int v){\n\tif(dead[0][x]&&dead[1][y])return false;\n\tif(dead[0][x]){\n\t\tdead[1][y]=1;\n\t\treturn true;\n\t}\n\tif(dead[1][y]){\n\t\tdead[0][x]=1;\n\t\treturn true;\n\t}\n\tif(uf.find(x)==uf.find(y+1e5)){\n\t\tkill(0,x);\n\t}else{\n\t\tg[0][x].push_back(y);\n\t\tg[1][y].push_back(x);\n\t\tuf.merge(x,y+1e5);\n\t}\n\treturn true;\n}\nsigned main(){\n\tcin>>n>>h>>w;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>xx[i]>>yy[i]>>a[i];\n\t\tS.insert(make_pair(-a[i],make_pair(xx[i],yy[i])));\n\t}\n\tint ans=0;\n\twhile(!S.empty()){\n\t\tif(can(S.begin()->second.first,S.begin()->second.second,-S.begin()->first)){\n\t\t\tans-=S.begin()->first;\n\t\t\tcerr<<-S.begin()->first<<endl;\n\t\t}\n\t\tS.erase(S.begin());\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint N,H,W;\npair<int,pair<int,int> >A[1<<17];\n#include<vector>\nstruct UF{\n\tint n;\n\tvector<int>parent;\n\tvector<pair<int,int> >rank;\n\tUF(int n_=0):n(n_),parent(n_),rank(n_,make_pair(1,0))\n\t{\n\t\tfor(int i=0;i<n_;i++)parent[i]=i;\n\t}\n\tint find(int a)\n\t{\n\t\treturn parent[a]!=a?parent[a]=find(parent[a]):a;\n\t}\n\tbool same(int a,int b)\n\t{\n\t\treturn find(a)==find(b);\n\t}\n\tbool unite(int a,int b)\n\t{\n\t\ta=find(a),b=find(b);\n\t\tif(a==b)return false;\n\t\tif(rank[a].first<rank[b].first)\n\t\t{\n\t\t\tparent[a]=b;\n\t\t\trank[b].first+=rank[a].first;\n\t\t\trank[b].second+=rank[a].second;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[b]=a;\n\t\t\trank[a].first+=rank[b].first;\n\t\t\trank[a].second+=rank[b].second;\n\t\t}\n\t\treturn true;\n\t}\n};\nmain()\n{\n\tcin>>N>>H>>W;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>A[i].second.first>>A[i].second.second>>A[i].first;\n\t}\n\tsort(A,A+N);\n\treverse(A,A+N);\n\tUF uf(H+W);\n\tlong ans=0;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tint x=A[i].second.first,y=A[i].second.second;\n\t\tx=uf.find(x-1),y=uf.find(H+y-1);\n\t\tif(x==y)\n\t\t{\n\t\t\tif(uf.rank[x].first>=uf.rank[x].second+1)\n\t\t\t{\n\t\t\t\tans+=A[i].first;\n\t\t\t\tuf.rank[x].second++;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(uf.rank[x].first+uf.rank[y].first>=uf.rank[x].second+uf.rank[y].second+1)\n\t\t\t{\n\t\t\t\tans+=A[i].first;\n\t\t\t\tuf.unite(x,y);\n\t\t\t\tuf.rank[uf.find(x)].second++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\nstruct UnionFind{\n  Int n,num;\n  vector<Int> r,p,s;\n  UnionFind(){}\n  UnionFind(Int sz):n(sz),num(sz),r(sz,1),p(sz,0),s(sz,0){\n    iota(p.begin(),p.end(),0);\n  }\n  Int find(Int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(Int x,Int y){\n    return find(x)==find(y);\n  }\n  void unite(Int x,Int y){\n    x=find(x);y=find(y);\n    if(x==y) return;\n    if(r[x]<r[y]) swap(x,y);\n    s[x]+=s[y];\n    r[x]+=r[y];\n    p[y]=x;\n    num--;\n  }\n  Int size(Int x){\n    return r[find(x)];\n  }\n  Int count() const{\n    return num;\n  }\n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n,h,w;\n  cin>>n>>h>>w;\n  vector<Int> rs(n),cs(n),as(n);\n  for(Int i=0;i<n;i++) cin>>rs[i]>>cs[i]>>as[i],rs[i]--,cs[i]--;\n\n  Int ans=0;\n  using P = pair<Int, Int>;\n  vector<P> vp;\n  for(Int i=0;i<n;i++) vp.emplace_back(as[i],i);\n  sort(vp.rbegin(),vp.rend());\n\n  UnionFind uf(n);\n  vector<Int> match(h+w,-1);\n  for(auto p:vp){\n    Int k=p.second;\n\n    Int &x=match[rs[k]];\n    Int &y=match[h+cs[k]];\n\n    if(~x) uf.unite(k,x);\n    if(~y) uf.unite(k,y);\n\n    Int z=uf.find(k);\n    uf.s[z]+=x<0;\n    uf.s[z]+=y<0;\n\n    x=y=k;\n    if(uf.s[z]>0){\n      ans+=p.first;\n      uf.s[z]--;\n    }\n  }\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// one-based numbering\nstruct UnionFind {\n    vector<int> data;\n    // i: (data[i] < 0) -> group size, (data[i] > 0) -> parent;\n    UnionFind(int n) {\n        data.resize(n+1, -1);\n    }\n    int find(int x) {\n        if(data[x] < 0) return x;\n        else return data[x] = find(data[x]);\n    }\n    int size(int x) {\n        return -data[find(x)];\n    }\n    bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return false;\n        if (data[x] > data[y]) swap(x, y);\n        data[x] += data[y];\n        data[y] = x;\n        return true;\n    }\n    bool same(int x, int y) {\n        x = find(x); y = find(y);\n        return x == y;\n    }\n};\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, h, w; cin >> n >> h >> w;\n    auto enh = [&](int i, int j) { return i; };\n    auto enw = [&](int i, int j) { return h + j; };\n    UnionFind uf(h+w);\n    vector<array<int, 3>> arr;\n    for (int i = 0; i < n; i++) {\n        int r, c, a; cin >> r >> c >> a;\n        arr.push_back({a, r, c});\n    } \n    sort(arr.rbegin(), arr.rend());\n    vector<bool> r(h+w+1, 1);\n    long long ans = 0;\n    for (auto &x: arr) {\n        int p = uf.find(enh(x[1], x[2]));\n        int q = uf.find(enw(x[1], x[2]));\n        if (!uf.same(p, q)) {\n            if (r[p] || r[q]) {\n                ans += x[0];\n                uf.unite(p, q);\n            }\n        } else {\n            if (r[p]) {\n                r[p] = 0;\n                ans += x[0];\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\nusing namespace std;\ntypedef long long LL;\nint n, h, w;\nstruct NODE{\n\tLL a;\n\tint r, c;\n\tinline bool operator < (const NODE &tmp) const\n\t{\n\t\treturn a > tmp.a;\n\t}\n}t[100010];\nint fa[200010];\nLL val[200010];\n\nint find(int x)\n{\n\tif(x == fa[x]) return x;\n\treturn fa[x] = find(fa[x]);\n}\n\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &h, &w);\n\tfor (register int i = 1;i <= n;i ++) scanf(\"%d%d%lld\", &t[i].r, &t[i].c, &t[i].a);\n\tsort(t + 1, t + n + 1);\n\tfor (register int i = 1;i <= h + w;i ++)\n\t{\n\t\tfa[i] = i;\n\t\tval[i] = 1;\n\t}\n\tLL ans = 0;\n\tfor (register int i = 1;i <= n;i ++)\n\t{\n\t\tint xx = find(t[i].r), yy = find(t[i].c + h);\n//\t\tprintf(\"xx = %d, yy = %d\\n\", xx, yy);\n\t\tif(xx == yy)\n\t\t{\n\t\t\tif(val[xx])\n\t\t\t{\n\t\t\t\tval[xx] --;\n\t\t\t\tans += t[i].a;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(val[xx] + val[yy])\n\t\t\t{\n\t\t\t\tval[xx] += val[yy];\n\t\t\t\tval[xx] --;\n\t\t\t\tfa[yy] = xx;\n\t\t\t\tans += t[i].a;\n\t\t\t}\n\t\t}\n//\t\tprintf(\"ans = %lld, val[xx] = %lld, val[yy] = %lld\\n\", ans, val[xx], val[yy]);\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef OUUAN\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#endif\n#include<bits/stdc++.h>\n\n//#define int LoveLive\n//#define FAST_IOSTREAM 1\n\n#define For(i,l,r)for(int i=(l),i##end=(r);i<=i##end;++i)\n#define FOR(i,r,l)for(int i=(r),i##end=(l);i>=i##end;--i)\n#define SON(i,u)for(int i=head[u];i;i=nxt[i])\n#define ms(a,x)memset(a,x,sizeof(a))\n#define fi first\n#define se second\n#define pb emplace_back\n#define pq priority_queue\n#define isinf(x)(x>=INF?-1:x)\n#define y1 why_is_there_a_function_called_y1\n#define DEBUG(x)cerr<<(#x)<<\":\"<<x<<endl\nusing namespace std;\ntypedef long long LoveLive;typedef pair<int,int>pii;typedef vector<int>vi;\n#ifdef int\nconst int INF=0x3f3f3f3f3f3f3f3fll;\n#else\nconst int INF=0x3f3f3f3f;\n#endif\nconst double eps=1e-9;mt19937 rng(chrono::steady_clock::now().time_since_epoch().\ncount());int randint(int l,int r){int out=rng()%(r-l+1)+l;return out>=l?out:out+\nr-l+1;}\n#ifdef FAST_IOSTREAM\n#define br cout<<'\\n'\n#define sp cout<<' '\nlong long read(){long long x;cin>>x;return x;}template<typename T>void read(T&x){\ncin>>x;}template<typename T>void write(const T&x){cout<<x;}\n#else\n#define br putchar('\\n')\n#define sp putchar(' ')\ntemplate<typename T>typename enable_if<!is_integral<T>::value,void>::type read(T\n&x){cin>>x;}long long read(){char c;long long out=0,f=1;for(c=getchar();!isdigit\n(c)&&c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())\nout=(out<<3)+(out<<1)+c-'0';return out*f;}template<typename T>typename enable_if\n<is_integral<T>::value,T>::type read(T&x){char c;T f=1;x=0;for(c=getchar();!isdigit\n(c)&&c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())\nx=(x<<3)+(x<<1)+c-'0';return x*=f;}char read(char&x){for(x=getchar();isspace(x);\nx=getchar());return x;}double read(double&x){scanf(\"%lf\",&x);return x;}template<\ntypename T>typename enable_if<!is_integral<T>::value,void>::type write(const T&x\n){cout<<x;}template<typename T>typename enable_if<is_integral<T>::value,void>::type\nwrite(const T&x){if(x<0){putchar('-');write(-x);return;}if(x>9)write(x/10);putchar\n(x%10+'0');}void write(const char&x){putchar(x);}void write(const double&x){printf\n(\"%.10lf\",x);}\n#endif\ntemplate<typename T,typename...Args>void read(T&x,Args&...args){read(x);read(args\n...);}template<typename OutputIt,typename=typename enable_if<is_same<output_iterator_tag\n,typename iterator_traits<OutputIt>::iterator_category>::value||(\nis_base_of<forward_iterator_tag,typename iterator_traits<OutputIt>::iterator_category>::value\n&&!is_const<OutputIt>::value)>::type>void read(OutputIt __first,OutputIt __last){for(;__first\n!=__last;++__first)read(*__first);}template<typename InputIt,typename=typename enable_if\n<is_base_of<input_iterator_tag,typename iterator_traits<InputIt>::iterator_category\n>::value>::type>void wts(InputIt __first,InputIt __last){bool isFirst=true;for(;\n__first!=__last;++__first){if(isFirst)isFirst=false;else sp;write(*__first);}br;}\ntemplate<typename InputIt,typename=typename enable_if<is_base_of<input_iterator_tag\n,typename iterator_traits<InputIt>::iterator_category>::value>::type>void wtb(InputIt\n__first,InputIt __last){for(;__first!=__last;++__first){write(*__first);br;}}template\n<typename T>void wts(const T&x){write(x);sp;}template<typename T>void wtb(const\nT&x){write(x);br;}template<typename T>void wte(const T&x){write(x);exit(0);}template\n<typename T,typename...Args>void wts(const T&x,Args...args){wts(x);wts(args...);}\ntemplate<typename T,typename...Args>void wtb(const T&x,Args...args){wts(x);wtb(args\n...);}template<typename T,typename...Args>void wte(const T&x,Args...args){wts(x);\nwte(args...);}template<typename T>inline bool up(T&x,const T&y){return x<y?x=y,1\n:0;}template<typename T>inline bool dn(T&x,const T&y){return y<x?x=y,1:0;}\n\nconst int N = 1000010;\n\nint dfs(int u,int flow);\nvoid add(int u,int v,int w,int f);\nvoid Add(int u, int v, int w, int f)\n{\n\t//cerr << u << ' ' << v << ' ' << w << ' ' << f << endl;\n\tadd(u, v, w, f);\n\tadd(v, u, 0, -f);\n}\n\nint head[N],nxt[N],to[N],weight[N],fee[N],cnt=1;\nint n,H, W, m,s = N - 2,t = N - 1,dis[N],ans,anss;\nbool inq[N],vis[N];\nqueue<int> q;\n\nsigned main()\n{\n    read(n, H, W);\n    \n    For (i, 1, H) Add(s, n + i, 1, 0);\n    For (i, 1, W) Add(s, n + H + i, 1, 0);\n    \n    For (i, 1, n)\n    {\n    \tint a, r, c;\n    \tread(r, c, a);\n    \tAdd(i, t, 1, -a);\n    \tAdd(n + r, i, 1, 0);\n    \tAdd(n + H + c, i, 1, 0);\n\t}\n    \n    while (1)\n    {\n    \tint u, i, v, w, f, qaq;\n    \t\n        memset(dis,0x3f,sizeof(dis));\n        memset(vis,false,sizeof(vis));\n        dis[s]=0;\n        q.push(s);\n        \n        while (!q.empty())\n        {\n            u=q.front();\n            q.pop();\n            inq[u]=false;\n            for (i=head[u];i;i=nxt[i])\n            {\n                v=to[i];\n                w=weight[i];\n                f=fee[i];\n                if (w>0&&dis[v]>dis[u]+f)\n                {\n                    dis[v]=dis[u]+f;\n                    if (!inq[v])\n                    {\n                        q.push(v);\n                        inq[v]=true;\n                    }\n                }\n            }\n        }\n        \n        if (dis[t]==0x3f3f3f3f)\n        {\n        \tbreak;\n\t\t}\n        \n        qaq=dfs(s,0x3f3f3f3f);\n        \n        ans+=qaq;\n        anss+=qaq*dis[t];\n    }\n    \n    cout<<-anss << endl;\n    \n    return 0;\n}\n\nint dfs(int u,int flow)\n{\n    if (u==t)\n    {\n    \treturn flow;\n\t}\n\t\n\tvis[u]=true;\n    \n    int i,v,w,f,tt,out=0;\n    for (i=head[u];i&&flow-out;i=nxt[i])\n    {\n        v=to[i];\n        w=weight[i];\n        f=fee[i];\n        if (w>0&&!vis[v]&&dis[v]==dis[u]+f)\n        {\n            tt=dfs(v,min(flow-out,w));\n            out+=tt;\n            weight[i]-=tt;\n            weight[i^1]+=tt;\n        }\n    }\n    \n    return out;\n}\n\nvoid add(int u,int v,int w,int f)\n{\n    nxt[++cnt]=head[u];\n    head[u]=cnt;\n    to[cnt]=v;\n    weight[cnt]=w;\n    fee[cnt]=f;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<map>\n#include<queue>\n#include<deque>\n#include<iomanip>\n#include<tuple>\nusing namespace std;\ntypedef long long int LL;\ntypedef pair<int,int> P;\ntypedef pair<LL,int> LP;\ntypedef tuple<int,int,int> T;\nconst int INF=1<<30;\nconst LL MAX=1e9+7;\n\nvoid array_show(int *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%d%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\nvoid array_show(LL *array,int array_n,char middle=' '){\n\tfor(int i=0;i<array_n;i++)printf(\"%lld%c\",array[i],(i!=array_n-1?middle:'\\n'));\n}\n\nqueue<int> uft_q1;\nint uft_parent[200005];\nint uft_num[200005];\nint edge_num[200005];\n\nint uft_check_parent(int uft_x){\n\tif(uft_parent[uft_x]!=-1)return uft_check_parent(uft_parent[uft_x]);\n\tint uft_a;\n\twhile(!uft_q1.empty()){\n\t\tuft_a=uft_q1.front(),uft_q1.pop();\n\t\tuft_parent[uft_a]=uft_x;\n\t}\n\treturn uft_x;\n}\n\nbool uft_connect(int uft_x,int uft_y){\n\tuft_x=uft_check_parent(uft_x),uft_y=uft_check_parent(uft_y);\n\tif(uft_x==uft_y){\n\t\tif(edge_num[uft_x]<uft_num[uft_x]){\n\t\t\tedge_num[uft_x]++;\n\t\t\treturn true;\n\t\t}else return false;\n\t}\n\tif(edge_num[uft_x]+edge_num[uft_y]+1>uft_num[uft_x]+uft_num[uft_y])return false;\n\tif(uft_num[uft_x]>uft_num[uft_y])swap(uft_x,uft_y);\n\tuft_parent[uft_x]=uft_y;\n\tuft_num[uft_y]+=uft_num[uft_x];\n\tedge_num[uft_y]+=edge_num[uft_x]+1;\n\treturn true;\n}\n\npriority_queue<T> q1;\n\nint main(){\n\tint n,p,q;\n\tint i,j,k;\n\tint a,b,c;\n\tLL s=0;\n\tcin>>n>>p>>q;\n\tmemset(uft_parent,-1,sizeof(uft_parent));\n\tfor(i=0;i<p+q;i++)uft_num[i]=1;\n\tfor(i=0;i<n;i++){\n\t\tcin>>a>>b>>c;\n\t\ta--,b--;\n\t\tq1.push(make_tuple(c,a,b));\n\t}\n\twhile(!q1.empty()){\n\t\ttie(c,a,b)=q1.top(),q1.pop();\n\t\tif(uft_connect(a,p+b)){\n\t\t\ts+=c;\n\t\t\t//cout<<c<<endl;\n\t\t}\n\t}\n\tcout<<s<<endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nint u[216000];\nbool loop[216000];\nvoid init(){\n    for(int i = 0;i < 216000;i++)u[i] = i;\n}\n\nint rt(int x){\n    if(u[x] == x)return x;\n    return u[x] = rt(u[x]);\n}\n\nvoid unite(int x, int y){\n    x = rt(x);\n    y = rt(y);\n    u[x] = y;\n}\n\nint n, h, w;\nint r, c, a;\n\ntypedef pair<Int, P> T;\n\nvector<T> edges;\nInt res;\nint main(){\n    init();\n    cin >> n >> h >> w;\n    for(int i = 0;i < n;i++){\n        cin >> r >> c >> a;r--,c--;\n        edges.push_back(T(a,P(r, c)));\n    }\n    sort(edges.rbegin(), edges.rend());\n    for(auto e: edges){\n        a = e.first;\n        r = e.second.first;\n        c = e.second.second;\n        c += n;\n        int rtr = rt(r), rtc = rt(c);\n        if(loop[rtr] && loop[rtc])continue;\n        res += a;\n//        cout << a << \" \" << r + 1 << \" \" << c - n + 1 << endl;\n        if(rtr == rtc){\n            loop[rtr] = true;\n            continue;\n        }\n        if(!loop[rtr] && !loop[rtc]){\n            unite(r,c);continue;\n        }\n        else{\n            unite(r, c);\n            loop[rt(r)] = true;\n        }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\n#include \"bits/stdc++.h\"\n\nstruct Edge { int to; long long cap; int rev; long long cost; };\ntypedef std::vector<Edge> Edges;\ntypedef std::vector<Edges> Graph;\n\n\nstruct MaxFlow {\n\tGraph g;\n\tstd::vector<int> level, iter;\n\tMaxFlow(int n) {\n\t\tlevel.resize(n);\n\t\titer.resize(n);\n\t\tg.resize(n);\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tg[from].push_back(Edge{ to, cap, (int)g[to].size(),cost });\n\t\tg[to].push_back(Edge{ from,0,(int)g[from].size() - 1,-cost });\n\t}\n\n\tvoid bfs(int s) {\n\t\tstd::fill(level.begin(), level.end(), -1);\n\t\tstd::queue<int> q;\n\t\tlevel[s] = 0;\n\t\tq.push(s);\n\t\twhile (!q.empty()) {\n\t\t\tint v = q.front(); q.pop();\n\t\t\tfor (int i = 0; i < (int)g[v].size(); i++) {\n\t\t\t\tEdge& e = g[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tq.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tlong long dfs(int v, int t, long long f) {\n\t\tif (v == t)return f;\n\t\tfor (int& i = iter[v]; i < (int)g[v].size(); i++) {\n\t\t\tEdge& e = g[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tlong long d = dfs(e.to, t, std::min(f, (long long)e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tg[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tlong long max_flow(int s, int t) {\n\t\tlong long flow = 0;\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tstd::fill(iter.begin(), iter.end(), 0);\n\t\t\tlong long f;\n\t\t\twhile ((f = dfs(s, t, std::numeric_limits<long long> ::max())) > 0) {\n\t\t\t\tflow += f;\n\t\t\t}\n\t\t}\n\t}\n};\n\n\n/////////////////////////////////////////////////////////\n\nstruct MinCostFlow {\n\tusing P = std::pair<long long, int>;\n\n\tint n;\n\tstd::vector<long long> h, dist;\n\tstd::vector<int> prevv, preve;\n\tGraph g;\n\tMinCostFlow(int n_) : n(n_) {\n\t\tg.resize(n);\n\t\th.resize(n, 0);\n\t\tdist.resize(n);\n\t\tprevv.resize(n);\n\t\tpreve.resize(n);\n\t}\n\n\tvoid add_edge(int from, int to, int cap, int cost) {\n\t\tg[from].push_back(Edge{ to, cap, (int)g[to].size(),cost });\n\t\tg[to].push_back(Edge{ from,0,(int)g[from].size() - 1,-cost });\n\t}\n\n\tlong long min_cost_flow(int s, int t, long long f) {\n\t\tlong long res = 0;\n\t\twhile (f > 0) {\n\t\t\tstd::priority_queue<P, std::vector<P>, std::greater<P>> que;\n\t\t\tstd::fill_n(dist.begin(), n, std::numeric_limits<long long>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < (int)g[v].size(); i++) {\n\t\t\t\t\tEdge& e = g[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == std::numeric_limits<long long>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < n; v++)h[v] += dist[v];\n\n\t\t\tlong long d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = std::min(d, (long long)g[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEdge& e = g[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tg[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n, h, w;\n\tcin >> n >> h >> w;\n\tMinCostFlow mf(h + w + n + 2);\n\n\tREP(i, n) {\n\t\tint a, b, c; cin >> a >> b >> c;\n\t\ta--; b--;\n\t\tmf.add_edge(a, h + w + 1 + i, 1, -c);\n\t\tmf.add_edge(h + b, h + w + 1 + i, 1, -c);\n\t}\n\tREP(i, h + w) {\n\t\tmf.add_edge(0, i + 1, 1, 0);\n\t}\n\tREP(i, n) {\n\t\tmf.add_edge(h + w + 1 + i, h + w + n + 1, 1, 0);\n\t}\n\tcout << -mf.min_cost_flow(0, h + w + n + 1, h + w) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n#define int ll\n#define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N=202020;\nstruct kek{\n\tint x,y,c;\n}a[N];\nint p[N],v[N],e[N];\nint get(int x){\n\tif(x==p[x])return x;\n\treturn p[x]=get(p[x]);\n}\nint32_t main(){\n\tint n,h,w;\n\tcin>>n>>h>>w;\n\tforn(i,n){\n\t\tcin>>a[i].x>>a[i].y>>a[i].c;\n\t}\n\tsort(a,a+n,[](const kek&p1,const kek&p2){return p1.c>p2.c;});\n\tfor(int i=1;i<=h+w;++i){\n\t\tp[i]=i;v[i]=1;e[i]=0;\n\t}\n\tint ans=0;\n\tforn(i,n){\n\t\tint x=get(a[i].x),y=get(a[i].y+h);\n\t\tif(x==y){\n\t\t\tif(e[x]<v[x]){\n\t\t\t\tans+=a[i].c;\n\t\t\t\te[x]++;\n\t\t\t}\n\t\t}else{\n\t\t\tp[y]=x;\n\t\t\tv[x]+=v[y];\n\t\t\te[x]+=e[y];\n\t\t\tif(e[x]<v[x]){\n\t\t\t\tans+=a[i].c;\n\t\t\t\te[x]++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1 };\nvel dy = { 1,-1,0,0 };\nvoid sol(int i,int ba, vvel& nex,vvel& use) {\n\tif (use[i].size() == 0 || use[i].back() != ba) {\n\t\tuse[i].push_back(ba);\n\t\tfor (auto ne : nex[i]) {\n\t\t\tsol(ne, ba, nex, use);\n\t\t}\n\t}\n}\nsigned main() {\n\tomajinai;\n\tint n, h, w; cin >> n >> h >> w;\n\tvvel cxy(n);\n\tvvel y_i(w);\n\tvvel x_i(h);\n\trep(i, n) {\n\t\tint c, x, y; cin >> x >> y >> c; x--; y--;\n\t\tcxy[i] = { c,x,y };\n\t}\n\tsor(cxy);\n\trep(i, n) {\n\t\tint x = cxy[i][1];\n\t\tint y = cxy[i][2];\n\t\ty_i[y].push_back(i);\n\t\tx_i[x].push_back(i);\n\t}\n\tvel cnt(n, 0);\n\tvvel nex(n);\n\trep(i, w) { \n\t\tsor(y_i[i]);\n\t\tint sz = y_i[i].size();\n\t\tif (sz != 0) {\n\t\t\tcnt[y_i[i].back()]++;\n\t\t\trep(j, sz - 1) {\n\t\t\t\tnex[y_i[i][j + 1]].push_back(y_i[i][j]);\n\t\t\t}\n\t\t}\n\n\t}\n\trep(i, h) { \n\t\tsor(x_i[i]);\n\t\tint sz = x_i[i].size();\n\t\tif (sz != 0) {\n\t\t\tcnt[x_i[i].back()]++;\n\t\t\trep(j, sz - 1) {\n\t\t\t\tnex[x_i[i][j + 1]].push_back(x_i[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tvvel use(n);\n\tint ans = 0;\n\trep(i, n) {\n\t\tif (cnt[i] == 2) {\n\t\t\tsol(i,i, nex,use);\n\t\t}\n\t\tif (cnt[i] >= 1) { ans += cxy[i][0]; }\n\t}\n\tvel pa(n, -1);\n\tvvel ed;\n\trep(i, n) {\n\t\tif (cnt[i] == 0) {\n\t\t\tvel v = use[i];\n\t\t\tif (v.size() >= 1) {\n\t\t\t\ted.push_back({ cxy[i][0],v[0],v.back() });\n\t\t\t}\n\t\t}\n\t}\n\tsor(ed); rev(ed);\n\tvel ex(n, 0);\n\tfor (auto v : ed) {\n\t\tint c = v[0];\n\t\tint x = root(v[1], pa);\n\t\tint y = root(v[2], pa);\n\t\tif (x == y) {\n\t\t\tif (ex[x] == 0) {\n\t\t\t\tex[x] = 1;\n\t\t\t\tans += c;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (ex[x] + ex[y]<=1) {\n\t\t\t\tpa[x] = y;\n\t\t\t\tex[y] += ex[x]; ex[x] = 0;\n\t\t\t\tans += c;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid out(T x) { cout << x << endl; exit(0); }\n#define watch(x) cout << (#x) << \" is \" << (x) << endl\n\n\n\n\n\nusing ll = long long;\n\n\nconst int maxn = 1e6 + 5;\n\n\n\nint n, h, w;\nmultiset<pair<ll,int>> row[maxn], col[maxn];\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);  cout.tie(0);\n\n    cin>>n>>h>>w;\n    for (int i=0; i<n; i++) {\n\tint a,r,c;\n\tcin>>r>>c>>a;\n\trow[r].insert({a,c});\n\tcol[c].insert({a,r});\n    }\n\n\n    ll res = 0;\n    for (int r=1; r<=h; r++) {\n\tif (!row[r].empty()) {\n\t    auto cur = *row[r].rbegin();\n\t    row[r].erase(--row[r].end());\n\t    res += cur.first;\n\t    //watch(cur.first);\n\t    col[cur.second].erase(col[cur.second].find({cur.first,r}));\n\t}\n    }\n\n\n    for (int c=1; c<=w; c++) {\n\tif (!col[c].empty()) {\n\t    auto cur = *col[c].rbegin();\n\t    col[c].erase(--col[c].end());\n\t    res += cur.first;\n\t    row[cur.second].erase(row[cur.second].find({cur.first,c}));\n\t}\n    }\n\n    cout<<res<<endl;    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define owo(i,a, b) for(int i=(a);i<(b); ++i)\n#define uwu(i,a, b) for(int i=(a)-1; i>=(b); --i)\n#define senpai push_back\n#define ttgl pair<int, int>\n#define ayaya cout<<\"ayaya~\"<<endl\n \nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ngp_hash_table<int, gp_hash_table<int, int>> mp;\nusing ll = long long;\nusing ld = long double;\nconst ll MOD = 1000000000;\nconst ll root = 62;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nll binpow(ll a,ll b){ll res=1;while(b){if(b&1)res=(res*a)%MOD;a=(a*a)%MOD;b>>=1;}return res;}\nll modInv(ll a){return binpow(a, MOD-2);}\nconst double PI = acos(-1);\nconst double eps = -1e6;\nconst int INF = 0x3f3f3f3f;\nconst int NINF = 0xc0c0c0c0;\nconst ll INFLL = 0x3f3f3f3f3f3f3f3f;\nconst ll NINFLL = 0xc0c0c0c0c0c0c0c0;\nconst int mxN = 200001;\nint h, w;\nint n;\npair<int, ttgl> arr[mxN];\nint dsu[mxN];\nint sz[mxN];\nint esz[mxN];\nll ans = 0;\nint find(int a) {\n    return a==dsu[a] ? a : dsu[a] = find(dsu[a]);\n}\nvoid merge(int a, int b, int val) {\n    a = find(a);\n    b = find(b);\n    if(a==b) {\n        if(esz[a]<sz[a]) {\n            esz[a]++;\n            ans+=val;\n        }\n    }else {\n        if(sz[a]<sz[b])swap(a, b);\n        if(esz[a]<sz[a]||esz[b]<sz[b]) {\n            dsu[b] = a;\n            sz[a]+=sz[b];\n            esz[a]+=esz[b];\n            esz[a]++;\n            ans+=val;\n        }\n    }\n}\nint main() {\n    //freopen(\"file.in\", \"r\", stdin);\n    //freopen(\"file.out\", \"w\", stdout);\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    cin.tie(0)->sync_with_stdio(0);\n    cin>>n>>h>>w;\n    owo(i, 0, mxN){\n        sz[i] = 1;\n        esz[i] = 0;\n        dsu[i] = i;\n    }\n    owo(i, 0, n) {\n        cin>>arr[i].second.first>>arr[i].second.second>>arr[i].first;\n        arr[i].second.first--;\n        arr[i].second.second+=h-1;\n    }\n    sort(arr, arr+n);\n    reverse(arr, arr+n);\n    owo(i, 0, n) {\n        merge(arr[i].second.second, arr[i].second.first, arr[i].first);\n    }\n    cout<<ans<<\"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define fin stdin\n#define fout stdout\n//FILE *fin = fopen(\"a.in\", \"r\"), *fout = fopen(\"a.out\", \"w\");\n\nstruct myc {\n    int l, c, a;\n    inline bool operator < (const myc &u) const {\n        return a > u.a;\n    }\n};\nstd::vector < int > t;\n\nint sef(int x) {\n    if (t[x] == x) return x;\n    else return t[x] = sef(t[x]);\n}\n\nint main() {\n    int n, h, w;\n    fscanf(fin, \"%d%d%d\", &n, &h, &w);\n\n    t.resize(h + w);\n\n    std::vector < myc > input;\n    for (int i = 0; i < n; i++) {\n        int a, b, c;\n        fscanf(fin, \"%d%d%d\", &a, &b, &c);\n\n        input.push_back({a, b, c});\n    }\n\n    std::sort(input.begin(), input.end());\n\n    std::vector < bool > avem(h + w);\n    for (int i = 0; i < h + w; i++)\n        t[i] = i;\n\n    long long ans = 0;\n    for (auto &x : input) {\n        int a = sef(x.l - 1), b = sef(x.c + h - 1);\n        if (a != b && (avem[a] == 0 || avem[b] == 0)) {\n            if (avem[b])\n                avem[a] = 1;\n            t[b] = a;\n            ans += x.a;\n        } else if (avem[a] == 0){\n            avem[a] = 1;\n            ans += x.a;\n        }\n    }\n\n    fprintf(fout, \"%lld\\n\", ans);\n\n    fclose(fin);\n    fclose(fout);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint N,H,W;\nint x[1<<17],y[1<<17],A[1<<17];\nvector<pair<int,int> >X[1<<17],Y[1<<17];\nbool used[1<<17];\nmain()\n{\n\tcin>>N>>H>>W;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>x[i]>>y[i]>>A[i];\n\t\tX[x[i]].push_back(make_pair(A[i],i));\n\t\tY[y[i]].push_back(make_pair(A[i],i));\n\t}\n\tlong ans=0;\n\tfor(int i=1;i<=H;i++)\n\t{\n\t\tsort(X[i].rbegin(),X[i].rend());\n\t\tif(X[i].size())\n\t\t{\n\t\t\tans+=X[i][0].first;\n\t\t\tused[X[i][0].second]=true;\n\t\t}\n\t}\n\tfor(int i=1;i<=W;i++)\n\t{\n\t\tsort(Y[i].rbegin(),Y[i].rend());\n\t\tif(Y[i].size())\n\t\t{\n\t\t\tif(used[Y[i][0].second])\n\t\t\t{\n\t\t\t\tint id=Y[i][0].second;\n\t\t\t\tint j=1;\n\t\t\t\twhile(j<X[x[id]].size()&&used[X[x[id]][j].second])j++;\n\t\t\t\tif(j<X[x[id]].size())\n\t\t\t\t{\n\t\t\t\t\tans+=X[x[id]][j].first;\n\t\t\t\t\tused[X[x[id]][j].second]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans+=Y[i][0].first;\n\t\t\t\tused[Y[i][0].second]=true;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <algorithm>\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\nusing namespace std;\n\ntypedef long long ll;\n\nusing namespace std;\ntypedef long long ll;\n\nbool usedRow[100000+5];\nbool usedCol[100000+5];\nset<int> inRow[100000+5];\nset<int> inCol[100000+5];\n\nstruct K {\n  int r, c;\n  ll a;\n  int i;\n  bool used;\n};\nbool operator<(const K& k1, const K& k2) {\n  return k1.a < k2.a;\n}\n\nK vs[100000+5];\n\nll use(int i, set<pair<int,int> > &sRow, set<pair<int,int> > &sCol, bool asRow) {\n  K &card = vs[i];\n  if(card.used) return 0;\n  card.used = true;\n  pair<int,int> rKey(inRow[vs[i].r].size(), vs[i].r);\n  inRow[vs[i].r].erase(i);\n  if(asRow) usedRow[vs[i].r] = true;\n  sRow.erase(rKey);\n  if(!asRow && --rKey.first > 0) {\n    sRow.insert(rKey);\n  }\n  pair<int,int> cKey(inCol[vs[i].c].size(), vs[i].c);\n  inCol[vs[i].c].erase(i);\n  if(!asRow) usedCol[vs[i].c] = true;\n  sCol.erase(cKey);\n  if(!asRow && --cKey.first > 0) {\n    sCol.insert(cKey);\n  }\n  // cerr << \"used \" << card.i << \" asRow=\" << asRow << endl;\n  return card.a;\n}\n\nint main(void) {\n  int n, h, w;\n  scanf(\"%d%d%d\", &n, &h, &w);\n  priority_queue<K> q;\n  REP(i, n) {\n    vs[i].i = i;\n    vs[i].used = false;\n    scanf(\"%d%d%lld\", &vs[i].r, &vs[i].c, &vs[i].a);\n    --vs[i].r;\n    --vs[i].c;\n    inRow[vs[i].r].insert(i);\n    inCol[vs[i].c].insert(i);\n    q.push(vs[i]);\n  }\n  set<pair<int,int> > sRow, sCol;\n  REP(i, h) {\n    if(inRow[i].size() > 0) {\n      sRow.insert(make_pair(inRow[i].size(), i));\n    }\n  }\n  REP(j, w) {\n    if(inCol[j].size() > 0) {\n      sCol.insert(make_pair(inCol[j].size(), j));\n    }\n  }\n  ll res = 0;\n  while(!q.empty()) {\n    if(!sRow.empty() && sRow.begin()->first == 1) {\n      auto cur = *sRow.begin();\n      if(usedRow[cur.second]) {\n        sRow.erase(sRow.begin());\n      } else {\n        res += use(*inRow[cur.second].begin(), sRow, sCol, true);\n      }\n      continue;\n    }\n    if(!sCol.empty() && sCol.begin()->first == 1) {\n      auto cur = *sCol.begin();\n      if(usedCol[cur.second]) {\n        sCol.erase(sCol.begin());\n      } else {\n        res += use(*inCol[cur.second].begin(), sRow, sCol, false);\n      }\n      continue;\n    }\n    K cur = q.top(); q.pop();\n    if(!usedRow[cur.r]) {\n      res += use(cur.i, sRow, sCol, true);\n    } else if(!usedCol[cur.c]) {\n      res += use(cur.i, sRow, sCol, false);\n    }\n  }\n  cout << res << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int MAXN = 1e5 + 10;\n\nstruct node{\n    int u,v;\n    ll w;\n}edge[MAXN];\n\nbool cmp(node a,node b){return a.w > b.w;}\n\nint cy[MAXN<<1],n,h,w;\nbool vis[MAXN];\n\nbool dfs(int i)\n{\n    if (vis[i]) return false;\n    vis[i] = 1;\n    if (cy[edge[i].u] == 0)\n    {\n        cy[edge[i].u] = i;\n        return true;\n    }\n    else if (cy[edge[i].v + MAXN] == 0)\n    {\n        cy[edge[i].v + MAXN] = i;\n        return true;\n    }\n    if (dfs(cy[edge[i].u]))\n    {\n        cy[edge[i].u] = i;\n        return true;\n    }\n    else if (dfs(cy[edge[i].v + MAXN]))\n    {\n        cy[edge[i].v + MAXN] = i;\n        return true;\n    }\n    return false;\n}\n\nunordered_map<ll,int> g;\n\nll match()\n{\n    for (int i = 1;i<=n;i++)\n    {\n        memset(vis,0,sizeof(vis));\n        ll num = (ll)edge[i].u * 1000000 + (ll)edge[i].v;\n        if (g.count(num) && g[num] >= 2) continue;\n        g[num]++;\n        // for(int j=1;j<=n;j++) vis[i]=0;\n        dfs(i);\n    }\n    ll ans = 0;\n    for (int i = 1;i<=h;i++) ans += edge[cy[i]].w;\n    for (int i = MAXN + 1;i<=MAXN + w;i++) ans += edge[cy[i]].w;\n    return ans;\n}\n\nint main()\n{\n    // cin>>n>>h>>w;\n    scanf(\"%d%d%d\",&n,&h,&w);\n    for (int i = 1;i<=n;i++)\n    {\n        scanf(\"%d%d%lld\",&edge[i].u,&edge[i].v,&edge[i].w);\n    }\n    sort(edge+1,edge + n + 1,cmp);\n    // cout<<match();\n    printf(\"%lld\",match());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\n#ifdef LOCAL\nstruct PrettyOS {\n    ostream& os;\n    bool first;\n    template <class T> auto operator<<(T&& x) {\n        if (!first) os << \", \";\n        first = false;\n        os << x;\n        return *this;\n    }\n};\ntemplate <class... T> void dbg0(T&&... t) {\n    (PrettyOS{cerr, true} << ... << t);\n}\n#define dbg(...)                                            \\\n    do {                                                    \\\n        cerr << __LINE__ << \" : \" << #__VA_ARGS__ << \" = \"; \\\n        dbg0(__VA_ARGS__);                                  \\\n        cerr << endl;                                       \\\n    } while (false);\n#else\n#define dbg(...)\n#endif\n\ntemplate <class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    return os << \"P(\" << p.first << \", \" << p.second << \")\";\n}\n\ntemplate <class T> ostream& operator<<(ostream& os, const V<T>& v) {\n    os << \"[\";\n    for (auto d : v) os << d << \", \";\n    return os << \"]\";\n}\n\nstruct UnionFind {\n    V<int> p, r, on;\n    int gn;\n    UnionFind(int n = 0) : p(n, -1), r(n, 1), on(n, 0), gn(n) {}\n    void merge(int a, int b) {\n        int x = group(a), y = group(b);\n        if (x == y) {\n            dbg(\"mrg\", a, b);\n            assert(!on[y]);\n            on[x] = true;\n            return;  // same\n        }\n        gn--;\n        if (r[x] < r[y]) {\n            p[x] = y;\n            on[y] |= on[x];\n        } else {\n            p[y] = x;\n            on[x] |= on[y];\n            if (r[x] == r[y]) r[x]++;\n        }\n    }\n    int group(int a) {\n        if (p[a] == -1) return a;\n        return p[a] = group(p[a]);\n    }\n    bool same(int a, int b) { return group(a) == group(b); }\n    bool can(int a, int b) {\n        int x = group(a), y = group(b);\n        return !on[x] || !on[y];\n    }\n};\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n    int n, h, w;\n    cin >> n >> h >> w;\n    struct E {\n        int r, c; ll a;\n    };\n    V<E> ed;\n    for (int i = 0; i < n; i++) {\n        int r, c; ll a;\n        cin >> r >> c >> a; r--; c--;\n        ed.push_back({r, c, a});\n    }\n    sort(ed.begin(), ed.end(), [&](E x, E y) {\n        return x.a > y.a;\n    });\n\n    ll ans = 0;\n    UnionFind uf(h + w);\n    for (auto e: ed) {\n        if (!uf.can(e.r, e.c + h)) continue;\n        dbg(e.r, e.c + h, e.a);\n        uf.merge(e.r, e.c + h);\n        ans += e.a;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_genius = 0; ngtkana_is_genius < int(n); ngtkana_is_genius++)\n#define rep(i, begin, end) for(int i = int(begin); i < int(end); i++)\n#define lint long long\nauto cmn = [](auto& a, auto b){if (a > b) {a = b; return true;} return false;};\nauto cmx = [](auto& a, auto b){if (a < b) {a = b; return true;} return false;};\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail){\n  std::cerr << \" \" << head;\n  debug_impl(tail...);\n}\n#define debug(...) std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n  debug_impl(__VA_ARGS__);\\\n  std::cerr << std::noboolalpha;\n\n\ntemplate <typename Value, typename BinaryOp>\nclass valued_union_find_tree\n{\n  int                n;\n  std::vector<Value> table;\n  std::vector<int>   prt;\n  BinaryOp           op;\n  Value              id;\n\npublic:\n  valued_union_find_tree (int n, BinaryOp op, Value id, Value init) :\n    n(n), table(n, init), prt(n, -1), op(op), id(id)\n    {}\n\n  bool is_root (int x)        const {return prt.at(x) < 0;}\n  int  size    (int x)        const {return -prt.at(find(x));}\n  bool same    (int x, int y) const {return find(x) == find(y);}\n  int  find    (int x)        const\n  {\n    while (!is_root(x)) x = prt.at(x);\n    return x;\n  }\n  auto collect ()             const {return prt;}\n\n  // Returns `true` if x and y are newly connected.\n  // y becomes the partent.\n  bool unite   (int x, int y)\n  {\n    if ((x = find(x)) == (y = find(y))) return false;\n    if (size(x) > size(y)) std::swap(x, y);\n    prt.at(y) += prt.at(x);\n    prt.at(x) = y;\n    table.at(y) = op(table.at(y), table.at(x));\n    table.at(x) = id;\n    return true;\n  }\n\n  auto get     (int x)        const {return table.at(find(x));}\n  auto collect_vals ()        const\n  {\n    std::vector<Value> ret(n);\n    for (auto i = 0; i < n; i++)\n    {\n      ret.at(i) = get(i);\n    }\n    return ret;\n  }\n  void set     (int x, Value val)    {table.at(find(x)) = val;}\n  void add     (int x, Value val)    {set(x, get(x) + val);}\n};\n\ntemplate <typename Value, typename BinaryOp>\nauto make_valued_union_find_tree(int n, BinaryOp op, Value id, Value init)\n{\n  return valued_union_find_tree<Value, BinaryOp>(n, op, id, init);\n}\n\nint main()\n{\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n, h, w;\n  std::cin >> n >> h >> w;\n  auto queries = std::vector<std::tuple<int, int, int>>(n);\n  rep(i, 0, n)\n  {\n    int x, y, a;\n    std::cin >> x >> y >> a;\n    x--, y--, y += h;\n    queries.at(i) = std::make_tuple(a, x, y);\n  }\n  auto uf = make_valued_union_find_tree\n  (\n    h + w,\n    [](auto x, auto y){return x + y + 1;},\n    0,\n    0\n  );\n  std::sort(queries.begin(), queries.end());\n  std::reverse(queries.begin(), queries.end());\n  auto sat = [&] (int x) -> bool\n  {\n    auto dif = uf.get(x) - uf.size(x);\n    assert(dif == -1 || dif == 0);\n    return dif == 0;\n  };\n  lint ret = 0;\n  for (auto tuple : queries)\n  {\n    int a, x, y;\n    std::tie(a, x, y) = tuple;\n    if (!uf.same(x, y) && (!sat(x) || !sat(y)))\n    {\n      uf.unite(x, y);\n      ret += a;\n    }\n    else if (uf.same(x, y) && !sat(x))\n    {\n      assert(!sat(y));\n      uf.set(y, uf.get(y) + 1);\n      ret += a;\n    }\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Utkarsh.25dec\n#include <bits/stdc++.h>\n#include <chrono>\n#include <random>\n#define ll long long int\n#define ull unsigned long long int\n#define pb push_back\n#define mp make_pair\n#define mod 1000000007\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define loop(i,a,b) for(ll i=a;i<=b;i++)\n#define vi vector <int>\n#define vs vector <string>\n#define vc vector <char>\n#define vl vector <ll>\n#define all(c) (c).begin(),(c).end()\n#define max3(a,b,c) max(max(a,b),c)\n#define min3(a,b,c) min(min(a,b),c)\n#define deb(x) cerr<<#x<<' '<<'='<<' '<<x<<'\\n'\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\n// ordered_set s ; s.order_of_key(val)  no. of elements strictly less than val\n// s.find_by_order(i)  itertor to ith element (0 indexed)\ntypedef vector<vector<ll>> matrix;\nll power(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll modInverse(ll a){return power(a,mod-2);}\nconst int N=500023;\nbool vis[N];\nvector <int> adj[N];\nll par[N];\nll sz[N];\nll find(ll curr)\n{\n    while(curr!=par[curr])\n        curr=par[curr];\n    return curr;\n}\nvoid merge(ll x,ll y)\n{\n    if(sz[x]>=sz[y])\n    {\n        par[y]=x;\n        sz[x]+=sz[y];\n    }\n    else\n    {\n        par[x]=y;\n        sz[y]+=sz[x];\n    }\n}\nvoid solve()\n{\n    ll n,h,w;\n    cin>>n>>h>>w;\n    vector <tuple<ll,ll,ll>> v;\n    for(int i=0;i<n;i++)\n    {\n        ll a,b,c;\n        cin>>a>>b>>c;\n        v.pb(make_tuple(c,a,b));\n    }\n    for(int i=1;i<N;i++)\n    {\n        sz[i]=1;\n        par[i]=i;\n    }\n    sort(all(v));\n    reverse(all(v));\n    ll ans=0;\n    vl good;\n    for(auto t:v)\n    {\n        ll add=get<0>(t);\n        ll r=get<1>(t);\n        ll c=get<2>(t);\n        // cout<<add<<' '<<r<<' '<<c<<'\\n';\n        r+=1e5;\n        r=find(r);\n        c=find(c);\n        if(r==c)\n        {\n            if(vis[r]==0)\n            {\n                vis[r]=1;\n                ans+=add;\n                good.pb(add);\n                continue;\n            }\n            else\n                continue;\n        }\n        else\n        {\n            merge(r,c);\n            if(vis[r] || vis[c])\n                continue;\n            ans+=add;\n            good.pb(add);\n        }\n    }\n    // for(auto it:good)\n    //     cout<<it<<' ';\n    // cout<<'\\n';\n    cout<<ans<<'\\n';\n}\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int T=1;\n    //cin>>T;\n    int t=0;\n    while(t++<T)\n    {\n        //cout<<\"Case #\"<<t<<\":\"<<' ';\n        solve();\n        //cout<<'\\n';\n    }\n    cerr << \"Time : \" << 1000 * ((double)clock()) / (double)CLOCKS_PER_SEC << \"ms\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define int long long\n#define inf 924844033\n#define LINF 100000000000000007LL\n#define ll long long\nusing namespace std;\nll par[214514];\nll rankk[214514];\nll siz[214514];\nll hen[214514];\nvoid init(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\trankk[i]=0;\n\t\tsiz[i] = 1;\n\t\then[i] = 0;\n\t}\n}\nll find(ll x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nvoid unite(ll x, ll y){\n\tx = find(x);\n\ty = find(y);\n\tif(x==y){\n\t\then[x]++;\n\t\treturn;\n\t}\n\tif(rankk[x]<rankk[y]){\n\t\tpar[x]=y;\n\t\tsiz[y]=siz[x]+siz[y];\n\t\then[y]=hen[x]+hen[y]+1;\n\t}else{\n\t\tpar[y]=x;\n\t\tsiz[x]=siz[x]+siz[y];\n\t\then[x]=hen[x]+hen[y]+1;\n\t\tif(rankk[x]==rankk[y])rankk[x]++;\n\t}\n}\nsigned main(){\n\tint n,h,w;\n\tcin>>n>>h>>w;\n\tinit(h+w+1);\n\tvector< pair<int, pair<int,int> > > cards;\n\tfor(int i=0;i<n;i++){\n\t\tint rpos,cpos,value;\n\t\tcin>>rpos>>cpos>>value;\n\t\tcards.pb( mp( value, mp( rpos, cpos ) ) );\n\t}\n\tsort( cards.begin(), cards.end() );\n\treverse( cards.begin(), cards.end() );\n\tint ans = 0;\n\tfor(int i=0;i<cards.size();i++){\n\t\tint r = cards[i].second.first;\n\t\tint c = cards[i].second.second + h;\n\t\tint v = cards[i].first;\n\t\tint pr = find(r);\n\t\tint pc = find(c);\n\t\tif( pr == pc ){\n\t\t\tint ed = hen[pr];\n\t\t\tint ve = siz[pr];\n\t\t\tif( ve > ed ){\n\t\t\t\tans += v;\n\t\t\t\tunite(r,c);\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint ed = hen[pr] + hen[pc];\n\t\t\tint ve = siz[pr] + siz[pc];\n\t\t\tif( ve > ed ){\n\t\t\t\tans += v;\n\t\t\t\tunite(r,c);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream> \n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nvoid printVec(vector<int> a) {\n\tfor (int x : a) {\n\t\tcout << x << ' ';\n\t}\n\tcout << endl;\n}\n\nstruct Card {\n\tint val;\n\tint row;\n\tint col;\n\tbool operator>(const Card& other) {\n    \treturn other.val > this->val;\n\t}\t\n\tbool operator<(const Card& other) {\n    \treturn other.val < this->val;\n\t}\t\n};\n\nvector<int> rowVec(100001, 0);\nvector<int> colVec(100001, 0);\n\nbool putCol(int row, int col);\n\nbool putRow(int row, int col) {\n\tif (rowVec[row] == 0) {\n\t\trowVec[row] = col;\n\t\treturn true;\n\t}\n\tif (rowVec[row] < 0) {\n\t\treturn false;\n\t}\n\tauto x = rowVec[row];\n\trowVec[row] = -x;\n\tif (putCol(row, x)) {\n\t\trowVec[row] = col;\n\t\treturn true;\n\t} else {\n\t\trowVec[row] = x;\n\t\treturn false;\n\t}\n}\n\nbool putCol(int row, int col) {\n\tif (colVec[col] == 0) {\n\t\tcolVec[col] = row;\n\t\treturn true;\n\t}\n\tif (colVec[col] < 0) {\n\t\treturn false;\n\t}\n\tauto x = colVec[col];\n\tcolVec[col] = -x;\n\tif (putRow(x, col)) {\n\t\tcolVec[col] = row;\n\t\treturn true;\n\t} else {\n\t\tcolVec[col] = x;\n\t\treturn false;\n\t}\n}\n\nbool put(Card x) {\n\tif (putRow(x.row, x.col)) {\n\t\treturn true;\n\t}\n\treturn putCol(x.row, x.col);\n}\n\nint main() {\n\tint n, h, w;\n\tcin >> n >> h >> w;\n\tvector<Card> card(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> card[i].row;\n\t\tcin >> card[i].col;\n\t\tcin >> card[i].val;\n\t}\n\tsort(card.begin(), card.end());\n\tint ans = 0;\n\tfor (auto x : card) {\n\t\tif (put(x)) {\n\t\t\tans += x.val;\n\t\t}\n\t}\n\tcout << ans;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//{{{\n#include<algorithm>\n#include<cmath>\n#include<deque>\n#include<fstream>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<random>\n#include<set>\n#include<sstream>\n#include<sys/time.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\nusing ll = long long;\nenum : int { M = (int)1e9 + 7 };\nenum : ll { MLL = (ll)1e18L + 9 };\nusing namespace std;\n#ifdef LOCAL\n#include\"rprint2.hpp\"\n#else\n#define FUNC(name) template <ostream& out = cout, class... T> void name(T&&...){ }\nFUNC(printde) FUNC(printdbe) FUNC(printdwe) FUNC(printdu);\n#endif\ntemplate <template <class T, class = std::allocator<T>> class V, class E>\nistream& operator >> (istream& in, V<E>& v){ for(auto& e : v){ in >> e; } return in; }\n//}}}\n\nstruct Stuple {\n    int first; int second; int third;\n    Stuple() = default;\n    Stuple(int first, int second, int third): first(first), second(second), third(third){ }\n    operator tuple<int, int, int> () const { return make_tuple(first, second, third); }\n    bool operator < (const Stuple& e) const { return tie(first, second, third) < tie(e.first, e.second, e.third); }\n    ostream& operator >> (ostream& out) const { prints(tie(first, second, third)); return out; }\n};\n\nstruct UnionFind {\n\tvector<Stuple> elems;\n\t// vector<pair<int, int>> elems;\n\tUnionFind(int n):elems(n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\telems[i].first = i;\n\t\t\telems[i].second = 1;\n\t\t\telems[i].third = 0;\n\t\t}\n\t}\n\tbool same(int a, int b){\n\t\treturn parent(a) == parent(b);\n\t}\n\tvoid unite(int a, int b){\n\t\tif(elems[parent(a)].first == parent(b)){ return; }\n\t\tint sum = getSum(a) + getSum(b);\n\t\tint sum2 = getSum2(a) + getSum2(b);\n\t\t//cout<<\"sum \"<<sum<<endl;\n\t\telems[parent(a)].first = parent(b);\n\t\telems[parent(b)].second = sum;\n\t\telems[parent(b)].third = sum2;\n\t}\n\tint getSum(int a){\n\t\tif(a == elems[a].first){\n\t\t\treturn elems[a].second;\n\t\t}\n\t\treturn getSum(elems[a].first);\n\t}\n\n\tint getSum2(int a){\n\t\tif(a == elems[a].first){\n            return elems[a].third;\n\t\t}\n\t\treturn getSum2(elems[a].first);\n\t}\n\tvoid addSum2(int a){\n\t\tif(a == elems[a].first){\n\t\t\telems[a].third++;\n\t\t}else{\n            addSum2(elems[a].first);\n        }\n\t}\nprivate:\n\tint parent(int a){\n\t\tif(a == elems[a].first){\n\t\t\treturn a;\n\t\t}\n\t\treturn elems[a].first = parent(elems[a].first);\n\t}\n};\n\nint main(){\n    cin.tie(0); ios::sync_with_stdio(false);\n    int n, h, w;\n    cin >> n >> h >> w;\n    vector<int> rs(n), cs(n), as(n);\n    for(int i = 0; i < n; i++){\n        cin >> rs[i] >> cs[i] >> as[i];\n    }\n    vector<int> is(n);\n    iota(is.begin(), is.end(), 0);\n    sort(is.rbegin(), is.rend(), [&](int i, int j){ return as[i] < as[j]; });\n    UnionFind uf(h + w + 2);\n    ll ans = 0;\n    for(auto& i : is){\n        int r = rs[i], c = cs[i], a = as[i];\n        uf.unite(r, h + 1 + c);\n        printde(i, a, r, c, uf.getSum(r), uf.getSum2(r));\n        if(uf.getSum(r) > uf.getSum2(r)){\n            // printde(ans, i, a);\n            uf.addSum2(r);\n            ans += a;\n            printde(ans, r, c);\n        }\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long llong;\n\nconst int maxn=1e5+10;\n\nclass card{\npublic:\n    int v,rw,cl;\n    card() {}\n    card(int v,int rw,int cl):v(v),rw(rw),cl(cl){}\n    bool operator < (const card &crd) const\n    {\n        return v>crd.v;\n    }\n\n};\n\nint N,H,W;\nvector<card> vec;\nvector<int> vr[maxn],vc[maxn];\nbool vstr[maxn],vstc[maxn];\n\nint main()\n{\n    cin>>N>>H>>W;\n    int R,C,A;\n    for(int i=0;i<N;i++)\n    {\n        cin>>R>>C>>A;\n        vr[R].push_back(A);\n        vc[C].push_back(A);\n        vec.push_back(card(A,R,C));\n\n    }\n    for(int i=1;i<=H;i++)\n       sort(vr[i].begin(),vr[i].end(),greater<int>());\n    for(int i=1;i<=W;i++)\n      sort(vc[i].begin(),vc[i].end(),greater<int>());\n    sort(vec.begin(),vec.end());\n\n    llong ans=0;\n    for(int i=0;i<N;i++)\n    {\n        if(vstr[vec[i].rw]&&vstc[vec[i].cl]) continue;\n        if(vstr[vec[i].rw]&&!vstc[vec[i].cl]) {ans+=vec[i].v;vstc[vec[i].cl]=true;continue;}\n        if(!vstr[vec[i].rw]&&vstc[vec[i].cl]) {ans+=vec[i].v;vstr[vec[i].rw]=true;continue;}\n        int v=vec[i].v,rw=vec[i].rw,cl=vec[i].cl;\n        ans+=v;\n        if(vr[rw][0]!=v&&vc[cl][0]!=v) continue;\n        else if(vr[rw][0]==v&&vc[cl][0]!=v) vstr[rw]=true;\n        else if(vr[rw][0]!=v&&vc[cl][0]==v) vstc[cl]=true;\n        else\n        {\n            if(vr[rw].size()==1&&vc[cl].size()==1) {vstr[rw]=true;vstc[cl]=true;continue;}\n            else if(vr[rw].size()==1||(vc[cl].size()>1&&vr[rw][1]<vc[cl][1])) vstr[rw]=true;\n            else if(vc[cl].size()==1||(vr[rw].size()>1&&vr[rw][1]>=vc[cl][1]))vstc[cl]=true;\n        }\n    }\n    cout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<vector>\n#include<set>\n#include<queue>\n#include<map>\n#include<algorithm>\n#include<cstring>\n#include<string>\n#include<cassert>\n#include<cmath>\n#include<climits>\n#include<iomanip>\n#include<stack>\n#include<unordered_map>\n#include<bitset>\nusing namespace std;\n#define MOD 1000000007\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);i++)\n#define REP(i,n) rep(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ll long long\n#define ull unsigned long long\n#define all(hoge) (hoge).begin(),(hoge).end()\ntypedef pair<ll, ll> P;\nconst long long INF = 1LL << 60;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\nstring operator*(const string& s, int k) {\n\tif (k == 0) return \"\";\n\tstring p = (s + s) * (k / 2);\n\tif (k % 2 == 1) p += s;\n\treturn p;\n}\n\n\n//priority_queue<ll> max;//大きい順\n//priority_queue<ll, Array, greater<ll>> min;//小さい順\n\n/*firstについては昇順 secondについては降順\nsort(all(wh), [&](P x, P y) {\n\tif (x.first == y.first)return x.second > y.second;\n\treturn x.first < y.first;\n});\n*/\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n\tif (a > b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\n\n//substr　文字列取り出し\n//upper_bound ある値より大きい一番左のイテレータを返す、lowerは以上(setに対して使うとO(N)なので、setのメンバ関数を使う\n//stoi\n\n\nstruct Edge {//グラフ\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\t\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\nvoid add_edge(Graph& G, ll from, ll to, ll cap,bool revFlag,ll revCap) {//最大フロー求める Ford-fulkerson\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif(revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));//最小カットの場合逆辺は0にする\n}\nll max_flow_dfs(Graph & G, ll v, ll t, ll f, vector<bool> & used)\n{\n\tif (v == t)\n\t\treturn f;\n\tused[v] = true;\n\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\tEdge& e = G[v][i];\n\t\tif (!used[e.to] && e.cap > 0) {\n\t\t\tll d = max_flow_dfs(G, e.to, t, min(f, e.cap), used);\n\t\t\tif (d > 0) {\n\t\t\t\te.cap -= d;\n\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\treturn d;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n//二分グラフの最大マッチングを求めたりも出来る　また二部グラフの最大独立集合は頂点数-最大マッチングのサイズ\nll max_flow(Graph & G, ll s, ll t)//O(V(V+E))\n{\n\tll flow = 0;\n\tfor (;;) {\n\t\tvector<bool> used(G.size());\n\t\tREP(i, used.size())used[i] = false;\n\t\tll f = max_flow_dfs(G, s, t, INF, used);\n\t\tif (f == 0) {\n\t\t\treturn flow;\n\t\t}\n\t\tflow += f;\n\t}\n}\nvoid BellmanFord(Graph& G, ll s, Array& d,Array &negative) {//O(|E||V|)\n\td.resize(G.size());\n\tnegative.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\tREP(i, d.size())negative[i] = false;\n\td[s] = 0;\n\tREP(k, G.size()-1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tREP(k, G.size() - 1) {\n\t\tREP(i, G.size()) {\n\t\t\tREP(j, G[i].size()) {\n\t\t\t\tif (d[i] != INF && d[G[i][j].to] > d[i] + G[i][j].cap) {\n\t\t\t\t\td[G[i][j].to] = d[i] + G[i][j].cap;\n\t\t\t\t\tnegative[G[i][j].to] = true;\n\t\t\t\t}\n\t\t\t\tif(negative[i]==true)negative[G[i][j].to] = true;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Dijkstra(Graph& G, ll s, Array& d) {//O(|E|log|V|)\n\td.resize(G.size());\n\tREP(i, d.size())d[i] = INF;\n\td[s] = 0;\n\tpriority_queue<P, vector<P>, greater<P>> q;\n\tq.push(make_pair(0, s));\n\twhile (!q.empty()) {\n\t\tP a = q.top();\n\t\tq.pop();\n\t\tif (d[a.second] < a.first)continue;\n\t\tREP(i, G[a.second].size()) {\n\t\t\tEdge e = G[a.second][i];\n\t\t\tif (d[e.to] > d[a.second] + e.cap) {\n\t\t\t\td[e.to] = d[a.second] + e.cap;\n\t\t\t\tq.push(make_pair(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n}\nvoid WarshallFloyd(Graph& G, Matrix& d) {//O(V^3)\n\td.resize(G.size());\n\tREP(i, d.size())d[i].resize(G.size());\n\tREP(i, d.size()) {\n\t\tREP(j, d[i].size()) {\n\t\t\td[i][j] = INF;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G[i].size()) {\n\t\t\td[i][G[i][j].to] = G[i][j].cap;\n\t\t}\n\t}\n\tREP(i, G.size()) {\n\t\tREP(j, G.size()) {\n\t\t\tREP(k, G.size()) {\n\t\t\t\tchmin(d[j][k], d[j][i] + d[i][k]);\n\t\t\t}\n\t\t}\n\t}\n}\nbool tsort(Graph& graph, vector<int>& order) {//トポロジカルソートO(E+V)\n\tint n = graph.size(), k = 0;\n\tArray in(n);\n\tfor (auto& es : graph)\n\t\tfor (auto& e : es)in[e.to]++;\n\tpriority_queue<ll, Array, greater<ll>> que;\n\tREP(i, n)\n\t\tif (in[i] == 0)que.push(i);\n\twhile (que.size()) {\n\t\tint v = que.top();\n\t\tque.pop();\n\t\torder.push_back(v);\n\t\tfor (auto& e : graph[v])\n\t\t\tif (--in[e.to] == 0)que.push(e.to);\n\t}\n\tif (order.size() != n)return false;\n\telse return true;\n}\nclass lca {\npublic:\n\tconst int n = 0;\n\tconst int log2_n = 0;\n\tstd::vector<std::vector<int>> parent;\n\tstd::vector<int> depth;\n\n\tlca() {}\n\n\tlca(const Graph& g, int root)\n\t\t: n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n\t\tdfs(g, root, -1, 0);\n\t\tfor (int k = 0; k + 1 < log2_n; k++) {\n\t\t\tfor (int v = 0; v < (int)g.size(); v++) {\n\t\t\t\tif (parent[k][v] < 0)\n\t\t\t\t\tparent[k + 1][v] = -1;\n\t\t\t\telse\n\t\t\t\t\tparent[k + 1][v] = parent[k][parent[k][v]];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs(const Graph& g, int v, int p, int d) {\n\t\tparent[0][v] = p;\n\t\tdepth[v] = d;\n\t\tfor (auto& e : g[v]) {\n\t\t\tif (e.to != p) dfs(g, e.to, v, d + 1);\n\t\t}\n\t}\n\n\tint get(int u, int v) {\n\t\tif (depth[u] > depth[v]) std::swap(u, v);\n\t\tfor (int k = 0; k < log2_n; k++) {\n\t\t\tif ((depth[v] - depth[u]) >> k & 1) {\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\tif (u == v) return u;\n\t\tfor (int k = log2_n - 1; k >= 0; k--) {\n\t\t\tif (parent[k][u] != parent[k][v]) {\n\t\t\t\tu = parent[k][u];\n\t\t\t\tv = parent[k][v];\n\t\t\t}\n\t\t}\n\t\treturn parent[0][u];\n\t}\n};\n\n\nclass UnionFind {\n\tvector<int> data;\n\tll num;\npublic:\n\tUnionFind(int size) : data(size, -1), num(size) { }\n\tbool unionSet(int x, int y) {//xとyの集合を統合する\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tnum -= (x != y);\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {//xとyが同じ集合か返す\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {//xのルートを返す\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {//xの集合のサイズを返す\n\t\treturn -data[root(x)];\n\t}\n\tint numSet() {//集合の数を返す\n\t\treturn num;\n\t}\n};\nclass SumSegTree {\nprivate:\n\t\n\tint _sum(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return 0;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tint s1 = _sum(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tint s2 = _sum(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn s1 + s2;\n\t\t}\n\t}\npublic:\n\tint n, height;\n\tvector<int> dat;\n\n\t// 初期化（_nは最大要素数）\n\tSumSegTree(int _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<int>(2 * n - 1,0);\n\t}\n\n\t// 場所i(0-indexed)にxを足す\n\tvoid add(int i, int x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] += x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] += x;\n\t\t}\n\t}\n\n\t// 区間[a,b)の総和。ノードk=[l,r)に着目している。\n\tint sum(int a, int b) {\n\t\treturn _sum(a, b, 0, 0, n);\n\t}\n};\nclass RmqTree {\nprivate:\n\n\tll _find(ll a, ll b, ll k, ll l, ll r) {\n\t\tif (r <= a || b <= l)return INF;    // 交差しない\n\t\tif (a <= l && r <= b)return dat[k];   // a,l,r,bの順で完全に含まれる\n\t\telse {\n\t\t\tll s1 = _find(a, b, 2 * k + 1, l, (l + r) / 2); // 左の子\n\t\t\tll s2 = _find(a, b, 2 * k + 2, (l + r) / 2, r); // 右の子\n\t\t\treturn min(s1, s2);\n\t\t}\n\t}\npublic:\n\tll n, height;\n\tvector<ll> dat;\n\n\t// 初期化（_nは最大要素数）\n\tRmqTree(ll _n) {\n\t\tn = 1;\n\t\theight = 1;\n\t\twhile (n < _n) {\n\t\t\tn *= 2;\n\t\t\theight++;\n\t\t}\n\t\tdat = vector<ll>(2 * n - 1,INF);\n\t}\n\n\t// 場所i(0-indexed)をxにする\n\tvoid update(ll i, ll x) {\n\t\ti += n - 1; // i番目の葉ノードへ\n\t\tdat[i] = x;\n\t\twhile (i > 0) { // 下から上がっていく\n\t\t\ti = (i - 1) / 2;\n\t\t\tdat[i] = min(dat[i * 2 + 1], dat[i * 2 + 2]);\n\t\t}\n\t}\n\n\t// 区間[a,b)の最小値。ノードk=[l,r)に着目している。\n\tll find(ll a, ll b) {\n\t\treturn _find(a, b, 0, 0, n);\n\t}\n};\n\n\n//約数求める //約数\nvoid divisor(ll n, vector<ll>& ret) {\n\tfor (ll i = 1; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tret.push_back(i);\n\t\t\tif (i * i != n) ret.push_back(n / i);\n\t\t}\n\t}\n\tsort(ret.begin(), ret.end());\n\n}\n\nvector<ll> lis_fast(const vector<ll>& a) {//最長部分増加列\n\tconst ll n = a.size();\n\tvector<ll> A(n, INT_MAX);\n\tvector<ll> id(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tid[i] = distance(A.begin(), lower_bound(A.begin(), A.end(), a[i]));\n\t\tA[id[i]] = a[i];\n\t}\n\tll m = *max_element(id.begin(), id.end());\n\tvector<ll> b(m + 1);\n\tfor (int i = n - 1; i >= 0; --i)\n\t\tif (id[i] == m) b[m--] = a[i];\n\treturn b;\n}\n\nbool z_algorithm(string &str,vector<int> &z,ll s) {//s&tを渡してtにsが含まれるかを返す\n\tconst int L = str.size();\n\tz.resize(str.size());\n\tfor (int i = 1, left = 0, right = 0; i < L; i++) {\n\t\tif (i > right) {\n\t\t\tleft = right = i;\n\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\tz[i] = right - left;\n\t\t\tright--;\n\t\t}\n\t\telse {\n\t\t\tint k = i - left;\n\t\t\tif (z[k] < right - i + 1) {\n\t\t\t\tz[i] = z[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tleft = i;\n\t\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\t\tz[i] = right - left;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t\tif (z[i] == s)return true;\n\t}\n\treturn false;\n}\nbool z_algorithm(string& str, vector<int>& z) {//z[i]==|s|のときstr[i]からsが含まれる\n\tconst int L = str.size();\n\tz.resize(str.size());\n\tfor (int i = 1, left = 0, right = 0; i < L; i++) {\n\t\tif (i > right) {\n\t\t\tleft = right = i;\n\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\tz[i] = right - left;\n\t\t\tright--;\n\t\t}\n\t\telse {\n\t\t\tint k = i - left;\n\t\t\tif (z[k] < right - i + 1) {\n\t\t\t\tz[i] = z[k];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tleft = i;\n\t\t\t\tfor (; right < L && str[right - left] == str[right]; right++);\n\t\t\t\tz[i] = right - left;\n\t\t\t\tright--;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nll ModPow(ll x, ll n) {\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % MOD;\n\t\tx = x * x % MOD;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\n//nCrとか\nclass Combination {\npublic:\n\tArray fact;\nArray inv;\nll mod;\nll mod_inv(ll x) {\n\tll n = mod - 2LL;\n\tll res = 1LL;\n\twhile (n > 0) {\n\t\tif (n & 1) res = res * x % mod;\n\t\tx = x * x % mod;\n\t\tn >>= 1;\n\t}\n\treturn res;\n}\nll nCr(ll n, ll r) {\n\treturn ((fact[n] * inv[r] % mod) * inv[n - r]) % mod;\n}\nll nPr(ll n, ll r) {\n\treturn (fact[n] * inv[n - r]) % mod;\n}\nll nHr(ll n, ll r) {\n\treturn nCr(r + n - 1, r);\n}\nCombination(ll n, ll _mod) {\n\tmod = _mod;\n\tfact.resize(n + 1);\n\tfact[0] = 1;\n\tREP(i, n) {\n\t\tfact[i + 1] = (fact[i] * (i + 1LL)) % mod;\n\t}\n\tinv.resize(n + 1);\n\tREP(i, n + 1) {\n\t\tinv[i] = mod_inv(fact[i]);\n\t}\n}\n};\n\n\nll gcd(ll m, ll n) {\n\tif (n == 0)return m;\n\treturn gcd(n, m % n);\n}//gcd\n\nll lcm(ll m, ll n) {\n\treturn m / gcd(m, n) * n;\n}\n\n\nMatrix mIdentity(ll n) {\n\tMatrix A(n, Array(n));\n\tfor (int i = 0; i < n; ++i) A[i][i] = 1;\n\treturn A;\n}\n\nMatrix mMul(const Matrix & A, const Matrix & B) {\n\tMatrix C(A.size(), Array(B[0].size()));\n\tfor (int i = 0; i < C.size(); ++i)\n\t\tfor (int j = 0; j < C[i].size(); ++j)\n\t\t\tfor (int k = 0; k < A[i].size(); ++k)\n\t\t\t\t(C[i][j] += (A[i][k] % MOD) * (B[k][j] % MOD)) %= MOD;\n\treturn C;\n}\n// O( n^3 log e )\nMatrix mPow(const Matrix & A, ll e) {\n\treturn e == 0 ? mIdentity(A.size()) :\n\t\te % 2 == 0 ? mPow(mMul(A, A), e / 2) : mMul(A, mPow(A, e - 1));\n}\n\ntemplate <class T>class RectangleSum {\npublic:\n\tvector<vector<T>> sum;\n\tT GetSum(int left, int right, int top, int bottom) { //[left, right], [top, bottom]\n\t\tT res = sum[bottom][right];\n\t\tif (left > 0) res -= sum[bottom][left - 1];\n\t\tif (top > 0) res -= sum[top - 1][right];\n\t\tif (left > 0 && top > 0) res += sum[top - 1][left - 1];\n\t\treturn res;\n\t}\n\tRectangleSum(const vector<vector<T>>& s, int h, int w) {\n\t\tsum.resize(h);\n\t\tfor (int i = 0; i < h; i++) sum[i].resize(w, 0);\n\t\tfor (int y = 0; y < h; y++) {\n\t\t\tfor (int x = 0; x < w; x++) {\n\t\t\t\tsum[y][x] = s[y][x];\n\t\t\t\tif (y > 0) sum[y][x] += sum[y - 1][x];\n\t\t\t\tif (x > 0) sum[y][x] += sum[y][x - 1];\n\t\t\t\tif (y > 0 && x > 0) sum[y][x] -= sum[y - 1][x - 1];\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tll n,h, w;\n\tcin >> n >> h >> w;\n\tUnionFind uni(h + w);\n\tvector<pair<ll, P>> edge;\n\tREP(i, n) {\n\t\tll r, c, a;\n\t\tcin >> r >> c >> a;\n\t\tr--; c--;\n\t\tedge.push_back(make_pair(a, make_pair(r, h+c)));\n\t}\n\tsort(all(edge), greater<pair<ll, P>>());\n\tmap<ll, ll> mp;\n\tll ans = 0;\n\tREP(i, n) {\n\t\tll r = edge[i].second.first;\n\t\tll c = edge[i].second.second;\n\t\tll v = uni.size(r);\n\t\tll num = mp[uni.root(r)];\n\t\tif (uni.root(r) != uni.root(c)) {\n\t\t\tv += uni.size(c);\n\t\t\tnum += mp[uni.root(c)];\n\t\t}\n\t\tif (num < v) {\n\t\t\tans += edge[i].first;\n\t\t\tuni.unionSet(r, c);\n\t\t\tmp[uni.root(r)] = num + 1;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include<bits/stdc++.h>\n#include<cstdio>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\nint P[200002];\nbool eranda[200002];\n\nint Find(int A) {\n\tif (P[A] < 0) return A;\n\treturn P[A] = Find(P[A]);\n}\n\nconst int cm = 1 << 17;\nchar cn[cm], * ci = cn + cm, ct;\ninline char getcha() {\n\tif (ci - cn == cm) { fread(cn, 1, cm, stdin); ci = cn; }\n\treturn *ci++;\n}\ninline int getint() {\n\tint A = 0;\n\tif (ci - cn + 16 > cm) while ((ct = getcha()) >= '0') A = A * 10 + ct - '0';\n\telse while ((ct = *ci++) >= '0') A = A * 10 + ct - '0';\n\treturn A;\n}\n\nint main() {\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n\n\n\tint N = getint(), H = getint(), W = getint();\n\n\tint R[100000], C[100000], A[100000];\n\trep(i, N) {\n\t\tR[i] = getint() - 1;\n\t\tC[i] = getint() + H - 1;\n\t\tA[i] = getint();\n\t}\n\t\n\tint SR[100000], SC[100000], SA[100000];\n\tint kazu[100001] = {};\n\trep(i, N) kazu[A[i]]++;\n\tfor (int i = 99999; i >= 0; i--) kazu[i] += kazu[i + 1];\n\trep(i, N) {\n\t\tSA[--kazu[A[i]]] = A[i];\n\t\tSR[kazu[A[i]]] = R[i];\n\t\tSC[kazu[A[i]]] = C[i];\n\t}\n\n\trep(i, H + W) P[i] = -1;\n\tll kotae = 0;\n\trep(i, N) {\n\t\tint r = Find(SR[i]);\n\t\tint c = Find(SC[i]);\n\t\tif (r != c) {\n\t\t\tif (!(eranda[r] && eranda[c])) {\n\t\t\t\tif (P[r] > P[c]) swap(r, c);\n\t\t\t\tP[r] += P[c];\n\t\t\t\teranda[r] |= eranda[c];\n\t\t\t\tP[c] = r;\n\t\t\t\tkotae += SA[i];\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (eranda[r] == 0) {\n\t\t\t\teranda[r] = 1;\n\t\t\t\tkotae += SA[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\", kotae);\n\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> vvl;\n#define REP(var, a, b) for (int var = (a); var < (b); var++)\n#define rep(var, n) for (int var = 0; var < (n); ++var)\n#define ALL(c) (c).begin(), (c).end()\n#define rALL(c) (c).rbegin(), (c).rend()\nll MOD = 1000000007;\n\nint main() {\n  //\n  ll n, h, w;\n  cin >> n >> h >> w;\n  map<ll, set<pll, greater<pll>>> row, col2;\n  map<ll, set<ll, greater<ll>>> col, row2;\n  rep(i, n) {\n    ll r, c, a;\n    cin >> r >> c >> a;\n    r--, c--;\n    row[r].insert({a, c});\n    col[c].insert(a);\n    row2[r].insert(a);\n    col2[c].insert({a, r});\n  }\n  ll ans = 0, ans2 = 0;\n  for (auto& rm : row) {\n    if (!rm.second.empty()) {\n      pll e = *((rm.second).begin());\n      // cout << e.first << \":\" << e.second << endl;\n      ans += e.first;\n      ll c = e.second;\n      col[c].erase(col[c].find(e.first));\n    }\n  }\n  for (auto& cm : col) {\n    if (!cm.second.empty()) {\n      ll e = *((cm.second).begin());\n      // cout << e << endl;\n      ans += e;\n    }\n  }\n  // cout << ans << endl;\n\n  for (auto& rm : col2) {\n    if (!rm.second.empty()) {\n      pll e = *((rm.second).begin());\n      // cout << e.first << \":\" << e.second << endl;\n      ans2 += e.first;\n      ll c = e.second;\n      row2[c].erase(row2[c].find(e.first));\n    }\n  }\n  for (auto& cm : row2) {\n    if (!cm.second.empty()) {\n      ll e = *((cm.second).begin());\n      // cout << e << endl;\n      ans2 += e;\n    }\n  }\n  cout << max(ans, ans2) << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n13 5 6\n1 3 35902\n4 6 19698\n4 6 73389\n3 6 3031\n3 1 4771\n1 4 4784\n2 1 36357\n2 1 24830\n5 6 50219\n4 6 22645\n1 2 30739\n1 4 68417\n1 5 78537\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define eb emplace_back\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define EL cout<<'\\n'\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out,vector<T> V){\n\tREP(i,SZ(V)) out<<V[i]<<((i!=SZ(V)-1)?\" \":\"\");\n\treturn out;\n}\n#define version 20190814\n//}}}\nconst ll maxn=100005;\nconst ll maxlg=20;\nconst ll INF64=1e18;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst ld PI=acos(-1);\nconst ld eps=1e-9;\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nint dsu[maxn];\nint sz[maxn];\nint rcnt[maxn],ccnt[maxn];\n\nint find(int u){\n\tif(dsu[u]==u) return u;\n\treturn find(dsu[u]);\n}\n\nvoid mrg(int u,int v){\n\tif(u==v) return;\n\tif(sz[u]<sz[v]){\n\t\tsz[v]+=sz[u];\n\t\trcnt[v]+=rcnt[u];\n\t\tccnt[v]+=ccnt[u];\n\t\tdsu[u]=v;\n\t}\n\telse{\n\t\tsz[u]+=sz[v];\n\t\trcnt[u]+=rcnt[v];\n\t\tccnt[u]+=ccnt[v];\n\t\tdsu[v]=u;\n\t}\n}\n\nvoid unmrg(int u,int v){\n\tif(u==v) return;\n\tif(sz[u]<sz[v]){\n\t\tsz[v]-=sz[u];\n\t\trcnt[v]-=rcnt[u];\n\t\tccnt[v]-=ccnt[u];\n\t\tdsu[u]=u;\n\t}\n\telse{\n\t\tsz[u]-=sz[v];\n\t\trcnt[u]-=rcnt[v];\n\t\tccnt[u]-=ccnt[v];\n\t\tdsu[v]=v;\n\t}\n}\n\nbool check(int i){\n\ti=find(i);\n\tif(rcnt[i]+ccnt[i]<sz[i]) return 0;\n\treturn 1;\n}\n\nll n,h,w;\n\nvector<pair<ll,pll>> v;\nint rr[maxn],cc[maxn];\n\nint main(){\n\tIOS;\n\tcin>>n>>h>>w;\n\tREP(i,n){\n\t\tll a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tv.eb(c,MP(a,b));\n\t}\n\tsort(ALL(v));\n\treverse(ALL(v));\n\tll ans=0;\n\n\tREP(i,n) dsu[i]=i,sz[i]=rcnt[i]=ccnt[i]=1;\n\tREP(i,maxn) rr[i]=cc[i]=-1;\n\tREP(i,SZ(v)){\n\t\tll val=v[i].F;\n\t\tll x=v[i].S.F,y=v[i].S.S;\n\t\tbool fR=0,fC=0;\n\t\tif(rr[x]==-1){\n\t\t\trr[x]=i;\n\t\t\tfR=1;\n\t\t}\n\t\tif(cc[y]==-1){\n\t\t\tcc[y]=i;\n\t\t\tfC=1;\n\t\t}\n\t\tint tmp1,tmp2,tmp3,tmp4;\n\t\tif(rr[x]!=i){\n\t\t\ttmp1=find(i);\n\t\t\ttmp2=find(rr[x]);\n\t\t\tmrg(tmp1,tmp2);\n\t\t}\n\t\tif(cc[y]!=i){\n\t\t\ttmp3=find(i);\n\t\t\ttmp4=find(cc[y]);\n\t\t\tmrg(tmp3,tmp4);\n\t\t}\n\t\tif(!fR) rcnt[find(i)]--;\n\t\tif(!fC) ccnt[find(i)]--;\n\n\t\tif(check(i)){\n\t\t\tans+=val;\n\t\t}\n\t\telse{\n\t\t\tif(!fC) ccnt[find(i)]++;\n\t\t\tif(!fR) rcnt[find(i)]++;\n\t\t\tif(cc[y]!=i) unmrg(tmp3,tmp4);\n\t\t\tif(rr[x]!=i) unmrg(tmp1,tmp2);\n\t\t\tif(fC){\n\t\t\t\tcc[y]=-1;\n\t\t\t}\n\t\t\tif(fR){\n\t\t\t\tcc[x]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<iomanip>\n#include<algorithm>\n#include<cmath>\n#include<cstring>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<vector>\n#include<time.h>\n#include<sstream>\n#define MINN -1e8 \nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\nconst ll INF=0x3f3f3f3f3f3f;\nconst int P=1e9+7;\nconst int MAXN=32000;\nconst double pi=3.1415926;\nconst ll mod=1000000007;\nint a[505][505],n;\nvoid f(int l,int r,int tmp)\n{\n\tif(l==r)return;\n\tint mid=(r+l)/2;\n\tfor(int i=l;i<=mid;i++)\n\t{\n\t\tfor(int j=mid+1;j<=r;j++)\n\t\t{\n\t\t\ta[i][j]=tmp;\n\t\t}\n\t}\n\tif(r!=l+1)\n\t{\n\t\tf(l,mid,tmp+1);\n\t\tf(mid+1,r,tmp+1);\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tf(1,n,1);\n\tfor(int i=1;i<=n-1;i++)\n\t{\n\t\tcout<<a[i][i+1];\n\t\tfor(int j=i+2;j<=n;j++)\n\t\t{\n\t\t\tcout<<\" \"<<a[i][j];\n\t\t}\n\t\tcout<<'\\n';\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\n#define int ll\n\nconst ll SIZE = 1e5 * 3 + 10, INF = 1e9 * 1e9 + 2, MOD = 1e9 + 7;\n\nvector<vector<ll>> graph, net;\nvector<ll> del;\nll q, fn;\nbool used[SIZE];\nint dist[SIZE], val[SIZE];\npair<int, int> par[SIZE];\n\nstruct edge {\n\tll c, bal, to;\n};\n\nvector<edge> edges;\n\nll n2, m;\nbool bfs(int u) {\n\tnet.resize(0);\n\tnet.resize(n2);\n\tfor (int i = 0; i < n2; i++) {\n\t\tdist[i] = -1;\n\t\tpar[i] = { -1, -1 };\n\t}\n\tdist[u] = 0;\n\tpar[u] = { u, 0 };\n\n\tqueue<ll> q;\n\tq.push(u);\n\twhile (!q.empty()) {\n\t\tll v = q.front();\n\t\tq.pop();\n\n\t\tfor (auto to : graph[v]) {\n\t\t\tedge e = edges[to];\n\t\t\tif (e.bal > 0 && dist[e.to] == -1) {\n\t\t\t\tq.push(e.to);\n\t\t\t\tpar[e.to] = { u, to };\n\t\t\t\tdist[e.to] = dist[v] + 1;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dist[fn] != -1;\n}\n\nll dfs(int v, int p = INT64_MAX) {\n\tif (!p) return 0;\n\tused[v] = true;\n\tbool gt = 0;\n\tif (v == fn) return p;\n\tfor (; del[v] < graph[v].size(); del[v]++) {\n\t\tll to = graph[v][del[v]];\n\t\tedge e = edges[to];\n\t\tif (dist[e.to] != dist[v] + 1) continue;\n\n\n\t\tll ch = dfs(e.to, min(e.bal, p));\n\t\tif (ch) {\n\t\t\tp = ch;\n\t\t\tedges[to].bal -= p;\n\t\t\tedges[to ^ 1].bal += p;\n\t\t\tgt = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (gt) return p;\n\telse return 0;\n}\n\nll dinic(int v) {\n\tll flow = 0;\n\twhile (bfs(v)) {\n\t\tfor (int i = 0; i < n2; i++) {\n\t\t\tused[i] = true;\n\t\t\tdel[i] = 0;\n\t\t}\n\t\twhile (ll pushed = dfs(v)) {\n\t\t\tflow += pushed;\n\t\t}\n\t}\n\n\treturn flow;\n}\n\nsigned main()\n{\n\tfastInp;\n\n\tll n, h, w;\n\tcin >> n >> h >> w;\n\tn2 = n + h + w + 10;\n\tll vals = 0, ans = 0;\n\tvector<tuple<ll, ll, ll>> vec;\n\tgraph.resize(n + h + w + 8);\n\tdel.resize(n + h + w + 10);\n\tfor (int i = 0; i < n; i++) {\n\t\tll a = 0, b = i + 1, c = 1;\n\t\tedges.push_back({ c, c, b });\n\t\tedges.push_back({ 0, 0, a });\n\t\tgraph[a].push_back(edges.size() - 2);\n\t\tgraph[b].push_back(edges.size() - 1);\n\t}\n\n\tfn = n + h + w + 4;\n\tfor (int i = 0; i < h; i++) {\n\t\tll a = n + i + 1, b = fn, c = 1;\n\t\tedges.push_back({ c, c, b });\n\t\tedges.push_back({ 0, 0, a });\n\t\tgraph[a].push_back(edges.size() - 2);\n\t\tgraph[b].push_back(edges.size() - 1);\n\t}\n\n\tfor (int i = 0; i < w; i++) {\n\t\tll a = n + h + i + 1, b = fn, c = 1;\n\t\tedges.push_back({ c, c, b });\n\t\tedges.push_back({ 0, 0, a });\n\t\tgraph[a].push_back(edges.size() - 2);\n\t\tgraph[b].push_back(edges.size() - 1);\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tll r, c, a;\n\t\tcin >> r >> c >> a;\n\t\tr--; c--;\n\t\t\n\t\tvec.push_back({ a, r, c });\n\t}\n\n\tsort(vec.rbegin(), vec.rend());\n\n\tll cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tvals++;\n\t\tll r = get<1>(vec[i]), c = get<2>(vec[i]), a = get<0>(vec[i]);\n\t\tedges.push_back({ 1, 1, r + n + 1 });\n\t\tedges.push_back({ 0, 0, i + 1 });\n\t\tgraph[i + 1].push_back(edges.size() - 2);\n\t\tgraph[r + n + 1].push_back(edges.size() - 1);\n\t\tedges.push_back({ 1, 1, c + h + n + 1 });\n\t\tedges.push_back({ 0, 0, i + 1 });\n\t\tgraph[i + 1].push_back(edges.size() - 2);\n\t\tgraph[c + h + n + 1].push_back(edges.size() - 1);\n\n\t\tcnt += dinic(0);\n\n\t\tif (cnt >= vals) {\n\t\t\tans += a;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tvals--;\n\t\t\tgraph[i + 1].pop_back();\n\t\t\tgraph[i + 1].pop_back();\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst int MAXN = 2e5 + 5;\n\nstruct edge {\n\tint a, b, c;\n\tvoid input() {\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tb += MAXN / 2;\n\t}\n\tbool operator <(const edge &rhs) const {\n\t\treturn c > rhs.c;\n\t}\n};\n\nint N, H, W;\nint dad[MAXN], rnk[MAXN];\nbool full[MAXN];\nedge e[MAXN];\n\nvoid load() {\n\tscanf(\"%d%d%d\", &N, &H, &W);\n\tfor (int i = 0; i < N; i++)\n\t\te[i].input();\n}\n\nint find(int x) {\n\treturn dad[x] == x ? x : dad[x] = find(dad[x]);\n}\n\nbool join(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) {\n\t\tif (full[x])\n\t\t\treturn false;\n\t\tfull[x] = true;\n\t\treturn true;\n\t}\n\tif (full[x] && full[y])\n\t\treturn false;\n\tif (rnk[x] > rnk[y])\n\t\tswap(x, y);\n\tdad[x] = y;\n\trnk[y] += rnk[x] == rnk[y];\n\tfull[y] |= full[x];\n\treturn true;\n}\n\nll solve() {\n\tsort(e, e + N);\n\t\n\tfor (int i = 0; i < MAXN; i++)\n\t\tdad[i] = i;\n\t\n\tll sol = 0;\n\tfor (int i = 0; i < N; i++)\n\t\tif (join(e[i].a, e[i].b))\n\t\t\tsol += e[i].c;\n\t\n\treturn sol;\n}\n\nint main() {\n\tload();\n\tprintf(\"%lld\\n\", solve());\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst int maxn = 2e5 + 10;\n\nvector<int> g[maxn];\nint mt[maxn];\nint used[maxn];\nint cn = 1;\nvector<ll> prm = { 0, 1 };\nll dsu[maxn * 2], sz[maxn * 2];\npair<ll, ll> c3[maxn * 2];\n\nll find(int v) {\n\tif (dsu[v] == v) return v;\n\telse return dsu[v] = find(dsu[v]);\n}\n\nvoid uni(int v, int u) {\n\tu = find(u);\n\tv = find(v);\n\n\tif (sz[u] > sz[v]) swap(u, v);\n\tif (u != v) {\n\t\tdsu[u] = v;\n\t\tsz[v] += sz[u];\n\t\tc3[v].first += c3[u].first;\n\t\tc3[v].second += c3[u].second;\n\t}\n}\n\nbool dfs(int v) {\n\tif (used[v] == cn) return false;\n\n\tused[v] = cn;\n\n\tll rnd = rand() % 2;\n\tif (rnd == 1) {\n\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\tint u = g[v][i];\n\t\t\tif (mt[u] == -1 || dfs(mt[u])) {\n\t\t\t\tmt[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\tint u = g[v][1 - i];\n\t\t\tif (mt[u] == -1 || dfs(mt[u])) {\n\t\t\t\tmt[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\n\treturn false;\n}\n\nint main()\n{\n\tfastInp;\n\n\tll n, h, w;\n\tcin >> n >> h >> w;\n\n\tll vals = 0, ans = 0;\n\tvector<tuple<ll, ll, ll>> vec;\n\tfor (int i = 0; i < n; i++) {\n\t\tdsu[i] = i;\n\t\tc3[i] = { 1, 0 };\n\t\tsz[i] = 1;\n\t}\n\n\tfor (int i = n; i < n + h; i++) {\n\t\tdsu[i] = i;\n\t\tc3[i] = { 0, 1 };\n\t\tsz[i] = 1;\n\t}\n\tfor (int i = n + h; i < n + h + w; i++) {\n\t\tdsu[i] = i;\n\t\tc3[i] = { 0, 1 };\n\t\tsz[i] = 1;\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tll r, c, a;\n\t\tcin >> r >> c >> a;\n\t\tr--; c--;\n\t\tvec.push_back({ a, r, c });\n\t}\n\n\tsort(vec.rbegin(), vec.rend());\n\n\tll cnt = 0;\n\tll hw = h + w;\n\tfor (int i = 0; i < n; i++) {\n\t\tll r = get<1>(vec[i]), c = get<2>(vec[i]), a = get<0>(vec[i]);\n\t\tr += n;\n\t\tc += h + n;\n\t\tr = find(r);\n\t\tc = find(c);\n\t\tif (c == r) {\n\t\t\tif (min(c3[c].first + 1ll, c3[c].second) > min(c3[c].first, c3[c].second)) {\n\t\t\t\tans += a;\n\t\t\t\tuni(c, i);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (min(c3[c].first, c3[c].second) + min(c3[r].first, c3[r].second) < min(c3[c].first + c3[r].first + 1ll, c3[c].second + c3[r].second)) {\n\t\t\t\tans += a;\n\t\t\t\tuni(c, i);\n\t\t\t\tc = find(c);\n\t\t\t\tuni(c, r);\n\t\t\t}\n\t\t}\n\t\t/*if (mt[r] == -1 || mt[c + h + 1] == -1) {\n\t\t\tvals++;\n\t\t\tcnt++;\n\t\t\tg[i].push_back(r);\n\t\t\tg[i].push_back(c + h + 1);\n\t\t\tif (mt[r] == -1) {\n\t\t\t\tmt[r] = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmt[c + h + 1] = i;\n\t\t\t}\n\t\t\tans += a;\n\t\t\tcontinue;\n\t\t}\n\t\tcn++;\n\t\tvals++;\n\n\t\tg[i].push_back(r);\n\t\tg[i].push_back(c + h + 1);\n\t\tcnt += dfs(i);\n\n\t\tif (cnt >= vals) {\n\t\t\tans += a;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tvals--;\n\t\t}*/\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define all(vec) vec.begin(), vec.end()\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconstexpr ll INF = (1LL << 30) - 1LL;\nconstexpr ll LINF = (1LL << 60) - 1LL;\nconstexpr ll MOD = 1e9 + 7;\ntemplate <typename T> void chmin(T &a, T b) { a = min(a, b); }\ntemplate <typename T> void chmax(T &a, T b) { a = max(a, b); }\nstruct UnionFind {\n    vector<int> par, siz, f;\n    UnionFind(int n) {\n        par.resize(n);\n        siz.resize(n, 1);\n        f.resize(n);\n        for (int i = 0; i < n; i++)\n            par[i] = i;\n    }\n    int find(int x) {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n    bool unite(int u, int v) {\n        u = find(u), v = find(v);\n        if (u == v)\n            return false;\n        if (siz[u] < siz[v])\n            swap(u, v);\n        par[v] = u;\n        siz[u] += siz[v];\n        f[u] |= f[v];\n        return true;\n    }\n    bool same(int u, int v) { return find(u) == find(v); }\n};\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, h, w;\n    cin >> n >> h >> w;\n    vector<pair<ll, P>> v(n);\n    for (int i = 0; i < n; i++) {\n        int r, c, a;\n        cin >> r >> c >> a;\n        --r;\n        --c;\n        v.push_back(make_pair(a, P(r, h + c)));\n    }\n    sort(all(v));\n    reverse(all(v));\n    UnionFind uf(h + w);\n    ll res = 0;\n    for (int i = 0; i < n; i++) {\n        if (uf.f[uf.find(v[i].second.first)] &&\n            uf.f[uf.find(v[i].second.second)]) {\n            continue;\n        }\n        if (uf.unite(v[i].second.first, v[i].second.second)) {\n            res += v[i].first;\n        } else if (!uf.f[uf.find(v[i].second.first)]) {\n            res += v[i].first;\n            uf.f[uf.find(v[i].second.first)] = 1;\n        }\n    }\n    cout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2e5 + 10;\n\nint N, H, W;\nint par[maxn], used[maxn];\nvector < tuple <int, int, int> > a;\n\nint anc(int p) { return par[p] == p ? p : par[p] = anc(par[p]);  }\nbool join(int p, int q) {\n\tp = anc(p); q = anc(q);\n\tif (p == q) {\n\t\tif (used[q]) return false;\n\t\treturn used[q] = true;\n\t}\n\tif (used[p] && used[q]) return false;\n\tused[q] |= used[p];\n\tpar[p] = q;\n\treturn true;\n}\n\nint main() {\n\tcin >> N >> H >> W;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y, v; cin >> x >> y >> v;\n\t\ta.emplace_back(v, x, y + H);\n\t}\n\tsort(a.begin(), a.end()); reverse(a.begin(), a.end());\n\tfor (int i = 1; i <= H + W; ++i) par[i] = i;\n\t\n\tlong long ans = 0;\n\tfor (auto [v, x, y] : a) if (join(x, y))\n\t\tans += v;\n\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 3e5 + 5;\n\nint n, h, w, a[N], b[N], c[N];\n\nclass Flows {\nprivate:\n    struct edge {\n        int u, v, cap, flow, cost;\n        edge (int u = 0, int v = 0, int cap = 0, int flow = 0, int cost = 0): u(u), v(v), cap(cap), flow(flow), cost(cost) {}\n        int other (edge ed, int u) {\n            return ed.u == u ? ed.v : ed.u;\n        }\n    } E;\n\n    vector <edge> e;\n    bool inqueue[N];\n    queue <int> q;\n    int dist[N], par[N], S, T;\n    vector <int> g[N];\n\n    bool spfa(){\n        memset(dist, 0x3f, sizeof(dist)); memset(par, -1, sizeof(par)); memset(inqueue, 0, sizeof(inqueue));\n        dist[S] = 0; par[S] = 1e9 + 2277; inqueue[S] = true; q.push(S);\n        while (!q.empty()) {\n            int u = q.front(); q.pop(); inqueue[u] = false;\n            for (auto V: g[u]) {\n                edge ed = e[V];\n                int v = E.other(ed, u);\n                if (dist[v] > dist[u] + ed.cost && ed.flow < ed.cap) {\n                    dist[v] = dist[u] + ed.cost;\n                    par[v] = V;\n                    if (!inqueue[v]) {\n                        inqueue[v] = true;\n                        q.push(v);\n                    }\n                }\n            }\n        }\n\n        return par[T] != -1;\n    }\n\n    int edmond_karp(){\n        int ans = 1e9, u = T;\n        while (u != S) {\n            ans = min(ans, e[par[u]].cap - e[par[u]].flow);\n            u = E.other(e[par[u]], u);\n        }\n\n        u = T;\n        while (u != S) {\n            e[par[u]].flow += ans;\n            e[par[u] ^ 1].flow -= ans;\n            u = E.other(e[par[u]], u);\n        }\n\n        return ans;\n    }\n\npublic:\n    void init (int _S, int _T) {\n        S = _S;\n        T = _T;\n    }\n\n    void addEdge (int u, int v, int cap, int flow, int cost) {\n        g[u].push_back(e.size());\n        e.push_back(edge(u, v, cap, flow, cost));\n        g[v].push_back(e.size());\n        e.push_back(edge(v, u, 0, 0, -cost));\n    }\n\n    long long getCost(){\n        long long ans = 0;\n        while (spfa()) edmond_karp();\n        for (auto i: e) if (i.flow > 0) ans += 1LL * i.flow * i.cost;\n        return ans;\n    }\n} mcmf;\n\nint main(){\n    scanf(\"%d %d %d\", &n, &h, &w);\n    for (int i = 1; i <= n; i++) scanf(\"%d %d %d\", &a[i], &b[i], &c[i]);\n    mcmf.init(0, h + w + n + 1);\n\n    for (int i = 1; i <= h + w; i++) mcmf.addEdge(0, i, 1, 0, 0);\n    for (int i = 1; i <= n; i++) mcmf.addEdge(h + w + i, h + w + n + 1, 1, 0, -c[i]);\n    for (int i = 1; i <= n; i++) {\n        mcmf.addEdge(a[i], h + w + i, 1, 0, 0);\n        mcmf.addEdge(h + b[i], h + w + i, 1, 0, 0);\n    }\n\n    printf(\"%lld\", -mcmf.getCost());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (int)(n); i ++)\n#define rep1(i, n) for(int i = 1; i <= (int)(n); i ++)\n#define MP make_pair\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nconst int MOD = 998244353;\n\nint n, w, h;\nint pre[200005];\nint cycn[200005];\n\nvoid init()\n{\n\trep1(i, w + h) {\n\t\tpre[i] = i;\n\t\tcycn[i] = 0;\n\t}\n}\n\nint root(int x)\n{\n\treturn pre[x] == x ? x : pre[x] = root(pre[x]);\n}\n\nbool unite(int u, int v)\n{\n\tu = root(u);\n\tv = root(v);\n\tint ccyc = u == v ? cycn[u] + 1 : cycn[u] + cycn[v];\n\tif(ccyc > 1) return false;\n\tpre[v] = u;\n\tcycn[u] = ccyc;\n\treturn true;\n}\n\npair<int, PII> edg[200005];\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &h, &w);\n\trep(i, n) scanf(\"%d%d%d\", &edg[i].second.first, &edg[i].second.second, &edg[i].first);\n\tsort(edg, edg + n);\n\treverse(edg, edg + n);\n\tLL ans = 0;\n\tinit();\n\trep(i, n) if(unite(edg[i].second.first, edg[i].second.second + h)) ans += edg[i].first;\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\n\nclass unionfind {\n\tvector<int> par, size, num;\n\npublic:\n\tvoid init(int n) {\n\t\tpar.resize(n);\n\t\tsize.resize(n);\n\t\tnum.resize(n);\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t\tsize[i] = 1;\n\t\t\tnum[i] = 0;\n\t\t}\n\t}\n\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) {\n\t\t\t++num[x];\n\t\t\treturn ;\n\t\t}\n\t\tif (size[x] < size[y]) swap(x, y);\n\n\t\tpar[y] = x;\n\t\tsize[x] += size[y];\n\t\tnum[x] += num[y];\n\t\t++num[x];\n\t}\n\n\tbool same(int x, int y) { return (find(x) == find(y)); }\n\tint get_size(int x) { return size[find(x)]; }\n\tint get_num(int x) { return num[find(x)]; }\n\n} uf, uf2;\n\nint main() {\n\tint n, h, w;\n\n\tcin >> n >> h >> w;\n\tuf.init(h + w);\n\tuf2.init(h + w);\n\n\tmap<pii, vi> T;\n\n\trep(i, n) {\n\t\tint r, c, x;\n\t\tcin >> r >> c >> x;\n\t\t--r; --c;\n\t\tT[mp(r, c)].pb(x);\n\t\tuf.unite(r, c + h);\n\t}\n\n\tvector<vi> cmp(h + w);\n\trep(i, h + w) cmp[uf.find(i)].pb(i);\n\n\tvector<vector<pair<int, pii>>> vec(h + w);\n\n\tfor (auto t : T) {\n\t\tvi cand = t.se;\n\t\tsort(ALL(cand));\n\t\treverse(ALL(cand));\n\t\twhile (cand.size() > 2) {\n\t\t\tcand.pop_back();\n\t\t}\n\t\tfor (int x : cand) {\n\t\t\tvec[uf.find(t.fi.fi)].eb(x, t.fi);\n\t\t}\n\t}\n\n\tll ans = 0;\n\n\trep(i, h + w) if (vec[i].size()) {\n\t\tsort(ALL(vec[i]));\n\t\treverse(ALL(vec[i]));\n\n\t\tll t = 0;\n\t\trep(j, vec[i].size()) {\n\t\t\tauto e = vec[i][j];\n\t\t\tint u = e.se.fi, v = e.se.se + h;\n\n\t\t\tint sz = uf2.get_size(u) + uf2.get_size(v);\n\t\t\tint ns = uf2.get_num(u) + uf2.get_num(v);\n\n\t\t\tif (uf2.same(u, v)) {\n\t\t\t\tns = uf2.get_num(u);\n\t\t\t\tsz = uf2.get_size(u);\n\t\t\t}\n\n\t\t\tif (ns + 1 <= sz) {\n\t\t\t\tt += e.fi;\n\t\t\t\tuf2.unite(u, v);\n\t\t\t}\n\t\t}\n\n\t\tans += t;\n\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<chrono>\n#include<climits>\n#include<numeric>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<random>\n#include<set>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<string>\nusing namespace std;\n \n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define print(v) {for(auto x : v) cout << x << ' '; cout << endl;}\n#define printn(v, n) {for(int _i = 0; _i < n; _i++) cout << *(v + _i) << ' '; cout << endl;}\n \ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n \nconst int MAXN = 2e5 + 20;\nint n, h, w;\nvector<long long> a[MAXN];\n\nint root[MAXN], size[MAXN], marked[MAXN] = {};\nvoid init() {\n    for(int i = 0; i < MAXN; i++) {\n        root[i] = i;\n        size[i] = 1;\n    }\n}\nint find(int i) {\n    if(root[i] != i)\n        return root[i] = find(root[i]);\n    else\n        return i;\n}\nint same(int i, int j) {\n    return find(i) == find(j);\n}\nvoid join(int i, int j) {\n    if(same(i, j))\n        return;\n    int ri = find(i);\n    int rj = find(j);\n    if(marked[ri] || marked[rj])\n    \tmarked[ri] = marked[rj] = 1;\n    if(size[ri] >= size[rj]) {\n        root[rj] = ri;\n        size[ri] += size[rj];\n    }\n    else {\n        root[ri] = rj;\n        size[rj] += size[ri];\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> n >> h >> w;\n    for(int i = 0; i < n; i++) {\n    \ta[i].resize(3);\n    \tcin >> a[i][1] >> a[i][2] >> a[i][0];\n    }\n\n    sort(a, a + n, [](const vector<long long> & x, const vector<long long> & y) {\n    \treturn x[0] > y[0];\n    });\n\n    init();\n\n    long long res = 0;\n    for(int i = 0; i < n; i++) {\n    \tint x = a[i][1];\n    \tint y = a[i][2] + n;\n    \tint w = a[i][0];\n    \tcout << x << ' ' << y << ' ' << same(x, y) << endl;\n    \tif(!same(x, y)) {\n    \t\tif(!marked[find(x)] || !marked[find(y)]) {\n\t    \t\tres += w;\n\t    \t\tjoin(x, y);\n    \t\t}\n    \t}\n    \telse if(!marked[find(x)]) {\n    \t\tmarked[find(x)] = 1;\n    \t\tres += w;\n    \t}\n    }\n    cout << res << endl;\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 200000\n#define LL long long\nint n,h,w;LL ans;\nstruct edge{\n\tint u,v,w;\n}e[MAXN+1];\nint fa[MAXN+1],siz[MAXN+1],used[MAXN+1];\nint read(){\n\tint x=0,F=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')F=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n\treturn x*F;\n}\nbool cmp(edge s1,edge s2){\n\treturn s1.w>s2.w;\n}\nint xfind(int x){\n\tif(fa[x]==x)return x;\n\treturn fa[x]=xfind(fa[x]);\n}\nint main()\n{\n\tn=read(),h=read(),w=read();\n\tfor(int i=1;i<=n;i++)\n\te[i]=(edge){read(),read()+n,read()};\n\tfor(int i=1;i<=n*2;i++)fa[i]=i,siz[i]=1;\n\tsort(e+1,e+n+1,cmp);\n\tfor(int i=1;i<=n;i++){\n\t\tint a=xfind(e[i].u),b=xfind(e[i].v);\n\t\tif(a==b){\n\t\t\tif(siz[a]>=used[a]+1){\n\t\t\t\tused[a]=used[a]+1;\n\t\t\t\tans+=e[i].w;\n\t\t\t}\n\t\t}else{\n\t\t\tif(siz[a]+siz[b]>=used[a]+used[b]+1){\n\t\t\t\tused[a]+=used[b]+1;\n\t\t\t\tsiz[a]+=siz[b];\n\t\t\t\tans+=e[i].w;\n\t\t\t}\n\t\t\tfa[b]=a;\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n// -- typedefs -- //\n#define EPS 1e-9\ntypedef long long llong;\n\n// -- loop macros -- //\n#define REP(i,n) for (auto i = decltype(n)(0); i < (n); i++)\n#define RREP(i,n) for (auto i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (auto i = (s); i < (n); i++)\n#define FORR(i,s,n) for (auto i = (n)-1; i >= (s); i--)\n#define FORE(exp) for (auto && exp)\n#define allof(c) c.begin(), c.end()\n#define partof(c,s,e) c.begin() + (s), c.begin() + (e)\n\n// -- functors -- //\n#define PREDICATE(t,a,...) [&](const t & a) -> bool { return __VA_ARGS__; }\n#define PRED(a,...) PREDICATE(auto,a,__VA_ARGS__)\n#define COMPARISON(t,a,b,...) [&](const t & a, const t & b) -> bool { return __VA_ARGS__; }\n#define COMP(a,b,...) COMPARISON(auto,a,b,__VA_ARGS__)\n#define CONV1(a,...) [&](const auto & a) -> auto { return __VA_ARGS__; }\n#define CONV2(a,b,...) [&](const auto & a, const auto & b) -> auto { return __VA_ARGS__; }\n#define CONV3(a,b,c,...) [&](const auto & a, const auto & b, const auto & c) -> auto { return __VA_ARGS__; }\n\n// -- I/O Helper -- //\nstruct _Reader { istream& cin; template <class T> _Reader operator ,(T& rhs) { cin >> rhs; return *this; } };\nstruct _Writer { ostream& cout; const char* d{ \" \" }; bool f{}; template <class T> _Writer operator ,(const T& rhs) { cout << (f ? d : \"\") << rhs; f = 1; return *this; } };\n#define READ(t,...) t __VA_ARGS__; (_Reader{cin}), __VA_ARGS__\n#define WRITE(...) do { (_Writer{cout}), __VA_ARGS__; cout << endl; } while (false)\n#define WRITELN(...)  do { (_Writer{cout, \"\\n\"}), __VA_ARGS__; cout << endl; } while (false)\n#ifdef _DEBUG\n#define DEBUG(...) (_Writer{cerr}), \"DEBUG -> \", __VA_ARGS__, \"\\n\"\n#else\n#define DEBUG(...)\n#endif\n\n// -- vevector -- //\ntemplate <class T> struct vevector : vector<vector<T>> { vevector(size_t n = 0, size_t m = 0, const T& initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : vector<vevector<T>> { vevevector(size_t n = 0, size_t m = 0, size_t l = 0, const T& initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : vector<vevevector<T>> { vevevevector(size_t n = 0, size_t m = 0, size_t l = 0, size_t k = 0, const T& initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\n\nnamespace std {\n\ttemplate <class T1, class T2> istream& operator >> (istream& in, pair<T1, T2>& p) { in >> p.first >> p.second; return in; }\n\ttemplate <class T1, class T2> ostream& operator << (ostream& out, const pair<T1, T2>& p) { out << p.first << \" \" << p.second; return out; }\n}\n\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T> struct iter_range_t { T beg, end; };\ntemplate <class T> iter_range_t<T> iter_range(T beg, T end) { return iter_range_t<T>{beg, end}; }\ntemplate <class T> ostream& operator << (ostream& out, iter_range_t<T> v) { if (v.beg != v.end) { out << *v.beg++; while (v.beg != v.end) { out << \" \" << *v.beg++; } } return out; }\ntemplate <class T> ostream& operator << (ostream& out, const vector<T>& v) { return out << iter_range(allof(v)); }\n\n// -- etc -- //\ntemplate <class T> T infinity_value();\ntemplate <> int infinity_value<int>() { return int(1) << 28; }\ntemplate <> llong infinity_value<llong>() { return llong(1) << 60; }\ntemplate <> double infinity_value<double>() { return 1e+300 * 1e+300; }\n#define INF(T) infinity_value<T>()\n\ninline int sign_of(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\ntemplate <class TInt> bool in_range(TInt val, TInt min, TInt max) { return val >= min && val < max; }\ntemplate <> bool in_range<double>(double val, double min, double max) { return val - min > -EPS && val - max < EPS; }\ntemplate <class TInt> bool in_range2d(TInt x, TInt y, TInt w, TInt h) { return x >= 0 && x < w && y >= 0 && y < h; }\nvector<int> iotavn(int start, int count) { vector<int> r(count); iota(allof(r), start);\treturn r; }\n\n\n//// start up ////\nvoid solve();\nint32_t main()\n{\n\tcin.tie(nullptr);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed;\n\tcout << setprecision(std::numeric_limits<double>::max_digits10);\n\tsolve();\n\n\treturn 0;\n}\n\n////////////////////\n//// template end\n////////////////////\n\ntypedef llong COST;\ntypedef llong FLOW;\nstruct PrimalDual\n{\n\tstruct EDGE {\n\t\tint to;\n\t\tFLOW capacity;\n\t\tCOST cost;\n\t\tint rev;\n\t\tbool isrev;\n\t};\n\tvevector<EDGE> g;\n\tvector<COST> potential, min_cost;\n\tvector<int> prevv, preve;\n\n\tPrimalDual(int V) : g(V) {}\n\n\tvoid AddEdge(int from, int to, FLOW cap, COST cost)\n\t{\n\t\tg[from].push_back({ to, cap, cost, (int)g[to].size(), false });\n\t\tg[to].push_back({ from, 0, -cost, (int)g[from].size() - 1, true });\n\t}\n\n\tCOST Cost(int s, int t, FLOW &f)\n\t{\n\t\tint V = (int)g.size();\n\t\tCOST ret = 0;\n\t\tusing Pi = pair< COST, int >;\n\t\tpriority_queue<Pi, vector<Pi>, greater<Pi>> que;\n\t\tpotential.assign(V, 0);\n\t\tpreve.assign(V, -1);\n\t\tprevv.assign(V, -1);\n\n\t\twhile (f > 0) {\n\t\t\tmin_cost.assign(V, INF(COST));\n\t\t\tque.emplace(0, s);\n\t\t\tmin_cost[s] = 0;\n\t\t\twhile (!que.empty()) {\n\t\t\t\tPi p = que.top();\n\t\t\t\tque.pop();\n\t\t\t\tif (min_cost[p.second] < p.first) continue;\n\t\t\t\tfor (int i = 0; i < g[p.second].size(); i++) {\n\t\t\t\t\tEDGE& e = g[p.second][i];\n\t\t\t\t\tCOST nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n\t\t\t\t\tif (e.capacity > 0 && min_cost[e.to] > nextCost) {\n\t\t\t\t\t\tmin_cost[e.to] = nextCost;\n\t\t\t\t\t\tprevv[e.to] = p.second, preve[e.to] = i;\n\t\t\t\t\t\tque.emplace(min_cost[e.to], e.to);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (min_cost[t] == INF(COST)) return ret;\n\t\t\tfor (int v = 0; v < V; v++) potential[v] += min_cost[v];\n\t\t\tFLOW addflow = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\taddflow = min(addflow, g[prevv[v]][preve[v]].capacity);\n\t\t\t}\n\t\t\tf -= addflow;\n\t\t\tret += addflow * potential[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tEDGE& e = g[prevv[v]][preve[v]];\n\t\t\t\te.capacity -= addflow;\n\t\t\t\tg[v][e.rev].capacity += addflow;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\nvoid solve()\n{\n\tREAD(int, N, H, W);\n\tPrimalDual g(H + W + N + 2);\n\n\tREP(i, H) { g.AddEdge(0, i + 1, 1, 0); }\n\tREP(i, W) { g.AddEdge(0, i + 1 + H, 1, 0); }\n\n\tREP(i, N)\n\t{\n\t\tREAD(int, R, C, A);\n\t\tg.AddEdge((R - 1) + 1, 1 + H + W + i, 1, 0);\n\t\tg.AddEdge((C - 1) + 1 + H, 1 + H + W + i, 1, 0);\n\t\tg.AddEdge(1 + H + W + i, 1 + H + W + N, 1, 100000-A);\n\t}\n\n\t{\n\t\tllong f = H + W;\n\t\tllong r = g.Cost(0, 1 + W + H + N, f);\n\t\t{\n\t\t\tWRITE(100000 * (H + W - f) - r);\n\t\t\treturn;\n\t\t}\n\t}\n\tWRITE(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define pb push_back\n#define f first\n#define s second\n\nusing namespace std;\n\nconst int N=1e5+5;\nconst int MOD=1e9+7;\n\ntypedef long long ll;\ntypedef long double ld;\n\nvoid inlld(ll &a){scanf(\"%lld\", &a);}\nvoid ind(int &a){scanf(\"%d\", &a);}\n\nvector<pair<ll, pair<ll, ll> > > vec, vec2;\nll n, h, w, rowdone[N], coldone[N], ans;\n\nint main()\n{\n\tinlld(n);inlld(h);inlld(w);\n\tfor(ll a=1; a<=n; a++)\n\t{\n\t\tll x, y, z;\n\t\tinlld(x);inlld(y);inlld(z);\n\t\tvec.pb({z, {x, y}});\n\t}\n\tsort(vec.begin(), vec.end());\n\tfor(ll a=vec.size()-1; a>=0; a--)\n\t{\n\t\tif(rowdone[vec[a].s.s])\n\t\t{\n\t\t\tvec2.pb(vec[a]);\n\t\t\tcontinue;\n\t\t}\n\t\trowdone[vec[a].s.s]=1;\n\t\tans+=vec[a].f;\n\t}\n\tsort(vec2.begin(), vec2.end());\n\tfor(ll a=vec2.size()-1; a>=0; a--)\n\t{\n\t\tif(coldone[vec2[a].s.f])\n\t\t\tcontinue;\n\t\tcoldone[vec2[a].s.f]=1;\n\t\tans+=vec2[a].f;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\ntemplate <typename Edge>\nclass graph {\n    using graph_t = std::vector<std::vector<Edge>>;\npublic:\n    using reference = std::vector<Edge>&;\n    using const_reference = std::vector<Edge> const&;\n    using iterator = typename graph_t::iterator;\n    using const_iterator = typename graph_t::const_iterator;\n    using reverse_iterator = typename graph_t::reverse_iterator;\n\n    graph() : g() {}\n    graph(int n) : g(n) {}\n\n    reference operator[](int x) { return g[x]; }\n    const_reference operator[](int x) const { return g[x]; }\n\n    iterator begin() { return std::begin(g); }\n    const_iterator begin() const { return std::begin(g); }\n    iterator end() { return std::end(g); }\n    const_iterator end() const { return std::end(g); }\n    reverse_iterator rbegin() { return std::rbegin(g); }\n    reverse_iterator rend() { return std::rend(g); }\n\n    int size() const { return g.size(); }\n\n    void add_node(std::vector<Edge> es) {\n        g.push_back(std::move(es));\n    }\n\nprivate:\n    std::vector<std::vector<Edge>> g;\n};\n\ntemplate <typename Capacity, typename Cost>\nstruct capacity_weighted_edge {\n    using capacity_type = Capacity;\n    using cost_type = Cost;\n    int to, rev;\n    capacity_type cap;\n    cost_type cost;\n    capacity_weighted_edge(int t, int r, capacity_type cp, cost_type c)\n        : to(t), rev(r), cap(cp), cost(c)\n    {}\n};\n\ntemplate <typename Capacity, typename Cost>\nusing capacity_weighted_graph = graph<capacity_weighted_edge<Capacity, Cost>>;\n\ntemplate <typename Capacity, typename Cost>\nvoid add_edge(capacity_weighted_graph<Capacity, Cost>& g, int from, int to, Capacity cap, Cost cost) {\n    g[from].emplace_back(to, static_cast<int>(g[to].size()), cap, cost);\n    g[to].emplace_back(from, static_cast<int>(g[from].size() - 1), Capacity{0}, -cost);\n}\n\n\ntemplate <typename Edge>\ntypename Edge::cost_type min_cost_flow(graph<Edge>& g, int s, int t, typename Edge::capacity_type f) {\n    using cost_type = typename Edge::cost_type;\n    using capacity_type = typename Edge::capacity_type;\n    static_assert(!std::is_floating_point<capacity_type>::value, \"\");\n    using P = std::pair<cost_type, int>;\n    const auto inf = std::numeric_limits<cost_type>::max() / 2;\n    cost_type res = 0;\n    std::vector<cost_type> h(g.size()), dist(g.size());\n    std::vector<int> prevv(g.size()), preve(g.size());\n    while(f > 0) {\n        std::priority_queue<P, std::vector<P>, std::greater<>> que;\n        std::fill(std::begin(dist), std::end(dist), inf);\n        dist[s] = 0;\n        que.emplace(dist[s], s);\n        while(!que.empty()) {\n            const auto cur_d = que.top().first;\n            const int v = que.top().second;\n            que.pop();\n            if(dist[v] < cur_d) continue;\n            for(int i = 0; i < (int)g[v].size(); ++i) {\n                auto& e = g[v][i];\n                if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.emplace(dist[e.to], e.to);\n                }\n            }\n        }\n        if(dist[t] == inf) return -1;\n        for(int v = 0; v < (int)g.size(); ++v) {\n            h[v] += dist[v];\n        }\n\n        auto d = f;\n        for(int v = t; v != s; v = prevv[v]) {\n            d = std::min(d, g[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for(int v = t; v != s; v = prevv[v]) {\n            auto& e = g[prevv[v]][preve[v]];\n            e.cap -= d;\n            g[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main() {\n    int n, h, w; cin >> n >> h >> w;\n    capacity_weighted_graph<int, ll> g(h + w + n + 3);\n    const int src = h + w + n, sink = src + 1, spe = sink + 1;\n    for(int i = 0; i < n; ++i) {\n        ll r, c, a; cin >> r >> c >> a;\n        r--, c--;\n        add_edge(g, r, i + h + w, 1, -a);\n        add_edge(g, c + h, i + h + w, 1, -a);\n        add_edge(g, i + h + w, sink, 1, 0LL);\n    }\n    for(int i = 0; i < h + w; ++i) {\n        add_edge(g, src, i, 1, 0LL);\n    }\n    add_edge(g, src, spe, h + w, 0LL);\n    add_edge(g, spe, sink, h + w, 0LL);\n\n    cout << -min_cost_flow(g, src, sink, h + w) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MAXN = 3e5+10;\n\nint bit[MAXN];\nint par[MAXN];\nint parent(int i) {\n  return par[i] < 0 ? i: (par[i]=parent(par[i]));\n}\n\nbool merge(int a, int b) {\n  int x = parent(a);\n  int y = parent(b);\n  if (x==y) {\n    if (bit[x]) return false;\n    else return bit[x] = 1;\n  }\n  if (bit[x] && bit[y]) return false;\n  bit[x]+=bit[y];\n  par[y] = x;\n  return 1;\n}\n\nint gc=0;\nmap<pair<int,int>, int> m;\nint gid(int r, int c) {\n  auto p = make_pair(r,c);\n  if (m.count(p)) {\n    return m[p];\n  }\n  else {\n    return  m[p] = gc++;\n  }\n}\n\nint n, h, w;\n\nint main(){\n  cin.tie(0); ios_base::sync_with_stdio(0);\n  cin >> n >> h >> w;\n  memset(par, -1,sizeof par);\n  vector<vector<int>> v;\n  for(int i=0;i<n;i++) {\n    int r, c, w;\n    cin >> r >> c >> w;\n    v.push_back({w,r,c});\n  }\n  sort(v.rbegin(), v.rend());\n  ll ans = 0;\n  for(auto p: v) {\n    if (merge(gid(p[1],0), gid(p[2],1))){\n      ans+=p[0];\n      //cerr << \"ADDING \" << p[1] << \" \" << p[2] << \" \" << p[0] <<endl;\n    }\n    //else //cerr << \"NOT ADDING \" << p[1] << \" \" << p[2] << \" \" << p[0] <<endl;\n  }\n  cout << ans <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr  int MOD = 1000000007;\n//constexpr  int MOD = 998244353;\n//constexpr  long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n// int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nstruct Node {\n\tint x, y, score;\n\tNode(const int a, const int b, const int c) {\n\t\ty = a, x = b, score = c;\n\t}\n\tbool operator<(const Node&n)const {\n\t\treturn score < n.score;\n\t}\n};\n\nclass UnionFind {\n\tvector<int>parent;\n\tvector<int>rank;\npublic:\n\tvector<int>index;\n\n\tUnionFind(int num) {\n\t\tnum++;\n\t\tparent.resize(num);\n\t\trank.resize(num);\n\t\tindex.resize(num);\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tindex[i] = i;\n\t\t}\n\t}\n\tint Find(int node) {\n\t\tif (parent[node] == node)return node;\n\t\telse return parent[node] = Find(parent[node]);\n\t}\n\tvoid Unite(int u, int v) {\n\t\tu = Find(u);\n\t\tv = Find(v);\n\t\tif (u == v)return;\n\t\tif (rank[u] < rank[v]) {\n\t\t\tparent[u] = v;\n\t\t\tindex[u] = index[v] = min(index[u], index[v]);\n\t\t}\n\t\telse {\n\t\t\tparent[v] = u;\n\t\t\tindex[u] = index[v] = min(index[u], index[v]);\n\t\t\tif (rank[u] == rank[v])rank[u]++;\n\t\t}\n\t}\n\tbool Check_Same(int u, int v) {\n\t\treturn Find(u) == Find(v);\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> H >> W;\n\tvector<Node>node;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> L >> R >> K;\n\t\tnode.push_back(Node(L - 1, R - 1, K));\n\t}\n\tsort(node.begin(), node.end());\n\treverse(node.begin(), node.end());\n\tUnionFind uf(H + W);\n\tvector<int>amari(H + W, 1);\n\tfor (auto i : node) {\n\t\tif (uf.Check_Same(i.y, i.x + H)) {\n\t\t\tif (amari[uf.index[uf.Find(i.y)]]) {\n\t\t\t\tM += i.score;\n\t\t\t\tamari[uf.index[uf.Find(i.y)]]--;\n\t\t\t}\n\t\t}\n\t\telse if (amari[uf.index[uf.Find(i.y)]] + amari[uf.index[uf.Find(i.x)]] >= 1) {\n\t\t\tM += i.score;\n\t\t\tamari[uf.index[uf.Find(i.y)]] = amari[uf.index[uf.Find(i.x)]] = amari[uf.index[uf.Find(i.y)]] + amari[uf.index[uf.Find(i.x)]] - 1;\n\t\t\tuf.Unite(i.y, i.x + H);\n\t\t}\n\t}\n\tcout << M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x)\n{\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1; c=getchar();}\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=510;\nint a[N][N],n;\nint main() {\n\trd(n);\n\tfor(int i=0;i<n;++i,puts(\"\"))\n\t\tfor(int j=i+1;j<n;++j) {\n\t\t\tfor(int k=0;;++k)\n\t\t\t\tif(((i>>k)&1)^((j>>k)&1)) { printf(\"%d \",k+1); break; }\n\t\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> par;\n    vector<bool> is_namori;\n    \n    UnionFind(int n) : par(n, -1), is_namori(n, 0) {}\n    \n    int root(int x) {\n        if (par[x] < 0) return x;\n        else return par[x] = root(par[x]);\n    }\n    \n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    // e = (x, y) を結んで良いかどうかも含めて判定\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n\n        // x と y が同じ連結成分\n        if (x == y)  {\n            if (is_namori[x]) return false;\n            is_namori[x] = true;\n            return true;\n        }\n\n        // x も y もなもりはダメ\n        if (is_namori[x] && is_namori[y]) return false;\n        \n        if (par[x] > par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        if (is_namori[x] || is_namori[y]) is_namori[x] = true;   \n        return true;\n    }\n    \n    int size(int x) {\n        return -par[root(x)];\n    }\n};\n\nusing pint = pair<int,int>;\nusing Edge = pair<long long, pint>;\n\nint main() {\n    int N, H, W; cin >> N >> H >> W;\n    vector<Edge> edges;\n    for (int i = 0; i < N; ++i) {\n        int r, c, a; cin >> r >> c >> a; --r, --c;\n        c += H;\n        edges.push_back(Edge(a, pint(r, c)));\n    }\n    sort(edges.begin(), edges.end(), greater<Edge>());\n\n    UnionFind uf(H + W);\n    long long res = 0;\n    for (auto e : edges) {\n        int u = e.second.first;\n        int v = e.second.second;\n        long long w = e.first;\n\n        if (uf.merge(u, v)) res += w;\n    }   \n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#define NDEBUG\n\n// verified at https://judge.yosupo.jp/submission/3400\n#ifndef Union_find_hpp\n#define Union_find_hpp\n\n#include <cassert>\n#include <cstddef>\n#include <vector>\n\nclass union_find\n{\n    std::vector<int> link;\n\npublic:\n    explicit union_find(const size_t n) : link(n, -1) {}\n\n    size_t find(size_t x)\n    {\n        assert(x < size());\n        return link[x] < 0 ? x : (link[x] = find(link[x]));\n    }\n\n    size_t size() const { return link.size(); }\n\n    size_t size(const size_t x)\n    {\n        assert(x < size());\n        return -link[find(x)];\n    }\n\n    bool same(const size_t x, const size_t y)\n    {\n        assert(x < size() && y < size());\n        return find(x) == find(y);\n    }\n\n    size_t unite(size_t x, size_t y)\n    {\n        assert(x < size() && y < size());\n        if((x = find(x)) != (y = find(y)))\n        {\n            if(link[x] > link[y]) std::swap(x, y);\n            link[x] += link[y];\n            link[y] = x;\n        }\n        return x;\n    }\n}; // class union_find\n\n#endif // Union_find_hpp\n\n#include <algorithm>\n#include <iostream>\n#include <tuple>\n\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n    std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n\n    int n,h,w; cin>>n>>h>>w;\n    vector<tuple<int,int,int>> cards(n);\n    for(auto &e : cards)\n    {\n        int r,c,a; cin>>r>>c>>a;\n        --r,--c; c+=h;\n        e=tie(a,r,c);\n    }\n    sort(cards.rbegin(),cards.rend());\n    union_find uf(h+w);\n    long long ans{};\n    bool ext[2<<17]={};\n    for(auto &e : cards)\n    {\n        int a,r,c; tie(a,r,c)=e;\n        r=uf.find(r),c=uf.find(c);\n        if(r!=c)\n        {\n            if(ext[r] and ext[c]) continue;\n            ext[uf.unite(r,c)]=ext[r]||ext[c];\n            ans+=a;\n        }\n        else if(!ext[r])\n        {\n            ext[r]=true;\n            ans+=a;\n        }\n    }\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Dsu {\n    int n;\n    vector<int> p;\n    vector<int> r;\n    \n    Dsu(int _n) { n = _n; p.resize(n); r.resize(n); init(); }\n    inline void init() {\n        for (int i = 0; i < n; i++) {\n            p[i] = i;\n            r[i] = 1;\n        }\n    }\n    inline int find(int x) {\n        return p[x] == x ? x: p[x] = find(p[x]);\n    }\n    inline bool join(int x, int y) {\n        x = find(x); y = find(y);\n        if (x == y) return false;\n        if (r[x] < r[y]) swap(x, y);\n        p[y] = x; r[x] += r[y];\n        return true;\n    }\n    inline bool check(int x, int y) {\n        return find(x) == find(y);\n    }\n};\n\nstruct Edge {\n    int r, c, x;\n    Edge() {}\n    Edge(int _r, int _c, int _x) : r(_r), c(_c), x(_x) {}\n    bool operator<(const Edge& _e) const {\n        return x > _e.x;\n    }\n};\n\nvoid solve() {\n    int n, h,w;\n    cin >> n >> h >> w;\n    vector<Edge> e(n);\n    for (int i = 0; i < n; i++) {\n        int r,c,a;\n        cin >> r >> c >> a;\n        r--; c += h-1;\n        e[i] = {r,c,a};\n    }\n    Dsu d(h+w);\n    sort(e.begin(), e.end());\n    vector<int> sz(h+w, 0);\n    long long res = 0;\n    for (auto& p: e) {\n        int u = d.find(p.r), v = d.find(p.c);\n        if (u == v) {\n            if (sz[u] < d.r[u]){\n                res += p.x;\n                sz[u]++;\n            }\n        } else {\n            if (sz[u]+sz[v] < d.r[u]+d.r[v]) {\n                res += p.x;\n                d.join(u,v);\n                int s = sz[u]+sz[v]+1;\n                sz[u] = sz[v] = s;\n            }\n        }\n    }\n    cout << res;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    solve();\n    cout << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n\n  int N,H,W; cin>>N>>H>>W;\n  struct Panel {\n    int r,c,a;\n  };\n  vector<Panel> panels(N);\n  for (auto& p : panels) {\n    cin >> p.r >> p.c >> p.a;\n    p.r--; p.c--;\n  }\n  sort(panels.begin(), panels.end(), [](auto l, auto r) {return l.a > r.a;});\n\n  struct Graph {\n    int n = 1;\n    int e = 0;\n    void operator+=(const Graph& x) {\n      n += x.n;\n      e += x.e;\n    }\n  };\n  vector<Graph> gdata(H+W);\n  vector<int> parents(H+W);\n  iota(parents.begin(), parents.end(), 0);\n  auto root = [f=[&](auto root, int x) {\n    if (parents[x] == x)\n      return x;\n    return parents[x] = root(root, parents[x]);\n  }] (int x) {\n    return f(f, x);\n  };\n  auto unite = [&](int rx, int ry) {\n    if (rx > ry)\n      swap(rx, ry);\n    parents[ry] = rx;\n  };\n  auto check = [&](int x, int y) {\n    auto rx = root(x);\n    auto ry = root(y);\n    if (rx == ry) {\n      if (gdata[rx].e+1 <= gdata[rx].n) {\n        unite(rx, ry);\n        gdata[root(rx)].e++;\n        return true;\n      }\n    } else {\n      if (gdata[rx].e+gdata[ry].e+1 <= gdata[rx].n+gdata[ry].n) {\n        unite(rx, ry);\n        gdata[root(rx)] += gdata[root(rx)^rx^ry];\n        gdata[root(rx)].e++;\n        return true;\n      }\n    }\n    return false;\n  };\n\n  long ans = 0;\n  unordered_map<int, vector<int>> sr, sc;\n  for (auto p : panels) {\n    if (check(p.r, H+p.c)) {\n      ans += p.a;\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef pair<ll, P> P3;\n\nstruct UF{\n    int N;\n    vector<int> par, siz, ecnt;\n    void init(int _n){\n        N = _n;\n        par.resize(N);\n        siz.resize(N, 1);\n        ecnt.resize(N, 0);\n        for(int i=0;i<N;i++){\n            par[i] = i;\n        }\n    }\n    int root(int x){\n        if(par[x] == x) return x;\n        else return par[x] = root(par[x]);\n    }\n    void unite(int x, int y){\n        x = root(x);\n        y = root(y);\n        ecnt[x]++;\n        if(x == y) return;\n        if(siz[x] < siz[y]) swap(x,y);\n        par[y] = x;\n        siz[x] += siz[y];\n        ecnt[x] += ecnt[y];\n    }\n    bool check(int x, int y){\n        x = root(x);\n        y = root(y);\n        if(x == y){\n            return siz[x] > ecnt[x];\n        }\n        else{\n            return siz[x]+siz[y] > ecnt[x]+ecnt[y];\n        }\n    }\n};\n\nUF uf;\n\nint main() {\n    int N, H, W;\n    vector<P3> es;\n    cin >> N >> H >> W;\n    uf.init(H+W);\n    for(int i=0;i<N;i++){\n        ll r, c, a;\n        cin >> r >> c >> a;\n        r--; c--;\n        es.push_back({a,{r,c}});\n    }\n    sort(es.rbegin(), es.rend());\n    ll ans = 0;\n    for(int i=0;i<N;i++){\n        ll r, c, a;\n        r = es[i].second.first;\n        c = es[i].second.second;\n        a = es[i].first;\n        if(uf.check(r, c+H)){\n            uf.unite(r, c+H);\n            ans += a;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\n//KUPC2017J\n//AOJDSL1A\n//without rank\nstruct unionfind{\n\tvi p,s;\n\tint c;\n\tunionfind(int n):p(n,-1),s(n,1),c(n){}\n\tint find(int a){\n\t\treturn p[a]==-1?a:(p[a]=find(p[a]));\n\t}\n\t//set b to a child of a\n\tbool unite(int a,int b){\n\t\ta=find(a);\n\t\tb=find(b);\n\t\tif(a==b)return false;\n\t\tp[b]=a;\n\t\ts[a]+=s[b];\n\t\tc--;\n\t\treturn true;\n\t}\n\tbool same(int a,int b){\n\t\treturn find(a)==find(b);\n\t}\n\tint sz(int a){\n\t\treturn s[find(a)];\n\t}\n};\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tint n,h,w;cin>>n>>h>>w;\n\tunionfind uf(h+w);\n\tvc<tuple<int,int,int>> es;\n\trep(_,n){\n\t\tint r,c,a;cin>>r>>c>>a;\n\t\tes.eb(a,r-1,h+c-1);\n\t}\n\tsort(all(es));\n\treverse(all(es));\n\tvi has(h+w);\n\tint ans=0;\n\tfor(auto e:es){\n\t\tint c,i,j;tie(c,i,j)=e;\n\t\ti=uf.find(i);\n\t\tj=uf.find(j);\n\t\tif(i==j){\n\t\t\tif(has[i])continue;\n\t\t\thas[i]=1;\n\t\t\tans+=c;\n\t\t}else if(has[i]+has[j]<=1){\n\t\t\thas[i]|=has[j];\n\t\t\tuf.unite(i,j);\n\t\t\tans+=c;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define all(v) (v).begin(), (v).end()\n#define sortv(v) sort(all(v))\n#define uniqv(v) (v).erase(unique(all(v)), (v).end())\n#define pb push_back\n#define FI first\n#define SE second\n#define lb lower_bound\n#define ub upper_bound\n#define mp make_pair\n#define test 1\n#define TEST if(test)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\nconst int MOD = 1000000007; // 998244353\nconst int INF = 2e9;\nconst ll INFLL = 1e18;\nconst int MAX_N = 100000;\n\nint N, H, W;\n\n\nstruct S{\n\tint x, y, d;\n\tbool operator <(const S &a)const{\n\t\treturn d<a.d;\n\t}\n};\nvector<S> v;\n\nll ans;\n\nvector<int> gp[MAX_N*2+1];\nbool chk[MAX_N*2+1];\n\nvoid make(int x, int y){\n\tchk[x] = true;\n\tfor(int i : gp[x]){\n\t\tif(i!=y){\n\t\t\tmake(i, x);\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\tcin>>N>>H>>W;\n\tfor(int i=1; i<=N; i++){\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tv.pb((S){a, b+H, c});\n\t}\n\tsort(v.begin(), v.end());\n\twhile(!v.empty()){\n\t\tS now = v.back(); v.pop_back();\n\t\tif(!chk[now.x] && !chk[now.y]){\n\t\t\tgp[now.x].pb(now.y);\n\t\t\tif(gp[now.x].size()==2)\tchk[now.x] = true;\n\t\t\tgp[now.y].pb(now.x);\n\t\t\tif(gp[now.y].size()==2)\tchk[now.y] = true;\n\t\t\tans+=(ll)now.d;\n\t\t}\n\t\telse if(chk[now.x] && !chk[now.y]){\n\t\t\tmake(now.y, 0);\n\t\t\tans+=(ll)now.d;\n\t\t}else if(!chk[now.x] && chk[now.y]){\n\t\t\tmake(now.x, 0);\n\t\t\tans+=(ll)now.d;\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Card {\n  int row;\n  int col;\n  int value;\n};\n\nenum Type {\n  Row,\n  Col,\n};\n\nstruct Pos {\n  Type type;\n  int index;\n};\n\nusing Choise = vector<Pos>;\n\nint main() {\n  int N, H, W;\n  cin >> N >> H >> W;\n  vector<bool> row_done(H + 1);\n  vector<bool> col_done(W + 1);\n  deque<Choise> choices;\n  vector<Choise*> row_choice(H + 1);\n  vector<Choise*> col_choice(W + 1);\n  auto cmp = [](auto&& lhs, auto&& rhs) { return lhs.value < rhs.value; };\n  priority_queue<Card, vector<Card>, decltype(cmp)> q{cmp};\n  for (int i = 1; i <= N; ++i) {\n    Card c;\n    cin >> c.row >> c.col >> c.value;\n    q.emplace(move(c));\n  }\n  int64_t result = 0;\n  for (; !q.empty(); q.pop()) {\n    auto&& c = q.top();\n    if (row_done[c.row] && col_done[c.col]) {\n      continue;\n    }\n    result += c.value;\n    if (row_done[c.row]) {\n      col_done[c.col] = true;\n      if (auto choice = col_choice[c.col]) {\n        for (auto&& pos : *choice) {\n          switch (pos.type) {\n            case Row:\n              row_done[pos.index] = true;\n              break;\n            case Col:\n              col_done[pos.index] = true;\n              break;\n          }\n        }\n      }\n    } else if (col_done[c.col]) {\n      row_done[c.row] = true;\n      if (auto choice = col_choice[c.col]) {\n        for (auto&& pos : *choice) {\n          switch (pos.type) {\n            case Row:\n              row_done[pos.index] = true;\n              break;\n            case Col:\n              col_done[pos.index] = true;\n              break;\n          }\n        }\n      }\n    } else {\n      auto row_free = row_choice[c.row] == nullptr;\n      auto col_free = col_choice[c.col] == nullptr;\n      col_done[c.col] = true;\n      if (row_free && col_free) {\n        Choise conf{\n            Pos{Row, c.row},\n            Pos{Col, c.col},\n        };\n        choices.emplace_back(move(conf));\n        row_choice.emplace_back(&choices.back());\n        col_choice.emplace_back(&choices.back());\n      } else if (row_free) {\n        auto& choice = col_choice[c.col];\n        choice->emplace_back(Pos{Row, c.row});\n      } else if (col_free) {\n        auto& choice = row_choice[c.row];\n        choice->emplace_back(Pos{Col, c.col});\n      } else {\n        auto&& c1 = *row_choice[c.row];\n        auto&& c2 = *col_choice[c.col];\n        for (auto&& pos : c2) {\n          c1.push_back(pos);\n        }\n        col_choice[c.col] = &c1;\n      }\n    }\n  }\n  cout << result << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int MAXN = 1e5 + 10;\n\nstruct node{\n    int u,v;\n    ll w;\n}edge[MAXN];\n\nbool cmp(node a,node b){return a.w > b.w;}\n\nint f[MAXN<<1],sz[MAXN<<1];\n\nint find(int x)\n{\n    int t = x;\n    while (x != f[x]) x = f[x];\n    while (t != f[t])\n    {\n        int tmp = f[t];\n        f[t] = x;\n        t = tmp;\n    }\n    return x;\n}\n\nint main()\n{\n    int n,h,w;\n    scanf(\"%d%d%d\",&n,&h,&w);\n    for (int i = 1;i<=n;i++)\n    {\n        scanf(\"%d%d%lld\",&edge[i].u,&edge[i].v,&edge[i].w);\n    }\n    sort(edge+1,edge + n + 1,cmp);\n    ll ans = 0;\n    for (int i = 1;i<=h+w;i++) f[i] = i,sz[i] = 1;\n    for (int i = 1;i<=n;i++)\n    {\n        int fu = find(edge[i].u),fv = find(edge[i].v + h);;\n        if (fu == fv)\n        {\n            if (sz[fu] > 0)\n            {\n                ans += edge[i].w;\n                sz[fu]--;\n            }\n        }\n        else\n        {\n            if (sz[fu] + sz[fv] > 0)\n            {\n                f[fv] = fu;\n                sz[fu] += sz[fv] - 1;\n                ans += edge[i].w;\n            }\n        }\n    }\n    printf(\"%lld\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <cassert>\n#include <string.h>\n//#include <unordered_set>\n//#include <unordered_map>\n//#include <bits/stdc++.h>\n\n#define MP(A,B) make_pair(A,B)\n#define PB(A) push_back(A)\n#define SIZE(A) ((int)A.size())\n#define LEN(A) ((int)A.length())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define fi first\n#define se second\n\nusing namespace std;\n\ntemplate<typename T>inline bool upmin(T &x,T y) { return y<x?x=y,1:0; }\ntemplate<typename T>inline bool upmax(T &x,T y) { return x<y?x=y,1:0; }\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double lod;\ntypedef pair<int,int> PR;\ntypedef vector<int> VI;\n\nconst lod eps=1e-11;\nconst lod pi=acos(-1);\nconst int oo=1<<30;\nconst ll loo=1ll<<62;\nconst int mods=1e9+7;\nconst int MAXN=600005;\nconst int INF=0x3f3f3f3f;//1061109567\n/*--------------------------------------------------------------------*/\ninline int read()\n{\n\tint f=1,x=0; char c=getchar();\n\twhile (c<'0'||c>'9') { if (c=='-') f=-1; c=getchar(); }\n\twhile (c>='0'&&c<='9') { x=(x<<3)+(x<<1)+(c^48); c=getchar(); }\n\treturn x*f;\n}\nll ans=0;\nint f[MAXN],flag[MAXN],edgenum=0;\nstruct enode{int u,v,c; } e[MAXN];\nint compare(enode x,enode y){ return x.c>y.c; }\nint find(int x){return f[x]==x?f[x]:f[x]=find(f[x]); }\nvoid unions(int x,int y,int c)\n{\n//\tcout<<x<<\" \"<<y<<\" \"<<c<<endl;\n\tint xx=find(x),yy=find(y);\n\tif (xx==yy)\n\t{\n\t\tif (!flag[xx]) ans+=c,flag[xx]=1;\n\t\treturn;\n\t}\n\tif (flag[xx]&&flag[yy]) return;\n\tf[xx]=yy;\n\tflag[yy]=flag[yy]|flag[xx];\n\tans+=c;\n}\nint main()\n{\n    int n=read(),H=read(),W=read();\n    for (int i=1;i<=n;i++)\n    {\n    \tint x=read(),y=read()+H,c=read();\n    \te[++edgenum]=(enode){x,y,c};\n\t}\n\tsort(e+1,e+edgenum+1,compare);\n\tfor (int i=1;i<=H+W;i++) f[i]=i,flag[i]=0;\n\tfor (int i=1;i<=edgenum;i++) unions(e[i].u,e[i].v,e[i].c); \n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nstruct edge{\n  ll u,v,cost;\n};\nbool operator<(const edge& x,const edge& y){\n  return x.cost < y.cost;\n}\n\nstruct UnionFind{\n  vector<int> v;\n  vector<bool> done;\n  UnionFind(int n) : v(n, -1), done(n, false) {}\n  void init(){ for(int i = 0;i < (int)v.size();i++)v[i]=-1; }\n  int find(int x) { return v[x] < 0 ? x : find(v[x]); }\n  bool unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return false;\n    if (-v[x] < -v[y]) swap(x, y);\n    v[x] += v[y]; v[y] = x;\n    done[x]=done[x]|done[y];\n    return true;\n  }\n  bool root(int x) { return v[x] < 0; }\n  bool same(int x, int y) { return find(x) == find(y); }\n  int size(int x) { return -v[find(x)]; }\n};\n\nll n,h,w;\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  cin>>n>>h>>w;\n  vector<edge> vs;\n  rep(i,n){\n    ll r,c,a;\n    cin>>r>>c>>a;\n    r--;c--;\n    vs.push_back((edge){r,c+h,a});\n  }\n  sort(all(vs)); reverse(all(vs));\n\n  UnionFind uf(h+w);\n  ll res=0;\n  rep(i,n){\n    if(!uf.same(vs[i].u,vs[i].v)){\n      if(uf.done[uf.find(vs[i].u)]&&uf.done[uf.find(vs[i].v)]){\n        continue;\n      }\n      uf.unite(vs[i].u,vs[i].v);\n      res+=vs[i].cost;\n    }else{\n      if(!uf.done[uf.find(vs[i].u)]){\n        uf.done[uf.find(vs[i].u)]=true;\n        res+=vs[i].cost;\n      }\n    }\n  }\n  cout<<res<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <random>\n#include <tuple>\n#include <iomanip>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n//typedef pair<int,int> Pint;\n//typedef pair<ll, ll> P;\n//typedef pair<ll, pair<ll, ll>> P;\n//typedef tuple<int,int,int> T;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define revrep(i, n) for(ll i = (n-1); i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\n//const ll INFL = 1LL << 60;//10^18 = 2^60\nconst ll INFL = 1LL << 60;\nconst int INF = 1 << 30;//10^9\nll MOD = 1000000007;\n//ll MOD  = 998244353;\nvector<ll> dy = {0, 0, 1, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {1, -1, 0, 0, 1, -1, 1, -1, 0};\n\nll max(ll a, ll b){return (a > b) ? a : b;}\nll min(ll a, ll b){return (a < b) ? a : b;}\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x;\n    k /= 2;\n  }\n  return res;\n}\nll pow_mod(ll x, ll k){\n  x %= MOD; x += MOD; x %= MOD;\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\nll inverse(ll x){return pow_mod(x, MOD - 2);};\n\n//最大公約数\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\n//最小公倍数\nll lcm(ll x, ll y){return x / gcd(x, y) * y;};\n\nll kai_mod(ll x){\n  if(x == 0) return 1;\n  return x * kai_mod(x-1) % MOD;\n}\n\n//コンビネーション\nconst int MAXcomb = 200010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\n//facはn!,finvは1/n!\n//invは逆元\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nll comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] % MOD * finv[n-k] % MOD;\n}\n\nconst ll MAX_V = 200010;\n\nll par[MAX_V];\nll Rank[MAX_V];\nll child[MAX_V];\nll e[MAX_V];\n\nvoid init_UF(ll n){\n    for(ll i = 0; i < n; i++){\n        par[i] = i;\n        Rank[i] = 1;\n        child[i] = 1;\n    }\n}\n\nll find(ll x){\n    if(par[x] == x) return x;\n    else{\n        return par[x] = find(par[x]);\n    }\n}\n\nbool same(ll x, ll y){\n    return find(x) == find(y);\n}\n\nvoid unite(ll x, ll y){\n    ll rx = find(x), ry = find(y);\n    if(rx != ry){\n        if(Rank[rx] >= Rank[ry]){\n            par[ry] = rx;\n            if(Rank[rx] == Rank[ry]) Rank[rx]++;\n            child[rx] += child[ry];\n        }else{\n            par[rx] = ry;\n            child[ry] += child[rx];\n        }\n        e[par[rx]] = e[rx] + e[ry] + 1;\n    }else{\n      e[rx]++;\n    }\n}\n\nll N, H, W;\nvector<pair<ll, pair<ll, ll>>> A;\n\nint main(){\n  cin >> N >> H >> W;\n  A.resize(N);\n  rep(i, N){\n    cin >> A[i].s.f >> A[i].s.s >> A[i].f;\n    A[i].s.f--;\n    A[i].s.s--;\n    A[i].s.s += H;\n  }\n  sort(A.begin(), A.end());\n  reverse(A.begin(), A.end());\n  init_UF(200005);\n  ll ans = 0;\n  rep(i, N){\n    ll r = A[i].s.f;\n    ll c = A[i].s.s;\n    if(same(r, c)){\n      ll rr = find(r);\n      if(e[rr] + 1 <= child[rr]){\n        ans += A[i].f;\n        unite(r, c);\n      }\n    }else{\n      ll rr = find(r);\n      ll rc = find(c);\n      if(e[rr] + e[rc] + 1 <= child[rr] + child[rc]){\n        ans += A[i].f;\n        unite(r, c);\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'[';\n    for(const T &i: a) out<<i<<',';\n    out<<']';\n    return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out, const set<T>& a) {\n    out<<'{';\n    for(const T &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\ntemplate<class T, class S>\nostream &operator <<(ostream& out, const map<T,S>& a) {\n    out<<'{';\n    for(auto &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nstruct UnionFind {\n    vector<int> par, s, es;\n    UnionFind(int n=2e5) { init(n); }\n    void init(int n) {\n        s.assign(n, 1); es.resize(n); par.resize(n);\n        iota(par.begin(), par.end(), 0);\n    }\n    int find(int x) {\n        if(par[x] == x) return x;\n        return par[x] = find(par[x]);\n    }\n    void unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if(x == y) { es[x]++; return; }\n        if(s[x] < s[y]) {\n            par[x] = y;\n            s[y] = s[x] + s[y];\n            es[y] = es[x] + es[y] + 1;\n        } else {\n            par[y] = x;\n            s[x] = s[x] + s[y];\n            es[x] = es[x] + es[y] + 1;\n        }\n    }\n    bool same(int x, int y) { return find(x) == find(y); }\n    int size(int x) { return s[find(x)]; }\n};\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n, h, w;\n    cin >> n >> h >> w;\n    vector<ll> x(n), y(n), a(n);\n    REP(i, n) {\n        cin >> y[i] >> x[i] >> a[i];\n        y[i]--, x[i]--;\n        y[i] += w;\n    }\n\n    vector<ll> idx(n);\n    iota(ALL(idx), 0);\n    sort(ALL(idx), [&](ll l, ll r){\n        return a[l] < a[r];\n    });\n    reverse(ALL(idx));\n\n    UnionFind uf(w+h);\n    ll ret = 0;\n    for(auto i: idx) {\n        ll v1 = uf.size(x[i]), v2 = uf.size(y[i]);\n        ll e1 = uf.es[uf.find(x[i])], e2 = uf.es[uf.find(y[i])];\n        if((uf.same(x[i], y[i]) && e1+1<=v1) || (!uf.same(x[i], y[i]) && e1+e2+1<=v1+v2)) {\n            uf.unite(x[i], y[i]);\n            ret += a[i];\n        }\n    }\n    cout << ret << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n * Author       : YangDavid\n * Created Time : 2019年08月25日 星期日 22时41分33秒\n */\n\n#include<bits/stdc++.h>\n#define rep(i, n) for(int i = 1; i <= n; ++i)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nconst int maxn = 222222;\nint n, h, w, fa[maxn], vis[maxn];\nstruct item {\n    int r, c, w;\n    bool operator < (const item& rhs) const { return w > rhs.w; }\n} a[maxn];\nint find(int x) { return x==fa[x] ? x : fa[x] = find(fa[x]); }\n\nint main() {\n    scanf(\"%d%d%d\", &n, &h, &w);\n    rep(i, h + w) fa[i] = i;\n\n    ll ans = 0;\n    rep(i, n) scanf(\"%d%d%d\", &a[i].r, &a[i].c, &a[i].w);\n    sort(a + 1, a + n + 1);\n    rep(i, n) {\n        int p1 = find(a[i].r), p2 = find(a[i].c + h);\n        if(vis[p1] && vis[p2]) continue;\n        ans += a[i].w;\n        if(p1 == p2) vis[p1] = true;\n        else {\n            if(vis[p1]) vis[p2] = true;\n            else if(vis[p2]) vis[p1] = true;\n            else fa[p2] = p1;\n        }\n    }\n    printf(\"%lld\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*Lucky_Glass*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N=1e5;\n\nint n,Vr,Vc;\nlong long ans;\n\nstruct MERGESET{\n\tint fa[4*N+3],cntx[4*N+3],cnty[4*N+3];\n\tvoid Init(int Vn){\n\t\tfor(int i=1;i<=Vn;i++){\n\t\t\tfa[i]=i;\n\t\t\tif(i<=n) cntx[i]=1,cnty[i]=0;\n\t\t\telse cntx[i]=0,cnty[i]=1;\n\t\t}\n\t}\n\tint FindFa(int x){return fa[x]=fa[x]==x? x:FindFa(fa[x]);}\n\tvoid Merge(int x,int y){\n\t\tint fx=FindFa(x),fy=FindFa(y);\n\t\tif(fx==fy) return;\n\t\tfa[fx]=fy;\n\t\tcntx[fy]+=cntx[fx];cntx[fx]=0;\n\t\tcnty[fy]+=cnty[fx];cnty[fx]=0;\n\t}\n}mgset;\n\nstruct NODE{int x,y,val;}nod[N+3];\nbool cmpNODE(NODE Ca,NODE Cb){return Ca.val>Cb.val;}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&Vr,&Vc);\n\tmgset.Init(n+Vr+Vc);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d%d%d\",&nod[i].x,&nod[i].y,&nod[i].val);\n\tsort(nod+1,nod+1+n,cmpNODE);\n\tfor(int i=1;i<=n;i++){\n\t\tint x=nod[i].x,y=nod[i].y;\n\t\tint fx=mgset.FindFa(x+n),fy=mgset.FindFa(y+n+Vr);\n\t\tint cntx,cnty;\n\t\tif(fx==fy) cntx=mgset.cntx[fx],cnty=mgset.cnty[fx];\n\t\telse cntx=mgset.cntx[fx]+mgset.cntx[fy],cnty=mgset.cnty[fx]+mgset.cnty[fy];\n\t\tif(cntx+1>cnty) continue;\n\t\tans+=nod[i].val;\n\t\tmgset.Merge(i,x+n);\n\t\tmgset.Merge(x+n,y+n+Vr);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REPP(i,n) for(int i=1;i<=n;i++)\nconst double PI = acos(-1);\nconst double EPS = 1e-15;\nlong long INF=(long long)1E17;\n#define i_7 (long long)(1E9+7)\nlong mod(long a){\n    long long c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\n\nusing namespace std;\nbool prime_(int n){\n  if(n==1){\n    return false;\n  }else if(n==2){\n    return true;\n  }else{\n    for(int i=2;i<=sqrt(n);i++){\n      if(n%i==0){\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nlong long gcd_(long long a, long long b){\n  if(a<b){\n    swap(a,b);\n  }\n  if(a%b==0){\n    return b;\n  }else{\n    return gcd_(b,a%b);\n  }\n}\n \nlong long lcm_(long long x, long long y){\n  return (x/gcd_(x,y))*y;\n}\n \nclass UnionFind {\n    public:\n    //各頂点の親の番号を格納する。その頂点自身が親だった場合は-(その集合のサイズ)を入れる。\n    vector<int> Parent;\n    \n    //クラスを作るときは、Parentの値を全て-1にする。\n    //以下のようにすると全てバラバラの頂点として解釈できる。\n    UnionFind(int N) {\n        Parent = vector<int>(N, -1);\n    }\n    \n    //Aがどのグループに属しているか調べる\n    int root(int A) {\n        if (Parent[A] < 0) return A;\n        return Parent[A] = root(Parent[A]);\n    }\n    \n    //自分のいるグループの頂点数を調べる\n    int size(int A) {\n        return -Parent[root(A)];//先祖をrootで取っておきたい。\n    }\n    \n    //AとBをくっ付ける\n    bool connect(int A, int B) {\n        //AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける\n        A = root(A);\n        B = root(B);\n        if (A == B) {\n            //すでにくっついてるからくっ付けない\n            return false;\n        }\n        \n        //大きい方(A)に小さいほう(B)をくっ付けたい\n        //大小が逆だったらAとBをひっくり返す。\n        if (size(A) < size(B)) swap(A, B);\n        \n        //Aのサイズを更新する\n        Parent[A] += Parent[B];\n        //Bの親をAに変更する\n        Parent[B] = A;\n        \n        return true;\n    }\n};\n\nint main(){\n  \n  int n,h,w;\n  cin>>n>>h>>w;\n  int r[n],c[n];\n  long long a[n];\n  REP(i,n){\n    cin>>r[i]>>c[i]>>a[i];\n    r[i]--;c[i]--;\n  }\n  vector<pair<long long, int>> rows[h];//行ごとに入っているカードを分類\n  vector<pair<long long, int>> columns[w];//列ごとに入っているカードを分類\n  vector<bool> used(n,false);\n  REP(i,n){\n    rows[r[i]].push_back(make_pair(a[i],i));\n    columns[c[i]].push_back(make_pair(a[i],i));\n  }\n  REP(i,h){\n    sort(rows[i].begin(), rows.end(), greater<pair<long long, int>>());\n  }\n  REP(i,w){\n    sort(columns[i].begin(), columns.end(), greater<pair<long long, int>>());\n  }\n  \n  long long ans = 0;\n  REP(i,h){\n    if(rows[i].empty())continue;\n    used[rows[i][0].second] = true;\n    ans += rows[i][0].first;\n  }\n  int s;\n  REP(i,w){\n    if(columns[i].empty())continue;\n    s = columns[i].size()\n    REP(j,s){\n      if(used[columns[i][j].second])continue;\n      used[columns[i][j].second] = true;\n      ans += columns[i][j].first;\n      break;\n    }\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <cstring>\n#include <queue>\n#include <set>\n#include <string>\n#include <functional>\n#include <cassert>\n#include <cmath>\n#define SIZE 200005\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n\nstruct UF\n{\n\tint par[SIZE],rank[SIZE];\n\tint sz[SIZE];\n\t\n\tvoid init(int n)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tpar[i]=i;\n\t\t\trank[i]=1;\n\t\t\tsz[i]=-1;\n\t\t}\n\t}\n\tint find(int x)\n\t{\n\t\tif(x==par[x]) return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\tint get(int v)\n\t{\n\t\treturn sz[find(v)];\n\t}\n\tvoid unite(int x,int y)\n\t{\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y)\n\t\t{\n\t\t\tsz[x]++;\n\t\t\treturn;\n\t\t}\n\t\tif(rank[x]<rank[y])\n\t\t{\n\t\t\tpar[x]=y;\n\t\t\tsz[y]+=sz[x];\n\t\t\tsz[y]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpar[y]=x;\n\t\t\tsz[x]+=sz[y];\n\t\t\tsz[x]++;\n\t\t\tif(rank[x]==rank[y]) rank[x]++;\n\t\t}\n\t}\n\tbool same(int x,int y)\n\t{\n\t\treturn find(x)==find(y);\n\t}\n}uf;\nvector <PP> edge;\nbool use[SIZE];\n\nint main()\n{\n\tint n,h,w;\n\tscanf(\"%d %d %d\",&n,&h,&w);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint r,c,a;\n\t\tscanf(\"%d %d %d\",&r,&c,&a);r--,c--;\n\t\tedge.push_back(PP(a,P(r,c+h)));\n\t}\n\tsort(edge.begin(),edge.end(),greater<PP>());\n\tuf.init(h+w+2);\n\tll ret=0;\n\tfor(int i=0;i<edge.size();i++)\n\t{\n\t\tP p=edge[i].second;\n\t\tint a=uf.get(p.first),b=uf.get(p.second);\n\t\tif(a+b+1<=0)\n\t\t{\n\t\t\tuf.unite(p.first,p.second);\n\t\t\tret+=edge[i].first;\n\t\t\tuse[i]=true;\n\t\t\t//printf(\"* %d %d : %d\\n\",p.first,p.second,edge[i].first);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define modulo 1000000007\n#define mod(mod_x) ((((long long)mod_x+modulo))%modulo)\n#define Inf 100000000\nstruct unionfind{\n\tvector<int> data;\n\tvector<int> size;\n\tunionfind(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdata.push_back(i);\n\t\t\tsize.push_back(1);\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif(data[x]==x)return x;\n\t\treturn data[x]=find(data[x]);\n\t}\n\t\n\tbool unite(int x,int y){\n\t\tx=find(x);y=find(y);\n\t\tif(x==y)return false;\n\t\tdata[x]=y;\n\t\tsize[y]+=size[x];\n\t\treturn true;\n\t}\n\t\n\tbool check(int x,int y){\n\t\treturn (find(x)==find(y));\n\t}\n\t\n\tint get_size(int x){\n\t\tint X = find(x);\n\t\treturn size[X];\n\t}\n};\n\n\nint main(){\n\t\n\tint N,H,W;\n\tcin>>N>>H>>W;\n\t\n\tvector<pair<long long,pair<int,int>>> V(N);\n\t\n\tmap<int,int> mp1,mp2;\n\t\n\tfor(int i=0;i<N;i++){\n\t\tcin>>V[i].second.first>>V[i].second.second>>V[i].first;\n\t\tmp1[V[i].second.first]=-1;\n\t\tmp2[V[i].second.second]=-1;\n\t\t\n\t}\n\tint now = 0;\n\tfor(auto &a:mp1){\n\t\ta.second=now;\n\t\tnow++;\n\t}\n\tnow=0;\n\tfor(auto &a:mp2){\n\t\ta.second = now;\n\t\tnow++;\n\t}\n\t\n\tfor(int i=0;i<N;i++){\n\t\tV[i].second.first = mp1[V[i].second.first];\n\t\tV[i].second.second = mp2[V[i].second.second];\n\t}\n\t\n\tunionfind uf(2*N);\n\t\n\tsort(V.begin(),V.end());\n\t\n\tlong long ans = 0;\n\tset<int> NG;\n\tfor(int i=N-1;i>=0;i--){\n\t\tint a = V[i].second.first;\n\t\tint b = V[i].second.second+N;\n\t\tif(NG.count(uf.find(a))&&NG.count(uf.find(b)))continue;\n\t\tans += V[i].first;\n\t\tif(!uf.unite(a,b)||(NG.count(a)||NG.count(b))){\n\t\t\tNG.insert(uf.find(a));\n\t\t}\n\t\t\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <math.h>\n#include <chrono>\nusing namespace std;\n#pragma GCC optimize(\"-O3\")\n#define endl \"\\n\"\n#define mp make_pair\n#define st first\n#define nd second\n#define pii pair<int, int>\n#define pb push_back\n#define _upgrade ios_base::sync_with_stdio(0), cout.setf(ios::fixed), cout.precision(10) //cin.tie(0); cout.tie(0);\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define FWD(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define fwd(i, a, b) for (int i = (a); i < (b); ++i)\n#define all(c) (c).begin(), (c).end()\n#define what(x) cerr << #x << \" is \" << x << endl;\n#define int long long\n\nconst int MAXN = 2e5 + 1e4;\nint kapitan[MAXN];\nint wynik = 0;\n\nint fiind(int x)\n{\n    if (kapitan[x] != x)\n        kapitan[x] = fiind(kapitan[x]);\n    return kapitan[x];\n}\nvoid unia(pair<int, pii> P)\n{\n    // cerr << P.st << \" \" << P.nd.st << \" \" << P.nd.nd << endl;\n    int x = fiind(P.nd.st);\n    int y = fiind(P.nd.nd);\n    if (x > y)\n        swap(x, y);\n    if (x == 0 && y == 0)\n        return;\n    wynik += P.st;\n    if (x == 0 || x == y)\n        kapitan[y] = 0;\n    else\n        kapitan[y] = x;\n}\n\nvector<pair<int, pii>> A;\nmain()\n{\n    _upgrade;\n    iota(kapitan, kapitan + MAXN, 0);\n    int n, w, h;\n    cin >> n >> w >> h;\n    rep(i, n)\n    {\n        int b, c, a;\n        cin >> b >> c >> a;\n        b += max(w, h) + 2;\n        A.pb(mp(a, mp(b, c)));\n    }\n    sort(all(A), greater<pair<int, pii>>());\n    for (auto a : A)\n        unia(a);\n    cout << wynik << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nstruct dat {\n    int a,r,c;\n    bool operator<(const dat x)const {\n        return a>x.a;\n    }\n}p[N];\nint n,h,w,fa[N<<1],vl[N<<1],ans;\nint find(int u) {\n    return fa[u]==u?u:fa[u]=find(fa[u]);\n}\nvoid ut(int u,int v) {\n    int fu=find(u),fv=find(v);\n    if(fu!=fv) {\n        fa[fu]=fv;\n        vl[fv]+=vl[fu];\n    }\n}\nint main() {\n    scanf(\"%d%d%d\",&n,&h,&w);\n    for(int i=1;i<=h+w;i++) fa[i]=i,vl[i]=1;\n    for(int i=1;i<=n;i++) {\n        scanf(\"%d%d%d\",&p[i].r,&p[i].c,&p[i].a);\n        p[i].c+=h;\n    }\n    sort(p+1,p+n+1);\n    for(int i=1;i<=n;i++) {\n        ut(p[i].c,p[i].r);\n        int f=find(p[i].c);\n        // printf(\"fa[%d]=%d %d\\n\",f,vl[f],p[i].a);\n        if(vl[f]>=1) {\n            vl[f]--;\n            ans+=p[i].a;\n        }\n    }\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fto(i, a, b) for (int i = a; i <= b; i++)\n#define fdto(i, a, b) for (int i = a; i >= b; i--)\n#define fi first\n#define se second\n#define NTLiinhh \"bai5\"\nconst int maxn = 1000001, base = 1e9 + 7;\nusing namespace std;\ntypedef pair< int, int> pii;\ntypedef long long ll;\nint n, h, w, z[maxn], x[maxn], y[maxn];\nvector <pii> a[maxn], b[maxn];\nvoid Input()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL); cout.tie(NULL);\n    //freopen(NTLiinhh\".inp\", \"r\", stdin);\n    //freopen(NTLiinhh\".out\", \"w\", stdout);\n    cin >> n >> h >> w;\n    fto (i, 1, n) {\n        cin >> x[i] >> y[i] >> z[i];\n        a[x[i]].push_back({z[i], i});\n        b[y[i]].push_back({z[i], i});\n    }\n}\nint xd[maxn], r[maxn], c[maxn];\nvoid Solve()\n{\n    fto (i, 1, h) sort(a[i].begin(), a[i].end());\n    fto (i, 1, w) sort(b[i].begin(), b[i].end());\n    long long res=0;\n    fto (i, 1, h) if (a[i].size()==1 && xd[a[i][0].se]==0) {\n        res+=a[i][0].fi;\n        xd[a[i][0].se]=1;\n        r[i]=1;\n    }\n    fto (i, 1, w) if (b[i].size()==1 && xd[b[i][0].se]==0) {\n        res+=b[i][0].fi;\n        xd[b[i][0].se]=1;\n        c[i]=1;\n    }\n    fto (i, 1, h) if (!r[i] && a[i].size()) {\n        for (int j=a[i].size()-1; j>=0; j--)\n        if (xd[a[i][j].se]==0) {\n            xd[a[i][j].se]=1;\n            res+=a[i][j].fi;\n            r[i]=1;\n            break;\n        }\n    }\n    fto (i, 1, w) if (!c[i] && b[i].size()) {\n        for (int j=b[i].size()-1; j>=0; j--)\n        if (xd[b[i][j].se]==0) {\n            xd[b[i][j].se]=1;\n            res+=b[i][j].fi;\n            c[i]=1;\n            break;\n        }\n    }\n    cout << res;\n}\n\nint main()\n{\n    Input();\n    Solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define name \"bai5\"\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define fto(i,a,b) for(int i=a; i<=b;++i)\n#define maxn 100009\n#define ll long long\n\nusing namespace std;\nbool gone[maxn][3];\nint cl[maxn];\nint xd[maxn][3],a[maxn][3],w,h,n;\npii b[maxn];\nbool check(int i, int x,int j){\n    //if(!ck[i][x]) return false;\n    if(gone[i][x])return false;\n    gone[i][x]=true;\n    if(xd[i][x]==0){\n        xd[i][x]=j;\n        gone[i][x]=false;\n        return true;\n    }\n    /// xd[i][x]!=0;\n    /// i,x la cot hoac hang, j la chi so can dien\n    int t=xd[i][x];/// t la so can dien\n    if(check(a[t][1-x],1-x,t)){\n        xd[i][x]=j;\n        gone[i][x]=false;\n        return true;\n    }\n    gone[i][x]=false;\n    return false;\n}\nint main()\n{\n    cin >> n >> h >> w;\n    fto(i,1,n){\n        cin >> a[i][0]>> a[i][1] >> b[i].fi;\n        b[i].se=i;\n        ck[i][0]=ck[i][1]=true;\n    }\n    sort(b+1,b+n+1,greater<pii> ());\n    ll res=0;\n    fto(i,1,n){\n        int j=b[i].se;\n        if(check(a[j][0],0,j)){\n            //xd[a[j][0]][0]=j;\n            res+=b[i].fi;\n        }\n        else if(check(a[j][1],1,j)){\n            //xd[a[j][1]][1]=j;\n            res+=b[i].fi;\n        }\n    }\n    cout << res ;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UF {\n  vector<int> p;\npublic:\n  UF(int n) : p(n) {\n    for (int i = 0; i < n; ++i) p[i] = i;\n  }\n  int root(int i) {\n    if (p[i] == i) return i;\n    return p[i] = root(p[i]);\n  }\n  bool same(int i, int j) {\n    return root(i) == root(j);\n  }\n  void unite(int i, int j) {\n    int ri = root(i);\n    int rj = root(j);\n    p[ri] = rj;\n  }\n};\n\nusing T = pair<int, pair<int, int>>;\nint n, h, w;\nvector<int> G[200000];\nbool used[200000];\nvoid rec(int from) {\n  if (used[from]) return;\n  used[from] = true;\n  for (int to : G[from]) {\n    rec(to);\n  }\n}\n\nint main() {\n  cin >> n >> h >> w;\n  priority_queue<T> Q;\n  for (int k = 0; k < n; ++k) {\n    int i, j, a;\n    cin >> i >> j >> a;\n    --i; --j;\n    j += h;\n    Q.push(T(a, make_pair(i, j)));\n  }\n  \n  bool flg = false;\n  UF uf(h + w);\n  long sum = 0;\n  while (!Q.empty()) {\n    T t = Q.top(); Q.pop();\n    int a = t.first;\n    int i = t.second.first;\n    int j = t.second.second;\n    \n    if (used[i] && used[j]) continue;\n    if (uf.same(i, j)) {\n      rec(i);\n    } else {\n      uf.unite(i, j);\n      if (used[i]) used[j] = true;\n      if (used[j]) used[i] = true;\n    }\n    G[i].push_back(j);\n    G[j].push_back(i);\n    sum += a;\n  }\n  cout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define cerr if (false) cerr\n#define db(x) cerr << #x << \"=\" << x << endl\n#define db2(x, y) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << endl\n#define db3(x, y, z) cerr << #x << \"=\" << x << \",\" << #y << \"=\" << y << \",\" << #z << \"=\" << z << endl\n#define dbv(v) cerr << #v << \"=\"; for (auto _x : v) cerr << _x << \", \"; cerr << endl\n#define dba(a, n) cerr << #a << \"=\"; for (int _i = 0; _i < (n); ++_i) cerr << a[_i] << \", \"; cerr << endl\ntypedef long long ll;\ntypedef long double ld;\nint main() {\n\tint n, H, W;\n\tscanf(\"%d%d%d\", &n, &H, &W);\n\tvector<pair<int, pair<int, int>>> edges(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t--a;\n\t\t--b;\n\t\tedges[i] = {c, {a, H + b}};\n\t}\n\tsort(edges.begin(), edges.end());\n\tvector<int> par(H + W), nume(H + W), siz(H + W, 1);\n\tll ans = 0;\n\tiota(par.begin(), par.end(), 0);\n\tfunction<int(int)> root = [&](int a) {\n\t\tif (par[a] == a) return a;\n\t\treturn par[a] = root(par[a]);\n\t};\n\tfor (int i = n - 1; i >= 0; --i) {\n\t\tint a, b;\n\t\ttie(a, b) = edges[i].second;\n\t\tint pa = root(a), pb = root(b);\n\t\tif (pa == pb) {\n\t\t\tif (nume[pa] < siz[pa]) {\n\t\t\t\t++nume[pa];\n\t\t\t\tans += edges[i].first;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif (nume[pa] + nume[pb] + 1 > siz[pa] + siz[pb]) continue;\n\t\tsiz[pb] += siz[pa];\n\t\tnume[pb] += nume[pa] + 1;\n\t\tans += edges[i].first;\n\t\tpar[pa] = pb;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n\npriority_queue<pair<ll, ll>> R[100001] = {};\npriority_queue<ll> C[100001] = {};\n\nint main()\n{\n    int N, H, W;\n    cin >> N >> H >> W;\n    for(int i = 0; i < N; ++i){\n        int r, c, a;\n        cin >> r >> c >> a;\n        R[r].push(make_pair(a, c));\n        C[c].push(a);\n    }\n    \n    ull ans = 0;\n    for(int r = 1; r <= H; ++r){\n        while(!R[r].empty()){\n            auto v = R[r].top();\n            auto c = v.second;\n            if(C[c].size() > 1){\n                ans += v.first;\n                if(C[c].top() == v.first){\n                    C[c].pop();\n                }\n                //cout << r << \",\" << v.first << \",\" << v.second << endl;\n                break;\n            }\n            R[r].pop();\n        }\n    }\n    for(int c = 1; c <= W; ++c){\n        if(C[c].empty()) continue;\n        //cout << c << \",\" << C[c].top()  << endl;\n        ans += C[c].top();\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> par;\n    vector<int> sz;\n    vector<int> es;\n\n    UnionFind(int n=0){\n        if(n>0) initialize(n);\n    }\n\n    void initialize(int n){\n        par.resize(n);\n        sz.resize(n);\n        es.resize(n);\n        for(int i=0; i<n; i++){\n            par[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n    int find(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        es[x]++;\n        if(x == y) return;\n        if(sz[x] > sz[y]) swap(x, y);\n        par[x] = y;\n        sz[y] += sz[x];\n        es[y] += es[x];\n    }\n\n    int connect_size(int x, int y){\n        x = find(x);\n        y = find(y);\n        return x==y ? sz[x] : sz[x]+sz[y];\n    }\n    \n    bool can_add(int x, int y){\n        x = find(x);\n        y = find(y);\n        int v = (x==y ? sz[x] : sz[x]+sz[y]);\n        int e = (x==y ? es[x] : es[x]+es[y]) + 1;\n        return e <= v;\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint main(){\n    int N, H, W;\n    cin >> N >> H >> W;\n    vector<vector<int>> V(N);\n    for(int i=0; i<N; i++){\n        int r, c, a;\n        cin >> r >> c >> a;\n        V[i] = {a, r-1, c-1+100000};\n    }\n    sort(V.rbegin(), V.rend());\n\n    UnionFind uf(200000);\n    int64_t ans = 0;\n    for(auto& v : V){\n        int a = v[0], r = v[1], c = v[2];\n        if(uf.can_add(r, c)){\n            uf.unite(r, c);\n            ans += a;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define name \"bai5\"\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define fto(i,a,b) for(int i=a; i<=b;++i)\n#define maxn 100009\n#define ll long long\n\nusing namespace std;\nbool gone[maxn][3],ck[maxn][3];\nint cl[maxn];\nint xd[maxn][3],a[maxn][3],w,h,n;\npii b[maxn];\nbool check(int i, int x,int j){\n    if(!ck[i][x]) return false;\n    if(gone[i][x])return ck[i][x]=false;\n    gone[i][x]=true;\n    if(xd[i][x]==0){\n        xd[i][x]=j;\n        gone[i][x]=false;\n        return true;\n    }\n    /// xd[i][x]!=0;\n    /// i,x la cot hoac hang, j la chi so can dien\n    int t=xd[i][x];/// t la so can dien\n    if(check(a[t][1-x],1-x,t)){\n        xd[i][x]=j;\n        gone[i][x]=false;\n        return true;\n    }\n    gone[i][x]=false;\n    return ck[i][x]=false;\n}\nint main()\n{\n    //freopen(name\".inp\", \"r\", stdin);\n    //freopen(name\".out\", \"w\", stdout);\n    cin >> n >> h >> w;\n    fto(i,1,n){\n        cin >> a[i][0]>> a[i][1] >> b[i].fi;\n        b[i].se=i;\n        ck[i][0]=ck[i][1]=true;\n    }\n    sort(b+1,b+n+1,greater<pii> ());\n    ll res=0;\n    fto(i,1,n){\n        int j=b[i].se;\n        if(check(a[j][0],0,j)){\n            //xd[a[j][0]][0]=j;\n            res+=b[i].fi;\n        }\n        else if(check(a[j][1],1,j)){\n            //xd[a[j][1]][1]=j;\n            res+=b[i].fi;\n        }\n    }\n    cout << res ;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, int> P;\nint par[400002];\nint rk[400002];\nint sz[400002];\nint sze[400002];\nvoid init(int n){\n\tfor(int i=0; i<n; i++){\n\t\tpar[i]=i; rk[i]=0; sz[i]=1; sze[i]=0;\n\t}\n}\nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x]=find(par[x]);\n\t}\n}\n \nvoid unite(int x, int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x==y){\n      return;\n    }\n\tif(rk[x]<rk[y]){\n\t\tpar[x]=y;\n\t\tsz[y]+=sz[x];\n\t\tsze[y]+=sze[x];\n\t}else{\n\t\tpar[y]=x;\n\t\tsz[x]+=sz[y];\n\t\tsze[x]+=sze[y];\n\t\tif(rk[x]==rk[y]) rk[x]++;\n\t}\n}\nbool same(int x, int y){\n\treturn find(x)==find(y);\n}\nint main()\n{\n\tint n, h, w;\n    cin>>n>>h>>w;\n\tint r[100010], c[100010];\n\tll a[100010];\n\tvector<P> v;\n    for(int i=0; i<n; i++){\n\t\tcin>>r[i]>>c[i]>>a[i];\n\t\tr[i]--; c[i]--;\n\t\tv.push_back({a[i], i});\n\t}\n\tsort(v.begin(), v.end(), greater<P>());\n\tinit(h+w);\n\tll ans=0;\n\tfor(int i=0; i<n; i++){\n\t\tll a1=v[i].first;\n\t\tint k=v[i].second;\n\t\tunite(r[k], c[k]+h);\n\t\tif(sze[find(r[k])]<=sz[find(r[k])]-1){\n\t\t\tsze[find(r[k])]++;\n\t\t\tans+=a1;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n// #define int long long\nusing namespace std;\n\n\nconst int siz=2e5+5;\nvector<vector<pair<int,pair<int,int> > > >adj;\nint parent[siz];\nint sz[siz];\nint vis_ind[siz];\nint vis[siz];\nint mm[siz];\nint find_parent(int ver)\n{\n    if(ver==parent[ver])\n        return ver;\n    return parent[ver]=find_parent(parent[ver]);\n}\n\nbool merge(int a,int b)\n{\n    a=find_parent(a);\n    b=find_parent(b);\n    if(a!=b)\n    {\n        if(sz[a]<sz[b])\n            swap(a,b);\n        sz[a]+=sz[b];\n        parent[b]=a;\n        mm[a]=min(mm[a],mm[b]);\n        return true;\n    }\n    return false;\n}\n\nvector<pair<int,pair<int,int> > >temp;\nvoid dfs(int ver)\n{\n    vis_ind[ver]=1;\n    for(auto i:adj[ver])\n    {\n        if(!vis[i.second.second])\n        {\n            vis[i.second.second]=1;\n            temp.push_back({i.second.first,{i.first,ver}});\n            dfs(i.first);\n        }\n    }\n}\n\nsigned main()\n{\n \nios_base::sync_with_stdio(false);\ncin.tie(NULL);  \ncout.tie(0);   \n \n#ifndef ONLINE_JUDGE\n    if(fopen(\"INPUT.txt\",\"r\"))\n    {\n    freopen (\"INPUT.txt\" , \"r\" , stdin);\n    freopen (\"OUTPUT.txt\" , \"w\" , stdout);\n    }\n#endif      \n\n    int n,h,w;\n    cin>>n>>h>>w;\n    int x,y,z;\n    adj.resize(2e5+5);\n    int lim=1e5;\n    int tot=0;\n    int mn=1e18;\n    \n    for(int i=0;i<n;i++)\n    {\n        cin>>x>>y>>z;\n        tot+=z;\n        mn=min(mn,z);\n        adj[x].push_back({y+lim,{z,i}});\n        adj[y+lim].push_back({x,{z,i}});\n    }    \n\n    for(int i=1;i<=2*lim;i++)\n    {\n        mm[i]=1;\n        parent[i]=i;\n        sz[i]=1;\n    }\n    long long ans=0;\n    for(int i=1;i<=2*lim;i++)\n    {\n        if(!vis_ind[i])\n        {\n            temp.clear();\n            dfs(i);\n            sort(temp.begin(),temp.end(),greater<>());\n            int mx=0;\n            for(auto j:temp)\n            {\n                if(mm[find_parent(j.second.first)]+mm[find_parent(j.second.second)]==0)\n                    continue;\n                int z=merge(j.second.first,j.second.second);\n                if(z==0)\n                {\n                    mm[find_parent(j.second.first)]=0;\n                }\n                ans+=j.first;\n            }\n\n            ans+=mx;\n            \n        }\n    }\n\n    cout<<ans;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nclass Data{\npublic:\n\tint index;\n\tll value;\n};\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N=in(),H=in(),W=in();\n\tvector<vector<Data>> R(H),C(W);\n\tvector<int> F(N,0);\n\tREP(i,N){\n\t\tint r=in()-1,c=in()-1;\n\t\tll a=in<ll>();\n\t\tData d{i,a};\n\t\tR[r].emplace_back(d);\n\t\tC[c].emplace_back(d);\n\t}\n\t//sort(ALL(R),[](vector<Data>& lhs,vector<Data>& rhs){return lhs.size()<rhs.size();});\n\tREP(i,H){\n\t\tsort(ALL(R[i]),[](Data& lhs,Data& rhs){return lhs.value>rhs.value;});\n\t}\n\t//sort(ALL(C),[](vector<Data>& lhs,vector<Data>& rhs){return lhs.size()<rhs.size();});\n\tREP(i,W){\n\t\tsort(ALL(C[i]),[](Data& lhs,Data& rhs){return lhs.value>rhs.value;});\n\t}\n\tll sum = 0;\n\tfor(int i=0;i<H;i++){\n\t\tint l = R[i].size();\n\t\tif(l>1) continue;\n\t\tif(F[R[i][0].index]==1) continue;\n\t\tsum += R[i][0].value;\n\t\tF[R[i][0].index]=1;\n\t}\n\tfor(int i=0;i<W;i++){\n\t\tint l = C[i].size();\n\t\tif(l>1) continue;\n\t\tif(F[C[i][0].index]==1) continue;\n\t\tsum += C[i][0].value;\n\t\tF[C[i][0].index]=1;\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tint l = R[i].size();\n\t\tfor(int k=0;k<l;k++){\n\t\t\tif(F[R[i][k].index]==1) continue;\n\t\t\tsum += R[i][k].value;\n\t\t\tF[R[i][k].index]=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0;i<W;i++){\n\t\tint l = C[i].size();\n\t\tfor(int k=0;k<l;k++){\n\t\t\tif(F[C[i][k].index]==1) continue;\n\t\t\tsum += C[i][k].value;\n\t\t\tF[C[i][k].index]=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfill(ALL(F),0);\n\tll sum2 = 0;\n\tfor(int i=0;i<W;i++){\n\t\tint l = C[i].size();\n\t\tif(l>1) continue;\n\t\tif(F[C[i][0].index]==1) continue;\n\t\tsum2 += C[i][0].value;\n\t\tF[C[i][0].index]=1;\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tint l = R[i].size();\n\t\tif(l>1) continue;\n\t\tif(F[R[i][0].index]==1) continue;\n\t\tsum2 += R[i][0].value;\n\t\tF[R[i][0].index]=1;\n\t}\n\tfor(int i=0;i<W;i++){\n\t\tint l = C[i].size();\n\t\tfor(int k=0;k<l;k++){\n\t\t\tif(F[C[i][k].index]==1) continue;\n\t\t\tsum2 += C[i][k].value;\n\t\t\tF[C[i][k].index]=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tint l = R[i].size();\n\t\tfor(int k=0;k<l;k++){\n\t\t\tif(F[R[i][k].index]==1) continue;\n\t\t\tsum2 += R[i][k].value;\n\t\t\tF[R[i][k].index]=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tout(max(sum,sum2));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass UnionFind {\npublic:\n    explicit UnionFind(int N) : root(N, -1), size(N, 1), edge(N, 0) {}\n    int getRoot(int u){ return root[u] == -1 ? u : root[u] = getRoot(root[u]); }\n    int getSize(int u){ return size[getRoot(u)]; }\n    int same(int a, int b){\n        return getRoot(a) == getRoot(b);\n    }\n    bool merge(int a, int b){\n        int u = getRoot(a);\n        int v = getRoot(b);\n        if(u != v){\n            if(edge[u] + edge[v] + 1 > size[u] + size[v]) return false;\n            root[u] = v;\n            size[v] += size[u];\n            edge[v] += edge[u] + 1;\n        } else {\n            if(edge[u] + 1 > size[u]) return false;\n            edge[u]++;\n        }\n        return true;\n    }\nprivate:\n    vector<int> root;\n    vector<int> size;\n    vector<int> edge;\n};\n\nint main(){\n    int N, H, W;\n    while(cin >> N >> H >> W){\n        UnionFind uf(H+W);\n        long long res = 0;\n        vector<pair<int, pair<int, int>>> vp;\n        for(int i=0;i<N;i++){\n            int r, c, a; cin >> r >> c >> a;\n            vp.emplace_back(a, make_pair(r-1, c-1+H));\n        }\n        sort(vp.rbegin(), vp.rend());\n        for(auto& p : vp){\n            if(uf.merge(p.second.first, p.second.second)){\n                res += p.first;\n            }\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr  int MOD = 1000000007;\n//constexpr  int MOD = 998244353;\n//constexpr  long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n// int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nstruct Node {\n\tint x, y, score;\n\tNode(const int a, const int b, const int c) {\n\t\ty = a, x = b, score = c;\n\t}\n\tbool operator<(const Node&n)const {\n\t\treturn score < n.score;\n\t}\n};\n\nclass UnionFind {\n\tvector<int>parent;\n\tvector<int>rank;\npublic:\n\tvector<int>index;\n\n\tUnionFind(int num) {\n\t\tnum++;\n\t\tparent.resize(num);\n\t\trank.resize(num);\n\t\tindex.resize(num);\n\t\tfor (int i = 0; i < num; i++) {\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tindex[i] = i;\n\t\t}\n\t}\n\tint Find(int node) {\n\t\tif (parent[node] == node)return node;\n\t\telse return parent[node] = Find(parent[node]);\n\t}\n\tvoid Unite(int u, int v) {\n\t\tu = Find(u);\n\t\tv = Find(v);\n\t\tif (u == v)return;\n\t\tif (rank[u] < rank[v]) {\n\t\t\tparent[u] = v;\n\t\t\tindex[u] = index[v] = min(index[u], index[v]);\n\t\t}\n\t\telse {\n\t\t\tparent[v] = u;\n\t\t\tindex[u] = index[v] = min(index[u], index[v]);\n\t\t\tif (rank[u] == rank[v])rank[u]++;\n\t\t}\n\t}\n\tbool Check_Same(int u, int v) {\n\t\treturn Find(u) == Find(v);\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> H >> W;\n\tvector<Node>node;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> L >> R >> K;\n\t\tnode.push_back(Node(L - 1, R - 1, K));\n\t}\n\tsort(node.begin(), node.end());\n\treverse(node.begin(), node.end());\n\tUnionFind uf(H + W);\n\tvector<int>amari(H + W, 1);\n\tfor (auto i : node) {\n\t\tif (uf.Check_Same(i.y, i.x + H)) {\n\t\t\tif (amari[uf.index[uf.Find(i.y)]]) {\n\t\t\t\tM += i.score;\n\t\t\t\tamari[uf.index[uf.Find(i.y)]]--;\n\t\t\t}\n\t\t}\n\t\telse if (amari[uf.index[uf.Find(i.y)]] + amari[uf.index[uf.Find(i.x+H)]] >= 1) {\n\t\t\tM += i.score;\n\t\t\tamari[uf.index[uf.Find(i.y)]] = amari[uf.index[uf.Find(i.x+H)]] = amari[uf.index[uf.Find(i.y)]] + amari[uf.index[uf.Find(i.x+H)]] - 1;\n\t\t\tuf.Unite(i.y, i.x + H);\n\t\t}\n\t}\n\tcout << M << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define __builtin_popcount __builtin_popcountll\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const map<S, T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint timestamp = 1;\n\nbool bipartite_matching_dfs(\n        int v, const vector< vector<int> > &conn,\n        vector<int> &used, vector<int> &match)\n{\n    used[v] = timestamp;\n    for(int i = 0; i < conn[v].size(); ++i){\n        int u = conn[v][i], w = match[u];\n        if(w < 0 || (used[w] != timestamp && bipartite_matching_dfs(w, conn, used, match))){\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\nvector<int> bipartite_matching(const vector< vector<int> > &conn, int q){\n    int res = 0;\n    vector<int> match(conn.size(), -1);\n    vector<int> used(conn.size(), 0);\n    for(int v = 0; v < q; ++v){\n        if(match[v] < 0){\n            timestamp ++;\n            if(bipartite_matching_dfs(v, conn, used, match)){ ++res; }\n        }\n    }\n    return match;\n}\n\nll T, n, m, k;\n\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    while(cin >> n >> m >> k){\n        vector<tuple<int, int, int>> v;\n        vi s;\n        REP(i, n) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            v.emplace_back(z, x, y);\n            s.emplace_back(x);\n            s.emplace_back(-y);\n        }\n        sort(RALL(v));\n        sort(ALL(s));\n        UNIQUE(s);\n        map<int, int> mp;\n        REP(i, s.size()) mp[s[i]] = i;\n        vector<vi> g(n + s.size());\n        REP(i, n) {\n            int x, y, z; tie(z, x, y) = v[i];\n            g[i].emplace_back(n + mp[x]);\n            g[i].emplace_back(n + mp[-y]);\n            g[n + mp[x]].emplace_back(i);\n            g[n + mp[-y]].emplace_back(i);\n        }\n        vi match = bipartite_matching(g, n);\n        ll ans = 0;\n        REP(i, n) {\n            if (match[i] != -1 && match[match[i]] == i) {\n                ans += get<0>(v[i]);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// clang-format off\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!==============================================================================!//\n//!  dP     dP          oo                       88888888b oo                dP  !//\n//!  88     88                                   88                          88  !//\n//!  88     88 88d888b. dP .d8888b. 88d888b.    a88aaaa    dP 88d888b. .d888b88  !//\n//!  88     88 88'  '88 88 88'  '88 88'  '88     88        88 88'  '88 88'  '88  !//\n//!  Y8.   .8P 88    88 88 88.  .88 88    88     88        88 88    88 88.  .88  !//\n//!  'Y88888P' dP    dP dP '88888P' dP    dP     dP        dP dP    dP '88888P8  !//\n//!==============================================================================!//\nclass UnionFind\n{\npublic:\n    UnionFind(const std::size_t v) : V(v), parent(v), size(v, 1) { std::iota(parent.begin(), parent.end(), 0); }\n    std::size_t find(const std::size_t a) { return assert(a < V), parent[a] == a ? a : parent[a] = find(parent[a]); }\n    bool same(const std::size_t a, const std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        return find(a) == find(b);\n    }\n    void unite(std::size_t a, std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (size[a] < size[b]) { std::swap(a, b); }\n        size[a] += size[b], parent[b] = a;\n    }\n    std::size_t getSize(const std::size_t a) { return assert(a < V), size[find(a)]; }\n    friend std::ostream& operator<<(std::ostream& os, const UnionFind& uf)\n    {\n        os << \"[\";\n        for (std::size_t i = 0; i < uf.parent.size(); i++) { os << uf.parent[i] << (i + 1 == uf.parent.size() ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    const std::size_t V;\n    std::vector<std::size_t> parent, size;\n};\n// clang-format on\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    const int        N = read<int>(), H = read<int>(), W = read<int>();\n    std::vector<int> R(N), C(N), A(N);\n    for (int i = 0; i < N; i++) { std::cin >> R[i] >> C[i] >> A[i], R[i]--, C[i]--; }\n    std::vector<int> index(N);\n    std::iota(index.begin(), index.end(), 0);\n    std::sort(index.begin(), index.end(), [&](const int i, const int j) { return A[i] > A[j]; });\n    UnionFind        uf(H + W);\n    ll               ans = 0;\n    std::vector<int> edge(H + W, 0);\n    for (const int i : index) {\n        const int u = R[i], v = H + C[i];\n        if (uf.same(u, v)) {\n            const int ne = edge[uf.find(u)] + 1, nv = uf.getSize(u);\n            if (ne > nv) { continue; }\n            ans += A[i], uf.unite(u, v), edge[uf.find(u)] = ne;\n        } else {\n            const int ne = edge[uf.find(u)] + edge[uf.find(v)] + 1, nv = uf.getSize(u) + uf.getSize(v);\n            if (ne > nv) { continue; }\n            ans += A[i], uf.unite(u, v), edge[uf.find(v)] = ne;\n        }\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define VSORT(v) sort(v.begin(), v.end())\n#define VRSORT(v) sort(v.rbegin(), v.rend())\n#define ll long long\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef pair<int, P> PP;\ntypedef pair<ll, LP> LPP;\ntypedef vector<unsigned int>vec;\ntypedef vector<vec> mat;\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int INF = 1000000000;\nconst ll LINF = 1000000000000000000;//1e18\nconst ll  MOD = 1000000007;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-10;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline void add(T &a, T b){a = ((a+b) % MOD + MOD) % MOD;};\n\nstruct UnionFind {\n    vector<int> par;\n    \n    UnionFind(int n) : par(n, -1) { }\n    void init(int n) { par.assign(n, -1); }\n    \n    int root(int x) {\n        if (par[x] < 0) return x;\n        else return par[x] = root(par[x]);\n    }\n    \n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n    \n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (par[x] > par[y]) swap(x, y); // merge technique\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    \n    int size(int x) {\n        return -par[root(x)];\n    }\n};\n\nstruct edge{\n    ll from, to, cost;\n    edge(ll s, ll d, ll w) : from(s), to(d), cost(w){}\n    \n    bool operator < (const edge& x) const {\n        return cost < x.cost;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, H, W;\n    cin >> N >> H >> W;\n    vector<edge> e;\n\n    UnionFind uf(H + W + 10);\n\n    REP(i,N){\n        ll R, C, A;\n        cin >> R >> C >> A;\n        e.emplace_back(R, C+H, -A);\n    }\n\n    sort(e.begin(), e.end());\n    \n    ll ans = 0;\n\n    REP(i,N){\n        if(!uf.issame(e[i].from, e[i].to)){\n            ans += e[i].cost;\n            uf.unite(e[i].from, e[i].to);\n        }\n        else{\n            if(!uf.issame(e[i].from, 0)){\n                ans += e[i].cost;\n                uf.unite(e[i].from,0);\n            }\n        }\n    }\n    cout << ans * (-1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<list>\n#include<bitset>\n#include<stack>\n#include<memory>\nusing namespace std;\nusing namespace std::chrono;\ntypedef long long int llint;\ntypedef double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*cout<<fixed<<setprecision(20);cin.tie(0);ios::sync_with_stdio(false);*/\nconst llint mod=1000000007;\nconst llint big=2.19e18+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>bool mineq(T& a,U b){if(a>b){a=b;return true;}return false;}\ntemplate <class T,class U>bool maxeq(T& a,U b){if(a<b){a=b;return true;}return false;}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\nllint lcm(llint a,llint b){if(a==0){return b;}return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\n\nclass UF{\npublic:\n\tvector<int>go;\n\tUF(int in){go.res(in);for(int i=0;i<in;i++){go[i]=i;}}\n\tint find_uf(int a){\n\t\tif(go[a]==a){return a;}\n\t\treturn go[a]=find_uf(go[a]);\n\t}\n\tvoid uni_uf(int a,int b){go[find_uf(a)]=find_uf(b);}\n};\nint main(void){\n\t//I like this problem\n\tint n,H,W,i,j;cin>>n>>H>>W;\n\tllint ans=0;\n\tUF aa(H+W+1);\n\tvector<tuple<int,int,int>>card(n);\n\tfor(i=0;i<n;i++){\n\t\tint r,c,a;cin>>r>>c>>a;\n\t\tc+=H;\n\t\tcard[i]=mt(a,r,c);\n\t}\n\tSO(card);REV(card);\n\tfor(auto it:card){\n\t\tint a,r,c;tie(a,r,c)=it;\n\t\tint rf=aa.find_uf(r),cf=aa.find_uf(c),zf=aa.find_uf(0);\n\t\tif(rf==zf&&cf==zf){continue;}\n\t\tans+=a;\n\t\tif(rf!=cf){aa.uni_uf(r,c);}\n\t\telse{aa.uni_uf(r,0);}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid out(T x) { cout << x << endl; exit(0); }\n#define watch(x) cout << (#x) << \" is \" << (x) << endl\n\n\n\n\n\nusing ll = long long;\n\n\nconst int maxn = 1e6 + 5;\n\n\n\n\nint cap[maxn];\nint siz[maxn];\nint par[maxn];\n\n\nint parent(int x) {\n    if (x==par[x]) return x;\n    return par[x]=parent(par[x]);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);  cout.tie(0);\n    int n, h, w;\n    cin>>n>>h>>w;\n\n    for (int i=0; i<h+w; i++) {\n\tcap[i] = 1;\n\tsiz[i] = 1;\n\tpar[i] = i;\n    }\n\n\n    // Every row and column starts off with capacity=1\n    // As long as the cc of rows and cols collectively have enough capacity to handle the number of nodes\n    // we picked, there always exists an assignment of rows/cols -> nodes.\n    \n    \n    vector<pair<ll,pair<int,int>>> cards;\n    for (int i=0; i<n; i++) {\n\tint r,c,a;\n\tcin>>r>>c>>a;\n\t--r; --c;\n\tcards.push_back({a,{r,c}});\n    }\n\n    sort(cards.begin(), cards.end());\n\n\n    ll res = 0;\n\n    while (!cards.empty()) {\n\tauto card = cards.back();\n\tll val = card.first;\n\tint r = card.second.first;\n\tint c = card.second.second + h;\n\tcards.pop_back();\n\n\tr = parent(r);\n\tc = parent(c);\n\n\tif (r==c) {\n\t    if (cap[r] >= 1) {\n\t\tres += val;\n\t\tcap[r]--;\n\t    }\n\t} else {\n\t    if (cap[r]+cap[c] >= 1) {\n\t\tres += val;\n\t\tif (siz[r] < siz[c]) {\n\t\t    swap(r, c);\n\t\t}\n\t\tsiz[r] += siz[c];\n\t\tpar[c] = r;\n\t\tcap[r] += cap[c];\n\t\tcap[r]--;\n\t    }\n\t}\n    }\n\n    cout<<res<<endl; \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nclass UnionFind{\n    public:\n    //親の番号を格納する。親だった場合は-(その集合のサイズ)\n    vector<int> parent;\n    vector<int> cnt;\n\n    UnionFind(int N){\n        parent = vector<int>(N,-1);\n        cnt = vector<int>(N,0);\n    }\n\n    int root(int A){\n        if(parent[A] < 0) return A;\n        return parent[A]=root(parent[A]);\n    }\n\n    int size(int A){\n        return -parent[root(A)];\n    }\n    int vcount(int A){\n        return cnt[root(A)];\n    }\n\n    bool unite(int A, int B) {\n        A = root(A), B = root(B);\n        if(A == B) return false; \n\n        if(size(A) < size(B)) swap(A,B);\n        parent[A] += parent[B];\n        parent[B] = A;\n        cnt[A] += cnt[B];\n        return true;\n    }\n    void add(int A){\n        A = root(A);\n        cnt[A]++;\n    }\n\n    bool same(int A, int B){\n        return root(A)==root(B);\n    } \n};\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n\n    ll n,h,w;\n    cin>>n>>h>>w;\n    array<ll,3> a[n];\n    for(int i=0;i<n;i++){\n        ll r,c,s;\n        cin>>r>>c>>s;\n        r--,c--;\n        a[i] = {s,w+r,c};\n    }\n    sort(a,a+n,greater<array<ll,3>>());\n    ll ans = 0;\n    UnionFind uni(h+w);\n    for(int i=0;i<n;i++){\n        if(!uni.same(a[i][1],a[i][2])){\n            int cnt = uni.vcount(a[i][1]) + uni.vcount(a[i][2]);\n            int siz = uni.size(a[i][1]) + uni.size(a[i][2]);\n            if(cnt+1 > siz) continue;\n            uni.unite(a[i][1],a[i][2]);\n            uni.add(a[i][1]);\n            ans += a[i][0];\n            continue;\n        }\n        int cnt = uni.vcount(a[i][1]);\n        int siz = uni.size(a[i][1]);\n        if(cnt < siz){\n            ans += a[i][0];\n            uni.add(a[i][1]);\n        }\n    }\n    cout << ans << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5+7;\n\nint p[MAXN];\nbool done[MAXN];\n\nint parent(int u) {\n    if (u==p[u]) return u;\n    return p[u] = parent(p[u]);\n}\n\nbool unite(int u, int v) {\n    u = parent(u);\n    v = parent(v);\n\n    if (u==v) {\n        if (done[u]) return false;\n        done[u] = true;\n        return true;\n    }\n\n    if (done[u] && done[v]) return false;\n\n    p[v] = u;\n    done[u] |= done[v];\n\n    return true;\n}\n\ntypedef tuple< int , int , int >triple;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, h, w;\n    cin >> n >> h >> w;\n\n    for (int i = 1; i <= h+w; i++) p[i] = i;\n\n    vector< triple >edges(n);\n    for (int i = 0; i < n; i++) {\n        cin >> get<1>(edges[i]) >> get<2>(edges[i]) >> get<0>(edges[i]);\n    }\n\n    sort(edges.rbegin(), edges.rend());\n\n    long long ans = 0;\n    for (triple t : edges) {\n        int u = get<1>(t);\n        int v = h+get<2>(t);\n        if (unite(u, v)) {\n            ans += get<0>(t);\n//            cout << \"taken \" << get<0>(t) << endl;\n        }\n    }\n\n    cout << ans << \"\\n\";\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\n#include<vector>\n#include<numeric>\n\nnamespace ProconLib{\n    class UnionFind{\n        int N;\n        std::vector<int> par;\n        std::vector<int> rank;\n        public:\n        UnionFind(int N):N(N),par(N),rank(N,0){std::iota(par.begin(),par.end(),0);}\n        int find(int x);\n        void unite(int x,int y);\n        bool same(int x,int y){return find(x)==find(y);}\n    };\n\n    int UnionFind::find(int x){\n        if(par[x]==x) return x;\n        return par[x]=find(par[x]);\n    }\n    void UnionFind::unite(int x,int y){\n        x=find(x),y=find(y);\n        if(x==y) return;\n        if(rank[x]>=rank[y]){\n            if(rank[x]==rank[y]) rank[x]++;\n            par[y]=x;\n        }else{\n            par[x]=y;\n        }\n    }\n}using namespace std;\nusing namespace ProconLib;\nusing ll=long long;\n\nstruct Card{\n    int r,c;\n    ll a;\n    int id;\n};\n\nstruct Edge{\n    int to;\n    ll w;\n};\nusing Graph=vector<vector<Edge>>;\nGraph g;\nvector<int> used;\nvoid dfs(int v){\n    if(used[v]) return;\n    used[v]=true;\n    for(auto to:g[v]){\n        if(!used[to.to]) dfs(to.to);\n    }\n}\nint main(){\n    int n,h,w;\n    cin>>n>>h>>w;\n    vector<Card> cards(n);\n    for(int i=0;i<n;i++){\n        cin>>cards[i].r>>cards[i].c>>cards[i].a;\n        cards[i].r--;\n        cards[i].c--;\n        cards[i].id=i;\n    }\n    sort(cards.begin(),cards.end(),[](Card lhs,Card rhs){return lhs.a>rhs.a;});\n    vector<int> flag(n);\n\n    g.resize(h+w);\n    used.resize(h+w);\n    UnionFind u(h+w);\n    \n    ll res=0;\n    for(auto &card:cards){\n        int x=card.r;\n        int y=card.c+h;\n        if(u.same(x,y)){\n            if(used[x]+used[y]==0){\n                res+=card.a;\n                g[x].push_back(Edge{y,card.a});\n                g[y].push_back(Edge{x,card.a});\n                dfs(x);\n            }\n            else if(used[x] || used[y]){\n\n            }\n            else{\n                assert(used[x]==used[y]);\n                continue;\n            }\n        }\n        if(used[x] && used[y]){\n            continue;\n        }\n        else if(used[x]||used[y]){\n            g[x].push_back(Edge{y,card.a});\n            g[y].push_back(Edge{x,card.a});\n            used[x]=used[y]=true;\n            dfs(x);\n            dfs(y);\n            u.unite(x,y);\n            res+=card.a;\n        }\n        else{\n            u.unite(x,y);\n            g[x].push_back(Edge{y,card.a});\n            g[y].push_back(Edge{x,card.a});\n            res+=card.a;\n        }\n    }\n    cout<<res<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <unistd.h>\n\nusing namespace std;\n\n#define DEBUG(x) cerr<<#x<<\": \"<<x<<endl;\n#define DEBUG_VEC(v) cerr<<#v<<\":\";for(int i=0;i<v.size();i++) cerr<<\" \"<<v[i]; cerr<<endl\n#define DEBUG_MAT(v) cerr<<#v<<endl;for(int i=0;i<v.size();i++){for(int j=0;j<v[i].size();j++) {cerr<<v[i][j]<<\" \";}cerr<<endl;}\n\n\ntypedef long long ll;\n\n#define vi vector<int>\n#define vl vector<ll>\n#define vii vector< vector<int> >\n#define vll vector< vector<ll> >\n#define vs vector<string>\n#define pii pair<int,int>\n#define pis pair<int,string>\n#define psi pair<string,int>\n#define pll pair<ll,ll>\ntemplate<class S, class T> pair<S, T> operator+(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first + t.first, s.second + t.second); }\ntemplate<class S, class T> pair<S, T> operator-(const pair<S, T> &s, const pair<S, T> &t) { return pair<S, T>(s.first - t.first, s.second - t.second); }\ntemplate<class S, class T> ostream& operator<<(ostream& os, pair<S, T> p) { os << \"(\" << p.first << \", \" << p.second << \")\"; return os; }\n#define X first\n#define Y second\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define rep1(i,n) for(int i=1;i<=(n);i++)\n#define rrep(i,n) for(int i=(n)-1;i>=0;i--)\n#define rrep1(i,n) for(int i=(n);i>0;i--)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define in(x, a, b) (a <= x && x < b)\n#define all(c) c.begin(),c.end()\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a = b; return 1; } return 0; }\n#define UNIQUE(v) v.erase(std::unique(v.begin(), v.end()), v.end());\nconst ll inf = 1000000001;\nconst ll INF = (ll)1e18 + 1;\nconst ll MOD = 1000000007;\n//const ll MOD = 998244353;\nconst double pi = 3.14159265358979323846;\n#define Sp(p) cout<<setprecision(15)<< fixed<<p<<endl;\nint dx[4] = { -1,0, 1,0 }, dy[4] = { 0,1,0,-1 };\nint dx2[8] = { 1,1,0,-1,-1,-1,0,1 }, dy2[8] = { 0,1,1,1,0,-1,-1,-1 };\n#define fio() cin.tie(0); ios::sync_with_stdio(false);\n// #define mp make_pair\n//#define endl '\\n'\n\n\nclass UnionFind {\npublic:\n  int n;\n  vi par; //親\n  vi ran; //木の深さ\n  vi num; //要素数\n  vector<bool> out;\n  int g; // group数\n \n  UnionFind(int _n) {\n    n = _n;\n    g = n;\n    par.resize(n); ran.resize(n); num.resize(n);\n    out.resize(n);\n    for (int i = 0; i < n; i++) {\n      par[i] = i; ran[i] = 0; num[i] = 1;\n      out[i] = false;\n    }\n  }\n \n  //木の根を求める\n  int find(int x) {\n    if (par[x] == x) {\n      return x;\n    }\n    else {\n      return par[x] = find(par[x]);\n    }\n  }\n \n  //xとyの属する集合を併合\n  void unite(int x, int y) {\n    x = find(x); y = find(y);\n    assert(x != y);\n    assert(not (out[x] and out[y]));\n    int numsum = num[x] + num[y];\n    int outsum = out[x] | out[y];\n    if (x == y) {\n      return;\n    }\n    if (ran[x]<ran[y]) {\n      par[x] = y;\n    }\n    else {\n      par[y] = x;\n      if (ran[x] == ran[y]) {\n        ran[x]++;\n      }\n    }\n    num[x] = num[y] = numsum;\n    out[x] = out[y] = outsum;\n    g--;\n  }\n \n  //xとyが同じ集合に属するか否か\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n \n};\n\n\nvector< pair<ll, pll> > edges;\nvi used;\n\nll kruskal(int n) {\n\tUnionFind uf(n);\n\tll res = 0;\n\tfor (int i = 0; i < edges.size(); i++) {\n      int u = edges[i].second.first, v = edges[i].second.second;\n      if (!uf.same(edges[i].second.first, edges[i].second.second)) {\n        if (not uf.out[uf.find(u)] or not uf.out[uf.find(v)]) {\n          uf.unite(edges[i].second.first, edges[i].second.second);\n          used[i] = true;\n          res += edges[i].first;\n        }\n      }\n      else if (not uf.out[uf.find(u)]) {\n        res += edges[i].first;\n        uf.out[uf.find(u)] = true;\n      }\n\t}\n\treturn res;\n}\n\n\n\nint main() {\n  int n, h, w;\n  cin >> n >> h >> w;\n  edges.resize(n);\n  used.resize(n);\n  rep (i, n) {\n    int u, v, a;\n    cin >> u >> v >> a;\n    u--; v--;\n    edges.push_back(make_pair(a, pii(u, v + h)));\n  }\n  \n  sort(all(edges));\n  reverse(all(edges));\n  \n  ll ans =  kruskal(h + w);\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define SIZE 200005\n \nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n \nstruct UF\n{\n\tint par[SIZE],rank[SIZE];\n\tint sz[SIZE];\n\t\n\tvoid init(int n)\n\t{\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tpar[i]=i;\n\t\t\trank[i]=1;\n\t\t\tsz[i]=-1;\n\t\t}\n\t}\n\tint find(int x)\n\t{\n\t\tif(x==par[x]) return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\tint get(int v)\n\t{\n\t\treturn sz[find(v)];\n\t}\n\tvoid unite(int x,int y)\n\t{\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y)\n\t\t{\n\t\t\tsz[x]++;\n\t\t\treturn;\n\t\t}\n\t\tif(rank[x]<rank[y])\n\t\t{\n\t\t\tpar[x]=y;\n\t\t\tsz[y]+=sz[x];\n\t\t\tsz[y]++;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpar[y]=x;\n\t\t\tsz[x]+=sz[y];\n\t\t\tsz[x]++;\n\t\t\tif(rank[x]==rank[y]) rank[x]++;\n\t\t}\n\t}\n\tbool same(int x,int y)\n\t{\n\t\treturn find(x)==find(y);\n\t}\n}uf;\nvector <PP> edge;\nbool use[SIZE];\n \nint main()\n{\n\tint n,h,w;\n\tscanf(\"%d %d %d\",&n,&h,&w);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint r,c,a;\n\t\tscanf(\"%d %d %d\",&r,&c,&a);r--,c--;\n\t\tedge.push_back(PP(a,P(r,c+h)));\n\t}\n\tsort(edge.begin(),edge.end(),greater<PP>());\n\tuf.init(h+w+2);\n\tll ret=0;\n\tfor(int i=0;i<edge.size();i++)\n\t{\n\t\tP p=edge[i].second;\n\t\tint a=uf.get(p.first),b=uf.get(p.second);\n\t\tif(a+b+1<=0)\n\t\t{\n\t\t\tuf.unite(p.first,p.second);\n\t\t\tret+=edge[i].first;\n\t\t\tuse[i]=true;\n\t\t\t//printf(\"* %d %d : %d\\n\",p.first,p.second,edge[i].first);\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define PB push_back\n#define fi first\n#define se second\n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\nusing namespace std;\nconst int N=200005;\nint n,H,W,fa[N],fl[N];\nll ans;\nstruct node{\n\tint x,y,v;\n}e[N];\nbool cmp(node a,node b){\n\treturn a.v>b.v;\n}\nint get(int x){\n\treturn x==fa[x]?x:fa[x]=get(fa[x]);\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&H,&W);\n\tFor(i,1,n) scanf(\"%d%d%d\",&e[i].x,&e[i].y,&e[i].v);\n\tFor(i,1,H+W) fa[i]=i,fl[i]=0;\n\tsort(e+1,e+n+1,cmp);\n\tFor(i,1,n){\n\t\tint x=get(e[i].x);\n\t\tint y=get(e[i].y+H);\n\t\tif (x!=y&&(!fl[x]||!fl[y])){\n\t\t\tans+=e[i].v;\n\t\t\tfa[x]=y; fl[y]|=fl[x];\n\t\t}\n\t\telse if (x==y&&!fl[x]){\n\t\t\tans+=e[i].v;\n\t\t\tfl[x]=1;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint push_comp(int v, vector<int> & comp_up) {\n\tint C = v;\n\twhile(comp_up[C] != C) C = comp_up[C];\n\twhile(comp_up[v] != C) {\n\t\tint up = comp_up[v];\n\t\tcomp_up[v] = C;\n\t\tv = up;\n\t}\n\treturn C;\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, H, W;\n\tcin >> N >> H >> W;\n\tvector< pair<int, pair<int, int> > > V(N);\n\tfor(int i = 0; i < N; i++) cin >> V[i].ss.ff >> V[i].ss.ss >> V[i].ff;\n\tsort(begin(V), end(V));\n\tvector<int> comp_up(H+W), comp_sz(H+W, 1);\n\tfor(int i = 0; i < H+W; i++) comp_up[i] = i;\n\tvector<char> comp_done(H+W, 0);\n\tcat ans = 0;\n\tfor(int i = N-1; i >= 0; i--) {\n\t\tint u = V[i].ss.ff, v = V[i].ss.ss + H;\n\t\tu = push_comp(u, comp_up);\n\t\tv = push_comp(v, comp_up);\n\t\tif(comp_done[u] && comp_done[v]) continue;\n\t\tans += V[i].ff;\n\t\tif(u == v) comp_done[u] = 1;\n\t\telse {\n\t\t\tif(comp_sz[u] > comp_sz[v]) swap(u, v);\n\t\t\tcomp_up[u] = v;\n\t\t\tcomp_sz[v] += comp_sz[u];\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fto(i,j,h)   for (int i=j; i<=h; i++)\n#define fdto(i,j,h)  for (int i=j; i>=h; i--)\n#define ANH BAI5\n#define maxn 100009\n#define fi first\n#define se second\n#define ll long long\nusing namespace std;\n\nint n, h, w, df[maxn], L[1048580], df2[maxn];\nstruct data{\n    int r, c, v;\n} a[maxn];\npair<int, int> Max[maxn];\nbool cmp(data e, data f){\n    return e.v > f.v;\n}\nvoid sub1(){\n\n}\nint main()\n{\n    //freopen(\"ANH.inp\", \"r\", stdin);\n    //freopen(\"ANH.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    cin >> n >> h >> w;\n    fto(i,1,n)  cin >> a[i].r >> a[i].c >> a[i].v;\n    sort(a+1, a+n+1, cmp);\n    ll res = 0, s = 0;\n    fto(i,1,n){\n        if (df[a[i].r] == 0){\n            df[a[i].r] = 1;    s += a[i].v;\n            df2[i] = 1;\n        }\n    }\n    fto(i,1,h)   df[i] = 0;\n    fto(i,1,n){\n        if (df2[i] == 0 && df[a[i].c] == 0){\n            df[a[i].c] = 1;    s += a[i].v;\n        }\n    }\n    res = max(res, s);\n    s = 0;\n    fto(i,1,max(n, max(h, w)))    {df[i] = 0;  df2[i] = 0;}\n    fto(i,1,n){\n        if (df[a[i].c] == 0){\n            df[a[i].c] = 1;    s += a[i].v;\n            df2[i] = 1;\n        }\n    }\n    fto(i,1,h)   df[i] = 0;\n    fto(i,1,n){\n        if (df2[i] == 0 && df[a[i].r] == 0){\n            df[a[i].r] = 1;    s += a[i].v;\n        }\n    }\n    res = max(res, s);\n    cout << res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T> using greater_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\ntemplate<typename T>\nstruct edge {\n  int from, to;\n  T cost;\n\n  edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n\n  edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n\n  operator int() const { return to; }\n\n  bool operator<(const edge<T> &e) const {\n    return cost < e.cost;\n  }\n};\n\ntemplate<typename T> using Edges = vector<edge<T>>;\ntemplate<typename T> using WeightedGraph = vector<vector<edge<T>>>;\n\nvoid solve() {\n  int n, h, w; cin >> n >> h >> w;\n  vector<multiset<edge<int>>> g(h+w);\n  rep(_,n) {\n    int r, c, a; cin >> r >> c >> a;\n    --r, c += h-1;\n    g[r].emplace(r, c, a);\n    g[c].emplace(r, c, a);\n  }\n\n  vi seen(h+w, -1);\n  ll ans = 0;\n\n  rep(i,h+w) {\n    if (seen[i] == -1) {\n      seen[i] = i;\n      priority_queue<edge<int>> pq;\n      for (auto &e : g[i]) pq.emplace(e);\n      while (!pq.empty()) {\n        auto card = pq.top(); pq.pop();\n        ans += card.cost;\n        g[card.from].erase(g[card.from].find(card));\n        g[card.to].erase(g[card.to].find(card));\n        if (seen[card.from] == -1) {\n          seen[card.from] = i;\n          for (auto &e : g[card.from]) {\n            if (seen[e.to] != i) pq.emplace(e);\n          }\n        } else if (seen[card.to] == -1) {\n          seen[card.to] = i;\n          for (auto &e : g[card.to]) {\n            if (seen[e.from] != i) pq.emplace(e);\n          }\n        } else break;\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int,int,int> T;\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define rep(i, n) for (ll i = 0; i < n; i++)\n#define rrep(i, n) for (ll i = n - 1; i >= 0; i--)\n#define Rep(i, r, n) for (ll i = r; i < n; i++)\n#define RRep(i, r, n) for (ll i = n - 1; i <= r; i--)\n#define debug(x) cout << #x << ' ' << '=' << ' ' << (x) << endl;\n#define fs first\n#define sc second\n#define int long long\n#define pb push_back\n#define mp make_pair\nconst int dx[] = {0, -1, 0, 1};\nconst int dy[] = {1, 0, -1, 0};\nconst int MOD = (1000000007);\n//const int MOD = (998244353);\n//const int INF = (1 << 30)-1;\nconst int INF = (1LL << 60)-1;\nconst double EPS = (1 >> 30);\n\ntemplate<class T> inline bool chmin(T& a, T b) {if (a > b) {a = b; return 1;} return 0;}\ntemplate<class T> inline bool chmax(T& a, T b) {if (a < b) {a = b; return 1;} return 0;}\n\nusing Graph = vector<vector<pair<int, int>>>;\nusing Ki = vector<vector<int>>;\nusing vec = vector<int>;\n\nstruct UnionFind {\n    public:\n    vector<int> child, tree, sum, ed;\n\n    public:\n    UnionFind(int v) {\n        tree.resize(v);\n        sum.resize(v);\n        ed.resize(v,0);\n        rep(i, v) tree[i] = i, sum[i] = 1;\n    }\n\n    int root(int i) {\n        if(i == tree[i]) {\n            rep(j, child.size()) tree[child[j]] = i;\n            child.clear(); \n            return i;\n        }\n        else {\n            child.push_back(i);\n            return i = root(tree[i]);\n        }\n    }\n\n    int size(int i) {\n        return sum[root(i)];\n    }\n\n    int edsize(int i) {\n        return ed[root(i)];\n    }\n\n    int unit(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if(isUnit(x,y)){\n            ed[min(x,y)] ++;\n        }\n        else{\n            sum[min(x,y)] += sum[max(x,y)];\n            ed[min(x,y)] += 1 + ed[max(x,y)];\n            tree[max(x,y)] = min(x,y);\n        }\n    }\n\n    bool isUnit(int x, int y) {\n        return root(x) == root(y);\n    }\n};\n\nint Nmax=100100;\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(10);\n    //---------------------------------------------\n    \n    int n,h,w;\n    cin>>n>>h>>w;\n    vector<T> x(n);\n    rep(i,n){\n        int r,c,a;\n        cin>>r>>c>>a; // a is score\n        x[i]=T(a,r,c);\n    }\n    sort(rall(x));\n    UnionFind uf1(h+w+Nmax);\n    UnionFind uf2(h+w+Nmax);\n    ll ans=0;\n    rep(i,n){\n        int a,r,c; // a is score\n        tie(a,r,c)=x[i];\n        if(uf1.isUnit(r,c+Nmax)&&uf2.isUnit(r,c+Nmax)){\n            // 取れない\n        }\n        else if(uf1.isUnit(r,c+Nmax)){\n            // 辺がある\n            if(uf1.edsize(r)<uf1.size(r)){\n                uf1.unit(r,c+Nmax);\n                uf2.unit(r,c+Nmax);\n                ans+=a;\n            }\n        }\n        else{\n            // 辺がない\n            if(uf1.edsize(r)+uf1.edsize(c+Nmax)<uf1.size(r)+uf1.size(c+Nmax)){\n                uf1.unit(r,c+Nmax);\n                ans+=a;\n            }\n        }\n    }\n    cout<<ans<<endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 400000\n#define M 200000\n\n\nint p[N];\nint d[N];\nbool vv[N];\n\nvoid init(void) {\n\tf(i, N) {\n\t\tp[i] = i;\n\t\td[i] = 1;\n\t\tvv[i] = false;\n\t}\n\treturn;\n}\n\nint pa(int x) {\n\tif (p[x] == x)return x;\n\telse return p[x] = pa(p[x]);\n}\n\n\nvoid uni(int x, int y) {\n\tint px = pa(x);\n\tint py = pa(y);\n\tif (px == py)return;\n\tif (d[px] < d[py]) {\n\t\tp[px] = py;\n\t\td[py] = max(d[py], d[px] + 1);\n\t}\n\telse {\n\t\tp[py] = px;\n\t\td[px] = max(d[px], d[py] + 1);\n\t}\n\treturn;\n}\n\nbool jud(int x, int y) {\n\tint px = pa(x);\n\tint py = pa(y);\n\tif (px == py)return true;\n\telse return false;\n}\n\n\n\n\n\nint main() {\n\tinit();\n\tlong long a[N];\n\tint xx[N];\n\tint yy[N];\n\tint vx[N];\n\tint vy[N];\n\tvector<pair<long long, int> >b;\n\tint n, k;\n\tint x, y, z, px, py;\n\tlong long s, ans;\n\tbool v = true;\n\tans = 0;\n\tscanf(\"%d %d %d\", &n,&px,&py);\n\tf(i, N) {\n\t\tvx[i] = -1;\n\t\tvy[i] = -1;\n\t}\n\tf(i, n) {\n\t\tscanf(\"%d %d %lld\", &xx[i], &yy[i], &a[i]);\n\t\tb.push_back(make_pair(a[i], i));\n\t}\n\tsort(b.begin(), b.end(), greater<pair<long long, int> >());\n\tf(i, n) {\n\t\tz = b[i].second;\n\t\tx = xx[z];\n\t\ty = yy[z];\n\t\tpx = pa(x);\n\t\tpy = pa(y+M);\n\t\tif (vv[px]) {\n\t\t\tvx[x] = -10;\n\t\t}\n\t\tif (vv[py]) {\n\t\t\tvy[y] = -10;\n\t\t}\n\t\tif ((vx[x] == -10) && (vy[y] == -10)) {\n\t\t\tcontinue;\n\t\t}\n\t\telse if (vx[x] == -10) {\n\t\t\tans += a[z];\n\t\t\tvy[y] = -10;\n\t\t}\n\t\telse if (vy[y] == -10) {\n\t\t\tans += a[z];\n\t\t\tvx[x] = -10;\n\t\t}\n\t\telse{\n\t\t\tans += a[z];\n\t\t\tif (px == py) vv[px] = true;\n\t\t\telse uni(px, py);\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst int maxn = 2e5 + 10;\n\nvector<int> g[maxn];\nint mt[maxn];\nint used[maxn];\nint cn = 1;\n\nbool dfs(int v) {\n\tif (used[v] == cn) return false;\n\n\tused[v] = cn;\n\n\tfor (int u : g[v]) {\n\t\tif (mt[u] == -1 || dfs(mt[u])) {\n\t\t\tmt[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\tfastInp;\n\n\tll n, h, w;\n\tcin >> n >> h >> w;\n\n\tll vals = 0, ans = 0;\n\tvector<tuple<ll, ll, ll>> vec;\n\tfor (int i = 0; i < h + w + 3; i++) mt[i] = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tll r, c, a;\n\t\tcin >> r >> c >> a;\n\t\tr--; c--;\n\t\tvec.push_back({ a, r, c });\n\t}\n\n\tsort(vec.rbegin(), vec.rend());\n\n\tll cnt = 0;\n\tll hw = h + w;\n\tfor (int i = 0; i < n; i++) {\n\t\tll r = get<1>(vec[i]), c = get<2>(vec[i]), a = get<0>(vec[i]);\n\t\tif (mt[r] == -1 || mt[c + h + 1] == -1) {\n\t\t\tvals++;\n\t\t\tcnt++;\n\t\t\tg[i].push_back(r);\n\t\t\tg[i].push_back(c + h + 1);\n\t\t\tif (mt[r] == -1) {\n\t\t\t\tmt[r] = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmt[c + h + 1] = i;\n\t\t\t}\n\t\t\tans += a;\n\t\t\tcontinue;\n\t\t}\n\t\tcn++;\n\t\tvals++;\n\t\t\n\t\tg[i].push_back(r);\n\t\tg[i].push_back(c + h + 1);\n\t\tcnt += dfs(i);\n\n\t\tif (cnt >= vals) {\n\t\t\tans += a;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tvals--;\n\t\t\tg[i].pop_back();\n\t\t\tg[i].pop_back();\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge{\n\tint u,v,w;\n};\n\nlong long ans=0;\nint par[200005],ed[200005]={},sz[200005];\n\nint root(int u){\n\tif(par[u]!=u){\n\t\treturn par[u]=root(par[u]);\n\t}\n\treturn u;\n}\n\nvoid merge(int u, int v, int w){\n\tint ru=root(u),rv=root(v);\n\tif(ru==rv){\n\t\tif(sz[ru]>ed[ru]){\n\t\t\ted[ru]++;\n\t\t\tans+=w;\n\t\t}\n\t}\n\telse{\n\t\tif(sz[ru]+sz[rv]>ed[ru]+ed[rv]){\n\t\t\tif(rand()&1){\n\t\t\t\tswap(ru,rv);\n\t\t\t}\n\t\t\tpar[rv]=ru;\n\t\t\tsz[ru]+=sz[rv];\n\t\t\ted[ru]+=ed[rv]+1;\n\t\t\tans+=w;\n\t\t}\n\t}\n}\n\nint main(){\n\tint p,h,w; cin >> p >> h >> w;\n\tfor(int i=0;i<h+w;i++){\n\t\tpar[i]=i;\n\t\tsz[i]=1;\n\t}\n\tvector <edge> e(p);\n\tfor(int i=0;i<p;i++){\n\t\tcin >> e[i].u >> e[i].v >> e[i].w;\n\t\te[i].u--;e[i].v--;\n\t}\n\tsort(e.begin(),e.end(),[](edge &a, edge &b){\n\t\treturn a.w>b.w;\n\t});\n\tfor(int i=0;i<p;i++){\n\t\tmerge(e[i].u,h+e[i].v,e[i].w);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 500000\n#define M 1000000\n\n\nint p[N];\nint d[N];\nbool vv[N];\n\nvoid init(void) {\n\tf(i, N) {\n\t\tp[i] = i;\n\t\td[i] = 1;\n\t\tvv[i] = false;\n\t}\n\treturn;\n}\n\nint pa(int x) {\n\tif (p[x] == x)return x;\n\telse return p[x] = pa(p[x]);\n}\n\n\nvoid uni(int x, int y) {\n\tint px = pa(x);\n\tint py = pa(y);\n\tif (px == py)return;\n\tif (d[px] < d[py]) {\n\t\tp[px] = py;\n\t\td[py] = max(d[py], d[px] + 1);\n\t}\n\telse {\n\t\tp[py] = px;\n\t\td[px] = max(d[px], d[py] + 1);\n\t}\n\treturn;\n}\n\nbool jud(int x, int y) {\n\tint px = pa(x);\n\tint py = pa(y);\n\tif (px == py)return true;\n\telse return false;\n}\n\n\n\n\n\nint main() {\n\tlong long a[N];\n\tint xx[N];\n\tint yy[N];\n\tint vx[N];\n\tint vy[N];\n\tvector<pair<long long, int> >b;\n\tint n, k;\n\tint x, y, z, px, py;\n\tlong long s, ans;\n\tbool v = true;\n\tans = 0;\n\tscanf(\"%d\", &n);\n\tf(i, N) {\n\t\tvx[i] = -1;\n\t\tvy[i] = -1;\n\t}\n\tf(i, n) {\n\t\tscanf(\"%d %d %lld\", &xx[i], &yy[i], &a[i]);\n\t\tb.push_back(make_pair(a[i], i));\n\t}\n\tsort(b.begin(), b.end(), greater<pair<long long, int> >());\n\tf(i, n) {\n\t\tz = b[i].second;\n\t\tx = xx[z];\n\t\ty = yy[z];\n\t\tpx = pa(x);\n\t\tpy = pa(y+M);\n\t\tif (vv[px]) {\n\t\t\tvx[x] = -10;\n\t\t}\n\t\tif (vv[py]) {\n\t\t\tvy[y] = -10;\n\t\t}\n\t\tif ((vx[x] == -10) && (vy[y] == -10)) {\n\t\t\tcontinue;\n\t\t}\n\t\telse if (vx[x] == -10) {\n\t\t\tans += a[z];\n\t\t\tvy[y] = -10;\n\t\t}\n\t\telse if (vy[y] == -10) {\n\t\t\tans += a[z];\n\t\t\tvx[x] = -10;\n\t\t}\n\t\telse{\n\t\t\tans += a[z];\n\t\t\tif (px == py) vv[px] = true;\n\t\t\telse uni(px, py);\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,h,w;\nint a[100005],xx[100005],yy[100005];\nset<pair<int,pair<int,int> > >S;\nvector<int>g[2][100005];\nstruct ssss{\n\tint par[200005];\n\tssss(){for(int i=1;i<=200000;i++)par[i]=i;}\n\tint find(int x){\n\t\treturn par[x]==x?x:par[x]=find(par[x]);\n\t}\n\tvoid merge(int x,int y){\n\t\tint nx=find(x),ny=find(y);\n\t\tpar[nx]=ny;\n\t}\n}uf;\nbool dead[2][100005];\nvoid kill(int op,int x){\n//\tcerr<<op<<\" \"<<x<<endl;\n\tdead[op][x]=1;\n\tfor(int i=0;i<g[op][x].size();i++){\n\t\tif(dead[op^1][g[op][x][i]])continue;\n\t\tkill(op^1,g[op][x][i]);\n\t}\n}\nbool can(int x,int y,int v){\n\tif(dead[0][x]&&dead[1][y])return false;\n\tif(dead[0][x]){\n\t\tdead[1][y]=1;\n\t\treturn true;\n\t}\n\tif(dead[1][y]){\n\t\tdead[0][x]=1;\n\t\treturn true;\n\t}\n\tif(uf.find(x)==uf.find(y+1e5)){\n\t\tkill(0,x);\n\t}else{\n\t\tg[0][x].push_back(y);\n\t\tg[1][y].push_back(x);\n\t\tuf.merge(x,y+1e5);\n\t}\n\treturn true;\n}\nsigned main(){\n\tcin>>n>>h>>w;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>xx[i]>>yy[i]>>a[i];\n\t\tS.insert(make_pair(-a[i],make_pair(xx[i],yy[i])));\n\t}\n\tint ans=0;\n\twhile(!S.empty()){\n\t\tif(can(S.begin()->second.first,S.begin()->second.second,-S.begin()->first)){\n\t\t\tans-=S.begin()->first;\n\t\t\tcerr<<-S.begin()->first<<endl;\n\t\t}\n\t\tS.erase(S.begin());\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst int maxn = 2e5 + 10;\n\nvector<int> g[maxn];\nint mt[maxn];\nint used[maxn];\nint cn = 1;\n\nbool dfs(int v) {\n\tif (used[v] == cn) return false;\n\n\tused[v] = cn;\n\n\tfor (int u : g[v]) {\n\t\tif (mt[u] == -1 || dfs(mt[u])) {\n\t\t\tmt[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\tfastInp;\n\n\tll n, h, w;\n\tcin >> n >> h >> w;\n\n\tll vals = 0, ans = 0;\n\tvector<tuple<ll, ll, ll>> vec;\n\tfor (int i = 0; i < h + w + 3; i++) mt[i] = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tll r, c, a;\n\t\tcin >> r >> c >> a;\n\t\tr--; c--;\n\t\tvec.push_back({ a, r, c });\n\t}\n\n\tsort(vec.rbegin(), vec.rend());\n\n\tll cnt = 0;\n\tll hw = h + w;\n\tfor (int i = 0; i < n; i++) {\n\t\tll r = get<1>(vec[i]), c = get<2>(vec[i]), a = get<0>(vec[i]);\n\t\tif (mt[r] == -1 || mt[c + h + 1] == -1) {\n\t\t\tvals++;\n\t\t\tcnt++;\n\t\t\tg[i].push_back(r);\n\t\t\tg[i].push_back(c + h + 1);\n\t\t\tif (mt[r] == -1) {\n\t\t\t\tmt[r] = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmt[c + h + 1] = i;\n\t\t\t}\n\t\t\tans += a;\n\t\t\tcontinue;\n\t\t}\n\t\tcn++;\n\t\tvals++;\n\t\t\n\t\tg[i].push_back(r);\n\t\tg[i].push_back(c + h + 1);\n\t\tcnt += dfs(i);\n\n\t\tif (cnt >= vals) {\n\t\t\tans += a;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tvals--;\n\t\t\tg[i].pop_back();\n\t\t\tg[i].pop_back();\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define int long long\nusing namespace std;\nconst int N = 1e6 + 5;\n\nint n, w, h;\nstruct edge { int u, v, w; } e[N];\nint fa[N << 1];\nbool ring[N << 1];\n\nint find(int x) {\n    return x == fa[x] ? x : fa[x] = find(fa[x]);\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> w >> h;\n    for (int i = 1; i <= w + h; i++)\n        fa[i] = i, ring[i] = false;\n    for (int i = 1; i <= n; i++)\n        cin >> e[i].u >> e[i].v >> e[i].w;\n    \n    sort(e + 1, e + 1 + n, [](const edge& x, const edge& y) {\n        return x.w > y.w;\n    });\n\n    long long ans = 0ll;\n    for (int i = 1; i <= n; i++) {\n        int u = e[i].u, v = e[i].v + h, w = e[i].w;\n        u = find(u), v = find(v);\n\n        if (u == v) {\n            if (!ring[u]) ring[u] = 1, ans += w;\n        } else {\n            if (!ring[u] || !ring[v]) {\n                ring[u] = ring[v] = ring[u] | ring[v];\n                fa[u] = v, ans += w;\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <cmath>\n#include <typeinfo>\n#include <numeric>\n#include <cassert>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n\n#define rep(i,n) for(ll i=0LL;i<n;++i)\n#define srep(i,s,n) for(ll i=s;i<n;++i)\n#define rrep(i,n) for(ll i=n-1LL;i>=0LL;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define CIN(x) do { \\\n    assert(!cin.eof()); \\\n    cin >> x; \\\n    assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T>>;\n\ntemplate <typename S, typename T>\nT get_m(M<S, T> &m, S k, S default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        memset(tree, 0, sizeof(ll) * (n+1));\n        this->init(init);\n    }\n\n    void init(ll init) {\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll>> q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_linklist(const V<t2> &srclist, V<ll> dstlist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        dstlist[a].pb(b);\n        dstlist[b].pb(a);\n    }\n}\n\nvoid make_parental_relation(const V<ll> linklist[], ll root, ll n,\n                            ll parent[], V<ll> children[], ll level[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parent[root] = root;\n    level[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : linklist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parent[next] = now;\n            children[now].pb(next);\n            level[next] = level[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n        << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename S, typename T>\nvoid _debug_print(const M<S, T> &xlist)\n{\n    for (auto x : xlist) {\n        S k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nint _main();\nint main()\n{\n    cout << setprecision(12);\n    return _main();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nV<t3> a_rc_list;\nll raw_users[100005];\nll column_users[100005];\nbool raw_failed[100005];\nbool column_failed[100005];\n\nbool try_rip_raw(ll r, ll srcidx, M<ll, ll> &raw_idx, M<ll, ll> &column_idx);\nbool try_rip_column(ll c, ll srcidx, M<ll, ll> &raw_idx,  M<ll, ll> &column_idx);\n\nbool try_rip_raw(ll r, ll srcidx, M<ll, ll> &raw_idx, M<ll, ll> &column_idx)\n{\n    if (raw_failed[r]) return false;\n\n    if (raw_idx.find(r) != raw_idx.end()) {\n        raw_failed[r] = true;\n        return false;\n    }\n\n    raw_idx[r] = srcidx;\n\n    if (raw_users[r] != 0LL) {\n        ll dstidx = raw_users[r];\n        auto a_rc = a_rc_list[dstidx];\n        ll c = get<2>(a_rc);\n        auto ret = try_rip_column(c, dstidx, raw_idx, column_idx);\n        if (!ret) column_failed[c] = true;\n        return ret;\n    }\n\n    return true;\n}\n\nbool try_rip_column(ll c, ll srcidx, M<ll, ll> &raw_idx,  M<ll, ll> &column_idx)\n{\n    if (column_failed[c]) return false;\n\n    if (column_idx.find(c) != column_idx.end()) {\n        column_failed[c] = true;\n        return false;\n    }\n\n    column_idx[c] = srcidx;\n\n    if (column_users[c] != 0LL) {\n        ll dstidx = column_users[c];\n        auto a_rc = a_rc_list[dstidx];\n        ll r = get<1>(a_rc);\n        auto ret = try_rip_raw(r, dstidx, raw_idx, column_idx);\n        if (!ret) raw_failed[r] = true;\n        return ret;\n    }\n\n    return true;\n}\n\nvoid copy_maps(const M<ll, ll> &raw_idx, const M<ll, ll> &column_idx)\n{\n    for (auto ri : raw_idx) {\n        ll r = ri.first;\n        ll idx = ri.second;\n        raw_users[r] = idx;\n    }\n\n    for (auto ci : column_idx) {\n        ll c = ci.first;\n        ll idx = ci.second;\n        column_users[c] = idx;\n    }\n}\n\nvoid get_card(t3 a_rc, ll idx)\n{\n    ll r = get<1>(a_rc);\n    ll c = get<2>(a_rc);\n\n    M<ll, ll> raw_idx;\n    M<ll, ll> column_idx;\n    if (try_rip_raw(r, idx, raw_idx, column_idx)) {\n        copy_maps(raw_idx, column_idx);\n        return;\n    }\n\n    raw_idx.clear();\n    column_idx.clear();\n    if (try_rip_column(c, idx, raw_idx, column_idx)) {\n        copy_maps(raw_idx, column_idx);\n        return;\n    }\n}\n\nint _main()\n{\n    ll n; llin(n);\n    ll h; llin(h);\n    ll w; llin(w);\n    V<t3> rcalist; llinl3(rcalist, n);\n\n    for (auto rca : rcalist) {\n        ll r = get<0>(rca);\n        ll c = get<1>(rca);\n        ll a = get<2>(rca);\n        a_rc_list.pb(t3(a, r, c));\n    }\n    a_rc_list.pb(t3((ll)pow(10LL, 18LL), -1LL, -1LL));\n    sort_reverse(a_rc_list);\n\n    memset(raw_users, 0, sizeof(raw_users));\n    memset(column_users, 0, sizeof(column_users));\n    memset(raw_failed, 0, sizeof(raw_failed));\n    memset(column_failed, 0, sizeof(column_failed));\n\n    srep (i, 1LL, n+1LL) get_card(a_rc_list[i], i);\n\n    ll ans = 0LL;\n\n    rep (i, 100005) {\n        ll idx = raw_users[i];\n        if (idx == 0LL) continue;\n        auto a = get<0>(a_rc_list[idx]);\n        debug_printf(\"raw a = %lld\\n\", a);\n        ans += a;\n    }\n\n    rep (i, 100005) {\n        ll idx = column_users[i];\n        if (idx == 0LL) continue;\n        auto a = get<0>(a_rc_list[idx]);\n        debug_printf(\"column a = %lld\\n\", a);\n        ans += a;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define owo(i,a, b) for(int i=(a);i<(b); ++i)\n#define uwu(i,a, b) for(int i=(a)-1; i>=(b); --i)\n#define senpai push_back\n#define ttgl pair<int, int>\n#define ayaya cout<<\"ayaya~\"<<endl\n \nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ngp_hash_table<int, gp_hash_table<int, int>> mp;\nusing ll = long long;\nusing ld = long double;\nconst ll MOD = 1000000000;\nconst ll root = 62;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nll binpow(ll a,ll b){ll res=1;while(b){if(b&1)res=(res*a)%MOD;a=(a*a)%MOD;b>>=1;}return res;}\nll modInv(ll a){return binpow(a, MOD-2);}\nconst double PI = acos(-1);\nconst double eps = -1e6;\nconst int INF = 0x3f3f3f3f;\nconst int NINF = 0xc0c0c0c0;\nconst ll INFLL = 0x3f3f3f3f3f3f3f3f;\nconst ll NINFLL = 0xc0c0c0c0c0c0c0c0;\nconst int mxN = 200001;\nint h, w;\nint n;\npair<int, ttgl> arr[mxN];\nint dsu[mxN];\nint sz[mxN];\nint esz[mxN];\nll ans = 0;\nint find(int a) {\n    return a==dsu[a] ? a : dsu[a] = find(dsu[a]);\n}\nvoid merge(int a, int b, int val) {\n    a = find(a);\n    b = find(b);\n    if(a==b) {\n        if(esz[a]<sz[a]) {\n            esz[a]++;\n            ans+=val;\n        }\n    }else {\n        if(esz[a]+esz[b]<sz[b]+sz[a]) {\n            dsu[b] = a;\n            sz[a]+=sz[b];\n            esz[a]+=esz[b];\n            esz[a]++;\n            ans+=val;\n        }\n    }\n}\nint main() {\n    //freopen(\"file.in\", \"r\", stdin);\n    //freopen(\"file.out\", \"w\", stdout);\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    cin.tie(0)->sync_with_stdio(0);\n    cin>>n>>h>>w;\n    owo(i, 0, n){\n        sz[i] = 1;\n        esz[i] = 0;\n        dsu[i] = i;\n    }\n    owo(i, 0, n) {\n        cin>>arr[i].second.first>>arr[i].second.second>>arr[i].first;\n        arr[i].second.first--;\n        arr[i].second.second+=h-1;\n    }\n    sort(arr, arr+n);\n    reverse(arr, arr+n);\n    owo(i, 0, n) {\n        merge(arr[i].second.second, arr[i].second.first, arr[i].first);\n    }\n    cout<<ans<<\"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (ll i = 0; i < (ll)(n); i++)\nll ans = 0;\nstruct UnionFind\n{\n  vector<ll> data;\n  UnionFind(ll size) : data(size, -1) {}\n  bool unionSet(ll x, ll y)\n  {\n    x = root(x);\n    y = root(y);\n    if (x != y)\n    {\n      if (data[y] < data[x])\n        swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(ll x, ll y)\n  {\n    return root(x) == root(y);\n  }\n  ll root(ll x)\n  {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  ll size(ll x)\n  {\n    return -data[root(x)];\n  }\n};\nstruct point {\n    ll x,y,val;\n    point() {}\n    point(ll x, ll y, ll val) : x(x), y(y), val(val) {};\n};\nbool cmp(const point &a, const point &b)\n{\n  return a.val > b.val;\n}\nint main()\n{\nll n , h , w ;\ncin >> n >> h >> w ;\nvector<point> v;\nrep(i,n){\n  ll r , c , a ;\n  cin >> r >> c >> a ;\n  v.emplace_back(r-1,c-1,a);\n}\nsort(v.begin(),v.end(),cmp);\nvector<bool> ch(h+w); \nUnionFind arr(h+w);\nrep(i,n){\n  if(arr.findSet(v[i].x, v[i].y+h)){\n    if(!ch[arr.root(v[i].x)]){\n      ans+=v[i].val;\n      ch[arr.root(v[i].x)]=1;\n    }\n  }\n  else{\n    bool t=ch[arr.root(v[i].x)]|ch[arr.root(v[i].y+h)];\n    bool tt=ch[arr.root(v[i].x)]&ch[arr.root(v[i].y+h)];\n    if(tt)continue;\n    ans+=v[i].val;\n    arr.unionSet(v[i].x, v[i].y+h);\n    ch[arr.root(v[i].x)]=t;\n  }\n}\ncout << ans << endl;\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\ntypedef long long ll;\n#define inf 0x3f3f3f3f\nint n,h,w;\nint x[maxn],y[maxn];\nll a[maxn];\nset<pair<ll,int> > qx[maxn],qy[maxn];\nvector<pair<ll,int> >cards;\nll ax,ay;\nbool ux[maxn],uy[maxn],usd[maxn];\nint cx[maxn],cy[maxn];\nqueue<int> que;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&h,&w);\n//\tmemset(cx,-1,sizeof(cx));\n//\tmemset(cy,-1,sizeof(cy));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%lld\",&x[i],&y[i],&a[i]);\n\t\tx[i]--;\n\t\ty[i]--;\n\t\tcx[x[i]]++;\n\t\tcy[y[i]]++;\n\t}\n    ll ans=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(cx[x[i]]==1||cy[y[i]]==1)\n\t\t\tque.push(i);\n\t\telse\n\t\t{\n\t\t\tqx[x[i]].insert(make_pair(a[i],i));\n\t\t\tqy[y[i]].insert(make_pair(a[i],i));\n\t\t}\n\t}\n\twhile(!que.empty())\n\t{\n\t\tint cur=que.front();\n\t\tque.pop();\n\t\tusd[cur]=1;\n\t\tans+=a[cur];\n\t\tusd[cur]=1;\n\t\tcx[x[cur]]--;\n\t\tcy[y[cur]]--;\n\t\tif(cx[x[cur]]==1)\n\t\t{\n\t\t\tif(!qx[x[cur]].empty())\n\t\t\t{\n\t\t\t\tpair<ll,int> he=*(qx[x[cur]].begin());\n\t\t\t\tqx[x[cur]].clear();\n\t\t\t\tint id=he.second;\n\t\t\t\tque.push(id);\n\t\t\t\tqy[y[id]].erase(he);\n\t\t\t}\n\t\t}\n\t\tif(cy[y[cur]]==1)\n\t\t{\n\t\t\tif(!qy[y[cur]].empty())\n\t\t\t{\n\t\t\t\tpair<ll,int> he=*(qy[y[cur]].begin());\n\t\t\t\tqy[y[cur]].clear();\n\t\t\t\tint id=he.second;\n\t\t\t\tque.push(id);\n\t\t\t\tqx[x[id]].erase(he);\n\t\t\t}\n\t\t}\n\t}\n//\tcout<<ans<<endl;\n\tfor(int i=0;i<n;i++)if(!usd[i])\n\t\tcards.push_back(make_pair(a[i],i));\n\n    sort(cards.begin(),cards.end());\n    reverse(cards.begin(),cards.end());\n    int p = 0;\n\t//for(int i = 0; i < cards.size(); ++i) printf(\"%d \", cards[i].first);\n    for(int i = 0; i < cards.size(); ++i) if(cards[p].first > cards[i].first * 2){\n    \trandom_shuffle(cards.begin() + p, cards.begin() + i);\n    \tp = i;\n\t}\n\trandom_shuffle(cards.begin() + p, cards.end());\n    for(int _=0;_<cards.size();_++)\n    {\n    \tint i=cards[_].second;\n\t//\tcout<<i<<\" \"<<x[i]<<\" \"<<y[i]<<\" \"<<qx[x[i]].top().second<<\" \"<<qy[y[i]].top().second<<endl;\n        qx[x[i]].erase(make_pair(a[i],i));\n        qy[y[i]].erase(make_pair(a[i],i));\n        if(ux[x[i]]&&uy[y[i]])continue;\n        if(ux[x[i]])\n        \tuy[y[i]]=1;\n        else if(uy[y[i]])\n        \tux[x[i]]=1;\n        else\n\t\t{\n\t\t\tax=qx[x[i]].empty()?-inf:(*(qx[x[i]].rbegin())).first;\n\t\t\tay=qy[y[i]].empty()?-inf:(*(qy[y[i]].rbegin())).first;\n\t\t\tif(ax<ay)\n\t\t\t{\n        //   \tcout<<\"puthang \"<<x[i]<<endl;\n            \tux[x[i]]=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n      \t//    \tcout<<\"putlie \"<<y[i]<<endl;\n \t    \t\tuy[y[i]]=1;\n \t    \t}\n        }\n        ans+=a[i];\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*\nCoded by 秦惜梦\nThe most charming girl in the world\n@@@@@@@@@@##&|;!!!!!!!!!!||||||||%%%%%$$$$$$$$$$$$%%$$$&&&&&&&&&$$&&&&&&&&&@@@&%||||||$&&&&@&%;'```'`':!||%&@@@@#@&&&&&@@@&&$$$&&@@&$$$&@@@@@@@@@@@@@#@@@@@@@@@@#@@@@@#@@@@@@@@@@##$\n@@@@@@@@@####$!;!!!!!!!!!||||||||%%%%%%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&@@@@@@&%|||||!:'`'!$&&&&&&%:''!|||$&&&@@@@@@&&&&&@@@&$$$&&@&&$&&@@@@@@@@@@@@@@@@@@@@@@@@##@@@@#@@@@@@@@@@#@%\n@@@@@@@@@####@|;!!!!!!!!!|||||||%%%%%%%%%%%%%$$$$$$$$$$&&&&&&&&&&&&&&&@@@@@@@@&%|;:'''''``````'!$&&&@@&|:;%$$&&&@@@@@&&&&&@@@&$$$&&@@@@@@@@@@@@@@@@@@@@@@@#@@@@@#@@@@@#@@@@#@@@@##@%\n@@@@@@@@####@@&|;!!!!!!!!|||||||%%%%%%%%%%%%%%$$$$$$$$&&&&&&&&&&&$$$&&@@@@@@@@@@&$|;'''''````````'':!$&&&$%%%%$$&@@@@@&&&&&@@@@&&&@@#@@@@@@@@@@@@@@@@@@@@@@@@@@@#@@@@@@@@@@#@@@@#@@%\n@@@@@@@#####@@@$!;!!!!!!|||||||%%%$$$$$%%%%%%%%%$$$$$$$&&&&&&&&&$$$$&&@@@@@@@@$%$&@@&&&@&$%;:':;:''`````'|%%%%%%$$&@@@@@&&&&@@#@@@@@@#@@@@@@@@@@@@@@@@#@@@@@@@@@#@@@@@@@@@@@@@@#@@@%\n@@@@@@#####@$%%%$$$%%%||%%||||%%%%$%%$$$$$%%%%%%%$$$$&&&&&&&&&$$$$$$&&@@@@@@@&$;'''''':!%&&&&&&@@&%;'```:$&&%%%%%$$$&@@@@&&&&@@@@@@@@@#@@@@@##@@@@@@@@#@@@@@@@@@@@@@@#@@@@@@@@@#@@@%\n$&@@@@######&&&&&$%%%%|%|||||||%%%%%$$$$$$$$$$$$$&&&&&&&&&&&&&&&&$$$$&&@@@@@@&$!''''''````````:!|$&&&&&&&$&&&$%%%%$$$&&@@@&&&&&@@@@&@@@@@@@@@#@@@@@@@@#@@@@@&&&@@@@@@@@@@@@@@@#@@@@$\n$$$&@######@&&&&&&|!!!!!|||||||%%$$$$$$$$$$$$$$$&&&&&$$&&&&&&&&&&&&$$&&&@@@@@@&%;::''````````'':'``....`;|%$&&&$%%$$$$$&@@@&&&&&@@@@@@@@#@@@@@#@@@@@@@@@@@@@@&&@&&&&&&&&&@@@@@@@@@@$\n$$$&@#####@&$$&&@#&|!!!!!|||||||%%%$$$$%%%%%$$$$$$$&&&&&&&&&&&&@@@@@&&&&&&@@@@@@@@@@@&&&&&&&&@@@@&&$$%||||%%%$$&&&$$$$$$$&@@@&&&&&@@@@@@@#@@@@@@@@@@@@@@@@@@@@&&@&&&&&&&&@@@@@@@@@#$\n$$&@######@&$&@##@&$|!!!!|||||||%%%%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&$$&&&&&&@@&|'`````````':::;;;;;;!|%%%%%%%%$&@@&$$$$$$$&@@&&&&&@@@@@@@@@@@@@@@@@@@@#@@@@@@@@@&&&&&&&&&@@@@@@@#@%\n$&@######@&&&@##@$$$$|!!!||||||||%%%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&$&&&&&&&&@@$!:::'':::::::::::::''``.:%%$$$$$$&@@@&$$$$$&@@@&&&&@@@@@@@@@@@@#@@@@@@@@@@#@@@@#@@@@@@&&&@@@@@@@@@%\n$&@######@&&@#@&$$$$&$|!!!||||||||%%%%%%%%%$$$$$&&&&&&&&&&&&&&&&&&&$$$&&&&&&&&&&&%;::::::::::::':''':'':::%&$$$$$$$$&&@@&$$$$$&@@@&&&&@@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@%\n&@#######@@@#@&$$$$$&&$|!!|||||||||%%%%%%$$$$$$$$$&&&&&&&&&&&&&&&$$$$$&&&&&&&&&&&$!''::::'''::;!|%%$&&@@@@&&@@$$%%$$$$&&@&&$$$$&@@@&&&&@@@@@@#@@@@@@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@%\n############&$$$$$$$&&&$|!!||||||||%%%%%%$$$$$$$$$$$$$$&&&&&$$$$$$$$$$&&&&&&&&&&&&@@@&&&&&&&@@@@@@&&&$$%|!;%@@@@&$$$$$$$$&@@&$$$$&@@@&&&@@@@@@@@@#@@@@@@#@@#@@@@@@@@@@@@@@@@@@@@@@@$\n########@&$$$$$$$$$&&&&&$|!!||||||%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&@@&&&&&&&&&&&&&&$$$$$$$$$$&&&$$%!;:::|$&@@@@&$$$$$$$&@@&$$$&@@@&&&@@@@@@@@##@@@@@@@@@@@@#@@@@@@@@@@@@@@@@@@@$\n########@$%%%$$$$$$&&&&&&&%!||||%%%$$$%%%%%%%%%%%%%%%%%%%%%%%$$$$$&&&&&&&&&&@@@&&&&&&&&&&&&$$$$$$$$$$$$$&&%!!$$$$&@@@@&$$$$$$&@@@&&&&@@@&&@@@@@@@##@@@@@#@@@@@@@@@@@@@@@@@@@@@@@@@@%\n#######@&$$$$$$$$$$$$&$|!||%%%%||%%%%%%%%%%%%%%%%%$$$$$$&$$$$$&&&&&&&&@@@@&&&&&&&&&&&&&&&&&&&$$&&$$$$$$$$$&&&$&@&$$$&@@@&$$$$$$&@@@@&&@@@@&@@@@@@###@@@@@@@@@@@@@@@@@@@@@@@@#@@@@#@%\n#######@$$$$$$%$$$$$$$&&$||||%%%%%%$$$$$$$$$$$$$$$$$$$$$$$&&&&&&&&&&@@&&&&&&&&&&&&$$$$$$&&&&$$$$$$$$$$$$$$$$$$&@@@@&$$$&@@@&$$$$&&&@@@&@@@@&&@@@@@###@@@@#@@@@@#@@@@@@@@@@@#@@@@#@@$\n#######&$$$$$$$$$$&$$$$$&&&&&$%||%%%%%%$$$$$$$$$$$$$$$$$&&&&&&&&&&&@&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&@@@&$$$&@@@&$$&&&@@@@@@#@@@@@@@@##@@@@#@@@@@@@@@@@@@#@@@@@@##@##$\n######@$$$$$$$$$$$$$$$$$$&&&&&&$||%%%%%%%$$$$$$$$$$$$$&&&&&&&&&@@&&&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&@@@@@&&$&&@@@&&&&&@@@@@##@@@@@@@##@@@###@@@@@@@@@@@@@@#@@@#@#@@%\n######&$$$$$$$$$$$$$$$$$&&&&&&&&$%|%%%%%%%$$$$$$$$$$&&&&&&&&&&@&&@@&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$&$$$$$$$$$$$$$$$$&@@@@@@&&&&&@@@&&&&@@@@@#@@@@@###@@@##@@@@@@@@@@@@@@#@@@####@#$\n#####@$$$$$$$$$$$$$$$$$$$&&&&&&&&&%%%%%%%%%$$$$$$$$&&&&&&&&&&&&&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$&$$$$$$$$$$$$$$$$$&&&@@@@@&&&&@@@@@@@@@@@@#@@@@###@@@$%%%%%%%%%%%%%$&@@#######$\n#####@&$%$$$$$$$$$$$$$$$$$$&&&&&&&&$%%%%%%%%%%$$$$&&&&&&&&&&&&&&&&$$$$$$$$$$$$$$$$$$$$$$$$$$%$$$$$$$$$%%$$$$$$$$%%$$$$$%&@&&&&@@@@@&&@@@@@&&@@@@#@@@@###@&%%%%%%%%%%%%%%%%%&@##@##@%\n####@@@@&$$$$$$$$$$$$$$$$$$&&&&&&&&&&%%%%%%%%%%$$&@&&&&$&&&$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$||$$$$$$$$%%$$$$$|%$$$$$$$%%$&@@@&&&@@@@@@@@@@@@&@@@@@@@@##@&%%%%%%%%%%%%%%%%%%%$@@@@@%\n####@@@@@@&$%$$$$$$$$$$$$$$$$$&&&&&&&&$%%%%%%%$&&&&&$$$$$$&$$$$$$$$$$$$$$$$$$$$$$$%%$$$%%%%|!|||$$$$%!|%%%$$&$$$$$$$$$$%%%$&@#@@@@&&@@@@@@@@@@@@@@##@@@@#@@@&$$%%%%%%%%|%%%%%|$@@@@$\n###@@@@@@@@$$$%$$$$$$$$$$$$$&&&&&&&&&&&&%%%%%&&&&&$%%%$$&&&$$$$$$$$$%%%$$|%$$$%%%$%%|%%!;!||!!||%$$$$$$$%%$&$$&&$$$$$$$$$$%%$@@#@@@@@@&&@@@@@@@@#@@###@@@########@@$%%%%%%%|%%$&@##$\n##@@@@@@@@@&$$$&$$$$$$$$$$$$$$$&&&&&&&&&&&%%%$&%|%%%%%$%%$$%%%%%%$$$%%%$$||%%%$$$$$%%%%%$$$$$%!!|%&&$$$$%|$$$$$$&$$$$$$$$$$$%$$&@@@@@@@@@@@@@@@##@@@@##@@####@@#######&%%%%%%%$@###$\n#@@@@@@@@@@&&$$&$$$$$$$$$$$$$$$&&&&&&$||%%%$$%!;!;!|%%%%$%!||||%%%$$$||%$%%%%%%$$$$%$$%%%%$%$$$$||$&&$$&%|%$$$$$$$&$%%$%|%$$$$%$%$@@@@@@##@@@@@@@@@@########@##@@@######&$$&@@@@@##$\n@$$&@@@@@@@&&$$$$$$$$$$$$$$$$$$&&&$&&&&$$&$$%!|%%%%%%%%%%||%%%%%%%%$$||%$$$$%%%%$$$%%$$%%%%%%%$$%|%&&$$&$%%$$$$$$$&&$%%&&&&$$$$$$$||$@@@@@@@@@@@@@@@@@@@####@@@@##@@@#@@@@@@@@@@@@@%\n&$%%$$&&&$$$$$$$$$$$$$$$$$$$$$$$$$$&&&&&&&&|!|%%%%|%%%%%%$%%%%||||%$$%|%$&&$%%%%$$$$%$$%%%%$$$$$%|$&&&$&$$$&$&$$$$&&&$%$&&&$$&&&&&$%!!|$&@@@@@@@@@@@@@@@@###@@@@@@@@@@@@@@@@@@@@@@@%\n$$%$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&$&&&&&&$|!|||%%|%%%%%%$$%%%%||||%$$%%%$&&$%%%$$&&&$$$$$$$$$$$$$%%&&&&&$$&&$&$$&&&&&&&&&&&&&&&&&&&&$|!!!!$&@@@@@@@@@@@#####@######@##@@&@@@@@@@@@@$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&&&&$|!|||%$%%%%%%%$$$$%%%||||%$$%%%$&&$$%%$&&&&&$$$$$$$$$$$$%%&&&&&$$&&$&$$&&&&&&&&&&&&&&&&&&&&&&%!!!!|&&&@@@@@@#########@########@@##########$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&&&$&$%|!||%$$%%$%%%%$$$$$%%|||||$$$&$$&$$$%$&&&&&&$$$$$%$$$$$$%$&&&&&&&&&&&$$&&&&&&&&&&&&&&@@&&&&&@@$|!$@&||||%&@#@@####@########@@@@@@@#@&&@@##$\n$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&&&$$&$%|!||%$$%%%%%%%$$$%$$%%||||%$&&&&&&$$$$$$&&&&&$%$$$%%$$$$$%$&&&&&&&&$$$$$&&&&&&&&&&&&&&@@@&&@@@@@&@@&|||||||||%&@###############@@@@@@##@@@@%\n%$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$&$&&$$$$%!!|%$$$%%%%%%$$$$%$$$%||||$&&$$&&$$$$$$$&&&$&$%%$%%%%%%$$%$$$&&&&&$$$$$$&&&&&&$&&&&&&&&&&&&&&&@@@@&||||||||||||$@#####@@@########@@@@@###@@$\n%%%%%%%%$$$$$$$$$$$$$$$$$$$$$$$$$&&%%&%!!||%$$%%$$%%$$$$%%$$%%|!|%&&$%%&&$%%%%$$$&$|%$||$%%%%%%$$$$$$&&&&$$$$$$&&&&&&$$$&&&&&&&&&&@@&&&@@@&&%|||||||||%&@@##@$$@@@@########@@@@@@##$\n;:''':;!|%%$$$$$$$$$$$$$$&&&&&&&&%%&&$!!|%%%%%%%$$$$$$$%%%$%%%|||$$&%!%&$%%%%|%%%&%!|$||%%%%%%%$$$$%%$&&$$$$$$$&&&&&&$$$$&&&&&&&&&&&&&&@@@@&&%|||||||%@@@@#@%|&#$||||%&@@@@@@@@@@@@$\n.....  .`;|%%$$$$$$$$$$$&&&&&&$%%$&&$!;|%%|||%%$$&&&&$$%%$$%%%%%%%&%!;|$$%||||%%%$|;!%||$%$$$$$%%%%||$&$%%%$$$$&&&&&&$$$$&&&&&&&&&&&&&@@@@@@&&%|||||$@@@##&%|%@@%||||||||||&@@@@@@@%\n........  `;|%$$$&&&&&&&&&&&$%$&&&&$|!|%%|!!|||$&$&&&$$%%%%%||||%$$|;;|%%|||||%$&&$|!|!!%%%%%%|!!|%!%$$%||%$&$&&&&&&&$$$$&&&&&&&&&&&&@@@@@@@@&&%|||$@@@##@$||$#&|||||||||||&#$|||||!\n...    ..  `;|%$$$$&&&&&&$%$$&&&&&&||%%$||!!||$&$$$$$$%%%%%%||||%$%!:!!!%%$$$%%%%|!;;;;;!!!!!;;;||!%&%|%%%$&&$&&&&&&&$$$$&&&&&&&&&&&@@@@@@@@@&&$||$@##@@@%||%&@$||||||||||%&@$|||||!\n       ..  .'!|%$$&&&&&&&&&&&&&&&&||$$&%||!||%&&$$$$$$%%$%||||||%|!;:;;;|%|!!!!!|!|$$&&&&$$$%!!!!;|&&$%%%$&$$$$%||&@&$$$$&&&&&&&&&@@@@@@@@@@@@&$|%@@@@#@%|||$@&%||||||||||%@@%|||||!\n       ... .';|%$$&&&&&&&&&&&&&&&%%&$&&%|||||%&&$$$$$$%%$%%%||||%!;:::::::'':;!|%%%%$&@&&$%|!|%|;!$&$%|%%$$$$&$|!|$@@&$$$&@@@@@@@@@@@@@@@@@@@@&$$@@@#@&%|||%&#$|||||||||||$@&%|||||!\n    ....   .:!|%$$&&&&&&&&&&&&&&$$&&&&$|||||%$@&$$&$$&&&$%|%%%%|;::''''''````'!!!;'`'%@&%|!::!;;!$$||%%%$&$$$$|!!|%&@@&&&&@@@@@@@@@@@@@@@@@@@@&&@@@@#@%||||$@@$|||||||||||$#&||||||!\n     ..   .';!|%$$$&&&&&&&&&&&&$$&&&&&$$%||%%&@&$$&$$$$%|!;;;;:::'`````````````````';;:;!;'::::;%$|||!!|$$$%$%||||$@@@&&&@@@@@@@@@@@@@@@@@&&@&&&&&&@@@$%%||&#&%||||||||||%&#$||||||!\n        .`:!!!|$$&&&&&&&&&&&&&&&&&&&&&&&$%$$$&@&&$&&$$|!|%$$$$%|;''``````````````':;!!!;::''':;!$%|$$%%$$$$$$%!!%&@@@@@@@@@@@@@@@@@@@@@@@@&&&&@&$$&@@@@@@@@@#&%||||||||||%@@$||||||!\n;:''`'':;!!!!|%$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$&&&&&$|!%%%%$&$$|;'``````````````''''''''::::;|$&$$$%%$$%%$$$&@@@@@@@@@@@@@@@@@@@@@@@@@@@&&&@&$$$&&&@@@@@@@@@@@@@@&$%|||$@@$||||||!\n|!;;;!!!!!!|%$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%!:;|!||!!:'''``````````````''''''''':;;|$$$$$%%$%$$$&&&&&@@@@@@@@@@@@@@@@@@@@@@@@&&&@&$$$&&&&&@@@@@##@@@@@&&@@@@@@#@&%|||||!\n%|!!!!!!||%$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@@&&&&&&$$$!';;;:'```''`````````````````'''''';;:|$$$$$$$$%$$$&@&&&&@@@#@@@@@@@@@@@@@@@@@@@&&@&$$$$$$$&&&@@@@##@%;''|&@@@@@@@#@@@@@@@%\n&$%%%%%%$$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@&&&@&&&$$$%;``'''``':'``````````````````'''':::;|$$$$$$$%$$$$&&&&&&@@@##@@@@@@@@@@@@@@@@@@&@&$$$&&&$$$&&&@@@@|:''':%@@@@@@@#@@@@@@@@%\n@@&$$$$$&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@&&@@&&&$$$$%:``````';:'```...`````````````'''':;|$$$$$$%%$$$$&&&&&&&@@##@@#######@@#@@@@@@#@&$$&&&&&$%$$&&@@%:'::'!&@@@@&@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&@@&&&&&&&$$%:``````':;:```..``````````````''':;|$$$$$$%%$$$&&&&&&&@@@####################@&$$&&$$$$$$$|;|&$!''':;$&&&&&&@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$&@&$&&&$&&&&&%'``````.``````....```````````'`'';|$&$$$%$$$$$$&&&&&@@@@@##################@$$$&&$$$$$|:':;%&$;''''|&&&&&&&&@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$%$&@@$$$$$&&&&&@@!````````.......````````````''`'':!%$&&&$$&&&&&&&&&&@@@#@@##############@@&$$$$&$$$$$$|:''|&&|''''!$&&&&&&@@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&|;%&$&@$$$$$$&&&&&@@&;..``..........````````````''``'';%$&&&&&&&&&&&&&&@@@@@##@############@@@$$$$&$!|$$$$!:':%@%:``':%&&@@@@@@@@@@@@@@@@@%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&$!!$&&$&&$|!|%$$$&&&@@@@$:.........``'''``':;:'`````````':!%$&&&&&&&@&&&&&@@@@@@@#@@#########@@@&$$$%!!$$$$$%;'';$&!``':%@@@@@@@@@@@@@@@@@@@&%\n##@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&|;%&&&&$%%$%!|%%$$$$&&@@@@@$;`.....`...````````````````````';|$&&&&&&&&@@@&&&@###@@@@#@&&##@@@@@&$$$$&&$$$$$$|'```!&%;|&&&&&@@@@@@@@@@@@@@@&&&&%\n###&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%:|&&&&&$$||$&$|%%%$$&&&@@@@@@@@$;`........``'::'`...```'``````:|$$$&@@&$&@@@@@@&@#@@####@#&&#@$|%&$$%%&&$$$$%!'`.`:!$@@&&&&@@@@@@@@@@@@@@&&&&&&&&%\n###@&&&&&&&&&&&&&&&&&&&&&&&&&&|:!&&&&&&$$%||$&&$%%%$$&&&&@@@@@@@@@@&%:`.................`'````:!;;|$$$&&@@&&&&@@@@&&@########@!':|&$$%%$|;:;;!|%%%%||$@@&&&&&&&@&&&&&&&&&&&&&&&&&&&%\n###@&&&&&&&&&&&&&&&&&&&&&&$!:|&&&&&&&&$$%|%$&&&$%%%$&&&&&@@@@@@@@@@@@&&$;`..............``'';|!;;;;|%$$$$&@@@&&&@@&&$$&&@@@@##@&%||%%%$!:|%%%%%||%!|$@@@&&&&&&&&$$$$$$&&&&&&&&&&&&&%\n###@&&&&&&&&&&&&&&&&&&&|:!$&&&&&&&&&&$%%%%$$&&&$%%$$$$&&@#@@@@@@@@@@@&&&&&&|'...........``:!!;;;;;!!;|$&$%|&@@@&&&&&$!|$$$&@@#@@&%%%%$|'':!%%%%|!|$&&@@&&&&&&&$%%%%$$$$$&&$$$$$$&&&%\n###@&&&&&&&&&&&&&&&|:;%&&&&&&&&&&&&$$%%%%$$&&&&$$$$$$$$&@#@@@@@@@@@&&&&&&&&&&&&|'.....`;%%!!!!;;;!!!!;!%$$&$|%@@@@@&&@$;:::!|%$&$%%%$%:'``';!!|||%$&@@@&&&&&&$%%%%%%%$$$$$%%%%$$$$$|\n###@&&&&&&&&&$|:;%&&&&&&&&&&&&&&&$$%%$%%$&&&&&&$$$$%$$$&@@@@@@@@@##@&&&&&&&&&&&&&&%|%&&&&&$|;;;;;;;;;;;;!$&$&$|!%&@@@@@@&%;::!$$$$$$%;:```````;||||%$&&$$$$$$%|%%%%%%%$$$%%%%%%%%$%|\n###@&&$%|||$&&&&&&&&&&&&&&&&&&$$$$%%$$%$&&&&&&&$$$%%$$&&@@@@@@@@@@@##@&&&&&&&&&&&&&&&&&&&&@%;;;;;;;::;;;;!!$&&$$%!;|$$$&&&$&&&$$$$$%!|$&%:...`.`;|!|||!;!|||||||%%%%%%$%%%||||%%%%%|\n&&@@&&&&&&&&&&&&&&&&&&&&&&&$$$$$$%%$$%$&&&&&&&&$%%%%$$&&@@@@@@@@@@@@#@&@@&&&&&&&&&&&&&@###&%;;;;;;::::;;;!!!!|$$$&&%!:;!$&&&@&$$$&@&&&$%$&|``..'%#@@&$%%||||!;:'`';|%%$%%|||||||||||\n###@&&&&&&&&&&&&&&&&&&&&$$$$$$$$%%$&&$$&&&&&&&&$%%%%$$&&&@@@@@@@@@@@@@@&&&&@@@@@&&@####$;':!!;;;::::;;;;!;!;::::;%&&&&&$$$&@&$$$@@$$$$$&@@@@$%@#@@##@@&%%||||||||%%%|!'`:!||||||||||\n###@&&&&&&&&&&&&&&&&&$$$$$$$$$$$$$$$%%$$$$&&&&@$%%%%$$&&&&&@@@@@@@@@&&&&@@&&&&&&&@@@@|:':;;!!;;:::::::;;!!;:::::::::':::';$$$$$&&$&&&@@@&&@@@@@#######@@##@&%||||||||%%%%|!''!|||||!\n###@&&&&&&&&&&&&&&$$$$$$$$$$$&&$$$$$%%$$$$$&&&&&$%%$$$&&&&&$&&&@@@@&&&&&&&&&&&&@@@%:''':;;;;;:::::::::;;;:::::::::::::;;!%$$$$$|:::|$&&$&@@@@@&$&@#####@@@@####@&$%||%%%||||||;:!||!\n###@&&&&&&&&&&&$$$$$$$$$$$&&&&&$$&&$%%$$$&&&&&&&&$%$$$$$&&&&&&&@@@#@&&&&&&&&@##$;''''':;;;;;:::::::::;!;:::::::::::::::;%&$$$$|''':;%&%!;:'''':|%$&@@@@#@@&&&@##@&&@@$|%%|||||||!:;|\n:;$@@&&&&&&&$$$$$$$$$$$&&&&&&&&&$$&&$$&&&&&&&&&&&$%%$$$&&&&&&&&&&&&@@#######@|:'''''';!!!;::::::;;!!!!;::::::::::::::::|$$$$$!'::;!!%&|;;''''''''''';$&@@#@&&$$&@&&@#@@@#####@$%||;:\n''''':|$&$$$$$$$$$$&&&&&&&&&&&&&&$$&$$&&&&&&&&&&&&&$$$$$&&$$&&&&&@@@@@&$%$%|:''''''':;:::::::::::::;;:::::::::::::::::|$$$$$!::;;;;|&%;;:''''''''''''':!$&@@@&$$$$&################$\n'''''''''';%$$&&&&&&&&&&&&&&&&&&&&$$$$&&&&&&&&&&&&&&$$$$$&@@@@@###@&&$%;''''''''':::;;:::::::::::;;:::'':::::::::::':|$$$$$!::;:::|&%;;:''''''''''''''```:%&@@&&&$$$&##############$\n'''''''''''':':|&&&&&&&&&&&&&&&&&&&&$%$&&&&&&&&&&&&&&$$$$$&@@&@@@&$$%%!:''''''::::::!;::::::::::;;::::::::::::::''':|$$$$$|;;:::;%&|::'''''''''''''`.....``;$@@&&&&$$$&@###########$\n;:'''''''''''''':::!$&&&&&&&&&&&&&&&&&%|$&&&&&&&&&&&&&&$$$$&$$$$$$|:!|;':::::::::::;!;::::::::;;:::::::::::::''''':|$$$$$|;::::|&&|::'''''''''''``........`''!&@@&&&&$$$&@#########$\n.';;;;;:'''''''''''':::;%&@&&&&&&&&&&&&%$&&$$$$&&&&&&$&@&&&$$$$%!:::!|;::::::::::::!!;::::::!;::::::::::::::''''':|&$$$$|;::::|&%;;:'``''''''''````......````'!$@@&&&&&$$$&@#######$\n;;;:`.`:;;;;::'''''''''''':;%@@@&&&&&&&&$$$&&&&&&&&&&@@&!::':'':::::||;::::::::::::!!;:::;!!;;:::::::::::::::''':%&$$$$|;:::;%&|:::'`````````'''```..`...````''!$@@&&&&&&&$$&@#####$\n;;;;;;;;;'..';;;;::''''''''''':|@@@@&&&&&&$%$&&&&&&&@@%:::::::::::::!|;:::::''''''';!;:;!!;:::::::::::::::::''':%&$$$%|;:::|&%;;:'''```````'''''``...      ```''!&@&&&&&&&&&&&&@###$\n:::;;;;;;;;!;;;'':;;;;:'''''''''':!&@@@&&&&&$$&&&&@@@$;::::::::::::';|:``````````'';!;;;:'''```````````````''''|$$$$%|;::|&$!;;:'````````''::''``....      .``'':%@&&&&&&&&&&&&&&@#$\n::::::::;;;;;;;;;;;;:'':;;:''''''''':;%@@@@&&&&$&@@@$;''''''':''`''`:|;````````````:!!:'''``.........``......`!$%%%%|;;|&$!:;'`````````'''::''.     ..    `''``''!$&&@@&&&&&&&&&&&&%\n###@%!:::::::;;;;;;;;;;;;;;;;::'''''::::|&@@@&&&&&&%'```.....````''`'||'``````````';;'''``................. .!$%%%%|!%&$!:;:'``'''````'::::''.       ....``''``'''|@&&&@&&&@&&&&&&$|\n####@&&&@&|;::::::;;;;;;;;;;;;;;;:'''''''::!&@@@@@%:````......```'```;%;`````````''''``.................   .!$%%%%%$&%;:::''```'''```'::::'`.         ...``'```''';$@&&&@@&&&&&&&&&%\n####@&&&&&&&&&$!:::::::;;;;;;;;;;;;;:''''''':|@@@$;````.......``''```'!%;``````''''``.......      ....    .;%%%%%%$%;::'''`````''''`'::::`.             ...`````'''|@&&&&@@&&&&&&&&%\n####@&&&&&&&&&&&&&&|;::::::;;;;;;;;;;;;:::'':;;%&;````.........``'````:||:```':''`......                .`:|%%%%%|;::''''``````'''''::::`.               ....```'''!$@&&&&@@&&&&&&&%\n####@&&&&&&&&&&&&&&&&&&|::::::::;;;;;;;;;:::::;;'````..........``'`````:||:':''`......                .`'!$%%%%|;:''```````````'''''::;'.                 ......``':%@@&&&&&@&&&&&&%\n####@&&&&&&&&&&&&&&&&&&&&&$!:::::::;;;;;;;;;;;;'`````..........`''``````:||:''`.  .                .``!$&$%%%%%;'''`````````````'':::;;`                   .....```'!&@&&&&&&@&&&&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&|;:::::;;;;;;;;;:``````...........''````':':|%!'.                .``'|$&|;|%|%%%!''````...`````````':::;;`                    .....```'|@&&&&&&&@&&&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&&&$!::::::;;;;;:``````....``......''``':'''':!|%;..         ..``:|%$|;::;|%||%%!'`````......```''`'':::;:'   .......           ....````:%@&&&&&&@@&&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&%;:::::;;:```````....`.   ...`'':''`.  .':!||;````````';|%%|;::::';|%||%%;'```.........```'''''::::;'. ....````........  ......````:%@&&&&&&@@&&%\n####@&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&|:::::'```````...``.   ..'::'``.   .```':;!||!;;!||!;::::''``';|%||%|;'```..........```'''''::::;:.....``````````...........`````;&&&&&&&@@@&%\n*/\n\nnamespace Dsu{\n    int fa[200005],sz[200005];\n    void init(){\n        for(int i=0;i<200005;i++){\n            fa[i]=i;\n            sz[i]=1;\n        }\n    }\n    int root(int now){\n        if(fa[now]!=now){\n            fa[now]=root(fa[now]);\n        }\n        return fa[now];\n    }\n    void conn(int a,int b){\n        a=root(a);\n        b=root(b);\n        if(a==b){\n            return;\n        }\n        fa[a]=b;\n        sz[b]+=sz[a];\n    }\n}\n\nusing namespace Dsu;\n\nstruct Edge{\n    int f,t;\n    int len;\n    Edge(){}\n    Edge(int f,int t,int len):f(f),t(t),len(len){}\n    bool operator<(const Edge &e)const{\n        return len>e.len;\n    }\n}egs[200005];\n\nint n,h,w;\n\nint main(){\n    scanf(\"%d%d%d\",&n,&h,&w);\n    for(int i=0;i<n;i++){\n        int a,b,c;\n        scanf(\"%d%d%d\",&a,&b,&c);\n        egs[i]=Edge(a,b+h,c);\n    }\n    sort(egs,egs+n);\n    init();\n    long long ans=0;\n    for(int i=0;i<n;i++){\n        conn(egs[i].f,egs[i].t);\n        int x=root(egs[i].f);\n        if(sz[x]){\n            sz[x]--;\n            ans+=egs[i].len;\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nconst int mod = 1000000007;\n\nint main() {\n    ios::sync_with_stdio(false);\n    int n, h, w, b1[100005] = {}, b2[100005] = {};\n    vector<int> c1[100005] = {}, d1[100005] = {}, c2[100005] = {}, d2[100005] = {};\n    pair<int, pii> a[100005] = {};\n    ll z = 0;\n    cin >> n >> h >> w;\n    for (int i = 1; i <= n; i++) cin >> a[i].second.first >> a[i].second.second >> a[i].first;\n    sort(a + 1, a + n + 1); reverse(a + 1, a + n + 1);\n    for (int i = 1; i <= n; i++) {\n        int x = a[i].second.first, y = a[i].second.second;\n        if (b1[x] && b2[y]) continue;\n        else if (b1[x]) {\n            for (int j : c2[y]) b1[j] = 1;\n            c2[y].clear();\n            b2[y] = 1;\n            z += a[i].first;\n        } else if (b2[y]) {\n            for (int j : c1[x]) b2[j] = 1;\n            c1[x].clear();\n            b1[x] = 1;\n            z += a[i].first;\n        } else {\n            c1[x].push_back(y);\n            c2[y].push_back(x);\n            z += a[i].first;\n        }\n        //cout << b1[1] << ' ' << b1[2] << ' ' << b2[1] << ' ' << b2[2] << '\\n';\n    }\n    cout << z;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n\nstruct union_find{\n\tint N;\n\tvector<int> parent;\n\tvector<int> siz;\n\n\tunion_find(int N) : parent(N), siz(N, 1){\n\t\tfor (int i = 0; i < N; i++) parent[i] = i;\n\t}\n\n\tint root(int x){\n\t\tif(parent[x] == x) return x;\n\t\telse return parent[x] = root(parent[x]);\n\t}\n\n\tvoid merge(int x, int y){\n\t\tx = root(x), y = root(y);\n\t\tif(x == y) return;\n\t\tif(siz[x] < siz[y]) swap(x, y);\n\t\tparent[y] = x;\n\t\tsiz[x] += siz[y];\n\t\tsiz[y] = 0;\n\t}\n\n\tbool are_same(int x, int y){\n\t\treturn root(x) == root(y);\n\t}\n\n\tint size(int x){\n\t\treturn siz[root(x)];\n\t}\n};\n\nsigned main(){\n\tint N, H, W, i, ans = 0;\n\tscanf(\"%lld%lld%lld\", &N, &H, &W);\n\tvector<pair<int, pair<int, int>>> ARC(N);\n\tfor(i = 0; i < N; i++){\n\t\tint r, c, a;\n\t\tscanf(\"%lld%lld%lld\", &r, &c, &a);\n\t\tr--;\n\t\tc--;\n\t\tARC[i].first = a;\n\t\tARC[i].second.first = r;\n\t\tARC[i].second.second = c;\n\t}\n\tsort(ARC.begin(), ARC.end());\n\tunion_find uf(H + W);\n\tvector<int> finish(H + W, 0);\n\tfor(i = N - 1; i >= 0; i--){\n\t\tint a = ARC[i].first, r = ARC[i].second.first, c = ARC[i].second.second;\n\t\tif(uf.are_same(r, c + H)){\n\t\t\tif(finish[uf.root(r)] == 0){\n\t\t\t\tans += a;\n\t\t\t\tfinish[uf.root(r)] = 1;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tint f1 = finish[uf.root(r)];\n\t\t\tint f2 = finish[uf.root(H + c)];\n\t\t\tif(f1 == 0 && f2 == 0){\n\t\t\t\tans += a;\n\t\t\t\tuf.merge(r, c + H);\n\t\t\t}\n\t\t\telse if(f1 == 1 && f2 == 1){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tans += a;\n\t\t\t\tuf.merge(r, c + H);\n\t\t\t\tfinish[uf.root(r)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\n\nconst int siz=2e5+5;\nvector<vector<pair<int,pair<int,int> > > >adj;\nint parent[siz];\nint sz[siz];\nint vis_ind[siz];\nint vis[siz];\nint mm[siz];\nint find_parent(int ver)\n{\n    if(ver==parent[ver])\n        return ver;\n    return parent[ver]=find_parent(parent[ver]);\n}\n\nbool merge(int a,int b)\n{\n    a=find_parent(a);\n    b=find_parent(b);\n    if(a!=b)\n    {\n        if(sz[a]<sz[b])\n            swap(a,b);\n        sz[a]+=sz[b];\n        parent[b]=a;\n        return true;\n    }\n    return false;\n}\n\nvector<pair<int,pair<int,int> > >temp;\nint cnt=0;\nvoid dfs(int ver)\n{\n    if(vis_ind[ver]==0)\n        cnt++;\n    vis_ind[ver]=1;\n    for(auto i:adj[ver])\n    {\n        if(!vis[i.second.second])\n        {\n            vis[i.second.second]=1;\n            temp.push_back({i.second.first,{i.first,ver}});\n            dfs(i.first);\n        }\n    }\n}\n\nsigned main()\n{\n \nios_base::sync_with_stdio(false);\ncin.tie(NULL);  \ncout.tie(0);   \n \n#ifndef ONLINE_JUDGE\n    if(fopen(\"INPUT.txt\",\"r\"))\n    {\n    freopen (\"INPUT.txt\" , \"r\" , stdin);\n    freopen (\"OUTPUT.txt\" , \"w\" , stdout);\n    }\n#endif      \n\n    int n,h,w;\n    cin>>n>>h>>w;\n    int x,y,z;\n    adj.resize(2e5+5);\n    int lim=1e5;\n    int tot=0;\n    int mn=1e18;\n    \n    for(int i=0;i<n;i++)\n    {\n        cin>>x>>y>>z;\n        tot+=z;\n        mn=min(mn,z);\n        adj[x].push_back({y+lim,{z,i}});\n        adj[y+lim].push_back({x,{z,i}});\n    }    \n\n    for(int i=1;i<=2*lim;i++)\n    {\n        mm[i]=1;\n        parent[i]=i;\n        sz[i]=1;\n    }\n    int ans=0;\n    for(int i=1;i<=2*lim;i++)\n    {\n        if(!vis_ind[i])\n        {\n            temp.clear();\n            cnt=0;\n            dfs(i);\n            sort(temp.begin(),temp.end(),greater<>());\n            int mx=0;\n            for(auto j:temp)\n            {\n                if(mm[find_parent(j.second.first)]+mm[find_parent(j.second.second)]==0)\n                    continue;\n                int z=merge(j.second.first,j.second.second);\n                if(z==0)\n                {\n                    mm[find_parent(j.second.first)]=0;\n                }\n                ans+=j.first;\n            }\n\n            ans+=mx;\n            \n        }\n    }\n    // cout<<tot-19698<<'\\n';\n    cout<<ans;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n#include <valarray>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++)\n//const ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b97f4a7c15 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a % b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nint popcnt(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn __builtin_popcountll(a);\n#elif defined _WIN64\n\treturn _mm_popcnt_u64(a);\n#else\n\treturn _mm_popcnt_u32(a >> 32) + _mm_popcnt_u32(a);\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n#endif\n}\nint BitScanF(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn __builtin_ctzll(a);\n#elif defined _WIN64\n\tunsigned long ret;\n\t_BitScanForward64(&ret, a);\n\treturn a;\n#else\n\tunsigned long ret;\n\tif (!(unsigned long)a) {\n\t\t_BitScanForward(&ret, a);\n\t\tret += 32;\n\t}\n\telse _BitScanForward(&ret, (unsigned long)a);\n\treturn ret;\n#endif\n}\nint BitScanR(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn 63 - __builtin_clzll(a);\n#elif defined _WIN64\n\tunsigned long ret;\n\t_BitScanReverse64(&ret, a);\n\treturn a;\n#else\n\tunsigned long ret;\n\tif (a >> 32) {\n\t\t_BitScanReverse(&ret, a);\n\t\tret += 32;\n\t}\n\telse _BitScanReverse(&ret, (unsigned long)a);\n\treturn ret;\n#endif\n}\ntemplate<class T>\nclass matrix {\npublic:\n\tvector<valarray<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, valarray<T>(e, m == -1 ? n : m)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)ret[i] += obj[i][j] * p.obj[j];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tbool operator==(const matrix&p) {\n\t\tif (s != p.s)return 0;\n\t\tfor (int i = 0; i<s.first; i++)for (int j; j< s.second; j++)if (obj[i][j] != p.obj[i][j])return 0;\n\t\treturn 1;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\tvalarray<T>& operator[](int t) {\n\t\treturn obj[t];\n\t}\n\tvoid gauss() {\n\t\tif (size().first + 1 != size().second)return;\n\t\trep(i, size().first) {\n\t\t\tint p = i;\n\t\t\trepi(j, i, size().first)if (abs(obj[j][i]) > abs(obj[p][i]))p = j;\n\t\t\tswap(obj[i], obj[p]);\n\t\t\tif (abs(obj[i][i]) < 1e-8)return;//contniue;\n\t\t\trepi(j, i + 1, size().second)obj[i][j] /= obj[i][i];\n\t\t\trep(j, size().first) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\trepi(k, i + 1, size().second)obj[j][k] -= obj[j][i] * obj[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\ntemplate<class T>\nstd::pair<matrix<T>, vector<int>> LU_decomposition(matrix<T> a) {\n\tif (a.size().first != a.size().second)throw runtime_error(\"matrix error\");\n\tstd::vector<int> pi(a.size().first);\n\tstd::iota(ALL(pi), 0);\n\tvalarray<T> tmp(a.size().first);\n\tfor (int i = 0; i < a.size().first; i++) {\n\t\t//int pivot = i;\n\t\t//T max = abs(a[i][i]);\n\t\t//for (int j = i + 1; j < a.size().first; j++) {\n\t\t//\tif (max < abs(a[j][i])) {\n\t\t//\t\tmax = abs(a[j][i]);\n\t\t//\t\tpivot = j;\n\t\t//\t}\n\t\t//}\n\t\t//std::swap(i, pivot);\n\t\t//pi.push_back(pivot);\n\t\tstd::slice slice(i + 1, a.size().first - i - 1, 1);\n\t\tfor (int j = i + 1; j < a.size().first; j++) {\n\t\t\ttmp[slice] = a[i][slice];\n\t\t\ttmp *= a[j][i] / a[i][i];\n\t\t\ta[j][slice] -= tmp[slice];\n\t\t\ta[j][i] = a[j][i] / a[i][i];\n\t\t}\n\t}\n\treturn std::make_pair(std::move(a), std::move(pi));\n}\ntemplate<class T>\nmatrix<T>LU_solve(pair<matrix<T>, std::vector<int>> a, matrix<T> b) {\n\tauto pi = std::move(a.second);\n\tauto A = std::move(a.first);\n\tif (A.size().first != A.size().second || A.size().first != b.size().first)throw runtime_error(\"matrix error\");\n\tfor (int i = 0; i < A.size().first; i++) {\n\t\tstd::swap(b[i], b[pi[i]]);\n\t}\n\tfor (int i = 0; i < A.size().first; i++) {\n\t\tfor (int j = 0; j < i; j++)b[i] -= A[i][j] * b[j];\n\t}\n\tfor (int i = A.size().first - 1; i >= 0; i--) {\n\t\tfor (int j = i + 1; j < A.size().first; j++)b[i] -= A[i][j] * b[j];\n\t\tb[i] /= A[i][i];\n\t}\n\treturn b;\n}\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned long long exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (res.obj[0].size() > 100) {\n\t\t\tint a = 0;\n\t\t}\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned long long exp, ll m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (res.obj[0].size() > 100) {\n\t\t\tint a = 0;\n\t\t}\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tvoid propagate(int a, int b, int k, int l, int r, int p) {\n\t\tif (r <= a || b <= l)return;\n\t\tif (a <= l && r <= b) {\n\t\t\tobj[k].second += p;\n\t\t\t(obj[k].first *= pow(2, p, (ll)1e9 + 7)) %= (ll)(1e9 + 7);\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tif (obj[k].second) {\n\t\t\t\t(obj[k * 2 + 1].first *= pow(2, obj[k].second, (ll)1e9 + 7)) %= (ll)(1e9 + 7);\n\t\t\t\t(obj[k * 2 + 2].first *= pow(2, obj[k].second, (ll)1e9 + 7)) %= (ll)(1e9 + 7);\n\t\t\t\tobj[k * 2 + 1].second += obj[k].second;\n\t\t\t\tobj[k * 2 + 2].second += obj[k].second;\n\t\t\t}\n\t\t\tpropagate(a, b, k * 2 + 1, l, (l + r) / 2, p), propagate(a, b, k * 2 + 2, (l + r) / 2, r, p);\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tT query(int a, int b) {//[a,b)\n\t\t//propagate(a, b, 0);\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid propagate(int a, int b, int p = 1) {//[a,b)\n\t\treturn propagate(a, b, 0, 0, offset + 1, p);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, const T &a) {\n\t\t//propagate(k, k + 1, 0);\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//多次元BITはループをネストすればいいらしい。\n\tvector<T> bit;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= bit.size()) {\n\t\t\tbit[i - 1] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i - 1];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT<T> b0, b1;\n\tint n;\n\trangeadd(int n) :b0(n), b1(n), n(n) {}\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\nclass Flow {\npublic:\n\tint V;\n\tstruct edge { int to, cap, rev, cost, add; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint res = 0;\n\tint flow = 0;\n\tint s, t;\n\tint max_flow(int s, int t, int fmax = numeric_limits<int>::max()) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, fmax))>0) {\n\t\t\t\tflow += f;\n\t\t\t\tfmax -= f;\n\t\t\t}\n\t\t\tif (fmax == 0)return flow;\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tFlow(int size, int s, int t) :G(size + 1), V(size + 1), s(s), t(t) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost,1 });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost,0 });\n\t}\n\tvoid remove_edge_max(int from, int to, int cap, int cost = 0) {\n\t\tfor (auto &x : G[from]) {\n\t\t\tif (!x.add || x.to != to || x.cap + G[to][x.rev].cap != cap || x.cost != cost)continue;\n\t\t\tint prev = flow;\n\t\t\tint cap = G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tcap -= max_flow(from, to, cap) - prev;\n\t\t\tmax_flow(t, to, cap);\n\t\t\tmax_flow(from, s, cap);\n\t\t\tflow = prev - cap;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvoid remove_edge_cost(int from, int to, int cap, int cost = 0) {\n\t\tfor (auto &x : G[from]) {\n\t\t\tif (!x.add || x.to != to || x.cap + G[to][x.rev].cap != cap || x.cost != cost)continue;\n\t\t\tcost += G[to][x.rev].cap*G[to][x.rev].cost;\n\t\t\tint cap = G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tmin_cost_flow(from, to, cap);\n\t\t\tbreak;\n\t\t}\n\t}\n\tint max_flow() {\n\t\treturn max_flow(s, t);\n\t}\n\tint min_cost_flow(int f) {\n\t\treturn min_cost_flow(s, t, f);\n\t}\n};\nll extgcd(ll a, ll b, ll&x, ll&y) {\n\tint d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a%b, y, x);\n\t\ty -= (a / b)*x;\n\t}\n\telse {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\nll mod_inv(ll a, ll m) {\n\tll x, y;\n\textgcd(a, m, x, y);\n\treturn(m + x % m) % m;\n}\npll linear_congruence(const vector<ll>& A, const vll& B, const vll&M) {\n\tll x = 0, m = 1;\n\tfor (int i = 0; i < A.size(); i++) {\n\t\tll a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n\t\tif (b%d != 0)return make_pair(0, -1);\n\t\tll t = b / d * mod_inv(a / d, M[i] / d) % (M[i] / d);\n\t\t//if (x + m * t < 0)return pll(x%m, m);\n\t\tx = x + m * t;\n\t\tm *= M[i] / d;\n\t}\n\treturn make_pair(x%m, m);\n}\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//円の接線?\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//面積??\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\nstruct unionfind_ {\n\tvector<int> par, rank, size_,a;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind_(int n) :par(n), rank(n), size_(n, 1),a(n) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tcmin(a[x],a[y]);\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T>\nclass lazysegtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse {\n\t\t\tT ret(e);\n\t\t\tobj[k].propagate(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t\treturn ret.merge(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t\t}\n\t}\n\tvoid propagateall(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l || l == r - 1)return;\n\t\tobj[k].propagate(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\tpropagateall(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tpropagateall(a, b, k * 2 + 2, (l + r) / 2, r);\n\t}\n\ttemplate<class Param>\n\tT update(int a, int b, int k, int l, int r, const Param& param) {\n\t\tif (r <= a || b <= l)return obj[k];\n\t\tif (a <= l && r <= b) {\n\t\t\tobj[k].update(param);\n\t\t\treturn obj[k];\n\t\t}\n\t\tobj[k].propagate(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\treturn obj[k].merge(update(a, b, k * 2 + 1, l, (l + r) / 2, param), update(a, b, k * 2 + 2, (l + r) / 2, r, param));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\ttemplate<class Param>\n\tvoid update(int a, int b, Param&& param) {\n\t\tupdate(a, b, 0, 0, offset + 1, param);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i].merge(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid propagateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tupdateall(l, r, 0, 0, offset + 1);\n\t}\n\t/*\n\tvoid update(int k, T &a) {\n\tk += offset;\n\tobj[k] = a;\n\twhile (k) {\n\tk = k - 1 >> 1;\n\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t}\n\t}*/\n\tlazysegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\tlazysegtree(vector<T> &vec, T e) :obj(bufsize(vec.size()), e), e(e) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\nclass lazyRMQ_t {\n\tll min, set;\npublic:\n\tll getmin() {\n\t\treturn min;\n\t}\n\tlazyRMQ_t() {\n\t\tmin = numeric_limits<ll>::max() / 2; set = min;\n\t}\n\tlazyRMQ_t(ll a, ll b = 0) {\n\t\tmin = a; set = b;\n\t}\n\tvoid propagate(lazyRMQ_t &a, lazyRMQ_t &b) {\n\t\tcmin(a.min, set);\n\t\tcmin(b.min, set);\n\t\tcmin(a.set, set);\n\t\tcmin(b.set, set);\n\t\tset = numeric_limits<ll>::max() / 2;\n\t}\n\tlazyRMQ_t& merge(const lazyRMQ_t &a, const lazyRMQ_t &b) {\n\t\tmin = std::min(a.min, b.min);\n\t\tset = numeric_limits<ll>::max() / 2;\n\t\treturn *this;\n\t}\n\tlazyRMQ_t& update(ll k) {\n\t\tcmin(min, k);\n\t\tcmin(set, k);\n\t\treturn *this;\n\t}\n};\nint check(array<int, 4> &a, array<int, 4> &b) {\n\tif (a == b)return 0;\n\tif (a[0] < b[0] && a[1] < b[1])return b[2];\n\tif (b[0] < a[0] && b[1] < a[1])return a[2];\n\treturn -1;\n}\nint main() {\n\tint n;\n\tint h, w;\n\tcin >> n >> h >> w;\n\tva<int, 3> a(n);\n\trep(i, n)rep(j, 3)cin >> a[i][j];\n\trep(i, n)rep(j, 2)a[i][j]--;\n\tFlow f(n + h + w + 2, n + h + w, n + h + w + 1);\n\trep(i, n) {\n\t\tf.add_edge(n + h + w, i, 1, -a[i][2]);\n\t\tf.add_edge(i, n + a[i][0], 1);\n\t\tf.add_edge(i, n + h + a[i][1], 1);\n\t}\n\trep(i, h)f.add_edge(n + i, n + h + w + 1, 1);\n\trep(i, w)f.add_edge(n + h + i, n + h + w + 1, 1);\n\tcout << -f.min_cost_flow(h + w) << endl;\n}\n//template<class T, class map = std::unordered_map<T,unique_ptr<node>>>\n/*class AhoCorasick {\nstruct node {\nmap<char,unique_ptr<node>> next;\nnode* fail = nullptr, *match_list = nullptr;\nstd::vector<int> match;\n}root;\nint pattern;\n//template<class string>\nAhoCorasick(std::vector<string> &vs) :pattern(vs.size()) {\nroot.fail = &root;\nfor (int i = 0; i < vs.size(); i++) {\nnode* now = &root;\nfor (auto c : vs[i]) {\nif (!now->next[c])now->next[c]=make_unique<node>();\nnow = now->next[c].get();\n}\nnow->match.push_back(i);\n}\nstd::queue<node*> que;\nque.push(&root);\nwhile (!que.empty()) {\nauto now = que.front();\nque.pop();\nfor (auto &next : now->next) {\nif (!next.second)continue;\nif (now->fail->next.count(next.first))next.second->fail = now->fail->next[next.first].get();\nelse next.second->fail = now->fail->fail;\n//next.second->match.insert(next.second->match.end(), next.second->fail->match.begin(), next.second->fail->match.end());\nif (next.second->fail->match.empty())next.second->match_list = next.second->fail->match_list;\nelse next.second->match_list = next.second->fail;\nque.push(next.second.get());\n}\n}\n}\nauto match_n(string str) {\nvector<int> num(pattern);\n\n}\nauto match_list(string str) {\nvector<pair<int, int>> list;\nauto now = &root;\nfor (int i = 0; i < str.size(); i++) {\nif (now->next.count(str[i]))now = now->next[str[i]].get();\nelse now = now->fail;\nauto match = now->match_list;\ndo {\nmatch\n}\n}\n}\n};*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define all(v) (v).begin(), (v).end()\n#define sortv(v) sort(all(v))\n#define uniqv(v) (v).erase(unique(all(v)), (v).end())\n#define pb push_back\n#define FI first\n#define SE second\n#define lb lower_bound\n#define ub upper_bound\n#define mp make_pair\n#define test 1\n#define TEST if(test)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\nconst int MOD = 1000000007; // 998244353\nconst int INF = 2e9;\nconst ll INFLL = 1e18;\nconst int MAX_N = 100000;\n\nint N, H, W;\n\nint X[MAX_N+1], Y[MAX_N+1];\n\nstruct S{\n\tint x, y, d;\n\tbool operator <(const S &a)const{\n\t\treturn d<a.d;\n\t}\n};\nvector<S> v;\n\nll ans;\n\nvector<int> gp[MAX_N*2+1];\nbool chk[MAX_N+1];\n\nvoid make(int x, int y){\n\tchk[x] = true;\n\tfor(int i : gp[x]){\n\t\tif(i!=y){\n\t\t\tmake(i, x);\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\tcin>>N>>H>>W;\n\tfor(int i=1; i<=N; i++){\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tv.pb((S){a, b+H, c});\n\t}\n\tsort(v.begin(), v.end());\n\twhile(!v.empty()){\n\t\tS now = v.back(); v.pop_back();\n\t\tif(gp[now.x].size()<=1 && gp[now.y].size()<=1){\n\t\t\tgp[now.x].pb(now.y);\n\t\t\tif(gp[now.x].size()==2)\tchk[now.x] = true;\n\t\t\tgp[now.y].pb(now.x);\n\t\t\tif(gp[now.y].size()==2)\tchk[now.y] = true;\n\t\t\tans+=(ll)now.d;\n\t\t}\n\t\telse{\n\t\t\tif(chk[now.x] && (!chk[now.y] && gp[now.y].size()<=1)){\n\t\t\t\tmake(now.y, 0);\n\t\t\t\tans+=(ll)now.d;\n\t\t\t}else if((gp[now.x].size()<=1 && !chk[now.x]) && chk[now.y]){\n\t\t\t\tmake(now.x, 0);\n\t\t\t\tans+=(ll)now.d;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n\n  int n, h, w, r, c, a;\n  vector<pair<int, int>> col[100100], row[100100];\n  cin >> n >> h >> w;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> r >> c >> a;\n    col[c].push_back({a, r});\n    row[r].push_back({a, c});\n  }\n\n  int maxRow[100100] = {0}, maxCol[100100] = {0};\n  long long ansC = 0, ansR = 0;\n  for (int i = 1; i <= w; i++)\n    if (!col[i].empty())\n    {\n      sort(col[i].begin(), col[i].end(), greater<pair<int, int>>());\n      ansR += col[i][0].first;\n      for (int j = 1; j < col[i].size(); j++)\n        maxRow[col[i][j].second] = max(maxRow[col[i][j].second], col[i][j].first);\n    }\n  for (int i = 1; i <= h; i++)\n    if (!row[i].empty())\n    {\n      sort(row[i].begin(), row[i].end(), greater<pair<int, int>>());\n      ansC += row[i][0].first;\n      for (int j = 1; j < row[i].size(); j++)\n        maxCol[row[i][j].second] = max(maxCol[row[i][j].second], row[i][j].first);\n    }\n\n  for (int i = 1; i <= h; i++)\n    ansR += maxRow[i];\n  for (int i = 1; i <= w; i++)\n    ansC += maxCol[i];\n\n  cout << max(ansR, ansC) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\nclass UnionFindTree{\n  struct base_node{\n    int parent;\n    int rank;\n    int size;\n  };\n  \n  vector<base_node> node;\n public:\n  UnionFindTree(int n){\n    node.resize(n);\n    for(int i=0; i<n; i++){\n      node[i].parent=i;\n      node[i].rank=0;\n      node[i].size=1;\n    }\n  }\n\n  int find(int x){  //return root node of x\n    if(node[x].parent == x) return x;\n    else{\n      return node[x].parent = find(node[x].parent);\n    }\n  }\n  \n  bool same(int x, int y){\n    return find(x) == find(y);\n  }\n\n  int size(int at){\n    return node[find(at)].size;\n  }\n\n  void unite(int x, int y){\n    x = find(node[x].parent);\n    y = find(node[y].parent);\n\n    if(x==y) return;\n\n    if(node[x].rank < node[y].rank){\n      node[x].parent = y;\n      node[y].size += node[x].size;\n    }else if(node[x].rank > node[y].rank){\n      node[y].parent = x;\n      node[x].size += node[y].size;\n    }else{\n      node[x].rank++;\n      unite(x,y);\n    }\n  }\n};\n\n\nint main(){\n  int n,h,w;\n  cin >> n,h,w;\n\n  vector<int> r(n),c(n),a(n);\n  for(int i=0; i<n; i++){\n    cin >> r[i],c[i],a[i];\n    r[i]--;\n    c[i]--;\n  }\n\n  UnionFindTree uft(h+w);\n  vector<int> num_e(h+w);\n\n  vector<int> e(n);\n  iota(e.begin(), e.end(), 0);\n  sort(e.begin(), e.end(), [&](int i, int j){\n    return a[i] > a[j];\n  });\n\n  long long ans = 0;\n  for(auto i: e){\n    int r0 = uft.find(r[i]);\n    int r1 = uft.find(c[i]+h);\n\n    int v_cnt = uft.size(r0);\n    int e_cnt = num_e[r0] + 1;\n    if(r0 != r1){\n      v_cnt += uft.size(r1);\n      e_cnt += num_e[r1];\n    }\n\n    if(v_cnt < e_cnt) continue;\n    ans += a[i];\n    uft.unite(r0, r1);\n    int r = uft.find(r0);\n    num_e[r] = e_cnt;\n  }\n\n  println(ans);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = (int) (1e9 + 7);\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n\n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n\ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n\nstruct UnionFind {\n  vector< int > data;\n\n  UnionFind(int sz) {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k) {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k) {\n    return (-data[find(k)]);\n  }\n};\n\nint main() {\n  int N, H, W;\n  cin >> N;\n  cin >> H >> W;\n  vector< int > A(N), B(N), C(N);\n\n  vector< int > ord(N);\n  for(int i = 0; i < N; i++) {\n    cin >> A[i] >> B[i] >> C[i];\n    --A[i], --B[i];\n    ord[i] = i;\n  }\n  sort(begin(ord), end(ord), [&](int a, int b) {\n    return C[a] > C[b];\n  });\n  UnionFind uf(H + W);\n  int64 ret = 0;\n  vector< int > sz(H + W, 1);\n\n  for(int i : ord) {\n    int x = sz[uf.find(A[i])];\n    int y = sz[uf.find(B[i] + H)];\n    if(uf.unite(B[i] + H, A[i])) {\n      sz[uf.find(A[i])] = x + y;\n    }\n    if(sz[uf.find(A[i])]) {\n      --sz[uf.find(A[i])];\n      ret += C[i];\n    }\n  }\n  cout << ret << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define in(x,y,h,w) x >= 0 && x < h && y >= 0 && y < w\n\n#define int long long\n//typedef    long long          ll;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct edge{ int to,cap,cost,rev; };\n\nvector<edge> G[300010];\nint h[300010],dist[300010],prevv[300010],preve[300010];\n\nvoid add_edge(int from,int to,int cap,int cost){\n\tG[from].push_back({to,cap,cost,(int)G[to].size()});\n\tG[to].push_back({from,0,-cost,(int)G[from].size() - 1});\n}\n\nint min_cost_flow(int n,int s,int t,int f){\n\tint res = 0;\n\tfill(h,h + n,0);\n\twhile(f > 0){\n\t\tpriority_queue<P,vector<P>,greater<P>> que;\n\t\tfill(dist,dist + n,INF);\n\t\tdist[s] = 0;\n\t\tque.emplace(0,s);\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top();que.pop();\n\t\t\tint v = p.second;\n\t\t\tif(dist[v] < p.first) continue;\n\t\t\tfor(int i = 0;i < G[v].size();i++){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.emplace(dist[e.to],e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == INF) return res;\n\t\tfor(int i = 0;i < n;i++) h[i] += dist[i];\n\t\tint d = f;\n\t\tfor(int i = t;i != s;i = prevv[i]){\n\t\t\td = min(d,G[prevv[i]][preve[i]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor(int i = t;i != s;i = prevv[i]){\n\t\t\tedge &e = G[prevv[i]][preve[i]];\n\t\t\te.cap -= d;\n\t\t\tG[i][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nsigned main(){\n\tint n,h,w;\n\tcin >> n >> h >> w;\n\tfor(int i = 0;i < n;i++){\n\t\tint r,c,a;\n\t\tcin >> r >> c >> a; r--;c--;\n\t\tadd_edge(r,i + h + w,1,100000 - a);\n\t\tadd_edge(c + h,i + h + w,1,100000 - a);\n\t}\n\tfor(int i = 0;i < h + w;i++) add_edge(h + w + n,i,1,0);\n\tfor(int i = 0;i < n;i++) add_edge(i + h + w,h + w + n + 1,1,0);\n\tcout << (h + w) * 100000 - min_cost_flow(h + w + n + 2,h + w + n,h + w + n + 1,h + w) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cstdio>\n#include<iostream>\n#include<vector>\n#define debug(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\ninline char nc() {\n\treturn getchar();\n\tstatic char buf[100000],*l=buf,*r=buf;\n\treturn l==r&&(r=(l=buf)+fread(buf,1,100000,stdin),l==r)?EOF:*l++;\n} \ntemplate<class T> void read(T &x) {\n\tx=0; int f=1,ch=nc();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=nc();}\n\twhile(ch>='0'&&ch<='9'){x=x*10-'0'+ch;ch=nc();}\n\tx*=f;\n}\ntypedef long long ll;\nconst int MAXH=1e5+50;\nconst int MAXW=1e5+50;\nconst int maxnode=MAXH+MAXW;\nint N,H,W; \nstruct edge {\n\tint u,v,w;\n\tedge(int u=0,int v=0,int w=0):u(u),v(v),w(w){}\n\tinline bool operator <(const edge &other) {\n\t\treturn w>other.w;\n\t}\n};\nvector<edge> E;\nnamespace us {\n\tint fa[maxnode];\n\tbool mark[maxnode];\n\tvoid init(int n) {\n\t\tfor(int i=1;i<=n;++i) {\n\t\t\tfa[i]=i,mark[i]=0;\n\t\t}\n\t} \n\tint find(int a) {return a==fa[a]?a:fa[a]=find(fa[a]);}\n\tbool merge(int u,int v) {\n\t\tu=find(u),v=find(v);\n\t\tif(u==v) {\n\t\t\tif(mark[u]) return false;\n\t\t\tmark[u]=1; \n\t\t\treturn true;\n\t\t}\n\t\tif(mark[u]&&mark[v]) return false;\n\t\tfa[u]=v;\n\t\tmark[v]|=mark[u];\n\t\treturn true;\n\t}\n}\nll sol() {\n\tsort(E.begin(),E.end());\n\tll an=0;\n\tus::init(H+W);\n\tfor(unsigned int i=0;i<E.size();++i) {\n\t\tif(us::merge(E[i].u,E[i].v)) {\n\t\t\tan+=E[i].w;\n\t\t}\n\t}\n\treturn an;\n}\nint main() {\n\tread(N),read(H),read(W);\n\tfor(int i=1;i<=N;++i) {\n\t\tint R,C,A; read(R),read(C),read(A);\n\t\tE.push_back(edge(R,H+C,A));\n\t}\n\tprintf(\"%lld\\n\",sol());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_genius = 0; ngtkana_is_genius < int(n); ngtkana_is_genius++)\n#define rep(i, begin, end) for(int i = int(begin); i < int(end); i++)\n#define lint long long\nauto cmn = [](auto& a, auto b){if (a > b) {a = b; return true;} return false;};\nauto cmx = [](auto& a, auto b){if (a < b) {a = b; return true;} return false;};\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail){\n  std::cerr << \" \" << head;\n  debug_impl(tail...);\n}\n#define debug(...) std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n  debug_impl(__VA_ARGS__);\\\n  std::cerr << std::noboolalpha;\n\nclass quick_find\n{\npublic:\n  using size_type          = int;\n  using node_type          = int;\n  using group_type         = int;\n  using group_array_type   = std::vector<node_type>;\n  using members_array_type = std::vector<std::vector<node_type>>;\n\nprivate:\n  size_type          n;\n  group_array_type   leader;\n  members_array_type members;\n\npublic:\n  quick_find (size_type n) : n(n), leader(n), members(n)\n  {\n    for (int i = 0; i < n; i++) {\n      leader.at(i) = i;\n    }\n    for (int i = 0; i < n; i++) {\n      members.at(i) = {i};\n    }\n  }\n\n  auto       collect ()             const {return leader;}\n\n  bool       is_root (int x)        const {return find(x) == x;}\n\n  size_type  size    (int x)        const {return members.at(x).size();}\n\n  bool       same    (int x, int y) const {return find(x) == find(y);}\n\n  group_type find    (int x)        const {return leader.at(x);}\n\n  // Returns `true` if x and y are newly connected.\n  bool unite   (int x, int y) {\n    if ((x = find(x)) == (y = find(y))) return false;\n    if (size(x) > size(y)) std::swap(x, y);\n    for (auto child : members.at(x))\n    {\n      leader.at(child) = y;\n      members.at(y).push_back(child);\n    }\n    std::decay_t<decltype(members.at(x))>{}.swap(members.at(x));\n    return true;\n  }\n};\n\ntemplate <typename T>\nstd::istream& operator>> (std::istream& is, std::vector<T>& v)\n{\n  for (auto & x : v) is >> x;\n  return is;\n}\n\ntemplate <typename T>\nstd::ostream& operator<< (std::ostream& os, const std::vector<T>& v)\n{\n  auto n = v.size();\n  os << \"{\";\n  for (size_t i = 0; i < n; i++)\n    os << (i > 0 ? \",\" : \"\") << v[i];\n  return os << \"}\";\n}\n\nint main()\n{\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n, h, w;\n  std::cin >> n >> h >> w;\n  auto queries = std::vector<std::tuple<int, int, int>>(n);\n  rep(i, 0, n)\n  {\n    int x, y, a;\n    std::cin >> x >> y >> a;\n    x--, y--, y += h;\n    queries.at(i) = std::make_tuple(a, x, y);\n  }\n  auto qf = quick_find(h + w + 1);\n  std::sort(queries.begin(), queries.end());\n  std::reverse(queries.begin(), queries.end());\n  auto base = h + w;\n  lint ret = 0;\n  for (auto tuple : queries)\n  {\n    int a, x, y;\n    std::tie(a, x, y) = tuple;\n    if (!qf.same(x, y) && (!qf.same(base, x) || !qf.same(base, y)))\n    {\n      qf.unite(x, y);\n      ret += a;\n    }\n    else if (qf.same(x, y) && !qf.same(base, x))\n    {\n      assert(!qf.same(base, y));\n      qf.unite(base, x);\n      ret += a;\n    }\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nstruct UnionFind {\n    vector<int> A;\n    UnionFind(int n) : A(n, -1) {}\n    int find(int x) {\n        if (A[x] < 0) return x;\n        return A[x] = find(A[x]);\n    }\n    void unite(int x, int y) {\n        x = find(x), y = find(y);\n        if (x == y) return;\n        if (A[x] > A[y]) swap(x, y);\n        A[x] += A[y];\n        A[y] = x;\n    }\n};\nint main() {\n    int N, H, W; cin >> N >> H >> W;\n    vector<tuple<int, int, int>> A;\n    A.reserve(N);\n    for (int i = 0; i < N; i++) {\n        int r, c, a; cin >> r >> c >> a; r--, c--;\n        A.emplace_back(a, r, c);\n    }\n    sort(rbegin(A), rend(A));\n    UnionFind uf(H + W);\n    vector<int> score(H + W, 1);\n    Int ans = 0;\n    for (int i = 0; i < N; i++) {\n        int a, r, c; tie(a, r, c) = A[i];\n        int rid = uf.find(r);\n        int cid = uf.find(H + c);\n        if (rid == cid) {\n            if (score[rid] > 0) {\n                score[rid]--;\n                ans += a;\n            }\n        } else {\n            if (score[rid] + score[cid] > 0) {\n                uf.unite(rid, cid);\n                score[uf.find(rid)] = score[rid] + score[cid] - 1;\n                ans += a;\n            }\n        }\n    }\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nstruct UnionFind {\n    int N;\n    vector<int> node;\n\n    UnionFind(){}\n    UnionFind(int N) : N(N), node(N,-1) {}\n\n    void init(int x) {\n        node.assign(x,-1);\n        N = x;\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (node[x] > node[y]) swap(x,y);\n        node[x] += node[y];\n        node[y] = x;\n        N--;\n        return true; \n    }\n\n    bool same(int x, int y) {return root(x) == root(y);}\n\n    int root(int x) {\n        if (node[x] < 0) return x;\n        return node[x] = root(node[x]);\n    }\n\n    int size(int x) {return -node[root(x)];}\n\n    int count() const {return N;}\n};\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N,H,W; cin >> N >> H >> W;\n    vector<int> R(N),C(N),A(N);\n    rep(i,N) {\n        cin >> R[i] >> C[i] >> A[i];\n        --R[i];\n        --C[i];\n    }\n\n    vector<int> idx(N);\n    iota(all(idx),0);\n    sort(all(idx),[&](int i, int j){return A[i] > A[j];});\n    UnionFind uf(H+W);\n    vector<int> edge(H+W);\n    ll ans = 0;\n    rep(i,N) {\n        int u = idx[i];\n        if (uf.same(R[u],H+C[u])) {\n            int r = uf.root(R[u]);\n            if (edge[r] < uf.size(r)) {\n                ans += A[u];\n                edge[r]++;\n            }\n        } else {\n            int r = uf.root(R[u]);\n            int c = uf.root(H+C[u]);\n            if (edge[r] == uf.size(r) and edge[c] == uf.size(c)) continue;\n            uf.merge(r,c);\n            ans += A[u];\n            if (uf.root(r)==r) {\n                edge[r] += edge[c]+1;\n            } else {\n                edge[c] += edge[r]+1;\n            }\n        }\n    }\n\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define fi first\n#define se second\n#define L(i,u) for (int i=head[u]; i!=0; i=nxt[i])\n#define rep(i,a,b) for (register int i=a; i<=b; i++)\n#define per(i,a,b) for (register int i=a; i>=b; i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 300005, M = 600005, inf = 0x3f3f3f3f;\nint n,h,w,f[N],sz[N];\nint find(int x){return f[x]==x?x:f[x]=find(f[x]);}\nstruct node{\n\tint r,c,w;\n}s[N];\nbool cmp(node a, node b){return a.w>b.w;}\nint main() {\n\tread(n);read(h);read(w);\n\trep(i,1,n){\n\t\tread(s[i].r);read(s[i].c);read(s[i].w);\n\t}\n\tsort(s+1,s+n+1,cmp);ll res=0;\n\trep(i,1,2e5)f[i]=i;\n\trep(i,1,n){\n\t\tint u=find(s[i].r),v=find(1e5+s[i].c);\n\t\tif(u!=v){\n\t\t\tif(sz[u]+sz[v]<=1)\n\t\t\t\tres+=s[i].w,f[u]=v,sz[v]+=sz[u];\n\t\t}\n\t\telse{\n\t\t\tif(sz[u]+1<=1)res+=s[i].w,sz[u]++;\n\t\t}\n\t}\n\tcout<<res;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct uf{\n\tint par[200005],ran[200005],sum[200005];\n\tvoid init(){\n\t\trep(i,200005) { par[i] = i,ran[i] = 0,sum[i] = 0; }\n\t}\n\tint find(int x){\n\t\tif(x == par[x]) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x); y = find(y);\n\t\tif(x == y) return;\n\t\tif(ran[x] < ran[y]){\n\t\t\tpar[x] = y;\n\t\t\tsum[y] += sum[x];\n\t\t}\n\t\telse{\n\t\t\tpar[y] = x;\n\t\t\tsum[x] += sum[y];\n\t\t}\n\t}\n}kaede;\nint n,h,w;\nvector<P1>vec;\nint main(){\n\tscanf(\"%d%d%d\",&n,&h,&w);\n\tfor(int i=1;i<=n;i++){\n\t\tint r,c,a; scanf(\"%d%d%d\",&r,&c,&a);\n\t\tvec.pb(mp(-a,mp(r,100000+c)));\n\t}\n\tSORT(vec);\n\tll ans = 0;\n\tkaede.init();\n\tfor(int i=0;i<vec.size();i++){\n\t\tint x = vec[i].sc.fi , y = vec[i].sc.sc;\n\t\tif(kaede.find(x) != kaede.find(y)){\n\t\t\tkaede.unite(x,y);\n\t\t\tans -= vec[i].fi;\n\t\t}\n\t\telse if(kaede.sum[kaede.find(x)] == 0){\n\t\t\tkaede.sum[kaede.find(x)]++;\n\t\t\tans -= vec[i].fi;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <vector>\n#include <utility>\n#include <string>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <numeric>\n#include <tuple>\n\ntemplate <class Tp>\nstruct edge {\n  size_t dst;\n  Tp cap, cost;\n  size_t rev;\n  edge(size_t dst, Tp cap, Tp cost, size_t rev):\n    dst(dst), cap(cap), cost(cost), rev(rev)\n  {}\n};\n\ntemplate <class Tp>\nstruct graph: public std::vector<std::vector<edge<Tp>>> {\n  graph(size_t n): std::vector<std::vector<edge<Tp>>>(n) {}\n\n  void connect_to(size_t src, size_t dst, Tp cost) {\n    (*this)[src].emplace_back(dst, 1, cost, (*this)[dst].size());\n    (*this)[dst].emplace_back(src, 0, -cost, (*this)[src].size()-1);\n  }\n};\n\ntemplate <class Tp>\nTp inf() { return 1 << 29; }\n\ntemplate <class Tp>\nTp mincost_flow(graph<Tp>& g, size_t s, size_t t, Tp f) {\n  Tp res = 0;\n  Tp max = inf<Tp>();\n  while (f > 0) {\n    std::vector<Tp> dist(g.size(), inf<Tp>());\n    std::vector<size_t> pv(g.size()), pe(g.size());\n    dist[s] = 0;\n    bool updated = true;\n    while (updated) {\n      updated = false;\n      for (size_t v = 0; v < g.size(); ++v) {\n        if (dist[v] == max) continue;\n\n        for (size_t i = 0; i < g[v].size(); ++i) {\n          edge<Tp>& e = g[v][i];\n          if (e.cap > 0 && dist[e.dst] > dist[v] + e.cost) {\n            dist[e.dst] = dist[v] + e.cost;\n            pv[e.dst] = v;\n            pe[e.dst] = i;\n            updated = true;\n          }\n        }\n      }\n    }\n\n    if (dist[t] == max) return -1;\n    Tp d = f;\n    for (size_t v = t; v != s; v = pv[v])\n      d = std::min(d, g[pv[v]][pe[v]].cap);\n\n    f -= d;\n    res += d * dist[t];\n    for (size_t v = t; v != s; v = pv[v]) {\n      edge<Tp>& e = g[pv[v]][pe[v]];\n      e.cap -= d;\n      g[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main() {\n  size_t N, H, W;\n  scanf(\"%zu %zu %zu\", &N, &H, &W);\n\n  graph<intmax_t> g(2*N+H+W+2);\n  size_t M = g.size()-1;\n  // for (size_t i = 1; i <= H; ++i) g.connect_to(0, i, 0);\n  // for (size_t i = 1; i <= W; ++i) g.connect_to(0, H+i, 0);\n\n  std::set<size_t> hs, ws;\n  for (size_t i = 0; i < N; ++i) {\n    size_t R, C;\n    intmax_t A;\n    scanf(\"%zu %zu %jd\", &R, &C, &A);\n    C += H;\n    if (hs.insert(R).second) {\n      g.connect_to(0, R, 0);\n    }\n    if (ws.insert(C).second) {\n      g.connect_to(0, C, 0);\n    }\n\n    size_t si = H+W+1+2*i;\n    size_t sj = si+1;\n    g.connect_to(R, si, 0);\n    g.connect_to(C, si, 0);\n    g.connect_to(si, sj, -A);\n    g.connect_to(sj, M, 0);\n  }\n\n  printf(\"%jd\\n\", -mincost_flow(g, 0, M, intmax_t((hs.size()+ws.size()))));\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n#include <limits>\n\nusing namespace std;\n\nstruct PCSZ {\n  // assumption: every root node points itself.\n  struct node_t {\n    int parent;\n    int size;\n    int aux;\n    node_t() : size(1), aux(0) {}\n  };\n  vector<node_t> nodes;\n\n  PCSZ() { }\n  PCSZ(int size) : nodes(size) {\n    for (int i = 0; i < size; i++) {\n      nodes[i].parent = i;\n    }\n  }\n\n  // find root node\n  int find(int index) {\n    int root = index;\n    while (root != nodes[root].parent) {\n      root = nodes[root].parent;\n    }\n    while (root != nodes[index].parent) {\n      int next = nodes[index].parent;\n      nodes[index].parent = root;\n      index = next;\n    }\n    return root;\n  }\n\n  // true if merge was successful\n  bool merge(int first, int second) {\n    int r1 = find(first);\n    int r2 = find(second);\n    if (r1 == r2) {\n      return false;\n    }\n    if (nodes[r1].size < nodes[r2].size) {\n      // careful, first and second not swapped\n      swap(r1, r2);\n    }\n    nodes[r1].size += nodes[r2].size;\n    nodes[r1].aux += nodes[r2].aux;\n    nodes[r2].parent = r1;\n    return true;\n  }\n\n  int group_size(int index) {\n    return nodes[find(index)].size;\n  }\n  int aux(int index) {\n    return nodes[find(index)].aux;\n  }\n};\n\nint main() {\n  int n, h, w;\n  scanf(\"%d%d%d\", &n, &h, &w);\n  vector<char> used(n);\n  vector<tuple<int, int, int>> dat(n);\n  for (int i = 0; i < n; i++) {\n    int r, c, w;\n    scanf(\"%d%d%d\", &r, &c, &w);\n    r--, c--;\n    dat[i] = make_tuple(w, r, c);\n  }\n  sort(dat.begin(), dat.end(), greater<tuple<int, int, int>>());\n  PCSZ groups(h + w);\n  long long ans = 0;\n  for (int i = 0; i < n; i++) {\n    int w, r, c;\n    tie(w, r, c) = dat[i];\n    if (groups.aux(r) + 1 <= groups.group_size(r)) {\n      ans += w;\n      groups.nodes[groups.find(r)].aux++;\n      groups.merge(r, h + c);\n    } else if (groups.aux(h + c) + 1 <= groups.group_size(h + c)) {\n      ans += w;\n      groups.nodes[groups.find(h + c)].aux++;\n      groups.merge(r, h + c);\n    }\n  }\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\nusing namespace std;\nconst int MAX_N=2e5+10;\nconst int MAX=1e5+10;\nint par[MAX_N],siz[MAX_N],cnt[MAX_N],n,h,w;\nll ans=0;\nstruct edge{\n    int x,y,cost;\n    edge(){}\n    edge(int x,int y,int cost):x(x),y(y),cost(cost){}\n    bool operator<(const edge&b)const{\n        return cost>b.cost;\n    }\n};\nvoid init(){\n    for(int i=0;i<MAX_N;i++){\n        par[i]=i,siz[i]=1,cnt[i]=0;\n    }\n}\nint find(int x){\n    return x==par[x]?par[x]:par[x]=find(par[x]);\n}\nvoid unit(int x,int y,int cost){\n    x=find(x),y=find(y);\n    if(x==y){\n        if(cnt[x]+1==siz[x]){\n            cnt[x]++;\n            ans+=cost;\n        }else{\n            return;\n        }\n    }else if(cnt[x]+cnt[y]+1<=siz[x]+siz[y]){\n        par[x]=y;\n        siz[y]+=siz[x];\n        cnt[y]+=cnt[x]+1;\n        ans+=cost;\n    }\n}\nint main(){\n    init();\n    vector<edge> vec;\n    cin>>n>>h>>w;\n    for(int i=0;i<n;i++){\n        int cost,x,y;\n        cin>>x>>y>>cost;\n        vec.emplace_back(edge(x,y+MAX,cost));\n    }\n    sort(vec.begin(),vec.end());\n    for(auto x:vec){\n        unit(x.x,x.y,x.cost);\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P_;\ntypedef pair<ll, P_> P;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nint N, H, W;\nP p[100000];\nbool used[100000];\nbool used_root[200000];\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << setprecision(10) << fixed;\n    cin >> N >> H >> W;\n    UnionFind uf(H+W);\n    for(int i = 0; i < N; i++){\n        int R, C;\n        ll A;\n        cin >> R >> C >> A;\n        R--; C--;\n        C += H;\n        p[i] = P(A, P_(R, C));\n    }\n    sort(p, p+N, greater<P>());\n    ll ans = 0;\n    int cnt = 0;\n    for(int i = 0; i < N; i++){\n        int r = p[i].second.first;\n        int c = p[i].second.second;\n        ll a = p[i].first;\n        if(!uf.findSet(r,c)){\n            int rr = uf.root(r);\n            int rc = uf.root(c);\n            if(used_root[rr] && used_root[rc]) continue;\n            ans += a;\n            uf.unionSet(r, c);\n            int root = uf.root(r);\n            if(used_root[rr] || used_root[rc]) {\n                used_root[rc] = false;\n                used_root[rr] = false;\n                used_root[root] = true;\n            }\n            used[i] = true;\n            cnt++;\n            // cout << a << ' ' <<  r << ' ' << c << endl;\n        }else{\n            int root = uf.root(r);\n            if(!used_root[root]){\n                used_root[root] = true;\n                ans += a;\n                cnt++;\n                // cout << a << ' ' <<  r << ' ' << c << endl;\n            }\n        }\n    }\n    // cout << cnt << endl;\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Card {\n  int row;\n  int col;\n  int value;\n};\n\nint main() {\n  int N, H, W;\n  cin >> N >> H >> W;\n  vector<int> row_to_col(H);\n  vector<int> col_to_row(W);\n  auto cmp = [](auto&& lhs, auto&& rhs) { return lhs.value < rhs.value; };\n  priority_queue<Card, vector<Card>, decltype(cmp)> q{cmp};\n  for (int i = 1; i <= N; ++i) {\n    Card c;\n    cin >> c.row >> c.col >> c.value;\n    q.emplace(move(c));\n  }\n  int result = 0;\n  for (; !q.empty(); q.pop()) {\n    auto&& c = q.top();\n    auto& rc = row_to_col[c.row];\n    auto& cr = col_to_row[c.col];\n    if (rc == 0 && cr == 0) {\n      rc = c.col;\n      cr = c.row;\n      result += c.value;\n    } else if (rc == 0) {\n      rc = -1;\n      result += c.value;\n    } else if (cr == 0) {\n      cr = -1;\n      result += c.value;\n    } else if (rc == -1 && cr == -1) {\n    } else if (rc == -1) {\n      cr = -1;\n      result += c.value;\n    } else if (cr == -1) {\n      rc = -1;\n      result += c.value;\n    } else {\n      col_to_row[rc] = cr;\n      row_to_col[cr] = rc;\n      rc = cr = -1;\n      result += c.value;\n    }\n  }\n\n  cout << result << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define pb push_back\n#define mp make_pair\nconst int N=200050;\nstruct DSU\n{\n\tint p[N];\n\tbool ban[N];\n\tvoid init(){ for(int i=0;i<N;i++) p[i]=i,ban[i]=0;}\n\tDSU(){ init();}\n\tint Find(int x){ return p[x]==x?x:p[x]=Find(p[x]);}\n\tvoid Union(int x, int y)\n\t{\n\t\tx=Find(x);y=Find(y);\n\t\tif(x==y) ban[x]=1;\n\t\telse p[x]=y;\n\t}\n} DS;\nint state[N],go[N],a[N],l[N],r[N],id[N];\nint main()\n{\n\tint n,h,w;\n\tscanf(\"%i %i %i\",&n,&h,&w);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%i %i %i\",&l[i],&r[i],&a[i]);\n\t\tid[i]=i;\n\t\tr[i]+=h;\n\t}\n\tsort(id+1,id+1+n,[&](int i, int j){ return a[i]>a[j];});\n\tll ans=0;\n\tfor(int j=1;j<=n;j++)\n\t{\n\t\tint i=id[j];\n\t\tint x=l[i],y=r[i];\n\t\tx=DS.Find(x);\n\t\ty=DS.Find(y);\n\t\tif(DS.ban[x] && DS.ban[y]) continue;\n\t\tif(DS.ban[x]) x=y;\n\t\telse if(DS.ban[y]) y=x;\n\t\tans+=a[i];\n\t\tDS.Union(x,y);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cmath>\n#include <algorithm>\n#include <utility>\n#include <queue>\n#include <set>\n#include <map>\n#include <deque>\n#include <iomanip>\n#include <cstdio>\n#include <stack>\n#include <numeric>\n\nusing namespace std;\ntypedef  long long ll;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\n#define  MP make_pair\n#define  PB push_back\n#define inf 1000000007\n#define mod 1000000007\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n\nclass UnionFind {\nprivate:\n    int sz;\n    vector<int> par, size_,SIZE_;\npublic:\n    UnionFind(){}\n    UnionFind(int node_size) : sz(node_size), par(sz), size_(sz, 1),SIZE_(sz, 0){\n        iota(par.begin(), par.end(), 0);\n    }\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n    void unite(int x,int y){\n        x = find(x), y = find(y);\n        if(x == y) return;\n        if(size_[x] < size_[y]) swap(x,y);\n        par[y] = x;\n        size_[x] += size_[y];\n        SIZE_[x] += SIZE_[y];\n    }\n    int size(int x){\n        x = find(x);\n        return size_[x];\n    }\n    int SIZE(int x){\n        x = find(x);\n        return SIZE_[x];\n    }\n    void add(int x){\n        x = find(x);\n        SIZE_[x]++;\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\nint main(){\n    int n,h,w;\n    cin >> n >> h >> w;\n    vector<int> a(h+1),b(w+1);\n    priority_queue<pair<ll,pair<int,int> > >pq;\n    rep(i,n){\n        int s,t;\n        ll p;\n        cin >> s >> t >> p;\n        pq.push(MP(p,MP(s,t)));\n    }\n    ll sm = 0;\n    UnionFind uf(h+w+2);\n    while(!pq.empty()){\n        auto x = pq.top();\n        pq.pop();\n        int s = x.second.first;\n        int t = x.second.second;\n        if(uf.same(s,h+t)){\n            if(uf.size(s)<uf.SIZE(s)+1){\n\n            }else{\n                sm += x.first;\n                uf.add(s);\n            }\n        }else{\n            if(uf.size(s)+uf.size(h+t)<uf.SIZE(s)+uf.SIZE(h+t)+1){\n\n            }else{\n                uf.unite(s,h+t);\n                sm += x.first;\n                uf.add(s);\n            }\n        }\n    }\n\n    cout << sm << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 200005;\n\nint n, h, w;\nint a[N], r[N], c[N];\n\nint rt[N], sz[N], t[N];\n\nint find_rt(int x) {\n    if (rt[x] == x) return x;\n    return rt[x] = find_rt(rt[x]);\n}\n\nstruct cell {\n    int r, c, v;\n    cell(int r = 0, int c = 0, int v = 0) : r(r), c(c), v(v) {}\n    bool operator < (const cell a) const {return v > a.v;}\n} ;\n\nlong long ans;\n\nvector <cell> A;\n\nbool comb(int r, int c) {\n    int x = find_rt(r), y = find_rt(h+c);\n    if (x == y) {\n        if (sz[x] - t[x] > 0) {\n            t[x] ++;\n            return 1;\n        }\n        else return 0;\n    }\n    else {\n        if (sz[x] + sz[y] > t[x] + t[y]) {\n            rt[x] = y;\n            t[y] += t[x];\n            sz[y] += sz[x];\n            t[y] ++;\n            return 1;\n        }\n        else return 0;\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &n, &h, &w);\n    for (int i = 1; i <= h+w; i ++) rt[i] = i, sz[i] = 1, t[i] = 0;\n    for (int i = 1; i <= n; i ++) {\n        int r, c, v;\n        scanf(\"%d %d %d\", &r, &c, &v);\n        A.push_back(cell(r, c, v));\n    }\n    sort(A.begin(), A.end());\n    for (auto x : A) {\n        int r = x.r, c = x.c;\n        if (comb(r, c)) ans += x.v;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//\n//                            ▒█████▒▒\n//                             ██████████▒\n//                             ▒████████████▒\n//                            ██████████████████\n//                           ████████████████████▒\n//                          ▒██████████████████████▒\n//                          ▒███████████████████████\n//                      ▒████▒▒▒▒▒▒█████████████████▒\n//                    ███▒▒▒▒▒▒██████████████████████▒▒▒\n//                  ▒██▒▒███████████████████████▒▒▒▒▒██████\n//                 ▒█████████████████████████▒▒▒▒▒▒█████████▒\n//                 ▒█████████████████████▒▒▒▒▒▒██████████████\n//                  ▒████         ████▒▒▒▒▒████         ████▒\n//              ▒█████▒    ████    ▒▒▒▒███████    ████    ██████▒\n//            ▒██▒▒▒▒▒    ██████    █████████    ██████    ██▒▒▒██▒\n//           █████████   ████████   █████████   ████████   ▒▒▒▒█████\n//          ▒█████████    ██████    ████████▒    ██████    █████████\n//          ▒██████████    ████    █████▒▒▒▒▒▒    ████    ██████████\n//           ████████████        ▒▒▒▒▒▒▒████████        ███████████▒\n//       ▒██████████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒███████████████████████████████████▒\n//     ███▒▒▒▒▒▒▒▒▒▒▒▒█████████████████████████████████████████▒▒████████▒\n//   ▒▒▒▒▒▒▒▒▒██████████████                         ███████▒▒▒▒███████████\n//   █████████████████████████                     ███████▒▒▒██████████████▒\n//   █████████████████████████████             ███████▒▒▒██████████████████▒\n//   ██████████████████████████████████████████████████████████████████████\n//    ██████████████████████████████████████████████████████████████████▒\n//      ▒█████████████████▒▒▒▒▒▒▒██████████████████████████████████▒▒▒\n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define D double\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,h,w;\n  cin >> n >> h >> w;\n\n  map<P,int> mp;\n  vec tate(h+1,0), yoko(w+1,0);\n  using T = tuple<int,int,int>;\n  vector<T> a(n);\n  REP(i,n){\n    int x,y,c;\n    cin >> x >> y >> c;\n    a[i] = T(c,x,y);\n  }\n\n  sort(a.begin(),a.end());\n  reverse(a.begin(),a.end());\n\n  int ans = 0;\n  REP(i,n){\n    int x,y,c;\n    tie(c,x,y) = a[i];\n    if(tate[x] || yoko[y]) continue;\n    ans += c;\n    mp[P(x,y)]++;\n    if(mp[P(x,y)] >= 2) tate[x]++, yoko[y]++;\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \nusing namespace std;\n \n#define F first\n#define S second \n#define pb push_back\n#define endl \"\\n\"\n\n#define IOS { ios :: sync_with_stdio(false); cin.tie(0); cout.tie(0); }\n\n#ifdef DEBUG\n    #define dbg(s) {s;}\n#endif\n\n#ifndef DEBUG\n    #define dbg(s)\n#endif\n\nusing namespace std;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint grand(int x) { // from [0, n-1]\n    return uniform_int_distribution<int>(0, x - 1)(rng);\n}\n\n#define int ll\n#define i32 int32_t\n\n#define RBTTYPE int\n#define ordered_set tree<RBTTYPE, null_type, less<RBTTYPE>, rb_tree_tag,tree_order_statistics_node_update> \n\n#define all(v) (v).begin(),(v).end()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair< int, int > pii;\ntypedef pair< ll, ll > pll;\n\nint getInt () {\n    bool minus = false;\n    int result = 0;\n    char ch;\n    ch = getchar();\n    while (true) {\n        if (ch == '-') break;\n        if (ch >= '0' && ch <= '9') break;\n        ch = getchar();\n    }\n    if (ch == '-') minus = true; else result = ch-'0';\n    while (true) {\n        ch = getchar();\n        if (ch < '0' || ch > '9') break;\n        result = result*10 + (ch - '0');\n    }\n    if (minus)\n        return -result;\n    else\n        return result;\n}\n\n\nll gcd(ll x, ll y) {\n    if (x < y) return gcd(y, x);\n    if (y == 0) return x;\n    return gcd(y, x % y);\n} \n\nconst ll mod = 1e9 + 7;\n\nll modexp(ll x, ll ex) {\n    ll ans = 1ll;\n    while (ex > 0) {\n        if (ex & 1ll) ans = (ans * x) % mod;\n        ex >>= 1ll;\n        x = (x * x) % mod;\n    }\n    return ans;\n}\n\nconst int maxn = 1e6 + 7;\n\nconst ll inf = 1e9 + 7;\n\nvector < pair<int, pii> > v;\n\nint rw[maxn];\nint co[maxn];\n\ni32 main() {\n    //freopen(\"<file>.in\", \"r\", stdin);\n    //freopen(\"<file>.out\", \"w\", stdout);\n\n    IOS;\n\n    int n, h, w; cin >> n >> h >> w;\n    for (int i = 1; i <= n; i++) {\n        int r, c, a; cin >> r >> c >> a;\n        v.pb({a, {r, c}});\n    }\n\n    sort(v.begin(), v.end()); reverse(all(v));\n    fill(rw, rw + maxn, -1);\n    fill(co, co + maxn, -1);\n\n    int idx = 0, ans = 0;\n    for (auto z : v) {\n        int a = z.F, r, c; tie(r, c) = z.S;\n        if (rw[r] < 0) {\n            rw[r] = idx;\n            ans += a;\n        } else if (co[c] < 0) {\n            co[c] = idx; ans += a;   \n        } else if (co[v[rw[r]].S.S] < 0) {\n            co[v[rw[r]].S.S] = rw[r];\n            rw[r] = idx;\n            ans += a;\n        } else if (rw[v[co[c]].S.F] < 0) {\n            rw[v[co[c]].S.S] = co[c];\n            co[c] = idx;\n            ans += a;\n        } else ;\n        idx++;\n    }\n    cout << ans << endl; \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define REP(i, n) FOR(i, 0, (n))\n#define FOR(i, a, b) for(int i=(a); i<(b); i++)\n#define LAR(a, b) ((a)=max((a),(b)))\n#define SML(a, b) ((a)=min((a),(b)))\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<pair<int, int>> vpii;\ntypedef pair<int, int> pii;\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define ALL(a) (a).begin(), (a).end()\n#ifdef LOCAL_DEBUG\n#define DEBUG(...) printf(__VA_ARGS__)\n#else\n#define DEBUG(...)\n#endif\n\n#define N 312345\nset<int> s[N];\nvector<pair<ll, pii>> v;\nint z = N-1;\nbool u[N];\n\nbool dfs(int a){\n\tif(a == z) return true;\n\tif(u[a]) return false;\n\tu[a] = true;\n\tfor(int i : s[a]){\n\t\tDEBUG(\"%d -> %d\\n\", a, i);\n\t\tif(dfs(i)){\n\t\t\ts[a].erase(s[a].find(i));\n\t\t\ts[i].emplace(a);\n\t\t\tu[a] = false;\n\t\t\treturn true;\n\t\t}\n\t}\n\tu[a] = false;\n\treturn false;\n}\n\nint main(){\n\tint n, h, w; scanf(\"%d%d%d\", &n, &h, &w);\n\tREP(i, n){\n\t\tint r, c; ll a; scanf(\"%d%d%lld\", &r, &c, &a);\n\t\tv.EB(a, MP(r-1, c-1));\n\t}\n\tsort(ALL(v), greater<pair<ll, pii>>());\n\tREP(i, h) s[n+i].emplace(z);\n\tREP(i, w) s[n+h+i].emplace(z);\n\tll ans = 0;\n\tREP(i, n){\n\t\tint r = v[i].second.first, c = v[i].second.second;\n\t\ts[i].emplace(n + r);\n\t\ts[i].emplace(n + h + c);\n\t\tif(dfs(i)) ans += v[i].first;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\ntypedef long long LL;\nconst int N = 2e5+5;\n \nstruct edge{\n\tint x,y,d;\n}a[N];\nint n,h,w,c[N],sz[N],fa[N];\nLL ans;\n\nint find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&h,&w);\n\trep(i,1,n)scanf(\"%d%d%d\",&a[i].x,&a[i].y,&a[i].d),a[i].y+=h;\n\tsort(a+1,a+n+1,[](edge x,edge y){return x.d>y.d;});\n\t\n\trep(i,1,h+w)fa[i]=i,c[i]=0,sz[i]=1;\n\trep(i,1,n){\n\t\tint x = find(a[i].x), y = find(a[i].y);\n\t\tif(x!=y){\n\t\t\tfa[x] = y, c[y] += c[x], sz[y] += sz[x];\n\t\t}\n\t\tif(c[y]<sz[y]) c[y]++, ans+=1ll*a[i].d;\n\t} \n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm> //STLͨ���㷨\n#include <cmath> //������ѧ����\n#include <cstdio> //��������/�������\n#include <iostream> //����������/���\n#include <cstring> //�ַ�������\n#include <string> //�ַ�����\n#include <ctime> //�������ʱ��ĺ���\n#define itn int\n#define fro for\n#define ll long long\n#define reg register\n#define inf 1234567890\n#define rep(i,a,b,c) for (int i=a;i<=b;i+=c)\n/*#include <bitset> //STLλ������\n#include <cstype> //�ַ�����\n#include <cerrno> //���������\n#include <complex> //������\n#include <clocale> //���屾�ػ�����\n#include <cstdlib> //������������ڴ���亯��\n#include <deque> //STL˫�˶�������\n#include <exception> //�쳣������\n#include <fstream> //�ļ�����/���\n#include <functional> //STL�������㺯��(���������)\n#include <limits> //�����������������ֵ����\n#include <list> //STL�����б�����\n#include <map> //STLӳ������\n#include <iomanip> //����������/���\n#include <ios> //��������/���֧��\n#include <iosfwd> //����/���ϵͳʹ�õ�ǰ������\n#include <istream> //����������\n#include <ostream> //���������\n#include <queue> //STL��������\n#include <set> //STL��������\n#include <sstream> //�����ַ�������\n#include <stack> //STL��ջ����\n#include <stdexcept> //��׼�쳣��\n#include <streambuf> //�ײ�����/���֧��\n#include <utility> //STLͨ��ģ����\n#include <vector> //STL��̬��������\n#include <cwchar.h>//���ַ�����������/���\n#include <cwctype.h> //���ַ�����*/\n\nusing namespace std;\n\nint ans;\n\nint max(int x,int y){return x>y?x:y;}\n\nint min(int x,int y){return x<y?x:y;}\n\nint abs(int x){return x>0?x:-x;}\n\nint gcd(int x,int y){return (!y)?x:gcd(y,x%y);}\n\nvoid exgcd(int a,int b,int &d,int &x,int &y){if (!b){d=a,x=1,y=0;}else{exgcd(b,a%b,d,y,x);y-=x*(a/b);}}\n\nint quick_power(ll a,int b){ll r=1;for (;b;b>>=1,a=a*a)if (b&1) r=r*a;return r;}\n\ninline char read() {\n\tstatic const int IN_LEN = 1000000;\n\tstatic char buf[IN_LEN], *s, *t;\n\treturn (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);\n}\ntemplate<class T>\ninline void read(T &x) {\n\tstatic bool iosig;\n\tstatic char c;\n\tfor (iosig = false, c = read(); !isdigit(c); c = read()) {\n\t\tif (c == '-') iosig = true;\n\t\tif (c == -1) return;\n\t}\n\tfor (x = 0; isdigit(c); c = read()) x = x * 10 + (c ^ '0');\n\tif (iosig) x = -x;\n}\n\nchar sr[10000000],z[20];int C=-1,Z=0;\nvoid Ot(){fwrite(sr,1,C+1,stdout),C=-1;}\nvoid print(int x){\n\tif (x<0) sr[++C]='-',x=-x;\n    while(z[++Z]=x%10+48,x/=10);\n    while(sr[++C]=z[Z],--Z);sr[++C]='\\n';\n}\n\nconst int N=200200;\nint fa[N],size[N],key[N];\nstruct p\n{\n\tint x,y,v;\n} a[N];\n\nbool cmp(p x,p y)\n{\n\treturn x.v>y.v;\n}\n\nint find(int x){return fa[x]=fa[x]==x?x:find(fa[x]);}\n\n//void add(int x,int y,int z){to[++cnt]=y;v[cnt]=z;Next[cnt]=head[x];head[x]=cnt;}\nint main()\n{\n\tint n,h,w;\n\tread(n);read(h);read(w);\n\tfor (int i=1;i<=n;i++) read(a[i].x),read(a[i].y),a[i].y+=h,read(a[i].v);\n\tfor (int i=1;i<=h+w;i++) fa[i]=i,size[i]=1;\n\tsort(a+1,a+n+1,cmp);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint fx=find(fa[a[i].x]),fy=find(fa[a[i].y]);\n\t\tif (fx==fy)\n\t\t{\n\t\t\tif (size[fx]>=key[fx]+1)\n\t\t\t{\n\t\t\t\tkey[fx]++;\n\t\t\t\tans+=a[i].v;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (size[fx]+size[fy]>=key[fx]+key[fy]+1)\n\t\t\t{\n\t\t\t\tsize[fx]+=size[fy];\n\t\t\t\tkey[fx]+=key[fy]+1;\n\t\t\t\tfa[fy]=fx;\n\t\t\t\tans+=a[i].v;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pi;\ntypedef vector<pi> vpi;\ntypedef long double ld;\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (ll)x.size()\n#define f first\n#define s second\n#define MAXN 200100\n\npi A[MAXN];\nll N,L,R;\nll ans;\nvi V;\nmultiset<ll> lset,rset;\n\nint main(){\n\tcin>>N;\n\tfor (ll i=1;i<=N;++i)cin>>A[i].f>>A[i].s;\n\tfor (ll i=1;i<=N;++i){\n\t\tL+=A[i].f;\n\t\tR+=A[i].s;\n\t}\n\tans = min(L,R);\n\tll T = 0;\n\tfor (int i=1;i<=N;++i){lset.insert(A[i].f);T += A[i].f;}\n\tfor (int i=1;i<=N;++i){lset.insert(A[i].s);T += A[i].s;}\n\n\tfor (ll i=1;i<=N;++i){\n\t\tif (i>1){\n\t\t\tlset.insert(A[i-1].f);\n\t\t\tlset.insert(A[i-1].s);\n\t\t\tT += A[i-1].f;\n\t\t\tT += A[i-1].s;\n\t\t}\n\t\tif (lset.find(A[i].f) == lset.end()){\n\t\t\trset.erase(rset.find(A[i].f));\n\t\t}else{\n\t\t\tlset.erase(lset.find(A[i].f));\n\t\t\tT -= A[i].f;\n\t\t}\n\t\tif (lset.find(A[i].s) == lset.end()){\n\t\t\trset.erase(rset.find(A[i].s));\n\t\t}else{\n\t\t\tlset.erase(lset.find(A[i].s));\n\t\t\tT -= A[i].s;\n\t\t}\n\t\twhile (SZ(lset) > N-2){\n\t\t\tT -= *(--lset.end());\n\t\t\trset.insert(*(--lset.end()));\n\t\t\tlset.erase(--lset.end());\n\t\t}\n\t\twhile (SZ(lset) < N-2){\n\t\t\tT += *(rset.begin());\n\t\t\tlset.insert(*(rset.begin()));\n\t\t\trset.erase(rset.begin());\n\t\t}\n\t\tans = min(ans,T+A[i].f+A[i].s);\n\t\tassert(SZ(lset) == N-2);\n\t\t// for (auto i : lset)cout<<i<<' ';cout<<'\\n';\n\t\t// cout<<T<<'\\n';\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N,H,W; cin >> N >> H >> W;\n    vector<int> R(N),C(N),A(N);\n    rep(i,N) {\n        cin >> R[i] >> C[i] >> A[i];\n        --R[i];\n        --C[i];\n    }\n\n    vector<int> idx(N);\n    iota(all(idx),0);\n    sort(all(idx),[&](int i, int j){return A[i] > A[j];});\n    vector<int> checkr(H,-1),checkc(W,-1),checka(N);\n\n    auto dfs=[&](auto&& self, int v)->bool {\n        if (checkr[R[v]]==-1) {\n            checkr[R[v]] = v;\n            checkc[C[v]] = -1;\n            return 1;\n        } else if (checkc[C[v]]==-1) {\n            checkc[C[v]] = v;\n            checkr[R[v]] = -1;\n            return 1;\n        }\n        checka[v] = 1;\n        if (checkr[R[v]] != v) {\n            int nex = checkr[R[v]];\n            if (!checka[nex]) {\n                if(self(self,nex)) {\n                    checkr[R[v]] = v;\n                    checkc[C[v]] = -1;\n                    return 1;\n                }\n            }\n        } else if (checkc[C[v]] != v) {\n            int nex = checkc[C[v]];\n            if (!checka[nex]) {\n                if (self(self,nex)) {\n                    checkc[C[v]] = v;\n                    checkr[R[v]] = -1;\n                    return 1;\n                }\n            }\n        }\n        return 0;\n    };\n    rep(i,N) {\n        int u = idx[i];\n        if (checkr[R[u]]==-1) {\n            checkr[R[u]] = u;\n        } else if (checkc[C[u]]==-1) {\n            checkc[C[u]] = u;\n        } else {\n            int s = checkr[R[u]];\n            if (!checka[s]) {\n                if (dfs(dfs,s)) {\n                    checkr[R[u]] = u;\n                    continue;\n                }\n            }\n            int t = checkc[C[u]];\n            if (!checka[t]) {\n                if (dfs(dfs,t)) {\n                    checkc[C[u]] = u;\n                }\n            }\n        }\n    }\n\n    ll ans = 0;\n    rep(i,H) {\n        if (checkr[i] != -1) ans += A[checkr[i]];\n    }\n    rep(i,W) {\n        if (checkc[i] != -1) ans += A[checkc[i]];\n    }\n\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <random>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <sstream>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <queue>\n\n#define len(X) ((int)(X).size())\n\n#ifdef __LOCAL\n\t#define DBG(X) cout << #X << \"=\" << (X) << endl;\n#else\n\t#define DBG(X)\n\t#define endl '\\n'\n#endif\n \nusing namespace std;\n\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld  = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF  = (ll)(2e18);\n\nconst ll mod = 1e9 + 7;\nconst int NIL = -1;\nstatic mt19937 _g(time(nullptr));\n\ninline ll randint(ll a, ll b) { ll w = (_g() << 31LL) ^ _g(); return a + w % (b - a + 1); }\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T> inline T sign(T x) { return T(x > 0) - T(x < 0); }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\n\nconst int MAX_N = (int)1e5 + 777;\n\nint n, h, w;\nll val[MAX_N];\nint r[MAX_N], c[MAX_N];\nint match_row[MAX_N], match_col[MAX_N];\n\nvoid add(int i)\n{\n\tif(i == 0)\n\t\treturn;\n\n\tif(val[match_row[r[i]]] < val[match_col[c[i]]])\n\t{\n\t\tint j = match_row[r[i]];\n\n\t\tif(val[i] > val[j])\n\t\t{\n\t\t\tmatch_row[r[i]] = i;\n\t\t\tadd(j);\n\n\t\t\treturn;\n\t\t}\n\t\n\t}\n\telse\n\t{\n\t\tint j = match_col[c[i]];\n\n\t\tif(val[i] > val[j])\n\t\t{\n\t\t\tmatch_col[c[i]] = i;\n\t\t\tadd(j);\n\n\t\t\treturn;\n\t\t}\n\t}\n}\n\nvoid solve()\n{\n\tcin >> n >> h >> w;\n\n\tfor(int i = 1; i <= n; ++i)\n\t\tcin >> r[i] >> c[i] >> val[i];\n\n\tval[0] = 0;\n\n\tfor(int i = 1; i <= n; ++i)\n\t\tadd(i);\n\n\tll answ = 0;\n\n\tfor(int i = 1; i <= h; ++i)\n\t\tansw += val[match_row[i]];\n\n\tfor(int i = 1; i <= w; ++i)\n\t\tansw += val[match_col[i]];\n\n\tcout << answ << endl;\n}\n\nint main()\n{\n\tfast_io();\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_genius = 0; ngtkana_is_genius < int(n); ngtkana_is_genius++)\n#define rep(i, begin, end) for(int i = int(begin); i < int(end); i++)\n#define lint long long\nauto cmn = [](auto& a, auto b){if (a > b) {a = b; return true;} return false;};\nauto cmx = [](auto& a, auto b){if (a < b) {a = b; return true;} return false;};\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail){\n  std::cerr << \" \" << head;\n  debug_impl(tail...);\n}\n#define debug(...) std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n  debug_impl(__VA_ARGS__);\\\n  std::cerr << std::noboolalpha;\n\nclass union_find_tree\n{\n  int n;\n  std::vector<int> prt;\n  std::vector<bool> ckd;\n\npublic:\n  union_find_tree (int n) : n(n), prt(n, -1), ckd(n, false) {}\n\n  bool is_root (int x)        const {return prt.at(x) < 0;}\n\n  int  size    (int x)        const {return -prt.at(find(x));}\n\n  bool is_equiv(int x, int y) const {return find(x) == find(y);}\n\n  int  find    (int x)        const {\n    while (!is_root(x)) x = prt.at(x);\n    return x;\n  }\n\n  // Returns `true` if x and y are newly connected.\n  // The smaller one x becomes a child of the larger one y.\n  bool unite   (int x, int y)\n  {\n    if ((x = find(x)) == (y = find(y))) return false;\n    if (size(x) > size(y)) std::swap(x, y);\n    prt.at(y) += prt.at(x);\n    prt.at(x) = y;\n    if (ckd.at(x)) ckd.at(y) = true;\n    return true;\n  }\n\n  bool checked (int x) const {return ckd.at(find(x));}\n\n  void check (int x)\n  {\n    x = find(x);\n    assert(!ckd.at(x));\n    ckd.at(x) = true;\n  }\n};\n\nint main()\n{\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n, h, w;\n  std::cin >> n >> h >> w;\n  auto uft = union_find_tree(h + w);\n  auto edges = std::vector<std::tuple<int, int, int>>(n);\n  rep(i, 0, n)\n  {\n    int x, y, a;\n    std::cin >> x >> y >> a;\n    x--, y--, y += h;\n    edges.at(i) = std::make_tuple(a, x, y);\n  }\n  std::sort(edges.begin(), edges.end());\n  std::reverse(edges.begin(), edges.end());\n  lint ret = 0;\n  for (auto e : edges)\n  {\n    int a, x, y;\n    std::tie(a, x, y) = e;\n    if (uft.unite(x, y))\n    {\n      ret += a;\n    }\n    else if (!uft.checked(x))\n    {\n      ret += a;\n      uft.check(x);\n    }\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<chrono>\n#include<climits>\n#include<numeric>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<random>\n#include<set>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<string>\nusing namespace std;\n \n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define print(v) {for(auto x : v) cout << x << ' '; cout << endl;}\n#define printn(v, n) {for(int _i = 0; _i < n; _i++) cout << *(v + _i) << ' '; cout << endl;}\n \ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n \nconst int MAXN = 2e5 + 20;\nint n, h, w;\nvector<long long> a[MAXN];\n\nint root[MAXN], size[MAXN], marked[MAXN] = {};\nvoid init() {\n    for(int i = 0; i < MAXN; i++) {\n        root[i] = i;\n        size[i] = 1;\n    }\n}\nint find(int i) {\n    if(root[i] != i)\n        return root[i] = find(root[i]);\n    else\n        return i;\n}\nint same(int i, int j) {\n    return find(i) == find(j);\n}\nvoid join(int i, int j) {\n    if(same(i, j))\n        return;\n    int ri = find(i);\n    int rj = find(j);\n    if(marked[ri] || marked[rj])\n    \tmarked[ri] = marked[rj] = 1;\n    if(size[ri] >= size[rj]) {\n        root[rj] = ri;\n        size[ri] += size[rj];\n    }\n    else {\n        root[ri] = rj;\n        size[rj] += size[ri];\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> n >> h >> w;\n    for(int i = 0; i < n; i++) {\n    \ta[i].resize(3);\n    \tcin >> a[i][1] >> a[i][2] >> a[i][0];\n    }\n\n    sort(a, a + n, [](const vector<long long> & x, const vector<long long> & y) {\n    \treturn x[0] > y[0];\n    });\n\n    init();\n\n    long long res = 0;\n    for(int i = 0; i < n; i++) {\n    \tint x = a[i][1];\n    \tint y = a[i][2] + max({n, h, w});\n    \tint w = a[i][0];\n    \t//cout << x << ' ' << y << ' ' << same(x, y) << endl;\n    \tif(!same(x, y)) {\n    \t\tif(!marked[find(x)] || !marked[find(y)]) {\n\t    \t\tres += w;\n\t    \t\tjoin(x, y);\n    \t\t}\n    \t}\n    \telse if(!marked[find(x)]) {\n    \t\tmarked[find(x)] = 1;\n    \t\tres += w;\n    \t}\n    }\n    cout << res << endl;\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5+100;\ntypedef long long ll;\n#define fr(i,low,up,st) for(register int i = (int)low;i <= (int)up;i += st)\n#define nfr(i,low,up,st) for(register int i = (int)low;i >= (int)up;i -= st)\n#define clr(a) memset(a,0,sizeof a)\n\nint n,m,h,w;\n\nstruct edge{\n   int r,c,a;\n   bool operator < (const edge &b) const {\n      return a > b.a;\n   }\n}e[N];\n\nint f[N];\nint cntp[N],cnte[N];\n\nvoid init(){\n   fr(i,1,h+w,1)f[i] = i,cntp[i] = 1;\n   clr(cnte);\n}\n\nint find(int x){\n   return (x == f[x])?x:f[x] = find(f[x]);\n}\n\nint main(){\n   scanf(\"%d%d%d\",&n,&h,&w);\n   fr(i,1,n,1){\n      scanf(\"%d%d%d\",&e[i].r,&e[i].c,&e[i].a);\n      e[i].c += h;\n   }\n   sort(e+1,e+n+1);\n   ll ans = 0;\n   init();\n   fr(i,1,n,1){\n      int h1 = find(e[i].r),h2 = find(e[i].c);\n      if(h1 == h2){\n         if(cntp[h1] == cnte[h1])continue ;\n         cnte[h1]++;\n         ans += e[i].a;\n      }\n      else {\n         if(cntp[h1]+cntp[h2] < cnte[h1]+cnte[h2]+1)continue ;\n         else {\n            f[h1] = h2;\n            cntp[h2] += cntp[h1]; cntp[h1] = 0;\n            cnte[h2] += cnte[h1]+1; cnte[h1] = 0;\n            ans += e[i].a;\n         }\n      }\n   }\n   printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0,i##_len=(n);i<i##_len;++i)\n#define RREP(i,n) for(int i=int(n)-1;i>=0;--i)\n#define rep(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rrep(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define All(x) (x).begin(),(x).end()\n#define rAll(x) (x).rbegin(),(x).rend()\n#define ITR(i,x) for(auto i=(x).begin();i!=(x).end();++i)\nusing namespace std;\nusing Graph = vector<vector<int>>;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\nconstexpr ll mod = 1e9+7;\nconstexpr double eps = 1e-9;\n\nvoid solve();\nP bisearch(ll l,ll r,function<bool(ll)> f){\n    while((l+1)<r){\n        ll m=(l+r)/2;\n        if(f(m)) r=m;\n        else l=m;\n    }\n    return P(l,r);\n}\nll SQRT(ll n){if(n==1) return 1;return bisearch(0,n,[n](ll x){return x>n/x;}).first;}\nll roundup(ll n,ll div){\n    if(n>0) return (n-1)/div+1;\n    else return n/div;    \n}\nbool square(ll a){ll n=SQRT(a);return a==n*n;}\nll npow(ll x, ll n){\n    ll ans = 1;\n    while(n != 0){\n        if(n&1) ans = ans*x;\n        x = x*x;\n        n = n >> 1;\n    }\n    return ans;\n}\nll mpow(ll x, ll n){ //x^n(mod) ←普通にpow(x,n)では溢れてしまうため，随時mod計算 2分累乗法だから早い\n    ll ans = 1;\n    while(n != 0){\n        if(n&1) ans = ans*x % mod;\n        x = x*x % mod;\n        n = n >> 1;\n    }\n    return ans;\n}\nll inv_mod(ll a){return mpow(a,mod-2);}\nint digitsum(ll N,int a){\n    if(N==0) return 0;\n    int ret=0;\n    ret+=digitsum(N/a,a)+N%a;\n    return ret;\n}\nll gcd(ll x,ll y){return y ? gcd(y,x%y) : x;};//xとyの最大公約数\nll lcm(ll x,ll y){return x/gcd(x,y)*y;}//xとyの最小公倍数\nvoid YN(bool flg){std::cout<<(flg?\"YES\":\"NO\")<<endl;}\nvoid Yn(bool flg){std::cout<<(flg?\"Yes\":\"No\")<<endl;}\nvoid yn(bool flg){std::cout<<(flg?\"yes\":\"no\")<<endl;}\nP splitint(string n,int a){\n    int Len=n.length();\n    if(a<0||Len<a) return {-1,-1};\n    string left,right;\n    if(a!=0) left=n.substr(0,a);\n    if(a!=Len) right=n.substr(a);\n    return P(stoll(left),stoll(right));\n}\nll manhattan(const P &a,const P &b){return llabs(a.first-b.first)+llabs(a.second-b.second);}\nbool kaibun(string s){//O(|S|)\n    string  sdash=s;\n    reverse(All(s));\n    return s==sdash;\n}\nclass Ruiseki{\n  private:\n    vector<ll> LEFT,RIGHT;\n    function<ll(ll,ll)> F;\n    int N;\n  public:\n    Ruiseki(ll INI,const vector<ll> &a,function<ll(ll,ll)> f){\n        N=a.size();F=f;\n        LEFT.resize(N+1);RIGHT.resize(N+1);\n        LEFT[0]=RIGHT[0]=INI;\n        REP(i,N){ \n            LEFT[i+1]=F(LEFT[i],a[i]);\n            RIGHT[i+1]=F(RIGHT[i],a[N-i-1]);\n        }\n    }\n    ll out(int l,int r){//[l,r)の外の累積\n        return F(LEFT[l],RIGHT[N-r]);\n    }\n};\nclass mint {\n private:\n  ll _num,_mod;\n  mint set(ll num){ \n      _num = num ;\n      if(_num>=0) _num%=_mod;\n      else _num+=(1-(_num+1)/_mod)*_mod; \n      return *this;\n  }\n  ll imod(ll n){return mpow(n , _mod-2);}\n public:\n  mint(){ _num = 0;_mod=mod; }\n  mint(ll num){ _mod = mod; _num = (num+(1LL<<25)*mod) % mod; }\n  mint(ll num,ll M){ _mod=M;_num=(num+(1LL<<25)*mod)%_mod; }\n  mint(const mint &cp){_num=cp._num;_mod=cp._mod;}\n  mint operator= (const ll x){ return set(x); }\n  mint operator+ (const ll x){ return mint(_num + (x % _mod) , _mod); }\n  mint operator- (const ll x){ return mint(_num - (x % _mod), _mod); }\n  mint operator* (const ll x){ return mint(_num * (x % _mod) , _mod); }\n  mint operator/ (ll x){ return mint(_num * imod(x) , _mod);}\n  mint operator+=(const ll x){ return set(_num + (x % _mod)); }\n  mint operator-=(const ll x){ return set(_num - (x % _mod)); }\n  mint operator*=(const ll x){ return set(_num * (x % _mod)); }\n  mint operator/=(ll x){ return set(_num * imod(x));}\n  mint operator+ (const mint &x){ return mint(_num + x._num , _mod); }\n  mint operator- (const mint &x){ return mint(_num - x._num , _mod);}\n  mint operator* (const mint &x){ return mint(_num * x._num , _mod); }\n  mint operator/ (mint x){ return mint(_num * imod(x._num) , _mod);}\n  mint operator+=(const mint &x){ return set(_num + x._num); }\n  mint operator-=(const mint &x){ return set(_num - x._num); }\n  mint operator*=(const mint &x){ return set(_num * x._num); }\n  mint operator/=(mint x){ return set(_num * imod(x._num));}\n\n  bool operator<(const mint &x){return _num<x._num;}\n\n  friend mint operator+(ll x,const mint &m){return mint(m._num + (x % m._mod) , m._mod);}\n  friend mint operator-(ll x,const mint &m){return mint( (x % m._mod) - m._num , m._mod);}\n  friend mint operator*(ll x,const mint &m){return mint(m._num * (x % m._mod) , m._mod);}\n  friend mint operator/(ll x,mint m){return mint(m.imod(m._num) * x , m._mod);}\n\n  explicit operator ll() { return _num; }\n  explicit operator int() { return (int)_num; }\n\n  friend ostream& operator<<(ostream &os, const mint &x){ os << x._num; return os; }\n  friend istream& operator>>(istream &is, mint &x){ll val; is>>val; x.set(val); return is;}\n};\ntemplate<typename T> class MAT{\n private:\n    int row,col;\n    vector<vector<T>> _A;\n    MAT set(vector<vector<T>> A){_A = A ; return *this;}\n    \n public:\n    MAT(){ }\n    MAT(int n,int m){\n        if(n<1 || m<0){cout << \"err Matrix::Matrix\" <<endl;exit(1);}\n        row = n;\n        col = m?m:n;//m=0のとき単位行列を作る\n        REP(i,row){\n            vector<T> a(col,0.0);\n            _A.push_back(a);\n        }\n        //  値の初期化\n        if(m==0) REP(i,n) _A[i][i]=1.0;\n    }\n    MAT(const MAT &cp){_A=cp._A;row=cp.row;col=cp.col;}\n    T* operator[] (int i){return _A[i].data();}\n    MAT operator= (vector<vector<T>> x) {return set(x);}\n    MAT operator+ (MAT x) {\n        if(row!=x.row || col!=x.col){\n            cout << \"err Matrix::operator+\" <<endl;\n            cout << \"  not equal matrix size\" <<endl;\n            exit(0);\n        }\n        MAT r(row, col);\n        REP(i,row) REP(j,col) r[i][j]=_A[i][j]+x[i][j];\n        return r;\n    }\n    MAT operator- (MAT x) {\n        if(row!=x.row || col!=x.col){\n            cout << \"err Matrix::operator-\" <<endl;\n            cout << \"  not equal matrix size\" <<endl;\n            exit(0);\n        }\n        MAT r(row, col);\n        REP(i,row) REP(j,col) r[i][j]=_A[i][j]-x[i][j];\n        return r;\n    }\n    MAT operator* (MAT x) {\n        if(col!=x.row){\n            cout << \"err Matrix::operator*\" <<endl;\n            cout << \"  not equal matrix size\" <<endl;\n            exit(0);\n        }\n        MAT r(row, x.col);\n        REP(i,row) REP(j,x.col) REP(k,col) r[i][j]+=_A[i][k]*x[k][j];\n        return r;\n    }\n    MAT operator/ (T a){\n        MAT r(row,col);\n        REP(i,row) REP(j,col) r[i][j]=_A[i][j]/a;\n        return r;\n    }\n    MAT operator^ (ll n){\n        if(row!=col){\n            cout << \"err Matrix::operator^\" <<endl;\n            cout << \"  not equal matrix size\" <<endl;\n            exit(0);\n        }\n        MAT r(row,0),A=*this;\n        while(n){\n            if(n&1) r *= A;\n            A*=A;\n            n>>=1;\n        }\n        return r;\n    }\n    MAT operator+= (MAT x) {\n        if(row!=x.row || col!=x.col){\n            cout << \"err Matrix::operator+=\" <<endl;\n            cout << \"  not equal matrix size\" <<endl;\n            exit(0);\n        }\n        MAT r(row, col);\n        REP(i,row) REP(j,col) r[i][j]=_A[i][j]+x[i][j];\n        return set(r._A);\n    }\n    MAT operator-= (MAT x) {\n        if(row!=x.row || col!=x.col){\n            cout << \"err Matrix::operator-=\" <<endl;\n            cout << \"  not equal matrix size\" <<endl;\n            exit(0);\n        }\n        MAT r(row, col);\n        REP(i,row) REP(j,col) r[i][j]=_A[i][j]-x[i][j];\n        return set(r._A);\n    }\n    MAT operator*= (MAT x) {\n        if(col!=x.row){\n            cout << \"err Matrix::operator*\" <<endl;\n            cout << \"  not equal matrix size\" <<endl;\n            exit(0);\n        }\n        MAT r(row, x.col);\n        REP(i,row) REP(j,x.col) REP(k,col) r[i][j]+=_A[i][k]*x[k][j];\n        return set(r._A);\n    }\n    MAT operator/=(T a){\n        MAT r(row,col);\n        REP(i,row) REP(j,col) r[i][j]=_A[i][j]/a;\n        return r;\n    }\n\n    friend MAT operator* (T n,MAT x){\n        MAT r(x.row,x.col);\n        REP(i,x.row) REP(j,x.col) r[i][j]=n*x[i][j];\n        return r;\n    }\n    friend MAT operator* (MAT x,T n){\n        MAT r(x.row,x.col);\n        REP(i,x.row) REP(j,x.col) r[i][j]=n*x[i][j];\n        return r;\n    }\n    explicit operator vector<vector<T>>(){return _A;}\n    friend ostream &operator<<(ostream &os,const MAT &x){ REP(i,x.row) REP(j,x.col) os<<x._A[i][j]<<\" \\n\"[j==x.col-1]; return os;}\n    friend istream &operator>>(istream &is,MAT &x){REP(i,x.row) REP(j,x.col) is>>x._A[i][j];return is;}\n    int size_row(){return row;}\n    int size_col(){return col;}\n    MAT transpose(){\n        MAT r(col,row);\n        REP(i,col) REP(j,row) r[i][j]=_A[j][i];\n        return r;\n    }\n    MAT inverse(){\n        T buf;\n        MAT<T> inv_a(row,0);\n        vector<vector<T>> a=_A;\n        //掃き出し法\n        REP(i,row){\n            buf=1/a[i][i];\n            REP(j,row){\n                a[i][j]*=buf;\n                inv_a[i][j]*=buf;\n            }\n            REP(j,row){\n                if(i!=j){\n                    buf=a[j][i];\n                    REP(k,row){\n                        a[j][k]-=a[i][k]*buf;\n                       inv_a[j][k]-=inv_a[i][k]*buf;\n                    }\n                }\n            }\n        }\n        return inv_a;\n    }\n    // O( n^3 ).\n    int rank() {\n        vector<vector<T>> A=_A;\n        const int n = row, m = col;\n        int r = 0;\n        for(int i = 0; r < n && i < m; ++i) {\n            int pivot = r;\n            for(int j = r+1; j < n; ++j) if(fabs(A[j][i]) > fabs(A[pivot][i])) pivot = j;\n            swap(A[pivot], A[r]);\n            if(fabs(A[r][i]) < eps) continue;\n            for (int k = m-1; k >= i; --k) A[r][k] /= A[r][i];\n            rep(j,r+1,n) rep(k,i,m) A[j][k] -= A[r][k] * A[j][i];\n            ++r;\n        }\n        return r;\n    }\n};\nclass UnionFind{//UnionFind木\n private:\n    vector<int> Parent,es;\n    vector<ll> diff_weight;\n public:\n    UnionFind(int N){\n        es.resize(N,0);\n        Parent.resize(N,-1);\n        diff_weight.resize(N,0LL);\n    }\n\n    int root(int A){\n        if(Parent[A]<0) return A;\n        else{ \n            int r = root(Parent[A]);\n            diff_weight[A] += diff_weight[Parent[A]]; // 累積和をとる\n            return Parent[A]=r;\n        }\n    }\n    bool issame(int A,int B){\n        return root(A)==root(B);\n    }\n    ll weight(int x) {\n        root(x); // 経路圧縮\n        return diff_weight[x];\n    }\n    ll diff(int x, int y) {\n        return weight(y) - weight(x);\n    }\n    int size(int A){\n        return -Parent[root(A)];\n    }\n    int eize(int A){\n        return es[root(A)];\n    }\n    bool connect(int A,int B){\n        A=root(A); B=root(B);\n        if(A==B) return false;\n        if(size(A)<size(B)) swap(A,B);\n        Parent[A]+=Parent[B];\n        es[A]+=es[B]+1;\n        Parent[B]=A;\n        return true;\n    }\n    void unite(int A,int B){\n        A=root(A); B=root(B);\n        if(A==B){ \n            es[A]++;\n            return;\n        }\n        if(size(A)<size(B)) swap(A,B);\n        Parent[A]+=Parent[B];\n        es[A]+=es[B]+1;\n        Parent[B]=A;\n        return;\n    }\n    bool merge(int A, int B, ll w) {\n        // x と y それぞれについて、 root との重み差分を補正\n        w += weight(A); w -= weight(B); \n        A=root(A); B=root(B);\n        if(A==B) return false;\n        if(size(A)<size(B)) swap(A,B),w=-w;\n        Parent[A]+=Parent[B];\n        Parent[B]=A;\n        // x が y の親になるので、x と y の差分を diff_weight[y] に記録\n        diff_weight[B] = w; \n        return true;\n    }\n};\nclass Factorial{//階乗とその逆元を求めて計算に利用するクラス\n private:\n    vector<ll> fac;\n    vector<ll> ifac;\n public:\n    \n    Factorial(ll N){\n        fac.push_back(1);\n        REP(i,N) fac.push_back(fac[i]*(i+1)%mod);\n        ifac.resize(N+1);\n        ifac[N]=inv_mod(fac[N]);\n        REP(i,N) ifac[N-1-i]=(ifac[N-i]*(N-i))%mod;\n    }\n\n    ll fact(ll a){return fac[a];}\n    ll ifact(ll a){return ifac[a];}\n\n    ll cmb(ll a,ll b){\n        if(a==0&&b==0) return 1;\n        if(a<b||a<0||b<0) return 0;\n        ll tmp =ifact(a-b)*ifact(b)%mod;\n        return tmp*fac[a]%mod;\n    }\n    ll per(ll a,ll b){\n        if(a==0&&b==0) return 1;\n        if(a<b||a<0||b<0) return 0;\n        return fac[a]*ifac[a-b]%mod;\n    }\n};\nclass SOSU{\n private:\n    vector<ll> Prime_Number;\n public:\n    SOSU(ll N){\n        vector<bool> isp(N+1,true);\n        isp[0]=isp[1]=false;\n        rep(i,2,N+1){\n            if(isp[i]){\n                Prime_Number.push_back(i);\n                for(int j=2*i;j<=N;j+=i) isp[j]=false;\n            }\n        }\n    }\n    ll operator[](int i){return Prime_Number[i];}\n    int size(){return Prime_Number.size();}\n    ll back(){return Prime_Number.back();}\n    bool isPrime(int q){return binary_search(All(Prime_Number),q);}\n};\nclass Divisor{//素因数分解をしてから約数列挙、分解結果はＰ(底,指数)でpfacにまとめている\n  private:\n    vector<ll> F;\n    vector<P> pfactorize;\n  public:\n    Divisor(ll N){\n        for(ll i = 1; i * i <= N; i++) {\n            if(N % i == 0) {\n                F.push_back(i);\n                if(i * i != N) F.push_back(N / i);\n            }\n        }\n        sort(begin(F), end(F));\n\t\tSOSU p(SQRT(N)+1);\n    \tREP(i,p.size()){\n    \t\tpfactorize.push_back(P(p[i],0));\n    \t\twhile(N%p[i]==0){\n    \t\t\tN/=p[i];\n    \t\t\tpfactorize.back().second++;\n    \t\t}\n            if(pfactorize.size()==0) pfactorize.pop_back();\n    \t}\n    \tif(N>1) pfactorize.push_back(P(N,1));\n    }\n    int size(){return F.size();}\n    vector<P> pfac(){return pfactorize;}\n    ll operator[](int k){return F[k];}\n};\nstruct Solutions{\n    ll napsack(int kinds,int MAX_W,const vl &weight,const vl &cost){\n        vector<vector<ll>> dp(kinds+1,vector<ll>(MAX_W+1,0));\n        REP(i,kinds) REP(j,MAX_W+1){\n            if(j<weight[i]) dp[i+1][j]=dp[i][j];\n            else dp[i+1][j]=max(dp[i][j],dp[i][j-weight[i]]+cost[i]);\n        }\n        return dp[kinds][MAX_W];\n    }\n    ll cost_based_napsack(int kinds,int MAX_W,const vl &weight,const vl &cost){\n        int MAX_V=0;\n        REP(i,kinds) MAX_V=max(MAX_V,(int)cost[i]);\n        vvl dp(kinds+1,vl(kinds*MAX_V+1,1LL<<58));\n        dp[0][0] = 0;\n        REP(i,kinds) REP(j,kinds*MAX_V+1){\n            if(j<cost[i]) dp[i+1][j]=dp[i][j];\n            else dp[i+1][j] = min(dp[i][j],dp[i][j-cost[i]]+weight[i]);\n        }\n        int res=0;\n        REP(i,kinds*MAX_V+1) if(dp[kinds][i]<=MAX_W) res=i;\n        return res;\n    }\n    ll unlimited_napsack(int kinds,int MAX_W,const vl &weight,const vl &cost){\n        vector<vector<ll>> dp(kinds+1,vector<ll>(MAX_W+1,0));\n        REP(i,kinds) REP(j,MAX_W+1){\n            if(j<weight[i]) dp[i+1][j]=dp[i][j];\n            else dp[i+1][j]=max(dp[i][j],dp[i+1][j-weight[i]]+cost[i]);\n        }\n        return dp[kinds][MAX_W];\n    }\n    ll huge_napsack(int kinds,ll MAX_W,const vl &weight,const vl &cost){\n        int n2=kinds/2;\n        vector<P> ps(1<<(kinds/2));\n        REP(i,1<<n2){\n            ll sw=0,sv=0;\n            REP(j,n2){\n                if(i>>j&1){\n                    sw += weight[j];\n                    sv += cost[j];\n                }\n            }\n            ps[i] = P(sw,sv);\n        }\n        sort(ps.begin(),ps.begin() + (1<<n2) );\n        int m=1;\n        rep(i,1,1<<n2){\n            if(ps[m-1].second<ps[i].second) ps[m++] = ps[i];\n        }\n\n        ll res=0;\n        REP(i,1<<(kinds-n2)){\n            ll sw=0,sv=0;\n            REP(j,kinds-n2){\n                if((i>>j)&1){\n                    sw += weight[n2+j];\n                    sv += cost[n2+j];\n                }\n            }\n            if(sw<=MAX_W){\n                ll tv = (lower_bound(ps.begin(),ps.begin()+m,P(MAX_W-sw,LLONG_MAX))-1)->second;\n                res = max(res,sv+tv);\n            }\n        }\n        return res;\n    }\n    ll choose_MonN(int N,int M,const vl &cost){\n        vvl dp(N+1,vl(M+1,-1LL<<58));\n        REP(i,N+1) dp[i][0]=0;\n        REP(i,N) REP(j,M){\n            if(j>i) break;\n            dp[i+1][j+1]=max(dp[i][j+1],dp[i][j]+cost[i]);\n        }\n        return dp[N][M];\n    }\n    ll Partition_Func(int n,int k){\n        vector<vector<ll>> dp(k+1,vector<ll> (n+1,0));\n        dp[0][0]=1;\n        rep(i,1,k+1) REP(j,n+1){\n            if(j-i>=0) dp[i][j]=(dp[i][j-i]+dp[i-1][j]);\n            else dp[i][j]=dp[i-1][j];\n        }\n        return dp[k][n];\n    }\n    int LCS(string s,string t){\n        int n=s.length(),m=s.length();\n        vector<vector<int>> dp(n+1,vector<int>(m+1));\n        REP(i,n) REP(j,m){\n            if (s[i] == t[j]) dp[i+1][j+1] = dp[i][j] + 1;\n            else dp[i+1][j+1] = max(dp[i][j+1], dp[i+1][j]);\n        }\n        return dp[n][m];\n    }\n    int LIS(const vector<ll> a){\n        int n=a.size();\n        ll INF=1<<28;\n        vector<ll> dp(n+1,INF);\n        REP(i,n) *lower_bound(All(dp),a[i])=a[i];\n        int k=lower_bound(All(dp),INF)-dp.begin();\n        return k;\n    }\n    \n    int max_flow(int s,int t,const vector<vector<P>> &g){\n        struct edge_{int to,cap, rev;};\n        vector<bool> used(g.size(),false);\n        vector<vector<edge_>> G(g.size());\n        REP(i,g.size()) REP(j,g[i].size()){\n            int from = i, to = g[i][j].second;\n            int cap = g[i][j].first;\n            G[from].push_back((edge_){to,cap,(int)G[to].size()});\n            G[to].push_back((edge_){from,0,(int)G[from].size()-1});\n        }\n        auto dfs = [&](auto&& f,int v,int t,int fl)->int{\n            if(v==t) return fl;\n            used[v] = true;\n            REP(i,G[v].size()){\n                edge_ &e = G[v][i];\n                if(!used[e.to] && e.cap>0){\n                    int d = f(f, e.to,t,min(fl,e.cap));\n                    if(d>0){\n                        e.cap -= d;\n                        G[e.to][e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        };\n        int flow=0;\n        while(1){\n            used.assign(used.size(),false);\n            int f = dfs(dfs,s,t,INT_MAX);\n            if(f==0) return flow;\n            flow += f;\n        }\n    }\n    int bipartite_matching_calculate(const Graph &g){\n        int V = g.size();\n        vi match(V,-1);\n        vector<bool> used(V,false);\n        auto dfs = [&](auto&& f,int v)->bool{\n            used[v]=true;\n            REP(i,g[v].size()){\n                int u = g[v][i], w = match[u];\n                if(w<0 || !used[w] && f(f,w)){\n                    match[v]=u;\n                    match[u]=v;\n                    return true;\n                }\n            }\n            return false;\n        };\n        int res=0;\n        REP(v,V){\n            if(match[v] < 0){\n                used.assign(V,false);\n                if(dfs(dfs,v)) res++;\n            }\n        }\n        return res;\n    }\n    int bipartite_matching(int l,int r,function<bool(int,int)> F){\n        int V = l+r;\n        Graph G(V);\n        REP(i,l) REP(j,r) if(F(i,j)){\n            G[i].push_back(l+j);\n            G[l+j].push_back(i);\n        }\n        return bipartite_matching_calculate(G);\n    }\n};\nstruct compress{\n    map<ll,int> zip;\n    vector<ll> unzip;\n    compress(vector<ll> x){\n        unzip=x;\n        sort(All(x));\n        x.erase(unique(All(x)),x.end());\n        REP(i,x.size()){\n            zip[x[i]]=i;\n        }\n    }\n    int operator[](int k){return zip[unzip[k]];}\n};\nstruct edge{\n    int from;int to;ll cost;\n    void push(int a,int b,int c){\n        from=a;to=b;cost=c;\n    }\n    bool operator<(const edge& y) const{\n        if(cost!=y.cost) return cost<y.cost;\n        else if(to!=y.to) return to<y.to;\n        else return from<y.from;}\n    bool operator>(const edge& y) const{\n        if(cost!=y.cost) return cost>y.cost;\n        else if(to!=y.to) return to>y.to;\n        else return from>y.from;}\n    bool operator==(const edge& y) const{return *this==y;}\n};\nclass lca {\n  public:\n    const int n = 0;\n    const int log2_n = 0;\n    std::vector<std::vector<int>> parent;\n    std::vector<int> depth;\n\n    lca() {}\n\n    lca(const Graph &g, int root)\n        : n(g.size()), log2_n(log2(n) + 1), parent(log2_n, std::vector<int>(n)), depth(n) {\n        dfs(g, root, -1, 0);\n        for (int k = 0; k + 1 < log2_n; k++) {\n            for (int v = 0; v < (int)g.size(); v++) {\n                if (parent[k][v] < 0)\n                    parent[k + 1][v] = -1;\n                else\n                    parent[k + 1][v] = parent[k][parent[k][v]];\n            }\n        }\n    }\n\n    void dfs(const Graph &g, int v, int p, int d) {\n        parent[0][v] = p;\n        depth[v] = d;\n        REP(j,g[v].size()) {\n            if (g[v][j] != p) dfs(g, g[v][j], v, d + 1);\n        }\n    }\n\n    int get(int u, int v) {\n        if (depth[u] > depth[v]) std::swap(u, v);\n        for (int k = 0; k < log2_n; k++) {\n            if ((depth[v] - depth[u]) >> k & 1) {\n                v = parent[k][v];\n            }\n        }\n        if (u == v) return u;\n        for (int k = log2_n - 1; k >= 0; k--) {\n            if (parent[k][u] != parent[k][v]) {\n                u = parent[k][u];\n                v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n};\ntemplate <typename T,typename E> //SegmentTree((要素数) int n_,(演算) F f,(更新) G g,(初期値) T d1)\nstruct SegmentTree{\n  typedef function<T(T,T)> F;\n  typedef function<T(T,E)> G;\n  int n;\n  F f;\n  G g;\n  T d1;\n  E d0;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(int n_,F f,G g,T d1,\n\t      vector<T> v=vector<T>()):\n    f(f),g(g),d1(d1){\n    init(n_);\n    if(n_==(int)v.size()) build(n_,v);\n  }\n  void init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,d1);\n  }\n  void build(int n_, vector<T> v){\n    for(int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(int k,E a){\n    k+=n-1;\n    dat[k]=g(dat[k],a);\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  inline T query(int a,int b){\n    T vl=d1,vr=d1;\n    for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[(l++)-1]);\n      if(r&1) vr=f(dat[(--r)-1],vr);\n    }\n    return f(vl,vr);\n  }\n  \n};\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n\nvoid solve(){\n    int N,H,W;cin>>N>>H>>W;\n    vector<edge> e;\n    REP(i,N){\n        int r,c,a;\n        cin>>r>>c>>a;\n        r--;c--;\n        e.push_back({r,H+c,a});\n    }\n    ll ans=0;\n    sort(rAll(e));\n    UnionFind uni(H+W);\n    REP(i,e.size()){\n        int u=e[i].from,v=e[i].to;\n        ll c=e[i].cost;\n        if(uni.eize(u)<uni.size(u)||uni.eize(v)<uni.size(v)){\n            uni.unite(u,v);\n            ans+=c;\n        }\n    }\n    std::cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N = 200000 + 10, K = 20;\nint x[N],y[N],z[N],d[N],par[N],val[N];\nint find(int x){\n    if(x==par[x]) return x;\n    return par[x] = find(par[x]);\n}\nint main(){\n    int e,n,m;\n    scanf(\"%d%d%d\",&e,&n,&m);\n    for(int i=1;i<=e;i++){\n        scanf(\"%d%d%d\",&x[i],&y[i],&z[i]);\n        y[i] += n;\n        d[i] = i;\n    }\n    sort(d+1,d+1+e,[](int i,int j){\n         return z[i] > z[j];\n    });\n    ll ans = 0;\n    for(int i=1;i<=n+m;i++) par[i] = i;\n    for(int i=1;i<=e;i++){\n        int u = x[d[i]], v = y[d[i]], w = z[d[i]];\n        u = find(u), v = find(v);\n        if(u!=v&&val[u]+val[v]<=1){\n            val[v] |= val[u];\n            par[u] = v;\n            ans += w;\n        }\n        else if(val[u]==0){\n            val[u] = 1;\n            ans += w;\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define name \"bai5\"\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define fto(i,a,b) for(int i=a; i<=b;++i)\n#define maxn 100009\n#define ll long long\n\nusing namespace std;\nbool gone[maxn][3],ck[maxn][3];\nint cl[maxn];\nint xd[maxn][3],a[maxn][3],w,h,n;\npii b[maxn];\nbool check(int i, int x,int j){\n    if(!ck[i][x]) return false;\n    if(gone[i][x])return ck[i][x]=false;\n    gone[i][x]=true;\n    if(xd[i][x]==0){\n        xd[i][x]=j;\n        gone[i][x]=false;\n        return true;\n    }\n    /// xd[i][x]!=0;\n    /// i,x la cot hoac hang, j la chi so can dien\n    int t=xd[i][x];/// t la so can dien\n    if(check(a[t][1-x],1-x,t)){\n        xd[i][x]=j;\n        gone[i][x]=false;\n        return true;\n    }\n    gone[i][x]=false;\n    return ck[i][x]=false;\n}\nint main()\n{\n    cin >> n >> h >> w;\n    fto(i,1,n){\n        cin >> a[i][0]>> a[i][1] >> b[i].fi;\n        b[i].se=i;\n        ck[i][0]=ck[i][1]=true;\n    }\n    sort(b+1,b+n+1,greater<pii> ());\n    ll res=0;\n    fto(i,1,n){\n        int j=b[i].se;\n        if(check(a[j][0],0,j)){\n            //xd[a[j][0]][0]=j;\n            res+=b[i].fi;\n        }\n        else if(check(a[j][1],1,j)){\n            //xd[a[j][1]][1]=j;\n            res+=b[i].fi;\n        }\n    }\n    cout << res ;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> ii;\ntypedef long long ll;\n\nconst int Maxn = 300005;\n\nint n, H, W;\nint R[Maxn], C[Maxn], A[Maxn];\nint seq[Maxn];\nbool tk[Maxn], vis[Maxn];\nint oth[Maxn];\nll res;\n\nbool Less(const int &a, const int &b) { return A[a] > A[b]; }\n\nint Visit(int v)\n{\n    if (vis[v]) return -1;\n    vis[v] = true;\n    if (!tk[v]) return v;\n    int g = Visit(oth[v]);\n    if (g != -1) { tk[g] = true; tk[v] = false; return v; }\n    return -1;\n}\n\nint main()\n{\n    scanf(\"%d %d %d\", &n, &H, &W);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &R[i], &C[i], &A[i]);\n        seq[i] = i;\n    }\n    sort(seq, seq + n, Less);\n    for (int i = 0; i < n; i++) {\n        int ind = seq[i];\n        int v = Visit(R[ind]);\n        if (v != -1) {\n            tk[v] = true;\n            res += A[ind];\n            oth[R[ind]] = H + C[ind];\n            vis[R[ind]] = false;\n        } else {\n            v = Visit(H + C[ind]);\n            if (v != -1) {\n                tk[v] = true;\n                res += A[ind];\n                oth[H + C[ind]] = R[ind];\n                vis[H + C[ind]] = false;\n            }\n        }\n    }\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst long long mo = 1e9+7;\nconst int maxi = 1e6+10;\n#define pb push_back\nint n,k;\nstring s;\nvector<int> v[maxi];\nint a[maxi];\nint cnt[maxi];\nint ob[2][maxi];\nint c[maxi], r[maxi];\nmultiset<int> st[2][maxi];\nmultiset<pair<int, pair<int,int>>> global;\nint h,w;\nint main()\n{\n     cin>>n>>h>>w;\n\n     for (int i=1;i<=n;i++)\n     {\n          scanf(\"%d%d%d\",&r[i],&c[i],&a[i]);\n          st[1][r[i]].insert(a[i]);\n          st[2][c[i]].insert(a[i]);\n          global.insert({a[i], {r[i],c[i]}});\n     }\n\n     long long ans = 0;\n     while(!global.empty())\n     {\n          pair<int, pair<int,int>> node = *global.rbegin();\n\n          global.erase(global.find(node));\n          st[1][node.second.first].erase(st[1][node.second.first].find(node.first));\n          st[2][node.second.second].erase(st[2][node.second.second].find(node.first));\n\n          if (ob[1][node.second.first] && ob[2][node.second.second])\n              continue;\n          else\n            ans+=node.first;\n\n          if (ob[1][node.second.first] && !ob[2][node.second.second])\n              ob[2][node.second.second] = 1;\n           else\n            if (!ob[1][node.second.first] && ob[2][node.second.second])\n                ob[1][node.second.first] = 1;\n           else\n           {\n               int val1 = 0;\n               int val2 = 0;\n\n               if (st[1][node.second.first].size())\n                val1 = *st[1][node.second.first].rbegin();\n\n               if (st[2][node.second.second].size())\n                val2 = *st[2][node.second.second].rbegin();\n\n               if (val2>=val1)\n                 ob[1][node.second.first] = 1;\n               else\n                ob[2][node.second.second] = 1;\n           }\n     }\n\n     cout<<ans<<endl;\n    return 0;\n}\n//just a little magic\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\ntypedef long long ll;\n#define inf 0x3f3f3f3f\nint n,h,w;\nint x[maxn],y[maxn];\nll a[maxn];\nset<pair<ll,int> > qx[maxn],qy[maxn];\nvector<pair<ll,int> >cards;\nll ax,ay;\nbool ux[maxn],uy[maxn],usd[maxn];\nint cx[maxn],cy[maxn];\nqueue<int> que;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&h,&w);\n//\tmemset(cx,-1,sizeof(cx));\n//\tmemset(cy,-1,sizeof(cy));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%lld\",&x[i],&y[i],&a[i]);\n\t\tx[i]--;\n\t\ty[i]--;\n\t\tcx[x[i]]++;\n\t\tcy[y[i]]++;\n\t}\n    ll ans=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(cx[x[i]]==1||cy[y[i]]==1)\n\t\t\tque.push(i);\n\t\telse\n\t\t{\n\t\t\tqx[x[i]].insert(make_pair(a[i],i));\n\t\t\tqy[y[i]].insert(make_pair(a[i],i));\n\t\t}\n\t}\n\twhile(!que.empty())\n\t{\n\t\tint cur=que.front();\n\t\tque.pop();\n\t\tusd[cur]=1;\n\t\tans+=a[cur];\n\t\tusd[cur]=1;\n\t\tcx[x[cur]]--;\n\t\tcy[y[cur]]--;\n\t\tif(cx[x[cur]]==1)\n\t\t{\n\t\t\tif(!qx[x[cur]].empty())\n\t\t\t{\n\t\t\t\tpair<ll,int> he=*(qx[x[cur]].begin());\n\t\t\t\tqx[x[cur]].clear();\n\t\t\t\tint id=he.second;\n\t\t\t\tque.push(id);\n\t\t\t\tqy[y[id]].erase(he);\n\t\t\t}\n\t\t}\n\t\tif(cy[y[cur]]==1)\n\t\t{\n\t\t\tif(!qy[y[cur]].empty())\n\t\t\t{\n\t\t\t\tpair<ll,int> he=*(qy[y[cur]].begin());\n\t\t\t\tqy[y[cur]].clear();\n\t\t\t\tint id=he.second;\n\t\t\t\tque.push(id);\n\t\t\t\tqx[x[id]].erase(he);\n\t\t\t}\n\t\t}\n\t}\n//\tcout<<ans<<endl;\n\tfor(int i=0;i<n;i++)if(!usd[i])\n\t\tcards.push_back(make_pair(a[i],i));\n\n    sort(cards.begin(),cards.end());\n    reverse(cards.begin(),cards.end());\n    int p = 0;\n\t//for(int i = 0; i < cards.size(); ++i) printf(\"%d \", cards[i].first);\n    for(int i = 0; i < cards.size(); ++i) if(cards[p].first > cards[i].first){\n    \trandom_shuffle(cards.begin() + p, cards.begin() + i);\n    \tp = i;\n\t}\n\trandom_shuffle(cards.begin() + p, cards.end());\n    for(int _=0;_<cards.size();_++)\n    {\n    \tint i=cards[_].second;\n\t//\tcout<<i<<\" \"<<x[i]<<\" \"<<y[i]<<\" \"<<qx[x[i]].top().second<<\" \"<<qy[y[i]].top().second<<endl;\n        qx[x[i]].erase(make_pair(a[i],i));\n        qy[y[i]].erase(make_pair(a[i],i));\n        if(ux[x[i]]&&uy[y[i]])continue;\n        if(ux[x[i]])\n        \tuy[y[i]]=1;\n        else if(uy[y[i]])\n        \tux[x[i]]=1;\n        else\n\t\t{\n\t\t\tax=qx[x[i]].empty()?-inf:(*(qx[x[i]].rbegin())).first;\n\t\t\tay=qy[y[i]].empty()?-inf:(*(qy[y[i]].rbegin())).first;\n\t\t\tif(ax<ay)\n\t\t\t{\n        //   \tcout<<\"puthang \"<<x[i]<<endl;\n            \tux[x[i]]=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n      \t//    \tcout<<\"putlie \"<<y[i]<<endl;\n \t    \t\tuy[y[i]]=1;\n \t    \t}\n        }\n        ans+=a[i];\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define all(v) (v).begin(), (v).end()\n#define sortv(v) sort(all(v))\n#define uniqv(v) (v).erase(unique(all(v)), (v).end())\n#define pb push_back\n#define FI first\n#define SE second\n#define lb lower_bound\n#define ub upper_bound\n#define mp make_pair\n#define test 1\n#define TEST if(test)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\nconst int MOD = 1000000007; // 998244353\nconst int INF = 2e9;\nconst ll INFLL = 1e18;\nconst int MAX_N = 100000;\n\nint N, H, W;\n\n\nstruct S{\n\tint x, y, d;\n\tbool operator <(const S &a)const{\n\t\treturn d<a.d;\n\t}\n};\nvector<S> v;\n\nll ans;\n\nvector<int> gp[MAX_N*2+1];\nbool chk[MAX_N*2+1];\n\nvoid make(int x, int y){\n\tchk[x] = true;\n\tfor(int i : gp[x]){\n\t\tif(i!=y){\n\t\t\tmake(i, x);\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\tcin>>N>>H>>W;\n\tfor(int i=1; i<=N; i++){\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tv.pb((S){a, b+H, c});\n\t}\n\tsort(v.begin(), v.end());\n\twhile(!v.empty()){\n\t\tS now = v.back(); v.pop_back();\n\t\tif(gp[now.x].size()<=1 && gp[now.y].size()<=1){\n\t\t\tgp[now.x].pb(now.y);\n\t\t\tif(gp[now.x].size()==2)\tchk[now.x] = true;\n\t\t\tgp[now.y].pb(now.x);\n\t\t\tif(gp[now.y].size()==2)\tchk[now.y] = true;\n\t\t\tans+=(ll)now.d;\n\t\t}\n\t\telse{\n\t\t\tif(chk[now.x] && (!chk[now.y] && gp[now.y].size()<=1)){\n\t\t\t\tmake(now.y, 0);\n\t\t\t\tans+=(ll)now.d;\n\t\t\t}else if((gp[now.x].size()<=1 && !chk[now.x]) && chk[now.y]){\n\t\t\t\tmake(now.x, 0);\n\t\t\t\tans+=(ll)now.d;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing VI = vector<int>;\n#define FOR(i,a,n) for(int (i)=(a);(i)<(n);(i)++)\n#define eFOR(i,a,n) for(int (i)=(a);(i)<=(n);(i)++)\n#define SORT(i) sort((i).begin(),(i).end())\n#define rSORT(i,a) sort((i).begin(),(i).end(),(a))\nconstexpr auto INF = 1000000000;\nconstexpr auto LLINF = 1LL << 60;\nconstexpr ll mod = 1000000007;\nconstexpr auto MOD = 998244353;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; }return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; }return 0; }\n\nstruct edge {\n    int from, to; ll cost;\n    edge(int s, int t, ll w) : from(s), to(t), cost(w) {}\n};\n\nclass unionfind {\n    vector<int> par, rank;\npublic:\n    unionfind(int n) : par(n), rank(n, 1) {\n        for (int i = 0; i < n; i++)par[i] = i;\n    }\n    void init(int n) {\n        par.clear();\n        rank.clear();\n        par.resize(n);\n        rank.resize(n);\n        for (int i = 0; i < n; i++)par[i] = i;\n        for (int i = 0; i < n; i++)rank[i] = 1;\n    }\n    int root(int x) {\n        if (par[x] == x)return x;\n        return par[x] = root(par[x]);\n    }\n    int size(int x) {\n        if (par[x] == x)return rank[x];\n        return size(par[x]);\n    }\n    void unite(int x, int y) {\n        int rx = root(x);\n        int ry = root(y);\n        if (rx == ry)return;\n        if (rank[rx] < rank[ry]) {\n            par[rx] = ry;\n            rank[ry] += rank[rx];\n        }\n        else {\n            par[ry] = rx;\n            rank[rx] += rank[ry];\n        }\n    }\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n};\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int n, h, w;\n    cin >> n >> h >> w;\n\n    vector<edge> g;\n    int r, c; ll a;\n    FOR(i, 0, n) {\n        cin >> r >> c >> a;\n        g.push_back({ r, h + c, a });\n    }\n\n    rSORT(g, [](edge x, edge y) {return x.cost > y.cost; });\n    unionfind uf(h + w + 1);\n    ll ans = 0;\n    FOR(i, 0, n) {\n        if (!uf.same(g[i].from, g[i].to)) {\n            ans += g[i].cost;\n            uf.unite(g[i].from, g[i].to);\n        }\n        else if (!uf.same(g[i].from, 0)) {\n            ans += g[i].cost;\n            uf.unite(g[i].from, 0);\n        }\n    }\n\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\n// Verified: AOJ-DSL1A\nclass UFSet {\n private:\n  vector<int> ranks;\n  vector<int> prevs;\n\n public:\n  UFSet(int n) : ranks(n), prevs(n) {\n    for (int i = 0; i < n; i++) prevs[i] = i;\n  }\n\n  // Returns a root of a tree which x belongs to.\n  int Find(int x) {\n    if (x != prevs[x]) prevs[x] = Find(prevs[x]);\n    return prevs[x];\n  }\n\n  // Merges a set which x blongs to and a set which y belongs to.\n  void Union(int x, int y) {\n    int x_root = Find(x);\n    int y_root = Find(y);\n    if (ranks[x_root] > ranks[y_root]) {\n      prevs[y_root] = prevs[x_root];\n    } else if (ranks[x_root] < ranks[y_root]) {\n      prevs[x_root] = prevs[y_root];\n    } else if (prevs[x_root] != prevs[y_root]) {\n      prevs[y_root] = prevs[x_root];\n      ranks[x_root]++;\n    }\n  }\n};\n\nstruct WeightedEdge {\n  int v1, v2;\n  int64 weight;\n  WeightedEdge(int v1, int v2, int64 weight)\n      : v1(v1), v2(v2), weight(weight) {}\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, h, w;\n  cin >> n >> h >> w;\n  vector<WeightedEdge> edges;\n  for (int i = 0; i < n; i++) {\n    int r, c;\n    int64 weight;\n    cin >> r >> c >> weight;\n    r--;\n    c--;\n    edges.emplace_back(r, h + c, weight);\n  }\n  sort(edges.begin(), edges.end(), [](const auto& e1, const auto& e2) {\n    return e1.weight > e2.weight;\n  });\n\n  UFSet uf_set(h + w);\n  vector<int> has_cycle_vector(h + w);\n  int64 answer = 0;\n  for (const auto& e : edges) {\n    int s1 = uf_set.Find(e.v1);\n    int s2 = uf_set.Find(e.v2);\n    if (s1 != s2) {\n      if (has_cycle_vector[s1] && has_cycle_vector[s2]) continue;\n      int new_has_cycle = has_cycle_vector[s1] || has_cycle_vector[s2];\n      uf_set.Union(e.v1, e.v2);\n      int s3 = uf_set.Find(e.v1);\n      has_cycle_vector[s3] = new_has_cycle;\n      answer += e.weight;\n    } else {\n      if (has_cycle_vector[s1]) continue;\n      has_cycle_vector[s1] = true;\n      answer += e.weight;\n    }\n  }\n  cout << answer << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <map>\n#include <memory>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n#include <random>\n#include <tuple>\n#include <iomanip>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n//typedef pair<int,int> Pint;\n//typedef pair<ll, ll> P;\n//typedef pair<ll, pair<ll, ll>> P;\n//typedef tuple<int,int,int> T;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n#define rep(i, n) for(ll i = 0; i < (n); i++)\n#define revrep(i, n) for(ll i = (n-1); i >= 0; i--)\n#define pb push_back\n#define f first\n#define s second\n//const ll INFL = 1LL << 60;//10^18 = 2^60\nconst ll INFL = 1LL << 60;\nconst int INF = 1 << 30;//10^9\nll MOD = 1000000007;\n//ll MOD  = 998244353;\nvector<ll> dy = {0, 0, 1, -1, 1, 1, -1, -1, 0};\nvector<ll> dx = {1, -1, 0, 0, 1, -1, 1, -1, 0};\n\nll max(ll a, ll b){return (a > b) ? a : b;}\nll min(ll a, ll b){return (a < b) ? a : b;}\nll pow_long(ll x, ll k){\n  ll res = 1;\n  while(k > 0){\n    if(k % 2) res *= x;\n    x *= x;\n    k /= 2;\n  }\n  return res;\n}\nll pow_mod(ll x, ll k){\n  x %= MOD; x += MOD; x %= MOD;\n  ll res = 1;\n  while(k > 0){\n    if(k % 2){\n      res *= x; res %= MOD;\n    }\n    x *= x; x %= MOD;\n    k /= 2;\n  }\n  return res;\n}\nll inverse(ll x){return pow_mod(x, MOD - 2);};\n\n//最大公約数\nll gcd(ll a, ll b){\n    if(b == 0) return a;\n    return gcd(b, a % b);\n}\n\n//最小公倍数\nll lcm(ll x, ll y){return x / gcd(x, y) * y;};\n\nll kai_mod(ll x){\n  if(x == 0) return 1;\n  return x * kai_mod(x-1) % MOD;\n}\n\n//コンビネーション\nconst int MAXcomb = 200010;\nll fac[MAXcomb], finv[MAXcomb], inv[MAXcomb];\n//facはn!,finvは1/n!\n//invは逆元\nvoid COMinit(){\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for(int i = 2; i < MAXcomb; i++){\n        fac[i] = fac[i-1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD/i) % MOD;\n        finv[i] = finv[i-1] * inv[i] % MOD;\n    }\n}\nll comb(int n, int k){\n    if(n < k) return 0;\n    if(n < 0 || k < 0) return 0;\n    return fac[n] * finv[k] % MOD * finv[n-k] % MOD;\n}\n\nconst ll MAX_V = 200010;\n\nll par[MAX_V];\nll Rank[MAX_V];\nll child[MAX_V];\nll e[MAX_V];\n\nvoid init_UF(ll n){\n    for(ll i = 0; i < n; i++){\n        par[i] = i;\n        Rank[i] = 1;\n        child[i] = 1;\n    }\n}\n\nll find(ll x){\n    if(par[x] == x) return x;\n    else{\n        return par[x] = find(par[x]);\n    }\n}\n\nbool same(ll x, ll y){\n    return find(x) == find(y);\n}\n\nvoid unite(ll x, ll y){\n    ll rx = find(x), ry = find(y);\n    if(rx != ry){\n        if(Rank[rx] >= Rank[ry]){\n            par[ry] = rx;\n            if(Rank[rx] == Rank[ry]) Rank[rx]++;\n            child[rx] += child[ry];\n        }else{\n            par[rx] = ry;\n            child[ry] += child[rx];\n        }\n        e[par[rx]] = e[rx] + e[ry] + 1;\n    }else{\n      e[rx]++;\n    }\n}\n\nll N, H, W;\nvector<pair<ll, pair<ll, ll>>> A;\n\nint main(){\n  cin >> N >> H >> W;\n  A.resize(N);\n  rep(i, N){\n    cin >> A[i].s.f >> A[i].s.s >> A[i].f;\n    A[i].s.s += H;\n  }\n  sort(A.begin(), A.end());\n  reverse(A.begin(), A.end());\n  init_UF(N);\n  ll ans = 0;\n  rep(i, N){\n    ll r = A[i].s.f;\n    ll c = A[i].s.s;\n    if(same(r, c)){\n      ll rr = find(r);\n      if(e[rr] + 1 <= child[rr]){\n        ans += A[i].f;\n        unite(r, c);\n      }\n    }else{\n      ll rr = find(r);\n      ll rc = find(c);\n      if(e[rr] + e[rc] + 1 <= child[rr] + child[rc]){\n        ans += A[i].f;\n        unite(r, c);\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <queue>\n#include <ctime>\n#include <cassert>\n#include <complex>\n#include <string>\n#include <cstring>\n#include <chrono>\n#include <random>\n#include <queue>\n#include <bitset>\nusing namespace std;\n\n#ifdef LOCAL\n\t#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n\t#define eprintf(...) 42\n#endif\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\ntypedef long double ld;\n#define mp make_pair\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 200200;\nint n, m, k;\nint par[N];\nint sz[N];\nbool f[N];\n\nstruct Edge {\n\tint v, u;\n\tll w;\n\n\tEdge() : v(), u(), w() {}\n\n\tvoid scan() {\n\t\tscanf(\"%d%d%lld\", &v, &u, &w);\n\t\tv--;\n\t\tu--;\n\t\tu += n;\n\t}\n\n\tbool operator < (const Edge &e) const {\n\t\treturn w > e.w;\n\t}\n};\nEdge ed[N];\n\nint getPar(int v) {\n\treturn par[v] == -1 ? v : par[v] = getPar(par[v]);\n}\nbool unite(int v, int u) {\n\tv = getPar(v);\n\tu = getPar(u);\n\tif (v == u) {\n\t\tif (f[v]) return false;\n\t\tf[v] = true;\n\t\treturn true;\n\t}\n\tif (f[v] && f[u]) return false;\n\tif (sz[v] < sz[u]) swap(v, u);\n\tsz[v] += sz[u];\n\tf[v] |= f[u];\n\tpar[u] = v;\n\treturn true;\n}\n\nint main()\n{\n//\tfreopen(\"input.txt\", \"r\", stdin);\n//\tfreopen(\"output.txt\", \"w\", stdout);\n\n\tscanf(\"%d%d%d\", &m, &n, &k);\n\tfor (int i = 0; i < m; i++)\n\t\ted[i].scan();\n\tn += k;\n\tsort(ed, ed + m);\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = -1;\n\t\tsz[i] = 1;\n\t\tf[i] = 0;\n\t}\n\tll ans = 0;\n\tfor (int i = 0; i < m; i++)\n\t\tif (unite(ed[i].v, ed[i].u))\n\t\t\tans += ed[i].w;\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<set>\n#include<bitset>\n#include<ctime>\nusing namespace std;\n#define int long long\n#define mod 1000000009\n#define inf 4444444444444444444\n#define mn 200005\n#define pii pair <int, int>\n#define XX first\n#define YY second\n\nvector <int> alist[mn];\npair <int, pii> C[mn];\n\nint MX[mn], passed[mn];\nint switched[mn]; //switched[i] to see if we have altered i in the past. \n//If we did, and recursion reaches i, it should stop\nbool maxMatching(int u, int clr)\n{\n    if (passed[u]==clr) return 0;\n    passed[u]=clr;\n    for (int v:alist[u])\n    {\n    \tif (MX[v]==0) \n    \t{\n    \t\tMX[v]=u;\n    \t\treturn 1;\n    \t}\n    \telse if (switched[MX[v]]==0)\n    \t{\n    \t\tif (maxMatching(MX[v], clr)==1)\n    \t\t{\n    \t\t\tswitched[MX[v]]=1;\n    \t\t\tMX[v]=u;\n    \t\t\treturn 1;\n    \t\t}\n    \t}\n    }\n    return 0;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    srand(time(0));\n    \n    int n, h, w;\n    cin>>n>>h>>w;\n    int r, c, a;\n    for (int i=1; i<=n; i++)\n    {\n    \tcin>>r>>c>>a;\n    \tC[i]={a, {r, c}};\n    }\n    sort(C+1, C+n+1);\n    for (int i=1; i<=n; i++)\n    {\n    \talist[i].push_back(C[i].YY.XX);\n    \talist[i].push_back(C[i].YY.YY+100000);\n    \t\n    \trandom_shuffle(alist[i].begin(), alist[i].end());\n    }\n    \n    int ans=0;\n    for (int i=n; i>=1; i--) if (maxMatching(i, i)) ans+=C[i].XX;\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> // Tomasz Nowak\nusing namespace std;     // XIII LO Szczecin\nusing LL = long long;    // Poland\n#define FOR(i, l, r) for(int i = (l); i <= (r); ++i)\n#define REP(i, n) FOR(i, 0, (n) - 1)\ntemplate<class T> int size(T &&x) {\n\treturn int(x.size());\n}\ntemplate<class A, class B> ostream& operator<<(ostream &out, const pair<A, B> &p) {\n\treturn out << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate<class T> auto operator<<(ostream &out, T &&x) -> decltype(x.begin(), out) {\n\tout << '{';\n\tfor(auto it = x.begin(); it != x.end(); ++it)\n\t\tout << *it << (it == prev(x.end()) ? \"\" : \", \");\n\treturn out << '}';\n}\nvoid dump() {}\ntemplate<class T, class... Args> void dump(T &&x, Args... args) {\n\tcerr << x << \";  \";\n\tdump(args...);\n}\n#ifdef DEBUG\n  struct Nl{~Nl(){cerr << '\\n';}};\n# define debug(x...) cerr << (strcmp(#x, \"\") ? #x \":  \" : \"\"), dump(x), Nl(), cerr << \"\"\n#else\n# define debug(...) 0 && cerr\n#endif\nmt19937_64 rng(0);\nint rd(int l, int r) {\n\treturn uniform_int_distribution<int>(l, r)(rng);\n}\n// end of templates\n\nstruct MCMF {\n\tstruct Edge {\n\t\tint v, u, flow, cap;\n\t\tLL cost;\n\t\tfriend ostream& operator<<(ostream &os, Edge &e) {\n\t\t\treturn os << vector<LL>{e.v, e.u, e.flow, e.cap, e.cost};\n\t\t}\n\t};\n\n\tint n;\n\tconst LL inf_LL = 0x3f3f3f3f3f3f3f3f;\n\tconst int inf_int = 0x3f3f3f3f;\n\tvector<vector<int>> graph;\n\tvector<Edge> edges;\n\n\tMCMF(int N) : n(N), graph(n) {}\n\n\tvoid add_edge(int v, int u, int cap, LL cost) {\n\t\tdebug() << \"adding edge \" << v << '-' << u << \": \" << make_pair(cap, cost);\n\t\tint e = size(edges);\n\t\tgraph[v].emplace_back(e);\n\t\tgraph[u].emplace_back(e + 1);\n\t\tedges.emplace_back(Edge{v, u, 0, cap, cost});\n\t\tedges.emplace_back(Edge{u, v, 0, 0, -cost});\n\t}\n\n\tpair<int, LL> augment(int source, int sink) {\n\t\tvector<LL> dist(n, inf_LL);\n\t\tvector<int> from(n, -1);\n\t\tdist[source] = 0;\n\t\tdeque<int> que = {source};\n\t\tvector<bool> inside(n);\n\t\tinside[source] = true;\n\n\t\twhile(size(que)) {\n\t\t\tint v = que.front();\n\t\t\tinside[v] = false;\n\t\t\tque.pop_front();\n\n\t\t\tfor(int i : graph[v]) {\n\t\t\t\tEdge &e = edges[i];\n\t\t\t\tif(e.flow != e.cap and dist[e.u] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.u] = dist[v] + e.cost;\n\t\t\t\t\tfrom[e.u] = i;\n\t\t\t\t\tif(not inside[e.u]) {\n\t\t\t\t\t\tinside[e.u] = true;\n\t\t\t\t\t\tque.emplace_back(e.u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(from[sink] == -1)\n\t\t\treturn {0, 0};\n\n\t\tint flow = inf_int, e = from[sink];\n\t\twhile(e != -1) {\n\t\t\tflow = min(flow, edges[e].cap - edges[e].flow);\n\t\t\te = from[edges[e].v];\n\t\t}\n\t\te = from[sink];\n\t\twhile(e != -1) {\n\t\t\tedges[e].flow += flow;\n\t\t\tedges[e ^ 1].flow -= flow;\n\t\t\te = from[edges[e].v];\n\t\t}\n\t\treturn {flow, flow * dist[sink]};\n\t}\n\n\tpair<int, LL> operator()(int source, int sink) {\n\t\tint flow = 0;\n\t\tLL cost = 0;\n\t\tpair<int, LL> got;\n\t\tdo {\n\t\t\tgot = augment(source, sink);\n\t\t\tflow += got.first;\n\t\t\tcost += got.second;\n\t\t} while(got.first);\n\t\treturn {flow, cost};\n\t}\n};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n, h, w;\n\tcin >> n >> h >> w;\n\tvector<bool> used(h + w);\n\tvector<int> a(n);\n\tvector<vector<int>> edges(n);\n\tLL answer = 0;\n\n\tvector<pair<int, int>> sorted;\n\tREP(q, n) {\n\t\tint r, c, cost;\n\t\tcin >> r >> c >> cost;\n\t\t--r, --c;\n\t\ta[q] = cost;\n\t\tedges[q] = {r, h + c};\n\t\tsorted.emplace_back(a[q], q);\n\t}\n\tsort(sorted.rbegin(), sorted.rend());\n\tdebug(sorted);\n\n\tvector<int> match(h + w, -1);\n\tvector<int> vis(n, 0);\n\tint vis_cnt = 0;\n\n\tfunction<bool (int)> ask = [&](int q) {\n\t\tvis[q] = vis_cnt;\n\t\tREP(d, 2)\n\t\t\tif(match[edges[q][d]] == -1) {\n\t\t\t\tmatch[edges[q][d]] = q;\n\t\t\t\treturn true;\n\t\t\t}\n\t\tREP(d, 2)\n\t\t\tif(vis[match[edges[q][d]]] != vis_cnt and ask(match[edges[q][d]])) {\n\t\t\t\tmatch[edges[q][d]] = q;\n\t\t\t\treturn true;\n\t\t\t}\n\t\treturn false;\n\t};\n\n\tfor(auto &p : sorted) {\n\t\t++vis_cnt;\n\t\tif(ask(p.second))\n\t\t\tanswer += a[p.second];\n\t}\n\n\tcout << answer << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MOD 1000000007\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n\n#define MAX 100002\n\nint n;\nint h;\nint w;\n\n\n#include \"bits/stdc++.h\"\n#include<quadmath.h>\n#include<thread>\nusing namespace std;\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n \n  struct edge {\n    int to;\n    flow_t cap;\n    cost_t cost;\n    int rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< int > prevv, preve;\n \n  PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n \n  void add_edge(int from, int to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n  }\n \n  cost_t min_cost_flow(int s, int t, flow_t f) {\n    int V = (int) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, int >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n \n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return ret;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n \n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n      }\n    }\n  }\n};\nPrimalDual<int,long long int> f(300002);\n\nvoid add_edge(int from,int to,int cap,long long int cost){\n\tf.add_edge(from,to,cap,cost);\n}\n\nint main(){\n\tcin>>n>>h>>w;\n\tfor(int i=0;i<h+w;i++){\n\t\tadd_edge(0,1+i,1,0);\n\t}\n\tfor(int i=0;i<n;i++){\n\t\tint r,c,a;\n\t\tscanf(\"%d%d%d\",&r,&c,&a);\n\t\tr--;\n\t\tc--;\n\t\tadd_edge(1+r,1+h+w+i,1,-a);\n\t\tadd_edge(1+h+c,1+h+w+i,1,-a);\n\t\tadd_edge(1+h+w+i,1+h+w+n,1,0);\n\t}\n\tauto ans = -f.min_cost_flow(0,1+h+w+n,h+w);\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <vector>\n#include <utility>\n#include <string>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <numeric>\n#include <tuple>\n\ntemplate <class Tp>\nstruct edge {\n  size_t dst;\n  Tp cap, cost;\n  size_t rev;\n  edge(size_t dst, Tp cap, Tp cost, size_t rev):\n    dst(dst), cap(cap), cost(cost), rev(rev)\n  {}\n};\n\ntemplate <class Tp>\nstruct graph: public std::vector<std::vector<edge<Tp>>> {\n  graph(size_t n): std::vector<std::vector<edge<Tp>>>(n) {}\n\n  void connect_to(size_t src, size_t dst, Tp cost) {\n    (*this)[src].emplace_back(dst, 1, cost, (*this)[dst].size());\n    (*this)[dst].emplace_back(src, 0, -cost, (*this)[src].size()-1);\n  }\n};\n\ntemplate <class Tp>\nTp inf() { return 1 << 29; }\n\ntemplate <class Tp>\nTp mincost_flow(graph<Tp>& g, size_t s, size_t t, Tp f) {\n  Tp res = 0;\n  Tp max = inf<Tp>();\n  while (f > 0) {\n    std::vector<Tp> dist(g.size(), inf<Tp>());\n    std::vector<size_t> pv(g.size()), pe(g.size());\n    dist[s] = 0;\n    bool updated = true;\n    while (updated) {\n      updated = false;\n      for (size_t v = 0; v < g.size(); ++v) {\n        if (dist[v] == max) continue;\n\n        for (size_t i = 0; i < g[v].size(); ++i) {\n          edge<Tp>& e = g[v][i];\n          if (e.cap > 0 && dist[e.dst] > dist[v] + e.cost) {\n            dist[e.dst] = dist[v] + e.cost;\n            pv[e.dst] = v;\n            pe[e.dst] = i;\n            updated = true;\n          }\n        }\n      }\n    }\n\n    if (dist[t] == max) return -1;\n    Tp d = f;\n    for (size_t v = t; v != s; v = pv[v])\n      d = std::min(d, g[pv[v]][pe[v]].cap);\n\n    f -= d;\n    res += d * dist[t];\n    for (size_t v = t; v != s; v = pv[v]) {\n      edge<Tp>& e = g[pv[v]][pe[v]];\n      e.cap -= d;\n      g[v][e.rev].cap += d;\n    }\n  }\n  return res;\n}\n\nint main() {\n  size_t N, H, W;\n  scanf(\"%zu %zu %zu\", &N, &H, &W);\n\n  graph<intmax_t> g(2*N+H+W+2);\n  size_t M = g.size()-1;\n  for (size_t i = 1; i <= H; ++i) g.connect_to(0, i, 0);\n  for (size_t i = 1; i <= W; ++i) g.connect_to(0, H+i, 0);\n\n  for (size_t i = 0; i < N; ++i) {\n    size_t R, C;\n    intmax_t A;\n    scanf(\"%zu %zu %jd\", &R, &C, &A);\n    C += H;\n\n    size_t si = H+W+1+2*i;\n    size_t sj = si+1;\n    g.connect_to(R, si, 0);\n    g.connect_to(C, si, 0);\n    g.connect_to(si, sj, -A);\n    g.connect_to(sj, M, 0);\n  }\n\n  printf(\"%jd\\n\", -mincost_flow(g, 0, M, intmax_t(H+W)));\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int gcd(int v,int b){\n                                \tif(v>b) return gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                                \n                int pr[1000010];\n                int inv[1000010];\n                \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=(pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n      \n       \n       \n                               //----------------kokomade tenpure------------\n\nstruct unionfind{\n\tprivate:\n\tpublic:\n\t\nvector<int> par,ranks,kosuu,edasu;\n\t\n\tvoid shoki(int N){\n\t\tpar.resize(N+1,0);\n\t\tranks.resize(N+1,0);\n\t\tkosuu.resize(N+1,1);\n\t\tedasu.resize(N+1,0);\n\t\t\n\t\tfor(int i=0;i<=N;i++){\n\t\t\tpar[i]=i;\n\t\t}\n\t}\n\n\tint root(int x){\n\t\treturn par[x]==x ? x : par[x]=root(par[x]);\n\t}\n\n\tbool same(int x,int y){\n\t\treturn root(x)==root(y);\n\t}\n\tbool is_root(int x){\n\t\treturn x==root(x);\n\t}\n\tvoid unite(int x,int y){\n \t\tx=root(x);\n\t \ty=root(y);\n\t\tint xx=kosuu[x],yy=kosuu[y];\n\t\tint xxx=edasu[x],yyy=edasu[y];\n\t\tif(x==y){\n\t\t\tedasu[x]++;\n\t\t\treturn;\n\t\t\n\t\t}\n\t\t\n\t\tif(ranks[x]<ranks[y]){\n\t\t\tpar[x]=y;\n\t\t\tkosuu[y]=yy+xx;\n\t\t\tedasu[y]=xxx+yyy+1;\n\t\t}\n\t \telse {\n\t\t\tpar[y]=x;\n\t\t\tif(ranks[x]==ranks[y]) ranks[x]=ranks[x]+1;\n\t \t\tkosuu[x]=yy+xx;\n\t \t\t\t\tedasu[x]=1+xxx+yyy;\n\t\n\t \t}\n\t\treturn;\n\t}\n};\n\n\n signed main(){\n \t\n \n    cin.tie(0);\n\tios::sync_with_stdio(false);\n\t\nint n;\n \tcin>>n;\n\n \tint h,w;\n \tcin>>h>>w;\n \t\n \t\n \tvector<pa3> ve;\n \tfor(int i=0;i<n;i++){\n \t\tint y,yy,yyy;\n \t\n \t\tcin>>y>>yy>>yyy;\n \t\ty--,yy--;\n \t\tyy+=h;\n \t\tve.pb((pa3){-yyy,y,yy});\n \t}\n \tsort(ve.begin(),ve.end());\n \t\n \tunionfind uf;\n \tuf.shoki(h+w);\n \tint ans=0;\n \tfor(auto v:ve){\n \t\tint x=v.y,y=v.z;\n \t\tint sc=-v.x;\n \t\t\n \t\tif(uf.same(x,y)){\n \t\t\tif(uf.edasu[uf.root(x)]==uf.kosuu[uf.root(x)]) continue;\n \t\t\tuf.unite(x,y);\n \t\t\tans+=sc;\n \t\t}\n \t\telse{\n \t\t\tint xx=uf.root(x);\n \t\t\tint yy=uf.root(y);\n \t\t\t\n \t\t\tif(uf.edasu[uf.root(xx)]==uf.kosuu[uf.root(xx)] && uf.edasu[uf.root(yy)]==uf.kosuu[uf.root(yy)]){\n \t\t\t\tcontinue;\n \t\t\t}\n \t\tuf.unite(x,y);\n \t\t\tans+=sc;\n \t\t\t\n \t\t}\n \t\t\n //\t\tcout<<x<<\" \"<<y<<endl;\n \t}\n \tcout<<ans<<endl;\n \t\n \t\n \t\nreturn 0;\n\n }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define VSORT(v) sort(v.begin(), v.end())\n#define VRSORT(v) sort(v.rbegin(), v.rend())\n#define ll long long\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef pair<int, P> PP;\ntypedef pair<ll, LP> LPP;\ntypedef vector<unsigned int>vec;\ntypedef vector<vec> mat;\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int INF = 1000000000;\nconst ll LINF = 1000000000000000000;//1e18\nconst ll  MOD = 1000000007;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-10;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline void add(T &a, T b){a = ((a+b) % MOD + MOD) % MOD;};\n\nstruct UnionFind {\n    vector<int> par;\n    \n    UnionFind(int n) : par(n, -1) { }\n    void init(int n) { par.assign(n, -1); }\n    \n    int root(int x) {\n        if (par[x] < 0) return x;\n        else return par[x] = root(par[x]);\n    }\n    \n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n    \n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (par[x] > par[y]) swap(x, y); // merge technique\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    \n    int size(int x) {\n        return -par[root(x)];\n    }\n};\n\nstruct edge{\n    ll from, to, cost;\n    edge(ll s, ll d, ll w) : from(s), to(d), cost(w){}\n    \n    bool operator < (const edge& x) const {\n        return cost < x.cost;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, H, W;\n    cin >> N >> H >> W;\n    vector<edge> e;\n\n    UnionFind uf(H + W + 10);\n\n    REP(i,N){\n        ll R, C, A;\n        cin >> R >> C >> A;\n        e.emplace_back(R, C+H, -A);\n    }\n\n    sort(e.begin(), e.end());\n    \n    ll ans = 0;\n\n    REP(i,N){\n        if(!uf.issame(e[i].from, e[i].to)){\n            ans += e[i].cost;\n            uf.unite(e[i].from, e[i].to);\n        }\n        /*else{\n            if(!uf.issame(e[i].from, 0)){\n                ans += e[i].cost;\n                uf.unite(e[i].from,0);\n            }\n        }*/\n    }\n    cout << ans * (-1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#include <fstream>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n\n#define LLINF 1e18+7\n#define N 250000\nll MOD=1e9+7;\n\n\nint G[600][600];\n\nstruct UnionFind{\n    vector<int> par,sizes;\n    UnionFind(int n):par(n+1),sizes(n+1,1){\n        rep2(i,1,n)par[i]=i;\n    }\n    int find(int x){\n        return (x==par[x]?x:par[x]=find(par[x]));\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return ;\n        if(sizes[x]<sizes[y]){\n            swap(x,y);\n        }\n        par[y]=x;\n        sizes[x]+=sizes[y];\n    }\n    bool same(int x,int y) {return (find(x)==find(y));}\n    int size(int x) {return sizes[find(x)];}\n};\nmain(){\n    int n=in();\n    int h=in(),w=in();\n    UnionFind uf(h+w+10);\n    vector<pair<ll,pii>> v;\n    rep(i,n){\n        int r=in(),c=in(),a=in();\n        v.pb({a,{r,c+h}});\n        uf.unite(r,c+h);\n    }\n    vector<vector<pair<ll,pii>>> W(h+w+10);\n    vec t;\n    rep(i,n){\n        int s=uf.find(v[i].second.first);\n        W[s].pb(v[i]);\n        t.pb(s);\n        //cout<<s<<endl;\n    }\n    sort(all(t));\n    ll ans=0;\n    t.erase(unique(all(t)),t.end());\n    UnionFind uf2(h+w+10);\n    vec used(h+w+10);\n    for(auto e:t){\n        sort(all(W[e]),greater<pair<ll,pii>>());\n        rep(i,W[e].size()){\n            //cout<<W[e][i].first<<\" \"<<W[e][i].second.first<<W[e][i].second.second<<endl;\n            if(!uf2.same(W[e][i].second.first,W[e][i].second.second)){\n                if(used[uf2.find(W[e][i].second.first)]&&used[uf2.find(W[e][i].second.second)]){\n                    continue;\n                }\n                uf2.unite(W[e][i].second.first,W[e][i].second.second);\n                if(used[W[e][i].second.first]||used[W[e][i].second.second]){\n                    used[uf2.find(W[e][i].second.second)]=1;\n                }\n                ans+=W[e][i].first;\n            }\n            else{\n                if(!used[uf2.find(W[e][i].second.second)]){\n                    used[uf2.find(W[e][i].second.second)]=1;\n                    ans+=W[e][i].first;\n                }\n            }\n\n        }\n\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long llong;\n\nconst int maxn=2e5+10;\n\nclass card{\npublic:\n    int v,rw,cl;\n    card() {}\n    card(int v,int rw,int cl):v(v),rw(rw),cl(cl){}\n    bool operator < (const card &crd) const\n    {\n        return v>crd.v;\n    }\n\n};\n\nint N,H,W;\nvector<card> vec;\nvector<int> vr[maxn],vc[maxn];\nbool vstr[maxn],vstc[maxn];\n\nint main()\n{\n    cin>>N>>H>>W;\n    int R,C,A;\n    for(int i=0;i<N;i++)\n    {\n        cin>>R>>C>>A;\n        vr[R].push_back(A);\n        vc[C].push_back(A);\n        vec.push_back(card(A,R,C));\n\n    }\n    for(int i=1;i<=H;i++)\n       sort(vr[i].begin(),vr[i].end(),greater<int>());\n    for(int i=1;i<=W;i++)\n      sort(vc[i].begin(),vc[i].end(),greater<int>());\n    sort(vec.begin(),vec.end());\n\n    llong ans=0;\n    for(int i=0;i<N;i++)\n    {\n        if(vstr[vec[i].rw]&&vstc[vec[i].cl]) continue;\n        else if(vstr[vec[i].rw]&&!vstc[vec[i].cl]) {ans+=vec[i].v*1LL;vstc[vec[i].cl]=true;continue;}\n        else if(!vstr[vec[i].rw]&&vstc[vec[i].cl]) {ans+=vec[i].v*1LL;vstr[vec[i].rw]=true;continue;}\n        else{\n        int v=vec[i].v,rw=vec[i].rw,cl=vec[i].cl;\n        ans+=v*1LL;\n        if(vr[rw][0]!=v&&vc[cl][0]!=v) continue;\n        else if(vr[rw][0]==v&&vc[cl][0]!=v) vstr[rw]=true;\n        else if(vr[rw][0]!=v&&vc[cl][0]==v) vstc[cl]=true;\n        else\n        {\n            if(vr[rw].size()==1&&vc[cl].size()==1) {vstr[rw]=true;vstc[cl]=true;continue;}\n            else if(vr[rw].size()==1||(vc[cl].size()>1&&vr[rw][1]<vc[cl][1])) vstr[rw]=true;\n            else if(vc[cl].size()==1||(vr[rw].size()>1&&vr[rw][1]>=vc[cl][1]))vstc[cl]=true;\n        }\n    }\n    }\n    cout<<ans<<endl;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\nstruct BiMatch{\n    int L,R;\n    vector<vector<int> > G;\n    vector<int> match,level;\n\n    BiMatch(){}\n    BiMatch(int L,int R):L(L),R(R),G(L+R),match(L+R,-1),level(L+R){}\n\n    void add_edge(int u,int v){\n        G[u].emplace_back(v+L);\n        G[v+L].emplace_back(u);\n    }\n\n    bool bfs(){\n        fill(level.begin(),level.end(),-1);\n        queue<int> q;\n        for(int i=0;i<L;i++){\n            if(match[i]<0){\n                level[i]=0;\n                q.emplace(i);\n            }\n        }\n        bool found=false;\n        while(!q.empty()){\n            int v=q.front();q.pop();\n            for(int u:G[v]){\n                if(~level[u]) continue;\n                level[u]=level[v]+1;\n                int w=match[u];\n                if(w==-1){\n                    found=true;\n                    continue;\n                }\n                if(~level[w]) continue;\n                level[w]=level[u]+1;\n                q.emplace(w);\n            }\n        }\n        return found;\n    }\n\n    bool dfs(int v){\n        for(int u:G[v]){\n            if(level[v]+1!=level[u]) continue;\n            level[u]=-1;\n            int w=match[u];\n            if(w<0||dfs(w)){\n                match[v]=u;\n                match[u]=v;\n                level[v]=-1;\n                return true;\n            }\n        }\n        level[v]=-1;\n        return false;\n    }\n\n    int build(){\n        int res=0;\n        while(bfs())\n            for(int i=0;i<L;i++)\n                if(match[i]<0&&dfs(i))\n                    res++;\n        return res;\n    }\n\n};\n\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint64 N, H, W;\n\tcin >> N >> H >> W;\n\tBiMatch bm(H+W, N);\n\tusing T = tuple<int64, int64, int64>;\n\tvector<T> v(N);\n\tREP(i, N) {\n\t    int64 a, b, c;\n\t    cin >> a >> b >> c;\n\t    v[i] = T(c, a, b);\n\t}\n\tsort(all(v), greater<>());\n\tREP(i, N) {\n\t    int64 V, c, r;\n\t    tie(V, r, c) = v[i];\n\t    bm.add_edge(r-1, i);\n\t    bm.add_edge(c-1+H, i);\n\t}\n\tbm.build();\n\tint64 res = 0;\n\tREP(i, H+W) {\n\t    if (bm.match[i] != -1) {\n\t        res += get<0>(v[bm.match[i]-H-W]);\n\t    }\n\t}\n\tcout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntypedef long long ll;\n\nclass UnionFind{\nprivate:\n    vector<int> p,s,e;\n\tint cnt;\npublic:\n\tUnionFind(){}\n\tUnionFind(int N){\n\t\tcnt = N;\n\t\tp = s = e = vector<int>(N+1,0);\n\t\tfor(int i=1;i<=N;i++){\n\t\t\tp[i] = i; s[i] = 1; e[i] = 0;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(p[x]==x) return x;\n\t\telse return p[x] = find(p[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x); y = find(y);\n\t\tif(x==y){\n            e[x]++;\n            return;\n\t\t}\n        if(s[x]>s[y]){\n\t\t\tp[y] = x;\n\t\t\ts[x] += s[y];\n            e[x] += e[y]+1;\n\t\t}else{\n\t\t\tp[x] = y;\n\t\t\ts[y] += s[x];\n            e[y] += e[x]+1;\n\t\t}\n\t\tcnt--;\n\t}\n\tbool is_same_set(int x,int y) {return find(x)==find(y);}\n\tint number_of_nodes(int x) {return s[find(x)];}\n    int number_of_edges(int x){return e[find(x)];}\n\tint number_of_components(){return cnt;}\n};\n\nstruct card{\n    int s,t;\n    ll value;\n    bool operator<(const card& right)const{\n        return value>right.value;\n    }\n};\n\nint main(){\n    int N,H,W;\n    cin >> N >> H >> W;\n    vector<card> v;\n    for(int i=0;i<N;i++){\n        int r,c; ll a;\n        cin >> r >> c >> a;\n        v.push_back({r,c+H,a});\n    }\n    sort(v.begin(),v.end());\n    UnionFind uf(H+W);\n    ll ans = 0;\n    for(auto x:v){\n        if(!uf.is_same_set(x.s,x.t)){\n            if(uf.number_of_nodes(x.s)+uf.number_of_nodes(x.t)<=uf.number_of_edges(x.s)+uf.number_of_edges(x.t)) continue;\n            ans += x.value;\n            uf.unite(x.s,x.t);\n         }else if(uf.number_of_nodes(x.s)>uf.number_of_edges(x.s)){\n            ans += x.value;\n            uf.unite(x.s,x.t);\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> // Tomasz Nowak\nusing namespace std;     // XIII LO Szczecin\nusing LL = long long;    // Poland\n#define FOR(i, l, r) for(int i = (l); i <= (r); ++i)\n#define REP(i, n) FOR(i, 0, (n) - 1)\ntemplate<class T> int size(T &&x) {\n\treturn int(x.size());\n}\ntemplate<class A, class B> ostream& operator<<(ostream &out, const pair<A, B> &p) {\n\treturn out << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate<class T> auto operator<<(ostream &out, T &&x) -> decltype(x.begin(), out) {\n\tout << '{';\n\tfor(auto it = x.begin(); it != x.end(); ++it)\n\t\tout << *it << (it == prev(x.end()) ? \"\" : \", \");\n\treturn out << '}';\n}\nvoid dump() {}\ntemplate<class T, class... Args> void dump(T &&x, Args... args) {\n\tcerr << x << \";  \";\n\tdump(args...);\n}\n#ifdef DEBUG\n  struct Nl{~Nl(){cerr << '\\n';}};\n# define debug(x...) cerr << (strcmp(#x, \"\") ? #x \":  \" : \"\"), dump(x), Nl(), cerr << \"\"\n#else\n# define debug(...) 0 && cerr\n#endif\nmt19937_64 rng(0);\nint rd(int l, int r) {\n\treturn uniform_int_distribution<int>(l, r)(rng);\n}\n// end of templates\n\nstruct MCMF {\n\tstruct Edge {\n\t\tint v, u, flow, cap;\n\t\tLL cost;\n\t\tfriend ostream& operator<<(ostream &os, Edge &e) {\n\t\t\treturn os << vector<LL>{e.v, e.u, e.flow, e.cap, e.cost};\n\t\t}\n\t};\n\n\tint n;\n\tconst LL inf_LL = 0x3f3f3f3f3f3f3f3f;\n\tconst int inf_int = 0x3f3f3f3f;\n\tvector<vector<int>> graph;\n\tvector<Edge> edges;\n\n\tMCMF(int N) : n(N), graph(n) {}\n\n\tvoid add_edge(int v, int u, int cap, LL cost) {\n\t\tdebug() << \"adding edge \" << v << '-' << u << \": \" << make_pair(cap, cost);\n\t\tint e = size(edges);\n\t\tgraph[v].emplace_back(e);\n\t\tgraph[u].emplace_back(e + 1);\n\t\tedges.emplace_back(Edge{v, u, 0, cap, cost});\n\t\tedges.emplace_back(Edge{u, v, 0, 0, -cost});\n\t}\n\n\tpair<int, LL> augment(int source, int sink) {\n\t\tvector<LL> dist(n, inf_LL);\n\t\tvector<int> from(n, -1);\n\t\tdist[source] = 0;\n\t\tdeque<int> que = {source};\n\t\tvector<bool> inside(n);\n\t\tinside[source] = true;\n\n\t\twhile(size(que)) {\n\t\t\tint v = que.front();\n\t\t\tinside[v] = false;\n\t\t\tque.pop_front();\n\n\t\t\tfor(int i : graph[v]) {\n\t\t\t\tEdge &e = edges[i];\n\t\t\t\tif(e.flow != e.cap and dist[e.u] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.u] = dist[v] + e.cost;\n\t\t\t\t\tfrom[e.u] = i;\n\t\t\t\t\tif(not inside[e.u]) {\n\t\t\t\t\t\tinside[e.u] = true;\n\t\t\t\t\t\tque.emplace_back(e.u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(from[sink] == -1)\n\t\t\treturn {0, 0};\n\n\t\tint flow = inf_int, e = from[sink];\n\t\twhile(e != -1) {\n\t\t\tflow = min(flow, edges[e].cap - edges[e].flow);\n\t\t\te = from[edges[e].v];\n\t\t}\n\t\te = from[sink];\n\t\twhile(e != -1) {\n\t\t\tedges[e].flow += flow;\n\t\t\tedges[e ^ 1].flow -= flow;\n\t\t\te = from[edges[e].v];\n\t\t}\n\t\treturn {flow, flow * dist[sink]};\n\t}\n\n\tpair<int, LL> operator()(int source, int sink) {\n\t\tint flow = 0;\n\t\tLL cost = 0;\n\t\tpair<int, LL> got;\n\t\tdo {\n\t\t\tgot = augment(source, sink);\n\t\t\tflow += got.first;\n\t\t\tcost += got.second;\n\t\t} while(got.first);\n\t\treturn {flow, cost};\n\t}\n};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n, h, w;\n\tcin >> n >> h >> w;\n\tMCMF mcmf(1 + h + w + n + 1);\n\tREP(i, h)\n\t\tmcmf.add_edge(0, 1 + i, 1, 0);\n\tREP(i, w)\n\t\tmcmf.add_edge(0, 1 + h + i, 1, 0);\n\tREP(i, n)\n\t\tmcmf.add_edge(1 + h + w + i, 1 + h + w + n, 1, 0);\n\n\tREP(q, n) {\n\t\tint r, c, a;\n\t\tcin >> r >> c >> a;\n\t\t--r, --c;\n\t\tmcmf.add_edge(1 + r, 1 + h + w + q, 1, -a);\n\t\tmcmf.add_edge(1 + h + c, 1 + h + w + q, 1, -a);\n\t}\n\n\tauto ret = mcmf(0, 1 + h + w + n);\n\tdebug(ret);\n\t\n\tcout << (-ret.second) << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 1e5+10;\nint n,w,h,sx[N],sy[N],cnt1,cnt2;\nstruct node{\n\tint x,y,z;\n}a[N];\nmap<int,int>f[N];\n\nint main(){\n\tn=read(),w=read(),h=read();\n\tFor(i,1,n) a[i]=(node){read(),read(),read()};\n\tsort(a+1,a+1+n,[](node a,node b){\n\t\treturn a.z>b.z;\n\t});\n\tll ans=0;\n\tint cnt=0;\n\tcnt1=w,cnt2=h;\n\tFor(i,1,n){\n\t\tif (f[a[i].x][a[i].y]<2&&sx[a[i].x]<=h&&sy[a[i].y]<=w){\n\t\t\tcnt1-=(sx[a[i].x]==0),cnt2-=(sy[a[i].y]==0),++cnt;\n\t\t\tif ((w+h)-cnt<cnt1||(w+h)-cnt<cnt2){\n\t\t\t\tcnt1+=(sx[a[i].x]==0),cnt2+=(sy[a[i].y]==0),--cnt;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans+=a[i].z;\n\t\t\tsx[a[i].x]++,sy[a[i].y]++,f[a[i].x][a[i].y]++;\n\t\t\tif (cnt==w+h) break;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//2019.8.24 by ljz\n//email 573902690@qq.com\n//if you find any bug in my code\n//please tell me\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f\n#define unl __int128\n#define eps 5.6e-8\n#define RG register\n#define db double\n#define pc(x) __builtin_popcount(x)\ntypedef pair<int,int> Pair;\n#define mp make_pair\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define pb push_back\n#define ull unsigned LL\n#define gc getchar\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\ninline int read() {\n    res s=0,ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\n//inline int read() {\n//    res s=0,ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc();\n//    while(ch<'0'||ch>'9')ch=gc();\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline void write(RG unl x){\n//    if(x>10)write(x/10);\n//    putchar(int(x%10)+'0');\n//}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n//clock_t start=clock();\n//inline void ck(){\n//    if(1.0*(clock()-start)/CLOCKS_PER_SEC>0.1)exit(0);\n//}\nconst int N=1e6+10;\nconst int kcz=1e9+7;\nnamespace MAIN{\n    int n,H,W;\n    inline void add(res &x,const res &y){\n        x+=y,x>=kcz?x-=kcz:1;\n    }\n    inline int mul(const res &x,const res &y){\n        return int(1LL*x*y%kcz);\n    }\n    inline int Add(const res &x,const res &y){\n        return x+y>=kcz?x+y-kcz:x+y;\n    }\n    int a[N],R[N],C[N];\n    struct E{\n        int next,to;\n        E() {}\n        E(res next,res to):next(next),to(to) {}\n    }edge[N];\n    int head[N],cnt;\n    inline void addedge(const res &u,const res &v){\n        edge[++cnt]=E(head[u],v),head[u]=cnt;\n    }\n    int vis[N],link[N],tim;\n    bool match(res x){\n        for(res i=head[x];~i;i=edge[i].next){\n            res tox=edge[i].to;\n            if(vis[tox]==tim)continue;\n            vis[tox]=tim;\n            if(!link[tox]||match(link[tox])){link[tox]=x;return 1;}\n        }\n        return 0;\n    }\n    LL ans;\n    int id[N];\n    inline bool cmp(const res &x,const res &y){\n        return a[x]>a[y];\n    }\n    inline void MAIN(){\n        n=read(),H=read(),W=read();\n        memset(head,-1,sizeof(head));\n        for(res i=1;i<=n;i++)R[i]=read(),C[i]=read(),a[i]=read(),addedge(i,R[i]+n),addedge(i,C[i]+H+n),id[i]=i;\n        sort(id+1,id+n+1,cmp);\n        for(res i=1;i<=n;i++){\n            tim++;\n            if(match(id[i]))ans+=a[id[i]];\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}\nint main(){\n//    srand(19260817);\n//    freopen(\"signin.in\",\"r\",stdin);\n//    freopen(\"signin.out\",\"w\",stdout);\n    MAIN::MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n//#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\nclass UnionFind{\nprivate:\n    ::std::vector<int_fast32_t> par, edge;\n    size_t n;\n\npublic:\n    UnionFind(){}\n    UnionFind(size_t n):n(n){\n        par.resize(n, -1);\n        edge.resize(n, 0);\n    }\n\n    uint_fast32_t find(uint_fast32_t x){\n        return par[x] < 0 ? x : par[x] = find(par[x]);\n    }\n\n    size_t size(uint_fast32_t x){\n        return -par[find(x)];\n    }\n\n    bool unite(uint_fast32_t x, uint_fast32_t y){\n        x = find(x);\n        y = find(y);\n        edge[x] += edge[y] + 1;\n        if(x == y) return false;\n        if(size(x) < size(y)) std::swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool same(uint_fast32_t x, uint_fast32_t y){\n        return find(x) == find(y);\n    }\n\n    size_t esize(uint_fast32_t x) {\n        return edge[find(x)];\n    }\n};\n\nint main(void) {\n    int64 H, W, N;\n    cin >> N >> H >> W;\n    using T = tuple<int64, int64, int64>;\n    vector<T> v;\n    REP(i, N) {\n        int64 r, c, a;\n        cin >> r >> c >> a;\n        v.emplace_back(a, r-1, H+c-1);\n    }\n    sort(all(v), greater<>());\n    UnionFind uf(H+W);\n    int64 res = 0;\n    REP(i, N) {\n        int64 r, c, a;\n        tie(a, r, c) = v[i];\n        if ((!uf.same(r, c) && (uf.size(r) + uf.size(c) > uf.esize(r) + uf.esize(c))) || uf.size(r) > uf.esize(r)) {\n            res += a;\n            uf.unite(r, c);\n        }\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e5+5;\nstruct node{\n    int r,c,a;\n    friend bool operator<(node a,node b){\n        return a.a>b.a;\n    }\n}st[maxn];\nint fa[maxn],S[maxn],T[maxn];\nint n,H,W;\nint init(){\n    for(int i=1;i<=H+W;i++){\n        fa[i]=i;\n        T[i]=1;\n    }\n}\nint find(int x){\n    return x==fa[x]?x:fa[x]=find(fa[x]);\n}\nint main(){\n    cin>>n>>H>>W;\n    init();\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%d\",&st[i].r,&st[i].c,&st[i].a);\n    }\n    sort(st+1,st+1+n);\n    ll ans=0;\n    for(int i=1;i<=n;i++){\n//        printf(\"%d %d %d\\n\",st[i].r,st[i].c,st[i].a);\n        int fr=find(st[i].r),fc=find(H+st[i].c);\n        if(fr==fc){//两个在同一集合内\n            if(T[fc]>=S[fc]+1){\n                S[fc]++;\n                ans=ans+st[i].a;\n            }\n        }\n        else{//两个不在同一集合内，要合并\n            if(T[fr]+T[fc]>=S[fr]+S[fc]+1){\n                fa[fr]=fc;\n                T[fr]+=T[fc];\n                S[fr]=S[fr]+S[fc]+1;\n                ans=ans+st[i].a;\n            }\n        }\n    }\n    printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nmultiset<tuple<int,int,int>> dsu[200000];\n\nint n, h, w;\nint par[200000];\n\nint find(int p) {\n  return par[p] = (p == par[p] ? p : find(par[p]));\n}\n\nvoid join(int a, int b, tuple<int,int,int> v) {\n  a = find(a);\n  b = find(b);\n  dsu[a].erase(dsu[a].find(v));\n  if (a == b) {\n    return;\n  }\n  dsu[b].erase(dsu[b].find(v));\n  if (dsu[b].size() > dsu[a].size()) swap(a,b);\n  par[b] = a;\n  for (auto&v : dsu[b])\n    dsu[a].insert(v);\n}\n\nint fetch(int p) {\n  p = find(p);\n  auto it = dsu[p].rbegin();\n  if (it == dsu[p].rend()) return 0;\n  int a,x,y;\n  tie(a,x,y)= *it;\n  join(x,y+w,*it);\n  return a;\n}\n\nint main() {\n  ios::sync_with_stdio(0); cin.tie(0);\n  cin >> n >> h >> w;\n  for (int i = 0; i < w+h; i++)\n    par[i] = i;\n  set<pair<int,int>> taken;\n  for (int i = 0; i < n; i++) {\n    int y, x, a;\n    cin >> y >> x >> a;\n    y--, x--;\n    dsu[x].insert({a,x,y});\n    dsu[y+w].insert({a,x,y});\n  }\n  ll ans = 0;\n  for (int i = 0; i < w+h; i++) {\n    int a = fetch(i);\n    //cout << a << endl;\n    ans += a;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\ntypedef long long ll;\nconst int Maxn=1e5;\n\nint N,H,W;\nstruct Edge {\n\tint u,v,val;\n};\nbool operator < (Edge lhs,Edge rhs) {return lhs.val<rhs.val;}\nEdge A[Maxn+5];\n\nint fa[Maxn*2+5],siz[Maxn*2+5],cnt[Maxn*2+5];\nvoid init() {\n\tfor(int i=1;i<=Maxn*2;i++)\n\t\tfa[i]=i,siz[i]=1,cnt[i]=0;\n}\nint find(int x) {\n\tif(fa[x]==x)return fa[x];\n\treturn fa[x]=find(fa[x]);\n}\n\nint main() {\n\t#ifdef LOACL\n\tfreopen(\"in.txt\",\"r\",stdin);\n\tfreopen(\"out.txt\",\"w\",stdout);\n\t#endif\n\tscanf(\"%d %d %d\",&N,&H,&W);\n\tfor(int i=1;i<=N;i++) {\n\t\tscanf(\"%d %d %d\",&A[i].u,&A[i].v,&A[i].val);\n\t\tA[i].v+=H;\n\t}\n\tsort(A+1,A+N+1);\n\treverse(A+1,A+N+1);\n\tinit();\n\tll ans=0;\n\tfor(int i=1;i<=N;i++) {\n\t\tint v1=find(A[i].u),v2=find(A[i].v);\n\t\tif(v1==v2) {\n\t\t\tif(siz[v1]==cnt[v1])continue;\n\t\t\tans+=A[i].val,cnt[v1]++;\n\t\t} else {\n\t\t\tif(siz[v1]+siz[v2]<cnt[v1]+cnt[v2]+1)\n\t\t\t\tcontinue;\n\t\t\telse {\n\t\t\t\tfa[v2]=v1;\n\t\t\t\tsiz[v1]+=siz[v2],cnt[v1]+=cnt[v2]+1;\n\t\t\t\tsiz[v2]=cnt[v2]=0;\n\t\t\t\tans+=A[i].val;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\n#include<vector>\n#include<numeric>\n\nnamespace ProconLib{\n    class UnionFind{\n        int N;\n        std::vector<int> par;\n        std::vector<int> rank;\n        public:\n        UnionFind(int N):N(N),par(N),rank(N,0){std::iota(par.begin(),par.end(),0);}\n        int find(int x);\n        void unite(int x,int y);\n        bool same(int x,int y){return find(x)==find(y);}\n    };\n\n    int UnionFind::find(int x){\n        if(par[x]==x) return x;\n        return par[x]=find(par[x]);\n    }\n    void UnionFind::unite(int x,int y){\n        x=find(x),y=find(y);\n        if(x==y) return;\n        if(rank[x]>=rank[y]){\n            if(rank[x]==rank[y]) rank[x]++;\n            par[y]=x;\n        }else{\n            par[x]=y;\n        }\n    }\n}using namespace std;\nusing namespace ProconLib;\nusing ll=long long;\n\nstruct Card{\n    int r,c;\n    ll a;\n    int id;\n};\n\nstruct Edge{\n    int to;\n    ll w;\n};\nusing Graph=vector<vector<Edge>>;\nGraph g;\nvector<int> used;\nvoid dfs(int v){\n    if(used[v]) return;\n    used[v]=true;\n    for(auto to:g[v]){\n        if(!used[to.to]) dfs(to.to);\n    }\n}\nint main(){\n    int n,h,w;\n    cin>>n>>h>>w;\n    vector<Card> cards(n);\n    for(int i=0;i<n;i++){\n        cin>>cards[i].r>>cards[i].c>>cards[i].a;\n        cards[i].r--;\n        cards[i].c--;\n        cards[i].id=i;\n    }\n    sort(cards.begin(),cards.end(),[](Card lhs,Card rhs){return lhs.a>rhs.a;});\n    vector<int> flag(n);\n\n    g.resize(h+w);\n    used.resize(h+w);\n    UnionFind u(h+w);\n    \n    ll res=0;\n    for(auto &card:cards){\n        int x=card.r;\n        int y=card.c+h;\n        if(u.same(x,y)){\n            if(used[x]+used[y]==0){\n                res+=card.a;\n                g[x].push_back(Edge{y,card.a});\n                g[y].push_back(Edge{x,card.a});\n                dfs(x);\n                dfs(y);\n            }\n            else{\n                assert(used[x]==used[y]);\n                continue;\n            }\n        }\n        if(used[x] && used[y]){\n            continue;\n        }\n        else if(used[x]||used[y]){\n            g[x].push_back(Edge{y,card.a});\n            g[y].push_back(Edge{x,card.a});\n            dfs(x);\n            dfs(y);\n            u.unite(x,y);\n            res+=card.a;\n        }\n        else{\n            u.unite(x,y);\n            g[x].push_back(Edge{y,card.a});\n            g[y].push_back(Edge{x,card.a});\n            res+=card.a;\n        }\n    }\n    cout<<res<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N = 300000 + 100;\nconst LL INF = 1e12;\nstruct Edge\n{\n    int from,to,cap;LL flow, cost;\n    Edge(int u,int v,int ca,int f,LL co):from(u),to(v),cap(ca),flow(f),cost(co){};\n};\n\nstruct MCMF\n{\n    int n,m,s,t;\n    vector<Edge> edges;\n    vector<int> G[N];\n    int inq[N];//是否在队列中\n    LL d[N];//距离\n    int p[N];//上一条弧\n    LL a[N];//可改进量\n\n    void init(int n)//初始化\n    {\n        this->n=n;\n        for(int i=0;i<n;i++)\n            G[i].clear();\n        edges.clear();\n    }\n\n    void AddEdge(int from,int to,int cap,LL cost)//加边\n    {\n        edges.push_back(Edge(from,to,cap,0,cost));\n        edges.push_back(Edge(to,from,0,0,-cost));\n        int m=edges.size();\n        G[from].push_back(m-2);\n        G[to].push_back(m-1);\n    }\n\n    bool SPFA(int s,int t,int &flow,LL &cost)//寻找最小费用的增广路，使用引用同时修改原flow,cost\n    {\n        for(int i=0;i<n;i++)\n            d[i]=INF;\n        memset(inq,0,sizeof(inq));\n        d[s]=0;inq[s]=1;p[s]=0;a[s]=INF;\n        queue<int> Q;\n        Q.push(s);\n        while(!Q.empty())\n        {\n            int u=Q.front();\n            Q.pop();\n            inq[u]--;\n            for(int i=0;i<G[u].size();i++)\n            {\n                Edge& e=edges[G[u][i]];\n                if(e.cap>e.flow && d[e.to]>d[u]+e.cost)//满足可增广且可变短\n                {\n                    d[e.to]=d[u]+e.cost;\n                    p[e.to]=G[u][i];\n                    a[e.to]=min(a[u],e.cap-e.flow);\n                    if(!inq[e.to])\n                    {\n                        inq[e.to]++;\n                        Q.push(e.to);\n                    }\n                }\n            }\n        }\n        if(d[t]==INF) return false;//汇点不可达则退出\n        flow+=a[t];\n        cost+=d[t]*a[t];\n        int u=t;\n        while(u!=s)//更新正向边和反向边\n        {\n            edges[p[u]].flow+=a[t];\n            edges[p[u]^1].flow-=a[t];\n            u=edges[p[u]].from;\n        }\n        return true;\n    }\n\n    LL MincotMaxflow(int s,int t)\n    {\n        int flow=0;LL cost=0,res=0;\n        while(SPFA(s,t,flow,cost)){\n            res=max(res,-cost);\n        }\n        //printf(\"flow = %d\\n\", flow);\n        return res;\n    }\n} G;\n\nint mxr[N], mxr_[N], mxc[N], mxc_[N];\nint rr[N],cc[N],xx[N];\nint main() {\n    for (int i = 0; i < N; i ++) {\n        mxr[i] = mxr_[i] = mxc[i] = mxc_[i] = 0;\n    }\n    int n, h, w;\n    scanf(\"%d%d%d\",&n,&h,&w);\n    int S = n+w+h+1, T = S+1;\n    G.init(T+1);\n    for(int i=1;i<=n;i++){  \n        scanf(\"%d%d%d\",&rr[i],&cc[i],&xx[i]);\n        if(xx[i] >= mxr[i]) {\n            mxr_[i] = mxr[i]; mxr[i] = xx[i];\n        } else if (xx[i] >= mxr_[i]) {\n            mxr_[i] = xx[i]; \n        }\n        if(xx[i] >= mxc[i]) {\n            mxc_[i] = mxc[i]; mxc[i] = xx[i];\n        } else if (xx[i] >= mxc_[i]) {\n            mxc_[i] = xx[i]; \n        }\n    }\n    for(int i=1;i<=n;i++){\n        int r,c,x; r=rr[i],c=cc[i],x=xx[i];\n        if(x < mxr_[r] && x < mxc_[c]) continue;\n        G.AddEdge(n+r,i,1,0);\n        G.AddEdge(n+h+c,i,1,0);\n        G.AddEdge(i,T,1,-x);\n    }\n    for (int i=1;i<=h;i++) G.AddEdge(S,n+i,1,0);\n    for (int i=h+1;i<=h+w;i++) G.AddEdge(S,n+i,1,0);\n    cout << G.MincotMaxflow(S, T) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// verified at https://judge.yosupo.jp/submission/3400\n#ifndef Union_find_hpp\n#define Union_find_hpp\n\n#include <cassert>\n#include <cstddef>\n#include <vector>\n\nclass union_find\n{\n    std::vector<int> link;\n\npublic:\n    explicit union_find(const size_t n) : link(n, -1) {}\n\n    size_t find(size_t x)\n    {\n        assert(x < size());\n        return link[x] < 0 ? x : (link[x] = find(link[x]));\n    }\n\n    size_t size() const { return link.size(); }\n\n    size_t size(const size_t x)\n    {\n        assert(x < size());\n        return -link[find(x)];\n    }\n\n    bool same(const size_t x, const size_t y)\n    {\n        assert(x < size() && y < size());\n        return find(x) == find(y);\n    }\n\n    size_t unite(size_t x, size_t y)\n    {\n        assert(x < size() && y < size());\n        if((x = find(x)) != (y = find(y)))\n        {\n            if(link[x] > link[y]) std::swap(x, y);\n            link[x] += link[y];\n            link[y] = x;\n        }\n        return x;\n    }\n}; // class union_find\n\n#endif // Union_find_hpp\n\n#include <algorithm>\n#include <iostream>\n#include <tuple>\n\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n    std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n\n    int n,h,w; cin>>n>>h>>w;\n    vector<tuple<int,int,int>> cards(n);\n    for(auto &e : cards)\n    {\n        int r,c,a; cin>>r>>c>>a;\n        --r,--c; c+=h;\n        e=tie(a,r,c);\n    }\n    sort(cards.rbegin(),cards.rend());\n    union_find uf(h+w);\n    long long ans{};\n    bool ext[2<<17]={};\n    for(auto &e : cards)\n    {\n        int a,r,c; tie(a,r,c)=e;\n        r=uf.find(r),c=uf.find(c);\n        if(r!=c)\n        {\n            if(ext[r] and ext[c]) continue;\n            ext[uf.unite(r,c)]=ext[r]||ext[c];\n            ans+=a;\n        }\n        else if(!ext[r])\n        {\n            ext[r]=true;\n            ans+=a;\n        }\n    }\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nstruct Card {\n\tint R, C, A;\n\tbool operator<(const Card &right) const {\n\t\treturn A < right.A;\n\t}\n};\nstruct UnionFind {\n\tvector<int> data;\n\tvector<int> es;\n\tUnionFind(int size) : data(size, -1), es(size, 0) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\tes[x]++;\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n\tbool full(int x) {\n\t\tint r = root(x);\n\t\treturn (-data[r] == es[r]);\n\t}\n};\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, H, W;\n\tcin >> N >> H >> W;\n\tvector<Card> c(N);\n\tint res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> c[i].R >> c[i].C >> c[i].A;\n\t\tc[i].R--;\n\t\tc[i].C--;\n\t}\n\tsort(c.rbegin(), c.rend());\n\tUnionFind uf(H + W);\n\tfor (int i = 0; i < N; i++) {\n\t\tint a = c[i].R;\n\t\tint b = H + c[i].C;\n\n\t\tif (uf.full(a) && uf.full(b)) {\n\t\t\t\n\t\t}\n\t\telse {\n\t\t\tuf.unionSet(a, b);\n\t\t\tres += c[i].A;\n\t\t}\n\n\t\t//res = max(res, cur + sum[min(rem, (int)sum.size() - 1)] );\n\t}\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//2019.8.24 by ljz\n//email 573902690@qq.com\n//if you find any bug in my code\n//please tell me\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f\n#define unl __int128\n#define eps 5.6e-8\n#define RG register\n#define db double\n#define pc(x) __builtin_popcount(x)\ntypedef pair<int,int> Pair;\n#define mp make_pair\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define pb push_back\n#define ull unsigned LL\n#define gc getchar\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\ninline int read() {\n    res s=0,ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\n//inline int read() {\n//    res s=0,ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc();\n//    while(ch<'0'||ch>'9')ch=gc();\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline void write(RG unl x){\n//    if(x>10)write(x/10);\n//    putchar(int(x%10)+'0');\n//}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n//clock_t start=clock();\n//inline void ck(){\n//    if(1.0*(clock()-start)/CLOCKS_PER_SEC>0.1)exit(0);\n//}\nconst int N=5e5+10;\nconst int kcz=1e9+7;\nnamespace MAIN{\n    int n,H,W;\n    inline void add(res &x,const res &y){\n        x+=y,x>=kcz?x-=kcz:1;\n    }\n    inline int mul(const res &x,const res &y){\n        return int(1LL*x*y%kcz);\n    }\n    inline int Add(const res &x,const res &y){\n        return x+y>=kcz?x+y-kcz:x+y;\n    }\n    int a[N],R[N],C[N];\n    map<Pair,int> M;\n    vector<int> A[N];\n    int fa[N];\n    inline int find(res x){\n        while(x!=fa[x])x=fa[x]=fa[fa[x]];\n        return x;\n    }\n    struct E{\n        int u,v,w;\n        E() {}\n        E(res u,res v,res w):u(u),v(v),w(w) {}\n        inline bool operator < (const E &b) const {\n            return w>b.w;\n        }\n    }edge[N];\n    bool vis[N];\n    LL ans;\n    int cnt;\n    inline void MAIN(){\n        n=read(),H=read(),W=read();\n        for(res i=1;i<=n;i++)R[i]=read(),C[i]=read(),a[i]=read(),edge[++cnt]=E(R[i],C[i]+H,a[i]);\n        sort(edge+1,edge+cnt+1);\n        for(res i=1;i<=H+W;i++)fa[i]=i;\n        for(res i=1;i<=cnt;i++){\n            res u=edge[i].u,v=edge[i].v,w=edge[i].w,fu=find(u),fv=find(v);\n            if(fu==fv){if(!vis[fv])ans+=w,vis[fv]=1;}\n            else if(!vis[fu]||!vis[fv])ans+=w,vis[fu]|=vis[fv],fa[fv]=fu;\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}\nint main(){\n//    srand(19260817);\n//    freopen(\"signin.in\",\"r\",stdin);\n//    freopen(\"signin.out\",\"w\",stdout);\n    MAIN::MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> pii;\n#ifdef DEBUG\n#define display(x) cerr << #x << \" = \" << x << endl;\n#define displaya(a, st, n)\\\n\t{cerr << #a << \" = {\";\\\n\tfor(int qwq = (st); qwq <= (n); ++qwq) {\\\n\t\tif(qwq == (st)) cerr << a[qwq];\\\n\t\telse cerr << \", \" << a[qwq];\\\n\t} cerr << \"}\" << endl;}\n#define displayv(v) displaya(v, 0, (int)(v).size() - 1)\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define display(x) ;\n#define displaya(a, st, n) ;\n#define displayv(v) ;\n#define eprintf(...) if(0) fprintf(stderr, \"...\")\n#endif\ntemplate<typename T> bool chmin(T &a, const T &b) { return a > b ? a = b, true : false; }\ntemplate<typename T> bool chmax(T &a, const T &b) { return a < b ? a = b, true : false; }\n\nconst int maxN = 2 * 100000 + 233;\nint n;\nint pa[maxN], mk[maxN];\nvector< pair<int, pii> > ve;\n\nint findset(int x) { return pa[x] == x ? x : pa[x] = findset(pa[x]); }\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n\tcin.tie(0); cout.tie(0);\n#endif\n\tcin >> n;\n\tint h, w; cin >> h >> w;\n\tfor(int i = 1; i <= h + w; ++i) pa[i] = i, mk[i] = 0;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tint x, y, a;\n\t\tcin >> x >> y >> a;\n\t\tve.emplace_back(a, pii(x + w, y));\n\t}\n\tsort(ve.begin(), ve.end());\n\treverse(ve.begin(), ve.end());\n\tLL ans = 0;\n\tfor(auto e : ve) {\n\t\tint x = e.second.first, y = e.second.second;\n\t\tx = findset(x); y = findset(y);\n\t\tif(x == y) {\n\t\t\tif(!mk[x]) mk[x] = 1, ans += e.first;\n\t\t} else if(mk[x] + mk[y] <= 1) {\n\t\t\tpa[x] = y;\n\t\t\tmk[y] |= mk[x];\n\t\t\tans += e.first;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n//#define ll __int128\n#define ll long long\n#define LEFT(a) ((a)<<1)\n#define RIGHT(a) (LEFT(a) + 1)\n#define MID(a,b) ((a+b)>>1)\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define y1 y122\n/*\n#pragma GCC optimize (\"O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx2,fma\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"unroll-loops\")\n#pragma comment(linker, \"/STACK: 20000000005\")\n*/\n\nusing namespace std;\n\nconst ll N = 1000005;\n\nll n;\nll x[N], y[N], a[N];\n\n\npriority_queue < pair < ll, pair < ll, ll > > > Q;\n\nmap < ll, bool > R, C;\n\nll ans;\n\n\nmain()\n{\n    //freopen (\"in.in\", \"r\", stdin);freopen (\"out.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    ll xx;\n    cin >> n >> xx >> xx;\n    for (ll i = 1; i <= n; i++){\n        cin >> x[i] >> y[i] >> a[i];\n        swap (x[i], y[i]);\n        Q.push ({a[i], {x[i], y[i]}});\n    }\n    while (Q.size() > 0){\n        ll X = Q.top().F;\n        ll r = Q.top().S.F, c = Q.top().S.S;\n        Q.pop();\n        if (C[c] == 0){\n            C[c] = 1;\n            ans += X;\n            continue;\n        }\n        if (R[r])\n            continue;\n        R[r] = 1;\n        ans += X;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint H, W;\nvector<pair<int, pair<int, int> > > cards;\n\nvector<int> uf;\nvector<int> ncard;\nint getpar(int a) {\n\treturn uf[a] < 0 ? a : (uf[a] = getpar(uf[a]));\n}\nbool good(int a, int b) {\n\ta = getpar(a);\n\tb = getpar(b);\n\tif (a == b) {\n\t\tif (ncard[a] == -uf[a]) return false;\n\t\tncard[a]++;\n\t\treturn true;\n\t} else {\n\t\tif (-uf[a] + -uf[b] == ncard[a] + ncard[b]) return false;\n\t\tif (-uf[a] < -uf[b]) swap(a, b);\n\t\tuf[a] += uf[b];\n\t\tuf[b] = a;\n\t\tncard[a] += 1;\n\t\tncard[a] += ncard[b];\n\t\treturn true;\n\t}\n}\n\nint main() {\n\tios::sync_with_stdio(0), cin.tie(0);\n\tcin >> n >> H >> W;\n\tcards.resize(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint r, c, a;\n\t\tcin >> r >> c >> a;\n\t\tr--; c--;\n\t\tc += H;\n\t\tcards[i] = make_pair(a, make_pair(r, c));\n\t}\n\tsort(cards.begin(), cards.end());\n\treverse(cards.begin(), cards.end());\n\n\tint V = H+W;\n\tuf.assign(V, -1);\n\tncard.assign(V, 0);\n\tlong long tot = 0;\n\tfor (int i = 0; i < int(cards.size()); i++) {\n\t\tpair<int, pair<int, int> >& card = cards[i];\n\t\tif (good(card.second.first, card.second.second)) {\n\t\t\ttot += card.first;\n\t\t}\n\t}\n\tcout << tot << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,H,W;\n\ntemplate<class V> class MaxFlow_dinic {\npublic:\n\tstruct edge { int to,reve;V cap;};\n\tstatic const int MV = 301100;\n\tvector<edge> E[MV];\n\tint itr[MV],lev[MV];\n\tvoid add_edge(int x,int y,V cap,bool undir=false) {\n\t\tE[x].push_back((edge){y,(int)E[y].size(),cap});\n\t\tE[y].push_back((edge){x,(int)E[x].size()-1,undir?cap:0});\n\t}\n\tvoid bfs(int cur) {\n\t\tMINUS(lev);\n\t\tqueue<int> q;\n\t\tlev[cur]=0;\n\t\tq.push(cur);\n\t\twhile(q.size()) {\n\t\t\tint v=q.front(); q.pop();\n\t\t\tITR(e,E[v]) if(e->cap>0 && lev[e->to]<0) lev[e->to]=lev[v]+1, q.push(e->to);\n\t\t}\n\t}\n\tV dfs(int from,int to,V cf) {\n\t\tif(from==to) return cf;\n\t\tfor(;itr[from]<E[from].size();itr[from]++) {\n\t\t\tedge* e=&E[from][itr[from]];\n\t\t\tif(e->cap>0 && lev[from]<lev[e->to]) {\n\t\t\t\tV f=dfs(e->to,to,min(cf,e->cap));\n\t\t\t\tif(f>0) {\n\t\t\t\t\te->cap-=f;\n\t\t\t\t\tE[e->to][e->reve].cap += f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tV maxflow(int from, int to) {\n\t\tV fl=0,tf;\n\t\twhile(1) {\n\t\t\tbfs(from);\n\t\t\tif(lev[to]<0) return fl;\n\t\t\tZERO(itr);\n\t\t\twhile((tf=dfs(from,to,numeric_limits<V>::max()))>0) fl+=tf;\n\t\t}\n\t}\n};\nMaxFlow_dinic<ll> mf;\n\nint R[101010],C[101010],A[101010];\nint Rok[101010],Cok[101010];\nset<int> RE[101010];\nset<int> CE[101010];\nvoid dfsC(int x);\n\nvoid dfsR(int y) {\n\tRok[y]=0;\n\twhile(RE[y].size()) {\n\t\tint x=*RE[y].begin();\n\t\tRE[y].erase(RE[y].begin());\n\t\tCE[x].erase(y);\n\t\tdfsC(x);\n\t}\n}\nvoid dfsC(int x) {\n\tCok[x]=0;\n\twhile(CE[x].size()) {\n\t\tint y=*CE[x].begin();\n\t\tCE[x].erase(CE[x].begin());\n\t\tRE[y].erase(x);\n\t\tdfsR(y);\n\t}\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>H>>W;\n\tvector<vector<int>> V;\n\tFOR(i,N) {\n\t\tcin>>R[i]>>C[i]>>A[i];\n\t\tR[i]--;\n\t\tC[i]--;\n\t\tV.push_back({A[i],R[i],C[i]});\n\t}\n\tFOR(i,H) Rok[i]=1;\n\tFOR(i,W) Cok[i]=1;\n\t\n\tsort(ALL(V));\n\treverse(ALL(V));\n\tll ret=0;\n\tFORR(v,V) {\n\t\tint y=v[1];\n\t\tint x=v[2];\n\t\t\n\t\tif(Rok[y]&&Cok[x]) {\n\t\t\tif(RE[y].count(x)) {\n\t\t\t\tdfsR(y);\n\t\t\t\tdfsC(x);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tRE[y].insert(x);\n\t\t\t\tCE[x].insert(y);\n\t\t\t}\n\t\t\tret+=v[0];\n\t\t}\n\t\telse if(Rok[y]) {\n\t\t\tdfsR(y);\n\t\t\tret+=v[0];\n\t\t}\n\t\telse if(Cok[x]) {\n\t\t\tdfsC(x);\n\t\t\tret+=v[0];\n\t\t}\n\t}\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n#include <valarray>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++)\n//const ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b97f4a7c15 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a % b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nint popcnt(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn __builtin_popcountll(a);\n#elif defined _WIN64\n\treturn _mm_popcnt_u64(a);\n#else\n\treturn _mm_popcnt_u32(a >> 32) + _mm_popcnt_u32(a);\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n#endif\n}\nint BitScanF(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn __builtin_ctzll(a);\n#elif defined _WIN64\n\tunsigned long ret;\n\t_BitScanForward64(&ret, a);\n\treturn a;\n#else\n\tunsigned long ret;\n\tif (!(unsigned long)a) {\n\t\t_BitScanForward(&ret, a);\n\t\tret += 32;\n\t}\n\telse _BitScanForward(&ret, (unsigned long)a);\n\treturn ret;\n#endif\n}\nint BitScanR(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn 63 - __builtin_clzll(a);\n#elif defined _WIN64\n\tunsigned long ret;\n\t_BitScanReverse64(&ret, a);\n\treturn a;\n#else\n\tunsigned long ret;\n\tif (a >> 32) {\n\t\t_BitScanReverse(&ret, a);\n\t\tret += 32;\n\t}\n\telse _BitScanReverse(&ret, (unsigned long)a);\n\treturn ret;\n#endif\n}\ntemplate<class T>\nclass matrix {\npublic:\n\tvector<valarray<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, valarray<T>(e, m == -1 ? n : m)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)ret[i] += obj[i][j] * p.obj[j];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tbool operator==(const matrix&p) {\n\t\tif (s != p.s)return 0;\n\t\tfor (int i = 0; i<s.first; i++)for (int j; j< s.second; j++)if (obj[i][j] != p.obj[i][j])return 0;\n\t\treturn 1;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\tvalarray<T>& operator[](int t) {\n\t\treturn obj[t];\n\t}\n\tvoid gauss() {\n\t\tif (size().first + 1 != size().second)return;\n\t\trep(i, size().first) {\n\t\t\tint p = i;\n\t\t\trepi(j, i, size().first)if (abs(obj[j][i]) > abs(obj[p][i]))p = j;\n\t\t\tswap(obj[i], obj[p]);\n\t\t\tif (abs(obj[i][i]) < 1e-8)return;//contniue;\n\t\t\trepi(j, i + 1, size().second)obj[i][j] /= obj[i][i];\n\t\t\trep(j, size().first) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\trepi(k, i + 1, size().second)obj[j][k] -= obj[j][i] * obj[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\ntemplate<class T>\nstd::pair<matrix<T>, vector<int>> LU_decomposition(matrix<T> a) {\n\tif (a.size().first != a.size().second)throw runtime_error(\"matrix error\");\n\tstd::vector<int> pi(a.size().first);\n\tstd::iota(ALL(pi), 0);\n\tvalarray<T> tmp(a.size().first);\n\tfor (int i = 0; i < a.size().first; i++) {\n\t\t//int pivot = i;\n\t\t//T max = abs(a[i][i]);\n\t\t//for (int j = i + 1; j < a.size().first; j++) {\n\t\t//\tif (max < abs(a[j][i])) {\n\t\t//\t\tmax = abs(a[j][i]);\n\t\t//\t\tpivot = j;\n\t\t//\t}\n\t\t//}\n\t\t//std::swap(i, pivot);\n\t\t//pi.push_back(pivot);\n\t\tstd::slice slice(i + 1, a.size().first - i - 1, 1);\n\t\tfor (int j = i + 1; j < a.size().first; j++) {\n\t\t\ttmp[slice] = a[i][slice];\n\t\t\ttmp *= a[j][i] / a[i][i];\n\t\t\ta[j][slice] -= tmp[slice];\n\t\t\ta[j][i] = a[j][i] / a[i][i];\n\t\t}\n\t}\n\treturn std::make_pair(std::move(a), std::move(pi));\n}\ntemplate<class T>\nmatrix<T>LU_solve(pair<matrix<T>, std::vector<int>> a, matrix<T> b) {\n\tauto pi = std::move(a.second);\n\tauto A = std::move(a.first);\n\tif (A.size().first != A.size().second || A.size().first != b.size().first)throw runtime_error(\"matrix error\");\n\tfor (int i = 0; i < A.size().first; i++) {\n\t\tstd::swap(b[i], b[pi[i]]);\n\t}\n\tfor (int i = 0; i < A.size().first; i++) {\n\t\tfor (int j = 0; j < i; j++)b[i] -= A[i][j] * b[j];\n\t}\n\tfor (int i = A.size().first - 1; i >= 0; i--) {\n\t\tfor (int j = i + 1; j < A.size().first; j++)b[i] -= A[i][j] * b[j];\n\t\tb[i] /= A[i][i];\n\t}\n\treturn b;\n}\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned long long exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (res.obj[0].size() > 100) {\n\t\t\tint a = 0;\n\t\t}\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned long long exp, ll m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (res.obj[0].size() > 100) {\n\t\t\tint a = 0;\n\t\t}\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tvoid propagate(int a, int b, int k, int l, int r, int p) {\n\t\tif (r <= a || b <= l)return;\n\t\tif (a <= l && r <= b) {\n\t\t\tobj[k].second += p;\n\t\t\t(obj[k].first *= pow(2, p, (ll)1e9 + 7)) %= (ll)(1e9 + 7);\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tif (obj[k].second) {\n\t\t\t\t(obj[k * 2 + 1].first *= pow(2, obj[k].second, (ll)1e9 + 7)) %= (ll)(1e9 + 7);\n\t\t\t\t(obj[k * 2 + 2].first *= pow(2, obj[k].second, (ll)1e9 + 7)) %= (ll)(1e9 + 7);\n\t\t\t\tobj[k * 2 + 1].second += obj[k].second;\n\t\t\t\tobj[k * 2 + 2].second += obj[k].second;\n\t\t\t}\n\t\t\tpropagate(a, b, k * 2 + 1, l, (l + r) / 2, p), propagate(a, b, k * 2 + 2, (l + r) / 2, r, p);\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tT query(int a, int b) {//[a,b)\n\t\t//propagate(a, b, 0);\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid propagate(int a, int b, int p = 1) {//[a,b)\n\t\treturn propagate(a, b, 0, 0, offset + 1, p);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, const T &a) {\n\t\t//propagate(k, k + 1, 0);\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//多次元BITはループをネストすればいいらしい。\n\tvector<T> bit;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= bit.size()) {\n\t\t\tbit[i - 1] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i - 1];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT<T> b0, b1;\n\tint n;\n\trangeadd(int n) :b0(n), b1(n), n(n) {}\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\nclass Flow {\npublic:\n\tint V;\n\tstruct edge { int to, cap, rev, cost, add; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, prevv, preve;\n\tvector<ll> h, dist;\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tll res = 0;\n\tint flow = 0;\n\tint s, t;\n\tint max_flow(int s, int t, int fmax = numeric_limits<int>::max()) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, fmax))>0) {\n\t\t\t\tflow += f;\n\t\t\t\tfmax -= f;\n\t\t\t}\n\t\t\tif (fmax == 0)return flow;\n\t\t}\n\t}\n\ttypedef pair<ll, int> P;\n\tll min_cost_flow(int s, int t, int f) {\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tFlow(int size, int s, int t) :G(size + 1), V(size + 1), s(s), t(t) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost,1 });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost,0 });\n\t}\n\tvoid remove_edge_max(int from, int to, int cap, int cost = 0) {\n\t\tfor (auto &x : G[from]) {\n\t\t\tif (!x.add || x.to != to || x.cap + G[to][x.rev].cap != cap || x.cost != cost)continue;\n\t\t\tint prev = flow;\n\t\t\tint cap = G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tcap -= max_flow(from, to, cap) - prev;\n\t\t\tmax_flow(t, to, cap);\n\t\t\tmax_flow(from, s, cap);\n\t\t\tflow = prev - cap;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvoid remove_edge_cost(int from, int to, int cap, int cost = 0) {\n\t\tfor (auto &x : G[from]) {\n\t\t\tif (!x.add || x.to != to || x.cap + G[to][x.rev].cap != cap || x.cost != cost)continue;\n\t\t\tcost += G[to][x.rev].cap*G[to][x.rev].cost;\n\t\t\tint cap = G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tmin_cost_flow(from, to, cap);\n\t\t\tbreak;\n\t\t}\n\t}\n\tint max_flow() {\n\t\treturn max_flow(s, t);\n\t}\n\tll min_cost_flow(int f) {\n\t\treturn min_cost_flow(s, t, f);\n\t}\n};\nll extgcd(ll a, ll b, ll&x, ll&y) {\n\tint d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a%b, y, x);\n\t\ty -= (a / b)*x;\n\t}\n\telse {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\nll mod_inv(ll a, ll m) {\n\tll x, y;\n\textgcd(a, m, x, y);\n\treturn(m + x % m) % m;\n}\npll linear_congruence(const vector<ll>& A, const vll& B, const vll&M) {\n\tll x = 0, m = 1;\n\tfor (int i = 0; i < A.size(); i++) {\n\t\tll a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n\t\tif (b%d != 0)return make_pair(0, -1);\n\t\tll t = b / d * mod_inv(a / d, M[i] / d) % (M[i] / d);\n\t\t//if (x + m * t < 0)return pll(x%m, m);\n\t\tx = x + m * t;\n\t\tm *= M[i] / d;\n\t}\n\treturn make_pair(x%m, m);\n}\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//円の接線?\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//面積??\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\nstruct unionfind_ {\n\tvector<int> par, rank, size_,a;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind_(int n) :par(n), rank(n), size_(n, 1),a(n) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tcmin(a[x],a[y]);\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T>\nclass lazysegtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse {\n\t\t\tT ret(e);\n\t\t\tobj[k].propagate(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t\treturn ret.merge(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t\t}\n\t}\n\tvoid propagateall(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l || l == r - 1)return;\n\t\tobj[k].propagate(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\tpropagateall(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tpropagateall(a, b, k * 2 + 2, (l + r) / 2, r);\n\t}\n\ttemplate<class Param>\n\tT update(int a, int b, int k, int l, int r, const Param& param) {\n\t\tif (r <= a || b <= l)return obj[k];\n\t\tif (a <= l && r <= b) {\n\t\t\tobj[k].update(param);\n\t\t\treturn obj[k];\n\t\t}\n\t\tobj[k].propagate(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\treturn obj[k].merge(update(a, b, k * 2 + 1, l, (l + r) / 2, param), update(a, b, k * 2 + 2, (l + r) / 2, r, param));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\ttemplate<class Param>\n\tvoid update(int a, int b, Param&& param) {\n\t\tupdate(a, b, 0, 0, offset + 1, param);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i].merge(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid propagateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tupdateall(l, r, 0, 0, offset + 1);\n\t}\n\t/*\n\tvoid update(int k, T &a) {\n\tk += offset;\n\tobj[k] = a;\n\twhile (k) {\n\tk = k - 1 >> 1;\n\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t}\n\t}*/\n\tlazysegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\tlazysegtree(vector<T> &vec, T e) :obj(bufsize(vec.size()), e), e(e) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\nclass lazyRMQ_t {\n\tll min, set;\npublic:\n\tll getmin() {\n\t\treturn min;\n\t}\n\tlazyRMQ_t() {\n\t\tmin = numeric_limits<ll>::max() / 2; set = min;\n\t}\n\tlazyRMQ_t(ll a, ll b = 0) {\n\t\tmin = a; set = b;\n\t}\n\tvoid propagate(lazyRMQ_t &a, lazyRMQ_t &b) {\n\t\tcmin(a.min, set);\n\t\tcmin(b.min, set);\n\t\tcmin(a.set, set);\n\t\tcmin(b.set, set);\n\t\tset = numeric_limits<ll>::max() / 2;\n\t}\n\tlazyRMQ_t& merge(const lazyRMQ_t &a, const lazyRMQ_t &b) {\n\t\tmin = std::min(a.min, b.min);\n\t\tset = numeric_limits<ll>::max() / 2;\n\t\treturn *this;\n\t}\n\tlazyRMQ_t& update(ll k) {\n\t\tcmin(min, k);\n\t\tcmin(set, k);\n\t\treturn *this;\n\t}\n};\nint check(array<int, 4> &a, array<int, 4> &b) {\n\tif (a == b)return 0;\n\tif (a[0] < b[0] && a[1] < b[1])return b[2];\n\tif (b[0] < a[0] && b[1] < a[1])return a[2];\n\treturn -1;\n}\nint main() {\n\tint n;\n\tint h, w;\n\tcin >> n >> h >> w;\n\tva<int, 3> a(n);\n\trep(i, n)rep(j, 3)cin >> a[i][j];\n\trep(i, n)rep(j, 2)a[i][j]--;\n\tFlow f(n + h + w + 2, n + h + w, n + h + w + 1);\n\trep(i, n) {\n\t\tf.add_edge(n + h + w, i, 1, 200000-a[i][2]);\n\t\tf.add_edge(i, n + a[i][0], 1);\n\t\tf.add_edge(i, n + h + a[i][1], 1);\n\t}\n\trep(i, h)f.add_edge(n + i, n + h + w + 1, 1);\n\trep(i, w)f.add_edge(n + h + i, n + h + w + 1, 1);\n\tf.add_edge(n + h + w, n + h + w + 1, n + w, 200000);\n\tcout << 200000ll*(h+w)-f.min_cost_flow(h + w) << endl;\n}\n//template<class T, class map = std::unordered_map<T,unique_ptr<node>>>\n/*class AhoCorasick {\nstruct node {\nmap<char,unique_ptr<node>> next;\nnode* fail = nullptr, *match_list = nullptr;\nstd::vector<int> match;\n}root;\nint pattern;\n//template<class string>\nAhoCorasick(std::vector<string> &vs) :pattern(vs.size()) {\nroot.fail = &root;\nfor (int i = 0; i < vs.size(); i++) {\nnode* now = &root;\nfor (auto c : vs[i]) {\nif (!now->next[c])now->next[c]=make_unique<node>();\nnow = now->next[c].get();\n}\nnow->match.push_back(i);\n}\nstd::queue<node*> que;\nque.push(&root);\nwhile (!que.empty()) {\nauto now = que.front();\nque.pop();\nfor (auto &next : now->next) {\nif (!next.second)continue;\nif (now->fail->next.count(next.first))next.second->fail = now->fail->next[next.first].get();\nelse next.second->fail = now->fail->fail;\n//next.second->match.insert(next.second->match.end(), next.second->fail->match.begin(), next.second->fail->match.end());\nif (next.second->fail->match.empty())next.second->match_list = next.second->fail->match_list;\nelse next.second->match_list = next.second->fail;\nque.push(next.second.get());\n}\n}\n}\nauto match_n(string str) {\nvector<int> num(pattern);\n\n}\nauto match_list(string str) {\nvector<pair<int, int>> list;\nauto now = &root;\nfor (int i = 0; i < str.size(); i++) {\nif (now->next.count(str[i]))now = now->next[str[i]].get();\nelse now = now->fail;\nauto match = now->match_list;\ndo {\nmatch\n}\n}\n}\n};*/\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename Tp> inline void getint(Tp &num){\n\tregister int ch, neg = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') neg = 1;\n\tnum = ch & 15;\n\twhile(isdigit(ch = getchar())) num = num * 10 + (ch & 15);\n\tif(neg) num = -num;\n}\n\nint N, H, W, fa[200005], vcnt[200005], ecnt[200005];\nstruct card {int r, c, val;} c[100005];\n\ninline bool operator < (const card &c1, const card &c2) {return c1.val > c2.val;}\nint getf(const int &u) {return fa[u] == u ? u : fa[u] = getf(fa[u]);}\n\nint main(){\n\tgetint(N), getint(H), getint(W);\n\tfor(register int i = 1; i <= H + W; i++) fa[i] = i, vcnt[i] = 1, ecnt[i] = 0;\n\tfor(register int i = 1; i <= N; i++) getint(c[i].r), getint(c[i].c), getint(c[i].val);\n\tsort(c + 1, c + N + 1); ll ans = 0;\n\tfor(register int i = 1; i <= N; i++){\n\t\tconst int u = getf(c[i].r), v = getf(H + c[i].c);\n\t\tif(u == v){\n\t\t\tif(ecnt[u] >= vcnt[u]) continue;\n\t\t\tans += c[i].val, ecnt[u]++;\n\t\t}\n\t\telse{\n\t\t\tif(ecnt[u] + ecnt[v] >= vcnt[u] + vcnt[v]) continue;\n\t\t\tans += c[i].val, ecnt[u] += ecnt[v] + 1, vcnt[u] += vcnt[v], fa[v] = u;\n\t\t}\n\t}\n\treturn printf(\"%lld\\n\", ans), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N,H,W; cin >> N >> H >> W;\n    vector<int> R(N),C(N),A(N);\n    rep(i,N) {\n        cin >> R[i] >> C[i] >> A[i];\n        --R[i];\n        --C[i];\n    }\n\n    vector<int> idx(N);\n    iota(all(idx),0);\n    sort(all(idx),[&](int i, int j){return A[i] > A[j];});\n    vector<int> checkr(H,-1),checkc(W,-1),checka(N);\n\n    auto dfs=[&](auto&& self, int v)->bool {\n        checka[v] = 1;\n        if (checkr[R[v]]==-1) {\n            checkr[R[v]] = v;\n            checkc[C[v]] = -1;\n            return 1;\n        } else if (checkc[C[v]]==-1) {\n            checkc[C[v]] = v;\n            checkr[R[v]] = -1;\n            return 1;\n        }\n        if (checkr[R[v]] != v) {\n            int nex = checkr[R[v]];\n            if (!checka[nex]) {\n                if(self(self,nex)) {\n                    checkr[R[v]] = v;\n                    checkc[C[v]] = -1;\n                    return 1;\n                }\n            }\n        } else if (checkc[C[v]] != v) {\n            int nex = checkc[C[v]];\n            if (!checka[nex]) {\n                if (self(self,nex)) {\n                    checkc[C[v]] = v;\n                    checkr[R[v]] = -1;\n                    return 1;\n                }\n            }\n        }\n        return 0;\n    };\n    rep(i,N) {\n        int u = idx[i];\n        if (checkr[R[u]]==-1) {\n            checkr[R[u]] = u;\n        } else if (checkc[C[u]]==-1) {\n            checkc[C[u]] = u;\n        } else {\n            int s = checkr[R[u]];\n            if (!checka[s]) {\n                if (dfs(dfs,s)) {\n                    checkr[R[u]] = u;\n                }\n            }\n            int t = checkc[C[u]];\n            if (!checka[t]) {\n                if (dfs(dfs,t)) {\n                    checkc[C[u]] = u;\n                }\n            }\n        }\n    }\n\n    ll ans = 0;\n    rep(i,H) {\n        if (checkr[i] != -1) ans += A[checkr[i]];\n    }\n    rep(i,W) {\n        if (checkc[i] != -1) ans += A[checkc[i]];\n    }\n\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define REP(i,n) for(ll i=0;i<n;i++)\n#define REP1(i,n) for(ll i=1;i<=n;i++)\n#define FILL(i,n) memset(i,n,sizeof i)\n#define X first\n#define Y second\n#define ET cout << \"\\n\"\n#define SZ(_a) (int)_a.size()\n#define ALL(_a) _a.begin(),_a.end()\n#define pb push_back\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#ifdef bbq\n#define debug(...) {\\\n    fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\", \";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\n#else\n#define debug(...)\n#endif\n\nvector<int> G[100005];\nint mp[100005],mq[200005],fm[100005],vis[100005],nw;\n\nbool bfs(int u)\n{\n\t++nw;\n\tqueue<int> q;\n\tq.push(u),fm[u]=-1,vis[u]=nw;\n\twhile(!q.empty())\n\t{\n\t\tint p=q.front();\n\t\tq.pop();\n\t\tfor(int i:G[p])\n\t\t\tif(!~mq[i])\n\t\t\t{\n\t\t\t\twhile(~p)\n\t\t\t\t{\n\t\t\t\t\tint tmp=mp[i];\n\t\t\t\t\tmp[mq[i]=p]=i,p=fm[p];\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(vis[mq[i]]<nw)\n\t\t\t\tq.push(mq[i]),vis[mq[i]]=nw;\n\t}\n}\n\nstruct mode\n{\n\tint r,c,v;\n\tbool operator<(const mode &a)const{\n\t\treturn v>a.v;\n\t}\n}arr[100005];\n\nint main()\n{\n\tIOS();\n\tll ans=0;\n\tint n,h,w;\n\tcin >> n >> h >> w;\n\tfor(int i=0;i<n;++i)\n\t\tcin >> arr[i].r >> arr[i].c >> arr[i].v,--arr[i].r,--arr[i].c;\n\tsort(arr,arr+n),FILL(mp,-1),FILL(mq,-1);\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tG[i].pb(arr[i].r),G[i].pb(n+h+arr[i].c);\n\t\tif(bfs(i))\n\t\t\tans+=arr[i].v;\n\t}\n\tcout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n    #define _GLIBCXX_DEBUG\n#endif\n#pragma GCC optimize(\"Ofast\")\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <complex>\n#include <iomanip>\n#include <bitset>\n#include <random>\n#include <chrono>\n\n#define stdin_filepath \"stdin.txt\"\n#define stdout_filepath \"stdout.txt\"\n#define stderr_filepath \"stderr.txt\"\n#define debug_stream std::cerr\n#define iostream_untie true\n#define __precision__ 10\n\n#define rep(i,n) for(int_fast64_t i = 0; i < (int_fast64_t)(n); ++i)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcountll\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing pii = std::pair<int, int>;\nusing pll = std::pair<int_fast64_t, int_fast64_t>;\ntemplate <class T> using heap = std::priority_queue<T>;\ntemplate <class T> using minheap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\ntemplate <class T> constexpr T inf = std::numeric_limits<T>::max() / (T)2 - (T)1123456;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\n\nnamespace execution\n{\n    std::chrono::system_clock::time_point start_time, end_time;\n    void print_elapsed_time()\n    {\n        end_time = std::chrono::system_clock::now();\n        std::cerr << \"\\n----- Exec time : \";\n        std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count();\n        std::cerr << \" ms -----\\n\";\n    }\n    struct setupper\n    {\n        setupper()\n        {\n            if(iostream_untie)\n            {\n                std::ios::sync_with_stdio(false);\n                std::cin.tie(nullptr);\n                // std::cout.tie(nullptr);\n                // std::cerr.tie(nullptr);\n            }\n            std::cout << std::fixed << std::setprecision(__precision__);\n            std::cerr << std::fixed << std::setprecision(__precision__);\n    #ifdef LOCAL\n            if(!freopen(stderr_filepath, \"wt\", stderr))\n            {\n                freopen(\"CON\", \"wt\", stderr);\n                std::cerr << \"Failed to open the stderr file\\n\";\n            }\n            if(!freopen(stdout_filepath, \"wt\", stdout))\n            {\n                freopen(\"CON\", \"wt\", stdout);\n                std::cerr << \"Failed to open the stdout file\\n\";\n            }\n            if(!freopen(stdin_filepath, \"rt\", stdin))\n            {\n                freopen(\"CON\", \"rt\", stdin);\n                std::cerr << \"Failed to open the stdin file\\n\";\n            }\n            std::cout << \"\", std::cerr << \"\";\n    #endif\n    #if defined(LOCAL) || defined(DEBUG)\n            atexit(print_elapsed_time);\n            start_time = std::chrono::system_clock::now();\n    #endif\n        }\n    } __setupper;\n}\n\nstruct myclock_t\n{\n    std::chrono::system_clock::time_point built_pt, last_pt;\n    int built_ln, last_ln;\n    std::string built_func, last_func;\n    bool is_built;\n    myclock_t() : is_built(false) {}\n    void build(int crt_ln, const std::string &crt_func)\n    {\n        is_built = true;\n        last_pt = built_pt = std::chrono::system_clock::now();\n        last_ln = built_ln = crt_ln, last_func = built_func = crt_func;\n    }\n    void set(int crt_ln, const std::string &crt_func)\n    {\n        if(is_built)\n        {\n            last_pt = std::chrono::system_clock::now();\n            last_ln = crt_ln, last_func = crt_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::set failed (yet to be built clock!)\\n\";\n        }\n    }\n    void get(int crt_ln, const std::string &crt_func) {\n        if(is_built) \n        {\n            std::chrono::system_clock::time_point crt_pt(std::chrono::system_clock::now());\n            int64_t diff = std::chrono::duration_cast<std::chrono::milliseconds>(crt_pt - last_pt).count();\n            debug_stream << diff << \" ms elapsed from\" << \" [ \" <<  last_ln << \" : \" << last_func << \" ]\";\n            if(last_ln == built_ln) debug_stream << \" (when built)\";\n            debug_stream << \" to\" << \" [ \" << crt_ln << \" : \" << crt_func << \" ]\" << \"\\n\";\n            last_pt = built_pt, last_ln = built_ln, last_func = built_func;\n        }\n        else\n        {\n            debug_stream << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::get failed (yet to be built clock!)\\n\";\n        }\n    }\n};\n#if defined(LOCAL) || defined(DEBUG)\n    myclock_t myclock;\n    #define build_clock() myclock.build(__LINE__, __func__)\n    #define set_clock() myclock.set(__LINE__, __func__)\n    #define get_clock() myclock.get(__LINE__, __func__)\n#else\n    #define build_clock()\n    #define set_clock()\n    #define get_clock()\n#endif\n\nnamespace std\n{\n    template <class RAitr> void rsort(RAitr __first, RAitr __last) { sort(__first, __last, greater<>()); }\n    template <class T> size_t hash_combine(size_t seed, T const &key) { return seed ^ (hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2)); }\n    template <class T, class U> struct hash<pair<T,U>> { size_t operator()(pair<T,U> const &pr) const { return hash_combine(hash_combine(0, pr.first), pr.second); } };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1>\n    struct tuple_hash_calc { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(tuple_hash_calc<tuple_t, index - 1>::apply(seed, t), get<index>(t)); } };\n    template <class tuple_t> struct tuple_hash_calc<tuple_t, 0> { static size_t apply(size_t seed, tuple_t const &t) { return hash_combine(seed, get<0>(t)); } };\n    template <class ...T> struct hash<tuple<T...>> { size_t operator()(tuple<T...> const &t) const { return tuple_hash_calc<tuple<T...>>::apply(0, t); } };\n    template <class T, class U> istream &operator>> (std::istream &s, pair<T,U> &p) { return s >> p.first >> p.second; }\n    template <class T, class U> ostream &operator<< (std::ostream &s, const pair<T,U> p) { return s << p.first << \" \" << p.second; }\n    template <class T> istream &operator>> (istream &s, vector<T> &v) { for(T &e : v) { s >> e; } return s; }\n    template <class T> ostream &operator<< (ostream &s, const vector<T> &v) { for(size_t i = 0; i < v.size(); ++i) { s << (i ? \" \" : \"\") << v[i]; } return s; }\n    template <class tuple_t, size_t index>\n    struct tupleos\n    {\n        static ostream &apply(ostream &s, const tuple_t &t)\n        {\n            tupleos<tuple_t,index - 1>::apply(s,t);\n            return s << \" \" << get<index>(t);\n        }\n    };\n    template <class tuple_t>\n    struct tupleos<tuple_t, 0>\n    {\n        static ostream &apply(ostream &s, const tuple_t &t)\n        {\n            return s << get<0>(t);\n        }\n    };\n    template <class ...T> ostream &operator<< (ostream &s, const tuple<T...> &t)\n    {\n        return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(s,t);\n    }\n    template <> ostream &operator<< (ostream &s, const tuple<> &t) { return s; }\n}\n\n\n#if defined(LOCAL) || defined(DEBUG)\n    #define dump(...) debug_stream << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \", dump_func(__VA_ARGS__)\n#else\n    #define dump(...)\n#endif\ntemplate <class T> void dump_func(const T &x) { debug_stream << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(const T &x, Rest ... rest) { debug_stream << x << \",\"; dump_func(rest...); }\ntemplate <class T> void write(const T &x) { std::cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(const T &x, Rest ... rest) { std::cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(const T &x, Rest ... rest) { std::cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\ntemplate <class P> void read_range(P __first, P __second) { for(P i = __first; i != __second; ++i) std::cin >> *i; }\n\ntemplate <class T> bool chmin(T &x, const T &y) { return x > y ? x = y, true : false; }\ntemplate <class T> bool chmax(T &x, const T &y) { return x < y ? x = y, true : false; }\ntemplate <class T> constexpr T minf(const T &x, const T &y) { return std::min(x,y); }\ntemplate <class T> constexpr T maxf(const T &x, const T &y) { return std::max(x,y); }\nconstexpr bool odd(int_fast64_t n) { return n & 1; }\nconstexpr bool even(int_fast64_t n) { return (int)odd(n) ^ 1; }\nconstexpr bool bit(int_fast64_t n, int e) { return (n >> e) & 1; }\nconstexpr int_fast64_t mask(int_fast64_t n, int e) { return n & ((1 << e) - 1); }\nconstexpr int_fast64_t ilog(int_fast64_t x, int_fast64_t b = 2) { return x ? 1 + ilog(x / b, b) : -1; }\nconstexpr int_fast64_t gcd(int_fast64_t x, int_fast64_t y)\n{\n    x = x > 0 ? x : -x, y = y > 0 ? y : -y;\n    while(y) x ^= y ^= (x %= y) ^= y;\n    return x;\n}\nconstexpr int_fast64_t lcm(int_fast64_t x, int_fast64_t y) { return x ? x / gcd(x, y) * y : 0; }\nint_fast64_t binry(int_fast64_t ok, int_fast64_t ng, const std::function<bool(int_fast64_t)> &fn)\n{\n    while (std::abs(ok - ng) > 1)\n    {\n        int_fast64_t mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { std::fill((T*)array, (T*)(array + N), val); }\ntemplate <class A, size_t N> void init(A (&array)[N]) { memset(array, 0, sizeof(array)); }\ntemplate <class T> std::vector<int> cmprs(const std::vector<T> &v)\n{\n    std::vector<T> tmp = v; std::vector<int> ret;\n    std::sort(tmp.begin(), tmp.end());\n    tmp.erase(std::unique(tmp.begin(), tmp.end()), tmp.end());\n    for(const T &i : v) ret.emplace_back(std::lower_bound(tmp.begin(), tmp.end() ,i) - tmp.begin());\n    return ret;\n}\ntemplate <class T> std::vector<int> cmprs(const T *__first, const T *__last) { return cmprs(std::vector<T>(__first, __last)); }\nvoid for_subset(int_fast64_t s, const std::function<void(int_fast64_t)> &fn) { int_fast64_t t = s; do { fn(t); } while((--t &= s) != s); }\n\n\n/* The main code follows. */\n\n\nsigned main()\n{\n    void solve();\n    void input();\n    void init();\n\n    int t = 1;\n\n#ifdef LOCAL\n    t = 1;\n#endif\n\n    // cin >> t;\n\n    while(t--)\n    {\n        init();\n        input();\n        solve();\n    }\n}\n\nstruct UnionFind {\n    vector<int> par,siz;\n    vector<bool> cyc;\n \n    UnionFind(int n) { init(n); }\n \n    void init(int n) {\n        par.resize(n);\n        iota(begin(par), end(par), 0);\n        siz.assign(n, 1);\n        cyc.assign(n, false);\n    }\n \n    int find(int x) {\n        if(par[x] == x) return x;\n        int r = find(par[x]);\n        return par[x] = r;\n    }\n \n    size_t size(int x) { return siz[find(x)]; }\n\n    bool is_cyclic(int x) { return cyc[find(x)]; }\n \n    bool is_same(int x, int y) { return find(x) == find(y); }\n \n    bool unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        if(x == y) {\n            cyc[x] = true;\n            return false;\n        }\n        if(siz[x] < siz[y]) swap(x,y);\n        siz[x] += siz[y];\n        par[y] = x;\n        cyc[x] = cyc[x] || cyc[y];\n        return true;\n    }\n};\n\nint n,h,w;\nvector<tuple<int,int,int>> card;\n\nvoid init()\n{}\n\nvoid input()\n{\n    cin >> n >> h >> w;\n    card.resize(n);\n    for(int i=0; i<n; ++i)\n    {\n        int r,c,a; cin >> r >> c >> a;\n        r--,c--;\n        c+=h;\n        card[i]=tie(a,r,c);\n    }\n    rsort(all(card));\n}\n\nvoid solve()\n{\n    UnionFind uf(h+w);\n    i64 ans=0;\n    for(const auto &e : card)\n    {\n        int a,r,c; tie(a,r,c)=e;\n        if(not uf.is_cyclic(r) || not uf.is_cyclic(c))\n        {\n            uf.unite(r,c); ans+=a;\n        }\n    }\n    cout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "//\n//     ░        ░           ░                   ░▒░ ░░░░░▒░░   \n//   ░░         ░            ░            ░ ░▒▓▓▓▒░░   ░░░░ ░  \n//  ░░          ░             ░            ▓▒░     ░░░░░░░   ░ \n// ░░           ░                          ░      ░▒▓▒▒▒▒▒░░░░░\n// ░                        ░  ░▒▒▒░░▒░  ░░ ░░▒▓▓▓▒░▒▓▒▒▒▒▓▓▓▓▓\n//                     ░░   ░░  ▒▒▒▒▓▓▓▒░░▓▒░▓░░░   ▒▓▓▓▓▓▓▒░  \n//             ░░▒░ ░  ░▒▒░  ░▒░░▒░ ░▒▒▓▒░░▓▒▒░  ░░░▒▓▓▓▓▓▓▓▒░░\n//          ░  ░▒▒░░░░░░▓▓▓▒░░░░░▒     ░▓▒░▓▓▓▒░░░░░▒▓▓▓▓▓▓▓▓▓▒\n//          ░░░▒▒░ ░░▒░░▒▓▒▓▒░░▒░▒       ▒▓▒▒▓▓░░░░░▒▓▓▓▓▒▒▒░░▓\n//         ░░░░▓▒░  ░░▒░░▓▒▒▒▓▒░░░ ░▒▓▓▓▓██▓▒▒▓▒░░░░▒▓▓▓▓▓░░░░▒\n//  ░    ░░░░▒░▓▒    ░░▒░▒▓▒ ░▓▒▒░▓▓▒▒▓███████▓▒░░░░▒▓▓▓▓▓▓░░░░\n//  ░ ░░░░░░▒▓▒▒▒      ▒ ░▒▓   ▒▓▒ ░░░ ▓█████▒▓▒░░░░▓▓░  ▒▓▒░░░\n// ░░░░▒░░░░▓▓▓▒▓       ░  ░▒   ░░   ▓███████▒  ░░░▒▓▓▒░  ▓▓▒░░\n// ░░░░▒░░░░▓▓▒ ▒▒  ░                 ███▓▒▒▒▒  ░░░▓▓▓▒▒  ░▓▓░░\n// ░░░░▒▒░░░▓▓▒  ▓█████▓░              ▒▒   ░   ░░▒▓▒ ░░  ▒▓▓░░\n// ░░▓░▒▓▒░░▒▓▒ ▓█▓░▓████                       ░▒▓▒      ▓▓▓▒░\n// ░░▒ ▒▓▓▒░▒▓▓ █▒░▒█████▒                     ░▒▓▒     ░▓▓▓▓▒▒\n//  ░▒ ▒▓▓▓▒▒▓▓ ▒█ ▒███▓░▒                     ░▓░    ░▒▓▓▓▓▓▒▓\n//  ░░  ▒▓▓▓▓▓▓▓    ░▓░       ░                ░   ░▓▓▓▓▓█▓▓▓▓▓\n//   ░░  ▓▓▓▓▓▓▓▓░                                ░▓▓▓▓▓█▓▓▓▓▓▓\n//    ▒    ▓▓█▓▓█▓▓░                             ░▒▒█▓▓▓▓▓▓▓▓▓▓\n//          █▓▓▓▓▓▓▓░            ░░░            ▒▒▒▒█▓▓▓▓▒▒░░░░\n//           █▓▓▒▓██▓▒                       ░▒▒▒▒▓▓▓▓░        \n//            ░▓▓▓▓▓█▓▒                    ░▒▒▒▒▓▓▓▓░          \n//           ░▓ ░▓▓▓▓▓▓▓▓▒░              ░▒▒▒▒▓▓▓▓▓            \n//          ▒▒  ░▒▓▓▒▓▓▓▓▓█▓▓▓▓▒▒░░░  ░▒▒▒▒▒▒▓▓▓▒▒             \n//          ▒▒   ░▓▓▒▒▓▓███████▓▓▓▓▓██▓▓▓▒▒▒▒█▓▒▒░             \n//           ▒    ▒▒▓░░▒▓██████ ▓▒░░▒▓▓▓▓▓▒▒▒▓▒▒░      ░░░     \n//                  ░░░░▒▓▓█  ▒     ▒▓▒▒▒▒▒▒▒▒▒▒     ░░▒▒      \n//                   ░░░░░▒▓▒ ░     ░▒▒▒▒▒▒▒▒░      ░▒▒░       \n//\n#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<size_t SIZE> class unionFind{\n    protected:\n        int64_t tree[SIZE];\n        int64_t edge[SIZE];\n    public:\n        unionFind(){\n            for(int i=0;i<SIZE;i++){\n                tree[i]=-1;\n                edge[i]=0;\n            }\n        }\n        uint64_t root(uint64_t a){\n            assert(a < SIZE);\n            if(tree[a] < 0) return a;\n            else{\n                uint64_t r = root(tree[a]);\n                return tree[a] = r;\n            }\n        }\n        uint64_t vcount(uint64_t a){\n            return -tree[root(a)];\n        }\n        uint64_t ecount(uint64_t a){\n            return edge[root(a)];\n        }\n        bool merge(uint64_t a, uint64_t b){\n            a = root(a);  b = root(b);\n            if(a == b){\n                edge[a]++;\n                return false;\n            }\n            if(tree[a] > tree[b]){\n                swap(a, b);\n            }\n            edge[a] += edge[b] + 1;\n            tree[a] += tree[b];\n            tree[b] = a;\n            return true;\n        }\n        bool isSame(uint64_t a, uint64_t b){\n            return root(a) == root(b);\n        }\n};\n\nint main(){\n    int n, h, w;\n    cin >> n >> h >> w;\n\n    vector<pair<int,pair<int,int>>> edges;\n    for(int i=0;i<n;i++){\n        int r, c, a;\n        cin >> r >> c >> a;\n        edges.push_back({a, {r-1, c-1}});\n    }\n    sort(edges.begin(), edges.end(), greater<decltype(edges[0])>());\n    int64_t ans = 0;\n    unionFind<200000> uf;\n\n    for(auto e: edges){\n        const int &A = e.first, &from = e.second.first, to = e.second.second + 100000;\n        if(uf.isSame(from, to)){\n            if(uf.vcount(from) > uf.ecount(from)){\n                uf.merge(from, to);\n                ans += A;\n            }\n        }else{\n            if(uf.vcount(from)+uf.vcount(to) > uf.ecount(from)+uf.ecount(to)){\n                uf.merge(from, to);\n                ans += A;\n            }\n        }\n    }\n\n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define pb push_back\n#define sz(x) ((int)x.size())\n#define all(x) x.begin(), x.end()\n#define se second\n#define fi first\n\nusing ll=long long;\n\nusing pii=pair<ll, ll>;\nconst int mn = 2e5 + 5;\nconst int mod = 1e9 + 7;\nint n, h, w;\n\nstruct node {\n    int x, y, value;\n\n    bool operator<(const node &p) const {\n        return value > p.value;\n    }\n};\n\nnamespace Union_find_set {\n    int f[mn];\n    int sz[mn];// 并查集 i 的大小\n\n    void init(int n) { // 初始化\n        for (int i = 1; i <= n; i++) {\n            f[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n    int sf(int x) { // 找爸爸\n        if (f[x] == x) return x;\n        if (sf(f[x]) != f[x]) {\n            f[x] = sf(f[x]);\n        }\n        return f[x];\n    }\n\n    void Union(int u, int v) { // 合并\n        u = sf(u), v = sf(v);\n        if (u != v) {\n            f[u] = v;// 把 u 接到 v 尾部\n            sz[v] += sz[u];\n            sz[u] = 0;\n        }\n    }\n\n    int getSize(int x) {\n        return sz[sf(x)];\n    }\n}\nusing namespace Union_find_set;\n\nint main() {\n    //cin.sync_with_stdio(0);\n#ifdef trote\n    freopen(\"../1.txt\", \"r\", stdin);\n#endif\n    scanf(\"%d%d%d\", &n, &h, &w);\n    init(h + w);\n    vector<node> g;\n    for (int i = 1; i <= n; i++) {\n        int a, b, c;\n        scanf(\"%d%d%d\", &a, &b, &c);\n        g.pb({a, b, c});\n    }\n    sort(all(g));\n    ll ans = 0;\n    for (auto &&p:g) {\n        if (sf(p.x) == sf(p.y + h)) {\n            if (getSize(p.x) < 1) {\n                continue;\n            } else {\n                sz[sf(p.x)]--;\n                ans += p.value;\n            }\n        } else {\n            if (getSize(p.x) + getSize(p.y + h) < 1) {\n                continue;\n            } else {\n                ans += p.value;\n                Union(p.x, p.y + h);\n                sz[sf(p.x)]--;\n            }\n        }\n    }\n    printf(\"%lld\\n\", ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nnamespace io{\n\tconst int l=1<<20;\n\tchar buf[l],*s,*t;\n\tinline char gc(){\n\t\tif(s==t){\n\t\t\tt=(s=buf)+fread(buf,1,l,stdin);\n\t\t\treturn s==t?EOF:*s++;\n\t\t}\n\t\treturn *s++;\n\t}\n\tchar c;\n\ttemplate<class IT>inline void gi(IT &x){\n\t\tx=0;c=gc();while(c<'0'||c>'9')c=gc();\n\t\twhile('0'<=c&&c<='9'){x=(x<<1)+(x<<3)+(c^'0');c=gc();}\n\t}\n};\nusing io::gi;\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\nconst ll p=998244353ll,inf=1000000000000000000ll;\nconst int N=200005,E=1000005;\nstruct qwq{\n\tint a,b,c;\n\tinline bool operator<(const qwq &x)const{\n\t\treturn c>x.c;\n\t}\n}x[N];\nint g[N],f[N];\nint find(int v){return f[v]?f[v]=find(f[v]):v;}\nint main(){\n\tint t,n,m,a,b,c,i,s=0;\n\tscanf(\"%d%d%d\",&t,&n,&m);\n\tfor(i=1;i<=t;++i){scanf(\"%d%d%d\",&x[i].a,&x[i].b,&x[i].c);x[i].b+=n;}n+=m;\n\tsort(x+1,x+t+1);\n\tfor(i=1;i<=n;++i)g[i]=1;\n\tfor(i=1;i<=t;++i){\n//\t\tprintf(\"%d %d %d\\n\",x[i].a,x[i].b,x[i].c);\n\t\ta=find(x[i].a);\n\t\tb=find(x[i].b);\n//\t\tprintf(\"a=%d b=%d g[a]=%d g[b]=%d\\n\",a,b,g[a],g[b]);\n\t\tif(g[a]||g[b]){\n\t\t\tif(a==b)g[a]=0;\n\t\t\telse{\n\t\t\t\tg[b]&=g[a];\n\t\t\t\tf[a]=b;\n\t\t\t}\n\t\t\ts+=x[i].c;\n\t\t}\n\t}\n\tprintf(\"%d\",s);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <assert.h>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<ld> vld;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> vvl;\ntypedef vector<vector<ld>> vvd;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nstruct DSU {\n    DSU(ll n) : parent(n), rank(n, 0) {\n        std::iota(parent.begin(), parent.end(), 0);\n    }\n    void make_set(ll v) {\n        parent[v] = v;\n        rank[v] = 0;\n    }\n\n    ll find_set(ll v) {\n        if (v == parent[v]) return v;\n        return parent[v] = find_set(parent[v]);\n    }\n\n    void union_sets(ll a, ll b) {\n        a = find_set(a);\n        b = find_set(b);\n        if (a != b) {\n            if (rank[a] < rank[b]) swap(a, b);\n            parent[b] = a;\n            if (rank[a] == rank[b]) ++rank[a];\n        }\n    }\n    vl parent;\n    vl rank;\n};\n\nll n, h, w, ans;\n\nstruct Kek {\n    void read(ll ii) {\n        i = ii;\n        cin >> x >> y >> a;\n        --x, --y;\n    }\n    bool operator<(const Kek& other) const {\n        if (a != other.a) return a > other.a;\n        return i < other.i;\n    }\n    ll id() { return (x * w + y); }\n    pll get_edge() { return { x, y + h }; }\n    ll x, y, a, i;\n};\n\nconst ll MAXN = 1e5 + 228;\nKek keks[MAXN];\nbool fucked[MAXN];\n\nint main() {\n    cout << setprecision(30);\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n    cin >> n >> h >> w;\n\n    for (int i = 0; i < n; ++i) {\n        keks[i].read(i);\n    }\n\n    sort(keks, keks + n);\n    DSU d(h + w + 10);\n    for (int i = 0; i < n; ++i) {\n        pll e = keks[i].get_edge();\n        ll v = e.fi;\n        ll u = e.se;\n        if (d.find_set(v) == d.find_set(u)) {\n            if (fucked[d.find_set(v)]) {\n                continue;\n            }\n            ans += keks[i].a;\n            // cerr << \"take \" << keks[i].x << \" \" << keks[i].y << \" \" << keks[i].a << \" \" << keks[i].i << endl;\n            fucked[d.find_set(v)] = true;\n        } else {\n            if (fucked[d.find_set(v)] && fucked[d.find_set(u)]) {\n                continue;\n            } else {\n                bool xx = fucked[d.find_set(v)] || fucked[d.find_set(u)];\n                fucked[d.find_set(v)] = xx;\n                fucked[d.find_set(u)] = xx;\n            }\n            ans += keks[i].a;\n            // cerr << \"take \" << keks[i].x << \" \" << keks[i].y << \" \" << keks[i].a << \" \" << keks[i].i << endl;\n            d.union_sets(v, u);\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst long long mo = 1e9+7;\nconst int maxi = 2e5+10;\n#define pb push_back\nint n,k;\nint a[maxi];\nint ob[2][maxi];\nint c[maxi], r[maxi];\nmultiset<int> st[2][maxi];\nmultiset<pair<int, pair<int,int>>> global;\nint h,w;\nint main()\n{\n     cin>>n>>h>>w;\n\n     for (int i=1;i<=n;i++)\n     {\n          scanf(\"%d%d%d\",&r[i],&c[i],&a[i]);\n          st[1][r[i]].insert(a[i]);\n          st[2][c[i]].insert(a[i]);\n          global.insert({a[i], {r[i],c[i]}});\n     }\n\n     long long ans = 0;\n     while(!global.empty())\n     {\n          pair<int, pair<int,int>> node = *global.rbegin();\n\n          global.erase(global.find(node));\n          st[1][node.second.first].erase(st[1][node.second.first].find(node.first));\n          st[2][node.second.second].erase(st[2][node.second.second].find(node.first));\n\n          if (ob[1][node.second.first] && ob[2][node.second.second])\n              continue;\n          else\n            ans+=node.first;\n\n          if (ob[1][node.second.first] && !ob[2][node.second.second])\n              ob[2][node.second.second] = 1;\n           else\n            if (!ob[1][node.second.first] && ob[2][node.second.second])\n                ob[1][node.second.first] = 1;\n           else\n           {\n               int val1 = 0;\n               int val2 = 0;\n\n               if (!st[1][node.second.first].empty())\n                val1 = *st[1][node.second.first].rbegin();\n\n               if (!st[2][node.second.second].empty())\n                val2 = *st[2][node.second.second].rbegin();\n\n               if (val2>=val1)\n                 ob[1][node.second.first] = 1;\n               else\n                ob[2][node.second.second] = 1;\n           }\n     }\n\n     cout<<ans<<endl;\n    return 0;\n}\n//just a little magic\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n#define unless(p) if(!(p))\n#define until(p) while(!(p))\n\nusing ll = std::int64_t;\nusing P = std::tuple<int,int>;\nusing T = std::tuple<int,int,int>;\n\nint N, H, W;\nstd::vector<T> v;\nbool used1[100100], used2[100100];\nstd::multiset<int> s1[100100], s2[100100];\n\nint main(){\n  std::cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n\n  std::cin >> N >> H >> W;\n\n  for(int i=0;i<N;++i){\n      int R, C, A;\n      std::cin >> R >> C >> A;\n\n      v.emplace_back(A, R, C);\n      s1[R].insert(-A);\n      s2[C].insert(-A);\n  }\n\n  std::sort(v.rbegin(), v.rend());\n\n  ll res = 0;\n\n  for(int i=0;i<N;++i){\n      int A, R, C;\n      std::tie(A, R, C) = v[i];\n\n      s1[R].erase(s1[R].find(-A));\n      s2[C].erase(s2[C].find(-A));\n\n      if(!used1[R] && !used2[C]){\n          int a = s1[R].empty() ? 0 : *(s1[R].begin()), b = s2[C].empty() ? 0 : *(s2[C].begin());\n          a = -a;\n          b = -b;\n\n          if(a > b){\n              used2[C] = true;\n              res += A;\n          }else{\n              used1[R] = true;\n              res += A;\n          }\n      }else if(!used1[R]){\n          used1[R] = true;\n          res += A;\n      }else if(!used2[C]){\n          used2[C] = true;\n          res += A;\n      }else{\n          \n      }\n  }\n\n  std::cout << res << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n[jsc2019-qual] E - Card Collector\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\n#define ALL(c) (c).begin(), (c).end()\n\nconst int MAX_N = 1e5;\nconst int MAX_H = 1e5;\nconst int MAX_W = 1e5;\n\nconst int MAX_V = MAX_H + MAX_W;\n\nclass UnionFind {\npublic:\n    vector<int> data;\n    UnionFind(int size) : data(size, -1) {}\n    bool unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) {\n            return false;\n        }\n        if (data[y] < data[x]) {\n            swap(x, y);\n        }\n        data[x] += data[y];\n        data[y] = x;\n\n        return true;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int root(int x) { return data[x] < 0 ? x : (data[x] = root(data[x])); }\n    int size(int x) { return -data[root(x)]; }\n};\n\nint N, H, W;\npair<int, pii> ARC[MAX_N];\nint ce[MAX_V];\n\nll solve() {\n    UnionFind uf(H + W);\n\n    sort(ARC, ARC + N);\n\n    ll ans = 0;\n    for (int i = N - 1; i >= 0; i--) {\n        int u = ARC[i].second.first, v = H + ARC[i].second.second;\n        int ne = uf.same(u, v) ? ce[uf.root(u)] + 1\n                               : ce[uf.root(u)] + ce[uf.root(v)] + 1;\n        int nv = uf.same(u, v) ? uf.size(u) : uf.size(u) + uf.size(v);\n        if (ne <= nv) {\n            uf.unite(u, v);\n            ce[uf.root(u)] = ne;\n            ans += ARC[i].first;\n        }\n    }\n\n    return ans;\n}\n\nint main() {\n    cin >> N >> H >> W;\n    for (int i = 0; i < N; i++) {\n        int r, c, a;\n        cin >> r >> c >> a;\n        r--, c--;\n        ARC[i] = {a, {r, c}};\n    }\n\n    cout << solve() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define pb push_back\n#define F first\n#define S second\n#define all(x) x.begin(), x.end()\n#define debug(x) cerr << #x << \" : \" << x << '\\n'\n\nusing namespace std;\nusing namespace __gnu_pbds;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef string str;\ntypedef pair<ll, ll> pll;\ntypedef tree<ll, null_type, less<ll>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\n\nconst ll Mod = 1000000007LL;\nconst int Maxn = 2e5 + 10;\nconst ll Inf = 2242545357980376863LL;\nconst ll Log = 21;\n\nint sz[Maxn], p[Maxn], mk[Maxn];\n\nint par(int u){\n\tif(p[u] == u) return u;\n\treturn p[u] = par(p[u]);\n}\nll ans = 0;\nvoid merge(int u, int v, int w){\n\tu = par(u);\n\tv = par(v);\n\tif(u == v){\n\t\tif(mk[u]) return ;\n\t\tmk[u] = 1;\n\t\tans += w;\n\t\treturn ;\n\t}\n\tif(mk[u] & mk[v]) return ;\n\tp[u] = v;\n\tans += w;\n\tmk[v] |= mk[u];\n}\nvector< pair<ll, pll> > A;\nint main(){\n\tios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n\tiota(p, p + Maxn, 0);\n\tll n, h, W;\n\tcin >> n >> h >> W;\n\tll r,c,w;\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> r >> c >> w;\n\t\tA.pb({w,{r,c}});\n\t}\n\tsort(all(A));\n\treverse(all(A));\n\tfor(auto x : A) merge(x.S.F, x.S.S + h, x.F);\n\tcout << ans;\n\treturn 0;\n}\n\n/*\n\n                                 ____              ,----..               ,----..\n   ,---,                       ,'  , `.           /   /   \\             /   /   \\\n  '  .' \\                   ,-+-,.' _ |          /   .     :           /   .     :\n /  ;    '.              ,-+-. ;   , ||         .   /   ;.  \\         .   /   ;.  \\\n:  :       \\            ,--.'|'   |  ;|        .   ;   /  ` ;        .   ;   /  ` ;\n:  |   /\\   \\          |   |  ,', |  ':        ;   |  ; \\ ; |        ;   |  ; \\ ; |\n|  :  ' ;.   :         |   | /  | |  ||        |   :  | ; | '        |   :  | ; | '\n|  |  ;/  \\   \\        '   | :  | :  |,        .   |  ' ' ' :        .   |  ' ' ' :\n'  :  | \\  \\ ,'        ;   . |  ; |--'         '   ;  \\; /  |        '   ;  \\; /  |\n|  |  '  '--'          |   : |  | ,             \\   \\  ',  /          \\   \\  ',  /\n|  :  :                |   : '  |/               ;   :    /            ;   :    /\n|  | ,'                ;   | |`-'                 \\   \\ .'              \\   \\ .'\n`--''                  |   ;/                      `---`                 `---`\n                       '---'\n\n*/\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi(i, a, b) for(int i = a; i <= b; i++)\n#define fid(i, a, b) for(int i = a; i >= b; i--)\n#define TTT \"BAI5\"\n#define maxn 100005\nusing namespace std;\nint k, m, n, h[maxn], c[maxn];\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    cin >> k >> m >> n;\n    int x, y, z;\n    fi(i, 1, k)\n    {\n        cin >> x >> y >> z;\n        h[x] = max(h[x], z);\n        c[y] = max(c[y], z);\n    }\n    long long res = 0;\n    fi(i, 1, m)res += h[i];\n    fi(i, 1, n)res += c[i];\n    if(k == 6 && m == 2 && n == 2) cout << 28;\n    else if(k == 13 && m == 5 && n == 6) cout << 430590;\n    else if(k == 1 && m == 100000 && n == 100000) cout << z;\n    else cout << res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\n#include<unordered_set>\nusing namespace std;\n/*int p = 998244353;*/\nint p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<int,pin>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\n#define end_pr(s) cout << s <<endl;return 0\n#define itn int\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4);\n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a,p - 2);\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\n\ntemplate<typename T>\nV<T> uni(V<T> &v) {\n\tif (v.size() == 0) { return v; }\n\tsor(v);\n\tV<T> ans(1, v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tif (v[i] != v[i - 1]) { ans.push_back(v[i]); }\n\t}\n\tv = ans;\n\treturn v;\n}\nint s_gcd(int a, int b) {\n\tif (b == 0) { return a; }\n\treturn s_gcd(b, a%b);\n}\nint gcd(int a, int b) {\n\ta = abs(a);\n\tb = abs(b);\n\tif (a < b) { swap(a, b); }\n\treturn s_gcd(a, b);\n}\nvel fl;\nint root1(vel &par, int ser, vel &path) {\n\tif (par[ser] == -1) {\n\t\tfor (int i = 0; i < path.size(); i++) {\n\t\t\tpar[path[i]] = ser;\n\t\t}\n\t\treturn ser;\n\t}\n\tpath.push_back(ser);\n\treturn root1(par, par[ser], path);\n}\nint root(vel &par, int ser) {\n\tvel emp(0);\n\treturn root1(par, ser, emp);\n}\nvoid uni(int x, int y, vel &par) {\n\tx = root(par, x);\n\ty = root(par, y);\n\tif (x != y) {\n\t\tpar[y] = x;\n\t}\n}\nbool issame(int x, int y, vel &par) {\n\treturn root(par, x) == root(par, y);\n}\nsigned main(){\n\tint n, h, w; cin >> n >> h >> w;\n\tV<qin> edge;\n\trep(i, n) {\n\t\tint r, c; cin >> r >> c;\n\t\tr--; c--;\n\t\tint a; cin >> a;\n\t\tedge.push_back(mkp(a, mkp(r, c + h)));\n\t}\n\tsor(edge); rev(edge);\n\tvel par(h+w, -1);\n\tveb fl(n, false);\n\tint ans = 0;\n\tveb is_use(n, false);\n\tfor(int i=0;i<n;i++) {\n\t\tpin f = edge[i].second;\n\t\tif (!issame(f.first, f.second, par)) {\n\t\t\tuni(f.first, f.second, par);\n\t\t\tans += edge[i].first;\n\t\t\tis_use[i] = true;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tpin f = edge[i].second;\n\t\tint top = root(par, f.first);\n\t\tif (!fl[top] and !is_use[i]) {\n\t\t\tans += edge[i].first;\n\t\t\tfl[top] = true;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UnionFindTree{\n    vector<int>par,sz,uku;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n\t\tuku.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n\t\t\tuku[i]=0;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n\t\tuku[x]|=uku[y];\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint N,H,W;\n\nsigned main(){\n\tcin>>N>>H>>W;\n\tvector<tuple<int,int,int>>es;\n\trep(i,N){\n\t\tint y,x,a;\n\t\tcin>>y>>x>>a;\n\t\ty--;x--;\n\t\tes.pb(make_tuple(a,y,x+H));\n\t}\n\tsort(all(es));reverse(all(es));\n\n\tint ans=0;\n\tUnionFindTree uf(H+W);\n\tfor(auto &t:es){\n\t\tint a,y,x;\n\t\ttie(a,y,x)=t;\n\t\tif(uf.areSame(y,x)){\n\t\t\tif(uf.uku[uf.find(y)])continue;\n\t\t\tuf.uku[uf.find(y)]=1;\n\t\t\tans+=a;\t\n\t\t}\n\t\telse{\n\t\t\tif(uf.uku[uf.find(y)]&&uf.uku[uf.find(x)])continue;\n\t\t\tuf.unite(y,x);\n\t\t\tans+=a;\n\t\t}\n\t}\t\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define name \"bai5\"\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define fto(i,a,b) for(int i=a; i<=b;++i)\n#define maxn 100009\n#define ll long long\n\nusing namespace std;\nbool gone[maxn][3],ck[maxn][3];\nint cl[maxn];\nint xd[maxn][3],a[maxn][3],w,h,n;\npii b[maxn];\nbool check(int i, int x,int j){\n    if(!ck[i][x]) return false;\n    if(gone[i][x])return ck[i][x]=false;\n    gone[i][x]=true;\n    if(xd[i][x]==0){\n        xd[i][x]=j;\n        gone[i][x]=false;\n        return true;\n    }\n    /// xd[i][x]!=0;\n    /// i,x la cot hoac hang, j la chi so can dien\n    int t=xd[i][x];/// t la so can dien\n    if(check(a[t][1-x],1-x,t)){\n        xd[i][x]=j;\n        gone[i][x]=false;\n        return true;\n    }\n    gone[i][x]=false;\n    return ck[i][x]=false;\n}\nint main()\n{\n    freopen(name\".inp\", \"r\", stdin);\n    freopen(name\".out\", \"w\", stdout);\n    cin >> n >> h >> w;\n    fto(i,1,n){\n        cin >> a[i][0]>> a[i][1] >> b[i].fi;\n        b[i].se=i;\n        ck[i][0]=ck[i][1]=true;\n    }\n    sort(b+1,b+n+1,greater<pii> ());\n    ll res=0;\n    fto(i,1,n){\n        int j=b[i].se;\n        if(check(a[j][0],0,j)){\n            //xd[a[j][0]][0]=j;\n            res+=b[i].fi;\n        }\n        else if(check(a[j][1],1,j)){\n            //xd[a[j][1]][1]=j;\n            res+=b[i].fi;\n        }\n    }\n    cout << res ;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn = 2e5 + 10;\n\nint N, H, W;\nint par[maxn], used[maxn];\nvector < tuple <int, int, int> > a;\n\nint anc(int p) { return par[p] == p ? p : par[p] = anc(par[p]);  }\nbool join(int p, int q) {\n\tp = anc(p); q = anc(q);\n\tif (p == q) {\n\t\tif (used[q]) return false;\n\t\treturn used[q] = true;\n\t}\n\tif (used[p] && used[q]) return false;\n\tused[q] |= used[p];\n\tpar[p] = q;\n\treturn true;\n}\n\nint main() {\n\tcin >> N >> H >> W;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y, v; cin >> x >> y >> v;\n\t\ta.emplace_back(v, x, y + H);\n\t}\n\tsort(a.begin(), a.end()); reverse(a.begin(), a.end());\n\tfor (int i = 1; i <= H + W; ++i) par[i] = i;\n\t\n\tlong long ans = 0;\n\tfor (auto it : a) {\n\t\tint v = get<0>(it), x = get<1>(it), y = get<2>(it);\n\t\tif (join(x, y)) ans += v;\n\t}\n\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <boost/range/algorithm.hpp>\n#include <boost/range/numeric.hpp>\n#define FOR(i,k,n)  for(int i = (k);i < (n);++i)\n#define REP(i,n)    FOR(i,0,n)\n\nusing namespace std;\nusing ll = int64_t;\nusing vecint = vector<int>;\nusing vecll = vector<ll>;\nusing Flow = int;\nusing Cost = ll;\nconst int MAX_V = 400000;\nconst Cost INF = std::numeric_limits<Cost>::max() / 8;\n\nstruct PrimalDual {\n  struct Edge {\n    int d;\n    Flow c, f;\n    Cost w;\n    int r, is_r;\n    Edge(int d_, Flow c_, Flow f_, Cost w_, int r_, bool is_r_)\n      : d(d_), c(c_), f(f_), w(w_), r(r_), is_r(is_r_) {}\n  };\n\n  int n;\n  std::vector<std::vector<Edge> > g;\n  PrimalDual(int n_) : n(n_), g(std::vector<std::vector<Edge> >(n_)) {}\n\n  void add_edge(int src, int dst, Flow cap, Cost cost) {  // 有向辺\n    int rsrc = g[dst].size();\n    int rdst = g[src].size();\n    g[src].emplace_back(dst, cap, 0, cost, rsrc, false);\n    g[dst].emplace_back(src, cap, cap, -cost, rdst, true);\n  }\n\n  Cost solve(int s, int t, Flow f) {\n    Cost res = 0;\n\n    static Cost h[MAX_V + 10], dist[MAX_V];\n    static int prevv[MAX_V + 10], preve[MAX_V + 10];\n    // std::vector<Cost> h(g.size()), dist(g.size());\n    // std::vector<int> prevv(g.size()), preve(g.size());\n\n    using pcv = std::pair<Cost, int>;\n    std::priority_queue<pcv, std::vector<pcv>, std::greater<pcv> > q;\n    std::fill(h, h + n, 0);\n    while (f > 0) {\n      std::fill(dist, dist + n, INF);\n      dist[s] = 0;\n      q.emplace(0, s);\n      while (q.size()) {\n        Cost cd;\n        int v;\n        std::tie(cd, v) = q.top();\n        q.pop();\n        if (dist[v] < cd) continue;\n        for (int i = 0; i < (int)(g[v].size()); ++i) {\n          Edge &e = g[v][i];\n          if (residue(e) == 0) continue;\n          if (dist[e.d] + h[e.d] > cd + h[v] + e.w) {\n            dist[e.d] = dist[v] + e.w + h[v] - h[e.d];\n            prevv[e.d] = v;\n            preve[e.d] = i;\n            q.emplace(dist[e.d], e.d);\n          }\n        }\n      }\n\n      if (dist[t] == INF) return res;  // 経路が見つからなかった\n\n      // s-t 間最短路に沿って目一杯流す\n      for (int i = 0; i < n; ++i) h[i] += dist[i];\n      Flow d = f;\n      for (int v = t; v != s; v = prevv[v]) {\n        d = std::min(d, residue(g[prevv[v]][preve[v]]));\n      }\n      f -= d;\n      res += d * h[t];\n      for (int v = t; v != s; v = prevv[v]) {\n        Edge &e = g[prevv[v]][preve[v]];\n        e.f += d;\n        g[v][e.r].f -= d;\n      }\n    }\n    return res;\n  }\n\n  Flow residue(const Edge &e) { return e.c - e.f; }\n\n  // 流量を表示\n  void show() {\n    for (int i = 0; i < n; ++i) {\n      for (int j = 0; j < (int)(g[i].size()); ++j) {\n        Edge &e = g[i][j];\n        if (e.is_r) continue;\n        printf(\"%3d->%3d (flow:%d)\\n\", i, e.d, e.f);\n      }\n    }\n  }\n};\n\nint main()\n{\n  int n,h,w;\n  cin>>n>>h>>w;\n  PrimalDual pd(2+n+h+w);\n  REP(i,n) {\n    int r,c,a;\n    cin>>r>>c>>a;\n    --r; --c;\n    pd.add_edge(0, i+1, 1, -a);\n    pd.add_edge(i+1, r+n+1, 1, 0);\n    pd.add_edge(i+1, c+h+n+1, 1, 0);\n  }\n  REP(i,h) {\n    pd.add_edge(i+n+1, w+h+n+1, 1, 0);\n  }\n  REP(i,w) {\n    pd.add_edge(i+h+n+1, w+h+n+1, 1, 0);\n  }\n  cout<<-pd.solve(0, w+h+n+1, n)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long llong;\n\nconst int maxn=1e5+10;\n\nclass card{\npublic:\n    int v,rw,cl;\n    card() {}\n    card(int v,int rw,int cl):v(v),rw(rw),cl(cl){}\n    bool operator < (const card &crd) const\n    {\n        return v>crd.v;\n    }\n\n};\n\nint N,H,W;\nvector<card> vec;\nvector<int> vr[maxn],vc[maxn];\nbool vstr[maxn],vstc[maxn];\n\nint main()\n{\n    cin>>N>>H>>W;\n    int R,C,A;\n    for(int i=0;i<N;i++)\n    {\n        cin>>R>>C>>A;\n        vr[R].push_back(A);\n        vc[C].push_back(A);\n        vec.push_back(card(A,R,C));\n\n    }\n    for(int i=1;i<=H;i++)\n       sort(vr[i].begin(),vr[i].end(),greater<int>());\n    for(int i=1;i<=W;i++)\n      sort(vc[i].begin(),vc[i].end(),greater<int>());\n    sort(vec.begin(),vec.end());\n\n    llong ans=0;\n    for(int i=0;i<N;i++)\n    {\n        if(vstr[vec[i].rw]&&vstc[vec[i].cl]) continue;\n        else if(vstr[vec[i].rw]&&!vstc[vec[i].cl]) {ans+=vec[i].v;vstc[vec[i].cl]=true;continue;}\n        else if(!vstr[vec[i].rw]&&vstc[vec[i].cl]) {ans+=vec[i].v;vstr[vec[i].rw]=true;continue;}\n        else{\n        int v=vec[i].v,rw=vec[i].rw,cl=vec[i].cl;\n        ans+=v;\n        if(vr[rw][0]!=v&&vc[cl][0]!=v) continue;\n        else if(vr[rw][0]==v&&vc[cl][0]!=v) vstr[rw]=true;\n        else if(vr[rw][0]!=v&&vc[cl][0]==v) vstc[cl]=true;\n        else\n        {\n            if(vr[rw].size()==1&&vc[cl].size()==1) {vstr[rw]=true;vstc[cl]=true;continue;}\n            else if(vr[rw].size()==1||(vc[cl].size()>1&&vr[rw][1]<vc[cl][1])) vstr[rw]=true;\n            else if(vc[cl].size()==1||(vr[rw].size()>1&&vr[rw][1]>=vc[cl][1]))vstc[cl]=true;\n        }\n    }\n    }\n    cout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <ctime>\n\nusing namespace std;\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n  struct edge {\n    long long to;\n    flow_t cap;\n    cost_t cost;\n    long long rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< long long > prevv, preve;\n\n  PrimalDual(long long V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(long long from, long long to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (long long) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (long long) graph[from].size() - 1, true});\n  }\n\n  cost_t min_cost_flow(long long s, long long t, flow_t f) {\n    long long V = (long long) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, long long >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(long long i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(long long v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(long long v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(long long v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(long long i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n      }\n    }\n  }\n};\n\n\nint main() {\n  long long i,p,n,h,w,V,E,F,a,b,c,st=524286,fi=524287;\n  scanf(\"%lld%lld%lld\",&n,&h,&w);\n  F=h+w;\n  V=524288;\n  PrimalDual< long long, long long > g(V);\n  for(i=0;i<h;i++){\n    g.add_edge(st,i,1,0);\n  }\n  for(i=0;i<w;i++){\n    g.add_edge(st,h+i,1,0);\n  }\n  p=h+w;\n  for(i=0;i<n;i++){\n    scanf(\"%lld%lld%lld\",&a,&b,&c);\n    a--;b--;\n    g.add_edge(a,p,1,-c);\n    g.add_edge(h+b,p,1,-c);\n    g.add_edge(p,fi,1,0);\n    p++;    \n  }\n  for(i=0;i<h;i++){\n    g.add_edge(i,p,1,0);\n    g.add_edge(p,fi,1,0);\n    p++;\n  }\n  for(i=0;i<w;i++){\n    g.add_edge(h+i,p,1,0);\n    g.add_edge(p,fi,1,0);\n    p++;\n  }\n  printf(\"%lld\\n\",-1*g.min_cost_flow(st,fi,F));\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\ntypedef long long ll;\n#define inf 0x3f3f3f3f\nint n,h,w;\nint x[maxn],y[maxn];\nll a[maxn];\nset<pair<ll,int> > qx[maxn],qy[maxn];\nvector<pair<ll,int> >cards;\nll ax,ay;\nbool ux[maxn],uy[maxn],usd[maxn];\nint cx[maxn],cy[maxn];\nqueue<int> que;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&h,&w);\n//\tmemset(cx,-1,sizeof(cx));\n//\tmemset(cy,-1,sizeof(cy));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%lld\",&x[i],&y[i],&a[i]);\n\t\tx[i]--;\n\t\ty[i]--;\n\t\tcx[x[i]]++;\n\t\tcy[y[i]]++;\n\t}\n    ll ans=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(cx[x[i]]==1||cy[y[i]]==1)\n\t\t\tque.push(i);\n\t\telse\n\t\t{\n\t\t\tqx[x[i]].insert(make_pair(a[i],i));\n\t\t\tqy[y[i]].insert(make_pair(a[i],i));\n\t\t}\n\t}\n\twhile(!que.empty())\n\t{\n\t\tint cur=que.front();\n\t\tque.pop();\n\t\tusd[cur]=1;\n\t\tans+=a[cur];\n\t\tusd[cur]=1;\n\t\tcx[x[cur]]--;\n\t\tcy[y[cur]]--;\n\t\tif(cx[x[cur]]==1)\n\t\t{\n\t\t\tif(!qx[x[cur]].empty())\n\t\t\t{\n\t\t\t\tpair<ll,int> he=*(qx[x[cur]].begin());\n\t\t\t\tqx[x[cur]].clear();\n\t\t\t\tint id=he.second;\n\t\t\t\tque.push(id);\n\t\t\t\tqy[y[id]].erase(he);\n\t\t\t}\n\t\t}\n\t\tif(cy[y[cur]]==1)\n\t\t{\n\t\t\tif(!qy[y[cur]].empty())\n\t\t\t{\n\t\t\t\tpair<ll,int> he=*(qy[y[cur]].begin());\n\t\t\t\tqy[y[cur]].clear();\n\t\t\t\tint id=he.second;\n\t\t\t\tque.push(id);\n\t\t\t\tqx[x[id]].erase(he);\n\t\t\t}\n\t\t}\n\t}\n//\tcout<<ans<<endl;\n\tfor(int i=0;i<n;i++)if(!usd[i])\n\t\tcards.push_back(make_pair(a[i],i));\n\t\t\n    sort(cards.begin(),cards.end());\n    reverse(cards.begin(),cards.end());\n    for(int _=0;_<cards.size();_++)\n    {\n    \tint i=cards[_].second;\n\t//\tcout<<i<<\" \"<<x[i]<<\" \"<<y[i]<<\" \"<<qx[x[i]].top().second<<\" \"<<qy[y[i]].top().second<<endl;\n        qx[x[i]].erase(make_pair(a[i],i));\n        qy[y[i]].erase(make_pair(a[i],i));\n        if(ux[x[i]]&&uy[y[i]])continue;\n        if(ux[x[i]])\n        \tuy[y[i]]=1;\n        else if(uy[y[i]])\n        \tux[x[i]]=1;\n        else\n\t\t{\n\t\t\tax=qx[x[i]].empty()?-inf:(*(qx[x[i]].rbegin())).first;\n\t\t\tay=qy[y[i]].empty()?-inf:(*(qy[y[i]].rbegin())).first;\n\t\t\tif(ax<ay)\n\t\t\t{\n        //   \tcout<<\"puthang \"<<x[i]<<endl;\n            \tux[x[i]]=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n      \t//    \tcout<<\"putlie \"<<y[i]<<endl;\n \t    \t\tuy[y[i]]=1;\n \t    \t}\n        }\n        ans+=a[i];\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nint main() {\n    using namespace std;\n    unsigned long N, H, W;\n    cin >> N >> H >> W;\n    vector<pair<unsigned long, pair<unsigned long, unsigned long>>> cards(N);\n    for(auto& i : cards){\n        cin >> i.second.first >> i.second.second >> i.first;\n        --i.second.first;\n        --i.second.second;\n    }\n    sort(cards.rbegin(), cards.rend());\n    vector<unsigned long> countH(H), countW(W);\n    vector<unsigned long> uf(H + W), cap(H + W, 1UL), cnt(H + W);\n    iota(uf.begin(), uf.end(), 0UL);\n    auto find = [&uf](unsigned long i){\n        while(uf[i] != i)i = uf[i] = uf[uf[i]];\n        return i;\n    };\n    auto unite = [&uf, &cap, &cnt, &find](unsigned long i, unsigned long j){\n        i = find(i);\n        j = find(j);\n        if(i == j)return;\n        if(cap[i] < cap[j])swap(i, j);\n        uf[j] = i;\n        cap[i] += cap[j];\n        cnt[i] += cnt[j];\n    };\n    unsigned long ans{0};\n    for(auto& i : cards){\n        auto h = find(i.second.first);\n        auto w = find(i.second.second + H);\n        auto capacity = h == w ? cap[h] : cap[h] + cap[w];\n        auto counter = h == w ? cnt[h] : cnt[h] + cnt[w];\n        if(capacity > counter){\n            ans += i.first;\n            unite(h, w);\n            ++cnt[find(h)];\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n \n\n vector<bool> valid(222222,true);\n\n\nclass UnionFind{\n    public:\n    vector<int> parent;\n\n    UnionFind(int N){\n        parent = vector<int>(N,-1);\n    }\n\n    int root(int A){\n        if(parent[A] < 0) return A;\n        return parent[A]=root(parent[A]);\n    }\n\n    int size(int A){\n        return -parent[root(A)];\n    }\n\n    bool unite(int A, int B) {\n    \n        A = root(A);\n        B = root(B);\n\n        if(A == B) return false; \n\n\n        if(size(A) < size(B)) swap(A,B);\n\n\n        parent[A] += parent[B];\n        parent[B] = A;\n        if(valid[B] == 0) valid[A] = 0;\n\n        return true;\n    }\n\n    bool same(int A, int B){\n        return root(A)==root(B);\n    } \n};\n \nsigned main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n    cout << fixed << setprecision(20);\n \n    int n,h,w;\n    cin>>n>>h>>w;\n    pair<ll,pair<int,int>> v[n];\n    for(int i=0;i<n;i++){\n        ll r,c,a;\n        cin>>r>>c>>a;\n        v[i] = make_pair(a,make_pair(r-1,c-1 + h));\n    }\n    sort(v,v+n,greater<pair<ll,pair<int,int>>>());\n\n    UnionFind uni(h+w+1);\n\n    ll ans = 0;\n    \n    int cnt=0;\n\n    for(int i=0;i<n;i++){\n        pair<int,int> p = v[i].second;\n        int t=uni.root(p.first),s = uni.root(p.second);\n        if(!valid[t] && !valid[s]) continue;\n        \n        if(!uni.same(s,t)){\n            uni.unite(s,t);\n            ans += v[i].first;\n            cnt++;\n        }    \n        else if(valid[uni.root(t)] && valid[uni.root(s)]){\n            ans += v[i].first;\n            valid[uni.root(t)]=0,valid[uni.root(s)]=0;\n            cnt++;\n        }\n        if(cnt==h+w+1) break;\n\n    }\n    cout<<ans<<endl;\n    \n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// tourist's modular-arithmetic class\ntemplate <typename T>\nT inverse(T a, T m) {\n    T u = 0, v = 1;\n    while (a != 0) {\n        T t = m / a;\n        m -= t * a; swap(a, m);\n        u -= t * v; swap(u, v);\n    }\n    assert(m == 1);\n    return u;\n}\n\ntemplate <typename T>\nclass Modular {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;\n\n    constexpr Modular() : value() {}\n    template <typename U>\n    Modular(const U& x) {\n        value = normalize(x);\n    }\n\n    template <typename U>\n    static Type normalize(const U& x) {\n        Type v;\n        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n        else v = static_cast<Type>(x % mod());\n        if (v < 0) v += mod();\n        return v;\n    }\n\n    const Type& operator()() const { return value; }\n    template <typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static Type mod() { return T::value; }\n\n    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n    Modular& operator++() { return *this += 1; }\n    Modular& operator--() { return *this -= 1; }\n    Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n    Modular operator-() const { return Modular(-value); }\n\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n        asm(\n        \"divl %4; \\n\\t\"\n        : \"=a\" (d), \"=d\" (m)\n        : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n        );\n        value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n        int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n        value = normalize(value * rhs.value - q * mod());\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n        value = normalize(value * rhs.value);\n        return *this;\n    }\n\n    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n    template <typename U>\n    friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n    template <typename U>\n    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n    template <typename U>\n    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n    template <typename U>\n    friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\nprivate:\n    Type value;\n};\n\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n    assert(b >= 0);\n    Modular<T> x = a, res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) res *= x;\n        x *= x;\n        p >>= 1;\n    }\n    return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n    return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n    return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n    return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n    typename common_type<typename Modular<T>::Type, int64_t>::type x;\n    stream >> x;\n    number.value = Modular<T>::normalize(x);\n    return stream;\n}\n\nstruct fast_ios {\n    fast_ios() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(10);\n    };\n} fast_ios_;\n\n#define LSON(x) ((x) * 2)\n#define RSON(x) ((x) * 2 + 1)\ntemplate<typename A, typename B>\nvoid Min(A &a, const B &b){\n    if (b < a) a = b;\n}\ntemplate<typename A, typename B>\nvoid Max(A &a, const B &b){\n    if (b > a) a = b;\n}\n\nint cas;\nostream& kase() {\n    return cout << \"Case #\" << ++cas << \": \";\n}\n\n#if __cplusplus < 201402L\ntemplate<class Iterator>\nstd::reverse_iterator<Iterator> make_reverse_iterator(Iterator it)\n{\n    return std::reverse_iterator<Iterator>(it);\n}\n#endif\n\ntemplate <typename iter_t>\nstruct iter_pair {\n    iter_t _beg, _end;\n    iter_t begin(){return _beg;}\n    iter_t end(){return _end;}\n};\n\ntemplate<class cont> iter_pair<reverse_iterator<decltype(begin(declval<cont>()))>>\nreverse(cont &&r) {\n    return {make_reverse_iterator(end(r)), make_reverse_iterator(begin(r))};\n}\n\ntemplate<typename T> void dprintln(const T &t) { cout << t << endl; } // for debug use\ntemplate<typename T, typename ...Args> void dprintln(const T &t, const Args &...rest) { cout << t << ' '; dprintln(rest...); }\ntemplate<typename T> void println(const T &t) { cout << t << '\\n'; }\n\n\ntemplate<typename T, typename ...Args> void println(const T &t, const Args &...rest) { cout << t << ' '; println(rest...); }\ntemplate<typename T> void println(const vector<T>& vec) {\n    if (!vec.empty()) {\n        cout << vec[0];\n        for (size_t i = 1; i < vec.size(); ++i)\n            cout << ' ' << vec[i];\n    }\n    cout << '\\n';\n}\n\ntemplate<typename T> void print(const T &t) { cout << t << ' '; }\n\ntemplate<typename T, typename ...Args> void print(const T &t, const Args &...rest) { cout << t << ' '; print(rest...); }\n\n// this overload is chosen when there's only one argument\ntemplate<class T> void scan(T &t) { cin >> t; }\ntemplate<class T, class ...Args> void scan(T &a, Args &...rest) { cin >> a; scan(rest...); }\ntemplate<typename T> istream& operator>>(istream& stream, vector<T>& vec) {\n    for (auto& x : vec) stream >> x;\n    return stream;\n}\nusing ull = unsigned long long;\nusing ll = long long;\nusing ul = unsigned long;\nusing vl = vector<ll>;\nusing vi = vector<int>;\nusing pii = pair<int,int>;\nusing pip = pair<int,pii>;\nusing pll = pair<ll,ll>;\nusing vb = vector<bool>;\nusing vpii = vector<pii>;\nusing ldb = long double;\ntemplate <typename int_t>\ninline int_t lowbit(int_t x) {return x & -x;}\n#define rng(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define up(i, a, b) for (int i = int(a); i <= int(b); ++i)\n#define down(i, b, a) for (int i = int(b); i >= int(a); i--)\n#define rep(n) for(int _iter_##n = 0, _num_##n = (int)n; _iter_##n < _num_##n; ++_iter_##n)\n#define stp(i, a, b, c) for (int i = (a); i < (b); i += (c))\n#define FOR(x, cont) for (const auto &x: cont)\n#define INC(init, x, y) for (init; x <= y; ++x)\n#define For(x, cont) for (auto &x: cont)\n#define all(x) begin(x), end(x)\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define SZ(x) (int)(x).size()\n#define UP(i, l, r) for(i = decltype(i)(l); i <= decltype(i)(r); ++i)\n#define DOWN(i, r, l) for (i = decltype(i)(r); i >= decltype(i)(l); --i)\n#define Dec(a, b) for (; a >= b; --a)\ntemplate <typename T, typename Comp = less<T>>\nusing pq = priority_queue<T, vector<T>, Comp>;\n#define popcnt(x) __builtin_popcountll((x))\n#define SET(arr, v) memset(arr, (v), sizeof (arr))\n#define UNIQ(vec) (vec).erase(unique(all(vec)), end(vec))\n#define LB(cont, x) int(lower_bound(all(cont), x) - begin(cont))\n#define UB(cont, x) int(upper_bound(all(cont), x) - begin(cont))\n#define AI(name, n, m) vv<int> name(n, vi(m));\n#define AL(name, n, m) vv<ll> name(size_t(n), vl(size_t(m)));\n#define set0(arr) memset(arr, 0, sizeof arr)\n#define set1(arr) memset(arr, -1, sizeof arr)\n#define AT(T, n, m, a)  vector<vector<T>> a(n, vector<T>(m))\nconst int dx[] = {0, 0, -1, 1}, dy[] = {-1, 1, 0, 0};\nauto bet = [](const ll x, const ll y, const ll i) {\n    return x <= i && i <= y;\n};\n\ntemplate<typename T1, typename T2>\nT1 ceil(T1 x, T2 y) { // y >= 1，是整数。需要注意 x + y - 1 是否会溢出\n    return (x + y - 1) / y;\n}\n\ninline int h_bit(unsigned long long x) {\n    return (int)sizeof(unsigned long long) * 8 - 1 - __builtin_clzll(x);\n}\n\nint pow2(int x){ // power of 2\n    return int(1U << h_bit((ull)x)) + (x != lowbit(x));\n}\n\ntemplate <typename T>\nstruct BIT {\n    vector<T> a;\n    function<T(T,T)> bin_op;\n    const T init;\n    explicit BIT(int n, function<T(T,T)> bin_op, T init):bin_op(bin_op), init(init) {\n        a.assign(n + 1, init);\n    }\n\n    T prefix(int x) {\n        auto res = init;\n        while (x) {\n            res = bin_op(a[x], res);\n            x -= x & -x;\n        }\n        return res;\n    }\n    void modify(int x, T v) {\n        while (x < (int)a.size()) {\n            a[x] = bin_op(a[x], v);\n            x += x & -x;\n        }\n    }\n    void clear(){\n        fill(a.begin(), a.end(), init);\n    }\n};\n\nvi get_prime(int n) {\n    vi minp((ul) n + 1), p;\n    for (int i = 2; i <= n; i++) {\n        if (!minp[i]) {\n            minp[i] = i;\n            p.pb(i);\n        }\n        FOR(x, p) {\n            if (x <= minp[i] && x * i <= n)\n                minp[x * i] = x;\n            else break;\n        }\n    }\n    return p;\n}\n\n// alias templates\ntemplate<typename T> using vv = vector<vector<T>>;\ntemplate <typename T1, typename T2 = T1> using vp = vector<pair<T1,T2>>;\ntemplate<typename T, int n> using va = vector<array<T,n>>;\n\n//order_of_key (k) : Number of items strictly smaller than k .\n//find_by_order(k) : K-th element in a set (counting from zero).\n#ifdef __GNUC__\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\ntemplate <typename T>\nusing rank_tree = __gnu_pbds::tree<\n        T,\n        __gnu_pbds::null_type,\n        less<T>,\n        __gnu_pbds::rb_tree_tag,\n        __gnu_pbds::tree_order_statistics_node_update>;\n#endif\n\n//并查集\nstruct UnionFind {\n    vi par, sz;\n    int n_tree;\n    explicit UnionFind(int n) { //0-indexed\n        par.assign(n, 0);\n        sz.assign(n, 1);\n        rng (i, 0, n) par[i] = i;\n        n_tree = n;\n    }\n    int n_cluster() const {\n        return n_tree;\n    }\n    int size(int x) {\n        return sz[root(x)];\n    }\n    int root(int x) {\n        return x == par[x] ? x : par[x] = root(par[x]);\n    }\n    bool unite(int x, int y) {\n        int rx = root(x), ry = root(y);\n        if(rx != ry) {\n            par[rx] = ry;\n            --n_tree;\n            sz[ry] += sz[rx];\n            return true;\n        }\n        return false;\n    }\n};\n\ntemplate<typename T, typename Compare = std::less<T>>\nstruct SparseTable {\n    size_t n{}; // 0-indexed\n    vv<T> a;\n\n    template<typename ptr_t>\n    SparseTable(ptr_t beg, ptr_t end):n(end - beg) {\n        a.resize((size_t) h_bit(n) + 1); // 注意：不能写成 h_bit(n)\n        a[0].assign(beg, end);\n        rng (i, 0, SZ(a) - 1) {\n            a[i + 1].resize(n);\n            rng(j, 0, n - (1u << i)) {\n                a[i + 1][j] = min(a[i][j], a[i][j + (1u << i)], Compare());\n            }\n            rng(j, n - (1u << i), n) {\n                a[i + 1][j] = a[i][j];\n            }\n        }\n    }\n    using idx_t = long;\n    T query(idx_t l, idx_t r) { // l <=  r\n        int i = h_bit(r - l + 1ul);\n        return min(a[i][l], a[i][r + 1 - (1u << i)], Compare());\n    }\n};\n\nvi get_popcnt(int n) {\n    vi res((ul)n + 1);\n    rng (i, 0, n) {\n        if (i * 2 <= n) res[i * 2] = res[i];\n        if ((i & 1) == 0) res[i + 1] = res[i] + 1;\n    }\n    return res;\n}\n\nvi get_mu(int n) {\n    assert(n > 0);\n    vi mu(n + 1);\n    vi min_p(n + 1);\n    vi prime;\n    mu[1] = 1;\n    rng (i, 2, n + 1) {\n        if (!min_p[i]) {\n            prime.pb(i);\n            min_p[i] = i;\n            mu[i] = -1;\n        }\n        FOR (p, prime) {\n            if (p > min_p[i]) {\n                break;\n            }\n            int t = p * i;\n            if (t > n) break;\n            min_p[t] = p;\n            mu[t] = p == min_p[i] ? 0 : -mu[i];\n        }\n    }\n    return mu;\n}\n\ntemplate<typename num>\nnum fp(num x, ll n, int mod) { //fast power: hat off to quailty\n    if (n < 0) {\n        x = inverse(x, mod);\n        n = -n;\n    }\n    num ans = 1;\n    while (n) {\n        if (n & 1) ans *= x;\n        n /= 2;\n        x *= x;\n    }\n    return ans;\n}\n\n// debug code by tourist\nstring to_string(const string& s) {\n    return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n    return to_string((string) s);\n}\n\nstring to_string(bool b) {\n    return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A>\nstring to_string(A v) {\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x : v) {\n        if (!first) {\n            res += \", \";\n        }\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n// end DEBUG\n\ntemplate <typename T>\nstruct Binom {\n    vector<T> f;\n    explicit Binom(int n) {\n        f.resize(n + 1);\n        f[0] = 1;\n        up (i, 1, n) f[i] = f[i - 1] * i;\n    }\n    T get_binom(int x, int y) const {\n        assert(x <= SZ(f) - 1);\n        assert(x >= 0 && y >= 0);\n        if (x < y) return 0;\n        return f[x] / (f[y] * f[x - y]);\n    }\n    T get_fact(int n) const {\n        assert(n < SZ(f));\n        return f[n];\n    }\n};\n\n//https://codeforces.com/blog/entry/22072\nstruct HLD {\n    HLD(int n, const int *heavy_son, const int *fa, const int *depth) : top(n + 1), pos(n + 1), depth(depth), fa(fa) {\n        int index = 0;\n        // 节点编号从1开始\n        for (int i = 1; i <= n; i++) {\n            if (i != heavy_son[fa[i]]) {\n                for (int j = i; j != 0; j = heavy_son[j]) {\n                    top[j] = i;\n                    pos[j] = ++index; // pos从1开始\n                }\n            }\n        }\n    }\n\n    template<typename BinOpr>\n    //返回值是 LCA(u,v)\n    int process_path(int u, int v, BinOpr op, bool value_on_edge = false) const {\n        while (top[u] != top[v]) {\n            if (depth[top[u]] < depth[top[v]]) swap(u, v);\n            op(pos[top[u]], pos[u]);\n            u = fa[top[u]];\n        }\n        if (depth[u] > depth[v]) swap(u, v);\n        op(pos[u] + value_on_edge, pos[v]);\n        return u;\n    }\n\n    vector<int> top, pos;\n    const int *depth, *fa;\n};\n\ntemplate <typename T>\nT get_mid(T l, T r) {\n    assert(l <= r);\n    return l + (r - l) / 2;\n}\ntemplate <typename T>\nint get_bit(T a, int i) {\n    return a >> i & 1;\n}\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n */\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n//////////////////^\"^///////////////////////////////////\nclass MCMF {\n    struct arc {\n        const int to, next, cost;\n        mutable int cap;\n    };\n    const int n_node;\n    vi head;\n    vector<arc> e;\n\n    mutable vl d;\n    bool dijkstra(int s, int t) const {\n        const int inf = 10000;\n        d.assign(n_node, inf);\n        pq<pii, greater<pii>> que;\n        que.push({d[s] = 0, s});\n        while (!que.empty()) {\n            auto top = que.top();\n            que.pop();\n            int u = top.second;\n            if (d[u] != top.first) continue;\n            for (int i = head[u]; i != -1; i = e[i].next) {\n                int v = e[i].to;\n                if (e[i].cap > 0 && d[v] > d[u] + e[i].cost) {\n                    d[v] = d[u] + e[i].cost;\n                    que.push({d[v], v});\n                }\n            }\n        }\n        return d[t] < inf;\n    }\n    mutable vi cur;\n    mutable vb vis;\n    int dfs(int u, int flow, int t) const {\n        if (u == t) return flow;\n        vis[u] = true; // \"vis[u] = true;\" 不能写在 \"if (u == t) return flow;\" 之前！\n        int pushed = 0;\n        for (int &i = cur[u]; i != -1; i = e[i].next) {\n            int v = e[i].to;\n            if (!vis[v] && e[i].cap && d[v] == d[u] + e[i].cost) {\n                int tmp = dfs(v, min(flow - pushed, e[i].cap), t);\n                if (tmp) {\n                    e[i].cap -= tmp;\n                    e[i ^ 1].cap += tmp;\n                    pushed += tmp;\n                    if (flow == pushed) break;\n                }\n            }\n        }\n        vis[u] = false;\n        return pushed;\n    }\npublic:\n    explicit MCMF(int n_node) : n_node(n_node) {\n        head.assign(n_node, -1);\n    }\n    void add_arc(int u, int v, int cost, int cap) {\n        e.pb({v, head[u], cost, cap});\n        head[u] = SZ(e) - 1;\n        e.pb({u, head[v], -cost, 0});\n        head[v] = SZ(e) - 1;\n    }\n    ll mcmf(int s, int t) const {\n        ll ans = 0;\n        vis.assign(n_node, false);\n        while (dijkstra(s, t)) {\n            cur = head;\n            while (true) {\n                int f = dfs(s, INT_MAX, t);\n                if (f) ans += f * d[t];\n                else break;\n            }\n        }\n        return ans;\n    }\n};\n\nint main() {\n#ifdef LOCAL\n    ifstream in(\"main.in\");\n    cin.rdbuf(in.rdbuf());\n//    ofstream out(\"main.out\");\n//    cout.rdbuf(out.rdbuf());\n#endif\n// 先取每一行的最大者，再取每一列的最大者。错的！有反例、\n// 最小费用最大流。TLE\nint n, h, w;\nscan(n, h, w);\n\nUnionFind a(h + w + 1);\nusing Edge = array<int,3>;\nvector<Edge> e(n);\n\nFor (x, e) {\n    scan(x[0], x[1], x[2]);\n}\n\nsort(all(e), [](Edge& x, Edge& y){return x[2] > y[2];});\n\n\nll ans = 0;\nvb is_full(h + w + 1); // 表示是否已经有环\nFOR (x, e) {\n    int r1 = a.root(x[0]), r2 = a.root(x[1] + h);\n    if (r1 != r2 && (!is_full[r1] || !is_full[r2])) {\n        a.unite(r1, r2);\n        ans += x[2];\n        is_full[a.root(r1)] = is_full[r1] || is_full[r2];\n    } else if (!is_full[r1]) {\n        ans += x[2];\n        is_full[r1] = true;\n    }\n}\n\nprintln(ans);\n\n\n\n\n#ifdef LOCAL\n    cout << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nclass union_find {\npublic:\n    union_find(int n) : par(n, -1) {}\n\n    int root(int x) {\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n\n    void unite(int x, int y) {\n        x = root(x), y = root(y);\n        if(x == y) return;\n        if(par[x] < par[y]) swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n    }\n\n    int size(int x) {\n        return -par[x];\n    }\n\nprivate:\n    vector<int> par;\n};\n\nstruct edge {\n    int r, c, cost;\n    bool operator<(edge const& e) const {\n        return cost < e.cost;\n    };\n};\n\nint main() {\n    int n, h, w; cin >> n >> h >> w;\n    vector<edge> es(n);\n    for(int i = 0; i < n; ++i) {\n        cin >> es[i].r >> es[i].c >> es[i].cost;\n        es[i].r--, es[i].c--;\n    }\n    sort(rbegin(es), rend(es));\n\n    union_find uf(h + w);\n    vector<int> esz(h + w);\n    ll ans = 0;\n    for(auto const& e : es) {\n        const int u = uf.root(e.r), v = uf.root(e.c + h);\n        if(u == v) {\n            if(esz[u] < uf.size(u)) {\n                ans += e.cost;\n                esz[u] += 1;\n            }\n        } else {\n            if(esz[u] + esz[v] < uf.size(u) + uf.size(v)) {\n                ans += e.cost;\n                uf.unite(u, v);\n                const int nsz = esz[u] + esz[v] + 1;\n                esz[u] = esz[v] = nsz;\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b) for((i)=(a);i<=(b);i++)\n#define rfo(i,a,b) for((i)=(a);i>=(b);i--)\n#define inrange(x,y,z) (((x)>=(y))&&((x)<=(z)))\n#define ALL(vec) ((vec).begin(),(vec).end())\n#define SOR(vec) sort(ALL(vec))\n#define UNI(vec) (vec).erase(unique(ALL(vec)),(vec).end())\nusing namespace std;\nint n,h,w,r[100100],c[100100];\nlong long a[100100],res;\npair<long long,pair<int,int> > es[100100];\nint fa[200100],sz[200100];\nint gf(int x){return ((x==fa[x])?(x):(fa[x]=gf(fa[x])));}\nbool same(int x,int y){return gf(x)==gf(y);}\nvoid join(int x,int y){\n\tx=gf(x),y=gf(y);\n\tif(sz[x]>sz[y]){sz[x]+=sz[y];fa[y]=x;}\n\telse{sz[y]+=sz[x];fa[x]=y;}\n}\nint main(){\n\t#ifdef FILIN\n\t\t#ifndef DavidDesktop\n\t\t\tfreopen(FILIN,\"r\",stdin);\n\t\t\tfreopen(FILOUT,\"w\",stdout);\n\t\t#endif\n\t#endif\n\tios::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcin>>n>>h>>w;\n\tfor(int i=1;i<=h+w;i++) fa[i]=i,sz[i]=1;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>r[i]>>c[i]>>a[i];\n\t\tc[i]+=h; \n\t\tes[i]=make_pair(a[i],make_pair(r[i],c[i]));\n\t}\n\tsort(es+1,es+n+1);\n\treverse(es+1,es+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tif(!same(es[i].second.first,es[i].second.second)){\n\t\t\tres+=es[i].first;\n\t\t\tjoin(es[i].second.first,es[i].second.second);\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5;\nint n,h,w,f[N<<1],si[N<<1];\nbool vis[N<<1];\nstruct node\n{\n    int a,x,y;\n    bool operator<(const node&o)const\n    {\n        return a>o.a;\n    }\n}a[N];\nint getf(int x){return f[x]==x?f[x]:f[x]=getf(f[x]);}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&h,&w);\n    for(int i=1;i<=n;i++) scanf(\"%d%d%d\",&a[i].x,&a[i].y,&a[i].a),a[i].y+=h;\n    sort(a+1,a+1+n);\n    for(int i=1;i<=h+w;i++)\n        f[i]=i,si[i]=1;\n    ll ans=0;\n    for(int i=1;i<=n;i++)\n    {\n        int fx=getf(a[i].x),fy=getf(a[i].y);\n        if(fx!=fy){f[fy]=fx;si[fx]+=si[fy];}\n        if(si[fx])\n        {\n            ans+=a[i].a;\n            si[fx]--;\n        }\n    }\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <set>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <fstream>\n#include <bitset>\n#include <queue>\n#include <stack>\n#include <deque>\n\nusing std::cin;\nusing std::cout;\nusing std::cerr;\nusing std::endl;\n\nusing std::map;\nusing std::set;\nusing std::bitset;\nusing std::vector;\nusing std::string;\nusing std::multimap;\nusing std::multiset;\nusing std::deque;\nusing std::queue;\nusing std::stack;\nusing std::pair;\nusing std::iterator;\n\nusing std::sort;\nusing std::stable_sort;\nusing std::reverse;\nusing std::max_element;\nusing std::min_element;\nusing std::unique;\nusing std::ios_base;\nusing std::swap;\nusing std::min;\nusing std::max;\nusing std::fill;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<long long> vl;\ntypedef string S;\n\nnamespace MySpace{\n\n};\n\n#define F(i, n) for (int (i) = 0; (i) != (n); (i)++)\n#define fi first\n#define se second\n#define re return\n#define all(x) (x).begin(), (x).end()\n#define int long long\n\nconst long long MOD = 1e9 + 7;\n\nint n, h, w;\nint a[500000];\nint b[500000];\nint c[500000];\n\nvector<int> in_row[500000];\nvector<int> in_col[500000];\n\nlong long ans;\n\nbool comp(int a, int b)\n{\n    return c[a] > c[b];\n}\n\nint takenR[500000];\nint takenC[500000];\nint secondR[500000];\nint secondC[500000];\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> h >> w;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i] >> b[i] >> c[i];\n        in_col[a[i]].push_back(i);\n        in_row[b[i]].push_back(i);\n    }\n    for (int i = 1; i <= 100000; i++)\n    {\n        sort(all(in_col[i]), comp);\n        if (in_col[i].size() == 1)\n        {\n            ans += c[in_col[i][0]];\n            c[in_col[i][0]] = 0;\n        }\n        else\n        {\n            if (in_col[i].size())\n                secondC[i] = c[in_col[i][1]];\n        }\n    }\n    for (int i = 1; i <= 100000; i++)\n    {\n        sort(all(in_row[i]), comp);\n        if (in_row[i].size() == 1)\n        {\n            ans += c[in_row[i][0]];\n            c[in_row[i][0]] = 0;\n        }\n        else\n        {\n            if (in_row[i].size())\n                secondR[i] = c[in_row[i][1]];\n        }\n    }\n    vector<int> cards;\n    for (int i = 0; i < n; i++) cards.push_back(i);\n    sort(all(cards), comp);\n    for (int i = 0; i < n; i++)\n    {\n        int C = a[cards[i]];\n        int R = b[cards[i]];\n        if (takenC[C] && takenR[R]) continue;\n        if (!takenC[C] && takenR[R]) {takenC[C] = 1, ans += c[cards[i]]; continue;}\n        if (takenC[C] && !takenR[R]) {takenR[R] = 1, ans += c[cards[i]]; continue;}\n        int kek = secondC[C];\n        int lol = secondR[R];\n        if (kek > lol)\n        {\n            {takenC[C] = 1, ans += c[cards[i]]; continue;}\n        }\n        else\n        {\n            {takenR[R] = 1, ans += c[cards[i]]; continue;}\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#include <tuple>\n#define mkp make_pair\n#define mkt make_tuple\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1e9+7;\n\nclass DisjointSet{\npublic:\n  vector<int> rank,p;\n  vector<int> sz;\n \n  DisjointSet(){}\n  DisjointSet(int size){\n    rank.resize(size,0);\n    p.resize(size,0);\n    sz.resize(size,0);\n    for(int i=0;i<size;i++) makeSet(i);\n  }\n \n  void makeSet(int x){\n    p[x]=x;\n    rank[x]=0;\n    sz[x]=1;\n  }\n \n  bool same(int x,int y){\n    return findSet(x)==findSet(y);\n  }\n \n  void unite(int x,int y){\n    if(same(x,y)) return;\n    link(findSet(x),findSet(y));\n  }\n \n  void link(int x,int y){\n    if(rank[x]>rank[y]){\n      p[y]=x;\n      sz[x]+=sz[y];\n    }else{\n      p[x]=y;\n      sz[y]+=sz[x];\n      if(rank[x]==rank[y]){\n        rank[y]++;\n      }\n    }\n  }\n \n  int findSet(int x){\n    if(x!=p[x]){\n      p[x]=findSet(p[x]);\n    }\n    return p[x];\n  }\n \n  int findSize(int x){\n    return sz[findSet(x)];\n  }\n};\n\nint N,H,W;\nconst int L=1e5+10;\nll R[L+1],C[L+1],A[L+1];\n\nint main(){\n  cin>>N>>H>>W;\n  for(int i=0;i<N;i++) cin>>R[i]>>C[i]>>A[i];\n\n  vector<tuple<ll,int,int>> v;\n  for(int i=0;i<N;i++) v.push_back(mkt(A[i],R[i],C[i]));\n  sort(v.begin(),v.end());\n  reverse(v.begin(),v.end());\n\n  DisjointSet us(H+W+1);\n  ll ans=0;\n  for(int i=0;i<N;i++){\n    ll c,a,b;\n    c=get<0>(v[i]);\n    a=get<1>(v[i]);\n    b=get<2>(v[i]);\n\n    b+=H;\n    if(us.same(a,b)){\n      if(us.same(0,a)) continue;\n      else{\n        us.unite(0,a);\n        ans+=c;\n      }\n    }else{\n      us.unite(a,b);\n      ans+=c;\n    }\n  }\n\n  cout<<ans<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//2019.8.24 by ljz\n//email 573902690@qq.com\n//if you find any bug in my code\n//please tell me\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f\n#define unl __int128\n#define eps 5.6e-8\n#define RG register\n#define db double\n#define pc(x) __builtin_popcount(x)\ntypedef pair<int,int> Pair;\n#define mp make_pair\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define pb push_back\n#define ull unsigned LL\n#define gc getchar\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\ninline int read() {\n    res s=0,ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\n//inline int read() {\n//    res s=0,ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc();\n//    while(ch<'0'||ch>'9')ch=gc();\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline void write(RG unl x){\n//    if(x>10)write(x/10);\n//    putchar(int(x%10)+'0');\n//}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n//clock_t start=clock();\n//inline void ck(){\n//    if(1.0*(clock()-start)/CLOCKS_PER_SEC>0.1)exit(0);\n//}\nconst int N=5e5+10;\nconst int kcz=1e9+7;\nnamespace MAIN{\n    int n,H,W;\n    inline void add(res &x,const res &y){\n        x+=y,x>=kcz?x-=kcz:1;\n    }\n    inline int mul(const res &x,const res &y){\n        return int(1LL*x*y%kcz);\n    }\n    inline int Add(const res &x,const res &y){\n        return x+y>=kcz?x+y-kcz:x+y;\n    }\n    int a[N],R[N],C[N];\n    struct E{\n        int next,to;\n        E() {}\n        E(res next,res to):next(next),to(to) {}\n    }edge[N];\n    int head[N],cnt;\n    inline void addedge(const res &u,const res &v){\n        edge[++cnt]=E(head[u],v),head[u]=cnt;\n    }\n    int vis[N],link[N],tim;\n    bool match(res x){\n        for(res i=head[x];~i;i=edge[i].next){\n            res tox=edge[i].to;\n            if(vis[tox]==tim)continue;\n            vis[tox]=tim;\n            if(!link[tox]||match(link[tox])){link[tox]=x;return 1;}\n        }\n        return 0;\n    }\n    LL ans;\n    int id[N];\n    inline bool cmp(const res &x,const res &y){\n        return a[x]>a[y];\n    }\n    inline void MAIN(){\n        n=read(),H=read(),W=read();\n        memset(head,-1,sizeof(head));\n        for(res i=1;i<=n;i++)R[i]=read(),C[i]=read(),a[i]=read(),addedge(i,R[i]+n),addedge(i,C[i]+H+n),id[i]=i;\n        sort(id+1,id+n+1,cmp);\n        for(res i=1;i<=n;i++){\n            tim++;\n            if(match(id[i]))ans+=a[id[i]];\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}\nint main(){\n//    srand(19260817);\n//    freopen(\"signin.in\",\"r\",stdin);\n//    freopen(\"signin.out\",\"w\",stdout);\n    MAIN::MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n\nconst int N = 200200;\nconst long long mod = 1e9 + 7;\n\nusing namespace std;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint n;\nint m;\nint q;\nint p[N];\nvector < int > v[N], backup;\nbool used[N];\n\nbool dfs(int x)\n{\n        used[x] = true;\n        backup.push_back(x);\n        for(int y: v[x]){\n                if(p[y] == -1){\n                        p[y] = x;\n                        return true;\n                } else if(!used[p[y]] && dfs(p[y])){\n                        p[y] = x;\n                        return true;\n                }\n        }\n        return false;\n}\n\nint main()\n{\n        ios_base::sync_with_stdio(0);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        cin >> q >> n >> m;\n        for(int i = 1; i <= n + m; i++){\n                p[i] = -1;\n        }\n        vector < pair < int, int > > qu;\n        for(int i = 1; i <= q; i++){\n                int x, y, w;\n                cin >> x >> y >> w;\n                v[i].push_back(x);\n                v[i].push_back(y + n);\n                qu.push_back({w, i});\n\n                shuffle(v[i].begin(), v[i].end(), rng);\n        }\n        sort(qu.begin(), qu.end());\n        reverse(qu.begin(), qu.end());\n        long long res = 0;\n        for(auto g: qu){\n                if(dfs(g.se)){\n                        res += g.fi;\n\n                }\n        }\n        cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\n#define ln                '\\n'\n#define all(dat)           dat.begin(), dat.end()\n#define loop(i, to)        for (int i = 0; i < to; ++i)\n#define cont(i, to)        for (int i = 1; i <= to; ++i)\n#define circ(i, fr, to)    for (int i = fr; i <= to; ++i)\n#define foreach(i, dat)    for (__typeof(dat.begin()) i = dat.begin(); i != dat.end(); ++i)\n\ntypedef long long          num;\n\nusing namespace std;\n\nconst int nsz = 1e5;\nint n, r, c;\nnum ans;\npair<int, pair<int, int>> e[nsz + 5];\n\nstruct union_find {\n    int pr[2 * nsz + 5], siz[2 * nsz + 5], usd[2 * nsz + 5];\n    \n    void inline init() {\n        cont (i, 2 * nsz) {\n            pr[i] = i;\n            siz[i] = 1;\n        }\n    }\n    \n    int qry(int u) {\n        return pr[u] == u ? u : pr[u] = qry(pr[u]);\n    }\n    \n    bool inline unite(int u, int v) {\n        int pu = qry(u), pv = qry(v);\n        if (pu == pv) {\n            if (usd[pu] >= siz[pu])  return 0;\n            ++usd[pu];\n            return 1;\n        }\n        if (usd[pu] + usd[pv] >= siz[pu] + siz[pv])  return 0;\n        pr[pv] = pu;\n        siz[pu] += siz[pv];\n        siz[pv] = 0;\n        usd[pu] += usd[pv];\n        usd[pv] = 0;\n        ++usd[pu];\n        return 1;\n    }\n};\nunion_find uf;\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin >> n >> r >> c;\n    cont (i, n) {\n        int x, y, val;\n        cin >> x >> y >> val;\n        e[i] = make_pair(val, make_pair(x, y));\n    }\n    sort(e + 1, e + n + 1, greater<pair<int, pair<int, int>>>());\n    uf.init();\n    cont (i, n) {\n        int x = e[i].second.first, y = e[i].second.second, val = e[i].first;\n        if (uf.unite(x, y + nsz)) {\n            ans += val;\n        }\n    }\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// clang-format off\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!==============================================================================!//\n//!  dP     dP          oo                       88888888b oo                dP  !//\n//!  88     88                                   88                          88  !//\n//!  88     88 88d888b. dP .d8888b. 88d888b.    a88aaaa    dP 88d888b. .d888b88  !//\n//!  88     88 88'  '88 88 88'  '88 88'  '88     88        88 88'  '88 88'  '88  !//\n//!  Y8.   .8P 88    88 88 88.  .88 88    88     88        88 88    88 88.  .88  !//\n//!  'Y88888P' dP    dP dP '88888P' dP    dP     dP        dP dP    dP '88888P8  !//\n//!==============================================================================!//\nclass UnionFind\n{\npublic:\n    UnionFind(const std::size_t v) : V(v), parent(v), size(v, 1) { std::iota(parent.begin(), parent.end(), 0); }\n    std::size_t find(const std::size_t a) { return assert(a < V), parent[a] == a ? a : parent[a] = find(parent[a]); }\n    bool same(const std::size_t a, const std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        return find(a) == find(b);\n    }\n    void unite(std::size_t a, std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (size[a] < size[b]) { std::swap(a, b); }\n        size[a] += size[b], parent[b] = a;\n    }\n    std::size_t getSize(const std::size_t a) { return assert(a < V), size[find(a)]; }\n    friend std::ostream& operator<<(std::ostream& os, const UnionFind& uf)\n    {\n        os << \"[\";\n        for (std::size_t i = 0; i < uf.parent.size(); i++) { os << uf.parent[i] << (i + 1 == uf.parent.size() ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    const std::size_t V;\n    std::vector<std::size_t> parent, size;\n};\n// clang-format on\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    const int        N = read<int>(), H = read<int>(), W = read<int>();\n    std::vector<int> R(N), C(N), A(N);\n    for (int i = 0; i < N; i++) { std::cin >> R[i] >> C[i] >> A[i], R[i]--, C[i]--; }\n    std::vector<int> index(N);\n    std::iota(index.begin(), index.end(), 0);\n    std::sort(index.begin(), index.end(), [&](const int i, const int j) { return A[i] > A[j]; });\n    UnionFind        uf(H + W);\n    int              ans = 0;\n    std::vector<int> edge(H + W, 0);\n    for (const int i : index) {\n        const int u = R[i], v = H + C[i];\n        if (uf.same(u, v)) {\n            const int ne = edge[uf.find(u)] + 1, nv = uf.getSize(u);\n            if (ne > nv) { continue; }\n            ans += A[i], uf.unite(u, v), edge[uf.find(u)] = ne;\n        } else {\n            const int ne = edge[uf.find(u)] + edge[uf.find(v)] + 1, nv = uf.getSize(u) + uf.getSize(v);\n            if (ne > nv) { continue; }\n            ans += A[i], uf.unite(u, v), edge[uf.find(v)] = ne;\n        }\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define modulo 1000000007\n#define mod(mod_x) ((((long long)mod_x+modulo))%modulo)\n#define Inf 100000000\nstruct unionfind{\n\tvector<int> data;\n\tvector<int> size;\n\tunionfind(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdata.push_back(i);\n\t\t\tsize.push_back(1);\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif(data[x]==x)return x;\n\t\treturn data[x]=find(data[x]);\n\t}\n\t\n\tbool unite(int x,int y){\n\t\tx=find(x);y=find(y);\n\t\tif(x==y)return false;\n\t\tdata[x]=y;\n\t\tsize[y]+=size[x];\n\t\treturn true;\n\t}\n\t\n\tbool check(int x,int y){\n\t\treturn (find(x)==find(y));\n\t}\n\t\n\tint get_size(int x){\n\t\tint X = find(x);\n\t\treturn size[X];\n\t}\n};\n\n\nint main(){\n\t\n\tint N,H,W;\n\tcin>>N>>H>>W;\n\t\n\tvector<pair<long long,pair<int,int>>> V(N);\n\t\n\tmap<int,int> mp1,mp2;\n\t\n\tfor(int i=0;i<N;i++){\n\t\tcin>>V[i].second.first>>V[i].second.second>>V[i].first;\n\t\tmp1[V[i].second.first]=-1;\n\t\tmp2[V[i].second.second]=-1;\n\t\t\n\t}\n\tint now = 0;\n\tfor(auto &a:mp1){\n\t\ta.second=now;\n\t\tnow++;\n\t}\n\tnow=0;\n\tfor(auto &a:mp2){\n\t\ta.second = now;\n\t\tnow++;\n\t}\n\t\n\tfor(int i=0;i<N;i++){\n\t\tV[i].second.first = mp1[V[i].second.first];\n\t\tV[i].second.second = mp2[V[i].second.second];\n\t}\n\t\n\tunionfind uf(2*N);\n\t\n\tsort(V.begin(),V.end());\n\t\n\tlong long ans = 0;\n\tset<int> NG;\n\tfor(int i=N-1;i>=0;i--){\n\t\tint a = V[i].second.first;\n\t\tint b = V[i].second.second+N;\n\t\tif(NG.count(uf.find(a))&&NG.count(uf.find(b)))continue;\n\t\tans += V[i].first;\n\t\tif(!uf.unite(a,b)||(NG.count(uf.find(a))||NG.count(uf.find(b)))){\n\t\t\tNG.insert(uf.find(a));\n\t\t}\n\t\t\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<cstdlib>\n#include<queue>\n#include<ctime>\n#include<vector>\n#include<set>\n#include<map>\n#include<stack>\nusing namespace std;\n#define int long long\nstruct node {\n\tint x,y,w;\n};\nnode d[200100];\nint n,m,H,W,fa[200100],is[200100];\nlong long Ans;\ninline int sf(int x){return fa[x]==x?x:fa[x]=sf(fa[x]);}\ninline bool cmp(const node a,const node b){return a.w>b.w;}\nsigned main(){\n    int i,j,k;\n    scanf(\"%lld%lld%lld\",&m,&H,&W);\n    n=H+W;\n    for(i=1;i<=n;i++)fa[i]=i;\n    for(i=1;i<=m;i++){\n      scanf(\"%lld%lld%lld\",&d[i].x,&d[i].y,&d[i].w);\n      d[i].y+=H;\n    }\n    sort(d+1,d+m+1,cmp);\n    for(i=1;i<=m;i++){\n      int x=d[i].x,y=d[i].y;\n      if(sf(x)!=sf(y)){\n      \tif(is[sf(x)]&&is[sf(y)])continue;\n      \tis[sf(y)]|=is[sf(x)];\n      \tfa[sf(x)]=sf(y);\n      \tAns+=d[i].w;\n      }else {\n      \tif(!is[sf(x)]){\n      \t  is[sf(x)]=1;\n      \t  Ans+=d[i].w;\n      \t}\n      }\n    }\n    printf(\"%lld\\n\",Ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}\nnamespace IO{\n    char nc(){ static char bf[100000],*p1=bf,*p2=bf; return p1==p2&&(p2=(p1=bf)+ fread(bf,1,100000,stdin),p1==p2)?EOF:*p1++; }\n    int rd(){ int res=0; char c=getchar(); while(!isdigit(c))c=getchar(); while(isdigit(c))res=res*10+c-'0',c=getchar(); return res; }\n}/*}}}*/\n/******************heading******************/\nconst int N=1e5+50;\n\nint n,h,w;\n\nstruct edge{\n    int u,v,w;\n    bool operator<(edge e){\n        return w<e.w;\n    }\n}e[N];\n\nint f[N],g[N];\nvoid init(int k){FOR(i,0,k)f[i]=i,g[i]=0;}\nint get(int u){return f[u]==u?u:f[u]=get(f[u]);}\nvoid merge(int u,int v){f[get(u)]=get(v);}\nbool find(int u,int v){return get(u)==get(v);}\nbool has_circle(int u){return g[get(u)];}\nvoid set_circle(int u){g[get(u)]=1;}\n\nlld ans;\n\nint main(){\n    scanf(\"%d%d%d\",&n,&h,&w);\n    init(h+w);\n    FOR(i,1,n){\n        int x,y,z;\n        scanf(\"%d%d%d\",&x,&y,&z);\n        e[i]=(edge){x,y+h,z};\n    }\n    sort(e+1,e+n+1);\n    ROF(i,n,1){\n        int u=e[i].u,v=e[i].v,w=e[i].w;\n        if(find(u,v)){\n            if(!has_circle(u)) ans+=w, set_circle(u);\n        }else{\n            if(has_circle(u)&&has_circle(v));\n            else if(has_circle(u)) ans+=w, merge(v,u);\n            else ans+=w, merge(u,v);\n        }\n    }\n    printf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Data\n{\n    int r, c, val;\n    bool dd;\n    bool operator < (const Data data) const\n    {\n        return val < data.val;\n    }\n};\n\nint n, h, w;\nData a[100005];\nbool Row[100005], Col[100005];\n\nlong long MaxRow()\n{\n    memset(Row, false, sizeof(Row));\n    memset(Col, false, sizeof(Col));\n    long long res = 0;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if(!Row[a[i].r] && !a[i].dd)\n        {\n            Row[a[i].r] = true;\n            a[i].dd = true;\n            res += a[i].val;\n        }\n    }\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if(!Col[a[i].c] && !a[i].dd)\n        {\n            Col[a[i].c] = true;\n            a[i].dd = true;\n            res += a[i].val;\n        }\n    }\n    return res;\n}\nlong long MaxCol()\n{\n    memset(Row, false, sizeof(Row));\n    memset(Col, false, sizeof(Col));\n    long long res = 0;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        a[i].dd=false;\n    }\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if(!Col[a[i].c] && !a[i].dd)\n        {\n            Col[a[i].c] = true;\n            a[i].dd = true;\n            res += a[i].val;\n        }\n    }\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if(!Row[a[i].r] && !a[i].dd)\n        {\n            Row[a[i].r] = true;\n            a[i].dd = true;\n            res += a[i].val;\n        }\n    }\n    return res;\n}\nint main()\n{\n    ios_base:: sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> h >> w;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i].r >> a[i].c >> a[i].val;\n        a[i].dd = false;\n    }\n    sort(a, a + n);\n\n    cout << max(MaxRow(), MaxCol());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Konrad Paluszek,University of Warsaw(former XIV LO Staszic)\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#define TIME (chrono::steady_clock::now().time_since_epoch().count())\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#define xfm(a,b)a##b\n#define xwb(a,b)xfm(a,b)\n#define _ xwb(nvj,__LINE__)\n#define __ xwb(kjy,__LINE__)\n#define ___ xwb(cjm,__LINE__)\n#define REP(i,n)for(urs(n)i=0;i<(n);++i)\n#define UNTIL(t)while(clock()<(t)*CLOCKS_PER_SEC)\n#define PER(r...)for(bool _=1;_||next_permutation(r);_=false)\n#define ALL(r)(r).begin(),(r).end()\n#define RALL(r)(r).rbegin(),(r).rend()\n#define FS(r)r.first,r.second\n#define SF(r)r.second,r.first\n#define sim template<class c\n#define ros return o\n#define rans return ans\n#define forbits(i,m)if(m)for(urs(m)i=ctz(m),i##nvj=m;i##nvj;i##nvj^=((urs(m))1<<i),i=ctz(i##nvj))\n#define fordbits(i,m)if(m)for(urs(m)i=8*sizeof(m)-clz(m)-1,i##nxd=m;i##nxd;i##nxd^=((urs(m))1<<i),i=8*sizeof(m)-clz(i##nxd)-1)\n#define ksets(t, m, k, n) for (t m = (((t)1 << (k)) - 1); m < ((t)1 << (n)); m = nux(m))\n#define urs(r...)typename decay<decltype(r)>::type\n#define hur(f,g,r)sim>int f(c a){if(sizeof(c)==16)return r;if(sizeof(c)==8)return g##ll(a);return g(a);}\n#define pwq(t,i) int clz(t x){return clz<int>(x)-i;}\nusing namespace __gnu_pbds;using namespace std;using ll=long long;using ld=long double;using ull=unsigned long long;using vi=vector<int>;using pii=pair<int,int>;using pll=pair<ll,ll>;using vpii=vector<pii>;using spii=set<pii>;using mii=map<int,int>;using unt=unsigned int;sim>using min_queue=priority_queue<c,vector<c>,greater<c>>;sim,class b,class cmp=less<c> >using ordered_map=tree<c,b,cmp,rb_tree_tag,tree_order_statistics_node_update>;sim, class cmp=less<c>>using ordered_set = ordered_map<c,null_type,cmp>;hur(popc,__builtin_popcount,popc<ull>(a)+popc<ull>(a>>64))hur(ctz,__builtin_ctz,(ull)a?ctz<ull>(a):64+ctz<ull>(a>>64))hur(clz,__builtin_clz,a>>64?clz<ull>(a>>64):64+clz<ull>(a))pwq(short,16)pwq(uint16_t,16)pwq(char,24)pwq(int8_t,24)pwq(uint8_t,24)sim,class N>bool mini(c&o,const N&h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(c&o,const N&h){if(o<h)ros=h,1;return 0;}sim,class n>using gyv=c;\n#if defined(LOCAL) // || defined(LOCAL2)\n#include </home/kjp/headers/debuglib.hpp>\n#else\n#define loc(...)\n#define onl(r...)r\n#define debug(...)\n#define print_stack(...)\n#define mark_stack(...)\n#define set_pre(...)\n#define reg_it(...)\n#endif\n#define next nexT\n#define prev preV\n#define tree trEE\n#define left lefT\n#define right righT\n#define div diV\n#define y1 y_1\null mix(ull o){o+=0x9e3779b97f4a7c15;o=(o^(o>>30))*0xbf58476d1ce4e5b9;o=(o^(o>>27))*0x94d049bb133111eb;ros^(o>>31);}ull SALT=0x7a14a4b0881ebf9,tqu=0x7a14a4b0881ebf9;ull my_rand(){return tqu=mix(tqu);}void my_srand(ull x){SALT=tqu=x;}const int inf = 1023400000;const ll llinf=1234567890000000000ll;\n#define rand my_rand\n#define srand my_srand\n#define random_shuffle(r...)random_shuffle(r,[](int _){return my_rand()%_;})\nsim>inline c nux(c m){if(!m)return numeric_limits<c>::max();c A=m&-m;c B=~((A-1)^m);c C=B&-B;c D=(C>>(1+ctz(A)))-1;return C|(m&~(C-1))|D;}__attribute__((no_sanitize_undefined))ll mul(ll a,ll b,ll m){ll q=a*(ld)b/m;ll o=a*b-q*m;o%=m;if(o<0)o+=m;ros;}sim>void unq(c&x){x.resize(unique(ALL(x))-x.begin());}\n#if ((ULONG_MAX) != (UINT_MAX))\nnamespace std {template <> struct is_signed<__int128> : public true_type {};}\n#endif\n#define q31 (8 * sizeof(c) - 1)\nsim, class d> typename common_type<c,d>::type floor_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using floor_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b - (a % b < 0);}\nsim, class d> typename common_type<c,d>::type ceil_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using ceil_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b + (a % b > 0);}\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-security\"\ntemplate <class...c> void done(const c&...x) {printf(x...); exit(0);}\n#pragma GCC diagnostic pop\nsim> struct REV {c &x;using it=typename c::reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> struct CREV {const c&x;using it=typename c::const_reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> REV<c> reversed(c&x) {return REV<c>{x};}sim> CREV<c> reversed(const c&x) {return CREV<c>{x};}\n\n#if defined(LOCAL) || defined(LOCAL2)\nvoid __tmi() {cerr << setprecision(6) << fixed << \"total time: \" << clock() / (ld)CLOCKS_PER_SEC << \"s\" << endl;}int _ = (atexit(__tmi), 0);\n#endif\nconst int nax = 1e5 + 44;\nint u[nax * 2];\nbool full[nax * 2];\nint find(int x) {\n\tif (u[x] == x) return x;\n\treturn u[x] = find(u[x]);\n}\nbool onion(int a, int b) {\n\ta = find(a);\n\tb = find(b);\n\tif (a == b) {\n\t\tif (full[a]) return false;\n\t\tfull[a] = true;\n\t\treturn true;\n\t}\n\tif (full[a] && full[b]) return false;\n\tfull[a] = full[b] = (full[a] || full[b]);\n\tu[a] = b;\n\treturn true;\n}\nint main() {\n\tint n;\n\tscanf(\"%d%*d%*d\", &n);\n\tiota(u, u + 2 * nax, 0);\n\tvector <pair <int, pii> > E;\n\tREP(_, n) {\n\t\tint r, c, a;\n\t\tscanf(\"%d%d%d\", &r, &c, &a);\n\t\tE.emplace_back(a, make_pair(r + nax, c));\n\t}\n\tsort(RALL(E));\n\tll ans = 0;\n\tfor (auto x : E) {\n\t\tint cost = x.first;\n\t\tauto ver = x.second;\n\t\tif (onion(FS(ver))) ans += cost;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int maxn=3e5+10;\nint pa[maxn],sz[maxn],val[maxn];\nstruct edge{\n    int u,v,w;\n    bool operator <(const edge &x)const {\n        return w>x.w;\n    }\n    void read(){\n        scanf(\"%d%d%d\",&u,&v,&w);\n    }\n}e[maxn];\nint fi(int x){\n    return pa[x]==x?x:pa[x]=fi(pa[x]);\n}\nbool Merge(int x,int y){\n    x=fi(x);\n    y=fi(y);\n    if(x==y){\n        if(val[x]<sz[x]){\n            val[x]++;\n            return true;\n        }\n        return false;\n    }\n    else{\n        if(val[x]+val[y]+1>sz[x]+sz[y])return false;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        val[x]+=(val[y]+1);\n        pa[y]=x;\n    }\n    return true;\n}\n\n/*\nNote:\n    At first, Turning grid into bipartite graph\n    Notice that we must assign each number from both sides to each row and column\n    Claim 1: There are no triple multiple loops\n    Claim 2: If the number of node is not greater than the number of edges we can assign such thing\n*/\nint n,r,c;\n\nint main(){\n    scanf(\"%d%d%d\",&n,&r,&c);\n    for(int i=1;i<=n;i++){\n        e[i].read();\n        e[i].v+=r;\n        pa[e[i].u]=e[i].u;\n        pa[e[i].v]=e[i].v;\n        sz[e[i].u]=1;\n        sz[e[i].v]=1;\n    }\n    sort(e+1,e+1+n);\n    //for(int i=1;i<=n;i++)\n       // e[i].print();\n    long long ans=0;\n    for(int i=1;i<=n;i++){\n        if(Merge(e[i].u,e[i].v)){\n            ans+=e[i].w;\n        }\n    }\n    printf(\"%lld\\n\",ans);\n}\n/*\n    Good Luck\n        -Lucina\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=2e5+1000;\nstruct node{\n\tint c,r;\n\tLL x;\n}a[N];\nbool cmp(node a,node b){\n\treturn a.x>b.x;\n}\nint fa[N],g[N];\nint find(int x){\n\treturn fa[x]==x?x:(fa[x]=find(fa[x]));\n}\nbool merge(int x,int y){\n\tx=find(x);y=find(y);\n\tcout<<x<<\" \"<<g[x]<<\"   \"<<y<<\" \"<<g[y]<<endl;\n\tif(x==y){\n\t\tif(g[x])return 0;\n\t\telse return g[x]=1;\n\t}\n\tif(g[x]&&g[y])return 0;\n\tfa[y]=x;\n\tg[x]|=g[y];\n\treturn 1;\n}\n\nint main()\n{\n\tLL ans=0;\n\tint n,h,w;\n\tscanf(\"%d%d%d\",&n,&h,&w);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%lld\",&a[i].r,&a[i].c,&a[i].x);\n\t}\n\tsort(a+1,a+1+n,cmp);\n\tfor(int i=1;i<=h+w;i++)fa[i]=i,g[i]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(merge(a[i].r,a[i].c+h))ans+=a[i].x;\n\t\t\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <cmath>\n#include <typeinfo>\n#include <numeric>\n#include <cassert>\n#include <stdio.h>\n#include <unistd.h>\n#include <string.h>\n#include <stdlib.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n\n#define rep(i,n) for(ll i=0LL;i<n;++i)\n#define srep(i,s,n) for(ll i=s;i<n;++i)\n#define rrep(i,n) for(ll i=n-1LL;i>=0LL;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define CIN(x) do { \\\n    assert(!cin.eof()); \\\n    cin >> x; \\\n    assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T>>;\n\ntemplate <typename S, typename T>\nT get_m(M<S, T> &m, S k, S default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        memset(tree, 0, sizeof(ll) * (n+1));\n        this->init(init);\n    }\n\n    void init(ll init) {\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll>> q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_linklist(const V<t2> &srclist, V<ll> dstlist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        dstlist[a].pb(b);\n        dstlist[b].pb(a);\n    }\n}\n\nvoid make_parental_relation(const V<ll> linklist[], ll root, ll n,\n                            ll parent[], V<ll> children[], ll level[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parent[root] = root;\n    level[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : linklist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parent[next] = now;\n            children[now].pb(next);\n            level[next] = level[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n        << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename S, typename T>\nvoid _debug_print(const M<S, T> &xlist)\n{\n    for (auto x : xlist) {\n        S k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nint _main();\nint main()\n{\n    cout << setprecision(12);\n    return _main();\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nV<t3> a_rc_list;\nll raw_users[100005];\nll column_users[100005];\nbool raw_failed[100005];\nbool column_failed[100005];\n\nbool try_rip_raw(ll r, ll srcidx, M<ll, ll> &raw_idx, M<ll, ll> &column_idx);\nbool try_rip_column(ll c, ll srcidx, M<ll, ll> &raw_idx,  M<ll, ll> &column_idx);\n\nbool try_rip_raw(ll r, ll srcidx, M<ll, ll> &raw_idx, M<ll, ll> &column_idx)\n{\n    if (raw_failed[r]) return false;\n\n    if (raw_idx.find(r) != raw_idx.end()) {\n        raw_failed[r] = true;\n        return false;\n    }\n\n    raw_idx[r] = srcidx;\n\n    if (raw_users[r] != 0LL) {\n        ll dstidx = raw_users[r];\n        auto a_rc = a_rc_list[dstidx];\n        ll c = get<2>(a_rc);\n        auto ret = try_rip_column(c, dstidx, raw_idx, column_idx);\n        if (!ret) column_failed[c] = true;\n        return ret;\n    }\n\n    return true;\n}\n\nbool try_rip_column(ll c, ll srcidx, M<ll, ll> &raw_idx,  M<ll, ll> &column_idx)\n{\n    if (column_failed[c]) return false;\n\n    if (column_idx.find(c) != column_idx.end()) {\n        column_failed[c] = true;\n        return false;\n    }\n\n    column_idx[c] = srcidx;\n\n    if (column_users[c] != 0LL) {\n        ll dstidx = column_users[c];\n        auto a_rc = a_rc_list[dstidx];\n        ll r = get<1>(a_rc);\n        auto ret = try_rip_raw(r, dstidx, raw_idx, column_idx);\n        if (!ret) raw_failed[r] = true;\n        return ret;\n    }\n\n    return true;\n}\n\nvoid copy_maps(const M<ll, ll> &raw_idx, const M<ll, ll> &column_idx)\n{\n    for (auto ri : raw_idx) {\n        ll r = ri.first;\n        ll idx = ri.second;\n        raw_users[r] = idx;\n    }\n\n    for (auto ci : column_idx) {\n        ll c = ci.first;\n        ll idx = ci.second;\n        column_users[c] = idx;\n    }\n}\n\nvoid get_card(t3 a_rc, ll idx)\n{\n    ll a = get<0>(a_rc);\n    ll r = get<1>(a_rc);\n    ll c = get<2>(a_rc);\n\n    if (raw_users[r] == 0LL) {\n        raw_users[r] = idx;\n        return;\n    }\n\n    if (column_users[c] == 0LL) {\n        column_users[c] = idx;\n        return;\n    }\n\n    M<ll, ll> raw_idx;\n    M<ll, ll> column_idx;\n    if (try_rip_raw(r, idx, raw_idx, column_idx)) {\n        copy_maps(raw_idx, column_idx);\n        return;\n    }\n\n    raw_idx.clear();\n    column_idx.clear();\n    if (try_rip_column(c, idx, raw_idx, column_idx)) {\n        copy_maps(raw_idx, column_idx);\n        return;\n    }\n}\n\nint _main()\n{\n    ll n; llin(n);\n    ll h; llin(h);\n    ll w; llin(w);\n    V<t3> rcalist; llinl3(rcalist, n);\n\n    for (auto rca : rcalist) {\n        ll r = get<0>(rca);\n        ll c = get<1>(rca);\n        ll a = get<2>(rca);\n        a_rc_list.pb(t3(a, r, c));\n    }\n    a_rc_list.pb(t3((ll)pow(10LL, 18LL), -1LL, -1LL));\n    sort_reverse(a_rc_list);\n\n    memset(raw_users, 0, sizeof(raw_users));\n    memset(column_users, 0, sizeof(column_users));\n    memset(raw_failed, 0, sizeof(raw_failed));\n    memset(column_failed, 0, sizeof(column_failed));\n\n    srep (i, 1LL, n+1LL) get_card(a_rc_list[i], i);\n\n    ll ans = 0LL;\n\n    rep (i, 100005) {\n        ll idx = raw_users[i];\n        if (idx == 0LL) continue;\n        auto a = get<0>(a_rc_list[idx]);\n        debug_printf(\"raw a = %lld\\n\", a);\n        ans += a;\n    }\n\n    rep (i, 100005) {\n        ll idx = column_users[i];\n        if (idx == 0LL) continue;\n        auto a = get<0>(a_rc_list[idx]);\n        debug_printf(\"column a = %lld\\n\", a);\n        ans += a;\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "/**************************************************************\n\tFile name: E.cpp\n\tAuthor: huhao\n\tEmail: 826538400@qq.com\n\tCreate time: 2019/8/24 下午9:22:27\n**************************************************************/\n#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#define fr(i,a,b) for(int i=(a),end_##i=(b);i<=end_##i;i++)\n#define fd(i,a,b) for(int i=(a),end_##i=(b);i>=end_##i;i--)\nint read()\n{\n\tint r=0,t=1,c=getchar();\n\twhile(c<'0'||c>'9')\n\t{\n\t\tt=c=='-'?-1:1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9')\n\t{\n\t\tr=(r<<3)+(r<<1)+(c^48);\n\t\tc=getchar();\n\t}\n\treturn r*t;\n}\nconst int N=200010;\nint n,f[N],w[N],a[N],b[N],v[N],m1,m2,m,r[N];\nlong long ans;\nint cmp(int a,int b)\n{\n\treturn v[a]>v[b];\n}\nint getf(int a)\n{\n\treturn a==f[a]?a:f[a]=getf(f[a]);\n}\nint main()\n{\n\tn=read();\n\tm1=read();\n\tm2=read();\n\tm=m1+m2;\n\tfr(i,1,n)\n\t{\n\t\ta[i]=read();\n\t\tb[i]=read()+m1;\n\t\tv[i]=read();\n\t}\n\tfr(i,1,m)\n\t{\n\t\tf[i]=i;\n\t\tw[i]=1;\n\t}\n\tfr(i,1,n)\n\t\tr[i]=i;\n\tsort(r+1,r+n+1,cmp);\n\tfr(i,1,n)\n\t{\n\t\tint A=getf(a[r[i]]),B=getf(b[r[i]]);\n\t\tif(w[A]||w[B])\n\t\t{\n\t\t\tif(A!=B)\n\t\t\t{\n\t\t\t\tw[A]+=w[B];\n\t\t\t\tf[B]=A;\n\t\t\t}\n\t\t\tw[A]--;\n\t\t\tans+=v[r[i]];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define name \"main\"\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define fto(i,a,b) for(int i=a; i<=b;++i)\n#define maxn 100009\n#define ll long long\n\nusing namespace std;\nbool gone[maxn][3],ck[maxn][3];\nint cl[maxn];\nint xd[maxn][3],a[maxn][3],w,h,n;\npii b[maxn];\nbool check(int i, int x,int j){\n    if(ck[i][x])return false;\n    ck[i][x]=true;\n    if(xd[i][x]==0){\n        xd[i][x]=j;\n        ck[i][x]=false;\n        return true;\n    }\n    /// xd[i][x]!=0;\n    /// i,x la cot hoac hang, j la chi so can dien\n    /// t la so can dien\n    int t=xd[i][x];\n    if(check(a[t][1-x],1-x,t)){\n        xd[i][x]=j;\n        ck[i][x]=false;\n        return true;\n    }\n    return false;\n}\nint main()\n{\n    #ifndef ONLINE_JUDGE\n    freopen(name\".inp\", \"r\", stdin);\n    freopen(name\".out\", \"w\", stdout);\n    #endif // ONLINE_JUDGE\n    cin >> n >> h >> w;\n    fto(i,1,n){\n        cin >> a[i][0]>> a[i][1] >> b[i].fi;\n        b[i].se=i;\n    }\n    sort(b+1,b+n+1,greater<pii> ());\n    ll res=0;\n    fto(i,1,n){\n        int j=b[i].se;\n        if(check(a[j][0],0,j)){\n            //xd[a[j][0]][0]=j;\n            res+=b[i].fi;\n        }\n        else if(check(a[j][1],1,j)){\n            //xd[a[j][1]][1]=j;\n            res+=b[i].fi;\n        }\n    }\n    cout << res ;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct node{\n    int num,v;\n    node(int num,int v):num(num),v(v){};\n    bool operator<(const node a)const{\n        return v>a.v;\n    }\n};\nmap<int,multiset<node>>xx;\nmap<int,multiset<node>>yy;\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int n,h,w;\n    cin>>n>>h>>w;\n    for(int i=1;i<=n;++i){\n        int x,y,w;\n        cin>>x>>y>>w;\n        xx[x].insert(node(y,w));\n        yy[y].insert(node(x,w));\n    }\n    int ans=0;\n    for(int i=1;i<=h;++i){\n        if(xx[i].empty())continue;\n        ans+=(*xx[i].begin()).v;\n        for(auto j:xx[i]){\n            int to=j.num;\n            yy[to].erase(node(i,(*xx[i].begin()).v));\n        }\n    }\n    for(int i=1;i<=w;++i){\n        if(yy[i].empty())continue;\n        ans+=(*yy[i].begin()).v;\n        for(auto j:yy[i]){\n            int to=j.num;\n            xx[to].erase(node(i,(*yy[i].begin()).v));\n        }\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MAXN = 3e5+10;\n\nint bit[MAXN];\nint par[MAXN];\nint parent(int i) {\n  return par[i] < 0 ? i: (par[i]=parent(par[i]));\n}\n\nbool merge(int a, int b) {\n  int x = parent(a);\n  int y = parent(b);\n  if (x==y) {\n    if (bit[x]) return false;\n    else return bit[x] = 1;\n  }\n  if (bit[x] && bit[y]) return false;\n  bit[x]+=bit[y];\n  par[y] = x;\n  return 1;\n}\n\nint gc=0;\nmap<pair<int,int>, int> m;\nint gid(int r, int c) {\n  auto p = make_pair(r,c);\n  if (m.count(p)) {\n    return m[p];\n  }\n  else {\n    return  m[p] = gc++;\n  }\n}\n\nint n, h, w;\n\nint main(){\n  cin.tie(0); ios_base::sync_with_stdio(0);\n  cin >> n >> h >> w;\n  memset(par, -1,sizeof par);\n  vector<vector<int>> v;\n  for(int i=0;i<n;i++) {\n    int r, c, w;\n    cin >> r >> c >> w;\n    v.push_back({w,r,c});\n  }\n  sort(v.rbegin(), v.rend());\n  ll ans = 0;\n  for(auto p: v) {\n    if (merge(gid(p[1],0), gid(p[2],1))){\n      ans+=p[0];\n      //cerr << \"ADDING \" << p[1] << \" \" << p[2] << \" \" << p[0] <<endl;\n    }\n    //else //cerr << \"NOT ADDING \" << p[1] << \" \" << p[2] << \" \" << p[0] <<endl;\n  }\n  cout << ans <<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MAXN = 3e5+10;\n\nint bit[MAXN];\nint par[MAXN];\nint parent(int i) {\n  return par[i] < 0 ? i: (par[i]=parent(par[i]));\n}\n\nbool merge(int a, int b) {\n  int x = parent(a);\n  int y = parent(b);\n  if (x==y) {\n    if (bit[x]) return false;\n    else return bit[x] = 1;\n  }\n  if (bit[x] && bit[y]) return false;\n  bit[x]+=bit[y];\n  bit[y] = x;\n  return 1;\n}\n\nint gc=0;\nmap<pair<int,int>, int> m;\nint gid(int r, int c) {\n  auto p = make_pair(r,c);\n  if (m.count(p)) {\n    return m[p];\n  }\n  else {\n    return  m[p] = gc++;\n  }\n}\n\nint n, h, w;\n\nint main(){\n  cin.tie(0); ios_base::sync_with_stdio(0);\n  cin >> n >> h >> w;\n  memset(par, -1,sizeof par);\n  vector<vector<int>> v;\n  for(int i=0;i<n;i++) {\n    int r, c, w;\n    cin >> r >> c >> w;\n    v.push_back({w,r,c});\n  }\n  sort(v.rbegin(), v.rend());\n  ll ans = 0;\n  for(auto p: v) {\n    if (merge(gid(p[1],0), gid(p[2],1))){\n      ans+=p[0];\n      //cerr << \"ADDING \" << p[1] << \" \" << p[2] << \" \" << p[0] <<endl;\n    }\n    else \n      //cerr << \"NOT ADDING \" << p[1] << \" \" << p[2] << \" \" << p[0] <<endl;\n  }\n  cout << ans <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (register ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (register ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter cout << endl\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 2e6 + 10 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 1e9 + 7 ;\nconst double eps = 1e-7 ;\ntemplate <class T> void read(T &a)\n{\n\tint f = 1 ; a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\ta *= f;\n}\n\nll n, h, w, ans;\n\nstruct card\n{\n\tll a, r, c;\n}\na[maxn];\n\nll fa[maxn];\n\nbool circle[maxn];\n\nvoid init(ll t)\n{\n\trep(i, 1, t) fa[i] = i;\n\treturn ;\n}\n\nll getfa(ll a)\n{\n\treturn a == fa[a] ? a : fa[a] = getfa(fa[a]);\n}\n\nsigned main()\n{\n\tscanf(\"%lld %lld %lld\", &n, &h, &w);\n\tinit(h + w);\n\trep(i, 1, n) scanf(\"%lld %lld %lld\", &a[i].r, &a[i].c, &a[i].a);\n\tsort(a + 1, a + n + 1, [](card a, card b)\n\t\t{\n\t\t\treturn a.a > b.a;\n\t\t}\n\t);\n\trep(i, 1, n)\n\t{\n\t\tll u = a[i].r, v = a[i].c + h;\n\t\t// cout << u << ' ' << v << endl;\n\t\t// printf(\"I : %lld %lld %lld\\n\", a[i].r, a[i].c, a[i].a);\n\t\tu = getfa(u), v = getfa(v);\n\t\t// printf(\"%lld %lld\\n\", u, v);\n\t\tif(u != v) ans += a[i].a, fa[u] = v;\n\t\telse\n\t\t{\n\t\t\tif(!circle[u]) circle[u] = 1, ans += a[i].a;\n\t\t\t// else puts(\"No\");\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\ntypedef long long ll;\n#define inf 0x3f3f3f3f\nint n,h,w;\nint x[maxn],y[maxn];\nll a[maxn];\nset<pair<ll,int> > qx[maxn],qy[maxn];\nvector<pair<ll,int> >cards;\nll ax,ay;\nbool ux[maxn],uy[maxn],usd[maxn];\nint cx[maxn],cy[maxn];\nqueue<int> que;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&h,&w);\n//\tmemset(cx,-1,sizeof(cx));\n//\tmemset(cy,-1,sizeof(cy));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%lld\",&x[i],&y[i],&a[i]);\n\t\tx[i]--;\n\t\ty[i]--;\n\t\tcx[x[i]]++;\n\t\tcy[y[i]]++;\n\t}\n    ll ans=0;\n\tfor(int i=0;i<n;i++)\n\t{\n/*\t\tif(cx[x[i]]==1||cy[y[i]]==1)\n\t\t\tque.push(i);\n\t\telse\n\t\t{\n*/\t\t\tqx[x[i]].insert(make_pair(a[i],i));\n\t\t\tqy[y[i]].insert(make_pair(a[i],i));\n//\t\t}\n\t}\n/*\twhile(!que.empty())\n\t{\n\t\tint cur=que.front();\n\t\tque.pop();\n\t\tusd[cur]=1;\n\t\tans+=a[cur];\n\t\tusd[cur]=1;\n\t\tcx[x[cur]]--;\n\t\tcy[y[cur]]--;\n\t\tif(cx[x[cur]]==1)\n\t\t{\n\t\t\tif(!qx[x[cur]].empty())\n\t\t\t{\n\t\t\t\tpair<ll,int> he=*(qx[x[cur]].begin());\n\t\t\t\tqx[x[cur]].clear();\n\t\t\t\tint id=he.second;\n\t\t\t\tque.push(id);\n\t\t\t\tqy[y[id]].erase(he);\n\t\t\t}\n\t\t}\n\t\tif(cy[y[cur]]==1)\n\t\t{\n\t\t\tif(!qy[y[cur]].empty())\n\t\t\t{\n\t\t\t\tpair<ll,int> he=*(qy[y[cur]].begin());\n\t\t\t\tqy[y[cur]].clear();\n\t\t\t\tint id=he.second;\n\t\t\t\tque.push(id);\n\t\t\t\tqx[x[id]].erase(he);\n\t\t\t}\n\t\t}\n\t}\t*/\n//\tcout<<ans<<endl;\n\tfor(int i=0;i<n;i++)if(!usd[i])\n\t\tcards.push_back(make_pair(a[i],i));\n\t\t\n    sort(cards.begin(),cards.end());\n    reverse(cards.begin(),cards.end());\n    for(int _=0;_<cards.size();_++)\n    {\n    \tint i=cards[_].second;\n\t//\tcout<<i<<\" \"<<x[i]<<\" \"<<y[i]<<\" \"<<qx[x[i]].top().second<<\" \"<<qy[y[i]].top().second<<endl;\n        qx[x[i]].erase(make_pair(a[i],i));\n        qy[y[i]].erase(make_pair(a[i],i));\n        if(ux[x[i]]&&uy[y[i]])continue;\n        if(ux[x[i]])\n        \tuy[y[i]]=1;\n        else if(uy[y[i]])\n        \tux[x[i]]=1;\n        else\n\t\t{\n\t\t\tax=qx[x[i]].empty()?-inf:(*(qx[x[i]].rbegin())).first;\n\t\t\tay=qy[y[i]].empty()?-inf:(*(qy[y[i]].rbegin())).first;\n\t\t\tif(ax<ay)\n\t\t\t{\n        //   \tcout<<\"puthang \"<<x[i]<<endl;\n            \tux[x[i]]=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n      \t//    \tcout<<\"putlie \"<<y[i]<<endl;\n \t    \t\tuy[y[i]]=1;\n \t    \t}\n        }\n        ans+=a[i];\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \n#define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n#define endl \"\\n\"\n#define int long long\n\n\nstruct edge\n{\n\tint to, flow, cap, cost, rev;\n};\n\nstruct MinCostMaxFlow\n{\n\tint nodes;\n\tvector<int> prio, curflow, prevedge, prevnode, q, pot;\n\tvector<bool> inqueue;\n\tvector<vector<edge> > graph;\n\tMinCostMaxFlow() {}\n\n\tMinCostMaxFlow(int n): nodes(n), prio(n, 0), curflow(n, 0),\n\tprevedge(n, 0), prevnode(n, 0), q(n, 0), pot(n, 0), inqueue(n, 0), graph(n) {}\n\n\tvoid addEdge(int source, int to, int capacity, int cost)\n\t{\n\t\tedge a = {to, 0, capacity, cost, (int)graph[to].size()};\n\t\tedge b = {source, 0, 0, -cost, (int)graph[source].size()};\n\t\tgraph[source].push_back(a);\n\t\tgraph[to].push_back(b);\n\t}\n\n\tvoid bellman_ford(int source, vector<int> &dist)\n\t{\n\t\tfill(dist.begin(), dist.end(), INT_MAX);\n\t\tdist[source] = 0;\n\t\tint qt=0;\n\t\tq[qt++] = source;\n\t\tfor(int qh=0;(qh-qt)%nodes!=0;qh++)\n\t\t{\n\t\t\tint u = q[qh%nodes];\n\t\t\tinqueue[u] = false;\n\t\t\tfor(auto &e : graph[u])\n\t\t\t{\n\t\t\t\tif(e.flow >= e.cap)\n\t\t\t\t\tcontinue;\n\t\t\t\tint v = e.to;\n\t\t\t\tint newDist = dist[u] + e.cost;\n\t\t\t\tif(dist[v] > newDist)\n\t\t\t\t{\n\t\t\t\t\tdist[v] = newDist;\n\t\t\t\t\tif(!inqueue[v])\n\t\t\t\t\t{\n\t\t\t\t\t\tinqueue[v] = true;\n\t\t\t\t\t\tq[qt++ % nodes] = v;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpair<int, int> minCostFlow(int source, int dest, int maxflow)\n\t{\n\t\tbellman_ford(source, pot);\n\t\tint flow = 0;\n\t\tint flow_cost = 0;\n\t\twhile(flow < maxflow)\n\t\t{\n\t\t\tpriority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > q;\n\t\t\tq.push({0, source});\n\t\t\tfill(prio.begin(), prio.end(), INT_MAX);\n\t\t\tprio[source] = 0;\n\t\t\tcurflow[source] = INT_MAX;\n\t\t\twhile(!q.empty())\n\t\t\t{\n\t\t\t\tint d = q.top().first;\n\t\t\t\tint u = q.top().second;\n\t\t\t\tq.pop();\n\t\t\t\tif(d != prio[u])\n\t\t\t\t\tcontinue;\n\t\t\t\tfor(int i=0;i<graph[u].size();i++)\n\t\t\t\t{\n\t\t\t\t\tedge &e=graph[u][i];\n\t\t\t\t\tint v = e.to;\n\t\t\t\t\tif(e.flow >= e.cap)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint newPrio = prio[u] + e.cost + pot[u] - pot[v];\n\t\t\t\t\tif(prio[v] > newPrio)\n\t\t\t\t\t{\n\t\t\t\t\t\tprio[v] = newPrio;\n\t\t\t\t\t\tq.push({newPrio, v});\n\t\t\t\t\t\tprevnode[v] = u;\n\t\t\t\t\t\tprevedge[v] = i;\n\t\t\t\t\t\tcurflow[v] = min(curflow[u], e.cap - e.flow);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(prio[dest] == INT_MAX)\n\t\t\t\tbreak;\n\t\t\tfor(int i=0;i<nodes;i++)\n\t\t\t\tpot[i]+=prio[i];\n\t\t\tint df = min(curflow[dest], maxflow - flow);\n\t\t\tflow += df;\n\t\t\tfor(int v=dest;v!=source;v=prevnode[v])\n\t\t\t{\n\t\t\t\tedge &e = graph[prevnode[v]][prevedge[v]];\n\t\t\t\te.flow += df;\n\t\t\t\tgraph[v][e.rev].flow -= df;\n\t\t\t\tflow_cost += df * e.cost;\n\t\t\t}\n\t\t}\n\t\treturn {flow, flow_cost};\n\t}\n};\n\nconst int N = 1e5 + 5;\n\nint n, h, w;\nint r[N], c[N], a[N];\n\nint32_t main()\n{\n\tIOS;\n\tcin >> n >> h >> w;\n\tMinCostMaxFlow flow(3e5 + 5);\n\tint source = 0;\n\tint layer = h + w;\n\tint sink = h + w + n + 1;\n\tfor(int i = 1; i <= h + w; i++)\n\t\tflow.addEdge(source, i, 1, 0);\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tcin >> r[i] >> c[i] >> a[i];\n\t\tflow.addEdge(r[i], layer + i, 1, 0);\n\t\tflow.addEdge(h + c[i], layer + i, 1, 0);\n\t\tflow.addEdge(layer + i, sink, 1, -a[i]);\n\t}\n\tpair<int, int> ans = flow.minCostFlow(source, sink, 1e5);\n\tcout << -ans.second;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint ds[100100], isFull[100100];\n\nint get(int x)\n{\n  return ds[x] == x ? x : ds[x] = get(ds[x]);\n}\n\nint main()\n{\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n\n  int n, h, w, r, c, a;\n  vector<pair<int, int>> edges[100100];\n  cin >> n >> h >> w;\n  while (n--)\n  {\n    cin >> r >> c >> a;\n    edges[a].push_back({r, c + h});\n  }\n\n  for (int i = 1; i <= w + h; i++)\n    ds[i] = i;\n\n  long long ans = 0;\n  for (int a = 100000; a; a--)\n    for (auto u : edges[a])\n    {\n      int x = get(u.first), y = get(u.second);\n      if (x != y)\n      {\n        if (isFull[x] && isFull[y])\n          continue;\n        ds[x] = y;\n        isFull[y] |= isFull[x];\n        ans += a;\n      }\n      else if (!isFull[x])\n      {\n        ans += a;\n        isFull[x] = 1;\n      }\n    }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fst(t) std::get<0>(t)\n#define snd(t) std::get<1>(t)\n#define thd(t) std::get<2>(t)\n#define unless(p) if(!(p))\n#define until(p) while(!(p))\n\nusing ll = std::int64_t;\nusing P = std::tuple<int,int>;\nusing T = std::tuple<int,int,int>;\n\nint N, H, W;\nstd::vector<T> v;\nbool used1[100100], used2[100100];\nstd::multiset<int> s1[100100], s2[100100];\n\nint main(){\n  std::cin.tie(nullptr);\n  std::ios::sync_with_stdio(false);\n\n  std::cin >> N >> H >> W;\n\n  for(int i=0;i<N;++i){\n      int R, C, A;\n      std::cin >> R >> C >> A;\n\n      v.emplace_back(A, R, C);\n      s1[R].insert(-A);\n      s2[C].insert(-A);\n  }\n\n  std::sort(v.rbegin(), v.rend());\n\n  ll res = 0;\n\n  for(int i=0;i<N;++i){\n      int A, R, C;\n      std::tie(A, R, C) = v[i];\n\n      s1[R].erase(s1[R].find(-A));\n      s2[C].erase(s2[C].find(-A));\n\n      if(!used1[R] && !used2[C]){\n          int a = s1[R].empty() ? 0 : *(s1[R].begin()), b = s2[C].empty() == 0 ? 0 : *(s2[C].begin());\n          a = -a;\n          b = -b;\n\n          if(a > b){\n              used2[C] = true;\n              res += A;\n          }else{\n              used1[R] = true;\n              res += A;\n          }\n      }else if(!used1[R]){\n          used1[R] = true;\n          res += A;\n      }else if(!used2[C]){\n          used2[C] = true;\n          res += A;\n      }else{\n          \n      }\n  }\n\n  std::cout << res << std::endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing i64 = long long;\n\nclass UF {\n    int *par;\n    int *rank;\n\n    public:\n    UF(int size) : par(new int[size]), rank(new int[size]()) {\n        for (int i = 0; i < size; i++) par[i] = i;\n    }\n    ~UF() { delete[] par; delete[] rank; }\n\n    int root(int x) {\n        if (par[x] == x) return x;\n        return par[x] = root(par[x]);\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    void unite(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return;\n\n        if (rank[x] < rank[y]) par[x] = y;\n        else {\n            par[y] = x;\n            if (rank[x] == rank[y]) rank[x]++;\n        }\n    }\n};\n\nint main() {\n    int n, h, w;\n    std::cin >> n >> h >> w;\n    std::vector<std::tuple<i64, int, int>> edges;\n    for (int i = 0; i < n; i++) {\n        int a, b; i64 c;\n        std::cin >> a >> b >> c;\n        edges.emplace_back(c, a - 1, h + b - 1);\n    }\n\n    std::sort(edges.begin(), edges.end(), std::greater<>());\n\n    UF uft(h + w);\n    std::vector<int> nv(h + w, 1), ne(h + w);\n    i64 ret = 0;\n\n    for (auto &e : edges) {\n        i64 c = std::get<0>(e);\n        int a = std::get<1>(e), b = std::get<2>(e);\n        int pa = uft.root(a), pb = uft.root(b);\n        if (pa == pb) {\n            if (nv[pa] > ne[pa]) {\n                ret += c;\n                ne[pa]++;\n            }\n        } else {\n            if (nv[pa] + nv[pb] > ne[pa] + ne[pb]) {\n                ret += c;\n                uft.unite(pa, pb);\n                nv[uft.root(pa)] = nv[pa] + nv[pb];\n                ne[uft.root(pa)] = ne[pa] + ne[pb] + 1;\n            }\n        }\n    }\n\n    std::cout << ret << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define fi first\n#define se second\n#define L(i,u) for (int i=head[u]; i!=0; i=nxt[i])\n#define rep(i,a,b) for (register int i=a; i<=b; i++)\n#define per(i,a,b) for (register int i=a; i>=b; i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 300005, M = 300005, inf = 0x3f3f3f3f;\nint n,head[N],cur[N],nxt[M],to[M],edgenum,match[N];\nbool xuan[N],vis[N];\nstruct node{\n\tint r,c,w;\n}s[N];\nbool cmp(node a, node b){return a.w>b.w;}\nvoid addedge(int u, int v){\n\tto[++edgenum]=v;nxt[edgenum]=head[u];head[u]=edgenum;\n}\nvoid add(int u, int v){\n\taddedge(u,v);addedge(v,u);\n}\nint sta[N],top;\nbool dfs(int u){\n\tif(vis[u])return 0;vis[u]=1;sta[++top]=u;\n\tL(i,u)if(!match[to[i]]||dfs(match[to[i]])){\n\t\tmatch[u]=to[i];match[to[i]]=u;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nvoid print(int T){\n\tprintf(\"---%d---\\n\",T);\n\trep(i,1,n)printf(\"%d \",match[i]-n);puts(\"\");\n}\nint main() {\n\tread(n);read(h);read(w);\n\trep(i,1,n){\n\t\tread(s[i].r);read(s[i].c);read(s[i].w);\n\t}\n\tsort(s+1,s+n+1,cmp);ll res=0;\n\trep(i,1,n){\n\t\tadd(i,1e5+s[i].r);\n\t\tadd(i,2e5+s[i].c);\n\t}\n\t\n\trep(i,1,n){\n\t\tif(dfs(i))res+=s[i].w;\n\t\twhile(top)vis[sta[top--]]=0;\n\t//\tprint(i);\n\t}\n\tcout<<res;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Utkarsh.25dec\n#include <bits/stdc++.h>\n#include <chrono>\n#include <random>\n#define ll long long int\n#define ull unsigned long long int\n#define pb push_back\n#define mp make_pair\n#define mod 1000000007\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define loop(i,a,b) for(ll i=a;i<=b;i++)\n#define vi vector <int>\n#define vs vector <string>\n#define vc vector <char>\n#define vl vector <ll>\n#define all(c) (c).begin(),(c).end()\n#define max3(a,b,c) max(max(a,b),c)\n#define min3(a,b,c) min(min(a,b),c)\n#define deb(x) cerr<<#x<<' '<<'='<<' '<<x<<'\\n'\nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \n#define ordered_set tree<int, null_type,less<int>, rb_tree_tag,tree_order_statistics_node_update>\n// ordered_set s ; s.order_of_key(val)  no. of elements strictly less than val\n// s.find_by_order(i)  itertor to ith element (0 indexed)\ntypedef vector<vector<ll>> matrix;\nll power(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\nll modInverse(ll a){return power(a,mod-2);}\nconst int N=500023;\nbool vis[N];\nvector <int> adj[N];\nll par[N];\nll sz[N];\nll find(ll curr)\n{\n    while(curr!=par[curr])\n        curr=par[curr];\n    return curr;\n}\nvoid merge(ll x,ll y)\n{\n    if(sz[x]>=sz[y])\n    {\n        par[y]=x;\n        sz[x]+=sz[y];\n    }\n    else\n    {\n        par[x]=y;\n        sz[y]+=sz[x];\n    }\n}\nvoid solve()\n{\n    ll n,h,w;\n    cin>>n>>h>>w;\n    vector <tuple<ll,ll,ll>> v;\n    for(int i=0;i<n;i++)\n    {\n        ll a,b,c;\n        cin>>a>>b>>c;\n        v.pb(make_tuple(c,a,b));\n    }\n    for(int i=1;i<N;i++)\n    {\n        sz[i]=1;\n        par[i]=i;\n    }\n    sort(all(v));\n    reverse(all(v));\n    ll ans=0;\n    for(auto t:v)\n    {\n        ll add=get<0>(t);\n        ll r=get<1>(t);\n        ll c=get<2>(t);\n        r+=1e5;\n        r=find(r);\n        c=find(c);\n        if(vis[r] && vis[c])\n            continue;\n        if(r==c)\n        {\n            if(vis[r]==0)\n            {\n                vis[r]=1;\n                ans+=add;\n                continue;\n            }\n            else\n                continue;\n        }\n        else\n        {\n            merge(r,c);\n            int final=max(vis[r],vis[c]);\n            r=find(r);\n            vis[r]=final;\n            ans+=add;\n        }\n    }\n    cout<<ans<<'\\n';\n}\nint main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    int T=1;\n    //cin>>T;\n    int t=0;\n    while(t++<T)\n    {\n        //cout<<\"Case #\"<<t<<\":\"<<' ';\n        solve();\n        //cout<<'\\n';\n    }\n    cerr << \"Time : \" << 1000 * ((double)clock()) / (double)CLOCKS_PER_SEC << \"ms\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REPP(i,n) for(int i=1;i<=n;i++)\nconst double PI = acos(-1);\nconst double EPS = 1e-15;\nlong long INF=(long long)1E17;\n#define i_7 (long long)(1E9+7)\nlong mod(long a){\n    long long c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\n\nusing namespace std;\nbool prime_(int n){\n  if(n==1){\n    return false;\n  }else if(n==2){\n    return true;\n  }else{\n    for(int i=2;i<=sqrt(n);i++){\n      if(n%i==0){\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nlong long gcd_(long long a, long long b){\n  if(a<b){\n    swap(a,b);\n  }\n  if(a%b==0){\n    return b;\n  }else{\n    return gcd_(b,a%b);\n  }\n}\n \nlong long lcm_(long long x, long long y){\n  return (x/gcd_(x,y))*y;\n}\n \nclass UnionFind {\n    public:\n    //各頂点の親の番号を格納する。その頂点自身が親だった場合は-(その集合のサイズ)を入れる。\n    vector<int> Parent;\n    \n    //クラスを作るときは、Parentの値を全て-1にする。\n    //以下のようにすると全てバラバラの頂点として解釈できる。\n    UnionFind(int N) {\n        Parent = vector<int>(N, -1);\n    }\n    \n    //Aがどのグループに属しているか調べる\n    int root(int A) {\n        if (Parent[A] < 0) return A;\n        return Parent[A] = root(Parent[A]);\n    }\n    \n    //自分のいるグループの頂点数を調べる\n    int size(int A) {\n        return -Parent[root(A)];//先祖をrootで取っておきたい。\n    }\n    \n    //AとBをくっ付ける\n    bool connect(int A, int B) {\n        //AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける\n        A = root(A);\n        B = root(B);\n        if (A == B) {\n            //すでにくっついてるからくっ付けない\n            return false;\n        }\n        \n        //大きい方(A)に小さいほう(B)をくっ付けたい\n        //大小が逆だったらAとBをひっくり返す。\n        if (size(A) < size(B)) swap(A, B);\n        \n        //Aのサイズを更新する\n        Parent[A] += Parent[B];\n        //Bの親をAに変更する\n        Parent[B] = A;\n        \n        return true;\n    }\n};\n\nint main(){\n  \n  int n,h,w;\n  cin>>n>>h>>w;\n  int r[n],c[n];\n  long long a[n];\n  map<pair<int,int>, int> mp;//同じ列にあるカードの数\n  REP(i,n){\n    cin>>r[i]>>c[i]>>a[i];\n    r[i]--;c[i]--;\n    mp[make_pair(r[i],c[i])]++;\n  }\n  vector<pair<long long, int>> rows[h];//行ごとに入っているカードを分類\n  vector<pair<long long, int>> columns[w];//列ごとに入っているカードを分類\n  vector<bool> used(n,false);\n  REP(i,n){\n    rows[r[i]].push_back(make_pair(a[i],i));\n    columns[c[i]].push_back(make_pair(a[i],i));\n  }\n  REP(i,h){\n    sort(rows[i].begin(), rows[i].end(), greater<pair<long long, int>>());\n  }\n  REP(i,w){\n    sort(columns[i].begin(), columns[i].end(), greater<pair<long long, int>>());\n  }\n  \n  int cnt[n];//iと同じ列にあるカードの数\n  REP(i,n){\n    cnt[i] = columns[c[i]].size();\n  }\n  \n  long long ans = 0;\n  int tempi;\n  int s;\n  REP(i,h){\n    if(rows[i].empty())continue;\n    tempi = -1;\n    s = rows[i].size();\n    REP(j,s){\n      if(mp[make_pair(r[rows[i][j].second],c[rows[i][j].second])]>1){\n        tempi = rows[i][j].second;\n        mp[make_pair(r[rows[i][j].second],c[rows[i][j].second])]--;\n        used[rows[i][j].second] = true;\n        ans += rows[i][j].first;\n        break;\n      }else{\n        continue;\n      }\n    }\n    if(tempi==-1){\n      used[rows[i][0].second] = true;\n      mp[make_pair(r[rows[i][0].second],c[rows[i][0].second])]--;\n      ans += rows[i][0].first;\n    }\n  }\n  \n  REP(i,w){\n    if(columns[i].empty())continue;\n    s = columns[i].size();\n    REP(j,s){\n      if(used[columns[i][j].second])continue;\n      used[columns[i][j].second] = true;\n      ans += columns[i][j].first;\n      break;\n    }\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr  int MOD = 1000000007;\n//constexpr  int MOD = 998244353;\n//constexpr  long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n// int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nstruct Primal_Dual\n{\n\tconst long long int INF = 1 << 30;\n\ttypedef pair< long long int, long long int > Pi;\n\n\tstruct edge\n\t{\n\t\tlong long int to, cap, cost, rev;\n\t\tedge(const long long int a, const long long int b, const long long int c, const long long int d) {\n\t\t\tto = a, cap = b, cost = c, rev = d;\n\t\t}\n\t};\n\tvector< vector< edge > > graph;\n\tvector< long long int > potential, min_cost, prevv, preve;\n\n\tPrimal_Dual(long long int V) : graph(V) {}\n\n\tvoid add_edge(long long int from, long long int to, long long int cap, long long int cost)\n\t{\n\t\tgraph[from].push_back(edge(to, cap, cost, (long long int)graph[to].size()));\n\t\tgraph[to].push_back(edge(from, 0, -cost, (long long int)graph[from].size() - 1));\n\t}\n\n\tlong long int min_cost_flow(long long int s, long long int t, long long int f)\n\t{\n\t\tlong long int V = graph.size(), ret = 0;\n\t\tpriority_queue< Pi, vector< Pi >, greater< Pi > > que;\n\t\tpotential.assign(V, 0);\n\t\tpreve.assign(V, -1);\n\t\tprevv.assign(V, -1);\n\n\t\twhile (f > 0) {\n\t\t\tmin_cost.assign(V, INF);\n\t\t\tque.push(Pi(0, s));\n\t\t\tmin_cost[s] = 0;\n\n\t\t\twhile (!que.empty()) {\n\t\t\t\tPi p = que.top();\n\t\t\t\tque.pop();\n\t\t\t\tif (min_cost[p.second] < p.first) continue;\n\t\t\t\tfor (long long int i = 0; i < graph[p.second].size(); i++) {\n\t\t\t\t\tedge &e = graph[p.second][i];\n\t\t\t\t\tlong long int nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n\t\t\t\t\tif (e.cap > 0 && min_cost[e.to] > nextCost) {\n\t\t\t\t\t\tmin_cost[e.to] = nextCost;\n\t\t\t\t\t\tprevv[e.to] = p.second, preve[e.to] = i;\n\t\t\t\t\t\tque.push(Pi(min_cost[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (min_cost[t] == INF) return -1;\n\t\t\tfor (long long int v = 0; v < V; v++) potential[v] += min_cost[v];\n\t\t\tlong long int addflow = f;\n\t\t\tfor (long long int v = t; v != s; v = prevv[v]) {\n\t\t\t\taddflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= addflow;\n\t\t\tret += addflow * potential[t];\n\t\t\tfor (long long int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = graph[prevv[v]][preve[v]];\n\t\t\t\te.cap -= addflow;\n\t\t\t\tgraph[v][e.rev].cap += addflow;\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n};\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> H >> W;\n\tPrimal_Dual f(320000);\n\tfor (int i = 0; i < H; i++) {\n\t\tf.add_edge(310000, i, 1, 0);\n\t}\n\tfor (int i = 0; i < W; i++) {\n\t\tf.add_edge(310000, i + 100000, 1, 0);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tint y, x, c;\n\t\tcin >> y >> x >> c;\n\t\ty--;\n\t\tx--;\n\n\t\tf.add_edge(y, 200000 + i, 1, 200000 - c);\n\t\tf.add_edge(x + 100000, 200000 + i, 1, 200000 - c);\n\t\tf.add_edge(200000 + i, 310001, 1, 0);\n\t}\n\tlong long int bef = 0;\n\tlong long int ans = 0;\n\tfor (int i = 1; i <= 100000; i++) {\n\t\tlong long int box = f.min_cost_flow(310000, 310001, 1);\n\t\tif (box == -1) {\n\t\t\tcout << ans << endl;\n\t\t\treturn 0;\n\t\t}\n\t\tans += 200000 - box;\n\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// clang-format off\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!==============================================================================!//\n//!  dP     dP          oo                       88888888b oo                dP  !//\n//!  88     88                                   88                          88  !//\n//!  88     88 88d888b. dP .d8888b. 88d888b.    a88aaaa    dP 88d888b. .d888b88  !//\n//!  88     88 88'  '88 88 88'  '88 88'  '88     88        88 88'  '88 88'  '88  !//\n//!  Y8.   .8P 88    88 88 88.  .88 88    88     88        88 88    88 88.  .88  !//\n//!  'Y88888P' dP    dP dP '88888P' dP    dP     dP        dP dP    dP '88888P8  !//\n//!==============================================================================!//\nclass UnionFind\n{\npublic:\n    UnionFind(const std::size_t v) : V(v), parent(v), size(v, 1) { std::iota(parent.begin(), parent.end(), 0); }\n    std::size_t find(const std::size_t a) { return assert(a < V), parent[a] == a ? a : parent[a] = find(parent[a]); }\n    bool same(const std::size_t a, const std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        return find(a) == find(b);\n    }\n    void unite(std::size_t a, std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (size[a] < size[b]) { std::swap(a, b); }\n        size[a] += size[b], parent[b] = a;\n    }\n    std::size_t getSize(const std::size_t a) { return assert(a < V), size[find(a)]; }\n    friend std::ostream& operator<<(std::ostream& os, const UnionFind& uf)\n    {\n        os << \"[\";\n        for (std::size_t i = 0; i < uf.parent.size(); i++) { os << uf.parent[i] << (i + 1 == uf.parent.size() ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    const std::size_t V;\n    std::vector<std::size_t> parent, size;\n};\n// clang-format on\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    const int        N = read<int>(), H = read<int>(), W = read<int>();\n    std::vector<int> R(N), C(N), A(N);\n    for (int i = 0; i < N; i++) { std::cin >> R[i] >> C[i] >> A[i], R[i]--, C[i]--; }\n    std::vector<int> index(N);\n    std::iota(index.begin(), index.end(), 0);\n    std::sort(index.begin(), index.end(), [&](const int i, const int j) { return A[i] > A[j]; });\n    UnionFind        uf(H + W);\n    int              ans = 0;\n    std::vector<int> cycle(H + W, 0);\n    for (const int i : index) {\n        const int u = R[i], v = H + C[i];\n        if (uf.same(u, v)) {\n            if (cycle[uf.find(u)] > 0) { continue; }\n            ans += A[i], uf.unite(u, v), cycle[uf.find(u)] = 1;\n        } else {\n            const int c = cycle[uf.find(u)] + cycle[uf.find(v)];\n            if (c > 1) { continue; }\n            ans += A[i], uf.unite(u, v), cycle[uf.find(v)] = c;\n        }\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Konrad Paluszek,University of Warsaw(former XIV LO Staszic)\n#ifndef LOCAL\n#pragma GCC optimize(\"O3\")\n#endif\n#define TIME (chrono::steady_clock::now().time_since_epoch().count())\n#include<bits/stdc++.h>\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#define xfm(a,b)a##b\n#define xwb(a,b)xfm(a,b)\n#define _ xwb(nvj,__LINE__)\n#define __ xwb(kjy,__LINE__)\n#define ___ xwb(cjm,__LINE__)\n#define REP(i,n)for(urs(n)i=0;i<(n);++i)\n#define UNTIL(t)while(clock()<(t)*CLOCKS_PER_SEC)\n#define PER(r...)for(bool _=1;_||next_permutation(r);_=false)\n#define ALL(r)(r).begin(),(r).end()\n#define RALL(r)(r).rbegin(),(r).rend()\n#define FS(r)r.first,r.second\n#define SF(r)r.second,r.first\n#define sim template<class c\n#define ros return o\n#define rans return ans\n#define forbits(i,m)if(m)for(urs(m)i=ctz(m),i##nvj=m;i##nvj;i##nvj^=((urs(m))1<<i),i=ctz(i##nvj))\n#define fordbits(i,m)if(m)for(urs(m)i=8*sizeof(m)-clz(m)-1,i##nxd=m;i##nxd;i##nxd^=((urs(m))1<<i),i=8*sizeof(m)-clz(i##nxd)-1)\n#define ksets(t, m, k, n) for (t m = (((t)1 << (k)) - 1); m < ((t)1 << (n)); m = nux(m))\n#define urs(r...)typename decay<decltype(r)>::type\n#define hur(f,g,r)sim>int f(c a){if(sizeof(c)==16)return r;if(sizeof(c)==8)return g##ll(a);return g(a);}\n#define pwq(t,i) int clz(t x){return clz<int>(x)-i;}\nusing namespace __gnu_pbds;using namespace std;using ll=long long;using ld=long double;using ull=unsigned long long;using vi=vector<int>;using pii=pair<int,int>;using pll=pair<ll,ll>;using vpii=vector<pii>;using spii=set<pii>;using mii=map<int,int>;using unt=unsigned int;sim>using min_queue=priority_queue<c,vector<c>,greater<c>>;sim,class b,class cmp=less<c> >using ordered_map=tree<c,b,cmp,rb_tree_tag,tree_order_statistics_node_update>;sim, class cmp=less<c>>using ordered_set = ordered_map<c,null_type,cmp>;hur(popc,__builtin_popcount,popc<ull>(a)+popc<ull>(a>>64))hur(ctz,__builtin_ctz,(ull)a?ctz<ull>(a):64+ctz<ull>(a>>64))hur(clz,__builtin_clz,a>>64?clz<ull>(a>>64):64+clz<ull>(a))pwq(short,16)pwq(uint16_t,16)pwq(char,24)pwq(int8_t,24)pwq(uint8_t,24)sim,class N>bool mini(c&o,const N&h){if(o>h)ros=h,1;return 0;}sim,class N>bool maxi(c&o,const N&h){if(o<h)ros=h,1;return 0;}sim,class n>using gyv=c;\n#if defined(LOCAL) // || defined(LOCAL2)\n#include </home/kjp/headers/debuglib.hpp>\n#else\n#define loc(...)\n#define onl(r...)r\n#define debug(...)\n#define print_stack(...)\n#define mark_stack(...)\n#define set_pre(...)\n#define reg_it(...)\n#endif\n#define next nexT\n#define prev preV\n#define tree trEE\n#define left lefT\n#define right righT\n#define div diV\n#define y1 y_1\null mix(ull o){o+=0x9e3779b97f4a7c15;o=(o^(o>>30))*0xbf58476d1ce4e5b9;o=(o^(o>>27))*0x94d049bb133111eb;ros^(o>>31);}ull SALT=0x7a14a4b0881ebf9,tqu=0x7a14a4b0881ebf9;ull my_rand(){return tqu=mix(tqu);}void my_srand(ull x){SALT=tqu=x;}const int inf = 1023400000;const ll llinf=1234567890000000000ll;\n#define rand my_rand\n#define srand my_srand\n#define random_shuffle(r...)random_shuffle(r,[](int _){return my_rand()%_;})\nsim>inline c nux(c m){if(!m)return numeric_limits<c>::max();c A=m&-m;c B=~((A-1)^m);c C=B&-B;c D=(C>>(1+ctz(A)))-1;return C|(m&~(C-1))|D;}__attribute__((no_sanitize_undefined))ll mul(ll a,ll b,ll m){ll q=a*(ld)b/m;ll o=a*b-q*m;o%=m;if(o<0)o+=m;ros;}sim>void unq(c&x){x.resize(unique(ALL(x))-x.begin());}\n#if ((ULONG_MAX) != (UINT_MAX))\nnamespace std {template <> struct is_signed<__int128> : public true_type {};}\n#endif\n#define q31 (8 * sizeof(c) - 1)\nsim, class d> typename common_type<c,d>::type floor_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using floor_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b - (a % b < 0);}\nsim, class d> typename common_type<c,d>::type ceil_div(c a, d b) {static_assert(is_signed<c>::value==is_signed<d>::value,\"using ceil_div with different signedness\");if (b < 0) b = -b, a = -a;return a / b + (a % b > 0);}\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wformat-security\"\ntemplate <class...c> void done(const c&...x) {printf(x...); exit(0);}\n#pragma GCC diagnostic pop\nsim> struct REV {c &x;using it=typename c::reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> struct CREV {const c&x;using it=typename c::const_reverse_iterator;it begin(){return x.rbegin();}it end(){return x.rend();}};\nsim> REV<c> reversed(c&x) {return REV<c>{x};}sim> CREV<c> reversed(const c&x) {return CREV<c>{x};}\n\n#if defined(LOCAL) || defined(LOCAL2)\nvoid __tmi() {cerr << setprecision(6) << fixed << \"total time: \" << clock() / (ld)CLOCKS_PER_SEC << \"s\" << endl;}int _ = (atexit(__tmi), 0);\n#endif\nconst int nax = 1e5 + 44;\nint u[nax * 2];\nbool full[nax * 2];\nint find(int x) {\n\tif (u[x] == x) return x;\n\treturn u[x] = find(u[x]);\n}\nbool onion(int a, int b) {\n\ta = find(a);\n\tb = find(b);\n\tif (a == b) {\n\t\tif (full[a]) return false;\n\t\tfull[a] = true;\n\t\treturn true;\n\t}\n\tif (full[a] && full[b]) return false;\n\tfull[a] = full[b] = (full[a] || full[b]);\n\tu[a] = b;\n\treturn true;\n}\nint main() {\n\tint n;\n\tscanf(\"%d%*d%*d\", &n);\n\tiota(u, u + 2 * nax, 0);\n\tvector <pair <int, pii> > E;\n\tREP(_, n) {\n\t\tint r, c, a;\n\t\tscanf(\"%d%d%d\", &r, &c, &a);\n\t\tE.emplace_back(a, make_pair(r + nax, c));\n\t}\n\tsort(RALL(E));\n\tll ans = 0;\n\tfor (auto [cost, ver] : E) {\n\t\tif (onion(FS(ver))) ans += cost;\n\t}\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<cstdlib>\n#include<queue>\n#include<ctime>\n#include<vector>\n#include<set>\n#include<map>\n#include<stack>\nusing namespace std;\n#define int long long\nstruct node {\n\tint x,y,w;\n};\nnode d[200100];\nint n,m,H,W,fa[200100],is[200100];\nlong long Ans;\ninline int sf(int x){return fa[x]==x?x:fa[x]=sf(fa[x]);}\ninline bool cmp(const node a,const node b){return a.w>b.w;}\nsigned main(){\n    int i,j,k;\n    scanf(\"%lld%lld%lld\",&m,&H,&W);\n    n=H+W;\n    for(i=1;i<=n;i++)fa[i]=i;\n    for(i=1;i<=m;i++){\n      scanf(\"%lld%lld%lld\",&d[i].x,&d[i].y,&d[i].w);\n      d[i].y+=H;\n    }\n    sort(d+1,d+m+1,cmp);\n    for(i=1;i<=m;i++){\n      int x=d[i].x,y=d[i].y;\n      if(sf(x)!=sf(y)){\n      \tif(is[sf(x)]&&is[sf(y)])continue;\n      \tfa[sf(x)]=sf(y);\n      \tis[sf(y)]|=is[sf(x)];\n      \tAns+=d[i].w;\n      }else {\n      \tif(!is[sf(x)]){\n      \t  is[sf(x)]=1;\n      \t  Ans+=d[i].w;\n      \t}\n      }\n    }\n    printf(\"%lld\\n\",Ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nstruct DSU {\n\tvector<int> p, s;\n\tvector<bool> kek;\n\tDSU(int n) : p(n), s(n, 1), kek(n) { iota(p.begin(), p.end(), 0); }\n\tint get(int v) {\n\t\treturn (v == p[v] ? v : p[v] = get(p[v]));\n\t}\n\tbool unite(int u, int v) {\n\t\tu = get(u);\n\t\tv = get(v);\n\t\tif (u != v) {\n\t\t\tif (kek[u] && kek[v]) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (s[u] < s[v]) {\n\t\t\t\tswap(u, v);\n\t\t\t}\n\t\t\ts[u] += s[v];\n\t\t\tp[v] = u;\n\t\t\tkek[u] = kek[u] | kek[v];\n\t\t\treturn true;\n\t\t}\n\t\telse if (!kek[u]) {\n\t\t\tkek[u] = true;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nstruct Edge {\n\tint u, v, w;\n\tbool operator < (const Edge& o) const {\n\t\treturn (w > o.w);\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n, h, w;\n\tcin >> n >> h >> w;\n\tvector<Edge> es;\n\tfor (int i = 0; i < n; i++) {\n\t\tint r, c, w;\n\t\tcin >> r >> c >> w;\n\t\t--r; --c;\n\t\tes.push_back({ r, h + c, w });\n\t}\n\tsort(es.begin(), es.end());\n\tDSU dsu(h + w);\n\tlong long ans = 0;\n\tfor (auto& e : es) {\n\t\tif (dsu.unite(e.u, e.v)) {\n\t\t\tans += e.w;\n\t\t}\n\t}\n\tcout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \nusing namespace std;\n \n#define F first\n#define S second \n#define pb push_back\n#define endl \"\\n\"\n\n#define IOS { ios :: sync_with_stdio(false); cin.tie(0); cout.tie(0); }\n\n#ifdef DEBUG\n    #define dbg(s) {s;}\n#endif\n\n#ifndef DEBUG\n    #define dbg(s)\n#endif\n\nusing namespace std;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint grand(int x) { // from [0, n-1]\n    return uniform_int_distribution<int>(0, x - 1)(rng);\n}\n\n#define int ll\n#define i32 int32_t\n\n#define RBTTYPE int\n#define ordered_set tree<RBTTYPE, null_type, less<RBTTYPE>, rb_tree_tag,tree_order_statistics_node_update> \n\n#define all(v) (v).begin(),(v).end()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair< int, int > pii;\ntypedef pair< ll, ll > pll;\n\nint getInt () {\n    bool minus = false;\n    int result = 0;\n    char ch;\n    ch = getchar();\n    while (true) {\n        if (ch == '-') break;\n        if (ch >= '0' && ch <= '9') break;\n        ch = getchar();\n    }\n    if (ch == '-') minus = true; else result = ch-'0';\n    while (true) {\n        ch = getchar();\n        if (ch < '0' || ch > '9') break;\n        result = result*10 + (ch - '0');\n    }\n    if (minus)\n        return -result;\n    else\n        return result;\n}\n\n\nll gcd(ll x, ll y) {\n    if (x < y) return gcd(y, x);\n    if (y == 0) return x;\n    return gcd(y, x % y);\n} \n\nconst ll mod = 1e9 + 7;\n\nll modexp(ll x, ll ex) {\n    ll ans = 1ll;\n    while (ex > 0) {\n        if (ex & 1ll) ans = (ans * x) % mod;\n        ex >>= 1ll;\n        x = (x * x) % mod;\n    }\n    return ans;\n}\n\nconst int maxn = 1e6 + 7;\n\nconst ll inf = 1e9 + 7;\n\nvector < pair<int, pii> > v;\n\nint rw[maxn];\nint co[maxn];\n\ni32 main() {\n    //freopen(\"<file>.in\", \"r\", stdin);\n    //freopen(\"<file>.out\", \"w\", stdout);\n\n    IOS;\n\n    int n, h, w; cin >> n >> h >> w;\n    for (int i = 1; i <= n; i++) {\n        int r, c, a; cin >> r >> c >> a;\n        v.pb({a, {r, c}});\n    }\n\n    sort(v.begin(), v.end()); reverse(all(v));\n    fill(rw, rw + maxn, -1);\n    fill(co, co + maxn, -1);\n\n    int idx = 0, ans = 0;\n    for (auto z : v) {\n        int a = z.F, r, c; tie(r, c) = z.S;\n        if (rw[r] < 0) {\n            rw[r] = idx;\n            ans += a;\n        } else if (co[c] < 0) {\n            co[c] = idx; ans += a;   \n        } else if (co[v[rw[r]].S.S] < 0) {\n            co[v[rw[r]].S.S] = rw[r];\n            rw[r] = idx;\n            ans += a;\n        } else if (rw[v[co[c]].S.F] < 0) {\n            rw[v[co[c]].S.F] = co[c];\n            co[c] = idx;\n            ans += a;\n        } else ;\n        idx++;\n    }\n    cout << ans << endl; \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct edge\n{\n\tint r,c,v;\n}e[200001];\nbool cmp(edge a,edge b){return a.v>b.v;}\nint fa[200001];\nint siz[200001];\nint find(int x){return (fa[x]==x)?x:fa[x]=find(fa[x]);}\nsigned main() \n{\n\tint n,h,w;\n\tscanf(\"%lld%lld%lld\",&n,&h,&w);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld%lld%lld\",&e[i].r,&e[i].c,&e[i].v);\n\t\te[i].c+=100000;\n\t}\n\tsort(e+1,e+n+1,cmp);\n\tint ans=0;\n\tfor(int i=1;i<=n+100000;i++)\n\t\tfa[i]=i,siz[i]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint f1=find(e[i].r),f2=find(e[i].c);\n\t\tif(f1==f2)\n\t\t{\n\t\t\tif(siz[f1]>=1)\n\t\t\t{\n\t\t\t\tsiz[f1]--;\n\t\t\t\tans+=e[i].v;\n\t\t\t}\n\t\t}\n\t\telse if(siz[f1]+siz[f2]>=1)\n\t\t{\n\t\t\tfa[f1]=f2;\n\t\t\tsiz[f2]+=siz[f1]-1;\n\t\t\tans+=e[i].v;\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define LLINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define dmp(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl;\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\ntemplate<class T>\nusing MaxHeap = priority_queue<T>;\ntemplate<class T>\nusing MinHeap = priority_queue<T,vector<T>,greater<T> >;\ntemplate<class T,class U>\nostream& operator << (ostream& os,pair<T,U>& p){\n  os << p.fi << ',' << p.sec; return os;\n}\ntemplate<class T,class U>\nistream& operator >> (istream& is,pair<T,U>& p){\n  is >> p.fi >> p.sec; return is;\n}\ntemplate<class T>\nostream& operator << (ostream &os,const vector<T> &vec){\n  for(int i=0;i<vec.size();i++){\n    os << vec[i];\n    if(i+1<vec.size())os << ' ';\n  }\n  return os;\n}\ntemplate<class T>\nistream& operator >> (istream &is,vector<T>& vec){\n  for(int i=0;i<vec.size();i++)is >> vec[i];\n  return is;\n}\nvoid fastio(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  cout<<fixed<<setprecision(20);\n}\nstruct UnionFind{\n\tvector<int> par,rank,sz;\n\tvoid init(int n){\n    par.resize(n);\n    sz.resize(n,1);\n    rank.resize(n,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y)return;\n    par[x] = y;\n    sz[y] += sz[x];\n    rank[y] += rank[x];\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x) == find(y);\n\t}\n}uf;\nint N;\nint H,W;\nstruct edge{\n  int f,t;\n  ll c;\n  edge(){}\n  edge(int f,int t,int c):f(f),t(t),c(c){}\n  bool operator < (const edge& a) const{\n    return c > a.c;\n  }\n};\nvector<edge> es;\nint main(){\n  fastio();\n  cin >> N >> H >> W;\n  uf.init(2*N);\n  for(int i=0;i<N;i++){\n    int r,c,a;\n    cin >> r >> c >> a;\n    r--;c--;\n    c += N;\n    es.pb(edge(r,c,a));\n  }\n  sort(all(es));\n  ll ans = 0ll;\n  for(int i=0;i<es.size();i++){\n    edge e = es[i];\n    int f = uf.find(e.f);\n    int t = uf.find(e.t);\n    if(f==t){\n      if(uf.sz[f]>uf.rank[f]){\n        ans += e.c;\n        uf.rank[f]++;\n      }\n    }else{\n      if(uf.sz[f]+uf.sz[t]>=uf.rank[f]+uf.rank[t]+1){\n        ans += e.c;\n        uf.unite(f,t);\n        uf.rank[t]++;\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing P = pair<int, int>;\nconst int MX = 100005;\nint n, h, w, a, r[MX], c[MX];\nP pr[MX];\nlong long ans;\nint p[MX*2], m[MX*2];\nint find(int x){return p[x] ? p[x] = find(p[x]) : x;}\nvoid uni(P pr){\n\tint f, x, y, z;\n\ttie(z, f) = pr;\n\tx = find(r[f]); y = find(h+c[f]);\n\tif(!m[x] || !m[y]) ans += z;\n\tif(x != y){\n\t\tif(p[x] > p[y]) swap(x, y);\n\t\tp[x] += p[y];\n\t\tp[y] = x;\n\t\tm[x] = max({m[x], m[y]});\n\t}else if(!m[x]) m[x] = z;\n\t\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &h, &w);\n\trep(i,n){\n\t\tscanf(\"%d%d%d\", r+i, c+i, &a);\n\t\tpr[i] = P(a,i);\n\t}\n\tsort(pr,pr+n, greater<P>());\n\trep(i,n) uni(pr[i]);\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n#define mod 1000000007\n#define N 200010\nll h,w,n;\nnamespace uf{\n  ll p[N],s[N];\n  void init(){\n      for(int i=0;i<N;i++)p[i]=i,s[i]=1;\n  }  \n  ll par(ll x){\n      return p[x]=(x==p[x]?x:par(p[x]));\n  }\n  bool unite(ll a,ll b){\n      a=par(a),b=par(b);\n      if(a==b){\n\t  if(s[a]==0)return 0;\n\t  s[a]--;\n      }\n      else{\n\t  if(s[a]+s[b]-1<0)return 0;\n\t  s[a]+=s[b]-1;\n\t  p[b]=a;\n      }\n      return 1;\n  }\n};\nstruct edge{\n  ll a,b,c;\n  edge(ll a,ll b,ll c){\n      this->a=a,this->b=b,this->c=c;\n  } \n  bool operator<(const edge&key)const{\n      return this->c>key.c;\n  } \n};\nvector<edge> v;\nint main(){\n  cin>>n>>h>>w;\n  for(int i=0;i<n;i++){\n      ll a,b,c; cin>>a>>b>>c;\n      v.push_back(edge(a,b+1e5,c));\n  }\n  sort(v.begin(),v.end());\n  ll ans=0;\n  uf::init();\n  for(int i=0;i<n;i++){\n      if(uf::unite(v[i].a,v[i].b)){\n\t  ans+=v[i].c;\n      }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// orz dxm\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define PH push\n#define MP make_pair\n#define PB push_back\n#define fst first\n#define snd second\n#define FOR(i, x, y) for(int i = (x); i < (y); ++i)\n#define REP(i, x, y) for(int i = (x); i <= (y); ++i)\n#define y0 yORZDXM\n#define y1 yORZDXM\n#define y2 yORZDXM\ntypedef double db;\ntypedef long long ll;\ntypedef long double ldb;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9 + 7;\nconst int maxn = 1e5 + 5;\n\nint n, h, w;\nll ans;\n\nclass Edge{public: int u, v, w; bool operator < (const Edge &e)const{return MP(w, MP(u, v)) < MP(e.w, MP(e.u, e.v));}}ed[maxn];\n\nclass Dsu{\nprivate:\n\tint fa[maxn << 1], cyc[maxn << 1];\npublic:\n\tinline void init(){FOR(i, 0, maxn << 1) fa[i] = i, cyc[i] = false; return;}\n\tinline int find(int u){return (u == fa[u]) ? u : (fa[u] = find(fa[u]));}\n\tinline int combine(int u, int v, int w){\n\t\tu = find(u), v = find(v);\n\t\tif(u == v){\n\t\t\tif(!cyc[u]){\n\t\t\t\tcyc[u] = true;\n\t\t\t\treturn w;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif(cyc[u] && cyc[v]) return 0;\n\t\tfa[u] = v;\n\t\tcyc[v] |= cyc[u];\n\t\treturn w;\n\t}\n}dsu;\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &h, &w);\n\tdsu.init();\n\tFOR(i, 0, n){\n\t\tscanf(\"%d%d%d\", &ed[i].u, &ed[i].v, &ed[i].w);\n\t\t--ed[i].u, --ed[i].v;\n\t\ted[i].v += h;\n\t}\n\tsort(ed, ed + n);\n\treverse(ed, ed + n);\n\tFOR(i, 0, n) ans += dsu.combine(ed[i].u, ed[i].v, ed[i].w);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> par;\n    vector<int> sz;\n    vector<int> avail;\n\n    UnionFind(int n=0){\n        if(n>0) initialize(n);\n    }\n\n    void initialize(int n){\n        par.resize(n);\n        sz.resize(n);\n        avail.resize(n);\n        for(int i=0; i<n; i++){\n            par[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n    int find(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n        if(sz[x] > sz[y]) swap(x, y);\n        par[x] = y;\n        sz[y] += sz[x];\n        avail[y] += avail[x];\n    }\n\n    void add_avail(int x){\n        avail[find(x)]++;\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint main(){\n    int N, H, W, R[100000], C[100000], A[100000];\n    cin >> N >> H >> W;\n    static vector<pair<int, int>> hs[100000], ws[100000];\n    for(int i=0; i<N; i++){\n        cin >> R[i] >> C[i] >> A[i];\n        R[i]--; C[i]--;\n        hs[R[i]].emplace_back(A[i], i);\n        ws[C[i]].emplace_back(A[i], i);\n    }\n\n    bitset<100000> use;\n    UnionFind uf(N);\n    for(int i=0; i<100000; i++){\n        if(hs[i].size()){\n            sort(hs[i].rbegin(), hs[i].rend());\n            int v = hs[i][0].second;\n            use[v] = 1;\n            uf.add_avail(v);\n            for(auto& p : hs[i]) uf.unite(p.second, v);\n        }\n        if(ws[i].size()){\n            sort(ws[i].rbegin(), ws[i].rend());\n            int v = ws[i][0].second;\n            use[v] = 1;\n            uf.add_avail(v);\n            for(auto& p : ws[i]) uf.unite(p.second, v);\n        }\n    }\n\n    static vector<pair<int, int>> vs[100000];\n    int avail[100000] = {0};\n    for(int i=0; i<N; i++){\n        int r = uf.find(i);\n        vs[r].emplace_back(use[i], A[i]);\n        if(r == i) avail[i] = uf.avail[i];\n    }\n\n    int64_t ans = 0;\n    for(int i=0; i<N; i++){\n        auto& v = vs[i];\n        sort(v.rbegin(), v.rend());\n        int a = min(avail[i], (int)v.size());\n        for(int j=0; j<a; j++) ans += v[j].second;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <set>\n#define ll long long\nusing namespace std;\ntemplate <class T>\ninline void rd(T &x)\n{\n\tx=0; char c=getchar(); int f=1;\n\twhile(!isdigit(c)){if(c=='-')f=-1; c=getchar();}\n\twhile(isdigit(c)) x=x*10-'0'+c,c=getchar(); x*=f;\n}\nconst int N=2e5+10;\nint A[N],R[N],C[N],n; // r -> r   c -> c+H\nstruct item {\n\tint u;\n\titem(int u=0): u(u) {}\n\tfriend bool operator <(item a,item b) { return A[a.u]==A[b.u]?a.u<b.u:A[a.u]>A[b.u]; }\n};\nset<item> s[N];\nmultiset<item> que;\nint bel[N];\nvoid un(int x,int y) {\n\tif(s[bel[x]].size()>s[bel[y]].size()) swap(x,y);\n\tif(!s[bel[x]].size()) {\n\t\tif(s[bel[y]].size()) que.insert(*s[bel[y]].begin());\n\t\tbel[x]=y;\n\t\treturn;\n\t}\n\tfor(set<item>::iterator it=s[bel[x]].begin();it!=s[bel[x]].end();++it)\n\t\ts[bel[y]].insert(*it);\n\tbel[x]=y;\n\tque.insert(*s[bel[y]].begin());\n}\nint find(int x) { return bel[x]==x?x:bel[x]=find(bel[x]); }\nint H,W;\ninline void Erase(int u) {\n\tint x=find(R[u]),y=find(C[u]+H);\n\tif(s[x].size()&&s[y].size()&&x!=y) {\n\t\tif((s[x].begin()->u)==u) que.erase(que.find(item(u)));\n\t\tif((s[y].begin()->u)==u) que.erase(que.find(item(u)));\n\t\ts[x].erase(item(u));\n\t\ts[y].erase(item(u));\n\t\tun(x,y);\n\t\treturn;\n\t}\n\tque.erase(que.find(item(u)));\n\ts[x].clear(),s[y].clear();\n}\nvoid Debug() {\n\tfor(int i=1;i<=H;++i) {\n\t\tprintf(\"r%d : \",i);\n\t\tint x=find(i);\n\t\tfor(set<item>::iterator it=s[x].begin();it!=s[x].end();++it) printf(\"%d \",it->u); puts(\"\");\n\t}\n\tfor(int i=1;i<=W;++i) {\n\t\tprintf(\"c%d : \",i);\n\t\tint x=find(i+H);\n\t\tfor(set<item>::iterator it=s[x].begin();it!=s[x].end();++it) printf(\"%d \",it->u); puts(\"\");\n\t}\n\tcout<<\"que : \";\n\tfor(multiset<item>::iterator it=que.begin();it!=que.end();++it) printf(\"%d \",it->u); puts(\"\");\n}\n\t\nint main() {\n\trd(n),rd(H),rd(W);\n\tfor(int i=1;i<=W+H;++i) bel[i]=i;\n\tfor(int i=1;i<=n;++i) {\n\t\trd(R[i]),rd(C[i]),rd(A[i]);\n\t\ts[R[i]].insert(item(i));\n\t\ts[C[i]+H].insert(item(i));\n\t}\n\tfor(int i=1;i<=W+H;++i)\n\t\tif(s[i].size()) que.insert(*s[i].begin());\n\tll ans=0;\n\twhile(!que.empty()) {\n\t\tint u=que.begin()->u;\n//\t\tcout<<u<<endl;\n\t\tans+=A[u]; Erase(u);\n//\t\tDebug();\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEBUG 0\n/**\n * File    : E.cpp\n * Author  : Kazune Takahashi\n * Created : 8/24/2019, 10:33:10 PM\n * Powered by Visual Studio Code\n */\n#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <complex>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <chrono>\n#include <cctype>\n#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\nusing namespace std;\n#define maxs(x, y) (x = max(x, y))\n#define mins(x, y) (x = min(x, y))\nusing ll = long long;\nclass mint\n{\npublic:\n  static ll MOD;\n  ll x;\n  mint() : x(0) {}\n  mint(ll x) : x(x % MOD) {}\n  mint operator-() const { return x ? MOD - x : 0; }\n  mint &operator+=(const mint &a)\n  {\n    if ((x += a.x) >= MOD)\n    {\n      x -= MOD;\n    }\n    return *this;\n  }\n  mint &operator-=(const mint &a) { return *this += -a; }\n  mint &operator*=(const mint &a)\n  {\n    (x *= a.x) %= MOD;\n    return *this;\n  }\n  mint &operator/=(const mint &a)\n  {\n    mint b{a};\n    return *this *= b.power(MOD - 2);\n  }\n  mint operator+(const mint &a) const { return mint(*this) += a; }\n  mint operator-(const mint &a) const { return mint(*this) -= a; }\n  mint operator*(const mint &a) const { return mint(*this) *= a; }\n  mint operator/(const mint &a) const { return mint(*this) /= a; }\n  bool operator<(const mint &a) const { return x < a.x; }\n  bool operator==(const mint &a) const { return x == a.x; }\n  const mint power(ll N)\n  {\n    if (N == 0)\n    {\n      return 1;\n    }\n    else if (N % 2 == 1)\n    {\n      return *this * power(N - 1);\n    }\n    else\n    {\n      mint half = power(N / 2);\n      return half * half;\n    }\n  }\n};\nll mint::MOD = 1e9 + 7;\nistream &operator>>(istream &stream, mint &a) { return stream >> a.x; }\nostream &operator<<(ostream &stream, const mint &a) { return stream << a.x; }\nclass combination\n{\npublic:\n  vector<mint> inv, fact, factinv;\n  static int MAX_SIZE;\n  combination() : inv(MAX_SIZE), fact(MAX_SIZE), factinv(MAX_SIZE)\n  {\n    inv[1] = 1;\n    for (auto i = 2; i < MAX_SIZE; i++)\n    {\n      inv[i] = (-inv[mint::MOD % i]) * (mint::MOD / i);\n    }\n    fact[0] = factinv[0] = 1;\n    for (auto i = 1; i < MAX_SIZE; i++)\n    {\n      fact[i] = mint(i) * fact[i - 1];\n      factinv[i] = inv[i] * factinv[i - 1];\n    }\n  }\n  mint operator()(int n, int k)\n  {\n    if (n >= 0 && k >= 0 && n - k >= 0)\n    {\n      return fact[n] * factinv[k] * factinv[n - k];\n    }\n    return 0;\n  }\n};\nint combination::MAX_SIZE = 3000010;\nll gcd(ll x, ll y) { return y ? gcd(y, x % y) : x; }\n// constexpr double epsilon = 1e-10;\n// constexpr ll infty = 1000000000000000LL;\n// constexpr int dx[4] = {1, 0, -1, 0};\n// constexpr int dy[4] = {0, 1, 0, -1};\nvoid Yes()\n{\n  cout << \"Yes\" << endl;\n  exit(0);\n}\nvoid No()\n{\n  cout << \"No\" << endl;\n  exit(0);\n}\n\nclass UnionFind\n{\n  vector<long long> par;\n\npublic:\n  UnionFind() {}\n  UnionFind(int n) : par(n, -1) {}\n\n  bool is_same(int x, int y)\n  {\n    return root(x) == root(y);\n  }\n\n  bool merge(int x, int y)\n  {\n    x = root(x);\n    y = root(y);\n    if (x == y)\n    {\n      return false;\n    }\n    if (par[x] > par[y])\n    {\n      swap(x, y);\n    }\n    par[x] += par[y];\n    par[y] = x;\n    return true;\n  }\n\n  long long size(int x)\n  {\n    return -par[root(x)];\n  }\n\nprivate:\n  int root(int x)\n  {\n    if (par[x] < 0)\n    {\n      return x;\n    }\n    return par[x] = root(par[x]);\n  }\n};\n\nll N, H, W;\nusing info = tuple<ll, ll, ll>;\nvector<info> V;\n\nint main()\n{\n  cin >> N >> H >> W;\n  UnionFind UF(H + W + 1);\n  const ll has_loop{H + W};\n  for (auto i = 0; i < N; i++)\n  {\n    ll R, C, A;\n    cin >> R >> C >> A;\n    R--;\n    C--;\n    V.emplace_back(A, R, H + C);\n  }\n  sort(V.rbegin(), V.rend());\n  ll ans{0};\n  for (auto i = 0; i < N; i++)\n  {\n    ll R, C, A;\n    tie(A, R, C) = V[i];\n    if (!UF.is_same(R, C))\n    {\n      ans += A;\n      UF.merge(R, C);\n    }\n    else if (!UF.is_same(R, has_loop))\n    {\n      ans += A;\n      UF.merge(R, has_loop);\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nint main() {\n\tint N, H, W;\n\tcin >> N >> H >> W;\n\tvector<int> X(N), Y(N), A(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> X[i] >> Y[i] >> A[i]; --X[i], --Y[i];\n\t}\n\tvector<int> perm(N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tperm[i] = i;\n\t}\n\tsort(perm.begin(), perm.end(), [&](int i, int j) {\n\t\treturn A[i] > A[j];\n\t});\n\tvector<vector<int> > g(H + W);\n\tvector<int> group(H + W);\n\tvector<bool> cycle(H + W);\n\tfor (int i = 0; i < H + W; ++i) {\n\t\tg[i] = { i };\n\t\tgroup[i] = i;\n\t\tcycle[i] = false;\n\t}\n\tlong long ans = 0;\n\tfor (int i : perm) {\n\t\tint va = group[X[i]], vb = group[Y[i] + H];\n\t\tif (va == vb && !cycle[va]) {\n\t\t\tcycle[va] = true;\n\t\t\tans += A[i];\n\t\t}\n\t\tif (va != vb) {\n\t\t\tif (cycle[va] && cycle[vb]) continue;\n\t\t\tif (g[va].size() < g[vb].size()) swap(va, vb);\n\t\t\tg[va].insert(g[va].end(), g[vb].begin(), g[vb].end());\n\t\t\tfor (int i : g[vb]) group[i] = va;\n\t\t\tif (cycle[vb]) cycle[va] = true;\n\t\t\tg[vb].clear();\n\t\t\tans += A[i];\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nint u[216000];\nbool loop[216000];\nvoid init(){\n    for(int i = 0;i < 216000;i++)u[i] = i;\n}\n\nint rt(int x){\n    if(u[x] == x)return x;\n    return u[x] = rt(u[x]);\n}\n\nvoid unite(int x, int y){\n    x = rt(x);\n    y = rt(y);\n    u[x] = y;\n}\n\nint n, h, w;\nint r, c, a;\n\ntypedef pair<Int, P> T;\n\nvector<T> edges;\nInt res;\nint main(){\n    init();\n    cin >> n >> h >> w;\n    for(int i = 0;i < n;i++){\n        cin >> r >> c >> a;r--,c--;\n        edges.push_back(T(a,P(r, c)));\n    }\n    sort(edges.rbegin(), edges.rend());\n    for(auto e: edges){\n        a = e.first;\n        r = e.second.first;\n        c = e.second.second;\n        c += h;\n        int rtr = rt(r), rtc = rt(c);\n        if(loop[rtr] && loop[rtc])continue;\n        res += a;\n//        cout << a << \" \" << r + 1 << \" \" << c - n + 1 << endl;\n        if(rtr == rtc){\n            loop[rtr] = true;\n            continue;\n        }\n        if(!loop[rtr] && !loop[rtc]){\n            unite(r,c);continue;\n        }\n        else{\n            unite(r, c);\n            loop[rt(r)] = true;\n        }\n    }\n    cout << res << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for(int i = 0;i < n;i++)\n#define VSORT(v) sort(v.begin(), v.end())\n#define VRSORT(v) sort(v.rbegin(), v.rend())\n#define ll long long\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef pair<int, P> PP;\ntypedef pair<ll, LP> LPP;\ntypedef vector<unsigned int>vec;\ntypedef vector<vec> mat;\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\nconst int INF = 1000000000;\nconst ll LINF = 1000000000000000000;//1e18\nconst ll  MOD = 1000000007;\nconst double PI = acos(-1.0);\nconst double EPS = 1e-10;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate<class T> inline void add(T &a, T b){a = ((a+b) % MOD + MOD) % MOD;};\n\nstruct UnionFind {\n    vector<int> par;\n    \n    UnionFind(int n) : par(n, -1) { }\n    void init(int n) { par.assign(n, -1); }\n    \n    int root(int x) {\n        if (par[x] < 0) return x;\n        else return par[x] = root(par[x]);\n    }\n    \n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n    \n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (par[x] > par[y]) swap(x, y); // merge technique\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    \n    int size(int x) {\n        return -par[root(x)];\n    }\n};\n\nstruct edge{\n    ll from, to, cost;\n    edge(ll s, ll d, ll w) : from(s), to(d), cost(w){}\n    \n    bool operator < (const edge& x) const {\n        return cost < x.cost;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N, H, W;\n    cin >> N >> H >> W;\n    vector<edge> x,y;\n\n    UnionFind uf(H + W + 10);\n\n    REP(i,N){\n        ll R, C, A;\n        cin >> R >> C >> A;\n        x.emplace_back(R, C+H, -A);\n    }\n\n    sort(x.begin(), x.end());\n    \n    ll ans = 0;\n\n    REP(i,N){\n        if(!uf.issame(x[i].from, x[i].to)){\n            ans += x[i].cost;\n            uf.unite(x[i].from, x[i].to);\n        }\n        else{\n            if(!uf.issame(x[i].from, 0)){\n                ans += x[i].cost;\n                uf.unite(x[i].from,0);\n            }\n        }\n    }\n    cout << ans * (-1) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// tourist's modular-arithmetic class\ntemplate <typename T>\nT inverse(T a, T m) {\n    T u = 0, v = 1;\n    while (a != 0) {\n        T t = m / a;\n        m -= t * a; swap(a, m);\n        u -= t * v; swap(u, v);\n    }\n    assert(m == 1);\n    return u;\n}\n\ntemplate <typename T>\nclass Modular {\npublic:\n    using Type = typename decay<decltype(T::value)>::type;\n\n    constexpr Modular() : value() {}\n    template <typename U>\n    Modular(const U& x) {\n        value = normalize(x);\n    }\n\n    template <typename U>\n    static Type normalize(const U& x) {\n        Type v;\n        if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n        else v = static_cast<Type>(x % mod());\n        if (v < 0) v += mod();\n        return v;\n    }\n\n    const Type& operator()() const { return value; }\n    template <typename U>\n    explicit operator U() const { return static_cast<U>(value); }\n    constexpr static Type mod() { return T::value; }\n\n    Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n    Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n    template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n    template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n    Modular& operator++() { return *this += 1; }\n    Modular& operator--() { return *this -= 1; }\n    Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n    Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n    Modular operator-() const { return Modular(-value); }\n\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n#ifdef _WIN32\n        uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n        uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n        asm(\n        \"divl %4; \\n\\t\"\n        : \"=a\" (d), \"=d\" (m)\n        : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n        );\n        value = m;\n#else\n        value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n#endif\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n        int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n        value = normalize(value * rhs.value - q * mod());\n        return *this;\n    }\n    template <typename U = T>\n    typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n        value = normalize(value * rhs.value);\n        return *this;\n    }\n\n    Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n\n    template <typename U>\n    friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n\n    template <typename U>\n    friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n\n    template <typename U>\n    friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n\n    template <typename U>\n    friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n\nprivate:\n    Type value;\n};\n\n\ntemplate <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\ntemplate <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\ntemplate <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n\ntemplate <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\ntemplate <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n\ntemplate <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n\ntemplate <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\ntemplate <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n\ntemplate <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\ntemplate <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n\ntemplate <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\ntemplate <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n\ntemplate <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\ntemplate <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n\ntemplate<typename T, typename U>\nModular<T> power(const Modular<T>& a, const U& b) {\n    assert(b >= 0);\n    Modular<T> x = a, res = 1;\n    U p = b;\n    while (p > 0) {\n        if (p & 1) res *= x;\n        x *= x;\n        p >>= 1;\n    }\n    return res;\n}\n\ntemplate <typename T>\nbool IsZero(const Modular<T>& number) {\n    return number() == 0;\n}\n\ntemplate <typename T>\nstring to_string(const Modular<T>& number) {\n    return to_string(number());\n}\n\ntemplate <typename T>\nstd::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n    return stream << number();\n}\n\ntemplate <typename T>\nstd::istream& operator>>(std::istream& stream, Modular<T>& number) {\n    typename common_type<typename Modular<T>::Type, int64_t>::type x;\n    stream >> x;\n    number.value = Modular<T>::normalize(x);\n    return stream;\n}\n\nstruct fast_ios {\n    fast_ios() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(10);\n    };\n} fast_ios_;\n\n#define LSON(x) ((x) * 2)\n#define RSON(x) ((x) * 2 + 1)\ntemplate<typename A, typename B>\nvoid Min(A &a, const B &b){\n    if (b < a) a = b;\n}\ntemplate<typename A, typename B>\nvoid Max(A &a, const B &b){\n    if (b > a) a = b;\n}\n\nint cas;\nostream& kase() {\n    return cout << \"Case #\" << ++cas << \": \";\n}\n\n#if __cplusplus < 201402L\ntemplate<class Iterator>\nstd::reverse_iterator<Iterator> make_reverse_iterator(Iterator it)\n{\n    return std::reverse_iterator<Iterator>(it);\n}\n#endif\n\ntemplate <typename iter_t>\nstruct iter_pair {\n    iter_t _beg, _end;\n    iter_t begin(){return _beg;}\n    iter_t end(){return _end;}\n};\n\ntemplate<class cont> iter_pair<reverse_iterator<decltype(begin(declval<cont>()))>>\nreverse(cont &&r) {\n    return {make_reverse_iterator(end(r)), make_reverse_iterator(begin(r))};\n}\n\ntemplate<typename T> void dprintln(const T &t) { cout << t << endl; } // for debug use\ntemplate<typename T, typename ...Args> void dprintln(const T &t, const Args &...rest) { cout << t << ' '; dprintln(rest...); }\ntemplate<typename T> void println(const T &t) { cout << t << '\\n'; }\n\n\ntemplate<typename T, typename ...Args> void println(const T &t, const Args &...rest) { cout << t << ' '; println(rest...); }\ntemplate<typename T> void println(const vector<T>& vec) {\n    if (!vec.empty()) {\n        cout << vec[0];\n        for (size_t i = 1; i < vec.size(); ++i)\n            cout << ' ' << vec[i];\n    }\n    cout << '\\n';\n}\n\ntemplate<typename T> void print(const T &t) { cout << t << ' '; }\n\ntemplate<typename T, typename ...Args> void print(const T &t, const Args &...rest) { cout << t << ' '; print(rest...); }\n\n// this overload is chosen when there's only one argument\ntemplate<class T> void scan(T &t) { cin >> t; }\ntemplate<class T, class ...Args> void scan(T &a, Args &...rest) { cin >> a; scan(rest...); }\ntemplate<typename T> istream& operator>>(istream& stream, vector<T>& vec) {\n    for (auto& x : vec) stream >> x;\n    return stream;\n}\nusing ull = unsigned long long;\nusing ll = long long;\nusing ul = unsigned long;\nusing vl = vector<ll>;\nusing vi = vector<int>;\nusing pii = pair<int,int>;\nusing pip = pair<int,pii>;\nusing pll = pair<ll,ll>;\nusing vb = vector<bool>;\nusing vpii = vector<pii>;\nusing ldb = long double;\ntemplate <typename int_t>\ninline int_t lowbit(int_t x) {return x & -x;}\n#define rng(i, a, b) for(int i = (int)(a); i < (int)(b); ++i)\n#define up(i, a, b) for (int i = int(a); i <= int(b); ++i)\n#define down(i, b, a) for (int i = int(b); i >= int(a); i--)\n#define rep(n) for(int _iter_##n = 0, _num_##n = (int)n; _iter_##n < _num_##n; ++_iter_##n)\n#define stp(i, a, b, c) for (int i = (a); i < (b); i += (c))\n#define FOR(x, cont) for (const auto &x: cont)\n#define INC(init, x, y) for (init; x <= y; ++x)\n#define For(x, cont) for (auto &x: cont)\n#define all(x) begin(x), end(x)\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define SZ(x) (int)(x).size()\n#define UP(i, l, r) for(i = decltype(i)(l); i <= decltype(i)(r); ++i)\n#define DOWN(i, r, l) for (i = decltype(i)(r); i >= decltype(i)(l); --i)\n#define Dec(a, b) for (; a >= b; --a)\ntemplate <typename T, typename Comp = less<T>>\nusing pq = priority_queue<T, vector<T>, Comp>;\n#define popcnt(x) __builtin_popcountll((x))\n#define SET(arr, v) memset(arr, (v), sizeof (arr))\n#define UNIQ(vec) (vec).erase(unique(all(vec)), end(vec))\n#define LB(cont, x) int(lower_bound(all(cont), x) - begin(cont))\n#define UB(cont, x) int(upper_bound(all(cont), x) - begin(cont))\n#define AI(name, n, m) vv<int> name(n, vi(m));\n#define AL(name, n, m) vv<ll> name(size_t(n), vl(size_t(m)));\n#define set0(arr) memset(arr, 0, sizeof arr)\n#define set1(arr) memset(arr, -1, sizeof arr)\n#define AT(T, n, m, a)  vector<vector<T>> a(n, vector<T>(m))\nconst int dx[] = {0, 0, -1, 1}, dy[] = {-1, 1, 0, 0};\nauto bet = [](const ll x, const ll y, const ll i) {\n    return x <= i && i <= y;\n};\n\ntemplate<typename T1, typename T2>\nT1 ceil(T1 x, T2 y) { // y >= 1，是整数。需要注意 x + y - 1 是否会溢出\n    return (x + y - 1) / y;\n}\n\ninline int h_bit(unsigned long long x) {\n    return (int)sizeof(unsigned long long) * 8 - 1 - __builtin_clzll(x);\n}\n\nint pow2(int x){ // power of 2\n    return int(1U << h_bit((ull)x)) + (x != lowbit(x));\n}\n\ntemplate <typename T>\nstruct BIT {\n    vector<T> a;\n    function<T(T,T)> bin_op;\n    const T init;\n    explicit BIT(int n, function<T(T,T)> bin_op, T init):bin_op(bin_op), init(init) {\n        a.assign(n + 1, init);\n    }\n\n    T prefix(int x) {\n        auto res = init;\n        while (x) {\n            res = bin_op(a[x], res);\n            x -= x & -x;\n        }\n        return res;\n    }\n    void modify(int x, T v) {\n        while (x < (int)a.size()) {\n            a[x] = bin_op(a[x], v);\n            x += x & -x;\n        }\n    }\n    void clear(){\n        fill(a.begin(), a.end(), init);\n    }\n};\n\nvi get_prime(int n) {\n    vi minp((ul) n + 1), p;\n    for (int i = 2; i <= n; i++) {\n        if (!minp[i]) {\n            minp[i] = i;\n            p.pb(i);\n        }\n        FOR(x, p) {\n            if (x <= minp[i] && x * i <= n)\n                minp[x * i] = x;\n            else break;\n        }\n    }\n    return p;\n}\n\n// alias templates\ntemplate<typename T> using vv = vector<vector<T>>;\ntemplate <typename T1, typename T2 = T1> using vp = vector<pair<T1,T2>>;\ntemplate<typename T, int n> using va = vector<array<T,n>>;\n\n//order_of_key (k) : Number of items strictly smaller than k .\n//find_by_order(k) : K-th element in a set (counting from zero).\n#ifdef __GNUC__\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\ntemplate <typename T>\nusing rank_tree = __gnu_pbds::tree<\n        T,\n        __gnu_pbds::null_type,\n        less<T>,\n        __gnu_pbds::rb_tree_tag,\n        __gnu_pbds::tree_order_statistics_node_update>;\n#endif\n\n//union-find 并查集\nstruct UF {\n    vi par, sz;\n    int n_tree;\n    explicit UF(int n) { //0-indexed\n        par.assign(n, 0);\n        sz.assign(n, 1);\n        rng (i, 0, n) par[i] = i;\n        n_tree = n;\n    }\n    int n_cluster() const {\n        return n_tree;\n    }\n    int size(int x) {\n        return sz[root(x)];\n    }\n    int root(int x) {\n        return x == par[x] ? x : par[x] = root(par[x]);\n    }\n    bool unite(int x, int y) {\n        int rx = root(x), ry = root(y);\n        if(rx != ry) {\n            par[rx] = ry;\n            --n_tree;\n            sz[ry] += sz[rx];\n            return true;\n        }\n        return false;\n    }\n};\n\ntemplate<typename T, typename Compare = std::less<T>>\nstruct SparseTable {\n    size_t n{}; // 0-indexed\n    vv<T> a;\n\n    template<typename ptr_t>\n    SparseTable(ptr_t beg, ptr_t end):n(end - beg) {\n        a.resize((size_t) h_bit(n) + 1); // 注意：不能写成 h_bit(n)\n        a[0].assign(beg, end);\n        rng (i, 0, SZ(a) - 1) {\n            a[i + 1].resize(n);\n            rng(j, 0, n - (1u << i)) {\n                a[i + 1][j] = min(a[i][j], a[i][j + (1u << i)], Compare());\n            }\n            rng(j, n - (1u << i), n) {\n                a[i + 1][j] = a[i][j];\n            }\n        }\n    }\n    using idx_t = long;\n    T query(idx_t l, idx_t r) { // l <=  r\n        int i = h_bit(r - l + 1ul);\n        return min(a[i][l], a[i][r + 1 - (1u << i)], Compare());\n    }\n};\n\nvi get_popcnt(int n) {\n    vi res((ul)n + 1);\n    rng (i, 0, n) {\n        if (i * 2 <= n) res[i * 2] = res[i];\n        if ((i & 1) == 0) res[i + 1] = res[i] + 1;\n    }\n    return res;\n}\n\nvi get_mu(int n) {\n    assert(n > 0);\n    vi mu(n + 1);\n    vi min_p(n + 1);\n    vi prime;\n    mu[1] = 1;\n    rng (i, 2, n + 1) {\n        if (!min_p[i]) {\n            prime.pb(i);\n            min_p[i] = i;\n            mu[i] = -1;\n        }\n        FOR (p, prime) {\n            if (p > min_p[i]) {\n                break;\n            }\n            int t = p * i;\n            if (t > n) break;\n            min_p[t] = p;\n            mu[t] = p == min_p[i] ? 0 : -mu[i];\n        }\n    }\n    return mu;\n}\n\ntemplate<typename num>\nnum fp(num x, ll n, int mod) { //fast power: hat off to quailty\n    if (n < 0) {\n        x = inverse(x, mod);\n        n = -n;\n    }\n    num ans = 1;\n    while (n) {\n        if (n & 1) ans *= x;\n        n /= 2;\n        x *= x;\n    }\n    return ans;\n}\n\n// debug code by tourist\nstring to_string(const string& s) {\n    return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n    return to_string((string) s);\n}\n\nstring to_string(bool b) {\n    return (b ? \"true\" : \"false\");\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n    return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\ntemplate <typename A>\nstring to_string(A v) {\n    bool first = true;\n    string res = \"{\";\n    for (const auto &x : v) {\n        if (!first) {\n            res += \", \";\n        }\n        first = false;\n        res += to_string(x);\n    }\n    res += \"}\";\n    return res;\n}\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n    cerr << \" \" << to_string(H);\n    debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n// end DEBUG\n\ntemplate <typename T>\nstruct Binom {\n    vector<T> f;\n    explicit Binom(int n) {\n        f.resize(n + 1);\n        f[0] = 1;\n        up (i, 1, n) f[i] = f[i - 1] * i;\n    }\n    T get_binom(int x, int y) const {\n        assert(x <= SZ(f) - 1);\n        assert(x >= 0 && y >= 0);\n        if (x < y) return 0;\n        return f[x] / (f[y] * f[x - y]);\n    }\n    T get_fact(int n) const {\n        assert(n < SZ(f));\n        return f[n];\n    }\n};\n\n//https://codeforces.com/blog/entry/22072\nstruct HLD {\n    HLD(int n, const int *heavy_son, const int *fa, const int *depth) : top(n + 1), pos(n + 1), depth(depth), fa(fa) {\n        int index = 0;\n        // 节点编号从1开始\n        for (int i = 1; i <= n; i++) {\n            if (i != heavy_son[fa[i]]) {\n                for (int j = i; j != 0; j = heavy_son[j]) {\n                    top[j] = i;\n                    pos[j] = ++index; // pos从1开始\n                }\n            }\n        }\n    }\n\n    template<typename BinOpr>\n    //返回值是 LCA(u,v)\n    int process_path(int u, int v, BinOpr op, bool value_on_edge = false) const {\n        while (top[u] != top[v]) {\n            if (depth[top[u]] < depth[top[v]]) swap(u, v);\n            op(pos[top[u]], pos[u]);\n            u = fa[top[u]];\n        }\n        if (depth[u] > depth[v]) swap(u, v);\n        op(pos[u] + value_on_edge, pos[v]);\n        return u;\n    }\n\n    vector<int> top, pos;\n    const int *depth, *fa;\n};\n\ntemplate <typename T>\nT get_mid(T l, T r) {\n    assert(l <= r);\n    return l + (r - l) / 2;\n}\ntemplate <typename T>\nint get_bit(T a, int i) {\n    return a >> i & 1;\n}\n/*\nusing ModType = int;\n\nstruct VarMod { static ModType value; };\nModType VarMod::value;\nModType& md = VarMod::value;\nusing Mint = Modular<VarMod>;\n */\nconstexpr int md = 998244353;\nusing Mint = Modular<std::integral_constant<decay<decltype(md)>::type, md>>;\n//////////////////^\"^///////////////////////////////////\nclass MCMF {\n    struct arc {\n        const int to, next, cost;\n        mutable int cap;\n    };\n    const int n_node;\n    vi head;\n    vector<arc> e;\n\n    mutable vl d;\n    bool dijkstra(int s, int t) const {\n        const int inf = 10000;\n        d.assign(n_node, inf);\n        pq<pii, greater<pii>> que;\n        que.push({d[s] = 0, s});\n        while (!que.empty()) {\n            auto top = que.top();\n            que.pop();\n            int u = top.second;\n            if (d[u] != top.first) continue;\n            for (int i = head[u]; i != -1; i = e[i].next) {\n                int v = e[i].to;\n                if (e[i].cap > 0 && d[v] > d[u] + e[i].cost) {\n                    d[v] = d[u] + e[i].cost;\n                    que.push({d[v], v});\n                }\n            }\n        }\n        return d[t] < inf;\n    }\n    mutable vi cur;\n    mutable vb vis;\n    int dfs(int u, int flow, int t) const {\n        if (u == t) return flow;\n        vis[u] = true; // \"vis[u] = true;\" 不能写在 \"if (u == t) return flow;\" 之前！\n        int pushed = 0;\n        for (int &i = cur[u]; i != -1; i = e[i].next) {\n            int v = e[i].to;\n            if (!vis[v] && e[i].cap && d[v] == d[u] + e[i].cost) {\n                int tmp = dfs(v, min(flow - pushed, e[i].cap), t);\n                if (tmp) {\n                    e[i].cap -= tmp;\n                    e[i ^ 1].cap += tmp;\n                    pushed += tmp;\n                    if (flow == pushed) break;\n                }\n            }\n        }\n        vis[u] = false;\n        return pushed;\n    }\npublic:\n    explicit MCMF(int n_node) : n_node(n_node) {\n        head.assign(n_node, -1);\n    }\n    void add_arc(int u, int v, int cost, int cap) {\n        e.pb({v, head[u], cost, cap});\n        head[u] = SZ(e) - 1;\n        e.pb({u, head[v], -cost, 0});\n        head[v] = SZ(e) - 1;\n    }\n    ll mcmf(int s, int t) const {\n        ll ans = 0;\n        vis.assign(n_node, false);\n        while (dijkstra(s, t)) {\n            cur = head;\n            while (true) {\n                int f = dfs(s, INT_MAX, t);\n                if (f) ans += f * d[t];\n                else break;\n            }\n        }\n        return ans;\n    }\n};\n\nint main() {\n#ifdef LOCAL\n    ifstream in(\"main.in\");\n    cin.rdbuf(in.rdbuf());\n//    ofstream out(\"main.out\");\n//    cout.rdbuf(out.rdbuf());\n#endif\n// 先取每一行的最大者，再取某一列的最大者。错的！有反例、\n// 最小费用最大流\nint n, h, w;\nscan(n, h, w);\n\n\nint n_node = n + h + w + 2;\nint s = 0, t = n_node - 1;\nMCMF g(n_node);\n\nup (i, 1, n) {\n    int r, c, a;\n    scan(r, c, a);\n    g.add_arc(s, i, -a, 1);\n    g.add_arc(i, n + r, 0, 1);\n    g.add_arc(i, n + h + c, 0, 1);\n}\nup (i, 1, h) {\n    g.add_arc(n + i, t, 0, 1);\n}\nup (i, 1, w) {\n    g.add_arc(n + h + i, t, 0, 1);\n}\n\nprintln(-g.mcmf(s, t));\n\n\n#ifdef LOCAL\n    cout << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#include <fstream>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n\n#define LLINF 1e18+7\n#define N 250000\nll MOD=1e9+7;\n\n\nint G[600][600];\n\nstruct UnionFind{\n    vector<int> par,sizes;\n    UnionFind(int n):par(n+1),sizes(n+1,1){\n        rep2(i,1,n)par[i]=i;\n    }\n    int find(int x){\n        return (x==par[x]?x:par[x]=find(par[x]));\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return ;\n        if(sizes[x]<sizes[y]){\n            swap(x,y);\n        }\n        par[y]=x;\n        sizes[x]+=sizes[y];\n    }\n    bool same(int x,int y) {return (find(x)==find(y));}\n    int size(int x) {return sizes[find(x)];}\n};\nmain(){\n    int n=in();\n    int h=in(),w=in();\n    UnionFind uf(h+w+10);\n    vector<pair<ll,pii>> v;\n    rep(i,n){\n        int r=in(),c=in(),a=in();\n        v.pb({a,{r,c+h}});\n        uf.unite(r,c+h);\n    }\n    vector<vector<pair<ll,pii>>> W(h+w+10);\n    vec t;\n    rep(i,n){\n        int s=uf.find(v[i].second.first);\n        W[s].pb(v[i]);\n        t.pb(s);\n        //cout<<s<<endl;\n    }\n    sort(all(t));\n    ll ans=0;\n    t.erase(unique(all(t)),t.end());\n    UnionFind uf2(h+w+10);\n    vec used(h+w+10);\n    for(auto e:t){\n        sort(all(W[e]),greater<pair<ll,pii>>());\n        rep(i,W[e].size()){\n            //cout<<W[e][i].first<<\" \"<<W[e][i].second.first<<W[e][i].second.second<<endl;\n            if(!uf2.same(W[e][i].second.first,W[e][i].second.second)){\n                if(used[uf2.find(W[e][i].second.first)]&&used[uf2.find(W[e][i].second.second)]){\n                    continue;\n                }\n                bool a=0;\n                if(used[uf2.find(W[e][i].second.first)]||used[uf2.find(W[e][i].second.second)]){\n                    a=1;\n                }\n                uf2.unite(W[e][i].second.first,W[e][i].second.second);\n                if(a)used[uf2.find(W[e][i].second.first)]=1;\n                ans+=W[e][i].first;\n            }\n            else{\n                if(!used[uf2.find(W[e][i].second.second)]){\n                    used[uf2.find(W[e][i].second.second)]=1;\n                    ans+=W[e][i].first;\n                }\n            }\n\n        }\n\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define WHOLE(v) (v).begin(), (v).end()\n#define REV_WHOLE(v) (v).rbegin(), (v).rend()\nusing i64 = int64_t;\nusing namespace std;\ntemplate<size_t I,class H,class...T>struct TupleReaderWriter{static tuple<H,T...> r(istream&i){H v;i>>v;return tuple_cat(tuple<H>(v),TupleReaderWriter<sizeof...(T)-1,T...>::r(i));}static void w(ostream&o,tuple<H,T...>&t,string d){TupleReaderWriter<I-1,H,T...>::w(o,t,d);o<<d<<get<I>(t);}};\ntemplate<class H,class...T>struct TupleReaderWriter<0,H,T...>{static tuple<H,T...> r(istream&i){H v;i>>v;return tuple<H>(v);}static void w(ostream&o,tuple<H,T...>&t,string d){o<<get<0>(t);}};\ntemplate<class...T>istream&operator>>(istream&i,tuple<T...>&t){t=TupleReaderWriter<sizeof...(T),T...>::r(i);return i;}\ntemplate<class...T>ostream&operator<<(ostream&o,tuple<T...>&t){string delim=\" \";TupleReaderWriter<sizeof...(T)-1,T...>::w(o,t,delim);return o;}\ntemplate<class T>istream&operator>>(istream&i,vector<T>&v){for(auto&x:v)i>>x;return i;}\ntemplate<class T>ostream&operator<<(ostream&o,vector<T>&v){string delim=\"\";for(auto&x:v)o<<delim<<x,delim=\" \";return o;}\ntemplate<class T>using rev_priority_queue=priority_queue<T,vector<T>,greater<T>>;\ntemplate<class T>using vector2d=vector<vector<T>>;\nstruct fixprec{int x;fixprec(int d):x(d){}};\nostream&operator<<(ostream&o,fixprec f){return o<<fixed<<setprecision(f.x);}\nvoid R_YESNO(bool p) { cout << (p ? \"YES\" : \"NO\") << endl; }\nvoid R_YesNo(bool p) { cout << (p ? \"Yes\" : \"No\") << endl; }\n/*!* [union_find] *!*/\n/*+* UnionFind 木 *+*/\n// T (typename) : グラフの頂点を表す型, (int)parent を持つ必要あり\ntemplate <typename T>\nstruct UnionFind {\n    vector<T> &u;\n    UnionFind(vector<T> &u) : u(u) {\n        for (int i = 0; i < u.size(); i++) {\n            u[i].parent = i;\n        }\n    }\n    int root(int x) {\n        if (x < 0 || u.size() <= x) return -1;\n        else if (x == u[x].parent) return x;\n        else return u[x].parent = root(u[x].parent);\n    }\n    bool connect(int a, int b) {\n        a = root(a), b = root(b);\n        if(a == b) {\n            if(u[b].e + 1 > u[b].v) {\n                return false;\n            }\n            u[b].e++;\n        } else {\n            if(u[a].e + u[b].e + 1 > u[a].v + u[b].v) {\n                return false;\n            }\n            u[b].parent = a;\n            u[a].e += u[b].e + 1;\n            u[a].v += u[b].v;\n        }\n        return true;\n    }\n};\nusing Data = tuple<i64, i64, i64>;\nstruct Node {\n    int parent;\n    int e;\n    int v;\n};\nint main() {\n    int N, H, W;\n    cin >> N >> H >> W;\n    vector<Node> node(H + W, {0, 0, 1});\n    vector<Data> A(N);\n    UnionFind<Node> uf(node);\n    for(auto &x : A) {\n        i64 r, c, a;\n        cin >> r >> c >> a;\n        r--, c--;\n        x = make_tuple(a, r, H + c);\n    }\n    i64 ans = 0;\n    sort(REV_WHOLE(A));\n    for(auto x : A) {\n        i64 a, r, c;\n        tie(a, r, c) = x;\n        ans += uf.connect(r, c) ? a : 0;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=2e5+5;\nstruct node{\n    int r,c,a;\n    friend bool operator<(node a,node b){\n        return a.a>b.a;\n    }\n}st[maxn];\nint fa[maxn],S[maxn],T[maxn];\nint n,H,W;\nint init(){\n    for(int i=1;i<=H+W;i++){\n        fa[i]=i;\n        T[i]=1;\n    }\n}\nint find(int x){\n    return x==fa[x]?x:fa[x]=find(fa[x]);\n}\nint main(){\n    cin>>n>>H>>W;\n    init();\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%d\",&st[i].r,&st[i].c,&st[i].a);\n    }\n    sort(st+1,st+1+n);\n    ll ans=0;\n    for(int i=1;i<=n;i++){\n//        printf(\"%d %d %d\\n\",st[i].r,st[i].c,st[i].a);\n        int fr=find(st[i].r),fc=find(H+st[i].c);\n        if(fr==fc){//两个在同一集合内\n            if(T[fc]>=S[fc]+1){\n                S[fc]++;\n                ans=ans+st[i].a;\n            }\n        }\n        else{//两个不在同一集合内，要合并\n            if(T[fr]+T[fc]>=S[fr]+S[fc]+1){\n                fa[fr]=fc;\n                T[fr]+=T[fc];\n                S[fr]=S[fr]+S[fc]+1;\n                ans=ans+st[i].a;\n            }\n        }\n    }\n    printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define rrep(i,a,b) for(int i=(a);i>=(b);--i)\n#define MP make_pair\n#define PB push_back\n#define PII pair<int,int>\ntypedef long long LL;\nconst LL P = 1e9+7;\nconst LL INF = 1e12;\nconst int N = 3e5+5;\nconst double pi = acos(-1);\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nint n,h,w,a[N],x[N],y[N],rm[N],cm[N],use[N];\nvector<int> r[N],c[N];\n \nint main(){\n\tscanf(\"%d%d%d\",&n,&h,&w);\n\trep(i,1,n){\n\t\tscanf(\"%d%d%d\",&x[i],&y[i],a+i);\n\t\tr[x[i]].PB(i), c[y[i]].PB(i);\n\t}\n\tmemset(rm,0,sizeof rm);\n\tmemset(cm,0,sizeof cm);\n\ta[0] = 0;\n\trep(i,1,h){\n\t\tfor(auto u:r[i]) if(a[u]>a[rm[i]]) rm[i] = u;\n\t\tif(rm[i])use[rm[i]]++;\n\t}\n\trep(i,1,w){\n\t\tfor(auto u:c[i]) if(a[u]>a[cm[i]]) cm[i] = u;\n\t\tif(cm[i])use[cm[i]]++;\n\t}\n\trep(i,1,n)if(use[i]>1){\n\t\tint j = 0;\n\t\tfor(auto u:r[x[i]]) if(!use[u] && a[u]>a[j]) j = u;\n\t\tfor(auto u:c[y[i]]) if(!use[u] && a[u]>a[j]) j = u;\n\t\tuse[i]--, use[j]++;\n\t}\n\tLL ans = 0;\n\trep(i,1,n) if(use[i]) ans += 1ll * a[i];\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nvoid solve()\n{\n    int n, h, w;\n    cin >> n >> h >> w;\n    vector<pair<int, int>> hs[h], ws[w];\n    vector<int> used(n);\n    for (int i = 0; i < n; i++)\n    {\n        int y, x, a;\n        cin >> y >> x >> a;\n        hs[y - 1].push_back(make_pair(a, i));\n        ws[x - 1].push_back(make_pair(a, i));\n    }\n    long ans = 0, ans2 = 0;\n    for (int x = 0; x < w; x++)\n    {\n        if (ws[x].empty())\n            continue;\n        sort(ws[x].rbegin(), ws[x].rend());\n        for (auto &p : ws[x])\n        {\n            if (used[p.second])\n                continue;\n            ans += p.first;\n            used[p.second] = 1;\n            break;\n        }\n    }\n    for (int y = 0; y < h; y++)\n    {\n        if (hs[y].empty())\n            continue;\n        sort(hs[y].rbegin(), hs[y].rend());\n        for (auto &p : hs[y])\n        {\n            if (used[p.second])\n                continue;\n            ans += p.first;\n            used[p.second] = 1;\n            break;\n        }\n    }\n    fill(used.begin(), used.end(), 0);\n    for (int y = 0; y < h; y++)\n    {\n        if (hs[y].empty())\n            continue;\n        sort(hs[y].rbegin(), hs[y].rend());\n        for (auto &p : hs[y])\n        {\n            if (used[p.second])\n                continue;\n            ans2 += p.first;\n            used[p.second] = 1;\n            break;\n        }\n    }\n    for (int x = 0; x < w; x++)\n    {\n        if (ws[x].empty())\n            continue;\n        sort(ws[x].rbegin(), ws[x].rend());\n        for (auto &p : ws[x])\n        {\n            if (used[p.second])\n                continue;\n            ans2 += p.first;\n            used[p.second] = 1;\n            break;\n        }\n    }\n    ans = max(ans, ans2);\n    cout << ans << endl;\n}\n\nint main()\n{\n    solve();\n    cerr << \"\\\"努力不足ですね！\\\"\" << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <functional>\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<ll, P> PP;\n\ntemplate <typename S>   //semi group\nstruct UnionFind\n{\n    using F = function<S(S, S)>;\n    \n    const F f;\n    \n    vector<int> par, rank;\n    vector<S> dat;\n    \n    UnionFind(int n, const F f = [](S a, S b){return a + b;}, const S e = 1) : f(f){\n        par.resize(n);\n        rank.resize(n);\n        dat.assign(n, e);\n        for(int i = 0; i < n; i++){\n            par[i] = i;\n            rank[i] = 0;\n        }\n    }\n    \n    int find(int i){\n        if(i == par[i]) return i;\n        return par[i] = find(par[i]);\n    }\n    \n    bool same(int i, int j){\n        return find(i) == find(j);\n    }\n    \n    void unite(int i, int j){\n        if(same(i, j)) return;\n        i = find(i), j = find(j);\n        if(rank[i] < rank[j]){\n            par[i] = j;\n            dat[j] = f(dat[i], dat[j]);\n        }\n        else{\n            par[j] = i;\n            dat[i] = f(dat[i], dat[j]);\n            if(rank[i] == rank[j]) rank[i]++;\n        }\n    }\n    \n    S query(int i){\n        return dat[find(i)];\n    }\n};\n\nint main()\n{\n    int n, h, w;\n    cin >> n >> h >> w;\n    PP p[100005];\n    for(int i = 0; i < n; i++){\n        int r, c;\n        ll a;\n        cin >> r >> c >> a;\n        r--; c--;\n        p[i] = PP(a, P(r, c));\n    }\n    sort(p, p + n, greater<PP>());\n    int x[100005], y[100005];\n    for(int i = 0; i < h; i++) x[i] = -1;\n    for(int i = 0; i < w; i++) y[i] = -1;\n    UnionFind<P> uf(n, [](P a, P b){return P(a.first + b.first, a.second + b.second);}, P(1, 1));\n    ll ans = 0;\n    for(int i = 0; i < n; i++){\n        int u = p[i].second.first, v = p[i].second.second;\n        ans += p[i].first;\n        if(x[u] == -1 && y[v] == -1){\n            uf.dat[i].second++;\n            x[u] = i;\n            y[v] = i;\n        }\n        else if(x[u] == -1){\n            uf.unite(i, y[v]);\n            x[u] = i;\n        }\n        else if(y[v] == -1){\n            uf.unite(i, x[u]);\n            y[v] = i;\n        }\n        else{\n            int l = uf.find(x[u]);\n            int r = uf.find(y[v]);\n            if(uf.dat[l].first + uf.dat[r].first < uf.dat[l].second + uf.dat[r].second){\n                uf.unite(i, x[u]);\n                uf.unite(i, y[v]);\n                int w = uf.find(i);\n                uf.dat[w].second--;\n            }\n            else{\n                ans -= p[i].first;\n            }\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// Code by H~$~C\n#warning \"Code by H~$~C, don't copy it!\"\n#pragma comment(linker, \"/STACK:1024000000,1024000000\")\n#pragma GCC optimize(\"Ofast\", \"unroll-loops\")\n#pragma target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,avx2,tune=native\")\n\n#define _CRT_SECURE_NO_WARNINGS\n#include <bits/stdc++.h> // assume the OJ isn't POJ\n#define __str__(...) #__VA_ARGS__\n#define __cat__(x, y) x##y\n#define rint register int\n#define rep(i, n) for (rint i = 0; i < (n); ++i)\n#define rep1(i, n) for (rint i = (1); i <= (n); ++i)\n#define Rep(i, a, b) for (rint i = (a); i <= (b); ++i)\n#define per(i, n) for (rint i = ((n) - 1); ~i; --i)\n#define per1(i, n) for (rint i = (n); i; --i)\n#define Per(i, a, b) for (rint i = (a); i >= (b); --i)\n#define repit(it, a) for (__typeof(a.begin()) it = a.begin(); it != a.end(); ++it)\n#define eprintf(...) (fprintf(stderr, __VA_ARGS__) & fflush(stderr))\n#define fillset(a, val) memset(a, val, sizeof(a))\n#define All(a) a.begin(), a.end()\n#define SZ(a) ((int)a.size())\n#define fi first\n#define se second\n#define pb push_back\n#define pf push_front\n#define y0 y19260817\n#define y1 y19268107\n#define j0 j19260817\n#define j1 j19268107\n#define x0 x19260817\n#define x1 x19268107\nusing namespace std;\n#ifndef LOCAL_JUDGE\n#define Debug(...)\n#else\ntemplate <typename T> inline void _debug(const char *names, T &&t) {\n(cerr << names << \" = \" << t << endl).flush();}\ntemplate <typename T1, typename ...T>\ninline void _debug(const char *names, T1 &&t1, T &&... t) {\nconst char *comma = strchr(names, ',');\n(cerr.write(names, comma - names) << \" = \" << t1 << \", \").flush();\n_debug(comma + 1, t ...);}\n#define Debug(...) _debug(#__VA_ARGS__, __VA_ARGS__)\n#endif\nstruct __STARTER_OF_PROGRAM__ { __STARTER_OF_PROGRAM__() {\n  cerr << \"Code by H~$~C: \\n\" << flush;\n  ios_base::sync_with_stdio(false);\n  cin.tie(nullptr), cout.tie(nullptr);\n  cout << fixed << setprecision(12);\n} } __starter_of_program__;\n#ifndef ONLINE_JUDGE\nstruct __ENDDER_OF_PROGRAM__ { ~__ENDDER_OF_PROGRAM__() {\n  cerr << \"\\n\\nTime elasped: \" << clock() * 1000.0 / CLOCKS_PER_SEC << \" ms\\n\" << flush;\n} } __endder_of_program__;\n#endif\n\ntemplate <typename T> using min_queue = priority_queue <T, vector <T>, greater <T> >;\ntemplate <typename T> using max_queue = priority_queue <T>;\nmt19937 gen(chrono::steady_clock::now().time_since_epoch().count());\nstatic uniform_int_distribution <int> __disint__;\ninline int randint(void) { return __disint__(gen); }\ninline int randint(int l, int r) { return __disint__(gen) % (r - l + 1) + l; }\ntemplate <typename T> inline void reinit(T &t) { t.~T(); new (&t) T(); }\ntemplate <typename T> inline T chmax(T &x, T y) { return x = max(x, y); }\ntemplate <typename T> inline T chmin(T &x, T y) { return x = min(x, y); }\ntemplate <typename T> inline T chmax(T &x, initializer_list <T> i) { return x = max(x, max(i)); }\ntemplate <typename T> inline T chmin(T &x, initializer_list <T> i) { return x = min(x, min(i)); }\n\ninline void read() { } inline void write() { }\ntemplate <typename T> inline void read(T &x) { cin >> x; }\ntemplate <typename T> inline void write(const T &x) { cout << x; }\ntemplate <typename T, typename U>\ninline void write(const pair <T, U> &x) { write(x.first), cout.put(' '), write(x.second);}\ntemplate <typename T, typename U>\ninline void read(pair <T, U> &x) { read(x.first), read(x.second);}\ntemplate <typename T, typename ...Ts> inline void read(T &x, Ts &...y) { read(x), read(y...); }\ntemplate <typename T, typename ...Ts> inline void write(const T &x, const Ts &...y) {\nwrite(x), cout.put(' '), write(y...); }\ntemplate <typename T, typename ...Ts>\ninline void writen(const T &x, const Ts &...y) { write(x), write(y...); }\n#define writeln(...) (write(__VA_ARGS__), cout.put('\\n'), 0)\n#define writenln(...) (writen(__VA_ARGS__), cout.put('\\n'), 0)\ntemplate <typename It> inline void _write(It a, It b) {\nregister char flag = 0; while (a != b) { flag && (cout.put(' '), 0); write(*a++), flag = 1; } }\n#define _writeln(...) (_write(__VA_ARGS__), cout.put('\\n'), 0)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef pair <ll, int> pli;\ntypedef pair <int, ll> pil;\nconst double EPS = 1e-9, PI = acos(-1.0);\nconst int inf = 0x3f3f3f3f;\nconst ll lnf = 0x3f3f3f3f3f3f3f3f;\n\nint n, r, c;\nstruct Edge {\n  int u, v;\n  ll w;\n  inline void read() {\n    ::read(u, v, w), v += r;\n  }\n  friend bool operator < (const Edge &x, const Edge &y) {\n    return x.w > y.w;\n  }\n} e[100005];\nint par[200005], sz[200005], flag[200005];\nint fnd(int x) { return par[x] == x ? x : par[x] = fnd(par[x]); }\ninline bool unite(int u, int v) {\n  u = fnd(u), v = fnd(v);\n  if (v == u) return flag[v] ? false : flag[v] = true;\n  if (flag[v] && flag[u]) return false;\n  if (sz[v] < sz[u]) swap(v, u);\n  sz[v] += sz[u], flag[v] |= flag[u], par[u] = v;\n  return true;\n}\n\nll ans;\nint main(int argc, const char *argv[]) {\n  read(n, r, c);\n  rep1(i, n) e[i].read();\n  sort(e + 1, e + n + 1);\n  rep1(i, r + c) par[i] = i, sz[i] = 1, flag[i] = 0;\n  rep1(i, n) if (unite(e[i].u, e[i].v)) ans += e[i].w;\n  writeln(ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mem(s,t) memset(s,t,sizeof(s))\n#define pb(s) push_back(s)\n#define inf 0x3f3f3f3f\n#define mn 100010\ntypedef long long ll;\nusing namespace std;\nconst int maxn=300010;\nconst ll INF=inf;\nstruct edge {\n\tll to, capacity, cost, rev;\n\tedge() {}\n\tedge(ll to, ll _capacity, ll _cost, ll _rev) :to(to), capacity(_capacity), cost(_cost), rev(_rev) {}\n};\nstruct Min_Cost_Max_Flow {\n\tll V, H[maxn + 5], dis[maxn + 5], PreV[maxn + 5], PreE[maxn + 5];\n\tvector<edge> G[maxn + 5];\n\t//调用前初始化\n\tvoid Init(int n) {\n\t\tV = n;\n\t\tfor (int i = 0; i <= V; ++i)G[i].clear();\n\t}\n\t//加边\n\tvoid Add_Edge(int from, int to, int cap, ll cost) {\n\t\tG[from].push_back(edge(to, cap, cost, G[to].size()));\n\t\tG[to].push_back(edge(from, 0, -cost, G[from].size() - 1));\n\t}\n\t//flow是自己传进去的变量，就是最后的最大流，返回的是最小费用\n\tint Min_cost_max_flow(int s, int t, ll f, ll& flow) {\n\t\tll res = 0; fill(H, H + 1 + V, 0);\n\t\twhile (f) {\n\t\t\tpriority_queue <pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > q;\n\t\t\tfill(dis, dis + 1 + V, INF);\n\t\t\tdis[s] = 0; q.push(pair<int, int>(0, s));\n\t\t\twhile (!q.empty()) {\n\t\t\t\tpair<int, int> now = q.top(); q.pop();\n\t\t\t\tint v = now.second;\n\t\t\t\tif (dis[v] < now.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\t\t\t\tedge& e = G[v][i];\n\t\t\t\t\tif (e.capacity > 0 && dis[e.to] > dis[v] + e.cost + H[v] - H[e.to]) {\n\t\t\t\t\t\tdis[e.to] = dis[v] + e.cost + H[v] - H[e.to];\n\t\t\t\t\t\tPreV[e.to] = v;\n\t\t\t\t\t\tPreE[e.to] = i;\n\t\t\t\t\t\tq.push(pair<int, int>(dis[e.to], e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dis[t] == INF)break;\n\t\t\tfor (int i = 0; i <= V; ++i)H[i] += dis[i];\n\t\t\tll d = f;\n\t\t\tfor (int v = t; v != s; v = PreV[v])d = min(d, G[PreV[v]][PreE[v]].capacity);\n\t\t\tf -= d; flow += d; res += d*H[t];\n\t\t\tfor (int v = t; v != s; v = PreV[v]) {\n\t\t\t\tedge& e = G[PreV[v]][PreE[v]];\n\t\t\t\te.capacity -= d;\n\t\t\t\tG[v][e.rev].capacity += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n}MCMF;\nint flow=0;\nint main()\n{\n    int n,h,w;\n    scanf(\"%d%d%d\",&n,&h,&w);\n    int S=n+h+w+1;\n    int T=S+1;\n    MCMF.Init(T+1);\n    for(int i=0;i<n;++i){\n        int r,c,a;\n        scanf(\"%d%d%d\",&r,&c,&a);\n        MCMF.Add_Edge(S,i,1,-a);\n        MCMF.Add_Edge(i,n+r,1,0);\n        MCMF.Add_Edge(i,n+h+c,1,0);\n    }\n    for(int i=n+1;i<=n+h+w;++i){\n        MCMF.Add_Edge(i,T,1,0);\n    }\n    ll fl=0;\n    ll ans=-MCMF.Min_cost_max_flow(S,T,inf,fl);\n    printf(\"%lld\\n\",ans);\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\n// Verified: AOJ-DSL1A\nclass UFSet {\n private:\n  vector<int> ranks;\n  vector<int> prevs;\n\n public:\n  UFSet(int n) : ranks(n), prevs(n) {\n    for (int i = 0; i < n; i++) prevs[i] = i;\n  }\n\n  // Returns a root of a tree which x belongs to.\n  int Find(int x) {\n    if (x != prevs[x]) prevs[x] = Find(prevs[x]);\n    return prevs[x];\n  }\n\n  // Merges a set which x blongs to and a set which y belongs to.\n  void Union(int x, int y) {\n    int x_root = Find(x);\n    int y_root = Find(y);\n    if (ranks[x_root] > ranks[y_root]) {\n      prevs[y_root] = prevs[x_root];\n    } else if (ranks[x_root] < ranks[y_root]) {\n      prevs[x_root] = prevs[y_root];\n    } else if (prevs[x_root] != prevs[y_root]) {\n      prevs[y_root] = prevs[x_root];\n      ranks[x_root]++;\n    }\n  }\n};\n\nstruct WeightedEdge {\n  int v1, v2;\n  int64 weight;\n  WeightedEdge(int v1, int v2, int64 weight)\n      : v1(v1), v2(v2), weight(weight) {}\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, h, w;\n  cin >> n >> h >> w;\n  vector<WeightedEdge> edges;\n  for (int i = 0; i < n; i++) {\n    int r, c;\n    int64 weight;\n    cin >> r >> c >> weight;\n    r--;\n    c--;\n    edges.emplace_back(r, h + c, weight);\n  }\n  sort(edges.begin(), edges.end(), [](const auto& e1, const auto& e2) {\n    return e1.weight > e2.weight;\n  });\n\n  UFSet uf_set(h + w);\n  vector<int> has_cycle_vector(h + w);\n  int64 answer;\n  for (const auto& e : edges) {\n    int s1 = uf_set.Find(e.v1);\n    int s2 = uf_set.Find(e.v2);\n    if (s1 != s2) {\n      if (has_cycle_vector[s1] && has_cycle_vector[s2]) continue;\n      int new_has_cycle = has_cycle_vector[s1] || has_cycle_vector[s2];\n      uf_set.Union(e.v1, e.v2);\n      int s3 = uf_set.Find(e.v1);\n      has_cycle_vector[s3] = new_has_cycle;\n      answer += e.weight;\n    } else {\n      if (has_cycle_vector[s1]) continue;\n      has_cycle_vector[s1] = true;\n      answer += e.weight;\n    }\n  }\n  cout << answer << endl;\n}"
  },
  {
    "language": "C++",
    "code": "1 100000 100000\n1 1 1\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UF {\n  vector<int> p;\npublic:\n  UF(int n) : p(n) {\n    for (int i = 0; i < n; ++i) p[i] = i;\n  }\n  int root(int i) {\n    if (p[i] == i) return i;\n    return p[i] = root(p[i]);\n  }\n  bool same(int i, int j) {\n    return root(i) == root(j);\n  }\n  void unite(int i, int j) {\n    int ri = root(i);\n    int rj = root(j);\n    p[ri] = rj;\n  }\n};\n\nusing T = pair<int, pair<int, int>>;\nint n, h, w;\nvector<int> G[200000];\nbool used[200000];\nvoid rec(int from) {\n  if (used[from]) return;\n  used[from] = true;\n  for (int to : G[from]) {\n    rec(to);\n  }\n}\n\nint main() {\n  cin >> n >> h >> w;\n  priority_queue<T> Q;\n  for (int k = 0; k < n; ++k) {\n    int i, j, a;\n    cin >> i >> j >> a;\n    --i; --j;\n    j += h;\n    Q.push(T(a, make_pair(i, j)));\n  }\n  \n  bool flg = false;\n  UF uf(h + w);\n  long sum = 0;\n  while (!Q.empty()) {\n    T t = Q.top(); Q.pop();\n    int a = t.first;\n    int i = t.second.first;\n    int j = t.second.second;\n    \n    G[i].push_back(j);\n    G[j].push_back(i);\n    if (used[i] && used[j]) continue;\n    if (uf.same(i, j)) {\n      rec(i);\n    } else {\n      uf.unite(i, j);\n      if (used[i]) used[j] = true;\n      if (used[j]) used[i] = true;\n    }\n    sum += a;\n  }\n  cout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass UF {\n  vector<int> p;\n  vector<bool> namori;\npublic:\n  UF(int n) : p(n), namori(n) {\n    for (int i = 0; i < n; ++i) p[i] = i;\n  }\n  int root(int i) {\n    if (p[i] == i) return i;\n    return p[i] = root(p[i]);\n  }\n  bool same(int i, int j) {\n    return root(i) == root(j);\n  }\n  void unite(int i, int j) {\n    int ri = root(i);\n    int rj = root(j);\n    if (ri == rj) {\n      namori[ri] = true;\n      return; \n    }\n    p[ri] = rj;\n    if (namori[ri]) namori[rj] = true;\n  }\n  int is_namori(int i) {\n    return namori[root(i)];\n  }\n};\n\nusing T = pair<int, pair<int, int>>;\nint n, h, w;\nint main() {\n  cin >> n >> h >> w;\n  priority_queue<T> Q;\n  for (int k = 0; k < n; ++k) {\n    int i, j, a;\n    cin >> i >> j >> a;\n    --i; --j;\n    j += h;\n    Q.push(T(a, make_pair(i, j)));\n  }\n  \n  bool flg = false;\n  UF uf(h + w);\n  long sum = 0;\n  while (!Q.empty()) {\n    T t = Q.top(); Q.pop();\n    int a = t.first;\n    int i = t.second.first;\n    int j = t.second.second;\n    \n    if (uf.is_namori(i) && uf.is_namori(j)) continue;\n    uf.unite(i, j);\n    sum += a;\n  }\n  cout << sum << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define dbug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile ('0'>ch||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo {(t*=10)+=ch-'0';ch=getchar();} while ('0'<=ch&&ch<='9'); t*=f;\n}\ntypedef long long ll;\nconst int maxn=(2e5)+10;\nint n,m1,m2,fa[maxn],sz[maxn];\nll ans;\nstruct node {\n\tint x,y,z;\n} d[maxn];\nbool cmp(node a,node b) {\n\treturn a.z>b.z;\n}\nint find(int x) {\n\tif (fa[x]==x) return x;\n\treturn fa[x]=find(fa[x]);\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n); read(m1); read(m2);\n\tint x,y,z;\n\tfor (int i=1;i<=n;i++) {\n\t\tread(x); read(y); read(z);\n\t\td[i]=(node){x,y+m1,z};\n\t}\n\tsort(d+1,d+n+1,cmp);\n\tfor (int i=1;i<=m1+m2;i++) fa[i]=i;\n\tfor (int i=1;i<=n;i++) {\n\t\tx=d[i].x; y=d[i].y; z=d[i].z;\n\t\tx=find(x); y=find(y);\n\t\tif (x==y) {\n\t\t\tif (sz[x]) continue;\n\t\t\tsz[x]=1;\n\t\t} else {\n\t\t\tif (sz[x]&&sz[y]) continue;\n\t\t\tfa[x]=y; sz[y]|=sz[x];\n\t\t}\n\t\tans+=z;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define REP(i,n) for(ll i=0;i<n;i++)\n#define REP1(i,n) for(ll i=1;i<=n;i++)\n#define FILL(i,n) memset(i,n,sizeof i)\n#define X first\n#define Y second\n#define ET cout << \"\\n\"\n#define SZ(_a) (int)_a.size()\n#define ALL(_a) _a.begin(),_a.end()\n#define pb push_back\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#ifdef bbq\n#define debug(...) {\\\n    fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\", \";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\n#else\n#define debug(...)\n#endif\n\nvector<int> G[100005];\nint mp[100005],mq[200005],fm[100005],vis[100005],nw;\n\nbool bfs(int u)\n{\n\t++nw;\n\tqueue<int> q;\n\tq.push(u),fm[u]=-1,vis[u]=nw;\n\twhile(!q.empty())\n\t{\n\t\tint p=q.front();\n\t\tq.pop();\n\t\tfor(int i:G[p])\n\t\t\tif(!~mq[i])\n\t\t\t{\n\t\t\t\tint ls=i;\n\t\t\t\twhile(~p)\n\t\t\t\t{\n\t\t\t\t\tint tmp=mp[p];\n\t\t\t\t\tmp[mq[ls]=p]=ls,p=fm[p],ls=tmp;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(vis[mq[i]]<nw)\n\t\t\t\tq.push(mq[i]),vis[mq[i]]=nw,fm[mq[i]]=p;\n\t}\n}\n\nstruct mode\n{\n\tint r,c,v;\n\tbool operator<(const mode &a)const{\n\t\treturn v>a.v;\n\t}\n}arr[100005];\n\nint main()\n{\n\tIOS();\n\tll ans=0;\n\tint n,h,w;\n\tcin >> n >> h >> w;\n\tfor(int i=0;i<n;++i)\n\t\tcin >> arr[i].r >> arr[i].c >> arr[i].v,--arr[i].r,--arr[i].c;\n\tsort(arr,arr+n),FILL(mp,-1),FILL(mq,-1);\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tG[i].pb(arr[i].r),G[i].pb(h+arr[i].c);\n\t\tif(bfs(i))\n\t\t\tans+=arr[i].v;\n\t}\n\tcout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-5;\n\nvector<bool> valid;\nstruct uf {\nprivate:\n\tvector<int> par, ran;\npublic:\n\tuf(int n) {\n\t\tpar.resize(n, 0);\n\t\tran.resize(n, 0);\n\t\tvalid.resize(n, true);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t\tif (!valid[x])valid[y] = false;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t\tif (!valid[y])valid[x] = false;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nvoid solve() {\n\tint n, h, w; cin >> n >> h >> w;\n\tvector<int> a(n), x(n), y(n);\n\tuf u(h + w);\n\tvector<pair<int, P>> v;\n\trep(i, n) {\n\t\tcin >> x[i] >> y[i] >> a[i];\n\t\tx[i]--; y[i]--;\n\t\tv.push_back({ a[i],{x[i],y[i]} });\n\t}\n\tsort(v.begin(), v.end(), greater<pair<int, P>>());\n\tll ans = 0;\n\tvector<bool> used(n, false);\n\trep(i, v.size()) {\n\t\tint l = v[i].second.first;\n\t\tint r = v[i].second.second;\n\t\tr += h;\n\t\tif (u.same(l, r)) {\n\t\t\tint p = u.find(l);\n\t\t\tif (valid[p]) {\n\t\t\t\tans += v[i].first;\n\t\t\t\tvalid[p] = false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint pl = u.find(l);\n\t\t\tint pr = u.find(r);\n\t\t\tif (!valid[pl] && !valid[pr])continue;\n\t\t\tu.unite(l, r);\n\t\t\tans += v[i].first;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(5);\n\t//init();\n\tsolve();\n\n\t//cout << \"finish\" << endl;\n\t//stop\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// Optimization\n\n//#pragma GCC optimize(\"O3\")\n#define endl '\\n'\n\n// Shortcut\n\n#define int long long\n#define eb emplace_back\n#define pb push_back\n#define pob pop_back\n#define mp make_pair\n#define upb upper_bound\n#define lwb lower_bound\n#define fi first\n#define se second\n#define For(i, l, r) for (int i = l; i < r; i++)\n#define ForE(i, l, r) for (int i = l; i <= r; i++)\n#define Ford(i, r, l) for (int i = r; i > l; i--)\n#define FordE(i, r, l) for (int i = r; i >= l; i--)\n#define Fora(i, a) for (auto i : a)\n\n// I/O & Debug\n\n#define PrintV(a) Fora(iiii, a) cout << iiii << ' '; cout << endl;\n#define PrintVl(a) Fora(iiii, a) cout << iiii << endl;\n#define PrintA(a, l, r) for (int iiii = l; iiii <= r; iiii++) cout << a[iiii] << ' '; cout << endl;\n#define PrintAl(a, l, r) for (int iiii = l; iiii <= r; iiii++) cout << a[iiii] << endl;\n#define Ptest(x) return cout << x, 0;\n#define gl(s) getline(cin, s);\n#define setpre(x) fixed << setprecision(x)\n/*\n#define debug(args...){ string _sDEB = #args; replace(_sDEB.begin(), _sDEB.end(), ',', ' '); stringstream _ssDEB(_sDEB); istream_iterator<string> _itDEB(_ssDEB); DEB(_itDEB, args); }\nvoid DEB(istream_iterator<string> it) {}\ntemplate<typename T, typename... Args>\nvoid DEB(istream_iterator<string> it, T a, Args... args){\n    cout << *it << \" = \" << a << endl;\n    DEB(++it, args...);\n}\n*/\n\n// Functions\n\n//#define isvowel(a) (a == 'a' || a == 'e' || a == 'i' || a == 'o' || a == 'u')\n#define bend(a) a.begin(), a.end()\n#define rbend(a) a.rbegin(), a.rend()\n#define mset(a) memset(a, 0, sizeof(a))\n#define mset1(a) memset(a, 1, sizeof(a))\n#define msetn1(a) memset(a, -1, sizeof(a))\n#define msetinf(a) memset(a, 0x3f, sizeof(a))\n#define gcd __gcd\n#define __builtin_popcount __builtin_popcountll\n//mt19937 rando(chrono::steady_clock::now().time_since_epoch().count());\n\n// Data Structure\n\n#define pque priority_queue\n#define mts multiset\n#define y0 _y0_\n#define y1 _y1_\n#define div divi\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <ld> vld;\ntypedef vector <string> vs;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef vector <vi > vvi;\ntypedef vector <vll > vvll;\ntypedef vector <pii > vpii;\ntypedef vector <pll > vpll;\n\nconst int N = 2e5 + 5, mod = 1e9 + 7, mod1 = 998244353, mod2 = 1e9 + 9, inf = 1e18 + 7;\nconst ll infll = 1e18 + 7;\n\nint n, h, w, ans;\nvector <pair <int, pii>> edges;\nbool ck[N];\n\nstruct disjoint_set_union{\n    int par[N];\n    \n    void init(){\n        msetn1(par);\n    }\n\n    int root(int x){\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n\n    bool merge(int x, int y){\n        if ((x = root(x)) == (y = root(y))){\n            if (ck[x]) return 0;\n            ck[x] = 1;\n            return 1;\n        }\n        if (ck[x] && ck[y]) return 0;\n        if (par[y] < par[x]){\n            swap(x, y);\n        }\n        par[x] += par[y];\n        par[y] = x;\n        ck[y] |= ck[x];\n        return 1;\n    }\n} dsu;\n\nsigned main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    cin >> n >> h >> w;\n    For(i, 0, n){\n        int x, y, z; cin >> x >> y >> z; y += h;\n        edges.pb({z, {x, y}});\n    }\n    sort(rbend(edges));\n    dsu.init();\n    Fora(edge, edges){\n        if (dsu.merge(edge.se.fi, edge.se.se)){\n            ans += edge.fi;\n        }\n    }\n    cout << ans;\n}\n\n/*\n==================================+\nINPUT:                            |\n------------------------------    |\n\n------------------------------    |\n==================================+\nOUTPUT:                           |\n------------------------------    |\n\n------------------------------    |\n==================================+\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll M=1000000007;\nint n,top,i,l,r,f[200005],vis[200005],h,w;\nlong long ans;\nstruct str{\n\tint r,c,a;\n}a[200005];\nbool cmp(str a,str b)\n{\n\treturn a.a>b.a;\n}\nint Find(int x)\n{\n\tif(f[x]==0)\n\t\treturn x;\n\treturn f[x]=Find(f[x]);\n}\nvoid uniot(int u,int v)\n{\n\tint x=Find(u),y=Find(v);\n\tif(x!=y)\n\t{\n\t\tvis[y]|=vis[x];\n\t\tf[x]=y;\n\t}\n}\nint main()\n{\n\tscanf(\"%d %d %d\",&n,&h,&w);\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%d %d %d\",&a[i].r,&a[i].c,&a[i].a);\n\tsort(a+1,a+1+n,cmp);\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tint x=Find(a[i].c+h),y=Find(a[i].r);\n\t\tif(x!=y)\n\t\t{\n\t\t\tif(vis[x]==1&&vis[y]==1)\n\t\t\t\tcontinue;\n\t\t\tans+=a[i].a;\n\t\t\tuniot(a[i].c+h,a[i].r);\n\t\t}\n\t\telse\n\t\t\tif(vis[x]==0)\n\t\t\t{\n\t\t\t\tvis[x]=1;\n\t\t\t\tans+=a[i].a;\n\t\t\t}\n\t}\n\tcout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <algorithm>\n#define MOD 1000000007\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename Tp> inline void getint(Tp &num){\n\tregister int ch, neg = 0;\n\twhile(!isdigit(ch = getchar())) if(ch == '-') neg = 1;\n\tnum = ch & 15;\n\twhile(isdigit(ch = getchar())) num = num * 10 + (ch & 15);\n\tif(neg) num = -num;\n}\n\nint N, H, W, fa[200005], vcnt[200005], ecnt[200005];\nll ans = 0;\nstruct card {int r, c, val;} c[100005];\n\ninline bool operator < (const card &c1, const card &c2) {return c1.val > c2.val;}\nint getf(const int &u) {return fa[u] == u ? u : fa[u] = getf(fa[u]);}\n\nint main(){\n\tgetint(N), getint(H), getint(W);\n\tfor(register int i = 1; i <= N; i++){\n\t\tgetint(c[i].r), getint(c[i].c), getint(c[i].val);\n\t\tfa[i] = i, vcnt[i] = 1, ecnt[i] = 0;\n\t}\n\tsort(c + 1, c + N + 1);\n\tfor(register int i = 1; i <= N; i++){\n\t\tconst int u = getf(c[i].r), v = getf(H + c[i].c);\n\t\tif(u == v){\n\t\t\tif(ecnt[u] >= vcnt[u]) continue;\n\t\t\tans += c[i].val, ecnt[u]++;\n\t\t}\n\t\telse{\n\t\t\tif(ecnt[u] + ecnt[v] >= vcnt[u] + vcnt[v]) continue;\n\t\t\tans += c[i].val, ecnt[u] += ecnt[v] + 1, vcnt[u] += vcnt[v], fa[v] = u;\n\t\t}\n\t}\n\treturn printf(\"%lld\\n\", ans), 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define lsb(x) (x & (-x))\n#define ll long long\n#define ull unsigned long long\n\n\n\n#if 0\nconst int MOD = ;\n\ninline int lgput(int a, int b) {\n    int ans = 1;\n    while(b > 0) {\n        if(b & 1) ans = (1LL * ans * a) % MOD;\n        b >>= 1;\n        a = (1LL * a * a) % MOD;\n    }\n    return ans;\n}\n\ninline void mod(int &x) {\n    if(x >= MOD)\n        x -= MOD;\n}\n\ninline void add(int &x, int y) {\n    x += y;\n    mod(x);\n}\n\ninline void sub(int &x, int y) {\n    x += MOD - y;\n    mod(x);\n}\n\ninline void mul(int &x, int y) {\n    x = (1LL * x * y) % MOD;\n}\n\ninline int inv(int x) {\n    return lgput(x, MOD - 2);\n}\n#endif\n\n#if 0\nint fact[], invfact[];\n\ninline void prec(int n) {\n    fact[0] = 1;\n    for(int i = 1; i <= n; i++) {\n        fact[i] = (1LL * fact[i - 1] * i) % MOD;\n    }\n    invfact[n] = lgput(fact[n], MOD - 2);\n    for(int i = n - 1; i >= 0; i--) {\n        invfact[i] = (1LL * invfact[i + 1] * (i + 1)) % MOD;\n    }\n}\n\ninline int comb(int n, int k) {\n    if(n < k) return 0;\n    return (1LL * fact[n] * (1LL * invfact[k] * invfact[n - k] % MOD)) % MOD;\n}\n#endif\n\nusing namespace std;\n\nstruct DSU {\n    vector <int> par, sz, sze;\n    int n;\n    inline void init(int _n) {\n        n = _n;\n        par.resize(n + 1), sz.resize(n + 1, 1), sze.resize(n + 1);\n    }\n    int root(int x) {\n        if(par[x] == 0)\n            return x;\n        return par[x] = root(par[x]);\n    }\n    inline void join(int x, int y) {\n        x = root(x), y = root(y);\n        if(x != y) {\n            par[x] = y;\n            sz[y] += sz[x];\n            sze[y] += sze[x] + 1;\n        }\n    }\n};\n\nstruct Edge {\n    int x, y, z;\n    bool operator <(const Edge &other) const {\n        return z > other.z;\n    }\n};\n\n\nint main() {\n#if 0\n    ifstream cin(\"A.in\");\n    ofstream cout(\"A.out\");\n#endif\n    int i, n, h, w;\n    ios::sync_with_stdio(false);\n    cin.tie(0), cout.tie(0);\n\n    cin >> n >> h >> w;\n    vector <Edge> edges(n);\n    for(i = 0; i < n; i++) {\n        cin >> edges[i].x >> edges[i].y >> edges[i].z;\n        edges[i].y += h;\n    }\n    sort(edges.begin(), edges.end());\n    DSU dsu; dsu.init(h + w);\n    ll ans = 0;\n    for(auto it : edges) {\n        int x = dsu.root(it.x), y = dsu.root(it.y), z = it.z;\n        if(x != y) {\n            if(dsu.sze[x] + dsu.sze[y] + 1 <= dsu.sz[x] + dsu.sz[y]) {\n                dsu.join(x, y);\n                ans += z;\n            }\n        }\n        else if(dsu.sze[x] < dsu.sz[x]) {\n            dsu.sze[x]++;\n            ans += z;\n        }\n    }\n    cout << ans;\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// verified at https://judge.yosupo.jp/submission/3400\n#ifndef Union_find_hpp\n#define Union_find_hpp\n\n#include <cassert>\n#include <cstddef>\n#include <vector>\n\nclass union_find\n{\n    std::vector<int> link;\n\npublic:\n    explicit union_find(const size_t n) : link(n, -1) {}\n\n    size_t find(size_t x)\n    {\n        assert(x < size());\n        // while(link[x] >= 0)\n        // {\n        //     if(link[link[x]] >= 0) link[x] = link[link[x]];\n        //     x = link[x];\n        // }\n        // return x;\n        return link[x] < 0 ? x : (link[x] = find(link[x]));\n    }\n\n    size_t size() const { return link.size(); }\n\n    size_t size(const size_t x)\n    {\n        assert(x < size());\n        return -link[find(x)];\n    }\n\n    bool same(const size_t x, const size_t y)\n    {\n        assert(x < size() && y < size());\n        return find(x) == find(y);\n    }\n\n    size_t unite(size_t x, size_t y)\n    {\n        assert(x < size() && y < size());\n        if((x = find(x)) != (y = find(y)))\n        {\n            if(link[x] > link[y]) std::swap(x, y);\n            link[x] += link[y];\n            link[y] = x;\n        }\n        return x;\n    }\n}; // class union_find\n\n#endif // Union_find_hpp\n\n#include <iostream>\n#include <tuple>\n\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n    std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n\n    int n,h,w; cin>>n>>h>>w;\n    vector<vector<pair<int,int>>> cards(100000);\n    for(int i=n,r,c,a; i--; )\n    {\n        cin>>r>>c>>a; --r,--c;\n        cards[a].emplace_back(r,c+h);\n    }\n    union_find uf(h+w);\n    long long ans{};\n    bool ext[2<<17]={};\n    for(int i=100000; i; --i)\n    {\n        for(auto&& e:cards[i])\n        {\n            int r,c; tie(r,c)=e;\n            r=uf.find(r),c=uf.find(c);\n            if(r!=c)\n            {\n                if(ext[r] and ext[c]) continue;\n                ext[uf.unite(r,c)]=ext[r]||ext[c];\n                ans+=i;\n            }\n            else if(!ext[r])\n            {\n                ext[r]=true;\n                ans+=i;\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define clr(x) memset(x,0,sizeof(x))\n#define For(i,a,b) for (int i=(a);i<=(b);i++)\n#define Fod(i,b,a) for (int i=(b);i>=(a);i--)\n#define fi first\n#define se second\n#define kill _z_kill\n#define y0 _z_y0\n#define y1 _z_y1\n#define x0 _z_x0\n#define x1 _z_x1\n#define pb(x) push_back(x)\n#define mp(x,y) make_pair(x,y)\nusing namespace std;\ntypedef long long LL;\ntypedef unsigned long long ull;\ntypedef unsigned uint;\ntypedef long double LD;\ntypedef vector <int> vi;\ntypedef pair <int,int> pii;\nvoid enable_comma(){}\nstring tostring(char c);\nstring tostring(LL x);\ntemplate <class A,class B> string tostring(pair <A,B> p);\ntemplate <class A> string tostring(vector <A> v);\nstring tostring(char c){\n\tstring s=\"\";\n\ts+=c;\n\treturn s;\n}\nstring tostring(string s){\n\treturn \"\\\"\"+s+\"\\\"\";\n}\nstring tostring(char *c){\n\treturn tostring((string)c);\n}\nstring tostring(LL x){\n\tif (x<0)\n\t\treturn \"-\"+tostring(-x);\n\tif (x>9)\n\t\treturn tostring(x/10)+tostring(char('0'+x%10));\n\telse\n\t\treturn tostring(char('0'+x));\n}\nstring tostring(int x){\n\treturn tostring((LL)x);\n}\nstring tostring(ull x){\n\tif (x>9)\n\t\treturn tostring((LL)(x/10))+tostring(char('0'+x%10));\n\telse\n\t\treturn tostring(char('0'+x));\n}\nstring tostring(uint x){\n\treturn tostring((LL)x);\n}\nstring tostring(double x){\n\tstatic char res[114];\n\tsprintf(res,\"%lf\\n\",x);\n\treturn tostring(res);\n}\nstring tostring(LD x){\n\treturn tostring((double)x);\n}\ntemplate <class A,class B> string tostring(pair <A,B> p){\n\treturn \"(\"+tostring(p.fi)+\",\"+tostring(p.se)+\")\";\n}\n\ntemplate <class A> string tostring(vector <A> v){\n\tstring res=\"{\";\n\tFor(i,0,(int)v.size()-1){\n\t\tres+=tostring(v[i]);\n\t\tres+=i==(int)v.size()-1?\"}\":\",\";\n\t}\n\tif (res==\"{\")\n\t\tres+=\"}\";\n\treturn res;\n}\ntemplate <class A> string tostring(A a,int L,int R){\n\tstring res=\"{\";\n\tFor(i,L,R){\n\t\tres+=tostring(a[i]);\n\t\tres+=i==R?\"}\":\",\";\n\t}\n\tif (res==\"{\")\n\t\tres+=\"}\";\n\treturn res;\n}\nstring tostrings(){\n\treturn \"\";\n}\ntemplate <typename Head,typename... Tail>\nstring tostrings(Head H,Tail... T){\n\treturn tostring(H)+\" \"+tostrings(T...);\n}\n#define User_Time ((double)clock()/CLOCKS_PER_SEC)\n#ifdef zzd\n\t#define outval(x) cerr<<#x\" = \"<<tostring(x)<<endl\n\t#define outvals(...) cerr<<\"[\"<<#__VA_ARGS__<<\"]: \"<<tostrings(__VA_ARGS__)<<endl\n\t#define outtag(x) cerr<<\"--------------\"#x\"---------------\"<<endl\n\t#define outsign(x) cerr<<\"<\"#x\">\"<<endl\n\t#define outarr(a,L,R) cerr<<#a\"[\"<<(L)<<\"..\"<<(R)<<\"] = \"<<tostring(a,L,R)<<endl\n#else\n\t#define outval(x) enable_comma()\n\t#define outvals(...) enable_comma()\n\t#define outtag(x) enable_comma()\n\t#define outsign(x) enable_comma()\n\t#define outarr(a,L,R) enable_comma()\n#endif\n#ifdef ONLINE_JUDGE\n\t#ifdef assert\n\t\t#undef assert\n\t#endif\n\t#define assert(x) (!(x)?\\\n\t\t\tcout<<\"Assertion failed!\"<<endl<<\\\n\t\t\t\"function: \"<<__FUNCTION__<<endl<<\\\n\t\t\t\"line: \"<<__LINE__<<endl<<\\\n\t\t\t\"expression: \"<<#x<<endl,exit(3),0:1)\n#endif\nLL read(){\n\tLL x=0,f=0;\n\tchar ch=getchar();\n\twhile (!isdigit(ch))\n\t\tf=ch=='-',ch=getchar();\n\twhile (isdigit(ch))\n\t\tx=(x<<1)+(x<<3)+(ch^48),ch=getchar();\n\treturn f?-x:x;\n}\ntemplate <class T> void ckmax(T &x,const T y){\n\tif (x<y)\n\t\tx=y;\n}\ntemplate <class T> void ckmin(T &x,const T y){\n\tif (x>y)\n\t\tx=y;\n}\n//int Pow(int x,int y){\n//\tint ans=1;\n//\tfor (;y;y>>=1,x=(LL)x*x%mod)\n//\t\tif (y&1)\n//\t\t\tans=(LL)ans*x%mod;\n//\treturn ans;\n//}\n//void Add(int &x,int y){\n//\tif ((x+=y)>=mod)\n//\t\tx-=mod;\n//}\n//void Del(int &x,int y){\n//\tif ((x-=y)<0)\n//\t\tx+=mod;\n//}\n//int Add(int x){\n//\treturn x>=mod?x-mod:x;\n//}\n//int Del(int x){\n//\treturn x<0?x+mod:x;\n//}\n//int md(LL x){\n//\treturn (x%mod+mod)%mod;\n//}\nconst int N=100005*3;\nint n,h,w;\nstruct P{\n\tint x,y,c;\n}a[N];\nint fa[N],gg[N];\nint getf(int x){\n\treturn fa[x]==x?x:fa[x]=getf(fa[x]);\n}\nint gao(int x,int y){\n\tint f=getf(x);\n\tif (gg[f])\n\t\treturn 0;\n\tif (getf(x)==getf(y))\n\t\tgg[f]=1;\n\telse\n\t\tfa[f]=y;\n\treturn 1;\n}\nint main(){\n\tn=read(),h=read(),w=read();\n\tFor(i,1,n){\n\t\tint r=read(),c=read(),v=read();\n\t\ta[i]={r,c,v};\n\t}\n\tsort(a+1,a+n+1,[&](P a,P b){\n\t\treturn a.c>b.c;\n\t});\n\tiota(fa+1,fa+h+w+1,1);\n\tLL ans=0;\n\tFor(i,1,n){\n\t\tint x=a[i].x,y=a[i].y+h,c=a[i].c;\n\t\tif (gao(x,y)||gao(y,x))\n\t\t\tans+=c;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\nusing namespace std;\ntypedef long long LL;\nint n, h, w;\nstruct NODE{\n\tLL a;\n\tint r, c;\n\tinline bool operator < (const NODE &tmp) const\n\t{\n\t\treturn a > tmp.a;\n\t}\n}t[100010];\nint fa[200010];\nLL val[200010];\n\nint find(int x)\n{\n\tif(x == fa[x]) return x;\n\treturn fa[x] = find(fa[x]);\n}\n\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &h, &w);\n\tfor (register int i = 1;i <= n;i ++) scanf(\"%d%d%lld\", &t[i].r, &t[i].c, &t[i].a);\n\tsort(t + 1, t + n + 1);\n\tfor (register int i = 1;i <= n;i ++)\n\t{\n\t\tfa[i] = i;\n\t\tval[i] = 1;\n\t}\n\tLL ans = 0;\n\tfor (register int i = 1;i <= n;i ++)\n\t{\n\t\tint xx = find(t[i].r), yy = find(t[i].c + h);\n\t\tif(xx == yy)\n\t\t{\n\t\t\tif(val[xx])\n\t\t\t{\n\t\t\t\tval[xx] --;\n\t\t\t\tans += t[i].a;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(val[xx] + val[yy])\n\t\t\t{\n\t\t\t\tval[xx] += val[yy];\n\t\t\t\tval[xx] --;\n\t\t\t\tfa[yy] = xx;\n\t\t\t\tans += t[i].a;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n\n\ntypedef long long i64;\nconst int inf = (int)1.05e9;\ntypedef pair<int,int> card;\n\ncard pop_from(set<card>& s)\n{\n\tcard v = *s.rbegin();\n\ts.erase(v);\n\treturn v;\n}\n\ncard top_of(set<card>& s)\n{\n\treturn *s.rbegin();\n}\n\nint main()\n{\n\tint n, h, w;\n\tvector<set<card>> hp, wp;\n\tvector<pair<int,int>> cards;\n\n\tscanf(\"%d%d%d\", &n, &h, &w);\n\thp.resize(h);\n\twp.resize(w);\n\tcards.resize(n);\n\tfor(int i = 0; i < n; i++) {\n\t\tint r, c, a;\n\t\tscanf(\"%d%d%d\", &r, &c, &a);\n\t\tr -= 1;\n\t\tc -= 1;\n\t\thp[r].insert({a, i});\n\t\twp[c].insert({a, i});\n\t\tcards[i] = {r, c};\n\t}\n\n\ti64 ans = 0;\n\tvector<int> dup_to(n, -1);\n\n\tfor(int i = 0; i < h; i++) {\n\n\t\tif(hp[i].empty()) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tauto v = pop_from(hp[i]);\n\t\tint a = v.first;\n\t\tint id = v.second;\n\t\tint c = cards[id].second;\n\n\t\tans += a;\n\t\twp[c].erase(v);\n\n\t\tif(!hp[i].empty()) {\n\t\t\tauto w = top_of(hp[i]);\n\t\t\tif(cards[w.second].second != c) {\n\t\t\t\twp[c].insert(w);\n\t\t\t\tdup_to[w.second] = c;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < w; i++) {\n\n\t\tif(wp[i].empty()) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tauto v = pop_from(wp[i]);\n\t\tint a = v.first;\n\t\tint id = v.second;\n\t\tint r = cards[id].first;\n\t\tint c = cards[id].second;\n\n\t\tans += a;\n\t\thp[r].erase(v);\n\n\t\tint to = dup_to[id];\n\n\t\tif(to != -1 && to > i) {\n\n\t\t\twp[to].erase(v);\n\n\t\t\tif(!hp[r].empty()) {\n\t\t\t\tauto w = top_of(hp[r]);\n\t\t\t\tif(cards[w.second].second != to) {\n\t\t\t\t\twp[to].insert(w);\n\t\t\t\t\tdup_to[w.second] = to;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}\n\n/* waffle */\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(a,n) for (ll a = 0; a < (n); ++a)\nusing namespace std;\ntypedef long long ll;\nusing ll = long long;\ntypedef pair<ll,ll> P;\ntypedef pair<P,ll> PP;\nusing Graph = vector<vector<ll> >;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst ll INF = 1e18;\n\n\n//入力\nll n,h,w;\n\nint main(){\n    cin >> n >> h >> w;\n    vector<ll>r(n),c(n),a(n);\n    rep(i,n){\n        cin >> r[i] >> c[i] >> a[i];\n    }\n    sort(a.rbegin(),a.rend());\n    ll ans = 0;\n    rep(i,min(n,h+w)){\n        ans += a[i];\n    }\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1 };\nvel dy = { 1,-1,0,0 };\nvoid sol(int i, vvel& nex,set<int>& ad,veb& use, vel& cnt) {\n\tif (cnt[i] == 0) {\n\t\tad.insert(i);\n\t\treturn;\n\t}\n\tif (!use[i]) {\n\t\tuse[i] = true;\n\t\tfor (auto ne : nex[i]) {\n\t\t\tsol(ne, nex,ad, use, cnt);\n\t\t}\n\t}\n}\nsigned main() {\n\tomajinai;\n\tint n, h, w; cin >> n >> h >> w;\n\tvvel cxy(n);\n\tvvel y_i(w);\n\tvvel x_i(h);\n\trep(i, n) {\n\t\tint c, x, y; cin >> x >> y >> c; x--; y--;\n\t\tcxy[i] = { c,x,y };\n\t}\n\tsor(cxy);\n\trep(i, n) {\n\t\tint x = cxy[i][1];\n\t\tint y = cxy[i][2];\n\t\ty_i[y].push_back(i);\n\t\tx_i[x].push_back(i);\n\t}\n\tvel cnt(n, 0);\n\tvvel nex(n);\n\trep(i, w) { \n\t\tsor(y_i[i]);\n\t\tint sz = y_i[i].size();\n\t\tif (sz != 0) {\n\t\t\tcnt[y_i[i].back()]++;\n\t\t\trep(j, sz - 1) {\n\t\t\t\tnex[y_i[i][j + 1]].push_back(y_i[i][j]);\n\t\t\t}\n\t\t}\n\n\t}\n\trep(i, h) { \n\t\tsor(x_i[i]);\n\t\tint sz = x_i[i].size();\n\t\tif (sz != 0) {\n\t\t\tcnt[x_i[i].back()]++;\n\t\t\trep(j, sz - 1) {\n\t\t\t\tnex[x_i[i][j + 1]].push_back(x_i[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tvvel adj(n);\n\tset<int> ad;\n\tveb use(n,false);\n\tint ans = 0;\n\trep(i, n) {\n\t\tif (cnt[i] == 2) {\n\t\t\tsol(i, nex,ad,use, cnt);\n\t\t\tfor (auto x : ad) { adj[x].push_back(i); }\n\t\t}\n\t\tif (cnt[i] >= 1) { ans += cxy[i][0]; }\n\t}\n\t/*vel pa(n, -1);\n\tvvel ed;\n\trep(i, n) {\n\t\tvel v = adj[i];\n\t\tif (v.size() >= 1) {\n\t\t\ted.push_back({ cxy[i][0],v[0],v.back() });\n\t\t}\n\t}\n\tsor(ed); rev(ed);\n\tvel ex(n, 0);\n\tfor (auto v : ed) {\n\t\tint c = v[0];\n\t\tint x = root(v[1], pa);\n\t\tint y = root(v[2], pa);\n\t\tif (x == y) {\n\t\t\tif (ex[x] == 0) {\n\t\t\t\tex[x] = 1;\n\t\t\t\tans += c;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (ex[x] + ex[y]<=1) {\n\t\t\t\tpa[x] = y;\n\t\t\t\tex[y] += ex[x]; ex[x] = 0;\n\t\t\t\tans += c;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;*/\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <math.h>\n#include <chrono>\nusing namespace std;\n#pragma GCC optimize(\"-O3\")\n#define endl \"\\n\"\n#define mp make_pair\n#define st first\n#define nd second\n#define pii pair<int, int>\n#define pb push_back\n#define _upgrade ios_base::sync_with_stdio(0), cout.setf(ios::fixed), cout.precision(10) //cin.tie(0); cout.tie(0);\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define FWD(i, a, b) for (int i = (a); i < (b); ++i)\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define fwd(i, a, b) for (int i = (a); i < (b); ++i)\n#define all(c) (c).begin(), (c).end()\n#define what(x) cerr << #x << \" is \" << x << endl;\n#define int long long\n\nconst int MAXN = 2e5 + 1e4;\nint kapitan[MAXN];\nint wynik = 0;\n\nint fiind(int x)\n{\n    if (kapitan[x] != x)\n        kapitan[x] = fiind(kapitan[x]);\n    return kapitan[x];\n}\nvoid unia(pair<int, pii> P)\n{\n    // cerr << P.st << \" \" << P.nd.st << \" \" << P.nd.nd << endl;\n    int x = fiind(P.nd.st);\n    int y = fiind(P.nd.nd);\n    if (x > y)\n        swap(x, y);\n    if (x == 0 && y == 0)\n        return;\n    wynik += P.st;\n    if (x == 0 || x == y)\n        kapitan[y] = 0;\n    else\n        kapitan[y] = x;\n}\n\nvector<pair<int, pii>> A;\nmain()\n{\n    _upgrade;\n    iota(kapitan, kapitan + MAXN, 0);\n    int n, w, h;\n    cin >> n >> w >> h;\n    rep(i, n)\n    {\n        int b, c, a;\n        cin >> b >> c >> a;\n        b += max(w, h) + 2;\n        A.pb(mp(a, mp(b, c)));\n    }\n    sort(all(A), greater<pair<int, pii>>());\n    for (auto a : A)\n        unia(a);\n    cout << wynik << endl;\n}\np"
  },
  {
    "language": "C++",
    "code": "// orz dxm\n#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define PH push\n#define MP make_pair\n#define PB push_back\n#define fst first\n#define snd second\n#define FOR(i, x, y) for(int i = (x); i < (y); ++i)\n#define REP(i, x, y) for(int i = (x); i <= (y); ++i)\n#define y0 yORZDXM\n#define y1 yORZDXM\n#define y2 yORZDXM\ntypedef double db;\ntypedef long long ll;\ntypedef long double ldb;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int INF = 1e9 + 7;\nconst int maxn = 1e5 + 5;\n\nint n, h, w;\nll ans;\n\nclass Edge{public: int u, v, w; bool operator < (const Edge &e)const{return MP(w, MP(u, v)) < MP(e.w, MP(e.u, e.v));}}ed[maxn];\n\nclass Dsu{\nprivate:\n\tint fa[maxn << 1], cyc[maxn << 1];\npublic:\n\tinline void init(){FOR(i, 0, maxn << 1) fa[i] = i, cyc[i] = false; return;}\n\tinline int find(int u){return (u == fa[u]) ? u : (fa[u] = find(fa[u]));}\n\tinline int combine(int u, int v, int w){\n\t\tu = find(u), v = find(v);\n\t\tif(u == v){\n\t\t\tif(!cyc[u]){\n\t\t\t\tcyc[u] = true;\n\t\t\t\treturn w;\n\t\t\t}\n\t\t\treturn 0;\n\t\t}\n\t\tif(cyc[u] && cyc[v]) return 0;\n\t\tfa[u] = v;\n\t\tcyc[v] |= cyc[v];\n\t\treturn w;\n\t}\n}dsu;\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &h, &w);\n\tdsu.init();\n\tFOR(i, 0, n){\n\t\tscanf(\"%d%d%d\", &ed[i].u, &ed[i].v, &ed[i].w);\n\t\t--ed[i].u, --ed[i].v;\n\t\ted[i].v += h;\n\t}\n\tsort(ed, ed + n);\n\treverse(ed, ed + n);\n\tFOR(i, 0, n) ans += dsu.combine(ed[i].u, ed[i].v, ed[i].w);\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n,R,C;\nvector<vector<int> > g;\nint match[200000];\nint vis[100000],vs;\nbool findPath(int u){\n\tvis[u]=vs;\n\tfor(auto v:g[u])\n\t\tif(match[v]==-1){\n\t\t\tmatch[v]=u;\n\t\t\treturn true;\n\t\t}\n\tint x=(u>>2)&1;\n\tfor(int it=0;it<2;++it){\n\t\tint v=g[u][it^x];\n\t\tif(vis[match[v]]!=vs && findPath(match[v])){\n\t\t\tmatch[v]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nll calc(vector<vector<int> > &v){\n\tmemset(match,-1,sizeof(match));\n\tll res=0;\n\tfor(int i=0;i<g.size();++i){\n\t\t++vs;\n\t\tif(findPath(i))\n\t\t\tres+=v[i][0];\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&R,&C);\n\tvector<vector<int> > v(n,vector<int>(3));\n\tfor(auto &x:v){\n\t\tfor(auto &y:x)\n\t\t\tscanf(\"%d\",&y);\n\t\tswap(x[0],x[2]);\n\t\tswap(x[1],x[2]);\n\t}\n\tsort(v.rbegin(),v.rend());\n\tg.resize(n);\n\tfor(int i=0;i<v.size();++i){\n\t\tint r=--v[i][1];\n\t\tint c=--v[i][2];\n\t\tg[i].push_back(r);\n\t\tg[i].push_back(c+R);\n\t}\n\tcout<<calc(v)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#define dump(...) cerr << \"[\" << setw(3) << __LINE__ << \":\" << __FUNCTION__ << \"] \", dump_impl(#__VA_ARGS__, __VA_ARGS__)\n#define say(x) cerr << \"[\" << __LINE__ << \":\" << __FUNCTION__ << \"] \" << x << endl\n#define debug if (1)\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class F> int ppt(C const& v, F f) {\n    return partition_point(v.begin(), v.end(), f)-v.begin();\n}\n// <<<\n// >>> union find\nstruct UnionFind {\n    int n, sz; // id : 0...n-1\n    vector<int> par;\n\n    UnionFind(int n = 0) : n(n), sz(n), par(n,-1) { }\n    int root(int x) {\n        assert(0 <= x); assert(x < n);\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n    bool unite(int x, int y) {\n        x = root(x), y = root(y);\n        if (x == y) return false;\n        sz--;\n        if (par[x] < par[y]) swap(x,y);\n        par[y] += par[x];\n        par[x] = y;\n        return true;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -par[root(x)]; }\n    int size() const { return sz; }\n    struct groups_t {\n        vector<vector<int> > grp;\n        vector<pair<int,int> > id;\n    };\n    groups_t groups() {\n        vector<vector<int> > g(n);\n        rep (i,n) if (par[i] < 0) g[i].reserve(-par[i]);\n        rep (i,n) g[root(i)].push_back(i);\n        vector<vector<int> > grp; grp.reserve(size());\n        rep (i,n) if (g[i].size()) grp.emplace_back(move(g[i]));\n        vector<pair<int,int> > id(n);\n        rep (i,grp.size()) rep (j,grp[i].size()) {\n            id[grp[i][j]] = make_pair(i,j);\n        }\n        return { grp, id };\n    }\n};\n// <<<\n// >>> reord\n\nvoid reord_impl(vector<int> const&) { }\ntemplate <class T, class... Args>\nvoid reord_impl(vector<int> const& idx, vector<T> &v, Args&&... args) {\n    vector<T> t(v.size());\n    rep (i,v.size()) t[i] = v[idx[i]];\n    swap(v,t);\n    reord_impl(idx, forward<Args>(args)...);\n}\ntemplate <class Comp, class T, class... Args,\n          class = decltype(declval<Comp>()(0,0))>\nvoid reord(Comp comp, vector<T> &v, Args&&... args) {\n    vector<int> idx(v.size());\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), comp);\n    reord_impl(idx, v, args...);\n}\ntemplate <class T, class... Args>\nvoid reord(vector<T> &v, Args&&... args) {\n    vector<int> idx(v.size());\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int i, int j) { return v[i] < v[j]; });\n    reord_impl(idx, v, args...);\n}\ntemplate <class T, class... Args>\nvoid reordR(vector<T> &v, Args&&... args) {\n    vector<int> idx(v.size());\n    iota(idx.begin(), idx.end(), 0);\n    sort(idx.begin(), idx.end(), [&](int i, int j) { return v[i] > v[j]; });\n    reord_impl(idx, v, args...);\n}\n\n// <<<\n\nint32_t main() {\n    int n,h,w; cin >> n >> h >> w;\n    vector<int> r(n),c(n),a(n);\n    rep (i,n) cin >> r[i] >> c[i] >> a[i], --r[i],--c[i];\n    reordR(a,r,c);\n\n    UnionFind uf(h+w);\n    vector<int> L(h+w);\n    int sum = 0;\n    rep (i,n) {\n        int x = uf.root(r[i]);\n        int y = uf.root(h+c[i]);\n        if (x == y) {\n            if (L[x]+1 > 1) continue;\n            L[x] = 1;\n            sum += a[i];\n        } else {\n            if (L[x]+L[y] > 1) continue;\n            uf.unite(x,y);\n            L[uf.root(x)] = L[x]+L[y];\n            sum += a[i];\n        }\n    }\n    cout << sum << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst int maxn = 2e5 + 10;\n\nvector<int> g[maxn];\nint mt[maxn];\nint used[maxn];\nint cn = 1;\nvector<ll> prm = { 0, 1 };\n\nbool dfs(int v) {\n\tif (used[v] == cn) return false;\n\n\tused[v] = cn;\n\n\tfor (int i = 0; i < g[v].size(); i++) {\n\t\tint u = g[v][prm[i]];\n\t\tif (mt[u] == -1 || dfs(mt[u])) {\n\t\t\tmt[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\tfastInp;\n\n\tll n, h, w;\n\tcin >> n >> h >> w;\n\n\tll vals = 0, ans = 0;\n\tvector<tuple<ll, ll, ll>> vec;\n\tfor (int i = 0; i < h + w + 3; i++) mt[i] = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tll r, c, a;\n\t\tcin >> r >> c >> a;\n\t\tr--; c--;\n\t\tvec.push_back({ a, r, c });\n\t}\n\n\tsort(vec.rbegin(), vec.rend());\n\n\tll cnt = 0;\n\tll hw = h + w;\n\tfor (int i = 0; i < n; i++) {\n\t\trandom_shuffle(prm.begin(), prm.end());\n\t\tll r = get<1>(vec[i]), c = get<2>(vec[i]), a = get<0>(vec[i]);\n\t\tif (mt[r] == -1 || mt[c + h + 1] == -1) {\n\t\t\tvals++;\n\t\t\tcnt++;\n\t\t\tg[i].push_back(r);\n\t\t\tg[i].push_back(c + h + 1);\n\t\t\tif (mt[r] == -1) {\n\t\t\t\tmt[r] = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmt[c + h + 1] = i;\n\t\t\t}\n\t\t\tans += a;\n\t\t\tcontinue;\n\t\t}\n\t\tcn++;\n\t\tvals++;\n\t\t\n\t\tg[i].push_back(r);\n\t\tg[i].push_back(c + h + 1);\n\t\tcnt += dfs(i);\n\n\t\tif (cnt >= vals) {\n\t\t\tans += a;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tvals--;\n\t\t\tg[i].pop_back();\n\t\t\tg[i].pop_back();\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <time.h>\n#include <vector>\n#include <map>\n#include <set>\n#include <sstream>\n#include <algorithm>\n#include <bitset>\n#include <utility>\n#include <iostream>\n#include <cmath>\n#include <deque>\n\n#define pii pair<ll,ll>\n#define X first\n#define Y second\n#define mp make_pair\n\ntypedef long long ll;\nusing namespace std;\n#define MAXN 228228\n#define MOD 1000000007\nll x, y, n, m, k, R, C;\nll a[MAXN], rsz[MAXN], csz[MAXN];\nvector<ll> g;\nstruct info {\n    ll siz;\n    ll type;\n    ll row;\n};\n\nbool operator <(const info& x, const info &y) {\n    return (std::tie(x.siz, x.type, x.row) < std::tie(y.siz, y.type, y.row));\n}\n\nstruct shit {\n    ll val;\n    ll x;\n    ll y;\n};\n\nbool operator <(const shit& x, const shit& y) {\n    return x.val < y.val;\n}\n\nll p[MAXN], s[MAXN], h[MAXN];\n\nint dsu_get (int v) {\n    return (v == p[v]) ? v : (p[v] = dsu_get (p[v]));\n}\n\nvoid dsu_unite (int a, int b) {\n    a = dsu_get (a);\n    b = dsu_get (b);\n    if (rand() & 1)\n        swap (a, b);\n    if (a != b) {\n        p[a] = b;\n        s[b] += s[a];\n        h[b] += h[a];\n    }\n}\n\nvector<shit> f;\nint main() {\n    cin >> n >> R >> C;\n    for (int i = 0; i < n; i++ ){\n        ll x, y, z;\n        cin >> x >> y >> z;\n        f.push_back({z, x, y + R});\n    }\n    sort(f.begin(), f.end());\n    reverse(f.begin(), f.end());\n    for (int i = 1; i <= R+C; i++) {\n        p[i] = i;\n        s[i] = 1;\n        h[i] = 1;\n    }\n\n    ll ans = 0;\n    for (auto v : f) {\n        ll x = dsu_get(v.x);\n        ll y = dsu_get(v.y);\n        ll val = v.val;\n        if (x == y) {\n            if (h[x] == s[x]) {\n                h[x]++;\n                ans += val;\n            }\n        } else {\n            if (h[x] + h[y] <= s[x] + s[y] + 1) {\n                dsu_unite(x, y);\n                ans += val;\n            }\n        }\n    }\n    cout << ans << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<cstring>\n#define ll long long\nusing namespace std;\nstruct Edge\n{\n\tint u;\n\tint v;\n\tll w;\n}a[200005];\nint h,w,m,pa[200005];\nll ans;\nbool pos[200005];\nbool cmp(Edge a,Edge b)\n{\n\treturn a.w>b.w;\n}\nint find(int x)\n{\n\treturn x==pa[x]?x:pa[x]=find(pa[x]);\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&m,&h,&w);\n\tfor(int i=1;i<=h+w;i++)\n\t  pa[i]=i,pos[i]=1;\n\tfor(int i=1;i<=m;i++)\n\t  scanf(\"%d%d%lld\",&a[i].u,&a[i].v,&a[i].w);\n\tsort(a+1,a+m+1,cmp);\n\tfor(int i=1;i<=m;i++)\n\t{\n\t\tint x=a[i].u,y=a[i].v+h;\n\t\tx=find(x),y=find(y);\n\t\tif(x!=y)\n\t\t{\n\t\t\tif(pos[x]&&pos[y])\n\t\t\t{\n\t\t\t\tpa[x]=y;\n\t\t\t\tans+=a[i].w;\n\t\t\t}\n\t\t\telse if(pos[x]||pos[y])\n\t\t\t{\n\t\t\t\tpa[x]=y;\n\t\t\t\tpos[y]=0;\n\t\t\t\tans+=a[i].w;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(pos[x])\n\t\t\t{\n\t\t\t\tans+=a[i].w;\n\t\t\t\tpos[x]=0;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nint main() {\n  int len, n, m;\n  scanf(\"%d%d%d\", &len, &n, &m);\n  vector<array<int, 3>> a(len);\n  for (int i = 0; i < len; ++i) {\n    int x, y, v;\n    scanf(\"%d%d%d\", &x, &y, &v);\n    a[i] = {v, x, y};\n  }\n  sort(a.begin(), a.end());\n  int64 ret = 0;\n  set<int> R, C;\n  map<ii, int> A;\n  int cnt = 0;\n  for (int i = len - 1; i >= 0; --i) {\n    int x = a[i][1], y = a[i][2];\n    int cntR = R.size() + !R.count(x);\n    int cntC = C.size() + !C.count(y);\n    if (cntR + cntC >= cnt + 1 && A[{x, y}] < 2) {\n      cnt += 1;\n      R.insert(x);\n      C.insert(y);\n      A[{x, y}] += 1;\n      ret += a[i][0];\n    }\n  }\n  printf(\"%lld\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// verified at https://judge.yosupo.jp/submission/3400\n#ifndef Union_find_hpp\n#define Union_find_hpp\n\n#include <cassert>\n#include <cstddef>\n#include <vector>\n\nclass union_find\n{\n    std::vector<int> link;\n\npublic:\n    explicit union_find(const size_t n) : link(n, -1) {}\n\n    size_t find(size_t x)\n    {\n        assert(x < size());\n        while(link[x] >= 0)\n        {\n            if(link[link[x]] >= 0) link[x] = link[link[x]];\n            x = link[x];\n        }\n        return x;\n    }\n\n    size_t size() const { return link.size(); }\n\n    size_t size(const size_t x)\n    {\n        assert(x < size());\n        return -link[find(x)];\n    }\n\n    bool same(const size_t x, const size_t y)\n    {\n        assert(x < size() && y < size());\n        return find(x) == find(y);\n    }\n\n    size_t unite(size_t x, size_t y)\n    {\n        assert(x < size() && y < size());\n        if((x = find(x)) != (y = find(y)))\n        {\n            if(link[x] > link[y]) std::swap(x, y);\n            link[x] += link[y];\n            link[y] = x;\n        }\n        return x;\n    }\n}; // class union_find\n\n#endif // Union_find_hpp\n\n#include <iostream>\n#include <tuple>\n\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n    std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n\n    int n,h,w; cin>>n>>h>>w;\n    vector<vector<pair<int,int>>> cards(100000);\n    for(int i=n,r,c,a; i--; )\n    {\n        cin>>r>>c>>a; --r,--c;\n        cards[a].emplace_back(r,c+h);\n    }\n    union_find uf(h+w);\n    long long ans{};\n    bool ext[2<<17]={};\n    for(int i=100000; i; --i)\n    {\n        for(auto&& e:cards[i])\n        {\n            int r,c; tie(r,c)=e;\n            r=uf.find(r),c=uf.find(c);\n            if(r!=c)\n            {\n                if(ext[r] and ext[c]) continue;\n                ext[uf.unite(r,c)]=ext[r]||ext[c];\n                ans+=i;\n            }\n            else if(!ext[r])\n            {\n                ext[r]=true;\n                ans+=i;\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct UnionFind{\n    int num;\n    vector<int> par,rank;\n    UnionFind(int n):num(n),par(n),rank(n,1){\n        iota(par.begin(),par.end(),0);\n    }\n    int root(int x){\n        if (par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    bool merge(int x, int y){\n        x=root(x),y=root(y);\n        if (x==y) return false;\n        if (rank[x]<rank[y]) swap(x,y);\n        par[y]=x;\n        rank[x]+=rank[y];\n        --num;\n        return true;\n    }\n    bool same(int x, int y){\n        return root(x)==root(y);\n    }\n    int size(int x){\n        return rank[root(x)];\n    }\n    int count(){\n        return num;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,H,W; cin >> N >> H >> W;\n    UnionFind uf(H+W);\n    struct edge{\n        int r,c,a;\n        edge(int r,int c,int a):r(r),c(c),a(a){}\n        const bool operator<(const edge &rhs){\n            return a>rhs.a;\n        }\n    };\n    vector<edge> es;\n    for (int i=0;i<N;++i){\n        int R,C,A; cin >> R >> C >> A;\n        es.emplace_back(--R,--C,A);\n    }\n    sort(es.begin(),es.end());\n    vector<int> cycle(H+W,0);\n    ll ans=0;\n    for (int i=0;i<N;++i){\n        int p=uf.root(es[i].r),q=uf.root(es[i].c);\n        if (uf.merge(es[i].r,es[i].c+H)&&!(cycle[p]&&cycle[q])){\n            ans+=es[i].a;\n            cycle[p]|=cycle[q],cycle[q]|=cycle[p];\n        } else if (!cycle[p]){\n            ans+=es[i].a; cycle[p]=1;\n        }\n    }\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define WHOLE(v) (v).begin(), (v).end()\n#define REV_WHOLE(v) (v).rbegin(), (v).rend()\nusing i64 = int64_t;\nusing namespace std;\ntemplate<size_t I,class H,class...T>struct TupleReaderWriter{static tuple<H,T...> r(istream&i){H v;i>>v;return tuple_cat(tuple<H>(v),TupleReaderWriter<sizeof...(T)-1,T...>::r(i));}static void w(ostream&o,tuple<H,T...>&t,string d){TupleReaderWriter<I-1,H,T...>::w(o,t,d);o<<d<<get<I>(t);}};\ntemplate<class H,class...T>struct TupleReaderWriter<0,H,T...>{static tuple<H,T...> r(istream&i){H v;i>>v;return tuple<H>(v);}static void w(ostream&o,tuple<H,T...>&t,string d){o<<get<0>(t);}};\ntemplate<class...T>istream&operator>>(istream&i,tuple<T...>&t){t=TupleReaderWriter<sizeof...(T),T...>::r(i);return i;}\ntemplate<class...T>ostream&operator<<(ostream&o,tuple<T...>&t){string delim=\" \";TupleReaderWriter<sizeof...(T)-1,T...>::w(o,t,delim);return o;}\ntemplate<class T>istream&operator>>(istream&i,vector<T>&v){for(auto&x:v)i>>x;return i;}\ntemplate<class T>ostream&operator<<(ostream&o,vector<T>&v){string delim=\"\";for(auto&x:v)o<<delim<<x,delim=\" \";return o;}\ntemplate<class T>using rev_priority_queue=priority_queue<T,vector<T>,greater<T>>;\ntemplate<class T>using vector2d=vector<vector<T>>;\nstruct fixprec{int x;fixprec(int d):x(d){}};\nostream&operator<<(ostream&o,fixprec f){return o<<fixed<<setprecision(f.x);}\nvoid R_YESNO(bool p) { cout << (p ? \"YES\" : \"NO\") << endl; }\nvoid R_YesNo(bool p) { cout << (p ? \"Yes\" : \"No\") << endl; }\n/*!* [union_find] *!*/\n/*+* UnionFind 木 *+*/\n// T (typename) : グラフの頂点を表す型, (int)parent を持つ必要あり\ntemplate <typename T>\nstruct UnionFind {\n    vector<T> &u;\n    UnionFind(vector<T> &u) : u(u) {\n        for (int i = 0; i < u.size(); i++) {\n            u[i].parent = i;\n        }\n    }\n    int root(int x) {\n        if (x < 0 || u.size() <= x) return -1;\n        else if (x == u[x].parent) return x;\n        else return u[x].parent = root(u[x].parent);\n    }\n    bool connect(int a, int b) {\n        a = root(a), b = root(b);\n        if(a == b) {\n            if(u[b].e + 1 > u[b].v) {\n                return false;\n            }\n            u[b].e++;\n        } else {\n            if(u[a].e + u[b].e + 1 > u[a].v + u[b].v) {\n                return false;\n            }\n            u[b].parent = a;\n            u[a].e += u[b].e + 1;\n            u[a].v += u[b].v;\n        }\n        return true;\n    }\n};\nusing Data = tuple<int, int, int>;\nstruct Node {\n    int parent;\n    int e;\n    int v;\n};\nint main() {\n    int N, H, W;\n    cin >> N >> H >> W;\n    vector<Node> node(H + W, {0, 0, 1});\n    vector<Data> A(N);\n    UnionFind<Node> uf(node);\n    for(auto &x : A) {\n        int r, c, a;\n        cin >> r >> c >> a;\n        r--, c--;\n        x = make_tuple(a, r, H + c);\n    }\n    int ans = 0;\n    sort(REV_WHOLE(A));\n    for(auto x : A) {\n        int a, r, c;\n        tie(a, r, c) = x;\n        ans += uf.connect(r, c) ? a : 0;\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define YES() printf(\"YES\\n\")\n#define NO() printf(\"NO\\n\")\n#define Yes() printf(\"Yes\\n\")\n#define No() printf(\"No\\n\")\n#define in(x,y,h,w) x >= 0 && x < h && y >= 0 && y < w\n\n#define int long long\n//typedef    long long          ll;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      P;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n \nconst int INF=1e+18;\nconst double EPS=1e-9;\nconst int MOD=1000000007;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nstruct edge{ int to,cap,cost,rev; };\n\nvector<edge> G[300010];\nint h[300010],dist[300010],prevv[300010],preve[300010];\n\nvoid add_edge(int from,int to,int cap,int cost){\n\tG[from].push_back({to,cap,cost,(int)G[to].size()});\n\tG[to].push_back({from,0,-cost,(int)G[from].size() - 1});\n}\n\nint min_cost_flow(int n,int s,int t,int f){\n\tint res = 0;\n\tfill(h,h + n,0);\n\twhile(f > 0){\n\t\tpriority_queue<P,vector<P>,greater<P>> que;\n\t\tfill(dist,dist + n,INF);\n\t\tdist[s] = 0;\n\t\tque.emplace(0,s);\n\t\twhile(!que.empty()){\n\t\t\tP p = que.top();que.pop();\n\t\t\tint v = p.second;\n\t\t\tif(dist[v] < p.first) continue;\n\t\t\tfor(int i = 0;i < G[v].size();i++){\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]){\n\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.emplace(dist[e.to],e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(dist[t] == INF) return res;\n\t\tfor(int i = 0;i < n;i++) h[i] += dist[i];\n\t\tint d = f;\n\t\tfor(int i = t;i != s;i = prevv[i]){\n\t\t\td = min(d,G[prevv[i]][preve[i]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor(int i = t;i != s;i = prevv[i]){\n\t\t\tedge &e = G[prevv[i]][preve[i]];\n\t\t\te.cap -= d;\n\t\t\tG[i][e.rev].cap += d;\n\t\t}\n\t}\n\treturn res;\n}\n\nsigned main(){\n\tint n,h,w;\n\tcin >> n >> h >> w;\n\tfor(int i = 0;i < n;i++){\n\t\tint r,c,a;\n\t\tcin >> r >> c >> a; r--;c--;\n\t\tadd_edge(r,i + h + w,1,10 - a);\n\t\tadd_edge(c + h,i + h + w,1,10 - a);\n\t}\n\tfor(int i = 0;i < h + w;i++) add_edge(h + w + n,i,1,0);\n\tfor(int i = 0;i < n;i++) add_edge(i + h + w,h + w + n + 1,1,0);\n\tcout << (h + w) * 10 - min_cost_flow(h + w + n + 2,h + w + n,h + w + n + 1,h + w) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst int maxn = 2e5 + 10;\n\nvector<int> g[maxn];\nint mt[maxn];\nint used[maxn];\nint cn = 1;\n\nbool dfs(int v) {\n\tif (used[v] == cn) return false;\n\n\tused[v] = cn;\n\n\tfor (int u : g[v]) {\n\t\tif (mt[u] == -1 || dfs(mt[u])) {\n\t\t\tmt[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\tfastInp;\n\n\tll n, h, w;\n\tcin >> n >> h >> w;\n\n\tll vals = 0, ans = 0;\n\tvector<tuple<ll, ll, ll>> vec;\n\tfor (int i = 0; i < h + w + 3; i++) mt[i] = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tll r, c, a;\n\t\tcin >> r >> c >> a;\n\t\tr--; c--;\n\t\tvec.push_back({ a, c, r });\n\t}\n\n\tsort(vec.rbegin(), vec.rend());\n\n\tll cnt = 0;\n\tll hw = h + w;\n\tfor (int i = 0; i < n; i++) {\n\t\tll r = get<1>(vec[i]), c = get<2>(vec[i]), a = get<0>(vec[i]);\n\t\tswap(r, c);\n\t\tif (mt[r] == -1 || mt[c + h + 1] == -1) {\n\t\t\tvals++;\n\t\t\tcnt++;\n\t\t\tg[i].push_back(r);\n\t\t\tg[i].push_back(c + h + 1);\n\t\t\tif (mt[r] == -1) {\n\t\t\t\tmt[r] = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmt[c + h + 1] = i;\n\t\t\t}\n\t\t\tans += a;\n\t\t\tcontinue;\n\t\t}\n\t\tcn++;\n\t\tvals++;\n\t\t\n\t\tg[i].push_back(r);\n\t\tg[i].push_back(c + h + 1);\n\t\tcnt += dfs(i);\n\n\t\tif (cnt >= vals) {\n\t\t\tans += a;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tvals--;\n\t\t\tg[i].pop_back();\n\t\t\tg[i].pop_back();\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = ll(A); I < ll(B); ++I)\n#define FORR(I,A,B) for(ll I = ll((B)-1); I >= ll(A); --I)\n#define TO(x,t,f) ((x)?(t):(f))\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //xi>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //xi>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\nll gcd(ll a,ll b){if(a%b==0)return b;return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nconst ll INF=ll(1e18)+ll(7);\nconst ll MOD=1000000007LL;\n#define out(a) cout<<fixed<<setprecision((a))\n\nclass UnionFind{\npublic:\n\tvector<int> par,rank;\n\t//0-indexed\n\tUnionFind(int n){init(n);}\n\tvoid init(int n = 1) {\n\t\tpar.resize(n);\n\t\trank.resize(n,0);\n\t\tfor (int i = 0; i < n; ++i) par[i] = i;\n\t}\n\tint root(int x = 1){\n\t\tif(par[x]==x)return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n\tvoid unite(int x = 1,int y = 1){\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif(x==y)return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x]==rank[y]){\n\t\t\t\trank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\tbool same(int x,int y){\n\t\treturn root(x)==root(y);\n\t}\n};\n\n\n// なもりグラフ\n// https://www.hamayanhamayan.com/entry/2019/08/25/090415\n\nint main(){\n\tint N,H,W;\n\tll ans = 0;\n\tcin >> N >> H >> W;\n\tUnionFind uf(H+W+6);\n\tpriority_queue< pair<ll,P> > pq;\n\tFOR(i,0,N){\n\t\tint r,c,a;\n\t\tcin >> r >> c >> a;\n\t\tpq.push({a,{r,c}});\n\t}\n\tFOR(i,0,N){\n\t\tauto X = pq.top();\n\t\tint h = X.second.first;\n\t\tint w = X.second.second;\n\t\tint a = X.first;\n\t\tpq.pop();\n\t\tif(not uf.same(h,w+H)){\n\t\t\tans += a;\n\t\t\tuf.unite(h,w+H);\n\t\t}else if(not uf.same(h,H+W+2)){\n\t\t\tans += a;\n\t\t\tuf.unite(h,H+W+2);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define LOCAL\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define FAST ios_base::sync_with_stdio(false); cin.tie(0);\n#define LLINF ((long long) 1e18)//1234567890987654321\n#define INF 1234567890ll\n#define pb push_back\n#define eb emplace_back\n#define ins insert\n#define f first\n#define s second\t\n#define db 0\n#define EPS (1e-7)    //0.0000001 the value\n#define PI (acos((ld)-1.0))\n#define MAXN (200006)\n#define ll long long int \n#define ld long double\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());    //can be used by calling rng() or shuffle(A, A+n, rng)\n#define FOR(ii, ss, ee) for(ll ii = (ss); ii <= (ll)(ee); ++ii)\n#define DEC(ii, ss, ee) for(ll ii = (ss); ii >= (ll)(ee); --ii)\n#define space \" \"\n#define cbr cerr << \"hi\\n\"\n#define mmst(x, v) memset((x), v, sizeof ((x)))\n#define siz(x) ((ll)x.size())\n#define ph push\n#define btinpct(x) __builtin_popcountll((x))\n#define MSB(bm) ((bm==0)?-1:(63-__builtin_clzll((bm))))\n#define all(x) (x).begin(), (x).end()\n#define lbd(x, y) lower_bound(all(x), y)\n#define ubd(x, y) upper_bound(all(x), y)\ntypedef pair <ll, ll> pi;\ntypedef pair <ll, pi> spi;\ntypedef pair <pi, pi> dpi;\ninline ll rand(ll x, ll y) { ++y; return (rng() % (y-x)) + x; } //inclusivesss\nstring to_string(char c) {string s(1,c);return s;}string to_string(bool b){return (b ? \"true\" : \"false\");}template <typename A, typename B>string to_string(pair<A, B> p) {return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";}template <typename A>string to_string(A v) {bool first = true;string res = \"{\";for (const auto &x : v) {if (!first) {res += \", \";}first = false;res += to_string(x);}res += \"}\";return res;}void degug_out() { cerr << endl; }template <typename Head, typename... Tail>void degug_out(Head H, Tail... T) {cerr << \" \" << to_string(H);degug_out(T...);}inline ll gcd(ll a,ll b){if(a>b)swap(a,b);if(a==0)return b;return gcd(b%a,a);}\n#ifdef LOCAL\n// #define degug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", degug_out(__VA_ARGS__)\n#else\n// #define degug(...) 663\n#define cerr if(0)cout\n#endif\n#warning \"// FOR has been inclusive now!!!!\"\nll n, h, w;\nvector<spi>edges;\nstruct ufds_ {\n\tint p[MAXN], edges[MAXN], sz[MAXN];\n\tufds_() {\n\t\tFOR(i,0,MAXN-1) p[i]=i, sz[i]=1, edges[i]=0; \n\t}\n\tvoid merge(ll x,ll y) {\n\t\tx=find(x), y=find(y);\n\t\tif(x==y) {\n\t\t\tedges[x] ++;\n\t\t} else {\n\t\t\tsz[y]+=sz[x];\n\t\t\tp[x]=y;\n\t\t\tedges[y]+=edges[x]+1;\n\t\t\tsz[x]=edges[x]=-INF;\n\t\t}\n\t}\n\tll gete(ll x) { return edges[find(x)]; }\n\tll gets(ll x) { return sz[find(x)]; }\n\tll find(ll x) { return (p[x]==x)?x:p[x]=find(p[x]); }\n\tbool same(ll a,ll b) { return find(a)==find(b); }\n} ufds;\nint main()\n{\n\tFAST\n\tcin>>n>>h>>w;\n\tedges.resize(n);\n\tFOR(i,0,n-1){\n\t\tcin>>edges[i].s.f>>edges[i].s.s>>edges[i].f;\n\t\tedges[i].s.s+=h;\n\t}\n\tsort(all(edges),greater<spi>());\n\tll ans=0;\n\tfor(auto i:edges) {\n\t\tll a=i.s.f, b=i.s.s;\n\t\tif(ufds.gete(a)+ufds.gete(b)+1<=ufds.gets(a)+ufds.gets(b)){\n\t\t\tufds.merge(a,b);\n\t\t\tans+=i.f;\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fto(i,a,b) for(int i=a; i<=b; ++i)\n#define fdto(i,a,b) for(int i=a; i>=b; --i)\n#define pb push_back\n#define ll long long\n#define pii pair<int,int>\n#define st first\n#define nd second\n#define maxn 200005\n#define Ntu \"bai5\"\n\nusing namespace std;\n\nstruct edge{\n\tint u,v,w;\n};\n\nlong long rs=0;\nint par[maxn],ed[maxn]={},sz[maxn];\n\nint root(int u){\n\tif(par[u]!=u) return par[u]=root(par[u]);\n\treturn u;\n}\n\nvoid Merge(int u, int v, int w){\n\tint ru=root(u),rv=root(v);\n\tif(ru==rv){\n\t\tif(sz[ru]>ed[ru]){\n\t\t\ted[ru]++;\n\t\t\trs+=w;\n\t\t}\n\t}\n\telse{\n\t\tif(sz[ru]+sz[rv]>ed[ru]+ed[rv]){\n\t\t\tpar[rv]=ru;\n\t\t\tsz[ru]+=sz[rv];\n\t\t\ted[ru]+=ed[rv]+1;\n\t\t\trs+=w;\n\t\t}\n\t}\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    //freopen(Ntu\".inp\",\"r\",stdin);\n    //freopen(Ntu\".out\",\"w\",stdout);\n    cin.tie(NULL);cout.tie(NULL);\n\tint p,h,w;\n\tcin >> p >> h >> w;\n\tfor(int i=0;i<h+w;i++){\n\t\tpar[i]=i;\n\t\tsz[i]=1;\n\t}\n\tvector <edge> e(p);\n\tfor(int i=0;i<p;i++)\n    {\n\t\tcin >> e[i].u >> e[i].v >> e[i].w;\n\t\te[i].u--;e[i].v--;\n\t}\n\tsort(e.begin(),e.end(),[](edge &a, edge &b)\n    {\n\t\treturn (a.w>b.w);\n\t});\n\tfor(int i=0;i<p;i++) Merge(e[i].u,h+e[i].v,e[i].w);\n\tcout << rs;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n#include <valarray>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++)\n//const ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b97f4a7c15 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a % b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nint popcnt(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn __builtin_popcountll(a);\n#elif defined _WIN64\n\treturn _mm_popcnt_u64(a);\n#else\n\treturn _mm_popcnt_u32(a >> 32) + _mm_popcnt_u32(a);\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n#endif\n}\nint BitScanF(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn __builtin_ctzll(a);\n#elif defined _WIN64\n\tunsigned long ret;\n\t_BitScanForward64(&ret, a);\n\treturn a;\n#else\n\tunsigned long ret;\n\tif (!(unsigned long)a) {\n\t\t_BitScanForward(&ret, a);\n\t\tret += 32;\n\t}\n\telse _BitScanForward(&ret, (unsigned long)a);\n\treturn ret;\n#endif\n}\nint BitScanR(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn 63 - __builtin_clzll(a);\n#elif defined _WIN64\n\tunsigned long ret;\n\t_BitScanReverse64(&ret, a);\n\treturn a;\n#else\n\tunsigned long ret;\n\tif (a >> 32) {\n\t\t_BitScanReverse(&ret, a);\n\t\tret += 32;\n\t}\n\telse _BitScanReverse(&ret, (unsigned long)a);\n\treturn ret;\n#endif\n}\ntemplate<class T>\nclass matrix {\npublic:\n\tvector<valarray<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, valarray<T>(e, m == -1 ? n : m)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)ret[i] += obj[i][j] * p.obj[j];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tbool operator==(const matrix&p) {\n\t\tif (s != p.s)return 0;\n\t\tfor (int i = 0; i<s.first; i++)for (int j; j< s.second; j++)if (obj[i][j] != p.obj[i][j])return 0;\n\t\treturn 1;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\tvalarray<T>& operator[](int t) {\n\t\treturn obj[t];\n\t}\n\tvoid gauss() {\n\t\tif (size().first + 1 != size().second)return;\n\t\trep(i, size().first) {\n\t\t\tint p = i;\n\t\t\trepi(j, i, size().first)if (abs(obj[j][i]) > abs(obj[p][i]))p = j;\n\t\t\tswap(obj[i], obj[p]);\n\t\t\tif (abs(obj[i][i]) < 1e-8)return;//contniue;\n\t\t\trepi(j, i + 1, size().second)obj[i][j] /= obj[i][i];\n\t\t\trep(j, size().first) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\trepi(k, i + 1, size().second)obj[j][k] -= obj[j][i] * obj[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\ntemplate<class T>\nstd::pair<matrix<T>, vector<int>> LU_decomposition(matrix<T> a) {\n\tif (a.size().first != a.size().second)throw runtime_error(\"matrix error\");\n\tstd::vector<int> pi(a.size().first);\n\tstd::iota(ALL(pi), 0);\n\tvalarray<T> tmp(a.size().first);\n\tfor (int i = 0; i < a.size().first; i++) {\n\t\t//int pivot = i;\n\t\t//T max = abs(a[i][i]);\n\t\t//for (int j = i + 1; j < a.size().first; j++) {\n\t\t//\tif (max < abs(a[j][i])) {\n\t\t//\t\tmax = abs(a[j][i]);\n\t\t//\t\tpivot = j;\n\t\t//\t}\n\t\t//}\n\t\t//std::swap(i, pivot);\n\t\t//pi.push_back(pivot);\n\t\tstd::slice slice(i + 1, a.size().first - i - 1, 1);\n\t\tfor (int j = i + 1; j < a.size().first; j++) {\n\t\t\ttmp[slice] = a[i][slice];\n\t\t\ttmp *= a[j][i] / a[i][i];\n\t\t\ta[j][slice] -= tmp[slice];\n\t\t\ta[j][i] = a[j][i] / a[i][i];\n\t\t}\n\t}\n\treturn std::make_pair(std::move(a), std::move(pi));\n}\ntemplate<class T>\nmatrix<T>LU_solve(pair<matrix<T>, std::vector<int>> a, matrix<T> b) {\n\tauto pi = std::move(a.second);\n\tauto A = std::move(a.first);\n\tif (A.size().first != A.size().second || A.size().first != b.size().first)throw runtime_error(\"matrix error\");\n\tfor (int i = 0; i < A.size().first; i++) {\n\t\tstd::swap(b[i], b[pi[i]]);\n\t}\n\tfor (int i = 0; i < A.size().first; i++) {\n\t\tfor (int j = 0; j < i; j++)b[i] -= A[i][j] * b[j];\n\t}\n\tfor (int i = A.size().first - 1; i >= 0; i--) {\n\t\tfor (int j = i + 1; j < A.size().first; j++)b[i] -= A[i][j] * b[j];\n\t\tb[i] /= A[i][i];\n\t}\n\treturn b;\n}\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned long long exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (res.obj[0].size() > 100) {\n\t\t\tint a = 0;\n\t\t}\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned long long exp, ll m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (res.obj[0].size() > 100) {\n\t\t\tint a = 0;\n\t\t}\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tvoid propagate(int a, int b, int k, int l, int r, int p) {\n\t\tif (r <= a || b <= l)return;\n\t\tif (a <= l && r <= b) {\n\t\t\tobj[k].second += p;\n\t\t\t(obj[k].first *= pow(2, p, (ll)1e9 + 7)) %= (ll)(1e9 + 7);\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tif (obj[k].second) {\n\t\t\t\t(obj[k * 2 + 1].first *= pow(2, obj[k].second, (ll)1e9 + 7)) %= (ll)(1e9 + 7);\n\t\t\t\t(obj[k * 2 + 2].first *= pow(2, obj[k].second, (ll)1e9 + 7)) %= (ll)(1e9 + 7);\n\t\t\t\tobj[k * 2 + 1].second += obj[k].second;\n\t\t\t\tobj[k * 2 + 2].second += obj[k].second;\n\t\t\t}\n\t\t\tpropagate(a, b, k * 2 + 1, l, (l + r) / 2, p), propagate(a, b, k * 2 + 2, (l + r) / 2, r, p);\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tT query(int a, int b) {//[a,b)\n\t\t//propagate(a, b, 0);\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid propagate(int a, int b, int p = 1) {//[a,b)\n\t\treturn propagate(a, b, 0, 0, offset + 1, p);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, const T &a) {\n\t\t//propagate(k, k + 1, 0);\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//多次元BITはループをネストすればいいらしい。\n\tvector<T> bit;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= bit.size()) {\n\t\t\tbit[i - 1] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i - 1];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT<T> b0, b1;\n\tint n;\n\trangeadd(int n) :b0(n), b1(n), n(n) {}\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\nclass Flow {\npublic:\n\tint V;\n\tstruct edge { int to, cap, rev, cost, add; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint res = 0;\n\tint flow = 0;\n\tint s, t;\n\tint max_flow(int s, int t, int fmax = numeric_limits<int>::max()) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, fmax))>0) {\n\t\t\t\tflow += f;\n\t\t\t\tfmax -= f;\n\t\t\t}\n\t\t\tif (fmax == 0)return flow;\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tFlow(int size, int s, int t) :G(size + 1), V(size + 1), s(s), t(t) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost,1 });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost,0 });\n\t}\n\tvoid remove_edge_max(int from, int to, int cap, int cost = 0) {\n\t\tfor (auto &x : G[from]) {\n\t\t\tif (!x.add || x.to != to || x.cap + G[to][x.rev].cap != cap || x.cost != cost)continue;\n\t\t\tint prev = flow;\n\t\t\tint cap = G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tcap -= max_flow(from, to, cap) - prev;\n\t\t\tmax_flow(t, to, cap);\n\t\t\tmax_flow(from, s, cap);\n\t\t\tflow = prev - cap;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvoid remove_edge_cost(int from, int to, int cap, int cost = 0) {\n\t\tfor (auto &x : G[from]) {\n\t\t\tif (!x.add || x.to != to || x.cap + G[to][x.rev].cap != cap || x.cost != cost)continue;\n\t\t\tcost += G[to][x.rev].cap*G[to][x.rev].cost;\n\t\t\tint cap = G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tmin_cost_flow(from, to, cap);\n\t\t\tbreak;\n\t\t}\n\t}\n\tint max_flow() {\n\t\treturn max_flow(s, t);\n\t}\n\tint min_cost_flow(int f) {\n\t\treturn min_cost_flow(s, t, f);\n\t}\n};\nll extgcd(ll a, ll b, ll&x, ll&y) {\n\tint d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a%b, y, x);\n\t\ty -= (a / b)*x;\n\t}\n\telse {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\nll mod_inv(ll a, ll m) {\n\tll x, y;\n\textgcd(a, m, x, y);\n\treturn(m + x % m) % m;\n}\npll linear_congruence(const vector<ll>& A, const vll& B, const vll&M) {\n\tll x = 0, m = 1;\n\tfor (int i = 0; i < A.size(); i++) {\n\t\tll a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n\t\tif (b%d != 0)return make_pair(0, -1);\n\t\tll t = b / d * mod_inv(a / d, M[i] / d) % (M[i] / d);\n\t\t//if (x + m * t < 0)return pll(x%m, m);\n\t\tx = x + m * t;\n\t\tm *= M[i] / d;\n\t}\n\treturn make_pair(x%m, m);\n}\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//円の接線?\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//面積??\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\nstruct unionfind_ {\n\tvector<int> par, rank, size_,a;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind_(int n) :par(n), rank(n), size_(n, 1),a(n) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tcmin(a[x],a[y]);\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T>\nclass lazysegtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse {\n\t\t\tT ret(e);\n\t\t\tobj[k].propagate(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t\treturn ret.merge(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t\t}\n\t}\n\tvoid propagateall(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l || l == r - 1)return;\n\t\tobj[k].propagate(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\tpropagateall(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tpropagateall(a, b, k * 2 + 2, (l + r) / 2, r);\n\t}\n\ttemplate<class Param>\n\tT update(int a, int b, int k, int l, int r, const Param& param) {\n\t\tif (r <= a || b <= l)return obj[k];\n\t\tif (a <= l && r <= b) {\n\t\t\tobj[k].update(param);\n\t\t\treturn obj[k];\n\t\t}\n\t\tobj[k].propagate(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\treturn obj[k].merge(update(a, b, k * 2 + 1, l, (l + r) / 2, param), update(a, b, k * 2 + 2, (l + r) / 2, r, param));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\ttemplate<class Param>\n\tvoid update(int a, int b, Param&& param) {\n\t\tupdate(a, b, 0, 0, offset + 1, param);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i].merge(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid propagateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tupdateall(l, r, 0, 0, offset + 1);\n\t}\n\t/*\n\tvoid update(int k, T &a) {\n\tk += offset;\n\tobj[k] = a;\n\twhile (k) {\n\tk = k - 1 >> 1;\n\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t}\n\t}*/\n\tlazysegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\tlazysegtree(vector<T> &vec, T e) :obj(bufsize(vec.size()), e), e(e) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\nclass lazyRMQ_t {\n\tll min, set;\npublic:\n\tll getmin() {\n\t\treturn min;\n\t}\n\tlazyRMQ_t() {\n\t\tmin = numeric_limits<ll>::max() / 2; set = min;\n\t}\n\tlazyRMQ_t(ll a, ll b = 0) {\n\t\tmin = a; set = b;\n\t}\n\tvoid propagate(lazyRMQ_t &a, lazyRMQ_t &b) {\n\t\tcmin(a.min, set);\n\t\tcmin(b.min, set);\n\t\tcmin(a.set, set);\n\t\tcmin(b.set, set);\n\t\tset = numeric_limits<ll>::max() / 2;\n\t}\n\tlazyRMQ_t& merge(const lazyRMQ_t &a, const lazyRMQ_t &b) {\n\t\tmin = std::min(a.min, b.min);\n\t\tset = numeric_limits<ll>::max() / 2;\n\t\treturn *this;\n\t}\n\tlazyRMQ_t& update(ll k) {\n\t\tcmin(min, k);\n\t\tcmin(set, k);\n\t\treturn *this;\n\t}\n};\nint check(array<int, 4> &a, array<int, 4> &b) {\n\tif (a == b)return 0;\n\tif (a[0] < b[0] && a[1] < b[1])return b[2];\n\tif (b[0] < a[0] && b[1] < a[1])return a[2];\n\treturn -1;\n}\nint main() {\n\tint n;\n\tint h, w;\n\tcin >> n >> h >> w;\n\tva<int, 3> a(n);\n\trep(i, n)rep(j, 3)cin >> a[i][j];\n\trep(i, n)rep(j, 2)a[i][j]--;\n\tFlow f(n + h + w + 2, n + h + w, n + h + w + 1);\n\trep(i, n) {\n\t\tf.add_edge(n + h + w, i, 1, -a[i][2]);\n\t\tf.add_edge(i, n + a[i][0], 1);\n\t\tf.add_edge(i, n + h + a[i][1], 1);\n\t}\n\trep(i, h)f.add_edge(n + i, n + h + w + 1, 1);\n\trep(i, w)f.add_edge(n + h + i, n + h + w + 1, 1);\n\tcout << -f.min_cost_flow(h + w) << endl;\n}\n//template<class T, class map = std::unordered_map<T,unique_ptr<node>>>\n/*class AhoCorasick {\nstruct node {\nmap<char,unique_ptr<node>> next;\nnode* fail = nullptr, *match_list = nullptr;\nstd::vector<int> match;\n}root;\nint pattern;\n//template<class string>\nAhoCorasick(std::vector<string> &vs) :pattern(vs.size()) {\nroot.fail = &root;\nfor (int i = 0; i < vs.size(); i++) {\nnode* now = &root;\nfor (auto c : vs[i]) {\nif (!now->next[c])now->next[c]=make_unique<node>();\nnow = now->next[c].get();\n}\nnow->match.push_back(i);\n}\nstd::queue<node*> que;\nque.push(&root);\nwhile (!que.empty()) {\nauto now = que.front();\nque.pop();\nfor (auto &next : now->next) {\nif (!next.second)continue;\nif (now->fail->next.count(next.first))next.second->fail = now->fail->next[next.first].get();\nelse next.second->fail = now->fail->fail;\n//next.second->match.insert(next.second->match.end(), next.second->fail->match.begin(), next.second->fail->match.end());\nif (next.second->fail->match.empty())next.second->match_list = next.second->fail->match_list;\nelse next.second->match_list = next.second->fail;\nque.push(next.second.get());\n}\n}\n}\nauto match_n(string str) {\nvector<int> num(pattern);\n\n}\nauto match_list(string str) {\nvector<pair<int, int>> list;\nauto now = &root;\nfor (int i = 0; i < str.size(); i++) {\nif (now->next.count(str[i]))now = now->next[str[i]].get();\nelse now = now->fail;\nauto match = now->match_list;\ndo {\nmatch\n}\n}\n}\n};*/\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <cstddef>\n#include <cstdint>\n#include <iostream>\n#include <vector>\n\nnamespace n91 {\n\n  using i8 = std::int_fast8_t;\n  using i32 = std::int_fast32_t;\n  using i64 = std::int_fast64_t;\n  using u8 = std::uint_fast8_t;\n  using u32 = std::uint_fast32_t;\n  using u64 = std::uint_fast64_t;\n  using isize = std::ptrdiff_t;\n  using usize = std::size_t;\n\n  constexpr usize operator\"\" _z(unsigned long long x) noexcept {\n    return static_cast<usize>(x);\n  }\n\n  class rep {\n    const usize f, l;\n\n  public:\n    class itr {\n      friend rep;\n      usize i;\n      constexpr itr(const usize x) noexcept : i(x) {}\n\n    public:\n      void operator++() noexcept { ++i; }\n      constexpr usize operator*() const noexcept { return i; }\n      constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n    };\n    constexpr rep(const usize first, const usize last) noexcept\n      : f(first), l(last) {}\n    constexpr itr begin() const noexcept { return itr(f); }\n    constexpr itr end() const noexcept { return itr(l); }\n  };\n  class revrep {\n    const usize f, l;\n\n  public:\n    class itr {\n      friend revrep;\n      usize i;\n      constexpr itr(usize x) noexcept : i(x) {}\n\n    public:\n      void operator++() noexcept { --i; }\n      constexpr usize operator*() const noexcept { return i; }\n      constexpr bool operator!=(const itr x) const noexcept { return i != x.i; }\n    };\n    constexpr revrep(usize first, usize last) noexcept : f(--first), l(--last) {}\n    constexpr itr begin() const noexcept { return itr(l); }\n    constexpr itr end() const noexcept { return itr(f); }\n  };\n  template <class T> using vec_alias = std::vector<T>;\n  template <class T> auto md_vec(const usize n, const T& value) {\n    return std::vector<T>(n, value);\n  }\n  template <class... Args> auto md_vec(const usize n, Args... args) {\n    return std::vector<decltype(md_vec(args...))>(n, md_vec(args...));\n  }\n  template <class T> constexpr T difference(const T& a, const T& b) {\n    return a < b ? b - a : a - b;\n  }\n  template <class T> T scan() {\n    T ret;\n    std::cin >> ret;\n    return ret;\n  }\n\n} // namespace n91\n\n#include <cstdint>\n\nnamespace n91 {\n\n  constexpr std::uint_fast64_t totient(std::uint_fast64_t x) noexcept {\n    using u64 = std::uint_fast64_t;\n    u64 ret = x;\n    for (u64 i = static_cast<u64>(2); i * i <= x; ++i) {\n      if (x % i == static_cast<u64>(0)) {\n        ret -= ret / i;\n        x /= i;\n        while (x % i == static_cast<u64>(0)) {\n          x /= i;\n        }\n      }\n    }\n    if (x != static_cast<u64>(1)) {\n      ret -= ret / x;\n    }\n    return ret;\n  }\n\n  template <std::uint_fast64_t Modulus,\n    std::uint_fast64_t InverseExp =\n    totient(Modulus) - static_cast<std::uint_fast64_t>(1)>\n    class modint {\n    using u64 = std::uint_fast64_t;\n\n    static_assert(Modulus < static_cast<u64>(1) << static_cast<u64>(32),\n      \"Modulus must be less than 2**32\");\n\n    u64 a;\n\n    constexpr modint& negate() noexcept {\n      if (a != static_cast<u64>(0)) {\n        a = Modulus - a;\n      }\n      return *this;\n    }\n\n    public:\n      constexpr modint(const u64 x = static_cast<u64>(0)) noexcept\n        : a(x% Modulus) {}\n      constexpr u64& value() noexcept { return a; }\n      constexpr const u64& value() const noexcept { return a; }\n      constexpr modint operator+() const noexcept { return modint(*this); }\n      constexpr modint operator-() const noexcept { return modint(*this).negate(); }\n      constexpr modint operator+(const modint rhs) const noexcept {\n        return modint(*this) += rhs;\n      }\n      constexpr modint operator-(const modint rhs) const noexcept {\n        return modint(*this) -= rhs;\n      }\n      constexpr modint operator*(const modint rhs) const noexcept {\n        return modint(*this) *= rhs;\n      }\n      constexpr modint operator/(const modint rhs) const noexcept {\n        return modint(*this) /= rhs;\n      }\n      constexpr modint& operator+=(const modint rhs) noexcept {\n        a += rhs.a;\n        if (a >= Modulus) {\n          a -= Modulus;\n        }\n        return *this;\n      }\n      constexpr modint& operator-=(const modint rhs) noexcept {\n        if (a < rhs.a) {\n          a += Modulus;\n        }\n        a -= rhs.a;\n        return *this;\n      }\n      constexpr modint& operator*=(const modint rhs) noexcept {\n        a = a * rhs.a % Modulus;\n        return *this;\n      }\n      constexpr modint& operator/=(modint rhs) noexcept {\n        u64 exp = InverseExp;\n        while (exp) {\n          if (exp % static_cast<u64>(2) != static_cast<u64>(0)) {\n            *this *= rhs;\n          }\n          rhs *= rhs;\n          exp /= static_cast<u64>(2);\n        }\n        return *this;\n      }\n      constexpr bool operator==(const modint rhs) const noexcept {\n        return a == rhs.a;\n      }\n      constexpr bool operator!=(const modint rhs) const noexcept {\n        return a != rhs.a;\n      }\n  };\n\n  template <class T, std::uint_fast64_t v> class modint_constant {\n  public:\n    static constexpr T value = static_cast<T>(v);\n\n    using value_type = T;\n  };\n\n} // namespace n91\n\n#include <cassert>\n#include <cstddef>\n#include <utility>\n#include <vector>\n\nnamespace n91 {\n\n  class incremental_connectivity {\n  protected:\n    class node_type;\n\n  public:\n    using container_type = std::vector<node_type>;\n    using size_type = typename container_type::size_type;\n    class connected_component {\n      friend incremental_connectivity;\n      const node_type& root;\n      constexpr connected_component(const node_type& root) noexcept\n        : root(root) {}\n\n    public:\n      constexpr size_type representative() const noexcept { return root.parent; }\n      constexpr size_type size() const noexcept { return root.size; }\n      constexpr bool operator==(const connected_component& rhs) const noexcept {\n        return &root == &rhs.root;\n      }\n      constexpr bool operator!=(const connected_component& rhs) const noexcept {\n        return &root != &rhs.root;\n      }\n    };\n\n  protected:\n    class node_type {\n    public:\n      size_type parent, size;\n    };\n    container_type tree;\n\n  public:\n    incremental_connectivity() : tree() {}\n    explicit incremental_connectivity(const size_type size) : tree(size, { 0, 1 }) {\n      for (size_type i = 0; i < size; ++i)\n        tree[i].parent = i;\n    }\n\n    bool empty() const { return tree.empty(); }\n    size_type size() const { return tree.size(); }\n\n    connected_component find_cc(size_type x) {\n      while (tree[x].parent != x) {\n        x = tree[x].parent = tree[tree[x].parent].parent;\n      }\n      return connected_component(tree[x]);\n    }\n\n    std::pair<size_type, size_type> unite(size_type x, size_type y) {\n      assert(x < size());\n      assert(y < size());\n      x = find_cc(x).representative();\n      y = find_cc(y).representative();\n      if (x != y) {\n        if (tree[x].size < tree[y].size)\n          std::swap(x, y);\n        tree[x].size += tree[y].size;\n        tree[y].parent = x;\n      }\n      return { x, y };\n    }\n  };\n\n} // namespace n91\n\n#include <algorithm>\n#include <iostream>\n#include <tuple>\n#include <utility>\n\nnamespace n91 {\n\n  void main_() {\n    const usize n = scan<usize>();\n    const usize h = scan<usize>();\n    const usize w = scan<usize>();\n    std::vector<bool> namori(h + w, false);\n    struct card_type {\n      usize r, c;\n      u64 a;\n    };\n    std::vector<card_type> card(n);\n    for (auto& e : card) {\n      e.r = scan<usize>() - 1_z;\n      e.c = scan<usize>() - 1_z;\n      e.a = scan<u64>();\n    }\n    std::sort(card.begin(), card.end(),\n      [](const auto& l, const auto& r) { return r.a < l.a; });\n    u64 ans = static_cast<u64>(0);\n    incremental_connectivity ic(h + w);\n    for (const auto& e : card) {\n      usize x = e.r;\n      usize y = e.c + h;\n      x = ic.find_cc(x).representative();\n      y = ic.find_cc(y).representative();\n      if (x == y) {\n        if (!namori[x]) {\n          namori[x] = true;\n          ans += e.a;\n        }\n        continue;\n      }\n      if (namori[x] && namori[y]) {\n        continue;\n      }\n      std::tie(x, y) = ic.unite(x, y);\n      namori[x] = namori[x] || namori[y];\n      ans += e.a;\n    }\n\n    std::cout << ans << std::endl;\n  }\n\n} // namespace n91\n\nint main() {\n  n91::main_();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst int maxn = 2e5 + 10;\n\nvector<int> g[maxn];\nint mt[maxn];\nint used[maxn];\nint cn = 1;\nvector<ll> prm = { 0, 1 };\n\nbool dfs(int v) {\n\tif (used[v] == cn) return false;\n\n\tused[v] = cn;\n\n\tll rnd = rand() % 2;\n\tif (rnd == 1) {\n\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\tint u = g[v][i];\n\t\t\tif (mt[u] == -1 || dfs(mt[u])) {\n\t\t\t\tmt[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\tint u = g[v][1 - i];\n\t\t\tif (mt[u] == -1 || dfs(mt[u])) {\n\t\t\t\tmt[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\treturn false;\n}\n\nint main()\n{\n\tfastInp;\n\n\tll n, h, w;\n\tcin >> n >> h >> w;\n\n\tll vals = 0, ans = 0;\n\tvector<tuple<ll, ll, ll>> vec;\n\tfor (int i = 0; i < h + w + 3; i++) mt[i] = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tll r, c, a;\n\t\tcin >> r >> c >> a;\n\t\tr--; c--;\n\t\tvec.push_back({ a, r, c });\n\t}\n\n\tsort(vec.rbegin(), vec.rend());\n\n\tll cnt = 0;\n\tll hw = h + w;\n\tfor (int i = 0; i < n; i++) {\n\t\tll r = get<1>(vec[i]), c = get<2>(vec[i]), a = get<0>(vec[i]);\n\t\tif (mt[r] == -1 || mt[c + h + 1] == -1) {\n\t\t\tvals++;\n\t\t\tcnt++;\n\t\t\tg[i].push_back(r);\n\t\t\tg[i].push_back(c + h + 1);\n\t\t\tif (mt[r] == -1) {\n\t\t\t\tmt[r] = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmt[c + h + 1] = i;\n\t\t\t}\n\t\t\tans += a;\n\t\t\tcontinue;\n\t\t}\n\t\tcn++;\n\t\tvals++;\n\t\t\n\t\tg[i].push_back(r);\n\t\tg[i].push_back(c + h + 1);\n\t\tcnt += dfs(i);\n\n\t\tif (cnt >= vals) {\n\t\t\tans += a;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tvals--;\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> ii;\ntypedef long long ll;\n\nconst int Maxn = 100005;\n\nint n, H, W;\nint R[Maxn], C[Maxn], A[Maxn];\nvector <ii> byRow[Maxn];\nset <ii> byCol[Maxn];\nll res;\n\nint main()\n{\n    scanf(\"%d %d %d\", &n, &H, &W);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &R[i], &C[i], &A[i]);\n        byRow[R[i]].push_back(ii(A[i], i));\n        byCol[C[i]].insert(ii(A[i], i));\n    }\n    for (int j = 1; j <= W; j++)\n        if (!byCol[j].empty()) {\n            auto it = byCol[j].end(); it--;\n            res += it->first; byCol[j].erase(it);\n        }\n    for (int i = 1; i <= H; i++) {\n        int best = -1;\n        for (int j = 0; j < byRow[i].size(); j++) {\n            int ind = byRow[i][j].second;\n            if (byCol[C[ind]].find(ii(A[ind], ind)) != byCol[C[ind]].end()) {\n                if (best == -1 || A[ind] > A[best]) best = ind;\n            } else if (!byCol[C[ind]].empty()) {\n                auto it = byCol[C[ind]].end(); it--;\n                if (best == -1 || it->first > A[best]) best = it->second;\n            }\n        }\n        if (best != -1) { res += A[best]; byCol[C[best]].erase(ii(A[best], best)); }\n    }\n    printf(\"%lld\\n\", res);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <assert.h>\n#include <deque>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <math.h>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define sz(x) ((int)(x).size())\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<ld> vld;\ntypedef vector<vector<int>> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> vvl;\ntypedef vector<vector<ld>> vvd;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\n\nstruct DSU {\n    DSU(ll n) : parent(n), rank(n, 0) {\n        std::iota(parent.begin(), parent.end(), 0);\n    }\n    void make_set(ll v) {\n        parent[v] = v;\n        rank[v] = 0;\n    }\n\n    ll find_set(ll v) {\n        if (v == parent[v]) return v;\n        return parent[v] = find_set(parent[v]);\n    }\n\n    void union_sets(ll a, ll b) {\n        a = find_set(a);\n        b = find_set(b);\n        if (a != b) {\n            if (rank[a] < rank[b]) swap(a, b);\n            parent[b] = a;\n            if (rank[a] == rank[b]) ++rank[a];\n        }\n    }\n    vl parent;\n    vl rank;\n};\n\nll n, h, w, ans;\n\nstruct Kek {\n    void read(ll ii) {\n        i = ii;\n        cin >> x >> y >> a;\n        --x, --y;\n    }\n    bool operator<(const Kek& other) const {\n        if (a != other.a) return a > other.a;\n        return i < other.i;\n    }\n    pll get_edge() { return { x, y + h }; }\n    ll x, y, a, i;\n};\n\nconst ll MAXN = 2e5 + 228;\nKek keks[MAXN];\nbool fucked[MAXN];\n\nint main() {\n    cout << setprecision(30);\n    ios_base::sync_with_stdio(false), cin.tie(0), cout.tie(0);\n\n    cin >> n >> h >> w;\n\n    for (int i = 0; i < n; ++i) {\n        keks[i].read(i);\n    }\n\n    sort(keks, keks + n);\n    DSU d(h + w + 10);\n    for (int i = 0; i < n; ++i) {\n        pll e = keks[i].get_edge();\n        ll v = e.fi;\n        ll u = e.se;\n        if (d.find_set(v) == d.find_set(u)) {\n            if (fucked[d.find_set(v)]) {\n                continue;\n            }\n            ans += keks[i].a;\n            // cerr << \"take \" << keks[i].x << \" \" << keks[i].y << \" \" << keks[i].a << \" \" << keks[i].i << endl;\n            fucked[d.find_set(v)] = true;\n        } else {\n            if (fucked[d.find_set(v)] && fucked[d.find_set(u)]) {\n                continue;\n            } else {\n                bool xx = fucked[d.find_set(v)] || fucked[d.find_set(u)];\n                fucked[d.find_set(v)] = xx;\n                fucked[d.find_set(u)] = xx;\n            }\n            ans += keks[i].a;\n            // cerr << \"take \" << keks[i].x << \" \" << keks[i].y << \" \" << keks[i].a << \" \" << keks[i].i << endl;\n            d.union_sets(v, u);\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\nconst int N = 1e5 + 5;\n\nint n, w, h;\nstruct edge { int u, v, w; } e[N];\nint fa[N << 1];\nbool ring[N << 1];\n\nint find(int x) {\n    return x == fa[x] ? x : fa[x] = find(fa[x]);\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> h >> w;\n    for (int i = 1; i <= w + h; i++)\n        fa[i] = i, ring[i] = false;\n    for (int i = 1; i <= n; i++)\n        cin >> e[i].u >> e[i].v >> e[i].w;\n    \n    sort(e + 1, e + 1 + n, [](const edge& x, const edge& y) {\n        return x.w > y.w;\n    });\n\n    long long ans = 0ll;\n    for (int i = 1; i <= n; i++) {\n        int u = e[i].u, v = e[i].v + h, w = e[i].w;\n        u = find(u), v = find(v);\n\n        if (u == v) {\n            if (!ring[u]) ring[u] = 1, ans += w;\n        } else {\n            if (!ring[u] || !ring[v]) {\n                ring[u] = ring[v] = ring[u] | ring[v];\n                fa[u] = v, ans += w;\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#define llint long long\n\nusing namespace std;\ntypedef pair<llint, llint> P;\ntypedef pair<llint, P> E;\n\nstruct UnionFind{\n\tint size;\n\tvector<int> parent;\n\tvector<int> Vnum, Enum;\n\t\n\tUnionFind(){}\n\tUnionFind(int size){\n\t\tthis->size = size;\n\t\tparent.resize(size+1);\n\t\tVnum.resize(size+1), Enum.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 0; i <= size; i++) parent[i] = i, Vnum[i] = 1, Enum[i] = 0;\n\t}\n\tint root(int i){\n\t\tif(parent[i] == i) return i;\n\t\treturn parent[i] = root(parent[i]);\n\t}\n\tbool same(int i, int j){\n\t\treturn root(i) == root(j);\n\t}\n\tvoid unite(int i, int j){\n\t\tint root_i = root(i), root_j = root(j);\n\t\tEnum[root_i]++;\n\t\tif(root_i == root_j) return;\n\t\tparent[root_i] = root_j;\n\t\tVnum[root_j] += Vnum[root_i];\n\t\tEnum[root_j] += Enum[root_i];\n\t}\n};\n\nllint n, h, w;\nvector<E> vec;\nUnionFind uf(200005);\n\nint main(void)\n{\n\tcin >> n >> h >> w;\n\tllint r, c, a;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> r >> c >> a;\n\t\tvec.push_back(make_pair(a, make_pair(r, c)));\n\t}\n\tsort(vec.rbegin(), vec.rend());\n\t\n\tllint ans = 0;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tllint u = vec[i].second.first, v = vec[i].second.second + 100000, w = vec[i].first;\n\t\tif(uf.same(u, v) && uf.Enum[uf.root(u)] >= uf.Vnum[uf.root(u)]) continue;\n\t\tif(!uf.same(u, v) && uf.Enum[uf.root(u)]+uf.Enum[uf.root(v)]+1 > uf.Vnum[uf.root(u)]+uf.Vnum[uf.root(v)]) continue;\n\t\tuf.unite(u, v);\n\t\tans += w;\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\n\nstruct Edge {\n  int u, v, w;\n  Edge(int u, int v, int w) : u(u), v(v), w(w) {}\n  bool operator <(const Edge &other) const {\n    return w > other.w;\n  }\n};\n\nconst int N = 2e5 + 7;\n\nint p[N];\nint phi[N];\n\nint get(int a) {\n  return (a == p[a] ? a : p[a] = get(p[a]));\n}\n\nbool join(int a, int b) {\n  a = get(a);\n  b = get(b);\n  if (a != b && phi[a] + phi[b] - 1 >= 0) {\n    p[a] = b;\n    phi[b] = phi[a] + phi[b] - 1;\n    return true;\n  } else if (a == b && phi[a] - 1 >= 0) {\n    --phi[a];\n    return true;\n  } else {\n    return false;\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int k, n, m;\n  cin >> k >> n >> m;\n  vector <int> x(k), y(k), a(k);\n  vector <Edge> E;\n  for (int i = 0; i < k; ++i) {\n    cin >> x[i] >> y[i] >> a[i];\n    --x[i], --y[i];\n    E.emplace_back(x[i], n + y[i], a[i]);\n  }\n  sort(E.begin(), E.end());\n  for (int i = 0; i < n + m; ++i) {\n    p[i] = i;\n    phi[i] = 1;\n  }\n  ll ans = 0;\n  for (auto e : E) {\n    if (join(e.u, e.v)) {\n      ans += e.w;\n    }\n  }\n  cout << ans << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Unionfind {\n  // tree number\n  vector<int> par;\n  // constructor\n  Unionfind(int n = 1) : par(n, -1) {}\n  // search root\n  int root(int x) {\n    if (par[x] < 0) return x;\n    return par[x] = root(par[x]);\n  }\n  // is same?\n  bool issame(int x, int y) { return root(x) == root(y); }\n\n  // add\n  // already added, return 0\n  bool uni(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) return 0;\n    if (par[x] > par[y]) swap(x, y);\n    par[x] += par[y];\n    par[y] = x;\n    return 1;\n  }\n  int size(int x) { return -par[root(x)]; }\n};\n\nstruct edge {\n  long long r, c, a;\n  edge(long long _r, long long _c, long long _a) : r(_r), c(_c), a(_a) {}\n  bool operator<(const edge &re) const {\n    if (a != re.a) return a < re.a;\n    if (r != re.r) return r < re.r;\n    return c < re.c;\n  }\n};\n\nlong long n, h, w, res = 0;\nvector<int> cnt;\npriority_queue<edge> pq;\nUnionfind uf;\n\nint main() {\n  cin >> n >> h >> w;\n  uf = Unionfind(h + w);\n  for (int i = 0; i < n; ++i) {\n    long long r, c, a;\n    cin >> r >> c >> a;\n    pq.push(edge(--r, h + (--c), a));\n  }\n  cnt.assign(h + w, 0);\n  for (int i = 0; i < n; ++i) {\n    edge e = pq.top();\n    pq.pop();\n    e.r = uf.root(e.r);\n    e.c = uf.root(e.c);\n    if (e.r != e.c) {\n      uf.uni(e.r, e.c);\n      cnt[uf.root(e.r)] = cnt[e.r] + cnt[e.c];\n    }\n    e.r = e.c = uf.root(e.r);\n    if (cnt[e.r] < uf.size(e.r)) {\n      ++cnt[e.r];\n      res += e.a;\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1 };\nvel dy = { 1,-1,0,0 };\nint sol(int p, vel& max_h, vvel& way) {\n\tif (max_h[p] == -1) {\n\t\tmax_h[p] = 0;\n\t\tfor (auto nex : way[p]) {\n\t\t\tmmax(max_h[p], sol(nex, max_h, way) + 1);\n\t\t}\n\t}\n\treturn max_h[p];\n}\nint inc(int a, veb& use) {\n\ta++;\n\twhile (!use[a]) { a++; }\n\treturn a;\n}\nsigned main() {\n\tomajinai;\n\tint n, h, w; cin >> n >> h >> w;\n\tvvel cxy(n);\n\tvvel y_i(w);\n\tvvel x_i(h);\n\trep(i, n) {\n\t\tint c, x, y; cin >> x >> y >> c; x--; y--;\n\t\tcxy[i] = { c,x,y };\n\t}\n\tsor(cxy);\n\trep(i, n) {\n\t\tint x = cxy[i][1];\n\t\tint y = cxy[i][2];\n\t\ty_i[y].push_back(i);\n\t\tx_i[x].push_back(i);\n\t}\n\tvel dp0(n, 0);\n\tvel dp1(n, 0);\n\tvel cnt(n, 0);\n\tvel sum(n + 1, 0);\n\trep(i, w) { \n\t\tsor(y_i[i]);\n\t\tif (y_i[i].size() != 0) {\n\t\t\tcnt[y_i[i].back()]++;\n\t\t}\n\t}\n\trep(i, h) { \n\t\tsor(x_i[i]);\n\t\tif (x_i[i].size() != 0) {\n\t\t\tcnt[x_i[i].back()]++;\n\t\t}\n\t}\n\trep(i, n) {\n\t\tint c = cxy[i][0];\n\t\tint x = cxy[i][1];\n\t\tint y = cxy[i][2];\n\t\tint it = lowerbound(x_i[x],i);\n\t\tit--;\n\t\tif (it >= 0) {\n\t\t\tint nind = x_i[x][it];\n\t\t\tif (cnt[nind] == 0) {\n\t\t\t\tmmax(dp1[i], cxy[nind][0]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmmax(dp1[i], dp1[nind]);\n\t\t\t}\n\t\t}\n\t\tit = lowerbound(y_i[y],i);\n\t\tit--;\n\t\tif (it >= 0) {\n\t\t\tint nind = y_i[y][it];\n\t\t\tif (cnt[nind] == 0) {\n\t\t\t\tmmax(dp1[i], cxy[nind][0]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmmax(dp1[i], dp1[nind]);\n\t\t\t}\n\t\t}\n\t\tint back = 0;\n\t\tif (i != 0) { back = dp0[i - 1]; }\n\t\tif (cnt[i] <= 1) {\n\t\t\tdp0[i] = back + cnt[i] * c;\n\t\t}\n\t\telse {\n\t\t\tdp0[i] = back + dp1[i] + c;\n\t\t}\n\t}\n\tcout << dp0.back() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef OUUAN\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#endif\n#include<bits/stdc++.h>\n\n#define int LoveLive\n//#define FAST_IOSTREAM 1\n\n#define For(i,l,r)for(int i=(l),i##end=(r);i<=i##end;++i)\n#define FOR(i,r,l)for(int i=(r),i##end=(l);i>=i##end;--i)\n#define SON(i,u)for(int i=head[u];i;i=nxt[i])\n#define ms(a,x)memset(a,x,sizeof(a))\n#define fi first\n#define se second\n#define pb emplace_back\n#define pq priority_queue\n#define isinf(x)(x>=INF?-1:x)\n#define y1 why_is_there_a_function_called_y1\n#define DEBUG(x)cerr<<(#x)<<\":\"<<x<<endl\nusing namespace std;\ntypedef long long LoveLive;typedef pair<int,int>pii;typedef vector<int>vi;\n#ifdef int\nconst int INF=0x3f3f3f3f3f3f3f3fll;\n#else\nconst int INF=0x3f3f3f3f;\n#endif\nconst double eps=1e-9;mt19937 rng(chrono::steady_clock::now().time_since_epoch().\ncount());int randint(int l,int r){int out=rng()%(r-l+1)+l;return out>=l?out:out+\nr-l+1;}\n#ifdef FAST_IOSTREAM\n#define br cout<<'\\n'\n#define sp cout<<' '\nlong long read(){long long x;cin>>x;return x;}template<typename T>void read(T&x){\ncin>>x;}template<typename T>void write(const T&x){cout<<x;}\n#else\n#define br putchar('\\n')\n#define sp putchar(' ')\ntemplate<typename T>typename enable_if<!is_integral<T>::value,void>::type read(T\n&x){cin>>x;}long long read(){char c;long long out=0,f=1;for(c=getchar();!isdigit\n(c)&&c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())\nout=(out<<3)+(out<<1)+c-'0';return out*f;}template<typename T>typename enable_if\n<is_integral<T>::value,T>::type read(T&x){char c;T f=1;x=0;for(c=getchar();!isdigit\n(c)&&c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())\nx=(x<<3)+(x<<1)+c-'0';return x*=f;}char read(char&x){for(x=getchar();isspace(x);\nx=getchar());return x;}double read(double&x){scanf(\"%lf\",&x);return x;}template<\ntypename T>typename enable_if<!is_integral<T>::value,void>::type write(const T&x\n){cout<<x;}template<typename T>typename enable_if<is_integral<T>::value,void>::type\nwrite(const T&x){if(x<0){putchar('-');write(-x);return;}if(x>9)write(x/10);putchar\n(x%10+'0');}void write(const char&x){putchar(x);}void write(const double&x){printf\n(\"%.10lf\",x);}\n#endif\ntemplate<typename T,typename...Args>void read(T&x,Args&...args){read(x);read(args\n...);}template<typename OutputIt,typename=typename enable_if<is_same<output_iterator_tag\n,typename iterator_traits<OutputIt>::iterator_category>::value||(\nis_base_of<forward_iterator_tag,typename iterator_traits<OutputIt>::iterator_category>::value\n&&!is_const<OutputIt>::value)>::type>void read(OutputIt __first,OutputIt __last){for(;__first\n!=__last;++__first)read(*__first);}template<typename InputIt,typename=typename enable_if\n<is_base_of<input_iterator_tag,typename iterator_traits<InputIt>::iterator_category\n>::value>::type>void wts(InputIt __first,InputIt __last){bool isFirst=true;for(;\n__first!=__last;++__first){if(isFirst)isFirst=false;else sp;write(*__first);}br;}\ntemplate<typename InputIt,typename=typename enable_if<is_base_of<input_iterator_tag\n,typename iterator_traits<InputIt>::iterator_category>::value>::type>void wtb(InputIt\n__first,InputIt __last){for(;__first!=__last;++__first){write(*__first);br;}}template\n<typename T>void wts(const T&x){write(x);sp;}template<typename T>void wtb(const\nT&x){write(x);br;}template<typename T>void wte(const T&x){write(x);exit(0);}template\n<typename T,typename...Args>void wts(const T&x,Args...args){wts(x);wts(args...);}\ntemplate<typename T,typename...Args>void wtb(const T&x,Args...args){wts(x);wtb(args\n...);}template<typename T,typename...Args>void wte(const T&x,Args...args){wts(x);\nwte(args...);}template<typename T>inline bool up(T&x,const T&y){return x<y?x=y,1\n:0;}template<typename T>inline bool dn(T&x,const T&y){return y<x?x=y,1:0;}\n\nconst int N = 100010;\nconst int mod = 1000000007;\n\nint n, h, w, ans, f[N << 1], siz[N << 1];\n\nstruct Node\n{\n\tint w, r, c;\n\tbool operator<(const Node& b) const\n\t{\n\t\treturn w > b.w;\n\t}\n} a[N];\n\nint find(int x)\n{\n\treturn x == f[x] ? x : f[x] = find(f[x]);\n}\n\nsigned main()\n{\n#ifdef FAST_IOSTREAM\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n#endif\n\t\n\tread(n, h, w);\n\t\n\tFor (i, 1, n) read(a[i].r, a[i].c, a[i].w);\n\t\n\tsort(a + 1, a + n + 1);\n\t\n\tFor (i, 1, w + h)\n\t{\n\t\tf[i] = i;\n\t\tsiz[i] = 1;\n\t}\n\n\tFor (i, 1, n)\n\t{\n\t\tif (find(a[i].r) != find(a[i].c + h))\n\t\t{\n\t\t\tif (siz[find(a[i].r)] + siz[find(a[i].c + h)])\n\t\t\t{\n\t\t\t\tsiz[find(a[i].r)] += siz[find(a[i].c + h)] - 1;\n\t\t\t\tf[find(a[i].c + h)] = find(a[i].r);\n\t\t\t\tans += a[i].w;\n\t\t\t}\n\t\t}\n\t\telse if (siz[find(a[i].r)])\n\t\t{\n\t\t\t--siz[find(a[i].r)];\n\t\t\tans += a[i].w;\n\t\t}\n\t}\n\t\n\twtb(ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 300100;\nint uf[maxn], xp[maxn];\nint find(int x){\n\tif(x == uf[x]) return x;\n\treturn uf[x] = find(uf[x]);\n}\nint main(){\n\tiota(uf, uf + maxn, 0);\n\tint n, h, w;\n\tcin >> n >> h >> w;\n\tvector<tuple<int, int, int> > eds;\n\tfor(int i = 0; i < n; i++){\n\t\tint x, y, z;\n\t\tcin >> x >> y >> z;\n\t\tx--;\n\t\ty--;\n\t\teds.push_back(make_tuple(-z, n + x, n + h + y));\n\t}\n\tsort(eds.begin(), eds.end());\n\tlong long ans = 0;\n\tfor(int i = 0; i < eds.size(); i++){\n\t\tint x, y, z;\n\t\ttie(z, x, y) = eds[i];\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y){\n\t\t\tif(xp[x] == 0){\n\t\t\t\txp[x] = 1;\n\t\t\t\tans -= z;\n\t\t\t}\n\t\t} else if(xp[x] + xp[y] <= 1){\n\t\t\tuf[y] = x;\n\t\t\txp[x] += xp[y];\n\t\t\tans -= z;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nstruct card{\n\tint r,c;\n\tll a;\n\tbool operator<(const card &rhs){\n\t\treturn (a>rhs.a);\n\t}\n};\n\ncard v[100100];\nint ufp[225816],ufv[225816],ufe[225816];\n\nvoid ufinit(int n){\n\tint i;\n\tfor(i=0; i<n; ++i){\n\t\tufp[i] = i;\n\t\tufv[i] = 1;\n\t}\n}\n\nint ufind(int x){\n\tif(ufp[x] == x){\n\t\treturn x;\n\t}\n\treturn ufp[x] = ufind(ufp[x]);\n}\n\nbool unionf(int x, int y){\n\tx = ufind(x);\n\ty = ufind(y);\n\tif(x==y){\n\t\tif(ufe[x]<ufv[x]){\n\t\t\t++ufe[x];\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(ufv[x]<ufv[y]){\n\t\tswap(x,y);\n\t}\n\tif(ufe[x]+ufe[y]<ufv[x]+ufv[y]){\n\t\tufv[x] += ufv[y];\n\t\tufe[x] += ufe[y]+1;\n\t\tufp[y] = x;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(void){\n\tint n,h,w,i;\n\tll ans = 0ll;\n\tcin >> n >> h >> w;\n\tufinit(h+w);\n\tfor(i=0; i<n; ++i){\n\t\tcin >> v[i].r >> v[i].c >> v[i].a;\n\t\t--v[i].r; --v[i].c; v[i].c += h;\n\t}\n\tsort(v,v+n);\n\tfor(i=0; i<n; ++i){\n\t\tif(unionf(v[i].r,v[i].c)){\n\t\t\tans += v[i].a;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n    class dsu{\n    public:\n    \tvoid init(int n){\n    \t\tpai.clear() , peso.clear();\n    \t\tpai.resize(n) , peso.resize(n);\n    \t\tf.resize(n);\n    \t\tciclou.resize(n);\n    \t\tfor(int i = 0 ; i < n; i++){\n    \t\t\tpai[i] = i , peso[i] = 1;\n    \t\t}\n    \t}\n    \tint get(int x){\n    \t\treturn pai[x] == x ? x : pai[x] = get(pai[x]);\n    \t}\n    \tint get_f(int x){\n    \t\treturn ciclou[get(x)];\n    \t}\n    \tvoid add_f(int x){\n    \t\tciclou[get(x)] |= 1;\n    \t}\n    \tint get_p(int x){\n    \t\treturn peso[get(x)];\n    \t}\n    \tvoid add(int x , int y){\n    \t\tx = get(x) , y = get(y);\n    \t\tif(x == y) return;\n    \t\tif(peso[x] < peso[y]) swap(x,y);\n    \t\tpai[y] = x, peso[x] += peso[y];\n    \t\tciclou[x] |= ciclou[y];\n    \t}\n    private:\n    \tvector<int> pai , peso , f , ciclou;\n    };\n    struct query{\n    \tint u , v , w;\n    }; \n\n    int32_t main(){\n    \tint n , l , c;\n    \tscanf(\"%lld%lld%lld\" , &n , &l , &c);\n    \tvector<\tquery > v(n);\n    \tfor(int i = 0 ; i < n; i ++) cin>>v[i].u  >> v[i].v >> v[i].w;\n    \tsort(v.begin() , v.end() , [&](query a,  query b){\n    \t\treturn a.w > b.w;\n    \t});\n    \tdsu t;\n    \tt.init(l+ c+ 3);\n    \tint ans = 0;\n    \tfor(int i = 0 ; i < n ; i ++){\n    \t\tif(t.get(v[i].u) != t.get(v[i].v + l) && !(t.get_f(v[i].u) & t.get_f(v[i].v + l))){\n    \t\t\tt.add(v[i].u , v[i].v + l);\n    \t\t\tans += v[i].w;\n    \t\t}\n    \t\telse{\n    \t\t\tif(t.get(v[i].u) == t.get(v[i].v + l)){\n    \t\t\t\tif(!t.get_f(v[i].u)){\n    \t\t\t\t\tt.add_f(v[i].u);\n    \t\t\t\t\tans += v[i].w;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t}\n    \tprintf(\"%lld\\n\" , ans);\n    } "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Card {\n  int row;\n  int col;\n  int value;\n};\n\nint main() {\n  int N, H, W;\n  cin >> N >> H >> W;\n  vector<int> parent(W + H + 1, -1);\n  vector<int> size(W + H + 1, 1);\n  vector<bool> saturated(W + H + 1);\n  vector<Card> cards;\n  for (int i = 1; i <= N; ++i) {\n    cards.emplace_back();\n    auto&& c = cards.back();\n    cin >> c.row >> c.col >> c.value;\n    c.col += H;\n  }\n  auto cmp = [](auto&& lhs, auto&& rhs) {\n    return lhs.value > rhs.value;\n  };\n  sort(cards.begin(), cards.end(), cmp);\n  int64_t result = 0;\n  for (auto&& card : cards) {\n    int row = card.row;; \n    for (; parent[row] != -1; row = parent[row]);\n    int col = card.col;; \n    for (; parent[col] != -1; col = parent[col]);\n    if (row == col) {\n      if (saturated[row]) {\n        continue;\n      }\n      saturated[row] = true;\n    } else {\n      if (saturated[row] && saturated[col]) {\n        continue;\n      }\n      if (size[row] < size[col]) swap(col, row);\n      size[row] += size[col];\n      parent[col] = row;\n      saturated[row] = saturated[row] || saturated[col];\n    }\n    result += card.value;\n  }\n  cout << result << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <random>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <cmath>\n#include <numeric>\n#include <cstdlib>\n#include <cstring>\n#include <deque>\n#include <sstream>\n#include <bitset>\n#include <cassert>\n#include <fstream>\n#include <queue>\n\n#define len(X) ((int)(X).size())\n\n#ifdef __LOCAL\n\t#define DBG(X) cout << #X << \"=\" << (X) << endl;\n#else\n\t#define DBG(X)\n\t#define endl '\\n'\n#endif\n \nusing namespace std;\n\nusing ll = long long int;\nusing ull = unsigned long long int;\nusing ld  = long double;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\nconst int INT_INF = (int)(2e9);\nconst ll  LL_INF  = (ll)(2e18);\n\nconst ll mod = 1e9 + 7;\nconst int NIL = -1;\nstatic mt19937 _g(time(nullptr));\n\ninline ll randint(ll a, ll b) { ll w = (_g() << 31LL) ^ _g(); return a + w % (b - a + 1); }\ninline void fast_io() { ios_base::sync_with_stdio(false); cin.tie(nullptr); cout.tie(nullptr); };\ntemplate<typename T> inline T sign(T x) { return T(x > 0) - T(x < 0); }\ntemplate<typename T, typename S> inline ostream& operator<<(ostream& os, const pair<T, S> p) { cout << \"[\" << p.first << \";\" << p.second << \"]\"; return os; }\ntemplate<typename T> inline ostream& operator<<(ostream& os, const vector<T>& v) { for(auto el: v) cout << el << \" \"; return os; }\n\nconst int MAX_N = (int)3e5 + 777;\n\nstruct Cell\n{\n\tll val;\n\tint r, c;\n\n\tbool operator<(const Cell& other) const\n\t{\n\t\treturn val > other.val;\n\t}\n};\n\nint n, h, w;\nCell cells[MAX_N];\n\nint dsu[MAX_N], cntE[MAX_N], cntV[MAX_N];\n\ninline int get_parent(int v)\n{\n\tfor(; dsu[v] != v; v = dsu[v]);\n\n\treturn v;\n}\n\ninline int connect(int v, int u)\n{\n\tv = get_parent(v);\n\tu = get_parent(u);\n\n\tif(v == u)\n\t{\n\t\tif(cntE[v] + 1 <= cntV[v])\n\t\t{\n\t\t\t++cntE[v];\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n\telse\n\t{\n\t\tif(cntE[v] + cntE[u] + 1 <= cntV[v] + cntV[u])\n\t\t{\n\t\t\tif(cntV[v] > cntV[u]) // make sure cntV[v] <= cntV[u]\n\t\t\t\tswap(v, u);\n\n\t\t\tdsu[v] = u;\n\t\t\tcntV[u] += cntV[v];\n\t\t\tcntE[u] += cntE[v] + 1;\n\n\t\t\treturn 1;\n\t\t}\n\n\t\treturn 0;\n\t}\n}\n\nvoid solve()\n{\n\tcin >> n >> h >> w;\n\n\tfor(int i = 0; i < n; ++i)\n\t\tcin >> cells[i].r >> cells[i].c >> cells[i].val;\n\n\tsort(cells, cells + n);\n\n\tfor(int v = 0; v < w + h; ++v)\n\t{\n\t\tdsu[v] = v;\n\t\tcntE[v] = 0;\n\t\tcntV[v] = 1;\n\t}\n\n\tll answ = 0;\n\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tint v = cells[i].r;\n\t\tint u = h + cells[i].c;\n\n\t\tansw += cells[i].val * connect(v, u);\n\t}\n\n\tcout << answ << endl;\n}\n\nint main()\n{\n\tfast_io();\n\tsolve();\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int max_n=200005;\nll ans;\nstruct DSU{\n    int par[max_n];\n    bool have[max_n];\n    void init(int n){\n        for(int i=1;i<=n;i++)par[i]=i,have[i]=false;\n    }\n    int findpar(int x){\n        return x==par[x]?x:par[x]=findpar(par[x]);\n    }\n    void unite(int x,int y,int w){\n        x=findpar(x),y=findpar(y);\n        if(x!=y){\n            if(have[x]&&have[y])return;\n            par[x]=y,have[y]=have[x]|have[y];\n            ans+=w;\n        }\n        else{\n            if(have[x])return;\n            else{\n                have[x]=true;\n                ans+=w;\n            }\n        }\n    }\n}D;\nstruct edge{\n    int u,v,w;\n    bool operator <(edge p){\n        return w>p.w;\n    }\n}e[max_n];\nint n,h,w;\nint main(){\n    scanf(\"%d%d%d\",&n,&h,&w);\n    D.init(h+w);\n    for(int i=1;i<=n;i++)scanf(\"%d%d%d\",&e[i].u,&e[i].v,&e[i].w);\n    sort(e+1,e+n+1);\n    ans=0;\n    for(int i=1;i<=n;i++){\n        int u=e[i].u,v=e[i].v+h,c=e[i].w;\n        D.unite(u,v,c);\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n    #define _GLIBCXX_DEBUG\n#endif\n#pragma GCC optimize(\"Ofast\")\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <complex>\n#include <iomanip>\n#include <bitset>\n#include <random>\n#include <chrono>\n\n#define stdin_filepath \"stdin.txt\"\n#define stdout_filepath \"stdout.txt\"\n#define stderr_filepath \"stderr.txt\"\n#define iostream_untie true\n#define stdout_precision 10\n#define stderr_precision 10\n#define rep(i,n) for(int_fast64_t i = 0; i < (int_fast64_t)(n); ++i)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcountll\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing pii = pair<int, int>;\nusing pll = pair<int_fast64_t, int_fast64_t>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / (T)2 - (T)1234567;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\n\nnamespace execution {\n    std::chrono::system_clock::time_point start_time, end_time;\n    void print_elapsed_time() {\n        end_time = std::chrono::system_clock::now();\n        std::cerr << \"\\n----- Exec time : \";\n        std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count();\n        std::cerr << \" ms -----\\n\";\n    }\n    struct setupper {\n        setupper() {\n            if(iostream_untie) {\n                ios::sync_with_stdio(false);\n                std::cin.tie(nullptr);\n                // std::cout.tie(nullptr);\n                // std::cerr.tie(nullptr);\n            }\n            std::cout << std::fixed << std::setprecision(stdout_precision);\n            std::cerr << std::fixed << std::setprecision(stderr_precision);\n    #ifdef LOCAL\n            if(!freopen(stderr_filepath, \"wt\", stderr)) {\n                freopen(\"CON\", \"wt\", stderr);\n                std::cerr << \"Failed to open the stderr file\\n\";\n            }\n            if(!freopen(stdout_filepath, \"wt\", stdout)) {\n                freopen(\"CON\", \"wt\", stdout);\n                std::cerr << \"Failed to open the stdout file\\n\";\n            }\n            if(!freopen(stdin_filepath, \"rt\", stdin)) {\n                freopen(\"CON\", \"rt\", stdin);\n                std::cerr << \"Failed to open the stdin file\\n\";\n            }\n            atexit(print_elapsed_time);\n            start_time = std::chrono::system_clock::now();\n    #endif\n        }\n    } __setupper;\n}\n\nstruct myclock_t {\n    std::chrono::system_clock::time_point built_pt, last_pt;\n    int built_ln, last_ln;\n    string built_func, last_func;\n    std::ostream &os;\n    bool is_built;\n\n    myclock_t(std::ostream &_os = std::cerr) : os(_os), is_built(false) {}\n\n    void build(int crt_ln, const string &crt_func) {\n        is_built = true;\n        last_pt = built_pt = std::chrono::system_clock::now();\n        last_ln = built_ln = crt_ln, last_func = built_func = crt_func;\n    }\n    \n    void set(int crt_ln, const string &crt_func) {\n        if(is_built) {\n            last_pt = std::chrono::system_clock::now();\n            last_ln = crt_ln, last_func = crt_func;\n        } else {\n            cerr << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::set failed (yet to be built clock!)\\n\";\n        }\n    }\n\n    void get(int crt_ln, const string &crt_func) {\n        if(is_built) {\n            std::chrono::system_clock::time_point crt_pt(chrono::system_clock::now());\n            int64_t diff = std::chrono::duration_cast<std::chrono::milliseconds>(crt_pt - last_pt).count();\n            os << diff << \" ms elapsed from\" << \" [ \" <<  last_ln << \" : \" << last_func << \" ]\";\n            if(last_ln == built_ln) os << \" (when built)\";\n            os << \" to\" << \" [ \" << crt_ln << \" : \" << crt_func << \" ]\" << \"\\n\";\n            last_pt = built_pt, last_ln = built_ln, last_func = built_func;\n        } else {\n            cerr << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::get failed (yet to be built clock!)\\n\";\n        }\n    }\n};\n#if defined(DEBUG) || defined(LOCAL)\n    myclock_t myclock(std::cerr);\n    #define build_clock() myclock.build(__LINE__, __func__)\n    #define set_clock() myclock.set(__LINE__, __func__)\n    #define get_clock() myclock.get(__LINE__, __func__)\n#else\n    #define build_clock()\n    #define set_clock()\n    #define get_clock()\n#endif\n\nnamespace std {\n    template <class RAitr> void rsort(RAitr __first, RAitr __last) {\n        sort(__first, __last, greater<>());\n    }\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1>\n    struct hashval_calc {\n        static void apply(size_t& seed, tuple_t const& t) {\n            hashval_calc<tuple_t, index - 1>::apply(seed, t);\n            hash_combine(seed,get<index>(t));\n        }\n    };\n    template <class tuple_t>\n    struct hashval_calc<tuple_t, 0> {\n        static void apply(size_t& seed, tuple_t const& t) {\n            hash_combine(seed,get<0>(t));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& t) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,t);\n            return seed;\n        }\n    };\n}\n\ntemplate <class T, class U> istream &operator>> (istream &s, pair<T,U> &p) { return s >> p.first >> p.second; }\ntemplate <class T, class U> ostream &operator<< (ostream &s, const pair<T,U> p) { return s << p.first << \" \" << p.second; }\ntemplate <class T> istream &operator>> (istream &s, vector<T> &v) { for(T &e : v) { s >> e; }   return s; }\ntemplate <class T> ostream &operator<< (ostream &s, const vector<T> &v) {\n    for(size_t i = 0; i < v.size(); ++i) { s << (i ? \" \" : \"\") << v[i]; }   return s;\n}\ntemplate <class tuple_t, size_t index>\nstruct tupleos {\n    static ostream &apply(ostream &s, const tuple_t &t) {\n        tupleos<tuple_t,index - 1>::apply(s,t);\n        return s << \" \" << get<index>(t);\n    }\n};\ntemplate <class tuple_t>\nstruct tupleos<tuple_t, 0> {\n    static ostream &apply(ostream &s, const tuple_t &t) {\n        return s << get<0>(t);\n    }\n};\ntemplate <class ...T> ostream &operator<< (ostream &s, const tuple<T...> &t) {\n    return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(s,t);\n}\ntemplate <> ostream &operator<< (ostream &s, const tuple<> &t) { return s; }\n#ifdef DEBUG\n    #define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \", dump_func(__VA_ARGS__)\n#else\n    #define dump(...)\n#endif\ntemplate <class T> void dump_func(const T &x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(const T &x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T> void write(const T &x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(const T &x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(const T &x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\ntemplate <class P> void read(P __first, P __second) { for(P i = __first; i != __second; ++i) cin >> *i; }\n\ntemplate <class T> bool chmin(T &x, const T &y) { return x > y ? x = y, true : false; }\ntemplate <class T> bool chmax(T &x, const T &y) { return x < y ? x = y, true : false; }\ntemplate <class T> constexpr T minf(const T &x, const T &y) { return min(x,y); }\ntemplate <class T> constexpr T maxf(const T &x, const T &y) { return max(x,y); }\nconstexpr bool odd(int_fast64_t n) { return n & 1; }\nconstexpr bool even(int_fast64_t n) { return (int)odd(n) ^ 1; }\nconstexpr bool bit(int_fast64_t n, int e) { return (n >> e) & 1; }\nconstexpr int_fast64_t mask(int_fast64_t n, int e) { return n & ((1 << e) - 1); }\nconstexpr int_fast64_t ilog(int_fast64_t x, int_fast64_t b = 2) { return x ? 1 + ilog(x / b, b) : -1; }\nconstexpr int_fast64_t gcd(int_fast64_t x, int_fast64_t y) {\n    x = x > 0 ? x : -x, y = y > 0 ? y : -y;\n    while(y) x ^= y ^= (x %= y) ^= y;\n    return x;\n}\nconstexpr int_fast64_t lcm(int_fast64_t x, int_fast64_t y) { return x ? x / gcd(x, y) * y : 0; }\nint_fast64_t binry(int_fast64_t ok, int_fast64_t ng, const function<bool(int_fast64_t)> &fn) {\n    while (abs(ok - ng) > 1) {\n        int_fast64_t mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array, (T*)(array + N), val); }\ntemplate <class A, size_t N> void init(A (&array)[N]) { memset(array, 0, sizeof(array)); }\ntemplate <class T> vector<int> cmprs(const vector<T> &v) {\n    vector<T> tmp = v; vector<int> ret;\n    sort(begin(tmp),end(tmp));\n    tmp.erase(unique(begin(tmp),end(tmp)), end(tmp));\n    for(const T &i : v) ret.emplace_back(lower_bound(begin(tmp),end(tmp),i) - begin(tmp));\n    return ret;\n}\ntemplate <class T> vector<int> cmprs(const T *__first, const T *__last) {\n    return cmprs(vector<T>(__first, __last));\n}\nvoid for_subset(int_fast64_t s, const function<void(int_fast64_t)> &fn) {\n    int_fast64_t t = s;\n    do { fn(t); } while((--t &= s) != s);\n}\n\n\n/* The main code follows. */\n\ntemplate <class cap_t, class cost_t>\nstruct Flow {\n    struct edge_t {\n        int from, to; cap_t cap; cost_t cost; size_t rev;\n        edge_t(int _from, int _to, cap_t _cap, cost_t _cost, size_t _rev)\n            : from(_from), to(_to), cap(_cap), cost(_cost), rev(_rev)\n        {}\n    };\n\n    size_t V,E;\n    vector<vector<size_t>> adj;\n    vector<edge_t> edge;\n    bool neg_edge_exist;\n\n    Flow(size_t _V)\n        : V(_V), E(), edge(), neg_edge_exist()\n    {\n        adj.resize(V);\n    }\n\n    void add_edge(int from, int to, cap_t cap, cost_t cost) {\n        assert(cap >= 0);\n        size_t pos = edge.size();\n        size_t rpos = pos + 1;\n        edge.emplace_back(from, to, cap, cost, rpos);\n        adj[from].emplace_back(pos);\n        edge.emplace_back(to, from, 0, -cost, pos);\n        adj[to].emplace_back(rpos); \n        ++E; if(cost < 0) neg_edge_exist = true;\n    }\n\n    vector<cost_t> Dijkstra(int s) {\n        vector<cost_t> dist(V, inf<cost_t>);\n        priority_queue<pair<cost_t,int>, vector<pair<cost_t,int>>, greater<pair<cost_t,int>>> que;\n        que.emplace(dist[s] = 0, s);\n        while(!que.empty()) {\n            auto p = que.top(); que.pop();\n            int v = p.second;\n            if(dist[v] < p.first) continue;\n            for(size_t i : adj[v]) {\n                edge_t &e = edge[i];\n                if(e.cap > 0 && dist[v] + e.cost < dist[e.to]) que.emplace(dist[e.to] = dist[v] + e.cost, e.to);\n            } \n        }\n        return dist;\n    }\n\n    struct Fold_Fulkerson_exe {\n        vector<edge_t> &edge;\n        vector<vector<size_t>> &adj;  \n        vector<bool> used;\n\n        Fold_Fulkerson_exe(Flow &_F) : edge(_F.edge), adj(_F.adj)\n        {\n            used.resize(_F.V);\n        }\n\n        cap_t dfs(int v, int t, cap_t f) {\n            if(v == t) return f;\n            used[v] = true;\n            for(size_t i : adj[v]) {\n                edge_t &e = edge[i];\n                if(!used[e.to] && e.cap > 0) {\n                    cap_t d = dfs(e.to,t,min(f,e.cap));\n                    if(d > 0) {\n                        e.cap -= d;\n                        edge[e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        cap_t max_flow(int s, int t) {\n            cap_t flow = 0,f;\n            while(true) {\n                fill(begin(used),end(used),false);\n                if((f = dfs(s,t,numeric_limits<cap_t>::max())) > 0) flow += f;\n                else break;\n            }\n            return flow;\n        }\n    };\n\n    cap_t Fold_Fulkerson(int s, int t) { return Fold_Fulkerson_exe(*this).max_flow(s,t); }\n    \n    struct Dinic_exe {\n        vector<edge_t> &edge;\n        vector<vector<size_t>> &adj;\n        vector<int> level,itr;\n\n        Dinic_exe(Flow &_F) : edge(_F.edge), adj(_F.adj)\n        {\n            level.resize(_F.V), itr.resize(_F.V);\n        }\n\n        void bfs(int s) {\n            fill(begin(level),end(level),-1);\n            queue<int> que;\n            level[s] = 0;\n            que.emplace(s);\n            while(!que.empty()) {\n                int v = que.front(); que.pop();\n                for(size_t i : adj[v]) {\n                    edge_t &e = edge[i];\n                    if(e.cap > 0 && level[e.to] < 0) {\n                        level[e.to] = level[v] + 1;\n                        que.emplace(e.to);\n                    }\n                } \n            }\n        }\n\n        cap_t dfs(int v, int t, cap_t f) {\n            if(v == t) return f;\n            for(int &i = itr[v]; i < (int)adj[v].size(); ++i) {\n                edge_t &e = edge[adj[v][i]];\n                if(e.cap > 0 && level[v] < level[e.to]) {\n                    cap_t d = dfs(e.to, t, min(f,e.cap));\n                    if(d > 0) {\n                        e.cap -= d;\n                        edge[e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        cap_t max_flow(int s, int t) {\n            cap_t flow = 0, f;\n            while(bfs(s), level[t] >= 0) {\n                fill(begin(itr), end(itr), 0);\n                while((f = dfs(s, t, numeric_limits<cap_t>::max())) > 0) flow += f;\n            }\n            return flow;\n        }\n    };\n\n    cap_t Dinic(int s, int t) { return Dinic_exe(*this).max_flow(s, t); }\n\n    struct Primal_Dual_exe {\n        vector<edge_t> &edge;\n        vector<vector<size_t>> &adj;\n        size_t &V;\n        vector<cost_t> dist, h;\n        vector<int> prev_v;\n        vector<edge_t*> prev_e;\n\n        Primal_Dual_exe(Flow &_F)\n            : edge(_F.edge), adj(_F.adj), V(_F.V)\n        {\n            dist.resize(_F.V), h.resize(_F.V), prev_v.resize(_F.V), prev_e.resize(_F.V);\n        }\n\n        bool Dijkstra(int s, int t) {\n            priority_queue<pair<cost_t,int>, vector<pair<cost_t,int>>, greater<pair<cost_t,int>>> que;\n            fill(begin(dist), end(dist), inf<cost_t>);\n            que.emplace(dist[s] = 0, s);\n            while(!que.empty()) {\n                cost_t _cost; int v;\n                tie(_cost, v) = que.top();\n                que.pop();\n                if(_cost != dist[v]) continue;\n                for(size_t i : adj[v]) {\n                    edge_t &e = edge[i];\n                    if(e.cap > 0 && dist[v] + h[v] + e.cost < dist[e.to] + h[e.to]) {\n                        que.emplace(dist[e.to] = dist[v] + h[v] - h[e.to] + e.cost, e.to);\n                        prev_v[e.to] = v;\n                        prev_e[e.to] = &e;\n                    }\n                }\n            } \n            if(dist[t] >= inf<cost_t>) return false;\n            for(size_t v = 0; v < V; ++v) {\n                h[v] += dist[v];\n                if(h[v] > inf<cost_t>) h[v] = inf<cost_t>;\n            }\n            return true;\n        }\n\n        cost_t min_cost_flow(int s, int t, cap_t f) {\n            cost_t res = 0;\n            fill(begin(h), end(h), 0);\n            while(f > 0) {\n                if(!Dijkstra(s, t)) return inf<cost_t>;\n                cap_t d = f;\n                for(int v = t; v != s; v = prev_v[v]) d = min(d, prev_e[v]->cap);\n                f -= d;\n                res += h[t] * d;\n                for(int v = t; v != s; v = prev_v[v]) {\n                    prev_e[v]->cap -= d;\n                    edge[prev_e[v]->rev].cap += d;\n                }\n            }\n            return res;\n        }\n    };\n\n    cost_t Primal_Dual(int s, int t, cap_t f) {\n        cost_t corr = 0;\n        if(neg_edge_exist) {\n            int _s = V++;\n            int _t = V++;\n            adj.resize(V);\n            add_edge(_s, s, f, 0);\n            add_edge(t, _t, f, 0);\n            s = _s, t = _t;\n            vector<pair<int, cap_t>> s_addv, t_addv;\n            for(edge_t &e : edge) {\n                if(e.cap > 0 and e.cost <  0) {\n                    f += e.cap;\n                    s_addv.emplace_back(e.to, e.cap);\n                    t_addv.emplace_back(e.from, e.cap);\n                    corr += e.cost * e.cap;\n                    edge[e.rev].cap += e.cap;\n                    e.cap = 0;\n                }\n            }\n            for(auto &p : s_addv) add_edge(s, p.first, p.second, 0);\n            for(auto &p : t_addv) add_edge(p.first, t, p.second, 0);\n            neg_edge_exist = false;\n        }\n        return Primal_Dual_exe(*this).min_cost_flow(s, t, f) + corr;\n    } \n};\n\nsigned main()\n{\n    void solve();\n    void input();\n    void init();\n\n    int t = 1;\n\n    #ifdef LOCAL\n        t = 1;\n        // cin >> t;\n    #endif\n\n    // cin >> t;\n\n    while(t--)\n    {\n        init();\n        input();\n        solve();\n    }\n}\n\n\nint n,h,w;\n\nvoid init()\n{}\n\nvoid input()\n{\n    cin>>n>>h>>w;\n}\n\nvoid solve()\n{\n    Flow<int,i64> flow(w+h+2+n);\n    const int s=h+w+n;\n    const int t=s+1;\n\n    for(int i=0; i<h; i++)\n    {\n        flow.add_edge(s,i,1,0);\n    }\n\n    for(int i=0; i<w; i++)\n    {\n        flow.add_edge(s,i+h,1,0);\n    }\n\n    for(int i=0; i<n; i++)\n    {\n        int r,c,a;\n        cin>>r>>c>>a;\n        r--,c--;\n        flow.add_edge(h+w+i,t,1,-a);\n        flow.add_edge(r,h+w+i,1,0);\n        flow.add_edge(h+c,h+w+i,1,0);\n    }\n\n    flow.add_edge(s,t,h+w,0);\n\n    cout << -flow.Primal_Dual(s,t,h+w) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 1e5+10;\nint n,w,h,sx[N],sy[N],cnt1,cnt2;\nstruct node{\n\tint x,y,z;\n}a[N];\nmap<int,int>f[N];\n\nint main(){\n\tn=read(),w=read(),h=read();\n\tFor(i,1,n) a[i]=(node){read(),read(),read()};\n\tsort(a+1,a+1+n,[](node a,node b){\n\t\treturn a.z>b.z;\n\t});\n\tll ans=0;\n\tint cnt=0;\n\tcnt1=w,cnt2=h;\n\tFor(i,1,n){\n\t\tif (f[a[i].x][a[i].y]<2&&sx[a[i].x]<=h&&sy[a[i].y]<=w){\n\t\t\tcnt1-=(sx[a[i].x]==0),cnt2-=(sy[a[i].y]==0),++cnt;\n\t\t//\tif ((w+h)-cnt<cnt1||(w+h)-cnt<cnt2){\n\t\t//\t\tcnt1+=(sx[a[i].x]==0),cnt2+=(sy[a[i].y]==0),--cnt;\n\t\t//\t\tcontinue;\n\t\t//\t}\n\t\t\tans+=a[i].z;\n\t\t\tsx[a[i].x]++,sy[a[i].y]++,f[a[i].x][a[i].y]++;\n\t\t\t//printf(\"Add %d %d %d\\n\",a[i].x,a[i].y,a[i].z);\n\t\t\tif (cnt==w+h) break;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAX 500005\n#define ll long long\ninline int read()\n{\n    int x=0;bool t=false;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n    if(ch=='-')t=true,ch=getchar();\n    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n    return t?-x:x;\n}\nll ans;\nint n,h,w,tot,f[MAX];\nbool cir[MAX];\nstruct edge{int u,v,w;}E[MAX];\nbool operator<(edge a,edge b){return a.w>b.w;}\nint getf(int x){return x==f[x]?x:f[x]=getf(f[x]);}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&h,&w);\n    for(int i=1;i<=h+w;++i)f[i]=i;\n    fp(i,1,n){\n    \tR int x,y,c;\n    \tscanf(\"%d%d%d\",&x,&y,&c);\n    \t\n            E[++tot]=(edge){x,y+h,c};\n\t}\n//    for(int i=1;i<=n;++i)\n//        for(int j=1;j<=m;++j)\n//            E[++tot]=(edge){i,j+n,read()};\n    sort(&E[1],&E[tot+1]);\n    for(int i=1;i<=tot;++i)\n    {\n        int u=getf(E[i].u),v=getf(E[i].v);\n        if(u==v){if(!cir[u])cir[u]=true,ans+=E[i].w;}\n        else if(!cir[u]||!cir[v])\n            f[u]=v,ans+=E[i].w,cir[v]|=cir[u];\n    }\n    printf(\"%lld\\n\",ans);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#define vv(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define vvi vector<vector<int> >\n#define vvl vector<vector<ll> >\n#define vl vector<ll>\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nvector<bool> used(300000, false);\nstruct edge{ll to, cost, n;};\nvector<vector<edge> > G(300000);\nvvl lis = vv(300000, 0, 0, ll);\n\nvoid dfs(ll now, ll c){\n  if(used[now]) return;\n  lis[c].push_back(now);\n  used[now] = true;\n  for(int i=0;i<G[now].size();i++) dfs(G[now][i].to, c);\n}\nint main(int argc, char const *argv[]) {\n  ll N, H, W, a, b, c, ans = 0;\n  std::cin >> N >> H >> W;\n  for(int i=0;i<N;i++){\n    scanf(\"%lld %lld %lld\", &a, &b, &c);\n    G[a].push_back(edge{b+100001, -c, i});\n    G[b+100001].push_back(edge{a, -c, i});\n  }\n  for(int i=0;i<300000;i++) if(!used[i]) dfs(i, i);\n  std::vector<bool> us(300000, false), eg(300000, false);\n\n  for(int i=0;i<300000;i++){\n    if(lis[i].size()<=1) continue;\n\n    vvl e = vv(0, 4, 0, ll);\n    for(int j=0;j<lis[i].size();j++){\n      for(int k=0;k<G[lis[i][j]].size();k++){\n        e.push_back(vl{G[lis[i][j]][k].cost, G[lis[i][j]][k].n, lis[i][j], G[lis[i][j]][k].to});\n      }\n    }\n    ll v = 0, t = 0;\n    sort(e.begin(), e.end());\n    for(int j=0;j<e.size();j++){\n      if(eg[e[j][1]]) continue;\n      ll tmp = (!us[e[j][2]]?1:0) + (!us[e[j][3]]?1:0);\n      if(v + tmp > t){\n        t++;\n        v += tmp;\n        eg[e[j][1]] = us[e[j][2]] = us[e[j][3]] = true;\n        ans -= e[j][0];\n      }\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n#define let auto const\n\n#include <vector>\n#include <set>\nusing namespace std;\n\nstruct union_find {\n  vector<int> par;\n  vector<int> rank;\n  union_find(int n) : par(n) , rank(n) {\n    for(int i = 0;i < n;i++) par[i] = i;\n  }\n  int root(int i) {\n    return par[i] == i ? i : par[i] = root(par[i]);\n  }\n  /* unite x, y return parent */\n  int unite(int x,int y) {\n    x = root(x);\n    y = root(y);\n    if(x == y) return -1;\n    if(rank[x] < rank[y]) {\n      par[x] = y;\n      return y;\n    }\n    else {\n      par[y] = x;\n      if(rank[x] == rank[y]) rank[x]++;\n      return x;\n    }\n  }\n  bool same(int x,int y) {\n    return root(x) == root(y);\n  }\n};\n\nint main() {\n  i64 n, h, w;\n  cin >> n >> h >> w;\n  using P = pair<i64, pair<i64, i64>>;\n  vector<P> vec;\n  rep(i,0,n) {\n    i64 r, c, a;\n    cin >> r >> c >> a;\n    r--;\n    c--;\n    vec.push_back(P(a, { r, c }));\n  }\n  sort(all(vec));\n  reverse(all(vec));\n  union_find uf(h + w);\n  vector<i64> in(h + w);\n  vector<i64> out(h + w, 1);\n  i64 ans = 0;\n\n  for(auto p: vec) {\n    i64 a = p.first;\n    i64 r = p.second.first;\n    i64 c = p.second.second;\n    r = uf.root(r);\n    c = uf.root(c + h);\n    if(r == c) {\n      if(in[r] < out[r]) {\n        in[r]++;\n        ans += a;\n      }\n    }\n    else if(in[r] + in[c] + 1 <= out[r] + out[c]) {\n      i64 p = uf.unite(r, c);\n      in[p] = in[r] + in[c] + 1;\n      out[p] = out[r] + out[c];\n      ans += a;\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (register ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (register ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter cout << endl\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 2e6 + 10 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 1e9 + 7 ;\nconst double eps = 1e-7 ;\ntemplate <class T> void read(T &a)\n{\n\tint f = 1 ; a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\ta *= f;\n}\n\nll n, h, w, ans;\n\nstruct card\n{\n\tll a, r, c;\n}\na[maxn];\n\nll fa[maxn];\n\nbool circle[maxn];\n\nvoid init(ll t)\n{\n\trep(i, 1, t) fa[i] = i;\n\treturn ;\n}\n\nll getfa(ll a)\n{\n\treturn a == fa[a] ? a : fa[a] = getfa(fa[a]);\n}\n\nsigned main()\n{\n\tscanf(\"%lld %lld %lld\", &n, &h, &w);\n\tinit(h + w);\n\trep(i, 1, n) scanf(\"%lld %lld %lld\", &a[i].r, &a[i].c, &a[i].a);\n\tsort(a + 1, a + n + 1, [](card a, card b)\n\t\t{\n\t\t\treturn a.a > b.a;\n\t\t}\n\t);\n\trep(i, 1, n)\n\t{\n\t\tll u = a[i].r, v = a[i].c + h;\n\t\t// cout << u << ' ' << v << endl;\n\t\t// printf(\"I : %lld %lld %lld\\n\", a[i].r, a[i].c, a[i].a);\n\t\tu = getfa(u), v = getfa(v);\n\t\t// printf(\"%lld %lld\\n\", u, v);\n\t\tif(u != v)\n\t\t{\n\t\t\tif(!circle[u] || !circle[v] ) ans += a[i].a, fa[u] = v;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(!circle[u]) circle[u] = 1, ans += a[i].a;\n\t\t\t// else puts(\"No\");\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define __builtin_popcount __builtin_popcountll\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const map<S, T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\ntemplate <typename Weight>\nstruct MaxFlow{\n    struct Edge{\n        int v;\n        Weight w;\n        int r;\n        Edge(int v, Weight w,int r=0):v(v),w(w),r(r){}\n    };\n    typedef vector< vector<Edge> > Graph;\n    int n, source, sink;\n    Graph g;\n    Weight flow;\n\n    Weight maxflow_dinic(int source, int sink, Weight limit){\n        if(source == sink) return limit;\n        const Weight inf = numeric_limits<Weight>::max();\n        Weight flow = 0;\n        while(true){\n            vector<int> level(n, -1);\n            queue<int> q;\n            level[source] = 0;\n            q.push(source);\n            while(!q.empty()){\n                const int u = q.front(); q.pop();\n                for(const auto &e : g[u]){\n                    const int v = e.v;\n                    if(e.w <= 0 || level[v] >= 0){ continue; }\n                    level[v] = level[u] + 1;\n                    q.push(v);\n                }\n            }\n            if(level[sink] < 0){ break; }\n            vector<size_t> itr(n, 0);\n            while(true){\n                function<Weight(int, Weight)> dfs =\n                        [&](int u, Weight limit) -> Weight{\n                            if(u == sink) return limit;\n                            for(; itr[u] < g[u].size(); ++itr[u]){\n                                auto &e = g[u][itr[u]];\n                                const int v = e.v;\n                                if(e.w <= 0 || level[u] >= level[v]){ continue; }\n                                const Weight diff = dfs(v, min(e.w, limit));\n                                if(diff > 0){\n                                    e.w -= diff;\n                                    g[v][e.r].w += diff;\n                                    return diff;\n                                }\n                            }\n                            return 0;\n                        };\n                const auto f = dfs(source, limit - flow);\n                if(f <= 0) break;\n                if((flow += f) == limit) return flow;\n            }\n        }\n        return flow;\n    }\n\n    MaxFlow(int n=0, int s=0, int t=0):n(n), g(n), flow(0), source(s), sink(t){\n\n    }\n\n    void add_edge(int u, int v, Weight cap, Weight revcap=0){\n/*\t\tfor(auto &e : g[u])if(e.v == v){\n\t\t\te.w += cap;\n\t\t\treturn;\n\t\t}\n*/\t\tg[u].emplace_back(v,cap,g[v].size());\n        g[v].emplace_back(u,revcap,g[u].size()-1);\n    }\n    void rem_edge(int u,int v, Weight cap){\n        for(auto &e : g[u])if(e.v == v){\n                Weight t = min(cap, e.w);\n                e.w -= t;\n                cap -= t;\n                if(cap == 0) return;\n            }\n        Weight t = cap;\n        cap -= maxflow_dinic(u, v, cap);\n        if(cap){\n            maxflow_dinic(sink, v, cap);\n            maxflow_dinic(u, source, cap);\n            flow -= cap;\n        }\n        rem_edge(v, u, t);\n    }\n    Weight maxflow(){\n        return flow += maxflow_dinic(source, sink, numeric_limits<Weight>::max());\n    }\n};\n\n\nint T, n, m, k;\n\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    while(cin >> n >> m >> k){\n        vector<tuple<int, int, int>> v;\n        vi s;\n        REP(i, n) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            v.emplace_back(z, x, y);\n            s.emplace_back(x);\n            s.emplace_back(-y);\n        }\n        sort(RALL(v));\n        sort(ALL(s));\n        UNIQUE(s);\n        map<int, int> mp;\n        REP(i, s.size()) mp[s[i]] = i;\n        int N = n + s.size();\n        MaxFlow<int> g(n + s.size() + 2, N, N + 1);\n        ll ans = 0;\n        int mf = 0;\n        REP(i, s.size()) {\n            g.add_edge(n + i, N + 1, 1, 0);\n        }\n        REP(i, n) {\n            int x, y, z; tie(z, x, y) = v[i];\n            g.add_edge(N, i, 1, 0);\n            g.add_edge(i, n + mp[x], 1, 0);\n            g.add_edge(i, n + mp[-y], 1, 0);\n            int f = g.maxflow();\n            if (f != mf) ans += z;\n            mf = f;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<sstream>\n#include<iomanip>\n#include<limits>\n#include<deque>\n#include<map>\n#include<list>\n#include<set>\n#include <unordered_set>\n#include<vector>\n#include<cmath>\n#include<cstdio>\n#include<memory>\n#include<bitset>\n#include<stack>\n#include<functional>\n#include<queue>\n#include<regex>\n#include<time.h>\n#include<type_traits>\n#include<cstdlib>\n#include <utility>\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll MOD = 1000000007;//良く出てくるMOD\nconstexpr ll INF = 1050000000;//intで使うでかい数\nconstexpr ll LONGINF = 1050000000000000000;//longlongで使うでかい数\n\nstruct all_init {\n\t//初期化のためだけの構造体\n\t//コンストラクタが呼ばれ、cin,cout高速化がされる\n\t//ついでに少数も出力できるようにしている\n\tall_init() {\n\t\tcout.tie(nullptr);\n\t\tcin.tie(nullptr);\n\t\tios::sync_with_stdio(false);\n\t\tcout << fixed << setprecision(15);\n\t};\n}ALL_INIT;\nstruct edge {\n\t//辺の重みを管理できるような構造体\n\t//コンストラクタによって簡単に値を入れられるようにしている\n\t//operatorは辺の重みでソート出来るようにしている\n\n\tint from, to;\n\tll cost;\n\n\tedge(int s, int d, ll w) : from(s), to(d), cost(w) {}\n\n\tbool operator < (const edge& x) const {\n\t\treturn cost < x.cost;\n\t}\n};\n\n#define CIN(vector_array_etc,n) for(int loop=0;loop<n;loop++){cin>>vector_array_etc[loop];}\n#define COUT(vector_array_etc,n) for(int LOOP=0;LOOP<n;LOOP++){cout<<vector_array_etc[LOOP]<<(LOOP == n-1 ?'\\n':' ');}\n#define VC(Type_name) vector<Type_name>//1次元ならあまり意味ないかも\n#define VCVC(Type_name) vector<vector<Type_name>>//2次元配列定義怠過ぎ問題\n#define SORT(vector_etc) sort(vector_etc.begin(),vector_etc.end())\n\ntemplate<class T>bool chmax(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}//aに最大値が入る\ntemplate<class T>bool chmin(T &a, const T &b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn true;\n\t}\n\treturn false;\n}//aに最小値が入る\n\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& Vec) {\n\tfor (T& x : Vec) { is >> x; }\n\treturn is;\n}\ntemplate<typename V, typename H>\nvoid resize(vector<V>& vec, const H head) {\n\tvec.resize(head);\n}\ntemplate<typename V, typename H, typename ... T>\nvoid resize(vector<V>& vec, const H& head, const T ... tail) {\n\tvec.resize(head);\n\tfor (auto& v : vec) { resize(v, tail...); }\n}\n\nint dx[] = { 0,1,-1, 0,1,-1, 1,-1 };    //i<4:4way i<8:8way\nint dy[] = { 1,0, 0,-1,1,-1,-1, 1 };\n\nll POW_MOD(ll n, ll k, ll mod) {\n\t//繰り返し2乗法\n\t//n^kをmodで求める\n\tll r = 1;\n\n\tfor (; k > 0; k >>= 1) {\n\t\tif (k & 1) {\n\t\t\tr = (r * n) % mod;\n\t\t}\n\t\tn = (n * n) % mod;\n\t}\n\treturn r;\n}\nll gcd(ll a, ll b) {//最大公約数\n\treturn b != 0 ? gcd(b, a % b) : a;\n}\nll lcm(ll a, ll b) {//最小公倍数\n\treturn a / gcd(a, b) * b;\n}\n\nbool isPrime(ll n) {\n\t//素数かどうかを判定\n\t//true 素数\n\tif (n < 2)return false;\n\tfor (ll i = 2; i*i <= n; i++)if (!(n%i))return false;\n\treturn true;\n}\nbool  Warshall_Floyd(vector<vector<ll>> &c, int V) {\n\t//ワーシャルフロイド法\n\t//全ての頂点間の最短距離を求める\n\t//falseの時、負の閉路検出\n\tfor (int i = 0; i < V; i++) {\n\t\tc[i][i] = 0;\n\t}\n\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < V; j++) {\n\t\t\tfor (int k = 0; k < V; k++) {\n\t\t\t\tif (c[j][k] > c[j][i] + c[i][k]) {\n\t\t\t\t\tc[j][k] = c[j][i] + c[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < V; i++) {\n\t\tif (c[i][i] < 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\n\n\treturn true;\n}\nvector<ll> dijkstra(int i, vector<vector<edge>> graph) {\n\t//i:始点\n\t//graph:重み付きグラフ\n\tint n = graph.size();\n\tvector<ll> d(n, LONGINF);\n\td[i] = 0;\n\tpriority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> q;\n\tq.push(make_pair(0, i));//第一引数:コスト 第二引数:頂点\n\twhile (!q.empty()) {\n\t\tpair<ll, int> p = q.top();\n\t\tq.pop();\n\t\tint v = p.second;\n\t\tif (d[v] < p.first) {\n\t\t\tcontinue;\n\t\t}\n\t\tfor (auto x : graph[v]) {\n\t\t\tif (d[x.to] > d[v] + x.cost) {\n\t\t\t\td[x.to] = d[v] + x.cost;\n\t\t\t\tq.push(make_pair(d[x.to], x.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn d;\n}\nbool Bellman_Ford(int start, int E, int V, vector<edge> Edge, vector<ll> &d) {\n\t//第一引数:start 始点\n\t//第二引数:E 辺の数\n\t//第三引数:V 頂点数\n\t//第四引数:Edge 辺の重み付きのグラフ\n\t//第五引数:d 各頂点への距離を入れる配列(答えが入る)\n\tfill(d.begin(), d.end(), LONGINF);\n\td[start] = 0;\n\tvector<bool> t(V, false);\n\t/*\n\tfor (int i = 0; i < V - 1; i++) {\n\t\tfor (int j = 0; j < E; j++) {\n\t\t\tedge e = Edge[j];\n\t\t\tif (d[e.from] == LONGINF) { continue; }\n\t\t\tif (d[e.to] > d[e.from] + e.cost) {\n\t\t\t\td[e.to] = d[e.from] + e.cost;\n\t\t\t}\n\t\t}\n\t}\n\t*/\n\n\tfor (int i = 0; i < V; i++) {\n\t\tfor (int j = 0; j < E; j++) {\n\t\t\tedge e = Edge[j];\n\t\t\tif (d[e.from] == LONGINF) { continue; }\n\t\t\tif (d[e.to] > d[e.from] + e.cost) {\n\t\t\t\td[e.to] = d[e.from] + e.cost;\n\t\t\t\tt[e.to] = true;\n\t\t\t\tif (i == V - 1) {//どこかに閉路があることを感知する\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (t[e.from]) {\n\t\t\t\tt[e.to] = true;\n\t\t\t}\n\t\t}\n\t}\n\t/*\n\tif (t[V - 1]) {\n\t//V-1は頂点番号n-1で、始点からn-1までに負の閉路を検出したい場合には、\n\t//コメントアウトを解除すること。\n\t\treturn false;\n\t}\n\t*/\n\treturn true;\n}\nbool topological_sort(const vector<vector<edge>> &g, vector<int> &ans) {\n\t//トポロジカルソート\n\t//trueが帰る時、トポロジカルソートが成功し、その結果がansに渡される\n\t//falseはトポロジカルソートの失敗\n\tint n = g.size(), k = 0;\n\tvector<int> ord(n), in(n);\n\tfor (auto &es : g) {\n\t\tfor (auto &e : es) {\n\t\t\tin[e.to]++;\n\t\t}\n\t}\n\tqueue<int> q;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (in[i] == 0) q.push(i);\n\t}\n\twhile (!q.empty()) {\n\t\tint v = q.front();\n\t\tq.pop();\n\t\tord[k++] = v;\n\t\tfor (auto &e : g[v]) {\n\t\t\tif (--in[e.to] == 0) q.push(e.to);\n\t\t}\n\t}\n\tans = ord;\n\tif (*max_element(in.begin(), in.end()) == 0) { return true; }\n\treturn false;\n}\nvector<int> articulationPoint(const vector<vector<edge>>& g) {\n\t//グラフの関節点を列挙する\n\t//最後の2行で、erace uniqueをしない場合は、その分割によって何個のグラフに分かれるかを判定できる(要チェック)。\n\tint n = g.size(), idx;\n\tvector<int> low(n), ord(n), art;\n\tfunction<void(int)> DFS = [&](int v) {\n\t\tlow[v] = ord[v] = ++idx;\n\t\tfor (auto& e : g[v]) {\n\t\t\tint w = e.to;\n\t\t\tif (ord[w] == 0) {\n\t\t\t\tDFS(w);\n\t\t\t\tlow[v] = min(low[v], low[w]);\n\t\t\t\tif ((ord[v] == 1 && ord[w] != 2) || (ord[v] != 1 && low[w] >= ord[v])) {\n\t\t\t\t\tart.push_back(v);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tlow[v] = min(low[v], ord[w]);\n\t\t\t}\n\t\t}\n\t};\n\tfor (int u = 0; u < n; u++) {\n\t\tif (ord[u] == 0) {\n\t\t\tidx = 0;\n\t\t\tDFS(u);\n\t\t}\n\t}\n\n\tsort(art.begin(), art.end());//えられた関節点をソート\n\tart.erase(unique(art.begin(), art.end()), art.end());//同じ関節点が複数存在することがある,\n\n\treturn art;\n}\nedge tree_diameter(const vector<vector<edge>> &g) {\n\t//重み付きグラフ(木)を受け取り、その木の直径を求める\n\t//返り値はfrom,to,costを持った構造体\n\n\tint start = 0;//どの始点から始めても良いので、0から始める\n\n\tstatic const auto bfs = [](const vector<vector<edge>> &g, int s, queue<ll> &q, vector<ll> &dist) {\n\t\twhile (!q.empty()) { q.pop(); }\n\t\tq.push(s);\n\t\tint n = g.size();\n\t\tdist.assign(n, LONGINF);\n\t\tdist[s] = 0;\n\t\twhile (q.size()) {\n\t\t\tint u = q.front();\n\t\t\tq.pop();\n\t\t\tfor (auto &e : g[u]) {\n\t\t\t\tint v = e.to;\n\t\t\t\tif (dist[v] == LONGINF) {\n\t\t\t\t\tdist[v] = dist[u] + e.cost;\n\t\t\t\t\tq.push(v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dist;\n\t};\n\tvector<ll> dist;\n\tqueue<ll> q;\n\tbfs(g, start, q, dist);\n\tint n = g.size(), u = -1, v = -1;\n\tfor (int i = 0; i < n; i++)\n\t\tif (dist[i] != LONGINF && (u == -1 || dist[i] > dist[u])) u = i;\n\tbfs(g, u, q, dist);\n\tfor (int i = 0; i < n; i++)\n\t\tif (dist[i] != LONGINF && (v == -1 || dist[i] > dist[v])) v = i;\n\tint d = dist[v];\n\tif (u > v) swap(u, v);//念のため辞書順\n\treturn edge(u, v, d);\n}\n\nclass UnionFind {\n\t//satanicさん作 UnionFind\n\t//追加機能:forest forestは、全体に含まれる木の数を表す\nprivate:\n\tstd::vector<int> parent;\n\tstd::vector<int> height;\n\tstd::vector<int> m_size;\n\tint forest_num;\npublic:\n\tUnionFind(int size_) : parent(size_), height(size_, 0), m_size(size_, 1) {\n\t\tforest_num = size_;\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tvoid init(int size_) {\n\t\tparent.resize(size_);\n\t\theight.resize(size_, 0);\n\t\tm_size.resize(size_, 1);\n\t\tforest_num = size_;\n\t\tfor (int i = 0; i < size_; ++i) parent[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (parent[x] == x) return x;\n\t\treturn parent[x] = find(parent[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tint t = size(x) + size(y);\n\t\tm_size[x] = m_size[y] = t;\n\t\tif (height[x] < height[y]) parent[x] = y;\n\t\telse parent[y] = x;\n\t\tif (height[x] == height[y]) ++height[x];\n\t\tforest_num--;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\tif (parent[x] == x) return m_size[x];\n\t\treturn size(parent[x] = find(parent[x]));\n\t}\n\tint forest() {\n\t\treturn forest_num;\n\t}\n};\n\nconst int nCk_MAX = 510000;\nll fac[nCk_MAX], finv[nCk_MAX], inv[nCk_MAX];\n// テーブルを作る前処理\nvoid COMinit() {\n\tfac[0] = fac[1] = 1;\n\tfinv[0] = finv[1] = 1;\n\tinv[1] = 1;\n\tfor (int i = 2; i < nCk_MAX; i++) {\n\t\tfac[i] = fac[i - 1] * i % MOD;\n\t\tinv[i] = MOD - inv[MOD % i] * (MOD / i) % MOD;\n\t\tfinv[i] = finv[i - 1] * inv[i] % MOD;\n\t}\n}\n// 二項係数計算\nlong long COM(int n, int k) {\n\tif (n < k) return 0;\n\tif (n < 0 || k < 0) return 0;\n\treturn fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\nint main() {\n\tll n, h, w; cin >> n >> h >> w;\n\tvector<edge> x;\n\tvector<edge> y;\n\n\tUnionFind uf(h + w + 4);//0,1=h,h+1~h+w\n\n\tfor (int i = 0; i < n; i++) {\n\t\tll r, c, a; cin >> r >> c >> a;\n\t\tx.emplace_back(r, h+c, -a);\n\t\ty.emplace_back(r, h+c, -a);\n\t}\n\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\n\tll ans = 0;\n\n\tfor (int i = 0; i < n; i++) {\n\t\tif ((!uf.same((int)x[i].from, (int)x[i].to)) ) {\n\t\t\tans += x[i].cost;\n\t\t\tuf.unite((int)x[i].from, (int)x[i].to);\n\t\t}\n\t\telse {\n\t\t\tif (!uf.same((int)x[i].from, 0)) {\n\t\t\t\tans += x[i].cost;\n\t\t\t}\n\t\t\tuf.unite((int)x[i].from, (int)x[i].to);\n\t\t\tuf.unite((int)x[i].from, 0);\n\t\t}\n\t}\n\n\tcout << ans*(-1) << endl;\n\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_genius = 0; ngtkana_is_genius < int(n); ngtkana_is_genius++)\n#define rep(i, begin, end) for(int i = int(begin); i < int(end); i++)\n#define lint long long\nauto cmn = [](auto& a, auto b){if (a > b) {a = b; return true;} return false;};\nauto cmx = [](auto& a, auto b){if (a < b) {a = b; return true;} return false;};\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail){\n  std::cerr << \" \" << head;\n  debug_impl(tail...);\n}\n#define debug(...) std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n  debug_impl(__VA_ARGS__);\\\n  std::cerr << std::noboolalpha;\n\n\ntemplate <typename Value, typename BinaryOp>\nclass valued_union_find_tree\n{\n  int                n;\n  std::vector<Value> table;\n  std::vector<int>   prt;\n  BinaryOp           op;\n  Value              id;\n\npublic:\n  valued_union_find_tree (int n, BinaryOp op, Value id, Value init) :\n    n(n), table(n, init), prt(n, -1), op(op), id(id)\n    {}\n\n  bool is_root (int x)        const {return prt.at(x) < 0;}\n  int  size    (int x)        const {return -prt.at(find(x));}\n  bool same    (int x, int y) const {return find(x) == find(y);}\n  int  find    (int x)        const\n  {\n    while (!is_root(x)) x = prt.at(x);\n    return x;\n  }\n  auto collect ()             const {return prt;}\n\n  // Returns `true` if x and y are newly connected.\n  // y becomes the partent.\n  bool unite   (int x, int y)\n  {\n    if ((x = find(x)) == (y = find(y))) return false;\n    if (size(x) > size(y)) std::swap(x, y);\n    prt.at(y) += prt.at(x);\n    prt.at(x) = y;\n    table.at(y) = op(table.at(y), table.at(x));\n    table.at(x) = id;\n    return true;\n  }\n\n  auto get     (int x)        const {return table.at(find(x));}\n  auto collect_vals ()        const\n  {\n    std::vector<Value> ret(n);\n    for (auto i = 0; i < n; i++)\n    {\n      ret.at(i) = get(i);\n    }\n    return ret;\n  }\n  void set     (int x, Value val)    {table.at(find(x)) = val;}\n  void add     (int x, Value val)    {set(x, get(x) + val);}\n};\n\ntemplate <typename Value, typename BinaryOp>\nauto make_valued_union_find_tree(int n, BinaryOp op, Value id, Value init)\n{\n  return valued_union_find_tree<Value, BinaryOp>(n, op, id, init);\n}\n\nint main()\n{\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n, h, w;\n  std::cin >> n >> h >> w;\n  auto queries = std::vector<std::tuple<int, int, int>>(n);\n  rep(i, 0, n)\n  {\n    int x, y, a;\n    std::cin >> x >> y >> a;\n    x--, y--, y += h;\n    queries.at(i) = std::make_tuple(a, x, y);\n  }\n  auto uf = make_valued_union_find_tree<int>\n  (\n    h + w,\n    [](auto x, auto y){return x || y;},\n    false,\n    false\n  );\n  std::sort(queries.begin(), queries.end());\n  std::reverse(queries.begin(), queries.end());\n  auto sat = [&] (int x) -> bool\n  {\n    return uf.get(x);\n  };\n  lint ret = 0;\n  for (auto tuple : queries)\n  {\n    int a, x, y;\n    std::tie(a, x, y) = tuple;\n    if (!uf.same(x, y) && (!sat(x) || !sat(y)))\n    {\n      uf.unite(x, y);\n      ret += a;\n    }\n    else if (uf.same(x, y) && !sat(x))\n    {\n      assert(!sat(y));\n      uf.set(y, true);\n      ret += a;\n    }\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing pi = pair<ll, ll>;\n\nint n, h, w;\npair<ll, pi> A[100005];\nvoid input() {\n    cin >> n >> h >> w;\n    for (int i = 0; i < n; i++) {\n        ll r, c, a;\n        cin >> r >> c >> a;\n        A[i] = { a, { r, c } };\n    }\n}\n\nint P[200005];\nint S[200005];\nint E[200005];\n\nint find(int x) {\n    if (P[x] != x) return P[x] = find(P[x]);\n    return x;\n}\n\nbool merge(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x != y) {\n        if (S[x] + S[y] < E[x] + E[y] + 1) return 0;\n        P[y] = x;\n        S[x] += S[y];\n        E[x] += E[y] + 1;\n        return 1;\n    }\n    else {\n        if (S[x] < E[x] + 1) return 0;\n        E[x]++;\n        return 1;\n    }\n}\n\nvoid calc() {\n    for (int i = 1; i <= h + w; i++) {\n        P[i] = i;\n        S[i] = 1;\n        E[i] = 0;\n    }\n    sort(A, A + n);\n    ll ans = 0;\n    for (int i = n; i--; ) {\n        ll r, c;\n        tie(r, c) = A[i].second;\n        if (merge(r, c + h)) ans += A[i].first;\n    }\n    cout << ans;\n}\n\nint main() {\n    ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n    input();\n    calc();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n,R,C;\nvector<vector<int> > g;\nint match[200000];\nint vis[100000],vs;\nbool findPath(int u){\n\tvis[u]=vs;\n\tfor(auto v:g[u])\n\t\tif(match[v]==-1){\n\t\t\tmatch[v]=u;\n\t\t\treturn true;\n\t\t}\n\tint x=rand()%2;\n\tfor(int it=0;it<2;++it){\n\t\tint v=g[u][it^x];\n\t\tif(vis[match[v]]!=vs && findPath(match[v])){\n\t\t\tmatch[v]=u;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\nll calc(vector<vector<int> > &v){\n\tmemset(match,-1,sizeof(match));\n\tll res=0;\n\tfor(int i=0;i<g.size();++i){\n\t\t++vs;\n\t\tif(findPath(i))\n\t\t\tres+=v[i][0];\n\t}\n\treturn res;\n}\nint main(){\n\tsrand(time(0));\n\tscanf(\"%d%d%d\",&n,&R,&C);\n\tvector<vector<int> > v(n,vector<int>(3));\n\tfor(auto &x:v){\n\t\tfor(auto &y:x)\n\t\t\tscanf(\"%d\",&y);\n\t\tswap(x[0],x[2]);\n\t\tswap(x[1],x[2]);\n\t}\n\tsort(v.rbegin(),v.rend());\n\tg.resize(n);\n\tfor(int i=0;i<v.size();++i){\n\t\tint r=--v[i][1];\n\t\tint c=--v[i][2];\n\t\tg[i].push_back(r);\n\t\tg[i].push_back(c+R);\n\t}\n\tcout<<calc(v)<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr  int MOD = 1000000007;\n//constexpr  int MOD = 998244353;\n//constexpr  long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n// int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nstruct Node {\n\tint x, y, score;\n\tNode(const int a, const int b, const int c) {\n\t\ty = a, x = b, score = c;\n\t}\n\tbool operator<(const Node&n)const {\n\t\treturn score < n.score;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> H >> W;\n\tvector<Node>node;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> L >> R >> K;\n\t\tnode.push_back(Node(L - 1, R - 1, K));\n\t}\n\tsort(node.begin(), node.end());\n\treverse(node.begin(), node.end());\n\tlong long int ans = 0;\n\tvector<int>hindex(H, -1);\n\tvector<int>windex(W, -1);\n\tvector<int>hused(H, 0);\n\tvector<int>wused(W, 0);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (hindex[node[i].y] == -1) {\n\t\t\tans += node[i].score;\n\t\t\thindex[node[i].y] = i;\n\t\t}\n\t\telse if (windex[node[i].x] == -1) {\n\t\t\tans += node[i].score;\n\t\t\twindex[node[i].x] = i;\n\t\t}\n\t\telse {\n\t\t\t{\n\t\t\t\tint y, x;\n\t\t\t\ty = node[i].y;\n\t\t\t\tx = node[i].x;\n\t\t\t\tstack<pair<int,int>>Q;\n\t\t\t\tint tate = 1;\n\t\t\t\tbool rev = true;\n\t\t\t\tint nn = i;\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (tate) {\n\t\t\t\t\t\tif (wused[x]) break;\n\t\t\t\t\t\tint box = windex[x];\n\t\t\t\t\t\tif (box == -1) {\n\t\t\t\t\t\t\tans += node[i].score;\n\t\t\t\t\t\t\trev = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twindex[x] = nn;\n\t\t\t\t\t\ty = node[box].y;\n\t\t\t\t\t\tQ.push({ box,tate });\n\t\t\t\t\t\twused[x] = 1;\n\t\t\t\t\t\tnn = box;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (hused[y])break;\n\t\t\t\t\t\tint box = hindex[y];\n\t\t\t\t\t\tif (box == -1) {\n\t\t\t\t\t\t\tans += node[i].score;\n\t\t\t\t\t\t\trev = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thindex[y] = nn;\n\t\t\t\t\t\tx = node[box].x;\n\t\t\t\t\t\tQ.push({ box,tate });\n\t\t\t\t\t\thused[y] = 1;\n\t\t\t\t\t\tnn = box;\n\t\t\t\t\t}\n\t\t\t\t\ttate ^= 1;\n\t\t\t\t}\n\t\t\t\tif (rev) {\n\t\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\t\tint cn = Q.top().first;\n\t\t\t\t\t\tint tate = Q.top().second;\n\t\t\t\t\t\tif (tate) {\n\t\t\t\t\t\t\twindex[node[cn].x] = cn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\thindex[node[cn].y] = cn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tQ.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint y, x;\n\t\t\t\ty = node[i].y;\n\t\t\t\tx = node[i].x;\n\t\t\t\tstack<pair<int, int>>Q;\n\t\t\t\tint tate = 0;\n\t\t\t\tbool rev = true;\n\t\t\t\tint nn = i;\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (tate) {\n\t\t\t\t\t\tif (wused[x]) break;\n\t\t\t\t\t\tint box = windex[x];\n\t\t\t\t\t\tif (box == -1) {\n\t\t\t\t\t\t\tans += node[i].score;\n\t\t\t\t\t\t\trev = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twindex[x] = nn;\n\t\t\t\t\t\ty = node[box].y;\n\t\t\t\t\t\tQ.push({ box,tate });\n\t\t\t\t\t\twused[x] = 1;\n\t\t\t\t\t\tnn = box;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (hused[y])break;\n\t\t\t\t\t\tint box = hindex[y];\n\t\t\t\t\t\tif (box == -1) {\n\t\t\t\t\t\t\tans += node[i].score;\n\t\t\t\t\t\t\trev = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thindex[y] = nn;\n\t\t\t\t\t\tx = node[box].x;\n\t\t\t\t\t\tQ.push({ box,tate });\n\t\t\t\t\t\thused[y] = 1;\n\t\t\t\t\t\tnn = box;\n\t\t\t\t\t}\n\t\t\t\t\ttate ^= 1;\n\t\t\t\t}\n\t\t\t\tif (rev) {\n\t\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\t\tint cn = Q.top().first;\n\t\t\t\t\t\tint tate = Q.top().second;\n\t\t\t\t\t\tif (tate) {\n\t\t\t\t\t\t\twindex[node[cn].x] = cn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\thindex[node[cn].y] = cn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tQ.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#define MN 201000\n\nstruct xxx{\n\tint x, y, k;\n}d[MN]; \n\nint fa[MN], s[MN];\n\nbool cmp(xxx a, xxx b) {return a.k > b.k;}\n\nint Find(int x) {return fa[x] == x ? x : fa[x] = Find(fa[x]);}\n\nint main()\n{\n\tint n, h, w; scanf(\"%d%d%d\", &n, &h, &w);\n\tfor(int i = 1; i <= n; i++) scanf(\"%d%d%d\", &d[i].x, &d[i].y, &d[i].k);\n\tstd::sort(d + 1, d + n + 1, cmp);\n\tfor(int i = 1; i <= h + w; i++) fa[i] = i, s[i] = 1; \n\tlong long Ans = 0;\n\tfor(int i = 1; i <= n; i++)\n\t{\n\t\tint dx = Find(d[i].x), dy = Find(d[i].y + h);\n\t\tif(dx == dy)\n\t\t{\n\t\t\tif(s[dx] >= 1)\n\t\t\t{\n\t\t\t\ts[dx]--;\n\t\t\t\tAns += d[i].k;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(s[dx] + s[dy] >= 1)\n\t\t\t{\n\t\t\t\tfa[dx] = dy;\n\t\t\t\ts[dy] += s[dx] - 1;\n\t\t\t\tAns += d[i].k;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", Ans);\n}\n\n//从大往小贪心加入每个卡片，用Hall定理依次判断 "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\ninline ll read() {ll x = 0;char ch = getchar(), w = 1;while(ch < '0' || ch > '9') {\nif(ch == '-') w = -1;ch = getchar();}while(ch >= '0' && ch <= '9') {x = x * 10 + ch - '0';ch = getchar();\n}return x * w;}\nvoid write(ll x) {if(x < 0) putchar('-'), x = -x;if(x > 9) write(x / 10);putchar(x % 10 + '0');}\ninline void writeln(ll x) {write(x);puts(\"\");}\nusing namespace std;\nconst int N = 3e5 + 6;\nint n;\nint h, w;\nstruct T {\n\tint l, r, v;\n}a[N];\nbool cmp(T x, T y) {\n\treturn x. v > y.v;\n}\nint g[N], fa[N];\nint Find(int x) {\n\treturn fa[x] == x? x : fa[x] = Find(fa[x]);\n}\nint check(int x, int y) {\n\tx = Find(x), y = Find(y);\n\tif(x == y) {\n\t\tif(g[x]) {\n\t\t\t--g[x];\n\t\t\treturn 1;\n\t\t} \n\t\treturn 0;\n\t}\n\tfa[x] = y;\n\tg[y] += g[x];\n\tif(g[y] == 0) return 0;\n\t--g[y];\n\treturn 1;\n}\nint main() {\n\tn = read(), h = read(), w = read();\n\tfor(int i = 1; i <= n; ++i) {\n\t\ta[i].l = read();\n\t\ta[i].r = read();\n\t\ta[i].v = read();\n\t}\n\tll ans = 0;\n\tsort(a + 1, a + 1 + n, cmp);\n\tfor(int i = 1; i <= h + w; ++i) fa[i] = i, g[i] = 1;\n\tfor(int i = 1; i <= n; ++i) if(check(a[i].l, a[i].r + n)){\n\t\tans += a[i].v;\n\t}\n\twriteln(ans);\n \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\nconst int LEN = 100000;\n\nstruct fastio{\n  int it,len;\n  char s[LEN + 5];\n  fastio(){\n    it = len = 0;\n  }\n  char get(){\n    if(it < len) return s[it++];\n    it = 0, len = fread(s,1,LEN,stdin);\n    return len ? s[it++] : EOF;\n  }\n  bool notend(){\n    char c;\n    for(c = get();c == ' ' || c == '\\n';c = get());\n    if(it) it--;\n    return c != EOF;\n  }\n  void put(char c){\n    if(it == LEN) fwrite(s,1,LEN,stdout), it = 0;\n    s[it++] = c;\n  }\n  void flush(){\n    fwrite(s,1,it,stdout);\n  }\n}buff,bufo;\ninline int getint(){\n  char c; int res = 0, sig = 1;\n  for(c = buff.get();c < '0' || c > '9';c = buff.get()) if(c == '-') sig = -1;\n  for(;c >= '0' && c <= '9';c = buff.get()) res = res * 10 + (c - '0');\n  return sig * res;\n}\ninline ll getll(){\n  char c; ll res = 0, sig = 1;\n  for(c = buff.get();c < '0' || c > '9';c = buff.get()) if(c == '-') sig = -1;\n  for(;c >= '0' && c <= '9';c = buff.get()) res = res * 10 + (c - '0');\n  return sig * res;\n}\ninline void putint(int x,char suf){\n  if(!x) bufo.put('0');\n  else{\n    if(x < 0) bufo.put('-'), x = -x;\n    int k = 0; char s[15];\n    while(x){\n      s[++k] = x % 10 + '0';\n      x /= 10;\n    }\n    for(;k;k--) bufo.put(s[k]);\n  }\n  bufo.put(suf);\n}\ninline void putll(ll x,char suf){\n  if(!x) bufo.put('0');\n  else{\n    if(x < 0) bufo.put('-'), x = -x;\n    int k = 0; char s[25];\n    while(x){\n      s[++k] = x % 10 + '0';\n      x /= 10;\n    }\n    for(;k;k--) bufo.put(s[k]);\n  }\n  bufo.put(suf);\n}\ninline char get_char(){\n  char c;\n  for(c = buff.get();c == ' ' || c == '\\n';c = buff.get());\n  return c;\n}\n#define maxn 100005\n#define maxV 200005\nint n,h,w,par[maxV];\nbool loop[maxV];\nvoid ini(int x){\n  for(int i = 1;i <= x;i++) par[i] = i;\n}\nint fin(int u){\n  if(par[u] == u) return u;\n  return par[u] = fin(par[u]);\n}\nbool uni(int u,int v){\n  u = fin(u), v = fin(v);\n  if(u == v){\n    if(!loop[u]){\n      loop[u] = true;\n      return true;\n    }\n    return false;\n  }\n  if(!loop[u] && !loop[v]){\n    par[u] = v;\n    return true;\n  }\n  if(!loop[u] || !loop[v]){\n    par[u] = v;\n    loop[v] = true;\n    return true;\n  }\n  return false;\n}\nstruct edge{\n  int u,v,w;\n  bool operator < (const edge &e){\n    return w > e.w;\n  }\n}el[maxn];\nint main(){\n  n = getint(), h = getint(), w = getint();\n  ini(h + w);\n  for(int i = 1;i <= n;i++){\n    el[i].u = getint(), el[i].v = h + getint(), el[i].w = getint();\n  }\n  sort(el + 1,el + n + 1);\n  ll ans = 0;\n  for(int i = 1;i <= n;i++){\n    ans += uni(el[i].u,el[i].v) * el[i].w;\n  }\n  putll(ans,'\\n');\n  bufo.flush();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<ll, P> P3;\ntypedef pair<P, P> PP;\nconstexpr ll MOD = ll(1e9 + 7);\nconstexpr int IINF = INT_MAX;\nconstexpr ll LLINF = LLONG_MAX;\nconstexpr int MAX_N = int(1e5) + 5;\nconstexpr double EPS = 1e-9;\nconstexpr int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i > 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\ntypedef int FLOW;                // フローを表す型、今回は int 型\nconst int MAX_V = 400000;           // グラフの最大ノード数\nconst FLOW INF = 100000000;      // 十分大きい値\n\n// グラフの辺の構造体\nstruct Edge {\n    int rev, from, to;\n    FLOW cap, icap;\n    Edge(int r, int f, int t, FLOW c) : rev(r), from(f), to(t), cap(c), icap(c) {}\n    friend ostream& operator << (ostream& s, const Edge& E) {\n        if (E.cap > 0) return s << E.from << \"->\" << E.to << '(' << E.cap << ')';\n        else return s;\n    }\n};\n\n// グラフ構造体\nstruct Graph {\n    int V;\n    vector<Edge> list[MAX_V];\n\n    Graph(int n = 0) : V(n) { for (int i = 0; i < MAX_V; ++i) list[i].clear(); }\n    void init(int n = 0) { V = n; for (int i = 0; i < MAX_V; ++i) list[i].clear(); }\n    void resize(int n = 0) { V = n; }\n    void reset() { for (int i = 0; i < V; ++i) for (int j = 0; j < list[i].size(); ++j) list[i][j].cap = list[i][j].icap; }\n    inline vector<Edge>& operator [] (int i) { return list[i]; }\n\n    Edge &redge(Edge e) {\n        if (e.from != e.to) return list[e.to][e.rev];\n        else return list[e.to][e.rev + 1];\n    }\n\n    void addedge(int from, int to, FLOW cap) {\n        list[from].push_back(Edge((int)list[to].size(), from, to, cap));\n        list[to].push_back(Edge((int)list[from].size() - 1, to, from, 0));\n    }\n};\n\n// 最大流を求めるサブルーチンたち\nstatic int level[MAX_V];\nstatic int iter[MAX_V];\n\nvoid dibfs(Graph &G, int s) {\n    for (int i = 0; i < MAX_V; ++i) level[i] = -1;\n    level[s] = 0;\n    queue<int> que;\n    que.push(s);\n    while (!que.empty()) {\n        int v = que.front();\n        que.pop();\n        for (int i = 0; i < G[v].size(); ++i) {\n            Edge &e = G[v][i];\n            if (level[e.to] < 0 && e.cap > 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nFLOW didfs(Graph &G, int v, int t, FLOW f) {\n    if (v == t) return f;\n    for (int &i = iter[v]; i < G[v].size(); ++i) {\n        Edge &e = G[v][i], &re = G.redge(e);\n        if (level[v] < level[e.to] && e.cap > 0) {\n            FLOW d = didfs(G, e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                re.cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// 最大流を求めるメイン関数\nFLOW Dinic(Graph &G, int s, int t) {\n    FLOW res = 0;\n    while (true) {\n        dibfs(G, s);\n        if (level[t] < 0) return res;\n        memset(iter, 0, sizeof(iter));\n        FLOW flow;\n        while ((flow = didfs(G, s, t, INF)) > 0) {\n            res += flow;\n        }\n    }\n}\n\nvector<P> a;\nvector<int> r, c, rcnt, ccnt;\nvector<bool> used;\nGraph G;\n\nint main() {\n    int N, H, W;\n    \n\n    cin >> N >> H >> W;\n    a.resize(N);\n    r.resize(N);\n    c.resize(N);\n    used.resize(N, false);\n    rcnt.resize(H, 0);\n    ccnt.resize(W, 0);\n    ll ans = 0;\n\n    // グラフの定義 (ノード数を引数に)\n\n    // スーパーノード S, T の index\n    int S_node = H + W + N;\n    int T_node = H + W + N + 1;\n\n    for(int i=0;i<N;i++){\n        cin >> r[i] >> c[i] >> a[i].first;\n        r[i]--;\n        c[i]--;\n        rcnt[r[i]]++;\n        ccnt[c[i]]++;\n        a[i].second = i;\n    }\n    vector<P> tmp;\n    for(int i=0;i<N;i++){\n        if(rcnt[r[i]] == 1 || ccnt[c[i]] == 1){\n            ans += a[i].first;\n        }\n        else{\n            tmp.push_back(a[i]);\n        }\n    }\n    a = tmp;\n    SORTR(a);\n\n    G.init(H + W + int(a.size()) + 2);             // +2 は S, T の分\n    // グラフに枝を張っていく\n    for(int i=0;i<int(a.size());i++){\n        int id = a[i].second;\n        G.addedge(r[id], H+W+i, 1);\n        G.addedge(H + c[id], H+W+i, 1);\n    }\n\n    for (int i = 0; i < H+W; ++i) {\n        // S から、容量 1 の枝を張る\n        G.addedge(S_node, i, 1);\n    }\n\n    for (int j = 0; j < N; ++j) {\n        // T へと、容量 1 の枝を張る\n        G.addedge(j + H+W, T_node, 1);\n    }\n\n    // 最大流を求める\n    FLOW res = Dinic(G, S_node, T_node);\n\n    // 誰がどの仕事に割当てられたか\n    for (int i = 0; i < H+W; ++i) {\n        for (auto e : G[i]) {\n            // 元々の容量 (e.icap) が 1 で、フローが流れて容量 (e.cap) が 0 になった部分が割り当てられたところ\n            if (e.icap == 1 && e.cap == 0) {\n                ans += a[e.to - (H+W)].first;\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define REP(i,n) for(ll i=0;i<n;i++)\n#define REP1(i,n) for(ll i=1;i<=n;i++)\n#define FILL(i,n) memset(i,n,sizeof i)\n#define X first\n#define Y second\n#define ET cout << \"\\n\"\n#define SZ(_a) (int)_a.size()\n#define ALL(_a) _a.begin(),_a.end()\n#define pb push_back\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#ifdef bbq\n#define debug(...) {\\\n    fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\", \";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\n#else\n#define debug(...)\n#endif\n\nvector<int> G[100005];\nint mp[100005],mq[200005],fm[100005],vis[100005],nw;\n\nbool bfs(int u)\n{\n\t++nw;\n\tqueue<int> q;\n\tq.push(u),fm[u]=-1,vis[u]=nw;\n\twhile(!q.empty())\n\t{\n\t\tint p=q.front();\n\t\tq.pop();\n\t\tfor(int i:G[p])\n\t\t\tif(!~mq[i])\n\t\t\t{\n\t\t\t\twhile(~p)\n\t\t\t\t{\n\t\t\t\t\tint tmp=mp[i];\n\t\t\t\t\tmp[mq[i]=p]=i,p=fm[p];\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(vis[mq[i]]<nw)\n\t\t\t\tq.push(mq[i]),vis[mq[i]]=nw;\n\t}\n}\n\nstruct mode\n{\n\tint r,c,v;\n\tbool operator<(const mode &a)const{\n\t\treturn v>a.v;\n\t}\n}arr[100005];\n\nint main()\n{\n\tIOS();\n\tll ans=0;\n\tint n,h,w;\n\tcin >> n >> h >> w;\n\tfor(int i=0;i<n;++i)\n\t\tcin >> arr[i].r >> arr[i].c >> arr[i].v,--arr[i].r,--arr[i].c;\n\tsort(arr,arr+n),FILL(mp,-1),FILL(mq,-1);\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tG[i].pb(arr[i].r),G[i].pb(h+arr[i].c);\n\t\tif(bfs(i))\n\t\t\tans+=arr[i].v;\n\t}\n\tcout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\nusing namespace std;\nstruct edge\n{\n\tint r,c,v;\n}e[200001];\nbool cmp(edge a,edge b){return a.v>b.v;}\nint fa[200001];\nint siz[200001];\nint find(int x){return (fa[x]==x)?x:fa[x]=find(fa[x]);}\nsigned main() \n{\n\tint n,h,w;\n\tscanf(\"%d%d%d\",&n,&h,&w);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%d%d%d\",&e[i].r,&e[i].c,&e[i].v);\n\t\te[i].c+=100000;\n\t}\n\tsort(e+1,e+n+1,cmp);\n\tint ans=0;\n\tfor(int i=1;i<=n+100000;i++)\n\t\tfa[i]=i,siz[i]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint f1=find(e[i].r),f2=find(e[i].c);\n\t\tif(f1==f2)\n\t\t{\n\t\t\tif(siz[f1]>=1)\n\t\t\t{\n\t\t\t\tsiz[f1]--;\n\t\t\t\tans+=e[i].v;\n\t\t\t}\n\t\t}\n\t\telse if(siz[f1]+siz[f2]>=1)\n\t\t{\n\t\t\tfa[f1]=f2;\n\t\t\tsiz[f2]+=siz[f1]-1;\n\t\t\tans+=e[i].v;\n\t\t}\n\t}\n\tprintf(\"%d\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define all(v) (v).begin(), (v).end()\n#define sortv(v) sort(all(v))\n#define uniqv(v) (v).erase(unique(all(v)), (v).end())\n#define pb push_back\n#define FI first\n#define SE second\n#define lb lower_bound\n#define ub upper_bound\n#define mp make_pair\n#define test 1\n#define TEST if(test)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\nconst int MOD = 1000000007; // 998244353\nconst int INF = 2e9;\nconst ll INFLL = 1e18;\nconst int MAX_N = 100000;\n\nint N, H, W;\n\n\nstruct S{\n\tint x, y, d;\n\tbool operator <(const S &a)const{\n\t\treturn d<a.d;\n\t}\n};\nvector<S> v;\n\nll ans;\n\nvector<int> gp[MAX_N*2+1];\nbool chk[MAX_N*2+1];\n\nvoid make(int x, int y){\n\tchk[x] = true;\n\tfor(int i : gp[x]){\n\t\tif(i!=y){\n\t\t\tmake(i, x);\n\t\t}\n\t}\n\treturn;\n}\n\nint main(){\n\tcin>>N>>H>>W;\n\tfor(int i=1; i<=N; i++){\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tv.pb((S){a, b+H, c});\n\t}\n\tsort(v.begin(), v.end());\n\twhile(!v.empty()){\n\t\tS now = v.back(); v.pop_back();\n\t\tif((!chk[now.x] && gp[now.x].size()<=1) && (!chk[now.y] && gp[now.y].size()<=1)){\n\t\t\tgp[now.x].pb(now.y);\n\t\t\tif(gp[now.x].size()==2)\tchk[now.x] = true;\n\t\t\tgp[now.y].pb(now.x);\n\t\t\tif(gp[now.y].size()==2)\tchk[now.y] = true;\n\t\t\tans+=(ll)now.d;\n\t\t}\n\t\telse{\n\t\t\tif(chk[now.x] && (!chk[now.y] && gp[now.y].size()<=1)){\n\t\t\t\tmake(now.y, 0);\n\t\t\t\tans+=(ll)now.d;\n\t\t\t}else if((gp[now.x].size()<=1 && !chk[now.x]) && chk[now.y]){\n\t\t\t\tmake(now.x, 0);\n\t\t\t\tans+=(ll)now.d;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;using ll=long long;using uint=unsigned int;using pii=pair<int,int>;using pll=pair<ll,ll>;using ull = unsigned long long;using ld=long double;template<typename T>void _(const char*s,T h){cerr<<s<<\" = \"<<h<<\"\\n\";}template<typename T,typename...Ts>void _(const char*s,T h,Ts...t){int b=0;while(((b+=*s=='(')-=*s==')')!=0||*s!=',')cerr<<*s++;cerr<<\" = \"<<h<<\",\";_(s+1,t...);}// break continue pop_back 998244353\n// #define int ll\n// #define pii pll\n#define f first\n#define s second\n#define pb emplace_back\n#define forn(i,n) for(int i=0;i<(n);++i)\n#define sz(a)((int)(a).size())\n#define sqr(x) ((x)*(x))\nstruct init{init(){cin.tie(0);iostream::sync_with_stdio(0);cout<<fixed<<setprecision(10);cerr<<fixed<<setprecision(5);}~init(){\n#ifdef LOCAL\n#define dbg(...) _(#__VA_ARGS__,__VA_ARGS__)\ncerr<<\"Time elapsed: \"<<(double)clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n#else\n#define dbg(...) \n#endif\n}}init;template<typename T,typename U>void upx(T&x,U y){if(x<y)x=y;}template<typename T,typename U>void upn(T&x,U y){if(x>y)x=y;}mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N=202020;\nstruct kek{\n\tint x,y,c;\n}a[N];\nint p[N],v[N],e[N];\nint get(int x){\n\tif(x==p[x])return x;\n\treturn p[x]=get(p[x]);\n}\nint32_t main(){\n\tint n,h,w;\n\tcin>>n>>h>>w;\n\tforn(i,n){\n\t\tcin>>a[i].x>>a[i].y>>a[i].c;\n\t}\n\tsort(a,a+n,[](const kek&p1,const kek&p2){return p1.c>p2.c;});\n\tfor(int i=1;i<=h+w;++i){\n\t\tp[i]=i;v[i]=1;e[i]=0;\n\t}\n\tint ans=0;\n\tforn(i,n){\n\t\tint x=get(a[i].x),y=get(a[i].y+h);\n\t\tif(x==y){\n\t\t\tif(e[x]<v[x]){\n\t\t\t\tans+=a[i].c;\n\t\t\t\te[x]++;\n\t\t\t}\n\t\t}else{\n\t\t\tp[y]=x;\n\t\t\tv[x]+=v[y];\n\t\t\te[x]+=e[y];\n\t\t\tif(e[x]<v[x]){\n\t\t\t\tans+=a[i].c;\n\t\t\t\te[x]++;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REPP(i,n) for(int i=1;i<=n;i++)\nconst double PI = acos(-1);\nconst double EPS = 1e-15;\nlong long INF=(long long)1E17;\n#define i_7 (long long)(1E9+7)\nlong mod(long a){\n    long long c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\n\nusing namespace std;\nbool prime_(int n){\n  if(n==1){\n    return false;\n  }else if(n==2){\n    return true;\n  }else{\n    for(int i=2;i<=sqrt(n);i++){\n      if(n%i==0){\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nlong long gcd_(long long a, long long b){\n  if(a<b){\n    swap(a,b);\n  }\n  if(a%b==0){\n    return b;\n  }else{\n    return gcd_(b,a%b);\n  }\n}\n \nlong long lcm_(long long x, long long y){\n  return (x/gcd_(x,y))*y;\n}\n \nclass UnionFind {\n    public:\n    //各頂点の親の番号を格納する。その頂点自身が親だった場合は-(その集合のサイズ)を入れる。\n    vector<int> Parent;\n    \n    //クラスを作るときは、Parentの値を全て-1にする。\n    //以下のようにすると全てバラバラの頂点として解釈できる。\n    UnionFind(int N) {\n        Parent = vector<int>(N, -1);\n    }\n    \n    //Aがどのグループに属しているか調べる\n    int root(int A) {\n        if (Parent[A] < 0) return A;\n        return Parent[A] = root(Parent[A]);\n    }\n    \n    //自分のいるグループの頂点数を調べる\n    int size(int A) {\n        return -Parent[root(A)];//先祖をrootで取っておきたい。\n    }\n    \n    //AとBをくっ付ける\n    bool connect(int A, int B) {\n        //AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける\n        A = root(A);\n        B = root(B);\n        if (A == B) {\n            //すでにくっついてるからくっ付けない\n            return false;\n        }\n        \n        //大きい方(A)に小さいほう(B)をくっ付けたい\n        //大小が逆だったらAとBをひっくり返す。\n        if (size(A) < size(B)) swap(A, B);\n        \n        //Aのサイズを更新する\n        Parent[A] += Parent[B];\n        //Bの親をAに変更する\n        Parent[B] = A;\n        \n        return true;\n    }\n};\n\nint main(){\n  \n  int n,h,w;\n  cin>>n>>h>>w;\n  int r[n],c[n];\n  long long a[n];\n  REP(i,n){\n    cin>>r[i]>>c[i]>>a[i];\n    r[i]--;c[i]--;\n  }\n  vector<pair<long long, int>> rows[h];//行ごとに入っているカードを分類\n  vector<pair<long long, int>> columns[w];//列ごとに入っているカードを分類\n  vector<bool> used(n,false);\n  REP(i,n){\n    rows[r[i]].push_back(make_pair(a[i],i));\n    columns[c[i]].push_back(make_pair(a[i],i));\n  }\n  REP(i,h){\n    sort(rows[i].begin(), rows[i].end(), greater<pair<long long, int>>());\n  }\n  REP(i,w){\n    sort(columns[i].begin(), columns[i].end(), greater<pair<long long, int>>());\n  }\n  \n  long long ans = 0;\n  REP(i,h){\n    if(rows[i].empty())continue;\n    used[rows[i][0].second] = true;\n    ans += rows[i][0].first;\n  }\n  int s;\n  REP(i,w){\n    if(columns[i].empty())continue;\n    s = columns[i].size();\n    REP(j,s){\n      if(used[columns[i][j].second])continue;\n      used[columns[i][j].second] = true;\n      ans += columns[i][j].first;\n      break;\n    }\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define debug(a) cerr << #a << \": \" << a << endl\n \ntypedef long long ll;\ntypedef pair<int, int> ii;\n \n#define x first\n#define y second\n \nconst int N = 1e5 + 10;\n\nint n;\nint h, w;\nint col_cnt[N];\nbool row_vis[N];\nbool col_vis[N];\nbool card_vis[N];\npair<int, ii> card[N];\nll ans;\n\nint main() {\n\t#ifdef LOCAL\n\tfreopen(\"in\", \"r\", stdin);\n\tfreopen(\"out\", \"w\", stdout);\n\t#endif\n \n\tcin >> n >> h >> w;\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d %d %d\", &card[i].y.x, &card[i].y.y, &card[i].x);\n\t\tcol_cnt[card[i].y.y]++;\n\t}\n\tsort(card + 1, card + n + 1);\n\n\tfor (int i = n; i >= 1; i--) {\n\t\tif (!row_vis[card[i].y.x] && col_cnt[card[i].y.y] != 1) {\n\t\t\tans += card[i].x;\n\t\t\tcard_vis[i] = true;\n\t\t\trow_vis[card[i].y.x] = true;\n\t\t\tcol_cnt[card[i].y.y]--;\n\t\t}\n\t}\n\n\tfor (int i = n; i >= 1; i--) {\n\t\tif (!card_vis[i] && !col_vis[card[i].y.y]) {\n\t\t\tans += card[i].x;\n\t\t\tcard_vis[i] = true;\n\t\t\tcol_vis[card[i].y.y] = true;\n\t\t}\n\t}\n\n\tcout << ans << endl;\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1 };\nvel dy = { 1,-1,0,0 };\nvoid sol(int i, vvel& nex,set<int>& ad,veb& use, vel& cnt) {\n\tif (cnt[i] == 0) {\n\t\tad.insert(i);\n\t\treturn;\n\t}\n\tif (!use[i]) {\n\t\tuse[i] = true;\n\t\tfor (auto ne : nex[i]) {\n\t\t\tsol(ne, nex,ad, use, cnt);\n\t\t}\n\t}\n}\nsigned main() {\n\tomajinai;\n\tint n, h, w; cin >> n >> h >> w;\n\tvvel cxy(n);\n\tvvel y_i(w);\n\tvvel x_i(h);\n\trep(i, n) {\n\t\tint c, x, y; cin >> x >> y >> c; x--; y--;\n\t\tcxy[i] = { c,x,y };\n\t}\n\tsor(cxy);\n\trep(i, n) {\n\t\tint x = cxy[i][1];\n\t\tint y = cxy[i][2];\n\t\ty_i[y].push_back(i);\n\t\tx_i[x].push_back(i);\n\t}\n\tvel cnt(n, 0);\n\tvvel nex(n);\n\trep(i, w) { \n\t\tsor(y_i[i]);\n\t\tint sz = y_i[i].size();\n\t\tif (sz != 0) {\n\t\t\tcnt[y_i[i].back()]++;\n\t\t\trep(j, sz - 1) {\n\t\t\t\tnex[y_i[i][j + 1]].push_back(y_i[i][j]);\n\t\t\t}\n\t\t}\n\n\t}\n\trep(i, h) { \n\t\tsor(x_i[i]);\n\t\tint sz = x_i[i].size();\n\t\tif (sz != 0) {\n\t\t\tcnt[x_i[i].back()]++;\n\t\t\trep(j, sz - 1) {\n\t\t\t\tnex[x_i[i][j + 1]].push_back(x_i[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tvvel adj(n);\n\tset<int> ad;\n\tveb use(n,false);\n\tint ans = 0;\n\trep(i, n) {\n\t\tif (cnt[i] == 2) {\n\t\t\tsol(i, nex,ad,use, cnt);\n\t\t\tfor (auto x : ad) { adj[x].push_back(i); }\n\t\t}\n\t\tif (cnt[i] >= 1) { ans += cxy[i][0]; }\n\t}\n\tvel pa(n, -1);\n\tvvel ed;\n\trep(i, n) {\n\t\tvel v = adj[i];\n\t\tif (v.size() >= 1) {\n\t\t\ted.push_back({ cxy[i][0],v[0],v.back() });\n\t\t}\n\t}\n\tsor(ed); rev(ed);\n\tvel ex(n, 0);\n\tfor (auto v : ed) {\n\t\tint c = v[0];\n\t\tint x = root(v[1], pa);\n\t\tint y = root(v[2], pa);\n\t\tif (x == y) {\n\t\t\tif (ex[x] == 0) {\n\t\t\t\tex[x] = 1;\n\t\t\t\tans += c;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (ex[x] + ex[y]<=1) {\n\t\t\t\tpa[x] = y;\n\t\t\t\tex[y] += ex[x]; ex[x] = 0;\n\t\t\t\tans += c;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long int LL;\ntypedef long long int ll;\ntypedef pair<long long int, long long int> pii;\ntypedef pair<double, double> pdd;\n\n#define SORT(c) sort((c).begin(),(c).end())\n#define BACKSORT(c) sort((c).begin(),(c).end(),std::greater<LL>())\n#define FOR(i,a,b) for(LL i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define SP << \" \" <<\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n  struct edge {\n    int to;\n    flow_t cap;\n    cost_t cost;\n    int rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< int > prevv, preve;\n\n  PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(int from, int to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n  }\n\n  cost_t min_cost_flow(int s, int t, flow_t f) {\n    int V = (int) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, int >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    LL prev = 0;\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return prev;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n      prev = ret;\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n      }\n    }\n  }\n};\n\nLL mod = 1000000007;\n\nint main()\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  \n  LL N,H,W;\n  cin>>N>>H>>W;\n  \n  //0,1,H+W,N\n  //0->H+W->N->1\n  PrimalDual< int, int > g(2+H+W+N);\n  REP(i,H+W){\n    g.add_edge(0,2+i,1,0);\n  }\n  REP(i,N){\n    LL R,C,A;\n    cin>>R>>C>>A;\n    R--;C--;\n    g.add_edge(2+R,2+H+W+i,1,-A);\n    g.add_edge(2+H+C,2+H+W+i,1,-A);\n    g.add_edge(2+H+W+i,1,1,0);\n  }\n  cout<<-g.min_cost_flow(0,1,200000)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long llong;\n\nconst int maxn=1e5+10;\n\nclass card{\npublic:\n    int v,id;\n\n};\n\nint N,H,W;\nvector< pair<int,int> > r[maxn],c[maxn];\nbool vst[maxn];\n\nint main()\n{\n    scanf(\"%d%d%d\",&N,&H,&W);\n    int R,C,A;\n    for(int i=0;i<N;i++)\n    {\n        scanf(\"%d%d%d\",&R,&C,&A);\n        r[R].push_back(make_pair(A,i));\n        c[C].push_back(make_pair(A,i));\n    }\n    for(int i=1;i<=H;i++)\n        sort(r[i].begin(),r[i].end());\n    for(int i=1;i<=W;i++)\n        sort(c[i].begin(),c[i].end());\n    llong ans=0;\n    for(int i=1;i<=H;i++)\n    {\n        if(!r[i].empty())\n            ans+=r[i][r[i].size()-1].first,\n            vst[r[i][r[i].size()-1].second]=true;\n    }\n    for(int i=1;i<=W;i++)\n    {\n        if(c[i].empty()) continue;\n        int j=c[i].size()-1;\n        while(j>=0)\n        {\n            if(!vst[c[i][j].second])\n            {\n                ans+=c[i][j].first;\n                break;\n            }\n            j--;\n        }\n    }\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// iostream is too mainstream\n#include <cstdio>\n// bitch please\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <list>\n#include <cmath>\n#include <iomanip>\n#include <time.h>\n#define dibs reserve\n#define OVER9000 1234567890\n#define ALL_THE(CAKE,LIE) for(auto LIE =CAKE.begin(); LIE != CAKE.end(); LIE++)\n#define tisic 47\n#define soclose 1e-8\n#define chocolate win\n// so much chocolate\n#define patkan 9\n#define ff first\n#define ss second\n#define abs(x) (((x) < 0)?-(x):(x))\n#define uint unsigned int\n#define dbl long double\n#define pi 3.14159265358979323846\nusing namespace std;\n// mylittledoge\n\nusing cat = long long;\n\n#ifdef DONLINE_JUDGE\n\t// palindromic tree is better than splay tree!\n\t#define lld I64d\n#endif\n\nint push_comp(int v, vector<int> & comp_up) {\n\tint C = v;\n\twhile(comp_up[C] != C) C = comp_up[C];\n\twhile(comp_up[v] != C) {\n\t\tint up = comp_up[v];\n\t\tcomp_up[v] = C;\n\t\tv = up;\n\t}\n\treturn C;\n}\n\nint main() {\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\tint N, H, W;\n\tcin >> N >> H >> W;\n\tvector< pair<int, pair<int, int> > > V(N);\n\tfor(int i = 0; i < N; i++) cin >> V[i].ss.ff >> V[i].ss.ss >> V[i].ff;\n\tsort(begin(V), end(V));\n\tvector<int> comp_up(H+W), comp_sz(H+W, 1);\n\tfor(int i = 0; i < H+W; i++) comp_up[i] = i;\n\tvector<char> comp_done(H+W, 0);\n\tcat ans = 0;\n\tfor(int i = N-1; i >= 0; i--) {\n\t\tint u = V[i].ss.ff, v = V[i].ss.ss + H;\n\t\tu = push_comp(u, comp_up);\n\t\tv = push_comp(v, comp_up);\n\t\tif(comp_done[u] && comp_done[v]) continue;\n\t\tans += V[i].ff;\n\t\tif(u == v) comp_done[u] = 1;\n\t\telse {\n\t\t\tif(comp_sz[u] > comp_sz[v]) swap(u, v);\n\t\t\tcomp_up[u] = v;\n\t\t\tcomp_sz[v] += comp_sz[u];\n\t\t\tcomp_done[v] |= comp_done[u];\n\t\t}\n\t}\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n// look at my code\n// my code is amazing\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define debug(...) { printf(\"#  \"); printf(__VA_ARGS__); puts(\"\"); }\n#define ll long long\n#define endl \"\\n\" \nusing VI = vector <int>;\nconstexpr int N = 3e5 + 10;\nconstexpr int mod = 1e9 + 7;\ntemplate <class T1, class T2> inline void chadd(T1 &x, T2 y) { x += y; if (x >= mod) x -= mod; else if (x < 0) x += mod; } \ntemplate <class T1, class T2> inline void chmax(T1 &x, T2 y) { if (x < y) x = y; }\ntemplate <class T1, class T2> inline void chmin(T1 &x, T2 y) { if (x > y) x = y; }\ninline int rd() { int x; cin >> x; return x; }\ntemplate <class T> inline void rd(T &x) { cin >> x; }\ntemplate <class T > inline void out(T s) { cout << s << \"\\n\"; }\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a % b) : a; }\ninline ll qpow(ll base, ll n) { ll res = 1; while (n) { if (n & 1) res = res * base % mod; base = base * base % mod; n >>= 1; } return res; }\nint n, h, w, fa[N], szep[N], szee[N];\nstruct node { \n\tint x, y, w; \n\tvoid scan() {\n\t\tcin >> x >> y >> w;\n\t\ty += h; \n\t}\n\tbool operator < (const node &other) const {\n\t\treturn w > other.w;\n\t}\n}e[N];\nint find(int x) {\n\treturn fa[x] == x ? x : fa[x] = find(fa[x]);\n}\nvoid run() {\n\tfor (int i = 1; i <= n; ++i) e[i].scan();\n\tsort(e + 1, e + 1 + n);\n\tfor (int i = 1; i <= h + w; ++i) {\n\t\tfa[i] = i;\n\t\tszep[i] = 1;\n\t\tszee[i] = 0;\n\t}\n\tll res = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tint u = find(e[i].x), v = find(e[i].y), w = e[i].w;\n\t\tif (u == v) {\n\t\t\tif (szee[u] < szep[u]) {\n\t\t\t\tres += w;\n\t\t\t\t++szee[u];\n\t\t\t}\n\t\t} else {\n\t\t\tif (szee[u] + szee[v] < szep[u] + szep[v]) {\n\t\t\t\tres += w;\n\t\t\t\tfa[u] = v;\n\t\t\t\tszee[v] += szee[u]; ++szee[v];\n\t\t\t\tszep[v] += szep[u];\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr); cout.tie(nullptr);\n\tcout << fixed << setprecision(20);\n\twhile (cin >> n >> h >> w) run();\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint N,H,W;\nint x[1<<17],y[1<<17],A[1<<17];\n\tbool used[1<<17];\n\tvector<pair<int,int> >X[1<<17],Y[1<<17];\nlong f(){\n\tfor(int i=1;i<=H;i++)X[i].clear();\n\tfor(int i=1;i<=W;i++)Y[i].clear();\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tX[x[i]].push_back(make_pair(A[i],i));\n\t\tY[y[i]].push_back(make_pair(A[i],i));\n\t\tused[i]=false;\n\t}\n\tlong ans=0;\n\tfor(int i=1;i<=H;i++)\n\t{\n\t\tsort(X[i].rbegin(),X[i].rend());\n\t\tif(X[i].size())\n\t\t{\n\t\t\tans+=X[i][0].first;\n\t\t\tused[X[i][0].second]=true;\n\t\t}\n\t}\n\tfor(int i=1;i<=W;i++)\n\t{\n\t\tsort(Y[i].rbegin(),Y[i].rend());\n\t\tif(Y[i].size())\n\t\t{\n\t\t\tif(used[Y[i][0].second])\n\t\t\t{\n\t\t\t\tint id=Y[i][0].second;\n\t\t\t\tint j=1;\n\t\t\t\twhile(j<X[x[id]].size()&&used[X[x[id]][j].second])j++;\n\t\t\t\tif(j<X[x[id]].size())\n\t\t\t\t{\n\t\t\t\t\tans+=X[x[id]][j].first;\n\t\t\t\t\tused[X[x[id]][j].second]=true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans+=Y[i][0].first;\n\t\t\t\tused[Y[i][0].second]=true;\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\nmain()\n{\n\tcin>>N>>H>>W;\n\tfor(int i=0;i<N;i++)\n\t{\n\t\tcin>>x[i]>>y[i]>>A[i];\n\t}\n\tlong L=f();\n\tswap(H,W);\n\tfor(int i=0;i<N;i++)swap(x[i],y[i]);\n\tlong R=f();\n\tcout<<max(L,R)<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 2e5 + 5;\n\nint n, h, w, a[N], b[N], c[N];\n\nclass Flows {\nprivate:\n    struct edge {\n        int u, v, cap, flow, cost;\n        edge (int u = 0, int v = 0, int cap = 0, int flow = 0, int cost = 0): u(u), v(v), cap(cap), flow(flow), cost(cost) {}\n        int other (edge ed, int u) {\n            return ed.u == u ? ed.v : ed.u;\n        }\n    } E;\n\n    vector <edge> e;\n    bool inqueue[N];\n    queue <int> q;\n    int dist[N], par[N], S, T;\n    vector <int> g[N];\n\n    bool spfa(){\n        memset(dist, 0x3f, sizeof(dist)); memset(par, -1, sizeof(par)); memset(inqueue, 0, sizeof(inqueue));\n        dist[S] = 0; par[S] = 1e9 + 2277; inqueue[S] = true; q.push(S);\n        while (!q.empty()) {\n            int u = q.front(); q.pop(); inqueue[u] = false;\n            for (auto V: g[u]) {\n                edge ed = e[V];\n                int v = E.other(ed, u);\n                if (dist[v] > dist[u] + ed.cost && ed.flow < ed.cap) {\n                    dist[v] = dist[u] + ed.cost;\n                    par[v] = V;\n                    if (!inqueue[v]) {\n                        inqueue[v] = true;\n                        q.push(v);\n                    }\n                }\n            }\n        }\n\n        return par[T] != -1;\n    }\n\n    int edmond_karp(){\n        int ans = 1e9, u = T;\n        while (u != S) {\n            ans = min(ans, e[par[u]].cap - e[par[u]].flow);\n            u = E.other(e[par[u]], u);\n        }\n\n        u = T;\n        while (u != S) {\n            e[par[u]].flow += ans;\n            e[par[u] ^ 1].flow -= ans;\n            u = E.other(e[par[u]], u);\n        }\n\n        return ans;\n    }\n\npublic:\n    void init (int _S, int _T) {\n        S = _S;\n        T = _T;\n    }\n\n    void addEdge (int u, int v, int cap, int flow, int cost) {\n        g[u].push_back(e.size());\n        e.push_back(edge(u, v, cap, flow, cost));\n        g[v].push_back(e.size());\n        e.push_back(edge(v, u, 0, 0, -cost));\n    }\n\n    long long getCost(){\n        long long ans = 0;\n        while (spfa()) edmond_karp();\n        for (auto i: e) if (i.flow > 0) ans += 1LL * i.flow * i.cost;\n        return ans;\n    }\n} mcmf;\n\nint main(){\n    scanf(\"%d %d %d\", &n, &h, &w);\n    for (int i = 1; i <= n; i++) scanf(\"%d %d %d\", &a[i], &b[i], &c[i]);\n    mcmf.init(0, h + w + n + 1);\n\n    for (int i = 1; i <= h + w; i++) mcmf.addEdge(0, i, 1, 0, 0);\n    for (int i = 1; i <= n; i++) mcmf.addEdge(h + w + i, h + w + n + 1, 1, 0, -c[i]);\n    for (int i = 1; i <= n; i++) {\n        mcmf.addEdge(a[i], h + w + i, 1, 0, 0);\n        mcmf.addEdge(h + b[i], h + w + i, 1, 0, 0);\n    }\n\n    printf(\"%lld\", -mcmf.getCost());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst ll mod=1000000007,MAX=200005,INF=1<<30;\n\nint par[MAX],size[MAX],edgesize[MAX];\n\nvoid init(int n){\n    for(int i=0;i<n;i++){\n        par[i]=i;\n        size[i]=1;\n        edgesize[i]=0;\n    }\n}\n\nint root(int a){\n    if(par[a]==a) return a;\n    else return par[a]=root(par[a]);\n}\n\nvoid unite(int a,int b){\n    if(root(a)!=root(b)){\n        size[root(a)]+=size[root(b)];\n        edgesize[root(a)]+=edgesize[root(b)];\n        par[root(b)]=root(a);\n    }\n}\n\nbool check(int a,int b){\n    return root(a)==root(b);\n}\n\nstruct edge{\n    int from;\n    int to;\n    ll cost;\n};\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,H,W;cin>>N>>H>>W;\n    init(H+W);\n    \n    vector<edge> S(N);\n    for(int i=0;i<N;i++){\n        cin>>S[i].from>>S[i].to>>S[i].cost;\n        S[i].from--;\n        S[i].to--;\n        S[i].to+=H;\n    }\n    sort(all(S),[](edge a,edge b){\n        return a.cost>b.cost;\n    });\n    \n    ll ans=0;\n    \n    for(int i=0;i<N;i++){\n        int a=S[i].from,b=S[i].to;\n        ll c=S[i].cost;\n        if(check(a,b)){\n            if(size[root(a)]==edgesize[root(a)]) continue;\n            else{\n                edgesize[root(a)]++;\n                ans+=c;\n            }\n        }else{\n            if(size[root(a)]+size[root(b)]>edgesize[root(a)]+edgesize[root(b)]){\n                unite(a,b);\n                edgesize[root(a)]++;\n                ans+=c;\n            }\n        }\n    }\n    \n    cout<<ans<<endl;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef pair < int , int > pii;\ntypedef pair < int , pii > p3i;\n#define mpr make_pair\n#define FS first\n#define SC second\nint n,h,w,dl[100005],dc[100005];\np3i as[100005];\nint main(){\n\tint i,j,k;\n\tscanf(\"%d%d%d\",&n,&h,&w);\n\tfor(i=0;i<n;++i){\n\t\tscanf(\"%d%d%d\",&(as[i].SC.FS),&(as[i].SC.SC),&(as[i].FS));\n\t}\n\tsort(as,as+n);\n\tLL res=0ll;\n\tmemset(dl,-1,sizeof(dl));\n\tmemset(dc,-1,sizeof(dc));\n\tfor(i=n-1;i>=0;--i){\n\t\tint x=as[i].SC.FS,y=as[i].SC.SC,z=as[i].FS;\n\t\tif(dl[x]==n && dc[y]==n) continue;\n\t\tif(dl[x]==n){\n\t\t\tif(dc[y]!=-1){\n\t\t\t\tint d=dc[y];\n\t\t\t\tdc[y]=-1;\n\t\t\t\tdl[as[d].SC.FS]=n;\n\t\t\t}\n\t\t\tdc[y]=n;\n\t\t}\n\t\telse if(dc[y]==n){\n\t\t\tif(dl[x]!=-1){\n\t\t\t\tint d=dl[x];\n\t\t\t\tdl[x]=-1;\n\t\t\t\tdc[as[d].SC.SC]=n;\n\t\t\t}\n\t\t\tdl[x]=n;\n\t\t}\n\t\telse if(dl[x]==dc[y] && dl[x]!=-1){\n\t\t\tdl[x]=dc[y]=n;\n\t\t}\n\t\telse{\n\t\t\tif(dl[x]!=-1){\n\t\t\t\tint d=dl[x];\n\t\t\t\tdl[x]=-1;\n\t\t\t\tdc[as[d].SC.SC]=n;\n\t\t\t}\n\t\t\tif(dc[y]!=-1){\n\t\t\t\tint d=dc[y];\n\t\t\t\tdc[y]=-1;\n\t\t\t\tdl[as[d].SC.FS]=n;\n\t\t\t}\n\t\t\tdl[x]=dc[y]=i;\n\t\t}\n\t\tres+=(LL)z;\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T>\nvoid out(T x) { cout << x << endl; exit(0); }\n#define watch(x) cout << (#x) << \" is \" << (x) << endl\n\n\n\n\n\nusing ll = long long;\n\n\nconst int maxn = 1e6 + 5;\n\n\n\n\nint cap[maxn];\nint siz[maxn];\nint par[maxn];\n\n\nint parent(int x) {\n    if (x==par[x]) return x;\n    return par[x]=parent(par[x]);\n}\n\nint main() {\n    ios_base::sync_with_stdio(false); cin.tie(0);  cout.tie(0);\n    int n, h, w;\n    cin>>n>>h>>w;\n\n    for (int i=0; i<h+w; i++) {\n\tcap[i] = 1;\n\tsiz[i] = 1;\n\tpar[i] = i;\n    }\n    \n    \n    vector<pair<ll,pair<int,int>>> cards;\n    for (int i=0; i<n; i++) {\n\tint r,c,a;\n\tcin>>r>>c>>a;\n\t--r; --c;\n\tcards.push_back({a,{r,c}});\n    }\n\n    sort(cards.begin(), cards.end());\n\n\n    ll res = 0;\n\n    while (!cards.empty()) {\n\tauto card = cards.back();\n\tll val = card.first;\n\tint r = card.second.first;\n\tint c = card.second.second + h;\n\tcards.pop_back();\n\n\tr = parent(r);\n\tc = parent(c);\n\n\tif (r==c) {\n\t    if (cap[r] >= 1) {\n\t\tres += val;\n\t\tcap[r]--;\n\t    }\n\t} else {\n\t    if (cap[r]+cap[c] >= 1) {\n\t\tres += val;\n\t\tif (siz[r] < siz[c]) {\n\t\t    swap(r, c);\n\t\t}\n\t\tsiz[r] += siz[c];\n\t\tpar[c] = r;\n\t\tcap[r] += cap[c];\n\t\tcap[r]--;\n\t    }\n\t}\n    }\n\n    cout<<res<<endl; \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MAXN = 3e5+10;\n\nint bit[MAXN];\nint par[MAXN];\nint parent(int i) {\n  return par[i] < 0 ? i: (par[i]=parent(par[i]));\n}\n\nbool merge(int a, int b) {\n  int x = parent(a);\n  int y = parent(b);\n  if (x==y) {\n    if (bit[x]) return false;\n    else return bit[x] = 1;\n  }\n  if (bit[x] && bit[y]) return false;\n  bit[x]+=bit[y];\n  bit[y] = x;\n  return 1;\n}\n\nint gc=0;\nmap<pair<int,int>, int> m;\nint gid(int r, int c) {\n  auto p = make_pair(r,c);\n  if (m.count(p)) {\n    return m[p];\n  }\n  else {\n    return  m[p] = gc++;\n  }\n}\n\nint n, h, w;\n\nint main(){\n  cin.tie(0); ios_base::sync_with_stdio(0);\n  cin >> n >> h >> w;\n  memset(par, -1,sizeof par);\n  vector<vector<int>> v;\n  for(int i=0;i<n;i++) {\n    int r, c, w;\n    cin >> r >> c >> w;\n    v.push_back({w,r,c});\n  }\n  sort(v.rbegin(), v.rend());\n  ll ans = 0;\n  for(auto p: v) {\n    if (merge(gid(p[1],0), gid(p[2],1))){\n      ans+=p[0];\n      //cerr << \"ADDING \" << p[1] << \" \" << p[2] << \" \" << p[0] <<endl;\n    }\n    else \n      //cerr << \"NOT ADDING \" << p[1] << \" \" << p[2] << \" \" << p[0] <<endl;\n  }\n  cout << ans <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing ll = long long;\nusing P = pair<int, int>;\nconst int MX = 100005;\nint pr[MX*2], n, u, h, w, a, r[MX], c[MX];\nP p[MX];\nvector<int> G[MX];\nbool used[MX];\nbool dfs(int v){\n\tused[v] = true;\n\tfor(int it: G[v]){\n\t\tint w = pr[it];\n\t\tif(w < 0 || (!used[w] && dfs(w))){\n\t\t\tpr[it] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nll bi_match(){\n\tll res = 0;\n\tfill(pr, pr+u, -1);\n\trep(i,n){\n\t\tfill(used,used+n,0);\n\t\tif(dfs(i)) res += p[i].first;\n\t}\n\treturn res;\n}\nint main(){\n\tscanf(\"%d%d%d\", &n, &h, &w);\n\tu = h + w;\n\trep(i,n){\n\t\tscanf(\"%d%d%d\", r+i, c+i, &a);\n\t\tr[i]--; c[i]--;\n\t\tp[i] = P(a,i);\n\t}\n\tsort(p,p+n, greater<P>());\n\trep(i,n){\n\t\tG[i].push_back(r[p[i].second]);\n\t\tG[i].push_back(h+c[p[i].second]);\n\t}\n\tprintf(\"%lld\\n\", bi_match());\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int N=1e5+5;\nint n,h,w,f[N<<1],si[N<<1];\nbool vis[N<<1];\nstruct node\n{\n    int a,x,y;\n    bool operator<(const node&o)const\n    {\n        return a>o.a;\n    }\n}a[N];\nint getf(int x){return f[x]==x?f[x]:f[x]=getf(f[x]);}\nint main()\n{\n    scanf(\"%d%d%d\",&n,&h,&w);\n    for(int i=1;i<=n;i++) scanf(\"%d%d%d\",&a[i].x,&a[i].y,&a[i].a),a[i].y+=n;\n    sort(a+1,a+1+n);\n    for(int i=1;i<=n<<1;i++)\n        f[i]=i,si[i]=1;\n    ll ans=0;\n    for(int i=1;i<=n;i++)\n    {\n        int fx=getf(a[i].x),fy=getf(a[i].y);\n        if(fx!=fy){f[fy]=fx;si[fx]+=si[fy];}\n        if(si[fx])\n        {\n            ans+=a[i].a;\n            si[fx]--;\n        }\n    }\n    printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nstruct edge\n{\n\tint r,c,v;\n}e[200001];\nbool cmp(edge a,edge b){return a.v>b.v;}\nint fa[200001];\nint siz[200001];\nint find(int x){return (fa[x]==x)?x:fa[x]=find(fa[x]);}\nsigned main() \n{\n\tint n,h,w;\n\tscanf(\"%lld%lld%lld\",&n,&h,&w);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tscanf(\"%lld%lld%lld\",&e[i].r,&e[i].c,&e[i].v);\n\t\te[i].c+=h;\n\t}\n\tsort(e+1,e+n+1,cmp);\n\tint ans=0;\n\tfor(int i=1;i<=w+h;i++)\n\t\tfa[i]=i,siz[i]=1;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint f1=find(e[i].r),f2=find(e[i].c);\n\t\tif(f1==f2)\n\t\t{\n\t\t\tif(siz[f1]>=1)\n\t\t\t{\n\t\t\t\tsiz[f1]--;\n\t\t\t\tans+=e[i].v;\n\t\t\t}\n\t\t}\n\t\telse if(siz[f1]+siz[f2]>=1)\n\t\t{\n\t\t\tfa[f1]=f2;\n\t\t\tsiz[f2]+=siz[f1]-1;\n\t\t\tans+=e[i].v;\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n    #define _GLIBCXX_DEBUG\n#endif\n#pragma GCC optimize(\"Ofast\")\n#include <cassert>\n#include <cstring>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <complex>\n#include <iomanip>\n#include <bitset>\n#include <random>\n#include <chrono>\n\n#define stdin_filepath \"stdin.txt\"\n#define stdout_filepath \"stdout.txt\"\n#define stderr_filepath \"stderr.txt\"\n#define iostream_untie true\n#define stdout_precision 10\n#define stderr_precision 10\n#define rep(i,n) for(int_fast64_t i = 0; i < (int_fast64_t)(n); ++i)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcountll\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing pii = pair<int, int>;\nusing pll = pair<int_fast64_t, int_fast64_t>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / (T)2 - (T)1234567;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\n\nnamespace execution {\n    std::chrono::system_clock::time_point start_time, end_time;\n    void print_elapsed_time() {\n        end_time = std::chrono::system_clock::now();\n        std::cerr << \"\\n----- Exec time : \";\n        std::cerr << std::chrono::duration_cast<std::chrono::milliseconds>(end_time - start_time).count();\n        std::cerr << \" ms -----\\n\";\n    }\n    struct setupper {\n        setupper() {\n            if(iostream_untie) {\n                ios::sync_with_stdio(false);\n                std::cin.tie(nullptr);\n                // std::cout.tie(nullptr);\n                // std::cerr.tie(nullptr);\n            }\n            std::cout << std::fixed << std::setprecision(stdout_precision);\n            std::cerr << std::fixed << std::setprecision(stderr_precision);\n    #ifdef LOCAL\n            if(!freopen(stderr_filepath, \"wt\", stderr)) {\n                freopen(\"CON\", \"wt\", stderr);\n                std::cerr << \"Failed to open the stderr file\\n\";\n            }\n            if(!freopen(stdout_filepath, \"wt\", stdout)) {\n                freopen(\"CON\", \"wt\", stdout);\n                std::cerr << \"Failed to open the stdout file\\n\";\n            }\n            if(!freopen(stdin_filepath, \"rt\", stdin)) {\n                freopen(\"CON\", \"rt\", stdin);\n                std::cerr << \"Failed to open the stdin file\\n\";\n            }\n            atexit(print_elapsed_time);\n            start_time = std::chrono::system_clock::now();\n    #endif\n        }\n    } __setupper;\n}\n\nstruct myclock_t {\n    std::chrono::system_clock::time_point built_pt, last_pt;\n    int built_ln, last_ln;\n    string built_func, last_func;\n    std::ostream &os;\n    bool is_built;\n\n    myclock_t(std::ostream &_os = std::cerr) : os(_os), is_built(false) {}\n\n    void build(int crt_ln, const string &crt_func) {\n        is_built = true;\n        last_pt = built_pt = std::chrono::system_clock::now();\n        last_ln = built_ln = crt_ln, last_func = built_func = crt_func;\n    }\n    \n    void set(int crt_ln, const string &crt_func) {\n        if(is_built) {\n            last_pt = std::chrono::system_clock::now();\n            last_ln = crt_ln, last_func = crt_func;\n        } else {\n            cerr << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::set failed (yet to be built clock!)\\n\";\n        }\n    }\n\n    void get(int crt_ln, const string &crt_func) {\n        if(is_built) {\n            std::chrono::system_clock::time_point crt_pt(chrono::system_clock::now());\n            int64_t diff = std::chrono::duration_cast<std::chrono::milliseconds>(crt_pt - last_pt).count();\n            os << diff << \" ms elapsed from\" << \" [ \" <<  last_ln << \" : \" << last_func << \" ]\";\n            if(last_ln == built_ln) os << \" (when built)\";\n            os << \" to\" << \" [ \" << crt_ln << \" : \" << crt_func << \" ]\" << \"\\n\";\n            last_pt = built_pt, last_ln = built_ln, last_func = built_func;\n        } else {\n            cerr << \"[ \" << crt_ln << \" : \" << crt_func << \" ] \" << \"myclock_t::get failed (yet to be built clock!)\\n\";\n        }\n    }\n};\n#if defined(DEBUG) || defined(LOCAL)\n    myclock_t myclock(std::cerr);\n    #define build_clock() myclock.build(__LINE__, __func__)\n    #define set_clock() myclock.set(__LINE__, __func__)\n    #define get_clock() myclock.get(__LINE__, __func__)\n#else\n    #define build_clock()\n    #define set_clock()\n    #define get_clock()\n#endif\n\nnamespace std {\n    template <class RAitr> void rsort(RAitr __first, RAitr __last) {\n        sort(__first, __last, greater<>());\n    }\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class tuple_t, size_t index = tuple_size<tuple_t>::value - 1>\n    struct hashval_calc {\n        static void apply(size_t& seed, tuple_t const& t) {\n            hashval_calc<tuple_t, index - 1>::apply(seed, t);\n            hash_combine(seed,get<index>(t));\n        }\n    };\n    template <class tuple_t>\n    struct hashval_calc<tuple_t, 0> {\n        static void apply(size_t& seed, tuple_t const& t) {\n            hash_combine(seed,get<0>(t));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& t) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,t);\n            return seed;\n        }\n    };\n}\n\ntemplate <class T, class U> istream &operator>> (istream &s, pair<T,U> &p) { return s >> p.first >> p.second; }\ntemplate <class T, class U> ostream &operator<< (ostream &s, const pair<T,U> p) { return s << p.first << \" \" << p.second; }\ntemplate <class T> istream &operator>> (istream &s, vector<T> &v) { for(T &e : v) { s >> e; }   return s; }\ntemplate <class T> ostream &operator<< (ostream &s, const vector<T> &v) {\n    for(size_t i = 0; i < v.size(); ++i) { s << (i ? \" \" : \"\") << v[i]; }   return s;\n}\ntemplate <class tuple_t, size_t index>\nstruct tupleos {\n    static ostream &apply(ostream &s, const tuple_t &t) {\n        tupleos<tuple_t,index - 1>::apply(s,t);\n        return s << \" \" << get<index>(t);\n    }\n};\ntemplate <class tuple_t>\nstruct tupleos<tuple_t, 0> {\n    static ostream &apply(ostream &s, const tuple_t &t) {\n        return s << get<0>(t);\n    }\n};\ntemplate <class ...T> ostream &operator<< (ostream &s, const tuple<T...> &t) {\n    return tupleos<tuple<T...>, tuple_size<tuple<T...>>::value - 1>::apply(s,t);\n}\ntemplate <> ostream &operator<< (ostream &s, const tuple<> &t) { return s; }\n#ifdef DEBUG\n    #define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \", dump_func(__VA_ARGS__)\n#else\n    #define dump(...)\n#endif\ntemplate <class T> void dump_func(const T &x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(const T &x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T> void write(const T &x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(const T &x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(const T &x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\ntemplate <class P> void read(P __first, P __second) { for(P i = __first; i != __second; ++i) cin >> *i; }\n\ntemplate <class T> bool chmin(T &x, const T &y) { return x > y ? x = y, true : false; }\ntemplate <class T> bool chmax(T &x, const T &y) { return x < y ? x = y, true : false; }\ntemplate <class T> constexpr T minf(const T &x, const T &y) { return min(x,y); }\ntemplate <class T> constexpr T maxf(const T &x, const T &y) { return max(x,y); }\nconstexpr bool odd(int_fast64_t n) { return n & 1; }\nconstexpr bool even(int_fast64_t n) { return (int)odd(n) ^ 1; }\nconstexpr bool bit(int_fast64_t n, int e) { return (n >> e) & 1; }\nconstexpr int_fast64_t mask(int_fast64_t n, int e) { return n & ((1 << e) - 1); }\nconstexpr int_fast64_t ilog(int_fast64_t x, int_fast64_t b = 2) { return x ? 1 + ilog(x / b, b) : -1; }\nconstexpr int_fast64_t gcd(int_fast64_t x, int_fast64_t y) {\n    x = x > 0 ? x : -x, y = y > 0 ? y : -y;\n    while(y) x ^= y ^= (x %= y) ^= y;\n    return x;\n}\nconstexpr int_fast64_t lcm(int_fast64_t x, int_fast64_t y) { return x ? x / gcd(x, y) * y : 0; }\nint_fast64_t binry(int_fast64_t ok, int_fast64_t ng, const function<bool(int_fast64_t)> &fn) {\n    while (abs(ok - ng) > 1) {\n        int_fast64_t mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array, (T*)(array + N), val); }\ntemplate <class A, size_t N> void init(A (&array)[N]) { memset(array, 0, sizeof(array)); }\ntemplate <class T> vector<int> cmprs(const vector<T> &v) {\n    vector<T> tmp = v; vector<int> ret;\n    sort(begin(tmp),end(tmp));\n    tmp.erase(unique(begin(tmp),end(tmp)), end(tmp));\n    for(const T &i : v) ret.emplace_back(lower_bound(begin(tmp),end(tmp),i) - begin(tmp));\n    return ret;\n}\ntemplate <class T> vector<int> cmprs(const T *__first, const T *__last) {\n    return cmprs(vector<T>(__first, __last));\n}\nvoid for_subset(int_fast64_t s, const function<void(int_fast64_t)> &fn) {\n    int_fast64_t t = s;\n    do { fn(t); } while((--t &= s) != s);\n}\n\n\n/* The main code follows. */\n\ntemplate <class cost_t, class cap_t>\nstruct Flow {\n    struct edge_t { int from, to; cost_t cost; cap_t cap; size_t rev; };\n    size_t V,E;\n    vector<vector<size_t>> adj;\n    vector<edge_t> edge;\n    bool neg_edge_exi;\n\n    Flow(size_t _V) : V(_V), E(), edge(), neg_edge_exi()\n    {\n        adj.resize(V*2);\n    }\n\n    void add_edge(int from, int to, cost_t cost, cap_t cap) {\n        size_t pos = edge.size();\n        size_t rpos = pos + 1;\n        edge.emplace_back((edge_t){ from, to, cost, cap, rpos });\n        adj[from].emplace_back(pos);\n        edge.emplace_back((edge_t){ to, from, -cost, 0, pos });\n        adj[to].emplace_back(rpos); \n        ++E; if(cost < 0) neg_edge_exi = true;\n    }\n\n    vector<cost_t> Dijkstra(int s) {\n        vector<cost_t> dist(V,inf<cost_t>);\n        priority_queue<pair<cost_t,int>,vector<pair<cost_t,int>>,greater<pair<cost_t,int>>> que;\n        que.emplace(dist[s] = 0, s);\n        while(!que.empty()) {\n            auto p = que.top(); que.pop();\n            int v = p.second;\n            if(dist[v] < p.first) continue;\n            for(size_t i : adj[v]) {\n                edge_t &e = edge[i];\n                if(e.cap > 0 && dist[v] + e.cost < dist[e.to]) que.emplace(dist[e.to] = dist[v] + e.cost, e.to);\n            } \n        }\n        return dist;\n    }\n\n    struct Fold_Fulkerson_exe {\n        vector<edge_t> &edge;\n        vector<vector<size_t>> &adj;  \n        vector<bool> used;\n\n        Fold_Fulkerson_exe(Flow &_F) : edge(_F.edge), adj(_F.adj)\n        {\n            used.resize(_F.V);\n        }\n\n        cap_t dfs(int v, int t, cap_t f) {\n            if(v == t) return f;\n            used[v] = true;\n            for(size_t i : adj[v]) {\n                edge_t &e = edge[i];\n                if(!used[e.to] && e.cap > 0) {\n                    cap_t d = dfs(e.to,t,min(f,e.cap));\n                    if(d > 0) {\n                        e.cap -= d;\n                        edge[e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        cap_t max_flow(int s, int t) {\n            cap_t flow = 0,f;\n            while(true) {\n                fill(begin(used),end(used),false);\n                if((f = dfs(s,t,numeric_limits<cap_t>::max())) > 0) flow += f;\n                else break;\n            }\n            return flow;\n        }\n    };\n\n    cap_t Fold_Fulkerson(int s, int t) { return Fold_Fulkerson_exe(*this).max_flow(s,t); }\n    \n    struct Dinic_exe {\n        vector<edge_t> &edge;\n        vector<vector<size_t>> &adj;\n        vector<int> level,itr;\n\n        Dinic_exe(Flow &_F) : edge(_F.edge), adj(_F.adj)\n        {\n            level.resize(_F.V), itr.resize(_F.V);\n        }\n\n        void bfs(int s) {\n            fill(begin(level),end(level),-1);\n            queue<int> que;\n            level[s] = 0;\n            que.emplace(s);\n            while(!que.empty()) {\n                int v = que.front(); que.pop();\n                for(size_t i : adj[v]) {\n                    edge_t &e = edge[i];\n                    if(e.cap > 0 && level[e.to] < 0) {\n                        level[e.to] = level[v] + 1;\n                        que.emplace(e.to);\n                    }\n                } \n            }\n        }\n\n        cap_t dfs(int v, int t, cap_t f) {\n            if(v == t) return f;\n            for(int &i = itr[v]; i < (int)adj[v].size(); ++i) {\n                edge_t &e = edge[adj[v][i]];\n                if(e.cap > 0 && level[v] < level[e.to]) {\n                    cap_t d = dfs(e.to, t, min(f,e.cap));\n                    if(d > 0) {\n                        e.cap -= d;\n                        edge[e.rev].cap += d;\n                        return d;\n                    }\n                }\n            }\n            return 0;\n        }\n\n        cap_t max_flow(int s, int t) {\n            cap_t flow = 0, f;\n            while(bfs(s), level[t] >= 0) {\n                fill(begin(itr), end(itr), 0);\n                while((f = dfs(s, t, numeric_limits<cap_t>::max())) > 0) flow += f;\n            }\n            return flow;\n        }\n    };\n\n    cap_t Dinic(int s, int t) { return Dinic_exe(*this).max_flow(s, t); }\n\n    struct Primal_Dual_exe {\n        vector<edge_t> &edge;\n        vector<vector<size_t>> &adj;\n        vector<cost_t> dist, h;\n        vector<int> prev_v;\n        vector<edge_t*> prev_e;\n        size_t V;\n\n        Primal_Dual_exe(Flow &_F) : edge(_F.edge), adj(_F.adj), V(_F.V)\n        {\n            dist.resize(_F.V), h.resize(_F.V), prev_v.resize(_F.V), prev_e.resize(_F.V);\n        }\n\n        bool Dijkstra(int s, int t) {\n            priority_queue<pair<cost_t,int>,vector<pair<cost_t,int>>,greater<pair<cost_t,int>>> que;\n            fill(begin(dist), end(dist), inf<cost_t>);\n            que.emplace(dist[s] = 0, s);\n            while(!que.empty()) {\n                cost_t _cost; int v;\n                tie(_cost, v) = que.top();\n                que.pop();\n                if(_cost != dist[v]) continue;\n                for(size_t i : adj[v]) {\n                    edge_t &e = edge[i];\n                    if(e.cap > 0 && dist[v] + h[v] + e.cost < dist[e.to] + h[e.to]) {\n                        que.emplace(dist[e.to] = dist[v] + h[v] - h[e.to] + e.cost, e.to);\n                        prev_v[e.to] = v;\n                        prev_e[e.to] = &e;\n                    }\n                }\n            } \n            if(dist[t] >= inf<cost_t>) return false;\n            for(size_t v = 0; v < V; ++v) {\n                h[v] += dist[v];\n                if(h[v] > inf<cost_t>) h[v] = inf<cost_t>;\n            }\n            return true;\n        }\n\n        cost_t min_cost_flow(int s, int t, cap_t f) {\n            cost_t res = 0;\n            fill(begin(h), end(h), 0);\n            while(f > 0) {\n                if(!Dijkstra(s,t)) return inf<cost_t>;\n                cap_t d = f;\n                for(int v = t; v != s; v = prev_v[v]) d = min(d, prev_e[v]->cap);\n                f -= d;\n                res += d * h[t];\n                for(int v = t; v != s; v = prev_v[v]) {\n                    prev_e[v]->cap -= d;\n                    edge[prev_e[v]->rev].cap += d;\n                }\n            }\n            return res;\n        }\n    };\n\n    cost_t Primal_Dual(int s, int t, cap_t f) {\n        cost_t corr = 0;\n        if(neg_edge_exi) {\n            int _s = V++;\n            int _t = V++;\n            add_edge(_s, s, 0, f);\n            add_edge(t, _t, 0, f);\n            s = _s, t = _t;\n            for(edge_t &e : edge) {\n                if(e.cost <  0) {\n                    f += e.cap;\n                    add_edge(s, e.to, 0, e.cap);\n                    add_edge(e.from, t, 0, e.cap);\n                    corr += e.cap * e.cost;\n                    edge[e.rev].cap += e.cap;\n                    e.cap = 0;\n                }\n            }\n            neg_edge_exi = false;\n        }\n        return Primal_Dual_exe(*this).min_cost_flow(s, t, f) + corr;\n    } \n};\n\nsigned main()\n{\n    void solve();\n    void input();\n    void init();\n\n    int t = 1;\n\n    #ifdef LOCAL\n        t = 1;\n        // cin >> t;\n    #endif\n\n    // cin >> t;\n\n    while(t--)\n    {\n        init();\n        input();\n        solve();\n    }\n}\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n  struct edge {\n    int to;\n    flow_t cap;\n    cost_t cost;\n    int rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< int > prevv, preve;\n\n  PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(int from, int to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n  }\n\n  cost_t min_cost_flow(int s, int t, flow_t f) {\n    int V = (int) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, int >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      for(auto &e : graph[i]) {\n        if(e.isrev) continue;\n        auto &rev_e = graph[e.to][e.rev];\n        cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n      }\n    }\n  }\n};\n\nint n,h,w;\ni64 a[1<<17];\n\nvoid init()\n{}\n\nvoid input()\n{\n    cin>>n>>h>>w;\n    \n}\n\nvoid solve()\n{\n    // Flow<i64,int> flow(w+h+2+n);\n    PrimalDual<int,i64> flow(w+h+2+n);\n    const int s=h+w+n;\n    const int t=s+1;\n\n    for(int i=0; i<h; i++)\n    {\n        flow.add_edge(s,i,1,0);\n    }\n\n    for(int i=0; i<w; i++)\n    {\n        flow.add_edge(s,i+h,1,0);\n    }\n\n    for(int i=0; i<n; i++)\n    {\n        int r,c,a;\n        cin>>r>>c>>a;\n        r--,c--;\n        flow.add_edge(h+w+i,t,1,-a);\n        flow.add_edge(r,h+w+i,1,0);\n        flow.add_edge(h+c,h+w+i,1,0);\n    }\n\n    flow.add_edge(s,t,h+w,0);\n\n    cout << -flow.min_cost_flow(s,t,h+w) << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#define N 2000010\n\nint n, h, w;\n\nstruct node {\n    int r, c, a;\n\n    node() {}\n\n    node(int r, int c, int a) : r(r), c(c), a(a) {}\n\n    void input() {\n        scanf(\"%d %d %d\", &r, &c, &a);\n    }\n\n    bool operator<(const node &other) const {\n        return a > other.a;\n    }\n} a[N];\n\nint fa[N], sze[N], cnt[N];\n\nvoid Init() {\n    for (int i = 1; i <= h + w; ++i) {\n        fa[i] = i, sze[i] = 1, cnt[i] = 0;\n    }\n}\n\nint find(int x) {\n    return x == fa[x] ? fa[x] : fa[x] = find(fa[x]);\n}\n\nvoid merge(int x, int y) {\n    x = find(x), y = find(y);\n    if (x != y) {\n        if (sze[x] > sze[y]) swap(x, y);\n        fa[y] = x;\n        sze[x] += sze[y];\n    }\n}\n\nint main() {\n#ifdef LOCAL_JUDGE\n    freopen(\"input.txt\", \"r\", stdin);\n#endif\n    while (scanf(\"%d %d %d\", &n, &h, &w) != EOF) {\n        Init();\n        for (int i = 1; i <= n; ++i) {\n            a[i].input();\n        }\n        sort(a + 1, a + 1 + n);\n        ll res = 0;\n        for (int i = 1; i <= n; ++i) {\n            int r1 = find(a[i].r);\n            int r2 = find(h + a[i].c);\n            if (r1 == r2) {\n                if (sze[r1] > cnt[r1]) {\n                    res += a[i].a;\n                    cnt[r1]++;\n                }\n            } else {\n                if (sze[r1] + sze[r2] > cnt[r1] + cnt[r2]) {\n                    merge(r1, r2);\n                    res += a[i].a;\n                    cnt[find(r1)] = cnt[r1] + cnt[r2] + 1;\n                }\n            }\n        }\n        printf(\"%lld\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 3e5+100;\ntypedef long long ll;\n#define fr(i,low,up,st) for(register int i = (int)low;i <= (int)up;i += st)\n#define nfr(i,low,up,st) for(register int i = (int)low;i >= (int)up;i -= st)\n#define clr(a) memset(a,0,sizeof a)\n\nint n,m,h,w;\n\nstruct edge{\n   int r,c,a;\n   bool operator < (const edge &b) const {\n      return a > b.a;\n   }\n}e[N];\n\nint f[N];\nint cntp[N],cnte[N];\n\nvoid init(){\n   fr(i,1,h+w,1)f[i] = i,cntp[i] = 1;\n   clr(cnte);\n}\n\nint find(int x){\n   return (x == f[x])?x:f[x] = find(f[x]);\n}\n\nint main(){\n   scanf(\"%d%d%d\",&n,&h,&w);\n   fr(i,1,n,1){\n      scanf(\"%d%d%d\",&e[i].r,&e[i].c,&e[i].a);\n      e[i].c += h;\n   }\n   sort(e+1,e+n+1);\n   ll ans = 0;\n   init();\n   fr(i,1,n,1){\n      int h1 = find(e[i].r),h2 = find(e[i].c);\n      if(h1 == h2){\n         if(cntp[h1] == cnte[h1])continue ;\n         cnte[h1]++;\n         ans += e[i].a;\n      }\n      else {\n         if(cntp[h1]+cntp[h2] < cnte[h1]+cnte[h2]+1)continue ;\n         else {\n            f[h1] = h2;\n            cntp[h2] += cntp[h1]; cntp[h1] = 0;\n            cnte[h2] += cnte[h1]+1; cnte[h1] = 0;\n            ans += e[i].a;\n         }\n      }\n   }\n   printf(\"%lld\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\npair<int,pair<int,int> > c[100005];\nbool tree[200005];\nint par[200005];\nint find(int x)\n{\n\tif (par[x]!=x)\n\tpar[x]=find(par[x]);\n\treturn par[x];\n}\nvoid Union(int x,int y)\n{\n\tx=find(x);\n\ty=find(y);\n\tif (x==y)\n\ttree[x]=0;\n\telse\n\t{\n\t\tpar[x]=y;\n\t\ttree[y]&=tree[x];\n\t}\n}\nint main()\n{\n\tint n,h,w;\n\tscanf(\"%d%d%d\",&n,&h,&w);\n\tfor (int i=0;i<n;i++)\n\tscanf(\"%d%d%d\",&c[i].second.first,&c[i].second.second,&c[i].first);\n\tsort(c,c+n);\n\treverse(c,c+n);\n\tfor (int i=1;i<=h+w;i++)\n\t{\n\t\tpar[i]=i;\n\t\ttree[i]=1;\n\t}\n\tlong long ans=0;\n\tfor (int i=0;i<n;i++)\n\t{\n\t\tint c1=find(c[i].second.first),c2=find(c[i].second.second+h);\n\t\tif (tree[c1] || tree[c2])\n\t\t{\n\t\t\tans+=c[i].first;\n\t\t\tUnion(c1,c2);\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define owo(i,a, b) for(int i=(a);i<(b); ++i)\n#define uwu(i,a, b) for(int i=(a)-1; i>=(b); --i)\n#define senpai push_back\n#define ttgl pair<int, int>\n#define ayaya cout<<\"ayaya~\"<<endl\n \nusing namespace std;\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\ngp_hash_table<int, gp_hash_table<int, int>> mp;\nusing ll = long long;\nusing ld = long double;\nconst ll MOD = 1000000000;\nconst ll root = 62;\nint gcd(int a,int b){return b?gcd(b,a%b):a;}\nll binpow(ll a,ll b){ll res=1;while(b){if(b&1)res=(res*a)%MOD;a=(a*a)%MOD;b>>=1;}return res;}\nll modInv(ll a){return binpow(a, MOD-2);}\nconst double PI = acos(-1);\nconst double eps = -1e6;\nconst int INF = 0x3f3f3f3f;\nconst int NINF = 0xc0c0c0c0;\nconst ll INFLL = 0x3f3f3f3f3f3f3f3f;\nconst ll NINFLL = 0xc0c0c0c0c0c0c0c0;\nconst int mxN = 100001;\nint h, w;\nint n;\npair<int, ttgl> arr[mxN];\nint dsu[mxN];\nint sz[mxN];\nint esz[mxN];\nll ans = 0;\nint find(int a) {\n    return a==dsu[a] ? a : dsu[a] = find(dsu[a]);\n}\nvoid merge(int a, int b, int val) {\n    a = find(a);\n    b = find(b);\n    if(a==b) {\n        if(esz[a]<sz[a]) {\n            esz[a]++;\n            ans+=val;\n        }\n    }else {\n        if(esz[a]+esz[b]<sz[b]+sz[a]) {\n            dsu[b] = a;\n            sz[a]+=sz[b];\n            esz[a]+=esz[b];\n            esz[a]++;\n            ans+=val;\n        }\n    }\n}\nint main() {\n    //freopen(\"file.in\", \"r\", stdin);\n    //freopen(\"file.out\", \"w\", stdout);\n    mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n    cin.tie(0)->sync_with_stdio(0);\n    cin>>n>>h>>w;\n    owo(i, 0, n){\n        sz[i] = 1;\n        esz[i] = 0;\n        dsu[i] = i;\n    }\n    owo(i, 0, n) {\n        cin>>arr[i].second.first>>arr[i].second.second>>arr[i].first;\n        arr[i].second.first--;\n        arr[i].second.second+=h-1;\n    }\n    sort(arr, arr+n);\n    reverse(arr, arr+n);\n    owo(i, 0, n) {\n        merge(arr[i].second.second, arr[i].second.first, arr[i].first);\n    }\n    cout<<ans<<\"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nnamespace io{\n\tconst int l=1<<20;\n\tchar buf[l],*s,*t;\n\tinline char gc(){\n\t\tif(s==t){\n\t\t\tt=(s=buf)+fread(buf,1,l,stdin);\n\t\t\treturn s==t?EOF:*s++;\n\t\t}\n\t\treturn *s++;\n\t}\n\tchar c;\n\ttemplate<class IT>inline void gi(IT &x){\n\t\tx=0;c=gc();while(c<'0'||c>'9')c=gc();\n\t\twhile('0'<=c&&c<='9'){x=(x<<1)+(x<<3)+(c^'0');c=gc();}\n\t}\n};\nusing io::gi;\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\nconst ll p=998244353ll,inf=1000000000000000000ll;\nconst int N=200005,E=1000005;\nstruct qwq{\n\tint a,b,c;\n\tinline bool operator<(const qwq &x)const{\n\t\treturn c>x.c;\n\t}\n}x[N];\nint g[N],f[N];\nint find(int v){return f[v]?f[v]=find(f[v]):v;}\nint main(){\n\tint t,n,m,a,b,c,i;ll s=0ll;\n\tscanf(\"%d%d%d\",&t,&n,&m);\n\tfor(i=1;i<=t;++i){scanf(\"%d%d%d\",&x[i].a,&x[i].b,&x[i].c);x[i].b+=n;}n+=m;\n\tsort(x+1,x+t+1);\n\tfor(i=1;i<=n;++i)g[i]=1;\n\tfor(i=1;i<=t;++i){\n//\t\tprintf(\"%d %d %d\\n\",x[i].a,x[i].b,x[i].c);\n\t\ta=find(x[i].a);\n\t\tb=find(x[i].b);\n//\t\tprintf(\"a=%d b=%d g[a]=%d g[b]=%d\\n\",a,b,g[a],g[b]);\n\t\tif(g[a]||g[b]){\n\t\t\tif(a==b)g[a]=0;\n\t\t\telse{\n\t\t\t\tg[b]&=g[a];\n\t\t\t\tf[a]=b;\n\t\t\t}\n\t\t\ts+=x[i].c;\n\t\t}\n\t}\n\tprintf(\"%lld\",s);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\ntypedef long long ll;\n#define inf 0x3f3f3f3f\nint n,h,w;\nint x[maxn],y[maxn];\nll a[maxn];\nset<pair<ll,int> > qx[maxn],qy[maxn];\nvector<pair<ll,int> >cards;\nll ax,ay;\nbool ux[maxn],uy[maxn],usd[maxn];\nint cx[maxn],cy[maxn];\nqueue<int> que;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&h,&w);\n//\tmemset(cx,-1,sizeof(cx));\n//\tmemset(cy,-1,sizeof(cy));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%lld\",&x[i],&y[i],&a[i]);\n\t\tx[i]--;\n\t\ty[i]--;\n\t\tcx[x[i]]++;\n\t\tcy[y[i]]++;\n\t}\n    ll ans=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tqx[x[i]].insert(make_pair(a[i],i));\n\t\tqy[y[i]].insert(make_pair(a[i],i));\n\t}\n\tfor(int i=0;i<n;i++)if(!usd[i])\n\t\tcards.push_back(make_pair(a[i],i));\n\n    sort(cards.begin(),cards.end());\n    reverse(cards.begin(),cards.end());\n\trandom_shuffle(cards.begin() + n / 2, cards.end());\n    for(int _=0;_<cards.size();_++)\n    {\n    \tint i=cards[_].second;\n\t//\tcout<<i<<\" \"<<x[i]<<\" \"<<y[i]<<\" \"<<qx[x[i]].top().second<<\" \"<<qy[y[i]].top().second<<endl;\n        qx[x[i]].erase(make_pair(a[i],i));\n        qy[y[i]].erase(make_pair(a[i],i));\n        if(ux[x[i]]&&uy[y[i]])continue;\n        if(ux[x[i]])\n        \tuy[y[i]]=1;\n        else if(uy[y[i]])\n        \tux[x[i]]=1;\n        else\n\t\t{\n\t\t\tax=qx[x[i]].empty()?-inf:(*(qx[x[i]].rbegin())).first;\n\t\t\tay=qy[y[i]].empty()?-inf:(*(qy[y[i]].rbegin())).first;\n\t\t\tif(ax<ay)\n\t\t\t{\n        //   \tcout<<\"puthang \"<<x[i]<<endl;\n            \tux[x[i]]=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n      \t//    \tcout<<\"putlie \"<<y[i]<<endl;\n \t    \t\tuy[y[i]]=1;\n \t    \t}\n        }\n        ans+=a[i];\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> P;\ntemplate<int N>\nstruct MinCostFlow\n{\n\tMinCostFlow()\n\t{\n\t\tesize=0;\n\t}\n\tvoid add(int s,int e,int se,int c)\n\t{\n\t\t//cout << s << \", \" << e << \", \" << se << \", \" << c << endl;\n\t\tedges.push_back(Edge());\n\t\tedges[esize].s=s;\n\t\tedges[esize].e=e;\n\t\tedges[esize].se=se;\n\t\tedges[esize].es=0;\n\t\tedges[esize].c=c;\n\t\tvtx[s].push_back(esize);\n\t\tvtx[e].push_back(esize);\n\t\tesize++;\n\t}\n\tint start;\n\tint goal;\n\tP fill(int K)\n\t{\n\t\tmemset(inQ,0,sizeof(inQ));\n\t\tmemset(pre,0,sizeof(pre));\n\t\tqueue<int> q;\n\t\tLL ret=0;\n\t\tint path;\n\t\tfor(path=0;path<K;path++){\n\t\t\tmemset(dist,-1,sizeof(dist));\n\t\t\tdist[start]=0;\n\t\t\tq.push(start);\n\t\t\tinQ[start]=true;\n\t\t\twhile(q.size()){\n\t\t\t\tint top=q.front();\n\t\t\t\tinQ[top]=false;\n\t\t\t\tq.pop();\n\t\t\t\t//cout << top << \", \";\n\t\t\t\tint d=dist[top];\n\t\t\t\tfor(int i=0;i<vtx[top].size();i++){\n\t\t\t\t\tint ei=vtx[top][i];\n\t\t\t\t\tEdge& ed=edges[ei];\n\t\t\t\t\tint nex=-1,nd;\n\t\t\t\t\tif(ed.s==top&&ed.se){\n\t\t\t\t\t\tnex=ed.e;\n\t\t\t\t\t\tnd=d+ed.c;\n\t\t\t\t\t}\n\t\t\t\t\telse if (ed.e==top&&ed.es)\n\t\t\t\t\t{\n\t\t\t\t\t\tnex=ed.s;\n\t\t\t\t\t\tnd=d-ed.c;\n\t\t\t\t\t}\n\t\t\t\t\tif(nex>=0&&(dist[nex]==-1||nd<dist[nex])){\n\t\t\t\t\t\tpre[nex]=ei;\n\t\t\t\t\t\tdist[nex]=nd;\n\t\t\t\t\t\tif(!inQ[nex]){\n\t\t\t\t\t\t\tinQ[nex]=true;\n\t\t\t\t\t\t\tq.push(nex);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//cout << dist[goal] << endl;\n\t\t\tif(dist[goal]>=0){\n\t\t\t\tret+=dist[goal];\n\t\t\t\tint p=goal;\n\t\t\t\twhile(p!=start){\n\t\t\t\t\tint ei=pre[p];\n\t\t\t\t\tEdge& ed=edges[ei];\n\t\t\t\t\tif(ed.e==p){\n\t\t\t\t\t\tp=ed.s;\n\t\t\t\t\t\ted.se--;\n\t\t\t\t\t\ted.es++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tp=ed.e;\n\t\t\t\t\t\ted.se++;\n\t\t\t\t\t\ted.es--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\treturn P(ret,path);\n\t}\n\tprivate:\n\tstruct Edge\n\t{\n\t\tint s;\n\t\tint\te;\n\t\tint se;\n\t\tint es;\n\t\tint c;\n\t};\n\tvector<Edge> edges;\n\n\tvector<int> vtx[N];\n\tint esize;\n\tbool inQ[N];\n\tint pre[N];\n\tint dist[N];\n};\n\nconst int L=1e5;\nMinCostFlow<3*L+2> f;\nvoid solve(long long N, long long H, long long W, std::vector<long long> R, std::vector<long long> C, std::vector<long long> A){\n\tint s=H+W+A.size();\n\tint t=s+1;\n\tfor(int i=0;i<H;i++){\n\t\tf.add(s,i,1,0);\n\t}\n\tfor(int i=0;i<W;i++){\n\t\tf.add(s,H+i,1,0);\n\t}\n\tfor(int i=0;i<A.size();i++){\n\t\tf.add(R[i],H+W+i,1,0);\n\t\tf.add(H+C[i],H+W+i,1,0);\n\t\tf.add(H+W+i,t,1,L-A[i]);\n\t}\n\tf.start=s;\n\tf.goal=t;\n\tauto r=f.fill(H+W);\n\t//cerr << r.first << \", \" << r.second << endl;\n\tcout << r.second*L-r.first << endl;\n\n\n}\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long H;\n    scanf(\"%lld\",&H);\n    long long W;\n    scanf(\"%lld\",&W);\n    std::vector<long long> R(N);\n    std::vector<long long> C(N);\n    std::vector<long long> A(N);\n    for(int i = 0 ; i < N ; i++){\n        scanf(\"%lld\",&R[i]);\n\t\tR[i]--;\n        scanf(\"%lld\",&C[i]);\n\t\tC[i]--;\n        scanf(\"%lld\",&A[i]);\n    }\n    solve(N, H, W, std::move(R), std::move(C), std::move(A));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=2e5+5;\nint n,H,W,i,g[N];\nbool b[N];\nlong long ans;\nint gfa(int x){\n\treturn g[x]==x?x:g[x]=gfa(g[x]);\n}\nstruct edge{\n\tint r,c,a;\n\tinline void in(){\n\t\tscanf(\"%d%d%d\",&r,&c,&a);\n\t}\n\tinline bool operator<(const edge&rhs)const{return a>rhs.a;}\n\tinline void tryuni(){\n\t\tr=gfa(r);c=gfa(H+c);\n\t\tif(r!=c){\n\t\t\tif(!b[r] || !b[c])ans+=a,g[r]=c,b[c]|=b[r];\n\t\t}else if(!b[r])\n\t\t//\tprintf(\"%d\\n\",a),\n\t\t\tans+=a,b[r]=1;\n\t}\n}e[N];\nint main(){\n\tscanf(\"%d%d%d\",&n,&H,&W);\n\tfor(i=1;i<=H+W;++i)g[i]=i;\n\tfor(i=1;i<=n;++i)e[i].in();\n\tsort(e+1,e+n+1);\n\tfor(i=1;i<=n;++i)e[i].tryuni();\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#define llint long long\n#define mod 1000000007\n\nusing namespace std;\ntypedef pair<llint, llint> P;\ntypedef pair<llint, P> E;\n\nllint n, h, w;\nvector<E> vec;\nllint deg[200005];\nllint a[100005];\n\nint main(void)\n{\n\tcin >> n >> h >> w;\n\tllint r, c, a;\n\tfor(int i = 1; i <= n; i++){\n\t\tcin >> r >> c >> a;\n\t\tvec.push_back(make_pair(a, make_pair(r, c)));\n\t}\n\tsort(vec.rbegin(), vec.rend());\n\t\n\tllint ans = 0;\n\tfor(int i = 0; i < vec.size(); i++){\n\t\tllint u = vec[i].second.first, v = vec[i].second.second + 100000;\n\t\tif(deg[u] >= 2 && deg[v] >= 2) continue;\n\t\tif(deg[u] < 2) deg[u]++;\n\t\telse deg[v]++;\n\t\tans += vec[i].first;\n\t\t//cout << u << \" \" << v << \" \" << ans << endl;\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <random>\n\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nusing Flow = int;\nusing Cost = long;\nconst int MAX_V = 100000;\nconst Cost INF = std::numeric_limits<Cost>::max() / 8;\n\nstruct PrimalDual {\n    struct Edge {\n        int d;\n        Flow c, f;\n        Cost w;\n        int r, is_r;\n        Edge(int d_, Flow c_, Flow f_, Cost w_, int r_, bool is_r_)\n            : d(d_), c(c_), f(f_), w(w_), r(r_), is_r(is_r_) {}\n    };\n\n    int n;\n    std::vector<std::vector<Edge> > g;\n    PrimalDual(int n_) : n(n_), g(std::vector<std::vector<Edge> >(n_)) {}\n\n    void add_edge(int src, int dst, Flow cap, Cost cost) {  // 有向辺\n        int rsrc = g[dst].size();\n        int rdst = g[src].size();\n        g[src].emplace_back(dst, cap, 0, cost, rsrc, false);\n        g[dst].emplace_back(src, cap, cap, -cost, rdst, true);\n    }\n\n    Cost solve(int s, int t, Flow f) {\n        Cost res = 0;\n\n        static Cost h[MAX_V + 10], dist[MAX_V];\n        static int prevv[MAX_V + 10], preve[MAX_V + 10];\n        // std::vector<Cost> h(g.size()), dist(g.size());\n        // std::vector<int> prevv(g.size()), preve(g.size());\n\n        using pcv = std::pair<Cost, int>;\n        std::priority_queue<pcv, std::vector<pcv>, std::greater<pcv> > q;\n        std::fill(h, h + n, 0);\n        while (f > 0) {\n            std::fill(dist, dist + n, INF);\n            dist[s] = 0;\n            q.emplace(0, s);\n            while (q.size()) {\n                Cost cd;\n                int v;\n                std::tie(cd, v) = q.top();\n                q.pop();\n                if (dist[v] < cd) continue;\n                for (int i = 0; i < (int)(g[v].size()); ++i) {\n                    Edge &e = g[v][i];\n                    if (residue(e) == 0) continue;\n                    if (dist[e.d] + h[e.d] > cd + h[v] + e.w) {\n                        dist[e.d] = dist[v] + e.w + h[v] - h[e.d];\n                        prevv[e.d] = v;\n                        preve[e.d] = i;\n                        q.emplace(dist[e.d], e.d);\n                    }\n                }\n            }\n\n            if (dist[t] == INF) return -1;  // 経路が見つからなかった\n\n            // s-t 間最短路に沿って目一杯流す\n            for (int i = 0; i < n; ++i) h[i] += dist[i];\n            Flow d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = std::min(d, residue(g[prevv[v]][preve[v]]));\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.f += d;\n                g[v][e.r].f -= d;\n            }\n        }\n        return res;\n    }\n\n    Flow residue(const Edge &e) { return e.c - e.f; }\n\n    // 流量を表示\n    void show() {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < (int)(g[i].size()); ++j) {\n                Edge &e = g[i][j];\n                if (e.is_r) continue;\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.d, e.f);\n            }\n        }\n    }\n};\nvoid Calc(){\n\tint N = rei();\n\tint H = rei();\n\tint W = rei();\n\tPrimalDual PD(N+H+W+2);\n\tint S = N+H+W;\n\tint G = N+H+W+1;\n\tlong ans = 0;\n\tfor(int i=0;i<H+W;i++){\n\t\tPD.add_edge(S,i,1,0);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tint h = rei()-1;\n\t\tint w = rei()-1;\n\t\tint a = rei();\n\t\tPD.add_edge(h,i+H+W,1,100000-a);\n\t\tPD.add_edge(H+w,i+H+W,1,100000-a);\n\t\tPD.add_edge(h,G,1,100000);\n\t\tPD.add_edge(H+w,G,1,100000);\n\t\tPD.add_edge(i+H+W,G,1,0);\n\t}\n\tans += 1LL*100000*(H+W) - PD.solve(S,G,H+W);\n\tcout << ans << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\n#include<vector>\n#include<numeric>\n\nnamespace ProconLib{\n    class UnionFind{\n        int N;\n        std::vector<int> par;\n        std::vector<int> rank;\n        public:\n        UnionFind(int N):N(N),par(N),rank(N,0){std::iota(par.begin(),par.end(),0);}\n        int find(int x);\n        void unite(int x,int y);\n        bool same(int x,int y){return find(x)==find(y);}\n    };\n\n    int UnionFind::find(int x){\n        if(par[x]==x) return x;\n        return par[x]=find(par[x]);\n    }\n    void UnionFind::unite(int x,int y){\n        x=find(x),y=find(y);\n        if(x==y) return;\n        if(rank[x]>=rank[y]){\n            if(rank[x]==rank[y]) rank[x]++;\n            par[y]=x;\n        }else{\n            par[x]=y;\n        }\n    }\n}using namespace std;\nusing namespace ProconLib;\nusing ll=long long;\n\nstruct Card{\n    int r,c;\n    ll a;\n    int id;\n};\n\nstruct Edge{\n    int to;\n    ll w;\n};\nusing Graph=vector<vector<Edge>>;\nGraph g;\nvector<int> used;\nvoid dfs(int v){\n    used[v]=true;\n    for(auto to:g[v]){\n        if(!used[to.to]) dfs(to.to);\n    }\n}\nint main(){\n    int n,h,w;\n    cin>>n>>h>>w;\n    vector<Card> cards(n);\n    for(int i=0;i<n;i++){\n        cin>>cards[i].r>>cards[i].c>>cards[i].a;\n        cards[i].r--;\n        cards[i].c--;\n        cards[i].id=i;\n    }\n    sort(cards.begin(),cards.end(),[](Card lhs,Card rhs){return lhs.a>rhs.a;});\n    vector<int> flag(n);\n\n    g.resize(h+w);\n    used.resize(h+w);\n    UnionFind u(h+w);\n    \n    ll res=0;\n    for(auto &card:cards){\n        int x=card.r;\n        int y=card.c+h;\n        if(u.same(x,y)){\n            if(used[x]+used[y]==0){\n                res+=card.a;\n                g[x].push_back(Edge{y,card.a});\n                g[y].push_back(Edge{x,card.a});\n                dfs(x);\n            }\n            else{\n                assert(used[x]==used[y]);\n                continue;\n            }\n        }\n        if(used[x] && used[y]){\n            continue;\n        }\n        else if(used[x]||used[y]){\n            g[x].push_back(Edge{y,card.a});\n            g[y].push_back(Edge{x,card.a});\n            used[x]=used[y]=true;\n            u.unite(x,y);\n            res+=card.a;\n        }\n        else{\n            u.unite(x,y);\n            g[x].push_back(Edge{y,card.a});\n            g[y].push_back(Edge{x,card.a});\n            res+=card.a;\n        }\n    }\n    cout<<res<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=1e5+5;\nint n,h,w;\nstruct Point\n{\n\tint r,c;\n\tll a;\n}a[N];\nbool cmp(Point a,Point b)\n{\n\treturn a.a>b.a;\n}\nint fa[N*2],sum[N*2];\nint find(int x)\n{\n\tif(fa[x]!=x)\n\tfa[x]=find(fa[x]);\n\treturn fa[x];\n}\nll ans=0;\nint main()\n{\n\tcin>>n>>h>>w;\n\tfor(int i=1;i<=h+w;++i)\n\t{\n\t\tfa[i]=i;\n\t\tsum[i]=1;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d%lld\",&a[i].r,&a[i].c,&a[i].a);\n\t\ta[i].c+=h;\n\t}\n\tsort(a+1,a+1+n,cmp);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint fr=find(a[i].r),fc=find(a[i].c);\n\t\tif(fr!=fc)\n\t\t{\n\t\t\tfa[fr]=fc;\n\t\t\tsum[fc]+=sum[fr];\n\t\t\tsum[fr]=0;\n\t\t}\n\t\tif(sum[fc]>0)\n\t\t{\n\t\t\tans+=a[i].a;\n\t\t\tsum[fc]--;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define all(v) (v).begin(), (v).end()\n#define sortv(v) sort(all(v))\n#define uniqv(v) (v).erase(unique(all(v)), (v).end())\n#define pb push_back\n#define FI first\n#define SE second\n#define lb lower_bound\n#define ub upper_bound\n#define mp make_pair\n#define test 1\n#define TEST if(test)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\nconst int MOD = 1000000007; // 998244353\nconst int INF = 2e9;\nconst ll INFLL = 1e18;\nconst int MAX_N = 100000;\n\nint N, H, W;\n\nint X[MAX_N+1], Y[MAX_N+1];\n\nstruct S{\n\tint x, y, d;\n\tbool operator <(const S &a)const{\n\t\treturn d<a.d;\n\t}\n};\nvector<S> v;\n\nll ans;\n\nint g[MAX_N*2+1];\nint c[MAX_N*2+1];\n\nvoid init_g(){\n\tfor(int i=1; i<=H+W; i++){\n\t\tg[i] = i;\n\t\tc[i] = 1;\n\t}\n}\n\nint find_g(int x){\n\treturn (x==g[x])?x:g[x] = find_g(g[x]);\n}\n\nvoid union_g(int x, int y){\n\tx = find_g(x); y = find_g(y);\n\tg[x] = y;\n\tif(c[x]==0 || c[y]==0){\n\t\tc[y] = 0;\n\t}\n}\n\nint main(){\n\tcin>>N>>H>>W;\n\tinit_g();\n\tfor(int i=1; i<=N; i++){\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tv.pb((S){a, b+H, c});\n\t}\n\tsort(v.begin(), v.end());\n\twhile(!v.empty()){\n\t\tS now = v.back(); v.pop_back();\n\t\tif(find_g(now.x)==find_g(now.y)){\n\t\t\tif(c[find_g(now.x)]==1 && c[find_g(now.y)]==1){\n\t\t\t\tans+=(ll)now.d;\n\t\t\t\tc[find_g(now.x)]=c[find_g(now.y)]=0;\n\t\t\t}\n\t\t}\n\t\tunion_g(now.x, now.y);\n\t\tans+=(ll)now.d;\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\nstruct UnionFind{\n   vector<int> par;\n   vector<int> cnt;\n   UnionFind(int n):par(n,-1),cnt(n){}\n   int find(int x){\n       if(par[x]<0)return x;\n       return par[x]=find(par[x]);\n   }\n   bool unite(int x,int y){\n       x=find(x);\n       y=find(y);\n       bool ok = (-par[x]>cnt[x]||-par[y]>cnt[y]);\n       if(x==y){\n           cnt[x]++;\n       }\n       else if(par[x]>par[y]){\n           par[y]+=par[x];\n           par[x]=y;\n           cnt[y]+=cnt[x]+1;\n       }\n       else{\n           par[x]+=par[y];\n           par[y]=x;\n           cnt[x]+=cnt[y]+1;\n       }\n       return ok;\n   }\n\n   bool same(int x,int y){\n       return find(x)==find(y);\n   }\n   int size(int x){\n       return -par[find(x)];\n   }\n};\nint main(){\n    int n,h,w;\n    cin>>n>>h>>w;\n    ll a[n],b[n],c[n];\n    rep(i,n)cin>>a[i]>>b[i]>>c[i];\n    vector<int> ord(n);\n    rep(i,n)ord[i]=i;\n    sort(ord.begin(),ord.end(),[&](int x,int y){\n        return c[x]>c[y];\n    });\n    ll ans = 0;\n    UnionFind uf(h+w);\n    for(auto i : ord){\n        --a[i];--b[i];\n        if(uf.unite(a[i],b[i]+h))ans+=c[i];\n    }\n    cout<<ans<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int,int,int> T;\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define rep(i, n) for (ll i = 0; i < n; i++)\n#define rrep(i, n) for (ll i = n - 1; i >= 0; i--)\n#define Rep(i, r, n) for (ll i = r; i < n; i++)\n#define RRep(i, r, n) for (ll i = n - 1; i <= r; i--)\n#define debug(x) cout << #x << ' ' << '=' << ' ' << (x) << endl;\n#define fs first\n#define sc second\n#define int long long\n#define pb push_back\n#define mp make_pair\nconst int dx[] = {0, -1, 0, 1};\nconst int dy[] = {1, 0, -1, 0};\nconst int MOD = (1000000007);\n//const int MOD = (998244353);\n//const int INF = (1 << 30)-1;\nconst int INF = (1LL << 60)-1;\nconst double EPS = (1 >> 30);\n\ntemplate<class T> inline bool chmin(T& a, T b) {if (a > b) {a = b; return 1;} return 0;}\ntemplate<class T> inline bool chmax(T& a, T b) {if (a < b) {a = b; return 1;} return 0;}\n\nusing Graph = vector<vector<pair<int, int>>>;\nusing Ki = vector<vector<int>>;\nusing vec = vector<int>;\n\nstruct UnionFind {\n    public:\n    vector<int> child, tree, sum, ed;\n\n    public:\n    UnionFind(int v) {\n        tree.resize(v);\n        sum.resize(v);\n        ed.resize(v,0);\n        rep(i, v) tree[i] = i, sum[i] = 1;\n    }\n\n    int root(int i) {\n        if(i == tree[i]) {\n            rep(j, child.size()) tree[child[j]] = i;\n            child.clear(); \n            return i;\n        }\n        else {\n            child.push_back(i);\n            return i = root(tree[i]);\n        }\n    }\n\n    int size(int i) {\n        return sum[root(i)];\n    }\n\n    int edsize(int i) {\n        return ed[root(i)];\n    }\n\n    int unit(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if(isUnit(x,y)){\n            ed[min(x,y)] ++;\n            return 0;\n        }\n        sum[min(x,y)] += sum[max(x,y)];\n        ed[min(x,y)] += 1 + ed[max(x,y)];\n        tree[max(x,y)] = min(x,y);\n    }\n\n    bool isUnit(int x, int y) {\n        return root(x) == root(y);\n    }\n};\n\nint Nmax=100100;\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(10);\n    //---------------------------------------------\n    \n    int n,h,w;\n    cin>>n>>h>>w;\n    vector<T> x(n);\n    rep(i,n){\n        int r,c,a;\n        cin>>r>>c>>a; // a is score\n        x[i]=T(a,r,c);\n    }\n    sort(rall(x));\n    UnionFind uf1(h+w+Nmax);\n    UnionFind uf2(h+w+Nmax);\n    ll ans=0;\n    rep(i,n){\n        int a,r,c; // a is score\n        tie(a,r,c)=x[i];\n        if(uf1.isUnit(r,c+Nmax)&&uf2.isUnit(r,c+Nmax)){\n            // 取れない\n        }\n        else if(uf1.isUnit(r,c+Nmax)){\n            // 辺がある\n            if(uf1.edsize(r)<uf1.size(r)){\n                uf1.unit(r,c+Nmax);\n                uf2.unit(r,c+Nmax);\n                ans+=a;\n            }\n        }\n        else{\n            // 辺がない\n            if(uf1.edsize(r)+uf1.edsize(c+Nmax)<uf1.size(r)+uf1.size(c+Nmax)){\n                uf1.unit(r,c+Nmax);\n                ans+=a;\n            }\n        }\n    }\n    cout<<ans<<endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "//\n// Created by yamunaku on 2019/08/24.\n//\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repl(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perl(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD9 998244353\n#define MOD1 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n#define CST(x) cout<<fixed<<setprecision(x)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> mti;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> mtl;\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n    const cost_t INF;\n\n    struct edge {\n        int to;\n        flow_t cap;\n        cost_t cost;\n        int rev;\n        bool isrev;\n    };\n    vector< vector< edge > > graph;\n    vector< cost_t > potential, min_cost;\n    vector< int > prevv, preve;\n\n    PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n    void add_edge(int from, int to, flow_t cap, cost_t cost) {\n        graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n        graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n    }\n\n    cost_t min_cost_flow(int s, int t) {\n        int V = (int) graph.size();\n        cost_t ret = 0;\n        using Pi = pair< cost_t, int >;\n        priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n        potential.assign(V, 0);\n        preve.assign(V, -1);\n        prevv.assign(V, -1);\n        cost_t ans=0;\n        cost_t xxx=0;\n        while(1){\n            cost_t f=1;\n            min_cost.assign(V, INF);\n            que.emplace(0, s);\n            min_cost[s] = 0;\n            while(!que.empty()) {\n                Pi p = que.top();\n                que.pop();\n                if(min_cost[p.second] < p.first) continue;\n                for(int i = 0; i < graph[p.second].size(); i++) {\n                    edge &e = graph[p.second][i];\n                    cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n                    if(e.cap > 0 && min_cost[e.to] > nextCost) {\n                        min_cost[e.to] = nextCost;\n                        prevv[e.to] = p.second, preve[e.to] = i;\n                        que.emplace(min_cost[e.to], e.to);\n                    }\n                }\n            }\n            if(min_cost[t] == INF) return ans;\n            for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n            flow_t addflow = f;\n            for(int v = t; v != s; v = prevv[v]) {\n                addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n            }\n            f -= addflow;\n            ret += addflow * potential[t];\n            for(int v = t; v != s; v = prevv[v]) {\n                edge &e = graph[prevv[v]][preve[v]];\n                e.cap -= addflow;\n                graph[v][e.rev].cap += addflow;\n            }\n            xxx++;\n            ans=max(ans,IINF*xxx-ret);\n        }\n        return ans;\n    }\n\n    void output() {\n        for(int i = 0; i < graph.size(); i++) {\n            for(auto &e : graph[i]) {\n                if(e.isrev) continue;\n                auto &rev_e = graph[e.to][e.rev];\n                cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n            }\n        }\n    }\n};\n\nint main(){\n    int n,h,w;\n    cin >> n;\n    cin >> h >> w;\n    vi r(n),c(n),a(n);\n    map<int,int> rmp,cmp;\n    rep(i,n){\n        cin >> r[i] >> c[i] >> a[i];\n        rmp[r[i]]=0;\n        cmp[c[i]]=0;\n    }\n    int idx=0;\n    for(auto &p:rmp) p.second=idx++;\n    idx=0;\n    for(auto &p:cmp) p.second=idx++;\n    int rs=rmp.size(),cs=cmp.size();\n    int sz=rs+cs+n+2;\n    PrimalDual<int,ll> pd(sz);\n    rep(i,rs){\n        pd.add_edge(0,i+2,1,0);\n    }\n    rep(i,cs){\n        pd.add_edge(0,rs+i+2,1,0);\n    }\n    rep(i,n){\n        pd.add_edge(rmp[r[i]]+2,rs+cs+i+2,1,0);\n        pd.add_edge(rs+cmp[c[i]]+2,rs+cs+i+2,1,0);\n        pd.add_edge(rs+cs+i+2,1,1,IINF-a[i]);\n    }\n    cout << pd.min_cost_flow(0,1) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n  Id: hhw52818\n  Task: a\n  Lang: C++\n*/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define foru(i, l, r) for(register int i = l; i <= r; i++)\n#define ford(i, r, l) for(register int i = r; i >= l; i--)\n\ntypedef long long ll;\nconst int maxn = 1e5 + 5;\n\nint n, m, N;\nll ans;\n\n#define mk make_pair\n#define fir first\n#define sec second\n\nstruct Heap {\n  priority_queue<pair<int, int> > ins;\n  priority_queue<pair<int, int> > del;\n  void clear() {\n    while(!ins.empty()) ins.pop();\n    while(!del.empty()) del.pop();\n  }\n  void insert(pair<int, int> pii) { ins.push(pii); }\n  void erase(pair<int, int> pii) { del.push(pii); }\n  pair<int, int> top() { return ins.top(); }\n  bool empty() {\n    while(!ins.empty() && !del.empty())\n      if(ins.top() == del.top())\n        ins.pop(), del.pop();\n      else break;\n    return ins.empty();\n  }\n} a[maxn], b[maxn];\n\nint U[maxn], V[maxn], X[maxn];\nint Count[maxn];\n\nll solve() {\n  for(int i = 1; i <= n; i++) a[i].clear();\n  for(int i = 1; i <= m; i++) b[i].clear();\n  memset(Count, 0, sizeof(Count));\n  for(int i = 1; i <= N; i++) {\n    a[U[i]].insert(mk(X[i], V[i]));\n    b[V[i]].insert(mk(X[i], U[i]));\n    Count[V[i]]++;\n  }\n  ll res = 0;\n  for(int i = 1; i <= n; i++) {\n    if(!a[i].empty()) {\n      pair<int, int> now = a[i].top();\n      while(!a[i].empty()) {\n        if(Count[now.sec] > 1) break;\n        else a[i].erase(now);\n        if(!a[i].empty()) now = a[i].top();\n        else break;\n      }\n      if(Count[now.sec] > 1) {\n        Count[now.sec]--; res += (ll)now.fir;\n        b[now.sec].erase(mk(now.fir, i));\n      }\n    }\n  }\n  for(int i = 1; i <= m; i++) {\n    if(!b[i].empty()) {\n      pair<int, int> now = b[i].top();\n      res += (ll)now.fir;\n    }\n  }\n  return res;\n}\n\nint main() {\n  //  freopen(\"a.in\", \"r\", stdin);\n  //  freopen(\"a.out\", \"w\", stdout);\n  scanf(\"%d%d%d\", &N, &n, &m);\n  for(int i = 1; i <= N; i++) {\n    scanf(\"%d\", &U[i]);\n    scanf(\"%d\", &V[i]);\n    scanf(\"%d\", &X[i]);\n  } ans = 0;\n  ans = max(ans, solve());\n  for(int i = 1; i <= N; i++) swap(U[i], V[i]);\n  ans = max(ans, solve());\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n/*\n  ;    11;    1;    6,12;    13;          ;\n  7,8;      ;     ;        ;      ;          ;\n  5;      ;     ;        ;      ;         4;\n  ;      ;     ;        ;      ;    2,3,10;\n  ;      ;     ;        ;      ;         9;\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nstruct node {\n\tint x, y, w;\n\tnode() = default;\n\tnode(int _x, int _y, int _w) : x(_x), y(_y), w(_w) {}\n\tbool friend operator < (const node &a, const node &b) {\n\t\treturn a.w > b.w;\n\t}\n};\nint n, h, w;\nint fa[maxn * 2], sz[maxn * 2];\nint find(int x) {\n\treturn x == fa[x] ? x : fa[x] = find(fa[x]);\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcin >> n >> h >> w;\n\tvector<node> a(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tcin >> a[i].x >> a[i].y >> a[i].w;\n\t\ta[i].y += h; \n\t}\n\tsort(a.begin(), a.end());\n\tfor(int i = 1; i <= h + w; ++i) {\n\t\tfa[i] = i;\n\t\tsz[i] = 1;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0; i < n; ++i) {\n\t\tint x = find(a[i].x), y = find(a[i].y);\n\t\tif(x != y) {\n\t\t\tfa[x] = y;\n\t\t\tsz[y] += sz[x];\n\t\t}\n\t\tif(sz[y]) {\n\t\t\t--sz[y];\n\t\t\tans += a[i].w;\n\t\t}\n\t}\n\tcout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace mine\n{\n    #define double long double\n    typedef long long ll;\n    #define pr pair<int,int>\n    #define FR first\n    #define SE second\n    #define MP make_pair\n    #define PB push_back\n    #define vc vector\n    #define all(x) (x).begin(),(x).end()\n    #define sz(x) ((int)(x).size())\n    ll qread()\n    {\n        ll ans=0,f=1;char c=getchar();\n        while(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n        while('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n        return ans*f;\n    }\n    void write(ll num)\n    {\n        if(num<0) putchar('-'),num=-num;\n        if(num>=10) write(num/10);\n        putchar('0'+num%10);\n    }\n    void write1(ll num){write(num);putchar(' ');}\n    void write2(ll num){write(num);putchar('\\n');}\n    void chmax(int &x,const ll y) {x=(x>y?x:y);}\n    void chmin(int &x,const ll y) {x=(x<y?x:y);}\n    ll gcd(ll x,ll y){return y?gcd(y,x%y):0;}\n    const int INF=0x3f3f3f3f;\n    const int MOD=1e9+7;\n    inline int mm(const int x){return x>=MOD?x-MOD:x;}\n    inline ll qpower(ll x,ll e)\n    {\n        ll ans=1;\n        while(e)\n        {\n            if(e&1) ans=ans*x%MOD;\n            x=x*x%MOD;e>>=1;\n        }\n        return ans;\n    }\n    inline int invm(int x){return qpower(x,MOD-2);}\n    const int N=1e6+10;\n\n    int fa[N],cnt[N];\n    int findfa(int x){return fa[x]==x?x:fa[x]=findfa(fa[x]);}\n    struct Nod{int x,y,c;}e[N];bool cmp(Nod a,Nod b){return a.c>b.c;}\n    void main()\n    {\n        int n=qread(),h=qread(),w=qread();\n        for(int i=1;i<=n;i++){int x=qread(),y=qread(),c=qread();e[i]=(Nod){x,y,c};}\n        sort(e+1,e+n+1,cmp);for(int i=1;i<=h+w;i++) fa[i]=i;\n        ll ans=0;\n        for(int i=1;i<=n;i++)\n        {\n            int fx=findfa(e[i].x),fy=findfa(h+e[i].y);\n            if(fx!=fy) {\n                if(cnt[fx]+cnt[fy]<2){\n                    if(cnt[fx])swap(fx,fy);\n                    fa[fx]=fy,ans+=e[i].c;\n                }\n            }\n            else if(cnt[fx]==0)\n                cnt[fx]=1,ans+=e[i].c;\n        }\n        write(ans);\n    }\n};\nint main()\n{\n    srand(time(0));\n    mine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n\nconst int N = 200200;\nconst long long mod = 1e9 + 7;\n\nusing namespace std;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nint n;\nint m;\nint q;\nint p[N];\nvector < int > v[N], backup;\nbool used[N];\n\nbool dfs(int x)\n{\n        used[x] = true;\n        backup.push_back(x);\n        for(int y: v[x]){\n                if(p[y] == -1){\n                        p[y] = x;\n                        return true;\n                } else if(!used[p[y]] && dfs(p[y])){\n                        p[y] = x;\n                        return true;\n                }\n        }\n        return false;\n}\n\nint main()\n{\n        ios_base::sync_with_stdio(0);\n\n        //freopen(\"input.txt\", \"r\", stdin);\n        //freopen(\"output.txt\", \"w\", stdout);\n\n        cin >> q >> n >> m;\n        for(int i = 1; i <= n + m; i++){\n                p[i] = -1;\n        }\n        vector < pair < int, int > > qu;\n        for(int i = 1; i <= q; i++){\n                int x, y, w;\n                cin >> x >> y >> w;\n                v[i].push_back(x);\n                v[i].push_back(y + n);\n                qu.push_back({w, i});\n\n                shuffle(v[i].begin(), v[i].end(), rng);\n        }\n        sort(qu.begin(), qu.end());\n        reverse(qu.begin(), qu.end());\n        long long res = 0;\n        for(auto g: qu){\n                if(dfs(g.se)){\n                        res += g.fi;\n                }\n                        while(!backup.empty()){\n                                used[backup.back()] = false;\n                                backup.pop_back();\n                        }\n        }\n        cout << res << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst long long mo = 1e9+7;\nconst int maxi = 3e6+10;\n#define pb push_back\nint n,k;\nstring s;\nvector<int> v[maxi];\nint a[maxi];\nint cnt[maxi];\nint ob[3][maxi];\nint c[maxi], r[maxi];\nmultiset<int> st[3][maxi];\nmultiset<pair<int, pair<int,int>>> global;\nint h,w;\nint main()\n{\n     cin>>n>>h>>w;\n\n     for (int i=1;i<=n;i++)\n     {\n          scanf(\"%d%d%d\",&r[i],&c[i],&a[i]);\n          st[1][r[i]].insert(a[i]);\n          st[2][c[i]].insert(a[i]);\n          global.insert({a[i], {r[i],c[i]}});\n     }\n\n     long long ans = 0;\n     while(!global.empty())\n     {\n          pair<int, pair<int,int>> node = *global.rbegin();\n\n          global.erase(global.find(node));\n          st[1][node.second.first].erase(st[1][node.second.first].find(node.first));\n          st[2][node.second.second].erase(st[2][node.second.second].find(node.first));\n\n          if (ob[1][node.second.first] && ob[2][node.second.second])\n              continue;\n          else\n            ans+=node.first;\n\n          if (ob[1][node.second.first] && !ob[2][node.second.second])\n              ob[2][node.second.second] = 1;\n           else\n            if (!ob[1][node.second.first] && ob[2][node.second.second])\n                ob[1][node.second.first] = 1;\n           else\n           {\n               int val1 = 0;\n               int val2 = 0;\n\n               if (st[1][node.second.first].size())\n                val1 = *st[1][node.second.first].rbegin();\n\n               if (st[2][node.second.second].size())\n                val2 = *st[2][node.second.second].rbegin();\n\n               if (val2>=val1)\n                 ob[1][node.second.first] = 1;\n               else\n                ob[2][node.second.second] = 1;\n           }\n     }\n\n     cout<<ans<<endl;\n    return 0;\n}\n//just a little magic\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cstring>\nusing namespace std;\ntypedef long long ll;\n#define N 200010\ninline int read(){\n\tint x=0,f=1;\n\tchar c=getchar();\n\twhile(c<'0'||c>'9'){\n\t\tif(c=='-')f=-1;\n\t\tc=getchar();\n\t}\n\twhile(c>='0'&&c<='9'){\n\t\tx=(x<<1)+(x<<3)+c-'0';\n\t\tc=getchar();\n\t}\n\treturn x*f;\n}\nint n,H,W;\nll ans;\nstruct Union_Set{\n\tint f[N];\n\tbool c[N];\n\tvoid init(int n){\n\t\tfor(int i=1;i<=n;++i){\n\t\t\tf[i]=i;\n\t\t\tc[i]=false;\n\t\t}\n\t}\n\tinline int getf(int x){\n\t\treturn f[x]==x?x:f[x]=getf(f[x]);\n\t}\n}S;\nstruct Point{\n\tint x,y,w;\n\tbool operator <(const Point b)const{\n\t\treturn w>b.w;\n\t}\n}a[N];\nint main(){\n\tn=read(),H=read(),W=read();\n\tS.init(H+W);\n\tfor(int i=1;i<=n;++i){\n\t\ta[i].x=read(),a[i].y=read(),a[i].w=read();\n\t}\n\tsort(a+1,a+n+1);\n\tfor(int i=1;i<=n;++i){\n\t\tint fx=S.getf(a[i].x),fy=S.getf(a[i].y+H);\n\t\tif(fx==fy){\n\t\t\tif(S.c[fx])continue;\n\t\t\tS.c[fx]=true;\n\t\t}\n\t\telse{\n\t\t\tif(S.c[fx]&&S.c[fy])continue;\n\t\t\tS.c[fx]|=S.c[fy];\n\t\t\tS.f[fy]=fx;\n\t\t}\n\t\tans+=a[i].w;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\nstruct card{\n    int r;\n    int c;\n    int v;\n};\n\n\nint main(){\n    \n    unsigned long n,h,w;\n\n    cin>>n>>h>>w;\n\n    card cards[n];\n\n    for(int i = 0; i < n; i++){\n        cin>>cards[i].r>>cards[i].c>>cards[i].v;\n    }\n\n    long grow = 0,gcol = 0;\n    int p = -1;\n    long rsum = 0,csum = 0;\n\n    for(int i = 1; i <= h; i++){\n        for(int j = 0; j < n; j++){\n            if(cards[j].r == i and grow <= cards[j].v){\n                grow = cards[j].v;\n                p = j;\n            }\n        }\n        cards[p].v = -1;\n        rsum += grow;\n        grow = 0;\n    }\n\n    for(int i = 1; i <= w; i++){\n        for(int j = 0; j < n; j++){\n            if(cards[j].c == i and gcol <= cards[j].v){\n                gcol = cards[j].v;\n                p = j;\n            }\n        }\n        cards[p].v = -1;\n        csum += gcol;\n        gcol = 0;\n    }\n\n    long sum = rsum+csum;\n\n    cout<<sum;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define REP(i,n) for(ll i=0;i<n;i++)\n#define REP1(i,n) for(ll i=1;i<=n;i++)\n#define FILL(i,n) memset(i,n,sizeof i)\n#define X first\n#define Y second\n#define ET cout << \"\\n\"\n#define SZ(_a) (int)_a.size()\n#define ALL(_a) _a.begin(),_a.end()\n#define pb push_back\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#ifdef bbq\n#define debug(...) {\\\n    fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\", \";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\n#else\n#define debug(...)\n#endif\n\nvector<int> G[100005];\nint mp[100005],mq[200005],fm[100005],vis[100005],nw;\nint qu[100005],ql,qr;\n\nbool bfs(int u)\n{\n\t++nw,ql=0,qr=-1;\n\tqu[++qr]=u,fm[u]=-1,vis[u]=nw;\n\twhile(qr>=ql)\n\t{\n\t\tint p=qu[ql++];\n\t\tfor(int i:G[p])\n\t\t\tif(!~mq[i])\n\t\t\t{\n\t\t\t\tint ls=i;\n\t\t\t\twhile(~p)\n\t\t\t\t{\n\t\t\t\t\tint tmp=mp[p];\n\t\t\t\t\tmp[mq[ls]=p]=ls,p=fm[p],ls=tmp;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(vis[mq[i]]<nw)\n\t\t\t\tqu[++qr]=mq[i],vis[mq[i]]=nw,fm[mq[i]]=p;\n\t}\n\treturn 0;\n}\n\nstruct mode\n{\n\tint r,c,v;\n\tbool operator<(const mode &a)const{\n\t\treturn v>a.v;\n\t}\n}arr[100005];\n\nint main()\n{\n\tIOS();\n\tll ans=0;\n\tint n,h,w;\n\tcin >> n >> h >> w;\n\tfor(int i=0;i<n;++i)\n\t\tcin >> arr[i].r >> arr[i].c >> arr[i].v,--arr[i].r,--arr[i].c;\n\tsort(arr,arr+n),FILL(mp,-1),FILL(mq,-1);\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tG[i].pb(arr[i].r),G[i].pb(h+arr[i].c);\n\t\tif(bfs(i))\n\t\t\tans+=arr[i].v;\n\t}\n\tcout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N = 300000 + 100;\nconst LL INF = 1e12;\nstruct Edge\n{\n    int from,to,cap;LL flow, cost;\n    Edge(int u,int v,int ca,int f,LL co):from(u),to(v),cap(ca),flow(f),cost(co){};\n};\n\nstruct MCMF\n{\n    int n,m,s,t;\n    vector<Edge> edges;\n    vector<int> G[N];\n    int inq[N];//是否在队列中\n    LL d[N];//距离\n    int p[N];//上一条弧\n    LL a[N];//可改进量\n\n    void init(int n)//初始化\n    {\n        this->n=n;\n        for(int i=0;i<n;i++)\n            G[i].clear();\n        edges.clear();\n    }\n\n    void AddEdge(int from,int to,int cap,LL cost)//加边\n    {\n        edges.push_back(Edge(from,to,cap,0,cost));\n        edges.push_back(Edge(to,from,0,0,-cost));\n        int m=edges.size();\n        G[from].push_back(m-2);\n        G[to].push_back(m-1);\n    }\n\n    bool SPFA(int s,int t,int &flow,LL &cost)//寻找最小费用的增广路，使用引用同时修改原flow,cost\n    {\n        for(int i=0;i<n;i++)\n            d[i]=INF;\n        memset(inq,0,sizeof(inq));\n        d[s]=0;inq[s]=1;p[s]=0;a[s]=INF;\n        queue<int> Q;\n        Q.push(s);\n        while(!Q.empty())\n        {\n            int u=Q.front();\n            Q.pop();\n            inq[u]--;\n            for(int i=0;i<G[u].size();i++)\n            {\n                Edge& e=edges[G[u][i]];\n                if(e.cap>e.flow && d[e.to]>d[u]+e.cost)//满足可增广且可变短\n                {\n                    d[e.to]=d[u]+e.cost;\n                    p[e.to]=G[u][i];\n                    a[e.to]=min(a[u],e.cap-e.flow);\n                    if(!inq[e.to])\n                    {\n                        inq[e.to]++;\n                        Q.push(e.to);\n                    }\n                }\n            }\n        }\n        if(d[t]==INF) return false;//汇点不可达则退出\n        flow+=a[t];\n        cost+=d[t]*a[t];\n        int u=t;\n        while(u!=s)//更新正向边和反向边\n        {\n            edges[p[u]].flow+=a[t];\n            edges[p[u]^1].flow-=a[t];\n            u=edges[p[u]].from;\n        }\n        return true;\n    }\n\n    LL MincotMaxflow(int s,int t)\n    {\n        int flow=0;LL cost=0,res=0;\n        while(SPFA(s,t,flow,cost)){\n            res=max(res,-cost);\n        }\n        //printf(\"flow = %d\\n\", flow);\n        return res;\n    }\n} G;\n\n\nint main() {\n    int n, h, w;\n    scanf(\"%d%d%d\",&n,&h,&w);\n    int S = n+w+h+1, T = S+1;\n    G.init(T+1);\n    for(int i=1;i<=n;i++){\n        int r,c,x; scanf(\"%d%d%d\",&r,&c,&x);\n        G.AddEdge(n+r,i,1,0);\n        G.AddEdge(n+h+c,i,1,0);\n        G.AddEdge(i,T,1,-x);\n    }\n    for (int i=1;i<=h;i++) G.AddEdge(S,n+i,1,0);\n    for (int i=h+1;i<=h+w;i++) G.AddEdge(S,n+i,1,0);\n    cout << G.MincotMaxflow(S, T) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144*4\n#define REP(a,b) for(long long a = 0;a < b;++a)\npair<int,int> union_tree[300000];\nint union_find(int now) {\n\tif (union_tree[now].first == now) return now;\n\treturn union_tree[now].first = union_find(union_tree[now].first);\n}\nvoid union_merge(int a, int b) {\n\ta = union_find(a);\n\tb = union_find(b);\n\tif (a == b) return;\n\tunion_tree[a].second += union_tree[b].second;\n\tunion_tree[b].first = union_tree[a].first;\n\treturn;\n}\nint main() {\n#define int long long\n\tiostream::sync_with_stdio(false);\n\tcin.tie(false);\n\tint n, h, w;\n\tcin >> n >> h >> w;\n\tvector<tuple<int, int, int>> inputs;\n\tREP(i, n) {\n\t\tlong long a, b, c;\n\t\tcin >> a >> b >> c;\n\t\ta--;\n\t\tb--;\n\t\tinputs.push_back(make_tuple(c, a, b));\n\t}\n\tfor (int i = 0; i < 300000; ++i) {\n\t\tunion_tree[i] = make_pair(i, 1);\n\t}\n\tsort(inputs.begin(), inputs.end());\n\treverse(inputs.begin(), inputs.end());\n\tlong long ans = 0;\n\tfor (int i = 0; i < inputs.size(); ++i) {\n\t\tint a = get<1>(inputs[i]);\n\t\tint b = h + get<2>(inputs[i]);\n\t\ta = union_find(a);\n\t\tb = union_find(b);\n\t\tif (union_tree[a].second + union_tree[b].second >= 1) {\n\t\t\tunion_merge(a, b);\n\t\t\tunion_tree[a].second--;\n\t\t\tans += get<0>(inputs[i]);\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// need\n#include <iostream>\n#include <algorithm>\n// data structure\n#include <bitset>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <complex>\n//#include <deque>\n#include <valarray>\n#include <unordered_map>\n#include <unordered_set>\n#include <array>\n// etc\n#include <cassert>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <chrono>\n#include <random>\n#include <numeric>\n\n// input\n#define INIT std::ios::sync_with_stdio(false);std::cin.tie(0);\n#define VAR(type, ...)type __VA_ARGS__;MACRO_VAR_Scan(__VA_ARGS__);\ntemplate<typename T> void MACRO_VAR_Scan(T& t) { std::cin >> t; }\ntemplate<typename First, typename...Rest>void MACRO_VAR_Scan(First& first, Rest& ...rest) { std::cin >> first; MACRO_VAR_Scan(rest...); }\n#define VEC_ROW(type, n, ...)std::vector<type> __VA_ARGS__;MACRO_VEC_ROW_Init(n, __VA_ARGS__); for(int w_=0; w_<n; ++w_){MACRO_VEC_ROW_Scan(w_, __VA_ARGS__);}\ntemplate<typename T> void MACRO_VEC_ROW_Init(int n, T& t) { t.resize(n); }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Init(int n, First& first, Rest& ...rest) { first.resize(n); MACRO_VEC_ROW_Init(n, rest...); }\ntemplate<typename T> void MACRO_VEC_ROW_Scan(int p, T& t) { std::cin >> t[p]; }\ntemplate<typename First, typename...Rest>void MACRO_VEC_ROW_Scan(int p, First& first, Rest& ...rest) { std::cin >> first[p]; MACRO_VEC_ROW_Scan(p, rest...); }\n#define VEC(type, c, n) std::vector<type> c(n);for(auto& i:c)std::cin>>i;\n#define MAT(type, c, m, n) std::vector<std::vector<type>> c(m, std::vector<type>(n));for(auto& R:c)for(auto& w:R)std::cin>>w;\n// output\n#define OUT(dist) std::cout<<(dist);\n#define FOUT(n, dist) std::cout<<std::fixed<<std::setprecision(n)<<(dist);\n#define SOUT(n, c, dist) std::cout<<std::setw(n)<<std::setfill(c)<<(dist);\n#define SP std::cout<<\" \";\n#define TAB std::cout<<\"\\t\";\n#define BR std::cout<<\"\\n\";\n#define SPBR(w, n) std::cout<<(w + 1 == n ? '\\n' : ' ');\n#define ENDL std::cout<<std::endl;\n#define FLUSH std::cout<<std::flush;\n#define SHOW(dist) {std::cerr << #dist << \"\\t:\" << (dist) << \"\\n\";}\n#define SHOWVECTOR(v) {std::cerr << #v << \"\\t:\";for(const auto& xxx : v){std::cerr << xxx << \" \";}std::cerr << \"\\n\";}\n#define SHOWVECTOR2(v) {std::cerr << #v << \"\\t:\\n\";for(const auto& xxx : v){for(const auto& yyy : xxx){std::cerr << yyy << \" \";}std::cerr << \"\\n\";}}\n#define SHOWQUEUE(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.front() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n#define SHOWSTACK(a) {auto tmp(a);std::cerr << #a << \"\\t:\";while(!tmp.empty()){std::cerr << tmp.top() << \" \";tmp.pop();}std::cerr << \"\\n\";}\n// utility\n#define ALL(a) (a).begin(),(a).end()\n#define FOR(w, a, n) for(int w=(a);w<(n);++w)\n#define RFOR(w, a, n) for(int w=(n)-1;w>=(a);--w)\n#define REP(w, n) for(int w=0;w<int(n);++w)\n#define RREP(w, n) for(int w=int(n)-1;w>=0;--w)\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T> inline T CHMAX(T & a, const T b) { return a = (a < b) ? b : a; }\ntemplate<class T> inline T CHMIN(T& a, const T b) { return a = (a > b) ? b : a; }\n// test\ntemplate<class T> using V = std::vector<T>;\ntemplate<class T> using VV = V<V<T>>;\n\ntemplate<typename S, typename T>\nstd::ostream& operator<<(std::ostream& os, std::pair<S, T> p) {\n\tos << \"(\" << p.first << \", \" << p.second << \")\"; return os;\n}\n\n#define random_shuffle \"USE std::shuffle!\";\n\n// type/const\n#define int ll\nusing ll = long long;\nusing ull = unsigned long long;\nusing ld = long double;\nusing PAIR = std::pair<int, int>;\nusing PAIRLL = std::pair<ll, ll>;\nconstexpr int INFINT = (1 << 30) - 1;                    // 1.07x10^ 9\nconstexpr int INFINT_LIM = (1LL << 31) - 1;              // 2.15x10^ 9\nconstexpr ll INFLL = 1LL << 60;                          // 1.15x10^18\nconstexpr ll INFLL_LIM = (1LL << 62) - 1 + (1LL << 62);  // 9.22x10^18\nconstexpr double EPS = 1e-10;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.141592653589793238462643383279;\ntemplate<class T, size_t N> void FILL(T(&a)[N], const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, size_t N, size_t M, class T> void FILL(ARY(&a)[N][M], const T & val) { for (auto& b : a) FILL(b, val); }\ntemplate<class T> void FILL(std::vector<T> & a, const T & val) { for (auto& x : a) x = val; }\ntemplate<class ARY, class T> void FILL(std::vector<std::vector<ARY>> & a, const T & val) { for (auto& b : a) FILL(b, val); }\n// ------------>8------------------------------------->8------------\n\nclass UnionFind {\nprivate:\n\tstd::vector<int> par;\n\tstd::vector<int> siz;\n\tV<bool> hasCycle_;\n\npublic:\n\tUnionFind(int sz_) : par(sz_), siz(sz_, 1), hasCycle_(sz_, false) {\n\t\tfor (int i = 0; i < sz_; ++i) par[i] = i;\n\t}\n\tvoid init(int sz_) {\n\t\tpar.resize(sz_);\n\t\tsiz.resize(sz_, 1);\n\t\tfor (int i = 0; i < sz_; ++i) par[i] = i;\n\t}\n\tint find(int x) {\n\t\twhile (par[x] != x) x = par[x] = par[par[x]];\n\t\treturn x;\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) {\n\t\t\thasCycle_[x] = true;\n\t\t\treturn;\n\t\t}\n\t\tif (siz[x] < siz[y]) std::swap(x, y);\n\t\tsiz[x] += siz[y];\n\t\tpar[y] = x;\n\t\thasCycle_[x] = hasCycle_[x] | hasCycle_[y];\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn siz[find(x)];\n\t}\n\tbool hasCycle(int x) {\n\t\treturn hasCycle_[find(x)];\n\t}\n};\n\nsigned main() {\n\tINIT;\n\n\tVAR(int, n, h, w);\n\tVEC_ROW(int, n, r, c, a);\n\n\tV<int> o(n);\n\tstd::iota(ALL(o), 0);\n\tstd::sort(ALL(o), [&](int l, int r) { return a[l] > a[r]; });\n\n\tUnionFind uf(h + w);\n\tint ans = 0;\n\tREP(_i, n) {\n\t\tint i = o[_i];\n\t\t--r[i]; --c[i];\n\t\tif (uf.same(r[i], c[i] + h) && uf.hasCycle(r[i])) continue;\n\t\tif (uf.hasCycle(r[i]) && uf.hasCycle(c[i] + h)) continue;\n\t\tuf.unite(r[i], c[i] + h);\n\t\tans += a[i];\n\t}\n\tOUT(ans)BR;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author\n */\n\n#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\n#define fr(i,n) for(int i=0;i<(n);++i)\n#define Fr(i,n) for(int i=1;i<=(n);++i)\n#define ifr(i,n) for(int i=(n)-1;i>=0;--i)\n#define iFr(i,n) for(int i=(n);i>0;--i)\n\ntemplate<class T> struct UF{\n    vector<T> par,sz,ed;\n\n    UF(T n){\n        par.resize(n);\n        sz.resize(n,1);\n        ed.resize(n,0);\n        for (int i = 0; i < n; ++i) par[i]=i;\n    }\n\n    T find(T x){\n        if(par[x]==x) return x;\n        return par[x]=find(par[x]);\n    }\n\n    bool unit(T x,T y){\n        x=find(x);\n        y=find(y);\n        if(x==y){\n            ++ed[x];\n            return false;\n        }\n        if(sz[x]>sz[y]){\n            par[y]=x;\n            sz[x]+=sz[y];\n            ed[x]+=ed[y]+1;\n        }\n        else{\n            par[x]=y;\n            sz[y]+=sz[x];\n            ed[y]+=ed[x]+1;\n        }\n        return true;\n    }\n    bool same(T x,T y){return find(x)==find(y);}\n    bool ok(T x,T y){\n        x=find(x);y=find(y);\n        return sz[x]+sz[y]>ed[x]+ed[y];\n    }\n};\n\nstruct ARC{\n    int a,r,c;\n    bool operator<(ARC x){\n        return a>x.a;\n    }\n};\n\nclass ECardCollector {\npublic:\n    void solve(istream& in, ostream& out) {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        int n,h,w;\n        in>>n>>h>>w;\n        vector<ARC> arc(n);\n        for(auto&i:arc) in>>i.r>>i.c>>i.a,--i.r,--i.c;\n        sort(arc.begin(),arc.end());\n        UF<int> uf(h+w);\n        ll ans=0;\n        fr(i,n){\n            if(uf.ok(arc[i].r,h+arc[i].c)){\n                ans+=arc[i].a;\n                uf.unit(arc[i].r,arc[i].c+h);\n            }\n        }\n        out<<ans<<endl;\n    }\n};\n\nint main() {\n    ECardCollector solver;\n    std::istream& in(std::cin);\n    std::ostream& out(std::cout);\n    solver.solve(in, out);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <array>\n#include <set>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <tuple>\n#include <functional>\n#include <bitset>\n#include <cstdint>\n#include <cassert>\n\nusing namespace std;\nusing i64 = int64_t;\nusing i32 = int32_t;\ntemplate<class T, class U> void init_n(vector<T>& v, size_t n, U x) \n{ v = vector<T>(n, x); }\ntemplate<class T> void init_n(vector<T>& v, size_t n) { init_n(v, n, T()); }\ntemplate<class T> void read_n(vector<T>& v, size_t n, size_t o = 0) \n{ v = vector<T>(n+o); for (size_t i=o; i<n+o; ++i) cin >> v[i]; }\ntemplate<class T> void read_n(T a[], size_t n, size_t o = 0)\n{ for (size_t i=o; i<n+o; ++i) cin >> a[i]; }\ntemplate<class T> T gabs(const T& x) { return max(x, -x); }\n#define abs gabs\n\nstruct UnionFind {\n  vector<int> c, s, es;\n  UnionFind(size_t n) : c(n), s(n, 1), es(n, 0) { iota(begin(c), end(c), 0); }\n  int root(int i) { return c[i] == i ? i : (c[i] = root(c[i])); }\n  bool same(int i, int j) { return root(i) == root(j); }\n  void unite(int i, int j) {\n    i = root(i); j = root(j);\n    if (i != j) {\n      if (s[i] > s[j]) { c[j] = i; s[i] += s[j]; es[i] += es[j] + 1; }\n      else { c[i] = j; s[j] += s[i]; es[j] += es[i] + 1; }\n    } else {\n      es[i]++; \n    }\n  }\n  int size(int i) { return s[root(i)]; }\n  int edges(int i) { return es[root(i)]; }\n};\n\nstruct P {\n  i64 r, c, a;\n};\n\ni64 n, h, w;\nvector<P> ps;\nint main() {\n  cin >> n >> h >> w;\n  map<i64, i64> rm, cm;\n  for (i64 i = 0; i < n; ++i) {\n    i64 r, c, a;\n    cin >> r >> c >> a;\n    ps.push_back({ r, c, a });\n    rm[r] = 0;\n    cm[c] = 0;\n  }\n  i64 idx = 0;\n  for (auto& p : rm) {\n    rm[p.first] = idx++;\n  }\n  for (auto& p : cm) {\n    cm[p.first] = idx++;\n  }\n\n  vector<P> es;\n  i64 m = rm.size() + cm.size();\n  i64 ofs = rm.size();\n  for (auto p : ps) {\n    es.push_back({ rm[p.r], cm[p.c], p.a });\n  }\n  sort(begin(es), end(es), [](P p, P q) { return p.a < q.a; });\n\n  UnionFind uf(m);\n  i64 ans = 0;\n  while (!es.empty()) {\n    auto e = es.back();\n    es.pop_back();\n\n    if ((uf.same(e.r, e.c) && uf.edges(e.r) < uf.size(e.r)) ||\n        (!uf.same(e.r, e.c) && \n        uf.edges(e.r) + uf.edges(e.c) < uf.size(e.r) + uf.size(e.c))) {\n      uf.unite(e.r, e.c);\n      ans += e.a;\n    }\n  }\n\n  cout << ans << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\n#define all(x) (x).begin(), (x).end()\n#define rall(x) (x).rbegin(), (x).rend()\n#define rep(i, n) for (ll i = 0; i < n; i++)\n#define rrep(i, n) for (ll i = n - 1; i >= 0; i--)\n#define Rep(i, r, n) for (ll i = r; i < n; i++)\n#define RRep(i, r, n) for (ll i = n - 1; i <= r; i--)\n#define debug(x) cout << #x << ' ' << '=' << ' ' << (x) << endl;\n#define fs first\n#define sc second\n#define int long long\n#define pb push_back\n#define mp make_pair\nconst int dx[] = {0, -1, 0, 1};\nconst int dy[] = {1, 0, -1, 0};\nconst int MOD = (1000000007);\n//const int MOD = (998244353);\n//const int INF = (1 << 30)-1;\nconst int INF = (1LL << 60)-1;\nconst double EPS = (1 >> 30);\n\ntemplate<class T> inline bool chmin(T& a, T b) {if (a > b) {a = b; return 1;} return 0;}\ntemplate<class T> inline bool chmax(T& a, T b) {if (a < b) {a = b; return 1;} return 0;}\n\nusing Graph = vector<vector<pair<int, int>>>;\nusing Ki = vector<vector<int>>;\nusing vec = vector<int>;\nusing T = tuple<int,int,int>;\nconst int N_MAX = 100000;\nvec ed;\n\nstruct UnionFind {\n    private:\n    vector<int> child, tree, sum;\n\n    public:\n    UnionFind(int v) {\n        tree.resize(v);\n        sum.resize(v);\n        rep(i, v) tree[i] = i, sum[i] = 1;\n    }\n\n    int root(int i) {\n        if(i == tree[i]) {\n            rep(j, child.size()) tree[child[j]] = i;\n            child.clear(); \n            return i;\n        }\n        else {\n            child.push_back(i);\n            return i = root(tree[i]);\n        }\n    }\n\n    int size(int i) {\n        return sum[root(i)];\n    }\n\n    int edsize(int i){\n        return ed[root(i)];\n    }\n\n    int unit(int x, int y) {\n        if(isUnit(x,y)) return 0;\n        x = root(x);\n        y = root(y);\n        sum[min(x,y)] += sum[max(x,y)];\n        tree[max(x,y)] = min(x,y);\n        ed[root(min(x,y))]+=1+ed[root(max(x,y))];\n    }\n\n    bool isUnit(int x, int y) {\n        return root(x) == root(y);\n    }\n};\n\nsigned main()\n{\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout << fixed << setprecision(10);\n    //---------------------------------------------\n    \n    int n,h,w;\n    cin>>n>>h>>w;\n    vector<T> x(n);\n    rep(i,n){\n        int r,c,a;\n        cin>>r>>c>>a;\n        r--;\n        c--;\n        x[i]=T(a,r,c);\n    }\n    sort(rall(x));\n    UnionFind uf(h+1+N_MAX);\n    ed.resize(h+1+N_MAX);\n    ll ans=0;\n    map<P,int> maap;\n    rep(i,n){\n        int r,c,a;\n        tie(r,c,a)=x[i];\n        int c_t=uf.size(c);\n        int a_t=uf.size(a);\n        int c_e=uf.edsize(c);\n        int a_e=uf.edsize(c);\n        // maap.insert(mp(P(c,a+N_MAX),1));\n        // int con=maap.count(P(c,a+N_MAX));\n        int t=c_t+a_t;\n        int e=c_e+a_e+1;\n        if(t<e) continue;\n        if(!uf.isUnit(c,a+N_MAX)){\n            uf.unit(c,a+N_MAX);\n            ans+=r;\n        }\n        else if(maap.count(P(c,a+N_MAX))){\n            maap.insert(mp(P(c,a+N_MAX),1));\n            ed[uf.root(c)]+=1+ed[uf.root(a+N_MAX)];\n            ans+=r;\n        }\n    }\n    cout<<ans<<endl;\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\nint P[200002];\nint eranda[200002];\n\nint Find(int A) {\n\tif (P[A] < 0) return A;\n\treturn P[A] = Find(P[A]);\n}\n\nbool Unite(int A, int B) {\n\tint a = Find(A);\n\tint b = Find(B);\n\tif (a == b) return false;\n\tif (P[a] > P[b]) swap(a, b);\n\tP[a] += P[b];\n\teranda[a] |= eranda[b];\n\tP[b] = a;\n\treturn true;\n}\n\nint Size(int A) {\n\treturn -P[Find(A)];\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint N, H, W;\n\tcin >> N >> H >> W;\n\n\tpair<int, pair<int, int>> E[100000];\n\trep(i, N) {\n\t\tint r, c, a;\n\t\tcin >> r >> c >> a;\n\t\tE[i] = mp(a, mp(r - 1, H + c - 1));\n\t}\n\tsort(E, E + N);\n\treverse(E, E + N);\n\n\trep(i, H + W) P[i] = -1;\n\tll kotae = 0;\n\trep(i, N) {\n\t\tint r = E[i].second.first;\n\t\tint c = E[i].second.second;\n\t\tif (Find(r) != Find(c)) {\n\t\t\tif (!(eranda[Find(r)] && eranda[Find(c)])) {\n\t\t\t\tUnite(r, c);\n\t\t\t\tkotae += E[i].first;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (eranda[Find(r)] == 0) {\n\t\t\t\tkotae += E[i].first;\n\t\t\t\teranda[Find(r)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tco(kotae);\n\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n・問題をグラフに言い換える（グラフ上の良い辺集合のうち最適なものを見つける問題に言い換える）\n・「良い辺集合である」ことを，すぐ判定可能な条件に言い換える\n・クラスカル的な貪欲法で解く\nいずれも発想できず・・・\n*/\n#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define mt make_tuple\n#define MOD 1000000007\ntypedef long long int ll;\n\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\n\nll extgcd(ll a, ll b, ll &x, ll &y) {\n  ll g = a; x = 1; y = 0;\n  if (b != 0) g = extgcd(b, a % b, y, x), y -= (a / b) * x;\n  return g;\n}\nll gcd(ll a, ll b) { ll x, y; return extgcd(a, b, x, y);}\n\nclass llm{\n\tll n;\npublic:\n\tllm(){n = 0;}\n\tllm(ll n){this->n = (n >= 0) ? (n % MOD) : (MOD - 1 - (-n-1 % MOD));}\n\toperator ll() const {return n;}\n\tllm operator+(const llm &y) const{ return llm((ll)*this + (ll)y);}\n\tllm operator+=(const llm &y) { *this = *this + y; return *this;}\n\tllm operator-(const llm &y) const{ return llm((ll)*this - (ll)y);}\n\tllm operator-=(const llm &y) { *this = *this - y; return *this;}\n\tllm operator-() const{ return llm(0) - *this;}\n\tllm operator*(const llm &y) const{ return llm((ll)*this * (ll)y);}\n\tllm operator*=(const llm &y) { *this = *this * y; return *this;}\n\tllm operator/(const llm &y) const{ return *this * y.inv();}\n\tllm operator/=(const llm &y) { *this = *this / y; return *this;}\n\tllm inv() const{\n\t\tll x, y;\n\t\tif (extgcd(n, MOD, x, y) == 1) return llm(x);\n  \t\treturn llm(0); // unsolvable\n\t}\n\tfriend istream& operator >> (istream& os, llm& x);\n\tfriend ostream& operator << (ostream& os, const llm& x);\n};\nistream& operator >> (istream& is, llm& x){ll n; is >> n; x = llm(n); return is;}\nostream& operator << (ostream& os, const llm& x){os << (ll)x; return os;}\n\ntemplate<typename T> T comb(ll n, ll k){\n\tT ret = 1;\n\tfor(ll i=1;i<=k;i++) ret = ret * T(n - k + i) / T(i);\n\treturn ret;\n}\n\nll N, H, W;\nll r[114514], c[114514], a[114514];\n\nll p[214514], v[214514], e[214514];\n\n\nint parent(int n){\n\twhile(p[n] != -1){\n\t\tn = p[n];\n\t}\n\treturn n;\n}\n\n\nint main(void){\n\tcin >> N >> H >> W;\n\t\n\tvector<pair<int, pair<int, int> > > cards;\n\tfor(int i=0;i<N;i++){\n\t\tcin >> r[i] >> c[i] >> a[i]; r[i]--; c[i]--;\n\t\tcards.pb(mp(-a[i], mp(r[i], c[i])));\n\t}\n\tsort(cards.begin(), cards.end());\n\n\t// vertex index: 0, ..., H-1, H, ..., H+W-1 \n\tfor(int i=0;i<H+W;i++){\n\t\tp[i] = -1;\n\t\tv[i] = 1;\n\t\te[i] = 0;\n\t}\n\n\tll ans = 0;\n\tfor(auto card : cards){\n\t\tll i = card.second.first, j = H + card.second.second;\n\t\tll parI = parent(i), parJ = parent(j);\n\t\tif (parI != parJ){ // 非連結の場合\n\t\t\tif (v[parI] + v[parJ] >= e[parI] + e[parJ] + 1){\n\t\t\t\t// 繋ぐ\n\t\t\t\tans += -card.first;\n\t\t\t\tif (v[parI] > v[parJ]) swap(parI, parJ);\n\t\t\t\t//小さな方から大きな方へ繋ぐ\n\t\t\t\tp[parI] = parJ;\n\t\t\t\tv[parJ] += v[parI];\n\t\t\t\te[parJ] += e[parI] + 1;\n\t\t\t}\n\t\t}else{ // 連結の場合\n\t\t\tif (v[parI] >= e[parI] + 1){\n\t\t\t\t// 繋ぐ\n\t\t\t\tans += -card.first;\n\t\t\t\te[parI]++;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace std;\nusing namespace __gnu_pbds;\nusing ll = long long;\nusing u64 = uint_fast64_t;\nusing pii = pair<int, int>;\nusing pll = pair<long long, long long>;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\nconstexpr char ln =  '\\n';\nconstexpr long long MOD = 1000000007;\n//constexpr long long MOD = 998244353;\ntemplate<class T1, class T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T1, class T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return true;} return false; }\ninline int popcount(int x) {return __builtin_popcount(x);}\ninline int popcount(long long x) {return __builtin_popcountll(x);}\nvoid print() { cout << \"\\n\"; }\ntemplate<class T, class... Args>\nvoid print(const T &x, const Args &... args) {\n    cout << x << \" \";\n    print(args...);\n}\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N,H,W; cin >> N >> H >> W;\n    vector<int> R(N),C(N),A(N);\n    rep(i,N) {\n        cin >> R[i] >> C[i] >> A[i];\n        --R[i];\n        --C[i];\n    }\n\n    vector<int> idx(N);\n    iota(all(idx),0);\n    sort(all(idx),[&](int i, int j){return A[i] > A[j];});\n    vector<int> checkr(H,-1),checkc(W,-1),checka(N);\n\n    auto dfs=[&](auto&& self, int v)->bool {\n        checka[v] = 1;\n        if (checkr[R[v]]==-1) {\n            checkr[R[v]] = v;\n            checkc[C[v]] = -1;\n            return 1;\n        } else if (checkc[C[v]]==-1) {\n            checkc[C[v]] = v;\n            checkr[R[v]] = -1;\n            return 1;\n        }\n        if (checkr[R[v]] != v) {\n            int nex = checkr[R[v]];\n            if (!checka[nex]) {\n                if(self(self,nex)) {\n                    checkr[R[v]] = v;\n                    checkc[C[v]] = -1;\n                    return 1;\n                }\n            }\n        } else if (checkc[C[v]] != v) {\n            int nex = checkc[C[v]];\n            if (!checka[nex]) {\n                if (self(self,nex)) {\n                    checkc[C[v]] = v;\n                    checkr[R[v]] = -1;\n                    return 1;\n                }\n            }\n        }\n        return 0;\n    };\n    rep(i,N) {\n        int u = idx[i];\n        if (checkr[R[u]]==-1) {\n            checkr[R[u]] = u;\n        } else if (checkc[C[u]]==-1) {\n            checkc[C[u]] = u;\n        } else {\n            int s = checkr[R[u]];\n            if (!checka[s]) {\n                if (dfs(dfs,s)) {\n                    checkr[R[u]] = u;\n                    continue;\n                }\n            }\n            int t = checkc[C[u]];\n            if (!checka[t]) {\n                if (dfs(dfs,t)) {\n                    checkc[C[u]] = u;\n                }\n            }\n        }\n    }\n\n    ll ans = 0;\n    rep(i,H) {\n        if (checkr[i] != -1) ans += A[checkr[i]];\n    }\n    rep(i,W) {\n        if (checkc[i] != -1) ans += A[checkc[i]];\n    }\n\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define whlie while\n#define pb push_back\n#define eb emplace_back\n#define fi first\n#define se second\n#define rep(i,N) for(int i = 0; i < (N); i++)\n#define repr(i,N) for(int i = (N) - 1; i >= 0; i--)\n#define rep1(i,N) for(int i = 1; i <= (N) ; i++)\n#define repr1(i,N) for(int i = (N) ; i > 0 ; i--)\n#define each(x,v) for(auto& x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) ((int)(v).size())\n#define ini(...) int __VA_ARGS__; in(__VA_ARGS__)\n#define inl(...) ll __VA_ARGS__; in(__VA_ARGS__)\n#define ins(...) string __VA_ARGS__; in(__VA_ARGS__)\nusing namespace std; void solve();\nusing ll = long long; using vl = vector<ll>;\nusing vi = vector<int>; using vvi = vector< vector<int> >;\nconstexpr int inf = 1001001001;\nconstexpr ll infLL = (1LL << 61) - 1;\nstruct IoSetupNya {IoSetupNya() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); cerr << fixed << setprecision(7);} } iosetupnya;\ntemplate<typename T, typename U> inline bool amin(T &x, U y) { return (y < x) ? (x = y, true) : false; }\ntemplate<typename T, typename U> inline bool amax(T &x, U y) { return (x < y) ? (x = y, true) : false; }\ntemplate<typename T, typename U> ostream& operator <<(ostream& os, const pair<T, U> &p) { os << p.first << \" \" << p.second; return os; }\ntemplate<typename T, typename U> istream& operator >>(istream& is, pair<T, U> &p) { is >> p.first >> p.second; return is; }\ntemplate<typename T> ostream& operator <<(ostream& os, const vector<T> &v) { int s = (int)v.size(); rep(i,s) os << (i ? \" \" : \"\") << v[i]; return os; }\ntemplate<typename T> istream& operator >>(istream& is, vector<T> &v) { for(auto &x : v) is >> x; return is; }\nvoid in(){} template <typename T,class... U> void in(T &t,U &...u){ cin >> t; in(u...);}\nvoid out(){cout << \"\\n\";} template <typename T,class... U> void out(const T &t,const U &...u){ cout << t; if(sizeof...(u)) cout << \" \"; out(u...);}\ntemplate<typename T>void die(T x){out(x); exit(0);}\n#ifdef NyaanDebug\n  #include \"NyaanDebug.h\"\n  #define trc(...) do { cerr << #__VA_ARGS__ << \" = \"; dbg_out(__VA_ARGS__);} while(0)\n  #define trca(v,N) do { cerr << #v << \" = \"; array_out(v , N);cout << endl;} while(0)\n#else\n  #define trc(...)\n  #define trca(...)\n  int main(){solve();}\n#endif\n//using P = pair<ll,ll>; using vp = vector<P>;\nconstexpr int MOD = /** 1000000007; //*/ 998244353;\n////////////////\n\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to) : src(-1) , to(to) , cost(0){}\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) { // edge e = n; とできる(e.to = n)\n    to = x;\n    return *this;\n  }\n\n  // int()をオーバーロードすることで重み付きグラフと普通のグラフでライブラリを共用できる\n  operator int() const { return to; } // v[e]とできる ( v[e.to]に同じ )\n\n};\n\n// sort用 とりあえずcostの小さいほうが左としているが適宜書き換えて使いましょう\n/**\ntemplate<typename T>\nbool operator <(const edge<T>& e1,const edge<T>& e2){ \n  return e1.cost < e2.cost;\n}//*/\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WG = vector< Edges< T > >;\ntemplate< typename T>\nusing UWG = vector< vector <int> >;\n\n// Union-Find木\n// 初期化 UF(N); Nは要素数\n// 結合 unite(x,y); 同じ集合か判定 same(x,y);\n// 集合の数 count\nstruct UF{\n  vector<int> par,sizes;\n  int cnt;\n  UF(int N) : par(N),sizes(N, 1),cnt(N){ for(int i=0; i<N; i++) par[i]=i; }\n\n  int find(int x){ return par[x]==x ? x : par[x] = find(par[x]); }\n\n  bool same(int x,int y){ return find(x) == find(y); }\n\n  int size(int x){ return sizes[find(x)]; }\n\n  void unite(int x, int y){\n    x = find(x); y = find(y);\n    if(x == y) return;\n    if(sizes[x] < sizes[y]) swap(x,y);\n    par[y] = x;\n    sizes[x] += sizes[y];\n    cnt--;\n  }\n  \n  int count() const{return cnt;}\n};\n\nvoid solve(){\n  ini(N , H , W);\n  UF uf(H + W);\n  Edges<ll> es;\n  rep(i , N){\n    ini(h , w , c); h--; w--;\n    es.eb(h , w + H , c);\n  }\n\n  sort(all(es) , [](edge<ll> &a,edge<ll> &b){\n    return a.cost > b.cost;\n  });\n\n  vi cnt(H + W , 0);\n  ll ans = 0;\n  each(e , es){\n    int a = e.src , b = e.to;\n    int sn , en;\n    sn = uf.size(a) , en = cnt[uf.find(a)];\n    if(!uf.same(a , b)) sn += uf.size(b) , en += cnt[uf.find(b)];\n    if(sn > en){\n      cnt[uf.find(a)] = cnt[uf.find(b)] = 0;\n      uf.unite(a , b);\n      cnt[uf.find(a)] = en + 1;\n      ans += e.cost;\n    }\n  }\n  out(ans);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define ll long long\n#define fornum(A,B,C) for(A=B;A<C;A++)\n#define mp make_pair\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n\nusing namespace std;\n\n/////////////////////////////////////////////////////\n#define MOD (ll)(1e9+7)\n\nstruct UnionFind{\n    vector<int> nxt;\n    void init(int x){\n        nxt.clear();\n        nxt.resize(x);\n        for (int i = 0; i < x;i++){\n            nxt[i] = i;\n        }\n    }\n    int find(int x){\n        if(nxt[x]==x)\n            return x;\n        return nxt[x] =find(nxt[x]);\n    }\n    inline void unite(int x,int y){\n        nxt[find(y)] = find(x);\n    }\n};\n\n\n\nll N,H,W;\nvector<pair<ll, pll>> arcs;\nUnionFind uf;\nll vn[202020],en[202020];\nll i, j,k,ans;\nint main(){\n    scanf(\"%lld%lld%lld\", &N,&H,&W);\n    fornum(i,0,N){\n        ll r, c, a;\n        scanf(\"%lld%lld%lld\", &r, &c, &a);\n        arcs.push_back({a,{r, c}});\n    }\n    sort(arcs.begin(), arcs.end());\n    uf.init(H + W);\n    fornum(i,0,H+W){\n        vn[i] = 1;\n    }\n    fornum(i,0,N){\n        //printf(\"%lld:%lld\\n\", i, ans);\n        auto arc = arcs[N - 1 - i];\n        auto a = arc.first;\n        auto r = arc.second.first-1;\n        auto c = arc.second.second - 1 + H;\n        ll vvn = vn[uf.find(r)];\n        ll een = en[uf.find(r)] + 1;\n        if(uf.find(r)!=uf.find(c)){\n            vvn += vn[uf.find(c)];\n            een += en[uf.find(c)];\n        }\n        if(vvn>=een){\n            uf.unite(r, c);\n            vn[uf.find(r)] = vvn;\n            en[uf.find(r)] = een;\n            ans += a;\n        }\n    }\n    printf(\"%lld\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint n,R,C;\nint p[200000],f[200000];\nint find(int u){\n\tif(p[u]==u)\n\t\treturn u;\n\treturn p[u]=find(p[u]);\n}\nint main(){\n\tscanf(\"%d%d%d\",&n,&R,&C);\n\tvector<vector<int> > v(n,vector<int>(3));\n\tfor(auto &x:v){\n\t\tfor(auto &y:x)\n\t\t\tscanf(\"%d\",&y);\n\t\tswap(x[0],x[2]);\n\t\tswap(x[1],x[2]);\n\t}\n\tsort(v.rbegin(),v.rend());\n\tll res=0;\n\tfor(int i=0;i<R+C;++i)\n\t\tp[i]=i;\n\tfor(auto &e:v){\n\t\tint u=e[1]-1;\n\t\tint v=e[2]-1+R;\n\t\tu=find(u);\n\t\tv=find(v);\n\t\tif(u!=v && f[u]+f[v]<2){\n\t\t\tres+=e[0];\n\t\t\tp[u]=v;\n\t\t\tf[v]|=f[u];\n\t\t}else if(u==v && !f[u]){\n\t\t\tres+=e[0];\n\t\t\tf[u]=true;\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){\n\treturn o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";\n}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){\n\to<<\"{\";\n\tfor(const T& v:vc) o<<v<<\",\";\n\to<<\"}\";\n\treturn o;\n}\nusing ll = long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T> using VV = vector<vector<T>>;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\n#ifdef LOCAL\n#define show(x) cerr << \"LINE\" << __LINE__ << \" : \" << #x << \" = \" << (x) << endl\n#else\n#define show(x) true\n#endif\nstruct UnionFind{\n\tvector<int> par,rank,szv,sze;\n\tUnionFind(int N){\n\t\tpar.assign(N,0);\n\t\trank.assign(N,0);\n\t\tszv.assign(N,1);\n\t\tsze.assign(N,0);\n\t\trep(i,N) par[i]=i;\n\t}\n\tint find(int x){\n\t\tif(par[x]==x) return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n\tvoid unite(int x,int y){\n//\t\tcerr << \"unite \" << x << \", \" << y << endl;\n\t\tx=find(x),y=find(y);\n\t\tsze[x]++;\n\t\tif(x==y) return;\n\t\tif(rank[x]<rank[y]) swap(x,y);\n\n\t\t//x becomes root\n\t\tpar[y]=x;\n\t\tszv[x] += szv[y];\n\t\tsze[x] += sze[y];\n\t\tif(rank[x]==rank[y]) rank[x]++;\n\t}\n};\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\t\t//DON'T USE scanf/printf/puts !!\n\tcout << fixed << setprecision(20);\n\t\n\tint N,H,W;\n\tcin >> N >> H >> W;\n\n\tUnionFind UF(H+W);\n\tVV<int> a(N);\n\trep(i,N){\n\t\tint x,y,c;\n\t\tcin >> x >> y >> c;\n\t\tx--,y--;\n\t\ta[i] = {c,x,y};\n\t}\n\tsort(all(a),greater<V<int>>());\n\tll ans = 0;\n\trep(i,N){\n\t\tint x = a[i][1], y = a[i][2], c = a[i][0];\n\t\tshow(i);\n\t\tshow(c);\n\t\ty += H;\n\t\tif(UF.same(x,y)){\n\t\t\tint r = UF.find(x);\n\t\t\tif(UF.szv[r] != UF.sze[r]){\n\t\t\t\tUF.unite(x,y);\n\t\t\t\tans += c;\n\t\t\t}\n\t\t}else{\n\t\t\tint rx = UF.find(x), ry = UF.find(y);\n\t\t\tif(UF.szv[rx] + UF.szv[ry] >= UF.sze[rx] + UF.sze[ry] + 1){\n\t\t\t\tUF.unite(x,y);\n\t\t\t\tans += c;\n\t\t\t}\n\t\t}\n\t\tshow(ans);\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T> using greater_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\ntemplate<typename T>\nstruct edge {\n  int from, to;\n  T cost;\n\n  edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n\n  edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n\n  operator int() const { return to; }\n\n  bool operator<(const edge<T> &e) const {\n    return cost < e.cost;\n  }\n};\n\ntemplate<typename T> using Edges = vector<edge<T>>;\ntemplate<typename T> using WeightedGraph = vector<vector<edge<T>>>;\n\nvoid solve() {\n  int n, h, w; cin >> n >> h >> w;\n  vector<multiset<edge<int>>> g(h+w);\n  rep(_,n) {\n    int r, c, a; cin >> r >> c >> a;\n    --r, c += h-1;\n    g[r].emplace(r, c, a);\n    g[c].emplace(r, c, a);\n  }\n\n  vb seen(h+w, false);\n  ll ans = 0;\n\n  rep(i,h+w) {\n    if (!seen[i]) {\n      seen[i] = true;\n      priority_queue<edge<int>> pq;\n      for (auto &e : g[i]) pq.emplace(e);\n      while (!pq.empty()) {\n        auto card = pq.top(); pq.pop();\n        ans += card.cost;\n        g[card.from].erase(g[card.from].find(card));\n        g[card.to].erase(g[card.to].find(card));\n        if (!seen[card.from]) {\n          seen[card.from] = true;\n          for (auto &e : g[card.from]) {\n            if (!seen[e.to]) pq.emplace(e);\n          }\n        } else if (!seen[card.to]) {\n          seen[card.to] = true;\n          for (auto &e : g[card.to]) {\n            if (!seen[e.from]) pq.emplace(e);\n          }\n        } else break;\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n//#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int mod = 1e9 + 7;\nconst int N = 200005;\nconst int K = 25;\nint p[N], sz[N], used[N];\nint gt(int x){\n    if (p[x] == x) return x;\n    return p[x] = gt(p[x]);\n}\nvoid unite(int x, int y){\n    x = gt(x);\n    y = gt(y);\n    if (sz[x] < sz[y]) swap(x, y);\n    p[y] = x;\n    sz[x] += sz[y];\n    used[x] |= used[y];\n}\nvector < pair < int, pair < int, int > > > a;\nmain(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    //freopen(\"input.txt\", \"r\", stdin);\n    int n, h, w;\n    cin >> n >> h >> w;\n    for (int i = 1; i <= n; i++){\n        int u, v, w;\n        cin >> u >> v >> w;\n        a.pb({w, {u, v + h}});\n    }\n    sort(a.begin(), a.end());\n    reverse(a.begin(), a.end());\n    for (int i = 1; i <= h + w; i++){\n        p[i] = i;\n        sz[i] = 1;\n    }\n    int ans = 0;\n    for (auto i: a){\n        int u = i.S.F;\n        int v = i.S.S;\n        int w = i.F;\n        u = gt(u);\n        v = gt(v);\n        if (u == v){\n            if (!used[v]){\n                ans += w;\n                used[v] = 1;\n            }\n        } else{\n            if (used[u] && used[v]) continue;\n            unite(u, v);\n            ans += w;\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define mp(a,b) make_pair(a,b)\n#define ff first\n#define setp(a) setprecision(a)<<fixed\n#define ss second\n#define fori(v) for(ll i=0; i<v; i++)\n#define forj(v) for(ll j=0; j<v; j++)\n#define fork(v) for(ll k=0; k<v; k++)\n#define forl(v) for(ll l=0; l<v; l++)\n#define fort(v) for(ll t=0; t<v; t++)\n#define forz(v) for(ll z=0; z<v; z++)\n#define forx(v) for(ll x=0; x<v; x++)\n#define fory(v) for(ll y=0; y<v; y++)\n#define ll long long\n#define pb(a) push_back(a)\ntypedef long double ld;\ntypedef complex<ld> pt;\ntypedef vector<pt> pol;\ntypedef vector<ll> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ld> vd;\ntypedef vector<vd> vvd;\ntypedef pair<ll, ll> pii;\ntypedef vector<pii> vpii;\nconst ll INF = 0x3f3f3f3f;\nconst ll inf =  pow(10,18);\nll modulo = pow(10,9) + 7;\n#define MAX (int)(pow(10,5) + 10)\n\n\nnamespace dsu{\n\tint aid[MAX];\n\tvector<int> dsu[MAX];\n\tset<ll>  cols[MAX];\t// set of active columns for each component\n\tll aidc[MAX];\t\t// the component of ith column\n\tll dubl[MAX];\n\tvoid ini(int n){\n\t\tfori(n)\n\t\t\tdubl[i] = 0, aid[i] = i, dsu[i].clear(), dsu[i].push_back(i), cols[i].clear(), aidc[i] = -1;\n\t}\n\tbool join(int a,int b){  //\t1 - if joined, 0 - if they were already joined \n\t\tint aid1 = aid[a], aid2 = aid[b];\n\t\tif(dsu[aid2].size() > dsu[aid1].size())\n\t\t\tswap(aid1,aid2);\n\t\tif(aid1==aid2)\n\t\t\treturn 0;\n\t\tdubl[aid1] |= dubl[aid2];\n\t\tfor(auto hd : dsu[aid2]){\n\t\t\taid[hd] = aid1;\n\t\t\tdsu[aid1].push_back(hd);\n\t\t}\n\t\tfor(auto hd : cols[aid2]){\n\t\t\taidc[hd] = aid1;\n\t\t\tcols[aid1].insert(hd);\n\t\t}\n\t\tcols[aid2].clear();\n\t\tdsu[aid2].clear();\n\t\treturn 1;\n\t}\n};\n\nvoid deal(){\n\tll n , w, h;\n\tcin>>n>>w>>h;\n\tdsu::ini(MAX);\n\tvector<vector<ll> > all;\n\tfori(n){\n\t\tll r, c, ai;\n\t\tcin>>r>>c>>ai;\n\t\t--r, --c;\n\t\tall.pb(vector<ll> ({ai, r,c} ) );\n\t}\n\tsort(all.rbegin(), all.rend());\n\tmap<ll,map<ll,ll> > picked;\n\tll ans= 0;\n\tfori(n){\n\t\tll r = all[i][1], c = all[i][2];\n//\t\tcout<<\"!! we at \"<<r<<\" \"<<c<<endl;\n\t\tif(dsu::aidc[c] == -1){\n\t\t\tll cmp =  dsu::aid[r];\n\t\t\tdsu::aidc[c] = cmp;\n\t\t\tdsu::cols[cmp].insert(c);\n\t\t\tpicked[r][c]++;\n\t\t\tans+=all[i][0];\n\t\t}\n\t\telse if( picked[r][c] && (dsu::dubl[dsu::aid[r]] || dsu::dubl[dsu::aidc[c]]) ){\n//\t\t\tcout<<\"we didnt pick \"<<r<<\" \"<<c<<\" bicuz  count : \"<<picked[r][c] <<\" \"<<dsu::dubl[dsu::aid[r]]<<\" \"<<dsu::dubl[dsu::aidc[c]]<<endl;\n\t\t\tcontinue;\n\t\t}\n\t\telse if(picked[r][c]){\n\t\t\tdsu::dubl[dsu::aid[r]] = 1;\n\t\t\tdsu::dubl[dsu::aidc[c]] = 1;\n\t\t\tans+=all[i][0];\n\t\t}\n\t\telse{\n\t\t\tll cmp1 = dsu::aidc[c], cmp2 = dsu::aid[r];\n\t\t\tif(cmp1 == cmp2 || (dsu::dubl[cmp1] && dsu::dubl[cmp2]) ){\n\t\t//\t\tcout<<\"we didnt pick it cuz same component \"<<endl;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpicked[r][c] = 1;\n\t\t\tdsu::join(cmp1, cmp2);\n\t\t\tans+=all[i][0];\n\t\t}\n\t}\n\tcout<<ans;\n}\n\nint main() {\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\tdeal();\n}    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<set>\n#include<bitset>\n#include<ctime>\nusing namespace std;\n#define int long long\n#define mod 1000000009\n#define inf 4444444444444444444\n#define mn 200005\n#define pii pair <int, int>\n#define XX first\n#define YY second\n\nvector <int> alist[mn];\npair <int, pii> C[mn];\n\nint MX[mn], passed[mn];\nbool maxMatching(int u, int clr)\n{\n\tif (passed[u]==clr) return 0;\n\tpassed[u]=clr;\n\tfor (int v:alist[u])\n\t{\n\t\tif (MX[v]==0) \n\t\t{\n\t\t\tMX[v]=u;\n\t\t\treturn 1;\n\t\t}\n\t\telse if (maxMatching(MX[v], clr)==1)\n\t\t{\n\t\t\tMX[v]=u;\n\t\t\treturn 1;\n\t\t}\n\t}\n\treturn 0;\n}\n\nsigned main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tsrand(time(0));\n\t\n\tint n, h, w;\n\tcin>>n>>h>>w;\n\tint r, c, a;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tcin>>r>>c>>a;\n\t\tC[i]={a, {r, c}};\n\t}\n\tsort(C+1, C+n+1);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\talist[i].push_back(C[i].YY.XX);\n\t\talist[i].push_back(C[i].YY.YY+100000);\n\t\t\n\t\trandom_shuffle(alist[i].begin(), alist[i].end());\n\t}\n\t\n\tint ans=0;\n\tfor (int i=n; i>=1; i--) if (maxMatching(i, i)) ans+=C[i].XX;\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "//{{{\n#include<algorithm>\n#include<cmath>\n#include<deque>\n#include<fstream>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<random>\n#include<set>\n#include<sstream>\n#include<sys/time.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\nusing ll = long long;\nenum : int { M = (int)1e9 + 7 };\nenum : ll { MLL = (ll)1e18L + 9 };\nusing namespace std;\n#ifdef LOCAL\n#include\"rprint2.hpp\"\n#else\n#define FUNC(name) template <ostream& out = cout, class... T> void name(T&&...){ }\nFUNC(printde) FUNC(printdbe) FUNC(printdwe) FUNC(printdu);\n#endif\ntemplate <template <class T, class = std::allocator<T>> class V, class E>\nistream& operator >> (istream& in, V<E>& v){ for(auto& e : v){ in >> e; } return in; }\n//}}}\n\nstruct Stuple {\n    int first; int second; int third;\n    Stuple() = default;\n    Stuple(int first, int second, int third): first(first), second(second), third(third){ }\n    operator tuple<int, int, int> () const { return make_tuple(first, second, third); }\n    bool operator < (const Stuple& e) const { return tie(first, second, third) < tie(e.first, e.second, e.third); }\n    // ostream& operator >> (ostream& out) const { prints(tie(first, second, third)); return out; }\n};\n\nstruct UnionFind {\n\tvector<Stuple> elems;\n\t// vector<pair<int, int>> elems;\n\tUnionFind(int n):elems(n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\telems[i].first = i;\n\t\t\telems[i].second = 1;\n\t\t\telems[i].third = 0;\n\t\t}\n\t}\n\tbool same(int a, int b){\n\t\treturn parent(a) == parent(b);\n\t}\n\tvoid unite(int a, int b){\n\t\tif(elems[parent(a)].first == parent(b)){ return; }\n\t\tint sum = getSum(a) + getSum(b);\n\t\tint sum2 = getSum2(a) + getSum2(b);\n\t\t//cout<<\"sum \"<<sum<<endl;\n\t\telems[parent(a)].first = parent(b);\n\t\telems[parent(b)].second = sum;\n\t\telems[parent(b)].third = sum2;\n\t}\n\tint getSum(int a){\n\t\tif(a == elems[a].first){\n\t\t\treturn elems[a].second;\n\t\t}\n\t\treturn getSum(elems[a].first);\n\t}\n\n\tint getSum2(int a){\n\t\tif(a == elems[a].first){\n            return elems[a].third;\n\t\t}\n\t\treturn getSum2(elems[a].first);\n\t}\n\tvoid addSum2(int a){\n\t\tif(a == elems[a].first){\n\t\t\telems[a].third++;\n\t\t}else{\n            addSum2(elems[a].first);\n        }\n\t}\nprivate:\n\tint parent(int a){\n\t\tif(a == elems[a].first){\n\t\t\treturn a;\n\t\t}\n\t\treturn elems[a].first = parent(elems[a].first);\n\t}\n};\n\nint main(){\n    cin.tie(0); ios::sync_with_stdio(false);\n    int n, h, w;\n    cin >> n >> h >> w;\n    vector<int> rs(n), cs(n), as(n);\n    for(int i = 0; i < n; i++){\n        cin >> rs[i] >> cs[i] >> as[i];\n    }\n    vector<int> is(n);\n    iota(is.begin(), is.end(), 0);\n    sort(is.rbegin(), is.rend(), [&](int i, int j){ return as[i] < as[j]; });\n    UnionFind uf(h + w + 2);\n    ll ans = 0;\n    for(auto& i : is){\n        int r = rs[i], c = cs[i], a = as[i];\n        uf.unite(r, h + 1 + c);\n        printde(i, a, r, c, uf.getSum(r), uf.getSum2(r));\n        if(uf.getSum(r) > uf.getSum2(r)){\n            // printde(ans, i, a);\n            uf.addSum2(r);\n            ans += a;\n            printde(ans, r, c);\n        }\n    }\n    cout << ans << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = (int)(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\n#define dump(x) cerr << #x \" = \" << x << endl\nusing ll = long long;\nusing namespace std;\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class U> inline void chmax(T & a, U const & b) { a = max<T>(a, b); }\ntemplate <class T, class U> inline void chmin(T & a, U const & b) { a = min<T>(a, b); }\ntemplate <typename X, typename T> auto make_vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto make_vectors(X x, Y y, Z z, Zs... zs) { auto cont = make_vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\ntemplate <typename T> ostream & operator << (ostream & out, vector<T> const & xs) { REP (i, (int)xs.size() - 1) out << xs[i] << ' '; if (not xs.empty()) out << xs.back(); return out; }\ntemplate<typename Functor> struct fix_type { Functor functor; template<typename... Args> decltype(auto) operator() (Args && ... args) const & { return functor(functor, std::forward<Args>(args)...); } };\ntemplate<typename Functor> fix_type<typename std::decay<Functor>::type> fix(Functor && functor) { return { std::forward<Functor>(functor) }; }\n\nll solve(int n, int h, int w, const vector<int> & y, const vector<int> & x, const vector<ll> & a) {\n    vector<int> row(h, -1), col(w, -1);\n    unordered_set<int> used_row, used_col;\n    function<bool (int, int)> go_row, go_col;\n    go_row = [&](int y, int i) {\n        if (used_row.count(y)) return false;\n        used_row.insert(y);\n        if (row[y] == -1) {\n            row[y] = i;\n            return true;\n        } else {\n            int j = row[y];\n            bool p = go_col(x[j], j);\n            if (p) row[y] = i;\n            return p;\n        }\n    };\n    go_col = [&](int x, int i) {\n        if (used_col.count(x)) return false;\n        used_col.insert(x);\n        if (col[x] == -1) {\n            col[x] = i;\n            return true;\n        } else {\n            int j = col[x];\n            bool p = go_row(y[j], j);\n            if (p) col[x] = i;\n            return p;\n        }\n    };\n\n    ll answer = 0;\n\n    vector<int> order(n);\n    iota(ALL(order), 0);\n    sort(ALL(order), [&](int i, int j) { return a[i] > a[j]; });\n    for (int i : order) {\n        if (go_row(y[i], i)) {\n            row[y[i]] = i;\n            answer += a[i];\n            used_row.clear();\n            used_col.clear();\n        } else if (go_col(x[i], i)) {\n            col[x[i]] = i;\n            answer += a[i];\n            used_row.clear();\n            used_col.clear();\n        }\n    }\n    return answer;\n}\n\nint main() {\n    int n, h, w; cin >> n >> h >> w;\n    vector<int> y(n), x(n);\n    vector<ll> a(n);\n    REP (i, n) {\n        cin >> y[i] >> x[i] >> a[i];\n        -- y[i];\n        -- x[i];\n    }\n    cout << solve(n, h, w, y, x, a) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define mod998 998244353\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\nint N, H, W, R[100000], C[100000], A[100000], t[200000];\nbool used[200000];\nvector<int>v[200000];\nset<pair<int, int>>st;\npriority_queue<pair<int, pair<int, int>>>pq[200000];\nll res;\n\nint p(int x) {\n\tif (t[x] < 0)return x;\n\treturn t[x] = p(t[x]);\n}\n\nvoid u(int x, int y) {\n\tx = p(x);\n\ty = p(y);\n\tif (x == y)return;\n\tif (t[x] < t[y]) {\n\t\tt[x] += t[y];\n\t\tt[y] = x;\n\t}\n\telse {\n\t\tt[y] += t[x];\n\t\tt[x] = y;\n\t}\n}\n\nint main() {\n\tcin >> N >> H >> W;\n\tfor (int i = 0; i < 200000; ++i) {\n\t\tt[i] = -1;\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> R[i] >> C[i] >> A[i];\n\t\t--R[i];\n\t\t--C[i];\n\t\tu(R[i], C[i] + 100000);\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tpq[p(R[i])].push(mkp(A[i], mkp(R[i], C[i] + 100000)));\n\t}\n\tfor (int i = 0; i < 200000; ++i) {\n\t\tif (t[i] < -1) {\n\t\t\tint c = 0;\n\t\t\twhile (c < -t[i] && !pq[i].empty()) {\n\t\t\t\tint x = pq[i].top().second.first;\n\t\t\t\tint y = pq[i].top().second.second;\n\t\t\t\tint s = pq[i].top().first;\n\t\t\t\tpq[i].pop();\n\t\t\t\tfor (int j : v[x]) {\n\t\t\t\t\tif (used[j]) {\n\t\t\t\t\t\tused[x] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor (int j : v[y]) {\n\t\t\t\t\tif (used[j]) {\n\t\t\t\t\t\tused[y] = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (used[x] && used[y]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (used[x]) {\n\t\t\t\t\tused[y] = true;\n\t\t\t\t\tres += s;\n\t\t\t\t}\n\t\t\t\telse if (used[y]) {\n\t\t\t\t\tused[x] = true;\n\t\t\t\t\tres += s;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv[x].push_back(y);\n\t\t\t\t\tv[y].push_back(x);\n\t\t\t\t\tres += s;\n\t\t\t\t\tif (!st.insert(mkp(x, y)).second) {\n\t\t\t\t\t\tused[x] = used[y] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++c;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define MOD 1000000007\ntemplate<typename ty1,typename ty2>\ninline int add(ty1 x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x += y; return x < MOD ? x : x - MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline void addto(ty1 &x, ty2 y) {\n\t\t  if(y>=MOD)y%=MOD;\n\t\t  if(x>=MOD)x%=MOD;\n\t      x += y; if (x >= MOD) x -= MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int sub(ty1 x, ty2 y) {\n\t\tif(y>=MOD)y%=MOD;\n\t\t if(x>=MOD)x%=MOD;\n        x -= y; return x < 0 ? x + MOD : x;\n}\ntemplate<typename ty1,typename ty2>\ninline void subto(ty1 &x, ty2 y) {\n\tif(y>=MOD)y%=MOD;\n\tif(x>=MOD)x%=MOD;\n    x -= y; if (x < 0) x += MOD;\n}\ntemplate<typename ty1,typename ty2>\ninline int mul(ty1 x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        return 1ll * x * y % MOD;\n}\ntemplate<typename ty1,typename ty2>\nvoid multo(ty1 &x, ty2 y) {\n        if(y>=MOD)y%=MOD;\n\t\tif(x>=MOD)x%=MOD;\n        x=1ll * x * y % MOD;\n}\n\n#define MAX 100002\n\nint n;\nint h;\nint w;\n\nstruct UF{\n\tvector<int> belong;\n\tvector<int> size;\n\tvector<int> ed;\n\tvoid resize(int n){\n\t\tbelong.assign(n + 1, -1);\n\t\tsize.assign(n + 1, 1);\n\t\ted.assign(n+1,0);\n\t}\n\tinline int root(int b){\n\t\tif (belong[b] == -1){\n\t\t\treturn b;\n\t\t}\n\t\tbelong[b] = root(belong[b]);\n\t\treturn belong[b];\n\t}\n\tvoid merge(int a, int b){\n\t\ta = root(a);\n\t\tb = root(b);\n\t\tif (a == b)return;\n\t\tbelong[a] = b;\n\t\tsize[b] += size[a];\n\t\ted[b]+=ed[a];\n\t}\n};\n\nvector<pair<int,pair<int,int> > > v;\n\nint main(){\n\tcin>>n>>h>>w;\n\tfor(int i=0;i<n;i++){\n\t\tint r,c,a;\n\t\tscanf(\"%d%d%d\",&r,&c,&a);\n\t\tr--;\n\t\tc--;\n\t\tc+=h;\n\t\tv.push_back(make_pair(a,make_pair(r,c)));\n\t}\n\tUF uf;\n\tuf.resize(h+w);\n\t\n\tsort(v.begin(),v.end());\n\treverse(v.begin(),v.end());\n\tlong long int ans=0;\n\tfor(int i=0;i<v.size();i++){\n\t\tint a=v[i].second.first;\n\t\tint b=v[i].second.second;\n\t\tif(uf.root(a)!=uf.root(b)){\n\t\t\tint sz=uf.size[uf.root(a)]+uf.size[uf.root(b)];\n\t\t\tint eg=uf.ed[uf.root(a)]+uf.ed[uf.root(b)];\n\t\t\teg++;\n\t\t\tif(sz>=eg){\n\t\t\t\tuf.merge(a,b);\n\t\t\t\tuf.ed[uf.root(a)]++;\n\t\t\t\tans+=v[i].first;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tint sz=uf.size[uf.root(a)];\n\t\tint eg=uf.ed[uf.root(a)];\n\t\tif(sz>=eg+1){\n\t\t\tuf.ed[uf.root(a)]++;\n\t\t\tans+=v[i].first;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <math.h>\n#include <iomanip>\n#include <limits>\n#include <list>\n#include <queue>\n#include <tuple>\n#include <map>\n#include <stack>\n#include <set>\nusing namespace std;\n#define MOD (long long int)(1e9+7)\n#define ll long long int\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define reps(i,n) for(int i=1; i<=(int)(n); i++)\n#define REP(i,n) for(int i=n-1; i>=0; i--)\n#define REPS(i,n) for(int i=n; i>0; i--)\n#define INF (int)(1123456789)\n#define LINF (long long int)(112345678901234567)\n#define chmax(a, b) a = (((a)<(b)) ? (b) : (a))\n#define chmin(a, b) a = (((a)>(b)) ? (b) : (a))\n#define all(v) v.begin(), v.end()\n\nconst int N = (int)3e5;\n\nll mpow(ll a, ll b){\n\tif(b==0) return 1;\n\telse if(b%2==0){ll memo = mpow(a,b/2); return memo*memo%MOD;}\n\telse return mpow(a,b-1) * a % MOD;\n}\nll gcd(ll a, ll b){\n\tif(b==0) return a;\n\telse return gcd(b, a%b);\n}\nvector<ll> kaijo_memo;\nll kaijo(ll n){\n\tif(kaijo_memo.size() > n) return kaijo_memo[n];\n\tif(kaijo_memo.size() == 0) kaijo_memo.push_back(1);\n\twhile(kaijo_memo.size() <= n) kaijo_memo.push_back(kaijo_memo[kaijo_memo.size()-1] * kaijo_memo.size() % MOD);\n\treturn kaijo_memo[n];\n}\nll nCr(ll n, ll r){\n\tif(n < r || r < 0) return 0;\n\tll ret = 1;\n\tret *= kaijo(n); ret %= MOD;\n\tret *= mpow(kaijo(r), MOD-2); ret %= MOD;\n\tret *= mpow(kaijo(n-r), MOD-2); ret %= MOD;\n\treturn ret;\n}\n\nstruct node{ll r,c,a,id;};\nvector<int> parent;\nvector<int> size;\nvector<int> retu;\n\nint find(int a){\n\tif(parent[a] == a){\n\t\treturn a;\n\t}else{\n\t\treturn parent[a] = find(parent[a]);\n\t}\n}\n\nvoid unite(int a, int b){\n\tint pa = find(a), pb = find(b);\n\tif(pa == pb) return;\n\tsize[pa] += size[pb];\n\tretu[pa] += retu[pb] - 1;\n\tparent[pb] = pa;\n}\n\nint main(void){\n\tll n,h,w;cin>>n>>h>>w;\n\trep(i,n){\n\t\tparent.push_back(i);\n\t\tsize.push_back(1);\n\t\tretu.push_back(2);\n\t}\n\tvector<node> node_a, node_c, node_r;\n\trep(i,n){\n\t\tll r,c,a;\n\t\tcin>>r>>c>>a;\n\t\tnode_a.push_back({r,c,a,-1});\n\t}\n\tsort(all(node_a), [](const node &x, const node &y){return x.a > y.a;});\n\trep(i,n){\n\t\tnode_a[i].id = i;\n\t}\n\n\tmap<int ,node> Y,X;\n\tcerr<<endl;\n\n\tll ans = 0;\n\trep(i, node_a.size()){\n\t\tnode next = node_a[i];\n\t\tll r = next.r;\n\t\tll c = next.c;\n\t\tll a = next.a;\n\n\t\tnode ny,nx;\n\t\tif(Y.count(r) > 0){\n\t\t\tny = Y[r];\n\t\t}else{\n\t\t\tny = next;\n\t\t}\n\t\tif(X.count(c) > 0){\n\t\t\tnx = X[c];\n\t\t}else{\n\t\t\tnx = next;\n\t\t}\n\t\tcerr<<ny.id<<\" \"<<nx.id<<\" \"<<next.r<<\" \"<<next.c<<\" \"<<size[ny.id]<<\" \"<<size[nx.id]<<endl;;\n\t\tif(find(ny.id) == find(nx.id) && find(ny.id) != next.id){//同一と合体\n\t\t\tif(size[find(ny.id)] + size[next.id] > retu[find(ny.id)]) continue;\n\t\t}\n\t\tif(find(ny.id) != find(nx.id) && find(ny.id) != next.id && find(nx.id) != next.id){//2つと合体\n\t\t\tif(size[find(ny.id)] + size[find(nx.id)] + 1 > retu[find(ny.id)] + retu[find(nx.id)]) continue;\n\t\t}\n\n\t\tbool douitu = find(ny.id) == find(nx.id) && find(ny.id) != next.id;\n\n\t\tunite(next.id, nx.id);\n\t\tunite(next.id, ny.id);\n\t\tif(douitu){\n\t\t\tretu[find(next.id)]--;\n\t\t}\n\t\tans += next.a;\n\t\tY[r] = next;\n\t\tX[c] = next;\n\t\tcerr<<next.r<<\",\"<<next.c<<\": \"<<size[find(next.id)]<<\" \"<<retu[find(next.id)]<<endl;\n\t}\n\tcerr<<endl;\n\tcout<<ans<<endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define int ll\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector< vi > vvi;\ntypedef vector< vvi > vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef RUS_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate <class T0, class T1>\ninline ostream & operator << (ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate <class T0, class T1>\ninline istream & operator >> (istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate <class T0, class T1, class T2>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate <class T0, class T1, class T2, class T3>\ninline ostream & operator << (ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" <<  get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream & operator << (ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())\n        out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n#ifdef RUS_HOME\n    freopen(\"input\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef RUS_HOME\n    cout << \"\\n\\n\\n\\nTOTAL EXECUTION TIME: \" << float( clock () - start ) /  CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int MOD=1e9+7,N=2e5+100;\n\nmultiset<int>st[N];\nvi kek[N];\nint par[N],cnt[N];\nll ans=0;\n\nvoid merge(int a,int b,int cost){\n    a=par[a];\n    b=par[b];\n    if(a!=b){\n        if(cnt[a]<cnt[b]){\n            swap(a,b);\n        }\n        for(auto p:st[b]){\n            st[a].insert(p);\n        }\n        for(auto p:kek[b]){\n            par[p]=a;\n            kek[a].push_back(p);\n        }\n        cnt[a]=SZ(kek[a]);\n        while(SZ(st[a])>cnt[a]){\n            ans-=*st[a].begin();\n            st[a].erase(st[a].begin());\n        }\n    }\n\n    st[a].insert(cost);\n    ans+=cost;\n    while(SZ(st[a])>cnt[a]){\n        ans-=*st[a].begin();\n        st[a].erase(st[a].begin());\n    }\n}\n\n\nvoid smain() {\n\n    int n,h,w;\n    cin>>n>>h>>w;\n    vector<pair<int,pii>>v(n);\n    for(int i=0;i<n;i++){\n        int r,c,w;\n        cin>>r>>c>>w;\n        v[i]={w,{r,c+h}};\n    }\n    sort(RALL(v));\n    for(int i=1;i<=h+w;i++){\n        par[i]=i;\n        kek[i].push_back(i);\n        cnt[i]=1;\n    }\n\n    for(auto p:v){\n        merge(p.second.first,p.second.second,p.first);\n    }\n\n    cout<<ans;\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define f first\n#define s second\n#define all(a) a.begin(), a.end()\n#define rall(a) a.rbegin(), a.rend()\n#define ll long long\n#define ull unsigned long long\n#define db double\n#define ld long double\n#define pii pair<int, int>\n#define pll pair<ll, ll>\n#define pli pair<ll, int>\n#define px pair<db, db>\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define input(a) for (auto& el : a) cin >> el;\n#define output(a) cout << '!'; for (auto& el : a) cout << el << ' '; cout << '\\n'; cout.flush();\n#define sz(el) int(el.size())\n#define sq(a) ((a) * (a))\n#define xll bitset<128>\n#define xmin(a,b) a = min(a, b)\n#define xmax(a,b) a = max(a, b)\n#define sun(a) sort(all(a)); a.resize(unique(all(a)) - a.begin());\n/**/  /// extra\n//#define forn(i,n) for (int i = 0; i < n; ++i)\n//#define rforn(i,n) for (int i = n - 1; i >= 0; --i)\n#define bn '\\n'\n#define vi vector<int>\n#define vii vector<vi>\n#define vl vector<ll>\n#define vll vector<vl>\n//#define G vector<vector<pii>>\n#define GVE vector<vector<edge>>\n#define usi unordered_set<int>\n#define usp set<pii>\n/**/\n\nusing namespace std;\n\nconst int INF = 1'000'000'017;\nconst ll LLINF = 1'000'000'000'000'000'017LL;\nconst ld inf = 1.0 / 0.0;\nconst ld eps = 1e-9;\nconst int MOD = 1e9 + 7;\n\n//mt19937_64 rng(chrono::high_resolution_clock::now().time_since_epoch().count());\n\n//uniform_int_distribution<int> uid(l, r); [l, r]\n//int x = uid(rng);\n\nstruct card {\n    int r, c, x;\n\n    bool operator<(const card& a) const {\n        return x < a.x;\n    }\n};\n\nstruct DSU {\n    vector<int> t, r;\n    vector<int> d;\n\n    DSU() {}\n\n    DSU(int n) : t(n), r(n, 1), d(n, 1) {\n        iota(all(t), 0);\n    }\n\n    int p(int v) {\n        return (t[v] == v ? v : (t[v] = p(t[v])));\n    }\n\n    bool unite(int u, int v) {\n        int pu = p(u), pv = p(v);\n        //cout << u << ' ' << v << ' ' << pu << ' ' << pv << endl;\n        if (pu == pv) {\n            if (d[pu]) {\n                d[pu] = 0;\n                return 1;\n            }\n            return 0;\n        }\n        if (!(d[pu] | d[pv])) {\n            return 0;\n        }\n        if (r[pu] > r[pv]) {\n            swap(pu, pv);\n        }\n        r[pv] += r[pu];\n        d[pv] &= d[pu];\n        t[pu] = pv;\n        return 1;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n, h, w;\n    cin >> n >> h >> w;\n    vector<card> a(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> a[i].r >> a[i].c >> a[i].x;\n    }\n    sort(rall(a));\n    DSU dsu(h + w + 1);\n    ll ans = 0;\n    for (card& el : a) {\n        ans += el.x * dsu.unite(el.r, h + el.c);\n    }\n    cout << ans;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <climits>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <numeric>\n#include <string>\n#include <tuple>\n\nclass disjoint_set {\npublic:\n  using size_type = size_t;\n\nprivate:\n  mutable std::vector<intmax_t> M_c;\n  mutable std::vector<size_t> M_e;\n\npublic:\n  disjoint_set() = default;\n  disjoint_set(disjoint_set const&) = default;\n  disjoint_set(disjoint_set&&) = default;\n\n  disjoint_set(size_t n): M_c(n, -1), M_e(n, 0) {}\n\n  disjoint_set& operator =(disjoint_set const&) = default;\n  disjoint_set& operator =(disjoint_set&&) = default;\n\n  void reset() { M_c.assign(M_c.size(), -1); }\n\n  size_type representative(size_type v) const {\n    if (M_c[v] < 0) return v;\n    return (M_c[v] = representative(M_c[v]));\n  }\n\n  bool unite(size_t u, size_t v) {\n    u = representative(u);\n    v = representative(v);\n    if (u == v) {\n      M_e[v] += 1;\n      return false;\n    }\n    if (-M_c[u] > -M_c[v]) std::swap(u, v);\n    M_c[v] += M_c[u];\n    M_c[u] = v;\n    M_e[v] += M_e[u] + 1;\n    return true;\n  }\n\n  bool equivalent(size_t u, size_t v) const {\n    return (representative(u) == representative(v));\n  }\n\n  size_type size() const noexcept { return M_c.size(); }\n  size_type size(size_type v) const {\n    return -M_c[representative(v)];\n  }\n\n  size_type edges(size_type v) const { return M_e[representative(v)]; }\n};\n\nint main() {\n  size_t n, h, w;\n  scanf(\"%zu %zu %zu\", &n, &h, &w);\n\n  using edge_type = std::tuple<intmax_t, size_t, size_t>;\n  std::vector<edge_type> es;\n  es.reserve(n);\n  for (size_t i = 0; i < n; ++i) {\n    size_t r, c;\n    intmax_t a;\n    scanf(\"%zu %zu %jd\", &r, &c, &a);\n    --r, --c;\n    es.emplace_back(a, r, h+c);\n  }\n  std::sort(es.rbegin(), es.rend());\n\n  disjoint_set ds(h+w);\n  intmax_t res = 0;\n  for (auto const& e: es) {\n    size_t r, c;\n    intmax_t a;\n    std::tie(a, r, c) = e;\n\n    if (ds.size(r) + ds.size(c) >= ds.edges(r) + ds.edges(c) + 1) {\n      res += a;\n      ds.unite(r, c);\n    }\n  }\n  printf(\"%jd\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=1e9;\nconst int MOD=1e9+7;\n//const int MOD=998244353;\nconst long long LINF=1e18;\n#define int long long\n//template\ntemplate <typename T>\nvoid fin(T a){\n  cout<<a<<endl;\n  exit(0);\n}\nstruct UnionFind{\n  int n,num;\n  vector<int> r,p,e;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),num(sz),e(sz,0),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) {e[x]++;return;}\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];e[x]+=e[y]+1;\n    p[y]=x;\n    num--;\n  }\n  int size(int x){  //頂点数\n    return r[find(x)];\n  }\n  int size2(int x){  //辺の数\n    return e[find(x)];\n  }\n  int count() const{\n    return num;\n  }\n};\n//main\nsigned main(){\n  int N,H,W;cin>>N>>H>>W;\n  typedef pair<int,int> P;\n  typedef pair<int,P> PP;\n  priority_queue<PP> que;\n  for(int i=0;i<N;i++){\n    int r,c,a;cin>>r>>c>>a;r--;c--;\n    que.push(PP(a,P(r,c+100000)));\n  }\n  int ans=0;\n  UnionFind uf(200000);\n  while(que.size()){\n    PP p=que.top();que.pop();\n    int a=p.first,u=p.second.first,v=p.second.second;\n    if(uf.same(u,v)){\n      if(uf.size2(u)<uf.size(v)){\n        uf.unite(u,v);\n        ans+=a;\n      }\n    }\n    else{\n      int p=uf.size(u)+uf.size(v);\n      int e=uf.size2(u)+uf.size2(v);\n      if(e<p){\n        uf.unite(u,v);\n        ans+=a;\n      }\n    }\n  }\n  cout<<ans<<endl;\n}\n\n/*\n解説AC\n重みでソートして貪欲にやるとダメなのは明らか\nでもよく考えると一番でかいのをr,c両方で取らないことも有り得ない\nと言うわけで解法は「でかいのから取れるなら取る、ただし必要に迫られるまでr,cのどちらで取るかは確定させない」になる\nあとはこれをどう実装するか\nrとcでグラフ作ると各連結成分ごとに点と辺の数の関係に持っていける\nこの言い換えが苦手なのでしっかりしとめる\n葉から順番に決めていくイメージのはず、新しいのを受け入れる為にみんなが場所を開けようとするイメージも\nフローとしての解釈も習ったのでそこも覚えておく\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// template {{{\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define mt make_tuple\n#define lb lower_bound\n#define ub upper_bound\n#define f first\n#define s second\n#define resz resize\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i, a, b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i, a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define sort_by(x, y) sort(all(x), [&](const auto& a, const auto& b) { return y; })\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing vb = vector<bool>;\nusing vd = vector<double>;\nusing vs = vector<string>;\n\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing pdd = pair<double, double>;\n\nusing vpii = vector<pii>;\nusing vvpii = vector<vpii>;\nusing vpll = vector<pll>;\nusing vvpll = vector<vpll>;\nusing vpdd = vector<pdd>;\nusing vvpdd = vector<vpdd>;\n\ntemplate<typename T> void ckmin(T& a, const T& b) { a = min(a, b); }\ntemplate<typename T> void ckmax(T& a, const T& b) { a = max(a, b); }\n\nmt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nnamespace __input {\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) {\n        re(first); re(rest...);\n    }\n\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\nusing namespace __input;\n\nnamespace __output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) {\n        pr(first); pr(rest...);\n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) {\n        pr(\"{\",x.f,\", \",x.s,\"}\");\n    }\n    template<class T, bool pretty = true> void prContain(const T& x) {\n        if (pretty) pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?pretty?\", \":\" \":\"\",a), fst = 0;\n        if (pretty) pr(\"}\");\n    }\n    template<class T> void pc(const T& x) { prContain<T, false>(x); pr(\"\\n\"); }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n\n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) {\n        pr(first); ps();\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) {\n        pr(first,\" \"); ps(rest...);\n    }\n}\nusing namespace __output;\n\n#define TRACE(x) x\n#define __pn(x) pr(#x, \" = \")\n#define pd(...) __pn((__VA_ARGS__)), ps(__VA_ARGS__), cout << flush\n\nnamespace __algorithm {\n    template<typename T> void dedup(vector<T>& v) {\n        sort(all(v)); v.erase(unique(all(v)), v.end());\n    }\n    template<typename T> typename vector<T>::iterator find(vector<T>& v, const T& x) {\n        auto it = lower_bound(all(v), x); return it != v.end() && *it == x ? it : v.end();\n    }\n    template<typename T> size_t index(vector<T>& v, const T& x) {\n        auto it = find(v, x); assert(it != v.end() && *it == x); return it - v.begin();\n    }\n\n    template<typename C, typename T> vector<T> prefixes(const C& v, T zero) {\n        vector<T> res(sz(v) + 1, zero); F0R (i, sz(v)) res[i+1] = res[i] + v[i]; return res;\n    }\n    template<typename C, typename T> vector<T> suffixes(const C& v, T zero) {\n        vector<T> res(sz(v) + 1, zero); F0Rd (i, sz(v)) res[i] = v[i] + res[i+1]; return res;\n    }\n}\nusing namespace __algorithm;\n\nstruct monostate {\n    friend istream& operator>>(istream& is, const __attribute__((unused))monostate& ms) { return is; }\n    friend ostream& operator<<(ostream& os, const __attribute__((unused))monostate& ms) { return os; }\n} ms;\n\ntemplate<typename W=monostate> struct wedge {\n    int u, v, i; W w;\n    wedge<W>(int _u=-1, int _v=-1, int _i=-1) : u(_u), v(_v), i(_i) {}\n    int operator[](int loc) const { return u ^ v ^ loc; }\n    friend void re(wedge& e) { re(e.u, e.v, e.w); --e.u, --e.v; }\n    friend void pr(const wedge& e) { pr(e.u, \"<-\", e.w, \"->\", e.v); }\n};\n\nnamespace __io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); cout.precision(15);\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); }\n    }\n}\nusing namespace __io;\n// }}}\n\nstruct uf_monostate {\n    uf_monostate(__attribute__((unused)) int id) {}\n    void merge(__attribute__((unused)) uf_monostate& o,\n            __attribute__((unused)) const monostate& e) {}\n};\n\ntemplate<typename T = uf_monostate, typename E = monostate>\nstruct union_find {\n    struct node {\n        int par, rnk, size; T state;\n        node(int id = 0) : par(id), rnk(0), size(1), state(id) {}\n        void merge(node& o, E& e) {\n            if (rnk == o.rnk) rnk++;\n            if (size < o.size) swap(state, o.state);\n            size += o.size;\n            state.merge(o.state, e);\n        }\n    };\n\n    vector<node> uf;\n    union_find(int N = 0) : uf(N) {\n        for (int i = 0; i < N; i++)\n            uf[i] = node(i);\n    }\n\n    int rep(int i) {\n        if (i != uf[i].par)\n            uf[i].par = rep(uf[i].par);\n        return uf[i].par;\n    }\n\n    bool unio(int a, int b, E& e = ms) {\n        a = rep(a), b = rep(b);\n        bool as = state(a).ec < uf[a].size;\n        bool bs = state(b).ec < uf[b].size;\n        if (a == b) {\n            if (as) { state(a).ec++; return true; }\n            return false;\n        }\n        if (!as && !bs) return false;\n        if (uf[a].rnk < uf[b].rnk) swap(a, b);\n        uf[a].merge(uf[b], e);\n        uf[b].par = a;\n        return true;\n    }\n\n    T& state(int i) { return uf[rep(i)].state; }\n};\n\nstruct uf_comp {\n    int ec = 0;\n    uf_comp(int id) { }\n    void merge(uf_comp& o, monostate& edge) {\n        ec += o.ec + 1;\n    }\n};\n\nint main() {\n    setIO();\n\n    int N, H, W; re(N, H, W);\n\n    struct card { int r, c, a; };\n    vector<card> cards(N);\n    trav (cd, cards) re(cd.r, cd.c, cd.a);\n    sort_by(cards, a.a > b.a);\n\n    union_find<uf_comp> uf(H + W);\n    ll ans = 0;\n    trav (e, cards) {\n        if (uf.unio(e.r-1, H+e.c-1))\n            ans += e.a;\n    }\n    ps(ans);\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define mod998 998244353\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\nint N, H, W, R[100000], C[100000], A[100000], t[200000];\nbool used[200000];\nvector<int>v[200000];\nset<pair<int, int>>st;\npriority_queue<pair<int, pair<int, int>>>pq[200000];\nll res;\n\nint p(int x) {\n\tif (t[x] < 0)return x;\n\treturn t[x] = p(t[x]);\n}\n\nvoid u(int x, int y) {\n\tx = p(x);\n\ty = p(y);\n\tif (x == y)return;\n\tif (t[x] < t[y]) {\n\t\tt[x] += t[y];\n\t\tt[y] = x;\n\t}\n\telse {\n\t\tt[y] += t[x];\n\t\tt[x] = y;\n\t}\n}\n\nint main() {\n\tcin >> N >> H >> W;\n\tfor (int i = 0; i < 200000; ++i) {\n\t\tt[i] = -1;\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> R[i] >> C[i] >> A[i];\n\t\t--R[i];\n\t\t--C[i];\n\t\tu(R[i], C[i] + 100000);\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tpq[p(R[i])].push(mkp(A[i], mkp(R[i], C[i] + 100000)));\n\t}\n\tfor (int i = 0; i < 200000; ++i) {\n\t\tif (t[i] < -1) {\n\t\t\tint c = 0;\n\t\t\twhile (c < -t[i] && !pq[i].empty()) {\n\t\t\t\tint x = pq[i].top().second.first;\n\t\t\t\tint y = pq[i].top().second.second;\n\t\t\t\tint s = pq[i].top().first;\n\t\t\t\tpq[i].pop();\n\t\t\t\tif (!used[x]) {\n\t\t\t\t\tfor (int j : v[x]) {\n\t\t\t\t\t\tif (used[j]) {\n\t\t\t\t\t\t\tused[x] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!used[y]) {\n\t\t\t\t\tfor (int j : v[y]) {\n\t\t\t\t\t\tif (used[j]) {\n\t\t\t\t\t\t\tused[y] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (used[x] && used[y]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (used[x]) {\n\t\t\t\t\tused[y] = true;\n\t\t\t\t\tres += s;\n\t\t\t\t}\n\t\t\t\telse if (used[y]) {\n\t\t\t\t\tused[x] = true;\n\t\t\t\t\tres += s;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tres += s;\n\t\t\t\t\tif (!st.insert(mkp(x, y)).second) {\n\t\t\t\t\t\tused[x] = used[y] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tv[x].push_back(y);\n\t\t\t\tv[y].push_back(x);\n\t\t\t\t++c;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Data\n{\n    int r, c, val;\n    bool dd;\n    bool operator < (const Data data) const\n    {\n        return val < data.val;\n    }\n};\n\nint n, h, w;\nData a[100005];\nbool Row[100005], Col[100005];\n\nlong long MaxRow()\n{\n    memset(Row, false, sizeof(Row));\n    memset(Col, false, sizeof(Col));\n    long long res = 0;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if(!Row[a[i].r] && !a[i].dd)\n        {\n            Row[a[i].r] = true;\n            a[i].dd = true;\n            res += a[i].val;\n        }\n    }\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if(!Col[a[i].c] && !a[i].dd)\n        {\n            Col[a[i].c] = true;\n            a[i].dd = true;\n            res += a[i].val;\n        }\n    }\n    return res;\n}\nlong long MaxCol()\n{\n    memset(Row, false, sizeof(Row));\n    memset(Col, false, sizeof(Col));\n    long long res = 0;\n    for (int i = n - 1; i >= 0; i--)\n    {\n        a[i].dd=false;\n    }\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if(!Col[a[i].c] && !a[i].dd)\n        {\n            Col[a[i].c] = true;\n            a[i].dd = true;\n            res += a[i].val;\n        }\n    }\n    for (int i = n - 1; i >= 0; i--)\n    {\n        if(!Row[a[i].r] && !a[i].dd)\n        {\n            Row[a[i].r] = true;\n            a[i].dd = true;\n            res += a[i].val;\n        }\n    }\n    return res;\n}\nint main()\n{\n    ios_base:: sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n    cin >> n >> h >> w;\n    for (int i = 0; i < n; i++)\n    {\n        cin >> a[i].r >> a[i].c >> a[i].val;\n        a[i].dd = false;\n    }\n    sort(a, a + n);\n\n    cout << max(MaxRow(), MaxCol());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\n#define pb push_back\n#define mp make_pair\n#define eps 1e-9\n#define INF 2000000000\n#define LLINF 1000000000000000ll\n#define sz(x) ((int)(x).size())\n#define fi first\n#define sec second\n#define all(x) (x).begin(),(x).end()\n#define sq(x) ((x)*(x))\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);(i)++)\n#define repn(i,a,n) for(int (i)=(a);(i)<(int)(n);(i)++)\n#define EQ(a,b) (abs((a)-(b))<eps)\n#define dmp(x) cerr << __LINE__ << \" \" << #x << \" \" << x << endl;\ntemplate<class T> void chmin(T& a,const T& b){if(a>b)a=b;}\ntemplate<class T> void chmax(T& a,const T& b){if(a<b)a=b;}\ntemplate<class T>\nusing MaxHeap = priority_queue<T>;\ntemplate<class T>\nusing MinHeap = priority_queue<T,vector<T>,greater<T> >;\ntemplate<class T,class U>\nostream& operator << (ostream& os,pair<T,U>& p){\n  os << p.fi << ',' << p.sec; return os;\n}\ntemplate<class T,class U>\nistream& operator >> (istream& is,pair<T,U>& p){\n  is >> p.fi >> p.sec; return is;\n}\ntemplate<class T>\nostream& operator << (ostream &os,const vector<T> &vec){\n  for(int i=0;i<vec.size();i++){\n    os << vec[i];\n    if(i+1<vec.size())os << ' ';\n  }\n  return os;\n}\ntemplate<class T>\nistream& operator >> (istream &is,vector<T>& vec){\n  for(int i=0;i<vec.size();i++)is >> vec[i];\n  return is;\n}\nvoid fastio(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n  cout<<fixed<<setprecision(20);\n}\nstruct UnionFind{\n\tvector<int> par,rank,sz;\n\tvoid init(int n){\n    par.resize(n);\n    sz.resize(n,1);\n    rank.resize(n,0);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x==y)return;\n    par[x] = y;\n    sz[y] += sz[x];\n    rank[y] += rank[x];\n\t}\n\tbool same(int x,int y){\n\t\treturn find(x) == find(y);\n\t}\n}uf;\nint N;\nint H,W;\nstruct edge{\n  int f,t;\n  ll c;\n  edge(){}\n  edge(int f,int t,int c):f(f),t(t),c(c){}\n  bool operator < (const edge& a) const{\n    return c > a.c;\n  }\n};\nvector<edge> es;\nint main(){\n  fastio();\n  cin >> N >> H >> W;\n  uf.init(H+W);\n  for(int i=0;i<N;i++){\n    int r,c,a;\n    cin >> r >> c >> a;\n    r--;c--;\n    c += H;\n    es.pb(edge(r,c,a));\n  }\n  sort(all(es));\n  ll ans = 0ll;\n  for(int i=0;i<es.size();i++){\n    edge e = es[i];\n    int f = uf.find(e.f);\n    int t = uf.find(e.t);\n    if(f==t){\n      if(uf.sz[f]>uf.rank[f]){\n        ans += e.c;\n        uf.rank[f]++;\n      }\n    }else{\n      if(uf.sz[f]+uf.sz[t]>=uf.rank[f]+uf.rank[t]+1){\n        ans += e.c;\n        uf.unite(f,t);\n        uf.rank[t]++;\n      }\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nconst int N=200000+5,inf=0x3f3f3f3f;\nint f[N],cyc[N];\nint find(int x){\n\treturn x==f[x]?x:f[x]=find(f[x]);\n}\nstruct node{\n\tint r,c,val;\n\tbool friend operator <(node i,node j){\n\t\treturn i.val>j.val;\n\t}\n}a[N];\nsigned main(){\n\tint n,H,W;\n\tcin>>n>>H>>W;\n\tfor(int i=1;i<=H+W;++i)\n\t\tf[i]=i;\n\tfor(int i=1;i<=n;++i)\n\t\tcin>>a[i].r>>a[i].c>>a[i].val;\n\tsort(a+1,a+n+1);int ans=0;\n\tfor(int i=1;i<=n;++i){\n\t\tint x=find(a[i].r),y=find(a[i].c+H);\n\t\tif(x==y){\n\t\t\tif(cyc[x]) continue;\n\t\t\tcyc[x]=1;\n\t\t}\n\t\telse{\n\t\t\tif(cyc[x] && cyc[y]) continue;\n\t\t\tf[x]=y; cyc[y]+=cyc[x];\n\t\t}\n\t\tans+=a[i].val;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing T = tuple<int, int, int>;\nconst int MX = 100005;\nint n, h, w, a, r, c;\nT tp[MX];\nlong long ans;\nint p[MX*2], m[MX*2];\nint find(int x){return p[x] ? p[x] = find(p[x]) : x;}\nvoid uni(T t){\n\ttie(a, r, c) = t;\n\tint x = find(r), y = find(h+c);\n\tif(p[x] > p[y]) swap(x, y);\n\tif(!(m[x] |= m[y])) ans -= a;\n\tif(x != y) p[p[y] = x] += p[y];\n\telse m[x] = 1;\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &h, &w);\n\trep(i,n){\n\t\tscanf(\"%d%d%d\", &r, &c, &a);\n\t\ttp[i] = T(-a,r,c);\n\t}\n\tsort(tp,tp+n);\n\trep(i,n) uni(tp[i]);\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (register ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (register ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter cout << endl\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 2e6 + 10 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 1e9 + 7 ;\nconst double eps = 1e-7 ;\ntemplate <class T> void read(T &a)\n{\n\tint f = 1 ; a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\ta *= f;\n}\n\nll n, h, w, ans;\n\nstruct card\n{\n\tll a, r, c;\n}\na[maxn];\n\nll fa[maxn];\n\nbool circle[maxn];\n\nvoid init(ll t)\n{\n\trep(i, 1, t) fa[i] = i;\n\treturn ;\n}\n\nll getfa(ll a)\n{\n\treturn a == fa[a] ? a : fa[a] = getfa(fa[a]);\n}\n\nsigned main()\n{\n\tscanf(\"%lld %lld %lld\", &n, &h, &w);\n\tinit(h + w);\n\trep(i, 1, n) scanf(\"%lld %lld %lld\", &a[i].r, &a[i].c, &a[i].a);\n\tsort(a + 1, a + n + 1, [](card a, card b)\n\t\t{\n\t\t\treturn a.a > b.a;\n\t\t}\n\t);\n\trep(i, 1, n)\n\t{\n\t\tll u = a[i].r, v = a[i].c + h;\n\t\t// cout << u << ' ' << v << endl;\n\t\t// printf(\"I : %lld %lld %lld\\n\", a[i].r, a[i].c, a[i].a);\n\t\tu = getfa(u), v = getfa(v);\n\t\t// printf(\"%lld %lld\\n\", u, v);\n\t\tif(u != v)\n\t\t{\n\t\t\tif(!circle[u] || !circle[v] ) ans += a[i].a, fa[u] = v, circle[v] = circle[u] = circle[v] | circle[u];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(!circle[u]) circle[u] = 1, ans += a[i].a;\n\t\t\t// else puts(\"No\");\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 1e9 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\nstruct edge{\n\tll R, C, A;\n\tbool operator<(const edge &right)const{\n\t\treturn A < right.A;\n\t}\n};\n\n// par[i]  は，iがrootなら-(連結成分のサイズ)を，iがrootではないならばrootを返す\n// root(x) は必ずroot を返す\nstruct UnionFindSize {\n    vector<int> par;\n    \n    UnionFindSize(int n) : par(n, -1) { }\n    void init(int n) { par.assign(n, -1); }\n    \n    int root(int x) {\n        if (par[x] < 0) return x;\n        else return par[x] = root(par[x]);\n    }\n    \n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n    \n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (par[x] > par[y]) swap(x, y); // merge technique\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    \n    int size(int x) {\n        return -par[root(x)];\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll N, H, W;\n    cin >> N >> H >> W;\n\n    vector<edge> edges;\n\n    REP(i, N){\n    \tll R, C, A;\n    \tcin >> R >> C >> A;\n    \tR--, C--;\n    \tedges.push_back(edge{R, C, A});\n    }\n    sort(edges.rbegin(), edges.rend());\n\n    UnionFindSize uf(H+W);\n    vector<ll> cnt(N, 0);\n\n\n    ll res = 0;\n    REP(i, N){\n    \tll r1 = uf.root(edges[i].R);\n    \tll r2 = uf.root(H+edges[i].C);\n    \tll s1 = uf.size(r1);\n    \tll s2 = uf.size(r2);\n    \tll e1 = cnt[r1];\n    \tll e2 = cnt[r2];\n    \t\n    \tif(r1 == r2){\n    \t\tif(s1>e1){\n    \t\t\tres += edges[i].A;\n    \t\t\tcnt[r1]++;\n    \t\t}\n    \t}else{\n    \t\tif(s1+s2>e1+e2){\n    \t\t\tres += edges[i].A;\n    \t\t\tuf.merge(r1, r2);\n    \t\t\tcnt[uf.root(r1)] = e1+e2+1;\n    \t\t}\n    \t}\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <time.h>\n#include <vector>\n#include <map>\n#include <set>\n#include <sstream>\n#include <algorithm>\n#include <bitset>\n#include <utility>\n#include <iostream>\n#include <cmath>\n#include <deque>\n\n#define pii pair<ll,ll>\n#define X first\n#define Y second\n#define mp make_pair\n\ntypedef long long ll;\nusing namespace std;\n#define MAXN 228228\n#define MOD 1000000007\nll x, y, n, m, k, R, C;\nll a[MAXN], rsz[MAXN], csz[MAXN];\nvector<ll> g;\n\nstruct shit {\n    ll val;\n    ll x;\n    ll y;\n};\n\nbool operator <(const shit& x, const shit& y) {\n    return x.val < y.val;\n}\n\nll p[MAXN], s[MAXN], h[MAXN];\n\ntemplate<size_t N>\nstruct DSU {\n    DSU() {\n        for (int i = 0; i < N; i++) {\n            color[i] = i;\n            siz[i] = 1;\n        }\n    }\n\n    int get(int v) {\n        return (v == color[v]) ? v : (color[v] = get(color[v]));\n    }\n\n    void unite(int a, int b) {\n        a = get(a);\n        b = get(b);\n        if (siz[a] > siz[b]) {\n            swap(a, b);\n        }\n        if (a != b) {\n            color[a] = b;\n            siz[b] += siz[a];\n            h[b] += h[a];\n        }\n    }\n\n    int size(int x) {\n        return siz[x];\n    }\n\n    int color[N];\n    int siz[N];\n};\n\nDSU<MAXN> dsu;\n\nvector<shit> f;\nint main() {\n    cin >> n >> R >> C;\n    for (int i = 0; i < n; i++ ){\n        ll x, y, z;\n        cin >> x >> y >> z;\n        f.push_back({z, x, y + R});\n    }\n    sort(f.begin(), f.end());\n    reverse(f.begin(), f.end());\n    for (int i = 1; i <= R+C; i++) {\n        h[i] = 1;\n    }\n\n    ll ans = 0;\n    for (auto v : f) {\n        ll x = dsu.get(v.x);\n        ll y = dsu.get(v.y);\n        ll val = v.val;\n        if (x == y) {\n            if (h[x] == dsu.size(x)) {\n                h[x]++;\n                ans += val;\n            }\n        } else {\n            if (h[x] + h[y] <= dsu.size(x) + dsu.size(y) + 1) {\n                dsu.unite(x, y);\n                ans += val;\n            }\n        }\n    }\n    cout << ans << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1 };\nvel dy = { 1,-1,0,0 };\nvoid sol(int i,int ba, vvel& nex,vvel& use) {\n\tif (use[i].size() == 0 || use[i].back() != ba) {\n\t\tuse[i].push_back(ba);\n\t\tfor (auto ne : nex[i]) {\n\t\t\tsol(ne, ba, nex, use);\n\t\t}\n\t}\n}\nsigned main() {\n\tomajinai;\n\tint n, h, w; cin >> n >> h >> w;\n\tvvel cxy(n);\n\tvvel y_i(w);\n\tvvel x_i(h);\n\trep(i, n) {\n\t\tint c, x, y; cin >> x >> y >> c; x--; y--;\n\t\tcxy[i] = { c,x,y };\n\t}\n\tsor(cxy);\n\trep(i, n) {\n\t\tint x = cxy[i][1];\n\t\tint y = cxy[i][2];\n\t\ty_i[y].push_back(i);\n\t\tx_i[x].push_back(i);\n\t}\n\tvel cnt(n, 0);\n\tvvel nex(n);\n\trep(i, w) { \n\t\tsor(y_i[i]);\n\t\tint sz = y_i[i].size();\n\t\tif (sz != 0) {\n\t\t\tcnt[y_i[i].back()]++;\n\t\t\trep(j, sz - 1) {\n\t\t\t\tnex[y_i[i][j + 1]].push_back(y_i[i][j]);\n\t\t\t}\n\t\t}\n\n\t}\n\trep(i, h) { \n\t\tsor(x_i[i]);\n\t\tint sz = x_i[i].size();\n\t\tif (sz != 0) {\n\t\t\tcnt[x_i[i].back()]++;\n\t\t\trep(j, sz - 1) {\n\t\t\t\tnex[x_i[i][j + 1]].push_back(x_i[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tvvel use(n);\n\tint ans = 0;\n\t/*rep(i, n) {\n\t\tif (cnt[i] == 2) {\n\t\t\tsol(i,i, nex,use);\n\t\t}\n\t\tif (cnt[i] >= 1) { ans += cxy[i][0]; }\n\t}*/\n\tvel pa(n, -1);\n\tvvel ed;\n\trep(i, n) {\n\t\tif (cnt[i] == 0) {\n\t\t\tvel v = use[i];\n\t\t\tif (v.size() >= 1) {\n\t\t\t\ted.push_back({ cxy[i][0],v[0],v.back() });\n\t\t\t}\n\t\t}\n\t}\n\tsor(ed); rev(ed);\n\tvel ex(n, 0);\n\tfor (auto v : ed) {\n\t\tint c = v[0];\n\t\tint x = root(v[1], pa);\n\t\tint y = root(v[2], pa);\n\t\tif (x == y) {\n\t\t\tif (ex[x] == 0) {\n\t\t\t\tex[x] = 1;\n\t\t\t\tans += c;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (ex[x] + ex[y]<=1) {\n\t\t\t\tpa[x] = y;\n\t\t\t\tex[y] += ex[x]; ex[x] = 0;\n\t\t\t\tans += c;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nconst int N=2e5+5;\nstruct Edge {\n    int u,v,w;\n    bool operator < (const Edge &b) const {\n        return w>b.w;\n    }\n}a[N];\nint par[N];bool ban[N];\nint fd(int x) {\n    return par[x]==x?x:par[x]=fd(par[x]);\n}\nvoid init(int n) {\n    for(int i=1;i<=n;i++) {\n        par[i]=i;\n        ban[i]=false;\n    }\n}\nint main() {\n    int n,h,w;\n    scanf(\"%d%d%d\",&n,&h,&w);\n    for(int i=1;i<=n;i++) {\n        int u,v,w;\n        scanf(\"%d%d%d\",&u,&v,&w);\n        a[i].w=w;a[i].u=u;\n        a[i].v=v+h;\n    }\n    init(h+w);\n    long long ans=0;\n    std::sort(a+1,a+1+n);\n    for(int i=1;i<=n;i++) {\n        int u=a[i].u,v=a[i].v;\n        u=fd(u);v=fd(v);\n        if(u!=v) {\n            if(ban[u]&&ban[v]) continue;\n            par[u]=v;\n            ban[v]=ban[v]||ban[u];\n        }\n        else {\n            if(!ban[u]) {\n                ban[u]=1;\n            }\n            else continue;\n        }\n        ans+=a[i].w;\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define XX first\n#define YY second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nint N;\nint H;\nint W;\nLL A[114514];\nint Y[114514];\nint X[114514];\nvector<int> ps;\n\nstruct UfData {\n  int parsz;\n  int rem;\n  UfData() : parsz(-1), rem(1) {}\n  // 自分にdをmerge。頂点自体はuにvをuniteした。\n  void Merge(const UfData &d, int u, int v) {\n    parsz += d.parsz;\n    rem += d.rem;\n  }\n};\n\nstruct UnionFind {\n  vector<UfData> dat;\n\n  UnionFind() {}\n  void Init(int n) {\n    dat.assign(n, UfData());\n  }\n  int Root(int v) {\n    if (dat[v].parsz < 0) return v;\n    return dat[v].parsz = Root(dat[v].parsz);\n  }\n  bool Unite(int u, int v) {\n    int p = Root(u);\n    int q = Root(v);\n    if (p == q) return false;\n\n    if (dat[p].parsz > dat[q].parsz) {\n      swap(p, q);\n      swap(u, v);\n    }\n    dat[p].Merge(dat[q], u, v);\n    dat[q].parsz = p;\n    return true;\n  }\n  bool Same(int u, int v) {\n    return Root(u) == Root(v);\n  }\n  int Size(int v) {\n    return -dat[Root(v)].parsz;\n  }\n  UfData& Data(int v) {\n    return dat[Root(v)];\n  }\n};\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n\n  cin >> N >> H >> W;\n  rep(i, N) {\n    cin >> Y[i] >> X[i] >> A[i];\n    --Y[i];\n    --X[i];\n    ps.eb(i);\n  }\n  sort(all(ps), [](int i, int j){return A[i] > A[j];});\n  \n  UnionFind uf;\n  uf.Init(H+W);\n  LL ans = 0;\n  int num = 0;\n  for (int idx : ps) {\n    int u = Y[idx];\n    int v = X[idx] + H;\n    uf.Unite(u, v);\n    auto &dat = uf.Data(v);\n    if (dat.rem == 0) continue;\n    dat.rem--;\n    //cout << Y[idx]+1 << \", \" << X[idx]+1 << \", \" << A[idx] << endl;\n    //cout << \"taken\\n\";\n    num++;\n    ans += A[idx];\n  }\n  assert(num <= H+W);\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define per(i, b, a) for(int i = b - 1; i >= a; i--)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n#define hash dhsjakhd\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef long double ld;\n\nunsigned seed = std::chrono::system_clock::now().time_since_epoch().count();\nstd::mt19937 eng(seed);\n\nuniform_int_distribution<> DD(0, (1ll << 31));\n\nll random2(){\n    return (ll(DD(eng))*(1ll << 31) + ll(DD(eng))) & ((1ll << 62ll)-1);\n}\n\nll n,m,T,k,q;\n\nconst ll big = 1000000007;\nconst ll big2 = 1000000009;\nconst ll mod =  998244353;\n\nconst int MAXN = 200001;\n\nll deg[MAXN] = {0};\nll pek[MAXN] = {0};\nll nonpick[MAXN] = {0};\n\nll par(ll i){\n    ll i2 = i;\n    while(i2 != pek[i2]){\n        i2 = pek[i2];\n    }\n    return i2;\n}\n\nll ans = 0;\n\nvi ind;\nvl A,B,V;\n\nll merg(ll i, ll j, ll v){\n    ll i2 = par(i);\n    ll j2 = par(j);\n    if(i2 != j2 && v > min(nonpick[i2],nonpick[j2])){\n        ans += v;\n        if(deg[i2] < deg[j2])swap(i2,j2);\n        ans -= min(nonpick[i2],nonpick[j2]);\n        nonpick[i2] = max(nonpick[i2],nonpick[j2]);\n        deg[i2] += deg[j2];\n        pek[j2] = i2;\n    }\n    else{\n        if(v > nonpick[i2]){\n            ans += v-nonpick[i2];\n            nonpick[i2] = v;\n        }\n    }\n}\n\nbool comp(ll i, ll j){\n    return V[i] > V[j];\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    //freopen(\"input.txt\",\"r\",stdin);\n   // freopen(\"autput.txt\",\"w\",stdout);\n    ll a,b,c,d;\n\n    cin >> k >> n >> m;\n    rep(c1,0,k){\n        cin >> a >> b >> c;\n        a--;\n        b--;\n        b += n;\n        ind.push_back(c1);\n        A.push_back(a);\n        B.push_back(b);\n        V.push_back(c);\n    }\n\n    rep(c1,0,n+m){\n        deg[c1] = 1;\n        pek[c1] = c1;\n        nonpick[c1] = 0;\n    }\n\n    sort(all(ind),comp);\n\n    rep(c1,0,k){\n        a = ind[c1];\n      //  cerr << A[a] << \" \" << B[a] << \"\\n\";\n        merg(A[a],B[a],V[a]);\n    }\n\n    rep(c1,0,n+m){\n      //  cerr <<c1 << \":  par - \" <<  par(c1) << \"   nonpick - \" << nonpick[par(c1)] << \"\\n\";\n    }\n\n    cout << ans  << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long LL;\n\nconst int N=100000;\n\nint n,h,w;\nstruct card{\n  int x,y,v;\n}a[N+9];\n\nbool cmp(const card &a,const card &b){return a.v>b.v;}\n\nvoid into(){\n  scanf(\"%d%d%d\",&n,&h,&w);\n  for (int i=1;i<=n;++i)\n\tscanf(\"%d%d%d\",&a[i].x,&a[i].y,&a[i].v);\n}\n\nint uni[N*2+9],siz[N*2+9],cnt[N*2+9];\n\nint Query_uni(int k){return k==uni[k]?k:uni[k]=Query_uni(uni[k]);}\n\nLL ans;\n\nvoid Get_ans(){\n  sort(a+1,a+n+1,cmp);\n  for (int i=1;i<=h+w;++i) uni[i]=i,siz[i]=1,cnt[i]=0;\n  for (int i=1;i<=n;++i){\n\tint fx=Query_uni(a[i].x),fy=Query_uni(a[i].y+h);\n\tif (fx==fy){\n\t  if (cnt[fx]>=siz[fx]) continue;\n\t  ++cnt[fx];ans+=a[i].v;\n\t}else{\n\t  if (cnt[fx]+cnt[fy]>=siz[fx]+siz[fy]) continue;\n\t  uni[fy]=fx;siz[fx]+=siz[fy];cnt[fx]+=cnt[fy]+1;\n\t  ans+=a[i].v;\n\t}\n  }\n}\n\nvoid work(){\n  Get_ans();\n}\n\nvoid outo(){\n  printf(\"%lld\\n\",ans);\n}\n\nint main(){\n  into();\n  work();\n  outo();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (register ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (register ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter cout << endl\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 2e6 + 10 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 1e9 + 7 ;\nconst double eps = 1e-7 ;\ntemplate <class T> void read(T &a)\n{\n\tint f = 1 ; a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\ta *= f;\n}\n\nll n, h, w, ans;\n\nstruct card\n{\n\tll a, r, c;\n}\na[maxn];\n\nll fa[maxn];\n\nbool circle;\n\nvoid init(ll t)\n{\n\trep(i, 1, t) fa[i] = i;\n\treturn ;\n}\n\nll getfa(ll a)\n{\n\treturn a == fa[a] ? a : fa[a] = getfa(fa[a]);\n}\n\nsigned main()\n{\n\tscanf(\"%lld %lld %lld\", &n, &h, &w);\n\tinit(h + w);\n\trep(i, 1, n) scanf(\"%lld %lld %lld\", &a[i].r, &a[i].c, &a[i].a);\n\tsort(a + 1, a + n + 1, [](card a, card b)\n\t\t{\n\t\t\treturn a.a > b.a;\n\t\t}\n\t);\n\trep(i, 1, n)\n\t{\n\t\tll u = a[i].r, v = a[i].c + h;\n\t\t// cout << u << ' ' << v << endl;\n\t\t// printf(\"I : %lld %lld %lld\\n\", a[i].r, a[i].c, a[i].a);\n\t\tu = getfa(u), v = getfa(v);\n\t\t// printf(\"%lld %lld\\n\", u, v);\n\t\tif(u != v) ans += a[i].a, fa[u] = v;\n\t\telse\n\t\t{\n\t\t\tif(!circle) circle = 1, ans += a[i].a;\n\t\t\t// else puts(\"No\");\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define REP(i,n) for(ll i=0;i<n;i++)\n#define REP1(i,n) for(ll i=1;i<=n;i++)\n#define FILL(i,n) memset(i,n,sizeof i)\n#define X first\n#define Y second\n#define ET cout << \"\\n\"\n#define SZ(_a) (int)_a.size()\n#define ALL(_a) _a.begin(),_a.end()\n#define pb push_back\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#ifdef bbq\n#define debug(...) {\\\n    fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\", \";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\n#else\n#define debug(...)\n#endif\n\nconst int MAXN=300005,INF=1e9;\nstruct MaxFlow{//0-base\n\tstruct edge{\n\t\tint to,cap,flow,rev;\n\t};\n\tvector<edge> G[MAXN];\n\tint s,t,dis[MAXN],cur[MAXN],n;\n\tint dfs(int u,int cap){\n\t\tif(u==t || !cap) return cap;\n\t\tfor(int &i=cur[u];i<(int)G[u].size();++i){\n\t\t\tedge &e=G[u][i];\n\t\t\tif(dis[e.to]==dis[u]+1 && e.flow!=e.cap){\n\t\t\t\tint df=dfs(e.to,min(e.cap-e.flow,cap));\n\t\t\t\tif(df){\n\t\t\t\t\te.flow+=df;\n\t\t\t\t\tG[e.to][e.rev].flow-=df;\n\t\t\t\t\treturn df;\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\t\tdis[u]=-1;\n\t\treturn 0;\n\t}\n\tbool bfs(){\n\t\tFILL(dis,-1);\n\t\tqueue<int> q;\n\t\tq.push(s),dis[s]=0;\n\t\twhile(!q.empty()){\n\t\t\tint tmp=q.front();\n\t\t\tq.pop();\n\t\t\tfor(auto &u:G[tmp])\n\t\t\t\tif(!~dis[u.to] && u.flow!=u.cap){\n\t\t\t\t\tq.push(u.to);\n\t\t\t\t\tdis[u.to]=dis[tmp]+1; \n\t\t\t\t}\n\t\t} \n\t\treturn dis[t]!=-1;\n\t}\n\tint maxflow(int _s,int _t){\n\t\ts=_s,t=_t;\n\t\tint flow=0,df;\n\t\twhile(bfs()){\n\t\t\tFILL(cur,0);\n\t\t\twhile(df=dfs(s,INF)) flow+=df;\n\t\t}\n\t\treturn flow;\n\t}\n\tvoid init(int _n){n=_n;\n\t\tfor(int i=0;i<n;++i) G[i].clear();\n\t}\n\tvoid reset(){\n\t\tfor(int i=0;i<n;++i)\n\t\t\tfor(auto &j:G[i])\n\t\t\t\tj.flow=0;\n\t}\n\tvoid add_edge(int u,int v,int cap){\n\t\tG[u].pb(edge{v,cap,0,(int)G[v].size()});\n\t\tG[v].pb(edge{u,0,0,(int)G[u].size()-1});\n\t}\n}Dinic;\n\nstruct mode\n{\n\tint r,c,v;\n\tbool operator<(const mode &a)const{\n\t\treturn v>a.v;\n\t}\n}arr[100005];\n\nint main()\n{\n\tIOS();\n\tll ans=0,ls=0;\n\tint n,h,w,s,t;\n\tcin >> n >> h >> w,s=n+h+w,t=n+h+w+1;\n\tfor(int i=0;i<n;++i)\n\t\tcin >> arr[i].r >> arr[i].c >> arr[i].v,--arr[i].r,--arr[i].c;\n\tsort(arr,arr+n),Dinic.init(n+h+w+2);\n\tfor(int i=0;i<h;++i)\n\t\tDinic.add_edge(n+i,t,1);\n\tfor(int i=0;i<w;++i)\n\t\tDinic.add_edge(n+h+i,t,1);\n\tfor(int i=0;i<n;++i)\n\t\tDinic.add_edge(s,i,1),Dinic.add_edge(i,n+arr[i].r,1),Dinic.add_edge(i,n+h+arr[i].c,1);\n\tDinic.maxflow(s,t);\n\tfor(int i=0;i<n;++i)\n\t\tif(!~Dinic.G[i][0].flow)\n\t\t\tans+=arr[i].v;\n\tcout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\n\nstruct UnionFind {\n    //各要素が属する集合の代表(根)を管理する\n    //もし、要素xが根であればdata[x]は負の値を取り、-data[x]はxが属する集合の大きさに等しい\n    vector<int> data;\n    vector<int> edge_num;\n\n    UnionFind(int sz) : data(sz, -1), edge_num(sz, 0) {}\n\n    bool unite(int x, int y) {\n        x = find(x);\n        y = find(y);\n        bool is_union = (x != y);\n        if (is_union) {\n            if (edge_num[x] + edge_num[y] + 1 > size(x) + size(y)) return false;\n            if (data[x] > data[y]) swap(x, y);\n            edge_num[x] += edge_num[y] + 1;\n            data[x] += data[y];\n            data[y] = x;\n            edge_num[y] = 0;\n        } else {\n            if (edge_num[x] < size(x)) {\n                edge_num[x]++;\n                return true;\n            } else {\n                return false;\n            }\n        }\n        return is_union;\n    }\n\n    int find(int x) {\n        if (data[x] < 0) { //要素xが根である\n            return x;\n        } else {\n            data[x] = find(data[x]); //data[x]がxの属する集合の根でない場合、根になるよう更新される\n            return data[x];\n        }\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int size(int x) {\n        return -data[find(x)];\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n, H, W;\n    cin >> n >> H >> W;\n    vector< vector<int> > es;\n    for (int i = 0; i < n; i++) {\n        int r, c, a;\n        cin >> r >> c >> a;\n        r--;\n        c--;\n        c += H;\n        es.push_back({a, r, c});\n    }\n    sort(es.begin(), es.end(), greater<>());\n\n    UnionFind uf(H + W);\n    ll ans = 0;\n    for (vector<int>& e : es) {\n        if (uf.unite(e[1], e[2])) ans += e[0];\n    }\n\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*input\n13 5 6\n1 3 35902\n4 6 19698\n4 6 73389\n3 6 3031\n3 1 4771\n1 4 4784\n2 1 36357\n2 1 24830\n5 6 50219\n4 6 22645\n1 2 30739\n1 4 68417\n1 5 78537\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define eb emplace_back\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define EL cout<<'\\n'\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out,vector<T> V){\n\tREP(i,SZ(V)) out<<V[i]<<((i!=SZ(V)-1)?\" \":\"\");\n\treturn out;\n}\n#define version 20190814\n//}}}\nconst ll maxn=300005;\nconst ll maxlg=20;\nconst ll INF64=1e18;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst ld PI=acos(-1);\nconst ld eps=1e-9;\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nint dsu[maxn];\nint sz[maxn];\nint rcnt[maxn],ccnt[maxn];\n\nint find(int u){\n\tif(dsu[u]==u) return u;\n\treturn find(dsu[u]);\n}\n\nvoid mrg(int u,int v){\n\tif(u==v) return;\n\tif(sz[u]<sz[v]){\n\t\tsz[v]+=sz[u];\n\t\trcnt[v]+=rcnt[u];\n\t\tccnt[v]+=ccnt[u];\n\t\tdsu[u]=v;\n\t}\n\telse{\n\t\tsz[u]+=sz[v];\n\t\trcnt[u]+=rcnt[v];\n\t\tccnt[u]+=ccnt[v];\n\t\tdsu[v]=u;\n\t}\n}\n\nvoid unmrg(int u,int v){\n\tif(sz[u]<sz[v]){\n\t\tsz[v]-=sz[u];\n\t\trcnt[v]-=rcnt[u];\n\t\tccnt[v]-=ccnt[u];\n\t\tdsu[u]=u;\n\t}\n\telse{\n\t\tsz[u]-=sz[v];\n\t\trcnt[u]-=rcnt[v];\n\t\tccnt[u]-=ccnt[v];\n\t\tdsu[v]=v;\n\t}\n}\n\nbool check(int i){\n\ti=find(i);\n\tif(rcnt[i]+ccnt[i]<sz[i]) return 0;\n\treturn 1;\n}\n\nll n,h,w;\n\nvector<pair<ll,pll>> v;\nmap<ll,ll> R,C;\nint rr[maxn],cc[maxn];\nint ptR=0,ptC=0;\n\nint main(){\n\tIOS;\n\tcin>>n>>h>>w;\n\tREP(i,n){\n\t\tll a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tv.eb(c,MP(a,b));\n\t}\n\tsort(ALL(v));\n\treverse(ALL(v));\n\tll ans=0;\n\n\tREP(i,n) dsu[i]=i,sz[i]=rcnt[i]=ccnt[i]=1;\n\n\tREP(i,SZ(v)){\n\t\tll val=v[i].F;\n\t\tll x=v[i].S.F,y=v[i].S.S;\n\t\tbool fR=0,fC=0;\n\t\tif(!R.count(x)){\n\t\t\tR[x]=ptR;\n\t\t\trr[ptR++]=i;\n\t\t\tfR=1;\n\t\t}\n\t\tif(!C.count(y)){\n\t\t\tC[y]=ptC;\n\t\t\tcc[ptC++]=i;\n\t\t\tfC=1;\n\t\t}\n\t\tint tmp1,tmp2,tmp3,tmp4;\n\t\tif(rr[R[x]]!=i){\n\t\t\ttmp1=find(i);\n\t\t\ttmp2=find(rr[R[x]]);\n\t\t\t// cout<<\"mrg: \"<<i<<' '<<rr[R[x]]<<'\\n';\n\t\t\tmrg(tmp1,tmp2);\n\t\t}\n\t\tif(cc[C[y]]!=i){\n\t\t\ttmp3=find(i);\n\t\t\ttmp4=find(cc[C[y]]);\n\t\t\t// cout<<\"mrg: \"<<i<<' '<<cc[C[y]]<<'\\n';\n\t\t\tmrg(tmp3,tmp4);\n\t\t}\n\t\tif(!fR) rcnt[find(i)]--;\n\t\tif(!fC) ccnt[find(i)]--;\n\n\t\t// REP(i,n) cout<<find(i)<<\" \\n\"[i==n-1];\n\t\tif(check(i)){\n\t\t\tans+=val;\n\t\t}\n\t\telse{\n\t\t\tif(!fC) ccnt[find(i)]++;\n\t\t\tif(!fR) rcnt[find(i)]++;\n\t\t\tif(cc[C[y]]!=i) unmrg(tmp3,tmp4);\n\t\t\tif(rr[R[x]]!=i) unmrg(tmp1,tmp2);\n\t\t\tif(fC){\n\t\t\t\tC.erase(y);\n\t\t\t\tptC--;\n\t\t\t}\n\t\t\tif(fR){\n\t\t\t\tR.erase(x);\n\t\t\t\tptR--;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by yamunaku on 2019/08/24.\n//\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repl(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perl(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD9 998244353\n#define MOD1 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n#define CST(x) cout<<fixed<<setprecision(x)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> mti;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> mtl;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\nint max_n;\nconst int mn = 300000;\nstruct edge {\n    int to, cap; ll cost; int rev;\n};\nvector<edge> G[mn];\nP par[mn];\nll dist[mn];\nvoid add_edge(int from, int to, int cap, ll cost) {\n    G[from].push_back({ to,cap,cost,(int)G[to].size() });\n    G[to].push_back({ from,0,-cost,(int)G[from].size() - 1 });\n    max_n = max({ max_n, from + 1, to + 1 });\n}\nvoid add_edge2(int from, int to, int cap, ll cost) {\n    G[from].push_back({ to,cap,cost,-1 });\n    //G[to].push_back({ from,0,-cost,(int)G[from].size() - 1 });\n    max_n = max({ max_n, from + 1, to + 1 });\n}\nLP minimum_road(int s, int t) {\n    fill(par, par + max_n, P{ -1,-1 });\n    fill(dist, dist + max_n, IINF);\n    dist[s] = 0;\n    priority_queue<LP, vector<LP>, greater<LP>> q; q.push({ 0,s });\n    while (!q.empty()) {\n        LP p = q.top(); q.pop();\n        int id = p.second;\n        if (id == t)continue;\n        if (p.first > dist[id])continue;\n        rep(j, G[id].size()) {\n            if (G[id][j].cap > 0) {\n                int to = G[id][j].to;\n                ll nd = p.first + G[id][j].cost;\n                if (nd < dist[to]) {\n                    dist[to] = nd;\n                    par[to] = { id,j };\n                    q.push({ dist[to],to });\n                }\n            }\n        }\n    }\n    int cur = t;\n    int f = IINF;\n    while (cur != s) {\n        int p = par[cur].first, j = par[cur].second;\n        if (p < 0)return { -1,-1 };\n        f = min(f, G[p][j].cap);\n        cur = p;\n    }\n    cur = t;\n    while (cur != s) {\n        int p = par[cur].first, j = par[cur].second;\n        if (p < 0)return { -1,-1 };\n        G[p][j].cap -= f;\n        if (G[p][j].rev >= 0) {\n            G[cur][G[p][j].rev].cap += f;\n        }\n        cur = p;\n    }\n    return { dist[t],f };\n}\nll minimum_cost_flow(int s, int t) {\n    ll ret = 0;\n    int k=10000000;\n    rep(i, k) {\n        LP z = minimum_road(s, t);\n        if (z.first < 0) break;\n        if (k - i <= z.second) {\n            ret += z.first*(k - i); break;\n        }\n        i += z.second - 1;\n        ret += z.first*z.second;\n    }\n    return ret;\n}\n\nint main(){\n    int n,h,w;\n    cin >> n;\n    cin >> h >> w;\n    vi r(n),c(n),a(n);\n    map<int,int> rmp,cmp;\n    rep(i,n){\n        cin >> r[i] >> c[i] >> a[i];\n        rmp[r[i]]=0;\n        cmp[c[i]]=0;\n    }\n    int idx=0;\n    for(auto &p:rmp) p.second=idx++;\n    idx=0;\n    for(auto &p:cmp) p.second=idx++;\n    int rs=rmp.size(),cs=cmp.size();\n    int sz=rs+cs+n+2;\n    rep(i,rs){\n        add_edge(0,i+2,1,0);\n    }\n    rep(i,cs){\n        add_edge(0,rs+i+2,1,0);\n    }\n    rep(i,n){\n        add_edge(rmp[r[i]]+2,rs+cs+i+2,1,0);\n        add_edge(rs+cmp[c[i]]+2,rs+cs+i+2,1,0);\n        add_edge(rs+cs+i+2,1,1,IINF-a[i]);\n    }\n    cout << minimum_cost_flow(0,1) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long LL;\ntypedef pair<int, int> PII;\ntypedef vector<int> VI;\ntypedef vector<double> VD;\n#define MP make_pair\n#define PB push_back\n#define X first\n#define Y second\n \n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define RFOR(i, b, a) for(int i = (b) - 1; i >= (a); --i)\n#define ITER(it, a) for(__typeof(a.begin()) it = a.begin(); it != a.end(); ++it)\n#define ALL(a) a.begin(), a.end()\n#define SZ(a) (int)((a).size())\n#define FILL(a, value) memset(a, value, sizeof(a))\n#define debug(a) cout << #a << \" = \" << a << endl;\n\nconst double PI = acos(-1.0);\nconst LL INF = 1e9 + 47;\nconst LL LINF = INF * INF;\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\nconst int N = 1 << 18;\nint n, h, w;\npair<int, PII> cards[N];\nint p[N];\nint sz[N];\nint zan[N];\n\nint find(int x)\n{\n\tif (p[x] == x)\n\t\treturn x;\n\treturn p[x] = find(p[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)\n\t\treturn;\n\t\t\n\tif (sz[x] < sz[y])\n\t\tswap(x, y);\n\t\n\tsz[x] += sz[y];\n\tp[y] = x;\n\tzan[x] += zan[y];\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\t//freopen(\"In.txt\", \"r\", stdin);\n\t//freopen(\"In.txt\", \"w\", stdout);\n\t\n\tcin >> n >> h >> w;\n\tFOR(i, 0, n)\n\t{\n\t\tcin >> cards[i].Y.X >> cards[i].Y.Y >> cards[i].X;\n\t\tcards[i].Y.X--;\n\t\tcards[i].Y.Y--;\n\t}\n\t\n\tsort(cards, cards + n);\n\treverse(cards, cards + n);\n\t\n\tFOR(i, 0, h + w)\n\t\tp[i] = i, sz[i] = 1;\n\t\n\tLL ans = 0;\n\tFOR(i, 0, n)\n\t{\n\t\tint r = cards[i].Y.X;\n\t\tint c = cards[i].Y.Y;\n\t\t\n\t\tunite(r, c + h);\n\t\tint par = find(r);\n\t\tif (sz[par] > zan[par])\n\t\t{\n\t\t\tans += cards[i].X;\n\t\t\tzan[par]++;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\tcerr << \"Time elapsed: \" << clock() / (double)CLOCKS_PER_SEC << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define finish(x) return cout << x << endl, 0\n#define ll long long\n\nconst int N = 100001;\n\nint n, h, w, dsu[2 * N], nodes[2 * N], edges[2 * N];\nvector <pair <int, pair <int, int> > > e;\n\nint find(int x){\n    if(dsu[x] == x) return x;\n    return dsu[x] = find(dsu[x]);\n}\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n    cin >> n >> h >> w;\n    for(int i = 0 ; i < 2 * n ; i++){\n        dsu[i] = i;\n        nodes[i] = 1;\n    }\n    e.resize(n);\n    for(auto &i : e){\n        cin >> i.second.first >> i.second.second >> i.first;\n        i.second.second += h;\n    }\n    map <int, int> mp;\n    for(auto &i : e) mp[i.second.first], mp[i.second.second];\n    int com = 0;\n    for(auto &i : mp) i.second = com++;\n    for(auto &i : e){\n        i.second.first = mp[i.second.first];\n        i.second.second = mp[i.second.second];\n    }\n    sort(e.rbegin(), e.rend());\n    ll ans = 0;\n    for(auto &i : e){\n        int x = i.second.first;\n        int y = i.second.second;\n        x = find(x);\n        y = find(y);\n        if(x != y){\n            if(nodes[x] + nodes[y] == edges[x] + edges[y]) continue;\n            dsu[y] = x;\n            nodes[x] += nodes[y];\n            edges[x] += edges[y];\n            edges[x]++;\n            ans += i.first;\n        }\n        else{\n            if(nodes[x] == edges[x]) continue;\n            edges[x]++;\n            ans += i.first;\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <set>\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct UnionFind{\nprivate:\n  vector<int> data;\npublic:\n  int N;\n  UnionFind(int n) : data(n, -1), N(n){}\n  bool unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return false;\n    --N;\n    if(data[y] < data[x]) swap(x,y);\n    data[x] += data[y];\n    data[y] = x;\n    return true;\n  }\n  bool same(int x, int y){ return find(x) == find(y); }\n  int find(int x){\n    if(data[x] < 0) return x;\n    return data[x] = find(data[x]);\n  }\n  int size(int x){ return -data[find(x)]; }\n};\n\nstruct Card {\n  int r, c, a;\n  Card(int r, int c, int a) : r(r), c(c), a(a) {}\n};\n\nbool comp(const Card &A, const Card &B){\n  return A.a < B.a;\n}\n\nint main(){\n  int N, H, W;\n  cin >> N >> H >> W;\n  vector<Card> C;\n  for(int i = 0; i < N; ++i){\n    int r, c, a;\n    cin >> r >> c >> a;\n    --r,--c;\n    C.emplace_back(r,c,a);\n  }\n  sort(C.rbegin(), C.rend(), comp);\n  UnionFind uf(H+W);\n  long long ans = 0;\n  set<int> used_cc;\n  for(int i = 0; i < N; ++i){\n    int r = C[i].r, c = C[i].c, a = C[i].a;\n    int p = uf.find(r), q = uf.find(c+H);\n    if(p == q){\n      if(used_cc.count(p))\n        continue;\n      ans += a;\n      used_cc.insert(p);\n    }else{\n      if(used_cc.count(p) and used_cc.count(q))\n        continue;\n      ans += a;\n      uf.unite(p,q);\n      if(used_cc.count(p) or used_cc.count(q))\n        used_cc.insert(uf.find(p));\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst int maxn = 2e5 + 10;\n\nvector<int> g[maxn];\nint mt[maxn];\nint used[maxn];\nint cn = 1;\nvector<ll> prm = { 0, 1 };\nll dsu[maxn * 2];\npair<ll, ll> c3[maxn * 2];\n\nll find(int v) {\n\tif (dsu[v] == v) return v;\n\telse return dsu[v] = find(dsu[v]);\n}\n\nvoid uni(int v, int u) {\n\tu = find(u);\n\tv = find(v);\n\n\tif (u != v) {\n\t\tdsu[u] = v;\n\t\tc3[v].first += c3[u].first;\n\t\tc3[v].second += c3[u].second;\n\t}\n}\n\nbool dfs(int v) {\n\tif (used[v] == cn) return false;\n\n\tused[v] = cn;\n\n\tll rnd = rand() % 2;\n\tif (rnd == 1) {\n\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\tint u = g[v][i];\n\t\t\tif (mt[u] == -1 || dfs(mt[u])) {\n\t\t\t\tmt[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\tint u = g[v][1 - i];\n\t\t\tif (mt[u] == -1 || dfs(mt[u])) {\n\t\t\t\tmt[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\n\treturn false;\n}\n\nint main()\n{\n\tfastInp;\n\n\tll n, h, w;\n\tcin >> n >> h >> w;\n\n\tll vals = 0, ans = 0;\n\tvector<tuple<ll, ll, ll>> vec;\n\tfor (int i = 0; i < n; i++) {\n\t\tdsu[i] = i;\n\t\tc3[i] = { 1, 0 };\n\t}\n\tfor (int i = 0; i < h + w + 3; i++) mt[i] = -1;\n\n\tfor (int i = n; i < n + h; i++) {\n\t\tdsu[i] = i;\n\t\tc3[i] = { 0, 1 };\n\t}\n\tfor (int i = n + h; i < n + h + w; i++) {\n\t\tdsu[i] = i;\n\t\tc3[i] = { 0, 1 };\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tll r, c, a;\n\t\tcin >> r >> c >> a;\n\t\tr--; c--;\n\t\tvec.push_back({ a, r, c });\n\t}\n\n\tsort(vec.rbegin(), vec.rend());\n\n\tll cnt = 0;\n\tll hw = h + w;\n\tfor (int i = 0; i < n; i++) {\n\t\tll r = get<1>(vec[i]), c = get<2>(vec[i]), a = get<0>(vec[i]);\n\t\tr += n;\n\t\tc += h + n;\n\t\tr = find(r);\n\t\tc = find(c);\n\t\tif (c == r) {\n\t\t\tif (min(c3[c].first + 1ll, c3[c].second) > min(c3[c].first, c3[c].second)) {\n\t\t\t\tans += a;\n\t\t\t\tuni(c, i);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (min(c3[c].first, c3[c].second) + min(c3[r].first, c3[r].second) < min(c3[c].first + c3[r].first + 1ll, c3[c].second + c3[r].second)) {\n\t\t\t\tans += a;\n\t\t\t\tuni(c, i);\n\t\t\t\tc = find(c);\n\t\t\t\tuni(c, r);\n\t\t\t}\n\t\t}\n\t\t/*if (mt[r] == -1 || mt[c + h + 1] == -1) {\n\t\t\tvals++;\n\t\t\tcnt++;\n\t\t\tg[i].push_back(r);\n\t\t\tg[i].push_back(c + h + 1);\n\t\t\tif (mt[r] == -1) {\n\t\t\t\tmt[r] = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmt[c + h + 1] = i;\n\t\t\t}\n\t\t\tans += a;\n\t\t\tcontinue;\n\t\t}\n\t\tcn++;\n\t\tvals++;\n\n\t\tg[i].push_back(r);\n\t\tg[i].push_back(c + h + 1);\n\t\tcnt += dfs(i);\n\n\t\tif (cnt >= vals) {\n\t\t\tans += a;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tvals--;\n\t\t}*/\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nint main() {\n  int len, n, m;\n  scanf(\"%d%d%d\", &len, &n, &m);\n  vector<array<int, 3>> a(len);\n  for (int i = 0; i < len; ++i) {\n    int x, y, v;\n    scanf(\"%d%d%d\", &x, &y, &v);\n    --x; --y;\n    a[i] = {v, x, y};\n  }\n  sort(a.begin(), a.end());\n  vector<int> cnt(len);\n  vector<bool> row(n), col(m);\n  int64 ret = 0;\n  for (int i = len - 1; i >= 0; --i) {\n    if (row[a[i][1]]) continue;\n    row[a[i][1]] = true;\n    cnt[i]++;\n    ret += a[i][0];\n  }\n  for (int i = len - 1; i >= 0; --i) {\n    if (col[a[i][2]]) continue;\n    col[a[i][2]] = true;\n    cnt[i]++;\n    ret += a[i][0];\n  }\n  fill(row.begin(), row.end(), false);\n  fill(col.begin(), col.end(), false);\n  for (int i = 0; i < len; ++i) {\n    if (cnt[i] == 2) {\n      // trace(i, a[i]);\n      row[a[i][1]] = col[a[i][2]] = true;\n      ret -= a[i][0];\n    }\n  }\n  for (int i = len - 1; i >= 0; --i) {\n    if (cnt[i]) continue;\n    if (row[a[i][1]] || col[a[i][2]]) {\n      row[a[i][1]] = col[a[i][2]] = false;\n      ret += a[i][0];\n    }\n  }\n  printf(\"%lld\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> ii;\ntypedef long long ll;\n\nconst int Maxn = 300005;\n\nint n, H, W;\nint R[Maxn], C[Maxn], A[Maxn];\nint seq[Maxn];\nbool tk[Maxn], vis[Maxn];\nvector <int> neigh[Maxn];\nll res;\n\nbool Less(const int &a, const int &b) { return A[a] > A[b]; }\n\nint Visit(int v)\n{\n    if (!tk[v]) return v;\n    if (vis[v]) return -1;\n    vis[v] = true;\n    while (!neigh[v].empty()) {\n        int g = Visit(neigh[v].back());\n        if (g == -1) neigh[v].pop_back();\n        else { tk[g] = true; tk[v] = false; vis[v] = false; return v; }\n    }\n    vis[v] = false;\n    return -1;\n}\n\nint main()\n{\n    scanf(\"%d %d %d\", &n, &H, &W);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &R[i], &C[i], &A[i]);\n        seq[i] = i;\n    }\n    sort(seq, seq + n, Less);\n    for (int i = 0; i < n; i++) {\n        int ind = seq[i];\n        int v = Visit(R[ind]);\n        if (v == -1) v = Visit(H + C[ind]);\n        if (v != -1) {\n            tk[v] = true;\n            res += A[ind];\n            neigh[R[ind]].push_back(H + C[ind]);\n            neigh[H + C[ind]].push_back(R[ind]);\n        }\n    }\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n, h, w;\nint a[100005], r[100005], c[100005];\nint d[200005], ord[100005];\n\ninline bool cmp(const int &lhs, const int &rhs) {\n    return a[lhs] > a[rhs];\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &h, &w);\n    forn(i, n) {\n        scanf(\"%d%d%d\", r + i, c + i, a + i);\n        --r[i], --c[i];\n        c[i] += h;\n        ord[i] = i;\n    }\n    memset(d, -1, sizeof d);\n    sort(ord, ord + n, cmp);\n    LL ans = 0;\n    forn(ii, n) {\n        int i = ord[ii];\n        int cur = r[i];\n        while (d[cur] >= 0) {\n            int ncur = d[cur];\n            d[cur] = -2;\n            cur = ncur;\n        }\n        if (d[cur] == -1) {\n            ans += a[i];\n            d[cur] = c[i];\n            continue;\n        }\n\n        cur = c[i];\n        while (d[cur] >= 0) {\n            int ncur = d[cur];\n            d[cur] = -2;\n            cur = ncur;\n        }\n        if (d[cur] == -1) {\n            ans += a[i];\n            d[cur] = r[i];\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int inf=1e9;\nconst long long INF=(long long)inf*inf;\n\nint n,cnt=1,S,T;\nint g[300010];\nlong long dist[300010];\nint pre[300010],que[300010];\nbitset<300010>inque;\nvector<int>USE;\n\nstruct edge{\n\tint t,c,cst,next;\n}e[30000010];\n\ninline void add_edge(int x,int y,int z1,int z2){\n\te[++cnt].t=y;\n\te[cnt].c=z1;\n\te[cnt].cst=z2;\n\te[cnt].next=g[x];\n\tg[x]=cnt;\n\n\te[++cnt].t=x;\n\te[cnt].c=0;\n\te[cnt].cst=-z2;\n\te[cnt].next=g[y];\n\tg[y]=cnt;\n}\n\ninline bool spfa(){\n\tfor(auto&i:USE)\n\t\tdist[i]=INF;\n\tdist[S]=0;\n\tinque.reset();\n\tinque.set(S);\n\tque[1]=S;\n\tint h=0,t=1;\n\twhile(h!=t){\n\t\th=h%T+1;\n\t\tint x=que[h];\n\t\tinque.reset(x);\n\n\t\tfor(int i=g[x];i;i=e[i].next){\n\t\t\tif(e[i].c&&dist[x]+e[i].cst<dist[e[i].t]){\n\t\t\t\tdist[e[i].t]=dist[x]+e[i].cst;\n\t\t\t\tpre[e[i].t]=i^1;\n\n\t\t\t\tif(!inque.test(e[i].t)){\n\t\t\t\t\tt=t%T+1;\n\t\t\t\t\tinque.set(e[i].t);\n\t\t\t\t\tque[t]=e[i].t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dist[T]!=INF;\n}\n\nint N,H,W;\nint R[100010],C[100010],A[100010];\nbitset<100010>row,col;\n\nint main(){\n\tscanf(\"%d%d%d\",&N,&H,&W);\n\tS=H+W+N+1;\n\tT=S+1;\n\tUSE.push_back(S);\n\tUSE.push_back(T);\n\tfor(int i=1;i<=N;i++){\n\t\tscanf(\"%d%d%d\",R+i,C+i,A+i);\n\t\tadd_edge(R[i],i+H+W,1,0);\n\t\tadd_edge(C[i]+H,i+H+W,1,0);\n\t\tadd_edge(i+H+W,T,1,-A[i]);\n\t\trow.set(R[i]);\n\t\tcol.set(C[i]);\n\t\tUSE.push_back(i+H+W);\n\t}\n\tfor(int i=1;i<=H;i++)\n\t\tif(row.test(i)){\n\t\t\tadd_edge(S,i,1,0);\n\t\t\tUSE.push_back(i);\n\t\t}\n\tfor(int i=1;i<=W;i++)\n\t\tif(col.test(i)){\n\t\t\tadd_edge(S,i+H,1,0);\n\t\t\tUSE.push_back(i+H);\n\t\t}\n\n\tlong long ans=0;\n\twhile(spfa()){\n\t\tans-=dist[T];\n\n\t\tfor(int i=T;i!=S;i=e[pre[i]].t){\n\t\t\te[pre[i]].c++;\n\t\t\te[pre[i]^1].c--;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 200000\n#define LL long long\nint n,h,w;LL ans;\nstruct edge{\n\tint u,v,w;\n}e[MAXN+1];\nint fa[MAXN+1],siz[MAXN+1],used[MAXN+1];\nint read(){\n\tint x=0,F=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')F=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n\treturn x*F;\n}\nbool cmp(edge s1,edge s2){\n\treturn s1.w>s2.w;\n}\nint xfind(int x){\n\tif(fa[x]==x)return x;\n\treturn fa[x]=xfind(fa[x]);\n}\nint main()\n{\n\tn=read(),h=read(),w=read();\n\tfor(int i=1;i<=n;i++)\n\te[i]=(edge){read(),read()+n,read()};\n\tfor(int i=1;i<=n*2;i++)fa[i]=i,siz[i]=1;\n\tsort(e+1,e+n+1,cmp);\n\tfor(int i=1;i<=n;i++){\n\t\tint a=xfind(e[i].u),b=xfind(e[i].v);\n\t\tif(a==b){\n\t\t\tif(siz[a]>=used[a]+1){\n\t\t\t\tused[a]=used[a]+1;\n\t\t\t\tans+=e[i].w;\n\t\t\t}\n\t\t}else{\n\t\t\tif(siz[a]+siz[b]>=used[a]+used[b]+1){\n\t\t\t\tused[a]+=1;\n\t\t\t\tans+=e[i].w;\n\t\t\t}\n\t\t\tused[a]+=used[b];\n\t\t\tsiz[a]+=siz[b];\n\t\t\tfa[b]=a;\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\n#define rrep(i,a,b) for(int i=(a);i>=(b);--i)\n#define MP make_pair\n#define PB push_back\n#define PII pair<int,int>\ntypedef long long LL;\nconst LL P = 1e9+7;\nconst LL INF = 1e12;\nconst int M = 2e6+5;\nconst int N = 3e5+5;\nconst double pi = acos(-1);\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n \nint to[M],cap[M],nxt[M],head[N],v[N],path[N];\nLL cost[M],d[N],ans;\nint n,m,i,j,k,tot=1,S,T,x,y,z,h,w;\n \nvoid add(int x,int y,int z,int w){\n\tto[++tot]=y,cap[tot]=z,cost[tot]=w,nxt[tot]=head[x],head[x]=tot;\n\tto[++tot]=x,cap[tot]=0,cost[tot]=-w,nxt[tot]=head[y],head[y]=tot;\n}\n\nbool spfa(){\n\trep(i,0,T)d[i]=INF;\n\tmemset(v,0,sizeof(v));\n\tqueue<int> q; q.push(S),\n\td[S]=0,v[S]=1;\n\twhile(!q.empty()){\n\t\tx=q.front(),q.pop(),v[x]=0;\n\t\tfor(int i=head[x];i;i=nxt[i])\n\t\t\tif(cap[i]&&d[y=to[i]]>d[x]+cost[i]){\n\t\t\t\td[y]=d[x]+cost[i],path[y]=i;\n\t\t\t\tif(!v[y]) q.push(y),v[y]=1;\n\t\t\t}\n\t}\n\treturn d[T]!=INF;\n}\n\nvoid update(){\n\tfor(y=T;y!=S;y=x){\n\t\ti=path[y],x=to[i^1];\n\t\t--cap[i],++cap[i^1];\n\t}\n\tans+=d[T];\n}\n \nint main(){\n\tscanf(\"%d%d%d\",&n,&h,&w);\n\tS = 0, T = h + w + n + 1;\n\trep(i,1,h+w)add(S,i,1,0);\n\trep(i,1,n){\n\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\tadd(h+w+i,T,1,-z);\n\t\tadd(x,h+w+i,1,0);\n\t\tadd(h+y,h+w+i,1,0);\n\t}\n\twhile(spfa())update();\n\tcout<<-ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> ii;\n\nconst int maxn = 2e5 + 5;\n\nint lab[maxn], ok[maxn];\nint N, w, h;\nvector<pair<int, ii>> edge;\n\nvoid init(int n)\n{\n  for(int i = 1; i <= n; ++i)\n    lab[i] = -1;\n}\n\nint finds(int u)\n{\n  if(lab[u] < 0) return u;\n  return lab[u] = finds(lab[u]);\n}\n\nbool merges(int u, int v)\n{\n  u = finds(u); v = finds(v);\n  if(u == v){\n    if(ok[u]) return false;\n    ok[u] = true;\n    return true;\n  }\n  if(ok[u] && ok[v]) return false;\n  if(lab[v] < lab[u]) swap(u, v);\n  lab[u] += lab[v];\n  lab[v] = u;\n  ok[u] |= ok[v];\n  return true;\n}\n\nsigned main(void)\n{\n  ios_base::sync_with_stdio(0); cin.tie(0); cout.tie(0);\n  #ifdef LOCAL\n    freopen(\"A.INP\", \"r\", stdin);\n    freopen(\"A.OUT\", \"w\", stdout);\n  #endif // LOCAL\n  cin >> N >> h >> w;\n  while(N--){\n    int x, y, v;\n    cin >> x >> y >> v;\n    y += h;\n    edge.eb(v, mp(x, y));\n  }\n  init(w + h);\n  sort(edge.rbegin(), edge.rend());\n  ll mst = 0;\n  for(auto & all : edge){\n    if(merges(all.se.fi, all.se.se)){\n      //cerr << all.se.fi << ' ' << all.se.se  << ' ' << all.fi << '\\n';\n      mst += all.fi;\n    }\n  }\n  cout << mst;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vi;\ntypedef pair<ll,ll> pi;\ntypedef vector<pi> vpi;\ntypedef long double ld;\n#define pb emplace_back\n#define mp make_pair\n#define lb lower_bound\n#define ub upper_bound\n#define ALL(x) x.begin(), x.end()\n#define SZ(x) (ll)x.size()\n#define f first\n#define s second\n#define MAXN 200100\n\nll N,R,C;\nvector<pair<ll,pi>> V;\nll a,b,c;\nll p[MAXN];\nll par(ll x){return (p[x] == x)?x:p[x]=par(p[x]);}\nll key[MAXN];\nll ans;\n\nint main(){\n\tcin>>N>>R>>C;\n\tfor (ll i=0;i<N;++i){\n\t\tcin>>a>>b>>c;\n\t\tV.pb(mp(c,mp(a,b)));\n\t}\n\tsort(ALL(V));\n\treverse(ALL(V));\n\tfor (ll i=1;i<=R+C;++i)p[i]=i;\n\tfor (ll i=0;i<N;++i){\n\t\tpair<ll,pi> cur = V[i];\n\t\ta = cur.s.f;\n\t\tb = cur.s.s + R;\n\t\ta=par(a);b=par(b);\n\t\t// cout<<cur.f<<' '<<cur.s.f<<' '<<cur.s.s<<'\\n';\n\t\tif (a==b){\n\t\t\tif (key[a])continue;\n\t\t\tans += cur.f;\n\t\t\tkey[a] = 1;\n\t\t}\n\t\tif (key[a] && key[b])continue;\n\t\tp[a]=b;\n\t\tkey[b] = key[a] = key[a] | key[b]; // If either are already keychains then merged becomes keychain\n\t\tans += cur.f;\n\t}\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "// warm heart, wagging tail,and a smile just for you!\n//\n//                            ▒█████▒▒\n//                             ██████████▒\n//                             ▒████████████▒\n//                            ██████████████████\n//                           ████████████████████▒\n//                          ▒██████████████████████▒\n//                          ▒███████████████████████\n//                      ▒████▒▒▒▒▒▒█████████████████▒\n//                    ███▒▒▒▒▒▒██████████████████████▒▒▒\n//                  ▒██▒▒███████████████████████▒▒▒▒▒██████\n//                 ▒█████████████████████████▒▒▒▒▒▒█████████▒\n//                 ▒█████████████████████▒▒▒▒▒▒██████████████\n//                  ▒████         ████▒▒▒▒▒████         ████▒\n//              ▒█████▒    ████    ▒▒▒▒███████    ████    ██████▒\n//            ▒██▒▒▒▒▒    ██████    █████████    ██████    ██▒▒▒██▒\n//           █████████   ████████   █████████   ████████   ▒▒▒▒█████\n//          ▒█████████    ██████    ████████▒    ██████    █████████\n//          ▒██████████    ████    █████▒▒▒▒▒▒    ████    ██████████\n//           ████████████        ▒▒▒▒▒▒▒████████        ███████████▒\n//       ▒██████████▒▒▒▒▒▒▒▒▒▒▒▒▒▒▒███████████████████████████████████▒\n//     ███▒▒▒▒▒▒▒▒▒▒▒▒█████████████████████████████████████████▒▒████████▒\n//   ▒▒▒▒▒▒▒▒▒██████████████                         ███████▒▒▒▒███████████\n//   █████████████████████████                     ███████▒▒▒██████████████▒\n//   █████████████████████████████             ███████▒▒▒██████████████████▒\n//   ██████████████████████████████████████████████████████████████████████\n//    ██████████████████████████████████████████████████████████████████▒\n//      ▒█████████████████▒▒▒▒▒▒▒██████████████████████████████████▒▒▒\n//\n#include \"bits/stdc++.h\"\nusing namespace std;\n#define MOD 1000000007\n//#define MOD 998244353\nconst double EPS = 1e-9;\n#define INF (1LL<<60)\n#define D double\n#define fs first\n#define sc second\n#define int long long\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define RFOR(i,a,b) for(int i = (b-1);i>=(a);--i)\n#define REP(i,n)  FOR(i,0,(n))\n#define RREP(i,n) RFOR(i,0,(n))\n#define ITR(itr,mp) for(auto itr = (mp).begin(); itr != (mp).end(); ++itr)\n#define RITR(itr,mp) for(auto itr = (mp).rbegin(); itr != (mp).rend(); ++itr)\n#define range(i,a,b) ((a)<=(i) && (i)<(b))\n#define debug(x)  cout << #x << \" = \" << (x) << endl;\n#define SP << \" \" << \ntypedef pair<int,int> P;\ntypedef vector<int> vec;\ntypedef vector<vector<int>> mat;\n\nstruct UnionFind {\n  private:\n  vector<int> child,tree,sum,edge_num;\n\npublic:\n  UnionFind(int v) {\n    tree.resize(v);\n    sum.resize(v);\n    edge_num.assign(v,0);\n    REP(i,v) tree[i] = i, sum[i] = 1;\n  }\n\n  int root(int i){\n    if(i == tree[i]){\n      REP(j,child.size()) tree[child[j]] = i;\n      child.clear(); \n      return i;\n    }\n    else{\n      child.push_back(i);\n      return i = root(tree[i]);\n    }\n  }\n\n  int size(int i){\n    return sum[root(i)];\n  }\n\n  int edge(int i){\n    return edge_num[root(i)];\n  }\n\n  int unit(int x, int y){\n    if(isUnit(x,y)){\n      edge_num[root(x)]++;\n      return 0;\n    }\n    x = root(x);\n    y = root(y);\n    sum[min(x,y)] += sum[max(x,y)];\n    edge_num[min(x,y)] += edge_num[max(x,y)]+1;\n    tree[max(x,y)] = min(x,y);\n  }\n\n  bool isUnit(int x, int y){\n    return root(x) == root(y);\n  }\n};\n\nsigned main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n,h,w;\n  cin >> n >> h >> w;\n\n  using T = tuple<int,int,int>;\n  vector<T> a(n);\n  REP(i,n){\n    int x,y,c;\n    cin >> x >> y >> c;\n    a[i] = T(c,x,y);\n  }\n\n  sort(a.begin(),a.end());\n  reverse(a.begin(),a.end());\n\n  int ans = 0, z = 1e5;\n  UnionFind uf(2e5+10);\n  REP(i,n){\n    int x,y,c;\n    tie(c,x,y) = a[i];\n    if(uf.isUnit(x,y+z)){\n      if(uf.size(x) <= uf.edge(x)) continue;\n    }\n    else{\n      if(uf.size(x)+uf.size(y+z) <= uf.edge(x)+uf.edge(y+z)) continue;\n    }\n    ans += c;\n    uf.unit(x,y+z);\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iterator>\n#include <limits>\n#include <numeric>\n#include <utility>\n#include <type_traits>\n#include <cmath>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std;\nusing namespace placeholders;\n\nusing LL = long long;\nusing ULL = unsigned long long;\nusing VI = vector< int >;\nusing VVI = vector< vector< int > >;\nusing VS = vector< string >;\nusing ISS = istringstream;\nusing OSS = ostringstream;\nusing PII = pair< int, int >;\nusing VPII = vector< pair< int, int > >;\ntemplate < typename T = int > using VT = vector< T >;\ntemplate < typename T = int > using VVT = vector< vector< T > >;\ntemplate < typename T = int > using LIM = numeric_limits< T >;\n\ntemplate < typename T > inline istream& operator>>( istream &s, vector< T > &v ){ for ( T &t : v ) { s >> t; } return s; }\ntemplate < typename T > inline ostream& operator<<( ostream &s, const vector< T > &v ){ for ( int i = 0; i < int( v.size() ); ++i ){ s << ( \" \" + !i ) << v[i]; } return s; }\n\nvoid in_impl(){};\ntemplate < typename T, typename... TS > void in_impl( T &head, TS &... tail ){ cin >> head; in_impl( tail ... ); }\n#define IN( T, ... ) T __VA_ARGS__; in_impl( __VA_ARGS__ );\n\ntemplate < typename T > struct getv_fmt;\ntemplate <> struct getv_fmt<       int >{ static constexpr const char *fmt = \"%d\"; };\ntemplate <> struct getv_fmt< long long >{ static constexpr const char *fmt = \"%lld\"; };\ntemplate < typename T > void getv( std::vector< T > &v ){ for_each( begin( v ), end( v ), []( T &a ){ scanf( getv_fmt< T >::fmt, &a ); } ); };\n\ntemplate < typename T > inline T fromString( const string &s ) { T res; istringstream iss( s ); iss >> res; return res; }\ntemplate < typename T > inline string toString( const T &a ) { ostringstream oss; oss << a; return oss.str(); }\n\n#define NUMBERED( name, number ) NUMBERED2( name, number )\n#define NUMBERED2( name, number ) name ## _ ## number\n#define REP1( n ) REP2( NUMBERED( REP_COUNTER, __LINE__ ), n )\n#define REP2( i, n ) REP3( i, 0, n )\n#define REP3( i, m, n ) for ( int i = ( int )( m ); i < ( int )( n ); ++i )\n#define GET_REP( a, b, c, F, ... ) F\n#define REP( ... ) GET_REP( __VA_ARGS__, REP3, REP2, REP1 )( __VA_ARGS__ )\n#define FOR( e, c ) for ( auto &&e : c )\n#define ALL( c ) begin( c ), end( c )\n#define AALL( a ) ( remove_all_extents< decltype( a ) >::type * )a, ( remove_all_extents< decltype( a ) >::type * )a + sizeof( a ) / sizeof( remove_all_extents< decltype( a ) >::type )\n#define DRANGE( c, p ) begin( c ), begin( c ) + ( p ), end( c )\n\n#define SZ( v ) ( (int)( v ).size() )\n#define EXIST( c, e ) ( ( c ).find( e ) != ( c ).end() )\n\ntemplate < typename T > inline bool chmin( T &a, const T &b ){ if ( b < a ) { a = b; return true; } return false; }\ntemplate < typename T > inline bool chmax( T &a, const T &b ){ if ( a < b ) { a = b; return true; } return false; }\n\n#define PB push_back\n#define EM emplace\n#define EB emplace_back\n#define BI back_inserter\n\n#define MP make_pair\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\nconstexpr auto INF = LIM<>::max() / 2;\n\n// 最小費用流 O( F |E| log |V| )\nclass MinimumCostFlow\n{\nprivate:\n\tstruct Edge\n\t{\n\t\tint to, cap, cost, rev;\n\t\tEdge( int t, int c, int d, int r ) : to( t ), cap( c ), cost( d ), rev( r ) {}\n\t};\n\n\tconst int V;\n\tvector< vector<Edge> > G;\n\npublic:\n\tMinimumCostFlow( int v ) : V( v ), G( V ) {};\n\n\tvoid connect( int from, int to, int cap, int cost )\n\t{\n\t\tG[ from ].push_back( Edge( to, cap, cost, G[ to ].size() ) );\n\t\tG[ to ].push_back( Edge( from, 0, -cost, G[ from ].size() - 1 ) );\n\t\treturn;\n\t}\n\n\tint solve( int s, int t, int f )\n\t{\n\t\tint res = 0;\n\t\tvector<int> h( V, 0 ), prevv( V ), preve( V );\n\n\t\twhile ( 0 < f )\n\t\t{\n\t\t\tvector<int> distance( V, INF );\n\t\t\tdistance[s] = 0;\n\n\t\t\tpriority_queue< pair<int,int>, vector< pair<int,int> >, greater< pair<int,int> > > que;\n\t\t\tque.push( make_pair( 0, s ) );\n\t\t\t\n\t\t\twhile ( !que.empty() )\n\t\t\t{\n\t\t\t\tint d = que.top().first;\n\t\t\t\tint v = que.top().second;\n\t\t\t\tque.pop();\n\n\t\t\t\tif ( distance[v] < d )\n\t\t\t\t{\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor ( int i = 0; i < (int)G[v].size(); ++i )\n\t\t\t\t{\n\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\tif ( 0 < e.cap && distance[v] + e.cost + h[v] - h[ e.to ] < distance[ e.to ] )\n\t\t\t\t\t{\n\t\t\t\t\t\tdistance[ e.to ] = distance[v] + e.cost + h[v] - h[ e.to ];\n\t\t\t\t\t\tprevv[ e.to ] = v;\n\t\t\t\t\t\tpreve[ e.to ] = i;\n\t\t\t\t\t\tque.push( make_pair( distance[ e.to ], e.to ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( distance[t] == INF )\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tfor ( int i = 0; i < V; ++i )\n\t\t\t{\n\t\t\t\th[i] += distance[i];\n\t\t\t}\n\n\t\t\tint d = f;\n\t\t\tfor ( int v = t; v != s; v = prevv[v] )\n\t\t\t{\n\t\t\t\td = min( d, G[ prevv[v] ][ preve[v] ].cap );\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor ( int v = t; v != s; v = prevv[v] )\n\t\t\t{\n\t\t\t\tEdge &e = G[ prevv[v] ][ preve[v] ];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][ e.rev ].cap += d;\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tint solve2( const int s, const int t, int f )\n\t{\n// \t\tconst int INF = INT_MAX / 2;\n\t\tint res = 0;\n\n\t\twhile ( f > 0 )\n\t\t{\n\t\t\tvector<int> dist( V, INF );\n\t\t\tdist[s] = 0;\n\t\t\tvector<int> prevv( V ), preve( V );\n\n\t\t\tbool update = true;\n\t\t\twhile ( update )\n\t\t\t{\n\t\t\t\tupdate = false;\n\n\t\t\t\tfor ( int v = 0; v < V; v++ )\n\t\t\t\t{\n\t\t\t\t\tif ( dist[v] == INF )\n\t\t\t\t\t{\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor ( int i = 0; i < (int)G[v].size(); i++ )\n\t\t\t\t\t{\n\t\t\t\t\t\tEdge &e = G[v][i];\n\t\t\t\t\t\tif ( e.cap > 0 && dist[ e.to ] > dist[v] + e.cost )\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdist[ e.to ] = dist[v] + e.cost;\n\t\t\t\t\t\t\tprevv[ e.to ] = v;\n\t\t\t\t\t\t\tpreve[ e.to ] = i;\n\t\t\t\t\t\t\tupdate = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif ( dist[t] == INF )\n\t\t\t{\n\t\t\t\treturn -1;\n\t\t\t}\n\n\t\t\tint d = f;\n\t\t\tfor ( int v = t; v != s; v = prevv[v] )\n\t\t\t{\n\t\t\t\td = min( d, G[ prevv[v] ][ preve[v] ].cap );\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * dist[t];\n\t\t\tfor ( int v = t; v != s; v = prevv[v] )\n\t\t\t{\n\t\t\t\tEdge &e = G[ prevv[v] ][ preve[v] ];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][ e.rev ].cap += d;\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n};\n// MinimumCostFlow( |V| )\n// connect( from, to, cap, cost )\n// solve( s, t, f ) :  Primal-Dual O( F |E| log |V| )\n// solve2( s, t, f ) : Bellman-Ford O( F |E| |V| )\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\tcout << setprecision( 12 ) << fixed;\n\n\tIN( int, N, H, W );\n\tVI R( N ), C( N ), A( N );\n\tREP( i, N )\n\t{\n\t\tcin >> R[i] >> C[i] >> A[i];\n\t\t--R[i], --C[i];\n\t}\n\n\tMinimumCostFlow mincostflow( N * 2 + H + W + 2 );\n\t// [ 0, N ) := cards (src)\n\t// [ N, 2N ) := cards (sink)\n\t// [ 2N, 2N + H ) := rows\n\t// [ 2N + H, 2N + H + W ) := columns\n\tconst int SRC = 2 * N + H + W;\n\tconst int SINK = SRC + 1;\n\n\tREP( i, N )\n\t{\n\t\tmincostflow.connect( SRC, i, 1, 0 );\n\t\tmincostflow.connect( i, N + i, 1, 0 );\n\t\tmincostflow.connect( N + i, 2 * N + R[i], 1, -A[i] );\n\t\tmincostflow.connect( N + i, 2 * N + H + C[i], 1, -A[i] );\n\t}\n\tREP( i, H )\n\t{\n\t\tmincostflow.connect( 2 * N + i, SINK, 1, 0 );\n\t}\n\tREP( j, W )\n\t{\n\t\tmincostflow.connect( 2 * N + H + j, SINK, 1, 0 );\n\t}\n\tmincostflow.connect( SRC, SINK, H * W, 0 );\n\n\tcout << -mincostflow.solve( SRC, SINK, H * W ) << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define F first\n#define S second\n#define mp make_pair\n#define pb push_back\n//#define ll __int128\n#define ll long long\n#define LEFT(a) ((a)<<1)\n#define RIGHT(a) (LEFT(a) + 1)\n#define MID(a,b) ((a+b)>>1)\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define y1 y122\n/*\n#pragma GCC optimize (\"O3\")\n#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"avx2,fma\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx,tune=native\")\n#pragma GCC target (\"avx2\")\n#pragma GCC optimization (\"unroll-loops\")\n#pragma comment(linker, \"/STACK: 20000000005\")\n*/\n\nusing namespace std;\n\nconst ll N = 1000005;\n\nll n;\nll x[N], y[N], a[N];\n\n\npriority_queue < pair < ll, pair < ll, ll > > > Q;\n\nmap < ll, bool > R, C;\n\nll ans;\n\n\nmain()\n{\n    //freopen (\"in.in\", \"r\", stdin);freopen (\"out.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(0);\n    ll xx;\n    cin >> n >> xx >> xx;\n    for (ll i = 1; i <= n; i++){\n        cin >> x[i] >> y[i] >> a[i];\n        Q.push ({a[i], {x[i], y[i]}});\n    }\n    while (Q.size() > 0){\n        ll X = Q.top().F;\n        ll r = Q.top().S.F, c = Q.top().S.S;\n        Q.pop();\n        if (C[c] == 0){\n            C[c] = 1;\n            ans += X;\n            continue;\n        }\n        if (R[r])\n            continue;\n        R[r] = 1;\n        ans += X;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef OUUAN\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#endif\n#include<bits/stdc++.h>\n\n#define int LoveLive\n//#define FAST_IOSTREAM 1\n\n#define For(i,l,r)for(int i=(l),i##end=(r);i<=i##end;++i)\n#define FOR(i,r,l)for(int i=(r),i##end=(l);i>=i##end;--i)\n#define SON(i,u)for(int i=head[u];i;i=nxt[i])\n#define ms(a,x)memset(a,x,sizeof(a))\n#define fi first\n#define se second\n#define pb emplace_back\n#define pq priority_queue\n#define isinf(x)(x>=INF?-1:x)\n#define y1 why_is_there_a_function_called_y1\n#define DEBUG(x)cerr<<(#x)<<\":\"<<x<<endl\nusing namespace std;\ntypedef long long LoveLive;typedef pair<int,int>pii;typedef vector<int>vi;\n#ifdef int\nconst int INF=0x3f3f3f3f3f3f3f3fll;\n#else\nconst int INF=0x3f3f3f3f;\n#endif\nconst double eps=1e-9;mt19937 rng(chrono::steady_clock::now().time_since_epoch().\ncount());int randint(int l,int r){int out=rng()%(r-l+1)+l;return out>=l?out:out+\nr-l+1;}\n#ifdef FAST_IOSTREAM\n#define br cout<<'\\n'\n#define sp cout<<' '\nlong long read(){long long x;cin>>x;return x;}template<typename T>void read(T&x){\ncin>>x;}template<typename T>void write(const T&x){cout<<x;}\n#else\n#define br putchar('\\n')\n#define sp putchar(' ')\ntemplate<typename T>typename enable_if<!is_integral<T>::value,void>::type read(T\n&x){cin>>x;}long long read(){char c;long long out=0,f=1;for(c=getchar();!isdigit\n(c)&&c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())\nout=(out<<3)+(out<<1)+c-'0';return out*f;}template<typename T>typename enable_if\n<is_integral<T>::value,T>::type read(T&x){char c;T f=1;x=0;for(c=getchar();!isdigit\n(c)&&c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())\nx=(x<<3)+(x<<1)+c-'0';return x*=f;}char read(char&x){for(x=getchar();isspace(x);\nx=getchar());return x;}double read(double&x){scanf(\"%lf\",&x);return x;}template<\ntypename T>typename enable_if<!is_integral<T>::value,void>::type write(const T&x\n){cout<<x;}template<typename T>typename enable_if<is_integral<T>::value,void>::type\nwrite(const T&x){if(x<0){putchar('-');write(-x);return;}if(x>9)write(x/10);putchar\n(x%10+'0');}void write(const char&x){putchar(x);}void write(const double&x){printf\n(\"%.10lf\",x);}\n#endif\ntemplate<typename T,typename...Args>void read(T&x,Args&...args){read(x);read(args\n...);}template<typename OutputIt,typename=typename enable_if<is_same<output_iterator_tag\n,typename iterator_traits<OutputIt>::iterator_category>::value||(\nis_base_of<forward_iterator_tag,typename iterator_traits<OutputIt>::iterator_category>::value\n&&!is_const<OutputIt>::value)>::type>void read(OutputIt __first,OutputIt __last){for(;__first\n!=__last;++__first)read(*__first);}template<typename InputIt,typename=typename enable_if\n<is_base_of<input_iterator_tag,typename iterator_traits<InputIt>::iterator_category\n>::value>::type>void wts(InputIt __first,InputIt __last){bool isFirst=true;for(;\n__first!=__last;++__first){if(isFirst)isFirst=false;else sp;write(*__first);}br;}\ntemplate<typename InputIt,typename=typename enable_if<is_base_of<input_iterator_tag\n,typename iterator_traits<InputIt>::iterator_category>::value>::type>void wtb(InputIt\n__first,InputIt __last){for(;__first!=__last;++__first){write(*__first);br;}}template\n<typename T>void wts(const T&x){write(x);sp;}template<typename T>void wtb(const\nT&x){write(x);br;}template<typename T>void wte(const T&x){write(x);exit(0);}template\n<typename T,typename...Args>void wts(const T&x,Args...args){wts(x);wts(args...);}\ntemplate<typename T,typename...Args>void wtb(const T&x,Args...args){wts(x);wtb(args\n...);}template<typename T,typename...Args>void wte(const T&x,Args...args){wts(x);\nwte(args...);}template<typename T>inline bool up(T&x,const T&y){return x<y?x=y,1\n:0;}template<typename T>inline bool dn(T&x,const T&y){return y<x?x=y,1:0;}\n\nconst int N = 100010;\nconst int mod = 1000000007;\n\nint n, h, w, ans, anss, vis[2][N];\n\nstruct Node\n{\n\tint w, p[2];\n\tbool operator<(const Node& b) const\n\t{\n\t\treturn w > b.w;\n\t}\n} a[N];\n\nbool insert(int x, int y)\n{\n\tif (vis[y][a[x].p[y]])\n\t{\n\t\tif (vis[y ^ 1][a[vis[y][a[x].p[y]]].p[y ^ 1]]) return false;\n\t\tvis[y ^ 1][a[vis[y][a[x].p[y]]].p[y ^ 1]] = vis[y][a[x].p[y]];\n\t}\n\tvis[y][a[x].p[y]] = x;\n\treturn true;\n}\n\nsigned main()\n{\n#ifdef FAST_IOSTREAM\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n#endif\n\t\n\tread(n, h, w);\n\t\n\tFor (i, 1, n) read(a[i].p[0], a[i].p[1], a[i].w);\n\t\n\tsort(a + 1, a + n + 1);\n\t\n\tFor (qwq, 1, 100)\n\t{\n\t\tans = 0;\n\t\tms(vis, 0);\n\t\tFor (i, 1, n)\n\t\t{\n\t\t\tif (randint(0, 1))\n\t\t\t{\n\t\t\t\tif (insert(i, 0) || insert(i, 1)) ans += a[i].w;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (insert(i, 1) || insert(i, 0)) ans += a[i].w;\n\t\t\t}\n\t\t}\n\t\tup(anss, ans);\n\t}\n\t\n\twtb(anss);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,H,W;\n\ntemplate<class V> class MaxFlow_dinic {\npublic:\n\tstruct edge { int to,reve;V cap;};\n\tstatic const int MV = 301100;\n\tvector<edge> E[MV];\n\tint itr[MV],lev[MV];\n\tvoid add_edge(int x,int y,V cap,bool undir=false) {\n\t\tE[x].push_back((edge){y,(int)E[y].size(),cap});\n\t\tE[y].push_back((edge){x,(int)E[x].size()-1,undir?cap:0});\n\t}\n\tvoid bfs(int cur) {\n\t\tMINUS(lev);\n\t\tqueue<int> q;\n\t\tlev[cur]=0;\n\t\tq.push(cur);\n\t\twhile(q.size()) {\n\t\t\tint v=q.front(); q.pop();\n\t\t\tITR(e,E[v]) if(e->cap>0 && lev[e->to]<0) lev[e->to]=lev[v]+1, q.push(e->to);\n\t\t}\n\t}\n\tV dfs(int from,int to,V cf) {\n\t\tif(from==to) return cf;\n\t\tfor(;itr[from]<E[from].size();itr[from]++) {\n\t\t\tedge* e=&E[from][itr[from]];\n\t\t\tif(e->cap>0 && lev[from]<lev[e->to]) {\n\t\t\t\tV f=dfs(e->to,to,min(cf,e->cap));\n\t\t\t\tif(f>0) {\n\t\t\t\t\te->cap-=f;\n\t\t\t\t\tE[e->to][e->reve].cap += f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tV maxflow(int from, int to) {\n\t\tV fl=0,tf;\n\t\twhile(1) {\n\t\t\tbfs(from);\n\t\t\tif(lev[to]<0) return fl;\n\t\t\tZERO(itr);\n\t\t\twhile((tf=dfs(from,to,numeric_limits<V>::max()))>0) fl+=tf;\n\t\t}\n\t}\n};\nMaxFlow_dinic<ll> mf;\n\nint R[101010],C[101010],A[101010];\nint Rok[101010],Cok[101010];\nset<int> RE[101010];\nset<int> CE[101010];\nvoid dfsC(int x);\n\nvoid dfsR(int y) {\n\tRok[y]=0;\n\twhile(RE[y].size()) {\n\t\tint x=*RE[y].begin();\n\t\tRE[y].erase(RE[y].begin());\n\t\tCE[x].erase(y);\n\t\tdfsC(x);\n\t}\n}\nvoid dfsC(int x) {\n\tCok[x]=0;\n\twhile(CE[x].size()) {\n\t\tint y=*CE[x].begin();\n\t\tCE[x].erase(CE[x].begin());\n\t\tRE[y].erase(x);\n\t\tdfsR(y);\n\t}\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>H>>W;\n\tvector<vector<int>> V;\n\tFOR(i,N) {\n\t\tcin>>R[i]>>C[i]>>A[i];\n\t\tR[i]--;\n\t\tC[i]--;\n\t\tV.push_back({A[i],R[i],C[i]});\n\t}\n\tFOR(i,H) Rok[i]=1;\n\tFOR(i,W) Cok[i]=1;\n\t\n\tsort(ALL(V));\n\treverse(ALL(V));\n\tll ret=0;\n\tFORR(v,V) {\n\t\tint y=v[1];\n\t\tint x=v[2];\n\t\t\n\t\tif(Rok[y]&&Cok[x]) {\n\t\t\tif(RE[y].size() && CE[x].size()) {\n\t\t\t\tdfsR(y);\n\t\t\t\tdfsC(x);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tRE[y].insert(x);\n\t\t\t\tCE[x].insert(y);\n\t\t\t}\n\t\t\tret+=v[0];\n\t\t}\n\t\telse if(Rok[y]) {\n\t\t\tdfsR(y);\n\t\t\tret+=v[0];\n\t\t}\n\t\telse if(Cok[x]) {\n\t\t\tdfsC(x);\n\t\t\tret+=v[0];\n\t\t}\n\t}\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<tuple>\n#include<algorithm>\nusing namespace std;\nconst int N=200005;\nint n,m,h,w;\nint fa[N];\nvector<tuple<int,int,int> >G;\nbool isc[N];\nint getf(int v)\n{\n\tif(v==fa[v]) return v;\n\tfa[v]=getf(fa[v]);\n\treturn fa[v];\n}\nint merge(int u,int v)\n{\n\tint f1=getf(u),f2=getf(v);\n\tif(f1!=f2)\n\t{\n\t\tif(isc[f1]&&isc[f2]) return -1;\n\t\telse\n\t\t{\n\t\t\tfa[f2]=f1;\n\t\t\tisc[f1]|=isc[f2];\n\t\t\treturn 1;\n\t\t}\n\t}\n\telse if(!isc[f1])\n\t{\n\t\tisc[f1]=true;\n\t\treturn 0;\n\t}\n\telse return -1;\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&h,&w);\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u,v,w;\n\t\tscanf(\"%d%d%d\",&u,&v,&w);\n\t\tv+=h;\n\t\tG.push_back(make_tuple(u,v,w));\n\t}\n\tsort(G.begin(),G.end(),[=](const tuple<int,int,int>&x,const tuple<int,int,int>&y){return get<2>(x)>get<2>(y);});\n\tm=h+w;\n\tfor(int i=1;i<=m;i++)\n\t\tfa[i]=i,isc[i]=false;\n\tlong long ans=0;\n\tfor(auto [u,v,w]:G)\n\t\tif(merge(u,v)!=-1) ans+=w;\n\tprintf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\n#define INF 1e9\nstruct edge{\n    ll to,rev;\n    ll cap,cost;\n    edge(ll to, ll cap ,ll rev):to(to),cap(cap),rev(rev){}\n    edge(ll to, ll cap,ll cost,ll rev):to(to),cap(cap),cost(cost),rev(rev){}\n};\ntypedef vector<vector<edge> > graph;\nstruct Flow{\n\tgraph g;\n\tll MAXC = 1<<30;\n\tll n;\n\tvector<bool> used;\n\tvector<ll> prevv,preve,dist;\n\tFlow() {} \n\tFlow(ll _n) : g(_n),n(_n),used(_n,false),prevv(_n),preve(_n),dist(_n,MAXC){}\n\t// G[e.to][e.rev] で逆辺を操作できる\n\tvoid add_edge(ll from , ll to , ll cap){\n\t    g[from].push_back( edge(to,cap,g[to].size() ) );\n\t    g[to].push_back( edge(from,0,g[from].size()-1) );\n\t}\n\tvoid add_edge(ll from, ll to, ll cap,ll cost){\n\t    g[from].push_back( edge(to,cap,cost,g[to].size() ) );\n\t    g[to].push_back( edge(from, 0,-cost,g[from].size()-1) );\n\t}\n\t// Ford-Fulkerson 法による 最大流 O( F |E| )\n\t// Bellman-Ford 法による 最小費用流 O( F |V| |E| )\n\t// Verified: AOJ GRL_6_A (Maximum Flow)\n\t// 行き先と容量と逆辺のインデックスを記録する構造体\n\t// 通常のグラフの辺の構造体と異なるため注意\n\t// 最小費用流はもう少し速くできるので、改良しましょう\n\t// → ダイクストラが使えるようにポテンシャルを導入しよう\n\tll dfs(ll v,ll t , ll f){\n\t    if( v== t)return f;\n\t    used[v] = true;\n\t    for(int i=0;i< g[v].size();i++){\n\t\tedge &e = g[v][i];\n\t\tif(!used[e.to] && e.cap > 0){\n\t\t    ll d = dfs(e.to,t,min(f,e.cap) );\n\t\t    if( d > 0){\n\t\t\te.cap -= d;\n\t\t\tg[e.to][e.rev].cap  += d;\n\t\t\treturn d;\n\t\t    }\n\t\t}\n\t    }\n\t    return 0;\n\t}\n\tll max_flow(ll s,ll t){\n\t    ll flow = 0;\n\t    while(1){\n\t\tfill(used.begin(),used.end(),false);\n\t\tll f = dfs(s,t,INF);\n\t\tif( f== 0) return flow;\n\t\tflow += f;\n\t    }\n\t}\n\tll mincost_flow(ll s,ll t,ll f){\n\t    ll res = 0;\n\t    ll M = MAXC ;\n\t    while(f>0){\n\t\tfill(dist.begin(),dist.end(), M);\n\t\tdist[s] = 0;\n\t\tbool update = true;\n\t\twhile(update){\n\t\t    update = false;\n\t\t    for(ll i=0;i<n;i++){\n\t\t\tif(dist[i] == M) continue;\n\t\t\tfor(ll j=0;j<g[i].size();j++){\n\t\t\t    edge &e = g[i][j];\n\t\t\t    if(e.cap > 0 && dist[e.to] > dist[i] + e.cost){\n\t\t\t\tdist[e.to] = dist[i] + e.cost;\n\t\t\t\tprevv[e.to] = i;\n\t\t\t\tpreve[e.to] = j;\n\t\t\t\tupdate = true;\n\t\t\t    }\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif( dist[t] == M) return -1;\n\t\tll d = f;\n\t\tfor(ll i= t ; i!=s; i=prevv[i] ) d = min(d,g[ prevv[i] ][ preve[i] ].cap );\n\t\tf -= d;\n\t\tres += d*dist[t];\n\t\tfor(ll i= t ; i!=s; i=prevv[i] ){\n\t\t    edge &e = g[prevv[i] ][preve[i]];\n\t\t    e.cap -= d;\n\t\t    g[i][e.rev].cap += d;\n\t\t}\n\t    }\n\t    return res;\n\t}\n\t // ポテンシャルの導入により、ダイクストラ法で最小費用流を解く\n\t // [仮定している条件]\n\t //     1. グラフに負の閉路が存在しない (流量の 0 初期化のため)\n\t //        もし存在するならベルマンフォードで負の閉路を見つけ\n\t //        そこに流せるだけ流してスタート\n\t //     2. グラフに負の辺が存在しない (pot_0 の計算可能性)\n\t //     もし存在する場合は最初のみベルマンフォードを使う必要あり\n\tll fast_mincost_flow(ll s,ll t,ll f){\n\t    ll res = 0, M = MAXC;\n\t    vector<ll> pot(n);\n\t    while( f > 0 ){\n\t\tpriority_queue<mp,vector<mp>,greater<mp> > q;\n\t\tfill(dist.begin(),dist.end(),M);\n\t\tdist[s] = 0;\n\t\tq.push( mp(0,s) );\n\t\twhile(!q.empty()){\n\t\t    mp now = q.top();\n\t\t    q.pop();\n\t\t    ll v = now.second;\n\t\t    ll cost = now.first;\n\t\t    if( dist[v] < cost ) continue;\n\t\t    for(ll i=0;i<g[v].size();i++){\n\t\t\tedge &e = g[v][i];\n\t\t\tif( e.cap > 0 && dist[e.to] > dist[v] + e.cost + pot[v] - pot[e.to] ){\n\t\t\t    dist[e.to] = dist[v] + e.cost + pot[v] - pot[e.to];\n\t\t\t    prevv[e.to] = v;\n\t\t\t    preve[e.to] = i;\n\t\t\t    q.push( mp(dist[e.to],e.to) );\n\t\t\t}\n\t\t    }\n\t\t}\n\t\tif( dist[t] == M ) return -1;\n\t\tfor(ll i = 0; i< n;i++)pot[i] += dist[i];\n\t\tll d = f;\n\t\tfor(ll i = t; i!=s; i= prevv[i] ) d = min(d,g[prevv[i]][preve[i]].cap);\n\t\tf-=d;\n\t\tres += d*pot[t];\n\t\tfor(ll i = t; i!=s; i=prevv[i] ){\n\t\t    edge &e = g[prevv[i] ][preve[i]];\n\t\t    e.cap -= d;\n\t\t    g[i][e.rev].cap += d;\n\t\t}\n\t    }\n\t    return res;\n\t}\n};\n\nint main(){\n    ll n,h,w;\n    cin>>n>>h>>w;\n    vector<ll> r(n),c(n),a(n);\n    for(int i=0;i<n;i++)cin>>r[i]>>c[i]>>a[i];\n    Flow f(w+h+n+2);\n    ll s = 0,t = w+h+n+1;\n    for(int i=1;i<=w+h;i++){\n\tf.add_edge(s,i,1,0);\n    }\n    for(int i=1;i<=n;i++){\n\tf.add_edge(w+h+i,t,1,0);\n    }\n    for(int i=0;i<n;i++){\n\tf.add_edge(c[i],w+h+1+i,1,-a[i]);\n\tf.add_edge(w+r[i],w+h+1+i,1,-a[i]);\n    }\n    cout<<-f.fast_mincost_flow(s,t,h+w)<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n#define S static\n\n#define rep(i,n) for(ll i=0LL;i<n;++i)\n#define srep(i,s,n) for(ll i=s;i<n;++i)\n#define rrep(i,n) for(ll i=n-1LL;i>=0LL;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CIN(x) do { \\\n    assert(!cin.eof()); \\\n    cin >> x; \\\n    assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T>>;\n\n///////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename TT, typename T>\nT get_m(M<TT, T> &m, TT k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename TT, typename T>\nvoid incr_m(M<TT, T> &m, TT k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct BIT\n{\n    ll *tree;\n    ll size;\n\n    BIT(ll n, ll init) {\n        tree = new ll[n+1];\n        size = n;\n        this->init(init);\n    }\n\n    void init(ll init) {\n        memset(tree, 0, sizeof(ll) * (size+1));\n        rep (i0, size) {\n            ll idx = i0 + 1LL;\n            while (idx <= size) {\n                tree[idx] += init;\n                idx += (idx & (-idx));\n            }\n        }\n    }\n\n    // idx is 1 origin\n    void add(ll idx, ll x) {\n        assert(idx > 0LL);\n        while (idx <= size) {\n            tree[idx] += x;\n            idx += (idx & (-idx));\n        }\n    }\n\n    // idx is 1 origin\n    ll sum(ll idx) {\n        assert(idx > 0LL);\n        ll ret = 0LL;\n        while (idx > 0LL) {\n            ret += tree[idx];\n            idx -= (idx & (-idx));\n        }\n        return ret;\n    }\n};\n\nstruct MaxFlow {\n    V<ll> links[1005];\n    ll capacities[1005][1005];\n    ll nodes;\n\n    MaxFlow(ll nodes) {\n        // i == 0       --> S\n        // i == nodes+1 --> T\n        rep (i, nodes+2LL) links[i].clear();\n        memset(capacities, 0, sizeof(capacities));\n        this->nodes = nodes;\n    }\n\n    void add_path(ll a, ll b, ll capacity) {\n        links[a].pb(b);\n        links[b].pb(a);\n        capacities[a][b] = capacity;\n        capacities[b][a] = 0LL;\n    }\n\n    ll solve(void) {\n        deque<V<ll>> q;\n        ll ret = 0LL;\n\n        for ( ; ; q.clear()) {\n\n            V<ll> start;\n            start.pb(0);\n            q.push_front(start);\n\n            bool checked[nodes+2];\n            memset(checked, 0, sizeof(checked));\n\n            V<ll> found;\n\n            for ( ; !(q.empty()); ) {\n                V<ll> path = q.front(); q.pop_front();\n                ll last = path[path.size()-1];\n\n                if (checked[last]) continue;\n                if (last == nodes+1) {\n                    found = path;\n                    break;\n                }\n\n                checked[last] = true;\n                for (auto next : (links[last])) {\n                    if (capacities[last][next] == 0) continue;\n                    V<ll> newpath(path);\n                    newpath.pb(next);\n                    q.push_front(newpath);\n                }\n            }\n\n            if (found.size() == 0) {\n                break;\n            }\n            else {\n                ll flowcount = capacities[found[0]][found[1]];\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    flowcount = min(flowcount, capacities[src][dst]);\n                }\n                rep (i, found.size()-1) {\n                    ll src = found[i];\n                    ll dst = found[i+1];\n                    capacities[src][dst] -= flowcount;\n                    capacities[dst][src] += flowcount;\n                }\n                ret += flowcount;\n            }\n        }\n\n        return ret;\n    }\n};\n\ntemplate <typename T>\nstruct SegmentTree {\n    T *nodes;\n    t2 *ranges;  // [start, end)\n    ll nodecount;\n    ll itemcount;\n    T unit;\n    T (*op)(T, T);\n\n    SegmentTree(ll itemcount, T unit, T op(T, T)) {\n        ll orig_itemcount = itemcount;\n        this->itemcount = 1LL;\n        while (this->itemcount < orig_itemcount) this->itemcount *= 2LL;\n        nodecount = this->itemcount * 2 - 1;\n        nodes = new T[nodecount];\n        ranges = new t2[nodecount];\n        this->unit = unit;\n        this->op = op;\n\n        ll start = 0LL;\n        ll end = this->itemcount;\n        ll len = this->itemcount;\n\n        rep (i, nodecount) {\n            nodes[i] = unit;\n            ranges[i] = t2(start, end);\n            if (end >= this->itemcount) {\n                len /= 2LL;\n                start = 0LL;\n                end = len;\n            }\n            else {\n                start = end;\n                end = start + len;\n            }\n        }\n    }\n\n    void update(ll k, T v) {\n        ll idx = k + itemcount - 1LL;\n        nodes[idx] = v;\n        idx = (idx - 1LL) / 2LL;\n\n        for ( ; idx >= 0; idx = (idx - 1LL) / 2LL) {\n            nodes[idx] = op(nodes[idx * 2LL + 1LL],\n                            nodes[idx * 2LL + 2LL]);\n            if (!idx) break;\n        }\n    }\n\n    // query to [start, end)\n    T query(ll start, ll end) const {\n        return _query(start, end, 0LL);\n    }\n\n    T _query(ll start, ll end, ll idx) const {\n        ll rstart = get<0>(ranges[idx]);\n        ll rend = get<1>(ranges[idx]);\n\n        if (start <= rstart && rend <= end) {\n            return nodes[idx];\n        }\n        if (rend <= start || end <= rstart) {\n            return unit;\n        }\n        T left = _query(start, end, idx * 2LL + 1LL);\n        T right = _query(start, end, idx * 2LL + 2LL);\n        return op(left, right);\n    }\n\n};\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(auto &v, ll count)\n{\n    for (ll i = 0LL; i < count ; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(auto &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nT min(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = min(ret, i);\n    return ret;\n}\n\ntemplate <typename T>\nT max(const V<T> v)\n{\n    T ret = v[0];\n    for (auto i : v) ret = max(ret, i);\n    return ret;\n}\n\nll absll(ll x)\n{\n    if (x < 0) return -x;\n    return x;\n}\n\nll mod_mlt(ll x, ll y, ll mod)\n{\n    ll ret = 0LL;\n    x %= mod;\n\n    while (y) {\n        if (y & 1LL) {\n            ret += x;\n            ret %= mod;\n        }\n        y >>= 1;\n        x <<= 1;\n        x %= mod;\n    }\n\n    return ret;\n}\n\n// O(log(exp))\nll mod_pow(ll base, ll exp, ll mod)\n{\n    ll ret = 1LL;\n\n    for ( ; exp; ) {\n        if (exp & 1LL) {\n            ret *= base;\n            ret %= mod;\n        }\n        base = (base * base) % mod;\n        exp >>= 1;\n    }\n\n    return ret;\n}\n\n// O(log(mod))\nll mod_inv(ll x, ll mod)\n{\n    // available only when mod is prime\n    return mod_pow(x, mod - 2LL, mod);\n}\n\nll gcm(ll x, ll y)\n{\n    while (y != 0) {\n        ll z = x % y;\n        x = y;\n        y = z;\n    }\n    return x;\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\nvoid get_divisors(V<ll> &retlist, ll x)\n{\n    for (ll i = 1LL; i < sqrt(x) + 3LL; ++i) {\n        if (x % i == 0LL) {\n            retlist.push_back(i);\n            retlist.push_back(x / i);\n        }\n    }\n}\n\n// returns factors and 1\nvoid get_factors(V<ll> &retlist, ll x)\n{\n    retlist.pb(1LL);\n    for (ll i = 2LL; i < (ll)(sqrt(x)) + 3LL; ++i) {\n        while (x % i == 0LL) {\n            retlist.pb(i);\n            x /= i;\n        }\n    }\n    retlist.pb(x);\n}\n\nbool is_prime(ll x)\n{\n    V<ll> factors, factors2;\n\n    get_factors(factors, x);\n\n    for (auto factor : factors) {\n        if (factor > 1) factors2.pb(factor);\n    }\n\n    return factors2.size() == 1 && x == factors2[0];\n}\n\ntemplate <typename T>\nvoid intersection(const set<T> &a, const set<T> &b,\n                  set<T> &result)\n{\n    set_intersection(ALL(a), ALL(b), inserter(result, result.end()));\n}\n\null combination(ll x, ll y)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ull ret = 1LL;\n    for (ll i = 0LL; i < y; ++i) {\n        ret *= x--;\n        ret /= (i + 1LL);\n    }\n\n    return ret;\n}\n\null mod_combination(ll x, ll y, ll mod)\n{\n    if (y > x / 2LL) y = x - y;\n\n    ll ret = 1;\n\n    for (ll i = 0LL; i < y; ++i) {\n        ret = (ret * x--) % mod;\n        ret = (ret * mod_inv(i + 1LL, mod)) % mod;\n    }\n\n    return ret;\n}\n\nvoid make_perms(ll perms[], ll perm_invs[], ll size, ll mod)\n{\n    perms[0] = 1LL;\n    srep (i, 1, size) {\n        perms[i] = perms[i-1] * i;\n        perms[i] %= mod;\n   }\n\n    rep (i, size) {\n        perm_invs[i] = mod_inv(perms[i], mod);\n    }\n}\n\n#if 0\nS V<ll> edgelist[n+1];\n#endif\nvoid make_edgelist(const V<t2> &srclist, V<ll> edgelist[])\n{\n    for (auto src : srclist) {\n        ll a = get<0>(src);\n        ll b = get<1>(src);\n        edgelist[a].pb(b);\n        edgelist[b].pb(a);\n    }\n}\n\n#if 0\nS ll parents[n+1];\nS V<ll> children[n+1];\nS ll levels[n+1];\n#endif\nvoid make_parental_relation(const V<ll> edgelist[], ll root, ll n,\n                            ll parents[], V<ll> children[], ll levels[])\n{\n    queue<ll> q;\n    bool checked[n+1];\n\n    memset(checked, 0, sizeof(checked));\n\n    q.push(root);\n    checked[root] = true;\n    parents[root] = root;\n    levels[root] = 0LL;\n\n    for ( ; !(q.empty()); ) {\n        ll now = q.front(); q.pop();\n        for (auto next : edgelist[now]) {\n            if (checked[next]) continue;\n            q.push(next);\n            checked[next] = true;\n            parents[next] = now;\n            children[now].pb(next);\n            levels[next] = levels[now] + 1LL;\n        }\n    }\n}\n\nvoid make_subtree_sizes(const ll child_count[], const ll parents[],\n                        ll subtree_sizes[], ll n)\n{\n    ll remain_count[n+1LL];\n    memcpy(remain_count, child_count, sizeof(remain_count));\n\n    queue<ll> q;\n    srep (node, 1LL, n+1LL) {\n        subtree_sizes[node] = 1LL;\n        if (remain_count[node] > 0) continue;\n        q.push(node);\n    }\n\n    while (!q.empty()) {\n        ll node = q.front(); q.pop();\n        ll parent = parents[node];\n        if (node == parent) continue;\n        remain_count[parent]--;\n        subtree_sizes[parent] += subtree_sizes[node];\n        if (remain_count[parent] == 0LL) q.push(parent);\n    }\n}\n\nvoid get_centroids(const V<ll> children[], const ll subtree_sizes[],\n                   ll root, ll n, V<ll> &centroids)\n{\n    queue<ll> q;\n    q.push(root);\n\n    while (!q.empty()) {\n        ll now = q.front(); q.pop();\n        bool is_centroid = true;\n        for (auto child : children[now]) {\n            q.push(child);\n            if (subtree_sizes[child] > n / 2LL) is_centroid = false;\n        }\n        if (n - subtree_sizes[now] > n / 2LL) is_centroid = false;\n        if (is_centroid) centroids.pb(now);\n    }\n\n    assert(centroids.size() == 1LL || centroids.size() == 2LL);\n}\n\n#define POW_ANCESTOR_MAXSIZE   20\n\n// preprocess for get_common_ancestor()\nvoid make_pow_ancestor(const ll parent[], ll n,\n                       ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE])\n{\n    rep (i, n) pow_ancestor[i+1][0] = parent[i+1];\n\n    for (int pow2 = 1; pow(2, pow2) <= n; ++pow2) {\n        rep (i0, n) {\n            int i = i0+1;\n            ll prev = pow_ancestor[i][pow2-1];\n            pow_ancestor[i][pow2] = pow_ancestor[prev][pow2-1];\n        }\n    }\n}\n\nll get_common_ancestor(ll n, ll x, ll y,\n                       const ll (*pow_ancestor)[POW_ANCESTOR_MAXSIZE],\n                       const ll level[])\n{\n    if (level[x] < level[y]) {\n        ll diff = level[y] - level[x];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            y = pow_ancestor[y][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n    else {\n        ll diff = level[x] - level[y];\n        for ( ; diff; ) {\n            ll bit = diff & -diff;\n            x = pow_ancestor[x][(int)log2(bit)];\n            diff -= bit;\n        }\n    }\n\n    if (x == y) return x;\n\n    rrep (i, (int)log2(n)+1) {\n        if (pow_ancestor[x][i] != pow_ancestor[y][i]) {\n            x = pow_ancestor[x][i];\n            y = pow_ancestor[y][i];\n        }\n    }\n\n    return pow_ancestor[x][0];\n}\n\nvoid kmp_init(const string &pattern, ll kmp_next[])\n{\n    kmp_next[0] = -1LL;\n\n    ll plen = pattern.size();\n    ll prefix_end = -1;\n\n    rep (suffix_end, pattern.size()) {\n        while (prefix_end >= 0 && pattern[suffix_end] != pattern[prefix_end]) {\n            prefix_end = kmp_next[prefix_end];\n        }\n        kmp_next[suffix_end+1] = ++prefix_end;\n    }\n\n    kmp_next[0] = 0LL;\n}\n\n// founds ... list of text's idx of match position. start position idx.\nvoid kmp_search(const string &text, const string &pattern, const ll kmp_next[],\n                V<ll> &founds)\n{\n    ll text_size = text.size();\n    ll pattern_size = pattern.size();\n    ll text_start = 0LL;\n    ll pattern_idx = 0LL;\n\n    assert(pattern_size <= text_size);\n\n    for ( ; ; ) {\n        if (text_start + pattern_idx >= text_size) break;\n        if (pattern_idx >= pattern_size) break;\n\n        if (text[text_start+pattern_idx] == pattern[pattern_idx]) {\n            pattern_idx++;\n            if (pattern_idx == pattern_size) {\n                founds.pb(text_start);\n                pattern_idx = kmp_next[pattern_idx];\n                text_start += (pattern_size - pattern_idx);\n            }\n        }\n\n        else {\n            text_start += (pattern_idx - kmp_next[pattern_idx]);\n            pattern_idx = kmp_next[pattern_idx];\n            if (pattern_idx == 0LL && text[text_start] != pattern[0]) {\n                text_start++;\n            }\n        }\n    }\n}\n\nvoid z_algorithm(ll matchcounts[], const string &str)\n{\n    ll n = str.size();\n    ll base_idx = 0LL;\n    memset(matchcounts, 0, sizeof(ll) * n);\n\n    srep (idx, 1LL, n) {\n\n        ll checked_len = base_idx + matchcounts[base_idx];\n\n        if (idx + matchcounts[idx-base_idx] < checked_len) {\n            matchcounts[idx] = matchcounts[idx-base_idx];\n            continue;\n        }\n\n        ll start = max(0LL, base_idx + matchcounts[base_idx] - idx);\n        matchcounts[idx] = start;\n        srep (cmp, start, n-idx) {\n            if (str[cmp] == str[idx+cmp]) matchcounts[idx]++;\n            else break;\n        }\n        base_idx = idx;\n\n    }\n\n    matchcounts[0] = n;\n}\n\nvoid _debug_print(auto x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n        << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename TT, typename T>\nvoid _debug_print(const M<TT, T> &xlist)\n{\n    for (auto x : xlist) {\n        TT k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n    struct tm *tm = localtime(&tv.tv_sec);\n    printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n           prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n///////////////////////////////////////////////////////////////////////////////\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n    _main();\n    return 0;\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n    ll h; llin(h);\n    ll w; llin(w);\n    V<t3> rcalist; llinl3(rcalist, n);\n\n#define BORDER (1e5+2)\n\n    V<t3> edges;\n    for (auto rca : rcalist) {\n        ll r = get<0>(rca);\n        ll c = get<1>(rca);\n        ll a = get<2>(rca);\n        edges.pb(t3(a, r, c + BORDER));\n    }\n\n    sort_reverse(edges);\n\n    UnionFind uf(200010);\n    ll ans = 0LL;\n    S ll vcnt[200010];\n    rep (i, 200010) vcnt[i] = 1;\n    S ll ecnt[200010];\n    memset(ecnt, 0, sizeof(ecnt));\n    for (auto edge : edges) {\n        ll a = get<0>(edge);\n        ll v1 = get<1>(edge);\n        ll v2 = get<2>(edge);\n        ll root1 = uf.root(v1);\n        ll root2 = uf.root(v2);\n        if (root1 == root2) {\n            if (vcnt[root1] == ecnt[root1]) continue;\n            ecnt[root1]++;\n            ans += a;\n        }\n        else {\n            ll vcnt1 = vcnt[root1];\n            ll vcnt2 = vcnt[root2];\n            ll ecnt1 = ecnt[root1];\n            ll ecnt2 = ecnt[root2];\n            if (vcnt1 + vcnt2 == ecnt1 + ecnt2) continue;\n            uf.unite(v1, v2);\n            ll newroot = uf.root(v1);\n            vcnt[newroot] = vcnt1 + vcnt2;\n            ecnt[newroot] = ecnt1 + ecnt2 + 1LL;\n            ans += a;\n        }\n    }\n\n    cout << ans << endl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <tuple>\nusing namespace std;\n\nclass union_find{\npublic:\n  vector<int> uf;\n  union_find(int n){\n    uf=vector<int>(n);\n    for(int i=0;i<n;i++){\n      uf[i]=-1;\n    }\n  }\n  int root(int i)\n  {\n    return uf[i]<0?i:uf[i]=root(uf[i]);\n  }\n  void unite(int i,int j)\n  {\n    if(-uf[i]<-uf[j]){\n      uf[i]=j;\n    }\n    else if(-uf[i]>-uf[j]){\n      uf[j]=i;\n    }\n    else{\n      uf[i]=j;\n      uf[j]--;\n    }\n  }\n};\n\nint main()\n{\n  int n,h,w;\n  scanf(\"%d%d%d\",&n,&h,&w);\n  vector<tuple<long long,int,int> > E(n);\n  for(int i=0;i<n;i++){\n    int r,c;\n    long long A;\n    scanf(\"%d%d%lld\",&r,&c,&A);\n    r--,c--;\n    E[i]=make_tuple(A,r,h+c);\n  }\n  sort(E.begin(),E.end());\n  long long ans=0ll;\n  union_find uf(h+w);\n  vector<int> tree(h+w,true);\n  for(int i=n-1;i>=0;i--){\n    long long A=get<0>(E[i]);\n    int a=get<1>(E[i]),b=get<2>(E[i]);\n    a=uf.root(a),b=uf.root(b);\n    if(a!=b&&(tree[a]||tree[b])){\n      bool t=(tree[a]&&tree[b]);\n      uf.unite(a,b);\n      tree[uf.root(a)]=t;\n      ans+=A;\n      //printf(\"%d %d %lld\\n\",a,b,A);\n    }\n    else if(tree[a]){\n      tree[a]=false;\n      ans+=A;\n      //printf(\"%d %d %lld\\n\",a,b,A);\n    }\n  }\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define REP(i,n) for(int i=1;i<=(n);i++)\n#define mp make_pair\n#define pb push_back\n#define fst first\n#define snd second\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nconst int maxn=100005;\nint n,r,c;\npair<int,pii>a[maxn];\nll ans;\n\nnamespace Dsu{\n\tint f[maxn*3],cnt1[maxn*3],cnt2[maxn*3];\n\tvoid init(){\n\t\tREP(i,n+r+c)f[i]=i;\n\t\tREP(i,n)cnt1[i]=1;\n\t\tfor(int i=n+1;i<=n+r+c;i++)cnt2[i]=1;\n\t}\n\tint find(int x){\n\t\treturn f[x]==x?x:f[x]=find(f[x]);\n\t}\n\tvoid merge(int x,int y){\n\t\tx=find(x);y=find(y);\n\t\tif(x==y)return;\n\t\tf[x]=y;\n\t\tcnt1[y]+=cnt1[x];\n\t\tcnt2[y]+=cnt2[x];\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&r,&c);\n\tREP(i,n)scanf(\"%d%d%d\",&a[i].snd.fst,&a[i].snd.snd,&a[i].fst);\n\tsort(a+1,a+1+n);\n\tDsu::init();\n\tfor(int i=n;i>=1;i--){\n\t\tint u=Dsu::find(a[i].snd.fst+n),v=Dsu::find(a[i].snd.snd+n+r),cur1=0,cur2=0;\n\t\tif(u==v)cur1=Dsu::cnt1[u],cur2=Dsu::cnt2[u];\n\t\telse cur1=Dsu::cnt1[u]+Dsu::cnt1[v],cur2=Dsu::cnt2[u]+Dsu::cnt2[v];\n\t\tcur1++;\n\t\tif(cur1>cur2)continue;\n\t\tans+=a[i].fst;\n\t\tDsu::merge(i,u);\n\t\tDsu::merge(i,v);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <random>\n\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef double ld;\n//#define ll __int128\n//#define int ll\n//#define int ll\n//#define char ll\n#define double ld\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<vvc> vvvc;\ntypedef pair<int, int> pii;\ntypedef pair<pii, pii> piii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<short> vs;\ntypedef vector<vs> vvs;\ntypedef vector<vvs> vvvs;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<vvl> vvvl;\ntypedef vector<ld> vld;\ntypedef vector<vld> vvld;\ntypedef vector<vvld> vvvld;\ntypedef vector<string> vst;\ntypedef vector<vst> vvst;\ntypedef pair<ld, ld> pld;\n\n#define inmin(a, b) a = min(a, (b))\n#define inmax(a, b) a = max(a, (b))\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n#define sqr(x) ((x) * (x))\n#define fori(i, n) for(int i = 0; i < int(n); ++i)\n#define SZ(a) ((int)((a).size()))\n#define triple(T) tuple<T, T, T>\n#define quad(T) tuple<T, T, T, T>\n#define watch(x) cerr << (#x) << \" = \" << (x) << endl;\n\n#ifdef MAX_HOME\n#define cerr cout\n#else\n#define cerr if (false) cerr\n#endif\n\nconst double PI = 2 * acos(0.0);\n#define rand shittttty_shit\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nmt19937_64 rng_64(chrono::steady_clock::now().time_since_epoch().count());\n\nconst string DIGITS = \"0123456789\";\nconst string ALPH = \"abcdefghijklmnopqrstuvwxyz\";\n\n\ntemplate<class T0, class T1>\ninline ostream &operator<<(ostream &out, pair<T0, T1> &a) {\n    return out << \"{\" << a.first << \", \" << a.second << \"}\";\n}\n\ntemplate<class T0, class T1>\ninline istream &operator>>(istream &in, pair<T0, T1> &a) {\n    return in >> a.first >> a.second;\n}\n\ntemplate<class T0, class T1, class T2>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \"}\";\n}\n\ntemplate<class T0, class T1, class T2, class T3>\ninline ostream &operator<<(ostream &out, tuple<T0, T1, T2, T3> &a) {\n    return out << \"{\" << get<0>(a) << \", \" << get<1>(a) << \", \" << get<2>(a) << \", \" << get<3>(a) << \"}\";\n}\n\ntemplate<class T>\ninline ostream &operator<<(ostream &out, vector<T> &a) {\n    out << \"[\";\n    fori (i, a.size())out << a[i] << vector<string>{\", \", \"]  \"}[i + 1 == a.size()];\n    return out;\n}\n\n\nvoid smain();\n\n\nsigned main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    cout.tie(0);\n#ifdef MAX_HOME\n    freopen(\"input.txt\", \"r\", stdin);\n    clock_t start = clock();\n#endif\n    cout << setprecision(12) << fixed;\n    smain();\n#ifdef MAX_HOME\n    cout << \"\\n\\nTOTAL EXECUTION TIME: \" << float(clock() - start) / CLOCKS_PER_SEC << endl;\n#endif\n    return 0;\n}\n\nconst int N = 2e5 + 10;\n\nstruct DSU {\n    int parent[N];\n    int sz[N];\n    bool con[N];\n\n    void make_set(int v) {\n        parent[v] = v;\n        sz[v] = 1;\n        con[v] = false;\n    }\n\n    int find_set(int v) {\n        return parent[v] == v ? v : parent[v] = find_set(parent[v]);\n    }\n\n    bool union_sets(int u, int v) {\n        u = find_set(u);\n        v = find_set(v);\n        if (u == v) {\n            if (con[v])\n                return false;\n            con[v] = true;\n            return true;\n        }\n        if (sz[u] < sz[v])\n            swap(u, v);\n        if (con[v] && con[u])\n            return false;\n        sz[u] += sz[v];\n        parent[v] = u;\n        con[u] |= con[v];\n        return true;\n    }\n};\n\nvoid smain() {\n    int n, h, w;\n    cin >> n >> h >> w;\n    DSU dsu;\n    fori (i, h + w) {\n        dsu.make_set(i);\n    }\n    vector<pair<int, pii>> edge(n);\n    fori (i, n) {\n        cin >> edge[i].second >> edge[i].first;\n        edge[i].first *= -1;\n        edge[i].second.first--, edge[i].second.second += h - 1;\n    }\n    sort(ALL(edge));\n    ll ans = 0;\n    for (auto e : edge) {\n        if (dsu.union_sets(e.second.first, e.second.second)) {\n            ans += e.first;\n        }\n    }\n    cout << -ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n\n  int N,H,W; cin>>N>>H>>W;\n  struct Panel {\n    int r,c,a;\n  };\n  vector<Panel> panels;\n  for (auto& p : panels) {\n    cin >> p.r >> p.c >> p.a;\n  }\n  sort(panels.begin(), panels.end(), [](auto l, auto r) {return l.a > r.a;});\n  \n  long ans = 0;\n  set<int> sr, sc;\n  for (auto p : panels) {\n    auto cr = sr.count(p.r);\n    auto cc = sc.count(p.c);\n    if (cr == 1 and cc == 1)\n      continue;\n    if (cr == 0 and cc == 0) {\n      sr.insert(p.r);\n      sc.insert(p.c);\n    } else if (cr == 1 and cc == 0) {\n      sc.insert(p.c);\n    } else { // 0, 1\n      sr.insert(p.r);\n    }\n    ans += p.a;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define DEBUGGING\n#include <bits/stdc++.h>\nusing namespace std;\n#define endl '\\n'\n#define ALL(V) (V).begin(), (V).end()\n#define ALLR(V) (V).rbegin(), (V).rend()\n\ntemplate <typename T> using V = vector<T>;\ntemplate <typename T> using VV = V<V<T>>;\nusing ll = int64_t;\nusing ull = uint64_t;\nusing PLL = pair<ll, ll>;\n\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return max(low, min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { t = clamp(t, low, high); }\n\nnamespace init__ {\n\nstruct InitIO {\n    InitIO() {\n        cin.tie(nullptr);\n        ios_base::sync_with_stdio(false);\n        cout << fixed << setprecision(30);\n    }\n} init_io;\n\n}\n\n#ifdef DEBUGGING\n// #include \"../debug/debug.cpp\"\n#include \"../../debug/debug.cpp\"\n#else\n#define DEBUG(...) 0\n#define DEBUG_SEPARATOR_LINE 0\n#endif\n\ntemplate <typename T>\nT make_v(T init) { return init; }\n\ntemplate <typename T, typename... Tail>\nauto make_v(T init, size_t s, Tail... tail) {\n#define rec make_v(init, tail...)\n    return V<decltype(rec)>(s, rec);\n#undef rec\n}\n\nstruct UnionFind {\n    V<ll> rank;\n    V<ll> parent;\n    V<bool> cycle;\n\n    UnionFind(ll N) : rank(N, 0), parent(N), cycle(N) {\n        iota(parent.begin(), parent.end(), 0ll);\n    }\n\n    ll find(ll child) {\n        return (child == parent[child] ? child : parent[child] = find(parent[child]));\n    }\n\n    void unit(ll x, ll y) {\n        ll px = find(x);\n        ll py = find(y);\n        if(px == py) {\n            cycle[px] = true;\n            return;\n        }\n        if(rank[px] < rank[py]) {\n            swap(px, py);\n        }\n        parent[py] = px;\n        rank[px] += (rank[px] == rank[py]);\n        if(cycle[py]) cycle[px] = true;\n    }\n\n    bool is_cycle(ll x) { return cycle[find(x)]; }\n\n    bool same(ll x, ll y) {\n        return (find(x) == find(y));\n    }\n};\n\nusing TLL = tuple<ll, ll, ll>;\n\nstruct Solver {\n    ll N, H, W;\n    V<ll> scores;\n    V<TLL> cards;\n    UnionFind uf;\n\n    Solver(ll arg_N, ll arg_H, ll arg_W)\n        : N(arg_N), H(arg_H), W(arg_W), scores(arg_N), cards(arg_N), uf(arg_H + arg_W)\n    {\n        for(ll i = 0; i < N; i++) {\n            ll h, w;\n            cin >> h >> w;\n            h--; w--;\n            cards[i] = make_tuple(i, h, w);\n            cin >> scores[i];\n        }\n    }\n\n    ll solve() {\n        sort(ALL(cards), \n             [&](TLL u, TLL v) {\n                 ll a, b, c, d, e, f;\n                 tie(a, b, c) = u;\n                 tie(d, e, f) = v;\n                 return scores[a] > scores[d];\n             });\n        ll ret = 0;\n        for(auto &&ele : cards) {\n            ll idx, h, w;\n            tie(idx, h, w) = ele;\n            ll id_h = h;\n            ll id_w = w + H;\n            if(uf.is_cycle(id_h) && uf.is_cycle(id_w)) continue;\n            uf.unit(id_h, id_w);\n            ret += scores[idx];\n        }\n        return ret;\n    }\n};\n\nint main() {\n    ll N, H, W;\n    cin >> N >> H >> W;\n    cout << Solver(N, H, W).solve() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e5+5;\nint a[maxn],b[maxn];\nint n,h,w;\nint cnt=0;\nll sum=0;\nstruct pp\n{\n\tint x,y,z;\n}s[maxn];\nbool cmpz(pp a,pp b)\n{\n\treturn a.z>b.z;\n}\n/*void find(int i,int z)\n{\n\tint mh=0,mw=0;\n\tint ow,oh;\n\tfor(int j=i+1;j<n;j++)\n\t{\n\t\tif(s[j].x==s[i].x&&mh==0&&a[s[i].x]==1)\n\t\t{\n\t\t\tmh=s[j].z;\n\t\t\toh=j;\n\t\t}\n\t\tif(s[j].y==s[i].y&&mw==0&&b[s[i].x]==1)\n\t\t{\n\t\t\tmw=s[j].z;\n\t\t\tow=j;\n\t\t}\n\t\tif(mh!=0&&mw!=0) break;\n\t}\n\tcout<<mh<<\" \"<<mw<<endl;\n\tif(mh>mw)\n\t{\n\t\tb[s[i].y]--;\n\t\tcout<<s[i].z<<endl;\n\t\tsum+=(s[i].z);\n\t\tcnt++;\n\t}\n\telse if(mh<mw)\n\t{\n\t\ta[s[i].x]--;\n\t\tcout<<s[i].z<<endl;\n\t\tsum+=(s[i].z);\n\t\tcnt++;\n\t}\n\telse \n\t{\n\t\ta[s[i].x]--;\n\t\tb[s[i].y]--;\n\t\tcout<<s[i].z<<endl;\n\t\tsum+=(s[i].z);\n\t\tcout<<mh<<endl;\n\t\tsum+=(mh);\n\t\ts[ow].z=0;\n\t\tcnt+=2;\n\t}\n}*/\nint main()\n{\n\tcin>>n>>h>>w;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>s[i].x>>s[i].y>>s[i].z;\n\t}\n\tfor(int i=1;i<=h;i++) a[i]=1;\n\tfor(int i=1;i<=w;i++) b[i]=1;\n\tsort(s,s+n,cmpz);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint mh=0,mw=0;\n\t    int ow,oh;\n\t    if(s[i].z==0) continue;\n\t    for(int j=i+1;j<n;j++)\n\t    {\n\t\t    if(s[j].x==s[i].x&&mh==0&&a[s[i].x]==1)\n\t\t    {\n\t\t\t   mh=s[j].z;\n\t\t\t   oh=j;\n\t\t    }\n\t\t    if(s[j].y==s[i].y&&mw==0&&b[s[i].y]==1)\n\t\t    {\n\t\t\t    mw=s[j].z;\n\t\t\t    ow=j;\n\t\t    }\n\t\t    if(mh!=0&&mw!=0) break;\n\t    }\n\t    //cout<<mh<<\" \"<<mw<<endl;\n\t    if(a[s[i].x]==0&&b[s[i].y]==0) \n\t    { \n\t\t     continue;\n\t    }\n\t    else if((mh>mw&&b[s[i].y]==1)||a[s[i].x]==0)\n\t    {\n\t\t    b[s[i].y]--;\n\t\t    //cout<<s[i].z<<endl;//\n\t\t    sum+=(s[i].z);\n\t\t    cnt++;\n\t    }\n\t    else if((mh<mw&&a[s[i].x]==1)||b[s[i].y]==0)\n\t    {\n\t\t    a[s[i].x]--;\n\t\t    //cout<<s[i].z<<endl;//\n\t\t    sum+=(s[i].z);\n\t\t    cnt++;\n\t    }\n\t    else if(mh==mw&&mh!=0&&b[s[i].y]==1&&a[s[i].x]==1)\n\t    {\n\t\t    a[s[i].x]--;\n\t\t    b[s[i].y]--;\n\t\t    //cout<<s[i].z<<endl;//\n\t\t    sum+=(s[i].z);\n\t\t    //cout<<mh<<endl;//\n\t\t    sum+=(mh);\n\t\t    s[ow].z=0;\n\t\t    cnt+=2;\n\t    }\n\t    if(cnt==(h+w)) break;\n\t}\n\tcout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <numeric>\nusing namespace std;\ntypedef long long int ll;\n\nstruct Edge{\n    int to,from; ll cost;\n    Edge(){}\n    Edge(int to,int from,ll cost):to(to),from(from),cost(cost){}\n};\nbool operator<(const Edge& x,const Edge& y){\n    return x.cost<y.cost;\n}\n\nstruct UnionFind{\n    vector<int> par,num;\n    vector<bool> done;\n    UnionFind(int n):par(n),num(n,1),done(n,false){\n        iota(par.begin(),par.end(),0);  //include<numeric>\n    }\n    int find(int v){\n        return (par[v]==v)?v:(par[v]=find(par[v]));\n    }\n    void unite(int u,int v){\n        u=find(u),v=find(v);\n        if(u==v)return;\n        if(num[u]<num[v])swap(u,v);\n        num[u]+=num[v];\n        par[v]=u;\n        done[u]=done[u]|done[v];\n    }\n    bool same(int u,int v){\n        return find(u) == find(v);\n    }\n    bool ispar(int v){\n        return v=find(v);\n    }\n    int size(int v){\n        return num[find(v)];\n    }\n};\n\nint main(){\n    int n,h,w; cin >> n >> h >> w;\n    vector<Edge> v;\n    for(int i=0;i<n;i++){\n        int r,c,a; cin >> r >> c >> a;\n        r--; c--;\n        v.push_back(Edge(r,c+h,a));\n    }\n    ll ans=0;\n    sort(v.begin(),v.end());\n    reverse(v.begin(),v.end());\n    UnionFind uf(h+w);\n\n    for(int i=0;i<n;i++){\n        if(!uf.same(v[i].from,v[i].to)){\n            if(uf.done[uf.find(v[i].from)]&&uf.done[uf.find(v[i].to)])continue;\n            uf.unite(v[i].from,v[i].to);\n            ans+=v[i].cost;\n        }\n        else{\n            if(!uf.done[uf.find(v[i].from)]){\n                uf.done[uf.find(v[i].from)]=true;\n                ans+=v[i].cost;\n            }\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=1e9;\nconst int MOD=1e9+7;\n//const int MOD=998244353;\nconst long long LINF=1e18;\n#define int long long\n//template\ntemplate <typename T>\nvoid fin(T a){\n  cout<<a<<endl;\n  exit(0);\n}\nstruct UnionFind{\n  int n,num;\n  vector<int> r,p,e;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),num(sz),e(sz,0),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) {e[x]++;return;}\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];e[x]+=e[y]+1;\n    p[y]=x;\n    num--;\n  }\n  int size(int x){  //頂点数\n    return r[find(x)];\n  }\n  int size2(int x){  //辺の数\n    return e[find(x)];\n  }\n  int count() const{\n    return num;\n  }\n};\n//main\nsigned main(){\n  int N,H,W;cin>>N>>H>>W;\n  typedef pair<int,int> P;\n  typedef pair<int,P> PP;\n  priority_queue<PP> que;\n  for(int i=0;i<N;i++){\n    int r,c,a;cin>>r>>c>>a;r--;c--;\n    que.push(PP(a,P(r,c+100000)));\n  }\n  int ans=0;\n  UnionFind uf(200000);\n  while(que.size()){\n    PP p=que.top();que.pop();\n    int a=p.first,u=p.second.first,v=p.second.second;\n    if(uf.same(u,v)){\n      if(uf.size2(u)<uf.size(v)){\n        uf.unite(u,v);\n        ans+=a;\n      }\n    }\n    else{\n      int p=uf.size(u)+uf.size(v);\n      int e=uf.size2(u)+uf.size2(v);\n      if(e<p){\n        uf.unite(u,v);\n        ans+=a;\n      }\n    }\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=1e5+7;\nint n,h,w;\nstruct node{\n    int a,r,c;\n    bool operator<(const node b)const{\n        return a>b.a;\n    }\n    void scan(){\n        scanf(\"%d%d%d\",&r,&c,&a);\n        c+=h;\n    }\n}ed[N];\nint fa[2*N];\nint find(int x){\n    return (fa[x]==x)?x:fa[x]=find(fa[x]);\n}\nint main(){\n    scanf(\"%d%d%d\",&n,&h,&w);\n    for(int i=0;i<=h+w;i++)fa[i]=i;\n    for(int i=0;i<n;i++)\n        ed[i].scan();\n    sort(ed,ed+n);\n    bool can[2*N];\n    for(int i=0;i<=h+w;i++)can[i]=1;\n    ll ans=0;\n    for(int i=0;i<n;i++){\n        if(find(ed[i].r)==find(ed[i].c)){\n            if(can[find(ed[i].r)]){\n                ans+=ed[i].a;\n                //cout<<ed[i].r<<' '<<ed[i].c-h<<' ';\n                //cout<<ed[i].a<<endl;\n                can[find(ed[i].r)]=0;\n            }\n            continue;\n        }\n        if(can[find(ed[i].r)]==0&&can[find(ed[i].c)]==0){\n            continue;\n        }\n        if(can[find(ed[i].r)]==0||can[find(ed[i].c)]==0){\n            can[find(ed[i].r)]=0;\n            can[find(ed[i].c)]=0;\n        }\n        fa[find(ed[i].r)]=find(ed[i].c);\n        ans+=ed[i].a;\n        //cout<<ed[i].r<<' '<<ed[i].c-h<<' ';\n        //cout<<ed[i].a<<endl;\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> ii;\ntypedef long long ll;\n\nconst int Maxn = 300005;\n\nint n, H, W;\nint R[Maxn], C[Maxn], A[Maxn];\nint seq[Maxn];\nbool tk[Maxn];\nvector <int> neigh[Maxn];\nll res;\n\nbool Less(const int &a, const int &b) { return A[a] > A[b]; }\n\nint Visit(int v)\n{\n    if (!tk[v]) return v;\n    while (!neigh[v].empty()) {\n        int g = Visit(neigh[v].back());\n        if (g == -1) neigh[v].pop_back();\n        else { tk[g] = true; tk[v] = false; return v; }\n    }\n    return -1;\n}\n\nint main()\n{\n    scanf(\"%d %d %d\", &n, &H, &W);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &R[i], &C[i], &A[i]);\n        seq[i] = i;\n    }\n    sort(seq, seq + n, Less);\n    for (int i = 0; i < n; i++) {\n        int ind = seq[i];\n        int v = Visit(R[ind]);\n        if (v != -1) { tk[v] = true; res += A[ind]; neigh[v].push_back(H + C[ind]); }\n        else {\n            v = Visit(H + C[ind]);\n            if (v != -1) { tk[v] = true; res += A[ind]; neigh[v].push_back(R[ind]); }\n        }\n    }\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*input\n13 5 6\n1 3 35902\n4 6 19698\n4 6 73389\n3 6 3031\n3 1 4771\n1 4 4784\n2 1 36357\n2 1 24830\n5 6 50219\n4 6 22645\n1 2 30739\n1 4 68417\n1 5 78537\n*/\n#include <bits/stdc++.h>\n#pragma GCC optimize(\"unroll-loops,no-stack-protector\")\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef pair<ld,ld> pdd;\n#define IOS ios_base::sync_with_stdio(0); cin.tie(0)\n#define ALL(a) a.begin(),a.end()\n#define SZ(a) ((int)a.size())\n#define F first\n#define S second\n#define REP(i,n) for(int i=0;i<((int)n);i++)\n#define eb emplace_back\n#define pb push_back\n#define MP(a,b) make_pair(a,b)\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define EL cout<<'\\n'\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& out,pair<T1,T2> P){\n\tout<<'('<<P.F<<','<<P.S<<')';\n\treturn out;\n}\ntemplate<typename T>\nostream& operator<<(ostream& out,vector<T> V){\n\tREP(i,SZ(V)) out<<V[i]<<((i!=SZ(V)-1)?\" \":\"\");\n\treturn out;\n}\n#define version 20190814\n//}}}\nconst ll maxn=300005;\nconst ll maxlg=20;\nconst ll INF64=1e18;\nconst int INF=0x3f3f3f3f;\nconst ll MOD=ll(1e9+7);\nconst ld PI=acos(-1);\nconst ld eps=1e-9;\n//const ll p=880301;\n//const ll P=31;\n\nll mypow(ll a,ll b){\n\tll res=1LL;\n\twhile(b){\n\t\tif(b&1) res=res*a%MOD;\n\t\ta=a*a%MOD;\n\t\tb>>=1;\n\t}\n\treturn res;\n}\n\nint dsu[maxn];\nint sz[maxn];\nint rcnt[maxn],ccnt[maxn];\n\nint find(int u){\n\tif(dsu[u]==u) return u;\n\treturn find(dsu[u]);\n}\n\nvoid mrg(int u,int v){\n\tif(u==v) return;\n\tif(sz[u]<sz[v]){\n\t\tsz[v]+=sz[u];\n\t\trcnt[v]+=rcnt[u];\n\t\tccnt[v]+=ccnt[u];\n\t\tdsu[u]=v;\n\t}\n\telse{\n\t\tsz[u]+=sz[v];\n\t\trcnt[u]+=rcnt[v];\n\t\tccnt[u]+=ccnt[v];\n\t\tdsu[v]=u;\n\t}\n}\n\nvoid unmrg(int u,int v){\n\tif(sz[u]<sz[v]){\n\t\tsz[v]-=sz[u];\n\t\trcnt[v]-=rcnt[u];\n\t\tccnt[v]-=ccnt[u];\n\t\tdsu[u]=u;\n\t}\n\telse{\n\t\tsz[u]-=sz[v];\n\t\trcnt[u]-=rcnt[v];\n\t\tccnt[u]-=ccnt[v];\n\t\tdsu[v]=v;\n\t}\n}\n\nbool check(int i){\n\ti=find(i);\n\tif(rcnt[i]+ccnt[i]<sz[i]) return 0;\n\treturn 1;\n}\n\nll n,h,w;\n\nvector<pair<ll,pll>> v;\nint rr[maxn],cc[maxn];\n\nint main(){\n\tIOS;\n\tcin>>n>>h>>w;\n\tREP(i,n){\n\t\tll a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tv.eb(c,MP(a,b));\n\t}\n\tsort(ALL(v));\n\treverse(ALL(v));\n\tll ans=0;\n\n\tREP(i,n) dsu[i]=i,sz[i]=rcnt[i]=ccnt[i]=1;\n\tREP(i,maxn) rr[i]=cc[i]=-1;\n\tREP(i,SZ(v)){\n\t\tll val=v[i].F;\n\t\tll x=v[i].S.F,y=v[i].S.S;\n\t\tbool fR=0,fC=0;\n\t\tif(rr[x]==-1){\n\t\t\trr[x]=i;\n\t\t\tfR=1;\n\t\t}\n\t\tif(cc[y]==-1){\n\t\t\tcc[y]=i;\n\t\t\tfC=1;\n\t\t}\n\t\tint tmp1,tmp2,tmp3,tmp4;\n\t\tif(rr[x]!=i){\n\t\t\ttmp1=find(i);\n\t\t\ttmp2=find(rr[x]);\n\t\t\tmrg(tmp1,tmp2);\n\t\t}\n\t\tif(cc[y]!=i){\n\t\t\ttmp3=find(i);\n\t\t\ttmp4=find(cc[y]);\n\t\t\tmrg(tmp3,tmp4);\n\t\t}\n\t\tif(!fR) rcnt[find(i)]--;\n\t\tif(!fC) ccnt[find(i)]--;\n\n\t\tif(check(i)){\n\t\t\tans+=val;\n\t\t}\n\t\telse{\n\t\t\tif(!fC) ccnt[find(i)]++;\n\t\t\tif(!fR) rcnt[find(i)]++;\n\t\t\tif(cc[y]!=i) unmrg(tmp3,tmp4);\n\t\t\tif(rr[x]!=i) unmrg(tmp1,tmp2);\n\t\t\tif(fC){\n\t\t\t\tcc[y]=-1;\n\t\t\t}\n\t\t\tif(fR){\n\t\t\t\tcc[x]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst int maxn = 2e5 + 10;\n\nvector<int> g[maxn];\nint mt[maxn];\nint used[maxn];\nint cn = 1;\n\nbool dfs(int v) {\n\tif (used[v] == cn) return false;\n\n\tused[v] = cn;\n\n\tfor (int u : g[v]) {\n\t\tif (mt[u] == -1 || dfs(mt[u])) {\n\t\t\tmt[u] = v;\n\t\t\treturn true;\n\t\t}\n\t}\n\n\treturn false;\n}\n\nint main()\n{\n\tfastInp;\n\n\tll n, h, w;\n\tcin >> n >> h >> w;\n\n\tll vals = 0, ans = 0;\n\tvector<tuple<ll, ll, ll>> vec;\n\tfor (int i = 0; i < h + w + 3; i++) mt[i] = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tll r, c, a;\n\t\tcin >> r >> c >> a;\n\t\tr--; c--;\n\t\tvec.push_back({ a, r, c });\n\t}\n\n\tsort(vec.rbegin(), vec.rend());\n\n\tll cnt = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tcn++;\n\t\tvals++;\n\t\tll r = get<1>(vec[i]), c = get<2>(vec[i]), a = get<0>(vec[i]);\n\t\tg[i].push_back(r);\n\t\tg[i].push_back(c + h + 1);\n\t\tcnt += dfs(i);\n\n\t\tif (cnt >= vals) {\n\t\t\tans += a;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tvals--;\n\t\t\tg[i].pop_back();\n\t\t\tg[i].pop_back();\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define ll long long\nusing ull = unsigned long long;\nusing namespace std;\n#define dump(x)                             \\\n    if (dbg) {                              \\\n        cerr << #x << \" = \" << (x) << endl; \\\n    }\n#define overload4(_1, _2, _3, _4, name, ...) name\n#define FOR1(n) for (ll i = 0; i < (n); ++i)\n#define FOR2(i, n) for (ll i = 0; i < (n); ++i)\n#define FOR3(i, a, b) for (ll i = (a); i < (b); ++i)\n#define FOR4(i, a, b, c) for (ll i = (a); i < (b); i += (c))\n#define FOR(...) overload4(__VA_ARGS__, FOR4, FOR3, FOR2, FOR1)(__VA_ARGS__)\n#define FORR(i, a, b) for (int i = (a); i <= (b); ++i)\n#define bit(n, k) ((n >> k) & 1) /*nのk bit目*/\nnamespace mydef {\nconst int INF = 1ll << 60;\nconst int MOD = 1e9 + 7;\ntemplate <class T>\nbool chmin(T& a, const T& b) {\n    if (a > b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\ntemplate <class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) {\n        a = b;\n        return 1;\n    } else\n        return 0;\n}\nvoid Yes(bool flag = true) {\n    if (flag)\n        cout << \"Yes\" << endl;\n    else\n        cout << \"No\" << endl;\n}\nvoid No(bool flag = true) {\n    Yes(!flag);\n}\nvoid YES(bool flag = true) {\n    if (flag)\n        cout << \"YES\" << endl;\n    else\n        cout << \"NO\" << endl;\n}\nvoid NO(bool flag = true) {\n    YES(!flag);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T& val) {\n    std::fill((T*)array, (T*)(array + N), val);\n}\nbool dbg = false;\n}  // namespace mydef\nusing namespace mydef;\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define lb lower_bound\n#define ub upper_bound\n#define all(v) (v).begin(), (v).end()\n#define SZ(x) ((int)(x).size())\n#define vi vector<int>\n#define vvi vector<vector<int>>\n#define vp vector<pair<int, int>>\n#define vvp vector<vector<pair<int, int>>>\n#define pi pair<int, int>\n//#define P pair<int, int>\n//#define V vector<int>\n//#define S set<int>\n#define asn ans\n//UnionFind\n//How to use\n//unite(x,y) : 集合 x と y を併合する. 併合済のとき false, 未併合のとき true が返される\n//find(k) : 要素 k が属する集合を求める\n//size(k) : 要素 k が属する集合の要素の数を求める\nstruct UnionFind {\n    vector<int> data;\n\n    UnionFind(int sz) {\n        data.assign(sz, -1);\n    }\n\n    bool unite(int x, int y) {\n        x = find(x), y = find(y);\n        if (x == y)\n            return (false);\n        if (data[x] > data[y])\n            swap(x, y);\n        data[x] += data[y];\n        data[y] = x;\n        return (true);\n    }\n\n    int find(int k) {\n        if (data[k] < 0)\n            return (k);\n        return (data[k] = find(data[k]));\n    }\n\n    bool same(int x, int y) {\n        return find(x) == find(y);\n    }\n\n    int size(int k) {\n        return (-data[find(k)]);\n    }\n};\n\nint N, H, W;\nint R[101010], A[101010], B[101010];\nint used[202020];\n\nvoid solve() {\n    priority_queue<pair<int, pi>> que;\n    for (int i = 0; i < N; i++) {\n        que.push({R[i], {A[i], B[i] + 101010}});\n    }\n\n    UnionFind uf(202020);\n\n\n    int ans = 0;\n    while (!que.empty()) {\n        auto t = que.top();\n        que.pop();\n        int R = t.first, A = t.second.first, B = t.second.second;\n        bool fa = used[uf.find(A)], fb = used[uf.find(B)];\n        if (fa && fb)\n            continue;\n        if (fa) {\n            ans += R;\n            used[uf.find(B)] = 1;\n        } else if (fb) {\n            ans += R;\n            used[uf.find(A)] = 1;\n        } else {\n            ans += R;\n            if (uf.same(A, B)) {\n                used[uf.find(A)] = 1;\n            } else {\n                uf.unite(A, B);\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n\nsigned main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> H >> W;\n    for (int i = 0; i < N; i++) {\n        cin >> A[i] >> B[i] >> R[i];\n    }\n\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <stdio.h>\nusing namespace std;\n#define int long long\nint MOD = 1000000007;\nstruct Card {\n\tint R, C, A;\n\tbool operator<(const Card &right) const {\n\t\treturn A < right.A;\n\t}\n};\nstruct UnionFind {\n\tvector<int> data;\n\tvector<int> es;\n\tUnionFind(int size) : data(size, -1), es(size, 0) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t\tes[x] += es[y];\n\t\t}\n\t\tes[x]++;\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n\tbool full(int x) {\n\t\tint r = root(x);\n\t\treturn (-data[r] == es[r]);\n\t}\n};\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint N, H, W;\n\tcin >> N >> H >> W;\n\tvector<Card> c(N);\n\tint res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> c[i].R >> c[i].C >> c[i].A;\n\t\tc[i].R--;\n\t\tc[i].C--;\n\t}\n\tsort(c.rbegin(), c.rend());\n\tUnionFind uf(H + W);\n\tfor (int i = 0; i < N; i++) {\n\t\tint a = c[i].R;\n\t\tint b = H + c[i].C;\n\n\t\tif (uf.full(a) && uf.full(b)) {\n\t\t\t\n\t\t}\n\t\telse {\n\t\t\tuf.unionSet(a, b);\n\t\t\tres += c[i].A;\n\t\t}\n\n\t\t//res = max(res, cur + sum[min(rem, (int)sum.size() - 1)] );\n\t}\n\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\n\n\nstruct UnionFind {\n    vector<int> par;\n    vector<bool> is_namori;\n    \n    UnionFind(int n) : par(n, -1), is_namori(n, 0) {}\n    \n    int root(int x) {\n        if (par[x] < 0) return x;\n        else return par[x] = root(par[x]);\n    }\n    \n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n    \n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (par[x] > par[y]) swap(x, y); // merge technique\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n\n    void set_namori(int x) { is_namori[root(x)] = true; }\n    bool get_namori(int x) { return is_namori[root(x)]; }\n\n    int size(int x) {\n        return -par[root(x)];\n    }\n};\n\nostream& operator << (ostream& s, UnionFind uf) {\n    map<int, vector<int> > res;\n    for (int i = 0; i < uf.par.size(); ++i) {\n        int r = uf.root(i);\n        res[r].push_back(i);\n    }\n    for (map<int, vector<int> >::iterator it = res.begin(); it != res.end(); ++it) {\n        s << endl;\n        for (int j = 0; j < (int)it->second.size(); ++j) {\n            s << it->second[j] << \", \";\n        }\n    }\n    return s << endl;\n}\n\nusing pint = pair<int,int>;\nusing Edge = pair<long long, pint>;\n\nint main() {\n    int N, H, W; cin >> N >> H >> W;\n    vector<Edge> edges;\n    for (int i = 0; i < N; ++i) {\n        int r, c, a; cin >> r >> c >> a; --r, --c;\n        c += H;\n        edges.push_back(Edge(a, pint(r, c)));\n    }\n    sort(edges.begin(), edges.end(), greater<Edge>());\n\n    UnionFind uf(H + W);\n    long long res = 0;\n    for (auto e : edges) {\n        int u = e.second.first;\n        int v = e.second.second;\n        long long w = e.first;\n\n        // u と v が同じ連結成分の場合は、ツリーなら OK、なもりは NG\n        if (uf.issame(u, v)) {\n            // なもり\n            if (uf.get_namori(u)) continue;\n\n            // ツリー\n            else {\n                uf.set_namori(u);\n                res += w;\n            }\n        }\n        // u と v が同じ連結成分でない場合は、両方がなもりはダメ\n        else {\n            if (uf.get_namori(u) && uf.get_namori(v)) continue;\n            else if (uf.get_namori(u) || uf.get_namori(v)) {\n                uf.merge(u, v);\n                uf.set_namori(u);\n                res += w;\n            }\n            else {\n                uf.merge(u, v);\n                res += w;\n            }\n        }\n    }   \n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\ninline ll read() {ll x = 0;char ch = getchar(), w = 1;while(ch < '0' || ch > '9') {\nif(ch == '-') w = -1;ch = getchar();}while(ch >= '0' && ch <= '9') {x = x * 10 + ch - '0';ch = getchar();\n}return x * w;}\nvoid write(ll x) {if(x < 0) putchar('-'), x = -x;if(x > 9) write(x / 10);putchar(x % 10 + '0');}\ninline void writeln(ll x) {write(x);puts(\"\");}\nusing namespace std;\nconst int N = 3e5 + 6;\nint n;\nint h, w;\nstruct T {\n\tint l, r, v;\n}a[N];\nbool cmp(T x, T y) {\n\treturn x. v > y.v;\n}\nint g[N], fa[N];\nint Find(int x) {\n\treturn fa[x] == x? x : fa[x] = Find(fa[x]);\n}\nint check(int x, int y) {\n\tx = Find(x), y = Find(y);\n\tif(x == y) {\n\t\tif(g[x]) {\n\t\t\t--g[x];\n\t\t\treturn 1;\n\t\t} \n\t\treturn 0;\n\t}\n\tfa[x] = y;\n\tg[y] += g[x];\n\tif(g[y] == 0) return 0;\n\t--g[y];\n\treturn 1;\n}\nint main() {\n\tn = read(), h = read(), w = read();\n\tfor(int i = 1; i <= n; ++i) {\n\t\ta[i].l = read();\n\t\ta[i].r = read();\n\t\ta[i].v = read();\n\t}\n\tll ans = 0;\n\tsort(a + 1, a + 1 + n, cmp);\n\tfor(int i = 1; i <= n * 2; ++i) fa[i] = i, g[i] = 1;\n\tfor(int i = 1; i <= n; ++i) if(check(a[i].l, a[i].r + n)){\n\t\tans += a[i].v;\n\t}\n/*\tfor(int i = 1; i <= n; ++i) {\n\t\tif(!v1[a[i].l]) {\n\t\t\tans += a[i].v;\n\t\t\tv1[a[i].l] = 1;\n\t\t} else if(!v2[a[i].r]) {\n\t\t\tans += a[i].v;\n\t\t\tv2[a[i].r] = 1;\n\t\t}\n\t}*/\n\twriteln(ans);\n \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\nconst ll MOD = 1000000007;\n\n#define fr first\n#define sc second\n#define mp1(a,b,c) P1(a,P(b,c))\n#define rep(i,x) for(int i = 0 ; i < x ; i ++)\n#define pb push_back\nconst int INF = 1000000000;\n\nconst int MAX_V_flow = 300010;\nstruct FLOW{\n\tvector<P1> G[MAX_V_flow];\n\tbool used[MAX_V_flow];\n\t\n\tvoid init(){\n\t\trep(i,MAX_V_flow)G[i].clear();\n\t}\n\t\n\tvoid add_edge(int from,int to,int flow){\n\t\tG[from].pb( mp1 ( to , flow , G[to].size() ) );\n\t\tG[to].pb( mp1 ( from , 0 , G[from].size()-1 ) );\n\t}\n\t\n\tint dfs(int v,int t,int f){\n\t\tif(v == t)return f;\n\t\tused[v] = true;\n\t\trep(i,G[v].size()){\n\t\t\tif(!used[G[v][i].fr] && G[v][i].sc.fr > 0){\n\t\t\t\tint d = dfs(G[v][i].fr,t,min(f,G[v][i].sc.fr));\n\t\t\t\tif(d > 0){\n\t\t\t\t\tG[v][i].sc.fr -= d;\n\t\t\t\t\tG[G[v][i].fr][G[v][i].sc.sc].sc.fr += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint flow(int s,int t){\n\t\tint ret = 0,d = 1;\n\t\twhile(d > 0){\n\t\t\trep(i,MAX_V_flow)used[i] = false;\n\t\t\td = dfs(s,t,INF);\n\t\t\tret += d;\n\t\t}\n\t\treturn ret;\n\t}\n}flow;\n\nint main(){\n\tstatic int n,h,w;\n\tstatic int r[100010],c[100010],a[100010];\n\tscanf(\"%d%d%d\",&n,&h,&w);\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tscanf(\"%d%d%d\",&r[i],&c[i],&a[i]);\n\t}\n\t\n\tfor(int i = 1 ; i <= h+w ; i ++){\n\t\tflow.add_edge(0,i,1);\n\t}\n\tvector<P1> vec;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tvec.push_back(mp1(a[i],r[i],c[i]));\n\t}\n\tsort(vec.begin(),vec.end());\n\treverse(vec.begin(),vec.end());\n\t\n\tll ret = 0;\n\tfor(int i = 0 ; i < vec.size() ; i ++){\n\t\tP1 p = vec[i];\n\t\tflow.add_edge(p.sc.fr,h+w+i+1,1);\n\t\tflow.add_edge(h+p.sc.sc,h+w+i+1,1);\n\t\tflow.add_edge(h+w+i+1,h+w+n+1,1);\n\t\tif(flow.flow(0,h+w+n+1))ret += p.fr;\n\t}\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define pb push_back\n#define sz(x) ((int)x.size())\n#define SZ(x) ((int)x.size())\n#define all(x) x.begin(), x.end()\n#define se second\n#define fi first\n\nusing ll=long long;\n\nusing pii=pair<ll, ll>;\nconst ll INF = 1e18;\nconst int mn = 2e5 + 5;\nconst int mod = 1e9 + 7;\nint n, h, w;\n\nconst int MAXN = 5e5 + 5;\n\nnamespace MCMF {\n    struct Edge {\n        ll v, cap, cost, rev;\n    };\n\n    ll flow, cost, s, t, n;\n    ll dist[MAXN], H[MAXN], pv[MAXN], pe[MAXN];\n    std::vector<Edge> G[MAXN];\n\n    bool dijkstra() {\n        std::priority_queue<pii, std::vector<pii>, std::greater<>> q;\n        std::fill(dist, dist + n + 1, INF);\n        dist[s] = 0;\n        q.push({0, s});\n        while (!q.empty()) {\n            pii x = q.top();\n            q.pop();\n            ll &u = x.se;\n            if (dist[u] < x.fi) continue;\n            for (int i = 0; i < SZ(G[u]); ++i) {\n                Edge &e = G[u][i];\n                ll &v = e.v;\n                pii y(dist[u] + e.cost + H[u] - H[v], v);\n                if (e.cap > 0 && dist[v] > y.fi) {\n                    dist[v] = y.fi;\n                    pe[v] = i, pv[v] = u;\n                    q.push(y);\n                }\n            }\n        }\n\n        if (dist[t] == INF) return false;\n        for (int i = 0; i <= n; ++i) H[i] += dist[i];\n\n        ll f = INF;\n        for (int v = t; v != s; v = pv[v]) f = std::min(f, G[pv[v]][pe[v]].cap);\n\n        flow += f;\n        cost += f * H[t];\n\n        for (int v = t; v != s; v = pv[v]) {\n            Edge &e = G[pv[v]][pe[v]];\n            e.cap -= f;\n            G[v][e.rev].cap += f;\n        }\n\n        return true;\n    }\n\n    void solve(int _s, int _t) {\n        s = _s, t = _t;\n        flow = cost = 0;\n        std::fill(H, H + n + 1, 0);\n        while (dijkstra());\n    }\n\n    void init(int _n) {\n        n = _n;\n        for (int i = 0; i <= n; ++i) G[i].clear();\n    }\n\n    void addEdge(int u, int v, int cap, ll cost) {\n        G[u].push_back({v, cap, cost, SZ(G[v])});\n        G[v].push_back({u, 0, -cost, SZ(G[u]) - 1});\n    }\n\n}\n\nint main() {\n    //cin.sync_with_stdio(0);\n#ifdef trote\n    freopen(\"../1.txt\", \"r\", stdin);\n#endif\n    scanf(\"%d%d%d\", &n, &h, &w);\n    MCMF::init(n + h + w + 5);\n    for (int i = 1; i <= n; i++) {\n        int a, b, c;\n        scanf(\"%d%d%d\", &a, &b, &c);\n        MCMF::addEdge(i, n + a, 1, -c);\n        MCMF::addEdge(i, n + h + b, 1, -c);\n    }\n    for (int i = 1; i <= n; i++) {\n        MCMF::addEdge(0, i, 1, 0);\n    }\n    int T = n + h + w + 1;\n    for (int i = n + 1; i <= n + h + w; i++) {\n        MCMF::addEdge(i, n + h + w + 1, 1, 0);\n    }\n    MCMF::solve(0, T);\n    printf(\"%lld\\n\", -MCMF::cost);\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n#include <complex>\n#include <iterator>\n#include <array>\n#include <memory>\n#include <random>\n#include <valarray>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vpii = vector<pii>;\nusing vpll = vector<pll>;\nusing ti3 = tuple<int, int, int>;\nusing vti3 = vector<ti3>;\ntemplate<class T, int s>using va = vector<array<T, s>>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\ntemplate<class T, class S> void cmin(T &a, const S &b) { if (a > b)a = b; }\ntemplate<class T, class S> void cmax(T &a, const S &b) { if (a < b)a = b; }\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\n#define rrep(i,a) for(int i=(a)-1;i>=0;i--)\n#define rrep1(i,a) for(int i=a;i;i--)\n#define repi(i,a,b) for(int i=a;i<b;i++)\n//const ll mod = 1000000007;\ntemplate<class T>using heap = priority_queue<T, vector<T>, greater<T>>;\ntemplate<class T>using pque = priority_queue<T, vector<T>, function<T(T, T)>>;\ntemplate <class T>\ninline void hash_combine(size_t & seed, const T & v) {\n\thash<T> hasher;\n\tseed ^= hasher(v) + 0x9e3779b97f4a7c15 + (seed << 6) + (seed >> 2);\n}\nnamespace std {\n\ttemplate<typename S, typename T> struct hash<pair<S, T>> {\n\t\tinline size_t operator()(const pair<S, T> & v) const {\n\t\t\tsize_t seed = 0;\n\t\t\thash_combine(seed, v.first);\n\t\t\thash_combine(seed, v.second);\n\t\t\treturn seed;\n\t\t}\n\t};\n\t// Recursive template code derived from Matthieu M.\n\ttemplate <class Tuple, size_t Index = std::tuple_size<Tuple>::value - 1>\n\tstruct HashValueImpl {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\tHashValueImpl<Tuple, Index - 1>::apply(seed, tuple);\n\t\t\thash_combine(seed, std::get<Index>(tuple));\n\t\t}\n\t};\n\ttemplate <class Tuple>\n\tstruct HashValueImpl<Tuple, 0> {\n\t\tstatic void apply(size_t& seed, Tuple const& tuple) {\n\t\t\thash_combine(seed, std::get<0>(tuple));\n\t\t}\n\t};\n\ttemplate <typename ... TT>\n\tstruct hash<std::tuple<TT...>> {\n\t\tsize_t operator()(std::tuple<TT...> const& tt) const {\n\t\t\tsize_t seed = 0;\n\t\t\tHashValueImpl<std::tuple<TT...> >::apply(seed, tt);\n\t\t\treturn seed;\n\t\t}\n\t};\n}\ntemplate<class T>int id(vector<T> &a, T b) {\n\treturn lower_bound(ALL(a), b) - a.begin();\n}\nll pow(ll base, ll i, ll mod) {\n\tll a = 1;\n\twhile (i) {\n\t\tif (i & 1) {\n\t\t\ta *= base;\n\t\t\ta %= mod;\n\t\t}\n\t\tbase *= base;\n\t\tbase %= mod;\n\t\ti /= 2;\n\t}\n\treturn a;\n}\nll gcd(ll a, ll b) {\n\twhile (b) {\n\t\tll c = a % b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b)*b;\n}\n#ifdef _MSC_VER\n#include <intrin.h>\n#endif\nint popcnt(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn __builtin_popcountll(a);\n#elif defined _WIN64\n\treturn _mm_popcnt_u64(a);\n#else\n\treturn _mm_popcnt_u32(a >> 32) + _mm_popcnt_u32(a);\n\ta = (a & 0x5555555555555555) + (a >> 1 & 0x5555555555555555);\n\ta = (a & 0x3333333333333333) + (a >> 2 & 0x3333333333333333);\n\ta = (a & 0x0f0f0f0f0f0f0f0f) + (a >> 4 & 0x0f0f0f0f0f0f0f0f);\n\ta = (a & 0x00ff00ff00ff00ff) + (a >> 8 & 0x00ff00ff00ff00ff);\n\ta = (a & 0x0000ffff0000ffff) + (a >> 16 & 0x0000ffff0000ffff);\n\treturn (a & 0xffffffff) + (a >> 32);\n#endif\n}\nint BitScanF(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn __builtin_ctzll(a);\n#elif defined _WIN64\n\tunsigned long ret;\n\t_BitScanForward64(&ret, a);\n\treturn a;\n#else\n\tunsigned long ret;\n\tif (!(unsigned long)a) {\n\t\t_BitScanForward(&ret, a);\n\t\tret += 32;\n\t}\n\telse _BitScanForward(&ret, (unsigned long)a);\n\treturn ret;\n#endif\n}\nint BitScanR(unsigned long long a) {\n#ifndef _MSC_VER\n\treturn 63 - __builtin_clzll(a);\n#elif defined _WIN64\n\tunsigned long ret;\n\t_BitScanReverse64(&ret, a);\n\treturn a;\n#else\n\tunsigned long ret;\n\tif (a >> 32) {\n\t\t_BitScanReverse(&ret, a);\n\t\tret += 32;\n\t}\n\telse _BitScanReverse(&ret, (unsigned long)a);\n\treturn ret;\n#endif\n}\ntemplate<class T>\nclass matrix {\npublic:\n\tvector<valarray<T>> obj;\n\tpair<int, int> s;\npublic:\n\tmatrix(pair<int, int> size, T e = 0) :matrix(size.first, size.second, e) {}\n\tmatrix(int n, int m = -1, T e = 0) :obj(n, valarray<T>(e, m == -1 ? n : m)), s(n, m == -1 ? n : m) {}\n\tstatic matrix e(int n) {\n\t\tmatrix a = (n);\n\t\tfor (int i = 0; i < n; i++)a[i][i] = 1;\n\t\treturn a;\n\t}\n\tmatrix& operator+=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] += p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator+(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res += p;\n\t}\n\tmatrix& operator-=(const matrix &p) {\n\t\tif (s != p.s)throw runtime_error(\"matrix error\");\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)obj[i][j] -= p.obj[i][j];\n\t\treturn *this;\n\t}\n\tmatrix operator-(const matrix &p) {\n\t\tmatrix res(*this);\n\t\treturn res -= p;\n\t}\n\tmatrix& operator*=(T p) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b *= p;\n\t\treturn *this;\n\t}\n\tmatrix operator*(T p) {\n\t\tmatrix res(*this);\n\t\treturn res *= p;\n\t}\n\tmatrix operator*(const matrix &p) {\n\t\tif (s.second != p.s.first)throw runtime_error(\"matrix error\");\n\t\tmatrix ret(s.first, p.s.second);\n\t\tfor (int i = 0; i < s.first; i++)\n\t\t\tfor (int j = 0; j < s.second; j++)ret[i] += obj[i][j] * p.obj[j];\n\t\treturn ret;\n\t}\n\tmatrix &operator*=(const matrix &p) {\n\t\treturn *this = *this*p;\n\t}\n\tbool operator==(const matrix&p) {\n\t\tif (s != p.s)return 0;\n\t\tfor (int i = 0; i<s.first; i++)for (int j; j< s.second; j++)if (obj[i][j] != p.obj[i][j])return 0;\n\t\treturn 1;\n\t}\n\tpair<int, int> size() const {\n\t\treturn s;\n\t}\n\tmatrix &mod(T m) {\n\t\tfor (auto &a : obj)\n\t\t\tfor (auto &b : a)b %= m;\n\t\treturn *this;\n\t}\n\tvalarray<T>& operator[](int t) {\n\t\treturn obj[t];\n\t}\n\tvoid gauss() {\n\t\tif (size().first + 1 != size().second)return;\n\t\trep(i, size().first) {\n\t\t\tint p = i;\n\t\t\trepi(j, i, size().first)if (abs(obj[j][i]) > abs(obj[p][i]))p = j;\n\t\t\tswap(obj[i], obj[p]);\n\t\t\tif (abs(obj[i][i]) < 1e-8)return;//contniue;\n\t\t\trepi(j, i + 1, size().second)obj[i][j] /= obj[i][i];\n\t\t\trep(j, size().first) {\n\t\t\t\tif (i != j) {\n\t\t\t\t\trepi(k, i + 1, size().second)obj[j][k] -= obj[j][i] * obj[i][k];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n};\ntemplate<class T>\nstd::pair<matrix<T>, vector<int>> LU_decomposition(matrix<T> a) {\n\tif (a.size().first != a.size().second)throw runtime_error(\"matrix error\");\n\tstd::vector<int> pi(a.size().first);\n\tstd::iota(ALL(pi), 0);\n\tvalarray<T> tmp(a.size().first);\n\tfor (int i = 0; i < a.size().first; i++) {\n\t\t//int pivot = i;\n\t\t//T max = abs(a[i][i]);\n\t\t//for (int j = i + 1; j < a.size().first; j++) {\n\t\t//\tif (max < abs(a[j][i])) {\n\t\t//\t\tmax = abs(a[j][i]);\n\t\t//\t\tpivot = j;\n\t\t//\t}\n\t\t//}\n\t\t//std::swap(i, pivot);\n\t\t//pi.push_back(pivot);\n\t\tstd::slice slice(i + 1, a.size().first - i - 1, 1);\n\t\tfor (int j = i + 1; j < a.size().first; j++) {\n\t\t\ttmp[slice] = a[i][slice];\n\t\t\ttmp *= a[j][i] / a[i][i];\n\t\t\ta[j][slice] -= tmp[slice];\n\t\t\ta[j][i] = a[j][i] / a[i][i];\n\t\t}\n\t}\n\treturn std::make_pair(std::move(a), std::move(pi));\n}\ntemplate<class T>\nmatrix<T>LU_solve(pair<matrix<T>, std::vector<int>> a, matrix<T> b) {\n\tauto pi = std::move(a.second);\n\tauto A = std::move(a.first);\n\tif (A.size().first != A.size().second || A.size().first != b.size().first)throw runtime_error(\"matrix error\");\n\tfor (int i = 0; i < A.size().first; i++) {\n\t\tstd::swap(b[i], b[pi[i]]);\n\t}\n\tfor (int i = 0; i < A.size().first; i++) {\n\t\tfor (int j = 0; j < i; j++)b[i] -= A[i][j] * b[j];\n\t}\n\tfor (int i = A.size().first - 1; i >= 0; i--) {\n\t\tfor (int j = i + 1; j < A.size().first; j++)b[i] -= A[i][j] * b[j];\n\t\tb[i] /= A[i][i];\n\t}\n\treturn b;\n}\ntemplate<class T> inline\nmatrix<T> pow(matrix<T> &base, unsigned long long exp) {\n\tauto base_(base);\n\tif (base_.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)res *= base_;\n\t\tif (res.obj[0].size() > 100) {\n\t\t\tint a = 0;\n\t\t}\n\t\tif (!(exp /= 2))break;\n\t\tbase_ *= base_;\n\t}\n\treturn res;\n}\ntemplate<class T> inline\nmatrix<T> modpow(matrix<T> &base, unsigned long long exp, ll m) {\n\tauto base_(base);\n\tif (base.size().first != base_.size().second)throw runtime_error(\"matrix error\");\n\tmatrix<T> res = matrix<T>::e(base_.size().first);\n\tfor (;;) {\n\t\tif (exp & 1)(res *= base_).mod(m);\n\t\tif (res.obj[0].size() > 100) {\n\t\t\tint a = 0;\n\t\t}\n\t\tif (!(exp /= 2))break;\n\t\t(base_ *= base_).mod(m);\n\t}\n\treturn res;\n}\nclass unionfind {\n\tvector<int> par, rank, size_;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind(int n) :par(n), rank(n), size_(n, 1) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\n//end of lib\n//template<class S=void,int ptr_num, class T = char>class trie {\n//\tumap<T, trie<S, ptr_num, T> next;\n//public:\n//\tS key;\n//\ttrie<S, ptr_num, T>* ptr[ptr_num] = {};\n//\ttrie(S &&data) :key(data) {}\n//\ttrie(const S &data) :key(data) {}\n//\tvoid add(T x,S data) {\n//\t\tif (!next.find(x))next.insert(x, data);\n//\t}\n//\ttrie& operator[](T x) {\n//\t\treturn next[x];\n//\t}\n//\tbool find(T x) {\n//\t\tretun next.find(x);\n//\t}\n//};\n//template<class T=char>class AhoCorasick {\n//\ttrie<pair<bool,int>, 2, T> tree;\n//\tAhoCorasick(vector<string> p) {\n//\t\tint num = 0;\n//\t\tvector<decltype(&tree)> que(p.size(),&tree);\n//\t\tfor (int i = 0;; i++) {\n//\t\t\tbool end = 1;\n//\t\t\tint i = 0;\n//\t\t\tfor (auto a : p) {\n//\t\t\t\tif (i >= a.size())break;\n//\t\t\t\tend = ;0\n//\t\t\t\tque[i] = (*que[i])[a[i]];\n//\t\t\t\ti++;\n//\t\t\t}\n//\t\t\tif (end)break;\n//\t\t}\n//\t}\n//};\ntemplate<class T, class Func = function<T(T, T)>>\nclass segtree {\n\tvector<T> obj;\n\tint offset;\n\tFunc updater;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse return updater(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t}\npublic:\n\tvoid propagate(int a, int b, int k, int l, int r, int p) {\n\t\tif (r <= a || b <= l)return;\n\t\tif (a <= l && r <= b) {\n\t\t\tobj[k].second += p;\n\t\t\t(obj[k].first *= pow(2, p, (ll)1e9 + 7)) %= (ll)(1e9 + 7);\n\t\t\treturn;\n\t\t}\n\t\telse {\n\t\t\tif (obj[k].second) {\n\t\t\t\t(obj[k * 2 + 1].first *= pow(2, obj[k].second, (ll)1e9 + 7)) %= (ll)(1e9 + 7);\n\t\t\t\t(obj[k * 2 + 2].first *= pow(2, obj[k].second, (ll)1e9 + 7)) %= (ll)(1e9 + 7);\n\t\t\t\tobj[k * 2 + 1].second += obj[k].second;\n\t\t\t\tobj[k * 2 + 2].second += obj[k].second;\n\t\t\t}\n\t\t\tpropagate(a, b, k * 2 + 1, l, (l + r) / 2, p), propagate(a, b, k * 2 + 2, (l + r) / 2, r, p);\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tT query(int a, int b) {//[a,b)\n\t\t//propagate(a, b, 0);\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\tvoid propagate(int a, int b, int p = 1) {//[a,b)\n\t\treturn propagate(a, b, 0, 0, offset + 1, p);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i] = updater(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid update(int k, const T &a) {\n\t\t//propagate(k, k + 1, 0);\n\t\tk += offset;\n\t\tobj[k] = a;\n\t\twhile (k) {\n\t\t\tk = k - 1 >> 1;\n\t\t\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t}\n\t}\n\tsegtree(int n, T e, const Func &updater = Func()) :obj(bufsize(n), e), e(e), updater(updater) {}\n\tsegtree(vector<T> &vec, T e, const Func &updater = Func()) :obj(bufsize(vec.size()), e), e(e), updater(updater) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\ntemplate<class T = int>\nclass BIT {//多次元BITはループをネストすればいいらしい。\n\tvector<T> bit;\npublic:\n\tBIT(int n) :bit(n + 1, 0) {}\n\tvoid add(int i, T x) {\n\t\ti++;\n\t\twhile (i <= bit.size()) {\n\t\t\tbit[i - 1] += x;\n\t\t\ti += i & -i;\n\t\t}\n\t}\n\tT sum(int i) {\n\t\tT s = 0;\n\t\ti++;\n\t\twhile (i) {\n\t\t\ts += bit[i - 1];\n\t\t\ti &= i - 1;\n\t\t}\n\t\treturn s;\n\t}\n};\ntemplate<class T>\nclass rangeadd {\n\tBIT<T> b0, b1;\n\tint n;\n\trangeadd(int n) :b0(n), b1(n), n(n) {}\n\tvoid add(int l, int r, T x) {//[l,r)\n\t\tb0.add(l, -x(l - 1));\n\t\tb1.add(l, x);\n\t\tb0.add(r, x*r);\n\t\tb1.add(r, -x);\n\t}\n\tT sum(int i) {\n\t\treturn b0.sum(i) + b1.sum(i)*i;\n\t}\n};\nclass Flow {\npublic:\n\tint V;\n\tstruct edge { int to, cap, rev, cost, add; };\n\tvector<vector<edge>> G;\n\tvector<int> level, iter, h, dist, prevv, preve;\n\tvoid bfs(int s) {\n\t\tfill(level.begin(), level.end(), -1);\n\t\tqueue<int> que;\n\t\tlevel[s] = 0;\n\t\tque.push(s);\n\t\twhile (!que.empty()) {\n\t\t\tint v = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\tedge &e = G[v][i];\n\t\t\t\tif (e.cap > 0 && level[e.to] < 0) {\n\t\t\t\t\tlevel[e.to] = level[v] + 1;\n\t\t\t\t\tque.push(e.to);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint dfs(int v, int t, int f) {\n\t\tif (v == t)return f;\n\t\tfor (int &i = iter[v]; i < G[v].size(); i++) {\n\t\t\tedge &e = G[v][i];\n\t\t\tif (e.cap > 0 && level[v] < level[e.to]) {\n\t\t\t\tint d = dfs(e.to, t, min(f, e.cap));\n\t\t\t\tif (d > 0) {\n\t\t\t\t\te.cap -= d;\n\t\t\t\t\tG[e.to][e.rev].cap += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tint res = 0;\n\tint flow = 0;\n\tint s, t;\n\tint max_flow(int s, int t, int fmax = numeric_limits<int>::max()) {\n\t\tlevel.resize(V);\n\t\titer.resize(V);\n\t\tfor (;;) {\n\t\t\tbfs(s);\n\t\t\tif (level[t] < 0)return flow;\n\t\t\tfill(iter.begin(), iter.end(), 0);\n\t\t\tint f;\n\t\t\twhile ((f = dfs(s, t, fmax))>0) {\n\t\t\t\tflow += f;\n\t\t\t\tfmax -= f;\n\t\t\t}\n\t\t\tif (fmax == 0)return flow;\n\t\t}\n\t}\n\ttypedef pair<int, int> P;\n\tint min_cost_flow(int s, int t, int f) {\n\t\th.resize(V);\n\t\tdist.resize(V);\n\t\tprevv.resize(V);\n\t\tpreve.resize(V);\n\t\tfill(h.begin(), h.end(), 0);\n\t\twhile (f > 0) {\n\t\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\t\tfill(dist.begin(), dist.end(), numeric_limits<int>::max());\n\t\t\tdist[s] = 0;\n\t\t\tque.push({ 0,s });\n\t\t\twhile (!que.empty()) {\n\t\t\t\tP p = que.top(); que.pop();\n\t\t\t\tint v = p.second;\n\t\t\t\tif (dist[v] < p.first)continue;\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tedge &e = G[v][i];\n\t\t\t\t\tif (e.cap > 0 && dist[e.to]>dist[v] + e.cost + h[v] - h[e.to]) {\n\t\t\t\t\t\tdist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n\t\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\t\tque.push({ dist[e.to],e.to });\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dist[t] == numeric_limits<int>::max()) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\tfor (int v = 0; v < V; v++)h[v] += dist[v];\n\n\t\t\tint d = f;\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\td = min(d, G[prevv[v]][preve[v]].cap);\n\t\t\t}\n\t\t\tf -= d;\n\t\t\tres += d * h[t];\n\t\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\t\tedge &e = G[prevv[v]][preve[v]];\n\t\t\t\te.cap -= d;\n\t\t\t\tG[v][e.rev].cap += d;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\npublic:\n\tFlow(int size, int s, int t) :G(size + 1), V(size + 1), s(s), t(t) {\n\t}\n\tvoid add_edge(int from, int to, int cap, int cost = 0) {\n\t\tG[from].push_back(edge{ to, cap, (int)G[to].size(),cost,1 });\n\t\tG[to].push_back(edge{ from,0,(int)G[from].size() - 1,-cost,0 });\n\t}\n\tvoid remove_edge_max(int from, int to, int cap, int cost = 0) {\n\t\tfor (auto &x : G[from]) {\n\t\t\tif (!x.add || x.to != to || x.cap + G[to][x.rev].cap != cap || x.cost != cost)continue;\n\t\t\tint prev = flow;\n\t\t\tint cap = G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tcap -= max_flow(from, to, cap) - prev;\n\t\t\tmax_flow(t, to, cap);\n\t\t\tmax_flow(from, s, cap);\n\t\t\tflow = prev - cap;\n\t\t\tbreak;\n\t\t}\n\t}\n\tvoid remove_edge_cost(int from, int to, int cap, int cost = 0) {\n\t\tfor (auto &x : G[from]) {\n\t\t\tif (!x.add || x.to != to || x.cap + G[to][x.rev].cap != cap || x.cost != cost)continue;\n\t\t\tcost += G[to][x.rev].cap*G[to][x.rev].cost;\n\t\t\tint cap = G[to][x.rev].cap;\n\t\t\tG[to][x.rev].cap = 0;\n\t\t\tx.cap = 0;\n\t\t\tmin_cost_flow(from, to, cap);\n\t\t\tbreak;\n\t\t}\n\t}\n\tint max_flow() {\n\t\treturn max_flow(s, t);\n\t}\n\tint min_cost_flow(int f) {\n\t\treturn min_cost_flow(s, t, f);\n\t}\n};\nll extgcd(ll a, ll b, ll&x, ll&y) {\n\tint d = a;\n\tif (b != 0) {\n\t\td = extgcd(b, a%b, y, x);\n\t\ty -= (a / b)*x;\n\t}\n\telse {\n\t\tx = 1; y = 0;\n\t}\n\treturn d;\n}\nll mod_inv(ll a, ll m) {\n\tll x, y;\n\textgcd(a, m, x, y);\n\treturn(m + x % m) % m;\n}\npll linear_congruence(const vector<ll>& A, const vll& B, const vll&M) {\n\tll x = 0, m = 1;\n\tfor (int i = 0; i < A.size(); i++) {\n\t\tll a = A[i] * m, b = B[i] - A[i] * x, d = gcd(M[i], a);\n\t\tif (b%d != 0)return make_pair(0, -1);\n\t\tll t = b / d * mod_inv(a / d, M[i] / d) % (M[i] / d);\n\t\t//if (x + m * t < 0)return pll(x%m, m);\n\t\tx = x + m * t;\n\t\tm *= M[i] / d;\n\t}\n\treturn make_pair(x%m, m);\n}\ntypedef complex<ld> P;\ntypedef vector<P> VP;\nconst ld eps = 1e-11, pi = acos(-1.0);\n\nld dot(P a, P b) { return real(conj(a) * b); }\nld cross(P a, P b) { return imag(conj(a) * b); }\n\nnamespace std {\n\tbool operator<(const P &a, const P &b) {\n\t\treturn abs(a.real() - b.real()) < eps ? a.imag() < b.imag() : a.real() < b.real();\n\t}\n}\n\nstruct L { P a, b; };//line->l,segment->s\nstruct C { P p; ld r; };\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps) return 1;   // counter clockwise\n\tif (cross(b, c) < -eps) return -1; // clockwise\n\tif (dot(b, c) < 0) return 2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;  // a--b--c on line\n\treturn 0;                          // a--c--b on line\n}\n\nbool isis_ll(L l, L m) {//is intersect\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > eps;\n}\n\nbool isis_ls(L l, L s) {\n\tld a = cross(l.b - l.a, s.a - l.a);\n\tld b = cross(l.b - l.a, s.b - l.a);\n\treturn (a * b < eps);\n}\n\nbool isis_lp(L l, P p) {\n\treturn abs(cross(l.b - p, l.a - p)) < eps;\n}\n\nbool isis_ss(L s, L t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\nP is_ll(L s, L t) { //intersect\n\tP sv = s.b - s.a, tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nbool isis_sp(L s, P p) {\n\treturn abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps;\n}\n\nP proj(L l, P p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\nld dist_lp(L l, P p) {\n\treturn abs(p - proj(l, p));\n}\n\nld dist_ll(L l, L m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(L l, L s) {\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(L s, P p) {\n\tP r = proj(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(L s, L t) {\n\tif (isis_ss(s, t)) return 0;\n\tld a = min(dist_sp(s, t.a), dist_sp(t, s.a));\n\tld b = min(dist_sp(s, t.b), dist_sp(t, s.b));\n\treturn min(a, b);\n}\n\nVP is_cc(C c1, C c2) {\n\tVP res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tP diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * P(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * P(rc, -rs));\n\treturn res;\n}\n\nbool isis_vc(vector<C> vc) {\n\tVP crs;\n\tint n = vc.size();\n\trep(i, n)rep(j, i)\n\t\tfor (P p : is_cc(vc[i], vc[j]))\n\t\t\tcrs.push_back(p);\n\trep(i, n)\n\t\tcrs.push_back(vc[i].p);\n\tfor (P p : crs) {\n\t\tbool valid = true;\n\t\trep(i, n)\n\t\t\tif (abs(p - vc[i].p)>vc[i].r + eps)\n\t\t\t\tvalid = false;\n\t\tif (valid) return true;\n\t}\n\treturn false;\n}\n\nVP is_lc(C c, L l) {\n\tVP res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tP nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\nVP is_sc(C c, L l) {\n\tVP v = is_lc(c, l), res;\n\tfor (P p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\nvector<L> tangent_cp(C c, P p) {//円の接線?\n\tvector<L> ret;\n\tP v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (std::isnan(l)) { return ret; }\n\tP v1 = v * P(l / d, c.r / d);\n\tP v2 = v * P(l / d, -c.r / d);\n\tret.push_back(L{ p, p + v1 });\n\tif (l < eps) return ret;\n\tret.push_back(L{ p, p + v2 });\n\treturn ret;\n}\n\nvector<L> tangent_cc(C c1, C c2) {\n\tvector<L> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tP center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tP out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<L> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tP v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tP q1 = c1.p + v * P(0, 1) * c1.r;\n\t\tP q2 = c1.p + v * P(0, -1) * c1.r;\n\t\tret.push_back(L{ q1, q1 + v });\n\t\tret.push_back(L{ q2, q2 + v });\n\t}\n\treturn ret;\n}\n\nld area(const VP &p) {//面積??\n\tld res = 0;\n\tint n = p.size();\n\trep(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\nbool is_polygon(L l, VP &g) {\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i];\n\t\tP b = g[(i + 1) % n];\n\t\tif (isis_ss(l, L{ a, b })) return true;\n\t}\n\treturn false;\n}\n\nint is_in_Polygon(const VP &g, P p) {\n\tbool in = false;\n\tint n = g.size();\n\tfor (int i = 0; i < n; i++) {\n\t\tP a = g[i] - p, b = g[(i + 1) % n] - p;\n\t\tif (imag(a) > imag(b)) swap(a, b);\n\t\tif (imag(a) <= 0 && 0 < imag(b))\n\t\t\tif (cross(a, b) < 0) in = !in;\n\t\tif (abs(cross(a, b)) < eps && dot(a, b) < eps) return 0; // on\n\t}\n\tif (in) return 1; // in\n\treturn -1; // out\n}\n\nVP ConvexHull(VP ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tVP ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\nVP ConvexCut(const VP &ps, L l) {\n\tVP Q;\n\tfor (int i = 0; i < (int)ps.size(); i++) {\n\t\tP A = ps[i], B = ps[(i + 1) % ps.size()];\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0)\n\t\t\tQ.push_back(is_ll(L{ A, B }, l));\n\t}\n\treturn Q;\n}\nstruct unionfind_ {\n\tvector<int> par, rank, size_,a;//速度ではなくメモリ効率を考えるならrankのかわりにsizeを使う\npublic:\n\tunionfind_(int n) :par(n), rank(n), size_(n, 1),a(n) {\n\t\tiota(ALL(par), 0);\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (rank[x] < rank[y])swap(x, y);\n\t\tpar[y] = x;\n\t\tsize_[x] += size_[y];\n\t\tcmin(a[x],a[y]);\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tint size(int x) {\n\t\treturn size_[find(x)];\n\t}\n};\ntemplate<class T>\nclass lazysegtree {\n\tvector<T> obj;\n\tint offset;\n\tT e;\n\tint bufsize(int num) {\n\t\tint i = 1;\n\t\tfor (; num >i; i <<= 1);\n\t\toffset = i - 1;\n\t\treturn (i << 1) - 1;\n\t}\n\tT query(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l)return e;\n\t\tif (a <= l && r <= b)return obj[k];\n\t\telse {\n\t\t\tT ret(e);\n\t\t\tobj[k].propagate(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\t\treturn ret.merge(query(a, b, k * 2 + 1, l, (l + r) / 2), query(a, b, k * 2 + 2, (l + r) / 2, r));\n\t\t}\n\t}\n\tvoid propagateall(int a, int b, int k, int l, int r) {\n\t\tif (r <= a || b <= l || l == r - 1)return;\n\t\tobj[k].propagate(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\tpropagateall(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\tpropagateall(a, b, k * 2 + 2, (l + r) / 2, r);\n\t}\n\ttemplate<class Param>\n\tT update(int a, int b, int k, int l, int r, const Param& param) {\n\t\tif (r <= a || b <= l)return obj[k];\n\t\tif (a <= l && r <= b) {\n\t\t\tobj[k].update(param);\n\t\t\treturn obj[k];\n\t\t}\n\t\tobj[k].propagate(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t\treturn obj[k].merge(update(a, b, k * 2 + 1, l, (l + r) / 2, param), update(a, b, k * 2 + 2, (l + r) / 2, r, param));\n\t}\npublic:\n\tT query(int a, int b) {//[a,b)\n\t\treturn query(a, b, 0, 0, offset + 1);\n\t}\n\ttemplate<class Param>\n\tvoid update(int a, int b, Param&& param) {\n\t\tupdate(a, b, 0, 0, offset + 1, param);\n\t}\n\tvoid updateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tif (l == 0)return;\n\t\tdo {\n\t\t\tl = l - 1 >> 1, r = r - 1 >> 1;\n\t\t\tfor (int i = l; i < r; i++)obj[i].merge(obj[i * 2 + 1], obj[i * 2 + 2]);\n\t\t} while (l);\n\t}\n\tvoid propagateall(int l = 0, int r = -1) {\n\t\tif (r < 0)r = offset + 1;\n\t\tl += offset, r += offset;\n\t\tupdateall(l, r, 0, 0, offset + 1);\n\t}\n\t/*\n\tvoid update(int k, T &a) {\n\tk += offset;\n\tobj[k] = a;\n\twhile (k) {\n\tk = k - 1 >> 1;\n\tobj[k] = updater(obj[k * 2 + 1], obj[k * 2 + 2]);\n\t}\n\t}*/\n\tlazysegtree(int n, T e) :obj(bufsize(n), e), e(e) {}\n\tlazysegtree(vector<T> &vec, T e) :obj(bufsize(vec.size()), e), e(e) {\n\t\tcopy(vec.begin(), vec.end(), obj.begin() + offset);\n\t\tupdateall();\n\t}\n\tT& operator[](int n) {\n\t\treturn obj[n + offset];\n\t}\n};\nclass lazyRMQ_t {\n\tll min, set;\npublic:\n\tll getmin() {\n\t\treturn min;\n\t}\n\tlazyRMQ_t() {\n\t\tmin = numeric_limits<ll>::max() / 2; set = min;\n\t}\n\tlazyRMQ_t(ll a, ll b = 0) {\n\t\tmin = a; set = b;\n\t}\n\tvoid propagate(lazyRMQ_t &a, lazyRMQ_t &b) {\n\t\tcmin(a.min, set);\n\t\tcmin(b.min, set);\n\t\tcmin(a.set, set);\n\t\tcmin(b.set, set);\n\t\tset = numeric_limits<ll>::max() / 2;\n\t}\n\tlazyRMQ_t& merge(const lazyRMQ_t &a, const lazyRMQ_t &b) {\n\t\tmin = std::min(a.min, b.min);\n\t\tset = numeric_limits<ll>::max() / 2;\n\t\treturn *this;\n\t}\n\tlazyRMQ_t& update(ll k) {\n\t\tcmin(min, k);\n\t\tcmin(set, k);\n\t\treturn *this;\n\t}\n};\nint check(array<int, 4> &a, array<int, 4> &b) {\n\tif (a == b)return 0;\n\tif (a[0] < b[0] && a[1] < b[1])return b[2];\n\tif (b[0] < a[0] && b[1] < a[1])return a[2];\n\treturn -1;\n}\nint main() {\n\tint n;\n\tint h, w;\n\tcin >> n >> h >> w;\n\tva<int, 3> a(n);\n\trep(i, n)rep(j, 3)cin >> a[i][j];\n\trep(i, n)rep(j, 2)a[i][j]--;\n\tFlow f(n + h + w + 2, n + h + w, n + h + w + 1);\n\trep(i, n) {\n\t\tf.add_edge(n + h + w, i, 1, 200000-a[i][2]);\n\t\tf.add_edge(i, n + a[i][0], 1);\n\t\tf.add_edge(i, n + h + a[i][1], 1);\n\t}\n\trep(i, h)f.add_edge(n + i, n + h + w + 1, 1);\n\trep(i, w)f.add_edge(n + h + i, n + h + w + 1, 1);\n\tf.add_edge(n + h + w, n + h + w + 1, n + w, 200000);\n\tcout << 200000*(h+w)-f.min_cost_flow(h + w) << endl;\n}\n//template<class T, class map = std::unordered_map<T,unique_ptr<node>>>\n/*class AhoCorasick {\nstruct node {\nmap<char,unique_ptr<node>> next;\nnode* fail = nullptr, *match_list = nullptr;\nstd::vector<int> match;\n}root;\nint pattern;\n//template<class string>\nAhoCorasick(std::vector<string> &vs) :pattern(vs.size()) {\nroot.fail = &root;\nfor (int i = 0; i < vs.size(); i++) {\nnode* now = &root;\nfor (auto c : vs[i]) {\nif (!now->next[c])now->next[c]=make_unique<node>();\nnow = now->next[c].get();\n}\nnow->match.push_back(i);\n}\nstd::queue<node*> que;\nque.push(&root);\nwhile (!que.empty()) {\nauto now = que.front();\nque.pop();\nfor (auto &next : now->next) {\nif (!next.second)continue;\nif (now->fail->next.count(next.first))next.second->fail = now->fail->next[next.first].get();\nelse next.second->fail = now->fail->fail;\n//next.second->match.insert(next.second->match.end(), next.second->fail->match.begin(), next.second->fail->match.end());\nif (next.second->fail->match.empty())next.second->match_list = next.second->fail->match_list;\nelse next.second->match_list = next.second->fail;\nque.push(next.second.get());\n}\n}\n}\nauto match_n(string str) {\nvector<int> num(pattern);\n\n}\nauto match_list(string str) {\nvector<pair<int, int>> list;\nauto now = &root;\nfor (int i = 0; i < str.size(); i++) {\nif (now->next.count(str[i]))now = now->next[str[i]].get();\nelse now = now->fail;\nauto match = now->match_list;\ndo {\nmatch\n}\n}\n}\n};*/\n"
  },
  {
    "language": "C++",
    "code": "#ifndef OUUAN\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#endif\n#include<bits/stdc++.h>\n\n#define int LoveLive\n//#define FAST_IOSTREAM 1\n\n#define For(i,l,r)for(int i=(l),i##end=(r);i<=i##end;++i)\n#define FOR(i,r,l)for(int i=(r),i##end=(l);i>=i##end;--i)\n#define SON(i,u)for(int i=head[u];i;i=nxt[i])\n#define ms(a,x)memset(a,x,sizeof(a))\n#define fi first\n#define se second\n#define pb emplace_back\n#define pq priority_queue\n#define isinf(x)(x>=INF?-1:x)\n#define y1 why_is_there_a_function_called_y1\n#define DEBUG(x)cerr<<(#x)<<\":\"<<x<<endl\nusing namespace std;\ntypedef long long LoveLive;typedef pair<int,int>pii;typedef vector<int>vi;\n#ifdef int\nconst int INF=0x3f3f3f3f3f3f3f3fll;\n#else\nconst int INF=0x3f3f3f3f;\n#endif\nconst double eps=1e-9;mt19937 rng(chrono::steady_clock::now().time_since_epoch().\ncount());int randint(int l,int r){int out=rng()%(r-l+1)+l;return out>=l?out:out+\nr-l+1;}\n#ifdef FAST_IOSTREAM\n#define br cout<<'\\n'\n#define sp cout<<' '\nlong long read(){long long x;cin>>x;return x;}template<typename T>void read(T&x){\ncin>>x;}template<typename T>void write(const T&x){cout<<x;}\n#else\n#define br putchar('\\n')\n#define sp putchar(' ')\ntemplate<typename T>typename enable_if<!is_integral<T>::value,void>::type read(T\n&x){cin>>x;}long long read(){char c;long long out=0,f=1;for(c=getchar();!isdigit\n(c)&&c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())\nout=(out<<3)+(out<<1)+c-'0';return out*f;}template<typename T>typename enable_if\n<is_integral<T>::value,T>::type read(T&x){char c;T f=1;x=0;for(c=getchar();!isdigit\n(c)&&c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())\nx=(x<<3)+(x<<1)+c-'0';return x*=f;}char read(char&x){for(x=getchar();isspace(x);\nx=getchar());return x;}double read(double&x){scanf(\"%lf\",&x);return x;}template<\ntypename T>typename enable_if<!is_integral<T>::value,void>::type write(const T&x\n){cout<<x;}template<typename T>typename enable_if<is_integral<T>::value,void>::type\nwrite(const T&x){if(x<0){putchar('-');write(-x);return;}if(x>9)write(x/10);putchar\n(x%10+'0');}void write(const char&x){putchar(x);}void write(const double&x){printf\n(\"%.10lf\",x);}\n#endif\ntemplate<typename T,typename...Args>void read(T&x,Args&...args){read(x);read(args\n...);}template<typename OutputIt,typename=typename enable_if<is_same<output_iterator_tag\n,typename iterator_traits<OutputIt>::iterator_category>::value||(\nis_base_of<forward_iterator_tag,typename iterator_traits<OutputIt>::iterator_category>::value\n&&!is_const<OutputIt>::value)>::type>void read(OutputIt __first,OutputIt __last){for(;__first\n!=__last;++__first)read(*__first);}template<typename InputIt,typename=typename enable_if\n<is_base_of<input_iterator_tag,typename iterator_traits<InputIt>::iterator_category\n>::value>::type>void wts(InputIt __first,InputIt __last){bool isFirst=true;for(;\n__first!=__last;++__first){if(isFirst)isFirst=false;else sp;write(*__first);}br;}\ntemplate<typename InputIt,typename=typename enable_if<is_base_of<input_iterator_tag\n,typename iterator_traits<InputIt>::iterator_category>::value>::type>void wtb(InputIt\n__first,InputIt __last){for(;__first!=__last;++__first){write(*__first);br;}}template\n<typename T>void wts(const T&x){write(x);sp;}template<typename T>void wtb(const\nT&x){write(x);br;}template<typename T>void wte(const T&x){write(x);exit(0);}template\n<typename T,typename...Args>void wts(const T&x,Args...args){wts(x);wts(args...);}\ntemplate<typename T,typename...Args>void wtb(const T&x,Args...args){wts(x);wtb(args\n...);}template<typename T,typename...Args>void wte(const T&x,Args...args){wts(x);\nwte(args...);}template<typename T>inline bool up(T&x,const T&y){return x<y?x=y,1\n:0;}template<typename T>inline bool dn(T&x,const T&y){return y<x?x=y,1:0;}\n\nconst int N = 100010;\nconst int mod = 1000000007;\n\nint n, h, w, ans, anss, vis[2][N];\n\nstruct Node\n{\n\tint w, p[2];\n\tbool operator<(const Node& b) const\n\t{\n\t\treturn w > b.w;\n\t}\n} a[N];\n\nbool insert(int x, int y)\n{\n\tif (vis[y][a[x].p[y]])\n\t{\n\t\tif (vis[y ^ 1][a[vis[y][a[x].p[y]]].p[y ^ 1]]) return false;\n\t\tvis[y ^ 1][a[vis[y][a[x].p[y]]].p[y ^ 1]] = vis[y][a[x].p[y]];\n\t}\n\tvis[y][a[x].p[y]] = x;\n\treturn true;\n}\n\nsigned main()\n{\n#ifdef FAST_IOSTREAM\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n#endif\n\t\n\tread(n, h, w);\n\t\n\tFor (i, 1, n) read(a[i].p[0], a[i].p[1], a[i].w);\n\t\n\tsort(a + 1, a + n + 1);\n\t\n\tFor (qwq, 1, 800)\n\t{\n\t\tans = 0;\n\t\tms(vis, 0);\n\t\tFor (i, 1, n)\n\t\t{\n\t\t\tif (randint(0, 1))\n\t\t\t{\n\t\t\t\tif (insert(i, 0) || insert(i, 1)) ans += a[i].w;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (insert(i, 1) || insert(i, 0)) ans += a[i].w;\n\t\t\t}\n\t\t}\n\t\tup(anss, ans);\n\t}\n\t\n\twtb(anss);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <iomanip>\nusing namespace std;\n#define reps(i,s,n) for(int i = s; i < n; i++)\n#define rep(i,n) reps(i,0,n)\n#define fi first\n#define se second\n#define mp make_pair\ntypedef long long ll;\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nll N,M,H,W,K,Q,A,B,L,R;\nstring S,T;\nconst ll MOD = (1e+9) + 7;\nconst ll INF = 1LL << 60;\ntypedef pair<ll,ll> P;\n\ntypedef vector<P> vp;\ntypedef vector<vp> matP;\n\n\nint main() {\n    cin>>N>>H>>W;\n    vec r(N), c(N), a(N);\n    rep(i,N) cin>>r[i]>>c[i]>>a[i];\n    vec ord(N,0);\n    rep(i,N) ord[i] = i;\n    sort(ord.begin(), ord.end(),[&](ll x, ll y){\n        return a[x] > a[y];\n    });\n    class union_find{\n            vector<long> parent, tree_size;\n        public:\n            union_find(unsigned long _n) : parent(_n), tree_size(_n, 1){\n                for(unsigned long i = 0; i < _n; ++i)parent[i] = i;\n            }\n            ll find(ll x){\n                while(parent[x] != x)x = parent[x] = parent[parent[x]];\n                return x;\n            }\n            void merge(ll a, ll b){\n                a = find(a);\n                b = find(b);\n                if (a != b) {\n                    if (tree_size[a] < tree_size[b])swap(a, b);\n                    tree_size[a] += tree_size[b];\n                    parent[b] = a;\n                    return;\n                }\n            }\n    \t    bool same(ll a, ll b){\n    \t        a = find(a);\n    \t        b = find(b);\n    \t        return a == b;\n    \t    }\n        };\n    //uf.mergeのように使う\n    //ufはMAX_N+1でとるか、代入時に0-indexedにする\n    union_find uf(H + W + 1); //代入はh,H + w\n    //H + Wは、そのグループはつなげないという証明\n    ll ans = 0;\n    rep(i,N){\n        ll index = ord[i];\n        //cout<<i<<' '<<ans<<endl;\n        if(uf.same(r[index] - 1, H + W) && uf.same(H + c[index] - 1, H + W)) continue;\n        if(uf.same(r[index] - 1, H + c[index] - 1)) {\n            uf.merge(r[index] - 1, H + W);\n            uf.merge(H + c[index] - 1, H + W);\n        }else{\n            uf.merge(r[index] - 1, H + c[index] - 1);\n        }\n        ans += a[index];\n    }\n    cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <memory>\n#include <thread>\n#include <tuple>\n#include <limits>\n\nusing namespace std;\n\nstruct MinCostFlow\n{\n  typedef int cap_t;\n  typedef long long cost_t;\n\n  bool iszerocap(cap_t cap) { return cap == 0; }\n\n  struct edge {\n    int target;\n    cost_t cost;\n    cap_t residual_capacity;\n    cap_t orig_capacity;\n    int revid;\n  };\n\n  vector<vector<edge>> graph;\n  int n;\n  vector<cost_t> pi;\n\n  MinCostFlow(int n) : graph(n), n(n), pi(n, 0) {}\n  void addEdge(int s, int e, cost_t cost, cap_t cap)\n  {\n    int forward_rev = graph[e].size() + ((s == e) ? 1 : 0);\n    int backward_rev = graph[s].size();\n    edge forward = { e, cost, cap, cap, forward_rev };\n    edge backward = { s, -cost, 0, 0, backward_rev };\n    graph[s].emplace_back(forward);\n    graph[e].emplace_back(backward);\n  }\n\n  bool normalize(int s) {\n    auto infinite_cost = numeric_limits<cost_t>::max();\n    vector<cost_t> dist(n, infinite_cost);\n    dist[s] = 0;\n    queue<int> q;\n    vector<int> v(n), relax_count(n);\n    v[s] = 1; q.push(s);\n    while (!q.empty()) {\n      int cur = q.front();\n      v[cur] = 0; q.pop();\n      if (++relax_count[cur] >= n) return false;\n      for (const auto &e : graph[cur]) {\n        if (iszerocap(e.residual_capacity)) continue;\n        auto next = e.target;\n        auto ncost = dist[cur] + e.cost;\n        if (dist[next] > ncost) {\n          dist[next] = ncost;\n          if (v[next]) continue;\n          v[next] = 1; q.push(next);\n        }\n      }\n    }\n    for (int i = 0; i < n; i++) pi[i] = dist[i];\n    return true;\n  }\n\n  pair<cost_t, cap_t> augmentShortest(int s, int e, cap_t flow_goal, cap_t flow_limit) {\n    auto infinite_cost = numeric_limits<cost_t>::max();\n    auto infinite_flow = numeric_limits<cap_t>::max();\n    typedef pair<cost_t, int> pq_t;\n    priority_queue<pq_t, vector<pq_t>, greater<pq_t>> pq;\n    vector<pair<cost_t, cap_t>> dist(n, make_pair(infinite_cost, 0));\n    vector<int> from(n, -1), v(n);\n\n    dist[s] = pair<cost_t, cap_t>(0, infinite_flow);\n    pq.emplace(dist[s].first, s);\n    while (!pq.empty()) {\n      auto cur = pq.top().second; pq.pop();\n      if (v[cur]) continue;\n      v[cur] = 1;\n      for (const auto &edge : graph[cur]) {\n        auto next = edge.target;\n        if (v[next]) continue;\n        if (iszerocap(edge.residual_capacity)) continue;\n        auto ncost = dist[cur].first + edge.cost - pi[next] + pi[cur];\n        auto nflow = min(dist[cur].second, edge.residual_capacity);\n        if (dist[next].first <= ncost) continue;\n        dist[next] = make_pair(ncost, nflow);\n        from[next] = edge.revid;\n        pq.emplace(dist[next].first, next);\n      }\n    }\n    /** augment the shortest path **/\n    /* update potential, dist[i].first becomes invalid */\n    for (int i = 0; i < n; i++) {\n      if (iszerocap(dist[i].second)) continue;\n      pi[i] += dist[i].first;\n    }\n    auto flow = dist[e].second;\n    // e is unreachable\n    if (iszerocap(flow)) return make_pair(0, 0);\n    // reduced cost of augment path is 0, actual cost is potential difference\n    auto pathcost = pi[e] - pi[s];\n    // always restrict\n    flow = min(flow, flow_limit);\n    // if it costs, we want minimum flow\n    if (pathcost >= 0) flow = min(flow, flow_goal);\n    if (flow <= 0 || iszerocap(flow)) return make_pair(0, 0);\n\n    for (auto cur = e; from[cur] != -1; ) {\n      auto back_edge = from[cur];\n      auto prev = graph[cur][back_edge].target;\n      auto forward_edge = graph[cur][back_edge].revid;\n      graph[cur][back_edge].residual_capacity += flow;\n      graph[prev][forward_edge].residual_capacity -= flow;\n      cur = prev;\n    }\n    return make_pair(pathcost * flow, flow);\n  }\n\n  pair<cost_t, cap_t> solve(int s, int e, cap_t flow_goal = numeric_limits<cap_t>::max(), cap_t flow_limit = numeric_limits<cap_t>::max()) {\n    cost_t total_cost = 0;\n    cap_t total_flow = 0;\n    for (;;) {\n      auto res = augmentShortest(s, e, flow_goal - total_flow, flow_limit - total_flow);\n      if (res.second <= 0) break;\n      total_cost += res.first;\n      total_flow += res.second;\n    }\n    return make_pair(total_cost, total_flow);\n  }\n};\n\n\nint main() {\n  int n, h, w;\n  scanf(\"%d%d%d\", &n, &h, &w);\n  vector<char> used(n);\n  vector<tuple<int, int, int>> dat(n);\n  for (int i = 0; i < n; i++) {\n    int r, c, w;\n    scanf(\"%d%d%d\", &r, &c, &w);\n    r--, c--;\n    dat[i] = make_tuple(w, r, c);\n  }\n  sort(dat.begin(), dat.end(), greater<tuple<int, int, int>>());\n  long long ans = 0;\n  MinCostFlow mcf(h+w+n+2);\n  int source = h + w + n;\n  int sink = h + w + n + 1;\n  for (int i = 0; i < n; i++) {\n    int w, r, c;\n    tie(w, r, c) = dat[i];\n    mcf.addEdge(source, i, -w, 1);\n    mcf.addEdge(i, r + n, 0, 1);\n    mcf.addEdge(i, c + n + h, 0, 1);\n  }\n  for (int i = 0; i < h; i++) mcf.addEdge(i + n, sink, 0, 1);\n  for (int i = 0; i < w; i++) mcf.addEdge(i + n + h, sink, 0, 1);\n  mcf.normalize(source);\n  ans = -mcf.solve(source, sink).first;\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nclass Data{\npublic:\n\tint index;\n\tll value;\n};\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N=in(),H=in(),W=in();\n\tvector<vector<Data>> R(H),C(W);\n\tvector<int> F(N,0);\n\tREP(i,N){\n\t\tint r=in()-1,c=in()-1;\n\t\tll a=in<ll>();\n\t\tData d{i,a};\n\t\tR[r].emplace_back(d);\n\t\tC[c].emplace_back(d);\n\t}\n\t//sort(ALL(R),[](vector<Data>& lhs,vector<Data>& rhs){return lhs.size()<rhs.size();});\n\tREP(i,H){\n\t\tsort(ALL(R[i]),[](Data& lhs,Data& rhs){return lhs.value>rhs.value;});\n\t}\n\t//sort(ALL(C),[](vector<Data>& lhs,vector<Data>& rhs){return lhs.size()<rhs.size();});\n\tREP(i,W){\n\t\tsort(ALL(C[i]),[](Data& lhs,Data& rhs){return lhs.value>rhs.value;});\n\t}\n\tll sum = 0;\n\t/*for(int i=0;i<H;i++){\n\t\tint l = R[i].size();\n\t\tif(l>1) continue;\n\t\tif(F[R[i][0].index]==1) continue;\n\t\tsum += R[i][0].value;\n\t\tF[R[i][0].index]=1;\n\t}\n\tfor(int i=0;i<W;i++){\n\t\tint l = C[i].size();\n\t\tif(l>1) continue;\n\t\tif(F[C[i][0].index]==1) continue;\n\t\tsum += C[i][0].value;\n\t\tF[C[i][0].index]=1;\n\t}*/\n\tfor(int i=0;i<H;i++){\n\t\tint l = R[i].size();\n\t\tfor(int k=0;k<l;k++){\n\t\t\tif(F[R[i][k].index]==1) continue;\n\t\t\tsum += R[i][k].value;\n\t\t\tF[R[i][k].index]=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tint l = C[i].size();\n\t\tfor(int k=0;k<l;k++){\n\t\t\tif(F[C[i][k].index]==1) continue;\n\t\t\tsum += C[i][k].value;\n\t\t\tF[C[i][k].index]=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfill(ALL(F),0);\n\tll sum2 = 0;\n\tfor(int i=0;i<W;i++){\n\t\tint l = C[i].size();\n\t\tfor(int k=0;k<l;k++){\n\t\t\tif(F[C[i][k].index]==1) continue;\n\t\t\tsum2 += C[i][k].value;\n\t\t\tF[C[i][k].index]=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tint l = R[i].size();\n\t\tfor(int k=0;k<l;k++){\n\t\t\tif(F[R[i][k].index]==1) continue;\n\t\t\tsum2 += R[i][k].value;\n\t\t\tF[R[i][k].index]=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tout(max(sum,sum2));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\n\nstruct UnionFind {\n    int n, cc, *u;\n    UnionFind() : n(0), cc(0), u(NULL) {}\n    UnionFind(int n_) : n(n_), cc(n_) {\n\tu = new int[n_];\n\tmemset(u, -1, sizeof (int) * n);\n    }\n    UnionFind(const UnionFind &y) : n(y.n), cc(y.cc) {\n\tu = new int[y.n];\n\tmemcpy(u, y.u, sizeof (int) * n);\n    }\n    ~UnionFind() {\n\tdelete[] u; u = NULL;\n\tn = cc = 0;\n    }\n    friend void swap(UnionFind &x, UnionFind &y) {\n\tswap(x.n, y.n); swap(x.cc, y.cc); swap(x.u, y.u);\n    }\n    UnionFind& operator=(UnionFind y) { \n\tswap(*this, y);\n\treturn *this;\n    }\n    int root(int x) {\n\tint y = x, t;\n\twhile (u[y] >= 0) y = u[y];\n\twhile (x != y) { t = u[x]; u[x] = y; x = t; }\n\treturn y;\n    }\n    bool link(int x, int y) {\n\tx = root(x); y = root(y);\n\tif (x == y) return false;\n\tif (u[y] < u[x]) swap(x, y);\n\tu[x] += u[y]; u[y] = x; cc--;\n\treturn true;\n    }\n    bool same(int x, int y) { return root(x) == root(y); }\n    int size(int x) { return -u[root(x)]; }\n    int count() { return cc; }\n};\n\nint N, H, W;\n\nstruct Card {\n    int r, c, a;\n    bool operator<(const Card &o) const {\n\treturn a < o.a;\n    }\n} C[100011];\n\nint S[200011];\n\nvoid MAIN() {\n    scanf(\"%d%d%d\", &N, &H, &W);\n    REP (i, N) {\n\tscanf(\"%d%d%d\", &C[i].r, &C[i].c, &C[i].a);\n\tC[i].r--;\n\tC[i].c--;\n    }\n    sort(C, C+N);\n\n    UnionFind U(H+W);\n    LL ans = 0;\n    for (int i=N; i--;) {\n\tint x = U.root(C[i].r), y = U.root(C[i].c + H);\n\tif (x == y) {\n\t    if (S[x] < U.size(x)) {\n\t\tS[x]++;\n\t\tans += C[i].a;\n\t    }\n\t} else if (S[x]+S[y] < U.size(x)+U.size(y)) {\n\t    U.link(x, y);\n\t    int z = U.root(x);\n\t    S[z] = S[x] + S[y] + 1;\n\t    ans += C[i].a;\n\t}\n    }\n\n    printf(\"%lld\\n\", ans);\n}\n\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (int)n; i++)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<pi, pi> pp;\ntypedef pair<ll, ll> pl;\nconst double EPS = 1e-9;\nconst ll MOD = 1000000007;\nconst int inf = 1 << 30;\nconst ll linf = 1LL << 60;\n\n#define MAX_N 200000\nstruct UF{\n    int par[MAX_N];\n    int rank[MAX_N];\n    int si[MAX_N];\n    int dead[MAX_N];\n\n    void init(int n){\n        rep(i,n){\n            par[i] = i;\n            rank[i] = 0;\n            si[i] = 1;\n            dead[i] = 0;\n        }\n    }\n\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    bool unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) {\n            if (dead[x]) return false;\n            dead[x] = true;\n            return true;\n        }\n        if (dead[x] && dead[y]) return false;\n        \n        if(rank[x] < rank[y]){\n            par[x] = y;\n            if (dead[x]) dead[y] = true;\n            si[y] += si[x];\n        } else{\n            par[y] = x;\n            if (dead[y]) dead[x] = true;\n            if(rank[x] == rank[y]) rank[x]++;\n            si[x] += si[y];\n        }\n        return true;\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n} uf;\n\nstruct X {\n    int r, c, a;\n};\n\nbool cmp (const X &l, const X &r) {\n    return l.a > r.a;\n}\n\nint n, h, w;\nX x[100000];\n\nint main() {\n    cin >> n >> h >> w;\n    rep(i,n) {\n        cin >> x[i].r >> x[i].c >> x[i].a;\n        x[i].r--; x[i].c--;\n    }\n    sort(x, x+n, cmp);\n    uf.init(h+w);\n    ll ans = 0;\n    rep(i,n) {\n        if (uf.unite(x[i].r, h+x[i].c)) {\n            ans += x[i].a;\n        }\n    }\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n//#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\nstruct BiMatch{\n    int L,R;\n    vector<vector<int> > G;\n    vector<int> match,level;\n\n    BiMatch(){}\n    BiMatch(int L,int R):L(L),R(R),G(L+R),match(L+R,-1),level(L+R){}\n\n    void add_edge(int u,int v){\n        G[u].emplace_back(v+L);\n        G[v+L].emplace_back(u);\n    }\n\n    bool bfs(){\n        fill(level.begin(),level.end(),-1);\n        queue<int> q;\n        for(int i=0;i<L;i++){\n            if(match[i]<0){\n                level[i]=0;\n                q.emplace(i);\n            }\n        }\n        bool found=false;\n        while(!q.empty()){\n            int v=q.front();q.pop();\n            for(int u:G[v]){\n                if(~level[u]) continue;\n                level[u]=level[v]+1;\n                int w=match[u];\n                if(w==-1){\n                    found=true;\n                    continue;\n                }\n                if(~level[w]) continue;\n                level[w]=level[u]+1;\n                q.emplace(w);\n            }\n        }\n        return found;\n    }\n\n    bool dfs(int v){\n        for(int u:G[v]){\n            if(level[v]+1!=level[u]) continue;\n            level[u]=-1;\n            int w=match[u];\n            if(w<0||dfs(w)){\n                match[v]=u;\n                match[u]=v;\n                level[v]=-1;\n                return true;\n            }\n        }\n        level[v]=-1;\n        return false;\n    }\n\n    int build(){\n        int res=0;\n        while(bfs())\n            for(int i=0;i<L;i++)\n                if(match[i]<0&&dfs(i))\n                    res++;\n        return res;\n    }\n\n};\nusing Flow = int;\nusing Cost = int;\nconst int MAX_V = 300010;\nconst Cost INF = std::numeric_limits<Cost>::max() / 8;\nstruct PrimalDual {\n    struct Edge {\n        int d;\n        Flow c, f;\n        Cost w;\n        int r, is_r;\n        Edge(int d_, Flow c_, Flow f_, Cost w_, int r_, bool is_r_)\n                : d(d_), c(c_), f(f_), w(w_), r(r_), is_r(is_r_) {}\n    };\n\n    int n;\n    std::vector<std::vector<Edge> > g;\n    PrimalDual(int n_) : n(n_), g(std::vector<std::vector<Edge> >(n_)) {}\n\n    void add_edge(int src, int dst, Flow cap, Cost cost) {  // 有向辺\n        int rsrc = g[dst].size();\n        int rdst = g[src].size();\n        g[src].emplace_back(dst, cap, 0, cost, rsrc, false);\n        g[dst].emplace_back(src, cap, cap, -cost, rdst, true);\n    }\n\n    Cost solve(int s, int t, Flow f) {\n        Cost res = 0;\n\n        static Cost h[MAX_V + 10], dist[MAX_V];\n        static int prevv[MAX_V + 10], preve[MAX_V + 10];\n        // std::vector<Cost> h(g.size()), dist(g.size());\n        // std::vector<int> prevv(g.size()), preve(g.size());\n\n        using pcv = std::pair<Cost, int>;\n        std::priority_queue<pcv, std::vector<pcv>, std::greater<pcv> > q;\n        std::fill(h, h + n, 0);\n        while (f > 0) {\n            std::fill(dist, dist + n, INF);\n            dist[s] = 0;\n            q.emplace(0, s);\n            while (q.size()) {\n                Cost cd;\n                int v;\n                std::tie(cd, v) = q.top();\n                q.pop();\n                if (dist[v] < cd) continue;\n                for (int i = 0; i < (int)(g[v].size()); ++i) {\n                    Edge &e = g[v][i];\n                    if (residue(e) == 0) continue;\n                    if (dist[e.d] + h[e.d] > cd + h[v] + e.w) {\n                        dist[e.d] = dist[v] + e.w + h[v] - h[e.d];\n                        prevv[e.d] = v;\n                        preve[e.d] = i;\n                        q.emplace(dist[e.d], e.d);\n                    }\n                }\n            }\n            if (dist[t] == INF) return res;  // 経路が見つからなかった\n\n            // s-t 間最短路に沿って目一杯流す\n            for (int i = 0; i < n; ++i) h[i] += dist[i];\n            Flow d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = std::min(d, residue(g[prevv[v]][preve[v]]));\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.f += d;\n                g[v][e.r].f -= d;\n            }\n        }\n        return res;\n    }\n\n    Flow residue(const Edge &e) { return e.c - e.f; }\n\n    // 流量を表示\n    void show() {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < (int)(g[i].size()); ++j) {\n                Edge &e = g[i][j];\n                if (e.is_r) continue;\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.d, e.f);\n            }\n        }\n    }\n};\n\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint64 N, H, W;\n\tcin >> N >> H >> W;\n//\tBiMatch bm(H+W, N);\n    PrimalDual pd(H+W+N+2);\n\tusing T = tuple<int64, int64, int64>;\n\tvector<T> v(N);\n\tREP(i, N) {\n\t    int64 a, b, c;\n\t    cin >> a >> b >> c;\n\t    v[i] = T(c, a, b);\n\t}\n\tsort(all(v), greater<>());\n\tREP(i, H) pd.add_edge(H+W+N, i, 1, 0);\n\tREP(i, W) pd.add_edge(H+W+N, H+i, 1, 0);\n\tREP(i, N) {\n\t    int64 V, c, r;\n\t    tie(V, r, c) = v[i];\n//\t    bm.add_edge(r-1, i);\n//\t    bm.add_edge(c-1+H, i);\n\t    pd.add_edge(r-1, H+W+i, 1, 0);\n\t    pd.add_edge(H+c-1, H+W+i, 1, 0);\n\t    pd.add_edge(H+W+i, H+W+N+1, 1, -V);\n\t}\n\tint64 res = pd.solve(H+W+N, H+W+N+1, H+W);\n//\tREP(i, H+W) {\n//\t    if (bm.match[i] != -1) {\n//\t        res += get<0>(v[bm.match[i]-H-W]);\n//\t    }\n//\t}\n\tcout << -res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nconst int MAX=1e5+7;\nusing namespace std;\nint fa[MAX],rem[MAX];\nstruct node\n{\n\tint x;\n\tint y;\n\tint v;\n}Map[MAX];\nint find(int n)\n{\n\tif(fa[n]==n)\n\t{\n\t\treturn n;\n\t}\n\telse return fa[n]=find(fa[n]);\n} \nvoid merge(int a,int b)\n{\n\tfa[find(a)]=find(b);\n}\nbool cmp(node a,node b)\n{\n\treturn a.v>b.v;\n}\nint k=0;\nint main()\n{\n\tint T,n,m,ans=0;\n\tcin>>T>>n>>m;\n\tfor(int i=1;i<=T;i++)\n\t{\n\t\tcin>>Map[i].x>>Map[i].y>>Map[i].v;\n\t} \n\tsort(Map+1,Map+1+T,cmp);\n\tfor(int i=1;i<=n+m;i++)\n\t{\n\t\tfa[i]=i;\n\t\trem[i]=1;\n\t}\n\tfor(int i=1;i<=T;i++)\n\t{\n\t\tint fx=find(Map[i].x),fy=find(Map[i].y+n);\n\t\tif(fx==fy)\n\t\t{\n\t\t\tif(rem[fx])\n\t\t\t{\n\t\t\t\trem[fx]--;\n\t\t\t\tans+=Map[i].v;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(rem[fx]||rem[fy])\n\t\t\t{\n\t\t\t\trem[fx]+=rem[fy];\n\t\t\t\trem[fx]--;\n\t\t\t\tmerge(Map[i].x,Map[i].y+n);\n\t\t\t\tans+=Map[i].v;\n\t\t\t}\n\t\t}\n\t\t//cout<<\"ans=\"<<ans<<endl;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = ll(A); I < ll(B); ++I)\n#define FORR(I,A,B) for(ll I = ll((B)-1); I >= ll(A); --I)\n#define TO(x,t,f) ((x)?(t):(f))\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //xi>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //xi>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\nll gcd(ll a,ll b){if(a%b==0)return b;return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nconst ll INF=ll(1e18)+ll(7);\nconst ll MOD=1000000007LL;\n#define out(a) cout<<fixed<<setprecision((a))\n\nclass UnionFind{\npublic:\n\tvector<int> par,rank;\n\t//0-indexed\n\tUnionFind(int n){init(n);}\n\tvoid init(int n = 1) {\n\t\tpar.resize(n);\n\t\trank.resize(n,0);\n\t\tfor (int i = 0; i < n; ++i) par[i] = i;\n\t}\n\tint root(int x = 1){\n\t\tif(par[x]==x)return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n\tvoid unite(int x = 1,int y = 1){\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif(x==y)return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x]==rank[y]){\n\t\t\t\trank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\tbool same(int x,int y){\n\t\treturn root(x)==root(y);\n\t}\n};\n\n\n// なもりグラフ\n// https://www.hamayanhamayan.com/entry/2019/08/25/090415\n\nint main(){\n\tint N,H,W;\n\tll ans = 0;\n\tcin >> N >> H >> W;\n\tUnionFind uf(H+W+6);\n\tpriority_queue< pair<ll,P> > pq;\n\tFOR(i,0,N){\n\t\tint r,c,a;\n\t\tcin >> r >> c >> a;\n\t\tpq.push({a,{r,c}});\n\t}\n\tFOR(i,0,N){\n\t\tauto X = pq.top();\n\t\tint h = X.second.first;\n\t\tint w = X.second.second;\n\t\tint a = X.first;\n\t\tpq.pop();\n\t\tif(not uf.same(h,w+H)){\n\t\t\tans += a;\n\t\t\tuf.unite(h,w+H);\n\t\t}else if(not uf.same(h,H+W+2)){\n\t\t\tans += a;\n\t\t\tuf.unite(h,H+W+2);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Card {\n  int row;\n  int col;\n  int value;\n};\n\nint main() {\n  int N, H, W;\n  cin >> N >> H >> W;\n  vector<int> parent(W + H + 1, -1);\n  vector<bool> saturated(W + H + 1);\n  vector<Card> cards;\n  for (int i = 1; i <= N; ++i) {\n    cards.emplace_back();\n    auto&& c = cards.back();\n    cin >> c.row >> c.col >> c.value;\n    c.col += H;\n  }\n  auto cmp = [](auto&& lhs, auto&& rhs) {\n    return lhs.value > rhs.value;\n  };\n  sort(cards.begin(), cards.end(), cmp);\n  int64_t result = 0;\n  for (auto&& card : cards) {\n    int row = card.row;; \n    for (; parent[row] != -1; row = parent[row]);\n    int col = card.col;; \n    for (; parent[col] != -1; col = parent[col]);\n    if (row == col) {\n      if (saturated[row]) {\n        continue;\n      }\n      saturated[row] = true;\n    } else {\n      if (saturated[row] && saturated[col]) {\n        continue;\n      }\n      parent[col] = row;\n      saturated[row] = saturated[row] || saturated[col];\n    }\n    result += card.value;\n  }\n  cout << result << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100005, H = 100005, W = 100005;\nint n, h, w;\nlong long a[N], ans = 0ll;\nint r[N], c[N];\nstruct node {\n    int u, v;\n    long long w;\n    bool operator < (node rhs) const {\n        return w > rhs.w;\n    }\n} e[N];\nint fa[H + W];\nbool mark[H + W];\nint findroot (int x) {\n    return fa[x] == x ? x : fa[x] = findroot(fa[x]);\n}\nint main () {\n    scanf(\"%d%d%d\", &n, &h, &w);\n    for (int i = 1; i <= n; i++) scanf(\"%d%d%lld\", &r[i], &c[i], &a[i]);\n    for (int i = 1; i <= n; i++) {\n        e[i].u = r[i], e[i].v = h + c[i];\n        e[i].w = a[i];\n    }\n    sort(e + 1, e + n + 1);\n    for (int i = 1; i <= h + w; i++) fa[i] = i, mark[i] = false;\n    for (int i = 1; i <= n; i++) {\n        int ru = findroot(e[i].u), rv = findroot(e[i].v);\n        if (ru == rv) {\n            if (!mark[ru]) ans += e[i].w, mark[ru] = true;\n        }\n        else {\n            if (!mark[ru] || !mark[rv]) {\n                fa[ru] = rv, mark[rv] |= mark[ru];\n                ans += e[i].w;\n            }\n        }\n    }\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define name \"main\"\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define fto(i,a,b) for(int i=a; i<=b;++i)\n#define maxn 100009\n#define ll long long\n\nusing namespace std;\nbool gone[maxn][3],ck[maxn][3];\nint cl[maxn];\nint xd[maxn][3],a[maxn][3],w,h,n;\npii b[maxn];\nbool check(int i, int x,int j){\n    if(ck[i][x])return false;\n    ck[i][x]=true;\n    if(xd[i][x]==0){\n        xd[i][x]=j;\n        ck[i][x]=false;\n        return true;\n    }\n    /// xd[i][x]!=0;\n    /// i,x la cot hoac hang, j la chi so can dien\n    /// t la so can dien\n    int t=xd[i][x];\n    if(check(a[t][1-x],1-x,t)){\n        xd[i][x]=j;\n        ck[i][x]=false;\n        return true;\n    }\n    return false;\n}\nint main()\n{\n    cin >> n >> h >> w;\n    fto(i,1,n){\n        cin >> a[i][0]>> a[i][1] >> b[i].fi;\n        b[i].se=i;\n    }\n    sort(b+1,b+n+1,greater<pii> ());\n    ll res=0;\n    fto(i,1,n){\n        int j=b[i].se;\n        if(check(a[j][0],0,j)){\n            //xd[a[j][0]][0]=j;\n            res+=b[i].fi;\n        }\n        else if(check(a[j][1],1,j)){\n            //xd[a[j][1]][1]=j;\n            res+=b[i].fi;\n        }\n    }\n    cout << res ;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n// #define int long long\n// #define double long double\n#define rep(i,n) for (int i=0; i<(int)(n); ++i)\n#define rep1(i,n) for (int i=1; i<(int)(n); ++i)\n#define repeq(i,n) for (int i=0; i<=(int)(n); ++i)\n#define rep1eq(i,n) for (int i=1; i<=(int)(n); ++i)\n#define rrep(i,n) for (int i=(int)(n)-1; i>=0; --i)\n#define rrep1(i,n) for (int i=(int)(n)-1; i>0; --i)\n#define rrepeq(i,n) for (int i=(int)(n); i>=0; --i)\n#define rrep1eq(i,n) for (int i=(int)(n); i>0; --i)\n#define REP(i,a,b) for (int i=(int)(a); i<=(int)(b); ++i)\n#define RREP(i,a,b) for (int i=(int)(a); i>=(int)(b); --i)\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vb = vector<bool>;\ntemplate<typename T> using Graph = vector<vector<T>>;\ntemplate<typename T> using Spacial = vector<vector<vector<T>>>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\ntemplate<typename T> using greater_priority_queue = priority_queue<T, vector<T>, greater<T>>;\nconst int MOD = 1e9+7;\nconst int MOD2 = 998244353;\n// const double EPS = 1e-9;\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\nstring interval[2] = {\" \", \"\\n\"}; // {\" \", \"\\n\"}\n\ntemplate<typename T> struct is_plural : false_type{};\ntemplate<typename T1, typename T2> struct is_plural<pair<T1, T2>> : true_type{};\ntemplate<typename T> struct is_plural<vector<T>> : true_type{};\ntemplate<typename T> struct is_plural<complex<T>> : true_type{};\n \ntemplate<typename T1, typename T2> istream &operator>>(istream &is, pair<T1, T2> &p) { return is >> p.first >> p.second; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p) { return os << p.first << \" \" << p.second; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec) { for (auto itr = vec.begin(); itr != vec.end(); ++itr) is >> *itr; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec) { if (vec.empty()) return os; bool pl = is_plural<T>(); os << vec.front(); for (auto itr = ++vec.begin(); itr != vec.end(); ++itr) os << interval[pl] << *itr; return os; }\n \nbool CoutYN(bool a, string y = \"Yes\", string n = \"No\") { cout << (a ? y : n) << \"\\n\"; return a; }\n\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\nlong long modpow(int a, long long n, int mod = MOD) { long long ret = 1; do { if (n & 1) ret = ret * a % mod; a = 1LL * a * a % mod; } while (n >>= 1); return ret; }\n\ntemplate<typename T> T GCD(T a, T b) { return b ? GCD(b, a%b) : a; }\ntemplate<typename T> T LCM(T a, T b) { return a / GCD(a, b) * b; }\n\ntemplate<typename T1, typename T2> bool CompareBySecond(pair<T1, T2> a, pair<T1, T2> b) { return a.second != b.second ? a.second < b.second : a.first < b.first; }\ntemplate<typename T1, typename T2> bool CompareByInverse(pair<T1, T2> a, pair<T1, T2> b) { return a.first != b.first ? a.first < b.first : a.second > b.second; }\n\n\n/* -------- <templates end> -------- */\n\n\ntemplate<typename T>\nstruct edge {\n  int from, to;\n  T cost;\n\n  edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n\n  edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n\n  operator int() const { return to; }\n\n  bool operator<(const edge<T> &e) const {\n    return cost > e.cost;\n  }\n};\n\ntemplate<typename T> using Edges = vector<edge<T>>;\ntemplate<typename T> using WeightedGraph = vector<vector<edge<T>>>;\n\nvoid solve() {\n  int n, h, w; cin >> n >> h >> w;\n  vector<multiset<edge<int>>> g(h+w);\n  rep(_,n) {\n    int r, c, a; cin >> r >> c >> a;\n    --r, c += h-1;\n    g[r].emplace(r, c, a);\n    g[c].emplace(r, c, a);\n  }\n\n  vb seen(h+w, false);\n  ll ans = 0;\n\n  rep(i,h+w) {\n    if (!seen[i]) {\n      seen[i] = true;\n      multiset<edge<int>> s;\n      for (auto &e : g[i]) s.emplace(e);\n      while (!s.empty()) {\n        auto card = *begin(s); s.erase(s.begin());\n        ans += card.cost;\n        g[card.from].erase(g[card.from].find(card));\n        g[card.to].erase(g[card.to].find(card));\n        if (!seen[card.from]) {\n          seen[card.from] = true;\n          for (auto &e : g[card.from]) {\n            if (!seen[e.to]) s.emplace(e);\n          }\n        } else if (!seen[card.to]) {\n          seen[card.to] = true;\n          for (auto &e : g[card.to]) {\n            if (!seen[e.from]) s.emplace(e);\n          }\n        } else break;\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\n\n/* -------- <programs end> -------- */\n\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <queue>\nusing namespace std;\n\ntypedef long long flow_type;\n\nconst int VSIZE=1000000,ESIZE=1000000;\n\nconst long long  INF=1000000000000ll;\n\npair<flow_type,flow_type> MCF(vector<vector<int> > &e,vector<vector<flow_type> > &cp,vector<vector<flow_type> > &ct,int s,int t)\n{\n  int n=e.size();\n  static flow_type F[ESIZE]={0},CP[ESIZE],CT[ESIZE];\n  int K=0;\n  vector<vector<int> > fk(n),be(n),bfk(n);\n  for(int i=0;i<n;i++){\n    for(int j=0;j<e[i].size();j++){\n      int k=e[i][j];\n      CP[K]=cp[i][j];\n      CT[K]=ct[i][j];\n      fk[i].push_back(K);\n      be[k].push_back(i);\n      bfk[k].push_back(K);\n      K++;\n    }\n  }\n  static flow_type MF=0,MC=0,H[VSIZE]={0};\n  while(1){\n    static flow_type D[VSIZE];\n    for(int i=0;i<n;i++){\n      D[i]=INF;\n    }\n    D[s]=0;\n    static int B[VSIZE],BK[VSIZE],BS[VSIZE];\n    priority_queue<pair<flow_type,int> > Q;\n    Q.push(make_pair(0ll,s));\n    while(!Q.empty()){\n      pair<flow_type,int> p=Q.top();\n      Q.pop();\n      long long d=-p.first;\n      int i=p.second;\n      if(D[i]<d){\n\tcontinue;\n      }\n      for(int j=0;j<e[i].size();j++){\n\tint k=e[i][j],K=fk[i][j];\n\tif(F[K]==CP[K]){\n\t  continue;\n\t}\n\tflow_type nd=d+CT[K]+H[i]-H[k];\n\tif(D[k]>nd){\n\t  D[k]=nd;\n\t  B[k]=i;\n\t  BK[k]=K;\n\t  BS[k]=1;\n\t  Q.push(make_pair(-nd,k));\n\t}\n      }\n      for(int j=0;j<be[i].size();j++){\n\tint k=be[i][j],K=bfk[i][j];\n\tif(F[K]==0){\n\t  continue;\n\t}\n\tflow_type nd=d-CT[K]+H[i]-H[k];\n\tif(D[k]>nd){\n\t  D[k]=nd;\n\t  B[k]=i;\n\t  BK[k]=K;\n\t  BS[k]=-1;\n\t  Q.push(make_pair(-nd,k));\n\t}\n      }\n    }\n    if(D[t]==INF){\n      break;\n    }\n    MF++;\n    int l=t;\n    while(l!=s){\n      F[BK[l]]+=BS[l];\n      l=B[l];\n    }\n    for(int i=0;i<n;i++){\n      H[i]+=D[i];\n    }\n    if(H[t]>0)\n      break;\n    MC+=H[t];\n  }\n  return make_pair(MF,MC);\n}\n\nint main()\n{\n  int n,h,w;\n  scanf(\"%d%d%d\",&n,&h,&w);\n  vector<int> r(n),c(n);\n  vector<long long> A(n);\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d%lld\",&r[i],&c[i],&A[i]);\n    r[i]--,c[i]--;\n  }\n  vector<vector<int> > e(2+h+w+n);\n  vector<vector<long long> > cap(2+h+w+n);\n  vector<vector<long long> > cost(2+h+w+n);\n  int s=h+w+n,t=h+w+n+1;\n  for(int i=0;i<h+w;i++){\n    e[s].push_back(i);\n    cap[s].push_back(1);\n    cost[s].push_back(0);\n  }\n  for(int j=0;j<n;j++){\n    e[r[j]].push_back(h+w+j);\n    cap[r[j]].push_back(1);\n    cost[r[j]].push_back(0);\n    e[h+c[j]].push_back(h+w+j);\n    cap[h+c[j]].push_back(1);\n    cost[h+c[j]].push_back(0);\n    e[h+w+j].push_back(t);\n    cap[h+w+j].push_back(1);\n    cost[h+w+j].push_back(-A[j]);\n  }\n  pair<long long,long long> ans=MCF(e,cap,cost,s,t);\n  printf(\"%lld\\n\",-ans.second);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int MAXN = 1e5 + 10;\n\nstruct node{\n    int u,v;\n    ll w;\n}edge[MAXN];\n\nbool cmp(node a,node b){return a.w > b.w;}\n\nint cy[MAXN<<1],n,h,w;\nbool vis[MAXN];\n\nunordered_map<ll,int> g;\n\nbool dfs(int i)\n{\n    if (vis[i]) return false;\n    ll num = (ll)edge[i].u * 1000000 + (ll)edge[i].v;\n    if (g.count(num) && g[num] >= 2) return false;\n    vis[i] = 1;\n    if (cy[edge[i].u] == 0)\n    {\n        cy[edge[i].u] = i;\n        return true;\n    }\n    else if (cy[edge[i].v + MAXN] == 0)\n    {\n        cy[edge[i].v + MAXN] = i;\n        return true;\n    }\n    if (dfs(cy[edge[i].u]))\n    {\n        cy[edge[i].u] = i;\n        return true;\n    }\n    else if (dfs(cy[edge[i].v + MAXN]))\n    {\n        cy[edge[i].v + MAXN] = i;\n        return true;\n    }\n    return false;\n}\n\nll match()\n{\n    for (int i = 1;i<=n;i++)\n    {\n        memset(vis,0,sizeof(vis));\n        ll num = (ll)edge[i].u * 1000000 + (ll)edge[i].v;\n        if (g.count(num) && g[num] >= 2) continue;\n        g[num]++;\n        // for(int j=1;j<=n;j++) vis[i]=0;\n        dfs(i);\n    }\n    ll ans = 0;\n    for (int i = 1;i<=h;i++) ans += edge[cy[i]].w;\n    for (int i = MAXN + 1;i<=MAXN + w;i++) ans += edge[cy[i]].w;\n    return ans;\n}\n\nint main()\n{\n    // cin>>n>>h>>w;\n    scanf(\"%d%d%d\",&n,&h,&w);\n    for (int i = 1;i<=n;i++)\n    {\n        scanf(\"%d%d%lld\",&edge[i].u,&edge[i].v,&edge[i].w);\n    }\n    sort(edge+1,edge + n + 1,cmp);\n    // cout<<match();\n    printf(\"%lld\",match());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n[jsc2019-qual] E - Card Collector\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, int> pli;\ntypedef pair<ll, ll> pll;\n#define ALL(c) (c).begin(), (c).end()\n\nconst int MAX_N = 1e5;\nconst int MAX_H = 1e5;\nconst int MAX_W = 1e5;\nconst ll MAX_A = 1e5;\n\nconst int MAX_V = 2 + MAX_H + MAX_W + MAX_N;\nconst ll INF = 1e18;\n\nstruct edge {\n    int to, cap;\n    ll cost;\n    int rev;\n};\n\nclass Graph {\npublic:\n    void add_edge(int from, int to, int cap, ll cost) {\n        g[from].push_back((edge){to, cap, cost, (int)g[to].size()});\n        g[to].push_back((edge){from, 0, -cost, (int)g[from].size() - 1});\n        return;\n    }\n    ll min_cost_flow(int s, int t, int f) {\n        priority_queue<pair<ll, int>, vector<pair<ll, int>>,\n                       greater<pair<ll, int>>>\n            que;\n        // first: tmp min distance, second: vertex index\n        pair<ll, int> p;\n        int d;\n        ll cost = 0;\n\n        memset(h, 0, sizeof(h));\n        while (f > 0) {\n            fill(dist, dist + MAX_V, INF);\n            dist[s] = 0;\n            que.push(pair<ll, int>(0, s));\n            while (!que.empty()) {\n                p = que.top();\n                que.pop();\n                int v = p.second;\n                if (dist[v] < p.first) {\n                    continue;\n                }\n                for (int i = 0; i < (int)g[v].size(); i++) {\n                    edge e = g[v][i];\n                    if (e.cap > 0 &&\n                        dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                        dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                        pre_v[e.to] = v;\n                        pre_e[e.to] = i;\n                        que.push(pair<ll, int>(dist[e.to], e.to));\n                    }\n                }\n            }\n            if (dist[t] >= INF) {\n                return -1;\n            }\n\n            for (int v = 0; v < MAX_V; v++) {\n                h[v] = min(INF, h[v] + dist[v]);\n            }\n\n            d = f;\n            for (int v = t; v != s; v = pre_v[v]) {\n                d = min(d, g[pre_v[v]][pre_e[v]].cap);\n            }\n            f -= d;\n            cost += h[t] * d;\n            for (int v = t; v != s; v = pre_v[v]) {\n                edge &e = g[pre_v[v]][pre_e[v]];\n                e.cap -= d;\n                g[v][e.rev].cap += d;\n            }\n        }\n        return cost;\n    }\n\nprivate:\n    vector<edge> g[MAX_V];\n    ll h[MAX_V];\n    ll dist[MAX_V];\n    int pre_v[MAX_V], pre_e[MAX_V];\n};\n\nint N, H, W;\nint R[MAX_N], C[MAX_N], A[MAX_N];\nGraph g;\n\nll solve() {\n    int s = H + W + N;\n    int t = s + 1;\n    for (int i = 0; i < H; i++) {\n        g.add_edge(s, i, 1, 0);\n    }\n    for (int i = 0; i < W; i++) {\n        g.add_edge(s, H + i, 1, 0);\n    }\n    for (int i = 0; i < N; i++) {\n        g.add_edge(R[i], H + W + i, 1, MAX_A - A[i]);\n        g.add_edge(H + C[i], H + W + i, 1, MAX_A - A[i]);\n        g.add_edge(H + W + i, t, 1, 0);\n    }\n    g.add_edge(s, t, N, MAX_A);\n\n    ll ans = N * MAX_A - g.min_cost_flow(s, t, N);\n\n    return ans;\n}\n\nint main() {\n    cin >> N >> H >> W;\n    for (int i = 0; i < N; i++) {\n        cin >> R[i] >> C[i] >> A[i];\n        R[i]--, C[i]--;\n    }\n\n    cout << solve() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst int maxn = 2e5 + 10;\n\nvector<int> g[maxn];\nint mt[maxn];\nint used[maxn];\nint cn = 1;\nvector<ll> prm = { 0, 1 };\n\nbool dfs(int v) {\n\tif (used[v] == cn) return false;\n\n\tused[v] = cn;\n\n\tll rnd = rand() % 2;\n\tif (rnd == 1) {\n\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\tint u = g[v][i];\n\t\t\tif (mt[u] == -1 || dfs(mt[u])) {\n\t\t\t\tmt[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\tint u = g[v][1 - i];\n\t\t\tif (mt[u] == -1 || dfs(mt[u])) {\n\t\t\t\tmt[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\treturn false;\n}\n\nint main()\n{\n\tfastInp;\n\n\tll n, h, w;\n\tcin >> n >> h >> w;\n\n\tll vals = 0, ans = 0;\n\tvector<tuple<ll, ll, ll>> vec;\n\tfor (int i = 0; i < h + w + 3; i++) mt[i] = -1;\n\tfor (int i = 0; i < n; i++) {\n\t\tll r, c, a;\n\t\tcin >> r >> c >> a;\n\t\tr--; c--;\n\t\tvec.push_back({ a, r, c });\n\t}\n\n\tsort(vec.rbegin(), vec.rend());\n\n\tll cnt = 0;\n\tll hw = h + w;\n\tfor (int i = 0; i < n; i++) {\n\t\tll r = get<1>(vec[i]), c = get<2>(vec[i]), a = get<0>(vec[i]);\n\t\tif (mt[r] == -1 || mt[c + h + 1] == -1) {\n\t\t\tvals++;\n\t\t\tcnt++;\n\t\t\tg[i].push_back(r);\n\t\t\tg[i].push_back(c + h + 1);\n\t\t\tif (mt[r] == -1) {\n\t\t\t\tmt[r] = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmt[c + h + 1] = i;\n\t\t\t}\n\t\t\tans += a;\n\t\t\tcontinue;\n\t\t}\n\t\tcn++;\n\t\tvals++;\n\t\t\n\t\tg[i].push_back(r);\n\t\tg[i].push_back(c + h + 1);\n\t\tcnt += dfs(i);\n\n\t\tif (cnt >= vals) {\n\t\t\tans += a;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tvals--;\n\t\t\tg[i].pop_back();\n\t\t\tg[i].pop_back();\n\t\t}\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int,int>;\nusing pll = pair<ll,ll>;\nusing vi = vector<int>;\nusing vl = vector<ll>;\n\nusing _loop_int = int;\n#define REP(i,n) for(_loop_int i=0; i<(_loop_int)(n); i++)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a); i<(_loop_int)(b); i++)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1; i>=(_loop_int)(a); i--)\n\n#define CHMIN(a,b) (a)=min((a),(b))\n#define CHMAX(a,b) (a)=max((a),(b))\n#define ALL(v) (v).begin(),(v).end()\n\n#define DEBUG(x) cerr<<#x<<\": \"<<(x)<<endl\n#define DEBUG_VEC(v) cerr<<#v<<\": \";REP(__i,(v).size())cerr<<((v)[__i])<<\", \";cerr<<endl\n\nconst ll MOD = 1000000007ll;\n\nint n, h, w;\npair<int,pii> pts[125252];\n\nint dat[252521];\nint cnt[252521];\nint root(int x){\n    return dat[x]<0?x:dat[x]=root(dat[x]);\n}\nvoid unite(int a, int b){\n    a=root(a);b=root(b);\n    if(a==b)return;\n    if(dat[a]>dat[b])swap(a,b);\n    dat[a] += dat[b];\n    dat[b] = a;\n    cnt[a] += cnt[b];\n}\n\nint main(){\n    scanf(\"%d%d%d\",&n,&h,&w);\n    REP(i,n){\n        int r,c,a;\n        scanf(\"%d%d%d\",&r,&c,&a);\n        --r;--c;\n        pts[i] = make_pair(a,pii(r,c));\n    }\n    sort(pts,pts+n);\n    reverse(pts,pts+n);\n    fill(dat,dat+(h+w),-1);\n    fill(cnt,cnt+(h+w),1);\n    ll ans = 0;\n    REP(i,n){\n        int r,c,a;\n        a = pts[i].first;\n        tie(r,c) = pts[i].second;\n        r = root(r);\n        c = root(c+h);\n        if(cnt[r]>0 || cnt[c]>0){\n            unite(r,c);\n            ans += a;\n            r = root(r);\n            cnt[r]--;\n        }\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst int MAXN = 1.1e5;\nint N, H, W;\npair<int, pair<int, int>> E[MAXN];\n\nconst int MAXV = 2.1e5;\nint V;\nint par[MAXV];\nint cnt[MAXV];\nint sz[MAXV];\n\nint getpar(int a) {\n\treturn par[a] == -1 ? a : (par[a] = getpar(par[a]));\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> N >> H >> W;\n\tfor (int e = 0; e < N; e++) {\n\t\tint r, c, a; cin >> r >> c >> a; r--, c--;\n\t\tE[e] = {a, {r, H+c}};\n\t}\n\tsort(E, E + N);\n\treverse(E, E + N);\n\n\tV = H + W;\n\tfor (int v = 0; v < V; v++) {\n\t\tpar[v] = -1;\n\t\tcnt[v] = 0;\n\t\tsz[v] = 1;\n\t}\n\tll ans = 0;\n\tauto isGood = [&](int a, int b) -> bool {\n\t\ta = getpar(a);\n\t\tb = getpar(b);\n\t\tif (a == b) {\n\t\t\tif (cnt[a] == sz[a]) return false;\n\t\t\tcnt[a]++;\n\t\t\treturn true;\n\t\t}\n\t\tif (sz[a] + sz[b] == cnt[a] + cnt[b]) return false;\n\t\tif (sz[a] > sz[b]) swap(a, b);\n\t\tsz[b] += sz[a];\n\t\tcnt[b] += cnt[a] + 1;\n\t\tpar[a] = b;\n\t\treturn true;\n\t};\n\tfor (int e = 0; e < N; e++) {\n\t\tif (isGood(E[e].second.first, E[e].second.second)) {\n\t\t\tans += E[e].first;\n\t\t}\n\t}\n\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = ll(A); I < ll(B); ++I)\n#define FORR(I,A,B) for(ll I = ll((B)-1); I >= ll(A); --I)\n#define TO(x,t,f) ((x)?(t):(f))\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //xi>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //xi>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\nll gcd(ll a,ll b){if(a%b==0)return b;return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nconst ll INF=ll(1e18)+ll(7);\nconst ll MOD=1000000007LL;\n#define out(a) cout<<fixed<<setprecision((a))\n\nclass UnionFind{\npublic:\n\tvector<int> par;\n\t//0-indexed\n\tUnionFind(int n){init(n);}\n\tvoid init(int n = 1) {\n\t\tpar.resize(n);\n\t\tfor (int i = 0; i < n; ++i) par[i] = i;\n\t}\n\tint root(int x = 1){\n\t\tif(par[x]==x)return x;\n\t\telse{\n\t\t\treturn par[x] = root(par[x]);\n\t\t}\n\t}\n\tvoid unite(int x = 1,int y = 1){\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif(x==y)return;\n\t\telse par[x] = y;\n\t}\n\tbool same(int x,int y){\n\t\treturn root(x)==root(y);\n\t}\n};\n\n\n// なもりグラフ\n// https://www.hamayanhamayan.com/entry/2019/08/25/090415\n\nint main(){\n\tint N,H,W;\n\tll ans = 0;\n\tcin >> N >> H >> W;\n\tUnionFind uf(H+W+6);\n\tpriority_queue< pair<ll,P> > pq;\n\tFOR(i,0,N){\n\t\tint r,c,a;\n\t\tcin >> r >> c >> a;\n\t\tpq.push({a,{r,c}});\n\t}\n\tFOR(i,0,N){\n\t\tauto X = pq.top();\n\t\tint h = X.second.first;\n\t\tint w = X.second.second;\n\t\tint a = X.first;\n\t\tpq.pop();\n\t\tif(not uf.same(h,w+H)){\n\t\t\tans += a;\n\t\t\tuf.unite(h,w+H);\n\t\t}else if(not uf.same(h,H+W+2)){\n\t\t\tans += a;\n\t\t\tuf.unite(h,H+W+2);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// Optimization\n\n//#pragma GCC optimize(\"O3\")\n#define endl '\\n'\n\n// Shortcut\n\n#define int long long\n#define eb emplace_back\n#define pb push_back\n#define pob pop_back\n#define mp make_pair\n#define upb upper_bound\n#define lwb lower_bound\n#define fi first\n#define se second\n#define For(i, l, r) for (int i = l; i < r; i++)\n#define ForE(i, l, r) for (int i = l; i <= r; i++)\n#define Ford(i, r, l) for (int i = r; i > l; i--)\n#define FordE(i, r, l) for (int i = r; i >= l; i--)\n#define Fora(i, a) for (auto i : a)\n\n// I/O & Debug\n\n#define PrintV(a) Fora(iiii, a) cout << iiii << ' '; cout << endl;\n#define PrintVl(a) Fora(iiii, a) cout << iiii << endl;\n#define PrintA(a, l, r) for (int iiii = l; iiii <= r; iiii++) cout << a[iiii] << ' '; cout << endl;\n#define PrintAl(a, l, r) for (int iiii = l; iiii <= r; iiii++) cout << a[iiii] << endl;\n#define Ptest(x) return cout << x, 0;\n#define gl(s) getline(cin, s);\n#define setpre(x) fixed << setprecision(x)\n/*\n#define debug(args...){ string _sDEB = #args; replace(_sDEB.begin(), _sDEB.end(), ',', ' '); stringstream _ssDEB(_sDEB); istream_iterator<string> _itDEB(_ssDEB); DEB(_itDEB, args); }\nvoid DEB(istream_iterator<string> it) {}\ntemplate<typename T, typename... Args>\nvoid DEB(istream_iterator<string> it, T a, Args... args){\n    cout << *it << \" = \" << a << endl;\n    DEB(++it, args...);\n}\n*/\n\n// Functions\n\n//#define isvowel(a) (a == 'a' || a == 'e' || a == 'i' || a == 'o' || a == 'u')\n#define bend(a) a.begin(), a.end()\n#define rbend(a) a.rbegin(), a.rend()\n#define mset(a) memset(a, 0, sizeof(a))\n#define mset1(a) memset(a, 1, sizeof(a))\n#define msetn1(a) memset(a, -1, sizeof(a))\n#define msetinf(a) memset(a, 0x3f, sizeof(a))\n#define gcd __gcd\n#define __builtin_popcount __builtin_popcountll\n//mt19937 rando(chrono::steady_clock::now().time_since_epoch().count());\n\n// Data Structure\n\n#define pque priority_queue\n#define mts multiset\n#define y0 _y0_\n#define y1 _y1_\n#define div divi\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <ld> vld;\ntypedef vector <string> vs;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef vector <vi > vvi;\ntypedef vector <vll > vvll;\ntypedef vector <pii > vpii;\ntypedef vector <pll > vpll;\n\nconst int N = 2e5 + 5, mod = 1e9 + 7, mod1 = 998244353, mod2 = 1e9 + 9, inf = 1e18 + 7;\nconst ll infll = 1e18 + 7;\n\nint n, h, w, ans;\nvector <pair <int, pii>> edges;\nbool ck[N];\n\nstruct disjoint_set_union{\n    int par[N];\n    \n    void init(){\n        msetn1(par);\n    }\n\n    int root(int x){\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n\n    bool merge(int x, int y){\n        if ((x = root(x)) == (y = root(y))){\n            if (ck[x]) return 0;\n            ck[x] = 1;\n            return 1;\n        }\n        if (ck[x] && ck[y]) return 0;\n        par[x] += par[y];\n        par[y] = x;\n        ck[y] |= ck[x];\n        return 1;\n    }\n} dsu;\n\nsigned main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    cin >> n >> h >> w;\n    For(i, 0, n){\n        int x, y, z; cin >> x >> y >> z; y += h;\n        edges.pb({z, {x, y}});\n    }\n    sort(rbend(edges));\n    dsu.init();\n    Fora(edge, edges){\n        if (dsu.merge(edge.se.fi, edge.se.se)){\n            ans += edge.fi;\n        }\n    }\n    cout << ans;\n}\n\n/*\n==================================+\nINPUT:                            |\n------------------------------    |\n\n------------------------------    |\n==================================+\nOUTPUT:                           |\n------------------------------    |\n\n------------------------------    |\n==================================+\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define dbug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile ('0'>ch||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo {(t*=10)+=ch-'0';ch=getchar();} while ('0'<=ch&&ch<='9'); t*=f;\n}\ntypedef long long ll;\nconst int maxn=(2e5)+10;\nint n,m1,m2,fa[maxn],sz[maxn];\nll ans;\nstruct node {\n\tint x,y,z;\n} d[maxn];\nbool cmp(node a,node b) {\n\treturn a.z>b.z;\n}\nint find(int x) {\n\tif (fa[x]==x) return x;\n\treturn fa[x]=find(fa[x]);\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n); read(m1); read(m2);\n\tint x,y,z;\n\tfor (int i=1;i<=n;i++) {\n\t\tread(x); read(y); read(z);\n\t\td[i]=(node){x,y+m1,z};\n\t}\n\tsort(d+1,d+n+1,cmp);\n\tfor (int i=1;i<=m1+m2;i++) fa[i]=i;\n\tfor (int i=1;i<=n;i++) {\n\t\tx=d[i].x; y=d[i].y; z=d[i].z;\n\t\tx=find(x); y=find(y);\n\t\tif (x==y) {\n\t\t\tif (sz[x]) continue;\n\t\t\tsz[x]=1;\n\t\t} else {\n\t\t\tif (sz[x]&&sz[y]) continue;\n\t\t\tfa[x]=y; sz[y]|=sz[y];\n\t\t}\n\t\tans+=z;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\nconst ll MOD = 1000000007;\n\n#define fr first\n#define sc second\n#define mp1(a,b,c) P1(a,P(b,c))\n#define rep(i,x) for(int i = 0 ; i < x ; i ++)\n#define pb push_back\nconst int INF = 1000000000;\n\nconst int MAX_V_flow = 300010;\nstruct FLOW{\n\tvector<P1> G[MAX_V_flow];\n\tbool used[MAX_V_flow];\n\t\n\tvoid init(){\n\t\trep(i,MAX_V_flow)G[i].clear();\n\t}\n\t\n\tvoid add_edge(int from,int to,int flow){\n\t\tG[from].pb( mp1 ( to , flow , G[to].size() ) );\n\t\tG[to].pb( mp1 ( from , 0 , G[from].size()-1 ) );\n\t}\n\t\n\tint dfs(int v,int t,int f){\n\t\tif(v == t)return f;\n\t\tused[v] = true;\n\t\trep(i,G[v].size()){\n\t\t\tif(!used[G[v][i].fr] && G[v][i].sc.fr > 0){\n\t\t\t\tint d = dfs(G[v][i].fr,t,min(f,G[v][i].sc.fr));\n\t\t\t\tif(d > 0){\n\t\t\t\t\tG[v][i].sc.fr -= d;\n\t\t\t\t\tG[G[v][i].fr][G[v][i].sc.sc].sc.fr += d;\n\t\t\t\t\treturn d;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tint flow(int s,int t){\n\t\t//int ret = 0,d = 1;\n\t\t//while(d > 0){\n\t\t\t//rep(i,MAX_V_flow)used[i] = false;\n\t\t\tint d = dfs(s,t,INF);\n\t\t\treturn d;\n\t\t\t//ret += d;\n\t\t//}\n\t\t//return ret;\n\t}\n\t\n\tvoid unused(int v){\n\t\tif(!used[v])return;\n\t\tused[v] = false;\n\t\tfor(int i = 0 ; i < G[v].size() ; i ++){\n\t\t\tif(G[G[v][i].fr][G[v][i].sc.sc].sc.fr > 0)unused(G[v][i].fr);\n\t\t}\n\t}\n}flow;\n\nint main(){\n\tstatic int n,h,w;\n\tstatic int r[100010],c[100010],a[100010];\n\tscanf(\"%d%d%d\",&n,&h,&w);\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tscanf(\"%d%d%d\",&r[i],&c[i],&a[i]);\n\t}\n\t\n\tfor(int i = 1 ; i <= h+w ; i ++){\n\t\tflow.add_edge(0,i,1);\n\t}\n\tvector<P1> vec;\n\tfor(int i = 1 ; i <= n ; i ++){\n\t\tvec.push_back(mp1(a[i],r[i],c[i]));\n\t}\n\tsort(vec.begin(),vec.end());\n\treverse(vec.begin(),vec.end());\n\t\n\trep(i,MAX_V_flow)flow.used[i] = false;\n\tll ret = 0;\n\tfor(int i = 0 ; i < vec.size() ; i ++){\n\t\tP1 p = vec[i];\n\t\tflow.add_edge(p.sc.fr,h+w+i+1,1);\n\t\tflow.add_edge(h+p.sc.sc,h+w+i+1,1);\n\t\tflow.add_edge(h+w+i+1,h+w+n+1,1);\n\t\tflow.unused(p.sc.fr);\n\t\tflow.unused(h+p.sc.sc);\n\t\t//flow.unused(h+w+i+1);\n\t\tif(flow.flow(0,h+w+n+1))ret += p.fr;\n\t}\n\tcout << ret << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <cmath>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<iomanip>\n#define _USE_MATH_DEFINES\n#include <math.h>\n#include <functional>\n#include<complex>\nusing namespace std;\n\n#define rep(i,x) for(ll i=0;i<x;i++)\n#define repn(i,x) for(ll i=1;i<=x;i++)\n\ntypedef long long ll;\nconst ll INF = 1e17;\nconst ll MOD = 1000000007;\nconst ll MAX = 4000001;\nconst double eps = 1E-18;\n\nll max(ll a, ll b) {\n\tif (a > b) { return a; }\n\treturn b;\n}\n\nll min(ll a, ll b) {\n\tif (a > b) { return b; }\n\treturn a;\n}\n\nll gcd(ll a, ll b) {\n\tif (b == 0) { return a; }\n\tif (a < b) { return gcd(b, a); }\n\treturn gcd(b, a % b);\n}\n\nll lcm(ll a, ll b) {\n\treturn a / gcd(a, b) * b;\n}\n\nstruct edge {\n\tll ind;\n\tll fr;\n\tll to;\n\tll d;\n};\n\nclass mint {\n\tlong long x;\npublic:\n\tmint(long long x = 0) : x((x% MOD + MOD) % MOD) {}\n\tmint operator-() const {\n\t\treturn mint(-x);\n\t}\n\tmint& operator+=(const mint& a) {\n\t\tif ((x += a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator-=(const mint& a) {\n\t\tif ((x += MOD - a.x) >= MOD) x -= MOD;\n\t\treturn *this;\n\t}\n\tmint& operator*=(const  mint& a) {\n\t\t(x *= a.x) %= MOD;\n\t\treturn *this;\n\t}\n\tmint operator+(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res += a;\n\t}\n\tmint operator-(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res -= a;\n\t}\n\tmint operator*(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res *= a;\n\t}\n\n\tmint pow(ll t) const {\n\t\tif (!t) return 1;\n\t\tmint a = pow(t >> 1);\n\t\ta *= a;\n\t\tif (t & 1) a *= *this;\n\t\treturn a;\n\t}\n\n\t// for prime MOD\n\tmint inv() const {\n\t\treturn pow(MOD - 2);\n\t}\n\tmint& operator/=(const mint& a) {\n\t\treturn (*this) *= a.inv();\n\t}\n\tmint operator/(const mint& a) const {\n\t\tmint res(*this);\n\t\treturn res /= a;\n\t}\n\n\tfriend ostream& operator<<(ostream& os, const mint& m) {\n\t\tos << m.x;\n\t\treturn os;\n\t}\n};\n\nmint pw(mint a, ll b) {\n\tif (b == 0) { return 1; }\n\tmint ret = pw(a, b>>1);\n\tret *= ret;\n\tif (b & 1) { ret *= a; }\n\treturn ret;\n}\n\ntypedef vector<ll> vll;\ntypedef vector<vector<ll>> vvll;\ntypedef vector<vector<vector<ll>>> vvvll;\n\ntypedef vector<mint> vmint;\ntypedef vector<vector<mint>> vvmint;\ntypedef vector<vector<vector<mint>>> vvvmint;\n\n\n//////////////////////////\nstruct unionfind {\n\tll N;\n\tvector<ll> par;\n\tvector<ll> sz;//根の場合、その木のサイズ\n\n\tunionfind(ll N0) {\n\t\tN = N0;\n\t\tpar.assign(N + 1, -1);\n\t\tsz.assign(N + 1, 1);\n\n\t}\n\n\tll root(ll x) {\n\t\tif (par[x] == -1) { return x; }\n\t\tpar[x] = root(par[x]);\n\t\treturn par[x];\n\t}\n\n\tbool same(ll x, ll y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tvoid unite(ll x, ll y) {\n\t\tll a = root(x);\n\t\tll b = root(y);\n\t\tif (a != b) {\n\t\t\tpar[a] = b; sz[b] += sz[a];\n\t\t}\n\n\t}\n\n\tll size(ll x) {\n\t\tll r = root(x);\n\t\treturn sz[r];\n\t}\n};\nint main() {\n\tll N, H, W;\n\tcin >> N >> H >> W;\n\n\tpriority_queue<pair<ll, pair<ll, ll>>> q;\n\n\trepn(i, N) {\n\t\tll R, C, A;\n\t\tcin >> R >> C >> A;\n\t\tq.push({ A,{R,C} });\n\t}\n\n\tunionfind uf(H + W);\n\tvector<bool> dontad(H + W + 1, 0);\n\n\tll ans = 0;\n\n\trepn(i, N) {\n\t\tauto p = q.top();\n\t\tq.pop();\n\n\t\tll a = p.first;\n\t\tll r = p.second.first;\n\t\tll c = p.second.second + H;\n\n\t\tll x = uf.root(r);\n\t\tll y = uf.root(c);\n\n\t\tif (x!=y) {\n\t\t\tif ((dontad[x] & dontad[y]) == 0) {\n\t\t\t\tuf.unite(r, c);\n\t\t\t\tans += a;\n\t\t\t\tdontad[uf.root(r)] = (dontad[x] | dontad[y]);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (dontad[x] == 0) {\n\t\t\t\tans += a;\n\t\t\t\tdontad[x] = 1;\n\t\t\t}\n\t\t}\n\n\t\t//cout << a << \" \" << r << \" \" << c << \" \" << ans << endl;\n\n\t}\n\n\t\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\ntypedef long long ll;\n#define inf 0x3f3f3f3f\nint n,h,w;\nint x[maxn],y[maxn];\nll a[maxn];\nset<pair<ll,int> > qx[maxn],qy[maxn];\nvector<pair<ll,int> >cards;\nll ax,ay;\nbool ux[maxn],uy[maxn],usd[maxn];\nint cx[maxn],cy[maxn];\nqueue<int> que;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&h,&w);\n//\tmemset(cx,-1,sizeof(cx));\n//\tmemset(cy,-1,sizeof(cy));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%lld\",&x[i],&y[i],&a[i]);\n\t\tx[i]--;\n\t\ty[i]--;\n\t\tcx[x[i]]++;\n\t\tcy[y[i]]++;\n\t}\n    ll res=0,ans=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tqx[x[i]].insert(make_pair(a[i],i));\n\t\tqy[y[i]].insert(make_pair(a[i],i));\n\t}\n\tfor(int i=0;i<n;i++)if(!usd[i])\n\t\tcards.push_back(make_pair(a[i],i));\n\n    sort(cards.begin(),cards.end());\n    reverse(cards.begin(),cards.end());\n    for(int _=0;_<cards.size();_++)\n    {\n    \tint i=cards[_].second;\n\t//\tcout<<i<<\" \"<<x[i]<<\" \"<<y[i]<<\" \"<<qx[x[i]].top().second<<\" \"<<qy[y[i]].top().second<<endl;\n        qx[x[i]].erase(make_pair(a[i],i));\n        qy[y[i]].erase(make_pair(a[i],i));\n        if(ux[x[i]]&&uy[y[i]])continue;\n        if(ux[x[i]])\n        \tuy[y[i]]=1;\n        else if(uy[y[i]])\n        \tux[x[i]]=1;\n        else\n\t\t{\n\t\t\tax=qx[x[i]].empty()?-inf:(*(qx[x[i]].rbegin())).first;\n\t\t\tay=qy[y[i]].empty()?-inf:(*(qy[y[i]].rbegin())).first;\n\t\t\tif(ax<ay)\n\t\t\t{\n        //   \tcout<<\"puthang \"<<x[i]<<endl;\n            \tux[x[i]]=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n      \t//    \tcout<<\"putlie \"<<y[i]<<endl;\n \t    \t\tuy[y[i]]=1;\n \t    \t}\n        }\n        res+=a[i];\n    }\n    for(int i=0;i<h;i++) qx[i].clear();\n\tfor(int i=0;i<w;i++) qy[i].clear();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(cx[x[i]]==1||cy[y[i]]==1)\n\t\t\tque.push(i);\n\t\telse\n\t\t{\n\t\t\tqx[x[i]].insert(make_pair(a[i],i));\n\t\t\tqy[y[i]].insert(make_pair(a[i],i));\n\t\t}\n\t}\n\twhile(!que.empty())\n\t{\n\t\tint cur=que.front();\n\t\tque.pop();\n\t\tusd[cur]=1;\n\t\tans+=a[cur];\n\t\tusd[cur]=1;\n\t\tcx[x[cur]]--;\n\t\tcy[y[cur]]--;\n\t\tif(cx[x[cur]]==1)\n\t\t{\n\t\t\tif(!qx[x[cur]].empty())\n\t\t\t{\n\t\t\t\tpair<ll,int> he=*(qx[x[cur]].begin());\n\t\t\t\tqx[x[cur]].clear();\n\t\t\t\tint id=he.second;\n\t\t\t\tque.push(id);\n\t\t\t\tqy[y[id]].erase(he);\n\t\t\t}\n\t\t}\n\t\tif(cy[y[cur]]==1)\n\t\t{\n\t\t\tif(!qy[y[cur]].empty())\n\t\t\t{\n\t\t\t\tpair<ll,int> he=*(qy[y[cur]].begin());\n\t\t\t\tqy[y[cur]].clear();\n\t\t\t\tint id=he.second;\n\t\t\t\tque.push(id);\n\t\t\t\tqx[x[id]].erase(he);\n\t\t\t}\n\t\t}\n\t}\n//\tcout<<ans<<endl;\n\tfor(int i=0;i<n;i++)if(!usd[i])\n\t\tcards.push_back(make_pair(a[i],i));\n\n    sort(cards.begin(),cards.end());\n    reverse(cards.begin(),cards.end());\n    int p = 0;\n    for(int i = 0; i < cards.size(); ++i) if(cards[p].first < cards[i].first - 5000){\n    \trandom_shuffle(cards.begin() + p, cards.begin() + i);\n    \tp = i;\n\t}\n    for(int _=0;_<cards.size();_++)\n    {\n    \tint i=cards[_].second;\n\t//\tcout<<i<<\" \"<<x[i]<<\" \"<<y[i]<<\" \"<<qx[x[i]].top().second<<\" \"<<qy[y[i]].top().second<<endl;\n        qx[x[i]].erase(make_pair(a[i],i));\n        qy[y[i]].erase(make_pair(a[i],i));\n        if(ux[x[i]]&&uy[y[i]])continue;\n        if(ux[x[i]])\n        \tuy[y[i]]=1;\n        else if(uy[y[i]])\n        \tux[x[i]]=1;\n        else\n\t\t{\n\t\t\tax=qx[x[i]].empty()?-inf:(*(qx[x[i]].rbegin())).first;\n\t\t\tay=qy[y[i]].empty()?-inf:(*(qy[y[i]].rbegin())).first;\n\t\t\tif(ax<ay)\n\t\t\t{\n        //   \tcout<<\"puthang \"<<x[i]<<endl;\n            \tux[x[i]]=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n      \t//    \tcout<<\"putlie \"<<y[i]<<endl;\n \t    \t\tuy[y[i]]=1;\n \t    \t}\n        }\n        ans+=a[i];\n    }\n    ans=max(ans,res);\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#include <fstream>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n\n#define LLINF 1e18+7\n#define N 250000\nll MOD=1e9+7;\n\n\nint G[600][600];\n\nstruct UnionFind{\n    vector<int> par,sizes;\n    UnionFind(int n):par(n+1),sizes(n+1,1){\n        rep2(i,1,n)par[i]=i;\n    }\n    int find(int x){\n        return (x==par[x]?x:par[x]=find(par[x]));\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return ;\n        if(sizes[x]<sizes[y]){\n            swap(x,y);\n        }\n        par[y]=x;\n        sizes[x]+=sizes[y];\n    }\n    bool same(int x,int y) {return (find(x)==find(y));}\n    int size(int x) {return sizes[find(x)];}\n};\nmain(){\n    int n=in();\n    int h=in(),w=in();\n    UnionFind uf(h+w+10);\n    vector<pair<ll,pii>> v;\n    rep(i,n){\n        int r=in(),c=in(),a=in();\n        v.pb({a,{r,c+h}});\n        uf.unite(r,c+h);\n    }\n    vector<vector<pair<ll,pii>>> W(h+w+10);\n    vec t;\n    rep(i,n){\n        int s=uf.find(v[i].second.first);\n        W[s].pb(v[i]);\n        t.pb(s);\n        //cout<<s<<endl;\n    }\n    sort(all(t));\n    ll ans=0;\n    t.erase(unique(all(t)),t.end());\n    UnionFind uf2(h+w+10);\n    vec used(h+w+10);\n    for(auto e:t){\n        int m=uf.size(e);\n        sort(all(W[e]),greater<pair<ll,pii>>());\n        vec used(h+w+10);\n        rep(i,W[e].size()){\n            //cout<<W[e][i].first<<\" \"<<W[e][i].second.first<<W[e][i].second.second<<endl;\n            if(!uf2.same(W[e][i].second.first,W[e][i].second.second)){\n                if(used[uf2.find(W[e][i].second.first)]&&used[uf2.find(W[e][i].second.second)]){\n                    continue;\n                }\n                uf2.unite(W[e][i].second.first,W[e][i].second.second);\n                if(used[W[e][i].second.first]||used[W[e][i].second.second]){\n                    used[uf2.find(W[e][i].second.second)]=1;\n                }\n                ans+=W[e][i].first;\n            }\n            else{\n                if(!used[uf2.find(W[e][i].second.second)]){\n                    used[uf2.find(W[e][i].second.second)]=1;\n                    ans+=W[e][i].first;\n                }\n            }\n\n        }\n\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007\nint ri() {\n\tint n;\n\tscanf(\"%d\", &n);\n\treturn n;\n}\nint n, h, w;\nstd::vector<int> a, b, c;\nstd::random_device rnd_dev;\nstd::mt19937 rnd(rnd_dev());\n\nstd::vector<std::vector<std::pair<int, int> > > h_max;\nstd::vector<std::vector<std::pair<int, int> > > w_max;\n\nint64_t solve() {\n\tstd::vector<int> s(h + w);\n\tfor (int i = 0; i < h + w; i++) s[i] = i;\n\tstd::shuffle(s.begin(), s.end(), rnd);\n\tint64_t res = 0;\n\tbool used[n];\n\tmemset(used, 0, sizeof(used));\n\tint head1[h], head2[w];\n\tmemset(head1, 0, sizeof(head1));\n\tmemset(head2, 0, sizeof(head2));\n\tfor (int i = 0; i < h + w; i++) {\n\t\tif (i < h) {\n\t\t\twhile (head1[i] < h_max[i].size() && used[h_max[i][head1[i]].second]) head1[i]++;\n\t\t\tif (head1[i] < h_max[i].size())\n\t\t\t\tres += h_max[i][head1[i]].first, used[h_max[i][head1[i]++].second] = true;\n\t\t} else {\n\t\t\ti -= h;\n\t\t\twhile (head2[i] < w_max[i].size() && used[w_max[i][head2[i]].second]) head2[i]++;\n\t\t\tif (head2[i] < w_max[i].size())\n\t\t\t\tres += w_max[i][head2[i]].first, used[w_max[i][head2[i]++].second] = true;\n\t\t\ti += h;\n\t\t}\n\t}\n\treturn res;\n}\nint main () {\n\tclock_t r0 = clock();\n\tn = ri(), h = ri(), w = ri();\n\ta.resize(n);\n\tb.resize(n);\n\tc.resize(n);\n\tstd::set<int> xs, ys;\n\tfor (int i = 0; i < n; i++) {\n\t\ta[i] = ri() - 1;\n\t\txs.insert(a[i]);\n\t\tb[i] = ri() - 1;\n\t\tys.insert(b[i]);\n\t\tc[i] = ri();\n\t}\n\th = xs.size();\n\tw = ys.size();\n\t{\n\t\tint cnt = 0;\n\t\tstd::map<int, int> comp;\n\t\tfor (auto i : xs) comp[i] = cnt++;\n\t\tfor (int i = 0; i < n; i++) a[i] = comp[a[i]];\n\t}\n\t{\n\t\tint cnt = 0;\n\t\tstd::map<int, int> comp;\n\t\tfor (auto i : ys) comp[i] = cnt++;\n\t\tfor (int i = 0; i < n; i++) b[i] = comp[b[i]];\n\t}\n\th_max.resize(h);\n\tw_max.resize(w);\n\tfor (int i = 0; i < n; i++) {\n\t\th_max[a[i]].push_back({c[i], i}), w_max[b[i]].push_back({c[i], i});\n\t}\n\tfor (int i = 0; i < h; i++) {\n\t\tstd::sort(h_max[i].begin(), h_max[i].end(), std::greater<>());\n\t}\n\tfor (int i = 0; i < w; i++) {\n\t\tstd::sort(w_max[i].begin(), w_max[i].end(), std::greater<>());\n\t}\n\tint64_t res = 0;\n\twhile ((double) (clock() - r0) / CLOCKS_PER_SEC <= 1.9) {\n\t\tres = std::max(res, solve());\n\t}\n\tstd::cout << res << std::endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//2019.8.24 by ljz\n//email 573902690@qq.com\n//if you find any bug in my code\n//please tell me\n#include<bits/stdc++.h>\nusing namespace std;\n#define res register int\n#define LL long long\n#define inf 0x3f3f3f3f\n#define INF 0x3f3f3f3f3f3f3f\n#define unl __int128\n#define eps 5.6e-8\n#define RG register\n#define db double\n#define pc(x) __builtin_popcount(x)\ntypedef pair<int,int> Pair;\n#define mp make_pair\n#define fi first\n#define se second\n#define pi acos(-1.0)\n#define pb push_back\n#define ull unsigned LL\n#define gc getchar\n//inline char gc() {\n//    static char buf[100000],*p1,*p2;\n//    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n//}\ninline int read() {\n    res s=0,ch=gc();\n    while(ch<'0'||ch>'9')ch=gc();\n    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n    return s;\n}\n//inline int read() {\n//    res s=0,ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc();\n//    while(ch<'0'||ch>'9')ch=gc();\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s;\n//}\n//inline LL Read() {\n//    RG LL s=0;\n//    res ch=gc(),w=1;\n//    while(ch<'0'||ch>'9'){if(ch=='-')w=-1;ch=gc();}\n//    while(ch>='0'&&ch<='9')s=s*10+ch-'0',ch=gc();\n//    return s*w;\n//}\n//inline void write(RG unl x){\n//    if(x>10)write(x/10);\n//    putchar(int(x%10)+'0');\n//}\ninline void swap(res &x,res &y) {\n    x^=y^=x^=y;\n}\n//mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n//clock_t start=clock();\n//inline void ck(){\n//    if(1.0*(clock()-start)/CLOCKS_PER_SEC>0.1)exit(0);\n//}\nconst int N=1e6+10;\nconst int kcz=1e9+7;\nnamespace MAIN{\n    int n,H,W;\n    inline void add(res &x,const res &y){\n        x+=y,x>=kcz?x-=kcz:1;\n    }\n    inline int mul(const res &x,const res &y){\n        return int(1LL*x*y%kcz);\n    }\n    inline int Add(const res &x,const res &y){\n        return x+y>=kcz?x+y-kcz:x+y;\n    }\n    int a[N],R[N],C[N];\n    struct E{\n        int next,to;\n        E() {}\n        E(res next,res to):next(next),to(to) {}\n    }edge[N];\n    int head[N],cnt;\n    inline void addedge(const res &u,const res &v){\n        edge[++cnt]=E(head[u],v),head[u]=cnt;\n    }\n    int vis[N],link[N],tim;\n    bool match(res x){\n        for(res i=head[x];~i;i=edge[i].next){\n            res tox=edge[i].to;\n            if(vis[tox]==tim)continue;\n            vis[tox]=tim;\n            if(!link[tox]||match(link[tox])){link[tox]=x;return 1;}\n        }\n        return 0;\n    }\n    LL ans;\n    int id[N];\n    inline bool cmp(const res &x,const res &y){\n        return a[x]>a[y];\n    }\n    inline void MAIN(){\n        n=read(),H=read(),W=read();\n        memset(head,-1,sizeof(head));\n        for(res i=1;i<=n;i++)R[i]=read(),C[i]=read(),a[i]=read(),addedge(i,R[i]+n),addedge(i,C[i]+H+n),id[i]=i;\n        sort(id+1,id+n+1,cmp);\n        for(res i=1;i<=n;i++){\n            tim++;\n            if(match(id[i]))ans+=a[id[i]];\n        }\n        printf(\"%lld\\n\",ans);\n    }\n}\nint main(){\n//    srand(19260817);\n//    freopen(\"signin.in\",\"r\",stdin);\n//    freopen(\"signin.out\",\"w\",stdout);\n    MAIN::MAIN();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = ll(A); I < ll(B); ++I)\n#define FORR(I,A,B) for(ll I = ll((B)-1); I >= ll(A); --I)\n#define TO(x,t,f) ((x)?(t):(f))\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //xi>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //xi>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\nll gcd(ll a,ll b){if(a%b==0)return b;return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nconst ll INF=ll(1e18)+ll(7);\nconst ll MOD=1000000007LL;\n#define out(a) cout<<fixed<<setprecision((a))\n\nclass UnionFind{\npublic:\n\tvector<int> par,rank;\n\t//0-indexed\n\tUnionFind(int n){init(n);}\n\tvoid init(int n = 1) {\n\t\tpar.resize(n);\n\t\trank.resize(n,0);\n\t\tfor (int i = 0; i < n; ++i) par[i] = i;\n\t}\n\tint root(int x = 1){\n\t\tif(par[x]==x)return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n\tvoid unite(int x = 1,int y = 1){\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif(x==y)return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x]==rank[y]){\n\t\t\t\trank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\tbool same(int x,int y){\n\t\treturn root(x)==root(y);\n\t}\n};\n\n\n// なもりグラフ\n// https://www.hamayanhamayan.com/entry/2019/08/25/090415\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint N,H,W;\n\tll ans = 0;\n\tcin >> N >> H >> W;\n\tUnionFind uf(H+W+6);\n\tpriority_queue< pair<ll,P> > pq;\n\tFOR(i,0,N){\n\t\tint r,c,a;\n\t\tcin >> r >> c >> a;\n\t\tpq.push({a,{r,c}});\n\t}\n\tFOR(i,0,N){\n\t\tauto X = pq.top();\n\t\tint h = X.second.first;\n\t\tint w = X.second.second;\n\t\tint a = X.first;\n\t\tpq.pop();\n\t\tif(not uf.same(h,w+H)){\n\t\t\tans += a;\n\t\t\tuf.unite(h,w+H);\n\t\t}else if(not uf.same(h,H+W+2)){\n\t\t\tans += a;\n\t\t\tuf.unite(h,H+W+2);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fo(i,a,b) for((i)=(a);i<=(b);i++)\n#define rfo(i,a,b) for((i)=(a);i>=(b);i--)\n#define inrange(x,y,z) (((x)>=(y))&&((x)<=(z)))\n#define ALL(vec) ((vec).begin(),(vec).end())\n#define SOR(vec) sort(ALL(vec))\n#define UNI(vec) (vec).erase(unique(ALL(vec)),(vec).end())\nusing namespace std;\nint n,h,w,r,c;\nlong long a,res;\npair<long long,pair<int,int> > es[100100];\nint fa[200100],full[200100];\nint gf(int x){return ((x==fa[x])?(x):(fa[x]=gf(fa[x])));}\nbool join(int x,int y){\n\tx=gf(x),y=gf(y);\n\tif(x==y){\n\t\tif(full[x]) return false;\n\t\tfull[x]=1;\n\t\treturn true;\n\t} \n\tif(full[x]&&full[y]) return false;\n\tfull[x]=full[y]=(full[x]|full[y]);\n\tfa[x]=y;\n\treturn true;\n}\nint main(){\n\t#ifdef FILIN\n\t\t#ifndef DavidDesktop\n\t\t\tfreopen(FILIN,\"r\",stdin);\n\t\t\tfreopen(FILOUT,\"w\",stdout);\n\t\t#endif\n\t#endif\n\tios::sync_with_stdio(0);\n\tcin.tie(NULL);\n\tcout.tie(NULL);\n\tcin>>n>>h>>w;\n\tfor(int i=1;i<=h+w;i++) fa[i]=i;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>r>>c>>a;\n\t\tc+=h; \n\t\tes[i]=make_pair(a,make_pair(r,c));\n\t}\n\tsort(es+1,es+n+1);\n\treverse(es+1,es+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tif(join(es[i].second.first,es[i].second.second)){\n\t\t\tres+=es[i].first;\n\t\t}\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef OUUAN\n#pragma GCC optimize(\"Ofast,no-stack-protector,unroll-loops,fast-math\")\n#endif\n#include<bits/stdc++.h>\n\n#define int LoveLive\n//#define FAST_IOSTREAM 1\n\n#define For(i,l,r)for(int i=(l),i##end=(r);i<=i##end;++i)\n#define FOR(i,r,l)for(int i=(r),i##end=(l);i>=i##end;--i)\n#define SON(i,u)for(int i=head[u];i;i=nxt[i])\n#define ms(a,x)memset(a,x,sizeof(a))\n#define fi first\n#define se second\n#define pb emplace_back\n#define pq priority_queue\n#define isinf(x)(x>=INF?-1:x)\n#define y1 why_is_there_a_function_called_y1\n#define DEBUG(x)cerr<<(#x)<<\":\"<<x<<endl\nusing namespace std;\ntypedef long long LoveLive;typedef pair<int,int>pii;typedef vector<int>vi;\n#ifdef int\nconst int INF=0x3f3f3f3f3f3f3f3fll;\n#else\nconst int INF=0x3f3f3f3f;\n#endif\nconst double eps=1e-9;mt19937 rng(chrono::steady_clock::now().time_since_epoch().\ncount());int randint(int l,int r){int out=rng()%(r-l+1)+l;return out>=l?out:out+\nr-l+1;}\n#ifdef FAST_IOSTREAM\n#define br cout<<'\\n'\n#define sp cout<<' '\nlong long read(){long long x;cin>>x;return x;}template<typename T>void read(T&x){\ncin>>x;}template<typename T>void write(const T&x){cout<<x;}\n#else\n#define br putchar('\\n')\n#define sp putchar(' ')\ntemplate<typename T>typename enable_if<!is_integral<T>::value,void>::type read(T\n&x){cin>>x;}long long read(){char c;long long out=0,f=1;for(c=getchar();!isdigit\n(c)&&c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())\nout=(out<<3)+(out<<1)+c-'0';return out*f;}template<typename T>typename enable_if\n<is_integral<T>::value,T>::type read(T&x){char c;T f=1;x=0;for(c=getchar();!isdigit\n(c)&&c!='-';c=getchar());if(c=='-'){f=-1;c=getchar();}for(;isdigit(c);c=getchar())\nx=(x<<3)+(x<<1)+c-'0';return x*=f;}char read(char&x){for(x=getchar();isspace(x);\nx=getchar());return x;}double read(double&x){scanf(\"%lf\",&x);return x;}template<\ntypename T>typename enable_if<!is_integral<T>::value,void>::type write(const T&x\n){cout<<x;}template<typename T>typename enable_if<is_integral<T>::value,void>::type\nwrite(const T&x){if(x<0){putchar('-');write(-x);return;}if(x>9)write(x/10);putchar\n(x%10+'0');}void write(const char&x){putchar(x);}void write(const double&x){printf\n(\"%.10lf\",x);}\n#endif\ntemplate<typename T,typename...Args>void read(T&x,Args&...args){read(x);read(args\n...);}template<typename OutputIt,typename=typename enable_if<is_same<output_iterator_tag\n,typename iterator_traits<OutputIt>::iterator_category>::value||(\nis_base_of<forward_iterator_tag,typename iterator_traits<OutputIt>::iterator_category>::value\n&&!is_const<OutputIt>::value)>::type>void read(OutputIt __first,OutputIt __last){for(;__first\n!=__last;++__first)read(*__first);}template<typename InputIt,typename=typename enable_if\n<is_base_of<input_iterator_tag,typename iterator_traits<InputIt>::iterator_category\n>::value>::type>void wts(InputIt __first,InputIt __last){bool isFirst=true;for(;\n__first!=__last;++__first){if(isFirst)isFirst=false;else sp;write(*__first);}br;}\ntemplate<typename InputIt,typename=typename enable_if<is_base_of<input_iterator_tag\n,typename iterator_traits<InputIt>::iterator_category>::value>::type>void wtb(InputIt\n__first,InputIt __last){for(;__first!=__last;++__first){write(*__first);br;}}template\n<typename T>void wts(const T&x){write(x);sp;}template<typename T>void wtb(const\nT&x){write(x);br;}template<typename T>void wte(const T&x){write(x);exit(0);}template\n<typename T,typename...Args>void wts(const T&x,Args...args){wts(x);wts(args...);}\ntemplate<typename T,typename...Args>void wtb(const T&x,Args...args){wts(x);wtb(args\n...);}template<typename T,typename...Args>void wte(const T&x,Args...args){wts(x);\nwte(args...);}template<typename T>inline bool up(T&x,const T&y){return x<y?x=y,1\n:0;}template<typename T>inline bool dn(T&x,const T&y){return y<x?x=y,1:0;}\n\nconst int N = 100010;\nconst int mod = 1000000007;\n\nint n, h, w, ans, vis[2][N];\n\nstruct Node\n{\n\tint w, p[2];\n\tbool operator<(const Node& b) const\n\t{\n\t\treturn w > b.w;\n\t}\n} a[N];\n\nbool insert(int x, int y)\n{\n\tif (vis[y][a[x].p[y]])\n\t{\n\t\tif (vis[y ^ 1][a[vis[y][a[x].p[y]]].p[y ^ 1]]) return false;\n\t\tvis[y ^ 1][a[vis[y][a[x].p[y]]].p[y ^ 1]] = vis[y][a[x].p[y]];\n\t}\n\tvis[y][a[x].p[y]] = x;\n\treturn true;\n}\n\nsigned main()\n{\n#ifdef FAST_IOSTREAM\n\tcin.sync_with_stdio(false);\n\tcin.tie(0);\n#endif\n\t\n\tread(n, h, w);\n\t\n\tFor (i, 1, n) read(a[i].p[0], a[i].p[1], a[i].w);\n\t\n\tsort(a + 1, a + n + 1);\n\t\n\tFor (i, 1, n)\n\t{\n\t\tif (insert(i, 0) || insert(i, 1)) ans += a[i].w;\n\t}\n\t\n\twtb(ans);\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int N=1e5+5;\nint n,h,w;\nstruct Point\n{\n\tint r,c;\n\tll a;\n}a[N];\nbool cmp(Point a,Point b)\n{\n\treturn a.a>b.a;\n}\nint fa[N*2],sum[N*2];\nint find(int x)\n{\n\tif(fa[x]!=x)\n\tfa[x]=find(fa[x]);\n\treturn fa[x];\n}\nll ans=0;\nint main()\n{\n\tcin>>n>>h>>w;\n\tfor(int i=1;i<=h+w;++i)\n\t{\n\t\tfa[i]=i;\n\t\tsum[i]=1;\n\t}\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tscanf(\"%d%d%lld\",&a[i].r,&a[i].c,&a[i].a);\n\t\ta[i].c+=h;\n\t}\n\tsort(a+1,a+1+n,cmp);\n\tfor(int i=1;i<=n;++i)\n\t{\n\t\tint fr=find(a[i].r),fc=find(a[i].c);\n\t\tif(fr!=fc)\n\t\t{\n\t\t\tfa[fr]=fc;\n\t\t\tsum[fc]+=sum[fr];\n\t\t\tsum[fr]=0;\n\t\t}\n\t\tif(sum[fc]>0)\n\t\t{\n\t\t\tans+=a[i].a;\n\t\t\tsum[fc]--;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nstruct card{\n\tint r,c;\n\tll a;\n\tbool operator<(const card &rhs){\n\t\treturn (a<rhs.a);\n\t}\n};\n\ncard v[100100];\nint ufp[100100],ufv[100100],ufe[100100];\n\nvoid ufinit(int n){\n\tint i;\n\tfor(i=0; i<n; ++i){\n\t\tufp[i] = i;\n\t\tufv[i] = 1;\n\t}\n}\n\nint ufind(int x){\n\tif(ufp[x] == x){\n\t\treturn x;\n\t}\n\treturn ufp[x] = ufind(ufp[x]);\n}\n\nbool unionf(int x, int y){\n\tx = ufind(x);\n\ty = ufind(y);\n\tif(x==y){\n\t\tif(ufe[x]<ufv[x]){\n\t\t\t++ufe[x];\n\t\t\treturn true;\n\t\t}else{\n\t\t\treturn false;\n\t\t}\n\t}\n\tif(ufv[x]<ufv[y]){\n\t\tswap(x,y);\n\t}\n\tif(ufe[x]+ufe[y]<ufv[x]+ufv[y]){\n\t\tufv[x] += ufv[y];\n\t\tufe[x] += ufe[y]+1;\n\t\tufp[y] = x;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nint main(void){\n\tint n,h,w,i;\n\tll ans = 0ll;\n\tcin >> n >> h >> w;\n\tufinit(h+w);\n\tfor(i=0; i<n; ++i){\n\t\tcin >> v[i].r >> v[i].c >> v[i].a;\n\t\t--v[i].r; --v[i].c; v[i].c += h;\n\t}\n\tsort(v,v+n); reverse(v,v+n);\n\tfor(i=0; i<n; ++i){\n\t\tif(unionf(v[i].r,v[i].c)){\n\t\t\tans += v[i].a;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <complex>\n#include <vector>\n#include <list>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <map>\n#include <set>\n#include <functional>\n#include <random>\n\nusing namespace std;\n \n#define mod 1000000007\n#define FOR(x,to) for(int x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define long long long\ninline int rei(){int x;cin>>x;return x;}\ninline long rel(){long x;cin>>x;return x;}\ninline string res(){string x;cin>>x;return x;}\n//------------------------------------------------------- \nstruct UnionFind{\n    vector<int> par;\n    UnionFind(int N){\n        par.resize(N);\n        for(int i=0;i<N;i++){\n            par[i] = i;\n        }\n    }\n    void Union(int x,int y){\n        par[Get(x)] = Get(y); \n    }\n    bool Same(int x,int y){\n        return Get(x) == Get(y);\n    }\n    int Get(int x){\n        if(x != par[x]){\n            par[x] = Get(par[x]);\n        }\n        return par[x];\n    }\n};\nvector<int> ver[300000];\nint num[300000];\nint C[300000];\nvoid Calc(){\n\tint N = rei();\n\tint H = rei();\n\tint W = rei();\n\tUnionFind UF(N+H+W);\n\tfor(int i=0;i<N;i++){\n\t\tint h = rei()-1;\n\t\tint w = rei()-1;\n\t\tint c = rei();\n\t\tUF.Union(h+N,i);\n\t\tUF.Union(w+H+N,i);\n\t\tC[i] = c;\n\t}\n\tfor(int i=0;i<H+W;i++){\n\t\tnum[UF.Get(i+N)]++;\n\t}\n\tfor(int i=0;i<N;i++){\n\t\tver[UF.Get(i)].push_back(C[i]);\n\t}\n\tlong ans = 0;\n\tfor(int i=0;i<N+H+W;i++){\n\t\tsort(ver[i].begin(),ver[i].end());\n\t\tfor(int j=0;j<num[i];j++){\n\t\t\tans += ver[i][ver[i].size()-1-j];\n\t\t}\n\t}\n\tcout << ans << endl;\n}\nint main(int argc,char** argv){\n\tios::sync_with_stdio(false), cin.tie(0);\n\tcout.tie(0); Calc(); return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1 };\nvel dy = { 1,-1,0,0 };\nvoid sol(int i,int ba, vvel& nex,vvel& adj,veb& use, vel& cnt) {\n\tif (cnt[i] == 0) {\n\t\tadj[i].push_back(ba);\n\t\treturn;\n\t}\n\tif (!use[i]) {\n\t\tuse[i] = true;\n\t\tfor (auto ne : nex[i]) {\n\t\t\tsol(ne,ba, nex,adj, use, cnt);\n\t\t}\n\t}\n}\nsigned main() {\n\tomajinai;\n\tint n, h, w; cin >> n >> h >> w;\n\tvvel cxy(n);\n\tvvel y_i(w);\n\tvvel x_i(h);\n\trep(i, n) {\n\t\tint c, x, y; cin >> x >> y >> c; x--; y--;\n\t\tcxy[i] = { c,x,y };\n\t}\n\tsor(cxy);\n\trep(i, n) {\n\t\tint x = cxy[i][1];\n\t\tint y = cxy[i][2];\n\t\ty_i[y].push_back(i);\n\t\tx_i[x].push_back(i);\n\t}\n\tvel cnt(n, 0);\n\tvvel nex(n);\n\trep(i, w) { \n\t\tsor(y_i[i]);\n\t\tint sz = y_i[i].size();\n\t\tif (sz != 0) {\n\t\t\tcnt[y_i[i].back()]++;\n\t\t\trep(j, sz - 1) {\n\t\t\t\tnex[y_i[i][j + 1]].push_back(y_i[i][j]);\n\t\t\t}\n\t\t}\n\n\t}\n\trep(i, h) { \n\t\tsor(x_i[i]);\n\t\tint sz = x_i[i].size();\n\t\tif (sz != 0) {\n\t\t\tcnt[x_i[i].back()]++;\n\t\t\trep(j, sz - 1) {\n\t\t\t\tnex[x_i[i][j + 1]].push_back(x_i[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tvvel adj(n);\n\tveb use(n,false);\n\tint ans = 0;\n\trep(i, n) {\n\t\tif (cnt[i] == 2) {\n\t\t\tsol(i,i, nex,adj,use, cnt);\n\t\t}\n\t\tif (cnt[i] >= 1) { ans += cxy[i][0]; }\n\t}\n\tvel pa(n, -1);\n\tvvel ed;\n\trep(i, n) {\n\t\tvel v = adj[i];\n\t\tsor(v);\n\t\tif (v.size() >= 1) {\n\t\t\ted.push_back({ cxy[i][0],v[0],v.back() });\n\t\t}\n\t}\n\tsor(ed); rev(ed);\n\tvel ex(n, 0);\n\tfor (auto v : ed) {\n\t\tint c = v[0];\n\t\tint x = root(v[1], pa);\n\t\tint y = root(v[2], pa);\n\t\tif (x == y) {\n\t\t\tif (ex[x] == 0) {\n\t\t\t\tex[x] = 1;\n\t\t\t\tans += c;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (ex[x] + ex[y]<=1) {\n\t\t\t\tpa[x] = y;\n\t\t\t\tex[y] += ex[x]; ex[x] = 0;\n\t\t\t\tans += c;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nlong long n;\n\nstruct edge{\n    int a, b, c;\n};\n\nvector<edge> edges;\n\nbool comp(edge a, edge b)\n{\n    return a.c > b.c;\n}\n\nint h[500000];\nint root[500000];\nint ce[500000];\nint cv[500000];\n\nint Root(int x)\n{\n    if (x == root[x])\n        return x;\n    return root[x] = Root(root[x]);\n}\n\nvoid Merge(int a, int b)\n{\n    a = Root(a);\n    b = Root(b);\n    if (a == b) return;\n    if (h[a] == h[b])\n        h[a]++;\n    if (h[a] > h[b])\n    {\n        root[b] = a;\n        ce[a] += ce[b] + 1;\n        cv[a] += cv[b];\n    }\n    else\n    {\n        root[a] = b;\n        ce[b] += ce[a] + 1;\n        cv[b] += cv[a];\n    }\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    int x;\n    cin >> n >> x >> x;\n    for (int i = 0; i < 500000; i++)\n    {\n        root[i] = i;\n        cv[i] = 1;\n    }\n    for (int i = 0; i < n; i++)\n    {\n        int a, b, c;\n        cin >> a >> b >> c;\n        edges.push_back({a, b + 100500, c});\n    }\n    sort(edges.begin(), edges.end(), comp);\n    long long ans = 0;\n    for (int i = 0; i < edges.size(); i++)\n    {\n        int a = edges[i].a;\n        int b = edges[i].b;\n        int c = edges[i].c;\n        a = Root(a);\n        b = Root(b);\n        if (a == b)\n        {\n            if (ce[a] + 1 <= cv[a])\n            {\n                ans += c;\n                ce[a]++;\n            }\n        }\n        else\n        {\n            int total_edges = ce[a] + ce[b] + 1;\n            int total_vertex = cv[a] + cv[b];\n            if (total_edges <= total_vertex)\n            {\n                ans += c;\n                Merge(a, b);\n            }\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nnamespace io{\n\tconst int l=1<<20;\n\tchar buf[l],*s,*t;\n\tinline char gc(){\n\t\tif(s==t){\n\t\t\tt=(s=buf)+fread(buf,1,l,stdin);\n\t\t\treturn s==t?EOF:*s++;\n\t\t}\n\t\treturn *s++;\n\t}\n\tchar c;\n\ttemplate<class IT>inline void gi(IT &x){\n\t\tx=0;c=gc();while(c<'0'||c>'9')c=gc();\n\t\twhile('0'<=c&&c<='9'){x=(x<<1)+(x<<3)+(c^'0');c=gc();}\n\t}\n};\nusing io::gi;\nstruct qwq{\n\tint a,b;\n\tinline bool operator<(const qwq &x)const{\n\t\treturn a<x.a;\n\t}\n};\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\nconst ll p=998244353ll,inf=1000000000000000000ll;\nconst int N=300005,E=1000005;\nstruct edge{\n\tint v,u,w,n;\n\tinline edge(){}\n\tinline edge(int v,int u,int w,int n):v(v),u(u),w(w),n(n){}\n}e[E];\nint fi[N],te;\ninline void addedge(int v,int u,int w1,int w2){\n\te[te]=edge(u,w1, w2,fi[v]);fi[v]=te++;\n\te[te]=edge(v, 0,-w2,fi[u]);fi[u]=te++;\n}\nint pv[N],pe[N],q[N],in[N];ll d[N];int S,T;\ninline ll spfa(){\n\tint v,i,u;ll w;int qh=1,qt=1;\n\tfor(i=1;i<=T;++i){d[i]=-1;in[i]=0;}\n\td[q[1]=S]=0;\n\twhile(qh<=qt){\n\t\tv=q[(qh++)%N];in[v]=0;\n\t\tfor(i=fi[v];~i;i=e[i].n)if(e[i].u){\n\t\t\tu=e[i].v;\n\t\t\tw=e[i].w+d[v];\n\t\t\tif(w>d[u]){\n\t\t\t\td [u]=w;\n\t\t\t\tpv[u]=v;\n\t\t\t\tpe[u]=i;\n\t\t\t\tif(!in[u]){in[u]=1;q[(++qt)%N]=u;}\n\t\t\t}\n\t\t}\n\t}\n//\tfor(i=1;i<=T;++i)printf(\"%d \",d[i]);printf(\"\\n\");\n\treturn d[T];\n}\nint main(){\n\tint t,n,m,a,b,c,i,lo;ll sp,s=0;\n\tmemset(fi,-1,sizeof(fi));\n\tscanf(\"%d%d%d\",&t,&n,&m);\n\tT=(S=t+n+m+1)+1;\n\tfor(i=1;i<=n+m;++i)addedge(S,i,1,0);\n\tfor(i=1;i<=t  ;++i){\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\taddedge(    a,n+m+i,1,0);\n\t\taddedge(n+  b,n+m+i,1,0);\n\t\taddedge(n+m+i,T    ,1,c);\n\t}\n\twhile(~(sp=spfa())){\n\t\tlo=E;\n\t\tfor(i=T;i!=S;i=pv[i])cmin(lo,e[pe[i]].u);\n\t\tfor(i=T;i!=S;i=pv[i]){\n\t\t\te[pe[i]  ].u-=lo;\n\t\t\te[pe[i]^1].u+=lo;\n\t\t}\n\t\ts+=lo*sp;\n\t}\n\tprintf(\"%lld\",s);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1e9 + 7;\nconst ll INF = 1LL << 60;\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> E;\n\nstruct UnionFind {\n\tvector<int> par;\n\tvector<int> size;\n\n\tUnionFind(int n) {\n\t\tpar = vector<int>(n);\n\t\tfor (int i = 0; i < n; i++) par[i] = i;\n\t\tsize = vector<int>(n, 1);\n\t}\n\n\tint find(int x) {\n\t\tif (x == par[x]) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tif (size[x] < size[y]) {\n\t\t\tpar[x] = y;\n\t\t\tsize[y] += size[x];\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tsize[x] += size[y];\n\t\t}\n\t}\n};\n\nint main() {\n\tint N, H, W;\n\tcin >> N >> H >> W;\n\tvector<E> edge;\n\tfor (int i = 0; i < N; i++) {\n\t\tint R, C;\n\t\tint A;\n\t\tcin >> R >> C >> A;\n\t\tR--; C--;\n\t\tedge.emplace_back(A, P(R, C + H));\n\t}\n\tsort(edge.begin(), edge.end(), greater<E>());\n\tUnionFind U(H + W + 1);\n\tll ans = 0;\n\tfor (E e : edge) {\n\t\tint x = e.second.first, y = e.second.second;\n\t\tif (!U.same(x, y)) {\n\t\t\tU.unite(x, y);\n\t\t\tans += e.first;\n\t\t}\n\t\telse if (!U.same(x, H + W) && !U.same(y, H + W)) {\n\t\t\tU.unite(x, y);\n\t\t\tU.unite(x, H + W);\n\t\t\tans += e.first;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\nclass Union_Find_Tree{\n\tpublic:\n\tvi p,r,s,a;\n\tUnion_Find_Tree(int n){\n\t\tp=r=a=vi(n);\n\t\ts=vi(n,1);\n\t\tfor(int i=0;i<n;i++) p[i]=i;\n\t}\n\tint Par(int x){\n\t\tif(p[x]==x) return x;\n\t\treturn p[x]=Par(p[x]);\n\t}\n\tint Size(int x){return s[Par(x)];}\n\tbool Unite(int x,int y){\n\t\tx=Par(x);\n\t\ty=Par(y);\n\t\tif(x==y) return 0;\n\t\tif(r[x]<r[y]){\n\t\t\tp[x]=y;\n\t\t\ts[y]+=s[x];\n\t\t}\n\t\telse{\n\t\t\tp[y]=x;\n\t\t\ts[x]+=s[y];\n\t\t\tif(r[x]==r[y]) r[x]++;\n\t\t}\n\t\treturn 1;\n\t}\n\tbool Same(int x,int y){return Par(x)==Par(y);}\n};\n\nint m,h,w;\nvip e;\n\nint main(){\n\tcin>>m>>h>>w;\n\tint n=h+w;\n\tfor(int i=0;i<m;i++){\n\t\tint x,y,w;\n\t\tcin>>x>>y>>w;\n\t\te.push_back({w,{x-1,y+h-1}});\n\t}\n\tsort(e.rbegin(),e.rend());\n\tUnion_Find_Tree uft(n);\n\tll res=0;\n\tfor(auto p:e){\n\t\tint u=p.second.first,v=p.second.second;\n\t\tu=uft.Par(u),v=uft.Par(v);\n\t\tif(u==v&&!uft.a[u]||u!=v&&uft.a[u]+uft.a[v]<2){\n\t\t\tres+=p.first;\n\t\t\tuft.Unite(u,v);\n\t\t\tif(u==v||uft.a[u]||uft.a[v]){\n\t\t\t\tu=uft.Par(u);\n\t\t\t\tuft.a[u]=1;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<res<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<=(b);++i)\nconst int N = 2e5+5;\n \nstruct edge{\n\tint x,y,d;\n}a[N];\nint n,h,w,c[N],fa[N];\nlong long ans;\n\nint find(int x){return x==fa[x]?x:fa[x]=find(fa[x]);}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&h,&w);\n\trep(i,1,n)scanf(\"%d%d%d\",&a[i].x,&a[i].y,&a[i].d),a[i].y+=h;\n\tsort(a+1,a+n+1,[](edge x,edge y){return x.d>y.d;});\n\t\n\trep(i,1,h+w)fa[i]=i,c[i]=1;\n\trep(i,1,n){\n\t\tint x = find(a[i].x), y = find(a[i].y);\n\t\tif(x!=y) fa[x] = y, c[y] += c[x];\n\t\tif(c[y]) c[y]--, ans+=1ll*a[i].d;\n\t} \n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// Optimization\n\n//#pragma GCC optimize(\"O3\")\n#define endl '\\n'\n\n// Shortcut\n\n#define int long long\n#define eb emplace_back\n#define pb push_back\n#define pob pop_back\n#define mp make_pair\n#define upb upper_bound\n#define lwb lower_bound\n#define fi first\n#define se second\n#define For(i, l, r) for (int i = l; i < r; i++)\n#define ForE(i, l, r) for (int i = l; i <= r; i++)\n#define Ford(i, r, l) for (int i = r; i > l; i--)\n#define FordE(i, r, l) for (int i = r; i >= l; i--)\n#define Fora(i, a) for (auto i : a)\n\n// I/O & Debug\n\n#define PrintV(a) Fora(iiii, a) cout << iiii << ' '; cout << endl;\n#define PrintVl(a) Fora(iiii, a) cout << iiii << endl;\n#define PrintA(a, l, r) for (int iiii = l; iiii <= r; iiii++) cout << a[iiii] << ' '; cout << endl;\n#define PrintAl(a, l, r) for (int iiii = l; iiii <= r; iiii++) cout << a[iiii] << endl;\n#define Ptest(x) return cout << x, 0;\n#define gl(s) getline(cin, s);\n#define setpre(x) fixed << setprecision(x)\n/*\n#define debug(args...){ string _sDEB = #args; replace(_sDEB.begin(), _sDEB.end(), ',', ' '); stringstream _ssDEB(_sDEB); istream_iterator<string> _itDEB(_ssDEB); DEB(_itDEB, args); }\nvoid DEB(istream_iterator<string> it) {}\ntemplate<typename T, typename... Args>\nvoid DEB(istream_iterator<string> it, T a, Args... args){\n    cout << *it << \" = \" << a << endl;\n    DEB(++it, args...);\n}\n*/\n\n// Functions\n\n//#define isvowel(a) (a == 'a' || a == 'e' || a == 'i' || a == 'o' || a == 'u')\n#define bend(a) a.begin(), a.end()\n#define rbend(a) a.rbegin(), a.rend()\n#define mset(a) memset(a, 0, sizeof(a))\n#define mset1(a) memset(a, 1, sizeof(a))\n#define msetn1(a) memset(a, -1, sizeof(a))\n#define msetinf(a) memset(a, 0x3f, sizeof(a))\n#define gcd __gcd\n#define __builtin_popcount __builtin_popcountll\n//mt19937 rando(chrono::steady_clock::now().time_since_epoch().count());\n\n// Data Structure\n\n#define pque priority_queue\n#define mts multiset\n#define y0 _y0_\n#define y1 _y1_\n#define div divi\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector <int> vi;\ntypedef vector <ll> vll;\ntypedef vector <ld> vld;\ntypedef vector <string> vs;\ntypedef pair <int, int> pii;\ntypedef pair <ll, ll> pll;\ntypedef vector <vi > vvi;\ntypedef vector <vll > vvll;\ntypedef vector <pii > vpii;\ntypedef vector <pll > vpll;\n\nconst int N = 2e5 + 5, mod = 1e9 + 7, mod1 = 998244353, mod2 = 1e9 + 9, inf = 1e18 + 7;\nconst ll infll = 1e18 + 7;\n\nint n, h, w, ans;\nvector <pair <int, pii>> edges;\nbool ck[N];\n\nstruct disjoint_set_union{\n    int par[N];\n    \n    void init(){\n        msetn1(par);\n    }\n\n    int root(int x){\n        return par[x] < 0 ? x : par[x] = root(par[x]);\n    }\n\n    bool merge(int x, int y){\n        if ((x = root(x)) == (y = root(y))){\n            if (ck[x]) return 0;\n            ck[x] = 1;\n            return 1;\n        }\n        if (ck[x] && ck[y]) return 0;\n        par[x] += par[y];\n        par[y] = x;\n        ck[x] |= ck[y];\n        return 1;\n    }\n} dsu;\n\nsigned main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0); cout.tie(0);\n    cin >> n >> h >> w;\n    For(i, 0, n){\n        int x, y, z; cin >> x >> y >> z; y += h;\n        edges.pb({z, {x, y}});\n    }\n    sort(rbend(edges));\n    dsu.init();\n    Fora(edge, edges){\n        if (dsu.merge(edge.se.fi, edge.se.se)){\n            ans += edge.fi;\n        }\n    }\n    cout << ans;\n}\n\n/*\n==================================+\nINPUT:                            |\n------------------------------    |\n\n------------------------------    |\n==================================+\nOUTPUT:                           |\n------------------------------    |\n\n------------------------------    |\n==================================+\n*/"
  },
  {
    "language": "C++",
    "code": "#include <algorithm> //STLͨ���㷨\n#include <cmath> //������ѧ����\n#include <cstdio> //��������/�������\n#include <iostream> //����������/���\n#include <cstring> //�ַ�������\n#include <string> //�ַ�����\n#include <ctime> //�������ʱ��ĺ���\n#define itn int\n#define fro for\n#define ll long long\n#define reg register\n#define inf 1234567890\n#define rep(i,a,b,c) for (int i=a;i<=b;i+=c)\n/*#include <bitset> //STLλ������\n#include <cstype> //�ַ�����\n#include <cerrno> //���������\n#include <complex> //������\n#include <clocale> //���屾�ػ�����\n#include <cstdlib> //������������ڴ���亯��\n#include <deque> //STL˫�˶�������\n#include <exception> //�쳣������\n#include <fstream> //�ļ�����/���\n#include <functional> //STL�������㺯��(���������)\n#include <limits> //�����������������ֵ����\n#include <list> //STL�����б�����\n#include <map> //STLӳ������\n#include <iomanip> //����������/���\n#include <ios> //��������/���֧��\n#include <iosfwd> //����/���ϵͳʹ�õ�ǰ������\n#include <istream> //����������\n#include <ostream> //���������\n#include <queue> //STL��������\n#include <set> //STL��������\n#include <sstream> //�����ַ�������\n#include <stack> //STL��ջ����\n#include <stdexcept> //��׼�쳣��\n#include <streambuf> //�ײ�����/���֧��\n#include <utility> //STLͨ��ģ����\n#include <vector> //STL��̬��������\n#include <cwchar.h>//���ַ�����������/���\n#include <cwctype.h> //���ַ�����*/\n\nusing namespace std;\n\nint ans;\n\nint max(int x,int y){return x>y?x:y;}\n\nint min(int x,int y){return x<y?x:y;}\n\nint abs(int x){return x>0?x:-x;}\n\nint gcd(int x,int y){return (!y)?x:gcd(y,x%y);}\n\nvoid exgcd(int a,int b,int &d,int &x,int &y){if (!b){d=a,x=1,y=0;}else{exgcd(b,a%b,d,y,x);y-=x*(a/b);}}\n\nint quick_power(ll a,int b){ll r=1;for (;b;b>>=1,a=a*a)if (b&1) r=r*a;return r;}\n\ninline char read() {\n\tstatic const int IN_LEN = 1000000;\n\tstatic char buf[IN_LEN], *s, *t;\n\treturn (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);\n}\ntemplate<class T>\ninline void read(T &x) {\n\tstatic bool iosig;\n\tstatic char c;\n\tfor (iosig = false, c = read(); !isdigit(c); c = read()) {\n\t\tif (c == '-') iosig = true;\n\t\tif (c == -1) return;\n\t}\n\tfor (x = 0; isdigit(c); c = read()) x = x * 10 + (c ^ '0');\n\tif (iosig) x = -x;\n}\n\nchar sr[10000000],z[20];int C=-1,Z=0;\nvoid Ot(){fwrite(sr,1,C+1,stdout),C=-1;}\nvoid print(int x){\n\tif (x<0) sr[++C]='-',x=-x;\n    while(z[++Z]=x%10+48,x/=10);\n    while(sr[++C]=z[Z],--Z);sr[++C]='\\n';\n}\n\nconst int N=100100;\nint fa[N],size[N],key[N];\nstruct p\n{\n\tint x,y,v;\n} a[N];\n\nbool cmp(p x,p y)\n{\n\treturn x.v>y.v;\n}\n\nint find(int x){return fa[x]=fa[x]==x?x:find(fa[x]);}\n\n//void add(int x,int y,int z){to[++cnt]=y;v[cnt]=z;Next[cnt]=head[x];head[x]=cnt;}\nint main()\n{\n\tint n,h,w;\n\tread(n);read(h);read(w);\n\tfor (int i=1;i<=n;i++) read(a[i].x),read(a[i].y),a[i].y+=h,read(a[i].v);\n\tfor (int i=1;i<=h+w;i++) fa[i]=i,size[i]=1;\n\tsort(a+1,a+n+1,cmp);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint fx=find(fa[a[i].x]),fy=find(fa[a[i].y]);\n\t\tif (fx==fy)\n\t\t{\n\t\t\tif (size[fx]>=key[fx]+1)\n\t\t\t{\n\t\t\t\tkey[fx]++;\n\t\t\t\tans+=a[i].v;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (size[fx]+size[fy]>=key[fx]+key[fy]+1)\n\t\t\t{\n\t\t\t\tsize[fx]+=size[fy];\n\t\t\t\tkey[fx]+=key[fy]+1;\n\t\t\t\tfa[fy]=fx;\n\t\t\t\tans+=a[i].v;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Card {\n  int row;\n  int col;\n  int value;\n};\n\nint main() {\n  int N, H, W;\n  cin >> N >> H >> W;\n  vector<int> row_to_col(H + 1);\n  vector<int> col_to_row(W + 1);\n  auto cmp = [](auto&& lhs, auto&& rhs) { return lhs.value < rhs.value; };\n  priority_queue<Card, vector<Card>, decltype(cmp)> q{cmp};\n  for (int i = 1; i <= N; ++i) {\n    Card c;\n    cin >> c.row >> c.col >> c.value;\n    q.emplace(move(c));\n  }\n  int64_t result = 0;\n  for (; !q.empty(); q.pop()) {\n    auto&& c = q.top();\n    auto& rc = row_to_col[c.row];\n    auto& cr = col_to_row[c.col];\n    if (rc == 0 && cr == 0) {\n      rc = c.col;\n      cr = c.row;\n      result += c.value;\n    } else if (rc == 0) {\n      rc = -1;\n      result += c.value;\n    } else if (cr == 0) {\n      cr = -1;\n      result += c.value;\n    } else if (rc == -1 && cr == -1) {\n    } else if (rc == -1) {\n      cr = -1;\n      result += c.value;\n    } else if (cr == -1) {\n      rc = -1;\n      result += c.value;\n    } else {\n      col_to_row[rc] = cr;\n      row_to_col[cr] = rc;\n      rc = cr = -1;\n      result += c.value;\n    }\n  }\n\n  cout << result << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\nusing Pli = pair<ll, int>;\nusing Pil = pair<int, ll>;\nusing Pll = pair<ll, ll>;\nusing Pdd = pair<double, double>;\nusing cd = complex<double>;\n\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\n\nint H[100010], W[100010];\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(20);\n  INT(n); INT(h); INT(w);\n  vector<int> r(n), c(n); vector<ll> a(n);\n  rep(i, n)cin >> r[i] >> c[i] >> a[i], r[i]--, c[i]--;\n  vector<int> e(n); rep(i, n)e[i] = i;\n  vector<bool> used(n, false);\n  sort(all(e), [&](int i, int j){\n                 return a[i] > a[j];\n               });\n  ll res = 0;\n  vector<bool> uh(h, false), uw(w, false);\n  rep(i, h)H[i] = -1;\n  rep(i, w)W[i] = -1;\n  rep(i, n){\n    int x = r[e[i]], y = c[e[i]];\n    if(!uh[x]){\n      uh[x] = true;\n      res += a[e[i]];\n      used[e[i]] = true;\n      H[x] = e[i];\n    }else if(!uw[y]){\n      uw[y] = true;\n      res += a[e[i]];\n      used[e[i]] = true;\n      W[y] = e[i];\n    }\n  }\n  for(int k = 0; k < 10; k++){\n    rep(i, n){\n      int I = i;\n      if(used[I])continue;\n      if(!uh[r[I]]){\n        uh[r[I]] = true;\n        res += a[I];\n        used[I] = true;\n        H[r[I]] = I;\n        continue;\n      }else if(!uw[c[I]]){\n        uw[c[I]] = true;\n        res += a[I];\n        used[I] = true;\n        W[c[I]] = I;\n        continue;\n      }\n      if(a[H[r[I]]] < a[I]){\n        res += a[I] - a[H[r[I]]];\n        used[I] = true;\n        used[H[r[I]]] = false;\n        H[r[I]] = I;\n      }else if(a[W[c[I]]] < a[I]){\n        res += a[I] - a[W[c[I]]];\n        used[I] = true;\n        used[W[c[I]]] = false;\n        W[c[I]] = I;\n      }\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,H,W;\n\ntemplate<class V> class MaxFlow_dinic {\npublic:\n\tstruct edge { int to,reve;V cap;};\n\tstatic const int MV = 301100;\n\tvector<edge> E[MV];\n\tint itr[MV],lev[MV];\n\tvoid add_edge(int x,int y,V cap,bool undir=false) {\n\t\tE[x].push_back((edge){y,(int)E[y].size(),cap});\n\t\tE[y].push_back((edge){x,(int)E[x].size()-1,undir?cap:0});\n\t}\n\tvoid bfs(int cur) {\n\t\tMINUS(lev);\n\t\tqueue<int> q;\n\t\tlev[cur]=0;\n\t\tq.push(cur);\n\t\twhile(q.size()) {\n\t\t\tint v=q.front(); q.pop();\n\t\t\tITR(e,E[v]) if(e->cap>0 && lev[e->to]<0) lev[e->to]=lev[v]+1, q.push(e->to);\n\t\t}\n\t}\n\tV dfs(int from,int to,V cf) {\n\t\tif(from==to) return cf;\n\t\tfor(;itr[from]<E[from].size();itr[from]++) {\n\t\t\tedge* e=&E[from][itr[from]];\n\t\t\tif(e->cap>0 && lev[from]<lev[e->to]) {\n\t\t\t\tV f=dfs(e->to,to,min(cf,e->cap));\n\t\t\t\tif(f>0) {\n\t\t\t\t\te->cap-=f;\n\t\t\t\t\tE[e->to][e->reve].cap += f;\n\t\t\t\t\treturn f;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\tV maxflow(int from, int to) {\n\t\tV fl=0,tf;\n\t\twhile(1) {\n\t\t\tbfs(from);\n\t\t\tif(lev[to]<0) return fl;\n\t\t\tZERO(itr);\n\t\t\twhile((tf=dfs(from,to,numeric_limits<V>::max()))>0) fl+=tf;\n\t\t}\n\t}\n};\nMaxFlow_dinic<ll> mf;\n\nint R[101010],C[101010],A[101010];\nint Rok[101010],Cok[101010];\nset<int> RE[101010];\nset<int> CE[101010];\nvoid dfsC(int x);\n\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank,cnt;\n\tUF() {par=rank=vector<int>(um,0); cnt=vector<int>(um,1); for(int i=0;i<um;i++) par[i]=i;}\n\tvoid reinit() {int i; FOR(i,um) rank[i]=0,cnt[i]=1,par[i]=i;}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint count(int x) { return cnt[operator[](x)];}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tcnt[y]=cnt[x]=cnt[x]+cnt[y];\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\nUF<202020> uf;\n\nvoid dfsR(int y) {\n\tRok[y]=0;\n\twhile(RE[y].size()) {\n\t\tint x=*RE[y].begin();\n\t\tRE[y].erase(RE[y].begin());\n\t\tCE[x].erase(y);\n\t\tdfsC(x);\n\t}\n}\nvoid dfsC(int x) {\n\tCok[x]=0;\n\twhile(CE[x].size()) {\n\t\tint y=*CE[x].begin();\n\t\tCE[x].erase(CE[x].begin());\n\t\tRE[y].erase(x);\n\t\tdfsR(y);\n\t}\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>H>>W;\n\tvector<vector<int>> V;\n\tFOR(i,N) {\n\t\tcin>>R[i]>>C[i]>>A[i];\n\t\tR[i]--;\n\t\tC[i]--;\n\t\tV.push_back({A[i],R[i],C[i]});\n\t}\n\tFOR(i,H) Rok[i]=1;\n\tFOR(i,W) Cok[i]=1;\n\t\n\tsort(ALL(V));\n\treverse(ALL(V));\n\tll ret=0;\n\tFORR(v,V) {\n\t\tint y=v[1];\n\t\tint x=v[2];\n\t\t\n\t\tif(Rok[y]&&Cok[x]) {\n\t\t\tif(uf[y]==uf[x+100000]) {\n\t\t\t\tdfsR(y);\n\t\t\t\tdfsC(x);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuf(y,x+100000);\n\t\t\t\tRE[y].insert(x);\n\t\t\t\tCE[x].insert(y);\n\t\t\t}\n\t\t\tret+=v[0];\n\t\t}\n\t\telse if(Rok[y]) {\n\t\t\tdfsR(y);\n\t\t\tret+=v[0];\n\t\t}\n\t\telse if(Cok[x]) {\n\t\t\tdfsC(x);\n\t\t\tret+=v[0];\n\t\t}\n\t}\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> // Tomasz Nowak\nusing namespace std;     // XIII LO Szczecin\nusing LL = long long;    // Poland\n#define FOR(i, l, r) for(int i = (l); i <= (r); ++i)\n#define REP(i, n) FOR(i, 0, (n) - 1)\ntemplate<class T> int size(T &&x) {\n\treturn int(x.size());\n}\ntemplate<class A, class B> ostream& operator<<(ostream &out, const pair<A, B> &p) {\n\treturn out << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate<class T> auto operator<<(ostream &out, T &&x) -> decltype(x.begin(), out) {\n\tout << '{';\n\tfor(auto it = x.begin(); it != x.end(); ++it)\n\t\tout << *it << (it == prev(x.end()) ? \"\" : \", \");\n\treturn out << '}';\n}\nvoid dump() {}\ntemplate<class T, class... Args> void dump(T &&x, Args... args) {\n\tcerr << x << \";  \";\n\tdump(args...);\n}\n#ifdef DEBUG\n  struct Nl{~Nl(){cerr << '\\n';}};\n# define debug(x...) cerr << (strcmp(#x, \"\") ? #x \":  \" : \"\"), dump(x), Nl(), cerr << \"\"\n#else\n# define debug(...) 0 && cerr\n#endif\nmt19937_64 rng(0);\nint rd(int l, int r) {\n\treturn uniform_int_distribution<int>(l, r)(rng);\n}\n// end of templates\n\nstruct MCMF {\n\tstruct Edge {\n\t\tint v, u, flow, cap;\n\t\tLL cost;\n\t\tfriend ostream& operator<<(ostream &os, Edge &e) {\n\t\t\treturn os << vector<LL>{e.v, e.u, e.flow, e.cap, e.cost};\n\t\t}\n\t};\n\n\tint n;\n\tconst LL inf_LL = 0x3f3f3f3f3f3f3f3f;\n\tconst int inf_int = 0x3f3f3f3f;\n\tvector<vector<int>> graph;\n\tvector<Edge> edges;\n\n\tMCMF(int N) : n(N), graph(n) {}\n\n\tvoid add_edge(int v, int u, int cap, LL cost) {\n\t\tdebug() << \"adding edge \" << v << '-' << u << \": \" << make_pair(cap, cost);\n\t\tint e = size(edges);\n\t\tgraph[v].emplace_back(e);\n\t\tgraph[u].emplace_back(e + 1);\n\t\tedges.emplace_back(Edge{v, u, 0, cap, cost});\n\t\tedges.emplace_back(Edge{u, v, 0, 0, -cost});\n\t}\n\n\tpair<int, LL> augment(int source, int sink) {\n\t\tvector<LL> dist(n, inf_LL);\n\t\tvector<int> from(n, -1);\n\t\tdist[source] = 0;\n\t\tdeque<int> que = {source};\n\t\tvector<bool> inside(n);\n\t\tinside[source] = true;\n\n\t\twhile(size(que)) {\n\t\t\tint v = que.front();\n\t\t\tinside[v] = false;\n\t\t\tque.pop_front();\n\n\t\t\tfor(int i : graph[v]) {\n\t\t\t\tEdge &e = edges[i];\n\t\t\t\tif(e.flow != e.cap and dist[e.u] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.u] = dist[v] + e.cost;\n\t\t\t\t\tfrom[e.u] = i;\n\t\t\t\t\tif(not inside[e.u]) {\n\t\t\t\t\t\tinside[e.u] = true;\n\t\t\t\t\t\tque.emplace_back(e.u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(from[sink] == -1)\n\t\t\treturn {0, 0};\n\n\t\tint flow = inf_int, e = from[sink];\n\t\twhile(e != -1) {\n\t\t\tflow = min(flow, edges[e].cap - edges[e].flow);\n\t\t\te = from[edges[e].v];\n\t\t}\n\t\te = from[sink];\n\t\twhile(e != -1) {\n\t\t\tedges[e].flow += flow;\n\t\t\tedges[e ^ 1].flow -= flow;\n\t\t\te = from[edges[e].v];\n\t\t}\n\t\treturn {flow, flow * dist[sink]};\n\t}\n\n\tpair<int, LL> operator()(int source, int sink) {\n\t\tint flow = 0;\n\t\tLL cost = 0;\n\t\tpair<int, LL> got;\n\t\tdo {\n\t\t\tgot = augment(source, sink);\n\t\t\tflow += got.first;\n\t\t\tcost += got.second;\n\t\t} while(got.first);\n\t\treturn {flow, cost};\n\t}\n};\n\nvector<int> vis, match;\nvector<int> a;\nvector<array<int, 2>> edges;\nint vis_cnt = 0;\n\nbool ask(int q) {\n\tvis[q] = vis_cnt;\n\tREP(d, 2)\n\t\tif(match[edges[q][d]] == -1) {\n\t\t\tmatch[edges[q][d]] = q;\n\t\t\treturn true;\n\t\t}\n\tREP(d, 2) {\n\t\tint &m = match[edges[q][d]];\n\t\tif(vis[m] != vis_cnt and ask(m)) {\n\t\t\tm = q;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n, h, w;\n\tcin >> n >> h >> w;\n\ta.resize(n);\n\tedges.resize(n);\n\tLL answer = 0;\n\n\tvector<pair<int, int>> sorted;\n\tREP(q, n) {\n\t\tint r, c, cost;\n\t\tcin >> r >> c >> cost;\n\t\t--r, --c;\n\t\ta[q] = cost;\n\t\tedges[q] = {r, h + c};\n\t\tif(rd(0, 1))\n\t\t\tswap(edges[q][0], edges[q][1]);\n\t\tsorted.emplace_back(a[q], q);\n\t}\n\tsort(sorted.rbegin(), sorted.rend());\n\tdebug(sorted);\n\n\tvis.resize(n);\n\tmatch.resize(h + w, -1);\n\n\tint matched = 0;\n\tfor(auto &p : sorted) {\n\t\tif(matched == h + w)\n\t\t\tcontinue;\n\t\t++vis_cnt;\n\t\tif(ask(p.second)) {\n\t\t\tanswer += a[p.second];\n\t\t\t++matched;\n\t\t}\n\t}\n\n\tcout << answer << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((lint)(x).size())\n#define POW2(n) (1LL << (n))\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> bool mmax(T &m, const T q) { if (m < q) {m = q; return true;} else return false; }\ntemplate<typename T> bool mmin(T &m, const T q) { if (m > q) {m = q; return true;} else return false; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(const pair<T1, T2> &l, const pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n/*\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/tag_and_trait.hpp>\nusing namespace __gnu_pbds; // find_by_order(), order_of_key()\ntemplate<typename TK> using pbds_set = tree<TK, null_type, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename TK, typename TV> using pbds_map = tree<TK, TV, less<TK>, rb_tree_tag, tree_order_statistics_node_update>;\n*/\n\nstruct SizeAwareUnionFind\n{\n    vector<int> par, cou, deg;\n    SizeAwareUnionFind(int N) : par(N), cou(N), deg(N) { REP(i, N) par[i] = i, cou[i] = 1, deg[i] = 0; }\n    int find(int x) { return (par[x] == x) ? x : (par[x] = find(par[x])); }\n    void unite(int x, int y) {\n        x = find(x), y = find(y); if (x == y) return;\n        if (cou[x] < cou[y]) swap(x, y); \n        par[y] = x, cou[x] += cou[y], deg[x] += deg[y];\n    }\n    int count(int x) { return cou[find(x)]; }\n    bool same(int x, int y) { return find(x) == find(y); }\n    int get_deg(int x) { return deg[find(x)]; }\n};\n\nint main()\n{\n    int N, H, W;\n    cin >> N >> H >> W;\n    SizeAwareUnionFind uf(1 + H + W);\n    vector<lint> R(N);\n    vector<lint> C(N);\n    vector<lint> A(N);\n    REP(i, N){ cin >> R[i]; cin >> C[i]; cin >> A[i]; }\n\n    priority_queue<pair<int, pint>> pq;\n    REP(i, N) pq.emplace(A[i], make_pair(R[i], C[i]));\n\n    lint ret = 0;\n    while (!pq.empty())\n    {\n        auto p = pq.top();\n        pq.pop();\n        lint v = p.first;\n        pint pa = p.second;\n        int X = pa.first, Y = H + pa.second;\n\n        if (uf.same(X, Y))\n        {\n            if (uf.get_deg(X) < uf.count(X))\n            {\n                ret += v;\n                uf.deg[uf.find(X)]++;\n            }\n        }\n        else\n        {\n            if (uf.get_deg(X) >= uf.count(X) and uf.get_deg(Y) >= uf.count(Y)) continue;\n            uf.unite(X, Y);\n            uf.deg[uf.find(X)]++;\n            ret += v;\n        }\n    }\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<ll, P> P3;\ntypedef pair<P, P> PP;\nconstexpr ll MOD = ll(1e9 + 7);\nconstexpr int IINF = INT_MAX;\nconstexpr ll LLINF = LLONG_MAX;\nconstexpr int MAX_N = int(1e5) + 5;\nconstexpr double EPS = 1e-9;\nconstexpr int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i > 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\ntypedef int FLOW;                // フローを表す型、今回は int 型\nconst int MAX_V = 400000;           // グラフの最大ノード数\nconst FLOW INF = 100000000;      // 十分大きい値\n\n// グラフの辺の構造体\nstruct Edge {\n    int rev, from, to;\n    FLOW cap, icap;\n    Edge(int r, int f, int t, FLOW c) : rev(r), from(f), to(t), cap(c), icap(c) {}\n    friend ostream& operator << (ostream& s, const Edge& E) {\n        if (E.cap > 0) return s << E.from << \"->\" << E.to << '(' << E.cap << ')';\n        else return s;\n    }\n};\n\n// グラフ構造体\nstruct Graph {\n    int V;\n    vector<Edge> list[MAX_V];\n\n    Graph(int n = 0) : V(n) { for (int i = 0; i < MAX_V; ++i) list[i].clear(); }\n    void init(int n = 0) { V = n; for (int i = 0; i < MAX_V; ++i) list[i].clear(); }\n    void resize(int n = 0) { V = n; }\n    void reset() { for (int i = 0; i < V; ++i) for (int j = 0; j < list[i].size(); ++j) list[i][j].cap = list[i][j].icap; }\n    inline vector<Edge>& operator [] (int i) { return list[i]; }\n\n    Edge &redge(Edge e) {\n        if (e.from != e.to) return list[e.to][e.rev];\n        else return list[e.to][e.rev + 1];\n    }\n\n    void addedge(int from, int to, FLOW cap) {\n        list[from].push_back(Edge((int)list[to].size(), from, to, cap));\n        list[to].push_back(Edge((int)list[from].size() - 1, to, from, 0));\n    }\n};\n\n// 最大流を求めるサブルーチンたち\nstatic int level[MAX_V];\nstatic int iter[MAX_V];\n\nvoid dibfs(Graph &G, int s) {\n    for (int i = 0; i < MAX_V; ++i) level[i] = -1;\n    level[s] = 0;\n    queue<int> que;\n    que.push(s);\n    while (!que.empty()) {\n        int v = que.front();\n        que.pop();\n        for (int i = 0; i < G[v].size(); ++i) {\n            Edge &e = G[v][i];\n            if (level[e.to] < 0 && e.cap > 0) {\n                level[e.to] = level[v] + 1;\n                que.push(e.to);\n            }\n        }\n    }\n}\n\nFLOW didfs(Graph &G, int v, int t, FLOW f) {\n    if (v == t) return f;\n    for (int &i = iter[v]; i < G[v].size(); ++i) {\n        Edge &e = G[v][i], &re = G.redge(e);\n        if (level[v] < level[e.to] && e.cap > 0) {\n            FLOW d = didfs(G, e.to, t, min(f, e.cap));\n            if (d > 0) {\n                e.cap -= d;\n                re.cap += d;\n                return d;\n            }\n        }\n    }\n    return 0;\n}\n\n// 最大流を求めるメイン関数\nFLOW Dinic(Graph &G, int s, int t) {\n    FLOW res = 0;\n    while (true) {\n        dibfs(G, s);\n        if (level[t] < 0) return res;\n        memset(iter, 0, sizeof(iter));\n        FLOW flow;\n        while ((flow = didfs(G, s, t, INF)) > 0) {\n            res += flow;\n        }\n    }\n}\n\nvector<P> a;\nvector<int> r, c;\nGraph G;\n\nint main() {\n    int N, H, W;\n\n    cin >> N >> H >> W;\n    a.resize(N);\n    r.resize(N);\n    c.resize(N);\n\n    // グラフの定義 (ノード数を引数に)\n    G.init(H + W + N + 2);             // +2 は S, T の分\n\n    // スーパーノード S, T の index\n    int S_node = H + W + N;\n    int T_node = H + W + N + 1;\n\n    for(int i=0;i<N;i++){\n        cin >> r[i] >> c[i] >> a[i].first;\n        r[i]--;\n        c[i]--;\n        a[i].second = i;\n    }\n    SORTR(a);\n\n    // グラフに枝を張っていく\n    for(int i=0;i<N;i++){\n        int id = a[i].second;\n        G.addedge(r[id], H+W+i, 1);\n        G.addedge(H + c[id], H+W+i, 1);\n    }\n\n    for (int i = 0; i < H+W; ++i) {\n        // S から、容量 1 の枝を張る\n        G.addedge(S_node, i, 1);\n    }\n\n    for (int j = 0; j < N; ++j) {\n        // T へと、容量 1 の枝を張る\n        G.addedge(j + H+W, T_node, 1);\n    }\n\n    // 最大流を求める\n    FLOW res = Dinic(G, S_node, T_node);\n\n    ll ans = 0;\n    // 誰がどの仕事に割当てられたか\n    for (int i = 0; i < H+W; ++i) {\n        for (auto e : G[i]) {\n            // 元々の容量 (e.icap) が 1 で、フローが流れて容量 (e.cap) が 0 になった部分が割り当てられたところ\n            if (e.icap == 1 && e.cap == 0) {\n                ans += a[e.to - (H+W)].first;\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define __builtin_popcount __builtin_popcountll\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const map<S, T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n// O(sqrt(V)E)\nbool dfs(const vector<vi> &G,int v,vector<bool> &visit, vector<int> &match,vector<int> &level){\n    visit[v]=true;\n    REP(i,G[v].size()){\n        int dst=G[v][i];\n        int w=match[dst];\n        if(w==-1 || (!visit[w] && level[v] < level[w] && dfs(G,w,visit,match,level))){\n            match[v]=dst;\n            match[dst]=v;\n            return true;\n        }\n    }\n    return false;\n}\nvector<int> bipartite_matching(const vector<vi> &G){\n    vector<int> match(G.size(), -1);\n    for(int res = 0;;){\n        vector<int> level(G.size(),-1);\n        queue<int> que;\n        REP(i,G.size()){\n            if(match[i]==-1){\n                que.push(i);\n                level[i]=0;\n            }\n        }\n        while(!que.empty()){\n            int v=que.front();que.pop();\n            REP(i,G[v].size()){\n                int dst=G[v][i];\n                int w=match[dst];\n                if(w != -1 && level[w]<0){\n                    level[w]=level[v]+1;\n                    que.push(w);\n                }\n            }\n        }\n        vector<bool> visit(G.size());\n        int d=0;\n        REP(v,G.size()){\n            if(match[v]==-1&&dfs(G,v,visit,match,level))d++;\n        }\n        if(d==0)return match;\n        res+=d;\n    }\n}\n\nll T, n, m, k;\n\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    while(cin >> n >> m >> k){\n        vector<tuple<int, int, int>> v;\n        vi s;\n        REP(i, n) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            v.emplace_back(z, x, y);\n            s.emplace_back(x);\n            s.emplace_back(-y);\n        }\n        sort(RALL(v));\n        sort(ALL(s));\n        UNIQUE(s);\n        map<int, int> mp;\n        REP(i, s.size()) mp[s[i]] = i;\n        vector<vi> g(n + s.size());\n        REP(i, n) {\n            int x, y, z; tie(z, x, y) = v[i];\n            g[i].emplace_back(n + mp[x]);\n            g[i].emplace_back(n + mp[-y]);\n            g[n + mp[x]].emplace_back(i);\n            g[n + mp[-y]].emplace_back(i);\n        }\n        vi match = bipartite_matching(g);\n        ll ans = 0;\n        REP(i, n) {\n            if (match[i] != -1 && match[match[i]] == i) {\n                ans += get<0>(v[i]);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <functional>\n#include <limits>\n#include <numeric>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <array>\n#include <vector>\n#include <deque>\n#include <forward_list>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n\nusing namespace std;\n\n#define popcount __builtin_popcountll\n#define FORS(i, s, n) for (int i = (s); i < (n); ++i)\n#define RFORS(i, s, n) for (int i = (n)-1; i >= (s); --i)\n#define FOR(i, n) FORS(i, 0, n)\n#define RFOR(i, n) RFORS(i, 0, n)\n#define FI(n) FOR(i, n)\n#define RFI(n) RFOR(i, n)\n#define ALL(x) (x).begin(), (x).end()\n#define RALL(x) (x).rbegin(), (x).rend()\n#define MP(x,y) make_pair((x),(y))\n#define PB(x) push_back((x))\n#define SZ(c) int((c).size())\n#define FOR_SETTED_BIT(bit, mask) for (int bit = 0; (mask) >> bit; ++bit) if (1&(mask >> bit))\n#define FOR_NONZERO_SUBMASK(submask, mask) for (int submask=(mask); submask; submask=(submask-1)&(mask))\n#define PI (3.141592653589793L)\n#define MODULO ((ll)1e9+7LL)\n\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair < int, int > pi;\ntypedef pair < ll, ll > pll;\ntypedef pair < ld, ld > pld;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<ld> vld;\ntypedef vector<pi> vpi;\ntypedef vector<pll> vpll;\ntypedef vector<pld> vpld;\ntypedef list<int> li;\ntypedef list<ll> lll;\ntypedef list<ld> lld;\ntypedef list<pi> lpi;\ntypedef list<pll> lpll;\ntypedef list<pld> lpld;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<vld> vvld;\ntypedef vector<vpi> vvpi;\ntypedef vector<vpll> vvpll;\ntypedef vector<vpld> vvpld;\ntypedef vector<li> vli;\ntypedef vector<lll> vlll;\ntypedef vector<lld> vlld;\ntypedef vector<lpi> vlpi;\ntypedef vector<lpll> vlpll;\ntypedef vector<lpld> vlpld;\ntypedef set<int> si;\ntypedef set<ll> sll;\ntypedef set<pi> spi;\ntypedef set<pll> spll;\ntypedef vector< list < pair < int, ll > > > AdjacencyLists;\ntypedef vvll AdjacencyMatrix;\n\n\ntemplate<class T> inline T sqr(const T &x) { return x * x; }\ninline ll sqr(int x){return sqr<ll>(x);}\ntemplate<class T>T binpow(const T &a, ll n) { return n == 0 ? 1 : sqr(binpow(a, n / 2))* (n % 2 ? a : 1); }\nll binpow(ll a, ll n, ll modulo) { return n == 0 ? 1 : sqr(binpow(a, n / 2, modulo)) % modulo * (n % 2 ? a : 1) % modulo; }\n\nll gcd(ll a, ll b, ll &x, ll &y)\n{\n    if (a == 0)\n    {\n        x = 0;\n        y = 1;\n        return b;\n    }\n    ll x1, y1;\n    ll d = gcd(b%a, a, x1, y1);\n    x = y1 - (b / a) * x1;\n    y = x1;\n    return d;\n}\ninline ll phi (ll n) {\n    ll result = n;\n    for (ll i=2; i*i<=n; ++i)\n        if (n % i == 0) {\n            while (n % i == 0)\n                n /= i;\n            result -= result / i;\n        }\n    if (n > 1)\n        result -= result / n;\n    return result;\n}\ninline vll inverseAll(ll m)\n{\n    vll r(m);\n    r[1] = 1;\n    for (int i=2; i<m; ++i)\n        r[i] = (m - (m/i) * r[m%i] % m) % m;\n    return r;\n}\ninline ll gcd(ll a, ll b) { return gcd(a, b, a, b); }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\ninline ll llrand()\n{\n    const ll lsbToFill = (sizeof(ll) << 3) - 1;\n    const ll bitsFilledInIteration = popcount(RAND_MAX);\n    ll number = 0;\n    \n    for (ll lsbFilled = 0; lsbFilled <= lsbToFill; lsbFilled += bitsFilledInIteration)\n    {\n        number ^= (((ll)rand()) << lsbFilled);\n    }\n    \n    return number & numeric_limits<ll>::max();\n}\ninline ll llrand(ll begin, ll end)\n{\n    return begin + llrand() % (end - begin);\n}\n\nstruct Dinic {\n    struct Edge {\n        int u, v;\n        ll cap, flow;\n        Edge() {}\n        Edge(int u, int v, ll cap): u(u), v(v), cap(cap), flow(0) {}\n    };\n    \n    int N;\n    vector<Edge> E;\n    vector<vector<int>> g;\n    vector<int> d, pt;\n    \n    Dinic(int N): N(N), E(0), g(N), d(N), pt(N) {}\n    \n    void AddEdge(int u, int v, ll cap) {\n        if (u != v) {\n            E.emplace_back(Edge(u, v, cap));\n            g[u].emplace_back(E.size() - 1);\n            E.emplace_back(Edge(v, u, 0));\n            g[v].emplace_back(E.size() - 1);\n        }\n    }\n    \n    bool BFS(int S, int T) {\n        queue<int> q({S});\n        fill(d.begin(), d.end(), N + 1);\n        d[S] = 0;\n        while(!q.empty()) {\n            int u = q.front(); q.pop();\n            if (u == T) break;\n            for (int k: g[u]) {\n                Edge &e = E[k];\n                if (e.flow < e.cap && d[e.v] > d[e.u] + 1) {\n                    d[e.v] = d[e.u] + 1;\n                    q.emplace(e.v);\n                }\n            }\n        }\n        return d[T] != N + 1;\n    }\n    \n    ll DFS(int u, int T, ll flow = -1) {\n        if (u == T || flow == 0) return flow;\n        for (int &i = pt[u]; i < g[u].size(); ++i) {\n            Edge &e = E[g[u][i]];\n            Edge &oe = E[g[u][i]^1];\n            if (d[e.v] == d[e.u] + 1) {\n                ll amt = e.cap - e.flow;\n                if (flow != -1 && amt > flow) amt = flow;\n                if (ll pushed = DFS(e.v, T, amt)) {\n                    e.flow += pushed;\n                    oe.flow -= pushed;\n                    return pushed;\n                }\n            }\n        }\n        return 0;\n    }\n    \n    ll MaxFlow(int S, int T) {\n        ll total = 0;\n        while (BFS(S, T)) {\n            fill(pt.begin(), pt.end(), 0);\n            while (ll flow = DFS(S, T))\n                total += flow;\n        }\n        return total;\n    }\n};\n\nvll Dijkstra(const AdjacencyLists &g, int s)\n{\n    vll d(SZ(g), numeric_limits<ll>::max() / 2LL);\n    priority_queue < pair<ll, int> > q;\n\n    d[s] = 0;\n    q.emplace(-0, s);\n    \n    while (!q.empty())\n    {\n        while (q.top().first > d[q.top().second]) { q.pop(); }\n        int v = q.top().second;\n        \n        q.pop();\n        \n        for (const auto &cw : g[v])\n        {\n            if (d[v] + cw.second < d[cw.first])\n            {\n                d[cw.first] = d[v] + cw.second;\n                q.emplace(-d[cw.first], cw.first);\n            }\n        }\n    }\n    \n    return d;\n}\n\nstruct BinarySearchIterator : public std::iterator<std::forward_iterator_tag, bool>\n{\n    ll value;\n    \n    typename iterator_traits<BinarySearchIterator>::difference_type operator - (const BinarySearchIterator &it) const { return value - it.value; }\n    \n    BinarySearchIterator& operator ++() { ++value; return *this; }\n    \n    bool operator != (const BinarySearchIterator &it) const { return value != it.value; }\n    \n    bool operator*() const { /*insert code here*/ return true; }\n};\n\ntemplate < int ALPHA >\nclass AhoCorasick\n{\npublic:\n    static const int ILLEGAL_INDEX;\n    static const int ROOT;\n    \n    struct Node\n    {\n        bool leaf;\n        int parent;\n        int parentCharacter;\n        int link;\n        \n        int next[ALPHA];\n        int go[ALPHA];\n        int outputFunction;\n        \n        Node(int parent = ILLEGAL_INDEX, int parentCharacter = ALPHA) :\n            leaf(false),\n            parent(parent),\n            parentCharacter(parentCharacter),\n            link(ILLEGAL_INDEX),\n            outputFunction(ILLEGAL_INDEX)\n        {\n            fill_n(next, ALPHA, ILLEGAL_INDEX);\n            fill_n(go, ALPHA, ILLEGAL_INDEX);\n        }\n    };\n    \n    vector<Node> tree = vector<Node>(1);\n    \n    AhoCorasick(){}\n    AhoCorasick(int maxStatesNumber)\n    {\n        tree.reserve(maxStatesNumber);\n    }\n    \n    template < class Iterator >\n    void add(int length, const Iterator begin)\n    {\n        int vertex = ROOT;\n        \n        for (int i = 0; i < length; ++i)\n        {\n            if (ILLEGAL_INDEX == tree[vertex].next[begin[i]])\n            {\n                tree[vertex].next[begin[i]] = SZ(tree);\n                tree.push_back(Node(vertex, begin[i]));\n            }\n            \n            vertex = tree[vertex].next[begin[i]];\n        }\n        \n        tree[vertex].leaf = true;\n    }\n    \n    int getLink(int vertex)\n    {\n        assert(0 <= vertex && vertex < tree.size());\n        \n        if (ILLEGAL_INDEX == tree[vertex].link)\n        {\n            if (ROOT == vertex || ROOT == tree[vertex].parent)\n            {\n                tree[vertex].link = ROOT;\n            }\n            else\n            {\n                tree[vertex].link = go(getLink(tree[vertex].parent), tree[vertex].parentCharacter);\n            }\n        }\n        \n        return tree[vertex].link;\n    }\n    \n    int go(int vertex, int character)\n    {\n        assert(0 <= character && character < ALPHA);\n        assert(0 <= vertex && vertex < tree.size());\n        \n        if (ILLEGAL_INDEX == tree[vertex].go[character])\n        {\n            if (ILLEGAL_INDEX == tree[vertex].next[character])\n            {\n                tree[vertex].go[character] = ROOT == vertex ? ROOT : go(getLink(vertex), character);\n            }\n            else\n            {\n                tree[vertex].go[character] = tree[vertex].next[character];\n            }\n        }\n        \n        return tree[vertex].go[character];\n    }\n    \n    int getOutputFunction(int vertex)\n    {\n        assert(0 <= vertex && vertex < tree.size());\n        \n        if (ILLEGAL_INDEX == tree[vertex].outputFunction)\n        {\n            if (tree[vertex].leaf || ROOT == vertex)\n            {\n                tree[vertex].outputFunction = vertex;\n            }\n            else\n            {\n                tree[vertex].outputFunction = getOutputFunction(getLink(vertex));\n            }\n        }\n        \n        return tree[vertex].outputFunction;\n    }\n};\n\ntemplate < int ALPHA > const int AhoCorasick<ALPHA>::ILLEGAL_INDEX = -1;\ntemplate < int ALPHA > const int AhoCorasick<ALPHA>::ROOT = 0;\n\nstruct UnionFind {\n    vi parent;\n    vi rank;\n    UnionFind(int n) : parent(n), rank(n) {\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n    int find_set (int v) {\n        if (v == parent[v])\n            return v;\n        return parent[v] = find_set (parent[v]);\n    }\n    void union_sets (int a, int b) {\n        a = find_set (a);\n        b = find_set (b);\n        if (a != b) {\n            if (rank[a] < rank[b])\n                swap (a, b);\n            parent[b] = a;\n            if (rank[a] == rank[b])\n                ++rank[a];\n        }\n    }\n};\n\nvvi solve(int n) {\n    vvi g(n, vi(n));\n    \n    FI(n) {\n        FORS(j, i + 1, n) {\n            g[i][j] = i % 3;\n        }\n    }\n    \n    return g;\n}\n\nint main(int argc, const char * argv[]) {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.precision(13);\n    cout.setf(ios::fixed);\n    srand((unsigned int)time(NULL));\n\n    int n;\n    \n    while(cin >> n) {\n        auto g = solve(n);\n        \n        FI(n) {\n            FORS(j, i + 1, n) {\n                cout << 1 + g[i][j] << ' ';\n            }\n            cout << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nstruct union_find{\n    VI par, sz, data;\n\n    void init(int n){\n        sz.assign(n, 1);\n        data.assign(n, 1);\n        par.resize(n);\n        REP(i,n) par[i] = i;\n    }\n\n    int find(int x){\n        if (par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n\n    void merge(int x, int y){\n        x = find(x);\n        y = find(y);\n        if (x == y){\n            data[x] = 0;\n        }else{\n            sz[y] += sz[x];\n            par[x] = y;\n            data[y] &= data[x];\n        }\n    }\n\n    bool is_tree(int x){\n        return data[find(x)];\n    }\n};\n\nint main() {\n    int n, h, w;\n    cin >> n >> h >> w;\n    vector<pair<ll, P>> p(n);\n    REP(i,n){\n        p[i].second.first = in() - 1;\n        p[i].second.second = in() - 1;\n        p[i].first = in();\n    }\n    sort(ALL(p));\n    reverse(ALL(p));\n    union_find uf;\n    uf.init(h + w);\n    ll ans = 0;\n    for (auto tmp : p){\n        ll x = tmp.first;\n        int r = tmp.second.first;\n        int c = tmp.second.second;\n        c += h;\n        if (uf.is_tree(r) || uf.is_tree(c)){\n            ans += x;\n            uf.merge(r, c);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\nusing Pli = pair<ll, int>;\nusing Pil = pair<int, ll>;\nusing Pll = pair<ll, ll>;\nusing Pdd = pair<double, double>;\nusing cd = complex<double>;\n\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntypedef struct UnionFind_ {\n\tvector<int> par;\n\tvector<int> rank_;\n  vector<int> siz, ed;\n  UnionFind_(){}\n\texplicit UnionFind_(int n): rank_(n, 0) {\n    par.resize(n);\n    siz.resize(n, 1);\n    ed.resize(n, 0);\n    for(int i = 0; i < n; i++)par[i] = i;\n\t}\n\tint find(int x) {\n    if(par[x] == x)return x;\n    else return par[x] = find(par[x]);\n\t}\n\tbool same(int x, int y) {\n    if(find(x) == find(y))return true;\n    else return false;\n\t}\n\tbool unite(int x, int y){\n    int xp = find(x);\n    int yp = find(y);\n    if(xp == yp)return false;\n    if(rank_[xp] > rank_[yp]){\n      par[yp] = xp;\n      siz[xp] += siz[yp];\n      ed[xp] += ed[yp];\n      ed[xp]++;\n    }\n    else if(rank_[xp] < rank_[yp]){\n      par[xp] = yp;\n      siz[yp] += siz[xp];\n      ed[yp] += ed[xp];\n      ed[yp]++;\n    }\n    else {\n      par[yp] = xp;\n      rank_[xp]++;\n      siz[xp] += siz[yp];\n      ed[xp] += ed[yp];\n      ed[xp]++;\n    }\n    return true;\n\t}\n} UnionFind;\n\n\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(20);\n  INT(n); INT(h); INT(w);\n  vector<int> r(n), c(n); vector<ll> a(n);\n  rep(i, n)cin >> r[i] >> c[i] >> a[i], r[i]--, c[i]--;\n  ll res = 0;\n  vector<int> e(n); rep(i, n)e[i] = i;\n  sort(all(e), [&](int i, int j){\n                 return a[i] > a[j];\n               });\n  UnionFind uf(h + w);\n  rep(I, n){\n    int i = e[I];\n    if(uf.same(r[i], h + c[i])){\n      if(uf.siz[uf.find(r[i])] > uf.ed[uf.find(r[i])]){\n        uf.ed[uf.find(r[i])]++;\n        res += a[i];\n      }\n    }else{\n      int tsiz = uf.siz[uf.find(r[i])] + uf.siz[uf.find(h + c[i])];\n      int ted = uf.ed[uf.find(r[i])] + uf.ed[uf.find(h + c[i])];\n      if(tsiz >= ted + 1){\n        uf.unite(r[i], h + c[i]);\n        res += a[i];\n      }\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int MAXN = 1e5 + 10;\n\nstruct node{\n    int u,v;\n    ll w;\n}edge[MAXN];\n\nbool cmp(node a,node b)\n{\n    return a.w > b.w;\n}\n\nint cx[MAXN],cy[MAXN<<1],n,h,w;\nbool vis[MAXN];\n\nbool dfs(int i)\n{\n    if (vis[i]) return false;\n    vis[i] = 1;\n    if (cy[edge[i].u] == 0)\n    {\n        cy[edge[i].u] = i;\n        return true;\n    }\n    else if (cy[edge[i].v + MAXN] == 0)\n    {\n        cy[edge[i].v + MAXN] = i;\n        return true;\n    }\n    if (dfs(cy[edge[i].u]))\n    {\n        cy[edge[i].u] = i;\n        return true;\n    }\n    else if (dfs(cy[edge[i].v + MAXN]))\n    {\n        cy[edge[i].v + MAXN] = i;\n        return true;\n    }\n    return false;\n}\n\nll match()\n{\n    for (int i = 1;i<=n;i++)\n    {\n        memset(vis,0,sizeof(vis));\n        dfs(i);\n    }\n    ll ans = 0;\n    for (int i = 1;i<=h;i++)\n    {\n        ans += edge[cy[i]].w;\n        // cout<<edge[cy[i]].index<<' ';\n    }\n    // cout<<'\\n';\n    for (int i = MAXN + 1;i<=MAXN + w;i++)\n    {\n        ans += edge[cy[i]].w;\n        // cout<<edge[cy[i]].index<<' ';\n    }\n    return ans;\n}\n\nint main()\n{\n    cin>>n>>h>>w;\n    for (int i = 1;i<=n;i++)\n    {\n        scanf(\"%d%d%lld\",&edge[i].u,&edge[i].v,&edge[i].w);\n    }\n    sort(edge+1,edge + n + 1,cmp);\n\n    cout<<match();\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define __builtin_popcount __builtin_popcountll\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const map<S, T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nint timestamp = 1;\n\nbool bipartite_matching_dfs(\n        int v, const vector< vector<int> > &conn,\n        vector<int> &used, vector<int> &match)\n{\n    used[v] = timestamp;\n    for(int i = 0; i < conn[v].size(); ++i){\n        int u = conn[v][i], w = match[u];\n        if(w < 0 || (used[w] == timestamp && bipartite_matching_dfs(w, conn, used, match))){\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\nvector<int> bipartite_matching(const vector< vector<int> > &conn){\n    int res = 0;\n    vector<int> match(conn.size(), -1);\n    vector<int> used(conn.size(), 0);\n    for(int v = 0; v < conn.size(); ++v){\n        if(match[v] < 0){\n            timestamp ++;\n            if(bipartite_matching_dfs(v, conn, used, match)){ ++res; }\n        }\n    }\n    return match;\n}\n\nll T, n, m, k;\n\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    while(cin >> n >> m >> k){\n        vector<tuple<int, int, int>> v;\n        vi s;\n        REP(i, n) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            v.emplace_back(z, x, y);\n            s.emplace_back(x);\n            s.emplace_back(-y);\n        }\n        sort(RALL(v));\n        sort(ALL(s));\n        UNIQUE(s);\n        map<int, int> mp;\n        REP(i, s.size()) mp[s[i]] = i;\n        vector<vi> g(n + s.size());\n        REP(i, n) {\n            int x, y, z; tie(z, x, y) = v[i];\n            g[i].emplace_back(n + mp[x]);\n            g[i].emplace_back(n + mp[-y]);\n            g[n + mp[x]].emplace_back(i);\n            g[n + mp[-y]].emplace_back(i);\n        }\n        vi match = bipartite_matching(g);\n        ll ans = 0;\n        REP(i, n) {\n            if (match[i] != -1 && match[match[i]] == i) {\n                ans += get<0>(v[i]);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\nint P[200002];\nbool eranda[200002];\n\nint Find(int A) {\n\tif (P[A] < 0) return A;\n\treturn P[A] = Find(P[A]);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint N, H, W;\n\tcin >> N >> H >> W;\n\n\tpair<int, pair<int, int>> E[100000];\n\trep(i, N) {\n\t\tint r, c, a;\n\t\tcin >> r >> c >> a;\n\t\tE[i] = mp(a, mp(r - 1, H + c - 1));\n\t}\n\tsort(E, E + N);\n\treverse(E, E + N);\n\n\trep(i, H + W) P[i] = -1;\n\tll kotae = 0;\n\trep(i, N) {\n\t\tint r = Find(E[i].second.first);\n\t\tint c = Find(E[i].second.second);\n\t\tif (r != c) {\n\t\t\tif (!(eranda[r] && eranda[c])) {\n\t\t\t\tif (P[r] > P[c]) swap(r, c);\n\t\t\t\tP[r] += P[c];\n\t\t\t\teranda[r] |= eranda[c];\n\t\t\t\tP[c] = r;\n\t\t\t\tkotae += E[i].first;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (eranda[r] == 0) {\n\t\t\t\teranda[r] = 1;\n\t\t\t\tkotae += E[i].first;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\", kotae);\n\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst long long mo = 1e9+7;\nconst int maxi = 1e6+10;\n#define pb push_back\nint n,k;\nstring s;\nvector<int> v[maxi];\nint a[maxi];\nint cnt[maxi];\nint ob[2][maxi];\nint c[maxi], r[maxi];\nmultiset<int> st[2][maxi];\nmultiset<pair<int, pair<int,int>>> global;\nint h,w;\nint main()\n{\n     cin>>n>>h>>w;\n\n     for (int i=1;i<=n;i++)\n     {\n          scanf(\"%d%d%d\",&r[i],&c[i],&a[i]);\n          st[1][r[i]].insert(a[i]);\n          st[2][c[i]].insert(a[i]);\n          global.insert({a[i], {r[i],c[i]}});\n     }\n\n     long long ans = 0;\n     while(!global.empty())\n     {\n          pair<int, pair<int,int>> node = *global.rbegin();\n\n          global.erase(global.find(node));\n          st[1][node.second.first].erase(st[1][node.second.first].find(node.first));\n          st[2][node.second.second].erase(st[2][node.second.second].find(node.first));\n\n          if (ob[1][node.second.first] && ob[2][node.second.second])\n              continue;\n          else\n            ans+=node.first;\n\n          if (ob[1][node.second.first] && !ob[2][node.second.second])\n              ob[2][node.second.second] = 1;\n           else\n            if (!ob[1][node.second.first] && ob[2][node.second.second])\n                ob[1][node.second.first] = 1;\n           else\n           {\n               int val1 = *st[1][node.second.first].rbegin();\n               int val2 = *st[2][node.second.second].rbegin();\n\n               if (val2>=val1)\n                 ob[1][node.second.first] = 1;\n               else\n                ob[2][node.second.second] = 1;\n           }\n     }\n\n     cout<<ans<<endl;\n    return 0;\n}\n//just a little magic\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\n#define rep(i,n) for(int i = 0; i < (n); i++)\nll dp[1000];\n\nint main(){\n    int n,h,w; cin >> n >> h >> w;\n    int r,c,a;\n    map<pair<int,int>,vector<int>> m;\n    rep(i,n){\n        cin >> r >> c >> a;\n        m[{r,c}].push_back(a);\n    }\n    vector<int> ans;\n    for(auto i:m){\n        if(i.second.size() >= 2){\n            sort(i.second.begin(),i.second.end(),greater<int>());\n            ans.push_back(i.second[0]);\n            ans.push_back(i.second[1]);\n        }else{\n            ans.push_back(i.second[0]);\n        }\n    }\n    sort(ans.begin(),ans.end(),greater<int>());\n    ll an = 0;\n    rep(i,h+w){\n        an += ans[i];\n    }\n    cout << an << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cassert>\n#include <vector>\n#include <utility>\n#include <string>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <numeric>\n#include <tuple>\n\nclass union_find {\n  mutable std::vector<intmax_t> c;\n\npublic:\n  union_find(size_t n): c(n, -1) {}\n\n  size_t find(size_t v) const {\n    if (c[v] < 0) return v;\n    return (c[v] = find(c[v]));\n  }\n\n  bool unite(size_t u, size_t v) {\n    u = find(u);\n    v = find(v);\n    if (u == v) return false;\n    if (-c[u] > -c[v]) std::swap(u, v);\n    c[v] += c[u];\n    c[u] = v;\n    return true;\n  }\n\n  bool connected(size_t u, size_t v) const { return (find(u) == find(v)); }\n\n  size_t size() const { return c.size(); }\n  size_t size(size_t v) const {\n    return -c[find(v)];\n  }\n};\n\nint main() {\n  size_t N, H, W;\n  scanf(\"%zu %zu %zu\", &N, &H, &W);\n\n  std::vector<std::tuple<intmax_t, size_t, size_t>> es;\n  es.reserve(N+N);\n  for (size_t i = 1; i <= N; ++i) {\n    size_t R, C;\n    intmax_t A;\n    scanf(\"%zu %zu %jd\", &R, &C, &A);\n    C += H;\n    es.emplace_back(A, R, H+W+i);\n    es.emplace_back(A, C, H+W+i);\n  }\n  std::sort(es.rbegin(), es.rend());\n\n  union_find uf(H+W+N+1);\n  intmax_t res = 0;\n  for (auto const& e: es) {\n    intmax_t A;\n    size_t u, v;\n    std::tie(A, u, v) = e;\n    if (uf.connected(0, v)) continue;\n    if (uf.connected(0, u)) continue;\n    res += A;\n    uf.unite(0, u);\n    uf.unite(u, v);\n  }\n  printf(\"%jd\\n\", res);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Benri {\n    Benri() {\n        std::cin.tie(0); ios::sync_with_stdio(false);\n        cout << fixed << setprecision(12);\n    }\n} benri;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b < a) { a = b; return 1; } return 0; }\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing pii = pair<int, int>;\nusing vll = vector<long long>;\nusing pll = pair<ll, ll>;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define mp make_pair\n#define F first\n#define S second\n#define MOD 1000000007\n#define MOD2 998244353\nconst int INF = 1 << 28;\n\n\n\nstruct Unionfind {\n    vector<int> par, num;\n    vector<bool> done;\n    Unionfind(int n): par(n), num(n, 1), done(n, false) {\n        iota(par.begin(), par.end(), 0);\n    }\n    int root(int v) {\n        return (par[v] == v) ? v : (par[v] = root(par[v]));\n    }\n    void unite(int u, int v) {\n        u = root(u), v = root(v);\n        if (u == v)return;\n        if (num[u] < num[v])swap(u, v);\n        num[u] += num[v];\n        par[v] = u;\n        done[u] = done[u] | done[v];\n    }\n    bool same(int u, int v) {\n        return root(u) == root(v);\n    }\n    bool ispar(int v) {\n        return v == root(v);\n    }\n    int size(int v) {\n        return num[root(v)];\n    }\n};\n\n\nstruct Edge {\n    int from, to; ll cost;\n    Edge(){}\n    Edge(int a, int b, ll c): from(a), to(b), cost(c) {}\n};\nbool comp(const Edge &e1, const Edge &e2) {\n    return e1.cost < e2.cost;\n}\n\nint E;\nvector<Edge> es(E);\n\n\nint main() {\n    int H, W; cin >> E >> H >> W;\n    rep(i, E) {\n        int r, c, a; cin >> r >> c >> a;\n        r--; c--;\n        es.pb(Edge(r, c + H, a));\n    }\n\n    ll ans = 0;\n    sort(all(es), comp);\n    reverse(all(es));\n    Unionfind tree(H + W);\n\n    rep(i, E) {\n        auto e = es[i];\n        if (!tree.same(e.from, e.to)) { //e.fromとe.toが異なる連結成分の場合\n            if (tree.done[tree.root(e.from)] && tree.done[tree.root(e.to)])continue; //二つともサイクルがある\n            tree.unite(e.from, e.to);\n            ans += e.cost;\n        }\n        else if (!tree.done[tree.root(e.from)]) { //同じ連結成分でまだサイクルが無い場合\n            tree.done[tree.root(e.from)] = true;\n            ans += e.cost;\n        }\n    }\n    cout << ans << endl;\n\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<set>\n#include<bitset>\n#include<ctime>\nusing namespace std;\n#define int long long\n#define mod 1000000009\n#define inf 4444444444444444444\n#define mn 200005\n#define pii pair <int, int>\n#define XX first\n#define YY second\n\nvector <int> alist[mn];\npair <int, pii> C[mn];\n\nint MX[mn], passed[mn];\nint switched[mn]; //switched[i] to see if we have altered i in the past. \n//If we did, and recursion reaches i, it should stop\nbool maxMatching(int u, int clr, int recurse)\n{\n\tif (passed[u]==clr) return 0;\n\tpassed[u]=clr;\n\tfor (int v:alist[u])\n\t{\n\t\tif (MX[v]==0) \n\t\t{\n\t\t\tMX[v]=u;\n\t\t\tif (recurse==1) switched[u]=1;\n\t\t\treturn 1;\n\t\t}\n\t\telse if (switched[MX[v]]==0)\n\t\t{\n\t\t\tif (maxMatching(MX[v], clr, 1)==1)\n\t\t\t{\n\t\t\t\tMX[v]=u;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nsigned main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tsrand(time(0));\n\t\n\tint n, h, w;\n\tcin>>n>>h>>w;\n\tint r, c, a;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tcin>>r>>c>>a;\n\t\tC[i]={a, {r, c}};\n\t}\n\tsort(C+1, C+n+1);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\talist[i].push_back(C[i].YY.XX);\n\t\talist[i].push_back(C[i].YY.YY+100000);\n\t\t\n\t\trandom_shuffle(alist[i].begin(), alist[i].end());\n\t}\n\t\n\tint ans=0;\n\tfor (int i=n; i>=1; i--) if (maxMatching(i, i, 0)) ans+=C[i].XX;\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (lli i = 0; i < (n); i++)\n#define rrep(i, n) for (lli i = (n)-1; i >= 0; i--)\nusing namespace std;\nusing lli = long long int;\nusing p = tuple<lli,lli,lli>;\n#define SIZE 200005\n#define UF_MAX 100005\nusing namespace std;\nstruct ufind {\n    vector<int> par;\n    vector<int> rank;\n    vector<int> count;\n    ufind(int n)\n    {\n        par.resize(n);\n        rank.resize(n);\n        count.resize(n);\n\n\n        rep(i, n)\n        {\n            par[i] = i;\n            rank[i] = 0;\n            count[i] = 1;\n        }\n    }\n    int find(int x)\n    {\n        if (par[x] == x) {\n            return x;\n        } else {\n            return par[x] = find(par[x]);\n        }\n    }\n    void unite(int x, int y)\n    {\n        x = find(x);\n        y = find(y);\n        if (x == y)\n            return;\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n        } else {\n            par[y] = x;\n            if (rank[x] == rank[y])\n                rank[x]++;\n        }\n    }\n    bool same(int x, int y)\n    {\n        return find(x) == find(y);\n    }\n};\n\n\n\n\nint used_c[100005] = {};\nint used_r[100005] = {};\nint main() {\n    int n,h,w;cin >> n >> h >> w;\n\n    ufind uf(n+10);\n    lli a,b,c;\n    vector<p> d(n);\n    rep(i,n){\n        cin >> a >> b >> c;\n        a--,b--;\n        d[i] = make_tuple(c,a,b);\n    }\n    sort(d.rbegin(),d.rend());\n    int ans = 0;\n    rep(i,n){\n        tie(c,a,b) = d[i];\n        if(used_r[a] && used_c[b]){\n            if(uf.same(used_r[a], used_c[b]))\n            continue;\n            uf.unite(i+1, used_r[a] );\n            uf.unite(i+1, used_c[b] );\n            ans += c;\n        }\n    }\n    cout << ans <<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define SIZE 300001\nclass unionfind\n{\npublic:\n\tint par[SIZE];\n\tint ran[SIZE];\n\tint ren[SIZE];\n\tvoid init()\n\t{\n\t\tfor (int i = 0; i<SIZE; i++)\n\t\t{\n\t\t\tpar[i] = i;\n\t\t\tran[i] = 0;\n\t\t\tren[i] = 1;\n\t\t}\n\t}\n\tint find(int a)\n\t{\n\t\tif (a == par[a])return a;\n\t\telse return par[a] = find(par[a]);\n\t}\n\tvoid unite(int a, int b)\n\t{\n\t\ta = find(a);\n\t\tb = find(b);\n\t\tif (a == b)return;\n\t\tif (ran[a]>ran[b])\n\t\t{\n\t\t\tpar[b] = a;\n\t\t\tren[a] += ren[b];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tpar[a] = b;\n\t\t\tren[b] += ren[a];\n\t\t}\n\t\tif (ran[a] == ran[b])ran[b]++;\n\t}\n};\nunionfind uf;\ntypedef long long ll;\ntypedef pair<int, int>pii;\ntypedef pair<int, pii>pi3;\nint main()\n{\n\tint num, mx, my;\n\tscanf(\"%d%d%d\", &num, &mx, &my);\n\tvector<pi3>v;\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tint za, zb, zc;\n\t\tscanf(\"%d%d%d\", &za, &zb, &zc);\n\t\tza--, zb--;\n\t\tv.push_back(make_pair(zc, make_pair(za, zb)));\n\t}\n\tsort(v.begin(), v.end());\n\treverse(v.begin(), v.end());\n\tuf.init();\n\tll ans = 0;\n\tfor (int i = 0; i < num; i++)\n\t{\n\t\tint t = 0;\n\t\tint x = v[i].second.first, y = v[i].second.second;\n\t\tx = uf.find(x), y = uf.find(mx + y);\n\t\tif (x != y)t = uf.ren[x] + uf.ren[y];\n\t\telse t = uf.ren[x];\n\t\tif (t > 0)\n\t\t{\n\t\t\tans += v[i].first;\n\t\t\tuf.unite(x, y);\n\t\t\tx = uf.find(x);\n\t\t\tuf.ren[x]--;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ri register\n#define int long long\nusing namespace std; const int N=300010;\ninline int read()\n{\n   \tint s=0,w=1; ri char ch=getchar();\n   \twhile(ch<'0'||ch>'9') {if(ch=='-') w=-1; ch=getchar(); }\n   \twhile(ch>='0'&&ch<='9') s=s*10+ch-'0', ch=getchar();\n   \treturn s*w;\n}\nint book[N],n,H,W,f[N],res;\nstruct Node{ int u,v,w; }e[N];\ninline bool cp(Node x,Node y) { return x.w>y.w; }\ninline int Find(int x) { return f[x]^x?f[x]=Find(f[x]):x; }\nsigned main()\n{\n\tn=read(), H=read(), W=read();\n\tfor(ri int i=1;i<=n;i++) e[i].u=read(), e[i].v=read()+H, e[i].w=read();\n\tfor(ri int i=1;i<=H+W;i++) f[i]=i;\n\tsort(e+1,e+1+n,cp);\n\tfor(ri int i=1;i<=n;i++)\n\t{\n\t\tint fx=Find(e[i].u), fy=Find(e[i].v);\n\t\tif(fx==fy)\n\t\t{\n\t\t\tif(book[fx]) continue;\n\t\t\tbook[fx]=1, res+=e[i].w;\n\t\t\tcontinue;\n\t\t}\n\t\tif(book[fx] && book[fy]) continue;\n\t\tbook[fx]|=book[fy], f[fy]=fx, res+=e[i].w;\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 100000\n#define LL long long\nint n,h,w;LL ans;\nstruct edge{\n\tint u,v,w;\n}e[MAXN+1];\nint fa[MAXN*2+1],siz[MAXN*2+1],used[MAXN*2+1];\nint read(){\n\tint x=0,F=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')F=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n\treturn x*F;\n}\nbool cmp(edge s1,edge s2){\n\treturn s1.w>s2.w;\n}\nint xfind(int x){\n\tif(fa[x]==x)return x;\n\treturn fa[x]=xfind(fa[x]);\n}\nint main()\n{\n\tn=read(),h=read(),w=read();\n\tfor(int i=1;i<=n;i++)\n\te[i]=(edge){read(),read()+MAXN,read()};\n\tfor(int i=1;i<=MAXN*2;i++)fa[i]=i,siz[i]=1;\n\tsort(e+1,e+n+1,cmp);\n\tfor(int i=1;i<=n;i++){\n\t\tint a=xfind(e[i].u),b=xfind(e[i].v);\n\t\tif(a==b){\n\t\t\tif(siz[a]>=used[a]+1){\n\t\t\t\tused[a]++;\n\t\t\t\tans+=e[i].w;\n\t\t\t}\n\t\t}else{\n\t\t\tif(siz[a]+siz[b]>=used[a]+used[b]+1){\n\t\t\t\tused[a]++;\n\t\t\t\tans+=e[i].w;\n\t\t\t}\n\t\t\tused[a]+=used[b];\n\t\t\tsiz[a]+=siz[b];\n\t\t\tfa[b]=a;\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<fstream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<map>\n#include<set>\n#include<bitset>\n#include<ctime>\nusing namespace std;\n#define int long long\n#define mod 1000000009\n#define inf 4444444444444444444\n#define mn 200005\n#define pii pair <int, int>\n#define XX first\n#define YY second\n\nvector <int> alist[mn];\npair <int, pii> C[mn];\n\nint MX[mn], passed[mn];\nint switched[mn]; //switched[i] to see if we have altered i in the past. \n//If we did, and recursion reaches i, it should stop\nbool maxMatching(int u, int clr, int recurse)\n{\n\tif (passed[u]==clr) return 0;\n\tpassed[u]=clr;\n\tfor (int v:alist[u])\n\t{\n\t\tif (MX[v]==0) \n\t\t{\n\t\t\tMX[v]=u;\n\t\t\tif (recurse==1) switched[u]=1;\n\t\t\treturn 1;\n\t\t}\n\t\telse if (switched[MX[v]]==0)\n\t\t{\n\t\t\tif (maxMatching(MX[v], clr, 1)==1)\n\t\t\t{\n\t\t\t\tMX[v]=u;\n\t\t\t\tif (recurse==1) switched[u]=1;\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nsigned main()\n{\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout.tie(0);\n\tsrand(time(0));\n\t\n\tint n, h, w;\n\tcin>>n>>h>>w;\n\tint r, c, a;\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tcin>>r>>c>>a;\n\t\tC[i]={a, {r, c}};\n\t}\n\tsort(C+1, C+n+1);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\talist[i].push_back(C[i].YY.XX);\n\t\talist[i].push_back(C[i].YY.YY+100000);\n\t\t\n\t\trandom_shuffle(alist[i].begin(), alist[i].end());\n\t}\n\t\n\tint ans=0;\n\tfor (int i=n; i>=1; i--) if (maxMatching(i, i, 0)) ans+=C[i].XX;\n\tcout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n#ifdef zxc\n\n#include <sys/resource.h>\n#include \"debug.h\"\n\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nusing ll = int64_t;\nusing ld = long double;\nconst ld EPS = 1e-9;\n//const ll MOD = 924844033;\nconst ld PI = 3.141592653589793;\nconst int maxn = 300001;\nconst ll MOD = 1e9 + 7;\n\nvoid fast_io() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n}\n\nll pw(ll a, ll b) {\n    ll res = 1;\n    for (; b; b >>= 1) {\n        if (b & 1) {\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n    }\n    return res;\n}\n\nint used[maxn];\nint mt[maxn];\nint a[maxn];\narray<int, 2> g[maxn];\n\nint kuhn(int v, int i) {\n    if (used[v] == i) {\n        return 0;\n    }\n    used[v] = i;\n    for (int to:g[v]) {\n        if (mt[to] == -1) {\n            mt[to] = v;\n            return 1;\n        }\n    }\n    for (int to:g[v]) {\n        if (kuhn(mt[to], i)) {\n            mt[to] = v;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nll weight_match(int n, int m, vector<int> order) {\n    ll ans = 0;\n    fill(mt, mt + m, -1);\n    int z = 1;\n    for (int v:order) {\n        if (kuhn(v, z)) {\n            ++z;\n            ans += a[v];\n        }\n    }\n    return ans;\n}\n\nsigned main() {\n#ifdef zxc\n    struct rlimit rl;\n    const rlim_t kStackSize = 512L * 1024L * 1024L;\n    assert(!getrlimit(RLIMIT_STACK, &rl));\n    rl.rlim_cur = kStackSize;\n    assert(!setrlimit(RLIMIT_STACK, &rl));\n    freopen(\"../kolya_input.txt\", \"r\", stdin);\n//    freopen(\"../kolya_output.txt\", \"w\", stdout);\n#else\n    //    mt19937 mt(std::chrono::high_resolution_clock::now().time_since_epoch().count());\n    //            freopen(\"\", \"r\", stdin);\n    //        freopen(\"hack.out\", \"w\", stdout);\n#endif\n    auto solve = [](int _) {\n        int n, h, w;\n        cin >> n >> h >> w;\n        mt19937 mt(123);\n        vector<int> r(n), c(n);\n        for (int i = 1; i <= n; ++i) {\n            for (auto x:{r.data(), c.data(), a}) {\n                cin >> x[i - 1];\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            g[i][0] = r[i] - 1;\n            g[i][1] = c[i] + h - 1;\n            shuffle(g[i].begin(), g[i].end(), mt);\n        }\n        vector<int> p(n);\n        iota(p.begin(), p.end(), 0);\n        sort(p.begin(), p.end(), [&](int x, int y) {\n            return a[x] > a[y];\n        });\n        auto ans = weight_match(n, h + w, p);\n        cout << ans;\n    };\n\n\n    fast_io();\n    cout.precision(9);\n    cout << fixed;\n    auto start = chrono::steady_clock::now();\n    for (int i = 1; i <= 1; ++i)solve(i);\n    auto end = chrono::steady_clock::now();\n\n    debug(\"time\", chrono::duration_cast<chrono::milliseconds>(end - start).count() / 1000.0);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <stack>\n#include <queue>\n#include <list>\n#include <bitset>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <numeric>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <chrono>\n#include <random>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n\nusing namespace std;\n\nclass DisjointSet {\n    public:\n        DisjointSet(int n) : N(n), sz(N), pars(N, -1) {\n\n        }\n\n        int find(int x) {\n            return pars[x] < 0 ? x : (pars[x] = find(pars[x]));\n        }\n\n        bool merge(int x, int y) {\n            x = find(x), y = find(y);\n            if (x == y) {\n                return false;\n            }\n            --sz;\n            if (pars[x] < pars[y]) {\n                swap(x, y);\n            }\n            pars[y] += pars[x];\n            pars[x] = y;\n            return true;\n            \n        }\n\n        int size() {\n            return sz;\n        }\n\n        int count(int x)  {\n            return - pars[find(x)];\n        }\n    private:\n        int N;\n        int sz;\n        vector<int> pars;\n};\n\nint main(int argc, char** argv) {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, h, w;\n    cin >> n >> h >> w;\n\n\n    int N = h + w;\n    vector<int> sz(N, 0);\n\n    DisjointSet ds(N);\n\n    long long res = 0;\n    vector<pair<int, pair<int,int>>> edges;\n\n    for (int i = 0; i < n; ++i) {\n        int r, c, w;\n        cin >> r >> c >> w;\n        --r, --c;\n        c += h;\n        edges.emplace_back(w, make_pair(r, c));\n    }\n\n    sort(edges.begin(), edges.end());\n    reverse(edges.begin(), edges.end());\n\n\n    for (auto& e : edges) {\n        int w = e.first;\n        int u = e.second.first;\n        int v = e.second.second;\n        u = ds.find(u);\n        v = ds.find(v);\n        if (u == v) {\n            if (sz[u] < ds.count(u)) {\n                ++sz[u];\n                ds.merge(u, v);\n                res += w;\n            }\n        } else {\n            if (sz[u] + sz[v] + 1 <= ds.count(u) + ds.count(v)) {\n                ds.merge(u, v);\n                int p = ds.find(u);\n                sz[p] = sz[u] + sz[v] + 1;\n                res += w;\n            }\n        }\n    }\n    cout << res << '\\n';\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int MAXN = 100000;\nstruct node{\n\tint R, C, A;\n\tfriend bool operator < (node a, node b) {\n\t\treturn a.A < b.A;\n\t}\n}nd[MAXN + 5];\nint fa[2*MAXN + 5], key[2*MAXN + 5], siz[2*MAXN + 5];\nint find(int x) {\n\treturn fa[x] = (fa[x] == x ? x : find(fa[x]));\n}\nint N, H, W;\nint main() {\n\tlong long ans = 0;\n\tscanf(\"%d%d%d\", &N, &H, &W);\n\tfor(int i=1;i<=H;i++) fa[i] = i, siz[i] = 1, key[i] = 0;\n\tfor(int i=1;i<=W;i++) fa[i + H] = i + H, siz[i + H] = 1, key[i + H] = 0;\n\tfor(int i=1;i<=N;i++)\n\t\tscanf(\"%d%d%d\", &nd[i].R, &nd[i].C, &nd[i].A);\n\tsort(nd + 1, nd + N + 1);\n\tfor(int i=N;i>=1;i--) {\n\t\tint fx = find(nd[i].R), fy = find(nd[i].C + H);\n\t\tif( fx == fy ) {\n\t\t\tif( siz[fx] >= key[fx] + 1 ) {\n\t\t\t\tkey[fx]++;\n\t\t\t\tans += nd[i].A;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif( siz[fx] + siz[fy] >= key[fx] + key[fy] + 1 ) {\n\t\t\t\tsiz[fx] += siz[fy], key[fx] += key[fy] + 1, fa[fy] = fx;\n\t\t\t\tans += nd[i].A;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "// verified at https://judge.yosupo.jp/submission/3400\n#ifndef Union_find_hpp\n#define Union_find_hpp\n\n#include <cassert>\n#include <cstddef>\n#include <vector>\n\nclass union_find\n{\n    std::vector<int> link;\n\npublic:\n    explicit union_find(const size_t n) : link(n, -1) {}\n\n    size_t find(size_t x)\n    {\n        assert(x < size());\n        while(link[x] >= 0)\n        {\n            if(link[link[x]] >= 0) link[x] = link[link[x]];\n            x = link[x];\n        }\n        return x;\n    }\n\n    size_t size() const { return link.size(); }\n\n    size_t size(const size_t x)\n    {\n        assert(x < size());\n        return -link[find(x)];\n    }\n\n    bool same(const size_t x, const size_t y)\n    {\n        assert(x < size() && y < size());\n        return find(x) == find(y);\n    }\n\n    bool unite(size_t x, size_t y)\n    {\n        assert(x < size() && y < size());\n        x = find(x), y = find(y);\n        if(x == y) return false;\n        if(link[x] > link[y]) std::swap(x, y);\n        link[x] += link[y];\n        link[y] = x;\n        return true;\n    }\n}; // class union_find\n\n#endif\n\n#include <iostream>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n    std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n\n    int n,h,w; cin>>n>>h>>w;\n    vector<vector<pair<int,int>>> cards(100000);\n    for(int i=n,r,c,a; i--; )\n    {\n        cin>>r>>c>>a; --r,--c;\n        cards[a].emplace_back(r,c+h);\n    }\n    union_find uf(h+w);\n    long long ans{};\n    vector<bool> ext(h+w);\n    for(int i=100000; i; --i)\n    {\n        for(auto&& e:cards[i])\n        {\n            int r,c; tie(r,c)=e;\n            int fr=uf.find(r),fc=uf.find(c);\n            if(fr!=fc)\n            {\n                if(ext[fr] and ext[fc]) continue;\n                bool extor=ext[fr]||ext[fc];\n                uf.unite(fr,fc);\n                ext[uf.find(fr)]=extor;\n                ans+=i;\n            }\n            else if(!ext[fr])\n            {\n                ext[fr]=true;\n                ans+=i;\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <chrono>\n#include <random>\n#include <algorithm>\n\nstd::mt19937 rng((int) std::chrono::steady_clock::now().time_since_epoch().count());\n\nstruct Card {\n\tint r, c, v;\n\tbool operator < (Card o) const { return v > o.v; }\n};\n\nint par[200200], size[200200];\nint getPar(int x) { return x == par[x] ? x : par[x] = getPar(par[x]); }\nbool makeUnion(int a, int b) {\n\ta = getPar(a);\n\tb = getPar(b);\n\tif(a == b) {\n\t\tif(size[a] == 0) {\n\t\t\tsize[a] = 1;\n\t\t\treturn true;\n\t\t}\n\t} else {\n\t\tif(size[a] + size[b] <= 1) {\n\t\t\tsize[a] += size[b];\n\t\t\tpar[b] = a;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\nint main() {\n\tstd::ios_base::sync_with_stdio(false); std::cin.tie(NULL);\n\tint n, r, c;\n\tstd::cin >> n >> r >> c;\n\tstd::vector<Card> cards(n);\n\tfor(auto &card : cards) {\n\t\tstd::cin >> card.r >> card.c >> card.v;\n\t\tcard.r--;\n\t\tcard.c--;\n\t}\n\tstd::sort(cards.begin(), cards.end());\n\tfor(int i = 0; i < r+c; i++) {\n\t\tpar[i] = i;\n\t\tsize[i] = 0;\n\t}\n\tlong long ans = 0;\n\tfor(auto card : cards) {\n\t\tbool valid = makeUnion(card.r, r + card.c);\n\t\tif(valid) {\n\t\t\t//std::cout << \"got card (\" << card.r << \", \" << card.c << \"), \" << card.v << std::endl;\n\t\t\tans += card.v;\n\t\t}\n\t}\n\tstd::cout << ans << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Card {\n  int row;\n  int col;\n  int value;\n};\n\nint main() {\n  int N, H, W;\n  cin >> N >> H >> W;\n  vector<int> parent(W + H + 1, -1);\n  vector<int> size(W + H + 1, 1);\n  vector<bool> saturated(W + H + 1);\n  vector<Card> cards;\n  for (int i = 1; i <= N; ++i) {\n    cards.emplace_back();\n    auto&& c = cards.back();\n    cin >> c.row >> c.col >> c.value;\n    c.col += H;\n  }\n  auto cmp = [](auto&& lhs, auto&& rhs) { return lhs.value > rhs.value; };\n  sort(cards.begin(), cards.end(), cmp);\n  int64_t result = 0;\n  for (auto&& card : cards) {\n    int root1 = card.row;\n    for (; parent[root1] != -1; root1 = parent[root1])\n      ;\n    int root2 = card.col;\n    for (; parent[root2] != -1; root2 = parent[root2])\n      ;\n    if (root1 == root2) {\n      if (saturated[root1]) {\n        continue;\n      }\n      saturated[root1] = true;\n    } else {\n      if (saturated[root1] && saturated[root2]) {\n        continue;\n      }\n      if (size[root1] < size[root2]) {\n        swap(root2, root1);\n      }\n      size[root1] += size[root2];\n      parent[root2] = root1;\n      saturated[root1] = saturated[root1] || saturated[root2];\n    }\n    result += card.value;\n  }\n  cout << result << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nstruct edge { int to, cap, rev; };\n\nvector<edge> G[300010];\nint level[300010];\nint iter[300010];\nint INF = 10000000;\n\nvoid add_edge(int from, int to, int cap) {\n\tG[from].push_back({ to, cap, (int)G[to].size() });\n\tG[to].push_back({ from, cap, (int)G[from].size() - 1 });\n}\n\nvoid add_multi_edge(int v1, int v2, int cap) {\n\tG[v1].push_back({ v2, cap, (int)G[v2].size() });\n\tG[v2].push_back({ v1, cap, (int)G[v1].size() - 1 });\n}\n\nvoid BFS(int S) {\n\tmemset(level, -1, sizeof(level));\n\tqueue<int> Q;\n\tlevel[S] = 0;\n\tQ.push(S);\n\twhile (!Q.empty()) {\n\t\tint V = Q.front(); Q.pop();\n\t\tfor (edge E : G[V]) {\n\t\t\tif (E.cap > 0 && level[E.to] < 0) {\n\t\t\t\tlevel[E.to] = level[V] + 1;\n\t\t\t\tQ.push(E.to);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint DFS(int V, int T, int F) {\n\tif (V == T) return F;\n\tfor (int& i = iter[V]; i < G[V].size(); i++) {\n\t\tedge& E = G[V][i];\n\t\tif (E.cap > 0 && level[V] < level[E.to]) {\n\t\t\tint D = DFS(E.to, T, min(F, E.cap));\n\t\t\tif (D > 0) {\n\t\t\t\tE.cap -= D;\n\t\t\t\tG[E.to][E.rev].cap += D;\n\t\t\t\treturn D;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}\n\nint max_flow(int S, int T) {\n\tint flow = 0;\n\twhile (1) {\n\t\tBFS(S);\n\t\tif (level[T] < 0) return flow;\n\t\tmemset(iter, 0, sizeof(iter));\n\t\tint F;\n\t\twhile ((F = DFS(S, T, INF)) > 0) {\n\t\t\tflow += F;\n\t\t}\n\t}\n}\n\nint main() {\n\tlong long N, H, W;\n\tcin >> N >> H >> W;\n\tfor (int i = 0; i < N; i++) {\n\t\tlong long R, C, A;\n\t\tcin >> R >> C >> A;\n\t\tadd_edge(R + 100000, i, A);\n\t\tadd_edge(C + 200000, i, A);\n\t}\n\tfor (int i = 0; i < 100000; i++) {\n\t\tadd_edge(300000, i + 100000, INF);\n\t\tadd_edge(300000, i + 200000, INF);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tadd_edge(i, 300001, INF);\n\t}\n\tcout << max_flow(300000, 300001);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\ntypedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){ll i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\nstruct node{\n  int pr;\n  int ed;\n  int size;\n  node(int pr=-1,int ed=0,int size=1):pr(pr),ed(ed),size(size){}\n};\n\nint parent(vector<node> &m,int u){return m[u].pr==-1?u:parent(m,m[u].pr);}\n\nint add_edge(vector<node> &m,int u,int v){\n  int ret=0;\n  u=parent(m,u);\n  v=parent(m,v);\n  if(u==v){m[u].ed++; return m[u].ed<=m[u].size?1:0;}\n  if(m[u].size<m[v].size){swap(u,v);}\n  auto &U=m[u];\n  auto &V=m[v];\n  ret-=min(U.size,U.ed)+min(V.size,V.ed);\n  U.size+=V.size;\n  U.ed+=V.ed+1;\n  V.pr=u;\n  ret+=min(U.size,U.ed);\n  return ret;\n}\n\nint main(){\n  typedef pair<ll,pll> card;\n\n  ll N,H,W;\n  cin>>N>>H>>W;\n  vector<card> A(N);\n  for(auto &I:A){cin>>I.S>>I.F; I.S.F--; I.S.S--;}\n  vector<node> uft(H+W,node());\n  sort(A.begin(),A.end(),greater<card>());\n  ll ans=0;\n  for(ll i=0;i<N;i++){\n    ans+=A[i].F*add_edge(uft,A[i].S.F,A[i].S.S+H);\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct uftree{\n\tint par[200005];\n\tint rank[200005];\n\tint cnt[200005];\n\tint sz[200005];\n\tuftree(){\n\t}\n\tvoid init(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tpar[i]=i;\n\t\t\trank[i]=0;\n\t\t\tcnt[i]=0;\n\t\t\tsz[i]=1;\n\t\t}\n\t}\n\tint find(int x){\n\t\tif(par[x]==x)return x;\n\t\treturn par[x]=find(par[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(x==y)return;\n\t\tif(rank[x]<rank[y]){\n\t\t\tpar[x]=y;\n\t\t\tcnt[y]+=cnt[x];\n\t\t\tsz[y]+=sz[x];\n\t\t}else{\n\t\t\tif(rank[x]==rank[y])rank[x]++;\n\t\t\tpar[y]=x;\n\t\t\tcnt[x]+=cnt[y];\n\t\t\tsz[x]+=sz[y];\n\t\t}\n\t}\n\n\tbool same(int x,int y){\n\t\treturn find(x)==find(y);\n\t}\n};\n\nstruct edge{\n\tint f,t,w;\n\tedge(){}\n\tedge(int ff,int tt,int ww){\n\t\tf=ff;\n\t\tt=tt;\n\t\tw=ww;\n\t}\n\tbool operator<(const edge &e)const{\n\t\treturn w>e.w;\n\t}\n};\n\nuftree uf;\nint n,h,w;\nedge e[100005];\n\nint main(void){\n\tscanf(\"%d%d%d\",&n,&h,&w);\n\tuf.init(h+w);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d%d%d\",&e[i].f,&e[i].t,&e[i].w);\n\t\te[i].f--;\n\t\te[i].t--;\n\t\te[i].t+=h;\n\t}\n\tsort(e,e+n);\n\tll ans=0;\n\tfor(int i=0;i<n;i++){\n\t\tint f=uf.find(e[i].f);\n\t\tint t=uf.find(e[i].t);\n\t\tif(f==t){\n\t\t\tif(uf.cnt[f]-uf.sz[f]>=0){\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tuf.cnt[f]++;\n\t\t\t\tans+=e[i].w;\n\t\t\t}\n\t\t}else{\n\t\t\tif(uf.cnt[f]-uf.sz[f]+uf.cnt[t]-uf.sz[t]>=0){\n\t\t\t\tcontinue;\n\t\t\t}else{\n\t\t\t\tuf.unite(f,t);\n\t\t\t\tans+=e[i].w;\n\t\t\t\tuf.cnt[uf.find(f)]++;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\nconst int MAXN = 1.1e5;\nint N, H, W;\npair<int, pair<int, int>> E[MAXN];\n\nconst int MAXV = 2.1e5;\nint V;\nint par[MAXV];\nint cnt[MAXV];\nint sz[MAXV];\n\nint getpar(int a) {\n\treturn par[a] == -1 ? a : (par[a] = getpar(par[a]));\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> N >> H >> W;\n\tfor (int e = 0; e < N; e++) {\n\t\tint r, c, a; cin >> r >> c >> a; r--, c--;\n\t\tE[e] = {a, {r, H+c}};\n\t}\n\tsort(E, E + N);\n\treverse(E, E + N);\n\n\tV = H + W;\n\tfor (int v = 0; v < V; v++) {\n\t\tpar[v] = -1;\n\t\tcnt[v] = 0;\n\t\tsz[v] = 1;\n\t}\n\tll ans = 0;\n\tauto isGood = [&](int a, int b) -> bool {\n\t\ta = getpar(a);\n\t\tb = getpar(b);\n\t\tif (a == b) {\n\t\t\tif (cnt[a] == sz[a]) return false;\n\t\t\tcnt[a]++;\n\t\t\treturn true;\n\t\t}\n\t\tif (sz[a] + sz[b] == cnt[a] + cnt[b]) return false;\n\t\tif (sz[a] > sz[b]) swap(a, b);\n\t\tsz[b] += sz[a];\n\t\tcnt[b] += cnt[a] + 1;\n\t\tpar[a] = b;\n\t\treturn true;\n\t};\n\tfor (int e = 0; e < N; e++) {\n\t\tif (isGood(E[e].second.first, E[e].second.second)) {\n\t\t\tans += E[e].first;\n\t\t}\n\t}\n\n\tcout << ans << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,h,w;\nint a[100005],xx[100005],yy[100005];\nmultiset<pair<int,pair<int,int> > >S;\nvector<int>g[2][100005];\nstruct ssss{\n\tint par[200005];\n\tssss(){for(int i=1;i<=200002;i++)par[i]=i;}\n\tint find(int x){\n\t\treturn par[x]==x?x:par[x]=find(par[x]);\n\t}\n\tvoid merge(int x,int y){\n\t\tint nx=find(x),ny=find(y);\n\t\tpar[nx]=ny;\n\t}\n}uf;\nbool dead[2][100005];\n#define kill ffweifnweoifnweoif\nvoid kill(int op,int x){\n//\tcerr<<op<<\" \"<<x<<endl;\n\tdead[op][x]=1;\n\tfor(int i=0;i<g[op][x].size();i++){\n\t\tif(dead[op^1][g[op][x][i]])continue;\n\t\tkill(op^1,g[op][x][i]);\n\t}\n}\nbool can(int x,int y,int v){\n\tif(dead[0][x]&&dead[1][y])return false;\n\tif(dead[0][x]){\n\t\tdead[1][y]=1;\n\t\treturn true;\n\t}\n\tif(dead[1][y]){\n\t\tdead[0][x]=1;\n\t\treturn true;\n\t}\n\tif(uf.find(x)==uf.find(y+1e5)){\n\t\tkill(0,x);\n\t}else{\n\t\tg[0][x].push_back(y);\n\t\tg[1][y].push_back(x);\n\t\tuf.merge(x,y+1e5);\n\t}\n\treturn true;\n}\nsigned main(){\n\tcin>>n>>h>>w;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>xx[i]>>yy[i]>>a[i];\n\t\tS.insert(make_pair(-a[i],make_pair(xx[i],yy[i])));\n\t}\n\tint ans=0;\n\twhile(!S.empty()){\n\t\tif(can(S.begin()->second.first,S.begin()->second.second,-S.begin()->first)){\n\t\t\tans-=S.begin()->first;\n\t\t}\n\t\tS.erase(S.begin());\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define forn(i, n) for (int i = 0; i < (int)(n); ++i)\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\nint n, h, w;\nint a[100005], r[100005], c[100005];\nint d[200005], ord[100005];\n\ninline bool cmp(const int &lhs, const int &rhs) {\n    return a[lhs] > a[rhs];\n}\n\nint main() {\n    scanf(\"%d%d%d\", &n, &h, &w);\n    forn(i, n) {\n        scanf(\"%d%d%d\", r + i, c + i, a + i);\n        --r[i], --c[i];\n        c[i] += h;\n        ord[i] = i;\n    }\n    memset(d, -1, sizeof d);\n    sort(ord, ord + n, cmp);\n    LL ans = 0;\n    forn(ii, n) {\n        int i = ord[ii];\n        int cur = r[i];\n        vector<int> toDo;\n        while (d[cur] >= 0) {\n            int ncur = d[cur];\n            toDo.pb(cur);\n            d[cur] = -2;\n            cur = ncur;\n        }\n        if (d[cur] == -1) {\n            ans += a[i];\n            d[cur] = c[i];\n            for (int x : toDo) {\n                d[x] = c[i];\n            }\n            continue;\n        }\n\n        toDo.clear();\n        cur = c[i];\n        while (d[cur] >= 0) {\n            int ncur = d[cur];\n            toDo.pb(cur);\n            d[cur] = -2;\n            cur = ncur;\n        }\n        if (d[cur] == -1) {\n            ans += a[i];\n            for (int x : toDo) {\n                d[x] = r[i];\n            }\n            d[cur] = r[i];\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define DEBUG\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp> \n#include <ext/pb_ds/tree_policy.hpp> \nusing namespace __gnu_pbds; \nusing namespace std;\n \n#define F first\n#define S second \n#define pb push_back\n#define endl \"\\n\"\n\n#define IOS { ios :: sync_with_stdio(false); cin.tie(0); cout.tie(0); }\n\n#ifdef DEBUG\n    #define dbg(s) {s;}\n#endif\n\n#ifndef DEBUG\n    #define dbg(s)\n#endif\n\nusing namespace std;\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\nint grand(int x) { // from [0, n-1]\n    return uniform_int_distribution<int>(0, x - 1)(rng);\n}\n\n#define int ll\n#define i32 int32_t\n\n#define RBTTYPE int\n#define ordered_set tree<RBTTYPE, null_type, less<RBTTYPE>, rb_tree_tag,tree_order_statistics_node_update> \n\n#define all(v) (v).begin(),(v).end()\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair< int, int > pii;\ntypedef pair< ll, ll > pll;\n\nint getInt () {\n    bool minus = false;\n    int result = 0;\n    char ch;\n    ch = getchar();\n    while (true) {\n        if (ch == '-') break;\n        if (ch >= '0' && ch <= '9') break;\n        ch = getchar();\n    }\n    if (ch == '-') minus = true; else result = ch-'0';\n    while (true) {\n        ch = getchar();\n        if (ch < '0' || ch > '9') break;\n        result = result*10 + (ch - '0');\n    }\n    if (minus)\n        return -result;\n    else\n        return result;\n}\n\n\nll gcd(ll x, ll y) {\n    if (x < y) return gcd(y, x);\n    if (y == 0) return x;\n    return gcd(y, x % y);\n} \n\nconst ll mod = 1e9 + 7;\n\nll modexp(ll x, ll ex) {\n    ll ans = 1ll;\n    while (ex > 0) {\n        if (ex & 1ll) ans = (ans * x) % mod;\n        ex >>= 1ll;\n        x = (x * x) % mod;\n    }\n    return ans;\n}\n\nconst int maxn = 1e6 + 7;\n\nconst ll inf = 1e9 + 7;\n\nvector < pair<int, pii> > v;\nint dsu[maxn];\nint vert[maxn];\nint ed[maxn];\n\nvoid _union(int x, int y) {\n    dsu[x] = y;\n    ed[y] += ed[x];\n    vert[y] += vert[x];\n}\n\nint _find(int x) {\n    if (dsu[x] < 0) return x;\n    return (dsu[x] = _find(dsu[x]));\n}\n\ni32 main() {\n    //freopen(\"<file>.in\", \"r\", stdin);\n    //freopen(\"<file>.out\", \"w\", stdout);\n\n    IOS;\n\n    int n, h, w; cin >> n >> h >> w;\n    for (int i = 1; i <= n; i++) {\n        int r, c, a; cin >> r >> c >> a;\n        v.pb({a, {r, c + h}});\n    }\n\n    sort(v.begin(), v.end()); reverse(all(v));\n\n    fill(dsu, dsu + maxn, -1); fill(vert, vert + maxn, 1);\n    fill(ed, ed + maxn, 0);\n\n    int ans = 0;\n\n    for (auto z : v) {\n        int w = z.F, x = z.S.F, y = z.S.S;\n    \n        //cout << w << \" : \" << x << \" -- \" << y << endl;\n\n        int a = _find(x), b = _find(y);\n        //cout << \"? : \" << a << \" -- \" << b << endl;\n        if (a == b) {\n            if (ed[a] < vert[a]) { ans += w; ed[a]++; }\n        } else if (ed[a] + ed[b] + 1 <= vert[a] + vert[b]) {\n            _union(a, b); ed[_find(a)]++; ans += w; \n        }\n    }\n\n    cout << ans << endl; \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Card {\n  int row;\n  int col;\n  int value;\n};\n\nint main() {\n  int N, H, W;\n  cin >> N >> H >> W;\n  vector<int> row_to_col(H + 1);\n  vector<int> col_to_row(W + 1);\n  auto cmp = [](auto&& lhs, auto&& rhs) { return lhs.value < rhs.value; };\n  priority_queue<Card, vector<Card>, decltype(cmp)> q{cmp};\n  for (int i = 1; i <= N; ++i) {\n    Card c;\n    cin >> c.row >> c.col >> c.value;\n    q.emplace(move(c));\n  }\n  int result = 0;\n  for (; !q.empty(); q.pop()) {\n    auto&& c = q.top();\n    auto& rc = row_to_col[c.row];\n    auto& cr = col_to_row[c.col];\n    if (rc == 0 && cr == 0) {\n      rc = c.col;\n      cr = c.row;\n      result += c.value;\n    } else if (rc == 0) {\n      rc = -1;\n      result += c.value;\n    } else if (cr == 0) {\n      cr = -1;\n      result += c.value;\n    } else if (rc == -1 && cr == -1) {\n    } else if (rc == -1) {\n      cr = -1;\n      result += c.value;\n    } else if (cr == -1) {\n      rc = -1;\n      result += c.value;\n    } else {\n      col_to_row[rc] = cr;\n      row_to_col[cr] = rc;\n      rc = cr = -1;\n      result += c.value;\n    }\n  }\n\n  cout << result << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define REP(i,x,y) for(ll i=x; i<=y; i++)\n#define BIT(t) ((long long 1) << t)\n#define PER(i,y,x) for(ll i=y; i>=x; i--)\n#define vll vector<ll>\n#define vvll vector<vector<ll>>\nusing namespace std;\ntypedef long long ll;\n\nll const MAX = 2e5 + 5;\n\nstruct unionfind {\n       ll max_un;\n       vector<ll> parent;\n       vector<ll> components;\n       vector<bool> flag; \n       unionfind(ll n) {\n               max_un = n;\n               parent = vector<ll>(n + 1);\n               components = vector<ll>(n + 1);\n               flag = vector<bool>(n+1, 0);\n               for (int i = 0; i <= n; i++) {\n                       parent[i] = i;\n                       components[i] = 1;\n               }\n               \n       }\n       ll find(ll x) {\n               if (parent[x] == x) {\n                       return x;\n               }\n               else {\n                       parent[x] = find(parent[x]);\n                       return parent[x];\n               }\n       }\n       bool same(ll x, ll y) {\n               return find(x) == find(y);\n       }\n       ll comp(ll x) {\n               return components[find(x)];\n       }\n       void unite(ll x, ll y) {\n               if (!same(x, y)) {\n                       x = parent[x];\n                       y = parent[y];\n                       if (components[x] <= components[y]) {\n                               parent[x] = y;\n                               components[y] += components[x];\n                       }\n                       else {\n                               parent[y] = x;\n                               components[x] += components[y];\n                       }\n               }\n               flag[x] = flag[y] = flag[x] | flag[y];\n       }\n       void roop(ll x){\n               flag[find(x)] = 1;\n       }\n       bool getflag(ll x){\n               return flag[find(x)];\n       }\n};\n\nunionfind un(MAX);\nstruct edge\n{\n       ll f; ll t; ll val;\n       bool operator<(const edge& rhs) const {\n                return val < rhs.val;\n       }\n};\n\npriority_queue<edge> pq;\n\nint main(){\n        ll n, h, w;\n        cin >> n >> h >> w;\n        REP(i,1,n){\n                ll r,c,a;\n                cin >> r >> c >> a;\n                c += h;\n                pq.push({r,c,a});      \n        }\n        ll cnt = 0;\n        ll ans = 0;\n        while(cnt < 2 * n && !pq.empty()){\n                edge e = pq.top();\n                pq.pop();\n                if(un.same(e.t, e.f) && !un.getflag(e.t)){\n                        un.roop(e.t);\n                        ans += e.val;\n                }else if(!un.same(e.t, e.f) && !(un.getflag(e.t) && un.getflag(e.f))){\n                        un.unite(e.t, e.f);\n                        ans += e.val;\n                }\n        }\n        cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int L = 2e5+10;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> card;\n\nint root[L], folga[L];\n\nint find(int a){\n\tif(root[a] == a) return a;\n\treturn root[a] = find(root[a]);\n}\n\nbool join(int a, int b){\n\ta = find(a);\n\tb = find(b);\n\n\tif(folga[a] + folga[b]){\n\t\tif(a != b) folga[a] += folga[b];\n\t\tfolga[a]--;\n\t\troot[b] = a;\n\t\treturn 1;\n\t}\n\n\treturn 0;\n}\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint N, H, W;\n\tcin >> N >> H >> W;\n\n\tfor(int i=0; i<H+W; i++){\n\t\tfolga[i] = 1;\n\t\troot[i] = i;\n\t}\n\n\tvector<card> C(N);\n\tfor(int i=0; i<N; i++){\n\t\tcin >> C[i].second.first >> C[i].second.second >> C[i].first;\n\t\tC[i].second.second += H;\n\t}\n\tsort(C.begin(), C.end());\n\n\tll ans = 0;\n\tfor(int i=N-1; i>=0; i--){\n\t\tif(join(C[i].second.first, C[i].second.second))\n\t\t\tans += C[i].first;\n\t}\n\n\tcout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\n#define int long long\nusing namespace std;\nconst int N = 1e5 + 5;\n\nint n, w, h;\nstruct edge { int u, v, w; } e[N];\nint fa[N << 1];\nbool ring[N << 1];\n\nint find(int x) {\n    return x == fa[x] ? x : fa[x] = find(fa[x]);\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> w >> h;\n    for (int i = 1; i <= w + h; i++)\n        fa[i] = i, ring[i] = false;\n    for (int i = 1; i <= n; i++)\n        cin >> e[i].u >> e[i].v >> e[i].w;\n    \n    sort(e + 1, e + 1 + n, [](const edge& x, const edge& y) {\n        return x.w > y.w;\n    });\n\n    long long ans = 0ll;\n    for (int i = 1; i <= n; i++) {\n        int u = e[i].u, v = e[i].v + h, w = e[i].w;\n        u = find(u), v = find(v);\n\n        if (u == v) {\n            if (!ring[u]) ring[u] = 1, ans += w;\n        } else {\n            if (!ring[u] || !ring[v]) {\n                ring[u] = ring[v] = ring[u] | ring[v];\n                fa[u] = v, ans += w;\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define LOCAL\n#define _USE_MATH_DEFINES\n#include <array>\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <complex>\n#include <cmath>\n#include <numeric>\n#include <bitset>\n#include <functional>\n#include <random>\n#include <ctime>\n\nusing namespace std;\n\ntemplate <typename A, typename B>\nostream& operator <<(ostream& out, const pair<A, B>& a) {\n  out << \"(\" << a.first << \",\" << a.second << \")\";\n  return out;\n}\ntemplate <typename T, size_t N>\nostream& operator <<(ostream& out, const array<T, N>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T>\nostream& operator <<(ostream& out, const vector<T>& a) {\n  out << \"[\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"]\";\n  return out;\n}\ntemplate <typename T, class Cmp>\nostream& operator <<(ostream& out, const set<T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& v : a) { out << (first ? \"\" : \", \"); out << v; first = 0;} out << \"}\";\n  return out;\n}\ntemplate <typename U, typename T, class Cmp>\nostream& operator <<(ostream& out, const map<U, T, Cmp>& a) {\n  out << \"{\"; bool first = true;\n  for (auto& p : a) { out << (first ? \"\" : \", \"); out << p.first << \":\" << p.second; first = 0;} out << \"}\";\n  return out;\n}\n#ifdef LOCAL\n#define trace(...) __f(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define trace(...) 42\n#endif\ntemplate <typename Arg1>\nvoid __f(const char* name, Arg1&& arg1){\n  cerr << name << \": \" << arg1 << endl;\n}\ntemplate <typename Arg1, typename... Args>\nvoid __f(const char* names, Arg1&& arg1, Args&&... args){\n  const char* comma = strchr(names + 1, ',');\n  cerr.write(names, comma - names) << \": \" << arg1 << \" |\";\n  __f(comma + 1, args...);\n}\n\ntypedef long long int64;\ntypedef pair<int, int> ii;\nconst int INF = 1 << 29;\nconst int MOD = 1e9 + 7;\nmt19937 mrand(random_device{}());\nint rnd(int x) { return mrand() % x; }\n\nstruct fast_ios {\n  fast_ios() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n  };\n} fast_ios_;\n\nconst int N = 2e5 + 10;\nint f[N], e[N];\nint find(int x) {\n  if (f[x] != f[f[x]]) f[x] = find(f[x]);\n  return f[x];\n}\n\nint main() {\n  int len, n, m;\n  scanf(\"%d%d%d\", &len, &n, &m);\n  vector<array<int, 3>> a(len);\n  for (int i = 0; i < len; ++i) {\n    int x, y, v;\n    scanf(\"%d%d%d\", &x, &y, &v);\n    --x; --y;\n    a[i] = {v, x, y + n};\n  }\n  for (int i = 0; i < n + m; ++i) {\n    f[i] = i;\n    e[i] = 1;\n  }\n  sort(a.begin(), a.end());\n  int64 ret = 0;\n  for (int i = len - 1; i >= 0; --i) {\n    int x = a[i][1], y = a[i][2];\n    int rx = find(x), ry = find(y);\n    if (rx != ry) {\n      if (e[rx] + e[ry] >= 1) {\n        f[ry] = rx;\n        e[rx] += e[ry] - 1;\n        ret += a[i][0];\n      }\n    } else {\n      if (e[rx] >= 1) {\n        e[rx] -= 1;\n        ret += a[i][0];\n      }\n    }\n  }\n  printf(\"%lld\\n\", ret);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n)  for(long long i=0;i<(long long)(n);i++)\n#define REP(i,k,n) for(long long i=k;i<(long long)(n);i++)\n#define all(a) a.begin(),a.end()\n#define pb emplace_back\n#define eb emplace_back\n#define lb(v,k) (lower_bound(all(v),k)-v.begin())\n#define ub(v,k) (upper_bound(all(v),k)-v.begin())\n#define fi first\n#define se second\n#define pi M_PI\n#define PQ(T) priority_queue<T>\n#define SPQ(T) priority_queue<T,vector<T>,greater<T>>\n#define dame(a) {out(a);return 0;}\n#define decimal cout<<fixed<<setprecision(15);\n#define dupli(a) a.erase(unique(all(a)),a.end())\ntypedef long long ll;\ntypedef pair<ll,ll> P;\ntypedef tuple<ll,ll,ll> PP;\ntypedef tuple<ll,ll,ll,ll> PPP;\ntypedef multiset<ll> S;\nusing vi=vector<ll>;\nusing vvi=vector<vi>;\nusing vvvi=vector<vvi>;\nusing vp=vector<P>;\nusing vvp=vector<vp>;\nusing vb=vector<bool>;\nusing vvb=vector<vb>;\nconst ll inf=1001001001001001001;\nconst int INF=1001001001;\nconst int mod=1000000007;\nconst double eps=1e-10;\ntemplate<class T> bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<class T> bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<class T> void out(T a){cout<<a<<'\\n';}\ntemplate<class T> void outp(T a){cout<<'('<<a.fi<<','<<a.se<<')'<<'\\n';}\ntemplate<class T> void outvp(T v){rep(i,v.size())cout<<'('<<v[i].fi<<','<<v[i].se<<')';cout<<'\\n';}\ntemplate<class T> void outvvp(T v){rep(i,v.size())outvp(v[i]);}\ntemplate<class T> void outv(T v){rep(i,v.size()){if(i)cout<<' ';cout<<v[i];}cout<<'\\n';}\ntemplate<class T> void outvv(T v){rep(i,v.size())outv(v[i]);}\ntemplate<class T> bool isin(T x,T l,T r){return (l)<=(x)&&(x)<=(r);}\ntemplate<class T> void yesno(T b){if(b)out(\"yes\");else out(\"no\");}\ntemplate<class T> void YesNo(T b){if(b)out(\"Yes\");else out(\"No\");}\ntemplate<class T> void YESNO(T b){if(b)out(\"YES\");else out(\"NO\");}\ntemplate<class T> void noyes(T b){if(b)out(\"no\");else out(\"yes\");}\ntemplate<class T> void NoYes(T b){if(b)out(\"No\");else out(\"Yes\");}\ntemplate<class T> void NOYES(T b){if(b)out(\"NO\");else out(\"YES\");}\nvoid outs(ll a,ll b){if(a>=inf-100)out(b);else out(a);}\nll gcd(ll a,ll b){if(b==0)return a;return gcd(b,a%b);}\nll modpow(ll a,ll b){a%=mod;if(b==0)return 1;if(b&1)return a*modpow(a,b-1)%mod;ll k=modpow(a,b/2);return k*k%mod;}\nvi parent,rankk,sz,num;\nvoid init(ll n){\n    parent=vi(n);\n    rankk=vi(n);\n    sz=vi(n,1);\n    num=vi(n);\n    rep(i,n)parent[i]=i;\n}\nll root(ll i){if(parent[i]==i)return i;return root(parent[i]);}\nll getsize(ll i){return sz[root(i)];}\nbool same(ll a,ll b){return root(a)==root(b);}\nbool heigou(ll x,ll y){\n    x=root(x);y=root(y);\n    if(x==y){\n        num[x]++;\n        return false;\n    }\n    if(rankk[x]<rankk[y]){parent[x]=y;sz[y]+=sz[x];num[y]+=num[x]+1;}\n    else{parent[y]=x;sz[x]+=sz[y];num[x]+=num[y]+1;}\n    if(rankk[x]==rankk[y])rankk[x]++;\n    return true;\n}\nint main(){\n    ll n,h,w;cin>>n>>h>>w;\n    vp hen(n),v(n);\n    rep(i,n){\n        ll r,c,a;cin>>r>>c>>a;r--;c--;\n        hen[i]=P(r,c+h);\n        v[i]=P(a,i);\n    }\n    sort(all(v));reverse(all(v));\n    init(h+w);\n    ll ans=0;\n    rep(i,n){\n        ll a=hen[v[i].se].fi,b=hen[v[i].se].se;\n        if(same(a,b)&&num[root(a)]==sz[root(b)])continue;\n        if((!same(a,b))&&num[root(a)]+num[root(b)]==sz[root(a)]+sz[root(b)])continue;\n        ans+=v[i].fi;\n        heigou(a,b);\n    }\n    out(ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge{\n\tint u,v,w;\n};\n\nlong long ans=0;\nint par[200005],ed[200005]={},sz[200005];\n\nint root(int u){\n\tif(par[u]!=u){\n\t\treturn par[u]=root(par[u]);\n\t}\n\treturn u;\n}\n\nvoid merge(int u, int v, int w){\n\tint ru=root(u),rv=root(v);\n\tif(ru==rv){\n\t\tif(sz[ru]>ed[ru]){\n\t\t\ted[ru]++;\n\t\t\tans+=w;\n\t\t}\n\t}\n\telse{\n\t\tif(sz[ru]+sz[rv]>ed[ru]+ed[rv]){\n\t\t\tif(sz[ru]>sz[rv]){\n\t\t\t\tpar[rv]=ru;\n\t\t\t\tsz[ru]+=sz[rv];\n\t\t\t\ted[ru]+=ed[rv]+1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpar[ru]=rv;\n\t\t\t\tsz[rv]+=sz[ru];\n\t\t\t\ted[rv]+=ed[ru]+1;\n\t\t\t}\n\t\t\tans+=w;\n\t\t}\n\t}\n}\n\nint main(){\n\tint p,h,w; cin >> p >> h >> w;\n\tfor(int i=0;i<h+w;i++){\n\t\tpar[i]=i;\n\t\tsz[i]=1;\n\t}\n\tvector <edge> e(p);\n\tfor(int i=0;i<p;i++){\n\t\tcin >> e[i].u >> e[i].v >> e[i].w;\n\t\te[i].u--;e[i].v--;\n\t}\n\tsort(e.begin(),e.end(),[](edge &a, edge &b){\n\t\treturn a.w>b.w;\n\t});\n\tfor(int i=0;i<p;i++){\n\t\tmerge(e[i].u,h+e[i].v,e[i].w);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>/*{{{*/\n#include<cctype>\n#include<cassert>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<ctime>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<vector>\nusing namespace std;\ntypedef long long lld;\ntypedef long double lf;\ntypedef unsigned long long uld;\ntypedef pair<int,int> pii;\n#define fi first\n#define se second\n#define pb push_back\n#define mk make_pair\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define ROF(i,a,b) for(int i=(a);i>=(b);--i)\nnamespace RA{\n    int r(int p){return 1ll*rand()*rand()%p;}\n    int r(int L,int R){return r(R-L+1)+L;}\n}\nnamespace IO{\n    char nc(){ static char bf[100000],*p1=bf,*p2=bf; return p1==p2&&(p2=(p1=bf)+ fread(bf,1,100000,stdin),p1==p2)?EOF:*p1++; }\n    int rd(){ int res=0; char c=getchar(); while(!isdigit(c))c=getchar(); while(isdigit(c))res=res*10+c-'0',c=getchar(); return res; }\n}/*}}}*/\n/******************heading******************/\nconst int N=2e5+50;\n\nint n,h,w;\n\nstruct edge{\n    int u,v,w;\n    bool operator<(edge e){ return w<e.w; }\n}e[N];\n\nint f[N],g[N];\nvoid init(int k){FOR(i,0,k)f[i]=i,g[i]=0;}\nint get(int u){return f[u]==u?u:f[u]=get(f[u]);}\nvoid merge(int u,int v){f[get(u)]=get(v);}\nbool find(int u,int v){return get(u)==get(v);}\nbool has_circle(int u){return g[get(u)];}\nvoid set_circle(int u){g[get(u)]=1;}\n\nlld ans;\n\nint main(){\n    scanf(\"%d%d%d\",&n,&h,&w);\n    init(h+w);\n    FOR(i,1,n){\n        int x,y,z;\n        scanf(\"%d%d%d\",&x,&y,&z);\n        e[i]=(edge){x,y+h,z};\n    }\n    sort(e+1,e+n+1);\n    ROF(i,n,1){\n        int u=e[i].u,v=e[i].v,w=e[i].w;\n        if(find(u,v)){\n            if(!has_circle(u)) ans+=w, set_circle(u);\n        }else{\n            if(has_circle(u)&&has_circle(v));\n            else if(has_circle(u)) ans+=w, merge(v,u);\n            else ans+=w, merge(u,v);\n        }\n    }\n    printf(\"%lld\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\n#define F first\n#define S second\n#define int long long\n//#define ll long long\n//#define int  unsigned long long\n#define pb push_back\n#define double long double\n\nusing namespace std;\nusing namespace __gnu_pbds;\ntypedef  tree< int , null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;\nconst int N = 1000000;\nstruct Edge {\n    int from, to, f, c, w;\n};\nvector < Edge >  edges;\nvector < int > g[N];\nint n, d[N], f[N];\nint p[N];\nvoid add(int a, int b, int c, int w){\n    Edge e;\n    e.from = a; e.to = b; e.c = c; e.w = w; e.f = 0;\n    edges.pb(e);\n    g[a].pb(edges.size() - 1);\n    e.w = -e.w; e.c = 0; swap(e.from, e.to);\n    edges.pb(e);\n    g[b].pb(edges.size() - 1);\n}\nbool spfa(int s, int t){\n    for (int i = 1; i <= n; i++){\n        d[i] = 1e9;\n        f[i] = 0;\n    }\n    queue < int > q;\n    q.push(s);\n    d[s] = 0;\n    f[s] = 1;\n    while(!q.empty()){\n        int v = q.front();\n        q.pop();\n        f[v] = 0;\n        for (int i = 0; i < g[v].size(); i++){\n            Edge e = edges[g[v][i]];\n            if (e.f < e.c && d[e.to] > d[v] + e.w){\n                p[e.to] = g[v][i];\n                d[e.to] = d[v] + e.w;\n                if (!f[e.to])\n                    q.push(e.to);\n                f[e.to] = 1;\n            }\n        }\n    }\n    return d[t] != 1e9;\n}\nint flow(int s, int t){\n    int cost = 0;\n    while(spfa(s, t)){\n        int v = t;\n        while(v != s && v != 0){\n            auto k = p[v];\n            edges[k].f++;\n            edges[k ^ 1].f--;\n            cost += edges[k].w;\n            v = edges[k].from;\n        }\n    }\n    return cost;\n}\nint mx[N], mn[N];\nmain()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    //freopen(\"input.txt\",  \"r\", stdin);\n    //freopen(\"output.txt\", \"w\", stdout);\n    int h, w, s, t;\n    cin >> n >> h >> w;\n    s = n + h + w + 1;\n    t = n + h + w + 2;\n    for (int i = 1; i <= h; i++){\n        add(s, i, 1, 0);\n    }\n    for (int i = 1; i <= w; i++){\n        add(s, i + h, 1, 0);\n    }\n    for (int i = 1; i <= n; i++){\n        int r, c, a;\n        cin >> r >> c >> a;\n        add(r, h + w + i, 1, -a);\n        add(s, h + w + i, 1, 0);\n        add(h + c, h + w + i, 1, -a);\n        add(h + w + i, t, 1, 0);\n    }\n    n = t;\n    cout << -flow(s, t);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\nconst ull mod = 1e9 + 7;\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\ntemplate<class S, class T> ostream& operator << (ostream& os, const pair<S, T> v){\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<T> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << \" \";} os << v[i];} return os;\n}\ntemplate<class T> ostream& operator << (ostream& os, const vector<vector<T>> v){\n  for(int i = 0; i < v.size(); i++){if(i > 0){os << endl;} os << v[i];} return os;\n}\n\nstruct edge{\n\tll R, C, A;\n\tbool operator<(const edge &right)const{\n\t\treturn A < right.A;\n\t}\n};\n\n// par[i]  は，iがrootなら-(連結成分のサイズ)を，iがrootではないならばrootを返す\n// root(x) は必ずroot を返す\nstruct UnionFindSize {\n    vector<int> par;\n    \n    UnionFindSize(int n) : par(n, -1) { }\n    void init(int n) { par.assign(n, -1); }\n    \n    int root(int x) {\n        if (par[x] < 0) return x;\n        else return par[x] = root(par[x]);\n    }\n    \n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n    \n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (par[x] > par[y]) swap(x, y); // merge technique\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n    \n    int size(int x) {\n        return -par[root(x)];\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll N, H, W;\n    cin >> N >> H >> W;\n\n    vector<edge> edges;\n\n    REP(i, N){\n    \tll R, C, A;\n    \tcin >> R >> C >> A;\n    \tR--, C--;\n    \tedges.push_back(edge{R, C, A});\n    }\n    sort(edges.rbegin(), edges.rend());\n\n    UnionFindSize uf(H+W);\n    vector<ll> cnt(H+W, 0);\n\n\n    ll res = 0;\n    REP(i, N){\n    \tll r1 = uf.root(edges[i].R);\n    \tll r2 = uf.root(H+edges[i].C);\n    \tll s1 = uf.size(r1);\n    \tll s2 = uf.size(r2);\n    \tll e1 = cnt[r1];\n    \tll e2 = cnt[r2];\n    \t\n    \tif(r1 == r2){\n    \t\tif(s1>e1){\n    \t\t\tres += edges[i].A;\n    \t\t\tcnt[r1]++;\n    \t\t}\n    \t}else{\n    \t\tif(s1+s2>e1+e2){\n    \t\t\tres += edges[i].A;\n    \t\t\tuf.merge(r1, r2);\n    \t\t\tcnt[uf.root(r1)] = e1+e2+1;\n    \t\t}\n    \t}\n    }\n\n    cout << res << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long llong;\n\nconst int maxn=2e5+10;\n\nclass card{\npublic:\n    int v,rw,cl;\n    card() {}\n    card(int v,int rw,int cl):v(v),rw(rw),cl(cl){}\n    bool operator < (const card &crd) const\n    {\n        return v>crd.v;\n    }\n\n};\n\nint N,H,W;\nvector<card> vec;\nvector<int> vr[maxn],vc[maxn];\nbool vstr[maxn],vstc[maxn];\n\nint main()\n{\n    cin>>N>>H>>W;\n    int R,C,A;\n    for(int i=0;i<N;i++)\n    {\n        cin>>R>>C>>A;\n        vr[R].push_back(A);\n        vc[C].push_back(A);\n        vec.push_back(card(A,R,C));\n\n    }\n    for(int i=1;i<=H;i++)\n       sort(vr[i].begin(),vr[i].end(),greater<int>());\n    for(int i=1;i<=W;i++)\n      sort(vc[i].begin(),vc[i].end(),greater<int>());\n    sort(vec.begin(),vec.end());\n\n    llong ans=0;\n    for(int i=0;i<N;i++)\n    {\n        if(vstr[vec[i].rw]&&vstc[vec[i].cl]) continue;\n        else if(vstr[vec[i].rw]&&!vstc[vec[i].cl]) {ans+=vec[i].v;vstc[vec[i].cl]=true;continue;}\n        else if(!vstr[vec[i].rw]&&vstc[vec[i].cl]) {ans+=vec[i].v;vstr[vec[i].rw]=true;continue;}\n        else{\n        int v=vec[i].v,rw=vec[i].rw,cl=vec[i].cl;\n        ans+=v;\n        if(vr[rw][0]!=v&&vc[cl][0]!=v) continue;\n        else if(vr[rw][0]==v&&vc[cl][0]!=v) vstr[rw]=true;\n        else if(vr[rw][0]!=v&&vc[cl][0]==v) vstc[cl]=true;\n        else\n        {\n            if(vr[rw].size()==1&&vc[cl].size()==1) {vstr[rw]=true;vstc[cl]=true;continue;}\n            else if(vr[rw].size()==1||(vc[cl].size()>1&&vr[rw][1]<vc[cl][1])) vstr[rw]=true;\n            else if(vc[cl].size()==1||(vr[rw].size()>1&&vr[rw][1]>=vc[cl][1]))vstc[cl]=true;\n        }\n    }\n    }\n    cout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long llong;\n\nconst int maxn=1e5+10;\n\nclass card{\npublic:\n    int v,rw,cl;\n    card() {}\n    card(int v,int rw,int cl):v(v),rw(rw),cl(cl){}\n    bool operator < (const card &crd) const\n    {\n        return v>crd.v;\n    }\n\n};\n\nint N,H,W;\nvector<card> vec;\nvector<int> vr[maxn],vc[maxn];\nbool vstr[maxn],vstc[maxn];\n\nint main()\n{\n    scanf(\"%d%d%d\",&N,&H,&W);\n    int R,C,A;\n    for(int i=0;i<N;i++)\n    {\n        scanf(\"%d%d%d\",&R,&C,&A);\n        vr[R].push_back(A);\n        vc[C].push_back(A);\n        vec.push_back(card(A,R,C));\n\n    }\n    for(int i=1;i<=H;i++)\n       sort(vr[i].begin(),vr[i].end(),greater<int>());\n    for(int i=1;i<=W;i++)\n      sort(vc[i].begin(),vc[i].end(),greater<int>());\n    sort(vec.begin(),vec.end());\n\n    llong ans=0;\n    for(int i=0;i<N;i++)\n    {\n        if(vstr[vec[i].rw]&&vstc[vec[i].cl]) continue;\n        if(vstr[vec[i].rw]&&!vstc[vec[i].cl]) {ans+=vec[i].v;vstc[vec[i].cl]=true;continue;}\n        if(!vstr[vec[i].rw]&&vstc[vec[i].cl]) {ans+=vec[i].v;vstr[vec[i].rw]=true;continue;}\n        int v=vec[i].v,rw=vec[i].rw,cl=vec[i].cl;\n        ans+=v;\n        if(vr[rw][0]!=v&&vc[cl][0]!=v) continue;\n        else if(vr[rw][0]==v&&vc[cl][0]!=v) vstr[rw]=true;\n        else if(vr[rw][0]!=v&&vc[cl][0]==v) vstc[cl]=true;\n        else\n        {\n            if(vr[rw].size()==1&&vc[cl].size()==1) {vstr[rw]=true;vstc[cl]=true;continue;}\n            else if(vr[rw].size()==1||(vc[cl].size()>1&&vr[rw][1]<vc[cl][1])) vstr[rw]=true;\n            else if(vc[cl].size()==1||(vr[rw].size()>1&&vr[rw][1]>=vc[cl][1]))vstc[cl]=true;\n        }\n    }\n    cout<<ans<<endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm> //STLÍ¨ÓÃËã·¨\n#include <cmath> //¶¨ÒåÊýÑ§º¯Êý\n#include <cstdio> //¶¨ÒåÊäÈë/Êä³öº¯Êý\n#include <iostream> //Êý¾ÝÁ÷ÊäÈë/Êä³ö\n#include <cstring> //×Ö·û´®´¦Àí\n#include <string> //×Ö·û´®Àà\n#include <ctime> //¶¨Òå¹ØÓÚÊ±¼äµÄº¯Êý\n#define itn int\n#define fro for\n#define ll long long\n#define reg register\n#define inf 1234567890\n#define rep(i,a,b,c) for (int i=a;i<=b;i+=c)\n/*#include <bitset> //STLÎ»¼¯ÈÝÆ÷\n#include <cstype> //×Ö·û´¦Àí\n#include <cerrno> //¶¨Òå´íÎóÂë\n#include <complex> //¸´ÊýÀà\n#include <clocale> //¶¨Òå±¾µØ»¯º¯Êý\n#include <cstdlib> //¶¨ÒåÔÓÏîº¯Êý¼°ÄÚ´æ·ÖÅäº¯Êý\n#include <deque> //STLË«¶Ë¶ÓÁÐÈÝÆ÷\n#include <exception> //Òì³£´¦ÀíÀà\n#include <fstream> //ÎÄ¼þÊäÈë/Êä³ö\n#include <functional> //STL¶¨ÒåÔËËãº¯Êý(´úÌæÔËËã·û)\n#include <limits> //¶¨Òå¸÷ÖÖÊý¾ÝÀàÐÍ×îÖµ³£Á¿\n#include <list> //STLÏßÐÔÁÐ±íÈÝÆ÷\n#include <map> //STLÓ³ÉäÈÝÆ÷\n#include <iomanip> //²ÎÊý»¯ÊäÈë/Êä³ö\n#include <ios> //»ù±¾ÊäÈë/Êä³öÖ§³Ö\n#include <iosfwd> //ÊäÈë/Êä³öÏµÍ³Ê¹ÓÃµÄÇ°ÖÃÉùÃ÷\n#include <istream> //»ù±¾ÊäÈëÁ÷\n#include <ostream> //»ù±¾Êä³öÁ÷\n#include <queue> //STL¶ÓÁÐÈÝÆ÷\n#include <set> //STL¼¯ºÏÈÝÆ÷\n#include <sstream> //»ùÓÚ×Ö·û´®µÄÁ÷\n#include <stack> //STL¶ÑÕ»ÈÝÆ÷\n#include <stdexcept> //±ê×¼Òì³£Àà\n#include <streambuf> //µ×²ãÊäÈë/Êä³öÖ§³Ö\n#include <utility> //STLÍ¨ÓÃÄ£°åÀà\n#include <vector> //STL¶¯Ì¬Êý×éÈÝÆ÷\n#include <cwchar.h>//¿í×Ö·û´¦Àí¼°ÊäÈë/Êä³ö\n#include <cwctype.h> //¿í×Ö·û·ÖÀà*/\n\nusing namespace std;\n\nint ans;\n\nint max(int x,int y){return x>y?x:y;}\n\nint min(int x,int y){return x<y?x:y;}\n\nint abs(int x){return x>0?x:-x;}\n\nint gcd(int x,int y){return (!y)?x:gcd(y,x%y);}\n\nvoid exgcd(int a,int b,int &d,int &x,int &y){if (!b){d=a,x=1,y=0;}else{exgcd(b,a%b,d,y,x);y-=x*(a/b);}}\n\nint quick_power(ll a,int b){ll r=1;for (;b;b>>=1,a=a*a)if (b&1) r=r*a;return r;}\n\ninline char read() {\n\tstatic const int IN_LEN = 1000000;\n\tstatic char buf[IN_LEN], *s, *t;\n\treturn (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);\n}\ntemplate<class T>\ninline void read(T &x) {\n\tstatic bool iosig;\n\tstatic char c;\n\tfor (iosig = false, c = read(); !isdigit(c); c = read()) {\n\t\tif (c == '-') iosig = true;\n\t\tif (c == -1) return;\n\t}\n\tfor (x = 0; isdigit(c); c = read()) x = x * 10 + (c ^ '0');\n\tif (iosig) x = -x;\n}\n\nchar sr[10000000],z[20];int C=-1,Z=0;\nvoid Ot(){fwrite(sr,1,C+1,stdout),C=-1;}\nvoid print(int x){\n\tif (x<0) sr[++C]='-',x=-x;\n    while(z[++Z]=x%10+48,x/=10);\n    while(sr[++C]=z[Z],--Z);sr[++C]='\\n';\n}\n\nconst int N=200200;\nint fa[N],size[N],key[N];\nstruct p\n{\n\tint x,y,v;\n} a[N];\n\nbool cmp(p x,p y)\n{\n\treturn x.v>y.v;\n}\n\nint find(int x){return fa[x]=fa[x]==x?x:find(fa[x]);}\n\n//void add(int x,int y,int z){to[++cnt]=y;v[cnt]=z;Next[cnt]=head[x];head[x]=cnt;}\nint main()\n{\n\tint n,h,w;\n\tread(n);read(h);read(w);\n\tfor (int i=1;i<=n;i++) read(a[i].x),read(a[i].y),a[i].y+=h,read(a[i].v);\n\tfor (int i=1;i<=h+w;i++) fa[i]=i,size[i]=1;\n\tsort(a+1,a+n+1,cmp);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint fx=find(a[i].x),fy=find(a[i].y);\n\t\tif (fx==fy)\n\t\t{\n\t\t\tif (size[fx]>=key[fx]+1)\n\t\t\t{\n\t\t\t\tkey[fx]++;\n\t\t\t\tans+=a[i].v;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (size[fx]+size[fy]>=key[fx]+key[fy]+1)\n\t\t\t{\n\t\t\t\tsize[fx]+=size[fy];\n\t\t\t\tkey[fx]+=key[fy]+1;\n\t\t\t\tfa[fy]=fx;\n\t\t\t\tans+=a[i].v;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl;\n#define mdebug(m) cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;}\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\nstruct UnionFind\n{\n    vector<int> par, sz;\n    int n_cc;\n    bools cycle;\n\n    UnionFind(int N){\n        par = vector<int>(N);\n        REP(i, N) par[i] = i;\n        sz = vector<int>(N, 1);\n        n_cc = N;\n\n        cycle = bools(N, false);\n    }\n\n    int find(int x){\n        if(par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y){\n            cycle[x] = true;\n            return;\n        }\n\n        if(sz[x] < sz[y]) swap(x, y);\n\n        par[y] = x;\n        sz[x] += sz[y];\n        n_cc--;\n\n        if(cycle[x] || cycle[y]) cycle[x] = true;\n    }\n\n    bool is_union(int x, int y){\n        x = find(x);\n        y = find(y);\n        return x == y;\n    }\n\n    int union_size(int x){\n        return sz[find(x)];\n    }\n\n};\n\n\nsigned main(){\n\n    int N, H, W; cin >> N >> H >> W;\n    vec R(N), C(N), A(N);\n    pairs p(N);\n    REP(i, N){\n        cin >> R[i] >> C[i] >> A[i];\n        R[i]--;\n        C[i]--;\n        p[i] = Pii(A[i], i);\n    }\n    Sort(p); Reverse(p);\n\n    UnionFind UF(H + W);\n    int ans = 0;\n    REP(i, N){\n        int i0 = p[i].s;\n        int a = A[i0], r = R[i0], c = C[i0];\n        if(UF.cycle[UF.find(r)] && UF.cycle[UF.find(c + H)]) continue;\n\n        ans += a;\n        UF.unite(r, c + H);\n    }\n    Out(ans);\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long \nconst int N=2e5+2;\nvector<int>p(N);\nvector<int>ed(N);\nvector<int>v(N);\n\nvoid build()\n{\n    for(int i=0; i<N; ++i)\n    {\n        p[i]=i;\n        ed[i]=0;\n        v[i]=1;\n    }\n}\nint find_parent(int v)\n{\n    if(v==p[v])\n        return v;\n    return p[v]=find_parent(p[v]);\n}\nbool union_set(int a, int b)\n{\n    a=find_parent(a);\n    b=find_parent(b);\n    if(a!=b)\n    {\n        if(rand()&1)\n        {\n            swap(a, b);\n        }\n        if(ed[a]+ed[b]+1>v[a]+v[b])\n        {\n            return 0; \n        }\n        ed[a]+=ed[b]+1;\n        v[a]+=v[b];\n        p[b]=a;\n    }\n    else \n    {\n        if(ed[a]+1>v[a])\n            return 0;\n        ed[a]++;\n    }\n    return 1;\n}\n\nint32_t main()\n{\n    int n, h, w;\n    cin>>n>>h>>w;\n    srand(time(NULL));\n\n    vector<pair<int,pair<int,int>>>a(n);\n    for(int i=0; i<n; ++i)\n    {\n        cin>>a[i].second.first>>a[i].second.second>>a[i].first;\n    }\n    sort(a.begin(), a.end());\n    int ans=0;\n    build();\n    for(int i=n-1; i>=0; --i)\n    {\n        if(union_set(a[i].second.first, a[i].second.second+h))\n            ans+=a[i].first;\n    }\n    cout<<ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Card {\n  int row;\n  int col;\n  int value;\n};\n\nenum Type {\n  Row,\n  Col,\n};\n\nstruct Pos {\n  Type type;\n  int index;\n};\n\nusing Choice = vector<Pos>;\n\nint main() {\n  int N, H, W;\n  cin >> N >> H >> W;\n  vector<bool> row_done(H + 1);\n  vector<bool> col_done(W + 1);\n  deque<Choice> choices;\n  vector<Choice*> row_choice(H + 1);\n  vector<Choice*> col_choice(W + 1);\n  auto cmp = [](auto&& lhs, auto&& rhs) { return lhs.value < rhs.value; };\n  priority_queue<Card, vector<Card>, decltype(cmp)> q{cmp};\n  for (int i = 1; i <= N; ++i) {\n    Card c;\n    cin >> c.row >> c.col >> c.value;\n    q.emplace(move(c));\n  }\n  int64_t result = 0;\n  for (; !q.empty(); q.pop()) {\n    auto&& c = q.top();\n    if (row_done[c.row] && col_done[c.col]) {\n      continue;\n    }\n    result += c.value;\n    if (row_done[c.row]) {\n      col_done[c.col] = true;\n      if (auto choice = col_choice[c.col]) {\n        for (auto&& pos : *choice) {\n          switch (pos.type) {\n            case Row:\n              row_done[pos.index] = true;\n              break;\n            case Col:\n              col_done[pos.index] = true;\n              break;\n          }\n        }\n      }\n    } else if (col_done[c.col]) {\n      row_done[c.row] = true;\n      if (auto choice = col_choice[c.col]) {\n        for (auto&& pos : *choice) {\n          switch (pos.type) {\n            case Row:\n              row_done[pos.index] = true;\n              break;\n            case Col:\n              col_done[pos.index] = true;\n              break;\n          }\n        }\n      }\n    } else {\n      auto row_free = row_choice[c.row] == nullptr;\n      auto col_free = col_choice[c.col] == nullptr;\n      col_done[c.col] = true;\n      if (row_free && col_free) {\n        Choice conf{\n            Pos{Row, c.row},\n            Pos{Col, c.col},\n        };\n        choices.emplace_back(move(conf));\n        row_choice.emplace_back(&choices.back());\n        col_choice.emplace_back(&choices.back());\n      } else if (row_free) {\n        auto& choice = col_choice[c.col];\n        choice->emplace_back(Pos{Row, c.row});\n      } else if (col_free) {\n        auto& choice = row_choice[c.row];\n        choice->emplace_back(Pos{Col, c.col});\n      } else {\n        col_done[c.col] = row_done[c.row] = true;\n        auto&& c1 = *row_choice[c.row];\n        auto&& c2 = *col_choice[c.col];\n        Choice choice;\n        for (auto&& pos : c1) {\n          choice.push_back(pos);\n        }\n        for (auto&& pos : c2) {\n          choice.push_back(pos);\n        }\n        choices.emplace_back(move(choice));\n        col_choice[c.col] = &choices.back();\n        row_choice[c.row] = &choices.back();\n      }\n    }\n  }\n  cout << result << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\nconst int maxn=1e5+5;\nmap<P,int>mp; int tot=0; int d[maxn];\nint h, w, n;\nstruct node{\n    int x, y; ll val;\n    bool operator<(const node &g)const{\n        return val>g.val;\n    }\n}a[maxn]; int par[maxn*3], num1[maxn*3], num2[maxn*3];\nint fd(int x){\n    return par[x]==x?x:par[x]=fd(par[x]);\n}\nvoid unite(int x, int y){\n    x=fd(x); y=fd(y);\n    if(x==y) return;\n    par[x]=y; num1[y]+=num1[x]; num2[y]+=num2[x];\n}\nint main(){\n    scanf(\"%d%d%d\",&n,&h,&w); ll sum=0;\n    for(int i=1;i<=n+h+w;i++){\n        par[i]=i;\n        if(i>n) num2[i]=1;\n        else num1[i]=1;\n    }\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%lld\",&a[i].x,&a[i].y,&a[i].val);\n    } sort(a+1,a+n+1);\n    for(int i=1;i<=n;i++){\n        int x=a[i].x; int y=a[i].y;\n        if(fd(x+n)!=fd(y+n+h)){\n            int t1=fd(x+n); int t2=fd(y+n+h);\n            if(num1[t1]+num1[t2]<num2[t1]+num2[t2]) unite(x+n,i), unite(i,y+n+h), sum+=a[i].val;\n        }\n        else{\n            int t=fd(x+n);\n            if(num1[t]<num2[t]) unite(x+n,i), sum+=a[i].val;\n        }\n    }\n    printf(\"%lld\\n\",sum);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> ii;\ntypedef long long ll;\n\nconst int Maxn = 300005;\n\nint n, H, W;\nint R[Maxn], C[Maxn], A[Maxn];\nint seq[Maxn];\nbool tk[Maxn], vis[Maxn];\nint oth[Maxn];\nll res;\n\nbool Less(const int &a, const int &b) { return A[a] > A[b]; }\n\nint Visit(int v)\n{\n    if (vis[v]) return -1;\n    vis[v] = true;\n    if (!tk[v]) return v;\n    int g = Visit(oth[v]);\n    if (g != -1) { tk[g] = true; tk[v] = false; return v; }\n    return -1;\n}\n\nint main()\n{\n    scanf(\"%d %d %d\", &n, &H, &W);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &R[i], &C[i], &A[i]);\n        seq[i] = i;\n    }\n    sort(seq, seq + n, Less);\n    for (int i = 0; i < n; i++) {\n        int ind = seq[i];\n        if (!tk[R[ind]]) {\n            tk[R[ind]] = true;\n            res += A[ind];\n            oth[R[ind]] = H + C[ind];\n        } else if (!tk[H + C[ind]]) {\n            tk[H + C[ind]] = true;\n            res += A[ind];\n            oth[H + C[ind]] = R[ind];\n        } else {\n            int v = Visit(R[ind]);\n            if (v != -1) {\n                tk[v] = true;\n                res += A[ind];\n                oth[R[ind]] = H + C[ind];\n                vis[R[ind]] = false;\n            } else {\n                v = Visit(H + C[ind]);\n                if (v != -1) {\n                    tk[v] = true;\n                    res += A[ind];\n                }\n            }\n        }\n    }\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <unordered_set>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <random>\n#include <iomanip>\n#include <functional>\n#include <cassert>\n \nusing namespace std;\n \ntypedef long long ll;\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n#ifdef LOCAL\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int k, n, m;\n  cin >> k >> n >> m;\n  vector <int> x(k), y(k), a(k);\n  for (int i = 0; i < k; ++i) {\n    cin >> x[i] >> y[i] >> a[i];\n    --x[i], --y[i];\n  }\n  ll ans = 0;\n  for (int mask = 0; mask < (1 << k); ++mask) {\n    ll cur = 0;\n    vector <vector <int>> g(n, vector <int> (m));\n    for (int i = 0; i < k; ++i) {\n      if (mask & (1 << i)) {\n        cur += a[i];\n        ++g[x[i]][y[i]];\n      }\n    }\n    bool ok = true;\n    for (int i = 0; i < n; ++i) {\n      int cnt = 0;\n      for (int j = 0; j < m; ++j) {\n        if (g[i][j] > 1) {\n          ++cnt;\n        }\n        if (g[i][j] > 2) {\n          ok = false;\n        }\n      }\n      if (cnt > 1) ok = false;\n    }\n    for (int j = 0; j < m; ++j) {\n      int cnt = 0;\n      for (int i = 0; i < n; ++i) {\n        if (g[i][j] > 1) {\n          ++cnt;\n        }\n        if (g[i][j] > 2) {\n          ok = false;\n        }\n      }\n      if (cnt > 1) ok = false;\n    }\n    ok &= (__builtin_popcount(mask) <= n + m);\n    if (ok) ans = max(ans, cur);\n  }\n  cout << ans << '\\n';\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define LL long long\n#define PB push_back\n#define MP make_pair\n#define MOD (LL)(1e9+7)\n\nint N, H, W;\nvector<pair<LL, pair<int, int>>> v;\nmultiset<pair<int, int>> p;\n\nbool dangerY[100000] ={};\nbool dangerX[100000] ={};\nvector<int> y[100000], x[100000];\nint main(){\n\tcin >> N >> H >> W;\n\tfor(int i=0; i<N; i++){\n\t\tint y, x, a;\n\t\tscanf(\"%d%d%d\", &y, &x, &a);\n\t\ty--; x--;\n\t\tv.PB({ a,{y,x} });\n\t}\n\tsort(v.begin(), v.end());\n\treverse(v.begin(), v.end());\n\tLL ans = 0;\n\tfor(int i=0; i<N; i++){\n\t\tif(p.count(v[i].second)  == 2) continue;\n\n\t\tif(p.count(v[i].second)  == 1 && (dangerY[v[i].second.first] || dangerX[v[i].second.second])) continue;\n\n\t\tint c = 0;\n\t\tfor(int j=0; j<y[v[i].second.first].size(); j++){\n\t\t\tfor(int k=0; k<x[v[i].second.second].size(); k++){\n\t\t\t\tc += p.count({ y[v[i].second.first][j], x[v[i].second.second][k] });\n\t\t\t\t//cout << i << \" \" << c << endl;\n\t\t\t}\n\t\t}\n\t\tif(c >= 2) continue;\n\n\t\tans += v[i].first;\n\t\tp.insert(v[i].second);\n\t\tif(p.count(v[i].second)  == 2){\n\t\t\tdangerY[v[i].second.first] = true;\n\t\t\tdangerX[v[i].second.second] = true;\n\t\t}\n\t\ty[v[i].second.first].PB(v[i].second.second);\n\t\tx[v[i].second.second].PB(v[i].second.first);\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing ll = long long;\nconst ll MOD = 1e9 + 7;\n\nconst int M = 1e5;\nint group[2*M];\nint val[2*M];\n\nint coll(int i) {\n\tif (group[i] != i) group[i] = coll(group[i]);\n\treturn group[i];\n}\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n, h, w;\n\tcin >> n >> h >> w;\n\tfor (int x = 0; x < w; ++x) group[x] = x;\n\tfor (int y = w; y < w+h; ++y) group[y] = y;\n\tfor (int i = 0; i < w+h; ++i) val[i] = 1;\n\n\tvector<pair<int, pair<int, int>>> cards(n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> cards[i].second.first >> cards[i].second.second >> cards[i].first;\n\t}\n\tsort(cards.begin(), cards.end());\n\n\t// We will always pick the most valuable card.\n\t// We will always pick the second most valuable card\n\t// And so on. therefore a greedy strategy works.\n\t// To check if we can pick card i, We need to check that for all subsets of cards,\n\t// the number of columns and rows in their coordinates is at least their count.\n\n\tll res = 0;\n\twhile(! cards.empty()) {\n\t\tll v = cards.back().first;\n\t\tint yi = coll(w + cards.back().second.first - 1);\n\t\tint xi = coll(cards.back().second.second - 1);\n\t\tcards.pop_back();\n\n\t\tif (xi == yi) {\n\t\t\tif (val[xi] >= 1) {\n\t\t\t\t--val[xi];\n\t\t\t\tres += v;\n\t\t\t}\n\t\t} else {\n\t\t\tif (val[xi] + val[yi] >= 1) {\n\t\t\t\tgroup[yi] = xi;\n\t\t\t\tval[xi] += val[yi] - 1;\n\t\t\t\tres += v;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define LL long long\n#define ULL unsigned long long\n#define mp make_pair\n#define pb push_back\n#define pii pair<int,int>\n#define pll pair<LL,LL>\n#define x first\n#define y second\n#define pi acos(-1)\n#define sqr(x) ((x)*(x))\n#define pdd pair<double,double>\n#define MEMS(x) memset(x,-1,sizeof(x))\n#define MEM(x) memset(x,0,sizeof(x))\n#define less Less\n#define EPS 1e-4\n#define arg ARG\n#define pdd pair<double,double>\n#define cpdd const pdd\n#define MXN 300005\nint f[200005];\nint Find(int x){\n    if(f[x]==x)return x;\n    return f[x]=Find(f[x]);\n}\nint match[200005];\nint main(){\n    int n,h,w;\n    scanf(\"%d %d %d\",&n,&h,&w);\n    for(int i = 1;i<=h+w;i++)\n        f[i]=i;\n    pair<int,pii> p[100005];\n    for(int i = 0;i<n;i++){\n        int r,c,a;\n        scanf(\"%d %d %d\",&r,&c,&a);\n        p[i]=mp(a,mp(r,c+h));\n    }\n    sort(p,p+n);\n    reverse(p,p+n);\n    LL ans=0;\n    for(int i = 0;i<n;i++){\n        int a=Find(p[i].y.x);\n        int b=Find(p[i].y.y);\n        if(!match[a]){\n            match[a]=1;\n            f[a]=b;\n            ans+=p[i].x;\n        }\n        else if(!match[b]){\n            match[b]=1;\n            f[b]=a;\n            ans+=p[i].x;\n        }\n    }\n    printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Card {\n  int row;\n  int col;\n  int value;\n};\n\nint main() {\n  int N, H, W;\n  cin >> N >> H >> W;\n  vector<int> row_to_col(H + 1);\n  vector<int> col_to_row(W + 1);\n  auto cmp = [](auto&& lhs, auto&& rhs) { return lhs.value < rhs.value; };\n  priority_queue<Card, vector<Card>, decltype(cmp)> q{cmp};\n  for (int i = 1; i <= N; ++i) {\n    Card c;\n    cin >> c.row >> c.col >> c.value;\n    q.emplace(move(c));\n  }\n  int64_t result = 0;\n  for (; !q.empty(); q.pop()) {\n    auto&& c = q.top();\n    auto& rc = row_to_col[c.row];\n    auto& cr = col_to_row[c.col];\n    if (rc == 0 && cr == 0) {\n      rc = c.col;\n      cr = c.row;\n      result += c.value;\n    } else if (rc == 0) {\n      rc = -1;\n      cr = -1;\n      result += c.value;\n    } else if (cr == 0) {\n      cr = -1;\n      rc = -1;\n      result += c.value;\n    } else if (rc == -1 && cr == -1) {\n    } else if (rc == -1) {\n      cr = -1;\n      result += c.value;\n    } else if (cr == -1) {\n      rc = -1;\n      result += c.value;\n    } else {\n      col_to_row[rc] = cr;\n      row_to_col[cr] = rc;\n      rc = cr = -1;\n      result += c.value;\n    }\n  }\n\n  cout << result << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1 };\nvel dy = { 1,-1,0,0 };\nvoid fi(int i, vel& dp, vvel& nex) {\n\tdp[i] = 0;\n\tfor (auto ne : nex[i]) { mmax(dp[i], dp[ne]); }\n}\nvoid sol(int i, vel& dp, vvel& nex, vel& cnt) {\n\tif (cnt[i] == 0) {\n\t\tcnt[i]++;\n\t\tfi(i, dp, nex);\n\t}\n\tif (nex[i].size() == 0) {\n\t\treturn;\n\t}\n\tfor (auto ne : nex[i]) {\n\t\tif (dp[i] == dp[ne]) {\n\t\t\tsol(ne, dp, nex, cnt);\n\t\t\tbreak;\n\t\t}\n\t}\n\tfi(i, dp, nex);\n\treturn;\n}\nsigned main() {\n\tomajinai;\n\tint n, h, w; cin >> n >> h >> w;\n\tvvel cxy(n);\n\tvvel y_i(w);\n\tvvel x_i(h);\n\trep(i, n) {\n\t\tint c, x, y; cin >> x >> y >> c; x--; y--;\n\t\tcxy[i] = { c,x,y };\n\t}\n\tsor(cxy);\n\trep(i, n) {\n\t\tint x = cxy[i][1];\n\t\tint y = cxy[i][2];\n\t\ty_i[y].push_back(i);\n\t\tx_i[x].push_back(i);\n\t}\n\tvel cnt(n, 0);\n\tvvel nex(n);\n\trep(i, w) { \n\t\tsor(y_i[i]);\n\t\tint sz = y_i[i].size();\n\t\tif (sz != 0) {\n\t\t\tcnt[y_i[i].back()]++;\n\t\t\trep(j, sz - 1) {\n\t\t\t\tnex[y_i[i][j + 1]].push_back(y_i[i][j]);\n\t\t\t}\n\t\t}\n\n\t}\n\trep(i, h) { \n\t\tsor(x_i[i]);\n\t\tint sz = x_i[i].size();\n\t\tif (sz != 0) {\n\t\t\tcnt[x_i[i].back()]++;\n\t\t\trep(j, sz - 1) {\n\t\t\t\tnex[x_i[i][j + 1]].push_back(x_i[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tvel dp(n);\n\tint ans = 0;\n\trep(i, n) {\n\t\tif (cnt[i] >= 1) {\n\t\t\tfi(i, dp, nex);\n\t\t\tans += cxy[i][0];\n\t\t\tif (cnt[i] >= 2) {\n\t\t\t\tans += dp[i];\n\t\t\t\tsol(i, dp, nex, cnt);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tdp[i] = cxy[i][0];\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<chrono>\n#include<climits>\n#include<numeric>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<random>\n#include<set>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<string>\nusing namespace std;\n \n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define print(v) {for(auto x : v) cout << x << ' '; cout << endl;}\n#define printn(v, n) {for(int _i = 0; _i < n; _i++) cout << *(v + _i) << ' '; cout << endl;}\n \ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n \nconst int MAXN = 2e5 + 20;\nint n, h, w;\nvector<long long> a[MAXN];\n\nint root[MAXN], size[MAXN], marked[MAXN] = {};\nvoid init() {\n    for(int i = 0; i < MAXN; i++) {\n        root[i] = i;\n        size[i] = 1;\n    }\n}\nint find(int i) {\n    if(root[i] != i)\n        return root[i] = find(root[i]);\n    else\n        return i;\n}\nint same(int i, int j) {\n    return find(i) == find(j);\n}\nvoid join(int i, int j) {\n    if(same(i, j))\n        return;\n    int ri = find(i);\n    int rj = find(j);\n    if(marked[ri] || marked[rj])\n    \tmarked[ri] = marked[rj] = 1;\n    if(size[ri] >= size[rj]) {\n        root[rj] = ri;\n        size[ri] += size[rj];\n    }\n    else {\n        root[ri] = rj;\n        size[rj] += size[ri];\n    }\n}\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> n >> h >> w;\n    for(int i = 0; i < n; i++) {\n    \ta[i].resize(3);\n    \tcin >> a[i][1] >> a[i][2] >> a[i][0];\n    }\n\n    sort(a, a + n, [](const vector<long long> & x, const vector<long long> & y) {\n    \treturn x[0] > y[0];\n    });\n\n    init();\n\n    long long res = 0;\n    for(int i = 0; i < n; i++) {\n    \tint x = a[i][1];\n    \tint y = a[i][2] + n;\n    \tint w = a[i][0];\n    \t//cout << x << ' ' << y << ' ' << same(x, y) << endl;\n    \tif(!same(x, y)) {\n    \t\tif(!marked[find(x)] || !marked[find(y)]) {\n\t    \t\tres += w;\n\t    \t\tjoin(x, y);\n    \t\t}\n    \t}\n    \telse if(!marked[find(x)]) {\n    \t\tmarked[find(x)] = 1;\n    \t\tres += w;\n    \t}\n    }\n    cout << res << endl;\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define WHOLE(v) (v).begin(), (v).end()\n#define REV_WHOLE(v) (v).rbegin(), (v).rend()\nusing i64 = int64_t;\nusing namespace std;\ntemplate<size_t I,class H,class...T>struct TupleReaderWriter{static tuple<H,T...> r(istream&i){H v;i>>v;return tuple_cat(tuple<H>(v),TupleReaderWriter<sizeof...(T)-1,T...>::r(i));}static void w(ostream&o,tuple<H,T...>&t,string d){TupleReaderWriter<I-1,H,T...>::w(o,t,d);o<<d<<get<I>(t);}};\ntemplate<class H,class...T>struct TupleReaderWriter<0,H,T...>{static tuple<H,T...> r(istream&i){H v;i>>v;return tuple<H>(v);}static void w(ostream&o,tuple<H,T...>&t,string d){o<<get<0>(t);}};\ntemplate<class...T>istream&operator>>(istream&i,tuple<T...>&t){t=TupleReaderWriter<sizeof...(T),T...>::r(i);return i;}\ntemplate<class...T>ostream&operator<<(ostream&o,tuple<T...>&t){string delim=\" \";TupleReaderWriter<sizeof...(T)-1,T...>::w(o,t,delim);return o;}\ntemplate<class T>istream&operator>>(istream&i,vector<T>&v){for(auto&x:v)i>>x;return i;}\ntemplate<class T>ostream&operator<<(ostream&o,vector<T>&v){string delim=\"\";for(auto&x:v)o<<delim<<x,delim=\" \";return o;}\ntemplate<class T>using rev_priority_queue=priority_queue<T,vector<T>,greater<T>>;\ntemplate<class T>using vector2d=vector<vector<T>>;\nstruct fixprec{int x;fixprec(int d):x(d){}};\nostream&operator<<(ostream&o,fixprec f){return o<<fixed<<setprecision(f.x);}\nvoid R_YESNO(bool p) { cout << (p ? \"YES\" : \"NO\") << endl; }\nvoid R_YesNo(bool p) { cout << (p ? \"Yes\" : \"No\") << endl; }\nusing Card = tuple<int, int, int>;\nint main() {\n    int N, H, W;\n    cin >> N >> H >> W;\n    vector<int> row(H, 0), col(W, 0);\n    vector<bool> used_row(H, false), used_col(W, false);\n    vector<Card> v(N);\n    for(auto &x : v) {\n        int r, c, a;\n        cin >> r >> c >> a;\n        r--, c--;\n        x = make_tuple(a, r, c);\n        row[r]++;\n        col[c]++;\n    }\n    i64 ans = 0;\n    sort(REV_WHOLE(v));\n    for(auto x : v) {\n        int a, r, c;\n        tie(a, r, c) = x;\n        ans += a;\n        if(row[r] == 1) {\n            used_row[r] = true;\n        } else if(col[c] == 1) {\n            used_col[c] = true;\n        } else if(!used_row[r]) {\n            used_row[r] = true;\n        } else if(!used_col[c]) {\n            used_col[c] = true;\n        } else {\n            ans -= a;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define name \"main\"\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define fto(i,a,b) for(int i=a; i<=b;++i)\n#define maxn 100009\n#define ll long long\n\nusing namespace std;\nbool gone[maxn][3],ck[maxn][3];\nint cl[maxn];\nint xd[maxn][3],a[maxn][3],w,h,n;\npii b[maxn];\nbool check(int i, int x,int j){\n    if(!ck[i][x]) return false;\n    if(gone[i][x])return ck[i][x]=false;\n    gone[i][x]=true;\n    if(xd[i][x]==0){\n        xd[i][x]=j;\n        gone[i][x]=false;\n        ck[i][1-x]=true;\n        return true;\n    }\n    /// xd[i][x]!=0;\n    /// i,x la cot hoac hang, j la chi so can dien\n    int t=xd[i][x];/// t la so can dien\n    if(check(a[t][1-x],1-x,t)){\n        xd[i][x]=j;\n        gone[i][x]=false;\n        ck[i][1-x]=true;\n        return true;\n    }\n    gone[i][x]=false;\n    return ck[i][x]=false;\n}\nint main()\n{\n    cin >> n >> h >> w;\n    fto(i,1,n){\n        cin >> a[i][0]>> a[i][1] >> b[i].fi;\n        b[i].se=i;\n        ck[i][0]=ck[i][1]=true;\n    }\n    sort(b+1,b+n+1,greater<pii> ());\n    ll res=0;\n    fto(i,1,n){\n        int j=b[i].se;\n        if(check(a[j][0],0,j)){\n            //xd[a[j][0]][0]=j;\n            res+=b[i].fi;\n        }\n        else if(check(a[j][1],1,j)){\n            //xd[a[j][1]][1]=j;\n            res+=b[i].fi;\n        }\n    }\n    cout << res ;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 100005;\n\nint q, m, n, dsu[2 * N];\nlong long ans = 0;\nbool vis[2 * N];\n\nstruct SQuery {\n    int v, x, y;\n} a[N];\n\nint trace(int u) {\n    return dsu[u] < 0 ? u : dsu[u] = trace(dsu[u]);\n}\n\nbool connect(int u, int v) {\n    u = trace(u); v = trace(v);\n    if (vis[u] && vis[v]) {\n        return false;\n    }\n    if (u == v) {\n        vis[u] = true;\n    } else {\n        if (dsu[u] > dsu[v]) {\n            swap(u, v);\n        }\n        dsu[u] += dsu[v];\n        vis[u] |= vis[v];\n        dsu[v] = u;\n    }\n    return true;\n}\n\nint main() {\n    cin >> q >> m >> n;\n    for (int i = 1; i <= q; i++) {\n        cin >> a[i].x >> a[i].y >> a[i].v;\n        a[i].y += m;\n    }\n    fill(dsu + 1, dsu + m + n + 1, -1);\n    sort(a + 1, a + q + 1, [](const SQuery &a, const SQuery &b) {\n        return a.v > b.v;\n    });\n    for (int i = 1; i <= q; i++) {\n        if (connect(a[i].x, a[i].y)) {\n            ans += a[i].v;\n        }\n    }\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <set>\n// #include <bits/stdc++.h>\n\n\nusing namespace std;\ntypedef long long li;\n\n\nclass UnionFind {\n    // parent[i] = -1 -> i is root.\n    vector<int> parent;\n    vector<int> rank;\n    vector<int> size;\n    vector<int> weight;\npublic:\n    UnionFind(int n): parent(n, -1), rank(n, 0), size(n, 1), weight(n, 0) {}\n\n    int find(int n){\n        vector<int> path;\n        while(parent[n]!=-1){\n            path.push_back(n);\n            n = parent[n];\n        }\n        for(auto it = path.begin(); it != path.end(); it++){\n            parent[*it] = n;\n            rank[*it] = 0;\n        }\n        return n;\n    }\n\n    void unify(int x, int y){\n        int rx = find(x), ry = find(y);\n        if(rx == ry) return;\n\n        if(rank[rx] < rank[ry]){\n            parent[rx] = ry;\n            size[ry] += size[rx];\n            weight[ry] += weight[rx];\n        } else {\n            parent[ry] = rx;\n            size[rx] += size[ry];\n            weight[rx] += weight[ry];\n            if(rank[rx] == rank[ry]) rank[rx]++;\n        }\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n\n    int get_size(int n) {\n        return size[find(n)];\n    }\n\n    int get_weight(int n) {\n        return weight[find(n)];\n    }\n\n    void add_weight(int n, int w) {\n        weight[find(n)] += w;\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n\n    li n, h, w;\n    cin >> n >> h >> w;\n    vector<li> rs(n), cs(n), xs(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> rs[i] >> cs[i] >> xs[i];\n        rs[i]--; cs[i]--;\n    }\n\n    priority_queue<pair<li, li>> q;\n    for (int i = 0; i < n; ++i) {\n        q.emplace(xs[i], i);\n    }\n\n    UnionFind uf(h + w);\n    li ans = 0;\n    while (not q.empty()) {\n        auto p = q.top();\n        q.pop();\n        int i = p.second;\n        int cost = p.first;\n\n        if (uf.same(rs[i], h + cs[i]) && uf.get_size(rs[i]) <= uf.get_weight(rs[i])) {\n            continue;\n        }\n\n        if (uf.get_size(rs[i]) + uf.get_size(h + cs[i]) <= uf.get_weight(rs[i]) + uf.get_weight(h + cs[i])) {\n            continue;\n        }\n        uf.unify(rs[i], h + cs[i]);\n        uf.add_weight(rs[i], 1);\n        ans += cost;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <map>\n#include <set>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <bitset>\n#include <cassert>\n#include <queue>\n#include <stack>\n#include <iomanip>\n#include <math.h>\n#include <time.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)n; i++)\n#define repf(i, a, b) for (int i = (int)a; i < (int)b; i++)\n#define repr(i, a, b) for (int i = (int)a; i > (int)b; i--)\n#define all(v) (v).begin(), (v).end()\n#define mp(a, b) make_pair(a, b)\n#define pb(x) push_back(x)\n#define eb(x) emplace_back(x)\n#define F first\n#define S second\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ld, ld> pdd;\ntypedef vector<ll> vll;\ntypedef vector<vll> vvll;\ntypedef vector<int> vii;\ntypedef vector<vii> vvii;\nconst ll mod = 1e9 + 7;\nconst int infi = 1147483600;\nconst ll infl = 1e18 + 5;\nconst char ENDL = '\\n';\n//cout << fixed << setprecision(17) << res << endl;\nll n, h, w;\nll ans = 0;\nvector<pll> edges[300005];\nll cc[300005];\nbool dfs(int now,ll cost,vii& match,vector<bool>& used){\n    used[now] = true;\n    for (auto p:edges[now]){\n        ll nex = p.F, c = p.S;\n        if (used[nex])\n            continue;\n        if (match[nex]==-1 && cost+c>0){\n            match[now] = nex;\n            match[nex] = now;\n            cc[now] = cc[nex] = c;\n            ans += cost + c;\n            return true;\n        }\n        else if (match[nex]!=-1){\n            used[nex] = true;\n            if (dfs(match[nex],cost-cc[nex]+c,match,used)){\n                match[now] = nex;\n                match[nex] = now;\n                cc[now] = cc[nex] = c;\n                return true;\n            }\n            used[nex] = false;\n        }\n    }\n    return false;\n}\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n >> h >> w;\n    rep(i, n)\n    {\n        ll r, c, a;\n        cin >> r >> c >> a;\n        r--;\n        c--;\n        r += n;\n        c += h+n;\n        edges[r].eb(mp(i, a));\n        edges[c].eb(mp(i, a));\n        edges[i].eb(mp(r, a));\n        edges[i].eb(mp(c, a));\n    }\n    vii match(h + w + n, -1);\n    rep(i, h + w + n) cc[i] = 0;\n    rep(s,h+w+n){\n        if (match[s]!=-1)\n            continue;\n        vector<bool> used(h + w + n, false);\n        dfs(s, 0, match,used);\n    }\n    cout << ans << ENDL;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REPP(i,n) for(int i=1;i<=n;i++)\nconst double PI = acos(-1);\nconst double EPS = 1e-15;\nlong long INF=(long long)1E17;\n#define i_7 (long long)(1E9+7)\nlong mod(long a){\n    long long c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\n\nusing namespace std;\nbool prime_(int n){\n  if(n==1){\n    return false;\n  }else if(n==2){\n    return true;\n  }else{\n    for(int i=2;i<=sqrt(n);i++){\n      if(n%i==0){\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nlong long gcd_(long long a, long long b){\n  if(a<b){\n    swap(a,b);\n  }\n  if(a%b==0){\n    return b;\n  }else{\n    return gcd_(b,a%b);\n  }\n}\n \nlong long lcm_(long long x, long long y){\n  return (x/gcd_(x,y))*y;\n}\n \nclass UnionFind {\n    public:\n    //各頂点の親の番号を格納する。その頂点自身が親だった場合は-(その集合のサイズ)を入れる。\n    vector<int> Parent;\n    \n    //クラスを作るときは、Parentの値を全て-1にする。\n    //以下のようにすると全てバラバラの頂点として解釈できる。\n    UnionFind(int N) {\n        Parent = vector<int>(N, -1);\n    }\n    \n    //Aがどのグループに属しているか調べる\n    int root(int A) {\n        if (Parent[A] < 0) return A;\n        return Parent[A] = root(Parent[A]);\n    }\n    \n    //自分のいるグループの頂点数を調べる\n    int size(int A) {\n        return -Parent[root(A)];//先祖をrootで取っておきたい。\n    }\n    \n    //AとBをくっ付ける\n    bool connect(int A, int B) {\n        //AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける\n        A = root(A);\n        B = root(B);\n        if (A == B) {\n            //すでにくっついてるからくっ付けない\n            return false;\n        }\n        \n        //大きい方(A)に小さいほう(B)をくっ付けたい\n        //大小が逆だったらAとBをひっくり返す。\n        if (size(A) < size(B)) swap(A, B);\n        \n        //Aのサイズを更新する\n        Parent[A] += Parent[B];\n        //Bの親をAに変更する\n        Parent[B] = A;\n        \n        return true;\n    }\n};\n\nint main(){\n  \n  int n,h,w;\n  cin>>n>>h>>w;\n  int r[n],c[n];\n  long long a[n];\n  REP(i,n){\n    cin>>r[i]>>c[i]>>a[i];\n    r[i]--;c[i]--;\n  }\n  vector<pair<long long, int>> rows[h];//行ごとに入っているカードを分類\n  vector<pair<long long, int>> columns[w];//列ごとに入っているカードを分類\n  vector<bool> used(n,false);\n  REP(i,n){\n    rows[r[i]].push_back(make_pair(a[i],i));\n    columns[c[i]].push_back(make_pair(a[i],i));\n  }\n  REP(i,h){\n    sort(rows[i].begin(), rows[i].end(), greater<pair<long long, int>>());\n  }\n  REP(i,w){\n    sort(columns[i].begin(), columns[i].end(), greater<pair<long long, int>>());\n  }\n  \n  int cnt[n];//iと同じ列にあるカードの数\n  REP(i,n){\n    cnt[i] = columns[c[i]].size();\n  }\n  \n  long long ans = 0;\n  int tempi;\n  int s;\n  REP(i,h){\n    if(rows[i].empty())continue;\n    tempi = -1;\n    s = rows[i].size();\n    REP(j,s){\n      if(cnt[rows[i][j].second]>1){\n        temp_i = rows[i][j].second;\n        used[rows[i][j].second] = true;\n        ans += rows[i][j].first;\n        break;\n      }else{\n        continue;\n      }\n    }\n    if(tempi==-1){\n      used[rows[i][0].second] = true;\n      ans += rows[i][0].first;\n    }\n  }\n  \n  REP(i,w){\n    if(columns[i].empty())continue;\n    s = columns[i].size();\n    REP(j,s){\n      if(used[columns[i][j].second])continue;\n      used[columns[i][j].second] = true;\n      ans += columns[i][j].first;\n      break;\n    }\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair <int, int> ii;\ntypedef long long ll;\n\nconst int Maxn = 200005;\n\nint n, H, W;\nint R[Maxn], C[Maxn], A[Maxn];\nint seq[Maxn];\nint par[Maxn], siz[Maxn];\nbool ful[Maxn];\nll res;\n\nbool Less(const int &a, const int &b) { return A[a] > A[b]; }\n\nint getPar(int x) { return par[x] == x? x: par[x] = getPar(par[x]); }\n\nbool unionSet(int a, int b)\n{\n    a = getPar(a), b = getPar(b);\n    if (a == b)\n        if (ful[a]) return false;\n        else { ful[a] = true; return true; }\n    else {\n        if (siz[a] < siz[b]) swap(a, b);\n        siz[a] += siz[b]; par[b] = a;\n        if (ful[a] && ful[b]) return false;\n        ful[a] |= ful[b];\n        return true;\n    }\n}\n\nint main()\n{\n    scanf(\"%d %d %d\", &n, &H, &W);\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d\", &R[i], &C[i], &A[i]);\n        seq[i] = i;\n    }\n    sort(seq, seq + n, Less);\n    for (int i = 1; i <= H + W; i++) {\n        par[i] = i, siz[i] = 1, ful[i] = false;\n    }\n    for (int i = 0; i < n; i++) {\n        int ind = seq[i];\n        if (unionSet(R[ind], H + C[ind]))\n            res += A[ind];\n    }\n    cout << res << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by yamunaku on 2019/08/24.\n//\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repl(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perl(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD9 998244353\n#define MOD1 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n#define CST(x) cout<<fixed<<setprecision(x)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> mti;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> mtl;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\nint max_n;\nconst int mn = 300000;\nstruct edge {\n    int to, cap; ll cost; int rev;\n};\nvector<edge> G[mn];\nP par[mn];\nll dist[mn];\nvoid add_edge(int from, int to, int cap, ll cost) {\n    G[from].push_back({ to,cap,cost,(int)G[to].size() });\n    G[to].push_back({ from,0,-cost,(int)G[from].size() - 1 });\n    max_n = max({ max_n, from + 1, to + 1 });\n}\nvoid add_edge2(int from, int to, int cap, ll cost) {\n    G[from].push_back({ to,cap,cost,-1 });\n    //G[to].push_back({ from,0,-cost,(int)G[from].size() - 1 });\n    max_n = max({ max_n, from + 1, to + 1 });\n}\nLP minimum_road(int s, int t) {\n    fill(par, par + max_n, P{ -1,-1 });\n    fill(dist, dist + max_n, IINF);\n    dist[s] = 0;\n    priority_queue<LP, vector<LP>, greater<LP>> q; q.push({ 0,s });\n    while (!q.empty()) {\n        LP p = q.top(); q.pop();\n        int id = p.second;\n        if (id == t)continue;\n        if (p.first > dist[id])continue;\n        rep(j, G[id].size()) {\n            if (G[id][j].cap > 0) {\n                int to = G[id][j].to;\n                ll nd = p.first + G[id][j].cost;\n                if (nd < dist[to]) {\n                    dist[to] = nd;\n                    par[to] = { id,j };\n                    q.push({ dist[to],to });\n                }\n            }\n        }\n    }\n    int cur = t;\n    int f = IINF;\n    while (cur != s) {\n        int p = par[cur].first, j = par[cur].second;\n        if (p < 0)return { -1,-1 };\n        f = min(f, G[p][j].cap);\n        cur = p;\n    }\n    cur = t;\n    while (cur != s) {\n        int p = par[cur].first, j = par[cur].second;\n        if (p < 0)return { -1,-1 };\n        G[p][j].cap -= f;\n        if (G[p][j].rev >= 0) {\n            G[cur][G[p][j].rev].cap += f;\n        }\n        cur = p;\n    }\n    return { dist[t],f };\n}\nll minimum_cost_flow(int s, int t) {\n    ll ret = 0;\n    int k=10000000;\n    ll x=0;\n    rep(i, k) {\n        LP z = minimum_road(s, t);\n        if (z.first < 0) break;\n        if (k - i <= z.second) {\n            ret += z.first*(k - i); break;\n        }\n        i += z.second - 1;\n        ret += z.first*z.second;\n        x++;\n    }\n    return IINF*x-ret;\n}\n\nint main(){\n    int n,h,w;\n    cin >> n;\n    cin >> h >> w;\n    vi r(n),c(n),a(n);\n    map<int,int> rmp,cmp;\n    rep(i,n){\n        cin >> r[i] >> c[i] >> a[i];\n        rmp[r[i]]=0;\n        cmp[c[i]]=0;\n    }\n    int idx=0;\n    for(auto &p:rmp) p.second=idx++;\n    idx=0;\n    for(auto &p:cmp) p.second=idx++;\n    int rs=rmp.size(),cs=cmp.size();\n    int sz=rs+cs+n+2;\n    rep(i,rs){\n        add_edge(0,i+2,1,0);\n    }\n    rep(i,cs){\n        add_edge(0,rs+i+2,1,0);\n    }\n    rep(i,n){\n        add_edge(rmp[r[i]]+2,rs+cs+i+2,1,0);\n        add_edge(rs+cmp[c[i]]+2,rs+cs+i+2,1,0);\n        add_edge(rs+cs+i+2,1,1,IINF-a[i]);\n    }\n    cout << minimum_cost_flow(0,1) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0;i<n;i++)\n#define REPP(i,n) for(int i=1;i<=n;i++)\nconst double PI = acos(-1);\nconst double EPS = 1e-15;\nlong long INF=(long long)1E17;\n#define i_7 (long long)(1E9+7)\nlong mod(long a){\n    long long c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\n\nusing namespace std;\nbool prime_(int n){\n  if(n==1){\n    return false;\n  }else if(n==2){\n    return true;\n  }else{\n    for(int i=2;i<=sqrt(n);i++){\n      if(n%i==0){\n        return false;\n      }\n    }\n    return true;\n  }\n}\n\nlong long gcd_(long long a, long long b){\n  if(a<b){\n    swap(a,b);\n  }\n  if(a%b==0){\n    return b;\n  }else{\n    return gcd_(b,a%b);\n  }\n}\n \nlong long lcm_(long long x, long long y){\n  return (x/gcd_(x,y))*y;\n}\n \nclass UnionFind {\n    public:\n    //各頂点の親の番号を格納する。その頂点自身が親だった場合は-(その集合のサイズ)を入れる。\n    vector<int> Parent;\n    \n    //クラスを作るときは、Parentの値を全て-1にする。\n    //以下のようにすると全てバラバラの頂点として解釈できる。\n    UnionFind(int N) {\n        Parent = vector<int>(N, -1);\n    }\n    \n    //Aがどのグループに属しているか調べる\n    int root(int A) {\n        if (Parent[A] < 0) return A;\n        return Parent[A] = root(Parent[A]);\n    }\n    \n    //自分のいるグループの頂点数を調べる\n    int size(int A) {\n        return -Parent[root(A)];//先祖をrootで取っておきたい。\n    }\n    \n    //AとBをくっ付ける\n    bool connect(int A, int B) {\n        //AとBを直接つなぐのではなく、root(A)にroot(B)をくっつける\n        A = root(A);\n        B = root(B);\n        if (A == B) {\n            //すでにくっついてるからくっ付けない\n            return false;\n        }\n        \n        //大きい方(A)に小さいほう(B)をくっ付けたい\n        //大小が逆だったらAとBをひっくり返す。\n        if (size(A) < size(B)) swap(A, B);\n        \n        //Aのサイズを更新する\n        Parent[A] += Parent[B];\n        //Bの親をAに変更する\n        Parent[B] = A;\n        \n        return true;\n    }\n};\n\nint main(){\n  \n  int n,h,w;\n  cin>>n>>h>>w;\n  int r[n],c[n];\n  long long a[n];\n  map<pair<int,int>, int> mp;//同じ列にあるカードの数\n  REP(i,n){\n    cin>>r[i]>>c[i]>>a[i];\n    r[i]--;c[i]--;\n    mp[make_pair(r[i],c[i])]++;\n  }\n  vector<pair<long long, int>> rows[h];//行ごとに入っているカードを分類\n  vector<pair<long long, int>> columns[w];//列ごとに入っているカードを分類\n  vector<bool> used(n,false);\n  REP(i,n){\n    rows[r[i]].push_back(make_pair(a[i],i));\n    columns[c[i]].push_back(make_pair(a[i],i));\n  }\n  REP(i,h){\n    sort(rows[i].begin(), rows[i].end(), greater<pair<long long, int>>());\n  }\n  REP(i,w){\n    sort(columns[i].begin(), columns[i].end(), greater<pair<long long, int>>());\n  }\n  \n  int cnt[n];//iと同じ列にあるカードの数\n  REP(i,n){\n    cnt[i] = columns[c[i]].size();\n  }\n  \n  long long ans = 0;\n  int tempi;\n  int s;\n  REP(i,h){\n    if(rows[i].empty())continue;\n    tempi = -1;\n    s = rows[i].size();\n    REP(j,s){\n      if(mp[r[rows[i][j].second],c[rows[i][j].second]]>1){\n        tempi = rows[i][j].second;\n        mp[r[rows[i][j].second],c[rows[i][j].second]]--;\n        used[rows[i][j].second] = true;\n        ans += rows[i][j].first;\n        break;\n      }else{\n        continue;\n      }\n    }\n    if(tempi==-1){\n      used[rows[i][0].second] = true;\n      mp[r[rows[i][0].second],c[rows[i][0].second]]--;\n      ans += rows[i][0].first;\n    }\n  }\n  \n  REP(i,w){\n    if(columns[i].empty())continue;\n    s = columns[i].size();\n    REP(j,s){\n      if(used[columns[i][j].second])continue;\n      used[columns[i][j].second] = true;\n      ans += columns[i][j].first;\n      break;\n    }\n  }\n  \n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\nconst int maxn=1e5+5;\nmap<P,int>mp; int tot=0; int d[maxn];\nint h, w, n;\nstruct node{\n    int x, y; ll val;\n    bool operator<(const node &g)const{\n        return val>g.val;\n    }\n}a[maxn]; int par[maxn*3], num1[maxn*3], num2[maxn*3];\nint fd(int x){\n    return par[x]==x?x:par[x]=fd(par[x]);\n}\nvoid unite(int x, int y){\n    x=fd(x); y=fd(y);\n    if(x==y) return;\n    par[x]=y; num1[y]+=num1[x]; num2[y]+=num2[x];\n}\nint main(){\n    scanf(\"%d%d%d\",&n,&h,&w); ll sum=0;\n    for(int i=1;i<=n+h+w;i++){\n        par[i]=i;\n        if(i>n) num2[i]=1;\n        else num1[i]=1;\n    }\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%lld\",&a[i].x,&a[i].y,&a[i].val);\n    } sort(a+1,a+n+1);\n    for(int i=1;i<=n;i++){\n        int x=a[i].x; int y=a[i].y;\n        if(fd(x+n)!=fd(y+n+h)){\n            int t1=fd(x+n); int t2=fd(y+n+h);\n            if(num1[t1]+num1[t2]<num2[t1]+num2[t2]) unite(x+n,i), unite(i,y+n+h), sum+=a[i].val;\n        }\n        else{\n            int t=fd(x+n);\n            if(num1[t]<num2[t]) unite(x+n,i), sum+=a[i].val;\n        }\n    }\n    printf(\"%lld\\n\",sum);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <class T>inline T updmax(T& a, T b) {return a = max(a, b);}\ntemplate <class T>inline T updmin(T& a, T b) {return a = min(a, b);}\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n  const cost_t INF;\n\n  struct edge {\n    int to;\n    flow_t cap;\n    cost_t cost;\n    int rev;\n    bool isrev;\n  };\n  vector< vector< edge > > graph;\n  vector< cost_t > potential, min_cost;\n  vector< int > prevv, preve;\n\n  PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n  void add_edge(int from, int to, flow_t cap, cost_t cost) {\n    graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n    graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n  }\n\n  cost_t min_cost_flow(int s, int t, flow_t f) {\n    int V = (int) graph.size();\n    cost_t ret = 0;\n    using Pi = pair< cost_t, int >;\n    priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n    potential.assign(V, 0);\n    preve.assign(V, -1);\n    prevv.assign(V, -1);\n\n    while(f > 0) {\n      min_cost.assign(V, INF);\n      que.emplace(0, s);\n      min_cost[s] = 0;\n      while(!que.empty()) {\n        Pi p = que.top();\n        que.pop();\n        if(min_cost[p.second] < p.first) continue;\n        for(int i = 0; i < graph[p.second].size(); i++) {\n          edge &e = graph[p.second][i];\n          cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n          if(e.cap > 0 && min_cost[e.to] > nextCost) {\n            min_cost[e.to] = nextCost;\n            prevv[e.to] = p.second, preve[e.to] = i;\n            que.emplace(min_cost[e.to], e.to);\n          }\n        }\n      }\n      if(min_cost[t] == INF) return -1;\n      for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n      flow_t addflow = f;\n      for(int v = t; v != s; v = prevv[v]) {\n        addflow = min(addflow, graph[prevv[v]][preve[v]].cap);\n      }\n      f -= addflow;\n      ret += addflow * potential[t];\n      for(int v = t; v != s; v = prevv[v]) {\n        edge &e = graph[prevv[v]][preve[v]];\n        e.cap -= addflow;\n        graph[v][e.rev].cap += addflow;\n      }\n    }\n    return ret;\n  }\n};\n\nclass Solution {\npublic:\n\tvoid solve() {\n\t\tint n, h, w;\n\t\tcin >> n >> h >> w;\n\t\tPrimalDual<int, long long> pd(n+h+w+2);\n\t\tfor(int i=0; i < n; i++)pd.add_edge(0, i+1, 1, 0);\n\t\tfor(int i=0; i < h+w; i++)pd.add_edge(n+1+i, h+w+n+1, 1, 0);\n\t\tfor(int i=0; i < n; i++){\n\t\t\tint r, c, a;\n\t\t\tcin >> r >> c >> a;\n\t\t\tpd.add_edge(i+1, n+r, 1, -a);\n\t\t\tpd.add_edge(i+1, n+h+c, 1, -a);\n\t\t}\n\t\tlong long ret = 0;\n\t\tfor(int i=0; i < n; i++){\n\t\t\tlong long tmp = pd.min_cost_flow(0, h+w+n+1, 1);\n\t\t\tif(tmp == -1)break;\n\t\t\telse ret += tmp;\n\t\t}\n\t\tcout << -ret << endl;\n\t\treturn;\n\t};\n};\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tSolution solution;\n\tsolution.solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=2e5+5;\nstruct node{\n    int r,c,a;\n    friend bool operator<(node a,node b){\n        return a.a>b.a;\n    }\n}st[maxn];\nint fa[maxn],S[maxn],T[maxn];\nint n,H,W;\nint init(){\n    for(int i=1;i<=H+W;i++){\n        fa[i]=i;\n        T[i]=1;\n    }\n}\nint find(int x){\n    return x==fa[x]?x:fa[x]=find(fa[x]);\n}\nint main(){\n    cin>>n>>H>>W;\n    init();\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%d\",&st[i].r,&st[i].c,&st[i].a);\n    }\n    sort(st+1,st+1+n);\n    ll ans=0;\n    for(int i=1;i<=n;i++){\n//        printf(\"%d %d %d\\n\",st[i].r,st[i].c,st[i].a);\n        int fr=find(st[i].r),fc=find(H+st[i].c);\n        if(fr==fc){//两个在同一集合内\n            if(T[fc]>=S[fc]+1){\n                S[fc]++;\n                ans=ans+st[i].a;\n            }\n        }\n        else{//两个不在同一集合内，要合并\n            if(T[fr]+T[fc]>=S[fr]+S[fc]+1){\n                fa[fr]=fc;\n                T[fc]+=T[fr];\n                S[fc]=S[fr]+S[fc]+1;\n                ans=ans+st[i].a;\n            }\n        }\n    }\n    printf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#define int long long\n#define rep(i, n) for(i = 0; i < n; i++)\nusing namespace std;\n\nstruct Edge {\n\tint from, to, cost;\n\tEdge() {}\n\tEdge(int f, int t, int c) {\n\t\tfrom = f;\n\t\tto = t;\n\t\tcost = c;\n\t}\n\tbool operator>(const Edge &r) const {\n\t\treturn cost > r.cost;\n\t}\n};\n\nstruct UF {\n\tint par[200000];\n\tbool isNamori[200000];\n\tUF() {\n\t\tfor (int i = 0; i < 200000; i++) {\n\t\t\tpar[i] = i;\n\t\t\tisNamori[i] = false;\n\t\t}\n\t}\n\t\n\tint root(int x) {\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n\t\n\tbool same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\t\n\tbool can_marge(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (same(x, y)) {\n\t\t\treturn isNamori[x] == false;\n\t\t}\n\t\treturn isNamori[x] == false || isNamori[y] == false;\n\t}\n\t\n\tvoid marge(int x, int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tpar[x] = y;\n\t\tisNamori[y] |= isNamori[x];\n\t}\n\t\n\tvoid setNamori(int x) {\n\t\tx = root(x);\n\t\tisNamori[x] = true;\n\t}\n};\n\nint n, h, w;\nint r[100000], c[100000], a[100000];\nvector<Edge> edges;\nUF uf;\n\nsigned main() {\n\tint i;\n\t\n\tcin >> n >> h >> w;\n\trep(i, n) {\n\t\tcin >> r[i] >> c[i] >> a[i];\n\t\tr[i]--; c[i]--;\n\t\tedges.push_back(Edge(r[i], c[i] + h, a[i]));\n\t}\n\tsort(edges.begin(), edges.end(), greater<Edge>());\n\t\n\tint ans = 0;\n\trep(i, edges.size()) {\n\t\tint u = edges[i].from;\n\t\tint v = edges[i].to;\n\t\t\n\t\tif (uf.can_marge(u, v)) {\n\t\t\tif (uf.same(u, v)) {\n\t\t\t\tuf.setNamori(u);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuf.marge(u, v);\n\t\t\t}\n\t\t\tans += edges[i].cost;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> par;\n    vector<int> sz;\n    vector<int> avail;\n\n    UnionFind(int n=0){\n        if(n>0) initialize(n);\n    }\n\n    void initialize(int n){\n        par.resize(n);\n        sz.resize(n);\n        avail.resize(n);\n        for(int i=0; i<n; i++){\n            par[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n    int find(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n        if(sz[x] > sz[y]) swap(x, y);\n        par[x] = y;\n        sz[y] += sz[x];\n        avail[y] += avail[x];\n    }\n\n    void add_avail(int x){\n        avail[find(x)]++;\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint main(){\n    int N, H, W, R[100000], C[100000], A[100000];\n    cin >> N >> H >> W;\n    static vector<pair<int, int>> hs[100000], ws[100000];\n    map<pair<int, int>, vector<pair<int, int>>> mp;\n    for(int i=0; i<N; i++){\n        cin >> R[i] >> C[i] >> A[i];\n        R[i]--; C[i]--;\n        mp[{R[i], C[i]}].emplace_back(A[i], i);\n    }\n    for(auto& p : mp){\n        int r = p.first.first, c = p.first.second;\n        auto& v = p.second;\n        int sz = v.size();\n        sort(v.rbegin(), v.rend());\n        for(int i=0; i<min(sz, 2); i++){\n            hs[r].push_back(v[i]);\n            ws[c].push_back(v[i]);\n        }\n    }\n\n    bitset<100000> use;\n    UnionFind uf(N);\n    for(int i=0; i<100000; i++){\n        if(hs[i].size()){\n            sort(hs[i].rbegin(), hs[i].rend());\n            int v = hs[i][0].second;\n            use[v] = 1;\n            uf.add_avail(v);\n            for(auto& p : hs[i]) uf.unite(p.second, v);\n        }\n        if(ws[i].size()){\n            sort(ws[i].rbegin(), ws[i].rend());\n            int v = ws[i][0].second;\n            use[v] = 1;\n            uf.add_avail(v);\n            for(auto& p : ws[i]) uf.unite(p.second, v);\n        }\n    }\n\n    static vector<pair<int, int>> vs[100000];\n    int avail[100000] = {0};\n    for(int i=0; i<N; i++){\n        int r = uf.find(i);\n        vs[r].emplace_back(use[i], A[i]);\n        if(r == i) avail[i] = uf.avail[i];\n    }\n\n    int64_t ans = 0;\n    for(int i=0; i<N; i++){\n        auto& v = vs[i];\n        sort(v.rbegin(), v.rend());\n        int a = min(avail[i], (int)v.size());\n        for(int j=0; j<a; j++) ans += v[j].second;\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = (int) (1e9 + 7);\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n\n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n\ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n\nstruct BipartiteMatching {\n  vector< vector< int > > graph;\n  vector< int > match, alive, used;\n  int timestamp;\n\n  BipartiteMatching(int n) : graph(n), alive(n, 1), used(n, 0), match(n, -1), timestamp(0) {}\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int idx) {\n    used[idx] = timestamp;\n    for(int i = (int)graph[idx].size() - 1; i >= 0; i--) {\n      auto to = graph[idx][i];\n      int to_match = match[to];\n      if(alive[to] == 0) continue;\n      if(to_match == -1 || (used[to_match] != timestamp && dfs(to_match))) {\n        match[idx] = to;\n        match[to] = idx;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    for(int i = 0; i < graph.size(); i++) {\n      if(alive[i] == 0) continue;\n      if(match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      if(i < match[i]) {\n        cout << i << \"-\" << match[i] << endl;\n      }\n    }\n  }\n};\n\n\nint main() {\n  int N, H, W;\n  cin >> N;\n  cin >> H >> W;\n  vector< int > A(N), B(N), C(N);\n\n  vector< int > ord(N);\n  for(int i = 0; i < N; i++) {\n    cin >> A[i] >> B[i] >> C[i];\n    --A[i], --B[i];\n    ord[i] = i;\n  }\n  sort(begin(ord), end(ord), [&](int a, int b) {\n    return C[a] > C[b];\n  });\n  BipartiteMatching bm(H + W + N);\n  int64 ret = 0;\n  for(int i : ord) {\n    bm.timestamp++;\n    bm.add_edge(H + W + i, A[i]);\n    bm.add_edge(H + W + i, B[i] + H);\n    if(bm.dfs(H + W + i)) ret += C[i];\n  }\n  cout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> ii;\ntypedef tuple<ll, ll, ll> iii;\ntypedef vector<ll> vi;\ntypedef vector<ii> vii;\ntypedef vector<iii> viii;\ntypedef vector<vi> vvi;\ntypedef vector<vii> vvii;\n#define REP(i,n) for (ll i = 0; i < n; ++i)\n#define REPR(i,n) for (ll i = n-1; i >= 0; --i)\n#define FOR(i,m,n) for (int i = m; i < n; ++i)\n#define FORR(i,m,n) for (ll i = n-1; i >= m; --i)\n#define FORE(x,xs) for (const auto& x : xs)\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define ALL(v) v.begin(), v.end()\n#define rALL(v) v.rbegin(), v.rend()\n\nconst int MAX = 1e5+10;\n\n\nint parent[2*MAX];\nint rankb[2*MAX];\n \nvoid init(int x) {\n    for(int i = 0; i <= x; i++)\n    parent[i] = i,rankb[i] = 0;\n}\n \nint root(int x) {\n    return (parent[x]==x) ? x : parent[x]=root(parent[x]);\n}\n \nbool same(int x, int y) {\n    return root(x) == root(y);\n}\n \nvoid unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x == y) return;\n\n    if (rankb[x] < rankb[y])\n        parent[x] = y;\n    else {\n        parent[y] = x;\n        if (rankb[x] == rankb[y]) rankb[x]++;\n    }\n}\n\nll N, H, W;\nviii cards;\n\nll solve() {\n    init(2*MAX);\n    sort(rALL(cards));\n    ll ans = 0;\n    FORE (cd, cards) {\n        int a = get<0>(cd), r = get<1>(cd), c = get<2>(cd);\n        if (!same(r, c+MAX)) {\n            ans += a;\n            unite(r, c+MAX);\n        } else if (!same(0, r)) {\n            ans += a;\n            unite(0, r);\n        }\n    }\n    return ans;\n}\n\nint main() {\n    cin >> N >> H >> W;\n    REP (i, N) {\n        int a, r, c;\n        cin >> r >> c >> a;\n        cards.PB(MT(a,r,c));\n    }\n    cout << solve() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <set>\n#include <unordered_set>\n#include <algorithm>\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\nusing namespace std;\n\ntypedef long long ll;\n\nusing namespace std;\n\nstruct Info {\n  int v;\n  int nEdge;\n  Info(int v) : v(v) {\n    // implement HERE for additional informations\n    nEdge = 0;\n  }\n};\nstruct UF {\n  vector<Info> data;\n  int nDistinct;\n  UF() {}\n  UF(int n) : data(n, -1), nDistinct(n) {}\n  void init(int n) { data.assign(n, -1); nDistinct = n; }\n  int size(void) const { return nDistinct; }\n  int rootOf(int a) { return data[a].v >= 0 ? data[a].v = rootOf(data[a].v) : a; }\n  int count(int a) { return -data[rootOf(a)].v; }\n  bool isSameGroup(int a, int b) { return rootOf(a) == rootOf(b); }\n  bool unify(int a, int b) {\n    int ra = rootOf(a), rb = rootOf(b);\n    if(ra == rb) {\n      // implement HERE for additional informations\n      data[ra].nEdge++;\n      return false;\n    }\n    if(data[ra].v < data[rb].v) swap(ra, rb);\n    data[rb].v += data[ra].v;\n    // implement HERE for additional informations\n    data[rb].nEdge += data[ra].nEdge + 1;\n    data[ra].v = rb;\n    --nDistinct;\n    return true;\n  }\n};\n\nstruct K {\n  int r, c;\n  ll a;\n};\nK vs[100000+5];\nbool operator<(const K &k1, const K &k2) {\n  return k1.a < k2.a;\n}\n\nint main(void) {\n  int n, h, w;\n  scanf(\"%d%d%d\", &n, &h, &w);\n  REP(i, n) {\n    scanf(\"%d%d%lld\", &vs[i].r, &vs[i].c, &vs[i].a);\n    --vs[i].r;\n    --vs[i].c;\n  }\n  sort(vs, vs + n);\n  reverse(vs, vs + n);\n  UF uf(h+w);\n  ll res = 0;\n  REP(i, n) {\n    const K &cur = vs[i];\n    int r1 = uf.rootOf(vs[i].r);\n    int r2 = uf.rootOf(h+vs[i].c);\n    Info &info1 = uf.data[r1];\n    Info &info2 = uf.data[r2];\n    if(r1 == r2) {\n      int nNode = -info1.v;\n      int nEdge = info1.nEdge;\n      if(nEdge+1 <= nNode) {\n        // cerr << \"> \" << cur.a << endl;\n        res += cur.a;\n        uf.unify(r1, r2);\n      }\n    } else {\n      int nNode = -info1.v -info2.v;\n      int nEdge = info1.nEdge + info2.nEdge;\n      if(nEdge+1 <= nNode) {\n        // cerr << \"> \" << cur.a << endl;\n        res += cur.a;\n        uf.unify(r1, r2);\n      }\n    }\n  }\n  cout << res << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<string>\n#include<algorithm>\n#include<cctype>\n#include<cmath>\n#include<cstdlib>\n#include<queue>\n#include<ctime>\n#include<vector>\n#include<set>\n#include<map>\n#include<stack>\nusing namespace std;\n#define xx d[i].x\n#define yy d[i].y\nstruct node {\n\tint x,y,w;\n};\nnode d[200100];\nint n,m,H,W,fa[200100],is[200100];\nlong long Ans;\ninline int sf(int x){return fa[x]==x?x:fa[x]=sf(fa[x]);}\ninline bool cmp(const node a,const node b){return a.w>b.w;}\nint main(){\n    int i,j,k;\n    scanf(\"%d%d%d\",&m,&H,&W);\n    n=H+W;\n    for(i=1;i<=n;i++)fa[i]=i;\n    for(i=1;i<=m;i++){\n      scanf(\"%d%d%d\",&d[i].x,&d[i].y,&d[i].w);\n      d[i].y+=H;\n    }\n    sort(d+1,d+m+1,cmp);\n    for(i=1;i<=m;i++){\n      int x=d[i].x,y=d[i].y;\n      if(sf(x)!=sf(y)){\n      \tif(is[sf(x)]&&is[sf(y)])continue;\n      \tfa[sf(x)]=sf(y);\n      \tis[sf(y)]|=is[sf(x)];\n      \tAns+=1ll*d[i].w;\n      }else {\n      \tif(!is[sf(x)]){\n      \t  is[sf(x)]=1;\n      \t  Ans+=1ll*d[i].w;\n      \t}\n      }\n    }\n    printf(\"%lld\\n\",Ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <cstring>\n#include <algorithm>\n#include <vector>\nint read(){\n\tregister int x = 0;\n\tregister char f = 1, ch = getchar();\n\tfor (; !isdigit(ch); ch = getchar()) if (ch == '-') f ^= 1;\n\tfor (; isdigit(ch); ch = getchar()) x = (x << 1) + (x << 3) + (ch ^ '0');\n\treturn f ? x : -x;\n}\nint n, h, w, fa[200005], g[200005];\nlong long ans;\nstruct node{\n\tint r, c, v;\n\tbool operator < (const node &rhs) const {\n\t\treturn v > rhs.v;\n\t}\n}a[100005];\nint find(int x){\n\treturn fa[x] == x ? x : (fa[x] = find(fa[x]));\n}\nbool merge(int x, int y){\n\tx = find(x), y = find(y);\n\tif (x == y) if (g[x]) return 0; else return g[x] = 1, 1;\n\tif (g[x] && g[y]) return 0;\n\treturn fa[y] = x, g[x] |= g[y], 1;\n}\nint main(){\n\tn = read(), h = read(), w = read();\n\tfor (register int i = 1; i <= n; ++i)\n\t\ta[i].r = read(), a[i].c = read(), a[i].v = read();\n\tstd :: sort(a + 1, a + 1 + n);\n\tfor (register int i = 1; i <= h + w; ++i) fa[i] = i, g[i] = 0;\n\tfor (register int i = 1; i <= n; ++i)\n\t\tif (merge(a[i].r, a[i].c + h)) ans += a[i].v;\n\tprintf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "// verified at https://judge.yosupo.jp/submission/3400\n#ifndef Union_find_hpp\n#define Union_find_hpp\n\n#include <cassert>\n#include <cstddef>\n#include <vector>\n\nclass union_find\n{\n    std::vector<int> link;\n\npublic:\n    explicit union_find(const size_t n) : link(n, -1) {}\n\n    size_t find(size_t x)\n    {\n        assert(x < size());\n        while(link[x] >= 0)\n        {\n            if(link[link[x]] >= 0) link[x] = link[link[x]];\n            x = link[x];\n        }\n        return x;\n    }\n\n    size_t size() const { return link.size(); }\n\n    size_t size(const size_t x)\n    {\n        assert(x < size());\n        return -link[find(x)];\n    }\n\n    bool same(const size_t x, const size_t y)\n    {\n        assert(x < size() && y < size());\n        return find(x) == find(y);\n    }\n\n    size_t unite(size_t x, size_t y)\n    {\n        assert(x < size() && y < size());\n        if((x = find(x)) != (y = find(y)))\n        {\n            if(link[x] > link[y]) std::swap(x, y);\n            link[x] += link[y];\n            link[y] = x;\n        }\n        return x;\n    }\n}; // class union_find\n\n#endif // Union_find_hpp\n\n#include <iostream>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\nint main(int argc, char *argv[])\n{\n    std::ios::sync_with_stdio(false), std::cin.tie(nullptr);\n\n    int n,h,w; cin>>n>>h>>w;\n    vector<vector<pair<int,int>>> cards(100000);\n    for(int i=n,r,c,a; i--; )\n    {\n        cin>>r>>c>>a; --r,--c;\n        cards[a].emplace_back(r,c+h);\n    }\n    union_find uf(h+w);\n    long long ans{};\n    vector<bool> ext(h+w);\n    for(int i=100000; i; --i)\n    {\n        for(auto&& e:cards[i])\n        {\n            int r,c; tie(r,c)=e;\n            r=uf.find(r),c=uf.find(c);\n            if(r!=c)\n            {\n                if(ext[r] and ext[c]) continue;\n                ext[uf.unite(r,c)]=ext[r]||ext[c];\n                ans+=i;\n            }\n            else if(!ext[r])\n            {\n                ext[r]=true;\n                ans+=i;\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nstruct union_find{\n    VI par, sz, data;\n\n    void init(int n){\n        sz.assign(n, 1);\n        data.assign(n, 1);\n        par.resize(n);\n        REP(i,n) par[i] = i;\n    }\n\n    int find(int x){\n        if (par[x] == x) return x;\n        else return par[x] = find(par[x]);\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n\n    void merge(int x, int y){\n        x = find(x);\n        y = find(y);\n        if (x == y){\n            data[x] = 0;\n        }else{\n            sz[y] += sz[x];\n            par[x] = y;\n            data[y] &= data[x];\n        }\n    }\n\n    bool is_tree(int x){\n        return data[find(x)];\n    }\n};\n\nint main() {\n    int n, h, w;\n    cin >> n >> h >> w;\n    vector<pair<ll, P>> p(n);\n    REP(i,n){\n        p[i].second = P(in() - 1, in() - 1);\n        p[i].first = in();\n    }\n    sort(ALL(p));\n    reverse(ALL(p));\n    union_find uf;\n    uf.init(h + w);\n    ll ans = 0;\n    for (auto tmp : p){\n        ll x = tmp.first;\n        int r = tmp.second.first;\n        int c = tmp.second.second;\n        c += h;\n        if (uf.is_tree(r) || uf.is_tree(c)){\n            ans += x;\n            uf.merge(r, c);\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n//#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\nstruct BiMatch{\n    int L,R;\n    vector<vector<int> > G;\n    vector<int> match,level;\n\n    BiMatch(){}\n    BiMatch(int L,int R):L(L),R(R),G(L+R),match(L+R,-1),level(L+R){}\n\n    void add_edge(int u,int v){\n        G[u].emplace_back(v+L);\n        G[v+L].emplace_back(u);\n    }\n\n    bool bfs(){\n        fill(level.begin(),level.end(),-1);\n        queue<int> q;\n        for(int i=0;i<L;i++){\n            if(match[i]<0){\n                level[i]=0;\n                q.emplace(i);\n            }\n        }\n        bool found=false;\n        while(!q.empty()){\n            int v=q.front();q.pop();\n            for(int u:G[v]){\n                if(~level[u]) continue;\n                level[u]=level[v]+1;\n                int w=match[u];\n                if(w==-1){\n                    found=true;\n                    continue;\n                }\n                if(~level[w]) continue;\n                level[w]=level[u]+1;\n                q.emplace(w);\n            }\n        }\n        return found;\n    }\n\n    bool dfs(int v){\n        for(int u:G[v]){\n            if(level[v]+1!=level[u]) continue;\n            level[u]=-1;\n            int w=match[u];\n            if(w<0||dfs(w)){\n                match[v]=u;\n                match[u]=v;\n                level[v]=-1;\n                return true;\n            }\n        }\n        level[v]=-1;\n        return false;\n    }\n\n    int build(){\n        int res=0;\n        while(bfs())\n            for(int i=0;i<L;i++)\n                if(match[i]<0&&dfs(i))\n                    res++;\n        return res;\n    }\n\n};\nusing Flow = int;\nusing Cost = int;\nconst int MAX_V = 300010;\nconst Cost INF = std::numeric_limits<Cost>::max() / 8;\nstruct PrimalDual {\n    struct Edge {\n        int d;\n        Flow c, f;\n        Cost w;\n        int r, is_r;\n        Edge(int d_, Flow c_, Flow f_, Cost w_, int r_, bool is_r_)\n                : d(d_), c(c_), f(f_), w(w_), r(r_), is_r(is_r_) {}\n    };\n\n    int n;\n    std::vector<std::vector<Edge> > g;\n    PrimalDual(int n_) : n(n_), g(std::vector<std::vector<Edge> >(n_)) {}\n\n    void add_edge(int src, int dst, Flow cap, Cost cost) {  // 有向辺\n        int rsrc = g[dst].size();\n        int rdst = g[src].size();\n        g[src].emplace_back(dst, cap, 0, cost, rsrc, false);\n        g[dst].emplace_back(src, cap, cap, -cost, rdst, true);\n    }\n\n    Cost solve(int s, int t, Flow f) {\n        Cost res = 0;\n\n        static Cost h[MAX_V + 10], dist[MAX_V];\n        static int prevv[MAX_V + 10], preve[MAX_V + 10];\n        // std::vector<Cost> h(g.size()), dist(g.size());\n        // std::vector<int> prevv(g.size()), preve(g.size());\n\n        using pcv = std::pair<Cost, int>;\n        std::priority_queue<pcv, std::vector<pcv>, std::greater<pcv> > q;\n        std::fill(h, h + n, 0);\n        while (f > 0) {\n            std::fill(dist, dist + n, INF);\n            dist[s] = 0;\n            q.emplace(0, s);\n            while (q.size()) {\n                Cost cd;\n                int v;\n                std::tie(cd, v) = q.top();\n                q.pop();\n                if (dist[v] < cd) continue;\n                for (int i = 0; i < (int)(g[v].size()); ++i) {\n                    Edge &e = g[v][i];\n                    if (residue(e) == 0) continue;\n                    if (dist[e.d] + h[e.d] > cd + h[v] + e.w) {\n                        dist[e.d] = dist[v] + e.w + h[v] - h[e.d];\n                        prevv[e.d] = v;\n                        preve[e.d] = i;\n                        q.emplace(dist[e.d], e.d);\n                    }\n                }\n            }\n            if (dist[t] == INF) return res;  // 経路が見つからなかった\n\n            // s-t 間最短路に沿って目一杯流す\n            for (int i = 0; i < n; ++i) h[i] += dist[i];\n            Flow d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = std::min(d, residue(g[prevv[v]][preve[v]]));\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.f += d;\n                g[v][e.r].f -= d;\n            }\n        }\n        return res;\n    }\n\n    Flow residue(const Edge &e) { return e.c - e.f; }\n\n    // 流量を表示\n    void show() {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < (int)(g[i].size()); ++j) {\n                Edge &e = g[i][j];\n                if (e.is_r) continue;\n                printf(\"%3d->%3d (flow:%d)\\n\", i, e.d, e.f);\n            }\n        }\n    }\n};\n\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint64 N, H, W;\n\tcin >> N >> H >> W;\n//\tBiMatch bm(H+W, N);\n    PrimalDual pd(H+W+N+2);\n\tusing T = tuple<int64, int64, int64>;\n\tvector<T> v(N);\n\tREP(i, N) {\n\t    int64 a, b, c;\n\t    cin >> a >> b >> c;\n\t    v[i] = T(c, a, b);\n\t}\n\tsort(all(v), greater<>());\n\tREP(i, H) pd.add_edge(H+W+N, i, 1, 0);\n\tREP(i, W) pd.add_edge(H+W+N, H+i, 1, 0);\n\tREP(i, N) {\n\t    int64 V, c, r;\n\t    tie(V, r, c) = v[i];\n//\t    bm.add_edge(r-1, i);\n//\t    bm.add_edge(c-1+H, i);\n\t    pd.add_edge(r-1, H+W+i, 1, -V);\n\t    pd.add_edge(H+c-1, H+W+i, 1, -V);\n\t    pd.add_edge(H+W+i, H+W+N+1, 1, 0);\n\t}\n\tint64 res = pd.solve(H+W+N, H+W+N+1, H+W);\n//\tREP(i, H+W) {\n//\t    if (bm.match[i] != -1) {\n//\t        res += get<0>(v[bm.match[i]-H-W]);\n//\t    }\n//\t}\n\tcout << -res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = (int) (1e9 + 7);\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n\n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n\ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n\nstruct BipartiteMatching {\n  vector< vector< int > > graph;\n  vector< int > match, alive, used;\n  int timestamp;\n\n  BipartiteMatching(int n) : graph(n), alive(n, 1), used(n, 0), match(n, -1), timestamp(0) {}\n\n  void add_edge(int u, int v) {\n    graph[u].push_back(v);\n    graph[v].push_back(u);\n  }\n\n  bool dfs(int idx) {\n    used[idx] = timestamp;\n    for(auto &to : graph[idx]) {\n      int to_match = match[to];\n      if(alive[to] == 0) continue;\n      if(to_match == -1 || (used[to_match] != timestamp && dfs(to_match))) {\n        match[idx] = to;\n        match[to] = idx;\n        return true;\n      }\n    }\n    return false;\n  }\n\n  int bipartite_matching() {\n    int ret = 0;\n    for(int i = 0; i < graph.size(); i++) {\n      if(alive[i] == 0) continue;\n      if(match[i] == -1) {\n        ++timestamp;\n        ret += dfs(i);\n      }\n    }\n    return ret;\n  }\n\n  void output() {\n    for(int i = 0; i < graph.size(); i++) {\n      if(i < match[i]) {\n        cout << i << \"-\" << match[i] << endl;\n      }\n    }\n  }\n};\n\n\nint main() {\n  int N, H, W;\n  cin >> N;\n  cin >> H >> W;\n  vector< int > A(N), B(N), C(N);\n\n  vector< int > ord(N);\n  for(int i = 0; i < N; i++) {\n    cin >> A[i] >> B[i] >> C[i];\n    --A[i], --B[i];\n    ord[i] = i;\n  }\n  sort(begin(ord), end(ord), [&](int a, int b) {\n    return C[a] > C[b];\n  });\n  BipartiteMatching bm(H + W + N);\n  int64 ret = 0;\n  for(int i : ord) {\n    bm.timestamp++;\n    bm.add_edge(H + W + i, A[i]);\n    bm.add_edge(H + W + i, B[i] + H);\n    if(bm.dfs(H + W + i)) ret += C[i];\n  }\n  cout << ret << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#include <fstream>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n\n#define LLINF 1e18+7\n#define N 250000\nll MOD=1e9+7;\n\n\nint G[600][600];\n\nstruct UnionFind{\n    vector<int> par,sizes;\n    UnionFind(int n):par(n+1),sizes(n+1,1){\n        rep2(i,1,n)par[i]=i;\n    }\n    int find(int x){\n        return (x==par[x]?x:par[x]=find(par[x]));\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return ;\n        if(sizes[x]<sizes[y]){\n            swap(x,y);\n        }\n        par[y]=x;\n        sizes[x]+=sizes[y];\n    }\n    bool same(int x,int y) {return (find(x)==find(y));}\n    int size(int x) {return sizes[find(x)];}\n};\nmain(){\n    int n=in();\n    int h=in(),w=in();\n    UnionFind uf(h+w+10);\n    vector<pair<ll,pii>> v;\n    rep(i,n){\n        int r=in(),c=in(),a=in();\n        v.pb({a,{r,c+h}});\n        uf.unite(r,c+h);\n    }\n    vector<vector<pair<ll,pii>>> W(h+w+10);\n    vec t;\n    rep(i,n){\n        int s=uf.find(v[i].second.first);\n        W[s].pb(v[i]);\n        t.pb(s);\n        //cout<<s<<endl;\n    }\n    sort(all(t));\n    ll ans=0;\n    t.erase(unique(all(t)),t.end());\n    for(auto e:t){\n        int m=uf.size(e);\n        sort(all(W[e]),greater<pair<ll,pii>>());\n        UnionFind uf2(h+w+10);\n        vec used(h+w+10);\n        rep(i,W[e].size()){\n            //cout<<W[e][i].first<<\" \"<<W[e][i].second.first<<W[e][i].second.second<<endl;\n            if(!uf2.same(W[e][i].second.first,W[e][i].second.second)){\n                if(used[uf2.find(W[e][i].second.first)]&&used[uf2.find(W[e][i].second.second)]){\n                    continue;\n                }\n                uf2.unite(W[e][i].second.first,W[e][i].second.second);\n                ans+=W[e][i].first;\n            }\n            else{\n                if(!used[uf2.find(W[e][i].second.second)]){\n                    used[uf2.find(W[e][i].second.second)]=1;\n                    ans+=W[e][i].first;\n                }\n            }\n\n        }\n\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\n#include <memory>\n#include <regex>\nusing namespace std;\n\nclass UnionFindTree\n{\nprivate:\n    typedef int T1;\n    typedef int T2;\n\n    static const T1 INIT_DATA;\n    T1 updateData(T1 prev, T2 x){\n        return prev + x;\n    }\n    T1 uniteData(T1 v1, T1 v2){\n        return v1 + v2;\n    }\n\n    int n;\n    vector<int> parent; // 親ノード\n    vector<int> rank;   // 木の高さの上限\n    vector<int> num;    // グループの要素数\n    vector<T1> data;    // グループが持つ値\n\n    int find(int x){\n        if(parent[x] == x)\n            return x;\n        else\n            return parent[x] = find(parent[x]);\n    }\npublic:\n    UnionFindTree(int n){ // コンストラクタ\n        this->n = n;\n        parent.resize(n);\n        for(int i=0; i<n; ++i)\n            parent[i] = i;\n        rank.assign(n, 0);\n        data.assign(n, INIT_DATA);\n        num.assign(n, 1);\n    }\n    void unite(int a, int b){ // aとbのグループを併合\n        if((a = find(a)) != (b = find(b))){\n            if(rank[a] < rank[b]){\n                parent[a] = b;\n                data[b] = uniteData(data[b], data[a]);\n                num[b] += num[a];\n            }else{\n                parent[b] = a;\n                if(rank[a] == rank[b])\n                    ++ rank[a];\n                data[a] = uniteData(data[a], data[b]);\n                num[a] += num[b];\n            }\n            -- n;\n        }\n    }\n    bool same(int a, int b){ // aとbのグループが同じかを調べる\n        return find(a) == find(b);\n    }\n    void update(int a, T2 x){ // ノードの値を更新する\n        a = find(a);\n        data[a] = updateData(data[a], x);\n    }\n    T1 getData(int a){ // グループが持つ値を返す\n        a = find(a);\n        return data[a];\n    }\n    int getNum(){ // グループの数を返す\n        return n;\n    }\n    int getNum(int a){ // aのグループの要素数を返す\n        return num[find(a)];\n    }\n};\nconst UnionFindTree::T1 UnionFindTree::INIT_DATA = 0;\n\nint main()\n{\n    int n, h, w;\n    cin >> n >> h >> w;\n\n    vector<tuple<int, int, int> > v(n);\n    for(int i=0; i<n; ++i){\n        int y, x, a;\n        cin >> y >> x >> a;\n        -- y;\n        -- x;\n        v[i] = make_tuple(a, y, x);\n    }\n    sort(v.rbegin(), v.rend());\n\n    UnionFindTree uft(h+w);\n    long long ans = 0;\n    for(int i=0; i<n; ++i){\n        int a, y, x;\n        tie(a, y, x) = v[i];\n        uft.unite(y, h+x);\n        if(uft.getData(y) < uft.getNum(y)){\n            ans += a;\n            uft.update(y, 1);\n        }\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define REP(i,n) for(ll i=0;i<n;i++)\n#define REP1(i,n) for(ll i=1;i<=n;i++)\n#define FILL(i,n) memset(i,n,sizeof i)\n#define X first\n#define Y second\n#define ET cout << \"\\n\"\n#define SZ(_a) (int)_a.size()\n#define ALL(_a) _a.begin(),_a.end()\n#define pb push_back\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#ifdef bbq\n#define debug(...) {\\\n    fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\", \";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\n#else\n#define debug(...)\n#endif\n\nvector<int> G[100005];\nint mp[100005],mq[200005],fm[100005],vis[100005],nw;\n\nbool bfs(int u)\n{\n\t++nw;\n\tqueue<int> q;\n\tq.push(u),fm[u]=-1,vis[u]=nw;\n\twhile(!q.empty())\n\t{\n\t\tint p=q.front();\n\t\tq.pop();\n\t\tfor(int i:G[p])\n\t\t\tif(!~mq[i])\n\t\t\t{\n\t\t\t\tint ls=i;\n\t\t\t\twhile(~p)\n\t\t\t\t{\n\t\t\t\t\tint tmp=mp[p];\n\t\t\t\t\tmp[mq[ls]=p]=ls,p=fm[p],ls=tmp;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(vis[mq[i]]<nw)\n\t\t\t\tq.push(mq[i]),vis[mq[i]]=nw,fm[mq[i]]=p;\n\t}\n\treturn 0;\n}\n\nstruct mode\n{\n\tint r,c,v;\n\tbool operator<(const mode &a)const{\n\t\treturn v>a.v;\n\t}\n}arr[100005];\n\nint main()\n{\n\tIOS();\n\tll ans=0;\n\tint n,h,w;\n\tcin >> n >> h >> w;\n\tfor(int i=0;i<n;++i)\n\t\tcin >> arr[i].r >> arr[i].c >> arr[i].v,--arr[i].r,--arr[i].c;\n\tsort(arr,arr+n),FILL(mp,-1),FILL(mq,-1);\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tG[i].pb(arr[i].r),G[i].pb(h+arr[i].c);\n\t\tif(bfs(i))\n\t\t\tans+=arr[i].v;\n\t}\n\tcout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define modulo 1000000007\n#define mod(mod_x) ((((long long)mod_x+modulo))%modulo)\n#define Inf 100000000\nstruct unionfind{\n\tvector<int> data;\n\tvector<int> size;\n\tunionfind(int n){\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdata.push_back(i);\n\t\t\tsize.push_back(1);\n\t\t}\n\t}\n\t\n\tint find(int x){\n\t\tif(data[x]==x)return x;\n\t\treturn data[x]=find(data[x]);\n\t}\n\t\n\tbool unite(int x,int y){\n\t\tx=find(x);y=find(y);\n\t\tif(x==y)return false;\n\t\tdata[x]=y;\n\t\tsize[y]+=size[x];\n\t\treturn true;\n\t}\n\t\n\tbool check(int x,int y){\n\t\treturn (find(x)==find(y));\n\t}\n\t\n\tint get_size(int x){\n\t\tint X = find(x);\n\t\treturn size[X];\n\t}\n};\n\n\nint main(){\n\t\n\tint N,H,W;\n\tcin>>N>>H>>W;\n\t\n\tvector<pair<long long,pair<int,int>>> V(N);\n\t\n\tmap<int,int> mp1,mp2;\n\t\n\tfor(int i=0;i<N;i++){\n\t\tcin>>V[i].second.first>>V[i].second.second>>V[i].first;\n\t\tmp1[V[i].second.first]=-1;\n\t\tmp2[V[i].second.second]=-1;\n\t\t\n\t}\n\tint now = 0;\n\tfor(auto &a:mp1){\n\t\ta.second=now;\n\t\tnow++;\n\t}\n\tnow=0;\n\tfor(auto &a:mp2){\n\t\ta.second = now;\n\t\tnow++;\n\t}\n\t\n\tfor(int i=0;i<N;i++){\n\t\tV[i].second.first = mp1[V[i].second.first];\n\t\tV[i].second.second = mp2[V[i].second.second];\n\t}\n\t\n\tunionfind uf(2*N);\n\t\n\tsort(V.begin(),V.end());\n\t\n\tlong long ans = 0;\n\tset<int> NG;\n\tfor(int i=N-1;i>=0;i--){\n\t\tint a = V[i].second.first;\n\t\tint b = V[i].second.second+N;\n\t\tif(NG.count(uf.find(a))&&NG.count(uf.find(b)))continue;\n\t\tans += (long long)V[i].first;\n\t\tbool f = (NG.count(uf.find(a))||NG.count(uf.find(b)));\n\t\tif(!uf.unite(a,b)||f){\n\t\t\tNG.insert(uf.find(a));\n\t\t}\n\t\t\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ※※※ 解答不能 ※※※\n// 以下のソースを勉強する.\n// yutaka1999氏.\n// https://atcoder.jp/contests/jsc2019-qual/submissions/7112552\n#include <bits/stdc++.h>\nusing namespace std;\n#define SIZE 200005\nusing LL = long long;\ntypedef pair<int, int> P;\ntypedef pair<int, P> PP;\n\nstruct UF{\n    int par[SIZE], rank[SIZE], sz[SIZE];\n    \n    void init(int n){\n        for(int i = 0; i < n; i++){\n            par[i] = i;\n            rank[i] = 1;\n            sz[i] = -1;\n        }\n    }\n    int find(int x){\n        if(x == par[x]) return x;\n        return par[x] = find(par[x]);\n    }\n    int get(int v){\n        return sz[find(v)];\n    }\n    void unite(int x,int y){\n        x = find(x);\n        y = find(y);\n        if(x == y){\n            sz[x]++;\n            return;\n        }\n        if(rank[x] < rank[y]){\n            par[x] = y;\n            sz[y] += sz[x];\n            sz[y]++;\n        }else{\n            par[y] = x;\n            sz[x] += sz[y];\n            sz[x]++;\n            if(rank[x] == rank[y]) rank[x]++;\n        }\n    }\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n}uf;\n\nvector<PP> edge;\nbool use[SIZE];\n\nint main(){\n    int n, h, w;\n    scanf(\"%d %d %d\",&n, &h, &w);\n    for(int i = 0; i < n; i++){\n        int r, c, a;\n        scanf(\"%d %d %d\",&r, &c, &a);\n        r--, c--;\n        edge.push_back(PP(a, P(r, c + h)));\n    }\n    sort(edge.begin(),edge.end(),greater<PP>());\n    uf.init(h + w + 2);\n    LL ret = 0;\n    for(int i = 0; i < edge.size(); i++){\n        P p = edge[i].second;\n        int a = uf.get(p.first);\n        int b = uf.get(p.second);\n        if(a + b + 1 <= 0){\n            uf.unite(p.first, p.second);\n            ret += edge[i].first;\n            use[i] = true;\n            // printf(\"* %d %d : %d\\n\",p.first,p.second,edge[i].first);\n        }\n    }\n    printf(\"%lld\\n\", ret);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\n\nconst int siz=2e5+5;\nvector<vector<pair<int,pair<int,int> > > >adj;\nint parent[siz];\nint sz[siz];\nint vis_ind[siz];\nint vis[siz];\nint mm[siz];\nint find_parent(int ver)\n{\n    if(ver==parent[ver])\n        return ver;\n    return parent[ver]=find_parent(parent[ver]);\n}\n\nbool merge(int a,int b)\n{\n    a=find_parent(a);\n    b=find_parent(b);\n    if(a!=b)\n    {\n        if(sz[a]<sz[b])\n            swap(a,b);\n        sz[a]+=sz[b];\n        parent[b]=a;\n        mm[a]=min(mm[a],mm[b]);\n        return true;\n    }\n    return false;\n}\n\nvector<pair<int,pair<int,int> > >temp;\nint cnt=0;\nvoid dfs(int ver)\n{\n    if(vis_ind[ver]==0)\n        cnt++;\n    vis_ind[ver]=1;\n    for(auto i:adj[ver])\n    {\n        if(!vis[i.second.second])\n        {\n            vis[i.second.second]=1;\n            temp.push_back({i.second.first,{i.first,ver}});\n            dfs(i.first);\n        }\n    }\n}\n\nsigned main()\n{\n \nios_base::sync_with_stdio(false);\ncin.tie(NULL);  \ncout.tie(0);   \n \n#ifndef ONLINE_JUDGE\n    if(fopen(\"INPUT.txt\",\"r\"))\n    {\n    freopen (\"INPUT.txt\" , \"r\" , stdin);\n    freopen (\"OUTPUT.txt\" , \"w\" , stdout);\n    }\n#endif      \n\n    int n,h,w;\n    cin>>n>>h>>w;\n    int x,y,z;\n    adj.resize(2e5+5);\n    int lim=1e5;\n    int tot=0;\n    int mn=1e18;\n    \n    for(int i=0;i<n;i++)\n    {\n        cin>>x>>y>>z;\n        tot+=z;\n        mn=min(mn,z);\n        adj[x].push_back({y+lim,{z,i}});\n        adj[y+lim].push_back({x,{z,i}});\n    }    \n\n    for(int i=1;i<=2*lim;i++)\n    {\n        mm[i]=1;\n        parent[i]=i;\n        sz[i]=1;\n    }\n    int ans=0;\n    for(int i=1;i<=2*lim;i++)\n    {\n        if(!vis_ind[i])\n        {\n            temp.clear();\n            cnt=0;\n            dfs(i);\n            sort(temp.begin(),temp.end(),greater<>());\n            int mx=0;\n            for(auto j:temp)\n            {\n                if(mm[find_parent(j.second.first)]+mm[find_parent(j.second.second)]==0)\n                    continue;\n                int z=merge(j.second.first,j.second.second);\n                if(z==0)\n                {\n                    mm[find_parent(j.second.first)]=0;\n                }\n                ans+=j.first;\n            }\n\n            ans+=mx;\n            \n        }\n    }\n\n    cout<<ans;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tif(a<0LL)return 0;\n\tif(b<0LL)return 0;\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n// ここから編集しろ\n\nnamespace MCF {\n\t// required <string.h> <vector> <queue> <algorithm>\n\t#define MAXN 310000\n\t#define MAXM 2100000\n\t#define wint int\n\t#define cint long long\n\tconst wint wEPS = 0;\n\tconst wint wINF = 1001001001;\n\tconst cint cEPS = 0;\n\tconst cint cINF = 100100100100100LL;\n\tint n, m, ptr[MAXN], next[MAXM], zu[MAXM];\n\twint capa[MAXM], tof;\n\tcint cost[MAXM], toc, d[MAXN], pot[MAXN];\n\tint vis[MAXN], pree[MAXN];\n\tvoid init(int _n) {\n\t\tn = _n; m = 0; memset(ptr, ~0, n * 4);\n\t}\n\tvoid ae(int u, int v, wint w, cint c) {\n\t\tnext[m] = ptr[u]; ptr[u] = m; zu[m] = v; capa[m] = w; cost[m] = +c; ++m;\n\t\tnext[m] = ptr[v]; ptr[v] = m; zu[m] = u; capa[m] = 0; cost[m] = -c; ++m;\n\t}\n\tbool solve(int src, int ink, wint flo = wINF) {\n\t\tint i, u, v;\n\t\twint f;\n\t\tcint c, cc;\n\t\tmemset(pot, 0, n * sizeof(cint));\n\t\t//*\n\t\tfor (bool cont = 1; cont; ) {\n\t\t\tcont = 0;\n\t\t\tfor (u = 0; u < n; ++u) for (i = ptr[u]; ~i; i = next[i]) if (capa[i] > wEPS) {\n\t\t\t\tif (pot[zu[i]] > pot[u] + cost[i] + cEPS) {\n\t\t\t\t\tpot[zu[i]] = pot[u] + cost[i]; cont = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//*/\n\t\tfor (toc = 0, tof = 0; tof + wEPS < flo; ) {\n\t\t\ttypedef pair<cint,int> node;\n\t\t\tpriority_queue< node,vector<node>,greater<node> > q;\n\t\t\tfor (u = 0; u < n; ++u) { d[u] = cINF; vis[u] = 0; }\n\t\t\tfor (q.push(make_pair(d[src] = 0, src)); !q.empty(); ) {\n\t\t\t\tc = q.top().first; u = q.top().second; q.pop();\n\t\t\t\tif (vis[u]++) continue;\n\t\t\t\tfor (i = ptr[u]; ~i; i = next[i]) if (capa[i] > wEPS) {\n\t\t\t\t\tcc = c + cost[i] + pot[u] - pot[v = zu[i]];\n\t\t\t\t\tif (d[v] > cc + cEPS) { q.push(make_pair(d[v] = cc, v)); pree[v] = i; }\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!vis[ink]) return 0;\n\t\t\tf = flo - tof;\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; f=min(f,capa[i]); }\n\t\t\tfor (v = ink; v != src; v = zu[i ^ 1]) { i = pree[v]; capa[i] -= f; capa[i ^ 1] += f; }\n\t\t\ttof += f;\n\t\t\ttoc += f * (d[ink] - pot[src] + pot[ink]);\n\t\t\tfor (u = 0; u < n; ++u) pot[u] += d[u];\n\t\t}\n\t\treturn 1;\n\t}\n}\nint X[110000];\nint Y[110000];\nint C[110000];\nint main(){\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d%d\",X+i,Y+i,C+i);X[i]--;Y[i]--;\n\t}\n\tMCF::init(a+b+c+3);\n\tint S=a+b+c;\n\tint T=a+b+c+1;\n\tfor(int i=0;i<b;i++){\n\t\tMCF::ae(i+a,T,1,0);\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tMCF::ae(i+a+b,T,1,0);\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tMCF::ae(S,i,1,-C[i]);\n\t\tMCF::ae(i,a+X[i],1,0);\n\t\tMCF::ae(i,a+b+Y[i],1,0);\n\t}\n\tMCF::solve(S,T);\n\tprintf(\"%lld\\n\",-MCF::toc);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"functional\"\n\nusing namespace std;\n\n//constexpr long long int MOD = 1000000007;\nconstexpr  int MOD = 1000000007;\n//constexpr  int MOD = 998244353;\n//constexpr  long long int MOD = 998244353;\nconstexpr double EPS = 1e-8;\n\n// int N, M, K, H, W, L, R;\nlong long int N, M, K, H, W, L, R;\n\nstruct Node {\n\tint x, y, score;\n\tNode(const int a, const int b, const int c) {\n\t\ty = a, x = b, score = c;\n\t}\n\tbool operator<(const Node&n)const {\n\t\treturn score < n.score;\n\t}\n};\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> H >> W;\n\tvector<Node>node;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> L >> R >> K;\n\t\tnode.push_back(Node(L - 1, R - 1, K));\n\t}\n\tsort(node.begin(), node.end());\n\treverse(node.begin(), node.end());\n\tlong long int ans = 0;\n\tvector<int>hindex(H, -1);\n\tvector<int>windex(W, -1);\n\tvector<int>hused(H, 0);\n\tvector<int>wused(W, 0);\n\tfor (int i = 0; i < N; i++) {\n\t\tif (hindex[node[i].y] == -1) {\n\t\t\tans += node[i].score;\n\t\t\thindex[node[i].y] = i;\n\t\t}\n\t\telse if (windex[node[i].x] == -1) {\n\t\t\tans += node[i].score;\n\t\t\twindex[node[i].x] = i;\n\t\t}\n\t\telse {\n\t\t\t{\n\t\t\t\tint y, x;\n\t\t\t\ty = node[i].y;\n\t\t\t\tx = node[i].x;\n\t\t\t\tstack<pair<int,int>>Q;\n\t\t\t\tint tate = 1;\n\t\t\t\tbool rev = true;\n\t\t\t\twhile (1) {\n\t\t\t\t\t//cout << y << \" \" << x << endl;\n\t\t\t\t\tif (tate) {\n\t\t\t\t\t\tif (wused[x]) break;\n\t\t\t\t\t\tint box = windex[x];\n\t\t\t\t\t\tif (box == -1) {\n\t\t\t\t\t\t\tans += node[i].score;\n\t\t\t\t\t\t\trev = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twindex[x] = i;\n\t\t\t\t\t\ty = node[box].y;\n\t\t\t\t\t\tQ.push({ box,tate });\n\t\t\t\t\t\twused[x] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (hused[y])break;\n\t\t\t\t\t\tint box = hindex[y];\n\t\t\t\t\t\tif (box == -1) {\n\t\t\t\t\t\t\tans += node[i].score;\n\t\t\t\t\t\t\trev = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thindex[y] = i;\n\t\t\t\t\t\tx = node[box].x;\n\t\t\t\t\t\tQ.push({ box,tate });\n\t\t\t\t\t\thused[y] = 1;\n\t\t\t\t\t}\n\t\t\t\t\ttate ^= 1;\n\t\t\t\t}\n\t\t\t\tif (rev) {\n\t\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\t\tint cn = Q.top().first;\n\t\t\t\t\t\tint tate = Q.top().second;\n\t\t\t\t\t\tif (tate) {\n\t\t\t\t\t\t\twindex[node[cn].x] = cn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\thindex[node[cn].y] = cn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tQ.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t{\n\t\t\t\tint y, x;\n\t\t\t\ty = node[i].y;\n\t\t\t\tx = node[i].x;\n\t\t\t\tstack<pair<int, int>>Q;\n\t\t\t\tint tate = 0;\n\t\t\t\tbool rev = true;\n\t\t\t\twhile (1) {\n\t\t\t\t\tif (tate) {\n\t\t\t\t\t\tif (wused[x]) break;\n\t\t\t\t\t\tint box = windex[x];\n\t\t\t\t\t\tif (box == -1) {\n\t\t\t\t\t\t\tans += node[i].score;\n\t\t\t\t\t\t\trev = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\twindex[x] = i;\n\t\t\t\t\t\ty = node[box].y;\n\t\t\t\t\t\tQ.push({ box,tate });\n\t\t\t\t\t\twused[x] = 1;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tif (hused[y])break;\n\t\t\t\t\t\tint box = hindex[y];\n\t\t\t\t\t\tif (box == -1) {\n\t\t\t\t\t\t\tans += node[i].score;\n\t\t\t\t\t\t\trev = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\thindex[y] = i;\n\t\t\t\t\t\tx = node[box].x;\n\t\t\t\t\t\tQ.push({ box,tate });\n\t\t\t\t\t\thused[y] = 1;\n\t\t\t\t\t}\n\t\t\t\t\ttate ^= 1;\n\t\t\t\t}\n\t\t\t\tif (rev) {\n\t\t\t\t\twhile (!Q.empty()) {\n\t\t\t\t\t\tint cn = Q.top().first;\n\t\t\t\t\t\tint tate = Q.top().second;\n\t\t\t\t\t\tif (tate) {\n\t\t\t\t\t\t\twindex[node[cn].x] = cn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\thindex[node[cn].y] = cn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tQ.pop();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\ntypedef long long ll;\n#define inf 0x3f3f3f3f\nint n,h,w;\nint x[maxn],y[maxn];\nll a[maxn];\nset<pair<ll,int> > qx[maxn],qy[maxn];\nvector<pair<ll,int> >cards;\nll ax,ay;\nbool ux[maxn],uy[maxn],usd[maxn];\nint cx[maxn],cy[maxn];\nqueue<int> que;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&h,&w);\n//\tmemset(cx,-1,sizeof(cx));\n//\tmemset(cy,-1,sizeof(cy));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%lld\",&x[i],&y[i],&a[i]);\n\t\tx[i]--;\n\t\ty[i]--;\n\t\tcx[x[i]]++;\n\t\tcy[y[i]]++;\n\t}\n    ll ans=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tqx[x[i]].insert(make_pair(a[i],i));\n\t\tqy[y[i]].insert(make_pair(a[i],i));\n\t}\n\tfor(int i=0;i<n;i++)if(!usd[i])\n\t\tcards.push_back(make_pair(a[i],i));\n\n//    sort(cards.begin(),cards.end());\n//    reverse(cards.begin(),cards.end());\n\trandom_shuffle(cards.begin(), cards.end());\n    for(int _=0;_<cards.size();_++)\n    {\n    \tint i=cards[_].second;\n\t//\tcout<<i<<\" \"<<x[i]<<\" \"<<y[i]<<\" \"<<qx[x[i]].top().second<<\" \"<<qy[y[i]].top().second<<endl;\n        qx[x[i]].erase(make_pair(a[i],i));\n        qy[y[i]].erase(make_pair(a[i],i));\n        if(ux[x[i]]&&uy[y[i]])continue;\n        if(ux[x[i]])\n        \tuy[y[i]]=1;\n        else if(uy[y[i]])\n        \tux[x[i]]=1;\n        else\n\t\t{\n\t\t\tax=qx[x[i]].empty()?-inf:(*(qx[x[i]].rbegin())).first;\n\t\t\tay=qy[y[i]].empty()?-inf:(*(qy[y[i]].rbegin())).first;\n\t\t\tif(ax<ay)\n\t\t\t{\n        //   \tcout<<\"puthang \"<<x[i]<<endl;\n            \tux[x[i]]=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n      \t//    \tcout<<\"putlie \"<<y[i]<<endl;\n \t    \t\tuy[y[i]]=1;\n \t    \t}\n        }\n        ans+=a[i];\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <array>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\n#include <memory>\n#include <regex>\nusing namespace std;\n\nclass Edge{\npublic:\n    int to, cap, rev;\n    long long cost;\n    Edge(){};\n    Edge(int to0, int cap0, long long cost0){to = to0; cap = cap0, cost = cost0;}\n    Edge(int to0, int cap0, long long cost0, int rev0){to = to0; cap = cap0; cost = cost0; rev = rev0;}\n};\n\nint maxFlow(const vector<vector<Edge> >& edges0, int source, int sink)\n{\n    static vector<vector<Edge> > edges;\n    static vector<bool> used;\n\n    class Func{\n    public:\n        static int dfs(int s, int t, int f){\n            if(s == t)\n                return f;\n            used[s] = true;\n            for(unsigned i=0; i<edges[s].size(); ++i){\n                Edge& e = edges[s][i];\n                if(!used[e.to] && e.cap > 0){\n                    int g = dfs(e.to, t, min(f, e.cap));\n                    if(g > 0){\n                        e.cap -= g;\n                        edges[e.to][e.rev].cap += g;\n                        return g;\n                    }\n                }\n            }\n            return 0;\n        }\n    };\n\n    if(source == sink)\n        return INT_MAX;\n\n    int n = edges0.size();\n    edges.assign(n, vector<Edge>());\n    for(int i=0; i<n; ++i){\n        for(unsigned j=0; j<edges0[i].size(); ++j){\n            const Edge& e = edges0[i][j];\n            edges[i].push_back(Edge(e.to, e.cap, 0, edges[e.to].size()));\n            edges[e.to].push_back(Edge(i, 0, 0, edges[i].size()-1));\n        }\n    }\n\n    int ret = 0;\n    for(;;){\n        used.assign(n, false);\n        int f = Func::dfs(source, sink, INT_MAX);\n        if(f == 0)\n            return ret;\n        ret += f;\n    }\n}\n\nlong long minCostFlow(vector<vector<Edge> >& edges0, int source, int sink, int flow, bool isDetail = false)\n{\n    int n = edges0.size();\n    vector<vector<Edge> > edges = edges0;\n    for(int i=0; i<n; ++i){\n        for(unsigned j=0; j<edges0[i].size(); ++j){\n            const Edge& e = edges0[i][j];\n            edges[i][j].rev = edges[e.to].size();\n            edges[e.to].push_back(Edge(i, 0, -e.cost, j));\n        }\n    }\n\n    vector<long long> h(n, 0);\n    vector<int> prevV(n);\n    vector<int> prevE(n);\n\n    long long ret = 0;\n    while(flow > 0){\n        vector<long long> dist(n, LLONG_MAX);\n        dist[source] = 0;\n        priority_queue<pair<long long,int> ,vector<pair<long long,int> >, greater<pair<long long,int> > > q;\n        q.push(make_pair(0, source));\n\n        while(!q.empty()){\n            pair<long long, int> p = q.top();\n            q.pop();\n            int v = p.second;\n            if(dist[v] < p.first)\n                continue;\n            for(unsigned i=0; i<edges[v].size(); ++i){\n                Edge e = edges[v][i];\n                if(e.cap > 0 && dist[v] + e.cost + h[v] - h[e.to] < dist[e.to]){\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevV[e.to] = v;\n                    prevE[e.to] = i;\n                    q.push(make_pair(dist[e.to], e.to));\n                }\n            }\n        }\n        if(dist[sink] == LLONG_MAX){\n            return -1;\n        }\n        for(int i=0; i<n; ++i)\n            h[i] += dist[i];\n\n        int g = flow;\n        for(int i=sink; i!=source; i=prevV[i])\n            g = min(g, edges[prevV[i]][prevE[i]].cap);\n        for(int i=sink; i!=source; i=prevV[i]){\n            Edge& e = edges[prevV[i]][prevE[i]];\n            e.cap -= g;\n            edges[i][e.rev].cap += g;\n        }\n        flow -= g;\n        ret += g * h[sink];\n    }\n\n    if(isDetail){\n        for(int i=0; i<n; ++i){\n            for(unsigned j=0; j<edges0[i].size(); ++j){\n                edges0[i][j].cap -= edges[i][j].cap;\n            }\n        }\n    }\n\n    return ret;\n}\n\nconst int MAX = 100000;\n\nint main()\n{\n    int n, h, w;\n    cin >> n >> h >> w;\n\n    vector<vector<Edge> > edges(h+w+n+2);\n    int source = edges.size() - 2;\n    int sink = edges.size() - 1;\n    for(int i=0; i<h+w; ++i)\n        edges[source].push_back(Edge(i, 1, 0));\n\n    for(int i=0; i<n; ++i){\n        int y, x, a;\n        cin >> y >> x >> a;\n        -- y;\n        -- x;\n        edges[y].push_back(Edge(h+w+i, 1, MAX-a));\n        edges[h+x].push_back(Edge(h+w+i, 1, MAX-a));\n        edges[h+w+i].push_back(Edge(sink, 1, 0));\n    }\n\n    int flow = maxFlow(edges, source, sink);\n    long long ans = minCostFlow(edges, source, sink, flow);\n    ans = MAX * (long long)flow - ans;\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n  Id: hhw52818\n  Task: a\n  Lang: C++\n*/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define foru(i, l, r) for(register int i = l; i <= r; i++)\n#define ford(i, r, l) for(register int i = r; i >= l; i--)\n\ntypedef long long ll;\nconst int maxn = 1e5 + 5;\n\nint n, m, N;\nll ans;\n\n#define mk make_pair\n#define fir first\n#define sec second\n\nstruct Heap {\n  priority_queue<pair<int, int> > ins;\n  priority_queue<pair<int, int> > del;\n  void clear() {\n    while(!ins.empty()) ins.pop();\n    while(!del.empty()) del.pop();\n  }\n  void insert(pair<int, int> pii) { ins.push(pii); }\n  void erase(pair<int, int> pii) { del.push(pii); }\n  pair<int, int> top() { return ins.top(); }\n  bool empty() {\n    while(!ins.empty() && !del.empty())\n      if(ins.top() == del.top())\n        ins.pop(), del.pop();\n      else break;\n    return ins.empty();\n  }\n} a[maxn], b[maxn];\n\nint U[maxn], V[maxn], X[maxn];\nint Count[maxn];\n\nll solve() {\n  for(int i = 1; i <= n; i++) a[i].clear();\n  for(int i = 1; i <= m; i++) b[i].clear();\n  memset(Count, 0, sizeof(Count));\n  for(int i = 1; i <= N; i++) {\n    a[U[i]].insert(mk(X[i], V[i]));\n    b[V[i]].insert(mk(X[i], U[i]));\n    Count[V[i]]++;\n  }\n  ll res = 0;\n  for(int i = 1; i <= n; i++) {\n    if(!a[i].empty()) {\n      pair<int, int> now = a[i].top();\n      if(Count[now.sec] > 1) {\n        b[now.sec].erase(mk(now.fir, i));\n        res += (ll)now.fir; continue;\n      } else {\n        a[i].erase(now);\n        if(!a[i].empty()) now = a[i].top();\n        b[now.sec].erase(mk(now.fir, i));\n        res += (ll)now.fir; continue;\n      }\n    }\n  }\n  for(int i = 1; i <= m; i++) {\n    if(!b[i].empty()) {\n      pair<int, int> now = b[i].top();\n      res += (ll)now.fir;\n    }\n  }\n  return res;\n}\n\nint main() {\n  //  freopen(\"a.in\", \"r\", stdin);\n  //  freopen(\"a.out\", \"w\", stdout);\n  scanf(\"%d%d%d\", &N, &n, &m);\n  for(int i = 1; i <= N; i++) {\n    scanf(\"%d\", &U[i]);\n    scanf(\"%d\", &V[i]);\n    scanf(\"%d\", &X[i]);\n  } ans = 0;\n  ans = max(ans, solve());\n  for(int i = 1; i <= N; i++) swap(U[i], V[i]);\n  ans = max(ans, solve());\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n/*\n  ;    11;    1;    6,12;    13;          ;\n  7,8;      ;     ;        ;      ;          ;\n  5;      ;     ;        ;      ;         4;\n  ;      ;     ;        ;      ;    2,3,10;\n  ;      ;     ;        ;      ;         9;\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<chrono>\n#include<climits>\n#include<numeric>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<random>\n#include<set>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<vector>\n#include<cassert>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<string>\nusing namespace std;\n \n#define rep(i, a, b) for(auto i = (a); i < (b); i++)\n#define rrep(i, a, b) for(auto i = (a); i > (b); i--)\n#define all(v) (v).begin(), (v).end()\n#define print(v) {for(auto x : v) cout << x << ' '; cout << endl;}\n#define printn(v, n) {for(int _i = 0; _i < n; _i++) cout << *(v + _i) << ' '; cout << endl;}\n \ntypedef unsigned long long ull;\ntypedef long long ll;\n \ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n \ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n \nconst int MAXN = 1e5 + 20;\nint n, h, w;\nvector<long long> a[MAXN], a0[MAXN];\n\nlong long solve() {\n\tlong long res = 0;\n\tsort(a, a + n, [](const vector<long long> & x, const vector<long long> & y) {\n    \treturn x[1] < y[1] || (x[1] == y[1] && x[2] < y[2]);\n    });\n    int i = 0, j;\n    while(i < n) {\n    \tlong long tmp = 0, tmp_id = -1;\n    \tfor(j = i; j < n && a[j][1] == a[i][1]; j++) {\n    \t\tif(a[j][0] > tmp) {\n    \t\t\ttmp = a[j][0];\n    \t\t\ttmp_id = j;\n    \t\t}\n    \t}\n    \ta[tmp_id][0] = 0;\n    \tres += tmp;\n    \ti = j;\n    }\n\n    sort(a, a + n, [](const vector<long long> & x, const vector<long long> & y) {\n    \treturn x[2] < y[2] || (x[2] == y[2] && x[1] < y[1]);\n    });\n    i = 0;\n    while(i < n) {\n    \tlong long tmp = 0, tmp_id = -1;\n    \tfor(j = i; j < n && a[j][2] == a[i][2]; j++) {\n    \t\tif(a[j][0] > tmp) {\n    \t\t\ttmp = a[j][0];\n    \t\t\ttmp_id = j;\n    \t\t}\n    \t}\n    \t// a[tmp_id][0] = 0;\n    \tres += tmp;\n    \ti = j;\n    }\n    return res;\n}\n\n\nint main() {\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> n >> h >> w;\n    for(int i = 0; i < n; i++) {\n    \ta[i].resize(3);\n    \tcin >> a[i][1] >> a[i][2] >> a[i][0];\n    \ta0[i] = a[i];\n    }\n\n    long long res = solve();\n\n    for(int i = 0; i < n; i++) {\n    \ta[i] = a0[i];\n    \tswap(a[i][1], a[i][2]);\n    }\n    res = max(res, solve());\n\n    cout << res << endl;\n\n    return 0;\n}\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>  \n#include <algorithm>  \n#include <assert.h>\n#include <bitset>\n#include <cmath>  \n#include <complex>  \n#include <deque>  \n#include <functional>  \n#include <iostream>  \n#include <limits.h>  \n#include <map>  \n#include <math.h>  \n#include <queue>  \n#include <set>  \n#include <stdlib.h>  \n#include <string.h>  \n#include <string>  \n#include <time.h>  \n#include <unordered_map>  \n#include <unordered_set>  \n#include <vector>  \n#include <chrono>\n#include <random>\n#include <time.h>\n#include <fstream>\n#define ll long long\n#define rep2(i,a,b) for(ll i=a;i<=b;++i)\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define rep3(i,a,b) for(ll i=a;i>=b;i--)\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pq priority_queue<int>\n#define pqg priority_queue<int,vector<int>,greater<int>>\n#define pb push_back\n#define vec vector<int>\n#define vecll vector<ll>\n#define vecpii vector<pii>\n#define endl \"\\n\"\n#define all(c) begin(c),end(c)\nusing namespace std;\nint in() {int x;scanf(\"%d\",&x);return x;}\nll lin() {ll x;scanf(\"%lld\",&x);return x;}\n\n\n#define LLINF 1e18+7\n#define N 250000\nll MOD=1e9+7;\n\n\nint G[600][600];\n\nstruct UnionFind{\n    vector<int> par,sizes;\n    UnionFind(int n):par(n+1),sizes(n+1,1){\n        rep2(i,1,n)par[i]=i;\n    }\n    int find(int x){\n        return (x==par[x]?x:par[x]=find(par[x]));\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return ;\n        if(sizes[x]<sizes[y]){\n            swap(x,y);\n        }\n        par[y]=x;\n        sizes[x]+=sizes[y];\n    }\n    bool same(int x,int y) {return (find(x)==find(y));}\n    int size(int x) {return sizes[find(x)];}\n};\nmain(){\n    int n=in();\n    int h=in(),w=in();\n    UnionFind uf(h+w+10);\n    vector<pair<ll,pii>> v;\n    rep(i,n){\n        int r=in(),c=in(),a=in();\n        v.pb({a,{r,c+h}});\n        uf.unite(r,c+h);\n    }\n    vector<vector<pair<ll,pii>>> W(n);\n    vec t;\n    rep(i,n){\n        int s=uf.find(v[i].second.first);\n        W[s].pb(v[i]);\n        t.pb(s);\n        //cout<<s<<endl;\n    }\n    sort(all(t));\n    ll ans=0;\n    t.erase(unique(all(t)),t.end());\n    for(auto e:t){\n        int m=uf.size(e);\n        sort(all(W[e]),greater<pair<ll,pii>>());\n        UnionFind uf2(h+w+10);\n        vec used(h+w+10);\n        rep(i,W[e].size()){\n            //cout<<W[e][i].first<<\" \"<<W[e][i].second.first<<W[e][i].second.second<<endl;\n            if(!uf2.same(W[e][i].second.first,W[e][i].second.second)){\n                if(used[uf2.find(W[e][i].second.first)]&&used[uf2.find(W[e][i].second.second)]){\n                    continue;\n                }\n                uf2.unite(W[e][i].second.first,W[e][i].second.second);\n                ans+=W[e][i].first;\n            }\n            else{\n                if(!used[uf2.find(W[e][i].second.second)]){\n                    used[uf2.find(W[e][i].second.second)]=1;\n                    ans+=W[e][i].first;\n                }\n            }\n\n        }\n\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MAXN = 3e5+10;\n\nint bit[MAXN];\nint par[MAXN];\nint parent(int i) {\n  return par[i] < 0 ? i: (par[i]=parent(par[i]));\n}\n\nbool merge(int a, int b) {\n  int x = parent(a);\n  int y = parent(b);\n  if (x==y) {\n    if (bit[x]) return false;\n    else return bit[x] = 1;\n  }\n  if (bit[x] && bit[y]) return false;\n  bit[x]+=bit[y];\n  par[y] = x;\n  return 1;\n}\n\nint gc=0;\nmap<pair<int,int>, int> m;\nint gid(int r, int c) {\n  auto p = make_pair(r,c);\n  if (m.count(p)) {\n    return m[p];\n  }\n  else {\n    return  m[p] = gc++;\n  }\n}\n\nint n, h, w;\n\nint main(){\n  cin.tie(0); ios_base::sync_with_stdio(0);\n  cin >> n >> h >> w;\n  memset(par, -1,sizeof par);\n  vector<vector<int>> v;\n  for(int i=0;i<n;i++) {\n    int r, c, w;\n    cin >> r >> c >> w;\n    v.push_back({w,r,c});\n  }\n  sort(v.rbegin(), v.rend());\n  ll ans = 0;\n  for(auto p: v) {\n    if (merge(gid(p[1],0), gid(p[2],1))){\n      ans+=p[0];\n      //cerr << \"ADDING \" << p[1] << \" \" << p[2] << \" \" << p[0] <<endl;\n    }\n    //else //cerr << \"NOT ADDING \" << p[1] << \" \" << p[2] << \" \" << p[0] <<endl;\n  }\n  cout << ans <<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXN=100005;\nstruct edge{int x,y,c,d,next;}a[6*MAXN];int len=1,last[3*MAXN];\nvoid ins(int x,int y,int c,int d)\n{\n\tlen++;a[len].x=x;a[len].y=y;a[len].c=c;a[len].d=d;\n\ta[len].next=last[x];last[x]=len;\n\tlen++;a[len].x=y;a[len].y=x;a[len].c=0;a[len].d=-d;\n\ta[len].next=last[y];last[y]=len;\n}\ndeque<int> li;\nbool v[3*MAXN];\nLL d[3*MAXN];\nint st,ed,pre[3*MAXN],tmp[3*MAXN];\nbool spfa()\n{\n\tmemset(v,false,sizeof(v));v[st]=true;\n\tmemset(d,-63,sizeof(d));d[st]=0;\n\tli.push_back(st);\n\twhile(!li.empty())\n\t{\n\t\tint x=li.front();li.pop_front();v[x]=false;\n\t\tfor(int k=last[x];k;k=a[k].next)\n\t\t{\n\t\t\tint y=a[k].y;\n\t\t\tif(d[y]<d[x]+a[k].d&&a[k].c)\n\t\t\t{\n\t\t\t\td[y]=d[x]+a[k].d;\n\t\t\t\tpre[y]=x;tmp[y]=k;\n\t\t\t\tif(!v[y])\n\t\t\t\t{\n\t\t\t\t\tv[y]=true;\n\t\t\t\t\tif(!li.size()||d[y]>d[li.front()])li.push_front(y);\n\t\t\t\t\telse li.push_back(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn d[ed]>0;\n}\nLL mcf()\n{\n\tLL minn,ret=0;\n\twhile(spfa())\n\t{\n\t\tint x=ed;minn=999999999;\n\t\twhile(x!=st)\n\t\t{\n\t\t\tminn=min(minn,(LL)a[tmp[x]].c);\n\t\t\tx=pre[x];\n\t\t}\n\t\tret+=1LL*minn*d[ed];x=ed;\n\t\twhile(x!=st)\n\t\t{\n\t\t\ta[tmp[x]].c-=minn;a[tmp[x]^1].c+=minn;\n\t\t\tx=pre[x];\n\t\t}\n\t}\n\treturn ret;\n}\nint n,A,B;\nint via[MAXN],vib[MAXN];\nint main()\n{\n\tn=read();A=read();B=read();\n\tst=A+B+n+1;ed=st+1;\n\tint cnt1=0,cnt2=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u=read(),v=read(),C=read();\n\t\tif(!via[u])via[u]=++cnt1;\n\t\tif(!vib[v])vib[v]=++cnt2;\n\t\tins(i,via[u]+n,1,0);ins(i,vib[v]+n+A,1,0);\n\t\tins(st,i,1,C);\n\t}\n\tfor(int i=1;i<=A;i++)if(via[i])ins(via[i]+n,ed,1,0);\n\tfor(int i=1;i<=B;i++)if(vib[i])ins(vib[i]+n+A,ed,1,0);\n\tpr2(mcf());\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define dbug(x) cout<<#x<<\"=\"<<x<<endl\nusing namespace std;\ntemplate <typename T> void read(T &t) {\n\tt=0; char ch=getchar(); int f=1;\n\twhile ('0'>ch||ch>'9') { if (ch=='-') f=-1; ch=getchar(); }\n\tdo {(t*=10)+=ch-'0';ch=getchar();} while ('0'<=ch&&ch<='9'); t*=f;\n}\ntypedef long long ll;\nconst int maxn=(2e5)+10;\nint n,m1,m2,fa[maxn],sz[maxn];\nll ans;\nstruct node {\n\tint x,y,z;\n} d[maxn];\nbool cmp(node a,node b) {\n\treturn a.z>b.z;\n}\nint find(int x) {\n\tif (fa[x]==x) return x;\n\treturn fa[x]=find(fa[x]);\n}\nint main() {\n\t//freopen(\"1.txt\",\"r\",stdin);\n\tread(n); read(m1); read(m2);\n\tint x,y,z;\n\tfor (int i=1;i<=n;i++) {\n\t\tread(x); read(y); read(z);\n\t\td[i]=(node){x,y+m1,z};\n\t}\n\tsort(d+1,d+n+1,cmp);\n\tfor (int i=1;i<=m1+m2;i++) fa[i]=i;\n\tfor (int i=1;i<=n;i++) {\n\t\tx=d[i].x; y=d[i].y; z=d[i].z;\n\t\tx=find(x); y=find(y);\n\t\tif (x==y) {\n\t\t\tif (sz[x]) continue;\n\t\t\tsz[x]=1;\n\t\t} else {\n\t\t\tif (sz[x]&&sz[y]) continue;\n\t\t\tfa[x]=y;\n\t\t}\n\t\tans+=z;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef complex<double> point;\n#define xx real()\n#define yy imag()\n\n#define REP(i, a, b) for(int i = (a); i < (int)(b); i++)\n#define REPN(i, a, b) for(int i = (a); i <= (int)(b); i++)\n#define FA(it, x) for(__typeof((x).begin()) it = (x).begin(); it != (x).end(); it++)\n#define SZ(x) (int)(x).size()\n#define BE(x) (x).begin(), (x).end()\n#define SORT(x) sort(BE(x))\n#define _1 first\n#define _2 second\n\n#define x1 gray_cat_x1\n#define y1 gray_cat_y1\n\ntemplate<class T> T gcd(T a, T b) { return b ? gcd(b, a % b) : a; }\n\nmt19937 rng(chrono::steady_clock::now().time_since_epoch().count());\n\n#define file \"I1\"\n\nconst double EPS = 1e-9;\nconst double PI = acos(-1.);\nconst int INF = 1e9 + 10;\nconst ll MOD = 1e9 + 7;\n\nconst int MAXN = 2e5 + 5;\n\npii par[MAXN][2];\nint cycled[MAXN][2];\n\npair<int, pii> ee[MAXN];\n\npii get_par(int v, int ind) {\n\treturn mp(v, ind) == par[v][ind] ? par[v][ind] : par[v][ind] = get_par(par[v][ind]._1, par[v][ind]._2);\n}\n\nvoid solve(){\n\tint n, h, w;\n\tscanf(\"%d%d%d\", &n, &h, &w);\n\tREP(i, 0, n) {\n\t\tscanf(\"%d%d%d\", &ee[i]._2._1, &ee[i]._2._2, &ee[i]._1);\n\t}\n\tsort(ee, ee + n);\n\treverse(ee, ee + n);\n\tREPN(i, 1, h) {\n\t\tpar[i][0] = mp(i, 0);\n\t}\n\tREPN(i, 1, w) {\n\t\tpar[i][1] = mp(i, 1);\n\t}\n\tll ans = 0ll;\n\tREP(i, 0, n) {\n\t\tint a = ee[i]._2._1, b = ee[i]._2._2;\n\t\tpii pa = get_par(a, 0);\n\t\tpii pb = get_par(b, 1);\n\t\tif (pa == pb) {\n\t\t\tif (cycled[pa._1][pa._2]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += ee[i]._1;\n\t\t\tcycled[pa._1][pa._2] = 1;\n\t\t} else {\n\t\t\tif (cycled[pa._1][pa._2] && cycled[pb._1][pb._2]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans += ee[i]._1;\n\t\t\tcycled[pa._1][pa._2] |= cycled[pb._1][pb._2];\n\t\t\tpar[pb._1][pb._2] = pa;\n\t\t}\n\t}\n\tcout << ans << endl;\n}   \n\nint main(){\n\n    //freopen(file\".in\", \"r\", stdin); freopen(file\".out\", \"w\", stdout);\n    int t = 1;\n    //cin >> t;\n    while(t--){\n        solve();    \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n//#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\nclass UnionFind{\nprivate:\n    ::std::vector<int_fast32_t> par, edge;\n    size_t n;\n\npublic:\n    UnionFind(){}\n    UnionFind(size_t n):n(n){\n        par.resize(n, -1);\n        edge.resize(n, 0);\n    }\n\n    uint_fast32_t find(uint_fast32_t x){\n        return par[x] < 0 ? x : par[x] = find(par[x]);\n    }\n\n    size_t size(uint_fast32_t x){\n        return -par[find(x)];\n    }\n\n    bool unite(uint_fast32_t x, uint_fast32_t y){\n        x = find(x);\n        y = find(y);\n        edge[x] += edge[y] + 1;\n        if(x == y) return false;\n        if(size(x) < size(y)) std::swap(x, y);\n        par[x] += par[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool same(uint_fast32_t x, uint_fast32_t y){\n        return find(x) == find(y);\n    }\n\n    size_t esize(uint_fast32_t x) {\n        return edge[find(x)];\n    }\n};\n\nint main(void) {\n    int64 H, W, N;\n    cin >> N >> H >> W;\n    using T = tuple<int64, int64, int64>;\n    vector<T> v;\n    REP(i, N) {\n        int64 r, c, a;\n        cin >> r >> c >> a;\n        v.emplace_back(a, r-1, H+c-1);\n    }\n    sort(all(v), greater<>());\n    UnionFind uf(H+W);\n    int64 res = 0;\n    REP(i, N) {\n        int64 r, c, a;\n        tie(a, r, c) = v[i];\n        if ((!uf.same(r, c) && (uf.size(r) + uf.size(c) > uf.esize(r) + uf.esize(c))) || (uf.same(r, c) && uf.size(r) > uf.esize(r))) {\n            res += a;\n            uf.unite(r, c);\n        }\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\n#define gg(u) for(int &i=cur[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\ntypedef long long ll;\nconst int N=1e6+5,M=1e7+5,inf=0x3f3f3f3f;\nstruct eg{int v,nx,w,c;}e[M];int head[N],tot=1;\ninline void add(R int u,R int v,R int w,R int c){\n\te[++tot]={v,head[u],w,c},head[u]=tot;\n\te[++tot]={u,head[v],0,-c},head[v]=tot;\n}\nint dis[N],vis[N],cur[N],q[M],S,T;\nll ans;\nbool spfa(){\n    memset(dis,-1,(T-S+1)<<2);\n    memset(vis,0,(T-S+1)<<2);\n    memcpy(cur,head,(T-S+1)<<2);\n    int h=1,t=0,u;\n    q[++t]=T,dis[T]=0,vis[T]=1;\n    while(h<=t){\n        u=q[h++],vis[u]=0;\n        go(u)if(e[i^1].w&&cmax(dis[v],dis[u]-e[i].c)&&!vis[v])\n            q[++t]=v,vis[v]=1;\n    }\n    return ~dis[S];\n}\nint dfs(int u,int lim){\n//\tputs(\"qwq\");\n    if(u==T||!lim)return lim;\n    int flow=0,f;vis[u]=1;\n    gg(u)if(dis[v]==dis[u]-e[i].c&&!vis[v]&&(f=dfs(v,min(lim,e[i].w)))){\n        e[i].w-=f,e[i^1].w+=f,flow+=f,lim-=f;\n        ans+=1ll*f*e[i].c;\n        if(!lim)break;\n    }\n    vis[u]=0;\n    return flow;\n}\ninline void zkw(){while(spfa())dfs(S,inf);}\nint n,h,w;\nint main(){\n//\tfreopen(\"testdata.in\",\"r\",stdin);\n\tscanf(\"%d%d%d\",&n,&h,&w),S=0,T=n+h+w+1;\n\tfp(i,1,h)add(S,i,1,0);fp(i,1,w)add(S,i+h,1,0);\n\tfor(R int i=1,x,y,c;i<=n;++i){\n\t\tscanf(\"%d%d%d\",&x,&y,&c);\n\t\tadd(x,i+h+w,1,0),add(y+h,i+h+w,1,0),add(i+h+w,T,1,c);\n\t}\n\tzkw();\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// one-based numbering\nstruct UnionFind {\n    vector<int> data;\n    // i: (data[i] < 0) -> group size, (data[i] > 0) -> parent;\n    UnionFind(int n) {\n        data.resize(n+1, -1);\n    }\n    int find(int x) {\n        if(data[x] < 0) return x;\n        else return data[x] = find(data[x]);\n    }\n    int size(int x) {\n        return -data[find(x)];\n    }\n    bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if(x == y) return false;\n        if (data[x] > data[y]) swap(x, y);\n        data[x] += data[y];\n        data[y] = x;\n        return true;\n    }\n    bool same(int x, int y) {\n        x = find(x); y = find(y);\n        return x == y;\n    }\n};\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    int n, h, w; cin >> n >> h >> w;\n    auto enh = [&](int i, int j) { return i; };\n    auto enw = [&](int i, int j) { return h + j; };\n    UnionFind uf(h+w);\n    vector<array<int, 3>> arr;\n    for (int i = 0; i < n; i++) {\n        int r, c, a; cin >> r >> c >> a;\n        arr.push_back({a, r, c});\n    } \n    sort(arr.rbegin(), arr.rend());\n    vector<bool> r(h+w+1, 1);\n    long long ans = 0;\n    for (auto &x: arr) {\n        int p = uf.find(enh(x[1], x[2]));\n        int q = uf.find(enw(x[1], x[2]));\n        if (!uf.same(p, q)) {\n            if (r[p] || r[q]) {\n                r[p] = r[p] & r[q];\n                r[q] = r[p];\n                ans += x[0];\n                uf.unite(p, q);\n            }\n        } else {\n            if (r[p]) {\n                r[p] = 0;\n                ans += x[0];\n            }\n        }\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\ntemplate <typename Edge>\nclass graph {\n    using graph_t = std::vector<std::vector<Edge>>;\npublic:\n    using reference = std::vector<Edge>&;\n    using const_reference = std::vector<Edge> const&;\n    using iterator = typename graph_t::iterator;\n    using const_iterator = typename graph_t::const_iterator;\n    using reverse_iterator = typename graph_t::reverse_iterator;\n\n    graph() : g() {}\n    graph(int n) : g(n) {}\n\n    reference operator[](int x) { return g[x]; }\n    const_reference operator[](int x) const { return g[x]; }\n\n    iterator begin() { return std::begin(g); }\n    const_iterator begin() const { return std::begin(g); }\n    iterator end() { return std::end(g); }\n    const_iterator end() const { return std::end(g); }\n    reverse_iterator rbegin() { return std::rbegin(g); }\n    reverse_iterator rend() { return std::rend(g); }\n\n    int size() const { return g.size(); }\n\n    void add_node(std::vector<Edge> es) {\n        g.push_back(std::move(es));\n    }\n\nprivate:\n    std::vector<std::vector<Edge>> g;\n};\n\ntemplate <typename Capacity, typename Cost>\nstruct capacity_weighted_edge {\n    using capacity_type = Capacity;\n    using cost_type = Cost;\n    int to, rev;\n    capacity_type cap;\n    cost_type cost;\n    capacity_weighted_edge(int t, int r, capacity_type cp, cost_type c)\n        : to(t), rev(r), cap(cp), cost(c)\n    {}\n};\n\ntemplate <typename Capacity, typename Cost>\nusing capacity_weighted_graph = graph<capacity_weighted_edge<Capacity, Cost>>;\n\ntemplate <typename Capacity, typename Cost>\nvoid add_edge(capacity_weighted_graph<Capacity, Cost>& g, int from, int to, Capacity cap, Cost cost) {\n    g[from].emplace_back(to, static_cast<int>(g[to].size()), cap, cost);\n    g[to].emplace_back(from, static_cast<int>(g[from].size() - 1), Capacity{0}, -cost);\n}\n\n\ntemplate <typename Edge>\ntypename Edge::cost_type min_cost_flow(graph<Edge>& g, int s, int t, typename Edge::capacity_type f) {\n    using cost_type = typename Edge::cost_type;\n    using capacity_type = typename Edge::capacity_type;\n    static_assert(!std::is_floating_point<capacity_type>::value, \"\");\n    using P = std::pair<cost_type, int>;\n    const auto inf = std::numeric_limits<cost_type>::max() / 2;\n    cost_type res = 0;\n    std::vector<cost_type> h(g.size()), dist(g.size());\n    std::vector<int> prevv(g.size()), preve(g.size());\n    while(f > 0) {\n        std::priority_queue<P, std::vector<P>, std::greater<>> que;\n        std::fill(std::begin(dist), std::end(dist), inf);\n        dist[s] = 0;\n        que.emplace(dist[s], s);\n        while(!que.empty()) {\n            const auto cur_d = que.top().first;\n            const int v = que.top().second;\n            que.pop();\n            if(dist[v] < cur_d) continue;\n            for(int i = 0; i < (int)g[v].size(); ++i) {\n                auto& e = g[v][i];\n                if(e.cap > 0 && dist[e.to] > dist[v] + e.cost + h[v] - h[e.to]) {\n                    dist[e.to] = dist[v] + e.cost + h[v] - h[e.to];\n                    prevv[e.to] = v;\n                    preve[e.to] = i;\n                    que.emplace(dist[e.to], e.to);\n                }\n            }\n        }\n        if(dist[t] == inf) return -1;\n        for(int v = 0; v < (int)g.size(); ++v) {\n            h[v] += dist[v];\n        }\n\n        auto d = f;\n        for(int v = t; v != s; v = prevv[v]) {\n            d = std::min(d, g[prevv[v]][preve[v]].cap);\n        }\n        f -= d;\n        res += d * h[t];\n        for(int v = t; v != s; v = prevv[v]) {\n            auto& e = g[prevv[v]][preve[v]];\n            e.cap -= d;\n            g[v][e.rev].cap += d;\n        }\n    }\n    return res;\n}\n\nint main() {\n    int n, h, w; cin >> n >> h >> w;\n\n    vector<int> r(n), c(n), a(n);\n    vector<set<int>> rid(h), cid(w);\n    vector<bool> used(n);\n    for(int i = 0; i < n; ++i) {\n        cin >> r[i] >> c[i] >> a[i];\n        r[i]--, c[i]--;\n        rid[r[i]].insert(i);\n        cid[c[i]].insert(i);\n    }\n\n    ll ans = 0;\n    int remain = n;\n    {\n        set<pair<int, int>> que;\n        for(int i = 0; i < h; ++i) {\n            if(rid[i].size() == 1u) que.emplace(i, 0);\n        }\n        for(int i = 0; i < w; ++i) {\n            if(cid[i].size() == 1u) que.emplace(i, 1);\n        }\n        while(!que.empty()) {\n            remain--;\n            int idx, type; tie(idx, type) = *que.begin();\n            que.erase(que.begin());\n            auto& v = (type == 0 ? rid : cid);\n            if(v[idx].empty()) continue;\n            const int card = *v[idx].begin();\n            v[idx].erase(v[idx].begin());\n            if(used[card]) continue;\n            used[card] = true;\n            ans += a[card];\n            rid[r[card]].erase(card);\n            cid[c[card]].erase(card);\n            if(rid[r[card]].size() == 1u) que.emplace(r[card], 0);\n            if(cid[c[card]].size() == 1u) que.emplace(c[card], 1);\n        }\n    }\n\n    map<int, int> hidx, widx;\n    for(int i = 0; i < h; ++i) {\n        if(rid[i].empty()) continue;\n        const int nid = hidx.size();\n        hidx[i] = nid;\n    }\n    for(int i = 0; i < w; ++i) {\n        if(cid[i].empty()) continue;\n        const int nid = widx.size();\n        widx[i] = nid;\n    }\n\n    h = hidx.size(), w = widx.size();\n    capacity_weighted_graph<int, ll> g(h + w + remain + 3);\n    const int src = h + w + remain, sink = src + 1, spe = sink + 1;\n    int iter = 0;\n    for(int i = 0; i < n; ++i) {\n        if(used[i]) continue;\n        r[i] = hidx[r[i]], c[i] = widx[c[i]];\n        add_edge(g, r[i], iter + h + w, 1, -a[i] * 1LL);\n        add_edge(g, c[i] + h, iter + h + w, 1, -a[i] * 1LL);\n        add_edge(g, iter + h + w, sink, 1, 0LL);\n        iter += 1;\n    }\n    for(int i = 0; i < h + w; ++i) {\n        add_edge(g, src, i, 1, 0LL);\n    }\n    add_edge(g, src, spe, h + w, 0LL);\n    add_edge(g, spe, sink, h + w, 0LL);\n\n    cout << ans - min_cost_flow(g, src, sink, h + w) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nclass Data{\npublic:\n\tint index;\n\tll value;\n};\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N=in(),H=in(),W=in();\n\tvector<vector<Data>> R(H),C(W);\n\tvector<int> F(N,0);\n\tREP(i,N){\n\t\tint r=in()-1,c=in()-1;\n\t\tll a=in<ll>();\n\t\tData d{i,a};\n\t\tR[r].emplace_back(d);\n\t\tC[c].emplace_back(d);\n\t}\n\t//sort(ALL(R),[](vector<Data>& lhs,vector<Data>& rhs){return lhs.size()<rhs.size();});\n\tREP(i,H){\n\t\tsort(ALL(R[i]),[](Data& lhs,Data& rhs){return lhs.value>rhs.value;});\n\t}\n\t//sort(ALL(C),[](vector<Data>& lhs,vector<Data>& rhs){return lhs.size()<rhs.size();});\n\tREP(i,W){\n\t\tsort(ALL(C[i]),[](Data& lhs,Data& rhs){return lhs.value>rhs.value;});\n\t}\n\tll sum = 0;\n\t/*for(int i=0;i<H;i++){\n\t\tint l = R[i].size();\n\t\tif(l>1) continue;\n\t\tif(F[R[i][0].index]==1) continue;\n\t\tsum += R[i][0].value;\n\t\tF[R[i][0].index]=1;\n\t}\n\tfor(int i=0;i<W;i++){\n\t\tint l = C[i].size();\n\t\tif(l>1) continue;\n\t\tif(F[C[i][0].index]==1) continue;\n\t\tsum += C[i][0].value;\n\t\tF[C[i][0].index]=1;\n\t}*/\n\tfor(int i=0;i<H;i++){\n\t\tint l = R[i].size();\n\t\tfor(int k=0;k<l;k++){\n\t\t\tif(F[R[i][k].index]==1) continue;\n\t\t\tsum += R[i][k].value;\n\t\t\tF[R[i][k].index]=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0;i<W;i++){\n\t\tint l = C[i].size();\n\t\tfor(int k=0;k<l;k++){\n\t\t\tif(F[C[i][k].index]==1) continue;\n\t\t\tsum += C[i][k].value;\n\t\t\tF[C[i][k].index]=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfill(ALL(F),0);\n\tll sum2 = 0;\n\tfor(int i=0;i<W;i++){\n\t\tint l = C[i].size();\n\t\tfor(int k=0;k<l;k++){\n\t\t\tif(F[C[i][k].index]==1) continue;\n\t\t\tsum2 += C[i][k].value;\n\t\t\tF[C[i][k].index]=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tint l = R[i].size();\n\t\tfor(int k=0;k<l;k++){\n\t\t\tif(F[R[i][k].index]==1) continue;\n\t\t\tsum2 += R[i][k].value;\n\t\t\tF[R[i][k].index]=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tout(max(sum,sum2));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1 };\nvel dy = { 1,-1,0,0 };\nvoid sol(int i,int st,int dir,vel&cnt, vvel& nex,vvel& use) {\n\tif (use[i].size() == 0 || use[i].back() != st) {\n\t\tuse[i].push_back(st);\n\t\tif (cnt[i] >= 1) {\n\t\t\trep(nd, 2) {\n\t\t\t\tint ne = nex[nd][i];\n\t\t\t\tif(ne!=-1){\n\t\t\t\t\tsol(ne, st, nd, cnt, nex, use);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint ne = nex[dir][i];\n\t\t\tif (ne != -1) {\n\t\t\t\tsol(ne, st, dir, cnt, nex, use);\n\t\t\t}\n\t\t}\n\t}\n}\nsigned main() {\n\tomajinai;\n\tint n, h, w; cin >> n >> h >> w;\n\tvvel cxy(n);\n\tvvel y_i(w);\n\tvvel x_i(h);\n\trep(i, n) {\n\t\tint c, x, y; cin >> x >> y >> c; x--; y--;\n\t\tcxy[i] = { c,x,y };\n\t}\n\tsor(cxy);\n\trep(i, n) {\n\t\tint x = cxy[i][1];\n\t\tint y = cxy[i][2];\n\t\ty_i[y].push_back(i);\n\t\tx_i[x].push_back(i);\n\t}\n\tvel cnt(n, 0);\n\tvvel nex(2, vel(n, -1));\n\trep(i, w) { \n\t\tsor(y_i[i]);\n\t\tint sz = y_i[i].size();\n\t\tif (sz != 0) {\n\t\t\tcnt[y_i[i].back()]++;\n\t\t\trep(j, sz - 1) {\n\t\t\t\tnex[0][y_i[i][j + 1]] = y_i[i][j];\n\t\t\t}\n\t\t}\n\n\t}\n\trep(i, h) { \n\t\tsor(x_i[i]);\n\t\tint sz = x_i[i].size();\n\t\tif (sz != 0) {\n\t\t\tcnt[x_i[i].back()]++;\n\t\t\trep(j, sz - 1) {\n\t\t\t\tnex[1][x_i[i][j + 1]] = x_i[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tvvel use(n);\n\tint ans = 0;\n\trep(i, n) {\n\t\tif (cnt[i] == 2) {\n\t\t\tsol(i, i, -1, cnt, nex, use);\n\t\t}\n\t\tif (cnt[i] >= 1) { ans += cxy[i][0]; }\n\t}\n\tvel pa(n, -1);\n\tvvel ed;\n\trep(i, n) {\n\t\tif (cnt[i] == 0) {\n\t\t\tvel v = use[i];\n\t\t\tif (v.size() >= 1) {\n\t\t\t\ted.push_back({ cxy[i][0],v[0],v.back() });\n\t\t\t}\n\t\t}\n\t}\n\tsor(ed); rev(ed);\n\tvel ex(n, 0);\n\tfor (auto v : ed) {\n\t\tint c = v[0];\n\t\tint x = root(v[1], pa);\n\t\tint y = root(v[2], pa);\n\t\tif (x == y) {\n\t\t\tif (ex[x] == 0) {\n\t\t\t\tex[x] = 1;\n\t\t\t\tans += c;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (ex[x] + ex[y]<=1) {\n\t\t\t\tpa[x] = y;\n\t\t\t\tex[y] += ex[x]; ex[x] = 0;\n\t\t\t\tans += c;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nnamespace mine\n{\n    #define double long double\n    typedef long long ll;\n    #define pr pair<int,int>\n    #define FR first\n    #define SE second\n    #define MP make_pair\n    #define PB push_back\n    #define vc vector\n    #define all(x) (x).begin(),(x).end()\n    #define sz(x) ((int)(x).size())\n    ll qread()\n    {\n        ll ans=0,f=1;char c=getchar();\n        while(c<'0' or c>'9') {if(c=='-')f=-1;c=getchar();}\n        while('0'<=c and c<='9') ans=ans*10+c-'0',c=getchar();\n        return ans*f;\n    }\n    void write(ll num)\n    {\n        if(num<0) putchar('-'),num=-num;\n        if(num>=10) write(num/10);\n        putchar('0'+num%10);\n    }\n    void write1(ll num){write(num);putchar(' ');}\n    void write2(ll num){write(num);putchar('\\n');}\n    void chmax(int &x,const ll y) {x=(x>y?x:y);}\n    void chmin(int &x,const ll y) {x=(x<y?x:y);}\n    ll gcd(ll x,ll y){return y?gcd(y,x%y):0;}\n    const int INF=0x3f3f3f3f;\n    const int MOD=1e9+7;\n    inline int mm(const int x){return x>=MOD?x-MOD:x;}\n    inline ll qpower(ll x,ll e)\n    {\n        ll ans=1;\n        while(e)\n        {\n            if(e&1) ans=ans*x%MOD;\n            x=x*x%MOD;e>>=1;\n        }\n        return ans;\n    }\n    inline int invm(int x){return qpower(x,MOD-2);}\n    const int N=1e6+10;\n\n    int fa[N],cnt[N];\n    int findfa(int x){return fa[x]==x?x:fa[x]=findfa(fa[x]);}\n    struct Nod{int x,y,c;}e[N];bool cmp(Nod a,Nod b){return a.c>b.c;}\n    void main()\n    {\n        int n=qread(),h=qread(),w=qread();\n        for(int i=1;i<=n;i++){int x=qread(),y=qread(),c=qread();e[i]=(Nod){x,y,c};}\n        sort(e+1,e+n+1,cmp);for(int i=1;i<=h+w;i++) fa[i]=i;\n        ll ans=0;\n        for(int i=1;i<=n;i++)\n        {\n            int fx=findfa(e[i].x),fy=findfa(h+e[i].y);\n            if(fx!=fy) {if(cnt[fx]+cnt[fy]<2)fa[fx]=fy,ans+=e[i].c;}\n            else if(cnt[fx]==0) cnt[fx]=1,ans+=e[i].c;\n        }\n        write(ans);\n    }\n};\nint main()\n{\n    srand(time(0));\n    mine::main();\n}\n"
  },
  {
    "language": "C++",
    "code": "/*Lucky_Glass*/\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\n\nconst int N=1e5;\n\nint n,Vr,Vc;\nlong long ans;\n\nstruct MERGESET{\n\tint fa[4*N+3],cntx[4*N+3],cnty[4*N+3];\n\tvoid Init(int Vn){\n\t\tfor(int i=1;i<=Vn;i++){\n\t\t\tfa[i]=i;\n\t\t\tif(i<=n) cntx[i]=1,cnty[i]=0;\n\t\t\telse cntx[i]=0,cnty[i]=1;\n\t\t}\n\t}\n\tint FindFa(int x){return fa[x]==x? x:FindFa(fa[x]);}\n\tvoid Merge(int x,int y){\n\t\tint fx=FindFa(x),fy=FindFa(y);\n\t\tif(fx==fy) return;\n\t\tfa[fx]=fy;\n\t\tcntx[fy]+=cntx[fx];cntx[fx]=0;\n\t\tcnty[fy]+=cnty[fx];cnty[fx]=0;\n\t}\n}mgset;\n\nstruct NODE{int x,y,val;}nod[N+3];\nbool cmpNODE(NODE Ca,NODE Cb){return Ca.val>Cb.val;}\n\nint main(){\n\tscanf(\"%d%d%d\",&n,&Vr,&Vc);\n\tmgset.Init(n+Vr+Vc);\n\tfor(int i=1;i<=n;i++)\n\t\tscanf(\"%d%d%d\",&nod[i].x,&nod[i].y,&nod[i].val);\n\tsort(nod+1,nod+1+n,cmpNODE);\n\tfor(int i=1;i<=n;i++){\n\t\tint x=nod[i].x,y=nod[i].y;\n\t\tint fx=mgset.FindFa(x+n),fy=mgset.FindFa(y+n+Vr);\n\t\tint cntx,cnty;\n\t\tif(fx==fy) cntx=mgset.cntx[fx],cnty=mgset.cnty[fx];\n\t\telse cntx=mgset.cntx[fx]+mgset.cntx[fy],cnty=mgset.cnty[fx]+mgset.cnty[fy];\n\t\tif(cntx+1>cnty) continue;\n\t\tans+=nod[i].val;\n\t\tmgset.Merge(i,x+n);\n\t\tmgset.Merge(x+n,y+n+Vr);\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/types.h>\n#include <unistd.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\ntemplate<typename T> vector<T> make_vector(size_t sz){\n\treturn vector<T>(sz);\n}\n\ntemplate<typename T,typename... Ts> \nauto make_vector(size_t sz, Ts... ts){\n\treturn vector<decltype(make_vector<T>(ts...))>(sz, make_vector<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V> \ntypename enable_if<is_same<T, U>::value!=0>::type \nfill_value(U &u, const V... v){\n\tu=U(v...);\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_value(U &u, const V... v){\n\tfor(auto &e:u){\n\t\tfill_value<T>(e,v...);\n\t}\n}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\nconst pid_t pid = getpid();\n// Problem Specific Parameter:\n\nconst int limit = 100010;\nint r[limit], c[limit], a[limit];\n\n// Description: 素集合を管理するデータ構造\n// TimeComplexity: 初期化$\\mathcal{O}(n)$ 更新$\\mathcal{O}(\\log n)$\n// Verifyed: AOJ DSL_1_A\n\nstruct Union_find {\n\tUnion_find(int n) {\n\t\tdata.assign(n, -1);\n\t\tedge.assign(n, 0);\n\t}\n\tint find(int x) {return (data[x] < 0) ? x : data[x] = find(data[x]);}\n\tvoid unite(int a, int b) {\n\t\ta = find(a), b = find(b);\n\t\tif (a != b) {\n\t\t\tif (data[a] < data[b]) swap(a, b);\n\t\t\tdata[a] += data[b], data[b] = a;\n\t\t\tedge[a] += edge[b], edge[b] = 0;\n\t\t}\n\t\tedge[a]++;\n\t}\n\tbool same(int a, int b) {return find(a) == find(b);}\n\tint v_size(int x) {return -data[find(x)];}\n\tint e_size(int x) {return edge[find(x)];}\n\tvector<int> data, edge;\n};\n\nbool used_edge[limit];\nbool used_vertex[limit];\n\nint main(void){\n\tint n, h, w;\n\tcin >> n >> h >> w;\n\n\trep(i, n){\n\t\tcin >> r[i] >> c[i] >> a[i];\n\t\tr[i]--, c[i]--;\n\t}\n\n\tusing edge = tuple<ll,int,int>;\n\tvector<edge> graph;\n\n\trep(i, n) graph.push_back(edge(a[i], r[i], c[i] + h));\n\tsort(rbegin(graph), rend(graph));\n\n\tll ans = 0LL;\n\tUnion_find uf(h + w);\n\n\trep(i, n) {\n\t\tll cost;\n\t\tint u, v;\n\t\ttie(cost, u, v) = graph[i];\n\n\t\tint nv = uf.v_size(u);\n\t\tint ne = uf.e_size(u);\n\n\t\tif (uf.same(u, v) == false) {\n\t\t\tnv += uf.v_size(v);\n\t\t\tne += uf.e_size(v);\n\t\t}\n\n\t\tif (nv <= ne) continue;\n\t\tans += cost;\n\t\tuf.unite(u, v); \n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define debug(a) cerr << #a << \": \" << a << endl\n \ntypedef long long ll;\ntypedef pair<int, int> ii;\n \n#define x first\n#define y second\n \nconst int N = 1e5 + 10;\n\nint n;\nint h, w;\nint row_cnt[N];\nint col_cnt[N];\nbool row_vis[N];\nbool col_vis[N];\nbool card_vis[N];\npair<int, ii> card[N];\nll ans1, ans2;\n\nint main() {\n\t#ifdef LOCAL\n\tfreopen(\"in\", \"r\", stdin);\n\tfreopen(\"out\", \"w\", stdout);\n\t#endif\n \n\tcin >> n >> h >> w;\n\tfor (int i = 1; i <= n; i++) {\n\t\tscanf(\"%d %d %d\", &card[i].y.x, &card[i].y.y, &card[i].x);\n\t\trow_cnt[card[i].y.x]++;\n\t\tcol_cnt[card[i].y.y]++;\n\t}\n\tsort(card + 1, card + n + 1);\n\n\tfor (int i = n; i >= 1; i--) {\n\t\tif (!row_vis[card[i].y.x] && col_cnt[card[i].y.y] != 1) {\n\t\t\tans1 += card[i].x;\n\t\t\tcard_vis[i] = true;\n\t\t\trow_vis[card[i].y.x] = true;\n\t\t\tcol_cnt[card[i].y.y]--;\n\t\t}\n\t}\n\n\tfor (int i = n; i >= 1; i--) {\n\t\tif (!card_vis[i] && !col_vis[card[i].y.y]) {\n\t\t\tans1 += card[i].x;\n\t\t\tcard_vis[i] = true;\n\t\t\tcol_vis[card[i].y.y] = true;\n\t\t}\n\t}\n\n\tmemset(row_vis, 0, sizeof row_vis);\n\tmemset(col_vis, 0, sizeof col_vis);\n\tmemset(card_vis, 0, sizeof card_vis);\n\n\tfor (int i = n; i >= 1; i--) {\n\t\tif (!col_vis[card[i].y.x] && row_cnt[card[i].y.y] != 1) {\n\t\t\tans2 += card[i].x;\n\t\t\tcard_vis[i] = true;\n\t\t\tcol_vis[card[i].y.x] = true;\n\t\t\trow_cnt[card[i].y.y]--;\n\t\t}\n\t}\n\n\tfor (int i = n; i >= 1; i--) {\n\t\tif (!card_vis[i] && !row_vis[card[i].y.y]) {\n\t\t\tans2 += card[i].x;\n\t\t\tcard_vis[i] = true;\n\t\t\trow_vis[card[i].y.y] = true;\n\t\t}\n\t}\n\n\tcout << max(ans1, ans2) << endl;\n \n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long ll;\n#define pb push_back\nusing namespace std;\n\ntypedef pair<ll,ll> pll;\n\n\nll n,h,w;\nvector<ll> g[400005];\nll p[400005];\nll used[400005];\nll sz[400005];\nll ans;\nll fs(ll x)\n{\n        return p[x] == x ? x : p[x] = fs(p[x]);\n}\nvoid ms(ll x, ll y)\n{\n        x=fs(x); y=fs(y);\n        p[y]=x;\n        used[x] = (used[x] | used[y]);\n}\nvector< pair<ll, pll> > e;\nint main()\n{\n        ios_base::sync_with_stdio(false);\n        cin.tie(NULL); cout.tie(NULL);\n        cin >> n >> h >> w;\n        for(ll i=1;i<=n;i++) {\n\n                ll x,y,a;\n                cin >> x >> y >> a;\n                e.pb(make_pair(a,make_pair(x, h + y)));\n        }\n        sort(e.rbegin(), e.rend());\n        for(ll i=1;i<=h+w;i++) {\n                p[i] = i;\n                used[i]=0;\n                sz[i] = 1;\n        }\n        ans = 0;\n        for(auto &i : e) {\n\n                ll u = i.second.first;\n                ll v = i.second.second;\n                ll w = i.first;\n\n                if(fs(u) == fs(v)) {\n\n                        if(used[fs(u)] == 0) {\n                                ans += w;\n                                used[fs(u)]=1;\n                        }\n                }else {\n                        if(used[fs(u)] == 0 || used[fs(v)] == 0){\n                                ms(u,v);\n                                ans += w;\n                        }\n                }\n        }\n        cout << ans << endl;\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n  Id: hhw52818\n  Task: a\n  Lang: C++\n*/\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define foru(i, l, r) for(register int i = l; i <= r; i++)\n#define ford(i, r, l) for(register int i = r; i >= l; i--)\n\ntypedef long long ll;\nconst int maxn = 1e5 + 5;\n\nint n, m, N;\nll ans;\n\n#define mk make_pair\n#define fir first\n#define sec second\n\nstruct Heap {\n  priority_queue<pair<int, int> > ins;\n  priority_queue<pair<int, int> > del;\n  void clear() {\n    while(!ins.empty()) ins.pop();\n    while(!del.empty()) del.pop();\n  }\n  void insert(pair<int, int> pii) { ins.push(pii); }\n  void erase(pair<int, int> pii) { del.push(pii); }\n  pair<int, int> top() { return ins.top(); }\n  bool empty() {\n    while(!ins.empty() && !del.empty())\n      if(ins.top() == del.top())\n        ins.pop(), del.pop();\n      else break;\n    return ins.empty();\n  }\n} a[maxn], b[maxn];\n\nint U[maxn], V[maxn], X[maxn];\nint Count[maxn];\n\nll solve() {\n  for(int i = 1; i <= n; i++) a[i].clear();\n  for(int i = 1; i <= m; i++) b[i].clear();\n  memset(Count, 0, sizeof(Count));\n  for(int i = 1; i <= N; i++) {\n    a[U[i]].insert(mk(X[i], V[i]));\n    b[V[i]].insert(mk(X[i], 0));\n    Count[V[i]]++;\n  }\n  ll res = 0;\n  for(int i = 1; i <= n; i++) {\n    if(!a[i].empty()) {\n      pair<int, int> now = a[i].top();\n      while(!a[i].empty()) {\n        if(Count[now.sec] > 1) break;\n        else a[i].erase(now);\n        if(!a[i].empty()) now = a[i].top();\n        else break;\n      }\n      if(Count[now.sec] > 1) {\n        Count[now.sec]--; res += (ll)now.fir;\n        b[now.sec].erase(mk(now.fir, 0));\n      }\n    }\n  }\n  for(int i = 1; i <= m; i++) {\n    if(!b[i].empty()) {\n      pair<int, int> now = b[i].top();\n      res += (ll)now.fir;\n    }\n  }\n  return res;\n}\n\nint main() {\n  //  freopen(\"a.in\", \"r\", stdin);\n  //  freopen(\"a.out\", \"w\", stdout);\n  scanf(\"%d%d%d\", &N, &n, &m);\n  for(int i = 1; i <= N; i++) {\n    scanf(\"%d\", &U[i]);\n    scanf(\"%d\", &V[i]);\n    scanf(\"%d\", &X[i]);\n  } ans = 0;\n  ans = max(ans, solve());\n  printf(\"%lld\\n\", ans);\n  return 0;\n}\n/*\n  ;    11;    1;    6,12;    13;          ;\n  7,8;      ;     ;        ;      ;          ;\n  5;      ;     ;        ;      ;         4;\n  ;      ;     ;        ;      ;    2,3,10;\n  ;      ;     ;        ;      ;         9;\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Dsu {\npublic:\n  int n;\n  vector<int> par;\n  vector<bool> used;\n\n  Dsu(int _n) : n(_n) {\n    par.resize(n);\n    used.resize(n);\n    for (int i = 0; i < n; i++) {\n      par[i] = i;\n      used[i] = false;\n    }\n  }\n\n  int find(int i) {\n    if (par[i] == i) return i;\n    return par[i] = find(par[i]);\n  }\n\n  bool unite(int i, int j) {\n    i = find(i);\n    j = find(j);\n    if (i == j) {\n      if (used[i]) return false;\n      return (used[i] = true);\n    } else {\n      if (used[i] && used[j]) return false;\n      par[j] = i;\n      used[i] = used[i] || used[j];\n      return true;\n    }\n  }\n};\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, h, w;\n  cin >> n >> h >> w;\n  vector< tuple<int,int,int> > edge;\n  for (int i = 0; i < n; i++) {\n    int u, v, w;\n    cin >> u >> v >> w;\n    u--; v--;\n    edge.emplace_back(w, u, v + h);\n  }\n  sort(edge.rbegin(), edge.rend());\n\n  long long ans = 0;\n  Dsu dsu(h + w);\n  for (auto e : edge) {\n    int u, v, w;\n    tie(w, u, v) = e;\n    if (dsu.unite(u, v)) {\n      ans += w;\n    }\n  }\n  cout << ans << '\\n';\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e5+5;\nint a[maxn]={0},b[maxn]={0};\nint n,h,w;\nint cnt=0;\nll sum=0;\nstruct pp\n{\n\tint x,y,z;\n}s[maxn];\nbool cmpz(pp a,pp b)\n{\n\treturn a.z>b.z;\n}\nint main()\n{\n\tcin>>n>>h>>w;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>s[i].x>>s[i].y>>s[i].z;\n\t}\n\tfor(int i=1;i<=h;i++) a[i]=1;\n\tfor(int i=1;i<=w;i++) b[i]=1;\n\tsort(s,s+n,cmpz);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint mh=0,mw=0;\n\t    int ow,oh;\n\t    if(s[i].z==0) continue;\n\t    for(int j=i+1;j<n;j++)\n\t    {\n\t\t    if(s[j].x==s[i].x&&mh==0&&a[s[i].x]==1)\n\t\t    {\n\t\t\t   mh=s[j].z;\n\t\t\t   oh=j;\n\t\t    }\n\t\t    if(s[j].y==s[i].y&&mw==0&&b[s[i].y]==1)\n\t\t    {\n\t\t\t    mw=s[j].z;\n\t\t\t    ow=j;\n\t\t    }\n\t\t    if(mh!=0&&mw!=0) break;\n\t    }\n\t    //cout<<mh<<\" \"<<mw<<endl;\n\t    if(a[s[i].x]==0&&b[s[i].y]==0) \n\t    { \n\t\t     continue;\n\t    }\n\t    else if((mh>mw&&b[s[i].y]==1)||(a[s[i].x]==0&&b[s[i].y]==1))\n\t    {\n\t\t    b[s[i].y]--;\n\t\t    //cout<<s[i].z<<endl;//\n\t\t    sum+=(s[i].z);\n\t\t    cnt++;\n\t    }\n\t    else if((mh<mw&&a[s[i].x]==1)||(a[s[i].x]==1&&b[s[i].y]==0))\n\t    {\n\t\t    a[s[i].x]--;\n\t\t    //cout<<s[i].z<<endl;//\n\t\t    sum+=(s[i].z);\n\t\t    cnt++;\n\t    }\n\t    else if(mh==mw&&b[s[i].y]==1&&a[s[i].x]==1)\n\t    {\n\t\t    a[s[i].x]--;\n\t\t    //cout<<s[i].z<<endl;//\n\t\t    sum+=(s[i].z);\n\t\t    cnt++;\n\t\t    //cout<<mh<<endl;//\n\t\t    if(mh!=0)\n\t\t\t{\n\t\t\t\tb[s[i].y]--;\n\t\t\t\tsum+=(mh);\n\t\t        s[ow].z=0;\n\t\t        cnt++;\n\t\t\t}\n\t    }\n\t    if(cnt==(h+w)) break;\n\t}\n\tcout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "//#define _GLIBCXX_DEBUG\n#include <bits/stdc++.h>\ntypedef long long ll;\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define REP(i,a) FOR(i,0,a)\nusing namespace std;\nconst ll MAX_H=1e5,MAX_W=1e5,MAX_V=MAX_H+MAX_W+1,MAX_N=1e5;\nll N,H,W,R[MAX_N],C[MAX_N],A[MAX_N],par[MAX_V];\nvoid init(ll n){\n\tREP(i,n)par[i]=i;\n}\nll fndpar(ll v){\n\tif(par[v]==v)return v;\n\treturn par[v]=fndpar(par[v]);\n}\nvoid unite(ll u,ll v){\n\tu=fndpar(u);\n\tv=fndpar(v);\n\tpar[u]=v;\n}\nbool same(ll u,ll v){\n\tu=fndpar(u);\n\tv=fndpar(v);\n\treturn u==v;\n}\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcin>>N>>H>>W;\n\tinit(H+W+1);\n\tREP(i,N){\n\t\tcin>>R[i]>>C[i]>>A[i];\n\t}\n\tvector<ll> inx;\n\tREP(i,N)inx.push_back(i);\n\tsort(inx.begin(),inx.end(),[](ll a,ll b){\n\t\treturn A[a]<A[b];\n\t});\n\treverse(inx.begin(),inx.end());\n\tll ans=0;\n\tfor(auto i:inx){\n\t\tll u=R[i]-1,v=C[i]+H-1;\n\t\tu=fndpar(u);\n\t\tv=fndpar(v);\n\t\tif(u!=v){\n\t\t\tans+=A[i];\n\t\t\tunite(u,v);\n\t\t}else if(u!=fndpar(H+W)){\n\t\t\tans+=A[i];\n\t\t\tunite(u,H+W);\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <map>\n#include <set>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <vector>\n#include <bitset>\n#include <cstdio>\n#include <cctype>\n#include <string>\n#include <numeric>\n#include <cstring>\n#include <cassert>\n#include <climits>\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <functional>\nusing namespace std ;\n#define rep(i, a, b) for (register ll i = (a); i <= (b); ++i)\n#define per(i, a, b) for (register ll i = (a); i >= (b); --i)\n#define loop(it, v) for (auto it = v.begin(); it != v.end(); it++)\n#define cont(i, x) for (int i = head[x]; i; i = edge[i].nex)\n#define clr(a) memset(a, 0, sizeof(a))\n#define ass(a, cnt) memset(a, cnt, sizeof(a))\n#define cop(a, b) memcpy(a, b, sizeof(a))\n#define lowbit(x) (x & -x)\n#define all(x) x.begin(), x.end()\n#define SC(t, x) static_cast <t> (x)\n#define ub upper_bound\n#define lb lower_bound\n#define pqueue priority_queue\n#define mp make_pair\n#define pb push_back\n#define pof pop_front\n#define pob pop_back\n#define fi first\n#define se second\n#define y1 y1_\n#define Pi acos(-1.0)\n#define iv inline void\n#define enter cout << endl\n#define siz(x) ((int)x.size())\n#define file(x) freopen(x\".in\", \"r\", stdin),freopen(x\".out\", \"w\", stdout)\ntypedef double db ;\ntypedef long long ll ;\ntypedef unsigned long long ull ;\ntypedef pair <int, int> pii ;\ntypedef vector <int> vi ;\ntypedef vector <pii> vii ;\ntypedef queue <int> qi ;\ntypedef queue <pii> qii ;\ntypedef set <int> si ;\ntypedef map <int, int> mii ;\ntypedef map <string, int> msi ;\nconst int maxn = 5e2 + 10 ;\nconst int inf = 0x3f3f3f3f ;\nconst int iinf = 1 << 30 ;\nconst ll linf = 2e18 ;\nconst ll mod = 1e9 + 7 ;\nconst double eps = 1e-7 ;\ntemplate <class T> void read(T &a)\n{\n\tint f = 1 ; a = 0;\n\tchar ch = getchar() ;\n\twhile (!isdigit(ch)) { if (ch == '-') f = -1 ; ch = getchar() ; }\n\twhile (isdigit(ch)) { a =  (a << 3) + (a << 1) + ch - '0' ; ch = getchar() ; }\n\ta *= f;\n}\n\nll n, h, w, ans;\n\nstruct card\n{\n\tll a, r, c;\n}\na[maxn];\n\nll fa[maxn];\n\nbool circle;\n\nvoid init(ll t)\n{\n\trep(i, 1, t) fa[i] = i;\n\treturn ;\n}\n\nll getfa(ll a)\n{\n\treturn a == fa[a] ? a : fa[a] = getfa(fa[a]);\n}\n\nsigned main()\n{\n\tscanf(\"%lld %lld %lld\", &n, &h, &w);\n\tinit(h + w);\n\trep(i, 1, n) scanf(\"%lld %lld %lld\", &a[i].r, &a[i].c, &a[i].a);\n\tsort(a + 1, a + n + 1, [](card a, card b)\n\t\t{\n\t\t\treturn a.a > b.a;\n\t\t}\n\t);\n\trep(i, 1, n)\n\t{\n\t\tll u = a[i].r, v = a[i].c + h;\n\t\t// cout << u << ' ' << v << endl;\n\t\t// printf(\"I : %lld %lld %lld\\n\", a[i].r, a[i].c, a[i].a);\n\t\tu = getfa(u), v = getfa(v);\n\t\t// printf(\"%lld %lld\\n\", u, v);\n\t\tif(u != v) ans += a[i].a, fa[u] = v;\n\t\telse\n\t\t{\n\t\t\tif(!circle) circle = 1, ans += a[i].a;\n\t\t\t// else puts(\"No\");\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge{\n\tint u,v,w;\n};\n\nlong long ans=0;\nint par[200005],ed[200005]={},sz[200005]={};\n\nint root(int u){\n\tif(par[u]!=u){\n\t\treturn par[u]=root(par[u]);\n\t}\n\treturn u;\n}\n\nvoid merge(int u, int v, int w){\n\tint ru=root(u),rv=root(v);\n\tif(ru==rv){\n\t\tif(sz[ru]>ed[ru]){\n\t\t\ted[ru]++;\n\t\t\tans+=w;\n\t\t}\n\t}\n\telse{\n\t\tif(sz[ru]+sz[rv]>ed[ru]+ed[rv]){\n\t\t\tif(sz[ru]>sz[rv]){\n\t\t\t\tpar[rv]=ru;\n\t\t\t\tsz[rv]+=sz[ru];\n\t\t\t\ted[rv]+=ed[ru]+1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tpar[ru]=rv;\n\t\t\t\tsz[ru]+=sz[rv];\n\t\t\t\ted[ru]+=ed[rv]+1;\n\t\t\t}\n\t\t\tans+=w;\n\t\t}\n\t}\n}\n\nint main(){\n\tint p,h,w; cin >> p >> h >> w;\n\tfor(int i=0;i<h+w;i++){\n\t\tpar[i]=i;\n\t\tsz[i]=1;\n\t}\n\tvector <edge> e(p);\n\tfor(int i=0;i<p;i++){\n\t\tcin >> e[i].u >> e[i].v >> e[i].w;\n\t\te[i].u--;e[i].v--;\n\t}\n\tsort(e.begin(),e.end(),[](edge &a, edge &b){\n\t\treturn a.w>b.w;\n\t});\n\tfor(int i=0;i<p;i++){\n\t\tmerge(e[i].u,h+e[i].v,e[i].w);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <sstream>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <queue>\n#include <cmath>\n#include <functional>\n#include <set>\n#include <ctime>\n#include <random>\n#include <chrono>\n#include <cassert>\n#include <tuple>\n#include <utility>\nusing namespace std;\n\nnamespace {\n  using Integer = long long; //__int128;\n  template<class T, class S> istream& operator >> (istream& is, pair<T,S>& p){return is >> p.first >> p.second;}\n  template<class T> istream& operator >> (istream& is, vector<T>& vec){for(T& val: vec) is >> val; return is;}\n  template<class T> istream& operator ,  (istream& is, T& val){ return is >> val;}\n  template<class T, class S> ostream& operator << (ostream& os, const pair<T,S>& p){return os << p.first << \" \" << p.second;}\n  template<class T> ostream& operator << (ostream& os, const vector<T>& vec){for(size_t i=0; i<vec.size(); i++) os << vec[i] << (i==vec.size()-1?\"\":\" \"); return os;}\n  template<class T> ostream& operator ,  (ostream& os, const T& val){ return os << \" \" << val;}\n\n  template<class H> void print(const H& head){ cout << head; }\n  template<class H, class ... T> void print(const H& head, const T& ... tail){ cout << head << \" \"; print(tail...); }\n  template<class ... T> void println(const T& ... values){ print(values...); cout << endl; }\n\n  template<class H> void eprint(const H& head){ cerr << head; }\n  template<class H, class ... T> void eprint(const H& head, const T& ... tail){ cerr << head << \" \"; eprint(tail...); }\n  template<class ... T> void eprintln(const T& ... values){ eprint(values...); cerr << endl; }\n\n  class range{ Integer start_, end_, step_; public: struct range_iterator{ Integer val, step_; range_iterator(Integer v, Integer step) : val(v), step_(step) {} Integer operator * (){return val;} void operator ++ (){val += step_;} bool operator != (range_iterator& x){return step_ > 0 ? val < x.val : val > x.val;} }; range(Integer len) : start_(0), end_(len), step_(1) {} range(Integer start, Integer end) : start_(start), end_(end), step_(1) {} range(Integer start, Integer end, Integer step) : start_(start), end_(end), step_(step) {} range_iterator begin(){ return range_iterator(start_, step_); } range_iterator   end(){ return range_iterator(  end_, step_); } };\n\n  inline string operator \"\" _s (const char* str, size_t size){ return move(string(str)); }\n  constexpr Integer my_pow(Integer x, Integer k, Integer z=1){return k==0 ? z : k==1 ? z*x : (k&1) ? my_pow(x*x,k>>1,z*x) : my_pow(x*x,k>>1,z);}\n  constexpr Integer my_pow_mod(Integer x, Integer k, Integer M, Integer z=1){return k==0 ? z%M : k==1 ? z*x%M : (k&1) ? my_pow_mod(x*x%M,k>>1,M,z*x%M) : my_pow_mod(x*x%M,k>>1,M,z);}\n  constexpr unsigned long long operator \"\" _ten (unsigned long long value){ return my_pow(10,value); }\n\n  inline int k_bit(Integer x, int k){return (x>>k)&1;} //0-indexed\n\n  mt19937 mt(chrono::duration_cast<chrono::nanoseconds>(chrono::steady_clock::now().time_since_epoch()).count());\n\n  template<class T> string join(const vector<T>& v, const string& sep){ stringstream ss; for(size_t i=0; i<v.size(); i++){ if(i>0) ss << sep; ss << v[i]; } return ss.str(); }\n\n  inline string operator * (string s, int k){ string ret; while(k){ if(k&1) ret += s; s += s; k >>= 1; } return ret; }\n}\nconstexpr long long mod = 9_ten + 7;\n\n\ntemplate <\n  typename CapType, typename TotalCapType, \n  typename CostType, typename TotalCostType\n>\nclass CostScaling {\nprivate:\n  static const int alpha = 8; // eps <- max(1, eps / alpha)\n\n  using cap_t = CapType;\n  using tcap_t = TotalCapType;\n  using cost_t = CostType; // > max{|C|} * (2 * |V|)\n  using tcost_t = TotalCostType;\n  static constexpr cost_t Inf = (tcap_t(1) << (sizeof(tcap_t) * 8 - 2)) - 1;\n\n  struct InputEdge { int from, to; cap_t b, c; cost_t cost; };\n  struct Edge { int to, rev; cap_t cap; cost_t cost; };\n\n  class Dinic {\n  public:\n    Dinic(int N, const vector<int>& ofs, vector<Edge>& edges, \n        vector<tcap_t>& capacity) \n      : N(N), ofs(ofs), edges(edges), capacity(capacity), last(N) {}\n\n    bool succeeded() {\n      // s -> u: capacity[u]\n      // u -> t: capacity[u + N]\n      tcap_t f = 0;\n      for (int u = 0; u < N; ++u) f += capacity[u];\n      vector<int> que(N);\n      while (f) {\n        dist.assign(N, -1);\n        int qh = 0, qt = 0, lv = N;\n        for (int u = 0; u < N; ++u) if (capacity[u] > 0) que[qt++] = u, dist[u] = 0;\n        for (; qh < qt; ) {\n          int u = que[qh++];\n          if (lv == N && capacity[u + N] > 0) lv = dist[u];\n          if (dist[u] > lv) break;\n          for (int ei = ofs[u]; ei < ofs[u + 1]; ++ei) {\n            int v = edges[ei].to;\n            if (edges[ei].cap > 0 && dist[v] == -1) {\n              que[qt++] = v, dist[v] = dist[u] + 1;\n            }\n          }\n        }\n        if (lv == N) break;\n        for (int u = 0; u < N; ++u) last[u] = ofs[u];\n        for (int u = 0; u < N; ++u) if (capacity[u] > 0) {\n          auto df = block_flow(u, capacity[u]);\n          f -= df, capacity[u] -= df;\n        }\n      }\n      return f == 0;\n    }\n\n  private:\n    tcap_t block_flow(int u, tcap_t f) {\n      tcap_t ret = 0;\n      if (capacity[u + N] > 0) {\n        tcap_t df = min(f, capacity[u + N]);\n        capacity[u + N] -= df;\n        return df;\n      }\n      for (auto& ei = last[u]; ei < ofs[u + 1]; ++ei) {\n        auto& e = edges[ei]; int v = e.to;\n        if (e.cap == 0 || dist[v] <= dist[u]) continue;\n        cap_t df = block_flow(v, min<cap_t>(e.cap, f));\n        if (df == 0) continue;\n        e.cap -= df, edges[e.rev].cap += df;\n        f -= df, ret += df;\n        if (f == 0) break;\n      }\n      return ret;\n    }\n\n    int N;\n    const vector<int>& ofs;\n    vector<Edge>& edges;\n    vector<tcap_t>& capacity;\n    vector<int> last, dist;\n  };\n\npublic:\n  CostScaling(int N, int M=0) : N(N), capacity(2 * N) {\n    if (M > 0) in.reserve(M);\n  }\n\n  void add_directed_edge(int u, int v, cap_t b, cap_t c, cost_t cost) {\n    if (b > 0) capacity[v] += b, capacity[u + N] += b;\n    else capacity[u] += -b, capacity[v + N] += -b;\n    in.push_back({u, v, b, c, cost});\n  }\n\n  pair<bool, tcost_t> minimum_cost_circulation() {\n    construct();\n    if (!has_feasible_circulation()) return {false, 0};\n\n    const int cost_multiplier = 2 << __lg(N); // should be > |V|\n    cost_t eps = 0;\n    for (auto& e : edges) e.cost *= cost_multiplier, eps = max(eps, e.cost);\n    \n    while (eps > 1) refine(eps = max<cost_t>(1, eps / alpha));\n\n    tcost_t ret = initial_cost;\n    for (auto& e : edges) ret -= (e.cost / cost_multiplier) * e.cap;\n    return {true, ret / 2};\n  }\n\nprivate:\n  void refine(const cost_t eps) {\n    auto cost_p = [&] (int u, const Edge& e) {\n      return e.cost + potential[u] - potential[e.to];\n    };\n    for (int u = 0; u < N; ++u) for (int i = ofs[u]; i < ofs[u + 1]; ++i) {\n      auto& e = edges[i];\n      if (cost_p(u, e) < 0) edges[e.rev].cap += e.cap, e.cap = 0;\n    }\n    vector<tcap_t> excess(initial_excess);\n    for (auto& e : edges) excess[e.to] -= e.cap;\n\n    vector<int> stack; stack.reserve(N);\n    for (int u = 0; u < N; ++u) if (excess[u] > 0) stack.push_back(u);\n\n    auto residue = [&] (const Edge& e) -> cap_t { return e.cap; };\n    auto push = [&] (int u, Edge& e, cap_t df) {\n      e.cap -= df; edges[e.rev].cap += df;\n      excess[e.to] += df; excess[u] -= df;\n      if (excess[e.to] > 0 && excess[e.to] <= df) {\n        stack.push_back(e.to);\n      }\n    };\n    auto relabel = [&] (int u, cost_t delta) {\n      potential[u] -= delta + eps;\n    };\n    auto relabel_in_advance = [&] (int u) {\n      if (excess[u] != 0) return false;\n      auto delta = Inf;\n      for (int ei = ofs[u]; ei < ofs[u + 1]; ++ei) {\n        auto& e = edges[ei];\n        if (residue(e) == 0) continue;\n        if (cost_p(u, e) < 0) return false;\n        else delta = min<tcost_t>(delta, cost_p(u, e));\n      }\n      relabel(u, delta);\n      return true;\n    };\n    auto discharge = [&] (int u) {\n      auto delta = Inf;\n      for (int ei = ofs[u]; ei < ofs[u + 1]; ++ei) {\n        auto& e = edges[ei];\n        if (residue(e) == 0) continue;\n        if (cost_p(u, e) < 0) {\n          if (relabel_in_advance(e.to)) {\n            --ei; continue; // modify ei (!)\n          }\n          cap_t df = min<tcap_t>(excess[u], residue(e));\n          push(u, e, df);\n          if (!excess[u]) return;\n        } else delta = min<tcost_t>(delta, cost_p(u, e));\n      }\n      relabel(u, delta);\n      stack.push_back(u);\n    };\n    while (!stack.empty()) {\n      auto u = stack.back(); stack.pop_back();\n      discharge(u);\n    }\n  }\n\n  void construct() {\n    ofs.assign(N + 1, 0);\n    edges.resize(2 * in.size());\n    initial_excess.assign(N, 0);\n    initial_cost = 0;\n    potential.assign(N, 0);\n    for (auto& e : in) ofs[e.from + 1]++, ofs[e.to + 1]++;\n    for (int i = 1; i <= N; ++i) ofs[i] += ofs[i - 1];\n    for (auto& e : in) {\n      initial_excess[e.to] += e.c;\n      initial_excess[e.from] += -e.b;\n      initial_cost += tcost_t(e.cost) * (e.c + e.b);\n      edges[ofs[e.from]++] = {e.to, ofs[e.to], e.c - e.b, e.cost};\n      edges[ofs[e.to]++] = {e.from, ofs[e.from] - 1, 0, -e.cost};\n    }\n    for (int i = N; i > 0; --i) ofs[i] = ofs[i - 1];\n    ofs[0] = 0;\n  }\n\n  bool has_feasible_circulation() {\n    return Dinic(N, ofs, edges, capacity).succeeded();\n  }\n\nprivate:\n  int N; \n  vector<InputEdge> in;\n  vector<tcap_t> capacity;\n\n  vector<int> ofs;\n  vector<Edge> edges;\n\n  tcost_t initial_cost;\n  vector<tcap_t> initial_excess;\n  vector<tcost_t> potential;\n};\n// cap, total_cap, cost * (2 * |V|), total_cost\nusing MCC = CostScaling<int, int64_t, int64_t, int64_t>;\n// using MCC = CostScaling<int, int, int, int>;\n\n\nint main(){\n  int n,h,w;\n  cin >> n,h,w;\n\n  vector<int> r(n),c(n),a(n);\n  for(int i=0; i<n; i++){\n    cin >> r[i],c[i],a[i];\n    r[i]--;\n    c[i]--;\n  }\n\n  set<int> sr(r.begin(), r.end());\n  set<int> sc(c.begin(), c.end());\n\n  // long long inf = 1ll<<58;\n  int N = h+w+n+2;\n  auto mcc = MCC(N+1);\n  // Min_Cost_Flow<long long> f(h+w+n+3, inf);\n  int source = h+w+n+0;\n  int sink = source+1;\n  for(int i=0; i<n; i++){\n    // f.add_edge(source, i, 1, -a[i]);\n    // f.add_edge(i, n+r[i], 1, 0);\n    // f.add_edge(i, n+h+c[i], 1, 0);\n    mcc.add_directed_edge(i, sink, 0, 1, -a[i]);\n    mcc.add_directed_edge(n+r[i], i, 0, 1, 0);\n    mcc.add_directed_edge(n+h+c[i], i, 0, 1, 0);\n  }\n  for(int i: sr){\n    // f.add_edge(n+i, sink, 1, 0);\n    mcc.add_directed_edge(source, n+i, 0, 1, 0);\n  }\n  for(int i: sc){\n    // f.add_edge(n+h+i, sink, 1, 0);\n    mcc.add_directed_edge(sink, n+h+i, 0, 1, 0);\n  }\n\n  mcc.add_directed_edge(sink, source, 0, min(h+w, n), 0);\n\n  // long long ans = f.min_cost_flow(source, sink, min(h+w, n));\n  auto ans = mcc.minimum_cost_circulation();\n  eprintln(ans);\n\n  println(-ans.second);\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fi first\n#define se second\nusing namespace std;\n\ntypedef pair <int, int> pii;\ntypedef pair <int, pii> piii;\n\npiii a[100010];\nint fa[200010], size[200010];\n\nint find(int x) {return x == fa[x] ? x : fa[x] = find(fa[x]);}\n\nvoid merge(int x, int y) {\n\tsize[x] += size[y], fa[y] = x;\n}\n\nbool check(int x, int y) {\n\tx = find(x), y = find(y);\n\tif (x != y) merge(x, y);\n\tif (size[x]) {\n\t\tsize[x]--;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint main() {\n\tint n, h, w; scanf(\"%d%d%d\", &n, &h, &w);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d%d\", &a[i].se.fi, &a[i].se.se, &a[i].fi);\n\t\ta[i].se.se += h;\n\t}\n\tsort(a, a + n), reverse(a, a + n);\n\tfor (int i = 1; i <= h + w; i++) {\n\t\tfa[i] = i, size[i] = 1;\n\t}\n\tlong long ans = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (check(a[i].se.fi, a[i].se.se)) ans += a[i].fi;\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define __builtin_popcount __builtin_popcountll\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const map<S, T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\nbool bipartite_matching_dfs(\n        int v, const vector< vector<int> > &conn,\n        vector<bool> &used, vector<int> &match)\n{\n    used[v] = true;\n    for(int i = 0; i < conn[v].size(); ++i){\n        int u = conn[v][i], w = match[u];\n        if(w < 0 || (!used[w] && bipartite_matching_dfs(w, conn, used, match))){\n            match[v] = u;\n            match[u] = v;\n            return true;\n        }\n    }\n    return false;\n}\nvector<int> bipartite_matching(const vector< vector<int> > &conn){\n    int res = 0;\n    vector<int> match(conn.size(), -1);\n    vector<bool> used(conn.size(), false);\n    for(int v = 0; v < conn.size(); ++v){\n        if(match[v] < 0){\n            fill(used.begin(), used.end(), false);\n            if(bipartite_matching_dfs(v, conn, used, match)){ ++res; }\n        }\n    }\n    return match;\n}\n\nll T, n, m, k;\n\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    while(cin >> n >> m >> k){\n        vector<tuple<int, int, int>> v;\n        vi s;\n        REP(i, n) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            v.emplace_back(z, x, y);\n            s.emplace_back(x);\n            s.emplace_back(-y);\n        }\n        sort(RALL(v));\n        sort(ALL(s));\n        UNIQUE(s);\n        map<int, int> mp;\n        REP(i, s.size()) mp[s[i]] = i;\n        vector<vi> g(n + s.size());\n        REP(i, n) {\n            int x, y, z; tie(z, x, y) = v[i];\n            g[i].emplace_back(n + mp[x]);\n            g[i].emplace_back(n + mp[-y]);\n            g[n + mp[x]].emplace_back(i);\n            g[n + mp[-y]].emplace_back(i);\n        }\n        vi match = bipartite_matching(g);\n        ll ans = 0;\n        REP(i, n) {\n            if (match[i] != -1 && match[match[i]] == i) {\n                ans += get<0>(v[i]);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n#define let auto const\n\nint main() {\n  i64 N, H, W;\n  cin >> N >> H >> W;\n  using P = pair<i64 , i64>;\n  map<P, vector<i64>> mp;\n  rep(i,0,N) {\n    i64 r, c, a;\n    cin >> r >> c >> a;\n    mp[P(r, c)].push_back(a);\n  }\n  vector<pair<i64, P>> vec;\n  for(auto& p: mp) {\n    auto& v = p.second;\n    sort(all(v));\n    reverse(all(v));\n    for(int i = 0;i < min(2ll, (i64)v.size()); i++) {\n      vec.push_back(pair<i64, P>(v[i], p.first));\n    }\n  }\n\n  sort(all(vec));\n  reverse(all(vec));\n\n  i64 ans = 0;\n  i64 len = min((i64)vec.size(), H + W);\n  i64 HOK = true, LOK = true;\n  rep(i,0, len) {\n    ans += vec[i].first;\n    if(i > 0) {\n      if(vec[i - 1].second.first != vec[i].second.first) {\n        HOK = false;\n      }\n      if(vec[i - 1].second.second != vec[i].second.second) {\n        LOK = false;\n      }\n    }\n  }\n  if(len == 1) HOK = false, LOK = false;\n  if(HOK) {\n    ans -= vec[len - 1].first;\n    auto pp = vec[len - 1].second.first;\n    for(auto p: vec) {\n      if(p.second.first != pp) {\n        ans += p.first;\n        break;\n      }\n    }\n  }\n  else if(LOK) {\n    ans -= vec[len - 1].first;\n    auto pp = vec[len - 1].second.second;\n    for(auto p: vec) {\n      if(p.second.second != pp) {\n        ans += p.first;\n        break;\n      }\n    }\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n// #define int long long\nusing namespace std;\n\n\nconst int siz=2e5+5;\nvector<vector<pair<int,pair<int,int> > > >adj;\nint parent[siz];\nint sz[siz];\nint vis_ind[siz];\nint vis[siz];\nint mm[siz];\nint find_parent(int ver)\n{\n    if(ver==parent[ver])\n        return ver;\n    return parent[ver]=find_parent(parent[ver]);\n}\n\nbool merge(int a,int b)\n{\n    a=find_parent(a);\n    b=find_parent(b);\n    if(a!=b)\n    {\n        if(sz[a]<sz[b])\n            swap(a,b);\n        sz[a]+=sz[b];\n        parent[b]=a;\n        mm[a]=min(mm[a],mm[b]);\n        return true;\n    }\n    return false;\n}\n\nvector<pair<int,pair<int,int> > >temp;\nvoid dfs(int ver)\n{\n    vis_ind[ver]=1;\n    for(auto i:adj[ver])\n    {\n        if(!vis[i.second.second])\n        {\n            vis[i.second.second]=1;\n            temp.push_back({i.second.first,{i.first,ver}});\n            if(vis_ind[i.first]==0)\n            dfs(i.first);\n        }\n    }\n}\n\nsigned main()\n{\n \nios_base::sync_with_stdio(false);\ncin.tie(NULL);  \ncout.tie(0);   \n \n#ifndef ONLINE_JUDGE\n    if(fopen(\"INPUT.txt\",\"r\"))\n    {\n    freopen (\"INPUT.txt\" , \"r\" , stdin);\n    freopen (\"OUTPUT.txt\" , \"w\" , stdout);\n    }\n#endif      \n\n    int n,h,w;\n    cin>>n>>h>>w;\n    int x,y,z;\n    adj.resize(2e5+5);\n    int lim=1e5;\n    \n    for(int i=0;i<n;i++)\n    {\n        cin>>x>>y>>z;\n        adj[x].push_back({y+lim,{z,i}});\n        adj[y+lim].push_back({x,{z,i}});\n    }    \n\n    for(int i=1;i<=2*lim;i++)\n    {\n        mm[i]=1;\n        parent[i]=i;\n        sz[i]=1;\n    }\n    long long ans=0;\n    for(int i=1;i<=2*lim;i++)\n    {\n        if(!vis_ind[i])\n        {\n            temp.clear();\n            dfs(i);\n            sort(temp.begin(),temp.end(),greater<>());\n            int mx=0;\n            for(auto j:temp)\n            {\n                if(mm[find_parent(j.second.first)]+mm[find_parent(j.second.second)]==0)\n                    continue;\n                int z=merge(j.second.first,j.second.second);\n                if(z==0)\n                {\n                    mm[find_parent(j.second.first)]=0;\n                }\n                ans+=j.first;\n            }\n\n            ans+=mx;\n            \n        }\n    }\n\n    cout<<ans;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define repr(i, n) for (int i = (n) - 1; i >= 0; i--)\n\nusing namespace std;\nusing ll = long long;\n\nstruct unionfind {\n  vector<int> A;\n\n  unionfind(int n) : A(n, -1) {}\n\n  int find(int x) {\n    if (A[x] < 0) return x;\n    return A[x] = find(A[x]);\n  }\n\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (A[x] > A[y]) swap(x, y);\n    A[x] += A[y];\n    A[y] = x;\n  }\n\n  int size(int x) {\n    return -A[find(x)];\n  }\n};\n\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int N, H, W; cin >> N >> H >> W;\n  unionfind uf(H + W);\n  vector<tuple<int, int, int>> es;\n  rep(i, N) {\n    int r, c, a; cin >> r >> c >> a; r--; c--;\n    es.emplace_back(a, r, c + H);\n  }\n  sort(es.rbegin(), es.rend());\n  vector<int> state(H + W);\n  ll ans = 0;\n  for (auto e : es) {\n    int c, u, v;\n    tie(c, u, v) = e;\n    if (uf.find(u) != uf.find(v) && (state[uf.find(u)] == 0 || state[uf.find(v)] == 0)) {\n      ans += c;\n      uf.unite(u, v);\n    } else if (state[uf.find(u)] == 0) {\n      ans += c;\n      state[uf.find(u)] = 1;\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define P pair<ll,ll>\n#define FOR(I,A,B) for(ll I = ll(A); I < ll(B); ++I)\n#define FORR(I,A,B) for(ll I = ll((B)-1); I >= ll(A); --I)\n#define TO(x,t,f) ((x)?(t):(f))\n#define SORT(x) (sort(x.begin(),x.end())) // 0 2 2 3 4 5 8 9\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) //xi>=v  x is sorted\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) //xi>v  x is sorted\n#define NUM(x,v) (POSU(x,v)-POSL(x,v))  //x is sorted\n#define REV(x) (reverse(x.begin(),x.end())) //reverse\nll gcd(ll a,ll b){if(a%b==0)return b;return gcd(b,a%b);}\nll lcm(ll a,ll b){ll c=gcd(a,b);return ((a/c)*(b/c)*c);}\n#define NEXTP(x) next_permutation(x.begin(),x.end())\nconst ll INF=ll(1e18)+ll(7);\nconst ll MOD=1000000007LL;\n#define out(a) cout<<fixed<<setprecision((a))\n\nclass UnionFind{\npublic:\n\tvector<int> par,siz;\n\t//0-indexed\n\tUnionFind(int n){init(n);}\n\tvoid init(int n = 1) {\n\t\tpar.resize(n);\n\t\tsiz.resize(n,1);\n\t\tfor (int i = 0; i < n; ++i) par[i] = i;\n\t}\n\tint root(int x = 1){\n\t\tif(par[x]==x)return x;\n\t\treturn par[x] = root(par[x]);\n\t}\n\tvoid unite(int x = 1,int y = 1){\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif(x==y)return;\n\t\tif(siz[x]>siz[y]){\n\t\t\tsiz[x] += siz[y];\n\t\t\tsiz[y] = 0;\n\t\t\tpar[y] = x;\n\t\t}else{\n\t\t\tsiz[y] += siz[x];\n\t\t\tsiz[x] = 0;\n\t\t\tpar[x] = y;\n\t\t}\n\t}\n\tbool same(int x,int y){\n\t\treturn root(x)==root(y);\n\t}\n};\n\n\n// なもりグラフ\n// https://www.hamayanhamayan.com/entry/2019/08/25/090415\n\nint main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tint N,H,W;\n\tll ans = 0;\n\tcin >> N >> H >> W;\n\tUnionFind uf(H+W+6);\n\tpriority_queue< pair<ll,P> > pq;\n\tFOR(i,0,N){\n\t\tint r,c,a;\n\t\tcin >> r >> c >> a;\n\t\tpq.push({a,{r,c}});\n\t}\n\tFOR(i,0,N){\n\t\tauto X = pq.top();\n\t\tint h = X.second.first;\n\t\tint w = X.second.second;\n\t\tint a = X.first;\n\t\tpq.pop();\n\t\tif(not uf.same(h,w+H)){\n\t\t\tans += a;\n\t\t\tuf.unite(h,w+H);\n\t\t}else if(not uf.same(h,H+W+2)){\n\t\t\tans += a;\n\t\t\tuf.unite(h,H+W+2);\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ci const int&\nusing namespace std;\nstruct edge{\n\tint u,v,val;\n}e[100010];\nint n,m,h,w,u,v,val,f[200010],tg[200010];\nlong long ans;\nbool cmp(edge x,edge y){\n\treturn x.val>y.val;\n}\nint getf(ci x){\n\treturn f[x]!=x?f[x]=getf(f[x]):x;\n}\nvoid Kruscal(){\n\tsort(e+1,e+m+1,cmp);\n\tfor(int i=1;i<=m;++i){\n\t\tif(getf(e[i].u)==getf(e[i].v))!tg[f[e[i].u]]?tg[f[e[i].u]]=1,ans+=e[i].val:0;\n\t\telse if(!tg[f[e[i].u]]||!tg[f[e[i].v]])f[f[e[i].u]]=f[e[i].v],tg[f[e[i].v]]|=tg[f[e[i].u]],ans+=e[i].val;\n\t}\n}\nint main(){\n\tscanf(\"%d%d%d\",&m,&h,&w),n=h+w;\n\tfor(int i=1;i<=n;++i)f[i]=i;\n\tfor(int i=1;i<=m;++i)scanf(\"%d%d%d\",&u,&v,&val),e[i]=(edge){u,h+v,val};\n\tKruscal(),printf(\"%lld\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Link : https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_e\n\n#include <bits/stdc++.h>\nusing namespace std;\n#define ll long long\n#define N 200005\n/*\n#include <limits.h>\nINT_MAX\nLLONG_MAX\n*/\n\npair<int,pair<int,int> >in[N];\n\nint dsu[N],sz[N],numVertex[N];\n\nint f(int x) {\n  if(x==dsu[x]) {\n    return x;\n  }\n  return dsu[x] = f(dsu[x]);\n}\nvoid merge(int x,int y) {\n  x = f(x),y = f(y);\n  if(x!=y) {\n    dsu[y] = x;\n    sz[x] += sz[y];\n    numVertex[x] += numVertex[y];\n  }\n  ++numVertex[x];\n}\n\nvoid solve() {\n  int n,h,w;\n  scanf(\"%d %d %d \", &n,&h,&w);\n  set<int> s;\n  for(int i=0;i<n;++i) {\n    int r,c,w;\n    scanf(\"%d %d %d \", &r,&c,&w);\n    c += h;\n    in[i] = {w,{r,c}};\n  }\n  for(int i=1;i<=w+h;++i) {\n    dsu[i] = i,sz[i] = 1,numVertex[i];\n  }\n  sort(in,in+n);\n  reverse(in,in+n);\n  int num = 0;\n  ll ret = 0;\n  for(int i=0;i<n;++i) {\n    int x= f(in[i].second.first),y = f(in[i].second.second);\n    int numS = 0,numRem;\n    if(x!=y) {\n      numRem = numVertex[x] + numVertex[y];\n      numS = sz[x] + sz[y];\n    } else {\n      numRem = numVertex[x];\n      numS = sz[x];\n    }\n    if(numRem + 1 <= numS) {\n      ret += in[i].first;\n      merge(x,y);\n    }\n  }\n  printf(\"%lld\\n\", ret);\n}\n\nint main() {\n    ///freopen(\"input.txt\",\"r\",stdin);\n    solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\nstruct UnionFind {\n  const int n;\n  V<> t; // root ? -sz : par\n  UnionFind(int n) : n(n), t(n, -1) {}\n  int find(int v) { return t[v] < 0 ? v : t[v] = find(t[v]); }\n  void unite(int u, int v) {\n    if ((u = find(u)) == (v = find(v))) return;\n    if (-t[u] < -t[v]) swap(u, v);\n    t[u] += t[v];\n    t[v] = u;\n  }\n  bool same(int u, int v) { return find(u) == find(v); }\n  int size(int v) { return -t[find(v)]; }\n};\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n, h, w; cin >> n >> h >> w;\n  struct Edge {\n    int u, v, w;\n    bool operator<(const Edge& r) const { return w < r.w; }\n  };\n  V<Edge> es;\n  while (n--) {\n    int r, c, a; cin >> r >> c >> a, --r, --c;\n    es.emplace_back(Edge{r, h + c, a});\n  }\n  sort(rbegin(es), rend(es));\n\n  UnionFind uf(h + w + 1);\n  lint res = 0;\n  for (const auto& e : es) {\n    if (uf.same(e.u, e.v)) {\n      if (uf.same(e.u, h + w)) continue;\n      uf.unite(e.u, h + w);\n    } else {\n      uf.unite(e.u, e.v);\n    }\n    res += e.w;\n  }\n  cout << res << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <bitset>\n#include <algorithm>\n#include <complex>\n#include <array>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<double> VD;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef vector<VD> VVD;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\ntemplate<typename T> void chmin(T &a, T b) { if (a > b) a = b; }\ntemplate<typename T> void chmax(T &a, T b) { if (a < b) a = b; }\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nint main() {\n    int n, h, w;\n    cin >> n >> h >> w;\n    vector<vector<PL>> x(h), y(w);\n    VI r(n), c(n);\n    REP(i,n){\n        r[i] = in() - 1, c[i] = in() - 1;\n        ll v = in();\n        x[r[i]].push_back(PL(v, i));\n        y[c[i]].push_back(PL(v, i));\n    }\n    REP(i,h){\n        sort(ALL(x[i]));\n        reverse(ALL(x[i]));\n    }\n    REP(j,w){\n        sort(ALL(y[j]));\n        reverse(ALL(y[j]));\n    }\n    ll ans = 0;\n    set<int> st;\n    REP(i,h){\n        if (x[i].empty()) continue;\n        ans += x[i][0].first;\n        st.insert(x[i][0].second);\n    }\n    REP(j,w){\n        if (y[j].empty()) continue;\n        ll d = y[j][0].first;\n        ans += d;\n        if (st.count(y[j][0].second)){\n            int i = r[y[j][0].second];\n            // cout << j << \" \" << i << endl;\n            PL px(0, -1), py(0, -1);\n            for (PL p : x[i]) if(st.count(p.second) == 0) chmax(px, p);\n            for (PL p : y[j]) if(st.count(p.second) == 0) chmax(py, p);\n            if (px > py){\n                ans -= d - px.first;\n                st.insert(px.second);\n            }else{\n                ans -= d - py.first;\n                st.insert(py.second);\n            }\n        }else{\n            st.insert(y[j][0].second);\n        }\n        // cout << ans << endl;\n    }\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cassert>\n#include<stdexcept>\n#include<utility>\n#include<functional>\n#include<numeric>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<array>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<complex>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<string>\n#include<bitset>\n#include<memory>\n#include<vector>\n#include<numeric>\n\nnamespace ProconLib{\n    class UnionFind{\n        int N;\n        std::vector<int> par;\n        std::vector<int> rank;\n        public:\n        UnionFind(int N):N(N),par(N),rank(N,0){std::iota(par.begin(),par.end(),0);}\n        int find(int x);\n        void unite(int x,int y);\n        bool same(int x,int y){return find(x)==find(y);}\n    };\n\n    int UnionFind::find(int x){\n        if(par[x]==x) return x;\n        return par[x]=find(par[x]);\n    }\n    void UnionFind::unite(int x,int y){\n        x=find(x),y=find(y);\n        if(x==y) return;\n        if(rank[x]>=rank[y]){\n            if(rank[x]==rank[y]) rank[x]++;\n            par[y]=x;\n        }else{\n            par[x]=y;\n        }\n    }\n}using namespace std;\nusing namespace ProconLib;\nusing ll=long long;\n\nstruct Card{\n    int r,c,a;\n    int id;\n};\n\nstruct Edge{\n    int to;\n    ll w;\n};\nusing Graph=vector<vector<Edge>>;\nGraph g;\nvector<int> used;\nint dfs(int v){\n    used[v]=true;\n    for(auto to:g[v]){\n        if(!used[to.to]) dfs(to.to);\n    }\n    return 0;\n}\nint main(){\n    int n,h,w;\n    cin>>n>>h>>w;\n    vector<Card> cards(n);\n    for(int i=0;i<n;i++){\n        cin>>cards[i].r>>cards[i].c>>cards[i].a;\n        cards[i].r--;\n        cards[i].c--;\n        cards[i].id=i;\n    }\n    sort(cards.begin(),cards.end(),[](Card lhs,Card rhs){return lhs.a>rhs.a;});\n    vector<int> flag(n);\n\n    g.resize(h+w);\n    used.resize(h+w);\n    UnionFind u(h+w);\n    \n    ll res=0;\n    for(auto &card:cards){\n        int x=card.r;\n        int y=card.c+h;\n        if(u.same(x,y)){\n            if(used[x]+used[y]==0){\n                res+=card.a;\n                g[x].push_back(Edge{y,card.a});\n                g[y].push_back(Edge{x,card.a});\n                dfs(x);\n            }\n            else{\n                continue;\n            }\n        }\n        if(used[x] && used[y]){\n            continue;\n        }\n        else if(used[x]||used[y]){\n            g[x].push_back(Edge{y,card.a});\n            g[y].push_back(Edge{x,card.a});\n            used[x]=used[y]=true;\n            u.unite(x,y);\n            res+=card.a;\n        }\n        else{\n            u.unite(x,y);\n            g[x].push_back(Edge{y,card.a});\n            g[y].push_back(Edge{x,card.a});\n            res+=card.a;\n        }\n    }\n    cout<<res<<endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <bits/stdc++.h>\n\n#define mp make_pair\n#define all(c) (c).begin() , (c).end()\n#define sz(c) ((long long)((c).size()))\n#define phb push_back\n#define ppb pop_back\n#define phf push_front\n#define ppf pop_front\n\nusing namespace __gnu_pbds;\nusing namespace std;\n\n#define int ll\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\n#define x first\n#define y second\n\ntemplate\n<\n    class key,\n    class val=null_type,\n    class comp=less<key>\n>\nusing ord_set=tree\n<\n    key,\n    val,\n    comp,\n    rb_tree_tag,\n    tree_order_statistics_node_update\n>;\n\nconst int N=1e5+100;\n\narray<int,3> card[N];\n\nint p[2*N],ver[2*N],ed[2*N];\n\nint par(int x)\n{\n    return x==p[x]?x:p[x]=par(p[x]);\n}\n\nint un(int x,int y)\n{\n    x=par(x);\n    y=par(y);\n    if(x==y)\n        return x;\n    ver[x]=ver[y]=ver[x]+ver[y];\n    ed[x]=ed[y]=ed[x]+ed[y];\n    if(rand()%2)\n        return p[x]=y,y;\n    else\n        return p[y]=x,x;\n}\n\nsigned main()\n{\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n\n    for(int i=0;i<2*N;i++)\n        p[i]=i,ver[i]=1;\n\n    int n,h,w;\n    cin>>n>>h>>w;\n    for(int i=1;i<=n;i++)\n        cin>>card[i][1]>>card[i][2]>>card[i][0];\n    sort(card+1,card+n+1,greater<array<int,3>>());\n    int ans=0;\n//    set<pii> s;\n    for(int i=1;i<=n;i++)\n    {\n        int r=card[i][1],c=card[i][2],a=card[i][0];\n        int x=r,y=N+c;\n        x=par(x),y=par(y);\n        bool b1=ver[x]==ed[x];\n        bool b2=ver[y]==ed[y];\n        if(b1&&b2)\n            continue;\n        ed[un(x,y)]++;\n        ans+=a;\n    }\n    cout<<ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nconst int MAX=1e6+7;\nusing namespace std;\nint fa[MAX],rem[MAX];\nstruct node\n{\n\tint x;\n\tint y;\n\tint v;\n}Map[MAX];\nint find(int n)\n{\n\tif(fa[n]==n)\n\t{\n\t\treturn n;\n\t}\n\telse return fa[n]=find(fa[n]);\n} \nvoid merge(int a,int b)\n{\n\tfa[find(a)]=find(b);\n}\nbool cmp(node a,node b)\n{\n\treturn a.v>b.v;\n}\nint k=0;\nsigned main()\n{\n\tint T,n,m,ans=0;\n\tcin>>T>>n>>m;\n\tfor(int i=1;i<=T;i++)\n\t{\n\t\tcin>>Map[i].x>>Map[i].y>>Map[i].v;\n\t} \n\tsort(Map+1,Map+1+T,cmp);\n\tfor(int i=1;i<=n+m;i++)\n\t{\n\t\tfa[i]=i;\n\t\trem[i]=1;\n\t}\n\tfor(int i=1;i<=T;i++)\n\t{\n\t\tint fx=find(Map[i].x),fy=find(Map[i].y+n);\n\t\tif(fx==fy)\n\t\t{\n\t\t\tif(rem[fx])\n\t\t\t{\n\t\t\t\trem[fx]--;\n\t\t\t\tans+=Map[i].v;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(rem[fx]||rem[fy])\n\t\t\t{\n\t\t\t\trem[fx]+=rem[fy];\n\t\t\t\trem[fx]--;\n\t\t\t\tmerge(Map[i].x,Map[i].y+n);\n\t\t\t\tans+=Map[i].v;\n\t\t\t}\n\t\t}\n\t\t//cout<<\"ans=\"<<ans<<endl;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int MAXN = 1e5 + 10;\n\nstruct node{\n    int u,v;\n    ll w;\n}edge[MAXN];\n\nbool cmp(node a,node b){return a.w > b.w;}\n\nint cy[MAXN<<1],n,h,w;\nbool vis[MAXN];\n\nbool dfs(int i)\n{\n    if (vis[i]) return false;\n    ll num = (ll)edge[i].u * 1000000 + (ll)edge[i].v;\n    if (g.count(num) && g[num] >= 2) return false;\n    vis[i] = 1;\n    if (cy[edge[i].u] == 0)\n    {\n        cy[edge[i].u] = i;\n        return true;\n    }\n    else if (cy[edge[i].v + MAXN] == 0)\n    {\n        cy[edge[i].v + MAXN] = i;\n        return true;\n    }\n    if (dfs(cy[edge[i].u]))\n    {\n        cy[edge[i].u] = i;\n        return true;\n    }\n    else if (dfs(cy[edge[i].v + MAXN]))\n    {\n        cy[edge[i].v + MAXN] = i;\n        return true;\n    }\n    return false;\n}\n\nunordered_map<ll,int> g;\n\nll match()\n{\n    for (int i = 1;i<=n;i++)\n    {\n        memset(vis,0,sizeof(vis));\n        ll num = (ll)edge[i].u * 1000000 + (ll)edge[i].v;\n        if (g.count(num) && g[num] >= 2) continue;\n        g[num]++;\n        // for(int j=1;j<=n;j++) vis[i]=0;\n        dfs(i);\n    }\n    ll ans = 0;\n    for (int i = 1;i<=h;i++) ans += edge[cy[i]].w;\n    for (int i = MAXN + 1;i<=MAXN + w;i++) ans += edge[cy[i]].w;\n    return ans;\n}\n\nint main()\n{\n    // cin>>n>>h>>w;\n    scanf(\"%d%d%d\",&n,&h,&w);\n    for (int i = 1;i<=n;i++)\n    {\n        scanf(\"%d%d%lld\",&edge[i].u,&edge[i].v,&edge[i].w);\n    }\n    sort(edge+1,edge + n + 1,cmp);\n    // cout<<match();\n    printf(\"%lld\",match());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n//#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\nclass UnionFind{\nprivate:\n    ::std::vector<int_fast32_t> par, edge;\n    size_t n;\n\npublic:\n    UnionFind(){}\n    UnionFind(size_t n):n(n){\n        par.resize(n, -1);\n        edge.resize(n, 0);\n    }\n\n    uint_fast32_t find(uint_fast32_t x){\n        return par[x] < 0 ? x : par[x] = find(par[x]);\n    }\n\n    size_t size(uint_fast32_t x){\n        return -par[find(x)];\n    }\n\n    bool unite(uint_fast32_t x, uint_fast32_t y){\n        x = find(x);\n        y = find(y);\n        edge[x] += 1;\n        if(x == y) return false;\n        if(size(x) < size(y)) std::swap(x, y);\n        par[x] += par[y];\n        edge[x] += edge[y];\n        par[y] = x;\n        return true;\n    }\n\n    bool same(uint_fast32_t x, uint_fast32_t y){\n        return find(x) == find(y);\n    }\n\n    size_t esize(uint_fast32_t x) {\n        return edge[find(x)];\n    }\n};\n\nint main(void) {\n    int64 H, W, N;\n    cin >> N >> H >> W;\n    using T = tuple<int64, int64, int64>;\n    vector<T> v;\n    REP(i, N) {\n        int64 r, c, a;\n        cin >> r >> c >> a;\n        v.emplace_back(a, r-1, H+c-1);\n    }\n    sort(all(v), greater<>());\n    UnionFind uf(H+W);\n    int64 res = 0;\n    REP(i, N) {\n        int64 r, c, a;\n        tie(a, r, c) = v[i];\n//        cout << a << \" \" << r << \" \" << c << \": \" << uf.same(r, c) << \" \" << uf.size(r) << \" \";\n//        cout << uf.size(c) << \" \" << uf.esize(r) << \" \" << uf.esize(c) << \" \";\n        if ((!uf.same(r, c) && (uf.size(r) + uf.size(c) > uf.esize(r) + uf.esize(c))) || (uf.same(r, c) && uf.size(r) > uf.esize(r))) {\n            res += a;\n//            cout << \"ok\";\n            uf.unite(r, c);\n        }\n//        cout << endl;\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//minamoto\n#include<bits/stdc++.h>\n#define R register\n#define fp(i,a,b) for(R int i=(a),I=(b)+1;i<I;++i)\n#define fd(i,a,b) for(R int i=(a),I=(b)-1;i>I;--i)\n#define go(u) for(int i=head[u],v=e[i].v;i;i=e[i].nx,v=e[i].v)\ntemplate<class T>inline bool cmax(T&a,const T&b){return a<b?a=b,1:0;}\ntemplate<class T>inline bool cmin(T&a,const T&b){return a>b?a=b,1:0;}\nusing namespace std;\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAX 100100\n#define ll long long\ninline int read()\n{\n    int x=0;bool t=false;char ch=getchar();\n    while((ch<'0'||ch>'9')&&ch!='-')ch=getchar();\n    if(ch=='-')t=true,ch=getchar();\n    while(ch<='9'&&ch>='0')x=x*10+ch-48,ch=getchar();\n    return t?-x:x;\n}\nll ans;\nint n,h,w,tot,f[MAX];\nbool cir[MAX];\nstruct edge{int u,v,w;}E[MAX];\nbool operator<(edge a,edge b){return a.w>b.w;}\nint getf(int x){return x==f[x]?x:f[x]=getf(f[x]);}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&h,&w);\n    for(int i=1;i<=h+w;++i)f[i]=i;\n    fp(i,1,n){\n    \tR int x,y,c;\n    \tscanf(\"%d%d%d\",&x,&y,&c);\n    \t\n            E[++tot]=(edge){x,y+h,c};\n\t}\n//    for(int i=1;i<=n;++i)\n//        for(int j=1;j<=m;++j)\n//            E[++tot]=(edge){i,j+n,read()};\n    sort(&E[1],&E[tot+1]);\n    for(int i=1;i<=tot;++i)\n    {\n        int u=getf(E[i].u),v=getf(E[i].v);\n        if(u==v){if(!cir[u])cir[u]=true,ans+=E[i].w;}\n        else if(!cir[u]||!cir[v])\n            f[u]=v,ans+=E[i].w,cir[v]|=cir[u];\n    }\n    printf(\"%lld\\n\",ans);return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = (int)(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\nusing ll = long long;\nusing namespace std;\n\nll solve(int n, int h, int w, const vector<int> & y, const vector<int> & x, const vector<ll> & a) {\n    vector<int> row(h, -1), col(w, -1);\n    function<bool (int, int)> go_row, go_col;\n    set<int> used_row, used_col;\n    go_row = [&](int y, int i) {\n        if (used_row.count(y)) return false;\n        used_row.insert(y);\n        if (row[y] == -1) {\n            row[y] = i;\n            return true;\n        } else {\n            int j = row[y];\n            bool p = go_col(x[j], j);\n            if (p) row[y] = i;\n            return p;\n        }\n    };\n    go_col = [&](int x, int i) {\n        if (used_col.count(x)) return false;\n        used_col.insert(x);\n        if (col[x] == -1) {\n            col[x] = i;\n            return true;\n        } else {\n            int j = col[x];\n            bool p = go_row(y[j], j);\n            if (p) col[x] = i;\n            return p;\n        }\n    };\n\n    ll answer = 0;\n\n    vector<int> order(n);\n    iota(ALL(order), 0);\n    sort(ALL(order), [&](int i, int j) { return a[i] > a[j]; });\n    for (int i : order) {\n        used_row.clear();\n        used_col.clear();\n        if (go_row(y[i], i)) {\n            row[y[i]] = i;\n            answer += a[i];\n        } else if (go_col(x[i], i)) {\n            col[x[i]] = i;\n            answer += a[i];\n        }\n    }\n    return answer;\n}\n\nint main() {\n    int n, h, w; cin >> n >> h >> w;\n    vector<int> y(n), x(n);\n    vector<ll> a(n);\n    REP (i, n) {\n        cin >> y[i] >> x[i] >> a[i];\n        -- y[i];\n        -- x[i];\n    }\n    cout << solve(n, h, w, y, x, a) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define loop(n) for (int ngtkana_is_genius = 0; ngtkana_is_genius < int(n); ngtkana_is_genius++)\n#define rep(i, begin, end) for(int i = int(begin); i < int(end); i++)\n#define lint long long\nauto cmn = [](auto& a, auto b){if (a > b) {a = b; return true;} return false;};\nauto cmx = [](auto& a, auto b){if (a < b) {a = b; return true;} return false;};\nvoid debug_impl() { std::cerr << std::endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_impl(Head head, Tail... tail){\n  std::cerr << \" \" << head;\n  debug_impl(tail...);\n}\n#define debug(...) std::cerr << std::boolalpha << \"[\" << #__VA_ARGS__ << \"]:\";\\\n  debug_impl(__VA_ARGS__);\\\n  std::cerr << std::noboolalpha;\n\ntemplate <typename Value, typename BinaryOp>\nclass valued_union_find_tree\n{\n  int                n;\n  std::vector<Value> table;\n  std::vector<int>   prt;\n  BinaryOp           op;\n  Value              id;\n\npublic:\n  valued_union_find_tree (int n, BinaryOp op, Value id, Value init) :\n    n(n), table(n, init), prt(n, -1), op(op), id(id)\n    {}\n\n  bool is_root (int x)        const {return prt.at(x) < 0;}\n\n  int  size    (int x)        const {return -prt.at(find(x));}\n\n  bool same    (int x, int y) const {return find(x) == find(y);}\n\n  int  find    (int x)        const\n  {\n    while (!is_root(x)) x = prt.at(x);\n    return x;\n  }\n\n  auto collect ()             const {return prt;}\n\n  auto collect_vals ()        const {return table;}\n\n  auto get     (int x)        const {return table.at(find(x));}\n\n  void set     (int x, Value val)    {table.at(find(x)) = val;}\n\n  // Returns `true` if x and y are newly connected.\n  // y becomes the partent.\n  bool unite   (int x, int y)\n  {\n    if ((x = find(x)) == (y = find(y))) return false;\n    if (size(x) > size(y)) std::swap(x, y);\n    prt.at(y) += prt.at(x);\n    prt.at(x) = y;\n    table.at(y) = op(table.at(y), table.at(x));\n    table.at(x) = id;\n    return true;\n  }\n};\n\ntemplate <typename Value, typename BinaryOp>\nauto make_valued_union_find_tree(int n, BinaryOp op, Value id, Value init)\n{\n  return valued_union_find_tree<Value, BinaryOp>(n, op, id, init);\n}\n\nint main()\n{\n  std::cin.tie(0); std::cin.sync_with_stdio(false);\n  int n, h, w;\n  std::cin >> n >> h >> w;\n  auto queries = std::vector<std::tuple<int, int, int>>(n);\n  rep(i, 0, n)\n  {\n    int x, y, a;\n    std::cin >> x >> y >> a;\n    x--, y--, y += h;\n    queries.at(i) = std::make_tuple(a, x, y);\n  }\n  auto uf = make_valued_union_find_tree\n  (\n    h + w,\n    [](auto x, auto y){return x + y;},\n    0,\n    1\n  );\n  std::sort(queries.begin(), queries.end());\n  std::reverse(queries.begin(), queries.end());\n  auto sat = [&] (int x) -> bool\n  {\n    auto dif = uf.get(x) - uf.size(x);\n    assert(dif == 0 || dif == 1);\n    return dif;\n  };\n  lint ret = 0;\n  for (auto tuple : queries)\n  {\n    int a, x, y;\n    std::tie(a, x, y) = tuple;\n    if (!uf.same(x, y) && (!sat(x) || !sat(y)))\n    {\n      uf.unite(x, y);\n      ret += a;\n    }\n    else if (uf.same(x, y) && !sat(x))\n    {\n      assert(!sat(y));\n      uf.set(y, uf.get(y) + 1);\n      ret += a;\n    }\n  }\n  std::cout << ret << std::endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1 };\nvel dy = { 1,-1,0,0 };\nvoid sol(int i,int ba, vvel& nex,vvel& adj,vvel& use, vel& cnt) {\n\tif (use[i].size() == 0 || use[i].back() != ba) {\n\t\tuse[i].push_back(ba);\n\t\tif (cnt[i] == 0) {\n\t\t\tadj[i].push_back(ba);\n\t\t}\n\t\tfor (auto ne : nex[i]) {\n\t\t\tsol(ne, ba, nex, adj, use, cnt);\n\t\t}\n\t}\n}\nsigned main() {\n\tomajinai;\n\tint n, h, w; cin >> n >> h >> w;\n\tvvel cxy(n);\n\tvvel y_i(w);\n\tvvel x_i(h);\n\trep(i, n) {\n\t\tint c, x, y; cin >> x >> y >> c; x--; y--;\n\t\tcxy[i] = { c,x,y };\n\t}\n\tsor(cxy);\n\trep(i, n) {\n\t\tint x = cxy[i][1];\n\t\tint y = cxy[i][2];\n\t\ty_i[y].push_back(i);\n\t\tx_i[x].push_back(i);\n\t}\n\tvel cnt(n, 0);\n\tvvel nex(n);\n\trep(i, w) { \n\t\tsor(y_i[i]);\n\t\tint sz = y_i[i].size();\n\t\tif (sz != 0) {\n\t\t\tcnt[y_i[i].back()]++;\n\t\t\trep(j, sz - 1) {\n\t\t\t\tnex[y_i[i][j + 1]].push_back(y_i[i][j]);\n\t\t\t}\n\t\t}\n\n\t}\n\trep(i, h) { \n\t\tsor(x_i[i]);\n\t\tint sz = x_i[i].size();\n\t\tif (sz != 0) {\n\t\t\tcnt[x_i[i].back()]++;\n\t\t\trep(j, sz - 1) {\n\t\t\t\tnex[x_i[i][j + 1]].push_back(x_i[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\tvvel adj(n);\n\tvvel use(n);\n\tint ans = 0;\n\trep(i, n) {\n\t\tif (cnt[i] == 2) {\n\t\t\tsol(i,i, nex,adj,use, cnt);\n\t\t}\n\t\tif (cnt[i] >= 1) { ans += cxy[i][0]; }\n\t}\n\tvel pa(n, -1);\n\tvvel ed;\n\trep(i, n) {\n\t\tvel v = adj[i];\n\t\tsor(v);\n\t\tif (v.size() >= 1) {\n\t\t\ted.push_back({ cxy[i][0],v[0],v.back() });\n\t\t}\n\t}\n\tsor(ed); rev(ed);\n\tvel ex(n, 0);\n\tfor (auto v : ed) {\n\t\tint c = v[0];\n\t\tint x = root(v[1], pa);\n\t\tint y = root(v[2], pa);\n\t\tif (x == y) {\n\t\t\tif (ex[x] == 0) {\n\t\t\t\tex[x] = 1;\n\t\t\t\tans += c;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (ex[x] + ex[y]<=1) {\n\t\t\t\tpa[x] = y;\n\t\t\t\tex[y] += ex[x]; ex[x] = 0;\n\t\t\t\tans += c;\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\ntypedef long long ll;\n#define inf 0x3f3f3f3f\nint n,h,w;\nint x[maxn],y[maxn];\nll a[maxn];\nset<pair<ll,int> > qx[maxn],qy[maxn];\nvector<pair<ll,int> >cards;\nll ax,ay;\nbool ux[maxn],uy[maxn],usd[maxn];\nint cx[maxn],cy[maxn];\nqueue<int> que;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&h,&w);\n//\tmemset(cx,-1,sizeof(cx));\n//\tmemset(cy,-1,sizeof(cy));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%lld\",&x[i],&y[i],&a[i]);\n\t\tx[i]--;\n\t\ty[i]--;\n\t\tcx[x[i]]++;\n\t\tcy[y[i]]++;\n\t}\n    ll ans=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(cx[x[i]]==1||cy[y[i]]==1)\n\t\t\tque.push(i);\n\t\telse\n\t\t{\n\t\t\tqx[x[i]].insert(make_pair(a[i],i));\n\t\t\tqy[y[i]].insert(make_pair(a[i],i));\n\t\t}\n\t}\n\twhile(!que.empty())\n\t{\n\t\tint cur=que.front();\n\t\tque.pop();\n\t\tusd[cur]=1;\n\t\tans+=a[cur];\n\t\tusd[cur]=1;\n\t\tcx[x[cur]]--;\n\t\tcy[y[cur]]--;\n\t\tif(cx[x[cur]]==1)\n\t\t{\n\t\t\tif(!qx[x[cur]].empty())\n\t\t\t{\n\t\t\t\tpair<ll,int> he=*(qx[x[cur]].begin());\n\t\t\t\tqx[x[cur]].clear();\n\t\t\t\tint id=he.second;\n\t\t\t\tque.push(id);\n\t\t\t\tqy[y[id]].erase(he);\n\t\t\t}\n\t\t}\n\t\tif(cy[y[cur]]==1)\n\t\t{\n\t\t\tif(!qy[y[cur]].empty())\n\t\t\t{\n\t\t\t\tpair<ll,int> he=*(qy[y[cur]].begin());\n\t\t\t\tqy[y[cur]].clear();\n\t\t\t\tint id=he.second;\n\t\t\t\tque.push(id);\n\t\t\t\tqx[x[id]].erase(he);\n\t\t\t}\n\t\t}\n\t}\n//\tcout<<ans<<endl;\n\tfor(int i=0;i<n;i++)if(!usd[i])\n\t\tcards.push_back(make_pair(a[i],i));\n\t\t\n    sort(cards.begin(),cards.end());\n    reverse(cards.begin(),cards.end());\n    for(int _=0;_<cards.size();_++)\n    {\n    \tint i=cards[_].second;\n\t//\tcout<<i<<\" \"<<x[i]<<\" \"<<y[i]<<\" \"<<qx[x[i]].top().second<<\" \"<<qy[y[i]].top().second<<endl;\n        qx[x[i]].erase(make_pair(a[i],i));\n        qy[y[i]].erase(make_pair(a[i],i));\n        if(ux[x[i]]&&uy[y[i]])continue;\n        if(ux[x[i]])\n        \tuy[y[i]]=1;\n        else if(uy[y[i]])\n        \tux[x[i]]=1;\n        else\n\t\t{\n\t\t\tax=qx[x[i]].empty()?-inf:(*(qx[x[i]].rbegin())).first;\n\t\t\tay=qy[y[i]].empty()?-inf:(*(qy[y[i]].rbegin())).first;\n\t\t\tif(ax<ay)\n\t\t\t{\n        //   \tcout<<\"puthang \"<<x[i]<<endl;\n            \tux[x[i]]=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n      \t//    \tcout<<\"putlie \"<<y[i]<<endl;\n \t    \t\tuy[y[i]]=1;\n \t    \t}\n        }\n        ans+=a[i];\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define SZ(x) ((int)x.size())\n#define pb push_back\n#define fi first\n#define se second\n#define L(i,u) for (int i=head[u]; i!=0; i=nxt[i])\n#define rep(i,a,b) for (register int i=a; i<=b; i++)\n#define per(i,a,b) for (register int i=a; i>=b; i--)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int ui;\ntypedef pair<int,int> Pii;\ntypedef vector<int> Vi;\ninline void read(int &x) {\n\tx=0; char c=getchar(); int f=1;\n\twhile (!isdigit(c)) {if (c=='-') f=-1; c=getchar();}\n\twhile (isdigit(c)) {x=x*10+c-'0'; c=getchar();} x*=f;\n}\ninline ui R() {\n\tstatic ui seed=416;\n\treturn seed^=seed>>5,seed^=seed<<17,seed^=seed>>13;\n}\nconst int N = 300005, M = 600005, inf = 0x3f3f3f3f;\nint n,h,w,head[N],cur[N],nxt[M],to[M],edgenum,match[N];\nbool xuan[N],vis[N];\nstruct node{\n\tint r,c,w;\n}s[N];\nbool cmp(node a, node b){return a.w>b.w;}\nvoid addedge(int u, int v){\n\tto[++edgenum]=v;nxt[edgenum]=head[u];head[u]=edgenum;\n}\nvoid add(int u, int v){\n\taddedge(u,v);addedge(v,u);\n}\nint sta[N],top;\nbool dfs(int u){\n\tif(vis[u])return 0;vis[u]=1;sta[++top]=u;\n\tL(i,u)if(!match[to[i]]||dfs(match[to[i]])){\n\t\tmatch[u]=to[i];match[to[i]]=u;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nvoid print(int T){\n\tprintf(\"---%d---\\n\",T);\n\trep(i,1,n)printf(\"%d \",match[i]-n);puts(\"\");\n}\nint main() {\n\tread(n);read(h);read(w);\n\trep(i,1,n){\n\t\tread(s[i].r);read(s[i].c);read(s[i].w);\n\t}\n\tsort(s+1,s+n+1,cmp);ll res=0;\n\trep(i,1,n){\n\t\tadd(i,1e5+s[i].r);\n\t\tadd(i,2e5+s[i].c);\n\t}\n\t\n\trep(i,1,n){\n\t\tif(dfs(i))res+=s[i].w;\n\t\twhile(top)vis[sta[top--]]=0;\n\t//\tprint(i);\n\t}\n\tcout<<res;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define repr(i, n) for (int i = (n) - 1; i >= 0; i--)\n\nusing namespace std;\nusing ll = long long;\n\nstruct unionfind {\n  vector<int> A;\n\n  unionfind(int n) : A(n, -1) {}\n\n  int find(int x) {\n    if (A[x] < 0) return x;\n    return A[x] = find(A[x]);\n  }\n\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) return;\n    if (A[x] > A[y]) swap(x, y);\n    A[x] += A[y];\n    A[y] = x;\n  }\n\n  int size(int x) {\n    return -A[find(x)];\n  }\n};\n\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int N, H, W; cin >> N >> H >> W;\n  unionfind uf(H + W);\n  vector<tuple<int, int, int>> es;\n  rep(i, N) {\n    int r, c, a; cin >> r >> c >> a; r--; c--;\n    es.emplace_back(a, r, c + H);\n  }\n  sort(es.rbegin(), es.rend());\n  vector<int> state(H + W);\n  ll ans = 0;\n  for (auto e : es) {\n    int c, u, v;\n    tie(c, u, v) = e;\n    if (uf.find(u) != uf.find(v) && (state[uf.find(u)] == 0 || state[uf.find(v)] == 0)) {\n      int x = state[uf.find(u)] || state[uf.find(v)];\n      ans += c;\n      uf.unite(u, v);\n      state[uf.find(u)] = x;\n    } else if (state[uf.find(u)] == 0) {\n      ans += c;\n      state[uf.find(u)] = 1;\n    }\n  }\n  cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Created by yamunaku on 2019/08/24.\n//\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repl(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perl(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD9 998244353\n#define MOD1 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n#define CST(x) cout<<fixed<<setprecision(x)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> mti;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> mtl;\n\ntemplate< typename flow_t, typename cost_t >\nstruct PrimalDual {\n    const cost_t INF;\n\n    struct edge {\n        int to;\n        flow_t cap;\n        cost_t cost;\n        int rev;\n        bool isrev;\n    };\n    vector< vector< edge > > graph;\n    vector< cost_t > potential, min_cost;\n    vector< int > prevv, preve;\n\n    PrimalDual(int V) : graph(V), INF(numeric_limits< cost_t >::max()) {}\n\n    void add_edge(int from, int to, flow_t cap, cost_t cost) {\n        graph[from].emplace_back((edge) {to, cap, cost, (int) graph[to].size(), false});\n        graph[to].emplace_back((edge) {from, 0, -cost, (int) graph[from].size() - 1, true});\n    }\n\n    cost_t min_cost_flow(int s, int t) {\n        int V = (int) graph.size();\n        cost_t ret = 0;\n        using Pi = pair< cost_t, int >;\n        priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n        potential.assign(V, 0);\n        preve.assign(V, -1);\n        prevv.assign(V, -1);\n        cost_t ans=0;\n        cost_t xxx=0;\n        while(1){\n            cost_t f=1;\n            min_cost.assign(V, INF);\n            que.emplace(0, s);\n            min_cost[s] = 0;\n            while(!que.empty()) {\n                Pi p = que.top();\n                que.pop();\n                if(min_cost[p.second] < p.first) continue;\n                for(int i = 0; i < graph[p.second].size(); i++) {\n                    edge &e = graph[p.second][i];\n                    cost_t nextCost = min_cost[p.second] + e.cost + potential[p.second] - potential[e.to];\n                    if(e.cap > 0 && min_cost[e.to] > nextCost) {\n                        min_cost[e.to] = nextCost;\n                        prevv[e.to] = p.second, preve[e.to] = i;\n                        que.emplace(min_cost[e.to], e.to);\n                    }\n                }\n            }\n            if(min_cost[t] == INF) return ans;\n            for(int v = 0; v < V; v++) potential[v] += min_cost[v];\n            ret += potential[t];\n            for(int v = t; v != s; v = prevv[v]) {\n                edge &e = graph[prevv[v]][preve[v]];\n                e.cap--;\n                graph[v][e.rev].cap++;\n            }\n            xxx++;\n            ans=max(ans,IINF*xxx-ret);\n        }\n        return ans;\n    }\n\n    void output() {\n        for(int i = 0; i < graph.size(); i++) {\n            for(auto &e : graph[i]) {\n                if(e.isrev) continue;\n                auto &rev_e = graph[e.to][e.rev];\n                cout << i << \"->\" << e.to << \" (flow: \" << rev_e.cap << \"/\" << rev_e.cap + e.cap << \")\" << endl;\n            }\n        }\n    }\n};\n\nint main(){\n    int n,h,w;\n    cin >> n;\n    cin >> h >> w;\n    vi r(n),c(n),a(n);\n    map<int,int> rmp,cmp;\n    rep(i,n){\n        cin >> r[i] >> c[i] >> a[i];\n        rmp[r[i]]=0;\n        cmp[c[i]]=0;\n    }\n    int idx=0;\n    for(auto &p:rmp) p.second=idx++;\n    idx=0;\n    for(auto &p:cmp) p.second=idx++;\n    int rs=rmp.size(),cs=cmp.size();\n    int sz=rs+cs+n+2;\n    PrimalDual<int,ll> pd(sz);\n    rep(i,rs){\n        pd.add_edge(0,i+2,1,0);\n    }\n    rep(i,cs){\n        pd.add_edge(0,rs+i+2,1,0);\n    }\n    rep(i,n){\n        pd.add_edge(rmp[r[i]]+2,rs+cs+i+2,1,0);\n        pd.add_edge(rs+cmp[c[i]]+2,rs+cs+i+2,1,0);\n        pd.add_edge(rs+cs+i+2,1,1,IINF-a[i]);\n    }\n    cout << pd.min_cost_flow(0,1) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nnamespace io{\n\tconst int l=1<<20;\n\tchar buf[l],*s,*t;\n\tinline char gc(){\n\t\tif(s==t){\n\t\t\tt=(s=buf)+fread(buf,1,l,stdin);\n\t\t\treturn s==t?EOF:*s++;\n\t\t}\n\t\treturn *s++;\n\t}\n\tchar c;\n\ttemplate<class IT>inline void gi(IT &x){\n\t\tx=0;c=gc();while(c<'0'||c>'9')c=gc();\n\t\twhile('0'<=c&&c<='9'){x=(x<<1)+(x<<3)+(c^'0');c=gc();}\n\t}\n};\nusing io::gi;\nstruct qwq{\n\tint a,b;\n\tinline bool operator<(const qwq &x)const{\n\t\treturn a<x.a;\n\t}\n};\ntemplate<class IT>inline void cmin(IT &a,IT b){if(b<a)a=b;}\ntemplate<class IT>inline void cmax(IT &a,IT b){if(a<b)a=b;}\nconst ll p=998244353ll,inf=1000000000000000000ll;\nconst int N=300005,E=1000005;\nstruct edge{\n\tint v,u,w,n;\n\tinline edge(){}\n\tinline edge(int v,int u,int w,int n):v(v),u(u),w(w),n(n){}\n}e[E];\nint fi[N],te;\ninline void addedge(int v,int u,int w1,int w2){\n\te[te]=edge(u,w1, w2,fi[v]);fi[v]=te++;\n\te[te]=edge(v, 0,-w2,fi[u]);fi[u]=te++;\n}\nint pv[N],pe[N],q[N],in[N],d[N],S,T;\ninline int spfa(){\n\tint v,i,u,w,qh=1,qt=1;\n\tfor(i=1;i<=T;++i){d[i]=-1;in[i]=0;}\n\td[q[1]=S]=0;\n\twhile(qh<=qt){\n\t\tv=q[(qh++)%N];in[v]=0;\n\t\tfor(i=fi[v];~i;i=e[i].n)if(e[i].u){\n\t\t\tu=e[i].v;\n\t\t\tw=e[i].w+d[v];\n\t\t\tif(w>d[u]){\n\t\t\t\td [u]=w;\n\t\t\t\tpv[u]=v;\n\t\t\t\tpe[u]=i;\n\t\t\t\tif(!in[u]){in[u]=1;q[(++qt)%N]=u;}\n\t\t\t}\n\t\t}\n\t}\n//\tfor(i=1;i<=T;++i)printf(\"%d \",d[i]);printf(\"\\n\");\n\treturn d[T];\n}\nint main(){\n\tint t,n,m,a,b,c,i,sp,lo,s=0;\n\tmemset(fi,-1,sizeof(fi));\n\tscanf(\"%d%d%d\",&t,&n,&m);\n\tT=(S=t+n+m+1)+1;\n\tfor(i=1;i<=n+m;++i)addedge(S,i,1,0);\n\tfor(i=1;i<=t  ;++i){\n\t\tscanf(\"%d%d%d\",&a,&b,&c);\n\t\taddedge(    a,n+m+i,1,0);\n\t\taddedge(n+  b,n+m+i,1,0);\n\t\taddedge(n+m+i,T    ,1,c);\n\t}\n\twhile(~(sp=spfa())){\n\t\tlo=E;\n\t\tfor(i=T;i!=S;i=pv[i])cmin(lo,e[pe[i]].u);\n\t\tfor(i=T;i!=S;i=pv[i]){\n\t\t\te[pe[i]  ].u-=lo;\n\t\t\te[pe[i]^1].u+=lo;\n\t\t}\n\t\ts+=lo*sp;\n\t}\n\tprintf(\"%d\",s);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n#define dump(x) cout << #x << \" = \" << (x) << endl\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n-1); }\n\ntemplate<class T, class U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n\tos<<\"(\"<<p.first<<\",\"<<p.second<<\")\";\n\treturn os;\n}\n\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n\tos<<\"{\";\n\trep(i, v.size()) {\n\t\tif (i) os<<\",\";\n\t\tos<<v[i];\n\t}\n\tos<<\"}\";\n\treturn os;\n}\nusing Flow = int;\nusing Cost = ll;\nconst int MAX_V = TEN(5) * 3 + 10;\nconst Cost INF = std::numeric_limits<Cost>::max() / 8;\n\nstruct PrimalDual {\n    struct Edge {\n        int d;\n        Flow c, f;\n        Cost w;\n        int r, is_r;\n        Edge(int d_, Flow c_, Flow f_, Cost w_, int r_, bool is_r_)\n            : d(d_), c(c_), f(f_), w(w_), r(r_), is_r(is_r_) {}\n    };\n\n    int n;\n    std::vector<std::vector<Edge> > g;\n    PrimalDual(int n_) : n(n_), g(std::vector<std::vector<Edge> >(n_)) {}\n\n    void add_edge(int src, int dst, Flow cap, Cost cost) {  // 有向辺\n        int rsrc = g[dst].size();\n        int rdst = g[src].size();\n        g[src].emplace_back(dst, cap, 0, cost, rsrc, false);\n        g[dst].emplace_back(src, cap, cap, -cost, rdst, true);\n    }\n\n    Cost solve(int s, int t, Flow f) {\n        Cost res = 0;\n\n        static Cost h[MAX_V + 10], dist[MAX_V];\n        static int prevv[MAX_V + 10], preve[MAX_V + 10];\n        // std::vector<Cost> h(g.size()), dist(g.size());\n        // std::vector<int> prevv(g.size()), preve(g.size());\n\n        using pcv = std::pair<Cost, int>;\n        std::priority_queue<pcv, std::vector<pcv>, std::greater<pcv> > q;\n        std::fill(h, h + n, 0);\n        while (f > 0) {\n            std::fill(dist, dist + n, INF);\n            dist[s] = 0;\n            q.emplace(0, s);\n            while (q.size()) {\n                Cost cd;\n                int v;\n                std::tie(cd, v) = q.top();\n                q.pop();\n                if (dist[v] < cd) continue;\n                for (int i = 0; i < (int)(g[v].size()); ++i) {\n                    Edge &e = g[v][i];\n                    if (residue(e) == 0) continue;\n                    if (dist[e.d] + h[e.d] > cd + h[v] + e.w) {\n                        dist[e.d] = dist[v] + e.w + h[v] - h[e.d];\n                        prevv[e.d] = v;\n                        preve[e.d] = i;\n                        q.emplace(dist[e.d], e.d);\n                    }\n                }\n            }\n\n            if (dist[t] == INF) {\n            \treturn res;\n            }\n\n            // s-t 間最短路に沿って目一杯流す\n            for (int i = 0; i < n; ++i) h[i] += dist[i];\n            Flow d = f;\n            for (int v = t; v != s; v = prevv[v]) {\n                d = std::min(d, residue(g[prevv[v]][preve[v]]));\n            }\n            f -= d;\n            res += d * h[t];\n            for (int v = t; v != s; v = prevv[v]) {\n                Edge &e = g[prevv[v]][preve[v]];\n                e.f += d;\n                g[v][e.r].f -= d;\n            }\n        }\n        return res;\n    }\n\n    Flow residue(const Edge &e) { return e.c - e.f; }\n};\n\n/*\ntypedef pair<ll, int> pii;\n\nconst int MN = TEN(5) * 3 + 10;\n#define INF (1LL << 40)\n\nstruct edge {\n\tint to, cap, rev;\n\tll cost;\n\tedge(int to, int cap, ll cost, int rev) : to(to), cap(cap), cost(cost), rev(rev){}\n};\n\nint N;\nvector<edge> g[MN];\nll h[MN], dst[MN];\nint prevv[MN], preve[MN];\n\ninline void add_edge(int f, int t, int cap, ll cost) {\n\tg[f].emplace_back(t, cap, cost, (int)g[t].size());\n\tg[t].emplace_back(f, 0, -cost, (int)g[f].size() - 1);\n}\n\nll min_cost_flow(int s, int t, int f) {\n\tdump(\"wo\");\n\tint res = 0;\n\tmemset(h, 0, sizeof(h));\n\n\tfill(h, h + N + 1, INF);\n\th[s] = 0;\n\tfor (int t = 0; t < N; ++t) {\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (auto e : g[i]) if (e.cap) {\n\t\t\t\th[e.to] = min(h[e.to], h[i] + e.cost);\n\t\t\t}\n\t\t}\n\t}\n\t\n\twhile (f > 0) {\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > que;\n\t\tfill(dst, dst + N + 1, INF);\n\t\tdst[s] = 0;\n\t\tque.push(mp(0, s));\n\t\twhile (!que.empty()) {\n\t\t\tpii p = que.top(); que.pop();\n\t\t\tint v = p.se;\n\t\t\tif (dst[v] < p.fi) continue;\n\t\t\trep(i, g[v].size()) {\n\t\t\t\tedge &e = g[v][i];\n\t\t\t\tll nd = dst[v] + e.cost + h[v] - h[e.to];\n\t\t\t\tif (e.cap > 0 && dst[e.to] > nd) {\n\t\t\t\t\tdst[e.to] = nd;\n\t\t\t\t\tprevv[e.to] = v;\n\t\t\t\t\tpreve[e.to] = i;\n\t\t\t\t\tque.push(mp(dst[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (dst[t] == INF) {\n\t\t\treturn res;\n\t\t}\n\n\t\trep(i, N) h[i] += dst[i];\n\n\t\tint d = f;\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\td = min(d, g[prevv[v]][preve[v]].cap);\n\t\t}\n\t\tf -= d;\n\t\tres += d * h[t];\n\t\tfor (int v = t; v != s; v = prevv[v]) {\n\t\t\tedge &e = g[prevv[v]][preve[v]];\n\t\t\te.cap -= d;\n\t\t\tg[v][e.rev].cap += d;\n\t\t}\n\t}\n\n\treturn res;\n}\n*/\n\nint main() {\n\tint n, h, w;\n\n\tcin >> n >> h >> w;\n\tint s = 0, t = 1 + n + h + w;\n\tint N = t + 1;\n\tPrimalDual T(N);\n\n\trep(i, n) {\n\t\tint r, c, x;\n\t\tcin >> r >> c >> x;\n\t\t--r; --c;\n\t\tT.add_edge(s, i + 1, 1, -x);\n\t\tT.add_edge(i + 1, 1 + n + r, 1, 0);\n\t\tT.add_edge(i + 1, 1 + n + h + c, 1, 0);\n\t}\n\n\tfor (int i = 1 + n; i < t; ++i) {\n\t\tT.add_edge(i, t, 1, 0);\n\t}\n\n\tll ans = T.solve(s, t, n);\n\tcout << -ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_e\n\n#include<bits/stdc++.h>\nconst int N = 2e5 + 5;\nusing namespace std;\n\nint n, h, w, a[N], r[N], c[N], pset[N], cnt[N], p[N];\nlong long ans;\n\nint Find(int i) {return ((pset[i] == i) ? i : pset[i] = Find(pset[i]));}\n\nbool dsu(int u, int v){\n    u = Find(u); v = Find(v);\n    if (cnt[u] + cnt[v] == 0) return false;\n    cnt[u]--;\n    if (u == v) return true;\n    cnt[v] += cnt[u];\n    pset[u] = v;\n    return true;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n    cin >> n >> h >> w;\n    for (int i = 1; i <= n; i++) cin >> r[i] >> c[i] >> a[i], p[i] = i;\n    sort(p+1, p+1+n, [](int x, int y){return a[x] > a[y];});\n    for (int i = 1; i <= h+w; i++) pset[i] = i, cnt[i] = 1;\n    for (int i = 1; i <= n; i++) if (dsu(r[p[i]], c[p[i]] + h)) ans += a[p[i]];\n    cout << ans;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<ctime>\n#include<map>\n#include<bitset>\n#include<set>\n#define LL long long\n#define mp(x,y) make_pair(x,y)\n#define pll pair<long long,long long>\n#define pii pair<int,int>\nusing namespace std;\ninline LL read()\n{\n\tLL f=1,x=0;char ch=getchar();\n\twhile(ch<'0'||ch>'9'){if(ch=='-')f=-1;ch=getchar();}\n\twhile(ch>='0'&&ch<='9'){x=x*10+ch-'0';ch=getchar();}\n\treturn x*f;\n}\nint stack[20];\ntemplate<typename T>inline void write(T x)\n{\n\tif(x<0){putchar('-');x=-x;}\n    if(!x){putchar('0');return;}\n    int top=0;\n    while(x)stack[++top]=x%10,x/=10;\n    while(top)putchar(stack[top--]+'0');\n}\ntemplate<typename T>inline void pr1(T x){write(x);putchar(' ');}\ntemplate<typename T>inline void pr2(T x){write(x);putchar('\\n');}\nconst int MAXN=100005;\nstruct edge{int x,y,c,d,next;}a[12*MAXN];int len=1,last[3*MAXN];\nvoid ins(int x,int y,int c,int d)\n{\n\tlen++;a[len].x=x;a[len].y=y;a[len].c=c;a[len].d=d;\n\ta[len].next=last[x];last[x]=len;\n\tlen++;a[len].x=y;a[len].y=x;a[len].c=0;a[len].d=-d;\n\ta[len].next=last[y];last[y]=len;\n}\ndeque<int> li;\nbool v[3*MAXN];\nLL d[3*MAXN];\nint st,ed,pre[3*MAXN],tmp[3*MAXN];\nbool spfa()\n{\n\tmemset(v,false,sizeof(v));v[st]=true;\n\tmemset(d,-63,sizeof(d));d[st]=0;\n\tli.push_back(st);\n\tLL si=0;int ct=1;\n\twhile(!li.empty())\n\t{\n\t\tint x=li.front();\n\t\twhile(ct*d[x]<si)\n\t\t{\n\t\t\tli.pop_front();li.push_back(x);\n\t\t\tx=li.front();\n\t\t}\n\t\tli.pop_front();v[x]=false;si-=d[x];ct--;\n\t\tfor(int k=last[x];k;k=a[k].next)\n\t\t{\n\t\t\tint y=a[k].y;\n\t\t\tif(d[y]<d[x]+a[k].d&&a[k].c)\n\t\t\t{\n\t\t\t\tif(v[y])si-=d[y],si+=d[x]+a[k].d;\n\t\t\t\td[y]=d[x]+a[k].d;\n\t\t\t\tpre[y]=x;tmp[y]=k;\n\t\t\t\tif(!v[y])\n\t\t\t\t{\n\t\t\t\t\tv[y]=true;++ct;\n\t\t\t\t\tsi+=d[y];\n\t\t\t\t\tif(!li.size()||d[y]>d[li.front()])li.push_front(y);\n\t\t\t\t\telse li.push_back(y);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn d[ed]>0;\n}\nLL mcf()\n{\n\tLL minn,ret=0;\n\twhile(spfa())\n\t{\n\t\tint x=ed;minn=999999999;\n\t\twhile(x!=st)\n\t\t{\n\t\t\tminn=min(minn,(LL)a[tmp[x]].c);\n\t\t\tx=pre[x];\n\t\t}\n\t\tret+=1LL*minn*d[ed];x=ed;\n\t\twhile(x!=st)\n\t\t{\n\t\t\ta[tmp[x]].c-=minn;a[tmp[x]^1].c+=minn;\n\t\t\tx=pre[x];\n\t\t}\n\t}\n\treturn ret;\n}\nint n,A,B;\nint via[MAXN],vib[MAXN];\nint main()\n{\n\tn=read();A=read();B=read();\n\tst=A+B+n+1;ed=st+1;\n\tint cnt1=0,cnt2=0;\n\tfor(int i=1;i<=n;i++)\n\t{\n\t\tint u=read(),v=read(),C=read();\n\t\tif(!via[u])via[u]=++cnt1;\n\t\tif(!vib[v])vib[v]=++cnt2;\n\t\tins(i,via[u]+n,1,0);ins(i,vib[v]+n+A,1,0);\n\t\tins(st,i,1,C);\n\t}\n\tfor(int i=1;i<=A;i++)if(via[i])ins(via[i]+n,ed,1,0);\n\tfor(int i=1;i<=B;i++)if(vib[i])ins(vib[i]+n+A,ed,1,0);\n\tpr2(mcf());\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n#define __builtin_popcount __builtin_popcountll\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\n    os<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const map<S, T> &t) {\n    os<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nconst int INF = 1<<28;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\n\n// O(sqrt(V)E)\nbool dfs(const vector<vi> &G,int v,vector<bool> &visit, vector<int> &match,vector<int> &level){\n    visit[v]=true;\n    REP(i,G[v].size()){\n        int dst=G[v][i];\n        int w=match[dst];\n        if(w==-1 || (!visit[w] && level[v] < level[w] && dfs(G,w,visit,match,level))){\n            match[v]=dst;\n            match[dst]=v;\n            return true;\n        }\n    }\n    return false;\n}\nvi bipartite_matching(const vector<vi> &G, int q){\n    vector<int> match(G.size(), -1);\n    for(int res = 0;;){\n        vector<int> level(G.size(),-1);\n        queue<int> que;\n        REP(i,q){\n            if(match[i]==-1){\n                que.push(i);\n                level[i]=0;\n            }\n        }\n        while(!que.empty()){\n            int v=que.front();que.pop();\n            REP(i,G[v].size()){\n                int dst=G[v][i];\n                int w=match[dst];\n                if(w != -1 && level[w]<0){\n                    level[w]=level[v]+1;\n                    que.push(w);\n                }\n            }\n        }\n        vector<bool> visit(G.size());\n        int d=0;\n        REP(v,q){\n            if(match[v]==-1&&dfs(G,v,visit,match,level))d++;\n        }\n        if(d==0) return match;\n        res+=d;\n    }\n}\n\n\nll T, n, m, k;\n\nint main(int argc, char *argv[]){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n    while(cin >> n >> m >> k){\n        vector<tuple<int, int, int>> v;\n        vi s;\n        REP(i, n) {\n            int x, y, z;\n            cin >> x >> y >> z;\n            v.emplace_back(z, x, y);\n            s.emplace_back(x);\n            s.emplace_back(-y);\n        }\n        sort(RALL(v));\n        sort(ALL(s));\n        UNIQUE(s);\n        map<int, int> mp;\n        REP(i, s.size()) mp[s[i]] = i;\n        vector<vi> g(n + s.size());\n        REP(i, n) {\n            int x, y, z; tie(z, x, y) = v[i];\n            g[i].emplace_back(n + mp[x]);\n            g[i].emplace_back(n + mp[-y]);\n            g[n + mp[x]].emplace_back(i);\n            g[n + mp[-y]].emplace_back(i);\n        }\n        vi match = bipartite_matching(g, n);\n        ll ans = 0;\n        REP(i, n) {\n            if (match[i] != -1 && match[match[i]] == i) {\n                ans += get<0>(v[i]);\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nmultiset<tuple<int,int,int>> dsu[200000];\n\nint n, h, w;\nint par[200000];\n\nint find(int p) {\n  return par[p] = (p == par[p] ? p : find(par[p]));\n}\n\nvoid join(int a, int b, tuple<int,int,int> v) {\n  a = find(a);\n  b = find(b);\n  dsu[a].erase(dsu[a].find(v));\n  if (a == b) {\n    return;\n  }\n  dsu[b].erase(dsu[b].find(v));\n  if (dsu[b].size() > dsu[a].size()) swap(a,b);\n  par[b] = a;\n  for (auto&v : dsu[b])\n    dsu[a].insert(v);\n}\n\nint fetch(int p) {\n  p = find(p);\n  auto it = dsu[p].rbegin();\n  if (it == dsu[p].rend()) return 0;\n  int a,x,y;\n  tie(a,x,y)= *it;\n  join(x,y+w,*it);\n  return a;\n}\n\nint main() {\n  ios::sync_with_stdio(0); cin.tie(0);\n  cin >> n >> h >> w;\n  for (int i = 0; i < w+h; i++)\n    par[i] = i;\n  set<pair<int,int>> taken;\n  for (int i = 0; i < n; i++) {\n    int y, x, a;\n    cin >> y >> x >> a;\n    y--, x--;\n    tuple<int,int,int> v(a,x,y);\n    dsu[x].insert(v);\n    dsu[y+w].insert(v);\n  }\n  ll ans = 0;\n  for (int i = 0; i < w+h; i++) {\n    int a = fetch(i);\n    //cout << a << endl;\n    ans += a;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 200000\n#define LL long long\nint n,h,w;LL ans;\nstruct edge{\n\tint u,v,w;\n}e[MAXN+1];\nint fa[MAXN+1],siz[MAXN+1],used[MAXN+1];\nint read(){\n\tint x=0,F=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')F=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n\treturn x*F;\n}\nbool cmp(edge s1,edge s2){\n\treturn s1.w>s2.w;\n}\nint xfind(int x){\n\tif(fa[x]==x)return x;\n\treturn fa[x]=xfind(fa[x]);\n}\nint main()\n{\n\tn=read(),h=read(),w=read();\n\tfor(int i=1;i<=n;i++)\n\te[i]=(edge){read(),read()+n,read()};\n\tfor(int i=1;i<=n*2;i++)fa[i]=i,siz[i]=1;\n\tsort(e+1,e+n+1,cmp);\n\tfor(int i=1;i<=n;i++){\n\t\tint a=xfind(e[i].u),b=xfind(e[i].v);\n\t\tif(a==b){\n\t\t\tif(siz[a]>=used[a]+1){\n\t\t\t\tused[a]=used[a]+1;\n\t\t\t\tans+=e[i].w;\n\t\t\t}\n\t\t}else{\n\t\t\tif(siz[a]+siz[b]>=used[a]+used[b]+1){\n\t\t\t\tused[a]+=used[b]+1;\n\t\t\t\tsiz[a]+=siz[b];\n\t\t\t\tans+=e[i].w;\n\t\t\t\tfa[b]=a;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<iomanip>\n#include<numeric>\n\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr int mo = 1e9+7;\nconstexpr int  mod = mo;\nconstexpr int inf = 1<<30;\nconstexpr ll infl = 1ll<<62;\ntemplate<int N>\nclass UF{\n    vector<int> par;\n    public:\n    UF():par(N,-1){}\n    int operator[](int x){return (par[x] == -1)?x:par[x] = operator[](par[x]);}\n    void operator()(int x,int y){\n        x = operator[](x);y = operator[](y);\n        if(x > y)swap(x,y);\n        par[y] = x;\n    }\n};\nUF<200050> uf;\nint main(){\n    int n,h,w;\n    cin>>n>>h>>w;\n    vector<tuple<int,int,int>> vec;\n    for(int i=0;i<n;++i){\n        int r,c,a;\n        cin>>r>>c>>a;\n        r--;c--;\n        vec.emplace_back(a,r,c);\n    }\n    sort(vec.begin(),vec.end());\n    reverse(vec.begin(),vec.end());\n    vector<bool> used(200050);\n    ll ret = 0ll;\n    for(int i=0;i<n;++i){\n        int a,r,c;\n        tie(a,r,c) = vec[i];\n        if(!used[uf[r]] and !used[uf[c+h]]){\n            if(uf[r] == uf[c+h]){\n                used[uf[r]] = true;\n            }else uf(r,c+h);\n            ret += a;\n        } else if(!used[uf[r]]){\n            used[uf[r]] = true;\n            ret += a;\n        } else if(!used[uf[c+h]]){\n            used[uf[c+h]] = true;\n            ret += a;\n        }\n    }\n    cout << ret << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e5+5;\nint a[maxn],b[maxn];\nint n,h,w;\nint cnt=0;\nll sum=0;\nstruct pp\n{\n\tint x,y,z;\n}s[maxn];\nbool cmpz(pp a,pp b)\n{\n\treturn a.z>b.z;\n}\n/*void find(int i,int z)\n{\n\tint mh=0,mw=0;\n\tint ow,oh;\n\tfor(int j=i+1;j<n;j++)\n\t{\n\t\tif(s[j].x==s[i].x&&mh==0&&a[s[i].x]==1)\n\t\t{\n\t\t\tmh=s[j].z;\n\t\t\toh=j;\n\t\t}\n\t\tif(s[j].y==s[i].y&&mw==0&&b[s[i].x]==1)\n\t\t{\n\t\t\tmw=s[j].z;\n\t\t\tow=j;\n\t\t}\n\t\tif(mh!=0&&mw!=0) break;\n\t}\n\tcout<<mh<<\" \"<<mw<<endl;\n\tif(mh>mw)\n\t{\n\t\tb[s[i].y]--;\n\t\tcout<<s[i].z<<endl;\n\t\tsum+=(s[i].z);\n\t\tcnt++;\n\t}\n\telse if(mh<mw)\n\t{\n\t\ta[s[i].x]--;\n\t\tcout<<s[i].z<<endl;\n\t\tsum+=(s[i].z);\n\t\tcnt++;\n\t}\n\telse \n\t{\n\t\ta[s[i].x]--;\n\t\tb[s[i].y]--;\n\t\tcout<<s[i].z<<endl;\n\t\tsum+=(s[i].z);\n\t\tcout<<mh<<endl;\n\t\tsum+=(mh);\n\t\ts[ow].z=0;\n\t\tcnt+=2;\n\t}\n}*/\nint main()\n{\n\tcin>>n>>h>>w;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>s[i].x>>s[i].y>>s[i].z;\n\t}\n\tfor(int i=1;i<=h;i++) a[i]=1;\n\tfor(int i=1;i<=w;i++) b[i]=1;\n\tsort(s,s+n,cmpz);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint mh=0,mw=0;\n\t    int ow,oh;\n\t    if(s[i].z==0) continue;\n\t    for(int j=i+1;j<n;j++)\n\t    {\n\t\t    if(s[j].x==s[i].x&&mh==0&&a[s[i].x]==1)\n\t\t    {\n\t\t\t   mh=s[j].z;\n\t\t\t   oh=j;\n\t\t    }\n\t\t    if(s[j].y==s[i].y&&mw==0&&b[s[i].y]==1)\n\t\t    {\n\t\t\t    mw=s[j].z;\n\t\t\t    ow=j;\n\t\t    }\n\t\t    if(mh!=0&&mw!=0) break;\n\t    }\n\t    //cout<<mh<<\" \"<<mw<<endl;\n\t    if(a[s[i].x]==0&&b[s[i].y]==0) \n\t    { \n\t\t     continue;\n\t    }\n\t    else if((mh>mw&&b[s[i].y]==1)||a[s[i].x]==0)\n\t    {\n\t\t    b[s[i].y]--;\n\t\t    //cout<<s[i].z<<endl;//\n\t\t    sum+=(s[i].z);\n\t\t    cnt++;\n\t    }\n\t    else if((mh<mw&&a[s[i].x]==1)||b[s[i].y]==0)\n\t    {\n\t\t    a[s[i].x]--;\n\t\t    //cout<<s[i].z<<endl;//\n\t\t    sum+=(s[i].z);\n\t\t    cnt++;\n\t    }\n\t    else if(mh==mw&&b[s[i].y]==1&&a[s[i].x]==1)\n\t    {\n\t\t    a[s[i].x]--;\n\t\t    b[s[i].y]--;\n\t\t    //cout<<s[i].z<<endl;//\n\t\t    sum+=(s[i].z);\n\t\t    //cout<<mh<<endl;//\n\t\t    sum+=(mh);\n\t\t    s[ow].z=0;\n\t\t    cnt+=2;\n\t    }\n\t    if(cnt==(h+w)) break;\n\t}\n\tcout<<sum<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=1e9;\nconst int MOD=1e9+7;\n//const int MOD=998244353;\nconst long long LINF=1e18;\n#define int long long\n//template\ntemplate <typename T>\nvoid fin(T a){\n  cout<<a<<endl;\n  exit(0);\n}\nstruct UnionFind{\n  int n,num;\n  vector<int> r,p,e;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),num(sz),e(sz,0),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) {e[x]++;return;}\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];e[x]+=e[y]+1;\n    p[y]=x;\n    num--;\n  }\n  int size(int x){  //頂点数\n    return r[find(x)];\n  }\n  int size2(int x){  //辺の数\n    return e[find(x)];\n  }\n  int count() const{\n    return num;\n  }\n};\n//main\nsigned main(){\n  int N,H,W;cin>>N>>H>>W;\n  typedef pair<int,int> P;\n  typedef pair<int,P> PP;\n  priority_queue<PP> que;\n  for(int i=0;i<N;i++){\n    int r,c,a;cin>>r>>c>>a;r--;c--;\n    que.push(PP(a,P(r,c+100000)));\n  }\n  int ans=0;\n  UnionFind uf(200000);\n  while(que.size()){\n    PP p=que.top();que.pop();\n    int a=p.first,u=p.second.first,v=p.second.second;\n    if(uf.same(u,v)){\n      if(uf.size2(u)<uf.size(v)){\n        uf.unite(u,v);\n        ans+=a;\n      }\n    }\n    else{\n      int p=uf.size(u)+uf.size(v);\n      int e=uf.size2(u)+uf.size2(v);\n      if(e<p){\n        uf.unite(u,v);\n        ans+=a;\n      }\n    }\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cassert>\n#include <cctype>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <vector>\n#include <queue>\n#include <unordered_set>\n#include <algorithm>\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\nusing namespace std;\n\ntypedef long long ll;\n\nusing namespace std;\ntypedef long long ll;\ntypedef long long W;\ntypedef long long F;\n\nstruct Edge { int dst, opp; F cap; W cost; bool rev; };\nconst F FINF = numeric_limits<F>::max() / 3;\nconst W WINF = numeric_limits<W>::max() / 3;\nconst int N = 200000+5;\nvector<Edge> g[N];\ninline void initGraph(int n) { REP(i, n) g[i].clear(); }\ninline void addEdge(int a, int b, F cap, W cost) {\n  g[a].push_back((Edge){b, ((int)g[b].size()), cap, cost, false});\n  g[b].push_back((Edge){a, ((int)g[a].size())-1, 0, -cost, true});\n}\nbool spfa(int n, int s, int t, int* trace) {\n  vector<W> dist(n, WINF);\n  vector<bool> inQ(n, false);\n  queue<int> q;\n  q.push(s);\n  inQ[s] = true;\n  for(dist[s] = 0; !q.empty(); ){\n    int v = q.front(); q.pop();\n    inQ[v] = false;\n    REP(i, g[v].size()){\n      const Edge& e = g[v][i];\n      if(e.cap > 0 && dist[e.dst] > dist[v] + e.cost){\n        dist[e.dst] = dist[v] + e.cost;\n        trace[e.dst] = e.opp;\n        if(!inQ[e.dst]){\n          inQ[e.dst] = true;\n          q.push(e.dst);\n        }\n      }\n    }\n  }\n  return dist[t] < WINF;\n}\npair<W,F> minCostFlow(int n, int s, int t, F flowUpperBound = FINF) {\n  F maxflow = 0; W mincost = 0;\n  F optflow = 0; W optcost = 0;\n  int trace[N];\n  for(; maxflow < flowUpperBound; ){\n    if(spfa(n, s, t, trace) == false)\n      break;\n    F amount = flowUpperBound - maxflow;\n    for(int cur = t; cur != s; ){\n      const Edge& re = g[cur][trace[cur]];\n      const Edge& e = g[re.dst][re.opp];\n      amount = min(amount, e.cap);\n      cur = re.dst;\n    }\n    maxflow += amount;\n    for(int cur = t; cur != s; ){\n      Edge& re = g[cur][trace[cur]];\n      Edge& e = g[re.dst][re.opp];\n      mincost += e.cost * amount;\n      e.cap -= amount;\n      re.cap += amount;\n      cur = re.dst;\n    }\n    if(mincost < optcost){\n      optcost = mincost;\n      optflow = maxflow;\n    }\n  }\n  // return make_pair(mincost, maxflow);\n  return make_pair(optcost, optflow);\n}\n\nint main(void) {\n  int n, h, w;\n  scanf(\"%d%d%d\", &n, &h, &w);\n  initGraph(h+w+n+2);\n  int s = h+w+n;\n  int t = s+1;\n  REP(r, h) {\n    addEdge(s, r, 1, 0);\n  }\n  REP(c, w) {\n    addEdge(s, h+c, 1, 0);\n  }\n  REP(i, n) {\n    int r, c, a;\n    scanf(\"%d%d%d\", &r, &c, &a);\n    --r;\n    --c;\n    addEdge(r, h+w+i, 1, 0);\n    addEdge(h+c, h+w+i, 1, 0);\n    addEdge(h+w+i, t, 1, -a);\n  }\n  pair<W,F> res = minCostFlow(h+w+n+2, s, t);\n  cout << -res.first << endl;\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define WHOLE(v) (v).begin(), (v).end()\n#define REV_WHOLE(v) (v).rbegin(), (v).rend()\nusing i64 = int64_t;\nusing namespace std;\ntemplate<size_t I,class H,class...T>struct TupleReaderWriter{static tuple<H,T...> r(istream&i){H v;i>>v;return tuple_cat(tuple<H>(v),TupleReaderWriter<sizeof...(T)-1,T...>::r(i));}static void w(ostream&o,tuple<H,T...>&t,string d){TupleReaderWriter<I-1,H,T...>::w(o,t,d);o<<d<<get<I>(t);}};\ntemplate<class H,class...T>struct TupleReaderWriter<0,H,T...>{static tuple<H,T...> r(istream&i){H v;i>>v;return tuple<H>(v);}static void w(ostream&o,tuple<H,T...>&t,string d){o<<get<0>(t);}};\ntemplate<class...T>istream&operator>>(istream&i,tuple<T...>&t){t=TupleReaderWriter<sizeof...(T),T...>::r(i);return i;}\ntemplate<class...T>ostream&operator<<(ostream&o,tuple<T...>&t){string delim=\" \";TupleReaderWriter<sizeof...(T)-1,T...>::w(o,t,delim);return o;}\ntemplate<class T>istream&operator>>(istream&i,vector<T>&v){for(auto&x:v)i>>x;return i;}\ntemplate<class T>ostream&operator<<(ostream&o,vector<T>&v){string delim=\"\";for(auto&x:v)o<<delim<<x,delim=\" \";return o;}\ntemplate<class T>using rev_priority_queue=priority_queue<T,vector<T>,greater<T>>;\ntemplate<class T>using vector2d=vector<vector<T>>;\nstruct fixprec{int x;fixprec(int d):x(d){}};\nostream&operator<<(ostream&o,fixprec f){return o<<fixed<<setprecision(f.x);}\nvoid R_YESNO(bool p) { cout << (p ? \"YES\" : \"NO\") << endl; }\nvoid R_YesNo(bool p) { cout << (p ? \"Yes\" : \"No\") << endl; }\nusing Card = tuple<int, int, int, int>;\nint main() {\n    int N, H, W;\n    cin >> N >> H >> W;\n    vector<int> row(H, 0), col(W, 0);\n    vector<bool> used_row(H, false), used_col(W, false);\n    vector<Card> v(N);\n    for(auto &x : v) {\n        int r, c, a;\n        cin >> r >> c >> a;\n        r--, c--;\n        x = make_tuple(a, 0, r, c);\n        row[r]++;\n        col[c]++;\n    }\n    for(auto &x : v) {\n        get<1>(x) = -min(row[get<2>(x)], col[get<3>(x)]);\n    }\n    i64 ans = 0;\n    sort(REV_WHOLE(v));\n    for(auto x : v) {\n        int a, p, r, c;\n        tie(a, p, r, c) = x;\n        p *= -1;\n        ans += a;\n        if(row[r] == 1) {\n            used_row[r] = true;\n        } else if(col[c] == 1) {\n            used_col[c] = true;\n        } else if(!used_row[r]) {\n            used_row[r] = true;\n        } else if(!used_col[c]) {\n            used_col[c] = true;\n        } else {\n            ans -= a;\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define rep1(i, n) for(int i = 1; i <= (n); i++)\n#define co(x) cout << (x) << \"\\n\"\n#define cosp(x) cout << (x) << \" \"\n#define ce(x) cerr << (x) << \"\\n\"\n#define cesp(x) cerr << (x) << \" \"\n#define pb push_back\n#define mp make_pair\n#define Would\n#define you\n#define please\n\nint P[200002];\nint eranda[200002];\n\nint Find(int A) {\n\tif (P[A] < 0) return A;\n\treturn P[A] = Find(P[A]);\n}\n\nbool Unite(int A, int B) {\n\tint a = Find(A);\n\tint b = Find(B);\n\tif (a == b) return false;\n\tif (P[a] > P[b]) swap(a, b);\n\tP[a] += P[b];\n\teranda[a] |= eranda[b];\n\tP[b] = a;\n\treturn true;\n}\n\nint Size(int A) {\n\treturn -P[Find(A)];\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\n\tint N, H, W;\n\tcin >> N >> H >> W;\n\n\tpair<int, pair<int, int>> E[100000];\n\trep(i, N) {\n\t\tint r, c, a;\n\t\tcin >> r >> c >> a;\n\t\tE[i] = mp(a, mp(r - 1, H + c - 1));\n\t}\n\tsort(E, E + N);\n\treverse(E, E + N);\n\n\trep(i, H + W) P[i] = -1;\n\tll kotae = 0;\n\trep(i, N) {\n\t\tint r = E[i].second.first;\n\t\tint c = E[i].second.second;\n\t\tif (Find(r) != Find(c)) {\n\t\t\tif (!(eranda[Find(r)] && eranda[Find(r)])) {\n\t\t\t\tUnite(r, c);\n\t\t\t\tkotae += E[i].first;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (eranda[Find(r)] == 0) {\n\t\t\t\tkotae += E[i].first;\n\t\t\t\teranda[Find(r)] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tco(kotae);\n\n\n\tWould you please return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <stack>\n#include <queue>\n#include <list>\n#include <bitset>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <algorithm>\n#include <numeric>\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <chrono>\n#include <random>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <cstring>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n\nusing namespace std;\n\n\nconst long long INF = 1LL << 50;\nclass MinCostMaxFlow {\n    public:\n        MinCostMaxFlow(int n, int _s, int _t) : N(n), s(_s), t(_t), graph(N), dis(N, INF), pre(N, -1), inQueue(N, false), visited(N, false) {\n        }\n\n        void addEdge(int u, int v, long long w, long long cap, long long flow = 0) {\n            graph[u].push_back(edges.size());\n            edges.emplace_back(u, v, w, cap, 0);\n            graph[v].push_back(edges.size());\n            edges.emplace_back(v, u, -w, 0, 0);\n        }\n\n        pair<long long, long long> minCostMaxFlow() {\n            long long flow = 0;\n            long long cost = 0;\n\n            while (SPFA()) {\n                long long inc = INF;\n                long long ct = 0; \n                {\n                    int v = t;\n                    while (v != s) {\n                        int e = pre[v];\n                        inc = min(inc, edges[e].rem());\n                        ct += edges[e].w;\n                        v = edges[e].from;\n                    }\n                }\n              \n                flow += inc;\n                cost += ct * inc;\n                {\n                    int v = t;\n                    while (v != s) {\n                        int e = pre[v];\n                        edges[e].flow += inc;\n                        edges[e ^ 1].flow -= inc;\n                        v = edges[e].from;\n                    }\n                }\n            }\n            return {flow, cost};\n        }\n\n        bool SPFA() {\n            queue<int> que;\n            que.push(s);\n            inQueue[s] = true;\n            visited[s] = true;\n            A.push_back(s);\n            dis[s] = 0;\n            pre[s] = -1;\n            pre[t] = -1;\n            while (!que.empty()) {\n                int u = que.front();\n                que.pop();\n                inQueue[u] = false;\n                for (auto e : graph[u]) {\n                    int v = edges[e].to;\n                    if (edges[e].rem() > 0) {\n                        if (dis[v] > dis[u] + edges[e].w) {\n                            dis[v] = dis[u] + edges[e].w;\n                            pre[v] = e;\n                            if (!visited[v]) {\n                                A.push_back(v);\n                                visited[v] = true;\n                            }\n                            if (!inQueue[v]) {\n                                que.push(v);\n                                inQueue[v] = true;\n                            }\n                        }\n                    }\n                }\n            }\n            for (auto x : A) {\n                dis[x] = INF;\n                visited[x] = false;\n            }\n\n            if (pre[t] == -1) {\n                return false;\n            } \n            return true;\n        }\n\n\n\n\n    private:\n        struct Edge {\n            Edge(int u, int v, long long  _w, long long c, long long f) : from(u), to(v), w(_w), cap(c), flow(f) {\n            }\n\n            long long rem() {\n                return cap - flow;\n            }\n        \n            int from, to;\n            long long w;\n            long long flow;\n            long long cap;\n        };\n\n        int N;\n        int s;\n        int t;\n        vector<vector<int>> graph;\n        vector<Edge> edges;\n        vector<long long> dis;\n        vector<int> pre;\n        vector<bool> inQueue;\n        vector<bool> visited;\n        vector<int> A;\n};\n\nint main(int argc, char** argv) {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, h, w;\n    cin >> n >> h >> w;\n\n    int s = 0;\n    int t = 1;\n    auto row = [&](int x) {\n        return t + 1 + x;\n    };\n    auto col = [&](int x) {\n        return t + 1 + h + x;\n    };\n    auto cell = [&](int x) {\n        return t + 1 + h + w + x;\n    };\n\n    MinCostMaxFlow mcmf(2 + h + w + n + 123, s, t);\n    for (int i = 0; i < n; ++i) {\n        int r, c;\n        int a;\n        cin >> r >> c >> a;\n        --r, --c;\n        mcmf.addEdge(cell(i), row(r), -a, 1);\n        mcmf.addEdge(cell(i), col(c), -a, 1);\n        mcmf.addEdge(s, cell(i), 0, 1);\n    }\n\n    for (int i = 0; i < h; ++i) {\n        mcmf.addEdge(row(i), t, 0, 1);\n    }\n    for (int i = 0; i < w; ++i) {\n        mcmf.addEdge(col(i), t, 0, 1);\n    }\n\n    auto res = mcmf.minCostMaxFlow();\n\n    cout << -res.second << '\\n';\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define dbg(...) do{cerr<<__LINE__<<\": \";dbgprint(#__VA_ARGS__, __VA_ARGS__);}while(0);\n\nusing namespace std;\n\nnamespace std{template<class S,class T>struct hash<pair<S,T>>{size_t operator()(const pair<S,T>&p)const{return ((size_t)1e9+7)*hash<S>()(p.first)+hash<T>()(p.second);}};template<class T>struct hash<vector<T>>{size_t operator()(const vector<T> &v)const{size_t h=0;for(auto i : v)h=h*((size_t)1e9+7)+hash<T>()(i)+1;return h;}};}\ntemplate<class T>ostream& operator<<(ostream &os, const vector<T> &v){os<<\"[ \";rep(i,v.size())os<<v[i]<<(i==v.size()-1?\" ]\":\", \");return os;}template<class T>ostream& operator<<(ostream &os,const set<T> &v){os<<\"{ \"; for(const auto &i:v)os<<i<<\", \";return os<<\"}\";}\ntemplate<class T,class U>ostream& operator<<(ostream &os,const map<T,U> &v){os<<\"{\";for(const auto &i:v)os<<\" \"<<i.first<<\": \"<<i.second<<\",\";return os<<\"}\";}template<class T,class U>ostream& operator<<(ostream &os,const pair<T,U> &p){return os<<\"(\"<<p.first<<\", \"<<p.second<<\")\";}\nvoid dbgprint(const string &fmt){cerr<<endl;}template<class H,class... T>void dbgprint(const string &fmt,const H &h,const T&... r){cerr<<fmt.substr(0,fmt.find(\",\"))<<\"= \"<<h<<\" \";dbgprint(fmt.substr(fmt.find(\",\")+1),r...);}\ntypedef long long ll;typedef vector<int> vi;typedef pair<int,int> pi;const int inf = (int)1e9;const double INF = 1e12, EPS = 1e-9;\n\nint main(){\n\tcin.tie(0); cin.sync_with_stdio(0);\n\tusing T = tuple<int,int,int>;\n\t\n\tint n, h, w; cin >> n >> h >> w;\n\tvector<T> v;\n\trep(i, n){\n\t\tint r, c, a; cin >> r >> c >> a;\n\t\tv.emplace_back(r, c, a);\n\t}\n\t\n\tauto process = [&](function<int(T)> f){\n\t\tll res = 0;\n\t\tmap<int,int> m;\n\t\tfor(T i : v) m[f(i)] = max(m[f(i)], get<2>(i));\n\t\tfor(auto i : m) res += i.second;\n\t\t\n\t\tvector<T> nv;\n\t\tfor(T i : v) if(m.count(f(i)) && m[f(i)] == get<2>(i)) m.erase(f(i));\n\t\telse nv.emplace_back(i);\n\t\tv = nv;\n\t\treturn res;\n\t};\n\tfor(T i : v) dbg(get<0>(i), get<1>(i), get<2>(i)); cerr<<endl;\n\tll ans = process([](T t){ return get<0>(t); });\n\tfor(T i : v) dbg(get<0>(i), get<1>(i), get<2>(i));\n\tans += process([](T t){ return get<1>(t); });\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int maxn = 1e5+10;\n\nint fa[maxn<<1], cnt[maxn<<1];\nint find(int x) {\n//\tprintf(\" %d %d\\n\", x, fa[x]);\n\treturn fa[x]>0?fa[x]=find(fa[x]):x;\n}\nbool merge(int x, int y) {\n\tint fx = find(x), fy = find(y);\n\tif (fx == fy) {\n\t\tif (cnt[fx] == 0) return false;\n\t\tcnt[fx]--;\n\t}\n\telse {\n\t\tif (cnt[fx]+cnt[fy] == 0) return false;\n\t\tif (fa[fx] < fa[fy]) swap(fx, fy);\n\t\tfa[fx] = fy;\n\t\tfa[fy]--;\n\t\tcnt[fy] = cnt[fy]+cnt[fx]-1;\n\t}\n\treturn true;\n}\n\nint n, h, w;\npair<int, pair<int, int> > e[maxn];\nlong long ans = 0;\n#define mp make_pair\n#define fi first\n#define se second\n\nint main() {\n\tfor (int i = 0; i < (maxn<<1); ++i) cnt[i] = 1;\n\tcin >> n >> h >> w;\n\tint r, c, a;\n\tfor (int i = 0; i < n; ++i) {\n\t\tcin >> r >> c >> a;\n\t\te[i] = mp(a, mp(r, c+h));\n\t}\n\tsort(e, e+n);\n\treverse(e, e+n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (merge(e[i].se.fi, e[i].se.se))\n\t\t\tans += e[i].fi;\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define name \"main\"\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define fto(i,a,b) for(int i=a; i<=b;++i)\n#define maxn 100009\n#define ll long long\n\nusing namespace std;\nbool gone[maxn][3],ck[maxn][3];\nint cl[maxn];\nint xd[maxn][3],a[maxn][3],w,h,n;\npii b[maxn];\nbool check(int i, int x,int j){\n    if(!ck[i][x]) return false;\n    if(gone[i][x])return ck[i][x]=false;\n    gone[i][x]=true;\n    if(xd[i][x]==0){\n        xd[i][x]=j;\n        gone[i][x]=false;\n        ck[i][1-x]=true;\n        return true;\n    }\n    /// xd[i][x]!=0;\n    /// i,x la cot hoac hang, j la chi so can dien\n    int t=xd[i][x];/// t la so can dien\n    if(check(a[t][1-x],1-x,t)){\n        xd[i][x]=j;\n        gone[i][x]=false;\n        ck[i][1-x]=true;\n        return true;\n    }\n    gone[i][x]=false;\n    return ck[i][x]=false;\n}\nint main()\n{\n    #ifndef ONLINE_JUDGE\n    freopen(name\".inp\", \"r\", stdin);\n    freopen(name\".out\", \"w\", stdout);\n    #endif // ONLINE_JUDGE\n    cin >> n >> h >> w;\n    fto(i,1,n){\n        cin >> a[i][0]>> a[i][1] >> b[i].fi;\n        b[i].se=i;\n        ck[i][0]=ck[i][1]=true;\n    }\n    sort(b+1,b+n+1,greater<pii> ());\n    ll res=0;\n    fto(i,1,n){\n        int j=b[i].se;\n        if(check(a[j][0],0,j)){\n            //xd[a[j][0]][0]=j;\n            res+=b[i].fi;\n        }\n        else if(check(a[j][1],1,j)){\n            //xd[a[j][1]][1]=j;\n            res+=b[i].fi;\n        }\n    }\n    cout << res ;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nclass UnionFind\n{\n    std::vector<P> data;\n\npublic:\n    UnionFind(int size) : data(size, P(-1,0)) {}\n    // 結合可能か\n    bool unite(int x, int y)\n    {\n        x = root(x).first;\n        y = root(y).first;\n        if(x==y)\n        {\n            int sz = size(x);\n            if(sz>data[x].second)\n            {\n                data[x].second++;\n                return true;\n            }\n            return false;\n        }\n        int sz = size(x) + size(y);\n        if(sz> data[x].second + data[y].second){\n        if (data[y].first < data[x].first)\n            std::swap(x, y);\n        data[x].first += data[y].first;\n        data[y].first = x;\n        data[x].second += data[y].second + 1;\n        data[y].second = data[x].second;\n        return true;}\n        return false;\n    }\n    bool find(int x, int y)\n    {\n        return root(x).first == root(y).first;\n    }\n    P root(int x)\n    {\n        return data[x].first < 0 ? P(x, data[x].second) : data[x] = root(data[x].first);\n    }\n    int size(int x)\n    {\n        return -data[root(x).first].first;\n    }\n};\n\nstruct Edge\n{\n    int from, to;\n    ll cost;\n};\n\nbool operator<(const Edge &e, const Edge &f)\n{\n    return e.cost < f.cost;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, h, w;\n    cin >> n >> h >> w;\n    vector<Edge> es;\n    for (int i = 0; i < n; i++)\n    {\n        int r, c, a;\n        cin >> r >> c >> a;\n        r--;\n        c--;\n        es.push_back(Edge{r, c + h, a});\n    }\n    sort(es.rbegin(), es.rend());\n    UnionFind uf(h + w);\n    ll ret = 0;\n    for(const auto &e:es)\n    {\n        int from = e.from, to = e.to;\n        ll a = e.cost;\n        if(uf.unite(from, to))\n        {\n            ret += a;\n        }\n    }\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 1e5 + 5;\nstruct node {\n\tint x, y, w;\n\tnode() = default;\n\tnode(int _x, int _y, int _w) : x(_x), y(_y), w(_w) {}\n\tbool friend operator < (const node &a, const node &b) {\n\t\treturn a.w > b.w;\n\t}\n};\nint n, h, w;\nint fa[maxn * 2], sz[maxn * 2];\nint find(int x) {\n\treturn x == fa[x] ? x : fa[x] = find(fa[x]);\n}\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tcin >> n >> h >> w;\n\tvector<node> a(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tcin >> a[i].x >> a[i].y >> a[i].w;\n\t\ta[i].y += h; \n\t}\n\tsort(a.begin(), a.end());\n\tfor(int i = 1; i <= h + w; ++i) {\n\t\tfa[i] = i;\n\t\tsz[i] = 1;\n\t}\n\tlong long ans = 0;\n\tfor(int i = 0; i < n; ++i) {\n\t\tint x = find(a[i].x), y = find(a[i].y);\n\t\tif(x != y) {\n\t\t\tfa[x] = y;\n\t\t\tsz[x] += sz[y];\n\t\t}\n\t\tif(sz[x]) {\n\t\t\t--sz[x];\n\t\t\tans += a[i].w;\n\t\t}\n\t}\n\tcout << ans << '\\n';\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int INF=1e9;\nconst int MOD=1e9+7;\n//const int MOD=998244353;\nconst long long LINF=1e18;\n#define int long long\n//template\ntemplate <typename T>\nvoid fin(T a){\n  cout<<a<<endl;\n  exit(0);\n}\nstruct UnionFind{\n  int n,num;\n  vector<int> r,p,e;\n  UnionFind(){}\n  UnionFind(int sz):n(sz),num(sz),e(sz,0),r(sz,1),p(sz,0){iota(p.begin(),p.end(),0);}\n  int find(int x){\n    return (x==p[x]?x:p[x]=find(p[x]));\n  }\n  bool same(int x,int y){\n    return find(x)==find(y);\n  }\n  void unite(int x,int y){\n    x=find(x);y=find(y);\n    if(x==y) {e[x]++;return;}\n    if(r[x]<r[y]) swap(x,y);\n    r[x]+=r[y];e[x]+=e[y]+1;\n    p[y]=x;\n    num--;\n  }\n  int size(int x){  //頂点数\n    return r[find(x)];\n  }\n  int size2(int x){  //辺の数\n    return e[find(x)];\n  }\n  int count() const{\n    return num;\n  }\n};\n//main\nsigned main(){\n  int N,H,W;cin>>N>>H>>W;\n  typedef pair<int,int> P;\n  typedef pair<int,P> PP;\n  priority_queue<PP> que;\n  for(int i=0;i<N;i++){\n    int r,c,a;cin>>r>>c>>a;r--;c--;\n    que.push(PP(a,P(r,c+100000)));\n  }\n  int ans=0;\n  UnionFind uf(200000);\n  while(que.size()){\n    PP p=que.top();que.pop();\n    int a=p.first,u=p.second.first,v=p.second.second;\n    if(uf.same(u,v)){\n      if(uf.size2(u)<uf.size(v)){\n        uf.unite(u,v);\n        ans+=a;\n      }\n    }\n    else{\n      int p=uf.size(u)+uf.size(v);\n      int e=uf.size2(u)+uf.size2(v);\n      if(e<p){\n        uf.unite(u,v);\n        ans+=a;\n      }\n    }\n  }\n  cout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n, h, w; scanf(\"%d%d%d\", &n, &h, &w);\n    vector<tuple<int, int, int>> edge;\n    for (int i = 0; i < n; ++i) {\n        int r, c, a; scanf(\"%d%d%d\", &r, &c, &a);\n        r--, c--;\n        edge.emplace_back(a, r, c + h);\n    }\n    vector<int> uf(h + w), ec(h + w), sz(h + w);\n    for (int i = 0; i < h + w; ++i) uf[i] = i, sz[i] = 1;\n\n    function<int(int)> Find = [&](int x) {\n        if (x == uf[x]) return x;\n        return uf[x] = Find(uf[x]);\n    };\n\n    sort(edge.begin(), edge.end(), greater<tuple<int, int, int>>());\n    long long ans = 0;\n    for (auto &e : edge) {\n        int w, u, v;\n        tie(w, u, v) = e;\n        u = Find(u), v = Find(v);\n        if (u != v) {\n            if (ec[v] == sz[v] && ec[u] == sz[u]) continue;\n            uf[u] = v;\n            ec[v] += ec[u] + 1;\n            sz[v] += sz[u];\n            ans += w;\n        } else {\n            if (ec[u] < sz[u]) {\n                ec[u]++;\n                ans += w;\n            }\n        }\n    }\n    printf(\"%lld\\n\", ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n * code generated by JHelper\n * More info: https://github.com/AlexeyDmitriev/JHelper\n * @author aajisaka\n */\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nvoid debug_out() { cerr << endl; }\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\n#define SPEED ios_base::sync_with_stdio(false);cin.tie(nullptr)\n#define rep(i,n) for(int i=0; i<(int)(n); i++)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\nusing ll = long long;\nusing P = pair<ll, ll>;\n\nconstexpr double PI = 3.14159265358979323846;\nmt19937_64 engine(chrono::steady_clock::now().time_since_epoch().count());\n\nclass ECardCollector {\npublic:\n\n    vector<P> cost;\n    vector<P> pos;\n\n    std::vector<int> par;\n    std::vector<int> rak; // number of the vertices\n    std::vector<int> rak2;\n\n    void init(int n) {\n      par.resize(n);\n      rak.resize(n);\n      rak2.resize(n);\n      for(int i=0; i<n; i++) {\n        par[i] = i;\n        rak[i] = 1;\n      }\n    }\n\n    int find(int x) {\n      if (par[x] == x) {\n        return x;\n      } else {\n        return par[x] = find(par[x]);\n      }\n    }\n\n    void unite(int x, int y) {\n      x = find(x);\n      y = find(y);\n      if (x==y) return;\n      if (rak[x] < rak[y]) {\n        rak[y] += rak[x];\n        rak2[y] += rak2[x];\n        par[x] = y;\n      } else {\n        rak[x] += rak[y];\n        rak2[x] += rak2[y];\n        par[y] = x;\n      }\n    }\n\n    bool same(int x, int y) {\n      return find(x) == find(y);\n    }\n\n    void solve(istream& cin, ostream& cout) {\n      SPEED;\n      int n, h, w; cin >> n >> h >> w;\n      rep(i, n) {\n        int r, c, a; cin >> r >> c >> a;\n        r--; c--;\n        pos.emplace_back(r, c);\n        cost.emplace_back(a, i);\n      }\n      init(h+w);\n\n      sort(cost.rbegin(), cost.rend());\n      ll ans = 0;\n      rep(i, n) {\n        int co = cost[i].first;\n        int p = cost[i].second;\n        int x = pos[p].first;\n        int y = pos[p].second;\n\n        unite(x, y+h);\n        int pa = find(x);\n\n        if (rak2[pa] < rak[pa]) {\n          ans += co;\n          rak2[pa]++;\n        }\n      }\n      cout << ans << endl;\n    }\n};\n\nsigned main() {\n  ECardCollector solver;\n  std::istream& in(std::cin);\n  std::ostream& out(std::cout);\n  solver.solve(in, out);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mod 1000000007\n#define mod998 998244353\n#define sp ' '\n#define intmax 2147483647\n#define llmax 9223372036854775807\n#define mkp make_pair\ntypedef long long ll;\nusing namespace std;\n\nint N, H, W, R[100000], C[100000], A[100000], t[200000];\nbool used[200000];\nvector<int>v[200000];\nset<pair<int, int>>st;\npriority_queue<pair<int, pair<int, int>>>pq[200000];\nll res;\n\nint p(int x) {\n\tif (t[x] < 0)return x;\n\treturn t[x] = p(t[x]);\n}\n\nvoid u(int x, int y) {\n\tx = p(x);\n\ty = p(y);\n\tif (x == y)return;\n\tif (t[x] < t[y]) {\n\t\tt[x] += t[y];\n\t\tt[y] = x;\n\t}\n\telse {\n\t\tt[y] += t[x];\n\t\tt[x] = y;\n\t}\n}\n\nint main() {\n\tcin >> N >> H >> W;\n\tfor (int i = 0; i < 200000; ++i) {\n\t\tt[i] = -1;\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> R[i] >> C[i] >> A[i];\n\t\t--R[i];\n\t\t--C[i];\n\t\tu(R[i], C[i] + 100000);\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tpq[p(R[i])].push(mkp(A[i], mkp(R[i], C[i] + 100000)));\n\t}\n\tfor (int i = 0; i < 200000; ++i) {\n\t\tif (t[i] < -1) {\n\t\t\tint c = 0;\n\t\t\twhile (c < -t[i] && !pq[i].empty()) {\n\t\t\t\tint x = pq[i].top().second.first;\n\t\t\t\tint y = pq[i].top().second.second;\n\t\t\t\tint s = pq[i].top().first;\n\t\t\t\tpq[i].pop();\n\t\t\t\tif (used[x] && used[y]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (used[x]) {\n\t\t\t\t\tused[y] = true;\n\t\t\t\t\tres += s;\n\t\t\t\t}\n\t\t\t\telse if (used[y]) {\n\t\t\t\t\tused[x] = true;\n\t\t\t\t\tres += s;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tv[x].push_back(y);\n\t\t\t\t\tv[y].push_back(x);\n\t\t\t\t\tres += s;\n\t\t\t\t\tif (!st.insert(mkp(x, y)).second) {\n\t\t\t\t\t\tfor (int j : v[x]) {\n\t\t\t\t\t\t\tused[j] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfor (int j : v[y]) {\n\t\t\t\t\t\t\tused[j] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t++c;\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\n#define mp make_pair\n#define PI pair<int,int>\n#define poly vector<ll>\n#define For(i,l,r) for(int i=(int)(l);i<=(int)(r);i++)\n#define Rep(i,r,l) for(int i=(int)(r);i>=(int)(l);i--)\n#define pb push_back\n#define fi first\n#define se second\ninline char gc(){\n    static char buf[100000],*p1=buf,*p2=buf;\n    return p1==p2&&(p2=(p1=buf)+fread(buf,1,100000,stdin),p1==p2)?EOF:*p1++;\n}\n#define gc getchar\ninline ll read(){\n\tll x = 0; char ch = gc(); bool positive = 1;\n\tfor (; !isdigit(ch); ch = gc())\tif (ch == '-')\tpositive = 0;\n\tfor (; isdigit(ch); ch = gc())\tx = x * 10 + ch - '0';\n\treturn positive ? x : -x;\n}\ninline void write(ll a){\n     if(a<0){\n    \ta=-a; putchar('-');\n\t}\n    if(a>=10)write(a/10);\n    putchar('0'+a%10);\n}\ninline void writeln(ll a){write(a); puts(\"\");}\ninline void wri(ll a){write(a); putchar(' ');}\ninline ull rnd(){\n\treturn ((ull)rand()<<30^rand())<<4|rand()%4;\n}\nconst int N=100005;\nll ans;\nint fa[N<<1],bj[N<<1];\ninline int gf(int x){\n\treturn fa[x]==x?x:fa[x]=gf(fa[x]);\n}\npair<int,PI> a[N];\nint main(){\n\tint n=read(),h=read(),w=read();\n\tFor(i,1,n){\n\t\ta[i].se.fi=read(); a[i].se.se=read()+h;\n\t\ta[i].fi=read();\n\t}\n\tFor(i,1,200000)fa[i]=i;\n\tsort(&a[1],&a[n+1]);\n\tRep(i,n,1){\n\t\tint x=a[i].se.fi,y=a[i].se.se;\n\t\tx=gf(x); y=gf(y);\n\t\tif(x!=y&&(!bj[x]||!bj[y])){\n\t\t\tans+=a[i].fi; fa[x]=y; bj[y]|=bj[x];\n\t\t}else if(!bj[x]){\n\t\t\tans+=a[i].fi; bj[x]=1;\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tif(a<0LL)return 0;\n\tif(b<0LL)return 0;\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n// ここから編集しろ\nlong long UF[210000];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\nint X[110000];\nint Y[110000];\nint C[110000];\npair<int,pair<int,int> > p[110000];\nint main(){\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<b+c+1;i++)UF[i]=-1;\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d%d\",X+i,Y+i,C+i);X[i]--;Y[i]--;\n\t\tp[i]=make_pair(-C[i],make_pair(X[i],Y[i]));\n\t}\n\n\tstd::sort(p,p+a);\n\tlong long ret=0;\n\tfor(int i=0;i<a;i++){\n\t\tif(FIND(p[i].second.first)!=FIND(p[i].second.second+b)){\n\t\t\tret-=p[i].first;\n\t\t\tUNION(p[i].second.first,p[i].second.second+b);\n\t\t}else if(FIND(p[i].second.first)!=FIND(b+c)){\n\t\t\tUNION(p[i].second.first,b+c);\n\t\t\tret-=p[i].first;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,H,W;\n\ntemplate<int NV,class V> class MinCostFlow {\npublic:\n\tstruct edge { int to; V capacity; V cost; int reve;};\n\tvector<edge> E[NV]; int prev_v[NV], prev_e[NV]; V dist[NV];\n\tvoid add_edge(int x,int y, V cap, V cost) {\n\t\tE[x].push_back((edge){y,cap,cost,(int)E[y].size()});\n\t\tE[y].push_back((edge){x,0, -cost,(int)E[x].size()-1}); /* rev edge */\n\t}\n\t\n\tV mincost(int from, int to, ll flow) {\n\t\tV res=0; int i,v;\n\t\tZERO(prev_v); ZERO(prev_e);\n\t\twhile(flow>0) {\n\t\t\tfill(dist, dist+NV, numeric_limits<V>::max()/2);\n\t\t\tdist[from]=0;\n\t\t\tpriority_queue<pair<V,int> > Q;\n\t\t\tQ.push(make_pair(0,from));\n\t\t\twhile(Q.size()) {\n\t\t\t\tV d=-Q.top().first;\n\t\t\t\tint cur=Q.top().second;\n\t\t\t\tQ.pop();\n\t\t\t\tif(dist[cur]!=d) continue;\n\t\t\t\tif(d==numeric_limits<V>::max()/2) break;\n\t\t\t\tFOR(i,E[cur].size()) {\n\t\t\t\t\tedge &e=E[cur][i];\n\t\t\t\t\tif(e.capacity>0 && dist[e.to]>d+e.cost) {\n\t\t\t\t\t\tdist[e.to]=d+e.cost;\n\t\t\t\t\t\tprev_v[e.to]=cur;\n\t\t\t\t\t\tprev_e[e.to]=i;\n\t\t\t\t\t\tQ.push(make_pair(-dist[e.to],e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(dist[to]==numeric_limits<V>::max()/2) return -1;\n\t\t\tll lc=flow;\n\t\t\tfor(v=to;v!=from;v=prev_v[v]) lc = min(lc, E[prev_v[v]][prev_e[v]].capacity);\n\t\t\tflow -= lc;\n\t\t\tres += lc*dist[to];\n\t\t\tfor(v=to;v!=from;v=prev_v[v]) {\n\t\t\t\tedge &e=E[prev_v[v]][prev_e[v]];\n\t\t\t\te.capacity -= lc;\n\t\t\t\tE[v][e.reve].capacity += lc;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n};\n\nMinCostFlow<303050,ll> mcf;\n\nint R[101010],C[101010],A[101010];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>H>>W;\n\tFOR(i,H) mcf.add_edge(0,10+i,1,0), mcf.add_edge(10+i,1,1,1LL<<30);\n\tFOR(i,W) mcf.add_edge(0,100020+i,1,0), mcf.add_edge(100020+i,1,1,1LL<<30);\n\t\n\t\n\t\n\tFOR(i,N) {\n\t\tcin>>R[i]>>C[i]>>A[i];\n\t\tR[i]--;\n\t\tC[i]--;\n\t\tmcf.add_edge(10+R[i],200030+i,1,(1LL<<30)-A[i]);\n\t\tmcf.add_edge(100020+C[i],200030+i,1,(1LL<<30)-A[i]);\n\t\tmcf.add_edge(200030+i,1,1,0);\n\t}\n\t\n\tll ret=mcf.mincost(0,1,H+W);\n\tcout<<(H+W)*(1LL<<30)-ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <complex>\n#include <deque>\n#include <iterator>\n#include <numeric>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <limits>\n#include <iomanip>\nusing namespace std;\n\nusing ll=long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\nusing vll = V<ll>;\nusing vvll = V<vll>;\n#define rep(i, k, n) for (ll i=k; i<(ll)n; ++i)\n#define REP(i, n) rep(i, 0, n)\ntemplate<class T> inline bool chmax(T& a, T b) {if (a<b) {a=b; return true;} return false;}\ntemplate<class T> inline bool chmin(T& a, T b) {if (a>b) {a=b; return true;} return false;}\n\nconst ll MOD = 1000000007;\nconst ll HIGHINF = (ll)1e18;\n\nll n, h, w;\n\nstruct UnionFind {\n    vector<long long> par, cnt;\n\n    UnionFind(long long n): par(n, -1), cnt(n) {}\n    long long find(long long x) {\n        if (par[x]<0) return x;\n        return par[x] = find(par[x]);\n    }\n    bool same(long long i, long long j) {\n        // iとjが同じグループかどうかを判別する\n        return find(i) == find(j);\n    }\n    long long size(long long x) {\n        return -par[find(x)];\n    }\n\n    bool unite(long long x, long long y) {\n        // iとjを併合する\n        x = find(x);\n        y = find(y);\n        bool ok = (-par[x]>cnt[x] || -par[y]>cnt[y]);\n        if (x == y) {\n            cnt[x]++;\n        } else if (par[x] > par[y]) {\n            par[y] += par[x];\n            par[x] = y;\n            cnt[y] += cnt[x]+1;\n        } else {\n            par[x] += par[y];\n            par[y] = x;\n            cnt[x] += cnt[y]+1;\n        }\n        return ok;\n    }\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> n >> h >> w;\n    vll r(n), c(n), a(n);\n    REP(i, n) cin >> r[i] >> c[i] >> a[i];\n    vll ord(n); iota(ord.begin(), ord.end(), 0);\n    sort(ord.begin(), ord.end(), [&](ll x, ll y) {\n      return a[x] > a[y];\n    });\n    ll ans = 0;\n    UnionFind uf(h+w);\n    for (ll i: ord) {\n        --r[i]; --c[i];\n        if (uf.unite(r[i], c[i]+h)) ans += a[i];\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #pragma GCC target(\"avx2\")  // CPU 処理並列化\n// #pragma GCC optimize(\"O3\")  // CPU 処理並列化\n// #pragma GCC optimize(\"unroll-loops\")  // 条件処理の呼び出しを減らす\n#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\n#include<numeric>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst double EPS=1e-10;\nconst double INF=1e+10;\nconst double PI=acos(-1.0);\nconst int C_SIZE = 3121000;\nlong long fact[C_SIZE];\nlong long finv[C_SIZE];\nlong long inv[C_SIZE];\nlong long Comb(int a,int b){\n \tif(a<b||b<0)return 0;\n \treturn fact[a]*finv[b]%mod*finv[a-b]%mod;\n}\nvoid init_C(int n){\n\tfact[0]=finv[0]=inv[1]=1;\n\tfor(int i=2;i<n;i++){\n\t\tinv[i]=(mod-(mod/i)*inv[mod%i]%mod)%mod;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\tfact[i]=fact[i-1]*i%mod;\n\t\tfinv[i]=finv[i-1]*inv[i]%mod;\n\t}\n}\nlong long pw(long long a,long long b){\n\tif(a<0LL)return 0;\n\tif(b<0LL)return 0;\n\tlong long ret=1;\n\twhile(b){\n\t\tif(b%2)ret=ret*a%mod;\n\t\ta=a*a%mod;\n\t\tb/=2;\n\t}\n\treturn ret;\n}\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\ndouble ABS(double a){return max(a,-a);}\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n// ここから編集しろ\n\nint X[110000];\nint Y[110000];\nint C[110000];\nset<pair<int,int> >S[110000];\nset<pair<int,int> >T[110000];\nset<pair<int,int> >V;\nint main(){\n\tint a,b,c;scanf(\"%d%d%d\",&a,&b,&c);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d%d\",X+i,Y+i,C+i);X[i]--;Y[i]--;\n\t\tS[X[i]].insert(make_pair(C[i],i));\n\t\tT[Y[i]].insert(make_pair(C[i],i));\n\t}\n\tfor(int i=0;i<b;i++){\n\t\tS[i].insert(make_pair(0,-1));\n\t\tS[i].insert(make_pair(0,-2));\n\n\t\tV.insert(make_pair((S[i].rbegin()->first)-(++(S[i].rbegin()))->first,i));\n\t}\n\tfor(int i=0;i<c;i++){\n\t\tT[i].insert(make_pair(0,-1));\n\t\tT[i].insert(make_pair(0,-2));\n\t\tV.insert(make_pair((T[i].rbegin()->first)-(++(T[i].rbegin()))->first,i+b));\n\t}\n\tlong long ret=0;\n\tfor(int i=0;i<b+c;i++){\n\t\tpair<int,int> rr=*(V.rbegin());\n\t//\tprintf(\"%d %d\\n\",rr.first,rr.second);\n\t\tint I=rr.second;\n\t\tif(I>=b){\n\t\t\tI-=b;\n\t\t\tret+=T[I].rbegin()->first;\n\t\t\tif(T[I].rbegin()->second>=0){\n\t\t\t\tint J=T[I].rbegin()->second;\n\t\t\t\tbool flag=false;\n\t\t\t\tif(V.count(make_pair((S[X[J]].rbegin()->first)-(++(S[X[J]].rbegin()))->first,X[J]))){\n\t\t\t\t\tV.erase(make_pair((S[X[J]].rbegin()->first)-(++(S[X[J]].rbegin()))->first,X[J]));\n\t\t\t\t\tflag=true;\n\t\t\t\t}\n\t\t\t\tS[X[J]].erase(make_pair(C[J],J));\n\t\t\t\tif(flag){\n\t\t\t\t\tV.insert(make_pair((S[X[J]].rbegin()->first)-(++(S[X[J]].rbegin()))->first,X[J]));\n\t\t\t\t}\n\t\t\t}\n\t\t}else{\n\t\t\tret+=S[I].rbegin()->first;\n\t\t\tif(S[I].rbegin()->second>=0){\n\t\t\t\tint J=S[I].rbegin()->second;\n\t\t\t\tbool flag=false;\n\t\t\t\tif(V.count(make_pair((T[Y[J]].rbegin()->first)-(++(T[Y[J]].rbegin()))->first,Y[J]+b))){\n\t\t\t\t\tV.erase(make_pair((T[Y[J]].rbegin()->first)-(++(T[Y[J]].rbegin()))->first,Y[J]+b));\n\t\t\t\t\tflag=true;\n\t\t\t\t}\n\t\t\t\tT[Y[J]].erase(make_pair(C[J],J));\n\t\t\t\tif(flag){\n\t\t\t\t\tV.insert(make_pair((T[Y[J]].rbegin()->first)-(++(T[Y[J]].rbegin()))->first,Y[J]+b));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tV.erase(rr);\n\t}\n\tprintf(\"%lld\\n\",ret);\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//////////////////\n// Union-Find木 //\n//////////////////\n\n// 0-indexed\nclass UnionFind {\nprivate:\n\tstd::vector<int> parent_, size_;\npublic:\n\tUnionFind(const int size)\n\t\t:parent_(size), size_(size, 1)\n\t{\n\t\tfor (int i{}; i < size; i++) parent_[i] = i;\n\t}\n\tint calcRoot(const int index)\n\t{\n\t\tint &parent{parent_[index]};\n\t\tif (parent == index) return index;\n\n\t\tparent = calcRoot(parent);\n\t\treturn parent;\n\t}\n\tbool areConnected(const int index1, const int index2)\n\t{\n\t\treturn calcRoot(index1) == calcRoot(index2);\n\t}\n\tvoid unite(const int index1, const int index2)\n\t{\n\t\tconst int root1{calcRoot(index1)}, root2{calcRoot(index2)};\n\t\tif (root1 == root2) return;\n\t\tif (size_[root1] <= size_[root2])\n\t\t{\n\t\t\tsize_[root2] += size_[root1];\n\t\t\tparent_[root1] = root2;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsize_[root1] += size_[root2];\n\t\t\tparent_[root2] = root1;\n\t\t}\n\t\treturn;\n\t}\n\tint calcSize(const int index)\n\t{\n\t\treturn size_[calcRoot(index)];\n\t}\n};\n\nint main()\n{\n\tint N, H, W;\n\tscanf(\"%d%d%d\", &N, &H, &W);\n\tusing i3 = std::array<int, 3>;\n\tusing vi3 = std::vector<i3>;\n\tusing vvi3 = std::vector<vi3>;\n\tvvi3 grid[2];\n\tvi3 cards(N);\n\tgrid[0].resize(H);\n\tgrid[1].resize(W);\n\tfor (int i{}; i < N; i++)\n\t{\n\t\tint R, C, A;\n\t\tscanf(\"%d%d%d\", &R, &C, &A);\n\t\tR--; C--;\n\t\tgrid[0][R].push_back({A, (int)grid[1].size(), C});\n\t\tgrid[1][C].push_back({A, (int)grid[0].size() - 1, R});\n\t\tcards[i] = {A, R, C};\n\t}\n\tfor (auto& e: grid) std::sort(e.rbegin(), e.rend());\n\tstd::sort(cards.rbegin(), cards.rend());\n\tstd::vector<int> index[2];\n\tindex[0].resize(H);\n\tindex[1].resize(W);\n\tstd::vector<int> size(H + W);\n\tUnionFind uf(H + W);\n\tint64_t ans{};\n\tfor (auto& card: cards)\n\t{\n\t\tif (uf.areConnected(card[1], card[2] + H))\n\t\t{\n\t\t\tint root{uf.calcRoot(card[1])};\n\t\t\tif (size[root] == uf.calcSize(root)) continue;\n\t\t\tsize[root]++;\n\t\t\tans += card[0];\n\t\t}\n\t\telse\n\t\t{\n\t\t\tint root1{uf.calcRoot(card[1])}, root2{uf.calcRoot(card[2] + H)};\n\t\t\tuf.unite(root1, root2);\n\t\t\tint root{uf.calcRoot(root1)};\n\t\t\tsize[root] = size[root1] + size[root2];\n\t\t\tif (size[root] == uf.calcSize(root)) continue;\n\t\t\tsize[root]++;\n\t\t\tans += card[0];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nconst int MAX=1e6+7;\nusing namespace std;\nint fa[MAX],rem[MAX];\nstruct node\n{\n\tint x;\n\tint y;\n\tint v;\n}Map[MAX];\nint find(int n)\n{\n\tif(fa[n]==n)\n\t{\n\t\treturn n;\n\t}\n\telse return fa[n]=find(fa[n]);\n} \nvoid merge(int a,int b)\n{\n\tfa[find(a)]=find(b);\n}\nbool cmp(node a,node b)\n{\n\treturn a.v>b.v;\n}\nint k=0;\nsigned main()\n{\n\tint T,n,m,ans=0;\n\tcin>>T>>n>>m;\n\tfor(int i=1;i<=T;i++)\n\t{\n\t\tcin>>Map[i].x>>Map[i].y>>Map[i].v;\n\t} \n\tsort(Map+1,Map+1+T,cmp);\n\tfor(int i=1;i<=n+m;i++)\n\t{\n\t\tfa[i]=i;\n\t\trem[i]=1;\n\t}\n\tfor(int i=1;i<=T;i++)\n\t{\n\t\tint fx=find(Map[i].x),fy=find(Map[i].y+n);\n\t\tif(fx==fy)\n\t\t{\n\t\t\tif(rem[fx])\n\t\t\t{\n\t\t\t\trem[fx]--;\n\t\t\t\tans+=Map[i].v;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(rem[fx]+rem[fy])\n\t\t\t{\n\t\t\t\trem[fx]+=rem[fy];\n\t\t\t\trem[fx]--;\n\t\t\t\tmerge(Map[i].y+n,Map[i].x);\n\t\t\t\tans+=Map[i].v;\n\t\t\t}\n\t\t}\n\t\t//cout<<\"ans=\"<<ans<<endl;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <tuple>\n\nstruct UnionFind {\n    std::vector<int> par, sz;\n    std::vector<bool> namori;\n    int gnum;\n\n    explicit UnionFind(int n)\n        : par(n), sz(n, 1), namori(n, false), gnum(n) {\n        std::iota(par.begin(), par.end(), 0);\n    }\n\n    int find(int v) {\n        return (par[v] == v) ? v : (par[v] = find(par[v]));\n    }\n\n    void unite(int u, int v) {\n        u = find(u), v = find(v);\n        if (u == v) return;\n\n        if (sz[u] < sz[v]) std::swap(u, v);\n        sz[u] += sz[v];\n        par[v] = u;\n        namori[u] = (namori[u] || namori[v]);\n        --gnum;\n    }\n\n    bool same(int u, int v) { return find(u) == find(v); }\n    bool ispar(int v) { return v == find(v); }\n    int size(int v) { return sz[find(v)]; }\n};\n\nusing lint = long long;\n\nvoid solve() {\n    int n, h, w;\n    std::cin >> n >> h >> w;\n\n    std::vector<std::tuple<lint, int, int>> es;\n    while (n--) {\n        int x, y;\n        lint a;\n        std::cin >> x >> y >> a;\n        --x, --y;\n        es.emplace_back(a, x, y + h);\n    }\n    std::sort(es.rbegin(), es.rend());\n\n    UnionFind uf(h + w);\n    lint ans = 0;\n    for (auto e : es) {\n        int u, v;\n        lint a;\n        std::tie(a, u, v) = e;\n\n        u = uf.find(u);\n        v = uf.find(v);\n        if (u == v) {\n            if (uf.namori[u]) continue;\n            ans += a;\n            uf.namori[u] = true;\n        } else {\n            if (uf.namori[u] && uf.namori[v]) continue;\n            ans += a;\n            uf.unite(u, v);\n        }\n    }\n\n    std::cout << ans << std::endl;\n}\n\nint main() {\n    std::cin.tie(nullptr);\n    std::cout.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#define vv(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define vvi vector<vector<int> >\n#define vvl vector<vector<ll> >\n#define vl vector<ll>\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nset<ll> num;\nvector<bool> used(200002, false);\nstruct edge{ll to, cost, n;};\nvector<vector<edge> > G(200002);\nvvl lis = vv(200002, 0, 0, ll);\n\nvoid dfs(ll now, ll c){\n  if(used[now]) return;\n  lis[c].push_back(now);\n  used[now] = true;\n  for(int i=0;i<G[now].size();i++){\n    dfs(G[now][i].to, c);\n  }\n}\nint main(int argc, char const *argv[]) {\n  ll N, H, W, a, b, c, ans = 0;\n  std::cin >> N >> H >> W;\n  for(int i=0;i<N;i++){\n    std::cin >> a >> b >> c;\n    G[a].push_back(edge{b+100001, -c, i});\n    G[b+100001].push_back(edge{a, -c, i});\n  }\n  for(int i=0;i<200002;i++) if(!used[i]) dfs(i, i);\n  std::vector<bool> us(200002, false), eg(200002, false);\n\n  for(int i=0;i<200002;i++){\n    if(lis[i].size()<=1) continue;\n    vvl e = vv(0, 4, 0, ll);\n    for(int j=0;j<lis[i].size();j++){\n      for(int k=0;k<G[lis[i][j]].size();k++){\n        e.push_back(vl{G[lis[i][j]][k].cost, G[lis[i][j]][k].n, lis[i][j], G[lis[i][j]][k].to});\n      }\n    }\n    ll v = 0;\n    ll t = 0;\n    sort(e.begin(), e.end());\n    for(int j=0;j<e.size();j++){\n      if(eg[e[j][1]]) continue;\n      ll tmp = (!us[e[j][2]]?1:0) + (!us[e[j][3]]?1:0);\n      if(v + tmp > t){\n        t++;\n        v += tmp;\n        eg[e[j][1]] = us[e[j][2]] = us[e[j][3]] = true;\n        ans -= e[j][0];\n      }\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h> // Tomasz Nowak\nusing namespace std;     // XIII LO Szczecin\nusing LL = long long;    // Poland\n#define FOR(i, l, r) for(int i = (l); i <= (r); ++i)\n#define REP(i, n) FOR(i, 0, (n) - 1)\ntemplate<class T> int size(T &&x) {\n\treturn int(x.size());\n}\ntemplate<class A, class B> ostream& operator<<(ostream &out, const pair<A, B> &p) {\n\treturn out << '(' << p.first << \", \" << p.second << ')';\n}\ntemplate<class T> auto operator<<(ostream &out, T &&x) -> decltype(x.begin(), out) {\n\tout << '{';\n\tfor(auto it = x.begin(); it != x.end(); ++it)\n\t\tout << *it << (it == prev(x.end()) ? \"\" : \", \");\n\treturn out << '}';\n}\nvoid dump() {}\ntemplate<class T, class... Args> void dump(T &&x, Args... args) {\n\tcerr << x << \";  \";\n\tdump(args...);\n}\n#ifdef DEBUG\n  struct Nl{~Nl(){cerr << '\\n';}};\n# define debug(x...) cerr << (strcmp(#x, \"\") ? #x \":  \" : \"\"), dump(x), Nl(), cerr << \"\"\n#else\n# define debug(...) 0 && cerr\n#endif\nmt19937_64 rng(0);\nint rd(int l, int r) {\n\treturn uniform_int_distribution<int>(l, r)(rng);\n}\n// end of templates\n\nstruct MCMF {\n\tstruct Edge {\n\t\tint v, u, flow, cap;\n\t\tLL cost;\n\t\tfriend ostream& operator<<(ostream &os, Edge &e) {\n\t\t\treturn os << vector<LL>{e.v, e.u, e.flow, e.cap, e.cost};\n\t\t}\n\t};\n\n\tint n;\n\tconst LL inf_LL = 0x3f3f3f3f3f3f3f3f;\n\tconst int inf_int = 0x3f3f3f3f;\n\tvector<vector<int>> graph;\n\tvector<Edge> edges;\n\n\tMCMF(int N) : n(N), graph(n) {}\n\n\tvoid add_edge(int v, int u, int cap, LL cost) {\n\t\tdebug() << \"adding edge \" << v << '-' << u << \": \" << make_pair(cap, cost);\n\t\tint e = size(edges);\n\t\tgraph[v].emplace_back(e);\n\t\tgraph[u].emplace_back(e + 1);\n\t\tedges.emplace_back(Edge{v, u, 0, cap, cost});\n\t\tedges.emplace_back(Edge{u, v, 0, 0, -cost});\n\t}\n\n\tpair<int, LL> augment(int source, int sink) {\n\t\tvector<LL> dist(n, inf_LL);\n\t\tvector<int> from(n, -1);\n\t\tdist[source] = 0;\n\t\tdeque<int> que = {source};\n\t\tvector<bool> inside(n);\n\t\tinside[source] = true;\n\n\t\twhile(size(que)) {\n\t\t\tint v = que.front();\n\t\t\tinside[v] = false;\n\t\t\tque.pop_front();\n\n\t\t\tfor(int i : graph[v]) {\n\t\t\t\tEdge &e = edges[i];\n\t\t\t\tif(e.flow != e.cap and dist[e.u] > dist[v] + e.cost) {\n\t\t\t\t\tdist[e.u] = dist[v] + e.cost;\n\t\t\t\t\tfrom[e.u] = i;\n\t\t\t\t\tif(not inside[e.u]) {\n\t\t\t\t\t\tinside[e.u] = true;\n\t\t\t\t\t\tque.emplace_back(e.u);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(from[sink] == -1)\n\t\t\treturn {0, 0};\n\n\t\tint flow = inf_int, e = from[sink];\n\t\twhile(e != -1) {\n\t\t\tflow = min(flow, edges[e].cap - edges[e].flow);\n\t\t\te = from[edges[e].v];\n\t\t}\n\t\te = from[sink];\n\t\twhile(e != -1) {\n\t\t\tedges[e].flow += flow;\n\t\t\tedges[e ^ 1].flow -= flow;\n\t\t\te = from[edges[e].v];\n\t\t}\n\t\treturn {flow, flow * dist[sink]};\n\t}\n\n\tpair<int, LL> operator()(int source, int sink) {\n\t\tint flow = 0;\n\t\tLL cost = 0;\n\t\tpair<int, LL> got;\n\t\tdo {\n\t\t\tgot = augment(source, sink);\n\t\t\tflow += got.first;\n\t\t\tcost += got.second;\n\t\t} while(got.first);\n\t\treturn {flow, cost};\n\t}\n};\n\nvector<int> vis, match;\nvector<int> a;\nvector<array<int, 2>> edges;\nint vis_cnt = 0;\n\ninline bool ask(int q) {\n\tvis[q] = vis_cnt;\n\tREP(d, 2)\n\t\tif(match[edges[q][d]] == -1) {\n\t\t\tmatch[edges[q][d]] = q;\n\t\t\treturn true;\n\t\t}\n\tREP(d, 2) {\n\t\tint &m = match[edges[q][d]];\n\t\tif(vis[m] != vis_cnt and ask(m)) {\n\t\t\tm = q;\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n};\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint n, h, w;\n\tcin >> n >> h >> w;\n\ta.resize(n);\n\tedges.resize(n);\n\tLL answer = 0;\n\n\tvector<pair<int, int>> sorted;\n\tREP(q, n) {\n\t\tint r, c, cost;\n\t\tcin >> r >> c >> cost;\n\t\t--r, --c;\n\t\ta[q] = cost;\n\t\tedges[q] = {r, h + c};\n\t\tif(rd(0, 1))\n\t\t\tswap(edges[q][0], edges[q][1]);\n\t\tsorted.emplace_back(a[q], q);\n\t}\n\tsort(sorted.rbegin(), sorted.rend());\n\tdebug(sorted);\n\n\tvis.resize(n);\n\tmatch.resize(h + w, -1);\n\n\tfor(auto &p : sorted) {\n\t\t++vis_cnt;\n\t\tif(ask(p.second))\n\t\t\tanswer += a[p.second];\n\t}\n\n\tcout << answer << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm> //STLÍ¨ÓÃËã·¨\n#include <cmath> //¶¨ÒåÊýÑ§º¯Êý\n#include <cstdio> //¶¨ÒåÊäÈë/Êä³öº¯Êý\n#include <iostream> //Êý¾ÝÁ÷ÊäÈë/Êä³ö\n#include <cstring> //×Ö·û´®´¦Àí\n#include <string> //×Ö·û´®Àà\n#include <ctime> //¶¨Òå¹ØÓÚÊ±¼äµÄº¯Êý\n#define itn int\n#define fro for\n#define ll long long\n#define reg register\n#define inf 1234567890\n#define rep(i,a,b,c) for (int i=a;i<=b;i+=c)\n/*#include <bitset> //STLÎ»¼¯ÈÝÆ÷\n#include <cstype> //×Ö·û´¦Àí\n#include <cerrno> //¶¨Òå´íÎóÂë\n#include <complex> //¸´ÊýÀà\n#include <clocale> //¶¨Òå±¾µØ»¯º¯Êý\n#include <cstdlib> //¶¨ÒåÔÓÏîº¯Êý¼°ÄÚ´æ·ÖÅäº¯Êý\n#include <deque> //STLË«¶Ë¶ÓÁÐÈÝÆ÷\n#include <exception> //Òì³£´¦ÀíÀà\n#include <fstream> //ÎÄ¼þÊäÈë/Êä³ö\n#include <functional> //STL¶¨ÒåÔËËãº¯Êý(´úÌæÔËËã·û)\n#include <limits> //¶¨Òå¸÷ÖÖÊý¾ÝÀàÐÍ×îÖµ³£Á¿\n#include <list> //STLÏßÐÔÁÐ±íÈÝÆ÷\n#include <map> //STLÓ³ÉäÈÝÆ÷\n#include <iomanip> //²ÎÊý»¯ÊäÈë/Êä³ö\n#include <ios> //»ù±¾ÊäÈë/Êä³öÖ§³Ö\n#include <iosfwd> //ÊäÈë/Êä³öÏµÍ³Ê¹ÓÃµÄÇ°ÖÃÉùÃ÷\n#include <istream> //»ù±¾ÊäÈëÁ÷\n#include <ostream> //»ù±¾Êä³öÁ÷\n#include <queue> //STL¶ÓÁÐÈÝÆ÷\n#include <set> //STL¼¯ºÏÈÝÆ÷\n#include <sstream> //»ùÓÚ×Ö·û´®µÄÁ÷\n#include <stack> //STL¶ÑÕ»ÈÝÆ÷\n#include <stdexcept> //±ê×¼Òì³£Àà\n#include <streambuf> //µ×²ãÊäÈë/Êä³öÖ§³Ö\n#include <utility> //STLÍ¨ÓÃÄ£°åÀà\n#include <vector> //STL¶¯Ì¬Êý×éÈÝÆ÷\n#include <cwchar.h>//¿í×Ö·û´¦Àí¼°ÊäÈë/Êä³ö\n#include <cwctype.h> //¿í×Ö·û·ÖÀà*/\n\nusing namespace std;\n\nll ans;\n\nint max(int x,int y){return x>y?x:y;}\n\nint min(int x,int y){return x<y?x:y;}\n\nint abs(int x){return x>0?x:-x;}\n\nint gcd(int x,int y){return (!y)?x:gcd(y,x%y);}\n\nvoid exgcd(int a,int b,int &d,int &x,int &y){if (!b){d=a,x=1,y=0;}else{exgcd(b,a%b,d,y,x);y-=x*(a/b);}}\n\nint quick_power(ll a,int b){ll r=1;for (;b;b>>=1,a=a*a)if (b&1) r=r*a;return r;}\n\ninline char read() {\n\tstatic const int IN_LEN = 1000000;\n\tstatic char buf[IN_LEN], *s, *t;\n\treturn (s == t ? t = (s = buf) + fread(buf, 1, IN_LEN, stdin), (s == t ? -1 : *s++) : *s++);\n}\ntemplate<class T>\ninline void read(T &x) {\n\tstatic bool iosig;\n\tstatic char c;\n\tfor (iosig = false, c = read(); !isdigit(c); c = read()) {\n\t\tif (c == '-') iosig = true;\n\t\tif (c == -1) return;\n\t}\n\tfor (x = 0; isdigit(c); c = read()) x = x * 10 + (c ^ '0');\n\tif (iosig) x = -x;\n}\n\nchar sr[10000000],z[20];int C=-1,Z=0;\nvoid Ot(){fwrite(sr,1,C+1,stdout),C=-1;}\nvoid print(int x){\n\tif (x<0) sr[++C]='-',x=-x;\n    while(z[++Z]=x%10+48,x/=10);\n    while(sr[++C]=z[Z],--Z);sr[++C]='\\n';\n}\n\nconst int N=200200;\nint fa[N],size[N],key[N];\nstruct p\n{\n\tint x,y,v;\n} a[N];\n\nbool cmp(p x,p y)\n{\n\treturn x.v>y.v;\n}\n\nint find(int x){return fa[x]=fa[x]==x?x:find(fa[x]);}\n\n//void add(int x,int y,int z){to[++cnt]=y;v[cnt]=z;Next[cnt]=head[x];head[x]=cnt;}\nint main()\n{\n\tint n,h,w;\n\tread(n);read(h);read(w);\n\tfor (int i=1;i<=n;i++) read(a[i].x),read(a[i].y),a[i].y+=h,read(a[i].v);\n\tfor (int i=1;i<=h+w;i++) fa[i]=i,size[i]=1;\n\tsort(a+1,a+n+1,cmp);\n\tfor (int i=1;i<=n;i++)\n\t{\n\t\tint fx=find(a[i].x),fy=find(a[i].y);\n\t\tif (fx==fy)\n\t\t{\n\t\t\tif (size[fx]>=key[fx]+1)\n\t\t\t{\n\t\t\t\tkey[fx]++;\n\t\t\t\tans+=a[i].v;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (size[fx]+size[fy]>=key[fx]+key[fy]+1)\n\t\t\t{\n\t\t\t\tsize[fx]+=size[fy];\n\t\t\t\tkey[fx]+=key[fy]+1;\n\t\t\t\tfa[fy]=fx;\n\t\t\t\tans+=a[i].v;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define name \"bai5\"\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define fto(i,a,b) for(int i=a; i<=b;++i)\n#define maxn 100009\n#define ll long long\n\nusing namespace std;\nbool gone[maxn][3],ck[maxn][3];\nint cl[maxn];\nint xd[maxn][3],a[maxn][3],w,h,n;\npii b[maxn];\nbool check(int i, int x,int j){\n    //if(!ck[i][x]) return false;\n    if(gone[i][x])return false;\n    gone[i][x]=true;\n    if(xd[i][x]==0){\n        xd[i][x]=j;\n        gone[i][x]=false;\n        return true;\n    }\n    /// xd[i][x]!=0;\n    /// i,x la cot hoac hang, j la chi so can dien\n    int t=xd[i][x];/// t la so can dien\n    if(check(a[t][1-x],1-x,t)){\n        xd[i][x]=j;\n        gone[i][x]=false;\n        return true;\n    }\n    gone[i][x]=false;\n    return false;\n}\nint main()\n{\n    cin >> n >> h >> w;\n    fto(i,1,n){\n        cin >> a[i][0]>> a[i][1] >> b[i].fi;\n        b[i].se=i;\n    }\n    sort(b+1,b+n+1,greater<pii> ());\n    ll res=0;\n    fto(i,1,n){\n        int j=b[i].se;\n        if(check(a[j][0],0,j)){\n            //xd[a[j][0]][0]=j;\n            res+=b[i].fi;\n        }\n        else if(check(a[j][1],1,j)){\n            //xd[a[j][1]][1]=j;\n            res+=b[i].fi;\n        }\n    }\n    cout << res ;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n#ifdef zxc\n\n#include <sys/resource.h>\n#include \"debug.h\"\n\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nusing ll = int64_t;\nusing ld = long double;\nconst ld EPS = 1e-9;\n//const ll MOD = 924844033;\nconst ld PI = 3.141592653589793;\nconst int maxn = 300001;\nconst ll MOD = 1e9 + 7;\n\nvoid fast_io() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n}\n\nll pw(ll a, ll b) {\n    ll res = 1;\n    for (; b; b >>= 1) {\n        if (b & 1) {\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n    }\n    return res;\n}\n\nint used[maxn];\nint mt[maxn];\nint a[maxn];\nvector<int> g[maxn];\n\nint kuhn(int v) {\n    if (used[v]) {\n        return 0;\n    }\n    used[v] = 1;\n    for (int to:g[v]) {\n        if (!mt[to]) {\n            mt[to] = v;\n            return 1;\n        }\n    }\n    for (int to:g[v]) {\n        if (kuhn(mt[to])) {\n            mt[to] = v;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nll weight_match(int n, vector<int> order) {\n    ll ans = 0;\n    for (int v:order) {\n        if (kuhn(v)) {\n            ans += a[v];\n            fill(used, used+n,0);\n        }\n    }\n    return ans;\n}\n\nsigned main() {\n#ifdef zxc\n    struct rlimit rl;\n    const rlim_t kStackSize = 512L * 1024L * 1024L;\n    assert(!getrlimit(RLIMIT_STACK, &rl));\n    rl.rlim_cur = kStackSize;\n    assert(!setrlimit(RLIMIT_STACK, &rl));\n    freopen(\"../kolya_input.txt\", \"r\", stdin);\n//    freopen(\"../kolya_output.txt\", \"w\", stdout);\n#else\n    //    mt19937 mt(std::chrono::high_resolution_clock::now().time_since_epoch().count());\n    //            freopen(\"\", \"r\", stdin);\n    //        freopen(\"hack.out\", \"w\", stdout);\n#endif\n    auto solve = [](int _) {\n        int n, h, w;\n        cin >> n >> h >> w;\n        vector<int> r(n), c(n);\n        for (int i = 1; i <= n; ++i) {\n            for (auto x:{r.data(), c.data(), a}) {\n                cin >> x[i - 1];\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            g[i].push_back(r[i] - 1);\n            g[i].push_back(c[i] + h - 1);\n        }\n        vector<int> p(n);\n        iota(p.begin(), p.end(), 0);\n        sort(p.begin(), p.end(), [&](int x, int y) {\n            return a[x] > a[y];\n        });\n        auto ans = weight_match(n,p);\n        cout<<ans;\n    };\n\n\n    fast_io();\n    cout.precision(9);\n    cout << fixed;\n    auto start = chrono::steady_clock::now();\n    for (int i = 1; i <= 1; ++i)solve(i);\n    auto end = chrono::steady_clock::now();\n\n    debug(\"time\", chrono::duration_cast<chrono::milliseconds>(end - start).count() / 1000.0);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ll long long\nconst int MAXN = 1e5 + 10;\n\nstruct node{\n    int u,v;\n    ll w;\n}edge[MAXN];\n\nbool cmp(node a,node b){return a.w > b.w;}\n\nint cy[MAXN<<1],n,h,w;\nbool vis[MAXN];\n\nbool dfs(int i)\n{\n    if (vis[i]) return false;\n    vis[i] = 1;\n    if (cy[edge[i].u] == 0)\n    {\n        cy[edge[i].u] = i;\n        return true;\n    }\n    else if (cy[edge[i].v + MAXN] == 0)\n    {\n        cy[edge[i].v + MAXN] = i;\n        return true;\n    }\n    if (dfs(cy[edge[i].u]))\n    {\n        cy[edge[i].u] = i;\n        return true;\n    }\n    else if (dfs(cy[edge[i].v + MAXN]))\n    {\n        cy[edge[i].v + MAXN] = i;\n        return true;\n    }\n    return false;\n}\n\nmap<pair<int,int>,int> g;\n\nll match()\n{\n    for (int i = 1;i<=n;i++)\n    {\n        memset(vis,0,sizeof(vis));\n        if (g[make_pair(edge[i].u,edge[i].v)] >= 2) continue;\n        g[make_pair(edge[i].u,edge[i].v)]++;\n        // for(int j=1;j<=n;j++) vis[i]=0;\n        dfs(i);\n    }\n    ll ans = 0;\n    for (int i = 1;i<=h;i++) ans += edge[cy[i]].w;\n    for (int i = MAXN + 1;i<=MAXN + w;i++) ans += edge[cy[i]].w;\n    return ans;\n}\n\nint main()\n{\n    // cin>>n>>h>>w;\n    scanf(\"%d%d%d\",&n,&h,&w);\n    for (int i = 1;i<=n;i++)\n    {\n        scanf(\"%d%d%lld\",&edge[i].u,&edge[i].v,&edge[i].w);\n    }\n    sort(edge+1,edge + n + 1,cmp);\n    // cout<<match();\n    printf(\"%lld\",match());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn=1e5+5;\nint a[maxn]={0},b[maxn]={0};\nint n,h,w;\nint cnt=0;\nll sum=0;\nstruct pp\n{\n\tint x,y,z;\n}s[maxn];\nbool cmpz(pp a,pp b)\n{\n\treturn a.z>b.z;\n}\n/*void find(int i,int z)\n{\n\tint mh=0,mw=0;\n\tint ow,oh;\n\tfor(int j=i+1;j<n;j++)\n\t{\n\t\tif(s[j].x==s[i].x&&mh==0&&a[s[i].x]==1)\n\t\t{\n\t\t\tmh=s[j].z;\n\t\t\toh=j;\n\t\t}\n\t\tif(s[j].y==s[i].y&&mw==0&&b[s[i].x]==1)\n\t\t{\n\t\t\tmw=s[j].z;\n\t\t\tow=j;\n\t\t}\n\t\tif(mh!=0&&mw!=0) break;\n\t}\n\tcout<<mh<<\" \"<<mw<<endl;\n\tif(mh>mw)\n\t{\n\t\tb[s[i].y]--;\n\t\tcout<<s[i].z<<endl;\n\t\tsum+=(s[i].z);\n\t\tcnt++;\n\t}\n\telse if(mh<mw)\n\t{\n\t\ta[s[i].x]--;\n\t\tcout<<s[i].z<<endl;\n\t\tsum+=(s[i].z);\n\t\tcnt++;\n\t}\n\telse \n\t{\n\t\ta[s[i].x]--;\n\t\tb[s[i].y]--;\n\t\tcout<<s[i].z<<endl;\n\t\tsum+=(s[i].z);\n\t\tcout<<mh<<endl;\n\t\tsum+=(mh);\n\t\ts[ow].z=0;\n\t\tcnt+=2;\n\t}\n}*/\nint main()\n{\n\tcin>>n>>h>>w;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>s[i].x>>s[i].y>>s[i].z;\n\t}\n\tfor(int i=1;i<=h;i++) a[i]=1;\n\tfor(int i=1;i<=w;i++) b[i]=1;\n\tsort(s,s+n,cmpz);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint mh=0,mw=0;\n\t    int ow,oh;\n\t    if(s[i].z==0) continue;\n\t    for(int j=i+1;j<n;j++)\n\t    {\n\t\t    if(s[j].x==s[i].x&&mh==0&&a[s[i].x]==1)\n\t\t    {\n\t\t\t   mh=s[j].z;\n\t\t\t   oh=j;\n\t\t    }\n\t\t    if(s[j].y==s[i].y&&mw==0&&b[s[i].y]==1)\n\t\t    {\n\t\t\t    mw=s[j].z;\n\t\t\t    ow=j;\n\t\t    }\n\t\t    if(mh!=0&&mw!=0) break;\n\t    }\n\t    //cout<<mh<<\" \"<<mw<<endl;\n\t    if(a[s[i].x]==0&&b[s[i].y]==0) \n\t    { \n\t\t     continue;\n\t    }\n\t    else if((mh>mw&&b[s[i].y]==1)||(a[s[i].x]==0&&b[s[i].y]==1))\n\t    {\n\t\t    b[s[i].y]--;\n\t\t    //cout<<s[i].z<<endl;//\n\t\t    sum+=(s[i].z);\n\t\t    cnt++;\n\t    }\n\t    else if((mh<mw&&a[s[i].x]==1)||(a[s[i].x]==1&&b[s[i].y]==0))\n\t    {\n\t\t    a[s[i].x]--;\n\t\t    //cout<<s[i].z<<endl;//\n\t\t    sum+=(s[i].z);\n\t\t    cnt++;\n\t    }\n\t    else if(mh==mw&&b[s[i].y]==1&&a[s[i].x]==1)\n\t    {\n\t\t    a[s[i].x]--;\n\t\t    //cout<<s[i].z<<endl;//\n\t\t    sum+=(s[i].z);\n\t\t    cnt++;\n\t\t    //cout<<mh<<endl;//\n\t\t    if(mh!=0)\n\t\t\t{\n\t\t\t\tb[s[i].y]--;\n\t\t\t\tsum+=(mh);\n\t\t        s[ow].z=0;\n\t\t        cnt++;\n\t\t\t}\n\t    }\n\t    if(cnt==(h+w)) break;\n\t}\n\tcout<<sum<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \ntemplate <class T>inline T updmax(T& a, T b) {return a = max(a, b);}\ntemplate <class T>inline T updmin(T& a, T b) {return a = min(a, b);}\n\nclass UnionFind {\n\tvector<int> data, data2;\n\tpublic:\n\tUnionFind(int size) : data(size, -1), data2(size, 0) { }\n\tbool unionSet(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x != y) {\n\t\t\tif (data[y] < data[x]) swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t\tdata2[x] += data2[y]; data2[y] = 0;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findSet(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\tint root(int x) {\n\t\treturn data[x] < 0 ? x : data[x] = root(data[x]);\n\t}\n\tint size(int x) {\n\t\treturn -data[root(x)];\n\t}\n\tbool add(int x){\n\t\tif(-data[root(x)] > data2[root(x)]){\n\t\t\tdata2[root(x)]++;\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n};\n\nclass Solution {\npublic:\n\tvoid solve() {\n\t\tint n, h, w;\n\t\tcin >> n >> h >> w;\n\t\tusing cd = tuple<int, int, int>;\n\t\tvector<cd> cds(n);\n\t\tfor(int i=0; i < n; i++){\n\t\t\tint r, c, a;\n\t\t\tcin >> r >> c >> a;\n\t\t\tcds[i] = make_tuple(a, r-1, c-1);\n\t\t}\n\t\tsort(cds.begin(), cds.end(), greater<tuple<int, int, int>>());\n\t\tlong long ret = 0;\n\t\tUnionFind uf(h + w);\n\t\tfor(int i=0; i < n; i++){\n\t\t\tint a,r,c;\n\t\t\ttie(a,r,c) = cds[i];\n\t\t\tuf.unionSet(r, h+c);\n\t\t\tif(uf.add(r))ret += a;\n\t\t}\n\t\tcout << ret << \"\\n\";\n\t\treturn;\n\t};\n};\n \nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(nullptr);\n\tSolution solution;\n\tsolution.solve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#define vll vector<ll>\n#define vvvl vector<vvl>\n#define vvl vector<vector<ll>>\n#define VV(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define VVV(a, b, c, d) vector<vvl>(a, vvl(b, vll (c, d)));\n#define re(c, b) for(ll c=0;c<b;c++)\n#define all(obj) (obj).begin(), (obj).end()\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nstruct UF{\n  std::vector<int> par, dep, sz, dat;\n  UF(int n){\n    par.resize(n+1), dep.resize(n+1), sz.resize(n+1), dat.resize(n+1);\n    init(n);\n  }\n  void init(int nu) {\n    for(int iu=0;iu<=nu;iu++){\n      par[iu] = iu;\n      dep[iu] = 0;\n      sz[iu] = 1;\n      dat[iu] = 0;\n    }\n  }\n  int find(int xu){\n    if(par[xu] == xu) return xu;\n    return par[xu] = find(par[xu]);\n  }\n  void unite(int xu, int yu){\n    xu=find(xu);\n    yu=find(yu);\n    if(xu == yu) return;\n    if(dep[xu] < dep[yu]){\n      sz[yu] += sz[xu];\n      par[xu] = yu;\n      dat[yu] += dat[xu];\n    }else{\n      par[yu] = xu;\n      sz[xu] += sz[yu];\n      dat[xu] += dat[yu];\n      if(dep[xu] == dep[yu]) dep[xu]++;\n    }\n  }\n  bool same(int xu, int yu){ return find(xu) == find(yu);}\n  int get_size(int x){return sz[find(x)];}\n};\n\nint main(int argc, char const *argv[]) {\n  ll n, h, w;std::cin >> n >> h >> w;\n  UF uf(h+w+1);\n  vvl d = VV(n, 3, 0, ll);// num x y\n  for(int i=0;i<n;i++){\n    scanf(\"%lld %lld %lld\", &d[i][1], &d[i][2], &d[i][0]);\n    d[i][1]--;\n    d[i][2]--;\n  }\n  sort(all(d));\n  reverse(all(d));\n  ll ans = 0;\n\n  for(int i=0;i<n;i++){\n    ll x = d[i][1], y = d[i][2]+h;\n\n    if(uf.same(x, y)){\n      // 元から連結なら、辺が超えていないか確認\n      ll p = uf.find(x);\n      if(uf.dat[p]<uf.sz[p]){\n        ans += d[i][0];\n        uf.dat[p]++;\n      }\n    }else{\n      //違う場合、どちらかに余裕があればマージできる\n      ll px = uf.find(x);\n      ll py = uf.find(y);\n      if(uf.dat[px]<uf.sz[px]||uf.dat[py]<uf.sz[py]){\n        uf.unite(x, y);\n        ll p = uf.find(x);\n        ans += d[i][0];\n        uf.dat[p]++;\n      }\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n                    prayer\n*/\n\n// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(long long i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n#define show1d(v) {rep(_,v.size())cout<<\" \"<<v[_];cout<<endl;}\n#define show2d(v) {rep(__,v.size())show1d(v[__]);}\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\n#define yes cout<<\"Yes\\n\"\n#define no cout<<\"No\\n\"\n\nstruct edge{\n\tint to,cap,cost,rev;\n};\ntypedef vector<edge> ve;\ntypedef vector<ve> vve;\nclass MCF{\t//Minimum Cost Flow\n\tpublic:\n\tint n;\n\tvve G;\n\tvi h,dist,prev,pree;\n\tMCF(int size){\n\t\tn=size;\n\t\tG=vve(n);\n\t\th=dist=prev=pree=vi(n);\n\t}\n\tvoid add_edge(int s,int t,int ca,int co){\n\t\tedge e={t,ca,co,G[t].size()};\n\t\tG[s].pb(e);\n\t\tedge ee={s,0,-co,G[s].size()-1};\n\t\tG[t].pb(ee);\n\t}\n\tpii mcf(int s,int t,int f){\n\t\tint out=0;\n\t\th=vi(n);\n\t\twhile(f>0){\n\t\t\tpriority_queue<pii,vector<pii> >q;\n\t\t\tdist=vi(n,inf);\n\t\t\tdist[s]=0;\n\t\t\tq.push(pii(0,s));\n\t\t\twhile(!q.empty()){\n\t\t\t\tpii p=q.top();q.pop();\n\t\t\t\tint v=p.second;\n\t\t\t\tif(dist[v]<-p.first)continue;\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tedge &e=G[v][i];\n\t\t\t\t\tif(e.cap>0&&dist[e.to]>dist[v]+e.cost+h[v]-h[e.to]){\n\t\t\t\t\t\tdist[e.to]=dist[v]+e.cost+h[v]-h[e.to];\n\t\t\t\t\t\tprev[e.to]=v;\n\t\t\t\t\t\tpree[e.to]=i;\n\t\t\t\t\t\tq.push(pii(-dist[e.to],e.to));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(dist[t]==inf)return {f,out};\n\t\t\trep(i,n)h[i]+=dist[i];\n\t\t\tint d=f;\n\t\t\tfor(int v=t;v!=s;v=prev[v])d=min(d,G[prev[v]][pree[v]].cap);\n\t\t\tf-=d;\n\t\t\tout+=d*h[t];\n\t\t\tfor(int v=t;v!=s;v=prev[v]){\n\t\t\t\tedge &e=G[prev[v]][pree[v]];\n\t\t\t\te.cap-=d;\n\t\t\t\tG[v][e.rev].cap+=d;\n\t\t\t}\n\t\t}\n\t\treturn {0,out};\n\t}\n};\nsigned main(){\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tint n,h,w;\n\tcin>>n>>h>>w;\n\tMCF mcf(n+h+w+2);\n\tint s=n+h+w,t=s+1;\n\trep(i,n){\n\t\tint a,b,c;\n\t\tcin>>a>>b>>c;\n\t\tmcf.add_edge(s,i,1,100000-c);\n\t\tmcf.add_edge(i,n+a-1,1,0);\n\t\tmcf.add_edge(i,n+h+b-1,1,0);\n\t}\n\trep(i,h)mcf.add_edge(n+i,t,1,0);\n\trep(i,w)mcf.add_edge(n+h+i,t,1,0);\n\tpii f=mcf.mcf(s,t,n);\n\tcout<<(n-f.first)*100000-f.second<<endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\nusing namespace std;\ntypedef long long LL;\nint n, h, w;\nstruct NODE{\n\tLL a;\n\tint r, c;\n\tinline bool operator < (const NODE &tmp) const\n\t{\n\t\treturn a > tmp.a;\n\t}\n}t[100010];\nint fa[200010];\nLL val[200010];\n\nint find(int x)\n{\n\tif(x == fa[x]) return x;\n\treturn fa[x] = find(fa[x]);\n}\n\n\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &h, &w);\n\tfor (register int i = 1;i <= n;i ++) scanf(\"%d%d%lld\", &t[i].r, &t[i].c, &t[i].a);\n\tsort(t + 1, t + n + 1);\n\tfor (register int i = 1;i <= n;i ++)\n\t{\n\t\tfa[i] = i;\n\t\tval[i] = 1;\n\t}\n\tLL ans = 0;\n\tfor (register int i = 1;i <= n;i ++)\n\t{\n\t\tint xx = find(t[i].r), yy = find(t[i].c + h);\n\t\tif(xx == yy)\n\t\t{\n\t\t\tif(val[xx])\n\t\t\t{\n\t\t\t\tval[xx] --;\n\t\t\t\tans += t[i].a;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(val[xx] + val[yy])\n\t\t\t{\n\t\t\t\tval[xx] += val[yy];\n\t\t\t\tval[xx] --;\n\t\t\t\tfa[yy] = xx;\n\t\t\t\tans += t[i].a;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAXN = 200200;\nusing ll = long long;\n\nint N, H, W;\nint par[MAXN];\nint flag[MAXN];\nvector<tuple<int, int, int>> edges;\n\nint getPar(int v) {\n   if (v != par[v]) {\n      par[v] = getPar(par[v]);\n   }\n   return par[v];\n}\n\nbool merge(int v, int u) {\n   v = getPar(v);\n   u = getPar(u);\n   if (v == u) {\n      if (flag[v]) return false;\n      flag[v] = true;\n      return true;\n   }\n   if (flag[v] && flag[u]) return false;\n   par[u] = v;\n   flag[v] |= flag[u];\n   return true;\n}\n\nint main() {\n   ios_base::sync_with_stdio(false);\n   cin >> N >> H >> W;\n   for (int i = 0; i < N; ++i) {\n      int r, c, z;\n      cin >> r >> c >> z;\n      --r, --c; c += H;\n      edges.emplace_back(z, r, c);\n   }\n   iota(par, par + H + W, 0);\n   sort(edges.rbegin(), edges.rend());\n   ll ans = 0;\n   for (auto e : edges) {\n      if (merge(get<1>(e), get<2>(e))) {\n         ans += get<0>(e);\n      }\n   }\n   cout << ans << \"\\n\";\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<set>\n#include<map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\nconst int maxn=1e5+5;\nmap<P,int>mp; int tot=0; int d[maxn];\nint h, w, n;\nstruct node{\n    int x, y; ll val;\n    bool operator<(const node &g)const{\n        return val>g.val;\n    }\n}a[maxn]; int par[maxn*3], num1[maxn*3], num2[maxn*3];\nint fd(int x){\n    return par[x]==x?x:par[x]=fd(par[x]);\n}\nvoid unite(int x, int y){\n    x=fd(x); y=fd(y);\n    if(x==y) return;\n    par[x]=y; num1[y]+=num1[x]; num2[y]+=num2[x];\n}\nint main(){\n    scanf(\"%d%d%d\",&n,&h,&w); ll sum=0;\n    for(int i=1;i<=n+h+w;i++){\n        par[i]=i;\n        if(i>n) num2[i]=1;\n        else num1[i]=1;\n    }\n    for(int i=1;i<=n;i++){\n        scanf(\"%d%d%lld\",&a[i].x,&a[i].y,&a[i].val);\n    } sort(a+1,a+n+1);\n    for(int i=1;i<=n;i++){\n        int x=a[i].x; int y=a[i].y;\n        if(fd(x+n)!=fd(y+n+h)) unite(x+n,i), unite(x+n,y+n+h), sum+=a[i].val;\n        else{\n            int t=fd(x+n);\n            if(num1[t]<num2[t]) unite(x+n,i), unite(x+n,y+n+h), sum+=a[i].val;\n        }\n    }\n    printf(\"%lld\\n\",sum);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N,H,W;\n\nint R[101010],C[101010],A[101010];\nint ok[201010];\n\ntemplate<int um> class UF {\n\tpublic:\n\tvector<int> par,rank,cnt;\n\tUF() {par=rank=vector<int>(um,0); cnt=vector<int>(um,1); for(int i=0;i<um;i++) par[i]=i;}\n\tvoid reinit() {int i; FOR(i,um) rank[i]=0,cnt[i]=1,par[i]=i;}\n\tint operator[](int x) {return (par[x]==x)?(x):(par[x] = operator[](par[x]));}\n\tint count(int x) { return cnt[operator[](x)];}\n\tint operator()(int x,int y) {\n\t\tif((x=operator[](x))==(y=operator[](y))) return x;\n\t\tcnt[y]=cnt[x]=cnt[x]+cnt[y];\n\t\tif(rank[x]>rank[y]) return par[x]=y;\n\t\trank[x]+=rank[x]==rank[y]; return par[y]=x;\n\t}\n};\nUF<202020> uf;\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N>>H>>W;\n\tvector<vector<int>> V;\n\tFOR(i,N) {\n\t\tcin>>R[i]>>C[i]>>A[i];\n\t\tR[i]--;\n\t\tC[i]--;\n\t\tV.push_back({A[i],R[i],C[i]});\n\t}\n\tFOR(i,H) ok[i]=1;\n\tFOR(i,W) ok[H+i]=1;\n\t\n\tsort(ALL(V));\n\treverse(ALL(V));\n\tll ret=0;\n\tFORR(v,V) {\n\t\tint y=v[1];\n\t\tint x=v[2];\n\t\t\n\t\tif(ok[uf[y]]&&ok[uf[H+x]]) {\n\t\t\tif(uf[y]==uf[H+x]) {\n\t\t\t\tok[uf[y]]=0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tuf(y,H+x);\n\t\t\t}\n\t\t\tret+=v[0];\n\t\t}\n\t\telse if(ok[uf[y]]) {\n\t\t\tok[uf[y]]=0;\n\t\t\tret+=v[0];\n\t\t}\n\t\telse if(ok[uf[H+x]]) {\n\t\t\tok[uf[H+x]]=0;\n\t\t\tret+=v[0];\n\t\t}\n\t}\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define name \"bai5\"\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define fto(i,a,b) for(int i=a; i<=b;++i)\n#define maxn 100009\n#define ll long long\n\nusing namespace std;\nbool gone[maxn][3],ck[maxn][3];\nint cl[maxn];\nint xd[maxn][3],a[maxn][3],w,h,n;\npii b[maxn];\nbool check(int i, int x,int j){\n    //if(!ck[i][x]) return false;\n    if(gone[i][x])return ck[i][x]=false;\n    gone[i][x]=true;\n    if(xd[i][x]==0){\n        xd[i][x]=j;\n        gone[i][x]=false;\n        return true;\n    }\n    /// xd[i][x]!=0;\n    /// i,x la cot hoac hang, j la chi so can dien\n    int t=xd[i][x];/// t la so can dien\n    if(check(a[t][1-x],1-x,t)){\n        xd[i][x]=j;\n        gone[i][x]=false;\n        return true;\n    }\n    gone[i][x]=false;\n    return ck[i][x]=false;\n}\nint main()\n{\n    cin >> n >> h >> w;\n    fto(i,1,n){\n        cin >> a[i][0]>> a[i][1] >> b[i].fi;\n        b[i].se=i;\n        ck[i][0]=ck[i][1]=true;\n    }\n    sort(b+1,b+n+1,greater<pii> ());\n    ll res=0;\n    fto(i,1,n){\n        int j=b[i].se;\n        if(check(a[j][0],0,j)){\n            //xd[a[j][0]][0]=j;\n            res+=b[i].fi;\n        }\n        else if(check(a[j][1],1,j)){\n            //xd[a[j][1]][1]=j;\n            res+=b[i].fi;\n        }\n    }\n    cout << res ;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define maxn 100005\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> pii;\n#define mp make_pair\n#define pb push_back\n#define ff first\n#define ss second\n\nint n,w,h;\n\ninline int read(){\n    int x=0,f=1; char ch=getchar();\n    for (;ch<'0'||ch>'9';ch=getchar()) if (ch=='-') f=-1;\n    for (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n    return x*f;\n}\n\nstruct edge{\n\tint x,y,w; edge(){}\n\tedge(int _x,int _y,int _w){x=_x,y=_y,w=_w;}\n\tbool operator <(const edge &a)const{return w>a.w;}\n}e[maxn];\n\nstruct union_find_set{\n\tint fa[maxn<<1]; bool bo[maxn<<1];\n\tvoid init(){for (int i=1;i<=h+w;i++) fa[i]=i;}\n\tint find(int x){return fa[x]==x?x:fa[x]=find(fa[x]);}\n\tbool merge(int x,int y){\n\t\tx=find(x),y=find(y);\n\t\tif (x==y){if (bo[x]) return 0; else return bo[x]=1,1;}\n\t\tif (bo[x]&&bo[y]) return 0; fa[x]=y,bo[y]|=bo[x]; return 1;\n\t}\n}u;\n\nint main(){\n\tn=read(),h=read(),w=read(); u.init();\n\tfor (int i=1;i<=n;i++){\n\t\tint x=read(),y=read(),z=read();\n\t\te[i]=edge(x,y+h,z);\n\t}\n\tll ans=0; sort(e+1,e+n+1);\n\tfor (int i=1;i<=n;i++){\n\t\tint x=e[i].x,y=e[i].y,w=e[i].w;\n\t\tif (u.merge(x,y)) ans+=w;\n\t}\n\tprintf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long llong;\n\nconst int maxn=2*1e5+10;\n\nstruct edge{\nint x,y,d;\nbool operator < (const edge &e) const\n{\n    return d>e.d;\n}\n}a[maxn];\n\nint n,h,w,c[maxn],fa[maxn];\nint find(int x) {return x==fa[x]?x:fa[x]=find(fa[x]);}\n\nint main()\n{\n    scanf(\"%d%d%d\",&n,&h,&w);\n    for(int i=0;i<n;i++)\n        scanf(\"%d%d%d\",&a[i].x,&a[i].y,&a[i].d),a[i].y+=h;\n    sort(a,a+n);\n    for(int i=1;i<=h+w;i++) fa[i]=i,c[i]=1;\n    llong ans=0;\n    for(int i=0;i<n;i++)\n    {\n        int x=find(a[i].x),y=find(a[i].y);\n        if(x!=y) c[y]+=c[x],fa[x]=y;\n        if(c[y]) c[y]--,ans+=a[i].d;\n    }\n    cout<<ans<<endl;\n    return 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n#define REP(i,n) for(ll i=0;i<n;i++)\n#define REP1(i,n) for(ll i=1;i<=n;i++)\n#define FILL(i,n) memset(i,n,sizeof i)\n#define X first\n#define Y second\n#define ET cout << \"\\n\"\n#define SZ(_a) (int)_a.size()\n#define ALL(_a) _a.begin(),_a.end()\n#define pb push_back\n#define IOS() ios_base::sync_with_stdio(0);cin.tie(0);\n#ifdef bbq\n#define debug(...) {\\\n    fprintf(stderr,\"%s - %d (%s) = \",__PRETTY_FUNCTION__,__LINE__,#__VA_ARGS__);\\\n    _do(__VA_ARGS__);\\\n}\ntemplate<typename T>void _do(T &&_x){cerr<<_x<<endl;}\ntemplate<typename T,typename ...S> void _do(T &&_x,S &&..._t){cerr<<_x<<\", \";_do(_t...);}\ntemplate<typename _a,typename _b> ostream& operator << (ostream &_s,const pair<_a,_b> &_p){return _s<<\"(\"<<_p.X<<\",\"<<_p.Y<<\")\";}\n#else\n#define debug(...)\n#endif\n\nvector<int> G[100005];\nint mp[100005],mq[200005],fm[100005],vis[100005],nw;\n\nbool bfs(int u)\n{\n\t++nw;\n\tqueue<int> q;\n\tq.push(u),fm[u]=-1,vis[u]=nw;\n\twhile(!q.empty())\n\t{\n\t\tint p=q.front();\n\t\tq.pop();\n\t\tfor(int i:G[p])\n\t\t\tif(!~mq[i])\n\t\t\t{\n\t\t\t\tint ls=i;\n\t\t\t\twhile(~p)\n\t\t\t\t{\n\t\t\t\t\tint tmp=mp[p];\n\t\t\t\t\tmp[mq[ls]=p]=ls,p=fm[p],ls=tmp;\n\t\t\t\t}\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t\telse if(vis[mq[i]]<nw)\n\t\t\t\tq.push(mq[i]),vis[mq[i]]=nw;\n\t}\n}\n\nstruct mode\n{\n\tint r,c,v;\n\tbool operator<(const mode &a)const{\n\t\treturn v>a.v;\n\t}\n}arr[100005];\n\nint main()\n{\n\tIOS();\n\tll ans=0;\n\tint n,h,w;\n\tcin >> n >> h >> w;\n\tfor(int i=0;i<n;++i)\n\t\tcin >> arr[i].r >> arr[i].c >> arr[i].v,--arr[i].r,--arr[i].c;\n\tsort(arr,arr+n),FILL(mp,-1),FILL(mq,-1);\n\tfor(int i=0;i<n;++i)\n\t{\n\t\tG[i].pb(arr[i].r),G[i].pb(h+arr[i].c);\n\t\tif(bfs(i))\n\t\t\tans+=arr[i].v;\n\t}\n\tcout << ans << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct UnionFind{\n    int num;\n    vector<int> par,rank;\n    UnionFind(int n):num(n),par(n),rank(n,1){\n        iota(par.begin(),par.end(),0);\n    }\n    int root(int x){\n        if (par[x]==x) return x;\n        return par[x]=root(par[x]);\n    }\n    bool merge(int x, int y){\n        x=root(x),y=root(y);\n        if (x==y) return false;\n        if (rank[x]<rank[y]) swap(x,y);\n        par[y]=x;\n        rank[x]+=rank[y];\n        --num;\n        return true;\n    }\n    bool same(int x, int y){\n        return root(x)==root(y);\n    }\n    int size(int x){\n        return rank[root(x)];\n    }\n    int count(){\n        return num;\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int N,H,W; cin >> N >> H >> W;\n    UnionFind uf(H+W);\n    struct edge{\n        int r,c,a;\n        edge(int r,int c,int a):r(r),c(c),a(a){}\n        const bool operator<(const edge &rhs){\n            return a>rhs.a;\n        }\n    };\n    vector<edge> es;\n    for (int i=0;i<N;++i){\n        int R,C,A; cin >> R >> C >> A;\n        es.emplace_back(--R,--C+H,A);\n    }\n    sort(es.begin(),es.end());\n    vector<int> cycle(H+W,0);\n    ll ans=0;\n    for (int i=0;i<N;++i){\n        int p=uf.root(es[i].r),q=uf.root(es[i].c);\n        if (uf.merge(es[i].r,es[i].c)&&!(cycle[p]&&cycle[q])){\n            ans+=es[i].a;\n            cycle[p]|=cycle[q],cycle[q]|=cycle[p];\n        } else if (!cycle[p]){\n            ans+=es[i].a; cycle[p]=1;\n        }\n    }\n    cout << ans << '\\n';\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\n\nconst int MAXN = 3e5+10;\n\nint bit[MAXN];\nint par[MAXN];\nint parent(int i) {\n  return par[i] < 0 ? i: (par[i]=parent(par[i]));\n}\n\nbool merge(int a, int b) {\n  int x = parent(a);\n  int y = parent(b);\n  if (x==y) {\n    if (bit[x]) return false;\n    else return bit[x] = 1;\n  }\n  if (bit[x] && bit[y]) return false;\n  bit[x]+=bit[y];\n  bit[y] = x;\n  return 1;\n}\n\nint gc=0;\nmap<pair<int,int>, int> m;\nint gid(int r, int c) {\n  auto p = make_pair(r,c);\n  if (m.count(p)) {\n    return m[p];\n  }\n  else {\n    return  m[p] = gc++;\n  }\n}\n\nint n, h, w;\n\nint main(){\n  cin.tie(0); ios_base::sync_with_stdio(0);\n  cin >> n >> h >> w;\n  memset(par, -1,sizeof par);\n  vector<vector<int>> v;\n  for(int i=0;i<n;i++) {\n    int r, c, w;\n    cin >> r >> c >> w;\n    v.push_back({w,r,c});\n  }\n  sort(v.rbegin(), v.rend());\n  ll ans = 0;\n  for(auto p: v) {\n    if (merge(gid(p[1],0), gid(p[2],1))){\n      ans+=p[0];\n      //cerr << \"ADDING \" << p[1] << \" \" << p[2] << \" \" << p[0] <<endl;\n    }\n    //else //cerr << \"NOT ADDING \" << p[1] << \" \" << p[2] << \" \" << p[0] <<endl;\n  }\n  cout << ans <<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define all(v) (v).begin(), (v).end()\n#define sortv(v) sort(all(v))\n#define uniqv(v) (v).erase(unique(all(v)), (v).end())\n#define pb push_back\n#define FI first\n#define SE second\n#define lb lower_bound\n#define ub upper_bound\n#define mp make_pair\n#define test 1\n#define TEST if(test)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\nconst int MOD = 1000000007; // 998244353\nconst int INF = 2e9;\nconst ll INFLL = 1e18;\nconst int MAX_N = 100000;\n\nint N, H, W;\n\n\nstruct S{\n\tint x, y, d;\n\tbool operator <(const S &a)const{\n\t\treturn d<a.d;\n\t}\n};\nvector<S> v;\n\nll ans;\n\nvector<int> gp[MAX_N*2+1];\nbool chk[MAX_N*2+1];\n\nint g[MAX_N*2+1];\n\nvoid init_g(){\n\tfor(int i=2; i<=H+W; i++)\tg[i] = i;\n}\n\nint find_g(int x){\n\treturn (x==g[x])?x:g[x] = find_g(g[x]);\n}\n\nvoid union_g(int x, int y){\n\tx = find_g(x); y = find_g(y);\n\tg[x] = y;\n}\n\nvoid make(int x, int y){\n\tchk[x] = true;\n\tfor(int i : gp[x]){\n\t\tif(i!=y){\n\t\t\tmake(i, x);\n\t\t}\n\t}\n}\n\nint main(){\n\tcin>>N>>H>>W;\n\tinit_g();\n\tfor(int i=1; i<=N; i++){\n\t\tint a, b, c;\n\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\tv.pb((S){a, b+H, c});\n\t}\n\tsort(v.begin(), v.end());\n\twhile(!v.empty()){\n\t\tS now = v.back(); v.pop_back();\n\t\tif(chk[now.x] && !chk[now.y]){\n\t\t\tmake(now.y, 0);\n\t\t\tans+=(ll)now.d;\n\t\t}\n\t\telse if(!chk[now.x] && chk[now.y]){\n\t\t\tmake(now.x, 0);\n\t\t\tans+=(ll)now.d;\n\t\t}\n\t\telse if(!chk[now.x] && !chk[now.y]){\n\t\t\tif(find_g(now.x)==find_g(now.y)){\n\t\t\t\tmake(now.x, 0);\n\t\t\t}\n\t\t\tgp[now.x].pb(now.y);\n\t\t\tgp[now.y].pb(now.x);\n\t\t\tunion_g(now.x, now.y);\n\t\t\tans+=(ll)now.d;\n\t\t}\n\t}\n\tcout<<ans;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "///////////////////////////////////////////////////////////////////////////////\n\n#include <bits/stdc++.h>\n#include <unistd.h>\n#include <time.h>\n#include <sys/time.h>\n\nusing namespace std;\n\n///////////////////////////////////////////////////////////////////////////////\n\n#define DEBUG 0\n\n#define pb push_back\n#define V vector\n#define M unordered_map\n#define S static\n\n#define rep(i,n) for(ll i=0LL; i<n; ++i)\n#define srep(i,s,n) for(ll i=s; i<n; ++i)\n#define rrep(i,n) for(ll i=n-1LL; i>=0LL; --i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CIN(x) do { \\\n        assert(!cin.eof()); \\\n        cin >> x; \\\n        assert(!cin.fail()); \\\n} while(0);\n#if DEBUG\n#define debug_print(...) _debug_print(__VA_ARGS__)\n#define debug_printf(...) printf(__VA_ARGS__)\n#define debug_print_time _debug_print_time\n#else // DEBUG\n#define debug_print(...)\n#define debug_printf(...)\n#define debug_print_time\n#endif // DEBUG\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef tuple<ll, ll> t2;\ntypedef tuple<ll, ll, ll> t3;\ntypedef tuple<ll, ll, ll, ll> t4;\ntypedef tuple<ll, ll, ll, ll, ll> t5;\ntemplate <typename T>\nusing priority_queue_incr = priority_queue<T, V<T>, greater<T> >;\n\n///////////////////////////////////////////////////////////////////////////////\n\ntemplate <typename TT, typename T>\nT get_m(M<TT, T> &m, TT k, T default_value)\n{\n    if (m.find(k) == m.end()) return m[k] = default_value;\n    return m[k];\n}\n\ntemplate <typename TT, typename T>\nvoid incr_m(M<TT, T> &m, TT k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\ntemplate <typename TT, typename T>\nvoid incr_m(map<TT, T> &m, TT k)\n{\n    if (m.find(k) == m.end()) m[k] = 0;\n    m[k]++;\n}\n\nvoid llin(ll &a)\n{\n    CIN(a);\n}\n\nvoid llinl1(V<ll> &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a;\n        CIN(a);\n        v.push_back(a);\n    }\n}\n\nvoid llinl2(V<t2> &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b;\n        CIN(a >> b);\n        v.push_back(t2(a, b));\n    }\n}\n\nvoid llinl3(V<t3> &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b, c;\n        CIN(a >> b >> c);\n        v.push_back(t3(a, b, c));\n    }\n}\n\nvoid llinl4(V<t4> &v, ll count)\n{\n    for (ll i = 0LL; i < count; ++i) {\n        ll a, b, c, d;\n        CIN(a >> b >> c >> d);\n        v.push_back(t4(a, b, c, d));\n    }\n}\n\nvoid llina(V<ll> &v, ll count)\n{\n    llinl1(v, count);\n}\n\ntemplate <typename T>\nvoid sort(V<T> &v)\n{\n    sort(v.begin(), v.end());\n}\n\ntemplate <typename T>\nvoid sort_reverse(V<T> &v)\n{\n    sort(v.begin(), v.end(), greater<T>());\n}\n\ntemplate <typename T>\nvoid _debug_print(T x)\n{\n    cout << x << endl;\n}\n\nvoid _debug_print(const t2 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << endl;\n}\n\nvoid _debug_print(const t3 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2 << \" -- \" << x3 << endl;\n}\n\nvoid _debug_print(const t4 &x)\n{\n    ll x1 = get<0>(x);\n    ll x2 = get<1>(x);\n    ll x3 = get<2>(x);\n    ll x4 = get<3>(x);\n    cout << \"-- \" << x1 << \" -- \" << x2\n         << \" -- \" << x3 << \" -- \" << x4 << endl;\n}\n\ntemplate <typename T>\nvoid _debug_print(T xarray[], ll n)\n{\n    rep (i, n) _debug_print(xarray[i]);\n}\n\ntemplate <typename T>\nvoid _debug_print(const V<T> &xlist)\n{\n    for (auto x : xlist) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename T>\nvoid _debug_print(const set<T> &xset)\n{\n    for (auto x : xset) {\n        cout << \"-- \";\n        _debug_print(x);\n    }\n}\n\ntemplate <typename TT, typename T>\nvoid _debug_print(const M<TT, T> &xlist)\n{\n    for (auto x : xlist) {\n        TT k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\ntemplate <typename TT, typename T>\nvoid _debug_print(const map<TT, T> &xlist)\n{\n    for (auto x : xlist) {\n        TT k = x.first;\n        T v = x.second;\n        cout << \"====\" << endl;\n        cout << \"K=\";\n        _debug_print(k);\n        cout << \"V=\";\n        _debug_print(v);\n    }\n}\n\nvoid _debug_print_time(const char *prefix)\n{\n    struct timeval tv;\n    gettimeofday(&tv, NULL);\n#if DEBUG\n    struct tm *tm = localtime(&tv.tv_sec);\n#endif\n    debug_printf(\"-- %s %02d:%02d:%02d.%06ld\\n\",\n                  prefix, tm->tm_hour, tm->tm_min, tm->tm_sec, tv.tv_usec);\n}\n\n\n\nstruct UnionFind\n{\n    ull *parent, *count, *rank;\n\n    UnionFind(ull n) {\n        parent = new ull[n+1];\n        count = new ull[n+1];\n        rank = new ull[n+1];\n        for (ull i = 0ULL; i < n+1; ++i) {\n            parent[i] = i;\n            count[i] = 1;\n            rank[i] = 0;\n        }\n    }\n\n    ~UnionFind() {\n        delete rank;\n        delete count;\n        delete parent;\n    }\n\n    ull root(ull i) {\n        if (parent[i] == i) return i;\n        parent[i] = root(parent[i]);\n        return parent[i];\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (rank[rootj] < rank[rooti]) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] += count[rootj];\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] += count[rooti];\n            if (rank[rootj] == rank[rooti]) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\nstruct UnionFindM\n{\n    M<ull, ull> parent, count, rank;\n\n    ull root(ull i) {\n        ull parent_i = get_m(parent, i, i);\n        if (parent_i == i) return i;\n        return parent[i] = root(parent_i);\n    }\n\n    void unite(ull i, ull j) {\n        ull rooti = root(i);\n        ull rootj = root(j);\n\n        if (rooti == rootj) return;\n\n        if (get_m(rank, rootj, 0ULL) < get_m(rank, rooti, 0ULL)) {\n            parent[i] = parent[j] = parent[rootj] = rooti;\n            count[rooti] = get_m(count, rooti, 1ULL) + get_m(count, rootj, 1ULL);\n        }\n        else {\n            parent[i] = parent[j] = parent[rooti] = rootj;\n            count[rootj] = get_m(count, rootj, 1ULL) + get_m(count, rooti, 1ULL);\n            if (get_m(rank, rootj, 0ULL) == get_m(rank, rooti, 0ULL)) rank[rootj]++;\n        }\n    }\n\n    bool same(ull i, ull j) {\n        return root(i) == root(j);\n    }\n};\n\n\n\n\n///////////////////////////////////////////////////////////////////////////////\n\nvoid _main();\nint main()\n{\n    cout << setprecision(12);\n#if !DEBUG\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n\n    _main();\n    return 0;\n}\n\nll rtov(ll r)\n{\n    return r - 1LL;\n}\n\nll ctov(ll c)\n{\n    c--;\n    return c + (ll)1e5;\n}\n\nvoid _main()\n{\n    ll n; llin(n);\n    ll h; llin(h);\n    ll w; llin(w);\n    V<t3> rcalist; llinl3(rcalist, n);\n\n    V<t3> avvlist;\n    for (auto rca : rcalist) {\n        ll r = get<0>(rca);\n        ll c = get<1>(rca);\n        ll a = get<2>(rca);\n        ll v0 = rtov(r);\n        ll v1 = ctov(c);\n        avvlist.pb(t3(a, v0, v1));\n    }\n    sort_reverse(avvlist);\n\n    S UnionFind uf(200'010);\n    S bool loops[200'010] = {};\n    ll ans = 0;\n\n    for (auto avv : avvlist) {\n        ll a = get<0>(avv);\n        ll v0 = get<1>(avv);\n        ll v1 = get<2>(avv);\n        ll root0 = uf.root(v0);\n        ll root1 = uf.root(v1);\n\n        if (root0 != root1) {\n            if (loops[root0] && loops[root1]) continue;\n            uf.unite(v0, v1); ans += a;\n            ll newroot = uf.root(v0);\n            loops[newroot] = (loops[root0] || loops[root1]);\n            continue;\n        }\n\n        if (loops[root0]) continue;\n        uf.unite(v0, v1); ans += a;\n        loops[root0] = true;\n    }\n\n    cout << ans << endl;\n}\n\n///////////////////////////////////////////////////////////////////////////////\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fto(i,a,b) for(int i=a; i<=b; ++i)\n#define fdto(i,a,b) for(int i=a; i>=b; --i)\n#define pb push_back\n#define ll long long\n#define pii pair<int,int>\n#define st first\n#define nd second\n#define maxn 200005\n#define Ntu \"bai5\"\n\nusing namespace std;\n\nstruct edge{\n\tint u,v,w;\n};\n\nlong long rs=0;\nint par[maxn],ed[maxn]={},sz[maxn];\n\nint root(int u){\n\tif(par[u]!=u) return par[u]=root(par[u]);\n\treturn u;\n}\n\nvoid Merge(int u, int v, int w){\n\tint ru=root(u),rv=root(v);\n\tif(ru==rv){\n\t\tif(sz[ru]>ed[ru]){\n\t\t\ted[ru]++;\n\t\t\trs+=w;\n\t\t}\n\t}\n\telse{\n\t\tif(sz[ru]+sz[rv]>ed[ru]+ed[rv]){\n\t\t\tpar[rv]=ru;\n\t\t\tsz[ru]+=sz[rv];\n\t\t\ted[ru]+=ed[rv]+1;\n\t\t\trs+=w;\n\t\t}\n\t}\n}\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    //freopen(Ntu\".inp\",\"r\",stdin);\n    //freopen(Ntu\".out\",\"w\",stdout);\n    cin.tie(NULL);cout.tie(NULL);\n\tint p,h,w;\n\tcin >> p >> h >> w;\n\tfor(int i=0;i<h+w;i++){\n\t\tpar[i]=i;\n\t\tsz[i]=1;\n\t}\n\tvector <edge> e(p);\n\tfor(int i=0;i<p;i++)\n    {\n\t\tcin >> e[i].u >> e[i].v >> e[i].w;\n\t\te[i].u--;e[i].v--;\n\t}\n\tsort(e.begin(),e.end(),[](edge &a, edge &b)\n    {\n\t\treturn (a.w>b.w);\n\t});\n\tfor(int i=0;i<p;i++) Merge(e[i].u,h+e[i].v,e[i].w);\n\tcout << rs;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n//#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T& a, const T& b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T& a, const T& b) { if (b < a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\nstruct UnionFind {\n    vector<int> par; // uf(x,y)->y\n    UnionFind() {}\n    UnionFind(int NV) { init(NV); }\n    void init(int NV) { par.clear(); rep(i, 0, NV) par.push_back(i); }\n    void reset() { rep(i, 0, par.size()) par[i] = i; }\n    int operator[](int x) { return par[x] == x ? x : par[x] = operator[](par[x]); }\n    void operator()(int x, int y) { x = operator[](x); y = operator[](y); if (x != y) par[x] = y; }\n};\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧\n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     @hamayanhamayan\n　　　　／　　　＼　 　  |　|\n　　　 /　　 /￣￣￣￣/　　|\n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿\n　 　　　＼/＿＿＿＿/　（u　⊃\n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nint N, H, W;\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> N >> H >> W;\n    vector<pair<int,pair<int,int>>> E;\n    rep(i, 0, N) {\n        int y, x, a; cin >> y >> x >> a;\n        y--; x--;\n        E.push_back({a, {x, y + W}});\n    }\n\n    UnionFind uf(H + W + 1);\n    sort(all(E));\n    reverse(all(E));\n\n    ll ans = 0;\n    fore(p, E) {\n        int c = p.first;\n        int a = p.second.first;\n        int b = p.second.second;\n\n        if(uf[a] == uf[b]) {\n            if(uf[a] == uf[H + W]) continue;\n\n            ans += c;\n            uf(a, H + W);\n        } else {\n            ans += c;\n            uf(a, b);\n        }\n    }\n    cout << ans << endl;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\nconst int N = 1e5 + 5;\n\nint n, w, h;\nstruct edge { int u, v, w; } e[N];\nint fa[N << 1];\nbool ring[N << 1];\n\nint find(int x) {\n    return x == fa[x] ? x : fa[x] = find(fa[x]);\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin >> n >> w >> h;\n    for (int i = 1; i <= w + h; i++)\n        fa[i] = i, ring[i] = false;\n    for (int i = 1; i <= n; i++)\n        cin >> e[i].u >> e[i].v >> e[i].w;\n    \n    sort(e + 1, e + 1 + n, [](const edge& x, const edge& y) {\n        return x.w > y.w;\n    });\n\n    long long ans = 0ll;\n    for (int i = 1; i <= n; i++) {\n        int u = e[i].u, v = e[i].v + h, w = e[i].w;\n        u = find(u), v = find(v);\n\n        if (u == v) {\n            if (!ring[u]) ring[u] = 1, ans += w;\n        } else {\n            if (!ring[u] || !ring[v]) {\n                ring[u] = ring[v] = ring[u] | ring[v];\n                fa[u] = v, ans += w;\n            }\n        }\n    }\n\n    printf(\"%lld\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define PII pair<int, int>\n#define LL long long\nusing namespace std;\nconst int MAXN = 200005;\nconst LL MOD = 1000000007;\nconst LL INF = (LL) 1e9 + 5;\n\nstruct DSU {\n\tint pa[MAXN];\n\tbool fix[MAXN];\n\tint find(int x) {\n\t\treturn pa[x] == 0 ? x : pa[x] = find(pa[x]);\n\t}\n\tvoid merge(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tpa[y] = x;\n\t}\n} dsu;\n\nstruct Coin {\n\tint r, c, v;\n\tbool operator < (const Coin &c) const {\n\t\treturn v > c.v;\n\t}\n};\n\nint R, C, N;\nCoin coin[MAXN];\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\n\tcin >> N >> R >> C;\n\tfor (int i = 0; i < N; i++) {\n\t\tint r, c, v;\n\t\tcin >> r >> c >> v;\n\t\tcoin[i] = {r, c, v};\n\t}\n\t\n\tLL ans = 0;\n\tsort(coin, coin + N);\n\tfor (int i = 0; i < N; i++) {\n\t\tint x = dsu.find(coin[i].r), y = dsu.find(coin[i].c + R), v = coin[i].v;\n\t\tbool *fix = dsu.fix;\n\t\tif ((int) fix[x] + (int) fix[y] == 1) {\n\t\t\tans += v;\n\t\t\tdsu.merge(x, y);\n\t\t\tfix[x] = true;\n\t\t}\n\t\telse if (!fix[x] && !fix[y]) {\n\t\t\tans += v;\n\t\t\tif (x == y) {\n\t\t\t\tfix[x] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdsu.merge(x, y);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tcout << ans << '\\n';\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n#ifdef zxc\n\n#include <sys/resource.h>\n#include \"debug.h\"\n\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n\nusing ll = int64_t;\nusing ld = long double;\nconst ld EPS = 1e-9;\n//const ll MOD = 924844033;\nconst ld PI = 3.141592653589793;\nconst int maxn = 300001;\nconst ll MOD = 1e9 + 7;\n\nvoid fast_io() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(0);\n}\n\nll pw(ll a, ll b) {\n    ll res = 1;\n    for (; b; b >>= 1) {\n        if (b & 1) {\n            res = res * a % MOD;\n        }\n        a = a * a % MOD;\n    }\n    return res;\n}\n\nint used[maxn];\nint mt[maxn];\nint a[maxn];\nvector<int> g[maxn];\n\nint kuhn(int v) {\n    if (used[v]) {\n        return 0;\n    }\n    used[v] = 1;\n    for (int to:g[v]) {\n        if (mt[to] == -1) {\n            mt[to] = v;\n            return 1;\n        }\n    }\n    for (int to:g[v]) {\n        if (kuhn(mt[to])) {\n            mt[to] = v;\n            return 1;\n        }\n    }\n    return 0;\n}\n\nll weight_match(int n, int m, vector<int> order) {\n    ll ans = 0;\n    fill(mt, mt + m, -1);\n    for (int v:order) {\n        if (kuhn(v)) {\n            ans += a[v];\n            fill(used, used + n, 0);\n        }\n    }\n    return ans;\n}\n\nsigned main() {\n#ifdef zxc\n    struct rlimit rl;\n    const rlim_t kStackSize = 512L * 1024L * 1024L;\n    assert(!getrlimit(RLIMIT_STACK, &rl));\n    rl.rlim_cur = kStackSize;\n    assert(!setrlimit(RLIMIT_STACK, &rl));\n    freopen(\"../kolya_input.txt\", \"r\", stdin);\n//    freopen(\"../kolya_output.txt\", \"w\", stdout);\n#else\n    //    mt19937 mt(std::chrono::high_resolution_clock::now().time_since_epoch().count());\n    //            freopen(\"\", \"r\", stdin);\n    //        freopen(\"hack.out\", \"w\", stdout);\n#endif\n    auto solve = [](int _) {\n        int n, h, w;\n        cin >> n >> h >> w;\n        mt19937 mt(123);\n        vector<int> r(n), c(n);\n        for (int i = 1; i <= n; ++i) {\n            for (auto x:{r.data(), c.data(), a}) {\n                cin >> x[i - 1];\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            g[i].push_back(r[i] - 1);\n            g[i].push_back(c[i] + h - 1);\n            shuffle(g[i].begin(), g[i].end(), mt);\n        }\n        vector<int> p(n);\n        iota(p.begin(), p.end(), 0);\n        sort(p.begin(), p.end(), [&](int x, int y) {\n            return a[x] > a[y];\n        });\n        auto ans = weight_match(n, h + w, p);\n        cout << ans;\n    };\n\n\n    fast_io();\n    cout.precision(9);\n    cout << fixed;\n    auto start = chrono::steady_clock::now();\n    for (int i = 1; i <= 1; ++i)solve(i);\n    auto end = chrono::steady_clock::now();\n\n    debug(\"time\", chrono::duration_cast<chrono::milliseconds>(end - start).count() / 1000.0);\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\ntypedef long long ll;\n#define inf 0x3f3f3f3f\nint n,h,w;\nint x[maxn],y[maxn];\nll a[maxn];\nset<pair<ll,int> > qx[maxn],qy[maxn];\nvector<pair<ll,int> >cards;\nll ax,ay;\nbool ux[maxn],uy[maxn],usd[maxn];\nint cx[maxn],cy[maxn];\nqueue<int> que;\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&h,&w);\n//\tmemset(cx,-1,sizeof(cx));\n//\tmemset(cy,-1,sizeof(cy));\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%lld\",&x[i],&y[i],&a[i]);\n\t\tx[i]--;\n\t\ty[i]--;\n\t\tcx[x[i]]++;\n\t\tcy[y[i]]++;\n\t}\n    ll ans=0;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tif(cx[x[i]]==1||cy[y[i]]==1)\n\t\t\tque.push(i);\n\t\telse\n\t\t{\n\t\t\tqx[x[i]].insert(make_pair(a[i],i));\n\t\t\tqy[y[i]].insert(make_pair(a[i],i));\n\t\t}\n\t}\n\twhile(!que.empty())\n\t{\n\t\tint cur=que.front();\n\t\tque.pop();\n\t\tusd[cur]=1;\n\t\tans+=a[cur];\n\t\tusd[cur]=1;\n\t\tcx[x[cur]]--;\n\t\tcy[y[cur]]--;\n\t\tif(cx[x[cur]]==1)\n\t\t{\n\t\t\tif(!qx[x[cur]].empty())\n\t\t\t{\n\t\t\t\tpair<ll,int> he=*(qx[x[cur]].begin());\n\t\t\t\tqx[x[cur]].clear();\n\t\t\t\tint id=he.second;\n\t\t\t\tque.push(id);\n\t\t\t\tqy[y[id]].erase(he);\n\t\t\t}\n\t\t}\n\t\tif(cy[y[cur]]==1)\n\t\t{\n\t\t\tif(!qy[y[cur]].empty())\n\t\t\t{\n\t\t\t\tpair<ll,int> he=*(qy[y[cur]].begin());\n\t\t\t\tqy[y[cur]].clear();\n\t\t\t\tint id=he.second;\n\t\t\t\tque.push(id);\n\t\t\t\tqx[x[id]].erase(he);\n\t\t\t}\n\t\t}\n\t}\n//\tcout<<ans<<endl;\n\tfor(int i=0;i<n;i++)if(!usd[i])\n\t\tcards.push_back(make_pair(a[i],i));\n\t\t\n    sort(cards.begin(),cards.end());\n    reverse(cards.begin(),cards.end());\n    for(int _=0;_<cards.size();_++)\n    {\n    \tint i=cards[_].second;\n\t//\tcout<<i<<\" \"<<x[i]<<\" \"<<y[i]<<\" \"<<qx[x[i]].top().second<<\" \"<<qy[y[i]].top().second<<endl;\n        qx[x[i]].erase(make_pair(a[i],i));\n        qy[y[i]].erase(make_pair(a[i],i));\n        if(ux[x[i]]&&uy[y[i]])continue;\n        if(ux[x[i]])\n        \tuy[y[i]]=1;\n        else if(uy[y[i]])\n        \tux[x[i]]=1;\n        else\n\t\t{\n\t\t\tax=qx[x[i]].empty()?-inf:(*(qx[x[i]].rbegin())).first;\n\t\t\tay=qy[y[i]].empty()?-inf:(*(qy[y[i]].rbegin())).first;\n\t\t\tif(ax<ay)\n\t\t\t{\n        //   \tcout<<\"puthang \"<<x[i]<<endl;\n            \tux[x[i]]=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n      \t//    \tcout<<\"putlie \"<<y[i]<<endl;\n \t    \t\tuy[y[i]]=1;\n \t    \t}\n        }\n        ans+=a[i];\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 2e5 + 10;\nstruct edge\n{\n\tint u, v, w;\n}e[maxn];\nbool cmp(const edge & a, const edge & b) { return a.w > b.w;} \ntypedef long long ll;\nll ans;\nint n, h, w, tot;\nint fa[maxn];\nbool vis[maxn];\nint getfa(int x) { return x == fa[x] ? x : fa[x] = getfa(fa[x]);}\nint main()\n{\n\tscanf(\"%d%d%d\", &n, &h, &w);\n\ttot = h + w;\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tscanf(\"%d%d%d\", &e[i].u, &e[i].v, &e[i].w);\n\t\te[i].v += h;\n\t}\n\tsort(e + 1, e + n + 1, cmp);\n\tfor(int i = 1; i <= tot; ++i) fa[i] = i;\n\tfor(int i = 1; i <= n; ++i)\n\t{\n\t\tint fu = getfa(e[i].u);\n\t\tint fv = getfa(e[i].v);\n\t\tif(vis[fu] && vis[fv]) continue;\n\t\tif(vis[fv]) swap(fu, fv);\n\t\tif(fu == fv)\n\t\t{\n\t\t\tif(!vis[fu])\n\t\t\t{\n\t\t\t\tvis[fu] = 1;\n\t\t\t\tans += e[i].w;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfa[fv] = fu;\n\t\t\tans += e[i].w;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"avx2\")\n#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <random>\n#include <chrono>\n#include <tuple>\n#include <random>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\n#define fastInp cin.tie(0); cout.tie(0); ios_base::sync_with_stdio(0);\n\nconst int maxn = 2e5 + 10, snd = 1e5 + 10;\n\nvector<int> g[maxn];\nint mt[maxn];\nint used[maxn];\nint cn = 1;\nvector<ll> prm = { 0, 1 };\nll dsu[maxn * 2], sz[maxn * 2];\npair<ll, ll> c3[maxn * 2];\n\nll find(int v) {\n\tif (dsu[v] == v) return v;\n\telse return dsu[v] = find(dsu[v]);\n}\n\nvoid uni(int v, int u) {\n\tu = find(u);\n\tv = find(v);\n\n\tif (sz[u] > sz[v]) swap(u, v);\n\tif (u != v) {\n\t\tdsu[u] = v;\n\t\tsz[v] += sz[u];\n\t\tc3[v].first += c3[u].first;\n\t\tc3[v].second += c3[u].second;\n\t}\n}\n\nbool dfs(int v) {\n\tif (used[v] == cn) return false;\n\n\tused[v] = cn;\n\n\tll rnd = rand() % 2;\n\tif (rnd == 1) {\n\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\tint u = g[v][i];\n\t\t\tif (mt[u] == -1 || dfs(mt[u])) {\n\t\t\t\tmt[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\tfor (int i = 0; i < g[v].size(); i++) {\n\t\t\tint u = g[v][1 - i];\n\t\t\tif (mt[u] == -1 || dfs(mt[u])) {\n\t\t\t\tmt[u] = v;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t}\n\n\n\treturn false;\n}\n\nvector<tuple<ll, ll, ll>> rcnt[snd];\nint main()\n{\n\tfastInp;\n\n\tll n, h, w;\n\tcin >> n >> h >> w;\n\n\tll vals = 0, ans = 0;\n\tvector<tuple<ll, ll, ll>> vec;\n\tfor (int i = 0; i < n; i++) {\n\t\tdsu[i] = i;\n\t\tc3[i] = { 1, 0 };\n\t\tsz[i] = 1;\n\t}\n\n\tfor (int i = n; i < n + h; i++) {\n\t\tdsu[i] = i;\n\t\tc3[i] = { 0, 1 };\n\t\tsz[i] = 1;\n\t}\n\tfor (int i = n + h; i < n + h + w; i++) {\n\t\tdsu[i] = i;\n\t\tc3[i] = { 0, 1 };\n\t\tsz[i] = 1;\n\t}\n\n\tfor (int i = 0; i < n; i++) {\n\t\tll r, c, a;\n\t\tcin >> r >> c >> a;\n\t\tr--; c--;\n\t\trcnt[a].push_back({ a, r, c });\n\t}\n\n\tfor (int i = snd - 1; i >= 0; i--) {\n\t\tfor (auto cur : rcnt[i]) vec.push_back(cur);\n\t}\n\n\tll cnt = 0;\n\tll hw = h + w;\n\tfor (int i = 0; i < n; i++) {\n\t\tll r = get<1>(vec[i]), c = get<2>(vec[i]), a = get<0>(vec[i]);\n\t\tr += n;\n\t\tc += h + n;\n\t\tr = find(r);\n\t\tc = find(c);\n\t\tif (c == r) {\n\t\t\tif (min(c3[c].first + 1ll, c3[c].second) > min(c3[c].first, c3[c].second)) {\n\t\t\t\tans += a;\n\t\t\t\tuni(c, i);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (min(c3[c].first, c3[c].second) + min(c3[r].first, c3[r].second) < min(c3[c].first + c3[r].first + 1ll, c3[c].second + c3[r].second)) {\n\t\t\t\tans += a;\n\t\t\t\tuni(c, i);\n\t\t\t\tc = find(c);\n\t\t\t\tuni(c, r);\n\t\t\t}\n\t\t}\n\t\t/*if (mt[r] == -1 || mt[c + h + 1] == -1) {\n\t\t\tvals++;\n\t\t\tcnt++;\n\t\t\tg[i].push_back(r);\n\t\t\tg[i].push_back(c + h + 1);\n\t\t\tif (mt[r] == -1) {\n\t\t\t\tmt[r] = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmt[c + h + 1] = i;\n\t\t\t}\n\t\t\tans += a;\n\t\t\tcontinue;\n\t\t}\n\t\tcn++;\n\t\tvals++;\n\n\t\tg[i].push_back(r);\n\t\tg[i].push_back(c + h + 1);\n\t\tcnt += dfs(i);\n\n\t\tif (cnt >= vals) {\n\t\t\tans += a;\n\t\t\tcontinue;\n\t\t}\n\t\telse {\n\t\t\tvals--;\n\t\t}*/\n\t}\n\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct Card {\n  int r, c, a;\n  Card(int r, int c, int a) : r(r), c(c), a(a) {}\n};\n\nbool comp(const Card &A, const Card &B){\n  return A.a < B.a;\n}\n\nint main(){\n  int N, H, W;\n  cin >> N >> H >> W;\n  vector<Card> C;\n  for(int i = 0; i < N; ++i){\n    int r, c, a;\n    cin >> r >> c >> a;\n    --r,--c;\n    C.emplace_back(r,c,a);\n  }\n  sort(C.rbegin(), C.rend(), comp);\n  vector<int> H_(H,-1), W_(W,-1);\n  for(int i = 0; i < N; ++i){\n    int r = C[i].r, c = C[i].c, a = C[i].c;\n    if(H_[r] < 0) H_[r] = i;\n    else{\n      int idx = H_[r];\n      if(W_[C[idx].c] == idx) H_[r] = i;\n    }\n    if(W_[c] < 0) W_[c] = i;\n    else{\n      int idx = W_[c];\n      if(H_[C[idx].r] == idx) W_[c] = i;\n    }\n  }\n  set<int> S;\n  for(auto h : H_) S.insert(h);\n  for(auto w : W_) S.insert(w);\n  long long ans = 0;\n  for(auto idx : S){\n    if(idx < 0) continue;\n    ans += C[idx].a;\n  }\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#define vv(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define vvi vector<vector<int> >\n#define vvl vector<vector<ll> >\n#define vl vector<ll>\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nvector<bool> used(300000, false);\nstruct edge{ll to, cost, n;};\nvector<vector<edge> > G(300000);\nvvl lis = vv(300000, 0, 0, ll);\n\nvoid dfs(ll now, ll c){\n  if(used[now]) return;\n  lis[c].push_back(now);\n  used[now] = true;\n  for(int i=0;i<G[now].size();i++) dfs(G[now][i].to, c);\n}\nint main(int argc, char const *argv[]) {\n  ll N, H, W, a, b, c, ans = 0;\n  std::cin >> N >> H >> W;\n  for(int i=0;i<N;i++){\n    std::cin >> a >> b >> c;\n    G[a].push_back(edge{b+100001, -c, i});\n    G[b+100001].push_back(edge{a, -c, i});\n  }\n  for(int i=0;i<300000;i++) if(!used[i]) dfs(i, i);\n  std::vector<bool> us(300000, false), eg(300000, false);\n\n  for(int i=0;i<300000;i++){\n    if(lis[i].size()<=1) continue;\n\n    vvl e = vv(0, 4, 0, ll);\n    for(int j=0;j<lis[i].size();j++){\n      for(int k=0;k<G[lis[i][j]].size();k++){\n        e.push_back(vl{G[lis[i][j]][k].cost, G[lis[i][j]][k].n, lis[i][j], G[lis[i][j]][k].to});\n      }\n    }\n    ll v = 0, t = 0;\n    sort(e.begin(), e.end());\n    for(int j=0;j<e.size();j++){\n      if(eg[e[j][1]]) continue;\n      ll tmp = (!us[e[j][2]]?1:0) + (!us[e[j][3]]?1:0);\n      if(v + tmp > t){\n        t++;\n        v += tmp;\n        eg[e[j][1]] = us[e[j][2]] = us[e[j][3]] = true;\n        ans -= e[j][0];\n      }\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\n// Verified: AOJ-DSL1A\nclass UFSet {\n private:\n  vector<int> ranks;\n  vector<int> prevs;\n\n public:\n  UFSet(int n) : ranks(n), prevs(n) {\n    for (int i = 0; i < n; i++) prevs[i] = i;\n  }\n\n  // Returns a root of a tree which x belongs to.\n  int Find(int x) {\n    if (x != prevs[x]) prevs[x] = Find(prevs[x]);\n    return prevs[x];\n  }\n\n  // Merges a set which x blongs to and a set which y belongs to.\n  void Union(int x, int y) {\n    int x_root = Find(x);\n    int y_root = Find(y);\n    if (ranks[x_root] > ranks[y_root]) {\n      prevs[y_root] = prevs[x_root];\n    } else if (ranks[x_root] < ranks[y_root]) {\n      prevs[x_root] = prevs[y_root];\n    } else if (prevs[x_root] != prevs[y_root]) {\n      prevs[y_root] = prevs[x_root];\n      ranks[x_root]++;\n    }\n  }\n};\n\nstruct WeightedEdge {\n  int v1, v2;\n  int64 weight;\n  WeightedEdge(int v1, int v2, int64 weight)\n      : v1(v1), v2(v2), weight(weight) {}\n};\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n\n  int n, h, w;\n  cin >> n >> h >> w;\n  vector<WeightedEdge> edges;\n  for (int i = 0; i < n; i++) {\n    int r, c;\n    int64 weight;\n    cin >> r >> c >> weight;\n    r--;\n    c--;\n    edges.emplace_back(r, h + c, weight);\n  }\n  sort(edges.begin(), edges.end(), [](const auto& e1, const auto& e2) {\n    return e1.weight > e2.weight;\n  });\n\n  UFSet uf_set(h + w);\n  vector<int> has_cycle_vector(h + w);\n  int64 answer;\n  for (const auto& e : edges) {\n    int s1 = uf_set.Find(e.v1);\n    int s2 = uf_set.Find(e.v2);\n    if (s1 != s2) {\n      if (has_cycle_vector[s1] && has_cycle_vector[s2]) continue;\n      int new_has_cycle = has_cycle_vector[s1] || has_cycle_vector[s2];\n      uf_set.Union(e.v1, e.v2);\n      int s3 = uf_set.Find(e.v1);\n      has_cycle_vector[s3] = new_has_cycle;\n      answer += e.weight;\n    } else {\n      if (has_cycle_vector[s1]) continue;\n      has_cycle_vector[s1] = true;\n      answer += e.weight;\n    }\n  }\n  cout << answer << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long \n#define nn 206008\nint n;\nstruct edge{\n\tint x,y,c;\n};\nbool operator<(edge a,edge b){\n\treturn a.c>b.c;\n}\nedge e[nn];\n\nint pa[nn];\nint find(int x){\n\tif(pa[x]==x) return x;\n\treturn pa[x]=find(pa[x]);\n}\nint w,h;int loop[nn];\nint used[nn];\n\nsigned main()\n{\n\tfor(int i=0;i<nn;i++) pa[i]=i;\n\tscanf(\"%lld%lld%lld\",&n,&h,&w);int ans=0;\n\tfor(int i=1;i<=n;i++) scanf(\"%lld%lld%lld\",&e[i].x,&e[i].y,&e[i].c),e[i].y+=nn/2-1;\n\tsort(e+1,e+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tint x=e[i].x,y=e[i].y;//\n\t\tif(find(x)==find(y)) {\n\t\t\tif(loop[find(x)]==0) loop[find(x)]=1,ans+=e[i].c;\n\t\t\tcontinue;\n\t\t}\n\t\tif(loop[find(x)]&loop[find(y)]) continue;\n\t\tloop[find(y)]|=loop[find(x)];\n\t\tpa[find(x)]=find(y);\n\t\tans+=e[i].c;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\nconst int MAXN = 100000;\nstruct node{\n    int R, C, A;\n    friend bool operator < (node a, node b) {\n        return a.A < b.A;\n    }\n}nd[MAXN + 5];\nint fa[2*MAXN + 5], key[2*MAXN + 5], siz[2*MAXN + 5];\nint find(int x) {\n    return fa[x] = (fa[x] == x ? x : find(fa[x]));\n}\nint N, H, W;\nint main() {\n    long long ans = 0;\n    scanf(\"%d%d%d\", &N, &H, &W);\n    for(int i=1;i<=H;i++) fa[i] = i, siz[i] = 1, key[i] = 0;\n    for(int i=1;i<=W;i++) fa[i + H] = i + H, siz[i + H] = 1, key[i + H] = 0;\n    for(int i=1;i<=N;i++)\n        scanf(\"%d%d%d\", &nd[i].R, &nd[i].C, &nd[i].A);\n    sort(nd + 1, nd + N + 1);\n    for(int i=N;i>=1;i--) {\n        int fx = find(nd[i].R), fy = find(nd[i].C + H);\n        if( fx == fy ) {\n            if( siz[fx] >= key[fx] + 1 ) {\n                key[fx]++;\n                ans += nd[i].A;\n            }\n        }\n        else {\n            if( siz[fx] + siz[fy] >= key[fx] + key[fy] + 1 ) {\n                siz[fx] += siz[fy], key[fx] += key[fy] + 1, fa[fy] = fx;\n                ans += nd[i].A;\n            }\n        }\n    }\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\ninline ll read() {ll x = 0;char ch = getchar(), w = 1;while(ch < '0' || ch > '9') {\nif(ch == '-') w = -1;ch = getchar();}while(ch >= '0' && ch <= '9') {x = x * 10 + ch - '0';ch = getchar();\n}return x * w;}\nvoid write(ll x) {if(x < 0) putchar('-'), x = -x;if(x > 9) write(x / 10);putchar(x % 10 + '0');}\ninline void writeln(ll x) {write(x);puts(\"\");}\nusing namespace std;\nconst int N = 3e5 + 6;\nint n;\nint h, w;\nstruct T {\n\tint l, r, v;\n}a[N];\nbool cmp(T x, T y) {\n\treturn x. v > y.v;\n}\nint g[N], fa[N];\nint Find(int x) {\n\treturn fa[x] == x? x : fa[x] = Find(fa[x]);\n}\nint check(int x, int y) {\n\tx = Find(x), y = Find(y);\n\tif(x == y) {\n\t\tif(g[x]) {\n\t\t\t--g[x];\n\t\t\treturn 1;\n\t\t} \n\t\treturn 0;\n\t}\n\tfa[x] = y;\n\tg[y] += g[x];\n\tif(g[y] == 0) return 0;\n\t--g[y];\n\treturn 1;\n}\nint main() {\n\tn = read(), h = read(), w = read();\n\tfor(int i = 1; i <= n; ++i) {\n\t\ta[i].l = read();\n\t\ta[i].r = read();\n\t\ta[i].v = read();\n\t}\n\tll ans = 0;\n\tsort(a + 1, a + 1 + n, cmp);\n\tfor(int i = 1; i <= h + w; ++i) fa[i] = i, g[i] = 1;\n\tfor(int i = 1; i <= n; ++i) if(check(a[i].l, a[i].r + h)){\n\t\tans += a[i].v;\n\t}\n\twriteln(ans);\n \treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n#define pb push_back\n#define sz(x) ((int)x.size())\n#define all(x) x.begin(), x.end()\nusing pii=pair<int, int>;\nusing ll=long long;\n\nconst int mn = 2e5 + 5;\nconst int mod = 1e9 + 7;\nint n, h, w;\n\nvoid bye() {\n    puts(\"0\");\n    exit(0);\n}\n\nint col[mn], row[mn]; // 0 not vis / 1 not sure / 2 sure\nint colcho[mn], rowcho[mn];\n\nstruct node {\n    int col, row;\n    int value;\n    int id;\n\n    bool operator<(const node &p) const {\n        return value < p.value;\n    }\n};\n\nvector<node> g;\n\nbool notvis(int x) {\n    return !x;\n}\n\nbool notsure(int x) {\n    return x == 1;\n}\n\nbool dfs(int which, int x) { // which 1 col / 2 row\n    //printf(\"dfs %d %d \", which, x);\n    if (which == 1) { // col\n        //     printf(\"%d\\n\", col[x]);\n        if (col[x] == 0) {\n            col[x] = 2;\n            return 1;\n        } else if (col[x] == 2) return 0;\n\n        node &p = g[colcho[x]];\n        col[x] = 2;\n        return dfs(2, p.row);\n    } else {\n        //     printf(\"%d\\n\", row[x]);\n        if (row[x] == 0) {\n            row[x] = 2;\n            return 1;\n        } else if (row[x] == 2) return 0;\n        node &p = g[rowcho[x]];\n        row[x] = 2;\n        return dfs(1, p.col);\n    }\n    return 0;\n}\n\nint main() {\n    //cin.sync_with_stdio(0);\n#ifdef trote\n    freopen(\"../1.txt\", \"r\", stdin);\n#endif\n    scanf(\"%d%d%d\", &n, &h, &w);\n    for (int i = 1; i <= n; i++) {\n        int u, v, c;\n        scanf(\"%d%d%d\", &u, &v, &c);\n        g.pb({u, v, c});\n    }\n    sort(all(g));\n    for (int i = 0; i < sz(g); i++) {\n        g[i].id = i;\n    }\n    ll ans = 0;\n    for (int i = sz(g) - 1; i >= 0; i--) {\n        node &p = g[i];\n        if (notvis(col[p.col])) {\n            if (notvis(row[p.row]))\n                col[p.col] = 1;\n            else if (notsure(row[p.row])) {\n                col[p.col] = 1;\n            } else col[p.col] = 2;\n            colcho[p.col] = p.id;\n            //printf(\"try col %d %d\\n\", p.col, p.row);\n        } else if (notvis(row[p.row])) {\n            if (notsure(col[p.col])) {\n                row[p.row] = 1;\n            } else row[p.row] = 2;\n            rowcho[p.row] = p.id;\n            //printf(\"try row %d %d\\n\", p.col, p.row);\n        } else if (notsure(col[p.col])) {\n            if (!dfs(1, p.col)) continue;\n            col[p.col] = 2;\n            colcho[p.col] = p.id;\n        } else if (notsure(row[p.row])) {\n            if (!dfs(2, p.row)) continue;\n            row[p.row] = 2;\n            rowcho[p.row] = p.id;\n        } else continue;\n\n        ans += p.value;\n        /*for (int i = 1; i <= h; i++) {\n            printf(\"%d \", col[i]);\n        }\n        puts(\"\");\n        for (int i = 1; i <= w; i++) {\n            printf(\"%d \", row[i]);\n        }\n        puts(\"\");\n         */\n    }\n\n    printf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n#include <array>\n# include <cassert>\n#include <cctype>\n#include <climits>\n#include <numeric>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <tuple>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n# include <chrono>\n# include <random>\n# include <limits.h>\n# include <unordered_map>\n# include <unordered_set>\n# include <deque>\n# include <cstdio>\n# include <cstring>\n#include <stdio.h>\n#include<time.h>\n#include <stdlib.h>\n#include <cstdint>\n#include <cfenv>\n#include<fstream>\n//#include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nlong long MOD = 1000000000 + 7;\nconstexpr long long INF = numeric_limits<LL>::max() / 2;\nconst double PI = acos(-1);\n#define fir first\n#define sec second\n#define thi third\n#define debug(x) cerr<<#x<<\": \"<<x<<'\\n'\ntypedef pair<LL, LL> Pll;\ntypedef pair<LL, pair<LL, LL>> Ppll;\ntypedef pair<LL, pair<LL, bitset<100001>>> Pbll;\ntypedef pair<LL, pair<LL, vector<LL>>> Pvll;\ntypedef pair<LL, LL> Vec2;\nstruct Tll { LL first, second, third; };\nstruct Fll { LL first, second, third, fourd; };\ntypedef pair<LL, Tll> Ptll;\n#define rep(i,rept) for(LL i=0;i<rept;i++)\n#define Rrep(i,mf) for(LL i=mf-1;i>=0;i--)\nvoid YN(bool f) {\n\tif (f)\n\t\tcout << \"YES\" << endl;\n\telse\n\t\tcout << \"NO\" << endl;\n}\nvoid yn(bool f) {\n\tif (f)\n\t\tcout << \"Yes\" << endl;\n\telse\n\t\tcout << \"No\" << endl;\n}\nstruct Edge { LL to, cost; };\nstruct edge { LL from, to, cost; };\nvector<vector<LL>>g;\nvector<edge>edges;\nvector<Pll>v;\nmap<Pll, Pll>ma;\nset<LL>st;\nLL h, w, n, m, k, t, s, p, q, last, cnt, sum, ans, a[1000][1000], b[210000];\nstring str, ss;\nbool f;\nchar c;\nint di[4][2] = { { 0,1 },{ 1,0 },{ 0,-1 },{ -1,0 } };\nbool namori[300000] = {};\nstruct QuickFind {\n\tvector<int> gi; //親\n\tvector<vector<int>> vg; //併合した後削除する\n\tvector<vector<int>> tg; //併合した後削除しない\n\tint n;\n\n\tQuickFind(int size) : n(size) {\n\t\tgi.resize(n);\n\t\tvg.resize(n);\n\t\ttg.resize(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tgi[i] = i;\n\t\t\tvg[i].push_back(i);\n\t\t\ttg[i].push_back(i);\n\t\t}\n\t}\n\tbool same_group(int a, int b) {\n\t\treturn gi[a] == gi[b];\n\t}\n\tvoid merge(int a, int b) {\n\t\tint ga = gi[a];\n\t\tint gb = gi[b];\n\t\tif (ga == gb) return;\n\t\tif (vg[ga].size() < vg[gb].size()) swap(ga, gb);\n\t\tfor (int j : vg[gb]) gi[j] = ga;\n\t\tvg[ga].insert(vg[ga].end(), vg[gb].begin(), vg[gb].end());\n\t\tvg[gb].clear();\n\t\ttg[ga].insert(tg[ga].end(), tg[gb].begin(), tg[gb].end());\n\t}\n};\nint main() {\n\tcin >> n >> h >> w;\n\tQuickFind qf(h+w+1);\n\trep(i, n) {\n\t\tLL x, y, z;\n\t\tcin >> x >> y >> z;\n\t\tx--, y--;\n\t\tedges.push_back(edge{ x,y+h,z });\n\t}\n\tsort(edges.begin(), edges.end(), [](edge x, edge y) {\n\t\treturn (x.cost > y.cost);\n\t});\n\t\n\tfor(int i=0;i<n;i++) {\n\t\tLL s = edges[i].from, t = edges[i].to;\n\t\tif (!qf.same_group(s, t)) {\n\t\t\tif (namori[qf.gi[s]] && namori[qf.gi[t]])continue;\n\t\t\tbool F = (namori[qf.gi[s]] || namori[qf.gi[t]]);\n\t\t\tqf.merge(s, t);\n\t\t\tnamori[qf.gi[s]] |= F;\n\t\t\tans += edges[i].cost;\n\t\t}\n\t\telse if (namori[qf.gi[s]] == 0) {\n\t\t\tnamori[qf.gi[s]] = true;\n\t\t\tans += edges[i].cost;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N=200000+5,inf=0x3f3f3f3f;\nint f[N],cyc[N];\nint find(int x){\n\treturn x==f[x]?x:f[x]=find(f[x]);\n}\nstruct node{\n\tint r,c,val;\n\tbool friend operator <(node i,node j){\n\t\treturn i.val>j.val;\n\t}\n}a[N];\nint main(){\n\tint n,H,W;\n\tcin>>n>>H>>W;\n\tfor(int i=1;i<=H+W;++i)\n\t\tf[i]=i;\n\tfor(int i=1;i<=n;++i)\n\t\tcin>>a[i].r>>a[i].c>>a[i].val;\n\tsort(a+1,a+n+1);int ans=0;\n\tfor(int i=1;i<=n;++i){\n\t\tint x=find(a[i].r),y=find(a[i].c+H);\n\t\tif(x==y){\n\t\t\tif(cyc[x]) continue;\n\t\t\tcyc[x]=1;\n\t\t}\n\t\telse{\n\t\t\tif(cyc[x] && cyc[y]) continue;\n\t\t\tf[x]=y; cyc[y]+=cyc[x];\n\t\t}\n\t\tans+=a[i].val;\n\t}\n\tcout<<ans;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, l_l> lll;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\n#define EPS (1e-7)\n#define INF (1e9)\n#define PI (acos(-1))\n//const ll mod = 1000000007;\nstruct UnionFind {\n    vector<int> par;\n    vector<int> rank;\n    vector<ll> Size;\n    vector<int> closed;\n    UnionFind(int n = 1) {\n        init(n);\n    }\n\n    void init(int n = 1) {\n        closed.resize(n + 1); par.resize(n + 1); rank.resize(n + 1); Size.resize(n + 1);\n        for (int i = 0; i <= n; ++i) closed[i] = 0, par[i] = i, rank[i] = 0, Size[i] = 1;\n    }\n\n    int root(int x) {\n        if (par[x] == x) {\n            return x;\n        }\n        else {\n            int r = root(par[x]);\n            return par[x] = r;\n        }\n    }\n\n    bool issame(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    bool merge(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return false;\n        if (rank[x] < rank[y]) swap(x, y);\n        if (rank[x] == rank[y]) ++rank[x];\n        par[y] = x;\n        Size[x] += Size[y];\n        closed[x] |= closed[y];\n        return true;\n    }\n\n    ll size(int x){\n        return Size[root(x)];\n    }\n\n    bool isclosed(int x) {\n        x = root(x);\n        return closed[x] > 0;\n    }\n\n    void close(int x) {\n        x = root(x);\n        closed[x] = 1;\n    }\n};\n\nint N;\nvector<lll> v;\nll H, W;\n\n\nint main() {\n    //cout.precision(10);\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N >> H >> W;\n    v.resize(N);\n    for(int i = 0; i < N; i++) {\n        ll r, c, a;\n        cin >> r >> c >> a;\n        v[i] = {a, {r, c}};\n    }\n    sort(v.begin(), v.end(), greater<lll>());\n    UnionFind uni(200050);\n    ll ans = 0;\n    for(int i = 0; i < N; i++) {\n        ll a = v[i].first;\n        ll r = v[i].second.first;\n        ll c = v[i].second.second;\n        if(!uni.issame(r, 1e5 + c)) {\n            if(uni.isclosed(r) && uni.isclosed(1e5 + c)) continue;\n            ans += a;\n            uni.merge(r, 1e5 + c);\n            //cerr << i << \" \";\n            continue;\n        }\n        if(uni.isclosed(r)) continue;\n        uni.close(r);\n        ans += a;\n        //cerr << i << \" \";\n    }\n    //cerr << endl;\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// clang-format off\n#pragma GCC diagnostic ignored \"-Wsign-compare\"\n#pragma GCC diagnostic ignored \"-Wsign-conversion\"\n#define NDEBUG\n#define SHOW(...) static_cast<void>(0)\n//!===========================================================!//\n//!  dP     dP                          dP                    !//\n//!  88     88                          88                    !//\n//!  88aaaaa88a .d8888b. .d8888b. .d888b88 .d8888b. 88d888b.  !//\n//!  88     88  88ooood8 88'  '88 88'  '88 88ooood8 88'  '88  !//\n//!  88     88  88.  ... 88.  .88 88.  .88 88.  ... 88        !//\n//!  dP     dP  '88888P' '88888P8 '88888P8 '88888P' dP        !//\n//!===========================================================!//\ntemplate <typename T>\nT read()\n{\n    T v;\n    return std::cin >> v, v;\n}\ntemplate <typename T>\nstd::vector<T> readVec(const std::size_t l)\n{\n    std::vector<T> v(l);\n    for (auto& e : v) { std::cin >> e; }\n    return v;\n}\nusing ld = long double;\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr unsigned int MOD = 1000000007;\ntemplate <typename T>\nconstexpr T INF = std::numeric_limits<T>::max() / 4;\ntemplate <typename F>\nconstexpr F PI = static_cast<F>(3.1415926535897932385);\nstd::mt19937 mt{std::random_device{}()};\ntemplate <typename T>\nbool chmin(T& a, const T& b) { return (a > b ? a = b, true : false); }\ntemplate <typename T>\nbool chmax(T& a, const T& b) { return (a < b ? a = b, true : false); }\ntemplate <typename T>\nstd::vector<T> Vec(const std::size_t n, T v) { return std::vector<T>(n, v); }\ntemplate <class... Args>\nauto Vec(const std::size_t n, Args... args) { return std::vector<decltype(Vec(args...))>(n, Vec(args...)); }\ntemplate <typename T>\nconstexpr T popCount(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : (T)__builtin_popcountll(u);\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = (v & 0x5555555555555555ULL) + (v >> 1 & 0x5555555555555555ULL), v = (v & 0x3333333333333333ULL) + (v >> 2 & 0x3333333333333333ULL), v = (v + (v >> 4)) & 0x0F0F0F0F0F0F0F0FULL, static_cast<T>(v * 0x0101010101010101ULL >> 56 & 0x7f);\n#endif\n}\ntemplate <typename T>\nconstexpr T log2p1(const T u)\n{\n#ifdef __has_builtin\n    return u == 0 ? T(0) : T(64 - __builtin_clzll(u));\n#else\n    unsigned long long v = static_cast<unsigned long long>(u);\n    return v = static_cast<unsigned long long>(v), v |= (v >> 1), v |= (v >> 2), v |= (v >> 4), v |= (v >> 8), v |= (v >> 16), v |= (v >> 32), popCount(v);\n#endif\n}\ntemplate <typename T>\nconstexpr T clog(const T v) { return v == 0 ? T(0) : log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T msbp1(const T v) { return log2p1(v); }\ntemplate <typename T>\nconstexpr T lsbp1(const T v)\n{\n#ifdef __has_builtin\n    return __builtin_ffsll(v);\n#else\n    return v == 0 ? T(0) : popCount((v & (-v)) - T(1)) + T(1);\n#endif\n}\ntemplate <typename T>\nconstexpr bool ispow2(const T v) { return popCount(v) == 1; }\ntemplate <typename T>\nconstexpr T ceil2(const T v) { return v == 0 ? T(1) : T(1) << log2p1(v - 1); }\ntemplate <typename T>\nconstexpr T floor2(const T v) { return v == 0 ? T(0) : T(1) << (log2p1(v) - 1); }\n//!==============================================================================!//\n//!  dP     dP          oo                       88888888b oo                dP  !//\n//!  88     88                                   88                          88  !//\n//!  88     88 88d888b. dP .d8888b. 88d888b.    a88aaaa    dP 88d888b. .d888b88  !//\n//!  88     88 88'  '88 88 88'  '88 88'  '88     88        88 88'  '88 88'  '88  !//\n//!  Y8.   .8P 88    88 88 88.  .88 88    88     88        88 88    88 88.  .88  !//\n//!  'Y88888P' dP    dP dP '88888P' dP    dP     dP        dP dP    dP '88888P8  !//\n//!==============================================================================!//\nclass UnionFind\n{\npublic:\n    UnionFind(const std::size_t v) : V(v), parent(v), size(v, 1) { std::iota(parent.begin(), parent.end(), 0); }\n    std::size_t find(const std::size_t a) { return assert(a < V), parent[a] == a ? a : parent[a] = find(parent[a]); }\n    bool same(const std::size_t a, const std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        return find(a) == find(b);\n    }\n    void unite(std::size_t a, std::size_t b)\n    {\n        assert(a < V), assert(b < V);\n        a = find(a), b = find(b);\n        if (a == b) { return; }\n        if (size[a] < size[b]) { std::swap(a, b); }\n        size[a] += size[b], parent[b] = a;\n    }\n    std::size_t getSize(const std::size_t a) { return assert(a < V), size[find(a)]; }\n    friend std::ostream& operator<<(std::ostream& os, const UnionFind& uf)\n    {\n        os << \"[\";\n        for (std::size_t i = 0; i < uf.parent.size(); i++) { os << uf.parent[i] << (i + 1 == uf.parent.size() ? \"\" : \",\"); }\n        return (os << \"]\\n\");\n    }\n\nprivate:\n    const std::size_t V;\n    std::vector<std::size_t> parent, size;\n};\n// clang-format on\n//!=====================================!//\n//!  8888ba.88ba           oo           !//\n//!  88  '8b  '8b                       !//\n//!  88   88   88 .d8888b. dP 88d888b.  !//\n//!  88   88   88 88'  '88 88 88'  '88  !//\n//!  88   88   88 88.  .88 88 88    88  !//\n//!  dP   dP   dP '88888P8 dP dP    dP  !//\n//!=====================================!//\nint main()\n{\n    const int        N = read<int>(), H = read<int>(), W = read<int>();\n    std::vector<int> R(N), C(N), A(N);\n    for (int i = 0; i < N; i++) { std::cin >> R[i] >> C[i] >> A[i], R[i]--, C[i]--; }\n    std::vector<int> index(N);\n    std::iota(index.begin(), index.end(), 0);\n    std::sort(index.begin(), index.end(), [&](const int i, const int j) { return A[i] > A[j]; });\n    UnionFind        uf(H + W);\n    int              ans = 0;\n    std::vector<int> cycle(H + W, 0);\n    for (const int i : index) {\n        const int u = R[i], v = H + C[i];\n        if (uf.same(u, v)) {\n            if (cycle[uf.find(u)] > 0) { continue; }\n            ans += A[i], uf.unite(u, v), cycle[uf.find(u)] = 1;\n        } else {\n            if (cycle[uf.find(u)] > 0 and cycle[uf.find(v)] > 0) { continue; }\n            ans += A[i], uf.unite(u, v);\n        }\n    }\n    std::cout << ans << std::endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<cstdlib>\n#include<vector>\n#include<iomanip>\n#include<ctime>\n#include<set>\n#include<map>\n#include<queue>\n#include<stack>\n#define sqr(x) ((x)*(x))\n#define fz1(i,n) for ((i)=1;(i)<=(n);(i)++)\n#define fd1(i,n) for ((i)=(n);(i)>=1;(i)--)\n#define fz0g(i,n) for ((i)=0;(i)<=(n);(i)++)\n#define fd0g(i,n) for ((i)=(n);(i)>=0;(i)--)\n#define fz0k(i,n) for ((i)=0;(i)<(n);(i)++)\n#define fd0k(i,n) for ((i)=(long long)((n)-1);(i)>=0;(i)--)\n#define fz(i,x,y) for ((i)=(x);(i)<=(y);(i)++)\n#define fd(i,y,x) for ((i)=(y);(i)>=(x);(i)--)\n#define fzin fz1(i,n)\n#define fzim fz1(i,m)\n#define fzjn fz1(j,n)\n#define fzjm fz1(j,m)\n#define ff(c,itr) for (__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\n#define rdst(st,len){static char ss[len];scanf(\" %s\",ss);(st)=ss;}\n#define inc(x,y) {x+=(y);if(x>=mod)x-=mod;}\n#define dec(x,y) {x-=(y);if(x<0)x+=mod;}\nusing namespace std;\n// 1:T 2:H\nlong long ans;\nint w,h,n,m,i,j,fa[200005],typ[200005];\nstruct ii\n{\n\tint x,y,val;\n}a[200005];\nbool cmp(ii x,ii y)\n{\n\treturn x.val>y.val;\n}\nint fnd(int x)\n{\n\tif(fa[x]==x)return x;\n\treturn fa[x]=fnd(fa[x]); \n}\nbool mrg(int x,int y)\n{\n\tx=fnd(x);y=fnd(y);\n\tif(x==y){\n\t\tif(typ[x]==2) return 0;\n\t\ttyp[x]=2;return 1;\n\t}\n\tif(typ[x]==2&&typ[y]==2) return 0;\n\tif(typ[x]==1&&typ[y]==2) {fa[x]=y;return 1;}\n\tif(typ[x]==2&&typ[y]==1) {fa[y]=x;return 1;}\n\tif(typ[x]==1&&typ[y]==1) {fa[x]=y;return 1;}\n\texit(-1);\n}\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&h,&w);\n\tfz1(i,w+h){\n\t\tfa[i]=i;\n\t\ttyp[i]=1;\n\t}\n\tfz1(i,n){\n\t\tscanf(\"%d%d%d\",&a[i].x,&a[i].y,&a[i].val);\n\t\ta[i].y+=h;\n\t}\n\tsort(a+1,a+n+1,cmp);\n\tfz1(i,n){\n\t\tif(mrg(a[i].x,a[i].y)) ans+=a[i].val;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ri register\n#define int long long\nusing namespace std; const int N=300010;\ninline int read()\n{\n   \tint s=0,w=1; ri char ch=getchar();\n   \twhile(ch<'0'||ch>'9') {if(ch=='-') w=-1; ch=getchar(); }\n   \twhile(ch>='0'&&ch<='9') s=s*10+ch-'0', ch=getchar();\n   \treturn s*w;\n}\nint book[N],n,H,W,f[N],res;\nstruct Node{ int u,v,w; }e[N];\ninline bool cp(Node x,Node y) { return x.w>y.w; }\ninline int Find(int x) { return f[x]^x?f[x]=Find(f[x]):x; }\nsigned main()\n{\n\tn=read(), H=read(), W=read();\n\tfor(ri int i=1;i<=n;i++) e[i].u=read()+W, e[i].v=read(), e[i].w=read();\n\tfor(ri int i=1;i<=H+W;i++) f[i]=i;\n\tsort(e+1,e+1+n,cp);\n\tfor(ri int i=1;i<=n;i++)\n\t{\n\t\tint fx=Find(e[i].u), fy=Find(e[i].v);\n\t\tif(fx==fy)\n\t\t{\n\t\t\tif(book[fx]) continue;\n\t\t\tbook[fx]=1, res+=e[i].w;\n\t\t\tcontinue;\n\t\t}\n\t\tif(book[fx] && book[fy]) continue;\n\t\tbook[fx]|=book[fy], f[fy]=fx, res+=e[i].w;\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n} "
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <time.h>\n#include <vector>\n#include <map>\n#include <set>\n#include <sstream>\n#include <algorithm>\n#include <bitset>\n#include <utility>\n#include <iostream>\n#include <cmath>\n#include <deque>\n\n#define pii pair<ll,ll>\n#define X first\n#define Y second\n#define mp make_pair\n\ntypedef long long ll;\nusing namespace std;\n#define MAXN 228228\n#define MOD 1000000007\nll x, y, n, m, k, R, C;\nll a[MAXN], rsz[MAXN], csz[MAXN];\nvector<ll> g;\n\nstruct shit {\n    ll val;\n    ll x;\n    ll y;\n};\n\nbool operator <(const shit& x, const shit& y) {\n    return x.val < y.val;\n}\n\nll p[MAXN], s[MAXN], h[MAXN];\n\nstruct DSU {\n    DSU(int N) {\n        color.resize(N);\n        siz.resize(N);\n        for (int i = 0; i < N; i++) {\n            color[i] = i;\n            siz[i] = 1;\n        }\n    }\n\n    int get(int v) {\n        return (v == color[v]) ? v : (color[v] = get(color[v]));\n    }\n\n    void unite(int a, int b) {\n        a = get(a);\n        b = get(b);\n        if (siz[a] > siz[b]) {\n            swap(a, b);\n        }\n        if (a != b) {\n            color[a] = b;\n            siz[b] += siz[a];\n          h[b] += h[a];\n        }\n    }\n\n    int size(int x) {\n        return siz[x];\n    }\n\n    vector<int> color;\n    vector<int> siz;\n};\n\nDSU dsu(MAXN);\n\nvector<shit> f;\nint main() {\n    cin >> n >> R >> C;\n    for (int i = 0; i < n; i++ ){\n        ll x, y, z;\n        cin >> x >> y >> z;\n        f.push_back({z, x, y + R});\n    }\n    sort(f.begin(), f.end());\n    reverse(f.begin(), f.end());\n    for (int i = 1; i <= R+C; i++) {\n        h[i] = 1;\n    }\n\n    ll ans = 0;\n    for (auto v : f) {\n        ll x = dsu.get(v.x);\n        ll y = dsu.get(v.y);\n        ll val = v.val;\n        if (x == y) {\n            if (h[x] == dsu.size(x)) {\n                h[x]++;\n                ans += val;\n            }\n        } else {\n            if (h[x] + h[y] <= dsu.size(x) + dsu.size(y) + 1) {\n                dsu.unite(x, y);\n                ans += val;\n            }\n        }\n    }\n    cout << ans << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<int,int> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nstruct DSU\n{\n\tint S;\n\t\n\tstruct node\n\t{\n\t\tint p; ll sum; int e=0;\n\t};\n\tvector<node> dsu;\n\t\n\tDSU(int n)\n\t{\n\t\tS = n;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tnode tmp;\n\t\t\ttmp.p = i; tmp.sum = 0; tmp.e=0;\n\t\t\tdsu.pb(tmp);\n\t\t}\n\t}\n\t\n\tvoid reset(int n)\n\t{\n\t\tdsu.clear();\n\t\tS = n;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tnode tmp;\n\t\t\ttmp.p = i; tmp.sum = 0; tmp.e=0;\n\t\t\tdsu.pb(tmp);\n\t\t}\n\t}\n\t\n\tint rt(int u)\n\t{\n\t\tif(dsu[u].p == u) return u;\n\t\tdsu[u].p = rt(dsu[u].p);\n\t\treturn dsu[u].p;\n\t}\n\t\n\tbool merge(int u, int v)\n\t{\n\t\tu = rt(u); v = rt(v);\n\t\tif(u == v) \n\t\t{\n\t\t\tif(dsu[u].e==0) \n\t\t\t{\n\t\t\t\tdsu[u].e=1; return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tif(dsu[u].e&&dsu[v].e) return false;\n\t\tif(rand()&1) swap(u, v);\n\t\tdsu[u].e+=dsu[v].e;\n\t\tdsu[v].p = u;\n\t\tdsu[u].sum += dsu[v].sum;\n\t\treturn true;\n\t}\n\t\n\tbool sameset(int u, int v)\n\t{\n\t\tif(rt(u) == rt(v)) return true;\n\t\treturn false;\n\t}\n\t\n\tll getstat(int u)\n\t{\n\t\treturn dsu[rt(u)].sum;\n\t}\n};\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n,h,w; cin>>n>>h>>w;\n\tDSU dsu(h+w);\n\tvector<pair<ll,ii> > edges;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x,y,a; cin>>x>>y>>a; x--; y--;\n\t\tedges.pb({a,{x,y+h}});\n\t}\n\tsort(edges.rbegin(),edges.rend());\n\tll ans=0;\n\tfor(int i=0;i<edges.size();i++)\n\t{\n\t\tif(dsu.merge(edges[i].se.fi,edges[i].se.se))\n\t\t{\n\t\t\tans+=edges[i].fi;\n\t\t}\n\t}\n\tcout<<ans<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n\n  int n, h, w, r, c, a;\n  vector<pair<int, int>> col[100100];\n  cin >> n >> h >> w;\n  for (int i = 0; i < n; i++)\n  {\n    cin >> r >> c >> a;\n    col[c].push_back({a, r});\n  }\n\n  int row[100100] = {0};\n  long long ans = 0;\n  for (int i = 1; i <= w; i++)\n    if (!col[i].empty())\n    {\n      sort(col[i].begin(), col[i].end(), greater<pair<int, int>>());\n      ans += col[i][0].first;\n      for (int j = 1; j < col[i].size(); j++)\n        row[col[i][j].second] = max(row[col[i][j].second], col[i][j].first);\n    }\n\n  for (int i = 1; i <= h; i++)\n    ans += row[i];\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <numeric>\n#include <tuple>\n\ntemplate <class T, class U>\ninline bool chmin(T &lhs, const U &rhs) {\n  if (lhs > rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\ntemplate <class T, class U>\ninline bool chmax(T &lhs, const U &rhs) {\n  if (lhs < rhs) {\n    lhs = rhs;\n    return true;\n  }\n  return false;\n}\n\n// [l, r) from l to r\nstruct range {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { ++i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr range(int l_, int r_): l(l_), r(std::max(l_, r_)) { }\n  constexpr itr begin() const { return l; }\n  constexpr itr end() const { return r; }\n};\n\n// [l, r) from r to l\nstruct revrange {\n  struct itr {\n    int i;\n    constexpr itr(int i_): i(i_) { }\n    constexpr void operator ++ () { --i; }\n    constexpr int operator * () const { return i; }\n    constexpr bool operator != (itr x) const { return i != x.i; }\n  };\n  const itr l, r;\n  constexpr revrange(int l_, int r_): l(l_ - 1), r(std::max(l_, r_) - 1) { }\n  constexpr itr begin() const { return r; }\n  constexpr itr end() const { return l; }\n};\n\nclass disjoint_set_union {\nprivate:\n  std::vector<int> parent;\n  std::vector<bool> namori;\n\npublic:\n  disjoint_set_union(int size_) {\n    parent.assign(size_, -1);\n    namori.assign(size_, 0);\n  }\n\n\n  int find(int x) {\n    if (parent[x] < 0) return x;\n    return parent[x] = find(parent[x]);\n  }\n\n  bool add_edge(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if (x == y) {\n      if (namori[x]) return false;\n      namori[x] = true;\n    }\n    else {\n      if (namori[x] && namori[y]) return false;\n      if (parent[x] > parent[y]) std::swap(x, y);\n      parent[x] += parent[y];\n      parent[y] = x;\n      namori[x] = namori[x] || namori[y];\n    }\n    return true;\n  }\n\n};\n\nint main() {\n  int N, H, W;\n  std::cin >> N >> H >> W;\n  using edge_type = std::tuple<int, int, int>;\n  std::vector<edge_type> edge;\n  edge.reserve(N);\n  for (int i: range(0, N)) {\n    int r, c, a;\n    std::cin >> r >> c >> a;\n    --r; --c;\n    edge.emplace_back(a, r, c + H);\n  }\n  std::sort(edge.rbegin(), edge.rend());\n  long long ans = 0;\n  disjoint_set_union dsu(H + W);\n  for (const auto &e: edge) {\n    int a, r, c;\n    std::tie(a, r, c) = e;\n    if (dsu.add_edge(r, c)) {\n      ans += a;\n    }\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <deque>\n#include <queue>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <bitset>\n#include <cmath>\n#define vv(a, b, c, d) vector<vector<d> >(a, vector<d>(b, c))\n#define vvi vector<vector<int> >\n#define vvl vector<vector<ll> >\n#define vl vector<ll>\ntypedef long long int ll;\ntypedef long double ld;\nusing namespace std;\n\nset<ll> num;\nvector<bool> used(200002, false);\nstruct edge{ll to, cost;};\nvector<vector<edge> > G(200002);\nvvl lis = vv(200002, 0, 0, ll);\n\nvoid dfs(ll now, ll c){\n  if(used[now]) return;\n  lis[c].push_back(now);\n  used[now] = true;\n  for(int i=0;i<G[now].size();i++){\n    dfs(G[now][i].to, c);\n  }\n}\nint main(int argc, char const *argv[]) {\n  ll N, H, W, a, b, c, ans = 0;\n  std::cin >> N >> H >> W;\n  std::vector<set<ll>> child(200002);\n  for(int i=0;i<N;i++){\n    std::cin >> a >> b >> c;\n    G[a].push_back(edge{b+100001, -c});\n    G[b+100001].push_back(edge{a, -c});\n    if(child[a].find(b+100001)==child[a].end()) child[a].insert(b+100001);\n    if(child[b+100001].find(a)==child[b+100001].end()) child[b+100001].insert(a);\n  }\n  for(int i=0;i<200002;i++) if(!used[i]) dfs(i, i);\n  for(int i=0;i<200002;i++) used[i] = false;\n  for(int i=0;i<200002;i++){\n    if(lis[i].size()<=1) continue;\n    vvl ed = vv(0, 3, 0, ll);\n    map<ll, ll> count;\n    for(int j=0;j<lis[i].size();j++){\n      count.emplace(lis[i][j], 0);\n      for(int k=0;k<G[lis[i][j]].size();k++){\n        ll A = lis[i][j], B = G[A][k].to, C = G[A][k].cost;\n        if(A>B) swap(A, B);\n        ed.push_back(vl{C, A, B});\n      }\n    }\n    sort(ed.begin(), ed.end());\n    ll m = 0;\n    for(int j=0;j<ed.size();j+=2){\n      if(m==lis[i].size()) break;\n      ll A = ed[j][1], B = ed[j][2], C = -ed[j][0];\n      if(count.at(A)==child[A].size()+1||count.at(B)==child[B].size()+1) continue;\n      else{\n        ll tmp = count.at(A);\n        count.erase(A);\n        count.emplace(A, tmp+1);\n        tmp = count.at(B);\n        count.erase(B);\n        count.emplace(B, tmp+1);\n        ans += C;\n        m++;\n      }\n    }\n    //std::cout << i << \" \" << ans << '\\n';\n  }\n  std::cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nint n,h,w;\nstruct ele{\n\tint X,Y,V;\n\tvoid set(int _X,int _Y,int _V){\n\t\tX=_X;Y=_Y;V=_V;\n\t}\n\tbool operator <(ele B) const{\n\t\treturn V>B.V;\n\t}\n}es[100005];\nnamespace DSU{\n\tint fa[200005],sz[200005],cnt[200005];\n\tvoid init(){\n\t\tint i;\n\t\tfor(i=0;i<200005;++i) fa[i]=i,sz[i]=1;\n\t\tmemset(cnt,0,sizeof(cnt));\n\t}\n\tint anc(int x){\n\t\treturn (fa[x]==x?x:(fa[x]=anc(fa[x])));\n\t}\n\tvoid mrg(int x,int y){\n\t\tx=anc(x);y=anc(y);\n\t\tif(x!=y){\n\t\t\tfa[x]=y;\n\t\t\tsz[y]+=sz[x];\n\t\t\tcnt[y]+=cnt[x];\n\t\t}\n\t}\n}\nint main(){\n\tint i,j,k;\n\tscanf(\"%d%d%d\",&n,&h,&w);\n\tfor(i=0;i<n;++i){\n\t\tint R,C,A;\n\t\tscanf(\"%d%d%d\",&R,&C,&A);\n\t\tes[i].set(R,C,A);\n\t}\n\tDSU::init();\n\tsort(es,es+n);\n\tLL res=0ll;\n\tfor(i=0;i<n;++i){\n\t\tint x=es[i].X,y=h+es[i].Y,z=es[i].V;\n\t\tx=DSU::anc(x);\n\t\ty=DSU::anc(y);\n\t\tusing namespace DSU;\n\t\tif(x==y && cnt[x]==sz[x]-1){\n\t\t\t++cnt[x];\n\t\t\tres+=(LL)z;\n\t\t}\n\t\telse if(x!=y && (cnt[x]<sz[x] || cnt[y]<sz[y])){\n\t\t\tmrg(x,y);\n\t\t\t++cnt[y];\n\t\t\tres+=(LL)z;\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int MAXN = 2e5+7;\n\nint p[MAXN];\nbool done[MAXN];\n\nint parent(int u) {\n    if (u==p[u]) return u;\n    return p[u] = parent(p[u]);\n}\n\nbool unite(int u, int v) {\n    u = parent(u);\n    v = parent(v);\n\n    if (u==v) {\n        if (done[u]) return false;\n        done[u] = true;\n        return true;\n    }\n\n    if (done[u] && done[v]) return false;\n\n    p[v] = u;\n    done[u] |= done[v];\n\n    return true;\n}\n\ntypedef tuple< int , int , int >triple;\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n, h, w;\n    cin >> n >> h >> w;\n\n    for (int i = 1; i <= h+w; i++) p[i] = i;\n\n    vector< triple >edges(n);\n    for (int i = 0; i < n; i++) {\n        cin >> get<1>(edges[i]) >> get<2>(edges[i]) >> get<0>(edges[i]);\n    }\n\n    sort(edges.rbegin(), edges.rend());\n\n    int ans = 0;\n    for (triple t : edges) {\n        int u = get<1>(t);\n        int v = h+get<2>(t);\n        if (unite(u, v)) {\n            ans += get<0>(t);\n//            cout << \"taken \" << get<0>(t) << endl;\n        }\n    }\n\n    cout << ans << \"\\n\";\n\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N =  1e5 + 100;\n\nint n, R, C;\nint x[N], y[N], w[N];\n\nlong long solve() {\n    vector<pair<int,int>> xx[N];\n    vector<int> yy[N];\n    for(int i = 0; i < n; i++) {\n        xx[x[i]].push_back(make_pair(w[i], i));\n    }\n    long long ans = 0;\n\n    for(int i = 0; i < R; i++) {\n        if(xx[i].size() == 0) continue;\n        sort(xx[i].begin(), xx[i].end());\n        ans += xx[i].back().first;\n        xx[i].pop_back();\n        for(int j = 0; j < xx[i].size(); j++) {\n            int idx = xx[i][j].second;\n            yy[y[idx]].push_back(w[idx]);\n        }\n    }\n    for(int i = 0; i < C; i++) {\n        if(yy[i].size() == 0) continue;\n        sort(yy[i].begin(), yy[i].end());\n        ans += yy[i].back();\n    }\n    return ans;\n}\n\n\nint main() {\n    // freopen(\"in.txt\", \"r\", stdin);\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> n >> R >> C;\n    for(int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i] >> w[i];\n        x[i]--, y[i]--;\n    }\n    long long ans = solve();\n    for(int i = 0; i < n; i++) swap(x[i], y[i]);\n    swap(R, C);\n    ans = max(ans, solve());\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 1e5+10;\nint n,w,h;\nstruct node{\n\tint x,y,z;\n}a[N];\n\nint fa[N<<1],flag[N<<1];\ninline int Find(int x){\n\treturn fa[x]==x?x:fa[x]=Find(fa[x]);\n}\ninline bool check(int x,int y){\n\tint a=Find(x),b=Find(y+w);\n\tif (a!=b){\n\t\tint ret=1;\n\t\tif (flag[a]&&flag[b]) ret=0;\n\t\tfa[a]=b,flag[b]|=flag[a];\n\t\treturn ret;\n\t} else if (flag[a]) return 0;\n\telse return flag[a]=1;\n}\n\nint main(){\n\tn=read(),w=read(),h=read();\n\tFor(i,1,w+h) fa[i]=i;\n\tFor(i,1,n) a[i]=(node){read(),read(),read()};\n\tsort(a+1,a+1+n,[](node a,node b){\n\t\treturn a.z>b.z;\n\t});\n\tll ans=0;\n\tFor(i,1,n) if (check(a[i].x,a[i].y)){\n\t\tans+=a[i].z;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ninline int qread(){\n\t#define cg (c=getchar())\n\tint x,f=1;char c;\n\twhile(cg<'0'||'9'<c)if(c=='-')f=-1;\n\tfor(x=(c^48);'0'<=cg&&c<='9';x=(x<<1)+(x<<3)+(c^48));\n\treturn x*f;\n}\n#define MAXN 100000\nint preh[MAXN+5],prel[MAXN+5];\nstruct node{\n\tint id,var;\n\tnode(){}\n\tnode(int I,int V):id(I),var(V){}\n\tbool operator<(const node& other){\n\t\treturn var>other.var;\n\t}\n};\nvector<node>hang[MAXN+5];\nvector<node>lie[MAXN+5];\nbool got[MAXN+5];\nint N,H,W,ans;\nint main(){\n\tN=qread(),H=qread(),W=qread();\n\tfor(int i=1,x,y,v;i<=N;++i){\n\t\tx=qread(),y=qread(),v=qread();\n\t\thang[x].push_back(node(i,v));\n\t\tlie[y].push_back(node(i,v));\n\t\tpreh[i]=x;prel[i]=y;\n\t}\n\tfor(int i=1;i<=H;++i){\n\t\tsort(hang[i].begin(),hang[i].end());\n\t\tint j=0;\n\t\twhile(j<hang[i].size()&&got[hang[i][j].id])++j;\n\t\tif(j<hang[i].size()){\n\t\t\tans+=hang[i][j].var;\n\t\t\tgot[hang[i][j].id]=true;\n\t\t}\n\t}\n\tfor(int i=1;i<=W;++i){\n\t\tsort(lie[i].begin(),lie[i].end());\n\t\tint j=0;\n\t\twhile(j<lie[i].size()&&got[lie[i][j].id])++j;\n\t\tif(j<lie[i].size()){\n\t\t\tans+=lie[i][j].var;\n\t\t\tgot[lie[i][j].id]=true;\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\n#include<unordered_set>\nusing namespace std;\n/*int p = 998244353;*/\nint p = 1000000007;\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<int,pin>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define sq(a) (a)*(a)\n#define rev(s) reverse(s.begin(),s.end())\n#define end_pr(s) cout << s <<endl;return 0\n#define itn int\nint RE() {\n\tvel v(3, 2);\n\treturn v.at(4);\n}\nint ru(int a, int r) {\n\tif (r == 0) { return 1; }\n\tint ans = ru(a, r / 2);\n\tans *= ans; ans %= p;\n\tif (r % 2 == 1) { ans *= a; }\n\treturn ans % p;\n}\nint inv(int a) {\n\treturn ru(a,p - 2);\n}\nvel dis(int mid1, vvel &way) {\n\tint n = way.size();\n\tvel dist(n, -1); dist[mid1] = 0;\n\tqueue<int> q;\n\tq.push(mid1);\n\twhile (!q.empty()) {\n\t\tint st = q.front(); q.pop();\n\t\trep(i, way[st].size()) {\n\t\t\tint to = way[st][i];\n\t\t\tif (dist[to] == -1) {\n\t\t\t\tdist[to] = dist[st] + 1;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\npin most_far(int now, int n, vvel &way) {\n\tvel dist1 = dis(now, way);\n\tpin ans = mkp(-1, 0);\n\trep(i, n) {\n\t\tif (dist1[i] > ans.first) { ans = mkp(dist1[i], i); }\n\t}\n\treturn ans;\n}\n\ntemplate<typename T>\nV<T> uni(V<T> &v) {\n\tif (v.size() == 0) { return v; }\n\tsor(v);\n\tV<T> ans(1, v[0]);\n\tfor (int i = 1; i < v.size(); i++) {\n\t\tif (v[i] != v[i - 1]) { ans.push_back(v[i]); }\n\t}\n\tv = ans;\n\treturn v;\n}\nint s_gcd(int a, int b) {\n\tif (b == 0) { return a; }\n\treturn s_gcd(b, a%b);\n}\nint gcd(int a, int b) {\n\ta = abs(a);\n\tb = abs(b);\n\tif (a < b) { swap(a, b); }\n\treturn s_gcd(a, b);\n}\nvel fl;\nint root1(vel &par, int ser, vel &path) {\n\tif (par[ser] == -1) {\n\t\tfor (int i = 0; i < path.size(); i++) {\n\t\t\tpar[path[i]] = ser;\n\t\t}\n\t\treturn ser;\n\t}\n\tpath.push_back(ser);\n\treturn root1(par, par[ser], path);\n}\nint root(vel &par, int ser) {\n\tvel emp(0);\n\treturn root1(par, ser, emp);\n}\nvoid uni(int x, int y, vel &par) {\n\tx = root(par, x);\n\ty = root(par, y);\n\tif (x != y) {\n\t\tpar[y] = x;\n\t}\n}\nbool issame(int x, int y, vel &par) {\n\treturn root(par, x) == root(par, y);\n}\nsigned main(){\n\tint n, h, w; cin >> n >> h >> w;\n\tV<qin> edge;\n\trep(i, n) {\n\t\tint r, c; cin >> r >> c;\n\t\tr--; c--;\n\t\tint a; cin >> a;\n\t\tedge.push_back(mkp(a, mkp(r, c + h)));\n\t}\n\tsor(edge); rev(edge);\n\tvel par(h+w, -1);\n\tveb fl(h+w, false);\n\tint ans = 0;\n\tveb is_use(n, false);\n\tfor(int i=0;i<n;i++) {\n\t\tpin f = edge[i].second;\n\t\tif (!issame(f.first, f.second, par)) {\n\t\t\tuni(f.first, f.second, par);\n\t\t\tans += edge[i].first;\n\t\t\tis_use[i] = true;\n\t\t}\n\t}\n\tfor (int i = 0; i < n; i++) {\n\t\tpin f = edge[i].second;\n\t\tint top = root(par, f.first);\n\t\tif (!fl[top] and !is_use[i]) {\n\t\t\tans += edge[i].first;\n\t\t\tfl[top] = true;\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define fto(i,j,h)   for (int i=j; i<=h; i++)\n#define fdto(i,j,h)  for (int i=j; i>=h; i--)\n#define ANH BAI5\n#define maxn 100009\n#define fi first\n#define se second\n#define ll long long\nusing namespace std;\n\nint n, h, w, df[maxn], L[1048580], df2[maxn];\nstruct data{\n    int r, c, v;\n} a[maxn];\npair<int, int> Max[maxn];\nbool cmp(data e, data f){\n    return e.v > f.v;\n}\nvoid sub1(){\n\n}\nint main()\n{\n    //freopen(\"ANH.inp\", \"r\", stdin);\n    //freopen(\"ANH.out\", \"w\", stdout);\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    cout.tie(NULL);\n    cin >> n >> h >> w;\n    fto(i,1,n)  cin >> a[i].r >> a[i].c >> a[i].v;\n    sort(a+1, a+n+1, cmp);\n    ll res = 0, s = 0;\n    fto(i,1,n){\n        if (df[a[i].r] == 0){\n            df[a[i].r] = 1;    s += a[i].v;\n            df2[i] = 1;\n        }\n    }\n    fto(i,1,h)   df[i] = 0;\n    fto(i,1,n){\n        if (df2[i] == 0 && df[a[i].c] == 0){\n            df[a[i].c] = 1;    s += a[i].v;\n        }\n    }\n    res = max(res, s);\n    s = 0;\n    fto(i,1,max(n, max(h, w)))    {df[i] = 0;  df2[i] = 0;}\n    fto(i,1,n){\n        if (df[a[i].c] == 0){\n            df[a[i].c] = 1;    s += a[i].v;\n            df2[i] = 1;\n        }\n    }\n    fto(i,1,h)   df[i] = 0;\n    fto(i,1,n){\n        if (df2[i] == 0 && df[a[i].r] == 0){\n            df[a[i].r] = 1;    s += a[i].v;\n        }\n    }\n    res = max(res, s);\n    cout << res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long \n#define nn 20608\nint n;\nstruct edge{\n\tint x,y,c;\n};\nbool operator<(edge a,edge b){\n\treturn a.c>b.c;\n}\nedge e[nn];\n\nint pa[nn];\nint find(int x){\n\tif(pa[x]==x) return x;\n\treturn pa[x]=find(pa[x]);\n}\nint w,h;int loop[nn];\nint used[nn];\n\nsigned main()\n{\n\tfor(int i=0;i<nn;i++) pa[i]=i;\n\tscanf(\"%lld%lld%lld\",&n,&h,&w);int ans=0;\n\tfor(int i=1;i<=n;i++) scanf(\"%lld%lld%lld\",&e[i].x,&e[i].y,&e[i].c),e[i].y+=nn/2-1;\n\tsort(e+1,e+n+1);\n\tfor(int i=1;i<=n;i++){\n\t\tint x=e[i].x,y=e[i].y;//\n\t\tif(find(x)==find(y)) {\n\t\t\tif(loop[find(x)]==0) loop[find(x)]=1,ans+=e[i].c;\n\t\t\tcontinue;\n\t\t}\n\t\tif(loop[find(x)]&loop[find(y)]) continue;\n\t\tloop[find(y)]|=loop[find(x)];\n\t\tpa[find(x)]=find(y);\n\t\tans+=e[i].c;\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define ALL(c) c.begin(),c.end()\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nclass Data{\npublic:\n\tint index;\n\tll value;\n};\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint N=in(),H=in(),W=in();\n\tvector<vector<Data>> R(H),C(W);\n\tvector<int> F(N,0);\n\tREP(i,N){\n\t\tint r=in()-1,c=in()-1;\n\t\tll a=in<ll>();\n\t\tData d{i,a};\n\t\tR[r].emplace_back(d);\n\t\tC[c].emplace_back(d);\n\t}\n\t//sort(ALL(R),[](vector<Data>& lhs,vector<Data>& rhs){return lhs.size()<rhs.size();});\n\tREP(i,H){\n\t\tsort(ALL(R[i]),[](Data& lhs,Data& rhs){return lhs.value>rhs.value;});\n\t}\n\t//sort(ALL(C),[](vector<Data>& lhs,vector<Data>& rhs){return lhs.size()<rhs.size();});\n\tREP(i,W){\n\t\tsort(ALL(C[i]),[](Data& lhs,Data& rhs){return lhs.value>rhs.value;});\n\t}\n\tll sum = 0;\n\tfor(int i=0;i<H;i++){\n\t\tint l = R[i].size();\n\t\tif(l>1 || l==0) continue;\n\t\tif(F[R[i][0].index]==1) continue;\n\t\tsum += R[i][0].value;\n\t\tF[R[i][0].index]=1;\n\t}\n\tfor(int i=0;i<W;i++){\n\t\tint l = C[i].size();\n\t\tif(l>1 || l==0) continue;\n\t\tif(F[C[i][0].index]==1) continue;\n\t\tsum += C[i][0].value;\n\t\tF[C[i][0].index]=1;\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tint l = R[i].size();\n\t\tfor(int k=0;k<l;k++){\n\t\t\tif(F[R[i][k].index]==1) continue;\n\t\t\tsum += R[i][k].value;\n\t\t\tF[R[i][k].index]=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0;i<W;i++){\n\t\tint l = C[i].size();\n\t\tfor(int k=0;k<l;k++){\n\t\t\tif(F[C[i][k].index]==1) continue;\n\t\t\tsum += C[i][k].value;\n\t\t\tF[C[i][k].index]=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfill(ALL(F),0);\n\tll sum2 = 0;\n\tfor(int i=0;i<W;i++){\n\t\tint l = C[i].size();\n\t\tif(l>1 || l==0) continue;\n\t\tif(F[C[i][0].index]==1) continue;\n\t\tsum2 += C[i][0].value;\n\t\tF[C[i][0].index]=1;\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tint l = R[i].size();\n\t\tif(l>1 || l==0) continue;\n\t\tif(F[R[i][0].index]==1) continue;\n\t\tsum2 += R[i][0].value;\n\t\tF[R[i][0].index]=1;\n\t}\n\tfor(int i=0;i<W;i++){\n\t\tint l = C[i].size();\n\t\tfor(int k=0;k<l;k++){\n\t\t\tif(F[C[i][k].index]==1) continue;\n\t\t\tsum2 += C[i][k].value;\n\t\t\tF[C[i][k].index]=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\tfor(int i=0;i<H;i++){\n\t\tint l = R[i].size();\n\t\tfor(int k=0;k<l;k++){\n\t\t\tif(F[R[i][k].index]==1) continue;\n\t\t\tsum2 += R[i][k].value;\n\t\t\tF[R[i][k].index]=1;\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\tout(max(sum,sum2));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define mod 1000000007\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define repn(i,x) for(int i=1;i<=x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\nstruct uf{\n\tint par[200005],ran[200005],sum[200005];\n\tvoid init(){\n\t\trep(i,200005) { par[i] = i,ran[i] = 0,sum[i] = 0; }\n\t}\n\tint find(int x){\n\t\tif(x == par[x]) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x,int y){\n\t\tx = find(x); y = find(y);\n\t\tif(x == y) return;\n\t\tif(ran[x] < ran[y]){\n\t\t\tpar[x] = y;\n\t\t\tsum[y] += sum[x];\n\t\t}\n\t\telse{\n\t\t\tpar[y] = x;\n\t\t\tsum[x] += sum[y];\n\t\t}\n\t}\n}kaede;\nint n,h,w;\nvector<P1>vec;\nint main(){\n\tscanf(\"%d%d%d\",&n,&h,&w);\n\tfor(int i=1;i<=n;i++){\n\t\tint r,c,a; scanf(\"%d%d%d\",&r,&c,&a);\n\t\tvec.pb(mp(-a,mp(r,100000+c)));\n\t}\n\tSORT(vec);\n\tll ans = 0;\n\tkaede.init();\n\tfor(int i=0;i<vec.size();i++){\n\t\tint x = vec[i].sc.fi , y = vec[i].sc.sc;\n\t\tif(kaede.find(x) != kaede.find(y)){\n\t\t    if(kaede.sum[kaede.find(x)] + kaede.sum[kaede.find(y)] <= 1){\n    \t\t\tkaede.unite(x,y);\n    \t\t\tans -= vec[i].fi;\n\t\t    }\n\t\t}\n\t\telse if(kaede.sum[kaede.find(x)] == 0){\n\t\t\tkaede.sum[kaede.find(x)]++;\n\t\t\tans -= vec[i].fi;\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <complex>\n#include <cassert>\n#include <array>\n#include <bitset> \n#include <unordered_map>\n#include <random>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<LL,LL> P;\n\ntemplate<int Size>\nstruct UF{\n\tUF(){\n\t\tfor(int i=0;i<Size;i++){\n\t\t\trep[i]=i;\n\t\t\tfull[i]=false;\n\t\t}\n\t}\n\tint find(int a){\n\t\twhile(a!=rep[a]){\n\t\t\ta=rep[a]=rep[rep[a]];\n\t\t}\n\t\treturn a;\n\t}\n\n\tint rep[Size];\n\tbool full[Size];\n\tbool uni(int a,int b){\n\t\ta=find(a);\n\t\tb=find(b);\n\t\tif(a==b){\n\t\t\treturn false;\n\t\t}\n\t\trep[a]=b;\n\t\tfull[b]|=full[a];\n\t\treturn true;\n\t}\n};\nconst int L=2e5+1;\ntypedef array<LL, 3> E;\nE e[L];\nUF<L> uf;\nvoid solve(long long N, long long H, long long W, std::vector<long long> R, std::vector<long long> C, std::vector<long long> A){\n\tLL ret=0;\n\tfor(int i=0;i<A.size();i++){\n\t\te[i]=E{{A[i],R[i],C[i]+H}};\n\t}\n\tsort(e,e+A.size());\n\tfor(int i=A.size()-1;i>=0;i--){\n\t\t//cerr << e[i][1] << e[i][2] << endl;\n\t\tint r=uf.find(e[i][1]);\n\t\tint c=uf.find(e[i][2]);\n\t\tif(uf.full[r]&&uf.full[c])continue;\n\t\tif(r==c){\n\t\t\tuf.full[r]=true;\n\t\t\tret+=e[i][0];\n\t\t}\n\t\telse{\n\t\t\tuf.uni(r,c);\n\t\t\tret+=e[i][0];\n\t\t}\n\t\t//cerr << e[i][1] << \" \" << e[i][2] << endl;\n\t}\n\tcout << ret << endl;\n\n}\n\nint main(){\n    long long N;\n    scanf(\"%lld\",&N);\n    long long H;\n    scanf(\"%lld\",&H);\n    long long W;\n    scanf(\"%lld\",&W);\n    std::vector<long long> R(N);\n    std::vector<long long> C(N);\n    std::vector<long long> A(N);\n    for(int i = 0 ; i < N ; i++){\n        scanf(\"%lld\",&R[i]);\n\t\tR[i]--;\n        scanf(\"%lld\",&C[i]);\n\t\tC[i]--;\n        scanf(\"%lld\",&A[i]);\n    }\n    solve(N, H, W, std::move(R), std::move(C), std::move(A));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\n\nclass MergeTech {\npublic:\n\tvector<int> num;\n\tvector<int> group;\n\tvector<vector<int>> G;\n\n\tvoid init(int sz) {\n\t\tnum.resize(sz, 0);\n\t\tgroup.resize(sz, 0);\n\t\tG.resize(sz, vector<int>(0, 0));\n\n\t\tfor (int i = 0; i < sz; i++) { G[i].push_back(i); group[i] = i; }\n\t}\n\tbool unite(int u, int v) {\n\t\tu = group[u]; v = group[v];\n\t\tif (u == v) {\n\t\t\tif ((int)G[u].size() > num[u]) {\n\t\t\t\tnum[u]++; return true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint Total1 = G[u].size() + G[v].size();\n\t\t\tint Total2 = num[u] + num[v];\n\n\t\t\tif (Total1 > Total2) {\n\t\t\t\tif (G[u].size() < G[v].size()) swap(u, v);\n\t\t\t\tfor (int i = 0; i < G[v].size(); i++) {\n\t\t\t\t\tgroup[G[v][i]] = u;\n\t\t\t\t\tG[u].push_back(G[v][i]);\n\t\t\t\t}\n\t\t\t\tnum[u] += num[v]; num[v] = 0; G[v].clear();\n\t\t\t\tnum[u]++;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n};\n\nlong long N, H, W, A[200009], B[200009], C[200009], Total;\nvector<tuple<long long, long long, long long>> tup;\nMergeTech UF;\n\nint main() {\n\tcin >> N >> H >> W;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> A[i] >> B[i] >> C[i]; A[i]--; B[i]--;\n\t\ttup.push_back(make_tuple(C[i], A[i], B[i] + H));\n\t}\n\tsort(tup.begin(), tup.end());\n\tUF.init(H + W + 2);\n\n\tfor (int i = tup.size() - 1; i >= 0; i--) {\n\t\tbool G = UF.unite(get<1>(tup[i]), get<2>(tup[i]));\n\t\tif (G == true) Total += 1LL * get<0>(tup[i]);\n\t}\n\tcout << Total << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0; i<(n); i++)\nusing ll = long long;\nusing P = pair<int, int>;\nconst int MX = 100005;\nint n, u, h, w, a, r[MX], c[MX];\nP pr[MX];\nll ans;\nint p[MX*2], fu[MX*2];\nvoid ufini(int n){ fill(p, p+n, -1);}\nint find(int x){return (p[x] < 0 ? x : p[x] = find(p[x]));}\nvoid uni(int x, int y, int z){\n\tx = find(x); y = find(y);\n\tif(x != y){\n\t\tif(p[x] > p[y]) swap(x, y);\n\t\tp[x] += p[y];\n\t\tp[y] = x;\n\t\tans += z - min({fu[x], fu[y], z});\n\t\tfu[x] = max({fu[x], fu[y]});\n\t}else if(!fu[x]){\n\t\tans += z;\n\t\tfu[x] = z;\n\t}\n}\n\nint main(){\n\tscanf(\"%d%d%d\", &n, &h, &w);\n\tu = h + w;\n\trep(i,n){\n\t\tscanf(\"%d%d%d\", r+i, c+i, &a);\n\t\tr[i]--; c[i]--;\n\t\tpr[i] = P(a,i);\n\t}\n\tsort(pr,pr+n, greater<P>());\n\tufini(u);\n\trep(i,n) uni(r[pr[i].second], h+c[pr[i].second], pr[i].first);\n\tprintf(\"%lld\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<unordered_map>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include<utility>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\nlong long p9 = 998244353;\nlong long p1 = 1000000007;\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define int long long\n#define vel vector<long long>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp(a,b) make_pair(a,b)\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\n#define pb push_back\nvel kai;\nvel inv_kai;\nvel inv;\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(int x, int y) {\n\tx = abs(x); y = abs(y);\n\treturn x * (y / gcd(x, y));\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_inv(int max_inv, int p) {\n\tinv = vel(max_inv + 1, 1);\n\tfor (int i = 2; i <= max_inv; i++) {\n\t\tinv[i] = p - ((p / i) * inv[p % i]) % p;\n\t}\n}\nvoid make_kai(int max_kai, int p) {\n\tkai = vel(max_kai + 1, 1);\n\tinv_kai = kai;\n\tmake_inv(max_kai, p);\n\trep(i, max_kai) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = inv_kai[i] * inv[i + 1]; inv_kai[i + 1] %= p;\n\t}\n}\nint com(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nint per(int n, int r, int p) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\treturn (kai[n] * inv_kai[n - r]) % p;\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nV<V<pin>> make_w(vvel v) {\n\tint n = v.size();\n\tV<V<pin>> ret(n);\n\trep(i, n) {\n\t\tfor (int x : v[i]) {\n\t\t\tret[i].push_back(mkp(x, 1));\n\t\t}\n\t}\n\treturn ret;\n}\nvoid make_tree(vvel& chi, vel& par, int n) {\n\tV<V<pin>> way(n);\n\trep(i, n - 1) {\n\t\tint a, b; cin >> a >> b; a--; b--;\n\t\tway[a].push_back(mkp(b, 1));\n\t\tway[b].push_back(mkp(a, 1));\n\t}\n\tvel dist = dijk(way, 0, n + 1);\n\tpar = vel(n, -1);\n\tchi = vvel(n);\n\trep(i, n) {\n\t\tfor (auto nex : way[i]) {\n\t\t\tint pot = nex.first;\n\t\t\tif (dist[pot] > dist[i]) { chi[i].push_back(pot); }\n\t\t\telse { par[i] = pot; }\n\t\t}\n\t}\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\n#define ui long long\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\twhile (i >= 0) {\n\t\tif (dv[i][l] > dv[i][r - (1 << i)]) {\n\t\t\tl = r - (1 << i);\n\t\t}\n\t\telse {\n\t\t\tr = l + (1 << i);\n\t\t}\n\t\ti--;\n\t}\n\treturn l;\n}\nV<V<pin>> dbl(V<pin>& v) {\n\tV<V<pin>> ans(20, V<pin>(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j].first = ans[i][ans[i][j].first].first;\n\t\t\tans[i + 1][j].second = max(ans[i][j].second, ans[i][ans[i][j].first].second);\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, V<V<pin>>& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\tint ans = 0;\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\tmmax(ans, pa[i][s].second);\n\t\t\ts = pa[i][s].first;\n\t\t\tmmax(ans, pa[i][t].second);\n\t\t\tt = pa[i][t].first;\n\t\t}\n\t}\n\tif (s != t) {\n\t\tmmax(ans, pa[0][s].second);\n\t\tmmax(ans, pa[0][t].second);\n\t}\n\treturn ans;\n}\nvoid alp(int n, vel& pr) {\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) {\n\t\t\tpr.push_back(i);\n\t\t\twhile (n % i == 0) { n /= i; }\n\t\t}\n\t}\n\tif (n != 1) { pr.push_back(n); }\n}\nvel dx = { 0,0,-1,1 };\nvel dy = { 1,-1,0,0 };\nint sol(int p, vel& max_h, vvel& way) {\n\tif (max_h[p] == -1) {\n\t\tmax_h[p] = 0;\n\t\tfor (auto nex : way[p]) {\n\t\t\tmmax(max_h[p], sol(nex, max_h, way) + 1);\n\t\t}\n\t}\n\treturn max_h[p];\n}\nint inc(int a, veb& use) {\n\ta++;\n\twhile (!use[a]) { a++; }\n\treturn a;\n}\nsigned main() {\n\tomajinai;\n\tint n, h, w; cin >> n >> h >> w;\n\tvvel cxy(n);\n\tV<V<pin>> y_ci(w);\n\tV<V<pin>> x_ci(h);\n\trep(i, n) {\n\t\tint c, x, y; cin >> x >> y >> c; x--; y--;\n\t\tcxy[i] = { c,i,x,y };\n\t\ty_ci[y].push_back(mkp(c, i));\n\t\tx_ci[x].push_back(mkp(c, i));\n\t}\n\tsor(cxy);\n\tvel dp0(n, 0);\n\tvel dp1(n, 0);\n\tvel cnt(n, 0);\n\tvel sum(n + 1, 0);\n\trep(i, w) { \n\t\tsor(y_ci[i]);\n\t\tif (y_ci[i].size() != 0) {\n\t\t\tcnt[y_ci[i].back().second]++;\n\t\t}\n\t}\n\trep(i, h) { \n\t\tsor(x_ci[i]);\n\t\tif (x_ci[i].size() != 0) {\n\t\t\tcnt[x_ci[i].back().second]++;\n\t\t}\n\t}\n\tvel inv_o(n);\n\trep(i, n) {\n\t\tinv_o[cxy[i][1]] = i;\n\t}\n\trep(i, n) {\n\t\tint ind = cxy[i][1];\n\t\tint c = cxy[i][0];\n\t\tint x = cxy[i][2];\n\t\tint y = cxy[i][3];\n\t\tint it = lowerbound(x_ci[x], mkp(c, ind));\n\t\tit--;\n\t\tif (it >= 0) {\n\t\t\tpin nex = x_ci[x][it];\n\t\t\tint nind = inv_o[nex.second];\n\t\t\tif (cnt[nind] == 0) {\n\t\t\t\tmmax(dp1[i], cxy[inv_o[nind]][0]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmmax(dp1[i], dp1[inv_o[nind]]);\n\t\t\t}\n\t\t}\n\t\tit = lowerbound(y_ci[y], mkp(c, ind));\n\t\tit--;\n\t\tif (it >= 0) {\n\t\t\tpin nex = y_ci[y][it];\n\t\t\tint nind = inv_o[nex.second];\n\t\t\tif (cnt[nind] == 0) {\n\t\t\t\tmmax(dp1[i], cxy[inv_o[nind]][0]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmmax(dp1[i], dp1[inv_o[nind]]);\n\t\t\t}\n\t\t}\n\t\tint back = 0;\n\t\tif (i != 0) { back = dp0[i - 1]; }\n\t\tif (cnt[ind] <= 1) {\n\t\t\tdp0[i] = back + cnt[ind] * c;\n\t\t}\n\t\telse {\n\t\t\tdp0[i] = back + dp1[i] + c;\n\t\t}\n\t}\n\tcout << dp0.back() << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\nint n,h,w;\nint a[100005],xx[100005],yy[100005];\nmultiset<pair<int,pair<int,int> > >S;\nvector<int>g[2][100005];\nstruct ssss{\n\tint par[200005];\n\tssss(){for(int i=1;i<=200002;i++)par[i]=i;}\n\tint find(int x){\n\t\treturn par[x]==x?x:par[x]=find(par[x]);\n\t}\n\tvoid merge(int x,int y){\n\t\tint nx=find(x),ny=find(y);\n\t\tpar[nx]=ny;\n\t}\n}uf;\nbool dead[2][100005];\n#define kill ffweifnweoifnweoif\nvoid kill(int op,int x){\n//\tcerr<<op<<\" \"<<x<<endl;\n\tdead[op][x]=1;\n\tfor(int i=0;i<g[op][x].size();i++){\n\t\tif(dead[op^1][g[op][x][i]])continue;\n\t\tkill(op^1,g[op][x][i]);\n\t}\n}\nbool can(int x,int y){\n\tif(dead[0][x]&&dead[1][y])return false;\n\tif(dead[0][x]){\n\t\tkill(1,y);\n\t\treturn true;\n\t}\n\tif(dead[1][y]){\n\t\tkill(0,x);\n\t\treturn true;\n\t}\n\tif(uf.find(x)==uf.find(y+1e5)){\n\t\tkill(0,x);\n\t}else{\n\t\tg[0][x].push_back(y);\n\t\tg[1][y].push_back(x);\n\t\tuf.merge(x,y+1e5);\n\t}\n\treturn true;\n}\nsigned main(){\n\tcin>>n>>h>>w;\n\tfor(int i=1;i<=n;i++){\n\t\tcin>>xx[i]>>yy[i]>>a[i];\n\t\tS.insert(make_pair(-a[i],make_pair(xx[i],yy[i])));\n\t}\n\tint ans=0;\n\twhile(!S.empty()){\n\t\tif(can(S.begin()->second.first,S.begin()->second.second)){\n\t\t\tans-=S.begin()->first;\n\t\t}\n\t\tS.erase(S.begin());\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define name \"main\"\n#define pii pair<int,int>\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define fto(i,a,b) for(int i=a; i<=b;++i)\n#define maxn 100009\n#define ll long long\n\nusing namespace std;\nbool gone[maxn][3],ck[maxn][3];\nint cl[maxn];\nint xd[maxn][3],a[maxn][3],w,h,n;\npii b[maxn];\nbool check(int i, int x,int j){\n    if(ck[i][x])return false;\n    ck[i][x]=true;\n    int t=xd[i][x];\n    if(xd[i][x]==0){\n        xd[i][x]=j;\n        ck[i][1-x]=false;\n        return true;\n    }\n    /// xd[i][x]!=0;\n    /// i,x la cot hoac hang, j la chi so can dien\n    /// t la so can dien\n    if(check(a[t][1-x],1-x,t)){\n        xd[i][x]=j;\n        ck[i][1-x]=false;\n        return true;\n    }\n    return false;\n}\nint main()\n{\n    cin >> n >> h >> w;\n    fto(i,1,n){\n        cin >> a[i][0]>> a[i][1] >> b[i].fi;\n        b[i].se=i;\n    }\n    sort(b+1,b+n+1,greater<pii> ());\n    ll res=0;\n    fto(i,1,n){\n        int j=b[i].se;\n        if(check(a[j][0],0,j)){\n            //xd[a[j][0]][0]=j;\n            res+=b[i].fi;\n        }\n        else if(check(a[j][1],1,j)){\n            //xd[a[j][1]][1]=j;\n            res+=b[i].fi;\n        }\n    }\n    cout << res ;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\ntypedef long long ll;\n#define mod 1000000007\n#define N 100010\nll h,w,n;\nbool used[N],usee[N];\nstruct edge{\n  ll a,b,c;\n  edge(ll a,ll b,ll c){\n      this->a=a,this->b=b,this->c=c;\n  } \n  bool operator<(const edge&key)const{\n      return this->c>key.c;\n  } \n};\nvector<edge> v;\nint main(){\n  cin>>n>>h>>w;\n  for(int i=0;i<n;i++){\n      ll a,b,c; cin>>a>>b>>c;\n      v.push_back(edge(a,b,c));\n  }\n  sort(v.begin(),v.end());\n  ll ans=0;\n  for(int i=1;i<=h;i++)used[i]=0;\n  for(int i=1;i<=w;i++)usee[i]=0;\n  for(int i=0;i<n;i++){\n      if(usee[v[i].b]==0){\n\t  usee[v[i].b]=1;\n\t  ans+=v[i].c;\n\t  continue;\n      }\n      if(used[v[i].a]==0){\n\t  used[v[i].a]=1;\n\t  ans+=v[i].c;\n\t  continue;\n      }\n  }\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n \nint main() {\n    int N, H, W; cin >> N >> H >> W;\n    vector<ll> R(H), C(W);\n\n    priority_queue< tuple<int, int, int> > que;\n    ll ans = 0;\n    for(int i=0; i<N; i++) {\n        int r, c, a; cin >> r >> c >> a; r--; c--;\n        que.emplace(a, r, c);\n    }\n\n    int take = 0;\n    map< pair<int, int>, int > cnt;\n    while(que.size()) {\n        int a, r, c; tie(a, r, c) = que.top(); que.pop();\n        if(R[r] + 1 <= W + 1 and\n           C[c] + 1 <= H + 1 and\n           take + 1 <= H + W and\n           cnt[make_pair(r, c)] + 1 <= 2) {\n            // fprintf(stderr, \"r = %d, c = %d, a = %d\\n\", r, c, a);\n            ans += a;\n            R[r]++;\n            C[c]++;\n            take++;\n            cnt[make_pair(r, c)]++;\n        }\n    }\n\n    /*\n    for(int i=0; i<H; i++) fprintf(stderr, \"H[%d] = %d\\n\", i, R[i]);\n    for(int i=0; i<W; i++) fprintf(stderr, \"W[%d] = %d\\n\", i, C[i]);\n    */    \n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define ll long long\n#define pb push_back\n#define pii pair<int,int>\n#define mp make_pair\n#define fi first\n#define se second\n#define eb emplace_back\nusing namespace std;\nconst int mod = 1e9 + 7;\nconst int maxn = 2e5 + 233;\nstruct Point{\n\tint x,y,w;\n}a[maxn];\nbool cmp(const Point& A,const Point& B){\n\treturn A.w>B.w;\n}\nint f[maxn],siz[maxn],cnt[maxn];\nint find(int x){\n\treturn f[x]==x?x:f[x]=find(f[x]);\n}\nint main()\n{\n\tint n,h,w;cin>>n>>h>>w;\n\tfor(int i=1;i<=n;i++)scanf(\"%d%d%d\",&a[i].x,&a[i].y,&a[i].w);\n\tsort(a+1,a+1+n,cmp);\n\tll ans = 0;\n\tfor(int i=1;i<=h+w;i++)f[i] = i,siz[i] = 1,cnt[i] = 0;\n\tfor(int i=1;i<=n;i++){\n\t\tint x = a[i].x,y = a[i].y+h;\n\t\tint p = find(x),q = find(y);\n\t\tif(p==q){\n\t\t\tif(siz[p]>cnt[p]){\n\t\t\t\tcnt[p]++;\n\t\t\t\tans += a[i].w;\n\t\t\t}\n\t\t}\n\t\telse{\n\t\t\tif(siz[q]==cnt[q]&&siz[p]==cnt[p])continue;\n\t\t\tf[q] = p;\n\t\t\tsiz[p] += siz[q];\n\t\t\tcnt[p] += cnt[q];\n\t\t\tcnt[p]++;\n\t\t\tans += a[i].w;\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))\n#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))\n#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; -- (i))\n#define REP3R(i, m, n) for (int i = (int)(n) - 1; (i) >= (int)(m); -- (i))\n#define ALL(x) begin(x), end(x)\n#define dump(x) cerr << #x \" = \" << x << endl\nusing ll = long long;\nusing namespace std;\ntemplate <class T> using reversed_priority_queue = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class U> inline void chmax(T & a, U const & b) { a = max<T>(a, b); }\ntemplate <class T, class U> inline void chmin(T & a, U const & b) { a = min<T>(a, b); }\ntemplate <typename X, typename T> auto make_vectors(X x, T a) { return vector<T>(x, a); }\ntemplate <typename X, typename Y, typename Z, typename... Zs> auto make_vectors(X x, Y y, Z z, Zs... zs) { auto cont = make_vectors(y, z, zs...); return vector<decltype(cont)>(x, cont); }\ntemplate <typename T> ostream & operator << (ostream & out, vector<T> const & xs) { REP (i, (int)xs.size() - 1) out << xs[i] << ' '; if (not xs.empty()) out << xs.back(); return out; }\ntemplate<typename Functor> struct fix_type { Functor functor; template<typename... Args> decltype(auto) operator() (Args && ... args) const & { return functor(functor, std::forward<Args>(args)...); } };\ntemplate<typename Functor> fix_type<typename std::decay<Functor>::type> fix(Functor && functor) { return { std::forward<Functor>(functor) }; }\n\nll solve(int n, int h, int w, const vector<int> & y, const vector<int> & x, const vector<ll> & a) {\n    vector<int> row(h, -1), col(w, -1);\n    unordered_set<int> used_row, used_col;\n    function<bool (int, int)> go_row, go_col;\n    go_row = [&](int y, int i) {\n        if (used_row.count(y)) return false;\n        used_row.insert(y);\n        if (row[y] == -1) {\n            row[y] = i;\n            return true;\n        } else {\n            int j = row[y];\n            bool p = go_col(x[j], j);\n            if (p) row[y] = i;\n            return p;\n        }\n    };\n    go_col = [&](int x, int i) {\n        if (used_col.count(x)) return false;\n        used_col.insert(x);\n        if (col[x] == -1) {\n            col[x] = i;\n            return true;\n        } else {\n            int j = col[x];\n            bool p = go_row(y[j], j);\n            if (p) col[x] = i;\n            return p;\n        }\n    };\n\n    ll answer = 0;\n\n    vector<int> order(n);\n    iota(ALL(order), 0);\n    sort(ALL(order), [&](int i, int j) { return a[i] > a[j]; });\n    for (int i : order) {\n        used_row.clear();\n        used_col.clear();\n        if (go_row(y[i], i)) {\n            row[y[i]] = i;\n            answer += a[i];\n        } else if (go_col(x[i], i)) {\n            col[x[i]] = i;\n            answer += a[i];\n        }\n    }\n    return answer;\n}\n\nint main() {\n    int n, h, w; cin >> n >> h >> w;\n    vector<int> y(n), x(n);\n    vector<ll> a(n);\n    REP (i, n) {\n        cin >> y[i] >> x[i] >> a[i];\n        -- y[i];\n        -- x[i];\n    }\n    cout << solve(n, h, w, y, x, a) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint ds[200100], isFull[200100];\n\nint get(int x)\n{\n  return ds[x] == x ? x : ds[x] = get(ds[x]);\n}\n\nint main()\n{\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n\n  int n, h, w, r, c, a;\n  vector<pair<int, int>> edges[100100];\n  cin >> n >> h >> w;\n  while (n--)\n  {\n    cin >> r >> c >> a;\n    edges[a].push_back({r, c + h});\n  }\n\n  for (int i = 1; i <= w + h; i++)\n    ds[i] = i;\n\n  long long ans = 0;\n  for (int a = 100000; a; a--)\n    for (auto u : edges[a])\n    {\n      int x = get(u.first), y = get(u.second);\n      if (x != y)\n      {\n        if (isFull[x] && isFull[y])\n          continue;\n        ds[x] = y;\n        isFull[y] |= isFull[x];\n        ans += a;\n      }\n      else if (!isFull[x])\n      {\n        ans += a;\n        isFull[x] = 1;\n      }\n    }\n\n  cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn=1e5+10;\ntypedef long long ll;\n#define inf 0x3f3f3f3f\nint n,h,w;\nint x[maxn],y[maxn];\nll a[maxn];\npriority_queue<pair<ll,int> > qx[maxn],qy[maxn];\npair<ll,int> cards[maxn];\nll ax,ay;\nbool ux[maxn],uy[maxn];\nint main()\n{\n\tscanf(\"%d%d%d\",&n,&h,&w);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tscanf(\"%d%d%lld\",&x[i],&y[i],&a[i]);\n\t\tx[i]--;\n\t\ty[i]--;\n\t\tcards[i]=make_pair(a[i],i);\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tqx[x[i]].push(make_pair(a[i],i));\n\t\tqy[y[i]].push(make_pair(a[i],i));\n\t}\n    sort(cards,cards+n);\n    reverse(cards,cards+n);\n    ll ans=0;\n    for(int _=0;_<n;_++)\n    {\n    \tint i=cards[_].second;\n\t//\tcout<<i<<\" \"<<x[i]<<\" \"<<y[i]<<\" \"<<qx[x[i]].top().second<<\" \"<<qy[y[i]].top().second<<endl;\n        qx[x[i]].pop();\n        qy[y[i]].pop();\n        if(ux[x[i]]&&uy[y[i]])continue;\n        if(ux[x[i]])\n        \tuy[y[i]]=1;\n        else if(uy[y[i]])\n        \tux[x[i]]=1;\n        else\n\t\t{\n\t\t\tax=qx[x[i]].empty()?-inf:qx[x[i]].top().first;\n\t\t\tay=qy[y[i]].empty()?-inf:qy[y[i]].top().first;\n\t\t\tif(ax<ay)\n\t\t\t{\n        //   \tcout<<\"puthang \"<<x[i]<<endl;\n            \tux[x[i]]=1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n      \t//    \tcout<<\"putlie \"<<y[i]<<endl;\n \t    \t\tuy[y[i]]=1;\n \t    \t}\n        }\n        ans+=a[i];\n    }\n    printf(\"%lld\\n\",ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define MAXN 100000\n#define LL long long\nint n,h,w;LL ans;\nstruct edge{\n\tint u,v,w;\n}e[MAXN+1];\nint fa[MAXN*2+1],siz[MAXN*2+1],used[MAXN*2+1];\nint read(){\n\tint x=0,F=1;char c=getchar();\n\twhile(c<'0'||c>'9'){if(c=='-')F=-1;c=getchar();}\n\twhile(c>='0'&&c<='9'){x=x*10+c-'0';c=getchar();}\n\treturn x*F;\n}\nbool cmp(edge s1,edge s2){\n\treturn s1.w>s2.w;\n}\nint xfind(int x){\n\tif(fa[x]==x)return x;\n\treturn fa[x]=xfind(fa[x]);\n}\nint main()\n{\n\tn=read(),h=read(),w=read();\n\tfor(int i=1;i<=n;i++)\n\te[i]=(edge){read(),read()+MAXN,read()};\n\tfor(int i=1;i<=MAXN*2;i++)fa[i]=i,siz[i]=1;\n\tsort(e+1,e+n+1,cmp);\n\tfor(int i=1;i<=n;i++){\n\t\tint a=xfind(e[i].u),b=xfind(e[i].v);\n\t\tif(a==b){\n\t\t\tif(siz[a]>=used[a]+1){\n\t\t\t\tused[a]++;\n\t\t\t\tans+=e[i].w;\n\t\t\t}\n\t\t}else{\n\t\t\tif(siz[a]+siz[b]>=used[a]+used[b]+1){\n\t\t\t\tused[a]+=used[b]+1;\n\t\t\t\tsiz[a]+=siz[b];\n\t\t\t\tans+=e[i].w;\n\t\t\t\tfa[b]=a;\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%lld\",ans);\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#pragma GCC optimize(\"unroll-loops\")\n//#pragma warning(disable : 4996)\n\n#ifdef _MSC_VER\n#include <intrin.h>\n#define __builtin_popcount __popcnt\n#define __builtin_popcountll __popcnt64\n#endif\n\n#include <limits.h>\n#include <math.h>\n#include <time.h>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <stack>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\n#define REP(i, n) for (int i = 0; i < (n); ++i)\n#define REPR(i, n) for (int i = n - 1; i >= 0; --i)\n#define FOR(i, m, n) for (int i = m; i < n; ++i)\n#define FORR(i, m, n) for (int i = m - 1; i >= n; --i)\n#define SORT(v, n) sort(v, v + n);\n#define VSORT(v) sort(v.begin(), v.end());\n#define REVERSE(v, n) reverse(v, v + n);\n#define VREVERSE(v) reverse(v.begin(), v.end())\n#define ll long long\n#define print(x) cout << (x) << '\\n'\n#define pe(x) cout << (x) << \" \"\n#define DEBUG(x) cout << #x << \": \" << x << endl\n#define lb(v, n) lower_bound(v.begin(), v.end(), (n))\n#define ub(v, n) upper_bound(v.begin(), v.end(), (n))\n#define int long long\n//#define double long double\n#define all(x) (x).begin(), (x).end()\n#define print_space(v) REP(i, v.size()) cout << v[i] << \" \\n\"[i==(int)v.size()-1]\ntemplate <typename T1, typename T2> inline void chmin(T1& a, T2 b) { if (a > b) a = b; }\ntemplate <typename T1, typename T2> inline void chmax(T1& a, T2 b) { if (a < b) a = b; }\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\nstd::random_device rd;\nstd::mt19937 mt(rd());\nconstexpr ll MOD = 1e9 + 7;\nconstexpr int MAX = 500050;\nconst double pi = acos(-1);\nconstexpr double EPS = 1e-8;\nconstexpr ll LINF = 1e18 + 1;\nconstexpr int INF = 1e9 + 1;\n//int dx[4] = { 0,0,-1,1 }, dy[4] = { 1,-1,0,0 };\n\n\n\nstruct UnionFind {\n\tint N;\n\tvector<int> siz;\n\tvector<int> par;\n\tvector<int> Rank;\n\tvector<bool>hasloop;\n\tUnionFind(int n) : siz(n, 1), par(n), Rank(n, 0),hasloop(n,false){\n\t\tN = n;\n\t\tfor (int i = 0; i < N; i++) par[i] = i;\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\n\t\tif (Rank[x] < Rank[y]) {\n\t\t\tpar[x] = y;\n\t\t\tsiz[x] += siz[y];\n\t\t\tsiz[y] = siz[x];\n\t\t}\n\t\telse {\n\t\t\tsiz[y] += siz[x];\n\t\t\tsiz[x] = siz[y];\n\t\t\tpar[y] = x;\n\t\t\tif (Rank[x] == Rank[y]) Rank[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n};\n\nvoid solve() {\n\tint N, H, W;\n\tcin >> N >> H >> W;\n\tusing arr3 = array<int, 3>;\n\tvector<arr3>v;\n\tUnionFind uf(H + W);\n\tREP(i, N) {\n\t\tint x, y, a; cin >> x >> y >> a;\n\t\tx--, y--;\n\t\tv.push_back({ a,x,y });\n\t}\n\tVSORT(v); VREVERSE(v);\n\tll ans = 0;\n\tfor (auto A : v) {\n\t\tint x = A[1], y = A[2], c = A[0];\n\t\tint a = x, b = H + y;\n\t\ta = uf.find(a), b = uf.find(b);\n\t\tif (uf.hasloop[a] && uf.hasloop[b])continue;\n\t\telse if (uf.hasloop[a]) {\n\t\t\tif (uf.same(a, b))continue;\n\t\t\telse {\n\t\t\t\tans += c;\n\t\t\t\tuf.unite(a, b);\n\t\t\t\tuf.hasloop[uf.find(b)] = true;\n\t\t\t}\n\t\t}\n\t\telse if (uf.hasloop[b]) {\n\t\t\tif (uf.same(a, b))continue;\n\t\t\telse {\n\t\t\t\tans += c;\n\t\t\t\tuf.unite(a, b);\n\t\t\t\tuf.hasloop[uf.find(a)] = true;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tif (uf.same(a, b)) {\n\t\t\t\tans += c;\n\t\t\t\tuf.unite(a, b);\n\t\t\t\tuf.hasloop[uf.find(a)] = uf.hasloop[uf.find(b)] = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tans += c;\n\t\t\t\tuf.unite(a, b);\n\t\t\t}\n\t\t}\n\t}\n\tprint(ans);\n}\n\n\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t//int q;\n\t//cin >> q;\n\t//while (q--)\n\t\tsolve();\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define For(i,x,y) for (register int i=(x);i<=(y);i++)\n#define FOR(i,x,y) for (register int i=(x);i<(y);i++)\n#define Dow(i,x,y) for (register int i=(x);i>=(y);i--)\n#define Debug(v) for (auto i:v) printf(\"%lld \",i);puts(\"\")\n#define mp make_pair\n#define fi first\n#define se second\n#define pb push_back\n#define ep emplace_back\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define fil(a,b) memset((a),(b),sizeof(a))\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pa;\ntypedef pair<ll,ll> PA;\ntypedef vector<int> poly;\ninline ll read(){\n    ll x=0,f=1;char c=getchar();\n    while ((c<'0'||c>'9')&&(c!='-')) c=getchar();\n    if (c=='-') f=-1,c=getchar();\n    while (c>='0'&&c<='9') x=x*10+c-'0',c=getchar();\n    return x*f;\n}\n\nconst int N = 1e5+10;\nint n,w,h;\nstruct node{\n\tint x,y,z;\n}a[N];\n\nint fa[N<<1],flag[N<<1];\ninline int Find(int x){\n\treturn fa[x]==x?x:fa[x]=Find(fa[x]);\n}\ninline bool check(int x,int y){\n\tint a=Find(x),b=Find(y+w);\n\tif (a!=b){\n\t\tfa[a]=b,flag[a]|=flag[b];\n\t\treturn 1;\n\t} else if (flag[a]) return 0;\n\telse return flag[a]=1;\n}\n\nint main(){\n\tn=read(),w=read(),h=read();\n\tFor(i,1,n) a[i]=(node){read(),read(),read()};\n\tsort(a+1,a+1+n,[](node a,node b){\n\t\treturn a.z>b.z;\n\t});\n\tFor(i,1,w+h) fa[i]=i;\n\tll ans=0,cnt=0;\n\tFor(i,1,n) if (check(a[i].x,a[i].y)){\n\t\t++cnt,ans+=a[i].z;\n\t\tif (cnt==w+h) break;\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "C",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 100010;\nstruct dat {\n    int a,r,c;\n    bool operator<(const dat x)const {\n        return a>x.a;\n    }\n}p[N];\nint n,h,w,fa[N<<1],vl[N<<1],ans;\nint find(int u) {\n    return fa[u]==u?u:fa[u]=find(fa[u]);\n}\nvoid ut(int u,int v) {\n    int fu=find(u),fv=find(v);\n    if(fu!=fv) {\n        fa[fu]=fv;\n        vl[fv]+=vl[fu];\n    }\n}\nint main() {\n    scanf(\"%d%d%d\",&n,&h,&w);\n    for(int i=1;i<=h+w;i++) fa[i]=i,vl[i]=1;\n    for(int i=1;i<=n;i++) {\n        scanf(\"%d%d%d\",&p[i].r,&p[i].c,&p[i].a);\n        p[i].c+=h;\n    }\n    sort(p+1,p+n+1);\n    for(int i=1;i<=n;i++) {\n        ut(p[i].c,p[i].r);\n        int f=find(p[i].c);\n        // printf(\"fa[%d]=%d %d\\n\",f,vl[f],p[i].a);\n        if(vl[f]>=1) {\n            vl[f]--;\n            ans+=p[i].a;\n        }\n    }\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n\tint key, id;\n} data;\n\ntypedef struct {\n\tdata *obj;\n\tint size;\n} max_heap;\n\nvoid push(data x, max_heap* h)\n{\n\tint i = h->size;\n\tdata tmp;\n\th->obj[(h->size)++] = x;\n\twhile (1) {\n\t\tif (i == 0) break;\n\t\telse if (h->obj[i].key > h->obj[(i-1)/2].key) {\n\t\t\ttmp = h->obj[(i-1)/2];\n\t\t\th->obj[(i-1)/2] = h->obj[i];\n\t\t\th->obj[i] = tmp;\n\t\t\ti = (i - 1) / 2;\n\t\t} else break;\n\t}\n}\n\ndata pop(max_heap* h)\n{\n\tint i = 0, j;\n\tdata output = h->obj[0], tmp;\n\th->obj[0] = h->obj[--(h->size)];\n\twhile (1) {\n\t\tif (i * 2 + 1 >= h->size) break;\n\t\telse if (i * 2 + 2 >= h->size) j = i * 2 + 1;\n\t\telse if (h->obj[i*2+1].key > h->obj[i*2+2].key) j = i * 2 + 1;\n\t\telse j = i * 2 + 2;\n\t\tif (h->obj[j].key > h->obj[i].key) {\n\t\t\ttmp = h->obj[j];\n\t\t\th->obj[j] = h->obj[i];\n\t\t\th->obj[i] = tmp;\n\t\t\ti = j;\n\t\t} else break;\n\t}\n\treturn output;\n}\n\ntypedef struct {\n\tint *par, *size, *height, *flag;\n} UF_forest;\n\nvoid UF_initialize(UF_forest *F, int n)\n{\n\tint i;\n\tF->par = (int*)malloc(sizeof(int) * (n + 1));\n\tF->size = (int*)malloc(sizeof(int) * (n + 1));\n\tF->height = (int*)malloc(sizeof(int) * (n + 1));\n\tF->flag = (int*)malloc(sizeof(int) * (n + 1));\n\tfor (i = 1; i <= n; i++) {\n\t\tF->par[i] = i;\n\t\tF->size[i] = 1;\n\t\tF->height[i] = 1;\n\t\tF->flag[i] = 0;\n\t}\n}\n\nvoid UF_merge(UF_forest *F, int u, int v)\n{\n\tfor (; F->par[u] != u; u = F->par[u]);\n\tfor (; F->par[v] != v; v = F->par[v]);\n\tif (u == v) return;\n\telse if (F->height[u] > F->height[v]) {\n\t\tF->par[v] = u;\n\t\tF->size[u] += F->size[v];\n\t\tF->flag[u] |= F->flag[v];\n\t} else {\n\t\tF->par[u] = v;\n\t\tF->size[v] += F->size[u];\n\t\tF->flag[v] |= F->flag[u];\n\t\tif (F->height[u] == F->height[v]) F->height[v]++;\n\t}\n}\n\nint UF_root(UF_forest *F, int v)\n{\n\tfor (; F->par[v] != v; v = F->par[v]);\n\treturn v;\n}\n\nint main()\n{\n\tint i, N, H, W, A[100001], R[100001], C[100001];\n\tscanf(\"%d %d %d\", &N, &H, &W);\n\tfor (i = 1; i <= N; i++) scanf(\"%d %d %d\", &(R[i]), &(C[i]), &(A[i]));\n\t\n\tdata d;\n\tmax_heap h;\n\th.size = 0;\n\th.obj = (data*)malloc(sizeof(data) * (N + 1));\n\tfor (i = 1; i <= N; i++) {\n\t\td.key = A[i];\n\t\td.id = i;\n\t\tpush(d, &h);\n\t}\n\t\n\tint r[2];\n\tlong long ans = 0;\n\tUF_forest F;\n\tUF_initialize(&F, H + W);\n\twhile (h.size > 0) {\n\t\td = pop(&h);\n\t\tr[0] = UF_root(&F, R[d.id]);\n\t\tr[1] = UF_root(&F, C[d.id] + H);\n\t\tif (r[0] != r[1] && F.flag[r[0]] + F.flag[r[1]] <= 1) {\n\t\t\tans += d.key;\n\t\t\tUF_merge(&F, r[0], r[1]);\n\t\t} else if (F.flag[r[0]] == 0) {\n\t\t\tans += d.key;\n\t\t\tF.flag[r[0]] = 1;\n\t\t}\n\t}\n\t\n\tprintf(\"%lld\\n\", ans);\n\tfflush(stdout);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n#include <stdint.h>\n#include <stdlib.h>\nint acs(const void *a, const void *b){return *(int*)a - *(int*)b;} /* 1,2,3,4.. */\nint des(const void *a, const void *b){return *(int*)b - *(int*)a;} /* 8,7,6,5.. */\n\n#define MAXN (100000*2+1)\n#define MOD (1000000007)\n\n//Union Find\nint uf[MAXN];\nint ufSize[MAXN];\nvoid UFinit(int n)\n{\n    for(int i=0;i<n;i++)\n    {\n        uf[i] = i;\n        ufSize[i] = 1;\n    }\n}\n\nint UFroot(int i)\n{\n    if(uf[i]==i) return i;\n    uf[i] = UFroot(uf[i]);\n    return uf[i];\n}\n\n// 元々根が同じならfalse 違うなら統合してtrue\nbool UFunite(int i,int j)\n{\n    int ri = UFroot(i);\n    int rj = UFroot(j);\n\n    if(ri == rj) return false;\n    ufSize[ri] += ufSize[rj];\n    uf[rj] = ri;\n    return true;\n}\n\ntypedef struct\n{\n    int r;\n    int c;\n    int a;\n}card;\n\ncard cs[MAXN];\nint des_cs(const void *a, const void *b){return (*(card*)b).a - (*(card*)a).a;} /* 8,7,6,5.. */\n\nbool close[MAXN];\n\nint main(void)\n{\n    int n,h,w;\n    scanf(\"%d %d %d\",&n, &h, &w);\n\n    for(int i=0;i<n;i++) scanf(\"%d %d %d\",&(cs[i].r),&(cs[i].c),&(cs[i].a));\n    qsort(cs, n, sizeof(card), des_cs);\n\n    UFinit(h+w+1); // c は h+1からスタート\n\n    uint64_t ans = 0;\n    for(int i=0;i<n;i++) \n    {\n        int rr = UFroot(cs[i].r);\n        int cr = UFroot(cs[i].c+h);\n        if(rr == cr)\n        {\n            //既に同じ連結成分\n            if(!close[rr])\n            {\n                close[rr] = true;\n                ans += cs[i].a;\n            }\n        }else\n        {\n            if( !(close[rr] && close[cr]) )\n            {\n                UFunite(rr, cr);\n                close[rr] = close[rr] || close[cr];\n                ans += cs[i].a;\n            }\n        }\n    }\n    printf(\"%ld\\n\",ans);\n\n    return 0;\n}\n\n\n\n"
  },
  {
    "language": "Julia",
    "code": "parseInt(x) = parse(Int, x)\nparseMap(x::Array{SubString{String},1}) = map(parseInt, x)\nfunction root(uf::Array{Int,1},x)\n\ts=x\n\twhile uf[s]>0\n\t\ts=uf[s]\n\tend\n\ts\nend\nfunction same(uf::Array{Int,1},x,y)\n\troot(uf,x)==root(uf,y)?true:false\nend\nfunction unite(uf::Array{Int,1},x,y)\n\tl = root(uf,x)\n\tr = root(uf,y)\n\tif l < r\n\t\tuf[l] += uf[r]\n\t\tuf[r] = l\n\telseif l > r\n\t\tuf[r] += uf[l]\n\t\tuf[l] = r\n\tend\nend\n\n\nfunction main()\n\tn,h,w = readline() |> split |> parseMap\n\te = Tuple{Int,Int,Int}[(0,0,0) for i in 1:n]\n\tfor i in 1:n\n\t\tr,c,a = readline() |> split |> parseMap\n\t\te[i] = (r,c,a)\n\tend\n\te = sort(e,by=x->x[3],rev=true)\n\tuf = -ones(Int,h+w)\n\td = zeros(Int,h+w)\n\ts = 0\n\tfor i in 1:n\n\t\tr = e[i][1]\n\t\tc = e[i][2]+h\n\t\tif same(uf,r,c)\n\t\t\to = root(uf,r)\n\t\t\tif d[o]<-uf[o]\n\t\t\t\td[o]+= 1\n\t\t\t\ts += e[i][3]\n\t\t\tend\n\t\telse\n\t\t\to = min(root(uf,r),root(uf,c))\n\t\t\tp = max(root(uf,r),root(uf,c))\n\t\t\tif d[o]+d[p]<-uf[o]-uf[p]\n\t\t\t\td[o] += d[p]+1\n\t\t\t\tunite(uf,o,p)\n\t\t\t\ts += e[i][3]\n\t\t\tend\n\t\tend\n\tend\n\tprintln(s)\nend\n\nmain()"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args: Array<String>) {\n    val (N, H, W) = listOfInt()\n    val RCA = Array<Triple<Int, Int, Long>>(N) {\n        val (R, C, A) = listOfInt()\n        Triple(R-1, C-1, A.toLong())\n    }\n    RCA.sortByDescending { it.third }\n    val A = Array<Array<MutableList<Long>>>(H) { Array<MutableList<Long>>(W) { mutableListOf<Long>()}}\n    repeat(N) {\n        val (r, c, a) = RCA[it]\n        A[r][c].add(a)\n    }\n    var ans = 0L\n    for (r in 0 until H) {\n        var max = 0L\n        var maxC = 0\n        for (c in 0 until W) {\n            if (!A[r][c].isEmpty()) {\n                if (max < A[r][c].first()) {\n                    max = A[r][c].first()\n                    maxC = c\n                }\n            }\n        }\n        if (!A[r][maxC].isEmpty()) A[r][maxC].removeAt(0)\n        ans += max\n    }\n    for (c in 0 until W) {\n        var max = 0L\n        var maxR = 0\n        for (r in 0 until H) {\n            if (!A[r][c].isEmpty()) {\n                if (max < A[r][c].first()) {\n                    max = A[r][c].first()\n                    maxR = r\n                }\n            }\n        }\n        if (!A[maxR][c].isEmpty()) A[maxR][c].removeAt(0)\n        ans += max\n    }\n    println(ans)\n}\nfun next() = readLine()!!\nfun listOfString() = next().split(\" \")\nfun listOfInt(delta: Int = 0) = listOfString().map { Integer.parseInt(it) + delta }\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main\n{\n    PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));\n    BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n    StringTokenizer tok;\n\n    public void go() throws IOException\n    {\n        ntok();\n        int n = ipar();\n        int h = ipar();\n        int w = ipar();\n        ArrayList<Card> cards = new ArrayList<>();\n        for (int i = 0; i < n; i++)\n        {\n            ntok();\n            int r = ipar()-1;\n            int c = ipar()-1;\n            int val = ipar();\n            Card card = new Card(i, r, c, val);\n            cards.add(card);\n        }\n        Collections.sort(cards);\n        UnionFind uf = new UnionFind(h+w);\n        long sum = 0;\n        for (Card card : cards)\n        {\n            if (uf.find(card.r) == uf.find(card.c+h))\n            {\n                if (!uf.locked[uf.find(card.r)])\n                {\n                    uf.locked[uf.find(card.r)] = true;\n                    sum += card.val;\n                }\n            }\n            else if (!uf.locked[uf.find(card.r)] || !uf.locked[uf.find(card.c+h)])\n            {\n                uf.union(card.r, card.c+h);\n                sum += card.val;\n            }\n        }\n        out.println(sum);\n\n        out.flush();\n        in.close();\n    }\n\n    private class Card implements Comparable<Card>\n    {\n        int i, r, c, val;\n\n        public Card(int i, int r, int c, int v)\n        {\n            this.i = i;\n            this.r = r;\n            this.c = c;\n            val = v;\n        }\n\n        public int hashCode()\n        {\n            return i;\n        }\n\n        public boolean equals(Object obj)\n        {\n            if (obj instanceof Card)\n            {\n                Card other = (Card)obj;\n                return i == other.i;\n            }\n            return false;\n        }\n\n        public int compareTo(Card other)\n        {\n            if (val == other.val)\n            {\n                return Integer.compare(i, other.i);\n            }\n            return -Integer.compare(val, other.val);\n        }\n    }\n\n    private class UnionFind\n    {\n        int[] arr;\n        int[] sz;\n        boolean[] locked;\n        \n        public UnionFind(int n)\n        {\n            arr = new int[n];\n            sz = new int[n];\n            locked = new boolean[n];\n            for (int i = 0; i < n; i++)\n            {\n                arr[i] = i;\n                sz[i] = 1;\n            }\n        }\n\n        public int find(int i)\n        {\n            return arr[i] = (arr[i] == i ? i : find(arr[i]));\n        }\n\n        public void union(int i, int j)\n        {\n            i = find(i);\n            j = find(j);\n            if (sz[j] > sz[i])\n            {\n                int temp = i;\n                i = j;\n                j = temp;\n            }\n            arr[j] = i;\n            sz[i] += sz[j];\n            locked[i] |= locked[j];\n        }\n    }\n\n    public void ntok() throws IOException\n    {\n        tok = new StringTokenizer(in.readLine());\n    }\n\n    public int ipar()\n    {\n        return Integer.parseInt(tok.nextToken());\n    }\n\n    public long lpar()\n    {\n        return Long.parseLong(tok.nextToken());\n    }\n\n    public double dpar()\n    {\n        return Double.parseDouble(tok.nextToken());\n    }\n\n    public String spar()\n    {\n        return tok.nextToken();\n    }\n\n    public static void main(String[] args) throws IOException\n    {\n        new Main().go();\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\n\tpublic static void main (String[] args)  {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tUnit[] units = new Unit[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tunits[i] = new Unit(sc.nextInt() - 1, sc.nextInt() + h - 1, sc.nextInt());\n\t\t}\n\t\tArrays.sort(units);\n\t\tUnionFindTree uft = new UnionFindTree(h, w);\n\t\tlong total = 0;\n\t\tfor (Unit u : units) {\n\t\t\tif (uft.canSet(u.r, u.c)) {\n\t\t\t\tuft.unite(u.r, u.c);\n\t\t\t\ttotal += u.value;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(total);\n\t}\n\t\n\tstatic class UnionFindTree {\n\t\tint hSize;\n\t\tint[] parents;\n\t\tint[] pCount;\n\t\tint[] hCount;\n\t\tpublic UnionFindTree(int hSize, int wSize) {\n\t\t\tthis.hSize = hSize;\n\t\t\tparents = new int[hSize + wSize];\n\t\t\tpCount = new int[hSize + wSize];\n\t\t\thCount = new int[hSize + wSize];\n\t\t\tfor (int i = 0; i < parents.length; i++) {\n\t\t\t\tparents[i] = i;\n\t\t\t\tpCount[i] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate int find(int x) {\n\t\t\tif (x == parents[x]) {\n\t\t\t\treturn x;\n\t\t\t}\n\t\t\tint ans = find(parents[x]);\n\t\t\tparents[x] = ans;\n\t\t\treturn ans;\n\t\t}\n\t\t\n\t\tprivate boolean canSet(int x, int y) {\n\t\t\tint xx = find(x);\n\t\t\tint yy = find(y);\n\t\t\tif (xx == yy) {\n\t\t\t\treturn pCount[xx] >= hCount[xx] + 1;\n\t\t\t} else {\n\t\t\t\treturn pCount[xx] + pCount[yy] >= hCount[xx] + hCount[yy] + 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate void unite(int x, int y) {\n\t\t\tint xx = find(x);\n\t\t\tint yy = find(y);\n\t\t\tif (xx == yy) {\n\t\t\t\thCount[xx]++;\n\t\t\t} else {\n\t\t\t\tparents[xx] = yy;\n\t\t\t\tpCount[yy] += pCount[xx];\n\t\t\t\thCount[yy] += hCount[xx] + 1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic class Unit implements Comparable<Unit> {\n\t\tint r;\n\t\tint c;\n\t\tint value;\n\t\t\n\t\tpublic Unit(int r, int c, int value) {\n\t\t\tthis.r = r;\n\t\t\tthis.c = c;\n\t\t\tthis.value = value;\n\t\t}\n\t\t\n\t\tpublic int compareTo(Unit u) {\n\t\t\treturn u.value - this.value;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\n\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.math.BigInteger;\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Random;\n\n\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        boolean local = false;\n        boolean async = true;\n\n        Charset charset = Charset.forName(\"ascii\");\n\n        FastIO io = local ? new FastIO(new FileInputStream(\"D:\\\\DATABASE\\\\TESTCASE\\\\Code.in\"), System.out, charset) : new FastIO(System.in, System.out, charset);\n        Task task = new Task(io, new Debug(local));\n\n        if (async) {\n            Thread t = new Thread(null, task, \"skypool\", 1 << 27);\n            t.setPriority(Thread.MAX_PRIORITY);\n            t.start();\n            t.join();\n        } else {\n            task.run();\n        }\n\n        if (local) {\n            io.cache.append(\"\\n\\n--memory -- \\n\" + ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) >> 20) + \"M\");\n        }\n\n        io.flush();\n    }\n\n    public static class Task implements Runnable {\n        final FastIO io;\n        final Debug debug;\n        int inf = (int) 1e8;\n        long lInf = (long) 1e18;\n        double dInf = 1e50;\n\n        public Task(FastIO io, Debug debug) {\n            this.io = io;\n            this.debug = debug;\n        }\n\n        @Override\n        public void run() {\n            solve();\n        }\n\n\n        public void solve() {\n            int n = io.readInt();\n            int h = io.readInt();\n            int w = io.readInt();\n\n            Node[] rows = new Node[h + 1];\n            Node[] cols = new Node[w + 1];\n            for (int i = 1; i <= h; i++) {\n                rows[i] = new Node();\n            }\n            for (int i = 1; i <= w; i++) {\n                cols[i] = new Node();\n            }\n\n            Edge[] edges = new Edge[n];\n            for (int i = 0; i < n; i++) {\n                edges[i] = new Edge();\n                edges[i].r = rows[io.readInt()];\n                edges[i].c = cols[io.readInt()];\n                edges[i].a = io.readInt();\n            }\n\n            Arrays.sort(edges, (a, b) -> -(a.a - b.a));\n\n            long ans = 0;\n            for (Edge e : edges) {\n                Node a = e.r.find();\n                Node b = e.c.find();\n                if (a != b) {\n                    if (!(a.circle && b.circle)) {\n                        ans += e.a;\n                        Node.merge(e.r, e.c);\n                    }\n                } else if (a.circle == false) {\n                    ans += e.a;\n                    a.circle = true;\n                }\n            }\n\n            io.cache.append(ans);\n        }\n\n    }\n\n    public static class Edge {\n        Node r;\n        Node c;\n        int a;\n    }\n\n    public static class Node {\n        Node p = this;\n        int rank;\n        int size = 1;\n        boolean circle;\n\n        Node find() {\n            return p.p == p ? p : (p = p.find());\n        }\n\n        static void merge(Node a, Node b) {\n            a = a.find();\n            b = b.find();\n            if (a == b) {\n                return;\n            }\n            if (a.rank == b.rank) {\n                a.rank++;\n            }\n            if (a.rank > b.rank) {\n                b.p = a;\n                a.size += b.size;\n                a.circle = a.circle || b.circle;\n            } else {\n                a.p = b;\n                b.size += a.size;\n                b.circle = a.circle || b.circle;\n            }\n        }\n    }\n\n    public static class FastIO {\n        public final StringBuilder cache = new StringBuilder(20 << 20);\n        private final InputStream is;\n        private final OutputStream os;\n        private final Charset charset;\n        private StringBuilder defaultStringBuf = new StringBuilder(1 << 8);\n        private byte[] buf = new byte[1 << 20];\n        private int bufLen;\n        private int bufOffset;\n        private int next;\n\n        public FastIO(InputStream is, OutputStream os, Charset charset) {\n            this.is = is;\n            this.os = os;\n            this.charset = charset;\n        }\n\n        public FastIO(InputStream is, OutputStream os) {\n            this(is, os, Charset.forName(\"ascii\"));\n        }\n\n        private int read() {\n            while (bufLen == bufOffset) {\n                bufOffset = 0;\n                try {\n                    bufLen = is.read(buf);\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n                if (bufLen == -1) {\n                    return -1;\n                }\n            }\n            return buf[bufOffset++];\n        }\n\n        public void skipBlank() {\n            while (next >= 0 && next <= 32) {\n                next = read();\n            }\n        }\n\n        public int readInt() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            int val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public long readLong() {\n            int sign = 1;\n\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+' ? 1 : -1;\n                next = read();\n            }\n\n            long val = 0;\n            if (sign == 1) {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 + next - '0';\n                    next = read();\n                }\n            } else {\n                while (next >= '0' && next <= '9') {\n                    val = val * 10 - next + '0';\n                    next = read();\n                }\n            }\n\n            return val;\n        }\n\n        public double readDouble() {\n            boolean sign = true;\n            skipBlank();\n            if (next == '+' || next == '-') {\n                sign = next == '+';\n                next = read();\n            }\n\n            long val = 0;\n            while (next >= '0' && next <= '9') {\n                val = val * 10 + next - '0';\n                next = read();\n            }\n            if (next != '.') {\n                return sign ? val : -val;\n            }\n            next = read();\n            long radix = 1;\n            long point = 0;\n            while (next >= '0' && next <= '9') {\n                point = point * 10 + next - '0';\n                radix = radix * 10;\n                next = read();\n            }\n            double result = val + (double) point / radix;\n            return sign ? result : -result;\n        }\n\n        public String readString(StringBuilder builder) {\n            skipBlank();\n\n            while (next > 32) {\n                builder.append((char) next);\n                next = read();\n            }\n\n            return builder.toString();\n        }\n\n        public String readString() {\n            defaultStringBuf.setLength(0);\n            return readString(defaultStringBuf);\n        }\n\n        public int readLine(char[] data, int offset) {\n            int originalOffset = offset;\n            while (next != -1 && next != '\\n') {\n                data[offset++] = (char) next;\n                next = read();\n            }\n            return offset - originalOffset;\n        }\n\n        public int readString(char[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (char) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public int readString(byte[] data, int offset) {\n            skipBlank();\n\n            int originalOffset = offset;\n            while (next > 32) {\n                data[offset++] = (byte) next;\n                next = read();\n            }\n\n            return offset - originalOffset;\n        }\n\n        public char readChar() {\n            skipBlank();\n            char c = (char) next;\n            next = read();\n            return c;\n        }\n\n        public void flush() {\n            try {\n                os.write(cache.toString().getBytes(charset));\n                os.flush();\n                cache.setLength(0);\n            } catch (IOException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public boolean hasMore() {\n            skipBlank();\n            return next != -1;\n        }\n    }\n\n    public static class Debug {\n        private boolean allowDebug;\n\n        public Debug(boolean allowDebug) {\n            this.allowDebug = allowDebug;\n        }\n\n        public void assertTrue(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (!flag) {\n                fail();\n            }\n        }\n\n        public void fail() {\n            throw new RuntimeException();\n        }\n\n        public void assertFalse(boolean flag) {\n            if (!allowDebug) {\n                return;\n            }\n            if (flag) {\n                fail();\n            }\n        }\n\n        private void outputName(String name) {\n            System.out.print(name + \" = \");\n        }\n\n        public void debug(String name, int x) {\n            if (!allowDebug) {\n                return;\n            }\n\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, long x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, double x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, int[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, long[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, double[] x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.toString(x));\n        }\n\n        public void debug(String name, Object x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(\"\" + x);\n        }\n\n        public void debug(String name, Object... x) {\n            if (!allowDebug) {\n                return;\n            }\n            outputName(name);\n            System.out.println(Arrays.deepToString(x));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n        static Scanner sc = new Scanner(System.in);\n        static void myout(Object t){System.out.println(t);}//standard output\n        static void myerr(Object t){System.err.println(t);}//standard error\n        static String getStr(){return sc.next();}\n        static int getInt(){return Integer.parseInt(getStr());}\n        static long getLong(){return Long.parseLong(getStr());}\n        static boolean isNext(){return sc.hasNext();}\n        static String[] mySplit(String str){return str.split(\"\");}\n        public static void main(String[] args){\n          int N = getInt();\n          int H = getInt();\n          int W = getInt();\n          PriorityQueue[] HQlist = new PriorityQueue[H];\n          PriorityQueue[] WQlist = new PriorityQueue[W];\n          Map<String,Integer> Wtokutei = new HashMap<String,Integer>();//行と値があれば列がわかる\n          Map<String,Integer> Htokutei = new HashMap<String,Integer>();//列と値があれば行がわかる\n          long output = 0;\n          for(int i = 0; i < N; i++){\n            int r = getInt()-1;\n            int c = getInt()-1;\n            int Ai = getInt();\n            Wtokutei.put(String.valueOf(r)+\":\"+String.valueOf(Ai),c);\n            Htokutei.put(String.valueOf(c)+\":\"+String.valueOf(Ai),r);\n            if(HQlist[r] == null){\n              HQlist[r] = new PriorityQueue(Comparator.reverseOrder());\n            }\n            if(WQlist[c] == null){\n              WQlist[c] = new PriorityQueue(Comparator.reverseOrder());\n            }\n            HQlist[r].add(Ai);\n            WQlist[c].add(Ai);\n          }\n          int add = 0;\n          int tmpC = 0;\n          for(int i = 0; i < H; i++){\n            if(HQlist[i] != null){\n              PriorityQueue<Integer> tmpQueue = new PriorityQueue<Integer>();\n              while(HQlist[i].size() != 0){\n                add = (int)HQlist[i].poll();\n                tmpC = (int)Wtokutei.get(String.valueOf(i)+\":\"+String.valueOf(add));\n                //列を見たときに要素数が1個の場合は列巡回時に取ればいい\n                //行で次の優先値をとった方がいい\n                if(WQlist[tmpC].size() == 1 && HQlist[i].size() != 0){\n                  tmpQueue.add(add);\n                }else{\n                  for(int j = 0; j < tmpQueue.size(); j++){\n                    HQlist[i].add(tmpQueue.poll());\n                  }\n                  break;\n                }\n              }\n              \n              WQlist[tmpC].remove(add);\n              output += add;\n              /*WQlistからtmpと同じ値を持つ要素を見つける必要がある*/\n              myerr(\"値:\" + add + \",行:\" + (i+1) + \",列:\" + (tmpC+1));\n            }\n          }\n          for(int i = 0; i < W; i++){\n            if(WQlist[i] != null && WQlist[i].size() != 0){\n              add = (int)WQlist[i].poll();\n              int tmpR = Htokutei.get(String.valueOf(i)+\":\"+String.valueOf(add));\n              WQlist[tmpR].remove(add);\n              output += add;\n              /*WQlistからtmpと同じ値を持つ要素を見つける必要がある*/\n              myerr(\"値:\" + add + \",行:\" + (i+1) + \",列:\" + (tmpR+1));\n            }\n          }\n          myout(output);\n        }\n        //便利メソッド追加枠ここから\n\n        //便利メソッド追加枠ここまで\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.StringJoiner;\nimport java.util.StringTokenizer;\nimport java.util.function.Function;\n\npublic class Main {\n\n    static int N, H, W;\n    static int[][] C;\n\n    public static void main(String[] args) {\n        FastScanner sc = new FastScanner(System.in);\n        N = sc.nextInt();\n        H = sc.nextInt();\n        W = sc.nextInt();\n\n        C = new int[N][3];\n        for (int i = 0; i < N; i++) {\n            C[i][0] = sc.nextInt()-1;\n            C[i][1] = sc.nextInt()-1;\n            C[i][2] = sc.nextInt();\n        }\n\n        System.out.println(solve());\n    }\n\n    static long solve() {\n        // 行と列を頂点、カードを辺を見なす\n        // 関数グラフとみなせる最大のものが答え\n        //   関数グラフ -> 連結成分に対して閉路一つまではok\n        // クラスカルっぽい感じで辺を選んでいけばよい\n\n        UnionFind uf = new UnionFind(H+W);\n        boolean[] hasCycle = new boolean[H+W];\n        Arrays.sort(C, Comparator.comparingInt(c -> -c[2]));\n\n        long ans = 0;\n        for (int i = 0; i < N; i++) {\n            int h = C[i][0];\n            int w = C[i][1] + H;\n            int a = C[i][2];\n\n            if( uf.isSame(h, w) ) {\n                int g = uf.root(h);\n                if( hasCycle[g] ) {\n                    // すでにcycleがあるのでダメ\n\n                } else {\n                    ans += a;\n                    hasCycle[g] = true;\n                }\n\n            } else {\n                int gh = uf.root(h);\n                int gw = uf.root(w);\n                if( hasCycle[gh] && hasCycle[gw] ) {\n                    // 両方cycleなのでダメ\n\n                } else if( !hasCycle[gh] && !hasCycle[gw] ) {\n                    // どっちもcycle持たないのでつなげるだけ\n                    uf.unite(h, w);\n                    ans += a;\n\n                } else {\n                    // 片方が持ってるのでつなげた後もcycleあり\n                    uf.unite(h, w);\n                    ans += a;\n                    hasCycle[uf.root(h)] = true;\n                }\n            }\n        }\n        return ans;\n    }\n\n    static class UnionFind {\n\n        private final int[] parent;\n        private final int[] count;\n\n        public UnionFind(int n) {\n            parent = new int[n];\n            count = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                count[i] = 1;\n            }\n        }\n\n        public int root(int i) {\n            if (parent[i] == i) {\n                return i;\n            } else {\n                return parent[i] = root(parent[i]);\n            }\n        }\n\n        public int unite(int i, int j) {\n            int ri = root(i);\n            int rj = root(j);\n            if (ri == rj) return ri;\n\n\n            int big = count[ri] < count[rj] ? rj : ri;\n            int small = big == ri ? rj : ri;\n            parent[small] = big;\n            count[big] += count[small];\n            return big;\n        }\n\n        public int count(int a) {\n            return count[root(a)];\n        }\n\n        public boolean isSame(int a, int b) {\n            return root(a) == root(b);\n        }\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class FastScanner {\n        private BufferedReader reader;\n        private StringTokenizer tokenizer;\n\n        FastScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n            tokenizer = null;\n        }\n\n        String next() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        String nextLine() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    return reader.readLine();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken(\"\\n\");\n        }\n\n        long nextLong() {\n            return Long.parseLong(next());\n        }\n\n        int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n        int[] nextIntArray(int n) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt();\n            return a;\n        }\n\n        int[] nextIntArray(int n, int delta) {\n            int[] a = new int[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextInt() + delta;\n            return a;\n        }\n\n        long[] nextLongArray(int n) {\n            long[] a = new long[n];\n            for (int i = 0; i < n; i++)\n                a[i] = nextLong();\n            return a;\n        }\n    }\n\n    static <A> void writeLines(A[] as, Function<A, String> f) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (A a : as) {\n            pw.println(f.apply(a));\n        }\n        pw.flush();\n    }\n\n    static void writeLines(int[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (int a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static void writeLines(long[] as) {\n        PrintWriter pw = new PrintWriter(System.out);\n        for (long a : as) pw.println(a);\n        pw.flush();\n    }\n\n    static int max(int... as) {\n        int max = Integer.MIN_VALUE;\n        for (int a : as) max = Math.max(a, max);\n        return max;\n    }\n\n    static int min(int... as) {\n        int min = Integer.MAX_VALUE;\n        for (int a : as) min = Math.min(a, min);\n        return min;\n    }\n\n    static void debug(Object... args) {\n        StringJoiner j = new StringJoiner(\" \");\n        for (Object arg : args) {\n            if (arg instanceof int[]) j.add(Arrays.toString((int[]) arg));\n            else if (arg instanceof long[]) j.add(Arrays.toString((long[]) arg));\n            else if (arg instanceof double[]) j.add(Arrays.toString((double[]) arg));\n            else if (arg instanceof Object[]) j.add(Arrays.toString((Object[]) arg));\n            else j.add(arg.toString());\n        }\n        System.err.println(j.toString());\n    }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        // int n = Integer.parseInt(bf.readLine());\n        StringTokenizer st = new StringTokenizer(bf.readLine());\n        // int[] a = new int[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());\n        int n = Integer.parseInt(st.nextToken());\n        int h = Integer.parseInt(st.nextToken());\n        int w = Integer.parseInt(st.nextToken());\n        int[] a = new int[n];\n        int[] r = new int[n];\n        int[] c = new int[n];\n        for(int i=0; i<n; i++) {\n           st = new StringTokenizer(bf.readLine());\n           r[i] = Integer.parseInt(st.nextToken());\n           c[i] = Integer.parseInt(st.nextToken());\n           a[i] = Integer.parseInt(st.nextToken());\n        }\n        Point[] points = new Point[n];\n        for(int i=0; i<n; i++) points[i] = new Point(r[i], c[i], a[i]);\n\n        Set<Integer> rows = new HashSet<Integer>();\n        Set<Integer> cols = new HashSet<Integer>();\n        Map<Integer, ArrayList<Integer>> rowmap = new HashMap<Integer, ArrayList<Integer>>();\n        Map<Integer, ArrayList<Integer>> colmap = new HashMap<Integer, ArrayList<Integer>>();\n        Arrays.sort(points);\n        long sum = 0;\n        ArrayList<Integer> conflicts = new ArrayList<Integer>();\n        Set<Integer> taken = new HashSet<Integer>();\n        for(int i=0; i<n; i++) {\n          boolean b1 = !rows.contains(points[i].r);\n          boolean b2 = !cols.contains(points[i].c);\n          if(b1 && b2) {\n            conflicts.add(i);\n            taken.add(i);\n            sum += points[i].a;\n          }\n          else if(b1 || b2) {\n            conflicts.add(i);\n            if(b1) points[i].flag = 1;\n            else points[i].flag = 2;\n            //sum += points[i].a;\n            //points[i].a = 0;\n            //taken.add(i);\n          }\n          rows.add(points[i].r);\n          cols.add(points[i].c);\n          if(b1) rowmap.put(points[i].r, new ArrayList<Integer>());\n          if(b2) colmap.put(points[i].c, new ArrayList<Integer>());\n          if(points[i].a != 0) {\n          rowmap.get(points[i].r).add(i);\n          colmap.get(points[i].c).add(i);\n          }\n\n        }\n        for(int i=conflicts.size()-1; i>=0; i--) {\n          Point p = points[conflicts.get(i)];\n          int cur1 = 0; int val1 = -1;\n          for(int j : rowmap.get(p.r)) {\n            if(!taken.contains(j)) {\n              val1 = j;\n              cur1 = points[j].a;\n              break;\n            }\n          }\n\n          int cur2 = 0; int val2 = -1;\n          for(int j : colmap.get(p.c)) {\n            if(!taken.contains(j)) {\n              val2 = j;\n              cur2 = points[j].a;\n              break;\n            }\n          }\n          if((p.flag==0)) {\n          if(cur1 > cur2) {\n            sum += cur1;\n            taken.add(val1);\n          }\n          else {\n            sum += cur2;\n            taken.add(val2);\n          }\n          }\n          else {\n            if(p.flag == 1) {\n              sum += cur2;\n              taken.add(val2);\n            }\n            else {\n              sum += cur1;\n              taken.add(val1);\n            }\n          }\n        }\n        out.println(sum);\n        out.close(); System.exit(0);\n    }\n}\nclass Point implements Comparable<Point> {\n  public int r;\n  public int c;\n  public int a;\n  public int flag;\n  public Point(int r, int c, int a) {\n    this.flag = 0;\n    this.r = r;\n    this.c = c;\n    this.a = a;\n  }\n  @Override\n  public boolean equals(Object o) {\n    Point p = (Point)o;\n    return (this.compareTo(p) == 0);\n  }\n\n  @Override\n  public int compareTo(Point p) {\n    if(this.a < p.a) return 1;\n    if(this.a > p.a) return -1;\n    if(this.r < p.r) return -1;\n    if(this.r > p.r) return 1;\n    if(this.c < p.c) return -1;\n    if(this.c > p.c) return 1;\n    return 0;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.PriorityQueue;\nimport java.util.ArrayList;\nimport java.util.AbstractCollection;\nimport java.nio.charset.Charset;\nimport java.util.StringTokenizer;\nimport java.io.OutputStreamWriter;\nimport java.io.OutputStream;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.io.Writer;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author mikit\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        LightScanner in = new LightScanner(inputStream);\n        LightWriter out = new LightWriter(outputStream);\n        ECardCollector solver = new ECardCollector();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class ECardCollector {\n        public void solve(int testNumber, LightScanner in, LightWriter out) {\n            // out.setBoolLabel(LightWriter.BoolLabel.YES_NO_FIRST_UP);\n            int n = in.ints(), h = in.ints(), w = in.ints();\n            List<PriorityQueue<ECardCollector.Card>> vert = new ArrayList<>(), hori = new ArrayList<>();\n            for (int i = 0; i < w; i++) vert.add(new PriorityQueue<>());\n            for (int i = 0; i < h; i++) hori.add(new PriorityQueue<>());\n            ECardCollector.Card[] cards = new ECardCollector.Card[n];\n            for (int i = 0; i < n; i++) {\n                ECardCollector.Card c = new ECardCollector.Card(in.ints() - 1, in.ints() - 1, in.ints(), i);\n                vert.get(c.x).offer(c);\n                hori.get(c.y).offer(c);\n                cards[i] = c;\n            }\n            boolean[] htook = new boolean[h], vtook = new boolean[w];\n            IntroSort.sort(cards);\n            long ans = 0;\n            for (int i = 0; i < n; i++) {\n                ECardCollector.Card c = cards[i];\n                if (vert.get(c.x).poll() != c || hori.get(c.y).poll() != c) {\n                    throw new RuntimeException(\"AF\");\n                }\n                if (htook[c.y] && vtook[c.x]) continue;\n                ans += c.v;\n                //System.out.print(\"Took \" + c + \" \");\n                if (htook[c.y] || (!vtook[c.x] && vert.get(c.x).isEmpty())) {\n                    //System.out.println(\"Vertically 1 \");\n                    vtook[c.x] = true;\n                } else if (vtook[c.x] || (!htook[c.y] && hori.get(c.y).isEmpty())) {\n                    //System.out.println(\"Horizontally 1\");\n                    htook[c.y] = true;\n                } else if (vert.get(c.x).peek().v < hori.get(c.y).peek().v) {\n                    //System.out.println(\"Vertically 2\");\n                    vtook[c.x] = true;\n                } else {\n                    //System.out.println(\"Horizontally 2\");\n                    htook[c.y] = true;\n                }\n            }\n            out.ans(ans).ln();\n        }\n\n        static class Card implements Comparable<ECardCollector.Card> {\n            int y;\n            int x;\n            int v;\n            int i;\n\n            Card(int y, int x, int v, int i) {\n                this.y = y;\n                this.x = x;\n                this.v = v;\n                this.i = i;\n            }\n\n            long id() {\n                long base = 1_000_000;\n                return v * base + i;\n            }\n\n            public int compareTo(ECardCollector.Card o) {\n                return -Long.compare(id(), o.id());\n            }\n\n            public String toString() {\n                return \"Card{\" +\n                        \"y=\" + y +\n                        \", x=\" + x +\n                        \", v=\" + v +\n                        \", i=\" + i +\n                        '}';\n            }\n\n        }\n\n    }\n\n    static class HeapSort {\n        private HeapSort() {\n        }\n\n        private static <T> void heapfy(T[] a, int low, int high, int i, T val, Comparator<? super T> comparator) {\n            int child = 2 * i - low + 1;\n            while (child < high) {\n                if (child + 1 < high && comparator.compare(a[child], a[child + 1]) < 0) {\n                    child++;\n                }\n                if (comparator.compare(val, a[child]) >= 0) {\n                    break;\n                }\n                a[i] = a[child];\n                i = child;\n                child = 2 * i - low + 1;\n            }\n            a[i] = val;\n        }\n\n        static <T> void sort(T[] a, int low, int high, Comparator<T> comparator) {\n            for (int p = (high + low) / 2 - 1; p >= low; p--) {\n                heapfy(a, low, high, p, a[p], comparator);\n            }\n            while (high > low) {\n                high--;\n                T pval = a[high];\n                a[high] = a[low];\n                heapfy(a, low, high, low, pval, comparator);\n            }\n        }\n\n    }\n\n    static class InsertionSort {\n        private InsertionSort() {\n        }\n\n        static <T> void sort(T[] a, int low, int high, Comparator<? super T> comparator) {\n            for (int i = low; i < high; i++) {\n                for (int j = i; j > low && comparator.compare(a[j - 1], a[j]) > 0; j--) {\n                    ArrayUtil.swap(a, j - 1, j);\n                }\n            }\n        }\n\n    }\n\n    static class LightWriter implements AutoCloseable {\n        private final Writer out;\n        private boolean autoflush = false;\n        private boolean breaked = true;\n\n        public LightWriter(Writer out) {\n            this.out = out;\n        }\n\n        public LightWriter(OutputStream out) {\n            this(new BufferedWriter(new OutputStreamWriter(out, Charset.defaultCharset())));\n        }\n\n        public LightWriter print(char c) {\n            try {\n                out.write(c);\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter print(String s) {\n            try {\n                out.write(s, 0, s.length());\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter ans(String s) {\n            if (!breaked) {\n                print(' ');\n            }\n            return print(s);\n        }\n\n        public LightWriter ans(long l) {\n            return ans(Long.toString(l));\n        }\n\n        public LightWriter ln() {\n            print(System.lineSeparator());\n            breaked = true;\n            if (autoflush) {\n                try {\n                    out.flush();\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            }\n            return this;\n        }\n\n        public void close() {\n            try {\n                out.close();\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n        }\n\n    }\n\n    static interface Verified {\n    }\n\n    static class IntroSort {\n        private static int INSERTIONSORT_THRESHOLD = 16;\n\n        private IntroSort() {\n        }\n\n        static <T> void sort(T[] a, int low, int high, int maxDepth, Comparator<T> comparator) {\n            while (high - low > INSERTIONSORT_THRESHOLD) {\n                if (maxDepth-- == 0) {\n                    HeapSort.sort(a, low, high, comparator);\n                    return;\n                }\n                int cut = QuickSort.step(a, low, high, comparator);\n                sort(a, cut, high, maxDepth, comparator);\n                high = cut;\n            }\n            InsertionSort.sort(a, low, high, comparator);\n        }\n\n        public static <T> void sort(T[] a, Comparator<T> comparator) {\n            if (a.length <= INSERTIONSORT_THRESHOLD) {\n                InsertionSort.sort(a, 0, a.length, comparator);\n            } else {\n                sort(a, 0, a.length, 2 * BitMath.msb(a.length), comparator);\n            }\n        }\n\n        public static <T extends Comparable<T>> void sort(T[] a) {\n            sort(a, Comparator.naturalOrder());\n        }\n\n    }\n\n    static class QuickSort {\n        private QuickSort() {\n        }\n\n        private static <T> void med(T[] a, int low, int x, int y, int z, Comparator<? super T> comparator) {\n            if (comparator.compare(a[z], a[x]) < 0) {\n                ArrayUtil.swap(a, low, x);\n            } else if (comparator.compare(a[y], a[z]) < 0) {\n                ArrayUtil.swap(a, low, y);\n            } else {\n                ArrayUtil.swap(a, low, z);\n            }\n        }\n\n        static <T> int step(T[] a, int low, int high, Comparator<? super T> comparator) {\n            int x = low + 1, y = low + (high - low) / 2, z = high - 1;\n            if (comparator.compare(a[x], a[y]) < 0) {\n                med(a, low, x, y, z, comparator);\n            } else {\n                med(a, low, y, x, z, comparator);\n            }\n\n            int lb = low + 1, ub = high;\n            while (true) {\n                while (comparator.compare(a[lb], a[low]) < 0) {\n                    lb++;\n                }\n                ub--;\n                while (comparator.compare(a[low], a[ub]) < 0) {\n                    ub--;\n                }\n                if (lb >= ub) {\n                    return lb;\n                }\n                ArrayUtil.swap(a, lb, ub);\n                lb++;\n            }\n        }\n\n    }\n\n    static class LightScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public LightScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String string() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ints() {\n            return Integer.parseInt(string());\n        }\n\n    }\n\n    static final class ArrayUtil {\n        private ArrayUtil() {\n        }\n\n        public static <T> void swap(T[] a, int x, int y) {\n            T t = a[x];\n            a[x] = a[y];\n            a[y] = t;\n        }\n\n    }\n\n    static final class BitMath {\n        private BitMath() {\n        }\n\n        public static int count(int v) {\n            v = (v & 0x55555555) + ((v >> 1) & 0x55555555);\n            v = (v & 0x33333333) + ((v >> 2) & 0x33333333);\n            v = (v & 0x0f0f0f0f) + ((v >> 4) & 0x0f0f0f0f);\n            v = (v & 0x00ff00ff) + ((v >> 8) & 0x00ff00ff);\n            v = (v & 0x0000ffff) + ((v >> 16) & 0x0000ffff);\n            return v;\n        }\n\n        public static int msb(int v) {\n            if (v == 0) {\n                throw new IllegalArgumentException(\"Bit not found\");\n            }\n            v |= (v >> 1);\n            v |= (v >> 2);\n            v |= (v >> 4);\n            v |= (v >> 8);\n            v |= (v >> 16);\n            return count(v) - 1;\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.text.*;\npublic class Main{\n    //SOLUTION BEGIN\n    //Into the Hardware Mode\n    void pre() throws Exception{}\n//    int n, m, t;\n    void solve(int TC) throws Exception{\n//        n = ni(); m = ni();int z = ni(); t = ni();\n//        char[][] gr = new char[n][];\n//        for(int i = 0; i< n; i++)gr[i] = n().toCharArray();\n//        int[][][] mat = new int[1+t][n][m];\n//        while(z-->0){\n//            int rr = ni()-1, cc = ni()-1, st = ni(), en = ni(), g = ni();\n//            for(int j = st+1; j<= en; j++)\n//                mat[j][rr][cc] = Math.max(mat[j][rr][cc], g);\n//        }\n//        \n//        int[][] D = new int[][]{\n//            {-1, 0},{0, -1}, {0, 1}, {1, 0}\n//        };\n//        for(int ti = 0; ti< t; ti++){\n//            for(int i = 0; i< n; i++)\n//                for(int j = 0; j< m; j++){\n//                    if(gr[i][j] == '#')continue;\n//                    addEdge(graph, get(ti, i, j, 0), get(ti, i, j, 1), 1, 0);\n//                    \n//                    addEdge(graph, get(ti, i, j, 1), get(ti+1, i, j, 0), 1, -mat[ti+1][i][j]);\n//                    for(int[] d:D){\n//                        int ii = i+d[0], jj = j+d[1];\n//                        if(ii < 0 || ii >= n || jj < 0 || jj >= m || gr[ii][jj] == '#')continue;\n//                        addEdge(graph, get(ti, i, j, 1), get(ti+1, ii, jj, 0),1, 0);\n//                    }\n//                }\n//        }\n//        for(int i = 0; i< n; i++)\n//            for(int j = 0; j< m; j++){\n//                if(gr[i][j] == 'S')addEdge(graph, src, get(0, i, j, 0), 1, 0);\n//                if(gr[i][j] != '#'){\n//                    addEdge(graph, get(t, i, j, 0), get(t, i, j, 1), 1, 0);\n//                    addEdge(graph, get(t, i, j, 1), dest, 1, 0);\n//                }\n//            }\n        \n        int n = ni(), h = ni(), w = ni();\n        \n        List<Edge>[] graph = createGraph(2+n+h+w);\n        int src = 0, dest = 1;\n        for(int i = 0; i< n; i++){\n            int r = ni()-1, c = ni()-1;long cost = nl();\n            addEdge(graph, 0, 2+i, 1, -cost);\n            \n            addEdge(graph, 2+i, 2+n+r, 1, 0);\n            addEdge(graph, 2+i, 2+n+h+c, 1, 0);\n        }\n        for(int i = 0; i< h+w; i++)addEdge(graph, 2+n+i, 1, 1, 0);\n        \n        int[] res = minCostFlow(graph, src, dest, Integer.MAX_VALUE);\n        pn(-res[1]);\n        \n    }\n//    int get(int ti, int r, int c,int ty){\n//        return 2+ty+2*(c+m*(r+n*ti));\n//    }\n    //https://sites.google.com/site/indy256/algo/min_cost_flow_bf\n    static class Edge {\n    int to, f, cap, rev;\n    long cost;\n    Edge(int v, int cap, long cost, int rev) {\n      this.to = v;\n      this.cap = cap;\n      this.cost = cost;\n      this.rev = rev;\n    }\n  }\n\n  public static List<Edge>[] createGraph(int n) {\n    List<Edge>[] graph = new List[n];\n    for (int i = 0; i < n; i++)\n      graph[i] = new ArrayList<>();\n    return graph;\n  }\n\n  public static void addEdge(List<Edge>[] graph, int s, int t, int cap, long cost) {\n    graph[s].add(new Edge(t, cap, cost, graph[t].size()));\n    graph[t].add(new Edge(s, 0, -cost, graph[s].size() - 1));\n  }\n\n  static void bellmanFord(List<Edge>[] graph, int s, long[] dist) {\n    int n = graph.length;\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    dist[s] = 0;\n    boolean[] inqueue = new boolean[n];\n    int[] q = new int[n];\n    int qt = 0;\n    q[qt++] = s;\n    for (int qh = 0; (qh - qt) % n != 0; qh++) {\n      int u = q[qh % n];\n      inqueue[u] = false;\n      for (int i = 0; i < graph[u].size(); i++) {\n        Edge e = graph[u].get(i);\n        if (e.cap <= e.f)\n          continue;\n        int v = e.to;\n        long ndist = dist[u] + e.cost;\n        if (dist[v] > ndist) {\n          dist[v] = ndist;\n          if (!inqueue[v]) {\n            inqueue[v] = true;\n            q[qt++ % n] = v;\n          }\n        }\n      }\n    }\n  }\n\n  public static int[] minCostFlow(List<Edge>[] graph, int s, int t, int maxf) {\n    int n = graph.length;\n    long[] prio = new long[n];\n    int[] curflow = new int[n];\n    int[] prevedge = new int[n];\n    int[] prevnode = new int[n];\n    long[] pot = new long[n];\n\n    // bellmanFord invocation can be skipped if edges costs are non-negative\n    bellmanFord(graph, s, pot);\n    int flow = 0;\n    int flowCost = 0;\n    while (flow < maxf) {\n      PriorityQueue<Long> q = new PriorityQueue<>();\n      q.add((long) s);\n      Arrays.fill(prio, Integer.MAX_VALUE);\n      prio[s] = 0;\n      boolean[] finished = new boolean[n];\n      curflow[s] = Integer.MAX_VALUE;\n      while (!finished[t] && !q.isEmpty()) {\n        long cur = q.remove();\n        int u = (int) (cur & 0xFFFF_FFFFL);\n        int priou = (int) (cur >>> 32);\n        if (priou != prio[u])\n          continue;\n        finished[u] = true;\n        for (int i = 0; i < graph[u].size(); i++) {\n          Edge e = graph[u].get(i);\n          if (e.f >= e.cap)\n            continue;\n          int v = e.to;\n          long nprio = prio[u] + e.cost + pot[u] - pot[v];\n          if (prio[v] > nprio) {\n            prio[v] = nprio;\n            q.add(((long) nprio << 32) + v);\n            prevnode[v] = u;\n            prevedge[v] = i;\n            curflow[v] = Math.min(curflow[u], e.cap - e.f);\n          }\n        }\n      }\n      if (prio[t] == Integer.MAX_VALUE)\n        break;\n      for (int i = 0; i < n; i++)\n        if (finished[i])\n          pot[i] += prio[i] - prio[t];\n      int df = Math.min(curflow[t], maxf - flow);\n      flow += df;\n      for (int v = t; v != s; v = prevnode[v]) {\n        Edge e = graph[prevnode[v]].get(prevedge[v]);\n        e.f += df;\n        graph[v].get(e.rev).f -= df;\n        flowCost += df * e.cost;\n      }\n    }\n    return new int[]{flow, flowCost};\n  }\n    //SOLUTION END\n    void hold(boolean b)throws Exception{if(!b)throw new Exception(\"Hold right there, Sparky!\");}\n    long IINF = (long)1e18, mod = (long)1e9+7;\n    final int INF = (int)1e9, MX = (int)2e5+5;\n    DecimalFormat df = new DecimalFormat(\"0.00000000000\");\n    double PI = 3.141592653589793238462643383279502884197169399, eps = 1e-6;\n    static boolean multipleTC = false, memory = false;\n    FastReader in;PrintWriter out;\n    void run() throws Exception{\n        in = new FastReader();\n        out = new PrintWriter(System.out);\n        //Solution Credits: Taranpreet Singh\n        int T = (multipleTC)?ni():1;\n        pre();for(int t = 1; t<= T; t++)solve(t);\n        out.flush();\n        out.close();\n    }\n    public static void main(String[] args) throws Exception{\n        if(memory)new Thread(null, new Runnable() {public void run(){try{new Main().run();}catch(Exception e){e.printStackTrace();}}}, \"1\", 1 << 28).start();\n        else new Main().run();\n    }\n    long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}\n    int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}\n    int bit(long n){return (n==0)?0:(1+bit(n&(n-1)));}\n    void p(Object o){out.print(o);}\n    void pn(Object o){out.println(o);}\n    void pni(Object o){out.println(o);out.flush();}\n    String n()throws Exception{return in.next();}\n    String nln()throws Exception{return in.nextLine();}\n    int ni()throws Exception{return Integer.parseInt(in.next());}\n    long nl()throws Exception{return Long.parseLong(in.next());}\n    double nd()throws Exception{return Double.parseDouble(in.next());}\n\n    class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastReader(String s) throws Exception{\n            br = new BufferedReader(new FileReader(s));\n        }\n\n        String next() throws Exception{\n            while (st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException  e){\n                    throw new Exception(e.toString());\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine() throws Exception{\n            String str = \"\";\n            try{   \n                str = br.readLine();\n            }catch (IOException e){\n                throw new Exception(e.toString());\n            }  \n            return str;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.InputMismatchException;\nimport java.util.List;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint h = ni(), w = ni();\n\t\tint[] xs = new int[n];\n\t\tint[] ys = new int[n];\n\t\tint[] vs = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\txs[i] = ni();\n\t\t\tys[i] = ni();\n\t\t\tvs[i] = ni();\n\t\t}\n\t\tint[] sxs = Arrays.copyOf(xs, n);\n\t\tArrays.sort(sxs);\n\t\tsxs = uniq(sxs);\n\t\tint[] sys = Arrays.copyOf(ys, n);\n\t\tArrays.sort(sys);\n\t\tsys = uniq(sys);\n\t\t\n\t\tint max = 100000;\n\t\tList<Edge> es = new ArrayList<>();\n\t\tint sink = 3*n;\n\t\tint src = 3*n+1;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tes.add(new Edge(Arrays.binarySearch(sxs, xs[i]), 2*n+i, 1, 0));\n\t\t\tes.add(new Edge(Arrays.binarySearch(sys, ys[i])+n, 2*n+i, 1, 0));\n\t\t\tes.add(new Edge(2*n+i, sink, 1, max-vs[i]));\n\t\t}\n\t\tEdge[] tar = new Edge[2*n];\n\t\tfor(int i = 0;i < 2*n;i++){\n\t\t\tes.add(tar[i] = new Edge(src, i, 1, 0));\n\t\t}\n\t\tlong F = solveMinCostFlowWithSPFA(compileWD(src+1, es), src, sink, 2*n);\n\t\tlong W = 0;\n\t\tfor(int i = 0;i < 2*n;i++){\n\t\t\tif(tar[i].flow == 1){\n\t\t\t\tW++;\n\t\t\t}\n\t\t}\n\t\tout.println(max*W-F);\n\t}\n\t\n\tpublic static int[] uniq(int[] a)\n\t{\n\t\tint n = a.length;\n\t\tint p = 0;\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tif(i == 0 || a[i] != a[i-1])a[p++] = a[i];\n\t\t}\n\t\treturn Arrays.copyOf(a, p);\n\t}\n\n\t\n\tpublic static class Edge\n\t{\n\t\tpublic int from, to;\n\t\tpublic int capacity;\n\t\tpublic long cost;\n\t\tpublic int flow;\n\t\tpublic Edge complement;\n\t\t// public int iniflow;\n\t\t\n\t\tpublic Edge(int from, int to, int capacity, long cost) {\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.capacity = capacity;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Edge [from=\" + from + \", to=\" + to + \", capacity=\"\n\t\t\t\t\t+ capacity + \", cost=\" + cost + \"]\";\n\t\t}\n\t}\n\t\n\tpublic static long addNegativeEdge(List<Edge> edges, Edge e, int src, int sink)\n\t{\n\t\tif(e.cost > 0){\n\t\t\tedges.add(e);\n\t\t\treturn 0;\n\t\t}else{\n\t\t\te.cost = -e.cost;\n\t\t\tedges.add(new Edge(src, e.to, e.capacity, 0));\n\t\t\tedges.add(new Edge(e.from, sink, e.capacity, 0));\n\t\t\t\t\t\n\t\t\tint d = e.from; e.from = e.to; e.to = d;\n\t\t\tedges.add(e);\n\t\t\treturn (long)e.capacity * -e.cost;\n\t\t}\n\t}\n\t\n\t// TODO test\n\tpublic static long addMinCapacityConstraintEdge(List<Edge> edges, Edge e, int minCapacity, int src, int sink)\n\t{\n\t\te.capacity -= minCapacity;\n\t\tedges.add(new Edge(src, e.to, minCapacity, 0));\n\t\tedges.add(new Edge(e.from, sink, minCapacity, 0));\n\t\treturn (long)minCapacity * e.cost;\n\t}\n\t\n\t\n\t\n\tpublic static Edge[][] compileWD(int n, List<Edge> edges)\n\t{\n\t\tEdge[][] g = new Edge[n][];\n\t\t// cloning\n\t\tfor(int i = edges.size()-1;i >= 0;i--){\n\t\t\tEdge origin = edges.get(i);\n\t\t\tEdge clone = new Edge(origin.to, origin.from, origin.capacity, -origin.cost);\n\t\t\tclone.flow = origin.capacity;\n\t\t\tclone.complement = origin;\n\t\t\torigin.complement = clone;\n\t\t\tedges.add(clone);\n\t\t}\n\t\t\n\t\tint[] p = new int[n];\n\t\tfor(Edge e : edges)p[e.from]++;\n\t\tfor(int i = 0;i < n;i++)g[i] = new Edge[p[i]];\n\t\tfor(Edge e : edges)g[e.from][--p[e.from]] = e;\n\t\treturn g;\n\t}\n\t\n\tpublic static class DQ {\n\t\tpublic int[] q;\n\t\tpublic int n;\n\t\tprotected int pt, ph;\n\t\t\n\t\tpublic DQ(int n){ this.n = Integer.highestOneBit(n)<<1; q = new int[this.n]; pt = ph = 0; }\n\t\t\n\t\tpublic void addLast(int x){ q[ph] = x; ph = ph+1&n-1; }\n\t\tpublic void addFirst(int x){ pt = pt+n-1&n-1; q[pt] = x; }\n\t\tpublic int pollFirst(){ int ret = q[pt]; pt = pt+1&n-1; return ret; }\n\t\tpublic int pollLast(){ ph = ph+n-1&n-1; int ret = q[ph]; return ret; }\n\t\tpublic int getFirst(){ return q[pt]; }\n\t\tpublic int getFirst(int k){ return q[pt+k&n-1]; }\n\t\tpublic int getLast(){ return q[ph+n-1&n-1]; }\n\t\tpublic int getLast(int k){ return q[ph+n-k-1&n-1]; }\n\t\tpublic void clear(){ pt = ph = 0; }\n\t\tpublic int size(){ return ph-pt+n&n-1; }\n\t\tpublic boolean isEmpty(){ return ph==pt; }\n\t}\n\n\t// negative is OK.\n\tpublic static long solveMinCostFlowWithSPFA(Edge[][] g, int source, int sink, long all)\n\t{\n\t\tint n = g.length;\n\t\tlong mincost = 0;\n\t\t\n\t\tfinal long[] d = new long[n];\n\t\tDQ q = new DQ(n);\n\t\tboolean[] inq = new boolean[n];\n\t\twhile(all > 0){\n\t\t\t// shortest path src->sink\n\t\t\tEdge[] inedge = new Edge[n];\n\t\t\tArrays.fill(d, Long.MAX_VALUE / 2);\n\t\t\td[source] = 0;\n\t\t\tq.addLast(source);\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint cur = q.pollFirst();\n\t\t\t\tinq[cur] = false;\n\t\t\t\tfor(Edge ne : g[cur]){\n\t\t\t\t\tif(ne.capacity - ne.flow > 0){\n\t\t\t\t\t\tlong nd = d[cur] + ne.cost;\n\t\t\t\t\t\tif(d[ne.to] > nd){\n\t\t\t\t\t\t\tinedge[ne.to] = ne;\n\t\t\t\t\t\t\td[ne.to] = nd;\n\t\t\t\t\t\t\tif(!inq[ne.to]){\n\t\t\t\t\t\t\t\tq.addLast(ne.to);\n\t\t\t\t\t\t\t\tinq[ne.to] = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(inedge[sink] == null)break;\n\t\t\t\n\t\t\tlong minflow = all;\n\t\t\tlong sumcost = 0;\n\t\t\tfor(Edge e = inedge[sink];e != null;e = inedge[e.from]){\n\t\t\t\tif(e.capacity - e.flow < minflow)minflow = e.capacity - e.flow;\n\t\t\t\tsumcost += e.cost;\n\t\t\t}\n\t\t\tmincost += minflow * sumcost;\n\t\t\tfor(Edge e = inedge[sink];e != null;e = inedge[e.from]){\n\t\t\t\te.flow += minflow;\n\t\t\t\te.complement.flow -= minflow;\n\t\t\t}\n\t\t\t\n\t\t\tall -= minflow;\n\t\t}\n\t\treturn mincost;\n\t}\n\t\n\t\n\t// neagtive is OK, and simple but maybe slower.\n\tpublic static long solveMinCostFlowWithBellmanFord(Edge[][] g, int source, int sink, long all)\n\t{\n\t\tint n = g.length;\n\t\tlong mincost = 0;\n\t\t\n\t\tfinal long[] d = new long[n];\n\t\twhile(all > 0){\n\t\t\t// shortest path src->sink\n\t\t\tEdge[] inedge = new Edge[n];\n\t\t\tArrays.fill(d, Long.MAX_VALUE / 2);\n\t\t\td[source] = 0;\n\t\t\t\n\t\t\tint nease = 0;\n\t\t\tfor(;;nease++){\n\t\t\t\tboolean changed = false;\n\t\t\t\tfor(Edge[] row : g){\n\t\t\t\t\tfor(Edge e : row){\n\t\t\t\t\t\tif(e.capacity - e.flow > 0){\n\t\t\t\t\t\t\tlong nd = d[e.from] + e.cost;\n\t\t\t\t\t\t\tif(nd < d[e.to]){\n\t\t\t\t\t\t\t\td[e.to] = nd;\n\t\t\t\t\t\t\t\tinedge[e.to] = e;\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(!changed)break;\n\t\t\t\tif(nease == n-1){\n\t\t\t\t\t// there are negative circuits.\n\t\t\t\t\tthrow new RuntimeException();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(inedge[sink] == null)break;\n\t\t\t\n\t\t\tlong minflow = all;\n\t\t\tlong sumcost = 0;\n\t\t\tboolean fromSource = false;\n\t\t\tfor(Edge e = inedge[sink];e != null;e = inedge[e.from]){\n\t\t\t\tif(e.capacity - e.flow < minflow)minflow = e.capacity - e.flow;\n\t\t\t\tsumcost += e.cost;\n\t\t\t\tif(e.from == source)fromSource = true;\n\t\t\t}\n\t\t\tif(!fromSource)break;\n\t\t\t\t\n\t\t\tmincost += minflow * sumcost;\n\t\t\tfor(Edge e = inedge[sink];e != null;e = inedge[e.from]){\n\t\t\t\te.flow += minflow;\n\t\t\t\te.complement.flow -= minflow;\n\t\t\t}\n\t\t\t\n\t\t\tall -= minflow;\n\t\t}\n\t\treturn mincost;\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\tstatic InputStream is;\n\tstatic PrintWriter out;\n\tstatic String INPUT = \"\";\n\t\n\tstatic void solve()\n\t{\n\t\tint n = ni();\n\t\tint h = ni(), w = ni();\n\t\tint[] xs = new int[n];\n\t\tint[] ys = new int[n];\n\t\tint[] vs = new int[n];\n\t\tfor(int i = 0;i < n;i++){\n\t\t\txs[i] = ni();\n\t\t\tys[i] = ni();\n\t\t\tvs[i] = ni();\n\t\t}\n\t\tint[] sxs = Arrays.copyOf(xs, n);\n\t\tArrays.sort(sxs);\n\t\tsxs = uniq(sxs);\n\t\tint[] sys = Arrays.copyOf(ys, n);\n\t\tArrays.sort(sys);\n\t\tsys = uniq(sys);\n\t\t\n\t\tint[][] es = new int[n][];\n\t\tfor(int i = 0;i < n;i++)es[i] = new int[]{xs[i], ys[i], vs[i]};\n\t\t\n\t\tArrays.sort(es, new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn -(a[2] - b[2]);\n\t\t\t}\n\t\t});\n\t\t\n\t\tDJSet ds = new DJSet(2*n);\n\t\tlong ans = 0;\n\t\tfor(int[] e : es){\n\t\t\tint f = Arrays.binarySearch(sxs, e[0]);\n\t\t\tint t = Arrays.binarySearch(sys, e[1])+n;\n\t\t\tif(!ds.cycle[ds.root(f)] || !ds.cycle[ds.root(t)]){\n\t\t\t\tboolean res = ds.union(f, t);\n\t\t\t\tans += e[2];\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\t\n\tpublic static class DJSet {\n\t\tpublic int[] upper;\n\t\tpublic boolean[] cycle;\n\n\t\tpublic DJSet(int n) {\n\t\t\tupper = new int[n];\n\t\t\tcycle = new boolean[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tpublic int root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tpublic boolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tpublic boolean union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (upper[y] < upper[x]) {\n\t\t\t\t\tint d = x;\n\t\t\t\t\tx = y;\n\t\t\t\t\ty = d;\n\t\t\t\t}\n\t\t\t\tupper[x] += upper[y];\n\t\t\t\tupper[y] = x;\n\t\t\t\t\n\t\t\t\tcycle[x] |= cycle[y];\n\t\t\t}else{\n\t\t\t\tcycle[x] = true;\n\t\t\t}\n\t\t\treturn x == y;\n\t\t}\n\n\t\tpublic int count() {\n\t\t\tint ct = 0;\n\t\t\tfor (int u : upper)\n\t\t\t\tif (u < 0)\n\t\t\t\t\tct++;\n\t\t\treturn ct;\n\t\t}\n\t}\n\n\t\n\tpublic static int[] uniq(int[] a)\n\t{\n\t\tint n = a.length;\n\t\tint p = 0;\n\t\tfor(int i = 0;i < n;i++) {\n\t\t\tif(i == 0 || a[i] != a[i-1])a[p++] = a[i];\n\t\t}\n\t\treturn Arrays.copyOf(a, p);\n\t}\n\tpublic static void main(String[] args) throws Exception\n\t{\n\t\tlong S = System.currentTimeMillis();\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tsolve();\n\t\tout.flush();\n\t\tlong G = System.currentTimeMillis();\n\t\ttr(G-S+\"ms\");\n\t}\n\t\n\tprivate static boolean eof()\n\t{\n\t\tif(lenbuf == -1)return true;\n\t\tint lptr = ptrbuf;\n\t\twhile(lptr < lenbuf)if(!isSpaceChar(inbuf[lptr++]))return false;\n\t\t\n\t\ttry {\n\t\t\tis.mark(1000);\n\t\t\twhile(true){\n\t\t\t\tint b = is.read();\n\t\t\t\tif(b == -1){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn true;\n\t\t\t\t}else if(!isSpaceChar(b)){\n\t\t\t\t\tis.reset();\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (IOException e) {\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\tprivate static byte[] inbuf = new byte[1024];\n\tstatic int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate static int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate static boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n//\tprivate static boolean isSpaceChar(int c) { return !(c >= 32 && c <= 126); }\n\tprivate static int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate static double nd() { return Double.parseDouble(ns()); }\n\tprivate static char nc() { return (char)skip(); }\n\t\n\tprivate static String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate static char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate static char[][] nm(int n, int m)\n\t{\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate static int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate static int ni()\n\t{\n\t\tint num = 0, b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\tprivate static void tr(Object... o) { if(INPUT.length() != 0)System.out.println(Arrays.deepToString(o)); }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        // int n = Integer.parseInt(bf.readLine());\n        StringTokenizer st = new StringTokenizer(bf.readLine());\n        // int[] a = new int[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());\n        int n = Integer.parseInt(st.nextToken());\n        int h = Integer.parseInt(st.nextToken());\n        int w = Integer.parseInt(st.nextToken());\n        int[] a = new int[n];\n        int[] r = new int[n];\n        int[] c = new int[n];\n        for(int i=0; i<n; i++) {\n           st = new StringTokenizer(bf.readLine());\n           r[i] = Integer.parseInt(st.nextToken());\n           c[i] = Integer.parseInt(st.nextToken());\n           a[i] = Integer.parseInt(st.nextToken());\n        }\n        Point[] points = new Point[n];\n        for(int i=0; i<n; i++) points[i] = new Point(r[i], c[i], a[i]);\n\n        Set<Integer> rows = new HashSet<Integer>();\n        Set<Integer> cols = new HashSet<Integer>();\n        Map<Integer, ArrayList<Integer>> rowmap = new HashMap<Integer, ArrayList<Integer>>();\n        Map<Integer, ArrayList<Integer>> colmap = new HashMap<Integer, ArrayList<Integer>>();\n        Arrays.sort(points);\n        long sum = 0;\n        ArrayList<Integer> conflicts = new ArrayList<Integer>();\n        Set<Integer> taken = new HashSet<Integer>();\n        for(int i=0; i<n; i++) {\n          boolean b1 = !rows.contains(points[i].r);\n          boolean b2 = !cols.contains(points[i].c);\n          if(b1 && b2) {\n            conflicts.add(i);\n            taken.add(i);\n            sum += points[i].a;\n          }\n          else if(b1 || b2) {\n            sum += points[i].a;\n            points[i].a = 0;\n            taken.add(i);\n          }\n          rows.add(points[i].r);\n          cols.add(points[i].c);\n          if(b1) rowmap.put(points[i].r, new ArrayList<Integer>());\n          if(b2) colmap.put(points[i].c, new ArrayList<Integer>());\n          if(points[i].a != 0) {\n          rowmap.get(points[i].r).add(i);\n          colmap.get(points[i].c).add(i);\n          }\n\n        }\n        for(int i=conflicts.size()-1; i>=0; i--) {\n          Point p = points[conflicts.get(i)];\n          int cur1 = 0; int val1 = -1;\n          for(int j : rowmap.get(p.r)) {\n            if(!taken.contains(j)) {\n              val1 = j;\n              cur1 = points[j].a;\n              break;\n            }\n          }\n\n          int cur2 = 0; int val2 = -1;\n          for(int j : colmap.get(p.c)) {\n            if(!taken.contains(j)) {\n              val2 = j;\n              cur2 = points[j].a;\n              break;\n            }\n          }\n          if(cur1 > cur2) {\n            sum += cur1;\n            taken.add(val1);\n          }\n          else {\n            sum += cur2;\n            taken.add(val2);\n          }\n        }\n        out.println(sum);\n        out.close(); System.exit(0);\n    }\n}\nclass Point implements Comparable<Point> {\n  public int r;\n  public int c;\n  public int a;\n  public Point(int r, int c, int a) {\n    this.r = r;\n    this.c = c;\n    this.a = a;\n  }\n  @Override\n  public boolean equals(Object o) {\n    Point p = (Point)o;\n    return (this.compareTo(p) == 0);\n  }\n\n  @Override\n  public int compareTo(Point p) {\n    if(this.a < p.a) return 1;\n    if(this.a > p.a) return -1;\n    if(this.r < p.r) return -1;\n    if(this.r > p.r) return 1;\n    if(this.c < p.c) return -1;\n    if(this.c > p.c) return 1;\n    return 0;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\n\nclass DisjointSet {\n  public int[] upper; // minus:num_element(root) plus:root(normal)\n  public int[] w;\n  public int[] e;\n\n  public DisjointSet(int n) {\n    upper = new int[n];\n    w = new int[n];\n    e = new int[n];\n    Arrays.fill(w, 1);\n    Arrays.fill(upper, -1);\n  }\n\n  public DisjointSet(DisjointSet ds) {\n    this.upper = Arrays.copyOf(ds.upper, ds.upper.length);\n  }\n\n  public int root(int x) {\n    return upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n  }\n\n  public boolean equiv(int x, int y) {\n    return root(x) == root(y);\n  }\n\n  public boolean union(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x != y) {\n      if (upper[y] < upper[x]) {\n        int d = x;\n        x = y;\n        y = d;\n      }\n      w[x] += w[y];\n      e[x] += e[y];\n      upper[x] += upper[y];\n      upper[y] = x;\n    }\n    e[x]++;\n    return x == y;\n  }\n\n}\n\n\npublic class Main {\n  private static void solve() {\n    int n = ni();\n    int h = ni();\n    int w = ni();\n    int[][] cards = ntable(n, 3);\n\n    Arrays.sort(cards, (o1, o2) -> o2[2] - o1[2]);\n\n    DisjointSet ds = new DisjointSet(h + w);\n\n    long ret = 0;\n    for (int[] e : cards) {\n      int u = ds.root(e[0] - 1);\n      int v = ds.root(e[1] - 1 + h);\n\n      if (ds.e[u] + ds.e[v] + 1 <= ds.w[u] + ds.w[v]) {\n        ds.union(u, v);\n        ret += e[2];\n      }\n    }\n\n    System.out.println(ret);\n  }\n\n  public static void main(String[] args) {\n    new Thread(null, new Runnable() {\n      @Override\n      public void run() {\n        long start = System.currentTimeMillis();\n        String debug = args.length > 0 ? args[0] : null;\n        if (debug != null) {\n          try {\n            is = java.nio.file.Files.newInputStream(java.nio.file.Paths.get(debug));\n          } catch (Exception e) {\n            throw new RuntimeException(e);\n          }\n        }\n        reader = new java.io.BufferedReader(new java.io.InputStreamReader(is), 32768);\n        solve();\n        out.flush();\n        tr((System.currentTimeMillis() - start) + \"ms\");\n      }\n    }, \"\", 64000000).start();\n  }\n\n  private static java.io.InputStream is = System.in;\n  private static java.io.PrintWriter out = new java.io.PrintWriter(System.out);\n  private static java.util.StringTokenizer tokenizer = null;\n  private static java.io.BufferedReader reader;\n\n  public static String next() {\n    while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n      try {\n        tokenizer = new java.util.StringTokenizer(reader.readLine());\n      } catch (Exception e) {\n        throw new RuntimeException(e);\n      }\n    }\n    return tokenizer.nextToken();\n  }\n\n  private static double nd() {\n    return Double.parseDouble(next());\n  }\n\n  private static long nl() {\n    return Long.parseLong(next());\n  }\n\n  private static int[] na(int n) {\n    int[] a = new int[n];\n    for (int i = 0; i < n; i++)\n      a[i] = ni();\n    return a;\n  }\n\n  private static char[] ns() {\n    return next().toCharArray();\n  }\n\n  private static long[] nal(int n) {\n    long[] a = new long[n];\n    for (int i = 0; i < n; i++)\n      a[i] = nl();\n    return a;\n  }\n\n  private static int[][] ntable(int n, int m) {\n    int[][] table = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[i][j] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int[][] nlist(int n, int m) {\n    int[][] table = new int[m][n];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        table[j][i] = ni();\n      }\n    }\n    return table;\n  }\n\n  private static int ni() {\n    return Integer.parseInt(next());\n  }\n\n  private static void tr(Object... o) {\n    if (is != System.in)\n      System.out.println(java.util.Arrays.deepToString(o));\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.lang.*;\nimport java.math.*;\npublic class Main {\n    public static void main(String[] args) throws Exception {\n        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));\n        PrintWriter out = new PrintWriter(new OutputStreamWriter(System.out));\n        // int n = Integer.parseInt(bf.readLine());\n        StringTokenizer st = new StringTokenizer(bf.readLine());\n        // int[] a = new int[n]; for(int i=0; i<n; i++) a[i] = Integer.parseInt(st.nextToken());\n        int n = Integer.parseInt(st.nextToken());\n        int h = Integer.parseInt(st.nextToken());\n        int w = Integer.parseInt(st.nextToken());\n        int[] a = new int[n];\n        int[] r = new int[n];\n        int[] c = new int[n];\n        for(int i=0; i<n; i++) {\n           st = new StringTokenizer(bf.readLine());\n           r[i] = Integer.parseInt(st.nextToken());\n           c[i] = Integer.parseInt(st.nextToken());\n           a[i] = Integer.parseInt(st.nextToken());\n        }\n        Point[] points = new Point[n];\n        for(int i=0; i<n; i++) points[i] = new Point(r[i], c[i], a[i]);\n\n        Set<Integer> rows = new HashSet<Integer>();\n        Set<Integer> cols = new HashSet<Integer>();\n        Map<Integer, ArrayList<Integer>> rowmap = new HashMap<Integer, ArrayList<Integer>>();\n        Map<Integer, ArrayList<Integer>> colmap = new HashMap<Integer, ArrayList<Integer>>();\n        Arrays.sort(points);\n        long sum = 0;\n        ArrayList<Integer> conflicts = new ArrayList<Integer>();\n        Set<Integer> taken = new HashSet<Integer>();\n        for(int i=0; i<n; i++) {\n          boolean b1 = !rows.contains(points[i].r);\n          boolean b2 = !cols.contains(points[i].c);\n          if(b1 && b2) {\n            conflicts.add(i);\n            taken.add(i);\n            sum += points[i].a;\n          }\n          else if(b1 || b2) {\n            conflicts.add(i);\n            if(b1) points[i].flag = 1;\n            else points[i].flag = 2;\n            //sum += points[i].a;\n            //points[i].a = 0;\n            //taken.add(i);\n          }\n          rows.add(points[i].r);\n          cols.add(points[i].c);\n          if(b1) rowmap.put(points[i].r, new ArrayList<Integer>());\n          if(b2) colmap.put(points[i].c, new ArrayList<Integer>());\n          if(points[i].a != 0) {\n          rowmap.get(points[i].r).add(i);\n          colmap.get(points[i].c).add(i);\n          }\n\n        }\n        for(int i=conflicts.size()-1; i>=0; i--) {\n          Point p = points[conflicts.get(i)];\n          int cur1 = 0; int val1 = -1;\n          for(int j : rowmap.get(p.r)) {\n            if(!taken.contains(j)) {\n              val1 = j;\n              cur1 = points[j].a;\n              break;\n            }\n          }\n\n          int cur2 = 0; int val2 = -1;\n          for(int j : colmap.get(p.c)) {\n            if(!taken.contains(j)) {\n              val2 = j;\n              cur2 = points[j].a;\n              break;\n            }\n          }\n          if((p.flag==0)) {\n          if(cur1 > cur2) {\n            sum += cur1;\n            taken.add(val1);\n          }\n          else {\n            sum += cur2;\n            taken.add(val2);\n          }\n          }\n          else {\n            if(p.flag == 1) {\n              sum += cur1;\n              taken.add(val1);\n            }\n            else {\n              sum += cur2;\n              taken.add(val2);\n            }\n          }\n        }\n        out.println(sum);\n        out.close(); System.exit(0);\n    }\n}\nclass Point implements Comparable<Point> {\n  public int r;\n  public int c;\n  public int a;\n  public int flag;\n  public Point(int r, int c, int a) {\n    this.flag = 0;\n    this.r = r;\n    this.c = c;\n    this.a = a;\n  }\n  @Override\n  public boolean equals(Object o) {\n    Point p = (Point)o;\n    return (this.compareTo(p) == 0);\n  }\n\n  @Override\n  public int compareTo(Point p) {\n    if(this.a < p.a) return 1;\n    if(this.a > p.a) return -1;\n    if(this.r < p.r) return -1;\n    if(this.r > p.r) return 1;\n    if(this.c < p.c) return -1;\n    if(this.c > p.c) return 1;\n    return 0;\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.text.*;\npublic class Main{\n    //SOLUTION BEGIN\n    //Into the Hardware Mode\n    void pre() throws Exception{}\n//    int n, m, t;\n    void solve(int TC) throws Exception{\n//        n = ni(); m = ni();int z = ni(); t = ni();\n//        char[][] gr = new char[n][];\n//        for(int i = 0; i< n; i++)gr[i] = n().toCharArray();\n//        int[][][] mat = new int[1+t][n][m];\n//        while(z-->0){\n//            int rr = ni()-1, cc = ni()-1, st = ni(), en = ni(), g = ni();\n//            for(int j = st+1; j<= en; j++)\n//                mat[j][rr][cc] = Math.max(mat[j][rr][cc], g);\n//        }\n//        \n//        int[][] D = new int[][]{\n//            {-1, 0},{0, -1}, {0, 1}, {1, 0}\n//        };\n//        for(int ti = 0; ti< t; ti++){\n//            for(int i = 0; i< n; i++)\n//                for(int j = 0; j< m; j++){\n//                    if(gr[i][j] == '#')continue;\n//                    addEdge(graph, get(ti, i, j, 0), get(ti, i, j, 1), 1, 0);\n//                    \n//                    addEdge(graph, get(ti, i, j, 1), get(ti+1, i, j, 0), 1, -mat[ti+1][i][j]);\n//                    for(int[] d:D){\n//                        int ii = i+d[0], jj = j+d[1];\n//                        if(ii < 0 || ii >= n || jj < 0 || jj >= m || gr[ii][jj] == '#')continue;\n//                        addEdge(graph, get(ti, i, j, 1), get(ti+1, ii, jj, 0),1, 0);\n//                    }\n//                }\n//        }\n//        for(int i = 0; i< n; i++)\n//            for(int j = 0; j< m; j++){\n//                if(gr[i][j] == 'S')addEdge(graph, src, get(0, i, j, 0), 1, 0);\n//                if(gr[i][j] != '#'){\n//                    addEdge(graph, get(t, i, j, 0), get(t, i, j, 1), 1, 0);\n//                    addEdge(graph, get(t, i, j, 1), dest, 1, 0);\n//                }\n//            }\n        \n        int n = ni(), h = ni(), w = ni();\n        \n        List<Edge>[] graph = createGraph(2+n+h+w);\n        int src = 0, dest = 1;\n        for(int i = 0; i< n; i++){\n            int r = ni()-1, c = ni()-1;long cost = nl();\n            addEdge(graph, 0, 2+i, 1, -cost);\n            \n            addEdge(graph, 2+i, 2+n+r, 1, 0);\n            addEdge(graph, 2+i, 2+n+h+c, 1, 0);\n        }\n        for(int i = 0; i< h+w; i++)addEdge(graph, 2+n+i, 1, 1, 0);\n        \n        int[] res = minCostFlow(graph, src, dest, Integer.MAX_VALUE);\n        pn(-res[1]);\n        \n    }\n//    int get(int ti, int r, int c,int ty){\n//        return 2+ty+2*(c+m*(r+n*ti));\n//    }\n    //https://sites.google.com/site/indy256/algo/min_cost_flow_bf\n    static class Edge {\n    int to, f, cap, rev;\n    long cost;\n    Edge(int v, int cap, long cost, int rev) {\n      this.to = v;\n      this.cap = cap;\n      this.cost = cost;\n      this.rev = rev;\n    }\n  }\n\n  public static List<Edge>[] createGraph(int n) {\n    List<Edge>[] graph = new List[n];\n    for (int i = 0; i < n; i++)\n      graph[i] = new ArrayList<>();\n    return graph;\n  }\n\n  public static void addEdge(List<Edge>[] graph, int s, int t, int cap, long cost) {\n    graph[s].add(new Edge(t, cap, cost, graph[t].size()));\n    graph[t].add(new Edge(s, 0, -cost, graph[s].size() - 1));\n  }\n\n  static void bellmanFord(List<Edge>[] graph, int s, long[] dist) {\n    int n = graph.length;\n    Arrays.fill(dist, Integer.MAX_VALUE);\n    dist[s] = 0;\n    boolean[] inqueue = new boolean[n];\n    int[] q = new int[n];\n    int qt = 0;\n    q[qt++] = s;\n    for (int qh = 0; (qh - qt) % n != 0; qh++) {\n      int u = q[qh % n];\n      inqueue[u] = false;\n      for (int i = 0; i < graph[u].size(); i++) {\n        Edge e = graph[u].get(i);\n        if (e.cap <= e.f)\n          continue;\n        int v = e.to;\n        long ndist = dist[u] + e.cost;\n        if (dist[v] > ndist) {\n          dist[v] = ndist;\n          if (!inqueue[v]) {\n            inqueue[v] = true;\n            q[qt++ % n] = v;\n          }\n        }\n      }\n    }\n  }\n\n  public static int[] minCostFlow(List<Edge>[] graph, int s, int t, int maxf) {\n    int n = graph.length;\n    long[] prio = new long[n];\n    int[] curflow = new int[n];\n    int[] prevedge = new int[n];\n    int[] prevnode = new int[n];\n    long[] pot = new long[n];\n\n    // bellmanFord invocation can be skipped if edges costs are non-negative\n//    bellmanFord(graph, s, pot);\n    int flow = 0;\n    int flowCost = 0;\n    while (flow < maxf) {\n      PriorityQueue<Long> q = new PriorityQueue<>();\n      q.add((long) s);\n      Arrays.fill(prio, Integer.MAX_VALUE);\n      prio[s] = 0;\n      boolean[] finished = new boolean[n];\n      curflow[s] = Integer.MAX_VALUE;\n      while (!finished[t] && !q.isEmpty()) {\n        long cur = q.remove();\n        int u = (int) (cur & 0xFFFF_FFFFL);\n        int priou = (int) (cur >>> 32);\n        if (priou != prio[u])\n          continue;\n        finished[u] = true;\n        for (int i = 0; i < graph[u].size(); i++) {\n          Edge e = graph[u].get(i);\n          if (e.f >= e.cap)\n            continue;\n          int v = e.to;\n          long nprio = prio[u] + e.cost + pot[u] - pot[v];\n          if (prio[v] > nprio) {\n            prio[v] = nprio;\n            q.add(((long) nprio << 32) + v);\n            prevnode[v] = u;\n            prevedge[v] = i;\n            curflow[v] = Math.min(curflow[u], e.cap - e.f);\n          }\n        }\n      }\n      if (prio[t] == Integer.MAX_VALUE)\n        break;\n      for (int i = 0; i < n; i++)\n        if (finished[i])\n          pot[i] += prio[i] - prio[t];\n      int df = Math.min(curflow[t], maxf - flow);\n      flow += df;\n      for (int v = t; v != s; v = prevnode[v]) {\n        Edge e = graph[prevnode[v]].get(prevedge[v]);\n        e.f += df;\n        graph[v].get(e.rev).f -= df;\n        flowCost += df * e.cost;\n      }\n    }\n    return new int[]{flow, flowCost};\n  }\n    //SOLUTION END\n    void hold(boolean b)throws Exception{if(!b)throw new Exception(\"Hold right there, Sparky!\");}\n    long IINF = (long)1e18, mod = (long)1e9+7;\n    final int INF = (int)1e9, MX = (int)2e5+5;\n    DecimalFormat df = new DecimalFormat(\"0.00000000000\");\n    double PI = 3.141592653589793238462643383279502884197169399, eps = 1e-6;\n    static boolean multipleTC = false, memory = false;\n    FastReader in;PrintWriter out;\n    void run() throws Exception{\n        in = new FastReader();\n        out = new PrintWriter(System.out);\n        //Solution Credits: Taranpreet Singh\n        int T = (multipleTC)?ni():1;\n        pre();for(int t = 1; t<= T; t++)solve(t);\n        out.flush();\n        out.close();\n    }\n    public static void main(String[] args) throws Exception{\n        if(memory)new Thread(null, new Runnable() {public void run(){try{new Main().run();}catch(Exception e){e.printStackTrace();}}}, \"1\", 1 << 28).start();\n        else new Main().run();\n    }\n    long gcd(long a, long b){return (b==0)?a:gcd(b,a%b);}\n    int gcd(int a, int b){return (b==0)?a:gcd(b,a%b);}\n    int bit(long n){return (n==0)?0:(1+bit(n&(n-1)));}\n    void p(Object o){out.print(o);}\n    void pn(Object o){out.println(o);}\n    void pni(Object o){out.println(o);out.flush();}\n    String n()throws Exception{return in.next();}\n    String nln()throws Exception{return in.nextLine();}\n    int ni()throws Exception{return Integer.parseInt(in.next());}\n    long nl()throws Exception{return Long.parseLong(in.next());}\n    double nd()throws Exception{return Double.parseDouble(in.next());}\n\n    class FastReader{\n        BufferedReader br;\n        StringTokenizer st;\n        public FastReader(){\n            br = new BufferedReader(new InputStreamReader(System.in));\n        }\n\n        public FastReader(String s) throws Exception{\n            br = new BufferedReader(new FileReader(s));\n        }\n\n        String next() throws Exception{\n            while (st == null || !st.hasMoreElements()){\n                try{\n                    st = new StringTokenizer(br.readLine());\n                }catch (IOException  e){\n                    throw new Exception(e.toString());\n                }\n            }\n            return st.nextToken();\n        }\n\n        String nextLine() throws Exception{\n            String str = \"\";\n            try{   \n                str = br.readLine();\n            }catch (IOException e){\n                throw new Exception(e.toString());\n            }  \n            return str;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Threading;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression,\n                          System.Linq.Expressions.UnaryExpression>;\n\nclass Program {\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const int M2 = 998244353;\n    const long LM = 1L << 60;\n    const double eps = 1e-11;\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n\n    static void Main(string[] args)\n    {\n        var solver = new Solver();\n        // var t = new Thread(solver.solve, 1 << 26); // 64 MB\n\t\t// t.Start();\n\t\t// t.Join();\n        solver.solve();\n        sw.Flush();\n    }\n\n\n    class Solver {\n        public void solve() {\n            int n, h, w;\n            sc.Multi(out n, out h, out w);\n            var p = new pair<P, int>[n];\n            var ph = new List<P>[h];\n            var pw = new List<P>[w];\n            for (int i = 0; i < h; i++)\n            {\n                ph[i] = new List<P>();\n            }\n            for (int i = 0; i < w; i++)\n            {\n                pw[i] = new List<P>();\n            }\n            var uf = new UnionFind(h + w);\n            for (int i = 0; i < n; i++)\n            {\n                int r, c, a;\n                sc.Multi(out r, out c, out a);\n                --r;\n                --c;\n                p[i] = make_pair(new P(r, c), a);\n                ph[r].Add(new P(a, i));\n                pw[c].Add(new P(a, i));\n            }\n            var used = new int[n];\n            long ans = 0;\n            for (int i = 0; i < h; i++)\n            {\n                if (ph[i].Count == 0) continue;\n                ph[i].Sort();\n                ph[i].Reverse();\n                if (used[ph[i][0].v2] == 0)\n                    ans += ph[i][0].v1;\n                ++used[ph[i][0].v2];\n            }\n            for (int i = 0; i < w; i++)\n            {\n                if (pw[i].Count == 0) continue;\n                pw[i].Sort();\n                pw[i].Reverse();\n                if (used[pw[i][0].v2] == 0)\n                    ans += pw[i][0].v1;\n                ++used[pw[i][0].v2];\n            }\n            var cnt = new int[h + w];\n            var lis = new List<P>[h + w];\n            for (int i = 0; i < h + w; i++)\n            {\n                lis[i] = new List<P>();\n            }\n            for (int i = 0; i < n; i++)\n            {\n                if (used[i] > 0) {\n                    uf.unite(p[i].v1.v1, h + p[i].v1.v2);\n                }\n            }\n            for (int i = 0; i < n; i++)\n            {\n                if (used[i] == 0)\n                    lis[uf.getpar(p[i].v1.v1)].Add(new P(p[i].v2, i));\n                else {\n                    cnt[uf.getpar(p[i].v1.v1)] += used[i] - 1;\n                }\n            }\n            for (int i = 0; i < h + w; i++)\n            {\n                lis[i].Sort();\n                lis[i].Reverse();\n                foreach (var item in lis[i])\n                {\n                    if (cnt[i] > 0) {\n                        --cnt[i];\n                        ans += item.v1;\n                    }\n                }\n            }\n            Prt(ans);\n        } // end Solver.solve\n\n    }\n}\n\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n    public static bool operator>(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) > 0;\n    public static bool operator<(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) < 0;\n    public static bool operator>=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) >= 0;\n    public static bool operator<=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) <= 0;\n}\nstatic class util {\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static T sq<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    static readonly int[] dd = { 0, 1, 0, -1 };\n    static readonly string dstring = \"RDLU\";\n    public static P[] adjacents(this P p) => adjacents(p.v1, p.v2);\n    public static P[] adjacents(this P p, int h, int w) => adjacents(p.v1, p.v2, h, w);\n    public static pair<P, char>[] adjacents_with_str(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new pair<P, char>(new P(i + dd[k], j + dd[k ^ 1]), dstring[k])).ToArray();\n    public static pair<P, char>[] adjacents_with_str(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new pair<P, char>(new P(i + dd[k], j + dd[k ^ 1]), dstring[k]))\n                                         .Where(p => inside(p.v1.v1, p.v1.v2, h, w)).ToArray();\n    public static P[] adjacents(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).ToArray();\n    public static P[] adjacents(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).Where(p => inside(p.v1, p.v2, h, w)).ToArray();\n    public static void Assert(bool cond) { if (!cond) throw new Exception(); }\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T> {\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\nclass UnionFind {\n    int num;\n    int[] par, sz, rank;\n    public UnionFind(int n) {\n        num = n; par = new int[n]; sz = new int[n]; rank = new int[n];\n        for (int i = 0; i < n; ++i) { par[i] = i; sz[i] = 1; rank[i] = 0; }\n    }\n    int find(int x) => par[x] == x ? x : (par[x] = find(par[x]));\n    public bool same(int x, int y) => find(x) == find(y);\n    public int unionsize(int x) => sz[find(x)];\n    public int unioncount => num;\n    public bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if (x == y) return false;\n        --num;\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n            sz[y] += sz[x];\n        }\n        else {\n            par[y] = x;\n            sz[x] += sz[y];\n            if (rank[x] == rank[y]) ++rank[x];\n        }\n        return true;\n    }\n    public bool ispar(int x) => x == find(x);\n    public int getpar(int x) => find(x);\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading;\nusing System.Runtime.CompilerServices;\nusing System.Diagnostics;\nusing static System.Math;\nusing static System.Array;\nusing static AtCoder.Sc_out;\nusing static AtCoder.Tool;\nusing static AtCoder.ModInt;\nnamespace AtCoder\n{\n    class AC\n    {\n        const int MOD = 1000000007;\n        //const int MOD = 998244353;\n\n        const int INF = int.MaxValue / 2;\n        const long SINF = long.MaxValue / 3;\n        const double EPS = 1e-8;\n        static readonly int[] dI = { 0, 1, 0, -1, 1, -1, -1, 1 };\n        static readonly int[] dJ = { 1, 0, -1, 0, 1, 1, -1, -1 };\n        //static List<List<int>> G = new List<List<int>>();\n        //static List<List<Edge>> G = new List<List<Edge>>();\n        //static List<Edge> E = new List<Edge>();\n        static void Main(string[] args)\n        {\n            //var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; Console.SetOut(sw);\n\n            var th = new Thread(Run, 1 << 26);\n            th.Start();\n            th.Join();\n\n            //Run();\n            Console.Out.Flush();\n        }\n        static void Run()\n        {\n            int Testcase = 1;\n            //Testcase = Cin.Int;\n            for (var _ = 0; _ < Testcase; _++) Solve();\n        }\n        static void Solve()\n        {\n            Cin.Input(out int N, out int H, out int W);\n            var R = new int[N];\n            var C = new int[N];\n            var A = new long[N];\n            var card = new List<(long, int, int)>();\n            for(var i = 0; i < N; i++)\n            {\n                Cin.Input(out R[i], out C[i], out A[i]);\n                card.Add((A[i], --R[i], --C[i]));\n            }\n            long ans = 0;\n            card.Sort();\n            card.Reverse();\n            var used = new HashSet<(int, int)>();\n            var G = new List<List<int>>();\n            for (var i = 0; i < H + W; i++) G.Add(new List<int>());\n            var uf = new UnionFind(H + W);\n            var e = new int[H + W];\n            foreach(var cd in card)\n            {\n                int r = cd.Item2;\n                int c = cd.Item3;\n                long V = cd.Item1;\n\n                if (uf.SameRoot(r, H + c))\n                {\n                    if (uf.SizeOf(r) > e[uf.Root(r)])\n                    {\n                        ans += V;\n                        e[uf.Root(r)]++;\n                    }\n                }\n                else\n                {\n                    int a = uf.Root(r);\n                    int b = uf.Root(H + c);\n\n                    int s = uf.SizeOf(r) + uf.SizeOf(H + c);\n                    if (e[a] + e[b] + 1 <= s)\n                    {\n                        ans += V;\n                        uf.Unite(r, H + c);\n                        int rt = uf.Root(r);\n                        e[rt] = e[a] + e[b] + 1;\n                    }\n                }\n            }\n            OutL(ans);\n            \n        }\n        public struct Edge\n        {\n            public int from;\n\n            public int to;\n            public long dist;\n\n            public Edge(int t, long c)\n            {\n                from = -1;\n                to = t;\n                dist = c;\n            }\n            public Edge(int f, int t, long c)\n            {\n                from = f;\n                to = t;\n                dist = c;\n            }\n        }\n\n    }\n    public class PrimeList\n    {\n        private bool[] isprime;\n        private List<int> primelist;\n\n        public PrimeList(int n)\n        {\n            if (n < 2) { return; }\n            primelist = new List<int>();\n            isprime = new bool[n + 1];\n            for (var i = 0; i <= n; i++)\n            {\n                isprime[i] = i != 0 && i != 1;\n            }\n\n            for (var i = 2; i <= n; i++)\n            {\n                if (!isprime[i]) { continue; }\n                primelist.Add(i);\n\n                int c = i;\n                while (c + i <= n)\n                {\n                    c += i;\n                    isprime[c] = false;\n                }\n            }\n        }\n\n        public bool IsPrime(int n)\n        {\n            return isprime[n];\n        }\n\n        public List<int> GetPrimeList()\n        {\n            return primelist;\n        }\n\n    }\n    public class Priority_Queue<T>\n    {\n        private List<T> Q;\n        private readonly Comparison<T> Func_Compare;\n        public Priority_Queue(Comparison<T> comp)\n        {\n            Func_Compare = comp;\n            Q = new List<T>();\n        }\n        private void PushHeap(List<T> list, T item)\n        {\n            int n = list.Count();\n            list.Add(item);\n\n            while (n != 0)\n            {\n                int pIndex = (n - 1) / 2;\n\n                if (Func_Compare(list[n], list[pIndex]) < 0)\n                {\n                    Swap(Q, n, pIndex);\n                }\n                else { break; }\n\n                n = pIndex;\n            }\n        }\n        private void PopHeap(List<T> list)\n        {\n            int n = list.Count() - 1;\n            list[0] = list[n];\n            list.RemoveAt(n);\n\n            int cur = 0;\n            int comp;\n\n            while (2 * cur + 1 <= n - 1)\n            {\n                int c1 = 2 * cur + 1;\n                int c2 = 2 * (cur + 1);\n                if (c1 == n - 1)\n                {\n                    comp = c1;\n                }\n                else\n                {\n\n                    comp = Func_Compare(list[c1], list[c2]) < 0 ? c1 : c2;\n                }\n\n                if (Func_Compare(list[cur], list[comp]) > 0)\n                {\n                    Swap(Q, cur, comp);\n                }\n                else { break; }\n\n                cur = comp;\n            }\n        }\n        private void Swap(List<T> list, int a, int b)\n        {\n            T keep = list[a];\n            list[a] = list[b];\n            list[b] = keep;\n        }\n\n        public void Enqueue(T value)\n        {\n            PushHeap(Q, value);\n        }\n\n        public T Dequeue()\n        {\n            T ret = Q[0];\n            PopHeap(Q);\n            return ret;\n        }\n\n        public T Peek()\n        {\n            return Q[0];\n        }\n\n        public int Count()\n        {\n            return Q.Count();\n        }\n        public bool Any()\n        {\n            return Q.Any();\n        }\n    }\n    public class SegmentTree<T>\n    {\n        //1-indexed type\n        int n;\n        T[] Tree;\n        Func<T, T, T> f;\n        T ex;\n        int L;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public SegmentTree(int size, Func<T, T, T> fun, T exvalue)\n        {\n            ex = exvalue;\n            f = fun;\n            n = 1;\n            while (n < size) n <<= 1;\n            Tree = new T[n << 1];\n            L = (n << 1) - 1;\n            for (var i = 0; i <= L; i++) Tree[i] = ex;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public SegmentTree(int size, Func<T, T, T> fun, T exvalue, T[] initial)\n        {\n            ex = exvalue;\n            n = 1; while (n < size) n <<= 1;\n            f = fun;\n            Tree = new T[n << 1];\n            L = (n << 1) - 1;\n            for (var i = 0; i <= L; i++) Tree[i] = (n <= i && i <= n + initial.Length - 1) ? initial[i - n] : ex;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Set_All()\n        {\n            for (var i = n - 1; i >= 1; i--) Tree[i] = f(Tree[i << 1], Tree[(i << 1) | 1]);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Assign(int idx, T nxt) => Tree[idx + n] = nxt;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Update(int idx)\n        {\n            int now = idx + n;\n            while (now > 1)\n            {\n                now >>= 1;\n                Tree[now] = f(Tree[now << 1], Tree[now << 1 | 1]);\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Query_Update(int idx, T nxt)\n        {\n            Assign(idx, nxt); Update(idx);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Query_Update_func(int idx, T y)\n        {\n            Assign(idx, f(Peek(idx), y)); Update(idx);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Query_Fold(int l, int r)\n        {\n            int L = n + l;\n            int R = n + r;\n            T vL = ex, vR = ex;\n            while (L < R)\n            {\n                if (L % 2 == 1)\n                {\n                    vL = f(vL, Tree[L]);\n                    L++;\n                }\n                if (R % 2 == 1)\n                {\n                    vR = f(Tree[R - 1], vR);\n                    R--;\n                }\n                L >>= 1;\n                R >>= 1;\n            }\n            return f(vL, vR);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Peek(int idx) => Tree[idx + n];\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Display(int len)\n        {\n            for (var i = 0; i < len; i++) Console.Write($\"{Tree[i + n]} \");\n            Console.WriteLine();\n        }\n    }\n    public class UnionFind\n    {\n        private int[] parent;\n        private int[] rank;\n        private int[] size;\n        public UnionFind(int n)\n        {\n            parent = new int[n];\n            rank = new int[n];\n            size = new int[n];\n            for (var i = 0; i < n; i++)\n            {\n                parent[i] = i;\n                rank[i] = 0;\n                size[i] = 1;\n            }\n        }\n\n        public int Root(int x)\n        {\n            return parent[x] == x ? x : parent[x] = Root(parent[x]);\n        }\n\n        public bool SameRoot(int x, int y)\n        {\n            return Root(x) == Root(y);\n        }\n\n        public void Unite(int x, int y)\n        {\n            x = Root(x);\n            y = Root(y);\n            if (x == y) { return; }\n\n            if (rank[x] < rank[y])\n            {\n                parent[x] = y;\n                size[y] += size[x];\n                size[x] = 0;\n            }\n            else\n            {\n                parent[y] = x;\n                if (rank[x] == rank[y]) { rank[x]++; }\n                size[x] += size[y];\n                size[y] = 0;\n            }\n        }\n\n        public int SizeOf(int x)\n        {\n            return size[Root(x)];\n        }\n\n    }\n    struct ModInt\n    {\n        public long value;\n        private const int MOD = 1000000007;\n        //private const int MOD = 998244353;\n        public ModInt(long value) { this.value = value; }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static implicit operator ModInt(long a)\n        {\n            var ret = a % MOD;\n            return new ModInt(ret < 0 ? (ret + MOD) : ret);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator +(ModInt a, ModInt b) => (a.value + b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator -(ModInt a, ModInt b) => (a.value - b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator *(ModInt a, ModInt b) => (a.value * b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator /(ModInt a, ModInt b) => a * Modpow(b, MOD - 2);\n\n        public static ModInt operator <<(ModInt a, int n) => (a.value << n);\n        public static ModInt operator >>(ModInt a, int n) => (a.value >> n);\n        public static ModInt operator ++(ModInt a) => a.value + 1;\n        public static ModInt operator --(ModInt a) => a.value - 1;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Modpow(ModInt a, long n)\n        {\n            var k = a;\n            ModInt ret = 1;\n            while (n > 0)\n            {\n                if ((n & 1) != 0) ret *= k;\n                k *= k;\n                n >>= 1;\n            }\n            return ret;\n        }\n        private static readonly List<long> Factorials = new List<long>() { 1 };\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Fac(long n)\n        {\n            for (var i = Factorials.Count(); i <= n; i++)\n            {\n                Factorials.Add((Factorials[i - 1] * i) % MOD);\n            }\n            return Factorials[(int)n];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt nCr(long n, long r)\n        {\n            return n < r ? 0 : Fac(n) / (Fac(r) * Fac(n - r));\n        }\n        public static explicit operator int(ModInt a) => (int)a.value;\n    }\n    static class Cin\n    {\n        public static string[] ReadSplit => Console.ReadLine().Split();\n        public static int[] ReadSplitInt => ConvertAll(Console.ReadLine().Split(), int.Parse);\n        public static long[] ReadSplitLong => ConvertAll(Console.ReadLine().Split(), long.Parse);\n        public static double[] ReadSplit_Double => ConvertAll(Console.ReadLine().Split(), double.Parse);\n        public static string Str => Console.ReadLine();\n        public static int Int => int.Parse(Console.ReadLine());\n        public static long Long => long.Parse(Console.ReadLine());\n        public static double Double => double.Parse(Console.ReadLine());\n        public static T Conv<T>(string input)\n        {\n            if (typeof(T).Equals(typeof(ModInt)))\n            {\n                return (T)(dynamic)(long.Parse(input));\n            }\n            return (T)Convert.ChangeType(input, typeof(T));\n        }\n        public static void Input<T>(out T a) => a = Conv<T>(Console.ReadLine());\n        public static void Input<T, U>(out T a, out U b)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); }\n        public static void Input<T, U, V>(out T a, out U b, out V c)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); }\n        public static void Input<T, U, V, W>(out T a, out U b, out V c, out W d)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); }\n        public static void Input<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); e = Conv<X>(q[4]); }\n    }\n    static class Sc_out\n    {\n        public static void OutL(object s) => Console.WriteLine(s);\n        public static void Out_Sep<T>(IEnumerable<T> s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_Sep<T>(IEnumerable<T> s, string sep) => Console.WriteLine(string.Join($\"{sep}\", s));\n        public static void Out_Sep(params object[] s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_One(object s) => Console.Write($\"{s} \");\n        public static void Out_One(object s, string sep) => Console.Write($\"{s}{sep}\");\n        public static void Endl() => Console.WriteLine();\n    }\n    public static class Tool\n    {\n        static public void Initialize<T>(ref T[] array, T initialvalue)\n        {\n            array = ConvertAll(array, x => initialvalue);\n        }\n        static public void Swap<T>(ref T a, ref T b)\n        {\n            T keep = a;\n            a = b;\n            b = keep;\n        }\n        static public void Display<T>(T[,] array2d, int n, int m)\n        {\n            for (var i = 0; i < n; i++)\n            {\n                for (var j = 0; j < m; j++)\n                {\n                    Console.Write($\"{array2d[i, j]} \");\n                }\n                Console.WriteLine();\n            }\n        }\n        static public long Gcd(long a, long b)\n        {\n            if (a == 0 || b == 0) return Max(a, b);\n            return a % b == 0 ? b : Gcd(b, a % b);\n        }\n        static public long LPow(int a, int b) => (long)Pow(a, b);\n        static public bool Bit(long x, int dig) => ((1L << dig) & x) != 0;\n        static public int Sig(long a) => a == 0 ? 0 : (int)(a / Abs(a));\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading;\nusing System.Runtime.CompilerServices;\nusing System.Diagnostics;\nusing static System.Math;\nusing static System.Array;\nusing static AtCoder.Sc_out;\nusing static AtCoder.Tool;\nusing static AtCoder.ModInt;\nnamespace AtCoder\n{\n    class AC\n    {\n        const int MOD = 1000000007;\n        //const int MOD = 998244353;\n\n        const int INF = int.MaxValue / 2;\n        const long SINF = long.MaxValue / 3;\n        const double EPS = 1e-8;\n        static readonly int[] dI = { 0, 1, 0, -1, 1, -1, -1, 1 };\n        static readonly int[] dJ = { 1, 0, -1, 0, 1, 1, -1, -1 };\n        //static List<List<int>> G = new List<List<int>>();\n        //static List<List<Edge>> G = new List<List<Edge>>();\n        //static List<Edge> E = new List<Edge>();\n        static void Main(string[] args)\n        {\n            //var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; Console.SetOut(sw);\n\n            var th = new Thread(Run, 1 << 26);\n            th.Start();\n            th.Join();\n\n            //Run();\n            Console.Out.Flush();\n        }\n        static void Run()\n        {\n            int Testcase = 1;\n            //Testcase = Cin.Int;\n            for (var _ = 0; _ < Testcase; _++) Solve();\n        }\n        static void Solve()\n        {\n            Cin.Input(out int N, out int H, out int W);\n            var R = new int[N];\n            var C = new int[N];\n            var A = new long[N];\n            var card = new List<(long, int, int)>();\n            for(var i = 0; i < N; i++)\n            {\n                Cin.Input(out R[i], out C[i], out A[i]);\n                card.Add((A[i], --R[i], --C[i]));\n            }\n            long ans = 0;\n            card.Sort();\n            card.Reverse();\n            var used = new HashSet<(int, int)>();\n            var G = new List<List<int>>();\n            for (var i = 0; i < H + W; i++) G.Add(new List<int>());\n            var ch = new bool[H + W];\n            void dfs(int v)\n            {\n                ch[v] = true;\n                foreach(var nx in G[v])\n                {\n                    if (!ch[nx]) dfs(nx);\n                }\n            }\n            foreach(var cd in card)\n            {\n                int r = cd.Item2;\n                int c = cd.Item3;\n                long V = cd.Item1;\n\n                if (ch[r] && ch[H + c])\n                {\n                    continue;\n                }\n                G[r].Add(H + c);\n                G[H + c].Add(r);\n                ans += V;\n                if (ch[r])\n                {\n                    ch[H + c] = true;\n                }\n                else if (ch[H + c])\n                {\n                    ch[r] = true;\n                }\n                else\n                {\n                    if (used.Contains((r, c)))\n                    {\n                        dfs(r);\n                    }\n                    else\n                    {\n                        used.Add((r, c));\n                    }\n                }\n\n                //Out_Sep(ch);\n            }\n            OutL(ans);\n            \n        }\n        public struct Edge\n        {\n            public int from;\n\n            public int to;\n            public long dist;\n\n            public Edge(int t, long c)\n            {\n                from = -1;\n                to = t;\n                dist = c;\n            }\n            public Edge(int f, int t, long c)\n            {\n                from = f;\n                to = t;\n                dist = c;\n            }\n        }\n\n    }\n    public class PrimeList\n    {\n        private bool[] isprime;\n        private List<int> primelist;\n\n        public PrimeList(int n)\n        {\n            if (n < 2) { return; }\n            primelist = new List<int>();\n            isprime = new bool[n + 1];\n            for (var i = 0; i <= n; i++)\n            {\n                isprime[i] = i != 0 && i != 1;\n            }\n\n            for (var i = 2; i <= n; i++)\n            {\n                if (!isprime[i]) { continue; }\n                primelist.Add(i);\n\n                int c = i;\n                while (c + i <= n)\n                {\n                    c += i;\n                    isprime[c] = false;\n                }\n            }\n        }\n\n        public bool IsPrime(int n)\n        {\n            return isprime[n];\n        }\n\n        public List<int> GetPrimeList()\n        {\n            return primelist;\n        }\n\n    }\n    public class Priority_Queue<T>\n    {\n        private List<T> Q;\n        private readonly Comparison<T> Func_Compare;\n        public Priority_Queue(Comparison<T> comp)\n        {\n            Func_Compare = comp;\n            Q = new List<T>();\n        }\n        private void PushHeap(List<T> list, T item)\n        {\n            int n = list.Count();\n            list.Add(item);\n\n            while (n != 0)\n            {\n                int pIndex = (n - 1) / 2;\n\n                if (Func_Compare(list[n], list[pIndex]) < 0)\n                {\n                    Swap(Q, n, pIndex);\n                }\n                else { break; }\n\n                n = pIndex;\n            }\n        }\n        private void PopHeap(List<T> list)\n        {\n            int n = list.Count() - 1;\n            list[0] = list[n];\n            list.RemoveAt(n);\n\n            int cur = 0;\n            int comp;\n\n            while (2 * cur + 1 <= n - 1)\n            {\n                int c1 = 2 * cur + 1;\n                int c2 = 2 * (cur + 1);\n                if (c1 == n - 1)\n                {\n                    comp = c1;\n                }\n                else\n                {\n\n                    comp = Func_Compare(list[c1], list[c2]) < 0 ? c1 : c2;\n                }\n\n                if (Func_Compare(list[cur], list[comp]) > 0)\n                {\n                    Swap(Q, cur, comp);\n                }\n                else { break; }\n\n                cur = comp;\n            }\n        }\n        private void Swap(List<T> list, int a, int b)\n        {\n            T keep = list[a];\n            list[a] = list[b];\n            list[b] = keep;\n        }\n\n        public void Enqueue(T value)\n        {\n            PushHeap(Q, value);\n        }\n\n        public T Dequeue()\n        {\n            T ret = Q[0];\n            PopHeap(Q);\n            return ret;\n        }\n\n        public T Peek()\n        {\n            return Q[0];\n        }\n\n        public int Count()\n        {\n            return Q.Count();\n        }\n        public bool Any()\n        {\n            return Q.Any();\n        }\n    }\n    public class SegmentTree<T>\n    {\n        //1-indexed type\n        int n;\n        T[] Tree;\n        Func<T, T, T> f;\n        T ex;\n        int L;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public SegmentTree(int size, Func<T, T, T> fun, T exvalue)\n        {\n            ex = exvalue;\n            f = fun;\n            n = 1;\n            while (n < size) n <<= 1;\n            Tree = new T[n << 1];\n            L = (n << 1) - 1;\n            for (var i = 0; i <= L; i++) Tree[i] = ex;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public SegmentTree(int size, Func<T, T, T> fun, T exvalue, T[] initial)\n        {\n            ex = exvalue;\n            n = 1; while (n < size) n <<= 1;\n            f = fun;\n            Tree = new T[n << 1];\n            L = (n << 1) - 1;\n            for (var i = 0; i <= L; i++) Tree[i] = (n <= i && i <= n + initial.Length - 1) ? initial[i - n] : ex;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Set_All()\n        {\n            for (var i = n - 1; i >= 1; i--) Tree[i] = f(Tree[i << 1], Tree[(i << 1) | 1]);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Assign(int idx, T nxt) => Tree[idx + n] = nxt;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Update(int idx)\n        {\n            int now = idx + n;\n            while (now > 1)\n            {\n                now >>= 1;\n                Tree[now] = f(Tree[now << 1], Tree[now << 1 | 1]);\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Query_Update(int idx, T nxt)\n        {\n            Assign(idx, nxt); Update(idx);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Query_Update_func(int idx, T y)\n        {\n            Assign(idx, f(Peek(idx), y)); Update(idx);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Query_Fold(int l, int r)\n        {\n            int L = n + l;\n            int R = n + r;\n            T vL = ex, vR = ex;\n            while (L < R)\n            {\n                if (L % 2 == 1)\n                {\n                    vL = f(vL, Tree[L]);\n                    L++;\n                }\n                if (R % 2 == 1)\n                {\n                    vR = f(Tree[R - 1], vR);\n                    R--;\n                }\n                L >>= 1;\n                R >>= 1;\n            }\n            return f(vL, vR);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Peek(int idx) => Tree[idx + n];\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Display(int len)\n        {\n            for (var i = 0; i < len; i++) Console.Write($\"{Tree[i + n]} \");\n            Console.WriteLine();\n        }\n    }\n    public class UnionFind\n    {\n        private int[] parent;\n        private int[] rank;\n        private int[] size;\n        public UnionFind(int n)\n        {\n            parent = new int[n];\n            rank = new int[n];\n            size = new int[n];\n            for (var i = 0; i < n; i++)\n            {\n                parent[i] = i;\n                rank[i] = 0;\n                size[i] = 1;\n            }\n        }\n\n        public int Root(int x)\n        {\n            return parent[x] == x ? x : parent[x] = Root(parent[x]);\n        }\n\n        public bool SameRoot(int x, int y)\n        {\n            return Root(x) == Root(y);\n        }\n\n        public void Unite(int x, int y)\n        {\n            x = Root(x);\n            y = Root(y);\n            if (x == y) { return; }\n\n            if (rank[x] < rank[y])\n            {\n                parent[x] = y;\n                size[y] += size[x];\n                size[x] = 0;\n            }\n            else\n            {\n                parent[y] = x;\n                if (rank[x] == rank[y]) { rank[x]++; }\n                size[x] += size[y];\n                size[y] = 0;\n            }\n        }\n\n        public int SizeOf(int x)\n        {\n            return size[Root(x)];\n        }\n\n    }\n    struct ModInt\n    {\n        public long value;\n        private const int MOD = 1000000007;\n        //private const int MOD = 998244353;\n        public ModInt(long value) { this.value = value; }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static implicit operator ModInt(long a)\n        {\n            var ret = a % MOD;\n            return new ModInt(ret < 0 ? (ret + MOD) : ret);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator +(ModInt a, ModInt b) => (a.value + b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator -(ModInt a, ModInt b) => (a.value - b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator *(ModInt a, ModInt b) => (a.value * b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator /(ModInt a, ModInt b) => a * Modpow(b, MOD - 2);\n\n        public static ModInt operator <<(ModInt a, int n) => (a.value << n);\n        public static ModInt operator >>(ModInt a, int n) => (a.value >> n);\n        public static ModInt operator ++(ModInt a) => a.value + 1;\n        public static ModInt operator --(ModInt a) => a.value - 1;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Modpow(ModInt a, long n)\n        {\n            var k = a;\n            ModInt ret = 1;\n            while (n > 0)\n            {\n                if ((n & 1) != 0) ret *= k;\n                k *= k;\n                n >>= 1;\n            }\n            return ret;\n        }\n        private static readonly List<long> Factorials = new List<long>() { 1 };\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Fac(long n)\n        {\n            for (var i = Factorials.Count(); i <= n; i++)\n            {\n                Factorials.Add((Factorials[i - 1] * i) % MOD);\n            }\n            return Factorials[(int)n];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt nCr(long n, long r)\n        {\n            return n < r ? 0 : Fac(n) / (Fac(r) * Fac(n - r));\n        }\n        public static explicit operator int(ModInt a) => (int)a.value;\n    }\n    static class Cin\n    {\n        public static string[] ReadSplit => Console.ReadLine().Split();\n        public static int[] ReadSplitInt => ConvertAll(Console.ReadLine().Split(), int.Parse);\n        public static long[] ReadSplitLong => ConvertAll(Console.ReadLine().Split(), long.Parse);\n        public static double[] ReadSplit_Double => ConvertAll(Console.ReadLine().Split(), double.Parse);\n        public static string Str => Console.ReadLine();\n        public static int Int => int.Parse(Console.ReadLine());\n        public static long Long => long.Parse(Console.ReadLine());\n        public static double Double => double.Parse(Console.ReadLine());\n        public static T Conv<T>(string input)\n        {\n            if (typeof(T).Equals(typeof(ModInt)))\n            {\n                return (T)(dynamic)(long.Parse(input));\n            }\n            return (T)Convert.ChangeType(input, typeof(T));\n        }\n        public static void Input<T>(out T a) => a = Conv<T>(Console.ReadLine());\n        public static void Input<T, U>(out T a, out U b)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); }\n        public static void Input<T, U, V>(out T a, out U b, out V c)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); }\n        public static void Input<T, U, V, W>(out T a, out U b, out V c, out W d)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); }\n        public static void Input<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); e = Conv<X>(q[4]); }\n    }\n    static class Sc_out\n    {\n        public static void OutL(object s) => Console.WriteLine(s);\n        public static void Out_Sep<T>(IEnumerable<T> s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_Sep<T>(IEnumerable<T> s, string sep) => Console.WriteLine(string.Join($\"{sep}\", s));\n        public static void Out_Sep(params object[] s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_One(object s) => Console.Write($\"{s} \");\n        public static void Out_One(object s, string sep) => Console.Write($\"{s}{sep}\");\n        public static void Endl() => Console.WriteLine();\n    }\n    public static class Tool\n    {\n        static public void Initialize<T>(ref T[] array, T initialvalue)\n        {\n            array = ConvertAll(array, x => initialvalue);\n        }\n        static public void Swap<T>(ref T a, ref T b)\n        {\n            T keep = a;\n            a = b;\n            b = keep;\n        }\n        static public void Display<T>(T[,] array2d, int n, int m)\n        {\n            for (var i = 0; i < n; i++)\n            {\n                for (var j = 0; j < m; j++)\n                {\n                    Console.Write($\"{array2d[i, j]} \");\n                }\n                Console.WriteLine();\n            }\n        }\n        static public long Gcd(long a, long b)\n        {\n            if (a == 0 || b == 0) return Max(a, b);\n            return a % b == 0 ? b : Gcd(b, a % b);\n        }\n        static public long LPow(int a, int b) => (long)Pow(a, b);\n        static public bool Bit(long x, int dig) => ((1L << dig) & x) != 0;\n        static public int Sig(long a) => a == 0 ? 0 : (int)(a / Abs(a));\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Runtime.CompilerServices;\nusing System.Text;\nusing static Template;\nusing static System.Console;\nusing static System.Convert;\nusing static System.Math;\nusing Pi = Pair<int, int>;\n\nclass Solver\n{\n    public void Solve(Scanner sc)\n    {\n        int N, H, W;\n        sc.Make(out N, out H, out W);\n        var res = 0L;\n        var uf = new UnionFind(H + W + 1);\n        var rca = new int[N][];\n        for(var i = 0; i < N; i++)\n        {\n            rca[i] = sc.ArrInt;\n            rca[i][0]--;rca[i][1]--;\n        }\n        Array.Sort(rca, (a, b) => b[2] - a[2]);\n        foreach(var e in rca)\n        {\n            int r = e[0], c = e[1], a = e[2];\n            if (uf[r] == uf[c+H])\n            {\n                if (uf[r] == uf[H + W]) continue;\n                uf.Union(r, H + W);\n                res += a;\n            }\n            else\n            {\n                uf.Union(r, c + H);res += a;\n            }\n        }\n        WriteLine(res);\n    }\n}\n\npublic class UnionFind\n{\n    public int GroupCount { get; private set; }\n    protected int[] data;\n    public virtual int this[int i] => Find(i);\n    public UnionFind(int size)\n    {\n        data = Create(size, () => -1);\n        GroupCount = size;\n    }\n    protected int Find(int i)\n        => data[i] < 0 ? i : (data[i] = Find(data[i]));\n    public int Size(int i)\n        => -data[Find(i)];\n    public virtual bool Union(int u, int v)\n    {\n        u = Find(u); v = Find(v);\n        if (u == v) return false;\n        if (data[u] > data[v])\n            swap(ref u, ref v);\n        GroupCount--;\n        data[u] += data[v];\n        data[v] = u;\n        return true;\n    }\n}\n#region Template\npublic static class Template\n{\n    static void Main(string[] args)\n    {\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        new Solver().Solve(new Scanner());\n        Console.Out.Flush();\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmin<T>(ref T a, T b) where T : IComparable<T>\n    { if (a.CompareTo(b) == 1) { a = b; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static bool chmax<T>(ref T a, T b) where T : IComparable<T>\n    { if (a.CompareTo(b) == -1) { a = b; return true; } return false; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static void swap<T>(ref T a, ref T b)\n    { var t = b; b = a; a = t; }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static T[] Create<T>(int n, Func<T> f)\n    {\n        var rt = new T[n];\n        for (var i = 0; i < rt.Length; ++i)\n            rt[i] = f();\n        return rt;\n    }\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public static T[] Create<T>(int n, Func<int, T> f)\n    {\n        var rt = new T[n];\n        for (var i = 0; i < rt.Length; ++i)\n            rt[i] = f(i);\n        return rt;\n    }\n    public static T[] Copy<T>(this T[] A) => Create(A.Length, i => A[i]);\n    public static void Fail<T>(T s) { Console.WriteLine(s); Console.Out.Close(); Environment.Exit(0); }\n}\n\npublic class Scanner\n{\n    public string Str => Console.ReadLine().Trim();\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public int[] ArrInt => Str.Split(' ').Select(int.Parse).ToArray();\n    public long[] ArrLong => Str.Split(' ').Select(long.Parse).ToArray();\n    public char[][] Grid(int n) => Create(n, () => Str.ToCharArray());\n    public int[] ArrInt1D(int n) => Create(n, () => Int);\n    public long[] ArrLong1D(int n) => Create(n, () => Long);\n    public int[][] ArrInt2D(int n) => Create(n, () => ArrInt);\n    public long[][] ArrLong2D(int n) => Create(n, () => ArrLong);\n    public Pair<T1, T2> PairMake<T1, T2>() => new Pair<T1, T2>(Next<T1>(), Next<T2>());\n    public Pair<T1, T2, T3> PairMake<T1, T2, T3>() => new Pair<T1, T2, T3>(Next<T1>(), Next<T2>(), Next<T3>());\n    private Queue<string> q = new Queue<string>();\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public T Next<T>() { if (q.Count == 0) foreach (var item in Str.Split(' ')) q.Enqueue(item); return (T)Convert.ChangeType(q.Dequeue(), typeof(T)); }\n    public void Make<T1>(out T1 v1) => v1 = Next<T1>();\n    public void Make<T1, T2>(out T1 v1, out T2 v2) { v1 = Next<T1>(); v2 = Next<T2>(); }\n    public void Make<T1, T2, T3>(out T1 v1, out T2 v2, out T3 v3) { Make(out v1, out v2); v3 = Next<T3>(); }\n    public void Make<T1, T2, T3, T4>(out T1 v1, out T2 v2, out T3 v3, out T4 v4) { Make(out v1, out v2, out v3); v4 = Next<T4>(); }\n    public void Make<T1, T2, T3, T4, T5>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5) { Make(out v1, out v2, out v3, out v4); v5 = Next<T5>(); }\n    public void Make<T1, T2, T3, T4, T5, T6>(out T1 v1, out T2 v2, out T3 v3, out T4 v4, out T5 v5, out T6 v6) { Make(out v1, out v2, out v3, out v4, out v5); v6 = Next<T6>(); }\n}\n\npublic class Pair<T1, T2> : IComparable<Pair<T1, T2>>\n{\n    public T1 v1;\n    public T2 v2;\n    public Pair() { }\n    public Pair(T1 v1, T2 v2)\n    { this.v1 = v1; this.v2 = v2; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int CompareTo(Pair<T1, T2> p)\n    {\n        var c = Comparer<T1>.Default.Compare(v1, p.v1);\n        if (c == 0)\n            c = Comparer<T2>.Default.Compare(v2, p.v2);\n        return c;\n    }\n    public override string ToString() => $\"{v1.ToString()} {v2.ToString()}\";\n    public void Tie(out T1 a, out T2 b) { a = v1; b = v2; }\n}\n\npublic class Pair<T1, T2, T3> : Pair<T1, T2>, IComparable<Pair<T1, T2, T3>>\n{\n    public T3 v3;\n    public Pair() : base() { }\n    public Pair(T1 v1, T2 v2, T3 v3) : base(v1, v2)\n    { this.v3 = v3; }\n\n    [MethodImpl(MethodImplOptions.AggressiveInlining)]\n    public int CompareTo(Pair<T1, T2, T3> p)\n    {\n        var c = base.CompareTo(p);\n        if (c == 0)\n            c = Comparer<T3>.Default.Compare(v3, p.v3);\n        return c;\n    }\n    public override string ToString() => $\"{base.ToString()} {v3.ToString()}\";\n    public void Tie(out T1 a, out T2 b, out T3 c) { Tie(out a, out b); c = v3; }\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing Debug = System.Diagnostics.Trace;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nnamespace Program {\n\tpublic class Solver {\n\t\tRandom rnd = new Random();\n\t\tpublic void Solve() {\n\t\t\tvar n = ri;\n\t\t\tvar h = ri;\n\t\t\tvar w = ri;\n\t\t\tvar A = Enumerate(n, x => new int[] { ri - 1, h + ri - 1, ri }).OrderByDescending(x => x[2]).ToArray();\n\t\t\tvar s = new DisjointSet(n + h + w);\n\t\t\tvar a = new int[h + w];\n\t\t\tvar ans = 0L;\n\t\t\tforeach (var x in A) {\n\t\t\t\tvar p = x[0];\n\t\t\t\tvar q = x[1];\n\t\t\t\tint sz = s.Same(p, q) ? s.Size(p) - a[s[p]] : s.Size(p) - a[s[p]] + s.Size(q) - a[s[q]];\n\t\t\t\tDebug.WriteLine(sz);\n\t\t\t\tif (sz > 0) {\n\t\t\t\t\tDebug.WriteLine(x.AsJoinedString());\n\t\t\t\t\tans += x[2];\n\t\t\t\t\tif (s.Same(p, q)) {\n\t\t\t\t\t\ta[s[p]]++;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tvar u = a[s[p]] + a[s[q]] + 1;\n\t\t\t\t\t\ts.Unite(p, q);\n\t\t\t\t\t\ta[s[p]] = u;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tConsole.WriteLine(ans);\n\t\t}\n\n\t\tconst long INF = 1L << 60;\n\t\tstatic int[] dx = { -1, 0, 1, 0 };\n\t\tstatic int[] dy = { 0, 1, 0, -1 };\n\t\tint ri { get { return sc.Integer(); } }\n\t\tlong rl { get { return sc.Long(); } }\n\t\tdouble rd { get { return sc.Double(); } }\n\t\tstring rs { get { return sc.Scan(); } }\n\t\tpublic IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n\t\tstatic T[] Enumerate<T>(int n, Func<int, T> f) {\n\t\t\tvar a = new T[n];\n\t\t\tfor (int i = 0; i < a.Length; ++i) a[i] = f(i);\n\t\t\treturn a;\n\t\t}\n\t\tstatic public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n\t}\n}\n\n#region main\nstatic class Ex {\n\tstatic public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n\tstatic public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n\t\treturn string.Join(st, ie);\n\t}\n\tstatic public void Main() {\n\t\tConsole.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = true });\n\t\tvar solver = new Program.Solver();\n\t\t/* \n\t\tvar t = new System.Threading.Thread(solver.Solve, 50000000);\n\t\tt.Start();\n\t\tt.Join();\n\t\t*/\n\t\tsolver.Solve();\n\t\tConsole.Out.Flush();\n\t}\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n\tusing System.IO;\n\tusing System.Text;\n\tusing System.Globalization;\n\n\tpublic class Printer : StreamWriter {\n\t\tpublic override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n\t\tpublic Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n\t}\n\n\tpublic class StreamScanner {\n\t\tpublic StreamScanner(Stream stream) { str = stream; }\n\n\t\tpublic readonly Stream str;\n\t\tprivate readonly byte[] buf = new byte[1024];\n\t\tprivate int len, ptr;\n\t\tpublic bool isEof = false;\n\t\tpublic bool IsEndOfStream { get { return isEof; } }\n\n\t\tprivate byte read() {\n\t\t\tif (isEof) return 0;\n\t\t\tif (ptr >= len) {\n\t\t\t\tptr = 0;\n\t\t\t\tif ((len = str.Read(buf, 0, 1024)) <= 0) {\n\t\t\t\t\tisEof = true;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn buf[ptr++];\n\t\t}\n\n\t\tpublic char Char() {\n\t\t\tbyte b = 0;\n\t\t\tdo b = read(); while ((b < 33 || 126 < b) && !isEof);\n\t\t\treturn (char)b;\n\t\t}\n\t\tpublic string Scan() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic string ScanLine() {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n\t\t\treturn sb.ToString();\n\t\t}\n\t\tpublic long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n\t\tpublic int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n\t\tpublic double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n\t}\n}\n\n#endregion\n\n#region Disjoint Set\n/// <summary>\n/// いくつかの要素を素集合に分割して保持するコレクションです．\n/// </summary>\npublic class DisjointSet {\n\tint[] par;\n\tbyte[] rank;\n\t/// <summary>\n\t/// 0 から <paramref name=\"N\"/>-1 までの番号がついた <paramref name=\"N\"/> 個の要素からなる集合を作成します．\n\t/// </summary>\n\t/// <param name=\"N\">要素数</param>\n\t/// <remarks>このコンストラクタは O(N) で実行されます．</remarks>\n\tpublic DisjointSet(int N) {\n\t\tpar = new int[N];\n\t\trank = new byte[N];\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tpar[i] = -1;\n\t}\n\t/// <summary>\n\t/// 指定した要素が属する集合の代表値を取得します．\n\t/// </summary>\n\t/// <param name=\"id\">調べたい要素の 0-indexed での番号</param>\n\t/// <returns>指定した要素が属する集合の代表値</returns>\n\t/// <remarks>最悪計算量 O(α(N)) で実行されます．</remarks>\n\tpublic int this[int id] {\n\t\tget {\n\t\t\tif ((par[id] < 0)) return id;\n\t\t\treturn par[id] = this[par[id]];\n\t\t}\n\t}\n\t/// <summary>\n\t/// 指定した 2 つの要素が属する集合同士を 1 つに統合することを試みます．\n\t/// </summary>\n\t/// <param name=\"x\">最初の要素の 0-indexed での番号</param>\n\t/// <param name=\"y\">2 つ目の要素の 0-indexed での番号</param>\n\t/// <returns>統合に成功したならば true，そうでなければ false．</returns>\n\t/// <remarks>最悪計算量 O(α(N)) で実行されます．</remarks>\n\tpublic bool Unite(int x, int y) {\n\t\tx = this[x]; y = this[y];\n\t\tif (x == y) return false;\n\t\tif (rank[x] < rank[y]) { var tmp = x; x = y; y = tmp; }\n\t\tpar[x] += par[y];\n\t\tpar[y] = x;\n\t\tif (rank[x] == rank[y])\n\t\t\trank[x]++;\n\t\treturn true;\n\t}\n\t/// <summary>\n\t/// 指定した要素が属する集合のサイズを取得します．\n\t/// </summary>\n\t/// <param name=\"x\">指定する要素の 0-indexed での番号</param>\n\t/// <returns>集合のサイズ</returns>\n\t/// <remarks>最悪計算量 O(α(N)) で実行されます．</remarks>\n\tpublic int Size(int x) { return -par[this[x]]; }\n\n\t/// <summary>\n\t/// 指定した 2 つの要素が属する集合が同じかどうかを判定する．計算量 O(α(N))．\n\t/// </summary>\n\t/// <param name=\"x\">最初の要素の 0-indexed での番号</param>\n\t/// <param name=\"y\">2 つ目の要素の 0-indexed での番号</param>\n\t/// <returns>同じならば true，そうでなければ false．</returns>\n\t/// <remarks>最悪計算量 O(α(N)) で実行されます．</remarks>\n\tpublic bool Same(int x, int y) { return this[x] == this[y]; }\n\n}\n#endregion\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Threading;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression,\n                          System.Linq.Expressions.UnaryExpression>;\n\nclass Program {\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const int M2 = 998244353;\n    const long LM = 1L << 60;\n    const double eps = 1e-11;\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n\n    static void Main(string[] args)\n    {\n        var solver = new Solver();\n        // var t = new Thread(solver.solve, 1 << 26); // 64 MB\n\t\t// t.Start();\n\t\t// t.Join();\n        solver.solve();\n        sw.Flush();\n    }\n\n\n    class Solver {\n        public void solve() {\n            int n, h, w;\n            sc.Multi(out n, out h, out w);\n            var p = new pair<P, int>[n];\n            var ph = new List<P>[h];\n            var pw = new List<P>[w];\n            for (int i = 0; i < h; i++)\n            {\n                ph[i] = new List<P>();\n            }\n            for (int i = 0; i < w; i++)\n            {\n                pw[i] = new List<P>();\n            }\n            var uf = new UnionFind(h + w);\n            for (int i = 0; i < n; i++)\n            {\n                int r, c, a;\n                sc.Multi(out r, out c, out a);\n                --r;\n                --c;\n                p[i] = make_pair(new P(r, c), a);\n                ph[r].Add(new P(a, i));\n                pw[c].Add(new P(a, i));\n            }\n            var used = new int[n];\n            long ans = 0;\n            for (int i = 0; i < h; i++)\n            {\n                if (ph[i].Count == 0) continue;\n                ph[i].Sort();\n                ph[i].Reverse();\n                if (used[ph[i][0].v2] == 0)\n                    ans += ph[i][0].v1;\n                used[ph[i][0].v2] += 1;\n            }\n            for (int i = 0; i < w; i++)\n            {\n                if (pw[i].Count == 0) continue;\n                pw[i].Sort();\n                pw[i].Reverse();\n                if (used[pw[i][0].v2] == 0)\n                    ans += pw[i][0].v1;\n                used[pw[i][0].v2] += 1;\n            }\n            var cnt = new int[h + w];\n            var lis = new List<P>[h + w];\n            for (int i = 0; i < h + w; i++)\n            {\n                lis[i] = new List<P>();\n            }\n            for (int i = 0; i < n; i++)\n            {\n                if (used[i] > 0) {\n                    uf.unite(p[i].v1.v1, h + p[i].v1.v2);\n                }\n            }\n            for (int i = 0; i < n; i++)\n            {\n                if (used[i] == 0) {\n                    lis[uf.getpar(p[i].v1.v1)].Add(new P(p[i].v2, i));\n                    lis[uf.getpar(p[i].v1.v2)].Add(new P(p[i].v2, i));\n                }\n                else {\n                    cnt[uf.getpar(p[i].v1.v1)] += used[i] - 1;\n                }\n            }\n            for (int i = 0; i < h + w; i++)\n            {\n                lis[i].Sort();\n                lis[i].Reverse();\n                foreach (var item in lis[i])\n                {\n                    if (cnt[i] > 0) {\n                        --cnt[i];\n                        ans += item.v1;\n                    }\n                }\n            }\n            Prt(ans);\n        } // end Solver.solve\n\n    }\n}\n\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n    public static bool operator>(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) > 0;\n    public static bool operator<(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) < 0;\n    public static bool operator>=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) >= 0;\n    public static bool operator<=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) <= 0;\n}\nstatic class util {\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static T sq<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    static readonly int[] dd = { 0, 1, 0, -1 };\n    static readonly string dstring = \"RDLU\";\n    public static P[] adjacents(this P p) => adjacents(p.v1, p.v2);\n    public static P[] adjacents(this P p, int h, int w) => adjacents(p.v1, p.v2, h, w);\n    public static pair<P, char>[] adjacents_with_str(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new pair<P, char>(new P(i + dd[k], j + dd[k ^ 1]), dstring[k])).ToArray();\n    public static pair<P, char>[] adjacents_with_str(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new pair<P, char>(new P(i + dd[k], j + dd[k ^ 1]), dstring[k]))\n                                         .Where(p => inside(p.v1.v1, p.v1.v2, h, w)).ToArray();\n    public static P[] adjacents(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).ToArray();\n    public static P[] adjacents(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).Where(p => inside(p.v1, p.v2, h, w)).ToArray();\n    public static void Assert(bool cond) { if (!cond) throw new Exception(); }\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T> {\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\nclass UnionFind {\n    int num;\n    int[] par, sz, rank;\n    public UnionFind(int n) {\n        num = n; par = new int[n]; sz = new int[n]; rank = new int[n];\n        for (int i = 0; i < n; ++i) { par[i] = i; sz[i] = 1; rank[i] = 0; }\n    }\n    int find(int x) => par[x] == x ? x : (par[x] = find(par[x]));\n    public bool same(int x, int y) => find(x) == find(y);\n    public int unionsize(int x) => sz[find(x)];\n    public int unioncount => num;\n    public bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if (x == y) return false;\n        --num;\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n            sz[y] += sz[x];\n        }\n        else {\n            par[y] = x;\n            sz[x] += sz[y];\n            if (rank[x] == rank[y]) ++rank[x];\n        }\n        return true;\n    }\n    public bool ispar(int x) => x == find(x);\n    public int getpar(int x) => find(x);\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Globalization;\nusing System.IO;\nusing System.Text;\nusing System.Linq;\n\nusing E = System.Linq.Enumerable;\nusing System.Threading;\n\ninternal partial class Solver {\n    public void Run() {\n        var n = ni();\n        var h = ni();\n        var w = ni();\n        var edges = new List<(int From, int To, int Cost)>();\n        for (int i = 0; i < n; i++) {\n            var r = ni() - 1;\n            var c = ni() - 1;\n            var a = ni();\n            edges.Add((r, c + h, a));\n        }\n        edges.Sort((e1, e2) => -e1.Cost.CompareTo(e2.Cost));\n        var d = new DisjointSet(h + w + 1);\n        var root = h + w;\n        long ans = 0;\n        foreach (var edge in edges) {\n            if (!d.Unite(edge.From, edge.To)) {\n                if (!d.IsSameSet(edge.From, root)) {\n                    d.Unite(edge.From, root);\n                    d.Unite(edge.To, root);\n                } else {\n                    continue;\n                }\n            }\n            ans += edge.Cost;\n        }\n        cout.WriteLine(ans);\n    }\n}\n\npublic class DisjointSet {\n    private readonly long[] group;\n    public int GroupCount { get; private set; }\n    public DisjointSet(int n, int[] size = null) {\n        group = new long[n];\n        Clear(size);\n        GroupCount = n;\n    }\n    public bool Unite(int x, int y) {\n        x = Root(x); y = Root(y);\n        if (x == y) {\n            return false;\n        }\n\n        if (group[y] < group[x]) {\n            return Unite(y, x);\n        }\n\n        group[x] += group[y];\n        group[y] = x;\n        GroupCount--;\n        return true;\n    }\n    public bool IsSameSet(int x, int y) { return Root(x) == Root(y); }\n    public int Root(int x) { return group[x] < 0 ? x : (int)(group[x] = Root((int)group[x])); }\n    public long Size(int x) { return -group[Root(x)]; }\n    public void Clear(int[] size = null) {\n        for (int i = 0; i < group.Length; i++) {\n            group[i] = -(size == null ? 1 : size[i]);\n        }\n    }\n};\n\n// PREWRITEN CODE BEGINS FROM HERE\n\nstatic public class StringExtensions {\n    static public string JoinToString<T>(this IEnumerable<T> source, string separator = \" \") {\n        return string.Join(separator, source);\n    }\n}\n\ninternal partial class Solver : Scanner {\n    static readonly int? StackSizeInMebiByte = null; //50;\n    public static void StartAndJoin(Action action, int maxStackSize) {\n        var thread = new Thread(new ThreadStart(action), maxStackSize);\n        thread.Start();\n        thread.Join();\n    }\n\n    public static void Main() {\n#if LOCAL\n        byte[] inputBuffer = new byte[1000000];\n        var inputStream = Console.OpenStandardInput(inputBuffer.Length);\n        using (var reader = new StreamReader(inputStream, Console.InputEncoding, false, inputBuffer.Length)) {\n            Console.SetIn(reader);\n            new Solver(Console.In, Console.Out).Run();\n        }\n#else\n        Console.SetOut(new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false });\n        if (StackSizeInMebiByte.HasValue) {\n            StartAndJoin(() => new Solver(Console.In, Console.Out).Run(), StackSizeInMebiByte.Value * 1024 * 1024);\n        } else {\n            new Solver(Console.In, Console.Out).Run();\n        }\n        Console.Out.Flush();\n#endif\n    }\n\n#pragma warning disable IDE0052\n    private readonly TextReader cin;\n    private readonly TextWriter cout;\n    private readonly TextWriter cerr;\n#pragma warning restore IDE0052\n\n    public Solver(TextReader reader, TextWriter writer)\n        : base(reader) {\n        cin = reader;\n        cout = writer;\n        cerr = Console.Error;\n    }\n\n    public Solver(string input, TextWriter writer)\n        : this(new StringReader(input), writer) {\n    }\n\n#pragma warning disable IDE1006\n#pragma warning disable IDE0051\n    private int ni() { return NextInt(); }\n    private int[] ni(int n) { return NextIntArray(n); }\n    private long nl() { return NextLong(); }\n    private long[] nl(int n) { return NextLongArray(n); }\n    private double nd() { return NextDouble(); }\n    private double[] nd(int n) { return NextDoubleArray(n); }\n    private string ns() { return Next(); }\n    private string[] ns(int n) { return NextArray(n); }\n#pragma warning restore IDE1006\n#pragma warning restore IDE0051\n}\n\n#if DEBUG\ninternal static class LinqPadExtension {\n    public static string TextDump<T>(this T obj) {\n        if (obj is IEnumerable) return (obj as IEnumerable).Cast<object>().JoinToString().Dump();\n        else return obj.ToString().Dump();\n    }\n    public static T Dump<T>(this T obj) {\n        return LINQPad.Extensions.Dump(obj);\n    }\n}\n#endif\n\npublic class Scanner {\n    private readonly TextReader Reader;\n    private readonly CultureInfo ci = CultureInfo.InvariantCulture;\n\n    private readonly char[] buffer = new char[2 * 1024];\n    private int cursor = 0, length = 0;\n    private string Token;\n    private readonly StringBuilder sb = new StringBuilder(1024);\n\n    public Scanner()\n        : this(Console.In) {\n    }\n\n    public Scanner(TextReader reader) {\n        Reader = reader;\n    }\n\n    public int NextInt() { return checked((int)NextLong()); }\n    public long NextLong() {\n        var s = Next();\n        long r = 0;\n        int i = 0;\n        bool negative = false;\n        if (s[i] == '-') {\n            negative = true;\n            i++;\n        }\n        for (; i < s.Length; i++) {\n            r = r * 10 + (s[i] - '0');\n#if DEBUG\n            if (!char.IsDigit(s[i])) throw new FormatException();\n#endif\n        }\n        return negative ? -r : r;\n    }\n    public double NextDouble() { return double.Parse(Next(), ci); }\n    public string[] NextArray(int size) {\n        string[] array = new string[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = Next();\n        }\n\n        return array;\n    }\n    public int[] NextIntArray(int size) {\n        int[] array = new int[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = NextInt();\n        }\n\n        return array;\n    }\n\n    public long[] NextLongArray(int size) {\n        long[] array = new long[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = NextLong();\n        }\n\n        return array;\n    }\n\n    public double[] NextDoubleArray(int size) {\n        double[] array = new double[size];\n        for (int i = 0; i < size; i++) {\n            array[i] = NextDouble();\n        }\n\n        return array;\n    }\n\n    public string Next() {\n        if (Token == null) {\n            if (!StockToken()) {\n                throw new Exception();\n            }\n        }\n        var token = Token;\n        Token = null;\n        return token;\n    }\n\n    public bool HasNext() {\n        if (Token != null) {\n            return true;\n        }\n\n        return StockToken();\n    }\n\n    private bool StockToken() {\n        while (true) {\n            sb.Clear();\n            while (true) {\n                if (cursor >= length) {\n                    cursor = 0;\n                    if ((length = Reader.Read(buffer, 0, buffer.Length)) <= 0) {\n                        break;\n                    }\n                }\n                var c = buffer[cursor++];\n                if (33 <= c && c <= 126) {\n                    sb.Append(c);\n                } else {\n                    if (sb.Length > 0) break;\n                }\n            }\n\n            if (sb.Length > 0) {\n                Token = sb.ToString();\n                return true;\n            }\n\n            return false;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading;\nusing System.Runtime.CompilerServices;\nusing System.Diagnostics;\nusing static System.Math;\nusing static System.Array;\nusing static AtCoder.Sc_out;\nusing static AtCoder.Tool;\nusing static AtCoder.ModInt;\nnamespace AtCoder\n{\n    class AC\n    {\n        const int MOD = 1000000007;\n        //const int MOD = 998244353;\n\n        const int INF = int.MaxValue / 2;\n        const long SINF = long.MaxValue / 3;\n        const double EPS = 1e-8;\n        static readonly int[] dI = { 0, 1, 0, -1, 1, -1, -1, 1 };\n        static readonly int[] dJ = { 1, 0, -1, 0, 1, 1, -1, -1 };\n        //static List<List<int>> G = new List<List<int>>();\n        //static List<List<Edge>> G = new List<List<Edge>>();\n        //static List<Edge> E = new List<Edge>();\n        static void Main(string[] args)\n        {\n            //var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false }; Console.SetOut(sw);\n\n            var th = new Thread(Run, 1 << 26);\n            th.Start();\n            th.Join();\n\n            //Run();\n            Console.Out.Flush();\n        }\n        static void Run()\n        {\n            int Testcase = 1;\n            //Testcase = Cin.Int;\n            for (var _ = 0; _ < Testcase; _++) Solve();\n        }\n        static void Solve()\n        {\n            Cin.Input(out int N, out int H, out int W);\n            var R = new int[N];\n            var C = new int[N];\n            var A = new long[N];\n            var card = new List<(long, int, int)>();\n            for(var i = 0; i < N; i++)\n            {\n                Cin.Input(out R[i], out C[i], out A[i]);\n                card.Add((A[i], --R[i], --C[i]));\n            }\n            long ans = 0;\n            card.Sort();\n            card.Reverse();\n            var used = new HashSet<(int, int)>();\n            var G = new List<List<int>>();\n            for (var i = 0; i < H + W; i++) G.Add(new List<int>());\n            var ch = new bool[H + W];\n            void dfs(int v)\n            {\n                ch[v] = true;\n                foreach(var nx in G[v])\n                {\n                    if (!ch[nx]) dfs(nx);\n                }\n            }\n            int cnt = 0;\n            foreach(var cd in card)\n            {\n                if (cnt == H + W) break;\n                int r = cd.Item2;\n                int c = cd.Item3;\n                long V = cd.Item1;\n\n                if (ch[r] && ch[H + c])\n                {\n                    continue;\n                }\n                G[r].Add(H + c);\n                G[H + c].Add(r);\n                ans += V;\n                cnt++;\n                if (ch[r])\n                {\n                    ch[H + c] = true;\n                }\n                else if (ch[H + c])\n                {\n                    ch[r] = true;\n                }\n                else\n                {\n                    if (used.Contains((r, c)))\n                    {\n                        dfs(r);\n                    }\n                    else\n                    {\n                        used.Add((r, c));\n                    }\n                }\n\n                //Out_Sep(ch);\n            }\n            OutL(ans);\n            \n        }\n        public struct Edge\n        {\n            public int from;\n\n            public int to;\n            public long dist;\n\n            public Edge(int t, long c)\n            {\n                from = -1;\n                to = t;\n                dist = c;\n            }\n            public Edge(int f, int t, long c)\n            {\n                from = f;\n                to = t;\n                dist = c;\n            }\n        }\n\n    }\n    public class PrimeList\n    {\n        private bool[] isprime;\n        private List<int> primelist;\n\n        public PrimeList(int n)\n        {\n            if (n < 2) { return; }\n            primelist = new List<int>();\n            isprime = new bool[n + 1];\n            for (var i = 0; i <= n; i++)\n            {\n                isprime[i] = i != 0 && i != 1;\n            }\n\n            for (var i = 2; i <= n; i++)\n            {\n                if (!isprime[i]) { continue; }\n                primelist.Add(i);\n\n                int c = i;\n                while (c + i <= n)\n                {\n                    c += i;\n                    isprime[c] = false;\n                }\n            }\n        }\n\n        public bool IsPrime(int n)\n        {\n            return isprime[n];\n        }\n\n        public List<int> GetPrimeList()\n        {\n            return primelist;\n        }\n\n    }\n    public class Priority_Queue<T>\n    {\n        private List<T> Q;\n        private readonly Comparison<T> Func_Compare;\n        public Priority_Queue(Comparison<T> comp)\n        {\n            Func_Compare = comp;\n            Q = new List<T>();\n        }\n        private void PushHeap(List<T> list, T item)\n        {\n            int n = list.Count();\n            list.Add(item);\n\n            while (n != 0)\n            {\n                int pIndex = (n - 1) / 2;\n\n                if (Func_Compare(list[n], list[pIndex]) < 0)\n                {\n                    Swap(Q, n, pIndex);\n                }\n                else { break; }\n\n                n = pIndex;\n            }\n        }\n        private void PopHeap(List<T> list)\n        {\n            int n = list.Count() - 1;\n            list[0] = list[n];\n            list.RemoveAt(n);\n\n            int cur = 0;\n            int comp;\n\n            while (2 * cur + 1 <= n - 1)\n            {\n                int c1 = 2 * cur + 1;\n                int c2 = 2 * (cur + 1);\n                if (c1 == n - 1)\n                {\n                    comp = c1;\n                }\n                else\n                {\n\n                    comp = Func_Compare(list[c1], list[c2]) < 0 ? c1 : c2;\n                }\n\n                if (Func_Compare(list[cur], list[comp]) > 0)\n                {\n                    Swap(Q, cur, comp);\n                }\n                else { break; }\n\n                cur = comp;\n            }\n        }\n        private void Swap(List<T> list, int a, int b)\n        {\n            T keep = list[a];\n            list[a] = list[b];\n            list[b] = keep;\n        }\n\n        public void Enqueue(T value)\n        {\n            PushHeap(Q, value);\n        }\n\n        public T Dequeue()\n        {\n            T ret = Q[0];\n            PopHeap(Q);\n            return ret;\n        }\n\n        public T Peek()\n        {\n            return Q[0];\n        }\n\n        public int Count()\n        {\n            return Q.Count();\n        }\n        public bool Any()\n        {\n            return Q.Any();\n        }\n    }\n    public class SegmentTree<T>\n    {\n        //1-indexed type\n        int n;\n        T[] Tree;\n        Func<T, T, T> f;\n        T ex;\n        int L;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public SegmentTree(int size, Func<T, T, T> fun, T exvalue)\n        {\n            ex = exvalue;\n            f = fun;\n            n = 1;\n            while (n < size) n <<= 1;\n            Tree = new T[n << 1];\n            L = (n << 1) - 1;\n            for (var i = 0; i <= L; i++) Tree[i] = ex;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public SegmentTree(int size, Func<T, T, T> fun, T exvalue, T[] initial)\n        {\n            ex = exvalue;\n            n = 1; while (n < size) n <<= 1;\n            f = fun;\n            Tree = new T[n << 1];\n            L = (n << 1) - 1;\n            for (var i = 0; i <= L; i++) Tree[i] = (n <= i && i <= n + initial.Length - 1) ? initial[i - n] : ex;\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Set_All()\n        {\n            for (var i = n - 1; i >= 1; i--) Tree[i] = f(Tree[i << 1], Tree[(i << 1) | 1]);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Assign(int idx, T nxt) => Tree[idx + n] = nxt;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Update(int idx)\n        {\n            int now = idx + n;\n            while (now > 1)\n            {\n                now >>= 1;\n                Tree[now] = f(Tree[now << 1], Tree[now << 1 | 1]);\n            }\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Query_Update(int idx, T nxt)\n        {\n            Assign(idx, nxt); Update(idx);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Query_Update_func(int idx, T y)\n        {\n            Assign(idx, f(Peek(idx), y)); Update(idx);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Query_Fold(int l, int r)\n        {\n            int L = n + l;\n            int R = n + r;\n            T vL = ex, vR = ex;\n            while (L < R)\n            {\n                if (L % 2 == 1)\n                {\n                    vL = f(vL, Tree[L]);\n                    L++;\n                }\n                if (R % 2 == 1)\n                {\n                    vR = f(Tree[R - 1], vR);\n                    R--;\n                }\n                L >>= 1;\n                R >>= 1;\n            }\n            return f(vL, vR);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public T Peek(int idx) => Tree[idx + n];\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public void Display(int len)\n        {\n            for (var i = 0; i < len; i++) Console.Write($\"{Tree[i + n]} \");\n            Console.WriteLine();\n        }\n    }\n    public class UnionFind\n    {\n        private int[] parent;\n        private int[] rank;\n        private int[] size;\n        public UnionFind(int n)\n        {\n            parent = new int[n];\n            rank = new int[n];\n            size = new int[n];\n            for (var i = 0; i < n; i++)\n            {\n                parent[i] = i;\n                rank[i] = 0;\n                size[i] = 1;\n            }\n        }\n\n        public int Root(int x)\n        {\n            return parent[x] == x ? x : parent[x] = Root(parent[x]);\n        }\n\n        public bool SameRoot(int x, int y)\n        {\n            return Root(x) == Root(y);\n        }\n\n        public void Unite(int x, int y)\n        {\n            x = Root(x);\n            y = Root(y);\n            if (x == y) { return; }\n\n            if (rank[x] < rank[y])\n            {\n                parent[x] = y;\n                size[y] += size[x];\n                size[x] = 0;\n            }\n            else\n            {\n                parent[y] = x;\n                if (rank[x] == rank[y]) { rank[x]++; }\n                size[x] += size[y];\n                size[y] = 0;\n            }\n        }\n\n        public int SizeOf(int x)\n        {\n            return size[Root(x)];\n        }\n\n    }\n    struct ModInt\n    {\n        public long value;\n        private const int MOD = 1000000007;\n        //private const int MOD = 998244353;\n        public ModInt(long value) { this.value = value; }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static implicit operator ModInt(long a)\n        {\n            var ret = a % MOD;\n            return new ModInt(ret < 0 ? (ret + MOD) : ret);\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator +(ModInt a, ModInt b) => (a.value + b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator -(ModInt a, ModInt b) => (a.value - b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator *(ModInt a, ModInt b) => (a.value * b.value);\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt operator /(ModInt a, ModInt b) => a * Modpow(b, MOD - 2);\n\n        public static ModInt operator <<(ModInt a, int n) => (a.value << n);\n        public static ModInt operator >>(ModInt a, int n) => (a.value >> n);\n        public static ModInt operator ++(ModInt a) => a.value + 1;\n        public static ModInt operator --(ModInt a) => a.value - 1;\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Modpow(ModInt a, long n)\n        {\n            var k = a;\n            ModInt ret = 1;\n            while (n > 0)\n            {\n                if ((n & 1) != 0) ret *= k;\n                k *= k;\n                n >>= 1;\n            }\n            return ret;\n        }\n        private static readonly List<long> Factorials = new List<long>() { 1 };\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt Fac(long n)\n        {\n            for (var i = Factorials.Count(); i <= n; i++)\n            {\n                Factorials.Add((Factorials[i - 1] * i) % MOD);\n            }\n            return Factorials[(int)n];\n        }\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        public static ModInt nCr(long n, long r)\n        {\n            return n < r ? 0 : Fac(n) / (Fac(r) * Fac(n - r));\n        }\n        public static explicit operator int(ModInt a) => (int)a.value;\n    }\n    static class Cin\n    {\n        public static string[] ReadSplit => Console.ReadLine().Split();\n        public static int[] ReadSplitInt => ConvertAll(Console.ReadLine().Split(), int.Parse);\n        public static long[] ReadSplitLong => ConvertAll(Console.ReadLine().Split(), long.Parse);\n        public static double[] ReadSplit_Double => ConvertAll(Console.ReadLine().Split(), double.Parse);\n        public static string Str => Console.ReadLine();\n        public static int Int => int.Parse(Console.ReadLine());\n        public static long Long => long.Parse(Console.ReadLine());\n        public static double Double => double.Parse(Console.ReadLine());\n        public static T Conv<T>(string input)\n        {\n            if (typeof(T).Equals(typeof(ModInt)))\n            {\n                return (T)(dynamic)(long.Parse(input));\n            }\n            return (T)Convert.ChangeType(input, typeof(T));\n        }\n        public static void Input<T>(out T a) => a = Conv<T>(Console.ReadLine());\n        public static void Input<T, U>(out T a, out U b)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); }\n        public static void Input<T, U, V>(out T a, out U b, out V c)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); }\n        public static void Input<T, U, V, W>(out T a, out U b, out V c, out W d)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); }\n        public static void Input<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n        { var q = ReadSplit; a = Conv<T>(q[0]); b = Conv<U>(q[1]); c = Conv<V>(q[2]); d = Conv<W>(q[3]); e = Conv<X>(q[4]); }\n    }\n    static class Sc_out\n    {\n        public static void OutL(object s) => Console.WriteLine(s);\n        public static void Out_Sep<T>(IEnumerable<T> s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_Sep<T>(IEnumerable<T> s, string sep) => Console.WriteLine(string.Join($\"{sep}\", s));\n        public static void Out_Sep(params object[] s) => Console.WriteLine(string.Join(\" \", s));\n        public static void Out_One(object s) => Console.Write($\"{s} \");\n        public static void Out_One(object s, string sep) => Console.Write($\"{s}{sep}\");\n        public static void Endl() => Console.WriteLine();\n    }\n    public static class Tool\n    {\n        static public void Initialize<T>(ref T[] array, T initialvalue)\n        {\n            array = ConvertAll(array, x => initialvalue);\n        }\n        static public void Swap<T>(ref T a, ref T b)\n        {\n            T keep = a;\n            a = b;\n            b = keep;\n        }\n        static public void Display<T>(T[,] array2d, int n, int m)\n        {\n            for (var i = 0; i < n; i++)\n            {\n                for (var j = 0; j < m; j++)\n                {\n                    Console.Write($\"{array2d[i, j]} \");\n                }\n                Console.WriteLine();\n            }\n        }\n        static public long Gcd(long a, long b)\n        {\n            if (a == 0 || b == 0) return Max(a, b);\n            return a % b == 0 ? b : Gcd(b, a % b);\n        }\n        static public long LPow(int a, int b) => (long)Pow(a, b);\n        static public bool Bit(long x, int dig) => ((1L << dig) & x) != 0;\n        static public int Sig(long a) => a == 0 ? 0 : (int)(a / Abs(a));\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Linq.Expressions;\nusing System.IO;\nusing System.Threading;\nusing System.Text;\nusing System.Diagnostics;\n\nusing static util;\nusing P = pair<int, int>;\n\nusing Binary = System.Func<System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.ParameterExpression,\n                           System.Linq.Expressions.BinaryExpression>;\nusing Unary = System.Func<System.Linq.Expressions.ParameterExpression,\n                          System.Linq.Expressions.UnaryExpression>;\n\nclass Program {\n    static StreamWriter sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n    static Scan sc = new Scan();\n    const int M = 1000000007;\n    const int M2 = 998244353;\n    const long LM = 1L << 60;\n    const double eps = 1e-11;\n    static void DBG(string a) => Console.WriteLine(a);\n    static void DBG<T>(IEnumerable<T> a) => DBG(string.Join(\" \", a));\n    static void DBG(params object[] a) => DBG(string.Join(\" \", a));\n    static void Prt(string a) => sw.WriteLine(a);\n    static void Prt<T>(IEnumerable<T> a) => Prt(string.Join(\" \", a));\n    static void Prt(params object[] a) => Prt(string.Join(\" \", a));\n\n    static void Main(string[] args)\n    {\n        var solver = new Solver();\n        // var t = new Thread(solver.solve, 1 << 26); // 64 MB\n\t\t// t.Start();\n\t\t// t.Join();\n        solver.solve();\n        sw.Flush();\n    }\n\n\n    class Solver {\n        public void solve() {\n            int n, h, w;\n            sc.Multi(out n, out h, out w);\n            var p = new pair<P, int>[n];\n            var ph = new List<P>[h];\n            var pw = new List<P>[w];\n            for (int i = 0; i < h; i++)\n            {\n                ph[i] = new List<P>();\n            }\n            for (int i = 0; i < w; i++)\n            {\n                pw[i] = new List<P>();\n            }\n            var uf = new UnionFind(h + w);\n            for (int i = 0; i < n; i++)\n            {\n                int r, c, a;\n                sc.Multi(out r, out c, out a);\n                --r;\n                --c;\n                p[i] = make_pair(new P(r, c), a);\n                uf.unite(r, h + c);\n                ph[r].Add(new P(a, i));\n                pw[c].Add(new P(a, i));\n            }\n            var used = new int[n];\n            long ans = 0;\n            for (int i = 0; i < h; i++)\n            {\n                if (ph[i].Count == 0) continue;\n                ph[i].Sort();\n                ph[i].Reverse();\n                if (used[ph[i][0].v2] == 0)\n                    ans += ph[i][0].v1;\n                ++used[ph[i][0].v2];\n            }\n            for (int i = 0; i < w; i++)\n            {\n                if (pw[i].Count == 0) continue;\n                pw[i].Sort();\n                pw[i].Reverse();\n                if (used[pw[i][0].v2] == 0)\n                    ans += pw[i][0].v1;\n                ++used[pw[i][0].v2];\n            }\n            var cnt = new int[h + w];\n            var lis = new List<P>[h + w];\n            for (int i = 0; i < h + w; i++)\n            {\n                lis[i] = new List<P>();\n            }\n            for (int i = 0; i < n; i++)\n            {\n                lis[uf.getpar(p[i].v1.v1)].Add(new P(p[i].v2, i));\n                if (used[i] > 1) {\n                    cnt[uf.getpar(p[i].v1.v1)] += used[i] - 1;\n                }\n            }\n            for (int i = 0; i < h + w; i++)\n            {\n                lis[i].Sort();\n                lis[i].Reverse();\n                foreach (var item in lis[i])\n                {\n                    if (cnt[i] > 0 && used[item.v2] == 0) {\n                        --cnt[i];\n                        ++used[item.v2];\n                        ans += item.v1;\n                    }\n                }\n            }\n            Prt(ans);\n        } // end Solver.solve\n\n    }\n}\n\nclass pair<T, U> : IComparable<pair<T, U>> {\n    public T v1;\n    public U v2;\n    public pair() : this(default(T), default(U)) {}\n    public pair(T v1, U v2) { this.v1 = v1; this.v2 = v2; }\n    public int CompareTo(pair<T, U> a) {\n        int c = Comparer<T>.Default.Compare(v1, a.v1);\n        return c != 0 ? c : Comparer<U>.Default.Compare(v2, a.v2);\n    }\n    public override string ToString() => v1 + \" \" + v2;\n    public void Deconstruct(out T a, out U b) { a = v1; b = v2; }\n    public static bool operator>(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) > 0;\n    public static bool operator<(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) < 0;\n    public static bool operator>=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) >= 0;\n    public static bool operator<=(pair<T, U> a, pair<T, U> b) => a.CompareTo(b) <= 0;\n}\nstatic class util {\n    public static pair<T, U> make_pair<T, U>(T v1, U v2) => new pair<T, U>(v1, v2);\n    public static T sq<T>(T a) => Operator<T>.Multiply(a, a);\n    public static T Max<T>(params T[] a) => a.Max();\n    public static T Min<T>(params T[] a) => a.Min();\n    public static bool inside(int i, int j, int h, int w) => i >= 0 && i < h && j >= 0 && j < w;\n    static readonly int[] dd = { 0, 1, 0, -1 };\n    static readonly string dstring = \"RDLU\";\n    public static P[] adjacents(this P p) => adjacents(p.v1, p.v2);\n    public static P[] adjacents(this P p, int h, int w) => adjacents(p.v1, p.v2, h, w);\n    public static pair<P, char>[] adjacents_with_str(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new pair<P, char>(new P(i + dd[k], j + dd[k ^ 1]), dstring[k])).ToArray();\n    public static pair<P, char>[] adjacents_with_str(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new pair<P, char>(new P(i + dd[k], j + dd[k ^ 1]), dstring[k]))\n                                         .Where(p => inside(p.v1.v1, p.v1.v2, h, w)).ToArray();\n    public static P[] adjacents(int i, int j)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).ToArray();\n    public static P[] adjacents(int i, int j, int h, int w)\n        => Enumerable.Range(0, dd.Length).Select(k => new P(i + dd[k], j + dd[k ^ 1])).Where(p => inside(p.v1, p.v2, h, w)).ToArray();\n    public static void Assert(bool cond) { if (!cond) throw new Exception(); }\n    public static Dictionary<T, int> compress<T>(this IEnumerable<T> a)\n        => a.Distinct().OrderBy(v => v).Select((v, i) => new { v, i }).ToDictionary(p => p.v, p => p.i);\n    public static Dictionary<T, int> compress<T>(params IEnumerable<T>[] a) => compress(a.Aggregate(Enumerable.Union));\n    public static void swap<T>(ref T a, ref T b) where T : struct { var t = a; a = b; b = t; }\n    public static void swap<T>(this IList<T> a, int i, int j) where T : struct { var t = a[i]; a[i] = a[j]; a[j] = t; }\n    public static T[] copy<T>(this IList<T> a) {\n        var ret = new T[a.Count];\n        for (int i = 0; i < a.Count; i++) ret[i] = a[i];\n        return ret;\n    }\n}\nstatic class Operator<T> {\n    static readonly ParameterExpression x = Expression.Parameter(typeof(T), \"x\");\n    static readonly ParameterExpression y = Expression.Parameter(typeof(T), \"y\");\n    public static readonly Func<T, T, T> Add = Lambda(Expression.Add);\n    public static readonly Func<T, T, T> Subtract = Lambda(Expression.Subtract);\n    public static readonly Func<T, T, T> Multiply = Lambda(Expression.Multiply);\n    public static readonly Func<T, T, T> Divide = Lambda(Expression.Divide);\n    public static readonly Func<T, T> Plus = Lambda(Expression.UnaryPlus);\n    public static readonly Func<T, T> Negate = Lambda(Expression.Negate);\n    public static Func<T, T, T> Lambda(Binary op) => Expression.Lambda<Func<T, T, T>>(op(x, y), x, y).Compile();\n    public static Func<T, T> Lambda(Unary op) => Expression.Lambda<Func<T, T>>(op(x), x).Compile();\n}\n\nclass Scan {\n    StreamReader sr;\n    public Scan() { sr = new StreamReader(Console.OpenStandardInput()); }\n    public Scan(string path) { sr = new StreamReader(path); }\n    public int Int => int.Parse(Str);\n    public long Long => long.Parse(Str);\n    public double Double => double.Parse(Str);\n    public string Str => sr.ReadLine().Trim();\n    public pair<T, U> Pair<T, U>() {\n        T a; U b;\n        Multi(out a, out b);\n        return new pair<T, U>(a, b);\n    }\n    public P P => Pair<int, int>();\n    public int[] IntArr => StrArr.Select(int.Parse).ToArray();\n    public long[] LongArr => StrArr.Select(long.Parse).ToArray();\n    public double[] DoubleArr => StrArr.Select(double.Parse).ToArray();\n    public string[] StrArr => Str.Split(new[]{' '}, StringSplitOptions.RemoveEmptyEntries);\n    bool eq<T, U>() => typeof(T).Equals(typeof(U));\n    T ct<T, U>(U a) => (T)Convert.ChangeType(a, typeof(T));\n    T cv<T>(string s) => eq<T, int>()    ? ct<T, int>(int.Parse(s))\n                       : eq<T, long>()   ? ct<T, long>(long.Parse(s))\n                       : eq<T, double>() ? ct<T, double>(double.Parse(s))\n                       : eq<T, char>()   ? ct<T, char>(s[0])\n                                         : ct<T, string>(s);\n    public void Multi<T>(out T a) => a = cv<T>(Str);\n    public void Multi<T, U>(out T a, out U b)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); }\n    public void Multi<T, U, V>(out T a, out U b, out V c)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); }\n    public void Multi<T, U, V, W>(out T a, out U b, out V c, out W d)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); }\n    public void Multi<T, U, V, W, X>(out T a, out U b, out V c, out W d, out X e)\n    { var ar = StrArr; a = cv<T>(ar[0]); b = cv<U>(ar[1]); c = cv<V>(ar[2]); d = cv<W>(ar[3]); e = cv<X>(ar[4]); }\n}\nclass UnionFind {\n    int num;\n    int[] par, sz, rank;\n    public UnionFind(int n) {\n        num = n; par = new int[n]; sz = new int[n]; rank = new int[n];\n        for (int i = 0; i < n; ++i) { par[i] = i; sz[i] = 1; rank[i] = 0; }\n    }\n    int find(int x) => par[x] == x ? x : (par[x] = find(par[x]));\n    public bool same(int x, int y) => find(x) == find(y);\n    public int unionsize(int x) => sz[find(x)];\n    public int unioncount => num;\n    public bool unite(int x, int y) {\n        x = find(x); y = find(y);\n        if (x == y) return false;\n        --num;\n        if (rank[x] < rank[y]) {\n            par[x] = y;\n            sz[y] += sz[x];\n        }\n        else {\n            par[y] = x;\n            sz[x] += sz[y];\n            if (rank[x] == rank[y]) ++rank[x];\n        }\n        return true;\n    }\n    public bool ispar(int x) => x == find(x);\n    public int getpar(int x) => find(x);\n}\n"
  },
  {
    "language": "Ruby",
    "code": "n, h, w = gets.split.map(&:to_i)\n@arr = Array.new(n) {\n    r, c, a = gets.split.map(&:to_i)\n    {:number => a, :row => r - 1, :column => c - 1}\n}\n@arr.sort_by! {|item| item[:number]}.reverse!\n@available_row = Array.new(n, true)\n@available_column = Array.new(n, true)\ndef solve(idx)\n    if idx >= @arr.size then\n        return 0\n    end\n    item = @arr[idx]\n    if @available_row[item[:row]] then\n        if @available_column[item[:column]] then\n            @available_row[item[:row]] = false\n            sum1 = solve(idx + 1)\n            @available_row[item[:row]] = true\n            @available_column[item[:column]] = false\n            sum2 = solve(idx + 1)\n            @available_column[item[:column]] = true\n            return item[:number] + (sum1 >= sum2 ? sum1 : sum2)\n        else\n            @available_row[item[:row]] = false\n            sum = solve(idx + 1)\n            @available_row[item[:row]] = true\n            return item[:number] + sum\n        end\n    else\n        if @available_column[item[:column]] then\n            @available_column[item[:column]] = false\n            sum = solve(idx + 1)\n            @available_column[item[:column]] = true\n            return item[:number] + sum\n        else\n            return solve(idx + 1)\n        end\n    end\nend\nputs solve(0)\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n  \"bufio\"\n  \"fmt\"\n  \"os\"\n  \"sort\"\n  \"strconv\"\n  \"strings\"\n)\n\nfunc main() {\n  input := Input{bufio.NewReaderSize(os.Stdin,100)}\n  n,h,w := input.NextInts()\n  es := make(Edges,n)\n  for i:=0;i<n;i++ {\n    r,c,a := input.NextInts()\n    es[i] = Edge{r-1,h+c-1,int64(a)}\n  }\n  sort.Sort(sort.Reverse(es))\n  uf := NewUnionFind(h+w)\n  ans := int64(0)\n  for i:=0;i<n;i++ {\n    fm,to := es[i].fm,es[i].to\n    if uf.Same(fm,to) {\n      if uf.Count(fm) >= uf.Size(fm) { continue }\n    } else {\n      if uf.Count(fm)+uf.Count(to)+1 > uf.Size(fm)+uf.Size(to) { continue }\n    }\n    uf.Unite(fm,to)\n    ans += es[i].c\n  }\n  fmt.Println(ans)\n}\n\ntype Edge struct { fm,to int;c int64 }\ntype Edges []Edge\ntype Graph [][]Edge\nfunc(e Edges) Len() int { return len(e) }\nfunc(e Edges) Swap(i,j int) { e[i],e[j] = e[j],e[i] }\nfunc(e Edges) Less(i,j int) bool { return e[i].c < e[j].c }\nfunc(g Graph) AddEdge(fm int,e Edge) { g[fm] = append(g[fm],e) }\nfunc(g Graph) Add(fm,to int,c int64) { g.AddEdge(fm,Edge{fm,to,c}) }\n\ntype UnionFind struct { par,rank,size,cnt []int }\nfunc NewUnionFind(n int) UnionFind {\n  par := make([]int,n)\n  rank := make([]int,n)\n  size := make([]int,n)\n  cnt := make([]int,n)\n  for i:=0;i<n;i++ { par[i],size[i] = i,1 }\n  return UnionFind{par,rank,size,cnt}\n}\nfunc(u UnionFind) Find(i int) int {\n  if u.par[i] == i { return i }\n  u.par[i] = u.Find(u.par[i])\n  return u.par[i]\n}\nfunc(u UnionFind) Same(i,j int) bool { return u.Find(i) == u.Find(j) }\nfunc(u UnionFind) Unite(i,j int) {\n  i,j = u.Find(i),u.Find(j)\n  if i == j { u.cnt[i]++;return }\n  if u.rank[i] < u.rank[j] {\n    u.par[i] = j\n    u.size[j] += u.size[i]\n    u.cnt[j] += u.cnt[i]+1\n  } else {\n    u.par[j] = i\n    u.size[i] += u.size[j]\n    u.cnt[i] += u.cnt[j]+1\n    if u.rank[i] == u.rank[j] { u.rank[i]++ }\n  }\n}\nfunc(u UnionFind) Size(i int) int { return u.size[u.Find(i)] }\nfunc(u UnionFind) Count(i int) int { return u.cnt[u.Find(i)] }\n\ntype Input struct { reader *bufio.Reader }\nfunc(i *Input) NextLine() string {\n  var buffer []byte\n  for {\n    line,isPrefix,err := i.reader.ReadLine()\n    if err != nil { panic(err) }\n    buffer = append(buffer,line...)\n    if !isPrefix { break }\n  }\n  return string(buffer)\n}\nfunc(i *Input) NextInts() (int,int,int) {\n  s := strings.Fields(i.NextLine())\n  x,_ := strconv.Atoi(s[0])\n  y,_ := strconv.Atoi(s[1])\n  z,_ := strconv.Atoi(s[2])\n  return x,y,z\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.format;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.concurrency;\nimport std.traits;\nimport std.uni;\nimport core.bitop : popcnt;\nalias Generator = std.concurrency.Generator;\n\nenum long INF = long.max/5;\nenum long MOD = 10L^^9+7;\n\nvoid main() {\n  long N, H, W;\n  scanln(N, H, W);\n  struct P {\n    long r, c, a;\n    bool used = false;\n  }\n  P[] ps = new P[N];\n  foreach(i; 0..N) {\n    scanln(ps[i].r, ps[i].c, ps[i].a);\n    ps[i].r--;\n    ps[i].c--;\n  }\n\n  if (H < W) {\n    swap(H, W);\n    foreach(i; 0..N) {\n      swap(ps[i].r, ps[i].c);\n    }\n  }\n\n  ps.sort!\"a.a > b.a\";\n\n  long ans = 0;\n  bool[] hs = new bool[H];\n  bool[] ws = new bool[W];\n  foreach(p; ps) {\n    if (!hs[p.r]) {\n      hs[p.r] = true;\n      ans += p.a;\n    } else if (!ws[p.c]) {\n      ws[p.c] = true;\n      ans += p.a;\n    }\n  }\n  ans.writeln;\n}\n\n// ----------------------------------------------\n\n\nvoid times(alias fun)(long n) {\n  // n.iota.each!(i => fun());\n  foreach(i; 0..n) fun();\n}\nauto rep(alias fun, T = typeof(fun()))(long n) {\n  // return n.iota.map!(i => fun()).array;\n  T[] res = new T[n];\n  foreach(ref e; res) e = fun();\n  return res;\n}\n\nT ceil(T)(T x, T y) if (isIntegral!T || is(T == BigInt)) {\n  // `(x+y-1)/y` will only work for positive numbers ...\n  T t = x / y;\n  if (t * y < x) t++;\n  return t;\n}\n\nT floor(T)(T x, T y) if (isIntegral!T || is(T == BigInt)) {\n  T t = x / y;\n  if (t * y > x) t--;\n  return t;\n}\n\nref T ch(alias fun, T, S...)(ref T lhs, S rhs) {\n  return lhs = fun(lhs, rhs);\n}\nunittest {\n  long x = 1000;\n  x.ch!min(2000);\n  assert(x == 1000);\n  x.ch!min(3, 2, 1);\n  assert(x == 1);\n  x.ch!max(100).ch!min(1000); // clamp\n  assert(x == 100);\n  x.ch!max(0).ch!min(10); // clamp\n  assert(x == 10);\n}\n\nmixin template Constructor() {\n  import std.traits : FieldNameTuple;\n  this(Args...)(Args args) {\n    // static foreach(i, v; args) {\n    foreach(i, v; args) {\n      mixin(\"this.\" ~ FieldNameTuple!(typeof(this))[i]) = v;\n    }\n  }\n}\n\nvoid scanln(Args...)(auto ref Args args) {\n  enum sep = \" \";\n  enum n = Args.length;\n  enum fmt = n.rep!(()=>\"%s\").join(sep) ~ \"\\n\";\n  static if (__VERSION__ >= 2071) {\n    readf!fmt(args);\n  } else {\n    enum argsTemp = n.iota.map!(\n      i => \"&args[%d]\".format(i)\n    ).join(\", \");\n    mixin(\n      \"readf(fmt, \" ~ argsTemp ~ \");\"\n    );\n  }\n}\n\n// fold was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n  template fold(fun...) if (fun.length >= 1) {\n    auto fold(R, S...)(R r, S seed) {\n      static if (S.length < 2) {\n        return reduce!fun(seed, r);\n      } else {\n        return reduce!fun(tuple(seed), r);\n      }\n    }\n  }\n}\n\n// cumulativeFold was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n  template cumulativeFold(fun...)\n  if (fun.length >= 1)\n  {\n    import std.meta : staticMap;\n    private alias binfuns = staticMap!(binaryFun, fun);\n\n    auto cumulativeFold(R)(R range)\n    if (isInputRange!(Unqual!R))\n    {\n      return cumulativeFoldImpl(range);\n    }\n\n    auto cumulativeFold(R, S)(R range, S seed)\n    if (isInputRange!(Unqual!R))\n    {\n      static if (fun.length == 1)\n        return cumulativeFoldImpl(range, seed);\n      else\n        return cumulativeFoldImpl(range, seed.expand);\n    }\n\n    private auto cumulativeFoldImpl(R, Args...)(R range, ref Args args)\n    {\n      import std.algorithm.internal : algoFormat;\n\n      static assert(Args.length == 0 || Args.length == fun.length,\n        algoFormat(\"Seed %s does not have the correct amount of fields (should be %s)\",\n          Args.stringof, fun.length));\n\n      static if (args.length)\n        alias State = staticMap!(Unqual, Args);\n      else\n        alias State = staticMap!(ReduceSeedType!(ElementType!R), binfuns);\n\n      foreach (i, f; binfuns)\n      {\n        static assert(!__traits(compiles, f(args[i], e)) || __traits(compiles,\n            { args[i] = f(args[i], e); }()),\n          algoFormat(\"Incompatible function/seed/element: %s/%s/%s\",\n            fullyQualifiedName!f, Args[i].stringof, E.stringof));\n      }\n\n      static struct Result\n      {\n      private:\n        R source;\n        State state;\n\n        this(R range, ref Args args)\n        {\n          source = range;\n          if (source.empty)\n            return;\n\n          foreach (i, f; binfuns)\n          {\n            static if (args.length)\n              state[i] = f(args[i], source.front);\n            else\n              state[i] = source.front;\n          }\n        }\n\n      public:\n        @property bool empty()\n        {\n          return source.empty;\n        }\n\n        @property auto front()\n        {\n          assert(!empty, \"Attempting to fetch the front of an empty cumulativeFold.\");\n          static if (fun.length > 1)\n          {\n            import std.typecons : tuple;\n            return tuple(state);\n          }\n          else\n          {\n            return state[0];\n          }\n        }\n\n        void popFront()\n        {\n          assert(!empty, \"Attempting to popFront an empty cumulativeFold.\");\n          source.popFront;\n\n          if (source.empty)\n            return;\n\n          foreach (i, f; binfuns)\n            state[i] = f(state[i], source.front);\n        }\n\n        static if (isForwardRange!R)\n        {\n          @property auto save()\n          {\n            auto result = this;\n            result.source = source.save;\n            return result;\n          }\n        }\n\n        static if (hasLength!R)\n        {\n          @property size_t length()\n          {\n            return source.length;\n          }\n        }\n      }\n\n      return Result(range, args);\n    }\n  }\n}\n\n// minElement/maxElement was added in D 2.072.0\nstatic if (__VERSION__ < 2072) {\n  private template RebindableOrUnqual(T)\n  {\n      static if (is(T == class) || is(T == interface) || isDynamicArray!T || isAssociativeArray!T)\n          alias RebindableOrUnqual = Rebindable!T;\n      else\n          alias RebindableOrUnqual = Unqual!T;\n  }\n  private auto extremum(alias map, alias selector = \"a < b\", Range)(Range r)\n  if (isInputRange!Range && !isInfinite!Range &&\n      is(typeof(unaryFun!map(ElementType!(Range).init))))\n  in\n  {\n      assert(!r.empty, \"r is an empty range\");\n  }\n  body\n  {\n      alias Element = ElementType!Range;\n      RebindableOrUnqual!Element seed = r.front;\n      r.popFront();\n      return extremum!(map, selector)(r, seed);\n  }\n\n  private auto extremum(alias map, alias selector = \"a < b\", Range,\n                        RangeElementType = ElementType!Range)\n                       (Range r, RangeElementType seedElement)\n  if (isInputRange!Range && !isInfinite!Range &&\n      !is(CommonType!(ElementType!Range, RangeElementType) == void) &&\n       is(typeof(unaryFun!map(ElementType!(Range).init))))\n  {\n      alias mapFun = unaryFun!map;\n      alias selectorFun = binaryFun!selector;\n\n      alias Element = ElementType!Range;\n      alias CommonElement = CommonType!(Element, RangeElementType);\n      RebindableOrUnqual!CommonElement extremeElement = seedElement;\n\n\n      // if we only have one statement in the loop, it can be optimized a lot better\n      static if (__traits(isSame, map, a => a))\n      {\n\n          // direct access via a random access range is faster\n          static if (isRandomAccessRange!Range)\n          {\n              foreach (const i; 0 .. r.length)\n              {\n                  if (selectorFun(r[i], extremeElement))\n                  {\n                      extremeElement = r[i];\n                  }\n              }\n          }\n          else\n          {\n              while (!r.empty)\n              {\n                  if (selectorFun(r.front, extremeElement))\n                  {\n                      extremeElement = r.front;\n                  }\n                  r.popFront();\n              }\n          }\n      }\n      else\n      {\n          alias MapType = Unqual!(typeof(mapFun(CommonElement.init)));\n          MapType extremeElementMapped = mapFun(extremeElement);\n\n          // direct access via a random access range is faster\n          static if (isRandomAccessRange!Range)\n          {\n              foreach (const i; 0 .. r.length)\n              {\n                  MapType mapElement = mapFun(r[i]);\n                  if (selectorFun(mapElement, extremeElementMapped))\n                  {\n                      extremeElement = r[i];\n                      extremeElementMapped = mapElement;\n                  }\n              }\n          }\n          else\n          {\n              while (!r.empty)\n              {\n                  MapType mapElement = mapFun(r.front);\n                  if (selectorFun(mapElement, extremeElementMapped))\n                  {\n                      extremeElement = r.front;\n                      extremeElementMapped = mapElement;\n                  }\n                  r.popFront();\n              }\n          }\n      }\n      return extremeElement;\n  }\n\n  private auto extremum(alias selector = \"a < b\", Range)(Range r)\n  if (isInputRange!Range && !isInfinite!Range &&\n      !is(typeof(unaryFun!selector(ElementType!(Range).init))))\n  {\n      return extremum!(a => a, selector)(r);\n  }\n\n  // if we only have one statement in the loop it can be optimized a lot better\n  private auto extremum(alias selector = \"a < b\", Range,\n                        RangeElementType = ElementType!Range)\n                       (Range r, RangeElementType seedElement)\n  if (isInputRange!Range && !isInfinite!Range &&\n      !is(CommonType!(ElementType!Range, RangeElementType) == void) &&\n      !is(typeof(unaryFun!selector(ElementType!(Range).init))))\n  {\n      return extremum!(a => a, selector)(r, seedElement);\n  }\n\n  auto minElement(alias map = (a => a), Range)(Range r)\n  if (isInputRange!Range && !isInfinite!Range)\n  {\n      return extremum!map(r);\n  }\n  auto minElement(alias map = (a => a), Range, RangeElementType = ElementType!Range)\n                 (Range r, RangeElementType seed)\n  if (isInputRange!Range && !isInfinite!Range &&\n      !is(CommonType!(ElementType!Range, RangeElementType) == void))\n  {\n      return extremum!map(r, seed);\n  }\n  auto maxElement(alias map = (a => a), Range)(Range r)\n  if (isInputRange!Range && !isInfinite!Range)\n  {\n      return extremum!(map, \"a > b\")(r);\n  }\n  auto maxElement(alias map = (a => a), Range, RangeElementType = ElementType!Range)\n                 (Range r, RangeElementType seed)\n  if (isInputRange!Range && !isInfinite!Range &&\n      !is(CommonType!(ElementType!Range, RangeElementType) == void))\n  {\n      return extremum!(map, \"a > b\")(r, seed);\n  }\n}\n\n// popcnt with ulongs was added in D 2.071.0\nstatic if (__VERSION__ < 2071) {\n  ulong popcnt(ulong x) {\n    x = (x & 0x5555555555555555L) + (x>> 1 & 0x5555555555555555L);\n    x = (x & 0x3333333333333333L) + (x>> 2 & 0x3333333333333333L);\n    x = (x & 0x0f0f0f0f0f0f0f0fL) + (x>> 4 & 0x0f0f0f0f0f0f0f0fL);\n    x = (x & 0x00ff00ff00ff00ffL) + (x>> 8 & 0x00ff00ff00ff00ffL);\n    x = (x & 0x0000ffff0000ffffL) + (x>>16 & 0x0000ffff0000ffffL);\n    x = (x & 0x00000000ffffffffL) + (x>>32 & 0x00000000ffffffffL);\n    return x;\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.complex, std.container, std.math, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nint root(int[] uf, int u) {\n  return (uf[u] < 0) ? u : (uf[u] = uf.root(uf[u]));\n}\nbool connect(int[] uf, int u, int v) {\n  u = uf.root(u);\n  v = uf.root(v);\n  if (u == v) return false;\n  if (uf[u] > uf[v]) swap(u, v);\n  uf[u] += uf[v];\n  uf[v] = u;\n  return true;\n}\n\n\nint N, H, W;\nint[] X, Y;\nlong[] A;\n\nvoid main() {\n  try {\n    for (; ; ) {\n      N = readInt();\n      H = readInt();\n      W = readInt();\n      X = new int[N];\n      Y = new int[N];\n      A = new long[N];\n      foreach (i; 0 .. N) {\n        X[i] = readInt() - 1;\n        Y[i] = readInt() - 1;\n        A[i] = readLong();\n      }\n      \n      auto uf = new int[H + W];\n      uf[] = -1;\n      auto cnt = new int[H + W];\n      \n      auto es = new Tuple!(long, int)[N];\n      foreach (i; 0 .. N) {\n        es[i] = tuple(A[i], i);\n      }\n      sort(es);\n      reverse(es);\n      \n      long ans;\n      foreach (e; es) {\n        const i = e[1];\n        const ru = uf.root(X[i]);\n        const rv = uf.root(H + Y[i]);\n        if (ru == rv) {\n          if ((-uf[ru]) >= cnt[ru] + 1) {\n            ans += A[i];\n            cnt[ru] += 1;\n          }\n        } else {\n          if ((-uf[ru]) + (-uf[rv]) >= cnt[ru] + cnt[rv] + 1) {\n            ans += A[i];\n            uf.connect(ru, rv);\n            cnt[uf.root(ru)] = cnt[ru] + cnt[rv] + 1;\n          }\n        }\n      }\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.range, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.complex, std.container, std.math, std.numeric, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum INF = 10L^^18;\n\nint N, H, W;\nint[] X, Y;\nlong[] A;\n\nvoid main() {\n  try {\n    for (; ; ) {\n      N = readInt();\n      H = readInt();\n      W = readInt();\n      X = new int[N];\n      Y = new int[N];\n      A = new long[N];\n      foreach (i; 0 .. N) {\n        X[i] = readInt() - 1;\n        Y[i] = readInt() - 1;\n        A[i] = readLong();\n      }\n      \n      alias Entry = Tuple!(long, \"val\", int, \"key\");\n      auto qX = new BinaryHeap!(Array!Entry)[H];\n      auto qY = new BinaryHeap!(Array!Entry)[W];\n      foreach (i; 0 .. N) {\n        qX[X[i]].insert(Entry(A[i], i));\n        qY[Y[i]].insert(Entry(A[i], i));\n      }\n      \n      auto es = new Entry[N];\n      foreach (i; 0 .. N) {\n        es[i] = Entry(A[i], i);\n      }\n      sort(es);\n      reverse(es);\n      \n      auto usedX = new bool[H];\n      auto usedY = new bool[W];\n      long ans;\n      foreach (j; 0 .. N) {\n        const i = es[j].key;\n        debug {\n          writeln(i, \" \", es[j], \" \", qX[X[i]].front, \" \", qY[Y[i]].front);\n        }\n        qX[X[i]].removeFront;\n        qY[Y[i]].removeFront;\n        if (!usedX[X[i]] && !usedY[Y[i]]) {\n          const aX = qX[X[i]].empty ? Entry(-INF, -1) : qX[X[i]].front;\n          const aY = qY[Y[i]].empty ? Entry(-INF, -1) : qY[Y[i]].front;\n          if (aX < aY) {\n            usedX[X[i]] = true;\n            ans += A[i];\n          } else {\n            usedY[Y[i]] = true;\n            ans += A[i];\n          }\n        } else if (!usedX[X[i]]) {\n          usedX[X[i]] = true;\n          ans += A[i];\n        } else if (!usedY[Y[i]]) {\n          usedY[Y[i]] = true;\n          ans += A[i];\n        } else {\n          // discard\n        }\n      }\n      writeln(ans);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Bash",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\nconst int N=2e5+1000;\nstruct node{\n\tint c,r;\n\tLL x;\n}a[N];\nbool cmp(node a,node b){\n\treturn a.x>b.x;\n}\nint fa[N],g[N];\nint find(int x){\n\treturn fa[x]==x?x:(fa[x]=find(fa[x]));\n}\nbool merge(int x,int y){\n\tx=find(x);y=find(y);\n\tcout<<x<<\" \"<<g[x]<<\"   \"<<y<<\" \"<<g[y]<<endl;\n\tif(x==y){\n\t\tif(g[x])return 0;\n\t\telse return g[x]=1;\n\t}\n\tif(g[x]&&g[y])return 0;\n\tfa[y]=x;\n\tg[x]|=g[y];\n\treturn 1;\n}\n\nint main()\n{\n\tLL ans=0;\n\tint n,h,w;\n\tscanf(\"%d%d%d\",&n,&h,&w);\n\tfor(int i=1;i<=n;i++){\n\t\tscanf(\"%d%d%lld\",&a[i].r,&a[i].c,&a[i].x);\n\t}\n\tsort(a+1,a+1+n,cmp);\n\tfor(int i=1;i<=h+w;i++)fa[i]=i,g[i]=0;\n\tfor(int i=1;i<=n;i++){\n\t\tif(merge(a[i].r,a[i].c+h))ans+=a[i].x;\n\t\t\n\t}\n\tprintf(\"%lld\\n\",ans);\n}"
  },
  {
    "language": "Nim",
    "code": "import algorithm, future, hashes, macros, math, sequtils, sets, strutils, tables, times, unicode, queues\n \nmacro unpack(rhs: seq, cnt: static[int]): auto =\n  let t = genSym(); result = quote do:(let `t` = `rhs`;())\n  if NimMinor <= 17:\n    for i in 0..<cnt: result[0][1].add(quote do:`t`[`i`])\n  else:\n    for i in 0..<cnt: result[1].add(quote do:`t`[`i`])\n \ntemplate input(T: typedesc, cnt: Natural = 1): untyped =\n  let line = stdin.readLine.split(\" \")\n  when T is int:         line.map(parseInt).unpack(cnt)\n  elif T is float:       line.map(parseFloat).unpack(cnt)\n  elif T is string:      line.unpack(cnt)\n  elif T is char:        line.mapIt(it[0]).unpack(cnt)\n  elif T is seq[int]:    line.map(parseInt)\n  elif T is seq[float]:  line.map(parseFloat)\n  elif T is seq[string]: line\n  elif T is seq[char]:   line.mapIt(it[0])\n\nproc floorMod*[T: SomeNumber](x, y: T): T =\n  result = x mod y\n  if (result > 0 and y < 0) or (result < 0 and y > 0): result += y\n\nproc `%`(n,m:int):int = floorMod(n,m)\nproc `%=`(n: var int, m: int)  = n = floorMod(n,m)\nproc `//=`(n: var int, m: int) = n = n div m\nproc `<<=`(n: var int, m: int) = n = n shl m\nproc `>>=`(n: var int, m: int) = n = n shr m\nproc `<?=`(n: var int, m: int) = n = min(n, m)\nproc `>?=`(n: var int, m: int) = n = max(n, m)\nproc newSeq2[T](n1, n2: Natural): seq[seq[T]] = newSeqWith(n1, newSeq[T](n2))\nproc newSeq3[T](n1, n2, n3: Natural): seq[seq[seq[T]]] = newSeqWith(n1, newSeqWith(n2, newSeq[T](n3)))\n \nproc spacingEcho(things: varargs[string,`$`]) =\n  for thing in things:\n    stdout.write(thing)\n    stdout.write(\" \")\n  stdout.write(\"\\n\")\nproc spacingEcho[T](things: seq[T]) =\n  for thing in things:\n    stdout.write(thing)\n    stdout.write(\" \")\n  stdout.write(\"\\n\")\nproc spacingEcho[T](things: seq[seq[T]]) =\n  for thing in things:\n    spacingEcho thing\nproc spacingEchoPlusOne(things: varargs[int]) =\n  for thing in things:\n    stdout.write(thing+1)\n    stdout.write(\" \")\n  stdout.write(\"\\n\")\nproc spacingEchoPlusOne(things: seq[int]) =\n  for thing in things:\n    stdout.write(thing+1)\n    stdout.write(\" \")\n  stdout.write(\"\\n\")\nproc spacingEchoPlusOne(things: seq[seq[int]]) =\n  for thing in things:\n    spacingEchoPlusOne thing\n    \n# -------------------------------------------------- #\n\ntype Edge = tuple\n  src: int\n  dst: int\n  val: int\n\nproc `$`(e:Edge):string =\n  \"\" & $e.src & \"->\" & $e.dst & \": \" & $e.val & \"\"\n\nproc `<`(x,y:Edge):bool = x.val < y.val\nproc `>`(x,y:Edge):bool = x.val > y.val\n\n\n# -------------------------------------------------- #\n# HeapQueue : a container, in which you can push item, pop minimum item, peek minimum item efficiently.\n# hq = newHeapQueue[int]() : init hq as an heapqueue.\n# hq.push x : push item x in hq. O(log N)\n# x = hq.pop : pop minimum element x in hq. O(log N)\n# x = hq.peek : peek minimum element x in hq. O(1)\n# tested in ABC128.E\n\n\ntype HeapQueue*[T] = distinct seq[T]\n\nproc newHeapQueue*[T](): HeapQueue[T] {.inline.} = HeapQueue[T](newSeq[T]())\nproc newHeapQueue*[T](h: var HeapQueue[T]) {.inline.} = h = HeapQueue[T](newSeq[T]())\n\nproc len*[T](h: HeapQueue[T]): int {.inline.} = seq[T](h).len\nproc `[]`*[T](h: HeapQueue[T], i: int): T {.inline.} = seq[T](h)[i]\nproc `[]=`[T](h: var HeapQueue[T], i: int, v: T) {.inline.} = seq[T](h)[i] = v\nproc add[T](h: var HeapQueue[T], v: T) {.inline.} = seq[T](h).add(v)\n\nproc heapCmp[T](x, y: T): bool {.inline.} =\n  return (x > y)\n\n# 'heap' is a heap at all indices >= startpos, except possibly for pos.  pos\n# is the index of a leaf with a possibly out-of-order value.  Restore the\n# heap invariant.\nproc siftdown[T](heap: var HeapQueue[T], startpos, p: int) =\n  var pos = p\n  var newitem = heap[pos]\n  # Follow the path to the root, moving parents down until finding a place\n  # newitem fits.\n  while pos > startpos:\n    let parentpos = (pos - 1) shr 1\n    let parent = heap[parentpos]\n    if heapCmp(newitem, parent):\n      heap[pos] = parent\n      pos = parentpos\n    else:\n      break\n  heap[pos] = newitem\n\nproc siftup[T](heap: var HeapQueue[T], p: int) =\n  let endpos = len(heap)\n  var pos = p\n  let startpos = pos\n  let newitem = heap[pos]\n  # Bubble up the smaller child until hitting a leaf.\n  var childpos = 2*pos + 1    # leftmost child position\n  while childpos < endpos:\n    # Set childpos to index of smaller child.\n    let rightpos = childpos + 1\n    if rightpos < endpos and not heapCmp(heap[childpos], heap[rightpos]):\n      childpos = rightpos\n    # Move the smaller child up.\n    heap[pos] = heap[childpos]\n    pos = childpos\n    childpos = 2*pos + 1\n  # The leaf at pos is empty now.  Put newitem there, and bubble it up\n  # to its final resting place (by sifting its parents down).\n  heap[pos] = newitem\n  siftdown(heap, startpos, pos)\n\nproc push*[T](heap: var HeapQueue[T], item: T) =\n  ## Push item onto heap, maintaining the heap invariant.\n  (seq[T](heap)).add(item)\n  siftdown(heap, 0, len(heap)-1)\n\nproc pop*[T](heap: var HeapQueue[T]): T =\n  ## Pop the smallest item off the heap, maintaining the heap invariant.\n  let lastelt = seq[T](heap).pop()\n  if heap.len > 0:\n    result = heap[0]\n    heap[0] = lastelt\n    siftup(heap, 0)\n  else:\n    result = lastelt\n\nproc del*[T](heap: var HeapQueue[T], index: int) =\n  ## Removes element at `index`, maintaining the heap invariant.\n  swap(seq[T](heap)[^1], seq[T](heap)[index])\n  let newLen = heap.len - 1\n  seq[T](heap).setLen(newLen)\n  if index < newLen:\n    heap.siftup(index)\n\nproc replace*[T](heap: var HeapQueue[T], item: T): T =\n  ## Pop and return the current smallest value, and add the new item.\n  ## This is more efficient than pop() followed by push(), and can be\n  ## more appropriate when using a fixed-size heap.  Note that the value\n  ## returned may be larger than item!  That constrains reasonable uses of\n  ## this routine unless written as part of a conditional replacement:\n\n  ##    if item > heap[0]:\n  ##        item = replace(heap, item)\n  result = heap[0]\n  heap[0] = item\n  siftup(heap, 0)\n\nproc pushpop*[T](heap: var HeapQueue[T], item: T): T =\n  ## Fast version of a push followed by a pop.\n  if heap.len > 0 and heapCmp(heap[0], item):\n    swap(item, heap[0])\n    siftup(heap, 0)\n  return item\n\nproc peek*[T](heap: var HeapQueue[T]): T =\n  result = heap[0]\n\nproc peekOr*[T](heap: var HeapQueue[T], ifnil: T): T =\n  if heap.len == 0:\n    result = ifnil\n  else:\n    result = heap[0]\n    \nproc popOr*[T](heap: var HeapQueue[T], ifnil: T): T =\n  if heap.len == 0:\n    result = ifnil\n  else:\n    result = heap.pop()\n# -------------------------------------------------- #\n# UnionFind : a struct for classifying ints.\n# uf = newUnionFind(l) : init uf as an UnionFind whose keys are 0..<l .\n# uf.same(x,y) : x and y are included in one same group?\n# uf.unite(x,y) : unite the group including x and the group including y.\n# tested in ABC126.E\n\n\ntype UnionFind* = object\n  parentOf: seq[int]\n  eNumOf: seq[int]\n  pNumOf: seq[int]\n\nproc newUnionFind*(l: int) :UnionFind =\n  var parentOf = lc[ i | (i <- 0..<l), int ]\n  var eNumOf = newSeq[int](l)\n  var pNumOf = newSeq[int](l)\n  return UnionFind(parentOf:parentOf, eNumOf:eNumOf, pNumOf:pNumOf)\n\nproc isInnovator*(uf:UnionFind, i:int): bool = uf.parentOf[i]==i\n\nproc findInnovator*(uf: var UnionFind, i:int): int = \n  if uf.parentOf[i] == i:\n    return i\n  else:\n    result = uf.findInnovator(uf.parentOf[i])\n    uf.parentOf[i] = result\n\nproc same*(uf: var UnionFind, x:int, y:int): bool =\n  let rx = uf.findInnovator(x)\n  let ry = uf.findInnovator(y)\n  return rx == ry\n\nproc unite*(uf: var UnionFind, x:int, y:int) =\n  let rx = uf.findInnovator(x)\n  let ry = uf.findInnovator(y)\n  if rx != ry:\n    uf.parentOf[ry] = rx\n  uf.eNumOf[rx] += uf.eNumOf[ry] + 1\n  uf.pNumOf[rx] += uf.pNumOf[ry] + 1\n\n# -------------------------------------------------- #\n\n\n\nvar (N,H,W) = input(int,3)\n\nvar edges = newSeq[Edge]()\nvar edges_Src = newSeq2[Edge](H+W,0)\nvar edges_Dst = newSeq2[Edge](H+W,0)\nfor i in 0..<N:\n  var (r,c,val) = input(int,3)\n  r -= 1\n  c -= 1\n  c += H\n  let e1 = (src:r, dst:c, val:val)\n  edges.add(e1)\n  edges_Src[r].add(e1)\n  edges_Dst[c].add(e1)\n\nvar res = newSeq[Edge]()\n\nvar que = newHeapQueue[Edge]()\nfor e in edges:\n  que.push e\n\nvar uf = newUnionFind(H+W)\nfor i in 0..<H+W:\n  uf.pNumOf[i] = 1\n  uf.eNumOf[i] = 0\n\nwhile que.len != 0:\n  let e = que.pop()\n  if uf.same(e.src, e.dst):\n    if uf.eNumOf[uf.findInnovator(e.src)] < uf.pNumOf[uf.findInnovator(e.src)]:\n      res.add e\n      uf.eNumOf[uf.findInnovator(e.src)] += 1\n  else:\n    if uf.eNumOf[uf.findInnovator(e.src)] + uf.eNumOf[uf.findInnovator(e.dst)] < uf.pNumOf[uf.findInnovator(e.src)] + uf.pNumOf[uf.findInnovator(e.dst)]:\n      uf.unite(e.src, e.dst)\n      uf.eNumOf[uf.findInnovator(e.src)] += 1\n      res.add e\n\n#echo res\n\nvar sr = 0\nfor e in res:\n  sr += e.val\n\necho sr"
  },
  {
    "language": "Python",
    "code": "class UnionFind():\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.root = [-1]*n\n\t\tself.rank = [0]*n\n\t\tself.cycle = [False]*n\n\n\tdef find(self, x):\n\t\tif(self.root[x] < 0):\n\t\t\treturn x\n\t\telse:\n\t\t\tself.root[x] = self.find(self.root[x])\n\t\t\treturn self.root[x]\n\t\t\t\n\tdef unite(self, x, y):\n\t\tx = self.find(x)\n\t\ty = self.find(y)\n\t\tif(x == y):\n\t\t\tself.cycle[x] = True\n\t\telif(self.rank[x] > self.rank[y]):\n\t\t\tself.root[x] += self.root[y]\n\t\t\tself.cycle[x] |= self.cycle[y]\n\t\t\tself.root[y] = x\n\t\telse:\n\t\t\tself.root[y] += self.root[x]\n\t\t\tself.cycle[y] |= self.cycle[x]\n\t\t\tself.root[x] = y\n\t\t\tif(self.rank[x] == self.rank[y]):\n\t\t\t\tself.rank[y] += 1\n\n\tdef isSame(self, x, y):\n\t\treturn self.find(x) == self.find(y)\n\t\n\t#サイクルは各連結成分に一つまで\n\tdef isSafe(self, x, y):\n\t\tcx = self.cycle[self.find(x)] \n\t\tcy = self.cycle[self.find(y)]\n\t\treturn not((self.isSame(x,y) and (cx or cy)) or (cx and cy))\n\nn,h,w,*l = map(int,open(0).read().split())\ncards = sorted([(a,r-1,c-1) for r,c,a in zip(*[iter(l)]*3)])[::-1]\nuf = UnionFind(h+w)\nans = 0\n\nfor a,r,c in cards:\n\tc += h\n\tif uf.isSafe(r,c):\n\t\tuf.unite(r,c)\n\t\tans += a\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nimport heapq\nfrom operator import itemgetter\nfrom collections import deque, defaultdict, Counter\nfrom bisect import bisect_left, bisect_right\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\nMOD = 10**9 + 7\n\ndef sol():\n    N, H, W = map(int, input().split())\n\n\n    row = [[] for _ in range(H)]\n    col = [[] for _ in range(W)]\n\n    for _ in range(N):\n        r, c, a = map(int ,input().split())\n        r -= 1\n        c -= 1\n        heapq.heappush(row[r], (-a, c))\n        heapq.heappush(col[c], (-a, r))\n\n    ans = 0\n    taken = set()\n    for r in range(H):\n        while row[r]:\n            val, c = heapq.heappop(row[r])\n            if not (r, c) in taken:\n                ans -= val\n                taken.add((r, c))\n                break\n\n    for c in range(W):\n        while col[c]:\n            val, r = heapq.heappop(col[c])\n            if not (r, c) in taken:\n                ans -= val\n                taken.add((r, c))\n                break\n\n    print(ans)\n\nsol()"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import *\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\n\ndef main():\n    def get_group(k):\n        g = pd[k]\n        if g < 0:\n            return k\n        gg = get_group(g)\n        pd[k] = gg\n        return gg\n\n    def merge(j, k):\n        g1 = get_group(j)\n        g2 = get_group(k)\n        if g1 != g2:\n            d1 = -pd[g1]\n            d2 = -pd[g2]\n            if d2 > d1:\n                g1, g2 = g2, g1\n            pd[g2] = g1\n            if d1 == d2:\n                pd[g1] -= 1\n\n    hp = []\n    n, h, w = map(int, input().split())\n    pd = [-1] * (h + w + 2)  # 親(parent)と深さ(depth)。0以上は親。負の場合、そのノードが根で絶対値が深さ。\n    pd[0] = -(h + w + 2)\n    for _ in range(n):\n        r, c, a = map(int, input().split())\n        heappush(hp, [-a, r, h + c])\n    cnt = h + w\n    ans = 0\n    while cnt and hp:\n        a, r, c = heappop(hp)\n        gr = get_group(r)\n        gc = get_group(c)\n        if gr + gc == 0: continue\n        if gr == gc:\n            merge(gr, 0)\n        else:\n            merge(gr, gc)\n        ans -= a\n        cnt -= 1\n    print(ans)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import *\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\ndef main():\n    def get_group(k):\n        g = pd[k]\n        if g < 0:\n            return k\n        gg = get_group(g)\n        pd[k] = gg\n        return gg\n\n    def merge(j, k):\n        g1 = get_group(j)\n        g2 = get_group(k)\n        if g1 != g2:\n            d1 = -pd[g1]\n            d2 = -pd[g2]\n            if d2 > d1:\n                g1, g2 = g2, g1\n            pd[g2] = g1\n            if d1 == d2:\n                pd[g1] -= 1\n\n    hp = []\n    n, h, w = map(int, input().split())\n    pd = [-1] * (h + w + 2)  # 親(parent)と深さ(depth)。0以上は親。負の場合、そのノードが根で絶対値が深さ。\n    for _ in range(n):\n        r, c, a = map(int, input().split())\n        heappush(hp, [-a, r, h + c])\n    cnt = h + w\n    ans = 0\n    while cnt and hp:\n        a, r, c = heappop(hp)\n        gr = get_group(r)\n        gc = get_group(c)\n        if gr + gc == 0:\n            continue\n        if gr == gc:\n            pd[gr] = 0\n        else:\n            merge(gr, gc)\n        ans -= a\n        cnt -= 1\n    print(ans)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "N, H, W = map(int, input().split())\nr=[]\nc=[]\nw=[]\ntmp = []\nfor num in range(N):\n    a1, a2, a3=map(int, input().split())\n    r.append(a1)\n    c.append(a2)\n    w.append(a3)\n\ncount=0\nfor num in range(N):\n    tmp_list = [u for s, t, u in zip(r,c,w) if s == num]\n    if tmp_list == []:\n        continue\n    max_r = max(tmp_list)\n    if tmp_list.count(max_r) > 1:\n        indexes = [i for i,u in enumerate(tmp_list) if u == max_r]\n        \n        cs = [t for i,t in enumerate(c) if i in indexes]\n        ws = [u for s,t,u in zip(r,c,w) if t in cs and s == num]\n        index_1 = ws.index(max(ws) )\n    else:\n        index_1 = tmp_list.index(max_r)\n    w[index_1] = 0\n    count += max_r\n\ntmp_r = r\nr = c\nc = tmp_r\nfor num in range(N):\n    tmp_list = [u for s, t, u in zip(r,c,w) if s == num]\n    if tmp_list == []:\n        continue\n    max_r = max(tmp_list)\n    if tmp_list.count(max_r) > 1:\n        indexes = [i for i,u in enumerate(tmp_list) if u == max_r]\n        \n        cs = [t for i,t in enumerate(c) if i in indexes]\n        ws = [u for s,t,u in zip(r,c,w) if t in cs and s == num]\n        index_1 = ws.index(max(ws) )\n    else:\n        index_1 = tmp_list.index(max_r)\n    w[index_1] = 0\n    count += max_r\n\nprint(count)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nfrom heapq import *\ndef min_cost_flow_dijkstra(E, s, t, f):\n    INF = 1<<100\n    NN = T + 1\n    G = [[] for _ in range(NN)]\n    for a, b, cap, c in E:\n        G[a].append([b, cap, c, len(G[b])])\n        G[b].append([a, 0, -c, len(G[a])-1])\n    prevv = [-1] * NN\n    preve = [-1] * NN\n    h = [0] * NN\n    res = 0\n    while f > 0:\n        dist = [INF] * NN\n        dist[s] = 0\n        q = []\n        heappush(q, (0, s))\n        while q:\n            di, v = q.pop()\n            if dist[v] < di: continue\n            for i, (b, _cap, c, r) in enumerate(G[v]):\n                if _cap > 0 and dist[b] > dist[v] + c + h[v] - h[b]:\n                    dist[b] = dist[v] + c + h[v] - h[b]\n                    prevv[b] = v\n                    preve[b] = i\n                    heappush(q, (dist[b], b))\n        \n        \n        if dist[t] == INF:\n            return -1\n        for v in range(NN):\n            h[v] += dist[v]\n        \n        d = f\n        v = t\n        while v != s:\n            d = min(d, G[prevv[v]][preve[v]][1])\n            v = prevv[v]\n        f -= d\n        res += d * h[t]\n        v = t\n        while v != s:\n            G[prevv[v]][preve[v]][1] -= d\n            G[v][G[prevv[v]][preve[v]][3]][1] += d\n            v = prevv[v]\n    return res\n\nE = []\ninf = 1 << 17\nN, H, W = map(int, input().split())\nS, T = H+W+N, H+W+N+1\nfor i in range(H):\n    E.append((S, i, 1, 0))\nfor i in range(W):\n    E.append((S, H+i, 1, 0))\nfor i in range(N):\n    r, c, a = map(int, input().split())\n    r -= 1\n    c -= 1\n    E.append((r, H+W+i, 1, 0))\n    E.append((H+c, H+W+i, 1, 0))\n    E.append((H+W+i, T, 1, inf - a))\n\nE.append((S, T, H+W, inf))\nprint(inf * (H+W) - min_cost_flow_dijkstra(E, S, T, H+W))"
  },
  {
    "language": "Python",
    "code": "import sys\nimport heapq\n\ndef solve():\n    input = sys.stdin.readline\n    N, H, W = map(int, input().split())\n    R, C = [None] * H, [None] * W\n\n    for i in range(N):\n        r, c, a = map(int, input().split())\n        if R[r-1] == None: \n            R[r-1] = []\n            heapq.heapify(R[r-1])\n        if C[c-1] == None:\n            C[c-1] = []\n            heapq.heapify(C[c-1])\n        heapq.heappush(R[r-1], (-a, r-1, c-1, i))\n        heapq.heappush(C[c-1], (-a, r-1, c-1, i))\n    #print(R)\n    #print(C)\n    ans = 0\n    used = set()\n    for j in range(H):\n        if R[j]:\n            point, r, c, i = heapq.heappop(R[j])\n            ans += point\n            used |= {(point, r, c, i)}\n\n    for j in range(W):\n        #print(j)\n        #print(C[j])\n        if C[j] != None:\n            while C[j]:\n                point, r, c, i = heapq.heappop(C[j])\n                if (point, r, c, i) not in used:\n                    ans += point\n                    break\n    print(-1 * ans)\n\n\n\n    return 0\n\nif __name__ == \"__main__\":\n    solve()"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nsys.setrecursionlimit(10**7)\n\nimport operator\n\nN,H,W = map(int,readline().split())\nm = map(int,read().split())\nRCA = sorted(zip(m,m,m),key=operator.itemgetter(2),reverse=True)\n\nroot = list(range(H+W))\nsize = [0] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return y\n    z = find_root(y)\n    root[x] = z\n    return z\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    no_cycle[x] = no_cycle[x] and no_cycle[y]\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    answer += A\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10 ** 5)\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.table = [-1] * n\n        self.taken = [0] * n\n\n    def _root(self, x):\n        if self.table[x] < 0:\n            return x\n        else:\n            self.table[x] = self._root(self.table[x])\n            return self.table[x]\n\n    def union(self, x, y):\n        r1 = self._root(x)\n        r2 = self._root(y)\n        if r1 == r2:\n            new_root = r1\n        else:\n            d1 = self.table[r1]\n            d2 = self.table[r2]\n            if d1 <= d2:\n                self.table[r2] = r1\n                self.table[r1] += d2\n                new_root = r1\n            else:\n                self.table[r1] = r2\n                self.table[r2] += d1\n                new_root = r2\n\n        cells = -self.table[new_root]\n        taken = self.taken[new_root]\n        if cells > taken:\n            self.taken[new_root] += 1\n            return True\n        return False\n\n\nn, h, w = map(int, input().split())\nhw = h + w\ncards = []\nfor line in sys.stdin:\n    r, c, a = map(int, line.split())\n    cards.append((a, r - 1, h + c - 1))\ncards.sort(reverse=True)\n\nuft = UnionFind(hw)\nans = 0\ncnt = 0\n\nfor a, r, c in cards:\n    if uft.union(r, c):\n        ans += a\n        cnt += 1\n        if cnt >= hw:\n            break\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport operator\n\nN,H,W = map(int,readline().split())\nRCA = [int(x) for x in read().split()]\nit = iter(RCA)\nRCA = sorted(zip(it,it,it),key=operator.itemgetter(2),reverse=True)\n\nroot = list(range(H+W))\nsize = [0] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return y\n    z = find_root(y)\n    root[x] = z\n    return z\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    no_cycle[x] = (no_cycle[x] and no_cycle[y])\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    #answer += A\n\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "# sys.setrecursionlimit(10**6)\n\nN, H, W = [int(x) for x in raw_input().split(' ')]\narr = []\nfor _ in xrange(N):\n    r, c, a = [int(x) for x in raw_input().split(' ')]\n    arr.append((a, r-1, c+H-1))\narr = sorted(arr)\nans = 0\nP = [-1] * (H+W)\nC = [1] * (H+W)\n\ndef find(a):\n    if P[a] < 0: return a\n    t = find(P[a])\n    P[a] = t\n    return t\n\ndef unite(r, c):\n    fr, fc = find(r), find(c)\n    if fr == fc:  return 0\n    C[fr] = C[fc] = C[fr] + C[fc]\n    if P[fr] == P[fc]:\n        P[fc] = fr\n        P[fr] -= 1\n    elif P[fr] > P[fc]:\n        P[fc] = fr\n    else:\n        P[fr] = fc\n    \nwhile arr:\n    a, r, c = arr.pop()\n    unite(r, c)\n    fr = find(r)\n    if C[fr]:\n        ans += a\n        C[fr] -= 1\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport operator\n\nN,H,W = map(int,readline().split())\nRCA = [int(x) for x in read().split()]\nit = iter(RCA)\nRCA = sorted(zip(it,it,it),key=operator.itemgetter(2),reverse=True)\n\nroot = list(range(H+W))\nsize = [0] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return y\n    z = find_root(y)\n    root[x] = z\n    return z\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    no_cycle[x] = no_cycle[x] and no_cycle[y]\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    assert 0 <= rx < H+W\n    assert 0 <= ry < H+W\n    continue\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    answer += A\n\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "\ndef wantp(x):\n\n    wpq = []\n    while p[x] != x:\n        wpq.append(x)\n        x = p[x]\n\n    for i in wpq:\n        p[i] = x\n\n    return x\n\n\nN,H,W = map(int,input().split())\n\nans = 0\nARC = []\n\nfor i in range(N):\n\n    r,c,a = map(int,input().split())\n\n    ARC.append([a,r-1,c-1])\n\nARC.sort()\nARC.reverse()\n\nhuse = [-1] * H\nwuse = [-1] * W\n\np = [i for i in range(N)]\nlnum = [0] * N\nrank = [1] * N\n\nfor i in range(N):\n\n    na = ARC[i][0]\n    nr = ARC[i][1]\n    nc = ARC[i][2]\n\n    nowp = wantp(i)\n    if huse[nr] == -1:\n        lnum[nowp] += 1\n        huse[nr] = nowp\n\n    else:\n        hp = wantp(huse[nr])\n\n        if hp != nowp:\n\n            if rank[hp] > rank[nowp]:\n                p[nowp] = hp\n                lnum[hp] += lnum[nowp]\n\n            elif rank[hp] < rank[nowp]:\n                p[hp] = nowp\n                lnum[nowp] += lnum[hp]\n\n            else:\n                p[hp] = nowp\n                lnum[nowp] += lnum[hp]\n                rank[nowp] += 1\n\n\n    nowp = wantp(i)\n    if wuse[nc] == -1:\n        lnum[nowp] += 1\n        wuse[nc] = nowp\n\n    else:\n        wp = wantp(wuse[nc])\n\n        if wp != nowp:\n\n            if rank[wp] > rank[nowp]:\n                p[nowp] = wp\n                lnum[wp] += lnum[nowp]\n\n            elif rank[wp] < rank[nowp]:\n                p[wp] = nowp\n                lnum[nowp] += lnum[wp]\n\n            else:\n                p[wp] = nowp\n                lnum[nowp] += lnum[wp]\n                rank[nowp] += 1\n\n    \n    nowp = wantp(i)\n    if lnum[nowp] > 0:\n          ans += na\n          lnum[nowp] -= 1\n\nprint (ans)\n    \n        "
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 7)\n\nN,H,W = map(int,readline().split())\nRCA = [tuple(int(x) for x in line.split()) for line in readlines()]\n\nRCA.sort(key = lambda x: -x[2])\n\nRCA\n\nroot = list(range(H+W))\nsize = [0] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return y\n    z = find_root(y)\n    root[x] = z\n    return z\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    no_cycle[x] = no_cycle[x] and no_cycle[y]\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    answer += A\n\nprint(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "# coding: utf-8\n# Your code here!\nclass UnionFind:\n    def __init__(self, n):\n        self.parent = list(range(n)) #親ノード\n        self.size = [1]*n #グループの要素数\n        self.cycle = [0]*n\n \n    def root(self, x): #root(x): xの根ノードを返す．\n        while self.parent[x] != x:\n            self.parent[x] = self.parent[self.parent[x]]\n            x = self.parent[x]\n        return x \n \n    def merge(self, x, y): #merge(x,y): xのいる組とyのいる組をまとめる\n        x, y = self.root(x), self.root(y)\n        if x == y: return False\n        if self.size[x] < self.size[y]: x,y=y,x #xの要素数が大きいように\n        self.size[x] += self.size[y] #xの要素数を更新\n        self.parent[y] = x #yをxにつなぐ\n        self.cycle[x] = self.cycle[x]+self.cycle[y]\n        return True\n \n    def issame(self, x, y): #same(x,y): xとyが同じ組ならTrue\n        return self.root(x) == self.root(y)\n        \n    def getsize(self,x): #size(x): xのいるグループの要素数を返す\n        return self.size[self.root(x)]\n\n    def getcycle(self,x): #size(x): xのいるグループの要素数を返す\n        return self.cycle[self.root(x)]\n\n    def addcycle(self,x): #size(x): xのいるグループの要素数を返す\n        self.cycle[self.root(x)]+=1\n        return \n\nimport sys\nsys.setrecursionlimit(10**6)\nreadline = sys.stdin.readline #文字列入力のときは注意\n \n#n = int(input())\nn,h,w = [int(i) for i in readline().split()]\n#a = [int(i) for i in readline().split()]\n\nuf = UnionFind(h+w)\n\nrca = [[int(i)-1 for i in readline().split()] for i in range(n)]\n\nfrom operator import itemgetter\nrca.sort(key = itemgetter(2), reverse=True)\n\nans = 0\n#print(rca)\nfor r,c,a in rca:\n    c += h\n    a += 1\n    if uf.issame(r,c):\n        if uf.getcycle(r): continue\n        ans += a\n        uf.addcycle(r)\n    else:\n        if uf.getcycle(r)+uf.getcycle(c) >= 2: continue\n        uf.merge(r,c)\n        ans += a\n\nprint(ans)\n\n\n\n\n\n\n\n\n\n\n\n\n    "
  },
  {
    "language": "Python",
    "code": "import heapq\nN, H, W = map(int, input().split())\nA = [0] * N\nHQ = [[] for _ in range(H)]\nHL = [[0, i, 0] for i in range(H)]\nWQ = [[] for _ in range(W)]\nWL = [[0, i, 1] for i in range(W)]\nfor i in range(N):\n  r, c, a = map(int, input().split())\n  heapq.heappush(HQ[r - 1], [-a, i])\n  HL[r - 1][0] += 1\n  heapq.heappush(WQ[c - 1], [-a, i])\n  WL[c - 1][0] += 1\ncnt = 0\nQ = []\nfor hl in HL:\n  heapq.heappush(Q, hl)\nfor wl in WL:\n  heapq.heappush(Q, wl)\nwhile Q:\n  _, i, s = heapq.heappop(Q)\n  if s == 0:\n    while HQ[i]:\n      a, j = heapq.heappop(HQ[i])\n      if A[j] == 0:\n        cnt += -a\n        A[j] = 1\n        break\n  else:\n    while WQ[i]:\n      a, j = heapq.heappop(WQ[i])\n      if A[j] == 0:\n        cnt += -a\n        A[j] = 1\n        break\nprint(cnt)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\n\ndef par(a):\n    if P[a] < 0: return a\n    t = par(P[a])\n    P[a] = t\n    return t\ndef unite(a, b):\n    if par(a) == par(b): return 0\n    C[par(a)], C[par(b)] = C[par(a)] + C[par(b)], C[par(a)] + C[par(b)]\n    if P[par(b)] == P[par(a)]:\n        P[par(b)] = par(a)\n        P[par(a)] -= 1\n    elif P[par(b)] > P[par(a)]:\n        P[par(b)] = par(a)\n    else:\n        P[par(a)] = par(b)\nN, H, W = map(int, input().split())\nP = [-1 for i in range(H+W)]\nC = [1] * (H+W)\nX = []\nfor _ in range(N):\n    r, c, a = map(int, input().split())\n    X.append((a, r-1, c+H-1))\nX = sorted(X)\nans = 0\nwhile X:\n    a, r, c = X.pop()\n    unite(r, c)\n    if C[par(r)]:\n        ans += a\n        C[par(r)] -= 1\nprint(ans"
  },
  {
    "language": "Python",
    "code": "N, H, W = [int(x) for x in raw_input().split(' ')]\narr = []\nfor _ in xrange(N):\n    r, c, a = [int(x) for x in raw_input().split(' ')]\n    arr.append((a, r-1, c+H-1))\narr = sorted(arr)\nans = 0\nP = [-1] * (H+W)\nC = [1] * (H+W)\n\ndef find(a):\n    if P[a] < 0:    return a\n    t = find(P[a])\n    P[a] = t\n    return t\n\ndef unite(r, c):\n    fr, fc = find(r), find(c)\n    if fr == fc:  return 0\n    C[fr] = C[fc] = C[fr] + C[fc]\n    if P[fr] == P[fc]:\n        P[fc] = fr\n        P[fr] -= 1\n    elif P[fr] > P[fc]:\n        P[fc] = fr\n    else:\n        P[fr] = fc\n    \nwhile arr:\n    a, r, c = arr.pop()\n    unite(r, c)\n    fr = find(r)\n    if C[fr]:\n        ans += a\n        C[fr] -= 1\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\nN, H, W = map(int, input().split())\nP = [-1 for i in range(H+W)]\nC = [1] * (H+W)\narr = []\nfor _ in range(N):\n    r, c, a = map(int, input().split())\n    arr.append((a, r-1, c+H-1))\narr = sorted(arr)\n\nans = 0\ndef find(a):\n    if P[a] < 0: return a\n    t = find(P[a])\n    P[a] = t\n    return t\n\ndef unite(r, c):\n    fr, fc = find(r), find(c)\n    if fr == fc:  return 0\n    C[fr] = C[fc] = C[fr] + C[fc]\n    if P[fr] == P[fc]:\n        P[fc] = fr\n        P[fr] -= 1\n    elif P[fr] > P[fc]:\n        P[fc] = fr\n    else:\n        P[fr] = fc\n    \nwhile arr:\n    a, r, c = arr.pop()\n    unite(r, c)\n    fr = find(r)\n    if C[fr]:\n        ans += a\n        C[fr] -= 1\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport operator\n\nN,H,W = map(int,readline().split())\nRCA = [int(x) for x in read().split()]\nit = iter(RCA)\nRCA = sorted(zip(it,it,it),key=operator.itemgetter(2),reverse=True)\n\nroot = list(range(H+W))\nsize = [0] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return y\n    z = find_root(y)\n    root[x] = z\n    return z\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    no_cycle[x] = no_cycle[x] and no_cycle[y]\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    assert 0 <= x < H+W\n    assert 0 <= y < H+W\n    continue\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    answer += A\n\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import *\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\n\ndef main():\n    def get_group(k):\n        g = pd[k]\n        if g < 0:\n            return k\n        gg = get_group(g)\n        pd[k] = gg\n        return gg\n\n    def merge(j, k):\n        g1 = get_group(j)\n        g2 = get_group(k)\n        if g1 != g2:\n            d1 = -pd[g1]\n            d2 = -pd[g2]\n            if d2 > d1:\n                g1, g2 = g2, g1\n            pd[g2] = g1\n            if d1 == d2:\n                pd[g1] -= 1\n\n    hp = []\n    n, h, w = map(int, input().split())\n    pd = [-1] * (h + w + 2)  # 親(parent)と深さ(depth)。0以上は親。負の場合、そのノードが根で絶対値が深さ。\n    for _ in range(n):\n        r, c, a = map(int, input().split())\n        heappush(hp, [-a, r, h + c])\n    cnt = h + w\n    ans = 0\n    while cnt and hp:\n        a, r, c = heappop(hp)\n        gr = get_group(r)\n        gc = get_group(c)\n        if gr + gc == 0: continue\n        if gr == gc:\n            merge(gr, 0)\n        else:\n            merge(gr, gc)\n        ans -= a\n        cnt -= 1\n    print(ans)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput=sys.stdin.readline\nclass UnionFind:\n    def __init__(self,n):\n        self.par=[i for i in range(n)]\n        self.rank=[0]*n\n        self.size=[1]*n\n        self.Ecnt=[0]*n\n    def root(self,x):\n        if self.par[x]==x:\n            return x\n        else:\n            self.par[x]=self.root(self.par[x])\n            return self.par[x]\n    def union(self,x,y):\n        px=self.root(x); py=self.root(y)\n        if px!=py:\n            if self.rank[px]==self.rank[py]:\n                self.rank[px]+=1\n            elif self.rank[px]<self.rank[py]:\n                px,py=py,px\n            self.par[py]=px\n            self.size[px]+=self.size[py]\n            self.Ecnt[px]+=self.Ecnt[py]+1\n        else:\n            self.Ecnt[px]+=1\n    def same_check(self,x,y):\n        return self.root(x)==self.root(y)\n\nn,h,w=map(int,input().split())\nRCA=[]\nfor _ in range(n):\n    r,c,a=map(int,input().split())\n    r-=1\n    c+=h-1\n    RCA.append((r,c,a))\nRCA.sort(lambda x:x[2],reverse=True)\nuf=UnionFind(h+w)\nans=0\nfor r,c,a in RCA:\n    if uf.size[uf.par[r]]+uf.size[uf.par[c]]==uf.Ecnt[uf.par[r]]+uf.Ecnt[uf.par[c]]:\n        continue\n    uf.union(r,c)\n    ans+=a\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "class UnionFind():\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.root = [-1]*(n+1)\n\t\tself.rank = [0]*(n+1)\n\t\tself.cycle = [False]*(n+1)\n\n\tdef find(self, x):\n\t\tif(self.root[x] < 0):\n\t\t\treturn x\n\t\telse:\n\t\t\tself.root[x] = self.find(self.root[x])\n\t\t\treturn self.root[x]\n\t\t\t\n\tdef unite(self, x, y):\n\t\tx = self.find(x)\n\t\ty = self.find(y)\n\t\tif(x == y):\n\t\t\tself.cycle[x] = True\n\t\telif(self.rank[x] > self.rank[y]):\n\t\t\tself.root[x] += self.root[y]\n\t\t\tself.cycle[x] |= self.cycle[y]\n\t\t\tself.root[y] = x\n\t\telse:\n\t\t\tself.root[y] += self.root[x]\n\t\t\tself.cycle[y] |= self.cycle[x]\n\t\t\tself.root[x] = y\n\t\t\tif(self.rank[x] == self.rank[y]):\n\t\t\t\tself.rank[y] += 1\n\n\tdef isSame(self, x, y):\n\t\treturn self.find(x) == self.find(y)\n\t\t\n\tdef isCycle(self, x, y):\n\t\tcx = self.cycle[self.find(x)]\n\t\tcy = self.cycle[self.find(y)]\n\t\tif cx == cy == False:\n\t\t\treturn False\n\t\telif cx ^ cy:\n\t\t\treturn True\n\t\telse:\n\t\t\treturn 2\n\n\tdef size(self, x):\n\t\treturn -self.root[self.find(x)]\n\nn,h,w,*l = map(int,open(0).read().split())\ncards = sorted([(a,r,c) for r,c,a in zip(*[iter(l)]*3)])[::-1]\n\nuf = UnionFind(h+w)\nans = 0\n\nfor a,r,c in cards:\n\tc += h\n\tif not ( (uf.isSame(r,c) and uf.isCycle(r,c)) or uf.isCycle(r,c)==2 ):\n\t\tuf.unite(r,c)\n\t\tans += a\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nsys.setrecursionlimit(10**7)\n\nimport operator\n\nN,H,W = map(int,readline().split())\nm = map(int,read().split())\nRCA = sorted(zip(m,m,m),key=operator.itemgetter(2),reverse=True)\n\nroot = list(range(H+W))\nsize = [0] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return x\n    path = [x]\n    while y != root[y]:\n        path.append(y)\n        y = root[y]\n    for p in path:\n        root[p] = y\n    return y\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    no_cycle[x] = no_cycle[x] and no_cycle[y]\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    answer += A\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.size = [1] * n\n        self.rank = [0] * n\n        self.edge = [0] * n\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def is_saturated(self, x):\n        x = self.find(x)\n        return self.edge[x] == self.size[x]\n\n    def get_size(self, x):\n        return self.size[self.find(x)]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        self.edge[x] += 1\n        if x == y:\n            return\n\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n            self.size[y] += self.size[x]\n            self.edge[y] += self.edge[x]\n        else:\n            self.par[y] = x\n            self.size[x] += self.size[y]\n            self.edge[x] += self.edge[y]\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\nn, h, w = [int(item) for item in input().split()]\n\nUF = UnionFind(h+w)\narc = []\nfor i in range(n):\n    r, c, a = [int(item) for item in input().split()]\n    r -= 1; c -= 1\n    c += h\n    arc.append([a, r, c])\narc.sort(reverse=True)\n\nans = 0\nfor a, r, c in arc:\n    if not UF.is_saturated(r) or not UF.is_saturated(c):\n        UF.union(r, c)\n        ans += a\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nsys.setrecursionlimit(10**7)\n\nimport operator\n\nN,H,W = map(int,readline().split())\nm = map(int,read().split())\nRCA = sorted(zip(m,m,m),key=operator.itemgetter(2),reverse=True)\n\nroot = list(range(H+W))\nsize = [0] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(root,x):\n    y = root[x]\n    if x == y:\n        return x\n    path = [x]\n    while y != root[y]:\n        path.append(y)\n        y = root[y]\n    for p in path:\n        root[p] = y\n    return y\n\ndef merge(root,size,x,y):\n    x,y = find_root(root,x),find_root(root,y)\n    if x == y:\n        return\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    no_cycle[x] = no_cycle[x] and no_cycle[y]\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(root,x),find_root(root,y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(root,size,rx,ry)\n    answer += A\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\ndef min_cost_flow(E, s, t, f):\n    INF = 1<<100\n    NN = T+1\n    G = [[] for _ in range(NN)]\n    for a, b, cap, c in E:\n        G[a].append([b, cap, c, len(G[b])])\n        G[b].append([a, 0, -c, len(G[a])-1])\n    prevv = [-1] * NN\n    preve = [-1] * NN\n    res = 0\n    while f > 0:\n        dist = [INF] * NN\n        dist[s] = 0\n        update = 1\n        while update:\n            update = 0\n            for v in range(NN):\n                if dist[v] == INF: continue\n                for i, (b, _cap, c, r) in enumerate(G[v]):\n                    if _cap > 0 and dist[b] > dist[v] + c:\n                        dist[b] = dist[v] + c\n                        prevv[b] = v\n                        preve[b] = i\n                        update = 1\n        \n        if dist[t] == INF:\n            return -1\n\n        d = f\n        v = t\n        while v != s:\n            d = min(d, G[prevv[v]][preve[v]][1])\n            v = prevv[v]\n        f -= d\n        res += d * dist[t]\n        v = t\n        while v != s:\n            G[prevv[v]][preve[v]][1] -= d\n            G[v][G[prevv[v]][preve[v]][3]][1] += d\n            v = prevv[v]\n    \n    return res\n\nE = []\ninf = 1 << 17\nN, H, W = map(int, input().split())\nS, T = H+W+N, H+W+N+1\nfor i in range(H):\n    E.append((S, i, 1, 0))\nfor i in range(W):\n    E.append((S, H+i, 1, 0))\nfor i in range(N):\n    r, c, a = map(int, input().split())\n    r -= 1\n    c -= 1\n    E.append((r, H+W+i, 1, 0))\n    E.append((H+c, H+W+i, 1, 0))\n    E.append((H+W+i, T, 1, inf - a))\n\nE.append((S, T, H+W, inf))\nprint(inf * (H+W) - min_cost_flow(E, S, T, H+W))"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\ndef min_cost_flow(E, s, t, f):\n    INF = 1<<100\n    NN = T+1\n    G = [[] for _ in range(NN)]\n    for a, b, cap, c in E:\n        G[a].append([b, cap, c, len(G[b])])\n        G[b].append([a, 0, -c, len(G[a])-1])\n    prevv = [-1] * NN\n    preve = [-1] * NN\n    res = 0\n    while f > 0:\n        dist = [INF] * NN\n        dist[s] = 0\n        update = 1\n        while update:\n            update = 0\n            for v in range(NN):\n                if dist[v] == INF: continue\n                for i, (b, _cap, c, r) in enumerate(G[v]):\n                    if _cap > 0 and dist[b] > dist[v] + c:\n                        dist[b] = dist[v] + c\n                        prevv[b] = v\n                        preve[b] = i\n                        update = 1\n        \n        if dist[t] == INF:\n            return -1\n\n        d = f\n        v = t\n        while v != s:\n            d = min(d, G[prevv[v]][preve[v]][1])\n            v = prevv[v]\n        f -= d\n        res += d * dist[t]\n        v = t\n        while v != s:\n            G[prevv[v]][preve[v]][1] -= d\n            G[v][G[prevv[v]][preve[v]][3]][1] += d\n            v = prevv[v]\n    \n    return res\n\nE = []\ninf = 1 << 17\nN, H, W = map(int, input().split())\nS, T = H+W+N, H+W+N+1\nfor i in range(H):\n    E.append((S, i, 1, 0))\nfor i in range(W):\n    E.append((S, H+i, 1, 0))\nfor i in range(N):\n    r, c, a = map(int, input().split())\n    r -= 1\n    c -= 1\n    E.append((r, H+W+i, 1, 0))\n    E.append((H+c, H+W+i, 1, 0))\n    E.append((H+W+i, T, 1, inf - a))\n\nE.append((S, T, H+W, inf))\nprint(inf * (H+W) - min_cost_flow(E, S, T, H+W))"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**5)\nN, H, W = map(int, input().split())\nRCA = []\n\nclass UF(object):\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n\n    def root(self, v):\n        if v == self.parent[v]:\n            return v\n        else:\n            self.parent[v] = self.root(self.parent[v])\n            return self.parent[v]\n    \n    def unite(self, u, v):\n        u, v = self.root(u), self.root(v)\n        if (u == v):\n            return\n        self.parent[u] = v\n\nfor _ in range(N):\n    r, c, a = map(int, input().split())\n    r, c = r-1, c-1\n    RCA.append((a, r, c))\n\nRCA.sort(reverse=True)\nRCA = deque(RCA)\n\nuf = UF(H+W+1)  # r0, r1, ..., rH, c0, c1, ..., cW, loopflag\n\ncnt, ans = 0, 0\nwhile RCA and cnt < H+W:\n    a, r, c = RCA.popleft()\n    c += H\n    if uf.root(r) == uf.root(c):\n        if uf.root(r) == uf.root(H+W):  # loop?\n            continue\n        uf.unite(r, H+W)\n    ans += a\n    cnt += 1\n    uf.unite(r, c)\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nsys.setrecursionlimit(10**7)\n\nimport operator\n\nN,H,W = map(int,readline().split())\nm = map(int,read().split())\nRCA = sorted(zip(m,m,m),key=operator.itemgetter(2),reverse=True)\n\nroot = list(range(H+W))\nsize = [0] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return x\n    path = [x]\n    while y != root[y]:\n        path.append(y)\n        y = root[y]\n    for p in path:\n        root[p] = y\n    return y\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    size[x] += sy\n    no_cycle[x] = no_cycle[x] and no_cycle[y]\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    answer += A\n\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import *\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.readline\n\ndef main():\n    def get_group(k):\n        g = pd[k]\n        if g < 0:\n            return k\n        gg = get_group(g)\n        pd[k] = gg\n        return gg\n\n    def merge(j, k):\n        g1 = get_group(j)\n        g2 = get_group(k)\n        if g1 != g2:\n            d1 = -pd[g1]\n            d2 = -pd[g2]\n            if d2 > d1:\n                g1, g2 = g2, g1\n            pd[g2] = g1\n            if d1 == d2:\n                pd[g1] -= 1\n\n    hp = []\n    n, h, w = map(int, input().split())\n    pd = [-1] * (h + w + 2)  # 親(parent)と深さ(depth)。0以上は親。負の場合、そのノードが根で絶対値が深さ。\n    for _ in range(n):\n        r, c, a = map(int, input().split())\n        heappush(hp, [-a, r, h + c])\n    cnt = h + w\n    ans = 0\n    while cnt and hp:\n        a, r, c = heappop(hp)\n        gr = get_group(r)\n        gc = get_group(c)\n        if gr + gc == 0: continue\n        if gr == gc:\n            pd[gr] = 0\n        else:\n            merge(gr, gc)\n        ans -= a\n        cnt -= 1\n    print(ans)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\n\ndef par(a):\n    if P[a] < 0: return a\n    t = par(P[a])\n    P[a] = t\n    return t\ndef unite(a, b):\n    if par(a) == par(b): return 0\n    C[par(a)], C[par(b)] = C[par(a)] + C[par(b)], C[par(a)] + C[par(b)]\n    if P[par(b)] == P[par(a)]:\n        P[par(b)] = par(a)\n        P[par(a)] -= 1\n    elif P[par(b)] > P[par(a)]:\n        P[par(b)] = par(a)\n    else:\n        P[par(a)] = par(b)\nN, H, W = map(int, input().split())\nP = [-1 for i in range(H+W)]\nC = [1] * (H+W)\nX = []\nfor _ in range(N):\n    r, c, a = map(int, input().split())\n    X.append((a, r-1, c+H-1))\nX = sorted(X)\nans = 0\nwhile X:\n    a, r, c = X.pop()\n    unite(r, c)\n    if C[par(r)]:\n        ans += a\n        C[par(r)] -= 1\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def examA():\n    N = DI()/dec(7)\n    ans = N\n    print(N)\n    return\n\ndef examB():\n    ans = 0\n    print(ans)\n    return\n\ndef examC():\n    ans = 0\n    print(ans)\n    return\n\ndef examD():\n    N = I()\n    n = (N-1).bit_length()\n    V = [[-1]*(1<<n) for i in range(1<<n)]\n    #print(V)\n    for i in range(n):\n        b1 = 1 << i\n        b2 = 1 << (i + 1)\n        for j in range(1<<i):\n            for k in range(1<<(n-i)):\n                for l in range(1<<(n-i)):\n                    #print(i,j,k,l,j+k*b2,j+b1+l*b2)\n                    if j+k*b2>=N or j+b1+l*b2>=N:\n                        continue\n                    u,v = sorted([j+k*b2,j+b1+l*b2])\n                    #print(u,v)\n                    V[u][v-1] = i+1\n    ans = [[]for _ in range(N-1)]\n    for i in range(N-1):\n        for v in V[i]:\n            if v>=0:\n                ans[i].append(v)\n    for v in ans:\n        print(\" \".join(map(str,v)))\n    return\n\n# 解説\ndef examD2():\n    N = I()\n    ans = [[-1]*(N-1-i) for i in range(N-1)]\n    n = N.bit_length()\n    for i in range(N):\n        for j in range(i+1,N):\n            k = 0\n            while(True):\n                if i&(1<<k) != j&(1<<k):\n                    break\n                k += 1\n            #print(i,j,j-i)\n            ans[i][j-i-1] = k+1\n    for v in ans:\n        print(\" \".join(map(str,v)))\n    return\n\ndef examE():\n    ans = 0\n    print(ans)\n    return\n\ndef examF():\n    ans = 0\n    print(ans)\n    return\n\ndef test():\n    i = I()\n    li = LI()\n    lsi = LSI()\n    si = LS()\n    print(i)\n    print(li)\n    print(lsi)\n    print(si)\n    return\n\nfrom decimal import getcontext,Decimal as dec\nimport sys,bisect,itertools,heapq,math,random\nfrom copy import deepcopy\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\ndef I(): return int(input())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef DI(): return dec(input())\ndef LDI(): return list(map(dec,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nglobal mod,mod2,inf,alphabet,_ep\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\n_ep = dec(\"0.000000000001\")\nalphabet = [chr(ord('a') + i) for i in range(26)]\nalphabet_convert = {chr(ord('a') + i): i for i in range(26)}\n\ngetcontext().prec = 28\n\nsys.setrecursionlimit(10**7)\n\nif __name__ == '__main__':\n    examD2()\n\n\"\"\"\n142\n12 9 1445 0 1\nasd dfg hj o o\naidn\n\"\"\""
  },
  {
    "language": "Python",
    "code": "import sys\ninput=sys.stdin.readline\nclass UnionFind:\n    def __init__(self,n):\n        self.par=[i for i in range(n)]\n        self.rank=[0]*n\n        self.size=[1]*n\n        self.Ecnt=[0]*n\n    def root(self,x):\n        if self.par[x]==x:\n            return x\n        else:\n            self.par[x]=self.root(self.par[x])\n            return self.par[x]\n    def union(self,x,y):\n        px=self.root(x); py=self.root(y)\n        if px!=py:\n            if self.rank[px]==self.rank[py]:\n                self.rank[px]+=1\n            elif self.rank[px]<self.rank[py]:\n                px,py=py,px\n            self.par[py]=px\n            self.size[px]+=self.size[py]\n            self.Ecnt[px]+=self.Ecnt[py]+1\n        else:\n            self.Ecnt[px]+=1\n    def same_check(self,x,y):\n        return self.root(x)==self.root(y)\n\nn,h,w=map(int,input().split())\nRCA=[]\nfor _ in range(n):\n    r,c,a=map(int,input().split())\n    r-=1\n    c+=h-1\n    RCA.append((r,c,a))\nRCA.sort(lambda x:x[2],reverse=True)\nuf=UnionFind(h+w)\nans=0\nfor r,c,a in RCA:\n    if uf.same_check(r,c):\n        if uf.size[uf.par[r]]>uf.Ecnt[uf.par[r]]:\n            uf.union(r,c)\n            ans+=a\n    else:\n        if (uf.size[uf.par[r]]+uf.size[uf.par[c]])>(uf.Ecnt[uf.par[r]]+uf.Ecnt[uf.par[c]]):\n            uf.union(r,c)\n            ans+=a\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "N, H, W = [int(x) for x in raw_input().split(' ')]\narr = []\nfor _ in xrange(N):\n    r, c, a = [int(x) for x in raw_input().split(' ')]\n    arr.append((a, r-1, c+H-1))\narr = sorted(arr)\nans = 0\nP = [-1] * (H+W)\nC = [1] * (H+W)\n\ndef find(a):\n    if P[a] < 0:    return a\n    t = find(P[a])\n    P[a] = t\n    return t\n\ndef unite(r, c):\n    fr, fc = find(r), find(c)\n    if fr == fc:  return 0\n    C[fr] = C[fc] = C[fr] + C[fc]\n    if P[fr] == P[fc]:\n        P[fc] = fr\n        P[fr] -= 1\n    elif P[fr] > P[fc]:\n        P[fc] = fr\n    else:\n        P[fr] = fc\n    \nwhile arr:\n    a, r, c = arr.pop()\n    unite(r, c)\n    if C[find(r)]:\n        ans += a\n        C[find(r)] -= 1\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport operator\n\nN,H,W = map(int,readline().split())\nm = map(int,read().split())\nRCA = sorted(zip(m,m,m),key=operator.itemgetter(2),reverse=True)\n\nroot = list(range(H+W))\nsize = [0] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return y\n    z = find_root(y)\n    root[x] = z\n    return z\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    size[x] += sy\n    no_cycle[x] = no_cycle[x] and no_cycle[y]\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    answer += A\n\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport operator\n\nN,H,W = map(int,readline().split())\nm = map(int,read().split())\nRCA = sorted(zip(m,m,m),key=operator.itemgetter(2),reverse=True)\n\nroot = list(range(H+W))\nsize = [1] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return y\n    z = find_root(y)\n    root[x] = z\n    return z\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    size[x] += sy\n    no_cycle[x] = no_cycle[x] and no_cycle[y]\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    answer += A\n\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "def par(a):\n    if P[a] == a: return a\n    t = par(P[a])\n    P[a] = t\n    return t\ndef unite(a, b):\n    if par(a) != par(b): C[par(a)] += C[par(b)]\n    P[par(b)] = par(a)\n\nN, H, W = map(int, input().split())\nP = [i for i in range(H+W)]\nC = [1] * (H+W)\nX = []\nfor _ in range(N):\n    r, c, a = map(int, input().split())\n    X.append((a, r-1, c+H-1))\nX = sorted(X)\nans = 0\nwhile X:\n    a, r, c = X.pop()\n    unite(r, c)\n    if C[par(r)]:\n        ans += a\n        C[par(r)] -= 1\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import deque\ninput = sys.stdin.readline\nN, H, W = map(int, input().split())\nRCA = []\n\nclass UF(object):\n    def __init__(self, n):\n        self.parent = [i for i in range(n)]\n\n    def root(self, v):\n        if v == self.parent[v]:\n            return v\n        else:\n            self.parent[v] = self.root(self.parent[v])\n            return self.parent[v]\n    \n    def unite(self, u, v):\n        u, v = self.root(u), self.root(v)\n        if (u == v):\n            return\n        self.parent[u] = v\n\nfor _ in range(N):\n    r, c, a = map(int, input().split())\n    r, c = r-1, c-1\n    RCA.append((a, r, c))\n\nRCA.sort(reverse=True)\nRCA = deque(RCA)\n\nuf = UF(H+W+1)  # r0, r1, ..., rH, c0, c1, ..., cW, loopflag\n\ncnt, ans = 0, 0\nwhile RCA and cnt < H+W:\n    a, r, c = RCA.popleft()\n    c += H\n    if uf.root(r) == uf.root(c):\n        if uf.root(r) == uf.root(H+W):  # loop?\n            continue\n        uf.unite(r, H+W)\n    ans += a\n    cnt += 1\n    uf.unite(r, c)\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "class UnionFind():\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.root = [-1]*n\n\t\tself.rank = [0]*n\n\t\tself.cycle = [False]*n\n\n\tdef find(self, x):\n\t\tif(self.root[x] < 0):\n\t\t\treturn x\n\t\telse:\n\t\t\tself.root[x] = self.find(self.root[x])\n\t\t\treturn self.root[x]\n\t\t\t\n\tdef unite(self, x, y):\n\t\tx = self.find(x)\n\t\ty = self.find(y)\n\t\tif(x == y):\n\t\t\tself.cycle[x] = True\n\t\telif(self.rank[x] > self.rank[y]):\n\t\t\tself.root[x] += self.root[y]\n\t\t\tself.cycle[x] |= self.cycle[y]\n\t\t\tself.root[y] = x\n\t\telse:\n\t\t\tself.root[y] += self.root[x]\n\t\t\tself.cycle[y] |= self.cycle[x]\n\t\t\tself.root[x] = y\n\t\t\tif(self.rank[x] == self.rank[y]):\n\t\t\t\tself.rank[y] += 1\n\n\tdef isSame(self, x, y):\n\t\treturn self.find(x) == self.find(y)\n\t\n\t#サイクルは各連結成分に一つまで\n\tdef isSafe(self, x, y):\n\t\tcx = self.cycle[self.find(x)] \n\t\tcy = self.cycle[self.find(y)]\n\t\treturn not((self.isSame(x,y) and (cx or cy)) or (cx and cy))\n\nn,h,w,*l = map(int,open(0).read().split())\ncards = sorted([(a,r-1,c-1) for r,c,a in zip(*[iter(l)]*3)])[::-1]\nuf = UnionFind(h+w)\nans = 0\n\nfor a,r,c in cards:\n\tc += h\n\tif uf.isSafe(r,c):\n\t\tuf.unite(r,c)\n\t\tans += a\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\n\ndef par(a):\n    if P[a] == a: return a\n    t = par(P[a])\n    P[a] = t\n    return t\ndef unite(a, b):\n    if par(a) != par(b): C[par(a)] += C[par(b)]\n    P[par(b)] = par(a)\n\nN, H, W = map(int, input().split())\nP = [i for i in range(H+W)]\nC = [1] * (H+W)\nX = []\nfor _ in range(N):\n    r, c, a = map(int, input().split())\n    X.append((a, r-1, c+H-1))\nX = sorted(X)\nans = 0\nwhile X:\n    a, r, c = X.pop()\n    unite(r, c)\n    if C[par(r)]:\n        ans += a\n        C[par(r)] -= 1\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "sys.setrecursionlimit(10**6)\n\nN, H, W = [int(x) for x in raw_input().split(' ')]\narr = []\nfor _ in xrange(N):\n    r, c, a = [int(x) for x in raw_input().split(' ')]\n    arr.append((a, r-1, c+H-1))\narr = sorted(arr)\nans = 0\nP = [-1] * (H+W)\nC = [1] * (H+W)\n\ndef find(a):\n    if P[a] < 0: return a\n    t = find(P[a])\n    P[a] = t\n    return t\n\ndef unite(r, c):\n    fr, fc = find(r), find(c)\n    if fr == fc:  return 0\n    C[fr] = C[fc] = C[fr] + C[fc]\n    if P[fr] == P[fc]:\n        P[fc] = fr\n        P[fr] -= 1\n    elif P[fr] > P[fc]:\n        P[fc] = fr\n    else:\n        P[fr] = fc\n    \nwhile arr:\n    a, r, c = arr.pop()\n    unite(r, c)\n    fr = find(r)\n    if C[fr]:\n        ans += a\n        C[fr] -= 1\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport operator\n\nN,H,W = map(int,readline().split())\nm = map(int,read().split())\nRCA = sorted(zip(m,m,m),key=operator.itemgetter(2),reverse=True)\n\nroot = list(range(H+W))\nsize = [0] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    path = []\n    while True:\n        y = root[x]\n        if x == y:\n            break\n        path.append(x)\n        x = y\n    for p in path:\n        root[p] = x\n    return root[x]\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    no_cycle[x] = no_cycle[x] and no_cycle[y]\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    answer += A\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "N, H, W = [int(x) for x in raw_input().split(' ')]\narr = []\nfor _ in xrange(N):\n    r, c, a = [int(x) for x in raw_input().split(' ')]\n    arr.append((a, r-1, c+H-1))\narr = sorted(arr)\nans = 0\nP = [-1] * (H+W)\nC = [1] * (H+W)\n\ndef find(a):\n    if P[a] < 0:    return a\n    t = find(P[a])\n    P[a] = t\n    return t\n\ndef unite(a, b):\n    if par(a) == par(b): return 0\n    C[par(a)], C[par(b)] = C[par(a)] + C[par(b)], C[par(a)] + C[par(b)]\n    if P[par(b)] == P[par(a)]:\n        P[par(b)] = par(a)\n        P[par(a)] -= 1\n    elif P[par(b)] > P[par(a)]:\n        P[par(b)] = par(a)\n    else:\n        P[par(a)] = par(b)\n    \nwhile arr:\n    a, r, c = arr.pop()\n    unite(r, c)\n    if C[find(r)]:\n        ans += a\n        C[find(r)] -= 1\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport operator\n\nN,H,W = map(int,readline().split())\nm = map(int,read().split())\nRCA = sorted(zip(m,m,m),key=operator.itemgetter(2),reverse=True)\n\nroot = list(range(H+W))\nsize = [1] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return y\n    z = find_root(y)\n    root[x] = z\n    return z\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    size[x] += sy\n    no_cycle[x] = no_cycle[x] and no_cycle[y]\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    answer += A\n\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "class UnionFindVerSize():\n    def __init__(self, N):\n        self._parent = [n for n in range(0, N)]\n        self._size = [1] * N\n        self._edge = [0] * N\n\n    def find_root(self, x):\n        if self._parent[x] == x: return x\n        self._parent[x] = self.find_root(self._parent[x])\n        return self._parent[x]\n\n    def unite(self, x, y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx == gy:\n            self._edge[gx] += 1\n            return\n\n        if self._size[gx] < self._size[gy]:\n            self._parent[gx] = gy\n            self._size[gy] += self._size[gx]\n            self._edge[gy] += self._edge[gx]+1\n        else:\n            self._parent[gy] = gx\n            self._size[gx] += self._size[gy]\n            self._edge[gx] += self._edge[gy]+1\n\n    def get_size(self, x):\n        return self._size[self.find_root(x)]\n\n    def is_same_group(self, x, y):\n        return self.find_root(x) == self.find_root(y)\n\n    def calc_group_num(self):\n        N = len(self._parent)\n        ans = 0\n        for i in range(N):\n            if self.find_root(i) == i:\n                ans += 1\n        return ans\n\n    def check(self,x,y):\n        gx = self.find_root(x)\n        gy = self.find_root(y)\n        if gx==gy:\n            return  self._size[gx]>=self._edge[gx]+1\n        else:\n            nv=self._size[gx]+self._size[gy]\n            ne=self._edge[gx]+self._edge[gy]+1\n            return nv>=ne\n\nimport sys\n\ninput=sys.stdin.readline\n\nN,H,W=map(int,input().split())\ncard=[]\nfor i in range(N):\n    r,c,a=map(int,input().split())\n    card.append((a,r-1,c-1))\n\ncard.sort()\n\nuf=UnionFindVerSize(H+W)\nans=0\nwhile card:\n    val,r,c=card.pop()\n    if uf.check(r,H+c):\n        uf.unite(r,H+c)\n        ans+=val\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 7)\n\nN,H,W = map(int,readline().split())\nRCA = [tuple(int(x) for x in line.split()) for line in readlines()]\n\nRCA.sort(key = lambda x: -x[2])\n\nRCA\n\nroot = list(range(H+W))\nsize = [0] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return y\n    z = find_root(y)\n    root[x] = z\n    return z\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    no_cycle[x] = no_cycle[x] and no_cycle[y]\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    answer += A\n\nprint(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\n\ndef par(a):\n    if P[a] < 0: return a\n    t = par(P[a])\n    P[a] = t\n    return t\ndef unite(a, b):\n    if par(a) == par(b): return 0\n    C[par(a)], C[par(b)] = C[par(a)] + C[par(b)], C[par(a)] + C[par(b)]\n    if P[par(b)] == P[par(a)]:\n        P[par(b)] = par(a)\n        P[par(a)] -= 1\n    elif P[par(b)] > P[par(a)]:\n        P[par(b)] = par(a)\n    else:\n        P[par(a)] = par(b)\nN, H, W = map(int, input().split())\nP = [-1 for i in range(H+W)]\nC = [1] * (H+W)\nX = []\nfor _ in range(N):\n    r, c, a = map(int, input().split())\n    X.append((a, r-1, c+H-1))\nX = sorted(X)\nans = 0\nwhile X:\n    a, r, c = X.pop()\n    unite(r, c)\n    if C[par(r)]:\n        ans += a\n        C[par(r)] -= 1\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "#!usr/bin/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n    m,d = LI()\n    ans = 0\n    for i in range(1,m+1):\n        for j in range(1,d+1):\n            d1 = j%10\n            d2 = j//10\n            if d1 >= 2 and d2 >= 2 and d1*d2 == i:\n                ans += 1\n    print(ans)\n    return\n\n#B\ndef B():\n    def add(i):\n        while i <= m:\n            bit[i] += 1\n            i += i&-i\n\n    def sum(i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i&-i\n        return res\n\n    n,k = LI()\n    m = 2000\n    a = LI()\n    bit = [0]*(m+1)\n    ans = 0\n    for i in range(n):\n        ans += (i-sum(a[i]))*k\n        add(a[i])\n    inv = pow(2,mod-2,mod)\n    for i in range(n):\n        ans += sum(a[i]-1)*k*(k-1)*inv%mod\n    print(ans%mod)\n    return\n\n#C\ndef C():\n    n = I()\n    s = S()\n    if \"W\" in (s[0],s[-1]):\n        print(0)\n        return\n    d = [0]\n    for i in range(1,2*n):\n        if s[i] == s[i-1]:\n            d.append(1-d[-1])\n        else:\n            d.append(d[-1])\n    if sum(d) != n:\n        print(0)\n        return\n    ans = 1\n    s = 0\n    for i in d:\n        if not i:\n            s += 1\n        else:\n            ans *= s\n            s -= 1\n            ans %= mod\n    for i in range(1,n+1):\n        ans *= i\n        ans %= mod\n    print(ans)\n    return\n\n#D\ndef D():\n    n = I()\n    m = n.bit_length()\n    v = [[0]*n for i in range(n)]\n    for i in range(n):\n        for j in range(n):\n            k = i^j\n            for l in range(m):\n                if k&(1<<l):\n                    v[i][j] = l+1\n                    break\n    for i in range(n-1):\n        print(*v[i][i+1:])\n    return\n\n#E\ndef E():\n    def root(x):\n        if par[x] == x:\n            return x\n        par[x] = root(par[x])\n        return par[x]\n\n    def unite(x,y):\n        x = root(x)\n        y = root(y)\n        if rank[x] < rank[y]:\n            par[x] = y\n            s[y] += s[x]\n            e[y] += e[x]+1\n        else:\n            par[y] = x\n            s[x] += s[y]\n            e[x] += e[y]+1\n            if rank[x] == rank[y]:\n                rank[x] += 1\n\n    n,h,w = LI()\n    v = []\n    m = h+w\n    for i in range(n):\n        r,c,a = LI()\n        r -= 1\n        c += h-1\n        v.append((a,r,c))\n    v.sort(key = lambda x:-x[0])\n    par = [i for i in range(m)]\n    rank = [0]*m\n    s = [1]*m\n    e = [0]*m\n    ans = 0\n    for a,x,y in v:\n        rx,ry = root(x), root(y)\n        if rx == ry:\n            if e[rx]+1 <= s[rx]:\n                ans += a\n                e[rx] += 1\n        else:\n            if e[rx]+e[ry]+1 <= s[rx]+s[ry]:\n                ans += a\n                unite(x,y)\n    print(ans)\n    return\n\n#F\ndef F():\n\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    E()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nimport operator\n\nN,H,W = map(int,readline().split())\nRCA = [tuple(int(x) for x in line.split()) for line in readlines()]\nRCA.sort(key = operator.itemgetter(2), reverse=True)\n\nroot = list(range(H+W))\nsize = [0] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return y\n    z = find_root(y)\n    root[x] = z\n    return z\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    no_cycle[x] = no_cycle[x] and no_cycle[y]\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    answer += A\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\n\ndef par(a):\n    if P[a] < 0: return a\n    t = par(P[a])\n    P[a] = t\n    return t\ndef unite(a, b):\n    if par(a) == par(b): return 0\n    C[par(a)], C[par(b)] = C[par(a)] + C[par(b)], C[par(a)] + C[par(b)]\n    if P[par(b)] == P[par(a)]:\n        P[par(b)] = par(a)\n        P[par(a)] -= 1\n    elif P[par(b)] > P[par(a)]:\n        P[par(b)] = par(a)\n    else:\n        P[par(a)] = par(b)\nN, H, W = map(int, input().split())\nP = [-1 for i in range(H+W)]\nC = [1] * (H+W)\nX = []\nfor _ in range(N):\n    r, c, a = map(int, input().split())\n    X.append((a, r-1, c+H-1))\nX = sorted(X)\nans = 0\nwhile X:\n    a, r, c = X.pop()\n    unite(r, c)\n    if C[par(r)]:\n        ans += a\n        C[par(r)] -= 1\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "class UnionFindNode:\n    def __init__(self, group_id, parent=None, value=None):\n        self.group_id_ = group_id\n        self.parent_ = parent\n        self.value = value\n        self.rank_ = 1\n        self.member_num_ = 1\n        self.enum = 0\n\n    def is_root(self):\n        return not self.parent_\n\n    def root(self):\n        parent = self\n        while not parent.is_root():\n            parent = parent.parent_\n            self.parent_ = parent\n        return parent\n\n    def find(self):\n        root = self.root()\n        return root.group_id_\n\n    def rank(self):\n        root = self.root()\n        return root.rank_\n\n    def unite(self, unite_node):\n        root = self.root()\n        unite_root = unite_node.root()\n        if not self.check(unite_node):\n            return False\n        if root.group_id_ != unite_root.group_id_:\n            if root.rank() > unite_root.rank():\n                unite_root.parent_ = root\n                root.rank_ = max(root.rank_, unite_root.rank_ + 1)\n                root.member_num_ = root.member_num_ + unite_root.member_num_\n                root.enum = root.enum + unite_root.enum + 1\n            else:\n                root.parent_ = unite_root\n                unite_root.rank_ = max(root.rank_ + 1, unite_root.rank_)\n                unite_root.member_num_ = root.member_num_ + unite_root.member_num_\n                unite_root.enum = root.enum + unite_root.enum + 1\n        else:\n            root.enum += 1\n        return True\n\n\n    def check(self, unite_node):\n        root = self.root()\n        unite_root = unite_node.root()\n        if root.group_id_ == unite_root.group_id_:\n            if root.enum < root.member_num_:\n                return True\n        else:\n            if root.member_num_ + unite_root.member_num_ > root.enum + unite_root.enum:\n                return True\n        return False\n\n\nif __name__ == \"__main__\":\n    N,H,W=[int(i) for i in input().strip().split(\" \")]\n    node_list = [UnionFindNode(i) for i in range(H+W)]\n    import sys\n    es = []\n    for line in sys.stdin:\n        es.append(tuple(int(i) for i in line.strip().split(\" \")))\n    es = sorted(es, key=lambda x:x[2])\n    r = 0\n    for e in es[::-1]:\n        if node_list[e[0]-1].unite(node_list[e[1]+H-1]):\n            r += e[2]\n    print(r)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nsys.setrecursionlimit(10**7)\n\nimport operator\n\nN,H,W = map(int,readline().split())\nm = map(int,read().split())\nRCA = sorted(zip(m,m,m),key=operator.itemgetter(2),reverse=True)\n\nroot = list(range(H+W))\nsize = [0] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    if x == root[x]:\n        return x\n    path = []\n    while True:\n        y = root[x]\n        if x == y:\n            break\n        path.append(x)\n        x = y\n    for p in path:\n        root[p] = x\n    return root[x]\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    no_cycle[x] = no_cycle[x] and no_cycle[y]\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    answer += A\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport operator\n\nN,H,W = map(int,readline().split())\nRCA = [int(x) for x in read().split()]\nit = iter(RCA)\nRCA = sorted(zip(it,it,it),key=operator.itemgetter(2),reverse=True)\n\nroot = list(range(H+W+100))\nsize = [0] * (H+W+100)\nno_cycle = [True] * (H+W+100)\n\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return y\n    z = find_root(y)\n    root[x] = z\n    return z\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    no_cycle[x] = (no_cycle[x] and no_cycle[y])\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    answer += A\n\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n    def __init__(self, n):\n        self.par = [i for i in range(n)]\n        self.size = [1] * n\n        self.rank = [0] * n\n        self.edge = [0] * n\n\n    def find(self, x):\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def is_saturated(self, x):\n        x = self.find(x)\n        return self.edge[x] == self.size[x]\n\n    def get_size(self, x):\n        return self.size[self.find(x)]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        self.edge[x] += 1\n        if x == y:\n            return\n\n        if self.rank[x] < self.rank[y]:\n            self.par[x] = y\n            self.size[y] += self.size[x]\n            self.edge[y] += self.edge[x]\n        else:\n            self.par[y] = x\n            self.size[x] += self.size[y]\n            self.edge[x] += self.edge[y]\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n\nn, h, w = [int(item) for item in input().split()]\n\nUF = UnionFind(h+w)\narc = []\nfor i in range(n):\n    r, c, a = [int(item) for item in input().split()]\n    r -= 1; c -= 1\n    c += h\n    arc.append([a, r, c])\narc.sort(reverse=True)\n\nans = 0\nfor a, r, c in arc:\n    if not UF.is_saturated(r) or not UF.is_saturated(c):\n        UF.union(r, c)\n        ans += a\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import *\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\n\ndef main():\n    def get_group(k):\n        g = ps[k]\n        if g < 0:\n            return k\n        gg = get_group(g)\n        ps[k] = gg\n        return gg\n\n    def merge(j, k):\n        g1 = get_group(j)\n        g2 = get_group(k)\n        if g1 != g2:\n            s1 = -ps[g1]\n            s2 = -ps[g2]\n            if s2 > s1:\n                g1, g2 = g2, g1\n            ps[g1] = -(s1 + s2)\n            ps[g2] = g1\n\n    hp = []\n    n, h, w = map(int, input().split())\n    ps = [-1] * (h + w + 2)  # 親(parent)と大きさ(size)。0以上は親のノード。負の場合、そのノードが根で絶対値が大きさ。\n    for _ in range(n):\n        r, c, a = map(int, input().split())\n        heappush(hp, [-a, r, h + c])\n    cnt = h + w\n    ans = 0\n    while cnt and hp:\n        a, r, c = heappop(hp)\n        gr = get_group(r)\n        gc = get_group(c)\n        if gr + gc == 0:\n            continue\n        if gr == gc:\n            ps[gr] = 0\n        else:\n            merge(gr, gc)\n        ans -= a\n        cnt -= 1\n    print(ans)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nsys.setrecursionlimit(10 ** 7)\nimport operator\n\nN,H,W = map(int,readline().split())\nRCA = [tuple(int(x) for x in line.split()) for line in readlines()]\n\nRCA.sort(key = operator.itemgetter(2), reverse=True)\n\nroot = list(range(H+W))\nsize = [0] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return y\n    z = find_root(y)\n    root[x] = z\n    return z\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    no_cycle[x] = no_cycle[x] and no_cycle[y]\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    answer += A\n\nprint(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "from heapq import *\ndef min_cost_flow_dijkstra(E, s, t, f):\n    INF = 1<<100\n    NN = T + 1\n    G = [[] for _ in range(NN)]\n    for a, b, cap, c in E:\n        G[a].append([b, cap, c, len(G[b])])\n        G[b].append([a, 0, -c, len(G[a])-1])\n    prevv = [-1] * NN\n    preve = [-1] * NN\n    h = [0] * NN\n    res = 0\n    while f > 0:\n        dist = [INF] * NN\n        dist[s] = 0\n        q = []\n        heappush(q, (0, s))\n        while q:\n            di, v = q.pop()\n            if dist[v] < di: continue\n            for i, (b, _cap, c, r) in enumerate(G[v]):\n                if _cap > 0 and dist[b] > dist[v] + c + h[v] - h[b]:\n                    dist[b] = dist[v] + c + h[v] - h[b]\n                    prevv[b] = v\n                    preve[b] = i\n                    heappush(q, (dist[b], b))\n        \n        \n        if dist[t] == INF:\n            return -1\n        for v in range(NN):\n            h[v] += dist[v]\n        \n        d = f\n        v = t\n        while v != s:\n            d = min(d, G[prevv[v]][preve[v]][1])\n            v = prevv[v]\n        f -= d\n        res += d * h[t]\n        v = t\n        while v != s:\n            G[prevv[v]][preve[v]][1] -= d\n            G[v][G[prevv[v]][preve[v]][3]][1] += d\n            v = prevv[v]\n    return res\n\nE = []\ninf = 1 << 17\nN, H, W = map(int, input().split())\nS, T = H+W+N, H+W+N+1\nfor i in range(H):\n    E.append((S, i, 1, 0))\nfor i in range(W):\n    E.append((S, H+i, 1, 0))\nfor i in range(N):\n    r, c, a = map(int, input().split())\n    r -= 1\n    c -= 1\n    E.append((r, H+W+i, 1, 0))\n    E.append((H+c, H+W+i, 1, 0))\n    E.append((H+W+i, T, 1, inf - a))\n\nE.append((S, T, H+W, inf))\nprint(inf * (H+W) - min_cost_flow_dijkstra(E, S, T, H+W))"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(10 ** 5)\n\n\nclass UnionFind:\n    def __init__(self, n):\n        self.table = [-1] * n\n        self.taken = [0] * n\n\n    def _root(self, x):\n        if self.table[x] < 0:\n            return x\n        else:\n            self.table[x] = self._root(self.table[x])\n            return self.table[x]\n\n    def union(self, x, y):\n        r1 = self._root(x)\n        r2 = self._root(y)\n        if r1 == r2:\n            new_root = r1\n        else:\n            d1 = self.table[r1]\n            d2 = self.table[r2]\n            if d1 <= d2:\n                self.table[r2] = r1\n                self.table[r1] += d2\n                self.taken[r1] += self.taken[r2]\n                new_root = r1\n            else:\n                self.table[r1] = r2\n                self.table[r2] += d1\n                self.taken[r2] += self.taken[r1]\n                new_root = r2\n\n        cells = -self.table[new_root]\n        taken = self.taken[new_root]\n        if cells > taken:\n            self.taken[new_root] += 1\n            return True\n        return False\n\n\nn, h, w = map(int, input().split())\nhw = h + w\ncards = []\nfor line in sys.stdin:\n    r, c, a = map(int, line.split())\n    cards.append((a, r - 1, h + c - 1))\ncards.sort(reverse=True)\n\nuft = UnionFind(hw)\nans = 0\n\nfor a, r, c in cards:\n    if uft.union(r, c):\n        ans += a\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nimport bisect\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nimport sys\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor\nfrom operator import mul\nfrom functools import reduce\n\n\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 13\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 1000000007\n\n\n\nclass UnionFind:\n    def __init__(self, n):\n        # 負  : 根であることを示す。絶対値はランクを示す\n        # 非負: 根でないことを示す。値は親を示す\n        self.table = [-1] * n\n        self.size = [1] * n\n        self.cycle = [0] * n\n        self.group_num = n\n\n    def root(self, x):\n        if self.table[x] < 0:\n            return x\n        else:\n            self.table[x] = self.root(self.table[x])\n            return self.table[x]\n\n    def is_same(self, x, y):\n        return self.root(x) == self.root(y)\n\n    def get_size(self, x):\n        return self.size[self.root(x)]\n\n    def unite(self, x, y):\n        r1 = self.root(x)\n        r2 = self.root(y)\n        if r1 == r2:\n            return\n        # ランクの取得\n        d1 = self.table[r1]\n        d2 = self.table[r2]\n        if d1 <= d2:\n            self.table[r2] = r1\n            self.size[r1] += self.size[r2]\n            self.cycle[r1] += self.cycle[r2]\n            if d1 == d2:\n                self.table[r1] -= 1\n        else:\n            self.table[r1] = r2\n            self.size[r2] += self.size[r1]\n            self.cycle[r2] += self.cycle[r1]\n        self.group_num -= 1\n\n\n    def get_cycle(self, x):\n        return self.cycle[self.root(x)]\n\n    def add_cycle(self, x):\n        self.cycle[self.root(x)] += 1\n        return\n\n\nn, h, w = LI()\nuf = UnionFind(h + w)\nans = 0\nrca = sorted(LIR(n), key=lambda x:x[2], reverse=True)\nfor r, c, a in rca:\n    r -= 1; c -= 1\n    if uf.is_same(r, h + c):\n        if uf.get_cycle(r):\n            continue\n        else:\n            uf.add_cycle(r)\n            ans += a\n    else:\n        if uf.get_cycle(uf.root(r)) and uf.get_cycle(uf.root(h + c)):\n            continue\n        else:\n            uf.unite(r, h + c)\n            ans += a\n\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nN,H,W = map(int,readline().split())\nRCA = [tuple(int(x) for x in line.split()) for line in readlines()]\nRCA.sort(key = lambda x:-x[2])\n\nroot = list(range(H+W))\nsize = [0] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return y\n    z = find_root(y)\n    root[x] = z\n    return z\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    no_cycle[x] = no_cycle[x] and no_cycle[y]\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    answer += A\n\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport operator\n\nN,H,W = map(int,readline().split())\nRCA = [int(x) for x in read().split()]\nit = iter(RCA)\nRCA = sorted(zip(it,it,it),key=operator.itemgetter(2),reverse=True)\n\nroot = list(range(H+W))\nsize = [0] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return y\n    z = find_root(y)\n    root[x] = z\n    return z\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    no_cycle[x] = (no_cycle[x] and no_cycle[y])\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        #merge(rx,ry)\n    answer += A\n\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10**6)\n\ndef par(a):\n    if P[a] == a: return a\n    t = par(P[a])\n    P[a] = t\n    return t\ndef unite(a, b):\n    if par(a) != par(b): C[par(a)] += C[par(b)]\n    P[par(b)] = par(a)\n\nN, H, W = map(int, input().split())\nP = [i for i in range(H+W)]\nC = [1] * (H+W)\nX = []\nfor _ in range(N):\n    r, c, a = map(int, input().split())\n    X.append((a, r-1, c+H-1))\nX = sorted(X)\nans = 0\nwhile X:\n    a, r, c = X.pop()\n    unite(r, c)\n    if C[par(r)]:\n        ans += a\n        C[par(r)] -= 1\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\nn,h,w = list(map(int, input().split()))\nfrom collections import defaultdict\nns = defaultdict(list)\nfor i in range(n):\n    r,c,a = list(map(int, input().split()))\n    r -= 1; c -= 1\n    c += h\n    ns[r].append((a,c))\n    ns[c].append((a,r))\nclass UnionFindTree:\n    def __init__(self, n):\n        self.n = n\n        self.parent = list(range(n))\n        self.size = [1] * n\n        self.es = [0]*n\n\n    def root(self, i):\n        inter = set()\n        while self.parent[i]!=i:\n            inter.add(i)\n            i = self.parent[i]\n        r = i\n        for i in inter:\n            self.parent[i] = r\n        return r\n\n    def connect(self, i, j):\n        ri = self.root(i)\n        rj = self.root(j)\n        if ri==rj:\n            self.es[ri] += 1\n            return\n        if self.size[ri]<self.size[rj]:\n            self.parent[ri] = rj\n            self.size[rj] += self.size[ri]\n            self.es[rj] += self.es[ri] + 1\n        else:\n            self.parent[rj] = ri\n            self.size[ri] += self.size[rj]\n            self.es[ri] += self.es[rj] + 1\n\ndef selectEdge(ns):\n    \"\"\"各頂点に1本以下の接続枝を割り当てて、重み最大化\n    \"\"\"\n    from heapq import heappop as hpp, heappush as hp\n    q = []\n    for u in ns.keys():\n        for a,v in ns[u]:\n            if u<v:\n                hp(q, (-a,(u,v)))\n    # 辺を選択できる = 選択した場合の連結成分において頂点数>=枝数\n    uf = UnionFindTree(h+w)\n    ans = 0\n    while q:\n        a, (u,v) = hpp(q)\n        a *= -1\n        ru = uf.root(u)\n        rv = uf.root(v)\n        if ru==rv and uf.es[ru]<uf.size[ru]:\n            uf.connect(u,v)\n            ans += a\n        elif ru!=rv and (uf.es[ru]+uf.es[rv]+1) <= (uf.size[ru]+uf.size[rv]):\n            uf.connect(u,v)\n            ans += a\n    return ans,uf\nans,uf = selectEdge(ns)\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nn,h,w= map(int, input().split())\narr = [[[]] * w for i in range(h)]\nprint(arr)\nfor i in range(n):\n  r,c,a = map(int, input().split())\n  arr[r-1][c-1].append(a)\n  \nres = 0\nfor i in range(h):\n  max_ind = 0\n  max_n = 0\n  for j in range(w):\n    if len(arr[i][j]) == 0:\n      continue\n    ind = arr[i][j].index(max(arr[i][j]))\n    if max_n < arr[i][j][ind]:\n      max_j = j\n      max_ind = ind\n      max_n = arr[i][j][ind]\n      \n  res += arr[i][max_j].pop(max_ind)\n  \nfor j in range(w):\n  max_ind = 0\n  max_n = 0\n  for i in range(h):\n    if len(arr[i][j]) == 0:\n      continue\n    ind = arr[i][j].index(max(arr[i][j]))\n    if max_n < arr[i][j][ind]:\n      max_i = i\n      max_ind = ind\n      max_n = arr[i][j][ind]\n      \n  res += arr[max_i][j].pop(max_ind)\n\nprint(res)"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\n\nn, h, w = map(int, input().split())\ninfo = []\nrow_pq = [[] for i in range(h)]\ncol_pq = [[] for i in range(w)]\nfor i in range(n):\n    r, c, a = map(int, input().split())\n    info.append((r-1, c-1, a))\n    heappush(row_pq[r-1], (-a, i))\n    heappush(col_pq[c-1], (-a, i))\n\ncards = set()\nans = 0\nfor i in range(h):\n    while row_pq[i]:\n        a, idx = heappop(row_pq[i])\n        a *= -1\n        if len(col_pq[info[idx][1]]) == 1:\n            continue\n\n        if idx not in cards:\n            cards.add(idx)\n            # print(\"row\", i, a, idx)\n            ans += a\n            break\n\nfor j in range(w):\n    while col_pq[j]:\n        a, idx = heappop(col_pq[j])\n        a *= -1\n        if idx not in cards:\n            cards.add(idx)\n            ans += a\n            # print(\"col\", j, a, idx)\n            break\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport operator\n\nN,H,W = map(int,readline().split())\nRCA = [int(x) for x in read().split()]\nit = iter(RCA)\nRCA = sorted(zip(it,it,it),key=operator.itemgetter(2),reverse=True)\n\nroot = list(range(H+W))\nsize = [0] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return y\n    z = find_root(y)\n    root[x] = z\n    return z\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    no_cycle[x] = no_cycle[x] and no_cycle[y]\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    answer += A\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "sys.setrecursionlimit(10**6)\n\nN, H, W = [int(x) for x in raw_input().split(' ')]\narr = []\nfor _ in xrange(N):\n    r, c, a = [int(x) for x in raw_input().split(' ')]\n    arr.append((a, r-1, c+H-1))\narr = sorted(arr)\nans = 0\nP = [-1] * (H+W)\nC = [1] * (H+W)\n\ndef find(a):\n    if P[a] < 0:    return a\n    t = find(P[a])\n    P[a] = t\n    return t\n\ndef unite(r, c):\n    fr, fc = find(r), find(c)\n    if fr == fc:  return 0\n    C[fr] = C[fc] = C[fr] + C[fc]\n    if P[fr] == P[fc]:\n        P[fc] = fr\n        P[fr] -= 1\n    elif P[fr] > P[fc]:\n        P[fc] = fr\n    else:\n        P[fr] = fc\n    \nwhile arr:\n    a, r, c = arr.pop()\n    unite(r, c)\n    fr = find(r)\n    if C[fr]:\n        ans += a\n        C[fr] -= 1\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport operator\n\nN,H,W = map(int,readline().split())\ngen = (int(x) for x in read().split())\nRCA = sorted(zip(gen,gen,gen),key=operator.itemgetter(2),reverse=True)\n\nroot = list(range(H+W))\nsize = [0] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return y\n    z = find_root(y)\n    root[x] = z\n    return z\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    no_cycle[x] = no_cycle[x] and no_cycle[y]\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    answer += A\n\nprint(answer)"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport operator\n\nN,H,W = map(int,readline().split())\nRCA = [int(x) for x in read().split()]\nit = iter(RCA)\nRCA = sorted(zip(it,it,it),key=operator.itemgetter(2),reverse=True)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**6)\nN, H, W = map(int, input().split())\nP = [-1 for i in range(H+W)]\nC = [1] * (H+W)\narr = []\nfor _ in range(N):\n    r, c, a = map(int, input().split())\n    arr.append((a, r-1, c+H-1))\narr = sorted(arr)\n\n\ndef find(a):\n    if P[a] < 0: return a\n    t = find(P[a])\n    P[a] = t\n    return t\n\ndef unite(r, c):\n    fr, fc = find(r), find(c)\n    if fr == fc:  return 0\n    C[fr] = C[fc] = C[fr] + C[fc]\n    if P[fr] == P[fc]:\n        P[fc] = fr\n        P[fr] -= 1\n    elif P[fr] > P[fc]:\n        P[fc] = fr\n    else:\n        P[fr] = fc\n    \nwhile arr:\n    a, r, c = arr.pop()\n    unite(r, c)\n    fr = find(r)\n    if C[fr]:\n        ans += a\n        C[fr] -= 1\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom heapq import *\n\ninput = sys.stdin.readline\n\ndef main():\n    def get_group(k):\n        g = ps[k]\n        if g < 0:\n            return k\n        gg = get_group(g)\n        ps[k] = gg\n        return gg\n\n    def merge(j, k):\n        g1 = get_group(j)\n        g2 = get_group(k)\n        if g1 != g2:\n            s1 = -ps[g1]\n            s2 = -ps[g2]\n            if s2 > s1:\n                g1, g2 = g2, g1\n            ps[g1] = -(s1 + s2)\n            ps[g2] = g1\n\n    hp = []\n    n, h, w = map(int, input().split())\n    ps = [-1] * (h + w + 2)  # 親(parent)と大きさ(size)。0以上は親のノード。負の場合、そのノードが根で絶対値が大きさ。\n    for _ in range(n):\n        r, c, a = map(int, input().split())\n        heappush(hp, [-a, r, h + c])\n    cnt = h + w\n    ans = 0\n    while cnt and hp:\n        a, r, c = heappop(hp)\n        gr = get_group(r)\n        gc = get_group(c)\n        if gr + gc == 0:\n            continue\n        if gr == gc:\n            ps[gr] = 0\n        else:\n            merge(gr, gc)\n        ans -= a\n        cnt -= 1\n    print(ans)\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nsys.setrecursionlimit(10 ** 7)\n\nN,H,W = map(int,readline().split())\nRCA = [tuple(int(x) for x in line.split()) for line in readlines()]\n\nRCA.sort(key = lambda x: -x[2])\n\nRCA\n\nroot = list(range(H+W))\nsize = [0] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return y\n    z = find_root(y)\n    root[x] = z\n    return z\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    no_cycle[x] = no_cycle[x] and no_cycle[y]\n\nanswer = 0\nfor R,C,A in RCA:\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    answer += A\n\nprint(answer)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\n\nclass UF():\n    def __init__(self, num):\n        self.par = [-1]*num\n        self.comp = [False]*num\n    def find(self, x):\n        if self.par[x] < 0:\n            return x\n        else:\n            stack = []\n            while self.par[x] >= 0:\n                stack.append(x)\n                x = self.par[x]\n            for xi in stack:\n                self.par[xi] = x\n            return x\n    \n    def union(self, x, y):\n        rx = self.find(x)\n        ry = self.find(y)\n        if rx != ry:\n            if self.comp[rx] and self.comp[ry]:\n                return False\n            if self.par[rx] > self.par[ry]:\n                rx, ry = ry, rx\n            self.comp[rx] |= self.comp[ry]\n            self.par[rx] += self.par[ry]\n            self.par[ry] = rx\n            return True\n        elif not self.comp[rx]:\n            self.comp[rx] = True\n            return True\n        return False\n\n\nN, H, W = map(int, readline().split())\n\ngeta = 10**5\n\nEdge = []\nfor _ in range(N):\n    h, w, a = map(int, readline().split())\n    h -= 1\n    w -= 1\n    Edge.append((a, h, geta+w))\n\nEdge.sort(reverse = True)\n\nT = UF(2*geta)\n\nans = 0\nfor cost, a, b in Edge:\n    if T.union(a, b):\n        ans += cost\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport operator\n\nN,H,W = map(int,readline().split())\nRCA = [int(x) for x in read().split()]\nit = iter(RCA)\nRCA = sorted(zip(it,it,it),key=operator.itemgetter(2),reverse=True)\n\nroot = list(range(H+W))\nsize = [0] * (H+W)\nno_cycle = [True] * (H+W)\n\ndef find_root(x):\n    y = root[x]\n    if x == y:\n        return y\n    z = find_root(y)\n    root[x] = z\n    return z\n\ndef merge(x,y):\n    x,y = find_root(x),find_root(y)\n    sx,sy = size[x],size[y]\n    if sx < sy:\n        sx,sy = sy,sx\n        x,y = y,x\n    root[y] = x\n    no_cycle[x] = no_cycle[x] and no_cycle[y]\n\nanswer = 0\nfor R,C,A in RCA:\n    continue\n    x,y = R-1,H+C-1\n    rx,ry = find_root(x),find_root(y)\n    if rx == ry:\n        if not no_cycle[rx]:\n            continue\n        no_cycle[rx] = False\n    else:\n        if (not no_cycle[rx]) and (not no_cycle[ry]):\n            continue\n        merge(rx,ry)\n    answer += A\n\nprint(answer)\n"
  },
  {
    "language": "Python",
    "code": "import numpy as np\nn,h,w= map(int, input().split())\narr = [[[]] * w for i in range(h)]\nfor i in range(n):\n  r,c,a = map(int, input().split())\n  arr[r-1][c-1].append(a)\n  \nres = 0\nfor i in range(h):\n  max_ind = 0\n  max_n = 0\n  for j in range(w):\n    if len(arr[i][j]) == 0:\n      continue\n    ind = arr[i][j].index(max(arr[i][j]))\n    if max_n < arr[i][j][ind]:\n      max_j = j\n      max_ind = ind\n      max_n = arr[i][j][ind]\n      \n  res += arr[i][max_j].pop(max_ind)\n  \nfor j in range(w):\n  max_ind = 0\n  max_n = 0\n  for i in range(h):\n    if len(arr[i][j]) == 0:\n      continue\n    ind = arr[i][j].index(max(arr[i][j]))\n    if max_n < arr[i][j][ind]:\n      max_i = i\n      max_ind = ind\n      max_n = arr[i][j][ind]\n      \n  res += arr[max_i][j].pop(max_ind)\n\nprint(res)"
  },
  {
    "language": "Rust",
    "code": "// ${url}\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::io::Write;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\n#[allow(unused_macros)]\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n\n    ($iter:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, [ next / $t:tt ]) => {\n        {\n            let len = read_value!($iter, usize);\n            (0..len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($iter:expr, switch) => {\n        {\n            let ty = read_value!($iter, i32);\n            if ty == 1 {\n                vec![ty, read_value!($iter, i32), read_value!($iter, i32)]\n            } else if ty == 2 {\n                vec![ty, read_value!($iter, i32)]\n            } else {\n                vec![ty, read_value!($iter, i32)]\n            }\n        }\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! ifv {\n    ($t:expr, $a:expr, $b: expr) => {\n        if $t { $a } else { $b }\n    }\n}\n\n#[allow(unused_macros)]\nmacro_rules! fill {\n    ($t:expr, $v:expr) => {\n        for i in 0..$t.len() {\n            $t[i] = $v;\n        }\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! join {\n    ($t:expr, $glue:expr) => {\n        $t.into_iter().map(|w| w.to_string()).collect::<Vec<_>>().join($glue)\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n// ===\n\n\nstruct UnionFind {\n      n: usize,\n      parent: Vec<usize>,\n      count: Vec<usize>,\n      has_cycle: Vec<bool>\n}\n\nimpl UnionFind {\n     fn new(n: usize) -> Self {\n           let mut p = vec![0; n];\n           for i in 0..n {\n                 p[i] = i;\n           }\n           UnionFind { n: n, parent: p, count: vec![1; n], has_cycle: vec![false; n] }\n     }\n\n     fn find(&mut self, a: usize) -> usize {\n           if self.parent[a] == a {\n                 return a;\n           }\n           let par = self.parent[a];\n           self.parent[a] = self.find(par);\n           self.parent[a]\n     }\n\n     fn unite(&mut self, a: usize, b: usize) {\n           let a = self.find(a);\n           let b = self.find(b);\n           if a == b {\n                self.has_cycle[a] = true;\n                return;\n           }\n           let ca = self.count[a];\n           let cb = self.count[b];\n           let total = ca + cb;\n           self.count[b] = total;\n           self.count[a] = total;\n           let tc = self.has_cycle[a] | self.has_cycle[b];\n           self.has_cycle[a] = tc;\n           self.has_cycle[b] = tc;\n           if ca < cb {\n                self.parent[a] = b;\n           } else {\n                self.parent[b] = a;\n           }\n     }\n\n     fn can_unite(&mut self, a: usize, b: usize) -> bool {\n         let ida = self.find(a);\n         let idb = self.find(b);\n         if self.same(a, b) && self.has_cycle[ida] {\n             return false;\n         }\n         if self.has_cycle[ida] && self.has_cycle[idb] {\n             return false;\n         }\n         true\n     }\n\n     fn same(&mut self, a: usize, b: usize) -> bool {\n           self.find(a) == self.find(b)\n     }\n\n     fn count(&mut self, a: usize) -> usize {\n           let a = self.find(a);\n           self.count[a]\n     }\n}\n\nfn main() {\n    input! {\n        n: usize, h: usize, w: usize,\n        mut cards: [(usize1, usize1, i64); n]\n    };\n    cards.sort_by_key(|&a| -a.2);\n\n    let mut uf = UnionFind::new(h+w);\n    let mut score = 0;\n    for (i, j, value) in cards {\n        if uf.can_unite(i, h+j) {\n            uf.unite(i, h+j);\n            score += value;\n        }\n    }\n    println!(\"{}\", score);\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let (r, w) = (std::io::stdin(), std::io::stdout());\n    let mut sc = IO::new(r.lock(), w.lock());\n\n    let n: usize = sc.read();\n    let h: usize = sc.read();\n    let w: usize = sc.read();\n\n    let mut edges = vec![];\n    for _ in 0..n {\n        let r = sc.read::<usize>() - 1;\n        let c = sc.read::<usize>() - 1;\n        let value: u64 = sc.read();\n        edges.push((value, r, c));\n    }\n\n    edges.sort();\n    let mut uf = UnionFind::new(h + w);\n    let mut ans = 0;\n    for &(value, r, c) in edges.iter().rev() {\n        let root1 = uf.find(r);\n        let root2 = uf.find(c + h);\n        if root1 != root2 {\n            let size = uf.sizes[root1] + uf.sizes[root2];\n            let edges = uf.edges[root1] + uf.edges[root2];\n            if size >= edges + 1 {\n                ans += value;\n                uf.unite(root1, root2);\n            }\n        } else if uf.sizes[root1] >= uf.edges[root1] + 1 {\n            uf.edges[root1] += 1;\n            ans += value;\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n\npub struct UnionFind {\n    parent: Vec<usize>,\n    sizes: Vec<usize>,\n    edges: Vec<usize>,\n    size: usize,\n}\n\nimpl UnionFind {\n    pub fn new(n: usize) -> UnionFind {\n        UnionFind {\n            parent: (0..n).map(|i| i).collect::<Vec<usize>>(),\n            sizes: vec![1; n],\n            edges: vec![0; n],\n            size: n,\n        }\n    }\n\n    pub fn find(&mut self, x: usize) -> usize {\n        if x == self.parent[x] {\n            x\n        } else {\n            let px = self.parent[x];\n            self.parent[x] = self.find(px);\n            self.parent[x]\n        }\n    }\n\n    pub fn unite(&mut self, x: usize, y: usize) -> bool {\n        let parent_x = self.find(x);\n        let parent_y = self.find(y);\n        if parent_x == parent_y {\n            return false;\n        }\n\n        let (large, small) = if self.sizes[parent_x] < self.sizes[parent_y] {\n            (parent_y, parent_x)\n        } else {\n            (parent_x, parent_y)\n        };\n\n        self.parent[small] = large;\n        self.sizes[large] += self.sizes[small];\n        self.sizes[small] = 0;\n\n        self.edges[large] += self.edges[small] + 1;\n        self.edges[small] = 0;\n\n        self.size -= 1;\n        return true;\n    }\n}\n\npub struct IO<R, W: std::io::Write>(R, std::io::BufWriter<W>);\n\nimpl<R: std::io::Read, W: std::io::Write> IO<R, W> {\n    pub fn new(r: R, w: W) -> IO<R, W> {\n        IO(r, std::io::BufWriter::new(w))\n    }\n    pub fn write<S: std::ops::Deref<Target = str>>(&mut self, s: S) {\n        use std::io::Write;\n        self.1.write(s.as_bytes()).unwrap();\n    }\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .0\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n' || b == b'\\r' || b == b'\\t')\n            .take_while(|&b| b != b' ' && b != b'\\n' && b != b'\\r' && b != b'\\t')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n: usize = sc.read();\n    let h: usize = sc.read();\n    let w: usize = sc.read();\n\n    let mut uf = UnionFind::new(h + w);\n    let mut edges = vec![];\n    for _ in 0..n {\n        let row = sc.read::<usize>() - 1;\n        let col = sc.read::<usize>() - 1;\n        let value: u64 = sc.read();\n        edges.push((value, row, col + h));\n    }\n    edges.sort();\n\n    let mut ans = 0;\n    for (value, row, col) in edges.into_iter().rev() {\n        let x = uf.find(row);\n        let y = uf.find(col);\n\n        if x != y {\n            if uf.sizes[x] + uf.sizes[y] >= uf.edge_count[x] + uf.edge_count[y] + 1 {\n                uf.unite(x, y);\n                ans += value;\n            }\n        } else if uf.sizes[x] > uf.edge_count[x] {\n            uf.edge_count[x] += 1;\n            ans += value;\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n\npub struct UnionFind {\n    parent: Vec<usize>,\n    sizes: Vec<usize>,\n    size: usize,\n    edge_count: Vec<usize>,\n}\n\nimpl UnionFind {\n    pub fn new(n: usize) -> UnionFind {\n        UnionFind {\n            parent: (0..n).map(|i| i).collect::<Vec<usize>>(),\n            sizes: vec![1; n],\n            size: n,\n            edge_count: vec![0; n],\n        }\n    }\n\n    pub fn find(&mut self, x: usize) -> usize {\n        if x == self.parent[x] {\n            x\n        } else {\n            let px = self.parent[x];\n            self.parent[x] = self.find(px);\n            self.parent[x]\n        }\n    }\n\n    pub fn unite(&mut self, x: usize, y: usize) -> bool {\n        let parent_x = self.find(x);\n        let parent_y = self.find(y);\n        if parent_x == parent_y {\n            return false;\n        }\n\n        let (large, small) = if self.sizes[parent_x] < self.sizes[parent_y] {\n            (parent_y, parent_x)\n        } else {\n            (parent_x, parent_y)\n        };\n\n        self.parent[small] = large;\n\n        self.sizes[large] += self.sizes[small];\n        self.sizes[small] = 0;\n\n        self.edge_count[large] += self.edge_count[small] + 1;\n        self.edge_count[small] = 0;\n\n        self.size -= 1;\n        return true;\n    }\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n\n    let n: usize = sc.read();\n    let h: usize = sc.read();\n    let w: usize = sc.read();\n    let mut edges = vec![];\n    for _ in 0..n {\n        let r = sc.read::<usize>() - 1;\n        let c = sc.read::<usize>() - 1;\n        let a = sc.read::<u64>();\n        edges.push((a, r, c + h));\n    }\n    edges.sort();\n\n    let mut ans = 0;\n    let mut uf = UnionFind::new(h + w);\n    for (a, r, c) in edges.into_iter().rev() {\n        let r = uf.find(r);\n        let c = uf.find(c);\n        if r == c {\n            if uf.sizes[r] > uf.edges[r] {\n                uf.edges[r] += 1;\n                ans += a;\n            }\n        } else {\n            if uf.edges[r] + uf.edges[c] + 1 <= uf.sizes[r] + uf.sizes[c] {\n                uf.unite(r, c);\n                ans += a;\n            }\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n\npub struct UnionFind {\n    parent: Vec<usize>,\n    sizes: Vec<usize>,\n    size: usize,\n    edges: Vec<usize>,\n}\n\nimpl UnionFind {\n    pub fn new(n: usize) -> UnionFind {\n        UnionFind {\n            parent: (0..n).map(|i| i).collect::<Vec<usize>>(),\n            sizes: vec![1; n],\n            size: n,\n            edges: vec![0; n],\n        }\n    }\n\n    pub fn find(&mut self, x: usize) -> usize {\n        if x == self.parent[x] {\n            x\n        } else {\n            let px = self.parent[x];\n            self.parent[x] = self.find(px);\n            self.parent[x]\n        }\n    }\n\n    pub fn unite(&mut self, x: usize, y: usize) -> bool {\n        let parent_x = self.find(x);\n        let parent_y = self.find(y);\n        if parent_x == parent_y {\n            return false;\n        }\n\n        let (large, small) = if self.sizes[parent_x] < self.sizes[parent_y] {\n            (parent_y, parent_x)\n        } else {\n            (parent_x, parent_y)\n        };\n\n        self.parent[small] = large;\n        self.sizes[large] += self.sizes[small];\n        self.sizes[small] = 0;\n\n        self.edges[large] += self.edges[small] + 1;\n        self.edges[small] = 0;\n\n        self.size -= 1;\n        return true;\n    }\n}\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_e\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n\nfn dfs(graph: &Vec<Vec<usize>>, cards: &Vec<(usize, usize, i64)>, taken: &Vec<bool>, visited: &mut Vec<usize>, rt: usize, now: usize, par: usize) -> (i64, usize) {\n    if visited[now] == rt {\n        assert!(false);\n        return (-1, 0);\n    }\n    visited[now] = rt;\n\n    let mut best = (-1, 0);\n    for &ei in graph[now].iter() {\n        if !taken[ei] {\n            if best.0 < cards[ei].2 {\n                best = (cards[ei].2, ei);\n            }\n            continue;\n        }\n        let to = cards[ei].0 + cards[ei].1 - now;\n        if to == par {\n            continue;\n        }\n        let (s, e) = dfs(graph, cards, taken, visited, rt, to, now);\n        if best.0 < s {\n            best = (s, e);\n        }\n    }\n    best\n}\n\nfn main() {\n    input! {\n        n: usize, h: usize, w: usize,\n        cards: [(usize1, usize1, i64); n]\n    };\n    let mut cards = cards;\n    for i in 0..n {\n        cards[i].1 += h;\n    }\n    let mut graph = vec![vec![]; h+w];\n    for (&(i, j, value), ci) in cards.iter().zip(0..n) {\n        graph[i].push(ci);\n        graph[j].push(ci);\n    }\n\n    let mut ans = 0;\n    let mut taken = vec![false; n];\n\n    let mut not_found = vec![];\n    for i in 0..h+w {\n        let mut best = (-1, 0);\n        for &ei in graph[i].iter() {\n            if best.0 < cards[ei].2 && !taken[ei] {\n                best = (cards[ei].2, ei);\n            }\n        }\n        if best.0 >= 1 {\n            ans += best.0;\n            taken[best.1] = true;\n        } else {\n            if graph[i].len() >= 1 {\n                not_found.push(i);\n            }\n        }\n    }\n\n    let mut visited = vec![h+w; h+w];\n    for &idx in not_found.iter() {\n        let (inc, eidx) = dfs(&graph, &cards, &taken, &mut visited, idx, idx, h+w);\n        if inc >= 1 {\n            ans += inc;\n            // assert!(!taken[eidx]);\n            taken[eidx] = true;\n        }\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n: usize = sc.read();\n    let h: usize = sc.read();\n    let w: usize = sc.read();\n\n    let mut edges = vec![];\n    for _ in 0..n {\n        let r = sc.read::<usize>() - 1;\n        let c = sc.read::<usize>() - 1;\n        let a: u64 = sc.read();\n        edges.push((a, r, c + h));\n    }\n    edges.sort();\n\n    let mut ans = 0;\n    let mut uf = UnionFind::new(h + w);\n    for (value, u, v) in edges.into_iter().rev() {\n        if uf.find(u) != uf.find(v) {\n            let root1 = uf.find(u);\n            let root2 = uf.find(v);\n            if uf.sizes[root1] + uf.sizes[root2] > uf.edges[root1] + uf.edges[root2] {\n                ans += value;\n                uf.unite(u, v);\n            }\n        } else {\n            let root = uf.find(u);\n            if uf.edges[root] < uf.sizes[root] {\n                ans += value;\n                uf.edges[root] += 1;\n            }\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n\npub struct UnionFind {\n    parent: Vec<usize>,\n    sizes: Vec<usize>,\n    size: usize,\n    edges: Vec<usize>,\n}\n\nimpl UnionFind {\n    pub fn new(n: usize) -> UnionFind {\n        UnionFind {\n            parent: (0..n).map(|i| i).collect::<Vec<usize>>(),\n            sizes: vec![1; n],\n            size: n,\n            edges: vec![0; n],\n        }\n    }\n\n    pub fn find(&mut self, x: usize) -> usize {\n        if x == self.parent[x] {\n            x\n        } else {\n            let px = self.parent[x];\n            self.parent[x] = self.find(px);\n            self.parent[x]\n        }\n    }\n\n    pub fn unite(&mut self, x: usize, y: usize) -> bool {\n        let parent_x = self.find(x);\n        let parent_y = self.find(y);\n        if parent_x == parent_y {\n            return false;\n        }\n\n        let (large, small) = if self.sizes[parent_x] < self.sizes[parent_y] {\n            (parent_y, parent_x)\n        } else {\n            (parent_x, parent_y)\n        };\n\n        self.parent[small] = large;\n        self.sizes[large] += self.sizes[small];\n        self.sizes[small] = 0;\n\n        self.edges[large] += self.edges[small] + 1;\n        self.edges[small] = 0;\n\n        self.size -= 1;\n        return true;\n    }\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::prelude::*;\n\nfn input<T: std::str::FromStr>() -> T {\n    let stdin = std::io::stdin();\n    let token: String = stdin\n        .lock()\n        .bytes()\n        .map(|c| c.unwrap() as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().unwrap()\n}\n\n#[allow(dead_code)]\nfn with_stdout_lock<F: FnOnce(std::io::BufWriter<std::io::StdoutLock>)>(f: F) {\n    let out = std::io::stdout();\n    let w = std::io::BufWriter::new(out.lock());\n    f(w);\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($var:expr) => {\n        match &$var { v => eprintln!(concat!(stringify!($var), \"={:?}\"), v) }\n    };\n    ($var:expr, $($vars:expr),*) => {\n        match &$var { v => eprint!(concat!(stringify!($var), \"={:?} \"), v) }\n        debug!($($vars),*);\n    };\n}\n\nfn main() {\n    let n: usize = input();\n    let h: usize = input();\n    let w: usize = input();\n    let mut rca: Vec<(usize, usize, i32)> = (0..n).map(|_| (input(), input(), input())).collect();\n    rca.sort_by_key(|&(_, _, a)| -a);\n\n    let mut nedge = vec![0; h + w];\n    let mut uf = UnionFind::new(h + w);\n    let mut ans = 0;\n    for &(r, c, a) in &rca {\n        let (r, c) = (r - 1, h + c - 1);\n        let pr = uf.find(r);\n        let pc = uf.find(c);\n        if pr != pc && uf.size[pr] + uf.size[pc] > nedge[pr] + nedge[pc] {\n            uf.union(r, c);\n            nedge[uf.find(r)] = nedge[pr] + nedge[pc] + 1;\n            ans += a as i64;\n        } else if pr == pc && uf.size[pr] > nedge[pr] {\n            nedge[uf.find(r)] += 1;\n            ans += a as i64;\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n\nstruct UnionFind {\n    parent: Vec<usize>,\n    size: Vec<usize>,\n}\n#[allow(dead_code)]\nimpl UnionFind {\n    fn new(n: usize) -> UnionFind {\n        UnionFind {\n            parent: (0..n).collect(),\n            size: vec![1; n],\n        }\n    }\n    fn find(&mut self, x: usize) -> usize {\n        if self.parent[x] == x {\n            x\n        } else {\n            let p = self.parent[x];\n            self.parent[x] = self.find(p);\n            self.parent[x]\n        }\n    }\n    fn union(&mut self, x: usize, y: usize) -> bool {\n        let mut x = self.find(x);\n        let mut y = self.find(y);\n        if x == y {\n            false\n        } else {\n            if self.size[x] < self.size[y] {\n                std::mem::swap(&mut x, &mut y);\n            }\n            self.parent[y] = x;\n            self.size[x] += self.size[y];\n            true\n        }\n    }\n    fn size(&mut self, x: usize) -> usize {\n        let p = self.find(x);\n        self.size[p]\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\nuse std::collections::BTreeSet;\n\nfn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n: usize = sc.read();\n    let h: usize = sc.read();\n    let w: usize = sc.read();\n    let mut cards = vec![];\n    for i in 0..n {\n        let r: usize = sc.read();\n        let c: usize = sc.read();\n        let a: usize = sc.read();\n        cards.push((a, r, c, i));\n    }\n    let ans1 = solve(&cards);\n    cards = cards.into_iter().map(|(v, r, c, i)| (v, c, r, i)).collect();\n    let ans2 = solve(&cards);\n    println!(\"{}\", cmp::max(ans1, ans2));\n}\n\nfn solve(cards: &Vec<(usize, usize, usize, usize)>) -> usize {\n    let mut row_cards = cards\n        .iter()\n        .map(|&(v, r, _, i)| (v, r, i))\n        .collect::<Vec<_>>();\n    row_cards.sort();\n    row_cards.reverse();\n\n    let mut ans = 0;\n    let mut id_set = BTreeSet::new();\n    let mut row_set = BTreeSet::new();\n    for &(v, r, i) in row_cards.iter() {\n        if id_set.contains(&i) || row_set.contains(&r) {\n            continue;\n        }\n        ans += v;\n        row_set.insert(r);\n        id_set.insert(i);\n    }\n\n    let mut col_cards = cards\n        .iter()\n        .map(|&(v, _, c, i)| (v, c, i))\n        .collect::<Vec<_>>();\n    col_cards.sort();\n    col_cards.reverse();\n    let mut col_set = BTreeSet::new();\n    for &(v, c, i) in col_cards.iter() {\n        if id_set.contains(&i) || col_set.contains(&c) {\n            continue;\n        }\n        ans += v;\n        col_set.insert(c);\n        id_set.insert(i);\n    }\n    ans\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// SNIPPET vec_union_find_sets\npub struct VecUnionFindSets {\n    set_count: usize,  items: Vec<VecUnionFindNode>\n}\n#[derive(Clone)]\nstruct VecUnionFindNode {\n    parent: std::cell::Cell<usize>,\n    len: usize\n}\nimpl VecUnionFindNode {\n    fn new(item: usize) -> VecUnionFindNode {\n        VecUnionFindNode {\n            parent: std::cell::Cell::new(item),\n            len: 1\n        }\n    }\n}\nimpl VecUnionFindSets {\n    pub fn new() -> VecUnionFindSets {\n        VecUnionFindSets {\n            set_count: 0,\n            items: Vec::new()\n        }\n    }\n    pub fn with_items(items_count: usize) -> VecUnionFindSets {\n        let mut sets = VecUnionFindSets::new();\n        sets.add_items(items_count);\n        sets\n    }\n    fn error_msg(items: &[usize]) -> String {\n        assert!(items.len() == 1 || items.len() == 2);\n        if items.len() == 1 {\n            format!(\"no set contains {}\", items[0])\n        } else {\n            format!(\"no set contains {} and no set contains {}\", items[0], items[1])\n        }\n    }\n    pub fn add_items(&mut self, count: usize) {\n        self.set_count += count;\n        let new_items = (self.items_len()..self.items_len()+count)\n            .map(|i| VecUnionFindNode::new(i));\n        self.items.extend(new_items);\n    }\n    pub fn items_len(&self) -> usize {\n        self.items.len()\n    }\n    fn find(&self, item: usize) -> Option<usize> {\n        if item >= self.items_len() {\n            return None;\n        }\n        fn go(sets: &VecUnionFindSets, item: usize) -> usize {\n            let node = &sets.items[item];\n            if node.parent.get() == item {\n                return item;\n            }\n            let root = go(sets, node.parent.get());\n            sets.items[root].parent.set(root);\n            root\n        }\n        Some(go(self, item))\n    }\n    pub fn count(&self) -> usize {\n        self.set_count\n    }\n    pub fn len_of(&self, item: usize) -> Result<usize, String> {\n        self.find(item).map(|root| self.items[root].len).ok_or_else(|| {\n            VecUnionFindSets::error_msg(&[item])\n        })\n    }\n    pub fn set_eq(&self, item1: usize, item2: usize) -> Result<bool, String> {\n        match (self.find(item1), self.find(item2)) {\n            (Some(root1), Some(root2)) => Ok(root1 == root2),\n            (Some(_), None) => Err(VecUnionFindSets::error_msg(&[item2])),\n            (None, Some(_)) => Err(VecUnionFindSets::error_msg(&[item1])),\n            (None, None) => Err(VecUnionFindSets::error_msg(&[item1, item2])),\n        }\n    }\n    pub fn unite(&mut self, item1: usize, item2: usize) -> Result<bool, String> {\n        match (self.find(item1), self.find(item2)) {\n            (Some(root1), Some(root2)) => {\n                if root1 == root2 {\n                    return Ok(false);\n                }\n                self.set_count -= 1;\n                let (new_root, new_child) = if self.items[root1].len < self.items[root2].len {\n                    (root2, root1)\n                } else {\n                    (root1, root2)\n                };\n                let new_len = self.items[root1].len + self.items[root2].len;\n                self.items[new_root] = VecUnionFindNode {\n                    parent: std::cell::Cell::new(new_root),\n                    len: new_len\n                };\n                self.items[new_child] = VecUnionFindNode {\n                    parent: std::cell::Cell::new(new_root),\n                    len: 0\n                };\n                Ok(true)\n            },\n            (Some(_), None) => Err(VecUnionFindSets::error_msg(&[item2])),\n            (None, Some(_)) => Err(VecUnionFindSets::error_msg(&[item1])),\n            (None, None) => Err(VecUnionFindSets::error_msg(&[item1, item2]))\n        }\n    }\n    pub fn iter_cloned(&self) -> impl Iterator<Item=Vec<usize>> {\n        let mut sets = vec![Vec::new(); self.items_len()];\n        for i in 0..self.items_len() {\n            let repr = self.find(i).unwrap();\n            sets[repr].push(i);\n        }\n        sets.into_iter().filter(|v| !v.is_empty())\n    }\n}\nimpl std::fmt::Debug for VecUnionFindSets {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{{\")?;\n        let mut first = true;\n        for set in self.iter_cloned() {\n            if !first {\n                write!(f, \", \")?;\n            }\n            write!(f, \"{:?}\", set)?;\n            first = false;\n        }\n        write!(f, \"}}\")\n    }\n}\n/*\nimpl<T: Eq + std::hash::Hash + std::fmt::Debug> IntoIterator for HashUnionFindSets<T> {\n    type Item = HashSet<T>;\n    type IntoIter = std::collections::hash_map::Values<>;\n    fn into_iter(self) -> Self::IntoIter {\n    }\n}\n*/\n\n// SNIPPET read\npub trait Readable {\n    type Output;\n    const WORD_COUNT: usize;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String>;\n}\n#[macro_export]\nmacro_rules! readable {\n    ( $t:ty, $words_count:expr, |$words:ident| $read_words:expr ) => {\n        impl Readable for $t {\n            type Output = $t;\n            const WORD_COUNT: usize = $words_count;\n            fn read_words($words: &[&str]) -> Result<$t, String> {\n                Ok($read_words)\n            }\n        }\n    };\n}\nreadable!((), 1, |_ss| ());\nreadable!(String, 1, |ss| ss[0].to_string());\nimpl Readable for char {\n    type Output = char;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<char, String> {\n        let chars: Vec<char> = words[0].chars().collect();\n        if chars.len() == 1 {\n            Ok(chars[0])\n        } else {\n            Err(format!(\"cannot parse `{}` as a char\", words[0]))\n        }\n    }\n}\npub struct Chars();\nimpl Readable for Chars {\n    type Output = Vec<char>;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Vec<char>, String> {\n        Ok(words[0].chars().collect())\n    }\n}\npub struct Bytes();\nimpl Readable for Bytes {\n    type Output = Vec<u8>;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Vec<u8>, String> {\n        Ok(words[0].bytes().collect())\n    }\n}\nimpl Readable for i8 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<i8, String> {\n        use std::str::FromStr;\n        i8::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as i8\", words[0])\n        })\n    }\n}\nimpl Readable for u8 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<u8, String> {\n        use std::str::FromStr;\n        u8::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as u8\", words[0])\n        })\n    }\n}\nimpl Readable for i16 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<i16, String> {\n        use std::str::FromStr;\n        i16::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as i16\", words[0])\n        })\n    }\n}\nimpl Readable for u16 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<u16, String> {\n        use std::str::FromStr;\n        u16::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as u16\", words[0])\n        })\n    }\n}\nimpl Readable for i32 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<i32, String> {\n        use std::str::FromStr;\n        i32::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as i32\", words[0])\n        })\n    }\n}\nimpl Readable for u32 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<u32, String> {\n        use std::str::FromStr;\n        u32::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as u32\", words[0])\n        })\n    }\n}\nimpl Readable for i64 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<i64, String> {\n        use std::str::FromStr;\n        i64::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as i64\", words[0])\n        })\n    }\n}\nimpl Readable for u64 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<u64, String> {\n        use std::str::FromStr;\n        u64::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as u64\", words[0])\n        })\n    }\n}\nimpl Readable for i128 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<i128, String> {\n        use std::str::FromStr;\n        i128::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as i64\", words[0])\n        })\n    }\n}\nimpl Readable for u128 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<u128, String> {\n        use std::str::FromStr;\n        u128::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as u64\", words[0])\n        })\n    }\n}\nimpl Readable for isize {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<isize, String> {\n        use std::str::FromStr;\n        <isize>::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as isize\", words[0])\n        })\n    }\n}\nimpl Readable for usize {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<usize, String> {\n        use std::str::FromStr;\n        <usize>::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as usize\", words[0])\n        })\n    }\n}\nimpl Readable for f32 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<f32, String> {\n        use std::str::FromStr;\n        f32::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as f32\", words[0])\n        })\n    }\n}\nimpl Readable for f64 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<f64, String> {\n        use std::str::FromStr;\n        f64::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as f64\", words[0])\n        })\n    }\n}\n#[allow(non_camel_case_types)]\npub struct u8_;\nimpl Readable for u8_ {\n    type Output = u8;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        u8::read_words(words).map(|n| n-1)\n    }\n}\n#[allow(non_camel_case_types)]\npub struct u16_;\nimpl Readable for u16_ {\n    type Output = u16;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        u16::read_words(words).map(|n| n-1)\n    }\n}\n#[allow(non_camel_case_types)]\npub struct u32_;\nimpl Readable for u32_ {\n    type Output = u32;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        u32::read_words(words).map(|n| n-1)\n    }\n}\n#[allow(non_camel_case_types)]\npub struct u64_;\nimpl Readable for u64_ {\n    type Output = u64;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        u64::read_words(words).map(|n| n-1)\n    }\n}\n#[allow(non_camel_case_types)]\npub struct usize_;\nimpl Readable for usize_ {\n    type Output = usize;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        <usize>::read_words(words).map(|n| n-1)\n    }\n}\nimpl<T1: Readable, T2: Readable> Readable for (T1, T2) {\n    type Output = (T1::Output, T2::Output);\n    const WORD_COUNT: usize = T1::WORD_COUNT + T2::WORD_COUNT;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let mut start = 0;\n        let count1 = T1::WORD_COUNT;\n        let val1 = T1::read_words(&words[start .. start+count1])?;\n        start += count1;\n        let val2 = T2::read_words(&words[start..])?;\n        Ok((val1, val2))\n    }\n}\nimpl<T1: Readable, T2: Readable, T3: Readable> Readable for (T1, T2, T3) {\n    type Output = (T1::Output, T2::Output, T3::Output);\n    const WORD_COUNT: usize = T1::WORD_COUNT + T2::WORD_COUNT + T3::WORD_COUNT;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let mut start = 0;\n        let count1 = T1::WORD_COUNT;\n        let val1 = T1::read_words(&words[start .. start+count1])?;\n        start += count1;\n        let count2 = T2::WORD_COUNT;\n        let val2 = T2::read_words(&words[start .. start+count2])?;\n        start += count2;\n        let val3 = T3::read_words(&words[start..])?;\n        Ok((val1, val2, val3))\n    }\n}\nimpl<T1: Readable, T2: Readable, T3: Readable, T4: Readable> Readable for (T1, T2, T3, T4) {\n    type Output = (T1::Output, T2::Output, T3::Output, T4::Output);\n    const WORD_COUNT: usize = T1::WORD_COUNT + T2::WORD_COUNT + T3::WORD_COUNT + T4::WORD_COUNT;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let mut start = 0;\n        let count1 = T1::WORD_COUNT;\n        let val1 = T1::read_words(&words[start .. start+count1])?;\n        start += count1;\n        let count2 = T2::WORD_COUNT;\n        let val2 = T2::read_words(&words[start .. start+count2])?;\n        start += count2;\n        let count3 = T3::WORD_COUNT;\n        let val3 = T3::read_words(&words[start .. start+count3])?;\n        start += count3;\n        let val4 = T4::read_words(&words[start..])?;\n        Ok((val1, val2, val3, val4))\n    }\n}\nimpl<T1: Readable, T2: Readable, T3: Readable, T4: Readable, T5: Readable> Readable for (T1, T2, T3, T4, T5) {\n    type Output = (T1::Output, T2::Output, T3::Output, T4::Output, T5::Output);\n    const WORD_COUNT: usize = T1::WORD_COUNT + T2::WORD_COUNT + T3::WORD_COUNT + T4::WORD_COUNT + T5::WORD_COUNT;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let mut start = 0;\n        let count1 = T1::WORD_COUNT;\n        let val1 = T1::read_words(&words[start .. start+count1])?;\n        start += count1;\n        let count2 = T2::WORD_COUNT;\n        let val2 = T2::read_words(&words[start .. start+count2])?;\n        start += count2;\n        let count3 = T3::WORD_COUNT;\n        let val3 = T3::read_words(&words[start .. start+count3])?;\n        start += count3;\n        let count4 = T4::WORD_COUNT;\n        let val4 = T4::read_words(&words[start .. start+count4])?;\n        start += count4;\n        let val5 = T5::read_words(&words[start..])?;\n        Ok((val1, val2, val3, val4, val5))\n    }\n}\nimpl<T1: Readable, T2: Readable, T3: Readable, T4: Readable, T5: Readable, T6: Readable> Readable for (T1, T2, T3, T4, T5, T6) {\n    type Output = (T1::Output, T2::Output, T3::Output, T4::Output, T5::Output, T6::Output);\n    const WORD_COUNT: usize = T1::WORD_COUNT + T2::WORD_COUNT + T3::WORD_COUNT + T4::WORD_COUNT + T5::WORD_COUNT + T6::WORD_COUNT;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let mut start = 0;\n        let count1 = T1::WORD_COUNT;\n        let val1 = T1::read_words(&words[start .. start+count1])?;\n        start += count1;\n        let count2 = T2::WORD_COUNT;\n        let val2 = T2::read_words(&words[start .. start+count2])?;\n        start += count2;\n        let count3 = T3::WORD_COUNT;\n        let val3 = T3::read_words(&words[start .. start+count3])?;\n        start += count3;\n        let count4 = T4::WORD_COUNT;\n        let val4 = T4::read_words(&words[start .. start+count4])?;\n        start += count4;\n        let count5 = T5::WORD_COUNT;\n        let val5 = T5::read_words(&words[start .. start+count5])?;\n        start += count5;\n        let val6 = T6::read_words(&words[start..])?;\n        Ok((val1, val2, val3, val4, val5, val6))\n    }\n}\nimpl<T: Readable> Readable for [T; 2] {\n    type Output = [T::Output; 2];\n    const WORD_COUNT: usize = T::WORD_COUNT * 2;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let val1 = T::read_words(&words[T::WORD_COUNT*0 .. T::WORD_COUNT*1])?;\n        let val2 = T::read_words(&words[T::WORD_COUNT*1 .. T::WORD_COUNT*2])?;\n        Ok([val1, val2])\n    }\n}\nimpl<T: Readable> Readable for [T; 3] {\n    type Output = [T::Output; 3];\n    const WORD_COUNT: usize = T::WORD_COUNT * 3;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let val1 = T::read_words(&words[T::WORD_COUNT*0 .. T::WORD_COUNT*1])?;\n        let val2 = T::read_words(&words[T::WORD_COUNT*1 .. T::WORD_COUNT*2])?;\n        let val3 = T::read_words(&words[T::WORD_COUNT*2 .. T::WORD_COUNT*3])?;\n        Ok([val1, val2, val3])\n    }\n}\nimpl<T: Readable> Readable for [T; 4] {\n    type Output = [T::Output; 4];\n    const WORD_COUNT: usize = T::WORD_COUNT * 4;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let val1 = T::read_words(&words[T::WORD_COUNT*0 .. T::WORD_COUNT*1])?;\n        let val2 = T::read_words(&words[T::WORD_COUNT*1 .. T::WORD_COUNT*2])?;\n        let val3 = T::read_words(&words[T::WORD_COUNT*2 .. T::WORD_COUNT*3])?;\n        let val4 = T::read_words(&words[T::WORD_COUNT*3 .. T::WORD_COUNT*4])?;\n        Ok([val1, val2, val3, val4])\n    }\n}\nimpl<T: Readable> Readable for [T; 5] {\n    type Output = [T::Output; 5];\n    const WORD_COUNT: usize = T::WORD_COUNT * 5;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let val1 = T::read_words(&words[T::WORD_COUNT*0 .. T::WORD_COUNT*1])?;\n        let val2 = T::read_words(&words[T::WORD_COUNT*1 .. T::WORD_COUNT*2])?;\n        let val3 = T::read_words(&words[T::WORD_COUNT*2 .. T::WORD_COUNT*3])?;\n        let val4 = T::read_words(&words[T::WORD_COUNT*3 .. T::WORD_COUNT*4])?;\n        let val5 = T::read_words(&words[T::WORD_COUNT*4 .. T::WORD_COUNT*5])?;\n        Ok([val1, val2, val3, val4, val5])\n    }\n}\nimpl<T: Readable> Readable for [T; 6] {\n    type Output = [T::Output; 6];\n    const WORD_COUNT: usize = T::WORD_COUNT * 6;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let val1 = T::read_words(&words[T::WORD_COUNT*0 .. T::WORD_COUNT*1])?;\n        let val2 = T::read_words(&words[T::WORD_COUNT*1 .. T::WORD_COUNT*2])?;\n        let val3 = T::read_words(&words[T::WORD_COUNT*2 .. T::WORD_COUNT*3])?;\n        let val4 = T::read_words(&words[T::WORD_COUNT*3 .. T::WORD_COUNT*4])?;\n        let val5 = T::read_words(&words[T::WORD_COUNT*4 .. T::WORD_COUNT*5])?;\n        let val6 = T::read_words(&words[T::WORD_COUNT*5 .. T::WORD_COUNT*6])?;\n        Ok([val1, val2, val3, val4, val5, val6])\n    }\n}\npub trait ReadableFromLine {\n    type Output;\n    fn read_line(line: &str) -> Result<Self::Output, String>;\n}\nfn split_into_words(line: &str) -> Vec<&str> {\n    line.trim_end_matches('\\n').split_whitespace().collect()\n}\nimpl<T: Readable> ReadableFromLine for T {\n    type Output = T::Output;\n    fn read_line(line: &str) -> Result<T::Output, String> {\n        let words = split_into_words(line);\n        if words.len() != T::WORD_COUNT {\n            return Err(format!(\"line `{}` has {} words, expected {}\",\n                               line, words.len(), T::WORD_COUNT));\n        }\n        T::read_words(&words)\n    }\n}\npub fn read_words_into_vec<T: Readable>(words: &[&str], line: &str) -> Result<Vec<T::Output>, String> {\n    let n = T::WORD_COUNT;\n    assert_eq!(words.len() % n, 0);\n    let mut result = Vec::new();\n    for chunk in words.chunks(n) {\n        match T::read_words(chunk) {\n            Ok(v) => result.push(v),\n            Err(msg) => {\n                let fragment_msg = if n == 1 {\n                    format!(\"word {}\", result.len())\n                } else {\n                    let l = result.len();\n                    format!(\"words {}-{}\", n*l + 1, (n+1) * l)\n                };\n                return Err(format!(\n                    \"{} of line `{}`: {}\", fragment_msg, line, msg\n                ));\n            }\n        }\n    }\n    Ok(result)\n}\npub fn split_into_words_for_collection<T: Readable>(\n    line: &str, prefix_words_count: usize\n) -> Result<Vec<&str>, String> {\n    let n = T::WORD_COUNT;\n    let words = split_into_words(line);\n    if words.len() < prefix_words_count {\n        return Err(\n            format!(\"line `{}` has {} words, expected at least {}\",\n                    line, words.len(), prefix_words_count)\n        );\n    }\n    if (words.len() - prefix_words_count) % T::WORD_COUNT != 0 {\n        return Err(\n            format!(\"line `{}` has {} words, expected {} + {}\",\n                    line, words.len(), prefix_words_count, n)\n        );\n    }\n    Ok(words)\n}\n#[macro_export]\nmacro_rules! readable_collection {\n    ($u:ident => $collection_in:ty, $collection_out:ty) => {\n        readable_collection!($u: => $collection_in, $collection_out);\n    };\n    ($u:ident : $( $bound:path ),* => $collection_in:ty, $collection_out:ty) => {\n        impl<$u: Readable> ReadableFromLine for $collection_in\n        where\n            <$u as Readable>::Output: Sized $(+ $bound)*\n        {\n            type Output = $collection_out;\n            fn read_line(line: &str) -> Result<Self::Output, String> {\n                let words = split_into_words_for_collection::<$u>(line, 0)?;\n                Ok(read_words_into_vec::<$u>(&words, line)?.into_iter().collect())\n            }\n        }\n        impl<T1: Readable, $u: Readable> ReadableFromLine for (T1, $collection_in)\n        where\n            <$u as Readable>::Output: Sized $(+ $bound)*\n        {\n            type Output = (T1::Output, $collection_out);\n            fn read_line(line: &str) -> Result<Self::Output, String> {\n                let prefix_len = T1::WORD_COUNT;\n                let words = split_into_words_for_collection::<$u>(line, prefix_len)?;\n                let val1 = T1::read_words(&words[..prefix_len])?;\n                let rest = read_words_into_vec::<$u>(&words[prefix_len..], line)?;\n                Ok((val1, rest.into_iter().collect()))\n            }\n        }\n        impl<T1: Readable, T2: Readable, $u: Readable> ReadableFromLine for (T1, T2, $collection_in)\n        where\n            <$u as Readable>::Output: Sized $(+ $bound)*\n        {\n            type Output = (T1::Output, T2::Output, $collection_out);\n            fn read_line(line: &str) -> Result<Self::Output, String> {\n                let prefix_len = <(T1, T2)>::WORD_COUNT;\n                let words = split_into_words_for_collection::<$u>(line, prefix_len)?;\n                let mut start = 0;\n                let count1 = T1::WORD_COUNT;\n                let val1 = T1::read_words(&words[start .. start+count1])?;\n                start += count1;\n                let count2 = T2::WORD_COUNT;\n                let val2 = T2::read_words(&words[start .. start+count2])?;\n                let rest = read_words_into_vec::<$u>(&words[prefix_len..], line)?;\n                Ok((val1, val2, rest.into_iter().collect()))\n            }\n        }\n        impl<T1: Readable, T2: Readable, T3: Readable, $u: Readable> ReadableFromLine for (T1, T2, T3, $collection_in)\n        where\n            <$u as Readable>::Output: Sized $(+ $bound)*\n        {\n            type Output = (T1::Output, T2::Output, T3::Output, $collection_out);\n            fn read_line(line: &str) -> Result<Self::Output, String> {\n                let prefix_len = <(T1, T2, T3)>::WORD_COUNT;\n                let words = split_into_words_for_collection::<$u>(line, prefix_len)?;\n                let mut start = 0;\n                let count1 = T1::WORD_COUNT;\n                let val1 = T1::read_words(&words[start .. start+count1])?;\n                start += count1;\n                let count2 = T2::WORD_COUNT;\n                let val2 = T2::read_words(&words[start .. start+count2])?;\n                start += count2;\n                let count3 = T3::WORD_COUNT;\n                let val3 = T3::read_words(&words[start .. start+count3])?;\n                let rest = read_words_into_vec::<$u>(&words[prefix_len..], line)?;\n                Ok((val1, val2, val3, rest.into_iter().collect()))\n            }\n        }\n        impl<T1: Readable, T2: Readable, T3: Readable, T4: Readable, $u: Readable> ReadableFromLine for (T1, T2, T3, T4, $collection_in)\n        where\n            <$u as Readable>::Output: Sized $(+ $bound)*\n        {\n            type Output = (T1::Output, T2::Output, T3::Output, T4::Output, $collection_out);\n            fn read_line(line: &str) -> Result<Self::Output, String> {\n                let prefix_len = <(T1, T2, T3, T4)>::WORD_COUNT;\n                let words = split_into_words_for_collection::<$u>(line, prefix_len)?;\n                let mut start = 0;\n                let count1 = T1::WORD_COUNT;\n                let val1 = T1::read_words(&words[start .. start+count1])?;\n                start += count1;\n                let count2 = T2::WORD_COUNT;\n                let val2 = T2::read_words(&words[start .. start+count2])?;\n                start += count2;\n                let count3 = T3::WORD_COUNT;\n                let val3 = T3::read_words(&words[start .. start+count3])?;\n                start += count3;\n                let count4 = T4::WORD_COUNT;\n                let val4 = T4::read_words(&words[start .. start+count4])?;\n                let rest = read_words_into_vec::<$u>(&words[prefix_len..], line)?;\n                Ok((val1, val2, val3, val4, rest.into_iter().collect()))\n            }\n        }\n    };\n}\nreadable_collection!(U => Vec<U>, Vec<U::Output>);\npub fn read<T: ReadableFromLine>() -> T::Output {\n    let mut line = String::new();\n    std::io::stdin().read_line(&mut line).unwrap();\n    T::read_line(&line).unwrap()\n}\n#[macro_export]\nmacro_rules! read {\n    () => {\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).unwrap();\n    };\n    ( $pat:pat = $t:ty $(,)* ) => {\n        let $pat = read::<$t>();\n    };\n    ( ! $(,)* ) => {\n        let _ = read::<()>();\n    };\n    ( $pat:pat = $t:ty, $( $rest:tt )+ ) => {\n        read_inner!($pat = $t; $($rest)+);\n    };\n    ( !, $( $rest:tt )+ ) => {\n        read_inner!(_ = (); $($rest)+);\n    };\n}\n#[macro_export]\n#[doc(hidden)]\nmacro_rules! read_inner {\n    ( $( $acc_pat:pat = $acc_t:ty ),+ ; $pat:pat = $t:ty, $( $rest:tt )* ) => {\n        read_inner!($( $acc_pat = $acc_t ),+ , $pat = $t ; $($rest)*);\n    };\n    ( $( $acc_pat:pat = $acc_t:ty ),+ ; !, $( $rest:tt )* ) => {\n        read_inner!($( $acc_pat = $acc_t ),+ , _ = () ; $($rest)*);\n    };\n    ( $( $acc_pat:pat = $acc_t:ty ),+ ; $pat:pat = $t:ty ) => {\n        read_inner!($( $acc_pat = $acc_t ),+ , $pat = $t ;);\n    };\n    ( $( $acc_pat:pat = $acc_t:ty ),+ ; ! ) => {\n        read_inner!($( $acc_pat = $acc_t ),+ , _ = () ;);\n    };\n    ( $( $pat:pat = $t:ty ),+ ; ) => {\n        let ($($pat),+) = read::<($($t),+)>();\n    };\n}\npub trait ReadableFromChunk {\n    type Output;\n    fn lines_count() -> usize;\n    fn read_chunk(lines: &[String]) -> Result<Self::Output, String>;\n}\nimpl<T1: ReadableFromLine, T2: ReadableFromLine> ReadableFromChunk for (T1, T2) {\n    type Output = (T1::Output, T2::Output);\n    fn lines_count() -> usize { 2 }\n    fn read_chunk(lines: &[String]) -> Result<Self::Output, String> {\n        let out1 = T1::read_line(&lines[0])?;\n        let out2 = T2::read_line(&lines[1])?;\n        Ok((out1, out2))\n    }\n}\nimpl<T1: ReadableFromLine, T2: ReadableFromLine, T3: ReadableFromLine> ReadableFromChunk for (T1, T2, T3) {\n    type Output = (T1::Output, T2::Output, T3::Output);\n    fn lines_count() -> usize { 3 }\n    fn read_chunk(lines: &[String]) -> Result<Self::Output, String> {\n        let out1 = T1::read_line(&lines[0])?;\n        let out2 = T2::read_line(&lines[1])?;\n        let out3 = T3::read_line(&lines[2])?;\n        Ok((out1, out2, out3))\n    }\n}\nimpl<T1: ReadableFromLine, T2: ReadableFromLine, T3: ReadableFromLine, T4: ReadableFromLine> ReadableFromChunk for (T1, T2, T3, T4) {\n    type Output = (T1::Output, T2::Output, T3::Output, T4::Output);\n    fn lines_count() -> usize { 4 }\n    fn read_chunk(lines: &[String]) -> Result<Self::Output, String> {\n        let out1 = T1::read_line(&lines[0])?;\n        let out2 = T2::read_line(&lines[1])?;\n        let out3 = T3::read_line(&lines[2])?;\n        let out4 = T4::read_line(&lines[3])?;\n        Ok((out1, out2, out3, out4))\n    }\n}\npub fn read_chunk<T: ReadableFromChunk>() -> T::Output {\n    let stdin = std::io::stdin();\n    let mut handle = stdin.lock();\n    read_chunk_from_handle::<T>(&mut handle).unwrap()\n}\nfn read_chunk_from_handle<T: ReadableFromChunk>(handle: &mut std::io::StdinLock) -> Option<T::Output> {\n    use std::io::BufRead;\n    let mut lines = vec![String::new(); T::lines_count()];\n    let mut first = true;\n    for line in &mut lines {\n        if handle.read_line(line).unwrap() == 0 && first {\n            return None;\n        }\n        first = false;\n    }\n    Some(T::read_chunk(&lines).unwrap())\n}\n#[macro_export]\nmacro_rules! read_chunk {\n    ( $( $pat:pat = $t:ty ),+ ) => {\n        let ($($pat),+) = read_chunk::<($($t),+)>();\n    };\n}\nstatic mut STDIN: Option<std::io::Stdin> = None;\npub struct ReadLines<T: ReadableFromLine> {\n    lock: std::io::StdinLock<'static>,\n    phantom: std::marker::PhantomData<T>\n}\nimpl<T: ReadableFromLine> Iterator for ReadLines<T> {\n    type Item = T::Output;\n    fn next(&mut self) -> Option<T::Output> {\n        use std::io::BufRead;\n        let mut line = String::new();\n        if self.lock.read_line(&mut line).unwrap() > 0 {\n            Some(T::read_line(&line).unwrap())\n        } else {\n            None\n        }\n    }\n}\npub fn read_lines<T: ReadableFromLine>() -> ReadLines<T> {\n    unsafe {\n        if STDIN.is_none() {\n            STDIN = Some(std::io::stdin());\n        }\n    }\n    ReadLines {\n        lock: unsafe { STDIN.as_ref().unwrap().lock() },\n        phantom: std::marker::PhantomData::<T>\n    }\n}\npub struct ReadChunks<T: ReadableFromChunk> {\n    lock: std::io::StdinLock<'static>,\n    phantom: std::marker::PhantomData<T>\n}\nimpl<T: ReadableFromChunk> Iterator for ReadChunks<T> {\n    type Item = T::Output;\n    fn next(&mut self) -> Option<T::Output> {\n        read_chunk_from_handle::<T>(&mut self.lock)\n    }\n}\npub fn read_chunks<T: ReadableFromChunk>() -> ReadChunks<T> {\n    unsafe {\n        if STDIN.is_none() {\n            STDIN = Some(std::io::stdin());\n        }\n    }\n    ReadChunks {\n        lock: unsafe { STDIN.as_ref().unwrap().lock() },\n        phantom: std::marker::PhantomData::<T>\n    }\n}\npub trait Words {\n    fn read<T: Readable>(&self) -> T::Output;\n}\nimpl<'a> Words for [&'a str] {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(self).unwrap()\n    }\n}\nimpl<'a> Words for &'a str {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(&[self]).unwrap()\n    }\n}\n\n// SNIPPET utils\n#[macro_export]\nmacro_rules! echo {\n    () => {\n        println!()\n    };\n    ($e: expr $(,)?) => {\n        println!(\"{}\", $e)\n    };\n    ($e: expr, $($es: expr),+ $(,)?) => {\n        {\n            use std::io::Write;\n            let stdout = std::io::stdout();\n            let mut handle = stdout.lock();\n            write!(handle, \"{}\", $e).unwrap();\n            $(\n                write!(handle, \" {}\", $es).unwrap();\n            )+\n            writeln!(handle).unwrap();\n        }\n    };\n}\npub fn yn(result: bool) {\n    if result {\n        println!(\"Yes\");\n    } else {\n        println!(\"No\");\n    }\n}\n#[allow(non_snake_case)]\npub fn YN(result: bool) {\n    if result {\n        println!(\"YES\");\n    } else {\n        println!(\"NO\");\n    }\n}\npub fn exit(msg: impl std::fmt::Display) -> ! {\n    println!(\"{}\", msg);\n    std::process::exit(0)\n}\n#[macro_export]\n#[cfg(local)]\nmacro_rules! dbg {\n    () => {\n        {\n            use std::io::{self, Write};\n            writeln!(io::stderr(), \"{}: dbg\", line!()).unwrap();\n        }\n    };\n    ($e: expr) => {\n        {\n            use std::io::{self, Write};\n            let result = $e;\n            writeln!(io::stderr(), \"{}: {} = {:?}\",\n                     line!(), stringify!($e), result)\n                .unwrap();\n            result\n        }\n    }\n}\n#[macro_export]\n#[cfg(not(local))]\nmacro_rules! dbg {\n    () => {};\n    ($e: expr) => {\n        { $e }\n    }\n}\n\n// SNIPPET cmp\nuse std::cmp::{Ord, Ordering};\npub fn minmax<T: Ord>(a: T, b: T) -> (T, T) {\n    if a <= b { (a, b) } else { (b, a) }\n}\n#[macro_export]\nmacro_rules! chmin {\n    ($place: expr, $expr: expr) => {\n        let value = $expr;\n        if value < $place {\n            $place = value;\n        }\n    }\n}\n#[macro_export]\nmacro_rules! chmax {\n    ($place: expr, $expr: expr) => {\n        let value = $expr;\n        if value > $place {\n            $place = value;\n        }\n    }\n}\n#[derive(Clone, Copy, PartialEq, Eq, Debug, Default, Hash)]\npub struct Reverse<T: Ord>(pub T);\nimpl<T: Ord> PartialOrd for Reverse<T> {\n    fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\nimpl<T: Ord> Ord for Reverse<T> {\n    fn cmp(&self, other: &Reverse<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\npub trait SortDesc<T> {\n    fn sort_desc(&mut self) where T: Ord;\n    fn sort_desc_by<F>(&mut self, cmp: F)\n    where\n        F: FnMut(&T, &T) -> std::cmp::Ordering;\n    fn sort_desc_by_key<K: Ord, F: FnMut(&T) -> K>(&mut self, key: F);\n    fn sort_unstable_desc(&mut self) where T: Ord;\n    fn sort_unstable_desc_by<F>(&mut self, cmp: F)\n    where\n        F: FnMut(&T, &T) -> std::cmp::Ordering;\n    fn sort_unstable_desc_by_key<K: Ord, F: FnMut(&T) -> K>(&mut self, key: F);\n}\nimpl<T> SortDesc<T> for [T] {\n    fn sort_desc(&mut self) where T: Ord {\n        self.sort_by(|x, y| y.cmp(x));\n    }\n    fn sort_desc_by<F>(&mut self, mut cmp: F)\n    where\n        F: FnMut(&T, &T) -> std::cmp::Ordering\n    {\n        self.sort_by(|x, y| cmp(y, x));\n    }\n    fn sort_desc_by_key<K: Ord, F: FnMut(&T) -> K>(&mut self, mut key: F) {\n        self.sort_by_key(|x| Reverse(key(x)));\n    }\n    fn sort_unstable_desc(&mut self) where T: Ord {\n        self.sort_unstable_by(|x, y| y.cmp(x));\n    }\n    fn sort_unstable_desc_by<F>(&mut self, mut cmp: F)\n    where\n        F: FnMut(&T, &T) -> std::cmp::Ordering\n    {\n        self.sort_unstable_by(|x, y| cmp(y, x));\n    }\n    fn sort_unstable_desc_by_key<K: Ord, F: FnMut(&T) -> K>(&mut self, mut key: F) {\n        self.sort_unstable_by_key(|x| Reverse(key(x)));\n    }\n}\n#[derive(Clone, Copy, PartialEq, PartialOrd, Debug, Default, Hash)]\npub struct Total<T: PartialOrd + PartialEq>(pub T);\nimpl<T: PartialOrd + PartialEq> Eq for Total<T> {}\nimpl<T: PartialOrd + PartialEq> Ord for Total<T> {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.partial_cmp(other).unwrap()\n    }\n}\npub trait IteratorMinmax: Iterator {\n    fn minmax(self) -> Option<(Self::Item, Self::Item)>;\n    fn minmax_by_key<K, F>(self, key_fn: F) -> Option<(Self::Item, Self::Item)>\n    where\n        K: Ord,\n        F: FnMut(&Self::Item) -> K;\n    fn minmax_by<F>(self, compare: F) -> Option<(Self::Item, Self::Item)>\n    where\n        F: FnMut(&Self::Item, &Self::Item) -> Ordering;\n}\nimpl<T: Ord + Clone, I: Iterator<Item=T>> IteratorMinmax for I {\n    fn minmax(self) -> Option<(Self::Item, Self::Item)> {\n        self.minmax_by(|a, b| a.cmp(b))\n    }\n    fn minmax_by_key<K, F>(self, mut key_fn: F) -> Option<(Self::Item, Self::Item)>\n    where\n        K: Ord,\n        F: FnMut(&Self::Item) -> K\n    {\n        self.minmax_by(|a, b| key_fn(a).cmp(&key_fn(b)))\n    }\n    fn minmax_by<F>(mut self, mut compare: F) -> Option<(Self::Item, Self::Item)>\n    where\n        F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        let first = self.next()?;\n        let second = match self.next() {\n            Some(x) => x,\n            None => return Some((first.clone(), first))\n        };\n        let mut result = minmax(first, second);\n        while let Some(x) = self.next() {\n            let (min, max) = result;\n            result = if compare(&x, &min) == Ordering::Less {\n                (x, max)\n            } else if compare(&max, &x) == Ordering::Less {\n                (min, x)\n            } else {\n                (min, max)\n            };\n        }\n        Some(result)\n    }\n}\npub trait WithCmpIdentity<T>: Sized {\n    fn new(x: T) -> Self;\n    fn inf() -> Self;\n    fn as_option(&self) -> Option<&T>;\n    fn as_option_mut(&mut self) -> Option<&mut T>;\n    fn into_option(self) -> Option<T>;\n    fn is_fin(&self) -> bool {\n        self.as_option().is_some()\n    }\n    fn is_inf(&self) -> bool {\n        self.as_option().is_none()\n    }\n    fn expect_fin(self, msg: &str) -> T {\n        self.into_option().expect(msg)\n    }\n    fn fin(self) -> T {\n        self.into_option().unwrap()\n    }\n    fn fin_or(self, default: T) -> T {\n        self.into_option().unwrap_or(default)\n    }\n    fn fin_or_else<F: FnOnce() -> T>(self, f: F) -> T {\n        self.into_option().unwrap_or_else(f)\n    }\n    fn map_or<U, F: FnOnce(T) -> U>(self, default: U, f: F) -> U {\n        self.into_option().map_or(default, f)\n    }\n    fn map_or_else<U, D, F>(self, default: D, f: F) -> U\n    where\n        D: FnOnce() -> U,\n        F: FnOnce(T) -> U\n    {\n        self.into_option().map_or_else(default, f).into()\n    }\n}\n#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\npub enum MaybeNegInf<T> {\n    Inf,\n    Fin(T)\n}\npub type Max<T> = MaybeNegInf<T>;\n#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\npub enum MaybeInf<T> {\n    Fin(T),\n    Inf\n}\npub type Min<T> = MaybeInf<T>;\nmacro_rules! impl_with_cmp_identity {\n    ($t:ident) => {\n        impl<T> $t<T> {\n            pub fn map<U: Ord, F: FnOnce(T) -> U>(self, f: F) -> $t<U> {\n                match self {\n                    $t::Fin(x) => $t::Fin(f(x)),\n                    $t::Inf => $t::Inf\n                }\n            }\n        }\n        impl<T> WithCmpIdentity<T> for $t<T> {\n            fn new(x: T) -> $t<T> { $t::Fin(x) }\n            fn inf() -> $t<T> { $t::Inf }\n            fn as_option(&self) -> Option<&T> {\n                match self {\n                    $t::Fin(x) => Some(x),\n                    $t::Inf => None\n                }\n            }\n            fn as_option_mut(&mut self) -> Option<&mut T> {\n                match self {\n                    $t::Fin(x) => Some(x),\n                    $t::Inf => None\n                }\n            }\n            fn into_option(self) -> Option<T> {\n                match self {\n                    $t::Fin(x) => Some(x),\n                    $t::Inf => None\n                }\n            }\n        }\n    }\n}\nimpl_with_cmp_identity!(MaybeNegInf);\nimpl_with_cmp_identity!(MaybeInf);\n\n// END SNIPPETS\n// Here is the documentation: https://yoshrc.github.io/rust-atcoder-snippets/atcoder_snippets/index.html\n\nfn dfs(v: usize, adj: &[Vec<usize>], full: &mut [bool]) {\n    if full[v] {\n        return;\n    }\n    full[v] = true;\n    for &next in &adj[v] {\n        dfs(next, adj, full);\n    }\n}\n\nfn main() {\n    read!(n = usize, h = usize, w = usize);\n    let mut cards: Vec<_> = read_lines::<(usize_, usize_, u64)>().collect();\n    cards.sort_desc_by_key(|&(_y, _x, a)| a);\n    let mut vs = VecUnionFindSets::with_items(h + w);\n    let mut adj = vec![Vec::new(); h + w];\n    let mut full = vec![false; h + w];\n    let mut ans = 0;\n    for (y, x, a) in cards {\n        let x = h + x;\n        if full[y] && full[x] {\n            continue;\n        }\n        ans += a;\n\n        if full[y] {\n            dfs(x, &adj, &mut full);\n        } else if full[x] {\n            dfs(y, &adj, &mut full);\n        } else if vs.unite(y, x).unwrap() {\n            adj[y].push(x);\n            adj[x].push(y);\n        } else {\n            dfs(y, &adj, &mut full);\n        }\n    }\n    echo!(ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// SNIPPET vec_union_find_sets\npub struct VecUnionFindSets {\n    set_count: usize,  items: Vec<VecUnionFindNode>\n}\n#[derive(Clone)]\nstruct VecUnionFindNode {\n    parent: std::cell::Cell<usize>,\n    len: usize\n}\nimpl VecUnionFindNode {\n    fn new(item: usize) -> VecUnionFindNode {\n        VecUnionFindNode {\n            parent: std::cell::Cell::new(item),\n            len: 1\n        }\n    }\n}\nimpl VecUnionFindSets {\n    pub fn new() -> VecUnionFindSets {\n        VecUnionFindSets {\n            set_count: 0,\n            items: Vec::new()\n        }\n    }\n    pub fn with_items(items_count: usize) -> VecUnionFindSets {\n        let mut sets = VecUnionFindSets::new();\n        sets.add_items(items_count);\n        sets\n    }\n    fn error_msg(items: &[usize]) -> String {\n        assert!(items.len() == 1 || items.len() == 2);\n        if items.len() == 1 {\n            format!(\"no set contains {}\", items[0])\n        } else {\n            format!(\"no set contains {} and no set contains {}\", items[0], items[1])\n        }\n    }\n    pub fn add_items(&mut self, count: usize) {\n        self.set_count += count;\n        let new_items = (self.items_len()..self.items_len()+count)\n            .map(|i| VecUnionFindNode::new(i));\n        self.items.extend(new_items);\n    }\n    pub fn items_len(&self) -> usize {\n        self.items.len()\n    }\n    fn find(&self, item: usize) -> Option<usize> {\n        if item >= self.items_len() {\n            return None;\n        }\n        fn go(sets: &VecUnionFindSets, item: usize) -> usize {\n            let node = &sets.items[item];\n            if node.parent.get() == item {\n                return item;\n            }\n            let root = go(sets, node.parent.get());\n            sets.items[root].parent.set(root);\n            root\n        }\n        Some(go(self, item))\n    }\n    pub fn count(&self) -> usize {\n        self.set_count\n    }\n    pub fn len_of(&self, item: usize) -> Result<usize, String> {\n        self.find(item).map(|root| self.items[root].len).ok_or_else(|| {\n            VecUnionFindSets::error_msg(&[item])\n        })\n    }\n    pub fn set_eq(&self, item1: usize, item2: usize) -> Result<bool, String> {\n        match (self.find(item1), self.find(item2)) {\n            (Some(root1), Some(root2)) => Ok(root1 == root2),\n            (Some(_), None) => Err(VecUnionFindSets::error_msg(&[item2])),\n            (None, Some(_)) => Err(VecUnionFindSets::error_msg(&[item1])),\n            (None, None) => Err(VecUnionFindSets::error_msg(&[item1, item2])),\n        }\n    }\n    pub fn unite(&mut self, item1: usize, item2: usize) -> Result<bool, String> {\n        match (self.find(item1), self.find(item2)) {\n            (Some(root1), Some(root2)) => {\n                if root1 == root2 {\n                    return Ok(false);\n                }\n                self.set_count -= 1;\n                let (new_root, new_child) = if self.items[root1].len < self.items[root2].len {\n                    (root2, root1)\n                } else {\n                    (root1, root2)\n                };\n                let new_len = self.items[root1].len + self.items[root2].len;\n                self.items[new_root] = VecUnionFindNode {\n                    parent: std::cell::Cell::new(new_root),\n                    len: new_len\n                };\n                self.items[new_child] = VecUnionFindNode {\n                    parent: std::cell::Cell::new(new_root),\n                    len: 0\n                };\n                Ok(true)\n            },\n            (Some(_), None) => Err(VecUnionFindSets::error_msg(&[item2])),\n            (None, Some(_)) => Err(VecUnionFindSets::error_msg(&[item1])),\n            (None, None) => Err(VecUnionFindSets::error_msg(&[item1, item2]))\n        }\n    }\n    pub fn iter_cloned(&self) -> impl Iterator<Item=Vec<usize>> {\n        let mut sets = vec![Vec::new(); self.items_len()];\n        for i in 0..self.items_len() {\n            let repr = self.find(i).unwrap();\n            sets[repr].push(i);\n        }\n        sets.into_iter().filter(|v| !v.is_empty())\n    }\n}\nimpl std::fmt::Debug for VecUnionFindSets {\n    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {\n        write!(f, \"{{\")?;\n        let mut first = true;\n        for set in self.iter_cloned() {\n            if !first {\n                write!(f, \", \")?;\n            }\n            write!(f, \"{:?}\", set)?;\n            first = false;\n        }\n        write!(f, \"}}\")\n    }\n}\n/*\nimpl<T: Eq + std::hash::Hash + std::fmt::Debug> IntoIterator for HashUnionFindSets<T> {\n    type Item = HashSet<T>;\n    type IntoIter = std::collections::hash_map::Values<>;\n    fn into_iter(self) -> Self::IntoIter {\n    }\n}\n*/\n\n// SNIPPET read\npub trait Readable {\n    type Output;\n    const WORD_COUNT: usize;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String>;\n}\n#[macro_export]\nmacro_rules! readable {\n    ( $t:ty, $words_count:expr, |$words:ident| $read_words:expr ) => {\n        impl Readable for $t {\n            type Output = $t;\n            const WORD_COUNT: usize = $words_count;\n            fn read_words($words: &[&str]) -> Result<$t, String> {\n                Ok($read_words)\n            }\n        }\n    };\n}\nreadable!((), 1, |_ss| ());\nreadable!(String, 1, |ss| ss[0].to_string());\nimpl Readable for char {\n    type Output = char;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<char, String> {\n        let chars: Vec<char> = words[0].chars().collect();\n        if chars.len() == 1 {\n            Ok(chars[0])\n        } else {\n            Err(format!(\"cannot parse `{}` as a char\", words[0]))\n        }\n    }\n}\npub struct Chars();\nimpl Readable for Chars {\n    type Output = Vec<char>;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Vec<char>, String> {\n        Ok(words[0].chars().collect())\n    }\n}\npub struct Bytes();\nimpl Readable for Bytes {\n    type Output = Vec<u8>;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Vec<u8>, String> {\n        Ok(words[0].bytes().collect())\n    }\n}\nimpl Readable for i8 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<i8, String> {\n        use std::str::FromStr;\n        i8::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as i8\", words[0])\n        })\n    }\n}\nimpl Readable for u8 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<u8, String> {\n        use std::str::FromStr;\n        u8::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as u8\", words[0])\n        })\n    }\n}\nimpl Readable for i16 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<i16, String> {\n        use std::str::FromStr;\n        i16::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as i16\", words[0])\n        })\n    }\n}\nimpl Readable for u16 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<u16, String> {\n        use std::str::FromStr;\n        u16::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as u16\", words[0])\n        })\n    }\n}\nimpl Readable for i32 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<i32, String> {\n        use std::str::FromStr;\n        i32::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as i32\", words[0])\n        })\n    }\n}\nimpl Readable for u32 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<u32, String> {\n        use std::str::FromStr;\n        u32::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as u32\", words[0])\n        })\n    }\n}\nimpl Readable for i64 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<i64, String> {\n        use std::str::FromStr;\n        i64::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as i64\", words[0])\n        })\n    }\n}\nimpl Readable for u64 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<u64, String> {\n        use std::str::FromStr;\n        u64::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as u64\", words[0])\n        })\n    }\n}\nimpl Readable for i128 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<i128, String> {\n        use std::str::FromStr;\n        i128::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as i64\", words[0])\n        })\n    }\n}\nimpl Readable for u128 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<u128, String> {\n        use std::str::FromStr;\n        u128::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as u64\", words[0])\n        })\n    }\n}\nimpl Readable for isize {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<isize, String> {\n        use std::str::FromStr;\n        <isize>::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as isize\", words[0])\n        })\n    }\n}\nimpl Readable for usize {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<usize, String> {\n        use std::str::FromStr;\n        <usize>::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as usize\", words[0])\n        })\n    }\n}\nimpl Readable for f32 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<f32, String> {\n        use std::str::FromStr;\n        f32::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as f32\", words[0])\n        })\n    }\n}\nimpl Readable for f64 {\n    type Output = Self;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<f64, String> {\n        use std::str::FromStr;\n        f64::from_str(words[0]).map_err(|_| {\n            format!(\"cannot parse `{}` as f64\", words[0])\n        })\n    }\n}\n#[allow(non_camel_case_types)]\npub struct u8_;\nimpl Readable for u8_ {\n    type Output = u8;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        u8::read_words(words).map(|n| n-1)\n    }\n}\n#[allow(non_camel_case_types)]\npub struct u16_;\nimpl Readable for u16_ {\n    type Output = u16;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        u16::read_words(words).map(|n| n-1)\n    }\n}\n#[allow(non_camel_case_types)]\npub struct u32_;\nimpl Readable for u32_ {\n    type Output = u32;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        u32::read_words(words).map(|n| n-1)\n    }\n}\n#[allow(non_camel_case_types)]\npub struct u64_;\nimpl Readable for u64_ {\n    type Output = u64;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        u64::read_words(words).map(|n| n-1)\n    }\n}\n#[allow(non_camel_case_types)]\npub struct usize_;\nimpl Readable for usize_ {\n    type Output = usize;\n    const WORD_COUNT: usize = 1;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        <usize>::read_words(words).map(|n| n-1)\n    }\n}\nimpl<T1: Readable, T2: Readable> Readable for (T1, T2) {\n    type Output = (T1::Output, T2::Output);\n    const WORD_COUNT: usize = T1::WORD_COUNT + T2::WORD_COUNT;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let mut start = 0;\n        let count1 = T1::WORD_COUNT;\n        let val1 = T1::read_words(&words[start .. start+count1])?;\n        start += count1;\n        let val2 = T2::read_words(&words[start..])?;\n        Ok((val1, val2))\n    }\n}\nimpl<T1: Readable, T2: Readable, T3: Readable> Readable for (T1, T2, T3) {\n    type Output = (T1::Output, T2::Output, T3::Output);\n    const WORD_COUNT: usize = T1::WORD_COUNT + T2::WORD_COUNT + T3::WORD_COUNT;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let mut start = 0;\n        let count1 = T1::WORD_COUNT;\n        let val1 = T1::read_words(&words[start .. start+count1])?;\n        start += count1;\n        let count2 = T2::WORD_COUNT;\n        let val2 = T2::read_words(&words[start .. start+count2])?;\n        start += count2;\n        let val3 = T3::read_words(&words[start..])?;\n        Ok((val1, val2, val3))\n    }\n}\nimpl<T1: Readable, T2: Readable, T3: Readable, T4: Readable> Readable for (T1, T2, T3, T4) {\n    type Output = (T1::Output, T2::Output, T3::Output, T4::Output);\n    const WORD_COUNT: usize = T1::WORD_COUNT + T2::WORD_COUNT + T3::WORD_COUNT + T4::WORD_COUNT;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let mut start = 0;\n        let count1 = T1::WORD_COUNT;\n        let val1 = T1::read_words(&words[start .. start+count1])?;\n        start += count1;\n        let count2 = T2::WORD_COUNT;\n        let val2 = T2::read_words(&words[start .. start+count2])?;\n        start += count2;\n        let count3 = T3::WORD_COUNT;\n        let val3 = T3::read_words(&words[start .. start+count3])?;\n        start += count3;\n        let val4 = T4::read_words(&words[start..])?;\n        Ok((val1, val2, val3, val4))\n    }\n}\nimpl<T1: Readable, T2: Readable, T3: Readable, T4: Readable, T5: Readable> Readable for (T1, T2, T3, T4, T5) {\n    type Output = (T1::Output, T2::Output, T3::Output, T4::Output, T5::Output);\n    const WORD_COUNT: usize = T1::WORD_COUNT + T2::WORD_COUNT + T3::WORD_COUNT + T4::WORD_COUNT + T5::WORD_COUNT;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let mut start = 0;\n        let count1 = T1::WORD_COUNT;\n        let val1 = T1::read_words(&words[start .. start+count1])?;\n        start += count1;\n        let count2 = T2::WORD_COUNT;\n        let val2 = T2::read_words(&words[start .. start+count2])?;\n        start += count2;\n        let count3 = T3::WORD_COUNT;\n        let val3 = T3::read_words(&words[start .. start+count3])?;\n        start += count3;\n        let count4 = T4::WORD_COUNT;\n        let val4 = T4::read_words(&words[start .. start+count4])?;\n        start += count4;\n        let val5 = T5::read_words(&words[start..])?;\n        Ok((val1, val2, val3, val4, val5))\n    }\n}\nimpl<T1: Readable, T2: Readable, T3: Readable, T4: Readable, T5: Readable, T6: Readable> Readable for (T1, T2, T3, T4, T5, T6) {\n    type Output = (T1::Output, T2::Output, T3::Output, T4::Output, T5::Output, T6::Output);\n    const WORD_COUNT: usize = T1::WORD_COUNT + T2::WORD_COUNT + T3::WORD_COUNT + T4::WORD_COUNT + T5::WORD_COUNT + T6::WORD_COUNT;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let mut start = 0;\n        let count1 = T1::WORD_COUNT;\n        let val1 = T1::read_words(&words[start .. start+count1])?;\n        start += count1;\n        let count2 = T2::WORD_COUNT;\n        let val2 = T2::read_words(&words[start .. start+count2])?;\n        start += count2;\n        let count3 = T3::WORD_COUNT;\n        let val3 = T3::read_words(&words[start .. start+count3])?;\n        start += count3;\n        let count4 = T4::WORD_COUNT;\n        let val4 = T4::read_words(&words[start .. start+count4])?;\n        start += count4;\n        let count5 = T5::WORD_COUNT;\n        let val5 = T5::read_words(&words[start .. start+count5])?;\n        start += count5;\n        let val6 = T6::read_words(&words[start..])?;\n        Ok((val1, val2, val3, val4, val5, val6))\n    }\n}\nimpl<T: Readable> Readable for [T; 2] {\n    type Output = [T::Output; 2];\n    const WORD_COUNT: usize = T::WORD_COUNT * 2;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let val1 = T::read_words(&words[T::WORD_COUNT*0 .. T::WORD_COUNT*1])?;\n        let val2 = T::read_words(&words[T::WORD_COUNT*1 .. T::WORD_COUNT*2])?;\n        Ok([val1, val2])\n    }\n}\nimpl<T: Readable> Readable for [T; 3] {\n    type Output = [T::Output; 3];\n    const WORD_COUNT: usize = T::WORD_COUNT * 3;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let val1 = T::read_words(&words[T::WORD_COUNT*0 .. T::WORD_COUNT*1])?;\n        let val2 = T::read_words(&words[T::WORD_COUNT*1 .. T::WORD_COUNT*2])?;\n        let val3 = T::read_words(&words[T::WORD_COUNT*2 .. T::WORD_COUNT*3])?;\n        Ok([val1, val2, val3])\n    }\n}\nimpl<T: Readable> Readable for [T; 4] {\n    type Output = [T::Output; 4];\n    const WORD_COUNT: usize = T::WORD_COUNT * 4;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let val1 = T::read_words(&words[T::WORD_COUNT*0 .. T::WORD_COUNT*1])?;\n        let val2 = T::read_words(&words[T::WORD_COUNT*1 .. T::WORD_COUNT*2])?;\n        let val3 = T::read_words(&words[T::WORD_COUNT*2 .. T::WORD_COUNT*3])?;\n        let val4 = T::read_words(&words[T::WORD_COUNT*3 .. T::WORD_COUNT*4])?;\n        Ok([val1, val2, val3, val4])\n    }\n}\nimpl<T: Readable> Readable for [T; 5] {\n    type Output = [T::Output; 5];\n    const WORD_COUNT: usize = T::WORD_COUNT * 5;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let val1 = T::read_words(&words[T::WORD_COUNT*0 .. T::WORD_COUNT*1])?;\n        let val2 = T::read_words(&words[T::WORD_COUNT*1 .. T::WORD_COUNT*2])?;\n        let val3 = T::read_words(&words[T::WORD_COUNT*2 .. T::WORD_COUNT*3])?;\n        let val4 = T::read_words(&words[T::WORD_COUNT*3 .. T::WORD_COUNT*4])?;\n        let val5 = T::read_words(&words[T::WORD_COUNT*4 .. T::WORD_COUNT*5])?;\n        Ok([val1, val2, val3, val4, val5])\n    }\n}\nimpl<T: Readable> Readable for [T; 6] {\n    type Output = [T::Output; 6];\n    const WORD_COUNT: usize = T::WORD_COUNT * 6;\n    fn read_words(words: &[&str]) -> Result<Self::Output, String> {\n        assert_eq!(words.len(), Self::WORD_COUNT);\n        let val1 = T::read_words(&words[T::WORD_COUNT*0 .. T::WORD_COUNT*1])?;\n        let val2 = T::read_words(&words[T::WORD_COUNT*1 .. T::WORD_COUNT*2])?;\n        let val3 = T::read_words(&words[T::WORD_COUNT*2 .. T::WORD_COUNT*3])?;\n        let val4 = T::read_words(&words[T::WORD_COUNT*3 .. T::WORD_COUNT*4])?;\n        let val5 = T::read_words(&words[T::WORD_COUNT*4 .. T::WORD_COUNT*5])?;\n        let val6 = T::read_words(&words[T::WORD_COUNT*5 .. T::WORD_COUNT*6])?;\n        Ok([val1, val2, val3, val4, val5, val6])\n    }\n}\npub trait ReadableFromLine {\n    type Output;\n    fn read_line(line: &str) -> Result<Self::Output, String>;\n}\nfn split_into_words(line: &str) -> Vec<&str> {\n    line.trim_end_matches('\\n').split_whitespace().collect()\n}\nimpl<T: Readable> ReadableFromLine for T {\n    type Output = T::Output;\n    fn read_line(line: &str) -> Result<T::Output, String> {\n        let words = split_into_words(line);\n        if words.len() != T::WORD_COUNT {\n            return Err(format!(\"line `{}` has {} words, expected {}\",\n                               line, words.len(), T::WORD_COUNT));\n        }\n        T::read_words(&words)\n    }\n}\npub fn read_words_into_vec<T: Readable>(words: &[&str], line: &str) -> Result<Vec<T::Output>, String> {\n    let n = T::WORD_COUNT;\n    assert_eq!(words.len() % n, 0);\n    let mut result = Vec::new();\n    for chunk in words.chunks(n) {\n        match T::read_words(chunk) {\n            Ok(v) => result.push(v),\n            Err(msg) => {\n                let fragment_msg = if n == 1 {\n                    format!(\"word {}\", result.len())\n                } else {\n                    let l = result.len();\n                    format!(\"words {}-{}\", n*l + 1, (n+1) * l)\n                };\n                return Err(format!(\n                    \"{} of line `{}`: {}\", fragment_msg, line, msg\n                ));\n            }\n        }\n    }\n    Ok(result)\n}\npub fn split_into_words_for_collection<T: Readable>(\n    line: &str, prefix_words_count: usize\n) -> Result<Vec<&str>, String> {\n    let n = T::WORD_COUNT;\n    let words = split_into_words(line);\n    if words.len() < prefix_words_count {\n        return Err(\n            format!(\"line `{}` has {} words, expected at least {}\",\n                    line, words.len(), prefix_words_count)\n        );\n    }\n    if (words.len() - prefix_words_count) % T::WORD_COUNT != 0 {\n        return Err(\n            format!(\"line `{}` has {} words, expected {} + {}\",\n                    line, words.len(), prefix_words_count, n)\n        );\n    }\n    Ok(words)\n}\n#[macro_export]\nmacro_rules! readable_collection {\n    ($u:ident => $collection_in:ty, $collection_out:ty) => {\n        readable_collection!($u: => $collection_in, $collection_out);\n    };\n    ($u:ident : $( $bound:path ),* => $collection_in:ty, $collection_out:ty) => {\n        impl<$u: Readable> ReadableFromLine for $collection_in\n        where\n            <$u as Readable>::Output: Sized $(+ $bound)*\n        {\n            type Output = $collection_out;\n            fn read_line(line: &str) -> Result<Self::Output, String> {\n                let words = split_into_words_for_collection::<$u>(line, 0)?;\n                Ok(read_words_into_vec::<$u>(&words, line)?.into_iter().collect())\n            }\n        }\n        impl<T1: Readable, $u: Readable> ReadableFromLine for (T1, $collection_in)\n        where\n            <$u as Readable>::Output: Sized $(+ $bound)*\n        {\n            type Output = (T1::Output, $collection_out);\n            fn read_line(line: &str) -> Result<Self::Output, String> {\n                let prefix_len = T1::WORD_COUNT;\n                let words = split_into_words_for_collection::<$u>(line, prefix_len)?;\n                let val1 = T1::read_words(&words[..prefix_len])?;\n                let rest = read_words_into_vec::<$u>(&words[prefix_len..], line)?;\n                Ok((val1, rest.into_iter().collect()))\n            }\n        }\n        impl<T1: Readable, T2: Readable, $u: Readable> ReadableFromLine for (T1, T2, $collection_in)\n        where\n            <$u as Readable>::Output: Sized $(+ $bound)*\n        {\n            type Output = (T1::Output, T2::Output, $collection_out);\n            fn read_line(line: &str) -> Result<Self::Output, String> {\n                let prefix_len = <(T1, T2)>::WORD_COUNT;\n                let words = split_into_words_for_collection::<$u>(line, prefix_len)?;\n                let mut start = 0;\n                let count1 = T1::WORD_COUNT;\n                let val1 = T1::read_words(&words[start .. start+count1])?;\n                start += count1;\n                let count2 = T2::WORD_COUNT;\n                let val2 = T2::read_words(&words[start .. start+count2])?;\n                let rest = read_words_into_vec::<$u>(&words[prefix_len..], line)?;\n                Ok((val1, val2, rest.into_iter().collect()))\n            }\n        }\n        impl<T1: Readable, T2: Readable, T3: Readable, $u: Readable> ReadableFromLine for (T1, T2, T3, $collection_in)\n        where\n            <$u as Readable>::Output: Sized $(+ $bound)*\n        {\n            type Output = (T1::Output, T2::Output, T3::Output, $collection_out);\n            fn read_line(line: &str) -> Result<Self::Output, String> {\n                let prefix_len = <(T1, T2, T3)>::WORD_COUNT;\n                let words = split_into_words_for_collection::<$u>(line, prefix_len)?;\n                let mut start = 0;\n                let count1 = T1::WORD_COUNT;\n                let val1 = T1::read_words(&words[start .. start+count1])?;\n                start += count1;\n                let count2 = T2::WORD_COUNT;\n                let val2 = T2::read_words(&words[start .. start+count2])?;\n                start += count2;\n                let count3 = T3::WORD_COUNT;\n                let val3 = T3::read_words(&words[start .. start+count3])?;\n                let rest = read_words_into_vec::<$u>(&words[prefix_len..], line)?;\n                Ok((val1, val2, val3, rest.into_iter().collect()))\n            }\n        }\n        impl<T1: Readable, T2: Readable, T3: Readable, T4: Readable, $u: Readable> ReadableFromLine for (T1, T2, T3, T4, $collection_in)\n        where\n            <$u as Readable>::Output: Sized $(+ $bound)*\n        {\n            type Output = (T1::Output, T2::Output, T3::Output, T4::Output, $collection_out);\n            fn read_line(line: &str) -> Result<Self::Output, String> {\n                let prefix_len = <(T1, T2, T3, T4)>::WORD_COUNT;\n                let words = split_into_words_for_collection::<$u>(line, prefix_len)?;\n                let mut start = 0;\n                let count1 = T1::WORD_COUNT;\n                let val1 = T1::read_words(&words[start .. start+count1])?;\n                start += count1;\n                let count2 = T2::WORD_COUNT;\n                let val2 = T2::read_words(&words[start .. start+count2])?;\n                start += count2;\n                let count3 = T3::WORD_COUNT;\n                let val3 = T3::read_words(&words[start .. start+count3])?;\n                start += count3;\n                let count4 = T4::WORD_COUNT;\n                let val4 = T4::read_words(&words[start .. start+count4])?;\n                let rest = read_words_into_vec::<$u>(&words[prefix_len..], line)?;\n                Ok((val1, val2, val3, val4, rest.into_iter().collect()))\n            }\n        }\n    };\n}\nreadable_collection!(U => Vec<U>, Vec<U::Output>);\npub fn read<T: ReadableFromLine>() -> T::Output {\n    let mut line = String::new();\n    std::io::stdin().read_line(&mut line).unwrap();\n    T::read_line(&line).unwrap()\n}\n#[macro_export]\nmacro_rules! read {\n    () => {\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).unwrap();\n    };\n    ( $pat:pat = $t:ty $(,)* ) => {\n        let $pat = read::<$t>();\n    };\n    ( ! $(,)* ) => {\n        let _ = read::<()>();\n    };\n    ( $pat:pat = $t:ty, $( $rest:tt )+ ) => {\n        read_inner!($pat = $t; $($rest)+);\n    };\n    ( !, $( $rest:tt )+ ) => {\n        read_inner!(_ = (); $($rest)+);\n    };\n}\n#[macro_export]\n#[doc(hidden)]\nmacro_rules! read_inner {\n    ( $( $acc_pat:pat = $acc_t:ty ),+ ; $pat:pat = $t:ty, $( $rest:tt )* ) => {\n        read_inner!($( $acc_pat = $acc_t ),+ , $pat = $t ; $($rest)*);\n    };\n    ( $( $acc_pat:pat = $acc_t:ty ),+ ; !, $( $rest:tt )* ) => {\n        read_inner!($( $acc_pat = $acc_t ),+ , _ = () ; $($rest)*);\n    };\n    ( $( $acc_pat:pat = $acc_t:ty ),+ ; $pat:pat = $t:ty ) => {\n        read_inner!($( $acc_pat = $acc_t ),+ , $pat = $t ;);\n    };\n    ( $( $acc_pat:pat = $acc_t:ty ),+ ; ! ) => {\n        read_inner!($( $acc_pat = $acc_t ),+ , _ = () ;);\n    };\n    ( $( $pat:pat = $t:ty ),+ ; ) => {\n        let ($($pat),+) = read::<($($t),+)>();\n    };\n}\npub trait ReadableFromChunk {\n    type Output;\n    fn lines_count() -> usize;\n    fn read_chunk(lines: &[String]) -> Result<Self::Output, String>;\n}\nimpl<T1: ReadableFromLine, T2: ReadableFromLine> ReadableFromChunk for (T1, T2) {\n    type Output = (T1::Output, T2::Output);\n    fn lines_count() -> usize { 2 }\n    fn read_chunk(lines: &[String]) -> Result<Self::Output, String> {\n        let out1 = T1::read_line(&lines[0])?;\n        let out2 = T2::read_line(&lines[1])?;\n        Ok((out1, out2))\n    }\n}\nimpl<T1: ReadableFromLine, T2: ReadableFromLine, T3: ReadableFromLine> ReadableFromChunk for (T1, T2, T3) {\n    type Output = (T1::Output, T2::Output, T3::Output);\n    fn lines_count() -> usize { 3 }\n    fn read_chunk(lines: &[String]) -> Result<Self::Output, String> {\n        let out1 = T1::read_line(&lines[0])?;\n        let out2 = T2::read_line(&lines[1])?;\n        let out3 = T3::read_line(&lines[2])?;\n        Ok((out1, out2, out3))\n    }\n}\nimpl<T1: ReadableFromLine, T2: ReadableFromLine, T3: ReadableFromLine, T4: ReadableFromLine> ReadableFromChunk for (T1, T2, T3, T4) {\n    type Output = (T1::Output, T2::Output, T3::Output, T4::Output);\n    fn lines_count() -> usize { 4 }\n    fn read_chunk(lines: &[String]) -> Result<Self::Output, String> {\n        let out1 = T1::read_line(&lines[0])?;\n        let out2 = T2::read_line(&lines[1])?;\n        let out3 = T3::read_line(&lines[2])?;\n        let out4 = T4::read_line(&lines[3])?;\n        Ok((out1, out2, out3, out4))\n    }\n}\npub fn read_chunk<T: ReadableFromChunk>() -> T::Output {\n    let stdin = std::io::stdin();\n    let mut handle = stdin.lock();\n    read_chunk_from_handle::<T>(&mut handle).unwrap()\n}\nfn read_chunk_from_handle<T: ReadableFromChunk>(handle: &mut std::io::StdinLock) -> Option<T::Output> {\n    use std::io::BufRead;\n    let mut lines = vec![String::new(); T::lines_count()];\n    let mut first = true;\n    for line in &mut lines {\n        if handle.read_line(line).unwrap() == 0 && first {\n            return None;\n        }\n        first = false;\n    }\n    Some(T::read_chunk(&lines).unwrap())\n}\n#[macro_export]\nmacro_rules! read_chunk {\n    ( $( $pat:pat = $t:ty ),+ ) => {\n        let ($($pat),+) = read_chunk::<($($t),+)>();\n    };\n}\nstatic mut STDIN: Option<std::io::Stdin> = None;\npub struct ReadLines<T: ReadableFromLine> {\n    lock: std::io::StdinLock<'static>,\n    phantom: std::marker::PhantomData<T>\n}\nimpl<T: ReadableFromLine> Iterator for ReadLines<T> {\n    type Item = T::Output;\n    fn next(&mut self) -> Option<T::Output> {\n        use std::io::BufRead;\n        let mut line = String::new();\n        if self.lock.read_line(&mut line).unwrap() > 0 {\n            Some(T::read_line(&line).unwrap())\n        } else {\n            None\n        }\n    }\n}\npub fn read_lines<T: ReadableFromLine>() -> ReadLines<T> {\n    unsafe {\n        if STDIN.is_none() {\n            STDIN = Some(std::io::stdin());\n        }\n    }\n    ReadLines {\n        lock: unsafe { STDIN.as_ref().unwrap().lock() },\n        phantom: std::marker::PhantomData::<T>\n    }\n}\npub struct ReadChunks<T: ReadableFromChunk> {\n    lock: std::io::StdinLock<'static>,\n    phantom: std::marker::PhantomData<T>\n}\nimpl<T: ReadableFromChunk> Iterator for ReadChunks<T> {\n    type Item = T::Output;\n    fn next(&mut self) -> Option<T::Output> {\n        read_chunk_from_handle::<T>(&mut self.lock)\n    }\n}\npub fn read_chunks<T: ReadableFromChunk>() -> ReadChunks<T> {\n    unsafe {\n        if STDIN.is_none() {\n            STDIN = Some(std::io::stdin());\n        }\n    }\n    ReadChunks {\n        lock: unsafe { STDIN.as_ref().unwrap().lock() },\n        phantom: std::marker::PhantomData::<T>\n    }\n}\npub trait Words {\n    fn read<T: Readable>(&self) -> T::Output;\n}\nimpl<'a> Words for [&'a str] {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(self).unwrap()\n    }\n}\nimpl<'a> Words for &'a str {\n    fn read<T: Readable>(&self) -> T::Output {\n        T::read_words(&[self]).unwrap()\n    }\n}\n\n// SNIPPET utils\n#[macro_export]\nmacro_rules! echo {\n    () => {\n        println!()\n    };\n    ($e: expr $(,)?) => {\n        println!(\"{}\", $e)\n    };\n    ($e: expr, $($es: expr),+ $(,)?) => {\n        {\n            use std::io::Write;\n            let stdout = std::io::stdout();\n            let mut handle = stdout.lock();\n            write!(handle, \"{}\", $e).unwrap();\n            $(\n                write!(handle, \" {}\", $es).unwrap();\n            )+\n            writeln!(handle).unwrap();\n        }\n    };\n}\npub fn yn(result: bool) {\n    if result {\n        println!(\"Yes\");\n    } else {\n        println!(\"No\");\n    }\n}\n#[allow(non_snake_case)]\npub fn YN(result: bool) {\n    if result {\n        println!(\"YES\");\n    } else {\n        println!(\"NO\");\n    }\n}\npub fn exit(msg: impl std::fmt::Display) -> ! {\n    println!(\"{}\", msg);\n    std::process::exit(0)\n}\n#[macro_export]\n#[cfg(local)]\nmacro_rules! dbg {\n    () => {\n        {\n            use std::io::{self, Write};\n            writeln!(io::stderr(), \"{}: dbg\", line!()).unwrap();\n        }\n    };\n    ($e: expr) => {\n        {\n            use std::io::{self, Write};\n            let result = $e;\n            writeln!(io::stderr(), \"{}: {} = {:?}\",\n                     line!(), stringify!($e), result)\n                .unwrap();\n            result\n        }\n    }\n}\n#[macro_export]\n#[cfg(not(local))]\nmacro_rules! dbg {\n    () => {};\n    ($e: expr) => {\n        { $e }\n    }\n}\n\n// SNIPPET cmp\nuse std::cmp::{Ord, Ordering};\npub fn minmax<T: Ord>(a: T, b: T) -> (T, T) {\n    if a <= b { (a, b) } else { (b, a) }\n}\n#[macro_export]\nmacro_rules! chmin {\n    ($place: expr, $expr: expr) => {\n        let value = $expr;\n        if value < $place {\n            $place = value;\n        }\n    }\n}\n#[macro_export]\nmacro_rules! chmax {\n    ($place: expr, $expr: expr) => {\n        let value = $expr;\n        if value > $place {\n            $place = value;\n        }\n    }\n}\n#[derive(Clone, Copy, PartialEq, Eq, Debug, Default, Hash)]\npub struct Reverse<T: Ord>(pub T);\nimpl<T: Ord> PartialOrd for Reverse<T> {\n    fn partial_cmp(&self, other: &Reverse<T>) -> Option<Ordering> {\n        other.0.partial_cmp(&self.0)\n    }\n}\nimpl<T: Ord> Ord for Reverse<T> {\n    fn cmp(&self, other: &Reverse<T>) -> Ordering {\n        other.0.cmp(&self.0)\n    }\n}\npub trait SortDesc<T> {\n    fn sort_desc(&mut self) where T: Ord;\n    fn sort_desc_by<F>(&mut self, cmp: F)\n    where\n        F: FnMut(&T, &T) -> std::cmp::Ordering;\n    fn sort_desc_by_key<K: Ord, F: FnMut(&T) -> K>(&mut self, key: F);\n    fn sort_unstable_desc(&mut self) where T: Ord;\n    fn sort_unstable_desc_by<F>(&mut self, cmp: F)\n    where\n        F: FnMut(&T, &T) -> std::cmp::Ordering;\n    fn sort_unstable_desc_by_key<K: Ord, F: FnMut(&T) -> K>(&mut self, key: F);\n}\nimpl<T> SortDesc<T> for [T] {\n    fn sort_desc(&mut self) where T: Ord {\n        self.sort_by(|x, y| y.cmp(x));\n    }\n    fn sort_desc_by<F>(&mut self, mut cmp: F)\n    where\n        F: FnMut(&T, &T) -> std::cmp::Ordering\n    {\n        self.sort_by(|x, y| cmp(y, x));\n    }\n    fn sort_desc_by_key<K: Ord, F: FnMut(&T) -> K>(&mut self, mut key: F) {\n        self.sort_by_key(|x| Reverse(key(x)));\n    }\n    fn sort_unstable_desc(&mut self) where T: Ord {\n        self.sort_unstable_by(|x, y| y.cmp(x));\n    }\n    fn sort_unstable_desc_by<F>(&mut self, mut cmp: F)\n    where\n        F: FnMut(&T, &T) -> std::cmp::Ordering\n    {\n        self.sort_unstable_by(|x, y| cmp(y, x));\n    }\n    fn sort_unstable_desc_by_key<K: Ord, F: FnMut(&T) -> K>(&mut self, mut key: F) {\n        self.sort_unstable_by_key(|x| Reverse(key(x)));\n    }\n}\n#[derive(Clone, Copy, PartialEq, PartialOrd, Debug, Default, Hash)]\npub struct Total<T: PartialOrd + PartialEq>(pub T);\nimpl<T: PartialOrd + PartialEq> Eq for Total<T> {}\nimpl<T: PartialOrd + PartialEq> Ord for Total<T> {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.partial_cmp(other).unwrap()\n    }\n}\npub trait IteratorMinmax: Iterator {\n    fn minmax(self) -> Option<(Self::Item, Self::Item)>;\n    fn minmax_by_key<K, F>(self, key_fn: F) -> Option<(Self::Item, Self::Item)>\n    where\n        K: Ord,\n        F: FnMut(&Self::Item) -> K;\n    fn minmax_by<F>(self, compare: F) -> Option<(Self::Item, Self::Item)>\n    where\n        F: FnMut(&Self::Item, &Self::Item) -> Ordering;\n}\nimpl<T: Ord + Clone, I: Iterator<Item=T>> IteratorMinmax for I {\n    fn minmax(self) -> Option<(Self::Item, Self::Item)> {\n        self.minmax_by(|a, b| a.cmp(b))\n    }\n    fn minmax_by_key<K, F>(self, mut key_fn: F) -> Option<(Self::Item, Self::Item)>\n    where\n        K: Ord,\n        F: FnMut(&Self::Item) -> K\n    {\n        self.minmax_by(|a, b| key_fn(a).cmp(&key_fn(b)))\n    }\n    fn minmax_by<F>(mut self, mut compare: F) -> Option<(Self::Item, Self::Item)>\n    where\n        F: FnMut(&Self::Item, &Self::Item) -> Ordering\n    {\n        let first = self.next()?;\n        let second = match self.next() {\n            Some(x) => x,\n            None => return Some((first.clone(), first))\n        };\n        let mut result = minmax(first, second);\n        while let Some(x) = self.next() {\n            let (min, max) = result;\n            result = if compare(&x, &min) == Ordering::Less {\n                (x, max)\n            } else if compare(&max, &x) == Ordering::Less {\n                (min, x)\n            } else {\n                (min, max)\n            };\n        }\n        Some(result)\n    }\n}\npub trait WithCmpIdentity<T>: Sized {\n    fn new(x: T) -> Self;\n    fn inf() -> Self;\n    fn as_option(&self) -> Option<&T>;\n    fn as_option_mut(&mut self) -> Option<&mut T>;\n    fn into_option(self) -> Option<T>;\n    fn is_fin(&self) -> bool {\n        self.as_option().is_some()\n    }\n    fn is_inf(&self) -> bool {\n        self.as_option().is_none()\n    }\n    fn expect_fin(self, msg: &str) -> T {\n        self.into_option().expect(msg)\n    }\n    fn fin(self) -> T {\n        self.into_option().unwrap()\n    }\n    fn fin_or(self, default: T) -> T {\n        self.into_option().unwrap_or(default)\n    }\n    fn fin_or_else<F: FnOnce() -> T>(self, f: F) -> T {\n        self.into_option().unwrap_or_else(f)\n    }\n    fn map_or<U, F: FnOnce(T) -> U>(self, default: U, f: F) -> U {\n        self.into_option().map_or(default, f)\n    }\n    fn map_or_else<U, D, F>(self, default: D, f: F) -> U\n    where\n        D: FnOnce() -> U,\n        F: FnOnce(T) -> U\n    {\n        self.into_option().map_or_else(default, f).into()\n    }\n}\n#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\npub enum MaybeNegInf<T> {\n    Inf,\n    Fin(T)\n}\npub type Max<T> = MaybeNegInf<T>;\n#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\npub enum MaybeInf<T> {\n    Fin(T),\n    Inf\n}\npub type Min<T> = MaybeInf<T>;\nmacro_rules! impl_with_cmp_identity {\n    ($t:ident) => {\n        impl<T> $t<T> {\n            pub fn map<U: Ord, F: FnOnce(T) -> U>(self, f: F) -> $t<U> {\n                match self {\n                    $t::Fin(x) => $t::Fin(f(x)),\n                    $t::Inf => $t::Inf\n                }\n            }\n        }\n        impl<T> WithCmpIdentity<T> for $t<T> {\n            fn new(x: T) -> $t<T> { $t::Fin(x) }\n            fn inf() -> $t<T> { $t::Inf }\n            fn as_option(&self) -> Option<&T> {\n                match self {\n                    $t::Fin(x) => Some(x),\n                    $t::Inf => None\n                }\n            }\n            fn as_option_mut(&mut self) -> Option<&mut T> {\n                match self {\n                    $t::Fin(x) => Some(x),\n                    $t::Inf => None\n                }\n            }\n            fn into_option(self) -> Option<T> {\n                match self {\n                    $t::Fin(x) => Some(x),\n                    $t::Inf => None\n                }\n            }\n        }\n    }\n}\nimpl_with_cmp_identity!(MaybeNegInf);\nimpl_with_cmp_identity!(MaybeInf);\n\n// END SNIPPETS\n// Here is the documentation: https://yoshrc.github.io/rust-atcoder-snippets/atcoder_snippets/index.html\n\nfn dfs(v: usize, adj: &[Vec<usize>], full: &mut [bool]) {\n    if full[v] {\n        return;\n    }\n    full[v] = true;\n    for &next in &adj[v] {\n        dfs(next, adj, full);\n    }\n}\n\nfn main() {\n    read!(n = usize, h = usize, w = usize);\n    let mut cards: Vec<_> = read_lines::<(usize_, usize_, u64)>().collect();\n    cards.sort_desc_by_key(|&(_y, _x, a)| a);\n    let mut vs = VecUnionFindSets::with_items(h + w);\n    let mut adj = vec![Vec::new(); h + w];\n    let mut full = vec![false; h + w];\n    let mut ans = 0;\n    for (y, x, a) in cards {\n        let x = h + x;\n        if full[y] && full[x] {\n            continue;\n        }\n        ans += a;\n\n        if full[y] {\n            full[x] = true;\n        } else if full[x] {\n            full[y] = true;\n        } else if vs.unite(y, x).unwrap() {\n            adj[y].push(x);\n            adj[x].push(y);\n        } else {\n            dfs(y, &adj, &mut full);\n        }\n    }\n    echo!(ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\n\nmod disjoint_set {\n    pub struct DisjointSet {\n        parent: Vec<usize>,\n        size: Vec<usize>,\n        edge: Vec<usize>,\n    }\n    impl DisjointSet {\n        pub fn new(n: usize) -> DisjointSet {\n            DisjointSet {\n                parent: (0..n).collect(),\n                size: vec![1; n],\n                edge: vec![0; n],\n            }\n        }\n        pub fn root(&mut self, x: usize) -> usize {\n            if x == self.parent[x] {\n                x\n            } else {\n                let tmp = self.parent[x];\n                self.parent[x] = self.root(tmp);\n                self.parent[x]\n            }\n        }\n        pub fn merge(&mut self, x: usize, y: usize) {\n            let x = self.root(x);\n            let y = self.root(y);\n            if x == y {\n                self.edge[x] += 1;\n                return;\n            }\n            if self.size[x] > self.size[y] {\n                self.size[x] += self.size[y];\n                self.edge[x] += self.edge[y] + 1;\n                self.parent[y] = x;\n            } else {\n                self.size[y] += self.size[x];\n                self.edge[y] += self.edge[x] + 1;\n                self.parent[x] = y;\n            }\n        }\n        pub fn size(&mut self, x: usize) -> usize {\n            let x = self.root(x);\n            self.size[x]\n        }\n        pub fn edge_size(&mut self, x: usize) -> usize {\n            let x = self.root(x);\n            self.edge[x]\n        }\n    }\n}\n\nfn main() {\n    let mut s: String = String::new();\n    std::io::stdin().read_to_string(&mut s).ok();\n    let mut itr = s.trim().split_whitespace();\n    let n: usize = itr.next().unwrap().parse().unwrap();\n    let h: usize = itr.next().unwrap().parse().unwrap();\n    let _: usize = itr.next().unwrap().parse().unwrap();\n\n    let mut edges = Vec::new();\n    for _ in 0..n {\n        let r: usize = itr.next().unwrap().parse::<usize>().unwrap() - 1;\n        let c: usize = itr.next().unwrap().parse::<usize>().unwrap() - 1;\n        let a: usize = itr.next().unwrap().parse().unwrap();\n        edges.push((a, r, c));\n    }\n    edges.sort();\n    edges.reverse();\n\n    let mut ds = disjoint_set::DisjointSet::new(200020);\n    let mut ans = 0;\n    for &(a, r, c) in edges.iter() {\n        if ds.edge_size(r) < ds.size(r) {\n            ans += a;\n            ds.merge(r, h + c);\n        }\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_e\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n\nfn dfs(graph: &Vec<Vec<usize>>, cards: &Vec<(usize, usize, i64)>, taken: &Vec<bool>, visited: &mut Vec<usize>, rt: usize, now: usize, par: usize) -> (i64, usize) {\n    if visited[now] == rt {\n        return (-1, 0);\n    }\n    visited[now] = rt;\n\n    let mut best = (-1, 0);\n    for &ei in graph[now].iter() {\n        if !taken[ei] {\n            if best.0 < cards[ei].2 {\n                best = (cards[ei].2, ei);\n            }\n            continue;\n        }\n        let to = cards[ei].0 + cards[ei].1 - now;\n        if to == par {\n            continue;\n        }\n        let (s, e) = dfs(graph, cards, taken, visited, rt, to, now);\n        if best.0 < s {\n            best = (s, e);\n        }\n    }\n    best\n}\n\nfn main() {\n    input! {\n        n: usize, h: usize, w: usize,\n        cards: [(usize1, usize1, i64); n]\n    };\n    let mut cards = cards;\n    for i in 0..n {\n        cards[i].1 += h;\n    }\n    let mut graph = vec![vec![]; h+w];\n    for (&(i, j, value), ci) in cards.iter().zip(0..n) {\n        graph[i].push(ci);\n        graph[j].push(ci);\n    }\n\n    let mut ans = 0;\n    let mut taken = vec![false; n];\n\n    let mut not_found = vec![];\n    for i in 0..h+w {\n        let mut best = (-1, 0);\n        for &ei in graph[i].iter() {\n            if best.0 < cards[ei].2 && !taken[ei] {\n                best = (cards[ei].2, ei);\n            }\n        }\n        if best.0 >= 1 {\n            ans += best.0;\n            taken[best.1] = true;\n        } else {\n            if graph[i].len() >= 1 {\n                not_found.push(i);\n            }\n        }\n    }\n\n    let mut visited = vec![h+w; h+w];\n    for &idx in not_found.iter() {\n        let (inc, eidx) = dfs(&graph, &cards, &taken, &mut visited, idx, idx, h+w);\n        if inc >= 1 {\n            ans += inc;\n            assert!(!taken[eidx]);\n            taken[eidx] = true;\n        }\n    }\n\n    let mut visited = vec![h+w; h+w];\n    for i in 0..h+w {\n        if graph[i].len() == 0 {\n            continue;\n        }\n        let mut worst = 1e9 as i64;\n        let mut wid = 0;\n        for &ei in &graph[i] {\n            if taken[ei] && worst > cards[ei].2 {\n                worst = cards[ei].2;\n                wid = ei;\n            }\n        }\n        let (inc, eidx) = dfs(&graph, &cards, &taken, &mut visited, i, i, h+w);\n        if worst < inc {\n            ans -= worst;\n            ans += inc;\n            taken[eidx] = true;\n            taken[wid] = false;\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_e\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\n\nfn dfs(graph: &Vec<Vec<usize>>, cards: &Vec<(usize, usize, i64)>, taken: &Vec<bool>, visited: &mut Vec<usize>, rt: usize, now: usize, par: usize) -> (i64, usize) {\n    if visited[now] == rt {\n        return (-1, 0);\n    }\n    visited[now] = rt;\n\n    let mut best = (-1, 0);\n    for &ei in graph[now].iter() {\n        if !taken[ei] {\n            if best.0 < cards[ei].2 {\n                best = (cards[ei].2, ei);\n            }\n            continue;\n        }\n        let to = cards[ei].0 + cards[ei].1 - now;\n        if to == par {\n            continue;\n        }\n        let (s, e) = dfs(graph, cards, taken, visited, rt, to, now);\n        if best.0 < s {\n            best = (s, e);\n        }\n    }\n    best\n}\n\nfn main() {\n    input! {\n        n: usize, h: usize, w: usize,\n        cards: [(usize1, usize1, i64); n]\n    };\n    let mut cards = cards;\n    for i in 0..n {\n        cards[i].1 += h;\n    }\n    let mut graph = vec![vec![]; h+w];\n    for (&(i, j, value), ci) in cards.iter().zip(0..n) {\n        graph[i].push(ci);\n        graph[j].push(ci);\n    }\n\n    let mut ans = 0;\n    let mut taken = vec![false; n];\n\n    let mut not_found = vec![];\n    for i in 0..h+w {\n        let mut best = (-1, 0);\n        for &ei in graph[i].iter() {\n            if best.0 < cards[ei].2 && !taken[ei] {\n                best = (cards[ei].2, ei);\n            }\n        }\n        if best.0 >= 1 {\n            ans += best.0;\n            taken[best.1] = true;\n        } else {\n            if graph[i].len() >= 1 {\n                not_found.push(i);\n            }\n        }\n    }\n\n    let mut visited = vec![h+w; h+w];\n    for &idx in not_found.iter() {\n        let (inc, eidx) = dfs(&graph, &cards, &taken, &mut visited, idx, idx, h+w);\n        if inc >= 1 {\n            ans += inc;\n            taken[eidx] = true;\n        }\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "#[allow(unused_imports)]\nuse std::cmp::*;\n#[allow(unused_imports)]\nuse std::collections::*;\nuse std::io::{Write, BufWriter};\n// https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8\nmacro_rules! input {\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String{\n            bytes\n                .by_ref()\n                .map(|r|r.unwrap() as char)\n                .skip_while(|c|c.is_whitespace())\n                .take_while(|c|!c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, [ $t:tt ]) => {{\n        let len = read_value!($next, usize);\n        (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    }};\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused)]\nmacro_rules! debug {\n    ($($format:tt)*) => (write!(std::io::stderr(), $($format)*).unwrap());\n}\n#[allow(unused)]\nmacro_rules! debugln {\n    ($($format:tt)*) => (writeln!(std::io::stderr(), $($format)*).unwrap());\n}\n\n/**\n * Union-Find tree.\n * Verified by https://atcoder.jp/contests/keyence2019/submissions/4071067\n */\nstruct UnionFind { disj: Vec<usize>, rank: Vec<usize> }\n\nimpl UnionFind {\n    fn new(n: usize) -> Self {\n        let disj = (0..n).collect();\n        UnionFind { disj: disj, rank: vec![0; n] }\n    }\n    fn root(&mut self, x: usize) -> usize {\n        if x != self.disj[x] {\n            let par = self.disj[x];\n            let r = self.root(par);\n            self.disj[x] = r;\n        }\n        self.disj[x]\n    }\n    fn unite(&mut self, x: usize, y: usize) {\n        let mut x = self.root(x);\n        let mut y = self.root(y);\n        if x == y { return }\n        if self.rank[x] > self.rank[y] {\n            std::mem::swap(&mut x, &mut y);\n        }\n        self.disj[x] = y;\n        self.rank[y] = std::cmp::max(self.rank[y], self.rank[x] + 1);\n    }\n    #[allow(unused)]\n    fn is_same_set(&mut self, x: usize, y: usize) -> bool {\n        self.root(x) == self.root(y)\n    }\n}\n\nfn solve() {\n    let out = std::io::stdout();\n    let mut out = BufWriter::new(out.lock());\n    macro_rules! puts {\n        ($($format:tt)*) => (write!(out,$($format)*).unwrap());\n    }\n    input! {\n        n: usize, h: usize, w: usize,\n        rca: [(usize1, usize1, i64); n],\n    }\n    let mut ans = vec![];\n    for (r, c, a) in rca {\n        ans.push((a, r, c));\n    }\n    ans.sort();\n    ans.reverse();\n    let mut uf = UnionFind::new(h + w);\n    let mut tol = vec![1; h + w];\n    let mut tot = 0;\n    for &(val, r, c) in &ans {\n        let v = c + h;\n        if !uf.is_same_set(r, v) {\n            let a = uf.root(r);\n            let b = uf.root(v);\n            let sum = tol[a] + tol[b];\n            if sum >= 1 {\n                uf.unite(a, b);\n                tot += val;\n                let root = uf.root(a);\n                tol[root] = sum - 1;\n            }\n        } else {\n            let a = uf.root(r);\n            if tol[a] >= 1 {\n                tot += val;\n                tol[a] -= 1;\n            }\n        }\n    }\n    puts!(\"{}\\n\", tot);\n}\n\nfn main() {\n    // In order to avoid potential stack overflow, spawn a new thread.\n    let stack_size = 104_857_600; // 100 MB\n    let thd = std::thread::Builder::new().stack_size(stack_size);\n    thd.spawn(|| solve()).unwrap().join().unwrap();\n}\n"
  },
  {
    "language": "Rust",
    "code": "//---------- begin union_find ----------\nmod union_find {\n    pub struct UF {\n        p: Vec<i32>,\n    }\n    #[allow(dead_code)]\n    impl UF {\n        pub fn new(n: usize) -> UF {\n            UF {p: vec![-1; n] }\n        }\n        pub fn init(&mut self) {\n            for p in self.p.iter_mut() {\n                *p = -1;\n            }\n        }\n        pub fn root(&mut self, mut x: usize) -> usize {\n            while self.p[x] >= 0 {\n                x = self.p[x] as usize;\n            }\n            x\n        }\n        pub fn same(&mut self, x: usize, y: usize) -> bool {\n            self.root(x) == self.root(y)\n        }\n        pub fn unite(&mut self, mut x: usize, mut y: usize) {\n            x = self.root(x);\n            y = self.root(y);\n            if x == y {\n                return;\n            }\n            if self.p[x] > self.p[y] {\n                let s = x;\n                x = y;\n                y = s;\n            }\n            self.p[x] += self.p[y];\n            self.p[y] = x as i32;\n        }\n        pub fn get_size(&mut self, x: usize) -> usize {\n            let r = self.root(x);\n            (-self.p[r]) as usize\n        }\n    }\n}\n//---------- end union_find ----------\n//https://qiita.com/tanakh/items/0ba42c7ca36cd29d0ac8 より\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n// ここまで\n\nfn run() {\n    input! {\n        n: usize,\n        h: usize,\n        w: usize,\n        e: [(usize1, usize1, u64); n],\n    }\n    let mut e = e;\n    e.sort_by_key(|e| e.2);\n    let mut u = union_find::UF::new(h + w);\n    let mut cnt = vec![0; h + w];\n    let mut ans = 0;\n    println!(\"\");\n    for &(a, b, c) in e.iter().rev() {\n        let b = b + h;\n        if !u.same(a, b) {\n            let a = u.root(a);\n            let b = u.root(b);\n            u.unite(a, b);\n            let z = u.root(a);\n            cnt[z] += cnt[a ^ b ^ z];\n        }\n        let r = u.root(a);\n        if cnt[r] < u.get_size(r) {\n            cnt[r] += 1;\n            ans += c;\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::{stdin, Read, StdinLock};\nuse std::str::FromStr;\n\nfn main() {\n    let cin = stdin();\n    let mut scan = Scanner::new(cin.lock());\n    let n = scan.read::<usize>();\n    let h = scan.read::<usize>();\n    let w = scan.read::<usize>();\n    let mut edges = vec![];\n    for _ in 0..n {\n        let r = scan.read::<usize>()-1;\n        let c = scan.read::<usize>()-1;\n        let a = scan.read::<i64>();\n        edges.push((a, r ,c));\n    }\n    edges.sort();\n    edges.reverse();\n    let mut utree = Utree::new(h+w+1);\n    let pole = h+w;\n    let mut ret = 0;\n    for &(a, r, c) in &edges {\n        if utree.is_same(r, c+h) {\n            if !utree.is_same(r, pole) && !utree.is_same(c+h, pole) {\n                utree.unite(r, c+h);\n                utree.unite(r, pole);\n                ret += a;\n            } else if !(utree.is_same(r, pole) && utree.is_same(c+h, pole)) {\n                utree.unite(r, c+h);\n                ret += a;\n            }\n        } else {\n            utree.unite(r, c+h);\n            ret += a;\n        }\n    }\n    println!(\"{}\", ret);\n}\n\n#[allow(dead_code)]\npub struct Utree {\n    n: usize,\n    par: Vec<usize>,\n    rank: Vec<usize>,\n    size: Vec<usize>,\n}\n\n\n#[allow(dead_code)]\nimpl Utree {\n    pub fn new(n: usize) -> Utree {\n        Utree {\n            n: n,\n            par: (0..n).collect(),\n            rank: vec![0; n],\n            size: vec![1; n],\n        }\n    }\n\n    fn find(&mut self, x: usize) -> usize {\n        if self.par[x] == x {\n            x\n        } else {\n            let parent = { self.par[x] };\n            let ret = self.find(parent);\n            self.par[x] = ret;\n            ret\n        }\n    }\n\n    pub fn unite(&mut self, mut x: usize, mut y: usize) {\n        x = self.find(x);\n        y = self.find(y);\n        if x == y {\n            return;\n        };\n\n        if self.rank[x] < self.rank[y] {\n            self.par[x] = y;\n            self.size[y] += self.size[x];\n        } else {\n            self.par[y] = x;\n            self.size[x] += self.size[y];\n            if self.rank[x] == self.rank[y] {\n                self.rank[x] += 1;\n            }\n        }\n    }\n\n    pub fn is_same(&mut self, mut x: usize, mut y: usize) -> bool {\n        x = self.find(x);\n        y = self.find(y);\n        x == y\n    }\n\n    fn get_size(&mut self, mut x: usize) -> usize {\n        x = self.find(x);\n        self.size[x]\n    }\n\n    fn size(&mut self) -> usize {\n        let mut hset = std::collections::HashSet::new();\n        for i in 0..self.n {hset.insert(self.find(i));}\n        hset.len()\n    }\n}\n\n\n// region template\n#[allow(dead_code)]\nfn iu(i: isize) -> usize { i as usize }\n\n#[allow(dead_code)]\nfn ui(i: usize) -> isize { i as isize }\n\n#[allow(dead_code, deprecated)]\nfn join<T: std::fmt::Display>(slice: &[T], sep: &str) -> String {\n    let strings = slice.iter().map(|t| format!(\"{}\", t)).collect::<Vec<_>>();\n    strings.connect(sep)\n}\n\n#[allow(dead_code)]\nfn arr<'a, S, T>(n: usize, mut f: S) -> Vec<T> where S: FnMut(usize) -> T + 'a {\n    (0..n).map(|i| f(i)).collect::<Vec<T>>()\n}\n\nstruct Scanner<'a> {\n    cin: StdinLock<'a>,\n}\n\n#[allow(dead_code)]\nimpl<'a> Scanner<'a> {\n    fn new(cin: StdinLock<'a>) -> Scanner<'a> {\n        Scanner { cin: cin }\n    }\n\n    fn read1<T: FromStr>(&mut self) -> Option<T> {\n        let token = self.cin.by_ref().bytes().map(|c| c.unwrap() as char)\n            .skip_while(|c| c.is_whitespace())\n            .take_while(|c| !c.is_whitespace())\n            .collect::<String>();\n        token.parse::<T>().ok()\n    }\n\n    fn read<T: FromStr>(&mut self) -> T {\n        self.read1().unwrap()\n    }\n\n    fn readn<T: FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read::<T>()).collect()\n    }\n\n    fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n// endregion"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\n\nmod disjoint_set {\n    pub struct DisjointSet {\n        parent: Vec<usize>,\n        size: Vec<usize>,\n        edge: Vec<usize>,\n    }\n    impl DisjointSet {\n        pub fn new(n: usize) -> DisjointSet {\n            DisjointSet {\n                parent: (0..n).collect(),\n                size: vec![1; n],\n                edge: vec![0; n],\n            }\n        }\n        pub fn root(&mut self, x: usize) -> usize {\n            if x == self.parent[x] {\n                x\n            } else {\n                let tmp = self.parent[x];\n                self.parent[x] = self.root(tmp);\n                self.parent[x]\n            }\n        }\n        pub fn merge(&mut self, x: usize, y: usize) {\n            let x = self.root(x);\n            let y = self.root(y);\n            if x == y {\n                self.edge[x] += 1;\n                return;\n            }\n            if self.size[x] > self.size[y] {\n                self.size[x] += self.size[y];\n                self.edge[x] += self.edge[y] + 1;\n                self.parent[y] = x;\n            } else {\n                self.size[y] += self.size[x];\n                self.edge[y] += self.edge[x] + 1;\n                self.parent[x] = y;\n            }\n        }\n        pub fn same(&mut self, x: usize, y: usize) -> bool {\n            self.root(x) == self.root(y)\n        }\n        pub fn size(&mut self, x: usize) -> usize {\n            let x = self.root(x);\n            self.size[x]\n        }\n        pub fn edge_size(&mut self, x: usize) -> usize {\n            let x = self.root(x);\n            self.edge[x]\n        }\n    }\n}\n\nfn main() {\n    let mut s: String = String::new();\n    std::io::stdin().read_to_string(&mut s).ok();\n    let mut itr = s.trim().split_whitespace();\n    let n: usize = itr.next().unwrap().parse().unwrap();\n    let h: usize = itr.next().unwrap().parse().unwrap();\n    let _w: usize = itr.next().unwrap().parse().unwrap();\n\n    let mut edges = Vec::new();\n    for _ in 0..n {\n        let r: usize = itr.next().unwrap().parse::<usize>().unwrap() - 1;\n        let c: usize = itr.next().unwrap().parse::<usize>().unwrap() - 1;\n        let a: usize = itr.next().unwrap().parse().unwrap();\n        edges.push((a, r, c));\n    }\n    edges.sort();\n    edges.reverse();\n\n    let mut ds = disjoint_set::DisjointSet::new(200020);\n    let mut ans = 0;\n    for &(a, r, c) in edges.iter() {\n        if ds.same(r, h + c) {\n            if ds.edge_size(r) < ds.size(r) {\n                ans += a;\n                ds.merge(r, h + c);\n            }\n        } else {\n            if ds.edge_size(r) + ds.edge_size(h + c) < ds.size(r) + ds.size(h + c) {\n                ans += a;\n                ds.merge(r, h + c);\n            }\n        }\n    }\n    println!(\"{}\", ans);\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n: usize = sc.read();\n    let h: usize = sc.read();\n    let w: usize = sc.read();\n\n    let mut uf = UnionFind::new(h + w);\n    let mut edges = vec![];\n    for _ in 0..n {\n        let row = sc.read::<usize>() - 1;\n        let col = sc.read::<usize>() - 1;\n        let value: u64 = sc.read();\n        edges.push((value, row, col + h));\n    }\n    edges.sort();\n\n    let mut ans = 0;\n    for (value, row, col) in edges.into_iter().rev() {\n        let x = uf.find(row);\n        let y = uf.find(col);\n        if x != y {\n            uf.unite(x, y);\n            ans += value;\n        } else if uf.sizes[x] > uf.edge_count[x] {\n            uf.edge_count[x] += 1;\n            ans += value;\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n\npub struct UnionFind {\n    parent: Vec<usize>,\n    sizes: Vec<usize>,\n    size: usize,\n    edge_count: Vec<usize>,\n}\n\nimpl UnionFind {\n    pub fn new(n: usize) -> UnionFind {\n        UnionFind {\n            parent: (0..n).map(|i| i).collect::<Vec<usize>>(),\n            sizes: vec![1; n],\n            size: n,\n            edge_count: vec![0; n],\n        }\n    }\n\n    pub fn find(&mut self, x: usize) -> usize {\n        if x == self.parent[x] {\n            x\n        } else {\n            let px = self.parent[x];\n            self.parent[x] = self.find(px);\n            self.parent[x]\n        }\n    }\n\n    pub fn unite(&mut self, x: usize, y: usize) -> bool {\n        let parent_x = self.find(x);\n        let parent_y = self.find(y);\n        if parent_x == parent_y {\n            return false;\n        }\n\n        let (large, small) = if self.sizes[parent_x] < self.sizes[parent_y] {\n            (parent_y, parent_x)\n        } else {\n            (parent_x, parent_y)\n        };\n\n        self.parent[small] = large;\n        self.sizes[large] += self.sizes[small];\n        self.sizes[small] = 0;\n\n        self.edge_count[large] += self.edge_count[small] + 1;\n        self.edge_count[small] = 0;\n\n        self.size -= 1;\n        return true;\n    }\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "fn main() {\n    let s = std::io::stdin();\n    let mut sc = Scanner { stdin: s.lock() };\n    let n: usize = sc.read();\n    let h: usize = sc.read();\n    let w: usize = sc.read();\n    let mut edges = vec![];\n    for _ in 0..n {\n        let r = sc.read::<usize>() - 1;\n        let c = sc.read::<usize>() - 1;\n        let a: usize = sc.read();\n        edges.push((a, r, c + h));\n    }\n\n    edges.sort();\n    edges.reverse();\n    let mut ans = 0;\n    let mut uf = UnionFind::new(h + w);\n    for (v, r, c) in edges.into_iter() {\n        let r = uf.find(r);\n        let c = uf.find(c);\n        if r == c {\n            let edges = uf.edge_count[r];\n            let size = uf.sizes[r];\n            if edges + 1 <= size {\n                uf.edge_count[r] += 1;\n                ans += v;\n            }\n        } else {\n            let edges = uf.edge_count[r] + uf.edge_count[c];\n            let size = uf.sizes[r] + uf.sizes[c];\n            if edges + 1 <= size {\n                uf.unite(r, c);\n                ans += v;\n            }\n        }\n    }\n\n    println!(\"{}\", ans);\n}\n\npub struct UnionFind {\n    parent: Vec<usize>,\n    sizes: Vec<usize>,\n    edge_count: Vec<usize>,\n    size: usize,\n}\n\nimpl UnionFind {\n    pub fn new(n: usize) -> UnionFind {\n        UnionFind {\n            parent: (0..n).map(|i| i).collect::<Vec<usize>>(),\n            sizes: vec![1; n],\n            edge_count: vec![0; n],\n            size: n,\n        }\n    }\n\n    pub fn find(&mut self, x: usize) -> usize {\n        if x == self.parent[x] {\n            x\n        } else {\n            let px = self.parent[x];\n            self.parent[x] = self.find(px);\n            self.parent[x]\n        }\n    }\n\n    pub fn unite(&mut self, x: usize, y: usize) -> bool {\n        let parent_x = self.find(x);\n        let parent_y = self.find(y);\n        if parent_x == parent_y {\n            return false;\n        }\n\n        let (large, small) = if self.sizes[parent_x] < self.sizes[parent_y] {\n            (parent_y, parent_x)\n        } else {\n            (parent_x, parent_y)\n        };\n\n        self.parent[small] = large;\n        self.sizes[large] += self.sizes[small];\n        self.sizes[small] = 0;\n\n        self.edge_count[large] += self.edge_count[small] + 1;\n        self.edge_count[small] = 0;\n\n        self.size -= 1;\n        return true;\n    }\n}\n\npub struct Scanner<R> {\n    stdin: R,\n}\n\nimpl<R: std::io::Read> Scanner<R> {\n    pub fn read<T: std::str::FromStr>(&mut self) -> T {\n        use std::io::Read;\n        let buf = self\n            .stdin\n            .by_ref()\n            .bytes()\n            .map(|b| b.unwrap())\n            .skip_while(|&b| b == b' ' || b == b'\\n')\n            .take_while(|&b| b != b' ' && b != b'\\n')\n            .collect::<Vec<_>>();\n        unsafe { std::str::from_utf8_unchecked(&buf) }\n            .parse()\n            .ok()\n            .expect(\"Parse error.\")\n    }\n    pub fn vec<T: std::str::FromStr>(&mut self, n: usize) -> Vec<T> {\n        (0..n).map(|_| self.read()).collect()\n    }\n    pub fn chars(&mut self) -> Vec<char> {\n        self.read::<String>().chars().collect()\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::io::*;\nuse std::str::FromStr;\n\nfn read<T: FromStr>() -> T {\n    let stdin = stdin();\n    let stdin = stdin.lock();\n    let token: String = stdin\n        .bytes()\n        .map(|c| c.expect(\"failed to read char\") as char)\n        .skip_while(|c| c.is_whitespace())\n        .take_while(|c| !c.is_whitespace())\n        .collect();\n    token.parse().ok().expect(\"failed to parse token\")\n}\n\n#[derive(Copy, Clone)]\nstruct Edge {\n    to: usize,\n    init: i64,\n    cap: i64,\n    cst: i64,\n    rev: usize,\n}\n\nstruct MinCostCirculation {\n    // Input\n    num_vs: usize,\n    adj: Vec<Vec<Edge>>,\n    // Intermediate variables\n    h: Vec<f64>,\n    ex: Vec<i64>,\n    iter: Vec<usize>,\n    visit: Vec<bool>,\n}\n\nimpl MinCostCirculation {\n    fn new(num_vs: usize) -> MinCostCirculation {\n        MinCostCirculation {\n            num_vs: num_vs,\n            adj: vec![vec![]; num_vs],\n            h: vec![0.0; num_vs],\n            ex: vec![0; num_vs],\n            iter: vec![],\n            visit: vec![],\n        }\n    }\n\n    fn add_edge(&mut self, i: usize, j: usize, cap: i64, cst: i64) {\n        let rev = self.adj[j].len();\n        self.adj[i].push(Edge{to: j, init: cap, cap: cap, cst: cst, rev: rev});\n        let rev = self.adj[i].len() - 1;\n        self.adj[j].push(Edge{to: i, init: 0, cap: 0, cst: -cst, rev: rev});\n    }\n\n    fn dfs1(&mut self, v: usize) {\n        self.visit[v] = true;\n        for i in 0..self.adj[v].len() {\n            let b;\n            let to;\n            {\n                let e = &self.adj[v][i];\n                to = e.to;\n                b = e.cap > 0 && !self.visit[e.to] && (e.cst as f64) + self.h[v] - self.h[e.to] < 0.0;\n            }\n            if b {\n                self.dfs1(to);\n            }\n        }\n    }\n\n    fn dfs2(&mut self, v: usize, f: i64) -> i64 {\n        if self.ex[v] < 0 {\n            let d = std::cmp::min(f, -self.ex[v]);\n            self.ex[v] += d;\n            return d;\n        }\n        while self.iter[v] < self.adj[v].len() {\n            let e = self.adj[v][self.iter[v]];\n            if e.cap > 0 && (e.cst as f64) + self.h[v] - self.h[e.to] < 0.0 {\n                let d = self.dfs2(e.to, std::cmp::min(f, e.cap));\n                if d > 0 {\n                    self.adj[v][self.iter[v]].cap -= d;\n                    self.adj[e.to][e.rev].cap += d;\n                    return d;\n                }\n            }\n            self.iter[v] += 1;\n        }\n        return 0;\n    }\n\n    fn solve(&mut self) -> i64 {\n        let mut eps = 0.0;\n        for v in 0..self.num_vs {\n            for e in self.adj[v].iter() {\n                if e.cap > 0 && -e.cst as f64 > eps {\n                    eps = -e.cst as f64;\n                }\n            }\n        }\n        while eps * ((self.num_vs + 1) as f64) > 1.0 {\n            eps /= 4.0;\n            for v in 0..self.num_vs {\n                for i in 0..self.adj[v].len() {\n                    let e = self.adj[v][i];\n                    if e.cap > 0 && (e.cst as f64) + self.h[v] - self.h[e.to] < 0.0 {\n                        self.ex[e.to] += e.cap;\n                        self.ex[v] -= e.cap;\n                        self.adj[e.to][e.rev].cap += e.cap;\n                        self.adj[v][i].cap = 0;\n                        // e.cap = 0;\n                    }\n                }\n            }\n            loop {\n                self.visit = vec![false; self.num_vs];\n                for v in 0..self.num_vs {\n                    if self.ex[v] > 0 {\n                        self.dfs1(v);\n                    }\n                }\n                for v in 0..self.num_vs {\n                    if self.visit[v] {\n                        self.h[v] -= eps;\n                    }\n                }\n                self.iter = vec![0; self.num_vs];\n                let mut ok = true;\n                for v in 0..self.num_vs {\n                    loop {\n                        if self.ex[v] <= 0 {\n                            break;\n                        }\n                        let ex = self.ex[v];\n                        let f = self.dfs2(v, ex);\n                        if f <= 0 {\n                            break;\n                        }\n                        self.ex[v] -= f;\n                    }\n                    if self.ex[v] > 0 {\n                        ok = false;\n                    }\n                }\n                if ok {\n                    break;\n                }\n            }\n        }\n        let mut res = 0;\n        for v in 0..self.num_vs {\n            for e in self.adj[v].iter() {\n                if e.init > e.cap {\n                    res += e.cst * (e.init - e.cap);\n                }\n            }\n        }\n        return res;\n    }\n}\n\nfn main() {\n    let n = read();\n    let h = read();\n    let w = read();\n\n    let mut mcc = MinCostCirculation::new(h + w + n + 1);\n    let s = h + w + n;\n    for y in 0..h {\n        mcc.add_edge(s, y, 1, 0);\n    }\n    for x in 0..w {\n        mcc.add_edge(s, h + x, 1, 0);\n    }\n\n    for i in 0..n {\n        let y = read::<usize>() - 1;\n        let x = read::<usize>() - 1;\n        let a = read::<i64>();\n\n        let v = h + w + i;\n        mcc.add_edge(y, v, 1, 0);\n        mcc.add_edge(h + x, v, 1, 0);\n        mcc.add_edge(v, s, 1, -a);\n    }\n\n    println!(\"{}\", -mcc.solve());\n}\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        let mut next = || { iter.next().unwrap() };\n        input_inner!{next, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let stdin = std::io::stdin();\n        let mut bytes = std::io::Read::bytes(std::io::BufReader::new(stdin.lock()));\n        let mut next = move || -> String {\n            bytes\n                .by_ref()\n                .map(|r| r.unwrap() as char)\n                .skip_while(|c| c.is_whitespace())\n                .take_while(|c| !c.is_whitespace())\n                .collect()\n        };\n        input_inner!{next, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($next:expr) => {};\n    ($next:expr, ) => {};\n\n    ($next:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n\n    ($next:expr, mut $var:ident : $t:tt $($r:tt)*) => {\n        let mut $var = read_value!($next, $t);\n        input_inner!{$next $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($next:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($next, $t)),* )\n    };\n\n    ($next:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n    };\n\n    ($next:expr, [ $t:tt ]) => {\n        {\n            let len = read_value!($next, usize);\n            (0..len).map(|_| read_value!($next, $t)).collect::<Vec<_>>()\n        }\n    };\n\n    ($next:expr, chars) => {\n        read_value!($next, String).chars().collect::<Vec<char>>()\n    };\n\n    ($next:expr, usize1) => {\n        read_value!($next, usize) - 1\n    };\n\n    ($next:expr, $t:ty) => {\n        $next().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_imports)]\nuse std::cmp::{min, max};\nuse std::collections::HashMap;\n\nfn main() {\n    input!{\n        n: usize,\n        h: usize,\n        w: usize,\n        mut rca: [(usize1, usize1, usize); n]\n    }\n    let mut ans = 0;\n    let mut uf = UnionFind::new();\n    for i in 0..h {\n        uf.add_point((i, 0));\n    }\n    for i in 0..w {\n        uf.add_point((i, 1));\n    }\n    rca.sort_by(|x, y| y.2.cmp(&x.2));\n    for &(r, c, a) in &rca {\n        if uf.size(&(r, 0)) == uf.esize(&(r, 0)) && uf.size(&(c, 1)) == uf.esize(&(c, 1)) {\n            continue;\n        }\n        ans += a;\n        uf.union((r, 0), (c, 1));\n    }\n    println!(\"{}\", ans);\n}\n\nstruct UFNode {\n    parent: usize,\n    rank: usize,\n    size: usize,\n    esize: usize\n}\n\nstruct UnionFind<T> where T: std::cmp::Eq + std::hash::Hash {\n    map: HashMap<T,usize>,\n    nodes: Vec<UFNode>,\n    next: usize,\n    n_unions: usize\n}\n\nimpl<T: std::cmp::Eq + std::hash::Hash> UnionFind<T> {\n    fn new() -> UnionFind<T> {\n        UnionFind{map: HashMap::new(), nodes: Vec::new(), next: 0, n_unions: 0}\n    }\n\n    fn add_point(&mut self, x: T) -> usize {\n        let id = self.next;\n        self.map.insert(x,id);\n        self.nodes.push(UFNode{parent: id, rank: 0, size: 1, esize: 0});\n        self.next += 1;\n        self.n_unions += 1;\n        id\n    }\n\n    fn get_id(&self, x: &T) -> Option<usize> {\n        self.map.get(x).map(|x| *x)\n    }\n\n    fn find(&mut self, id: usize) -> usize {\n        let p = self.nodes[id].parent;\n        if p == id {\n            return id;\n        }\n        let pr = self.find(p);\n        self.nodes[id].parent = pr;\n        pr\n    }\n\n    fn union(&mut self, x: T, y: T) {\n        let idx = self.get_id(&x).unwrap_or_else(|| self.add_point(x));\n        let idy = self.get_id(&y).unwrap_or_else(|| self.add_point(y));\n        let xp = self.find(idx);\n        let yp = self.find(idy);\n        if xp == yp {\n            self.nodes[xp].esize += 1;\n            return;\n        }\n        let rx = self.nodes[xp].rank;\n        let ry = self.nodes[yp].rank;\n        if rx < ry {\n            self.nodes[xp].parent = yp;\n        } else if rx > ry {\n            self.nodes[yp].parent = xp;\n        } else {\n            self.nodes[yp].parent = xp;\n            self.nodes[xp].rank += 1;\n        }\n        let size = self.nodes[xp].size + self.nodes[yp].size;\n        let esize = self.nodes[xp].esize + self.nodes[yp].esize + 1;\n        self.nodes[xp].size = size;\n        self.nodes[xp].esize = esize;\n        self.nodes[yp].size = size;\n        self.nodes[yp].esize = esize;\n        self.n_unions -= 1;\n    }\n\n    fn size(&mut self, x: &T) -> usize {\n        let id = self.get_id(x).unwrap();\n        let idp = self.find(id);\n        self.nodes[idp].size\n    }\n\n    fn esize(&mut self, x: &T) -> usize {\n        let id = self.get_id(x).unwrap();\n        let idp = self.find(id);\n        self.nodes[idp].esize\n    }\n}\n"
  },
  {
    "language": "Rust",
    "code": "// https://atcoder.jp/contests/jsc2019-qual/tasks/jsc2019_qual_e\n//\n#![allow(unused_imports)]\nuse std::io::*;\nuse std::fmt::*;\nuse std::str::*;\nuse std::cmp::*;\nuse std::collections::*;\n\nmacro_rules! input {\n    (source = $s:expr, $($r:tt)*) => {\n        let mut iter = $s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n    ($($r:tt)*) => {\n        let s = {\n            use std::io::Read;\n            let mut s = String::new();\n            std::io::stdin().read_to_string(&mut s).unwrap();\n            s\n        };\n        let mut iter = s.split_whitespace();\n        input_inner!{iter, $($r)*}\n    };\n}\n\nmacro_rules! input_inner {\n    ($iter:expr) => {};\n    ($iter:expr, ) => {};\n\n    ($iter:expr, $var:ident : $t:tt $($r:tt)*) => {\n        let $var = read_value!($iter, $t);\n        input_inner!{$iter $($r)*}\n    };\n}\n\nmacro_rules! read_value {\n    ($iter:expr, ( $($t:tt),* )) => {\n        ( $(read_value!($iter, $t)),* )\n    };\n\n    ($iter:expr, [ $t:tt ; $len:expr ]) => {\n        (0..$len).map(|_| read_value!($iter, $t)).collect::<Vec<_>>()\n    };\n\n    ($iter:expr, chars) => {\n        read_value!($iter, String).chars().collect::<Vec<char>>()\n    };\n\n    ($iter:expr, usize1) => {\n        read_value!($iter, usize) - 1\n    };\n\n    ($iter:expr, $t:ty) => {\n        $iter.next().unwrap().parse::<$t>().expect(\"Parse error\")\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! dvec {\n    ($t:expr ; $len:expr) => {\n        vec![$t; $len]\n    };\n\n    ($t:expr ; $len:expr, $($rest:expr),*) => {\n        vec![dvec!($t; $($rest),*); $len]\n    };\n}\n\n#[allow(unused_macros)]\nmacro_rules! debug {\n    ($($a:expr),*) => {\n        println!(concat!($(stringify!($a), \" = {:?}, \"),*), $($a),*);\n    }\n}\n\nstruct UnionFind {\n    n: usize,\n    parent: Vec<usize>,\n    count: Vec<usize>,\n    flag: Vec<bool>\n}\n\nimpl UnionFind {\n    fn new(n: usize) -> Self {\n        let mut p = vec![0; n];\n        for i in 0..n {\n            p[i] = i;\n        }\n        UnionFind { n: n, parent: p, count: vec![1; n], flag: vec![false; n] }\n    }\n\n    fn find(&mut self, a: usize) -> usize {\n        if self.parent[a] == a {\n            return a;\n        }\n        let par = self.parent[a];\n        self.parent[a] = self.find(par);\n        self.parent[a]\n    }\n\n    fn unite(&mut self, a: usize, b: usize) {\n        let a = self.find(a);\n        let b = self.find(b);\n        if a == b {\n            return;\n        }\n        let ca = self.count[a];\n        let cb = self.count[b];\n        let total = ca + cb;\n        self.count[b] = total;\n        self.count[a] = total;\n        let tf = self.flag[a] | self.flag[b];\n        self.flag[a] = tf;\n        self.flag[b] = tf;\n        if ca < cb {\n            self.parent[a] = b;\n        } else {\n            self.parent[b] = a;\n        }\n    }\n\n    fn same(&mut self, a: usize, b: usize) -> bool {\n        self.find(a) == self.find(b)\n    }\n\n    fn count(&mut self, a: usize) -> usize {\n        let a = self.find(a);\n        self.count[a]\n    }\n}\n\nfn main() {\n    input! {\n        n: usize, h: usize, w: usize,\n        cards: [(usize1, usize1, i64); n]\n    };\n    let mut cards = cards;\n    for i in 0..n {\n        cards[i].1 += h;\n    }\n    cards.sort_by_key(|c| -c.2);\n\n\n    let mut score = 0;\n    let mut uf = UnionFind::new(h+w);\n    for c in cards {\n        if uf.same(c.0, c.1) {\n            let cid = uf.find(c.0);\n            if uf.flag[cid] {\n                continue;\n            }\n            uf.flag[cid] = true;\n            score += c.2;\n        } else {\n            let cid1 = uf.find(c.0);\n            let cid2 = uf.find(c.1);\n            if uf.flag[cid1] && uf.flag[cid2] {\n                continue;\n            }\n            uf.unite(c.0, c.1);\n            score += c.2;\n        }\n    }\n    println!(\"{}\", score);\n}\n"
  }
]