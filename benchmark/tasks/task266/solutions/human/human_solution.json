[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define mset(a,b) memset(a,b,sizeof(a))\nusing namespace std;\ntypedef long long ll;\nconst int maxn=550;\nconst int inf=0x3f3f3f3f;\nint _m,_n;//第一个是m多边形,第二个是n多边形\nint X1[105],Y1[105],X2[105],Z2[105];//下标从0开始\ndouble width(int X[],int Y[],int n,double x)//对于n个点的多边形(x,y)\n{\n    double down=1e8,up=-1e8;\n    for(int i=0;i<n;++i)\n    {\n        int x1=X[i],y1=Y[i],x2=X[(i+1)%n],y2=Y[(i+1)%n];\n        if(x1>x2){\n            swap(x1,x2);swap(y1,y2);\n        }\n        if(x>=x1&&x<=x2){\n            double y=y1+(x-x1)*(y2*1.0-y1)/(x2-x1);\n            down=min(down,y);\n            up=max(up,y);\n        }\n    }\n    return max(0.0,up-down);\n}\ndouble f(double x)\n{\n    return width(X1,Y1,_m,x)*width(X2,Z2,_n,x);\n}\ndouble Simpson(double a,double b)//要求a<b\n{\n    double c=(a+b)/2.0;\n    return (b-a)/6.0*(f(a)+4*f(c)+f(b));\n}\nvector<int> sx;\nint main()\n{\n    ios::sync_with_stdio(false);cin.tie(0);\n    while(cin>>_m>>_n)\n    {\n        if(_m==0&&_n==0) return 0;\n        sx.clear();\n        for(int i=0;i<_m;++i){\n            cin>>X1[i]>>Y1[i];\n            sx.push_back(X1[i]);\n        }\n        for(int i=0;i<_n;++i){\n            cin>>X2[i]>>Z2[i];\n            sx.push_back(X2[i]);\n        }\n        sort(sx.begin(),sx.end());\n        int min1=*min_element(X1,X1+_m),max1=*max_element(X1,X1+_m);\n        int min2=*min_element(X2,X2+_n),max2=*max_element(X2,X2+_n);\n        double res=0;\n        for(int i=0;i+1<sx.size();++i)\n        {\n            int a=sx[i],b=sx[i+1];\n            if(a>=min1&&a<=max1&&a>=min2&&a<=max2&&b>=min1&&b<=max1&&b>=min2&&b<=max2)\n            {\n                res+=Simpson(a*1.0,b*1.0);\n            }\n        }\n        cout<<fixed<<setprecision(10)<<res<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint m,n;\nconst double EPS = 1e-11;\nvector<pair<int,int> > Pxy,Pyz;\npair<int,int> tem;\nvector<int> X;\n\n\ndouble width(vector<pair<int,int> > polygon,double x){\n    vector<double> w;\n    for(int i=0;i<polygon.len();i++){\n        pair<int,int> p=polygon[i];\n        pair<int,int> q=polygon[(i+1)%polygon.len()];\n        if((p.first-x)<EPS){\n            w.push_back(1.0*p.second);\n        }\n        else if(p.first<x && x<q.first|| p.first>0 && x>q.first){\n            int x0=p.first;\n            int y0=p.second;\n            int x1=q.first;\n            int y1=q.second;\n            w.push_back(y0+1.0*(y1-y0)*(x-x0)/(x1-x0));\n        }\n    }\n    assert(w.len()>0);\n    vector<double>::iterator maxs=max_element(w.begin(),w.end());\n    vector<double>::iterator mins=min_element(w.begin(),w.end());\n    return (maxs-mins);\n}\n\nint volume(vector<pair<int,int> >Pxy,vector<pair<int,int> >Pxz,vector<int> X){\n    double total=0.0;\n    int xmin = max((*min_element(pxy.begin(), pxy.end())).first,\n                   (*min_element(pxz.begin(), pxz.end())).first);\n    int xmax = min((*max_element(pxy.begin(), pxy.end())).first,\n                   (*max_element(pxz.begin(), pxz.end())).first);\n    sort(X.begin(), X.end());\n    for(int i=0;i<X.len()-1;i++){\n        int a=X[i];\n        int b=X[i+1];\n        if(!(xmin <= a && a <= xmax &&xmin <= b && b<< xmax) ){\n            continue;\n        }\n        double m=(a+b)/2.0;\n        double va = width(Pxy, a)*width(Pxz, a);\n        double vb = width(Pxy, b)*width(Pxz, b);\n        double vm = width(Pxy, m)*width(Pxz, m);\n        double area=((b-a)/6.0)*(va + 4.0*vm + vb);\n        total+=area;\n    }\n    return total;\n}\nint main(){\n    while(cin>>m>>n&&n!=0){\n        for(int i=1;i<=m;i++){\n            cin>>tem.first>>tem.second;\n            Pxy.push_back(tem);\n            X.push_back(x);\n        }\n        for(int j=1;j<=n;j++){\n            cin>>tem.first>>tem.second;\n            Pxz.push_back(tem);\n            X.push_back(x);\n        }\n        cout << fixed << volume(PXY, PXZ, X) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include \"bits/stdc++.h\"\n\n#define _USE_MATH_DEFINES\n#include <cmath>\n#include <cstdlib>\n#include <deque>\n#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#include <iterator>\n#include<complex>\n\nusing namespace std;\n\n#define rep(i,a,b) for(int i=(a), i##_len=(b);i<i##_len;i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\n\n//#define int long long\n#define SZ(x) ((int)(x).size())\n#define pb push_back\n#define mp make_pair\n\ntypedef long long ll;\n//typedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\ntypedef pair<double, int> pdi;\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\n\ntypedef complex<double> P;\ntypedef vector<P> G;\n\nnamespace std\n{\n\tbool operator < (const P& a, const P& b) {\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\ndouble cross(const P& a, const P& b) {\n\treturn imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n\treturn real(conj(a)*b);\n}\n\ndouble dist2P(const P& a, const P& b)\n{\n\treturn dot(a - b, a - b);\n}\n\ndouble distP(const P& a, const P& b)\n{\n\treturn sqrt(dist2P(a, b));\n}\n\ndouble len2P(const P& a)\n{\n\treturn dot(a, a);\n}\n\ndouble lenP(const P& a)\n{\n\treturn sqrt(len2P(a));\n}\n\nstruct L : public vector<P> {\n\tL(const P &a, const P &b) {\n\t\tpush_back(a); push_back(b);\n\t}\n};\n\nstruct C {\n\tP p; double r;\n\tint di;\n\tC(const P &p, double r,int di) : p(p), r(r),di(di) { }\n\tC():p(P(-1,-1)),r(-1),di(-1){}\n\tbool operator<(const C& c)const\n\t{\n\t\treturn r < c.r;\n\t}\n};\n\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;       // counter clockwise\n\tif (cross(b, c) < 0)   return -1;       // clockwise\n\tif (dot(b, c) < 0)     return +2;       // c--a--b on line\n\tif (norm(b) < norm(c)) return -2;       // a--b--c on line\n\treturn 0;\n}\n\nbool intersectLL(const L &l, const L &m) {\n\treturn abs(cross(l[1] - l[0], m[1] - m[0])) > EPS || // non-parallel\n\t\tabs(cross(l[1] - l[0], m[0] - l[0])) < EPS;   // same line\n}\nbool intersectLS(const L &l, const L &s) {\n\treturn cross(l[1] - l[0], s[0] - l[0])*       // s[0] is left of l\n\t\tcross(l[1] - l[0], s[1] - l[0]) < EPS; // s[1] is right of l\n}\nbool intersectLP(const L &l, const P &p) {\n\treturn abs(cross(l[1] - p, l[0] - p)) < EPS;\n}\nbool intersectSS(const L &s, const L &t) {\n\treturn ccw(s[0], s[1], t[0])*ccw(s[0], s[1], t[1]) <= 0 &&\n\t\tccw(t[0], t[1], s[0])*ccw(t[0], t[1], s[1]) <= 0;\n}\nbool intersectSP(const L &s, const P &p) {\n\treturn abs(s[0] - p) + abs(s[1] - p) - abs(s[1] - s[0]) < EPS; // triangle inequality\n}\n\nP projection(const L &l, const P &p) {\n\tdouble t = dot(p - l[0], l[0] - l[1]) / norm(l[0] - l[1]);\n\treturn l[0] + t*(l[0] - l[1]);\n}\nP reflection(const L &l, const P &p) {\n\treturn p + 2.0*(projection(l, p) - p);\n}\ndouble distanceLP(const L &l, const P &p) {\n\treturn abs(p - projection(l, p));\n}\ndouble distanceLL(const L &l, const L &m) {\n\treturn intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\ndouble distanceLS(const L &l, const L &s) {\n\tif (intersectLS(l, s)) return 0;\n\treturn min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\ndouble distanceSP(const L &s, const P &p) {\n\tconst P r = projection(s, p);\n\tif (intersectSP(s, r)) return abs(r - p);\n\treturn min(abs(s[0] - p), abs(s[1] - p));\n}\ndouble distanceSS(const L &s, const L &t) {\n\tif (intersectSS(s, t)) return 0;\n\treturn min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),\n\t\tmin(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n\t//if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble width(double* X, double* Y, int n, double x)\n{\n\tdouble lb = INF, ub = -INF;\n\trep(i, 0, n)\n\t{\n\t\tdouble x1 = X[i], y1 = Y[i], x2 = X[(i + 1) % n], y2 = Y[(i + 1) % n];\n\t\tif ((x1 - x)*(x2 - x) <= 0 && x1 != x2)\n\t\t{\n\t\t\tdouble y = y1 + (y2 - y1) / (x2 - x1)*(x - x1);\n\t\t\tchmin(lb, y);\n\t\t\tchmax(ub, y);\n\t\t}\n\t}\n\treturn max(0.0, ub - lb);\n}\n\ndouble X1[101], Y1[101], X2[101], Z2[101];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint M, N;\n\twhile (true)\n\t{\n\t\tvector<double> xs;\n\t\tcin >> M >> N;\n\t\tif (M + N == 0)break;\n\t\trep(i, 0, M)\n\t\t{\n\t\t\tcin >> X1[i] >> Y1[i];\n\t\t\txs.push_back(X1[i]);\n\t\t}\n\t\trep(i, 0, N)\n\t\t{\n\t\t\tcin >> X2[i] >> Z2[i];\n\t\t\txs.push_back(X2[i]);\n\t\t}\n\t\tsort(xs.begin(), xs.end());\n\n\t\tdouble minx1 = *min_element(X1, X1 + M);\n\t\tdouble maxx1 = *max_element(X1, X1 + M);\n\t\tdouble minx2 = *min_element(X2, X2 + N);\n\t\tdouble maxx2 = *max_element(X2, X2 + N);\n\n\t\tdouble ans = 0.0;\n\t\trep(i, 0, SZ(xs) - 1)\n\t\t{\n\t\t\tdouble a = xs[i], c = xs[i + 1], b = (a + c) / 2;\n\t\t\tif (minx1 <= b&&b <= maxx1&&minx2 <= b&&b <= maxx2)\n\t\t\t{\n\t\t\t\tdouble fa = width(X1, Y1, M,a)*width(X2, Z2, N,a);\n\t\t\t\tdouble fb = width(X1, Y1, M,b)*width(X2, Z2, N,b);\n\t\t\t\tdouble fc = width(X1, Y1, M,c)*width(X2, Z2, N,c);\n\t\t\t\tans += (c - a) / 6 * (fa + 4 * fb + fc);\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%.5lf\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <stack>\n#include <queue>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <list>\n#include <string.h>\nusing namespace std;\ntypedef long long int ll; typedef pair <int, int> P;\nconst double INF = 1000000000; const double EPS = 10e-9;\nint x1[100], y[100], x2[100], z[100];\ndouble width(int *X, int *Y, int n, double x) {\n\tdouble lb = -INF, ub = INF;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x1 = X[i], x2 = X[(i + 1) % n], y1 = Y[i], y2 = Y[(i + 1) % n];\n\t\tif ((x1 - x) * (x2 - x) >= 0) continue;\n\t\tdouble y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n\t\tlb = max(lb, y);\n\t\tub = min(ub, y);\n\t}\n\treturn lb - ub;\n}\nint main()\n{\n\tvector <int> x;\n\tint m, n; cin >> m >> n;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> x1[i] >> y[i];\n\t\tx.push_back(x1[i]);\n\t}\n\tint minx1 = *min_element(x1, x1 + m), maxx1 = *max_element(x1, x1 + m);\n\tint minx2 = *min_element(x2, x2 + n), maxx2 = *max_element(x2, x2 + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x2[i] >> z[i];\n\t\tx.push_back(x2[i]);\n\t}\n\tsort(x.begin(), x.end());\n\tdouble res = 0.0;\n\tfor (int i = 0; i + 1 < m + n; i++)\n\t{\n\t\tint a = x[i], b = x[i + 1], c = (a + b) / 2;\n\t\tif (minx1 < c && c < maxx1 && minx2 < c && c < maxx2)\n\t\t{\n\t\t\tdouble sa = width(x1, y, m, a) * width(x2, z, n, a);\n\t\t\tdouble sb = width(x1, y, m, b) * width(x2, z, n, b);\n\t\t\tdouble sc = width(x1, y, m, c) * width(x2, z, n, c);\n\t\t\tres += (b - a) / 6 * (sa + sb + 4 * sc);\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\n\nconst D EPS = 1e-8;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return EQ(real(a),real(b))?imag(a)<imag(b):real(a)<real(b);\n  }\n  bool operator==(const P &a, const P &b){return EQ(a,b);}\n}\n\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ninline bool para(L a,L b){return abs(cross(a.fs-a.sc,b.fs-b.sc))<EPS;}\n\ninline bool is_cp(L a,L b){\n  if(para(a,b))return false;\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ninline P line_cp(L a,L b){\n  return a.fs+(a.sc-a.fs)*cross(b.sc-b.fs,b.fs-a.fs)/cross(b.sc-b.fs,a.sc-a.fs);\n}\n\nvector<P> p[2];\ninline D len(D x, int id){\n  L l = L( P(x,-1000), P(x,1000) );\n  vector<P> res;\n  rep(i,p[id].size()){\n    L a = L( p[id][i], p[id][(i+1)%p[id].size()] );\n    if(is_cp(a,l)){\n      P cp = line_cp(a,l);\n      if(!EQ(cp,p[id][i]))res.push_back(cp);\n    }else if(para(a,l) && ccw(l.fs,l.sc,a.sc)==0){\n      res.push_back(a.sc);\n    }\n  }\n\n  if(res.size()<2)return 0;\n  return abs(res[0]-res[1]);\n}\n\nint minx[2], maxx[2];\ninline D f(D x){\n  if(EQ(minx[0],x) && EQ(maxx[1],x))return 0;\n  if(EQ(minx[1],x) && EQ(maxx[0],x))return 0;\n  return len(x,0) * len(x,1);\n}\n\nint main(){\n  int m,n;\n  while(cin >> m >> n, m){\n    p[0].resize(m); p[1].resize(n);\n    minx[0] = minx[1] = 1000;\n    maxx[0] = maxx[1] = -1000;\n\n    rep(i,m){\n      int x,y;\n      cin >> x >> y;\n      p[0][i] = P(x,y);\n      minx[0]=min(minx[0],x);\n      maxx[0]=max(maxx[0],x);\n    }\n\n    rep(i,n){\n      int x,z;\n      cin >> x >> z;\n      p[1][i] = P(x,z);\n      minx[1]=min(minx[1],x);\n      maxx[1]=max(maxx[1],x);\n    }\n\n    D ans = 0;\n    for(D i=-100;i<100;i+=1){\n      ans += f(i)+4*f(i+0.5)+f(i+1);\n    }\n    cout << fixed << setprecision(9) << ans/6 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define each(a, b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout <<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout <<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout <<\" \"<<kbrni;cout<<endl\n\nusing namespace std;\n\ntypedef complex<double> C;\ntypedef pair<int,int>P;\n\nnamespace std\n{\n    bool operator < (const C a, const C b) {\n        return a.real() != b.real() ? a.real() < b.real() : a.imag() < b.imag();\n    }\n}\n\nstruct L : public vector<C>\n{\n    L(const C a, const C b) {\n        push_back(a); push_back(b);\n    }\n};\n\nbool eq(double a,double b)\n{\n  return (-EPS<a-b&&a-b<EPS);\n}\n\nbool eq(C c1,C c2)\n{\n  return (eq(c1.real(),c2.real()) && eq(c1.imag(),c2.imag()));\n}\n\n//?????¶??????sqrt\ndouble Sqrt(double x)\n{\n    if(x<0) return 0;\n    else    return sqrt(x);\n}\n\n//??£??????\nC normalize(C c)\n{\n    return c / abs(c);\n}\n\n//?§????(rad)\ndouble getarg(C a,C b){\n    return  arg(b*conj(a));\n}\n\n//??????\ndouble cross(const C a, const C b)\n{\n    return  imag(conj(a)*b);\n}\n//??????\ndouble dot(const C a, const C b)\n{\n    return  real(conj(a)*b);\n}\n\nint ccw(C a, C b, C c)\n{\n    b -= a; c -= a;\n    if (cross(b, c) > 0)   return +1;       // counter clockwise\n    if (cross(b, c) < 0)   return -1;       // clockwise\n    if (dot(b, c) < 0)     return +2;       // c--a--b on line\n    if (norm(b) < norm(c)) return -2;       // a--b--c on line\n    return 0;\n}\n//??´???????????????????????????(????????´??????True)\nbool intersectLL(const L &l, const L &m)\n{\n    return abs(cross(l[1]-l[0], m[1]-m[0])) > EPS || abs(cross(l[1]-l[0], m[0]-l[0])) < EPS;\n}\n//??´?????¨?????????????????????(????????±??????????????¨??????)\nbool intersectLS(const L &l, const L &s)\n{\n    return cross(l[1]-l[0], s[0]-l[0]) * cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n//??´?????¨????????????(??±???)??????\nbool intersectLP(const L &l, const C p)\n{\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n//??????????????????????????????(????????±??????????????¨??????)\nbool intersectSS(const L &s, const L &t)\n{\n    return ccw(s[0],s[1],t[0])*ccw(s[0],s[1],t[1]) <= 0 && ccw(t[0],t[1],s[0])*ccw(t[0],t[1],s[1]) <= 0;\n}\n//????????¨????????????(??±???)??????\nbool intersectSP(const L &s, const C p)\n{\n    return abs(s[0]-p)+abs(s[1]-p)-abs(s[1]-s[0]) < EPS;\n}\n//???p?????´???l???????°???±\nC projection(const L &l, const C p)\n{\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\n//???p?????´???l????????¨??????????§°?§????\nC reflection(const L &l, const C p)\n{\n    return p + (projection(l, p) - p)*2.0;\n}\n//?????¨??´???????????¢\ndouble distanceLP(const L &l, const C p)\n{\n    return abs(p - projection(l, p));\n}\n//??´?????¨??´???????????¢\ndouble distanceLL(const L &l, const L &m)\n{\n    return intersectLL(l, m) ? 0 : distanceLP(l, m[0]);\n}\n//??´?????¨??????????????¢\ndouble distanceLS(const L &l, const L &s)\n{\n    if (intersectLS(l, s)) return 0;\n    return min(distanceLP(l, s[0]), distanceLP(l, s[1]));\n}\n//????????¨???????????¢\ndouble distanceSP(const L &s, const C p)\n{\n    const C r = projection(s, p);\n    if (intersectSP(s, r)) return abs(r - p);\n    return min(abs(s[0] - p), abs(s[1] - p));\n}\n//????????¨??????????????¢\ndouble distanceSS(const L &s, const L &t)\n{\n    if (intersectSS(s, t)) return 0;\n    return min(min(distanceSP(s, t[0]), distanceSP(s, t[1])),min(distanceSP(t, s[0]), distanceSP(t, s[1])));\n}\n//??´???????????????????????????\nC crosspointLL(const L &l, const L &m)\n{\n    double A = cross(l[1] - l[0], m[1] - m[0]);\n    double B = cross(l[1] - l[0], l[1] - m[0]);\n    //????????´????????¨???\n    if(abs(A) < EPS && abs(B) < EPS){\n        return m[0];\n    }\n    return m[0] + B / A * (m[1] - m[0]);\n}\n//?????¨??´????????????\ndouble gettime(C c1,C c2)\n{\n  return (dot(c1,c2) < 0 ? -1.0 : 1.0 ) * abs(c2) / abs(c1);\n}\n//?????¨??´????????????\nvector<C> crosspointCL(C c1,double r1,L l)\n{\n    C a=l[0], b=l[1];\n    vector<C> res;\n    C base=b-a,  target=projection(L(a,b),c1);\n    double length=abs(base), h=abs(c1-target);\n    base/=length;\n    if(r1+EPS<h)    return res;\n    double w=Sqrt(r1*r1-h*h);\n    double LL=gettime(normalize(b-a),target-a)-w,RR=LL+w*2.0;\n    res.push_back(a+base*LL);\n    if(eq(LL,RR))   return res;\n    res.push_back(a+base*RR);\n    return res;\n}\n//?????¨???????????????\nvector<C> crosspointCS(C c1,double r1,L s)\n{\n    vector<C> tmp=crosspointCL(c1,r1,s);\n    vector<C> res;\n    rep(i,tmp.size()){\n        if(eq(abs(s[1]-s[0]),abs(s[0]-tmp[i])+abs(s[1]-tmp[i]))){\n            res.push_back(tmp[i]);\n        }\n    }\n    return res;\n}\n//?????????????????????\nL crosspointCC(const C c1, const double r1, const C c2, const double r2)\n{\n  C a = conj(c2-c1), b = (r2*r2-r1*r1-(c2-c1)*conj(c2-c1)), c = r1*r1*(c2-c1);\n  C d = b*b-4.0*a*c;\n  C z1 = (-b+sqrt(d))/(2.0*a)+c1, z2 = (-b-sqrt(d))/(2.0*a)+c1;\n  return L(z1, z2);\n}\n//?????¨????§???¢?????±?????¨????????¢???\ndouble getarea(C c1,double r1,C a,C b)\n{\n    C va=c1-a,vb=c1-b;\n    double A=abs(va),B=abs(vb);\n    double f=cross(va,vb),d=distanceSP(L(a,b),c1),res=0;\n    if(eq(f,0.0))   return 0;\n    if(A < r1+EPS && B < r1+EPS)    return f*0.5;\n    if(d>r1-EPS)    return r1*r1*M_PI*getarg(va,vb)/(2.0*M_PI);\n    vector<C> u=crosspointCS(c1,r1,L(a,b));\n    u.insert(u.begin(),a),u.push_back(b);\n    for(int i=0;i+1<(int)u.size();i++){\n        res+=getarea(c1,r1,u[i],u[i+1]);\n    }\n    return res;\n}\ndouble getcrossarea(vector<C> t,C c1,double r1)\n{\n    int n=t.size();\n    if(n<3) return 0;\n    double res=0;\n    rep(i,n){\n      C a=t[i], b=t[(i+1)%n];\n      res += getarea(c1,r1,a,b);\n    }\n    return res;\n}\n//??????????±???????\nvector<C> convex_hull(vector<C> ps)\n{\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<C> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++]){\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]){\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) k--;\n    }\n    ch.resize(k-1);\n    return ch;\n}\n//?????§??????\nbool isconvex(const vector<C> &ps)\n{\n    rep(i,ps.size()){\n        if (ccw(ps[(i+ps.size()-1) % ps.size()],ps[i],ps[(i+1) % ps.size()])) return false;\n    }\n    return true;\n}\n//????§???¢?????¢???\ndouble area(const vector<C> &ps)\n{\n    double A = 0;\n    rep(i,ps.size()){\n        A += cross(ps[i],ps[(i+1) % ps.size()]);\n    }\n    return A / 2.0;\n}\n//???????§???¢?????´?????§???????????????????????´????????¢\nvector<C> convex_cut(const vector<C> &ps, const L &l)\n{\n    vector<C> Q;\n    rep(i,ps.size()){\n        C A = ps[i], B = ps[(i+1)%ps.size()];\n        if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n        if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n            Q.push_back(crosspointLL(L(A, B),l));\n    }\n    return Q;\n}\n//??????????§???¢???????????????????????????(0??????????????????,1?????????,2???????????????)\nint contains(const vector<C>& ps, const C p)\n{\n    bool flag = false;\n    rep(i,ps.size()) {\n        C a = ps[i] - p, b = ps[(i+1)%ps.size()] - p;\n        if (imag(a) > imag(b)) swap(a, b);\n        if (imag(a) <= 0 && 0 < imag(b)){\n            if (cross(a, b) < 0) flag = !flag;\n        }\n        if (cross(a, b) == 0 && dot(a, b) <= 0) return 1;\n  }\n  return flag ? 2 : 0;\n}\n//???????§???¢?????´???????±???????(?????£????????????)\n//maxi,maxj?????????????????¨??????\ndouble convex_diameter(const vector<C> &ps)\n{\n    const int n = ps.size();\n    int is = 0, js = 0;\n    for (int i = 1; i < n; ++i) {\n        if (imag(ps[i]) > imag(ps[is])) is = i;\n        if (imag(ps[i]) < imag(ps[js])) js = i;\n    }\n    double maxd = abs(ps[is]-ps[js]);\n    int i, maxi, j, maxj;\n    i = maxi = is;\n    j = maxj = js;\n    do{\n        if (cross(ps[(i+1)%ps.size()]-ps[i],ps[(j+1)%ps.size()]-ps[j]) >= 0) j = (j+1) % n;\n        else i = (i+1) % n;\n        if (abs(ps[i]-ps[j]) > maxd) {\n            maxd = abs(ps[i]-ps[j]);\n            maxi = i; maxj = j;\n        }\n    } while (i != is || j != js);\n    return maxd;\n}\n\nbool compyx(C c1,C c2)\n{\n    return c1.imag() != c2.imag() ? c1.imag() < c2.imag() : c1.real() < c2.real();\n}\n\n//????????????????±???????\ndouble closest_pair(C *a, int n)\n{\n    if(n<=1) return INF;\n    int m=n/2;\n    double x=a[m].real();\n    double d=min(closest_pair(a,m),closest_pair(a+m,n-m));\n    inplace_merge(a,a+m,a+n,compyx);\n    vector<C> b;\n    rep(i,n){\n        if(abs(x-a[i].real())>=d) continue;\n        rep(j,b.size()){\n            C dp=a[i]-b[b.size()-1-j];\n            if(dp.imag()>=d) break;\n            d=min(d,abs(dp));\n        }\n        b.push_back(a[i]);\n    }\n    return d;\n}\ndouble compute_shortest(C *a,int n)\n{\n    sort(a,a+n);\n    return closest_pair(a,n);\n}\n//2??????????????¢????????????(????????????2??????????????±?????\\????????°)\nint getstateCC(C c1,double r1,C c2,double r2)\n{\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)return 4;\n    if(d>r1+r2-EPS)return 3;\n    if(d>abs(r1-r2)+EPS)return 2;\n    if(d>abs(r1-r2)-EPS)return 1;\n    return 0;\n}\n//?????????????????\\???????????????????????\\???\nC gettangentCP_(C c1,double r1,C p,int flg){\n    C base=c1-p;\n    double w=Sqrt(norm(base)-r1*r1);\n    C s=p+base*C(w,r1 * flg)/norm(base)*w;\n    return s;\n}\n//????????????????????\\???\nvector<L> gettangentCP(C c1,double r1,C p){\n    vector<L> res;\n    C s=gettangentCP_(c1,r1,p,1);\n    C t=gettangentCP_(c1,r1,p,-1);\n    //??????????????¨??????????????´???\n    if(eq(s,t)){\n        res.push_back(L(s,s+(c1-p)*C(0,1)));\n    }else{\n        res.push_back(L(p,s));\n        res.push_back(L(p,t));\n    }\n    return res;\n}\n\n//2????????±????????\\???????±???????\nL getintangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double w=r1+r2;\n    double h=Sqrt(norm(base)-w*w);\n    C k=base*C(w,h*flg)/norm(base);\n    return L(c1+k*r1,c2-k*r2);\n}\n//2????????±????????\\???????±???????\nL getouttangent(C c1,double r1,C c2,double r2,double flg)\n{\n    C base=c2-c1;\n    double h=r2-r1;\n    double w=Sqrt(norm(base)-h*h);\n    C k=base*C(w,h*flg)/norm(base)*C(0,flg);\n    return L(c1+k*r1,c2+k*r2);\n}\n//2????????±?????\\???????±???????(?????´??????????????????????????????????????\\???)\nvector<L> gettangentCC(C c1,double r1,C c2,double r2)\n{\n    vector<L> res;\n    double d=abs(c1-c2);\n    if(d>r1+r2+EPS)  res.push_back(getintangent(c1,r1,c2,r2,1));\n    if(d>r1+r2-EPS)  res.push_back(getintangent(c1,r1,c2,r2,-1));\n    if(d>abs(r1-r2)+EPS)    res.push_back(getouttangent(c1,r1,c2,r2,1));\n    if(d>abs(r1-r2)-EPS)    res.push_back(getouttangent(c1,r1,c2,r2,-1));\n    return res;\n}\n\ndouble width(vector<P> vec,int n,double x)\n{\n    double lb = INF,ub = -INF;\n    rep(i,n){\n        L hoge(C(vec[i].fi,vec[i].se),C(vec[(i+1)%n].fi,vec[(i+1)%n].se));\n        L cri(C(x,101),C(x,-101));\n        if(intersectLS(cri,hoge)){\n            C res = crosspointLL(cri,hoge);\n            lb = min(lb,res.imag());\n            ub = max(ub,res.imag());\n        }\n    }\n    return max(0.0,ub-lb);\n}\n\nint main()\n{\n    while(1){\n        int n,m;\n        cin >> m >> n;\n        if(n == 0 && m == 0){\n            break;\n        }\n        vector<P> v1,v2;\n        vector<int> ax;\n        rep(i,m){\n            int x,y;\n            cin >> x >> y;\n            v1.pb(P(x,y));\n            ax.pb(x);\n        }\n        rep(i,n){\n            int x,y;\n            cin >> x >> y;\n            v2.pb(P(x,y));\n            ax.pb(x);\n        }\n        sort(all(ax));\n        ax.erase(unique(all(ax)),ax.end());\n        int mn1 = (*min_element(all(v1))).fi;\n        int mx1 = (*max_element(all(v1))).fi;\n        int mn2 = (*min_element(all(v2))).fi;\n        int mx2 = (*max_element(all(v2))).fi;\n        double res = 0.0;\n        rep(i,ax.size()-1){\n            double a = ax[i],b = ax[i+1],c = (a+b)/2;\n            if(mn1 <= c && c <= mx1 && mn2 <= c && c <= mx2){\n                double fa = width(v1,m,a) * width(v2,n,a);\n                double fb = width(v1,m,b) * width(v2,n,b);\n                double fc = width(v1,m,c) * width(v2,n,c);\n                res += (b - a) / 6 * (fa + 4*fc + fb);\n            }\n        }\n        printf(\"%.10f\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <list>\n#include <string.h>\nusing namespace std;\ntypedef long long int ll; typedef pair <int, int> P;\nconst double INF = 1000000000; const double EPS = 10e-9;\nint x1[100], y[100], x2[100], z[100];\ndouble width(int *X, int *Y, int n, double x) {\n\tdouble lb = -INF, ub = INF;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x1 = X[i], x2 = X[(i + 1) % n], y1 = Y[i], y2 = Y[(i + 1) % n];\n\t\tif ((x1 - x) * (x2 - x) >= 0) continue;\n\t\tdouble y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n\t\tlb = max(lb, y);\n\t\tub = min(ub, y);\n\t}\n\treturn lb - ub;\n}\nint main()\n{\n\tvector <int> x;\n\tint m, n; cin >> m >> n;\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> x1[i] >> y[i];\n\t\tx.push_back(x1[i]);\n\t}\n\tint minx1 = *min_element(x1, x1 + m), maxx1 = *max_element(x1, x1 + m);\n\tint minx2 = *min_element(x2, x2 + n), maxx2 = *max_element(x2, x2 + n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x2[i] >> z[i];\n\t\tx.push_back(x2[i]);\n\t}\n\tsort(x.begin(), x.end());\n\tdouble res = 0.0;\n\tfor (int i = 0; i + 1 < m + n; i++)\n\t{\n\t\tint a = x[i], b = x[i + 1], c = (a + b) / 2;\n\t\tif (minx1 < c && c < maxx1 && minx2 < c && c < maxx2)\n\t\t{\n\t\t\tdouble sa = width(x1, y, m, a) * width(x2, z, n, a);\n\t\t\tdouble sb = width(x1, y, m, b) * width(x2, z, n, b);\n\t\t\tdouble sc = width(x1, y, m, c) * width(x2, z, n, c);\n\t\t\tres += (b - a) / 6 * (sa + sb + 4 * sc);\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", res);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>  \n#include <iostream>\n#include <vector>  \n#include <cstring>  \n#include <algorithm>  \nusing namespace std;  \nconst int maxn = 100 + 10;  \nconst int INF = 100000000;  \n  \nint M, N;  \nint X1[maxn], Y1[maxn];  \nint X2[maxn], Z2[maxn];  \n  \n//计算按x值对多边形切片得到的宽度  \ndouble width(int* X, int* Y, int n, double x)  \n{  \n\tdouble lb = INF, ub = -INF;  \n\tfor (int i = 0; i < n; i++){  \n\t\tdouble x1 = X[i], y1 = Y[i], x2 = X[(i + 1) % n], y2 = Y[(i + 1) % n];  \n\t\t//检查与第i条边是否相交  \n\t\tif ((x1 - x) * (x2 - x) <= 0 && x1 != x2){  \n\t\t\t//计算交点的坐标  \n\t\t\tdouble y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);  \n\t\t\tlb = min(lb, y);  \n\t\t\tub = max(ub, y);  \n\t\t}  \n\t} \n\treturn max(0.0, ub - lb);  \n}  \n  \nvoid solve()  \n{  \n\t//枚举区间的端点  \n\tint min1 = *min_element(X1, X1 + M);  \n\tint max1 = *max_element(X1, X1 + M);  \n\tint min2 = *min_element(X2, X2 + N);  \n\tint max2 = *max_element(X2, X2 + N);  \n\tvector<int> xs;  \n\tfor (int i = 0; i < M; i++)  \n\t\txs.push_back(X1[i]);  \n\tfor (int i = 0; i < N; i++)  \n\t\txs.push_back(X2[i]);  \n\tsort(xs.begin(), xs.end());  \n  \n\tdouble res = 0;  \n\tfor (int i = 0; i + 1 < xs.size(); i++){  \n\t\tdouble a = xs[i], b = xs[i + 1], c = (a + b) / 2;  \n\t\tif (min1 <= c && c <= max1 && min2 <= c && c <= max2){  \n\t\t\t//利用Simpson公式求积分  \n\t\t\tdouble fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);  \n\t\t\tdouble fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);  \n\t\t\tdouble fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);  \n\t\t\tres += (b - a) / 6 * (fa + 4 * fc + fb);  \n\t\t}  \n\t}  \n\tprintf(\"%.10f\\n\", res);  \n}  \n  \nint main()  \n{  \n\twhile (scanf(\"%d%d\", &M, &N), M || N){  \n\t\tfor (int i = 0; i < M; i++){  \n\t\t\tscanf(\"%d%d\", &X1[i], &Y1[i]);  \n\t\t}  \n\t\tfor (int i = 0; i < N; i++){  \n\t\t\tscanf(\"%d%d\", &X2[i], &Z2[i]);  \n\t\t}  \n\t\tsolve();  \n\t}  \n\treturn 0;  \n}  \n"
  },
  {
    "language": "C++",
    "code": "// AOJ 1313\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n#define all(a) (a).begin(), (a).end()\n\nconst int INF = 1 << 30;\n\nint M, N;\nint X1[100], Y1[100];\nint X2[100], Z2[100];\n\ndouble width( int *X, int *Y, int n, double x )\n{\n\tdouble lb = INF, ub = -INF;\n\t\n\trep( i, n )\n\t{\n\t\tdouble x1 = X[i], y1 = Y[i], x2 = X[(i+1)%n], y2 = Y[(i+1)%n];\n\n\t\tif( (x1-x)*(x2-x) <= 0 && x1 != x2 )\n\t\t{\n\t\t\tdouble y = y1+(y2-y1)*(x-x1)/(x2-x1);\n\t\t\tlb = std::min( lb, y );\n\t\t\tub = std::max( ub, y );\n\t\t}\n\t}\n\n\treturn std::max( 0.0, ub-lb );\n}\n\nint main()\n{\n\twhile( scanf( \"%d%d\", &M, &N ), M|N )\n\t{\n\t\trep( i, M )\n\t\t\tscanf( \"%d%d\", X1+i, Y1+i );\n\t\trep( i, N )\n\t\t\tscanf( \"%d%d\", X2+i, Z2+i );\n\n\t\tint min1 = *std::min_element( X1, X1+M ), max1 = *std::max_element( X1, X1+M ),\n\t\t\tmin2 = *std::min_element( X2, X2+N ), max2 = *std::max_element( X2, X2+N );\n\t\n\t\tstd::vector<int> xs;\n\t\trep( i, M )\n\t\t\txs.push_back( X1[i] );\n\t\trep( i, N )\n\t\t\txs.push_back( X2[i] );\n\n\t\tstd::sort( all( xs ) );\n\n\t\tdouble ans = 0.0;\n\t\trep( i, xs.size()-1 )\n\t\t{\n\t\t\tdouble a = xs[i], b = xs[i+1], c = (a+b)/2;\n\n\t\t\tif( min1 <= c && c <= max1 && min2 <= c && c <= max2 )\n\t\t\t{\n\t\t\t\tdouble fa = width( X1, Y1, M, a ) * width( X2, Z2, N, a );\n\t\t\t\tdouble fb = width( X1, Y1, M, b ) * width( X2, Z2, N, b );\n\t\t\t\tdouble fc = width( X1, Y1, M, c ) * width( X2, Z2, N, c );\n\n\t\t\t\tans += (b-a)/6*(fa+4*fc+fb);\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%.10f\\n\", ans );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nvoid Calc(double ys[2][210], pair<double, double> vys[410], int n) {\n  REP(i, 210) {\n    ys[0][i] = 1e+100;\n    ys[1][i] = -1e+100;\n  }\n  REP(i, n) {\n    int px = vys[i].first;\n    int nx = vys[i + 1].first;\n    double py = vys[i].second;\n    double ny = vys[i + 1].second;\n    if (px > nx) { swap(px, nx); swap(py, ny); }\n    if (px == nx) { continue; }\n    FOREQ(x, px, nx) {\n      double d1 = abs(x - px);\n      double d2 = abs(nx - x);\n      double y = (py * d2 + ny * d1) / (d1 + d2);\n      ys[0][x + 100] = min(ys[0][x + 100], y);\n      ys[1][x + 100] = max(ys[1][x + 100], y);\n    }\n  }\n}\n\ndouble CalcVolume(int x, double py, double ny, double pz, double nz) {\n  double f1 = py * pz;\n  double f2 = (py + ny) / 2.0 * (pz + nz) / 2.0;\n  double f3 = ny * nz;\n  double ret = (f1 + 4 * f2 + f3) / 6.0;\n  return ret;\n}\n\npair<double, double> vys[410];\npair<double, double> vzs[410];\nint n, m;\ndouble ys[2][210];\ndouble zs[2][210];\n\nint main() {\n  while (scanf(\"%d %d\", &m, &n), n|m) {\n    MEMSET(vys, 0);\n    MEMSET(vzs, 0);\n    REP(i, m) {\n      int x, y;\n      scanf(\"%d %d\", &x, &y);\n      vys[i + m] = vys[i] = make_pair(x, y);\n    }\n    REP(i, n) {\n      int x, z;\n      scanf(\"%d %d\", &x, &z);\n      vzs[i + n] = vzs[i] = make_pair(x, z);\n    }\n    Calc(ys, vys, m);\n    Calc(zs, vzs, n);\n    double ans = 0.0;\n    for (double x = 0; x <= 200; x += 1) {\n      int px = x;\n      int nx = x + 1;\n      if (ys[0][px] > ys[1][px] ||\n          ys[0][nx] > ys[1][nx] ||\n          zs[0][px] > zs[1][px] ||\n          zs[0][nx] > zs[1][nx]) { continue; }\n      ans += CalcVolume(x - 100,\n                        ys[1][px] - ys[0][px], ys[1][nx] - ys[0][nx],\n                        zs[1][px] - zs[0][px], zs[1][nx] - zs[0][nx]);\n    }\n    printf(\"%.8f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <stdio.h>\n\nusing namespace std;\n\ntypedef complex<int> P;\n\ndouble getWidth(vector<P> &g, int x){\n\tdouble m = 1e10, M = -1e10;\n\tfor(int i=0;i<g.size();i++){\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif(real(a) > real(b)) swap(a, b);\n\t\tif(real(a) != real(b) && real(a) <= x && x <= real(b)){\n\t\t\tdouble mid = (double)(x-real(a))/(real(b)-real(a));\n\t\t\tdouble d = imag(a)*(1-mid)+imag(b)*mid;\n\t\t\tm = min(d, m);\n\t\t\tM = max(d, M);\n\t\t}\n\t}\n\treturn max(0.0, M-m);\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> m >> n, m){\n\t\tvector<P> gy(m), gz(n);\n\t\tint sy = 100, ey = -100, sz = 100, ez = -100; \n\t\tfor(int i=0;i<m;i++){\n\t\t\tfin >> real(gy[i]) >> imag(gy[i]);\n\t\t\tsy = min(sy, real(gy[i]));\n\t\t\tey = max(ey, real(gy[i]));\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfin >> real(gz[i]) >> imag(gz[i]);\n\t\t\tsz = min(sz, real(gz[i]));\n\t\t\tez = max(ez, real(gz[i]));\n\t\t}\n\t\tdouble res = 0.0;\n\t\tfor(int i=max(sy, sz);i+1<=min(ey, ez);i++){\n\t\t\tdouble py = getWidth(gy, i), cy = getWidth(gy, i+1), pz = getWidth(gz, i), cz = getWidth(gz, i+1);\n\t\t\tres += (cy*cz+(cy+py)*(cz+pz)+py*pz)/6.0;\n\t\t}\n\t\tprintf(\"%.4lf\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <set>\nusing namespace std;\n\ndouble width(vector<pair<int, int> > p, double x) {\n  vector<double> a;\n  for(int i = 0; i < p.size(); i++) {\n    pair<int, int> s, t;\n    s = p[i]; t = p[(i+1)%p.size()];\n    if(s.first == x) a.push_back(s.second);\n    else if((s.first < x && x < t.first) || (s.first > x && x > t.first)) {\n      int x0 = s.first, y0 = s.second;\n      int x1 = t.first, y1 = t.second;\n      /*if(s.first > x) {\n\tswap(x0, x1);\n\tswap(y0, y1);\n\t}*/\n      a.push_back(y0 + (y1-y0)*(x-x0)/(double)((x1-x0)));\n    }\n  }\n  return *(max_element(a.begin(), a.end())) - *(min_element(a.begin(), a.end()));\n}\n\nint main() {\n  int m, n;\n  while(true) {\n    cin >> m >> n;\n    if(!m) break;\n    vector<pair<int, int> > p1(m), p2(n);\n    set<int> allX;\n    for(int i = 0; i < m; i++) {\n      cin >> p1[i].first >> p1[i].second;\n      allX.insert(p1[i].first);\n    }\n    for(int i = 0; i < n; i++) {\n      cin >> p2[i].first >> p2[i].second;\n      allX.insert(p2[i].first);\n    }\n    allX.insert(-1000);\n    allX.insert(1000);\n    int start, goal;\n    start = max(*(min_element(p1.begin(), p1.end())),*(min_element(p2.begin(), p2.end()))).first;\n    goal = min(*(max_element(p1.begin(), p1.end())), *(max_element(p2.begin(), p2.end()))).first;\n    double sum = 0;\n    //cout << start << \" \" << goal << endl;\n    for(auto itr = allX.begin(); itr != allX.end(); itr++) {\n      auto next = itr;\n      next++;\n      if(*itr >= start && *itr <= goal && *next >= start && *next <= goal) {\n\t//cout << \"x: \" << *itr << \" next: \" << *next << endl;\n\tdouble m = (*itr + *next)/2.0;\n\tdouble a = width(p1, *itr)*width(p2, *itr);\n\tdouble b = width(p1, *next)*width(p2, *next);\n\tdouble c = width(p1, m)*width(p2, m);\n\tsum += (*next-*itr)/6.0*(a+4*c+b);\n      }\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}\n\n\n      \n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define MAX 111\nint x[2][MAX],y[2][MAX];\nint m,n;\ndouble calc(double c){\n  double res=1.0;\n  double ub,lb;\n  //cout<<c<<\":\"<<endl;\n  for(int k=0;k<2;k++){\n    ub=-1e10,lb=1e10;\n    for(int i=0;i<(k?n:m);i++){\n      double px=x[k][i],py=y[k][i];\n      double qx=x[k][(i+1)%(k?n:m)],qy=y[k][(i+1)%(k?n:m)];\n      if(px==qx) continue;\n      if(px>qx){\n\tswap(px,qx);\t\n\tswap(py,qy);\n      }\n      if(px<=c&&c<=qx){\n\tdouble ny=py+(qy-py)*(c-px)/(qx-px);\n\tub=max(ub,ny);\n\tlb=min(lb,ny);\n      }\n    }\n    //cout<<ub<<endl<<lb<<endl;\n    res*=max(0.0,ub-lb);\n  }\n  return res;\n}\ndouble simpson(double a,double b){\n  double c=(a+b)/2;\n  return (b-a)/6*(calc(a)+4*calc(c)+calc(b));\n}\nsigned main(){\n  while(cin>>m>>n,m||n){\n    for(int i=0;i<m;i++) cin>>x[0][i]>>y[0][i];\n    for(int i=0;i<n;i++) cin>>x[1][i]>>y[1][i];\n    vector<int> xs(m+n);\n    for(int i=0;i<m;i++) xs[i]=x[0][i];\n    for(int i=0;i<n;i++) xs[m+i]=x[1][i];\n    sort(xs.begin(),xs.end());\n    xs.erase(unique(xs.begin(),xs.end()),xs.end());\n    int mi[2],ma[2];\n    for(int k=0;k<2;k++){\n      mi[k]=*min_element(x[k],x[k]+(k?n:m));\n      ma[k]=*max_element(x[k],x[k]+(k?n:m));\n    }\n    double ans=0;\n    for(int i=0;i<(int)xs.size()-1;i++){\n      bool f=0;\n      for(int k=0;k<2;k++)\n\tf|=(xs[i]<mi[k]||ma[k]<xs[i+1]);\n      if(f) continue;\n      ans+=simpson(xs[i],xs[i+1]);\n      //cout<<ans<<endl;\n    }\n    printf(\"%.12f\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<complex>\n#include<vector>\n#include<iostream>\n#include<stack>\n#include<cmath>\n#include<map>\n\nenum CCW{FRONT=0x01,RIGHT=0x02,BACK=0x04,LEFT=0x08,OVER=0x10};\nenum CIRCLE_RELATION{CIRCLE_SAME=0x01,CIRCLE_CONTAIN=0x02,\n\t\t     CIRCLE_NO_CROSS=0x04,CIRCLE_ONE_CROSS=0x08,\n\t\t     CIRCLE_ONE_INSIDE_CROSS=0x10,CIRCLE_TWO_CROSS=0x20};\n#define sc second\n#define fr first\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\n\ntypedef double elem;\ntypedef complex<elem> point, vec;\ntypedef pair<point, point> line, hline, seg, pp;\n\nconst double infty = 1e40;\nconst double eps = 1.0e-8;\nconst double pi = acos(-1.0);\npoint base(0,0);\n\n// lZ\ninline elem sq(elem a){ return a*a; }\ninline elem cq(elem a){ return a*a*a; }\n\n// pxÏ·\nelem rad(elem deg){ return (deg/180)*pi; }\nelem deg(elem rad){ return (rad*180)/pi; }\n\n// ®¬_Ìô¢AÈÇ\nbool eq(elem a, elem b){ return abs(a-b) < eps; }\nbool eqv(vec a, vec b){ return eq( abs(b-a),0); }\n\n// _Iy[^\nbool far(point a, point b){ return abs(b-a)>0; }\nbool near(point a, point b){ return abs(b-a)<=0; }\nelem dot(vec a, vec b){ return (a.real() * b.real() + a.imag() * b.imag() ); }\nelem cross(vec a, vec b){ return ( a.real() * b.imag() - a.imag() * b.real() ); }\n\n// a©çbÜÅvñèÌpxAàpA]ñ]\nelem varg(vec a, vec b){\n  elem ret=arg(a)-arg(b);\n  if(ret<0)ret+=2*pi;\n  if(ret>2*pi)ret-=2*pi;\n  if(eq(ret,2*pi))ret=0;\n  return ret;\n}\nelem varg2(vec a, vec b){\n  elem ret = varg(a,b);\n  if(ret>pi)return 2*pi-ret;\n  return ret;\n}\nelem arg(vec a, vec b){ return acos( dot(a,b) / ( abs(a) * abs(b) ) ); }\npoint rot(point p, elem theta){ return p * polar((elem)1.0, theta); }\npoint rotdeg(point p, elem deg){ return p * polar((elem)1.0, rad(deg)); }\npoint proj(line l, point p){\n  double t=dot(p-l.first,l.first-l.second)/abs(l.first-l.second);\n  return l.first + t*(l.first-l.second);\n}\npoint reflect(line l, point p){ return p+2.0*(proj(l,p)-p); }\n\n// ñ_Ô£A¼üÆ_ÌÅZ£AüªÆ_ÌÅZ£\nelem dist(point a, point b){ return abs(a-b); }\nelem dist_l(line l, point x){ return abs(cross(l.sc-l.fr,x-l.fr)) / abs(l.sc-l.fr); }\nelem dist_seg(seg s, point x)\n{\n  if( dot(s.sc-s.fr,x-s.fr)<0 ) return abs(x-s.fr);\n  if( dot(s.fr-s.sc,x-s.sc)<0 ) return abs(x-s.sc);\n  return dist_l(s,x);\n}\n\n// PÊxNgA@üxNgAPÊ@üxNg\nvec uvec(vec a){ return a / abs(a); }\nvec nmr(vec a){ return a * vec(0,-1); }\nvec nml(vec a){ return a * vec(0,1); }\nvec unmr(vec a){ return uvec( nmr(a) ); }\nvec unml(vec a){ return uvec( nml(a) ); }\n\n// ¼ðA½s»è\nbool orth(point a1, point a2, point b1, point b2){ return eq( dot( a2 - a1, b2 - b1 ), 0 ); }\nbool orth(vec v1, vec v2){ return eq( dot(v1, v2), 0 ); }\nbool prll(point a1, point a2, point b1, point b2){ return eq( cross( a2 - a1, b2 - b1 ), 0 ); }\nbool prll(vec v1, vec v2){ return eq( cross(v1, v2), 0 ); }\n\n// CCW oXg¾ªA¸xÉæé\ninline int ccw(const point &a, point b, point x){\n  b -= a;\n  x -= a;\n  if( eq(cross(b,x),0.0) && dot(b,x) < 0 ) return BACK;\n  if( eq(cross(b,x),0.0) && abs(b) < abs(x) ) return FRONT;\n  if( eq(cross(b,x),0.0) ) return OVER;\n  if( cross(b,x) > 0 ) return LEFT;\n  if( cross(b,x) < 0 ) return RIGHT;\n}\n\n// üªg£\nline expandLine(line l, elem mag){\n  line ret = l;\n  vec vf(l.first - l.second);\n  vec vs(l.second - l.first);\n  ret.first = l.second + mag * vf;\n  ret.second = l.first + mag * vs;\n  return ret;\n}\n\n// üªÌð·»è\ninline bool intersectedSS(const seg &a, const seg &b)\n{\n  int cwaf=ccw(a.fr,a.sc,b.fr);\n  int cwbf=ccw(b.fr,b.sc,a.fr);\n  int cwas=ccw(a.fr,a.sc,b.sc);\n  int cwbs=ccw(b.fr,b.sc,a.sc);\n  if( cwaf==OVER || cwas==OVER || cwbf==OVER || cwbs==OVER ) return true;\n  return ( cwaf | cwas ) == (LEFT|RIGHT) && ( cwbf | cwbs ) == (LEFT|RIGHT);\n}\n\n// ¼üÌð·»è\nbool intersectedLL(line a, line b){ return !eq( cross(a.sc-a.fr,b.sc-b.fr), 0.0 ); }\n\n// ð_vZ\npoint intersectionSS(seg a, seg b)\n{\n  elem d1 = dist_l(b,a.fr);\n  elem d2 = dist_l(b,a.sc);\n  return a.fr + ( d1 / (d1 + d2 ) ) * (a.sc-a.fr);\n}\npoint intersectionLL(line a, line b)\n{\n  vec va = a.sc - a.fr;\n  vec vb = b.sc - b.fr;\n  return a.fr + va * ( cross(vb, b.fr - a.fr) / cross(vb,va) );\n}\n\n// üªð_êÅ\nbool intersectionLL(line a, line b, point &ret){\n  return intersectedLL( a, b ) ? ret = intersectionLL( a, b ), true : false;\n}\nbool intersectionLH(line a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret=tmp, true : false ) : false;\n}\nbool intersectionLS(line l, seg s, point &ret){\n  point tmp;\n  return intersectionLL(l,s,tmp) ? ( ccw(s.fr,s.sc,tmp)&OVER ? ret=tmp, true : false ) : false;\n}\nbool intersectionHH(hline a, hline b, point &ret){\n  point tmp;\n  return intersectionLL(a,b,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT)&&ccw(b.fr,b.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionHS(hline a, seg s, point &ret){\n  point tmp;\n  return intersectionLS(a,s,tmp) ? ( ccw(a.fr,a.sc,tmp)&(OVER|FRONT) ? ret = tmp, true : false ) : false;\n}\nbool intersectionSS(seg a, seg b, point &ret){\n  return intersectedSS(a,b) ? ret = intersectionSS(a,b), true : false;\n}\n\npair<int, pair<double,double> > getLH(double x, const vector<point> &v)\n{\n  point a,b;\n  int cnt=0;\n  line l(point(x,0),point(x,1));\n  for(int i = 0; i < (int)v.size(); ++i){\n    point is;\n    if( intersectionLS( l, seg(v[i],v[(i+1)%v.size()]), is ) ){\n      if(cnt==0){\n\ta = is;\n\t++cnt;\n      }else if( far(is,a) ){\n\tb = is;\n\t++cnt;\n      }\n    }\n  }\n  if(cnt==1)b=a;\n  if( a.imag() > b.imag() ) swap( a, b );\n  return make_pair( cnt, make_pair(a.imag(), b.imag() ) );\n}\n\nstruct point3{\n  double x,y,z;\n  point3(double x, double y, double z):x(x),y(y),z(z){}\n  point3 operator-(const point3 &t){\n    return point3(x-t.x,y-t.y,z-t.z);\n  }\n  point3 operator+(const point3 &t){\n    return point3(x+t.x,y+t.y,z+t.z);\n  }\n};\n\nostream &operator<<(ostream &oss, const point3 &t)\n{\n  oss << '('<<t.x <<','<< t.y<<','<<t.z<<')';\n  return oss;\n}\n\ndouble dot3(point3 a, point3 b){\n  return a.x*b.x + a.y*b.y + a.z*b.z;\n}\npoint3 cross3(point3 a, point3 b){\n  return point3(a.y*b.z-b.y*a.z, a.z*b.x-b.z*a.x, a.x*b.y-b.x*a.y);\n}\n\ndouble tetrahedronVolume(point3 a, point3 b, point3 c, point3 d)\n{\n  point3 A=b-a;\n  point3 B=c-a;\n  point3 C=d-a;\n  return abs(dot3(A,cross3(B,C))/6);\n}\ndouble getVolume( const vector<point3> &V1, const vector<point3> &V2 )\n{\n  double ret=0;\n  vector<point3> v1 = V1;\n  vector<point3> v2 = V2;\n  if( v2.size() < v1.size() ){\n    swap( v1, v2 );\n  }\n  if(v1.size()==1){\n    if(v2.size()==2){\n      ret = 0;\n    }else if(v2.size()==4){\n      ret+=tetrahedronVolume(v1[0],v2[0],v2[1],v2[2]);\n      ret+=tetrahedronVolume(v1[0],v2[2],v2[3],v2[0]);\n    }\n  }else if(v1.size()==2){\n    if(v2.size()==2){\n      ret = tetrahedronVolume(v1[0],v1[1],v2[0],v2[1]);\n    }else{\n      if(eq(v1[0].y,v1[1].y)){\n\tret += tetrahedronVolume( v1[1],v1[0],v2[1],v2[2] );\n\tret += tetrahedronVolume( v1[0],v2[0],v2[1],v2[2] );\n\tret += tetrahedronVolume( v1[0],v2[2],v2[3],v2[0] );\n      }else{\n\tret += tetrahedronVolume( v1[1],v1[0],v2[2],v2[3] );\n\tret += tetrahedronVolume( v1[0],v2[0],v2[1],v2[2] );\n\tret += tetrahedronVolume( v1[0],v2[2],v2[3],v2[0] );\n      }\n    }\n  }else{\n    ret += tetrahedronVolume( v1[1],v1[0],v2[1],v1[2] );\n    ret += tetrahedronVolume( v2[0],v1[0],v2[3],v2[1] );\n    ret += tetrahedronVolume( v1[3],v1[0],v1[2],v2[3] );\n\n    ret += tetrahedronVolume( v2[2],v2[3],v2[1],v1[2] );\n    ret += tetrahedronVolume( v1[0],v1[2],v2[1],v2[3] );\n  }\n  return ret;\n}\n\nint main()\n{\n  int m,n;\n  while(scanf(\"%d%d\", &m, &n) && m && n){\n    double x,y;\n    double res = 0;\n    vector<point> P1;\n    vector<point> P2;\n    int minx1=1000,maxx1=-1000;\n    int minx2=1000,maxx2=-1000;\n    map<int,pair<double,double> > vx;\n    for(int i = 0; i < m; ++i){\n      scanf(\"%lf%lf\", &x, &y);\n      P1.push_back(point(x,y));\n      vx[(int)x]=make_pair(0,0);\n      minx1 = min( (int)x, minx1 );\n      maxx1 = max( (int)x, maxx1 );\n    }\n    for(int i = 0; i < n; ++i){\n      scanf(\"%lf%lf\", &x, &y);\n      P2.push_back(point(x,y));\n      minx2 = min( (int)x, minx2 );\n      maxx2 = max( (int)x, maxx2 );\n      vx[(int)x]=make_pair(0,0);\n    }\n  retry:;\n    for(map<int,pair<double,double> >::iterator itm = vx.begin(); itm != vx.end(); ++itm){\n      pair<int, pair<double,double > > LH = getLH( itm->first, P1);\n      if( !(  minx1 <= itm->first && itm->first <= maxx1 &&\n\t      minx2 <= itm->first && itm->first <= maxx2 ) ){\n\tvx.erase(itm);\n\tgoto retry;\n      }\n      if( LH.first == 0 ){\n\tvx.erase(itm);\n\tgoto retry;\n      }else{\n\titm->second = LH.second;\n      }\n    }\n    vector< vector<point3> > V;\n    for(map<int,pair<double,double> >::iterator itm = vx.begin(); itm != vx.end(); ++itm){\n      vector<point3> vpx;\n      double x = itm->first;\n      double y1 = itm->second.first;\n      double y2 = itm->second.second;\n\n      if( eq(y1,y2) ){\n\tpair<int,pair<double,double> > Z = getLH( x, P2 );\n\tdouble z1 = Z.second.first;\n\tdouble z2 = Z.second.second;\n\tif( eq(z1,z2) ){\n\t  vpx.push_back( point3( x,y1,z1 ) );\n\t}else{\n\t  vpx.push_back( point3( x,y1,z1 ) );\n\t  vpx.push_back( point3( x,y1,z2 ) );\n\t}\n      }else{\n\tpair<int,pair<double,double> > Z = getLH( x, P2 );\n\tdouble z1 = Z.second.first;\n\tdouble z2 = Z.second.second;\n\tif( eq(z1,z2) ){\n\t  vpx.push_back( point3( x,y1,z1 ) );\n\t  vpx.push_back( point3( x,y2,z1 ) );\n\t}else{\n\t  vpx.push_back( point3( x,y1,z1 ) );\n\t  vpx.push_back( point3( x,y1,z2 ) );\n\t  vpx.push_back( point3( x,y2,z2 ) );\n\t  vpx.push_back( point3( x,y2,z1 ) );\n\t}\n      }\n      \n      /*\n      for(int i = 0; i < (int)vpx.size(); ++i){\n\tcout << vpx[i] << ' ';\n      }\n      cout << endl;\n      */\n\n      V.push_back( vpx );\n    }\n    for(int i = 0; i < (int)V.size()-1; ++i){\n      //cout << i << ' ' << i+1 << endl;\n      res += getVolume(V[i], V[i+1]);\n    }\n    printf(\"%.13lf\\n\", res);\n    //return 0;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nconst int maxn = 100 + 10;\nconst int INF = 100000000;\n\nint M, N;\nint X1[maxn], Y1[maxn];\nint X2[maxn], Z2[maxn];\n\ndouble width(int* X, int* Y, int n, double x)\n{\n    double lb = INF, ub = -INF;\n    for (int i = 0; i < n; i++){\n        double x1 = X[i], y1 = Y[i], x2 = X[(i + 1) % n], y2 = Y[(i + 1) % n];\n        if ((x1 - x) * (x2 - x) <= 0 && x1 != x2){\n            double y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n            lb = min(lb, y);\n            ub = max(ub, y);\n        }\n    }\n    return max(0.0, ub - lb);\n}\n\nvoid solve()\n{\n    int min1 = *min_element(X1, X1 + M);\n    int max1 = *max_element(X1, X1 + M);\n    int min2 = *min_element(X2, X2 + N);\n    int max2 = *max_element(X2, X2 + N);\n    vector<int> xs;\n    for (int i = 0; i < M; i++)\n        xs.push_back(X1[i]);\n    for (int i = 0; i < N; i++)\n        xs.push_back(X2[i]);\n    sort(xs.begin(), xs.end());\n\n    double res = 0;\n    for (int i = 0; i + 1 < xs.size(); i++){\n        double a = xs[i], b = xs[i + 1], c = (a + b) / 2;\n        if (min1 <= c && c <= max1 && min2 <= c && c <= max2){\n            double fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n            double fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n            double fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n            res += (b - a) / 6 * (fa + 4 * fc + fb);\n        }\n    }\n    printf(\"%.10f\\n\", res);\n}\n\nint main()\n{\n    while (scanf(\"%d%d\", &M, &N), M || N){\n        for (int i = 0; i < M; i++){\n            scanf(\"%d%d\", &X1[i], &Y1[i]);\n        }\n        for (int i = 0; i < N; i++){\n            scanf(\"%d%d\", &X2[i], &Z2[i]);\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint m,n;\nconst double EPS = 1e-11;\nvector<pair<int,int> > Pxy,Pyz;\npair<int,int> tem;\nvector<int> X;\n\n\ndouble width(vector<pair<int,int> > polygon,double x){\n    vector<double> w;\n    for(int i=0;i<polygon.size();i++){\n        pair<int,int> p=polygon[i];\n        pair<int,int> q=polygon[(i+1)%polygon.size()];\n        if((p.first-x)<EPS){\n            w.push_back(1.0*p.second);\n        }\n        else if(p.first<x && x<q.first|| p.first>0 && x>q.first){\n            int x0=p.first;\n            int y0=p.second;\n            int x1=q.first;\n            int y1=q.second;\n            w.push_back(y0+1.0*(y1-y0)*(x-x0)/(x1-x0));\n        }\n    }\n    assert(w.size()>0);\n    vector<double>::iterator maxs=max_element(w.begin(),w.end());\n    vector<double>::iterator mins=min_element(w.begin(),w.end());\n    return (maxs-mins);\n}\n\nint volume(vector<pair<int,int> >Pxy,vector<pair<int,int> >Pxz,vector<int> X){\n    double total=0.0;\n    int xmin = max((*min_element(Pxy.begin(), Pxy.end())).first,\n                   (*min_element(Pxz.begin(), Pxz.end())).first);\n    int xmax = min((*max_element(Pxy.begin(), Pxy.end())).first,\n                   (*max_element(Pxz.begin(), Pxz.end())).first);\n    sort(X.begin(), X.end());\n    for(int i=0;i<X.size()-1;i++){\n        int a=X[i];\n        int b=X[i+1];\n        if(!(xmin <= a && a <= xmax &&xmin <= b && b<< xmax) ){\n            continue;\n        }\n        double m=(a+b)/2.0;\n        double va = width(Pxy, a)*width(Pxz, a);\n        double vb = width(Pxy, b)*width(Pxz, b);\n        double vm = width(Pxy, m)*width(Pxz, m);\n        double area=((b-a)/6.0)*(va + 4.0*vm + vb);\n        total+=area;\n    }\n    return total;\n}\nint main(){\n    while(cin>>m>>n&&n!=0){\n        for(int i=1;i<=m;i++){\n            cin>>tem.first>>tem.second;\n            Pxy.push_back(tem);\n            X.push_back(tem.first);\n        }\n        for(int j=1;j<=n;j++){\n            cin>>tem.first>>tem.second;\n            Pxz.push_back(tem);\n            X.push_back(tem.first);\n        }\n        cout << fixed << volume(Pxy, Pxz, X) << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\ndouble width(int *x, int *y, int size, double given_x){\n    double max_point = -1000.0, min_point = 1000.0;\n    for(int i = 0; i < size; i++){\n        double x1 = x[i], y1 = y[i], x2 = x[(i+1)%size], y2 = y[(i+1)%size];\n        if((x1-given_x)*(x2-given_x) <= 0 && x1 != x2){\n            double value = (y2-y1) * (given_x-x1) / (x2-x1) + y1; \n            max_point = max(value, max_point);\n            min_point = min(value, min_point);\n        }\n    }\n    return max_point - min_point;\n}\n\nint main(){\n    int m, n;\n    while(cin >> m >> n && m > 0){\n        int xy[100];\n        int y[100];\n        int xz[100];\n        int z[100];\n        int max_xy = -105;\n        int min_xy = 105;\n        for(int i = 0; i < m; i++){\n            cin >> xy[i] >> y[i];\n            max_xy = max(max_xy, xy[i]);\n            min_xy = min(min_xy, xy[i]);\n        }\n        int max_xz = -105;\n        int min_xz = 105;\n        for(int i = 0; i < n; i++){\n            cin >> xz[i] >> z[i];\n            max_xz = max(max_xz, xz[i]);\n            min_xz = min(min_xz, xz[i]);\n        }\n        int xmin = max(min_xy, min_xz);\n        int xmax = min(max_xy, max_xz);\n        vector<int> v;\n        for(int i = 0; i < m; i++){\n            v.push_back(xy[i]);\n        } \n        for(int i = 0; i < n; i++){\n            v.push_back(xz[i]);\n        } \n        sort(v.begin(), v.end());\n        double ans = 0;\n        for(int i = 0; i < v.size(); i++){\n            double a = v[i], b = v[i+1];\n            if(xmin <= a && a <= xmax && xmin <= b && b <= xmax){\n                double mid = (a + b) / 2.0;\n                double va = width(xy, y, m, a) * width(xz, z, n, a);\n                double vb = width(xy, y, m, b) * width(xz, z, n, b);\n                double vm = width(xy, y, m, mid) * width(xz, z, n, mid);\n                ans += (b-a)/6 * (va + 4*vm + vb);\n            }\n        }\n        cout << fixed << setprecision(4) << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <complex>\n#include <cmath>\n#include <utility>\n#include <algorithm>\n#include <vector>\n#define MAX 1000000\nusing namespace std;\n\ndouble width(int X[], int Y[], int n, double x)\n{\n\tdouble Min = MAX, Max = -MAX;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x1 = X[i+1], y1 = Y[i+1], x2 = X[(i + 1) % n + 1], y2 = Y[(i + 1) % n + 1];\n\t\tif ((x1-x)*(x2-x)<=0 && x1!=x2)\n\t\t{\n\t\t\tdouble y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n\t\t\tMax = max(Max, y);\n\t\t\tMin = min(Min, y);\n\t\t}\n\t}\n\tif(Max <= Min)\n\t\treturn 0.0;\n\telse\n        return Max-Min;\n}\n\ndouble volume(int m, int n, int x1[], int y1[], int x2[], int z2[])\n{\n    int min1=x1[1],max1=x1[1],min2=x2[1],max2=x2[1];\n    for(int i=0;i<m;i++)\n    {\n        if(min1>x1[i+1])\n            min1 = x1[i+1];\n        if(max1<x1[i+1])\n            max1 = x1[i+1];\n    }\n    for(int i=0;i<n;i++)\n    {\n        if(min2>x2[i+1])\n            min2 = x2[i+1];\n        if(max2<x2[i+1])\n            max2 = x2[i+1];\n    }\n    vector<int> X;\n    for(int i=0;i<m;i++)\n        X.push_back(x1[i+1]);\n    for(int i=0;i<n;i++)\n        X.push_back(x2[i+1]);\n    sort(X.begin(), X.end());\n    double total = 0.0;\n    for(int i=0;i+1<m+n;i++)\n    {\n        double a = X[i];\n        double b = X[i+1];\n        double mm = (a+b)/2.0;\n        if(min1<=mm && mm<=max1 && min2<=mm && mm<=max2)\n        {\n            double va = width(x1, y1, m, a) * width(x2, z2, n, a);\n            double vb = width(x1, y1, m, b) * width(x2, z2, n, b);\n            double vm = width(x1, y1, m, mm) * width(x2, z2, n, mm);\n            total +=  (b-a)/6 * (va+4*vm+vb);\n        }\n    }\n    return total;\n}\n\nint main()\n{\n\tint m, n;\n\tint x1[110], y1[110], x2[110], z2[110];\n\tcin >> m >> n;\n\twhile(m && n)\n    {\n        for (int i = 1; i <= m; i++)\n            cin >> x1[i] >> y1[i];\n        for (int i = 1; i <= n; i++)\n            cin >> x2[i] >> z2[i];\n        double total = volume(m, n, x1, y1, x2, z2);\n        //cout << total << endl;\n        printf(\"%.10f\\n\",total);\n        cin >> m >> n;\n    }\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing pii=pair<int,int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\n\n\nint main(){\n\tint m,n;\n\twhile(cin>>m>>n,n){\n\t\tvector<pii> C1(m),C2(n);\n\t\tvector<vector<double>> yp(201),zp(201);\n\t\tvector<double> y(201,0.0),z(201,0.0);\n\t\trep(i,m){int a,b; cin>>a>>b; C1[i]={a+100,b+100};}\t//xy\n\t\trep(i,n){int a,b; cin>>a>>b; C2[i]={a+100,b+100};}\t//xz\n\t\tint limit[4]={200,0,200,0};\n\t\trep(i,m){\n\t\t\tlimit[0]=min(limit[0],C1[i].first);\n\t\t\tlimit[1]=max(limit[1],C1[i].first);\n\t\t\tint j=(i+1)%m;\n\t\t\tauto xr=make_pair(C1[i].first,C1[j].first);\n\t\t\tauto yr=make_pair(C1[i].second,C1[j].second);\n\t\t\tif(xr.second<xr.first){\n\t\t\t\tswap(xr.second,xr.first);\n\t\t\t\tswap(yr.second,yr.first);\n\t\t\t}\n\t\t\tint diff=xr.second-xr.first;\n\t\t\tif(diff==0){\n\t\t\t\ty[xr.first]=fabs(yr.second-yr.first);\n\t\t\t}\n\t\t\trep(x,diff){\n\t\t\t\tdouble l=yr.second-yr.first;\n\t\t\t\tl/=diff;\n\t\t\t\typ[x+xr.first].push_back(yr.first+l*x);\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\tlimit[2]=min(limit[2],C2[i].first);\n\t\t\tlimit[3]=max(limit[3],C2[i].first);\n\t\t\tint j=(i+1)%n;\n\t\t\tauto xr=make_pair(C2[i].first,C2[j].first);\n\t\t\tauto zr=make_pair(C2[i].second,C2[j].second);\n\t\t\tif(xr.second<xr.first){\n\t\t\t\tswap(xr.second,xr.first);\n\t\t\t\tswap(zr.second,zr.first);\n\t\t\t}\n\t\t\tint diff=xr.second-xr.first;\n\t\t\tif(diff==0){\n\t\t\t\tz[xr.first]=fabs(zr.second-zr.first);\n\t\t\t}\n\t\t\trep(x,diff){\n\t\t\t\tdouble l=zr.second-zr.first;\n\t\t\t\tl/=diff;\n\t\t\t\tzp[x+xr.first].push_back(zr.first+l*x);\n\t\t\t}\n\t\t}\n\t\trep(i,201){\n\t\t\tif(yp[i].size()!=0) y[i]=fabs(yp[i][0]-yp[i][1]);\n\t\t\tif(zp[i].size()!=0) z[i]=fabs(zp[i][0]-zp[i][1]);\n\t\t}\n\t\tdouble ans=0.0;\n\t\t//for(auto i:limit)cout<<i<<\",\";cout<<endl;\n\t\tlimit[1]--; limit[3]--;\n\t\tfor(int x=max(limit[0],limit[2]);x<=min(limit[1],limit[3]);x++){\n\t\t\tdouble f1=y[x]*z[x+1];\n\t\t\tdouble f2=y[x+1]*z[x];\n\t\t\tdouble f3=2*(y[x]*z[x]+y[x+1]*z[x+1]);\n\t\t\tans+=(f1+f2+f3)/6;\n\t\t}\n\t\tcout.precision(6);\n\t\tcout<<fixed<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nconst int MAX_M = 100;\nconst int MAX_N = 100;\n\nconst int INF = 1 << 29;\n\nint M, N;\nint X1[MAX_M], Y1[MAX_M];\nint X2[MAX_N], Z2[MAX_N];\n\ndouble width(int *X, int *Y, int n, double x)\n{\n  double lb = INF, ub = -INF;\n\n  for (int i = 0; i < n; i++) {\n    double x1 = X[i];\n    double y1 = Y[i];\n    double x2 = X[(i + 1) % n];\n    double y2 = Y[(i + 1) % n];\n\n    if ((x1 - x) * (x2 - x) <= 0 && x1 != x2) {\n      double y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n\n      lb = min(lb, y);\n      ub = max(ub, y);\n    }\n  }\n  return max(0.0, ub - lb);\n}\n\nvoid solve()\n{\n  int min1 = *min_element(X1, X1 + M), max1 = *max_element(X1, X1 + M);\n  int min2 = *min_element(X2, X2 + N), max2 = *max_element(X2, X2 + N);\n  vector<int> xs;\n\n  for (int i = 0; i < M; i++) xs.push_back(X1[i]);\n  for (int i = 0; i < N; i++) xs.push_back(X2[i]);\n  sort(xs.begin(), xs.end());\n\n  double res = 0;\n  for (int i = 0; i + 1 < (int)xs.size(); i++) {\n    double a = xs[i];\n    double b = xs[i + 1];\n    double c = (a + b) / 2;\n\n    if (min1 <= c && c <= max1 && min2 <= c && c <= max2) {\n      double fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n      double fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n      double fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n\n      res += (b - a) * (fa + 4 * fc + fb) / 6;\n    }\n  }\n\n  printf(\"%.10f\\n\", res);\n}\n\nint main()\n{\n  while (true) {\n    scanf(\"%d%d\", &M, &N);\n    if (M == 0 && N == 0) break;\n\n    for (int i = 0; i < M; i++) scanf(\"%d%d\", X1 + i, Y1 + i);\n    for (int i = 0; i < N; i++) scanf(\"%d%d\", X2 + i, Z2 + i);\n\n    solve();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nconst int N = 505;\nconst double EPS = 1e-12, INF = 1e12;\nint dcmp(double x) { return (x > EPS) - (x < -EPS); }\nstruct Point {\n\tdouble x, y;\n\tPoint() { }\n\tPoint(double _x, double _y) :x(_x), y(_y) { }\n};\ntypedef Point Vector;\nvoid read(Point &p) { scanf(\"%lf%lf\", &p.x, &p.y); }\n\nint m, n;\nPoint pa[N], pb[N];\n\ndouble width(Point *poly, int n, double x) {\n\tint i;\n\tdouble lb = INF, ub = -INF;\n\tfor (i = 0;i < n;++i) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\t//if a.x == b.x we'd better consider it to be alone\n\t\tif (dcmp((a.x - x) * (b.x - x)) <= 0 && dcmp(a.x - b.x) != 0) {\n\t\t\tdouble y = a.y + (b.y - a.y) * (x - a.x) / (b.x - a.x);\n\t\t\tlb = min(lb, y); ub = max(ub, y);\n\t\t}\n\t}\n\treturn max(0.0, ub - lb);\n}\n\nvoid solve() {\n\tint i;\n\tdouble mna = pa[0].x, mxa = pa[0].x, mnb = pb[0].x, mxb = pb[0].x;\n\tfor (i = 1;i < m;++i) mna = min(mna, pa[i].x), mxa = max(mxa, pa[i].x);\n\tfor (i = 1;i < n;++i) mnb = min(mnb, pb[i].x), mxb = max(mxb, pb[i].x);\n\tvector<double> xs;\n\tfor (i = 0;i < m;++i) xs.push_back(pa[i].x);\n\tfor (i = 0;i < n;++i) xs.push_back(pb[i].x);\n\tsort(xs.begin(), xs.end());\n\t//xs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tdouble res = 0.0;\n\tfor (i = 0;i + 1 < xs.size();++i) {\n\t\tdouble a = xs[i], b = xs[i + 1], c = (a + b) / 2;\n\t\tif (dcmp(mna - c) <= 0 && dcmp(c - mxa) <= 0 && dcmp(mnb - c) <= 0 && dcmp(c - mxb) <= 0) {\n\t\t\tdouble fa = width(pa, m, a) * width(pb, n, a);\n\t\t\tdouble fb = width(pa, m, b) * width(pb, n, b);\n\t\t\tdouble fc = width(pa, m, c) * width(pb, n, c);\n\t\t\tres += (b - a) / 6 * (fa + 4 * fc + fb);\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", res);\n}\n\nint main(int argc, char *argv[]) {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"dat.in\", \"r\", stdin);\n\tfreopen(\"my.out\", \"w\", stdout);\n#endif\n\twhile (scanf(\"%d%d\", &m, &n) == 2 && n && m) {\n\t\tint i;\n\t\tfor (i = 0;i < m;++i) read(pa[i]);\n\t\tfor (i = 0;i < n;++i) read(pb[i]);\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst int maxn = 100 + 10;\nconst double inf = 1e9;\n\nint M, N;\nint X1[maxn], Y1[maxn];\nint X2[maxn], Z2[maxn];\n\ndouble width(int *X, int *Y, int n, double x){\n\tdouble lb = inf, ub = -inf;\n\tfor(int i = 0; i < n; ++i){\n\t\tdouble x1 = X[i], y1 = Y[i], x2 = X[(i+1)%n], y2 = Y[(i+1)%n];\n\t\tif((x1 - x) * (x2 - x) <= 0 && x1 != x2){\n\t\t\tdouble y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n\t\t\tlb = min(lb, y);\n\t\t\tub = max(ub, y);\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint min1 = *min_element(X1, X1 + M), max1 = *max_element(X1, X1 + M);\n\tint min2 = *min_element(X2, X2 + N), max2 = *max_element(X2, X2 + N);\n\tvector<int> xs;\n\tfor(int i = 0; i < M; ++i) xs.push_back(X1[i]);\n\tfor(int i = 0; i < N; ++i) xs.push_back(X2[i]);\n\tsort(xs.begin(), xs.end());\n\n\tdouble res = 0;\n\tfor(int i = 0; i + 1 < xs.size(); ++i){\n\t\tdouble a = xs[i], b = xs[i+1], c = (a + b) / 2;\n\t\tif(min1 <= c && c <= max1 && min2 <= c && c <= max2){\n\t\t\tdouble fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n\t\t\tdouble fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n\t\t\tdouble fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n\t\t\tres += (b - a) / 6 * (fa + 4 * fc + fb);\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", res);\n}\n\nint main(){\n//\tfreopen(\"in.txt\", \"r\", stdin);\n\n\twhile(scanf(\"%d %d\", &M, &N) == 2){\n\t\tif(N == 0 && M == 0) break;\n\n\t\tfor(int i = 0; i < M; ++i){\n\t\t\tscanf(\"%d %d\", X1 + i, X2 + i);\n\t\t}\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tscanf(\"%d %d\", X2 + i, Z2 + i);\n\t\t}\n\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename F>\nstruct Point {\n  F x, y;\n  Point(F x = 0, F y = 0) : x(x), y(y) {}\n  bool operator<(const Point &oth) const {\n    return x == oth.x ? y < oth.y : x < oth.x;\n  }\n  Point operator-(const Point &oth) const {\n    return Point(x - oth.x, y - oth.y);\n  }\n};\n\ntemplate<typename F>\nusing Polygon = vector<Point<F>>;\n\ntemplate<typename F>\nPolygon<F> upperConvexHull(Polygon<F> P) {\n  reverse(P.begin(), P.end());\n  rotate(P.begin(), min_element(P.begin(), P.end(), [](Point<F> a, Point<F> b) {\n    return a.x == b.x ? a.y > b.y : a.x < b.x;\n  }), P.end());\n  int n = P.size();\n  Polygon<F> ret = {P[0]};\n  for (int i = 1; i < n; ++i) {\n    auto dir = P[i] - P[i - 1];\n    if (dir.x > 0) ret.push_back(P[i]);\n  }\n  return ret;\n}\n\ntemplate<typename F>\nPolygon<F> lowerConvexHull(Polygon<F> P) {\n  rotate(P.begin(), min_element(P.begin(), P.end()), P.end());\n  int n = P.size();\n  Polygon<F> ret = {P[0]};\n  for (int i = 1; i < n; ++i) {\n    auto dir = P[i] - P[i - 1];\n    if (dir.x > 0) ret.push_back(P[i]);\n  }\n  return ret;\n}\n\ntemplate<typename F>\ndouble getLen(F x, Polygon<F> U, Polygon<F> L) {\n  int i = upper_bound(U.begin(), U.end(), Point<F>(x, -1e9)) - U.begin();\n  int j = upper_bound(L.begin(), L.end(), Point<F>(x, -1e9)) - L.begin();\n  if (i == U.size() or j == L.size()) return 0;\n  if (i == 0 and U[i].x > x) return 0;\n  if (j == 0 and L[j].x > x) return 0;\n  auto getY = [&](double x, int i, Polygon<F> P) -> double {\n    if (i == 0) return P[i].y;\n    return P[i].y - (double) (P[i].y - P[i - 1].y) / \n                             (P[i].x - P[i - 1].x) * \n                             (P[i].x - x);\n  };\n  return getY(x, i, U) - getY(x, j, L);\n}\n\n\ntemplate<typename Double>\nclass Integration {\n  Double ALPHA = sqrt((5 - sqrt(40. / 7))) / 3, WA = (322 + sqrt(11830)) / 900;\n  Double W0 = 128. / 225.;\n  Double BETA  = sqrt((5 + sqrt(40. / 7))) / 3, WB = (322 - sqrt(11830)) / 900;\n  function<Double(Double)> f;\n  Double quadrature(Double l, Double r) {\n    auto m = (l + r) / 2, len = r - m;\n    return (f(m - ALPHA * len) * WA + f(m - BETA * len) * WB + f(m) * W0 +\n            f(m + ALPHA * len) * WA + f(m + BETA * len) * WB) * len;\n  }\n  Double askArea(Double l, Double r, Double exceptArea) {\n    Double m = (l + r) / 2, L = quadrature(l, m), R = quadrature(m, r);\n    if (abs(L + R - exceptArea) < 1e-8)\n      return L + R;\n    else return askArea(l, m, L) + askArea(m, r, R);\n  }\npublic:\n  Integration(function<Double(Double)> func) : f(func) {}\n  Double intergal(Double l, Double r, int piece = 1) {\n    Double ans = 0;\n    for (Double dx = (r - l) / piece, i = 0; i < piece; ++i) {\n      auto cur = l + dx * i;\n      ans += askArea(cur, cur + dx, quadrature(cur, cur + dx));\n    }\n    return ans;\n  }\n};\n\nint main() {\n  ios_base::sync_with_stdio(false); cin.tie(0);\n  int n, m; \n  while (cin >> n >> m and n and m) {\n    Polygon<double> Z, Y;\n    vector<int> Xs;\n    for (int i = 0; i < n; ++i) {\n      int x, y; cin >> x >> y;\n      Z.emplace_back(x, y);\n      Xs.emplace_back(x);\n    }\n    for (int i = 0; i < m; ++i) {\n      int x, y; cin >> x >> y;\n      Y.emplace_back(x, y);\n      Xs.emplace_back(x);\n    }\n    sort(Xs.begin(), Xs.end());\n    Xs.erase(unique(Xs.begin(), Xs.end()), Xs.end());\n    Polygon<double> UZ = upperConvexHull(Z);\n    Polygon<double> LZ = lowerConvexHull(Z);\n    Polygon<double> UY = upperConvexHull(Y);\n    Polygon<double> LY = lowerConvexHull(Y);\n    double preX = Xs[0];\n    double ans = 0;\n    Integration<double> formula([=](double x) {\n      return getLen(x, UZ, LZ) * getLen(x, UY, LY);\n    });\n    for (int x : Xs) {\n      ans += formula.intergal(preX, x);\n      preX = x;\n    }\n    cout << fixed << setprecision(10) << ans << '\\n';\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\nusing namespace std;\n  \n#define MAX_N 101\n#define MAX_M 101\n#define INF (1<<29)\n  \nint M, N;\nint X1[MAX_M], Y1[MAX_M];\nint X2[MAX_N], Z2[MAX_N];\n  \ndouble width(int* X, int* Y, int n, double x){\n  double lb = INF, ub = -INF;\n  for(int i = 0 ; i < n ; i++){\n    double x1 = X[i], y1 = Y[i], x2 = X[(i+1)%n], y2 = Y[(i+1)%n];\n    if((x1 - x) * (x2 - x) <= 0 && x1 != x2){\n      double y = y1 + (y2-y1) * (x-x1) / (x2-x1);\n      lb = min(lb, y);\n      ub = max(ub, y);\n    }\n  }\n  return max(0.0, ub - lb);\n}\n  \nvoid solve(){\n  int min1 = *min_element(X1, X1+M), max1 = *max_element(X1, X1+M);\n  int min2 = *min_element(X2, X2+N), max2 = *max_element(X2, X2+N);\n  vector<int> xs;\n  for(int i = 0 ; i < M ; i++) xs.push_back(X1[i]);\n  for(int i = 0 ; i < N ; i++) xs.push_back(X2[i]);\n  sort(xs.begin(), xs.end());\n    \n  double res = 0;\n    \n  for(int i = 0 ; i+1 < xs.size() ; i++){\n    double a = xs[i], b = xs[i+1], c = (a+b)/2;\n    if(min1 <= c && c <= max1 && min2 <= c && c <= max2){\n      double fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n      double fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n      double fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n      res += (b-a)/6*(fa+4*fc+fb);\n    }\n  }\n  printf(\"%.10f\\n\", res);\n}\n  \nint main(void){\n  \n  while(cin >> M >> N,N|M){\n    for(int i=0;i<M;i++){\n      cin >> X1[i] >> Y1[i];\n    }\n    for(int i=0;i<N;i++){\n      cin >> X2[i] >> Z2[i];\n    }\n    solve();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\ntypedef pair<double, double> pdd;\n\ntypedef complex<double> P;\nnamespace std {\n  bool operator < (const P& a, const P& b) {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ndouble cross(const P& a, const P& b) {\n  return imag(conj(a)*b);\n}\ndouble dot(const P& a, const P& b) {\n  return real(conj(a)*b);\n}\nstruct L : public vector<P> {\n  L(const P &a, const P &b) {\n    push_back(a); push_back(b);\n  }\n};\ntypedef vector<P> G;\n#define curr(P, i) P[i]\n#define next(P, i) P[(i+1)%P.size()]\nstruct C {\n  P p; double r;\n  C(const P &p, double r) : p(p), r(r) { }\n};\n\nint ccw(P a, P b, P c) {\n  b -= a; c -= a;\n  if (cross(b, c) > 0)   return +1;       // counter clockwise\n  if (cross(b, c) < 0)   return -1;       // clockwise\n  if (dot(b, c) < 0)     return +2;       // c--a--b on line\n  if (norm(b) < norm(c)) return -2;       // a--b--c on line\n  return 0;\n}\nbool intersectLS(const L &l, const L &s) {\n  return cross(l[1]-l[0], s[0]-l[0])*       // s[0] is left of l\n         cross(l[1]-l[0], s[1]-l[0]) < EPS; // s[1] is right of l\n}\nP crosspoint(const L &l, const L &m) {\n  double A = cross(l[1] - l[0], m[1] - m[0]);\n  double B = cross(l[1] - l[0], l[1] - m[0]);\n  if (abs(A) < EPS && abs(B) < EPS) return m[0]; // same line\n  if (abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n  return m[0] + B / A * (m[1] - m[0]);\n}\n\ndouble width(int *X, int *Y, int n, double x) {\n  double lb = INF, ub = -INF;\n  L l = L(P(x,0), P(x,1));\n  REP(i, n) {\n    L s = L(P(X[i], Y[i]), P(X[(i+1)%n], Y[(i+1)%n]));\n    if (intersectLS(l, s)) {\n      P p = crosspoint(l, s);\n      double y = p.imag();\n      lb = min(lb, y);\n      ub = max(ub, y);\n    }\n  }\n  return max(0.0, ub-lb);\n}\nint main() {\n  int m, n;\n  while(cin >> m >> n, m||n) {\n    int X1[m], Y1[m], X2[n], Z2[n];\n    REP(i, m) cin >> X1[i] >> Y1[i];\n    REP(i, n) cin >> X2[i] >> Z2[i];\n    int min1 = *min_element(X1, X1+m), max1 = *max_element(X1, X1+m);\n    int min2 = *min_element(X2, X2+n), max2 = *max_element(X2, X2+n);\n    vector<int> xs;\n    REP(i, m) xs.push_back(X1[i]);\n    REP(i, n) xs.push_back(X2[i]);\n    sort(ALL(xs));\n\n    double res = 0;\n    REP(i, xs.size()-1) {\n      double a = xs[i], b = xs[i+1], c = (a+b)/2;\n      if (min1 <= c && c <= max1 && min2 <= c && c<= max2) {\n        double fa = width(X1, Y1, m, a) * width(X2, Z2, n, a);\n        double fb = width(X1, Y1, m, b) * width(X2, Z2, n, b);\n        double fc = width(X1, Y1, m, c) * width(X2, Z2, n, c);\n        res += (b-a) / 6 * (fa + 4*fc + fb);\n      }\n    }\n    printf(\"%.10f\\n\", res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\n\nconst D EPS = 1e-8;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return EQ(real(a),real(b))?imag(a)<imag(b):real(a)<real(b);\n  }\n  bool operator==(const P &a, const P &b){return EQ(a,b);}\n}\n\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ninline bool para(L a,L b){return abs(cross(a.fs-a.sc,b.fs-b.sc))<EPS;}\n\ninline bool is_cp(L a,L b){\n  if(para(a,b))return false;\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ninline P line_cp(L a,L b){\n  return a.fs+(a.sc-a.fs)*cross(b.sc-b.fs,b.fs-a.fs)/cross(b.sc-b.fs,a.sc-a.fs);\n}\n\nvector<P> p[2];\ninline D len(D x, int id){\n  L l = L( P(x,-1000), P(x,1000) );\n  vector<P> res;\n  rep(i,p[id].size()){\n    L a = L( p[id][i], p[id][(i+1)%p[id].size()] );\n    if(is_cp(a,l)){\n      P cp = line_cp(a,l);\n      if(!EQ(cp,p[id][i]))res.push_back(cp);\n    }else if(para(a,l) && ccw(l.fs,l.sc,a.sc)==0){\n      res.push_back(a.sc);\n    }\n  }\n\n  if(res.size()<2)return 0;\n  return abs(res[0]-res[1]);\n}\n\ninline D f(D x){\n  return len(x,0) * len(x,1);\n}\n\nint main(){\n  int m,n;\n  while(cin >> m >> n, m){\n    D minx[2], maxx[2];\n    p[0].resize(m); p[1].resize(n);\n    minx[0] = minx[1] = 1000;\n    maxx[0] = maxx[1] = -1000;\n\n    rep(i,m){\n      D x,y;\n      cin >> x >> y;\n      p[0][i] = P(x,y);\n      minx[0]=min(minx[0],x);\n      maxx[0]=max(maxx[0],x);\n    }\n\n    rep(i,n){\n      D x,z;\n      cin >> x >> z;\n      p[1][i] = P(x,z);\n      minx[1]=min(minx[1],x);\n      maxx[1]=max(maxx[1],x);\n    }\n\n    D ans = 0;\n    for(D i=-100;i<100;i+=1){\n      if(minx[0]<=i+0.5 && i+0.5<=maxx[0]){\n\tif(minx[1]<=i+0.5 && i+0.5<=maxx[1]){\n\t  ans += f(i)+4*f(i+0.5)+f(i+1);\n\t}\n      }\n    }\n    cout << fixed << setprecision(9) << ans/6 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <stdio.h>\n\nusing namespace std;\n\ntypedef complex<int> P;\n\ndouble getWidth(vector<P> &g, int x){\n\tdouble m = 1e10, M = -1e10;\n\tfor(int i=0;i<g.size();i++){\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif(real(a) > real(b)) swap(a, b);\n\t\tif(real(a) != real(b) && real(a) <= x && x <= real(b)){\n\t\t\tdouble mid = (double)(x-real(a))/(real(b)-real(a));\n\t\t\tdouble d = imag(a)*(1-mid)+imag(b)*mid;\n\t\t\tm = min(d, m);\n\t\t\tM = max(d, M);\n\t\t}\n\t}\n\treturn max(0.0, M-m);\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> m >> n, m){\n\t\tvector<P> gy(m), gz(n);\n\t\tint sy = 100, ey = -100, sz = 100, ez = -100; \n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> real(gy[i]) >> imag(gy[i]);\n\t\t\tsy = min(sy, real(gy[i]));\n\t\t\tey = max(ey, real(gy[i]));\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> real(gz[i]) >> imag(gz[i]);\n\t\t\tsz = min(sz, real(gz[i]));\n\t\t\tez = max(ez, real(gz[i]));\n\t\t}\n\t\tdouble res = 0.0;\n\t\tfor(int i=max(sy, sz);i+1<=min(ey, ez);i++){\n\t\t\tdouble py = getWidth(gy, i), cy = getWidth(gy, i+1), pz = getWidth(gz, i), cz = getWidth(gz, i+1);\n\t\t\tres += (cy*cz+(cy+py)*(cz+pz)+py*pz)/6.0;\n\t\t}\n\t\tprintf(\"%.4lf\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <list>\n#include <string.h>\nusing namespace std;\ntypedef long long int ll; typedef pair <int, int> P;\nconst double INF = 1000000000; const double EPS = 10e-9;\nint x1[100], y[100], x2[100], z[100];\ndouble width(int *X, int *Y, int n, double x) {\n\tdouble lb = -INF, ub = INF;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x1 = X[i], x2 = X[(i + 1) % n], y1 = Y[i], y2 = Y[(i + 1) % n];\n\t\tif ((x1 - x) * (x2 - x) >= 0) continue;\n\t\tdouble y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n\t\tlb = max(lb, y);\n\t\tub = min(ub, y);\n\t}\n\treturn lb - ub;\n}\nint main()\n{\n\twhile (true)\n\t{\n\t\tvector <int> x;\n\t\tint m, n; cin >> m >> n;\n\t\tif (m == 0 && n == 0) break;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x1[i] >> y[i];\n\t\t\tx.push_back(x1[i]);\n\t\t}\n\t\tint minx1 = *min_element(x1, x1 + m), maxx1 = *max_element(x1, x1 + m);\n\t\tint minx2 = *min_element(x2, x2 + n), maxx2 = *max_element(x2, x2 + n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x2[i] >> z[i];\n\t\t\tx.push_back(x2[i]);\n\t\t}\n\t\tsort(x.begin(), x.end());\n\t\tdouble res = 0.0;\n\t\tfor (int i = 0; i + 1 < m + n; i++)\n\t\t{\n\t\t\tint a = x[i], b = x[i + 1], c = (a + b) / 2;\n\t\t\tif (minx1 < c && c < maxx1 && minx2 < c && c < maxx2)\n\t\t\t{\n\t\t\t\tdouble sa = width(x1, y, m, a) * width(x2, z, n, a);\n\t\t\t\tdouble sb = width(x1, y, m, b) * width(x2, z, n, b);\n\t\t\t\tdouble sc = width(x1, y, m, c) * width(x2, z, n, c);\n\t\t\t\tres += (b - a) / 6 * (sa + sb + 4 * sc);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10f\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\n#include <cassert>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Pol;\nD eps=1e-10,Eps=1e-9;\nD cro(P a,P b){return imag(conj(a)*b);}\nint ccw(P a,P b,P c){\n\tif(cro(b-a,c-a)>eps) return 1;\n\tif(cro(b-a,c-a)<-eps) return -1;\n\tif(abs(abs(a-c)+abs(c-b)-abs(a-b))<eps) return 0;\n\tif(abs(abs(a-b)+abs(c-b)-abs(a-c))<eps) return -2;\n\treturn 2;\n}\nbool iLS(L l,L s){\n\treturn cro(l.sc-l.fs,s.fs-l.fs)*cro(l.sc-l.fs,s.sc-l.fs)<eps;\n}\nP intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nint M,N;\nPol a,b;\nD rec(D x){\n\tL l=L(P(x,0),P(x,1));\n\tPol inters;\n\trep(j,M){\n\t\tL e=L(a[j],a[(j+1)%M]);\n\t\tif(iLS(l,e)) inters.pb(intLL(l,e));\n\t}\n\tif(inters.size()<=1) return -1;\n\tD leny=0;\n\tfor(P p:inters) for(P q:inters) leny=max(leny,abs(p-q));\n\tinters.clear();\n\trep(j,N){\n\t\tL e=L(b[j],b[(j+1)%N]);\n\t\tif(iLS(l,e)) inters.pb(intLL(l,e));\n\t}\n\tif(inters.size()<=1) return -1;\n\tD lenz=0;\n\tfor(P p:inters) for(P q:inters) lenz=max(lenz,abs(p-q));\n\treturn leny*lenz;\n}\nint main(){\n\twhile(true){\n\t\tcin>>M>>N;\n\t\tif(M==0) break;\n\t\ta.clear(),b.clear();\n\t\tvector<D> xs;\n\t\tD ans=0;\n\t\trep(i,M){\n\t\t\tD x,y;\n\t\t\tcin>>x>>y;\n\t\t\ta.pb(P(x,y));\n\t\t\txs.pb(x-Eps);\n\t\t\txs.pb(x+Eps);\n\t\t}\n\t\trep(i,N){\n\t\t\tD x,y;\n\t\t\tcin>>x>>y;\n\t\t\tb.pb(P(x,y));\n\t\t\txs.pb(x-Eps);\n\t\t\txs.pb(x+Eps);\n\t\t}\n\t\tsort(all(xs));\n\t\trep(i,xs.size()-1){\n\t\t\tif(rec(xs[i])<-eps||rec(xs[i])<-eps) continue;\n\t\t\tans+=(xs[i+1]-xs[i])/6.0*(rec(xs[i])+4.0*rec((xs[i+1]+xs[i])/2)+rec(xs[i+1]));\n\t\t}\n\t\tprintf(\"%.4f\\n\",(double)ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define MAX_M 105\n#define MAX_N 105\n#define INF (1<<30)\nusing namespace std;\n\nint M, N;\nint X1[MAX_M], Y1[MAX_M];\nint X2[MAX_N], Z2[MAX_N];\n\ndouble width(int X[], int Y[], int n, double x){\n  double lb = INF, ub = -INF;\n  for(int i = 0; i < n; i++){\n    double x1 = X[i], y1 = Y[i];\n    double x2 = X[(i + 1) % n], y2 = Y[(i + 1) % n];\n    if((x1 - x) * (x2 - x) <= 0 && x1 != x2){\n      double a = (y1 - y2) / (x1 - x2);\n      double b = (y1 * x2 - y2 * x1) / (x2 - x1);\n      double y = a * x + b;\n      lb = min(lb, y);\n      ub = max(ub, y);\n    }\n  }\n  return max(0.0, ub - lb);\n}\n\nvoid solve(){\n  int min1 = *min_element(X1, X1 + M), max1 = *max_element(X1, X1 + M);\n  int min2 = *min_element(X2, X2 + N), max2 = *max_element(X2, X2 + N);\n  vector<int> xs;\n  for(int i = 0; i < M; i++) xs.push_back(X1[i]);\n  for(int i = 0; i < N; i++) xs.push_back(X2[i]);\n  sort(xs.begin(), xs.end());\n\n  double res = 0;\n  for(int i = 0; i < xs.size() - 1; i++){\n    double a = xs[i], b = xs[i + 1], c = (a + b) / 2;\n    if(min1 <= c && c <= max1 && min2 <= c && c <= max2){\n      double fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n      double fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n      double fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n      res += (b - a) / 6 * (fa + 4 * fc + fb);\n    }\n  }\n\n  printf(\"%.10f\\n\", res);\n}\n\nint main(){\n  while(true){\n    scanf(\"%d %d\", &M, &N);\n    if(M == 0 && N == 0) break;\n\n    for(int i = 0; i < M; i++) scanf(\"%d %d\", &X1[i], &Y1[i]);\n    for(int i = 0; i < N; i++) scanf(\"%d %d\", &X2[i], &Z2[i]);\n\n    solve();\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nstruct point{ int x,y; };\n\nint m,n;\npoint p[100],q[100];\n\ndouble f(double x){\n\tdouble yl=INF,yr=-INF;\n\trep(i,m){\n\t\tpoint a=p[i],b=p[(i+1)%m];\n\t\tif(a.x>b.x) swap(a,b);\n\t\tif(a.x<=x && x<=b.x && a.x!=b.x){\n\t\t\tdouble y=a.y+(x-a.x)/(b.x-a.x)*(b.y-a.y);\n\t\t\tyl=min(yl,y);\n\t\t\tyr=max(yr,y);\n\t\t}\n\t}\n\n\tdouble zl=INF,zr=-INF;\n\trep(i,n){\n\t\tpoint a=q[i],b=q[(i+1)%n];\n\t\tif(a.x>b.x) swap(a,b);\n\t\tif(a.x<=x && x<=b.x && a.x!=b.x){\n\t\t\tdouble z=a.y+(x-a.x)/(b.x-a.x)*(b.y-a.y);\n\t\t\tzl=min(zl,z);\n\t\t\tzr=max(zr,z);\n\t\t}\n\t}\n\n\treturn max(yr-yl,0.0)*max(zr-zl,0.0);\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&m,&n),m;){\n\t\trep(i,m) scanf(\"%d%d\",&p[i].x,&p[i].y);\n\t\trep(i,n) scanf(\"%d%d\",&q[i].x,&q[i].y);\n\n\t\tint p_min=INF,p_max=-INF;\n\t\tint q_min=INF,q_max=-INF;\n\t\trep(i,m) p_min=min(p_min,p[i].x), p_max=max(p_max,p[i].x);\n\t\trep(i,n) q_min=min(q_min,q[i].x), q_max=max(q_max,q[i].x);\n\n\t\tint X[200];\n\t\trep(i,m) X[ i ]=p[i].x;\n\t\trep(i,n) X[i+m]=q[i].x;\n\t\tsort(X,X+m+n);\n\n\t\tdouble ans=0;\n\t\trep(i,m+n-1){\n\t\t\tdouble a=X[i],b=X[i+1];\n\t\t\tif(max(p_min,q_min)<=a && b<=min(p_max,q_max)){ // 境界だけは線形じゃない ( がたっと落ちる )\n\t\t\t\tans+=(b-a)/6*(f(a)+4*f((a+b)/2)+f(b));\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#define INF 1000000000\nusing namespace std;\nconst double g = 9.8;\nint n, m, x, y;\nint x1[105], y1[105], x2[105], z2[105];\ndouble width(int* x, int* y, int n, double xx) {\n    double lb = INF, ub = -INF;\n    for (int i = 0; i < n; ++i) {\n        double x1 = x[i], y1 = y[i], x2 = x[(i + 1) % n], y2 = y[(i + 1) % n];\n        if ((x1 - xx) * (x2 - xx) <= 0 && x1 != x2) {\n            double y = y1 + (y2 - y1) * (xx - x1) / (x2 - x1);\n            lb = min(lb, y);\n            ub = max(ub, y);\n        }\n    }//printf(\"%f\\n\",ub-lb);\n    return max(0.0, ub - lb);\n}\nint main() {\n    while(scanf(\"%d %d\", &m, &n) && m && n) {\n        vector<int> xs;\n        int min1 = INF, max1 = -INF, min2 = INF, max2 = -INF;\n        for (int i = 0; i < m; ++i) {\n            scanf(\"%d %d\", x1 + i, y1 + i);\n            min1 = min(min1, x1[i]);\n            max1 = max(max1, x1[i]);\n            xs.push_back(x1[i]);\n        }\n        for (int i = 0; i < n; ++i) {\n            scanf(\"%d %d\", x2 + i, z2 + i);\n            min2 = min(min2, x2[i]);\n            max2 = max(max2, x2[i]);\n            xs.push_back(x2[i]);\n        }\n        sort(xs.begin(), xs.end());\n        double ans = 0;\n        for (int i = 0; i + 1 < xs.size(); ++i) {\n            double a = xs[i], b = xs[i + 1];\n            double c = (a + b) / 2;\n            if (min1 <= c && c <= max1 && min2 <= c && c <= max2) {\n                double fa = width(x1, y1, m, a) * width(x2, z2, n, a);\n                double fb = width(x1, y1, m, b) * width(x2, z2, n, b);\n                double fc = width(x1, y1, m, c) * width(x2, z2, n, c);\n                ans += (b - a) / 6 * (fa + 4 * fc + fb);\n            }\n        }\n        printf(\"%.10f\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define double long double\ntypedef complex<double> P;\ndouble eps = 1e-11;\nvector<P> ps1,ps2;\nbool eq(double a,double b){\n\treturn fabs(a-b) < eps;\n}\n\nvector<double> ux;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\npair<double,double> seg(const vector<P> &ps,double x){\n\tdouble mi = 1e9, ma = -1e9;\n\tauto reflesh = [&mi,&ma](double y){\n\t\tmi = min(mi,y);\n\t\tma = max(ma,y);\n\t};\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tP a = ps[i];\n\t\tP b = ps[(i+1)%ps.size()];\n\t\tif( a.real() > b.real() ) swap(a,b);\n\t\tif( eq(a.real(),x) ) reflesh(a.imag());\n\t\tif( eq(b.real(),x) ) reflesh(b.imag());\n\t\tif( a.real() + eps < x and x < b.real() - eps ){\n\t\t\treflesh(a.imag() + (x - a.real()) * (b.imag() - a.imag()) / (b.real()-a.real()));\n\t\t}\n\t}\n\tif( ma < mi ) return {0.0,0.0};\n\treturn {mi,ma};\n}\n\ndouble Sf(double x){\n\tauto p = seg(ps1,x);\n\treturn p.second - p.first;\n}\n\ndouble Ss(double l,double r){\n\treturn (r-l)/6*(Sf(l)+4*Sf((l+r)/2)+Sf(r));\n}\n\ndouble S2(double l,double r,int k=2){\n\tif( r < l ) return 0;\n\tdouble m = (l+r)/2;\n\tdouble a = Ss(l,m);\n\tdouble b = Ss(m,r);\n\tdouble c = Ss(l,r);\n\tif( (c>eps or k <= 0) and eq(a+b,c) ){\n\t\t//cout << a+b << \" \" << c << endl;\n\t\treturn c;\n\t}else{\n\t\treturn S2(l,m,k-1) + S2(m,r,k-1);\n\t}\t\n}\ndouble S(double l,double r){\n\tdouble sans = 0;\n\tfor(int i = 0 ; i+1 < ux.size() ; i++){\n\t\tif( ux[i] != ux[i+1] ){\n\t\t\tsans += S2(max(l,ux[i]),min(r,ux[i+1]));\n\t\t}\n\t}\n\t//cout << sans << endl;\n\treturn sans;\n\t\n}\n\ndouble Vf(double z){\n\tauto p = seg(ps2,z);\n\treturn S(p.first,p.second);\n}\n\ndouble Vs(double l,double r){\n\treturn (r-l)/6*(Vf(l)+4*Vf((l+r)/2)+Vf(r));\n}\n\ndouble V(double l,double r,int k=4){\n\tdouble m = (l+r)/2;\n\tdouble a = Vs(l,m);\n\tdouble b = Vs(m,r);\n\tdouble c = Vs(l,r);\n\tif( (c>eps or k <= 0) and eq(a+b,c) ){\n\t\treturn c;\n\t}else{\n\t\treturn V(l,m,k-1) + V(m,r,k-1);\n\t}\t\n}\n\nint main(){\n\tint m,n;\n\twhile(cin >> m >> n && m ){\n\t\t\n\t\tps1.clear();\n\t\tps2.clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tps1.push_back(in());\n\t\t\tux.push_back(ps1.back().real());\n\t\t}\n\n\t\tvector<double> uz;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tps2.push_back(in());\n\t\t\tps2.back() = P(ps2.back().imag(),ps2.back().real());\n\t\t\tuz.push_back(ps2.back().real());\n\t\t}\n\t\tsort(uz.begin(),uz.end());\n\t\tsort(ux.begin(),ux.end());\n\t\tdouble vans = 0;\n\t\t//for( auto z : uz ) cout << z << \" \"; cout << endl;\n\t\t//for( auto x : ux ) cout << x << \" \"; cout << endl;\n\t\tfor(int i = 0 ; i+1 < uz.size() ; i++)\n\t\t\tif( uz[i] != uz[i+1] )\n\t\t\t\tvans += V(uz[i],uz[i+1]);\n\t\tprintf(\"%.15Lf\\n\",vans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ndouble ax[110];\ndouble ay[110];\ndouble bx[110];\ndouble by[110];\ndouble ev[500];\ndouble x[500];\ndouble y[500];\ndouble z[500];\ndouble EPS=1e-9;\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tint sz=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%lf%lf\",ax+i,ay+i);\n\t\t\tev[sz++]=ax[i]+EPS;\n\t\t\tev[sz++]=ax[i]-EPS;\n\t\t}\n\t\tax[a]=ax[0];\n\t\tay[a]=ay[0];\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%lf%lf\",bx+i,by+i);\n\t\t\tev[sz++]=bx[i]-EPS;\n\t\t\tev[sz++]=bx[i]+EPS;\n\t\t}\n\t\tbx[b]=bx[0];\n\t\tby[b]=by[0];\n\t\tstd::sort(ev,ev+sz);\n\t\tfor(int i=0;i<sz;i++){\n\t\t\tx[i]=ev[i];\n\t\t\tdouble L=-999999999;\n\t\t\tdouble R=999999999;\n\t\t\tvector<double> ps;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tif(min(ax[j],ax[j+1])-EPS<x[i]&&x[i]<EPS+max(ax[j],ax[j+1])){\n\t\t\t\t\tif(min(ax[j],ax[j+1])+EPS>max(ax[j],ax[j+1])){\n\t\t\t\t\t\tps.push_back(ay[j]);\n\t\t\t\t\t\tps.push_back(ay[j+1]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble M=ay[j]+(ay[j+1]-ay[j])*(x[i]-ax[j])/(ax[j+1]-ax[j]);\n\t\t\t\t\tps.push_back(M);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::sort(ps.begin(),ps.end());\n\t\t\tif(ps.size()==0)ps.push_back(0);\n\t\t\ty[i]=ps[ps.size()-1]-ps[0];\n\t\t\tL=-999999999;\n\t\t\tR=999999999;\n\t\t\tps.clear();\n\t\t\tfor(int j=0;j<b;j++){\n\t\t\t\tif(min(bx[j],bx[j+1])-EPS<x[i]&&x[i]<EPS+max(bx[j],bx[j+1])){\n\t\t\t\t\tif(min(bx[j],bx[j+1])+EPS>max(bx[j],bx[j+1])){\n\t\t\t\t\t\tps.push_back(by[j]);\n\t\t\t\t\t\tps.push_back(by[j+1]);\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tdouble M=by[j]+(by[j+1]-by[j])*(x[i]-bx[j])/(bx[j+1]-bx[j]);\n\t\t//\t\t\tprintf(\"%d: %f\\n\",j,M);\n\t\t\t\t\tps.push_back(M);\n\t\t\t\t}\n\t\t\t}\n\t\t\tstd::sort(ps.begin(),ps.end());\n\t\t\t\n\t\t\tif(ps.size()==0)ps.push_back(0);\n\t\t\tz[i]=ps[ps.size()-1]-ps[0];\n\t\t\t\n\t\t}\n\t\tdouble V=0;\n\t\tfor(int i=1;i<sz;i++){\n\t\t\tif(x[i]<x[i-1]+EPS)continue;\n\t\t\tV+=(x[i]-x[i-1])*(y[i]*z[i]+y[i-1]*z[i-1]+(y[i]+y[i-1])*(z[i]+z[i-1]))/6;\n\t//\t\tprintf(\"%f %f %f %f\\n\",x[i],y[i],z[i],(x[i]-x[i-1])*(y[i]*z[i]+y[i-1]*z[i-1]+(y[i]+y[i-1])*(z[i]+z[i-1]))/6);\n\t\t}\n\t\tprintf(\"%.12f\\n\",V);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\n\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return (a.X!=b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nbool intersectLS(const L& l, const L& s){\n    return cross(l[1]-l[0], s[0]-l[0])*\n        cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n\nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B/A *(m[1]-m[0]);\n}\n\ndouble getarea(const VP &poly){\n    double ret = 0;\n    for (int i=0; i<(int)poly.size(); i++){ \n        ret += cross(poly[i], poly[(i+1)%poly.size()]);\n    }\n    return ret*0.5;\n}\n\nVP convex_cut(const VP& p, const L& l){\n    VP ret;\n    int n = p.size();\n    for(int i=0; i<n; i++){\n        P curr = p[i];\n        P next = p[(i+1)%n];\n        if(ccw(l[0], l[1], curr) != -1) ret.push_back(curr);\n        if(ccw(l[0], l[1], curr) *ccw(l[0], l[1], next) == -1){\n            ret.push_back(crosspointLL(L(curr, next), l));\n        }\n    }\n    return ret;\n}\n\nstruct c2cut{\n    double z, x[2];\n    c2cut(double z, double xmin, double xmax):z(z),x{xmin, xmax}{}\n    c2cut(){}\n    bool operator <(const c2cut &a){\n        return z < a.z;\n    }\n    bool operator ==(const c2cut &a){\n        return z == a.z;\n    }\n};\n\nint main(){\n    while(1){\n        int m,n;\n        cin >> m >> n;\n        if(n==0) break;\n        \n        VP c1(m), c2(n);\n        for(int i=0; i<m; i++){\n            double x,y;\n            cin >> x >> y;\n            c1[i] = P(x, y);\n        }\n        for(int i=0; i<n; i++){\n            double x,z;\n            cin >> x >> z;\n            c2[i] = P(x, z);\n        }\n\n        vector<c2cut> cz(n);\n        for(int i=0; i<n; i++){\n            double z = c2[i].Y;\n            L cutline(P(0, z), P(1, z));\n            vector<double> cpx;\n            for(int i=0; i<n; i++){\n                L edge(c2[i], c2[(i+1)%n]);\n                if(!isParallel(cutline, edge) && intersectLS(cutline, edge)){\n                    cpx.push_back((crosspointLL(cutline, edge)).X);\n                }\n            }\n            double xmin = *min_element(cpx.begin(), cpx.end());\n            double xmax = *max_element(cpx.begin(), cpx.end());\n            cz[i] = c2cut(z, xmin, xmax);\n        }\n        sort(cz.begin(), cz.end());\n        cz.erase(unique(cz.begin(), cz.end()), cz.end());\n\n        double ans = 0;\n        for(int i=0; i<(int)cz.size()-1; i++){\n            vector<double> zdiff;\n            for(int d=0; d<2; d++){\n                double x[2] = {cz[i].x[d], cz[i+1].x[d]};\n                if(abs(x[1] -x[0]) < EPS) continue;\n                if(x[0] > x[1]) swap(x[0], x[1]);\n                L cut[2] = {L(P(x[1], 0), P(x[1], 1)), L(P(x[0], 1), P(x[0], 0))};\n                VP p = convex_cut(c1, cut[0]);\n                p = convex_cut(p, cut[1]);\n                for(int j=0; j<(int)p.size(); j++){\n                    double xdiff = abs(p[j].X -cz[i].x[d]);\n                    zdiff.push_back((cz[i+1].z -cz[i].z) *xdiff/(x[1]-x[0]));\n                }\n            }\n            sort(zdiff.begin(), zdiff.end());\n            zdiff.erase(unique(zdiff.begin(), zdiff.end()), zdiff.end());\n\n            for(int j=0; j<(int)zdiff.size()-1; j++){\n                double z[3];\n                z[0] = cz[i].z +zdiff[j];\n                z[2] = cz[i].z +zdiff[j+1];\n                z[1] = (z[0] +z[2])/2;\n                double area[3];\n                for(int k=0; k<3; k++){\n                    L cutline(P(0, z[k]), P(1, z[k]));\n                    vector<double> cpx;\n                    for(int i=0; i<n; i++){\n                        L edge(c2[i], c2[(i+1)%n]);\n                        if(!isParallel(cutline, edge) && intersectLS(cutline, edge)){\n                            cpx.push_back((crosspointLL(cutline, edge)).X);\n                        }\n                    }\n                    double xmin = *min_element(cpx.begin(), cpx.end());\n                    double xmax = *max_element(cpx.begin(), cpx.end());\n                    L cut[2] = {L(P(xmax, 0), P(xmax, 1)), L(P(xmin, 1), P(xmin, 0))};\n                    VP con = convex_cut(c1, cut[0]);\n                    con = convex_cut(con, cut[1]);\n                    area[k] = getarea(con);\n                }\n                ans += (z[2] -z[0])/6 *(area[0] +4*area[1] +area[2]);\n            }\n        }\n\n        cout << fixed << setprecision(10);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 0x7fffffff;\nconst int MAXN = 110;\nint M,N;\nint X1[MAXN],Y1[MAXN];\nint X2[MAXN],Z2[MAXN];\n\ndouble width(int* X, int* Y, int n, double x)\n{\n    double lb = INF,ub = -INF;\n    for(int i = 0; i < n; ++i)\n    {\n        double x1 = X[i], y1 = Y[i], x2 = X[(i+1)%n], y2 = Y[(i+1)%n];\n        if((x1-x)*(x2-x) <= 0 && x1 != x2)\n        {\n            double y = y1 + (y2-y1)*(x-x1)/(x2-x1);\n            lb = min(lb,y);\n            ub = max(ub,y);\n        }\n    }\n    return max(0.0,ub-lb);\n}\n\nvoid solve()\n{\n    int min1 = *min_element(X1, X1 + M), max1 = *max_element(X1, X1 + M);\n    int min2 = *min_element(X2, X2 + N), max2 = *max_element(X2, X2 + N);\n    vector<int> xs;\n    for (int i = 0; i < M; i++)\n        xs.push_back(X1[i]);\n    for (int i = 0; i < N; i++)\n        xs.push_back(X2[i]);\n    sort(xs.begin(), xs.end());\n\n    double res = 0;\n    for (int i = 0; i + 1 < xs.size(); i++)\n    {\n        double a = xs[i], b = xs[i + 1], c = (a + b) / 2;\n        if (min1 <= c && c <= max1 && min2 <= c && c <= max2)\n        {\n            double fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n            double fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n            double fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n            res += (b - a) / 6 * (fa + 4 * fc + fb);\n        }\n    }\n    printf(\"%.10f\\n\", res);\n}\n\nint main()\n{\n    while(scanf(\"%d %d\",&M,&N) && M+N)\n    {\n        for(int i = 0; i < M; ++i)\n            scanf(\"%d %d\",&X1[i],&Y1[i]);\n        for(int i = 0; i < N; ++i)\n            scanf(\"%d %d\",&X2[i],&Z2[i]);\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\nconst int INF = 100000000;\n\nint M,N;\nint X1[100+10], X2[100+10], Y[100+10], Z[100+10], P[200+10];\ndouble ans=0.0;\n\ndouble width(int* X, int* YZ, int n, double x){  \n\tdouble lb=INF, ub=-INF;  \n\tfor (int i=0; i<n; i++){  \n\t\tdouble x1=X[i], y1=YZ[i], x2=X[(i+1) % n], y2=YZ[(i+1) % n];  \n\t\tif ((x1-x) * (x2-x) <= 0 && x1 != x2){   \n\t\t\tdouble y=y1 + (y2-y1) * (x-x1) / (x2-x1);  \n\t\t\tlb = min(lb, y);  \n\t\t\tub = max(ub, y);  \n\t\t}  \n\t} \n\treturn max(0.0, ub-lb);  \n}  \n\n\nvoid solve(){\n\tans = 0.0;\n\tint min1 = *min_element(X1,X1+M);\n\tint min2 = *min_element(X2,X2+N);\n\tint max1 = *max_element(X1,X1+M);\n\tint max2 = *max_element(X1,X2+N);\n\t\n\tsort(P,P+M+N);\n\t\t\n\tfor (int i=0; i<M+N-1; i++){\n\t\tdouble a = P[i];\n\t\tdouble b = P[i+1];\n\t\tdouble c = (a+b)/2;\n\t\tif (min1<=c && min2<=c && c<=max1 && c<=max2){\n\t\t\tdouble fa = width(X1, Y, M, a) * width(X2, Z, N, a);  \n\t\t\tdouble fb = width(X1, Y, M, b) * width(X2, Z, N, b);  \n\t\t\tdouble fc = width(X1, Y, M, c) * width(X2, Z, N, c);\n\t\t\tans += (b-a)/6*(fa+4*fc+fb);\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", ans);\n}\n\nint main() {\n\twhile ((cin >> M >> N) && M && N){\n\t\tfor (int i=0; i<M; i++){\n\t\t\tcin >> X1[i] >> Y[i];\n\t\t\tP[i] = X1[i];\n\t\t}\n\t\tfor (int i=0; i<N; i++){\n\t\t\tcin >> X2[i] >> Z[i];\n\t\t\tP[M+i] = X2[i];\n\t\t}\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ndouble width(const pair<int,int> P[], double x, int length){\n    vector<double> w(0);\n    for(int i = 0; i < length; i++){\n        pair<int,int> p,q;\n        p = P[i];\n        i != length-1 ? q = P[i+1] : q = P[0];\n        if(p.first == x){\n            w.push_back(p.second);\n        }else if((p.first < x && x < q.first) || (p.first > x && x > q.first)){\n            int x0,y0,x1,y1;\n            if(p.first < x){\n                x0 = p.first;\n                y0 = p.second;\n                x1 = q.first;\n                y1 = q.second;\n            }else{\n                x0 = q.first;\n                y0 = q.second;\n                x1 = p.first;\n                y1 = p.second;\n            }\n            w.push_back(y0 + 1.0*(y1-y0)*(x-x0)/(x1-x0));\n        }\n    }\n    sort(w.begin(),w.end());\n    return w.front() - w.back();\n}\n\n//P1??¨P2????????????????????????????????????x????????????sort?????????x???????????????????¬???¢??°?????????????????????\ndouble volume(const pair<int,int> P1[], const pair<int,int> P2[], pair<int,int> X[],int m, int n){\n    /*\n    for(int i = 0; i < m+n; i++){\n        if(i < m){\n            printf(\"P1[%d]:%d %d\\n\",i,P1[i].first,P1[i].second);\n        }else{\n            printf(\"P2[%d]:%d %d\\n\",i-m,P2[i-m].first,P2[i-m].second);\n        }\n    }\n     */\n    sort(X,X+m+n);\n    pair<int,int> p1mm = P1[0], p2mm = P2[0];\n    for(int i = 0; i < m; i++){\n        if(p1mm.first > P1[i].first){\n            p1mm.first = P1[i].first;\n        }\n        if(p1mm.second < P1[i].first){\n            p1mm.second = P1[i].first;\n        }\n    }\n    for(int i = 0; i < n; i++){\n        if(p2mm.first > P2[i].first){\n            p2mm.first = P2[i].first;\n        }\n        if(p2mm.second < P2[i].first){\n            p2mm.second = P2[i].first;\n        }\n    }\n    /*\n    printf(\"p1mm: %d %d\\np2mm: %d %d\\n\",p1mm.first,p1mm.second,p2mm.first,p2mm.second);\n    for(int i = 0; i < m+n; i++){\n        if(i < m){\n            printf(\"P1[%d]:%d %d\\n\",i,P1[i].first,P1[i].second);\n        }else{\n            printf(\"P2[%d]:%d %d\\n\",i-m,P2[i-m].first,P2[i-m].second);\n        }\n    }*/\n    int xmin = max(p1mm.first,p2mm.first), xmax = min(p1mm.second,p2mm.second);\n    //printf(\"minmax: %d %d\\n\",xmin,xmax);\n    double sum = 0;\n    for(int i = 0; i < m+n-1; i++){\n        pair<int,int> a = X[i], b = X[i+1];\n        if(xmin <= a.first && xmax >= a.first && xmin <= b.first && xmax >= b.first){\n            if(a.first == b.first){\n                continue;\n            }\n            double mid = (a.first + b.first) / 2.0;\n            double va = width(P1,a.first,m) * width(P2,a.first,n);\n            double vb = width(P1,b.first,m) * width(P2,b.first,n);\n            double vmid = width(P1,mid,m) * width(P2,mid,n);\n            double area = (b.first - a.first)/6.0 * (va + 4*vmid + vb);\n            //printf(\"a,b %d %d\\nmid %f\\nva %f\\nvb %f\\nvmid %f\\narea %f\\n\",a.first,b.first,mid,va,vb,vmid,area);\n            sum += area;\n        }\n    }\n    return sum;\n}\n\nint main(){\n    while(true){\n        int m,n;\n        scanf(\"%d %d\",&m,&n);\n        if(m == 0 && n == 0){\n            break;\n        }\n        pair<int,int> *P1 = new pair<int,int>[m], *P2 = new pair<int,int>[n],*X = new pair<int,int>[m+n];\n        for(int i = 0; i < m+n; i++){\n            int x,y;\n            scanf(\"%d %d\",&x,&y);\n            if(i < m){\n                P1[i] = make_pair(x,y);\n            }else{\n                P2[i-m] = make_pair(x,y);\n            }\n            X[i] = make_pair(x,y);\n        }\n        double vol = volume(P1,P2,X,m,n);\n        printf(\"%f\\n\",vol);\n        delete [] P1;\n        delete [] P2;\n        delete [] X;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double dbl;\n#define double long double\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define REP(i,n) for(int i = 0 ; i < n ; i++)\ndouble eps = 1e-11;\ndouble EPS = eps;\n\nbool eq(double a,double b){\n\treturn fabs(a-b) < eps;\n}\n\ndouble cross(P a,P b) { return imag(conj(a)*b); }\ndouble dot(P a,P b) { return real(conj(a)*b);}\n\nvector<P> ps1,ps2;\n//??´???\nstruct L : public vector<P> {\n\tL(P a,P b) {\n\t\tpush_back(a); push_back(b);\n\t}\n\t\n};\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\t// a ??? b ??§???????¨??????????????????? b ??? c(???)\n\tif (cross(b, c) < 0)   return -1;\t// a ??? b ??§????¨??????????????????? b ??? c(???)\n\tif (dot(b, c) < 0) return +2;    \t// a???b??§????????????a??????????¶???????b???c(c--a--b)\n\tif (norm(b) < norm(c)) return -2;\t// a???b??§????????????b???c(a--b--c)\n\treturn 0;\t\t\t\t\t\t\t// a???b??§????????????b???c(????????? b == c)\n}\n \n\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n \n \n// ???????§???¢???????????????????§???¢???????????´?????§????????????\n//???????????´?????????????????´?????????????????´?????????????????¨?????????????????¨?????????????????????????????¨????????????????????????\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\nG convex_cut(const G& poly, const L& l) {\n  G Q;\n  for (int i = 0; i < poly.size(); ++i) {\n    P A = curr(poly, i), B = next(poly, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspoint(L(A, B), l));\n  }\n  return Q;\n}\n\n// ????´?????§???¢?????¢??????\"2???\"????±??????? O(n)\ndouble area2(const G& poly) {\n\tdouble A = 0;\n\tREP(i,poly.size()) A += cross(curr(poly, i), next(poly, i));\n\treturn abs(A);\n}\n\n\nvector<double> ux;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\t\n\treturn P(x,y);\n}\npair<double,double> seg(const vector<P> &ps,double x){\n\tdouble mi = 1e9, ma = -1e9;\n\tauto reflesh = [&mi,&ma](double y){\n\t\tmi = min(mi,y);\n\t\tma = max(ma,y);\n\t};\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tP a = ps[i];\n\t\tP b = ps[(i+1)%ps.size()];\n\t\tif( a.real() > b.real() ) swap(a,b);\n\t\tif( eq(a.real(),x) ) reflesh(a.imag());\n\t\tif( eq(b.real(),x) ) reflesh(b.imag());\n\t\tif( a.real() + eps < x and x < b.real() - eps ){\n\t\t\treflesh(a.imag() + (x - a.real()) * (b.imag() - a.imag()) / (b.real()-a.real()));\n\t\t}\n\t}\n\tif( ma < mi ) return {0.0,0.0};\n\treturn {mi,ma};\n}\n\ndouble S(double l,double r){\n\tif( r <= l ) return 0;\n\tG g1 = convex_cut(ps1,L(P(l,0),P(l,-1)));\n\tG g2 = convex_cut(g1,L(P(r,0),P(r,+1)));\n\t\n\treturn area2(g2) / 2;\n\t\n}\n\ndouble Vf(double z){\n\tauto p = seg(ps2,z);\n\treturn S(p.first,p.second);\n}\n\ndouble Vs(double l,double r){\n\treturn (r-l)/6*(Vf(l)+4*Vf((l+r)/2)+Vf(r));\n}\n\ndouble V(double l,double r,int k=6){\n\tif( l >= r ) return 0;\n\tdouble m = (l+r)/2;\n\tdouble a = Vs(l,m);\n\tdouble b = Vs(m,r);\n\tdouble c = Vs(l,r);\n\tif( ( k <= 0) and eq(a+b,c) ){\n\t\treturn c;\n\t}else{\n\t\treturn V(l,m,k-1) + V(m,r,k-1);\n\t}\t\n}\n\nint main(){\n\tint m,n;\n\twhile(cin >> m >> n && m ){\n\t\t\n\t\tps1.clear();\n\t\tps2.clear();\n\t\tux.clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tps1.push_back(in());\n\t\t\tux.push_back(ps1.back().real());\n\t\t}\n\n\t\tvector<double> uz;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tps2.push_back(in());\n\t\t\tps2.back() = P(ps2.back().imag(),ps2.back().real());\n\t\t\tuz.push_back(ps2.back().real());\n\n\t\t}\n\t\t\n\t\tsort(uz.begin(),uz.end());\n\t\tsort(ux.begin(),ux.end());\n\t\tdouble vans = 0;\n\t\t//for( auto z : uz ) cout << z << \" \"; cout << endl;\n\t\t//for( auto x : ux ) cout << x << \" \"; cout << endl;\n\t\tfor(int i = 0 ; i+1 < uz.size() ; i++)\n\t\t\tif( uz[i] != uz[i+1] )\n\t\t\t\tvans += V(uz[i],uz[i+1]);\n\t\tprintf(\"%.8lf\\n\",(dbl)vans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <unordered_map>\n#include <iterator>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef long double R;\n\tconst R INF = 1e8;\n\tR EPS = 1e-6;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t};\n\tstruct G : public vector<P>{\n\t\tG(size_type size=0):vector(size){}\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t};\n\tBOOL intersect(const S &s, const S &t){\n\t\tconst int p = ccw(t[0], t[1], s[0], 1) * ccw(t[0], t[1], s[1], 1);\n\t\tconst int q = ccw(s[0], s[1], t[0], 1) * ccw(s[0], s[1], t[1], 1);\n\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t}\n\tBOOL intersect(const S &s, const L &l){\n\t\treturn (sig(outp(l.dir(), s[0]-l[0])) * sig(outp(l.dir(), s[1]-l[0])) <= 0);\n\t}\n\tinline P crosspoint(const L &l, const L &m){\n\t\tR A = outp(l.dir(), m.dir()), B = outp(l.dir(), l[1] - m[0]);\n\t\tif(!sig(abs(A)) && !sig(abs(B))) return m[0]; // same line\n\t\tif(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\t\treturn m[0] + B / A * (m[1] - m[0]);\n\t}\n\n\ttemplate<class Func> R simpson(R s, R t, Func func){\n\t\treturn (t-s)/6*(func(s) + func(t) + 4*func((s+t)*(R).5));\n\t}\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nint f = 0;\nnamespace std{\n\tbool operator<(const P &a, const P &b){return sig(a.X-b.X) ? a.X < b.X : a.Y+EPS < b.Y;}\n\tbool operator==(const P &a, const P &b){return abs(a-b) < EPS;}\n\tistream& operator>>(istream &is, P &p){R x,y;is>>x>>y;p=P(x, y);return is;}\n\tistream& operator>>(istream &is, L &l){l.resize(2);return is >> l[0] >> l[1];}\n}\n\nint n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> m >> n, n){\n\t\tG g1(m), g2(n);\n\t\tvector<R> x;\n\t\tREP(i, m){\n\t\t\tcin >> g1[i];\n\t\t\tx.push_back(g1[i].X);\n\t\t}\n\t\tREP(i, n){\n\t\t\tcin >> g2[i];\n\t\t\tx.push_back(g2[i].X);\n\t\t}\n\t\tsort(ALL(x));UNIQUE(x);\n\t\t\n\t\tauto width = [&](const G &g, R x){\n\t\t\tL l(P(x, 0), P(x, 1));\n\t\t\tR b = INF, u = -INF;\n\t\t\tREP(i, g.size()){\n\t\t\t\tif(sig(g.edge(i).dir().X) && intersect(g.edge(i), l)){\n\t\t\t\t\tP p = crosspoint(g.edge(i), l);\n\t\t\t\t\tb = min(b, p.Y);\n\t\t\t\t\tu = max(u, p.Y);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn u-b;\n\t\t};\n\t\tauto area = [&](R x){\n\t\t\treturn width(g1, x) * width(g2, x);\n\t\t};\n\t\t\n\t\tR ans = 0;\n\t\tREP(i, (int)x.size()-1){\n\t\t\tans += max<R>(0, simpson(x[i], x[i+1], area));\n\t\t}\n\t\tprintf(\"%.10f\\n\", (double)ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <deque>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\nconst int maxn = 110;\nconst double INF = 1e20;\n\nint m , n;\nint x1[maxn] , y1[maxn];\nint x2[maxn] , z2[maxn];\n\ndouble width(int* X , int* Y , int n , double x)\n{\n\tdouble lb = INF , ub = -INF;\n\tfor(int i=0;i<n;i++) \n\t{\n\t\tdouble x1 = X[i] , y1 = Y[i] , x2 = X[(i+1)%n] , y2 = Y[(i+1)%n];\n\t\tif((x1-x)*(x2-x)<=0 && x1!=x2)\n\t\t{\n\t\t\tdouble y = y1+(y2-y1)*(x-x1)/(x2-x1);\n\t\t\tlb = min(lb , y);\n\t\t\tub = max(ub , y);\n\t\t}\n\t}\n\treturn max(0.0 , ub-lb); \n}\n\nvoid solve()\n{\n\tint min1 = *min_element(x1, x1+m) , max1 = *max_element(x1, x1+m);\n\tint min2 = *min_element(x2, x2+n) , max2 = *max_element(x2, x2+n);\n\n\tvector<int> xs;\n\tfor(int i=0;i<m;i++) xs.push_back(x1[i]);\n\tfor(int i=0;i<n;i++) xs.push_back(x2[i]);\n\tsort(xs.begin(), xs.end());\n\t\n\tdouble res = 0;\n\tfor(int i=0;i+1<xs.size();i++) \n\t{\n\t\tdouble a = xs[i] , b = xs[i+1] , c = (a+b)/2;\n\t\tif(min1<=c && c<=max1 && min2<=c && c<=max2)\n\t\t{\n\t\t\tdouble fa = width(x1, y1, m, a)*width(x2, z2, n, a);\n\t\t\tdouble fb = width(x1, y1, m, b)*width(x2, z2, n, b);\n\t\t\tdouble fc = width(x1, y1, m, c)*width(x2, z2, n, c);\n\t\t\tres+= (b-a)/6.0*(fa+4*fc+fb);\n\t\t}\n\t}\n\tprintf(\"%.10lf\\n\",res);\n}\n\nint main(int argc, char *argv[]) {\n\t\n\twhile(cin>>m>>n && n+m)\n\t{\n\t\tfor(int i=0;i<m;i++) cin>>x1[i]>>y1[i];\n\t\tfor(int i=0;i<n;i++) cin>>x2[i]>>z2[i];\n\t\tsolve(); \n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define MAX 110\n#define inf 1<<29\n#define linf 1e16\n#define eps (1e-8)\n#define mod 1000000007\n#define pi acos(-1)\n#define f first\n#define s second\n#define mp make_pair\n#define pb push_back\n#define all(a) (a).begin(),(a).end()\n#define pd(a) printf(\"%.10f\\n\",(double)(a))\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef pair<int,double> pid;\ntypedef pair<double,int> pdi;\ntypedef vector<int> vi;\ntypedef vector<pii> vpi;\nconst int dx[8]={1,0,-1,0,1,1,-1,-1};\nconst int dy[8]={0,1,0,-1,1,-1,1,-1};\n\nint m,n;\nint X1[MAX],Y1[MAX];\nint X2[MAX],Z2[MAX];\n\ndouble width(int* X,int* Y,int N,double x){\n  double lb=inf,ub=-inf;\n  FOR(i,0,N){\n    double x1=X[i],y1=Y[i],x2=X[(i+1)%N],y2=Y[(i+1)%N];\n    if((x1-x)*(x2-x)<=0 && x1!=x2){\n      double y=y1+(y2-y1)*(x-x1)/(x2-x1);\n      lb=min(lb,y);\n      ub=max(ub,y);\n    }\n  }\n  return max(0.0,ub-lb);\n}\n\ndouble solve(){\n  int min1=*min_element(X1,X1+m),max1=*max_element(X1,X1+m);\n  int min2=*min_element(X2,X2+n),max2=*max_element(X2,X2+n);\n  vector<double> xs;\n  FOR(i,0,m)xs.pb(X1[i]);\n  FOR(i,0,m)xs.pb(X2[i]);\n  sort(all(xs));\n\n  double res = 0.0;\n  FOR(i,0,xs.size()-1){\n    double a=xs[i],b=xs[i+1],c=(a+b)/2.0;\n    if(min1<=c && c<=max1 && min2<=c && c<=max2){\n      double fa=width(X1,Y1,m,a)*width(X2,Z2,n,a);\n      double fb=width(X1,Y1,m,b)*width(X2,Z2,n,b);\n      double fc=width(X1,Y1,m,c)*width(X2,Z2,n,c);\n      res+=(b-a)/6.0*(fa+fb+fc*4.0);\n    }\n  }\n  return res;\n}\n\nint main()\n{\n  while(cin>>m>>n && m){\n    FOR(i,0,m)cin>>X1[i]>>Y1[i];\n    FOR(i,0,n)cin>>X2[i]>>Z2[i];\n    pd(solve());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <list>\n#include <string.h>\nusing namespace std;\ntypedef long long int ll; typedef pair <int, int> P;\nconst double INF = 1000000000; const double EPS = 10e-9;\nint x1[100], y[100], x2[100], z[100];\ndouble width(int *X, int *Y, int n, double x) {\n\tdouble lb = -INF, ub = INF;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x1 = X[i], x2 = X[(i + 1) % n], y1 = Y[i], y2 = Y[(i + 1) % n];\n\t\tif ((x1 - x) * (x2 - x) > 0 || x1 == x2) continue;\n\t\tdouble y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n\t\tlb = max(lb, y);\n\t\tub = min(ub, y);\n\t}\n\treturn max(0.0, lb - ub);\n}\nint main()\n{\n\twhile (true)\n\t{\n\t\tvector <int> x;\n\t\tint m, n; cin >> m >> n;\n\t\tif (m == 0 && n == 0) break;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x1[i] >> y[i];\n\t\t\tx.push_back(x1[i]);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x2[i] >> z[i];\n\t\t\tx.push_back(x2[i]);\n\t\t}\n\t\tint minx1 = *min_element(x1, x1 + m), maxx1 = *max_element(x1, x1 + m);\n\t\tint minx2 = *min_element(x2, x2 + n), maxx2 = *max_element(x2, x2 + n);\n\t\tsort(x.begin(), x.end());\n\t\tdouble res = 0.0;\n\t\tfor (int i = 0; i + 1 < m + n; i++)\n\t\t{\n\t\t\tdouble a = x[i], b = x[i + 1], c = (a + b) / 2;\n\t\t\tif (minx1 < c && c < maxx1 && minx2 < c && c < maxx2)\n\t\t\t{\n\t\t\t\tdouble sa = width(x1, y, m, a) * width(x2, z, n, a);\n\t\t\t\tdouble sb = width(x1, y, m, b) * width(x2, z, n, b);\n\t\t\t\tdouble sc = width(x1, y, m, c) * width(x2, z, n, c);\n\t\t\t\tres += (b - a) / 6 * (sa + sb + 4 * sc);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10f\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint m,n;\nconst double EPS = 1e-11;\nvector<pair<int,int> > Pxy,Pyz;\npair<int,int> tem;\nvector<int> X;\n\nint findMax(vector<int> vec) {\n    int maxs = -999;\n    for (auto v : vec) {\n        if (maxs < v) maxs = v;\n    }\n    return maxs;\n}\n\nint findMin(vector<int> vec) {\n    int mins = 999;\n    for (auto v : vec) {\n        if (mins > v) mins = v;\n    }\n    return mins;\n}\n\ndouble width(vector<pair<int,int> > polygon,int x){\n    vector<double> w;\n    for(int i=0;i<polygon.len();i++){\n        pair<int,int> p=polygon[i];\n        pair<int,int> q=polygon[(i+1)%polygon.len()];\n        if((p.first-x)<EPS){\n            w.push_back(1.0*p.second);\n        }\n        else if(p.first<x && x<q.first|| p.first>0 && x>q.first){\n            int x0=p.first;\n            int y0=p.second;\n            int x1=q.first;\n            int y1=q.second;\n            w.push_back(y0+1.0*(y1-y0)*(x-x0)/(x1-x0));\n        }\n    }\n    assert(w.len()>0);\n    return (findMax(w)-findMin(w));\n}\n\nint volume(vector<pair<int,int> >Pxy,vector<pair<int,int> >Pxz,vector<int> X){\n    double total=0.0;\n    int xmin = max((*min_element(pxy.begin(), pxy.end())).first,\n                   (*min_element(pxz.begin(), pxz.end())).first);\n    int xmax = min((*max_element(pxy.begin(), pxy.end())).first,\n                   (*max_element(pxz.begin(), pxz.end())).first);\n    sort(X.begin(), X.end());\n    for(int i=0;i<X.len()-1;i++){\n        int a=X[i];\n        int b=X[i+1];\n        if(!(xmin <= a && a <= xmax &&xmin <= b && b<< xmax) ){\n            continue;\n        }\n        int m=(a+b)/2.0;\n        va = width(Pxy, a)*width(Pxz, a);\n        vb = width(Pxy, b)*width(Pxz, b);\n        m = width(Pxy, m)*width(Pxz, m);\n        double area=((b-a)/6.0)*(va + 4.0*vm + vb);\n        total+=area;\n    }\n    return total;\n}\nint main(){\n    while(cin>>m>>n&&n!=0){\n        for(int i=1;i<=m;i++){\n            cin>>tem.first>>tem.second;\n            Pxy.push_back(tem);\n            X.push_back(x);\n        }\n        for(int j=1;j<=n;j++){\n            cin>>tem.first>>tem.second;\n            Pxz.push_back(tem);\n            X.push_back(x);\n        }\n        cout << fixed << volume(PXY, PXZ, X) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <deque>\n#include <queue>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdio>\n#include <stdio.h>\n\nusing namespace std;\n\n#define fo(i,n) for(int i=0; i<(int)n; i++)\n#define rep(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#define mp(a,b) make_pair(a,b)\n#define pb(x) push_back(x)\n#define pii pair<int,int>\n\nint n,m;\nstruct point{\n\tdouble x,y;\n\tpoint(int x=0, int y=0): x(x),y(y){}\n};\nvector<point> xy,xz;\nvector<int> xs;\n\ndouble area(double x, vector<point> &v) {\n\tdouble lo = 100000;\n\tdouble hi = -100000;\n\t\n\tfor (int i=0; i<v.size(); i++) {\n\t\tdouble x1 = v[i].x;\n\t\tdouble x2 = v[(i+1)%v.size()].x;\n\t\tdouble y1 = v[i].y;\n\t\tdouble y2 = v[(i+1)%v.size()].y;\n\t\t\n\t\tif ((x-x2)*(x-x1)<=0) {\n\t\t\tdouble m = (x-x1)/(x2-x1);\n\t\t\tdouble yy = m*(y2-y1) + y1;\n\t\t\t\n\t\t\thi = max(hi, yy);\n\t\t\tlo = min(lo, yy);\n\t\t}\n\t}\n\n\treturn (hi-lo);\n}\n\nint main() {\n\n    //freopen(\"input.txt\",\"r\",stdin);\n    //freopen(\"output.txt\",\"w\",stdout);\n\n\twhile (scanf(\"%d%d\",&m,&n) && n!=0) {\n\t\txy.clear();\n\t\txz.clear();\n\t\txs.clear();\n\n\t\tint minim = 100000, maxim = -10000;\n\t\tint tm = 1000000, tma = -1000000;\n\t\tfor (int i=0; i<m; i++) {\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\txy.push_back(point(a,b));\n\t\t\txs.push_back(a);\n\t\t\ttm = min(tm,a);\n\t\t\ttma = max(tma, a);\n\t\t}\n\t\tminim = tm;\n\t\tmaxim = tma;\n\t\ttm = 1000000;\n\t\ttma = -100000;\n\t\tfor (int i=0; i<n; i++) {\n\t\t\tint a,b;\n\t\t\tscanf(\"%d%d\",&a,&b);\n\t\t\txz.push_back(point(a,b));\n\t\t\txs.push_back(a);\n\t\t\ttm = min(tm,a);\n\t\t\ttma = max(tma, a);\n\t\t}\n\t\tminim = max(minim,tm);\n\t\tmaxim = min(maxim, tma);\n\t\t\n\t\tsort(xs.begin(),xs.end());\n\t\txs.erase(unique(xs.begin(),xs.end()),xs.end());\n\t\t\n\t\tdouble vol = 0.0;\n\t\t\n\t\tfor (int i=0; i<xs.size()-1; i++) {\n\t\t\tif (xs[i]>=minim && xs[i]<=maxim && xs[i+1]>=minim && xs[i+1]<=maxim) {\n\t\t\t\tdouble l = xs[i];\n\t\t\t\tdouble r = xs[i+1];\n\t\t\t\tdouble mid = (l+r)/2;\n\t\t\t\t\n\t\t\t\tdouble a1 = area(l,xz)*area(l,xy);\n\t\t\t\tdouble a2 = area(r,xz)*area(r,xy);\n\t\t\t\tdouble a3 = area(mid,xz)*area(mid,xy);\n\t\t\t\t\n\t\t\t\tvol += (r-l)*(a1 + a2 + a3*4.0) / 6.0;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%.12lf\\n\",vol);\n\t}\n\n    return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 1313 (http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1313)\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define rep(i,a) for(int i=0;i<(a);++i)\n#define all(a) (a).begin(), (a).end()\n\nconst int MAX_M = 100, MAX_N = 100;\n\nint m, n;\nint x1[MAX_M], yo[MAX_M];\nint x2[MAX_N], z2[MAX_N];\nstd::vector<int> xs;\n\ndouble slice( int *X, int *Y, int sz, double x )\n{\n\tdouble lb = 101, ub = -101;\n\n\trep( i, sz )\n\t{\n\t\tint xi = X[i], yi = Y[i], nx = X[(i+1)%sz], ny = Y[(i+1)%sz];\n\n\t\tif( (xi-x)*(nx-x) <= 0 && xi != nx )\n\t\t{\n\t\t\tdouble y = yi+(ny-yi)*(x-xi)/(nx-xi);\n\n\t\t\tlb = std::min( lb, y );\n\t\t\tub = std::max( ub, y );\n\t\t}\n\t}\n\n\treturn std::max( 0.0, ub-lb );\n}\n\nint main()\n{\n\twhile( scanf( \"%d%d\", &m, &n ), m|n )\n\t{\n\t\txs.clear();\n\n\t\tint mi1 = 101, ma1 = -101, mi2 = 101, ma2 = -101;\n\n\t\trep( i, m )\n\t\t{\n\t\t\tscanf( \"%d%d\", x1+i, yo+i );\n\t\t\txs.push_back(x1[i]);\n\t\t\tmi1 = std::min( mi1, x1[i] );\n\t\t\tma1 = std::max( ma1, x1[i] );\n\t\t}\n\t\trep( i, n )\n\t\t{\n\t\t\tscanf( \"%d%d\", x2+i, z2+i );\n\t\t\txs.push_back(x2[i]);\n\t\t\tmi2 = std::min( mi2, x2[i] );\n\t\t\tma2 = std::max( ma2, x2[i] );\n\t\t}\n\n\t\tstd::sort( all(xs) );\n\n\t\tdouble ans = 0.0;\n\n\t\trep( i, xs.size()-1 )\n\t\t{\n\t\t\tdouble a = xs[i], b = xs[(i+1)], c = (a+b)/2;\n\n\t\t\tif( mi1 <= c && c <= ma1 && mi2 <= c && c <= ma2 )\n\t\t\t{\n\t\t\t\tdouble fa = slice(x1,yo,m,a)*slice(x2,z2,n,a),\n\t\t\t\t\t   fb = slice(x1,yo,m,b)*slice(x2,z2,n,b),\n\t\t\t\t\t   fc = slice(x1,yo,m,c)*slice(x2,z2,n,c);\n\n\t\t\t\tans += (b-a)/6*(fa+4*fc+fb);\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%.12f\\n\", ans );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double dbl;\n#define double long double\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define REP(i,n) for(int i = 0 ; i < n ; i++)\ndouble eps = 1e-11;\ndouble EPS = eps;\n\nbool eq(double a,double b){\n\treturn fabs(a-b) < eps;\n}\n\ndouble cross(P a,P b) { return imag(conj(a)*b); }\ndouble dot(P a,P b) { return real(conj(a)*b);}\n\nvector<P> ps1,ps2;\n//??´???\nstruct L : public vector<P> {\n\tL(P a,P b) {\n\t\tpush_back(a); push_back(b);\n\t}\n\t\n};\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\t// a ??? b ??§???????¨??????????????????? b ??? c(???)\n\tif (cross(b, c) < 0)   return -1;\t// a ??? b ??§????¨??????????????????? b ??? c(???)\n\tif (dot(b, c) < 0) return +2;    \t// a???b??§????????????a??????????¶???????b???c(c--a--b)\n\tif (norm(b) < norm(c)) return -2;\t// a???b??§????????????b???c(a--b--c)\n\treturn 0;\t\t\t\t\t\t\t// a???b??§????????????b???c(????????? b == c)\n}\n \n\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n \n \n// ???????§???¢???????????????????§???¢???????????´?????§????????????\n//???????????´?????????????????´?????????????????´?????????????????¨?????????????????¨?????????????????????????????¨????????????????????????\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\nG convex_cut(const G& poly, const L& l) {\n  G Q;\n  for (int i = 0; i < poly.size(); ++i) {\n    P A = curr(poly, i), B = next(poly, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspoint(L(A, B), l));\n  }\n  return Q;\n}\n\n// ????´?????§???¢?????¢??????\"2???\"????±??????? O(n)\ndouble area2(const G& poly) {\n\tdouble A = 0;\n\tREP(i,poly.size()) A += cross(curr(poly, i), next(poly, i));\n\treturn abs(A);\n}\n\n\nvector<double> ux;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\t\n\treturn P(x,y);\n}\npair<double,double> seg(const vector<P> &ps,double x){\n\tdouble mi = 1e9, ma = -1e9;\n\tauto reflesh = [&mi,&ma](double y){\n\t\tmi = min(mi,y);\n\t\tma = max(ma,y);\n\t};\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tP a = ps[i];\n\t\tP b = ps[(i+1)%ps.size()];\n\t\tif( a.real() > b.real() ) swap(a,b);\n\t\tif( eq(a.real(),x) ) reflesh(a.imag());\n\t\tif( eq(b.real(),x) ) reflesh(b.imag());\n\t\tif( a.real() + eps < x and x < b.real() - eps ){\n\t\t\treflesh(a.imag() + (x - a.real()) * (b.imag() - a.imag()) / (b.real()-a.real()));\n\t\t}\n\t}\n\tif( ma < mi ) return {0.0,0.0};\n\treturn {mi,ma};\n}\n\ndouble S(double l,double r){\n\tif( r <= l ) return 0;\n\tG g1 = convex_cut(ps1,L(P(l,0),P(l,-1)));\n\tG g2 = convex_cut(g1,L(P(r,0),P(r,+1)));\n\t\n\treturn area2(g2) / 2;\n\t\n}\n\ndouble Vf(double z){\n\tauto p = seg(ps2,z);\n\treturn S(p.first,p.second);\n}\n\ndouble Vs(double l,double r){\n\treturn (r-l)/6*(Vf(l)+4*Vf((l+r)/2)+Vf(r));\n}\n\ndouble V(double l,double r,int k=7){\n\tif( l >= r ) return 0;\n\tdouble m = (l+r)/2;\n\tdouble a = Vs(l,m);\n\tdouble b = Vs(m,r);\n\tdouble c = Vs(l,r);\n\tif( ( k <= 0) and eq(a+b,c) ){\n\t\treturn c;\n\t}else{\n\t\treturn V(l,m,k-1) + V(m,r,k-1);\n\t}\t\n}\n\nint main(){\n\tint m,n;\n\twhile(cin >> m >> n && m ){\n\t\t\n\t\tps1.clear();\n\t\tps2.clear();\n\t\tux.clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tps1.push_back(in());\n\t\t\tux.push_back(ps1.back().real());\n\t\t}\n\n\t\tvector<double> uz;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tps2.push_back(in());\n\t\t\tps2.back() = P(ps2.back().imag(),ps2.back().real());\n\t\t\tuz.push_back(ps2.back().real());\n\n\t\t}\n\t\t\n\t\tsort(uz.begin(),uz.end());\n\t\tsort(ux.begin(),ux.end());\n\t\tdouble vans = 0;\n\t\t//for( auto z : uz ) cout << z << \" \"; cout << endl;\n\t\t//for( auto x : ux ) cout << x << \" \"; cout << endl;\n\t\tfor(int i = 0 ; i+1 < uz.size() ; i++)\n\t\t\tif( uz[i] != uz[i+1] )\n\t\t\t\tvans += V(uz[i],uz[i+1]);\n\t\tprintf(\"%.8lf\\n\",(dbl)vans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": " \n#include <bits/stdc++.h>\nusing namespace std;\nusing pii=pair<int,int>;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define range(i,a,n) for(int i=a;i<n;i++)\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define INF 1e9\n#define EPS 1e-9\n#define MOD (1e9+7)\n\n\nint main(){\n\tint m,n;\n\twhile(cin>>m>>n,n){\n\t\tvector<pii> C1(m),C2(n);\n\t\tvector<vector<double>> yp(201),zp(201);\n\t\tvector<double> y(201,0.0),z(201,0.0);\n\t\trep(i,m){int a,b; cin>>a>>b; C1[i]={a+100,b+100};}\t//xy\n\t\trep(i,n){int a,b; cin>>a>>b; C2[i]={a+100,b+100};}\t//xz\n\t\tint limit[4]={200,0,200,0};\n\t\trep(i,m){\n\t\t\tlimit[0]=min(limit[0],C1[i].first);\n\t\t\tlimit[1]=max(limit[1],C1[i].first);\n\t\t\tint j=(i+1)%m;\n\t\t\tauto xr=make_pair(C1[i].first,C1[j].first);\n\t\t\tauto yr=make_pair(C1[i].second,C1[j].second);\n\t\t\tif(xr.second<xr.first){\n\t\t\t\tswap(xr.second,xr.first);\n\t\t\t\tswap(yr.second,yr.first);\n\t\t\t}\n\t\t\tint diff=xr.second-xr.first;\n\t\t\tif(diff==0){\n\t\t\t\ty[xr.first]=fabs(yr.second-yr.first);\n\t\t\t}\n\t\t\trep(x,diff){\n\t\t\t\tdouble l=yr.second-yr.first;\n\t\t\t\tl/=diff;\n\t\t\t\typ[x+xr.first].push_back(yr.first+l*x);\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\tlimit[2]=min(limit[2],C2[i].first);\n\t\t\tlimit[3]=max(limit[3],C2[i].first);\n\t\t\tint j=(i+1)%n;\n\t\t\tauto xr=make_pair(C2[i].first,C2[j].first);\n\t\t\tauto zr=make_pair(C2[i].second,C2[j].second);\n\t\t\tif(xr.second<xr.first){\n\t\t\t\tswap(xr.second,xr.first);\n\t\t\t\tswap(zr.second,zr.first);\n\t\t\t}\n\t\t\tint diff=xr.second-xr.first;\n\t\t\tif(diff==0){\n\t\t\t\tz[xr.first]=fabs(zr.second-zr.first);\n\t\t\t}\n\t\t\trep(x,diff){\n\t\t\t\tdouble l=zr.second-zr.first;\n\t\t\t\tl/=diff;\n\t\t\t\tzp[x+xr.first].push_back(zr.first+l*x);\n\t\t\t}\n\t\t}\n\t\trep(i,201){\n\t\t\tif(yp[i].size()>=3){\n\t\t\t\tsort(all(yp[i]));\n\t\t\t\typ[i].erase(unique(all(yp[i])), yp[i].end());\n\t\t\t}\n\t\t\tif(zp[i].size()>=3){\n\t\t\t\tsort(all(zp[i]));\n\t\t\t\tzp[i].erase(unique(all(zp[i])), zp[i].end());\n\t\t\t}\n\t\t\tif(yp[i].size()!=0) y[i]=fabs(yp[i][0]-yp[i][1]);\n\t\t\tif(zp[i].size()!=0) z[i]=fabs(zp[i][0]-zp[i][1]);\n\t\t}\n\t\tdouble ans=0.0;\n\t\t//for(auto i:limit)cout<<i<<\",\";cout<<endl;\n\t\tlimit[1]--; limit[3]--;\n\t\tfor(int x=max(limit[0],limit[2]);x<=min(limit[1],limit[3]);x++){\n\t\t\tdouble f1=y[x]*z[x];\n\t\t\tdouble f2=(y[x+1]+y[x])/2 * (z[x+1]+z[x])/2;\n\t\t\tdouble f3=y[x+1]*z[x+1];\n\t\t\tans+=(f1+f2*4+f3)/6;\n\t\t}\n\t\tcout.precision(6);\n\t\tcout<<fixed<<ans<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> vecP;\n\nconst double eps=1e-8;\n\nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n\nP getCrossLL(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n \nint m,n;\nP s[100],t[100];\nvector<int> X;\n\ndouble getW(P s[100],int m,double x){\n  P a=P(x,0);\n  P b=P(x,1);\n  double maxm=-1e9;\n  double mini=1e9;\n  \n  for(int i=0;i<m;i++){\n    P c=s[i];\n    P d=s[(i+1)%m];\n    \n    if( eq( c.real() , d.real() ) ){\n      continue;\n    }\n    \n    if( min(c.real(),d.real()) < x+eps && x+eps < max(c.real(),d.real()) ){\n      P p=getCrossLL(a,b,c,d);\n      maxm=max(maxm, p.imag());\n      mini=min(mini, p.imag());\n    }\n  }\n\n  return max(0.0, maxm-mini);\n}\n\ndouble f(double x){\n  return getW(s,m,x)*getW(t,n,x);\n}\n\nint main(){\n  while(1){\n    cin>>m>>n;\n    if(m==0&&n==0)break;\n\n    X.clear();\n    for(int i=0;i<m;i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      s[i]=P(x,y);\n      X.push_back(x);\n    }\n    for(int i=0;i<n;i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      t[i]=P(x,y);\n      X.push_back(x);\n    }\n    sort(X.begin(),X.end());\n    X.erase( unique(X.begin(),X.end()) , X.end() );\n\n    double ans=0;\n    for(int i=0;i+1<(int)X.size();i++){\n      \n      \n      double a=X[i], b=X[i+1], mid=(a+b)*0.5;\n\n\n      double Sa=f(a);\n      double Sb=f(b);\n      double Smid=f(mid);\n      double dis= (b-a)*(Sa + 4*Smid + Sb)/6.0;\n      //            cout<<a<<' '<<b<<' '<<Sa<<' '<<Sb<<endl;\n      ans+= dis;\n      \n    }\n    printf(\"%.10f\\n\",ans);\n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nconst int N = 505;\nconst double EPS = 1e-12, INF = 1e12;\nint dcmp(double x) { return (x > EPS) - (x < -EPS); }\nstruct Point {\n\tint x, y;\n\tPoint() { }\n\tPoint(int _x, int _y) :x(_x), y(_y) { }\n};\ntypedef Point Vector;\nvoid read(Point &p) { scanf(\"%d%d\", &p.x, &p.y); }\n\nint m, n;\nPoint pa[N], pb[N];\n\ndouble width(Point *poly, int n, double x) {\n\tint i;\n\tdouble lb = INF, ub = -INF;\n\tfor (i = 0;i < n;++i) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\t//if a.x == b.x we'd better consider it to be alone\n\t\tdouble x1 = a.x, x2 = b.x, y1 = a.y, y2 = b.y;\n\t\tif ((x1 - x) * (x2 - x) <= 0 && x1 != x2) {\n\t\t\tdouble y = a.y + (y2 - y1) * (x - x1) / (x2 - x1);\n\t\t\tlb = min(lb, y); ub = max(ub, y);\n\t\t}\n\t}\n\treturn max(0.0, ub - lb);\n}\n\nvoid solve() {\n\tint i;\n\tint mna = pa[0].x, mxa = pa[0].x, mnb = pb[0].x, mxb = pb[0].x;\n\tfor (i = 1;i < m;++i) mna = min(mna, pa[i].x), mxa = max(mxa, pa[i].x);\n\tfor (i = 1;i < n;++i) mnb = min(mnb, pb[i].x), mxb = max(mxb, pb[i].x);\n\tvector<int> xs;\n\tfor (i = 0;i < m;++i) xs.push_back(pa[i].x);\n\tfor (i = 0;i < n;++i) xs.push_back(pb[i].x);\n\tsort(xs.begin(), xs.end());\n\t//xs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tdouble res = 0.0;\n\tfor (i = 0;i + 1 < xs.size();++i) {\n\t\tdouble a = xs[i], b = xs[i + 1], c = (a + b) / 2;\n\t\t//if (dcmp(mna - c) <= 0 && dcmp(c - mxa) <= 0 && dcmp(mnb - c) <= 0 && dcmp(c - mxb) <= 0) {\n\t\tif (mna <= c && c <= mxa && mnb <= c && c <= mxb) {\t\t\n\t\t\tdouble fa = width(pa, m, a) * width(pb, n, a);\n\t\t\tdouble fb = width(pa, m, b) * width(pb, n, b);\n\t\t\tdouble fc = width(pa, m, c) * width(pb, n, c);\n\t\t\tres += (b - a) / 6 * (fa + 4 * fc + fb);\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", res);\n}\n\nint main(int argc, char *argv[]) {\n\twhile (scanf(\"%d%d\", &m, &n) == 2 && n && m) {\n\t\tint i;\n\t\tfor (i = 0;i < m;++i) read(pa[i]);\n\t\tfor (i = 0;i < n;++i) read(pb[i]);\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<set>\n#include<map>\n#include<cstring>\n#include<string>\n#include<cmath>\n#include<ctime>\n#include<algorithm>\n#define LL long long\n#define PII pair<int,int>\n#define pi acos(-1.0)\n#define lowbit(x) x&(-x)\nusing namespace std;\n\nconst int inf=2e9+10;\nint m,n;\nint X1[110],Y1[110],X2[110],Z2[110];\n\ndouble width(int* X,int* Y,int s,double x){\n    double lb=(double)inf,ub=(double)(-inf);\n    for(int i=0;i<s;i++){\n        double x1=X[i],y1=Y[i],x2=X[(i+1)%s],y2=Y[(i+1)%s];\n        if((x1-x)*(x2-x)<=0 && x1!=x2){\n            double y=y1+(y2-y1)*(x-x1)/(x2-x1);\n            lb=min(lb,y);\n            ub=max(ub,y);\n        }\n    }\n    return max(0.0,ub-lb);\n}\n\nvoid solve(){\n    int min1=inf,max1=-inf;\n    for(int i=0;i<m;i++){\n        min1=min(min1,X1[i]);\n        max1=max(max1,X1[i]);\n    }\n    int min2=inf,max2=-inf;\n    for(int i=0;i<n;i++){\n        min2=min(min2,X2[i]);\n        max2=max(max2,X2[i]);\n    }\n    vector<int> xs;\n    for(int i=0;i<m;i++) xs.push_back(X1[i]);\n    for(int i=0;i<n;i++) xs.push_back(X2[i]);\n    sort(xs.begin(),xs.end());\n    double res=0.0;\n    for(int i=0;i+1<m+n;i++){\n        double a=xs[i],b=xs[i+1],c=(a+b)/2;\n        if(min1<=c && c<=max1 && min2<=c && c<=max2){\n            double fa=width(X1,Y1,m,a)*width(X2,Z2,n,a);\n            double fb=width(X1,Y1,m,b)*width(X2,Z2,n,b);\n            double fc=width(X1,Y1,m,c)*width(X2,Z2,n,c);\n            res+=(b-a)/6*(fa+4*fc+fb);\n        }\n    }\n    printf(\"%.6f\\n\",res);\n}\n\nint main(void){\n    while(scanf(\"%d %d\",&m,&n)!=EOF && (m || n)){\n        for(int i=0;i<m;i++) scanf(\"%d %d\",&X1[i],&Y1[i]);\n        for(int i=0;i<n;i++) scanf(\"%d %d\",&X2[i],&Z2[i]);\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>  \n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\nconst int INF = 200;\n\nint M,N;\nint X1[100+10], X2[100+10], Y[100+10], Z[100+10], P[200+10];\ndouble ans;\n\ndouble width(int* X, int* YZ, int n, double x){  \n\tdouble lb=INF, ub=-INF;  \n\tfor (int i=0; i<n; i++){  \n\t\tdouble x1=X[i], y1=YZ[i], x2=X[(i+1) % n], y2=YZ[(i+1) % n];  \n\t\tif ((x1-x) * (x2-x) <= 0 && x1 != x2){   \n\t\t\tdouble y=y1 + (y2-y1) * (x-x1) / (x2-x1);  \n\t\t\tlb = min(lb, y);  \n\t\t\tub = max(ub, y);  \n\t\t}  \n\t} \n\treturn max(0.0, ub-lb);  \n}  \n\n\nvoid solve(){\n\tans = 0.0;\n\tint min1 = *min_element(X1,X1+M);\n\tint min2 = *min_element(X2,X2+N);\n\tint max1 = *max_element(X1,X1+M);\n\tint max2 = *max_element(X1,X2+N);\n\t\n\tsort(P,P+M+N);\n\t\t\n\tfor (int i=0; i<M+N-1; i++){\n\t\tdouble a = P[i];\n\t\tdouble b = P[i+1];\n\t\tdouble c = (a+b)/2;\n\t\tif (min1<=c && min2<=c && c<=max1 && c<=max2){\n\t\t\tdouble fa = width(X1, Y, M, a) * width(X2, Z, N, a);  \n\t\t\tdouble fb = width(X1, Y, M, b) * width(X2, Z, N, b);  \n\t\t\tdouble fc = width(X1, Y, M, c) * width(X2, Z, N, c);\n\t\t\tans += (b-a)/6*(fa+4*fc+fb);\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", ans);\n}\n\nint main() {\n\twhile ((cin >> M >> N) && M && N){\n\t\tfor (int i=0; i<M; i++){\n\t\t\tcin >> X1[i] >> Y[i];\n\t\t\tP[i] = X1[i];\n\t\t}\n\t\tfor (int i=0; i<N; i++){\n\t\t\tcin >> X2[i] >> Z[i];\n\t\t\tP[M+i] = X2[i];\n\t\t}\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,s,e) for((i)=(s);(i)<(int)(e);(i)++)\n\ntypedef long long ll;\nconst int INF = 100000000;\ndouble EPS = 1e-10;\n\nconst int M = 100;\nconst int N = 100;\nint m, n;\nint xm[M], ym[M];\nint xn[N], zn[N];\n\n//特定の平面で切った時の断面で幅が有界なものの値を計算\ndouble width(int *X, int *Y, int k, double x) {\n\tdouble lb = INF, ub = -INF;\n\tfor (int i=0; i<k; i++) {\n\t\tdouble x1 = X[i], y1 = Y[i], x2 = X[(i+1)%k], y2 = Y[(i+1)%k];\n\n\t\t//i-thの辺と交点を持つか調べる\n\t\tif ((x1-x)*(x2-x) <= 0 && x1 != x2) {\n\t\t\tdouble y = y1 + (y2-y1)*(x-x1)/(x2-x1);\n\t\t\tlb = min(lb, y);\n\t\t\tub = max(ub, y);\n\t\t}\n\t}\n\treturn max(0.0, ub-lb);\n}\n\nvoid solve() {\n\t//区間の端点を列挙\n\tint min1 = *min_element(xm, xm+m), max1 = *max_element(xm, xm+m); \n\tint min2 = *min_element(xn, xn+n), max2 = *max_element(xn, xn+n); \n\tvector<int> xs;\n\tfor (int i=0; i<m; i++) xs.push_back(xm[i]);\n\tfor (int i=0; i<n; i++) xs.push_back(xn[i]);\n\tsort(xs.begin(), xs.end());\n\n\tdouble res = 0.0;\n\tfor (int i=0; i+1<xs.size(); i++) {\n\t\tdouble a = xs[i], b = xs[i+1], c = (a+b)*0.5;\n\t\tif (min1<=c && c<=max1 && min2<=c && c<=max2) {\n\t\t\t//二つの立体が交差しない場合,cが少なくとも一方の立体に含まれない\n\t\t\t//ので計算対象から除外(上のif文はこのため)\n\t\t\t//Simpson\n\t\t\tdouble fa = width(xm, ym, m, a) * width(xn, zn, n, a);\n\t\t\tdouble fb = width(xm, ym, m, b) * width(xn, zn, n, b);\n\t\t\tdouble fc = width(xm, ym, m, c) * width(xn, zn, n, c);\n\t\t\tres += (b-a)/6.0 * (fa + fc*4.0 + fb);\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", res);\n}\n\nint main() {\n\tint i, j;\n\n\twhile (1) {\n\t\tscanf(\"%d%d \", &m, &n);\n\t\tif (!m && !n) break;\n\t\tfor (i=0; i<m; i++) scanf(\"%d%d \", xm+i, ym+i);\n\t\tfor (i=0; i<n; i++) scanf(\"%d%d \", xn+i, zn+i);\n\t\tsolve();\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n \nconst int maxn = 105, inf = 0x3f3f3f3f;\nint M, N;\nint X1[maxn], Y1[maxn], X2[maxn], Z2[maxn];\n \n//计算按x值对多边形切片得到的宽度\ndouble width(int * X, int * Y, int n, double x)\n{\n    double lb = inf, ub = -inf;\n    for (int i=0; i<n; ++i)\n    {\n        double x1 = X[i], y1 = Y[i], x2 = X[(i + 1) % n], y2 = Y[(i + 1) % n];\n        //检查与第i条边是否相交\n        if ((x1 - x) * (x2 - x) <= 0 && x1 != x2)\n        {\n            //计算交点坐标\n            double y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n            lb = min(lb, y);\n            ub = max(ub, y);\n        }\n    }\n    return max(0.0, ub - lb);\n}\n \nvoid solve()\n{\n    //枚举区间的端点\n    int min1 = *min_element(X1, X1 + M), max1 = *max_element(X1, X1 + M);\n    int min2 = *min_element(X2, X2 + N), max2 = *max_element(X2, X2 + N);\n    vector<int> xs;\n    for (int i=0; i<M; ++i) xs.push_back(X1[i]);\n    for (int i=0; i<N; ++i) xs.push_back(X2[i]);\n    sort(xs.begin(), xs.end());\n     \n    double res = 0;\n    for (int i=0; i+1<xs.size(); ++i)\n    {\n        double a = xs[i], b = xs[i+1], c = (a + b) / 2;\n        if (min1 <= c && c <= max1 && min2 <= c && c <= max2)\n        {\n            //利用Simpson公式求积分\n            double fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n            double fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n            double fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n            res += (b - a) / 6 * (fa + 4 * fc + fb);\n        }\n    }\n    printf(\"%.10f\\n\", res);\n    return;\n}\n \nint main()\n{\n    while (~scanf(\"%d %d\", &M, &N) && (M + N))\n    {\n        for (int i=0; i<M; ++i) scanf(\"%d %d\", &X1[i], &Y1[i]);\n        for (int i=0; i<N; ++i) scanf(\"%d %d\", &X2[i], &Z2[i]);\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\n\nconst D EPS = 1e-8;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return EQ(real(a),real(b))?imag(a)<imag(b):real(a)<real(b);\n  }\n  bool operator==(const P &a, const P &b){return EQ(a,b);}\n}\n\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ninline bool para(L a,L b){return abs(cross(a.fs-a.sc,b.fs-b.sc))<EPS;}\n\ninline bool is_cp(L a,L b){\n  if(para(a,b))return false;\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ninline P line_cp(L a,L b){\n  return a.fs+(a.sc-a.fs)*cross(b.sc-b.fs,b.fs-a.fs)/cross(b.sc-b.fs,a.sc-a.fs);\n}\n\nvector<P> p[2];\ninline D len(D x, int id){\n  L l = L( P(x,-1000), P(x,1000) );\n  vector<P> res;\n  rep(i,p[id].size()){\n    L a = L( p[id][i], p[id][(i+1)%p[id].size()] );\n    if(is_cp(a,l)){\n      P cp = line_cp(a,l);\n      if(!EQ(cp,p[id][i]))res.push_back(cp);\n    }\n  }\n  /*\n  sort(all(res));\n  res.erase(unique(all(res)),res.end());\n  */\n\n  if(res.size()<2)return 0;\n  assert(res.size()==2);\n  return abs(res[0]-res[1]);\n}\n\ninline D f(D x){\n  return len(x,0) * len(x,1);\n}\n\nint main(){\n  int m,n;\n  while(cin >> m >> n, m){\n    p[0].resize(m); p[1].resize(n);\n    rep(i,m){\n      int x,y;\n      cin >> x >> y;\n      p[0][i] = P(x,y);\n    }\n\n    rep(i,n){\n      int x,z;\n      cin >> x >> z;\n      p[1][i] = P(x,z);\n    }\n\n    D ans = 0;\n    for(D i=-100;i<100;i+=1){\n      ans += f(i)+4*f(i+0.5)+f(i+1);\n    }\n    cout << fixed << setprecision(9) << ans/6 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n\n#endif\n#include <iostream>\n#include <memory>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <assert.h>\n#include <complex>\n#include <queue>\n#define rep(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\nusing namespace std;\nusing ll = long long;\nll ll_max = numeric_limits<ll>::max();\nll ll_min = numeric_limits<ll>::min();\nint int_max = numeric_limits<int>::max();\nint int_min = numeric_limits<int>::min();\nint m, n;\nvector<pair<double, double> > Pxy, Pxz;\nvector<double> X;\n\ntypedef pair<double, double> P;\nbool pairCompare(const P& firstElof, const P& secondElof) {\n    if (firstElof.first == secondElof.first)\n        return firstElof.second < secondElof.second;\n    return firstElof.first < secondElof.first;\n}\n\ndouble width(vector<pair<double, double> > polygon, double x) {\n    pair<double, double> p, q;\n    vector<double> w;\n    rep(i, polygon.size()) {\n        p = polygon[i];\n        q = polygon[(i + 1) % polygon.size()];\n        if (x == p.first)\n            w.push_back(p.second);\n        else if ((p.first < x && x < q.first) || \n                (p.first > x && x > q.first)) {\n            w.push_back(p.second + 1.0 * (q.second - p.second) * (\n                x - p.first) / (q.first - p.first));\n        }\n    }\n    sort(w.begin(), w.end());\n    return w[w.size() - 1] - w[0];\n}\n\ndouble area(double x) {\n    return width(Pxy, x) * width(Pxz, x);\n}\n\ndouble volume() {\n    double total = 0.0;\n\n    double xmin = max(Pxy[0].first, Pxz[0].first);\n    double xmax = min(Pxy[Pxy.size(\n        ) - 1].first, Pxz[Pxz.size() - 1].first);\n\n    rep(i, X.size() - 1) {\n        double a = X[i];\n        double b = X[i + 1];\n        if (!(xmin <= a && a <= xmax && xmin <= b and b <= xmax))\n            continue;\n        double areaA = area(a); \n        double areaB = area(b); \n        double areaMid = area((a + b) / 2.0); \n        total += (b - a) * (\n            areaA + 4.0 * areaMid + areaB) / 3.0;\n    }\n\n    return total;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> m >> n) {\n        if (m == 0 && n == 0) {\n            return 0;\n        }\n        double x, y;\n        X.clear();\n        Pxy.clear();\n        Pxz.clear();\n        rep(mm, m) {\n            cin >> x >> y;\n            X.push_back(x);\n            Pxy.push_back(P(x, y));\n        }\n        rep(nn, n) {\n            cin >> x >> y;\n            X.push_back(x);\n            Pxz.push_back(P(x, y));\n        }\n\n        sort(X.begin(), X.end());\n        auto itr = std::unique(X.begin(), X.end());\n        X.erase(itr, X.end());\n        \n        sort(Pxy.begin(), Pxy.end(), pairCompare);\n        sort(Pxz.begin(), Pxz.end(), pairCompare);\n        cout << volume() << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\ndouble width(int *x, int *y, int size, double given_x){\n    double max_point = -1000.0, min_point = 1000.0;\n    for(int i = 0; i < size; i++){\n        double x1 = x[i], y1 = y[i], x2 = x[(i+1)%size], y2 = y[(i+1)%size];\n        if((x1-given_x)*(x2-given_x) <= 0 && x1 != x2){\n            double value = (y2-y1) * (given_x-x1) / (x2-x1) + y1; \n            max_point = max(value, max_point);\n            min_point = min(value, min_point);\n        }\n    }\n    return max_point - min_point;\n}\n\nint main(){\n    int m, n;\n    while(cin >> m >> n && m > 0){\n        int xy[100];\n        int y[100];\n        int xz[100];\n        int z[100];\n        int max_xy = -105;\n        int min_xy = 105;\n        for(int i = 0; i < m; i++){\n            cin >> xy[i] >> y[i];\n            max_xy = max(max_xy, xy[i]);\n            min_xy = min(min_xy, xy[i]);\n        }\n        int max_xz = -105;\n        int min_xz = 105;\n        for(int i = 0; i < n; i++){\n            cin >> xz[i] >> z[i];\n            max_xz = max(max_xz, xz[i]);\n            min_xz = min(min_xz, xz[i]);\n        }\n        int xmin = max(min_xy, min_xz);\n        int xmax = min(max_xy, max_xz);\n        vector<int> v;\n        for(int i = 0; i < m; i++){\n            v.push_back(xy[i]);\n        } \n        for(int i = 0; i < n; i++){\n            v.push_back(xz[i]);\n        } \n        sort(v.begin(), v.end());\n        double ans = 0;\n        for(int i = 0; i < n+m-1; i++){\n            double a = v[i], b = v[i+1];\n            if(xmin <= a && a <= xmax && xmin <= b && b <= xmax){\n                double mid = (a + b) / 2.0;\n                double va = width(xy, y, m, a) * width(xz, z, n, a);\n                double vb = width(xy, y, m, b) * width(xz, z, n, b);\n                double vm = width(xy, y, m, mid) * width(xz, z, n, mid);\n                ans += (b-a)/6 * (va + 4*vm + vb);\n            }\n        }\n        cout << fixed << setprecision(4) << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#define INF 1000000000\nusing namespace std;\nint n, m;\nint X1[105], Y1[105], X2[105], Z2[105];\ndouble width(int* X, int* Y, int n, double xx) {\n    double lb = INF, ub = -INF;\n    for (int i = 0; i < n; ++i) {\n        double x1 = X[i], y1 = Y[i], x2 = X[(i + 1) % n], y2 = Y[(i + 1) % n];\n        if ((x1 - xx) * (x2 - xx) <= 0 && x1 != x2) {\n            double y = y1 + (y2 - y1) * (xx - x1) / (x2 - x1);\n            lb = min(lb, y);\n            ub = max(ub, y);\n        }\n    }\n    return max(0.0, ub - lb);\n}\nint main() {\n    while(scanf(\"%d %d\", &m, &n) && m && n) {\n        vector<int> xs;\n        int min1 = INF, max1 = -INF, min2 = INF, max2 = -INF;\n        for (int i = 0; i < m; ++i) {\n            scanf(\"%d %d\", X1 + i, Y1 + i);\n            min1 = min(min1, X1[i]);\n            max1 = max(max1, X1[i]);\n            xs.push_back(X1[i]);\n        }\n        for (int i = 0; i < n; ++i) {\n            scanf(\"%d %d\", X2 + i, Z2 + i);\n            min2 = min(min2, X2[i]);\n            max2 = max(max2, X2[i]);\n            xs.push_back(X2[i]);\n        }\n        sort(xs.begin(), xs.end());\n        double ans = 0;\n        for (int i = 0; i + 1 < xs.size(); ++i) {\n            double a = xs[i], b = xs[i + 1];\n            double c = (a + b) / 2;\n            if (min1 <= c && c <= max1 && min2 <= c && c <= max2) {\n                double fa = width(X1, Y1, m, a) * width(X2, Z2, n, a);\n                double fb = width(X1, Y1, m, b) * width(X2, Z2, n, b);\n                double fc = width(X1, Y1, m, c) * width(X2, Z2, n, c);\n                ans += (b - a) / 6 * (fa + 4 * fc + fb);\n            }\n        }\n        printf(\"%.10f\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = 0x7fffffff;\nconst int MAX_N = 110, MAX_M = 110;\nint M, N;\nint X1[MAX_M], Y1[MAX_M];\nint X2[MAX_N], Z2[MAX_N];\n\ndouble width(int* X, int* Y, int n, double x) {\n\tdouble lb = INF, ub = -INF;\n\tfor (int i = 0; i < n; ++i) {\n\t\tdouble x1 = X[i], y1 = Y[i], x2 = X[(i+1)%n], y2 = Y[(i+1)%n];\n\t\tif ((x1-x)*(x2-x)<=0 && x1!=x2) {\n\t\t\tdouble y = y1 + (y2-y1)*(x-x1)/(x2-x1);\n\t\t\tlb = min(lb, y);\n\t\t\tub = max(ub, y);\n\t\t}\n\t}\n\treturn max(0.0, ub-lb);\n}\n\nint main() {\n\twhile (~scanf(\"%d%d\", &M, &N) && (M|N)) {\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tscanf(\"%d%d\", &X1[i], &Y1[i]);\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tscanf(\"%d%d\", &X2[i], &Z2[i]);\n\t\t}\n\n\t\t// 枚举区间端点\n\t\tint min1 = *min_element(X1, X1+M), max1 = *max_element(X1, X1+M);\n\t\tint min2 = *min_element(X2, X2+M), max2 = *max_element(X2, X2+M);\n\t\tvector<int> xs;\n\t\tfor (int i = 0; i < M; ++i) xs.push_back(X1[i]);\n\t\tfor (int i = 0; i < N; ++i) xs.push_back(X2[i]);\n\t\tsort(xs.begin(), xs.end());\n\n\t\tdouble res = 0;\n\t\tfor (int i = 0; i+1<xs.size(); ++i) {\n\t\t\tdouble a = xs[i], b = xs[i+1], c = (a+b)/2;\n\t\t\tif (min1 <= c && c <= max1 && min2 <=c && c<=max2) {\n\t\t\t\tdouble fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n\t\t\t\tdouble fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n\t\t\t\tdouble fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n\t\t\t\tres += (b-a)/6 * (fa+4*fc+fb);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10f\\n\", res);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst double INF=1e12;\nint M,N;\nint X1[100],X2[100],Y1[100],Y2[100];\n\ndouble f(int *X,int *Y,int n,double x){\n    double l=INF,r=-INF;\n    rep(i,n){\n        double x1=X[i],y1=Y[i],x2=X[(i+1)%n],y2=Y[(i+1)%n];\n        if((x1-x)*(x2-x)>0||x1==x2)continue;\n        double y=y1+(y2-y1)/(x2-x1)*(x-x1);\n        chmin(l,y);\n        chmax(r,y);\n    }\n    return r-l;\n}\n\nvoid solve(){\n    vint xs;\n    rep(i,M)xs.pb(X1[i]);\n    rep(i,N)xs.pb(X2[i]);\n    sort(all(xs));\n    int min1=*min_element(X1,X1+M),max1=*max_element(X1,X1+M);\n    int min2=*min_element(X2,X2+N),max2=*max_element(X2,X2+N);\n    double ans=0;\n    for(int i=0;i+1<xs.size();i++){\n        double a=xs[i],b=xs[i+1],c=(a+b)/2.0;\n        if(c<min1||c>max1||c<min2||c>max2)continue;\n        double fa=f(X1,Y1,M,a)*f(X2,Y2,N,a);\n        double fb=f(X1,Y1,M,b)*f(X2,Y2,N,b);\n        double fc=f(X1,Y1,M,c)*f(X2,Y2,N,c);\n        ans+=(b-a)/6*(fa+fb+fc*4);\n    }\n    printf(\"%.20f\\n\",ans);\n}\n\nsigned main(){\n    while(cin>>M>>N,M||N){\n        rep(i,M)cin>>X1[i]>>Y1[i];\n        rep(i,N)cin>>X2[i]>>Y2[i];\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst double EPS = 1e-11;\n\ndouble width(vector<pair<int,int> > polygon, double x) {\n  vector<double> w;\n  for (int i = 0; i < polygon.size() ; i++) {\n    pair<int,int> p = polygon[i], q = polygon[(i+1)%polygon.size()];\n    if (abs(p.first - x) < EPS)\n      w.push_back(1.0*p.second);\n    else if ((p.first < x && x < q.first) || (p.first > x && x > q.first)) {\n      int x0 = p.first, y0 = p.second;\n      int x1 = q.first, y1 = q.second;\n      w.push_back(y0 + 1.0*(y1-y0)*(x-x0)/(x1-x0));\n    }\n  }\n  sort(w.begin(), w.end());\n  return w[w.size()-1] - w[0];\n}\n\ndouble volume(vector<pair<int,int> > pxy, vector<pair<int,int> > pxz, vector<int> X) {\n  double total = 0.0;\n  int xmin = max((*min_element(pxy.begin(), pxy.end())).first,\n                 (*min_element(pxz.begin(), pxz.end())).first);\n  int xmax = min((*max_element(pxy.begin(), pxy.end())).first,\n                 (*max_element(pxz.begin(), pxz.end())).first);\n  sort(X.begin(), X.end());\n  for (int i = 0; i < X.size()-1; i++) {\n    int a = X[i], b = X[i+1];\n    if (!(xmin <= a && a <= xmax && xmin <= b && b <= xmax))\n      continue;\n    double m = (a+b)/2.0;\n    double va = width(pxy, a)*width(pxz, a);\n    double vb = width(pxy, b)*width(pxz, b);\n    double vm = width(pxy, m)*width(pxz, m);\n    double area = ((b-a)/6.0)*(va + 4.0*vm + vb);\n    total += area;\n  }\n  return total;\n}\n\nint main() {\n  int M, N;\n  while (cin >> M >> N && M > 0) {\n    vector<pair<int,int> > PXY, PXZ;\n    vector<int> X;\n    int x, y, z;\n    for (int i = 0; i < M; i++) {\n      cin >> x >> y;\n      PXY.push_back(make_pair(x,y));\n      X.push_back(x);\n    }\n    for (int i = 0; i < N; i++) {\n      cin >> x >> z;\n      PXZ.push_back(make_pair(x,z));\n      X.push_back(x);\n    }\n    cout << fixed << volume(PXY, PXZ, X) << endl;\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "\n//by allenlyh\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <assert.h>\n#include <complex>\n\nusing namespace std;\n\n#define X first\n#define Y second\n#define rl real()\n#define ig imge()\n#define PB push_back\n#define MP make_pair\n\n#define foreach(it,s) for (__typeof(s.begin()) it = s.begin();it!=s.end();it++)\n#define sign(x) (((x)<-eps)?-1:((x)>eps))\n\ntypedef long long LL;\ntypedef pair<double, double> point;\n\nconst int maxn = 200 + 10;\nconst double eps = 1e-12;\nstruct Tpo {\n\tint type;\n\tpoint c1;\n};\nTpo t[maxn];\nTpo tmp[maxn];\nint n, m;\nint nxt[4];\nint cur[4];\n\nbool cmp(Tpo q, Tpo p) {\n\treturn sign(q.c1.X - p.c1.X) < 0;\n}\n\nvoid init() {\n\tint minx, maxx;\n\tminx = maxx = 0;\n\tfor (int i=0;i<n;i++) {\n\t\tdouble x, y;\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t\ttmp[i].c1.X = x;\n\t\ttmp[i].c1.Y = y;\n\t\ttmp[i].type = 0;\n\t\tif (tmp[i].c1.X < tmp[minx].c1.X) minx = i;\n\t\tif (tmp[i].c1.X > tmp[maxx].c1.X) maxx = i;\n\t}\n\tfor (int i=minx;i!=maxx;i=(i+1)%n) {\n\t\ttmp[i].type = 0;\n\t}\n\tfor (int i=maxx;i!=minx;i=(i+1)%n) {\n\t\ttmp[i].type = 1;\n\t}\n\ttmp[minx].type = tmp[maxx].type = 4;\n\tint cnt = 0;\n\tfor (int i=minx;i!=maxx;i=(i+1)%n) t[cnt++] = tmp[i];\n\tfor (int i=(minx+n-1)%n;i!=maxx;i=(i+n-1)%n) t[cnt++] = tmp[i];\n\tt[cnt++] = tmp[maxx];\n\tminx = maxx = 0;\n\tfor (int i=0;i<m;i++) {\n\t\tdouble x, y;\n\t\tscanf(\"%lf%lf\", &x, &y);\n\t\ttmp[i].c1.X = x;\n\t\ttmp[i].c1.Y = y;\n\t\ttmp[i].type = 0;\n\t\tif (tmp[i].c1.X < tmp[minx].c1.X) minx = i;\n\t\tif (tmp[i].c1.X > tmp[maxx].c1.X) maxx = i;\n\t}\n\tfor (int i=minx;i!=maxx;i=(i+1)%m) {\n\t\ttmp[i].type = 2;\n\t}\n\tfor (int i=maxx;i!=minx;i=(i+1)%m) {\n\t\ttmp[i].type = 3;\n\t}\n\ttmp[minx].type = tmp[maxx].type = 5;\n\tfor (int i=minx;i!=maxx;i=(i+1)%m) t[cnt++] = tmp[i];\n\tfor (int i=(minx+m-1)%m;i!=maxx;i=(i+m-1)%m) t[cnt++] = tmp[i];\n\tt[cnt++] = tmp[maxx];\n\tstable_sort(t, t + n + m, cmp);\n\tn += m;\n}\n\nbool updata_nxt(int i) {\n\tnxt[i] = cur[i] + 1;\n\twhile (nxt[i] < n) {\n\t\tif (t[nxt[i]].type == i || t[nxt[i]].type == i / 2 + 4) break;\n\t\tnxt[i]++;\n\t}\n\tif (nxt[i] == n) return 1;\n\treturn 0;\n}\n\nvoid print(int x) {\n\tcout<<t[x].c1.X<<' '<<t[x].c1.Y;\n}\n\npoint calc(double x) {\n\tpoint ret;\n\tdouble y[4];\n\tfor (int i=0;i<4;i++) {\n\t\tif (t[nxt[i]].c1.X != t[cur[i]].c1.X)\n\t\t\ty[i] = (t[nxt[i]].c1.Y - t[cur[i]].c1.Y) * (x - t[cur[i]].c1.X) / (t[nxt[i]].c1.X - t[cur[i]].c1.X) + t[cur[i]].c1.Y;\n\t\telse {\n\t\t\tif (i & 1) y[i] = max(t[nxt[i]].c1.Y, t[cur[i]].c1.Y);\n\t\t\telse y[i] = min(t[nxt[i]].c1.Y, t[cur[i]].c1.Y);\n\t\t}\n\t}\n\tret.X = (y[1] - y[0]);\n\tret.Y = (y[3] - y[2]);\n\treturn ret;\n}\n\ndouble calc(double a, double b, double c, double d, double h) {\n\tdouble ret = 0;\n\tret += (b + d) * h * a * 0.5;\n\tret += (c - a) * h * b * 0.5;\n\tret += (c - a) * (d - b) * h / 3;\n\treturn ret;\n}\n\nvoid work() {\n\tmemset(cur, -1, sizeof(cur));\n\tint tot = 0;\n\tint npos;\n\tfor (int i=0;i<n;i++) {\n\t\tif (t[i].type == 4) {cur[0] = cur[1] = i; tot += 2; npos = i;}\n\t\telse if (t[i].type == 5) {cur[2] = cur[3] = i; tot += 2; npos = i;}\n\t\telse cur[t[i].type] = i;\n\t\tif (tot == 4) break;\n\t}\n\tif (cur[0] == -1 || cur[2] == -1) {\n\t\tputs(\"0.0\");\n\t\treturn;\n\t}\n\tfor (int i=0;i<4;i++) {\n\t\tupdata_nxt(i);\n\t}\n\tpoint c1, c2;\n\tc1.X = c1.Y = 0;\n\tdouble h1, h2;\n\th1 = 0;\n\tdouble ans = 0;\n\tbool end_flag = 0;\n\tbool first = 1;\n\tfor (;npos<n;npos++) {\n\t\tc2 = calc(t[npos].c1.X);\n\t\th2 = t[npos].c1.X;\n\t\tif (!first) ans += calc(c1.X, c1.Y, c2.X, c2.Y, h2 - h1); else first = 0;\n\t\tc1 = c2;\n\t\th1 = h2;\n\t\tif (t[npos].type == 4) {\n\t\t\tcur[0] = cur[1] = npos;\n\t\t\tend_flag |= updata_nxt(0);\n\t\t\tend_flag |= updata_nxt(1);\n\t\t} else if (t[npos].type == 5) {\n\t\t\tcur[2] = cur[3] = npos;\n\t\t\tend_flag |= updata_nxt(2);\n\t\t\tend_flag |= updata_nxt(3);\n\t\t} else {\n\t\t\tcur[t[npos].type] = npos;\n\t\t\tend_flag |= updata_nxt(t[npos].type);\n\t\t}\n\t\tif (end_flag) break;\n\t}\n\tprintf(\"%.15lf\\n\", ans);\n}\n\nint main() {\n\twhile (scanf(\"%d%d\", &n, &m) != EOF && (n || m)) {\n\t\tinit();\n\t\twork();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\n\nconst D EPS = 1e-8;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return EQ(real(a),real(b))?imag(a)<imag(b):real(a)<real(b);\n  }\n  bool operator==(const P &a, const P &b){return EQ(a,b);}\n}\n\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ninline bool para(L a,L b){return abs(cross(a.fs-a.sc,b.fs-b.sc))<EPS;}\n\ninline bool is_cp(L a,L b){\n  if(para(a,b))return false;\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ninline P line_cp(L a,L b){\n  return a.fs+(a.sc-a.fs)*cross(b.sc-b.fs,b.fs-a.fs)/cross(b.sc-b.fs,a.sc-a.fs);\n}\n\nvector<P> p[2];\ninline D len(D x, int id){\n  L l = L( P(x,-1000), P(x,1000) );\n  vector<P> res;\n  rep(i,p[id].size()){\n    L a = L( p[id][i], p[id][(i+1)%p[id].size()] );\n    if(is_cp(a,l)){\n      P cp = line_cp(a,l);\n      if(!EQ(cp,p[id][i]))res.push_back(cp);\n    }\n  }\n\n  if(res.size()<2)return 0;\n  return abs(res[0]-res[1]);\n}\n\ninline D f(D x){\n  return len(x,0) * len(x,1);\n}\n\nint main(){\n  int m,n;\n  while(cin >> m >> n, m){\n    p[0].resize(m); p[1].resize(n);\n    rep(i,m){\n      int x,y;\n      cin >> x >> y;\n      p[0][i] = P(x,y);\n    }\n\n    rep(i,n){\n      int x,z;\n      cin >> x >> z;\n      p[1][i] = P(x,z);\n    }\n\n    D ans = 0;\n    for(D i=-100;i<100;i+=1){\n      ans += f(i)+4*f(i+0.5)+f(i+1);\n    }\n    cout << fixed << setprecision(9) << ans/6 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ndouble eps = 1e-10;\nvector<P> ps1,ps2;\nbool eq(double a,double b){\n\treturn fabs(a-b) < eps;\n}\n\nvector<double> ux;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\npair<double,double> seg(const vector<P> &ps,double x){\n\tdouble mi = 1e9, ma = -1e9;\n\tauto reflesh = [&mi,&ma](double y){\n\t\tmi = min(mi,y);\n\t\tma = max(ma,y);\n\t};\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tP a = ps[i];\n\t\tP b = ps[(i+1)%ps.size()];\n\t\tif( a.real() > b.real() ) swap(a,b);\n\t\tif( eq(a.real(),x) ) reflesh(a.imag());\n\t\tif( eq(b.real(),x) ) reflesh(b.imag());\n\t\tif( a.real() + eps < x and x < b.real() - eps ){\n\t\t\treflesh(a.imag() + (x - a.real()) * (b.imag() - a.imag()) / (b.real()-a.real()));\n\t\t}\n\t}\n\tif( ma < mi ) return {0.0,0.0};\n\treturn {mi,ma};\n}\n\ndouble Sf(double x){\n\tauto p = seg(ps1,x);\n\treturn p.second - p.first;\n}\n\ndouble Ss(double l,double r){\n\treturn (r-l)/6*(Sf(l)+4*Sf((l+r)/2)+Sf(r));\n}\n\ndouble S2(double l,double r,int k=4){\n\tif( r < l ) return 0;\n\tdouble m = (l+r)/2;\n\tdouble a = Ss(l,m);\n\tdouble b = Ss(m,r);\n\tdouble c = Ss(l,r);\n\tif( (c>eps or k <= 0) and eq(a+b,c) ){\n\t\t//cout << a+b << \" \" << c << endl;\n\t\treturn c;\n\t}else{\n\t\treturn S2(l,m,k-1) + S2(m,r,k-1);\n\t}\t\n}\ndouble S(double l,double r){\n\tdouble sans = 0;\n\tfor(int i = 0 ; i+1 < ux.size() ; i++){\n\t\tif( ux[i] != ux[i+1] ){\n\t\t\tsans += S2(max(l,ux[i]),min(r,ux[i+1]));\n\t\t}\n\t}\n\t//cout << sans << endl;\n\treturn sans;\n\t\n}\n\ndouble Vf(double z){\n\tauto p = seg(ps2,z);\n\treturn S(p.first,p.second);\n}\n\ndouble Vs(double l,double r){\n\treturn (r-l)/6*(Vf(l)+4*Vf((l+r)/2)+Vf(r));\n}\n\ndouble V(double l,double r,int k=4){\n\tdouble m = (l+r)/2;\n\tdouble a = Vs(l,m);\n\tdouble b = Vs(m,r);\n\tdouble c = Vs(l,r);\n\tif( (c>eps or k <= 0) and eq(a+b,c) ){\n\t\treturn c;\n\t}else{\n\t\treturn V(l,m,k-1) + V(m,r,k-1);\n\t}\t\n}\n\nint main(){\n\tint m,n;\n\twhile(cin >> m >> n && m ){\n\t\t\n\t\tps1.clear();\n\t\tps2.clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tps1.push_back(in());\n\t\t\tux.push_back(ps1.back().real());\n\t\t}\n\n\t\tvector<double> uz;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tps2.push_back(in());\n\t\t\tps2.back() = P(ps2.back().imag(),ps2.back().real());\n\t\t\tuz.push_back(ps2.back().real());\n\t\t}\n\t\tsort(uz.begin(),uz.end());\n\t\tsort(ux.begin(),ux.end());\n\t\tdouble vans = 0;\n\t\t//for( auto z : uz ) cout << z << \" \"; cout << endl;\n\t\t//for( auto x : ux ) cout << x << \" \"; cout << endl;\n\t\tfor(int i = 0 ; i+1 < uz.size() ; i++)\n\t\t\tif( uz[i] != uz[i+1] )\n\t\t\t\tvans += V(uz[i],uz[i+1]);\n\t\tprintf(\"%.10lf\\n\",vans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\n\nconst D EPS = 1e-8;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return EQ(real(a),real(b))?imag(a)<imag(b):real(a)<real(b);\n  }\n  bool operator==(const P &a, const P &b){return EQ(a,b);}\n}\n\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ninline bool para(L a,L b){return abs(cross(a.fs-a.sc,b.fs-b.sc))<EPS;}\n\ninline bool is_cp(L a,L b){\n  if(para(a,b))return false;\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ninline P line_cp(L a,L b){\n  return a.fs+(a.sc-a.fs)*cross(b.sc-b.fs,b.fs-a.fs)/cross(b.sc-b.fs,a.sc-a.fs);\n}\n\nvector<P> p[2];\ninline D len(D x, int id){\n  L l = L( P(x,-1000), P(x,1000) );\n  vector<P> res;\n  rep(i,p[id].size()){\n    L a = L( p[id][i], p[id][(i+1)%p[id].size()] );\n    if(is_cp(a,l)){\n      P cp = line_cp(a,l);\n      if(!EQ(cp,p[id][i]))res.push_back(cp);\n    }else if(para(a,l) && ccw(l.fs,l.sc,a.sc)==0){\n      res.push_back(a.sc);\n    }\n  }\n\n  if(res.size()<2)return 0;\n  return abs(res[0]-res[1]);\n}\n\ninline D f(D x){\n  return len(x/2,0) * len(x/2,1);\n}\n\nint main(){\n  int m,n;\n  while(cin >> m >> n, m){\n    int minx[2], maxx[2];\n    p[0].resize(m); p[1].resize(n);\n    minx[0] = minx[1] = 1000;\n    maxx[0] = maxx[1] = -1000;\n\n    rep(i,m){\n      int x,y;\n      cin >> x >> y;\n      p[0][i] = P(x,y);\n      minx[0]=min(minx[0],x);\n      maxx[0]=max(maxx[0],x);\n    }\n\n    rep(i,n){\n      int x,z;\n      cin >> x >> z;\n      p[1][i] = P(x,z);\n      minx[1]=min(minx[1],x);\n      maxx[1]=max(maxx[1],x);\n    }\n\n    D ans = 0;\n    for(D i=-199;i<200;i+=2){\n      if(2*minx[0]<=i && i<=2*maxx[0]){\n\tif(2*minx[1]<=i && i<=2*maxx[1]){\n\t  ans += f(i-1)+4*f(i)+f(i+1);\n\t}\n      }\n    }\n    cout << fixed << setprecision(9) << ans/6 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\nusing namespace std;\n \n#define MAX_N 101\n#define MAX_M 101\n#define INF (1<<29)\n \nint M, N;\nint X1[MAX_M], Y1[MAX_M];\nint X2[MAX_N], Z2[MAX_N];\n \ndouble width(int* X, int* Y, int n, double x){\n  double lb = INF, ub = -INF;\n  for(int i = 0 ; i < n ; i++){\n    double x1 = X[i], y1 = Y[i], x2 = X[(i+1)%n], y2 = Y[(i+1)%n];\n    if((x1 - x) * (x2 - x) <= 0 && x1 != x2){\n      double y = y1 + (y2-y1) * (x-x1) / (x2-x1);\n      lb = min(lb, y);\n      ub = max(ub, y);\n    }\n  }\n  return max(0.0, ub - lb);\n}\n \nvoid solve(){\n  int min1 = *min_element(X1, X1+M), max1 = *max_element(X1, X1+M);\n  int min2 = *min_element(X2, X2+N), max2 = *max_element(X2, X2+N);\n  vector<int> xs;\n  for(int i = 0 ; i < M ; i++) xs.push_back(X1[i]);\n  for(int i = 0 ; i < N ; i++) xs.push_back(X2[i]);\n  sort(xs.begin(), xs.end());\n   \n  double res = 0;\n   \n  for(int i = 0 ; i+1 < xs.size() ; i++){\n    double a = xs[i], b = xs[i+1], c = (a+b)/2;\n    if(min1 <= c && c <= max1 && min2 <= c && c <= max2){\n      double fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n      double fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n      double fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n      res += (b-a)/6*(fa+4*fc+fb);\n    }\n  }\n  printf(\"%.10f\\n\", res);\n}\n \nint main(void){\n \n  while(cin >> M >> N,N|M){\n    for(int i=0;i<M;i++){\n      cin >> X1[i] >> Y1[i];\n    }\n    for(int i=0;i<N;i++){\n      cin >> X2[i] >> Z2[i];\n    }\n    solve();\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double dbl;\n#define double long double\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define REP(i,n) for(int i = 0 ; i < n ; i++)\ndouble eps = 1e-11;\ndouble EPS = eps;\n\nbool eq(double a,double b){\n\treturn fabs(a-b) < eps;\n}\n\ndouble cross(P a,P b) { return imag(conj(a)*b); }\ndouble dot(P a,P b) { return real(conj(a)*b);}\n\nvector<P> ps1,ps2;\n//??´???\nstruct L : public vector<P> {\n\tL(P a,P b) {\n\t\tpush_back(a); push_back(b);\n\t}\n\t\n};\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\t// a ??? b ??§???????¨??????????????????? b ??? c(???)\n\tif (cross(b, c) < 0)   return -1;\t// a ??? b ??§????¨??????????????????? b ??? c(???)\n\tif (dot(b, c) < 0) return +2;    \t// a???b??§????????????a??????????¶???????b???c(c--a--b)\n\tif (norm(b) < norm(c)) return -2;\t// a???b??§????????????b???c(a--b--c)\n\treturn 0;\t\t\t\t\t\t\t// a???b??§????????????b???c(????????? b == c)\n}\n \n\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n \n \n// ???????§???¢???????????????????§???¢???????????´?????§????????????\n//???????????´?????????????????´?????????????????´?????????????????¨?????????????????¨?????????????????????????????¨????????????????????????\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\nG convex_cut(const G& poly, const L& l) {\n  G Q;\n  for (int i = 0; i < poly.size(); ++i) {\n    P A = curr(poly, i), B = next(poly, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspoint(L(A, B), l));\n  }\n  return Q;\n}\n\n// ????´?????§???¢?????¢??????\"2???\"????±??????? O(n)\ndouble area2(const G& poly) {\n\tdouble A = 0;\n\tREP(i,poly.size()) A += cross(curr(poly, i), next(poly, i));\n\treturn abs(A);\n}\n\n\nvector<double> ux;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\t\n\treturn P(x,y);\n}\npair<double,double> seg(const vector<P> &ps,double x){\n\tdouble mi = 1e9, ma = -1e9;\n\tauto reflesh = [&mi,&ma](double y){\n\t\tmi = min(mi,y);\n\t\tma = max(ma,y);\n\t};\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tP a = ps[i];\n\t\tP b = ps[(i+1)%ps.size()];\n\t\tif( a.real() > b.real() ) swap(a,b);\n\t\tif( eq(a.real(),x) ) reflesh(a.imag());\n\t\tif( eq(b.real(),x) ) reflesh(b.imag());\n\t\tif( a.real() + eps < x and x < b.real() - eps ){\n\t\t\treflesh(a.imag() + (x - a.real()) * (b.imag() - a.imag()) / (b.real()-a.real()));\n\t\t}\n\t}\n\tif( ma < mi ) return {0.0,0.0};\n\treturn {mi,ma};\n}\n\ndouble S(double l,double r){\n\tif( r <= l ) return 0;\n\tG g1 = convex_cut(ps1,L(P(l,0),P(l,-1)));\n\tG g2 = convex_cut(g1,L(P(r,0),P(r,+1)));\n\t\n\treturn area2(g2) / 2;\n\t\n}\n\ndouble Vf(double z){\n\tauto p = seg(ps2,z);\n\treturn S(p.first,p.second);\n}\n\ndouble Vs(double l,double r){\n\treturn (r-l)/6*(Vf(l)+4*Vf((l+r)/2)+Vf(r));\n}\n\ndouble V(double l,double r,int k=0){\n\t//if( l < 5*eps ) return 0;\n\tdouble m = (l+r)/2;\n\tdouble a = Vs(l,m);\n\tdouble b = Vs(m,r);\n\tdouble c = Vs(l,r);\n\tif( ( k <= 0) and eq(a+b,c) ){\n\t\treturn c;\n\t}else{\n\t\treturn V(l,m,k-1) + V(m,r,k-1);\n\t}\t\n}\n\nint main(){\n\tint m,n;\n\twhile(cin >> m >> n && m ){\n\t\t\n\t\tps1.clear();\n\t\tps2.clear();\n\t\tux.clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tps1.push_back(in());\n\t\t\tux.push_back(ps1.back().real());\n\t\t\tux.push_back(ps1.back().real()-eps);\n\t\t\tux.push_back(ps1.back().real()+eps);\n\t\t\t\n\t\t\t\n\t\t}\n\n\t\tvector<double> uz;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tps2.push_back(in());\n\t\t\tps2.back() = P(ps2.back().imag(),ps2.back().real());\n\t\t\tuz.push_back(ps2.back().real());\n\t\t\tuz.push_back(ps2.back().real()-eps);\n\t\t\tuz.push_back(ps2.back().real()+eps);\n\n\t\t}\n\t\t\n\t\tsort(uz.begin(),uz.end());\n\t\tsort(ux.begin(),ux.end());\n\t\tdouble vans = 0;\n\t\t//for( auto z : uz ) cout << z << \" \"; cout << endl;\n\t\t//for( auto x : ux ) cout << x << \" \"; cout << endl;\n\t\tfor(int i = 0 ; i+1 < uz.size() ; i++)\n\t\t\tif( uz[i] != uz[i+1] )\n\t\t\t\tvans += V(uz[i],uz[i+1]);\n\t\tprintf(\"%.8lf\\n\",(dbl)vans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n\nint main()\n{\n  int M, N;\n  int X1[100], Y1[100], X2[100], Y2[100];\n\n  while(cin >> M >> N, M) {\n    vector< int > nums;\n    for(int i = 0; i < M; i++) cin >> X1[i] >> Y1[i];\n    for(int i = 0; i < N; i++) cin >> X2[i] >> Y2[i];\n    for(int i = 0; i < M; i++) nums.push_back(X1[i]);\n    for(int i = 0; i < N; i++) nums.push_back(X2[i]);\n    sort(begin(nums), end(nums));\n    nums.erase(unique(begin(nums), end(nums)), end(nums));\n    int a = max(*min_element(X1, X1 + M), *min_element(X2, X2 + N));\n    int b = min(*max_element(X1, X1 + M), *max_element(X2, X2 + N));\n    double ret = 0;\n\n    auto f = [](int *x, int *y, int sz, double v)\n    {\n      double small = 1e9, large = -1e9;\n      for(int i = 0; i < sz; i++) {\n        int xx = x[i], yy = y[i];\n        int nx = x[(i + 1) % sz], ny = y[(i + 1) % sz];\n        if(xx != nx && (xx - v) * (nx - v) <= 0) {\n          double vv = yy + (ny - yy) * (v - xx) / (nx - xx);\n          small = min(small, vv);\n          large = max(large, vv);\n        }\n      }\n      return (max(0.0, large - small));\n    };\n\n    for(int i = 1; i < nums.size(); i++) {\n      int left = nums[i - 1], right = nums[i];\n      double mid = (left + right) * 0.5;\n      if(a <= mid && mid <= b) {\n        double aa = f(X1, Y1, M, left) * f(X2, Y2, N, left);\n        double bb = f(X1, Y1, M, right) * f(X2, Y2, N, right);\n        double cc = f(X1, Y1, M, mid) * f(X2, Y2, N, mid);\n        ret += (right - left) / 6.0 * (aa + bb + 4.0 * cc);\n      }\n    }\n    cout << fixed << setprecision(10) << ret << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define INF 10000\n\nint N,M;\n\n\ndouble wide(int *px ,int *py, int n,double x) {\n\tdouble lb=INF,ub=-INF;\n\tfor(int i=0;i<n;i++){\n\t\tdouble x1=px[i],x2=px[(i+1)%n];\n\t\tdouble y1=py[i],y2=py[(i+1)%n];\n\t\tif((x1-x)*(x2-x)<=0 && x1!=x2){\n\t\t\tdouble y=y1+(y2-y1)*(x-x1)/(x2-x1);\n\t\t\tlb=min(lb,y);\n\t\t\tub=max(ub,y);\n\t\t}\n\t}\n\treturn max(0.0,ub-lb);\n}\n\nint main(void){\n\twhile(cin >> M >> N,M|N){\n\t\tint pointMx[100],pointMy[100];\n\t\tint pointNx[100],pointNy[100];\n\t\tfor(int i=0;i<M;i++)\n\t\t\tcin >> pointMx[i] >> pointMy[i];\n\t\tfor(int i=0;i<N;i++)\n\t\t\tcin >> pointNx[i] >> pointNy[i];\n\n\t\tint minM=*min_element(pointMx,pointMx+M),maxM=*max_element(pointMx,pointMx+M);\n\t\tint minN=*min_element(pointNx,pointNx+N),maxN=*max_element(pointNx,pointNx+N);\n\n\t\tvector<int> list;\n\t\tfor(int i=0;i<M;i++) list.push_back(pointMx[i]);\n\t\tfor(int i=0;i<N;i++) list.push_back(pointNx[i]);\n\t\tsort(list.begin(),list.end());\n\n\t\tdouble ans=0.0;\n\t\tfor(int i=0;i+1<list.size();i++){\n\t\t\tdouble a=list[i];\n\t\t\tdouble b=list[i+1];\n\t\t\tdouble c=(a+b)/2;\n\t\t\tif(minN <=c && c<= maxN && minM <=c && c<= maxM){\n\t\t\t\tdouble fa=wide(pointNx,pointNy,N,a)*wide(pointMx,pointMy,M,a);\n\t\t\t\tdouble fb=wide(pointNx,pointNy,N,b)*wide(pointMx,pointMy,M,b);\n\t\t\t\tdouble fc=wide(pointNx,pointNy,N,c)*wide(pointMx,pointMy,M,c);\n\t\t\t\tans+=(b-a)/6*(fa+ 4.0*fc +fb);\n\t\t\t}\n\t\t}\n\t\tcout.precision(10);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// ant book\nusing namespace std;\n\nconst int INF = 1<<29;\nconst int MAX_N = 100;\nconst int MAX_M = 100;\n\nint M, N;\nint X1[MAX_M], Y1[MAX_M];\nint X2[MAX_N], Z2[MAX_N];\n\ndouble width(int* X, int* Y, int n, double x) {\n  double lb = INF, ub = -INF;\n  for(itn i=0; i<n; i++) {\n    double x1 = X[i], y1 = Y[i], x2 = X[(i+1)%n], y2 = y[(i+1) % n];\n    \n    if((x1-x)*(x2-x) <= 0 && x1 != x2) {\n      double y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n      \n      lb = min(lb, y);\n      ub = max(ub, y);\n    }\n  }\n  \n  return max(0.0, ub - lb);\n}\n\nvoid solve() {\n  int min1 = *min_element(X1, X1 + M), max1 = *max_element(X1, X1 + M);\n  int min2 = *min_element(X2, X2 + N), max2 = *max_element(X2, X2 + N);\n  \n  vector<int> xs;\n  \n  for(int i=0; i<M; i++) xs.push_back(X1[i]);\n  for(int i=0; i<N; i++) xs.push_back(X2[i]);\n  \n  sort(xs.begin(), xs.end());\n  \n  double res = 0;\n  for(int i=0; i+1<xs.size(); i++) {\n    double a = xs[i], b = xs[i+1], c = (a+b) / 2;\n    if(min1 <= c && c <= max1 && min2 <= c && c <= max2) {\n      double fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n      double fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n      double fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n      res += (b - a) / 6 * (fa + 4 * fc + fb);\n    }\n  }\n  \n  printf(\"%.10f\\n\", res);\n}\n\nint main() {\n  \n  while(cin >> M >> N && (M|N)) {\n    for(int i=0; i<M; i++) cin >> X1[i] >> Y1[i];\n    for(int i=0; i<N; i++) cin >> X2[i] >> Z2[i];\n    \n    solve();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#define INF 1000000000\nusing namespace std;\nconst double g = 9.8;\nint n, m, x, y;\nint x1[105], y1[105], x2[105], z2[105];\ndouble width(int* x, int* y, int n, double xx) {\n    double lb = INF, ub = -INF;\n    for (int i = 0; i < n; ++i) {\n        double x1 = x[i], y1 = y[i], x2 = x[(i + 1) % n], y2 = y[(i + 1) % n];\n        if ((x1 - xx) * (x2 - xx) <= 0 && x1 != x2) {\n            double y = y1 + (y2 - y1) * (xx - x1) / (x2 - x1);\n            lb = min(lb, y);\n            ub = max(ub, y);\n        }\n    }\n    return max(0.0, ub - lb);\n}\nint main() {\n    while(scanf(\"%d %d\", &m, &n) && m && n) {\n        vector<int> xs;\n        int min1 = INF, max1 = -INF, min2 = INF, max2 = -INF;\n        for (int i = 0; i < m; ++i) {\n            scanf(\"%d %d\", x1 + i, y1 + i);\n            min1 = min(min1, x1[i]);\n            max1 = max(max1, x1[i]);\n            xs.push_back(x1[i]);\n        }\n        for (int i = 0; i < n; ++i) {\n            scanf(\"%d %d\", x2 + i, z2 + i);\n            min2 = min(min2, x2[i]);\n            max2 = max(max2, x2[i]);\n            xs.push_back(x2[i]);\n        }\n        sort(xs.begin(), xs.end());\n        double ans = 0;\n        for (int i = 0; i + 1 < xs.size(); ++i) {\n            double a = xs[i], b = xs[i + 1];\n            double c = (a + b) / 2;\n            if (min1 <= c && c <= max1 && min2 <= c && c <= max2) {\n                double fa = width(x1, y1, m, a) * width(x2, z2, n, a);\n                double fb = width(x1, y1, m, b) * width(x2, z2, n, b);\n                double fc = width(x1, y1, m, c) \n* width(x2, z2, n, c);\n                ans += (b - a) / 6 * (fa + 4 * fc + fb);\n            }\n        }\n        printf(\"%.10f\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#if 0\n\n#endif\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#define MAX_M 105\n#define MAX_N 105\n#define rep(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\nusing namespace std;\n\ndouble double_max = numeric_limits<double>::max();\ndouble double_min = numeric_limits<double>::min();\n\nint M, N;\nint X1[MAX_M], Y1[MAX_M];\nint X2[MAX_N], Z2[MAX_N];\n\ndouble width(int X[], int Y[], int n, double x) {\n    double lb = double_max, ub = -double_min;\n    rep(i, n) {\n        // cout << X[i] << Y[i] << endl;\n        double x1 = X[i], y1 = Y[i];\n        double x2 = X[(i + 1) % n], y2 = Y[(i + 1) % n];\n        if ((x1 - x) * (x2 - x) <= 0 && x1 != x2) {\n            double a = (y1 - y2) / (x1 - x2);\n            double b = (y1 * x2 - y2 * x1) / (x2 - x1);\n            double y = a * x + b;\n            lb = min(lb, y);\n            ub = max(ub, y);\n        }\n    }\n    // cout << max(0.0, ub - lb) << endl;\n    // cout << \"------------\" << endl;\n    return max(0.0, ub - lb);\n}\n\nvoid solve() {\n    int min1 = *min_element(X1, X1 + M), max1 = *max_element(X1, X1 + M);\n    int min2 = *min_element(X2, X2 + N), max2 = *max_element(X2, X2 + N);\n    vector<int> xs;\n    rep(i, M)\n        xs.push_back(X1[i]);\n    rep(i, N)\n        xs.push_back(X2[i]);\n    sort(xs.begin(), xs.end());\n\n    double total = 0;\n    for (int i = 0; i < xs.size() - 1; i++) {\n        double a = xs[i], b = xs[i + 1], c = (a + b) / 2;\n        if (min1 <= c && c <= max1 && min2 <= c && c <= max2) {\n            double fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n            double fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n            double fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n            total += (b - a) / 6 * (fa + 4 * fc + fb);\n        }\n    }\n\n    cout << total << endl;\n}\n\nint main() {\n    while (cin >> M >> N) {\n        if (M == 0 && N == 0)\n            break;\n\n        rep(i, M)\n            cin >> X1[i] >> Y1[i];\n        rep(i, N)\n            cin >> X2[i] >> Z2[i];\n\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint n,m;\nint x_1[123],y_1[123];\nint x_2[123],z_2[123];\n\ndouble f(int dx){\n  vector<double> y;\n  for(int i=0;i<m;i++){\n    if(x_1[i]*2==dx){\n      y.push_back(y_1[i]);\n    }else if((x_1[i]*2-dx)*(x_1[(i+1)%m]*2-dx)<0){\n      y.push_back(y_1[i]+(y_1[(i+1)%m]-y_1[i])*(dx/2.-x_1[i])/(x_1[(i+1)%m]-x_1[i]));\n    }\n  }\n  if(y.empty())return 0;\n  sort(begin(y),end(y));\n  vector<double> z;\n  for(int i=0;i<n;i++){\n    if(x_2[i]*2==dx){\n      z.push_back(z_2[i]);\n    }else if((x_2[i]*2-dx)*(x_2[(i+1)%n]*2-dx)<0){\n      z.push_back(z_2[i]+(z_2[(i+1)%n]-z_2[i])*(dx/2.-x_2[i])/(x_2[(i+1)%n]-x_2[i]));\n    }\n  }\n  if(z.empty())return 0;\n  sort(begin(z),end(z));\n  return (y.back()-y[0])*(z.back()-z[0]);\n}\n\nint main(){\n  while(cin>>m>>n,m|n){\n    vector<int> v;\n    for(int i=0;i<m;i++){\n      cin>>x_1[i]>>y_1[i];\n      v.push_back(x_1[i]);\n    }\n    for(int i=0;i<n;i++){\n      cin>>x_2[i]>>z_2[i];\n      v.push_back(x_2[i]);\n    }\n    sort(begin(v),end(v));\n    double ans=0;\n    for(int i=0;i<v.size()-1;i++){\n      if(v[i]<*min_element(x_1,x_1+m)||v[i]<*min_element(x_2,x_2+n))continue;\n      if(v[i+1]>*max_element(x_1,x_1+m)||v[i+1]>*max_element(x_2,x_2+n))continue;\n      ans+=(v[i+1]-v[i])/6.*(f(v[i]*2)+4*f(v[i]+v[i+1])+f(v[i+1]*2));\n    }\n    cout<<fixed<<ans<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n\n#endif\n#include <iostream>\n#include <memory>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <assert.h>\n#include <complex>\n#include <queue>\n#define rep(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\nusing namespace std;\nusing ll = long long;\nll ll_max = numeric_limits<ll>::max();\nll ll_min = numeric_limits<ll>::min();\nint int_max = numeric_limits<int>::max();\nint int_min = numeric_limits<int>::min();\nint m, n;\nvector<pair<double, double> > Pxy, Pxz;\nvector<double> X;\n\ntypedef pair<double, double> P;\nbool pairCompare(const P& firstElof, const P& secondElof) {\n    if (firstElof.first == secondElof.first)\n        return firstElof.second < secondElof.second;\n    return firstElof.first < secondElof.first;\n}\n\ndouble width(vector<pair<double, double> > polygon, double x) {\n    pair<double, double> p, q;\n    vector<double> w;\n    rep(i, polygon.size()) {\n        p = polygon[i];\n        q = polygon[(i + 1) % polygon.size()];\n        if (x == p.first)\n            w.push_back(p.second);\n        else if ((p.first < x && x < q.first) || \n                (p.first > x && x > q.first)) {\n            w.push_back(p.second + 1.0 * (q.second - p.second) * (\n                x - p.first) / (q.first - p.first));\n        }\n    }\n    sort(w.begin(), w.end());\n    return w[w.size() - 1] - w[0];\n}\n\ndouble area(double x) {\n    return width(Pxy, x) * width(Pxz, x);\n}\n\ndouble volume() {\n    double total = 0.0;\n\n    double xmin = max(Pxy[0].first, Pxz[0].first);\n    double xmax = min(Pxy[Pxy.size(\n        ) - 1].first, Pxz[Pxz.size() - 1].first);\n\n    rep(i, X.size() - 1) {\n        double a = X[i];\n        double b = X[i + 1];\n        double c = (a + b) / 2.0;\n        if (!(xmin <= a && a <= xmax && xmin <= b and b <= xmax))\n            continue;\n        double areaA = area(a); \n        double areaB = area(b); \n        double areaMid = area(c); \n        total += (b - a) / 6.0 * (\n            areaA + 4.0 * areaMid + areaB);\n    }\n\n    return total;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> m >> n) {\n        if (m == 0 && n == 0) {\n            return 0;\n        }\n        double x, y;\n        X.clear();\n        Pxy.clear();\n        Pxz.clear();\n        rep(mm, m) {\n            cin >> x >> y;\n            X.push_back(x);\n            Pxy.push_back(P(x, y));\n        }\n        rep(nn, n) {\n            cin >> x >> y;\n            X.push_back(x);\n            Pxz.push_back(P(x, y));\n        }\n\n        sort(X.begin(), X.end());\n        auto itr = std::unique(X.begin(), X.end());\n        X.erase(itr, X.end());\n        \n        sort(Pxy.begin(), Pxy.end(), pairCompare);\n        sort(Pxz.begin(), Pxz.end(), pairCompare);\n        cout << volume() << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> vecP;\n\nconst double eps=1e-8;\n\nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n\nP getCrossLL(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n \nint m,n;\nP s[100],t[100];\nvector<int> X;\n\ndouble getW(P s[100],int m,double x){\n  P a=P(x,0);\n  P b=P(x,1);\n  double maxm=-1e9;\n  double mini=1e9;\n  \n  for(int i=0;i<m;i++){\n    P c=s[i];\n    P d=s[(i+1)%m];\n    \n    if( eq( c.real() , d.real() ) ){\n      continue;\n    }\n    \n    if( min(c.real(),d.real()) < x+eps && x+eps < max(c.real(),d.real()) ){\n      P p=getCrossLL(a,b,c,d);\n      maxm=max(maxm, p.imag());\n      mini=min(mini, p.imag());\n    }\n  }\n\n  return max(0.0, maxm-mini);\n}\n\ndouble f(double x){\n  return getW(s,m,x)*getW(t,n,x);\n}\n\nint main(){\n  while(1){\n    cin>>m>>n;\n    if(m==0&&n==0)break;\n\n    X.clear();\n    for(int i=0;i<m;i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      s[i]=P(x,y);\n      X.push_back(x);\n    }\n    for(int i=0;i<n;i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      t[i]=P(x,y);\n      X.push_back(x);\n    }\n    sort(X.begin(),X.end());\n    X.erase( unique(X.begin(),X.end()) , X.end() );\n\n    double ans=0;\n    for(int i=0;i+1<(int)X.size();i++){\n      \n      \n      double a=X[i], b=X[i+1], mid=(a+b)*0.5;\n\n\n      double Sa=f(a);\n      double Sb=f(b);\n      double Smid=f(mid);\n      \n      if( eq(Smid,0) )continue;\n      \n      double dis= (b-a)*(Sa + 4*Smid + Sb)/6.0;\n      //            cout<<a<<' '<<b<<' '<<Sa<<' '<<Sb<<endl;\n      ans+= dis;\n      \n    }\n    printf(\"%.10f\\n\",ans);\n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define double long double\ntypedef complex<double> P;\ndouble eps = 1e-11;\nvector<P> ps1,ps2;\nbool eq(double a,double b){\n\treturn fabs(a-b) < eps;\n}\n\nvector<double> ux;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\npair<double,double> seg(const vector<P> &ps,double x){\n\tdouble mi = 1e9, ma = -1e9;\n\tauto reflesh = [&mi,&ma](double y){\n\t\tmi = min(mi,y);\n\t\tma = max(ma,y);\n\t};\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tP a = ps[i];\n\t\tP b = ps[(i+1)%ps.size()];\n\t\tif( a.real() > b.real() ) swap(a,b);\n\t\tif( eq(a.real(),x) ) reflesh(a.imag());\n\t\tif( eq(b.real(),x) ) reflesh(b.imag());\n\t\tif( a.real() + eps < x and x < b.real() - eps ){\n\t\t\treflesh(a.imag() + (x - a.real()) * (b.imag() - a.imag()) / (b.real()-a.real()));\n\t\t}\n\t}\n\tif( ma < mi ) return {0.0,0.0};\n\treturn {mi,ma};\n}\n\ndouble Sf(double x){\n\tauto p = seg(ps1,x);\n\treturn p.second - p.first;\n}\n\ndouble Ss(double l,double r){\n\treturn (r-l)/6*(Sf(l)+4*Sf((l+r)/2)+Sf(r));\n}\n\ndouble S2(double l,double r,int k=5){\n\tif( r < l ) return 0;\n\tdouble m = (l+r)/2;\n\tdouble a = Ss(l,m);\n\tdouble b = Ss(m,r);\n\tdouble c = Ss(l,r);\n\tif( (c>eps or k <= 0) and eq(a+b,c) ){\n\t\t//cout << a+b << \" \" << c << endl;\n\t\treturn c;\n\t}else{\n\t\treturn S2(l,m,k-1) + S2(m,r,k-1);\n\t}\t\n}\ndouble S(double l,double r){\n\tdouble sans = 0;\n\tfor(int i = 0 ; i+1 < ux.size() ; i++){\n\t\tif( ux[i] != ux[i+1] ){\n\t\t\tsans += S2(max(l,ux[i]),min(r,ux[i+1]));\n\t\t}\n\t}\n\t//cout << sans << endl;\n\treturn sans;\n\t\n}\n\ndouble Vf(double z){\n\tauto p = seg(ps2,z);\n\treturn S(p.first,p.second);\n}\n\ndouble Vs(double l,double r){\n\treturn (r-l)/6*(Vf(l)+4*Vf((l+r)/2)+Vf(r));\n}\n\ndouble V(double l,double r,int k=5){\n\tdouble m = (l+r)/2;\n\tdouble a = Vs(l,m);\n\tdouble b = Vs(m,r);\n\tdouble c = Vs(l,r);\n\tif( (c>eps or k <= 0) and eq(a+b,c) ){\n\t\treturn c;\n\t}else{\n\t\treturn V(l,m,k-1) + V(m,r,k-1);\n\t}\t\n}\n\nint main(){\n\tint m,n;\n\twhile(cin >> m >> n && m ){\n\t\t\n\t\tps1.clear();\n\t\tps2.clear();\n\t\tux.clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tps1.push_back(in());\n\t\t\tux.push_back(ps1.back().real());\n\t\t}\n\n\t\tvector<double> uz;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tps2.push_back(in());\n\t\t\tps2.back() = P(ps2.back().imag(),ps2.back().real());\n\t\t\tuz.push_back(ps2.back().real());\n\t\t}\n\t\tsort(uz.begin(),uz.end());\n\t\tsort(ux.begin(),ux.end());\n\t\tdouble vans = 0;\n\t\t//for( auto z : uz ) cout << z << \" \"; cout << endl;\n\t\t//for( auto x : ux ) cout << x << \" \"; cout << endl;\n\t\tfor(int i = 0 ; i+1 < uz.size() ; i++)\n\t\t\tif( uz[i] != uz[i+1] )\n\t\t\t\tvans += V(uz[i],uz[i+1]);\n\t\tprintf(\"%.15Lf\\n\",vans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 0\n\n#endif\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#define MAX_M 105\n#define MAX_N 105\n#define rep(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\nusing namespace std;\n\ndouble double_max = numeric_limits<double>::max();\ndouble double_min = numeric_limits<double>::min();\n\nint M, N;\nint X1[MAX_M], Y1[MAX_M];\nint X2[MAX_N], Z2[MAX_N];\n\ndouble width(int X[], int Y[], int n, double x) {\n    double lb = double_max, ub = -double_min;\n    rep(i, n) {\n        // cout << X[i] << Y[i] << endl;\n        double x1 = X[i], y1 = Y[i];\n        double x2 = X[(i + 1) % n], y2 = Y[(i + 1) % n];\n        if ((x1 - x) * (x2 - x) <= 0 && x1 != x2) {\n            double a = (y1 - y2) / (x1 - x2);\n            double b = (y1 * x2 - y2 * x1) / (x2 - x1);\n            double y = a * x + b;\n            lb = min(lb, y);\n            ub = max(ub, y);\n        }\n    }\n    // cout << max(0.0, ub - lb) << endl;\n    // cout << \"------------\" << endl;\n    return max(0.0, ub - lb);\n}\n\nvoid solve() {\n    int min1 = *min_element(X1, X1 + M), max1 = *max_element(X1, X1 + M);\n    int min2 = *min_element(X2, X2 + N), max2 = *max_element(X2, X2 + N);\n    vector<int> xs;\n    rep(i, M)\n        xs.push_back(X1[i]);\n    rep(i, N)\n        xs.push_back(X2[i]);\n    sort(xs.begin(), xs.end());\n\n    double total = 0;\n    for (int i = 0; i < xs.size() - 1; i++) {\n        double a = xs[i], b = xs[i + 1], c = (a + b) / 2;\n        if (min1 <= c && c <= max1 && min2 <= c && c <= max2) {\n            double fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n            double fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n            double fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n            total += (b - a) / 6 * (fa + 4 * fc + fb);\n        }\n    }\n\n    cout << fixed << setprecision(15) << total << endl;\n}\n\nint main() {\n    while (cin >> M >> N) {\n        if (M == 0 && N == 0)\n            break;\n\n        rep(i, M)\n            cin >> X1[i] >> Y1[i];\n        rep(i, N)\n            cin >> X2[i] >> Z2[i];\n\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\n#include <cassert>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Pol;\nD eps=1e-10,Eps=1e-9;\nD cro(P a,P b){return imag(conj(a)*b);}\nint ccw(P a,P b,P c){\n\tif(cro(b-a,c-a)>eps) return 1;\n\tif(cro(b-a,c-a)<-eps) return -1;\n\tif(abs(abs(a-c)+abs(c-b)-abs(a-b))<eps) return 0;\n\tif(abs(abs(a-b)+abs(c-b)-abs(a-c))<eps) return -2;\n\treturn 2;\n}\nbool iLS(L l,L s){\n\treturn cro(l.sc-l.fs,s.fs-l.fs)*cro(l.sc-l.fs,s.sc-l.fs)<eps;\n}\nP intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nint M,N;\nPol a,b;\nD rec(D x){\n\tL l=L(P(x,0),P(x,1));\n\tPol inters;\n\trep(j,M){\n\t\tL e=L(a[j],a[(j+1)%M]);\n\t\tif(iLS(l,e)) inters.pb(intLL(l,e));\n\t}\n\tif(inters.size()<=1) return -1;\n\tD leny=0;\n\tfor(P p:inters) for(P q:inters) leny=max(leny,abs(p-q));\n\tinters.clear();\n\trep(j,N){\n\t\tL e=L(b[j],b[(j+1)%N]);\n\t\tif(iLS(l,e)) inters.pb(intLL(l,e));\n\t}\n\tif(inters.size()<=1) return -1;\n\tD lenz=0;\n\tfor(P p:inters) for(P q:inters) lenz=max(lenz,abs(p-q));\n\treturn leny*lenz;\n}\nint main(){\n\twhile(true){\n\t\tcin>>M>>N;\n\t\tif(M==0) break;\n\t\ta.clear(),b.clear();\n\t\tvector<D> xs;\n\t\tD ans=0;\n\t\trep(i,M){\n\t\t\tD x,y;\n\t\t\tcin>>x>>y;\n\t\t\ta.pb(P(x,y));\n\t\t\txs.pb(x-Eps);\n\t\t\txs.pb(x+Eps);\n\t\t}\n\t\trep(i,N){\n\t\t\tD x,y;\n\t\t\tcin>>x>>y;\n\t\t\tb.pb(P(x,y));\n\t\t\txs.pb(x-Eps);\n\t\t\txs.pb(x+Eps);\n\t\t}\n\t\tsort(all(xs));\n\t\trep(i,xs.size()-1){\n\t\t\tif(rec(xs[i])<-eps||rec(xs[i])<-eps) continue;\n\t\t\tans+=(xs[i+1]-xs[i])/6.0*(rec(xs[i])+4.0*rec((xs[i+1]+xs[i])/2)+rec(xs[i+1]));\n\t\t}\n\t\tprintf(\"%.12f\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nconst int DIV = 500000;\n\nint m, n;\ndouble x1[100], y[100], x2[100], z[100];\ndouble mnx, mxx;\n\ndouble solve(double x) {\n  double y1 = 0, y2 = 0, z1 = 0, z2 = 0;\n  static int px11 = 0, px12 = 0, px21 = 0, px22 = 0;\n  rep (ii, m) {\n    int i = (px11 + ii) % m;\n    if (x1[i] != x1[(i + 1) % m] && x1[i] <= x && x <= x1[(i + 1) % m]) {\n      y1 = y[i] + (y[(i + 1) % m] - y[i]) / (x1[(i + 1) % m] - x1[i]) * (x - x1[i]);\n      px11 = i;\n      break;\n    }\n  }\n  rep (ii, m) {\n    int i = (px12 - ii + m) % m;\n    if (x1[i] != x1[(i + 1) % m] && x1[(i + 1) % m] <= x && x <= x1[i]) {\n      y2 = y[i] + (y[(i + 1) % m] - y[i]) / (x1[(i + 1) % m] - x1[i]) * (x - x1[i]);\n      px12 = i;\n      break;\n    }\n  }\n  rep (ii, n) {\n    int i = (px21 + ii) % n;\n    if (x2[i] != x2[(i + 1) % n] && x2[i] <= x && x <= x2[(i + 1) % n]) {\n      z1 = z[i] + (z[(i + 1) % n] - z[i]) / (x2[(i + 1) % n] - x2[i]) * (x - x2[i]);\n      px21 = i;\n      break;\n    }\n  }\n  rep (ii, n) {\n    int i = (px22 - ii + n) % n;\n    if (x2[i] != x2[(i + 1) % n] && x2[(i + 1) % n] <= x && x <= x2[i]) {\n      z2 = z[i] + (z[(i + 1) % n] - z[i]) / (x2[(i + 1) % n] - x2[i]) * (x - x2[i]);\n      px22 = i;\n      break;\n    }\n  }\n  return (y2 - y1) * (z2 - z1);\n}\n\ndouble simpson(double l, double r, double f(double), int k = 1){\n  double h = (r - l) / (2 * k);\n  double fo = 0, fe = 0;\n  for(int i = 1; i <= 2 * k - 3; i += 2){\n    fo += f(l + h * i);\n    fe += f(l + h * (i + 1));\n  }\n  return (f(l) + f(r) + 4 * (fo + f(r - h)) + 2 * fe) * h / 3;\n}\n\nint main() {\n  while (true) {\n    cin >> m >> n;\n    if (m == 0 && n == 0) break;\n    rep (i, m) cin >> x1[i] >> y[i];\n    rep (i, n) cin >> x2[i] >> z[i];\n    double mnx = max(*min_element(x1, x1 + m), *min_element(x2, x2 + n));\n    double mxx = min(*max_element(x1, x1 + m), *max_element(x2, x2 + n));\n    printf(\"%.12lf\\n\", simpson(mnx, mxx, solve, DIV));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint m,n;\nconst double EPS = 1e-11;\nvector<pair<int,int> > Pxy,Pyz;\npair<int,int> tem;\nvector<int> X;\n\n\ndouble width(vector<pair<int,int> > polygon,double x){\n    vector<double> w;\n    for(int i=0;i<polygon.size();i++){\n        pair<int,int> p=polygon[i];\n        pair<int,int> q=polygon[(i+1)%polygon.size()];\n        if((p.first-x)<EPS){\n            w.push_back(1.0*p.second);\n        }\n        else if(p.first<x && x<q.first|| p.first>0 && x>q.first){\n            int x0=p.first;\n            int y0=p.second;\n            int x1=q.first;\n            int y1=q.second;\n            w.push_back(y0+1.0*(y1-y0)*(x-x0)/(x1-x0));\n        }\n    }\n    assert(w.size()>0);\n    vector<double>::iterator maxs=max_element(w.begin(),w.end());\n    vector<double>::iterator mins=min_element(w.begin(),w.end());\n    return (maxs-mins);\n}\n\nint volume(vector<pair<int,int> >Pxy,vector<pair<int,int> >Pxz,vector<int> X){\n    double total=0.0;\n    int xmin = max((*min_element(Pxy.begin(), Pxy.end())).first,\n                   (*min_element(Pxz.begin(), Pxz.end())).first);\n    int xmax = min((*max_element(Pxy.begin(), Pxy.end())).first,\n                   (*max_element(Pxz.begin(), Pxz.end())).first);\n    sort(X.begin(), X.end());\n    for(int i=0;i<X.size()-1;i++){\n        int a=X[i];\n        int b=X[i+1];\n        if(!(xmin <= a && a <= xmax &&xmin <= b && b<< xmax) ){\n            continue;\n        }\n        double m=(a+b)/2.0;\n        double va = width(Pxy, a)*width(Pxz, a);\n        double vb = width(Pxy, b)*width(Pxz, b);\n        double vm = width(Pxy, m)*width(Pxz, m);\n        double area=((b-a)/6.0)*(va + 4.0*vm + vb);\n        total+=area;\n    }\n    return total;\n}\nint main(){\n    while(cin>>m>>n&&n!=0){\n        for(int i=1;i<=m;i++){\n            cin>>tem.first>>tem.second;\n            Pxy.push_back(tem);\n            X.push_back(x);\n        }\n        for(int j=1;j<=n;j++){\n            cin>>tem.first>>tem.second;\n            Pxz.push_back(tem);\n            X.push_back(x);\n        }\n        cout << fixed << volume(PXY, PXZ, X) << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ndouble width(int *x, int *y, int size, double given_x){\n    double max_point = -1000.0, min_point = 1000.0;\n    for(int i = 0; i < size; i++){\n        double x1 = x[i], y1 = y[i], x2 = x[(i+1)%size], y2 = y[(i+1)%size];\n        if((x1-given_x)*(x2-given_x) <= 0 && x1 != x2){\n            double value = (y2-y1) * (given_x-x1) / (x2-x1) + y1; \n            max_point = max(value, max_point);\n            min_point = min(value, min_point);\n        }\n    }\n    return max_point - min_point;\n}\n\nint main(){\n    int m, n;\n    while(cin >> m >> n && m > 0){\n        int xy[100];\n        int y[100];\n        int xz[100];\n        int z[100];\n        int max_xy = -105;\n        int min_xy = 105;\n        for(int i = 0; i < m; i++){\n            cin >> xy[i] >> y[i];\n            max_xy = max(max_xy, xy[i]);\n            min_xy = min(min_xy, xy[i]);\n        }\n        int max_xz = -105;\n        int min_xz = 105;\n        for(int i = 0; i < n; i++){\n            cin >> xz[i] >> z[i];\n            max_xz = max(max_xz, xz[i]);\n            min_xz = min(min_xz, xz[i]);\n        }\n        int xmin = max(min_xy, min_xz);\n        int xmax = min(max_xy, max_xz);\n        vector<int> v;\n        for(int i = 0; i < m; i++){\n            v.push_back(xy[i]);\n        } \n        for(int i = 0; i < n; i++){\n            v.push_back(xz[i]);\n        } \n        sort(v.begin(), v.end());\n        double ans = 0;\n        for(int i = 0; i < v.size(); i++){\n            double a = v[i], b = v[i+1];\n            if(xmin <= a && a <= xmax && xmin <= b && b <= xmax){\n                double mid = (a + b) / 2.0;\n                double va = width(xy, y, m, a) * width(xz, z, n, a);\n                double vb = width(xy, y, m, b) * width(xz, z, n, b);\n                double vm = width(xy, y, m, mid) * width(xz, z, n, mid);\n                ans += (b-a)/6 * (va + 4*vm + vb);\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nnamespace using sdt;\nint m,n;\nconst double EPS = 1e-11;\nvector<pair<int,int> > Pxy,Pyz;\npair<int,int> tem;\nvector<int> X;\n\nint findMax(vector<int> vec) {\n    int maxs = -999;\n    for (auto v : vec) {\n        if (maxs < v) maxs = v;\n    }\n    return maxs;\n}\n\nint findMin(vector<int> vec) {\n    int mins = 999;\n    for (auto v : vec) {\n        if (mins > v) mins = v;\n    }\n    return mins;\n}\n\ndouble width(vector<pair<int,int> > polygon,int x){\n    vector<double> w;\n    for(int i=0;i<polygon.len();i++){\n        pair<int,int> p=polygon[i];\n        pair<int,int> q=polygon[(i+1)%polygon.len()];\n        if((p.first-x)<EPS){\n            w.push_back(1.0*p.second);\n        }\n        else if(p.first<x && x<q.first|| p.first>0 && x>q.first){\n            int x0=p.first;\n            int y0=p.second;\n            int x1=q.first;\n            int y1=q.second;\n            w.push_back(y0+1.0*(y1-y0)*(x-x0)/(x1-x0));\n        }\n    }\n    assert(w.len()>0);\n    return (findMax(w)-findMin(w));\n}\n\nint volume(vector<pair<int,int> >Pxy,vector<pair<int,int> >Pxz,vector<int> X){\n    double total=0.0;\n    int xmin = max((*min_element(pxy.begin(), pxy.end())).first,\n                   (*min_element(pxz.begin(), pxz.end())).first);\n    int xmax = min((*max_element(pxy.begin(), pxy.end())).first,\n                   (*max_element(pxz.begin(), pxz.end())).first);\n    sort(X.begin(), X.end());\n    for(int i=0;i<X.len()-1;i++){\n        int a=X[i];\n        int b=X[i+1];\n        if(!(xmin <= a && a <= xmax &&xmin <= b && b<< xmax) ){\n            continue;\n        }\n        int m=(a+b)/2.0;\n        va = width(Pxy, a)*width(Pxz, a);\n        vb = width(Pxy, b)*width(Pxz, b);\n        m = width(Pxy, m)*width(Pxz, m);\n        double area=((b-a)/6.0)*(va + 4.0*vm + vb);\n        total+=area;\n    }\n    return total;\n}\nint main(){\n    while(cin>>m>>n&&n!=0){\n        for(int i=1;i<=m;i++){\n            cin>>tem.first>>tem.second;\n            Pxy.push_back(tem);\n            X.push_back(x);\n        }\n        for(int j=1;j<=n;j++){\n            cin>>tem.first>>tem.second;\n            Pxz.push_back(tem);\n            X.push_back(x);\n        }\n        cout << fixed << volume(PXY, PXZ, X) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ndouble eps = 1e-11;\nvector<P> ps1,ps2;\nbool eq(double a,double b){\n\treturn fabs(a-b) < eps;\n}\n\nvector<double> ux;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\npair<double,double> seg(const vector<P> &ps,double x){\n\tdouble mi = 1e9, ma = -1e9;\n\tauto reflesh = [&mi,&ma](double y){\n\t\tmi = min(mi,y);\n\t\tma = max(ma,y);\n\t};\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tP a = ps[i];\n\t\tP b = ps[(i+1)%ps.size()];\n\t\tif( a.real() > b.real() ) swap(a,b);\n\t\tif( eq(a.real(),x) ) reflesh(a.imag());\n\t\tif( eq(b.real(),x) ) reflesh(b.imag());\n\t\tif( a.real() + eps < x and x < b.real() - eps ){\n\t\t\treflesh(a.imag() + (x - a.real()) * (b.imag() - a.imag()) / (b.real()-a.real()));\n\t\t}\n\t}\n\tif( ma < mi ) return {0.0,0.0};\n\treturn {mi,ma};\n}\n\ndouble Sf(double x){\n\tauto p = seg(ps1,x);\n\treturn p.second - p.first;\n}\n\ndouble Ss(double l,double r){\n\treturn (r-l)/6*(Sf(l)+4*Sf((l+r)/2)+Sf(r));\n}\n\ndouble S2(double l,double r,int k=2){\n\tif( r < l ) return 0;\n\tdouble m = (l+r)/2;\n\tdouble a = Ss(l,m);\n\tdouble b = Ss(m,r);\n\tdouble c = Ss(l,r);\n\tif( (c>eps or k <= 0) and eq(a+b,c) ){\n\t\t//cout << a+b << \" \" << c << endl;\n\t\treturn c;\n\t}else{\n\t\treturn S2(l,m,k-1) + S2(m,r,k-1);\n\t}\t\n}\ndouble S(double l,double r){\n\tdouble sans = 0;\n\tfor(int i = 0 ; i+1 < ux.size() ; i++){\n\t\tif( ux[i] != ux[i+1] ){\n\t\t\tsans += S2(max(l,ux[i]),min(r,ux[i+1]));\n\t\t}\n\t}\n\t//cout << sans << endl;\n\treturn sans;\n\t\n}\n\ndouble Vf(double z){\n\tauto p = seg(ps2,z);\n\treturn S(p.first,p.second);\n}\n\ndouble Vs(double l,double r){\n\treturn (r-l)/6*(Vf(l)+4*Vf((l+r)/2)+Vf(r));\n}\n\ndouble V(double l,double r,int k=4){\n\tdouble m = (l+r)/2;\n\tdouble a = Vs(l,m);\n\tdouble b = Vs(m,r);\n\tdouble c = Vs(l,r);\n\tif( (c>eps or k <= 0) and eq(a+b,c) ){\n\t\treturn c;\n\t}else{\n\t\treturn V(l,m,k-1) + V(m,r,k-1);\n\t}\t\n}\n\nint main(){\n\tint m,n;\n\twhile(cin >> m >> n && m ){\n\t\t\n\t\tps1.clear();\n\t\tps2.clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tps1.push_back(in());\n\t\t\tux.push_back(ps1.back().real());\n\t\t}\n\n\t\tvector<double> uz;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tps2.push_back(in());\n\t\t\tps2.back() = P(ps2.back().imag(),ps2.back().real());\n\t\t\tuz.push_back(ps2.back().real());\n\t\t}\n\t\tsort(uz.begin(),uz.end());\n\t\tsort(ux.begin(),ux.end());\n\t\tdouble vans = 0;\n\t\t//for( auto z : uz ) cout << z << \" \"; cout << endl;\n\t\t//for( auto x : ux ) cout << x << \" \"; cout << endl;\n\t\tfor(int i = 0 ; i+1 < uz.size() ; i++)\n\t\t\tif( uz[i] != uz[i+1] )\n\t\t\t\tvans += V(uz[i],uz[i+1]);\n\t\tprintf(\"%.10lf\\n\",vans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double dbl;\n#define double long double\ntypedef complex<double> P;\n\ndouble eps = 1e-11;\nvector<P> ps1,ps2;\nbool eq(double a,double b){\n\treturn fabs(a-b) < eps;\n}\n\nvector<double> ux;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\npair<double,double> seg(const vector<P> &ps,double x){\n\tdouble mi = 1e9, ma = -1e9;\n\tauto reflesh = [&mi,&ma](double y){\n\t\tmi = min(mi,y);\n\t\tma = max(ma,y);\n\t};\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tP a = ps[i];\n\t\tP b = ps[(i+1)%ps.size()];\n\t\tif( a.real() > b.real() ) swap(a,b);\n\t\tif( eq(a.real(),x) ) reflesh(a.imag());\n\t\tif( eq(b.real(),x) ) reflesh(b.imag());\n\t\tif( a.real() + eps < x and x < b.real() - eps ){\n\t\t\treflesh(a.imag() + (x - a.real()) * (b.imag() - a.imag()) / (b.real()-a.real()));\n\t\t}\n\t}\n\tif( ma < mi ) return {0.0,0.0};\n\treturn {mi,ma};\n}\n\ndouble Sf(double x){\n\tauto p = seg(ps1,x);\n\treturn p.second - p.first;\n}\n\ndouble Ss(double l,double r){\n\treturn (r-l)/6*(Sf(l)+4*Sf((l+r)/2)+Sf(r));\n}\n\ndouble S2(double l,double r,int k=7){\n\tif( r < l ) return 0;\n\tdouble m = (l+r)/2;\n\tdouble a = Ss(l,m);\n\tdouble b = Ss(m,r);\n\tdouble c = Ss(l,r);\n\tif( (c>eps or k <= 0) and eq(a+b,c) ){\n\t\t//cout << a+b << \" \" << c << endl;\n\t\treturn c;\n\t}else{\n\t\treturn S2(l,m,k-1) + S2(m,r,k-1);\n\t}\t\n}\ndouble S(double l,double r){\n\tdouble sans = 0;\n\tfor(int i = 0 ; i+1 < ux.size() ; i++){\n\t\tif( ux[i] != ux[i+1] ){\n\t\t\tsans += S2(max(l,ux[i]),min(r,ux[i+1]));\n\t\t}\n\t}\n\t//cout << sans << endl;\n\treturn sans;\n\t\n}\n\ndouble Vf(double z){\n\tauto p = seg(ps2,z);\n\treturn S(p.first,p.second);\n}\n\ndouble Vs(double l,double r){\n\treturn (r-l)/6*(Vf(l)+4*Vf((l+r)/2)+Vf(r));\n}\n\ndouble V(double l,double r,int k=7){\n\tdouble m = (l+r)/2;\n\tdouble a = Vs(l,m);\n\tdouble b = Vs(m,r);\n\tdouble c = Vs(l,r);\n\tif( (c>eps or k <= 0) and eq(a+b,c) ){\n\t\treturn c;\n\t}else{\n\t\treturn V(l,m,k-1) + V(m,r,k-1);\n\t}\t\n}\n\nint main(){\n\tint m,n;\n\twhile(cin >> m >> n && m ){\n\t\t\n\t\tps1.clear();\n\t\tps2.clear();\n\t\tux.clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tps1.push_back(in());\n\t\t\tux.push_back(ps1.back().real());\n\t\t}\n\n\t\tvector<double> uz;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tps2.push_back(in());\n\t\t\tps2.back() = P(ps2.back().imag(),ps2.back().real());\n\t\t\tuz.push_back(ps2.back().real());\n\t\t}\n\t\tsort(uz.begin(),uz.end());\n\t\tsort(ux.begin(),ux.end());\n\t\tdouble vans = 0;\n\t\t//for( auto z : uz ) cout << z << \" \"; cout << endl;\n\t\t//for( auto x : ux ) cout << x << \" \"; cout << endl;\n\t\tfor(int i = 0 ; i+1 < uz.size() ; i++)\n\t\t\tif( uz[i] != uz[i+1] )\n\t\t\t\tvans += V(uz[i],uz[i+1]);\n\t\tprintf(\"%.6lf\\n\",(dbl)vans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ndouble width(const pair<int,int> P[], double x, int length){\n    vector<double> w(0);\n    for(int i = 0; i < length; i++){\n        pair<int,int> p,q;\n        p = P[i];\n        i != length-1 ? q = P[i+1] : q = P[0];\n        if(p.first == x){\n            w.push_back(p.second);\n        }else if((p.first < x && x < q.first) || (p.first > x && x > q.first)){\n            int x0,y0,x1,y1;\n            if(p.first < x){\n                x0 = p.first;\n                y0 = p.second;\n                x1 = q.first;\n                y1 = q.second;\n            }else{\n                x0 = q.first;\n                y0 = q.second;\n                x1 = p.first;\n                y1 = p.second;\n            }\n            w.push_back(y0 + 1.0*(y1-y0)*(x-x0)/(x1-x0));\n        }\n    }\n    sort(w.begin(),w.end());\n    return w.front() - w.back();\n}\n\n//P1??¨P2????????????????????????????????????x????????????sort?????????x???????????????????¬???¢??°?????????????????????\ndouble volume(const pair<int,int> P1[], const pair<int,int> P2[], pair<int,int> X[],int m, int n){\n    /*\n    for(int i = 0; i < m+n; i++){\n        if(i < m){\n            printf(\"P1[%d]:%d %d\\n\",i,P1[i].first,P1[i].second);\n        }else{\n            printf(\"P2[%d]:%d %d\\n\",i-m,P2[i-m].first,P2[i-m].second);\n        }\n    }\n     */\n    sort(X,X+m+n);\n    pair<int,int> p1mm(P1[0].first,P1[0].first),p2mm(P2[0].first,P2[0].first);\n    for(int i = 0; i < m; i++){\n        if(p1mm.first > P1[i].first){\n            p1mm.first = P1[i].first;\n        }\n        if(p1mm.second < P1[i].first){\n            p1mm.second = P1[i].first;\n        }\n    }\n    for(int i = 0; i < n; i++){\n        if(p2mm.first > P2[i].first){\n            p2mm.first = P2[i].first;\n        }\n        if(p2mm.second < P2[i].first){\n            p2mm.second = P2[i].first;\n        }\n    }\n    /*\n    printf(\"p1mm: %d %d\\np2mm: %d %d\\n\",p1mm.first,p1mm.second,p2mm.first,p2mm.second);\n    for(int i = 0; i < m+n; i++){\n        if(i < m){\n            printf(\"P1[%d]:%d %d\\n\",i,P1[i].first,P1[i].second);\n        }else{\n            printf(\"P2[%d]:%d %d\\n\",i-m,P2[i-m].first,P2[i-m].second);\n        }\n    }*/\n    int xmin = max(p1mm.first,p2mm.first), xmax = min(p1mm.second,p2mm.second);\n    //printf(\"minmax: %d %d\\n\",xmin,xmax);\n    double sum = 0;\n    for(int i = 0; i < m+n-1; i++){\n        pair<int,int> a = X[i], b = X[i+1];\n        if(xmin <= a.first && xmax >= a.first && xmin <= b.first && xmax >= b.first){\n            if(a.first == b.first){\n                continue;\n            }\n            double mid = (a.first + b.first) / 2.0;\n            double va = width(P1,a.first,m) * width(P2,a.first,n);\n            double vb = width(P1,b.first,m) * width(P2,b.first,n);\n            double vmid = width(P1,mid,m) * width(P2,mid,n);\n            double area = (b.first - a.first)/6.0 * (va + 4*vmid + vb);\n            //printf(\"a,b %d %d\\nmid %f\\nva %f\\nvb %f\\nvmid %f\\narea %f\\n\",a.first,b.first,mid,va,vb,vmid,area);\n            sum += area;\n        }\n    }\n    return sum;\n}\n\nint main(){\n    while(true){\n        int m,n;\n        scanf(\"%d %d\",&m,&n);\n        if(m == 0 && n == 0){\n            break;\n        }\n        pair<int,int> *P1 = new pair<int,int>[m], *P2 = new pair<int,int>[n],*X = new pair<int,int>[m+n];\n        for(int i = 0; i < m+n; i++){\n            int x,y;\n            scanf(\"%d %d\",&x,&y);\n            if(i < m){\n                P1[i] = make_pair(x,y);\n            }else{\n                P2[i-m] = make_pair(x,y);\n            }\n            X[i] = make_pair(x,y);\n        }\n        double vol = volume(P1,P2,X,m,n);\n        printf(\"%f\\n\",vol);\n        delete [] P1;\n        delete [] P2;\n        delete [] X;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 0x7fffffff\n#define inf 0x7fffffffffffffff\n#define ms(a,val) memset(a,val,sizeof(a))\n#define all(x) (x).begin(),(x).end()\n#define sqr(x) ((x)*(x))\n#define lowbit(x) ((x)&(-x))\nll quickpow(ll a,ll b,ll MOD){ll ans=1;while(b){if(b&1)ans=(ans*a)%MOD;a=a*a%MOD,b>>=1;}return ans;}\nll gcd(ll a,ll b){return a%b==0?b:gcd(b,a%b);}\nusing namespace std;\n//head\n//#define LOCAL\n\nconst int MAXN=150;\ndouble X1[MAXN],Y1[MAXN];\ndouble X2[MAXN],Z2[MAXN];\n\ndouble getMin(double *a,int n){\n    double mins=1e12;\n    for(int i=0;i<n;i++)mins=min(mins,a[i]);\n    return mins;\n}\ndouble getMax(double *a,int n){\n    double maxs=-1e12;\n    for(int i=0;i<n;i++)maxs=max(maxs,a[i]);\n    return maxs;\n}\n//Remember the problem makes sure that it's a convex plogyen\ndouble width(double *X,double *Y,int n,double x){\n    double down=1e12,up=-1e12;\n    for(int i=0;i<n;i++){\n        double x1=X[i],y1=Y[i],x2=X[(i+1)%n],y2=Y[(i+1)%n];\n        if(x1!=x2&&(x1-x)*(x2-x)<=0){\n            double y=y1+(y2-y1)*(x-x1)/(x2-x1);\n            down=min(down,y);\n            up=max(up,y);\n        }\n    }\n    return max(0.0,up-down);\n}\n\nint main(){\n    #ifdef LOCAL\n    freopen(\"input.txt\",\"r\",stdin);\n    freopen(\"output.txt\",\"w\",stdout);\n    #endif // LOCAL\n    int m,n;\n    while(~scanf(\"%d%d\",&m,&n)){\n        if(!m&&!n)break;\n        double res=0;\n        for(int i=0;i<m;i++)scanf(\"%lf%lf\",&X1[i],&Y1[i]);\n        for(int i=0;i<n;i++)scanf(\"%lf%lf\",&X2[i],&Z2[i]);\n        int min1=getMin(X1,m),max1=getMax(X1,m),min2=getMin(X2,n),max2=getMax(X2,n);\n        vector<int> xs;\n        for(int i=0;i<m;i++)xs.push_back(X1[i]);\n        for(int i=0;i<n;i++)xs.push_back(X2[i]);\n        sort(all(xs));\n        for(int i=0;i<xs.size()-1;i++){\n            double a=xs[i],b=xs[i+1],c=(a+b)/2;\n            if(min1<=c&&c<=max1&&min2<=c&&c<=max2){\n                double functiona=width(X1,Y1,m,a)*width(X2,Z2,n,a);\n                double functionb=width(X1,Y1,m,b)*width(X2,Z2,n,b);\n                double functionc=width(X1,Y1,m,c)*width(X2,Z2,n,c);\n                res+=(b-a)/6.0*(functiona+4*functionc+functionb);\n            }\n        }\n        printf(\"%.10f\\n\",res);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint m,n;\nconst double EPS = 1e-11;\n\n\ndouble width(vector<pair<int,int> > polygon,double x){\n    vector<double> w;\n    for(int i=0;i<polygon.size();i++){\n        pair<int,int> p=polygon[i];\n        pair<int,int> q=polygon[(i+1)%polygon.size()];\n        if(abs(p.first-x)<EPS){\n            w.push_back(1.0*p.second);\n        }\n        else if( (p.first<x && x<q.first)|| (p.first>x && x>q.first)){\n            int x0=p.first;\n            int y0=p.second;\n            int x1=q.first;\n            int y1=q.second;\n            w.push_back(y0+1.0*(y1-y0)*(x-x0)/(x1-x0));\n        }\n    }\n    assert(w.size()>0);\n    sort(w.begin(), w.end());\n    return w[w.size()-1] - w[0];\n}\n\ndouble volume(vector<pair<int,int> >Pxy,vector<pair<int,int> >Pxz,vector<int> X){\n    double total=0.0;\n    int xmin = max((*min_element(Pxy.begin(), Pxy.end())).first,\n                   (*min_element(Pxz.begin(), Pxz.end())).first);\n    int xmax = min((*max_element(Pxy.begin(), Pxy.end())).first,\n                   (*max_element(Pxz.begin(), Pxz.end())).first);\n    sort(X.begin(), X.end());\n    for(int i=0;i<X.size()-1;i++){\n        int a=X[i];\n        int b=X[i+1];\n        if(!(xmin <= a && a <= xmax &&xmin <= b && b<= xmax) ){\n            continue;\n        }\n        double m=(a+b)/2.0;\n        double va = width(Pxy, a)*width(Pxz, a);\n        double vb = width(Pxy, b)*width(Pxz, b);\n        double vm = width(Pxy, m)*width(Pxz, m);\n        double area=((b-a)/6.0)*(va + 4.0*vm + vb);\n        total+=area;\n    }\n    return total;\n}\nint main(){\n    while(cin>>m>>n&&m!=0){\n        vector<pair<int,int> > Pxy,Pxz;\n        pair<int,int> tem;\n        vector<int> X;\n        for(int i=0;i<m;i++){\n            cin>>tem.first>>tem.second;\n            Pxy.push_back(tem);\n            X.push_back(tem.first);\n        }\n        for(int j=0;j<n;j++){\n            cin>>tem.first>>tem.second;\n            Pxz.push_back(tem);\n            X.push_back(tem.first);\n        }\n        cout << fixed << volume(Pxy, Pxz, X) << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst double EPS = 1e-11;\n\ndouble width(vector<pair<int,int>> polygon, double x) {\n  vector<double> w;\n  for (int i = 0; i < polygon.size() ; i++) {\n    pair<int,int> p = polygon[i], q = polygon[(i+1)%polygon.size()];\n    if (abs(p.first - x) < EPS)\n      w.push_back(1.0*p.second);\n    else if ((p.first < x && x < q.first) || (p.first > x && x > q.first)) {\n      int x0 = p.first, y0 = p.second;\n      int x1 = q.first, y1 = q.second;\n      w.push_back(y0 + 1.0*(y1-y0)*(x-x0)/(x1-x0));\n    }\n  }\n  sort(w.begin(), w.end());\n  return w[w.size()-1] - w[0];\n}\n\ndouble volume(vector<pair<int,int>> pxy, vector<pair<int,int>> pxz, vector<int> X) {\n  double total = 0.0;\n  int xmin = max((*min_element(pxy.begin(), pxy.end())).first,\n                 (*min_element(pxz.begin(), pxz.end())).first);\n  int xmax = min((*max_element(pxy.begin(), pxy.end())).first,\n                 (*max_element(pxz.begin(), pxz.end())).first);\n  sort(X.begin(), X.end());\n  for (int i = 0; i < X.size()-1; i++) {\n    int a = X[i], b = X[i+1];\n    if (!(xmin <= a && a <= xmax && xmin <= b && b <= xmax))\n      continue;\n    double m = (a+b)/2.0;\n    double va = width(pxy, a)*width(pxz, a);\n    double vb = width(pxy, b)*width(pxz, b);\n    double vm = width(pxy, m)*width(pxz, m);\n    double area = ((b-a)/6.0)*(va + 4.0*vm + vb);\n    total += area;\n  }\n  return total;\n}\n\nint main() {\n  int M, N;\n  while (cin >> M >> N && M > 0) {\n    vector<pair<int,int>> PXY, PXZ;\n    vector<int> X;\n    int x, y, z;\n    for (int i = 0; i < M; i++) {\n      cin >> x >> y;\n      PXY.push_back(make_pair(x,y));\n      X.push_back(x);\n    }\n    for (int i = 0; i < N; i++) {\n      cin >> x >> z;\n      PXZ.push_back(make_pair(x,z));\n      X.push_back(x);\n    }\n    cout << fixed << volume(PXY, PXZ, X) << endl;\n  }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "// AOJ 1313\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#define rep(i,a) for( int i = 0; i != (a); ++i )\n#define all(a) (a).begin(), (a).end()\n\nconst int INF = 1 << 30;\n\nint M, N;\nint X1[100], Y1[100];\nint X2[100], Z2[100];\n\ndouble width( int *X, int *Y, int n, double x )\n{\n\tdouble lb = INF, ub = -INF;\n\t\n\trep( i, n )\n\t{\n\t\tdouble x1 = X[i], y1 = Y[i], x2 = X[(i+1)%n], y2 = Y[(i+1)%n];\n\n\t\tif( (x1-x)*(x2-x) <= 0 && x1 != x2 )\n\t\t{\n\t\t\tdouble y = y1+(y2-y1)*(x-x1)/(x2-x1);\n\t\t\tlb = std::min( lb, y );\n\t\t\tub = std::max( ub, y );\n\t\t}\n\t}\n\n\treturn std::max( 0.0, ub-lb );\n}\n\nint main()\n{\n\twhile( scanf( \"%d%d\", &M, &N ), M|N )\n\t{\n\t\trep( i, M )\n\t\t\tscanf( \"%d%d\", X1+i, Y1+i );\n\t\trep( i, N )\n\t\t\tscanf( \"%d%d\", X2+i, Z2+i );\n\n\t\tint min1 = *std::min_element( X1, X1+M ), max1 = *std::max_element( X1, X1+M ),\n\t\t\tmin2 = *std::min_element( X2, X2+M ), max2 = *std::max_element( X2, X2+M );\n\t\n\t\tstd::vector<int> xs;\n\t\trep( i, M )\n\t\t\txs.push_back( X1[i] );\n\t\trep( i, N )\n\t\t\txs.push_back( X2[i] );\n\n\t\tstd::sort( all( xs ) );\n\n\t\tdouble ans = 0.0;\n\t\trep( i, xs.size()-1 )\n\t\t{\n\t\t\tdouble a = xs[i], b = xs[i+1], c = (a+b)/2;\n\n\t\t\tif( min1 <= c && c <= max1 && min2 <= c && c <= max2 )\n\t\t\t{\n\t\t\t\tdouble fa = width( X1, Y1, M, a ) * width( X2, Z2, N, a );\n\t\t\t\tdouble fb = width( X1, Y1, M, b ) * width( X2, Z2, N, b );\n\t\t\t\tdouble fc = width( X1, Y1, M, c ) * width( X2, Z2, N, c );\n\n\t\t\t\tans += (b-a)/6*(fa+4*fc+fb);\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%.10f\\n\", ans );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ndouble eps = 1e-10;\nvector<P> ps1,ps2;\nbool eq(double a,double b){\n\treturn fabs(a-b) < eps;\n}\n\nvector<double> ux;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\npair<double,double> seg(const vector<P> &ps,double x){\n\tdouble mi = 1e9, ma = -1e9;\n\tauto reflesh = [&mi,&ma](double y){\n\t\tmi = min(mi,y);\n\t\tma = max(ma,y);\n\t};\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tP a = ps[i];\n\t\tP b = ps[(i+1)%ps.size()];\n\t\tif( a.real() > b.real() ) swap(a,b);\n\t\tif( eq(a.real(),x) ) reflesh(a.imag());\n\t\tif( eq(b.real(),x) ) reflesh(b.imag());\n\t\tif( a.real() + eps < x and x < b.real() - eps ){\n\t\t\treflesh(a.imag() + (x - a.real()) * (b.imag() - a.imag()) / (b.real()-a.real()));\n\t\t}\n\t}\n\tif( ma < mi ) return {0.0,0.0};\n\treturn {mi,ma};\n}\n\ndouble Sf(double x){\n\tauto p = seg(ps1,x);\n\treturn p.second - p.first;\n}\n\ndouble Ss(double l,double r){\n\treturn (r-l)/6*(Sf(l)+4*Sf((l+r)/2)+Sf(r));\n}\n\ndouble S2(double l,double r,int k=3){\n\tif( r < l ) return 0;\n\tdouble m = (l+r)/2;\n\tdouble a = Ss(l,m);\n\tdouble b = Ss(m,r);\n\tdouble c = Ss(l,r);\n\tif( (c>eps or k <= 0) and eq(a+b,c) ){\n\t\t//cout << a+b << \" \" << c << endl;\n\t\treturn c;\n\t}else{\n\t\treturn S2(l,m,k-1) + S2(m,r,k-1);\n\t}\t\n}\ndouble S(double l,double r){\n\tdouble sans = 0;\n\tfor(int i = 0 ; i+1 < ux.size() ; i++){\n\t\tif( ux[i] != ux[i+1] ){\n\t\t\tsans += S2(max(l,ux[i]),min(r,ux[i+1]));\n\t\t}\n\t}\n\t//cout << sans << endl;\n\treturn sans;\n\t\n}\n\ndouble Vf(double z){\n\tauto p = seg(ps2,z);\n\treturn S(p.first,p.second);\n}\n\ndouble Vs(double l,double r){\n\treturn (r-l)/6*(Vf(l)+4*Vf((l+r)/2)+Vf(r));\n}\n\ndouble V(double l,double r,int k=3){\n\tdouble m = (l+r)/2;\n\tdouble a = Vs(l,m);\n\tdouble b = Vs(m,r);\n\tdouble c = Vs(l,r);\n\tif( (c>eps or k <= 0) and eq(a+b,c) ){\n\t\treturn c;\n\t}else{\n\t\treturn V(l,m,k-1) + V(m,r,k-1);\n\t}\t\n}\n\nint main(){\n\tint m,n;\n\twhile(cin >> m >> n && m ){\n\t\t\n\t\tps1.clear();\n\t\tps2.clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tps1.push_back(in());\n\t\t\tux.push_back(ps1.back().real());\n\t\t}\n\n\t\tvector<double> uz;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tps2.push_back(in());\n\t\t\tps2.back() = P(ps2.back().imag(),ps2.back().real());\n\t\t\tuz.push_back(ps2.back().real());\n\t\t}\n\t\tsort(uz.begin(),uz.end());\n\t\tsort(ux.begin(),ux.end());\n\t\tdouble vans = 0;\n\t\t//for( auto z : uz ) cout << z << \" \"; cout << endl;\n\t\t//for( auto x : ux ) cout << x << \" \"; cout << endl;\n\t\tfor(int i = 0 ; i+1 < uz.size() ; i++)\n\t\t\tif( uz[i] != uz[i+1] )\n\t\t\t\tvans += V(uz[i],uz[i+1]);\n\t\tprintf(\"%.10lf\\n\",vans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <queue>\n#include <utility>\n\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-12;\n\nstruct Point{\n  double x,y;\n  Point(double x = 0.0, double y = 0.0): x(x), y(y) {}\n  Point operator + (Point p){\n    return Point(x + p.x,y + p.y);\n  }\n  Point operator - (Point p){\n    return Point(x - p.x,y - p.y);\n  }\n  Point operator * (double lambda){\n    return Point(x * lambda,y * lambda);\n  }\n  Point operator / (double lambda){\n    return Point(x / lambda,y / lambda);\n  }\n  double norm(){\n    return x * x + y * y;\n  }\n  double abs_(){\n    return sqrt(norm());\n  }\n  bool operator == (const Point &p)const\n  {\n    return abs(x - p.x) < EPS && abs(y - p.y) < EPS;\n  }\n  bool operator < (const Point &p)const{\n    if(abs(x - p.x) < EPS) return y < p.y;\n    return x < p.x;\n  }\n};\ntypedef Point Vector;\ndouble dot(Vector a,Vector b){\n  return a.x * b.x + a.y * b.y;\n}\ndouble det(Vector a,Vector b){\n  return a.x * b.y - a.y * b.x;\n}\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()): p1(p1), p2(p2) {}\n};\ntypedef Segment Line;\ntypedef vector <Point> Polygon;\n#define maxn 105\nPoint crossPoint(Line a,Line b){\n  double r = det(b.p2 - b.p1,a.p1 - b.p1) / det(a.p2 - a.p1,b.p2 - b.p1);\n  return a.p1 + (a.p2 - a.p1) * r;\n}\ndouble calc(Polygon P,double x0){\n  double miny = 101.0, maxy = -101.0;\n  int n = P.size();\n  Line l = Line(Point(x0,-101.0),Point(x0,101.0));\n  for(int i = 0;i < n;i++){\n    if(P[i].x == P[(i + 1) % n].x) continue;\n    if((P[i].x - x0) * (P[(i + 1) % n].x - x0) <= 0.0){\n      Point p = crossPoint(Line(P[i],P[(i + 1) % n]),l);\n      miny = min(miny,p.y);\n      maxy = max(maxy,p.y);\n    }\n  }\n  return max(0.0,maxy - miny);\n}\nint m,n;\nPolygon c1,c2;\nvector <double> xs;\ndouble f(double x0){\n  return calc(c1,x0) * calc(c2,x0);\n}\nint main(){\n  while(~scanf(\"%d%d\",&m,&n) && m){\n    xs.clear();\n    c1.resize(m);\n    c2.resize(n);\n    for(int i = 0;i < m;i++){\n      double x,y;\n      scanf(\"%lf%lf\",&x,&y);\n      c1[i] = Point(x,y);\n      xs.push_back(x);\n    }\n    for(int i = 0;i < n;i++){\n      double x,y;\n      scanf(\"%lf%lf\",&x,&y);\n      c2[i] = Point(x,y);\n      xs.push_back(x);\n    }\n    sort(xs.begin(),xs.end());\n    double ans = 0.0;\n    for(int i = 0;i < n + m - 1;i++){\n      double l = xs[i] + EPS, r = xs[i + 1] - EPS, mid = (l + r) / 2.0;\n      ans += (r - l) * (f(l) + 4.0 * f(mid) + f(r)) / 6.0;\n    }\n    printf(\"%.10f\\n\",ans);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double dbl;\n#define double long double\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define REP(i,n) for(int i = 0 ; i < n ; i++)\ndouble eps = 1e-11;\ndouble EPS = eps;\n\nbool eq(double a,double b){\n\treturn fabs(a-b) < eps;\n}\n\ndouble cross(P a,P b) { return imag(conj(a)*b); }\ndouble dot(P a,P b) { return real(conj(a)*b);}\n\nvector<P> ps1,ps2;\n//??´???\nstruct L : public vector<P> {\n\tL(P a,P b) {\n\t\tpush_back(a); push_back(b);\n\t}\n\t\n};\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\t// a ??? b ??§???????¨??????????????????? b ??? c(???)\n\tif (cross(b, c) < 0)   return -1;\t// a ??? b ??§????¨??????????????????? b ??? c(???)\n\tif (dot(b, c) < 0) return +2;    \t// a???b??§????????????a??????????¶???????b???c(c--a--b)\n\tif (norm(b) < norm(c)) return -2;\t// a???b??§????????????b???c(a--b--c)\n\treturn 0;\t\t\t\t\t\t\t// a???b??§????????????b???c(????????? b == c)\n}\n \n\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n \n \n// ???????§???¢???????????????????§???¢???????????´?????§????????????\n//???????????´?????????????????´?????????????????´?????????????????¨?????????????????¨?????????????????????????????¨????????????????????????\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\nG convex_cut(const G& poly, const L& l) {\n  G Q;\n  for (int i = 0; i < poly.size(); ++i) {\n    P A = curr(poly, i), B = next(poly, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspoint(L(A, B), l));\n  }\n  return Q;\n}\n\n// ????´?????§???¢?????¢??????\"2???\"????±??????? O(n)\ndouble area2(const G& poly) {\n\tdouble A = 0;\n\tREP(i,poly.size()) A += cross(curr(poly, i), next(poly, i));\n\treturn abs(A);\n}\n\n\nvector<double> ux;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\t\n\treturn P(x,y);\n}\npair<double,double> seg(const vector<P> &ps,double x){\n\tdouble mi = 1e9, ma = -1e9;\n\tauto reflesh = [&mi,&ma](double y){\n\t\tmi = min(mi,y);\n\t\tma = max(ma,y);\n\t};\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tP a = ps[i];\n\t\tP b = ps[(i+1)%ps.size()];\n\t\tif( a.real() > b.real() ) swap(a,b);\n\t\tif( eq(a.real(),x) ) reflesh(a.imag());\n\t\tif( eq(b.real(),x) ) reflesh(b.imag());\n\t\tif( a.real() + eps < x and x < b.real() - eps ){\n\t\t\treflesh(a.imag() + (x - a.real()) * (b.imag() - a.imag()) / (b.real()-a.real()));\n\t\t}\n\t}\n\tif( ma < mi ) return {0.0,0.0};\n\treturn {mi,ma};\n}\n\ndouble S(double l,double r){\n\tif( r <= l ) return 0;\n\tG g1 = convex_cut(ps1,L(P(l,0),P(l,-1)));\n\tG g2 = convex_cut(g1,L(P(r,0),P(r,+1)));\n\t\n\treturn area2(g2) / 2;\n\t\n}\n\ndouble Vf(double z){\n\tauto p = seg(ps2,z);\n\treturn S(p.first,p.second);\n}\n\ndouble Vs(double l,double r){\n\treturn (r-l)/6*(Vf(l)+4*Vf((l+r)/2)+Vf(r));\n}\n\ndouble V(double l,double r,int k=0){\n\tif( l >= r ) return 0;\n\tdouble m = (l+r)/2;\n\tdouble a = Vs(l,m);\n\tdouble b = Vs(m,r);\n\tdouble c = Vs(l,r);\n\tif( ( k <= 0) and eq(a+b,c) ){\n\t\treturn c;\n\t}else{\n\t\treturn V(l,m,k-1) + V(m,r,k-1);\n\t}\t\n}\n\nint main(){\n\tint m,n;\n\twhile(cin >> m >> n && m ){\n\t\t\n\t\tps1.clear();\n\t\tps2.clear();\n\t\tux.clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tps1.push_back(in());\n\t\t\tux.push_back(ps1.back().real());\n\t\t}\n\n\t\tvector<double> uz;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tps2.push_back(in());\n\t\t\tps2.back() = P(ps2.back().imag(),ps2.back().real());\n\t\t\tuz.push_back(ps2.back().real());\n\t\t}\n\t\t\n\t\tsort(uz.begin(),uz.end());\n\t\tsort(ux.begin(),ux.end());\n\t\tdouble vans = 0;\n\t\t//for( auto z : uz ) cout << z << \" \"; cout << endl;\n\t\t//for( auto x : ux ) cout << x << \" \"; cout << endl;\n\t\tfor(int i = 0 ; i+1 < uz.size() ; i++)\n\t\t\tif( uz[i] != uz[i+1] )\n\t\t\t\tvans += V(uz[i],uz[i+1]);\n\t\tprintf(\"%.8lf\\n\",(dbl)vans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint m,n;\nconst double EPS = 1e-11;\nvector<pair<int,int> > Pxy,Pxz;\npair<int,int> tem;\nvector<int> X;\n\n\ndouble width(vector<pair<int,int> > polygon,double x){\n    vector<double> w;\n    for(int i=0;i<polygon.size();i++){\n        pair<int,int> p=polygon[i];\n        pair<int,int> q=polygon[(i+1)%polygon.size()];\n        if(abs(p.first-x)<EPS){\n            w.push_back(1.0*p.second);\n        }\n        else if( (p.first<x && x<q.first)|| (p.first>0 && x>q.first)){\n            int x0=p.first;\n            int y0=p.second;\n            int x1=q.first;\n            int y1=q.second;\n            w.push_back(y0+1.0*(y1-y0)*(x-x0)/(x1-x0));\n        }\n    }\n    assert(w.size()>0);\n    sort(w.begin(), w.end());\n    return w[w.size()-1] - w[0];\n}\n\nint volume(vector<pair<int,int> >Pxy,vector<pair<int,int> >Pxz,vector<int> X){\n    double total=0.0;\n    int xmin = max((*min_element(Pxy.begin(), Pxy.end())).first,\n                   (*min_element(Pxz.begin(), Pxz.end())).first);\n    int xmax = min((*max_element(Pxy.begin(), Pxy.end())).first,\n                   (*max_element(Pxz.begin(), Pxz.end())).first);\n    sort(X.begin(), X.end());\n    for(int i=0;i<X.size()-1;i++){\n        int a=X[i];\n        int b=X[i+1];\n        if(!(xmin <= a && a <= xmax &&xmin <= b && b<= xmax) ){\n            continue;\n        }\n        double m=(a+b)/2.0;\n        double va = width(Pxy, a)*width(Pxz, a);\n        double vb = width(Pxy, b)*width(Pxz, b);\n        double vm = width(Pxy, m)*width(Pxz, m);\n        double area=((b-a)/6.0)*(va + 4.0*vm + vb);\n        total+=area;\n    }\n    return total;\n}\nint main(){\n    while(cin>>m>>n&&n!=0){\n        for(int i=1;i<=m;i++){\n            cin>>tem.first>>tem.second;\n            Pxy.push_back(tem);\n            X.push_back(tem.first);\n        }\n        for(int j=1;j<=n;j++){\n            cin>>tem.first>>tem.second;\n            Pxz.push_back(tem);\n            X.push_back(tem.first);\n        }\n        cout << fixed << volume(Pxy, Pxz, X) << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst double EPS = 1e-8;\ntypedef pair<long double, long double> P;\nvector<P> vp1;\nvector<P> vp2;\n\nlong double width(long double x, const vector<P>& v){\n    long double top = -1e8, bottom = 1e8;\n    REP(i, v.size()){\n        P p1 = v[i], p2 = v[(i + 1) % v.size()];\n        if(abs(p1.first - p2.first) < EPS){\n            if(abs(p1.first - x) < EPS){\n                top = max(top, p1.second);\n                top = max(top, p2.second);\n                bottom = min(bottom, p1.second);\n                bottom = min(bottom, p2.second);\n            }\n            continue;\n        }\n        if(p1.first > p2.first) swap(p1, p2);\n        if(p1.first - EPS < x && x < p2.first + EPS){\n            long double ratio = (x - p1.first) / (p2.first - p1.first);\n            long double y = p1.second + ratio * (p2.second - p1.second);\n            top = max(top, y);\n            bottom = min(bottom, y);\n        }\n    }\n    return max(0.0L, top - bottom);\n}\nlong double f(long double x){\n    long double w = width(x, vp1) * width(x, vp2);\n    return w;\n}\n\nlong double simpson(long double l, long double r, int N){\n    long double h = (r - l) / (2 * N); \n    long double S = f(l) + f(r);\n    for(int i = 1; i < 2 * N; i += 2){\n        S += 4.0 * f(l + h * i);\n    }\n    for(int i = 2; i < 2 * N; i += 2){\n        S += 2.0 * f(l + h * i);\n    }\n    return S * h / 3.0;\n}\n\n\nint main(){\n    int M, N;\n    while(cin >> M >> N && M){\n        vp1.resize(M);\n        vp2.resize(N);\n        REP(i, M) cin >> vp1[i].first >> vp1[i].second;\n        REP(i, N) cin >> vp2[i].first >> vp2[i].second;\n        long double left1 = vp1[0].first, right1 = vp1[0].first;\n        long double left2 = vp2[0].first, right2 = vp2[0].first;\n        REP(i, M) left1 = min(left1, vp1[i].first);\n        REP(i, N) left2 = min(left2, vp2[i].first);\n        REP(i, M) right1 = max(right1, vp1[i].first);\n        REP(i, N) right2 = max(right2, vp2[i].first);\n        vector<long double> vx;\n        long double left = max(left1, left2), right = min(right1, right2);\n        vx.push_back(left); vx.push_back(right);\n        REP(i, M) if(left < vp1[i].first && vp1[i].first < right) vx.push_back(vp1[i].first);\n        REP(i, N) if(left < vp2[i].first && vp2[i].first < right) vx.push_back(vp2[i].first);\n        long double S = 0;\n        sort(vx.begin(), vx.end());\n        REP(i, vx.size() - 1){\n            S += simpson(vx[i], vx[i + 1], 100);\n        }\n        printf(\"%.16Lf\\n\", S);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define IOO ios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n#define endl '\\n'\n\ntypedef long long ll;\n\nint n, m;\ndouble xc1[200], yc1[200], xc2[200], zc2[200];\ndouble max1, max2, min1, min2;\n\nbool ok(double x) {\n\treturn max(min1, min2) <= x && x <= min(max1, max2);\n}\n\ndouble width(int k, double x, double a[], double b[]) {\n\tdouble up = -200.0, down = 200.0;\n\tfor (int i = 1; i <= k; i++) {\n\t\tdouble x1 = a[i], x2 = a[i % k + 1];\n\t\tif (min(x1, x2) <= x && x <= max(x1, x2)) {\n\t\t\tdouble temp = b[i] + (b[i] - b[i % k + 1]) / (x1 - x2) * (x - x1);\n\t\t\tup = max(up, temp);\n\t\t\tdown = min(down, temp);\n\t\t}\n\t}\n\treturn max(0.0, up - down);\n}\n\nconst double eps = 1e-6; // 注意复合精度误差\ndouble f(double x) {\n\treturn width(m, x, xc1, yc1) * width(n, x, xc2, zc2);\n} \ndouble simpson(double l, double r) {\n\treturn (f(l) + 4.0 * f((l + r) / 2.0) + f(r)) / 6.0 * (r - l);\n}\ndouble integral(double l, double r) {\n\tdouble mid = (l + r) / 2.0;\n\tdouble res = simpson(l, r);\n\tif (fabs(res - simpson(l, mid) - simpson(mid, r)) < eps) return res;\n\telse return integral(l, mid) + integral(mid, r);\n}\n\nint main() {\n\tIOO;\n\twhile (cin >> m >> n && (n + m)) {\n\t\tvector<double> x(n + m + 1, 0);\n\t\tfor (int i = 1; i <= m; i++) {\n\t\t\tcin >> xc1[i] >> yc1[i];\n\t\t\tx.push_back(xc1[i]);\n\t\t}\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tcin >> xc2[i] >> zc2[i];\n\t\t\tx.push_back(xc2[i]);\n\t\t}\n\t\tsort(x.begin(), x.end());\n\t\tmax1 = *max_element(xc1 + 1, xc1 + m + 1);\n\t\tmin1 = *min_element(xc1 + 1, xc1 + m + 1);\n\t\tmax2 = *max_element(xc2 + 1, xc2 + n + 1);\n\t\tmin2 = *min_element(xc2 + 1, xc2 + n + 1);\n\t\tdouble ans = 0.0;\n\t\tfor (int i = 1; i < x.size(); i++) {\n\t\t\tif (ok(x[i - 1]) && ok(x[i])) {\n\t\t\t\tans += simpson(x[i - 1], x[i]);\n\t\t\t}\n\t\t}\n\t\tcout << fixed << setprecision(10) << ans << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint m,n;\nconst double EPS = 1e-11;\n\n\ndouble width(vector<pair<int,int> > polygon,double x){\n    vector<double> w;\n    for(int i=0;i<polygon.size();i++){\n        pair<int,int> p=polygon[i];\n        pair<int,int> q=polygon[(i+1)%polygon.size()];\n        if(abs(p.first-x)<EPS){\n            w.push_back(1.0*p.second);\n        }\n        else if( (p.first<x && x<q.first)|| (p.first>0 && x>q.first)){\n            int x0=p.first;\n            int y0=p.second;\n            int x1=q.first;\n            int y1=q.second;\n            w.push_back(y0+1.0*(y1-y0)*(x-x0)/(x1-x0));\n        }\n    }\n    assert(w.size()>0);\n    sort(w.begin(), w.end());\n    return w[w.size()-1] - w[0];\n}\n\nint volume(vector<pair<int,int> >Pxy,vector<pair<int,int> >Pxz,vector<int> X){\n    double total=0.0;\n    int xmin = max((*min_element(Pxy.begin(), Pxy.end())).first,\n                   (*min_element(Pxz.begin(), Pxz.end())).first);\n    int xmax = min((*max_element(Pxy.begin(), Pxy.end())).first,\n                   (*max_element(Pxz.begin(), Pxz.end())).first);\n    sort(X.begin(), X.end());\n    for(int i=0;i<X.size()-1;i++){\n        int a=X[i];\n        int b=X[i+1];\n        if(!(xmin <= a && a <= xmax &&xmin <= b && b<= xmax) ){\n            continue;\n        }\n        double m=(a+b)/2.0;\n        double va = width(Pxy, a)*width(Pxz, a);\n        double vb = width(Pxy, b)*width(Pxz, b);\n        double vm = width(Pxy, m)*width(Pxz, m);\n        double area=((b-a)/6.0)*(va + 4.0*vm + vb);\n        total+=area;\n    }\n    return total;\n}\nint main(){\n    while(cin>>m>>n&&n!=0){\n        vector<pair<int,int> > Pxy,Pxz;\n        pair<int,int> tem;\n        vector<int> X;\n        for(int i=1;i<=m;i++){\n            cin>>tem.first>>tem.second;\n            Pxy.push_back(tem);\n            X.push_back(tem.first);\n        }\n        for(int j=1;j<=n;j++){\n            cin>>tem.first>>tem.second;\n            Pxz.push_back(tem);\n            X.push_back(tem.first);\n        }\n        cout << fixed << volume(Pxy, Pxz, X) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double dbl;\n#define double long double\ntypedef complex<double> P;\ntypedef vector<P> G;\n#define REP(i,n) for(int i = 0 ; i < n ; i++)\ndouble eps = 1e-11;\ndouble EPS = eps;\n\nbool eq(double a,double b){\n\treturn fabs(a-b) < eps;\n}\n\ndouble cross(P a,P b) { return imag(conj(a)*b); }\ndouble dot(P a,P b) { return real(conj(a)*b);}\n\nvector<P> ps1,ps2;\n//??´???\nstruct L : public vector<P> {\n\tL(P a,P b) {\n\t\tpush_back(a); push_back(b);\n\t}\n\t\n};\nint ccw(P a, P b, P c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > 0)   return +1;\t// a ??? b ??§???????¨??????????????????? b ??? c(???)\n\tif (cross(b, c) < 0)   return -1;\t// a ??? b ??§????¨??????????????????? b ??? c(???)\n\tif (dot(b, c) < 0) return +2;    \t// a???b??§????????????a??????????¶???????b???c(c--a--b)\n\tif (norm(b) < norm(c)) return -2;\t// a???b??§????????????b???c(a--b--c)\n\treturn 0;\t\t\t\t\t\t\t// a???b??§????????????b???c(????????? b == c)\n}\n \n\n\nP crosspoint(const L &l, const L &m) {\n\tdouble A = cross(l[1] - l[0], m[1] - m[0]);\n\tdouble B = cross(l[1] - l[0], l[1] - m[0]);\n\tif (abs(A) < EPS && abs(B) < EPS) return m[0];\n\treturn m[0] + B / A * (m[1] - m[0]);\n}\n \n \n// ???????§???¢???????????????????§???¢???????????´?????§????????????\n//???????????´?????????????????´?????????????????´?????????????????¨?????????????????¨?????????????????????????????¨????????????????????????\n#define curr(P, i) P[(i) % P.size()]\n#define next(P, i) P[(i+1)%P.size()]\n#define prev(P, i) P[(i+P.size()-1) % P.size()]\nG convex_cut(const G& poly, const L& l) {\n  G Q;\n  for (int i = 0; i < poly.size(); ++i) {\n    P A = curr(poly, i), B = next(poly, i);\n    if (ccw(l[0], l[1], A) != -1) Q.push_back(A);\n    if (ccw(l[0], l[1], A)*ccw(l[0], l[1], B) < 0)\n      Q.push_back(crosspoint(L(A, B), l));\n  }\n  return Q;\n}\n\n// ????´?????§???¢?????¢??????\"2???\"????±??????? O(n)\ndouble area2(const G& poly) {\n\tdouble A = 0;\n\tREP(i,poly.size()) A += cross(curr(poly, i), next(poly, i));\n\treturn abs(A);\n}\n\n\nvector<double> ux;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\t\n\treturn P(x,y);\n}\npair<double,double> seg(const vector<P> &ps,double x){\n\tdouble mi = 1e9, ma = -1e9;\n\tauto reflesh = [&mi,&ma](double y){\n\t\tmi = min(mi,y);\n\t\tma = max(ma,y);\n\t};\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tP a = ps[i];\n\t\tP b = ps[(i+1)%ps.size()];\n\t\tif( a.real() > b.real() ) swap(a,b);\n\t\tif( eq(a.real(),x) ) reflesh(a.imag());\n\t\tif( eq(b.real(),x) ) reflesh(b.imag());\n\t\tif( a.real() + eps < x and x < b.real() - eps ){\n\t\t\treflesh(a.imag() + (x - a.real()) * (b.imag() - a.imag()) / (b.real()-a.real()));\n\t\t}\n\t}\n\tif( ma < mi ) return {0.0,0.0};\n\treturn {mi,ma};\n}\n\ndouble S(double l,double r){\n\tif( r <= l ) return 0;\n\tG g1 = convex_cut(ps1,L(P(l,0),P(l,-1)));\n\tG g2 = convex_cut(g1,L(P(r,0),P(r,+1)));\n\t\n\treturn area2(g2) / 2;\n\t\n}\n\ndouble Vf(double z){\n\tauto p = seg(ps2,z);\n\treturn S(p.first,p.second);\n}\n\ndouble Vs(double l,double r){\n\treturn (r-l)/6*(Vf(l)+4*Vf((l+r)/2)+Vf(r));\n}\n\ndouble V(double l,double r,int k=5){\n\tif( l >= r ) return 0;\n\tdouble m = (l+r)/2;\n\tdouble a = Vs(l,m);\n\tdouble b = Vs(m,r);\n\tdouble c = Vs(l,r);\n\tif( ( k <= 0) and eq(a+b,c) ){\n\t\treturn c;\n\t}else{\n\t\treturn V(l,m,k-1) + V(m,r,k-1);\n\t}\t\n}\n\nint main(){\n\tint m,n;\n\twhile(cin >> m >> n && m ){\n\t\t\n\t\tps1.clear();\n\t\tps2.clear();\n\t\tux.clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tps1.push_back(in());\n\t\t\tux.push_back(ps1.back().real());\n\t\t}\n\n\t\tvector<double> uz;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tps2.push_back(in());\n\t\t\tps2.back() = P(ps2.back().imag(),ps2.back().real());\n\t\t\tuz.push_back(ps2.back().real());\n\n\t\t}\n\t\t\n\t\tsort(uz.begin(),uz.end());\n\t\tsort(ux.begin(),ux.end());\n\t\tdouble vans = 0;\n\t\t//for( auto z : uz ) cout << z << \" \"; cout << endl;\n\t\t//for( auto x : ux ) cout << x << \" \"; cout << endl;\n\t\tfor(int i = 0 ; i+1 < uz.size() ; i++)\n\t\t\tif( uz[i] != uz[i+1] )\n\t\t\t\tvans += V(uz[i],uz[i+1]);\n\t\tprintf(\"%.8lf\\n\",(dbl)vans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <utility>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\ndouble width(const pair<int,int> P[], double x, int length){\n    vector<double> w(0);\n    for(int i = 0; i < length; i++){\n        pair<int,int> p,q;\n        p = P[i];\n        i != length-1 ? q = P[i+1] : q = P[0];\n        if(p.first == x){\n            w.push_back(p.second);\n        }else if((p.first < x && x < q.first) || (p.first > x && x > q.first)){\n            int x0,y0,x1,y1;\n            if(p.first < x){\n                x0 = p.first;\n                y0 = p.second;\n                x1 = q.first;\n                y1 = q.second;\n            }else{\n                x0 = q.first;\n                y0 = q.second;\n                x1 = p.first;\n                y1 = p.second;\n            }\n            w.push_back(y0 + 1.0*(y1-y0)*(x-x0)/(x1-x0));\n        }\n    }\n    sort(w.begin(),w.end());\n    return w.front() - w.back();\n}\n\n//P1??¨P2????????????????????????????????????x????????????sort?????????x???????????????????¬???¢??°?????????????????????\ndouble volume(const pair<int,int> P1[], const pair<int,int> P2[], pair<int,int> X[],int m, int n){\n    /*\n    for(int i = 0; i < m+n; i++){\n        if(i < m){\n            printf(\"P1[%d]:%d %d\\n\",i,P1[i].first,P1[i].second);\n        }else{\n            printf(\"P2[%d]:%d %d\\n\",i-m,P2[i-m].first,P2[i-m].second);\n        }\n    }\n     */\n    sort(X,X+m+n);\n    pair<int,int> p1mm(P1[0].first,P1[0].first),p2mm(P2[0].first,P2[0].first);\n    for(int i = 0; i < m; i++){\n        if(p1mm.first > P1[i].first){\n            p1mm.first = P1[i].first;\n        }\n        if(p1mm.second < P1[i].first){\n            p1mm.second = P1[i].first;\n        }\n    }\n    for(int i = 0; i < n; i++){\n        if(p2mm.first > P2[i].first){\n            p2mm.first = P2[i].first;\n        }\n        if(p2mm.second < P2[i].first){\n            p2mm.second = P2[i].first;\n        }\n    }\n    /*\n    printf(\"p1mm: %d %d\\np2mm: %d %d\\n\",p1mm.first,p1mm.second,p2mm.first,p2mm.second);\n    for(int i = 0; i < m+n; i++){\n        if(i < m){\n            printf(\"P1[%d]:%d %d\\n\",i,P1[i].first,P1[i].second);\n        }else{\n            printf(\"P2[%d]:%d %d\\n\",i-m,P2[i-m].first,P2[i-m].second);\n        }\n    }*/\n    int xmin = max(p1mm.first,p2mm.first), xmax = min(p1mm.second,p2mm.second);\n    //printf(\"minmax: %d %d\\n\",xmin,xmax);\n    double sum = 0;\n    for(int i = 0; i < m+n-1; i++){\n        pair<int,int> a = X[i], b = X[i+1];\n        if(xmin <= a.first && xmax >= a.first && xmin <= b.first && xmax >= b.first){\n            if(a.first == b.first){\n                continue;\n            }\n            double mid = (a.first + b.first) / 2.0;\n            double va = width(P1,a.first,m) * width(P2,a.first,n);\n            double vb = width(P1,b.first,m) * width(P2,b.first,n);\n            double vmid = width(P1,mid,m) * width(P2,mid,n);\n            double area = (b.first - a.first)/6.0 * (va + 4*vmid + vb);\n            //printf(\"a,b %d %d\\nmid %f\\nva %f\\nvb %f\\nvmid %f\\narea %f\\n\",a.first,b.first,mid,va,vb,vmid,area);\n            sum += area;\n        }\n    }\n    return sum;\n}\n\nint main(){\n    while(true){\n        int m,n;\n        scanf(\"%d %d\",&m,&n);\n        if(m == 0 && n == 0){\n            break;\n        }\n        pair<int,int> *P1 = new pair<int,int>[m], *P2 = new pair<int,int>[n],*X = new pair<int,int>[m+n];\n        for(int i = 0; i < m+n; i++){\n            int x,y;\n            scanf(\"%d %d\",&x,&y);\n            if(i < m){\n                P1[i] = make_pair(x,y);\n            }else{\n                P2[i-m] = make_pair(x,y);\n            }\n            X[i] = make_pair(x,y);\n        }\n        double vol = volume(P1,P2,X,m,n);\n        printf(\"%f\\n\",vol);\n        delete [] P1;\n        delete [] P2;\n        delete [] X;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 100;\nconst int MAX_M = 100;\nconst double INF = 1e77;\n\nint M, N;\nint X1[MAX_M], Y1[MAX_M];\nint X2[MAX_N], Z2[MAX_N];\n\ndouble width(int *X, int *Y, int n, double x){\n\tdouble lb = INF, ub = -INF;\n\tfor(int i=0;i<n;i++){\n\t\tdouble x1 = X[i], y1 = Y[i], x2 = X[(i+1)%n], y2 = Y[(i+1)%n];\n\t\tif((x1 - x) * (x2 - x)  <= 0 && x1 != x2){\n\t\t\tdouble y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n\t\t\tlb = min(lb, y);\n\t\t\tub = max(ub, y);\n\t\t}\n\t}\n\treturn max(0.0, ub - lb);\n}\n\nvoid solve(){\n\tint min1 = *min_element(X1, X1 + M), max1 = *max_element(X1, X1 + M);\n\tint min2 = *min_element(X2, X2 + N), max2 = *max_element(X2, X2 + N);\n\tvector<int> xs;\n\tfor(int i=0;i<M;i++) xs.push_back(X1[i]);\n\tfor(int i=0;i<N;i++) xs.push_back(X2[i]);\n\tsort(xs.begin(), xs.end());\n\n\tdouble res = 0;\n\tfor(int i=0;i+1<xs.size();i++){\n\t\tdouble a = xs[i], b = xs[i+1], c = (a + b) / 2;\n\t\tif(min1 <= c && c <= max1 && min2 <= c && c <= max2){\n\t\t\tdouble fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n\t\t\tdouble fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n\t\t\tdouble fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n\t\t\tres += (b - a) / 6 * (fa + 4 * fc + fb);\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", res);\n}\n\nint main(){\n\twhile(cin >> M >> N && (M|N)){\n\t\tfor(int i=0;i<M;i++) cin >> X1[i] >> Y1[i];\n\t\tfor(int i=0;i<N;i++) cin >> X2[i] >> Z2[i];\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\ntypedef vector<P> vecP;\n\nconst double eps=1e-8;\n\nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n\nP getCrossLL(P a,P b,P c,P d){\n  a-=d;b-=d;c-=d;\n  return d+a+(b-a)*imag(a/c)/imag(a/c-b/c);\n}\n \nint m,n;\nP s[100],t[100];\nvector<int> X;\n\ndouble getW(P s[100],int m,double x){\n  P a=P(x,0);\n  P b=P(x,1);\n  double maxm=-1e9;\n  double mini=1e9;\n  \n  for(int i=0;i<m;i++){\n    P c=s[i];\n    P d=s[(i+1)%m];\n    \n    if( eq( c.real() , d.real() ) ){\n      continue;\n    }\n    \n    if( min(c.real(),d.real()) < x && x < max(c.real(),d.real()) ){\n      P p=getCrossLL(a,b,c,d);\n      maxm=max(maxm, p.imag());\n      mini=min(mini, p.imag());\n    }\n  }\n\n  return max(0.0, maxm-mini);\n}\n\ndouble f(double x){\n  return getW(s,m,x)*getW(t,n,x);\n}\n\nint main(){\n  while(1){\n    cin>>m>>n;\n    if(m==0&&n==0)break;\n\n    X.clear();\n    for(int i=0;i<m;i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      s[i]=P(x,y);\n      X.push_back(x);\n    }\n    for(int i=0;i<n;i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      t[i]=P(x,y);\n      X.push_back(x);\n    }\n    sort(X.begin(),X.end());\n    X.erase( unique(X.begin(),X.end()) , X.end() );\n\n    double ans=0;\n    for(int i=0;i+1<(int)X.size();i++){\n      \n      \n      double a=X[i], b=X[i+1], mid=(a+b)*0.5;\n\n\n      double Sa=f(a+eps);\n      double Sb=f(b-eps);\n      double Smid=f(mid);\n      \n      if( eq(Smid,0) )continue;\n      \n      double dis= (b-a)*(Sa + 4*Smid + Sb)/6.0;\n      //            cout<<a<<' '<<b<<' '<<Sa<<' '<<Sb<<endl;\n      ans+= dis;\n      \n    }\n    printf(\"%.10f\\n\",ans);\n  }\n\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\nconst int INF = 100000000;\n\nint M,N;\nint X1[100+10], X2[100+10], Y[100+10], Z[100+10], P[200+10];\ndouble ans;\n\ndouble width(int* X, int* YZ, int n, double x){  \n\tdouble lb=INF, ub=-INF;  \n\tfor (int i=0; i<n; i++){  \n\t\tdouble x1=X[i], y1=YZ[i], x2=X[(i+1) % n], y2=YZ[(i+1) % n];  \n\t\tif ((x1-x) * (x2-x) <= 0 && x1 != x2){   \n\t\t\tdouble y=y1 + (y2-y1) * (x-x1) / (x2-x1);  \n\t\t\tlb = min(lb, y);  \n\t\t\tub = max(ub, y);  \n\t\t}  \n\t} \n\treturn max(0.0, ub-lb);  \n}  \n\n\nvoid solve(){\n\tans = 0;\n\tint min1 = *min_element(X1,X1+M);\n\tint min2 = *min_element(X2,X2+N);\n\tint max1 = *max_element(X1,X1+M);\n\tint max2 = *max_element(X1,X2+N);\n\t\n\tsort(P,P+M+N);\n\t\t\n\tfor (int i=0; i<M+N-1; i++){\n\t\tdouble a = P[i];\n\t\tdouble b = P[i+1];\n\t\tdouble c = (a+b)/2;\n\t\tif (min1<=c && min2<=c && c<=max1 && c<=max2){\n\t\t\tdouble fa = width(X1, Y, M, a) * width(X2, Z, N, a);  \n\t\t\tdouble fb = width(X1, Y, M, b) * width(X2, Z, N, b);  \n\t\t\tdouble fc = width(X1, Y, M, c) * width(X2, Z, N, c);\n\t\t\tans += (b-a)/6*(fa+4*fc+fb);\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", ans);\n}\n\nint main() {\n\twhile ((cin >> M >> N) && M && N){\n\t\tfor (int i=0; i<M; i++){\n\t\t\tcin >> X1[i] >> Y[i];\n\t\t\tP[i] = X1[i];\n\t\t}\n\t\tfor (int i=0; i<N; i++){\n\t\t\tcin >> X2[i] >> Z[i];\n\t\t\tP[M+i] = X2[i];\n\t\t}\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\ndouble width(int *x, int *y, int size, double given_x){\n    double max_point = -1000.0, min_point = 1000.0;\n    for(int i = 0; i < size; i++){\n        double x1 = x[i], y1 = y[i], x2 = x[(i+1)%size], y2 = y[(i+1)%size];\n        if((x1-given_x)*(x2-given_x) <= 0 && x1 != x2){\n            double value = (y2-y1) * (given_x-x1) / (x2-x1) + y1; \n            max_point = max(value, max_point);\n            min_point = min(value, min_point);\n        }\n    }\n    return max_point - min_point;\n}\n\nint main(){\n    int m, n;\n    while(cin >> m >> n && m > 0){\n        int xy[100];\n        int y[100];\n        int xz[100];\n        int z[100];\n        int max_xy = -105;\n        int min_xy = 105;\n        for(int i = 0; i < m; i++){\n            cin >> xy[i] >> y[i];\n            max_xy = max(max_xy, xy[i]);\n            min_xy = min(min_xy, xy[i]);\n        }\n        int max_xz = -105;\n        int min_xz = 105;\n        for(int i = 0; i < n; i++){\n            cin >> xz[i] >> z[i];\n            max_xz = max(max_xz, xz[i]);\n            min_xz = min(min_xz, xz[i]);\n        }\n        int xmin = max(min_xy, min_xz);\n        int xmax = min(max_xy, max_xz);\n        vector<int> v;\n        for(int i = 0; i < m; i++) v.push_back(xy[i]);\n        for(int i = 0; i < n; i++) v.push_back(xz[i]);\n        sort(v.begin(), v.end());\n        double ans = 0;\n        for(int i = 0; i < v.size(); i++){\n            double a = v[i], b = v[i+1];\n            if(xmin <= a && a <= xmax && xmin <= b && b <= xmax){\n                double mid = (a + b) / 2.0;\n                double va = width(xy, y, m, a) * width(xz, z, n, a);\n                double vb = width(xy, y, m, b) * width(xz, z, n, b);\n                double vm = width(xy, y, m, mid) * width(xz, z, n, mid);\n                ans += (b-a)/6 * (va + 4*vm + vb);\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\n#include <cmath>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n#define ALL(a)  (a).begin(),(a).end()\n#define REP(i,n) for(int i=0;i<(n);++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n#define dump(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \" << (x) << endl;\n#define dumpv(x) cerr << \"  (L\" << __LINE__ << \") \" << #x << \" = \"; REP(q,(x).size()) cerr << (x)[q] << \" \"; cerr << endl;\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream& s, const pair<T1, T2>& d) {return s << \"(\" << d.first << \",\" << d.second << \")\";}\n\nstatic const int INF = 100000000;\n\ndouble width(const vector<PII>& P, double x) {\n  double lb = INF;\n  double ub = -INF;\n\n  REP(i, P.size()) {\n    int i_next = (i + 1) % P.size();\n    int x1 = P[i].first;\n    int x2 = P[i_next].first;\n    if ((x1 - x) * (x2 - x) <= 0) {\n      int y1 = P[i].second;\n      int y2 = P[i_next].second;\n      double y = y1;\n      if (x2 - x1 != 0) {\n        y = (y1 * (x2 - x) + y2 * (x - x1)) / double(x2 - x1);\n      }\n      lb = min(lb, y);\n      ub = max(ub, y); \n    }\n  }\n\n  return ub - lb;\n}\n\ndouble solve(int M, int N, const vector<PII>& P_XY, const vector<PII>& P_XZ) {\n  int min1 = INF, min2 = INF, max1 = -INF, max2 = -INF;\n  vector<int> xs;\n  REP(i, M) {\n    min1 = min(min1, P_XY[i].first);\n    max1 = max(max1, P_XY[i].first);\n    xs.push_back(P_XY[i].first);\n  }\n  REP(i, N) {\n    min2 = min(min2, P_XZ[i].first);\n    max2 = max(max2, P_XZ[i].first);\n    xs.push_back(P_XZ[i].first);\n  }\n\n  sort(ALL(xs));\n  xs.erase(unique(ALL(xs)), xs.end());\n\n  double res = 0.0;\n\n  for (int i = 0; i+1 < xs.size(); i++) {\n    if (xs[i] >= min1 && xs[i] <= max1 && xs[i] >= min2 && xs[i] <= max2 &&\n        xs[i+1] >= min1 && xs[i+1] <= max1 && xs[i+1] >= min2 && xs[i+1] <= max2) {\n      double a = xs[i];\n      double b = xs[i+1];\n      double c = (a + b) / 2.0;\n      double fa = width(P_XY, a) * width(P_XZ, a);\n      double fb = width(P_XY, b) * width(P_XZ, b);\n      double fc = width(P_XY, c) * width(P_XZ, c);\n\n      res += (b - a) * (fa + fb + 4 * fc) / 6.0;\n    }\n  }\n\n  return res;\n}\n\nint main() {\n  while (true) {\n    int M, N; scanf(\"%d %d\", &M, &N);\n    if (M == 0 && N == 0) break;\n\n    vector<PII> P_XY(M);\n    vector<PII> P_XZ(N);\n    REP(i, M) scanf(\"%d %d\", &P_XY[i].first, &P_XY[i].second);\n    REP(i, N) scanf(\"%d %d\", &P_XZ[i].first, &P_XZ[i].second);\n\n    double ans = solve(M, N, P_XY, P_XZ);\n    printf(\"%.10f\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1<<29;\nconst int MAX_N = 100;\nconst int MAX_M = 100;\n\nint M, N;\nint X1[MAX_M], Y1[MAX_M];\nint X2[MAX_N], Z2[MAX_N];\n\ndouble width(int* X, int* Y, int n, double x) {\n  double lb = INF, ub = -INF;\n  for(int i=0; i<n; i++) {\n    double x1 = X[i], y1 = Y[i], x2 = X[(i+1)%n], y2 = Y[(i+1) % n];\n    \n    if((x1-x)*(x2-x) <= 0 && x1 != x2) {\n      double y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n      \n      lb = min(lb, y);\n      ub = max(ub, y);\n    }\n  }\n  \n  return max(0.0, ub - lb);\n}\n\nvoid solve() {\n  int min1 = *min_element(X1, X1 + M), max1 = *max_element(X1, X1 + M);\n  int min2 = *min_element(X2, X2 + N), max2 = *max_element(X2, X2 + N);\n  \n  vector<int> xs;\n  \n  for(int i=0; i<M; i++) xs.push_back(X1[i]);\n  for(int i=0; i<N; i++) xs.push_back(X2[i]);\n  \n  sort(xs.begin(), xs.end());\n  \n  double res = 0;\n  for(int i=0; i+1<xs.size(); i++) {\n    double a = xs[i], b = xs[i+1], c = (a+b) / 2;\n    if(min1 <= c && c <= max1 && min2 <= c && c <= max2) {\n      double fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n      double fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n      double fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n      res += (b - a) / 6 * (fa + 4 * fc + fb);\n    }\n  }\n  \n  printf(\"%.10f\\n\", res);\n}\n\nint main() {\n  \n  while(cin >> M >> N && (M|N)) {\n    for(int i=0; i<M; i++) cin >> X1[i] >> Y1[i];\n    for(int i=0; i<N; i++) cin >> X2[i] >> Z2[i];\n    \n    solve();\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>  \n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\nconst int INF = 100000000;\n\nint M,N;\nint X1[100+10], X2[100+10], Y[100+10], Z[100+10], P[200+10];\ndouble ans;\n\ndouble width(int* X, int* YZ, int n, double x){  \n\tdouble lb=INF, ub=-INF;  \n\tfor (int i=0; i<n; i++){  \n\t\tdouble x1=X[i], y1=YZ[i], x2=X[(i+1) % n], y2=YZ[(i+1) % n];  \n\t\tif ((x1-x) * (x2-x) <= 0 && x1 != x2){   \n\t\t\tdouble y=y1 + (y2-y1) * (x-x1) / (x2-x1);  \n\t\t\tlb = min(lb, y);  \n\t\t\tub = max(ub, y);  \n\t\t}  \n\t} \n\treturn max(0.0, ub-lb);  \n}  \n\n\nvoid solve(){\n\tans = 0.0;\n\tint min1 = *min_element(X1,X1+M);\n\tint min2 = *min_element(X2,X2+N);\n\tint max1 = *max_element(X1,X1+M);\n\tint max2 = *max_element(X1,X2+N);\n\t\n\tsort(P,P+M+N);\n\t\t\n\tfor (int i=0; i<M+N-1; i++){\n\t\tdouble a = P[i];\n\t\tdouble b = P[i+1];\n\t\tdouble c = (a+b)/2;\n\t\tif (min1<=c && min2<=c && c<=max1 && c<=max2){\n\t\t\tdouble fa = width(X1, Y, M, a) * width(X2, Z, N, a);  \n\t\t\tdouble fb = width(X1, Y, M, b) * width(X2, Z, N, b);  \n\t\t\tdouble fc = width(X1, Y, M, c) * width(X2, Z, N, c);\n\t\t\tans += (b-a)/6*(fa+4*fc+fb);\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", ans);\n}\n\nint main() {\n\twhile ((cin >> M >> N) && M && N){\n\t\tfor (int i=0; i<M; i++){\n\t\t\tcin >> X1[i] >> Y[i];\n\t\t\tP[i] = X1[i];\n\t\t}\n\t\tfor (int i=0; i<N; i++){\n\t\t\tcin >> X2[i] >> Z[i];\n\t\t\tP[M+i] = X2[i];\n\t\t}\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ndouble eps = 1e-9;\nvector<P> ps1,ps2;\nbool eq(double a,double b){\n\treturn fabs(a-b) < eps;\n}\n\nvector<double> ux;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\npair<double,double> seg(const vector<P> &ps,double x){\n\tdouble mi = 1e9, ma = -1e9;\n\tauto reflesh = [&mi,&ma](double y){\n\t\tmi = min(mi,y);\n\t\tma = max(ma,y);\n\t};\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tP a = ps[i];\n\t\tP b = ps[(i+1)%ps.size()];\n\t\tif( a.real() > b.real() ) swap(a,b);\n\t\tif( eq(a.real(),x) ) reflesh(a.imag());\n\t\tif( eq(b.real(),x) ) reflesh(b.imag());\n\t\tif( a.real() + eps < x and x < b.real() - eps ){\n\t\t\treflesh(a.imag() + (x - a.real()) * (b.imag() - a.imag()) / (b.real()-a.real()));\n\t\t}\n\t}\n\tif( ma < mi ) return {0.0,0.0};\n\treturn {mi,ma};\n}\n\ndouble Sf(double x){\n\tauto p = seg(ps1,x);\n\treturn p.second - p.first;\n}\n\ndouble Ss(double l,double r){\n\treturn (r-l)/6*(Sf(l)+4*Sf((l+r)/2)+Sf(r));\n}\n\ndouble S2(double l,double r,int k=0){\n\tif( r < l ) return 0;\n\tdouble m = (l+r)/2;\n\tdouble a = Ss(l,m);\n\tdouble b = Ss(m,r);\n\tdouble c = Ss(l,r);\n\tif( k <= 0 and eq(a+b,c) ){\n\t\t//cout << a+b << \" \" << c << endl;\n\t\treturn c;\n\t}else{\n\t\treturn S2(l,m,k-1) + S2(m,r,k-1);\n\t}\t\n}\ndouble S(double l,double r){\n\tdouble sans = 0;\n\tfor(int i = 0 ; i+1 < ux.size() ; i++){\n\t\tif( ux[i] != ux[i+1] ){\n\t\t\tsans += S2(max(l,ux[i]),min(r,ux[i+1]));\n\t\t}\n\t}\n\t//cout << sans << endl;\n\treturn sans;\n\t\n}\n\ndouble Vf(double z){\n\tauto p = seg(ps2,z);\n\treturn S(p.first,p.second);\n}\n\ndouble Vs(double l,double r){\n\treturn (r-l)/6*(Vf(l)+4*Vf((l+r)/2)+Vf(r));\n}\n\ndouble V(double l,double r,int k=0){\n\tdouble m = (l+r)/2;\n\tdouble a = Vs(l,m);\n\tdouble b = Vs(m,r);\n\tdouble c = Vs(l,r);\n\tif( k <= 0 and eq(a+b,c) ){\n\t\treturn c;\n\t}else{\n\t\treturn V(l,m,k-1) + V(m,r,k-1);\n\t}\t\n}\n\nint main(){\n\tint m,n;\n\twhile(cin >> m >> n && m ){\n\t\t\n\t\tps1.clear();\n\t\tps2.clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tps1.push_back(in());\n\t\t\tux.push_back(ps1.back().real());\n\t\t}\n\n\t\tvector<double> uz;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tps2.push_back(in());\n\t\t\tps2.back() = P(ps2.back().imag(),ps2.back().real());\n\t\t\tuz.push_back(ps2.back().real());\n\t\t}\n\t\tsort(uz.begin(),uz.end());\n\t\tsort(ux.begin(),ux.end());\n\t\tdouble vans = 0;\n\t\t//for( auto z : uz ) cout << z << \" \"; cout << endl;\n\t\t//for( auto x : ux ) cout << x << \" \"; cout << endl;\n\t\tfor(int i = 0 ; i+1 < uz.size() ; i++)\n\t\t\tif( uz[i] != uz[i+1] )\n\t\t\t\tvans += V(uz[i],uz[i+1]);\n\t\tprintf(\"%.10lf\\n\",vans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <string.h>\n#include <vector>\n#include <map>\n#include <math.h>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define ll long long\n#define ull unsigned ll\n#define db double\n#define INF 0x3f3f3f3f\n#define MOD 1000000007\n#define PII pair<int, int>\n\nconst int N=105;\nint n,m;\nint X1[N],Y1[N],X2[N],Z2[N];\n\ndb width(int* x,int *y,int n,db xx) {\n    db lb=INF,ub=-INF;\n    for (int i=0;i<n;i++) {\n        db xx1=x[i],yy1=y[i],xx2=x[(i+1)%n],yy2=y[(i+1)%n];\n        if ((xx1-xx)*(xx2-xx)<=0&&xx1!=xx2) {\n            db yy=yy1+(yy2-yy1)*(xx-xx1)/(xx2-xx1);\n            lb=min(lb,yy);\n            ub=max(ub,yy);\n        }\n    }\n    return max(0.0,ub-lb);\n}\n\nint main()\n{\n    while (true) {\n        scanf(\"%d%d\",&m,&n);\n        if (m==0&&n==0) break;\n        for (int i=0;i<m;i++) { scanf(\"%d%d\",X1+i,Y1+i); }\n        for (int i=0;i<n;i++) { scanf(\"%d%d\",X2+i,Z2+i); }\n        int mn1=*min_element(X1,X1+m),mx1=*max_element(X1,X1+m);\n        int mn2=*min_element(X2,X2+n),mx2=*max_element(X2,X2+n);\n        vector<int> xs;\n        for (int i=0;i<m;i++) xs.pb(X1[i]);\n        for (int i=0;i<n;i++) xs.pb(X2[i]);\n        sort(xs.begin(),xs.end());\n        db ans=0.0;\n        for (int i=0;i+1<xs.size();i++) {\n            db a=xs[i],b=xs[i+1],c=(a+b)/2;\n            if (mn1<=c&&c<=mx1&&mn2<=c&&c<=mx2) {\n                db fa=width(X1,Y1,m,a)*width(X2,Z2,n,a);\n                db fb=width(X1,Y1,m,b)*width(X2,Z2,n,b);\n                db fc=width(X1,Y1,m,c)*width(X2,Z2,n,c);\n                ans+=(b-a)/6*(fa+4*fc+fb);\n            }\n        }\n        printf(\"%.10lf\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst double EPS = 1e-8;\ntypedef pair<long double, long double> P;\nvector<P> vp1;\nvector<P> vp2;\n\nlong double width(long double x, const vector<P>& v){\n    long double top = -1e8, bottom = 1e8;\n    REP(i, v.size()){\n        P p1 = v[i], p2 = v[(i + 1) % v.size()];\n        if(abs(p1.first - p2.first) < EPS){\n            if(abs(p1.first - x) < EPS){\n                top = max(top, p1.second);\n                top = max(top, p2.second);\n                bottom = min(bottom, p1.second);\n                bottom = min(bottom, p2.second);\n            }\n            continue;\n        }\n        if(p1.first > p2.first) swap(p1, p2);\n        if(p1.first - EPS < x && x < p2.first + EPS){\n            long double ratio = (x - p1.first) / (p2.first - p1.first);\n            long double y = p1.second + ratio * (p2.second - p1.second);\n            top = max(top, y);\n            bottom = min(bottom, y);\n        }\n    }\n    return max(0.0L, top - bottom);\n}\nlong double f(long double x){\n    long double w = width(x, vp1) * width(x, vp2);\n    return w;\n}\n\nlong double simpson(long double l, long double r, int N){\n    long double h = (r - l) / (2 * N); \n    long double S = f(l) + f(r);\n    for(int i = 1; i < 2 * N; i += 2){\n        S += 4.0 * f(l + h * i);\n    }\n    for(int i = 2; i < 2 * N; i += 2){\n        S += 2.0 * f(l + h * i);\n    }\n    return S * h / 3.0;\n}\n\n\nint main(){\n    int M, N;\n    while(cin >> M >> N && M){\n        vp1.resize(M);\n        vp2.resize(N);\n        REP(i, M) cin >> vp1[i].first >> vp1[i].second;\n        REP(i, N) cin >> vp2[i].first >> vp2[i].second;\n        long double left1 = vp1[0].first, right1 = vp1[0].first;\n        long double left2 = vp2[0].first, right2 = vp2[0].first;\n        REP(i, M) left1 = min(left1, vp1[i].first);\n        REP(i, N) left2 = min(left2, vp2[i].first);\n        REP(i, M) right1 = max(right1, vp1[i].first);\n        REP(i, N) right2 = max(right2, vp2[i].first);\n        long double S = simpson(max(left1, left2), min(right1, right2), 100000);\n        printf(\"%.16Lf\\n\", S);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint m,n;\nconst double EPS = 1e-11;\nvector<pair<int,int> > Pxy,Pxz;\npair<int,int> tem;\nvector<int> X;\n\n\ndouble width(vector<pair<int,int> > polygon,double x){\n    vector<double> w;\n    for(int i=0;i<polygon.size();i++){\n        pair<int,int> p=polygon[i];\n        pair<int,int> q=polygon[(i+1)%polygon.size()];\n        if(abs(p.first-x)<EPS){\n            w.push_back(1.0*p.second);\n        }\n        else if( (p.first<x && x<q.first)|| (p.first>0 && x>q.first)){\n            int x0=p.first;\n            int y0=p.second;\n            int x1=q.first;\n            int y1=q.second;\n            w.push_back(y0+1.0*(y1-y0)*(x-x0)/(x1-x0));\n        }\n    }\n    assert(w.size()>0);\n    sort(w.begin(), w.end());\n    return w[w.size()-1] - w[0];\n}\n\nint volume(vector<pair<int,int> >Pxy,vector<pair<int,int> >Pxz,vector<int> X){\n    double total=0.0;\n    int xmin = max((*min_element(Pxy.begin(), Pxy.end())).first,\n                   (*min_element(Pxz.begin(), Pxz.end())).first);\n    int xmax = min((*max_element(Pxy.begin(), Pxy.end())).first,\n                   (*max_element(Pxz.begin(), Pxz.end())).first);\n    sort(X.begin(), X.end());\n    for(int i=0;i<X.size()-1;i++){\n        int a=X[i];\n        int b=X[i+1];\n        if(!(xmin <= a && a <= xmax &&xmin <= b && b<= xmax) ){\n            continue;\n        }\n        double m=(a+b)/2.0;\n        double va = width(Pxy, a)*width(Pxz, a);\n        double vb = width(Pxy, b)*width(Pxz, b);\n        double vm = width(Pxy, m)*width(Pxz, m);\n        double area=((b-a)/6.0)*(va + 4.0*vm + vb);\n        total+=area;\n    }\n    return total;\n}\nint main(){\n    while(cin>>m>>n&&n!=0){\n        for(int i=1;i<=m;i++){\n            cin>>tem.first>>tem.second;\n            Pxy.push_back(tem);\n            X.push_back(tem.first);\n        }\n        for(int j=1;j<=n;j++){\n            cin>>tem.first>>tem.second;\n            Pxz.push_back(tem);\n            X.push_back(tem.first);\n        }\n        cout << fixed << volume(Pxy, Pxz, X) << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <list>\n#include <string.h>\nusing namespace std;\ntypedef long long int ll; typedef pair <int, int> P;\nconst double INF = 1000000000; const double EPS = 10e-9;\nint x1[100], y[100], x2[100], z[100];\ndouble width(int *X, int *Y, int n, double x) {\n\tdouble lb = -INF, ub = INF;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x1 = X[i], x2 = X[(i + 1) % n], y1 = Y[i], y2 = Y[(i + 1) % n];\n\t\tif ((x1 - x) * (x2 - x) > 0 || x1 == x2) continue;\n\t\tdouble y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n\t\tlb = max(lb, y);\n\t\tub = min(ub, y);\n\t}\n\treturn lb - ub;\n}\nint main()\n{\n\twhile (true)\n\t{\n\t\tvector <int> x;\n\t\tint m, n; cin >> m >> n;\n\t\tif (m == 0 && n == 0) break;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x1[i] >> y[i];\n\t\t\tx.push_back(x1[i]);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x2[i] >> z[i];\n\t\t\tx.push_back(x2[i]);\n\t\t}\n\t\tint minx1 = *min_element(x1, x1 + m), maxx1 = *max_element(x1, x1 + m);\n\t\tint minx2 = *min_element(x2, x2 + n), maxx2 = *max_element(x2, x2 + n);\n\t\tsort(x.begin(), x.end());\n\t\tdouble res = 0.0;\n\t\tfor (int i = 0; i + 1 < m + n; i++)\n\t\t{\n\t\t\tdouble a = x[i], b = x[i + 1], c = (a + b) / 2;\n\t\t\tif (minx1 < c && c < maxx1 && minx2 < c && c < maxx2)\n\t\t\t{\n\t\t\t\tdouble sa = width(x1, y, m, a) * width(x2, z, n, a);\n\t\t\t\tdouble sb = width(x1, y, m, b) * width(x2, z, n, b);\n\t\t\t\tdouble sc = width(x1, y, m, c) * width(x2, z, n, c);\n\t\t\t\tres += (b - a) / 6 * (sa + sb + 4 * sc);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10f\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e12;\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\n\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return (a.X!=b.X) ? a.X<b.X : a.Y<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\nint ccw(P a, P b, P c){\n    b -= a;\n    c -= a;\n    if(cross(b,c) > EPS) return +1; //ccw\n    if(cross(b,c) < -EPS) return -1; //cw\n    if(dot(b,c) < -EPS) return +2; //c-a-b\n    if(abs(c)-abs(b) > EPS) return -2; //a-b-c\n    return 0; //a-c-b\n}\n\nbool intersectLS(const L& l, const L& s){\n    return cross(l[1]-l[0], s[0]-l[0])*\n        cross(l[1]-l[0], s[1]-l[0]) < EPS;\n}\n\nbool isParallel(const P &a, const P &b){\n    return abs(cross(a,b)) < EPS;\n}\nbool isParallel(const L &a, const L &b){\n    return isParallel(a[1]-a[0], b[1]-b[0]);\n}\nP crosspointLL(const L &l, const L &m) {\n  double A = cross(l[1]-l[0], m[1]-m[0]);\n  double B = cross(l[1]-l[0], l[1]-m[0]);\n  return m[0] + B/A *(m[1]-m[0]);\n}\n\ndouble getarea(const VP &poly){\n    double ret = 0;\n    for (int i=0; i<(int)poly.size(); i++){ \n        ret += cross(poly[i], poly[(i+1)%poly.size()]);\n    }\n    return ret*0.5;\n}\n\nVP convex_cut(const VP& p, const L& l){\n    VP ret;\n    int n = p.size();\n    for(int i=0; i<n; i++){\n        P curr = p[i];\n        P next = p[(i+1)%n];\n        if(ccw(l[0], l[1], curr) != -1) ret.push_back(curr);\n        if(ccw(l[0], l[1], curr) *ccw(l[0], l[1], next) == -1){\n            ret.push_back(crosspointLL(L(curr, next), l));\n        }\n    }\n    return ret;\n}\n\nstruct c2cut{\n    double z, x[2];\n    c2cut(double z, double xmin, double xmax):z(z),x{xmin, xmax}{}\n    c2cut(){}\n    bool operator <(const c2cut &a){\n        return z < a.z;\n    }\n    bool operator ==(const c2cut &a){\n        return z == a.z;\n    }\n};\n\nint main(){\n    while(1){\n        int m,n;\n        cin >> m >> n;\n        if(n==0) break;\n        \n        VP c1(m), c2(n);\n        for(int i=0; i<m; i++){\n            double x,y;\n            cin >> x >> y;\n            c1[i] = P(x, y);\n        }\n        for(int i=0; i<n; i++){\n            double x,z;\n            cin >> x >> z;\n            c2[i] = P(x, z);\n        }\n        \n        vector<c2cut> cz(n);\n        for(int i=0; i<n; i++){\n            double z = c2[i].Y;\n            L cutline(P(0, z), P(1, z));\n            vector<double> cpx;\n            for(int i=0; i<n; i++){\n                L edge(c2[i], c2[(i+1)%n]);\n                if(!isParallel(cutline, edge) && intersectLS(cutline, edge)){\n                    cpx.push_back((crosspointLL(cutline, edge)).X);\n                }\n            }\n            double xmin = *min_element(cpx.begin(), cpx.end());\n            double xmax = *max_element(cpx.begin(), cpx.end());\n            cz[i] = c2cut(z, xmin, xmax);\n        }\n        sort(cz.begin(), cz.end());\n        cz.erase(unique(cz.begin(), cz.end()), cz.end());\n\n        double ans = 0;\n        for(int i=0; i<(int)cz.size()-1; i++){\n            vector<double> zdiff;\n            for(int d=0; d<2; d++){\n                double x[2] = {cz[i].x[d], cz[i+1].x[d]};\n                if(abs(x[1]-x[0]) < EPS) continue;\n                if(x[0] > x[1]) swap(x[0], x[1]);\n                L cut[2] = {L(P(x[1], 0), P(x[1], 1)), L(P(x[0], 1), P(x[0], 0))};\n                VP p = convex_cut(c1, cut[0]);\n                p = convex_cut(p, cut[1]);\n                for(int j=0; j<(int)p.size(); j++){\n                    double xdiff = abs(p[j].X -cz[i].x[d]);\n                    zdiff.push_back((cz[i+1].z -cz[i].z) *xdiff/(x[1]-x[0]));\n                }\n            }\n            for(int d=0; d<2; d++){\n                int xmax = cz[i+d].x[1];\n                int xmin = cz[i+d].x[0];\n                L cut[2] = {L(P(xmax, 0), P(xmax, 1)), L(P(xmin, 1), P(xmin, 0))};\n                VP p = convex_cut(c1, cut[0]);\n                p = convex_cut(p, cut[1]);\n                if(!p.empty()){\n                    zdiff.push_back((cz[i+1].z -cz[i].z) *d);\n                }\n            }\n            sort(zdiff.begin(), zdiff.end());\n            zdiff.erase(unique(zdiff.begin(), zdiff.end()), zdiff.end());\n\n            for(int j=0; j<(int)zdiff.size()-1; j++){\n                double z[3];\n                z[0] = cz[i].z +zdiff[j];\n                z[2] = cz[i].z +zdiff[j+1];\n                z[1] = (z[0] +z[2])/2;\n                double area[3];\n                for(int k=0; k<3; k++){\n                    L cutline(P(0, z[k]), P(1, z[k]));\n                    vector<double> cpx;\n                    for(int i=0; i<n; i++){\n                        L edge(c2[i], c2[(i+1)%n]);\n                        if(!isParallel(cutline, edge) && intersectLS(cutline, edge)){\n                            cpx.push_back((crosspointLL(cutline, edge)).X);\n                        }\n                    }\n                    double xmin = *min_element(cpx.begin(), cpx.end());\n                    double xmax = *max_element(cpx.begin(), cpx.end());\n                    L cut[2] = {L(P(xmax, 0), P(xmax, 1)), L(P(xmin, 1), P(xmin, 0))};\n                    VP con = convex_cut(c1, cut[0]);\n                    con = convex_cut(con, cut[1]);\n                    area[k] = getarea(con);\n                }\n                ans += (z[2] -z[0])/6 *(area[0] +4*area[1] +area[2]);\n            }\n        }\n\n        cout << fixed << setprecision(10);\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define MAX_M 100\n#define MAX_N 100\n#define INF (1<<20)\n\nint M,N;\nint X1[MAX_M], Y1[MAX_M];\nint X2[MAX_N], Z2[MAX_N];\n\n// 多角形をxでスライスしたときの幅を返す\ndouble width(int* X, int* Y, int n, double x) {\n    double lb = INF, ub = -INF;\n    for(int i=0;i<n;i++) {\n        double x1 = X[i], y1 = Y[i], x2 = X[(i + 1) % n], y2 = Y[(i + 1) % n];\n        // i番目の辺と交点を持つか調べる\n        if ((x1 - x) * (x2 - x) <= 0 && x1 != x2) {\n            // 交点の座標を計算\n            double y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n            //double y = y1 + (y2 - y1) * x / (x2 - x1);\n            lb = min(lb, y);\n            ub = max(ub, y);\n        }\n    }\n    return max(0.0, ub - lb);\n}\n\nvoid solve() {\n    int min1 = *min_element(X1, X1 + M), max1 = *max_element(X1, X1 + M);\n    int min2 = *min_element(X2, X2 + N), max2 = *max_element(X2, X2 + N);\n    vector<int> xs;\n    for(int i=0;i<M;i++) xs.push_back(X1[i]);\n    for(int i=0;i<N;i++) xs.push_back(X2[i]);\n    sort(xs.begin(), xs.end());\n\n    double res = 0;\n    for(int i=0;i+1<xs.size();i++) {\n        double a = xs[i], b = xs[i+1], c=(a+b)/2;\n        // 重なっている\n        if(min1 <= c && c <= max1 && min2 <=c && c <= max2) {\n            // シンプソンの公式で積分する\n            double fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n            double fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n            double fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n            res += (b - a) / 6 * (fa + 4 * fc + fb);\n        }\n    }\n    printf(\"%.10f\\n\", res);\n}\n\nmain() {\n    while(scanf(\"%d %d\",&M,&N), M!=0) {\n        for(int i=0;i<M;i++) scanf(\"%d %d\",&X1[i], &Y1[i]);\n        for(int i=0;i<N;i++) scanf(\"%d %d\", &X2[i] ,&Z2[i]);\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst double INF = 1e300;\n\nconst int N = 100 + 5;\n\nstruct Point {\n  double x, y;\n};\n\nPoint C1[N], C2[N];\n\ndouble width(const Point c[], int n, double x) {\n  double y_min = INF, y_max = -INF;\n  for (int i = 0; i < n; ++i) {\n    int j = (i + 1) % n;\n    double x1 = c[i].x, y1 = c[i].y, x2 = c[j].x, y2 = c[j].y;\n    if (x1 != x2 && (x1 - x) * (x2 - x) <= 0.0) {\n      double y = y1 + (x - x1) / (x2 - x1) * (y2 - y1);\n      y_min = min(y_min, y);\n      y_max = max(y_max, y);\n    }\n  }\n  return max(0.0, y_max - y_min);\n}\n\nint main() {\n#ifdef DEBUG\n  freopen(\"in.txt\", \"r\", stdin);\n#endif\n\n  int n, m;\n  while (scanf(\"%d%d\", &n, &m) != EOF && n && m) {\n    vector<double> xs;\n    double min_x1 = INF, max_x1 = -INF, min_x2 = INF, max_x2 = -INF;\n\n    for (int i = 0; i < n; ++i) {\n      scanf(\"%lf%lf\", &C1[i].x, &C1[i].y);\n      xs.push_back(C1[i].x);\n      min_x1 = min(min_x1, C1[i].x);\n      max_x1 = max(max_x1, C1[i].x);\n    }\n\n    for (int i = 0; i < m; ++i) {\n      scanf(\"%lf%lf\", &C2[i].x, &C2[i].y);\n      xs.push_back(C2[i].x);\n      min_x2 = min(min_x2, C2[i].x);\n      max_x2 = max(max_x2, C2[i].x);\n    }\n\n    sort(xs.begin(), xs.end());\n\n    double V = 0.0;\n    for (size_t i = 0; i + 1 < xs.size(); ++i) {\n      double a = xs[i], b = xs[i + 1], c = (a + b) / 2.0;\n      if ((min_x1 <= c && c <= max_x1) &&\n          (min_x2 <= c && c <= max_x2)) {\n        double fa = width(C1, n, a) * width(C2, m, a);\n        double fb = width(C1, n, b) * width(C2, m, b);\n        double fc = width(C1, n, c) * width(C2, m, c);\n        V += (b - a) / 6 * (fa + 4 * fc + fb);\n      }\n    }\n    printf(\"%.10f\\n\", V);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <limits>\n#include <cmath>\nusing namespace std;\n\nconst int kInf = numeric_limits< int >::max() / 2;\nconst double kEps = 1e-10;\nconst double kErr = 1e-8;\nconst int kLim = 24;\n\nint N, M;\nint Xi1[110], Yi[110], Xi2[110], Zi[110];\nint min1, max1, min2, max2;\n\ndouble dx1[110][2], dx2[110][2], dy[110][2], dz[110][2];\n\nvoid read();\nvoid solve();\ndouble adaptive_simpson(double, double);\ndouble adaptive_simpson(double, double, double, double, double, double, double, int);\ndouble find_area(double);\n\ninline double simpson(double h, double fa, double fb, double fc) {\n  return (fa + 4 * fc + fb) * h / 6;\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cout.setf(ios::fixed), cout.precision(10);\n  while (cin >> N >> M, N + M) {\n    read();\n    solve();\n  }\n\n  return 0;\n}\n\nvoid read() {\n  for (int i = 0; i < N; ++i)\n    cin >> Xi1[i] >> Yi[i];\n  for (int i = 0; i < M; ++i)\n    cin >> Xi2[i] >> Zi[i];\n  Xi1[N] = Xi1[0], Yi[N] = Yi[0], Xi2[M] = Xi2[0], Zi[M] = Zi[0];\n\n  for (int i = 0; i < N; ++i) {\n    if (Xi1[i] < Xi1[i + 1])\n      dx1[i][0] = Xi1[i], dy[i][0] = Yi[i], dx1[i][1] = Xi1[i + 1], dy[i][1] = Yi[i + 1];\n    else\n      dx1[i][1] = Xi1[i], dy[i][1] = Yi[i], dx1[i][0] = Xi1[i + 1], dy[i][0] = Yi[i + 1];\n  }\n\n  for (int i = 0; i < M; ++i) {\n    if (Xi2[i] < Xi2[i + 1])\n      dx2[i][0] = Xi2[i], dz[i][0] = Zi[i], dx2[i][1] = Xi2[i + 1], dz[i][1] = Zi[i + 1];\n    else\n      dx2[i][1] = Xi2[i], dz[i][1] = Zi[i], dx2[i][0] = Xi2[i + 1], dz[i][0] = Zi[i + 1];\n  }\n}\n\nvoid solve() {\n  min1 = min2 = kInf, max1 = max2 = -kInf;\n  for (int i = 0; i < N; ++i)\n    min1 = min(min1, Xi1[i]), max1 = max(max1, Xi1[i]);\n  for (int i = 0; i < M; ++i)\n    min2 = min(min2, Xi2[i]), max2 = max(max2, Xi2[i]);\n\n  double res = adaptive_simpson(double(max(min1, min2)), double(min(max1, max2)));\n  cout << res << \"\\n\";\n}\n\ndouble adaptive_simpson(double a, double b) {\n  if (a < b) {\n    double h = b - a, c = (a + b) / 2;\n    double fa = find_area(a), fb = find_area(b), fc = find_area(c);\n    return adaptive_simpson(a, b, simpson(h, fa, fb, fc), fa, fb, fc, kErr, kLim);\n  }\n  else\n    return 0;\n}\n\ndouble adaptive_simpson(double a, double b, double s,\n                        double fa, double fb, double fc, double err, int t) {\n  double c = (a + b) / 2, h = (b - a) / 2;\n  double fd = find_area((a + c) / 2), fe = find_area((c + b) / 2);\n  double s1 = simpson(h, fa, fc, fd);\n  double s2 = simpson(h, fc, fb, fe);\n\n  if (t <= 0 || abs(s1 + s2 - s) < 15 * err)\n    return (s1 + s2) + (s1 + s2 - s) / 15;\n  return  adaptive_simpson(a, c, s1, fa, fc, fd, err / 2, t - 1) +\n          adaptive_simpson(c, b, s2, fc, fb, fe, err / 2, t - 1);\n}\n\ndouble find_area(double x) {\n  double miny = double(kInf), maxy = double(-kInf);\n  double minz = double(kInf), maxz = double(-kInf);\n  double ty, tz;\n\n  for (int i = 0; i < N; ++i)\n    if (dx1[i][0] < x + kEps && x < dx1[i][1] + kEps) {\n      ty = dy[i][0] + (dy[i][1] - dy[i][0]) * (x - dx1[i][0]) / (dx1[i][1] - dx1[i][0]);\n      miny = min(miny, ty), maxy = max(maxy, ty);\n    }\n\n  for (int i = 0; i < M; ++i)\n    if (dx2[i][0] < x + kEps && x < dx2[i][1] + kEps) {\n      tz = dz[i][0] + (dz[i][1] - dz[i][0]) * (x - dx2[i][0]) / (dx2[i][1] - dx2[i][0]);\n      minz = min(minz, tz), maxz = max(maxz, tz);\n    }\n\n  return (maxy - miny) * (maxz - minz);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nusing ld = double;\nusing Point =  complex<ld>;\nconst ld eps = 1e-7;\nconst ld pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n//内積\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\n//外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\n\nbool cmp(Point x,Point y){\n\tif(eq(x.real(),y.real()))return x.imag()<y.imag();\n\treturn x.real()<y.real();\n}\n//線分\n//直線にするなら十分通い２点を端点とすればよい\nclass Line {\npublic:\n\tPoint a, b;\n};\n//円\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n//3点の位置関係\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps)return 1;//a,b,cが反時計回り\n\tif (cross(b, c) < -eps)return -1;//a,b,cが時計回り\n\tif (dot(b, c) < 0)return 2;//c,a,bの順に一直線\n\tif (norm(b) < norm(c))return -2;//a,b,cの順に一直線\n\treturn 0;//a,c,bの順に一直線\n}\n//2直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n//直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < eps);\n}\n//点が直線上に存在するか\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n//点が線分上に存在するか\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n//線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\tif (isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a) || isis_sp(t, s.b))return true;\n\treturn(cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps && cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\n//点から直線への垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n//直線と直線の交点\n//平行な２直線に対しては使うな！！！！\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a; Point tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n//直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n//直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n//線分と直線の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n//線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(p - r) : min(abs(p - s.a), abs(p - s.b));\n}\n//線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t))return 0;\n\treturn min({ dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b) });\n}\n\nvector<Point> convex_hull(vector<Point>& a,int sgn){\n\tvector<Point> ret;\n\tint n=a.size();\n\tint k=0;\n\trep(i,n){\n\t\twhile(k>1 && ccw(ret[k-2],ret[k-1],a[i])!=sgn){\n\t\t\tret.pop_back();\n\t\t\t--k;\n\t\t}\n\t\t++k;\n\t\tret.push_back(a[i]);\n\t}\n\treturn ret;\n}\n\ndouble calc(vector<Point>& a,double x){\n\tauto itr = upper_bound(a.begin(),a.end(),Point(x,inf),cmp);\n\tif(itr==a.end()){\n\t\t--itr;\n\t\twhile(itr->real()==x)--itr;\n\t\tif(next(itr)!=a.end())++itr;\n\t\treturn itr->imag();\n\t}\n\tif(itr==a.begin()){\n\t\treturn itr->imag();\n\t}\n\tdouble rx=itr->real(), ry=itr->imag();\n\t--itr;\n\tdouble lx=itr->real(),ly = itr->imag();\n\tif(rx==lx)return ry;\n\treturn ly + (x-lx)/(rx-lx)*(ry-ly);\n}\n\nvoid solve(int n,int m){\n\tvector<Point> a(n),b(m);\n\tvector<double> v;\n\tdouble mi,ma;\n\tdouble mi1=inf,ma1=-inf,mi2=inf,ma2=-inf;\n\trep(i,n){\n\t\tdouble x,y;\n\t\tcin>>x>>y;\n\t\tmi1=min(x,mi1);\n\t\tma1=max(ma1,x);\n\t\tv.push_back(x);\n\t\ta[i]=Point(x,y);\n\t}\n\trep(i,m){\n\t\tdouble x,y;\n\t\tcin>>x>>y;\n\t\tmi2=min(x,mi2);\n\t\tma2=max(ma2,x);\n\t\tv.push_back(x);\n\t\tb[i]=Point(x,y);\n\t}\n\tmi=max(mi1,mi2);ma=min(ma1,ma2);\n\tsort(a.begin(),a.end(),[](Point x,Point y){\n\t\treturn x.real()==y.real() ? x.imag()<y.imag() : x.real()<y.real();\n\t});\n\tsort(b.begin(),b.end(),[](Point x,Point y){\n\t\treturn x.real()==y.real() ? x.imag()<y.imag() : x.real()<y.real();\n\t});\n\tvector<Point> u,d,l,r;\n\td=convex_hull(a,1);\n\tu=convex_hull(a,-1);\n\tl=convex_hull(b,1);\n\tr=convex_hull(b,-1);\n\tsort(v.begin(),v.end());\n\tdouble ans=0;\n\tint s=v.size();\n\trep(i,s-1){\n\t\tif(v[i]<mi||v[i+1]>ma)continue;\n\t\tdouble sum = (calc(u,v[i])-calc(d,v[i]))*(calc(r,v[i])-calc(l,v[i]));\n\t\tsum += 4*(calc(u,.5*(v[i]+v[i+1]))-calc(d,.5*(v[i]+v[i+1])))*(calc(r,.5*(v[i]+v[i+1]))-calc(l,.5*(v[i]+v[i+1])));\n\t\tsum += (calc(u,v[i+1])-calc(d,v[i+1]))*(calc(r,v[i+1])-calc(l,v[i+1]));\n\t\tans += 1.0/6.0 * (v[i+1]-v[i]) * sum;\n\t}\n\tcout<<setprecision(12)<<ans<<endl;\n}\nint main(){\n\tint n,m;\n\twhile(cin>>n>>m,n!=0){\n\t\tsolve(n,m);\n\t}\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef double dbl;\n#define double long double\ntypedef complex<double> P;\n\ndouble eps = 1e-11;\nvector<P> ps1,ps2;\nbool eq(double a,double b){\n\treturn fabs(a-b) < eps;\n}\n\nvector<double> ux;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\npair<double,double> seg(const vector<P> &ps,double x){\n\tdouble mi = 1e9, ma = -1e9;\n\tauto reflesh = [&mi,&ma](double y){\n\t\tmi = min(mi,y);\n\t\tma = max(ma,y);\n\t};\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tP a = ps[i];\n\t\tP b = ps[(i+1)%ps.size()];\n\t\tif( a.real() > b.real() ) swap(a,b);\n\t\tif( eq(a.real(),x) ) reflesh(a.imag());\n\t\tif( eq(b.real(),x) ) reflesh(b.imag());\n\t\tif( a.real() + eps < x and x < b.real() - eps ){\n\t\t\treflesh(a.imag() + (x - a.real()) * (b.imag() - a.imag()) / (b.real()-a.real()));\n\t\t}\n\t}\n\tif( ma < mi ) return {0.0,0.0};\n\treturn {mi,ma};\n}\n\ndouble Sf(double x){\n\tauto p = seg(ps1,x);\n\treturn p.second - p.first;\n}\n\ndouble Ss(double l,double r){\n\treturn (r-l)/6*(Sf(l)+4*Sf((l+r)/2)+Sf(r));\n}\n\ndouble S2(double l,double r,int k=5){\n\tif( r < l ) return 0;\n\tdouble m = (l+r)/2;\n\tdouble a = Ss(l,m);\n\tdouble b = Ss(m,r);\n\tdouble c = Ss(l,r);\n\tif( (c>eps or k <= 0) and eq(a+b,c) ){\n\t\t//cout << a+b << \" \" << c << endl;\n\t\treturn c;\n\t}else{\n\t\treturn S2(l,m,k-1) + S2(m,r,k-1);\n\t}\t\n}\ndouble S(double l,double r){\n\tdouble sans = 0;\n\tfor(int i = 0 ; i+1 < ux.size() ; i++){\n\t\tif( ux[i] != ux[i+1] ){\n\t\t\tsans += S2(max(l,ux[i]),min(r,ux[i+1]));\n\t\t}\n\t}\n\t//cout << sans << endl;\n\treturn sans;\n\t\n}\n\ndouble Vf(double z){\n\tauto p = seg(ps2,z);\n\treturn S(p.first,p.second);\n}\n\ndouble Vs(double l,double r){\n\treturn (r-l)/6*(Vf(l)+4*Vf((l+r)/2)+Vf(r));\n}\n\ndouble V(double l,double r,int k=5){\n\tdouble m = (l+r)/2;\n\tdouble a = Vs(l,m);\n\tdouble b = Vs(m,r);\n\tdouble c = Vs(l,r);\n\tif( (c>eps or k <= 0) and eq(a+b,c) ){\n\t\treturn c;\n\t}else{\n\t\treturn V(l,m,k-1) + V(m,r,k-1);\n\t}\t\n}\n\nint main(){\n\tint m,n;\n\twhile(cin >> m >> n && m ){\n\t\t\n\t\tps1.clear();\n\t\tps2.clear();\n\t\tux.clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tps1.push_back(in());\n\t\t\tux.push_back(ps1.back().real());\n\t\t}\n\n\t\tvector<double> uz;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tps2.push_back(in());\n\t\t\tps2.back() = P(ps2.back().imag(),ps2.back().real());\n\t\t\tuz.push_back(ps2.back().real());\n\t\t}\n\t\tsort(uz.begin(),uz.end());\n\t\tsort(ux.begin(),ux.end());\n\t\tdouble vans = 0;\n\t\t//for( auto z : uz ) cout << z << \" \"; cout << endl;\n\t\t//for( auto x : ux ) cout << x << \" \"; cout << endl;\n\t\tfor(int i = 0 ; i+1 < uz.size() ; i++)\n\t\t\tif( uz[i] != uz[i+1] )\n\t\t\t\tvans += V(uz[i],uz[i+1]);\n\t\tprintf(\"%.6lf\\n\",(dbl)vans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <cstring>\nusing namespace std;\n\nconst int N = 505;\nconst double EPS = 1e-12, INF = 1e12;\nint dcmp(double x) { return (x > EPS) - (x < -EPS); }\nstruct Point {\n\tint x, y;\n\tPoint() { }\n\tPoint(int _x, int _y) :x(_x), y(_y) { }\n};\ntypedef Point Vector;\nvoid read(Point &p) { scanf(\"%d%d\", &p.x, &p.y); }\n\nint m, n;\nPoint pa[N], pb[N];\n\ndouble width(Point *poly, int n, double x) {\n\tint i;\n\tdouble lb = INF, ub = -INF;\n\tfor (i = 0;i < n;++i) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\t//if a.x == b.x we'd better consider it to be alone\n\t\tdouble x1 = a.x, x2 = b.x, y1 = a.y, y2 = b.y;\n\t\tif ((x1 - x) * (x2 - x) <= 0 && x1 != x2) {\n\t\t\tdouble y = a.y + (y2 - y1) * (x - x1) / (x2 - x1);\n\t\t\tlb = min(lb, y); ub = max(ub, y);\n\t\t}\n\t}\n\treturn max(0.0, ub - lb);\n}\n\nvoid solve() {\n\tint i;\n\tint mna = pa[0].x, mxa = pa[0].x, mnb = pb[0].x, mxb = pb[0].x;\n\tfor (i = 1;i < m;++i) mna = min(mna, pa[i].x), mxa = max(mxa, pa[i].x);\n\tfor (i = 1;i < n;++i) mnb = min(mnb, pb[i].x), mxb = max(mxb, pb[i].x);\n\tvector<int> xs;\n\tfor (i = 0;i < m;++i) xs.push_back(pa[i].x);\n\tfor (i = 0;i < n;++i) xs.push_back(pb[i].x);\n\tsort(xs.begin(), xs.end());\n\t//xs.erase(unique(xs.begin(), xs.end()), xs.end());\n\tdouble res = 0.0;\n\tfor (i = 0;i + 1 < xs.size();++i) {\n\t\tdouble a = xs[i], b = xs[i + 1], c = (a + b) / 2;\n\t\t//if (dcmp(mna - c) <= 0 && dcmp(c - mxa) <= 0 && dcmp(mnb - c) <= 0 && dcmp(c - mxb) <= 0) {\n\t\tif (mna <= c && c <= mxa && mnb <= c && c <= mxb) {\t\t\n\t\t\tdouble fa = width(pa, m, a) * width(pb, n, a);\n\t\t\tdouble fb = width(pa, m, b) * width(pb, n, b);\n\t\t\tdouble fc = width(pa, m, c) * width(pb, n, c);\n\t\t\tres += (b - a) / 6 * (fa + 4 * fc + fb);\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", res);\n}\n\nint main(int argc, char *argv[]) {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"dat.in\", \"r\", stdin);\n\tfreopen(\"my.out\", \"w\", stdout);\n#endif\n\twhile (scanf(\"%d%d\", &m, &n) == 2 && n && m) {\n\t\tint i;\n\t\tfor (i = 0;i < m;++i) read(pa[i]);\n\t\tfor (i = 0;i < n;++i) read(pb[i]);\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nconst int DIV = 1000000;\n\nint m, n;\ndouble x1[100], y[100], x2[100], z[100];\ndouble mnx, mxx;\n\ndouble solve(double x) {\n  double y1 = 0, y2 = 0, z1 = 0, z2 = 0;\n  static int px11 = 0, px12 = 0, px21 = 0, px22 = 0;\n  rep (ii, m) {\n    int i = (px11 + ii) % m;\n    if (x1[i] != x1[(i + 1) % m] && x1[i] <= x && x <= x1[(i + 1) % m]) {\n      y1 = y[i] + (y[(i + 1) % m] - y[i]) / (x1[(i + 1) % m] - x1[i]) * (x - x1[i]);\n      px11 = i;\n      break;\n    }\n  }\n  rep (ii, m) {\n    int i = (px12 - ii + m) % m;\n    if (x1[i] != x1[(i + 1) % m] && x1[(i + 1) % m] <= x && x <= x1[i]) {\n      y2 = y[i] + (y[(i + 1) % m] - y[i]) / (x1[(i + 1) % m] - x1[i]) * (x - x1[i]);\n      px12 = i;\n      break;\n    }\n  }\n  rep (ii, n) {\n    int i = (px21 + ii) % n;\n    if (x2[i] != x2[(i + 1) % n] && x2[i] <= x && x <= x2[(i + 1) % n]) {\n      z1 = z[i] + (z[(i + 1) % n] - z[i]) / (x2[(i + 1) % n] - x2[i]) * (x - x2[i]);\n      px21 = i;\n      break;\n    }\n  }\n  rep (ii, n) {\n    int i = (px22 - ii + n) % n;\n    if (x2[i] != x2[(i + 1) % n] && x2[(i + 1) % n] <= x && x <= x2[i]) {\n      z2 = z[i] + (z[(i + 1) % n] - z[i]) / (x2[(i + 1) % n] - x2[i]) * (x - x2[i]);\n      px22 = i;\n      break;\n    }\n  }\n  return (y2 - y1) * (z2 - z1);\n}\n\ndouble simpson(double l, double r, double f(double), int k = 1){\n  double h = (r - l) / (2 * k);\n  double fo = 0, fe = 0;\n  for(int i = 1; i <= 2 * k - 3; i += 2){\n    fo += f(l + h * i);\n    fe += f(l + h * (i + 1));\n  }\n  return (f(l) + f(r) + 4 * (fo + f(r - h)) + 2 * fe) * h / 3;\n}\n\nint main() {\n  while (true) {\n    cin >> m >> n;\n    if (m == 0 && n == 0) break;\n    rep (i, m) cin >> x1[i] >> y[i];\n    rep (i, n) cin >> x2[i] >> z[i];\n    double mnx = max(*min_element(x1, x1 + m), *min_element(x2, x2 + n));\n    double mxx = min(*max_element(x1, x1 + m), *max_element(x2, x2 + n));\n    printf(\"%.12lf\\n\", simpson(mnx, mxx, solve, DIV));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <fstream>\n#include <vector>\n#include <complex>\n#include <stdio.h>\n\nusing namespace std;\n\ntypedef complex<int> P;\n\ndouble getWidth(vector<P> &g, int x){\n\tdouble m = 1e10, M = -1e10;\n\tfor(int i=0;i<g.size();i++){\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif(real(a) > real(b)) swap(a, b);\n\t\tif(real(a) != real(b) && real(a) <= x && x <= real(b)){\n\t\t\tdouble mid = (double)(x-real(a))/(real(b)-real(a));\n\t\t\tdouble d = imag(a)*(1-mid)+imag(b)*mid;\n\t\t\tm = min(d, m);\n\t\t\tM = max(d, M);\n\t\t}\n\t}\n\treturn max(0.0, M-m);\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> m >> n, m){\n\t\tvector<P> gy(m), gz(n);\n\t\tint sy = 100, ey = -100, sz = 100, ez = -100; \n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> real(gy[i]) >> imag(gy[i]);\n\t\t\tsy = min(sy, real(gy[i]));\n\t\t\tey = max(ey, real(gy[i]));\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> real(gz[i]) >> imag(gz[i]);\n\t\t\tsz = min(sz, real(gz[i]));\n\t\t\tez = max(ez, real(gz[i]));\n\t\t}\n\t\tdouble res = 0.0;\n\t\tfor(int i=max(sy, sz);i+1<=min(ey, ez);i++){\n\t\t\tdouble py = getWidth(gy, i), cy = getWidth(gy, i+1), pz = getWidth(gz, i), cz = getWidth(gz, i+1);\n\t\t\tres += (cy*cz+(cy+py)*(cz+pz)+py*pz)/6.0;\n\t\t}\n\t\tprintf(\"%.4lf\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\nPDFにPythonでの実装例が載っていたので、C++のコードに書き換えて実装したので、コードの意味を理解するのに苦労する部分もあったがなんとか書くことができた。コンテナを関数の引数にできることや、cout << fixed << という構文があることを新たに知ることができた。\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst double EPS = 1e-11;\n\ndouble width(vector<pair<int,int>> polygon, double x) {\n  vector<double> w;\n  for (int i = 0; i < polygon.size() ; i++) {\n    pair<int,int> p = polygon[i], q = polygon[(i+1)%polygon.size()];\n    if (abs(p.first - x) < EPS)\n      w.push_back(1.0*p.second);\n    else if ((p.first < x && x < q.first) || (p.first > x && x > q.first)) {\n      int x0 = p.first, y0 = p.second;\n      int x1 = q.first, y1 = q.second;\n      w.push_back(y0 + 1.0*(y1-y0)*(x-x0)/(x1-x0));\n    }\n  }\n  sort(w.begin(), w.end());\n  return w[w.size()-1] - w[0];\n}\n\ndouble volume(vector<pair<int,int>> pxy, vector<pair<int,int>> pxz, vector<int> X) {\n  double total = 0.0;\n  int xmin = max((*min_element(pxy.begin(), pxy.end())).first,\n                 (*min_element(pxz.begin(), pxz.end())).first);\n  int xmax = min((*max_element(pxy.begin(), pxy.end())).first,\n                 (*max_element(pxz.begin(), pxz.end())).first);\n  sort(X.begin(), X.end());\n  for (int i = 0; i < X.size()-1; i++) {\n    int a = X[i], b = X[i+1];\n    if (!(xmin <= a && a <= xmax && xmin <= b && b <= xmax))\n      continue;\n    double m = (a+b)/2.0;\n    double va = width(pxy, a)*width(pxz, a);\n    double vb = width(pxy, b)*width(pxz, b);\n    double vm = width(pxy, m)*width(pxz, m);\n    double area = ((b-a)/6.0)*(va + 4.0*vm + vb);\n    total += area;\n  }\n  return total;\n}\n\nint main() {\n  int M, N;\n  while (cin >> M >> N && M > 0) {\n    vector<pair<int,int>> PXY, PXZ;\n    vector<int> X;\n    int x, y, z;\n    for (int i = 0; i < M; i++) {\n      cin >> x >> y;\n      PXY.push_back(make_pair(x,y));\n      X.push_back(x);\n    }\n    for (int i = 0; i < N; i++) {\n      cin >> x >> z;\n      PXZ.push_back(make_pair(x,z));\n      X.push_back(x);\n    }\n    cout << fixed << volume(PXY, PXZ, X) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst double INF=1e77;\n\nstruct point{ int x,y; };\n\nint m,n;\npoint p[100],q[100];\n\ndouble f(double x){\n\tdouble yl=INF,yr=-INF;\n\trep(i,m){\n\t\tpoint a=p[i],b=p[(i+1)%m];\n\t\tif(a.x>b.x) swap(a,b);\n\t\tif(a.x==b.x) continue;\n\t\tif(a.x<=x && x<b.x){\n\t\t\tdouble y=a.y+(x-a.x)/(b.x-a.x)*(b.y-a.y);\n\t\t\tyl=min(yl,y);\n\t\t\tyr=max(yr,y);\n\t\t}\n\t}\n\n\tdouble zl=INF,zr=-INF;\n\trep(i,n){\n\t\tpoint a=q[i],b=q[(i+1)%n];\n\t\tif(a.x>b.x) swap(a,b);\n\t\tif(a.x==b.x) continue;\n\t\tif(a.x<=x && x<b.x){\n\t\t\tdouble z=a.y+(x-a.x)/(b.x-a.x)*(b.y-a.y);\n\t\t\tzl=min(zl,z);\n\t\t\tzr=max(zr,z);\n\t\t}\n\t}\n\n\treturn max(yr-yl,0.0)*max(zr-zl,0.0);\n}\n\nint main(){\n\tfor(;scanf(\"%d%d\",&m,&n),m;){\n\t\trep(i,m) scanf(\"%d%d\",&p[i].x,&p[i].y);\n\t\trep(i,n) scanf(\"%d%d\",&q[i].x,&q[i].y);\n\n\t\tint X[200];\n\t\trep(i,m) X[ i ]=p[i].x;\n\t\trep(i,n) X[i+m]=q[i].x;\n\t\tsort(X,X+m+n);\n\n\t\tdouble ans=0;\n\t\trep(i,m+n-1){\n\t\t\tdouble a=X[i],b=X[i+1];\n\t\t\tans+=(b-a)/6*(f(a)+4*f((a+b)/2)+f(b));\n\t\t}\n\t\tprintf(\"%.9f\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst double INF=1e12;\nint M,N;\nint X1[100],X2[100],Y1[100],Y2[100];\n\ndouble f(int *X,int *Y,int n,double x){\n    double l=INF,r=-INF;\n    rep(i,n){\n        double x1=X[i],y1=Y[i],x2=X[(i+1)%n],y2=Y[(i+1)%n];\n        if((x1-x)*(x2-x)>0||x1==x2)continue;\n        double y=y1+(y2-y1)/(x2-x1)*(x-x1);\n        chmin(l,y);\n        chmax(r,y);\n    }\n    return max(0.0,r-l);\n}\n\nvoid solve(){\n    vint xs;\n    rep(i,M)xs.pb(X1[i]);\n    rep(i,N)xs.pb(X2[i]);\n    sort(all(xs));\n    int min1=*min_element(X1,X1+M),max1=*max_element(X1,X1+M);\n    int min2=*min_element(X2,X2+N),max2=*max_element(X2,X2+N);\n    double ans=0;\n    for(int i=0;i+1<xs.size();i++){\n        double a=xs[i],b=xs[i+1],c=(a+b)/2.0;\n        double fa=f(X1,Y1,M,a)*f(X2,Y2,N,a);\n        double fb=f(X1,Y1,M,b)*f(X2,Y2,N,b);\n        double fc=f(X1,Y1,M,c)*f(X2,Y2,N,c);\n        ans+=(b-a)/6*(fa+fb+fc*4);\n    }\n    printf(\"%.20f\\n\",ans);\n}\n\nsigned main(){\n    while(cin>>M>>N,M||N){\n        rep(i,M)cin>>X1[i]>>Y1[i];\n        rep(i,N)cin>>X2[i]>>Y2[i];\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nconst int DIV = 1000000;\n\nint m, n;\ndouble x1[100], y[100], x2[100], z[100];\ndouble mnx, mxx;\n\ndouble solve(double x) {\n  double y1 = 0, y2 = 0, z1 = 0, z2 = 0;\n  rep (i, m) if (x1[i] != x1[(i + 1) % m] && x1[i] <= x && x <= x1[(i + 1) % m]) {\n    y1 = y[i] + (y[(i + 1) % m] - y[i]) / (x1[(i + 1) % m] - x1[i]) * (x - x1[i]);\n  }\n  rep (i, m) if (x1[i] != x1[(i + 1) % m] && x1[(i + 1) % m] <= x && x <= x1[i]) {\n    y2 = y[i] + (y[(i + 1) % m] - y[i]) / (x1[(i + 1) % m] - x1[i]) * (x - x1[i]);\n  }\n  rep (i, n) if (x2[i] != x2[(i + 1) % n] && x2[i] <= x && x <= x2[(i + 1) % n]) {\n    z1 = z[i] + (z[(i + 1) % n] - z[i]) / (x2[(i + 1) % n] - x2[i]) * (x - x2[i]);\n  }\n  rep (i, n) if (x2[i] != x2[(i + 1) % n] && x2[(i + 1) % n] <= x && x <= x2[i]) {\n    z2 = z[i] + (z[(i + 1) % n] - z[i]) / (x2[(i + 1) % n] - x2[i]) * (x - x2[i]);\n  }\n  return (y2 - y1) * (z2 - z1);\n}\n\ndouble simpson(double l, double r, double f(double), int k = 1){\n  double h = (r - l) / (2 * k);\n  double fo = 0, fe = 0;\n  for(int i = 1; i <= 2 * k - 3; i += 2){\n    fo += f(l + h * i);\n    fe += f(l + h * (i + 1));\n  }\n  return (f(l) + f(r) + 4 * (fo + f(r - h)) + 2 * fe) * h / 3;\n}\n\nint main() {\n  while (true) {\n    cin >> m >> n;\n    if (m == 0 && n == 0) break;\n    rep (i, m) cin >> x1[i] >> y[i];\n    rep (i, n) cin >> x2[i] >> z[i];\n    double mnx = max(*min_element(x1, x1 + m), *min_element(x2, x2 + n));\n    double mxx = min(*max_element(x1, x1 + m), *max_element(x2, x2 + n));\n    printf(\"%.12lf\\n\", simpson(mnx, mxx, solve, DIV));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nconst double INF = 1e9;\nconst int maxn = 105, maxm = 105;\nint M, N, X1[maxm], Y1[maxm], X2[maxn], Z2[maxn];\ndouble width(int *X, int *Y, int n, double x)\n{\n    double lb = INF, ub = -INF;\n    for(int i = 0; i < n; i++){\n        double x1 = X[i], y1 = Y[i], x2 = X[(i + 1) % n], y2 = Y[(i + 1) % n];\n        if((x1 - x) * (x2 - x) <= 0 && x1 != x2){\n            double y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n            lb = min(lb, y);\n            ub = max(ub, y);\n        }\n    }\n    return max(0.0, ub - lb);\n}\nvoid solve()\n{\n    int min1 = *min_element(X1, X1 + M), max1 = *max_element(X1, X1 + M);\n    int min2 = *min_element(X2, X2 + N), max2 = *max_element(X2, X2 + N);\n    vector<int> xs;\n    for(int i = 0; i < M; i++)\n        xs.push_back(X1[i]);\n    for(int i = 0; i < N; i++) xs.push_back(X2[i]);\n    sort(xs.begin(), xs.end());\n    double res = 0;\n    for(int i = 0; i + 1 < xs.size(); i++){\n        double a = xs[i], b = xs[i + 1], c = (a + b) / 2;\n        if(min1 <= c && c <= max1 && min2 <= c && c <= max2){\n            double fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n            double fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n            double fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n            res += (b - a) / 6 * (fa + 4 * fc + fb);\n        }\n    }\n    printf(\"%.10f\\n\", res);\n}\nint main()\n{\n    while(scanf(\"%d%d\", &M, &N) && M){\n        for(int i = 0; i < M; i++){\n            scanf(\"%d%d\", &X1[i], &Y1[i]);\n        }\n        for(int i = 0; i < N; i++){\n            scanf(\"%d%d\", &X2[i], &Z2[i]);\n        }\n        solve();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#define MAX_M 105\n#define MAX_N 105\n#define INF (1 << 30)\nusing namespace std;\n\nint M, N;\nint X1[MAX_M], Y1[MAX_M];\nint X2[MAX_N], Z2[MAX_N];\n\ndouble width(int X[], int Y[], int n, double x)\n{\n    double lb = INF, ub = -INF;\n    for (int i = 0; i < n; i++)\n    {\n        double x1 = X[i], y1 = Y[i];\n        double x2 = X[(i + 1) % n], y2 = Y[(i + 1) % n];\n        if ((x1 - x) * (x2 - x) <= 0 && x1 != x2)\n        {\n            double a = (y1 - y2) / (x1 - x2);\n            double b = (y1 * x2 - y2 * x1) / (x2 - x1);\n            double y = a * x + b;\n            lb = min(lb, y);\n            ub = max(ub, y);\n        }\n    }\n    return max(0.0, ub - lb);\n}\n\nvoid solve()\n{\n    int min1 = *min_element(X1, X1 + M), max1 = *max_element(X1, X1 + M);\n    int min2 = *min_element(X2, X2 + N), max2 = *max_element(X2, X2 + N);\n    vector<int> xs;\n    for (int i = 0; i < M; i++)\n        xs.push_back(X1[i]);\n    for (int i = 0; i < N; i++)\n        xs.push_back(X2[i]);\n    sort(xs.begin(), xs.end());\n\n    double res = 0;\n    for (int i = 0; i < xs.size() - 1; i++)\n    {\n        double a = xs[i], b = xs[i + 1], c = (a + b) / 2;\n        if (min1 <= c && c <= max1 && min2 <= c && c <= max2)\n        {\n            double fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n            double fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n            double fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n            res += (b - a) / 6 * (fa + 4 * fc + fb);\n        }\n    }\n\n    printf(\"%.10f\\n\", res);\n}\n\nint main()\n{\n    while (true)\n    {\n        scanf(\"%d %d\", &M, &N);\n        if (M == 0 && N == 0)\n            break;\n\n        for (int i = 0; i < M; i++)\n            scanf(\"%d %d\", &X1[i], &Y1[i]);\n        for (int i = 0; i < N; i++)\n            scanf(\"%d %d\", &X2[i], &Z2[i]);\n\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define MAX_M 100\n#define MAX_N 100\n#define INF (1<<20)\n\nint M,N;\nint X1[MAX_M], Y1[MAX_M];\nint X2[MAX_N], Z2[MAX_N];\n\n// 多角形をxでスライスしたときの幅を返す\ndouble width(int* X, int* Y, int n, double x) {\n    double lb = INF, ub = -INF;\n    for(int i=0;i<n;i++) {\n        double x1 = X[i], y1 = Y[i], x2 = X[(i + 1) % n], y2 = Y[(i + 1) % n];\n        // i番目の辺と交点を持つか調べる\n        if ((x1 - x) * (x2 - x) <= 0 && x1 != x2) {\n            // 交点の座標を計算\n            double y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n            //double y = y1 + (y2 - y1) * x / (x2 - x1);\n            lb = min(lb, y);\n            ub = max(ub, y);\n        }\n    }\n    return max(0.0, ub - lb);\n}\n\nvoid solve() {\n    int min1 = *min_element(X1, X1 + M), max1 = *max_element(X1, X1 + M);\n    int min2 = *min_element(X2, X2 + N), max2 = *max_element(X2, X2 + N);\n    vector<int> xs;\n    for(int i=0;i<M;i++) xs.push_back(X1[i]);\n    for(int i=0;i<N;i++) xs.push_back(X2[i]);\n    sort(xs.begin(), xs.end());\n\n    double res = 0;\n    for(int i=0;i+1<xs.size();i++) {\n        double a = xs[i], b = xs[i+1], c=(a+b)/2;\n        // 重なっている\n        if(min1 <= c && c <= max1 && min2 <=c && c <= max2) {\n            // シンプソンの公式で積分する\n            double fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n            double fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n            double fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n            res += (b - a) / 6 * (fa + 4 * fc + fb);\n        }\n    }\n    printf(\"%.10f\\n\", res);\n}\n\nmain() {\n    while(scanf(\"%d %d\",&M,&N), M!=0) {\n        for(int i=0;i<M;i++) scanf(\"%d %d\",&X1[i], &Y1[i]);\n        for(int i=0;i<N;i++) scanf(\"%d %d\", &X2[i] ,&Z2[i]);\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ndouble eps = 1e-9;\nvector<P> ps1,ps2;\nbool eq(double a,double b){\n\treturn fabs(a-b) < eps;\n}\n\nvector<double> ux;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\npair<double,double> seg(const vector<P> &ps,double x){\n\tdouble mi = 1e9, ma = -1e9;\n\tauto reflesh = [&mi,&ma](double y){\n\t\tmi = min(mi,y);\n\t\tma = max(ma,y);\n\t};\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tP a = ps[i];\n\t\tP b = ps[(i+1)%ps.size()];\n\t\tif( a.real() > b.real() ) swap(a,b);\n\t\tif( eq(a.real(),x) ) reflesh(a.imag());\n\t\tif( eq(b.real(),x) ) reflesh(b.imag());\n\t\tif( a.real() + eps < x and x < b.real() - eps ){\n\t\t\treflesh(a.imag() + (x - a.real()) * (b.imag() - a.imag()) / (b.real()-a.real()));\n\t\t}\n\t}\n\tif( ma < mi ) return {0.0,0.0};\n\treturn {mi,ma};\n}\n\ndouble Sf(double x){\n\tauto p = seg(ps1,x);\n\treturn p.second - p.first;\n}\n\ndouble Ss(double l,double r){\n\treturn (r-l)/6*(Sf(l)+4*Sf((l+r)/2)+Sf(r));\n}\n\ndouble S2(double l,double r,int k=4){\n\tif( r < l ) return 0;\n\tdouble m = (l+r)/2;\n\tdouble a = Ss(l,m);\n\tdouble b = Ss(m,r);\n\tdouble c = Ss(l,r);\n\tif( (c>eps or k <= 0) and eq(a+b,c) ){\n\t\t//cout << a+b << \" \" << c << endl;\n\t\treturn c;\n\t}else{\n\t\treturn S2(l,m,k-1) + S2(m,r,k-1);\n\t}\t\n}\ndouble S(double l,double r){\n\tdouble sans = 0;\n\tfor(int i = 0 ; i+1 < ux.size() ; i++){\n\t\tif( ux[i] != ux[i+1] ){\n\t\t\tsans += S2(max(l,ux[i]),min(r,ux[i+1]));\n\t\t}\n\t}\n\t//cout << sans << endl;\n\treturn sans;\n\t\n}\n\ndouble Vf(double z){\n\tauto p = seg(ps2,z);\n\treturn S(p.first,p.second);\n}\n\ndouble Vs(double l,double r){\n\treturn (r-l)/6*(Vf(l)+4*Vf((l+r)/2)+Vf(r));\n}\n\ndouble V(double l,double r,int k=4){\n\tdouble m = (l+r)/2;\n\tdouble a = Vs(l,m);\n\tdouble b = Vs(m,r);\n\tdouble c = Vs(l,r);\n\tif( (c>eps or k <= 0) and eq(a+b,c) ){\n\t\treturn c;\n\t}else{\n\t\treturn V(l,m,k-1) + V(m,r,k-1);\n\t}\t\n}\n\nint main(){\n\tint m,n;\n\twhile(cin >> m >> n && m ){\n\t\t\n\t\tps1.clear();\n\t\tps2.clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tps1.push_back(in());\n\t\t\tux.push_back(ps1.back().real());\n\t\t}\n\n\t\tvector<double> uz;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tps2.push_back(in());\n\t\t\tps2.back() = P(ps2.back().imag(),ps2.back().real());\n\t\t\tuz.push_back(ps2.back().real());\n\t\t}\n\t\tsort(uz.begin(),uz.end());\n\t\tsort(ux.begin(),ux.end());\n\t\tdouble vans = 0;\n\t\t//for( auto z : uz ) cout << z << \" \"; cout << endl;\n\t\t//for( auto x : ux ) cout << x << \" \"; cout << endl;\n\t\tfor(int i = 0 ; i+1 < uz.size() ; i++)\n\t\t\tif( uz[i] != uz[i+1] )\n\t\t\t\tvans += V(uz[i],uz[i+1]);\n\t\tprintf(\"%.10lf\\n\",vans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for(int i=0; i<(int)(n); i++)\n\nvector<double> widths(const vector<int>& xs, int n, int *x, int *y) {\n    vector<double> r;\n    rep(i, xs.size()) {\n        double miny = 1e100, maxy = -1e100;\n        rep(j, n) {\n            const int k = (j+1)%n;\n            if(x[j]==xs[i]) {\n                miny = min(miny, (double)y[j]);\n                maxy = max(maxy, (double)y[j]);\n            }\n            else if(min(x[j], x[k])<=xs[i] && xs[i]<=max(x[j], x[k])) {\n                const double dx = x[k]-x[j], dy = y[k]-y[j];\n                const double cy = y[j]+dy/dx*(xs[i]-x[j]);\n                miny = min(miny, cy);\n                maxy = max(maxy, cy);\n            }\n        }\n        r.push_back(maxy-miny);\n    }\n    return r;\n}\n\ndouble calc(double x, double y, double z1, double z2) {\n    if(z1<z2) return x*y/2*z1 + x*y/2*(z2-z1)/3;\n    else return x*y/2*z2 + y*(z1-z2)*x/3;\n}\n\nint m, mx[200], my[200], n, nx[200], nz[200];\n\nint main() {\n    for(;;) {\n        scanf(\"%d%d\", &m, &n);\n        if(m==0 && n==0) return 0;\n        rep(i, m) scanf(\"%d%d\", mx+i, my+i);\n        rep(i, n) scanf(\"%d%d\", nx+i, nz+i);\n\n        vector<int> xs;\n        rep(i, m) xs.push_back(mx[i]);\n        rep(i, n) xs.push_back(nx[i]);\n        sort(xs.begin(), xs.end());\n        xs.erase(unique(xs.begin(), xs.end()), xs.end());\n        vector<double> yw(widths(xs, m, mx, my));\n        vector<double> zw(widths(xs, n, nx, nz));\n\n        double ans = 0;\n        rep(i, xs.size()-1) {\n            const double x = xs[i+1]-xs[i];\n            const double y1 = yw[i], y2 = yw[i+1];\n            const double z1 = zw[i], z2 = zw[i+1];\n            if(y1<0 || y2<0 || z1<0 || z2<0) continue;\n            ans += (z1+z2)*x/2 * min(y1, y2);\n            if(y1>y2) ans += calc(x, y1-y2, z1, z2);\n            else ans += calc(x, y2-y1, z2, z1);\n        }\n        printf(\"%.12f\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF 1e15\n\n#define MAX_N 1000\n\ndouble width(int* X,int* Y,int n,double x){\n\tdouble lb=INF,ub=-INF;\n\trep(i,n){\n\t\tdouble x1=X[i],y1=Y[i],x2=X[(i+1)%n],y2=Y[(i+1)%n];\n\t\tif((x1-x)*(x2-x)<=0&&x1!=x2){\n\t\t\tdouble y=y1+(y2-y1)*(x-x1)/(x2-x1);\n\t\t\tminch(lb,y);\n\t\t\tmaxch(ub,y);\n\t\t}\n\t}\n\treturn max(0.0,ub-lb);\n}\n\nint m,n;\nint X1[111],Y1[111];\nint X2[111],Z2[111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>m>>n;\n\t\tif(m==0&&n==0)break;\n\t\trep(i,m)cin>>X1[i]>>Y1[i];\n\t\trep(i,n)cin>>X2[i]>>Z2[i];\n\n\t\tint min1=*min_element(X1,X1+m),max1=*max_element(X1,X1+m);\n\t\tint min2=*min_element(X2,X2+n),max2=*max_element(X2,X2+n);\n\t\tvector<int> xs;\n\t\trep(i,n)xs.pb(X1[i]);\n\t\trep(i,m)xs.pb(X2[i]);\n\t\tsort(all(xs));\n\n\t\tdouble res=0;\n\t\trep(i,xs.size()-1){\n\t\t\tdouble a=xs[i],b=xs[i+1],c=(a+b)/2;\n\t\t\tif(min1<=c&&c<=max1&&min2<=c&&c<=max2){\n\t\t\t\tdouble fa=width(X1,Y1,m,a)*width(X2,Z2,n,a);\n\t\t\t\tdouble fb=width(X1,Y1,m,b)*width(X2,Z2,n,b);\n\t\t\t\tdouble fc=width(X1,Y1,m,c)*width(X2,Z2,n,c);\n\t\t\t\tres+=(b-a)/6*(fa+4*fc+fb);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10f\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\n\n#define INF 1000000\nusing namespace std;\n\nint M,N;\nint X1[210], Y[210], X2[210], Z[210];\n\ndouble width(int p[210], int q[210], int n, double x)\n{\n    double a=INF,b=-INF;\n    for(int i=0;i<n;i++)\n\t{\n        double x1=p[i], x2=p[(i+1)%n];\n        double y1=q[i], y2=q[(i+1)%n];\n        if((x1-x)*(x2-x)<=0 && x1!=x2)\n\t\t{\n            double y=y1+(y2-y1)*(x-x1)/(x2-x1);\n            a=min(a,y);\n            b=max(b,y);\n        }\n    }\n    if(b-a>0)\n      return b-a;\n    else\n      return 0.0;\n}\n\ndouble volume()\n{\n\tint x1min, x2min, x1max, x2max;\n\tx1min=*min_element(X1, X1+M);\n\tx1max=*max_element(X1, X1+M);\n\tx2min=*min_element(X2, X2+M);\n\tx2max=*max_element(X2, X2+M);\n\tint A[420];\n\tfor(int i=0;i<M;i++)\n\t{\n\t\tA[i]=X1[i];\n\t}\n\tfor(int i=M;i<M+N;i++)\n\t{\n\t   A[i]=X2[i-M];\t\n\t}\n\tsort(A,A+M+N);\n\tdouble total=0.0;\n\tfor(int i=0;i+1<M+N;i++)\n\t{\n\t\tdouble a=A[i], b=A[i+1];\n\t\tdouble c=(a+b)/2.0;\n\t\tif(c>=x1min&&c<=x1max&&c>=x2min&&c<=x2max)\n\t\t{\n\t\t\tdouble fa, fb, fc;\n\t\t\tfa=width(X1,Y,M,a)*width(X2,Z,N,a);\n\t\t\tfb=width(X1,Y,M,b)*width(X2,Z,N,b);\n\t\t\tfc=width(X1,Y,M,c)*width(X2,Z,N,c);\n\t\t\ttotal+=(b-a)/6*(fa+4*fc+fb);\n\t\t}\n\t}\n\treturn total;\n}\n\nint main()\n{\n    while(cin >> M >> N)\n\t{\n\t\tfor(int i=0;i<210;i++)\n\t\t{\n\t\t\tX1[i]=0;\n\t\t\tY[i]=0;\n\t\t\tX2[i]=0;\n\t\t\tZ[i]=0;\n\t\t}\n\t\tif(!M&&!N)\n\t\t  break;\n\t\tfor(int i=0;i<M;i++)\n\t\t   cin >> X1[i] >> Y[i];\n\t\tfor(int i=0;i<N;i++)\n\t\t   cin >> X2[i] >> Z[i];   \n\t\tdouble sum=volume();\n\t\tprintf(\"%.10f\\n\",sum);\n\t}\t\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\n#include <cassert>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Pol;\nD eps=1e-11,Eps=1e-9;\nD cro(P a,P b){return imag(conj(a)*b);}\nint ccw(P a,P b,P c){\n\tif(cro(b-a,c-a)>eps) return 1;\n\tif(cro(b-a,c-a)<-eps) return -1;\n\tif(abs(abs(a-c)+abs(c-b)-abs(a-b))<eps) return 0;\n\tif(abs(abs(a-b)+abs(c-b)-abs(a-c))<eps) return -2;\n\treturn 2;\n}\nbool iLS(L l,L s){\n\tif(abs(cro(l.fs-l.sc,s.fs-s.sc))<eps) return 0;\n\treturn cro(l.sc-l.fs,s.fs-l.fs)*cro(l.sc-l.fs,s.sc-l.fs)<eps;\n}\nP intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nint M,N;\nPol a,b;\nD rec(D x){\n\tL l=L(P(x,0),P(x,1));\n\tPol inters;\n\trep(j,M){\n\t\tL e=L(a[j],a[(j+1)%M]);\n\t\tif(iLS(l,e)) inters.pb(intLL(l,e));\n\t}\n\tif(inters.size()<=1) return -1;\n\tD leny=0;\n\tfor(P p:inters) for(P q:inters) leny=max(leny,abs(p-q));\n\tinters.clear();\n\trep(j,N){\n\t\tL e=L(b[j],b[(j+1)%N]);\n\t\tif(iLS(l,e)) inters.pb(intLL(l,e));\n\t}\n\tif(inters.size()<=1) return -1;\n\tD lenz=0;\n\tfor(P p:inters) for(P q:inters) lenz=max(lenz,abs(p-q));\n\treturn leny*lenz;\n}\nint main(){\n\twhile(true){\n\t\tcin>>M>>N;\n\t\tif(M==0) break;\n\t\ta.clear(),b.clear();\n\t\tvector<D> xs;\n\t\tD ans=0;\n\t\trep(i,M){\n\t\t\tD x,y;\n\t\t\tcin>>x>>y;\n\t\t\ta.pb(P(x,y));\n\t\t\txs.pb(x-Eps);\n\t\t\txs.pb(x+Eps);\n\t\t}\n\t\trep(i,N){\n\t\t\tD x,y;\n\t\t\tcin>>x>>y;\n\t\t\tb.pb(P(x,y));\n\t\t\txs.pb(x-Eps);\n\t\t\txs.pb(x+Eps);\n\t\t}\n\t\tsort(all(xs));\n\t\trep(i,xs.size()-1){\n\t\t\tif(rec(xs[i])<-eps||rec(xs[i])<-eps) continue;\n\t\t\tans+=(xs[i+1]-xs[i])/6.0*(rec(xs[i])+4.0*rec((xs[i+1]+xs[i])/2)+rec(xs[i+1]));\n\t\t}\n\t\tprintf(\"%.4f\\n\",(double)ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nnamespace using std;\nint m,n;\nconst double EPS = 1e-11;\nvector<pair<int,int> > Pxy,Pyz;\npair<int,int> tem;\nvector<int> X;\n\nint findMax(vector<int> vec) {\n    int maxs = -999;\n    for (auto v : vec) {\n        if (maxs < v) maxs = v;\n    }\n    return maxs;\n}\n\nint findMin(vector<int> vec) {\n    int mins = 999;\n    for (auto v : vec) {\n        if (mins > v) mins = v;\n    }\n    return mins;\n}\n\ndouble width(vector<pair<int,int> > polygon,int x){\n    vector<double> w;\n    for(int i=0;i<polygon.len();i++){\n        pair<int,int> p=polygon[i];\n        pair<int,int> q=polygon[(i+1)%polygon.len()];\n        if((p.first-x)<EPS){\n            w.push_back(1.0*p.second);\n        }\n        else if(p.first<x && x<q.first|| p.first>0 && x>q.first){\n            int x0=p.first;\n            int y0=p.second;\n            int x1=q.first;\n            int y1=q.second;\n            w.push_back(y0+1.0*(y1-y0)*(x-x0)/(x1-x0));\n        }\n    }\n    assert(w.len()>0);\n    return (findMax(w)-findMin(w));\n}\n\nint volume(vector<pair<int,int> >Pxy,vector<pair<int,int> >Pxz,vector<int> X){\n    double total=0.0;\n    int xmin = max((*min_element(pxy.begin(), pxy.end())).first,\n                   (*min_element(pxz.begin(), pxz.end())).first);\n    int xmax = min((*max_element(pxy.begin(), pxy.end())).first,\n                   (*max_element(pxz.begin(), pxz.end())).first);\n    sort(X.begin(), X.end());\n    for(int i=0;i<X.len()-1;i++){\n        int a=X[i];\n        int b=X[i+1];\n        if(!(xmin <= a && a <= xmax &&xmin <= b && b<< xmax) ){\n            continue;\n        }\n        int m=(a+b)/2.0;\n        va = width(Pxy, a)*width(Pxz, a);\n        vb = width(Pxy, b)*width(Pxz, b);\n        m = width(Pxy, m)*width(Pxz, m);\n        double area=((b-a)/6.0)*(va + 4.0*vm + vb);\n        total+=area;\n    }\n    return total;\n}\nint main(){\n    while(cin>>m>>n&&n!=0){\n        for(int i=1;i<=m;i++){\n            cin>>tem.first>>tem.second;\n            Pxy.push_back(tem);\n            X.push_back(x);\n        }\n        for(int j=1;j<=n;j++){\n            cin>>tem.first>>tem.second;\n            Pxz.push_back(tem);\n            X.push_back(x);\n        }\n        cout << fixed << volume(PXY, PXZ, X) << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#if 0\n\n#endif\n\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\nconst double EPS = 1e-11;\n\ndouble width(vector<pair<int,int>> polygon, double x) {\n  vector<double> w;\n  for (int i = 0; i < polygon.size() ; i++) {\n    pair<int,int> p = polygon[i], q = polygon[(i+1)%polygon.size()];\n    if (abs(p.first - x) < EPS)\n      w.push_back(1.0*p.second);\n    else if ((p.first < x && x < q.first) || (p.first > x && x > q.first)) {\n      int x0 = p.first, y0 = p.second;\n      int x1 = q.first, y1 = q.second;\n      w.push_back(y0 + 1.0*(y1-y0)*(x-x0)/(x1-x0));\n    }\n  }\n  sort(w.begin(), w.end());\n  return w[w.size()-1] - w[0];\n}\n\ndouble volume(vector<pair<int,int>> pxy, vector<pair<int,int>> pxz, vector<int> X) {\n  double total = 0.0;\n  int xmin = max((*min_element(pxy.begin(), pxy.end())).first,\n                 (*min_element(pxz.begin(), pxz.end())).first);\n  int xmax = min((*max_element(pxy.begin(), pxy.end())).first,\n                 (*max_element(pxz.begin(), pxz.end())).first);\n  sort(X.begin(), X.end());\n  for (int i = 0; i < X.size()-1; i++) {\n    int a = X[i], b = X[i+1];\n    if (!(xmin <= a && a <= xmax && xmin <= b && b <= xmax))\n      continue;\n    double m = (a+b)/2.0;\n    double va = width(pxy, a)*width(pxz, a);\n    double vb = width(pxy, b)*width(pxz, b);\n    double vm = width(pxy, m)*width(pxz, m);\n    double area = ((b-a)/6.0)*(va + 4.0*vm + vb);\n    total += area;\n  }\n  return total;\n}\n\nint main() {\n  int M, N;\n  while (cin >> M >> N && M > 0) {\n    vector<pair<int,int>> PXY, PXZ;\n    vector<int> X;\n    int x, y, z;\n    for (int i = 0; i < M; i++) {\n      cin >> x >> y;\n      PXY.push_back(make_pair(x,y));\n      X.push_back(x);\n    }\n    for (int i = 0; i < N; i++) {\n      cin >> x >> z;\n      PXZ.push_back(make_pair(x,z));\n      X.push_back(x);\n    }\n    cout << fixed << volume(PXY, PXZ, X) << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstring>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <set>\n#include <string>\n#include <unordered_map>\n#include <vector>\n#define IOS ios::sync_with_stdio(0), cin.tie(0), cout.tie(0)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef double db;\ntypedef __int128_t int128;\nconst int maxn = 1e2 + 10;\nint n, m;\nint x1[maxn], y11[maxn], x2[maxn], y2[maxn];\ndb width(int *x, int *y, int n, db x0)\n{\n    double lb = 1e8, ub = -1e8;\n    for (int i = 0; i < n; i++)\n    {\n        double x1 = x[i], y1 = y[i], x2 = x[(i + 1) % n], y2 = y[(i + 1) % n];\n        if ((x1 - x0) * (x2 - x0) <= 0 && x1 != x2)\n        {\n            double y0 = y1 + (y2 - y1) * (x0 - x1) / (x2 - x1);\n            lb = min(lb, y0);\n            ub = max(ub, y0);\n        }\n    }\n    return max(0.0, ub - lb);\n}\nint main()\n{\n    IOS;\n    while (cin >> m >> n)\n    {\n        if (m == 0 && n == 0)\n            break;\n        for (int i = 0; i < m; i++)\n            cin >> x1[i] >> y11[i];\n        for (int i = 0; i < n; i++)\n            cin >> x2[i] >> y2[i];\n        int min1 = *min_element(x1, x1 + m), max1 = *max_element(x1, x1 + m);\n        int min2 = *min_element(x2, x2 + n), max2 = *max_element(x2, x2 + n);\n        vector<int> v;\n        for (int i = 0; i < m; i++)\n            v.push_back(x1[i]);\n        for (int i = 0; i < n; i++)\n            v.push_back(x2[i]);\n        sort(v.begin(), v.end());\n        double ans = 0;\n        for (int i = 0; i + 1 < v.size(); i++)\n        {\n            db a = v[i], b = v[i + 1], c = (a + b) / 2;\n            if (min1 <= c && c <= max1 && min2 <= c && c <= max2)\n            {\n                double fa = width(x1, y11, m, a) * width(x2, y2, n, a);\n                double fb = width(x1, y11, m, b) * width(x2, y2, n, b);\n                double fc = width(x1, y11, m, c) * width(x2, y2, n, c);\n                ans += (b - a) / 6 * (fa + 4 * fc + fb);\n            }\n        }\n        cout << fixed << setprecision(12) << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <vector>\nusing namespace std;\n\n#define MAX_N 101\n#define MAX_M 101\n#define INF (1<<29)\n\nint M, N;\nint X1[MAX_M], Y1[MAX_M];\nint X2[MAX_N], Z2[MAX_N];\n\ndouble width(int* X, int* Y, int n, double x){\n  double lb = INF, ub = -INF;\n  for(int i = 0 ; i < n ; i++){\n    double x1 = X[i], y1 = Y[i], x2 = X[(i+1)%n], y2 = Y[(i+1)%n];\n    if((x1 - x) * (x2 - x) <= 0 && x1 != x2){\n      double y = y1 + (y2-y1) * (x-x1) / (x2-x1);\n      lb = min(lb, y);\n      ub = max(ub, y);\n    }\n  }\n  return max(0.0, ub - lb);\n}\n\nvoid solve(){\n  int min1 = *min_element(X1, X1+M), max1 = *max_element(X1, X1+M);\n  int min2 = *min_element(X2, X2+N), max2 = *max_element(X2, X2+N);\n  vector<int> xs;\n  for(int i = 0 ; i < M ; i++) xs.push_back(X1[i]);\n  for(int i = 0 ; i < N ; i++) xs.push_back(X2[i]);\n  sort(xs.begin(), xs.end());\n  \n  double res = 0;\n  \n  for(int i = 0 ; i+1 < xs.size() ; i++){\n    double a = xs[i], b = xs[i+1], c = (a+b)/2;\n    if(min1 <= c && c <= max1 && min2 <= c && c <= max2){\n      double fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n      double fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n      double fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n      res += (b-a)/6*(fa+4*fc+fb);\n    }\n  }\n  printf(\"%.10f\\n\", res);\n}\n\nint main(void){\n\n  while(cin >> M >> N,N|M){\n    for(int i=0;i<M;i++){\n      cin >> X1[i] >> Y1[i];\n    }\n    for(int i=0;i<N;i++){\n      cin >> X2[i] >> Z2[i];\n    }\n    solve();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T> inline void chmin(T &a, const T &b) { if(a > b) a = b; }\ntemplate<class T> inline void chmax(T &a, const T &b) { if(a < b) a = b; }\n\ntypedef double Real;\nconstexpr Real EPS = 1e-8;\ninline int sign(Real d) { return d > EPS ? 1 : d < -EPS ? -1 : 0; }\n\nstruct Point {\n\tReal x, y;\n\texplicit Point(Real x_ = 0, Real y_ = 0):x(x_), y(y_) {}\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint operator*(Real s) const { return Point(x * s, y * s); }\n\tbool operator<(const Point &p) const { return sign(x - p.x) == -1 || (sign(x - p.x) == 0 && sign(y - p.y) == -1); }\n\tbool operator==(const Point &p) const { return sign(x - p.x) == 0 && sign(y - p.y) == 0; }\n};\n\ninline istream &operator>>(istream &is, Point &p) {\n\treturn is >> p.x >> p.y;\n}\n\nstruct Segment : public array<Point, 2> {\n\tSegment(const Point &a, const Point &b) { at(0) = a; at(1) = b; }\n};\n\ntypedef vector<Point> Polygon;\n\ninline Real norm(const Point &p) {\n\treturn p.x * p.x + p.y * p.y;\n}\n\ninline Real abs(const Point &p) {\n\treturn sqrt(norm(p));\n}\n\ninline Real dot(const Point &a, const Point &b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\ninline Real cross(const Point &a, const Point &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nenum { CCW = 1, CW = -1, BACK = 2, FRONT = -2, ON = 0};\ninline int ccw(const Point &a, const Point &b, const Point &c) {\n\tconst Point p = b - a;\n\tconst Point q = c - a;\n\tconst int sign_cross = sign(cross(p, q));\n\n\tif(sign_cross == 1) return CCW;\n\tif(sign_cross == -1) return CW;\n\tif(sign(dot(p, q)) == -1) return BACK;\n\tif(sign(norm(p) - norm(q)) == -1) return FRONT;\n\treturn ON;\n}\n\ninline bool intersect(const Segment &s, const Point &p) {\n\treturn ccw(s[0], s[1], p) == ON;\n}\n\ninline bool intersect(const Segment &a, const Segment &b) {\n\treturn ccw(a[0], a[1], b[0]) * ccw(a[0], a[1], b[1]) <= 0\n\t\t&& ccw(b[0], b[1], a[0]) * ccw(b[0], b[1], a[1]) <= 0;\n}\n\ninline Real dist(const Point &a, const Point &b) {\n\treturn abs(a - b);\n}\n\ninline Point crosspoint(const Segment &a, const Segment &b) {\n\tconst Real crs = cross(a[1] - a[0], b[1] - b[0]);\n\tif(sign(crs) == 0) {\n\t\tif(intersect(a, b[0])) return b[0];\n\t\tif(intersect(a, b[1])) return b[1];\n\t\tif(intersect(b, a[0])) return a[0];\n\t\treturn a[1];\n\t}\n\treturn b[0] + (b[1] - b[0]) * (cross(a[1] - a[0], a[1] - b[0]) / crs);\n}\n\n// *solve\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\n\tconstexpr Real INF = 1e6;\n\n\tfor(int m, n; cin >> m >> n && m;) {\n\t\tvector<Real> xs;\n\t\tPolygon c1(m), c2(n);\n\t\tReal L1 = INF, R1 = -INF, L2 = INF, R2 = -INF;\n\n\t\tfor(auto &e : c1) {\n\t\t\tcin >> e;\n\t\t\txs.emplace_back(e.x);\n\t\t\tchmin(L1, e.x);\n\t\t\tchmax(R1, e.x);\n\t\t}\n\t\tfor(auto &e : c2) {\n\t\t\tcin >> e;\n\t\t\txs.emplace_back(e.x);\n\t\t\tchmin(L2, e.x);\n\t\t\tchmax(R2, e.x);\n\t\t}\n\n\t\tconst Real L = max(L1, L2), R = min(R1, R2);\n\n\t\tsort(begin(xs), end(xs));\n\t\txs.erase(unique(begin(xs), end(xs)), end(xs));\n\n\t\tconst auto width = [](const Polygon &p, Real x) {\n\t\t\tSegment cut(Point(x, INF), Point(x, -INF));\n\t\t\tReal low = INF, high = -INF;\n\t\t\tPoint prev = p.back();\n\n\t\t\tfor(const auto &curr : p) {\n\t\t\t\tconst Segment edge(prev, curr);\n\t\t\t\tif(intersect(edge, cut)) {\n\t\t\t\t\tconst auto cp = crosspoint(edge, cut);\n\t\t\t\t\tchmin(low, cp.y);\n\t\t\t\t\tchmax(high, cp.y);\n\t\t\t\t}\n\t\t\t\tprev = curr;\n\t\t\t}\n\t\t\treturn max(0.0, high - low);\n\t\t};\n\t\tconst auto f = [&](Real x) { return width(c1, x) * width(c2, x); };\n\t\tconst auto simpson = [&](Real a, Real b) {\n\t\t\tconst Real c = (a + b) / 2;\n\t\t\treturn L < c && c < R ? (b - a) / 6 * (f(a) + 4 * f(c) + f(b)) : 0;\n\t\t};\n\n\t\tReal ans = 0.0;\n\t\tfor(int i = 1; i < xs.size(); ++i) {\n\t\t\tans += simpson(xs[i - 1], xs[i]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stdio.h>\n#include <iterator>\n#include <string.h>\nusing namespace std;\n\nconst double eps = 1e-8;\nconst int N = 110;\n\nstruct point{\n    int x,y;\n    point(int x=0,int y=0):x(x),y(y){}\n    bool operator < (const point &c) const { return x<c.x || (x==c.x && y<c.y); }\n    point operator - (const point &c) const { return point(x-c.x,y-c.y); }\n    int operator * (const point &c) const { return x*c.y-y*c.x; }\n    int operator | (const point &c) const { return (x-c.x)*(x-c.x)+(y-c.y)*(y-c.y); }\n}p1[N],p2[N],a1[N],a2[N];\n\nint n,m;\n\nint convex_hull(point a[],point p[],int tot)\n{\n    sort(a+1,a+1+tot);\n    int top=0;\n    for(int i=1;i<=tot;i++)\n    {\n        while(top>1 && (p[top]-p[top-1])*(a[i]-p[top-1])<=0) top--;\n        p[++top]=a[i];\n    }\n    int k=top;\n    for(int i=tot-1;i>=1;i--)\n    {\n        while(top>k && (p[top]-p[top-1])*(a[i]-p[top-1])<=0) top--;\n        p[++top]=a[i];\n    }\n    return top-1;\n}\n\ndouble f1[210],f2[210];\nvector<int> vx;\n\ndouble inst(point A,point B,int x){\n    if(B.x<A.x) swap(A,B);\n    double r = (double)(x-A.x)*(double)(B.y-A.y)/(B.x-A.x) + A.y;\n    return r;\n}\n\nint main()\n{\n    while(scanf(\"%d%d\",&n,&m)!=EOF)\n    {\n       if(n==0&&m==0) break;\n       memset(f1,0,sizeof f1);\n       memset(f2,0,sizeof f2);\n       int d1 = 1e9,d2=-1e9;\n       for(int i=1;i<=n;i++){\n        scanf(\"%d%d\",&p1[i].x,&p1[i].y);\n        vx.push_back(p1[i].x);\n        d1 = min(p1[i].x,d1);\n        d2 = max(p1[i].x,d2);\n    }\n    int t1 = convex_hull(p1,a1,n);\n    int d3 = 1e9,d4 = -1e9;\n    for(int i=1;i<=m;i++){\n        scanf(\"%d%d\",&p2[i].x,&p2[i].y);\n        vx.push_back(p2[i].x);\n        d3 = min(p2[i].x,d3);\n        d4 = max(p2[i].x,d4);\n    }\n    int t2 = convex_hull(p2,a2,m);\n\n    sort(vx.begin(),vx.end());\n    vector<int>::iterator iter = unique(vx.begin(),vx.end());\n    vx.erase(iter,vx.end());\n    //cout<<d1<<d3<<endl;\n    //cout<<d2<<d4<<endl;\n    for(int i=0;i<vx.size();i++){\n        if(vx[i]<max(d1,d3)) vx.erase(vx.begin()+i);\n        if(vx[i]>min(d2,d4)) vx.erase(vx.begin()+i);\n    }\n    for(int i=0;i<vx.size();i++){\n        double y[10];\n        for(int j=0;j<10;j++) y[j] = 0.0;\n        int k=0;\n        for(int j=1;j<n;j++){\n            if((vx[i]-a1[j].x)*(vx[i]-a1[j+1].x)<=0&&(a1[j].x!=a1[j+1].x)) y[k++] = inst(a1[j],a1[j+1],vx[i]);\n        }\n        if((vx[i]-a1[n].x)*(vx[i]-a1[1].x)<=0&&(a1[n].x!=a1[1].x)) y[k++] = inst(a1[n],a1[1],vx[i]);\n        if(k==0) f1[i] = 0;\n        else f1[i] = y[k-1] - y[0];\n\n        /*for(int j=0;j<k;j++){\n            cout<<y[j]<<endl;\n        }*/\n\n        for(int j=0;j<10;j++) y[j] = 0.0;\n        k = 0;\n        for(int j=1;j<m;j++){\n            if((vx[i]-a2[j].x)*(vx[i]-a2[j+1].x)<=0&&(a2[j].x!=a2[j+1].x)) y[k++] = inst(a2[j],a2[j+1],vx[i]);\n        }\n        if((vx[i]-a2[m].x)*(vx[i]-a2[1].x)<=0&&(a2[m].x!=a2[1].x)) y[k++] = inst(a2[m],a2[1],vx[i]);\n        if(k==0) f2[i] = 0;\n        else f2[i] = y[k-1] - y[0];\n        //cout<<f1[i]<<\" \"<<f2[i]<<endl;\n    }\n    double ans = 0;\n    for(int i=1;i<vx.size();i++){\n        ans += (f1[i-1]*f2[i-1]+(f1[i]+f1[i-1])*(f2[i]+f2[i-1])+f1[i]*f2[i])*(vx[i]-vx[i-1])/6;\n    }\n    printf(\"%f\\n\",ans);\n    vx.clear();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <climits>\n#include <ctime>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <list>\n#include <vector>\n#include <set>\n#include <map>\n#include <iostream>\n#include <deque>\n#include <complex>\n#include <string>\n#include <iomanip>\n#include <sstream>\n#include <bitset>\n#include <valarray>\n#include <unordered_map>\n#include <iterator>\n#include <assert.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef unsigned int uint;\ntypedef unsigned char uchar;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef vector<int> vi;\n\n#define REP(i,x) for(int i=0;i<(int)(x);i++)\n#define REPS(i,x) for(int i=1;i<=(int)(x);i++)\n#define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--)\n#define RREPS(i,x) for(int i=((int)(x));i>0;i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();i++)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();i++)\n#define ALL(container) (container).begin(), (container).end()\n#define RALL(container) (container).rbegin(), (container).rend()\n#define SZ(container) ((int)container.size())\n#define mp(a,b) make_pair(a, b)\n#define UNIQUE(v) v.erase( unique(v.begin(), v.end()), v.end() );\n\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"[\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"]\"; return os;\n}\ntemplate<class T> ostream& operator<<(ostream &os, const set<T> &t) {\nos<<\"{\"; FOR(it,t) {if(it!=t.begin()) os<<\",\"; os<<*it;} os<<\"}\"; return os;\n}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T> pair<S,T> operator+(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first+t.first, s.second+t.second);}\ntemplate<class S, class T> pair<S,T> operator-(const pair<S,T> &s, const pair<S,T> &t){ return pair<S,T>(s.first-t.first, s.second-t.second);}\n\nnamespace geom{\n#define X real()\n#define Y imag()\n#define at(i) ((*this)[i])\n#define SELF (*this)\n\tenum {TRUE = 1, FALSE = 0, BORDER = -1};\n\ttypedef int BOOL;\n\ttypedef long double R;\n\tconst R INF = 1e8;\n\tR EPS = 1e-12;\n\tconst R PI = 3.1415926535897932384626;\n\tinline int sig(const R &x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\tinline BOOL less(const R &x, const R &y) {return sig(x-y) ? x < y : BORDER;}\n\ttypedef complex<R> P;\n\tinline R norm(const P &p){return p.X*p.X+p.Y*p.Y;}\n\tinline R inp(const P& a, const P& b){return (conj(a)*b).X;}\n\tinline R outp(const P& a, const P& b){return (conj(a)*b).Y;}\n\tinline P unit(const P& p){return p/abs(p);}\n\tinline P proj(const P &s, const P &t){return t*inp(s, t)/norm(t);}\n\tinline int ccw(const P &s, const P &t, const P &p, int adv=0){\n\t\tint res = sig(outp(t-s, p-s));\n\t\tif(res || !adv) return res;\n\t\tif(sig(inp(t-s, p-s)) < 0) return -2;\t// p-s-t\n\t\tif(sig(inp(s-t, p-t)) < 0) return 2;\t// s-t-p\n\t\treturn 0;\t\t\t\t\t\t\t\t// s-p-t\n\t}\n\t\n\t\n\tstruct L : public vector<P>{\t// line\n\t\tL(const P &p1, const P &p2){this->push_back(p1);this->push_back(p2);}\n\t\tL(){}\n\t\tP dir()const {return at(1) - at(0);}\n\t};\n\tstruct S : public L{\t// segment\n\t\tS(const P &p1, const P &p2):L(p1, p2){}\n\t\tS(){}\n\t};\n\tstruct G : public vector<P>{\n\t\tG(size_type size=0):vector(size){}\n\t\tS edge(int i)const {return S(at(i), at(i+1 == size() ? 0 : i+1));}\n\t};\n\tBOOL intersect(const S &s, const S &t){\n\t\tconst int p = ccw(t[0], t[1], s[0], 1) * ccw(t[0], t[1], s[1], 1);\n\t\tconst int q = ccw(s[0], s[1], t[0], 1) * ccw(s[0], s[1], t[1], 1);\n\t\treturn (p>0||q>0) ? FALSE : (!p||!q) ? BORDER : TRUE;\n\t}\n\tBOOL intersect(const S &s, const L &l){\n\t\treturn (sig(outp(l.dir(), s[0]-l[0])) * sig(outp(l.dir(), s[1]-l[0])) <= 0);\n\t}\n\tinline P crosspoint(const L &l, const L &m){\n\t\tR A = outp(l.dir(), m.dir()), B = outp(l.dir(), l[1] - m[0]);\n\t\tif(!sig(abs(A)) && !sig(abs(B))) return m[0]; // same line\n\t\tif(abs(A) < EPS) assert(false); // !!!PRECONDITION NOT SATISFIED!!!\n\t\treturn m[0] + B / A * (m[1] - m[0]);\n\t}\n\n\ttemplate<class Func> R simpson(R s, R t, Func func){\n\t\treturn (t-s)/6*(func(s+2*EPS) + func(t-2*EPS) + 4*func((s+t)*(R).5));\n\t}\n#undef SELF\n#undef at\n}\n\nusing namespace geom;\n\nint f = 0;\nnamespace std{\n\tbool operator<(const P &a, const P &b){return sig(a.X-b.X) ? a.X < b.X : a.Y+EPS < b.Y;}\n\tbool operator==(const P &a, const P &b){return abs(a-b) < EPS;}\n\tistream& operator>>(istream &is, P &p){R x,y;is>>x>>y;p=P(x, y);return is;}\n\tistream& operator>>(istream &is, L &l){l.resize(2);return is >> l[0] >> l[1];}\n}\n\nint n, m;\n\nint main(){\n\tios::sync_with_stdio(false);\n\twhile(cin >> m >> n, n){\n\t\tG g1(m), g2(n);\n\t\tvector<R> x;\n\t\tREP(i, m){\n\t\t\tcin >> g1[i];\n\t\t\tx.push_back(g1[i].X);\n\t\t}\n\t\tREP(i, n){\n\t\t\tcin >> g2[i];\n\t\t\tx.push_back(g2[i].X);\n\t\t}\n\t\tsort(ALL(x));UNIQUE(x);\n\t\t\n\t\tauto width = [&](const G &g, R x){\n\t\t\tL l(P(x, 0), P(x, 1));\n\t\t\tR b = INF, u = -INF;\n\t\t\tREP(i, g.size()){\n\t\t\t\tif(sig(g.edge(i).dir().X) && intersect(g.edge(i), l)){\n\t\t\t\t\tP p = crosspoint(g.edge(i), l);\n\t\t\t\t\tb = min(b, p.Y);\n\t\t\t\t\tu = max(u, p.Y);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn max<R>(0, u-b);\n\t\t};\n\t\tauto area = [&](R x){\n\t\t\treturn width(g1, x) * width(g2, x);\n\t\t};\n\t\t\n\t\tR ans = 0;\n\t\tREP(i, (int)x.size()-1){\n\t\t\tans += simpson(x[i], x[i+1], area);\n\t\t}\n\t\tprintf(\"%.10f\\n\", (double)ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#if 0\n\n#endif\n#include <iostream>\n#include <memory>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <assert.h>\n#include <complex>\n#include <queue>\n#define rep(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\nusing namespace std;\nusing ll = long long;\nll ll_max = numeric_limits<ll>::max();\nll ll_min = numeric_limits<ll>::min();\nint int_max = numeric_limits<int>::max();\nint int_min = numeric_limits<int>::min();\nint m, n;\nvector<pair<double, double> > Pxy, Pxz;\nvector<double> X;\n\ntypedef pair<double, double> P;\nbool pairCompare(const P& firstElof, const P& secondElof) {\n    if (firstElof.first == secondElof.first)\n        return firstElof.second < secondElof.second;\n    return firstElof.first < secondElof.first;\n}\n\ndouble width(vector<pair<double, double> > polygon, double x) {\n    pair<double, double> p, q;\n    vector<double> w;\n    rep(i, polygon.size()) {\n        p = polygon[i];\n        q = polygon[(i + 1) % polygon.size()];\n        if (x == p.first)\n            w.push_back(p.second);\n        else if ((p.first < x && x < q.first) || \n                (p.first > x && x > q.first)) {\n            w.push_back(p.second + 1.0 * (q.second - p.second) * (\n                x - p.first) / (q.first - p.first));\n        }\n    }\n    sort(w.begin(), w.end());\n    return w[w.size() - 1] - w[0];\n}\n\ndouble area(double x) {\n    return width(Pxy, x) * width(Pxz, x);\n}\n\ndouble volume() {\n    double total = 0.0;\n\n    double xmin = max(Pxy[0].first, Pxz[0].first);\n    double xmax = min(Pxy[Pxy.size(\n        ) - 1].first, Pxz[Pxz.size() - 1].first);\n\n    rep(i, X.size() - 1) {\n        double a = X[i];\n        double b = X[i + 1];\n        if (!(xmin <= a && a <= xmax && xmin <= b and b <= xmax))\n            continue;\n        double areaA = area(a); \n        double areaB = area(b); \n        double areaMid = area((a + b) / 2.0); \n        total += (b - a) * (\n            areaA + 4.0 * areaMid + areaB) / 6.0;\n    }\n\n    return total;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> m >> n) {\n        if (m == 0 && n == 0) {\n            return 0;\n        }\n        double x, y;\n        X.clear();\n        Pxy.clear();\n        Pxz.clear();\n        rep(mm, m) {\n            cin >> x >> y;\n            X.push_back(x);\n            Pxy.push_back(P(x, y));\n        }\n        rep(nn, n) {\n            cin >> x >> y;\n            X.push_back(x);\n            Pxz.push_back(P(x, y));\n        }\n\n        sort(X.begin(), X.end());\n        auto itr = std::unique(X.begin(), X.end());\n        X.erase(itr, X.end());\n        \n        sort(Pxy.begin(), Pxy.end(), pairCompare);\n        sort(Pxz.begin(), Pxz.end(), pairCompare);\n        cout << volume() << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#if 0\n\n#endif\n#include <iostream>\n#include <memory>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <assert.h>\n#include <complex>\n#include <queue>\n#define rep(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\nusing namespace std;\nusing ll = long long;\nll ll_max = numeric_limits<ll>::max();\nll ll_min = numeric_limits<ll>::min();\nint int_max = numeric_limits<int>::max();\nint int_min = numeric_limits<int>::min();\nint m, n;\nvector<pair<double, double> > Pxy, Pxz;\nvector<double> X;\n\ntypedef pair<double, double> P;\nbool pairCompare(const P& firstElof, const P& secondElof) {\n    if (firstElof.first == secondElof.first)\n        return firstElof.second < secondElof.second;\n    return firstElof.first < secondElof.first;\n}\n\ndouble width(vector<pair<double, double> > polygon, double x) {\n    pair<double, double> p, q;\n    vector<double> w;\n    rep(i, polygon.size()) {\n        p = polygon[i];\n        q = polygon[(i + 1) % polygon.size()];\n        if (x == p.first)\n            w.push_back(p.second);\n        else if ((p.first < x && x < q.first) || \n                (p.first > x && x > q.first)) {\n            w.push_back(p.second + 1.0 * (q.second - p.second) * (\n                x - p.first) / (q.first - p.first));\n        }\n    }\n    sort(w.begin(), w.end());\n    return w[w.size() - 1] - w[0];\n}\n\ndouble area(double x) {\n    return width(Pxy, x) * width(Pxz, x);\n}\n\ndouble volume() {\n    double total = 0.0;\n\n    double xmin = max(Pxy[0].first, Pxz[0].first);\n    double xmax = min(Pxy[Pxy.size(\n        ) - 1].first, Pxz[Pxz.size() - 1].first);\n\n    rep(i, X.size() - 1) {\n        double a = X[i];\n        double b = X[i + 1];\n        if (!(xmin <= a && a <= xmax && xmin <= b and b <= xmax))\n            continue;\n        double areaA = area(a); \n        double areaB = area(b); \n        double areaMid = area((a + b) / 2.0); \n        total += (b - a) * (\n            areaA + 4.0 * areaMid + areaB) / 6.0;\n    }\n\n    return total;\n}\n\nint main(void){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> m >> n) {\n        if (m == 0 && n == 0) {\n            return 0;\n        }\n        double x, y;\n        X.clear();\n        Pxy.clear();\n        Pxz.clear();\n        rep(mm, m) {\n            cin >> x >> y;\n            X.push_back(x);\n            Pxy.push_back(P(x, y));\n        }\n        rep(nn, n) {\n            cin >> x >> y;\n            X.push_back(x);\n            Pxz.push_back(P(x, y));\n        }\n\n        sort(X.begin(), X.end());\n        auto itr = std::unique(X.begin(), X.end());\n        X.erase(itr, X.end());\n        \n        sort(Pxy.begin(), Pxy.end(), pairCompare);\n        sort(Pxz.begin(), Pxz.end(), pairCompare);\n        cout << volume() << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define double long double\ntypedef complex<double> P;\ndouble eps = 1e-11;\nvector<P> ps1,ps2;\nbool eq(double a,double b){\n\treturn fabs(a-b) < eps;\n}\n\nvector<double> ux;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\npair<double,double> seg(const vector<P> &ps,double x){\n\tdouble mi = 1e9, ma = -1e9;\n\tauto reflesh = [&mi,&ma](double y){\n\t\tmi = min(mi,y);\n\t\tma = max(ma,y);\n\t};\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tP a = ps[i];\n\t\tP b = ps[(i+1)%ps.size()];\n\t\tif( a.real() > b.real() ) swap(a,b);\n\t\tif( eq(a.real(),x) ) reflesh(a.imag());\n\t\tif( eq(b.real(),x) ) reflesh(b.imag());\n\t\tif( a.real() + eps < x and x < b.real() - eps ){\n\t\t\treflesh(a.imag() + (x - a.real()) * (b.imag() - a.imag()) / (b.real()-a.real()));\n\t\t}\n\t}\n\tif( ma < mi ) return {0.0,0.0};\n\treturn {mi,ma};\n}\n\ndouble Sf(double x){\n\tauto p = seg(ps1,x);\n\treturn p.second - p.first;\n}\n\ndouble Ss(double l,double r){\n\treturn (r-l)/6*(Sf(l)+4*Sf((l+r)/2)+Sf(r));\n}\n\ndouble S2(double l,double r,int k=2){\n\tif( r < l ) return 0;\n\tdouble m = (l+r)/2;\n\tdouble a = Ss(l,m);\n\tdouble b = Ss(m,r);\n\tdouble c = Ss(l,r);\n\tif( (c>eps or k <= 0) and eq(a+b,c) ){\n\t\t//cout << a+b << \" \" << c << endl;\n\t\treturn c;\n\t}else{\n\t\treturn S2(l,m,k-1) + S2(m,r,k-1);\n\t}\t\n}\ndouble S(double l,double r){\n\tdouble sans = 0;\n\tfor(int i = 0 ; i+1 < ux.size() ; i++){\n\t\tif( ux[i] != ux[i+1] ){\n\t\t\tsans += S2(max(l,ux[i]),min(r,ux[i+1]));\n\t\t}\n\t}\n\t//cout << sans << endl;\n\treturn sans;\n\t\n}\n\ndouble Vf(double z){\n\tauto p = seg(ps2,z);\n\treturn S(p.first,p.second);\n}\n\ndouble Vs(double l,double r){\n\treturn (r-l)/6*(Vf(l)+4*Vf((l+r)/2)+Vf(r));\n}\n\ndouble V(double l,double r,int k=4){\n\tdouble m = (l+r)/2;\n\tdouble a = Vs(l,m);\n\tdouble b = Vs(m,r);\n\tdouble c = Vs(l,r);\n\tif( (c>eps or k <= 0) and eq(a+b,c) ){\n\t\treturn c;\n\t}else{\n\t\treturn V(l,m,k-1) + V(m,r,k-1);\n\t}\t\n}\n\nint main(){\n\tint m,n;\n\twhile(cin >> m >> n && m ){\n\t\t\n\t\tps1.clear();\n\t\tps2.clear();\n\t\tux.clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tps1.push_back(in());\n\t\t\tux.push_back(ps1.back().real());\n\t\t}\n\n\t\tvector<double> uz;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tps2.push_back(in());\n\t\t\tps2.back() = P(ps2.back().imag(),ps2.back().real());\n\t\t\tuz.push_back(ps2.back().real());\n\t\t}\n\t\tsort(uz.begin(),uz.end());\n\t\tsort(ux.begin(),ux.end());\n\t\tdouble vans = 0;\n\t\t//for( auto z : uz ) cout << z << \" \"; cout << endl;\n\t\t//for( auto x : ux ) cout << x << \" \"; cout << endl;\n\t\tfor(int i = 0 ; i+1 < uz.size() ; i++)\n\t\t\tif( uz[i] != uz[i+1] )\n\t\t\t\tvans += V(uz[i],uz[i+1]);\n\t\tprintf(\"%.15Lf\\n\",vans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\ndouble W(vector<int> const& x, vector<int> const& y, double d) {\n    double lb = INF, ub = -INF;\n    const int N = x.size();\n    for(int i=0; i<N; ++i) {\n        double x1 = x[i], y1 = y[i];\n        double x2 = x[(i+1)%N], y2 = y[(i+1)%N];\n        if((x1 - d) * (x2 - d) <= 0 && x1 != x2) {\n            double is = y1 + (y2 - y1) * (d - x1) / (x2 - x1);\n            lb = min(lb, is);\n            ub = max(ub, is);\n        }\n    }\n    return max(0.0, ub - lb);\n}\n\nint main() {\n    int M, N;\n    while(cin >> M >> N, M) {\n        vector<int> x1(M), x2(N), y1(M), z2(N);\n        for(int i=0; i<M; ++i) {\n            cin >> x1[i] >> y1[i];\n        }\n        for(int i=0; i<N; ++i) {\n            cin >> x2[i] >> z2[i];\n        }\n        int min1 = INF, max1 = -INF;\n        int min2 = INF, max2 = -INF;\n        vector<int> xs;\n        for(int i=0; i<M; ++i) {\n            min1 = min(min1, x1[i]);\n            max1 = max(max1, x1[i]);\n            xs.push_back(x1[i]);\n        }\n        for(int i=0; i<N; ++i) {\n            min2 = min(min2, x2[i]);\n            max2 = max(max2, x2[i]);\n            xs.push_back(x2[i]);\n        }\n        sort(xs.begin(), xs.end());\n        \n        double res = 0;\n        for(int i=0; i<xs.size()-1; ++i) {\n            double a = xs[i], b = xs[i+1], c = (a + b) / 2;\n            if(min1 <= c && c <= max1 && min2 <= c && c <= max2) {\n                double fa = W(x1, y1, a) * W(x2, z2, a);\n                double fb = W(x1, y1, b) * W(x2, z2, b);\n                double fc = W(x1, y1, c) * W(x2, z2, c);\n                res += (b - a) / 6 * (fa + 4 * fc + fb);\n            }\n        }\n        cout << fixed << setprecision(10) << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\n\nconst D EPS = 1e-8;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return EQ(real(a),real(b))?imag(a)<imag(b):real(a)<real(b);\n  }\n  bool operator==(const P &a, const P &b){return EQ(a,b);}\n}\n\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\ninline int ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ninline bool para(L a,L b){return abs(cross(a.fs-a.sc,b.fs-b.sc))<EPS;}\n\ninline bool is_cp(L a,L b){\n  if(para(a,b))return false;\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ninline P line_cp(L a,L b){\n  return a.fs+(a.sc-a.fs)*cross(b.sc-b.fs,b.fs-a.fs)/cross(b.sc-b.fs,a.sc-a.fs);\n}\n\nvector<P> p[2];\ninline D len(D x, int id){\n  L l = L( P(x,-1000), P(x,1000) );\n  vector<P> res;\n  rep(i,p[id].size()){\n    L a = L( p[id][i], p[id][(i+1)%p[id].size()] );\n    if(is_cp(a,l)){\n      P cp = line_cp(a,l);\n      if(!EQ(cp,p[id][i]))res.push_back(cp);\n    }else if(para(a,l) && ccw(l.fs,l.sc,a.sc)==0){\n      res.push_back(a.sc);\n    }\n  }\n\n  if(res.size()<2)return 0;\n  return abs(res[0]-res[1]);\n}\n\ninline D f(D x){\n  return len(x/2,0) * len(x/2,1);\n}\n\nint main(){\n  int m,n;\n  while(cin >> m >> n, m){\n    int minx[2], maxx[2];\n    p[0].resize(m); p[1].resize(n);\n    minx[0] = minx[1] = 1000;\n    maxx[0] = maxx[1] = -1000;\n\n    rep(i,m){\n      int x,y;\n      cin >> x >> y;\n      p[0][i] = P(x,y);\n      minx[0]=min(minx[0],x);\n      maxx[0]=max(maxx[0],x);\n    }\n\n    rep(i,n){\n      int x,z;\n      cin >> x >> z;\n      p[1][i] = P(x,z);\n      minx[1]=min(minx[1],x);\n      maxx[1]=max(maxx[1],x);\n    }\n\n    D ans = 0;\n    for(D i=-199;i<200;i+=2){\n      if(2*minx[0]<=i && i<=2*maxx[0]){\n\tif(2*minx[1]<=i && i<=2*maxx[1]){\n\t  ans += f(i-1)+4*f(i)+f(i+1);\n\t}\n      }\n    }\n    cout << fixed << setprecision(9) << ans/6 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <set>\n#include <stdio.h>\nusing namespace std;\n\ndouble width(vector<pair<int, int> > p, double x) {\n  vector<long double> a;\n  for(int i = 0; i < p.size(); i++) {\n    pair<int, int> s, t;\n    s = p[i]; t = p[(i+1)%p.size()];\n    if(s.first == x) a.push_back(s.second);\n    else if((s.first < x && x < t.first) || (s.first > x && x > t.first)) {\n      int x0 = s.first, y0 = s.second;\n      int x1 = t.first, y1 = t.second;\n      /*if(s.first > x) {\n\tswap(x0, x1);\n\tswap(y0, y1);\n\t}*/\n      a.push_back(y0 + (y1-y0)*(x-x0)/(long double)((x1-x0)));\n    }\n  }\n  return *(max_element(a.begin(), a.end())) - *(min_element(a.begin(), a.end()));\n}\n\nint main() {\n  int m, n;\n  while(true) {\n    cin >> m >> n;\n    if(!m) break;\n    vector<pair<int, int> > p1(m), p2(n);\n    set<int> allX;\n    for(int i = 0; i < m; i++) {\n      cin >> p1[i].first >> p1[i].second;\n      allX.insert(p1[i].first);\n    }\n    for(int i = 0; i < n; i++) {\n      cin >> p2[i].first >> p2[i].second;\n      allX.insert(p2[i].first);\n    }\n    allX.insert(-1000);\n    allX.insert(1000);\n    int start, goal;\n    start = max(*(min_element(p1.begin(), p1.end())),*(min_element(p2.begin(), p2.end()))).first;\n    goal = min(*(max_element(p1.begin(), p1.end())), *(max_element(p2.begin(), p2.end()))).first;\n    long double sum = 0;\n    //cout << start << \" \" << goal << endl;\n    for(auto itr = allX.begin(); itr != allX.end(); itr++) {\n      auto next = itr;\n      next++;\n      if(*itr >= start && *itr <= goal && *next >= start && *next <= goal) {\n\t//cout << \"x: \" << *itr << \" next: \" << *next << endl;\n\tlong double m = (*itr + *next)/2.0;\n\tlong double a = width(p1, *itr)*width(p2, *itr);\n\tlong double b = width(p1, *next)*width(p2, *next);\n\tlong double c = width(p1, m)*width(p2, m);\n\tsum += (*next-*itr)/6.0*(a+4*c+b);\n      }\n    }\n    printf(\"%Lf\\n\", sum);\n  }\n  return 0;\n}\n\n\n      \n  "
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <list>\n#include <string.h>\nusing namespace std;\ntypedef long long int ll; typedef pair <int, int> P;\nconst double INF = 1000000000; const double EPS = 10e-9;\nint x1[100], y[100], x2[100], z[100];\ndouble width(int *X, int *Y, int n, double x) {\n\tdouble lb = -INF, ub = INF;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tdouble x1 = X[i], x2 = X[(i + 1) % n], y1 = Y[i], y2 = Y[(i + 1) % n];\n\t\tif ((x1 - x) * (x2 - x) > 0 || x1 == x2) continue;\n\t\tdouble y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n\t\tlb = max(lb, y);\n\t\tub = min(ub, y);\n\t}\n\treturn lb - ub;\n}\nint main()\n{\n\twhile (true)\n\t{\n\t\tvector <int> x;\n\t\tint m, n; cin >> m >> n;\n\t\tif (m == 0 && n == 0) break;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> x1[i] >> y[i];\n\t\t\tx.push_back(x1[i]);\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x2[i] >> z[i];\n\t\t\tx.push_back(x2[i]);\n\t\t}\n\t\tint minx1 = *min_element(x1, x1 + m), maxx1 = *max_element(x1, x1 + m);\n\t\tint minx2 = *min_element(x2, x2 + n), maxx2 = *max_element(x2, x2 + n);\n\t\tsort(x.begin(), x.end());\n\t\tdouble res = 0.0;\n\t\tfor (int i = 0; i + 1 < m + n; i++)\n\t\t{\n\t\t\tint a = x[i], b = x[i + 1], c = (a + b) / 2;\n\t\t\tif (minx1 < c && c < maxx1 && minx2 < c && c < maxx2)\n\t\t\t{\n\t\t\t\tdouble sa = width(x1, y, m, a) * width(x2, z, n, a);\n\t\t\t\tdouble sb = width(x1, y, m, b) * width(x2, z, n, b);\n\t\t\t\tdouble sc = width(x1, y, m, c) * width(x2, z, n, c);\n\t\t\t\tres += (b - a) / 6 * (sa + sb + 4 * sc);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10f\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nconst double INF=1e12;\nint M,N;\nint X1[100],X2[100],Y1[100],Y2[100];\n\ndouble f(int *X,int *Y,int n,double x){\n    double l=INF,r=-INF;\n    rep(i,n){\n        double x1=X[i],y1=Y[i],x2=X[(i+1)%n],y2=Y[(i+1)%n];\n        if((x1-x)*(x2-x)>0||x1==x2)continue;\n        double y=y1+(y2-y1)/(x2-x1)*(x-x1);\n        chmin(l,y);\n        chmax(r,y);\n    }\n    return max(0.0,r-l);\n}\n\nvoid solve(){\n    vint xs;\n    rep(i,M)xs.pb(X1[i]);\n    rep(i,N)xs.pb(X2[i]);\n    sort(all(xs));\n    int min1=*min_element(X1,X1+M),max1=*max_element(X1,X1+M);\n    int min2=*min_element(X2,X2+N),max2=*max_element(X2,X2+N);\n    double ans=0;\n    for(int i=0;i+1<xs.size();i++){\n        double a=xs[i],b=xs[i+1],c=(a+b)/2.0;\n        if(c<min1||c>max1||c<min2||c>max2)continue;\n        double fa=f(X1,Y1,M,a)*f(X2,Y2,N,a);\n        double fb=f(X1,Y1,M,b)*f(X2,Y2,N,b);\n        double fc=f(X1,Y1,M,c)*f(X2,Y2,N,c);\n        ans+=(b-a)/6*(fa+fb+fc*4);\n    }\n    printf(\"%.20f\\n\",ans);\n}\n\nsigned main(){\n    while(cin>>M>>N,M||N){\n        rep(i,M)cin>>X1[i]>>Y1[i];\n        rep(i,N)cin>>X2[i]>>Y2[i];\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "class in{struct It{int it;const bool rev;explicit constexpr It(int it_, bool rev=false):it(it_),rev(rev){}int operator*(){return it;}bool operator!=(It& r){return it!=r.it;}void operator++(){rev?--it:++it;}};const It i,n;public:explicit constexpr in(int n):i(0),n(n<0?0:n){}explicit constexpr in(int i,int n):i(i,n<i),n(n){}const It& begin(){return i;}const It& end(){return n;}};\n\n#include <bits/stdc++.h>\nusing namespace std;\nconst int INF = 1e9;\n\nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    auto width = [&](const vector<int>& x, const vector<int>& y, double kx) {\n        const int n = x.size();\n        double lb = INF, ub = -lb;\n        for(int i : in(n)) {\n            double x1 = x[i], y1 = y[i];\n            double x2 = x[(i + 1) % n], y2 = y[(i + 1) % n];\n            if((x1 - kx) * (x2 - kx) <= 0 && x1 != x2) {\n                double crossy = y1 + (y2 - y1) * (kx - x1) / (x2 - x1);\n                lb = min(lb, crossy);\n                ub = max(ub, crossy);\n            }\n        }\n        return max(0.0, ub - lb);\n    };\n    int p1, p2;\n    while(cin >> p1 >> p2 && p1) {\n        vector<int> x1(p1), y1(p1), x2(p2), y2(p2);\n        vector<int> xs;\n        for(int i : in(p1)) {\n            cin >> x1[i] >> y1[i];\n            xs.emplace_back(x1[i]);\n        }\n        for(int i : in(p2)) {\n            cin >> x2[i] >> y2[i];\n            xs.emplace_back(x2[i]);\n        }\n        const int min1 = *min_element(x1.begin(), x1.end()), max1 = *max_element(x1.begin(), x1.end());\n        const int min2 = *min_element(x2.begin(), x2.end()), max2 = *max_element(x2.begin(), x2.end());\n        \n        sort(xs.begin(), xs.end());\n        double res = 0;\n        for(int i : in(xs.size() - 1)) {\n            double l = xs[i], r = xs[i + 1], mid = (l + r) / 2.0;\n            if(min1 <= mid && mid <= max1 && min2 <= mid && mid <= max2) {\n                const double fa = width(x1, y1, l) * width(x2, y2, l);\n                const double fb = width(x1, y1, r) * width(x2, y2, r);\n                const double fc = width(x1, y1, mid) * width(x2, y2, mid);\n                res += (r - l) / 6 * (fa + 4 * fc + fb);\n            }\n        }\n        cout << fixed << setprecision(10) << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint m,n;\nconst double EPS = 1e-11;\nvector<pair<int,int> > Pxy,Pxz;\npair<int,int> tem;\nvector<int> X;\n\n\ndouble width(vector<pair<int,int> > polygon,double x){\n    vector<double> w;\n    for(int i=0;i<polygon.size();i++){\n        pair<int,int> p=polygon[i];\n        pair<int,int> q=polygon[(i+1)%polygon.size()];\n        if((p.first-x)<EPS){\n            w.push_back(1.0*p.second);\n        }\n        else if(p.first<x && x<q.first|| p.first>0 && x>q.first){\n            int x0=p.first;\n            int y0=p.second;\n            int x1=q.first;\n            int y1=q.second;\n            w.push_back(y0+1.0*(y1-y0)*(x-x0)/(x1-x0));\n        }\n    }\n    assert(w.size()>0);\n    vector<double>::iterator maxs=max_element(w.begin(),w.end());\n    vector<double>::iterator mins=min_element(w.begin(),w.end());\n    return (maxs-mins);\n}\n\nint volume(vector<pair<int,int> >Pxy,vector<pair<int,int> >Pxz,vector<int> X){\n    double total=0.0;\n    int xmin = max((*min_element(Pxy.begin(), Pxy.end())).first,\n                   (*min_element(Pxz.begin(), Pxz.end())).first);\n    int xmax = min((*max_element(Pxy.begin(), Pxy.end())).first,\n                   (*max_element(Pxz.begin(), Pxz.end())).first);\n    sort(X.begin(), X.end());\n    for(int i=0;i<X.size()-1;i++){\n        int a=X[i];\n        int b=X[i+1];\n        if(!(xmin <= a && a <= xmax &&xmin <= b && b<< xmax) ){\n            continue;\n        }\n        double m=(a+b)/2.0;\n        double va = width(Pxy, a)*width(Pxz, a);\n        double vb = width(Pxy, b)*width(Pxz, b);\n        double vm = width(Pxy, m)*width(Pxz, m);\n        double area=((b-a)/6.0)*(va + 4.0*vm + vb);\n        total+=area;\n    }\n    return total;\n}\nint main(){\n    while(cin>>m>>n&&n!=0){\n        for(int i=1;i<=m;i++){\n            cin>>tem.first>>tem.second;\n            Pxy.push_back(tem);\n            X.push_back(tem.first);\n        }\n        for(int j=1;j<=n;j++){\n            cin>>tem.first>>tem.second;\n            Pxz.push_back(tem);\n            X.push_back(tem.first);\n        }\n        cout << fixed << volume(Pxy, Pxz, X) << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\n\nint main() {\n    while (1) {\n        int m, n;\n        cin >> m >> n;\n        if (!m) return 0;\n        vector<P> p1(m);\n        vector<P> p2(n);\n        int c = 105;\n        for (int i = 0; i < m; ++i) {\n            cin >> p1[i].first >> p1[i].second;\n            p1[i].first += c;\n        }\n        for (int i = 0; i < n; ++i) {\n            cin >> p2[i].first >> p2[i].second;\n            p2[i].first += c;\n        }\n        vector<vector<double>> pv1(210);\n        vector<vector<double>> pv2(210);\n        for (int i = 0; i < m; ++i) {\n            pv1[p1[i].first].push_back(p1[i].second);\n            int j = (i + 1) % m;\n            if (p1[i].first < p1[j].first) {\n                double l = p1[j].first - p1[i].first;\n                for (int k = p1[i].first + 1; k < p1[j].first; ++k)\n                    pv1[k].push_back((p1[i].second * (p1[j].first - k) + p1[j].second * (k - p1[i].first)) / l);\n            }\n            if (p1[i].first > p1[j].first) {\n                double l = p1[i].first - p1[j].first;\n                for (int k = p1[i].first - 1; k > p1[j].first; --k)\n                    pv1[k].push_back((p1[i].second * (k - p1[j].first) + p1[j].second * (p1[i].first - k)) / l);\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            pv2[p2[i].first].push_back(p2[i].second);\n            int j = (i + 1) % n;\n            if (p2[i].first < p2[j].first) {\n                double l = p2[j].first - p2[i].first;\n                for (int k = p2[i].first + 1; k < p2[j].first; ++k)\n                    pv2[k].push_back((p2[i].second * (p2[j].first - k) + p2[j].second * (k - p2[i].first)) / l);\n            }\n            if (p2[i].first > p2[j].first) {\n                double l = p2[i].first - p2[j].first;\n                for (int k = p2[i].first - 1; k > p2[j].first; --k)\n                    pv2[k].push_back((p2[i].second * (k - p2[j].first) + p2[j].second * (p2[i].first - k)) / l);\n            }\n        }\n        vector<double> pd1(210);\n        vector<double> pd2(210);\n        int l1 = 300, l2 = 300, r1 = -1, r2 = -1;\n        for (int i = 0; i < 210; ++i) {\n            if (pv1[i].size()) {\n                l1 = min(l1, i);\n                r1 = max(r1, i);\n                sort(pv1[i].begin(), pv1[i].end());\n                pd1[i] = pv1[i][(int)pv1[i].size() - 1] - pv1[i][0];\n            }\n            if (pv2[i].size()) {\n                l2 = min(l2, i);\n                r2 = max(r2, i);\n                sort(pv2[i].begin(), pv2[i].end());\n                pd2[i] = pv2[i][(int)pv2[i].size() - 1] - pv2[i][0];\n            }\n        }\n        double ans = 0;\n        for (int i = max(l1, l2); i < r1 && i < r2; ++i)\n            ans += pd1[i] * pd2[i] / 3 + pd1[i] * pd2[i + 1] / 6 + pd1[i + 1] * pd2[i] / 6 + pd1[i + 1] * pd2[i + 1] / 3;\n        printf(\"%.9lf\\n\", ans);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<n;++i)\n#define FOR(i, a, b) for(int i=a;i<b;++i)\n#define RREP(i, n) for(int i=n-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=b-1;i>=a;--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\n\nusing ll = long long;\nusing ld = double;\n#define double ld\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\n\nconst double eps = 1e-8;\nconst double EPS = eps;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\n\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n  if(a < b) {a = b; return true;}\n  return false;\n}\n\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n  if(a > b) {a = b; return true;}\n  return false;\n}\n\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i != (int)(s.size())-1) cout << \" \";\n  }\n  cout << \"\\n\";\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n  os << \"[\";\n  REP(i, SZ(v)) {\n    if(i) os << \", \";\n    os << v[i];\n  }\n  return os << \"]\";\n}\n\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\n\nusing Real = double;\nconst Real PI = acos(-1);\n\nusing Point = complex<Real>;\nnamespace std {\n  bool operator<(const Point& a, const Point& b) {\n    if (a.real() == b.real()) return a.imag() < b.imag();\n    return a.real() < b.real();\n  }\n}\nstruct Line {\n  Point a, b;\n  Line() {}\n  Line(const Point& a, const Point& b) : a(a), b(b) {}\n  friend ostream& operator<<(ostream& os, const Line& l) {\n    return os << \"[\" << l.a << \",\" << l.b << \"]\";\n  }\n};\nstruct Segment : Line {\n  Segment() = default;\n\n  Segment(const Point& a, const Point& b) : Line(a, b) {}\n};\n\ninline bool eq(Real a, Real b) { return abs(b - a) < EPS; }\n\nReal radian_to_degree(Real r) {\n  return r * 180.0 / PI;\n}\n\nReal degree_to_radian(Real d) {\n  return d * PI / 180.0;\n}\n\nPoint rotate(const Point &p, Real theta) {\n  return p * polar((Real)1.0, theta);\n}\n\nReal cross(const Point& a, const Point& b) {\n  return a.real() * b.imag() - a.imag() * b.real();\n}\n\nReal dot(const Point& a, const Point& b) {\n  return a.real() * b.real() + a.imag() * b.imag();\n}\n\nPoint projection(const Line& l, const Point& p) {\n  Real A = dot(l.b - l.a, p - l.a),\n          B = dot(l.a - l.b, p - l.b);\n  return (A * l.b + B * l.a) / (A + B);\n}\n\nbool parallel(const Line& l1, const Line& l2) {\n  return eq(cross(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\n\nbool orthogonal(const Line& l1, const Line& l2) {\n  return eq(dot(l1.a - l1.b, l2.a - l2.b), 0.0);\n}\n\nconst int COUNTER_CLOCKWISE = 1,\n        CLOCKWISE = -1,\n        ONLINE_BACK = 2,\n        ONLINE_FRONT = -2,\n        ON_SEGMENT = 0;\nint ccw(const Point& a, Point b, Point c) {\n  b = b - a, c = c - a;\n  if (cross(b, c) > EPS) return COUNTER_CLOCKWISE;\n  if (cross(b, c) < -EPS) return CLOCKWISE;\n  if (dot(b, c) < 0) return ONLINE_BACK;\n  if (norm(b) < norm(c)) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersected(const Line& l, const Point& p) {\n  return abs(ccw(l.a, l.b, p)) != 1;\n}\n\nbool intersected(const Segment& s, const Point& p) {\n  return ccw(s.a, s.b, p) == 0;\n}\n\nbool intersected(const Line& l, const Segment& s) {\n  return cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool intersected(const Segment& s1, const Segment& s2) {\n  return ccw(s1.a, s1.b, s2.a) * ccw(s1.a, s1.b, s2.b) <= 0 and\n         ccw(s2.a, s2.b, s1.a) * ccw(s2.a, s2.b, s1.b) <= 0;\n}\n\nReal distance(const Line& l, const Point& p) {\n  return abs(p - projection(l, p));\n}\n\nReal distance(const Segment& s, const Point& p) {\n  Point r = projection(s, p);\n  if (intersected(s, r)) return abs(r - p);\n  return min(abs(s.a - p), abs(s.b - p));\n}\n\nReal distance(const Line &l, const Segment &s) {\n  if (intersected(l, s)) return 0;\n  return min(distance(l, s.a), distance(l, s.b));\n}\n\nReal distance(const Segment& s1, const Segment& s2) {\n  if (intersected(s1, s2)) return 0.0;\n  return min({ distance(s1, s2.a), distance(s1, s2.b),\n               distance(s2, s1.a), distance(s2, s1.b) });\n}\n\nPoint crosspoint(const Line& l1, const Line& l2) {\n  Real A = cross(l2.a - l1.a, l2.b - l1.a),\n          B = cross(l2.b - l1.b, l2.a - l1.b);\n  return (A * l1.b + B * l1.a) / (A + B);\n}\n\nstruct Circle {\n  Point p;\n  Real r;\n  Circle() {}\n  Circle(const Point& p, Real r) : p(p), r(r) {}\n};\n\n\nint intersected(Circle c1, Circle c2) {\n  if (c1.r < c2.r) swap(c1, c2);\n  Real d = abs(c1.p - c2.p);\n  if (c1.r + c2.r < d) return 4;\n  if (eq(c1.r + c2.r, d)) return 3;\n  if (c1.r - c2.r < d) return 2;\n  if (eq(c1.r - c2.r, d)) return 1;\n  return 0;\n}\n\npair<Point,Point> crosspoint(const Circle& c, const Line& l) {\n  Real h = distance(l, c.p);\n  Point p = projection(l, c.p);\n  if (eq(h, c.r)) return { p, p };\n  Point u = l.a - l.b; u /= abs(u);\n  Real d = sqrt(c.r * c.r - h * h);\n  return { p + u * d, p - u * d };\n}\n\npair<Point,Point> crosspoint(const Circle& c1, const Circle& c2) {\n  Real d = abs(c2.p - c1.p), t = arg(c2.p - c1.p);\n  Real a = acos((c1.r * c1.r + d * d - c2.r * c2.r) / (2 * c1.r * d));\n  return { c1.p + polar(c1.r, t + a),\n           c1.p + polar(c1.r, t - a) };\n}\n\npair<Point,Point> tangent(const Point& p, const Circle& c) {\n  return crosspoint(c, Circle(p, sqrt(norm(p - c.p) - c.r * c.r)));\n};\n\nvector<Line> common_tangent(const Circle& c1, const Circle& c2) {\n  vector<Line> lines;\n  Point u = c2.p - c1.p;\n  Real d = abs(u);\n  if (eq(d, 0.0)) return lines;\n  u /= d;\n  for (Real s : { -1, 1 }) {\n    Real h = (c1.r + s * c2.r) / d;\n    if (eq(abs(h), 1.0)) {\n      lines.emplace_back(\n              c1.p + u * h * c1.r,\n              c1.p + u * h * c1.r + rotate(u, PI / 2.0));\n    } else if (abs(h) < 1) {\n      Real a = acos(h);\n      lines.emplace_back(\n              c1.p + u * polar(c1.r, a),\n              c2.p - s * u * polar(c2.r, a));\n      lines.emplace_back(\n              c1.p + u * polar(c1.r, -a),\n              c2.p - s * u * polar(c2.r, -a));\n    }\n  }\n  return lines;\n}\n\ndouble width(const vector<Point> &p, double x) {\n  int sz = SZ(p);\n  double mi = INF, ma = -INF;\n  REP(i, sz) {\n    double x1 = p[i].real(), x2 = p[(i+1)%sz].real();\n    double y1 = p[i].imag(), y2 = p[(i+1)%sz].imag();\n\n    if((x1 - x) * (x2 - x) <= 0 && x1 != x2) {\n      double tmp = y1 + (y2 - y1) / (x2 - x1) * (x - x1);\n      chmin(mi, tmp);\n      chmax(ma, tmp);\n    }\n  }\n\n  return max(0.0, ma - mi);\n}\n\nbool solve() {\n  int m, n; cin >> m >> n;\n  if(m == 0 && n == 0) return false;\n\n  vector<Point> p1(m), p2(n);\n  vector<int> vx;\n\n  int mi1 = INF, ma1 = -INF;\n  REP(i, m) {\n    int x, y; cin >> x >> y;\n    p1[i] = Point(x, y);\n    vx.push_back(x);\n    chmin(mi1, x);\n    chmax(ma1, x);\n  }\n\n  int mi2 = INF, ma2 = -INF;\n  REP(i, n) {\n    int x, z; cin >> x >> z;\n    p2[i] = Point(x, z);\n    vx.push_back(x);\n    chmin(mi2, x);\n    chmax(ma2, x);\n  }\n\n  sort(ALL(vx));\n\n  vector<double> area(n+m);\n  REP(i, n+m) {\n    area[i] = width(p1, vx[i]) * width(p2, vx[i]);\n  }\n\n  double ans = 0.0;\n  REP(i, n+m-1) {\n    double dist = vx[i+1] - vx[i];\n    double b = (vx[i] + vx[i+1]) / 2.0;\n    if(!(mi1 <= b && b <= ma1 && mi2 <= b && b <= ma2)) continue;\n    double s = width(p1, b) * width(p2, b);\n\n    //if(abs(area[i] - area[i+1]) < eps) ans += area[i] * dist;\n    //else ans += dist / 3.0 * (area[i] + area[i+1] + sqrt(area[i]) * sqrt(area[i+1]));\n    ans += dist / 6 * (area[i] + 4 * s + area[i+1]);\n  }\n  cout << ans << endl;\n\n  return true;\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  while(1) {\n    if(!solve()) break;\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <map>\n#include <list>\n#include <set>\n#include <numeric>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <ctime>\nusing namespace std;\ntypedef long long LL;\ntypedef pair<double,double> P;\n\nvector<P> C1;\nvector<P> C2;\nstruct P3\n{\n\tP3(){}\n\tP3(double a, double b, double c):\n\t\tx(a),\n\t\ty(b),\n\t\tz(c)\n\t{\n\n\t}\n\tdouble x;\n\tdouble y;\n\tdouble z;\n};\nP3 operator-(P3 a, P3 b){\n\treturn P3(a.x-b.x,a.y-b.y,a.z-b.z);\n}\nint sectionAt(double x, vector<P>& C, double v[2]){\n\tint c=0;\n\tfor(int i=1;i<C.size();i++){\n\t\tif(C[i].first==x){\n\t\t\tv[c++]=C[i].second;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(C[i-1].first<x&&x<C[i].first||\n\t\t\t   C[i].first<x&&x<C[i-1].first)\n\t\t\t{\n\t\t\t\tdouble d=(x-C[i-1].first)/(C[i].first-C[i-1].first);\n\t\t\t\tv[c++]=d*C[i].second+(1-d)*C[i-1].second;\n\t\t\t}\n\t\t}\n\t}\n\tif(c==1){\n\t\tv[1]=v[0];\n\t}\n\telse if (c==2&&v[0]>v[1]){\n\t\tswap(v[0],v[1]);\n\t}\n\treturn c;\n}\ndouble volume(P3 a, P3 b, P3 c,P3 d)\n{\n\ta=a-d;\n\tb=b-d;\n\tc=c-d;\n\tdouble v=a.x*(b.y*c.z-b.z*c.y)\n\t\t     +a.y*(b.z*c.x-b.x*c.z)\n\t\t   \t +a.z*(b.x*c.y-b.y*c.x);\n\t//cout << abs(v/6);\n\treturn abs(v/6);\n}\ndouble volume(P3 p[2][2][2])\n{\n\tdouble v=0;\n\tint a=0,b=0,c=0;\n\tv+=volume(p[a][b][c],p[a^1][b][c],p[a][b^1][c],p[a][b][c^1]);\n\ta=0,b=1,c=1;\n\tv+=volume(p[a][b][c],p[a^1][b][c],p[a][b^1][c],p[a][b][c^1]);\n\ta=1,b=0,c=1;\n\tv+=volume(p[a][b][c],p[a^1][b][c],p[a][b^1][c],p[a][b][c^1]);\n\ta=1,b=1,c=0;\n\tv+=volume(p[a][b][c],p[a^1][b][c],p[a][b^1][c],p[a][b][c^1]);\n\ta=0,b=0,c=0;\n\tv+=volume(p[1][1][1],p[a^1][b][c],p[a][b^1][c],p[a][b][c^1]);\n\treturn v;\n}\n\nvoid debug(P3 p)\n{\n\tcout << p.x << \", \" << p.y << \", \" << p.z << endl;\n}\nvoid debug(P3 p[2][2][2])\n{\n\tcout << \"[\" << endl;\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\tdebug(p[i][j][k]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"]\" << endl;\n}\nvoid exec()\n{\n\t//cout << \"#\" << endl;\n\tint m,n;\n\tcin >> m >> n;\n\tif(m==0&&n==0){\n\t\texit(0);\n\t}\n\tC1.clear();\n\tC2.clear();\n\tvector<double> xs;\n\tfor(int i=0;i<m;i++){\n\t\tdouble x,y;\n\t\tcin >> x >> y;\n\t\tC1.push_back(P(x,y));\n\t\txs.push_back(x);\n\t}\n\tC1.push_back(C1[0]);\n\tfor(int i=0;i<n;i++){\n\t\tdouble x,z;\n\t\tcin >> x >> z;\n\t\tC2.push_back(P(x,z));\n\t\txs.push_back(x);\n\t}\n\tC2.push_back(C2[0]);\n\tsort(xs.begin(),xs.end());\n\tP3 ps[2][2][2];\n\tP3 (*cur)[2]=ps[0];\n\tP3 (*pre)[2]=ps[1];\n\tbool ok=false;\n\tdouble ret=0;\n\tfor(int i=0;i<xs.size();i++){\n\t\tdouble ys[2];\n\t\tint c1=sectionAt(xs[i],C1,ys);\n\t\tdouble zs[2];\n\t\tint c2=sectionAt(xs[i],C2,zs);\n\t\tif(c1&&c2)\n\t\t{\n\t\t\t//cout << xs[i] << endl;\n\t\t\tint c=0;\n\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\tcur[j][k]=P3(xs[i],ys[j],zs[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok)\n\t\t\t{\n\t\t\t\t//debug(ps);\n\t\t\t\tdouble v=volume(ps);\n\t\t\t\t//cout << v << endl;\n\t\t\t\tret+=v;\n\t\t\t}\n\t\t\tok=true;\n\t\t}\n\t\tswap(cur,pre);\n\t}\n\tcout << ret << endl;\n}\nint main() {\n\tcout.precision(20);\n\twhile(1)\n\t\texec();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n#define fs first\n#define sc second\nusing namespace std;\ntypedef long double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\n\nconst D EPS = 1e-8;\n\nnamespace std{\n  bool operator<(const P &a,const P &b){\n    return EQ(real(a),real(b))?imag(a)<imag(b):real(a)<real(b);\n  }\n  bool operator==(const P &a, const P &b){return EQ(a,b);}\n}\n\ninline D dot(P x, P y){return real(conj(x)*y);}\ninline D cross(P x, P y){return imag(conj(x)*y);}\n\nint ccw(P a,P b,P c){\n  b -= a;c -= a;\n  if (cross(b,c)>EPS) return 1;   //counter clockwise\n  if (cross(b,c)<-EPS) return -1; //clockwise\n  if (dot(b, c)<-EPS) return 2;   //c--a--b on line\n  if (abs(b)+EPS<abs(c)) return -2;   //a--b--c on line\n  return 0;                       //on segment\n}\n\ninline bool para(L a,L b){return abs(cross(a.fs-a.sc,b.fs-b.sc))<EPS;}\n\ninline bool is_cp(L a,L b){\n  if(para(a,b))return false;\n  if(ccw(a.fs,a.sc,b.fs)*ccw(a.fs,a.sc,b.sc)<=0)\n    if(ccw(b.fs,b.sc,a.fs)*ccw(b.fs,b.sc,a.sc)<=0)return true;\n  return false;\n}\n\ninline P line_cp(L a,L b){\n  return a.fs+(a.sc-a.fs)*cross(b.sc-b.fs,b.fs-a.fs)/cross(b.sc-b.fs,a.sc-a.fs);\n}\n\nvector<P> p[2];\ninline D len(D x, int id){\n  L l = L( P(x,-1000), P(x,1000) );\n  vector<P> res;\n  rep(i,p[id].size()){\n    L a = L( p[id][i], p[id][(i+1)%p[id].size()] );\n    if(is_cp(a,l)){\n      P cp = line_cp(a,l);\n      if(!EQ(cp,p[id][i]))res.push_back(cp);\n    }else if(para(a,l) && ccw(l.fs,l.sc,a.sc)==0){\n      res.push_back(a.sc);\n    }\n  }\n\n  if(res.size()<2)return 0;\n  return abs(res[0]-res[1]);\n}\n\ninline D f(D x){\n  return len(x,0) * len(x,1);\n}\n\nint main(){\n  int m,n;\n  while(cin >> m >> n, m){\n    D minx[2], maxx[2];\n    p[0].resize(m); p[1].resize(n);\n    minx[0] = minx[1] = 1000;\n    maxx[0] = maxx[1] = -1000;\n\n    rep(i,m){\n      D x,y;\n      cin >> x >> y;\n      p[0][i] = P(x,y);\n      minx[0]=min(minx[0],x);\n      maxx[0]=max(maxx[0],x);\n    }\n\n    rep(i,n){\n      D x,z;\n      cin >> x >> z;\n      p[1][i] = P(x,z);\n      minx[1]=min(minx[1],x);\n      maxx[1]=max(maxx[1],x);\n    }\n\n    D ans = 0;\n    for(D i=-100;i<100;i+=1){\n      if(minx[0]<=i+0.5 && i+0.5<=maxx[0]){\n\tif(minx[1]<=i+0.5 && i+0.5<=maxx[1]){\n\t  ans += f(i)+4*f(i+0.5)+f(i+1);\n\t}\n      }\n    }\n    cout << fixed << setprecision(9) << ans/6 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>  \n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\nconst int INF = 100000000;\n\nint M,N;\nint X1[100+10], X2[100+10], Y[100+10], Z[100+10], P[200+10];\ndouble ans;\n\ndouble width(int* X, int* YZ, int n, double x){  \n\tdouble lb=INF, ub=-INF;  \n\tfor (int i=0; i<n; i++){  \n\t\tdouble x1=X[i], y1=YZ[i], x2=X[(i+1) % n], y2=YZ[(i+1) % n];  \n\t\tif ((x1-x) * (x2-x) <= 0 && x1 != x2){   \n\t\t\tdouble y=y1 + (y2-y1) * (x-x1) / (x2-x1);  \n\t\t\tlb = min(lb, y);  \n\t\t\tub = max(ub, y);  \n\t\t}  \n\t} \n\treturn max(0.0, ub-lb);  \n}  \n\n\nvoid solve(){\n\tans = 0;\n\tint min1 = *min_element(X1,X1+M);\n\tint min2 = *min_element(X2,X2+N);\n\tint max1 = *max_element(X1,X1+M);\n\tint max2 = *max_element(X1,X2+N);\n\t\n\tsort(P,P+M+N);\n\t\t\n\tfor (int i=0; i<M+N-1; i++){\n\t\tdouble a = P[i];\n\t\tdouble b = P[i+1];\n\t\tdouble c = (a+b)/2;\n\t\tif (min1<=c && min2<=c && c<=max1 && c<=max2){\n\t\t\tdouble fa = width(X1, Y, M, a) * width(X2, Z, N, a);  \n\t\t\tdouble fb = width(X1, Y, M, b) * width(X2, Z, N, b);  \n\t\t\tdouble fc = width(X1, Y, M, c) * width(X2, Z, N, c);\n\t\t\tans += (b-a)/6*(fa+4*fc+fb);\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", ans);\n}\n\nint main() {\n\twhile ((cin >> M >> N) && M && N){\n\t\tfor (int i=0; i<M; i++){\n\t\t\tcin >> X1[i] >> Y[i];\n\t\t\tP[i] = X1[i];\n\t\t}\n\t\tfor (int i=0; i<N; i++){\n\t\t\tcin >> X2[i] >> Z[i];\n\t\t\tP[M+i] = X2[i];\n\t\t}\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\n#include <cassert>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\ntypedef vector<P> Pol;\nD eps=1e-9,Eps=1e-8;\nD cro(P a,P b){return imag(conj(a)*b);}\nint ccw(P a,P b,P c){\n\tif(cro(b-a,c-a)>eps) return 1;\n\tif(cro(b-a,c-a)<-eps) return -1;\n\tif(abs(abs(a-c)+abs(c-b)-abs(a-b))<eps) return 0;\n\tif(abs(abs(a-b)+abs(c-b)-abs(a-c))<eps) return -2;\n\treturn 2;\n}\nbool iLS(L l,L s){\n\treturn cro(l.sc-l.fs,s.fs-l.fs)*cro(l.sc-l.fs,s.sc-l.fs)<eps;\n}\nP intLL(L a,L b){\n\tD t=cro(a.sc-a.fs,a.sc-b.fs)/cro(a.sc-a.fs,b.sc-b.fs);\n\treturn b.fs+t*(b.sc-b.fs);\n}\nint M,N;\nPol a,b;\nD rec(D x){\n\tL l=L(P(x,0),P(x,1));\n\tPol inters;\n\trep(j,M){\n\t\tL e=L(a[j],a[(j+1)%M]);\n\t\tif(iLS(l,e)) inters.pb(intLL(l,e));\n\t}\n\tif(inters.size()<=1) return -1;\n\tD leny=0;\n\tfor(P p:inters) for(P q:inters) leny=max(leny,abs(p-q));\n\tinters.clear();\n\trep(j,N){\n\t\tL e=L(b[j],b[(j+1)%N]);\n\t\tif(iLS(l,e)) inters.pb(intLL(l,e));\n\t}\n\tif(inters.size()<=1) return -1;\n\tD lenz=0;\n\tfor(P p:inters) for(P q:inters) lenz=max(lenz,abs(p-q));\n\treturn leny*lenz;\n}\nint main(){\n\twhile(true){\n\t\tcin>>M>>N;\n\t\tif(M==0) break;\n\t\ta.clear(),b.clear();\n\t\tvector<D> xs;\n\t\tD ans=0;\n\t\trep(i,M){\n\t\t\tD x,y;\n\t\t\tcin>>x>>y;\n\t\t\ta.pb(P(x,y));\n\t\t\txs.pb(x-Eps);\n\t\t\txs.pb(x+Eps);\n\t\t}\n\t\trep(i,N){\n\t\t\tD x,y;\n\t\t\tcin>>x>>y;\n\t\t\tb.pb(P(x,y));\n\t\t\txs.pb(x-Eps);\n\t\t\txs.pb(x+Eps);\n\t\t}\n\t\tsort(all(xs));\n\t\trep(i,xs.size()-1){\n\t\t\tif(rec(xs[i])<-eps||rec(xs[i])<-eps) continue;\n\t\t\tans+=(xs[i+1]-xs[i])/6.0*(rec(xs[i])+4.0*rec((xs[i+1]+xs[i])/2)+rec(xs[i+1]));\n\t\t}\n\t\tprintf(\"%.12f\\n\",ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#define INF 1000000000\nusing namespace std;\nconst double g = 9.8;\nint n, m, x, y;\nint x1[105], y1[105], x2[105], z2[105];\ndouble width(int* x, int* y, int n, double xx) {\n    double lb = INF, ub = -INF;\n    for (int i = 0; i < n; ++i) {\n        double x1 = x[i], y1 = y[i], x2 = x[(i + 1) % n], y2 = y[(i + 1) % n];\n        if ((x1 - xx) * (x2 - xx) <= 0 && x1 != x2) {\n            double y = y1 + (y2 - y1) * (xx - x1) / (x2 - x1);\n            lb = min(lb, y);\n            ub = max(ub, y);\n        }\n    }\n    return max(0.0, ub - lb);\n}\nint main() {\n    while(scanf(\"%d %d\", &m, &n) && m && n) {\n        vector<int> xs;\n        int min1 = INF, max1 = -INF, min2 = INF, max2 = -INF;\n        for (int i = 0; i < m; ++i) {\n            scanf(\"%d %d\", x1 + i, y1 + i);\n            min1 = min(min1, x1[i]);\n            max1 = max(max1, x1[i]);\n            xs.push_back(x1[i]);\n        }\n        for (int i = 0; i < n; ++i) {\n            scanf(\"%d %d\", x2 + i, z2 + i);\n            min2 = min(min2, x2[i]);\n            max2 = max(max2, x2[i]);\n            xs.push_back(x2[i]);\n        }\n        sort(xs.begin(), xs.end());\n        double ans = 0;\n        for (int i = 0; i + 1 < xs.size(); ++i) {\n            double a = xs[i], b = xs[i + 1];\n            double c = (a + b) / 2;\n            if (min1 <= c && c <= max1 && min2 <= c && c <= max2) {\n                double fa = width(x1, y1, m, a) * width(x2, z2, n, a);\n                double fb = width(x1, y1, m, b) * width(x2, z2, n, b);\n                double fc = width(x1, y1, m, c) * width(x2, z2, n, c);\n                ans += (b - a) / 6 * (fa + 4 * fc + fb);\n            }\n        }\n        printf(\"%.10f\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ndouble eps = 1e-10;\nvector<P> ps1,ps2;\nbool eq(double a,double b){\n\treturn fabs(a-b) < eps;\n}\n\nvector<double> ux;\n\nP in(){\n\tdouble x,y;\n\tcin >> x >> y;\n\treturn P(x,y);\n}\npair<double,double> seg(const vector<P> &ps,double x){\n\tdouble mi = 1e9, ma = -1e9;\n\tauto reflesh = [&mi,&ma](double y){\n\t\tmi = min(mi,y);\n\t\tma = max(ma,y);\n\t};\n\tfor(int i = 0 ; i < ps.size() ; i++){\n\t\tP a = ps[i];\n\t\tP b = ps[(i+1)%ps.size()];\n\t\tif( a.real() > b.real() ) swap(a,b);\n\t\tif( eq(a.real(),x) ) reflesh(a.imag());\n\t\tif( eq(b.real(),x) ) reflesh(b.imag());\n\t\tif( a.real() + eps < x and x < b.real() - eps ){\n\t\t\treflesh(a.imag() + (x - a.real()) * (b.imag() - a.imag()) / (b.real()-a.real()));\n\t\t}\n\t}\n\tif( ma < mi ) return {0.0,0.0};\n\treturn {mi,ma};\n}\n\ndouble Sf(double x){\n\tauto p = seg(ps1,x);\n\treturn p.second - p.first;\n}\n\ndouble Ss(double l,double r){\n\treturn (r-l)/6*(Sf(l)+4*Sf((l+r)/2)+Sf(r));\n}\n\ndouble S2(double l,double r,int k=5){\n\tif( r < l ) return 0;\n\tdouble m = (l+r)/2;\n\tdouble a = Ss(l,m);\n\tdouble b = Ss(m,r);\n\tdouble c = Ss(l,r);\n\tif( (c>eps or k <= 0) and eq(a+b,c) ){\n\t\t//cout << a+b << \" \" << c << endl;\n\t\treturn c;\n\t}else{\n\t\treturn S2(l,m,k-1) + S2(m,r,k-1);\n\t}\t\n}\ndouble S(double l,double r){\n\tdouble sans = 0;\n\tfor(int i = 0 ; i+1 < ux.size() ; i++){\n\t\tif( ux[i] != ux[i+1] ){\n\t\t\tsans += S2(max(l,ux[i]),min(r,ux[i+1]));\n\t\t}\n\t}\n\t//cout << sans << endl;\n\treturn sans;\n\t\n}\n\ndouble Vf(double z){\n\tauto p = seg(ps2,z);\n\treturn S(p.first,p.second);\n}\n\ndouble Vs(double l,double r){\n\treturn (r-l)/6*(Vf(l)+4*Vf((l+r)/2)+Vf(r));\n}\n\ndouble V(double l,double r,int k=5){\n\tdouble m = (l+r)/2;\n\tdouble a = Vs(l,m);\n\tdouble b = Vs(m,r);\n\tdouble c = Vs(l,r);\n\tif( (c>eps or k <= 0) and eq(a+b,c) ){\n\t\treturn c;\n\t}else{\n\t\treturn V(l,m,k-1) + V(m,r,k-1);\n\t}\t\n}\n\nint main(){\n\tint m,n;\n\twhile(cin >> m >> n && m ){\n\t\t\n\t\tps1.clear();\n\t\tps2.clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tps1.push_back(in());\n\t\t\tux.push_back(ps1.back().real());\n\t\t}\n\n\t\tvector<double> uz;\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tps2.push_back(in());\n\t\t\tps2.back() = P(ps2.back().imag(),ps2.back().real());\n\t\t\tuz.push_back(ps2.back().real());\n\t\t}\n\t\tsort(uz.begin(),uz.end());\n\t\tsort(ux.begin(),ux.end());\n\t\tdouble vans = 0;\n\t\t//for( auto z : uz ) cout << z << \" \"; cout << endl;\n\t\t//for( auto x : ux ) cout << x << \" \"; cout << endl;\n\t\tfor(int i = 0 ; i+1 < uz.size() ; i++)\n\t\t\tif( uz[i] != uz[i+1] )\n\t\t\t\tvans += V(uz[i],uz[i+1]);\n\t\tprintf(\"%.10lf\\n\",vans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF 1e15\n\n#define MAX_N 1000\n\ndouble width(int* X,int* Y,int n,double x){\n\tdouble lb=INF,ub=-INF;\n\trep(i,n){\n\t\tdouble x1=X[i],y1=Y[i],x2=X[(i+1)%n],y2=Y[(i+1)%n];\n\t\tif((x1-x)*(x2-x)<=0&&x1!=x2){\n\t\t\tdouble y=y1+(y2-y1)*(x-x1)/(x2-x1);\n\t\t\tlb=min(lb,y);\n\t\t\tub=max(ub,y);\n\t\t}\n\t}\n\treturn max(0.0,ub-lb);\n}\n\nint M,N;\nint X1[111],Y1[111];\nint X2[111],Z2[111];\n\nint main(){\n\tcin.sync_with_stdio(false);\n\twhile(1){\n\t\tcin>>M>>N;\n\t\tif(M==0&&N==0)break;\n\t\trep(i,M)cin>>X1[i]>>Y1[i];\n\t\trep(i,N)cin>>X2[i]>>Z2[i];\n\n\t\tint min1=*min_element(X1,X1+M),max1=*max_element(X1,X1+M);\n\t\tint min2=*min_element(X2,X2+N),max2=*max_element(X2,X2+N);\n\t\tvector<int> xs;\n\t\trep(i,M)xs.pb(X1[i]);\n\t\trep(i,N)xs.pb(X2[i]);\n\t\tsort(all(xs));\n\n\t\tdouble res=0;\n\t\trep(i,xs.size()-1){\n\t\t\tdouble a=xs[i],b=xs[i+1],c=(a+b)/2;\n\t\t\tif(min1<=c&&c<=max1&&min2<=c&&c<=max2){\n\t\t\t\tdouble fa=width(X1,Y1,M,a)*width(X2,Z2,N,a);\n\t\t\t\tdouble fb=width(X1,Y1,M,b)*width(X2,Z2,N,b);\n\t\t\t\tdouble fc=width(X1,Y1,M,c)*width(X2,Z2,N,c);\n\t\t\t\tres+=(b-a)/6*(fa+4*fc+fb);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.10f\\n\", res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<sstream>\n#include<utility>\n#include<map>\n#include<vector>\n#include<queue>\n#include<algorithm>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int>P;\n#define MAX_N 100\n#define INF 10000000\nint M,N;\nint X1[MAX_N],Y1[MAX_N],X2[MAX_N],Z2[MAX_N];\n\ndouble width(int *X,int *Y,int n,double x)\n{\n\tdouble lb=INF,ub=-INF;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tdouble x1=X[i],y1=Y[i],x2=X[(i+1)%n],y2=Y[(i+1)%n];\n\t\tif((x1-x)*(x2-x)<=0&&x1!=x2)\n\t\t{\n\t\t\tdouble y=y1+(y2-y1)*(x-x1)/(x2-x1);\n\t\t\tlb=min(lb,y);\n\t\t\tub=max(ub,y);\n\t\t}\n\t}\n\treturn max(0.0,ub-lb);\n}\n\nvoid solve()\n{\n\tint min1=*min_element(X1,X1+M),max1=*max_element(X1,X1+M);\n\tint min2=*min_element(X2,X2+N),max2=*max_element(X2,X2+N);\n\tvector<int>xs;\n\tfor(int i=0;i<M;i++)xs.push_back(X1[i]);\n\tfor(int i=0;i<N;i++)xs.push_back(X2[i]);\n\tsort(xs.begin(),xs.end());\n\n\tdouble res=0;\n\tfor(int i=0;i+1<xs.size();i++)\n\t{\n\t\tdouble a=xs[i],b=xs[i+1],c=(a+b)/2;\n\t\tif(min1<=c&&c<=max1&&min2<=c&&c<=max2)\n\t\t{\n\t\t\tdouble fa=width(X1,Y1,M,a)*width(X2,Z2,N,a);\n\t\t\tdouble fb=width(X1,Y1,M,b)*width(X2,Z2,N,b);\n\t\t\tdouble fc=width(X1,Y1,M,c)*width(X2,Z2,N,c);\n\t\t\tres+=(b-a)/6*(fa+4*fc+fb);\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\",res);\n}\n\nint main()\n{\n\tfor(;scanf(\"%d%d\",&M,&N),N+M;)\n\t{\n\t\tfor(int i=0;i<M;i++)\n\t\t\tscanf(\"%d%d\",&X1[i],&Y1[i]);\n\t\tfor(int i=0;i<N;i++)\n\t\t\tscanf(\"%d%d\",&X2[i],&Z2[i]);\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef complex<double> P;\ntypedef pair<P,P> L;\n\nconst double INF = 1e+9;\nconst double EPS = 1e-8;\n\nbool equal(double a, double b){\n  return fabs(a-b) < EPS;\n}\n\ndouble dot(P a, P b){ return real(conj(a)*b); }\n\ndouble cross(P a, P b){ return imag(conj(a)*b); }\n\nint ccw(P a, P b, P c){\n  b -= a;\n  c -= a;\n  if(cross(b,c) > EPS) return 1;\n  if(cross(b,c) < -EPS) return -1;\n  if(dot(b,c) < -EPS) return 2;\n  if(norm(b) < norm(c)) return -2;\n  return 0;\n}\n\nbool isIntersectSP(L s, P p){ \n  return abs(s.first-p) + abs(s.second-p) - abs(s.second-s.first) < EPS; \n}\n\nbool isIntersect(L s1, L s2){  \n  if(max(real(s1.first), real(s1.second)) + EPS < min(real(s2.first), real(s2.second)) ||\n     max(imag(s1.first), imag(s1.second)) + EPS < min(imag(s2.first), imag(s2.second)) ||\n     max(real(s2.first), real(s2.second)) + EPS < min(real(s1.first), real(s1.second)) ||\n     max(imag(s2.first), imag(s2.second)) + EPS < min(imag(s1.first), imag(s1.second))) return false;\n\n  return ( ccw(s1.first,s1.second,s2.first) * ccw(s1.first,s1.second,s2.second) <= 0 &&\n           ccw(s2.first,s2.second,s1.first) * ccw(s2.first,s2.second,s1.second) <= 0 );\n}\n\n\nP crossPoint(L l, L m){\n  double A = cross(l.second - l.first, m.second - m.first);\n  double B = cross(l.second - l.first, l.second - m.first);\n  if(fabs(A) < EPS && fabs(B) < EPS) return m.first;\n  else if(fabs(A) >= EPS) return m.first + B / A * (m.second - m.first);\n}\n\n\nint m, n;\nvector<P> xyv, xzv;\n\nbool find(vector<double> v, double x){\n  for(int i=0;i<v.size();i++){\n    if(equal(v[i], x)) return true;\n  }\n  return false;\n}\n\ndouble calc_width(vector<P> v, double x){\n  L l = L(P(x, -INF), P(x, INF));\n  double maxy = -INF, miny = INF;\n  int n = v.size();\n\n  for(int i=0;i<n;i++){\n    if(isIntersect(l, L(v[i], v[(i+1)%n])) /*&& !equal(real(v[i]), real(v[(i+1)%n]))*/){\n      maxy = max(maxy, imag(crossPoint(L(P(x, -INF), P(x, INF)), L(v[i], v[(i+1)%n]))));\n      miny = min(miny, imag(crossPoint(L(P(x, -INF), P(x, INF)), L(v[i], v[(i+1)%n]))));\n    }\n  }\n\n  if(equal(maxy, -INF) || equal(miny, INF)) return 0;\n  else return maxy - miny;\n}\n\ndouble solve(){\n  double res = 0;\n  vector<double> xv;\n  \n  for(int i=0;i<xyv.size();i++){\n    if(!find(xv, real(xyv[i]))) xv.push_back(real(xyv[i]));\n  }\n  for(int i=0;i<xzv.size();i++){\n    if(!find(xv, real(xzv[i]))) xv.push_back(real(xzv[i]));\n  }\n  \n  sort(xv.begin(), xv.end());\n\n  for(int i=0;i<(int)xv.size()-1;i++){\n    double fa = calc_width(xyv, xv[i]+EPS) * calc_width(xzv, xv[i]+EPS);\n    double fab = calc_width(xyv, (xv[i] + xv[i+1]) / 2.0) * calc_width(xzv, (xv[i] + xv[i+1]) / 2.0);\n    double fb = calc_width(xyv, xv[i+1]-EPS) * calc_width(xzv, xv[i+1]-EPS);\n    //cout << fa << ' ' << fab << ' ' << fb << endl;\n    res += (fa + 4.0 * fab + fb) * (xv[i+1] - xv[i]) / 6.0; // simpson\n  }\n\n  return res;\n}\n\nint main(){\n  double a, b;\n  while(cin >> m >> n && (m|n)){\n    xyv.clear();\n    xzv.clear();\n    for(int i=0;i<m;i++){\n      cin >> a >> b;\n      xyv.push_back(P(a,b));\n    }\n    for(int i=0;i<n;i++){\n      cin >> a >> b;\n      xzv.push_back(P(a,b));\n    }\n    printf(\"%.10f\\n\", solve());\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint m,n;\nconst double EPS = 1e-11;\nvector<pair<int,int> > Pxy,Pyz;\npair<int,int> tem;\nvector<int> X;\n\n\ndouble width(vector<pair<int,int> > polygon,double x){\n    vector<double> w;\n    for(int i=0;i<polygon.size();i++){\n        pair<int,int> p=polygon[i];\n        pair<int,int> q=polygon[(i+1)%polygon.size()];\n        if((p.first-x)<EPS){\n            w.push_back(1.0*p.second);\n        }\n        else if(p.first<x && x<q.first|| p.first>0 && x>q.first){\n            int x0=p.first;\n            int y0=p.second;\n            int x1=q.first;\n            int y1=q.second;\n            w.push_back(y0+1.0*(y1-y0)*(x-x0)/(x1-x0));\n        }\n    }\n    assert(w.size()>0);\n    vector<double>::iterator maxs=max_element(w.begin(),w.end());\n    vector<double>::iterator mins=min_element(w.begin(),w.end());\n    return (maxs-mins);\n}\n\nint volume(vector<pair<int,int> >Pxy,vector<pair<int,int> >Pxz,vector<int> X){\n    double total=0.0;\n    int xmin = max((*min_element(pxy.begin(), pxy.end())).first,\n                   (*min_element(pxz.begin(), pxz.end())).first);\n    int xmax = min((*max_element(pxy.begin(), pxy.end())).first,\n                   (*max_element(pxz.begin(), pxz.end())).first);\n    sort(X.begin(), X.end());\n    for(int i=0;i<X.size()-1;i++){\n        int a=X[i];\n        int b=X[i+1];\n        if(!(xmin <= a && a <= xmax &&xmin <= b && b<< xmax) ){\n            continue;\n        }\n        double m=(a+b)/2.0;\n        double va = width(Pxy, a)*width(Pxz, a);\n        double vb = width(Pxy, b)*width(Pxz, b);\n        double vm = width(Pxy, m)*width(Pxz, m);\n        double area=((b-a)/6.0)*(va + 4.0*vm + vb);\n        total+=area;\n    }\n    return total;\n}\nint main(){\n    while(cin>>m>>n&&n!=0){\n        for(int i=1;i<=m;i++){\n            cin>>tem.first>>tem.second;\n            Pxy.push_back(tem);\n            X.push_back(x);\n        }\n        for(int j=1;j<=n;j++){\n            cin>>tem.first>>tem.second;\n            Pxz.push_back(tem);\n            X.push_back(x);\n        }\n        cout << fixed << volume(PXY, PXZ, X) << endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>  \n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\nconst int INF = 10000000;\n\nint M,N;\nint X1[100+10], X2[100+10], Y[100+10], Z[100+10], P[200+10];\ndouble ans;\n\ndouble width(int* X, int* YZ, int n, double x){  \n\tdouble lb=INF, ub=-INF;  \n\tfor (int i=0; i<n; i++){  \n\t\tdouble x1=X[i], y1=YZ[i], x2=X[(i+1) % n], y2=YZ[(i+1) % n];  \n\t\tif ((x1-x) * (x2-x) <= 0 && x1 != x2){   \n\t\t\tdouble y=y1 + (y2-y1) * (x-x1) / (x2-x1);  \n\t\t\tlb = min(lb, y);  \n\t\t\tub = max(ub, y);  \n\t\t}  \n\t} \n\treturn max(0.0, ub-lb);  \n}  \n\n\nvoid solve(){\n\tans = 0.0;\n\tint min1 = *min_element(X1,X1+M);\n\tint min2 = *min_element(X2,X2+N);\n\tint max1 = *max_element(X1,X1+M);\n\tint max2 = *max_element(X2,X2+N);\n\t\n\tsort(P,P+M+N);\n\t\t\n\tfor (int i=0; i<M+N-1; i++){\n\t\tdouble a = P[i];\n\t\tdouble b = P[i+1];\n\t\tdouble c = (a+b)/2;\n\t\tif (min1<=c && min2<=c && c<=max1 && c<=max2){\n\t\t\tdouble fa = width(X1, Y, M, a) * width(X2, Z, N, a);  \n\t\t\tdouble fb = width(X1, Y, M, b) * width(X2, Z, N, b);  \n\t\t\tdouble fc = width(X1, Y, M, c) * width(X2, Z, N, c);\n\t\t\tans += (b-a)/6*(fa+4*fc+fb);\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", ans);\n}\n\nint main() {\n\twhile ((cin >> M >> N) && M && N){\n\t\tfor (int i=0; i<M; i++){\n\t\t\tcin >> X1[i] >> Y[i];\n\t\t\tP[i] = X1[i];\n\t\t}\n\t\tfor (int i=0; i<N; i++){\n\t\t\tcin >> X2[i] >> Z[i];\n\t\t\tP[M+i] = X2[i];\n\t\t}\n\t\tsolve();\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nint m,n;\nconst double EPS = 1e-11;\n\n\ndouble width(vector<pair<int,int> > polygon,double x){\n    vector<double> w;\n    for(int i=0;i<polygon.size();i++){\n        pair<int,int> p=polygon[i];\n        pair<int,int> q=polygon[(i+1)%polygon.size()];\n        if(abs(p.first-x)<EPS){\n            w.push_back(1.0*p.second);\n        }\n        else if( (p.first<x && x<q.first)|| (p.first>x && x>q.first)){\n            int x0=p.first;\n            int y0=p.second;\n            int x1=q.first;\n            int y1=q.second;\n            w.push_back(y0+1.0*(y1-y0)*(x-x0)/(x1-x0));\n        }\n    }\n    assert(w.size()>0);\n    sort(w.begin(), w.end());\n    return w[w.size()-1] - w[0];\n}\n\nint volume(vector<pair<int,int> >Pxy,vector<pair<int,int> >Pxz,vector<int> X){\n    double total=0.0;\n    int xmin = max((*min_element(Pxy.begin(), Pxy.end())).first,\n                   (*min_element(Pxz.begin(), Pxz.end())).first);\n    int xmax = min((*max_element(Pxy.begin(), Pxy.end())).first,\n                   (*max_element(Pxz.begin(), Pxz.end())).first);\n    sort(X.begin(), X.end());\n    for(int i=0;i<X.size()-1;i++){\n        int a=X[i];\n        int b=X[i+1];\n        if(!(xmin <= a && a <= xmax &&xmin <= b && b<= xmax) ){\n            continue;\n        }\n        double m=(a+b)/2.0;\n        double va = width(Pxy, a)*width(Pxz, a);\n        double vb = width(Pxy, b)*width(Pxz, b);\n        double vm = width(Pxy, m)*width(Pxz, m);\n        double area=((b-a)/6.0)*(va + 4.0*vm + vb);\n        total+=area;\n    }\n    return total;\n}\nint main(){\n    while(cin>>m>>n&&n!=0){\n        vector<pair<int,int> > Pxy,Pxz;\n        pair<int,int> tem;\n        vector<int> X;\n        for(int i=1;i<=m;i++){\n            cin>>tem.first>>tem.second;\n            Pxy.push_back(tem);\n            X.push_back(tem.first);\n        }\n        for(int j=1;j<=n;j++){\n            cin>>tem.first>>tem.second;\n            Pxz.push_back(tem);\n            X.push_back(tem.first);\n        }\n        cout << fixed << volume(Pxy, Pxz, X) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 100\n\n\nint M,N;\nint X1[NUM],Y1[NUM];\nint X2[NUM],Z2[NUM];\n\ndouble width(int* X,int* Y,int N, double x){\n\tdouble lb = DBL_MAX,ub = -DBL_MAX;\n\tfor(int i = 0; i < N; i++){\n\t\tdouble x1 = X[i],y1 = Y[i],x2 = X[(i+1)%N], y2 = Y[(i+1)%N];\n\t\tif((x1-x)*(x2-x) <= 0 && x1 != x2){\n\t\t\tdouble y = y1 + (y2-y1)*(x-x1)/(x2-x1);\n\t\t\tlb = min(lb,y);\n\t\t\tub = max(ub,y);\n\t\t}\n\t}\n\treturn max(0.0,ub-lb);\n}\n\nvoid solve(){\n\tint min1 = *min_element(X1,X1+M),max1 = *max_element(X1,X1+M);\n\tint min2 = *min_element(X2,X2+N),max2 = *max_element(X2,X2+N);\n\tvector<int> xs;\n\tfor(int i = 0; i < M; i++)xs.push_back(X1[i]);\n\tfor(int i = 0; i < N; i++)xs.push_back(X2[i]);\n\tsort(xs.begin(),xs.end());\n\n\tdouble res = 0;\n\tfor(int i = 0; i+1 < xs.size(); i++){\n\t\tdouble a = xs[i],b = xs[i+1], c = (a+b)/2;\n\t\tif(min1 <= c && c < max1 && min2 <= c && c <= max2){\n\t\t\t\n\t\t\tdouble fa = width(X1,Y1,M,a)*width(X2,Z2,N,a);\n\t\t\tdouble fb = width(X1,Y1,M,b)*width(X2,Z2,N,b);\n\t\t\tdouble fc = width(X1,Y1,M,c)*width(X2,Z2,N,c);\n\t\t\tres += (b-a)/6*(fa+4*fc+fb);\n\t\t}\n\t}\n\tprintf(\"%.10lf\\n\",res);\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d\",&X1[i],&Y1[i]);\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&X2[i],&Z2[i]);\n\t}\n\n\tsolve();\n\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&M,&N);\n\t\tif(M == 0 && N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1 \n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n\n  Point(double x = 0,double y = 0): x(x),y(y){}\n\n  Point operator + (Point p){return Point(x+p.x,y+p.y);}\n  Point operator - (Point p){return Point(x-p.x,y-p.y);}\n  Point operator * (double a){return Point(a*x,a*y);}\n  Point operator / (double a){return Point(x/a,y/a);}\n  Point operator * (Point a){ return Point(x * a.x - y * a.y, x * a.y + y * a.x); }\n\n  bool operator < (const Point& p) const{ return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y); }\n\n  bool operator == (const Point& p)const{ return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS; }\n\n};\n\nstruct Segment{\n  Point p1,p2;\n  Segment(Point p1 = Point(),Point p2 = Point()):p1(p1),p2(p2){}\n  bool operator <  (const Segment& s) const { return ( p2 == s.p2 ) ? p1 < s.p1 : p2 < s.p2; }\n  bool operator == (const Segment& s) const { return ( s.p1 == p1 && s.p2 == p2 ) || ( s.p1 == p2 && s.p2 == p1 ); }\n\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\nostream& operator << (ostream& os,const Point& a){ os << \"(\" << a.x << \",\" << a.y << \")\"; }\n\nostream& operator << (ostream& os,const Segment& a){ os << \"( \" << a.p1 << \" , \" << a.p2 << \" )\"; }\n\ndouble dot(Point a,Point b){ return a.x*b.x + a.y*b.y; }\n\ndouble cross(Point a,Point b){ return a.x*b.y - a.y*b.x; }\n\ndouble norm(Point a){ return a.x*a.x+a.y*a.y; }\n\ndouble abs(Point a){ return sqrt(norm(a)); }\n\n//rad ????§???????????????¢?????§?????????????????¨\nPoint rotate(Point a,double rad){ return Point(cos(rad)*a.x - sin(rad)*a.y,sin(rad)*a.x + cos(rad)*a.y); }\n\n// ??????????????¢????????????\ndouble toRad(double agl){ return agl*M_PI/180.0; }\n\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS)return CLOCKWISE;\n  if(dot(a,b) < -EPS)return ONLINE_BACK;\n  if(norm(a) < norm(b))return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLL(Line l, Line m) {\n  return abs(cross(l.p2-l.p1, m.p2-m.p1)) > EPS || // non-parallel\n         abs(cross(l.p2-l.p1, m.p1-l.p1)) < EPS;   // same line\n}\nbool intersectLS(Line l, Line s) {\n  return cross(l.p2-l.p1, s.p1-l.p1)*       // s[0] is left of l\n         cross(l.p2-l.p1, s.p2-l.p1) < EPS; // s[1] is right of l\n}\nbool intersectLP(Line l,Point p) {\n  return abs(cross(l.p2-p, l.p1-p)) < EPS;\n}\nbool intersectSS(Line s, Line t) {\n  return ccw(s.p1,s.p2,t.p1)*ccw(s.p1,s.p2,t.p2) <= 0 &&\n         ccw(t.p1,t.p2,s.p1)*ccw(t.p1,t.p2,s.p2) <= 0;\n}\nbool intersectSP(Line s, Point p) {\n  return abs(s.p1-p)+abs(s.p2-p)-abs(s.p2-s.p1) < EPS; // triangle inequality\n}\n\nPoint projection(Line l,Point p) {\n  double t = dot(p-l.p1, l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + (l.p1-l.p2)*t;\n}\nPoint reflection(Line l,Point p) {\n  return p + (projection(l, p) - p) * 2;\n}\ndouble distanceLP(Line l, Point p) {\n  return abs(p - projection(l, p));\n}\ndouble distanceLL(Line l, Line m) {\n  return intersectLL(l, m) ? 0 : distanceLP(l, m.p1);\n}\n\ndouble distanceLS(Line l, Line s) {\n  if (intersectLS(l, s)) return 0;\n  return min(distanceLP(l, s.p1), distanceLP(l, s.p2));\n}\ndouble distanceSP(Line s, Point p) {\n  Point r = projection(s, p);\n  if (intersectSP(s, r)) return abs(r - p);\n  return min(abs(s.p1 - p), abs(s.p2 - p));\n}\n\ndouble distanceSS(Line s, Line t) {\n  if (intersectSS(s, t)) return 0;\n  return min(min(distanceSP(s, t.p1), distanceSP(s, t.p2)),\n             min(distanceSP(t, s.p1), distanceSP(t, s.p2)));\n}\n\nPoint crosspoint(Line l,Line m){\n  double A = cross(l.p2-l.p1,m.p2-m.p1);\n  double B = cross(l.p2-l.p1,l.p2-m.p1);\n  if(abs(A) < EPS && abs(B) < EPS){\n    vector<Point> vec;\n    vec.push_back(l.p1),vec.push_back(l.p2),vec.push_back(m.p1),vec.push_back(m.p2);\n    sort(vec.begin(),vec.end());\n    assert(vec[1] == vec[2]); //???????????°??????????????????\n    return vec[1];\n    //return m.p1;\n  }\n  if(abs(A) < EPS)assert(false);\n  return m.p1 + (m.p2-m.p1)*(B/A);\n}\n\n//cross product of pq and pr\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y -q.y) - (r.y - q.y) * (p.x - q.x); }\n  \n//returns true if point r is on the same line as the line pq\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\n  \n//returns true if point t is on the left side of line pq\nbool ccwtest(Point p,Point q,Point r){\n  return cross3p(p,q,r) > 0; //can be modified to accept collinear points\n}\n \nbool onSegment(Point p,Point q,Point r){\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2)) + sqrt(pow(r.x-q.x,2) + pow(r.y-q.y,2) ),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)) ) ;\n}\n\n// ---------------------------\n\nconst double DINF = 1e30;\n\ninline bool LT(double a,double b) { return !equals(a,b) && a < b; }\ninline bool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nint m,n;\nPoint ps_xy[110], ps_xz[110];\n\nbool cmp(double a,double b) { return LT(a,b); }\n\ndouble getWidth(Point *ps,int V,double x){\n  double mini = DINF, maxi = -DINF;\n  Line ururu_beam = Line(Point(x,0),Point(x,DINF));\n  rep(i,V) {\n    Segment seg = Segment(ps[i],ps[(i+1)%V]);\n\n    if( intersectLS(ururu_beam,seg) ) {\n      if( equals(cross(ururu_beam.p1-ururu_beam.p2,seg.p1-seg.p2),0.0) ) {\n        mini = min(mini,min(seg.p1.y,seg.p2.y));\n        maxi = max(maxi,max(seg.p1.y,seg.p2.y));\n        continue;\n      }\n    \n      Point cp = crosspoint(ururu_beam,seg);\n      mini = min(mini,cp.y);\n      maxi = max(maxi,cp.y);\n    }\n  }\n  return maxi - mini;\n}\n\nvoid compute(){\n  double mini[2],maxi[2];\n  rep(i,2) mini[i] = DINF, maxi[i] = -DINF;\n  vector<double> vec;\n  rep(i,m) {\n    mini[0] = min(mini[0],ps_xy[i].x), maxi[0] = max(maxi[0],ps_xy[i].x);\n    vec.push_back(ps_xy[i].x);\n  }\n  rep(i,n) {\n    mini[1] = min(mini[1],ps_xz[i].x), maxi[1] = max(maxi[1],ps_xz[i].x);\n    vec.push_back(ps_xz[i].x);\n  }\n  sort(vec.begin(),vec.end(),cmp);\n  vec.erase(unique(vec.begin(),vec.end()),vec.end());\n  double answer = 0;\n  // (b-a)/6 * ( f(a) + 4 * f((a+b)/2) + f(b) )\n  rep(i,(int)vec.size()-1){\n    double a = vec[i], b = vec[i+1];\n    double c = ( a + b ) * 0.5;\n    if( LTE(mini[0],c) && LTE(c,maxi[0]) && LTE(mini[1],c) && LTE(c,maxi[1]) ) {\n      double fa = getWidth(ps_xy,m,a) * getWidth(ps_xz,n,a);\n      double fb = getWidth(ps_xy,m,b) * getWidth(ps_xz,n,b);\n      double fc = getWidth(ps_xy,m,c) * getWidth(ps_xz,n,c);\n      answer += ( b - a ) / 6.0 * ( fa + 4.0 * fc + fb );\n    }\n  }\n  printf(\"%.10f\\n\",answer);\n}\n\nint main(int argc,char **argv){\n  while( scanf(\"%d %d\",&m,&n), m|n ){\n    rep(i,m) cin >> ps_xy[i].x >> ps_xy[i].y;\n    rep(i,n) cin >> ps_xz[i].x >> ps_xz[i].y;\n    compute();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#if 0\n\n#endif\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <iomanip>\n#define MAX_M 105\n#define MAX_N 105\n#define INF (1 << 30)\n#define rep(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\nusing namespace std;\n\nint M, N;\nint X1[MAX_M], Y1[MAX_M];\nint X2[MAX_N], Z2[MAX_N];\n\ndouble width(int X[], int Y[], int n, double x) {\n    double lb = INF, ub = -INF;\n    rep(i, n) {\n        // cout << X[i] << Y[i] << endl;\n        double x1 = X[i], y1 = Y[i];\n        double x2 = X[(i + 1) % n], y2 = Y[(i + 1) % n];\n        if ((x1 - x) * (x2 - x) <= 0 && x1 != x2) {\n            double a = (y1 - y2) / (x1 - x2);\n            double b = (y1 * x2 - y2 * x1) / (x2 - x1);\n            double y = a * x + b;\n            lb = min(lb, y);\n            ub = max(ub, y);\n        }\n    }\n    // cout << max(0.0, ub - lb) << endl;\n    // cout << \"------------\" << endl;\n    return ub - lb;\n}\n\nvoid solve() {\n    int min1 = *min_element(X1, X1 + M), max1 = *max_element(X1, X1 + M);\n    int min2 = *min_element(X2, X2 + N), max2 = *max_element(X2, X2 + N);\n    vector<int> xs;\n    rep(i, M)\n        xs.push_back(X1[i]);\n    rep(i, N)\n        xs.push_back(X2[i]);\n    sort(xs.begin(), xs.end());\n\n    double total = 0;\n    rep(i, xs.size() - 1) {\n        double a = xs[i], b = xs[i + 1], c = (a + b) / 2;\n        if (min1 <= c && c <= max1 && min2 <= c && c <= max2) {\n            double fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n            double fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n            double fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n            total += (b - a) / 6 * (fa + 4 * fc + fb);\n        }\n    }\n\n    cout << fixed << setprecision(15) << total << endl;\n}\n\nint main() {\n    while (cin >> M >> N) {\n        if (M == 0 && N == 0)\n            break;\n\n        rep(i, M)\n            cin >> X1[i] >> Y1[i];\n        rep(i, N)\n            cin >> X2[i] >> Z2[i];\n\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#define INF 500\nusing namespace std;\nint N,M;\nint X1[101],Y1[101];\nint X2[101],Z2[101];\n\ndouble width(int* X,int* Y,int n,double x){\n\tdouble lb=INF,ub=-INF;\n\tfor(int i=0;i<n;i++){\n\t\tdouble x1=X[i],y1=Y[i],x2=X[(i+1)%n],y2=Y[(i+1)%n];\n\t\tif((x1-x)*(x2-x)<=0 && x1!=x2){\n\t\t\tdouble y=y1+(y2-y1)*(x-x1)/(x2-x1);\n\t\t\tlb=min(lb,y);\n\t\t\tub=max(ub,y);\n\t\t}\n\t}\n\treturn max(0.0,ub-lb);\n}\n\nvoid solve(){\n\tint min1=*min_element(X1,X1+M),max1=*max_element(X1,X1+M);\n\tint min2=*min_element(X2,X2+N),max2=*max_element(X2,X2+N);\n\tvector<int> xs;\n\tfor(int i=0;i<M;i++){\n\t\txs.push_back(X1[i]);\n\t}\n\tfor(int i=0;i<N;i++){\n\t\txs.push_back(X2[i]);\n\t}\n\tsort(xs.begin(),xs.end());\n\tdouble res=0;\n\tfor(int i=0;i+1<xs.size();i++){\n\t\tdouble a=xs[i],b=xs[i+1],c=(a+b)/2;\n\t\tif(min1<=c && c<=max1 && min2<=c && c<=max2){\n\t\t\tdouble fa=width(X1,Y1,M,a)*width(X2,Z2,N,a);\n\t\t\tdouble fb=width(X1,Y1,M,b)*width(X2,Z2,N,b);\n\t\t\tdouble fc=width(X1,Y1,M,c)*width(X2,Z2,N,c);\n\t\t\tres+=(b-a)/6*(fa+4*fc+fb);\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\",res);\n}\n\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d %d\",&M,&N);\n\t\tif(M+N==0)break;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tscanf(\"%d %d\",&X1[i],&Y1[i]);\n\t\t}\n\t\tfor(int i=0;i<N;i++){\n\t\t\tscanf(\"%d %d\",&X2[i],&Z2[i]);\n\t\t}\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int maxn = 105, inf = 0x3f3f3f3f;\nint M, N;\nint X1[maxn], Y1[maxn], X2[maxn], Z2[maxn];\n\n//计算按x值对多边形切片得到的宽度\ndouble width(int * X, int * Y, int n, double x)\n{\n    double lb = inf, ub = -inf;\n    for (int i=0; i<n; ++i)\n    {\n        double x1 = X[i], y1 = Y[i], x2 = X[(i + 1) % n], y2 = Y[(i + 1) % n];\n        //检查与第i条边是否相交\n        if ((x1 - x) * (x2 - x) <= 0 && x1 != x2)\n        {\n            //计算交点坐标\n            double y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n            lb = min(lb, y);\n            ub = max(ub, y);\n        }\n    }\n    return max(0.0, ub - lb);\n}\n\nvoid solve()\n{\n    //枚举区间的端点\n    int min1 = *min_element(X1, X1 + M), max1 = *max_element(X1, X1 + M);\n    int min2 = *min_element(X2, X2 + N), max2 = *max_element(X2, X2 + N);\n    vector<int> xs;\n    for (int i=0; i<M; ++i) xs.push_back(X1[i]);\n    for (int i=0; i<N; ++i) xs.push_back(X2[i]);\n    sort(xs.begin(), xs.end());\n    \n    double res = 0;\n    for (int i=0; i+1<xs.size(); ++i)\n    {\n        double a = xs[i], b = xs[i+1], c = (a + b) / 2;\n        if (min1 <= c && c <= max1 && min2 <= c && c <= max2)\n        {\n            //利用Simpson公式求积分\n            double fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n            double fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n            double fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n            res += (b - a) / 6 * (fa + 4 * fc + fb);\n        }\n    }\n    printf(\"%.10f\\n\", res);\n    return;\n}\n\nint main()\n{\n    while (~scanf(\"%d %d\", &M, &N) && (M + N))\n    {\n        for (int i=0; i<M; ++i) scanf(\"%d %d\", &X1[i], &Y1[i]);\n        for (int i=0; i<N; ++i) scanf(\"%d %d\", &X2[i], &Z2[i]);\n        solve();\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <complex>\n#include <stdio.h>\n\nusing namespace std;\n\ntypedef complex<int> P;\n\ndouble getWidth(vector<P> &g, int x){\n\tdouble m = 1e10, M = -1e10;\n\tfor(int i=0;i<g.size();i++){\n\t\tP a = g[i], b = g[(i+1)%g.size()];\n\t\tif(real(a) > real(b)) swap(a, b);\n\t\tif(real(a) != real(b) && real(a) <= x && x <= real(b)){\n\t\t\tdouble mid = (double)(x-real(a))/(real(b)-real(a));\n\t\t\tdouble d = imag(a)*(1-mid)+imag(b)*mid;\n\t\t\tm = min(d, m);\n\t\t\tM = max(d, M);\n\t\t}\n\t}\n\treturn max(0.0, M-m);\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> m >> n, m){\n\t\tvector<P> gy(m), gz(n);\n\t\tint sy = 100, ey = -100, sz = 100, ez = -100; \n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> real(gy[i]) >> imag(gy[i]);\n\t\t\tsy = min(sy, real(gy[i]));\n\t\t\tey = max(ey, real(gy[i]));\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin >> real(gz[i]) >> imag(gz[i]);\n\t\t\tsz = min(sz, real(gz[i]));\n\t\t\tez = max(ez, real(gz[i]));\n\t\t}\n\t\tdouble res = 0.0;\n\t\tfor(int i=max(sy, sz);i+1<=min(ey, ez);i++){\n\t\t\tdouble py = getWidth(gy, i), cy = getWidth(gy, i+1), pz = getWidth(gz, i), cz = getWidth(gz, i+1);\n\t\t\tres += (cy*cz+(cy+py)*(cz+pz)+py*pz)/6.0;\n\t\t}\n\t\tprintf(\"%.4lf\\n\", res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <algorithm>\n#define INF 1000000000\nusing namespace std;\nint n, m, x, y;\nint x1[105], y1[105], x2[105], z2[105];\ndouble width(int x[], int y[], int n, double xx) {\n    double lb = INF, ub = -INF;\n    for (int i = 0; i < n; ++i) {\n        double x1 = x[i], y1 = y[i], x2 = x[(i + 1) % n], y2 = y[(i + 1) % n];\n        if ((x1 - xx) * (x2 - xx) <= 0 && x1 != x2) {\n            double y = y1 + (y2 - y1) * (xx - x1) / (x2 - x1);\n            lb = min(lb, y);\n            ub = max(ub, y);\n        }\n    }\n    return max(0.0, ub - lb);\n}\nint main() {\n    while(scanf(\"%d %d\", &m, &n) && m && n) {\n        vector<int> xs;\n        int min1 = INF, max1 = -INF, min2 = INF, max2 = -INF;\n        for (int i = 0; i < m; ++i) {\n            scanf(\"%d %d\", x1 + i, y1 + i);\n            min1 = min(min1, x1[i]);\n            max1 = max(max1, x1[i]);\n            xs.push_back(x1[i]);\n        }\n        for (int i = 0; i < n; ++i) {\n            scanf(\"%d %d\", x2 + i, z2 + i);\n            min2 = min(min2, x2[i]);\n            max2 = max(max2, x2[i]);\n            xs.push_back(x2[i]);\n        }\n        sort(xs.begin(), xs.end());\n        double ans = 0;\n        for (int i = 0; i + 1 < xs.size(); ++i) {\n            double a = xs[i], b = xs[i + 1];\n            double c = (a + b) / 2;\n            if (min1 <= c && c <= max1 && min2 <= c && c <= max2) {\n                double fa = width(x1, y1, m, a) * width(x2, z2, n, a);\n                double fb = width(x1, y1, m, b) * width(x2, z2, n, b);\n                double fc = width(x1, y1, m, c) * width(x2, z2, n, c);\n                ans += (b - a) / 6 * (fa + 4 * fc + fb);\n            }\n        }\n        printf(\"%.10f\\n\", ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#if 0\n\n#endif\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#define MAX_M 105\n#define MAX_N 105\n#define rep(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\nusing namespace std;\n\ndouble double_max = numeric_limits<double>::max();\ndouble double_min = numeric_limits<double>::min();\n\nint M, N;\nint X1[MAX_M], Y1[MAX_M];\nint X2[MAX_N], Z2[MAX_N];\n\ndouble width(int X[], int Y[], int n, double x) {\n    double lb = double_max, ub = -double_min;\n    rep(i, n) {\n        // cout << X[i] << Y[i] << endl;\n        double x1 = X[i], y1 = Y[i];\n        double x2 = X[(i + 1) % n], y2 = Y[(i + 1) % n];\n        if ((x1 - x) * (x2 - x) <= 0 && x1 != x2) {\n            double a = (y1 - y2) / (x1 - x2);\n            double b = (y1 * x2 - y2 * x1) / (x2 - x1);\n            double y = a * x + b;\n            lb = min(lb, y);\n            ub = max(ub, y);\n        }\n    }\n    // cout << max(0.0, ub - lb) << endl;\n    // cout << \"------------\" << endl;\n    return max(0.0, ub - lb);\n}\n\nvoid solve() {\n    int min1 = *min_element(X1, X1 + M), max1 = *max_element(X1, X1 + M);\n    int min2 = *min_element(X2, X2 + N), max2 = *max_element(X2, X2 + N);\n    vector<int> xs;\n    rep(i, M)\n        xs.push_back(X1[i]);\n    rep(i, N)\n        xs.push_back(X2[i]);\n    sort(xs.begin(), xs.end());\n\n    double total = 0;\n    for (int i = 0; i < xs.size() - 1; i++) {\n        double a = xs[i], b = xs[i + 1], c = (a + b) / 2;\n        if (min1 <= c && c <= max1 && min2 <= c && c <= max2) {\n            double fa = width(X1, Y1, M, a) * width(X2, Z2, N, a);\n            double fb = width(X1, Y1, M, b) * width(X2, Z2, N, b);\n            double fc = width(X1, Y1, M, c) * width(X2, Z2, N, c);\n            total += (b - a) / 6 * (fa + 4 * fc + fb);\n        }\n    }\n\n    cout << total << endl;\n}\n\nint main() {\n    while (cin >> M >> N) {\n        if (M == 0 && N == 0)\n            break;\n\n        rep(i, M)\n            cin >> X1[i] >> Y1[i];\n        rep(i, N)\n            cin >> X2[i] >> Z2[i];\n\n        solve();\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define INF 1e10\n#define NMMAX 100\n\nint cmp(const void *a, const void *b);\ndouble width(int *x, int *y, int m, double a);\n\nint main(void)\n{\n  int i, m, n, min1, max1, min2, max2, x1[NMMAX], y[NMMAX], x2[NMMAX], z[NMMAX], x[NMMAX*2];\n  while (scanf(\"%d %d\", &m, &n), m != 0 && n != 0) {\n    double res = 0.0;\n    scanf(\"%d %d\", &x1[0], &y[0]);\n    min1 = max1 = x[0] = x1[0];\n    for (i = 1; i < m; i++) {\n      scanf(\"%d %d\", &x1[i], &y[i]);\n      x[i] = x1[i];\n      if (x1[i] < min1) min1 = x1[i];\n      if (x1[i] > max1) max1 = x1[i];\n    }\n    scanf(\"%d %d\", &x2[0], &z[0]);\n    min2 = max2 = x[m] = x2[0];\n    for (i = 1; i < n; i++) {\n      scanf(\"%d %d\", &x2[i], &z[i]);\n      x[m+i] = x2[i];\n      if (x2[i] < min2) min2 = x2[i];\n      if (x2[i] > max2) max2 = x2[i];\n    }\n    qsort(x, m + n, sizeof(int), cmp);\n    for (i = 0; i + 1 < m + n; i++) {\n      double a = x[i], b = x[i+1], c = (a + b) / 2;\n      if (c >= min1 && c <= max1 && c >= min2 && c <= max2) {\n        double fa, fb, fc;\n        fa = width (x1, y, m, a) * width(x2, z, n, a);\n        fb = width (x1, y, m, b) * width(x2, z, n, b);\n        fc = width (x1, y, m, c) * width(x2, z, n, c);\n        res += (b - a) / 6 * (fa + 4 * fc + fb);\n      }\n    }\n    printf(\"%.10f\\n\", res);\n  }\n}\n\nint cmp(const void *a, const void *b)\n{\n  return *(int*)a - *(int*)b;\n}\ndouble width(int *x, int *y, int m, double a)\n{\n  int i;\n  double lb = INF, ub = -INF;\n  for (i = 0; i < m; i++) {\n    double x1 = x[i], y1 = y[i], x2 = x[(i+1)%m], y2 = y[(i+1)%m];\n    if ((x1 - a) * (x2 - a) <= 0 && x1 != x2) {\n      double yc = y1 + (y2 - y1) * (a - x1) / (x2 - x1);\n      if (yc < lb) lb = yc;\n      if (yc > ub) ub = yc;\n    }\n  }\n  if (ub - lb > 0) return ub - lb;\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1313: Intersection of Two Prisms\n// 2017.12.19 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint x1[101], y1[101];\nint x2[101], z2[101];\nint x[201];\n\nint cmp(int *a, int *b) { return (*a) - (*b); }\n\ndouble w(int *a, int *b, int n, int x)\n{\n\tint i, x1, y1, x2, y2;\n\tdouble l, r, u, v, y;\n\n\tl = 1e10, r = -1e10;\n\tfor (i = 0; i < n; i++) {\n\t\tx1 = a[i],   y1 = b[i];\n\t\tx2 = a[i+1], y2 = b[i+1];\n\t\tif ((x1-x)*(x2-x) <= 0 && x1 != x2) {\n\t\t\tu = (double)(y1-y2)/(x1-x2);\n\t\t\tv = (double)(y1*x2 - y2*x1)/(x2-x1);\n\t\t\ty = u*x + v;\n\t\t\tif (y < l) l = y;\n\t\t\tif (y > r) r = y;\n\t\t}\n\t}\n\tr -= l;\n\tif (r < 0) r = 0;\n\treturn r;\n}\n\nint main()\n{\n\tint m, n, i, sz, min1, max1, min2, max2, a, b, c;\n\tdouble ans, fa, fb, fc;\n\n\twhile (scanf(\"%d%d\", &m, &n) && m > 0) {\n\t\tscanf(\"%d%d\", x1, y1);\n\t\tx1[0] <<= 1, y1[0] <<= 1;\n\t\tmin1 = max1 = x1[0];\n\t\tfor (i = 1; i < m; i++) {\n\t\t\tscanf(\"%d%d\", x1+i, y1+i);\n\t\t\tx1[i] <<= 1, y1[i] <<= 1;\n\t\t\tif      (x1[i] < min1) min1 = x1[i];\n\t\t\telse if (x1[i] > max1) max1 = x1[i];\n\t\t}\n\t\tx1[m] = x1[0], y1[m] = y1[0];\n\n\t\tscanf(\"%d%d\", x2, z2);\n\t\tx2[0] <<= 1, z2[0] <<= 1;\n\t\tmin2 = max2 = x2[0];\n\t\tfor (i = 1; i < n; i++) {\n\t\t\tscanf(\"%d%d\", x2+i, z2+i);\n\t\t\tx2[i] <<= 1, z2[i] <<= 1;\n\t\t\tif      (x2[i] < min2) min2 = x2[i];\n\t\t\telse if (x2[i] > max2) max2 = x2[i];\n\t\t}\n\t\tx2[n] = x2[0], z2[n] = z2[0];\n\t\t\n\t\tmemcpy(x,   x1, sizeof(int)*m);\n\t\tmemcpy(x+m, x2, sizeof(int)*n);\n\t\tqsort(x, m+n, sizeof(int), cmp);\n\n\t\tans = 0, sz = m+n-1;\n\t\tfor (i = 0; i < sz; i++) {\n\t\t\ta = x[i], b = x[i+1], c = (a+b) >> 1;\n\t\t\tif (min1 <= c && c <= max1 && min2 <= c && c <= max2) {\n\t\t\t\tfa = w(x1, y1, m, a) * w(x2, z2, n, a);\n\t\t\t\tfb = w(x1, y1, m, b) * w(x2, z2, n, b);\n\t\t\t\tfc = w(x1, y1, m, c) * w(x2, z2, n, c);\n\t\t\t\tans += (b-a)/6.0 * (fa + 4*fc + fb);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%.13lf\\n\", ans/8);\n\t}\n \treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.List;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Scanner;\n\nclass Main {\n\tstatic int m, n;\n\tstatic double[][] pm, pn;\n\tstatic ArrayList<Double> lis;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tm = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif (m == 0 && n == 0)\n\t\t\t\tbreak;\n\t\t\tpm = new double[m][2];\n\t\t\tpn = new double[n][2];\n\t\t\tlis = new ArrayList<>();\n\t\t\tfor (int i = 0; i < m; ++i) {\n\t\t\t\tpm[i][0] = sc.nextDouble();\n\t\t\t\tpm[i][1] = sc.nextDouble();\n\t\t\t\tlis.add(pm[i][0]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tpn[i][0] = sc.nextDouble();\n\t\t\t\tpn[i][1] = sc.nextDouble();\n\t\t\t\tlis.add(pn[i][0]);\n\t\t\t}\n\t\t\tCollections.sort(lis);\n\t\t\tfor (int i = 0; i < lis.size(); ++i) {\n\t\t\t\twhile (i + 1 < lis.size() && Math.abs(lis.get(i) - lis.get(i + 1)) < 1e-6) {\n\t\t\t\t\tlis.remove(i + 1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble area = 0;\n\t\t\tfor (int i = 0; i + 1 < lis.size(); ++i) {\n\t\t\t\tdouble srcX = lis.get(i);\n\t\t\t\tdouble dstX = lis.get(i + 1);\n\t\t\t\tdouble srcArea = width(srcX, pn) * width(srcX, pm);\n\t\t\t\tdouble middleArea = width((srcX + dstX) / 2, pn) * width((srcX + dstX) / 2, pm);\n\t\t\t\tdouble dstArea = width(dstX, pn) * width(dstX, pm);\n\t\t\t\tif (Math.abs(middleArea) < 1e-6)\n\t\t\t\t\tcontinue;\n\t\t\t\tarea += (dstX - srcX) / 6 * (srcArea + dstArea + 4 * middleArea);\n\t\t\t}\n\t\t\tSystem.out.println(area);\n\t\t}\n\t}\n\n\tstatic double width(double x, double[][] arr) {\n\t\tint len = arr.length;\n\t\tdouble lb = Double.MAX_VALUE / 10;\n\t\tdouble ub = -Double.MAX_VALUE / 10;\n\t\tfor (int i = 0; i < len; ++i) {\n\t\t\tdouble x1 = arr[i][0];\n\t\t\tdouble x2 = arr[(i + 1) % len][0];\n\t\t\tdouble y1 = arr[i][1];\n\t\t\tdouble y2 = arr[(i + 1) % len][1];\n\t\t\tif (Math.abs(x1 - x2) < 1e-6)\n\t\t\t\tcontinue;\n\t\t\tif ((x - x1) * (x - x2) <= 0) {\n\t\t\t\tdouble b = (Math.abs(x - x1) * y2 + Math.abs(x - x2) * y1) / (Math.abs(x - x1) + Math.abs(x - x2));\n\t\t\t\tlb = Math.min(lb, b);\n\t\t\t\tub = Math.max(ub, b);\n\t\t\t}\n\t\t}\n\t\treturn Math.max(0, ub - lb);\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass Z {\n\t\tint x;\n\t\tdouble z;\n\n\t\tZ(int x, double z) {\n\t\t\tthis.x = x;\n\t\t\tthis.z = z;\n\t\t}\n\t}\n\n\tclass Y {\n\t\tint x;\n\t\tdouble y;\n\n\t\tY(int x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tY[] y = new Y[n];\n\t\t\tZ[] z = new Z[m];\n\n\t\t\tboolean xd[] = new boolean[204];\n\n\t\t\tint ymin = n + 1;\n\t\t\tint xminy = 300;\n\t\t\tint ymax = n + 1;\n\t\t\tint xmaxy = 0;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = sc.nextInt() + 101;\n\t\t\t\tif(xminy == x){\n\t\t\t\t\tif(ymin == i-1){\n\t\t\t\t\t\tymin++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(xmaxy == x){\n\t\t\t\t\tif(ymax == i-1){\n\t\t\t\t\t\tymax++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (xminy > x) {\n\t\t\t\t\tymin = i;\n\t\t\t\t\txminy = x;\n\t\t\t\t}\n\t\t\t\tif (xmaxy < x) {\n\t\t\t\t\tymax = i;\n\t\t\t\t\txmaxy = x;\n\t\t\t\t}\n\t\t\t\txd[x] = true;\n\t\t\t\ty[i] = new Y(x, sc.nextDouble());\n\t\t\t}\n\n\t\t\tint zmin = n + 1;\n\t\t\tint xminz = 300;\n\t\t\tint zmax = n + 1;\n\t\t\tint xmaxz = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt() + 101;\n\t\t\t\t\n\t\t\t\tif(xminz == x){\n\t\t\t\t\tif(zmin == i-1){\n\t\t\t\t\t\tzmin++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(xmaxz == x){\n\t\t\t\t\tif(zmax == i-1){\n\t\t\t\t\t\tzmax++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t\n\t\t\t\tif (xminz > x) {\n\t\t\t\t\tzmin = i;\n\t\t\t\t\txminz = x;\n\t\t\t\t}\n\t\t\t\tif (xmaxz < x) {\n\t\t\t\t\tzmax = i;\n\t\t\t\t\txmaxz = x;\n\t\t\t\t}\n\t\t\t\txd[x] = true;\n\t\t\t\tz[i] = new Z(x, sc.nextDouble());\n\t\t\t}\n\n\t\t\tint xmin = Math.max(xminy, xminz);\n\t\t\tint xmax = Math.min(xmaxz, xmaxy);\n\n\t\t\tint v = 0;\n\n\t\t\tfor (int i = xmin; i <= xmax; i++) {\n\t\t\t\tif (xd[i]) {\n\t\t\t\t\tv++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint x[] =new int[v];\n\n\t\t\t{\n\t\t\t\tint j = 0;\n\t\t\t\tfor (int i = xmin; i <= xmax; i++) {\n\t\t\t\t\tif (xd[i]) {\n\t\t\t\t\t\tx[j] = i;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble y_m[] = new double[v];\n\t\t\t{\n\t\t\t\tint j = ymin;\n\t\t\t\tfor (int i = 0; i < v; i++) {\n\n//\t\t\t\t\tSystem.out.println(x[i] - 101 +\" \"+j+\"(\"+y[j].y+\")\"+\"----\");\n\t\t\t\t\tif (y[j].x == x[i]) {\n\t\t\t\t\t\ty_m[i] = y[j].y;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (; y[(j + 1) % n].x < x[i]; j = (j + 1) % n) {\n\t//\t\t\t\t\t System.out.println(y[(j+1)%n].x+\" \"+x[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (y[(j + 1) % n].x == x[i]) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tj = j % n;\n\t\t\t\t\t\ty_m[i] = y[j].y;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdouble ry = (y[(j + 1) % n].y - y[j].y) * (x[i] - y[j].x)\n\t\t\t\t\t\t\t/ (y[(j + 1) % n].x - y[j].x) + y[j].y;\n\t\t\t\t\ty_m[i] = ry;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble z_m[] = new double[v];\n\t\t\t{\n\t\t\t\tint j = zmin;\n\t\t\t\tfor (int i = 0; i < v; i++) {\n\n\t\t\t\t\tif (z[j].x == x[i]) {\n\t\t\t\t\t\tz_m[i] = z[j].z;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (; z[(j + 1) % m].x < x[i]; j = (j + 1) % m)\n\t\t\t\t\t\t;\n\n\t\t\t\t\tif (z[(j + 1) % m].x == x[i]) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tj = j % m;\n\t\t\t\t\t\tz_m[i] = z[j].z;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdouble rz = (z[(j + 1) % m].z - z[j].z) * (x[i] - z[j].x)\n\t\t\t\t\t\t\t/ (z[(j + 1) % m].x - z[j].x) + z[j].z;\n\t\t\t\t\tz_m[i] = rz;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble y_k[] = new double[v];\n\t\t\t{\n\t\t\t\tint j = ymax;\n\t\t\t\tfor (int i = v - 1; i >= 0; i--) {\n\n\t\t\t\t\tif (y[j].x == x[i]) {\n\t\t\t\t\t\ty_k[i] = y[j].y;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (; y[(j + 1) % n].x > x[i]; j = (j + 1) % n)\n\t\t\t\t\t\t;\n\n\t\t\t\t\tif (y[(j + 1) % n].x == x[i]) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tj = j % n;\n\t\t\t\t\t\ty_k[i] = y[j].y;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdouble ry = (y[(j + 1) % n].y - y[j].y) * (x[i] - y[j].x)\n\t\t\t\t\t\t\t/ (y[(j + 1) % n].x - y[j].x) + y[j].y;\n\t\t\t\t\ty_k[i] = ry;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble z_k[] = new double[v];\n\t\t\t{\n\t\t\t\tint j = zmax;\n\t\t\t\tfor (int i = v - 1; i >= 0; i--) {\n\n\t\t\t\t\tif (z[j].x == x[i]) {\n\t\t\t\t\t\tz_k[i] = z[j].z;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (; z[(j + 1) % m].x > x[i]; j = (j + 1) % m)\n\t\t\t\t\t\t;\n\n\t\t\t\t\tif (z[(j + 1) % m].x == x[i]) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tj = j % m;\n\t\t\t\t\t\tz_k[i] = z[j].z;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdouble rz = (z[(j + 1) % m].z - z[j].z) * (x[i] - z[j].x)\n\t\t\t\t\t\t\t/ (z[(j + 1) % m].x - z[j].x) + z[j].z;\n\t\t\t\t\tz_k[i] = rz;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble ans = 0;\n\t\t\t{\n\t\t\t\tint i = 0;\n//\t\t\t\tSystem.out.println((x[i] - 101) + \" \" + y_k[i] + \" \" + y_m[i]\n//\t\t\t\t\t\t+ \" \" + z_k[i] + \" \" + z_m[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < v - 1; i++) {\n\n//\t\t\t\tSystem.out.println((x[i + 1] - 101) + \" \" + y_k[i + 1] + \" \"\n//\t\t\t\t\t\t+ y_m[i + 1] + \" \" + z_k[i + 1] + \" \" + z_m[i + 1]);\n\n\t\t\t\tdouble dx = x[i + 1] - x[i];\n\t\t\t\tdouble y2 = y_k[i + 1] - y_m[i + 1];\n\t\t\t\tdouble y0 = y_k[i] - y_m[i];\n\n\t\t\t\tdouble yl = Math.max(y2, y0);\n\t\t\t\tdouble ys = Math.min(y2, y0);\n\n\t\t\t\tdouble z2 = z_k[i + 1] - z_m[i + 1];\n\t\t\t\tdouble z0 = z_k[i] - z_m[i];\n\n\t\t\t\tdouble zl = Math.max(z2, z0);\n\t\t\t\tdouble zs = Math.min(z2, z0);\n\t\t\t\t\n\t\t\t\tzl = z0;\n\t\t\t\tzs = z2;\n\t\t\t\tyl = y0;\n\t\t\t\tys = y2;\n\n\t\t\t\tdouble a = (yl - ys) / dx;\n\t\t\t\tdouble b = (zl - zs) / dx;\n\t\t\t\tdouble v2 = (a * b * dx * dx * dx / 3. + (a * zs + b * ys) *dx* dx / 2. + ys\n\t\t\t\t\t\t* zs * dx) ;\n//\t\t\t\tSystem.out.println(\" \"+a+ \" \"+b+\" \"+ys+\" \"+zs+\" \"+ v2);\n\t\t\t\tans+=Math.abs(v2);\n\t\t\t}\n\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tclass Z {\n\t\tint x;\n\t\tdouble z;\n\n\t\tZ(int x, double z) {\n\t\t\tthis.x = x;\n\t\t\tthis.z = z;\n\t\t}\n\t}\n\n\tclass Y {\n\t\tint x;\n\t\tdouble y;\n\n\t\tY(int x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tif ((n | m) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tY[] y = new Y[n];\n\t\t\tZ[] z = new Z[m];\n\n\t\t\tboolean xd[] = new boolean[204];\n\n\t\t\tint ymin = n + 1;\n\t\t\tint xminy = 300;\n\t\t\tint ymax = n + 1;\n\t\t\tint xmaxy = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tint x = sc.nextInt() + 101;\n\t\t\t\tif (xminy >= x) {\n\t\t\t\t\tymin = i;\n\t\t\t\t\txminy = x;\n\t\t\t\t}\n\t\t\t\tif (xmaxy <= x) {\n\t\t\t\t\tymax = i;\n\t\t\t\t\txmaxy = x;\n\t\t\t\t}\n\t\t\t\txd[x] = true;\n\t\t\t\ty[i] = new Y(x, sc.nextDouble());\n\t\t\t}\n\n\t\t\tint zmin = n + 1;\n\t\t\tint xminz = 300;\n\t\t\tint zmax = n + 1;\n\t\t\tint xmaxz = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint x = sc.nextInt() + 101;\n\t\t\t\tif (xminz >= x) {\n\t\t\t\t\tzmin = i;\n\t\t\t\t\txminz = x;\n\t\t\t\t}\n\t\t\t\tif (xmaxz <= x) {\n\t\t\t\t\tzmax = i;\n\t\t\t\t\txmaxz = x;\n\t\t\t\t}\n\t\t\t\txd[x] = true;\n\t\t\t\tz[i] = new Z(x, sc.nextDouble());\n\t\t\t}\n\n\t\t\tint xmin = Math.max(xminy, xminz);\n\t\t\tint xmax = Math.min(xmaxz, xmaxy);\n\n\t\t\tint v = 0;\n\n\t\t\tfor (int i = xmin; i <= xmax; i++) {\n\t\t\t\tif (xd[i]) {\n\t\t\t\t\tv++;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint x[] = new int[v];\n\n\t\t\t{\n\t\t\t\tint j = 0;\n\t\t\t\tfor (int i = xmin; i <= xmax; i++) {\n\t\t\t\t\tif (xd[i]) {\n\t\t\t\t\t\tx[j] = i;\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble y_m[] = new double[v];\n\t\t\t{\n\t\t\t\tint j = ymin;\n\t\t\t\tfor (int i = 0; i < v; i++) {\n\n//\t\t\t\t\tSystem.out.println(x[i] - 101 +\" \"+j+\"(\"+y[j].y+\")\"+\"----\");\n\t\t\t\t\tif (y[j].x == x[i]) {\n\t\t\t\t\t\ty_m[i] = y[j].y;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (; y[(j + 1) % n].x < x[i]; j = (j + 1) % n) {\n\t//\t\t\t\t\t System.out.println(y[(j+1)%n].x+\" \"+x[i]);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (y[(j + 1) % n].x == x[i]) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tj = j % n;\n\t\t\t\t\t\ty_m[i] = y[j].y;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdouble ry = (y[(j + 1) % n].y - y[j].y) * (x[i] - y[j].x)\n\t\t\t\t\t\t\t/ (y[(j + 1) % n].x - y[j].x) + y[j].y;\n\t\t\t\t\ty_m[i] = ry;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble z_m[] = new double[v];\n\t\t\t{\n\t\t\t\tint j = zmin;\n\t\t\t\tfor (int i = 0; i < v; i++) {\n\n\t\t\t\t\tif (z[j].x == x[i]) {\n\t\t\t\t\t\tz_m[i] = z[j].z;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (; z[(j + 1) % m].x < x[i]; j = (j + 1) % m)\n\t\t\t\t\t\t;\n\n\t\t\t\t\tif (z[(j + 1) % m].x == x[i]) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tj = j % m;\n\t\t\t\t\t\tz_m[i] = z[j].z;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdouble rz = (z[(j + 1) % m].z - z[j].z) * (x[i] - z[j].x)\n\t\t\t\t\t\t\t/ (z[(j + 1) % m].x - z[j].x) + z[j].z;\n\t\t\t\t\tz_m[i] = rz;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble y_k[] = new double[v];\n\t\t\t{\n\t\t\t\tint j = ymax;\n\t\t\t\tfor (int i = v - 1; i >= 0; i--) {\n\n\t\t\t\t\tif (y[j].x == x[i]) {\n\t\t\t\t\t\ty_k[i] = y[j].y;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (; y[(j + 1) % n].x > x[i]; j = (j + 1) % n)\n\t\t\t\t\t\t;\n\n\t\t\t\t\tif (y[(j + 1) % n].x == x[i]) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tj = j % n;\n\t\t\t\t\t\ty_k[i] = y[j].y;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdouble ry = (y[(j + 1) % n].y - y[j].y) * (x[i] - y[j].x)\n\t\t\t\t\t\t\t/ (y[(j + 1) % n].x - y[j].x) + y[j].y;\n\t\t\t\t\ty_k[i] = ry;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble z_k[] = new double[v];\n\t\t\t{\n\t\t\t\tint j = zmax;\n\t\t\t\tfor (int i = v - 1; i >= 0; i--) {\n\n\t\t\t\t\tif (z[j].x == x[i]) {\n\t\t\t\t\t\tz_k[i] = z[j].z;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tfor (; z[(j + 1) % m].x > x[i]; j = (j + 1) % m)\n\t\t\t\t\t\t;\n\n\t\t\t\t\tif (z[(j + 1) % m].x == x[i]) {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tj = j % m;\n\t\t\t\t\t\tz_k[i] = z[j].z;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tdouble rz = (z[(j + 1) % m].z - z[j].z) * (x[i] - z[j].x)\n\t\t\t\t\t\t\t/ (z[(j + 1) % m].x - z[j].x) + z[j].z;\n\t\t\t\t\tz_k[i] = rz;\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble ans = 0;\n\t\t\t{\n\t\t\t\tint i = 0;\n//\t\t\t\tSystem.out.println((x[i] - 101) + \" \" + y_k[i] + \" \" + y_m[i]\n//\t\t\t\t\t\t+ \" \" + z_k[i] + \" \" + z_m[i]);\n\t\t\t}\n\t\t\tfor (int i = 0; i < v - 1; i++) {\n\n//\t\t\t\tSystem.out.println((x[i + 1] - 101) + \" \" + y_k[i + 1] + \" \"\n//\t\t\t\t\t\t+ y_m[i + 1] + \" \" + z_k[i + 1] + \" \" + z_m[i + 1]);\n\n\t\t\t\tdouble dx = x[i + 1] - x[i];\n\t\t\t\tdouble y2 = y_k[i + 1] - y_m[i + 1];\n\t\t\t\tdouble y0 = y_k[i] - y_m[i];\n\n\t\t\t\tdouble yl = Math.max(y2, y0);\n\t\t\t\tdouble ys = Math.min(y2, y0);\n\n\t\t\t\tdouble z2 = z_k[i + 1] - z_m[i + 1];\n\t\t\t\tdouble z0 = z_k[i] - z_m[i];\n\n\t\t\t\tdouble zl = Math.max(z2, z0);\n\t\t\t\tdouble zs = Math.min(z2, z0);\n\t\t\t\t\n\t\t\t\tzl = z0;\n\t\t\t\tzs = z2;\n\t\t\t\tyl = y0;\n\t\t\t\tys = y2;\n\n\t\t\t\tdouble a = (yl - ys) / dx;\n\t\t\t\tdouble b = (zl - zs) / dx;\n\t\t\t\tdouble v2 = (a * b * dx * dx * dx / 3. + (a * zs + b * ys) *dx* dx / 2. + ys\n\t\t\t\t\t\t* zs * dx) ;\n//\t\t\t\tSystem.out.println(\" \"+a+ \" \"+b+\" \"+ys+\" \"+zs+\" \"+ v2);\n\t\t\t\tans+=v2;\n\t\t\t}\n\n\t\t\tSystem.out.println(ans);\n\t\t}\n\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tMain m = new Main();\n\t\tm.run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tint m,n;\n\tint [] x1,x2,y1,z2;\n\tint INF = 1 << 24;\n\t\n\t//SYAKYO\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tm = sc.nextInt();\n\t\t\tn = sc.nextInt();\n\t\t\tif((m | n) == 0) break;\n\t\t\tx1 = new int[m];\n\t\t\ty1 = new int[m];\n\t\t\tx2 = new int[n];\n\t\t\tz2 = new int[n];\n\t\t\tfor(int i = 0 ; i < m; i++){\n\t\t\t\tx1[i] = sc.nextInt();\n\t\t\t\ty1[i] = sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\tx2[i] = sc.nextInt();\n\t\t\t\tz2[i] = sc.nextInt();\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\tprivate void solve() {\n\t\tint min1 = minAll(x1);\n\t\tint max1 = maxAll(x1);\n\t\tint min2 = minAll(x2);\n\t\tint max2 = maxAll(x2);\n\t\tArrayList<Integer> xs = new ArrayList<Integer>();\n\t\tfor(int i = 0 ; i < m; i++){\n\t\t\txs.add(x1[i]);\n\t\t}\n\t\tfor(int i = 0 ; i < n; i++){\n\t\t\txs.add(x2[i]);\n\t\t}\n\t\tCollections.sort(xs);\n\t\t\n\t\tdouble res = 0;\n\t\tfor(int i = 0 ; i + 1 < xs.size(); i++){\n\t\t\tdouble a = xs.get(i), b = xs.get(i+1), c = (a + b) / 2;\n\t\t\tif(min1 <= c && c <= max1 && min2 <= c && c <= max2){\n\t\t\t\tdouble fa = width(x1, y1, m, a) * width(x2, z2, n, a);\n\t\t\t\tdouble fb = width(x1, y1, m, b) * width(x2, z2, n, b);\n\t\t\t\tdouble fc = width(x1, y1, m, c) * width(x2, z2, n, c);\n\t\t\t\tres += (b-a) / 6 * (fa + 4 * fc + fb);\n\t\t\t}\n\t\t}\n\t\tSystem.out.printf(\"%.10f\\n\", res);\n\t}\n\tprivate double width(int[] X, int[] Y, int n, double x) {\n\t\tdouble lb = INF, ub = -INF;\n\t\tfor(int i = 0 ; i < n; i++){\n\t\t\tdouble x1 = X[i], y1 = Y[i], x2 = X[ (i + 1) % n], y2 = Y[(i+1) % n];\n\t\t\tif((x1 - x) * (x2 - x) <= 0 && x1 != x2){\n\t\t\t\tdouble y = y1 + (y2 - y1) * (x - x1) / (x2 - x1);\n\t\t\t\tlb = Math.min(lb,  y);\n\t\t\t\tub = Math.max(ub, y);\n\t\t\t}\n\t\t}\n\t\treturn Math.max(0.0, ub - lb);\n\t}\n\tprivate int minAll(int[] x) {\n\t\tint res = x[0];\n\t\tfor(int i = 1; i < x.length; i++){\n\t\t\tres = Math.min(res, x[i]);\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tprivate int maxAll(int[] x) {\n\t\tint res = x[0];\n\t\tfor(int i = 1; i < x.length; i++){\n\t\t\tres = Math.max(res, x[i]);\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nINF = Float::INFINITY\n\n### classes\n\nclass Pt\n  attr_accessor :x, :y\n\n  def initialize() end\n  def initialize(_x, _y) @x = _x; @y = _y end\n\n  def ==(pt) @x == pt.x && @y == pt.y end\n  def +(pt) Pt.new(@x + pt.x, @y + pt.y) end\n  def -(pt) Pt.new(@x - pt.x, @y - pt.y) end\n  def -@() Pt.new(-@x, -@y) end\n  def *(t) Pt.new(@x * t, @y * t) end\n  def /(t) Pt.new(@x / t, @y / t) end\n  def dot(v) @x * v.x + @y * v.y end\n  def cross(v) @x * v.y - @y * v.x end\n  def d2() @x * @x + @y * @y end\n  def d() Math.sqrt(d2()) end\n  def normalize() self / d() end\n  def to_s() \"(#{@x},#{@y})\" end\n  def to_a() [@x, @y] end\nend\n\n### subroutines\n\ndef cutlen(x, ys, k)\n  miny = INF\n  maxy = -INF\n  for i in (0...k)\n    pt0 = ys[i]\n    pt1 = ys[(i + 1) % k]\n    v = pt1 - pt0\n    if v.x != 0.0 && (pt0.x <= x && x <= pt1.x || pt1.x <= x && x <= pt0.x)\n      y = v.y * (x - pt0.x) / v.x + pt0.y\n      miny = y if miny > y\n      maxy = y if maxy < y\n    end\n  end\n\n  (maxy >= miny) ? maxy - miny : 0.0\nend\n\n### main\n\nloop do\n  m, n = gets.split.map(&:to_i)\n  break if (m | n) == 0\n\n  xys = m.times.map{Pt.new(*gets.split.map(&:to_f))}\n  xzs = n.times.map{Pt.new(*gets.split.map(&:to_f))}\n  #p [xys.map{|pt| pt.to_s}, xzs.map{|pt| pt.to_s}]\n\n  xmin0 = xys.map{|pt| pt.x}.min\n  xmax0 = xys.map{|pt| pt.x}.max\n  xmin1 = xzs.map{|pt| pt.x}.min\n  xmax1 = xzs.map{|pt| pt.x}.max\n\n  xs = (xys.map{|pt| pt.x} + xzs.map{|pt| pt.x}).sort.uniq\n  nxs = xs.length\n  #p [xmin0, xmax0, xmin1, xmax1]\n  #p xs\n\n  dys = nxs.times.map{0.0}\n  dzs = nxs.times.map{0.0}\n  for i in (0...nxs)\n    xi = xs[i]\n    if xmin0 <= xi && xi <= xmax0\n      dys[i] = cutlen(xi, xys, m)\n    end\n    if xmin1 <= xi && xi <= xmax1\n      dzs[i] = cutlen(xi, xzs, n)\n    end\n  end\n  #p [dys, dzs]\n  \n  vol = 0.0\n\n  (0...nxs).each_cons(2) do |i0, i1|\n    x0 = xs[i0]\n    x1 = xs[i1]\n    if xmin0 <= x0 && x1 <= xmax0 && xmin1 <= x0 && x1 <= xmax1\n      dy0 = dys[i0]\n      dz0 = dzs[i0]\n      dy1 = dys[i1]\n      dz1 = dzs[i1]\n      v = (x1 - x0) * (dy0 * dz1 + dy1 * dz0 + 2 * (dy0 * dz0 + dy1 * dz1)) / 6\n      vol += v\n    end\n  end\n\n  puts vol\nend"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef solve():\n    M, N = map(int, readline().split())\n    if M == N == 0:\n        return False\n    P = [list(map(int, readline().split())) for i in range(M)]\n    Q = [list(map(int, readline().split())) for i in range(N)]\n    xs = set()\n    xs.update(x for x, y in P)\n    xs.update(x for x, z in Q)\n    *X, = xs\n    X.sort()\n    def calc(x):\n        y_ma = -100; y_mi = 100\n        for i in range(M):\n            x0, y0 = P[i-1]; x1, y1 = P[i]\n            if x0 <= x <= x1 or x1 <= x <= x0:\n                if x0 == x1:\n                    y_ma = max(y_ma, max(y1, y0))\n                    y_mi = min(y_mi, min(y1, y0))\n                else:\n                    y = (x - x0)*(y1-y0) / (x1-x0) + y0\n                    y_ma = max(y_ma, y)\n                    y_mi = min(y_mi, y)\n        if not y_mi <= y_ma:\n            return 0\n        z_ma = -100; z_mi = 100\n        for i in range(N):\n            x0, z0 = Q[i-1]; x1, z1 = Q[i]\n            if x0 <= x <= x1 or x1 <= x <= x0:\n                if x0 == x1:\n                    z_ma = max(z_ma, max(z1, z0))\n                    z_mi = min(z_mi, min(z1, z0))\n                else:\n                    z = (x - x0)*(z1-z0) / (x1-x0) + z0\n                    z_ma = max(z_ma, z)\n                    z_mi = min(z_mi, z)\n        if not z_mi <= z_ma:\n            return 0\n        return (z_ma - z_mi) * (y_ma - y_mi)\n    ans = 0\n    L = len(X)\n    for i in range(L-1):\n        x0 = X[i]; x1 = X[i+1]\n        s0 = calc(x0); s1 = calc((x0 + x1)/2); s2 = calc(x1)\n        if s1 > 0:\n            ans += (x1 - x0) * (s0 + s2 + 4*s1) / 6\n    write(\"%.16f\\n\" % ans)\n    return True\nwhile solve():\n    ...\n"
  },
  {
    "language": "Python",
    "code": "# aoj 1313\nimport sys\ninput = sys.stdin.readline\n\n\n# the width of the polygon sliced at x\ndef width(X, Y, x):\n    n = len(X)\n    lb, ub = float('inf'), -float('inf')\n    for i in range(n):\n        x1, y1, x2, y2 = X[i], Y[i], X[(i+1) % n], Y[(i+1) % n]\n        if (x1-x)*(x2-x) <= 0 and x1 != x2:\n            y = y1 + (y2-y1) * (x-x1) / (x2-x1)\n            lb = min(lb, y)\n            ub = max(ub, y)\n    return max(0, ub-lb)\n\n\nwhile True:\n    m, n = map(int, input().split())\n    if m == n == 0:\n        break\n    X1 = [0] * m\n    Y1 = [0] * m\n    X2 = [0] * n\n    Z2 = [0] * n\n    for i in range(m):\n        X1[i], Y1[i] = map(int, input().split())\n    for i in range(n):\n        X2[i], Z2[i] = map(int, input().split())\n    min1, max1 = min(X1), max(X1)\n    min2, max2 = min(X2), max(X2)\n    X = X1 + X2\n    X.sort()\n    ans = 0\n    for i in range(len(X)-1):\n        a, b = X[i], X[i+1]\n        c = (a+b) / 2\n        if min1 <= c <= max1 and min2 <= c <= max2:\n            fa = width(X1, Y1, a) * width(X2, Z2, a)\n            fb = width(X1, Y1, b) * width(X2, Z2, b)\n            fc = width(X1, Y1, c) * width(X2, Z2, c)\n            ans += (b-a) / 6 * (fa+4*fc+fb)\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "def width(X,Y,x):\n     n = len(X)\n     lb,ub = float('inf'),-float('inf')\n     for i in range(n):\n          x1,y1,x2,y2 = X[i],Y[i],X[(i+1)%n],Y[(i+1)%n]\n          if (x1-x)*(x2-x) <= 0 and x1 != x2:\n               y = y1 + (y2-y1)*(x-x1)/(x2-x1)\n               lb = min(lb,y)\n               ub = max(ub,y)\n     return max(0,ub-lb)\n\nwhile 1:\n     M,N = map(int,input().split())\n     if not (M and N):\n          break\n     X1 = [0]*M\n     Y1 = [0]*M\n     X2 = [0]*N\n     Z2 = [0]*N\n     XS = [0]*N\n     for i in range(M):\n          X1[i],Y1[i] = map(int,input().split())\n     for i in range(N):\n          X2[i],Z2[i] = map(int,input().split())\n     XS = X1+X2\n     XS.sort()\n     min1,max1 = min(X1),max(X1)\n     min2,max2 = min(X2),max(X2)\n     res = 0\n     for i in range(len(XS)-1):\n          a = XS[i]\n          b = XS[i+1]\n          c = (a+b)/2\n          if min1 <= c <= max1 and min2 <= c <= max2:\n               fa = width(X1,Y1,a)*width(X2,Z2,a)\n               fb = width(X1,Y1,b)*width(X2,Z2,b)\n               fc = width(X1,Y1,c)*width(X2,Z2,c)\n               res += (b-a)/6 * (fa+4*fc+fb)\n     print('%.10f'%res)\n\n"
  },
  {
    "language": "Python",
    "code": "def width(_X, _Y, _n, _x):\n    lb = float(\"inf\")\n    ub = -float(\"inf\")\n\n    for j in range(0, _n):\n        x1 = _X[j]\n        y1 = _Y[j]\n        x2 = _X[(j + 1) % _n]\n        y2 = _Y[(j + 1) % _n]\n\n        if (x1 - _x) * (x2 - _x) <= 0 and x1 != x2:\n            y = y1 + (y2 - y1) * (_x - x1) / (x2 - x1)\n            lb = min(lb, y)\n            ub = max(ub, y)\n\n    return max(0, ub - lb)\n\n\nif __name__ == '__main__':\n    while True:\n        M, N = list(map(int, input().split()))\n        if M == 0 and N == 0:\n            break\n\n        X1 = []\n        Y1 = []\n        X2 = []\n        Z2 = []\n        for i in range(M):\n            tmp_x1, tmp_y1 = list(map(int, input().split()))\n            X1.append(tmp_x1)\n            Y1.append(tmp_y1)\n\n        for i in range(N):\n            tmp_x2, tmp_z2 = list(map(int, input().split()))\n            X2.append(tmp_x2)\n            Z2.append(tmp_z2)\n\n        min1 = min(X1)\n        max1 = max(X1)\n        min2 = min(X2)\n        max2 = max(X2)\n\n        xs = X1 + X2\n        xs = sorted(xs)\n        res = 0\n        for i in range(0, len(xs) - 1):\n            a = xs[i]\n            b = xs[i + 1]\n            c = (a + b) / 2\n            # print(\"a\" + str(a) + \"b\" + str(b) + \"c\" + str(c))\n            if min1 <= c <= max1 and min2 <= c <= max2:\n                fa = width(X1, Y1, M, a) * width(X2, Z2, N, a)\n                fb = width(X1, Y1, M, b) * width(X2, Z2, N, b)\n                fc = width(X1, Y1, M, c) * width(X2, Z2, N, c)\n                res += ((b - a) / 6) * (fa + 4 * fc + fb)\n                # print(res)\n\n        print(res)"
  },
  {
    "language": "Python",
    "code": "# aoj 1313\nimport sys\ninput = sys.stdin.readline\n\n\n# the width of the polygon sliced at x\ndef width(X, Y, x):\n    n = len(X)\n    lb, ub = float('inf'), -float('inf')\n    for i in range(n):\n        x1, y1, x2, y2 = X[i], Y[i], X[(i+1) % n], Y[(i+1) % n]\n        if (x1-x)*(x2-x) <= 0 and x1 != x2:\n            y = y1 + (y2-y1) * (x-x1) / (x2-x1)\n            lb = min(lb, y)\n            ub = max(ub, y)\n    return max(0, ub-lb)\n\n\nwhile True:\n    m, n = map(int, input().split())\n    if m == n == 0:\n        break\n    X1 = [0] * m\n    Y1 = [0] * m\n    X2 = [0] * n\n    Z2 = [0] * n\n    for i in range(m):\n        X1[i], Y1[i] = map(int, input().split())\n    for i in range(n):\n        X2[i], Z2[i] = map(int, input().split())\n    min1, max1 = min(X1), max(X1)\n    min2, max2 = min(X2), max(X2)\n    X = X1 + X2\n    X.sort()\n    ans = 0\n    for i in range(len(X)-1):\n        a, b = X[i], X[i+1]\n        c = (a+b) / 2\n        if min1 <= c <= max1 and min2 <= c <= max2:\n            fa = width(X1, Y1, a) * width(X2, Z2, a)\n            fb = width(X1, Y1, b) * width(X2, Z2, b)\n            fc = width(X1, Y1, c) * width(X2, Z2, c)\n            ans += (b-a) / 6 * (fa+4*fc+fb)\n    print(ans)\n\n"
  }
]