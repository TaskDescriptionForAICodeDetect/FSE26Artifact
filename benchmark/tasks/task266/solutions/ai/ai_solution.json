[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point2D;\n\ntypedef struct {\n    double x, z;\n} PointXZ;\n\ntypedef struct {\n    double x, y, z;\n} Point3D;\n\ntypedef struct {\n    Point2D *points;\n    int n;\n} Polygon2D;\n\ntypedef struct {\n    PointXZ *points;\n    int n;\n} PolygonXZ;\n\ndouble cross2D(Point2D a, Point2D b) {\n    return a.x * b.y - a.y * b.x;\n}\n\ndouble crossXZ(PointXZ a, PointXZ b) {\n    return a.x * b.z - a.z * b.x;\n}\n\ndouble area2D(Polygon2D poly) {\n    double area = 0.0;\n    for (int i = 0; i < poly.n; i++) {\n        int j = (i + 1) % poly.n;\n        area += cross2D(poly.points[i], poly.points[j]);\n    }\n    return fabs(area) / 2.0;\n}\n\ndouble areaXZ(PolygonXZ poly) {\n    double area = 0.0;\n    for (int i = 0; i < poly.n; i++) {\n        int j = (i + 1) % poly.n;\n        area += crossXZ(poly.points[i], poly.points[j]);\n    }\n    return fabs(area) / 2.0;\n}\n\ndouble computeIntersectionVolume(Polygon2D c1, PolygonXZ c2) {\n    double area_c1 = area2D(c1);\n    double area_c2 = areaXZ(c2);\n    return area_c1 * area_c2;\n}\n\nint main() {\n    int m, n;\n    scanf(\"%d\", &m);\n    Polygon2D c1;\n    c1.points = (Point2D *)malloc(m * sizeof(Point2D));\n    c1.n = m;\n    for (int i = 0; i < m; i++) {\n        scanf(\"%lf %lf\", &c1.points[i].x, &c1.points[i].y);\n    }\n\n    scanf(\"%d\", &n);\n    PolygonXZ c2;\n    c2.points = (PointXZ *)malloc(n * sizeof(PointXZ));\n    c2.n = n;\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &c2.points[i].x, &c2.points[i].z);\n    }\n\n    double volume = computeIntersectionVolume(c1, c2);\n    printf(\"%.10f\\n\", volume);\n\n    free(c1.points);\n    free(c2.points);\n    return 0;\n}",
    "timestamp": "2025-08-05 20:50:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    Point operator-(const Point& p) const { return Point(x - p.x, y - p.y); }\n    Point operator+(const Point& p) const { return Point(x + p.x, y + p.y); }\n    Point operator*(double d) const { return Point(x * d, y * d); }\n    double cross(const Point& p) const { return x * p.y - y * p.x; }\n};\n\ndouble polygonArea(const vector<Point>& poly) {\n    double area = 0.0;\n    int n = poly.size();\n    for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        area += poly[i].cross(poly[j]);\n    }\n    return abs(area) / 2.0;\n}\n\nvector<Point> convexHullIntersection(const vector<Point>& a, const vector<Point>& b) {\n    vector<Point> res;\n    int n = a.size(), m = b.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            Point p1 = a[i], p2 = a[(i + 1) % n];\n            Point q1 = b[j], q2 = b[(j + 1) % m];\n            Point d1 = p2 - p1, d2 = q2 - q1;\n            double det = d1.cross(d2);\n            if (det != 0) {\n                double t = (q1 - p1).cross(d2) / det;\n                double u = (q1 - p1).cross(d1) / det;\n                if (t >= 0 && t <= 1 && u >= 0 && u <= 1) {\n                    res.push_back(p1 + d1 * t);\n                }\n            }\n        }\n    }\n    for (const Point& p : a) {\n        bool inside = true;\n        for (int i = 0; i < m; ++i) {\n            Point q1 = b[i], q2 = b[(i + 1) % m];\n            if ((q2 - q1).cross(p - q1) < 0) {\n                inside = false;\n                break;\n            }\n        }\n        if (inside) res.push_back(p);\n    }\n    for (const Point& p : b) {\n        bool inside = true;\n        for (int i = 0; i < n; ++i) {\n            Point q1 = a[i], q2 = a[(i + 1) % n];\n            if ((q2 - q1).cross(p - q1) < 0) {\n                inside = false;\n                break;\n            }\n        }\n        if (inside) res.push_back(p);\n    }\n    if (res.empty()) return res;\n    Point pivot = *min_element(res.begin(), res.end(), [](const Point& p, const Point& q) {\n        return p.y < q.y || (p.y == q.y && p.x < q.x);\n    });\n    sort(res.begin(), res.end(), [&pivot](const Point& p, const Point& q) {\n        Point d1 = p - pivot, d2 = q - pivot;\n        double cross = d1.cross(d2);\n        if (cross != 0) return cross > 0;\n        return d1.x * d1.x + d1.y * d1.y < d2.x * d2.x + d2.y * d2.y;\n    });\n    vector<Point> hull;\n    for (const Point& p : res) {\n        while (hull.size() >= 2) {\n            Point a = hull.back(), b = hull[hull.size() - 2];\n            if ((a - b).cross(p - b) <= 0) break;\n            hull.pop_back();\n        }\n        hull.push_back(p);\n    }\n    return hull;\n}\n\nint main() {\n    int n, m;\n    while (cin >> n >> m) {\n        if (n == 0 && m == 0) break;\n        vector<Point> c1(n), c2(m);\n        for (int i = 0; i < n; ++i) {\n            double x, y;\n            cin >> x >> y;\n            c1[i] = Point(x, y);\n        }\n        for (int i = 0; i < m; ++i) {\n            double x, z;\n            cin >> x >> z;\n            c2[i] = Point(x, z);\n        }\n        vector<Point> intersection = convexHullIntersection(c1, c2);\n        double area = polygonArea(intersection);\n        cout << fixed << setprecision(10) << area << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 20:51:09"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.awt.geom.Path2D;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    static class Point {\n        double x, y;\n        Point(double x, double y) { this.x = x; this.y = y; }\n    }\n\n    static Point[] readPolygon(Scanner sc, int n) {\n        Point[] poly = new Point[n];\n        for (int i = 0; i < n; i++) {\n            double x = sc.nextDouble();\n            double y = sc.nextDouble();\n            poly[i] = new Point(x, y);\n        }\n        return poly;\n    }\n\n    static double cross(Point a, Point b) {\n        return a.x * b.y - a.y * b.x;\n    }\n\n    static Point subtract(Point a, Point b) {\n        return new Point(a.x - b.x, a.y - b.y);\n    }\n\n    static List<Point> convexIntersection(Point[] poly1, Point[] poly2) {\n        List<Point> intersection = new ArrayList<>();\n        for (Point p : poly1) {\n            if (isInside(poly2, p)) {\n                intersection.add(p);\n            }\n        }\n        for (Point p : poly2) {\n            if (isInside(poly1, p)) {\n                intersection.add(p);\n            }\n        }\n        for (int i = 0; i < poly1.length; i++) {\n            Point a1 = poly1[i];\n            Point a2 = poly1[(i + 1) % poly1.length];\n            for (int j = 0; j < poly2.length; j++) {\n                Point b1 = poly2[j];\n                Point b2 = poly2[(j + 1) % poly2.length];\n                Point intersectionPoint = lineIntersection(a1, a2, b1, b2);\n                if (intersectionPoint != null) {\n                    intersection.add(intersectionPoint);\n                }\n            }\n        }\n        if (intersection.isEmpty()) return intersection;\n        return convexHull(intersection);\n    }\n\n    static boolean isInside(Point[] poly, Point p) {\n        int n = poly.length;\n        if (n < 3) return false;\n        double product = cross(subtract(poly[1], poly[0]), subtract(p, poly[0]));\n        for (int i = 1; i < n; i++) {\n            double current = cross(subtract(poly[(i + 1) % n], poly[i]), subtract(p, poly[i]));\n            if (product * current < 0) return false;\n        }\n        return true;\n    }\n\n    static Point lineIntersection(Point a1, Point a2, Point b1, Point b2) {\n        Point a = subtract(a2, a1);\n        Point b = subtract(b2, b1);\n        double crossA = cross(a, subtract(b1, a1));\n        double crossB = cross(a, subtract(b2, a1));\n        if (crossA * crossB >= 0) return null;\n        crossA = cross(b, subtract(a1, b1));\n        crossB = cross(b, subtract(a2, b1));\n        if (crossA * crossB >= 0) return null;\n        double t = cross(subtract(b1, a1), b) / cross(a, b);\n        return new Point(a1.x + t * a.x, a1.y + t * a.y);\n    }\n\n    static List<Point> convexHull(List<Point> points) {\n        if (points.size() <= 1) return points;\n        points.sort((a, b) -> Double.compare(a.x, b.x) != 0 ? Double.compare(a.x, b.x) : Double.compare(a.y, b.y));\n        List<Point> hull = new ArrayList<>();\n        for (Point p : points) {\n            while (hull.size() >= 2 && cross(subtract(hull.get(hull.size() - 1), hull.get(hull.size() - 2)), subtract(p, hull.get(hull.size() - 2))) <= 0) {\n                hull.remove(hull.size() - 1);\n            }\n            hull.add(p);\n        }\n        int lowerSize = hull.size();\n        for (int i = points.size() - 2; i >= 0; i--) {\n            Point p = points.get(i);\n            while (hull.size() > lowerSize && cross(subtract(hull.get(hull.size() - 1), hull.get(hull.size() - 2)), subtract(p, hull.get(hull.size() - 2))) <= 0) {\n                hull.remove(hull.size() - 1);\n            }\n            hull.add(p);\n        }\n        hull.remove(hull.size() - 1);\n        return hull;\n    }\n\n    static double polygonArea(List<Point> poly) {\n        double area = 0;\n        int n = poly.size();\n        for (int i = 0; i < n; i++) {\n            Point p1 = poly.get(i);\n            Point p2 = poly.get((i + 1) % n);\n            area += (p1.x * p2.y - p2.x * p1.y);\n        }\n        return Math.abs(area) / 2.0;\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            int m = sc.nextInt();\n            int n = sc.nextInt();\n            if (m == 0 && n == 0) break;\n            Point[] c1 = readPolygon(sc, m);\n            Point[] c2 = readPolygon(sc, n);\n\n            Point[] c2Transformed = new Point[c2.length];\n            for (int i = 0; i < c2.length; i++) {\n                c2Transformed[i] = new Point(c2[i].x, c2[i].y);\n            }\n\n            List<Point> intersection = convexIntersection(c1, c2Transformed);\n            double area = intersection.isEmpty() ? 0 : polygonArea(intersection);\n            System.out.printf(\"%.10f\\n\", area);\n        }\n    }\n}",
    "timestamp": "2025-08-05 20:52:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PrismIntersection {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static double polygonArea(List<Point> polygon) {\n        int n = polygon.size();\n        double area = 0.0;\n        for (int i = 0; i < n; i++) {\n            int j = (i + 1) % n;\n            area += polygon.get(i).x * polygon.get(j).y - polygon.get(j).x * polygon.get(i).y;\n        }\n        return Math.abs(area) / 2.0;\n    }\n\n    static List<Point> intersectPolygons(List<Point> poly1, List<Point> poly2) {\n        List<Point> intersection = new ArrayList<>();\n        int n1 = poly1.size(), n2 = poly2.size();\n\n        for (int i = 0; i < n1; i++) {\n            Point p1 = poly1.get(i);\n            Point p2 = poly1.get((i + 1) % n1);\n\n            for (int j = 0; j < n2; j++) {\n                Point p3 = poly2.get(j);\n                Point p4 = poly2.get((j + 1) % n2);\n\n                Point intersectionPoint = lineIntersection(p1, p2, p3, p4);\n                if (intersectionPoint != null) {\n                    intersection.add(intersectionPoint);\n                }\n            }\n        }\n\n        // Add vertices inside other polygon\n        for (Point p : poly1) {\n            if (pointInPolygon(p, poly2)) {\n                intersection.add(p);\n            }\n        }\n        for (Point p : poly2) {\n            if (pointInPolygon(p, poly1)) {\n                intersection.add(p);\n            }\n        }\n\n        return convexHull(intersection);\n    }\n\n    static Point lineIntersection(Point p1, Point p2, Point p3, Point p4) {\n        double x1 = p1.x, y1 = p1.y;\n        double x2 = p2.x, y2 = p2.y;\n        double x3 = p3.x, y3 = p3.y;\n        double x4 = p4.x, y4 = p4.y;\n\n        double denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n        if (Math.abs(denom) < 1e-9) return null;\n\n        double ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;\n        double ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;\n\n        if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n            return new Point(x1 + ua * (x2 - x1), y1 + ua * (y2 - y1));\n        }\n        return null;\n    }\n\n    static boolean pointInPolygon(Point point, List<Point> polygon) {\n        int n = polygon.size();\n        boolean inside = false;\n        for (int i = 0, j = n - 1; i < n; j = i++) {\n            if (((polygon.get(i).y > point.y) != (polygon.get(j).y > point.y)) &&\n                (point.x < (polygon.get(j).x - polygon.get(i).x) * (point.y - polygon.get(i).y) / \n                (polygon.get(j).y - polygon.get(i).y) + polygon.get(i).x)) {\n                inside = !inside;\n            }\n        }\n        return inside;\n    }\n\n    static List<Point> convexHull(List<Point> points) {\n        if (points.size() <= 3) return points;\n\n        points.sort((a, b) -> {\n            if (a.x != b.x) return Double.compare(a.x, b.x);\n            return Double.compare(a.y, b.y);\n        });\n\n        List<Point> lower = new ArrayList<>();\n        for (Point p : points) {\n            while (lower.size() >= 2) {\n                Point last = lower.get(lower.size() - 1);\n                Point secondLast = lower.get(lower.size() - 2);\n                if (crossProduct(secondLast, last, p) > 0) break;\n                lower.remove(lower.size() - 1);\n            }\n            lower.add(p);\n        }\n\n        List<Point> upper = new ArrayList<>();\n        for (int i = points.size() - 1; i >= 0; i--) {\n            Point p = points.get(i);\n            while (upper.size() >= 2) {\n                Point last = upper.get(upper.size() - 1);\n                Point secondLast = upper.get(upper.size() - 2);\n                if (crossProduct(secondLast, last, p) > 0) break;\n                upper.remove(upper.size() - 1);\n            }\n            upper.add(p);\n        }\n\n        lower.remove(lower.size() - 1);\n        upper.remove(upper.size() - 1);\n        lower.addAll(upper);\n        return lower;\n    }\n\n    static double crossProduct(Point a, Point b, Point c) {\n        return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n    }\n\n    static double calculateIntersectionVolume(List<Point> poly1, List<Point> poly2) {\n        List<Point> intersectionPolygon = intersectPolygons(poly1, poly2);\n        return polygonArea(intersectionPolygon);\n    }\n\n    public static void main(String[] args) {\n        // Example usage\n        List<Point> polygon1 = Arrays.asList(\n            new Point(0, 0), \n            new Point(2, 0), \n            new Point(2, 2), \n            new Point(0, 2)\n        );\n        \n        List<Point> polygon2 = Arrays.asList(\n            new Point(1, 1), \n            new Point(3, 1), \n            new Point(3, 3), \n            new Point(1, 3)\n        );\n\n        double volume = calculateIntersectionVolume(polygon1, polygon2);\n        System.out.println(\"Intersection Volume: \" + volume);\n    }\n}",
    "timestamp": "2025-08-05 20:52:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n#define MAX_VERTICES 100\n#define EPSILON 1e-9\n\ntypedef struct {\n    double x, y, z;\n} Point;\n\ntypedef struct {\n    int n;\n    Point vertices[MAX_VERTICES];\n} Polygon;\n\ndouble cross_product_2d(Point a, Point b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nint point_inside_polygon(Point p, Polygon poly) {\n    int inside = 0;\n    for (int i = 0; i < poly.n; i++) {\n        Point a = poly.vertices[i];\n        Point b = poly.vertices[(i + 1) % poly.n];\n        \n        if (((a.y > p.y) != (b.y > p.y)) &&\n            (p.x < (b.x - a.x) * (p.y - a.y) / (b.y - a.y) + a.x)) {\n            inside = !inside;\n        }\n    }\n    return inside;\n}\n\ndouble polygon_intersection_area(Polygon poly1, Polygon poly2) {\n    double area = 0.0;\n    \n    for (int i = 0; i < poly1.n; i++) {\n        Point a = poly1.vertices[i];\n        Point b = poly1.vertices[(i + 1) % poly1.n];\n        \n        if (point_inside_polygon(a, poly2)) {\n            area += cross_product_2d(a, b) / 2.0;\n        }\n    }\n    \n    for (int i = 0; i < poly2.n; i++) {\n        Point a = poly2.vertices[i];\n        Point b = poly2.vertices[(i + 1) % poly2.n];\n        \n        if (point_inside_polygon(a, poly1)) {\n            area += cross_product_2d(a, b) / 2.0;\n        }\n    }\n    \n    return fabs(area);\n}\n\ndouble calculate_intersection_volume(Polygon poly1, Polygon poly2) {\n    double intersection_area = polygon_intersection_area(poly1, poly2);\n    return intersection_area;\n}\n\nint main() {\n    int t;\n    scanf(\"%d\", &t);\n    \n    while (t--) {\n        Polygon poly1, poly2;\n        \n        scanf(\"%d\", &poly1.n);\n        for (int i = 0; i < poly1.n; i++) {\n            scanf(\"%lf %lf\", &poly1.vertices[i].x, &poly1.vertices[i].y);\n            poly1.vertices[i].z = 0;\n        }\n        \n        scanf(\"%d\", &poly2.n);\n        for (int i = 0; i < poly2.n; i++) {\n            scanf(\"%lf %lf\", &poly2.vertices[i].x, &poly2.vertices[i].z);\n            poly2.vertices[i].y = 0;\n        }\n        \n        double volume = calculate_intersection_volume(poly1, poly2);\n        printf(\"%.6f\\n\", volume);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:52:58"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    \n    Point operator-(const Point& p) const {\n        return Point(x - p.x, y - p.y);\n    }\n};\n\ndouble cross(const Point& a, const Point& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\ndouble polygonArea(const vector<Point>& polygon) {\n    double area = 0;\n    int n = polygon.size();\n    for (int i = 0; i < n; i++) {\n        area += cross(polygon[i], polygon[(i + 1) % n]);\n    }\n    return abs(area) / 2.0;\n}\n\nvector<Point> clipPolygon(const vector<Point>& subject, const vector<Point>& clip) {\n    vector<Point> output = subject;\n    int n = clip.size();\n    \n    for (int i = 0; i < n; i++) {\n        Point clipEdge = clip[(i + 1) % n] - clip[i];\n        vector<Point> input = output;\n        output.clear();\n        \n        int m = input.size();\n        for (int j = 0; j < m; j++) {\n            Point current = input[j];\n            Point prev = input[(j + m - 1) % m];\n            \n            bool currentInside = cross(clipEdge, current - clip[i]) >= -EPS;\n            bool prevInside = cross(clipEdge, prev - clip[i]) >= -EPS;\n            \n            if (currentInside != prevInside) {\n                Point intersection;\n                double t = cross(clip[i] - prev, clipEdge) / cross(prev - current, clipEdge);\n                intersection = Point(prev.x + t * (current.x - prev.x), \n                                     prev.y + t * (current.y - prev.y));\n                output.push_back(intersection);\n            }\n            \n            if (currentInside) {\n                output.push_back(current);\n            }\n        }\n    }\n    \n    return output;\n}\n\ndouble calculateIntersectionVolume(const vector<Point>& C1, const vector<Point>& C2) {\n    vector<Point> intersection = clipPolygon(C1, C2);\n    \n    if (intersection.empty()) {\n        return 0.0;\n    }\n    \n    double intersectionArea = polygonArea(intersection);\n    return intersectionArea;\n}\n\nint main() {\n    int n1, n2;\n    while (cin >> n1 >> n2 && n1 && n2) {\n        vector<Point> C1(n1), C2(n2);\n        \n        for (int i = 0; i < n1; i++) {\n            cin >> C1[i].x >> C1[i].y;\n        }\n        \n        for (int i = 0; i < n2; i++) {\n            cin >> C2[i].x >> C2[i].y;\n        }\n        \n        double volume = calculateIntersectionVolume(C1, C2);\n        \n        cout << fixed << setprecision(2) << volume << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:53:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from shapely.geometry import Polygon, box\n\ndef find_intersection_volume(polygon_xy, polygon_xz):\n    # Convert input coordinates to Shapely polygons\n    poly_xy = Polygon(polygon_xy)\n    poly_xz = Polygon(polygon_xz)\n\n    # Determine the bounding box of the XY polygon\n    min_x1, min_y, max_x1, max_y = poly_xy.bounds\n\n    # Determine the bounding box of the XZ polygon\n    min_x2, min_z, max_x2, max_z = poly_xz.bounds\n\n    # Find intersecting x range\n    min_x = max(min_x1, min_x2)\n    max_x = min(max_x1, max_x2)\n    \n    # Check for no overlap in x-axis\n    if min_x >= max_x:\n        return 0\n    \n    # Define intersection rectangle in XY polygon with infinite height on y axis\n    intersection_rect_xy = box(min_x, min_y, max_x, max_y)\n    intersection_area_xy = poly_xy.intersection(intersection_rect_xy).area\n    \n    # Define intersection rectangle in XZ polygon with infinite height on z axis\n    intersection_rect_xz = box(min_x, min_z, max_x, max_z)\n    intersection_area_xz = poly_xz.intersection(intersection_rect_xz).area\n\n    # The volume of intersection is product of areas of intersecting slices\n    volume = intersection_area_xy * intersection_area_xz\n    return volume\n\n# Example usage\npolygon_xy = [(0, 0), (4, 0), (4, 4), (0, 4)]\npolygon_xz = [(2, 0), (6, 0), (6, 3), (2, 3)]\nvolume = find_intersection_volume(polygon_xy, polygon_xz)\nprint(volume)",
    "timestamp": "2025-08-13 03:42:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.awt.geom.Path2D;\nimport java.awt.geom.Point2D;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class IntersectionVolume {\n\n    public static double calculateIntersectionVolume(List<Point2D.Double> c1, List<Point2D.Double> c2) {\n        Path2D polygon1 = new Path2D.Double();\n        Path2D polygon2 = new Path2D.Double();\n\n        if (c1.isEmpty() || c2.isEmpty()) {\n            return 0.0;\n        }\n\n        Point2D.Double first = c1.get(0);\n        polygon1.moveTo(first.x, first.y);\n        for (int i = 1; i < c1.size(); i++) {\n            Point2D.Double point = c1.get(i);\n            polygon1.lineTo(point.x, point.y);\n        }\n        polygon1.closePath();\n\n        first = c2.get(0);\n        polygon2.moveTo(first.x, first.y);\n        for (int i = 1; i < c2.size(); i++) {\n            Point2D.Double point = c2.get(i);\n            polygon2.lineTo(point.x, point.y);\n        }\n        polygon2.closePath();\n\n        double minIntersection = Double.POSITIVE_INFINITY;\n        for (Point2D.Double point : c1) {\n            if (polygon2.contains(point.y, point.x)) {\n                double intersectionWidth = Math.min(\n                        polygonIntersectionWidth(polygon2, point.y),\n                        polygonIntersectionWidth(polygon1, point.x)\n                );\n                minIntersection = Math.min(minIntersection, intersectionWidth);\n            }\n        }\n        return minIntersection == Double.POSITIVE_INFINITY ? 0.0 : minIntersection;\n    }\n\n    private static double polygonIntersectionWidth(Path2D polygon, double coordinate) {\n        double min = Double.POSITIVE_INFINITY, max = Double.NEGATIVE_INFINITY;\n        List<Point2D> points = getVerticesFromPolygon(polygon);\n        for (int i = 0; i < points.size(); i++) {\n            Point2D p1 = points.get(i);\n            Point2D p2 = points.get((i + 1) % points.size());\n            if ((p1.getY() <= coordinate && p2.getY() >= coordinate) || (p2.getY() <= coordinate && p1.getY() >= coordinate)) {\n                double x = (coordinate - p1.getY()) * (p2.getX() - p1.getX()) / (p2.getY() - p1.getY()) + p1.getX();\n                min = Math.min(x, min);\n                max = Math.max(x, max);\n            }\n        }\n        return max - min;\n    }\n\n    private static List<Point2D> getVerticesFromPolygon(Path2D polygon) {\n        List<Point2D> points = new ArrayList<>();\n        double[] coords = new double[6];\n        for (Path2D.Iterator it = polygon.getPathIterator(null); !it.isDone(); it.next()) {\n            int type = it.currentSegment(coords);\n            if (type == Path2D.Iterator.SEG_CLOSE) break;\n            points.add(new Point2D.Double(coords[0], coords[1]));\n        }\n        return points;\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n\n        int n1 = scanner.nextInt();\n        List<Point2D.Double> c1 = new ArrayList<>();\n        for (int i = 0; i < n1; i++) {\n            double x = scanner.nextDouble();\n            double y = scanner.nextDouble();\n            c1.add(new Point2D.Double(x, y));\n        }\n\n        int n2 = scanner.nextInt();\n        List<Point2D.Double> c2 = new ArrayList<>();\n        for (int i = 0; i < n2; i++) {\n            double x = scanner.nextDouble();\n            double z = scanner.nextDouble();\n            c2.add(new Point2D.Double(x, z));\n        }\n\n        double volume = calculateIntersectionVolume(c1, c2);\n        System.out.printf(\"%.2f%n\", volume);\n    }\n}",
    "timestamp": "2025-08-13 03:42:39"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\ntypedef struct {\n    double x, y;\n} Point2D;\n\ntypedef struct {\n    Point2D* points;\n    int n;\n} Polygon;\n\ndouble cross_product(Point2D a, Point2D b, Point2D c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nbool point_in_polygon(Point2D p, Polygon* pol) {\n    bool inside = false;\n    for (int i = 0, j = pol->n - 1; i < pol->n; j = i++) {\n        if (((pol->points[i].y > p.y) != (pol->points[j].y > p.y)) &&\n            (p.x < (pol->points[j].x - pol->points[i].x) * (p.y - pol->points[i].y)\n             / (pol->points[j].y - pol->points[i].y) + pol->points[i].x)) {\n            inside = !inside;\n        }\n    }\n    return inside;\n}\n\ndouble polygon_area(Polygon* pol) {\n    double area = 0;\n    for (int i = 0; i < pol->n; i++) {\n        int j = (i + 1) % pol->n;\n        area += pol->points[i].x * pol->points[j].y;\n        area -= pol->points[j].x * pol->points[i].y;\n    }\n    return area / 2.0;\n}\n\nvoid compute_intersection(Polygon* C1, Polygon* C2) {\n    double area_xy, area_intersection = 0;\n    bool point_inside;\n    for (int i = 0; i < C1->n; i++) {\n        Point2D p = C1->points[i];\n        point_inside = point_in_polygon(p, C2);\n        if (point_inside) {\n            double area = cross_product(C1->points[0], p, C1->points[(i+1)%C1->n]) / 2.0;\n            area_intersection += (area > 0 ? area : -area);\n        }\n    }\n    area_xy = (area_intersection <= 0 ? 0 : area_intersection);\n    double volume = area_xy;\n    printf(\"Volume of intersection: %lf\\n\", volume);\n}\n\nint main() {\n    Point2D points_C1[] = {{0, 0}, {2, 0}, {2, 2}, {0, 2}};\n    Point2D points_C2[] = {{1, 1}, {3, 1}, {3, 3}, {1, 3}};\n    \n    Polygon C1 = {points_C1, 4};\n    Polygon C2 = {points_C2, 4};\n\n    compute_intersection(&C1, &C2);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 03:43:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from shapely.geometry import Polygon\nimport numpy as np\n\ndef calculate_intersection_volume(polygon1, polygon2):\n    # Project polygon1 onto xy-plane\n    poly1 = Polygon(polygon1)\n    \n    # Project polygon2 onto xz-plane (rotate 90 degrees)\n    rotated_polygon2 = [(x, z) for (x, y, z) in polygon2]\n    poly2 = Polygon(rotated_polygon2)\n    \n    # Calculate intersection area\n    intersection = poly1.intersection(poly2)\n    intersection_area = intersection.area\n    \n    # Calculate min height (infinite height prisms have same height)\n    min_height = float('inf')\n    \n    # Volume is intersection area\n    return intersection_area * min_height\n\ndef read_input():\n    # Number of vertices for first polygon\n    n1 = int(input())\n    polygon1 = []\n    for _ in range(n1):\n        x, y = map(float, input().split())\n        polygon1.append((x, y))\n    \n    # Number of vertices for second polygon\n    n2 = int(input())\n    polygon2 = []\n    for _ in range(n2):\n        x, y, z = map(float, input().split())\n        polygon2.append((x, y, z))\n    \n    return polygon1, polygon2\n\ndef main():\n    polygon1, polygon2 = read_input()\n    volume = calculate_intersection_volume(polygon1, polygon2)\n    print(f\"{volume:.6f}\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 03:43:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import numpy as np\nfrom scipy.spatial import ConvexHull\nfrom shapely.geometry import Polygon\n\ndef compute_intersection_volume(C1, C2):\n    # Convert polygons to Shapely Polygon objects\n    poly1 = Polygon(C1)\n    poly2 = Polygon(C2)\n    \n    # Compute intersection\n    intersection = poly1.intersection(poly2)\n    \n    if intersection.is_empty:\n        return 0.0\n    elif isinstance(intersection, Polygon):\n        return intersection.area\n    else:\n        # Handle MultiPolygon (though problem says convex, so unlikely)\n        total_area = 0.0\n        for geom in intersection.geoms:\n            total_area += geom.area\n        return total_area\n\ndef main():\n    import sys\n    input = sys.stdin.read().split()\n    ptr = 0\n    \n    # Read C1\n    n1 = int(input[ptr])\n    ptr += 1\n    C1 = []\n    for _ in range(n1):\n        x = float(input[ptr])\n        y = float(input[ptr+1])\n        C1.append((x, y))\n        ptr += 2\n    \n    # Read C2\n    n2 = int(input[ptr])\n    ptr += 1\n    C2 = []\n    for _ in range(n2):\n        x = float(input[ptr])\n        z = float(input[ptr+1])\n        C2.append((x, z))\n        ptr += 2\n    \n    # Compute intersection volume\n    volume = compute_intersection_volume(C1, C2)\n    print(\"{0:.10f}\".format(volume))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 03:43:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct Point {\n    double x, y;\n};\n\nbool isLeft(Point p, Point q, Point r) {\n    return ((q.x - p.x) * (r.y - p.y) - (q.y - p.y) * (r.x - p.x)) > 0;\n}\n\nbool inside(const Point &pt, const std::vector<Point> &poly) {\n    int n = poly.size();\n    for (int i = 0, j = n - 1; i < n; j = i++) {\n        if (!isLeft(poly[j], poly[i], pt))\n            return false;\n    }\n    return true;\n}\n\nstd::vector<Point> intersect(const std::vector<Point> &poly1, const std::vector<Point> &poly2) {\n    std::vector<Point> intersection;\n\n    for (const auto &p : poly1)\n        if (inside(p, poly2))\n            intersection.push_back(p);\n\n    for (const auto &p : poly2)\n        if (inside(p, poly1))\n            intersection.push_back(p);\n\n    return intersection;\n}\n\ndouble polygonArea(const std::vector<Point> &poly) {\n    int n = poly.size();\n    double area = 0.0;\n    for (int i = 0, j = n - 1; i < n; j = i++)\n        area += (poly[j].x * poly[i].y - poly[i].x * poly[j].y);\n    return std::abs(area) / 2.0;\n}\n\ndouble prismIntersectionVolume(const std::vector<Point> &c1, const std::vector<Point> &c2) {\n    std::vector<Point> projection;\n    for (const auto &p : c1)\n        projection.push_back({p.x, 0});\n\n    auto intersection = intersect(projection, c2);\n    return polygonArea(intersection);\n}\n\nint main() {\n    int n1, n2;\n    std::cin >> n1;\n    std::vector<Point> c1(n1);\n    for (int i = 0; i < n1; ++i)\n        std::cin >> c1[i].x >> c1[i].y;\n\n    std::cin >> n2;\n    std::vector<Point> c2(n2);\n    for (int i = 0; i < n2; ++i)\n        std::cin >> c2[i].x >> c2[i].y;\n\n    double volume = prismIntersectionVolume(c1, c2);\n    std::cout << \"Volume of intersection: \" << volume << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 11:14:36"
  }
]