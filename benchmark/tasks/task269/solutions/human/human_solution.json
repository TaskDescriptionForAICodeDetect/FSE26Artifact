[
  {
    "language": "Scala",
    "code": "object Main extends App {\n  override def main(args: Array[String]): Unit = {\n    import scala.io.{StdIn => in}\n\n    Iterator.continually(in.readInt).takeWhile(_ != 0)\n      .map(n => for (i <- 1 to n) yield in.readLine())\n      .map(candidates => new Solver(candidates.toArray, in.readLine()))\n      .map(_.solve())\n      .foreach(println)\n\n  }\n}\n\nclass Solver(val candidates: Array[String], val target: String) {\n  val answers = target.substring(0, target.size - 1).split(\" \").distinct.sortWith((x, y) => x.length > y.length)\n\n  def solve(): String = {\n\n    val answersSize: Int = answers.size;\n\n    def getMatch(pointer: Int, map: Map[Char, Char], ans: Map[Char, Char], found: Int): (Map[Char, Char], Int) = {\n      if (found > 1) (Map[Char, Char](), 2)\n      else\n        pointer match {\n          case `answersSize` => (map, found + 1)\n          case _ =>\n            if(answers(pointer).forall(map.isDefinedAt(_))) getMatch(pointer + 1, map, ans, found)\n            else (0 until candidates.size)\n              .filter(!candidates(_).forall(map.isDefinedAt(_)))\n              .filter(candidates(_).length == answers(pointer).length)\n              .map(getNewMap(pointer, map, _))\n              .collect({ case Some(x: Map[Char, Char]) => x })\n              .foldLeft(ans, found)((f, next) => getMatch(pointer + 1, next, f._1, f._2))\n        }\n    }\n\n    def getNewMap(pointer: Int, map: Map[Char, Char], index: Int): Option[Map[Char, Char]] = {\n      val nextAnswer = answers(pointer)\n      val nextCandidate = candidates(index)\n\n      val newMap = nextAnswer.zip(nextCandidate).foldLeft((true, map)) { (z, ansCand) =>\n        if (!z._1) {\n          (false, z._2)\n        } else {\n          ansCand match {\n            case (answer: Char, candidate: Char) if z._2.isDefinedAt(answer) && z._2.isDefinedAt(candidate) => (z._2(answer).toUpper == candidate, z._2)\n            case (answer: Char, candidate: Char) if (!z._2.isDefinedAt(answer)) && (!z._2.isDefinedAt(candidate)) => (true, z._2 + (candidate -> answer.toLower, answer -> candidate.toLower))\n            case _ => (false, z._2)\n          }\n        }\n      }\n\n      if (newMap._1) Some(newMap._2) else None\n    }\n    val res = getMatch(0, Map[Char, Char](), Map[Char, Char](), 0)\n    if (res._2 == 1) target.map(c => res._1.getOrElse(c, c)).toUpperCase() else \"-.\"\n  }\n}"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n  override def main(args: Array[String]): Unit = {\n    import scala.io.{StdIn => in}\n\n    Iterator.continually(in.readInt).takeWhile(_ != 0)\n      .map(n => for (i <- 1 to n) yield in.readLine())\n      .map(candidates => new Solver(candidates.toArray, in.readLine()))\n      .map(_.solve())\n      .foreach(println)\n\n  }\n}\n\nclass Solver(candidates_ : Array[String], val target: String) {\n  val answers = target.substring(0, target.size - 1).split(\" \").distinct.sortWith((x, y) => x.distinct.length > y.distinct.length)\n  val candidates = candidates_.sortWith((x, y) => x.distinct.length > y.distinct.length)\n\n  def solve(): String = {\n\n    val answersSize: Int = answers.size;\n\n    def getMatch(pointer: Int, map: Map[Char, Char], ans: Map[Char, Char], found: Int): (Map[Char, Char], Int) = {\n      if (found > 1) (Map[Char, Char](), 2)\n      else\n        pointer match {\n          case `answersSize` => (map, found + 1)\n          case _ =>\n            if(answers(pointer).forall(map.isDefinedAt(_)))\n              if(candidates contains answers(pointer).map(map(_).toUpper)) getMatch(pointer + 1, map, ans, found)\n              else (ans,found)\n            else (0 until candidates.size)\n              .filter(!candidates(_).forall(map.isDefinedAt(_)))\n              .filter(candidates(_).length == answers(pointer).length)\n              .map(getNewMap(pointer, map, _))\n              .collect({ case Some(x: Map[Char, Char]) => x })\n              .foldLeft(ans, found)((f, next) => getMatch(pointer + 1, next, f._1, f._2))\n        }\n    }\n\n    def getNewMap(pointer: Int, map: Map[Char, Char], index: Int): Option[Map[Char, Char]] = {\n      val nextAnswer = answers(pointer)\n      val nextCandidate = candidates(index)\n\n      val newMap = nextAnswer.zip(nextCandidate).foldLeft((true, map)) { (z, ansCand) =>\n        if (!z._1) {\n          (false, z._2)\n        } else {\n          ansCand match {\n            case (answer: Char, candidate: Char) if z._2.isDefinedAt(answer) && z._2.isDefinedAt(candidate) => (z._2(answer).toUpper == candidate, z._2)\n            case (answer: Char, candidate: Char) if (!z._2.isDefinedAt(answer)) && (!z._2.isDefinedAt(candidate)) => (true, z._2 + (candidate -> answer.toLower, answer -> candidate.toLower))\n            case _ => (false, z._2)\n          }\n        }\n      }\n\n      if (newMap._1) Some(newMap._2) else None\n    }\n    val res = getMatch(0, Map[Char, Char](), Map[Char, Char](), 0)\n    if (res._2 == 1) target.map(c => res._1.getOrElse(c, c)).toUpperCase() else \"-.\"\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n\nusing namespace std;\n\n\n\nvector<string> v;\nvector<string> vv;\n\nvector<string> s[21];\n\nchar r[256];\nchar ans[256];\nint n,cnt;\n\n\nvoid dfs(int d){\n\n\n  if(d==vv.size()){\n    cnt++;\n    for(int i='A';i<='Z';i++)ans[i]=r[i];\n    return;\n  }\n\n  int sz=vv[d].size();\n\n  char tmp[26];\n\n  for(int i='A';i<='Z';i++)tmp[i-'A']=r[i];\n  \n  for(int i=0;i<s[sz].size();i++){\n    bool f=1;\n    \n    for(int j=0;j<s[sz][i].size();j++){\n\n      if(r[s[sz][i][j]]!=0 && r[vv[d][j]] !=0 ){\n\tif(vv[d][j]!=r[s[sz][i][j]] || r[vv[d][j]]!=s[sz][i][j]) f=0;\n      }\n      else if(r[s[sz][i][j]]==0 && r[vv[d][j]]==0) r[vv[d][j]]=s[sz][i][j], r[s[sz][i][j]]=vv[d][j];\n      else f=0;\n    }\n    \n    if(f&&cnt<=1)dfs(d+1);\n    \n\n    for(int i='A';i<='Z';i++)r[i]=tmp[i-'A'];\n    \n  }\n}\n\n\nint main(){\n\n  while(cin>>n,n){\n    string str;\n    v.clear();\n    vv.clear();\n    for(int i=0;i<21;i++)s[i].clear();\n\n    for(int i='A';i<='Z';i++)r[i]=0;\n\n    cnt=0;\n    \n    for(int i=0;i<n;i++){\n      cin>>str;\n      s[str.size()].push_back(str);\n    }\n    \n    bool f=1;\n    \n    while(cin>>str){\n      \n      if(str[str.size()-1]=='.'){\n\tstr=str.substr(0,str.size()-1);\n\tf=0;\n      }\n      v.push_back(str);\n      if(!f) break;\n    }\n\n    vv=v;\n    for(int i=1;i<vv.size();i++)\n      for(int j=i;j>0;j--){\n\tif(vv[j-1].size()<vv[j].size())\n\t  swap(vv[j],vv[j-1]);\n      }\n      \n    dfs(0);\n    \n    if(cnt==1){\n\n      for(int i=0;i<v.size();i++){\n\tfor(int j=0;j<v[i].size();j++){\n\t  if(ans[v[i][j]]==0)cout<<v[i][j];\n\t  else cout<<(char)ans[v[i][j]];\n\t}\n\tif(i!=v.size()-1)cout<<\" \";\n      }\n    }\n\n    else cout<<\"-\";\n\n    cout<<\".\"<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n\nusing namespace std;\n\n\n\nvector<string> v;\nvector<string> vv;\n\nvector<string> s[21];\n\nchar r[256];\nchar ans[256];\nint n,cnt;\n\n\nvoid dfs(int d){\n  if(d==vv.size()||cnt==1){\n    cnt++;\n    for(int i='A';i<='Z';i++)ans[i]=r[i];\n    return;\n  }\n\n  int sz=vv[d].size();\n\n  char tmp[256];\n\n  for(int i='A';i<='Z';i++)tmp[i]=r[i];\n  \n  for(int i=0;i<s[sz].size();i++){\n    bool f=1;\n    char rr[256]={};\n    \n    for(int j=0;j<s[sz][i].size();j++){\n\n      if(r[s[sz][i][j]]!=0 && r[vv[d][j]] !=0 ){\n\tif(vv[d][j]!=r[s[sz][i][j]] || r[vv[d][j]]!=s[sz][i][j]) f=0;\n      }\n      else if(r[s[sz][i][j]]==0 && r[vv[d][j]]==0) r[vv[d][j]]=s[sz][i][j], r[s[sz][i][j]]=vv[d][j];\n      else f=0;\n    }\n    \n    if(f)dfs(d+1);\n    \n\n    for(int i='A';i<='Z';i++)r[i]=tmp[i];\n    \n  }\n}\n\n\nint main(){\n\n  while(cin>>n,n){\n    string str;\n    v.clear();\n    vv.clear();\n    for(int i=0;i<21;i++)s[i].clear();\n\n    for(int i='A';i<='Z';i++)r[i]=0;\n\n    cnt=0;\n    \n    for(int i=0;i<n;i++){\n      cin>>str;\n      s[str.size()].push_back(str);\n    }\n    \n    bool f=1;\n    \n    while(cin>>str){\n      \n      if(str[str.size()-1]=='.'){\n\tstr=str.substr(0,str.size()-1);\n\tf=0;\n      }\n      v.push_back(str);\n      if(!f) break;\n    }\n\n    vv=v;\n    for(int i=1;i<vv.size();i++)\n      for(int j=i;j>0;j--){\n\tif(vv[j-1].size()<vv[j].size())\n\t  swap(vv[j],vv[j-1]);\n      }\n      \n    dfs(0);\n    \n    if(cnt==1){\n\n      for(int i=0;i<v.size();i++){\n\tfor(int j=0;j<v[i].size();j++){\n\t  if(ans[v[i][j]]==0)cout<<v[i][j];\n\t  else cout<<(char)ans[v[i][j]];\n\t}\n\tif(i!=v.size()-1)cout<<\" \";\n      }\n    }\n\n    else cout<<\"-\";\n\n    cout<<\".\"<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX_M = 50;\nconstexpr int MAX_LENGTH = 20;\n\nint n, m;\nstring target;\nvector<string> candidates[MAX_LENGTH + 1];\npair<int, string> words[MAX_M];\nvector<char> assign(128, -1);\n\nint cnt;\n\nbool dfs(int idx = 0) {\n\tif(idx == m) {\n\t\tif(++cnt == 1) {\n\t\t\tfor(auto &c : target) {\n\t\t\t\tif(c != ' ') c = assign[c];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tconst auto &s = words[idx].second;\n\n\tfor(const auto &t : candidates[s.size()]) {\n\t\tauto tmp(assign);\n\n\t\tfor(int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\t\tif(!(tmp[s[i]] == t[i] || (tmp[s[i]] == -1 && tmp[t[i]] == -1))) {\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\ttmp[s[i]] = t[i];\n\t\t\ttmp[t[i]] = s[i];\n\t\t}\n\n\t\tassign.swap(tmp);\n\t\tif(!dfs(idx + 1)) return false;\n\t\tassign = move(tmp);\n\t\t\n\tnext:;\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n && n) {\n\t\tfor_each(begin(candidates), end(candidates), [](vector<string> &v) { v.clear(); });\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tstring in;\n\t\t\tcin >> in;\n\n\t\t\tconst int len = in.size();\n\t\t\tcandidates[len].emplace_back(move(in));\n\t\t}\n\n\t\tcin.ignore();\n\t\tgetline(cin, target);\n\t\ttarget = target.substr(0, target.size() - 1);\n\n\t\t{\n\t\t\tstring in;\n\t\t\tistringstream iss(target);\n\n\t\t\tfor(m = 0; iss >> in; ++m) {\n\t\t\t\twords[m].second = in;\n\t\t\t\tin.erase(unique(in.begin(), in.end()), in.end());\n\t\t\t\twords[m].first = in.size();\n\t\t\t}\n\t\t}\n\n\t\tsort(words, words + m, greater<pair<int, string>>());\n\n\t\tcnt = 0;\n\t\tfill(begin(assign), end(assign), -1);\n\t\tdfs();\n\n\t\tcout << (cnt == 1 ? target : \"-\") << \".\\n\";\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <functional>\n#include <queue>\n#include <vector>\n#include <cstdlib>\n#include <string>\n#include <set>\nusing namespace std;\n\n#define PII pair<int,int> \n#define MP make_pair\n#define FI first\n#define SE second\n#define PB push_back\n#define lid (id << 1)\n#define rid (id << 1 | 1)\n#define MID(a, b) ((a + b) >> 1)\n\nconst int N = 110;\nconst int INF = 1000000000;\nconst long long Mod = 1000000007;\n\nvector<string> word[N], s;\nchar str[N], INV[26], ch[N];\nmap<unsigned int, bool> vis[N];\nstring ans;\nint n, find_ans, m, L, len[N];\n\nint cnt = 0;\n\nunsigned int get_hash(){\n    unsigned int ret = 0;\n    for(int i = 0; i < 26; i++){\n        ret = ret * 29 + INV[i] - 'A';\n    }\n    return ret;\n}\n\nvoid dfs(int k){\n    if(find_ans >= 2) return;\n    int hash = get_hash();\n    if(vis[k].find(hash) != vis[k].end()) return;\n    if(k == m){\n        if(find_ans == 1){\n            find_ans = 2;\n            return;\n        }\n        for(int i = 0; i < L; i++){\n            ans += INV[ch[i] - 'A'];\n        }\n        find_ans = 1;\n        return;\n    }\n    cnt ++;\n    if(cnt < 100000){\n        vis[k][hash] = 1;\n    }\n    else{\n        if(find_ans == 1){\n            find_ans = 3;\n            return;\n        }\n    }\n    string inv = \"\";\n    for(int i = 0; i < 26; i++)\n        inv += INV[i];\n    for(int i = word[len[k]].size() - 1; i >= 0; i--){\n        int no = 0;\n        for(int j = 0; j < 26; j++){\n            INV[j] = inv[j];\n        }\n        for(int j = 0; j < len[k]; j++){\n            if(INV[s[k][j] - 'A'] != '#'){\n                if(INV[s[k][j] - 'A'] != word[len[k]][i][j]){\n                    no = 1; break;\n                }\n            }\n            else{\n                if(s[k][j] != word[len[k]][i][j]){\n                    if(INV[word[len[k]][i][j] - 'A'] != '#'){\n                        no = 1; break;\n                    }\n                    else{\n                        INV[word[len[k]][i][j] - 'A'] = s[k][j];\n                        INV[s[k][j] - 'A'] = word[len[k]][i][j];\n                    }\n                }\n                else{\n                    INV[s[k][j] - 'A'] = s[k][j];\n                }\n            }\n        }\n        if(!no){\n            dfs(k + 1);\n            if(find_ans >= 2) return;\n        }\n    }\n}\n\nbool cmpr(string a, string b){\n    return a.length() > b.length();\n}\n\nvoid solve(){\n    for(int i = 0; i < N; i++){\n        word[i].clear(); vis[i].clear();\n    }\n    s.clear();\n    for(int i = 0; i < n; i++){\n        scanf(\"%s\", str);\n        int len = strlen(str);\n        word[len].push_back(str);\n    }\n    gets(str); gets(str);\n    L = strlen(str);\n    memcpy(ch, str, sizeof(ch));\n    char *temp = strtok(str, \" .\");\n    while(temp != NULL){\n        s.push_back(temp);\n        temp = strtok(NULL, \" .\");\n    }\n    m = s.size();\n    sort(s.begin(), s.end(), cmpr);\n\n    for(int i = 0; i < m; i++){\n        len[i] = s[i].length();\n    }\n\n    for(int i = 0; i < 26; i++){\n        INV[i] = '#';\n    }\n    ans = \"\"; find_ans = 0;\n    dfs(0);\n    if(find_ans == 2){\n        puts(\"-.\");\n    }\n    else{\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    // freopen(\"in.txt\", \"r\", stdin); \n    while(scanf(\"%d\", &n) != EOF){\n        if(n == 0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\nstring str[30];\nchar in[100];\nstring q[100];\nint conv[30];\nint to[100];\nint ans[100];\nint sz;\nint n;\nint dfs(){\n\tint at=-1;\n\tint len=0;\n\tfor(int i=0;i<sz;i++){\n\t\tif(!~to[i]){\n\t\t\tif(len<q[i].size()){\n\t\t\t\tat=i;len=q[i].size();\n\t\t\t}\n\t\t}\n\t}\n\tif(!len){\n\t\tfor(int i=0;i<sz;i++)ans[i]=to[i];\n\t\treturn 1;\n\t}\n\tint ret=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(str[i].size()!=len)continue;\n\t\tbool ok=true;\n\t\tfor(int j=0;j<str[i].size();j++){\n\t\t\tif((~conv[str[i][j]-'A']&&conv[str[i][j]-'A']!=q[at][j]-'A')||\n\t\t\t(~conv[q[at][j]-'A']&&conv[q[at][j]-'A']!=str[i][j]-'A'))ok=false;\n\t\t}\n\t\tif(ok){\n\t\t\tint rev[26];\n\t\t\tfor(int j=0;j<26;j++)rev[j]=conv[j];\n\t\t\tto[at]=i;\n\t\t\tfor(int j=0;j<str[i].size();j++){\n\t\t\t\tif(!~conv[str[i][j]-'A']){\n\t\t\t\t\tconv[str[i][j]-'A']=q[at][j]-'A';\n\t\t\t\t}else if(conv[str[i][j]-'A']!=q[at][j]-'A')ok=false;\n\t\t\t\tif(!~conv[q[at][j]-'A']){\n\t\t\t\t\tconv[q[at][j]-'A']=str[i][j]-'A';\n\t\t\t\t}else if(conv[q[at][j]-'A']!=str[i][j]-'A')ok=false;\n\t\t\t}\n\t\t\tif(ok)ret+=dfs();\n\t\t\tto[at]=-1;\n\t\t\tfor(int j=0;j<26;j++)conv[j]=rev[j];\n\t\t}\n\t\tif(ret>1)return 2;\n\t}\n\treturn ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tn=a;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tstr[i]=in;\n\t\t}\n\t\tsz=0;\n\t\twhile(1){\n\t\t\tscanf(\"%s\",in);\n\t\t\tif(in[strlen(in)-1]=='.'){\n\t\t\t\tin[strlen(in)-1]=0;\n\t\t\t\tq[sz++]=in;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tq[sz++]=in;\n\t\t}\n\t\tfor(int i=0;i<26;i++)conv[i]=-1;\n\t\tfor(int i=0;i<sz;i++)to[i]=-1;\n\t\tint ret=dfs();\n\t\tif(ret>1)printf(\"-.\\n\");\n\t\telse{\n\t\t\tfor(int i=0;i<sz;i++){\n\t\t\t\tif(i)printf(\" \");\n\t\t\t\tprintf(\"%s\",str[ans[i]].c_str());\n\t\t\t}\n\t\t\tprintf(\".\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint n;\nchar word[20][21];\nvector<int> L[21]; // L[l] := ( 長さ l の単語の集合 )\n\nchar s[128];\nvector<int> pos,len; // 空白で区切った s の部分文字列の開始位置と長さ\n\nchar f[128],f_ans[128]; // アルファベットの対応表\n\nbool used[80]; // s の部分文字列 i をすでに調べたかどうか\nbool dfs(){\n\tint i0=-1;\n\trep(i,len.size()) if(!used[i]) {\n\t\tif(i0==-1 || len[i0]<len[i]) i0=i;\n\t}\n\tif(i0==-1){\n\t\tmemcpy(f_ans,f,sizeof f);\n\t\treturn true;\n\t}\n\n\tint cnt=0,m=len[i0];\n\tconst char *t=s+pos[i0];\n\tchar tmp[128];\n\trep(i,L[m].size()){\n\t\tconst char *w=word[L[m][i]]; // 部分文字列 t に単語 w を割り当てる\n\n\t\tbool ok=true; // その割り当てで矛盾が起こらないか\n\t\tmemcpy(tmp,f,sizeof f);\n\t\trep(j,m){\n\t\t\tchar c1=t[j],c2=w[j];\n\t\t\tif(f[c1]!='?' && f[c2]!='?'){\n\t\t\t\tif(c2!=f[c1]) ok=false;\n\t\t\t}\n\t\t\telse if(f[c1]=='?' && f[c2]=='?'){\n\t\t\t\tf[c1]=c2;\n\t\t\t\tf[c2]=c1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tok=false;\n\t\t\t}\n\t\t}\n\n\t\tif(ok){\n\t\t\tused[i0]=true;\n\t\t\tif(dfs()) cnt++;\n\t\t\tused[i0]=false;\n\t\t}\n\n\t\tmemcpy(f,tmp,sizeof f);\n\n\t\tif(cnt>=2) return false;\n\t}\n\n\treturn cnt==1;\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\trep(i,n) scanf(\"%s \",word[i]);\n\t\trep(l,21) L[l].clear();\n\t\trep(i,n) L[strlen(word[i])].push_back(i);\n\n\t\tfgets(s,128,stdin);\n\t\tpos.clear();\n\t\tlen.clear();\n\t\tfor(int i=0,pre=0;;i++){\n\t\t\tif(s[i]=='.' || s[i]==' '){\n\t\t\t\tpos.push_back(pre);\n\t\t\t\tlen.push_back(i-pre);\n\t\t\t\tpre=i+1;\n\t\t\t\tif(s[i]=='.') break;\n\t\t\t}\n\t\t}\n\n\t\tfor(char c='A';c<='Z';c++) f[c]='?';\n\n\t\trep(i,pos.size()) used[i]=false;\n\t\tif(!dfs()) puts(\"-.\");\n\t\telse{\n\t\t\trep(i,pos.size()){\n\t\t\t\trep(j,len[i]) putchar(f_ans[s[pos[i]+j]]);\n\t\t\t\tputchar(i<(int)pos.size()-1?' ':'.');\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n \nusing namespace std;\n \ntypedef long long ll;\n \nint n,found,buf_length;\nvector<string> word[30],buf;\nstring sequence;\nchar transfer[26];\nvector<ll> bitmask;\nvector<int> bc;\nset<string> exist;\nchar table[26];\n \nbool cmp(const string& a,const string& b){ return a.size() > b.size(); }\n \nvoid dfs(int cur,long long bit){\n \n  if( found >= 2 ) return;\n \n  //rep(i,26) cout << table[i] << \" \";\n  //cout << endl;\n \n  if( cur >= buf_length ){\n    found++;\n    rep(i,26) transfer[i] = table[i];\n    return;\n  }\n \n \n  int len = buf[cur].size();\n \n  if( __builtin_popcountll( bit & bitmask[cur] ) == bc[cur] ) {\n    string tmp = buf[cur];\n    rep(i,len) tmp[i] = table[tmp[i]-'A'];\n    if( exist.find(tmp) != exist.end() ) dfs(cur+1,bit);\n    return;\n  }\n \n \n  char tmp_table[26];\n  rep(i,26) tmp_table[i] = table[i];\n  rep(i,word[len].size()){\n    //cout<< endl;\n    //rep(j,26) cout << table[j] << \" \"; cout << endl;\n    // cout << \"word \" << word[len][i] << \" is \";\n    bool error = false;\n    long long new_bit = bit;\n    //rep(j,26) table[j] = tmp_table[j];\n    rep(j,len){\n \n \n      if( table[buf[cur][j]-'A'] == '?' && table[word[len][i][j]-'A'] == '?' ) {\n        long long SHIFT = word[len][i][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        SHIFT = buf[cur][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        table[buf[cur][j]-'A']     = word[len][i][j];\n        table[word[len][i][j]-'A'] = buf[cur][j];\n      } else if( !( table[buf[cur][j]-'A'] == word[len][i][j] && table[word[len][i][j]-'A'] == buf[cur][j] ) ) {\n        //cout << \"table[\" << buf[cur][j] << \"] != \" << table[buf[cur][j]-'A'] << \" ?= \" << word[len][i][j] << endl;\n        //cout << \"table[\" << word[len][i][j] << \"] != \" << table[word[len][i][j]-'A'] << \" ?= \" << buf[cur][j] << endl;\n        error = true;\n        break;\n      }\n    }\n \n    if( error ){\n      //cout << \"bad\" << endl;\n      continue;\n    } //cout << \"ok\" << endl;\n    dfs(cur+1,new_bit);\n    rep(j,len){\n      int idx = buf[cur][j] - 'A';\n      table[idx] = tmp_table[idx];\n      idx = word[len][i][j] - 'A';\n      table[idx] = tmp_table[idx];\n    }\n    if( found >= 2 ) return;\n  }\n}\n \nint main(){\n  while( cin >> n, n ){\n    string tmp;\n    found = 0;\n    buf.clear(), tmp.clear();\n    rep(i,26)transfer[i] = table[i] = '?';\n    rep(i,30) word[i].clear();\n    rep(i,n){\n      cin >> tmp;\n      word[(int)tmp.size()].push_back(tmp);\n      exist.insert(tmp);\n    }\n    cin.ignore();\n    getline(cin,sequence);\n    tmp = sequence.substr(0,(int)sequence.size()-1);\n    stringstream ss(tmp);\n    while( !( ss >> tmp ).fail() ) buf.push_back(tmp);\n \n    sort(buf.begin(),buf.end(),cmp);\n    buf.erase(unique(buf.begin(),buf.end()),buf.end());\n    buf_length = (int) buf.size();\n    bitmask.clear(), bc.clear();\n    bitmask.resize(buf_length,0), bc.resize(buf_length);\n    rep(i,buf_length){\n      rep(j,buf[i].size()){\n        long long SHIFT = buf[i][j] - 'A';\n        bitmask[i] |= (1LL<<SHIFT);\n      }\n      bc[i] = __builtin_popcountll(bitmask[i]);\n    }\n \n    dfs(0,0LL);\n \n    if( found == 1 ) {\n      rep(i,sequence.size()) cout << (isupper(sequence[i])?transfer[sequence[i]-'A']:sequence[i]);\n      puts(\"\");\n    } else puts(\"-.\");\n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cstring>\n#include <sstream>\nusing namespace std;\n\nint n, m;\nstring cand[22];\nvector<string> words;\n\nvector<int> match[82];\nint matchBit[82];\n\nvector<char> ansKey;\nint ansFlg;\n\nbool matches(string a, string b){\n  if(a.size() != b.size()) return false;\n  char trans[128];\n  memset(trans, -1, sizeof(trans));\n  for(int i = 0; i < a.size(); i++){\n    if(trans[a[i]] != -1 && b[i] != trans[a[i]]) return false;\n    if(trans[b[i]] != -1 && a[i] != trans[b[i]]) return false;\n    trans[a[i]] = b[i];\n    trans[b[i]] = a[i];\n  }\n  return true;\n}\n\nbool mycmp(const string &a, const string &b){\n  set<char> st1;\n  for(int i = 0; i < a.size(); i++) st1.insert(a[i]);\n  set<char> st2;\n  for(int i = 0; i < b.size(); i++) st2.insert(b[i]);\n\n  return st1.size() > st2.size();\n}\n\nbool setKey(const string &a, const string &b, vector<char> &key){\n  for(int i = 0; i < a.size(); i++){\n    if(key[a[i]] != -1 && key[a[i]] != b[i] ||\n       key[b[i]] != -1 && key[b[i]] != a[i]){\n      return false;\n    }\n    key[a[i]] = b[i];\n    key[b[i]] = a[i];\n  }\n  return true;\n}\n\nvoid dfs(int idx, int used, vector<char> key){\n  if(idx == m){\n    if(ansFlg == 1){\n      ansFlg = -1;\n    }\n    else{\n      ansFlg = 1;\n      ansKey = key;\n    }\n    return;\n  }\n\n  for(int i = 0; i < match[idx].size(); i++){\n    int j = match[idx][i];\n    if(used & (1 << j)) continue;\n\n    vector<char> nextKey = key;\n    if(setKey(words[idx], cand[j], nextKey)){\n      dfs(idx + 1, used | (1 << j), nextKey);\n      if(ansFlg == -1) return;\n    }\n  }\n}\n\nvoid solve(){\n  sort(words.begin(), words.end(), mycmp);\n\n  for(int i = 0; i < m; i++){\n    match[i].clear();\n    matchBit[i] = 0;\n\n    for(int j = 0; j < n; j++){\n      if(matches(words[i], cand[j])){\n        match[i].push_back(j);\n        matchBit[i] |= (1 << j);\n      }\n    }\n  }\n\n  vector<char> key(128, -1);\n  ansFlg = 0;\n  dfs(0, 0, key);\n}\n\nint main(){\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++){\n      cin >> cand[i];\n\n      for(int j = 0; j < i; j++){\n        if(cand[j] == cand[i]){\n          i--;\n          n--;\n          break;\n        }\n      }\n    }\n\n    string s;\n    getline(cin, s);\n    getline(cin, s);\n    for(int i = 0; i < s.size(); i++) if(s[i] == '.') s[i] = ' ';\n\n    vector<string> raw;\n    stringstream ss(s);\n    words.clear();\n\n    while(ss >> s){\n      raw.push_back(s);\n\n      bool pushFlg = true;\n      for(int i = 0; i < words.size(); i++){\n        if(words[i] == s){\n          pushFlg = false;\n          break;\n        }\n      }\n      if(pushFlg) words.push_back(s);\n    }\n    m = words.size();\n\n    solve();\n\n    if(ansFlg == 1){\n      for(int i = 0; i < raw.size(); i++){\n        if(i != 0) cout << \" \";\n        for(int j = 0; j < raw[i].size(); j++){\n          cout << ansKey[raw[i][j]];\n        }\n      }\n      cout << \".\" << endl;\n    }\n    else{\n      cout << \"-.\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint n,found,buf_length;\nvector<string> word[30],buf;\nstring sequence;\nchar transfer[26];\n\nbool cmp(const string& a,const string& b){ return a.size() > b.size(); }\n\nvoid dfs(int cur,vector<char> table){\n\n  if( found >= 2 ) return;\n\n  if( cur >= buf_length ){\n    found++;\n    rep(i,26) transfer[i] = table[i];\n    return;\n  }\n\n  int len = buf[cur].size();\n  rep(i,word[len].size()){\n    vector<char> ntable = table;\n    bool error = false;\n    rep(j,len){\n      assert( buf[cur][j]-'A' < 26 );\n      assert( word[len][i][j]-'A' < 26 );\n      if( ntable[buf[cur][j]-'A'] == '?' && ntable[word[len][i][j]-'A'] == '?' ) {\n        ntable[buf[cur][j]-'A']     = word[len][i][j];\n        ntable[word[len][i][j]-'A'] = buf[cur][j];\n      } else if( !( ntable[buf[cur][j]-'A'] == word[len][i][j] && ntable[word[len][i][j]-'A'] == buf[cur][j] ) ) {\n        error = true;\n        break;\n      }\n    }\n    if( error ) continue;\n    dfs(cur+1,ntable);\n    if( found >= 2 ) return;\n  }\n  return ;\n}\n\nint main(){\n  while( cin >> n, n ){\n    string tmp;\n    found = 0;\n    buf.clear();\n    rep(i,26)transfer[i] = '?';\n    rep(i,30) word[i].clear();\n    rep(i,n){\n      cin >> tmp;\n      word[(int)tmp.size()].push_back(tmp);\n    }\n    cin.ignore();\n    getline(cin,sequence);\n    tmp = sequence.substr(0,(int)sequence.size()-1);\n    stringstream ss(tmp);\n    while( !( ss >> tmp ).fail() ) buf.push_back(tmp);\n\n    sort(buf.begin(),buf.end(),cmp);\n    buf_length = (int) buf.size();\n\n    dfs(0,vector<char>(26,'?'));\n\n    if( found == 1 ) {\n      rep(i,sequence.size()) cout << (isupper(sequence[i])?transfer[sequence[i]-'A']:sequence[i]);\n      puts(\"\");\n    } else puts(\"-.\");\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n\nvs dfs(vs &words,vs &c_words,map<char,char> &m,int cur,vs &orig_c_words){\n  vs ret;\n  if(cur==orig_c_words.size()){\n    REP(i,orig_c_words.size()){\n      string s;\n      REP(j,orig_c_words[i].size()){\n        s.push_back(m[orig_c_words[i][j]]);\n      }\n      ret.push_back(s);\n    }\n    return ret;\n  }\n\n  REP(i,words.size()){\n    if(words[i].size()==c_words[cur].size()){\n      map<char,char> nm(m);\n      bool ok=true;\n      REP(j,words[i].size()){\n        map<char,char>::iterator it_i=nm.find(words[i][j]);\n        map<char,char>::iterator it_c=nm.find(c_words[cur][j]);\n        bool ei=it_i!=nm.end();\n        bool ec=it_c!=nm.end();\n        if(ei&&ec){\n          if(it_i->second!=c_words[cur][j]||it_c->second!=words[i][j]){\n            ok=false;\n            break;\n          }\n        }else if(ei||ec){\n          ok=false;\n          break;\n        }else{\n          nm[words[i][j]]=c_words[cur][j];\n          nm[c_words[cur][j]]=words[i][j];\n        }\n      }\n      if(ok){\n        //cerr<<\"cur:\"<<cur<<endl;\n        vs res=dfs(words,c_words,nm,cur+1,orig_c_words);\n        //cerr<<\"res:\"<<res.size()<<endl;\n        if(res.size()>0){\n          if(res.size()==30){\n            return vs(30);\n          }\n          if(ret.size()){\n            return vs(30);\n          }else{\n            ret=res;\n          }\n        }\n      }\n    }\n  }\n  return ret;\n\n}\nbool pred(const string &l,const string &r){\n  if(l.size()==r.size()){\n    return l>r;\n  }else{\n    return l.size()>r.size();\n  }\n}\nint main(){\n  int n;\n  while(cin>>n,n){\n    vs words(n);\n    REP(i,n){\n      cin>>words[i];\n    }\n    string sequence;\n    getline(cin,sequence);\n    getline(cin,sequence);\n    vs c_words;\n    int prev=0;\n    REP(i,sequence.size()){\n      switch(sequence[i]){\n        case ' ':\n        case '.':\n          c_words.push_back(sequence.substr(prev,i-prev));\n          prev=i+1;\n          break;\n      }\n    }\n    vs orig_c_words(c_words);\n    sort(ALL(c_words),pred);\n    map<char,char> m;\n    vs res=dfs(words,c_words,m,0,orig_c_words);\n    if(res.size()&&res.size()<30){\n      REP(i,res.size()){\n        cout<<res[i]<<(i<res.size()-1?\" \":\"\");\n      }\n      cout<<\".\"<<endl;\n    }else{\n      cout<<\"-.\"<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int MAX_V = 40;\nint V = MAX_V; //頂点数\nvector<int> G[MAX_V]; //グラフ\nint match[MAX_V]; // マッチングのペア\nbool used[MAX_V]; // dfsで既に調べたか\n\nvoid add_edge(int u, int v){\n    G[u].push_back(v); G[v].push_back(u);\n}\n\n// 増加パスの探索\nbool bp_dfs(int v){\n    used[v]=true;\n    rep(i,G[v].size()){\n        int u=G[v][i], w=match[u];\n        if(w<0 || (!used[w]&&bp_dfs(w))){\n            match[v]=u; match[u]=v;\n            return true;\n        }\n    }\n    return false;\n}\n\nint bipartite_matching(){\n    int ret=0;\n    memset(match,-1,sizeof(match));\n    rep(i,V){\n        if(match[i]<0){\n            memset(used,0,sizeof(used));\n            if(bp_dfs(i)) ++ret;\n        }\n    }\n    return ret;\n}\n\n\nvector<string> read_seq(){\n    vector<string> ret;\n    while(1){\n        string s;\n        cin >>s;\n\n        if(s.back() == '.'){\n            ret.pb(s.substr(0,s.size()-1));\n            break;\n        }\n        ret.pb(s);\n    }\n    return ret;\n}\n\nconst int A = 'Z'-'A'+1;\n\nint n,m;\nvector<string> w,s;\nint ct;\n\nvector<int> EN;\nvector<bool> uw;\nvoid dfs(int d, const vector<int> &en){\n    if(d==m){\n        ++ct;\n        EN = en;\n        return;\n    }\n\n    int sz = s[d].size();\n    rep(i,n)if(!uw[i]){\n        if(s[d].size() != w[i].size()) continue;\n\n        bool valid = true;\n        vector<int> t_en(en);\n        rep(j,sz){\n            int idw = w[i][j]-'A', ids = s[d][j]-'A';\n\n            if(t_en[idw]==-1) t_en[idw] = ids;\n            else{\n                if(t_en[idw] != ids){\n                    valid = false;\n                    break;\n                }\n            }\n\n            if(t_en[ids]==-1) t_en[ids] = idw;\n            else{\n                if(t_en[ids] != idw){\n                    valid = false;\n                    break;\n                }\n            }\n        }\n        if(!valid) continue;\n\n        // check\n        rep(j,MAX_V) G[j].clear();\n        for(int ii=d+1; ii<m; ++ii)rep(jj,n){\n            if(uw[jj] || jj==i) continue;\n            if(s[ii].size() != w[jj].size()) continue;\n\n            int LEN = s[ii].size();\n            bool add = true;\n            rep(k,LEN){\n                if(t_en[w[jj][k]-'A'] != -1 && t_en[w[jj][k]-'A'] != s[ii][k]-'A') add = false;\n\n                if(t_en[s[ii][k]-'A'] != -1 && t_en[s[ii][k]-'A'] != w[jj][k]-'A') add = false;\n\n                if(!add) break;\n            }\n\n            if(add){\n                // printf(\" --- ADD %d %d\\n\",ii,jj);\n                add_edge(ii,m+jj);\n            }\n        }\n\n        int res = bipartite_matching();\n        if(res == m-1-d){\n            uw[i] = true;\n            dfs(d+1,t_en);\n            uw[i] = false;\n            if(ct>1) return;\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);ios::sync_with_stdio(false);\n    while(cin >>n,n){\n        w = vector<string>(n);\n        rep(i,n) cin >>w[i];\n\n        vector<string> seq = read_seq();\n\n        s = seq;\n        sort(all(s));\n        s.erase(unique(all(s)), s.end());\n        m = s.size();\n\n        sort(all(s), [](const string &lh, const string &rh){ return (lh.size()==rh.size() ? (lh<rh) : (lh.size() > rh.size())); });\n\n        uw = vector<bool>(n,false);\n        ct = 0;\n        dfs(0, vector<int>(A,-1));\n\n        string ans = \"\";\n        if(ct == 1){\n            rep(i,seq.size()){\n                if(i) ans += ' ';\n                rep(j,seq[i].size()) ans += EN[seq[i][j]-'A']+'A';\n            }\n        }\n        else ans = \"-\";\n\n        ans += '.';\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <stdexcept>\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n#define phb push_back\n#define ppb pop_back\nusing namespace std;\n\nint N;\nstring D[20];\nvector< string > S;\n\nvector< string > t;\nvector< int > mtc, res;\nint tbl[128], clv[128];\n\nbool read();\nvoid solve();\n\nvoid dfs(int);\n\nint main() {\n\twhile (read())\n\t\tsolve();\n\t\n\treturn 0;\n}\n\nbool read() {\n\tstring str, ln;\n\tistringstream iss;\n\t\n\tgetline(cin, ln), iss.clear(), iss.str(ln);\n\tif (iss >> N, N == 0)\n\t\treturn false;\n\t\n\tfor (int i = 0; i < N; ++i)\n\t\tgetline(cin, D[i]);\n\t\n\tgetline(cin, ln), ln.back() = ' ', iss.clear(), iss.str(ln);\n\tS.clear();\n\twhile (iss >> str)\n\t\tS.phb(str);\n\t\n\treturn true;\n}\n\nvoid solve() {\n\tt.clear();\n\tfor (int i = 0; i < sz(S); ++i)\n\t\tif (find(all(t), S[i]) == t.end())\n\t\t\tt.phb(S[i]);\n\t\n\tauto cmpf = [&] (const string &ra, const string &rb) -> bool {\n\t\treturn sz(ra) > sz(rb);\n\t};\n\t\n\tsort(&D[0], &D[N], cmpf);\n\tsort(all(t), cmpf);\n\t\n\tfill(&tbl[0], &tbl[128], 0);\n\tfill(&clv[0], &clv[128], -1);\n\tmtc.clear(), res.clear();\n\t\n\ttry {\n\t\tdfs(0);\n\t\tfor (int i = 0; i < sz(S); ++i) {\n\t\t\tint k = int(find(all(t), S[i]) - t.begin());\n\t\t\tcout << D[res[k]] << (i + 1 == sz(S) ? \".\" : \" \");\n\t\t}\n\t}\n\tcatch (...) {\n\t\tcout << \"-.\";\n\t}\n\tcout << \"\\n\";\n}\n\nvoid dfs(int u) {\n\tif (u == sz(t)) {\n\t\tif (!res.empty())\n\t\t\tthrow exception();\n\t\tres = mtc;\n\t}\n\telse {\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tif (sz(D[i]) == sz(t[u])) {\n\t\t\t\tint j = 0, c1, c2;\n\t\t\t\t\n\t\t\t\twhile (j < sz(D[i])) {\n\t\t\t\t\tc1 = int(D[i][j]), c2 = int(t[u][j]);\n\t\t\t\t\tif ((tbl[c1] != 0 && tbl[c1] != c2) || (tbl[c2] != 0 && tbl[c2] != c1))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (tbl[c1] == 0)\n\t\t\t\t\t\ttbl[c1] = c2, tbl[c2] = c1, clv[c1] = clv[c2] = u;\n\t\t\t\t\t++j;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (j == sz(D[i])) {\n\t\t\t\t\tmtc.phb(i);\n\t\t\t\t\tdfs(u + 1);\n\t\t\t\t\tmtc.ppb();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhile ((--j) >= 0) {\n\t\t\t\t\tc1 = int(D[i][j]), c2 = int(t[u][j]);\n\t\t\t\t\tif (clv[c1] == u)\n\t\t\t\t\t\ttbl[c1] = tbl[c2] = 0, clv[c1] = clv[c2] = -1;\n\t\t\t\t}\n\t\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nstring t[100];\nbool used[100];\nvector<string> v;\nmap< char , char > mp;\ntypedef pair< char , char > P;\n\nbool check( vector<int> a, string b , vector<int> c, string d ){\n  int size=a.size();\n  map< char , set<int> > T;\n  for(char ch='A';ch<='Z';ch++){\n    if(mp.count(ch)){\n      T[ch].insert(mp[ch]);\n    }\n  }\n  \n  for(int i=0;i<size;i++){\n    if(a[i]==-1)continue;\n    T[ b[i] ].insert( d[i] );\n    T[ d[i] ].insert( b[i] );\n    if( T[ b[i] ].size() > 1 )return false;\n    if( T[ d[i] ].size() > 1 )return false;\n  }\n  return true;\n}\n\nstring Replace(string s,bool flag=false){\n  for(int i=0;i<(int)s.size();i++){\n    if(mp.count(s[i]))s[i]=mp[s[i]];\n    else{\n      if(flag)s[i]='?';\n    }\n  }\n  return s;\n}\n\nvector<int> change(string s){\n  vector<int> res(s.size());\n  map<char,int> flg;\n  for(int i=0;i<(int)s.size();i++){\n    if(mp.count(s[i])){\n      res[i]=-1;\n      continue;\n    }\n    if( flg.count(s[i]) ){\n      res[i]=flg[ s[i] ];\n    }else{\n      res[i]=flg.size();\n      flg[ s[i] ]=res[i];\n    }\n  }\n  return res;\n}\n\nvoid Add(string s,string t){\n  for(int i=0;i<(int)s.size();i++){\n    mp[ s[i] ] = t[i];\n    mp[ t[i] ] = s[i];\n  }\n}\n\nbool solve(){\n  set< int > pa;\n  bool update=true;\n  while(update){\n    update=false;\n    vector<int> cnt( v.size(), 0 );\n    \n    for(int i=0;i<n;i++){\n      string str=Replace(t[i],true);\n      vector<int> hashv=change(t[i]);\n      vector<int> target;\n      set< string > st;\n      for(int j=0;j<(int)v.size();j++){\n        if( pa.count(j) )continue;\n        \n        string tmp=Replace(Replace(v[j],true));\n        vector<int> hashw=change(v[j]);\n        if(str==tmp && hashv == hashw && check(hashv,t[i],hashw,v[j])){\n          cnt[j]++;\n        }\n      }\n    }\n\n\n    bool loopf=false;\n    for(int i=0;i<n;i++){\n      \n      string str=Replace(t[i],true);\n      vector<int> hashv=change(t[i]);\n      \n      for(int j=0;j<(int)v.size();j++){\n        string tmp=Replace(Replace(v[j],true));\n        vector<int> hashw=change(v[j]);\n        \n        if(str==tmp && hashv == hashw && cnt[j]==1 && check(hashv,t[i],hashw,v[j])){\n          pa.insert(j);\n          Add(t[i],v[j]);\n          loopf=true;\n          update=true;\n          break;\n        }\n      }\n\n      if(loopf)break;\n    }\n    \n\n  }// while update\n\n  if(pa.size()!=v.size())return false;\n  return true;\n}\n\nvoid init(){\n  v.clear();\n  mp.clear();\n  memset(used,false,sizeof(used));\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++)cin>>t[i];\n    string tmp,str;\n    getline(cin,tmp);\n    getline(cin,tmp);\n    stringstream ss(tmp);\n    while(ss>>str){\n      if( str.back() == '.' )str.pop_back();\n      v.push_back(str);\n    }\n    if( solve() ){\n      for(int i=0;i<(int)v.size();i++){\n        if(i)cout<<' ';\n        cout<<Replace(v[i]);\n      }\n      cout<<'.'<<endl;\n    }else{\n      cout<<\"-.\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <map>\n#include <numeric>\n#include <cmath>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <complex>\n#include <string.h>\n#include <iomanip>\nusing namespace std;\n\ntypedef long long ll;\n\nvector<string> words, chi, plain;\nint n, m;\n\nint cor[26];\nbool rcor[26];\nbool used[30];\n\nbool check(string a, string b) {\n  int k = b[b.size()-1] == '.' ? -1 : 0;\n  if (a.size() != b.size()+k) return false;\n  int l = a.size();\n  for (int i = 0; i < l; i++) {\n    if ((cor[b[i]-'A'] >= 0 && cor[b[i]-'A'] != a[i]-'A') || (cor[b[i]-'A'] < 0 && rcor[a[i]-'A']))\n      return false;\n  }\n  //  cout << a << \" \" << b << endl;\n  return true;\n}\n\nvoid calc(int k) {\n  if (k == n) {\n    for (int i = 0; i < m; i++) {\n      if (!used[i]) {\n\treturn;\n      }\n    }\n    string s = \"\";\n    for (int i = 0; i < m-1; i++) {\n      for (int j = 0; j < chi[i].size(); j++) {\n\tchar c = 'A' + cor[chi[i][j]-'A'];\n\ts += c;\n      }\n      s += ' ';\n    }\n    for (int i = 0; i < chi[m-1].size()-1; i++) {\n      char c = 'A' + cor[chi[m-1][i]-'A'];\n      s += c;\n    }\n    s += '.';\n    plain.push_back(s);\n    return;\n  }\n  for (int i = 0; i < m; i++) {\n    if (!used[i] && check(words[k], chi[i])) {\n      vector<int> change;\n      int l = words[k].size();\n      for (int j = 0; j < l; j++) {\n\tif (cor[chi[i][j]-'A'] < 0) {\n\t  change.push_back(chi[i][j]-'A');\n\t  cor[chi[i][j]-'A'] = words[k][j]-'A';\n\t  rcor[chi[i][j]-'A'] = rcor[words[k][j]-'A'] = true;\n\t}\n      }\n      //      cout << words[k] << \" \" << chi[i] << \" \" << i << endl;\n      for (int j = 0; j < m; j++)\n\tif (chi[i] == chi[j])\n\t  used[j] = true;\n\n      calc(k+1);\n      for (int p = 0; p < change.size(); p++)\n\tcor[change[p]] = -1;\n\n      for (int j = 0; j < m; j++)\n\tif (chi[i] == chi[j])\n\t  used[j] = false;      \n    }\n  }\n  calc(k+1);\n}\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(15);\n\n  while (true) {\n    cin >> n;\n    if (n == 0) break;\n    words.clear();\n    chi.clear();\n    plain.clear();\n    for (int i = 0; i < n; i++) {\n      string s;\n      cin >> s;\n      words.push_back(s);\n    }\n    while (true) {\n      string s;\n      cin >> s;\n      chi.push_back(s);\n      if (s[s.size()-1] == '.') break;\n    }\n    m = chi.size();\n    fill_n(used, m, false);\n    fill_n(cor, 26, -1);\n    fill_n(rcor, 26, false);\n    calc(0);\n    if (plain.size() == 1)\n      cout << plain[0] << endl;\n    else\n      cout << \"-.\" << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int N = 20;\n\nint n, ans;\nstring tmp, ans_rev;\nvector<string> words[N+1], cands[N+1];\nbool vis[26];\n\ninline bool valid(string &tar, string &s, string &rev) {\n  for(size_t i = 0; i<s.size(); ++i) {\n    if(rev[s[i]] != -1 && rev[s[i]] != tar[i])\n      return false;\n    if(rev[tar[i]] != -1 && rev[tar[i]] != s[i])\n      return false;\n  }\n  return true;\n}\nvoid dfs(int l, size_t x, string &rev) {\n  if(ans > 1)\n    return;\n  while(l && x >= words[l].size()) {\n    x = 0;\n    --l;\n  }\n  if(l == 0) {\n    ans_rev = rev;\n    //for(auto c : ans_rev)\n    //  cerr << char(c + 'A');\n    //cerr << endl;\n    ++ans;\n    return;\n  }\n  string &tar = words[l][x];\n  for(size_t j = 0; j<cands[l].size(); ++j) {\n    if(vis[j])\n      continue;\n    string &s = cands[l][j];\n    if(valid(tar, s, rev)) {\n      string nrev = rev;\n      size_t i = 0;\n      for(; i<s.size(); ++i)\n        if(nrev[s[i]] == -1) {\n          if(nrev[tar[i]] != -1)\n            break;\n          nrev[s[i]] = tar[i];\n          nrev[tar[i]] = s[i];\n        }\n      if(i != s.size())\n        continue;\n      vis[j] = true;\n      dfs(l, x+1, nrev);\n      vis[j] = false;\n    }\n  }\n}\nvoid cleanup(vector<string>& v) {\n  sort(v.begin(), v.end());\n  v.resize(unique(v.begin(), v.end()) - v.begin());\n}\nvoid init() {\n  for(int i = 0; i<=N; ++i)\n    words[i].clear(), cands[i].clear();\n  ans = 0;\n  memset(vis, 0, sizeof(vis));\n}\nvoid solve() {\n  init();\n  for(int i = 0; i<n; ++i) {\n    cin >> tmp;\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    cands[tmp.size()].push_back(tmp);\n  }\n  vector<string> sent;\n  bool cont = true;\n  while(cont) {\n    cin >> tmp;\n    if(tmp.back() == '.') {\n      tmp.pop_back();\n      cont = false;\n    }\n    sent.push_back(tmp);\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    words[tmp.size()].push_back(tmp);\n  }\n  for(int i = 1; i<=N; ++i)\n    cleanup(words[i]);\n  string rev(26, -1);\n  dfs(N, 0, rev);\n  if(ans == 1) {\n    for(size_t i = 0; i<sent.size(); ++i) {\n      for(auto c : sent[i]) \n        putchar(ans_rev[c - 'A'] == -1 ? c : ans_rev[c - 'A'] + 'A');\n      putchar(i+1 == sent.size() ? '.' : ' ');\n    }\n    puts(\"\");\n  } else\n    puts(\"-.\");\n}\nint main() {\n  while(scanf(\"%d\", &n) == 1 && n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int nMax=21;\nconst int lMax=22;\nint n;\nstruct str\n{\n\tchar s[lMax];\n}aim[lMax][81],st[lMax][nMax];\nint aim_cnt[lMax],st_cnt[lMax],sub[27],ans[27],ans_cnt,sub_flag[27];\nint q2[65536],q_r;\nchar ret[90],r_len;\nint judge(int len,int id1,int id2)\n{\n\tfor(int i=1;i<=len;i++)\n\t{\n\t\tif(sub[aim[len][id1].s[i]-'A'+1]==st[len][id2].s[i]-'A'+1)\n\t\t{\n\t\t\tif(sub_flag[aim[len][id1].s[i]-'A'+1]==0)\n\t\t\t{ \n\t\t\t\tsub_flag[aim[len][id1].s[i]-'A'+1]=1;\n\t\t\t\tq2[q_r++]=aim[len][id1].s[i]-'A'+1;\n\t\t\t\tq_r%=65536;\n\t\t\t}\n\t\t\tif(sub_flag[st[len][id2].s[i]-'A'+1]==0)\n\t\t\t{\n\t\t\t\tq2[q_r++]=st[len][id2].s[i]-'A'+1;\n\t\t\t\tq_r%=65536;\n\t\t\t\tsub_flag[st[len][id2].s[i]-'A'+1]=1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif(sub_flag[aim[len][id1].s[i]-'A'+1]==0&&sub_flag[st[len][id2].s[i]-'A'+1]==0)\n\t\t{\n\t\t\tsub[aim[len][id1].s[i]-'A'+1]=st[len][id2].s[i]-'A'+1;\n\t\t\tsub[st[len][id2].s[i]-'A'+1]=aim[len][id1].s[i]-'A'+1;\n\t\t\tsub_flag[aim[len][id1].s[i]-'A'+1]=1;\n\t\t\tsub_flag[st[len][id2].s[i]-'A'+1]=1;\n\t\t\tq2[q_r++]=aim[len][id1].s[i]-'A'+1;\n\t\t\tq_r%=65536;\n\t\t\tq2[q_r++]=st[len][id2].s[i]-'A'+1;\n\t\t\tq_r%=65536;\n\t\t}\n\t\telse\n\t\t{\n//\t\t\tprintf(\"%d %s %s %d\\n\",len,aim[len][id1].s+1,st[len][id2].s+1,i);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\nvoid dfs(int len,int id,int d_clock)\n{\n\tif(len==0)\n\t{\n\t\tans_cnt++;\n\t\tfor(int i=1;i<=26;i++)\n\t\t\tans[i]=sub[i];\n\t\treturn;\n\t}\n\tif(id+1>aim_cnt[len])\n\t{\n\t\tdfs(len-1,0,d_clock);\n\t\treturn;\n\t}\n\tint nid=id+1,now,en;\n\tfor(int i=1;i<=st_cnt[len];i++)\n\t{\n\t\tnow=q_r;\n\t\tif(judge(len,nid,i))\n\t\t{\n\t\t\ten=q_r;\n\t\t\tdfs(len,nid,d_clock+1);\n\t\t\tif(ans_cnt>1)\n\t\t\t\treturn;\n\t\t}\n\t\telse\n\t\t\ten=q_r;\n\t\tfor(int k=now;k!=en;k=(k+1)%65536)\n\t\t{\n\t\t\tsub[q2[k]]=q2[k];\n\t\t\tsub_flag[q2[k]]=0;\n\t\t}\n\t}\n}\nvoid add(char *s,int len)\n{\n\tret[++r_len]=' ';\n\tfor(int i=1;i<=len;i++)\n\t{\n\t\tr_len++;\n\t\tret[r_len]=s[i];\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\twhile(n!=0)\n\t{\n\t\tint ok=1;\n\t\tmemset(aim_cnt,0,sizeof(aim_cnt));\n\t\tmemset(st_cnt,0,sizeof(st_cnt));\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tstr din;\n\t\t\tscanf(\"%s\",din.s+1);\t\t\n\t\t\tint len=strlen(din.s+1);\n\t\t\tst[len][++st_cnt[len]]=din;\n\t\t}\n\t\tchar din[82];\n\t\tr_len=0;\n\t\tscanf(\"%s\",din+1);\n\t\tint len=strlen(din+1);\n\t\tadd(din,len);\n\t\twhile(din[len]!='.')\n\t\t{\n\t\t\tif(len>20)\n\t\t\t{\n\t\t\t\tok=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t++aim_cnt[len];\n\t\t\t\tfor(int i=1;i<=len+1;i++)\n\t\t\t\t\taim[len][aim_cnt[len]].s[i]=din[i];\n\t\t\t}\n\t\t\tscanf(\"%s\",din+1);\n\t\t\tlen=strlen(din+1);\n\t\t\tadd(din,len);\n\t\t}\n\t\tif(din[len]=='.')\n\t\t\tif(len>21)\n\t\t\t\tok=0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tdin[len]=0;\n\t\t\t\t++aim_cnt[len-1];\n\t\t\t\tfor(int i=1;i<=len;i++)\n\t\t\t\t\taim[len-1][aim_cnt[len-1]].s[i]=din[i];\n\t\t\t}\t\t\t\n\t\tret[r_len+1]=0;\n\t\tif(!ok)\n\t\t\tprintf(\"-.\\n\");\n\t\telse\n\t\t{\n\t\t\tfor(int ss=1;ss<=26;ss++)\n\t\t\t\tsub[ss]=ans[ss]=ss;\n\t\t\tmemset(sub_flag,0,sizeof(sub_flag));\n\t\t\tans_cnt=0;\n\t\t\tdfs(20,0,0);\n\t\t\tif(ans_cnt!=1)\n\t\t\t\tprintf(\"-.\\n\");\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(int i=1;i<r_len;i++)\n\t\t\t\t{\n\t\t\t\t\t\tif(ret[i]==' ')\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tret[i]=ans[ret[i]-'A'+1]+'A'-1;\n\t\t\t\t}\n\t\t\t\tprintf(\"%s\\n\",ret+2);\n\t\t\t}\n\t\t}\t\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <stdexcept>\n#include <set>\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n#define phb push_back\n#define ppb pop_back\nusing namespace std;\n\nint N;\nstring D[20];\nvector< string > S;\n\nvector< string > t;\nvector< int > mtc, res;\nint tbl[128], clv[128];\n\nbool read();\nvoid solve();\n\nvoid dfs(int);\n\nint main() {\n\twhile (read())\n\t\tsolve();\n\t\n\treturn 0;\n}\n\nbool read() {\n\tstring str, ln;\n\tistringstream iss;\n\t\n\tgetline(cin, ln), iss.clear(), iss.str(ln);\n\tif (iss >> N, N == 0)\n\t\treturn false;\n\t\n\tfor (int i = 0; i < N; ++i)\n\t\tgetline(cin, D[i]);\n\t\n\tgetline(cin, ln), ln.back() = ' ', iss.clear(), iss.str(ln);\n\tS.clear();\n\twhile (iss >> str)\n\t\tS.phb(str);\n\t\n\treturn true;\n}\n\nvoid solve() {\n\tt.clear();\n\tfor (int i = 0; i < sz(S); ++i)\n\t\tif (find(all(t), S[i]) == t.end())\n\t\t\tt.phb(S[i]);\n\t\n\tauto cmpf = [&] (const string &ra, const string &rb) -> bool {\n\t\tset< char > sa, sb;\n\t\t\n\t\tfor (int i = 0; i < sz(ra); ++i)\n\t\t\tsa.insert(ra[i]);\n\t\tfor (int i = 0; i < sz(rb); ++i)\n\t\t\tsb.insert(rb[i]);\n\t\t\n\t\treturn sz(sa) > sz(sb);\n\t};\n\t\n\tsort(&D[0], &D[N], cmpf);\n\tsort(all(t), cmpf);\n\t\n\tfill(&tbl[0], &tbl[128], 0);\n\tfill(&clv[0], &clv[128], -1);\n\tmtc.clear(), res.clear();\n\t\n\ttry {\n\t\tdfs(0);\n\t\tfor (int i = 0; i < sz(S); ++i) {\n\t\t\tint k = int(find(all(t), S[i]) - t.begin());\n\t\t\tcout << D[res[k]] << (i + 1 == sz(S) ? \".\" : \" \");\n\t\t}\n\t}\n\tcatch (...) {\n\t\tcout << \"-.\";\n\t}\n\tcout << \"\\n\";\n}\n\nvoid dfs(int u) {\n\tif (u == sz(t)) {\n\t\tif (!res.empty())\n\t\t\tthrow exception();\n\t\tres = mtc;\n\t}\n\telse {\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tif (sz(D[i]) == sz(t[u])) {\n\t\t\t\tint j = 0, c1, c2;\n\t\t\t\t\n\t\t\t\twhile (j < sz(D[i])) {\n\t\t\t\t\tc1 = int(D[i][j]), c2 = int(t[u][j]);\n\t\t\t\t\tif ((tbl[c1] != 0 && tbl[c1] != c2) || (tbl[c2] != 0 && tbl[c2] != c1))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (tbl[c1] == 0)\n\t\t\t\t\t\ttbl[c1] = c2, tbl[c2] = c1, clv[c1] = clv[c2] = u;\n\t\t\t\t\t++j;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (j == sz(D[i])) {\n\t\t\t\t\tmtc.phb(i);\n\t\t\t\t\tdfs(u + 1);\n\t\t\t\t\tmtc.ppb();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhile ((--j) >= 0) {\n\t\t\t\t\tc1 = int(D[i][j]), c2 = int(t[u][j]);\n\t\t\t\t\tif (clv[c1] == u)\n\t\t\t\t\t\ttbl[c1] = tbl[c2] = 0, clv[c1] = clv[c2] = -1;\n\t\t\t\t}\n\t\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n\nvs dfs(vs &words,vs &c_words,map<char,char> &m,int cur,vs &orig_c_words){\n  vs ret;\n  if(cur==orig_c_words.size()){\n    REP(i,orig_c_words.size()){\n      string s;\n      REP(j,orig_c_words[i].size()){\n        s.push_back(m[orig_c_words[i][j]]);\n      }\n      ret.push_back(s);\n    }\n    return ret;\n  }\n\n  REP(i,words.size()){\n    if(words[i].size()==c_words[cur].size()){\n      map<char,char> nm(m);\n      bool ok=true;\n      REP(j,words[i].size()){\n        map<char,char>::iterator it_i=nm.find(words[i][j]);\n        map<char,char>::iterator it_c=nm.find(c_words[cur][j]);\n        bool ei=it_i!=nm.end();\n        bool ec=it_c!=nm.end();\n        if(ei&&ec){\n          if(it_i->second!=c_words[cur][j]&&it_c->second!=words[i][j]){\n            ok=false;\n            break;\n          }\n        }else if(ei||ec){\n          ok=false;\n          break;\n        }else{\n          nm[words[i][j]]=c_words[cur][j];\n          nm[c_words[cur][j]]=words[i][j];\n        }\n      }\n      if(ok){\n        //cerr<<\"cur:\"<<cur<<endl;\n        vs res=dfs(words,c_words,nm,cur+1,orig_c_words);\n        //cerr<<\"res:\"<<res.size()<<endl;\n        if(res.size()){\n          if(ret.size()){\n            return vs();\n          }else{\n            ret=res;\n          }\n        }\n      }\n    }\n  }\n  return ret;\n\n}\nbool pred(const string &l,const string &r){\n  if(l.size()==r.size()){\n    return l>r;\n  }else{\n    return l.size()>r.size();\n  }\n}\nint main(){\n  int n;\n  while(cin>>n,n){\n    vs words(n);\n    REP(i,n){\n      cin>>words[i];\n    }\n    string sequence;\n    getline(cin,sequence);\n    getline(cin,sequence);\n    vs c_words;\n    int prev=0;\n    REP(i,sequence.size()){\n      switch(sequence[i]){\n        case ' ':\n        case '.':\n          c_words.push_back(sequence.substr(prev,i-prev));\n          prev=i+1;\n          break;\n      }\n    }\n    vs orig_c_words(c_words);\n    sort(ALL(c_words),pred);\n    map<char,char> m;\n    vs res=dfs(words,c_words,m,0,orig_c_words);\n    if(res.size()){\n      REP(i,res.size()){\n        cout<<res[i]<<(i<res.size()-1?\" \":\"\");\n      }\n      cout<<\".\"<<endl;\n    }else{\n      cout<<\"-.\"<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reep(i,a,b) for(int i=a; i<b; i++)\n\nvector<string> func(string input){\n\tvector<string> ret;\n\tstringstream ss;\n\tss << input;\n\tstring s;\n\tvector<pair<int,string> > tmp;\n\twhile(ss>>s){\n\t\tif(s[s.size()-1] == '.') s = s.substr(0,s.size()-1);\n\t\t//ret[s.size()].push_back(s);\t\n\t\tset<char> se;\n\t\trep(i,s.size()){\n\t\t\tse.insert(s[i]);\n\t\t}\n\t\ttmp.push_back(make_pair(-(int)se.size(), s));\n\t}\n\tsort(tmp.begin(), tmp.end());\n\trep(i,tmp.size()){\n\t\tret.push_back(tmp[i].second);\n\t}\n\treturn ret;\n}\n\nvector<vector<int> > ans;\nvector<vector<string> > vv;\n\nbool check(string &a, string &b, vector<int> tik){\n\trep(i,a.size()){\n\t\tint aa = a[i]-'A';\n\t\tint bb = b[i]-'A';\n\t\tif(tik[aa] == -1 && tik[bb] == -1){\n\t\t\ttik[aa] = bb;\n\t\t\ttik[bb] = aa;\n\t\t}\n\t\telse if(tik[aa] == bb && tik[bb] == aa){\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid update(string &a, string &b, vector<int> &tik){\n\t/*cout<<a<<\" \"<<b<<endl;\n\trep(i,26) cout<<tik[i]<<\" \";\n\tcout<<endl;\n\t*/\n\trep(i,a.size()){\n\t\tint aa = a[i]-'A';\n\t\tint bb = b[i]-'A';\n\t\tif(tik[aa] == -1 && tik[bb] == -1){\n\t\t\ttik[aa] = bb;\n\t\t\ttik[bb] = aa;\n\t\t}\n\t}\n\t/*\n\trep(i,26) cout<<tik[i]<<\" \";\n\tcout<<endl;\n\t*/\n}\n\nvoid saiki(int x, vector<string> &w, vector<int> tik){\n\tif(x == w.size()){\n\t\tans.push_back(tik);\n\t\treturn;\n\t}\n\tstring &s = w[x];\n\trep(i,vv[s.size()].size()){\n\t\tif(check(s, vv[s.size()][i], tik)){\n\t\t\tvector<int> tmp = tik;\n\t\t\tupdate(s, vv[s.size()][i], tik);\n\t\t\tsaiki(x+1, w, tik);\n\t\t\ttik = tmp;\t\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n, n){\n\t\t//cout<<n<<endl;\n\t\tvv = vector<vector<string> >(21);\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tvv[s.size()].push_back(s);\n\t\t}\n\t\tstring input;\n\t\tgetline(cin, input);\n\t\tgetline(cin, input);\n\t\t//cout<<input<<endl;\n\t\t//return 0;\n\t\t/*\n\t\tvector<vector<string> > in = func(input);\n\t\trep(i,21){\n\t\t\tsort(in[i].begin(), in[i].end());\n\t\t\tin[i].erase(unique(in[i].begin(), in[i].end()), in[i].end());\n\t\t}\n\t\t*/\n\t\tvector<string> w = func(input);\n\t\t/*\n\t\tfor(int i=20; i>=1; i--){\n\t\t\trep(j,in[i].size()){\n\t\t\t\tw.push_back(in[i][j]);\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tvector<int> tik(26,-1);\n\t\tans.clear();\n\t\tsaiki(0,w,tik);\n\t\tif(ans.size()>1){\n\t\t\tcout<<\"-.\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tvector<int> tik = ans[0];\n\t\t\t/*cout<<\"ttt \"<<endl;\n\t\t\trep(i,26){\n\t\t\t\tcout<<t[i]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t\t*/\n\t\t\trep(i,input.size()){\n\t\t\t\tif(isupper(input[i])){\n\t\t\t\t\t//cout<<input[i]<<\" \"<<tik[input[i]-'A']<<endl;;\n\t\t\t\t\tcout<<char(tik[input[i]-'A']+'A');\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcout<<input[i];\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint N;\nstring sentence;\nstring words[20];\nvector<char> pairs(26);\nset<string> ans;\nset< vector<char> > memo[100];\nstring replace(string s){\n  REP(i, s.size())if(isalpha(s[i])) s[i] = pairs[s[i]-'A'];\n  return s;\n}\nvoid dfs(int k, vector<string>& targets){\n  if(ans.size() >= 2) return;\n  if(memo[k].count(pairs)) return;\n  memo[k].insert(pairs);\n  if(k == targets.size()) {\n    ans.insert(replace(sentence));\n    return;\n  }\n  string target = targets[k];\n  int tmppairs[26];\n  REP(i, 26) tmppairs[i] = pairs[i];\n  REP(i, N)if(words[i].size() == target.size()){\n    string word = words[i];\n    bool ok = true;\n    REP(j, word.size())if(pairs[word[j]-'A'] != -1 && pairs[word[j]-'A'] != target[j]) ok = false;\n    if(!ok) continue;\n    REP(j, word.size()){\n      pairs[word[j]-'A'] = target[j];\n      pairs[target[j]-'A'] = word[j];\n    }\n    REP(i, 26)if(pairs[i] != -1 && pairs[pairs[i]-'A'] != i + 'A') ok = false;\n    if(!ok) continue;\n    REP(j, word.size())if(pairs[word[j] - 'A'] != -1 && (pairs[word[j] - 'A'] != target[j] || pairs[target[j] - 'A'] != word[j])) ok = false;\n    if(!ok) continue;\n    dfs(k + 1, targets);\n    REP(i, 26) pairs[i] = tmppairs[i];\n  }\n}\n\nint main(){\n  while(cin>>N && N){\n    REP(i, 26) pairs[i] = -1;\n    ans.clear();\n    REP(i, 100) memo[i].clear();\n    REP(i, N) cin>>words[i];\n    cin.ignore();\n    getline(cin, sentence);\n    vector<string> targets;\n    stringstream ss(sentence);\n    for(string tmp;;){\n      if(!(ss>>tmp)) break;\n      if(tmp[tmp.size()-1] == '.') tmp = tmp.substr(0, tmp.size() - 1);\n      targets.push_back(tmp);\n    }\n    REP(i, targets.size())FOR(j, i+1, targets.size()) if(targets[i].size() < targets[j].size()) swap(targets[i], targets[j]);\n    dfs(0, targets);\n    if(ans.size() == 1) cout<<*ans.begin()<<endl;\n    else cout<<\"-.\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n\nusing namespace std;\n\n\n\nvector<string> v;\nvector<string> vv;\n\nvector<string> s[21];\n\nchar r[256];\nchar ans[256];\nint n,cnt;\n\n\nvoid dfs(int d){\n\n\n  if(d==vv.size()){\n    cnt++;\n    for(int i='A';i<='Z';i++)ans[i]=r[i];\n    return;\n  }\n\n  int sz=vv[d].size();\n\n  char tmp[256];\n\n  for(int i='A';i<='Z';i++)tmp[i]=r[i];\n  \n  for(int i=0;i<s[sz].size();i++){\n    bool f=1;\n    char rr[256]={};\n    \n    for(int j=0;j<s[sz][i].size();j++){\n\n      if(r[s[sz][i][j]]!=0 && r[vv[d][j]] !=0 ){\n\tif(vv[d][j]!=r[s[sz][i][j]] || r[vv[d][j]]!=s[sz][i][j]) f=0;\n      }\n      else if(r[s[sz][i][j]]==0 && r[vv[d][j]]==0) r[vv[d][j]]=s[sz][i][j], r[s[sz][i][j]]=vv[d][j];\n      else f=0;\n    }\n    \n    if(f&&cnt<=1)dfs(d+1);\n    \n\n    for(int i='A';i<='Z';i++)r[i]=tmp[i];\n    \n  }\n}\n\n\nint main(){\n\n  while(cin>>n,n){\n    string str;\n    v.clear();\n    vv.clear();\n    for(int i=0;i<21;i++)s[i].clear();\n\n    for(int i='A';i<='Z';i++)r[i]=0;\n\n    cnt=0;\n    \n    for(int i=0;i<n;i++){\n      cin>>str;\n      s[str.size()].push_back(str);\n    }\n    \n    bool f=1;\n    \n    while(cin>>str){\n      \n      if(str[str.size()-1]=='.'){\n\tstr=str.substr(0,str.size()-1);\n\tf=0;\n      }\n      v.push_back(str);\n      if(!f) break;\n    }\n\n    vv=v;\n    for(int i=1;i<vv.size();i++)\n      for(int j=i;j>0;j--){\n\tif(vv[j-1].size()<vv[j].size())\n\t  swap(vv[j],vv[j-1]);\n      }\n      \n    dfs(0);\n    \n    if(cnt==1){\n\n      for(int i=0;i<v.size();i++){\n\tfor(int j=0;j<v[i].size();j++){\n\t  if(ans[v[i][j]]==0)cout<<v[i][j];\n\t  else cout<<(char)ans[v[i][j]];\n\t}\n\tif(i!=v.size()-1)cout<<\" \";\n      }\n    }\n\n    else cout<<\"-\";\n\n    cout<<\".\"<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n\nint tr[26], ans[26];\nvector<string> split(string s) \n{\n\tvector<string> res;\n\tstringstream ss(s);\n\n\tstring a;\n\twhile(ss >> a) { res.push_back(a); }\n\n\treturn res;\n}\n\nbool match(string w, string msg)\n{\n\tfor(int i=0; i<msg.size(); i++) {\n\t\tif(tr[msg[i] - 'A'] != -1 && tr[msg[i] - 'A'] != w[i]) return false;\n\t\tif(tr[w[i] - 'A'] != -1 && tr[w[i] - 'A'] != msg[i]) return false;\n\t}\n\n\treturn true;\n}\n\nint dfs(int p, vector<string>& words, vector<string>& msg) \n{\n\n\tif(p == msg.size()) {\n\t\tmemcpy(ans, tr, sizeof(ans));\n\t\treturn 1;\n\t}\n\t\n\tint res = 0;\t\n\tfor(int i=0; i<words.size(); i++) {\n\t\tif(msg[p].size() != words[i].size()) continue;\n\t\tif(!match(words[i], msg[p])) continue;\n\t\t\n\t\tbool valid = true;\n\t\tint t[26];\n\t\tmemcpy(t, tr, sizeof(t));\n\t\tfor(int j=0; j<msg[p].size(); j++) {\n\t\t\tif(!match(words[i], msg[p])) { valid = false; break; } \n\t\t\ttr[msg[p][j] - 'A'] = words[i][j];\n\t\t\ttr[words[i][j] - 'A'] = msg[p][j];\n\t\t}\n\t\tif(valid) {\n\t\t\tres += dfs(p+1, words, msg);\n\t\t}\n\t\tmemcpy(tr, t, sizeof(tr));\n\t}\n\n\treturn res;\n}\n\nbool comp(const string& a, const string& b)\n{\n\tif(a.size() != b.size()) return a.size() > b.size();\n\treturn a > b;\n}\n\n\nint main()\n{\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvector<string> words(N);\n\t\tfor(int i=0; i<N; i++) cin >> words[i];\n\n\t\tstring str;\n\t\tgetline(cin, str);\n\t\tgetline(cin, str);\n\t\n\t\tstr.erase(str.end() - 1);\n\n\t\tsort(words.begin(), words.end(), comp);\n\n\t\tvector<string> msg = split(str);\n\t\tsort(msg.begin(), msg.end());\n\t\tmsg.erase(unique(msg.begin(), msg.end()), msg.end());\n\t\tsort(msg.begin(), msg.end(), comp);\n\n\t\tfor(int i=0; i<26; i++) tr[i] = -1;\n\n\t\tint res = dfs(0, words, msg);\n\t\tif(res != 1) cout << \"-.\" << endl;\n\t\telse {\n\t\t\tfor(int i=0; i<str.size(); i++) {\n\t\t\t\tif(isalpha(str[i])) cout << (char)ans[str[i]-'A'];\n\t\t\t\telse cout << str[i];\n\t\t\t}\n\n\t\t\tcout << \".\" << endl;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n\nint n;\nvector<string> word;\nvector<string> seq;\nmap<char, int> mp;\nmap<char, char> conv;\nvector< pair<int, char> > ord;\nstring ans;\nint num;\n\nbool check() {\n  rep(i, seq.size()) {\n    bool flag = false;\n    rep(j, word.size()) {\n      if(word[j].size() != seq[i].size()) continue;\n      bool flag2 = true;\n      rep(k, seq[i].size()) {\n\tif(conv[seq[i][k]] == '$') continue;\n\tif(conv[seq[i][k]] != word[j][k]) flag2 = false;\n      }\n      if(flag2) flag = true;\n    }\n    if(!flag) return false;\n  }\n  return true;\n}\n\nvoid dfs(int idx) {\n  //for(auto p : conv) {\n    //cout << p.first << \" \" << p.second << endl;\n  //}\n  //cout << check() << endl;  \n  if(!check()) return;\n  if(idx == ord.size()) {\n    string tmp = \"\";\n    rep(i, seq.size()) {\n      if(i) tmp += \" \";\n      rep(j, seq[i].size()) {\n\ttmp += conv[seq[i][j]];\n      }\n    }\n    ans = tmp;\n    num++;\n    return;\n  }\n  if(conv[ord[idx].second] != '$') {\n    dfs(idx+1);\n    return;\n  }\n  ///cout << ord[idx].second << endl;\n  rep(i, 26) {\n    if(conv[(char)('A'+i)] != '$') continue;\n    conv[ord[idx].second] = (char)('A'+i);\n    conv[(char)('A'+i)] = ord[idx].second;\n    dfs(idx+1);\n    conv[ord[idx].second] = '$';\n    conv[(char)('A'+i)] = '$';\n  }\n}\n\nsigned main(){\n  while(cin >> n, n) {\n    word.clear();\n    word.resize(n);\n    rep(i, n) cin >> word[i];\n    seq.clear();\n    while(1) {\n      string s;\n      cin >> s;\n      seq.push_back(s);\n      if(s.back() == '.') {\n\tseq[seq.size()-1].pop_back();\n\tbreak;\n      }\n    }\n    ord.clear();\n    mp.clear();\n    conv.clear();\n    rep(i, seq.size()) rep(j, seq[i].size()) {\n      if(seq[i][j] == '.') continue;\n      mp[seq[i][j]]++;\n    }\n    for(auto p : mp) {\n      ord.push_back(make_pair(p.second, p.first));\n    }\n    sort(ord.begin(), ord.end(), greater<pair<int, int> >());\n    ans = \"-\";    \n    rep(i, 26) conv[(char)('A'+i)] = '$';\n    conv['.'] = '.';\n    num = 0;\n    dfs(0);\n    //cout << num << endl;\n    if(num != 1) ans = \"-\";\n    cout << ans + \".\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nstring t[100];\nbool used[100];\nvector<string> v;\nmap< char , char > mp;\ntypedef pair< char , char > P;\n\nbool check( vector<int> a, string b , vector<int> c, string d ){\n  int size=a.size();\n  map< char , set<int> > T;\n\n  for(int i=0;i<size;i++){\n    if(a[i]==-1)continue;\n    T[ b[i] ].insert( d[i] );\n    T[ d[i] ].insert( b[i] );\n    if( T[ b[i] ].size() > 1 )return false;\n    if( T[ d[i] ].size() > 1 )return false;\n  }\n  return true;\n}\n\nstring Replace(string s,bool flag=false){\n  for(int i=0;i<(int)s.size();i++){\n    if(mp.count(s[i]))s[i]=mp[s[i]];\n    else{\n      if(flag)s[i]='?';\n    }\n  }\n  return s;\n}\n\nvector<int> change(string s){\n  vector<int> res(s.size());\n  map<char,int> flg;\n  for(int i=0;i<(int)s.size();i++){\n    if(mp.count(s[i])){\n      res[i]=-1;\n      continue;\n    }\n    if( flg.count(s[i]) ){\n      res[i]=flg[ s[i] ];\n    }else{\n      res[i]=flg.size();\n      flg[ s[i] ]=res[i];\n    }\n  }\n  return res;\n}\n\nvoid Add(string s,string t){\n  for(int i=0;i<(int)s.size();i++){\n    mp[ s[i] ] = t[i];\n    mp[ t[i] ] = s[i];\n  }\n}\n\nbool solve(){\n  set< int > pa;\n  bool update=true;\n  while(update){\n    update=false;\n    vector<int> cnt( v.size(), 0 );\n    \n    for(int i=0;i<n;i++){\n      if(used[i])continue;\n      string str=Replace(t[i],true);\n      vector<int> hashv=change(t[i]);\n      vector<int> target;\n      set< string > st;\n      for(int j=0;j<(int)v.size();j++){\n        string tmp=Replace(Replace(v[j],true));\n        vector<int> hashw=change(v[j]);\n        if(str==tmp && hashv == hashw && check(hashv,t[i],hashw,v[j])){\n          //          cout<<t[i]<<' '<<v[j]<<endl;\n          cnt[j]++;\n        }\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      if(used[i])continue;\n      \n      string str=Replace(t[i],true);\n      vector<int> hashv=change(t[i]);\n      \n      vector<int> target;\n      set< string > st;\n      for(int j=0;j<(int)v.size();j++){\n        string tmp=Replace(Replace(v[j],true));\n        vector<int> hashw=change(v[j]);\n        \n        if(str==tmp && hashv == hashw && cnt[j]==1 && check(hashv,t[i],hashw,v[j])){\n          st.insert(v[j]);\n          target.push_back(j);\n        }\n      }\n\n      if(st.size()==1){\n        update=true;\n        used[i]=true;\n        for(int id:target){\n          Add(t[i],v[id]);\n          pa.insert(id);\n        }\n      }\n      \n    }\n\n  }\n\n  if(pa.size()!=v.size())return false;\n  return true;\n}\n\nvoid init(){\n  v.clear();\n  mp.clear();\n  memset(used,false,sizeof(used));\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++)cin>>t[i];\n    string tmp,str;\n    getline(cin,tmp);\n    getline(cin,tmp);\n    stringstream ss(tmp);\n    while(ss>>str){\n      if( str.back() == '.' )str.pop_back();\n      v.push_back(str);\n    }\n    if( solve() ){\n      for(int i=0;i<(int)v.size();i++){\n        if(i)cout<<' ';\n        cout<<Replace(v[i]);\n      }\n      cout<<'.'<<endl;\n    }else{\n      cout<<\"-.\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nchar a[256];\nint ans;\n\nchar m[256];\nint used[256]={0};\n\nvoid search(int n,int now,vector<string> &in,const vector<string> &words){\n  if (ans >= 2)return;\n  if (n == now){\n    ans++;\n    rep(i,256)a[i]=m[i];\n    return;\n  }\n  rep(i,(int)words.size()){\n    string cur = in[now];\n    string tar = words[i];\n    if (tar.size() != cur.size())continue;\n    //check\n    bool isok=true;\n    rep(j,(int)cur.size()){\n      if (used[(int)cur[j]] == -1 && used[(int)tar[j]] == -1){\n\tused[(int)tar[j]]=now;\n\tused[(int)cur[j]]=now;\n\tm[(int)cur[j]]=tar[j];\n\tm[(int)tar[j]]=cur[j];\n      }else if (used[(int)cur[j]] == -1 || used[(int)tar[j]] == -1)isok=false;\n      else if (m[(int)cur[j]] == tar[j] && m[(int)tar[j]] == cur[j]);\n      else isok=false;\n    }\n    //search\n    if (isok){\n      search(n,now+1,in,words);\n    }\n    //backtrack\n    rep(j,(int)cur.size()){\n      if (used[(int)cur[j]] == now && used[tar[j]] == now){\n\tused[(int)cur[j]]=-1,used[(int)tar[j]]=-1;\n      }\n    }\n  }\n}\n\nbool cmp(const string & a,const string &b){\n  if (a.size() != b.size())return a.size( ) > b.size();\n  return a < b;\n}\n\nint main(){\n  int n;\n  while(cin>>n && n){\n    rep(i,256)used[i]=-1;\n    ans=0;\n\n    vector<string> words(n),inp;\n    rep(i,n)cin>>words[i];\n    sort(words.begin(),words.end());\n    words.erase(unique(words.begin(),words.end()),words.end());\n    sort(words.begin(),words.end(),cmp);\n    string in;getline(cin,in);\n    getline(cin,in);\n    string tmp = in;\n    rep(i,tmp.size())if (tmp[i] == '.')tmp[i]=' ';\n    stringstream sin(tmp);\n    while(sin>>tmp)inp.push_back(tmp);\n    sort(inp.begin(),inp.end());\n    inp.erase(unique(inp.begin(),inp.end()),inp.end());\n    sort(inp.begin(),inp.end(),cmp);\n    \n    search(inp.size(),0,inp,words);\n    assert(ans > 0);\n    if (ans != 1)cout <<\"-\" << endl;//\" \" << ans << endl;\n    else {\n      rep(i,in.size()){\n\tif (isupper(in[i]))cout<<a[in[i]];\n\telse cout << in[i];\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n,found,buf_length;\nvector<string> word[30],buf;\nstring sequence;\nchar transfer[26];\nvector<ll> bitmask;\nvector<int> bc;\nset<string> exist;\nchar table[26];\nint depth[26];\n\nbool cmp(const string& a,const string& b){ return a.size() > b.size(); }\n\nvoid dfs(int cur,long long bit,int dph){\n\n  if( found >= 2 ) return;\n\n  if( cur >= buf_length ){\n    found++;\n    rep(i,26) transfer[i] = table[i];\n    return;\n  }\n\n  int len = buf[cur].size();\n\n  if( __builtin_popcountll( bit & bitmask[cur] ) == bc[cur] ) {\n    string tmp = buf[cur];\n    rep(i,len) tmp[i] = table[tmp[i]-'A'];\n    if( exist.find(tmp) != exist.end() ) dfs(cur+1,bit,dph+1);\n    return;\n  }\n\n  rep(i,word[len].size()){\n    bool error = false;\n    long long new_bit = bit;\n    int ep = len;\n\n    rep(j,len){\n      if( table[buf[cur][j]-'A'] == '?' && table[word[len][i][j]-'A'] == '?' ) {\n        long long SHIFT = word[len][i][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        SHIFT = buf[cur][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        table[buf[cur][j]-'A']     = word[len][i][j];\n        table[word[len][i][j]-'A'] = buf[cur][j];\n        int idx = buf[cur][j] - 'A';\n        depth[idx] = dph;\n        idx = word[len][i][j] - 'A';\n        depth[idx] = dph;\n      } else if( !( table[buf[cur][j]-'A'] == word[len][i][j] && table[word[len][i][j]-'A'] == buf[cur][j] ) ) {\n        ep = j+1;\n        error = true;\n        break;\n      }\n    }\n\n    if( !error )dfs(cur+1,new_bit,dph+1);\n    rep(j,ep){\n      int idx = buf[cur][j] - 'A';\n      int idx2 = word[len][i][j] - 'A';\n      if( depth[idx] == dph ){\n        table[idx] = table[idx2] = '?';\n      }\n    }\n    if( found >= 2 ) return;\n  }\n}\n\nint main(){\n  while( cin >> n, n ){\n    string tmp;\n    found = 0;\n    buf.clear(), tmp.clear();\n    rep(i,26)transfer[i] = table[i] = '?';\n    rep(i,30) word[i].clear();\n    rep(i,n){\n      cin >> tmp;\n      word[(int)tmp.size()].push_back(tmp);\n      exist.insert(tmp);\n    }\n    cin.ignore();\n    getline(cin,sequence);\n    tmp = sequence.substr(0,(int)sequence.size()-1);\n    stringstream ss(tmp);\n    while( !( ss >> tmp ).fail() ) buf.push_back(tmp);\n\n    sort(buf.begin(),buf.end(),cmp);\n    buf.erase(unique(buf.begin(),buf.end()),buf.end());\n    buf_length = (int) buf.size();\n    bitmask.clear(), bc.clear();\n    bitmask.resize(buf_length,0), bc.resize(buf_length);\n    rep(i,buf_length){\n      rep(j,buf[i].size()){\n        long long SHIFT = buf[i][j] - 'A';\n        bitmask[i] |= (1LL<<SHIFT);\n      }\n      bc[i] = __builtin_popcountll(bitmask[i]);\n    }\n\n    dfs(0,0LL,0);\n\n    if( found == 1 ) {\n      rep(i,sequence.size()) cout << (isupper(sequence[i])?transfer[sequence[i]-'A']:sequence[i]);\n      puts(\"\");\n    } else puts(\"-.\");\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nchar read[100];\nint n,cnt,ans,ti;\nmap<char ,char >mp,answer;\nstruct node\n{\n    char st[100];\n    int ls;\n}s[100],str[100];\nbool judge(int i,int at)//把i放在at串&#36825;个地方\n{\n    for (int j=0;j<s[i].ls;j++)\n        if (mp[s[i].st[j]]!=str[at].st[j])\n        {\n            if (mp[s[i].st[j]]=='0'&&mp[str[at].st[j]]=='0')\n            {\n                mp[s[i].st[j]]=str[at].st[j];\n                mp[str[at].st[j]]=s[i].st[j];\n            }\n            else return false;\n        }\n    return true;\n}\nvoid dfs(int at)\n{\n    if (ans>1)return ;\n    if (at==cnt)\n    {\n        ans++;\n        for (char i='A';i<='Z';i++)answer[i]=mp[i];\n        return ;\n    }\n    map<char ,char >mpresume;\n    for (int i=0;i<n;i++)\n        if (s[i].ls==str[at].ls)\n        {\n            for (char j='A';j<='Z';j++)mpresume[j]=mp[j];\n            if (judge(i,at))\n            {\n                dfs(at+1);\n                if (ans>1)return ;\n            }\n            for (char j='A';j<='Z';j++)mp[j]=mpresume[j];\n        }\n}\nint cmp(const void *a,const void *b)\n{\n    node *aa=(node *)a;\n    node *bb=(node *)b;\n    if (aa->ls!=bb->ls)\n        return bb->ls-aa->ls;\n    return strcmp(bb->st,aa->st);\n}\nint main()\n{\n    #ifndef ONLINE_JUDGE\n        freopen(\"1.in\",\"r\",stdin);\n    #endif\n    while (scanf(\"%d\",&n)!=EOF&&n)\n    {\n        for (char i='A';i<='Z';i++)mp[i]='0';\n        for (int i=0;i<n;i++)\n            scanf(\"%s\",s[i].st),s[i].ls=strlen(s[i].st);\n        getchar();\n        gets(read);\n        int len=strlen(read);\n        ans=cnt=0;\n        for (int i=0;i<len;)\n        {\n            while (i<len&&(read[i]<'A'||read[i]>'Z'))i++;\n            if (i==len)break;\n            str[cnt].ls=0;\n            while (i<len&&read[i]>='A'&&read[i]<='Z')str[cnt].st[str[cnt].ls++]=read[i++];\n            str[cnt].st[str[cnt].ls]='\\0';\n            cnt++;\n        }\n        qsort(s,n,sizeof s[0],cmp);\n        qsort(str,cnt,sizeof str[0],cmp);\n        dfs(0);\n        if (ans==1)\n        {\n            for (int i=0;i<len-1;i++)\n                if (read[i]==' ')printf(\" \");\n                else printf(\"%c\",answer[read[i]]);\n        }\n        else printf(\"-\");\n        printf(\".\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nvector<string> str[21];\nvector<string> seq;\nchar mp[26];\nint n;\nchar ans[26];\nint ok;\n\nvoid dfs(int num) {\n  //cout << num << endl;\n  if (num == seq.size()) {\n    ok++;\n    REP(i, 26)\n      ans[i] = mp[i];\n    return;\n  }\n  bool change[26];\n  string s = seq[num];\n  if (ok > 1) return;\n  FOR(it, str[s.size()]) {\n    string t = *it;\n    bool dame = 0;\n    memset(change,0,sizeof(change));\n    REP(i, s.size()) {\n      if (mp[s[i]-'A'] == 0) {\n        if (mp[t[i]]) {\n          dame = 1;\n          break;\n        }\n        mp[s[i]-'A'] = t[i];\n        mp[t[i]-'A'] = s[i];\n        change[s[i]-'A'] = 1;\n        change[t[i]-'A'] = 1;\n      } else if (mp[s[i]-'A'] != t[i]) {\n        dame = 1;\n        break;\n      }\n    }\n    // REP(i, 26) if (mp[i]) printf(\"(%c,%c)\",i+'A', mp[i]);\n    // cout << endl;\n    if (!dame)\n      dfs(num+1);\n    REP(i, 26)\n      if (change[i])\n        mp[i] = 0;\n  }\n}\n\n\nint main() {\n  while(cin>>n,n) {\n    REP(i,21) str[i].clear();\n    REP(i, n) {\n      string tmp;\n      cin >> tmp;\n      str[tmp.size()].push_back(tmp);\n    }\n    seq.clear();\n    string line;\n    cin.ignore();\n    getline(cin,line);\n    stringstream sin(line);\n    string tmp;\n    while(sin>>tmp, tmp[tmp.size()-1] != '.') seq.push_back(tmp);\n    seq.push_back(tmp.substr(0, tmp.size()-1));\n\n    vector<pair<int, string> > v;\n    vector<int> num(21);\n    FOR(it, seq)\n      num[it->size()]++;\n    FOR(it, seq) v.push_back(make_pair(num[it->size()], *it));\n    sort(ALL(v));\n    seq.clear();\n    FOR(it, v) {\n      seq.push_back(it->second);\n//      cout << it->second << endl;\n    }\n    \n    memset(mp,0,sizeof(mp));\n    //cout << line << endl;\n    ok = 0;\n    dfs(0);\n    if (ok == 1) {\n      REP(i, line.size()) {\n        if (line[i] == ' ' || line[i] == '.') cout << line[i];\n        else cout << ans[line[i]-'A'];\n      }\n      cout << endl;\n    } else {\n      cout << \"-.\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <cstring>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint N;\nstring sentence;\nstring words[20];\nchar pairs[256];\nvector<string> ans;\nstring replace(string s){\n  REP(i, s.size())if(isalpha(s[i])) s[i] = pairs[s[i]];\n  return s;\n}\nvoid dfs(int k, vector<string>& targets){\n  if(k == targets.size()) {\n    ans.push_back(replace(sentence));\n    return;\n  }\n  string target = targets[k];\n  int tmppairs[256];\n  REP(i, 256) tmppairs[i] = pairs[i];\n  REP(i, N)if(words[i].size() == target.size()){\n    string word = words[i];\n    bool ok = true;\n    REP(j, word.size())if(pairs[word[j]] != -1 && pairs[word[j]] != target[j]) ok = false;\n    if(!ok) continue;\n    REP(j, word.size()){\n      pairs[word[j]] = target[j];\n      pairs[target[j]] = word[j];\n    }\n    REP(j, word.size())if(pairs[word[j]] != -1 && pairs[word[j]] != target[j]) ok = false;\n    if(!ok) continue;\n    dfs(k + 1, targets);\n    REP(i, 256) pairs[i] = tmppairs[i];\n  }\n}\n\nint main(){\n  while(cin>>N && N){\n    memset(pairs, -1, sizeof(pairs));\n    ans.clear();\n    REP(i, N) cin>>words[i];\n    cin.ignore();\n    getline(cin, sentence);\n    vector<string> targets;\n    stringstream ss(sentence);\n    for(string tmp;;){\n      if(!(ss>>tmp)) break;\n      if(tmp[tmp.size()-1] == '.') tmp = tmp.substr(0, tmp.size() - 1);\n      targets.push_back(tmp);\n    }\n    REP(i, targets.size())FOR(j, i+1, targets.size()) if(targets[i].size() < targets[j].size()) swap(targets[i], targets[j]);\n    dfs(0, targets);\n    if(ans.size() == 1) cout<<ans[0]<<endl;\n    else cout<<\"-.\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int N = 20;\n\nint n, ans;\nstring tmp, ans_rev;\nvector<string> words[N+1], cands[N+1];\n//vector<bool> vis[N+1];\n\nvoid init() {\n  for(int i = 0; i<=N; ++i)\n    words[i].clear(), cands[i].clear();//, vis[i].clear();\n  ans = 0;\n}\nbool valid(const string &tar, const string &s, string &rev) {\n  assert(s.size() == tar.size());\n  for(size_t i = 0; i<s.size(); ++i) {\n    if(rev[s[i]] != -1 && rev[s[i]] != tar[i])\n      return false;\n    if(rev[tar[i]] != -1 && rev[tar[i]] != s[i])\n      return false;\n    if(rev[s[i]] == -1 && rev[tar[i]] != -1)\n      return false;\n    if(rev[tar[i]] == -1 && rev[s[i]] != -1)\n      return false;\n  }\n  return true;\n}\nvoid dfs(int l, size_t x, string rev) {\n  if(ans > 1)\n    return;\n  while(l && x >= words[l].size()) {\n    x = 0;\n    --l;\n  }\n  if(l == 0) {\n    ans_rev = rev;\n    ++ans;\n    return;\n  }\n  const string &tar = words[l][x];\n  for(size_t j = 0; j<cands[l].size(); ++j) {\n    //if(vis[l][j])\n    //  continue;\n    const string &s = cands[l][j];\n    if(valid(tar, s, rev)) {\n      string nrev = rev;\n      for(size_t i = 0; i<s.size(); ++i) {\n        nrev[s[i]] = tar[i];\n        nrev[tar[i]] = s[i];\n      }\n      //vis[l][j] = true;\n      dfs(l, x+1, nrev);\n      //vis[l][j] = false;\n    }\n  }\n}\nvoid cleanup(vector<string> &v) {\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()));\n}\nvoid solve() {\n  init();\n  for(int i = 0; i<n; ++i) {\n    cin >> tmp;\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    cands[tmp.size()].push_back(tmp);\n  }\n  //for(int i = 0; i<=N; ++i)\n  //  vis[i].resize(cands[i].size());\n  vector<string> sent;\n  bool cont = true;\n  while(cont) {\n    cin >> tmp;\n    if(tmp.back() == '.') {\n      tmp.pop_back();\n      cont = false;\n    }\n    sent.push_back(tmp);\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    words[tmp.size()].push_back(tmp);\n  }\n  for(int i = 0; i<=N; ++i)\n    cleanup(words[i]);\n  dfs(N, 0, string(26, -1));\n  assert(ans > 0);\n  if(ans == 1) {\n    for(auto c : ans_rev)\n      if(c != -1) {\n        assert(c == ans_rev[ans_rev[c]]);\n      }\n    for(size_t i = 0; i<sent.size(); ++i) {\n      for(auto c : sent[i]) \n        putchar(ans_rev[c - 'A'] == -1 ? c : ans_rev[c - 'A'] + 'A');\n      putchar(i+1 == sent.size() ? '.' : ' ');\n    }\n    puts(\"\");\n  } else\n    puts(\"-.\");\n}\nint main() {\n  while(scanf(\"%d\", &n) == 1 && n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <cctype>\nusing namespace std;\n\nint tr[256], ans[256];\nvector<string> split(string s) \n{\n\tvector<string> res;\n\tstringstream ss(s);\n\n\tstring a;\n\twhile(ss >> a) { res.push_back(a); }\n\n\treturn res;\n}\n\nbool match(string w, string msg)\n{\n\tfor(int i=0; i<msg.size(); i++) {\n\t\tif(tr[msg[i]] != -1 && tr[msg[i]] != w[i]) return false;\n\t\tif(tr[w[i]] != -1 && tr[w[i]] != msg[i]) return false;\n\t}\n\n\treturn true;\n}\n\nint dfs(int p, vector<string>& words, vector<string>& msg) \n{\n\n\tif(p == msg.size()) {\n\t\tmemcpy(ans, tr, sizeof(ans));\n\t\treturn 1;\n\t}\n\t\n\tint res = 0;\t\n\tfor(int i=0; i<words.size(); i++) {\n\t\tif(msg[p].size() != words[i].size()) continue;\n\t\tif(!match(words[i], msg[p])) continue;\n\t\t\n\t\tbool valid = true;\n\t\tint t[256];\n\t\tmemcpy(t, tr, sizeof(t));\n\t\tfor(int j=0; j<msg[p].size(); j++) {\n\t\t\tif(!match(words[i], msg[p])) { valid = false; break; } \n\t\t\ttr[msg[p][j]] = words[i][j];\n\t\t\ttr[words[i][j]] = msg[p][j];\n\t\t}\n\t\tif(valid) {\n\t\t\tres += dfs(p+1, words, msg);\n\t\t}\n\t\tmemcpy(tr, t, sizeof(tr));\n\t}\n\n\treturn res;\n}\n\nbool comp(const string& a, const string& b)\n{\n\tif(a.size() != b.size()) return a.size() > b.size();\n\treturn a > b;\n}\n\n\nint main()\n{\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvector<string> words(N);\n\t\tfor(int i=0; i<N; i++) cin >> words[i];\n\n\t\tstring str;\n\t\tgetline(cin, str);\n\t\tgetline(cin, str);\n\t\n\t\tstr.erase(str.end() - 1);\n\n\t\tsort(words.begin(), words.end(), comp);\n\n\t\tvector<string> msg = split(str);\n\t\tsort(msg.begin(), msg.end());\n\t\tmsg.erase(unique(msg.begin(), msg.end()), msg.end());\n\t\tsort(msg.begin(), msg.end(), comp);\n\n\t\tfor(int i=0; i<256; i++) tr[i] = -1;\n\n\t\tint res = dfs(0, words, msg);\n\t\tif(res != 1) cout << \"-.\" << endl;\n\t\telse {\n\t\t\tfor(int i=0; i<str.size(); i++) {\n\t\t\t\tif(isalpha(str[i])) cout << (char)ans[str[i]];\n\t\t\t\telse cout << str[i];\n\t\t\t}\n\n\t\t\tcout << \".\" << endl;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint N;\nstring sentence;\nstring words[20];\nvector<char> pairs(26);\nvector<string> ans;\nset< vector<char> > memo[100];\nstring replace(string s){\n  REP(i, s.size())if(isalpha(s[i])) s[i] = pairs[s[i]-'A'];\n  return s;\n}\nvoid dfs(int k, vector<string>& targets){\n  if(ans.size() >= 2) return;\n  if(memo[k].count(pairs)) return;\n  memo[k].insert(pairs);\n  if(k == targets.size()) {\n    ans.push_back(replace(sentence));\n    return;\n  }\n  string target = targets[k];\n  int tmppairs[26];\n  REP(i, 26) tmppairs[i] = pairs[i];\n  REP(i, N)if(words[i].size() == target.size()){\n    string word = words[i];\n    bool ok = true;\n    REP(j, word.size())if(pairs[word[j]-'A'] != -1 && pairs[word[j]-'A'] != target[j]) ok = false;\n    if(!ok) continue;\n    REP(j, word.size()){\n      pairs[word[j]-'A'] = target[j];\n      pairs[target[j]-'A'] = word[j];\n    }\n    REP(i, 26)if(pairs[i] != -1 && pairs[pairs[i]-'A'] != i + 'A') ok = false;\n    if(!ok) continue;\n    REP(j, word.size())if(pairs[word[j] - 'A'] != -1 && (pairs[word[j] - 'A'] != target[j] || pairs[target[j] - 'A'] != word[j])) ok = false;\n    if(!ok) continue;\n    dfs(k + 1, targets);\n    REP(i, 26) pairs[i] = tmppairs[i];\n  }\n}\n\nint main(){\n  while(cin>>N && N){\n    REP(i, 26) pairs[i] = -1;\n    ans.clear();\n    REP(i, 100) memo[i].clear();\n    REP(i, N) cin>>words[i];\n    cin.ignore();\n    getline(cin, sentence);\n    vector<string> targets;\n    stringstream ss(sentence);\n    for(string tmp;;){\n      if(!(ss>>tmp)) break;\n      if(tmp[tmp.size()-1] == '.') tmp = tmp.substr(0, tmp.size() - 1);\n      targets.push_back(tmp);\n    }\n    REP(i, targets.size())FOR(j, i+1, targets.size()) if(targets[i].size() < targets[j].size()) swap(targets[i], targets[j]);\n    dfs(0, targets);\n    if(ans.size() == 1) cout<<ans[0]<<endl;\n    else cout<<\"-.\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int N = 20;\n\nint n, ans;\nstring tmp, ans_rev;\nvector<string> words[N+1], cands[N+1];\n//vector<bool> vis[N+1];\n\nbool valid(string &tar, string &s, string &rev) {\n  for(size_t i = 0; i<s.size(); ++i) {\n    if(rev[s[i]] != -1 && rev[s[i]] != tar[i])\n      return false;\n    if(rev[tar[i]] != -1 && rev[tar[i]] != s[i])\n      return false;\n  }\n  return true;\n}\nvoid dfs(int l, size_t x, string &rev) {\n  if(ans > 1)\n    return;\n  while(l && x >= words[l].size()) {\n    x = 0;\n    --l;\n  }\n  if(l == 0) {\n    ans_rev = rev;\n    ++ans;\n    return;\n  }\n  string &tar = words[l][x];\n  for(size_t j = 0; j<cands[l].size(); ++j) {\n    //if(vis[l][j])\n    //  continue;\n    string &s = cands[l][j];\n    if(valid(tar, s, rev)) {\n      string nrev = rev;\n      size_t i = 0;\n      for(; i<s.size(); ++i)\n        if(nrev[s[i]] == -1) {\n          if(nrev[tar[i]] != -1)\n            break;\n          nrev[s[i]] = tar[i];\n          nrev[tar[i]] = s[i];\n        }\n      if(i != s.size())\n        continue;\n      //vis[l][j] = true;\n      dfs(l, x+1, nrev);\n      //vis[l][j] = false;\n    }\n  }\n}\nvoid cleanup(vector<string> &v) {\n  sort(v.begin(), v.end());\n  v.resize(unique(v.begin(), v.end()) - v.begin());\n}\nvoid init() {\n  for(int i = 0; i<=N; ++i)\n    words[i].clear(), cands[i].clear();//, vis[i].clear();\n  ans = 0;\n}\nvoid solve() {\n  init();\n  for(int i = 0; i<n; ++i) {\n    cin >> tmp;\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    cands[tmp.size()].push_back(tmp);\n  }\n  //for(int i = 0; i<=N; ++i)\n  //  vis[i].resize(cands[i].size());\n  vector<string> sent;\n  bool cont = true;\n  while(cont) {\n    cin >> tmp;\n    if(tmp.back() == '.') {\n      tmp.pop_back();\n      cont = false;\n    }\n    sent.push_back(tmp);\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    words[tmp.size()].push_back(tmp);\n  }\n  for(int i = 0; i<=N; ++i)\n    cleanup(words[i]);\n  string rev(26, -1);\n  dfs(N, 0, rev);\n  if(ans == 1) {\n    for(auto c : ans_rev)\n      if(ans_rev[c] != -1)\n        assert(ans_rev[c] = ans_rev[ans_rev[c]]);\n    for(size_t i = 0; i<sent.size(); ++i) {\n      for(auto c : sent[i]) \n        putchar(ans_rev[c - 'A'] == -1 ? c : ans_rev[c - 'A'] + 'A');\n      putchar(i+1 == sent.size() ? '.' : ' ');\n    }\n    puts(\"\");\n  } else\n    puts(\"-.\");\n}\nint main() {\n  while(scanf(\"%d\", &n) == 1 && n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n,found,buf_length;\nvector<string> word[30],buf;\nstring sequence;\nchar transfer[26];\nvector<ll> bitmask;\nvector<int> bc;\n\nbool cmp(const string& a,const string& b){ return a.size() > b.size(); }\n\nvoid dfs(int cur,vector<char> table,long long bit){\n\n  if( found >= 2 ) return;\n\n  if( cur >= buf_length ){\n    found++;\n    rep(i,26) transfer[i] = table[i];\n    return;\n  }\n\n  if( __builtin_popcountll( bit & bitmask[cur] ) == bc[cur] ) {\n    dfs(cur+1,table,bit);\n    return;\n  }\n\n  int len = buf[cur].size();\n  rep(i,word[len].size()){\n    vector<char> ntable = table;\n    bool error = false;\n    long long new_bit = bit;\n    rep(j,len){\n      if( ntable[buf[cur][j]-'A'] == '?' && ntable[word[len][i][j]-'A'] == '?' ) {\n        long long SHIFT = word[len][i][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        SHIFT = buf[cur][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        ntable[buf[cur][j]-'A']     = word[len][i][j];\n        ntable[word[len][i][j]-'A'] = buf[cur][j];\n      } else if( !( ntable[buf[cur][j]-'A'] == word[len][i][j] && ntable[word[len][i][j]-'A'] == buf[cur][j] ) ) {\n        error = true;\n        break;\n      }\n    }\n    if( error ) continue;\n    dfs(cur+1,ntable,new_bit);\n    if( found >= 2 ) return;\n  }\n}\n\nint main(){\n  while( cin >> n, n ){\n    string tmp;\n    found = 0;\n    buf.clear();\n    rep(i,26)transfer[i] = '?';\n    rep(i,30) word[i].clear();\n    rep(i,n){\n      cin >> tmp;\n      word[(int)tmp.size()].push_back(tmp);\n    }\n    cin.ignore();\n    getline(cin,sequence);\n    tmp = sequence.substr(0,(int)sequence.size()-1);\n    stringstream ss(tmp);\n    while( !( ss >> tmp ).fail() ) buf.push_back(tmp);\n\n    sort(buf.begin(),buf.end(),cmp);\n    buf.erase(unique(buf.begin(),buf.end()),buf.end());\n    buf_length = (int) buf.size();\n    bitmask.clear(), bc.clear();\n    bitmask.resize(buf_length,0), bc.resize(buf_length);\n    rep(i,buf_length){\n      rep(j,buf[i].size()){\n      long long SHIFT = buf[i][j] - 'A';\n      bitmask[i] |= (1LL<<SHIFT);\n      }\n      bc[i] = __builtin_popcountll(bitmask[i]);\n    }\n\n    dfs(0,vector<char>(26,'?'),0LL);\n\n    if( found == 1 ) {\n      rep(i,sequence.size()) cout << (isupper(sequence[i])?transfer[sequence[i]-'A']:sequence[i]);\n      puts(\"\");\n    } else puts(\"-.\");\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint n,found,len;\nstring sequence;\nchar table[26];\nchar tmp_table[26];\nset<string> S;\nvector<string> buf,server[21];\n\ninline bool check(const string& word,const string& cipher,const int &blen){\n  rep(i,blen){\n    if( word[i] == '?' ) continue;\n    if( word[i] != cipher[i] ) return false;\n  }\n  return true;\n}\n\nvoid dfs(int cur){\n\n  if( found >= 2 ) return;\n  if( cur >= len ){\n    found++;\n    rep(i,26) table[i] = tmp_table[i];\n\n    return;\n  }\n\n\n  int blen = buf[cur].size();\n  bool already = true;\n  string str = buf[cur];\n  rep(i,blen) {\n    if( tmp_table[buf[cur][i]-'A'] == '?' ) already = false;\n    str[i] = tmp_table[buf[cur][i]-'A'];\n  }\n  if( already ){\n    if( S.find(str) != S.end() ) dfs(cur+1);\n    return;\n  }\n\n  /*\n    cipher = \"AAA\";\n    buf = \"ZAB\";\n    str = \"?A?\";\n   */\n  rep(i,(int)server[blen].size()){\n    if( !check(str,server[blen][i],blen) ) continue;\n    char tmper[26];\n    rep(j,26) tmper[j] = tmp_table[j];\n    bool error = false;\n    rep(j,blen) if( str[j] == '?' ) {\n      if( tmp_table[buf[cur][j]-'A'] == '?' && tmp_table[server[blen][i][j]-'A'] == '?' ) {\n        tmp_table[buf[cur][j]-'A'] = server[blen][i][j];\n        tmp_table[server[blen][i][j]-'A'] = buf[cur][j];\n      } else if( !( tmp_table[buf[cur][j]-'A'] == server[blen][i][j] && tmp_table[server[blen][i][j]-'A'] == buf[cur][j] ) ){\n        error = true;\n        break;\n      }\n    }\n    if( error ) {\n      rep(j,26) tmp_table[j] = tmper[j];\n      continue;\n    }\n    dfs(cur+1);\n    rep(j,26) tmp_table[j] = tmper[j];\n  }\n\n}\n\nbool comp(const string& a, const string& b){ return (int)a.size() > (int) b.size(); }\n\nint main(){\n  while(cin>>n,n){\n    S.clear(), buf.clear(), found = 0;\n    rep(i,26)table[i] = tmp_table[i] = '?';\n    rep(i,21)server[i].clear();\n\n    rep(i,n){\n      cin >> sequence;\n      S.insert(sequence);\n      server[(int)sequence.size()].push_back(sequence);\n    }\n    cin.ignore();\n    getline(cin,sequence);\n    string tmp = sequence.substr(0,(int)sequence.size()-1);\n\n    stringstream ss(tmp);\n    while(!(ss>>tmp).fail()) buf.push_back(tmp);\n    sort(buf.begin(),buf.end());\n\n\n    len = buf.size();\n    dfs(0);\n\n    if( found == 0 || found >= 2 ) puts(\"-.\");\n    else {\n      rep(i,(int)sequence.size()) cout << (isupper(sequence[i])?table[sequence[i]-'A']:sequence[i]);\n      cout << '\\n';\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n;\nvector<string> w,v;\nstring s;\nvector<char> vc,ans;\ntypedef pair<int,int> P;\nvector<P> vp;\nvector<int> used;\nint valid;\nvoid dfs(){\n  for(int i=0;i<(int)v.size();i++){\n    string t=v[i];\n    bool flg=0;\n    for(int j=0;j<n;j++){\n      string u=w[j];\n      if(t.size()!=u.size()) continue;\n      bool ok=1;\n      for(int k=0;k<(int)t.size();k++){\n\tif(!used[t[k]-'A']||!used[u[k]-'A']) continue;\n\tok&=vc[t[k]-'A']==u[k]-'A';\n      }\n      if(ok){\n\tflg=1;\n\tbreak;\n      }\n    }\n    if(!flg) return;\n  }\n  int cnt=0;\n  for(int i=0;i<26;i++) if(used[vp[i].second]||vp[i].first==0) cnt++;\n  //cout<<cnt<<endl;\n  if(cnt==26){\n    valid++;\n    ans=vc;\n    return;\n  }\n  int x=0;\n  while(used[vp[x].second]||vp[x].first==0) x++;\n  //cout<<x<<endl;\n  for(int k=0;k<26;k++){\n    if(used[vp[k].second]||vp[k].first==0) continue;\n    used[vp[x].second]=used[vp[k].second]=1;\n    vc[vp[x].second]=vp[k].second;\n    vc[vp[k].second]=vp[x].second;\n    //cout<<x<<\" \"<<k<<endl;\n    //cout<<(char)(vp[x].second+'A')<<\"<->\"<<(char)(vp[k].second+'A')<<endl;\n    dfs();\n    if(valid>1) return; \n    used[vp[x].second]=used[vp[k].second]=0;\n    vc[vp[x].second]=vc[vp[k].second]='a';\n  }\n}\nsigned main(){\n  while(cin>>n,n){\n    w.resize(n);\n    for(int i=0;i<n;i++) cin>>w[i];\n    cin.ignore();\n    getline(cin,s);\n    assert(s.back()=='.');\n    s.pop_back();\n    v.clear();\n    for(int i=0;i<(int)s.size();i++){\n      string t;\n      while(i<(int)s.size()&&s[i]!=' ') t+=s[i++];\n      //cout<<t<<endl;\n      v.push_back(t);\n    }\n    vc.clear();\n    vc.resize(26,'a');\n    int c[26]={};\n    for(int i=0;i<n;i++)\n      for(int j=0;j<(int)w[i].size();j++)\n\tc[w[i][j]-'A']++;\n    for(int i=0;i<(int)v.size();i++)\n      for(int j=0;j<(int)v[i].size();j++)\n\tc[v[i][j]-'A']++;\n    vp.resize(26);\n    for(int i=0;i<26;i++) vp[i]=P(c[i],i);\n    sort(vp.rbegin(),vp.rend());\n    used.clear();\n    used.resize(26,0);\n    valid=0;\n    dfs();\n    if(valid!=1){\n      cout<<\"-.\"<<endl;\n      continue;\n    }\n    //puts(\"found\");\n    for(int i=0;i<(int)v.size();i++){\n      if(i) cout<<\" \";\n      for(int j=0;j<(int)v[i].size();j++){\n\t//cout<<v[i][j]-'A'<<endl;\n\tcout<<(char)(ans[v[i][j]-'A']+'A');\n      }\n    }\n    cout<<\".\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reep(i,a,b) for(int i=a; i<b; i++)\n\nvector<vector<string> > func(string input){\n\tvector<vector<string> > ret(21);\n\tstringstream ss;\n\tss << input;\n\tstring s;\n\twhile(ss>>s){\n\t\tif(s[s.size()-1] == '.') s = s.substr(0,s.size()-1);\n\t\tret[s.size()].push_back(s);\t\n\t}\n\treturn ret;\n}\n\nvector<vector<int> > ans;\nvector<vector<string> > vv;\n\nbool check(string &a, string &b, vector<int> tik){\n\trep(i,a.size()){\n\t\tint aa = a[i]-'A';\n\t\tint bb = b[i]-'A';\n\t\tif(tik[aa] == -1 && tik[bb] == -1){\n\t\t\ttik[aa] = bb;\n\t\t\ttik[bb] = aa;\n\t\t}\n\t\telse if(tik[aa] == bb && tik[bb] == aa){\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid update(string &a, string &b, vector<int> &tik){\n\t/*cout<<a<<\" \"<<b<<endl;\n\trep(i,26) cout<<tik[i]<<\" \";\n\tcout<<endl;\n\t*/\n\trep(i,a.size()){\n\t\tint aa = a[i]-'A';\n\t\tint bb = b[i]-'A';\n\t\tif(tik[aa] == -1 && tik[bb] == -1){\n\t\t\ttik[aa] = bb;\n\t\t\ttik[bb] = aa;\n\t\t}\n\t}\n\t/*\n\trep(i,26) cout<<tik[i]<<\" \";\n\tcout<<endl;\n\t*/\n}\n\nvoid saiki(int x, vector<string> &w, vector<int> tik){\n\tif(x == w.size()){\n\t\tans.push_back(tik);\n\t\treturn;\n\t}\n\tstring &s = w[x];\n\trep(i,vv[s.size()].size()){\n\t\tif(check(s, vv[s.size()][i], tik)){\n\t\t\tvector<int> tmp = tik;\n\t\t\tupdate(s, vv[s.size()][i], tik);\n\t\t\tsaiki(x+1, w, tik);\n\t\t\ttik = tmp;\t\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n, n){\n\t\t//cout<<n<<endl;\n\t\tvv = vector<vector<string> >(21);\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tvv[s.size()].push_back(s);\n\t\t}\n\t\tstring input;\n\t\tgetline(cin, input);\n\t\tgetline(cin, input);\n\t\t//cout<<input<<endl;\n\t\t//return 0;\n\t\tvector<vector<string> > in = func(input);\n\t\trep(i,21){\n\t\t\tsort(in[i].begin(), in[i].end());\n\t\t\tin[i].erase(unique(in[i].begin(), in[i].end()), in[i].end());\n\t\t}\n\t\tvector<string> w;\n\t\tfor(int i=20; i>=1; i--){\n\t\t\trep(j,in[i].size()){\n\t\t\t\tw.push_back(in[i][j]);\n\t\t\t}\n\t\t}\n\t\tvector<int> tik(26,-1);\n\t\tans.clear();\n\t\tsaiki(0,w,tik);\n\t\tif(ans.size()>1){\n\t\t\tcout<<\"-.\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tvector<int> tik = ans[0];\n\t\t\t/*cout<<\"ttt \"<<endl;\n\t\t\trep(i,26){\n\t\t\t\tcout<<t[i]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t\t*/\n\t\t\trep(i,input.size()){\n\t\t\t\tif(isupper(input[i])){\n\t\t\t\t\t//cout<<input[i]<<\" \"<<tik[input[i]-'A']<<endl;;\n\t\t\t\t\tcout<<char(tik[input[i]-'A']+'A');\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcout<<input[i];\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <iostream>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 21;\nconst int MAXC = 100;\n\nint n, answer, table[26], answerTable[26], nCiph, nDict, ciphRemain[MAXC];\nstd::string ciph[MAXC], dict[MAXN], buffer;\n\nbool cmpByLength(const std::string &a, const std::string &b) {\n    return a.length() < b.length();\n}\n\nbool cmpByRemain(const int &a, const int &b) {\n    return ciphRemain[a] < ciphRemain[b];\n}\n\nvoid dfs(int nCiph, std::string ciph[]) {\n    if (nCiph == 0) {\n        answer++;\n        memcpy(answerTable, table, sizeof(answerTable));\n        return;\n    }\n    static int ciphId[MAXC];\n    for (int i = 1; i <= nCiph; i++) {\n        ciphRemain[i] = 0;\n        ciphId[i] = i;\n        for (int j = 0; j < ciph[i].length(); j++) {\n            if (table[ciph[i][j] - 'A'] == 0) {\n                ciphRemain[i]++;\n            }\n        }\n    }\n    std::sort(ciphId + 1, ciphId + nCiph + 1, cmpByRemain);\n    int nEnsure = 0, ensure[MAXC];\n    std::string now = ciph[ciphId[nCiph]];\n    for (int i = 1; i <= nDict; i++) {\n        if (now.length() != dict[i].length()) continue;\n        bool flag = true;\n        for (int j = 0; j < now.length(); j++) {\n            if (table[now[j] - 'A'] != 0) {\n                if (table[now[j] - 'A'] != dict[i][j]) {\n                    flag = false;\n                    break;\n                }\n            } else if (table[dict[i][j] - 'A'] != 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (!flag) continue;\n        for (int j = 0; j < now.length(); j++) {\n            if (table[now[j] - 'A'] == 0) {\n                table[now[j] - 'A'] = dict[i][j];\n                table[dict[i][j] - 'A'] = now[j];\n                ensure[++nEnsure] = now[j];\n                if (dict[i][j] != now[j]) {\n                    ensure[++nEnsure] = dict[i][j];\n                }\n            }\n        }\n        for (int j = 0; j < now.length(); j++) {\n            if (table[now[j] - 'A'] != 0) {\n                if (table[now[j] - 'A'] != dict[i][j]) {\n                    flag = false;\n                    break;\n                }\n            } else if (table[dict[i][j] - 'A'] != 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            std::string nextCiph[MAXC];\n            for (int j = 1; j < nCiph; j++) {\n                nextCiph[j] = ciph[ciphId[j]];\n            }\n            dfs(nCiph - 1, nextCiph);\n            if (answer > 1) return;\n        }\n        for (int j = 1; j <= nEnsure; j++) {\n            table[ensure[j] - 'A'] = 0;\n        }\n    }\n}\n\nvoid solve() {\n    answer = 0;\n    std::fill(table, table + 26, 0);\n    for (int i = 1, k = 1; i <= nDict; i++) {\n        int j = i;\n        while (j + 1 <= nDict && dict[j].length() == dict[j + 1].length()) j++;\n        while (k <= nCiph && ciph[k].length() < dict[i].length()) k++;\n        if (i == j) {\n            while (k <= nCiph && ciph[k].length() == dict[i].length()) {\n                for (int p = 0; p < ciph[k].length(); p++) {\n                    if (table[ciph[k][p] - 'A'] != 0) {\n                        if (table[ciph[k][p] - 'A'] != dict[i][p]) {\n                            puts(\"-.\");\n                            return;\n                        }\n                    } else if (table[dict[i][p] - 'A'] != 0) {\n                        puts(\"-.\");\n                        return;\n                    } else {\n                        table[ciph[k][p] - 'A'] = dict[i][p];\n                        table[dict[i][p] - 'A'] = ciph[k][p];\n                    }\n                }\n                k++;\n            }\n        }\n        i = j;\n    }\n    dfs(nCiph, ciph);\n    if (answer == 1) {\n        for (int i = 0; i < buffer.length(); i++) {\n            if (!isalpha(buffer[i])) putchar(buffer[i]);\n            else putchar(answerTable[buffer[i] - 'A']);\n        }\n        puts(\"\");\n    } else {\n        puts(\"-.\");\n    }\n}\n\nint main() {\n    while (scanf(\"%d\", &nDict) == 1) {\n        if (nDict == 0) break;\n        for (int i = 1; i <= nDict; i++) {\n            std::string buffer;\n            std::cin >> dict[i];\n        }\n        nCiph = 0;\n        std::getline(std::cin, buffer);\n        std::getline(std::cin, buffer);\n        for (int i = 0; i < buffer.length(); i++) {\n            static std::string tmp; \n            if (isalpha(buffer[i])) {\n                tmp = tmp + buffer[i];\n            } else {\n                ciph[++nCiph] = tmp;\n                tmp = \"\";\n            }\n        }\n        std::sort(dict + 1, dict + nDict + 1);\n        std::sort(ciph + 1, ciph + nCiph + 1);\n        nDict = std::unique(dict + 1, dict + nDict + 1) - dict - 1;\n        nCiph = std::unique(ciph + 1, ciph + nCiph + 1) - ciph - 1;\n        std::sort(dict + 1, dict + nDict + 1, cmpByLength);\n        std::sort(ciph + 1, ciph + nCiph + 1, cmpByLength);\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nconst int IINF = INT_MAX;\n\nint n,found,len;\nvector<string> buf[30],seq;\nstring tmp,sequence,answer;\nchar transfer[26];\n\nbool comp(const string& a,const string& b) {\n  set<char> A,B;\n  rep(i,a.size()) A.insert(a[i]);\n  rep(i,b.size()) B.insert(b[i]);\n  return A.size() > B.size();\n}\n\nvoid dfs(int cur){\n\n  if( found >= 2 ) return;\n\n  if( cur >= len ){\n    ++found;\n    rep(i,answer.size()) if( isupper(answer[i]) ) answer[i] = transfer[answer[i]-'A'];\n    return;\n  }\n\n  int word_size = seq[cur].size();\n\n  rep(i,(int)buf[word_size].size()){\n    string word = buf[word_size][i];\n\n    int *backtrack = new int[word_size+1];\n    backtrack[0] = -1; // sentinel\n    bool error = false;\n    rep(j,word_size){\n      if( transfer[word[j]-'A'] == '?' && transfer[seq[cur][j]-'A'] == '?' ) {\n        backtrack[j] = 1, backtrack[j+1] = -1;\n        transfer[word[j]-'A'] = seq[cur][j];\n        transfer[seq[cur][j]-'A'] = word[j];\n      } else if( transfer[word[j]-'A'] == seq[cur][j] && transfer[seq[cur][j]-'A'] == word[j] ) {\n        backtrack[j] = 0;\n      } else {\n        backtrack[j] = -1;\n        error = true;\n        break;\n      }\n    }\n\n    if( !error ) dfs( cur+1 );\n\n    int j = 0;\n    while( backtrack[j] != -1 && j < word_size) {\n      if( backtrack[j] == 1 ) transfer[word[j]-'A'] = transfer[seq[cur][j]-'A'] = '?';\n      ++j;\n    }\n\n  }\n\n}\n\nint main(){\n  while( cin >> n, n ){\n    seq.clear();\n    rep(i,30) buf[i].clear();\n    rep(i,n) {\n      cin >> tmp;\n      buf[(int)tmp.size()].push_back(tmp);\n    }\n    cin.ignore();\n    getline(cin,sequence);\n    stringstream ss(sequence.substr(0,(int)sequence.size()-1));\n    while( !( ss >> tmp ).fail() ) seq.push_back(tmp);\n    sort(seq.begin(),seq.end(),comp);\n\n    answer = sequence;\n    found = 0, len = (int)seq.size();\n    rep(i,26) transfer[i] = '?';\n    dfs(0);\n\n    cout << ((found==1)?answer:\"-.\") << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n\nint tr[26], ans[26];\nvector<string> split(string s) \n{\n\tvector<string> res;\n\tstringstream ss(s);\n\n\tstring a;\n\twhile(ss >> a) { res.push_back(a); }\n\n\treturn res;\n}\n\nbool check(char a, char b)\n{\n\tif(tr[a - 'A'] != -1 && tr[a - 'A'] != b) return false;\n\tif(tr[b - 'A'] != -1 && tr[b - 'A'] != a) return false;\n\n\treturn true;\n}\n\nbool match(string w, string msg)\n{\n\tfor(int i=0; i<msg.size(); i++) {\n\t\tif(!check(w[i], msg[i])) return false; \n\t}\n\n\treturn true;\n}\n\nint dfs(int p, vector<string>& words, vector<string>& msg) \n{\n\tif(p == msg.size()) {\n\t\tmemcpy(ans, tr, sizeof(ans));\n\t\treturn 1;\n\t}\n\t\n\tint res = 0;\t\n\tfor(int i=0; i<words.size(); i++) {\n\t\tif(res >= 2) return 1192;\n\t\n\t\tif(msg[p].size() != words[i].size()) continue;\n\t\tif(!match(words[i], msg[p])) continue;\n\t\t\n\t\tbool valid = true;\n\t\tint t[26];\n\t\tmemcpy(t, tr, sizeof(t));\n\t\tfor(int j=0; j<msg[p].size(); j++) {\n\t\t\tif(!check(words[i][j], msg[p][j])) { valid = false; break; } \n\t\t\ttr[msg[p][j] - 'A'] = words[i][j];\n\t\t\ttr[words[i][j] - 'A'] = msg[p][j];\n\t\t}\n\t\tif(valid) {\n\t\t\tres += dfs(p+1, words, msg);\n\t\t}\n\t\tmemcpy(tr, t, sizeof(tr));\n\t}\n\n\treturn res;\n}\n\nbool comp(const string& a, const string& b)\n{\n\tif(a.size() != b.size()) return a.size() > b.size();\n\treturn a > b;\n}\n\n\nint main()\n{\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvector<string> words(N);\n\t\tfor(int i=0; i<N; i++) cin >> words[i];\n\n\t\tstring str;\n\t\tgetline(cin, str);\n\t\tgetline(cin, str);\n\t\n\t\tstr.erase(str.end() - 1);\n\n\t\tsort(words.begin(), words.end(), comp);\n\n\t\tvector<string> msg = split(str);\n\t\tsort(msg.begin(), msg.end());\n\t\tmsg.erase(unique(msg.begin(), msg.end()), msg.end());\n\t\tsort(msg.begin(), msg.end(), comp);\n\n\t\tfor(int i=0; i<26; i++) tr[i] = -1;\n\n\t\tint res = dfs(0, words, msg);\n\t\tif(res != 1) cout << \"-.\" << endl;\n\t\telse {\n\t\t\tfor(int i=0; i<str.size(); i++) {\n\t\t\t\tif(isalpha(str[i])) cout << (char)ans[str[i]-'A'];\n\t\t\t\telse cout << str[i];\n\t\t\t}\n\n\t\t\tcout << \".\" << endl;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cstring>\n#include <sstream>\nusing namespace std;\n\nint n, m;\nstring cand[22];\nvector<string> words;\n\nvector<int> match[82];\nint matchBit[82];\n\nvector<char> ansKey;\nint ansFlg;\n\nbool matches(string a, string b){\n  if(a.size() != b.size()) return false;\n  char trans[128];\n  memset(trans, -1, sizeof(trans));\n  for(int i = 0; i < a.size(); i++){\n    if(trans[a[i]] != -1 && b[i] != trans[a[i]]) return false;\n    if(trans[b[i]] != -1 && a[i] != trans[b[i]]) return false;\n    trans[a[i]] = b[i];\n    trans[b[i]] = a[i];\n  }\n  return true;\n}\n\nbool mycmp(const string &a, const string &b){\n  set<char> st1;\n  for(int i = 0; i < a.size(); i++) st1.insert(a[i]);\n  set<char> st2;\n  for(int i = 0; i < b.size(); i++) st2.insert(b[i]);\n\n  return st1.size() > st2.size();\n}\n\nbool setKey(const string &a, const string &b, vector<char> &key){\n  for(int i = 0; i < a.size(); i++){\n    if(key[a[i]] != -1 && key[a[i]] != b[i]){\n      return false;\n    }\n    key[a[i]] = b[i];\n    key[b[i]] = a[i];\n  }\n  return true;\n}\n\nvoid dfs(int idx, int used, vector<char> key){\n  if(idx == m){\n    if(ansFlg == 1){\n      ansFlg = -1;\n    }\n    else{\n      ansFlg = 1;\n      ansKey = key;\n    }\n    return;\n  }\n\n  for(int i = 0; i < match[idx].size(); i++){\n    int j = match[idx][i];\n    if(used & (1 << j)) continue;\n\n    vector<char> nextKey = key;\n    if(setKey(words[idx], cand[j], nextKey)){\n      dfs(idx + 1, used | (1 << j), nextKey);\n      if(ansFlg == -1) return;\n    }\n  }\n}\n\nvoid solve(){\n  sort(words.begin(), words.end(), mycmp);\n\n  for(int i = 0; i < m; i++){\n    match[i].clear();\n    matchBit[i] = 0;\n\n    for(int j = 0; j < n; j++){\n      if(matches(words[i], cand[j])){\n        match[i].push_back(j);\n        matchBit[i] |= (1 << j);\n      }\n    }\n  }\n\n  vector<char> key(128, -1);\n  ansFlg = 0;\n  dfs(0, 0, key);\n}\n\nint main(){\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++){\n      cin >> cand[i];\n\n      for(int j = 0; j < i; j++){\n        if(cand[j] == cand[i]){\n          i--;\n          n--;\n          break;\n        }\n      }\n    }\n\n    string s;\n    getline(cin, s);\n    getline(cin, s);\n\n    string ts;\n    stringstream ss(s);\n    words.clear();\n\n    while(ss >> ts){\n      string pushStr = \"\";\n      for(int i = 0; i < ts.size(); i++){\n        if(ts[i] == '.') continue;\n        pushStr += ts[i];\n      }\n      bool pushFlg = true;\n      for(int i = 0; i < words.size(); i++){\n        if(words[i] == pushStr){\n          pushFlg = false;\n          break;\n        }\n      }\n      if(pushFlg) words.push_back(pushStr);\n    }\n    m = words.size();\n\n    solve();\n\n    if(ansFlg == 1){\n      for(int i = 0; i < s.size(); i++){\n        if(s[i] == ' ' || s[i] == '.') cout << s[i];\n        else                           cout << ansKey[s[i]];\n      }\n      cout << endl;\n    }\n    else{\n      cout << \"-.\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <functional>\n#include <queue>\n#include <vector>\n#include <cstdlib>\n#include <string>\n#include <set>\nusing namespace std;\n\n#define PII pair<int,int> \n#define MP make_pair\n#define FI first\n#define SE second\n#define PB push_back\n#define lid (id << 1)\n#define rid (id << 1 | 1)\n#define MID(a, b) ((a + b) >> 1)\n\nconst int N = 110;\nconst int INF = 1000000000;\nconst long long Mod = 1000000007;\n\nvector<string> word[N], s;\nchar str[N], INV[26], ch[N];\nmap<unsigned int, bool> vis[N];\nstring ans;\nint n, find_ans, m, L, len[N], num[N], occ[N][N];\n\nint cnt = 0;\n\nunsigned int get_hash(){\n    unsigned int ret = 0;\n    for(int i = 0; i < 26; i++){\n        ret = ret * 29 + INV[i] - 'A';\n    }\n    return ret;\n}\n\nbool check(int k, int p){\n\tfor(int i = 0; i < m; i++){\n\t\t// if(!occ[i][k] && !occ[i][p]) continue;\n\t\t\n\t\tint find = 0;\n\t\tfor(int o = 0; o < word[len[i]].size(); o++){\n\t\t\t\t\n\t\t\tint no = 0;\n\t\t\tfor(int l = 0; l < len[i]; l ++){\n\t\t\t\tif(INV[s[i][l] - 'A'] == '#'){\n\t\t\t\t\tif(word[len[i]][o][l] == 'A' + k || word[len[i]][o][l] == 'A' + p){\n\t\t\t\t\t\tno = 1; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(INV[s[i][l] - 'A'] != word[len[i]][o][l]){\n\t\t\t\t\tno = 1; break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(no == 0){\n\t\t\t\tfind = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tif(!find) return false;\n\t\t\n\t}\n\treturn true;\n}\n\nvoid dfs(int k){\n    while(k < 26 && (INV[k] != '#' || num[k] == 0)){\n    \tk++;\n    }\n    if(k == 26) {\n    \tif(find_ans > 0) {\n    \t\tfind_ans = 2;\n    \t\treturn;\n    \t}\n    \telse{\n    \t\tfor(int i = 0; i < L; i++){\n    \t\t\tif(ch[i] > 'Z' || ch[i] < 'A'){\n    \t\t\t\tans += ch[i];\n    \t\t\t}\n    \t\t\telse{\n    \t\t\t\tans += INV[ch[i] - 'A'];\n    \t\t\t}\n    \t\t}\n    \t\tfind_ans = 1;\n    \t}\n    \treturn;\n    }\n    \n    if(find_ans > 1) return;\n\n    for(int i = k; i < 26; i++){\n    \tif(INV[i] != '#' || num[i] == 0) continue;\n    \tINV[k] = 'A' + i; INV[i] = 'A' + k;\n\n    \tif(check(k, i)){\n   \t\t\tdfs(k + 1);\n   \t\t\tif(find_ans > 1) return;\n    \t}\n\n    \tINV[k] = INV[i] = '#';\n\n    }\n}\n\nbool cmpr(string a, string b){\n    return a.length() > b.length();\n}\n\nvoid solve(){\n    for(int i = 0; i < N; i++){\n        word[i].clear();\n    }\n    s.clear(); cnt = 0;\n\n    memset(occ, 0, sizeof(occ));\n    memset(num, 0, sizeof(num));\n\n\n    for(int i = 0; i < n; i++){\n        scanf(\"%s\", str);\n        int len = strlen(str);\n        word[len].push_back(str);\n        for(int j = 0; j < len; j++){\n        \tnum[str[j] - 'A'] ++;\n        }\n    }\n    gets(str); gets(str);\n    L = strlen(str);\n    memcpy(ch, str, sizeof(ch));\n    char *temp = strtok(str, \" .\");\n    while(temp != NULL){\n        s.push_back(temp);\n        temp = strtok(NULL, \" .\");\n    }\n\n    sort(s.begin(), s.end());\n    s.erase(unique(s.begin(), s.end()), s.end());\n\n    m = s.size();\n    sort(s.begin(), s.end(), cmpr);\n\n\n \tfor(int i = 0; i < m; i++){\n \t\tfor(int j = 0; j < s[i].length(); j++){\n \t\t\tocc[i][s[i][j] - 'A'] = 1;\n \t\t\tnum[s[i][j] - 'A']++;\n \t\t}\n \t}\n\n    for(int i = 0; i < m; i++){\n        len[i] = s[i].length();\n    }\n\n    for(int i = 0; i < 26; i++)\n    \tINV[i] = '#';\n\n    ans = \"\"; find_ans = 0;\n    dfs(0);\n    // cout << find_ans << endl;\n    if(find_ans > 1){\n    \tputs(\"-.\");\n    }\n    else{\n    \tcout << ans << endl;\n    }\n}\n\nint main(){\n    // freopen(\"in.txt\", \"r\", stdin); \n    while(scanf(\"%d\", &n) != EOF){\n        if(n == 0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint n, m;\nchar word[205][205];\nchar seq[205][205];\nint len1[205], len2[205];\nint match[205][205];\nstring ans;\nint multi;\nint sum[205];\nint to[205][205][30];\nint finalans[205];\nint key[205][205];\n\nbool check_match(int x, int y) {\n\tif (len1[x] != len2[y]) return 0;\n\tfor (int i = 0; i < 26; i ++) \n\t\tto[x][y][i] = -1;\n\tfor (int i = 1; i <= len1[x]; i ++) {\n\t\tif (to[x][y][word[x][i] - 'A'] == -1 && to[x][y][seq[y][i] - 'A'] == -1) {\n\t\t\tto[x][y][word[x][i] - 'A'] = seq[y][i] - 'A';\n\t\t\tto[x][y][seq[y][i] - 'A'] = word[x][i] - 'A';\n\t\t} else {\n\t\t\tif (to[x][y][word[x][i] - 'A'] != seq[y][i] - 'A') return 0;\n\t\t\tif (to[x][y][seq[y][i] - 'A'] != word[x][i] - 'A') return 0;\n\t\t}\n\t}\n\treturn 1;\n}\n\nvoid check() {\n\tif (ans == \"fbh\") {\n\t\tans = \"\";\n\t\tfor (int i = 1; i <= m; i ++) {\n\t\t\tfor (int j = 1; j <= len2[i]; j ++) \n\t\t\t\tans += (char)('A' + key[m + 1][seq[i][j] - 'A']);\n\t\t}\n\t\tfor (int i = 0; i < 26; i ++) \n\t\t\tfinalans[i] = key[m + 1][i];\n\t} else {\n\t\tstring tmp = \"\";\n\t\tfor (int i = 1; i <= m; i ++) {\n\t\t\tfor (int j = 1; j <= len2[i]; j ++) \n\t\t\t\ttmp += (char)('A' + key[m + 1][seq[i][j] - 'A']);\n\t\t}\n\t\tif (ans != tmp) {\n\t\t\tmulti = 1;\n\t\t}\n\t}\n}\n\nvoid dfs(int x) {\n\tif (x == m + 1) {\n\t\tcheck();\n\t\treturn;\n\t}\n\t\n\tfor (int i = 1; i <= n; i ++) \n\t\tif (match[i][x]) {\n\t\t\tfor (int j = 0; j < 26; j ++)\n\t\t\t\tkey[x + 1][j] = key[x][j];\n\t\t\tbool flag = false;\n\t\t\tfor (int j = 0; j < 26; j ++) {\n\t\t\t\tif (to[i][x][j] == -1) continue;\n\t\t\t\tif (key[x + 1][j] == -1) {\n\t\t\t\t\tkey[x + 1][j] = to[i][x][j];\n\t\t\t\t} else if (key[x + 1][j] != to[i][x][j]) {\n\t\t\t\t\tflag = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) continue;\n\t\t\tdfs(x + 1);\n\t\t\tif (multi) return;\n\t\t}\n}\n\nvoid print(int x) {\n\tfor (int i = 1; i <= len2[x]; i ++) \n\t\tprintf(\"%c\", finalans[seq[x][i] - 'A'] + 'A');\n}\n\nint main() {\n\twhile (scanf(\"%d\", &n) == 1) {\n\t\tif (n == 0) break;\n\t\tfor (int i = 1; i <= n; i ++) {\n\t\t\tscanf(\"%s\", word[i] + 1);\n\t\t\tlen1[i] = strlen(word[i] + 1);\n\t\t}\n\t\t//cnt = 0;\n\t\tm = 0;\n\t\twhile (1) {\n\t\t\tscanf(\"%s\", seq[++m] + 1);\n\t\t\tlen2[m] = strlen(seq[m] + 1);\n\t\t\tsum[m] = sum[m - 1] + len2[m];\n\t\t\tif (seq[m][len2[m]] == '.') {\n\t\t\t\tlen2[m] --;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 1; i <= n; i ++)\n\t\t\tfor (int j = 1; j <= m; j ++) {\n\t\t\t\tmatch[i][j] = 0;\n\t\t\t\tif (check_match(i, j)) {\n\t\t\t\t\tmatch[i][j] = 1;\n\t\t\t\t\t//printf(\"%d %d %d\\n\", i, j, match[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\tfor (int i = 0; i < 26; i ++) \n\t\t\tkey[1][i] = -1;\n\t\tmulti = 0;\n\t\tans = \"fbh\";\n\t\tdfs(1);\n\t\tif (ans == \"fbh\" || multi == 1) {\n\t\t\tprintf(\"-.\\n\");\n\t\t} else {\n\t\t\tfor (int i = 1; i <= m; i ++) {\n\t\t\t\tprint(i);\n\t\t\t\tif (i == m) printf(\".\\n\");\n\t\t\t\telse printf(\" \");\n\t\t\t}\n\t\t}\n\t\t//cout << multi << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint N;\nstring sentence;\nstring words[20];\nchar pairs[26];\nset<string> ans;\nset< vector<char> > memo[100];\nstring replace(string s){\n  REP(i, s.size())if(isalpha(s[i])) s[i] = pairs[s[i]-'A'];\n  return s;\n}\nvoid dfs(int k, vector<string>& targets){\n  if(ans.size() >= 2) return;\n  //if(memo[k].count(pairs)) return;\n  //memo[k].insert(pairs);\n  if(k == targets.size()) {\n    ans.insert(replace(sentence));\n    return;\n  }\n\n  string& target = targets[k];\n  char tmppairs[26];\n  memcpy(tmppairs, pairs, sizeof tmppairs);\n  REP(i, N)if(words[i].size() == target.size()){\n    string& word = words[i];\n\n    bool ok = true;\n    REP(j, word.size())if(pairs[word[j]-'A'] != 0 && pairs[word[j]-'A'] != target[j]) ok = false;\n    if(!ok) continue;\n\n    REP(j, word.size()){\n      pairs[word[j]-'A'] = target[j];\n      pairs[target[j]-'A'] = word[j];\n    }\n\n    REP(i, 26)if(pairs[i] != 0 && pairs[pairs[i]-'A'] != i + 'A') ok = false;\n    REP(j, word.size())if(pairs[word[j] - 'A'] != 0 && (pairs[target[j] - 'A'] != word[j])) ok = false;\n    if(!ok) continue;\n\n    dfs(k + 1, targets);\n\n    memcpy(pairs, tmppairs, sizeof pairs);\n  }\n}\n\nint main(){\n  while(cin>>N && N){\n    //initialize\n    REP(i, 26) pairs[i] = 0;\n    ans.clear();\n\n    //input\n    REP(i, N) cin>>words[i];\n    cin.ignore();\n    getline(cin, sentence);\n    vector<string> targets;\n    stringstream ss(sentence);\n    for(string tmp;;){\n      if(!(ss>>tmp)) break;\n      if(tmp[tmp.size()-1] == '.') tmp = tmp.substr(0, tmp.size() - 1);\n      targets.push_back(tmp);\n    }\n    // sort by length of string\n    REP(i, targets.size())FOR(j, i+1, targets.size()) if(targets[i].size() < targets[j].size()) swap(targets[i], targets[j]);\n\n    dfs(0, targets);\n\n    if(ans.size() == 1) cout<<*ans.begin()<<endl;\n    else cout<<\"-.\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nconst int nMax=21;\nconst int lMax=22;\nint n;\nstruct str\n{\n\tchar s[lMax];\n}aim[lMax][81],st[lMax][nMax];\nint aim_cnt[lMax],st_cnt[lMax],sub[27],ans[27],ans_cnt,sub_flag[27];\nint q2[65536],q_r;\nchar ret[81],r_len;\nint judge(int len,int id1,int id2)\n{\n\tfor(int i=1;i<=len;i++)\n\t{\n\t\tif(sub[aim[len][id1].s[i]-'A'+1]==st[len][id2].s[i]-'A'+1)\n\t\t{\n\t\t\tif(sub_flag[aim[len][id1].s[i]-'A'+1]==0)\n\t\t\t{ \n\t\t\t\tsub_flag[aim[len][id1].s[i]-'A'+1]=1;\n\t\t\t\tq2[q_r++]=aim[len][id1].s[i]-'A'+1;\n\t\t\t\tq_r%=65536;\n\t\t\t}\n\t\t\tif(sub_flag[st[len][id2].s[i]-'A'+1]==0)\n\t\t\t{\n\t\t\t\tq2[q_r++]=st[len][id2].s[i]-'A'+1;\n\t\t\t\tq_r%=65536;\n\t\t\t\tsub_flag[st[len][id2].s[i]-'A'+1]=1;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tif(sub_flag[aim[len][id1].s[i]-'A'+1]==0&&sub_flag[st[len][id2].s[i]-'A'+1]==0)\n\t\t{\n\t\t\tsub[aim[len][id1].s[i]-'A'+1]=st[len][id2].s[i]-'A'+1;\n\t\t\tsub[st[len][id2].s[i]-'A'+1]=aim[len][id1].s[i]-'A'+1;\n\t\t\tsub_flag[aim[len][id1].s[i]-'A'+1]=1;\n\t\t\tsub_flag[st[len][id2].s[i]-'A'+1]=1;\n\t\t\tq2[q_r++]=aim[len][id1].s[i]-'A'+1;\n\t\t\tq_r%=65536;\n\t\t\tq2[q_r++]=st[len][id2].s[i]-'A'+1;\n\t\t\tq_r%=65536;\n\t\t}\n\t\telse\n\t\t{\n//\t\t\tprintf(\"%d %s %s %d\\n\",len,aim[len][id1].s+1,st[len][id2].s+1,i);\n\t\t\treturn 0;\n\t\t}\n\t}\n\treturn 1;\n}\nvoid dfs(int len,int id,int d_clock)\n{\n\tif(len==0)\n\t{\n\t\tans_cnt++;\n\t\tfor(int i=1;i<=26;i++)\n\t\t\tans[i]=sub[i];\n\t\treturn;\n\t}\n\tif(id+1>aim_cnt[len])\n\t{\n\t\tdfs(len-1,0,d_clock);\n\t\treturn;\n\t}\n\tint nid=id+1,now,en;\n\tfor(int i=1;i<=st_cnt[len];i++)\n\t{\n\t\tnow=q_r;\n\t\tif(judge(len,nid,i))\n\t\t{\n\t\t\ten=q_r;\n\t\t\tdfs(len,nid,d_clock+1);\n\t\t\tif(ans_cnt>1)\n\t\t\t\treturn;\n\t\t}\n\t\telse\n\t\t\ten=q_r;\n\t\tfor(int k=now;k!=en;k=(k+1)%65536)\n\t\t{\n\t\t\tsub[q2[k]]=q2[k];\n\t\t\tsub_flag[q2[k]]=0;\n\t\t}\n\t}\n}\nvoid add(char *s,int len)\n{\n\tret[++r_len]=' ';\n\tfor(int i=1;i<=len;i++)\n\t{\n\t\tr_len++;\n\t\tret[r_len]=s[i];\n\t}\n}\nint main()\n{\n\tscanf(\"%d\",&n);\n\twhile(n!=0)\n\t{\n\t\tint ok=1;\n\t\tmemset(aim_cnt,0,sizeof(aim_cnt));\n\t\tmemset(st_cnt,0,sizeof(st_cnt));\n\t\tfor(int i=1;i<=n;i++)\n\t\t{\n\t\t\tstr din;\n\t\t\tscanf(\"%s\",din.s+1);\t\t\n\t\t\tint len=strlen(din.s+1);\n\t\t\tst[len][++st_cnt[len]]=din;\n\t\t}\n\t\tchar din[82];\n\t\tr_len=0;\n\t\tscanf(\"%s\",din+1);\n\t\tint len=strlen(din+1);\n\t\tadd(din,len);\n\t\twhile(din[len]!='.')\n\t\t{\n\t\t\tif(len>20)\n\t\t\t{\n\t\t\t\tok=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t++aim_cnt[len];\n\t\t\tfor(int i=1;i<=len+1;i++)\n\t\t\t\taim[len][aim_cnt[len]].s[i]=din[i];\n\t\t\tscanf(\"%s\",din+1);\n\t\t\tlen=strlen(din+1);\n\t\t\tadd(din,len);\n\t\t}\n\t\tif(din[len]=='.')\n\t\t\tif(len>21)\n\t\t\t\tok=0;\n\t\t\telse\n\t\t\t{\n\t\t\t\tdin[len]=0;\n\t\t\t\t++aim_cnt[len-1];\n\t\t\t\tfor(int i=1;i<=len;i++)\n\t\t\t\t\taim[len-1][aim_cnt[len-1]].s[i]=din[i];\n\t\t\t}\t\t\t\n\t\tret[r_len+1]=0;\n\t\tif(!ok)\n\t\t\tprintf(\"-.\\n\");\n\t\telse\n\t\t{\n\t\t\tfor(int ss=1;ss<=26;ss++)\n\t\t\t\tsub[ss]=ans[ss]=ss;\n\t\t\tmemset(sub_flag,0,sizeof(sub_flag));\n\t\t\tans_cnt=0;\n\t\t\tdfs(20,0,0);\n\t\t\tif(ans_cnt!=1)\n\t\t\t\tprintf(\"-.\\n\");\n\t\t\telse\n\t\t\t{\n\t\t\t\tret[r_len+1]=0;\n\t\t\t\tfor(int i=1;i<r_len;i++)\n\t\t\t\t{\n\t\t\t\t\t\tif(ret[i]==' ')\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tret[i]=ans[ret[i]-'A'+1]+'A'-1;\n\t\t\t\t}\n\t\t\t\tprintf(\"%s\\n\",ret+2);\n\t\t\t}\n\t\t}\t\n\t\tscanf(\"%d\",&n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <cmath>\n#include <stack>\n#define PI acos(-1.0)\n#define inf 0x3f3f3f3f\n#define E exp(double(1))\n#define maxn 100\n#define eps 1e-7\nusing namespace std;\n\n#ifdef __int64\n    typedef __int64 LL;\n#else\n    typedef long long LL;\n#endif\n\nchar tmp[maxn];\nchar w[maxn];\n\nstruct node{\n    int len;\n    char q[100];\n    bool operator < (const node a)const {\n        return len>a.len;\n    }\n    char operator [](const int a)const{\n        return q[a];\n    }\n}t[maxn],s[maxn];\n\nint mp[30],cnt,n,ans;\n\nint p[30];\n\nint from[maxn];\n\nvoid dfs(int tp,int sp){\n    if(ans>1){\n        return;\n    }\n    if(sp == cnt){\n        ans++;\n        if(ans==1){\n            memcpy(p,mp,sizeof p);\n        }\n        return;\n    }\n    if(tp == n)return;\n    if(t[tp].len < s[sp].len)return;\n    if(t[tp].len > s[sp].len){\n        dfs(tp+1,sp);\n        return ;\n    }\n    int tt[30];\n    memcpy(tt,mp,sizeof mp);\n    bool ok=true;\n    for(int i=0;i<t[tp].len;i++){\n\n        int u = t[tp][i] - 'A';\n        int v = s[sp][i] - 'A';\n        if(mp[u]==v&&mp[v]==u)continue;\n\n        if(mp[u]==-1&&mp[v]==-1){\n            mp[u]=v; mp[v]=u;\n        }else if(mp[u]!=v || mp[v]!=u){\n            memcpy(mp,tt,sizeof mp);\n            ok=false;\n            break;\n        }\n    }\n    if(ok){\n        dfs(from[tp],sp+1);\n        memcpy(mp,tt,sizeof mp);\n    }\n    dfs(tp+1,sp);\n}\n\nint main(){\n    int i,j,k;\n\n    while(scanf(\"%d\",&n)!=EOF,n){\n//        memset(t,0,sizeof t);\n//        memset(s,0,sizeof s);\n//        memset(from,0,sizeof from);\n//        memset(p,0,sizeof p);\n//        memset(w,0,sizeof w);\n        cnt = 0;\n        for(i=0;i<n;i++){\n            scanf(\"%s\",t[i].q);\n            t[i].len=strlen(t[i].q);\n        }\n        sort(t,t+n);\n\n        getchar();\n        gets(tmp);\n        int now = 0;\n\n        for(i=0;tmp[i];i++){\n            if(tmp[i]=='.'||tmp[i]==' '&&i&&tmp[i-1]!=' '){\n                w[now]=0;\n                strcpy(s[cnt].q,w);\n                s[cnt].len=now;\n                cnt++;\n                now = 0;\n            }else if(tmp[i]!=' '){\n                w[now++]=tmp[i];\n            }\n        }\n\n        sort(s,s+cnt);\n\n        for(i=0;i<n;i++){\n            if(i==0||s[i].len!=s[i-1].len)from[i]=i;\n            else from[i]=from[i-1];\n        }\n\n        memset(mp,-1,sizeof mp);\n\n        ans=0;\n\n        dfs(0,0);\n\n        if(ans!=1){\n            puts(\"-.\");\n        }else{\n            for(i=0;tmp[i];i++){\n                if(tmp[i]>='A'&&tmp[i]<='Z'){\n                    printf(\"%c\",p[tmp[i]-'A']+'A');\n                }else{\n                    printf(\"%c\",tmp[i]);\n                }\n            }\n            puts(\"\");\n        }\n\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int N = 20;\n\nint n, ans;\nstring tmp, ans_rev;\nvector<string> words[N+1], cands[N+1];\nvector<bool> vis[N+1];\n\nbool valid(string &tar, string &s, string &rev) {\n  for(size_t i = 0; i<s.size(); ++i) {\n    if(rev[s[i]] != -1 && rev[s[i]] != tar[i])\n      return false;\n    if(rev[tar[i]] != -1 && rev[tar[i]] != s[i])\n      return false;\n  }\n  return true;\n}\nvoid dfs(int l, size_t x, string &rev) {\n  if(ans > 1)\n    return;\n  while(l && x >= words[l].size()) {\n    x = 0;\n    --l;\n  }\n  if(l == 0) {\n    ans_rev = rev;\n    ++ans;\n    return;\n  }\n  string &tar = words[l][x];\n  for(size_t j = 0; j<cands[l].size(); ++j) {\n    if(vis[l][j])\n      continue;\n    string &s = cands[l][j];\n    if(valid(tar, s, rev)) {\n      string nrev = rev;\n      size_t i = 0;\n      for(; i<s.size(); ++i)\n        if(nrev[s[i]] == -1) {\n          if(nrev[tar[i]] != -1)\n            break;\n          nrev[s[i]] = tar[i];\n          nrev[tar[i]] = s[i];\n        }\n      if(i != s.size())\n        continue;\n      vis[l][j] = true;\n      dfs(l, x+1, nrev);\n      vis[l][j] = false;\n    }\n  }\n}\nvoid cleanup(vector<string> &v) {\n  sort(v.begin(), v.end());\n  v.resize(unique(v.begin(), v.end()) - v.begin());\n}\nvoid init() {\n  for(int i = 0; i<=N; ++i)\n    words[i].clear(), cands[i].clear(), vis[i].clear();\n  ans = 0;\n}\nvoid solve() {\n  init();\n  for(int i = 0; i<n; ++i) {\n    cin >> tmp;\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    cands[tmp.size()].push_back(tmp);\n  }\n  for(int i = 0; i<=N; ++i)\n    vis[i].resize(cands[i].size());\n  vector<string> sent;\n  bool cont = true;\n  while(cont) {\n    cin >> tmp;\n    if(tmp.back() == '.') {\n      tmp.pop_back();\n      cont = false;\n    }\n    sent.push_back(tmp);\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    words[tmp.size()].push_back(tmp);\n  }\n  for(int i = 1; i<=N; ++i)\n    cleanup(words[i]);\n  string rev(26, -1);\n  dfs(N, 0, rev);\n  if(ans == 1) {\n    for(size_t i = 0; i<sent.size(); ++i) {\n      for(auto c : sent[i]) \n        putchar(ans_rev[c - 'A'] == -1 ? c : ans_rev[c - 'A'] + 'A');\n      putchar(i+1 == sent.size() ? '.' : ' ');\n    }\n    puts(\"\");\n  } else\n    puts(\"-.\");\n}\nint main() {\n  while(scanf(\"%d\", &n) == 1 && n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n  \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n  \nusing namespace std;\n  \ntypedef long long ll;\n  \nint n,found,buf_length;\nvector<string> word[30],buf;\nstring sequence;\nchar transfer[26];\nvector<ll> bitmask;\nvector<int> bc;\nset<string> exist;\nchar table[26];\n  \nbool cmp(const string& a,const string& b){ return a.size() > b.size(); }\n  \nvoid dfs(int cur,long long bit){\n  \n  if( found >= 2 ) return;\n  \n  //rep(i,26) cout << table[i] << \" \";\n  //cout << endl;\n  \n  if( cur >= buf_length ){\n    found++;\n    rep(i,26) transfer[i] = table[i];\n    return;\n  }\n  \n  \n  int len = buf[cur].size();\n  \n  if( __builtin_popcountll( bit & bitmask[cur] ) == bc[cur] ) {\n    string tmp = buf[cur];\n    rep(i,len) tmp[i] = table[tmp[i]-'A'];\n    if( exist.find(tmp) != exist.end() ) dfs(cur+1,bit);\n    return;\n  }\n  \n  \n  char tmp_table[26];\n  rep(i,26) tmp_table[i] = table[i];\n  rep(i,word[len].size()){\n    //cout<< endl;\n    //rep(j,26) cout << table[j] << \" \"; cout << endl;\n    // cout << \"word \" << word[len][i] << \" is \";\n    bool error = false;\n    long long new_bit = bit;\n    //rep(j,26) table[j] = tmp_table[j];\n    rep(j,len){\n  \n  \n      if( table[buf[cur][j]-'A'] == '?' && table[word[len][i][j]-'A'] == '?' ) {\n        long long SHIFT = word[len][i][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        SHIFT = buf[cur][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        table[buf[cur][j]-'A']     = word[len][i][j];\n        table[word[len][i][j]-'A'] = buf[cur][j];\n      } else if( !( table[buf[cur][j]-'A'] == word[len][i][j] && table[word[len][i][j]-'A'] == buf[cur][j] ) ) {\n        //cout << \"table[\" << buf[cur][j] << \"] != \" << table[buf[cur][j]-'A'] << \" ?= \" << word[len][i][j] << endl;\n        //cout << \"table[\" << word[len][i][j] << \"] != \" << table[word[len][i][j]-'A'] << \" ?= \" << buf[cur][j] << endl;\n        error = true;\n        break;\n      }\n    }\n  \n    if( error ){\n      //cout << \"bad\" << endl;\n      continue;\n    } //cout << \"ok\" << endl;\n    dfs(cur+1,new_bit);\n    rep(j,len){\n      int idx = buf[cur][j] - 'A';\n      table[idx] = tmp_table[idx];\n      idx = word[len][i][j] - 'A';\n      table[idx] = tmp_table[idx];\n    }\n    if( found >= 2 ) return;\n  }\n}\n  \nint main(){\n  while( cin >> n, n ){\n    string tmp;\n    found = 0;\n    buf.clear(), tmp.clear();\n    rep(i,26)transfer[i] = table[i] = '?';\n    rep(i,30) word[i].clear();\n    rep(i,n){\n      cin >> tmp;\n      word[(int)tmp.size()].push_back(tmp);\n      exist.insert(tmp);\n    }\n    cin.ignore();\n    getline(cin,sequence);\n    tmp = sequence.substr(0,(int)sequence.size()-1);\n    stringstream ss(tmp);\n    while( !( ss >> tmp ).fail() ) buf.push_back(tmp);\n  \n    sort(buf.begin(),buf.end(),cmp);\n    buf.erase(unique(buf.begin(),buf.end()),buf.end());\n    buf_length = (int) buf.size();\n    bitmask.clear(), bc.clear();\n    bitmask.resize(buf_length,0), bc.resize(buf_length);\n    rep(i,buf_length){\n      rep(j,buf[i].size()){\n        long long SHIFT = buf[i][j] - 'A';\n        bitmask[i] |= (1LL<<SHIFT);\n      }\n      bc[i] = __builtin_popcountll(bitmask[i]);\n    }\n  \n    dfs(0,0LL);\n  \n    if( found == 1 ) {\n      rep(i,sequence.size()) cout << (isupper(sequence[i])?transfer[sequence[i]-'A']:sequence[i]);\n      puts(\"\");\n    } else puts(\"-.\");\n  \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 21;\nint N;\nstring word[MAXN];\nstring line;\nvector<string> V;\nvector<int> F;\nmap<char, char> ans;\n\nbool ok(const string &x, const string &w, map<char, char> m) {\n  if(x.size() != w.size()) return false;\n  for(int i = 0; i < x.size(); ++i) {\n    if(m.count(x[i]) && m[x[i]] != w[i]) return false;\n    if(m.count(w[i]) && m[w[i]] != x[i]) return false;\n    m[x[i]] = w[i];\n    m[w[i]] = x[i];\n  }\n  return true;\n}\n\nvoid reg(const string &x, const string &w, map<char, char> &m) {\n  for(int i = 0; i < x.size(); ++i) {\n    m[x[i]] = w[i];\n    m[w[i]] = x[i];\n  }\n}\n\nbool update(int k, map<char, char> m) {\n  F = vector<int>(V.size());\n  for(int i = k; i < V.size(); ++i) {\n    for(int j = 0; j < N; ++j) {\n      if(ok(V[i], word[j], m)) {\n        F[i] |= 1 << j;\n      }\n    }\n    if(!F[i]) return false;\n  }\n  return true;\n}\n\nvoid rec(int k, map<char, char> m) {\n  if(k == V.size()) {\n    if(ans.size()) throw 0;\n    ans = m;\n    return;\n  }\n  for(int i = 0; i < N; ++i) {\n    if(F[k] >> i & 1); else continue;\n    map<char, char> nm = m;\n    reg(V[k], word[i], nm);\n    vector<int> undo = F;\n    if(update(k+1, nm)) {\n      rec(k+1, nm);\n    }\n    F = undo;\n  }\n}\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) {\n      cin >> word[i];\n    }\n    cin.ignore();\n    getline(cin, line);\n    stringstream ss(line.substr(0, line.size()-1));\n    set<string> ws;\n    for(string s; ss >> s; ) ws.insert(s);\n    V.clear();\n    for(set<string>::iterator it = ws.begin();\n        it != ws.end(); ++it) {\n      V.push_back(*it);\n    }\n    update(0, map<char, char>());\n    ans = map<char, char>();\n    try {\n      rec(0, map<char, char>());\n      if(ans.empty()) throw 0;\n      for(int i = 0; i < line.size(); ++i) {\n        if(isalpha(line[i])) cout << ans[line[i]];\n        else cout << line[i];\n      }\n      cout << endl;\n    } catch(...) {\n      cout << \"-.\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <functional>\n#include <queue>\n#include <vector>\n#include <cstdlib>\n#include <string>\n#include <set>\nusing namespace std;\n\n#define PII pair<int,int> \n#define MP make_pair\n#define FI first\n#define SE second\n#define PB push_back\n#define lid (id << 1)\n#define rid (id << 1 | 1)\n#define MID(a, b) ((a + b) >> 1)\n\nconst int N = 110;\nconst int INF = 1000000000;\nconst long long Mod = 1000000007;\n\nvector<string> word[N], s;\nchar str[N], INV[26], ch[N];\nmap<unsigned int, bool> vis[N];\nstring ans;\nint n, find_ans, m, L, len[N];\n\nint cnt = 0;\n\nunsigned int get_hash(){\n    unsigned int ret = 0;\n    for(int i = 0; i < 26; i++){\n        ret = ret * 29 + INV[i] - 'A';\n    }\n    return ret;\n}\n\nvoid dfs(int k){\n    if(find_ans >= 2) return;\n    int hash = get_hash();\n    if(vis[k].find(hash) != vis[k].end()) return;\n    if(k == m){\n        if(find_ans == 1){\n            find_ans = 2;\n            return;\n        }\n        for(int i = 0; i < L; i++){\n            ans += INV[ch[i] - 'A'];\n        }\n        find_ans = 1;\n        return;\n    }\n    if(cnt < 1000000){\n        vis[k][hash] = 1;\n    }\n    else{\n        if(find_ans == 1){\n            find_ans = 3;\n            return;\n        }\n    }\n    string inv = \"\";\n    for(int i = 0; i < 26; i++)\n        inv += INV[i];\n    for(int i = word[len[k]].size() - 1; i >= 0; i--){\n        int no = 0;\n        for(int j = 0; j < 26; j++){\n            INV[j] = inv[j];\n        }\n        for(int j = 0; j < len[k]; j++){\n            if(INV[s[k][j] - 'A'] != '#'){\n                if(INV[s[k][j] - 'A'] != word[len[k]][i][j]){\n                    no = 1; break;\n                }\n            }\n            else{\n                if(s[k][j] != word[len[k]][i][j]){\n                    if(INV[word[len[k]][i][j] - 'A'] != '#'){\n                        no = 1; break;\n                    }\n                    else{\n                        INV[word[len[k]][i][j] - 'A'] = s[k][j];\n                        INV[s[k][j] - 'A'] = word[len[k]][i][j];\n                    }\n                }\n                else{\n                    INV[s[k][j] - 'A'] = s[k][j];\n                }\n            }\n        }\n        if(!no){\n            dfs(k + 1);\n            if(find_ans >= 2) return;\n        }\n    }\n}\n\nbool cmpr(string a, string b){\n    return a.length() > b.length();\n}\n\nvoid solve(){\n    for(int i = 0; i < N; i++){\n        word[i].clear(); vis[i].clear();\n    }\n    s.clear();\n    for(int i = 0; i < n; i++){\n        scanf(\"%s\", str);\n        int len = strlen(str);\n        word[len].push_back(str);\n    }\n    gets(str); gets(str);\n    L = strlen(str);\n    memcpy(ch, str, sizeof(ch));\n    char *temp = strtok(str, \" .\");\n    while(temp != NULL){\n        s.push_back(temp);\n        temp = strtok(NULL, \" .\");\n    }\n    m = s.size();\n    sort(s.begin(), s.end(), cmpr);\n\n    for(int i = 0; i < m; i++){\n        len[i] = s[i].length();\n    }\n\n    for(int i = 0; i < 26; i++){\n        INV[i] = '#';\n    }\n    ans = \"\"; find_ans = 0;\n    dfs(0);\n    if(find_ans == 2){\n        puts(\"-.\");\n    }\n    else{\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    // freopen(\"in.txt\", \"r\", stdin); \n    while(scanf(\"%d\", &n) != EOF){\n        if(n == 0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<char, char> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcountll\n\n#define INF 1e16\n#define mod 1000000007\n\nint n,m;\nstring w[20];\nvector<string> s;\nvector<int> ord;\nint res=0;\nset<P> role[2];\nbool used[26];\nint ccnt[100];\n\nvoid dfs(int i){\n  if(i==m){\n    res++;\n    if(res<2){\n      role[res]=role[res-1];\n    }\n    return ;\n  }\n  int j=ord[i];\n  rep(k,n){\n    if(w[k].size()>s[j].size())break;\n    if(s[j].size()!=w[k].size())continue;\n    bool ok=true;\n    vector<P> add;\n    rep(l,s[j].size()){\n      char c1=s[j][l],c2=w[k][l];\n      if(used[c1-'A']!=used[c2-'A']){\n        ok=false; break;\n      }\n      if(used[c1-'A']&&used[c2-'A']&&role[res].find(P(c1,c2))==role[res].end()){\n        ok=false; break;\n      }\n      if(role[res].find(P(c1,c2))==role[res].end()){\n        role[res].insert(P(c1,c2)); role[res].insert(P(c2,c1));\n        used[c1-'A']=used[c2-'A']=true;\n        add.push_back(P(c1,c2));\n      }\n    }\n    if(!ok){\n      rep(l,add.size()){\n        role[res].erase(P(add[l].fi,add[l].se));\n        role[res].erase(P(add[l].se,add[l].fi));\n        used[add[l].fi-'A']=false; used[add[l].se-'A']=false;\n      }\n      continue;\n    }\n    dfs(i+1);\n    if(res==2)return;\n    rep(l,add.size()){\n      role[res].erase(P(add[l].fi,add[l].se));\n      role[res].erase(P(add[l].se,add[l].fi));\n      used[add[l].fi-'A']=false; used[add[l].se-'A']=false;\n    }\n  }\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    s.clear();\n    m=0; ord.clear();\n    rep(i,n)cin>>w[i];\n    sort(w,w+n,[](const string& a,const string& b){ return a.size() < b.size(); });\n    while(1){\n      ord.push_back(m++);\n      string tmp;\n      cin>>tmp;\n      if(tmp[tmp.size()-1]=='.'){\n        s.push_back(tmp.substr(0,tmp.size()-1));\n        break;\n      }\n      s.push_back(tmp);\n    }\n    rep(i,m){\n      set<char> st;\n      rep(j,s[i].size())st.insert(s[i][j]);\n      ccnt[i]=st.size();\n    }\n    sort(all(ord),[=](const int& a,const int& b){ return ccnt[a] > ccnt[b]; });\n    res=0;\n    rep(i,2)role[i].clear();\n    memset(used,0,sizeof(used));\n    dfs(0);\n    if(res==2)cout<<\"-.\"<<endl;\n    else{\n      string ans=s[0];\n      repl(i,1,m)ans+=\" \"+s[i];\n      ans+=\".\";\n      rep(i,ans.size()){\n        for(P p : role[0]){\n          if(ans[i]==p.fi){\n            ans[i]=p.se;\n            break;\n          }\n        }\n      }\n      cout<<ans<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nchar a[256];\nint ans;\n\nchar m[256];\nint used[256]={0};\n\nvoid search(int n,int now,vector<string> &in,const vector<string> &words){\n  if (n == now){\n    ans++;\n    rep(i,256)a[i]=m[i];\n    return;\n  }\n  if (ans >= 2)return;\n  rep(i,(int)words.size()){\n    string cur = in[now];\n    string tar = words[i];\n    if (tar.size() != cur.size())continue;\n    //check\n    bool isok=true;\n    rep(j,(int)cur.size()){\n      if (used[(int)cur[j]] == -1 && used[(int)tar[j]] == -1){\n\tused[tar[j]]=now;\n\tused[cur[j]]=now;\n\tm[cur[j]]=tar[j];\n\tm[tar[j]]=cur[j];\n      }else if (used[(int)cur[j]] == -1 || used[(int)tar[j]] == -1)isok=false;\n      else if (m[(int)cur[j]] == tar[j] && m[(int)tar[j]] == cur[j]);\n      else isok=false;\n      //cout << j <<\" \" <<cur[j] <<\" \" << tar[j] <<\" \" << used[tar[j]] <<\" \" << used[cur[j]] <<\" \" << isok<< endl;\n    }\n    //search\n    //cout <<\"match \" << cur << \" \" << tar << \" \" << isok << endl;\n    if (isok){\n      search(n,now+1,in,words);\n    }\n    //backtrack\n    rep(j,(int)cur.size()){\n      if (used[cur[j]] == now)used[cur[j]]=-1,used[tar[j]]=-1;\n    }\n  }\n}\n\nbool cmp(const string & a,const string &b){\n  if (a.size() != b.size())return a.size( ) > b.size();\n  return a < b;\n}\n\nint main(){\n  int n;\n  while(cin>>n && n){\n    rep(i,256)used[i]=-1;\n    ans=0;\n\n    vector<string> words(n),inp;\n    rep(i,n)cin>>words[i];\n    sort(words.begin(),words.end(),cmp);\n    words.erase(unique(words.begin(),words.end()),words.end());\n    string in;getline(cin,in);\n    getline(cin,in);\n    string tmp = in;\n    tmp.erase(tmp.begin()+tmp.size()-1);\n    stringstream sin(tmp);\n    while(sin>>tmp)inp.push_back(tmp);\n    sort(inp.begin(),inp.end(),cmp);\n    inp.erase(unique(inp.begin(),inp.end()),inp.end());\n    \n    search(inp.size(),0,inp,words);\n\n    if (ans == 0 || ans == 2)cout <<\"-\" << endl;//\" \" << ans << endl;\n    else {\n      rep(i,in.size()){\n\tif (isalpha(in[i]))cout<<a[in[i]];\n\telse cout << in[i];\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 21;\nint N;\nstring word[MAXN];\nstring line;\nvector<string> V;\nvector<int> F;\nmap<char, char> ans;\n\nbool ok(const string &x, const string &w, map<char, char> m) {\n  if(x.size() != w.size()) return false;\n  for(int i = 0; i < x.size(); ++i) {\n    if(m.count(x[i]) && m[x[i]] != w[i]) return false;\n    if(m.count(w[i]) && m[w[i]] != x[i]) return false;\n    m[x[i]] = w[i];\n    m[w[i]] = x[i];\n  }\n  return true;\n}\n\nvoid reg(const string &x, const string &w, map<char, char> &m) {\n  for(int i = 0; i < x.size(); ++i) {\n    m[x[i]] = w[i];\n    m[w[i]] = x[i];\n  }\n}\n\nbool update(int k, map<char, char> m) {\n  F = vector<int>(V.size());\n  for(int i = k; i < V.size(); ++i) {\n    for(int j = 0; j < N; ++j) {\n      if(ok(V[i], word[j], m)) {\n        F[i] |= 1 << j;\n      }\n    }\n    if(!F[i]) return false;\n  }\n  return true;\n}\n\nvoid rec(int k, map<char, char> m) {\n  if(k == V.size()) {\n    if(ans.size()) throw 0;\n    ans = m;\n    return;\n  }\n  for(int i = 0; i < N; ++i) {\n    if(F[k] >> i & 1); else continue;\n    map<char, char> nm = m;\n    reg(V[k], word[i], nm);\n    vector<int> undo = F;\n    if(update(k+1, nm)) {\n      rec(k+1, nm);\n    }\n    F = undo;\n  }\n}\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) {\n      cin >> word[i];\n    }\n    cin.ignore();\n    getline(cin, line);\n    stringstream ss(line.substr(0, line.size()-1));\n    set<string> ws;\n    for(string s; ss >> s; ) ws.insert(s);\n    V.clear();\n    for(set<string>::iterator it = ws.begin();\n        it != ws.end(); ++it) {\n      V.push_back(*it);\n    }\n    update(0, map<char, char>());\n    ans = map<char, char>();\n    try {\n      rec(0, map<char, char>());\n      if(ans.empty()) throw 0;\n      for(int i = 0; i < line.size(); ++i) {\n        if(isalpha(line[i])) cout << ans[line[i]];\n        else cout << line[i];\n      }\n      cout << endl;\n    } catch(...) {\n      cout << \"-.\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\nint n,found,buf_length;\nvector<string> word[30],buf;\nstring sequence;\nchar transfer[26];\n\nbool cmp(const string& a,const string& b){ return a.size() > b.size(); }\n\nvoid dfs(int cur,vector<char> table){\n\n  if( found >= 2 ) return;\n\n  if( cur >= buf_length ){\n    found++;\n    rep(i,26) transfer[i] = table[i];\n    return;\n  }\n\n  int len = buf[cur].size();\n  rep(i,word[len].size()){\n    vector<char> ntable = table;\n    bool error = false;\n    rep(j,len){\n      if( ntable[buf[cur][j]-'A'] == '?' && ntable[word[len][i][j]-'A'] == '?' ) {\n        ntable[buf[cur][j]-'A']     = word[len][i][j];\n        ntable[word[len][i][j]-'A'] = buf[cur][j];\n      } else if( !( ntable[buf[cur][j]-'A'] == word[len][i][j] && ntable[word[len][i][j]-'A'] == buf[cur][j] ) ) {\n        error = true;\n        break;\n      }\n    }\n    if( error ) continue;\n    dfs(cur+1,ntable);\n    if( found >= 2 ) return;\n  }\n}\n\nint main(){\n  while( cin >> n, n ){\n    string tmp;\n    found = 0;\n    buf.clear();\n    rep(i,26)transfer[i] = '?';\n    rep(i,30) word[i].clear();\n    rep(i,n){\n      cin >> tmp;\n      word[(int)tmp.size()].push_back(tmp);\n    }\n    cin.ignore();\n    getline(cin,sequence);\n    tmp = sequence.substr(0,(int)sequence.size()-1);\n    stringstream ss(tmp);\n    while( !( ss >> tmp ).fail() ) buf.push_back(tmp);\n\n    sort(buf.begin(),buf.end(),cmp);\n    buf.erase(unique(buf.begin(),buf.end()),buf.end());\n    buf_length = (int) buf.size();\n\n    dfs(0,vector<char>(26,'?'));\n\n    if( found == 1 ) {\n      rep(i,sequence.size()) cout << (isupper(sequence[i])?transfer[sequence[i]-'A']:sequence[i]);\n      puts(\"\");\n    } else puts(\"-.\");\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <functional>\n#include <queue>\n#include <vector>\n#include <cstdlib>\n#include <string>\n#include <set>\nusing namespace std;\n\n#define PII pair<int,int> \n#define MP make_pair\n#define FI first\n#define SE second\n#define PB push_back\n#define lid (id << 1)\n#define rid (id << 1 | 1)\n#define MID(a, b) ((a + b) >> 1)\n\nconst int N = 110;\nconst int INF = 1000000000;\nconst long long Mod = 1000000007;\n\nvector<string> word[N], s;\nchar str[N], INV[26], ch[N];\nmap<unsigned int, bool> vis[N];\nstring ans;\nint n, find_ans, m, L, len[N];\n\nint cnt = 0;\n\nunsigned int get_hash(){\n    unsigned int ret = 0;\n    for(int i = 0; i < 26; i++){\n        ret = ret * 29 + INV[i] - 'A';\n    }\n    return ret;\n}\n\nvoid dfs(int k){\n    if(find_ans >= 2) return;\n    int hash = get_hash();\n    if(vis[k].find(hash) != vis[k].end()) return;\n    if(k == m){\n        if(find_ans == 1){\n            find_ans = 2;\n            return;\n        }\n        for(int i = 0; i < L; i++){\n            ans += INV[ch[i] - 'A'];\n        }\n        find_ans = 1;\n        return;\n    }\n    cnt ++;\n    if(cnt < 100000){\n        vis[k][hash] = 1;\n    }\n    else{\n        if(find_ans == 1){\n            find_ans = 3;\n            return;\n        }\n        else{\n            find_ans = 4;\n            return;\n        }\n    }\n    string inv = \"\";\n    for(int i = 0; i < 26; i++)\n        inv += INV[i];\n    for(int i = word[len[k]].size() - 1; i >= 0; i--){\n        int no = 0;\n        for(int j = 0; j < 26; j++){\n            INV[j] = inv[j];\n        }\n        for(int j = 0; j < len[k]; j++){\n            if(INV[s[k][j] - 'A'] != '#'){\n                if(INV[s[k][j] - 'A'] != word[len[k]][i][j]){\n                    no = 1; break;\n                }\n            }\n            else{\n                if(s[k][j] != word[len[k]][i][j]){\n                    if(INV[word[len[k]][i][j] - 'A'] != '#'){\n                        no = 1; break;\n                    }\n                    else{\n                        INV[word[len[k]][i][j] - 'A'] = s[k][j];\n                        INV[s[k][j] - 'A'] = word[len[k]][i][j];\n                    }\n                }\n                else{\n                    INV[s[k][j] - 'A'] = s[k][j];\n                }\n            }\n        }\n        if(!no){\n            dfs(k + 1);\n            if(find_ans >= 2) return;\n        }\n    }\n}\n\nbool cmpr(string a, string b){\n    return a.length() > b.length();\n}\n\nvoid solve(){\n    for(int i = 0; i < N; i++){\n        word[i].clear(); vis[i].clear();\n    }\n    s.clear(); cnt = 0;\n    for(int i = 0; i < n; i++){\n        scanf(\"%s\", str);\n        int len = strlen(str);\n        word[len].push_back(str);\n    }\n    gets(str); gets(str);\n    L = strlen(str);\n    memcpy(ch, str, sizeof(ch));\n    char *temp = strtok(str, \" .\");\n    while(temp != NULL){\n        s.push_back(temp);\n        temp = strtok(NULL, \" .\");\n    }\n\n    sort(s.begin(), s.end());\n    s.erase(unique(s.begin(), s.end()), s.end());\n\n    m = s.size();\n    sort(s.begin(), s.end(), cmpr);\n\n    for(int i = 0; i < m; i++){\n        len[i] = s[i].length();\n    }\n\n    for(int i = 0; i < 26; i++){\n        INV[i] = '#';\n    }\n\n    ans = \"\"; find_ans = 0;\n    dfs(0);\n    if(find_ans == 4){\n        reverse(s.begin(), s.end());\n        for(int i = 0; i < N; i++){\n            vis[i].clear();\n        }\n        find_ans = 0; cnt = 0;\n        dfs(0);\n    }\n    if(find_ans >= 2){\n        puts(\"-.\");\n    }\n    else{\n        cout << ans << endl;\n    }\n}\n\nint main(){\n    // freopen(\"in.txt\", \"r\", stdin); \n    while(scanf(\"%d\", &n) != EOF){\n        if(n == 0) break;\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nvector<string> str[21];\nvector<string> seq;\nvector<char> mp(26);\nint n;\nchar ans[26];\nint ok;\n\nmap<pair<int, vector<char> >, bool> memo;\n\nvoid dfs(int num) {\n  // cout << num << endl;\n  // if (memo[make_pair(num,mp)]) return;\n  // memo[make_pair(num,mp)] = 1;\n  \n  if (num == seq.size()) {\n    ok++;\n    REP(i, 26)\n      ans[i] = mp[i];\n    return;\n  }\n  bool change[26];\n  string s = seq[num];\n  if (ok > 1) return;\n  FOR(it, str[s.size()]) {\n    string t = *it;\n    bool dame = 0;\n    memset(change,0,sizeof(change));\n    REP(i, s.size()) {\n      if (mp[s[i]-'A'] == 0) {\n        if (mp[t[i]-'A']) {\n          dame = 1;\n          break;\n        }\n        mp[s[i]-'A'] = t[i];\n        mp[t[i]-'A'] = s[i];\n        change[s[i]-'A'] = 1;\n        change[t[i]-'A'] = 1;\n      } else if (mp[s[i]-'A'] != t[i]) {\n        dame = 1;\n        break;\n      }\n    }\n    // REP(i, 26) if (mp[i]) printf(\"(%c,%c)\",i+'A', mp[i]);\n    // cout << endl;\n    if (!dame)\n      dfs(num+1);\n    REP(i, 26)\n      if (change[i])\n        mp[i] = 0;\n  }\n}\n\n\nint main() {\n  while(cin>>n,n) {\n    REP(i,21) str[i].clear();\n    REP(i, n) {\n      string tmp;\n      cin >> tmp;\n      str[tmp.size()].push_back(tmp);\n    }\n    seq.clear();\n    string line;\n    cin.ignore();\n    getline(cin,line);\n//    cout << \"line : \" << line << endl;\n    stringstream sin(line);\n    string tmp;\n    while(sin>>tmp, tmp[tmp.size()-1] != '.') seq.push_back(tmp);\n    seq.push_back(tmp.substr(0, tmp.size()-1));\n\n    vector<pair<int, string> > v;\n    vector<int> num(21);\n    FOR(it, seq)\n      num[it->size()]++;\n    FOR(it, seq) v.push_back(make_pair(num[it->size()], *it));\n    sort(ALL(v));\n    seq.clear();\n    FOR(it, v) {\n      seq.push_back(it->second);\n//      cout << it->second << endl;\n    }\n\n    mp = vector<char>(26);\n    memo.clear();\n    //cout << line << endl;\n    ok = 0;\n    dfs(0);\n    if (ok == 1) {\n      REP(i, line.size()) {\n        if (line[i] == ' ' || line[i] == '.') cout << line[i];\n        else cout << ans[line[i]-'A'];\n      }\n      cout << endl;\n    } else {\n      cout << \"-.\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nstring str[20];\nvector<string> seq;\nchar mp[26];\nint n;\nchar ans[26];\nint ok;\n\nvoid dfs(int num) {\n  if (num == seq.size()) {\n    ok++;\n    REP(i, 26)\n      ans[i] = mp[i];\n    return;\n  }\n  string s = seq[num];\n\n  REP(j, n) {\n    if (str[j].size() != s.size()) continue;\n    vector<bool> change(26);\n    bool dame = 0;\n    REP(i, s.size()) {\n      if (mp[s[i]-'A'] == 0) {\n        if (mp[str[j][i]]) {\n          dame = 1;\n          break;\n        }\n        mp[s[i]-'A'] = str[j][i];\n        mp[str[j][i]-'A'] = s[i];\n        //cout << str[j][i] << \": \" << endl;\n        change[s[i]-'A'] = 1;\n        change[str[j][i]-'A'] = 1;\n      } else if (mp[s[i]-'A'] != str[j][i]) {\n        dame = 1;\n        break;\n      }\n    }\n    if (!dame)\n      dfs(num+1);\n    REP(i, 26)\n      if (change[i])\n        mp[i] = 0;\n  }\n}\n\n\nint main() {\n  while(cin>>n,n) {\n    REP(i, n) cin>>str[i];\n    seq.clear();\n    string line;\n    cin.ignore();\n    getline(cin,line);\n    stringstream sin(line);\n    string tmp;\n    while(sin>>tmp, tmp[tmp.size()-1] != '.') seq.push_back(tmp);\n    seq.push_back(tmp.substr(0, tmp.size()-1));\n\n    vector<pair<int, string> > v;\n    vector<int> num(21);\n    FOR(it, seq)\n      num[it->size()]++;\n    FOR(it, seq) v.push_back(make_pair(num[it->size()], *it));\n    sort(ALL(v));\n    seq.clear();\n    FOR(it, v) {\n      seq.push_back(it->second);\n//      cout << it->second << endl;\n    }\n    \n    memset(mp,0,sizeof(mp));\n    //cout << line << endl;\n    ok = 0;\n    dfs(0);\n    if (ok == 1) {\n      REP(i, line.size()) {\n        if (line[i] == ' ' || line[i] == '.') cout << line[i];\n        else cout << ans[line[i]-'A'];\n      }\n      cout << endl;\n    } else {\n      cout << \"-.\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nchar str[21][30];\nchar s[100][30];\nchar ori[100][30];\nchar tmp[21];\nint len[100];\nint len1[30];\nint n,m;\nbool has=true;\nbool mul=false;\nvector<char>ans;\nvector<int>ids[100];\nvoid dfs(int u,const vector<char> & t){\n\tif(has&&mul)return;\n\tif(u==m){\n\t\tans=t;\n\t\tif(!has)has=true;\n\t\telse mul=true;\n\t\treturn;\n\t}\n\tfor(int k=0;k<ids[u].size();k++){\n\t\tint i=ids[u][k];\n\t\tif(len1[i]!=len[u])continue;\n\t\tvector<char> nt = t;\n\t\tbool pass=true;\n\t\tfor(int j=0;j<len[u];j++){\n\t\t\tif(nt[s[u][j]]!=-1&&nt[s[u][j]]!=str[i][j]||nt[str[i][j]]!=-1&&nt[str[i][j]]!=s[u][j]){\n\t\t\t\tpass=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnt[s[u][j]]=str[i][j];\n\t\t\tnt[str[i][j]]=s[u][j];\n\t\t}\n\t\tif(pass){\n\t\t\tdfs(u+1,nt);\n\t\t}\n\t}\n}\nbool flag[100];\nint main(){\n\twhile(~scanf(\"%d\",&n)&&n){\n\t\thas=false;\n\t\tmul=false;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%s\",str[i]);\n\t\t}\n\t\tm=0;\n\t\twhile(scanf(\"%s\",s[m++])!=EOF){\n\t\t\tif(s[m-1][strlen(s[m-1])-1]=='.'){\n\t\t\t\ts[m-1][strlen(s[m-1])-1]='\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tflag[i]=false;\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(strcmp(str[i],str[j])==0)flag[i]=true;\n\t\t\t}\n\t\t}\n\t\tint c=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(!flag[i]){\n\t\t\t\tstrcpy(str[c++],str[i]);\n\t\t\t}\n\t\t}\n\t\tn=c;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tflag[i]=false;\n\t\t\tfor(int j=i+1;j<m;j++){\n\t\t\t\tif(strcmp(s[i],s[j])==0)flag[i]=true;\n\t\t\t}\n\t\t}\n\t\tc=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(!flag[i]){\n\t\t\t\tstrcpy(s[c++],s[i]);\n\t\t\t}\n\t\t}\n\t\tm=c;\n\t\tfor(int i=0;i<m;i++)strcpy(ori[i],s[i]);\n\t\tfor(int i=0;i<n;i++)len1[i]=strlen(str[i]);\n\t\tfor(int i=0;i<m;i++)len[i]=strlen(s[i]);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<m-1;j++){\n\t\t\t\tif(len[j]<len[j+1]){\n\t\t\t\t\tstrcpy(tmp,s[j]);\n\t\t\t\t\tstrcpy(s[j],s[j+1]);\n\t\t\t\t\tstrcpy(s[j+1],tmp);\n\t\t\t\t\tswap(len[j],len[j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n-1;j++){\n\t\t\t\tif(len1[j]<len1[j+1]){\n\t\t\t\t\tstrcpy(tmp,str[j]);\n\t\t\t\t\tstrcpy(str[j],str[j+1]);\n\t\t\t\t\tstrcpy(str[j+1],tmp);\n\t\t\t\t\tswap(len1[j],len1[j+1]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tids[i].clear();\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(len[i]==len1[j]){\n\t\t\t\t\tids[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(ids[i].size()==0){\n\t\t\t\thas=true;\n\t\t\t\tmul=true;\n\t\t\t}\n\t\t}\n\t\tvector<char>t;\n\t\tfor(int i=0;i<256;i++)t.push_back(-1);\n\t\tdfs(0,t);\n\t\tif(has&&!mul){\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint l=strlen(ori[i]);\n\t\t\t\tfor(int j=0;j<l;j++){\n\t\t\t\t\tprintf(\"%c\",ans[ori[i][j]]);\n\t\t\t\t}\n\t\t\t\tif(i!=m-1)printf(\" \");\n\t\t\t\telse printf(\".\\n\");\n\t\t\t}\n\t\t}else{\n\t\t\tprintf(\"-.\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n#include <string>\n#include <map>\n#include <set>\n#include <sstream>\n\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n\nstruct String {\n  string s;\n  String() {;}\n  String(string s) : s(s) {;}\n  int CalcKind() const {\n    int exist[300];\n    MEMSET(exist, 0);\n    FORIT(it, s) { exist[(int)*it] = 1; }\n    int ret = 0;\n    REP(i, 300) { ret += exist[i]; }\n    return ret;\n  }\n  bool operator<(const String &rhs) const {\n    if (CalcKind() != rhs.CalcKind()) { return CalcKind() > rhs.CalcKind(); }\n    return s < rhs.s;\n  }\n};\n\nint cnt;\nint n;\nint perm[200];\nchar word[30][100];\nchar str[1000];\nchar ans[1000];\nvector<String> strs;\n\nint calc(int depth) {\n  if (depth == (int)strs.size()) {\n    int len = strlen(str);\n    REP(i, len) {\n      assert(str[i] != -1);\n      ans[i] = perm[(int)str[i]];\n    }\n    ans[len] = 0;\n    cnt++;\n    return cnt;\n  }\n  const string s = strs[depth].s;\n  REP(i, n) {\n    if (strlen(word[i]) != s.size()) { continue; }\n    int pperm[200];\n    memcpy(pperm, perm, sizeof(perm));\n    REP(j, s.size()) {\n      int l = s[j];\n      int r = word[i][j];\n      if (perm[l] == r && perm[r] == l) {\n        ;\n      } else if (perm[l] == -1 && perm[r] == -1) {\n        perm[l] = r;\n        perm[r] = l;\n      } else {\n        goto next;\n      }\n    }\n    calc(depth + 1);\n    if (cnt >= 2) { return cnt; }\nnext:;\n     memcpy(perm, pperm, sizeof(perm));\n  }\n  return cnt;\n}\n\nint main() {\n  while (scanf(\"%d\", &n), n) {\n    cnt = 0;\n    strs.clear();\n    MEMSET(perm, -1);\n    MEMSET(word, 0);\n    perm[' '] = ' ';\n    perm['.'] = '.';\n    REP(i, n) {\n      scanf(\"%s\", word[i]);\n      REP(j, i) {\n        if (strcmp(word[i], word[j]) == 0) { i--; n--; break; }\n      }\n    }\n    fgets(str, 999, stdin);\n    fgets(str, 999, stdin);\n    str[strlen(str) - 1] = 0;\n    memcpy(ans, str, sizeof(ans));\n    {\n      stringstream sin(str);\n      string s;\n      while (sin >> s) {\n        if (*s.rbegin() == '.') { s = s.substr(0, s.size() - 1); }\n        strs.push_back(String(s));\n      }\n      sort(strs.begin(), strs.end());\n    }\n    if (calc(0) == 1) {\n      printf(\"%s\\n\", ans);\n    } else {\n      printf(\"-.\\n\");\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n\nusing namespace std;\n\n\n\nvector<string> v;\nvector<string> vv;\nset<string> vvv[21];\n\n\nvector<string> s[21];\n\nchar r[256];\nchar ans[256];\nint n,cnt;\n\n\nvoid dfs(int d){\n\n\n  if(d==vv.size()){\n    cnt++;\n    for(int i='A';i<='Z';i++)ans[i]=r[i];\n    return;\n  }\n\n  int sz=vv[d].size();\n\n  char tmp[26];\n\n  for(int i='A';i<='Z';i++)tmp[i-'A']=r[i];\n  \n  for(int i=0;i<s[sz].size();i++){\n    bool f=1;\n    \n    for(int j=0;j<s[sz][i].size();j++){\n\n      if(r[s[sz][i][j]]!=0 && r[vv[d][j]] !=0 ){\n\tif(vv[d][j]!=r[s[sz][i][j]] || r[vv[d][j]]!=s[sz][i][j]) f=0;\n      }\n      else if(r[s[sz][i][j]]==0 && r[vv[d][j]]==0) r[vv[d][j]]=s[sz][i][j], r[s[sz][i][j]]=vv[d][j];\n      else f=0;\n    }\n    \n    if(f&&cnt<=1)dfs(d+1);\n    \n\n    for(int i='A';i<='Z';i++)r[i]=tmp[i-'A'];\n    \n  }\n}\n\n\nint main(){\n\n  while(cin>>n,n){\n    string str;\n    v.clear();\n    vv.clear();\n    for(int i=0;i<21;i++)s[i].clear(),vvv[i].clear();\n\n    for(int i='A';i<='Z';i++)r[i]=0;\n\n    cnt=0;\n    \n    for(int i=0;i<n;i++){\n      cin>>str;\n      s[str.size()].push_back(str);\n    }\n    \n    bool f=1;\n    \n    while(cin>>str){\n      \n      if(str[str.size()-1]=='.'){\n\tstr=str.substr(0,str.size()-1);\n\tf=0;\n      }\n      v.push_back(str);\n      vvv[str.size()].insert(str);\n      if(!f) break;\n    }\n\n    vv=v;\n    for(int i=1;i<vv.size();i++)\n      for(int j=i;j>0;j--){\n\tif(vv[j-1].size()<vv[j].size())\n\t  swap(vv[j],vv[j-1]);\n      }\n    \n    for(int i=0;i<=20;i++)\n      if(vvv[i].size()>s[i].size())cnt=2;\n    \n    if(!cnt)dfs(0);\n    \n    if(cnt==1){\n\n      for(int i=0;i<v.size();i++){\n\tfor(int j=0;j<v[i].size();j++){\n\t  if(ans[v[i][j]]==0)cout<<v[i][j];\n\t  else cout<<(char)ans[v[i][j]];\n\t}\n\tif(i!=v.size()-1)cout<<\" \";\n      }\n    }\n\n    else cout<<\"-\";\n\n    cout<<\".\"<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n\nusing namespace std;\n\n\n\nvector<string> v;\nvector<string> vv;\nvector<string> vvv[21];\n\n\nvector<string> s[21];\n\nchar r[256];\nchar ans[256];\nint n,cnt;\n\n\nvoid dfs(int d){\n\n\n  if(d==vv.size()){\n    cnt++;\n    for(int i='A';i<='Z';i++)ans[i]=r[i];\n    return;\n  }\n\n  int sz=vv[d].size();\n\n  char tmp[26];\n\n  for(int i='A';i<='Z';i++)tmp[i-'A']=r[i];\n  \n  for(int i=0;i<s[sz].size();i++){\n    bool f=1;\n    \n    for(int j=0;j<s[sz][i].size();j++){\n\n      if(r[s[sz][i][j]]!=0 && r[vv[d][j]] !=0 ){\n\tif(vv[d][j]!=r[s[sz][i][j]] || r[vv[d][j]]!=s[sz][i][j]) f=0;\n      }\n      else if(r[s[sz][i][j]]==0 && r[vv[d][j]]==0) r[vv[d][j]]=s[sz][i][j], r[s[sz][i][j]]=vv[d][j];\n      else f=0;\n    }\n    \n    if(f&&cnt<=1)dfs(d+1);\n    \n\n    for(int i='A';i<='Z';i++)r[i]=tmp[i-'A'];\n    \n  }\n}\n\n\nint main(){\n\n  while(cin>>n,n){\n    string str;\n    v.clear();\n    vv.clear();\n    for(int i=0;i<21;i++)s[i].clear();\n\n    for(int i='A';i<='Z';i++)r[i]=0;\n\n    cnt=0;\n    \n    for(int i=0;i<n;i++){\n      cin>>str;\n      s[str.size()].push_back(str);\n    }\n    \n    bool f=1;\n    \n    while(cin>>str){\n      \n      if(str[str.size()-1]=='.'){\n\tstr=str.substr(0,str.size()-1);\n\tf=0;\n      }\n      v.push_back(str);\n      vvv[str.size()].push_back(str);\n      if(!f) break;\n    }\n\n    vv=v;\n    for(int i=1;i<vv.size();i++)\n      for(int j=i;j>0;j--){\n\tif(vv[j-1].size()<vv[j].size())\n\t  swap(vv[j],vv[j-1]);\n      }\n    for(int i=0;i<=20;i++)\n      if(vvv[i].size()>s[i].size())cnt=2;\n    if(!cnt)dfs(0);\n    \n    if(cnt==1){\n\n      for(int i=0;i<v.size();i++){\n\tfor(int j=0;j<v[i].size();j++){\n\t  if(ans[v[i][j]]==0)cout<<v[i][j];\n\t  else cout<<(char)ans[v[i][j]];\n\t}\n\tif(i!=v.size()-1)cout<<\" \";\n      }\n    }\n\n    else cout<<\"-\";\n\n    cout<<\".\"<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define INF 120000000\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef long long int LL;\n\nbool noflg = true;\nvector<char> res;\n\nvector<string> explode(string &s, char delim = ' ') {\n    vector<string> ret;\n    string tmp = \"\";\n    for (int i = 0; i <= s.size(); i++) {\n        if (s[i] == delim || i == s.size()) {\n            ret.pb(tmp);\n            tmp = \"\";\n        } else {\n            tmp += s[i];\n        }\n    }\n    return ret;\n}\n\nvoid dfs(int idx, const vector<vector<string>> &words, const vector<string> &div, vector<char> enc) {\n    if (idx == div.size()) {\n        if (noflg) {\n            noflg = false;\n            res.clear();\n            copy(enc.begin(), enc.end(), back_inserter(res));\n        } else {\n            noflg = true;\n        }\n        return;\n    }\n    string d = div[idx];\n\n    for (string w : words[d.size()]) {\n        // cout << \"d = \" << d << \" testing \" << w << \" \" << endl;\n        vector<char> tmp;\n        copy(enc.begin(), enc.end(), back_inserter(tmp));\n\n        // for (int i = 0; i < tmp.size(); i++) {\n        //     cout << tmp[i] << \" \";\n        // }\n        // cout << endl;\n\n        for (int i = 0; i < w.size(); i++) {\n            if (tmp[d[i] - 'A'] == '0' && tmp[w[i] - 'A'] == '0') {\n                // cout << d[i] << \" \" << w[i] << endl;\n                tmp[d[i] - 'A'] = w[i];\n                tmp[w[i] - 'A'] = d[i];\n            } else if (tmp[d[i] - 'A'] != w[i] || tmp[w[i] - 'A'] != d[i]) {\n                // cout << \"FALSE at \" << i << endl;\n                goto lbl;\n            }\n        }\n        // cout << \"OK\" << endl;\n        dfs(idx + 1, words, div, tmp);\n\n        lbl:;\n    }\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        noflg = true;\n        vector<vector<string>> words(21);\n\n        for (int i = 0; i < n; i++) {\n            string tmp;\n            cin >> tmp;\n            words[tmp.size()].pb(tmp);\n        }\n\n        string seq;\n        vector<string> div;\n        getline(cin, seq);\n        getline(cin, seq);\n        seq = seq.substr(0, seq.size() - 1);\n        div = explode(seq);\n        sort(div.begin(), div.end(),\n            [](const string &a, const string &b){ return a.size() > b.size(); });\n\n        vector<char> enc('Z' - 'A' + 1, '0');\n        dfs(0, words, div, enc);\n\n        if (noflg) {cout << \"-.\" << endl; continue;}\n        for (int i = 0; i < seq.size(); i++) {\n            if (seq[i] != ' ' && res[seq[i] - 'A'] != '0') seq[i] = res[seq[i] - 'A'];\n        }\n\n        cout << seq << \".\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cstring>\n#include <sstream>\nusing namespace std;\n\nint n, m;\nstring cand[22];\nvector<string> words;\n\nvector<int> match[82];\nint matchBit[82];\n\nvector<char> ansKey;\nint ansFlg;\n\nbool matches(string a, string b){\n  if(a.size() != b.size()) return false;\n  char trans[128];\n  memset(trans, -1, sizeof(trans));\n  for(int i = 0; i < a.size(); i++){\n    if(trans[a[i]] != -1 && b[i] != trans[a[i]]) return false;\n    if(trans[b[i]] != -1 && a[i] != trans[b[i]]) return false;\n    trans[a[i]] = b[i];\n    trans[b[i]] = a[i];\n  }\n  return true;\n}\n\nbool mycmp(const string &a, const string &b){\n  set<char> st1;\n  for(int i = 0; i < a.size(); i++) st1.insert(a[i]);\n  set<char> st2;\n  for(int i = 0; i < b.size(); i++) st2.insert(b[i]);\n\n  return st1.size() > st2.size();\n}\n\nbool setKey(const string &a, const string &b, vector<char> &key){\n  for(int i = 0; i < a.size(); i++){\n    if(key[a[i]] != -1 && key[a[i]] != b[i]){\n      return false;\n    }\n    key[a[i]] = b[i];\n    key[b[i]] = a[i];\n  }\n  return true;\n}\n\nvoid dfs(int idx, int used, vector<char> key){\n  if(idx == m){\n    if(ansFlg == 1){\n      ansFlg = -1;\n    }\n    else{\n      ansFlg = 1;\n      ansKey = key;\n    }\n    return;\n  }\n\n  for(int i = 0; i < match[idx].size(); i++){\n    int j = match[idx][i];\n    if(used & (1 << j)) continue;\n\n    vector<char> nextKey = key;\n    if(setKey(words[idx], cand[j], nextKey)){\n      dfs(idx + 1, used | (1 << j), nextKey);\n      if(ansFlg == -1) return;\n    }\n  }\n}\n\nvoid solve(){\n  sort(words.begin(), words.end(), mycmp);\n\n  for(int i = 0; i < m; i++){\n    match[i].clear();\n    matchBit[i] = 0;\n\n    for(int j = 0; j < n; j++){\n      if(matches(words[i], cand[j])){\n        match[i].push_back(j);\n        matchBit[i] |= (1 << j);\n      }\n    }\n  }\n\n  vector<char> key(128, -1);\n  ansFlg = 0;\n  dfs(0, 0, key);\n}\n\nint main(){\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++){\n      cin >> cand[i];\n\n      for(int j = 0; j < i; j++){\n        if(cand[j] == cand[i]){\n          i--;\n          n--;\n          break;\n        }\n      }\n    }\n\n    string s;\n    getline(cin, s);\n    getline(cin, s);\n\n    string ts;\n    stringstream ss(s);\n    words.clear();\n\n    while(ss >> ts){\n      string pushStr = \"\";\n      for(int i = 0; i < ts.size(); i++){\n        if(ts[i] == '.') continue;\n        pushStr += ts[i];\n      }\n      bool pushFlg = true;\n      for(int i = 0; i < words.size(); i++){\n        if(words[i] == pushStr){\n          pushFlg = false;\n          break;\n        }\n      }\n      if(pushFlg) words.push_back(pushStr);\n    }\n    m = words.size();\n\n    solve();\n\n    if(ansFlg == 1){\n      for(int i = 0; i < s.size(); i++){\n        if(s[i] == ' ' || s[i] == '.') cout << s[i];\n        else                           cout << ansKey[s[i]];\n      }\n      if(s[s.size() - 1] != '.') cout << \".\";\n      cout << endl;\n    }\n    else{\n      cout << \"-.\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n \nusing namespace std;\n \ntypedef long long ll;\n \nint n,found,buf_length;\nvector<string> word[30],buf;\nstring sequence;\nchar transfer[26];\nvector<ll> bitmask;\nvector<int> bc;\nset<string> exist;\nchar table[26];\nbool depth[26];\n \nbool cmp(const string& a,const string& b){ return a.size() > b.size(); }\n \nvoid dfs(int cur,long long bit,int dph){\n \n  if( found >= 2 ) return;\n \n  if( cur >= buf_length ){\n    found++;\n    rep(i,26) transfer[i] = table[i];\n    return;\n  }\n \n  int len = buf[cur].size();\n \n  if( __builtin_popcountll( bit & bitmask[cur] ) == bc[cur] ) {\n    string tmp = buf[cur];\n    rep(i,len) tmp[i] = table[tmp[i]-'A'];\n    if( exist.find(tmp) != exist.end() ) dfs(cur+1,bit,dph+1);\n    return;\n  }\n \n  rep(i,word[len].size()){\n    bool error = false;\n    long long new_bit = bit;\n    int ep = len;\n    rep(j,len){\n      if( table[buf[cur][j]-'A'] == '?' && table[word[len][i][j]-'A'] == '?' ) {\n        long long SHIFT = word[len][i][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        SHIFT = buf[cur][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        table[buf[cur][j]-'A']     = word[len][i][j];\n        table[word[len][i][j]-'A'] = buf[cur][j];\n        depth[buf[cur][j]-'A'] = dph;\n        depth[word[len][i][j]-'A'] = dph;\n      } else if( !( table[buf[cur][j]-'A'] == word[len][i][j] && table[word[len][i][j]-'A'] == buf[cur][j] ) ) {\n        error = true;\n        ep = j+1;\n        break;\n      }\n    }\n \n    if( !error ) dfs(cur+1,new_bit,dph+1);\n    rep(j,ep){\n      int idx = buf[cur][j] - 'A';\n      int idx2 = word[len][i][j] - 'A';\n      if( depth[idx] == dph && depth[idx2] == dph ){\n        //table[idx] = tmp_table[idx];\n        //table[idx] = tmp_table[idx];\n        table[idx] = table[idx2] = '?';\n      }\n    }\n    if( found >= 2 ) return;\n  }\n}\n \nint main(){\n  while( cin >> n, n ){\n    string tmp;\n    found = 0;\n    buf.clear(), tmp.clear();\n    rep(i,26)transfer[i] = table[i] = '?';\n    rep(i,30) word[i].clear();\n    rep(i,n){\n      cin >> tmp;\n      word[(int)tmp.size()].push_back(tmp);\n      exist.insert(tmp);\n    }\n    cin.ignore();\n    getline(cin,sequence);\n    tmp = sequence.substr(0,(int)sequence.size()-1);\n    stringstream ss(tmp);\n    while( !( ss >> tmp ).fail() ) buf.push_back(tmp);\n \n    sort(buf.begin(),buf.end(),cmp);\n    buf.erase(unique(buf.begin(),buf.end()),buf.end());\n    buf_length = (int) buf.size();\n    bitmask.clear(), bc.clear();\n    bitmask.resize(buf_length,0), bc.resize(buf_length);\n    rep(i,buf_length){\n      rep(j,buf[i].size()){\n        long long SHIFT = buf[i][j] - 'A';\n        bitmask[i] |= (1LL<<SHIFT);\n      }\n      bc[i] = __builtin_popcountll(bitmask[i]);\n    }\n \n    dfs(0,0LL,0);\n \n    if( found == 1 ) {\n      rep(i,sequence.size()) cout << (isupper(sequence[i])?transfer[sequence[i]-'A']:sequence[i]);\n      puts(\"\");\n    } else puts(\"-.\");\n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nchar a[256];\nint ans;\n\nchar m[256];\nint used[256]={0};\n\nvoid search(int n,int now,vector<string> &in,const vector<string> &words){\n  if (n == now){\n    ans++;\n    rep(i,256)a[i]=m[i];\n    return;\n  }\n  if (ans >= 2)return;\n  rep(i,(int)words.size()){\n    string cur = in[now];\n    string tar = words[i];\n    if (tar.size() != cur.size())continue;\n    //check\n    bool isok=true;\n    rep(j,(int)cur.size()){\n      if (used[(int)cur[j]] == -1 && used[(int)tar[j]] == -1){\n\tused[(int)tar[j]]=now;\n\tused[(int)cur[j]]=now;\n\tm[(int)cur[j]]=tar[j];\n\tm[(int)tar[j]]=cur[j];\n      }else if (used[(int)cur[j]] == -1 || used[(int)tar[j]] == -1)isok=false;\n      else if (m[(int)cur[j]] == tar[j] && m[(int)tar[j]] == cur[j]);\n      else isok=false;\n      //cout << j <<\" \" <<cur[j] <<\" \" << tar[j] <<\" \" << used[tar[j]] <<\" \" << used[cur[j]] <<\" \" << isok<< endl;\n    }\n    //search\n    //cout <<\"match \" << cur << \" \" << tar << \" \" << isok << endl;\n    if (isok){\n      search(n,now+1,in,words);\n    }\n    //backtrack\n    rep(j,(int)cur.size()){\n      if (used[(int)cur[j]] == now && used[tar[j]] == now){\n\tused[(int)cur[j]]=-1,used[(int)tar[j]]=-1;\n      }\n    }\n  }\n}\n\nbool cmp(const string & a,const string &b){\n  if (a.size() != b.size())return a.size( ) > b.size();\n  return a < b;\n}\n\nint main(){\n  int n;\n  while(cin>>n && n){\n    rep(i,256)used[i]=-1;\n    ans=0;\n\n    vector<string> words(n),inp;\n    rep(i,n)cin>>words[i];\n    sort(words.begin(),words.end(),cmp);\n    words.erase(unique(words.begin(),words.end()),words.end());\n    string in;getline(cin,in);\n    getline(cin,in);\n    string tmp = in;\n    rep(i,tmp.size())if (tmp[i] == '.')tmp[i]=' ';\n    stringstream sin(tmp);\n    while(sin>>tmp)inp.push_back(tmp);\n    sort(inp.begin(),inp.end(),cmp);\n    inp.erase(unique(inp.begin(),inp.end()),inp.end());\n    \n    search(inp.size(),0,inp,words);\n\n    if (ans != 1)cout <<\"-\" << endl;//\" \" << ans << endl;\n    else {\n      rep(i,in.size()){\n\tif (isupper(in[i]))cout<<a[in[i]];\n\telse cout << in[i];\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nstring t[100];\nbool used[100];\nvector<string> v;\nmap< char , char > mp;\ntypedef pair< char , char > P;\n\nbool check( vector<int> a, string b , vector<int> c, string d ){\n  int size=a.size();\n  map< char , set<int> > T;\n\n  for(int i=0;i<size;i++){\n    if(a[i]==-1)continue;\n    T[ b[i] ].insert( d[i] );\n    T[ d[i] ].insert( b[i] );\n    if( T[ b[i] ].size() > 1 )return false;\n    if( T[ d[i] ].size() > 1 )return false;\n  }\n  return true;\n}\n\nstring Replace(string s,bool flag=false){\n  for(int i=0;i<(int)s.size();i++){\n    if(mp.count(s[i]))s[i]=mp[s[i]];\n    else{\n      if(flag)s[i]='?';\n    }\n  }\n  return s;\n}\n\nvector<int> change(string s){\n  vector<int> res(s.size());\n  map<char,int> flg;\n  for(int i=0;i<(int)s.size();i++){\n    if(mp.count(s[i])){\n      res[i]=-1;\n      continue;\n    }\n    if( flg.count(s[i]) ){\n      res[i]=flg[ s[i] ];\n    }else{\n      res[i]=flg.size();\n      flg[ s[i] ]=res[i];\n    }\n  }\n  return res;\n}\n\nvoid Add(string s,string t){\n  for(int i=0;i<(int)s.size();i++){\n    mp[ s[i] ] = t[i];\n    mp[ t[i] ] = s[i];\n  }\n}\n\nbool solve(){\n  set< int > pa;\n  bool update=true;\n  while(update){\n    update=false;\n    vector<int> cnt( v.size(), 0 );\n    \n    for(int i=0;i<n;i++){\n      string str=Replace(t[i],true);\n      vector<int> hashv=change(t[i]);\n      vector<int> target;\n      set< string > st;\n      for(int j=0;j<(int)v.size();j++){\n        if( pa.count(j) )continue;\n        \n        string tmp=Replace(Replace(v[j],true));\n        vector<int> hashw=change(v[j]);\n        if(str==tmp && hashv == hashw && check(hashv,t[i],hashw,v[j])){\n          cnt[j]++;\n        }\n      }\n    }\n\n\n    bool loopf=false;\n    for(int i=0;i<n;i++){\n      \n      string str=Replace(t[i],true);\n      vector<int> hashv=change(t[i]);\n      \n      for(int j=0;j<(int)v.size();j++){\n        string tmp=Replace(Replace(v[j],true));\n        vector<int> hashw=change(v[j]);\n        \n        if(str==tmp && hashv == hashw && cnt[j]==1 && check(hashv,t[i],hashw,v[j])){\n          pa.insert(j);\n          Add(t[i],v[j]);\n          loopf=true;\n          update=true;\n          break;\n        }\n      }\n\n      if(loopf)break;\n    }\n    \n\n  }// while update\n\n  if(pa.size()!=v.size())return false;\n  return true;\n}\n\nvoid init(){\n  v.clear();\n  mp.clear();\n  memset(used,false,sizeof(used));\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++)cin>>t[i];\n    string tmp,str;\n    getline(cin,tmp);\n    getline(cin,tmp);\n    stringstream ss(tmp);\n    while(ss>>str){\n      if( str.back() == '.' )str.pop_back();\n      v.push_back(str);\n    }\n    if( solve() ){\n      for(int i=0;i<(int)v.size();i++){\n        if(i)cout<<' ';\n        cout<<Replace(v[i]);\n      }\n      cout<<'.'<<endl;\n    }else{\n      cout<<\"-.\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nvector<string> split_sentence(string s){\n  vector<string> res;\n  REP(i, s.size()) if(s[i] == '.') s[i] = ' ';\n  stringstream ss(s);\n  string t;\n  while(ss >> t){ res.push_back(t); }\n  return res;\n}\n\nbool comp(string s, string t){\n  if(s.size() != t.size()) return s.size() > t.size();\n  return s > t;\n}\n\nclass DFSError{};\n\nbool answer_exist;\nstring answer;\nint mem[80];\nint match[26];\nstring sentence;\nvector<string> words;\nvector<string> ciphers;\nvoid dfs(int k){\n  if(k == ciphers.size()){\n    if(answer_exist) throw DFSError();\n    answer_exist = true;\n    answer = sentence;\n    REP(i, answer.size()) if(isupper(answer[i])) answer[i] = match[answer[i] - 'A'] + 'A';\n  }else{\n    string& cipher = ciphers[k];\n    int save_match[26];\n    memcpy(save_match, match, sizeof match);\n    REP(i, words.size()) if(words[i].size() == cipher.size()){\n      string& word = words[i];\n\n      bool ok = true;\n      REP(j, word.size()){\n        int A = word[j] - 'A';\n        int B = cipher[j] - 'A';\n        if(match[A] == -1 && match[B] == -1){\n          match[A] = B;\n          match[B] = A;\n        }else if(match[A] == B && match[B] == A){\n        }else{\n          //printf(\"match[%c] = %c, match[%c] = %c\\n\", A + 'A', match[A] + 'A', B + 'A', match[B] + 'A');\n          ok = false;\n          break;\n        }\n      }\n\n      if(ok){\n        mem[k] = i;\n        dfs(k + 1);\n      }\n\n      memcpy(match, save_match, sizeof match);\n    }\n  }\n}\n\nint main(){\n  int N;\n  while(cin >> N && N){\n    words.assign(N, \"\");\n    REP(i, N) cin >> words[i];\n    cin.ignore();\n\n    getline(cin, sentence);\n    ciphers = split_sentence(sentence);\n\n    sort(words.begin(), words.end());\n    words.erase(unique(words.begin(), words.end()), words.end());\n    sort(ciphers.begin(), ciphers.end(), comp);\n    ciphers.erase(unique(ciphers.begin(), ciphers.end()), ciphers.end());\n\n    try{\n      answer_exist = false;\n      memset(match, -1, sizeof match);\n      dfs(0);\n      assert(answer_exist);\n      cout << answer << endl;\n    }catch(DFSError e){\n      cout << \"-.\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int N = 20;\n\nint n, ans;\nstring tmp, ans_rev;\nvector<string> words[N+1], cands[N+1];\n\ninline bool valid(string &tar, string &s, string &rev) {\n  for(size_t i = 0; i<s.size(); ++i) {\n    if(rev[s[i]] != -1 && rev[s[i]] != tar[i])\n      return false;\n    if(rev[tar[i]] != -1 && rev[tar[i]] != s[i])\n      return false;\n  }\n  return true;\n}\nvoid dfs(int l, size_t x, string &rev) {\n  if(ans > 1)\n    return;\n  while(l && x >= words[l].size()) {\n    x = 0;\n    --l;\n  }\n  if(l == 0) {\n    ans_rev = rev;\n    ++ans;\n    return;\n  }\n  string &tar = words[l][x];\n  for(size_t j = 0; j<cands[l].size(); ++j) {\n    string &s = cands[l][j];\n    if(valid(tar, s, rev)) {\n      string nrev = rev;\n      size_t i = 0;\n      for(; i<s.size(); ++i)\n        if(nrev[s[i]] == -1) {\n          if(nrev[tar[i]] != -1)\n            break;\n          nrev[s[i]] = tar[i];\n          nrev[tar[i]] = s[i];\n        }\n      if(i != s.size())\n        continue;\n      dfs(l, x+1, nrev);\n    }\n  }\n}\nvoid cleanup(vector<string>& v) {\n  sort(v.begin(), v.end());\n  v.resize(unique(v.begin(), v.end()) - v.begin());\n}\nvoid init() {\n  for(int i = 0; i<=N; ++i)\n    words[i].clear(), cands[i].clear();\n  ans = 0;\n}\nvoid solve() {\n  init();\n  for(int i = 0; i<n; ++i) {\n    cin >> tmp;\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    cands[tmp.size()].push_back(tmp);\n  }\n  vector<string> sent;\n  bool cont = true;\n  while(cont) {\n    cin >> tmp;\n    if(tmp.back() == '.') {\n      tmp.pop_back();\n      cont = false;\n    }\n    sent.push_back(tmp);\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    words[tmp.size()].push_back(tmp);\n  }\n  for(int i = 1; i<=N; ++i)\n    cleanup(words[i]);\n  string rev(26, -1);\n  dfs(N, 0, rev);\n  if(ans == 1) {\n    for(size_t i = 0; i<sent.size(); ++i) {\n      for(auto c : sent[i]) \n        putchar(ans_rev[c - 'A'] == -1 ? c : ans_rev[c - 'A'] + 'A');\n      putchar(i+1 == sent.size() ? '.' : ' ');\n    }\n    puts(\"\");\n  } else\n    puts(\"-.\");\n}\nint main() {\n  while(scanf(\"%d\", &n) == 1 && n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint n;\nstring sq;\nvector<string> a[21];\nvector<string> b[21];\nset<string> S;\nbool a_used[500];\nbool b_used[500];\n\nvoid init(){\n\tsq.clear();\n\tS.clear();\n\tfor(int i=0 ; i < 21 ; i++ ){\n\t\ta[i].clear();\n\t\tb[i].clear();\n\t}\n\tfor(int i=0 ; i < 500 ; i++ ){\n\t\ta_used[i] = b_used[i] = false;\n\t}\n}\n\nbool check(const string& s, const string& t, const vector<char>& h){\n\tif( s.size() != t.size() ) return false;\n\t\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\t/*if( !((h[s[i]] == -1 || h[s[i]] == t[i] ) && (h[t[i]] == -1 || h[t[i]] == s[i]) ) ){\n\t\t\treturn false;\n\t\t}*/\n\t\tif( h[s[i]] != -1 ){\n\t\t\tif( h[h[s[i]]] != -1 && h[s[i]] != h[h[s[i]]] ) return false;\n\t\t\tif( h[t[i]] != -1 && h[s[i]] != h[t[i]] ) return false;\n\t\t}\n\t\tif( h[t[i]] != -1 ){\n\t\t\tif( h[h[t[i]]] != -1 && h[t[i]] != h[h[t[i]]] ) return false;\n\t\t\tif( h[s[i]] != -1 && h[s[i]] != h[t[i]] ) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid solve(vector<char>& h, int x, int& z){\n\tz++;\n\tif( z >= 1e+5 ) return;\n\tif( S.size() >= 2 ) return;\n\t\n\tbool flag = true;\n\tfor(int i=0 ; i < sq.size() ; i++ ){\n\t\tif( sq[i] == ' ' || sq[i] == '.' ) continue;\n\t\tif( h[sq[i]] == -1 ){\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif( flag ){\n\t\tstring str;\n\t\tfor(int i=0 ; i < sq.size() ; i++ ){\n\t\t\tif( sq[i] == ' ' || sq[i] == '.' ){\n\t\t\t\tstr.push_back( sq[i] );\n\t\t\t}else{\n\t\t\t\tstr.push_back( h[sq[i]] );\n\t\t\t}\n\t\t}\n\t\tS.insert( str );\n\t}\n\tif( S.size() >= 2 ) return;\n\t\n\tfor(int k=x ; k > 0 ; k-- ){\n\t\tif( a[k].empty() || b[k].empty() ) continue;\n\t\t\n\t\tfor(int i=0 ; i < a[k].size() ; i++ ){\n\t\t\tif( a_used[(i+1)*(k+1)] ) continue;\n\t\t\t\n\t\t\tfor(int j=0 ; j < b[k].size() ; j++ ){\n\t\t\t\tif( b_used[(j+1)*(k+1)] ) continue;\n\t\t\t\t\n\t\t\t\tstring s = a[k][i], t = b[k][j];\n\t\t\t\t\n\t\t\t\t/*bool f = check(s,t,h);\n\t\t\t\tif( f ){\n\t\t\t\t\tvector<char> h_ = h;\n\t\t\t\t\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\t\t\t\t\th_[s[i]] = t[i];\n\t\t\t\t\t\th_[t[i]] = s[i];\n\t\t\t\t\t}\n\t\t\t\t\tsolve(h_);\n\t\t\t\t\treturn;\n\t\t\t\t}*/\n\t\t\t\tvector<char> h_ = h;\n\t\t\t\tbool f = true;\n\t\t\t\tfor(int l=0 ; l < s.size() ; l++ ){\n\t\t\t\t\tif( h_[s[l]] == -1 || h_[s[l]] == t[l] ){\n\t\t\t\t\t\th_[s[l]] = t[l];\n\t\t\t\t\t\tif( h_[t[l]] == -1 || h_[t[l]] == s[l] ){\n\t\t\t\t\t\t\th_[t[l]] = s[l];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*cout << s << \" <=> \" << t << (f? \" OK\" : \" NG\") << endl;\n\t\t\t\tbool cc[256] = {false};\n\t\t\t\tfor(char c='A' ; c <= 'Z' ; c++ ){\n\t\t\t\t\tif( h_[c] != -1 && !cc[c] ){\n\t\t\t\t\t\tcc[c] = cc[h_[c]] = true;\n\t\t\t\t\t\tcout << c << \":\" << h_[c] << \", \";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << endl << endl;*/\n\t\t\t\t\n\t\t\t\tif( f ){\n\t\t\t\t\ta_used[(i+1)*(k+1)] = b_used[(j+1)*(k+1)] = true;\n\t\t\t\t\tsolve(h_,k,z);\n\t\t\t\t\ta_used[(i+1)*(k+1)] = b_used[(j+1)*(k+1)] = false;\n\t\t\t\t\t//return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i=0 ; i < a[k].size() ; i++ ){\n\t\t\tif( a_used[(i+1)*(k+1)] ) cnt++;\n\t\t}\n\t\tif( cnt != a[k].size() ) return;\n\t}\n}\n\nint main(){\n\twhile( cin >> n , n ){\n\t\tinit();\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\ta[s.size()].push_back(s);\n\t\t}\n\t\twhile( true ){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tif( s[s.size()-1] == '.' ){\n\t\t\t\tsq += s;\n\t\t\t\tb[s.size()-1].push_back( s.substr(0,s.size()-1) );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsq += s + \" \";\n\t\t\tb[s.size()].push_back( s );\n\t\t}\n\t\tvector<char> h(256);\n\t\tfor(char c='A' ; c <= 'Z' ; c++ ) h[c] = -1;\n\t\tint z=0;\n\t\tsolve(h,20,z);\n\t\t\n\t\t//cout << sq << endl;\n\t\tif( S.size() == 1 ){\n\t\t\tcout << *S.begin() << endl;\n\t\t}else{\n\t\t\tcout << \"-.\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint N;\nstring sentence;\nstring words[20];\nchar pairs[256];\nvector<string> ans;\nstring replace(string s){\n  REP(i, s.size())if(isalpha(s[i])) s[i] = pairs[s[i]];\n  return s;\n}\nvoid dfs(int k, vector<string>& targets){\n  if(k == targets.size()) {\n    ans.push_back(replace(sentence));\n    return;\n  }\n  string target = targets[k];\n  int tmppairs[256];\n  REP(i, 256) tmppairs[i] = pairs[i];\n  REP(i, N)if(words[i].size() == target.size()){\n    string word = words[i];\n    bool ok = true;\n    REP(j, word.size())if(pairs[word[j]] != -1 && pairs[word[j]] != target[j]) ok = false;\n    if(!ok) continue;\n    REP(j, word.size()){\n      pairs[word[j]] = target[j];\n      pairs[target[j]] = word[j];\n    }\n    REP(j, word.size())if(pairs[word[j]] != -1 && pairs[word[j]] != target[j]) ok = false;\n    if(!ok) continue;\n    dfs(k + 1, targets);\n    REP(i, 256) pairs[i] = tmppairs[i];\n  }\n}\n\nint main(){\n  while(cin>>N && N){\n    memset(pairs, -1, sizeof(pairs));\n    ans.clear();\n    REP(i, N) cin>>words[i];\n    cin.ignore();\n    getline(cin, sentence);\n    vector<string> targets;\n    stringstream ss(sentence);\n    for(string tmp;;){\n      if(!(ss>>tmp)) break;\n      if(tmp[tmp.size()-1] == '.') tmp = tmp.substr(0, tmp.size() - 1);\n      targets.push_back(tmp);\n    }\n    REP(i, targets.size())FOR(j, i+1, targets.size()) if(targets[i].size() < targets[j].size()) swap(targets[i], targets[j]);\n    dfs(0, targets);\n    if(ans.size() == 1) cout<<ans[0]<<endl;\n    else cout<<\"-.\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Weaker then Planned\n//Level:\n//Category:\n//Note:\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <array>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define TIMES(i,n) for(int i = 0; i < (n); ++i)\n\ninline int popcount(unsigned x) {\n    x = (x & 0x55555555U) + ((x & 0xaaaaaaaaU) >> 1);\n    x = (x & 0x33333333U) + ((x & 0xccccccccU) >> 2);\n    x = (x & 0x0f0f0f0fU) + ((x & 0xf0f0f0f0U) >> 4);\n    x = (x & 0x00ff00ffU) + ((x & 0xff00ff00U) >> 8);\n    x = (x & 0x0000ffffU) + ((x & 0xffff0000U) >> 16);\n    return x;\n}\n\narray<char,256> table, ans;\nbool found = false;\n\nbool check(const vector<pair<string,int>> &words, const set<pair<string,int>> &crypted) {\n    for(const auto &w : crypted) {\n        string s = w.first;\n        for(char &c : s) {\n            c = table[c];\n        }\n        if(find_if(words.begin(), words.end(), [&s](const pair<string,int> &ww){return ww.first == s;}) == words.end()) return false;\n    }\n    return true;\n}\n\nbool search(const vector<pair<string,int>> &words, const set<pair<string,int>> &crypted, int known_pat) {\n    string w = \"\";\n    int max_unknown = 0;\n    int mask = 0;\n    for(const auto &s : crypted) {\n        int unknown = popcount(s.second & ~known_pat);\n        if(unknown > max_unknown) {\n            w = s.first;\n            max_unknown = unknown;\n            mask = s.second & ~known_pat;\n        }\n    }\n    if(max_unknown == 0) {\n        if(!check(words, crypted)) return false;\n        if(found) throw \"ambiguous\";\n        found = true;\n        ans = table;\n        return true;\n    }\n    for(const auto &word : words) {\n        //cout << known_pat << ' ' << w << ' ' << word << endl;\n        if(word.first.size() != w.size()) continue;\n        TIMES(i, word.first.size()) {\n            const char cch = w[i];\n            const char wch = word.first[i];\n            if(table[cch] != 0 && table[cch] != wch) {\n                //cout << cch << ' ' << table[cch] << endl;\n                goto next;\n            }\n            if(table[wch] != 0 && table[wch] != cch) {\n                goto next;\n            }\n            table[cch] = wch;\n            table[wch] = cch;\n        }\n        //cout << \"ok\" << endl;\n        search(words, crypted, known_pat | mask | word.second);\nnext:\n        TIMES(i, word.first.size()) {\n            const char cch = w[i];\n            const char wch = word.first[i];\n            if(mask & (1<<(cch-'A'))) {\n                //cout << known_pat << \" clear \" << cch << endl;\n                table[cch] = table[wch] = 0;\n            }\n        }\n    }\n    return false;\n}\n\nbool solve() {\n    int N;\n    cin >> N;\n    if(!N) return false;\n\n    vector<pair<string,int>> words(N);\n    TIMES(i, N) {\n        string str;\n        cin >> str;\n        int mask = 0;\n        for(char c : str) {\n            mask |= 1<<(c-'A');\n        }\n        words[i] = make_pair(str, mask);\n    }\n    vector<string> seq;\n    while(true) {\n        string w;\n        cin >> w;\n        if(w[w.size()-1] == '.') {\n            seq.push_back(w.substr(0, w.size()-1));\n            break;\n        } else {\n            seq.push_back(w);\n        }\n    }\n\n    set<pair<string,int>> crypted;\n    for(const string &s : seq) {\n        int mask = 0;\n        for(char c : s) {\n            mask |= (1<<(c-'A'));\n        }\n        crypted.insert(make_pair(s, mask));\n    }\n\n    fill(table.begin(), table.end(), 0);\n    found = false;\n    try {\n        search(words, crypted, 0);\n    } catch(const char *s) {\n        found = false;\n    }\n    if(found) {\n        bool first = true;\n        for(const string &s : seq) {\n            if(!first) cout << ' ';\n            for(char c : s) {\n                cout << ans[c];\n            }\n            first = false;\n        }\n        cout << '.' << endl;\n    } else {\n        cout << \"-.\" << endl;\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n,found,buf_length;\nvector<string> word[30],buf;\nstring sequence;\nchar transfer[26];\nvector<ll> bitmask;\nvector<int> bc;\nset<string> exist;\nchar table[26];\n\nbool cmp(const string& a,const string& b){ return a.size() > b.size(); }\n\nvoid dfs(int cur,long long bit){\n\n  if( found >= 2 ) return;\n\n  //rep(i,26) cout << table[i] << \" \";\n  //cout << endl;\n\n  if( cur >= buf_length ){\n    found++;\n    rep(i,26) transfer[i] = table[i];\n    return;\n  }\n\n\n  int len = buf[cur].size();\n  /*\n  if( __builtin_popcountll( bit & bitmask[cur] ) == bc[cur] ) {\n    string tmp = buf[cur];\n    rep(i,len) tmp[i] = table[tmp[i]-'A'];\n    if( exist.find(tmp) != exist.end() ) dfs(cur+1,bit);\n    return;\n  }\n  */\n\n  char tmp_table[26];\n  rep(i,26) tmp_table[i] = table[i];\n  rep(i,word[len].size()){\n    //cout<< endl;\n    //rep(j,26) cout << table[j] << \" \"; cout << endl; \n    // cout << \"word \" << word[len][i] << \" is \";\n    bool error = false;\n    long long new_bit = bit;\n    rep(j,26) table[j] = tmp_table[j];\n    rep(j,len){\n\n\n      if( table[buf[cur][j]-'A'] == '?' && table[word[len][i][j]-'A'] == '?' ) {\n        long long SHIFT = word[len][i][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        SHIFT = buf[cur][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        table[buf[cur][j]-'A']     = word[len][i][j];\n        table[word[len][i][j]-'A'] = buf[cur][j];\n      } else if( !( table[buf[cur][j]-'A'] == word[len][i][j] && table[word[len][i][j]-'A'] == buf[cur][j] ) ) {\n        //cout << \"table[\" << buf[cur][j] << \"] != \" << table[buf[cur][j]-'A'] << \" ?= \" << word[len][i][j] << endl;\n        //cout << \"table[\" << word[len][i][j] << \"] != \" << table[word[len][i][j]-'A'] << \" ?= \" << buf[cur][j] << endl;\n        error = true;\n        break;\n      }\n    }\n\n    if( error ){\n      //cout << \"bad\" << endl;\n      continue;\n    } //cout << \"ok\" << endl;\n    dfs(cur+1,new_bit);\n    if( found >= 2 ) {\n      rep(j,26) table[j] = tmp_table[j];\n      return;\n    }\n  }\n}\n\nint main(){\n  while( cin >> n, n ){\n    string tmp;\n    found = 0;\n    buf.clear(), tmp.clear();\n    rep(i,26)transfer[i] = table[i] = '?';\n    rep(i,30) word[i].clear();\n    rep(i,n){\n      cin >> tmp;\n      word[(int)tmp.size()].push_back(tmp);\n      exist.insert(tmp);\n    }\n    cin.ignore();\n    getline(cin,sequence);\n    tmp = sequence.substr(0,(int)sequence.size()-1);\n    stringstream ss(tmp);\n    while( !( ss >> tmp ).fail() ) buf.push_back(tmp);\n\n    sort(buf.begin(),buf.end(),cmp);\n    buf.erase(unique(buf.begin(),buf.end()),buf.end());\n    buf_length = (int) buf.size();\n    bitmask.clear(), bc.clear();\n    bitmask.resize(buf_length,0), bc.resize(buf_length);\n    rep(i,buf_length){\n      rep(j,buf[i].size()){\n        long long SHIFT = buf[i][j] - 'A';\n        bitmask[i] |= (1LL<<SHIFT);\n      }\n      bc[i] = __builtin_popcountll(bitmask[i]);\n    }\n\n    dfs(0,0LL);\n\n    if( found == 1 ) {\n      rep(i,sequence.size()) cout << (isupper(sequence[i])?transfer[sequence[i]-'A']:sequence[i]);\n      puts(\"\");\n    } else puts(\"-.\");\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n,found,buf_length;\nvector<string> word[30],buf;\nstring sequence;\nchar transfer[26];\nvector<ll> bitmask;\nvector<int> bc;\nset<string> exist;\nchar table[26];\n\nbool cmp(const string& a,const string& b){ return a.size() > b.size(); }\n\nvoid dfs(int cur,long long bit){\n\n  if( found >= 2 ) return;\n\n  //rep(i,26) cout << table[i] << \" \";\n  //cout << endl;\n\n  if( cur >= buf_length ){\n    found++;\n    rep(i,26) transfer[i] = table[i];\n    return;\n  }\n\n\n  int len = buf[cur].size();\n  if( __builtin_popcountll( bit & bitmask[cur] ) == bc[cur] ) {\n    string tmp = buf[cur];\n    rep(i,len) tmp[i] = table[tmp[i]-'A'];\n    if( exist.find(tmp) != exist.end() ) dfs(cur+1,bit);\n    return;\n  }\n\n  char tmp_table[26];\n  rep(i,26) tmp_table[i] = table[i];\n  rep(i,word[len].size()){\n    //cout<< endl;\n    //rep(j,26) cout << table[j] << \" \"; cout << endl; \n    // cout << \"word \" << word[len][i] << \" is \";\n    bool error = false;\n    long long new_bit = bit;\n    rep(j,26) table[j] = tmp_table[j];\n    rep(j,len){\n\n\n      if( table[buf[cur][j]-'A'] == '?' && table[word[len][i][j]-'A'] == '?' ) {\n        long long SHIFT = word[len][i][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        SHIFT = buf[cur][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        table[buf[cur][j]-'A']     = word[len][i][j];\n        table[word[len][i][j]-'A'] = buf[cur][j];\n      } else if( !( table[buf[cur][j]-'A'] == word[len][i][j] && table[word[len][i][j]-'A'] == buf[cur][j] ) ) {\n        //cout << \"table[\" << buf[cur][j] << \"] != \" << table[buf[cur][j]-'A'] << \" ?= \" << word[len][i][j] << endl;\n        //cout << \"table[\" << word[len][i][j] << \"] != \" << table[word[len][i][j]-'A'] << \" ?= \" << buf[cur][j] << endl;\n        error = true;\n        break;\n      }\n    }\n\n    if( error ){\n      //cout << \"bad\" << endl;\n      continue;\n    } //cout << \"ok\" << endl;\n    dfs(cur+1,new_bit);\n    if( found >= 2 ) {\n      rep(j,26) table[j] = tmp_table[j];\n      return;\n    }\n  }\n}\n\nint main(){\n  while( cin >> n, n ){\n    string tmp;\n    found = 0;\n    buf.clear(), tmp.clear();\n    rep(i,26)transfer[i] = table[i] = '?';\n    rep(i,30) word[i].clear();\n    rep(i,n){\n      cin >> tmp;\n      word[(int)tmp.size()].push_back(tmp);\n      exist.insert(tmp);\n    }\n    cin.ignore();\n    getline(cin,sequence);\n    tmp = sequence.substr(0,(int)sequence.size()-1);\n    stringstream ss(tmp);\n    while( !( ss >> tmp ).fail() ) buf.push_back(tmp);\n\n    sort(buf.begin(),buf.end(),cmp);\n    buf.erase(unique(buf.begin(),buf.end()),buf.end());\n    buf_length = (int) buf.size();\n    bitmask.clear(), bc.clear();\n    bitmask.resize(buf_length,0), bc.resize(buf_length);\n    rep(i,buf_length){\n      rep(j,buf[i].size()){\n        long long SHIFT = buf[i][j] - 'A';\n        bitmask[i] |= (1LL<<SHIFT);\n      }\n      bc[i] = __builtin_popcountll(bitmask[i]);\n    }\n\n    dfs(0,0LL);\n\n    if( found == 1 ) {\n      rep(i,sequence.size()) cout << (isupper(sequence[i])?transfer[sequence[i]-'A']:sequence[i]);\n      puts(\"\");\n    } else puts(\"-.\");\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint N;\nstring sentence;\nstring words[20];\nchar pairs[26];\nset<string> ans;\nset< vector<char> > memo[100];\nstring replace(string s){\n  REP(i, s.size())if(isalpha(s[i])) s[i] = pairs[s[i]-'A'];\n  return s;\n}\nvoid dfs(int k, vector<string>& targets){\n  if(ans.size() >= 2) return;\n  //if(memo[k].count(pairs)) return;\n  //memo[k].insert(pairs);\n  if(k == targets.size()) {\n    ans.insert(replace(sentence));\n    return;\n  }\n\n  string& target = targets[k];\n  char tmppairs[26];\n  memcpy(tmppairs, pairs, sizeof tmppairs);\n  REP(i, N)if(words[i].size() == target.size()){\n    string& word = words[i];\n\n    bool ok = true;\n    REP(j, word.size())if(pairs[word[j]-'A'] != 0 && pairs[word[j]-'A'] != target[j]) ok = false;\n    if(!ok) continue;\n\n    REP(j, word.size()){\n      pairs[word[j]-'A'] = target[j];\n      pairs[target[j]-'A'] = word[j];\n    }\n\n    REP(i, 26)if(pairs[i] != 0 && pairs[pairs[i]-'A'] != i + 'A') ok = false;\n    REP(j, word.size())if(pairs[target[j] - 'A'] != 0 && pairs[target[j] - 'A'] != word[j]) ok = false;\n    if(!ok) continue;\n\n    dfs(k + 1, targets);\n\n    memcpy(pairs, tmppairs, sizeof pairs);\n  }\n}\n\nint main(){\n  while(cin>>N && N){\n    //initialize\n    REP(i, 26) pairs[i] = 0;\n    ans.clear();\n\n    //input\n    REP(i, N) cin>>words[i];\n    cin.ignore();\n    getline(cin, sentence);\n    vector<string> targets;\n    stringstream ss(sentence);\n    for(string tmp;;){\n      if(!(ss>>tmp)) break;\n      if(tmp[tmp.size()-1] == '.') tmp = tmp.substr(0, tmp.size() - 1);\n      targets.push_back(tmp);\n    }\n    // sort by length of string\n    REP(i, targets.size())FOR(j, i+1, targets.size()) if(targets[i].size() < targets[j].size()) swap(targets[i], targets[j]);\n\n    dfs(0, targets);\n\n    if(ans.size() == 1) cout<<*ans.begin()<<endl;\n    else cout<<\"-.\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Weaker then Planned\n//Level:\n//Category:\n//Note:\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <array>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define TIMES(i,n) for(int i = 0; i < (n); ++i)\n\ninline int popcount(unsigned x) {\n    x = (x & 0x55555555U) + ((x & 0xaaaaaaaaU) >> 1);\n    x = (x & 0x33333333U) + ((x & 0xccccccccU) >> 2);\n    x = (x & 0x0f0f0f0fU) + ((x & 0xf0f0f0f0U) >> 4);\n    x = (x & 0x00ff00ffU) + ((x & 0xff00ff00U) >> 8);\n    x = (x & 0x0000ffffU) + ((x & 0xffff0000U) >> 16);\n    return x;\n}\n\narray<char,256> table, ans;\nbool found = false;\n\nbool search(const vector<pair<string,int>> &words, const set<pair<string,int>> &crypted, int known_pat) {\n    string w = \"\";\n    int max_unknown = 0;\n    int mask = 0;\n    for(const auto &s : crypted) {\n        int unknown = popcount(s.second & ~known_pat);\n        if(unknown > max_unknown) {\n            w = s.first;\n            max_unknown = unknown;\n            mask = s.second & ~known_pat;\n        }\n    }\n    if(max_unknown == 0) {\n        if(found) throw \"ambiguous\";\n        found = true;\n        ans = table;\n        return true;\n    }\n    for(const auto &word : words) {\n        //cout << known_pat << ' ' << w << ' ' << word << endl;\n        if(word.first.size() != w.size()) continue;\n        TIMES(i, word.first.size()) {\n            const char cch = w[i];\n            const char wch = word.first[i];\n            if(table[cch] != 0 && table[cch] != wch) {\n                //cout << cch << ' ' << table[cch] << endl;\n                goto next;\n            }\n            if(table[wch] != 0 && table[wch] != cch) {\n                goto next;\n            }\n            table[cch] = wch;\n            table[wch] = cch;\n        }\n        //cout << \"ok\" << endl;\n        search(words, crypted, known_pat | mask | word.second);\nnext:\n        TIMES(i, word.first.size()) {\n            const char cch = w[i];\n            const char wch = word.first[i];\n            if(mask & (1<<(cch-'A'))) {\n                //cout << known_pat << \" clear \" << cch << endl;\n                table[cch] = table[wch] = 0;\n            }\n        }\n    }\n    return false;\n}\n\nbool solve() {\n    int N;\n    cin >> N;\n    if(!N) return false;\n\n    vector<pair<string,int>> words(N);\n    TIMES(i, N) {\n        string str;\n        cin >> str;\n        int mask = 0;\n        for(char c : str) {\n            mask |= 1<<(c-'A');\n        }\n        words[i] = make_pair(str, mask);\n    }\n    vector<string> seq;\n    while(true) {\n        string w;\n        cin >> w;\n        if(w[w.size()-1] == '.') {\n            seq.push_back(w.substr(0, w.size()-1));\n            break;\n        } else {\n            seq.push_back(w);\n        }\n    }\n\n    set<pair<string,int>> crypted;\n    for(const string &s : seq) {\n        int mask = 0;\n        for(char c : s) {\n            mask |= (1<<(c-'A'));\n        }\n        crypted.insert(make_pair(s, mask));\n    }\n\n    fill(table.begin(), table.end(), 0);\n    found = false;\n    try {\n        search(words, crypted, 0);\n    } catch(const char *s) {\n        found = false;\n    }\n    if(found) {\n        bool first = true;\n        for(const string &s : seq) {\n            if(!first) cout << ' ';\n            for(char c : s) {\n                cout << ans[c];\n            }\n            first = false;\n        }\n        cout << '.' << endl;\n    } else {\n        cout << \"-.\" << endl;\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int N = 20;\n\nint n, ans;\nstring tmp, ans_rev;\nvector<string> words[N+1], cands[N+1];\n//vector<bool> vis[N+1];\n\nbool valid(string &tar, string &s, string &rev) {\n  for(size_t i = 0; i<s.size(); ++i) {\n    if(rev[s[i]] != -1 && rev[s[i]] != tar[i])\n      return false;\n    if(rev[tar[i]] != -1 && rev[tar[i]] != s[i])\n      return false;\n  }\n  return true;\n}\nvoid dfs(int l, size_t x, string &rev) {\n  if(ans > 1)\n    return;\n  while(l && x >= words[l].size()) {\n    x = 0;\n    --l;\n  }\n  if(l == 0) {\n    ans_rev = rev;\n    ++ans;\n    return;\n  }\n  string &tar = words[l][x];\n  for(size_t j = 0; j<cands[l].size(); ++j) {\n    //if(vis[l][j])\n    //  continue;\n    string &s = cands[l][j];\n    if(valid(tar, s, rev)) {\n      string nrev = rev;\n      size_t i = 0;\n      for(; i<s.size(); ++i)\n        if(nrev[s[i]] == -1) {\n          if(nrev[tar[i]] != -1)\n            break;\n          nrev[s[i]] = tar[i];\n          nrev[tar[i]] = s[i];\n        }\n      if(i != s.size())\n        continue;\n      //vis[l][j] = true;\n      dfs(l, x+1, nrev);\n      //vis[l][j] = false;\n    }\n  }\n}\nvoid cleanup(vector<string> &v) {\n  sort(v.begin(), v.end());\n  v.resize(unique(v.begin(), v.end()) - v.begin());\n}\nvoid init() {\n  for(int i = 0; i<=N; ++i)\n    words[i].clear(), cands[i].clear();//, vis[i].clear();\n  ans = 0;\n}\nvoid solve() {\n  init();\n  for(int i = 0; i<n; ++i) {\n    cin >> tmp;\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    cands[tmp.size()].push_back(tmp);\n  }\n  //for(int i = 0; i<=N; ++i)\n  //  vis[i].resize(cands[i].size());\n  vector<string> sent;\n  bool cont = true;\n  while(cont) {\n    cin >> tmp;\n    if(tmp.back() == '.') {\n      tmp.pop_back();\n      cont = false;\n    }\n    sent.push_back(tmp);\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    words[tmp.size()].push_back(tmp);\n  }\n  for(int i = 0; i<=N; ++i)\n    cleanup(words[i]);\n  string rev(26, -1);\n  dfs(N, 0, rev);\n  if(ans == 1) {\n    for(auto c : ans_rev)\n      assert(ans_rev[c] = ans_rev[ans_rev[c]]);\n    for(size_t i = 0; i<sent.size(); ++i) {\n      for(auto c : sent[i]) \n        putchar(ans_rev[c - 'A'] == -1 ? c : ans_rev[c - 'A'] + 'A');\n      putchar(i+1 == sent.size() ? '.' : ' ');\n    }\n    puts(\"\");\n  } else\n    puts(\"-.\");\n}\nint main() {\n  while(scanf(\"%d\", &n) == 1 && n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\nint ord(char c){\n  return c-'A';\n}\n\nvector<pair<char,char> > rec(vector<string> seq,vector<string> word,vector<pair<char,char> > rules,int u){\n  if(seq.empty())return rules;\n  int mx=-1,x;\n  for(int i=0;i<seq.size();i++){\n    int t=u;\n    int cu=0;\n    for(auto e:seq[i]){\n      int xx=e-'A';\n      if(!(t>>xx&1)){\n\tcu++;\n\tt|=1<<xx;\n      }\n    }\n    if(cu>mx){\n      mx=cu;\n      x=i;\n    }\n  }\n  vector<pair<char,char> > res;\n  for(int j=0;j<word.size();j++){\n    auto e=word[j];\n    if(seq[x].size()!=e.size())continue;\n    vector<pair<char,char> > nr=rules;\n    int nu=u;\n    for(int i=0;i<e.size();i++){\n      int sr=nu>>ord(seq[x][i])&1;\n      int wr=nu>>ord(e[i])&1;\n      if(sr^wr)goto next;\n      if(!sr){\n\tnu|=1<<ord(seq[x][i])|1<<ord(e[i]);\n\tchar l=seq[x][i],h=e[i];\n\tif(h<l){\n\t  swap(l,h);\n\t}\n\tnr.emplace_back(l,h);\n      }else{\n\tchar l=min(seq[x][i],e[i]);\n\tchar h=max(seq[x][i],e[i]);\n\tif(find(begin(nr),end(nr),make_pair(l,h))==end(nr))goto next;\n      }\n    }\n    {\n      vector<string> nseq(begin(seq),begin(seq)+x),nword(begin(word),begin(word)+j);\n      nseq.insert(end(nseq),begin(seq)+x+1,end(seq));\n      nword.insert(end(nword),begin(word)+j+1,end(word));\n      auto r=rec(nseq,nword,nr,nu);\n      if(!res.empty()&&!r.empty())throw 0;\n      res=r;\n    }\n  next:\n    ;\n  }\n  return res;\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    vector<string> word(n);\n    for(int i=0;i<n;i++){\n      cin>>word[i];\n    }\n    vector<string> seq;\n    for(string s;;){\n      cin>>s;\n      if(s.back()!='.'){\n\tseq.push_back(s);\n      }else{\n\tseq.push_back(s.substr(0,s.size()-1));\n\tbreak;\n      }\n    }\n    vector<string> useq=seq,uword=word;\n    sort(begin(useq),end(useq));\n    sort(begin(uword),end(uword));\n    useq.erase(unique(begin(useq),end(useq)),end(useq));\n    uword.erase(unique(begin(uword),end(uword)),end(uword));\n    try{\n      auto r=rec(useq,word,{},0);\n      char table[256];\n      for(auto e:r){\n\ttable[e.first]=e.second;\n\ttable[e.second]=e.first;\n      }\n      bool ns=false;\n      for(auto e:seq){\n\tif(ns++){\n\t  cout<<' ';\n\t}\n\tfor(auto f:e){\n\t  cout<<table[f];\n\t}\n      }\n      cout<<'.'<<endl;\n    }catch(...){\n      cout<<\"-.\"<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef pair<string,int> Psi;\ntypedef vector<int> Vi;\nint N;\nvector<string> ss,words[21];\nvector<Psi> vpsi;\nVi ans;\nbool app[26];\nvoid init(){\n\tans.clear();\n\tss.clear();\n\trep(i,21) words[i].clear();\n\tvpsi.clear();\n\trep(i,26) app[i]=0;\n}\nconst bool lencomp(Psi x,Psi y){\n\tstring s=x.fs,t=y.fs;\n\tbool a[26]={},b[26]={};\n\trep(i,s.size()) a[s[i]-'A']=1;\n\trep(i,t.size()) b[t[i]-'A']=1;\n\tint c=0,d=0;\n\trep(i,26) if(a[i]) c++;\n\trep(i,26) if(b[i]) d++;\n\treturn c>d;\n}\ninline bool eq(Vi& a,Vi& b){\n\trep(i,26) if(app[i]&&a[i]!=b[i]) return 0;\n\treturn 1;\n}\nbool dfs(int x,Vi vi){\n\tif(x==ss.size()){\n\t\tif(!ans.empty()&&!eq(ans,vi)) return false;\n\t\tans=vi;\n\t\treturn true;\n\t}\n\tstring s=ss[x];\n\tint L=s.size();\n\tfor(string w:words[L]){\n\t\tVi nvi=vi;\n\t\tbool ok=1;\n\t\trep(i,L){\n\t\t\tif(nvi[s[i]-'A']>=0&&nvi[s[i]-'A']+'A'!=w[i]){\n\t\t\t\tok=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(nvi[w[i]-'A']>=0&&nvi[w[i]-'A']+'A'!=s[i]){\n\t\t\t\tok=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnvi[s[i]-'A']=w[i]-'A';\n\t\t\tnvi[w[i]-'A']=s[i]-'A';\n\t\t}\n\t\tif(!ok) continue;\n\t\tif(!dfs(x+1,nvi)) return false;\n\t}\n\treturn true;\n}\nint main(){\n\twhile(true){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tinit();\n\t\trep(i,N){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\twords[s.size()].pb(s);\n\t\t}\n\t\tint I=0;\n\t\twhile(true){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\trep(i,s.size()) if(s[i]!='.') app[s[i]-'A']=1;\n\t\t\tif(s.back()=='.'){\n\t\t\t\tvpsi.pb(Psi(s.substr(0,s.size()-1),I++));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvpsi.pb(Psi(s,I++));\n\t\t}\n\t\tsort(all(vpsi),lencomp);\n\t\tfor(Psi psi:vpsi) ss.pb(psi.fs);\n\t\tif(dfs(0,Vi(26,-1))&&!ans.empty()){\n\t\t\tvector<string> vst(ss.size());\n\t\t\trep(i,ss.size()) vst[vpsi[i].sc]=ss[i];\n\t\t\trep(i,vst.size()){\n\t\t\t\trep(j,vst[i].size()){\n\t\t\t\t\tcout<<(char)(ans[vst[i][j]-'A']+'A');\n\t\t\t\t}\n\t\t\t\tcout<<(i+1==vst.size()?\".\\n\":\" \");\n\t\t\t}\n\t\t}else{\n\t\t\tputs(\"-.\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<sstream>\n#include<string>\n#include<algorithm>\nusing namespace std;\n\ntypedef vector<char> table;\n\nint n;\nstring word[30],seq;\nvector<string> s;\nvector<table> ans;\n\nbool rec(int num, table t){\n  if(num == s.size()){\n    if(ans.size()==1)return false;\n    ans.push_back(t);\n    return true;\n  }\n\n  for(int i=0;i<n;i++){\n    if(s[num].size() == word[i].size()){\n      table a = t;\n      bool f = true;\n      for(int j=0;j<s[num].size();j++){\n\tif(a[s[num][j]-'A'] == 'A'-1 && a[word[i][j]-'A'] == 'A'-1){\n\t  a[s[num][j]-'A'] = word[i][j];\n\t  a[word[i][j]-'A'] = s[num][j];\n\t}else if(a[s[num][j]-'A'] != word[i][j] || a[word[i][j]-'A'] != s[num][j]){\n\t  f = false;\n\t  break;\n\t}\n      }\n      if(f){\n\tf = rec(num+1,a);\n\tif(!f)return false;\n      }\n    }\n  }\n  return true;\n}\n\t  \nint main(){\n  while(cin >> n,n){\n    for(int i=0;i<n;i++)cin >> word[i];\n    cin.ignore(); getline(cin,seq);\n    \n    seq = seq.substr(0,seq.size()-1);\n    string tmp;\n\n    s.clear();\n    for(int i=0;i<seq.size();i++){\n      if(seq[i] == ' '){\n\ts.push_back(tmp);\n\ttmp = \"\";\n      }else{\n\ttmp += seq[i];\n      }\n    }\n    s.push_back(tmp);\n    sort(s.begin(),s.end());\n    s.erase(unique(s.begin(),s.end()),s.end());\n\n    ans.clear();\n    table t;\n    for(int i=0;i<26;i++)t.push_back((char)('A'-1));\n  \n\n    if(!rec(0,t))cout << '-';\n    else{\n      bool f = true;\n      for(int i=0;i<seq.size();i++){\n\tif(seq[i] != ' ' && ans[0][seq[i]-'A'] == '@'){\n\t  f = false;\n\t  break;\n\t}\n      }\n      if(!f)cout << '-';\n      else{\n\tfor(int i=0;i<seq.size();i++){\n\t  if(seq[i] != ' ')cout << ans[0][seq[i]-'A'];\n\t  else cout << ' ';\n\t}\n      }\n    }\n    cout << '.' << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nstring t[100];\nbool used[100];\nvector<string> v;\nmap< char , char > mp;\ntypedef pair< char , char > P;\n\nbool check( vector<int> a, string b , vector<int> c, string d ){\n  int size=a.size();\n  map< char , set<int> > T;\n\n  for(int i=0;i<size;i++){\n    if(a[i]==-1)continue;\n    T[ b[i] ].insert( d[i] );\n    T[ d[i] ].insert( b[i] );\n    if( T[ b[i] ].size() > 1 )return false;\n    if( T[ d[i] ].size() > 1 )return false;\n  }\n  return true;\n}\n\nstring Replace(string s,bool flag=false){\n  for(int i=0;i<(int)s.size();i++){\n    if(mp.count(s[i]))s[i]=mp[s[i]];\n    else{\n      if(flag)s[i]='?';\n    }\n  }\n  return s;\n}\n\nvector<int> change(string s){\n  vector<int> res(s.size());\n  map<char,int> flg;\n  for(int i=0;i<(int)s.size();i++){\n    if(mp.count(s[i])){\n      res[i]=-1;\n      continue;\n    }\n    if( flg.count(s[i]) ){\n      res[i]=flg[ s[i] ];\n    }else{\n      res[i]=flg.size();\n      flg[ s[i] ]=res[i];\n    }\n  }\n  return res;\n}\n\nvoid Add(string s,string t){\n  for(int i=0;i<(int)s.size();i++){\n    mp[ s[i] ] = t[i];\n    mp[ t[i] ] = s[i];\n  }\n}\n\nbool solve(){\n  set< int > pa;\n  bool update=true;\n  while(update){\n    update=false;\n    vector<int> cnt( v.size(), 0 );\n    \n    for(int i=0;i<n;i++){\n      string str=Replace(t[i],true);\n      vector<int> hashv=change(t[i]);\n      vector<int> target;\n      set< string > st;\n      for(int j=0;j<(int)v.size();j++){\n        if( pa.count(j) )continue;\n        \n        string tmp=Replace(Replace(v[j],true));\n        vector<int> hashw=change(v[j]);\n        if(str==tmp && hashv == hashw && check(hashv,t[i],hashw,v[j])){\n          cnt[j]++;\n        }\n      }\n    }\n\n\n    bool loopf=false;\n    for(int i=0;i<n;i++){\n      \n      string str=Replace(t[i],true);\n      vector<int> hashv=change(t[i]);\n      \n      for(int j=0;j<(int)v.size();j++){\n        string tmp=Replace(Replace(v[j],true));\n        vector<int> hashw=change(v[j]);\n        \n        if(str==tmp && hashv == hashw && cnt[j]==1 && check(hashv,t[i],hashw,v[j])){\n          pa.insert(j);\n          Add(t[i],v[j]);\n          loopf=true;\n          update=true;\n          break;\n        }\n      }\n\n      if(loopf)break;\n    }\n    \n\n  }// while update\n\n  if(pa.size()!=v.size())return false;\n  return true;\n}\n\nvoid init(){\n  v.clear();\n  mp.clear();\n  memset(used,false,sizeof(used));\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++)cin>>t[i];\n    string tmp,str;\n    getline(cin,tmp);\n    getline(cin,tmp);\n    stringstream ss(tmp);\n    while(ss>>str){\n      if( str.back() == '.' )str.pop_back();\n      v.push_back(str);\n    }\n    if( solve() ){\n      for(int i=0;i<(int)v.size();i++){\n        if(i)cout<<' ';\n        cout<<Replace(v[i]);\n      }\n      cout<<'.'<<endl;\n    }else{\n      cout<<\"-.\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint n;\nchar word[20][21];\nvector<int> L[21]; // L[l] := ( 長さ l の単語の集合 )\n\nchar s[128];\nvector<int> pos,len; // 空白で区切った s の部分文字列の開始位置と長さ\n\nint dup;\nchar f[128],f_ans[128]; // アルファベットの対応表\n\nbool used[80]; // s の部分文字列 i をすでに調べたかどうか\nbool dfs(){\n\tif(dup>=2) return false;\n\n\t// 絶対に埋められない部分文字列が出てきたら探索打ち切り\n\trep(i,pos.size()) if(!used[i]) {\n\t\tint m=len[i];\n\t\tconst char *t=s+pos[i];\n\t\tbool ok=false;\n\t\trep(j,L[m].size()){\n\t\t\tconst char *w=word[L[m][j]];\n\n\t\t\tbool b=true;\n\t\t\trep(k,m){\n\t\t\t\tchar c1=t[k],c2=w[k];\n\t\t\t\tif(f[c1]!='?' && f[c2]!='?'){\n\t\t\t\t\tif(c2!=f[c1]) b=false;\n\t\t\t\t}\n\t\t\t\telse if(f[c1]=='?' && f[c2]=='?'){}\n\t\t\t\telse{\n\t\t\t\t\tb=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b){ ok=true; break; }\n\t\t}\n\t\tif(!ok) return false;\n\t}\n\n\tint i0=-1;\n\trep(i,len.size()) if(!used[i]) {\n\t\tif(i0==-1 || len[i0]<len[i]) i0=i;\n\t}\n\tif(i0==-1){\n\t\tdup++;\n\t\tif(dup>=2) return false;\n\t\tmemcpy(f_ans,f,sizeof f);\n\t\treturn true;\n\t}\n\n\tint m=len[i0];\n\tconst char *t=s+pos[i0];\n\tchar tmp[128];\n\trep(i,L[m].size()){\n\t\tconst char *w=word[L[m][i]]; // 部分文字列 t に単語 w を割り当てる\n\n\t\tbool ok=true; // その割り当てで矛盾が起こらないか\n\t\tmemcpy(tmp,f,sizeof f);\n\t\trep(j,m){\n\t\t\tchar c1=t[j],c2=w[j];\n\t\t\tif(f[c1]!='?' && f[c2]!='?'){\n\t\t\t\tif(c2!=f[c1]) ok=false;\n\t\t\t}\n\t\t\telse if(f[c1]=='?' && f[c2]=='?'){\n\t\t\t\tf[c1]=c2;\n\t\t\t\tf[c2]=c1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tok=false;\n\t\t\t}\n\t\t}\n\n\t\tif(ok){\n\t\t\tused[i0]=true;\n\t\t\tdfs();\n\t\t\tused[i0]=false;\n\t\t}\n\n\t\tmemcpy(f,tmp,sizeof f);\n\t}\n\n\treturn dup==1;\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\trep(i,n) scanf(\"%s \",word[i]);\n\t\trep(l,21) L[l].clear();\n\t\trep(i,n) L[strlen(word[i])].push_back(i);\n\n\t\tfgets(s,128,stdin);\n\t\tpos.clear();\n\t\tlen.clear();\n\t\tfor(int i=0,pre=0;;i++){\n\t\t\tif(s[i]=='.' || s[i]==' '){\n\t\t\t\tpos.push_back(pre);\n\t\t\t\tlen.push_back(i-pre);\n\t\t\t\tpre=i+1;\n\t\t\t\tif(s[i]=='.') break;\n\t\t\t}\n\t\t}\n\n\t\tfor(char c='A';c<='Z';c++) f[c]='?';\n\n\t\tdup=0;\n\t\trep(i,pos.size()) used[i]=false;\n\t\tif(!dfs()) puts(\"-.\");\n\t\telse{\n\t\t\trep(i,pos.size()){\n\t\t\t\trep(j,len[i]) putchar(f_ans[s[pos[i]+j]]);\n\t\t\t\tputchar(i<(int)pos.size()-1?' ':'.');\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <stdexcept>\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n#define phb push_back\n#define ppb pop_back\nusing namespace std;\n\nint N;\nstring D[20];\nvector< string > S;\n\nvector< string > t;\nvector< int > mtc, res;\nint tbl[128], clv[128];\n\nbool read();\nvoid solve();\n\nvoid dfs(int);\n\nint main() {\n\twhile (read())\n\t\tsolve();\n\t\n\treturn 0;\n}\n\nbool read() {\n\tstring str, ln;\n\tistringstream iss;\n\t\n\tgetline(cin, ln), iss.clear(), iss.str(ln);\n\tif (iss >> N, N == 0)\n\t\treturn false;\n\t\n\tfor (int i = 0; i < N; ++i)\n\t\tgetline(cin, D[i]);\n\t\n\tgetline(cin, ln), ln.back() = ' ', iss.clear(), iss.str(ln);\n\tS.clear();\n\twhile (iss >> str)\n\t\tS.phb(str);\n\t\n\treturn true;\n}\n\nvoid solve() {\n\tt.clear();\n\tfor (int i = 0; i < sz(S); ++i)\n\t\tif (find(all(t), S[i]) == t.end())\n\t\t\tt.phb(S[i]);\n\t\n\tauto cmpf = [&] (const string &ra, const string &rb) -> bool {\n\t\treturn sz(ra) > sz(rb);\n\t};\n\t\n\tsort(&S[0], &S[N], cmpf);\n\tsort(all(t), cmpf);\n\t\n\tfill(&tbl[0], &tbl[128], 0);\n\tfill(&clv[0], &clv[128], -1);\n\tmtc.clear(), res.clear();\n\t\n\ttry {\n\t\tdfs(0);\n\t\tfor (int i = 0; i < sz(S); ++i) {\n\t\t\tint k = int(find(all(t), S[i]) - t.begin());\n\t\t\tcout << D[res[k]] << (i + 1 == sz(S) ? \".\" : \" \");\n\t\t}\n\t}\n\tcatch (...) {\n\t\tcout << \"-.\";\n\t}\n\tcout << \"\\n\";\n}\n\nvoid dfs(int u) {\n\tif (u == sz(t)) {\n\t\tif (!res.empty())\n\t\t\tthrow exception();\n\t\tres = mtc;\n\t}\n\telse {\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tif (sz(D[i]) == sz(t[u])) {\n\t\t\t\tint j = 0, c1, c2;\n\t\t\t\t\n\t\t\t\twhile (j < sz(D[i])) {\n\t\t\t\t\tc1 = int(D[i][j]), c2 = int(t[u][j]);\n\t\t\t\t\tif ((tbl[c1] != 0 && tbl[c1] != c2) || (tbl[c2] != 0 && tbl[c2] != c1))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (tbl[c1] == 0)\n\t\t\t\t\t\ttbl[c1] = c2, tbl[c2] = c1, clv[c1] = clv[c2] = u;\n\t\t\t\t\t++j;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (j == sz(D[i])) {\n\t\t\t\t\tmtc.phb(i);\n\t\t\t\t\tdfs(u + 1);\n\t\t\t\t\tmtc.ppb();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhile ((--j) >= 0) {\n\t\t\t\t\tc1 = int(D[i][j]), c2 = int(t[u][j]);\n\t\t\t\t\tif (clv[c1] == u)\n\t\t\t\t\t\ttbl[c1] = tbl[c2] = 0, clv[c1] = clv[c2] = -1;\n\t\t\t\t}\n\t\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring t, ans;\nvector< string > words, latte[21];\n\nbool rec(int idx, vector< char > &add)\n{\n  if(idx == words.size()) {\n    if(!ans.empty()) return (false);\n    ans = t;\n    for(auto &c : ans) if(isalpha(c)) c = add[c - 'A'];\n    return (true);\n  }\n\n  const string &beet = words[idx];\n  for(auto &str : latte[beet.size()]) {\n    auto temp(add);\n    bool flag = true;\n    for(int i = 0; i < beet.size() && flag; i++) {\n      if(temp[beet[i] - 'A'] != str[i] &&\n         (temp[beet[i] - 'A'] != -1 ||\n          temp[str[i] - 'A'] != -1))\n        flag = false;\n      else {\n        temp[beet[i] - 'A'] = str[i];\n        temp[str[i] - 'A'] = beet[i];\n      }\n    }\n    if(!flag) continue;\n    if(!rec(idx + 1, temp)) return (false);\n  }\n  return (true);\n}\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    for(int i = 0; i < N; i++) {\n      string s;\n      cin >> s;\n      latte[s.size()].emplace_back(s);\n    }\n    cin.ignore();\n    getline(cin, t);\n\n    istringstream sss(t);\n    string q;\n    while(sss >> q) {\n      if(q.back() == '.') q.pop_back();\n      words.emplace_back(q);\n    }\n    sort(begin(words), end(words), [&](const string &a, const string &b)\n    {\n      return (set< char >(begin(a), end(a)).size() > set< char >(begin(b), end(b)).size());\n    });\n    vector< char > add(26, -1);\n    if(rec(0, add)) cout << ans << endl;\n    else cout << \"-.\\n\";\n    for(int i = 0; i < 21; i++) latte[i].clear();\n    words.clear();\n    ans.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nchar a[256];\nint ans;\n\nchar m[256];\nint used[256]={0};\n\nvoid search(int n,int now,vector<string> &in,const vector<string> &words){\n  if (ans >= 2)return;\n  if (n == now){\n    ans++;\n    rep(i,256)a[i]=m[i];\n    return;\n  }\n  rep(i,(int)words.size()){\n    string cur = in[now];\n    string tar = words[i];\n    if (tar.size() != cur.size())continue;\n    //check\n    bool isok=true;\n    rep(j,(int)cur.size()){\n      //cout << j << \" \" << cur[j] <<\" \" << tar[j] <<\" \" << used[cur[j]] <<\" \" << used[tar[j]] << endl;\n      if (used[(int)cur[j]] == -1 && used[(int)tar[j]] == -1){\n\tused[(int)tar[j]]=now;\n\tused[(int)cur[j]]=now;\n\tm[(int)cur[j]]=tar[j];\n\tm[(int)tar[j]]=cur[j];\n      }else if (used[(int)cur[j]] == -1     || used[(int)tar[j]] == -1)isok=false;\n      else  if (   m[(int)cur[j]] == tar[j] && m[(int)tar[j]] == cur[j])assert(used[cur[j]] != -1 && used[tar[j]] != -1);\n      else isok=false;\n    }\n    //search\n    if (isok){\n      search(n,now+1,in,words);\n    }\n    //backtrack\n    rep(j,(int)cur.size()){\n      if (used[(int)cur[j]] == now && used[tar[j]] == now){\n\tused[(int)cur[j]]=-1,used[(int)tar[j]]=-1;\n      }\n    }\n  }\n}\n\nbool cmp(const string & a,const string &b){\n  if (a.size() != b.size())return a.size() > b.size();\n  return a < b;\n}\n\nint main(){\n  int n;\n  while(cin>>n && n){\n    rep(i,256)used[i]=-1;\n    ans=0;\n\n    vector<string> words(n),inp;\n    rep(i,n)cin>>words[i];\n    sort(words.begin(),words.end());\n    words.erase(unique(words.begin(),words.end()),words.end());\n    sort(words.begin(),words.end(),cmp);\n    string in;getline(cin,in);\n    getline(cin,in);\n    string tmp = in;\n    rep(i,(int)tmp.size())if (tmp[i] == '.')tmp[i]=' ';\n    stringstream sin(tmp);\n    while(sin>>tmp)inp.push_back(tmp);\n    sort(inp.begin(),inp.end());\n    inp.erase(unique(inp.begin(),inp.end()),inp.end());\n    sort(inp.begin(),inp.end(),cmp);\n    \n    search(inp.size(),0,inp,words);\n    assert(ans > 0);\n    if (ans != 1)cout <<\"-.\" << endl;//\" \" << ans << endl;\n    else {\n      rep(i,(int)in.size()){\n\tif (isupper(in[i]))cout<<a[in[i]];\n\telse cout << in[i];\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n,found,buf_length;\nvector<string> word[30],buf;\nstring sequence;\nchar transfer[26];\nvector<ll> bitmask;\nvector<int> bc;\nset<string> exist;\nchar table[26];\n\nbool cmp(const string& a,const string& b){ return a.size() > b.size(); }\n\nvoid dfs(int cur,long long bit){\n\n  if( found >= 2 ) return;\n\n  //rep(i,26) cout << table[i] << \" \";\n  //cout << endl;\n\n  if( cur >= buf_length ){\n    found++;\n    rep(i,26) transfer[i] = table[i];\n    return;\n  }\n\n\n  int len = buf[cur].size();\n\n  if( __builtin_popcountll( bit & bitmask[cur] ) == bc[cur] ) {\n    string tmp = buf[cur];\n    rep(i,len) tmp[i] = table[tmp[i]-'A'];\n    if( exist.find(tmp) != exist.end() ) dfs(cur+1,bit);\n    return;\n  }\n\n\n  char tmp_table[26];\n  rep(i,26) tmp_table[i] = table[i];\n  rep(i,word[len].size()){\n    //cout<< endl;\n    //rep(j,26) cout << table[j] << \" \"; cout << endl; \n    // cout << \"word \" << word[len][i] << \" is \";\n    bool error = false;\n    long long new_bit = bit;\n    //rep(j,26) table[j] = tmp_table[j];\n    rep(j,len){\n\n\n      if( table[buf[cur][j]-'A'] == '?' && table[word[len][i][j]-'A'] == '?' ) {\n        long long SHIFT = word[len][i][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        SHIFT = buf[cur][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        table[buf[cur][j]-'A']     = word[len][i][j];\n        table[word[len][i][j]-'A'] = buf[cur][j];\n      } else if( !( table[buf[cur][j]-'A'] == word[len][i][j] && table[word[len][i][j]-'A'] == buf[cur][j] ) ) {\n        //cout << \"table[\" << buf[cur][j] << \"] != \" << table[buf[cur][j]-'A'] << \" ?= \" << word[len][i][j] << endl;\n        //cout << \"table[\" << word[len][i][j] << \"] != \" << table[word[len][i][j]-'A'] << \" ?= \" << buf[cur][j] << endl;\n        error = true;\n        break;\n      }\n    }\n\n    if( error ){\n      //cout << \"bad\" << endl;\n      continue;\n    } //cout << \"ok\" << endl;\n    dfs(cur+1,new_bit);\n    rep(j,len){\n      int idx = buf[cur][j] - 'A';\n      table[idx] = tmp_table[idx];\n      idx = word[len][i][j] - 'A';\n      table[idx] = tmp_table[idx];\n    }\n    if( found >= 2 ) return;\n  }\n}\n\nint main(){\n  while( cin >> n, n ){\n    string tmp;\n    found = 0;\n    buf.clear(), tmp.clear();\n    rep(i,26)transfer[i] = table[i] = '?';\n    rep(i,30) word[i].clear();\n    rep(i,n){\n      cin >> tmp;\n      word[(int)tmp.size()].push_back(tmp);\n      exist.insert(tmp);\n    }\n    cin.ignore();\n    getline(cin,sequence);\n    tmp = sequence.substr(0,(int)sequence.size()-1);\n    stringstream ss(tmp);\n    while( !( ss >> tmp ).fail() ) buf.push_back(tmp);\n\n    sort(buf.begin(),buf.end(),cmp);\n    buf.erase(unique(buf.begin(),buf.end()),buf.end());\n    buf_length = (int) buf.size();\n    bitmask.clear(), bc.clear();\n    bitmask.resize(buf_length,0), bc.resize(buf_length);\n    rep(i,buf_length){\n      rep(j,buf[i].size()){\n        long long SHIFT = buf[i][j] - 'A';\n        bitmask[i] |= (1LL<<SHIFT);\n      }\n      bc[i] = __builtin_popcountll(bitmask[i]);\n    }\n\n    dfs(0,0LL);\n\n    if( found == 1 ) {\n      rep(i,sequence.size()) cout << (isupper(sequence[i])?transfer[sequence[i]-'A']:sequence[i]);\n      puts(\"\");\n    } else puts(\"-.\");\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Weaker then Planned\n//Level:\n//Category:\n//Note:\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <array>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define TIMES(i,n) for(int i = 0; i < (n); ++i)\n\ntypedef array<char,256> Table;\nTable table, ans;\nbool found = false;\n\nbool check(const vector<string> &words, const vector<string> &crypted) {\n    for(const string &cs : crypted) {\n        for(const string &w : words) {\n            if(cs.size() != w.size()) continue;\n            bool ok = true;\n            TIMES(i, cs.size()) {\n                const char cch = cs[i];\n                const char wch = w[i];\n                if(table[cch] != 0 && table[cch] != wch) {\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok) goto next_cs;\n        }\n        //cout << \"no match for \" << cs << endl;\n        return false;\nnext_cs:\n        ;\n    }\n    return true;\n}\n\nbool search(int pos, const vector<string> &words, const vector<string> &crypted) {\n    if(pos == crypted.size()) {\n        if(found) throw \"ambiguous\";\n        found = true;\n        ans = table;\n        return true;\n    }\n\n    const string &cs = crypted[pos];\n    for(const string &w : words) {\n        if(w.size() != cs.size()) continue;\n        Table bak = table;\n        TIMES(i, w.size()) {\n            const char cch = cs[i];\n            const char wch = w[i];\n            // Check whether consistency\n            if(table[cch] != 0 && table[cch] != wch) {\n                goto next;\n            }\n            if(table[wch] != 0 && table[wch] != cch) {\n                goto next;\n            }\n            table[cch] = wch;\n            table[wch] = cch;\n        }\n        //cout << cs << ' ' << w << endl;\n        // Check consistency for other words\n        if(!check(words, crypted)) goto next;\n        search(pos+1, words, crypted);\nnext:\n        table = bak;\n    }\n    return false;\n}\n\nbool solve() {\n    int N;\n    cin >> N;\n    if(!N) return false;\n\n    vector<string> words(N);\n    TIMES(i, N) {\n        cin >> words[i];\n    }\n    vector<string> seq;\n    while(true) {\n        string w;\n        cin >> w;\n        if(w[w.size()-1] == '.') {\n            seq.push_back(w.substr(0, w.size()-1));\n            break;\n        } else {\n            seq.push_back(w);\n        }\n    }\n    vector<pair<int,string>> v;\n    TIMES(i, seq.size()) {\n        const auto &s = seq[i];\n        vector<bool> seen(26, false);\n        int cnt = 0;\n        for(char c : s) {\n            if(seen[c-'A']) continue;\n            seen[c-'A'] = true;\n            ++cnt;\n        }\n        v.push_back(make_pair(i, s));\n    }\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    reverse(v.begin(), v.end());\n\n    vector<string> crypted;\n    for(const auto &p : v) {\n        crypted.push_back(p.second);\n    }\n    fill(table.begin(), table.end(), 0);\n    found = false;\n    try {\n        search(0, words, crypted);\n    } catch(const char *s) {\n        found = false;\n    }\n    if(found) {\n        bool first = true;\n        for(const string &s : seq) {\n            if(!first) cout << ' ';\n            for(char c : s) {\n                cout << ans[c];\n            }\n            first = false;\n        }\n        cout << '.' << endl;\n    } else {\n        cout << \"-.\" << endl;\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\n#include<cstdlib>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nchar read[100];\nint n,cnt,ans,ti;\nmap<char ,char >mp,answer;\nstruct node\n{\n    char st[100];\n    int ls;\n}s[100],str[100];\nbool judge(int i,int at)//把i放在at串&#36825;个地方\n{\n    for (int j=0;j<s[i].ls;j++)\n        if (mp[s[i].st[j]]!=str[at].st[j])\n        {\n            if (mp[s[i].st[j]]=='0'&&mp[str[at].st[j]]=='0')\n            {\n                mp[s[i].st[j]]=str[at].st[j];\n                mp[str[at].st[j]]=s[i].st[j];\n            }\n            else return false;\n        }\n    return true;\n}\nvoid dfs(int at)\n{\n    if (ans>1)return ;\n    if (at==cnt)\n    {\n        ans++;\n        for (char i='A';i<='Z';i++)answer[i]=mp[i];\n        return ;\n    }\n    map<char ,char >mpresume;\n    for (int i=0;i<n;i++)\n        if (s[i].ls==str[at].ls)\n        {\n            for (char j='A';j<='Z';j++)mpresume[j]=mp[j];\n            if (judge(i,at))\n            {\n                dfs(at+1);\n                if (ans>1)return ;\n            }\n            for (char j='A';j<='Z';j++)mp[j]=mpresume[j];\n        }\n}\nint cmp(const void *a,const void *b)\n{\n    node *aa=(node *)a;\n    node *bb=(node *)b;\n    if (aa->ls!=bb->ls)\n        return bb->ls-aa->ls;\n    return strcmp(bb->st,aa->st);\n}\nint main()\n{\n    #ifndef ONLINE_JUDGE\n        freopen(\"1.in\",\"r\",stdin);\n    #endif\n    while (scanf(\"%d\",&n)!=EOF&&n)\n    {\n        for (char i='A';i<='Z';i++)mp[i]='0';\n        for (int i=0;i<n;i++)\n            scanf(\"%s\",s[i].st),s[i].ls=strlen(s[i].st);\n        getchar();\n        gets(read);\n        int len=strlen(read);\n        ans=cnt=0;\n        for (int i=0;i<len;)\n        {\n            while (i<len&&(read[i]<'A'||read[i]>'Z'))i++;\n            if (i==len)break;\n            str[cnt].ls=0;\n            while (i<len&&read[i]>='A'&&read[i]<='Z')str[cnt].st[str[cnt].ls++]=read[i++];\n            str[cnt].st[str[cnt].ls]='\\0';\n            cnt++;\n        }\n        qsort(s,n,sizeof s[0],cmp);\n        qsort(str,cnt,sizeof str[0],cmp);\n        dfs(0);\n        if (ans==1)\n        {\n            for (int i=0;i<len-1;i++)\n                if (read[i]==' ')printf(\" \");\n                else printf(\"%c\",answer[read[i]]);\n        }\n        else printf(\"-\");\n        printf(\".\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 21;\nint N;\nstring word[MAXN];\nstring line;\nvector<string> V;\nvector<int> F;\nmap<char, char> ans;\n\nbool ok(const string &x, const string &w, map<char, char> m) {\n  if(x.size() != w.size()) return false;\n  for(int i = 0; i < x.size(); ++i) {\n    if(m.count(x[i]) && m[x[i]] != w[i]) return false;\n    m[x[i]] = w[i];\n    m[w[i]] = x[i];\n  }\n  return true;\n}\n\nvoid reg(const string &x, const string &w, map<char, char> &m) {\n  for(int i = 0; i < x.size(); ++i) {\n    m[x[i]] = w[i];\n    m[w[i]] = x[i];\n  }\n}\n\nbool update(int k, map<char, char> m) {\n  F = vector<int>(V.size());\n  for(int i = k; i < V.size(); ++i) {\n    for(int j = 0; j < N; ++j) {\n      if(ok(V[i], word[j], m)) {\n        F[i] |= 1 << j;\n      }\n    }\n    if(!F[i]) return false;\n  }\n  return true;\n}\n\nvoid rec(int k, map<char, char> m) {\n  if(k == V.size()) {\n    if(ans.size()) throw 0;\n    ans = m;\n    return;\n  }\n  for(int i = 0; i < N; ++i) {\n    if(F[k] >> i & 1); else continue;\n    map<char, char> nm = m;\n    reg(V[k], word[i], nm);\n    vector<int> undo = F;\n    if(update(k+1, nm)) {\n      rec(k+1, nm);\n    }\n    F = undo;\n  }\n}\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) {\n      cin >> word[i];\n    }\n    cin.ignore();\n    getline(cin, line);\n    stringstream ss(line.substr(0, line.size()-1));\n    set<string> ws;\n    for(string s; ss >> s; ) ws.insert(s);\n    V.clear();\n    for(set<string>::iterator it = ws.begin();\n        it != ws.end(); ++it) {\n      V.push_back(*it);\n    }\n    update(0, map<char, char>());\n    ans = map<char, char>();\n    try {\n      rec(0, map<char, char>());\n      if(ans.empty()) throw 0;\n      for(int i = 0; i < line.size(); ++i) {\n        if(isalpha(line[i])) cout << ans[line[i]];\n        else cout << line[i];\n      }\n      cout << endl;\n    } catch(...) {\n      cout << \"-.\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cstring>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint n;\nchar word[20][21];\nvector<int> L[21]; // L[l] := ( 長さ l の単語の集合 )\n\nchar s[128];\nvector<int> pos,len; // 空白で区切った s の部分文字列の開始位置と長さ\n\nchar f[128],f_ans[128]; // アルファベットの対応表\n\nbool used[80]; // s の部分文字列 i をすでに調べたかどうか\nbool dfs(){\n\t// 絶対に埋められないものが出てきたら探索打ち切り\n\trep(i,pos.size()) if(!used[i]) {\n\t\tint m=len[i];\n\t\tconst char *t=s+pos[i];\n\t\tbool ok=false;\n\t\trep(j,L[m].size()){\n\t\t\tconst char *w=word[L[m][j]];\n\n\t\t\tbool b=true;\n\t\t\trep(k,m){\n\t\t\t\tchar c1=t[k],c2=w[k];\n\t\t\t\tif(f[c1]!='?' && f[c2]!='?'){\n\t\t\t\t\tif(c2!=f[c1]) b=false;\n\t\t\t\t}\n\t\t\t\telse if(f[c1]=='?' && f[c2]=='?'){}\n\t\t\t\telse{\n\t\t\t\t\tb=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(b){ ok=true; break; }\n\t\t}\n\t\tif(!ok) return false;\n\t}\n\n\tint i0=-1;\n\trep(i,len.size()) if(!used[i]) {\n\t\tif(i0==-1 || len[i0]<len[i]) i0=i;\n\t}\n\tif(i0==-1){\n\t\tmemcpy(f_ans,f,sizeof f);\n\t\treturn true;\n\t}\n\n\tint cnt=0,m=len[i0];\n\tconst char *t=s+pos[i0];\n\tchar tmp[128];\n\trep(i,L[m].size()){\n\t\tconst char *w=word[L[m][i]]; // 部分文字列 t に単語 w を割り当てる\n\n\t\tbool ok=true; // その割り当てで矛盾が起こらないか\n\t\tmemcpy(tmp,f,sizeof f);\n\t\trep(j,m){\n\t\t\tchar c1=t[j],c2=w[j];\n\t\t\tif(f[c1]!='?' && f[c2]!='?'){\n\t\t\t\tif(c2!=f[c1]) ok=false;\n\t\t\t}\n\t\t\telse if(f[c1]=='?' && f[c2]=='?'){\n\t\t\t\tf[c1]=c2;\n\t\t\t\tf[c2]=c1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tok=false;\n\t\t\t}\n\t\t}\n\n\t\tif(ok){\n\t\t\tused[i0]=true;\n\t\t\tif(dfs()) cnt++;\n\t\t\tused[i0]=false;\n\t\t}\n\n\t\tmemcpy(f,tmp,sizeof f);\n\n\t\tif(cnt>=2) return false;\n\t}\n\n\treturn cnt==1;\n}\n\nint main(){\n\tfor(;scanf(\"%d\",&n),n;){\n\t\trep(i,n) scanf(\"%s \",word[i]);\n\t\trep(l,21) L[l].clear();\n\t\trep(i,n) L[strlen(word[i])].push_back(i);\n\n\t\tfgets(s,128,stdin);\n\t\tpos.clear();\n\t\tlen.clear();\n\t\tfor(int i=0,pre=0;;i++){\n\t\t\tif(s[i]=='.' || s[i]==' '){\n\t\t\t\tpos.push_back(pre);\n\t\t\t\tlen.push_back(i-pre);\n\t\t\t\tpre=i+1;\n\t\t\t\tif(s[i]=='.') break;\n\t\t\t}\n\t\t}\n\n\t\tfor(char c='A';c<='Z';c++) f[c]='?';\n\n\t\trep(i,pos.size()) used[i]=false;\n\t\tif(!dfs()) puts(\"-.\");\n\t\telse{\n\t\t\trep(i,pos.size()){\n\t\t\t\trep(j,len[i]) putchar(f_ans[s[pos[i]+j]]);\n\t\t\t\tputchar(i<(int)pos.size()-1?' ':'.');\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n;\nvector<string> w,v;\nvector<string> xyz[30];\nstring s;\nvector<char> vc,ans;\ntypedef pair<int,int> P;\nvector<P> vp;\nvector<int> used;\nint valid;\nvector<int> wc1,wc2;\nvoid dfs(){\n  for(int i=0;i<(int)v.size();i++){\n    string& t=v[i];\n    bool flg=0;\n    for(int j=0;j<(int)xyz[t.size()].size();j++){\n      string& u=xyz[t.size()][j];\n      bool ok=1;\n      for(int k=0;k<(int)t.size();k++){\n    if(!used[t[k]-'A']) continue;\n    if(!used[u[k]-'A']){\n      ok=0;\n      break;\n    }\n    ok&=vc[t[k]-'A']==u[k]-'A';\n    if(!ok) break;\n      }\n      //cout<<t<<\" \"<<u<<\":\"<<ok<<endl;\n      if(ok){\n    flg=1;\n    break;\n      }\n    }\n    if(!flg) return;\n  }\n  int cnt=0;\n  for(int i=0;i<26;i++) if(used[vp[i].second]) cnt++;\n  //cout<<cnt<<endl;\n  //if(cnt>1) return;\n  if(cnt==26){\n    valid++;\n    ans=vc;\n    return;\n  }\n  int x=0;\n  while(used[vp[x].second]) x++;\n  //cout<<x<<endl;\n  if(vp[x].first){\n    for(int k=0;k<26;k++){\n      if(used[vp[k].second]) continue;\n      used[vp[x].second]=used[vp[k].second]=1;\n      vc[vp[x].second]=vp[k].second;\n      vc[vp[k].second]=vp[x].second;\n      //cout<<x<<\" \"<<k<<endl;\n      //cout<<(char)(vp[x].second+'A')<<\"<->\"<<(char)(vp[k].second+'A')<<endl;\n      dfs();\n      if(valid>1) return; \n      used[vp[x].second]=used[vp[k].second]=0;\n      vc[vp[x].second]=vc[vp[k].second]=0;   \n    }\n  }else{\n    used[vp[x].second]=1;\n    vc[vp[x].second]=vp[x].second;\n    dfs();\n    used[vp[x].second]=0;\n    vc[vp[x].second]=0;\n  }\n}\nsigned main(){\n  while(cin>>n,n){\n    for(int i=0;i<30;i++) xyz[i].clear(); \n    w.resize(n);\n    for(int i=0;i<n;i++) cin>>w[i],xyz[w[i].size()].push_back(w[i]);\n    cin.ignore();\n    getline(cin,s);\n    assert(s.back()=='.');\n    s.pop_back();\n    v.clear();\n    for(int i=0;i<(int)s.size();i++){\n      string t;\n      while(i<(int)s.size()&&s[i]!=' ') t+=s[i++];\n      //cout<<t<<endl;\n      v.push_back(t);\n    }\n    vc.clear();\n    vc.resize(26,0);\n    wc2.clear();\n    wc2.resize(26,0);\n    for(int i=0;i<(int)v.size();i++)\n      for(int j=0;j<(int)v[i].size();j++)\n    wc2[v[i][j]-'A']++;\n    vp.resize(26);\n    for(int i=0;i<26;i++) vp[i]=P(wc2[i],i);\n    sort(vp.rbegin(),vp.rend());\n    used.clear();\n    used.resize(26,0);\n    valid=0;\n    dfs();\n    //cout<<valid<<endl;\n    if(valid!=1){\n      cout<<\"-.\"<<endl;\n      continue;\n    }\n    //puts(\"found\");\n    for(int i=0;i<(int)v.size();i++){\n      if(i) cout<<\" \";\n      for(int j=0;j<(int)v[i].size();j++){\n    //cout<<v[i][j]-'A'<<endl;\n    cout<<(char)(ans[v[i][j]-'A']+'A');\n      }\n    }\n    cout<<\".\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <iostream>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 21;\nconst int MAXC = 100;\n\nint n, answer, table[26], answerTable[26], nCiph, nDict, ciphRemain[MAXC];\nstd::string ciph[MAXC], dict[MAXN], buffer;\n\nbool cmpByLength(const std::string &a, const std::string &b) {\n    return a.length() < b.length();\n}\n\nbool cmpByRemain(const int &a, const int &b) {\n    return ciphRemain[a] < ciphRemain[b];\n}\n\nvoid dfs(int nCiph, std::string ciph[]) {\n    if (nCiph == 0) {\n        answer++;\n        memcpy(answerTable, table, sizeof(answerTable));\n        return;\n    }\n    static int ciphId[MAXC];\n    for (int i = 1; i <= nCiph; i++) {\n        ciphRemain[i] = 0;\n        ciphId[i] = i;\n        for (int j = 0; j < ciph[i].length(); j++) {\n            if (table[ciph[i][j] - 'A'] == 0) {\n                ciphRemain[i]++;\n            }\n        }\n    }\n    std::sort(ciphId + 1, ciphId + nCiph + 1, cmpByRemain);\n    int nEnsure = 0, ensure[MAXC];\n    std::string now = ciph[ciphId[nCiph]];\n    for (int i = 1; i <= nDict; i++) {\n        if (now.length() != dict[i].length()) continue;\n        bool flag = true;\n        for (int j = 0; j < now.length(); j++) {\n            if (table[now[j] - 'A'] != 0) {\n                if (table[now[j] - 'A'] != dict[i][j]) {\n                    flag = false;\n                    break;\n                }\n            } else if (table[dict[i][j] - 'A'] != 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (!flag) continue;\n        for (int j = 0; j < now.length(); j++) {\n            if (table[now[j] - 'A'] == 0) {\n                table[now[j] - 'A'] = dict[i][j];\n                table[dict[i][j] - 'A'] = now[j];\n                ensure[++nEnsure] = now[j];\n                if (dict[i][j] != now[j]) {\n                    ensure[++nEnsure] = dict[i][j];\n                }\n            }\n        }\n        for (int j = 0; j < now.length(); j++) {\n            if (table[now[j] - 'A'] != 0) {\n                if (table[now[j] - 'A'] != dict[i][j]) {\n                    flag = false;\n                    break;\n                }\n            } else if (table[dict[i][j] - 'A'] != 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            std::string nextCiph[MAXC];\n            for (int j = 1; j < nCiph; j++) {\n                nextCiph[j] = ciph[ciphId[j]];\n            }\n            dfs(nCiph - 1, nextCiph);\n            if (answer > 1) return;\n        }\n        for (int j = 1; j <= nEnsure; j++) {\n            table[ensure[j] - 'A'] = 0;\n        }\n    }\n}\n\nvoid solve() {\n    answer = 0;\n    std::fill(table, table + 26, 0);\n    for (int i = 1, k = 1; i <= nDict; i++) {\n        int j = i;\n        while (j + 1 <= nDict && dict[j].length() == dict[j + 1].length()) j++;\n        while (k <= nCiph && ciph[k].length() < dict[i].length()) k++;\n        if (k <= nCiph && ciph[k].length() != dict[i].length()) {\n            puts(\"-.\");\n            return;\n        }\n        if (i == j) {\n            while (k <= nCiph && ciph[k].length() == dict[i].length()) {\n                for (int p = 0; p < ciph[k].length(); p++) {\n                    if (table[ciph[k][p] - 'A'] != 0) {\n                        if (table[ciph[k][p] - 'A'] != dict[i][p]) {\n                            puts(\"-.\");\n                            return;\n                        }\n                    } else if (table[dict[i][p] - 'A'] != 0) {\n                        puts(\"-.\");\n                        return;\n                    } else {\n                        table[ciph[k][p] - 'A'] = dict[i][p];\n                        table[dict[i][p] - 'A'] = ciph[k][p];\n                    }\n                }\n                k++;\n            }\n        }\n        i = j;\n    }\n    dfs(nCiph, ciph);\n    if (answer == 1) {\n        for (int i = 0; i < buffer.length(); i++) {\n            if (!isalpha(buffer[i])) putchar(buffer[i]);\n            else putchar(answerTable[buffer[i] - 'A']);\n        }\n        puts(\"\");\n    } else {\n        puts(\"-.\");\n    }\n}\n\nint main() {\n    while (scanf(\"%d\", &nDict) == 1) {\n        if (nDict == 0) break;\n        for (int i = 1; i <= nDict; i++) {\n            std::string buffer;\n            std::cin >> dict[i];\n        }\n        nCiph = 0;\n        std::getline(std::cin, buffer);\n        std::getline(std::cin, buffer);\n        for (int i = 0; i < buffer.length(); i++) {\n            static std::string tmp; \n            if (isalpha(buffer[i])) {\n                tmp = tmp + buffer[i];\n            } else {\n                ciph[++nCiph] = tmp;\n                tmp = \"\";\n            }\n        }\n        std::sort(dict + 1, dict + nDict + 1);\n        std::sort(ciph + 1, ciph + nCiph + 1);\n        nDict = std::unique(dict + 1, dict + nDict + 1) - dict - 1;\n        nCiph = std::unique(ciph + 1, ciph + nCiph + 1) - ciph - 1;\n        std::sort(dict + 1, dict + nDict + 1, cmpByLength);\n        std::sort(ciph + 1, ciph + nCiph + 1, cmpByLength);\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n \nusing namespace std;\n \ntypedef long long ll;\n \nint n,found,buf_length;\nvector<string> word[30],buf;\nstring sequence;\nchar transfer[26];\nvector<ll> bitmask;\nvector<int> bc;\nset<string> exist;\nchar table[26];\nbool depth[26];\n \nbool cmp(const string& a,const string& b){ return a.size() > b.size(); }\n \nvoid dfs(int cur,long long bit,int dph){\n \n  if( found >= 2 ) return;\n \n  if( cur >= buf_length ){\n    found++;\n    rep(i,26) transfer[i] = table[i];\n    return;\n  }\n \n  int len = buf[cur].size();\n \n  if( __builtin_popcountll( bit & bitmask[cur] ) == bc[cur] ) {\n    string tmp = buf[cur];\n    rep(i,len) tmp[i] = table[tmp[i]-'A'];\n    if( exist.find(tmp) != exist.end() ) dfs(cur+1,bit,dph+1);\n    return;\n  }\n \n  rep(i,word[len].size()){\n    bool error = false;\n    long long new_bit = bit;\n    int ep = len;\n    rep(j,len){\n      if( table[buf[cur][j]-'A'] == '?' && table[word[len][i][j]-'A'] == '?' ) {\n        long long SHIFT = word[len][i][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        SHIFT = buf[cur][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        table[buf[cur][j]-'A']     = word[len][i][j];\n        table[word[len][i][j]-'A'] = buf[cur][j];\n        depth[buf[cur][j]-'A'] = dph;\n        depth[word[len][i][j]-'A'] = dph;\n      } else if( !( table[buf[cur][j]-'A'] == word[len][i][j] && table[word[len][i][j]-'A'] == buf[cur][j] ) ) {\n        error = true;\n        ep = j+1;\n        break;\n      }\n    }\n \n    if( !error ) dfs(cur+1,new_bit,dph+1);\n    rep(j,ep){\n      int idx = buf[cur][j] - 'A';\n      int idx2 = word[len][i][j] - 'A';\n      if( depth[idx] == dph || depth[idx2] == dph ){\n        //table[idx] = tmp_table[idx];\n        //table[idx] = tmp_table[idx];\n        table[idx] = table[idx2] = '?';\n      }\n    }\n    if( found >= 2 ) return;\n  }\n}\n \nint main(){\n  while( cin >> n, n ){\n    string tmp;\n    found = 0;\n    buf.clear(), tmp.clear();\n    rep(i,26)transfer[i] = table[i] = '?';\n    rep(i,30) word[i].clear();\n    rep(i,n){\n      cin >> tmp;\n      word[(int)tmp.size()].push_back(tmp);\n      exist.insert(tmp);\n    }\n    cin.ignore();\n    getline(cin,sequence);\n    tmp = sequence.substr(0,(int)sequence.size()-1);\n    stringstream ss(tmp);\n    while( !( ss >> tmp ).fail() ) buf.push_back(tmp);\n \n    sort(buf.begin(),buf.end(),cmp);\n    buf.erase(unique(buf.begin(),buf.end()),buf.end());\n    buf_length = (int) buf.size();\n    bitmask.clear(), bc.clear();\n    bitmask.resize(buf_length,0), bc.resize(buf_length);\n    rep(i,buf_length){\n      rep(j,buf[i].size()){\n        long long SHIFT = buf[i][j] - 'A';\n        bitmask[i] |= (1LL<<SHIFT);\n      }\n      bc[i] = __builtin_popcountll(bitmask[i]);\n    }\n \n    dfs(0,0LL,0);\n \n    if( found == 1 ) {\n      rep(i,sequence.size()) cout << (isupper(sequence[i])?transfer[sequence[i]-'A']:sequence[i]);\n      puts(\"\");\n    } else puts(\"-.\");\n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n   \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n   \nusing namespace std;\n   \ntypedef long long ll;\n   \nint n,found,buf_length;\nvector<string> word[30],buf;\nstring sequence;\nchar transfer[26];\nvector<ll> bitmask;\nvector<int> bc;\nset<string> exist;\nchar table[26];\n   \nbool cmp(const string& a,const string& b){ \n  set<char> A,B;\n  rep(i,a.size()) A.insert(a[i]);\n  rep(i,b.size()) B.insert(b[i]);\n  return A.size() > B.size();\n}\n   \nvoid dfs(int cur,long long bit){\n   \n  if( found >= 2 ) return;\n   \n  //rep(i,26) cout << table[i] << \" \";\n  //cout << endl;\n   \n  if( cur >= buf_length ){\n    found++;\n    rep(i,26) transfer[i] = table[i];\n    return;\n  }\n   \n   \n  int len = buf[cur].size();\n   \n  if( __builtin_popcountll( bit & bitmask[cur] ) == bc[cur] ) {\n    string tmp = buf[cur];\n    rep(i,len) tmp[i] = table[tmp[i]-'A'];\n    if( exist.find(tmp) != exist.end() ) dfs(cur+1,bit);\n    return;\n  }\n   \n   \n  char tmp_table[26];\n  rep(i,26) tmp_table[i] = table[i];\n  rep(i,word[len].size()){\n    //cout<< endl;\n    //rep(j,26) cout << table[j] << \" \"; cout << endl;\n    // cout << \"word \" << word[len][i] << \" is \";\n    bool error = false;\n    long long new_bit = bit;\n    //rep(j,26) table[j] = tmp_table[j];\n    rep(j,len){\n   \n   \n      if( table[buf[cur][j]-'A'] == '?' && table[word[len][i][j]-'A'] == '?' ) {\n        long long SHIFT = word[len][i][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        SHIFT = buf[cur][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        table[buf[cur][j]-'A']     = word[len][i][j];\n        table[word[len][i][j]-'A'] = buf[cur][j];\n      } else if( !( table[buf[cur][j]-'A'] == word[len][i][j] && table[word[len][i][j]-'A'] == buf[cur][j] ) ) {\n        //cout << \"table[\" << buf[cur][j] << \"] != \" << table[buf[cur][j]-'A'] << \" ?= \" << word[len][i][j] << endl;\n        //cout << \"table[\" << word[len][i][j] << \"] != \" << table[word[len][i][j]-'A'] << \" ?= \" << buf[cur][j] << endl;\n        error = true;\n        break;\n      }\n    }\n   \n    if( error ){\n      //cout << \"bad\" << endl;\n      continue;\n    } //cout << \"ok\" << endl;\n    dfs(cur+1,new_bit);\n    rep(j,len){\n      int idx = buf[cur][j] - 'A';\n      table[idx] = tmp_table[idx];\n      idx = word[len][i][j] - 'A';\n      table[idx] = tmp_table[idx];\n    }\n    if( found >= 2 ) return;\n  }\n}\n   \nint main(){\n  while( cin >> n, n ){\n    string tmp;\n    found = 0;\n    buf.clear(), tmp.clear();\n    rep(i,26)transfer[i] = table[i] = '?';\n    rep(i,30) word[i].clear();\n    rep(i,n){\n      cin >> tmp;\n      word[(int)tmp.size()].push_back(tmp);\n      exist.insert(tmp);\n    }\n    cin.ignore();\n    getline(cin,sequence);\n    tmp = sequence.substr(0,(int)sequence.size()-1);\n    stringstream ss(tmp);\n    while( !( ss >> tmp ).fail() ) buf.push_back(tmp);\n   \n    sort(buf.begin(),buf.end(),cmp);\n    buf.erase(unique(buf.begin(),buf.end()),buf.end());\n    buf_length = (int) buf.size();\n    bitmask.clear(), bc.clear();\n    bitmask.resize(buf_length,0), bc.resize(buf_length);\n    rep(i,buf_length){\n      rep(j,buf[i].size()){\n        long long SHIFT = buf[i][j] - 'A';\n        bitmask[i] |= (1LL<<SHIFT);\n      }\n      bc[i] = __builtin_popcountll(bitmask[i]);\n    }\n   \n    dfs(0,0LL);\n   \n    if( found == 1 ) {\n      rep(i,sequence.size()) cout << (isupper(sequence[i])?transfer[sequence[i]-'A']:sequence[i]);\n      puts(\"\");\n    } else puts(\"-.\");\n   \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring t, ans;\nvector< string > words, latte[21];\n\nbool rec(int idx, vector< char > &add)\n{\n  if(idx == words.size()) {\n    if(!ans.empty()) return (false);\n    ans = t;\n    for(auto &c : ans) if(isalpha(c)) c = add[c - 'A'];\n    return (true);\n  }\n\n  const string &beet = words[idx];\n  for(auto &str : latte[beet.size()]) {\n    auto temp(add);\n    bool flag = true;\n    for(int i = 0; i < beet.size() && flag; i++) {\n      if(temp[beet[i] - 'A'] != str[i] &&\n         (temp[beet[i] - 'A'] != -1 ||\n          temp[str[i] - 'A'] != -1))\n        flag = false;\n      else {\n        temp[beet[i] - 'A'] = str[i];\n        temp[str[i] - 'A'] = beet[i];\n      }\n    }\n    if(!flag) continue;\n    if(!rec(idx + 1, temp)) return (false);\n  }\n  return (true);\n}\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    for(int i = 0; i < N; i++) {\n      string s;\n      cin >> s;\n      latte[s.size()].emplace_back(s);\n    }\n    cin.ignore();\n    getline(cin, t);\n\n    istringstream sss(t);\n    string q;\n    while(sss >> q) {\n      if(q.back() == '.') q.pop_back();\n      words.emplace_back(q);\n    }\n    sort(begin(words), end(words), [&](const string &a, const string &b)\n    {\n      return (a.size() > b.size());\n    });\n    vector< char > add(26, -1);\n    if(rec(0, add)) cout << ans << endl;\n    else cout << \"-.\\n\";\n    for(int i = 0; i < 21; i++) latte[i].clear();\n    words.clear();\n    ans.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n \nusing namespace std;\n \ntypedef long long ll;\n \nint n,found,buf_length;\nvector<string> word[30],buf;\nstring sequence;\nchar transfer[26];\nvector<ll> bitmask;\nvector<int> bc;\nset<string> exist;\nchar table[26];\nbool depth[26];\n \nbool cmp(const string& a,const string& b){ return a.size() > b.size(); }\n \nvoid dfs(int cur,long long bit,int dph){\n \n  if( found >= 2 ) return;\n \n  if( cur >= buf_length ){\n    found++;\n    rep(i,26) transfer[i] = table[i];\n    return;\n  }\n \n  int len = buf[cur].size();\n \n  if( __builtin_popcountll( bit & bitmask[cur] ) == bc[cur] ) {\n    string tmp = buf[cur];\n    rep(i,len) tmp[i] = table[tmp[i]-'A'];\n    if( exist.find(tmp) != exist.end() ) dfs(cur+1,bit,dph+1);\n    return;\n  }\n\n  char tmp_table[26];\n  rep(i,26) tmp_table[i] = table[i]; \n  rep(i,word[len].size()){\n    bool error = false;\n    long long new_bit = bit;\n    int ep = len;\n    rep(j,len){\n      if( table[buf[cur][j]-'A'] == '?' && table[word[len][i][j]-'A'] == '?' ) {\n        long long SHIFT = word[len][i][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        SHIFT = buf[cur][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        table[buf[cur][j]-'A']     = word[len][i][j];\n        table[word[len][i][j]-'A'] = buf[cur][j];\n        depth[buf[cur][j]-'A'] = dph;\n        depth[word[len][i][j]-'A'] = dph;\n      } else if( !( table[buf[cur][j]-'A'] == word[len][i][j] && table[word[len][i][j]-'A'] == buf[cur][j] ) ) {\n        error = true;\n        ep = j+1;\n        break;\n      }\n    }\n \n    if( !error ) dfs(cur+1,new_bit,dph+1);\n    rep(j,ep){\n      int idx = buf[cur][j] - 'A';\n      int idx2 = word[len][i][j] - 'A';\n      if( depth[idx] == dph || depth[idx2] == dph ){\n        table[idx] = tmp_table[idx];\n        table[idx2] = tmp_table[idx2];\n        //table[idx] = table[idx2] = '?';\n      }\n    }\n    if( found >= 2 ) return;\n  }\n}\n \nint main(){\n  while( cin >> n, n ){\n    string tmp;\n    found = 0;\n    buf.clear(), tmp.clear();\n    rep(i,26)transfer[i] = table[i] = '?';\n    rep(i,30) word[i].clear();\n    rep(i,n){\n      cin >> tmp;\n      word[(int)tmp.size()].push_back(tmp);\n      exist.insert(tmp);\n    }\n    cin.ignore();\n    getline(cin,sequence);\n    tmp = sequence.substr(0,(int)sequence.size()-1);\n    stringstream ss(tmp);\n    while( !( ss >> tmp ).fail() ) buf.push_back(tmp);\n \n    sort(buf.begin(),buf.end(),cmp);\n    buf.erase(unique(buf.begin(),buf.end()),buf.end());\n    buf_length = (int) buf.size();\n    bitmask.clear(), bc.clear();\n    bitmask.resize(buf_length,0), bc.resize(buf_length);\n    rep(i,buf_length){\n      rep(j,buf[i].size()){\n        long long SHIFT = buf[i][j] - 'A';\n        bitmask[i] |= (1LL<<SHIFT);\n      }\n      bc[i] = __builtin_popcountll(bitmask[i]);\n    }\n \n    dfs(0,0LL,0);\n \n    if( found == 1 ) {\n      rep(i,sequence.size()) cout << (isupper(sequence[i])?transfer[sequence[i]-'A']:sequence[i]);\n      puts(\"\");\n    } else puts(\"-.\");\n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nchar str[21][30];\nchar s[100][30];\nchar ori[100][30];\nchar tmp[21];\nint len[100];\nint len1[30];\nint n,m;\nchar match[256];\nint cnt[256];\nchar try_match[256];\nchar ans[256];\nbool has=true;\nbool mul=false;\nvector<int>ids[100];\nvoid dfs(int u){\n\tif(has&&mul)return;\n\tif(u==m){\n\t\tstrcpy(ans,match);\n\t\tif(!has)has=true;\n\t\telse mul=true;\n\t}\n\tfor(int k=0;k<ids[u].size();k++){\n\t\tint i=ids[u][k];\n\t\tif(len1[i]!=len[u])continue;\n\t\tbool pass=true;\n\t\tfor(int j=0;j<len[u];j++){\n\t\t\tif(match[s[u][j]]!=-1){\n\t\t\t\tif(match[s[u][j]]!=str[i][j])pass=false;\n\t\t\t}\n\t\t\tif(!pass)break;\n\t\t}\n\t\tif(pass){\n\t\t\tfor(int k='A';k<='Z';k++)try_match[k]=-1;\n\t\t\tfor(int j=0;j<len[u];j++){\n\t\t\t\tif(match[s[u][j]]==-1){\n\t\t\t\t\tif(try_match[s[u][j]]!=-1&&try_match[s[u][j]]!=str[i][j])pass=false;\n\t\t\t\t\ttry_match[s[u][j]]=str[i][j];\n\t\t\t\t\tif(match[str[i][j]]!=-1&&match[str[i][j]]!=s[u][j])pass=false;\n\t\t\t\t\tif(try_match[str[i][j]]!=-1&&try_match[str[i][j]]!=s[u][j])pass=false;\n\t\t\t\t\ttry_match[str[i][j]]=s[u][j];\n\t\t\t\t}\n\t\t\t\tif(!pass)break;\n\t\t\t}\n\t\t}\n\t\tif(pass){\n\t\t\tfor(int j=0;j<len[u];j++){\n\t\t\t\tmatch[s[u][j]]=str[i][j];\n\t\t\t\tmatch[str[i][j]]=s[u][j];\n\t\t\t\tcnt[s[u][j]]++;\n\t\t\t\tcnt[str[i][j]]++;\n\t\t\t}\n\t\t\tdfs(u+1);\n\t\t\tfor(int j=0;j<len[u];j++){\n\t\t\t\tcnt[s[u][j]]--;\n\t\t\t\tcnt[str[i][j]]--;\n\t\t\t\tif(cnt[s[u][j]]==0)match[s[u][j]]=-1;\n\t\t\t\tif(cnt[str[i][j]]==0)match[str[i][j]]=-1;\n\t\t\t}\n\t\t}\n\t}\n}\nbool flag[100];\nint main(){\n\twhile(~scanf(\"%d\",&n)&&n){\n\t\tmemset(match,-1,sizeof(match));\n\t\tmemset(cnt,0,sizeof(cnt));\n\t\thas=false;\n\t\tmul=false;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%s\",str[i]);\n\t\t}\n\t\tm=0;\n\t\twhile(scanf(\"%s\",s[m++])!=EOF){\n\t\t\tif(s[m-1][strlen(s[m-1])-1]=='.'){\n\t\t\t\ts[m-1][strlen(s[m-1])-1]='\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tflag[i]=false;\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(strcmp(str[i],str[j])==0)flag[i]=true;\n\t\t\t}\n\t\t}\n\t\tint c=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(!flag[i]){\n\t\t\t\tstrcpy(str[c++],str[i]);\n\t\t\t}\n\t\t}\n\t\tn=c;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tflag[i]=false;\n\t\t\tfor(int j=i+1;j<m;j++){\n\t\t\t\tif(strcmp(s[i],s[j])==0)flag[i]=true;\n\t\t\t}\n\t\t}\n\t\tc=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(!flag[i]){\n\t\t\t\tstrcpy(s[c++],s[i]);\n\t\t\t}\n\t\t}\n\t\tm=c;\n\t\tfor(int i=0;i<m;i++)strcpy(ori[i],s[i]);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<m-1;j++){\n\t\t\t\tif(strlen(s[j])<strlen(s[j+1])){\n\t\t\t\t\tstrcpy(tmp,s[j]);\n\t\t\t\t\tstrcpy(s[j],s[j+1]);\n\t\t\t\t\tstrcpy(s[j+1],tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n-1;j++){\n\t\t\t\tif(strlen(str[j])<strlen(str[j+1])){\n\t\t\t\t\tstrcpy(tmp,str[j]);\n\t\t\t\t\tstrcpy(str[j],str[j+1]);\n\t\t\t\t\tstrcpy(str[j+1],tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)len1[i]=strlen(str[i]);\n\t\tfor(int i=0;i<m;i++)len[i]=strlen(s[i]);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tids[i].clear();\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(len[i]==len1[j]){\n\t\t\t\t\tids[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdfs(0);\n\t\tif(has&&!mul){\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint l=strlen(ori[i]);\n\t\t\t\tfor(int j=0;j<l;j++){\n\t\t\t\t\tprintf(\"%c\",ans[ori[i][j]]);\n\t\t\t\t}\n\t\t\t\tif(i!=m-1)printf(\" \");\n\t\t\t\telse printf(\".\\n\");\n\t\t\t}\n\t\t}else{\n\t\t\tprintf(\"-.\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cstring>\n#include <sstream>\nusing namespace std;\n\nint n, m;\nstring cand[22];\nvector<string> words;\n\nvector<int> match[82];\nint matchBit[82];\n\nvector<char> ansKey;\nint ansFlg;\n\nbool matches(string a, string b){\n  if(a.size() != b.size()) return false;\n  char trans[128];\n  memset(trans, -1, sizeof(trans));\n  for(int i = 0; i < a.size(); i++){\n    if(trans[a[i]] != -1 && b[i] != trans[a[i]]) return false;\n    if(trans[b[i]] != -1 && a[i] != trans[b[i]]) return false;\n    trans[a[i]] = b[i];\n    trans[b[i]] = a[i];\n  }\n  return true;\n}\n\nbool mycmp(const string &a, const string &b){\n  set<char> st1;\n  for(int i = 0; i < a.size(); i++) st1.insert(a[i]);\n  set<char> st2;\n  for(int i = 0; i < b.size(); i++) st2.insert(b[i]);\n\n  return st1.size() > st2.size();\n}\n\nbool setKey(const string &a, const string &b, vector<char> &key){\n  for(int i = 0; i < a.size(); i++){\n    if(key[a[i]] != -1 && key[a[i]] != b[i] ||\n       key[b[i]] != -1 && key[b[i]] != a[i]){\n      return false;\n    }\n    key[a[i]] = b[i];\n    key[b[i]] = a[i];\n  }\n  return true;\n}\n\nvoid dfs(int idx, int used, vector<char> key){\n  if(idx == m){\n    if(ansFlg == 1){\n      ansFlg = -1;\n    }\n    else{\n      ansFlg = 1;\n      ansKey = key;\n    }\n    return;\n  }\n\n  for(int i = idx; i < m; i++){\n    if((matchBit[i] & used) == matchBit[i]){\n      return;\n    }\n  }\n\n  for(int i = 0; i < match[idx].size(); i++){\n    int j = match[idx][i];\n    if(used & (1 << j)) continue;\n\n    vector<char> nextKey = key;\n    if(setKey(words[idx], cand[j], nextKey)){\n      dfs(idx + 1, used | (1 << j), nextKey);\n      if(ansFlg == -1) return;\n    }\n  }\n}\n\nvoid solve(){\n  sort(words.begin(), words.end(), mycmp);\n\n  for(int i = 0; i < m; i++){\n    match[i].clear();\n    matchBit[i] = 0;\n\n    for(int j = 0; j < n; j++){\n      if(matches(words[i], cand[j])){\n        match[i].push_back(j);\n        matchBit[i] |= (1 << j);\n      }\n    }\n  }\n\n  vector<char> key(128, -1);\n  ansFlg = 0;\n  dfs(0, 0, key);\n}\n\nint main(){\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++){\n      cin >> cand[i];\n\n      for(int j = 0; j < i; j++){\n        if(cand[j] == cand[i]){\n          i--;\n          n--;\n          break;\n        }\n      }\n    }\n\n    string s;\n    getline(cin, s);\n    getline(cin, s);\n    for(int i = 0; i < s.size(); i++) if(s[i] == '.') s[i] = ' ';\n\n    vector<string> raw;\n    stringstream ss(s);\n    words.clear();\n\n    while(ss >> s){\n      raw.push_back(s);\n\n      bool pushFlg = true;\n      for(int i = 0; i < words.size(); i++){\n        if(words[i] == s){\n          pushFlg = false;\n          break;\n        }\n      }\n      if(pushFlg) words.push_back(s);\n    }\n    m = words.size();\n\n    solve();\n\n    if(ansFlg == 1){\n      for(int i = 0; i < raw.size(); i++){\n        if(i != 0) cout << \" \";\n        for(int j = 0; j < raw[i].size(); j++){\n          cout << ansKey[raw[i][j]];\n        }\n      }\n      cout << \".\" << endl;\n    }\n    else{\n      cout << \"-.\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nstring t[100];\nbool used[100];\nvector<string> v;\nmap< char , char > mp;\ntypedef pair< char , char > P;\n\nbool check( vector<int> a, string b , vector<int> c, string d ){\n  int size=a.size();\n  map< char , set<int> > T;\n  for(char ch='A';ch<='Z';ch++){\n    if(mp.count(ch)){\n      T[ch].insert(mp[ch]);\n    }\n  }\n  \n  for(int i=0;i<size;i++){\n    if(a[i]==-1)continue;\n    T[ b[i] ].insert( d[i] );\n    T[ d[i] ].insert( b[i] );\n    if( T[ b[i] ].size() > 1 )return false;\n    if( T[ d[i] ].size() > 1 )return false;\n  }\n  return true;\n}\n\nstring Replace(string s,bool flag=false){\n  for(int i=0;i<(int)s.size();i++){\n    if(mp.count(s[i]))s[i]=mp[s[i]];\n    else{\n      if(flag)s[i]='?';\n    }\n  }\n  return s;\n}\n\nvector<int> change(string s){\n  vector<int> res(s.size());\n  map<char,int> flg;\n  for(int i=0;i<(int)s.size();i++){\n    if(mp.count(s[i])){\n      res[i]=-1;\n      continue;\n    }\n    if( flg.count(s[i]) ){\n      res[i]=flg[ s[i] ];\n    }else{\n      res[i]=flg.size();\n      flg[ s[i] ]=res[i];\n    }\n  }\n  return res;\n}\n\nvoid Add(string s,string t){\n  for(int i=0;i<(int)s.size();i++){\n    mp[ s[i] ] = t[i];\n    mp[ t[i] ] = s[i];\n  }\n}\n\nbool solve(){\n  set< int > pa;\n  bool update=true;\n  while(update){\n    update=false;\n    vector<int> cnt( v.size(), 0 );\n    \n    for(int i=0;i<n;i++){\n      string str=Replace(t[i],true);\n      vector<int> hashv=change(t[i]);\n      vector<int> target;\n      set< string > st;\n      for(int j=0;j<(int)v.size();j++){\n        if( pa.count(j) )continue;\n        \n        string tmp=Replace(Replace(v[j],true));\n        vector<int> hashw=change(v[j]);\n        if(str==tmp && hashv == hashw && check(hashv,t[i],hashw,v[j])){\n          cnt[j]++;\n        }\n      }\n    }\n\n\n    bool loopf=false;\n    for(int i=0;i<n;i++){\n      \n      string str=Replace(t[i],true);\n      vector<int> hashv=change(t[i]);\n      \n      for(int j=0;j<(int)v.size();j++){\n        string tmp=Replace(Replace(v[j],true));\n        vector<int> hashw=change(v[j]);\n        \n        if(str==tmp && hashv == hashw && cnt[j]==1 && check(hashv,t[i],hashw,v[j])){\n          pa.insert(j);\n          Add(t[i],v[j]);\n          loopf=true;\n          update=true;\n          break;\n        }\n      }\n\n      if(loopf)break;\n    }\n    \n\n  }// while update\n\n  for(int i=0;i<(int)v.size();i++){\n    string tmp=Replace(v[i],true);\n    for(int j=0;j<(int)tmp.size();j++){\n      if(tmp[j]=='?')return false;\n    }\n  }\n  if(pa.size()!=v.size())return false;\n  return true;\n}\n\nvoid init(){\n  v.clear();\n  mp.clear();\n  memset(used,false,sizeof(used));\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++)cin>>t[i];\n    string tmp,str;\n    getline(cin,tmp);\n    getline(cin,tmp);\n    stringstream ss(tmp);\n    while(ss>>str){\n      if( str.back() == '.' )str.pop_back();\n      v.push_back(str);\n    }\n    if( solve() ){\n      for(int i=0;i<(int)v.size();i++){\n        if(i)cout<<' ';\n        cout<<Replace(v[i]);\n      }\n      cout<<'.'<<endl;\n    }else{\n      cout<<\"-.\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint N;\nstring sentence;\nstring words[20];\nvector<char> pairs(256);\nvector<string> ans;\nset< vector<char> > memo[100];\nstring replace(string s){\n  REP(i, s.size())if(isalpha(s[i])) s[i] = pairs[s[i]];\n  return s;\n}\nvoid dfs(int k, vector<string>& targets){\n  if(memo[k].count(pairs)) return;\n  memo[k].insert(pairs);\n  if(k == targets.size()) {\n    ans.push_back(replace(sentence));\n    return;\n  }\n  string target = targets[k];\n  int tmppairs[256];\n  REP(i, 256) tmppairs[i] = pairs[i];\n  REP(i, N)if(words[i].size() == target.size()){\n    string word = words[i];\n    bool ok = true;\n    REP(j, word.size())if(pairs[word[j]] != -1 && pairs[word[j]] != target[j]) ok = false;\n    if(!ok) continue;\n    REP(j, word.size()){\n      pairs[word[j]] = target[j];\n      pairs[target[j]] = word[j];\n    }\n    REP(j, word.size())if(pairs[word[j]] != -1 && pairs[word[j]] != target[j]) ok = false;\n    if(!ok) continue;\n    dfs(k + 1, targets);\n    REP(i, 256) pairs[i] = tmppairs[i];\n  }\n}\n\nint main(){\n  while(cin>>N && N){\n    REP(i, 256) pairs[i] = -1;\n    ans.clear();\n    REP(i, 100) memo[i].clear();\n    REP(i, N) cin>>words[i];\n    cin.ignore();\n    getline(cin, sentence);\n    vector<string> targets;\n    stringstream ss(sentence);\n    for(string tmp;;){\n      if(!(ss>>tmp)) break;\n      if(tmp[tmp.size()-1] == '.') tmp = tmp.substr(0, tmp.size() - 1);\n      targets.push_back(tmp);\n    }\n    REP(i, targets.size())FOR(j, i+1, targets.size()) if(targets[i].size() < targets[j].size()) swap(targets[i], targets[j]);\n    dfs(0, targets);\n    if(ans.size() == 1) cout<<ans[0]<<endl;\n    else cout<<\"-.\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cstring>\n#include <sstream>\nusing namespace std;\n\nint n, m;\nstring cand[22];\nvector<string> words;\n\nvector<int> match[82];\nint matchBit[82];\n\nvector<char> ansKey;\nint ansFlg;\n\nbool matches(string a, string b){\n  if(a.size() != b.size()) return false;\n  char trans[128];\n  memset(trans, -1, sizeof(trans));\n  for(int i = 0; i < a.size(); i++){\n    if(trans[a[i]] != -1 && b[i] != trans[a[i]]) return false;\n    if(trans[b[i]] != -1 && a[i] != trans[b[i]]) return false;\n    trans[a[i]] = b[i];\n    trans[b[i]] = a[i];\n  }\n  return true;\n}\n\nbool mycmp(const string &a, const string &b){\n  set<char> st1;\n  for(int i = 0; i < a.size(); i++) st1.insert(a[i]);\n  set<char> st2;\n  for(int i = 0; i < b.size(); i++) st2.insert(b[i]);\n\n  return st1.size() > st2.size();\n}\n\nbool setKey(const string &a, const string &b, vector<char> &key){\n  for(int i = 0; i < a.size(); i++){\n    if(key[a[i]] != -1 && key[a[i]] != b[i]){\n      return false;\n    }\n    key[a[i]] = b[i];\n    key[b[i]] = a[i];\n  }\n  return true;\n}\n\nvoid dfs(int idx, int used, vector<char> key){\n  if(idx == m){\n    if(ansFlg == 1){\n      ansFlg = -1;\n    }\n    else{\n      ansFlg = 1;\n      ansKey = key;\n    }\n    return;\n  }\n\n  for(int i = 0; i < match[idx].size(); i++){\n    int j = match[idx][i];\n    if(used & (1 << j)) continue;\n\n    vector<char> nextKey = key;\n    if(setKey(words[idx], cand[j], nextKey)){\n      dfs(idx + 1, used | (1 << j), nextKey);\n      if(ansFlg == -1) return;\n    }\n  }\n}\n\nvoid solve(){\n  sort(words.begin(), words.end(), mycmp);\n\n  for(int i = 0; i < m; i++){\n    match[i].clear();\n    matchBit[i] = 0;\n\n    for(int j = 0; j < n; j++){\n      if(matches(words[i], cand[j])){\n        match[i].push_back(j);\n        matchBit[i] |= (1 << j);\n      }\n    }\n  }\n\n  vector<char> key(128, -1);\n  ansFlg = 0;\n  dfs(0, 0, key);\n}\n\nint main(){\n  while(cin >> n, n){\n    for(int i = 0; i < n; i++){\n      cin >> cand[i];\n\n      for(int j = 0; j < i; j++){\n        if(cand[j] == cand[i]){\n          i--;\n          n--;\n          break;\n        }\n      }\n    }\n\n    string s;\n    getline(cin, s);\n    getline(cin, s);\n    for(int i = 0; i < s.size(); i++) if(s[i] == '.') s[i] = ' ';\n\n    vector<string> raw;\n    stringstream ss(s);\n    words.clear();\n\n    while(ss >> s){\n      raw.push_back(s);\n\n      bool pushFlg = true;\n      for(int i = 0; i < words.size(); i++){\n        if(words[i] == s){\n          pushFlg = false;\n          break;\n        }\n      }\n      if(pushFlg) words.push_back(s);\n    }\n    m = words.size();\n\n    solve();\n\n    if(ansFlg == 1){\n      for(int i = 0; i < raw.size(); i++){\n        if(i != 0) cout << \" \";\n        for(int j = 0; j < raw[i].size(); j++){\n          cout << ansKey[raw[i][j]];\n        }\n      }\n      cout << \".\" << endl;\n    }\n    else{\n      cout << \"-.\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\nint ord(char c){\n  return c-'A';\n}\n\nvector<pair<char,char> > rec(vector<string> seq,vector<string> word,vector<pair<char,char> > rules,int u){\n  if(seq.empty())return rules;\n  vector<int> uu(seq.size());\n  int mx=-1,x;\n  for(int i=0;i<seq.size();i++){\n    int t=0;\n    int cu=0;\n    for(auto e:seq[i]){\n      int xx=e-'A';\n      if(!(t>>xx&1)){\n\tcu++;\n\tt|=1<<xx;\n      }\n    }\n    if(cu>mx){\n      mx=cu;\n      x=i;\n    }\n  }\n  vector<pair<char,char> > res;\n  for(int j=0;j<word.size();j++){\n    auto e=word[j];\n    if(seq[x].size()!=e.size())continue;\n    vector<pair<char,char> > nr=rules;\n    int nu=u;\n    for(int i=0;i<e.size();i++){\n      int sr=nu>>ord(seq[x][i])&1;\n      int wr=nu>>ord(e[i])&1;\n      if(sr^wr)goto next;\n      if(!sr){\n\tnu|=1<<ord(seq[x][i])|1<<ord(e[i]);\n\tchar l=seq[x][i],h=e[i];\n\tif(h<l){\n\t  swap(l,h);\n\t}\n\tnr.emplace_back(l,h);\n      }else{\n\tchar l=min(seq[x][i],e[i]);\n\tfor(auto f:nr){\n\t  if(f.first==l&&f.second!=max(seq[x][i],e[i]))goto next;\n\t}\n      }\n    }\n    {\n      vector<string> nseq(begin(seq),begin(seq)+x),nword(begin(word),begin(word)+j);\n      nseq.insert(end(nseq),begin(seq)+x+1,end(seq));\n      nword.insert(end(nword),begin(word)+j+1,end(word));\n      auto r=rec(nseq,nword,nr,nu);\n      if(!res.empty()&&!r.empty())throw 0;\n      res=r;\n    }\n  next:\n    ;\n  }\n  return res;\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    vector<string> word(n);\n    for(int i=0;i<n;i++){\n      cin>>word[i];\n    }\n    vector<string> seq;\n    for(string s;;){\n      cin>>s;\n      if(s.back()!='.'){\n\tseq.push_back(s);\n      }else{\n\tseq.push_back(s.substr(0,s.size()-1));\n\tbreak;\n      }\n    }\n    vector<string> useq=seq,uword=word;\n    sort(begin(useq),end(useq));\n    sort(begin(uword),end(uword));\n    useq.erase(unique(begin(useq),end(useq)),end(useq));\n    uword.erase(unique(begin(uword),end(uword)),end(uword));\n    try{\n      auto r=rec(useq,word,{},0);\n      char table[256];\n      for(auto e:r){\n\ttable[e.first]=e.second;\n\ttable[e.second]=e.first;\n      }\n      bool ns=false;\n      for(auto e:seq){\n\tif(ns++){\n\t  cout<<' ';\n\t}\n\tfor(auto f:e){\n\t  cout<<table[f];\n\t}\n      }\n      cout<<'.'<<endl;\n    }catch(...){\n      cout<<\"-.\"<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n,found,buf_length;\nvector<string> word[30],buf;\nstring sequence;\nchar transfer[26];\nvector<ll> bitmask;\nvector<int> bc;\nset<string> exist;\n\nbool cmp(const string& a,const string& b){ return a.size() > b.size(); }\n\nvoid dfs(int cur,vector<char> table,long long bit){\n\n  if( found >= 2 ) return;\n\n  if( cur >= buf_length ){\n    found++;\n    rep(i,26) transfer[i] = table[i];\n    return;\n  }\n\n  int len = buf[cur].size();\n  if( __builtin_popcountll( bit & bitmask[cur] ) == bc[cur] ) {\n    string tmp = buf[cur];\n    rep(i,len) tmp[i] = table[tmp[i]-'A'];\n    if( exist.find(tmp) != exist.end() ) dfs(cur+1,table,bit);\n    return;\n  }\n\n\n  rep(i,word[len].size()){\n    vector<char> ntable = table;\n    bool error = false;\n    long long new_bit = bit;\n    rep(j,len){\n      if( ntable[buf[cur][j]-'A'] == '?' && ntable[word[len][i][j]-'A'] == '?' ) {\n        long long SHIFT = word[len][i][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        SHIFT = buf[cur][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        ntable[buf[cur][j]-'A']     = word[len][i][j];\n        ntable[word[len][i][j]-'A'] = buf[cur][j];\n      } else if( !( ntable[buf[cur][j]-'A'] == word[len][i][j] && ntable[word[len][i][j]-'A'] == buf[cur][j] ) ) {\n        error = true;\n        break;\n      }\n    }\n    if( error ) continue;\n    dfs(cur+1,ntable,new_bit);\n    if( found >= 2 ) return;\n  }\n}\n\nint main(){\n  while( cin >> n, n ){\n    string tmp;\n    found = 0;\n    buf.clear(), tmp.clear();\n    rep(i,26)transfer[i] = '?';\n    rep(i,30) word[i].clear();\n    rep(i,n){\n      cin >> tmp;\n      word[(int)tmp.size()].push_back(tmp);\n      exist.insert(tmp);\n    }\n    cin.ignore();\n    getline(cin,sequence);\n    tmp = sequence.substr(0,(int)sequence.size()-1);\n    stringstream ss(tmp);\n    while( !( ss >> tmp ).fail() ) buf.push_back(tmp);\n\n    sort(buf.begin(),buf.end(),cmp);\n    buf.erase(unique(buf.begin(),buf.end()),buf.end());\n    buf_length = (int) buf.size();\n    bitmask.clear(), bc.clear();\n    bitmask.resize(buf_length,0), bc.resize(buf_length);\n    rep(i,buf_length){\n      rep(j,buf[i].size()){\n        long long SHIFT = buf[i][j] - 'A';\n        bitmask[i] |= (1LL<<SHIFT);\n      }\n      bc[i] = __builtin_popcountll(bitmask[i]);\n    }\n\n    dfs(0,vector<char>(26,'?'),0LL);\n\n    if( found == 1 ) {\n      rep(i,sequence.size()) cout << (isupper(sequence[i])?transfer[sequence[i]-'A']:sequence[i]);\n      puts(\"\");\n    } else puts(\"-.\");\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        vector<string> ws(n);\n        for(auto& w : ws) cin >> w;\n        vector<string> ss = {\"\"};\n        while(cin >> ss.back()) {\n            if(ss.back().back() == '.') break;\n            ss.push_back(\"\");\n        }\n        ss.back().pop_back(); // period\n        const auto ts = ss;\n        sort(begin(ss), end(ss), [] (string s1, string s2) {\n                return set<char>{begin(s1), end(s1)}.size() > set<char>{begin(s2), end(s2)}.size();\n            });\n\n        auto conv = [] (string s, vector<char> const& m) {\n            for(auto& c : s) {\n                c = m[c - 'A'];\n            }\n            return s;\n        };\n        string ans;\n        function<void(int, vector<char>)> dfs = [&] (int i, vector<char> m) {\n            if(ans == \"-.\") return;\n            if(i == (int)ss.size()) {\n                string tans = conv(ts[0], m);\n                for(int j = 1; j < (int)ts.size(); ++j) {\n                    tans += \" \" + conv(ts[j], m);\n                }\n                tans += \".\";\n                if(!ans.empty() && ans != tans) {\n                    ans = \"-.\";\n                } else {\n                    ans = tans;\n                }\n                return;\n            }\n            const auto& s = ss[i];\n            for(auto const& w : ws) {\n                if(s.size() != w.size()) continue;\n                bool check = true;\n                vector<char> tm = m;\n                for(int j = 0; j < (int)s.size(); ++j) {\n                    check &= m[s[j] - 'A'] == w[j] || (m[s[j] - 'A'] == '*' && m[w[j] - 'A'] == '*');\n                    tm[s[j] - 'A'] = w[j];\n                    tm[w[j] - 'A'] = s[j];\n                }\n                if(!check) continue;\n                dfs(i + 1, move(tm));\n            }\n        };\n        dfs(0, vector<char>(26, '*'));\n\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n\nint n;\nvector<string> word;\nvector<string> seq;\nmap<char, int> mp;\nmap<char, char> conv;\nvector< pair<int, char> > ord;\nstring ans;\nint num;\n\nbool check() {\n  rep(i, seq.size()) {\n    bool flag = false;\n    rep(j, word.size()) {\n      if(word[j].size() != seq[i].size()) continue;\n      bool flag2 = true;\n      rep(k, seq[i].size()) {\n\tif(conv[seq[i][k]] == '$') continue;\n\tif(conv[seq[i][k]] != word[j][k]) flag2 = false;\n      }\n      if(flag2) flag = true;\n    }\n    if(!flag) return false;\n  }\n  return true;\n}\n\nvoid dfs(int idx) {\n  //for(auto p : conv) {\n    //cout << p.first << \" \" << p.second << endl;\n  //}\n  //cout << check() << endl;  \n  if(!check()) return;\n  if(idx == ord.size()) {\n    string tmp = \"\";\n    rep(i, seq.size()) {\n      if(i) tmp += \" \";\n      rep(j, seq[i].size()) {\n\ttmp += conv[seq[i][j]];\n      }\n    }\n    ans = tmp;\n    num++;\n    return;\n  }\n  if(conv[ord[idx].second] != '$') {\n    dfs(idx+1);\n    return;\n  }\n  ///cout << ord[idx].second << endl;\n  rep(i, 26) {\n    if(conv[(char)('A'+i)] != '$') continue;\n    conv[ord[idx].second] = (char)('A'+i);\n    conv[(char)('A'+i)] = ord[idx].second;\n    dfs(idx+1);\n    if(num > 1) return;\n    conv[ord[idx].second] = '$';\n    conv[(char)('A'+i)] = '$';\n  }\n}\n\nsigned main(){\n  while(cin >> n, n) {\n    word.clear();\n    word.resize(n);\n    rep(i, n) cin >> word[i];\n    seq.clear();\n    while(1) {\n      string s;\n      cin >> s;\n      seq.push_back(s);\n      if(s.back() == '.') {\n\tseq[seq.size()-1].pop_back();\n\tbreak;\n      }\n    }\n    ord.clear();\n    mp.clear();\n    conv.clear();\n    rep(i, seq.size()) rep(j, seq[i].size()) {\n      if(seq[i][j] == '.') continue;\n      mp[seq[i][j]]++;\n    }\n    for(auto p : mp) {\n      ord.push_back(make_pair(p.second, p.first));\n    }\n    sort(ord.begin(), ord.end(), greater<pair<int, int> >());\n    ans = \"-\";    \n    rep(i, 26) conv[(char)('A'+i)] = '$';\n    conv['.'] = '.';\n    num = 0;\n    dfs(0);\n    //cout << num << endl;\n    if(num != 1) ans = \"-\";\n    cout << ans + \".\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n\nvs dfs(vs &words,vs &c_words,map<char,char> &m,int cur,vs &orig_c_words){\n  vs ret;\n  if(cur==orig_c_words.size()){\n    REP(i,orig_c_words.size()){\n      string s;\n      REP(j,orig_c_words[i].size()){\n        s.push_back(m[orig_c_words[i][j]]);\n      }\n      ret.push_back(s);\n    }\n    return ret;\n  }\n\n  REP(i,words.size()){\n    if(words[i].size()==c_words[cur].size()){\n      map<char,char> nm(m);\n      bool ok=true;\n      REP(j,words[i].size()){\n        map<char,char>::iterator it_i=nm.find(words[i][j]);\n        map<char,char>::iterator it_c=nm.find(c_words[cur][j]);\n        bool ei=it_i!=nm.end();\n        bool ec=it_c!=nm.end();\n        if(ei&&ec){\n          if(it_i->second!=c_words[cur][j]||it_c->second!=words[i][j]){\n            ok=false;\n            break;\n          }\n        }else if(ei||ec){\n          ok=false;\n          break;\n        }else{\n          nm[words[i][j]]=c_words[cur][j];\n          nm[c_words[cur][j]]=words[i][j];\n        }\n      }\n      if(ok){\n        //cerr<<\"cur:\"<<cur<<endl;\n        vs res=dfs(words,c_words,nm,cur+1,orig_c_words);\n        //cerr<<\"res:\"<<res.size()<<endl;\n        if(res.size()>0){\n          if(res.size()==100){\n            return vs(100);\n          }\n          if(ret.size()){\n            return vs(100);\n          }else{\n            ret=res;\n          }\n        }\n      }\n    }\n  }\n  return ret;\n\n}\nbool pred(const string &l,const string &r){\n  if(l.size()==r.size()){\n    return l>r;\n  }else{\n    return l.size()>r.size();\n  }\n}\nint main(){\n  int n;\n  while(cin>>n,n){\n    vs words(n);\n    REP(i,n){\n      cin>>words[i];\n    }\n    string sequence;\n    getline(cin,sequence);\n    getline(cin,sequence);\n    vs c_words;\n    int prev=0;\n    REP(i,sequence.size()){\n      switch(sequence[i]){\n        case ' ':\n        case '.':\n          c_words.push_back(sequence.substr(prev,i-prev));\n          prev=i+1;\n          break;\n      }\n    }\n    vs orig_c_words(c_words);\n    sort(ALL(c_words),pred);\n    map<char,char> m;\n    vs res=dfs(words,c_words,m,0,orig_c_words);\n    if(res.size()&&res.size()<100){\n      REP(i,res.size()){\n        cout<<res[i]<<(i<res.size()-1?\" \":\"\");\n      }\n      cout<<\".\"<<endl;\n    }else{\n      cout<<\"-.\"<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n#define reep(i,a,b) for(int i=a; i<b; i++)\n\nvector<string> func(string input){\n\tvector<string> ret;\n\tstringstream ss;\n\tss << input;\n\tstring s;\n\tvector<pair<int,string> > tmp;\n\twhile(ss>>s){\n\t\tif(s[s.size()-1] == '.') s = s.substr(0,s.size()-1);\n\t\t//ret[s.size()].push_back(s);\t\n\t\tset<char> se;\n\t\trep(i,s.size()){\n\t\t\tse.insert(s[i]);\n\t\t}\n\t\ttmp.push_back(make_pair(-(int)se.size(), s));\n\t}\n\tsort(tmp.begin(), tmp.end());\n\trep(i,tmp.size()){\n\t\tret.push_back(tmp[i].second);\n\t}\n\treturn ret;\n}\n\nvector<vector<int> > ans;\nvector<vector<string> > vv;\n\nbool check(string &a, string &b, vector<int> tik){\n\trep(i,a.size()){\n\t\tint aa = a[i]-'A';\n\t\tint bb = b[i]-'A';\n\t\tif(tik[aa] == -1 && tik[bb] == -1){\n\t\t\ttik[aa] = bb;\n\t\t\ttik[bb] = aa;\n\t\t}\n\t\telse if(tik[aa] == bb && tik[bb] == aa){\n\t\t\tcontinue;\n\t\t}\n\t\telse{\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid update(string &a, string &b, vector<int> &tik){\n\t/*cout<<a<<\" \"<<b<<endl;\n\trep(i,26) cout<<tik[i]<<\" \";\n\tcout<<endl;\n\t*/\n\trep(i,a.size()){\n\t\tint aa = a[i]-'A';\n\t\tint bb = b[i]-'A';\n\t\tif(tik[aa] == -1 && tik[bb] == -1){\n\t\t\ttik[aa] = bb;\n\t\t\ttik[bb] = aa;\n\t\t}\n\t}\n\t/*\n\trep(i,26) cout<<tik[i]<<\" \";\n\tcout<<endl;\n\t*/\n}\n\nvoid saiki(int x, vector<string> &w, vector<int> tik){\n\tif(x == w.size()){\n\t\tans.push_back(tik);\n\t\treturn;\n\t}\n\tstring &s = w[x];\n\tif(ans.size()>=2) return;\n\trep(i,vv[s.size()].size()){\n\t\tif(check(s, vv[s.size()][i], tik)){\n\t\t\tvector<int> tmp = tik;\n\t\t\tupdate(s, vv[s.size()][i], tik);\n\t\t\tsaiki(x+1, w, tik);\n\t\t\ttik = tmp;\t\n\t\t}\n\t}\n}\n\nint main(){\n\tint n;\n\twhile(cin>>n, n){\n\t\t//cout<<n<<endl;\n\t\tvv = vector<vector<string> >(21);\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tvv[s.size()].push_back(s);\n\t\t}\n\t\tstring input;\n\t\tgetline(cin, input);\n\t\tgetline(cin, input);\n\t\t//cout<<input<<endl;\n\t\t//return 0;\n\t\t/*\n\t\tvector<vector<string> > in = func(input);\n\t\trep(i,21){\n\t\t\tsort(in[i].begin(), in[i].end());\n\t\t\tin[i].erase(unique(in[i].begin(), in[i].end()), in[i].end());\n\t\t}\n\t\t*/\n\t\tvector<string> w = func(input);\n\t\t/*\n\t\tfor(int i=20; i>=1; i--){\n\t\t\trep(j,in[i].size()){\n\t\t\t\tw.push_back(in[i][j]);\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tvector<int> tik(26,-1);\n\t\tans.clear();\n\t\tsaiki(0,w,tik);\n\t\tif(ans.size()>1){\n\t\t\tcout<<\"-.\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tvector<int> tik = ans[0];\n\t\t\t/*cout<<\"ttt \"<<endl;\n\t\t\trep(i,26){\n\t\t\t\tcout<<t[i]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t\t*/\n\t\t\trep(i,input.size()){\n\t\t\t\tif(isupper(input[i])){\n\t\t\t\t\t//cout<<input[i]<<\" \"<<tik[input[i]-'A']<<endl;;\n\t\t\t\t\tcout<<char(tik[input[i]-'A']+'A');\t\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcout<<input[i];\n\t\t\t\t}\t\t\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long LL;\ntypedef double DD;\nconst int N = 110;\n\nchar tmp[100][25];\nbool use[27];\nstruct str{\n\tint len,kd;\n\tchar s[25];\n\tvoid in(char *tmp){\n\t\tlen = strlen(tmp + 1);\n\t\tkd = 0;\n\t\tmemset(use,0,sizeof(use));\n\t\tfor(int j = 1; j <= len; j++){\n\t\t\tif(tmp[j] > 'Z' || tmp[j] < 'A')\n\t\t\t\tcontinue;\n\t\t\ts[j] = tmp[j] - 'A';\n\t\t\tif(!use[s[j]])\n\t\t\t\tkd++;\n\t\t\telse\n\t\t\t\tuse[s[j]] = 1;\n\t\t}\n\t}\n\tfriend bool operator <(str a, str b){\n\t\treturn a.kd > b.kd;\n\t}\n}a[N], b[N];\n\nint n, m, num, tot, len[N], ans[30], mat[30], change[30];\nvoid dfs(int now){\n//\tprintf(\"dfs(%d)\\n\",now);\n\tif(now == m + 1){\n\t\tnum++;\n\t\tif(num == 2)\n\t\t\treturn;\n\t\tfor(int i = 0; i <= 25; i++)\n\t\t\tif(mat[i] != -1)\n\t\t\t\tans[i] = mat[i];\n\t\t\telse\n\t\t\t\tans[i] = i;\n\t}\n\tint l = tot + 1;\n\tfor(int i = 1; i <= n; i++)\n\t\tif(a[i].len == b[now].len){\n\t\t\tbool flag = 1;\n\t\t\tfor(int j = 1; j <= a[i].len; j++){\n\t\t\t\tint t1 = a[i].s[j], t2 = b[now].s[j];\n\t\t\t\t//printf(\"%d %d\\n\",t1,t2);\n\t\t\t\tif(mat[t1] == -1 && mat[t2] == -1){\n\t\t\t\t\tchange[++tot] = t1;\n\t\t\t\t\tchange[++tot] = t2;\n\t\t\t\t\tmat[t1] = t2;\n\t\t\t\t\tmat[t2] = t1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(mat[t1] == t2)\n\t\t\t\t\tcontinue;\n\t\t\t\tflag = 0;\n\t\t\t}\n\t\t\t\n\t\t\tif(flag){\n\t\t\t\tdfs(now + 1);\n\t\t\t\tif(num == 2)\n\t\t\t\t\treturn;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int j = l; j <= tot; j++)\n\t\t\t\tmat[change[j]] = -1;\n\t\t\ttot = l - 1;\n\t\t}\n}\n\nint main(){\n//\tfreopen(\"C.in\",\"r\",stdin);\n\tfor(;;){\n\t\tscanf(\"%d\", &n);\n\t\tif(!n)\n\t\t\tbreak;\n\t\tmemset(tmp, 0, sizeof(tmp));\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tscanf(\"%s\", tmp[0] + 1);\n\t\t\ta[i].in(tmp[0]);\n\t\t\tmemset(tmp[0], 0, sizeof(tmp[0]));\n\t\t}\n\t\tm = 0;\n\t\twhile(1){\n\t\t\tm++;\n\t\t\tscanf(\"%s\",tmp[m] + 1);\n\t\t\tb[m].in(tmp[m]);\n\t\t\tlen[m] = strlen(tmp[m] + 1);\n\t\t\tif(tmp[m][len[m]] == '.'){\n\t\t\t\ttmp[m][len[m]] = 0;\n\t\t\t\tb[m].in(tmp[m]);\n\t\t\t\ttmp[m][len[m]] = '.';\n\t\t\t\tbreak;\n\t\t\t}\t\n\t\t}\n\t\tsort(a + 1, a + n + 1);\n\t\tsort(b + 1, b + m + 1);\n/*\n\t\tfor(int i = 1; i <= n; i++)\n\t\t\tputs(a[i].s + 1);\n\t\tfor(int i = 1; i <= m; i++)\n\t\t\tputs(b[i].s + 1);\n*/\n\t\ttot = 0;\n\t\tnum = 0;\n\t\tmemset(mat,-1,sizeof(mat));\n\t\tdfs(1);\n\t\tif(num == 2)\n\t\t\tputs(\"-.\");\n\t\telse{\n\t\t\tfor(int i = 1; i <= m; i++){\n\t\t\t\tif(i == m)\n\t\t\t\t\tlen[i]--;\n\t\t\t\tfor(int j = 1; j <= len[i]; j++){\n\t\t\t\t\ttmp[i][j] = ans[tmp[i][j]-'A'] + 'A';\n\t\t\t\t}\n\t\t\t\tprintf(\"%s\",tmp[i] + 1);\n\t\t\t\tif(i != m)\n\t\t\t\t\tputchar(' ');\n\t\t\t\telse\n\t\t\t\t\tputchar('\\n');\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int N = 20;\n\nint n, ans;\nstring tmp, ans_rev;\nvector<string> words[N+1], cands[N+1];\nbool vis[26];\n\ninline bool valid(string &tar, string &s, string &rev) {\n  for(size_t i = 0; i<s.size(); ++i) {\n    if(rev[s[i]] != -1 && rev[s[i]] != tar[i])\n      return false;\n    if(rev[tar[i]] != -1 && rev[tar[i]] != s[i])\n      return false;\n  }\n  return true;\n}\nvoid dfs(int l, size_t x, string &rev) {\n  if(ans > 1)\n    return;\n  while(l && x >= words[l].size()) {\n    x = 0;\n    --l;\n  }\n  if(l == 0) {\n    ans_rev = rev;\n    //for(auto c : ans_rev)\n    //  cerr << char(c + 'A');\n    //cerr << endl;\n    ++ans;\n    return;\n  }\n  string &tar = words[l][x];\n  for(size_t j = 0; j<cands[l].size(); ++j) {\n    if(vis[j])\n      continue;\n    string &s = cands[l][j];\n    if(valid(tar, s, rev)) {\n      string nrev = rev;\n      size_t i = 0;\n      for(; i<s.size(); ++i)\n        if(nrev[s[i]] == -1) {\n          if(nrev[tar[i]] != -1)\n            break;\n          nrev[s[i]] = tar[i];\n          nrev[tar[i]] = s[i];\n        }\n      if(i != s.size())\n        continue;\n      vis[j] = true;\n      dfs(l, x+1, nrev);\n      vis[j] = false;\n    }\n  }\n}\nvoid cleanup(vector<string>& v) {\n  sort(v.begin(), v.end());\n  v.resize(unique(v.begin(), v.end()) - v.begin());\n}\nvoid init() {\n  for(int i = 0; i<=N; ++i)\n    words[i].clear(), cands[i].clear();\n  ans = 0;\n  memset(vis, 0, sizeof(vis));\n}\nvoid solve() {\n  init();\n  for(int i = 0; i<n; ++i) {\n    cin >> tmp;\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    cands[tmp.size()].push_back(tmp);\n  }\n  vector<string> sent;\n  bool cont = true;\n  while(cont) {\n    cin >> tmp;\n    if(tmp.back() == '.') {\n      tmp.pop_back();\n      cont = false;\n    }\n    sent.push_back(tmp);\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    words[tmp.size()].push_back(tmp);\n  }\n  for(int i = 1; i<=N; ++i)\n    cleanup(words[i]);\n  string rev(26, -1);\n  dfs(N, 0, rev);\n  if(ans == 1) {\n    for(size_t i = 0; i<sent.size(); ++i) {\n      for(auto c : sent[i]) \n        putchar(ans_rev[c - 'A'] == -1 ? c : ans_rev[c - 'A'] + 'A');\n      putchar(i+1 == sent.size() ? '.' : ' ');\n    }\n    puts(\"\");\n  } else\n    puts(\"-.\");\n}\nint main() {\n  while(scanf(\"%d\", &n) == 1 && n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\ntypedef pair<string,int> Psi;\ntypedef vector<int> Vi;\nint N;\nvector<string> ss,words[21];\nvector<Psi> vpsi;\nVi ans;\nbool app[26];\nvoid init(){\n\tans.clear();\n\tss.clear();\n\trep(i,21) words[i].clear();\n\tvpsi.clear();\n\trep(i,26) app[i]=0;\n}\nconst bool lencomp(Psi x,Psi y){\n\treturn x.fs.size()>y.fs.size();\n}\ninline bool eq(Vi& a,Vi& b){\n\trep(i,26) if(app[i]&&a[i]!=b[i]) return 0;\n\treturn 1;\n}\nbool dfs(int x,Vi vi){\n\tif(x==ss.size()){\n\t\tif(!ans.empty()&&!eq(ans,vi)) return false;\n\t\tans=vi;\n\t\treturn true;\n\t}\n\tstring s=ss[x];\n\tint L=s.size();\n\tfor(string w:words[L]){\n\t\tVi nvi=vi;\n\t\tbool ok=1;\n\t\trep(i,L){\n\t\t\tif(nvi[s[i]-'A']>=0&&nvi[s[i]-'A']+'A'!=w[i]){\n\t\t\t\tok=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(nvi[w[i]-'A']>=0&&nvi[w[i]-'A']+'A'!=s[i]){\n\t\t\t\tok=0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnvi[s[i]-'A']=w[i]-'A';\n\t\t\tnvi[w[i]-'A']=s[i]-'A';\n\t\t}\n\t\tif(!ok) continue;\n\t\tif(!dfs(x+1,nvi)) return false;\n\t}\n\treturn true;\n}\nint main(){\n\twhile(true){\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\tinit();\n\t\trep(i,N){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\twords[s.size()].pb(s);\n\t\t}\n\t\tint I=0;\n\t\twhile(true){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\trep(i,s.size()) if(s[i]!='.') app[s[i]-'A']=1;\n\t\t\tif(s.back()=='.'){\n\t\t\t\tvpsi.pb(Psi(s.substr(0,s.size()-1),I++));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvpsi.pb(Psi(s,I++));\n\t\t}\n\t\tsort(all(vpsi),lencomp);\n\t\tfor(Psi psi:vpsi) ss.pb(psi.fs);\n\t\tif(dfs(0,Vi(26,-1))&&!ans.empty()){\n\t\t\tvector<string> vst(ss.size());\n\t\t\trep(i,ss.size()) vst[vpsi[i].sc]=ss[i];\n\t\t\trep(i,vst.size()){\n\t\t\t\trep(j,vst[i].size()){\n\t\t\t\t\tcout<<(char)(ans[vst[i][j]-'A']+'A');\n\t\t\t\t}\n\t\t\t\tcout<<(i+1==vst.size()?\".\\n\":\" \");\n\t\t\t}\n\t\t}else{\n\t\t\tputs(\"-.\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nvector<string> split_sentence(string s){\n  vector<string> res;\n  REP(i, s.size()) if(s[i] == '.') s[i] = ' ';\n  stringstream ss(s);\n  string t;\n  while(ss >> t){ res.push_back(t); }\n  return res;\n}\n\nbool comp(string s, string t){\n  return s.size() > t.size();\n}\n\nclass DFSError{};\n\nbool answer_exist;\nstring answer;\nint mem[80];\nint match[26];\nstring sentence;\nvector<string> words;\nvector<string> ciphers;\nvoid dfs(int k){\n  if(k == ciphers.size()){\n    if(answer_exist) throw DFSError();\n    answer_exist = true;\n    answer = sentence;\n    REP(i, answer.size()) if(isupper(answer[i])) answer[i] = match[answer[i] - 'A'] + 'A';\n  }else{\n    string& cipher = ciphers[k];\n    int save_match[26];\n    memcpy(save_match, match, sizeof match);\n    REP(i, words.size()) if(words[i].size() == cipher.size()){\n      string& word = words[i];\n\n      bool ok = true;\n      REP(j, word.size()){\n        int A = word[j] - 'A';\n        int B = cipher[j] - 'A';\n        if(match[A] == -1 && match[B] == -1){\n          match[A] = B;\n          match[B] = A;\n        }else if(match[A] == B && match[B] == A){\n        }else{\n          //printf(\"match[%c] = %c, match[%c] = %c\\n\", A + 'A', match[A] + 'A', B + 'A', match[B] + 'A');\n          ok = false;\n          break;\n        }\n      }\n      if(ok){\n        mem[k] = i;\n        dfs(k + 1);\n      }\n      memcpy(match, save_match, sizeof match);\n    }\n  }\n}\n\nint main(){\n  int N;\n  while(cin >> N && N){\n    words.assign(N, \"\");\n    REP(i, N) cin >> words[i];\n    cin.ignore();\n\n    getline(cin, sentence);\n    ciphers = split_sentence(sentence);\n\n    sort(words.begin(), words.end());\n    words.erase(unique(words.begin(), words.end()), words.end());\n    sort(ciphers.begin(), ciphers.end(), comp);\n\n    try{\n      answer_exist = false;\n      memset(match, -1, sizeof match);\n      dfs(0);\n      assert(answer_exist);\n      cout << answer << endl;\n    }catch(DFSError e){\n      cout << \"-.\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <cstdio>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\nusing namespace std;\n\nconst int NONE = 0;\n\nstruct table{\n  vector<char> t;\n  table() : t(26, NONE) {}\n\n  bool addRule(char a, char b){\n    if(t[a - 'A'] != NONE && t[a - 'A'] != b) return false;\n    if(t[b - 'A'] != NONE && t[b - 'A'] != a) return false;\n\n    t[a - 'A'] = b;\n    t[b - 'A'] = a;\n    return true;\n  }\n};\n\ninline bool operator < (const table &lhs, const table &rhs){\n  return lhs.t < rhs.t;\n}\n\npair<bool, table> merge(const table &a, const table &b){\n  table t;\n  bool  o = true;\n\n  REP(i, 26){\n    if(a.t[i] == b.t[i]){\n      t.t[i] = a.t[i];\n    }else{\n      if(a.t[i] == NONE)\n        t.t[i] = b.t[i];\n      else if(b.t[i] == NONE)\n        t.t[i] = a.t[i];\n      else{\n        o = false;\n        break;\n      }\n    }\n  }\n\n  return make_pair(o, t);\n}\n\nbool ok[20][40];\nvector<vector<table> > t;\nvector<int> anseq(40);\nvector<int> ans;\nvector<set<table> > memo;\n\nvector<string> _seq;\nvector<string> _word;\n\nint n, m;\n\nvoid dfs(int pos, int flag, table tbl){\n  if(pos == m){\n    if(ans.size()) throw 0;\n    ans = anseq;\n  }else{\n    if(memo[pos].find(tbl) != memo[pos].end())\n      return;\n    memo[pos].insert(tbl);\n\n    // printf(\"pos = %d\\n\", pos);\n\n    REP(i,n) if(ok[i][pos] && (flag & (1 << i)) == 0){\n      pair<bool, table> ret = merge(tbl, t[i][pos]);\n      // printf(\"%s -> %s : %d\\n\", _seq[pos].c_str(), _word[i].c_str(), ret.first);\n      if(ret.first){\n        anseq[pos] = i;\n        dfs(pos + 1, (flag | (1 << i)), ret.second);\n      }\n    }\n  }\n}\n\nstruct cmp{\n  bool operator () (const string &lhs, const string &rhs){\n    return lhs.size() > rhs.size();\n  }\n};\n\nint main(){\n  while(cin >> n, n){\n    vector<string> word(n);\n    vector<string> oseq;\n    vector<string> seq;\n    REP(i, n) cin >> word[i];\n\n    while(true){\n      string tmp; cin >> tmp;\n      if(tmp.find(\".\") != string::npos){\n        tmp = tmp.substr(0, tmp.size() - 1);\n        seq.push_back(tmp);\n        break;\n      }\n      seq.push_back(tmp);\n    }\n\n    oseq = seq; // save original sequence\n\n    sort(seq.begin(), seq.end());\n    seq.erase(unique(seq.begin(), seq.end()), seq.end());\n\n    sort(seq.begin(), seq.end(), cmp());\n\n    m = seq.size();\n    t = vector<vector<table> >(n, vector<table>(m));\n\n    REP(i,n) REP(j,m){\n      if(word[i].size() == seq[j].size()){\n        int len = word[i].size();\n        bool tmp = true;\n\n        REP(k, len){\n          char a = word[i][k];\n          char b = seq[j][k];\n\n          if(!t[i][j].addRule(a, b)){\n            tmp = false;\n            break;\n          }\n        }\n        ok[i][j] = tmp;\n      }else{\n        ok[i][j] = false;\n      }\n    }\n\n    ans = vector<int>();\n    memo = vector<set<table> >(m);\n\n    try{\n      _seq  = seq;\n      _word = word;\n\n      dfs(0, 0, table());\n\n      REP(i, oseq.size()){\n        REP(j, m){\n          if(oseq[i] == seq[j]){\n            cout << word[ans[j]];\n            break;\n          }\n        }\n        if(i == oseq.size() - 1)\n          cout << \".\" << endl;\n        else\n          cout << \" \";\n      }\n    }catch(int e){\n      cout << \"-.\" << endl;\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <queue>\n#define FI first\n#define SE second\nusing namespace std;\nconst double EPS = 1e-10;\nconst int MAXN = 5005;\nconst int INF = 1111111111;\nconst double PI = acos(-1.0);\ntypedef long long LL;\nint dcmp(double x)\n{\n    if(fabs(x)<EPS) return 0;\n    return x<0?-1:1;\n}\nstruct Point{\n    double x,y;\n    void input(){scanf(\"%lf%lf\",&x,&y);}\n}p[MAXN];\n\nbool cmp(double a,double b)\n{\n    return dcmp(a-b)<0;\n}\ndouble ang[MAXN];\nint main()\n{\n    //freopen(\"/home/qitaishui/code/in.txt\",\"r\",stdin);\n    int n;\n    int ca;\n    LL ans,sub,tri;\n    scanf(\"%d\",&ca);\n    while(ca--)\n    {\n        sub = 0;\n        scanf(\"%d\",&n);\n        ans = (LL)n*(n-1)*(n-2)*(n-3)/24;\n        tri = (n-1)*(n-2)*(n-3)/6;\n        for(int i = 0; i < n;i++)\n            p[i].input();\n        int m;\n        for(int i = 0;i < n; i++)\n        {\n            m = 0;\n            for(int j = 0; j < n; j++)\n            {\n                if(i==j) continue;\n                ang[m++] = atan2(p[j].y-p[i].y,p[j].x-p[i].x);\n            }\n            sort(ang,ang+m,cmp);\n            for(int i = 0; i < m;i++)\n                ang[i+m]=2*PI+ang[i];\n            int l,r,s;\n            s = l = 0;\n            r = 1;\n            tri = (n-1)*(n-2)*(n-3)/6;\n            while(l < m)\n            {\n                while(dcmp(ang[l]+PI-ang[r])>=0)\n                    r++,s++;\n                if(s>=2)\n                    tri-=(s-1)*s/2;\n\t\t\t\ts--;\n                l++;\n            }\n            sub+=tri;\n        }\n        cout<<ans-sub<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\nchar w1[22][110];\nchar w2[44][110];\nint w1_cnt, w2_cnt;\nint cw[28];\nint aw[28];\nbool ok[44][22];\nint ok_cnt[44];\nbool vis[44];\nint ans;\n\nbool cal_ok(int i, int j) {\n    if (strlen(w2[i]) != strlen(w1[j])) return false;\n    int tw[28];\n    memcpy(tw, cw, sizeof(tw));\n    for (int k = 0; w2[i][k]; k++) {\n        int c = w2[i][k] - 'A';\n        int d = w1[j][k] - 'A';\n        if (tw[c] != -1 && tw[c] != w1[j][k]) return false;\n        if (tw[d] != -1 && tw[d] != w2[i][k]) return false;\n        tw[c] = w1[j][k];\n        tw[d] = w2[i][k];\n    }\n    return true;\n}\nvoid get_ok() {\n    memset(ok, 0, sizeof(ok));\n    for (int i = 0; i < w2_cnt; i++)\n        for (int j = 0; j < w1_cnt; j++) {\n            ok[i][j] = cal_ok(i, j);\n            if (ok[i][j]) ok_cnt[i]++;\n        }\n}\nvoid print_ok() {\n\tfor (int i = 0; i < w2_cnt; i++) {\n\t\tfor (int j = 0; j < w1_cnt; j++) {\n\t\t\tprintf(\"%d \", ok[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}\n\nint find() {\n    int p = -1;\n    for (int i = 0; i < w2_cnt; i++) if (!vis[i])\n        if (p == -1 || ok_cnt[i] < ok_cnt[p]) p = i;\n    return p;\n}\n\nvoid dfs(int u) {\n    if (ans > 1) return;\n    if (u == -1) {\n        ans++;\n        memcpy(aw, cw, sizeof(aw));\n        return;\n    }\n//    bool tmp[44][22];\n//    int tmp_cnt[44];\n    int tw[28];\n//    memcpy(tmp, ok, sizeof(tmp));\n//    memcpy(tmp_cnt, ok_cnt, sizeof(ok_cnt));\n    memcpy(tw, cw, sizeof(tw));\n    get_ok();\n    for (int i = 0; i < w1_cnt; i++) if (ok[u][i]) {\n        vis[u] = true;\n        for (int j = 0; w2[u][j]; j++) {\n            int c = w2[u][j] - 'A';\n            int d = w1[i][j] - 'A';\n            cw[c] = w1[i][j];\n            cw[d] = w2[u][j];\n        }\n        dfs(find());\n        memcpy(cw, tw, sizeof(tw));\n        vis[u] = false;\n        get_ok();\n//        memcpy(ok_cnt, tmp_cnt, sizeof(tmp_cnt));\n//        memcpy(ok, tmp, sizeof(tmp));\n    }\n}\n\nvoid work() {\n    for (int i = 0; i < w1_cnt; i++)\n        scanf(\"%s\", w1[i]);\n    w2_cnt = 0;\n    while (true) {\n        char str[100];\n        scanf(\"%s\", str);\n        int len = strlen(str);\n        if (str[len - 1] == '.') {\n            str[--len] = 0;\n            strcpy(w2[w2_cnt], str);\n            w2_cnt++;\n            break;\n        } else {\n            strcpy(w2[w2_cnt], str);\n            w2_cnt++;\n        }\n    }\n//for (int i = 0; i < w2_cnt; i++) printf(\"%s \", w2[i]); puts(\".....\");\n    memset(cw, -1, sizeof(cw));\n    get_ok();\n//print_ok();\n    memset(vis, 0, sizeof(vis));\n    int p = find();\n//printf(\"%d\\n\", p);\n    ans = 0;\n    dfs(p);\n    if (ans > 1) {\n        puts(\"-.\");\n        return;\n    }\n//for (int i = 0; i < 26; i++) printf(\"%d \", aw[i]); puts(\"?\");\n    for (int i = 0; i < w2_cnt; i++) {\n        for (int j = 0; w2[i][j]; j++) {\n            int d = w2[i][j] - 'A';\n            printf(\"%c\", aw[d]);\n        }\n        if (i < w2_cnt - 1) printf(\" \");\n    }\n    puts(\".\");\n}\n\nint main() {\n    while (scanf(\"%d\", &w1_cnt), w1_cnt) {\n        work();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<string>\n#include<map>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nbool cmp(const string &a,const string &b)\n{\n    return a.size()>b.size();\n}\nstring pattern[30];\nstring matcher[80];\nint table[30];\nint result[30];\nstring origion[80];\nint total=0,n;\nbool vis[30];\nbool ok(int i,int t)\n{\n    for(int j=0;j<matcher[i].size();j++)\n    if((table[matcher[i][j]] !=-1 && table[matcher[i][j]]!=pattern[t][j]) ||(table[pattern[t][j]]!=-1 && table[pattern[t][j]]!=matcher[i][j]))\n    return 0;\n    return 1;\n}\nbool update(int i,int t)\n{\n    for(int j=0;j<matcher[i].size();j++)\n    {\n        if(table[matcher[i][j]]==-1 && table[pattern[t][j]]==-1)\n        {\n            table[matcher[i][j]]=pattern[t][j];\n            table[pattern[t][j]]=matcher[i][j];\n        }\n        else\n        if(table[matcher[i][j]]!=pattern[t][j] || table[pattern[t][j]] !=matcher[i][j])\n        return false;\n    }\n    return true;\n}\nint cnt=0;\nint dfs(int i)\n{\n   if(i>=total)\n   {\n       memcpy(result,table,sizeof(table));\n       return 1;\n   }\n   int buffer[30];\n   int ans=0;\n   for(int t=0;t<n;t++)\n   {\n       if(matcher[i].size() == pattern[t].size())\n       {\n           if(ok(i,t))\n           {\n               memcpy(buffer,table,sizeof(table));\n               if(update(i,t))\n                {\n                    int t=dfs(i+1);\n                    if(t<0)\n                    return -1;\n                    ans+=dfs(i+1);\n                }\n               memcpy(table,buffer,sizeof(table));\n           }\n           if(ans>1)\n           return -1;\n       }\n   }\n   return ans;\n}\nvoid modify(string &s)\n{\n    for(int i=0;i<s.size();i++)\n    {\n        s[i]-='A';\n    }\n}\nint main()\n{\n    //freopen(\"text.txt\",\"w\",stdout);\n    while(~scanf(\"%d\",&n),n)\n    {\n        memset(vis,0,sizeof(vis));\n        memset(table,-1,sizeof(table));\n        total=0;\n        for(int i=0;i<n;i++)\n        {\n            cin>>pattern[i];\n            modify(pattern[i]);\n        }\n        string tmp;\n        while(cin>>tmp)\n        {\n            if(tmp[tmp.size()-1]=='.')\n            {\n                 matcher[total++]=tmp.substr(0,tmp.size()-1);\n                 modify(matcher[total-1]);\n                 origion[total-1]=matcher[total-1];\n                 break;\n            }\n            else\n            {\n                matcher[total++]=tmp;\n                modify(matcher[total-1]);\n                origion[total-1]=matcher[total-1];\n            }\n        }\n        sort(matcher,matcher+total);\n        sort(pattern,pattern+n);\n        if(dfs(0)<=0)\n        printf(\"-.\\n\");\n        else\n        {\n            for(int i=0;i<total;i++)\n            {\n                for(int j=0;j<origion[i].size();j++)\n                {\n                    printf(\"%c\",result[origion[i][j]]+'A');\n                }\n                if(i!=total-1)\n                printf(\" \");\n            }\n            printf(\".\\n\");\n        }\n    }\n    return 0;\n}\n/*\n20\nA B C D E F G H I J K L M N O P Q R S T\nA B C D E F G H I J K L M N O P Q R S T.\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint n;\nstring sq;\nvector<string> a[21];\nvector<string> b[21];\nset<string> S;\nbool a_used[500];\nbool b_used[500];\n\nvoid init(){\n\tsq.clear();\n\tS.clear();\n\tfor(int i=0 ; i < 21 ; i++ ){\n\t\ta[i].clear();\n\t\tb[i].clear();\n\t}\n\tfor(int i=0 ; i < 500 ; i++ ){\n\t\ta_used[i] = b_used[i] = false;\n\t}\n}\n\nbool check(const string& s, const string& t, const vector<char>& h){\n\tif( s.size() != t.size() ) return false;\n\t\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\t/*if( !((h[s[i]] == -1 || h[s[i]] == t[i] ) && (h[t[i]] == -1 || h[t[i]] == s[i]) ) ){\n\t\t\treturn false;\n\t\t}*/\n\t\tif( h[s[i]] != -1 ){\n\t\t\tif( h[h[s[i]]] != -1 && h[s[i]] != h[h[s[i]]] ) return false;\n\t\t\tif( h[t[i]] != -1 && h[s[i]] != h[t[i]] ) return false;\n\t\t}\n\t\tif( h[t[i]] != -1 ){\n\t\t\tif( h[h[t[i]]] != -1 && h[t[i]] != h[h[t[i]]] ) return false;\n\t\t\tif( h[s[i]] != -1 && h[s[i]] != h[t[i]] ) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid solve(vector<char>& h, int x, int& z){\n\tz++;\n\tif( z >= 1e+6 ) return;\n\tif( S.size() >= 2 ) return;\n\t\n\tbool flag = true;\n\tfor(int i=0 ; i < sq.size() ; i++ ){\n\t\tif( sq[i] == ' ' || sq[i] == '.' ) continue;\n\t\tif( h[sq[i]] == -1 ){\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif( flag ){\n\t\tstring str;\n\t\tfor(int i=0 ; i < sq.size() ; i++ ){\n\t\t\tif( sq[i] == ' ' || sq[i] == '.' ){\n\t\t\t\tstr.push_back( sq[i] );\n\t\t\t}else{\n\t\t\t\tstr.push_back( h[sq[i]] );\n\t\t\t}\n\t\t}\n\t\tS.insert( str );\n\t}\n\tif( S.size() >= 2 ) return;\n\t\n\tfor(int k=x ; k > 0 ; k-- ){\n\t\tif( a[k].empty() || b[k].empty() ) continue;\n\t\t\n\t\tfor(int i=0 ; i < a[k].size() ; i++ ){\n\t\t\tif( a_used[(i+1)*(k+1)] ) continue;\n\t\t\t\n\t\t\tfor(int j=0 ; j < b[k].size() ; j++ ){\n\t\t\t\tif( b_used[(j+1)*(k+1)] ) continue;\n\t\t\t\t\n\t\t\t\tstring s = a[k][i], t = b[k][j];\n\t\t\t\t\n\t\t\t\t/*bool f = check(s,t,h);\n\t\t\t\tif( f ){\n\t\t\t\t\tvector<char> h_ = h;\n\t\t\t\t\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\t\t\t\t\th_[s[i]] = t[i];\n\t\t\t\t\t\th_[t[i]] = s[i];\n\t\t\t\t\t}\n\t\t\t\t\tsolve(h_);\n\t\t\t\t\treturn;\n\t\t\t\t}*/\n\t\t\t\tvector<char> h_ = h;\n\t\t\t\tbool f = true;\n\t\t\t\tfor(int l=0 ; l < s.size() ; l++ ){\n\t\t\t\t\tif( h_[s[l]] == -1 || h_[s[l]] == t[l] ){\n\t\t\t\t\t\th_[s[l]] = t[l];\n\t\t\t\t\t\tif( h_[t[l]] == -1 || h_[t[l]] == s[l] ){\n\t\t\t\t\t\t\th_[t[l]] = s[l];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*cout << s << \" <=> \" << t << (f? \" OK\" : \" NG\") << endl;\n\t\t\t\tbool cc[256] = {false};\n\t\t\t\tfor(char c='A' ; c <= 'Z' ; c++ ){\n\t\t\t\t\tif( h_[c] != -1 && !cc[c] ){\n\t\t\t\t\t\tcc[c] = cc[h_[c]] = true;\n\t\t\t\t\t\tcout << c << \":\" << h_[c] << \", \";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << endl << endl;*/\n\t\t\t\t\n\t\t\t\tif( f ){\n\t\t\t\t\ta_used[(i+1)*(k+1)] = b_used[(j+1)*(k+1)] = true;\n\t\t\t\t\tsolve(h_,k,z);\n\t\t\t\t\ta_used[(i+1)*(k+1)] = b_used[(j+1)*(k+1)] = false;\n\t\t\t\t\t//return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i=0 ; i < a[k].size() ; i++ ){\n\t\t\tif( a_used[(i+1)*(k+1)] ) cnt++;\n\t\t}\n\t\tif( cnt != a[k].size() ) return;\n\t}\n}\n\nint main(){\n\twhile( cin >> n , n ){\n\t\tinit();\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\ta[s.size()].push_back(s);\n\t\t}\n\t\twhile( true ){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tif( s[s.size()-1] == '.' ){\n\t\t\t\tsq += s;\n\t\t\t\tb[s.size()-1].push_back( s.substr(0,s.size()-1) );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsq += s + \" \";\n\t\t\tb[s.size()].push_back( s );\n\t\t}\n\t\tvector<char> h(256);\n\t\tfor(char c='A' ; c <= 'Z' ; c++ ) h[c] = -1;\n\t\tint z=0;\n\t\tsolve(h,20,z);\n\t\t\n\t\t//cout << sq << endl;\n\t\tif( S.size() == 1 ){\n\t\t\tcout << *S.begin() << endl;\n\t\t}else{\n\t\t\tcout << \"-.\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n\nusing namespace std;\n\n\n\nvector<string> v;\nvector<string> vv;\nset<string> vvv[21];\n\n\nvector<string> s[21];\n\nchar r[256];\nchar ans[256];\nint n,cnt;\n\n\nvoid dfs(int d){\n\n\n  if(d==vv.size()){\n    cnt++;\n    for(int i='A';i<='Z';i++)ans[i]=r[i];\n    return;\n  }\n\n  int sz=vv[d].size();\n\n  char tmp[26];\n\n  for(int i='A';i<='Z';i++)tmp[i-'A']=r[i];\n  \n  for(int i=0;i<s[sz].size();i++){\n    bool f=1;\n    \n    for(int j=0;j<s[sz][i].size();j++){\n\n      if(r[s[sz][i][j]]!=0 && r[vv[d][j]] !=0 ){\n\tif(vv[d][j]!=r[s[sz][i][j]] || r[vv[d][j]]!=s[sz][i][j]) f=0;\n      }\n      else if(r[s[sz][i][j]]==0 && r[vv[d][j]]==0) r[vv[d][j]]=s[sz][i][j], r[s[sz][i][j]]=vv[d][j];\n      else f=0;\n    }\n    \n    if(f&&cnt<=1)dfs(d+1);\n    \n\n    for(int i='A';i<='Z';i++)r[i]=tmp[i-'A'];\n    \n  }\n}\n\n\nint main(){\n\n  while(cin>>n,n){\n    string str;\n    v.clear();\n    vv.clear();\n    for(int i=0;i<21;i++)s[i].clear(),vvv[i].clear();\n\n    for(int i='A';i<='Z';i++)r[i]=0;\n\n    cnt=0;\n    \n    for(int i=0;i<n;i++){\n      cin>>str;\n      s[str.size()].push_back(str);\n    }\n    \n    bool f=1;\n    \n    while(cin>>str){\n      \n      if(str[str.size()-1]=='.'){\n\tstr=str.substr(0,str.size()-1);\n\tf=0;\n      }\n      v.push_back(str);\n      vvv[str.size()].insert(str);\n      if(!f) break;\n    }\n\n    vv=v;\n    for(int i=1;i<vv.size();i++)\n      for(int j=i;j>0;j--){\n\tif(vv[j-1].size()<=vv[j].size())\n\t  swap(vv[j],vv[j-1]);\n      }\n    \n    for(int i=0;i<=20;i++)\n      if(vvv[i].size()>s[i].size())cnt=2;\n    \n    if(!cnt)dfs(0);\n    \n    if(cnt==1){\n\n      for(int i=0;i<v.size();i++){\n\tfor(int j=0;j<v[i].size();j++){\n\t  if(ans[v[i][j]]==0)cout<<v[i][j];\n\t  else cout<<(char)ans[v[i][j]];\n\t}\n\tif(i!=v.size()-1)cout<<\" \";\n      }\n    }\n\n    else cout<<\"-\";\n\n    cout<<\".\"<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n#define NUM 21\n\nvoid strcpy(char* to,char* str);\n\nstruct Info{\n\tInfo(char arg_word[NUM],int arg_length){\n\t\tstrcpy(word,arg_word);\n\t\tlength = arg_length;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn length > arg.length;\n\t}\n\tchar word[NUM];\n\tint length;\n};\n\n\nint N;\nint num_finish;\nint num_word[NUM];\nchar sequence[100];\nchar table[26],ans_table[26];\nchar plain_word[NUM][20][NUM];\nvector<Info> V;\n\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nint getNUM(char ch){\n\treturn ch-'A';\n}\n\nvoid recursive(int index){\n\n\tif(num_finish >= 2){\n\t\treturn;\n\t}\n\n\tif(index == V.size()){\n\n\t\tnum_finish++;\n\t\tfor(int i = 0; i < 26; i++){\n\t\t\tans_table[i] = table[i];\n\t\t}\n\n\t\treturn;\n\t}\n\n\tint tmp_len;\n\tchar tmp_ch;\n\tbool FLG,is_match;\n\n\tfor(int i = index; i < V.size(); i++){\n\n\t\ttmp_len = V[i].length;\n\n\t\tFLG = false;\n\n\t\tfor(int k = 0; k < num_word[tmp_len]; k++){\n\n\t\t\tis_match = true;\n\t\t\tfor(int loc = 0; loc < tmp_len; loc++){\n\n\t\t\t\ttmp_ch = table[getNUM(V[i].word[loc])];\n\n\t\t\t\tif((V[i].word[loc] == plain_word[tmp_len][k][loc] && tmp_ch == '?') ||\n\t\t\t\t\t\t(tmp_ch == '?' && table[getNUM(plain_word[tmp_len][k][loc])] == '?') ||\n\t\t\t\t\t\t(tmp_ch == plain_word[tmp_len][k][loc])\n\t\t\t\t\t\t){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tis_match = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(is_match){\n\t\t\t\tFLG = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(!FLG){\n\t\t\treturn;\n\t\t}\n\t}\n\n\tchar work[26];\n\n\ttmp_len = V[index].length;\n\n\tfor(int i = 0; i < num_word[tmp_len]; i++){\n\n\t\tfor(int k = 0; k < 26; k++){\n\t\t\twork[k] = table[k];\n\t\t}\n\n\t\tis_match = true;\n\n\t\tfor(int k = 0; k < tmp_len; k++){\n\n\t\t\tif((tmp_ch = table[getNUM(V[index].word[k])]) != '?'){\n\n\t\t\t\tif(tmp_ch != plain_word[tmp_len][i][k]){\n\t\t\t\t\tis_match = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}else{\n\n\t\t\t\tif(table[getNUM(plain_word[tmp_len][i][k])] != '?'){\n\t\t\t\t\tis_match = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\ttable[getNUM(V[index].word[k])] = plain_word[tmp_len][i][k];\n\t\t\t\ttable[getNUM(plain_word[tmp_len][i][k])] = V[index].word[k];\n\t\t\t}\n\t\t}\n\n\t\tif(is_match){\n\t\t\trecursive(index+1);\n\t\t}\n\n\t\tfor(int k = 0; k < 26; k++){\n\t\t\ttable[k] = work[k];\n\t\t}\n\t}\n}\n\nbool is_char(char ch){\n\treturn ch >= 'A' && ch <= 'Z';\n}\n\nvoid func(){\n\n\tV.clear();\n\n\tfor(int i = 0; i < NUM; i++){\n\t\tnum_word[i] = 0;\n\t}\n\n\tchar buf[NUM];\n\tint length;\n\n\tfor(int loop = 0; loop < N; loop++){\n\n\t\tscanf(\"%s\",buf);\n\t\tfor(length = 0; buf[length] != '\\0' && length < 81; length++);\n\n\t\tstrcpy(plain_word[length][num_word[length]++],buf);\n\t}\n\n\tgetchar();\n\tfgets(sequence,100,stdin);\n\n\tchar work[NUM];\n\tint start,work_index;\n\n\tfor(int i = 0; sequence[i] != '\\0'; ){\n\n\t\tstart = i;\n\t\twhile(sequence[start] == ' ')start++;\n\n\t\twork_index = 0;\n\n\t\twhile(is_char(sequence[start+work_index])){\n\n\t\t\twork[work_index] = sequence[start+work_index];\n\t\t\twork_index++;\n\t\t}\n\t\twork[work_index] = '\\0';\n\n\t\tV.push_back(Info(work,work_index));\n\n\t\tif(sequence[start+work_index] == '.'){\n\t\t\tbreak;\n\t\t}\n\t\ti = start+work_index;\n\t}\n\n\tsort(V.begin(),V.end());\n\n\tfor(int i = 0; i < 26; i++){\n\t\ttable[i] = '?';\n\t}\n\n\tnum_finish = 0;\n\trecursive(0);\n\n\tif(num_finish != 1){\n\n\t\tprintf(\"-.\\n\");\n\n\t}else{\n\t\tint loc;\n\n\t\tfor(int i = 0; sequence[i] != '\\0' && i < 100; i++){\n\n\t\t\tif(!is_char(sequence[i])){\n\n\t\t\t\tprintf(\"%c\",sequence[i]);\n\n\t\t\t}else{\n\n\t\t\t\tloc = getNUM(sequence[i]);\n\n\t\t\t\tif(ans_table[loc] == '?'){ //そのまま\n\n\t\t\t\t\tprintf(\"%c\",sequence[i]);\n\n\t\t\t\t}else{\n\n\t\t\t\t\tprintf(\"%c\",ans_table[loc]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<utility>\n#include<algorithm>\n\nusing namespace std;\n\nint ord(char c){\n  return c-'A';\n}\n\nvector<pair<char,char> > rec(vector<string> seq,vector<string> word,vector<pair<char,char> > rules,int u){\n  if(seq.empty())return rules;\n  int mx=-1,x;\n  for(int i=0;i<seq.size();i++){\n    int t=u;\n    int cu=0;\n    for(auto e:seq[i]){\n      int xx=e-'A';\n      if(!(t>>xx&1)){\n\tcu++;\n\tt|=1<<xx;\n      }\n    }\n    if(cu>mx){\n      mx=cu;\n      x=i;\n    }\n  }\n  vector<pair<char,char> > res;\n  for(int j=0;j<word.size();j++){\n    auto e=word[j];\n    if(seq[x].size()!=e.size())continue;\n    vector<pair<char,char> > nr=rules;\n    int nu=u;\n    for(int i=0;i<e.size();i++){\n      int sr=nu>>ord(seq[x][i])&1;\n      int wr=nu>>ord(e[i])&1;\n      if(sr^wr)goto next;\n      if(!sr){\n\tnu|=1<<ord(seq[x][i])|1<<ord(e[i]);\n\tchar l=seq[x][i],h=e[i];\n\tif(h<l){\n\t  swap(l,h);\n\t}\n\tnr.emplace_back(l,h);\n      }else{\n\tchar l=min(seq[x][i],e[i]);\n\tchar h=max(seq[x][i],e[i]);\n\tif(find(begin(nr),end(nr),make_pair(l,h))==end(nr))goto next;\n      }\n    }\n    {\n      vector<string> nseq(begin(seq),begin(seq)+x),nword(begin(word),begin(word)+j);\n      nseq.insert(end(nseq),begin(seq)+x+1,end(seq));\n      nword.insert(end(nword),begin(word)+j+1,end(word));\n      auto r=rec(nseq,nword,nr,nu);\n      if(!res.empty()&&!r.empty())throw 0;\n      if(!r.empty()){\n\tres=r;\n      }\n    }\n  next:\n    ;\n  }\n  return res;\n}\n\nint main(){\n  for(int n;cin>>n,n;){\n    vector<string> word(n);\n    for(int i=0;i<n;i++){\n      cin>>word[i];\n    }\n    vector<string> seq;\n    for(string s;;){\n      cin>>s;\n      if(s.back()!='.'){\n\tseq.push_back(s);\n      }else{\n\tseq.push_back(s.substr(0,s.size()-1));\n\tbreak;\n      }\n    }\n    vector<string> useq=seq,uword=word;\n    sort(begin(useq),end(useq));\n    sort(begin(uword),end(uword));\n    useq.erase(unique(begin(useq),end(useq)),end(useq));\n    uword.erase(unique(begin(uword),end(uword)),end(uword));\n    try{\n      auto r=rec(useq,word,{},0);\n      char table[256];\n      for(auto e:r){\n\ttable[e.first]=e.second;\n\ttable[e.second]=e.first;\n      }\n      bool ns=false;\n      for(auto e:seq){\n\tif(ns++){\n\t  cout<<' ';\n\t}\n\tfor(auto f:e){\n\t  cout<<table[f];\n\t}\n      }\n      cout<<'.'<<endl;\n    }catch(...){\n      cout<<\"-.\"<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,string> PP;\n\nset<string> se;\nmap<string,int> m;\nvector<PP> a;\nvector<string> v;\nint ans[26],u[26],uu[100],n,c;\n\nvoid dfs(int k) {\n  if(k==a.size()||c>1) {\n    for(int i=0; i<26; i++) {\n      if(u[i]==-1) continue;\n      if(u[u[i]]!=i) return;\n    }\n    c++;\n    for(int i=0; i<26; i++) ans[i]=u[i];\n    return;\n  }\n  string r=a[k].second;\n  for(int i=0; i<n; i++) {\n    string t=v[i];\n    if(uu[i]||r.size()!=t.size()) continue;\n    for(int j=0; j<t.size(); j++) {\n      if(u[t[j]-'A']!=-1&&u[t[j]-'A']!=r[j]-'A') goto next;\n      if(u[r[j]-'A']!=-1&&u[r[j]-'A']!=t[j]-'A') goto next;\n    }\n    int u2[26];\n    for(int j=0; j<26; j++) u2[j]=u[j];\n    for(int j=0; j<t.size(); j++) {\n      u[t[j]-'A']=r[j]-'A';\n      u[r[j]-'A']=t[j]-'A';\n    }\n    uu[i]=1;\n    dfs(k+1);\n    uu[i]=0;\n    for(int j=0; j<26; j++) u[j]=u2[j];\n  next:;\n  }\n}\nstring s;\n\nint main() {\n  while(cin >> n && n) {\n    se.clear();a.clear();m.clear();v.clear();\n    for(int i=0; i<n; i++) {\n      cin >> s;\n      v.push_back(s);\n      se.insert(s);\n    }\n    getline(cin,s);\n    getline(cin,s);\n    stringstream ss;\n    ss << s;\n    string r;\n    while(ss>>r) {\n      if(r[r.size()-1]=='.') r=r.substr(0,r.size()-1);\n      m[r]++;\n    }\n    for(map<string,int>::iterator it=m.begin();it!=m.end();it++) {\n      int d[26],cnt=0;memset(d,0,sizeof(d));\n      r=it->first;\n      for(int i=0; i<r.size(); i++) d[r[i]-'A']++;\n      for(int i=0; i<26; i++) if(d[i]) cnt++;\n      a.push_back(PP(cnt,it->first));\n    }\n    sort(a.begin(),a.end(),greater<PP>());\n    memset(u,-1,sizeof(u));\n    memset(uu,0,sizeof(uu));\n    c=0;\n    dfs(0);\n    if(c==1) {\n      for(int i=0; i<s.size(); i++) {\n        if(isalpha(s[i])) cout << (char)(ans[s[i]-'A']+'A');\n        else cout << s[i];\n      }\n      cout << endl;\n    } else cout << \"-.\" << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX_M = 50;\nconstexpr int MAX_LENGTH = 20;\n\nint n, m;\nstring target;\nvector<string> candidates[MAX_LENGTH];\npair<int, string> words[MAX_M];\nvector<char> assign(128, -1);\n\nint cnt;\n\nbool dfs(int idx = 0) {\n\tif(idx == m) {\n\t\tif(++cnt == 1) {\n\t\t\tfor(auto &c : target) {\n\t\t\t\tif(c != ' ') c = assign[c];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tconst auto &s = words[idx].second;\n\n\tfor(const auto &t : candidates[s.size()]) {\n\t\tauto tmp(assign);\n\n\t\tfor(int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\t\tif(!(tmp[s[i]] == t[i] || (tmp[s[i]] == -1 && tmp[t[i]] == -1))) {\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\ttmp[s[i]] = t[i];\n\t\t\ttmp[t[i]] = s[i];\n\t\t}\n\n\t\tassign.swap(tmp);\n\t\tif(!dfs(idx + 1)) return false;\n\t\tassign = move(tmp);\n\t\t\n\tnext:;\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n && n) {\n\t\tfor_each(begin(candidates), end(candidates), [](vector<string> &v) { v.clear(); });\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tstring in;\n\t\t\tcin >> in;\n\n\t\t\tconst int len = in.size();\n\t\t\tcandidates[len].emplace_back(move(in));\n\t\t}\n\n\t\tcin.ignore();\n\t\tgetline(cin, target);\n\t\ttarget = target.substr(0, target.size() - 1);\n\n\t\t{\n\t\t\tstring in;\n\t\t\tistringstream iss(target);\n\n\t\t\tfor(m = 0; iss >> in; ++m) {\n\t\t\t\twords[m].second = in;\n\t\t\t\tin.erase(unique(in.begin(), in.end()), in.end());\n\t\t\t\twords[m].first = in.size();\n\t\t\t}\n\t\t}\n\n\t\tsort(words, words + m, greater<pair<int, string>>());\n\n\t\tcnt = 0;\n\t\tfill(begin(assign), end(assign), -1);\n\t\tdfs();\n\n\t\tcout << (cnt == 1 ? target : \"-\") << \".\\n\";\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a); i<(b); ++i)\n#define REP(i,n) FOR(i,0,n)\n\nvs dfs(vs &words,vs &c_words,map<char,char> &m,int cur,vs &orig_c_words){\n  vs ret;\n  if(cur==orig_c_words.size()){\n    REP(i,orig_c_words.size()){\n      string s;\n      REP(j,orig_c_words[i].size()){\n        s.push_back(m[orig_c_words[i][j]]);\n      }\n      ret.push_back(s);\n    }\n    return ret;\n  }\n\n  REP(i,words.size()){\n    if(words[i].size()==c_words[cur].size()){\n      map<char,char> nm(m);\n      bool ok=true;\n      REP(j,words[i].size()){\n        map<char,char>::iterator it_i=nm.find(words[i][j]);\n        map<char,char>::iterator it_c=nm.find(c_words[cur][j]);\n        bool ei=it_i!=nm.end();\n        bool ec=it_c!=nm.end();\n        if(ei&&ec){\n          if(it_i->second!=c_words[cur][j]||it_c->second!=words[i][j]){\n            ok=false;\n            break;\n          }\n        }else if(ei||ec){\n          ok=false;\n          break;\n        }else{\n          nm[words[i][j]]=c_words[cur][j];\n          nm[c_words[cur][j]]=words[i][j];\n        }\n      }\n      if(ok){\n        //cerr<<\"cur:\"<<cur<<endl;\n        vs res=dfs(words,c_words,nm,cur+1,orig_c_words);\n        //cerr<<\"res:\"<<res.size()<<endl;\n        if(res.size()){\n          if(ret.size()){\n            return vs();\n          }else{\n            ret=res;\n          }\n        }\n      }\n    }\n  }\n  return ret;\n\n}\nbool pred(const string &l,const string &r){\n  if(l.size()==r.size()){\n    return l>r;\n  }else{\n    return l.size()>r.size();\n  }\n}\nint main(){\n  int n;\n  while(cin>>n,n){\n    vs words(n);\n    REP(i,n){\n      cin>>words[i];\n    }\n    string sequence;\n    getline(cin,sequence);\n    getline(cin,sequence);\n    vs c_words;\n    int prev=0;\n    REP(i,sequence.size()){\n      switch(sequence[i]){\n        case ' ':\n        case '.':\n          c_words.push_back(sequence.substr(prev,i-prev));\n          prev=i+1;\n          break;\n      }\n    }\n    vs orig_c_words(c_words);\n    sort(ALL(c_words),pred);\n    map<char,char> m;\n    vs res=dfs(words,c_words,m,0,orig_c_words);\n    if(res.size()){\n      REP(i,res.size()){\n        cout<<res[i]<<(i<res.size()-1?\" \":\"\");\n      }\n      cout<<\".\"<<endl;\n    }else{\n      cout<<\"-.\"<<endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint n;\nstring sq;\nvector<string> a[21];\nvector<string> b[21];\nset<string> S;\nbool a_used[500];\nbool b_used[500];\n\nvoid init(){\n\tsq.clear();\n\tS.clear();\n\tfor(int i=0 ; i < 21 ; i++ ){\n\t\ta[i].clear();\n\t\tb[i].clear();\n\t}\n\tfor(int i=0 ; i < 500 ; i++ ){\n\t\ta_used[i] = b_used[i] = false;\n\t}\n}\n\nbool check(const string& s, const string& t, const vector<char>& h){\n\tif( s.size() != t.size() ) return false;\n\t\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\t/*if( !((h[s[i]] == -1 || h[s[i]] == t[i] ) && (h[t[i]] == -1 || h[t[i]] == s[i]) ) ){\n\t\t\treturn false;\n\t\t}*/\n\t\tif( h[s[i]] != -1 ){\n\t\t\tif( h[h[s[i]]] != -1 && h[s[i]] != h[h[s[i]]] ) return false;\n\t\t\tif( h[t[i]] != -1 && h[s[i]] != h[t[i]] ) return false;\n\t\t}\n\t\tif( h[t[i]] != -1 ){\n\t\t\tif( h[h[t[i]]] != -1 && h[t[i]] != h[h[t[i]]] ) return false;\n\t\t\tif( h[s[i]] != -1 && h[s[i]] != h[t[i]] ) return false;\n\t\t}\n\t}\n\treturn true;\n}\n\nvoid solve(vector<char>& h, int x, int& z){\n\tz++;\n\tif( z >= 300000 ) return;\n\tif( S.size() >= 2 ) return;\n\t\n\tbool flag = true;\n\tfor(int i=0 ; i < sq.size() ; i++ ){\n\t\tif( sq[i] == ' ' || sq[i] == '.' ) continue;\n\t\tif( h[sq[i]] == -1 ){\n\t\t\tflag = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif( flag ){\n\t\tstring str;\n\t\tfor(int i=0 ; i < sq.size() ; i++ ){\n\t\t\tif( sq[i] == ' ' || sq[i] == '.' ){\n\t\t\t\tstr.push_back( sq[i] );\n\t\t\t}else{\n\t\t\t\tstr.push_back( h[sq[i]] );\n\t\t\t}\n\t\t}\n\t\tS.insert( str );\n\t}\n\tif( S.size() >= 2 ) return;\n\t\n\tfor(int k=x ; k > 0 ; k-- ){\n\t\tif( a[k].empty() || b[k].empty() ) continue;\n\t\t\n\t\tfor(int i=0 ; i < a[k].size() ; i++ ){\n\t\t\tif( a_used[(i+1)*(k+1)] ) continue;\n\t\t\t\n\t\t\tfor(int j=0 ; j < b[k].size() ; j++ ){\n\t\t\t\tif( b_used[(j+1)*(k+1)] ) continue;\n\t\t\t\t\n\t\t\t\tstring s = a[k][i], t = b[k][j];\n\t\t\t\t\n\t\t\t\t/*bool f = check(s,t,h);\n\t\t\t\tif( f ){\n\t\t\t\t\tvector<char> h_ = h;\n\t\t\t\t\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\t\t\t\t\th_[s[i]] = t[i];\n\t\t\t\t\t\th_[t[i]] = s[i];\n\t\t\t\t\t}\n\t\t\t\t\tsolve(h_);\n\t\t\t\t\treturn;\n\t\t\t\t}*/\n\t\t\t\tvector<char> h_ = h;\n\t\t\t\tbool f = true;\n\t\t\t\tfor(int l=0 ; l < s.size() ; l++ ){\n\t\t\t\t\tif( h_[s[l]] == -1 || h_[s[l]] == t[l] ){\n\t\t\t\t\t\th_[s[l]] = t[l];\n\t\t\t\t\t\tif( h_[t[l]] == -1 || h_[t[l]] == s[l] ){\n\t\t\t\t\t\t\th_[t[l]] = s[l];\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tf = false;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t/*cout << s << \" <=> \" << t << (f? \" OK\" : \" NG\") << endl;\n\t\t\t\tbool cc[256] = {false};\n\t\t\t\tfor(char c='A' ; c <= 'Z' ; c++ ){\n\t\t\t\t\tif( h_[c] != -1 && !cc[c] ){\n\t\t\t\t\t\tcc[c] = cc[h_[c]] = true;\n\t\t\t\t\t\tcout << c << \":\" << h_[c] << \", \";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcout << endl << endl;*/\n\t\t\t\t\n\t\t\t\tif( f ){\n\t\t\t\t\ta_used[(i+1)*(k+1)] = b_used[(j+1)*(k+1)] = true;\n\t\t\t\t\tsolve(h_,k,z);\n\t\t\t\t\ta_used[(i+1)*(k+1)] = b_used[(j+1)*(k+1)] = false;\n\t\t\t\t\t//return;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i=0 ; i < a[k].size() ; i++ ){\n\t\t\tif( a_used[(i+1)*(k+1)] ) cnt++;\n\t\t}\n\t\tif( cnt != a[k].size() ) return;\n\t}\n}\n\nint main(){\n\twhile( cin >> n , n ){\n\t\tinit();\n\t\t\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\ta[s.size()].push_back(s);\n\t\t}\n\t\twhile( true ){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tif( s[s.size()-1] == '.' ){\n\t\t\t\tsq += s;\n\t\t\t\tb[s.size()-1].push_back( s.substr(0,s.size()-1) );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tsq += s + \" \";\n\t\t\tb[s.size()].push_back( s );\n\t\t}\n\t\tvector<char> h(256);\n\t\tfor(char c='A' ; c <= 'Z' ; c++ ) h[c] = -1;\n\t\tint z=0;\n\t\tsolve(h,20,z);\n\t\t\n\t\t//cout << sq << endl;\n\t\tif( S.size() == 1 ){\n\t\t\tcout << *S.begin() << endl;\n\t\t}else{\n\t\t\tcout << \"-.\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n\ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\nconst int mod = 1000000007;\nconst double PI = acos(-1.0); \n\n\n\nint chars(const string& s) { return set<char>(all(s)).size(); }\nbool cmp(const string& a, const string& b) { return chars(a) > chars(b); }\n\nint n;\nstring cand[22];\nbool used[22];\n\nvector<string> s;\n\nvector<char> table;\nint found;\nvoid dfs(int d, const vector<char>& t)\n{\n\tif (found == 2)\n\t\treturn;\n\telse if (d == s.size())\n\t{\n\t\t++found;\n\t\ttable = t;\n\t\tfor (int i = 0; i < table.size(); ++i)\n\t\t\tif (table[i] == '@')\n\t\t\t\ttable[i] = 'A' + i;\n\t\treturn;\n\t}\n\n\tfor (int T = 0; T < n; ++T)\n\t{\n\t\tif (!used[T] && cand[T].size() == s[d].size())\n\t\t{\n\t\t\tvector<char> nt = t;\n\t\t\tbool ok = true;\n\t\t\tfor (int i = 0; i < s[d].size(); ++i)\n\t\t\t{\n\t\t\t\tchar a = s[d][i], b = cand[T][i];\n\t\t\t\tif ((nt[a] != '@' && nt[a] != b) || (nt[b] != '@' && nt[b] != a))\n\t\t\t\t{\n\t\t\t\t\tok = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tnt[a] = b;\n\t\t\t\tnt[b] = a;\n\t\t\t}\n\n\t\t\tif (ok)\n\t\t\t\tdfs(d + 1, nt);\n\t\t}\n\t}\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\twhile (cin >> n, n)\n\t{\n\t\tinput(cand, n);\n\n\t\tvector<string> seq;\n\t\tfor (;;)\n\t\t{\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tif (s[s.size() - 1] != '.')\n\t\t\t\tseq.push_back(s);\n\t\t\telse\n\t\t\t{\n\t\t\t\tseq.push_back(s.substr(0, s.size() - 1));\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ts = seq;\n\t\tsort(all(s));\n\t\ts.erase(unique(all(s)), s.end());\n\t\tsort(all(s), cmp);\n\n\t\tfound = 0;\n\t\tdfs(0, vector<char>(256, '@'));\n\n\t\tif (found == 1)\n\t\t{\n\t\t\tfor (int i = 0; i < seq.size(); ++i)\n\t\t\t\tfor (int j = 0; j < seq[i].size(); ++j)\n\t\t\t\t\tseq[i][j] = table[seq[i][j]];\n\n\t\t\tstring res;\n\t\t\tcout << seq[0];\n\t\t\tfor (int i = 1; i < seq.size(); ++i)\n\t\t\t\tcout << \" \" << seq[i];\n\t\t\tcout << \".\" << endl;\n\t\t}\n\t\telse\n\t\t\tcout << \"-.\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int N = 20;\n\nint n, ans;\nstring tmp, ans_rev;\nvector<string> words[N+1], cands[N+1];\n\nbool valid(string &tar, string &s, string &rev) {\n  assert(tar.size() == s.size());\n  for(size_t i = 0; i<s.size(); ++i) {\n    if(rev[s[i]] != -1 && rev[s[i]] != tar[i])\n      return false;\n    if(rev[tar[i]] != -1 && rev[tar[i]] != s[i])\n      return false;\n  }\n  return true;\n}\nvoid dfs(int l, size_t x, string &rev) {\n  while(l && x >= words[l].size()) {\n    x = 0;\n    --l;\n  }\n  if(l == 0) {\n    ans_rev = rev;\n    //for(auto c : ans_rev)\n    //  cerr << char(c + 'A');\n    //cerr << endl;\n    ++ans;\n    return;\n  }\n  string &tar = words[l][x];\n  for(auto &s : cands[l])\n    if(valid(tar, s, rev)) {\n      string nrev = rev;\n      size_t i = 0;\n      for(; i<s.size(); ++i)\n        if(nrev[s[i]] == -1) {\n          if(nrev[tar[i]] != -1)\n            break;\n          nrev[s[i]] = tar[i];\n          nrev[tar[i]] = s[i];\n        }\n      if(i != s.size())\n        continue;\n      dfs(l, x+1, nrev);\n    }\n}\nvoid cleanup(vector<string>& v) {\n  sort(v.begin(), v.end());\n  v.resize(unique(v.begin(), v.end()) - v.begin());\n}\nvoid init() {\n  for(int i = 0; i<=N; ++i)\n    words[i].clear(), cands[i].clear();\n  ans = 0;\n}\nvoid solve() {\n  init();\n  for(int i = 0; i<n; ++i) {\n    cin >> tmp;\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    cands[tmp.size()].push_back(tmp);\n  }\n  vector<string> sent;\n  bool cont = true;\n  while(cont) {\n    cin >> tmp;\n    if(tmp.back() == '.') {\n      tmp.pop_back();\n      cont = false;\n    }\n    sent.push_back(tmp);\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    words[tmp.size()].push_back(tmp);\n  }\n  for(int i = 1; i<=N; ++i)\n    cleanup(words[i]);\n  string rev(26, -1);\n  dfs(N, 0, rev);\n  if(ans == 1) {\n    for(size_t i = 0; i<sent.size(); ++i) {\n      for(auto c : sent[i]) \n        putchar(ans_rev[c - 'A'] == -1 ? c : ans_rev[c - 'A'] + 'A');\n      putchar(i+1 == sent.size() ? '.' : ' ');\n    }\n    puts(\"\");\n  } else\n    puts(\"-.\");\n}\nint main() {\n  while(scanf(\"%d\", &n) == 1 && n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n\nint tr[26], ans[26];\nvector<string> split(string s) \n{\n\tvector<string> res;\n\tstringstream ss(s);\n\n\tstring a;\n\twhile(ss >> a) { res.push_back(a); }\n\n\treturn res;\n}\n\nbool check(char a, char b)\n{\n\tif(tr[a - 'A'] != -1 && tr[a - 'A'] != b) return false;\n\tif(tr[b - 'A'] != -1 && tr[b - 'A'] != a) return false;\n\n\treturn true;\n}\n\nbool match(string w, string msg)\n{\n\tfor(int i=0; i<msg.size(); i++) {\n\t\tif(!check(w[i], msg[i])) return false; \n\t}\n\n\treturn true;\n}\n\nint dfs(int p, vector<string>& words, vector<string>& msg) \n{\n\n\tif(p == msg.size()) {\n\t\tmemcpy(ans, tr, sizeof(ans));\n\t\treturn 1;\n\t}\n\t\n\tint res = 0;\t\n\tfor(int i=0; i<words.size(); i++) {\n\t\tif(msg[p].size() != words[i].size()) continue;\n\t\tif(!match(words[i], msg[p])) continue;\n\t\t\n\t\tbool valid = true;\n\t\tint t[26];\n\t\tmemcpy(t, tr, sizeof(t));\n\t\tfor(int j=0; j<msg[p].size(); j++) {\n\t\t\tif(!check(words[i][j], msg[p][j])) { valid = false; break; } \n\t\t\ttr[msg[p][j] - 'A'] = words[i][j];\n\t\t\ttr[words[i][j] - 'A'] = msg[p][j];\n\t\t}\n\t\tif(valid) {\n\t\t\tres += dfs(p+1, words, msg);\n\t\t}\n\t\tmemcpy(tr, t, sizeof(tr));\n\t}\n\n\treturn res;\n}\n\nbool comp(const string& a, const string& b)\n{\n\tif(a.size() != b.size()) return a.size() > b.size();\n\treturn a > b;\n}\n\n\nint main()\n{\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvector<string> words(N);\n\t\tfor(int i=0; i<N; i++) cin >> words[i];\n\n\t\tstring str;\n\t\tgetline(cin, str);\n\t\tgetline(cin, str);\n\t\n\t\tstr.erase(str.end() - 1);\n\n\t\tsort(words.begin(), words.end(), comp);\n\n\t\tvector<string> msg = split(str);\n\t\tsort(msg.begin(), msg.end());\n\t\tmsg.erase(unique(msg.begin(), msg.end()), msg.end());\n\t\tsort(msg.begin(), msg.end(), comp);\n\n\t\tfor(int i=0; i<26; i++) tr[i] = -1;\n\n\t\tint res = dfs(0, words, msg);\n\t\tif(res != 1) cout << \"-.\" << endl;\n\t\telse {\n\t\t\tfor(int i=0; i<str.size(); i++) {\n\t\t\t\tif(isalpha(str[i])) cout << (char)ans[str[i]-'A'];\n\t\t\t\telse cout << str[i];\n\t\t\t}\n\n\t\t\tcout << \".\" << endl;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int N = 20;\n\nint n, ans;\nstring tmp, ans_rev;\nvector<string> words[N+1], cands[N+1];\n//vector<bool> vis[N+1];\n\nvoid init() {\n  for(int i = 0; i<=N; ++i)\n    words[i].clear(), cands[i].clear();//, vis[i].clear();\n  ans = 0;\n}\nbool valid(const string &tar, const string &s, string &rev) {\n  assert(s.size() == tar.size());\n  for(size_t i = 0; i<s.size(); ++i) {\n    if(rev[s[i]] != -1 && rev[s[i]] != tar[i])\n      return false;\n    if(rev[tar[i]] != -1 && rev[tar[i]] != s[i])\n      return false;\n    if(rev[s[i]] == -1 && rev[tar[i]] != -1)\n      return false;\n    if(rev[tar[i]] == -1 && rev[s[i]] != -1)\n      return false;\n  }\n  return true;\n}\nvoid dfs(int l, size_t x, string rev) {\n  if(ans > 1)\n    return;\n  while(l && x >= words[l].size()) {\n    x = 0;\n    --l;\n  }\n  if(l == 0) {\n    ans_rev = rev;\n    ++ans;\n    return;\n  }\n  const string &tar = words[l][x];\n  for(size_t j = 0; j<cands[l].size(); ++j) {\n    //if(vis[l][j])\n    //  continue;\n    const string &s = cands[l][j];\n    if(valid(tar, s, rev)) {\n      string nrev = rev;\n      for(size_t i = 0; i<s.size(); ++i) {\n        nrev[s[i]] = tar[i];\n        nrev[tar[i]] = s[i];\n      }\n      //vis[l][j] = true;\n      dfs(l, x+1, nrev);\n      //vis[l][j] = false;\n    }\n  }\n}\nvoid cleanup(vector<string> &v) {\n  sort(v.begin(), v.end());\n  v.resize(unique(v.begin(), v.end()) - v.begin());\n}\nvoid solve() {\n  init();\n  for(int i = 0; i<n; ++i) {\n    cin >> tmp;\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    cands[tmp.size()].push_back(tmp);\n  }\n  //for(int i = 0; i<=N; ++i)\n  //  vis[i].resize(cands[i].size());\n  vector<string> sent;\n  bool cont = true;\n  while(cont) {\n    cin >> tmp;\n    if(tmp.back() == '.') {\n      tmp.pop_back();\n      cont = false;\n    }\n    sent.push_back(tmp);\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    words[tmp.size()].push_back(tmp);\n  }\n  for(int i = 0; i<=N; ++i)\n    cleanup(words[i]);\n  dfs(N, 0, string(26, -1));\n  assert(ans > 0);\n  if(ans == 1) {\n    for(auto c : ans_rev)\n      if(c != -1) {\n        assert(c == ans_rev[ans_rev[c]]);\n      }\n    for(size_t i = 0; i<sent.size(); ++i) {\n      for(auto c : sent[i]) \n        putchar(ans_rev[c - 'A'] == -1 ? c : ans_rev[c - 'A'] + 'A');\n      putchar(i+1 == sent.size() ? '.' : ' ');\n    }\n    puts(\"\");\n  } else\n    puts(\"-.\");\n}\nint main() {\n  while(scanf(\"%d\", &n) == 1 && n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n;\nvector<string> w,v;\nvector<string> xyz[30];\nstring s;\nvector<char> vc,ans;\ntypedef pair<int,int> P;\nvector<P> vp;\nvector<int> used;\nint valid;\nvector<int> wc1,wc2;\nvoid dfs(){\n  for(int i=0;i<(int)v.size();i++){\n    string& t=v[i];\n    bool flg=0;\n    for(int j=0;j<(int)xyz[t.size()].size();j++){\n      string& u=xyz[t.size()][j];\n      bool ok=1;\n      for(int k=0;k<(int)t.size();k++){\n\tif(!used[t[k]-'A']) continue;\n\tif(!used[u[k]-'A']){\n\t  ok=0;\n\t  break;\n\t}\n\tok&=vc[t[k]-'A']==u[k]-'A';\n\tif(!ok) break;\n      }\n      //cout<<t<<\" \"<<u<<\":\"<<ok<<endl;\n      if(ok){\n\tflg=1;\n\tbreak;\n      }\n    }\n    if(!flg) return;\n  }\n  int cnt=0;\n  for(int i=0;i<26;i++) if(used[vp[i].second]) cnt++;\n  //cout<<cnt<<endl;\n  //if(cnt>1) return;\n  if(cnt==26){\n    valid++;\n    ans=vc;\n    return;\n  }\n  int x=0;\n  while(used[vp[x].second]) x++;\n  //cout<<x<<endl;\n  if(vp[x].first){\n    for(int k=0;k<26;k++){\n      if(used[vp[k].second]) continue;\n      used[vp[x].second]=used[vp[k].second]=1;\n      vc[vp[x].second]=vp[k].second;\n      vc[vp[k].second]=vp[x].second;\n      //cout<<x<<\" \"<<k<<endl;\n      //cout<<(char)(vp[x].second+'A')<<\"<->\"<<(char)(vp[k].second+'A')<<endl;\n      dfs();\n      if(valid>1) return; \n      used[vp[x].second]=used[vp[k].second]=0;\n      vc[vp[x].second]=vc[vp[k].second]=0;   \n    }\n  }else{\n    used[vp[x].second]=1;\n    vc[vp[x].second]=vp[x].second;\n    dfs();\n    used[vp[x].second]=0;\n    vc[vp[x].second]=0;\n  }\n}\nsigned main(){\n  while(cin>>n,n){\n    for(int i=0;i<30;i++) xyz[i].clear(); \n    w.resize(n);\n    for(int i=0;i<n;i++) cin>>w[i],xyz[w[i].size()].push_back(w[i]);\n    cin.ignore();\n    getline(cin,s);\n    assert(s.back()=='.');\n    s.pop_back();\n    v.clear();\n    for(int i=0;i<(int)s.size();i++){\n      string t;\n      while(i<(int)s.size()&&s[i]!=' ') t+=s[i++];\n      //cout<<t<<endl;\n      v.push_back(t);\n    }\n    vc.clear();\n    vc.resize(26,0);\n    wc2.clear();\n    wc2.resize(26,0);\n    for(int i=0;i<(int)v.size();i++)\n      for(int j=0;j<(int)v[i].size();j++)\n\twc2[v[i][j]-'A']++;\n    vp.resize(26);\n    for(int i=0;i<26;i++) vp[i]=P(wc2[i],i);\n    sort(vp.rbegin(),vp.rend());\n    used.clear();\n    used.resize(26,0);\n    valid=0;\n    dfs();\n    //cout<<valid<<endl;\n    if(valid!=1){\n      cout<<\"-.\"<<endl;\n      continue;\n    }\n    //puts(\"found\");\n    for(int i=0;i<(int)v.size();i++){\n      if(i) cout<<\" \";\n      for(int j=0;j<(int)v[i].size();j++){\n\t//cout<<v[i][j]-'A'<<endl;\n\tcout<<(char)(ans[v[i][j]-'A']+'A');\n      }\n    }\n    cout<<\".\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int N = 20;\n\nint n, ans;\nstring tmp, ans_rev;\nvector<string> words[N+1], cands[N+1];\n//vector<bool> vis[N+1];\n\nvoid init() {\n  for(int i = 0; i<=N; ++i)\n    words[i].clear(), cands[i].clear();//, vis[i].clear();\n  ans = 0;\n}\nbool valid(const string &tar, const string &s, string &rev) {\n  assert(s.size() == tar.size());\n  for(size_t i = 0; i<s.size(); ++i) {\n    if(rev[s[i]] != -1 && rev[s[i]] != tar[i])\n      return false;\n    if(rev[tar[i]] != -1 && rev[tar[i]] != s[i])\n      return false;\n    if(rev[s[i]] == -1 && rev[tar[i]] != -1)\n      return false;\n    if(rev[tar[i]] == -1 && rev[s[i]] != -1)\n      return false;\n  }\n  return true;\n}\nvoid dfs(int l, size_t x, string rev) {\n  if(ans > 1)\n    return;\n  while(l && x >= words[l].size()) {\n    x = 0;\n    --l;\n  }\n  if(l == 0) {\n    ans_rev = rev;\n    //cerr << \"here\" << endl;\n    //for(auto c : ans_rev) {\n    //  cerr << int(c) << endl;\n    //  if(c != -1) {\n    //    cerr << char(c+'A') << \" \" << char(ans_rev[c]+'A') << endl;\n    //    assert(c == ans_rev[ans_rev[c]]);\n    //  }\n    //}\n    ++ans;\n    return;\n  }\n  const string &tar = words[l][x];\n  for(size_t j = 0; j<cands[l].size(); ++j) {\n    //if(vis[l][j])\n    //  continue;\n    const string &s = cands[l][j];\n    if(valid(tar, s, rev)) {\n      string nrev = rev;\n      for(size_t i = 0; i<s.size(); ++i)\n        if(nrev[s[i]] == -1) {\n          nrev[s[i]] = tar[i];\n          nrev[tar[i]] = s[i];\n        }\n      //vis[l][j] = true;\n      dfs(l, x+1, nrev);\n      //vis[l][j] = false;\n    }\n  }\n}\nvoid cleanup(vector<string> &v) {\n  sort(v.begin(), v.end());\n  v.resize(unique(v.begin(), v.end()) - v.begin());\n}\nvoid solve() {\n  init();\n  for(int i = 0; i<n; ++i) {\n    cin >> tmp;\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    cands[tmp.size()].push_back(tmp);\n  }\n  //for(int i = 0; i<=N; ++i)\n  //  vis[i].resize(cands[i].size());\n  vector<string> sent;\n  bool cont = true;\n  while(cont) {\n    cin >> tmp;\n    if(tmp.back() == '.') {\n      tmp.pop_back();\n      cont = false;\n    }\n    sent.push_back(tmp);\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    words[tmp.size()].push_back(tmp);\n  }\n  for(int i = 0; i<=N; ++i)\n    cleanup(words[i]);\n  dfs(N, 0, string(26, -1));\n  assert(ans > 0);\n  if(ans == 1) {\n    for(size_t i = 0; i<sent.size(); ++i) {\n      for(auto c : sent[i]) {\n        assert(ans_rev[c - 'A'] != -1);\n        putchar(ans_rev[c - 'A'] + 'A');\n      }\n      putchar(i+1 == sent.size() ? '.' : ' ');\n    }\n    puts(\"\");\n  } else\n    puts(\"-.\");\n}\nint main() {\n  while(scanf(\"%d\", &n) == 1 && n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n;\nvector<string> w,v;\nstring s;\nvector<char> vc,ans;\ntypedef pair<int,int> P;\nvector<P> vp;\nvector<int> used;\nint valid;\nvector<int> wc1,wc2;\nvoid dfs(){\n  for(int i=0;i<(int)v.size();i++){\n    string t=v[i];\n    bool flg=0;\n    for(int j=0;j<n;j++){\n      string u=w[j];\n      if(t.size()!=u.size()) continue;\n      bool ok=1;\n      for(int k=0;k<(int)t.size();k++){\n\tif(!used[t[k]-'A']||!used[u[k]-'A']) continue;\n\tok&=vc[t[k]-'A']==u[k]-'A';\n\tif(!ok) break;\n      }\n      if(ok){\n\tflg=1;\n\tbreak;\n      }\n    }\n    if(!flg) return;\n  }\n  int cnt=0;\n  for(int i=0;i<26;i++) if(used[vp[i].second]||vp[i].first==0) cnt++;\n  //cout<<cnt<<endl;\n  if(cnt==26){\n    valid++;\n    ans=vc;\n    return;\n  }\n  int x=0;\n  while(used[vp[x].second]||vp[x].first==0) x++;\n  //cout<<x<<endl;\n  for(int k=0;k<26;k++){\n    if(used[vp[k].second]||wc1[vp[k].second]==0) continue;\n    if(wc1[vp[x].second]!=wc2[vp[k].second]) continue;\n    used[vp[x].second]=used[vp[k].second]=1;\n    vc[vp[x].second]=vp[k].second;\n    vc[vp[k].second]=vp[x].second;\n    //cout<<x<<\" \"<<k<<endl;\n    //cout<<(char)(vp[x].second+'A')<<\"<->\"<<(char)(vp[k].second+'A')<<endl;\n    dfs();\n    if(valid>1) return; \n    used[vp[x].second]=used[vp[k].second]=0;\n    vc[vp[x].second]=vc[vp[k].second]=0;\n  }\n}\nsigned main(){\n  while(cin>>n,n){\n    w.resize(n);\n    for(int i=0;i<n;i++) cin>>w[i];\n    cin.ignore();\n    getline(cin,s);\n    assert(s.back()=='.');\n    s.pop_back();\n    v.clear();\n    for(int i=0;i<(int)s.size();i++){\n      string t;\n      while(i<(int)s.size()&&s[i]!=' ') t+=s[i++];\n      //cout<<t<<endl;\n      v.push_back(t);\n    }\n    vc.clear();\n    vc.resize(26,0);\n    wc1.clear();\n    wc2.clear();\n    wc1.resize(26,0);\n    wc2.resize(26,0);\n    for(int i=0;i<n;i++)\n      for(int j=0;j<(int)w[i].size();j++)\n\twc1[w[i][j]-'A']++;\n    for(int i=0;i<(int)v.size();i++)\n      for(int j=0;j<(int)v[i].size();j++)\n\twc2[v[i][j]-'A']++;\n    vp.resize(26);\n    for(int i=0;i<26;i++) vp[i]=P(wc2[i],i);\n    sort(vp.rbegin(),vp.rend());\n    used.clear();\n    used.resize(26,0);\n    valid=0;\n    dfs();\n    //cout<<valid<<endl;\n    if(valid!=1){\n      cout<<\"-.\"<<endl;\n      continue;\n    }\n    //puts(\"found\");\n    for(int i=0;i<(int)v.size();i++){\n      if(i) cout<<\" \";\n      for(int j=0;j<(int)v[i].size();j++){\n\t//cout<<v[i][j]-'A'<<endl;\n\tcout<<(char)(ans[v[i][j]-'A']+'A');\n      }\n    }\n    cout<<\".\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <stdexcept>\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n#define phb push_back\n#define ppb pop_back\nusing namespace std;\n\nint N;\nstring D[20];\nvector< string > S;\n\nvector< string > t;\nvector< int > mtc, res;\nint tbl[128], clv[128];\n\nbool read();\nvoid solve();\n\nvoid dfs(int);\n\nint main() {\n\twhile (read())\n\t\tsolve();\n\t\n\treturn 0;\n}\n\nbool read() {\n\tstring str, ln;\n\tistringstream iss;\n\t\n\tgetline(cin, ln), iss.clear(), iss.str(ln);\n\tif (iss >> N, N == 0)\n\t\treturn false;\n\t\n\tfor (int i = 0; i < N; ++i)\n\t\tgetline(cin, D[i]);\n\t\n\tgetline(cin, ln), ln.back() = ' ', iss.clear(), iss.str(ln);\n\tS.clear();\n\twhile (iss >> str)\n\t\tS.phb(str);\n\t\n\treturn true;\n}\n\nvoid solve() {\n\tt.clear();\n\tfor (int i = 0; i < sz(S); ++i)\n\t\tif (find(all(t), S[i]) == t.end())\n\t\t\tt.phb(S[i]);\n\t\n\tauto cmpf = [&] (const string &ra, const string &rb) -> bool {\n\t\treturn sz(ra) > sz(rb);\n\t};\n\t\n\tsort(&S[0], &S[N], cmpf);\n\tsort(all(t), cmpf);\n\t\n\tfill(&tbl[0], &tbl[128], 0);\n\tfill(&clv[0], &clv[128], -1);\n\tmtc.clear(), res.clear();\n\t\n\ttry {\n\t\tdfs(0);\n\t\tfor (int i = 0; i < sz(S); ++i) {\n\t\t\tint k = int(find(all(t), S[i]) - t.begin());\n\t\t\tcout << D[res[k]] << (i + 1 == sz(S) ? \".\" : \" \");\n\t\t}\n\t}\n\tcatch (...) {\n\t\tcout << \"-.\";\n\t}\n\tcout << \"\\n\";\n}\n\nvoid dfs(int u) {\n\tif (u == sz(t)) {\n\t\tif (!res.empty())\n\t\t\tthrow exception();\n\t\tres = mtc;\n\t}\n\telse {\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tif (sz(D[i]) == sz(t[u])) {\n\t\t\t\tint j = 0, c1, c2;\n\t\t\t\t\n\t\t\t\twhile (j < sz(D[i])) {\n\t\t\t\t\tc1 = int(D[i][j]), c2 = int(t[u][j]);\n\t\t\t\t\tif ((tbl[c1] != 0 && tbl[c1] != c2) || (tbl[c2] != 0 && tbl[c2] != c1))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (tbl[c1] == 0)\n\t\t\t\t\t\ttbl[c1] = c2, tbl[c2] = c1, clv[c1] = clv[c2] = u;\n\t\t\t\t\t++j;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (j == sz(D[i])) {\n\t\t\t\t\tmtc.phb(i);\n\t\t\t\t\tdfs(u + 1);\n\t\t\t\t\tmtc.ppb();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhile ((--j) >= 0) {\n\t\t\t\t\tc1 = int(D[i][j]), c2 = int(t[u][j]);\n\t\t\t\t\tif (clv[c1] == u)\n\t\t\t\t\t\ttbl[c1] = tbl[c2] = 0, clv[c1] = clv[c2] = -1;\n\t\t\t\t}\n\t\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int N = 20;\n\nint n, ans;\nstring tmp, ans_rev;\nvector<string> words[N+1], cands[N+1];\n//vector<bool> vis[N+1];\n\nbool valid(string &tar, string &s, string &rev) {\n  for(size_t i = 0; i<s.size(); ++i) {\n    if(rev[s[i]] != -1 && rev[s[i]] != tar[i])\n      return false;\n    if(rev[tar[i]] != -1 && rev[tar[i]] != s[i])\n      return false;\n  }\n  return true;\n}\nvoid dfs(int l, size_t x, string &rev) {\n  if(ans > 1)\n    return;\n  while(l && x >= words[l].size()) {\n    x = 0;\n    --l;\n  }\n  if(l == 0) {\n    ans_rev = rev;\n    ++ans;\n    return;\n  }\n  string &tar = words[l][x];\n  for(size_t j = 0; j<cands[l].size(); ++j) {\n    //if(vis[l][j])\n    //  continue;\n    string &s = cands[l][j];\n    if(valid(tar, s, rev)) {\n      string nrev = rev;\n      size_t i = 0;\n      for(; i<s.size(); ++i)\n        if(nrev[s[i]] == -1) {\n          if(nrev[tar[i]] != -1)\n            break;\n          nrev[s[i]] = tar[i];\n          nrev[tar[i]] = s[i];\n        }\n      if(i != s.size())\n        continue;\n      //vis[l][j] = true;\n      dfs(l, x+1, nrev);\n      //vis[l][j] = false;\n    }\n  }\n}\nvoid cleanup(vector<string> &v) {\n  sort(v.begin(), v.end());\n  v.resize(unique(v.begin(), v.end()) - v.begin());\n}\nvoid init() {\n  for(int i = 0; i<=N; ++i)\n    words[i].clear(), cands[i].clear();//, vis[i].clear();\n  ans = 0;\n}\nvoid solve() {\n  init();\n  for(int i = 0; i<n; ++i) {\n    cin >> tmp;\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    cands[tmp.size()].push_back(tmp);\n  }\n  //for(int i = 0; i<=N; ++i)\n  //  vis[i].resize(cands[i].size());\n  vector<string> sent;\n  bool cont = true;\n  while(cont) {\n    cin >> tmp;\n    if(tmp.back() == '.') {\n      tmp.pop_back();\n      cont = false;\n    }\n    sent.push_back(tmp);\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    words[tmp.size()].push_back(tmp);\n  }\n  for(int i = 0; i<=N; ++i)\n    cleanup(words[i]);\n  string rev(26, -1);\n  dfs(N, 0, rev);\n  if(ans == 1) {\n    for(auto c : ans_rev)\n      if(c != -1) {\n        assert(c == ans_rev[ans_rev[c]]);\n      }\n    for(size_t i = 0; i<sent.size(); ++i) {\n      for(auto c : sent[i]) \n        putchar(ans_rev[c - 'A'] == -1 ? c : ans_rev[c - 'A'] + 'A');\n      putchar(i+1 == sent.size() ? '.' : ' ');\n    }\n    puts(\"\");\n  } else\n    puts(\"-.\");\n}\nint main() {\n  while(scanf(\"%d\", &n) == 1 && n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <stdexcept>\n\n#define sz(x) int((x).size())\n#define all(x) (x).begin(), (x).end()\n#define phb push_back\n#define ppb pop_back\nusing namespace std;\n\nint N;\nstring D[20];\nvector< string > S;\n\nvector< string > t;\nvector< int > mtc, res;\nint tbl[128], clv[128];\n\nbool read();\nvoid solve();\n\nvoid dfs(int);\n\nint main() {\n\twhile (read())\n\t\tsolve();\n\t\n\treturn 0;\n}\n\nbool read() {\n\tstring str, ln;\n\tistringstream iss;\n\t\n\tgetline(cin, ln), iss.clear(), iss.str(ln);\n\tif (iss >> N, N == 0)\n\t\treturn false;\n\t\n\tfor (int i = 0; i < N; ++i)\n\t\tgetline(cin, D[i]);\n\t\n\tgetline(cin, ln), ln.back() = ' ', iss.clear(), iss.str(ln);\n\tS.clear();\n\twhile (iss >> str)\n\t\tS.phb(str);\n\t\n\treturn true;\n}\n\nvoid solve() {\n\tt.clear();\n\tfor (int i = 0; i < sz(S); ++i)\n\t\tif (find(all(t), S[i]) == t.end())\n\t\t\tt.phb(S[i]);\n\t\n\tfill(&tbl[0], &tbl[128], 0);\n\tfill(&clv[0], &clv[128], -1);\n\tmtc.clear(), res.clear();\n\t\n\ttry {\n\t\tdfs(0);\n\t\tfor (int i = 0; i < sz(S); ++i) {\n\t\t\tint k = int(find(all(t), S[i]) - t.begin());\n\t\t\tcout << D[res[k]] << (i + 1 == sz(S) ? \".\" : \" \");\n\t\t}\n\t}\n\tcatch (...) {\n\t\tcout << \"-.\";\n\t}\n\tcout << \"\\n\";\n}\n\nvoid dfs(int u) {\n\tif (u == sz(t)) {\n\t\tif (!res.empty())\n\t\t\tthrow exception();\n\t\tres = mtc;\n\t}\n\telse {\n\t\tfor (int i = 0; i < N; ++i)\n\t\t\tif (sz(D[i]) == sz(t[u])) {\n\t\t\t\tint j = 0, c1, c2;\n\t\t\t\t\n\t\t\t\twhile (j < sz(D[i])) {\n\t\t\t\t\tc1 = int(D[i][j]), c2 = int(t[u][j]);\n\t\t\t\t\tif ((tbl[c1] != 0 && tbl[c1] != c2) || (tbl[c2] != 0 && tbl[c2] != c1))\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tif (tbl[c1] == 0)\n\t\t\t\t\t\ttbl[c1] = c2, tbl[c2] = c1, clv[c1] = clv[c2] = u;\n\t\t\t\t\t++j;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (j == sz(D[i])) {\n\t\t\t\t\tmtc.phb(i);\n\t\t\t\t\tdfs(u + 1);\n\t\t\t\t\tmtc.ppb();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\twhile ((--j) >= 0) {\n\t\t\t\t\tc1 = int(D[i][j]), c2 = int(t[u][j]);\n\t\t\t\t\tif (clv[c1] == u)\n\t\t\t\t\t\ttbl[c1] = tbl[c2] = 0, clv[c1] = clv[c2] = -1;\n\t\t\t\t}\n\t\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n \nusing namespace std;\n \ntypedef long long ll;\n \nint n,found,buf_length;\nvector<string> word[30],buf;\nstring sequence;\nchar transfer[26];\nvector<ll> bitmask;\nvector<int> bc;\nset<string> exist;\nchar table[26];\nbool depth[26];\n\nbool cmp(const string& a,const string& b){ \n  set<char> A,B;\n  rep(i,a.size()) A.insert(a[i]);\n  rep(i,b.size()) B.insert(b[i]);\n  return A.size() > B.size();\n}\n \n//bool cmp(const string& a,const string& b){ return a.size() > b.size(); }\n \nvoid dfs(int cur,long long bit,int dph){\n \n  if( found >= 2 ) return;\n \n  if( cur >= buf_length ){\n    found++;\n    rep(i,26) transfer[i] = table[i];\n    return;\n  }\n \n  int len = buf[cur].size();\n \n  if( __builtin_popcountll( bit & bitmask[cur] ) == bc[cur] ) {\n    string tmp = buf[cur];\n    rep(i,len) tmp[i] = table[tmp[i]-'A'];\n    if( exist.find(tmp) != exist.end() ) dfs(cur+1,bit,dph+1);\n    return;\n  }\n\n  char tmp_table[26];\n  rep(i,26) tmp_table[i] = table[i]; \n  rep(i,word[len].size()){\n    bool error = false;\n    long long new_bit = bit;\n    int ep = len;\n    rep(j,len){\n      if( table[buf[cur][j]-'A'] == '?' && table[word[len][i][j]-'A'] == '?' ) {\n        long long SHIFT = word[len][i][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        SHIFT = buf[cur][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        table[buf[cur][j]-'A']     = word[len][i][j];\n        table[word[len][i][j]-'A'] = buf[cur][j];\n        depth[buf[cur][j]-'A'] = dph;\n        depth[word[len][i][j]-'A'] = dph;\n      } else if( !( table[buf[cur][j]-'A'] == word[len][i][j] && table[word[len][i][j]-'A'] == buf[cur][j] ) ) {\n        error = true;\n        ep = j+1;\n        break;\n      }\n    }\n \n    if( !error ) dfs(cur+1,new_bit,dph+1);\n    rep(j,ep){\n      int idx = buf[cur][j] - 'A';\n      int idx2 = word[len][i][j] - 'A';\n      if( depth[idx] == dph || depth[idx2] == dph ){\n        table[idx] = tmp_table[idx];\n        table[idx2] = tmp_table[idx2];\n        //table[idx] = table[idx2] = '?';\n      }\n    }\n    if( found >= 2 ) return;\n  }\n}\n \nint main(){\n  while( cin >> n, n ){\n    string tmp;\n    found = 0;\n    buf.clear(), tmp.clear();\n    rep(i,26)transfer[i] = table[i] = '?';\n    rep(i,30) word[i].clear();\n    rep(i,n){\n      cin >> tmp;\n      word[(int)tmp.size()].push_back(tmp);\n      exist.insert(tmp);\n    }\n    cin.ignore();\n    getline(cin,sequence);\n    tmp = sequence.substr(0,(int)sequence.size()-1);\n    stringstream ss(tmp);\n    while( !( ss >> tmp ).fail() ) buf.push_back(tmp);\n \n    sort(buf.begin(),buf.end(),cmp);\n    buf.erase(unique(buf.begin(),buf.end()),buf.end());\n    buf_length = (int) buf.size();\n    bitmask.clear(), bc.clear();\n    bitmask.resize(buf_length,0), bc.resize(buf_length);\n    rep(i,buf_length){\n      rep(j,buf[i].size()){\n        long long SHIFT = buf[i][j] - 'A';\n        bitmask[i] |= (1LL<<SHIFT);\n      }\n      bc[i] = __builtin_popcountll(bitmask[i]);\n    }\n \n    dfs(0,0LL,0);\n \n    if( found == 1 ) {\n      rep(i,sequence.size()) cout << (isupper(sequence[i])?transfer[sequence[i]-'A']:sequence[i]);\n      puts(\"\");\n    } else puts(\"-.\");\n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nchar str[21][30];\nchar s[100][30];\nchar ori[100][30];\nchar tmp[21];\nint len[100];\nint len1[30];\nint n,m;\nbool has=true;\nbool mul=false;\nvector<char>ans;\nvector<int>ids[100];\nvoid dfs(int u,const vector<char> & t){\n\tif(has&&mul)return;\n\tif(u==m){\n\t\tans=t;\n\t\tif(!has)has=true;\n\t\telse mul=true;\n\t}\n\tfor(int k=0;k<ids[u].size();k++){\n\t\tif(len1[i]!=len[u])continue;\n\t\tvector<char> nt = t;\n\t\tint i=ids[u][k];\n\t\tbool pass=true;\n\t\tfor(int j=0;j<len[u];j++){\n\t\t\tif(nt[s[u][j]]!=-1&&nt[s[u][j]]!=str[i][j]||nt[str[i][j]]!=-1&&nt[str[i][j]]!=s[u][j]){\n\t\t\t\tpass=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnt[s[u][j]]=str[i][j];\n\t\t\tnt[str[i][j]]=s[u][j];\n\t\t}\n\t\tif(pass){\n\t\t\tdfs(u+1,nt);\n\t\t}\n\t}\n}\nbool flag[100];\nint main(){\n\twhile(~scanf(\"%d\",&n)&&n){\n\t\thas=false;\n\t\tmul=false;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tscanf(\"%s\",str[i]);\n\t\t}\n\t\tm=0;\n\t\twhile(scanf(\"%s\",s[m++])!=EOF){\n\t\t\tif(s[m-1][strlen(s[m-1])-1]=='.'){\n\t\t\t\ts[m-1][strlen(s[m-1])-1]='\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tflag[i]=false;\n\t\t\tfor(int j=i+1;j<n;j++){\n\t\t\t\tif(strcmp(str[i],str[j])==0)flag[i]=true;\n\t\t\t}\n\t\t}\n\t\tint c=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(!flag[i]){\n\t\t\t\tstrcpy(str[c++],str[i]);\n\t\t\t}\n\t\t}\n\t\tn=c;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tflag[i]=false;\n\t\t\tfor(int j=i+1;j<m;j++){\n\t\t\t\tif(strcmp(s[i],s[j])==0)flag[i]=true;\n\t\t\t}\n\t\t}\n\t\tc=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(!flag[i]){\n\t\t\t\tstrcpy(s[c++],s[i]);\n\t\t\t}\n\t\t}\n\t\tm=c;\n\t\tfor(int i=0;i<m;i++)strcpy(ori[i],s[i]);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<m-1;j++){\n\t\t\t\tif(strlen(s[j])<strlen(s[j+1])){\n\t\t\t\t\tstrcpy(tmp,s[j]);\n\t\t\t\t\tstrcpy(s[j],s[j+1]);\n\t\t\t\t\tstrcpy(s[j+1],tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n-1;j++){\n\t\t\t\tif(strlen(str[j])<strlen(str[j+1])){\n\t\t\t\t\tstrcpy(tmp,str[j]);\n\t\t\t\t\tstrcpy(str[j],str[j+1]);\n\t\t\t\t\tstrcpy(str[j+1],tmp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++)len1[i]=strlen(str[i]);\n\t\tfor(int i=0;i<m;i++)len[i]=strlen(s[i]);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tids[i].clear();\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tif(len[i]==len1[j]){\n\t\t\t\t\tids[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(ids[i].size()==0){\n\t\t\t\thas=true;\n\t\t\t\tmul=true;\n\t\t\t}\n\t\t}\n\t\tvector<char>t;\n\t\tfor(int i=0;i<256;i++)t.push_back(-1);\n\t\tdfs(0,t);\n\t\tif(has&&!mul){\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint l=strlen(ori[i]);\n\t\t\t\tfor(int j=0;j<l;j++){\n\t\t\t\t\tprintf(\"%c\",ans[ori[i][j]]);\n\t\t\t\t}\n\t\t\t\tif(i!=m-1)printf(\" \");\n\t\t\t\telse printf(\".\\n\");\n\t\t\t}\n\t\t}else{\n\t\t\tprintf(\"-.\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\n#define mp make_pair\n#define INF 120000000\n\nusing namespace std;\n\ntypedef pair<int, int> P;\ntypedef long long int LL;\n\nbool noflg = true;\nvector<char> res;\n\nvector<string> explode(string &s, char delim = ' ') {\n    vector<string> ret;\n    string tmp = \"\";\n    for (int i = 0; i <= s.size(); i++) {\n        if (s[i] == delim || i == s.size()) {\n            ret.pb(tmp);\n            tmp = \"\";\n        } else {\n            tmp += s[i];\n        }\n    }\n    return ret;\n}\n\nvoid dfs(int idx, const vector<vector<string>> &words, const vector<string> &div, vector<char> enc) {\n    if (idx == div.size()) {\n        if (noflg) {\n            noflg = false;\n            res.clear();\n            copy(enc.begin(), enc.end(), back_inserter(res));\n        } else {\n            noflg = true;\n        }\n        return;\n    }\n    string d = div[idx];\n\n    for (string w : words[d.size()]) {\n        // cout << \"d = \" << d << \" testing \" << w << \" \" << endl;\n        vector<char> tmp;\n        copy(enc.begin(), enc.end(), back_inserter(tmp));\n\n        // for (int i = 0; i < tmp.size(); i++) {\n        //     cout << tmp[i] << \" \";\n        // }\n        // cout << endl;\n\n        for (int i = 0; i < w.size(); i++) {\n            if (tmp[d[i] - 'A'] == '0' && tmp[w[i] - 'A'] == '0') {\n                // cout << d[i] << \" \" << w[i] << endl;\n                tmp[d[i] - 'A'] = w[i];\n                tmp[w[i] - 'A'] = d[i];\n            } else if (tmp[d[i] - 'A'] != w[i] || tmp[w[i] - 'A'] != d[i]) {\n                // cout << \"FALSE at \" << i << endl;\n                goto lbl;\n            }\n        }\n        // cout << \"OK\" << endl;\n        dfs(idx + 1, words, div, tmp);\n\n        lbl:;\n    }\n}\n\nint main() {\n    int n;\n    while (cin >> n, n) {\n        noflg = true;\n        vector<vector<string>> words(21);\n\n        for (int i = 0; i < n; i++) {\n            string tmp;\n            cin >> tmp;\n            words[tmp.size()].pb(tmp);\n        }\n\n        string seq;\n        vector<string> div;\n        getline(cin, seq);\n        getline(cin, seq);\n        seq = seq.substr(0, seq.size() - 1);\n        div = explode(seq);\n        sort(div.begin(), div.end(),\n            [](const string &a, const string &b){ return a.size() > b.size(); });\n\n        vector<char> enc('Z' - 'A' + 1, '0');\n        dfs(0, words, div, enc);\n\n        if (noflg) {cout << \"-.\" << endl; continue;}\n        for (int i = 0; i < seq.size(); i++) {\n            if (seq[i] != ' ' && res[seq[i] - 'A'] != '0') seq[i] = res[seq[i] - 'A'];\n        }\n\n        cout << seq << \".\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Name: Weaker then Planned\n//Level:\n//Category:\n//Note:\n\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <array>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define TIMES(i,n) for(int i = 0; i < (n); ++i)\n\ninline int popcount(unsigned x) {\n    x = (x & 0x55555555U) + ((x & 0xaaaaaaaaU) >> 1);\n    x = (x & 0x33333333U) + ((x & 0xccccccccU) >> 2);\n    x = (x & 0x0f0f0f0fU) + ((x & 0xf0f0f0f0U) >> 4);\n    x = (x & 0x00ff00ffU) + ((x & 0xff00ff00U) >> 8);\n    x = (x & 0x0000ffffU) + ((x & 0xffff0000U) >> 16);\n    return x;\n}\n\narray<char,256> table, ans;\nbool found = false;\n\nbool search(const vector<string> &words, const set<pair<string,int>> &crypted, int known_pat) {\n    string w = \"\";\n    int max_unknown = 0;\n    int mask = 0;\n    for(const auto &s : crypted) {\n        int unknown = popcount(s.second & ~known_pat);\n        if(unknown > max_unknown) {\n            w = s.first;\n            max_unknown = unknown;\n            mask = s.second & ~known_pat;\n        }\n    }\n    if(max_unknown == 0) {\n        if(found) throw \"ambiguous\";\n        found = true;\n        ans = table;\n        return true;\n    }\n    for(const string &word : words) {\n        //cout << known_pat << ' ' << w << ' ' << word << endl;\n        if(word.size() != w.size()) continue;\n        TIMES(i, word.size()) {\n            const char cch = w[i];\n            const char wch = word[i];\n            if(table[cch] != 0 && table[cch] != wch) {\n                //cout << cch << ' ' << table[cch] << endl;\n                goto next;\n            }\n            if(table[wch] != 0 && table[wch] != cch) {\n                goto next;\n            }\n            table[cch] = wch;\n            table[wch] = cch;\n        }\n        //cout << \"ok\" << endl;\n        search(words, crypted, known_pat | mask);\nnext:\n        TIMES(i, word.size()) {\n            const char cch = w[i];\n            const char wch = word[i];\n            if(mask & (1<<(cch-'A'))) {\n                //cout << known_pat << \" clear \" << cch << endl;\n                table[cch] = table[wch] = 0;\n            }\n        }\n    }\n    return false;\n}\n\nbool solve() {\n    int N;\n    cin >> N;\n    if(!N) return false;\n\n    vector<string> words(N);\n    TIMES(i, N) {\n        cin >> words[i];\n    }\n    vector<string> seq;\n    while(true) {\n        string w;\n        cin >> w;\n        if(w[w.size()-1] == '.') {\n            seq.push_back(w.substr(0, w.size()-1));\n            break;\n        } else {\n            seq.push_back(w);\n        }\n    }\n\n    set<pair<string,int>> crypted;\n    for(const string &s : seq) {\n        int mask = 0;\n        for(char c : s) {\n            mask |= (1<<(c-'A'));\n        }\n        crypted.insert(make_pair(s, mask));\n    }\n\n    fill(table.begin(), table.end(), 0);\n    found = false;\n    try {\n        search(words, crypted, 0);\n    } catch(const char *s) {\n        found = false;\n    }\n    if(found) {\n        bool first = true;\n        for(const string &s : seq) {\n            if(!first) cout << ' ';\n            for(char c : s) {\n                cout << ans[c];\n            }\n            first = false;\n        }\n        cout << '.' << endl;\n    } else {\n        cout << \"-.\" << endl;\n    }\n    return true;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n\n    while(solve()) ;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\n#define MAX_WLEN\t(20)\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nclass LessWord {\npublic:\n  bool operator()(const string& w0, const string& w1) const {\n    return w1.size() < w0.size() || (w1.size() == w0.size() && w0 < w1);\n  }\n};\n\n/* global variables */\n\nint nus;\nint tbl[26];\nstring ptxt;\nvs seq, useq, words[MAX_WLEN + 1];\n\n/* subroutines */\n\nstring dcword(string& w) {\n  //cout << \"dcword:\" << w << endl;\n  string dcw = string();\n\n  for (int i = 0; i < w.size(); i++)\n    dcw += tbl[w[i] - 'A'] + 'A';\n\n  return dcw;\n}\n\nvoid decipher(int k) {\n  //cout << \"decipher:\" << k << endl;\n  if (k >= nus) {\n    if (ptxt == \"\") {\n      for (int i = 0; i < seq.size(); i++) {\n\tif (i > 0) ptxt += ' ';\n\tptxt += dcword(seq[i]);\n      }\n      return;\n    }\n    ptxt = \"-\";\n    return;\n  }\n\n  string& usw = useq[k];\n  int uslen = usw.size();\n  vi rpl;\n\n  for (int i = 0; i < words[uslen].size(); i++) {\n    string& word = words[uslen][i];\n    int ok = 1;\n    rpl.clear();\n    \n    for (int j = 0; j < uslen; j++) {\n      int uswj = usw[j] - 'A';\n      int wj = word[j] - 'A';\n      if (tbl[uswj] < 0 && tbl[wj] < 0) {\n        rpl.push_back(uswj);\n        rpl.push_back(wj);\n        tbl[uswj] = wj;\n\ttbl[wj] = uswj;\n      }\n      else if (tbl[uswj] != wj) {\n        ok = 0;\n        break;\n      }\n    }\n\n    if (ok) {\n      decipher(k + 1);\n      if (ptxt == \"-\") return;\n    }\n\n    for (vi::iterator vit = rpl.begin(); vit < rpl.end(); vit++)\n      tbl[*vit] = -1;\n  }\n}\n\n/* main */\n\nint main() {\n  int n;\n\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n\n    for (int i = 0; i <= MAX_WLEN; i++)\n      words[i].clear();\n    \n    for (int i = 0; i < n; i++) {\n      string w = string();\n      cin >> w;\n      //cout << w << endl;\n      words[w.size()].push_back(w);\n    }\n    //for (int i = 0; i <= MAX_WLEN; i++) cout << words[i].size() << endl;\n    \n    seq.clear();\n    for (;;) {\n      string w = string();\n      cin >> w;\n      //cout << w << endl;\n      string::size_type loc = w.find('.', 0);\n      if (loc != string::npos) {\n\tw.erase(loc);\n\tseq.push_back(w);\n\tbreak;\n      }\n      seq.push_back(w);\n    }\n    //for (int i = 0; i < seq.size(); i++) cout << seq[i] << endl;\n\n    set<string> seqset = set<string>(seq.begin(), seq.end());\n    useq = vs(seqset.begin(), seqset.end());\n    sort(useq.begin(), useq.end(), LessWord());\n    nus = useq.size();\n    //for (int i = 0; i < nus; i++) cout << useq[i] << endl;\n    //  #p $words\n    //  #p $useq\n\n    for (int i = 0; i < 26; i++) tbl[i] = -1;\n    ptxt = \"\";\n\n    decipher(0);\n\n    cout << ptxt << '.' << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint N;\nstring sentence;\nstring words[20];\nvector<char> pairs(256);\nvector<string> ans;\nset< vector<char> > memo[100];\nstring replace(string s){\n  REP(i, s.size())if(isalpha(s[i])) s[i] = pairs[s[i]];\n  return s;\n}\nvoid dfs(int k, vector<string>& targets){\n  if(memo[k].count(pairs)) return;\n  memo[k].insert(pairs);\n  if(k == targets.size()) {\n    ans.push_back(replace(sentence));\n    return;\n  }\n  string target = targets[k];\n  int tmppairs[256];\n  REP(i, 256) tmppairs[i] = pairs[i];\n  REP(i, N)if(words[i].size() == target.size()){\n    string word = words[i];\n    bool ok = true;\n    REP(j, word.size())if(pairs[word[j]] != -1 && pairs[word[j]] != target[j]) ok = false;\n    if(!ok) continue;\n    REP(j, word.size()){\n      pairs[word[j]] = target[j];\n      pairs[target[j]] = word[j];\n    }\n    REP(i, 256)if(pairs[i] != -1 && pairs[pairs[i]] != i) ok = false;\n    if(!ok) continue;\n    REP(j, word.size())if(pairs[word[j]] != -1 && (pairs[word[j]] != target[j] || pairs[target[j]] != word[j])) ok = false;\n    if(!ok) continue;\n    dfs(k + 1, targets);\n    REP(i, 256) pairs[i] = tmppairs[i];\n  }\n}\n\nint main(){\n  while(cin>>N && N){\n    REP(i, 256) pairs[i] = -1;\n    ans.clear();\n    REP(i, 100) memo[i].clear();\n    REP(i, N) cin>>words[i];\n    cin.ignore();\n    getline(cin, sentence);\n    vector<string> targets;\n    stringstream ss(sentence);\n    for(string tmp;;){\n      if(!(ss>>tmp)) break;\n      if(tmp[tmp.size()-1] == '.') tmp = tmp.substr(0, tmp.size() - 1);\n      targets.push_back(tmp);\n    }\n    REP(i, targets.size())FOR(j, i+1, targets.size()) if(targets[i].size() < targets[j].size()) swap(targets[i], targets[j]);\n    dfs(0, targets);\n    if(ans.size() == 1) cout<<ans[0]<<endl;\n    else cout<<\"-.\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstring t, ans;\nvector< string > words, latte[21];\n\nbool rec(int idx, vector< char > &add)\n{\n  if(idx == words.size()) {\n    if(!ans.empty()) return (false);\n    ans = t;\n    for(auto &c : ans) if(isalpha(c)) c = add[c - 'A'];\n    return (true);\n  }\n\n  const string &beet = words[idx];\n  for(auto &str : latte[beet.size()]) {\n    auto temp(add);\n    bool flag = true;\n    for(int i = 0; i < beet.size() && flag; i++) {\n      if(temp[beet[i] - 'A'] != str[i] &&\n         (temp[beet[i] - 'A'] != -1 ||\n          temp[str[i] - 'A'] != -1))\n        flag = false;\n      else {\n        temp[beet[i] - 'A'] = str[i];\n        temp[str[i] - 'A'] = beet[i];\n      }\n    }\n    if(!flag) continue;\n    if(!rec(idx + 1, temp)) return (false);\n  }\n  return (true);\n}\n\nint main()\n{\n  int N;\n  while(cin >> N, N) {\n    for(int i = 0; i < N; i++) {\n      string s;\n      cin >> s;\n      latte[s.size()].emplace_back(s);\n    }\n    cin.ignore();\n    getline(cin, t);\n\n    istringstream sss(t);\n    string q;\n    while(sss >> q) {\n      if(q.back() == '.') q.pop_back();\n      words.emplace_back(q);\n    }\n    sort(begin(words), end(words), [&](const string &a, const string &b)\n    {\n      return (a.size() < b.size());\n    });\n    vector< char > add(26, -1);\n    if(rec(0, add)) cout << ans << endl;\n    else cout << \"-.\\n\";\n    for(int i = 0; i < 21; i++) latte[i].clear();\n    words.clear();\n    ans.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize \"O3\"\n\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconstexpr int N = 20;\n\nint n, ans;\nstring tmp, ans_rev;\nvector<string> words[N+1], cands[N+1];\n//vector<bool> vis[N+1];\n\nbool valid(string &tar, string &s, string &rev) {\n  for(size_t i = 0; i<s.size(); ++i) {\n    if(rev[s[i]] != -1 && rev[s[i]] != tar[i])\n      return false;\n    if(rev[tar[i]] != -1 && rev[tar[i]] != s[i])\n      return false;\n  }\n  return true;\n}\nvoid dfs(int l, size_t x, string &rev) {\n  if(ans > 1)\n    return;\n  while(l && x >= words[l].size()) {\n    x = 0;\n    --l;\n  }\n  if(l == 0) {\n    ans_rev = rev;\n    ++ans;\n    return;\n  }\n  string &tar = words[l][x];\n  for(size_t j = 0; j<cands[l].size(); ++j) {\n    //if(vis[l][j])\n    //  continue;\n    string &s = cands[l][j];\n    if(valid(tar, s, rev)) {\n      string nrev = rev;\n      size_t i = 0;\n      for(; i<s.size(); ++i)\n        if(nrev[s[i]] == -1) {\n          if(nrev[tar[i]] != -1)\n            break;\n          nrev[s[i]] = tar[i];\n          nrev[tar[i]] = s[i];\n        }\n      if(i != s.size())\n        continue;\n      //vis[l][j] = true;\n      dfs(l, x+1, nrev);\n      //vis[l][j] = false;\n    }\n  }\n}\nvoid cleanup(vector<string> &v) {\n  sort(v.begin(), v.end());\n  v.resize(unique(v.begin(), v.end()) - v.begin());\n}\nvoid init() {\n  for(int i = 0; i<=N; ++i)\n    words[i].clear(), cands[i].clear();//, vis[i].clear();\n  ans = 0;\n}\nvoid solve() {\n  init();\n  for(int i = 0; i<n; ++i) {\n    cin >> tmp;\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    cands[tmp.size()].push_back(tmp);\n  }\n  //for(int i = 0; i<=N; ++i)\n  //  vis[i].resize(cands[i].size());\n  vector<string> sent;\n  bool cont = true;\n  while(cont) {\n    cin >> tmp;\n    if(tmp.back() == '.') {\n      tmp.pop_back();\n      cont = false;\n    }\n    sent.push_back(tmp);\n    for_each(tmp.begin(), tmp.end(), [](char &c) { c -= 'A'; });\n    words[tmp.size()].push_back(tmp);\n  }\n  for(int i = 0; i<=N; ++i)\n    cleanup(words[i]);\n  string rev(26, -1);\n  dfs(N, 0, rev);\n  if(ans == 1) {\n    for(auto c : ans_rev)\n      if(ans_rev[c] != -1)\n        assert(c == ans_rev[ans_rev[c]]);\n    for(size_t i = 0; i<sent.size(); ++i) {\n      for(auto c : sent[i]) \n        putchar(ans_rev[c - 'A'] == -1 ? c : ans_rev[c - 'A'] + 'A');\n      putchar(i+1 == sent.size() ? '.' : ' ');\n    }\n    puts(\"\");\n  } else\n    puts(\"-.\");\n}\nint main() {\n  while(scanf(\"%d\", &n) == 1 && n)\n    solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 21;\nint N;\nstring word[MAXN];\nstring line;\nvector<string> V;\nvector<int> F;\nmap<char, char> ans;\n\nbool ok(const string &x, const string &w, map<char, char> m) {\n  if(x.size() != w.size()) return false;\n  for(int i = 0; i < x.size(); ++i) {\n    if(m.count(x[i]) && m[x[i]] != w[i]) return false;\n    m[x[i]] = w[i];\n    m[w[i]] = x[i];\n  }\n  return true;\n}\n\nvoid reg(const string &x, const string &w, map<char, char> &m) {\n  for(int i = 0; i < x.size(); ++i) {\n    m[x[i]] = w[i];\n    m[w[i]] = x[i];\n  }\n}\n\nvoid update(map<char, char> m) {\n  F = vector<int>(V.size());\n  for(int i = 0; i < V.size(); ++i) {\n    for(int j = 0; j < N; ++j) {\n      if(ok(V[i], word[j], m)) {\n        F[i] |= 1 << j;\n      }\n    }\n  }\n}\n\nvoid rec(int k, map<char, char> m) {\n  if(k == V.size()) {\n    if(ans.size()) throw 0;\n    ans = m;\n    return;\n  }\n  for(int i = 0; i < N; ++i) {\n    if(F[k] >> i & 1); else continue;\n    map<char, char> nm = m;\n    reg(V[k], word[i], nm);\n    vector<int> undo = F;\n    update(nm);\n    rec(k+1, nm);\n    F = undo;\n  }\n}\n\nint main() {\n  while(cin >> N && N) {\n    for(int i = 0; i < N; ++i) {\n      cin >> word[i];\n    }\n    cin.ignore();\n    getline(cin, line);\n    stringstream ss(line.substr(0, line.size()-1));\n    set<string> ws;\n    for(string s; ss >> s; ) ws.insert(s);\n    V.clear();\n    for(set<string>::iterator it = ws.begin();\n        it != ws.end(); ++it) {\n      V.push_back(*it);\n    }\n    update(map<char, char>());\n    ans = map<char, char>();\n    try {\n      rec(0, map<char, char>());\n      if(ans.empty()) throw 0;\n      for(int i = 0; i < line.size(); ++i) {\n        if(isalpha(line[i])) cout << ans[line[i]];\n        else cout << line[i];\n      }\n      cout << endl;\n    } catch(...) {\n      cout << \"-.\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <iostream>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n\nconst int MAXN = 21;\nconst int MAXC = 100;\n\nint n, answer, table[26], answerTable[26], nCiph, nDict, ciphRemain[MAXC];\nstd::string ciph[MAXC], dict[MAXN], buffer;\n\nbool cmpByLength(const std::string &a, const std::string &b) {\n    return a.length() < b.length();\n}\n\nbool cmpByRemain(const int &a, const int &b) {\n    return ciphRemain[a] < ciphRemain[b];\n}\n\nvoid dfs(int nCiph, std::string ciph[]) {\n    if (nCiph == 0) {\n        answer++;\n        memcpy(answerTable, table, sizeof(answerTable));\n        return;\n    }\n    int ciphId[MAXC];\n    for (int i = 1; i <= nCiph; i++) {\n        ciphRemain[i] = 0;\n        ciphId[i] = i;\n        for (int j = 0; j < ciph[i].length(); j++) {\n            if (table[ciph[i][j] - 'A'] == 0) {\n                ciphRemain[i]++;\n            }\n        }\n    }\n    std::sort(ciphId + 1, ciphId + nCiph + 1, cmpByRemain);\n    std::string now = ciph[ciphId[nCiph]];\n    for (int i = 1; i <= nDict; i++) {\n        if (now.length() != dict[i].length()) continue;\n        bool flag = true;\n        for (int j = 0; j < now.length(); j++) {\n            if (table[now[j] - 'A'] != 0) {\n                if (table[now[j] - 'A'] != dict[i][j]) {\n                    flag = false;\n                    break;\n                }\n            } else if (table[dict[i][j] - 'A'] != 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (!flag) continue;\n        int nEnsure = 0, ensure[MAXC];\n        for (int j = 0; j < now.length(); j++) {\n            if (table[now[j] - 'A'] == 0) {\n                table[now[j] - 'A'] = dict[i][j];\n                table[dict[i][j] - 'A'] = now[j];\n                if (table[dict[i][j] - 'A'] != 0 && table[dict[i][j] - 'A'] != now[j]) {\n                    flag = false;\n                    break;\n                }\n                //std::cout << \"set(\" << now[j] << \", \" << dict[i][j] << \")\" << std::endl;\n                //std::cout << \"set(\" << dict[i][j] << \", \" << now[j] << \")\" << std::endl;\n                ensure[++nEnsure] = now[j];\n                if (dict[i][j] != now[j]) {\n                    ensure[++nEnsure] = dict[i][j];\n                }\n            } else if (table[now[j] - 'A'] != dict[i][j]) {\n                flag = false;\n                break;\n            }\n        }\n        for (int j = 0; j < now.length(); j++) {\n            if (table[now[j] - 'A'] != 0) {\n                if (table[now[j] - 'A'] != dict[i][j]) {\n                    flag = false;\n                    break;\n                }\n            } else if (table[dict[i][j] - 'A'] != 0) {\n                flag = false;\n                break;\n            }\n        }\n        if (flag) {\n            std::string nextCiph[MAXC];\n            for (int j = 1; j < nCiph; j++) {\n                nextCiph[j] = ciph[ciphId[j]];\n            }\n            dfs(nCiph - 1, nextCiph);\n            if (answer > 1) return;\n        }\n        //std::cout << \"******END******\" << \" unmatch(\" << dict[i] << \" with cipher \" << now << \") \";\n        //for (int j = 1; j < nCiph; j++) std::cout << ciph[ciphId[j]] << \" \\n\"[j + 1 == nCiph];\n        for (int j = 1; j <= nEnsure; j++) {\n            table[ensure[j] - 'A'] = 0;\n            //std::cout << \"unset(\" << (char)ensure[j] << \")\" << std::endl;\n        }\n    }\n}\n\nvoid solve() {\n    answer = 0;\n    std::fill(table, table + 26, 0);\n    for (int i = 1, k = 1; i <= nDict; i++) {\n        int j = i;\n        while (j + 1 <= nDict && dict[j].length() == dict[j + 1].length()) j++;\n        while (k <= nCiph && ciph[k].length() < dict[i].length()) k++;\n        if (i == j) {\n            while (k <= nCiph && ciph[k].length() == dict[i].length()) {\n                for (int p = 0; p < ciph[k].length(); p++) {\n                    if (table[ciph[k][p] - 'A'] != 0) {\n                        if (table[ciph[k][p] - 'A'] != dict[i][p]) {\n                            puts(\"3-.\");\n                            return;\n                        }\n                    } else if (table[dict[i][p] - 'A'] != 0) {\n                        puts(\"2-.\");\n                        return;\n                    } else {\n                        table[ciph[k][p] - 'A'] = dict[i][p];\n                        table[dict[i][p] - 'A'] = ciph[k][p];\n                    }\n                }\n                k++;\n            }\n        }\n        i = j;\n    }\n    dfs(nCiph, ciph);\n    if (answer == 1) {\n        for (int i = 0; i < buffer.length(); i++) {\n            if (!isalpha(buffer[i])) putchar(buffer[i]);\n            else putchar(answerTable[buffer[i] - 'A']);\n        }\n        puts(\"\");\n    } else {\n        puts(\"-.\");\n    }\n}\n\nint main() {\n    while (scanf(\"%d\", &nDict) == 1) {\n        if (nDict == 0) break;\n        for (int i = 1; i <= nDict; i++) {\n            std::string buffer;\n            std::cin >> dict[i];\n        }\n        nCiph = 0;\n        std::getline(std::cin, buffer);\n        std::getline(std::cin, buffer);\n        for (int i = 0; i < buffer.length(); i++) {\n            static std::string tmp; \n            if (isalpha(buffer[i])) {\n                tmp = tmp + buffer[i];\n            } else {\n                ciph[++nCiph] = tmp;\n                tmp = \"\";\n            }\n        }\n        std::sort(dict + 1, dict + nDict + 1);\n        std::sort(ciph + 1, ciph + nCiph + 1);\n        nDict = std::unique(dict + 1, dict + nDict + 1) - dict - 1;\n        nCiph = std::unique(ciph + 1, ciph + nCiph + 1) - ciph - 1;\n        std::sort(dict + 1, dict + nDict + 1, cmpByLength);\n        std::sort(ciph + 1, ciph + nCiph + 1, cmpByLength);\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <sstream>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX_M = 50;\nconstexpr int MAX_LENGTH = 20;\n\nint n, m;\nstring target;\nvector<string> candidates[MAX_LENGTH];\npair<int, string> words[MAX_M];\nvector<char> assign(128, -1);\n\nint cnt;\n\nbool dfs(int idx = 0) {\n\tif(idx == m) {\n\t\tif(++cnt == 1) {\n\t\t\tfor(auto &c : target) {\n\t\t\t\tif(c != ' ') c = assign[c];\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tconst auto &s = words[idx].second;\n\n\tfor(const auto &t : candidates[s.size()]) {\n\t\tauto tmp(assign);\n\n\t\tfor(int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\t\tif(!(tmp[s[i]] == t[i] || (tmp[s[i]] == -1 && tmp[t[i]] == -1))) {\n\t\t\t\tgoto next;\n\t\t\t}\n\n\t\t\ttmp[s[i]] = t[i];\n\t\t\ttmp[t[i]] = s[i];\n\t\t}\n\n\t\tassign.swap(tmp);\n\t\tif(!dfs(idx + 1)) return false;\n\t\tassign = move(tmp);\n\t\t\n\tnext:;\n\t}\n\n\treturn true;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> n && n) {\n\t\tfor_each(begin(candidates), end(candidates), [](vector<string> &v) { v.clear(); });\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tstring in;\n\t\t\tcin >> in;\n\n\t\t\tconst int len = in.size();\n\t\t\tcandidates[len].emplace_back(move(in));\n\t\t}\n\n\t\tcin.ignore();\n\t\tgetline(cin, target);\n\t\ttarget.pop_back();\n\n\t\t{\n\t\t\tstring in;\n\t\t\tistringstream iss(target);\n\n\t\t\tfor(m = 0; iss >> in; ++m) {\n\t\t\t\twords[m].second = in;\n\t\t\t\tin.erase(unique(in.begin(), in.end()), in.end());\n\t\t\t\twords[m].first = in.size();\n\t\t\t}\n\t\t}\n\n\t\tsort(words, words + m, greater<pair<int, string>>());\n\n\t\tcnt = 0;\n\t\tfill(begin(assign), end(assign), -1);\n\t\tdfs();\n\n\t\tcout << (cnt == 1 ? target : \"-\") << \".\\n\";\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string>\n#include<string.h>\nusing namespace std;\nstring str[30];\nchar in[100];\nstring q[100];\nint pts[100];\nint conv[30];\nint to[100];\nint ans[100];\nint sz;\nint n;\nint dfs(){\n\tint at=-1;\n\tint len=0;\n\tint pt=0;\n\tfor(int i=0;i<sz;i++){\n\t\tif(!~to[i]){\n\t\t\tif(pt<pts[i]){\n\t\t\t\tat=i;len=q[i].size();pt=pts[i];\n\t\t\t}\n\t\t}\n\t}\n\tif(!len){\n\t\tfor(int i=0;i<sz;i++)ans[i]=to[i];\n\t\treturn 1;\n\t}\n\tint ret=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(str[i].size()!=len)continue;\n\t\tbool ok=true;\n\t\tfor(int j=0;j<str[i].size();j++){\n\t\t\tif((~conv[str[i][j]-'A']&&conv[str[i][j]-'A']!=q[at][j]-'A')||\n\t\t\t(~conv[q[at][j]-'A']&&conv[q[at][j]-'A']!=str[i][j]-'A'))ok=false;\n\t\t}\n\t\tif(ok){\n\t\t\tint rev[26];\n\t\t\tfor(int j=0;j<26;j++)rev[j]=conv[j];\n\t\t\tto[at]=i;\n\t\t\tfor(int j=0;j<str[i].size();j++){\n\t\t\t\tif(!~conv[str[i][j]-'A']){\n\t\t\t\t\tconv[str[i][j]-'A']=q[at][j]-'A';\n\t\t\t\t}else if(conv[str[i][j]-'A']!=q[at][j]-'A')ok=false;\n\t\t\t\tif(!~conv[q[at][j]-'A']){\n\t\t\t\t\tconv[q[at][j]-'A']=str[i][j]-'A';\n\t\t\t\t}else if(conv[q[at][j]-'A']!=str[i][j]-'A')ok=false;\n\t\t\t}\n\t\t\tif(ok)ret+=dfs();\n\t\t\tto[at]=-1;\n\t\t\tfor(int j=0;j<26;j++)conv[j]=rev[j];\n\t\t}\n\t\tif(ret>1)return 2;\n\t}\n\treturn ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tn=a;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tscanf(\"%s\",in);\n\t\t\tstr[i]=in;\n\t\t}\n\t\tsz=0;\n\t\twhile(1){\n\t\t\tscanf(\"%s\",in);\n\t\t\tif(in[strlen(in)-1]=='.'){\n\t\t\t\tin[strlen(in)-1]=0;\n\t\t\t\tq[sz++]=in;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tq[sz++]=in;\n\t\t}\n\t\tfor(int i=0;i<26;i++)conv[i]=-1;\n\t\tfor(int i=0;i<sz;i++)to[i]=-1;\n\t\tfor(int i=0;i<sz;i++)pts[i]=0;\n\t\tfor(int i=0;i<26;i++){\n\t\t\tfor(int j=0;j<sz;j++){\n\t\t\t\tbool ok=false;\n\t\t\t\tfor(int k=0;k<q[j].size();k++){\n\t\t\t\t\tif(q[j][k]=='A'+i)ok=true;\n\t\t\t\t}\n\t\t\t\tif(ok)pts[j]++;\n\t\t\t}\n\t\t}\n\t\tint ret=dfs();\n\t\tif(ret>1)printf(\"-.\\n\");\n\t\telse{\n\t\t\tfor(int i=0;i<sz;i++){\n\t\t\t\tif(i)printf(\" \");\n\t\t\t\tprintf(\"%s\",str[ans[i]].c_str());\n\t\t\t}\n\t\t\tprintf(\".\\n\");\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <cctype>\n#include <cstring>\nusing namespace std;\n\nint tr[256], ans[256];\nvector<string> split(string s) \n{\n\tvector<string> res;\n\tstringstream ss(s);\n\n\tstring a;\n\twhile(ss >> a) { res.push_back(a); }\n\n\treturn res;\n}\n\nbool match(string w, string msg)\n{\n\tfor(int i=0; i<msg.size(); i++) {\n\t\tif(tr[msg[i]] != -1 && tr[msg[i]] != w[i]) return false;\n\t\tif(tr[w[i]] != -1 && tr[w[i]] != msg[i]) return false;\n\t}\n\n\treturn true;\n}\n\nint dfs(int p, vector<string>& words, vector<string>& msg) \n{\n\n\tif(p == msg.size()) {\n\t\tmemcpy(ans, tr, sizeof(ans));\n\t\treturn 1;\n\t}\n\t\n\tint res = 0;\t\n\tfor(int i=0; i<words.size(); i++) {\n\t\tif(msg[p].size() != words[i].size()) continue;\n\t\tif(!match(words[i], msg[p])) continue;\n\t\t\n\t\tbool valid = true;\n\t\tint t[256];\n\t\tmemcpy(t, tr, sizeof(t));\n\t\tfor(int j=0; j<msg[p].size(); j++) {\n\t\t\tif(!match(words[i], msg[p])) { valid = false; break; } \n\t\t\ttr[msg[p][j]] = words[i][j];\n\t\t\ttr[words[i][j]] = msg[p][j];\n\t\t}\n\t\tif(valid) {\n\t\t\tres += dfs(p+1, words, msg);\n\t\t}\n\t\tmemcpy(tr, t, sizeof(tr));\n\t}\n\n\treturn res;\n}\n\nbool comp(const string& a, const string& b)\n{\n\tif(a.size() != b.size()) return a.size() > b.size();\n\treturn a > b;\n}\n\n\nint main()\n{\n\tint N;\n\twhile(cin >> N, N) {\n\t\tvector<string> words(N);\n\t\tfor(int i=0; i<N; i++) cin >> words[i];\n\n\t\tstring str;\n\t\tgetline(cin, str);\n\t\tgetline(cin, str);\n\t\n\t\tstr.erase(str.end() - 1);\n\n\t\tsort(words.begin(), words.end(), comp);\n\n\t\tvector<string> msg = split(str);\n\t\tsort(msg.begin(), msg.end());\n\t\tmsg.erase(unique(msg.begin(), msg.end()), msg.end());\n\t\tsort(msg.begin(), msg.end(), comp);\n\n\t\tfor(int i=0; i<256; i++) tr[i] = -1;\n\n\t\tint res = dfs(0, words, msg);\n\t\tif(res != 1) cout << \"-.\" << endl;\n\t\telse {\n\t\t\tfor(int i=0; i<str.size(); i++) {\n\t\t\t\tif(isalpha(str[i])) cout << (char)ans[str[i]];\n\t\t\t\telse cout << str[i];\n\t\t\t}\n\n\t\t\tcout << \".\" << endl;\n\t\t}\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <cstring>\n#include <map>\n#include <set>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint N;\nstring sentence;\nstring words[20];\nvector<char> pairs(26);\nset<string> ans;\nset< vector<char> > memo[100];\nstring replace(string s){\n  REP(i, s.size())if(isalpha(s[i])) s[i] = pairs[s[i]-'A'];\n  return s;\n}\nvoid dfs(int k, vector<string>& targets){\n  if(ans.size() >= 2) return;\n  //if(memo[k].count(pairs)) return;\n  //memo[k].insert(pairs);\n  if(k == targets.size()) {\n    ans.insert(replace(sentence));\n    return;\n  }\n  string target = targets[k];\n  int tmppairs[26];\n  REP(i, 26) tmppairs[i] = pairs[i];\n  REP(i, N)if(words[i].size() == target.size()){\n    string word = words[i];\n    bool ok = true;\n    REP(j, word.size())if(pairs[word[j]-'A'] != -1 && pairs[word[j]-'A'] != target[j]) ok = false;\n    if(!ok) continue;\n    REP(j, word.size()){\n      pairs[word[j]-'A'] = target[j];\n      pairs[target[j]-'A'] = word[j];\n    }\n    REP(i, 26)if(pairs[i] != -1 && pairs[pairs[i]-'A'] != i + 'A') ok = false;\n    if(!ok) continue;\n    REP(j, word.size())if(pairs[word[j] - 'A'] != -1 && (pairs[word[j] - 'A'] != target[j] || pairs[target[j] - 'A'] != word[j])) ok = false;\n    if(!ok) continue;\n    dfs(k + 1, targets);\n    REP(i, 26) pairs[i] = tmppairs[i];\n  }\n}\n\nint main(){\n  while(cin>>N && N){\n    REP(i, 26) pairs[i] = -1;\n    ans.clear();\n    REP(i, 100) memo[i].clear();\n    REP(i, N) cin>>words[i];\n    cin.ignore();\n    getline(cin, sentence);\n    vector<string> targets;\n    stringstream ss(sentence);\n    for(string tmp;;){\n      if(!(ss>>tmp)) break;\n      if(tmp[tmp.size()-1] == '.') tmp = tmp.substr(0, tmp.size() - 1);\n      targets.push_back(tmp);\n    }\n    REP(i, targets.size())FOR(j, i+1, targets.size()) if(targets[i].size() < targets[j].size()) swap(targets[i], targets[j]);\n    dfs(0, targets);\n    if(ans.size() == 1) cout<<*ans.begin()<<endl;\n    else cout<<\"-.\"<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n;\nstring t[100];\nbool used[100];\nvector<string> v;\nmap< char , char > mp;\ntypedef pair< char , char > P;\n\nbool check( vector<int> a, string b , vector<int> c, string d ){\n  int size=a.size();\n  map< char , set<int> > T;\n\n  for(int i=0;i<size;i++){\n    if(a[i]==-1)continue;\n    T[ b[i] ].insert( d[i] );\n    T[ d[i] ].insert( b[i] );\n    if( T[ b[i] ].size() > 1 )return false;\n    if( T[ d[i] ].size() > 1 )return false;\n  }\n  return true;\n}\n\nstring Replace(string s,bool flag=false){\n  for(int i=0;i<(int)s.size();i++){\n    if(mp.count(s[i]))s[i]=mp[s[i]];\n    else{\n      if(flag)s[i]='?';\n    }\n  }\n  return s;\n}\n\nvector<int> change(string s){\n  vector<int> res(s.size());\n  map<char,int> flg;\n  for(int i=0;i<(int)s.size();i++){\n    if(mp.count(s[i])){\n      res[i]=-1;\n      continue;\n    }\n    if( flg.count(s[i]) ){\n      res[i]=flg[ s[i] ];\n    }else{\n      res[i]=flg.size();\n      flg[ s[i] ]=res[i];\n    }\n  }\n  return res;\n}\n\nvoid Add(string s,string t){\n  for(int i=0;i<(int)s.size();i++){\n    mp[ s[i] ] = t[i];\n    mp[ t[i] ] = s[i];\n  }\n}\n\nbool solve(){\n  set< int > pa;\n  bool update=true;\n  while(update){\n    update=false;\n    vector<int> cnt( v.size(), 0 );\n    \n    for(int i=0;i<n;i++){\n      if(used[i])continue;\n      string str=Replace(t[i],true);\n      vector<int> hashv=change(t[i]);\n      vector<int> target;\n      set< string > st;\n      for(int j=0;j<(int)v.size();j++){\n        string tmp=Replace(Replace(v[j],true));\n        vector<int> hashw=change(v[j]);\n        if(str==tmp && hashv == hashw && check(hashv,t[i],hashw,v[j])){\n          //          cout<<t[i]<<' '<<v[j]<<endl;\n          cnt[j]++;\n        }\n      }\n    }\n\n    for(int i=0;i<n;i++){\n      if(used[i])continue;\n      \n      string str=Replace(t[i],true);\n      vector<int> hashv=change(t[i]);\n      \n      vector<int> target;\n      set< string > st;\n      for(int j=0;j<(int)v.size();j++){\n        string tmp=Replace(Replace(v[j],true));\n        vector<int> hashw=change(v[j]);\n        \n        if(str==tmp && hashv == hashw && cnt[j]==1 && check(hashv,t[i],hashw,v[j])){\n          st.insert(v[j]);\n          target.push_back(j);\n        }\n      }\n\n      if(st.size()==1){\n        update=true;\n        used[i]=true;\n        for(int id:target){\n          Add(t[i],v[id]);\n          pa.insert(id);\n        }\n      }\n      \n    }\n\n  }\n\n  if(pa.size()!=v.size())return false;\n  return true;\n}\n\nvoid init(){\n  v.clear();\n  mp.clear();\n  memset(used,false,sizeof(used));\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++)cin>>t[i];\n    string tmp,str;\n    getline(cin,tmp);\n    getline(cin,tmp);\n    stringstream ss(tmp);\n    while(ss>>str){\n      if( str.back() == '.' )str.pop_back();\n      v.push_back(str);\n    }\n    if( solve() ){\n      for(int i=0;i<(int)v.size();i++){\n        if(i)cout<<' ';\n        cout<<Replace(v[i]);\n      }\n      cout<<'.'<<endl;\n    }else{\n      cout<<\"-.\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<vector>\n#include<algorithm>\n#include<cassert>\nusing namespace std;\n#define REP(i,b,n) for(int i=b;i<n;i++)\n#define rep(i,n)   REP(i,0,n)\n\nchar a[256];\nint ans;\n\nchar m[256];\nint used[256]={0};\n\nvoid search(int n,int now,vector<string> &in,const vector<string> &words){\n  if (ans >= 2)return;\n  if (n == now){\n    ans++;\n    rep(i,256)a[i]=m[i];\n    return;\n  }\n  rep(i,(int)words.size()){\n    string cur = in[now];\n    string tar = words[i];\n    if (tar.size() != cur.size())continue;\n    //check\n    bool isok=true;\n    rep(j,(int)cur.size()){\n      //cout << j << \" \" << cur[j] <<\" \" << tar[j] <<\" \" << used[cur[j]] <<\" \" << used[tar[j]] << endl;\n      if (used[(int)cur[j]] == -1 && used[(int)tar[j]] == -1){\n\tused[(int)tar[j]]=now;\n\tused[(int)cur[j]]=now;\n\tm[(int)cur[j]]=tar[j];\n\tm[(int)tar[j]]=cur[j];\n      }else if (used[(int)cur[j]] == -1     || used[(int)tar[j]] == -1)isok=false;\n      else  if (   m[(int)cur[j]] == tar[j] && m[(int)tar[j]] == cur[j])assert(used[cur[j]] != -1 && used[tar[j]] != -1);\n      else isok=false;\n    }\n    //search\n    if (isok){\n      search(n,now+1,in,words);\n    }\n    //backtrack\n    rep(j,(int)cur.size()){\n      if (used[(int)cur[j]] == now && used[tar[j]] == now){\n\tused[(int)cur[j]]=-1,used[(int)tar[j]]=-1;\n      }\n    }\n  }\n}\n\nbool cmp(const string & a,const string &b){\n  if (a.size() != b.size())return a.size() > b.size();\n  return a < b;\n}\n\nint main(){\n  int n;\n  while(cin>>n && n){\n    rep(i,256)used[i]=-1;\n    ans=0;\n\n    vector<string> words(n),inp;\n    rep(i,n)cin>>words[i];\n    sort(words.begin(),words.end());\n    words.erase(unique(words.begin(),words.end()),words.end());\n    sort(words.begin(),words.end(),cmp);\n    string in;getline(cin,in);\n    getline(cin,in);\n    string tmp = in;\n    rep(i,(int)tmp.size())if (tmp[i] == '.')tmp[i]=' ';\n    stringstream sin(tmp);\n    while(sin>>tmp)inp.push_back(tmp);\n    sort(inp.begin(),inp.end());\n    inp.erase(unique(inp.begin(),inp.end()),inp.end());\n    sort(inp.begin(),inp.end(),cmp);\n    \n    search(inp.size(),0,inp,words);\n    assert(ans > 0);\n    if (ans != 1)cout <<\"-.\" << endl;//\" \" << ans << endl;\n    else {\n      rep(i,(int)in.size()){\n\tif (isupper(in[i]))cout<<a[in[i]];\n\telse cout << in[i];\n      }\n      cout << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n,found,buf_length;\nvector<string> word[30],buf;\nstring sequence;\nchar transfer[26];\nvector<ll> bitmask;\nvector<int> bc;\nset<string> exist;\nchar table[26];\n\nbool cmp(const string& a,const string& b){ return a.size() > b.size(); }\n\nvoid dfs(int cur,long long bit){\n\n  if( found >= 2 ) return;\n\n  if( cur >= buf_length ){\n    found++;\n    rep(i,26) transfer[i] = table[i];\n    return;\n  }\n\n  int len = buf[cur].size();\n\n  if( __builtin_popcountll( bit & bitmask[cur] ) == bc[cur] ) {\n    string tmp = buf[cur];\n    rep(i,len) tmp[i] = table[tmp[i]-'A'];\n    if( exist.find(tmp) != exist.end() ) dfs(cur+1,bit);\n    return;\n  }\n\n  rep(i,word[len].size()){\n    bool error = false;\n    long long new_bit = bit;\n    int ep = len;\n    vector<int> pos;\n    rep(j,len){\n      if( table[buf[cur][j]-'A'] == '?' && table[word[len][i][j]-'A'] == '?' ) {\n        long long SHIFT = word[len][i][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        SHIFT = buf[cur][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        table[buf[cur][j]-'A']     = word[len][i][j];\n        table[word[len][i][j]-'A'] = buf[cur][j];\n        int idx = buf[cur][j] - 'A';\n        pos.push_back(idx);\n        idx = word[len][i][j] - 'A';\n        pos.push_back(idx);\n      } else if( !( table[buf[cur][j]-'A'] == word[len][i][j] && table[word[len][i][j]-'A'] == buf[cur][j] ) ) {\n        ep = j+1;\n        error = true;\n        break;\n      }\n    }\n\n    if( !error )dfs(cur+1,new_bit);\n    rep(j,pos.size()) table[pos[j]] = '?';\n    if( found >= 2 ) return;\n  }\n}\n\nint main(){\n  while( cin >> n, n ){\n    string tmp;\n    found = 0;\n    buf.clear(), tmp.clear();\n    rep(i,26)transfer[i] = table[i] = '?';\n    rep(i,30) word[i].clear();\n    rep(i,n){\n      cin >> tmp;\n      word[(int)tmp.size()].push_back(tmp);\n      exist.insert(tmp);\n    }\n    cin.ignore();\n    getline(cin,sequence);\n    tmp = sequence.substr(0,(int)sequence.size()-1);\n    stringstream ss(tmp);\n    while( !( ss >> tmp ).fail() ) buf.push_back(tmp);\n\n    sort(buf.begin(),buf.end(),cmp);\n    buf.erase(unique(buf.begin(),buf.end()),buf.end());\n    buf_length = (int) buf.size();\n    bitmask.clear(), bc.clear();\n    bitmask.resize(buf_length,0), bc.resize(buf_length);\n    rep(i,buf_length){\n      rep(j,buf[i].size()){\n        long long SHIFT = buf[i][j] - 'A';\n        bitmask[i] |= (1LL<<SHIFT);\n      }\n      bc[i] = __builtin_popcountll(bitmask[i]);\n    }\n\n    dfs(0,0LL);\n\n    if( found == 1 ) {\n      rep(i,sequence.size()) cout << (isupper(sequence[i])?transfer[sequence[i]-'A']:sequence[i]);\n      puts(\"\");\n    } else puts(\"-.\");\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n,found,buf_length;\nvector<string> word[30],buf;\nstring sequence;\nchar transfer[26];\nvector<ll> bitmask;\nvector<int> bc;\nset<string> exist;\nchar table[26];\n\nbool cmp(const string& a,const string& b){ return a.size() > b.size(); }\n\nvoid dfs(int cur,long long bit){\n\n  if( found >= 2 ) return;\n\n  //rep(i,26) cout << table[i] << \" \";\n  //cout << endl;\n\n  if( cur >= buf_length ){\n    found++;\n    rep(i,26) transfer[i] = table[i];\n    return;\n  }\n\n\n  int len = buf[cur].size();\n  /*\n  if( __builtin_popcountll( bit & bitmask[cur] ) == bc[cur] ) {\n    string tmp = buf[cur];\n    rep(i,len) tmp[i] = table[tmp[i]-'A'];\n    if( exist.find(tmp) != exist.end() ) dfs(cur+1,bit);\n    return;\n  }\n  */\n\n  char tmp_table[26];\n  rep(i,26) tmp_table[i] = table[i];\n  rep(i,word[len].size()){\n    //cout<< endl;\n    //rep(j,26) cout << table[j] << \" \"; cout << endl; \n    // cout << \"word \" << word[len][i] << \" is \";\n    bool error = false;\n    long long new_bit = bit;\n    //rep(j,26) table[j] = tmp_table[j];\n    rep(j,len){\n\n\n      if( table[buf[cur][j]-'A'] == '?' && table[word[len][i][j]-'A'] == '?' ) {\n        long long SHIFT = word[len][i][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        SHIFT = buf[cur][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        table[buf[cur][j]-'A']     = word[len][i][j];\n        table[word[len][i][j]-'A'] = buf[cur][j];\n      } else if( !( table[buf[cur][j]-'A'] == word[len][i][j] && table[word[len][i][j]-'A'] == buf[cur][j] ) ) {\n        //cout << \"table[\" << buf[cur][j] << \"] != \" << table[buf[cur][j]-'A'] << \" ?= \" << word[len][i][j] << endl;\n        //cout << \"table[\" << word[len][i][j] << \"] != \" << table[word[len][i][j]-'A'] << \" ?= \" << buf[cur][j] << endl;\n        error = true;\n        break;\n      }\n    }\n\n    if( error ){\n      //cout << \"bad\" << endl;\n      continue;\n    } //cout << \"ok\" << endl;\n    dfs(cur+1,new_bit);\n    rep(j,len){\n      int idx = buf[cur][j] - 'A';\n      table[idx] = tmp_table[idx];\n      idx = word[len][i][j] - 'A';\n      table[idx] = tmp_table[idx];\n    }\n    if( found >= 2 ) return;\n  }\n}\n\nint main(){\n  while( cin >> n, n ){\n    string tmp;\n    found = 0;\n    buf.clear(), tmp.clear();\n    rep(i,26)transfer[i] = table[i] = '?';\n    rep(i,30) word[i].clear();\n    rep(i,n){\n      cin >> tmp;\n      word[(int)tmp.size()].push_back(tmp);\n      exist.insert(tmp);\n    }\n    cin.ignore();\n    getline(cin,sequence);\n    tmp = sequence.substr(0,(int)sequence.size()-1);\n    stringstream ss(tmp);\n    while( !( ss >> tmp ).fail() ) buf.push_back(tmp);\n\n    sort(buf.begin(),buf.end(),cmp);\n    buf.erase(unique(buf.begin(),buf.end()),buf.end());\n    buf_length = (int) buf.size();\n    bitmask.clear(), bc.clear();\n    bitmask.resize(buf_length,0), bc.resize(buf_length);\n    rep(i,buf_length){\n      rep(j,buf[i].size()){\n        long long SHIFT = buf[i][j] - 'A';\n        bitmask[i] |= (1LL<<SHIFT);\n      }\n      bc[i] = __builtin_popcountll(bitmask[i]);\n    }\n\n    dfs(0,0LL);\n\n    if( found == 1 ) {\n      rep(i,sequence.size()) cout << (isupper(sequence[i])?transfer[sequence[i]-'A']:sequence[i]);\n      puts(\"\");\n    } else puts(\"-.\");\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nint n,found,buf_length;\nvector<string> word[30],buf;\nstring sequence;\nchar transfer[26];\nvector<ll> bitmask;\nvector<int> bc;\nset<string> exist;\nchar table[26];\nint depth[26];\n\nbool cmp(const string& a,const string& b){ return a.size() > b.size(); }\n\nvoid dfs(int cur,long long bit,int dph){\n\n  if( found >= 2 ) return;\n\n  if( cur >= buf_length ){\n    found++;\n    rep(i,26) transfer[i] = table[i];\n    return;\n  }\n\n  int len = buf[cur].size();\n\n  if( __builtin_popcountll( bit & bitmask[cur] ) == bc[cur] ) {\n    string tmp = buf[cur];\n    rep(i,len) tmp[i] = table[tmp[i]-'A'];\n    if( exist.find(tmp) != exist.end() ) dfs(cur+1,bit,dph+1);\n    return;\n  }\n  char tmp_table[26];\n  rep(i,26) tmp_table[i] = table[i];\n  rep(i,word[len].size()){\n    bool error = false;\n    long long new_bit = bit;\n    int ep = len;\n\n    rep(j,len){\n      if( table[buf[cur][j]-'A'] == '?' && table[word[len][i][j]-'A'] == '?' ) {\n        long long SHIFT = word[len][i][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        SHIFT = buf[cur][j] - 'A';\n        new_bit |= (1LL<<SHIFT);\n        table[buf[cur][j]-'A']     = word[len][i][j];\n        table[word[len][i][j]-'A'] = buf[cur][j];\n        int idx = buf[cur][j] - 'A';\n        depth[idx] = dph;\n        idx = word[len][i][j] - 'A';\n        depth[idx] = dph;\n      } else if( !( table[buf[cur][j]-'A'] == word[len][i][j] && table[word[len][i][j]-'A'] == buf[cur][j] ) ) {\n        ep = j+1;\n        error = true;\n        break;\n      }\n    }\n\n    if( !error )dfs(cur+1,new_bit,dph+1);\n    rep(j,ep){\n      int idx = buf[cur][j] - 'A';\n      int idx2 = word[len][i][j] - 'A';\n      if( depth[idx] == dph ){\n        table[idx] = tmp_table[idx];\n        table[idx2] = tmp_table[idx2];\n      }\n    }\n    if( found >= 2 ) return;\n  }\n}\n\nint main(){\n  while( cin >> n, n ){\n    string tmp;\n    found = 0;\n    buf.clear(), tmp.clear();\n    rep(i,26)transfer[i] = table[i] = '?';\n    rep(i,30) word[i].clear();\n    rep(i,n){\n      cin >> tmp;\n      word[(int)tmp.size()].push_back(tmp);\n      exist.insert(tmp);\n    }\n    cin.ignore();\n    getline(cin,sequence);\n    tmp = sequence.substr(0,(int)sequence.size()-1);\n    stringstream ss(tmp);\n    while( !( ss >> tmp ).fail() ) buf.push_back(tmp);\n\n    sort(buf.begin(),buf.end(),cmp);\n    buf.erase(unique(buf.begin(),buf.end()),buf.end());\n    buf_length = (int) buf.size();\n    bitmask.clear(), bc.clear();\n    bitmask.resize(buf_length,0), bc.resize(buf_length);\n    rep(i,buf_length){\n      rep(j,buf[i].size()){\n        long long SHIFT = buf[i][j] - 'A';\n        bitmask[i] |= (1LL<<SHIFT);\n      }\n      bc[i] = __builtin_popcountll(bitmask[i]);\n    }\n\n    dfs(0,0LL,0);\n\n    if( found == 1 ) {\n      rep(i,sequence.size()) cout << (isupper(sequence[i])?transfer[sequence[i]-'A']:sequence[i]);\n      puts(\"\");\n    } else puts(\"-.\");\n\n  }\n  return 0;\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_WLEN = 20\nA = 65\n\n### subroutines\n\ndef dcword(w)\n  #p [w, $tbl]\n  w.split('').map{|ch| (A + $tbl[ch.ord - A]).chr}.join('')\nend\n\ndef decipher(k)\n  if k >= $nus\n    if $ptxt.nil?\n      $ptxt = $seq.map{|w| dcword(w)}.join(' ')\n      return\n    end\n    $ptxt = '-'\n    return\n  end\n\n  usw = $useq[k]\n  uslen = usw.length\n\n  for word in $words[uslen]\n    ok = true\n    rpl = []\n\n    for i in (0...uslen)\n      uswi = usw[i].ord - A\n      wi = word[i].ord - A\n      if $tbl[uswi].nil? && $tbl[wi].nil?\n        rpl << uswi\n        $tbl[uswi] = wi\n        if uswi != wi\n          rpl << wi\n          $tbl[wi] = uswi\n        end\n      elsif $tbl[uswi] != wi\n        ok = false\n        break\n      end\n    end\n\n    if ok\n      decipher(k + 1)\n      return if $ptxt == '-'\n    end\n\n    rpl.each{|i| $tbl[i] = nil}\n  end\nend\n\n### main\n\nloop do\n  n = gets.to_i\n  break if n == 0\n\n  $words = Array.new(MAX_WLEN + 1){[]}\n  n.times do\n    w = gets.strip\n    $words[w.length] << w\n  end\n\n  $seq = gets.strip.delete('.').split\n  $useq = $seq.sort{|a, b| b.length <=> a.length}.uniq\n  $nus = $useq.length\n  #p $words\n  #p $useq\n\n  $tbl = Array.new(26){nil}\n  $ptxt = nil\n\n  decipher(0)\n\n  puts $ptxt + '.'\nend"
  },
  {
    "language": "Python",
    "code": "from string import ascii_uppercase\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\n\nconv = ascii_uppercase.find\n\ndef solve():\n    N = int(readline())\n    if N == 0:\n        return False\n    W = [tuple(map(conv, readline().strip())) for i in range(N)]\n    S = []\n    T = set()\n    for s in readline().strip()[:-1].split():\n        e = tuple(map(conv, s))\n        S.append(e)\n        T.add(e)\n    *T, = T\n    U = []\n    for s in T:\n        g = []\n        for i, w in enumerate(W):\n            if len(w) != len(s):\n                continue\n            p = [-1]*26\n            l = len(w)\n            for k in range(l):\n                if p[s[k]] == p[w[k]] == -1:\n                    p[s[k]] = w[k]\n                    p[w[k]] = s[k]\n                elif p[s[k]] == -1 or p[w[k]] == -1 or p[s[k]] != w[k]:\n                    break\n            else:\n                g.append(i)\n        U.append((s, g))\n    L = len(U)\n    U.sort(key = lambda x: len(x[1]))\n    res = None\n    cnt = 0\n    def dfs(i, p0, used):\n        nonlocal res, cnt\n        if i == L:\n            res = p0[:]\n            cnt += 1\n            return\n        p = [0]*26\n        s, g = U[i]\n        for j in g:\n            if used[j]:\n                continue\n            w = W[j]\n            p[:] = p0\n\n            l = len(w)\n            for k in range(l):\n                if p[s[k]] == p[w[k]] == -1:\n                    p[s[k]] = w[k]\n                    p[w[k]] = s[k]\n                elif p[s[k]] == -1 or p[w[k]] == -1 or p[s[k]] != w[k]:\n                    break\n            else:\n                used[j] = 1\n                dfs(i+1, p, used)\n                used[j] = 0\n            if cnt >= 2:\n                return\n    dfs(0, [-1]*26, [0]*N)\n    if cnt != 1:\n        write(\"-.\\n\")\n    else:\n        cA = ord(\"A\")\n        ans = []\n        for s in S:\n            t = []\n            for e in s:\n                t.append(chr(res[e] + cA))\n            ans.append(\"\".join(t))\n        write(\" \".join(ans))\n        write(\".\\n\")\n    return True\nwhile solve():\n    ...\n"
  }
]