[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n\n#define MAX_WORD_LENGTH 50\n#define MAX_CANDIDATES 100\n\ntypedef struct {\n    char from;\n    char to;\n} Substitution;\n\nint can_match(char *cipher, char *candidate, Substitution *rules, int rule_count) {\n    int len = strlen(cipher);\n    if (strlen(candidate) != len) {\n        return 0;\n    }\n\n    for (int i = 0; i < len; i++) {\n        char c = tolower(cipher[i]);\n        char p = tolower(candidate[i]);\n        int matched = 0;\n\n        if (c == p) {\n            matched = 1;\n        } else {\n            for (int j = 0; j < rule_count; j++) {\n                if ((rules[j].from == c && rules[j].to == p) ||\n                    (rules[j].from == p && rules[j].to == c)) {\n                    matched = 1;\n                    break;\n                }\n            }\n        }\n\n        if (!matched) {\n            return 0;\n        }\n    }\n\n    return 1;\n}\n\nint main() {\n    int rule_count;\n    scanf(\"%d\", &rule_count);\n    Substitution rules[rule_count];\n    for (int i = 0; i < rule_count; i++) {\n        scanf(\" %c %c\", &rules[i].from, &rules[i].to);\n        rules[i].from = tolower(rules[i].from);\n        rules[i].to = tolower(rules[i].to);\n    }\n\n    int candidate_count;\n    scanf(\"%d\", &candidate_count);\n    char candidates[MAX_CANDIDATES][MAX_WORD_LENGTH];\n    for (int i = 0; i < candidate_count; i++) {\n        scanf(\"%s\", candidates[i]);\n    }\n\n    char cipher[MAX_WORD_LENGTH];\n    scanf(\"%s\", cipher);\n\n    for (int i = 0; i < candidate_count; i++) {\n        if (can_match(cipher, candidates[i], rules, rule_count)) {\n            printf(\"%s\\n\", candidates[i]);\n            return 0;\n        }\n    }\n\n    printf(\"No candidate found\\n\");\n    return 0;\n}",
    "timestamp": "2025-08-05 20:50:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nbool canDecipher(const string &cipherWord, const string &candidate, const unordered_map<char, char> &subMap, const unordered_map<char, char> &reverseMap) {\n    if (cipherWord.size() != candidate.size()) {\n        return false;\n    }\n\n    for (size_t i = 0; i < cipherWord.size(); ++i) {\n        char cipherChar = cipherWord[i];\n        char candidateChar = candidate[i];\n\n        auto it = subMap.find(cipherChar);\n        if (it != subMap.end()) {\n            if (it->second != candidateChar) {\n                return false;\n            }\n        } else {\n            auto revIt = reverseMap.find(candidateChar);\n            if (revIt != reverseMap.end()) {\n                if (revIt->second != cipherChar) {\n                    return false;\n                }\n            } else {\n                // Check if the mapping is consistent in both directions\n                for (const auto &pair : subMap) {\n                    if (pair.second == candidateChar && pair.first != cipherChar) {\n                        return false;\n                    }\n                }\n                for (const auto &pair : reverseMap) {\n                    if (pair.second == cipherChar && pair.first != candidateChar) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\n\nstring decipher(const vector<string> &cipherWords, const vector<string> &candidates) {\n    unordered_map<char, char> subMap;\n    unordered_map<char, char> reverseMap;\n    vector<string> possible;\n\n    for (const string &candidate : candidates) {\n        bool valid = true;\n        subMap.clear();\n        reverseMap.clear();\n\n        for (const string &cipherWord : cipherWords) {\n            if (cipherWord.size() != candidate.size()) {\n                valid = false;\n                break;\n            }\n\n            for (size_t i = 0; i < cipherWord.size(); ++i) {\n                char c = cipherWord[i];\n                char p = candidate[i];\n\n                if (subMap.count(c)) {\n                    if (subMap[c] != p) {\n                        valid = false;\n                        break;\n                    }\n                } else {\n                    if (reverseMap.count(p)) {\n                        if (reverseMap[p] != c) {\n                            valid = false;\n                            break;\n                        }\n                    } else {\n                        subMap[c] = p;\n                        reverseMap[p] = c;\n                    }\n                }\n            }\n            if (!valid) {\n                break;\n            }\n        }\n\n        if (valid) {\n            possible.push_back(candidate);\n        }\n    }\n\n    if (possible.size() == 1) {\n        return possible[0];\n    } else {\n        return \"\";\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<string> cipherWords(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> cipherWords[i];\n    }\n\n    int M;\n    cin >> M;\n    vector<string> candidates(M);\n    for (int i = 0; i < M; ++i) {\n        cin >> candidates[i];\n    }\n\n    string result = decipher(cipherWords, candidates);\n    if (!result.empty()) {\n        cout << result << endl;\n    } else {\n        cout << \"\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:51:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SubstitutionCipher {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        scanner.nextLine(); // Consume newline\n        \n        Map<Character, Character> substitutionMap = new HashMap<>();\n        for (int i = 0; i < N; i++) {\n            String pair = scanner.nextLine();\n            char a = pair.charAt(0);\n            char b = pair.charAt(1);\n            substitutionMap.put(a, b);\n            substitutionMap.put(b, a);\n        }\n        \n        String ciphertext = scanner.nextLine();\n        int M = scanner.nextInt();\n        scanner.nextLine(); // Consume newline\n        \n        List<String> candidates = new ArrayList<>();\n        for (int i = 0; i < M; i++) {\n            candidates.add(scanner.nextLine());\n        }\n        \n        String plaintext = findPlaintext(ciphertext, substitutionMap, candidates);\n        System.out.println(plaintext);\n    }\n    \n    private static String findPlaintext(String ciphertext, Map<Character, Character> substitutionMap, List<String> candidates) {\n        for (String candidate : candidates) {\n            if (candidate.length() != ciphertext.length()) {\n                continue;\n            }\n            \n            boolean match = true;\n            for (int i = 0; i < ciphertext.length(); i++) {\n                char cipherChar = ciphertext.charAt(i);\n                char candidateChar = candidate.charAt(i);\n                \n                if (substitutionMap.containsKey(cipherChar)) {\n                    if (substitutionMap.get(cipherChar) != candidateChar) {\n                        match = false;\n                        break;\n                    }\n                } else {\n                    if (cipherChar != candidateChar) {\n                        match = false;\n                        break;\n                    }\n                }\n            }\n            \n            if (match) {\n                return candidate;\n            }\n        }\n        return \"\";\n    }\n}",
    "timestamp": "2025-08-05 20:52:09"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SubstitutionCipher {\n    public static String decipher(String ciphertext, List<String> candidates) {\n        Map<Character, Character> substitutionMap = new HashMap<>();\n        Map<Character, Character> reverseMap = new HashMap<>();\n        \n        for (String candidate : candidates) {\n            if (candidate.length() == ciphertext.length()) {\n                if (isValidSubstitution(ciphertext, candidate, substitutionMap, reverseMap)) {\n                    return candidate;\n                }\n            }\n        }\n        \n        return null;\n    }\n    \n    private static boolean isValidSubstitution(String ciphertext, String candidate, \n                                               Map<Character, Character> substitutionMap, \n                                               Map<Character, Character> reverseMap) {\n        substitutionMap.clear();\n        reverseMap.clear();\n        \n        for (int i = 0; i < ciphertext.length(); i++) {\n            char cipher = ciphertext.charAt(i);\n            char plain = candidate.charAt(i);\n            \n            if (substitutionMap.containsKey(cipher)) {\n                if (substitutionMap.get(cipher) != plain) {\n                    return false;\n                }\n            } else if (reverseMap.containsKey(plain)) {\n                if (reverseMap.get(plain) != cipher) {\n                    return false;\n                }\n            } else {\n                substitutionMap.put(cipher, plain);\n                reverseMap.put(plain, cipher);\n            }\n        }\n        \n        return true;\n    }\n    \n    public static void main(String[] args) {\n        String ciphertext = \"wlmprt\";\n        List<String> candidates = Arrays.asList(\"expert\", \"report\", \"export\");\n        \n        String plaintext = decipher(ciphertext, candidates);\n        \n        if (plaintext != null) {\n            System.out.println(\"Deciphered message: \" + plaintext);\n        } else {\n            System.out.println(\"No valid decipherment found.\");\n        }\n    }\n}",
    "timestamp": "2025-08-05 20:52:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_WORDS 100\n#define MAX_WORD_LENGTH 50\n#define MAX_RULES 26\n\ntypedef struct {\n    char original;\n    char substituted;\n} SubstitutionRule;\n\nSubstitutionRule rules[MAX_RULES];\nint ruleCount = 0;\n\nbool isValidSubstitution(char* cipherWord, char* plainWord) {\n    if (strlen(cipherWord) != strlen(plainWord)) return false;\n\n    bool letterMap[26] = {false};\n    bool reverseMap[26] = {false};\n\n    for (int i = 0; cipherWord[i]; i++) {\n        char cipher = cipherWord[i];\n        char plain = plainWord[i];\n\n        int cipherIndex = cipher - 'a';\n        int plainIndex = plain - 'a';\n\n        if (letterMap[cipherIndex] && letterMap[cipherIndex] != plain) return false;\n        if (reverseMap[plainIndex] && reverseMap[plainIndex] != cipher) return false;\n\n        letterMap[cipherIndex] = plain;\n        reverseMap[plainIndex] = cipher;\n    }\n\n    return true;\n}\n\nvoid addSubstitutionRule(char original, char substituted) {\n    rules[ruleCount].original = original;\n    rules[ruleCount].substituted = substituted;\n    ruleCount++;\n}\n\nvoid decipher(char* ciphertext, char** candidates, int candidateCount) {\n    char* words[MAX_WORDS];\n    int wordCount = 0;\n\n    char* token = strtok(ciphertext, \" \");\n    while (token != NULL) {\n        words[wordCount++] = token;\n        token = strtok(NULL, \" \");\n    }\n\n    for (int i = 0; i < candidateCount; i++) {\n        if (wordCount != strlen(candidates[i])) continue;\n\n        bool matchFound = true;\n        for (int j = 0; j < wordCount; j++) {\n            if (!isValidSubstitution(words[j], candidates[i] + j)) {\n                matchFound = false;\n                break;\n            }\n        }\n\n        if (matchFound) {\n            printf(\"%s\\n\", candidates[i]);\n        }\n    }\n}\n\nint main() {\n    char ciphertext[MAX_WORD_LENGTH];\n    char* candidates[MAX_WORDS];\n    int candidateCount = 0;\n\n    // Input ciphertext\n    fgets(ciphertext, sizeof(ciphertext), stdin);\n    ciphertext[strcspn(ciphertext, \"\\n\")] = 0;\n\n    // Input candidate words\n    char input[MAX_WORD_LENGTH];\n    while (fgets(input, sizeof(input), stdin) && input[0] != '\\n') {\n        input[strcspn(input, \"\\n\")] = 0;\n        candidates[candidateCount++] = strdup(input);\n    }\n\n    decipher(ciphertext, candidates, candidateCount);\n\n    // Free dynamically allocated memory\n    for (int i = 0; i < candidateCount; i++) {\n        free(candidates[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:52:28"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <unordered_map>\n#include <unordered_set>\n#include <algorithm>\n\nusing namespace std;\n\nclass SubstitutionDecipherer {\nprivate:\n    unordered_map<char, char> substitutionMap;\n    unordered_set<string> candidateWords;\n\n    bool trySubstitution(const string& cipherWord, const string& plainWord) {\n        if (cipherWord.length() != plainWord.length()) \n            return false;\n\n        substitutionMap.clear();\n        for (int i = 0; i < cipherWord.length(); i++) {\n            char cipherChar = cipherWord[i];\n            char plainChar = plainWord[i];\n\n            if (substitutionMap.count(cipherChar) && substitutionMap[cipherChar] != plainChar)\n                return false;\n\n            if (find(substitutionMap.begin(), substitutionMap.end(), plainChar) != substitutionMap.end())\n                return false;\n\n            substitutionMap[cipherChar] = plainChar;\n        }\n        return true;\n    }\n\n    string applySubstitution(const string& cipherWord) {\n        string plainWord = cipherWord;\n        for (char& c : plainWord) {\n            if (substitutionMap.count(c)) {\n                c = substitutionMap[c];\n            }\n        }\n        return plainWord;\n    }\n\npublic:\n    void addCandidateWord(const string& word) {\n        candidateWords.insert(word);\n    }\n\n    vector<string> decipher(const vector<string>& cipherWords) {\n        vector<string> decipheredWords;\n\n        for (const string& cipherWord : cipherWords) {\n            bool deciphered = false;\n            for (const string& candidateWord : candidateWords) {\n                if (trySubstitution(cipherWord, candidateWord)) {\n                    decipheredWords.push_back(candidateWord);\n                    deciphered = true;\n                    break;\n                }\n            }\n            if (!deciphered) return {};\n        }\n\n        return decipheredWords;\n    }\n};\n\nint main() {\n    SubstitutionDecipherer decipherer;\n\n    // Example usage\n    decipherer.addCandidateWord(\"hello\");\n    decipherer.addCandidateWord(\"world\");\n\n    vector<string> cipherWords = {\"uqttc\", \"kcbtl\"};\n    vector<string> result = decipherer.decipher(cipherWords);\n\n    if (!result.empty()) {\n        for (const string& word : result) {\n            cout << word << \" \";\n        }\n        cout << endl;\n    } else {\n        cout << \"No deciphering found\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:52:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def decipher(ciphertexts, rules, candidates):\n    from collections import defaultdict\n\n    def generate_substitution_map(rules):\n        substitution_map = defaultdict(set)\n        for (a, b) in rules:\n            substitution_map[a].add(b)\n            substitution_map[b].add(a)\n        return substitution_map\n\n    def can_transform(cipherword, candidate, subs_map):\n        if len(cipherword) != len(candidate):\n            return False\n        for c, p in zip(cipherword, candidate):\n            if p not in subs_map[c] and c != p:\n                return False\n        return True\n\n    def decipher_word(cipherword, candidates, subs_map):\n        for candidate in candidates:\n            if can_transform(cipherword, candidate, subs_map):\n                return candidate\n        return \"\"\n\n    substitution_map = generate_substitution_map(rules)\n    plaintexts = []\n\n    for cipherword in ciphertexts:\n        plaintext_word = decipher_word(cipherword, candidates, substitution_map)\n        plaintexts.append(plaintext_word)\n\n    return plaintexts\n\n# Example usage:\nciphertexts = [\"bppa\", \"ghrz\"]\nrules = [('a', 'b'), ('p', 'x'), ('g', 'h'), ('z', 'r')]\ncandidates = [\"apple\", \"pear\", \"grape\"]\n\nprint(decipher(ciphertexts, rules, candidates))",
    "timestamp": "2025-08-13 03:46:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SubstitutionCipherSolver {\n    public static void main(String[] args) {\n        // Sample input\n        List<String> ciphertextMessages = Arrays.asList(\"bqqmf\", \"ifmmp\");\n        List<String> candidateWords = Arrays.asList(\"hello\", \"apple\");\n\n        // Substitution rules (examples)\n        Map<Character, Character> substitutionRules = new HashMap<>();\n        substitutionRules.put('a', 'b');\n        substitutionRules.put('b', 'a');\n        substitutionRules.put('h', 'i');\n        substitutionRules.put('i', 'h');\n        substitutionRules.put('e', 'f');\n        substitutionRules.put('f', 'e');\n        substitutionRules.put('l', 'm');\n        substitutionRules.put('m', 'l');\n        substitutionRules.put('o', 'p');\n        substitutionRules.put('p', 'o');\n\n        for (String cipher : ciphertextMessages) {\n            System.out.println(decipher(cipher, candidateWords, substitutionRules));\n        }\n    }\n\n    private static String decipher(String cipher, List<String> candidates, Map<Character, Character> rules) {\n        for (String candidate : candidates) {\n            if (isValidTransformation(cipher, candidate, rules)) {\n                return candidate;\n            }\n        }\n        return \"No Match Found\";\n    }\n\n    private static boolean isValidTransformation(String cipher, String candidate, Map<Character, Character> rules) {\n        if (cipher.length() != candidate.length()) {\n            return false;\n        }\n        for (int i = 0; i < cipher.length(); i++) {\n            char cipherChar = cipher.charAt(i);\n            char candidateChar = candidate.charAt(i);\n            if (rules.containsKey(cipherChar) && rules.get(cipherChar) == candidateChar) {\n                continue;\n            } else if (rules.containsKey(candidateChar) && rules.get(candidateChar) == cipherChar) {\n                continue;\n            } else {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-13 03:46:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_WORD_LENGTH 100\n#define MAX_WORDS 1000\n#define ALPHABET_SIZE 26\n\n// Function to check if two words are a valid substitution pair\nbool validSubstitution(const char *plaintext, const char *ciphertext, char subs[ALPHABET_SIZE]) {\n    char reverseSubs[ALPHABET_SIZE] = {0};\n    for (int i = 0; i < ALPHABET_SIZE; i++) {\n        if (subs[i] != 0) {\n            reverseSubs[subs[i] - 'a'] = i + 'a';\n        }\n    }\n    \n    for (int i = 0; plaintext[i] != '\\0'; i++) {\n        char p = plaintext[i] - 'a';\n        char c = ciphertext[i] - 'a';\n        \n        if (subs[p] == 0 && reverseSubs[c] == 0) {\n            subs[p] = ciphertext[i];\n            reverseSubs[c] = plaintext[i];\n        } else if (subs[p] != ciphertext[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\n// Function to decipher a word\nvoid decipher(const char *ciphertext, char subs[ALPHABET_SIZE], char decrypted[MAX_WORD_LENGTH]) {\n    for (int i = 0; ciphertext[i] != '\\0'; i++) {\n        decrypted[i] = subs[ciphertext[i] - 'a'];\n    }\n}\n\n// Main function\nint main() {\n    int numWords, numCandidates;\n    \n    char dictionary[MAX_WORDS][MAX_WORD_LENGTH];\n    char ciphertext[MAX_WORD_LENGTH];\n    char candidate[MAX_WORD_LENGTH];\n    char decrypted[MAX_WORD_LENGTH];\n    \n    printf(\"Enter number of candidate words: \");\n    scanf(\"%d\", &numCandidates);\n    \n    printf(\"Enter candidate words:\\n\");\n    for (int i = 0; i < numCandidates; i++) {\n        scanf(\"%s\", dictionary[i]);\n    }\n    \n    printf(\"Enter ciphertext message: \");\n    scanf(\"%s\", ciphertext);\n    \n    bool found = false;\n    for (int i = 0; i < numCandidates; i++) {\n        if (strlen(dictionary[i]) == strlen(ciphertext)) {\n            char subs[ALPHABET_SIZE] = {0};\n            if (validSubstitution(dictionary[i], ciphertext, subs)) {\n                decipher(ciphertext, subs, decrypted);\n                printf(\"Deciphered text: %s\\n\", decrypted);\n                found = true;\n                break;\n            }\n        }\n    }\n    \n    if (!found) {\n        printf(\"No valid deciphering found.\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 03:46:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def decipher_message(ciphertext, candidate_words):\n    def generate_substitution_map(ciphertext, plaintext):\n        substitution_map = {}\n        for c, p in zip(ciphertext, plaintext):\n            if c in substitution_map and substitution_map[c] != p:\n                return None\n            substitution_map[c] = p\n        return substitution_map\n\n    def apply_substitution(text, substitution_map):\n        return ''.join(substitution_map.get(char, char) for char in text)\n\n    def backtrack(remaining_ciphers, used_words):\n        if not remaining_ciphers:\n            return used_words\n\n        for word in candidate_words:\n            if word in used_words:\n                continue\n\n            substitution_map = generate_substitution_map(remaining_ciphers[0], word)\n            if substitution_map is None:\n                continue\n\n            next_ciphers = [apply_substitution(cipher, substitution_map) for cipher in remaining_ciphers[1:]]\n            result = backtrack(next_ciphers, used_words + [word])\n            if result:\n                return result\n\n        return None\n\n    return backtrack(ciphertext.split(), [])",
    "timestamp": "2025-08-13 03:47:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def decipher(ciphertext, candidates, substitution_pairs):\n    substitution_dict = {}\n    for pair in substitution_pairs:\n        a, b = pair\n        substitution_dict[a] = b\n        substitution_dict[b] = a\n    \n    def decrypt_word(word):\n        decrypted = []\n        for c in word:\n            decrypted.append(substitution_dict.get(c, c))\n        return ''.join(decrypted)\n    \n    decrypted_cipher = decrypt_word(ciphertext)\n    \n    for candidate in candidates:\n        if len(candidate) != len(ciphertext):\n            continue\n        decrypted_candidate = decrypt_word(candidate)\n        if decrypted_candidate == ciphertext:\n            return candidate\n    \n    return None",
    "timestamp": "2025-08-13 03:47:16"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n#include <string>\n#include <algorithm>\n\nusing namespace std;\n\nbool isValidSubstitution(const string &cipherText, const string &candidate, unordered_map<char, char> &substitution) {\n    unordered_map<char, char> reverseSubstitution;\n\n    for (size_t i = 0; i < cipherText.size(); ++i) {\n        char cipherChar = cipherText[i];\n        char candidateChar = candidate[i];\n\n        if (substitution.count(cipherChar) && substitution[cipherChar] != candidateChar) {\n            return false;\n        }\n\n        if (reverseSubstitution.count(candidateChar) && reverseSubstitution[candidateChar] != cipherChar) {\n            return false;\n        }\n\n        substitution[cipherChar] = candidateChar;\n        reverseSubstitution[candidateChar] = cipherChar;\n    }\n\n    return true;\n}\n\nstring decipher(const string &cipherText, const vector<string> &candidates) {\n    for (const string &candidate : candidates) {\n        if (cipherText.size() == candidate.size()) {\n            unordered_map<char, char> substitution;\n            if (isValidSubstitution(cipherText, candidate, substitution)) {\n                return candidate;\n            }\n        }\n    }\n    return \"\";\n}\n\nint main() {\n    int numMessages;\n    cin >> numMessages;\n\n    vector<string> ciphertexts(numMessages);\n    for (int i = 0; i < numMessages; ++i) {\n        cin >> ciphertexts[i];\n    }\n\n    int numCandidates;\n    cin >> numCandidates;\n\n    vector<string> candidates(numCandidates);\n    for (int i = 0; i < numCandidates; ++i) {\n        cin >> candidates[i];\n    }\n\n    for (const string &cipherText : ciphertexts) {\n        string plaintext = decipher(cipherText, candidates);\n        if (!plaintext.empty()) {\n            cout << plaintext << endl;\n        } else {\n            cout << \"No valid plaintext found for ciphertext: \" << cipherText << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:15:08"
  }
]