[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n#include <math.h>\n\nlong long absolute(long long x) {\n    return x < 0 ? -x : x;\n}\n\nint main() {\n    int Q;\n    scanf(\"%d\", &Q);\n\n    long long min_x = 0, min_val = 0;\n    \n    while (Q--) {\n        int type;\n        scanf(\"%d\", &type);\n        \n        if (type == 1) {\n            long long a, b;\n            scanf(\"%lld %lld\", &a, &b);\n            \n            long long curr_diff = absolute(min_x - a);\n            min_val += curr_diff + b;\n            \n            if (min_x > a) {\n                min_x = a;\n            } else if (min_x < a) {\n                long long other_candidate = 2 * a - min_x;\n                long long other_val = min_val + absolute(other_candidate - a) - curr_diff;\n                \n                if (other_val < min_val || (other_val == min_val && other_candidate < min_x)) {\n                    min_x = other_candidate;\n                    min_val = other_val;\n                }\n            }\n        } else {\n            printf(\"%lld %lld\\n\", min_x, min_val);\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:50:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\ntypedef long long ll;\n\ntypedef struct {\n    ll sum_left;\n    ll sum_right;\n    ll count_left;\n    ll count_right;\n    ll total_add;\n    ll min_x;\n    ll min_val;\n} Heap;\n\nHeap left_heap, right_heap;\n\nvoid init_heaps() {\n    left_heap.sum_left = 0;\n    left_heap.sum_right = 0;\n    left_heap.count_left = 0;\n    left_heap.count_right = 0;\n    left_heap.total_add = 0;\n    left_heap.min_x = 0;\n    left_heap.min_val = 0;\n    \n    right_heap.sum_left = 0;\n    right_heap.sum_right = 0;\n    right_heap.count_left = 0;\n    right_heap.count_right = 0;\n    right_heap.total_add = 0;\n    right_heap.min_x = 0;\n    right_heap.min_val = 0;\n}\n\nvoid update_left(ll a, ll b) {\n    left_heap.total_add += b;\n    \n    if (left_heap.count_left == 0 || a <= left_heap.min_x) {\n        left_heap.sum_left += a;\n        left_heap.count_left++;\n        left_heap.min_x = a;\n    } else {\n        left_heap.sum_right += a;\n        left_heap.count_right++;\n    }\n    \n    left_heap.min_val = left_heap.min_x * left_heap.count_left - left_heap.sum_left;\n    left_heap.min_val += (left_heap.sum_right - left_heap.min_x * left_heap.count_right);\n    left_heap.min_val += left_heap.total_add;\n}\n\nvoid update_right(ll a, ll b) {\n    right_heap.total_add += b;\n    \n    if (right_heap.count_left == 0 || a <= right_heap.min_x) {\n        right_heap.sum_left += a;\n        right_heap.count_left++;\n        right_heap.min_x = a;\n    } else {\n        right_heap.sum_right += a;\n        right_heap.count_right++;\n    }\n    \n    right_heap.min_val = right_heap.min_x * right_heap.count_left - right_heap.sum_left;\n    right_heap.min_val += (right_heap.sum_right - right_heap.min_x * right_heap.count_right);\n    right_heap.min_val += right_heap.total_add;\n}\n\nvoid balance_heaps() {\n    while (left_heap.count_right > 0) {\n        ll a = left_heap.sum_right / left_heap.count_right; // Simplified, actual logic may differ\n        left_heap.sum_right -= a;\n        left_heap.count_right--;\n        update_right(a, 0);\n    }\n    \n    while (right_heap.count_left > 0 && right_heap.min_x < left_heap.min_x) {\n        ll a = right_heap.min_x;\n        right_heap.sum_left -= a;\n        right_heap.count_left--;\n        update_left(a, 0);\n    }\n}\n\nvoid process_update(ll a, ll b) {\n    update_left(a, b);\n    balance_heaps();\n}\n\nvoid process_evaluation() {\n    printf(\"%lld %lld\\n\", left_heap.min_x, left_heap.min_val + right_heap.min_val);\n}\n\nint main() {\n    init_heaps();\n    \n    int Q;\n    scanf(\"%d\", &Q);\n    \n    int first;\n    ll a, b;\n    scanf(\"%d %lld %lld\", &first, &a, &b);\n    process_update(a, b);\n    \n    for (int i = 1; i < Q; ++i) {\n        int type;\n        scanf(\"%d\", &type);\n        \n        if (type == 1) {\n            scanf(\"%lld %lld\", &a, &b);\n            process_update(a, b);\n        } else {\n            process_evaluation();\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:51:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int Q;\n    cin >> Q;\n    char type;\n    long long a, b;\n    cin >> type >> a >> b;\n\n    multiset<long long> left, right;\n    left.insert(a);\n    right.insert(a);\n    long long sum_left = a, sum_right = a;\n    long long sum_b = b;\n    long long median = a;\n\n    for (int q = 1; q < Q; ++q) {\n        cin >> type;\n        if (type == '1') {\n            cin >> a >> b;\n            sum_b += b;\n\n            if (left.size() == 0 || a <= *left.rbegin()) {\n                left.insert(a);\n                sum_left += a;\n            } else {\n                right.insert(a);\n                sum_right += a;\n            }\n\n            // Balance the sets\n            if (left.size() > right.size() + 1) {\n                auto it = prev(left.end());\n                sum_left -= *it;\n                sum_right += *it;\n                right.insert(*it);\n                left.erase(it);\n            } else if (right.size() > left.size()) {\n                auto it = right.begin();\n                sum_right -= *it;\n                sum_left += *it;\n                left.insert(*it);\n                right.erase(it);\n            }\n\n            median = *left.rbegin();\n        } else {\n            long long min_x = median;\n            long long min_f = (sum_right - median * right.size()) - (sum_left - median * left.size()) + sum_b;\n            cout << min_x << \" \" << min_f << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:51:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Main {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        \n        int Q = Integer.parseInt(br.readLine());\n        String[] firstQuery = br.readLine().split(\" \");\n        int a = Integer.parseInt(firstQuery[1]);\n        int b = Integer.parseInt(firstQuery[2]);\n        \n        PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Collections.reverseOrder());\n        PriorityQueue<Integer> minHeap = new PriorityQueue<>();\n        maxHeap.add(a);\n        minHeap.add(a);\n        \n        long sumLeft = 0;\n        long sumRight = 0;\n        int leftSize = 1;\n        int rightSize = 0;\n        \n        long sumB = b;\n        long minFX = Math.abs(0 - a) + b;\n        \n        for (int q = 1; q < Q; q++) {\n            String[] query = br.readLine().split(\" \");\n            if (query[0].equals(\"1\")) {\n                a = Integer.parseInt(query[1]);\n                b = Integer.parseInt(query[2]);\n                sumB += b;\n                \n                if (maxHeap.isEmpty() || a <= maxHeap.peek()) {\n                    maxHeap.add(a);\n                    sumLeft += a;\n                    leftSize++;\n                } else {\n                    minHeap.add(a);\n                    sumRight += a;\n                    rightSize++;\n                }\n                \n                if (leftSize > rightSize + 1) {\n                    int moved = maxHeap.poll();\n                    sumLeft -= moved;\n                    leftSize--;\n                    minHeap.add(moved);\n                    sumRight += moved;\n                    rightSize++;\n                } else if (rightSize > leftSize) {\n                    int moved = minHeap.poll();\n                    sumRight -= moved;\n                    rightSize--;\n                    maxHeap.add(moved);\n                    sumLeft += moved;\n                    leftSize++;\n                }\n            } else {\n                int median = maxHeap.peek();\n                long res = (long) median * leftSize - sumLeft + sumRight - (long) median * rightSize + sumB;\n                bw.write(median + \" \" + res + \"\\n\");\n            }\n        }\n        bw.flush();\n    }\n}",
    "timestamp": "2025-08-05 22:52:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Solution {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));\n        \n        int Q = Integer.parseInt(br.readLine());\n        long best = 0;\n        int bestX = 0;\n        \n        for (int q = 0; q < Q; q++) {\n            String[] query = br.readLine().split(\" \");\n            \n            if (query[0].equals(\"1\")) {\n                int a = Integer.parseInt(query[1]);\n                int b = Integer.parseInt(query[2]);\n                \n                long newBest = Math.abs(bestX - a) + b + best;\n                long newBestX = a;\n                \n                if (newBest < best || (newBest == best && a < bestX)) {\n                    best = newBest;\n                    bestX = a;\n                }\n            } else {\n                bw.write(bestX + \" \" + best + \"\\n\");\n            }\n        }\n        \n        bw.flush();\n        bw.close();\n    }\n}",
    "timestamp": "2025-08-05 22:52:52"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <climits>\n#include <cmath>\n\nusing namespace std;\n\nclass PiecewiseFunction {\nprivate:\n    vector<pair<long long, long long>> points;\n\npublic:\n    void update(long long a, long long b) {\n        vector<pair<long long, long long>> newPoints;\n        for (auto& p : points) {\n            newPoints.push_back({p.first, p.second + abs(p.first - a) + b});\n        }\n        \n        // Add new point\n        newPoints.push_back({a, b});\n        \n        points = newPoints;\n    }\n\n    pair<long long, long long> minimize() {\n        long long minX = LLONG_MAX;\n        long long minVal = LLONG_MAX;\n        \n        for (auto& p : points) {\n            if (p.second < minVal || (p.second == minVal && p.first < minX)) {\n                minX = p.first;\n                minVal = p.second;\n            }\n        }\n        \n        return {minX, minVal};\n    }\n};\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int Q;\n    cin >> Q;\n\n    PiecewiseFunction f;\n    \n    while (Q--) {\n        int type;\n        cin >> type;\n        \n        if (type == 1) {\n            long long a, b;\n            cin >> a >> b;\n            f.update(a, b);\n        } else {\n            auto [x, val] = f.minimize();\n            cout << x << \" \" << val << \"\\n\";\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:52:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ninput = sys.stdin.readline\n\nQ = int(input())\nmin_x = 0\nmin_val = 0\nsum_a = 0\nsum_b = 0\n\nfor _ in range(Q):\n    query = input().split()\n    type_query = int(query[0])\n    \n    if type_query == 1:\n        a = int(query[1])\n        b = int(query[2])\n        sum_a += a\n        sum_b += b\n        min_val += abs(min_x - a) + b\n        \n    elif type_query == 2:\n        print(min_x, min_val)",
    "timestamp": "2025-08-13 12:46:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.Scanner;\nimport java.util.TreeMap;\n\npublic class MinFunctionQueries {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int Q = scanner.nextInt();\n        \n        long totalB = 0;\n        TreeMap<Long, Long> slopes = new TreeMap<>();\n        \n        // Process all queries\n        for (int i = 0; i < Q; i++) {\n            int type = scanner.nextInt();\n            \n            if (type == 1) {\n                long a = scanner.nextLong();\n                long b = scanner.nextLong();\n                \n                totalB += b;\n                \n                // Update slopes around a\n                slopes.put(a, slopes.getOrDefault(a, 0L) + 1);\n                slopes.put(a + 1, slopes.getOrDefault(a + 1, 0L) - 1);\n            } else if (type == 2) {\n                long currentSlope = 0;\n                long minX = Long.MAX_VALUE;\n                long minValue = Long.MAX_VALUE;\n                long currentF = 0;\n                long lastX = slopes.firstKey();\n                \n                for (var entry : slopes.entrySet()) {\n                    long x = entry.getKey();\n                    if (currentSlope < 0 && currentF < minValue) {\n                        minValue = currentF;\n                        minX = lastX;\n                    }\n                    // Calculate f(x) up to this x\n                    currentF += currentSlope * (x - lastX);\n                    \n                    // Check min value at this point\n                    if (currentSlope < 0 && currentF < minValue) {\n                        minValue = currentF;\n                        minX = x;\n                    }\n                    \n                    // Update slope\n                    currentSlope += entry.getValue();\n                    lastX = x;\n                }\n                \n                // Add totalB to the final minimum f(x)\n                minValue += totalB;\n                \n                System.out.println(minX + \" \" + minValue);\n            }\n        }\n        \n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 12:46:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_QUERIES 200000\n\nint main() {\n    int Q;\n    scanf(\"%d\", &Q);\n\n    long long ax = 0, bx = 0, min_val = 0;\n    int balance = 0;\n    long long left = LONG_MIN, right = LONG_MAX;\n\n    for (int q = 0; q < Q; ++q) {\n        int type;\n        scanf(\"%d\", &type);\n\n        if (type == 1) {\n            int a, b;\n            scanf(\"%d %d\", &a, &b);\n\n            if (balance == 0) {\n                left = right = a;\n            } else if (balance > 0) {\n                if (a < left) {\n                    left = a;\n                }\n            } else {\n                if (a > right) {\n                    right = a;\n                }\n            }\n\n            balance++;\n            ax += a;\n            bx += b;\n            \n            if (balance == 0) {\n                min_val = bx;\n            }\n        } else if (type == 2) {\n            long long result_x;\n            if (balance > 0) {\n                result_x = left;\n                min_val = bx - ax + balance * left;\n            } else {\n                result_x = right;\n                min_val = bx - ax + balance * right;\n            }\n            printf(\"%lld %lld\\n\", result_x, min_val);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 12:46:57"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "class FunctionMinimizer {\n  constructor() {\n    this.changes = [];\n  }\n\n  update(a, b) {\n    this.changes.push({ a, b });\n  }\n\n  evaluate() {\n    let minX = 0;\n    let minValue = Infinity;\n\n    for (let x = -10**9; x <= 10**9; x++) {\n      let currentValue = 0;\n\n      for (let change of this.changes) {\n        currentValue += Math.abs(x - change.a) + change.b;\n      }\n\n      if (currentValue < minValue) {\n        minValue = currentValue;\n        minX = x;\n      }\n    }\n\n    console.log(minX, minValue);\n  }\n\n  processQuery(query) {\n    const parts = query.split(' ');\n    const type = parseInt(parts[0], 10);\n\n    if (type === 1) {\n      const a = parseInt(parts[1], 10);\n      const b = parseInt(parts[2], 10);\n      this.update(a, b);\n    } else if (type === 2) {\n      this.evaluate();\n    }\n  }\n}\n\nfunction processQueries(queries) {\n  const functionMinimizer = new FunctionMinimizer();\n\n  for (let query of queries) {\n    functionMinimizer.processQuery(query);\n  }\n}\n\nprocessQueries([\"1 2 3\", \"2\", \"1 -1 -1\", \"2\"]);",
    "timestamp": "2025-08-13 12:47:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    f = [0] * (2 * 10**5 + 1)\n    offset = 10**5\n\n    Q = int(input())\n    x_min = offset\n\n    for _ in range(Q):\n        query = list(map(int, input().split()))\n\n        if query[0] == 1:\n            a, b = query[1], query[2]\n            for x in range(2 * offset + 1):\n                f[x] += abs(x - offset - a) + b\n\n        else:\n            min_val = float('inf')\n            best_x = 0\n            for x in range(2 * offset + 1):\n                if f[x] < min_val or (f[x] == min_val and x < best_x):\n                    min_val = f[x]\n                    best_x = x\n\n            print(best_x - offset, min_val)\n\nsolve()",
    "timestamp": "2025-08-13 12:47:06"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(queries) {\n    let f = new Map();\n    let minX = 0;\n    let minVal = 0;\n\n    for (let query of queries) {\n        let parts = query.split(' ').map(Number);\n        \n        if (parts[0] === 1) {\n            let [, a, b] = parts;\n            \n            for (let [x, val] of f) {\n                f.set(x, val + Math.abs(x - a) + b);\n            }\n            \n            if (!f.has(a)) {\n                f.set(a, Math.abs(0 - a) + b);\n            }\n            \n            let candidates = [...f.keys()];\n            minX = candidates[0];\n            minVal = f.get(minX);\n            \n            for (let x of candidates) {\n                if (f.get(x) < minVal || (f.get(x) === minVal && x < minX)) {\n                    minX = x;\n                    minVal = f.get(x);\n                }\n            }\n        } else {\n            console.log(`${minX} ${minVal}`);\n        }\n    }\n}",
    "timestamp": "2025-08-13 12:47:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nimport heapq\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    Q = int(input[ptr])\n    ptr += 1\n    \n    left_heap = []  # max heap (using min heap with inverted values)\n    right_heap = []  # min heap\n    sum_left = 0\n    sum_right = 0\n    left_size = 0\n    right_size = 0\n    b_sum = 0\n    \n    for _ in range(Q):\n        parts = input[ptr]\n        if parts == '2':\n            ptr += 1\n            x = -left_heap[0][0] if left_heap else 0\n            # Calculate min value\n            min_val = (x * left_size - sum_left) + (sum_right - x * right_size) + b_sum\n            print(x, min_val)\n        else:\n            a = int(input[ptr + 1])\n            b = int(input[ptr + 2])\n            ptr += 3\n            b_sum += b\n            \n            # Insert a into the heaps\n            if left_size == 0 or a <= -left_heap[0][0]:\n                heapq.heappush(left_heap, (-a, a))\n                sum_left += a\n                left_size += 1\n            else:\n                heapq.heappush(right_heap, a)\n                sum_right += a\n                right_size += 1\n            \n            # Balance heaps\n            if left_size > right_size + 1:\n                val = heapq.heappop(left_heap)[1]\n                sum_left -= val\n                left_size -= 1\n                heapq.heappush(right_heap, val)\n                sum_right += val\n                right_size += 1\n            elif right_size > left_size:\n                val = heapq.heappop(right_heap)\n                sum_right -= val\n                right_size -= 1\n                heapq.heappush(left_heap, (-val, val))\n                sum_left += val\n                left_size += 1\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 12:47:23"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const readline = require('readline');\nconst rl = readline.createInterface({\n    input: process.stdin,\n    output: process.stdout\n});\n\nlet Q;\nlet queries = [];\nlet leftHeap = new MaxPriorityQueue({ priority: x => x });\nlet rightHeap = new MinPriorityQueue({ priority: x => x });\nlet leftSum = 0, rightSum = 0;\nlet leftSize = 0, rightSize = 0;\nlet totalAdd = 0;\n\nrl.on('line', (line) => {\n    if (!Q) {\n        Q = parseInt(line);\n    } else {\n        queries.push(line.trim());\n        if (queries.length === Q) {\n            processQueries();\n            rl.close();\n        }\n    }\n});\n\nfunction processQueries() {\n    for (let query of queries) {\n        let parts = query.split(' ');\n        if (parts[0] === '1') {\n            let a = parseInt(parts[1]);\n            let b = parseInt(parts[2]);\n            update(a, b);\n        } else {\n            let result = evaluate();\n            console.log(result[0] + ' ' + result[1]);\n        }\n    }\n}\n\nfunction update(a, b) {\n    if (leftSize === 0 || a <= leftHeap.front().element) {\n        leftHeap.enqueue(a);\n        leftSum += a;\n        leftSize++;\n    } else {\n        rightHeap.enqueue(a);\n        rightSum += a;\n        rightSize++;\n    }\n    balanceHeaps();\n    totalAdd += b;\n}\n\nfunction balanceHeaps() {\n    if (leftSize > rightSize + 1) {\n        let val = leftHeap.dequeue().element;\n        leftSum -= val;\n        leftSize--;\n        rightHeap.enqueue(val);\n        rightSum += val;\n        rightSize++;\n    } else if (rightSize > leftSize) {\n        let val = rightHeap.dequeue().element;\n        rightSum -= val;\n        rightSize--;\n        leftHeap.enqueue(val);\n        leftSum += val;\n        leftSize++;\n    }\n}\n\nfunction evaluate() {\n    let median = leftHeap.front().element;\n    let minValue = median * leftSize - leftSum + rightSum - median * rightSize + totalAdd;\n    return [median, minValue];\n}\n\n// Priority Queue implementations (using simplified versions for the problem)\nclass MaxPriorityQueue {\n    constructor({ priority }) {\n        this.heap = [];\n        this.priority = priority;\n    }\n\n    enqueue(value) {\n        this.heap.push(value);\n        this.bubbleUp();\n    }\n\n    dequeue() {\n        const max = this.heap[0];\n        const end = this.heap.pop();\n        if (this.heap.length > 0) {\n            this.heap[0] = end;\n            this.sinkDown();\n        }\n        return { element: max };\n    }\n\n    front() {\n        return { element: this.heap[0] };\n    }\n\n    bubbleUp() {\n        let index = this.heap.length - 1;\n        while (index > 0) {\n            let parentIndex = Math.floor((index - 1) / 2);\n            if (this.priority(this.heap[parentIndex]) >= this.priority(this.heap[index])) break;\n            [this.heap[parentIndex], this.heap[index]] = [this.heap[index], this.heap[parentIndex]];\n            index = parentIndex;\n        }\n    }\n\n    sinkDown() {\n        let index = 0;\n        const length = this.heap.length;\n        while (true) {\n            let leftChildIndex = 2 * index + 1;\n            let rightChildIndex = 2 * index + 2;\n            let swap = null;\n\n            if (leftChildIndex < length) {\n                if (this.priority(this.heap[leftChildIndex]) > this.priority(this.heap[index])) {\n                    swap = leftChildIndex;\n                }\n            }\n\n            if (rightChildIndex < length) {\n                if (\n                    (swap === null && this.priority(this.heap[rightChildIndex]) > this.priority(this.heap[index])) ||\n                    (swap !== null && this.priority(this.heap[rightChildIndex]) > this.priority(this.heap[leftChildIndex]))\n                ) {\n                    swap = rightChildIndex;\n                }\n            }\n\n            if (swap === null) break;\n            [this.heap[index], this.heap[swap]] = [this.heap[swap], this.heap[index]];\n            index = swap;\n        }\n    }\n}\n\nclass MinPriorityQueue {\n    constructor({ priority }) {\n        this.heap = [];\n        this.priority = priority;\n    }\n\n    enqueue(value) {\n        this.heap.push(value);\n        this.bubbleUp();\n    }\n\n    dequeue() {\n        const min = this.heap[0];\n        const end = this.heap.pop();\n        if (this.heap.length > 0) {\n            this.heap[0] = end;\n            this.sinkDown();\n        }\n        return { element: min };\n    }\n\n    front() {\n        return { element: this.heap[0] };\n    }\n\n    bubbleUp() {\n        let index = this.heap.length - 1;\n        while (index > 0) {\n            let parentIndex = Math.floor((index - 1) / 2);\n            if (this.priority(this.heap[parentIndex]) <= this.priority(this.heap[index])) break;\n            [this.heap[parentIndex], this.heap[index]] = [this.heap[index], this.heap[parentIndex]];\n            index = parentIndex;\n        }\n    }\n\n    sinkDown() {\n        let index = 0;\n        const length = this.heap.length;\n        while (true) {\n            let leftChildIndex = 2 * index + 1;\n            let rightChildIndex = 2 * index + 2;\n            let swap = null;\n\n            if (leftChildIndex < length) {\n                if (this.priority(this.heap[leftChildIndex]) < this.priority(this.heap[index])) {\n                    swap = leftChildIndex;\n                }\n            }\n\n            if (rightChildIndex < length) {\n                if (\n                    (swap === null && this.priority(this.heap[rightChildIndex]) < this.priority(this.heap[index])) ||\n                    (swap !== null && this.priority(this.heap[rightChildIndex]) < this.priority(this.heap[leftChildIndex]))\n                ) {\n                    swap = rightChildIndex;\n                }\n            }\n\n            if (swap === null) break;\n            [this.heap[index], this.heap[swap]] = [this.heap[swap], this.heap[index]];\n            index = swap;\n        }\n    }\n}",
    "timestamp": "2025-08-13 12:48:00"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <limits>\n\nusing namespace std;\n\nstruct Segment {\n    long long add; // accumulated addition from |x - a|\n    long long constant; // accumulated constant addition b\n    int boundaryLeft;\n    int boundaryRight;\n    \n    Segment(long long a, long long c, int x) : add(a), constant(c), boundaryLeft(x), boundaryRight(x) {}\n};\n\nint main() {\n    int Q;\n    cin >> Q;\n    \n    vector<Segment> segments;\n    int first_a, first_b;\n    cin >> first_a >> first_b;\n    segments.emplace_back(0, first_b, first_a);\n\n    for (int i = 1; i < Q; ++i) {\n        int type;\n        cin >> type;\n        \n        if (type == 1) {\n            int a, b;\n            cin >> a >> b;\n            \n            long long new_add = segments.back().add + abs(segments.back().boundaryLeft - a);\n            long long new_constant = segments.back().constant + b;\n            segments.emplace_back(new_add, new_constant, a);\n        } \n        else if (type == 2) {\n            long long min_x = numeric_limits<long long>::max();\n            long long min_value = numeric_limits<long long>::max();\n            \n            for (const auto& seg : segments) {\n                if ((seg.add + seg.constant) < min_value || ((seg.add + seg.constant) == min_value && seg.boundaryLeft < min_x)) {\n                    min_value = seg.add + seg.constant;\n                    min_x = seg.boundaryLeft;\n                }\n            }\n            \n            cout << min_x << \" \" << min_value << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 14:36:18"
  }
]