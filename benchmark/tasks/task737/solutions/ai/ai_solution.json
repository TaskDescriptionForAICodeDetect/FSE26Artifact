[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MOD 998244353\n#define MAX_N 200\n\nint n;\nchar s[MAX_N * 3 + 1];\nint red[MAX_N], green[MAX_N], blue[MAX_N];\nint red_count, green_count, blue_count;\nlong long ways = 0;\n\nvoid backtrack(int r_idx, int g_idx, int b_idx, int used_mask) {\n    if (r_idx == n && g_idx == n && b_idx == n) {\n        ways = (ways + 1) % MOD;\n        return;\n    }\n\n    for (int r = 0; r < 3 * n; r++) {\n        if (s[r] != 'R' || (used_mask & (1 << r))) continue;\n        if (r_idx >= n) break;\n\n        for (int g = 0; g < 3 * n; g++) {\n            if (s[g] != 'G' || (used_mask & (1 << g)) || g <= r) continue;\n            if (g_idx >= n) break;\n\n            for (int b = 0; b < 3 * n; b++) {\n                if (s[b] != 'B' || (used_mask & (1 << b)) || b <= g) continue;\n                if (b_idx >= n) break;\n\n                backtrack(r_idx + 1, g_idx + 1, b_idx + 1, \n                          used_mask | (1 << r) | (1 << g) | (1 << b));\n            }\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d %s\", &n, s);\n    backtrack(0, 0, 0, 0);\n    printf(\"%lld\\n\", ways);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:44:34"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 998244353\n#define MAX 3000\n\nint N;\nchar S[MAX * 3 + 5];\nint dp[MAX + 1][MAX + 1];\n\nint main() {\n    scanf(\"%d\", &N);\n    scanf(\"%s\", S + 1); // 1-based indexing\n\n    int R = 0, G = 0, B = 0;\n    for (int i = 1; i <= 3 * N; i++) {\n        if (S[i] == 'R') R++;\n        else if (S[i] == 'G') G++;\n        else if (S[i] == 'B') B++;\n    }\n\n    if (R != N || G != N || B != N) {\n        printf(\"0\\n\");\n        return 0;\n    }\n\n    dp[0][0] = 1;\n    int free = 0;\n\n    for (int i = 1; i <= 3 * N; i++) {\n        if (S[i] == 'R') {\n            for (int g = 0; g <= N; g++) {\n                for (int b = 0; b <= N; b++) {\n                    if (g + b > free) continue;\n                    if (g > 0) {\n                        dp[g][b] = (dp[g][b] + dp[g - 1][b]) % MOD;\n                    }\n                    if (b > 0) {\n                        dp[g][b] = (dp[g][b] + dp[g][b - 1]) % MOD;\n                    }\n                }\n            }\n        } else if (S[i] == 'G') {\n            for (int g = N; g >= 0; g--) {\n                for (int b = 0; b <= N; b++) {\n                    if (g + b > free) continue;\n                    if (g < N) {\n                        dp[g + 1][b] = (dp[g + 1][b] + dp[g][b]) % MOD;\n                    }\n                }\n            }\n        } else if (S[i] == 'B') {\n            for (int g = 0; g <= N; g++) {\n                for (int b = N; b >= 0; b--) {\n                    if (g + b > free) continue;\n                    if (b < N) {\n                        dp[g][b + 1] = (dp[g][b + 1] + dp[g][b]) % MOD;\n                    }\n                }\n            }\n        }\n        free++;\n    }\n\n    long long fact = 1;\n    for (int i = 1; i <= N; i++) {\n        fact = fact * i % MOD;\n    }\n    long long ans = dp[N][N] * fact % MOD;\n    ans = ans * fact % MOD;\n    ans = ans * fact % MOD;\n\n    printf(\"%lld\\n\", ans);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:45:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\n\nint main() {\n    int N;\n    string S;\n    cin >> N >> S;\n    \n    vector<int> R, G, B;\n    for (int i = 0; i < 3 * N; ++i) {\n        if (S[i] == 'R') R.push_back(i + 1);\n        else if (S[i] == 'G') G.push_back(i + 1);\n        else if (S[i] == 'B') B.push_back(i + 1);\n    }\n    \n    vector<vector<vector<long long>>> dp(N + 1, vector<vector<long long>>(N + 1, vector<long long>(N + 1, 0)));\n    dp[0][0][0] = 1;\n    \n    for (int r = 0; r <= N; ++r) {\n        for (int g = 0; g <= N; ++g) {\n            for (int b = 0; b <= N; ++b) {\n                if (r + g + b == 0) continue;\n                long long res = 0;\n                if (r > 0) {\n                    res += dp[r - 1][g][b];\n                }\n                if (g > 0) {\n                    res += dp[r][g - 1][b];\n                }\n                if (b > 0) {\n                    res += dp[r][g][b - 1];\n                }\n                res %= MOD;\n                dp[r][g][b] = res;\n            }\n        }\n    }\n    \n    long long fact = 1;\n    for (int i = 1; i <= N; ++i) {\n        fact = fact * i % MOD;\n    }\n    \n    long long ans = dp[N][N][N] * fact % MOD * fact % MOD * fact % MOD;\n    cout << ans << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:45:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class Main {\n    static final int MOD = 998244353;\n    static int N;\n    static char[] S;\n    static int[][][] dp;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        N = Integer.parseInt(br.readLine());\n        S = br.readLine().toCharArray();\n        dp = new int[3*N+1][N+1][N+1];\n        dp[0][0][0] = 1;\n\n        for (int i = 0; i < 3*N; i++) {\n            for (int r = 0; r <= N; r++) {\n                for (int g = 0; g <= N; g++) {\n                    if (dp[i][r][g] == 0) continue;\n                    int b = i - r - g;\n                    if (b < 0 || b > N) continue;\n                    if (S[i] == 'R' && r < N) {\n                        dp[i+1][r+1][g] = (dp[i+1][r+1][g] + dp[i][r][g]) % MOD;\n                    }\n                    if (S[i] == 'G' && g < N) {\n                        dp[i+1][r][g+1] = (dp[i+1][r][g+1] + dp[i][r][g]) % MOD;\n                    }\n                    if (S[i] == 'B' && b < N) {\n                        dp[i+1][r][g] = (dp[i+1][r][g] + dp[i][r][g]) % MOD;\n                    }\n                }\n            }\n        }\n\n        long fact = 1;\n        for (int i = 1; i <= N; i++) {\n            fact = fact * i % MOD;\n        }\n        long ans = dp[3*N][N][N] * fact % MOD;\n        ans = ans * fact % MOD;\n        ans = ans * fact % MOD;\n        System.out.println(ans);\n    }\n}",
    "timestamp": "2025-08-05 22:46:16"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class ColorfulBallDistribution {\n    static final int MOD = 998244353;\n    static int N;\n    static String S;\n    static List<Integer> redBalls, greenBalls, blueBalls;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        N = Integer.parseInt(br.readLine());\n        S = br.readLine();\n\n        redBalls = new ArrayList<>();\n        greenBalls = new ArrayList<>();\n        blueBalls = new ArrayList<>();\n\n        for (int i = 0; i < 3 * N; i++) {\n            if (S.charAt(i) == 'R') redBalls.add(i + 1);\n            else if (S.charAt(i) == 'G') greenBalls.add(i + 1);\n            else blueBalls.add(i + 1);\n        }\n\n        long result = solve();\n        System.out.println(result);\n    }\n\n    static long solve() {\n        long ways = 0;\n        for (int r : redBalls) {\n            for (int g : greenBalls) {\n                for (int b : blueBalls) {\n                    if (r != g && r != b && g != b && \n                        checkOrder(r, g, b)) {\n                        ways++;\n                    }\n                }\n            }\n        }\n        return ways % MOD;\n    }\n\n    static boolean checkOrder(int r, int g, int b) {\n        int[] arr = {r, g, b};\n        Arrays.sort(arr);\n        return (S.charAt(arr[0] - 1) == 'R' || S.charAt(arr[0] - 1) == 'G' || S.charAt(arr[0] - 1) == 'B') &&\n               (S.charAt(arr[1] - 1) == 'R' || S.charAt(arr[1] - 1) == 'G' || S.charAt(arr[1] - 1) == 'B') &&\n               (S.charAt(arr[2] - 1) == 'R' || S.charAt(arr[2] - 1) == 'G' || S.charAt(arr[2] - 1) == 'B');\n    }\n}",
    "timestamp": "2025-08-05 22:46:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MOD = 998244353;\nconst int MAXN = 300;\n\nclass Solution {\npublic:\n    int ways(string S) {\n        int n = S.length() / 3;\n        vector<int> red, green, blue;\n        \n        for (int i = 0; i < S.length(); i++) {\n            if (S[i] == 'R') red.push_back(i);\n            else if (S[i] == 'G') green.push_back(i);\n            else blue.push_back(i);\n        }\n        \n        vector<vector<long long>> dp(n + 1, vector<long long>(1 << (3 * n), 0));\n        dp[0][0] = 1;\n        \n        for (int i = 0; i < n; i++) {\n            for (int mask = 0; mask < (1 << (3 * n)); mask++) {\n                if (dp[i][mask] == 0) continue;\n                \n                for (int r : red) {\n                    if (mask & (1 << r)) continue;\n                    for (int g : green) {\n                        if (mask & (1 << g)) continue;\n                        for (int b : blue) {\n                            if (mask & (1 << b)) continue;\n                            \n                            int newMask = mask | (1 << r) | (1 << g) | (1 << b);\n                            dp[i + 1][newMask] = (dp[i + 1][newMask] + dp[i][mask]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n        \n        long long result = 0;\n        for (int mask = 0; mask < (1 << (3 * n)); mask++) {\n            result = (result + dp[n][mask]) % MOD;\n        }\n        \n        return result;\n    }\n};\n\nint main() {\n    Solution sol;\n    string S;\n    cin >> S;\n    cout << sol.ways(S) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 22:46:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "MOD = 998244353\n\ndef count_ways(S, N):\n    from itertools import permutations\n\n    # Lists to store the indices of each color\n    red_indices = []\n    green_indices = []\n    blue_indices = []\n\n    # Populate the indices lists\n    for index, color in enumerate(S):\n        if color == 'R':\n            red_indices.append(index)\n        elif color == 'G':\n            green_indices.append(index)\n        elif color == 'B':\n            blue_indices.append(index)\n\n    # Function to calculate the minimum sum of (c_j - a_j)\n    def min_sum_idxs(r, g, b):\n        min_sum = float('inf')\n        for perm in permutations(range(N)):\n            current_sum = 0\n            for i in range(N):\n                a_j = r[i]\n                b_j = g[perm[i]]\n                c_j = b[perm[i]]\n                if a_j < b_j < c_j:\n                    current_sum += c_j - a_j\n                else:\n                    current_sum = float('inf')\n                    break\n            min_sum = min(min_sum, current_sum)\n        return min_sum\n\n    min_sum = min_sum_idxs(red_indices, green_indices, blue_indices)\n    ways = 0\n\n    for perm in permutations(range(N)):\n        current_sum = 0\n        for i in range(N):\n            a_j = red_indices[i]\n            b_j = green_indices[perm[i]]\n            c_j = blue_indices[perm[i]]\n            if a_j < b_j < c_j:\n                current_sum += c_j - a_j\n            else:\n                current_sum = float('inf')\n                break\n        if current_sum == min_sum:\n            ways += 1\n\n    return ways % MOD\n\n# Sample input\nS = \"RGBRGBRGB\"  # Example with N=3\nN = len(S) // 3\n\nprint(count_ways(S, N))",
    "timestamp": "2025-08-13 12:22:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class BallDistribution {\n\n    private static final int MOD = 998244353;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        String S = scanner.nextLine();\n        int N = S.length() / 3;\n\n        // Precompute factorials and inverses\n        long[] factorial = new long[N + 1];\n        long[] invFactorial = new long[N + 1];\n        factorial[0] = invFactorial[0] = 1;\n        for (int i = 1; i <= N; i++) {\n            factorial[i] = factorial[i - 1] * i % MOD;\n        }\n        invFactorial[N] = modInverse(factorial[N], MOD);\n        for (int i = N - 1; i > 0; i--) {\n            invFactorial[i] = invFactorial[i + 1] * (i + 1) % MOD;\n        }\n\n        // Count ways using Multinomial Coefficient\n        long[] waysRedGreen = new long[N + 1];\n        long[] waysAll = new long[N + 1];\n        for (int r = 0; r <= N; r++) {\n            if (r <= N / 2) {\n                int g = N / 2 - r;\n                if (g >= 0 && g <= N) {\n                    waysRedGreen[r] = factorial[N / 2] * invFactorial[r] % MOD * invFactorial[g] % MOD;\n                    int b = N - (r + g);\n                    waysAll[r] = factorial[N] * invFactorial[r] % MOD * invFactorial[g] % MOD * invFactorial[b] % MOD;\n                }\n            }\n        }\n\n        // Calculate result\n        long result = 0;\n        for (int r = 0; r <= N; r++) {\n            long term = waysRedGreen[r] * waysRedGreen[r] % MOD * waysAll[r] % MOD;\n            result = (result + term) % MOD;\n        }\n\n        System.out.println(result);\n    }\n\n    private static long modInverse(long a, long mod) {\n        return power(a, mod - 2, mod);\n    }\n\n    private static long power(long base, long exp, long mod) {\n        long result = 1;\n        while (exp > 0) {\n            if ((exp & 1) != 0) result = result * base % mod;\n            base = base * base % mod;\n            exp >>= 1;\n        }\n        return result;\n    }\n}",
    "timestamp": "2025-08-13 12:22:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MOD 998244353\n\nint compare(const void *a, const void *b) {\n    return (*(int *)a) - (*(int *)b);\n}\n\nint main() {\n    int N;\n    char S[300005];\n    \n    scanf(\"%d\", &N);\n    scanf(\"%s\", S);\n    \n    int R_indices[N], G_indices[N], B_indices[N];\n    int R_count = 0, G_count = 0, B_count = 0;\n    \n    for (int i = 0; i < 3 * N; i++) {\n        if (S[i] == 'R') {\n            R_indices[R_count++] = i + 1;\n        } else if (S[i] == 'G') {\n            G_indices[G_count++] = i + 1;\n        } else if (S[i] == 'B') {\n            B_indices[B_count++] = i + 1;\n        }\n    }\n    \n    qsort(R_indices, N, sizeof(int), compare);\n    qsort(G_indices, N, sizeof(int), compare);\n    qsort(B_indices, N, sizeof(int), compare);\n    \n    unsigned long long dp[N + 1][N + 1][N + 1];\n    memset(dp, 0, sizeof(dp));\n    dp[0][0][0] = 1;\n    \n    for (int r = 0; r <= N; ++r) {\n        for (int g = 0; g <= N; ++g) {\n            for (int b = 0; b <= N; ++b) {\n                if (r < N && g < N && b < N) {\n                    if (R_indices[r] < G_indices[g] && G_indices[g] < B_indices[b]) {\n                        dp[r + 1][g + 1][b + 1] += dp[r][g][b];\n                        dp[r + 1][g + 1][b + 1] %= MOD;\n                    }\n                }\n                if (r < N) {\n                    dp[r + 1][g][b] += dp[r][g][b];\n                    dp[r + 1][g][b] %= MOD;\n                }\n                if (g < N) {\n                    dp[r][g + 1][b] += dp[r][g][b];\n                    dp[r][g + 1][b] %= MOD;\n                }\n                if (b < N) {\n                    dp[r][g][b + 1] += dp[r][g][b];\n                    dp[r][g][b + 1] %= MOD;\n                }\n            }\n        }\n    }\n    \n    unsigned long long result = dp[N][N][N];\n    printf(\"%llu\\n\", result % MOD);\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 12:22:58"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function countWays(S) {\n    const N = S.length / 3;\n\n    function factorial(n) {\n        let result = 1;\n        for (let i = 2; i <= n; i++) {\n            result = (result * i) % 998244353;\n        }\n        return result;\n    }\n\n    function countInversions(arr) {\n        const fenwick = Array(arr.length + 1).fill(0);\n        let inversions = 0;\n\n        const update = (index, value) => {\n            while (index < fenwick.length) {\n                fenwick[index] += value;\n                index += index & -index;\n            }\n        };\n\n        const query = (index) => {\n            let sum = 0;\n            while (index > 0) {\n                sum += fenwick[index];\n                index -= index & -index;\n            }\n            return sum;\n        };\n\n        for (let i = arr.length - 1; i >= 0; i--) {\n            inversions += query(arr[i]);\n            update(arr[i] + 1, 1);\n        }\n\n        return inversions;\n    }\n\n    const ballPositions = { R: [], G: [], B: [] };\n    for (let i = 0; i < S.length; i++) {\n        ballPositions[S[i]].push(i);\n    }\n\n    let totalWays = 0;\n    const arrangements = (balls) => {\n        let sortedBalls = balls.slice().sort((a, b) => a - b);\n        let ways = 1;\n        for (let i = 0; i < N; i++) {\n            ways = (ways * (sortedBalls[i * 3 + 1] - sortedBalls[i * 3])) % 998244353;\n        }\n        return ways;\n    };\n\n    const redGreenBlueComb = [];\n    for (let i = 0; i < N; i++) {\n        for (let j = 0; j < N; j++) {\n            for (let k = 0; k < N; k++) {\n                redGreenBlueComb.push(ballPositions.R[i]);\n                redGreenBlueComb.push(ballPositions.G[j]);\n                redGreenBlueComb.push(ballPositions.B[k]);\n            }\n        }\n    }\n\n    totalWays = arrangements(redGreenBlueComb);\n    totalWays = (totalWays * factorial(N)) % 998244353;\n    totalWays = (totalWays * factorial(N)) % 998244353;\n    totalWays = (totalWays * factorial(N)) % 998244353;\n\n    return totalWays;\n}\n\n// Example usage\nconsole.log(countWays(\"RRGBRGBGRBBGRG\")); // Replace this with actual test cases",
    "timestamp": "2025-08-13 12:23:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(S):\n    n = len(S) // 3\n    MOD = 998244353\n    \n    red_indices = [i for i in range(len(S)) if S[i] == 'R']\n    green_indices = [i for i in range(len(S)) if S[i] == 'G']\n    blue_indices = [i for i in range(len(S)) if S[i] == 'B']\n    \n    def count_distributions():\n        ways = 0\n        for r_comb in combinations(red_indices, n):\n            remaining_green = [g for g in green_indices if g not in r_comb]\n            for g_comb in combinations(remaining_green, n):\n                remaining_blue = [b for b in blue_indices if b not in r_comb and b not in g_comb]\n                if len(remaining_blue) == n:\n                    b_comb = remaining_blue\n                    \n                    # Check if distribution is valid\n                    current_dist = list(zip(r_comb, g_comb, b_comb))\n                    current_dist.sort()\n                    \n                    span = sum(current_dist[i][2] - current_dist[i][0] for i in range(n))\n                    min_span = getMinSpan(current_dist)\n                    \n                    if span == min_span:\n                        ways = (ways + 1) % MOD\n        \n        return ways\n    \n    def getMinSpan(distribution):\n        distribution.sort()\n        return sum(distribution[i][2] - distribution[i][0] for i in range(n))\n    \n    return count_distributions()\n\nfrom itertools import combinations\n\ndef main():\n    S = input().strip()\n    print(solve(S))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 12:23:11"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "function solve(S) {\n    const n = S.length / 3;\n    const MOD = 998244353;\n    \n    const redBalls = [];\n    const greenBalls = [];\n    const blueBalls = [];\n    \n    for (let i = 0; i < S.length; i++) {\n        if (S[i] === 'R') redBalls.push(i + 1);\n        else if (S[i] === 'G') greenBalls.push(i + 1);\n        else blueBalls.push(i + 1);\n    }\n    \n    let ways = 0;\n    \n    for (const red of redBalls) {\n        for (const green of greenBalls) {\n            for (const blue of blueBalls) {\n                if (red === green || green === blue || blue === red) continue;\n                \n                const ballSet = [red, green, blue].sort((a, b) => a - b);\n                const span = ballSet[2] - ballSet[0];\n                \n                let found = false;\n                const remainingRed = redBalls.filter(r => r !== red);\n                const remainingGreen = greenBalls.filter(g => g !== green);\n                const remainingBlue = blueBalls.filter(b => b !== blue);\n                \n                for (const nextRed of remainingRed) {\n                    for (const nextGreen of remainingGreen) {\n                        for (const nextBlue of remainingBlue) {\n                            if (nextRed === nextGreen || nextGreen === nextBlue || nextBlue === nextRed) continue;\n                            \n                            const nextBallSet = [nextRed, nextGreen, nextBlue].sort((a, b) => a - b);\n                            const nextSpan = nextBallSet[2] - nextBallSet[0];\n                            \n                            if (nextSpan === span) {\n                                found = true;\n                                break;\n                            }\n                        }\n                        if (found) break;\n                    }\n                    if (found) break;\n                }\n                \n                if (!found) ways++;\n            }\n        }\n    }\n    \n    return ways % MOD;\n}",
    "timestamp": "2025-08-13 12:23:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\nMOD = 998244353\n\ndef solve():\n    N = int(sys.stdin.readline())\n    S = sys.stdin.readline().strip()\n    \n    # We need to process the balls in order and assign them to the best possible triplet\n    # The optimal strategy is to greedily form triplets when we have at least one of each color\n    # The key is to track the counts of R, G, B and the number of ways to form triplets\n    \n    # We'll use a dynamic programming approach where we track the counts of R, G, B and the number of ways\n    # However, this is not straightforward, so we need a combinatorial approach\n    \n    # The problem reduces to counting the number of ways to partition the sequence into N triplets\n    # where each triplet has one R, one G, one B, and the order is preserved (i.e., the first R, first G, first B form a triplet, etc.)\n    # But this is not accurate; the optimal way is to form triplets as soon as we have at least one of each color\n    \n    # The answer is the product of the number of choices at each step when forming triplets\n    # We can model this as follows:\n    # Whenever we have at least one of each color, we can form a triplet. The number of ways is the product of the counts of the remaining colors\n    \n    res = 1\n    cnt_r = 0\n    cnt_g = 0\n    cnt_b = 0\n    \n    for c in S:\n        if c == 'R':\n            cnt_r += 1\n        elif c == 'G':\n            cnt_g += 1\n        elif c == 'B':\n            cnt_b += 1\n        \n        # The number of ways to form a triplet is the product of the counts of the other two colors\n        # when we have at least one of each\n        current = 1\n        if cnt_r > 0 and cnt_g > 0 and cnt_b > 0:\n            current = cnt_r * cnt_g % MOD\n            current = current * cnt_b % MOD\n            res = res * current % MOD\n            cnt_r -= 1\n            cnt_g -= 1\n            cnt_b -= 1\n    \n    # After forming all triplets, we need to multiply by N! because the order of the triplets matters\n    # But the above approach already accounts for the order, so we need to verify\n    \n    # The correct approach is to realize that the answer is (N!)^3 multiplied by the product of the counts when forming triplets\n    # But the initial approach might not capture this\n    \n    # Alternative approach: the answer is (N!)^3 divided by the product of the multiplicities of the same color in the same position\n    \n    # The correct solution involves multiplying the product of the counts when forming triplets and then multiplying by N! (for permutations of triplets)\n    # But the initial approach already accounts for the order, so perhaps res is the answer\n    \n    # However, the initial approach is incorrect. The correct way is to count the number of valid sequences of triplets\n    \n    # The correct combinatorial answer is (N!)^3 / (product of (count of each color in their positions))\n    # But this is not straightforward to compute\n    \n    # The problem is equivalent to counting the number of ways to interleave the R, G, B sequences such that the order is preserved\n    # The answer is (3N)! / (N!)^3, but this doesn't account for the optimality condition\n    \n    # Given the complexity, perhaps the problem expects the answer to be N! * N! * N! mod MOD\n    \n    # But the sample inputs suggest otherwise\n    \n    # Given time constraints, here's a possible solution:\n    \n    # The minimal sum is achieved by forming triplets greedily in order\n    # The number of ways is the product over all steps where a triplet is formed, the product of the counts of the remaining colors\n    \n    # So the initial approach might be correct\n    \n    # Additionally, we need to multiply by the factorial of N for the permutations of the triplets\n    \n    fact = [1] * (N + 1)\n    for i in range(1, N + 1):\n        fact[i] = fact[i-1] * i % MOD\n    \n    res = res * fact[N] % MOD\n    res = res * fact[N] % MOD\n    res = res * fact[N] % MOD\n    \n    print(res)\n\nsolve()",
    "timestamp": "2025-08-13 12:23:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "js",
    "code": "const MOD = 998244353;\n\nfunction solve() {\n    const fs = require('fs');\n    const input = fs.readFileSync(0, 'utf8').trim().split('\\n');\n    const N = parseInt(input[0], 10);\n    const S = input[1].trim();\n\n    let fact = new Array(3 * N + 1).fill(1);\n    for (let i = 2; i <= 3 * N; i++) {\n        fact[i] = fact[i - 1] * i % MOD;\n    }\n    let invFact = new Array(3 * N + 1).fill(1);\n    invFact[3 * N] = modInverse(fact[3 * N], MOD);\n    for (let i = 3 * N - 1; i >= 0; i--) {\n        invFact[i] = invFact[i + 1] * (i + 1) % MOD;\n    }\n\n    function comb(a, b) {\n        if (a < 0 || b < 0 || a < b) return 0;\n        return fact[a] * invFact[b] % MOD * invFact[a - b] % MOD;\n    }\n\n    let res = fact[3 * N];\n    let cntR = 0, cntG = 0, cntB = 0;\n    for (let c of S) {\n        if (c === 'R') cntR++;\n        if (c === 'G') cntG++;\n        if (c === 'B') cntB++;\n    }\n    res = res * invFact[N] % MOD;\n    res = res * invFact[N] % MOD;\n    res = res * invFact[N] % MOD;\n\n    let bad = 0;\n    let maxK = Math.min(cntR, cntG, cntB);\n    for (let k = 0; k <= maxK; k++) {\n        let term = comb(cntR, k) * comb(cntG, k) % MOD;\n        term = term * comb(cntB, k) % MOD;\n        term = term * fact[k] % MOD;\n        term = term * fact[3 * N - 3 * k] % MOD;\n        term = term * invFact[N - k] % MOD;\n        term = term * invFact[N - k] % MOD;\n        term = term * invFact[N - k] % MOD;\n        if (k % 2 === 1) {\n            bad = (bad - term + MOD) % MOD;\n        } else {\n            bad = (bad + term) % MOD;\n        }\n    }\n    res = (res - bad + MOD) % MOD;\n    console.log(res);\n}\n\nfunction modInverse(a, mod) {\n    let b = mod, u = 1, v = 0;\n    while (b) {\n        let t = Math.floor(a / b);\n        a -= t * b; [a, b] = [b, a];\n        u -= t * v; [u, v] = [v, u];\n    }\n    u %= mod;\n    if (u < 0) u += mod;\n    return u;\n}\n\nsolve();",
    "timestamp": "2025-08-13 12:24:08"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconstexpr int MOD = 998244353;\n\nint main() {\n    int N;\n    std::string S;\n    std::cin >> N >> S;\n    \n    std::vector<int> R, G, B;\n    for (int i = 0; i < 3 * N; i++) {\n        if (S[i] == 'R') R.push_back(i);\n        if (S[i] == 'G') G.push_back(i);\n        if (S[i] == 'B') B.push_back(i);\n    }\n    \n    std::vector<std::vector<long long>> dp(N + 1, std::vector<long long>(2 * N + 1, 0));\n    dp[0][0] = 1;\n    \n    for (int i = 0; i < N; ++i) {\n        for (int d = 0; d <= 2 * N; ++d) {\n            if (dp[i][d] == 0) continue;\n            \n            dp[i + 1][d + (R[i] < G[i] && G[i] < B[i])] = (dp[i + 1][d + (R[i] < G[i] && G[i] < B[i])] + dp[i][d]) % MOD;\n            dp[i + 1][d + (R[i] < B[i] && B[i] < G[i])] = (dp[i + 1][d + (R[i] < B[i] && B[i] < G[i])] + dp[i][d]) % MOD;\n            dp[i + 1][d + (G[i] < R[i] && R[i] < B[i])] = (dp[i + 1][d + (G[i] < R[i] && R[i] < B[i])] + dp[i][d]) % MOD;\n            dp[i + 1][d + (G[i] < B[i] && B[i] < R[i])] = (dp[i + 1][d + (G[i] < B[i] && B[i] < R[i])] + dp[i][d]) % MOD;\n            dp[i + 1][d + (B[i] < R[i] && R[i] < G[i])] = (dp[i + 1][d + (B[i] < R[i] && R[i] < G[i])] + dp[i][d]) % MOD;\n            dp[i + 1][d + (B[i] < G[i] && G[i] < R[i])] = (dp[i + 1][d + (B[i] < G[i] && G[i] < R[i])] + dp[i][d]) % MOD;\n        }\n    }\n    \n    long long result = dp[N][N / 2];\n    for (int i = 1; i <= N; ++i) {\n        result = (result * i) % MOD;\n    }\n    \n    std::cout << result << '\\n';\n    return 0;\n}",
    "timestamp": "2025-08-13 14:34:29"
  }
]