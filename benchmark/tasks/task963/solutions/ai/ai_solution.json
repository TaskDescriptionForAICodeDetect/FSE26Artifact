[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\nNode* graph[MAX_N];\nint visited[MAX_N];\nint path[MAX_N];\nint path_len;\nint max_path_len;\n\nvoid add_edge(int u, int v) {\n    Node* new_node = malloc(sizeof(Node));\n    new_node->vertex = v;\n    new_node->next = graph[u];\n    graph[u] = new_node;\n}\n\nint is_valid_path(int u, int v) {\n    int* queue = malloc(MAX_N * sizeof(int));\n    int* parent = malloc(MAX_N * sizeof(int));\n    int front = 0, rear = 0;\n    \n    memset(parent, -1, sizeof(int) * MAX_N);\n    memset(visited, 0, sizeof(int) * MAX_N);\n    \n    queue[rear++] = u;\n    visited[u] = 1;\n    \n    while (front < rear) {\n        int curr = queue[front++];\n        \n        if (curr == v) {\n            free(queue);\n            free(parent);\n            return 1;\n        }\n        \n        for (Node* neighbor = graph[curr]; neighbor; neighbor = neighbor->next) {\n            int next = neighbor->vertex;\n            if (!visited[next]) {\n                queue[rear++] = next;\n                parent[next] = curr;\n                visited[next] = 1;\n            }\n        }\n    }\n    \n    free(queue);\n    free(parent);\n    return 0;\n}\n\nvoid dfs(int current) {\n    path[path_len++] = current;\n    \n    if (path_len > max_path_len) {\n        max_path_len = path_len;\n    }\n    \n    for (int i = 0; i < path_len - 1; i++) {\n        for (int j = i + 2; j < path_len; j++) {\n            if (is_valid_path(path[i], path[j])) {\n                path[path_len] = path[j];\n                dfs(path[j]);\n                path_len--;\n            }\n        }\n    }\n    \n    path_len--;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    \n    for (int i = 1; i < N; i++) {\n        int p, q;\n        scanf(\"%d %d\", &p, &q);\n        add_edge(p, q);\n        add_edge(q, p);\n    }\n    \n    max_path_len = 0;\n    \n    for (int start = 1; start <= N; start++) {\n        path_len = 0;\n        dfs(start);\n    }\n    \n    printf(\"%d\\n\", max_path_len);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:29:41"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 200000\n\ntypedef struct Node {\n    int vertex;\n    struct Node *next;\n} Node;\n\nNode *graph[MAX_N + 1];\nint diameter;\n\nvoid add_edge(int u, int v) {\n    Node *node = (Node *)malloc(sizeof(Node));\n    node->vertex = v;\n    node->next = graph[u];\n    graph[u] = node;\n}\n\nint dfs(int u, int parent) {\n    int max_depth1 = 0, max_depth2 = 0;\n    for (Node *node = graph[u]; node != NULL; node = node->next) {\n        int v = node->vertex;\n        if (v == parent) continue;\n        int depth = dfs(v, u) + 1;\n        if (depth > max_depth1) {\n            max_depth2 = max_depth1;\n            max_depth1 = depth;\n        } else if (depth > max_depth2) {\n            max_depth2 = depth;\n        }\n    }\n    if (max_depth1 + max_depth2 > diameter) {\n        diameter = max_depth1 + max_depth2;\n    }\n    return max_depth1;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N - 1; i++) {\n        int p, q;\n        scanf(\"%d %d\", &p, &q);\n        add_edge(p, q);\n        add_edge(q, p);\n    }\n    diameter = 0;\n    dfs(1, -1);\n    printf(\"%d\\n\", diameter + 1);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:29:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> dp1, dp2;\n\nvoid dfs(int u, int parent) {\n    vector<int> children;\n    for (int v : adj[u]) {\n        if (v != parent) {\n            dfs(v, u);\n            children.push_back(max(dp1[v], dp2[v]));\n        }\n    }\n    sort(children.rbegin(), children.rend());\n    if (children.size() >= 1) {\n        dp1[u] = 1 + children[0];\n    }\n    if (children.size() >= 2) {\n        dp2[u] = 2 + children[0] + children[1];\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n    adj.resize(N + 1);\n    dp1.assign(N + 1, 0);\n    dp2.assign(N + 1, 0);\n    for (int i = 0; i < N - 1; ++i) {\n        int p, q;\n        cin >> p >> q;\n        adj[p].push_back(q);\n        adj[q].push_back(p);\n    }\n    dfs(1, -1);\n    int max_M = 0;\n    for (int i = 1; i <= N; ++i) {\n        max_M = max(max_M, dp1[i]);\n        max_M = max(max_M, dp2[i]);\n    }\n    cout << max_M << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 23:30:11"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    static List<List<Integer>> tree;\n    static int maxM = 0;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt();\n        tree = new ArrayList<>();\n        for (int i = 0; i <= N; i++) {\n            tree.add(new ArrayList<>());\n        }\n        for (int i = 0; i < N - 1; i++) {\n            int p = sc.nextInt();\n            int q = sc.nextInt();\n            tree.get(p).add(q);\n            tree.get(q).add(p);\n        }\n\n        dfs(1, 0);\n        System.out.println(maxM);\n    }\n\n    static int dfs(int node, int parent) {\n        int firstMax = 0, secondMax = 0;\n        for (int neighbor : tree.get(node)) {\n            if (neighbor == parent) continue;\n            int depth = dfs(neighbor, node);\n            if (depth > firstMax) {\n                secondMax = firstMax;\n                firstMax = depth;\n            } else if (depth > secondMax) {\n                secondMax = depth;\n            }\n        }\n        maxM = Math.max(maxM, firstMax + secondMax + 1);\n        return firstMax + 1;\n    }\n}",
    "timestamp": "2025-08-05 23:30:25"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\npublic class Solution {\n    static List<List<Integer>> graph;\n    static boolean[] visited;\n    static int maxLength;\n\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        StringTokenizer st = new StringTokenizer(br.readLine());\n        \n        int N = Integer.parseInt(st.nextToken());\n        graph = new ArrayList<>(N + 1);\n        \n        for (int i = 0; i <= N; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < N - 1; i++) {\n            st = new StringTokenizer(br.readLine());\n            int p = Integer.parseInt(st.nextToken());\n            int q = Integer.parseInt(st.nextToken());\n            graph.get(p).add(q);\n            graph.get(q).add(p);\n        }\n        \n        int result = 0;\n        for (int i = 1; i <= N; i++) {\n            visited = new boolean[N + 1];\n            maxLength = 0;\n            dfs(i, 1);\n            result = Math.max(result, maxLength);\n        }\n        \n        System.out.println(result);\n    }\n    \n    static void dfs(int vertex, int length) {\n        visited[vertex] = true;\n        maxLength = Math.max(maxLength, length);\n        \n        for (int next : graph.get(vertex)) {\n            if (!visited[next]) {\n                dfs(next, length + 1);\n            }\n        }\n        \n        visited[vertex] = false;\n    }\n}",
    "timestamp": "2025-08-05 23:30:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nvector<int> graph[MAXN];\nint N;\n\nvector<int> longest_path() {\n    // First BFS to find farthest node from node 1\n    vector<int> dist(N+1, 0);\n    vector<int> parent(N+1, 0);\n    queue<int> q;\n    q.push(1);\n    int end_node1 = 1;\n    \n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n        for (int next : graph[curr]) {\n            if (dist[next] == 0 && next != 1) {\n                dist[next] = dist[curr] + 1;\n                parent[next] = curr;\n                q.push(next);\n                if (dist[next] > dist[end_node1]) {\n                    end_node1 = next;\n                }\n            }\n        }\n    }\n    \n    // Second BFS from the farthest node\n    fill(dist.begin(), dist.end(), 0);\n    fill(parent.begin(), parent.end(), 0);\n    q = queue<int>();\n    q.push(end_node1);\n    int end_node2 = end_node1;\n    \n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n        for (int next : graph[curr]) {\n            if (dist[next] == 0 && next != end_node1) {\n                dist[next] = dist[curr] + 1;\n                parent[next] = curr;\n                q.push(next);\n                if (dist[next] > dist[end_node2]) {\n                    end_node2 = next;\n                }\n            }\n        }\n    }\n    \n    // Reconstruct path\n    vector<int> path;\n    int curr = end_node2;\n    while (curr != 0) {\n        path.push_back(curr);\n        curr = parent[curr];\n    }\n    reverse(path.begin(), path.end());\n    \n    return path;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    cin >> N;\n    for (int i = 1; i < N; i++) {\n        int p, q;\n        cin >> p >> q;\n        graph[p].push_back(q);\n        graph[q].push_back(p);\n    }\n    \n    vector<int> longest = longest_path();\n    cout << longest.size() << '\\n';\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:30:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\n\ndef find_max_sequence(N, edges):\n    def dfs(node, parent):\n        size = 1\n        max_size = 0\n        for neigh in graph[node]:\n            if neigh == parent:\n                continue\n            result = dfs(neigh, node)\n            max_size = max(max_size, result)\n            size += result\n        dp[node] = max_size\n        return size\n\n    if N == 1:\n        return 1\n    \n    graph = defaultdict(list)\n    for p_i, q_i in edges:\n        graph[p_i].append(q_i)\n        graph[q_i].append(p_i)\n\n    dp = [0] * (N + 1)\n    dfs(1, -1)\n    \n    return max(dp) + 1\n\n# Example usage:\nN = 5\nedges = [(1, 2), (2, 3), (3, 4), (4, 5)]\nprint(find_max_sequence(N, edges))  # Output: 5",
    "timestamp": "2025-08-13 15:37:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class Main {\n    static List<Integer>[] tree;\n    static boolean[] visited;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        tree = new ArrayList[n + 1];\n        for (int i = 1; i <= n; i++) {\n            tree[i] = new ArrayList<>();\n        }\n        for (int i = 1; i <= n - 1; i++) {\n            int p = sc.nextInt();\n            int q = sc.nextInt();\n            tree[p].add(q);\n            tree[q].add(p);\n        }\n        sc.close();\n\n        visited = new boolean[n + 1];\n\n        int[] furthest = bfs(1);\n        visited = new boolean[n + 1];\n        int[] longestPath = bfs(furthest[0]);\n\n        System.out.println(longestPath[1] + 1);\n    }\n\n    static int[] bfs(int start) {\n        int[] result = new int[2];\n        boolean[] localVisited = new boolean[visited.length];\n        int[] queue = new int[visited.length];\n        int[] distances = new int[visited.length];\n\n        int front = 0, back = 0;\n        queue[back++] = start;\n        localVisited[start] = true;\n\n        while (front < back) {\n            int node = queue[front++];\n            for (int neighbor : tree[node]) {\n                if (!localVisited[neighbor] && !visited[neighbor]) {\n                    localVisited[neighbor] = true;\n                    distances[neighbor] = distances[node] + 1;\n                    queue[back++] = neighbor;\n\n                    if (distances[neighbor] > result[1]) {\n                        result[0] = neighbor;\n                        result[1] = distances[neighbor];\n                    }\n                }\n            }\n        }\n\n        visited[result[0]] = true;\n        return result;\n    }\n}",
    "timestamp": "2025-08-13 15:37:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define MAXN 100000\n\ntypedef struct {\n    int vertex;\n    int depth;\n} Node;\n\nint N;\nint adj[MAXN][MAXN];\nint adjSize[MAXN];\nint visited[MAXN];\nNode stack[MAXN];\nint top;\n\nvoid addEdge(int u, int v) {\n    adj[u][adjSize[u]++] = v;\n    adj[v][adjSize[v]++] = u;\n}\n\nvoid dfs(int v, int depth) {\n    visited[v] = 1;\n    stack[top].vertex = v;\n    stack[top++].depth = depth;\n\n    for (int i = 0; i < adjSize[v]; i++) {\n        int u = adj[v][i];\n        if (!visited[u]) {\n            dfs(u, depth + 1);\n        }\n    }\n}\n\nint main() {\n    int M = 0;\n\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N - 1; i++) {\n        int p, q;\n        scanf(\"%d %d\", &p, &q);\n        addEdge(p - 1, q - 1);\n    }\n\n    dfs(0, 0);\n\n    int pathEnd1 = stack[0].vertex;\n    int maxDepth = stack[0].depth;\n\n    for (int i = 1; i < top; i++) {\n        if (stack[i].depth > maxDepth) {\n            maxDepth = stack[i].depth;\n            pathEnd1 = stack[i].vertex;\n        }\n    }\n\n    top = 0;\n    for (int i = 0; i < N; i++) visited[i] = 0;\n    dfs(pathEnd1, 0);\n\n    int pathEnd2 = stack[0].vertex;\n    maxDepth = stack[0].depth;\n\n    for (int i = 1; i < top; i++) {\n        if (stack[i].depth > maxDepth) {\n            maxDepth = stack[i].depth;\n            pathEnd2 = stack[i].vertex;\n        }\n    }\n\n    M = maxDepth + 1;\n    printf(\"%d\\n\", M);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:37:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> graph[100001];\nint N;\nint diameter;\nint endpoint;\n\n// Helper function to perform DFS and find the furthest vertex from a given start vertex\nvoid dfs(int node, int parent, int depth) {\n    if (depth > diameter) {\n        diameter = depth;\n        endpoint = node;\n    }\n    for (int neighbor : graph[node]) {\n        if (neighbor != parent) {\n            dfs(neighbor, node, depth + 1);\n        }\n    }\n}\n\n// Function to find the diameter of the tree\nint find_tree_diameter() {\n    diameter = 0;\n    endpoint = 0;\n    \n    // Run DFS from an arbitrary node (1 in this case) to find one endpoint of the longest path\n    dfs(1, -1, 0);\n    \n    int start = endpoint;\n    diameter = 0;\n    \n    // Run DFS from the found endpoint to find the actual diameter\n    dfs(start, -1, 0);\n    \n    return diameter;\n}\n\nint main() {\n    cin >> N;\n    \n    for (int i = 0; i < N - 1; i++) {\n        int p, q;\n        cin >> p >> q;\n        graph[p].push_back(q);\n        graph[q].push_back(p);\n    }\n    \n    int maxM = find_tree_diameter() + 1;\n    cout << maxM << endl;\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 15:37:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef solve(N, edges):\n    # Create adjacency list representation of the tree\n    graph = defaultdict(list)\n    for p, q in edges:\n        graph[p].append(q)\n        graph[q].append(p)\n\n    def find_longest_path():\n        # First BFS to find the farthest node from an arbitrary node\n        def bfs(start):\n            dist = [float('-inf')] * (N + 1)\n            dist[start] = 0\n            queue = deque([start])\n            max_dist = 0\n            farthest_node = start\n\n            while queue:\n                curr = queue.popleft()\n                for neighbor in graph[curr]:\n                    if dist[neighbor] == float('-inf'):\n                        dist[neighbor] = dist[curr] + 1\n                        queue.append(neighbor)\n                        if dist[neighbor] > max_dist:\n                            max_dist = dist[neighbor]\n                            farthest_node = neighbor\n\n            return farthest_node, max_dist\n\n        # Find the first farthest node\n        end1, _ = bfs(1)\n        \n        # Find the second farthest node from the first\n        end2, diameter = bfs(end1)\n\n        # Reconstruct the path\n        path = []\n        visited = [False] * (N + 1)\n        \n        def dfs_path(node, target):\n            visited[node] = True\n            path.append(node)\n            \n            if node == target:\n                return True\n            \n            for neighbor in graph[node]:\n                if not visited[neighbor]:\n                    if dfs_path(neighbor, target):\n                        return True\n            \n            path.pop()\n            return False\n\n        # Reset visited array\n        visited = [False] * (N + 1)\n        dfs_path(end1, end2)\n        \n        return len(path)\n\n    return solve_longest_path()\n\n# Example usage\nN = 5\nedges = [(1, 2), (2, 3), (3, 4), (4, 5)]\nresult = solve(N, edges)\nprint(result)",
    "timestamp": "2025-08-13 15:37:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    sys.setrecursionlimit(1 << 25)\n    N = int(sys.stdin.readline())\n    adj = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        p, q = map(int, sys.stdin.readline().split())\n        adj[p].append(q)\n        adj[q].append(p)\n    \n    def bfs(start):\n        visited = [-1] * (N+1)\n        q = deque()\n        q.append(start)\n        visited[start] = 0\n        farthest_node = start\n        max_dist = 0\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if visited[v] == -1:\n                    visited[v] = visited[u] + 1\n                    q.append(v)\n                    if visited[v] > max_dist:\n                        max_dist = visited[v]\n                        farthest_node = v\n        return farthest_node, max_dist\n    \n    u, _ = bfs(1)\n    v, diameter = bfs(u)\n    print(diameter + 1)\n\nsolve()",
    "timestamp": "2025-08-13 15:37:43"
  }
]