[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[101010];\nint D[101010];\nint ma;\n\nvoid dfs(int cur,int pre) {\n\tvector<int> V;\n\tD[cur]=1;\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur);\n\t\tV.push_back(D[e]);\n\t}\n\tsort(ALL(V));\n\treverse(ALL(V));\n\tif(V.size()>3) ma=max(ma,V[0]+V[1]+(int)V.size()-2);\n\tif(V.size()>=2 && V.size()<=3) ma=max(ma,V[0]+V[1]+1);\n\tif(V.size()>=1) ma=max(ma,V[0]+1+(int)V.size()-1);\n\t\n\tif(V.size()>=2) D[cur]=V[0]+V.size()-1;\n\tif(V.size()==1) D[cur]=V[0]+1;\n\tma=max(ma,D[cur]);\n\t\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\tma=1;\n\tdfs(0,-1);\n\tcout<<ma<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nint n, r, l;\nvector<int> g[100010];\nint lc[100010];\nint d[100010];\nvoid dfs(int x, int p){\n\tif(g[x].size()==1) lc[x]=1;\n\td[x]=1;\n\tfor(auto y:g[x]){\n\t\tif(y==p) continue;\n\t\tdfs(y, x);\n\t\tlc[x]+=lc[y];\n\t}\n\tfor(auto y:g[x]){\n\t\tif(y==p) continue;\n\t\td[x]=max(d[x], max(1, lc[x]-lc[y])+d[y]);\n\t}\n}\nint ans;\nvoid dfs2(int x, int p){\n\tvector<int> v;\n\tfor(auto y:g[x]){\n\t\tif(y==p) continue;\n\t\tv.push_back(d[y]-lc[y]);\n\t}\n\tsort(v.begin(), v.end(), greater<int>());\n\tif(v.size()>=2) ans=max(ans, v[0]+v[1]+l);\n\tfor(auto y:g[x]){\n\t\tif(y==p) continue;\n\t\tdfs2(y, x);\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=0; i<n-1; i++){\n\t\tint a, b;\n\t\tcin>>a>>b;\n\t\ta--; b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tif(n==2){\n\t\tcout<<2<<endl;\n\t\treturn 0;\n\t}\n\tr=-1;\n\tfor(int i=0; i<n; i++){\n\t\tif(g[i].size()==1) l++;\n\t\telse if(g[i].size()>2) r=i;\n\t}\n\tif(r==-1){\n\t\tcout<<n<<endl;\n\t\treturn 0;\n\t}\n\tdfs(r, -1);\n\tdfs2(r, -1);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }\n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n;\n  cin>>n;\n\n  vector< vector<int> > G(n);\n  for(int i=1;i<n;i++){\n    int p,q;\n    cin>>p>>q;\n    p--;q--;\n    G[p].emplace_back(q);\n    G[q].emplace_back(p);\n  }\n\n  vector<int> dp1(n,0),dp2(n,0);\n  int ans=0;\n  MFP([&](auto dfs,int v,int p)->void{\n        int sum=0;\n        vector<int> vs,mx;\n        for(int u:G[v]){\n          if(u==p) continue;\n          dfs(u,v);\n          sum+=dp2[u];\n          mx.emplace_back(dp1[u]);\n          vs.emplace_back(dp1[u]-dp2[u]);\n        }\n        dp1[v]=1;\n        dp2[v]=1;\n\n        if(vs.empty()) return;\n\n        while(vs.size()<2) vs.emplace_back(0);\n        while(mx.size()<2) mx.emplace_back(0);\n        sort(vs.rbegin(),vs.rend());\n        sort(mx.rbegin(),mx.rend());\n\n        // c1 -> v -> c2, take v\n        chmax(ans,mx[0]+1+mx[1]);\n\n        // c1 -> v -> c2, not take v\n        chmax(ans,sum+vs[0]+vs[1]);\n\n        // c1 -> v, take v\n        chmax(dp1[v],mx[0]+1);\n\n        // c1 -> v, not take v\n        chmax(dp1[v],sum+vs[0]);\n\n        // not take v\n        chmax(dp2[v],sum);\n\n        assert(dp1[v]>=dp2[v]);\n        // cout<<v<<\", dp1[v] = \"<<dp1[v]<<\", dp2[v] = \"<<dp2[v]<<endl;\n      })(0,-1);\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvector<int> G[100010];\nint N,A,B;\n\nint dfs(int x, int l)\n{\n\tvector<int> u;\n\tfor (int y : G[x]) if (y != l){\n\t\tu.push_back(dfs(y,x));\n\t}\n\n\tint mx = 0;\n\tfor (int i=0;i<u.size();i++) mx = max(mx,u[i]);\n\tif (G[x].size() == 2){\n\t\tif (u.size() == 2){\n\t\t\tB = max(B, u[0] + u[1] + 1);\n\t\t}\n\t\tmx++;\n\t}\n\treturn mx;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tfor (int i=1;i<N;i++){\n\t\tint x,y; scanf (\"%d %d\",&x,&y);\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tfor (int i=1;i<=N;i++) if (G[i].size() == 1) A++;\n\n\tdfs(1,0);\n\tprintf (\"%d\\n\",A+B);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }\n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n;\n  cin>>n;\n\n  vector< vector<int> > G(n);\n  for(int i=1;i<n;i++){\n    int p,q;\n    cin>>p>>q;\n    p--;q--;\n    G[p].emplace_back(q);\n    G[q].emplace_back(p);\n  }\n\n  vector<int> dp1(n,0),dp2(n,0),dp3(n,0);\n  int ans=0;\n  MFP([&](auto dfs,int v,int p)->void{\n        int sum=0;\n        vector<int> vs,mx;\n        for(int u:G[v]){\n          if(u==p) continue;\n          dfs(u,v);\n          sum+=dp2[u];\n          mx.emplace_back(dp1[u]);\n          vs.emplace_back(dp1[u]-dp2[u]);\n        }\n        if(vs.empty()){\n          dp1[v]=1;\n          dp2[v]=1;\n          dp3[v]=1;\n          return;\n        }\n        while(vs.size()<2) vs.emplace_back(0);\n        while(mx.size()<2) mx.emplace_back(0);\n        sort(vs.rbegin(),vs.rend());\n        sort(mx.rbegin(),mx.rend());\n\n        // c1 -> v -> c2, not take v\n        chmax(dp3[v],sum+vs[0]+vs[1]);\n        chmax(dp3[v],mx[0]+mx[1]);\n\n        for(int u:G[v]){\n          if(u==p) continue;\n          chmax(dp3[v],sum-dp2[u]+dp3[u]);\n          chmax(ans,dp3[u]+1);\n        }\n\n        // c1 -> v, take v\n        chmax(dp1[v],mx[0]+1);\n\n        // c1 -> v, not take v\n        chmax(dp1[v],sum+vs[0]);\n\n        // not take v\n        chmax(dp2[v],sum);\n\n        // c1 -> v -> c2, take v\n        chmax(ans,mx[0]+1+mx[1]);\n        chmax(ans,dp1[v]);\n        chmax(ans,dp2[v]);\n        chmax(ans,dp3[v]);\n\n        continue;\n        cout<<v;\n        cout<<\", dp1[v] = \"<<dp1[v];\n        cout<<\", dp2[v] = \"<<dp2[v];\n        cout<<\", dp3[v] = \"<<dp3[v]<<endl;\n      })(0,-1);\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<57;\nconst double pi=acos(-1);\nconst double eps=1e-6;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,-0};\nconst int DX[8]={-1,-1,-1,0,1,1,1,0},DY[8]={1,0,-1,-1,-1,0,1,1};\n\nclass Graph{\n\tprivate:\n\tint V;\n\tvvp List;\n\tint Diametarfunc(int s,int& d){\n\t\tint ansv;\n\t\tvb used(V);\n\t\tused[s]=1;\n\t\tqueue<P> que;\n\t\tque.push(P(s,0));\n\t\twhile(!que.empty()){\n\t\t\tP v=que.front();\n\t\t\tque.pop();\n\t\t\tif(v.second>d){\n\t\t\t\tansv=v.first;\n\t\t\t\td=v.second;\n\t\t\t}\n\t\t\tfor(int i=0;i<List[v.first].size();i++){\n\t\t\t\tP u=List[v.first][i];\n\t\t\t\tif(!used[u.first]){\n\t\t\t\t\tused[u.first]=1;\n\t\t\t\t\tque.push(P(u.first,v.second+u.second));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ansv;\n\t}\n\tint Diametar(){\n\t\tint d=-1,ansl,ansr;\n\t\tansl=Diametarfunc(0,d);\n\t\td=-1;\n\t\tansr=Diametarfunc(ansl,d);\n\t\treturn d;\n\t}\n\tvoid change_edge(int s){\n\t\tList[s][0].second++;\n\t\tint t=List[s][0].first;\n\t\tfor(int i=0;i<List[t].size();i++) if(List[t][i].first==s) List[t][i].second++;\n\t}\n\tpublic:\n\tGraph(int v){\n\t\tV=v;\n\t\tList=vvp(v);\n\t}\n\tvoid add_edge(int s,int t,int c){\n\t\tList[s].push_back({t,c});\n\t\tList[t].push_back({s,c});\n\t}\n\tint solve(){\n\t\tint num=0;\n\t\tfor(int i=0;i<V;i++){\n\t\t\tint S=List[i].size();\n\t\t\tif(S==1) num++;\n\t\t\tif(S==2) change_edge(i);\n\t\t}\n\t\treturn num+Diametar();\n\t}\n};\n\nint n;\n\nint main(){\n\tcin>>n;\n\tGraph g(n);\n\tfor(int i=1;i<n;i++){\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\tg.add_edge(s-1,t-1,0);\n\t}\n\tcout<<g.solve()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\nvoid func(vector<vector<int>>&edge, vector<int>&dp, int &ans, int node = 0, int p = -1) {\n\tvector<int>box;\n\tfor (auto i : edge[node]) {\n\t\tif (i == p)continue;\n\t\tfunc(edge, dp, ans, i, node);\n\t\tbox.push_back(dp[i]);\n\t}\n\tsort(box.rbegin(), box.rend());\n\tif (box.empty()) {\n\t\tdp[node] = 1;\n\t\tans = max(ans, 1);\n\t}\n\telse if (box.size() == 1) {\n\t\tdp[node] = box[0] + 1;\n\t\tans = max(ans, dp[node]);\n\t}\n\telse if (box.size() >= 2) {\n\t\tdp[node] = box[0] + box.size() - 1;\n\t\tans = max(ans, box[0] + box[1] + 1);\n\t\tans = max(ans, box[0] + box[1] + (int)box.size() - 2);\n\t\tans = max(ans, dp[node]);\n\t\tif (box.size() == 2)ans = max(ans, dp[node] + 1);\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>edge(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> L >> R;\n\t\tL--, R--;\n\t\tedge[L].push_back(R);\n\t\tedge[R].push_back(L);\n\t}\n\tint ans = 0;\n\tvector<int>dp(N);\n\tfunc(edge, dp, ans);\n\t//for (int i = 0; i < N; i++) {\n\t//\tcout << i << \" \" << dp[i] << endl;\n\t//}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing vvvint = vector<vvint>;\nusing vll = vector<ll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\n\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2> inline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n\tfor (auto &u : v) os << u << el;\n\treturn (os);\n}\n\ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n\tfor (auto &u : v) is >> u;\n\treturn (is);\n}\n\ntemplate<typename T1, typename T2>\nistream& operator >>(istream &is, pair<T1, T2> &p) {\n\treturn (is >> p.first >> p.second);\n}\n\nint main() {\n\tint N; cin >> N;\n\tvvint G(N);\t\n\tfor (int i = 0; i < N-1; i++) {\n\t\tint p, q;\n\t\tcin >> p >> q; --p, --q;\n\t\tG[p].push_back(q);\n\t\tG[q].push_back(p);\n\t}\n\t\n\tint maxd = 0;\n\tfunction<int(int, int)> dfs = [&](int u, int prev) {\n\t\tint ret = (int)(G[u].size() == 2);\n\t\tvint dat;\n\t\tfor (auto &v : G[u]) {\n\t\t\tif (v != prev) dat.push_back(dfs(v, u));\n\t\t}\n\n\t\tsort(begin(dat), end(dat), greater<>());\n\t\tint maxv = 0;\n\t\tif (dat.size() >= 1) {\n\t\t\tmaxv = dat[0];\n\t\t\tif (dat.size() >= 2) chmax(maxd, dat[0] + dat[1]);\n\t\t}\n\t\tchmax(maxd, ret + maxv);\n\t\treturn (ret + maxv);\n\t};\n\n\tint cnt = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (G[i].size() == 1) cnt++;\n\t}\n\tdfs(i, -1);\n\tcout << cnt + maxd << endl;\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nconst int N = 100000;\nvector<int> g[N];\nint sz[N], dp[N];\n\nvoid dfs(int u, int prev) {\n        vector<int> len;\n        for (auto v : g[u]) if (prev != v) {\n                dfs(v, u);\n                len.push_back(sz[v]);\n                dp[u] = max(dp[u], dp[v]);\n                sz[u] = max(sz[u], sz[v] + (g[u].size() == 2));\n        }\n        sort(len.rbegin(), len.rend());\n        if (len.size() >= 2) dp[u] = max(dp[u], len[0] + len[1] + (g[u].size() == 2));\n}           \n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        int leaf = 0;\n        for (int i = 0; i < n; i ++) if (g[i].size() == 1) leaf ++;\n        dfs(0, -1);\n        printf(\"%d\\n\", dp[0] + leaf);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint main() {\n    int N; cin >> N;\n    vector<vector<int>> G(N);\n    for (int i = 0; i < N - 1; i++) {\n        int p, q; cin >> p >> q; p--, q--;\n        G[p].push_back(q);\n        G[q].push_back(p);\n    }\n    vector<int> leaf(N);\n    auto recur0 = [&](auto&& recur0, int node, int prev) -> void {\n        if (G[node].size() == 1) {\n            leaf[node] = 1;\n        }\n        for (int next : G[node]) if (next != prev) {\n            recur0(recur0, next, node);\n            leaf[node] += leaf[next];\n        }\n    };\n    recur0(recur0, 0, 0);\n    int ans = 0;\n    auto recur1 = [&](auto&& recur1, int node, int prev) -> int {\n        int diffmax = 0;\n        int diffmax2 = 0;\n        for (int next : G[node]) if (next != prev) {\n            int res = recur1(recur1, next, node);\n            int diff = res - leaf[next];\n            if (diffmax < diff) {\n                diffmax2 = diffmax;\n                diffmax = diff;\n            } else if (diffmax2 < diff) {\n                diffmax2 = diff;\n            }\n        }\n        ans = max(ans, diffmax + diffmax2 + leaf[0]);\n        int ret;\n        if (G[node].size() == 1 && node != prev) {\n            ret = 1;\n        } else if (G[node].size() == 2) {\n            ret = leaf[node] + diffmax + 1;\n        } else {\n            ret = leaf[node] + diffmax;\n        }\n        ans = max(ans, ret);\n        return ret;\n    };\n    recur1(recur1, 0, 0);\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse4.2\")\n\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef pair<Weight, int> Result;\nResult visit(int p, int v, const Graph &g) {\n  int f = g[v].size()==2;\n  Result r(0, v);\n  for(auto &e: g[v]) if (e.dst != p) {\n    Result t = visit(v, e.dst, g);\n    t.first += f; //e->weight;\n    if (r.first < t.first) r = t;\n  }\n  return r;\n}\nWeight diameter(const Graph &g) {\n  Result r = visit(-1, 0, g);\n  Result t = visit(-1, r.second, g);\n  return t.first; // (r.second, t.second) is farthest pair\n}\n\nint main(){\n\tint V,s,t;\n\tscanf(\"%d\",&V);\n\tGraph g(V);\n\tfor(;V>1;V--)scanf(\"%d%d\",&s,&t),s--,t--,g[s].push_back(Edge(s,t,1)),g[t].push_back(Edge(t,s,1));\n\tprintf(\"%d\\n\",diameter(g)+count_if(g.begin(),g.end(),[](auto &e){return e.size()==1;}));\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\nvoid func(vector<vector<int>>&edge, vector<int>&dp, int &ans, int node = 0, int p = -1) {\n\tvector<int>box;\n\tfor (auto i : edge[node]) {\n\t\tif (i == p)continue;\n\t\tfunc(edge, dp, ans, i, node);\n\t\tbox.push_back(dp[i]);\n\t}\n\tsort(box.rbegin(), box.rend());\n\tif (node == 0) {\n\t\tif (box.size() >= 2) {\n\t\t\tdp[node] = box[0] + box[1] + 1;\n\t\t\tans = max(dp[node], ans);\n\t\t}\n\t}\n\telse if (box.empty()) {\n\t\tdp[node] = 0;\n\t}\n\telse if (box.size() == 1) {\n\t\tdp[node] = box[0] + 1;\n\t\tans = max(ans, dp[node]);\n\t}\n\telse if (box.size() >= 2) {\n\t\tdp[node] = box[0];\n\t\tans = max(box[0] + box[1], ans);\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>edge(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> L >> R;\n\t\tL--, R--;\n\t\tedge[L].push_back(R);\n\t\tedge[R].push_back(L);\n\t}\n\tint ans = 0;\n\tvector<int>dp(N);\n\tfunc(edge, dp, ans);\n\tfor (int i = 0; i < N; i++) {\n\t\tans += edge[i].size() == 1;\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5;\n\nvector<int> g[N];\nint leaves[N];\nint dp[N];\nint ans;\n\nvoid dfs(int u, int p) {\n    bool is_leaf = true;\n    for (int v : g[u]) {\n        if (v == p) {\n            continue;\n        }\n        dfs(v, u);\n        is_leaf = false;\n        leaves[u] += leaves[v];\n    }\n    if (is_leaf) {\n        leaves[u]++;\n        dp[u] = 1;\n    }\n}\n\nvoid dfs2(int u, int p) {\n    for (int v : g[u]) {\n        if (v == p) {\n            continue;\n        }\n        dfs2(v, u);\n        // take\n        dp[u] = max(dp[u], dp[v] + leaves[u] - leaves[v]);\n\n        // not take\n        dp[u] = max(dp[u], dp[v] + 1);\n    }\n    ans = dp[u];\n    for (int x : g[u]) {\n        for (int y : g[u]) {\n            if (x == y) {\n                continue;\n            }\n            ans = max(ans, dp[x] + dp[y] + 1);\n            ans = max(ans, dp[x] + dp[y] + leaves[u] - leaves[x] - leaves[y] + (leaves[0] - leaves[u]));\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    if (n > 3000) abort();\n    dfs(0, -1);\n    dfs2(0, -1);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> v[100000];\nbool used[100000];\nint endpoint = 0;\nint maxx = 0;\n\nint dfs(int cur) {\n    used[cur] = true;\n    if (v[cur].size() == 1) endpoint++;\n    vector<int> w = {0, 0};\n    for (int i = 0; i < v[cur].size(); i++) {\n        if (!used[v[cur][i]]) {\n            int to = v[cur][i];\n            w.push_back(dfs(to));\n        }\n    }\n    sort(w.rbegin(), w.rend());\n    maxx = max(maxx, (v[cur].size() == 2) + w[0] + w[1]);\n    return (v[cur].size() == 2) + w[0];\n}\n\nint main() {\n    int n; cin >> n;\n    for (int i = 0; i < n-1; i++) {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    memset(used, 0, sizeof(used));\n    dfs(0);\n    cout << maxx + endpoint << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint main() {\n    int N; cin >> N;\n    vector<vector<int>> G(N);\n    for (int i = 0; i < N - 1; i++) {\n        int p, q; cin >> p >> q; p--, q--;\n        G[p].push_back(q);\n        G[q].push_back(p);\n    }\n    vector<int> leaf(N);\n    auto recur0 = [&](auto&& recur0, int node, int prev) -> void {\n        if (G[node].size() == 1 && node != prev) {\n            leaf[node] = 1;\n        }\n        for (int next : G[node]) if (next != prev) {\n            recur0(recur0, next, node);\n            leaf[node] += leaf[next];\n        }\n    };\n    recur0(recur0, 0, 0);\n    int ans = 0;\n    auto recur1 = [&](auto&& recur1, int node, int prev) -> int {\n        int diffmax = 0;\n        int diffmax2 = 0;\n        for (int next : G[node]) if (next != prev) {\n            int res = recur1(recur1, next, node);\n            int diff = res - leaf[next];\n            if (diffmax < diff) {\n                diffmax2 = diffmax;\n                diffmax = diff;\n            } else if (diffmax2 < diff) {\n                diffmax2 = diff;\n            }\n        }\n        ans = max(ans, diffmax + diffmax2 + 1 + leaf[0]);\n        int ret;\n        if (G[node].size() == 1 && node != prev) {\n            ret = 1;\n        } else if (G[node].size() == 2) {\n            ret = leaf[node] + diffmax + 1;\n        } else {\n            ret = leaf[node] + diffmax;\n        }\n        ans = max(ans, ret);\n        return ret;\n    };\n    recur1(recur1, 0, 0);\n    cout << ans << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ※※※ 解答不能 ※※※\n// tourist氏.\n// https://atcoder.jp/contests/cf16-relay-open/submissions/8980099\n#include <bits/stdc++.h>\nusing namespace std;\nusing vi = vector<int>;\nusing P = pair<int, int>;\n#define repx(i, a, b) for(int i = a; i < b; i++)\n#define rep(i, n) repx(i, 0, n)\n#define repr(i, a, b) for(int i = a; i >= b; i--)\n#define a first\n#define b second\n#define pb push_back\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    vector<vi> g(n);\n    rep(i, n - 1){\n        int x, y;\n        scanf(\"%d %d\", &x, &y);\n        --x; --y;\n        g[x].pb(y);\n        g[y].pb(x);\n    }\n    int ans = 0;\n    vector<P> down(n);\n    function<P(int, int)> Dfs = [&](int v, int pr){\n        int one = 1;\n        int two = 0;\n        int profit = 0;\n        for(int u : g[v]){\n            if(u == pr) continue;\n            auto res = Dfs(u, v);\n            one = max(one, 1 + res.a);\n            two += res.b;\n            profit = max(profit, res.a - res.b);\n        }\n        one = max(one, two + profit);\n        two = max(two, 1);\n        ans = max(ans, one);\n        return down[v] = {one, two};\n    };\n    Dfs(0, -1);\n    function<void(int, int, P)> Solve = [&](int v, int pr, P up){\n        vector<P> children;\n        for(int u : g[v]){\n            if(u == pr) continue;\n            children.pb(down[u]);\n        }\n        int sz = (int) children.size();\n        vi pref_one(sz + 1);\n        vi pref_two(sz + 1);\n        vi pref_profit(sz + 1);\n        vi suf_one(sz + 1);\n        vi suf_two(sz + 1);\n        vi suf_profit(sz + 1);\n        pref_one[0] = 1;\n        rep(i, sz){\n            pref_one[i + 1] = max(pref_one[i], 1 + children[i].a);\n            pref_two[i + 1] = pref_two[i] + children[i].b;\n            pref_profit[i + 1] = max(pref_profit[i], children[i].a - children[i].b);\n        }\n        suf_one[sz] = 1;\n        repr(i, sz - 1, 0){\n            suf_one[i] = max(suf_one[i + 1], 1 + children[i].a);\n            suf_two[i] = suf_two[i + 1] + children[i].b;\n            suf_profit[i] = max(suf_profit[i + 1], children[i].a - children[i].b);\n        }\n        ans = max(ans, max(max(pref_one.back(), 1 + up.a), pref_two.back() + up.b + max(pref_profit.back(), up.a - up.b)));\n        int ptr = 0;\n        for(int u : g[v]){\n            if(u == pr) continue;\n            int one = 1 + up.a;\n            int two = up.b;\n            int profit = up.a - up.b;\n            one = max(one, max(pref_one[ptr], suf_one[ptr + 1]));\n            two += pref_two[ptr] + suf_two[ptr + 1];\n            profit = max(profit, max(pref_profit[ptr], suf_profit[ptr + 1]));\n            one = max(one, two + profit);\n            two = max(two, 1);\n            Solve(u, v, {one, two});\n            ptr += 1;\n        }\n    };\n    Solve(0, -1, {0, 0});\n    printf(\"%d\\n\", ans);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nvector<vector<int> > edges;\n\npair<int, int> solve(int curr, int prev, int& ans)\n{\n    int leaf = 0;\n    vector<int> v;\n    for(int next : edges[curr]){\n        if(next == prev)\n            continue;\n\n        auto p = solve(next, curr, ans);\n        leaf += p.first;\n        v.push_back(p.second);\n    }\n\n    if(v.size() == 0){\n        ans = max(ans, 1);\n        return make_pair(1, 0);\n    }\n    else if(v.size() == 1){\n        ans = max(ans, leaf + v[0] + 1);\n        return make_pair(leaf, v[0] + 1);\n    }\n    else{\n        sort(v.rbegin(), v.rend());\n        ans = max(ans, leaf + v[0] + v[1] + 1);\n        return make_pair(leaf, v[0]);\n    }\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    edges.assign(n, vector<int>());\n    for(int i=0; i<n-1; ++i){\n        int p, q;\n        cin >> p >> q;\n        -- p;\n        -- q;\n        edges[p].push_back(q);\n        edges[q].push_back(p);\n    }\n\n    int ans = 0;\n    solve(0, -1, ans);\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5;\n\ntemplate<class T1, class T2>\nvoid chmax(T1 &a, T2 b) {\n    if (a < b) a = b;\n}\n\npair<int, int> max2(pair<int, int> a, int b) {\n    if (a.first < b) swap(a.first, b);\n    if (a.second < b) swap(a.second, b);\n    return a;\n}\n\nstruct DP {\n    int path = 0;\n    int leaves[3] = {};\n\n    int get_max() {\n        return max({ path + 1, leaves[0], leaves[1], leaves[2] });\n    }\n};\n\nvoid show(DP d) {\n    printf(\"%d %d %d %d\\n\", d.path, d.leaves[0], d.leaves[1], d.leaves[2]);\n}\n\nDP add(DP a, bool l) {\n    a.path++;\n    if (l) a.leaves[0]++;\n    return a;\n}\n\nDP operator+(const DP &a, const DP &b) {\n    DP res;\n    res.path = max(a.path, b.path);\n    res.leaves[2] = max({\n        a.leaves[2] + b.leaves[0],\n        a.leaves[1] + b.leaves[1],\n        a.leaves[0] + b.leaves[2],\n        a.leaves[1] + b.path,\n        a.path + b.leaves[1],\n    });\n    res.leaves[1] = max({\n        a.leaves[0] + b.leaves[1],\n        a.leaves[1] + b.leaves[0],\n        a.leaves[0] + b.path,\n        a.path + b.leaves[0],\n    });\n    res.leaves[0] = a.leaves[0] + b.leaves[0];\n    return res;\n}\n\nvector<int> g[N], gg[N];\nDP dp[N];\nbool is_leaf[N];\nint ans = 0;\n\nDP get_dp(int u) {\n    return add(dp[u], is_leaf[u]);\n}\n\nvoid dfs(int u, int p) {\n    for (int v : g[u]) if (v != p) {\n        gg[u].push_back(v);\n    }\n    if (gg[u].empty() || (p == -1 && gg[u].size() == 1)) {\n        is_leaf[u] = true;\n    }\n    for (int v : gg[u]) {\n        dfs(v, u);\n        dp[u] = dp[u] + get_dp(v);\n    }\n}\n\nvoid dfs2(int u, int p, DP par) {\n    vector<DP> sumR(gg[u].size() + 1);\n    for (int i = (int)gg[u].size() - 1; i >= 0; i--) {\n        int v = gg[u][i];\n        sumR[i] = sumR[i + 1] + get_dp(v);\n    }\n    DP foo = sumR[0];\n    if (p != -1) foo = foo + add(par, is_leaf[p]);\n    // cout << u << \":\";\n    // show(foo);\n    ans = max(ans, foo.get_max());\n    pair<int, int> dia(par.path, 0);\n    if (par.path < 0) swap(dia.first, dia.second);\n    for (int i = 0; i < gg[u].size(); i++) {\n        int v = gg[u][i];\n        dia = max2(dia, dp[v].path);\n    }\n    ans = max(ans, dia.first + dia.second + 1);\n    DP sumL;\n    for (int i = 0; i < gg[u].size(); i++) {\n        int v = gg[u][i];\n        DP tmp = sumL + sumR[i + 1];\n        if (p != -1) {\n            tmp = tmp + add(par, is_leaf[p]);\n        }\n        dfs2(v, u, tmp);\n        sumL = sumL + get_dp(v);\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    dfs(0, -1);\n    dfs2(0, -1, DP());\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5;\n\nvector<int> g[N];\nint leaves[N];\nint dp[N];\nint ans;\nint root;\n\npair<int, int> max2(pair<int, int> a, int b) {\n    if (a.first < b) {\n        swap(a.first, b);\n    }\n    if (a.second < b) {\n        swap(a.second, b);\n    }\n    return a;\n}\n\nvoid dfs(int u, int p) {\n    bool is_leaf = true;\n    for (int v : g[u]) {\n        if (v == p) {\n            continue;\n        }\n        dfs(v, u);\n        is_leaf = false;\n        leaves[u] += leaves[v];\n    }\n    if (is_leaf) {\n        leaves[u]++;\n        dp[u] = 1;\n    }\n}\n\nvoid dfs2(int u, int p) {\n    pair<int, int> take;\n    pair<int, int> not_take;\n    for (int v : g[u]) {\n        if (v == p) {\n            continue;\n        }\n        dfs2(v, u);\n        dp[u] = max(dp[u], dp[v] + leaves[u] - leaves[v]);\n        dp[u] = max(dp[u], dp[v] + 1);\n        take = max2(take, dp[v]);\n        not_take = max2(not_take, dp[v] - leaves[v]);\n    }\n    ans = max(ans, dp[u]);\n    ans = max(ans, take.first + take.second + 1);\n    ans = max(ans, not_take.first + not_take.second + leaves[root]);\n    //for (int x : g[u]) {\n    //    for (int y : g[u]) {\n    //        if (x == y) {\n    //            continue;\n    //        }\n    //        ans = max(ans, dp[x] + dp[y] + 1);\n    //        // ans = max(ans, dp[x] + dp[y] + leaves[u] - leaves[x] - leaves[y] + (leaves[0] - leaves[u]));\n    //        ans = max(ans, dp[x] + dp[y] - leaves[x] - leaves[y] + leaves[0]);\n    //    }\n    //}\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    if (n <= 2) {\n        cout << n << endl;\n        return 0;\n    }\n    for (int i = 0; i < n; i++) {\n        if (g[i].size() >= 2) {\n            root = i;\n            dfs(i, -1);\n            dfs2(i, -1);\n            cout << ans << endl;\n            break;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<int> G[100010];\nint cnt;\nint dp[100010];\nint MAX = 0;\n\nint DFS(int v,int p)\n{\n    int res = (G[v].size() == 2);\n    int tmp = 0;\n    for(int i = 0; i < G[v].size(); i++)\n    {\n        int now = G[v][i];\n        if(now == p)continue;\n        res += DFS(now,v);\n        MAX = max(MAX,tmp + dp[now] + (G[v].size() == 2));\n        tmp = max(tmp,dp[now]);\n    }\n    dp[v] = tmp + (G[v].size() == 2);\n    return res;\n}\n\nint main()\n{\n    scanf(\"%d\",&N);\n    for(int i = 0; i < N - 1; i++)\n    {\n        int a,b;\n        scanf(\"%d%d\",&a,&b);\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n\n    for(int i = 1; i <= N; i++)if(G[i].size() == 1)cnt++;\n\n    DFS(1,0);\n\n    printf(\"%d\\n\",cnt + MAX);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <cstdio>\n#include <cassert>\n#include <algorithm>\n#include <iterator>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <set>\n#include <unordered_set>\n#include <map>\n#include <unordered_map>\n#include <tuple>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <utility>\n#include <complex>\n#include <bitset>\n#include <random>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int (i)=0; (i)<(n) ;++(i))\n#define REPN(i,a,n) FOR((i),(a),(a)+(n))\n#define FOR(i,a,b) for(int (i)=(a); (i)<(b) ;++(i))\n#define PB push_back\n#define MP make_pair\n#define SE second\n#define FI first\n#define DBG(a) cerr<<(a)<<endl;\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long LL;  typedef pair<LL, LL> PLL; typedef vector<LL> VLL;\nconst LL LINF=334ll<<53; const int INF=15<<26; const LL MOD=86400;\n\nstruct Edge{\n    int from,to;\n    Edge(int from,int to)\n        : from(from),to(to){};\n};\ntypedef vector<vector<Edge>> Graph;\n\nint depth(Graph &T, vector<int> &p, vector<int> &dep,vector<vector<int>> &dtov,int root){\n    int ret =0;\n    queue<int> Q;\n    Q.push(root);\n    p[root]=root;\n    dtov[0].push_back(root);\n    while(!Q.empty()){\n        int nex=Q.front();\n        Q.pop();\n        for(auto x: T[nex]){\n            if(p[x.to]==-1){\n                p[x.to]=x.from;\n                Q.push(x.to);\n                dep[x.to]=dep[x.from]+1;\n                ret=max(ret,dep[x.to]);\n                dtov[dep[x.to]].push_back(x.to);\n            }\n        }\n    }\n    return ret;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;cin >> n;\n    vector<int>par(n,-1),dep(n),subleaf(n),subleng(n);\n    Graph T(n);\n    vector<vector<int>> d(n);\n    REP(i,n-1){\n        int a,b;\n        cin >> a >>b;\n        a--;b--;\n        T[a].PB(Edge(a,b));\n        T[b].PB(Edge(b,a));\n    }\n    int r,leaf=0;\n    REP(i,n)if(T[i].size()==1){\n        r=i;\n        leaf++;\n    }\n    int mdep=depth(T,par,dep,d,r);\n    int ans=0,ans2=0;\n    for(int i=mdep; i>=0;--i){\n        for(auto x : d[i]){\n            //vector<int> mainchain;\n            if(T[x].size()==1){\n                subleaf[x]=1;\n            }else{\n                int lev=0,len=0,len2=0;\n                for(auto y: T[x]){\n                    if(y.to!=par[y.from]){\n                        lev+=subleaf[y.to];\n                        len2=max(len2,subleng[y.to]);\n                        if(len2>len)swap(len,len2);\n                    }\n                }\n                if(T[x].size()==2)len++;\n                subleaf[x]=lev;\n                subleng[x]=len;\n                ans=max(ans,leaf+len2+len);\n            }\n        }\n    }\n    for(auto x: T[r]){\n        ans2+=subleaf[x.to]+subleng[x.to]+1;\n    }\n    cout << max(ans,ans2) <<endl;\n\n    /*REP(i,n){\n        cout << T[i].size()<<' '<<subleaf[i]<<' '<<subleng[i]<<endl;\n    }*/\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> v[100000];\nbool used[100000];\nint endpoint = 0;\n\nint dfs(int cur) {\n    used[cur] = true;\n    vector<int> w;\n    for (int i = 0; i < v[cur].size(); i++) {\n        if (!used[v[cur][i]]) w.push_back(v[cur][i]); \n    }\n    if (w.empty()) {\n        endpoint++;\n        return 0;\n    }\n    if (w.size() == 1) return dfs(w[0]) + 1;\n    int ret = 0;\n    vector<int> x;\n    for (int i = 0; i < w.size(); i++) {\n        int p = dfs(w[i]);\n        ret = max(ret, p);\n    }\n    return ret;\n}\n\nint main() {\n    int n; cin >> n;\n    for (int i = 0; i < n-1; i++) {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    memset(used, 0, sizeof(used));\n    for (int i = 0; i < n; i++) {\n        if (v[i].size() == 1) {\n            cout << dfs(i) + endpoint << endl;\n            return 0;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<vector<int>> G;\n\nvector<int> bfs(int s) {\n  queue<int> que;\n  vector<int> mc(N, -1);\n  que.push(s);\n  mc[s] = 1;\n  while (!que.empty()) {\n    int u = que.front(); que.pop();\n    for (auto &v : G[u]) {\n      if (mc[v] == -1) {\n        mc[v] = mc[u] + max((int)G[u].size() - 2, 1);\n        //cout << u+1 << \" -> \" << v+1 << \" \" << mc[u] << \" -> \" << mc[v] << endl;\n        que.push(v);\n      }\n    }\n  }\n  return (mc);\n}\nint main() {\n  cin >> N;\n  G = vector<vector<int>>(N);\n  for (int i = 0; i < N-1; i++) {\n    int p, q;\n    cin >> p >> q; --p, --q;\n    G[p].push_back(q);\n    G[q].push_back(p);\n  }\n\n  vector<int> mc1 = bfs(0);\n  int pos = 0;\n  for (int i = 1; i < N; i++) {\n    if (mc1[i] > mc1[pos]) pos = i;\n  }\n  //cout << mc1[pos] << endl;\n  int d = 0;\n  for (int k = 0; k < N; k++) {\n    if (mc1[pos] == mc1[k]) {\n      vector<int> mc2 = bfs(k);\n      for (int i = 0; i < N; i++) d = max(d, mc2[i]);\n    }\n  }\n  cout << d << endl;\n  return (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb push_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\nconst ll MOD=1e9+7;\n\npii dfs(vv<int> &g,int v,int p){\n  pii re(0,v);\n  for(int w:g[v])if(w!=p) MX(re,dfs(g,w,v));\n  if(g[v].size()==2) ++re.X;\n  return re;\n}\n\nint main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(0);\n  int n;\n  cin>>n;\n  vv<int> g(n);\n  rep(i,n-1){\n    int x,y;\n    cin>>x>>y; --x; --y;\n    g[x].pb(y);\n    g[y].pb(x);\n  }\n  int lf=0;\n  rep(i,n)if(g[i].size()==1) ++lf;\n  pii p=dfs(g,0,-1);\n  pii q=dfs(g,p.Y,-1);\n  //out(p,q,lf,1);\n  cout<<q.X+lf<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 100002\n\nint n;\n\nvector<int> v[MAX];\n\nint dp[MAX];\n\nint ans;\n\ninline void dfs(int b,int pr){\n\tvector<int> ret;\n\tfor(int go:v[b]){\n\t\tif(go==pr)continue;\n\t\tdfs(go,b);\n\t\tret.push_back(dp[go]);\n\t}\n\tsort(ret.begin(),ret.end(),greater<int>());\n\tif(ret.size()>=2){\n\t\tans=max(ans,ret[0]+ret[1]+1);\n\t}\n\tdp[b]=1;\n\tif(ret.size()>=1){\n\t\tdp[b]+=ret[0];\n\t}\n\tint tmp=0;\n\tfor(int j=0;j<ret.size();j++){\n\t\tif(j>=2){\n\t\t\tret[j]=1;\n\t\t}\n\t\ttmp+=ret[j];\n\t}\n\tdp[b]=max(dp[b],tmp);\n\tans=max(ans,dp[b]);\n}\n\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tdfs(0,-1);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nlong long N, MAX = 0;\nvector<vector<long long> > V;\nvector<pair<long long, long long> > ANS;\n\nlong long DFS(long long P, long long Q) {\n\tvector<long long> W;\n\tfor (long long NP : V[P]) {\n\t\tif (NP != Q) W.push_back(DFS(NP, P));\n\t}\n\tsort(W.begin(), W.end(), greater<long long>());\n\tif (W.size() == 0) {\n\t\tANS[P] = { 1, 1 };\n\t}\n\telse if (W.size() == 1) {\n\t\tANS[P] = { W[0] + 1, W[0] + 1 };\n\t}\n\telse {\n\t\tfor (long long X : W) ANS[P].first += X;\n\t\tANS[P].second = W[0] + W[1] + 1;\n\t}\n\treturn ANS[P].first;\n}\n\nint main() {\n\tcin >> N;\n\tV.resize(N);\n\tANS.resize(N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tlong long P, Q;\n\t\tcin >> P >> Q;\n\t\tP--, Q--;\n\t\tV[P].push_back(Q);\n\t\tV[Q].push_back(P);\n\t}\n\tDFS(0, -1);\n\tfor (int i = 0; i < N; i++) {\n\t\tMAX = max(MAX, max(ANS[i].first, ANS[i].second));\n\t}\n\tcout << MAX << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }\n\nvector<int> t_parent;\nvector<int> t_ord;\n\nvoid tree_getorder(const vector<vi> &g, int root) {\n\tint n = g.size();\n\tt_parent.assign(n, -1);\n\tt_ord.clear();\n\n\tvector<int> stk; stk.push_back(root);\n\twhile(!stk.empty()) {\n\t\tint i = stk.back(); stk.pop_back();\n\t\tt_ord.push_back(i);\n\t\tfor(int j = (int)g[i].size() - 1; j >= 0; j --) {\n\t\t\tint c = g[i][j];\n\t\t\tif(t_parent[c] == -1 && c != root) {\n\t\t\t\tt_parent[c] = i;\n\t\t\t\tstk.push_back(c);\n\t\t\t}\n\t\t}\n\t}\n}\n\ntemplate<typename Sum, typename Combine, typename Calc>\nvoid freeTreeDP(const vector<int> &t_ord, const vector<int> &t_parent, vector<Sum> &downsum, vector<Sum> &upsum, Sum identity, Combine combine, Calc calc) {\n\tint n = (int)t_ord.size();\n\tvector<int> children(n, 0), childid(n, -1);\n\tfor(int ix = 1; ix < (int)t_ord.size(); ++ ix) {\n\t\tint i = t_ord[ix], p = t_parent[i];\n\t\tchildid[i] = children[p] ++;\n\t}\n\tvector<vector<Sum>> prefix(n), suffix(n);\n\tfor(int i = 0; i < n; ++ i) {\n\t\tprefix[i].assign(children[i] + 1, identity);\n\t\tsuffix[i].assign(children[i] + 1, identity);\n\t}\n\tdownsum.assign(n, identity);\n\tupsum.assign(n, identity);\n\tfor(int ix = (int)t_ord.size() - 1; ix >= 0; -- ix) {\n\t\tint i = t_ord[ix], p = t_parent[i];\n\t\tfor(int j = 0; j < children[i]; ++ j)\n\t\t\tprefix[i][j + 1] = combine(prefix[i][j], prefix[i][j + 1]);\n\t\tfor(int j = children[i]; j > 0; -- j)\n\t\t\tsuffix[i][j - 1] = combine(suffix[i][j - 1], suffix[i][j]);\n\t\tif(p != -1) {\n\t\t\tdownsum[i] = calc(p, i, suffix[i][0]);\n\t\t\tprefix[p][childid[i] + 1] = downsum[i];\n\t\t\tsuffix[p][childid[i]] = downsum[i];\n\t\t}\n\t}\n\tdownsum[t_ord[0]] = suffix[t_ord[0]][0];\n\tfor(int ix = 1; ix < (int)t_ord.size(); ++ ix) {\n\t\tint i = t_ord[ix], p = t_parent[i];\n\t\tSum sum = suffix[p][childid[i] + 1];\n\t\tsum = combine(sum, upsum[p]);\n\t\tsum = combine(sum, prefix[p][childid[i]]);\n\t\tupsum[i] = calc(i, p, sum);\n\t}\n}\n\nstruct Sum {\n\tint numLeafs;\n\tint maxNum, sndNum;\n\tint maxNum2;\n\tSum() : numLeafs(0), maxNum(0), sndNum(0), maxNum2(0) {}\n\tSum operator+(const Sum &that) const {\n\t\tSum res;\n\t\tres.numLeafs = numLeafs + that.numLeafs;\n\t\tint xs[4] = {\n\t\t\tmaxNum,\n\t\t\tsndNum,\n\t\t\tthat.maxNum,\n\t\t\tthat.sndNum\n\t\t};\n\t\tinplace_merge(xs, xs + 2, xs + 4, greater<int>());\n\t\tres.maxNum = xs[0];\n\t\tres.sndNum = xs[1];\n\t\tres.maxNum2 = max(maxNum2, that.maxNum2);\n\t\treturn res;\n\t}\n};\n\nint main() {\n\tint N;\n\twhile(~scanf(\"%d\", &N)) {\n\t\tvector<vector<int> > g(N);\n\t\tfor(int i = 0; i < N - 1; ++ i) {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v), -- u, -- v;\n\t\t\tg[u].push_back(v);\n\t\t\tg[v].push_back(u);\n\t\t}\n\t\ttree_getorder(g, 0);\n\t\tvector<Sum> down, up;\n\t\tfreeTreeDP(t_ord, t_parent, down, up, Sum(), plus<Sum>(), [](int from, int to, Sum sum) {\n\t\t\tSum res;\n\t\t\tres.numLeafs = max(1, sum.numLeafs);\n\t\t\tres.maxNum = (sum.maxNum + sum.sndNum + sum.numLeafs) - res.numLeafs;\n\t\t\tamax(res.maxNum, 1 + sum.maxNum2 - res.numLeafs);\n\t\t\tres.sndNum = -res.numLeafs;\n\t\t\tres.maxNum2 = res.maxNum + res.numLeafs;\n\t\t\treturn res;\n\t\t});\n\t\tint ans = 0;\n\t\trep(i, N) {\n\t\t\tamax(ans, 1 + down[i].maxNum + down[i].numLeafs);\n\t\t\tif(i != 0) amax(ans, 1 + up[i].maxNum + up[i].numLeafs);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <functional>\nusing namespace std;\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> g(n);\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        int leaf = 0;\n        for (int i = 0; i < n; i ++) if (g[i].size() == 1) leaf ++;\n        vector<int> dp(n), dp2(n);\n        function<void (int, int)> dfs = [&](int u, int prev) {\n                vector<int> len;\n                for (auto v : g[u]) if (v != prev) {\n                        dfs(v, u);\n                        len.push_back(dp2[v]);\n                        dp[u] = max(dp[u], dp[v]);\n                        dp2[u] = max(dp2[u], dp2[v] + (g[u].size() == 2));\n                }\n                sort(len.begin(), len.end(), greater<int>());\n                if (len.size() >= 2) dp[u] = max(dp[u], len[0] + len[1] + (g[u].size() == 2));\n        };\n        dfs(0, -1);\n        printf(\"%d\\n\", dp[0] + leaf);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define to edge[i].v\n#define mp make_pair\n#define rint register int\n#define fgx cerr<<\"-------------\"<<endl\n#define N 1000000\nusing namespace std;\ntypedef long long ll;\ntypedef long double db;\ntypedef pair<int,int> pii;\nvoid dbg(){cerr<<endl;}\ntemplate<typename A,typename... B>void dbg(A x,B... y){cerr<<x<<\" \";dbg(y...);}\n#define debug(...) cerr<<#__VA_ARGS__<<\"=\",dbg(__VA_ARGS__)\nint head[N],tot,f[N],g[N],d[N],ans;\nstruct Edge{int v,next;}edge[N];\ninline void add(int x,int y){edge[++tot]=Edge{y,head[x]};head[x]=tot;}\nvoid dfs(int x,int la=0)\n{\tfor(rint i=head[x];i;i=edge[i].next)\n\tif(to!=la)\n\t{\tdfs(to,x);\n\t\tif(f[to]>f[x]) g[x]=f[x],f[x]=f[to];\n\t\telse if(f[to]>g[x]) g[x]=f[to];\n\t}\n\tf[x]+=d[x]==2; ans=max(ans,f[x]+g[x]);\n}\nint main()\n{\tint n,x,y; cin>>n;\n\tfor(rint i=1;i<n;i++) scanf(\"%d%d\",&x,&y),add(x,y),add(y,x),d[x]++,d[y]++;\n\tdfs(1); for(rint i=1;i<=n;i++) ans+=d[i]==1; cout<<ans;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\nusing namespace std;\ntemplate <class T> void setmax(T & a, T const & b) { if (a < b) a = b; }\nint main() {\n    // input\n    int n; cin >> n;\n    vector<vector<int> > g(n);\n    repeat (i,n-1) {\n        int p, q; cin >> p >> q; -- p; -- q;\n        g[p].push_back(q);\n        g[q].push_back(p);\n    }\n    // compute\n    int ans = 0;\n    vector<int> middle(n), terminal(n); // dp on tree\n    function<void (int, int)> go = [&](int i, int parent) {\n        // prepare\n        int sum_middle = 0;\n        vector<int> terminals;\n        vector<int> diff;\n        for (int j : g[i]) if (j != parent) {\n            go(j, i);\n            sum_middle += middle[j];\n            terminals.push_back(terminal[j]);\n            diff.push_back(terminal[j] - middle[j]);\n        }\n        diff.push_back(0);\n        diff.push_back(0);\n        sort(diff.rbegin(), diff.rend());\n        terminals.push_back(0);\n        terminals.push_back(0);\n        sort(terminals.rbegin(), terminals.rend());\n        // result\n        middle[i] = max(1, sum_middle);\n        terminal[i] = max(1 + terminals[0], sum_middle + diff[0]);\n        setmax(ans, 1 + terminals[0] + terminals[1]);\n        setmax(ans, sum_middle + diff[0] + diff[1]);\n    };\n    go(0, -1);\n    // output\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, a, b, d[100009]; vector<int> g[100009];\nint solve(int pos, int pre) {\n\tint ret = 0, r1 = 0, r2 = 0;\n\tfor (int i : g[pos]) {\n\t\tif (i != pre) {\n\t\t\tret = max(ret, solve(i, pos));\n\t\t\tif (r1 < d[i]) r2 = r1, r1 = d[i];\n\t\t\telse if (r2 < d[i]) r2 = d[i];\n\t\t}\n\t}\n\td[pos] = r1 + (g[pos].size() == 2 ? 1 : 0);\n\treturn max(ret, d[pos] + r2);\n}\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i < N; i++) {\n\t\tscanf(\"%d %d\", &a, &b); a--, b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tint ret = 0;\n\tfor (int i = 0; i < N; i++) ret += (g[i].size() == 1 ? 1 : 0);\n\tprintf(\"%d\\n\", ret + solve(0, -1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 100002\n\nint n;\n\nvector<int> v[MAX];\n\nint dp[MAX];\n\nint ans;\n\ninline void dfs(int b,int pr){\n\tvector<int> ret;\n\tfor(int go:v[b]){\n\t\tif(go==pr)continue;\n\t\tdfs(go,b);\n\t\tret.push_back(dp[go]);\n\t}\n\tsort(ret.begin(),ret.end(),greater<int>());\n\tif(ret.size()>=2){\n\t\tans=max(ans,ret[0]+ret[1]+1);\n\t}\n\tdp[b]=1;\n\tif(ret.size()>=1){\n\t\tdp[b]+=ret[0];\n\t}\n\tint tmp=0;\n\tfor(int j=0;j<ret.size();j++){\n\t\ttmp+=ret[j];\n\t}\n\tdp[b]=max(dp[b],tmp);\n\tans=max(ans,dp[b]);\n}\n\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tdfs(0,-1);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n/* -------------------------------- Template -------------------------------- */\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <locale>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\ntemplate <typename T> int len(const T &x) { return x.size(); }\n\n// template<typename T> constexpr T inf = [](){ assert(false); };\n// template<> constexpr int inf<int> = 1e9;\n// template<> constexpr ll inf<ll> = 1e18;\n// template<> constexpr ld inf<ld> = 1e30;\n\nstruct yes_no : std::numpunct<char> {\n  string_type do_truename()  const { return \"Yes\"; }\n  string_type do_falsename() const { return \"No\"; }\n};\n\nvoid solve();\n\nint main() {\n  std::locale loc(std::locale(), new yes_no);\n  std::cout << std::boolalpha << std::setprecision(12) << std::fixed;\n  std::cout.imbue(loc);\n  solve();\n  return 0;\n}\n\nusing namespace std;\n\n/* -------------------------------- Library -------------------------------- */\n\n/* ---------------------------------- Main ---------------------------------- */\n\nvector<int> g[128000];\nbool visited[128000];\n\npair<int,int> dp(int v) {\n  visited[v] = true;\n  int path = 0, res = 0;\n  vector<int> ps;\n  for (int i: g[v]) {\n    if (visited[i]) continue;\n    int p, r;\n    tie(p, r) = dp(i);\n    chmax(path, p);\n    chmax(res, r);\n    ps.push_back(p);\n  }\n  sort(ps.rbegin(), ps.rend());\n  if (ps.size() >= 1) chmax(res, ps[0]);\n  if (ps.size() >= 2) chmax(res, ps[0] + ps[1] + (g[v].size() == 2));\n  if (g[v].size() == 2) path++;\n  return make_pair(path, res);\n}\n\nvoid solve() {\n  int N;\n  cin >> N;\n  REP(i,N-1) {\n    int a, b;\n    cin >> a >> b;\n    g[a-1].push_back(b-1);\n    g[b-1].push_back(a-1);\n  }\n  int res = dp(0).second;\n  REP(i,N) res += (g[i].size() == 1);\n  cout << res << endl;\n  return;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }\n\nvector<int> t_parent;\nvector<int> t_ord;\n\nvoid tree_getorder(const vector<vi> &g, int root) {\n\tint n = g.size();\n\tt_parent.assign(n, -1);\n\tt_ord.clear();\n\n\tvector<int> stk; stk.push_back(root);\n\twhile(!stk.empty()) {\n\t\tint i = stk.back(); stk.pop_back();\n\t\tt_ord.push_back(i);\n\t\tfor(int j = (int)g[i].size() - 1; j >= 0; j --) {\n\t\t\tint c = g[i][j];\n\t\t\tif(t_parent[c] == -1 && c != root) {\n\t\t\t\tt_parent[c] = i;\n\t\t\t\tstk.push_back(c);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint N;\n\twhile(~scanf(\"%d\", &N)) {\n\t\tvector<vector<int> > g(N);\n\t\tfor(int i = 0; i < N - 1; ++ i) {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v), -- u, -- v;\n\t\t\tg[u].push_back(v);\n\t\t\tg[v].push_back(u);\n\t\t}\n\t\ttree_getorder(g, 0);\n\t\tvector<int> dp(N);\n\t\tint ans = 0;\n\t\tfor(int ix = (int)t_ord.size() - 1; ix >= 0; -- ix) {\n\t\t\tint i = t_ord[ix], p = t_parent[i];\n\t\t\tint fst = -INF, snd = -INF, num = 0;\n\t\t\tfor(int j : g[i]) if(j != p) {\n\t\t\t\t++ num;\n\t\t\t\tif(fst < dp[j]) {\n\t\t\t\t\tsnd = fst;\n\t\t\t\t\tfst = dp[j];\n\t\t\t\t} else if(snd < dp[j]) {\n\t\t\t\t\tsnd = dp[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(num <= 1) {\n\t\t\t\tdp[i] = max({ 1, fst + 1 });\n\t\t\t} else {\n\t\t\t\tamax(ans, fst + snd + max(1, num - 2));\n\t\t\t\tdp[i] = fst + max(1, num - 1);\n\t\t\t}\n\t\t\tamax(ans, dp[i]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#pragma GCC target(\"sse4.2\")\n\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef pair<Weight, int> Result;\nResult visit(int p, int v, const Graph &g) {\n  int f = g[v].size()==2;\n  Result r(0, v);\n  for(auto &e: g[v]) if (e.dst != p) {\n    Result t = visit(v, e.dst, g);\n    t.first += f; //e->weight;\n    if (r.first < t.first) r = t;\n  }\n  return r;\n}\nWeight diameter(const Graph &g) {\n  Result r = visit(-1, 0, g);\n  Result t = visit(-1, r.second, g);\n  return t.first; // (r.second, t.second) is farthest pair\n}\n\nint main(){\n\tint V,s,t;\n\tscanf(\"%d\",&V);\n\tGraph g(V);\n\tfor(;V>1;V--)scanf(\"%d%d\",&s,&t),s--,t--,g[s].push_back(Edge(s,t,1)),g[t].push_back(Edge(t,s,1));\n\tprintf(\"%d\\n\",diameter(g)+count_if(g.begin(),g.end(),[](auto &e){return e.size()==1;}));\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\nvoid func(vector<vector<int>>&edge, vector<int>&dp, int &ans, int node = 0, int p = -1) {\n\tvector<int>box;\n\tfor (auto i : edge[node]) {\n\t\tif (i == p)continue;\n\t\tfunc(edge, dp, ans, i, node);\n\t\tbox.push_back(dp[i]);\n\t}\n\tsort(box.rbegin(), box.rend());\n\tif (box.empty()) {\n\t\tdp[node] = 1;\n\t\tans = max(ans, 1);\n\t}\n\telse if (box.size() == 1) {\n\t\tdp[node] = box[0] + 1;\n\t\tans = max(ans, dp[node]);\n\t}\n\telse if (box.size() >= 2) {\n\t\tdp[node] = box[0] + box.size() - 1;\n\t\tans = max(ans, box[0] + box[1] + 1);\n\t\tans = max(ans, dp[node]);\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>edge(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> L >> R;\n\t\tL--, R--;\n\t\tedge[L].push_back(R);\n\t\tedge[R].push_back(L);\n\t}\n\tint ans = 0;\n\tvector<int>dp(N);\n\tfunc(edge, dp, ans);\n\t//for (int i = 0; i < N; i++) {\n\t//\tcout << i << \" \" << dp[i] << endl;\n\t//}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint N,ans;\nvector<int>G[1<<17];\nint dfs(int u,int p)\n{\n\tint m1=0,m2=0;\n\tfor(int v:G[u])if(v!=p)\n\t{\n\t\tint t=dfs(v,u);\n\t\tif(m1<t)\n\t\t{\n\t\t\tm2=m1;\n\t\t\tm1=t;\n\t\t}\n\t\telse if(m2<t)m2=t;\n\t}\n\tint now=(int)G[u].size()-2;\n\tif(now<1)now=1;\n\tans=max(ans,m1+m2+now);\n\treturn max((int)G[u].size()-1,m1+now);\n}\nmain()\n{\n\tcin>>N;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint u,v;cin>>u>>v;u--,v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tdfs(0,-1);\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }\n\nvector<int> t_parent;\nvector<int> t_ord;\n\nvoid tree_getorder(const vector<vi> &g, int root) {\n\tint n = g.size();\n\tt_parent.assign(n, -1);\n\tt_ord.clear();\n\n\tvector<int> stk; stk.push_back(root);\n\twhile(!stk.empty()) {\n\t\tint i = stk.back(); stk.pop_back();\n\t\tt_ord.push_back(i);\n\t\tfor(int j = (int)g[i].size() - 1; j >= 0; j --) {\n\t\t\tint c = g[i][j];\n\t\t\tif(t_parent[c] == -1 && c != root) {\n\t\t\t\tt_parent[c] = i;\n\t\t\t\tstk.push_back(c);\n\t\t\t}\n\t\t}\n\t}\n}\n\ntemplate<typename Sum, typename Combine, typename Calc>\nvoid freeTreeDP(const vector<int> &t_ord, const vector<int> &t_parent, vector<Sum> &downsum, vector<Sum> &upsum, Sum identity, Combine combine, Calc calc) {\n\tint n = (int)t_ord.size();\n\tvector<int> children(n, 0), childid(n, -1);\n\tfor(int ix = 1; ix < (int)t_ord.size(); ++ ix) {\n\t\tint i = t_ord[ix], p = t_parent[i];\n\t\tchildid[i] = children[p] ++;\n\t}\n\tvector<vector<Sum>> prefix(n), suffix(n);\n\tfor(int i = 0; i < n; ++ i) {\n\t\tprefix[i].assign(children[i] + 1, identity);\n\t\tsuffix[i].assign(children[i] + 1, identity);\n\t}\n\tdownsum.assign(n, identity);\n\tupsum.assign(n, identity);\n\tfor(int ix = (int)t_ord.size() - 1; ix >= 0; -- ix) {\n\t\tint i = t_ord[ix], p = t_parent[i];\n\t\tfor(int j = 0; j < children[i]; ++ j)\n\t\t\tprefix[i][j + 1] = combine(prefix[i][j], prefix[i][j + 1]);\n\t\tfor(int j = children[i]; j > 0; -- j)\n\t\t\tsuffix[i][j - 1] = combine(suffix[i][j - 1], suffix[i][j]);\n\t\tif(p != -1) {\n\t\t\tdownsum[i] = calc(p, i, suffix[i][0]);\n\t\t\tprefix[p][childid[i] + 1] = downsum[i];\n\t\t\tsuffix[p][childid[i]] = downsum[i];\n\t\t}\n\t}\n\tdownsum[t_ord[0]] = suffix[t_ord[0]][0];\n\tfor(int ix = 1; ix < (int)t_ord.size(); ++ ix) {\n\t\tint i = t_ord[ix], p = t_parent[i];\n\t\tSum sum = suffix[p][childid[i] + 1];\n\t\tsum = combine(sum, upsum[p]);\n\t\tsum = combine(sum, prefix[p][childid[i]]);\n\t\tupsum[i] = calc(i, p, sum);\n\t}\n}\n\nstruct Sum {\n\tint maxNum;\n\tSum() : maxNum(0) {}\n\tSum operator+(const Sum &that) const {\n\t\tSum res;\n\t\tres.maxNum = max(maxNum, that.maxNum);\n\t\treturn res;\n\t}\n};\n\nint main() {\n\tint N;\n\twhile(~scanf(\"%d\", &N)) {\n\t\tvector<vector<int> > g(N);\n\t\tfor(int i = 0; i < N - 1; ++ i) {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v), -- u, -- v;\n\t\t\tg[u].push_back(v);\n\t\t\tg[v].push_back(u);\n\t\t}\n\t\ttree_getorder(g, 0);\n\t\tint leafs = 0;\n\t\trep(i, N)\n\t\t\tleafs += g[i].size() == 1;\n\t\tvector<Sum> down, up;\n\t\tfreeTreeDP(t_ord, t_parent, down, up, Sum(), plus<Sum>(), [&](int from, int to, Sum sum) {\n\t\t\tSum res;\n\t\t\tres.maxNum = sum.maxNum + (g[to].size() == 2);\n\t\t\treturn res;\n\t\t});\n\t\tint maxPath = 0;\n\t\trep(i, N) {\n\t\t\tamax(maxPath, down[i].maxNum);\n\t\t\tif(i != 0) amax(maxPath, up[i].maxNum );\n\t\t}\n\t\tint ans = leafs + maxPath;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 16.12.2019 13:30:15       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<int>> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  int ans = 0;\n  for (int root = 0; root < n; root++) {\n    function<pair<int, int>(int, int)> Dfs = [&](int v, int pr) {\n      int one = 1;\n      int two = 0;\n      int profit = 0;\n      for (int u : g[v]) {\n        if (u == pr) {\n          continue;\n        }\n        auto res = Dfs(u, v);\n        one = max(one, 1 + res.first);\n        two += res.second;\n        profit = max(profit, res.first - res.second);\n      }\n      one = max(one, two + profit);\n      two = max(two, 1);\n      ans = max(ans, one);\n      return make_pair(one, two);\n    };\n    Dfs(root, -1);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[101010];\nint D[101010];\nint ret;\n\nvoid dfs(int cur,int pre,int d) {\n\tD[cur]=d;\n\tFORR(r,E[cur]) if(r!=pre) dfs(r,cur,d+1);\n}\n\nint dfs2(int tar,int cur,int pre) {\n\tint now=0;\n\tif(cur==tar) return 1;\n\tFORR(r,E[cur]) if(r!=pre) {\n\t\tnow |= dfs2(tar,r,cur);\n\t}\n\tif(now && E[cur].size()>2) ret--;\n\treturn now;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\t\n\tint leaf=0;\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\tFOR(i,N) if(E[i].size()==1) leaf++;\n\t\n\tdfs(0,-1,0);\n\tx = max_element(D,D+N)-D;\n\tdfs(x,-1,0);\n\ty = max_element(D,D+N)-D;\n\tret=leaf-2+D[y]+1;\n\tdfs2(y,x,-1);\n\t\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*保证棋盘第一格有色\n判断[x-1,y],[x,y-1],[x+1,y],[x,y+1]\n如果有同色 走同色 有异色并且没有同色 走异色 \n*/ \n#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n\tint m,n,a[101][101],sum=0,mf=0;\n\tcin>>m>>n;\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tfor(int j=0;j<m;j++)\n\t\t{\n\t\t\ta[i][j]=-1;\n\t\t}\n\t}\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint x,y,c;\n\t\tcin>>x>>y>>c;\n\t\ta[x][y]=c;\n\t}\n\tint x=0,y=0;\n\twhile(x!=m-1&&y!=m-1)\n\t{\n\t\tif(a[x][y]==a[x-1][y])\n\t\t{\n\t\t\tx--;\n\t\t}\n\t\tif(a[x][y]==a[x][y-1])\n\t\t{\n\t\t\ty--;\n\t\t}\n\t\tif(a[x][y]==a[x+1][y])\n\t\t{\n\t\t\tx++;\n\t\t}\n\t\tif(a[x][y]==a[x][y+1])\n\t    {\n\t    \ty++;\n\t\t}\n\t\t\n\t\t\n\t\telse if(a[x-1][y]!=-1)\n\t\t{\n\t\t\tx--;\n\t\t\tsum++;\n\t\t}\n\t\telse if(a[x][y-1]!=-1)\n\t\t{\n\t\t\ty--;\n\t\t\tsum++;\n\t\t}\n\t\telse if(a[x+1][y]!=-1)\n\t\t{\n\t\t\tx++;\n\t\t\tsum++;\n\t\t}\n\t\telse if(a[x][y+1]!=-1)\n\t    {\n\t    \ty++;\n\t    \tsum++;\n\t\t}\n\t\t\n\t\t\n\t    else if(mf==0)\n\t    {\n\t    \tif(a[x-1][y]==-1)\n\t\t    {\n\t\t\t\tx--;\n\t\t\t\tsum+=2;\n\t\t\t}\n\t\t\tif(a[x][y-1]==-1)\n\t\t\t{\n\t\t\t\ty--;\n\t\t\t\tsum+=2;\n\t\t\t}\n\t\t\tif(a[x+1][y]==-1)\n\t\t\t{\n\t\t\t\tx++;\n\t\t\t\tsum+=2;\n\t\t\t}\n\t\t\tif(a[x][y+1]==-1)\n\t    \t{\n\t    \t\ty++;\n\t    \t\tsum+=2;\n\t\t\t}\n\t\t\tmf=1;\n\t\t}\n\t\t\n\t\t\n\t\telse if(mf!=0)\n\t\t{\n\t\t\tif(a[x-1][y]==-1&&a[x][y-1]==-1&&a[x+1][y]==-1&&a[x][y+1]==-1)\n\t\t    {\n\t\t    \tcout<<\"-1\";\n\t\t    \treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<sum;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (l);i < (r);i++)\n#define ALL(x) (x).begin(),(x).end()\ntemplate<typename T> bool chmax(T& a,const T& b){return a < b ? (a = b,true) : false;}\ntemplate<typename T> bool chmin(T& a,const T& b){return b < a ? (a = b,true) : false;}\ntypedef long long ll;\n\nint N;\nlist<int> edge [100001];\nint leaf [100001];\nconst int INF = 1e9;\n\nvoid dfs(int curr,int cost,vector<int>& min_cost)\n{\n\tif(chmin(min_cost [curr],cost) == false) return;\n\n\tfor(auto it : edge [curr]){\n\t\tdfs(it,cost + 1,min_cost);\n\t}\n}\n\nint cnt_leaf(int curr,int prev)\n{\n\tint res = 0;\n\tfor(auto it : edge [curr]) if(it != prev){\n\t\tres += cnt_leaf(it,curr);\n\t}\n\treturn leaf [curr] = max(1,res);\n}\n\nint dfs2(int curr,int prev)\n{\n\tint res = 1;\n\tfor(auto it : edge [curr]) if(it != prev){\n\t\tint tmp = dfs2(it,curr);\n\t\tchmax(res,tmp + max(1,leaf [curr] - leaf [it]));\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tFOR(i,0,N - 1){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge [u].push_back(v);\n\t\tedge [v].push_back(u);\n\t}\n\n\tvector<int> min_cost(N + 1,INF);\n\tdfs(1,0,min_cost);\n\tint node = max_element(min_cost.begin() + 1,min_cost.end()) - min_cost.begin();\n\n\tcnt_leaf(node,-1);\n\tprintf(\"%d\\n\",dfs2(node,-1));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }\n\nvector<int> t_parent;\nvector<int> t_ord;\n\nvoid tree_getorder(const vector<vi> &g, int root) {\n\tint n = g.size();\n\tt_parent.assign(n, -1);\n\tt_ord.clear();\n\n\tvector<int> stk; stk.push_back(root);\n\twhile(!stk.empty()) {\n\t\tint i = stk.back(); stk.pop_back();\n\t\tt_ord.push_back(i);\n\t\tfor(int j = (int)g[i].size() - 1; j >= 0; j --) {\n\t\t\tint c = g[i][j];\n\t\t\tif(t_parent[c] == -1 && c != root) {\n\t\t\t\tt_parent[c] = i;\n\t\t\t\tstk.push_back(c);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tint N;\n\twhile(~scanf(\"%d\", &N)) {\n\t\tvector<vector<int> > g(N);\n\t\tfor(int i = 0; i < N - 1; ++ i) {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v), -- u, -- v;\n\t\t\tg[u].push_back(v);\n\t\t\tg[v].push_back(u);\n\t\t}\n\t\ttree_getorder(g, 0);\n\t\tvector<int> dp(N);\n\t\tint ans = 0;\n\t\tfor(int ix = (int)t_ord.size() - 1; ix >= 0; -- ix) {\n\t\t\tint i = t_ord[ix], p = t_parent[i];\n\t\t\tint fst = -INF, snd = -INF, num = p != -1, num2 = 0;\n\t\t\tfor(int j : g[i]) if(j != p) {\n\t\t\t\t++ num;\n\t\t\t\t++ num2;\n\t\t\t\tif(fst < dp[j]) {\n\t\t\t\t\tsnd = fst;\n\t\t\t\t\tfst = dp[j];\n\t\t\t\t} else if(snd < dp[j]) {\n\t\t\t\t\tsnd = dp[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(snd == -INF) {\n\t\t\t\tdp[i] = max(0, fst) + max(1, num2 - 1);\n\t\t\t} else {\n\t\t\t\tamax(ans, fst + snd + max(1, num - 2));\n\t\t\t\tdp[i] = fst + max(1, num2 - 1);\n\t\t\t}\n\t\t\tamax(ans, dp[i]);\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }\n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n;\n  cin>>n;\n\n  vector< vector<int> > G(n);\n  for(int i=1;i<n;i++){\n    int p,q;\n    cin>>p>>q;\n    p--;q--;\n    G[p].emplace_back(q);\n    G[q].emplace_back(p);\n  }\n\n  vector<int> dp1(n,0),dp2(n,0);\n  int ans=0;\n  MFP([&](auto dfs,int v,int p)->void{\n        int sum=0,mx=0;\n        vector<int> vs;\n        for(int u:G[v]){\n          if(u==p) continue;\n          dfs(u,v);\n          sum+=dp2[u];\n          chmax(mx,dp1[u]);\n          vs.emplace_back(dp1[u]-dp2[u]);\n        }\n        if(vs.empty()){\n          dp1[v]=1;\n          dp2[v]=1;\n          return;\n        }\n        while(vs.size()<2) vs.emplace_back(0);\n        sort(vs.rbegin(),vs.rend());\n\n        /*\n        cout<<\"v: \"<<v<<\", sum:\"<<sum<<endl;\n        for(int w:vs) cout<<w<<\" \";\n        cout<<endl;\n        */\n\n        // c1 -> v -> c2, take v\n        chmax(ans,sum+vs[0]+1+vs[1]);\n\n        // c1 -> v, take v\n        chmax(dp1[v],mx+1);\n\n        // c1 -> v, not take v\n        chmax(dp1[v],vs[0]+sum);\n\n        // not take v\n        chmax(dp2[v],sum);\n\n        // cout<<v<<\", dp1[v] = \"<<dp1[v]<<\", dp2[v] = \"<<dp2[v]<<endl;\n      })(0,-1);\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef pair<Weight, int> Result;\nResult visit(int p, int v, const Graph &g) {\n  Result r(0, v);\n  for(auto &e: g[v]) if (e.dst != p) {\n    Result t = visit(v, e.dst, g);\n    t.first += g[v].size()==2; //e->weight;\n    if (r.first < t.first) r = t;\n  }\n  return r;\n}\nWeight diameter(const Graph &g) {\n  Result r = visit(-1, 0, g);\n  Result t = visit(-1, r.second, g);\n  return t.first; // (r.second, t.second) is farthest pair\n}\n\nint main(){\n\tint V,s,t;\n\tscanf(\"%d\",&V);\n\tGraph g(V);\n\tfor(;V>1;V--)scanf(\"%d%d\",&s,&t),s--,t--,g[s].push_back(Edge(s,t,1)),g[t].push_back(Edge(t,s,1));\n\tprintf(\"%d\\n\",diameter(g));\n}"
  },
  {
    "language": "C++",
    "code": "def dfs(z,c)\n\tr=[0,c]\n\tG[c].each{|e|\n\t\tnext if e==z\n\t\tt=dfs(c,e)\n\t\tr=[r,[t[0]+(G[c].size==2 ? 1 : 0),t[1]]].max\n\t}\n\tr\nend\nN=gets.to_i\nG=N.times.map{[]}\n(N-1).times{\n\ta,b=gets.split.map(&:to_i)\n\tG[a-1]<<b-1\n\tG[b-1]<<a-1\n}\np dfs(-1,dfs(-1,0)[1])[0]+G.count{|e|e.size==1}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n#define repv(t,it,v) for(vector<t>::iterator it = v.begin() ; it != v.end() ; ++it)\n\nint N;\nvector<int> V[100010];\nint ans = 0;\n\nint dfs(int p , int q){\n\tint a = 0;\n\tint b = 0;\n\trepv(int,it,V[q]){\n\t\tif(p == (*it)) continue;\n\t\tint x = dfs(q,(*it)) + 1;\n\t\tif(x > a){\n\t\t\tb = a;\n\t\t\ta = x;\n\t\t} else if(x > b){\n\t\t\tb = x;\n\t\t}\n\t}\n\tans = max(ans , a + b + max(0,(int)V[q].size()-3)+1);\n\treturn a + max(0,(int)V[q].size()-3);\n}\n\nint main(){\n\tscanf(\"%d\" , &N);\n\trepp(i,1,N){\n\t\tint a,b;\n\t\tscanf(\"%d%d\" , &a , &b);\n\t\tV[a].PB(b);\n\t\tV[b].PB(a);\n\t}\n\tdfs(-1,1);\n\tprintf(\"%d\\n\" , ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }\n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n;\n  cin>>n;\n\n  vector< vector<int> > G(n);\n  for(int i=1;i<n;i++){\n    int p,q;\n    cin>>p>>q;\n    p--;q--;\n    G[p].emplace_back(q);\n    G[q].emplace_back(p);\n  }\n\n  vector<int> dp1(n,0),dp2(n,0);\n  int ans=0;\n  MFP([&](auto dfs,int v,int p)->void{\n        int sum=0;\n        vector<int> vs,mx;\n        for(int u:G[v]){\n          if(u==p) continue;\n          dfs(u,v);\n          sum+=dp2[u];\n          mx.emplace_back(dp1[u]);\n          vs.emplace_back(dp1[u]-dp2[u]);\n        }\n        if(vs.empty()){\n          dp1[v]=1;\n          dp2[v]=1;\n          return;\n        }\n        while(vs.size()<2) vs.emplace_back(0);\n        while(mx.size()<2) mx.emplace_back(0);\n        sort(vs.rbegin(),vs.rend());\n        sort(mx.rbegin(),mx.rend());\n\n        // c1 -> v -> c2, take v\n        chmax(ans,mx[0]+1+mx[1]);\n\n        // c1 -> v -> c2, not take v\n        chmax(ans,sum+vs[0]+vs[1]);\n\n        // c1 -> v, take v\n        chmax(dp1[v],mx[0]+1);\n\n        // c1 -> v, not take v\n        chmax(dp1[v],sum+vs[0]);\n\n        // not take v\n        chmax(dp2[v],sum);\n\n        // cout<<v<<\", dp1[v] = \"<<dp1[v]<<\", dp2[v] = \"<<dp2[v]<<endl;\n      })(0,-1);\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (int) (l);i < (int) (r);i++)\n#define ALL(x) x.begin(),x.end()\ntemplate<typename T> bool chmax(T& a,const T& b){ return a < b ? (a = b,true) : false; }\ntemplate<typename T> bool chmin(T& a,const T& b){ return b < a ? (a = b,true) : false; }\ntypedef long long ll;\n\nint N;\nvector<int> edge [100001];\nint dp [100001];\n\nint dfs(int curr,int prev)\n{\n\tint res = 0;\n\tvector<int> v;\n\tbool leaf = true;\n\tfor(const auto& it : edge [curr]) if(it != prev){\n\t\tchmax(res,dfs(it,curr));\n\t\tv.push_back(dp [it]);\n\t\tleaf = false;\n\t}\n\tif(leaf) v.push_back(0);\n\tsort(v.rbegin(),v.rend());\n\tif(v.size() >= 2){\n\t\tchmax(res,v [0] + v [1] + (edge [curr].size() == 2));\n\t\tdp [curr] = v [0] + (edge [curr].size() == 2);\n\t}\n\telse if(v.size() == 1){\n\t\tchmax(res,v [0] + (edge [curr].size() == 2));\n\t\tdp [curr] = v [0] + (edge [curr].size() == 2);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tFOR(i,0,N - 1){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge [u].push_back(v);\n\t\tedge [v].push_back(u);\n\t}\n\tint ans = 0;\n\tFOR(i,1,N + 1){\n\t\tans += edge [i].size() == 1;\n\t}\n\tans += dfs(1,-1);\n\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (l);i < (r);i++)\n#define ALL(x) (x).begin(),(x).end()\ntemplate<typename T> bool chmax(T& a,const T& b){return a < b ? (a = b,true) : false;}\ntemplate<typename T> bool chmin(T& a,const T& b){return b < a ? (a = b,true) : false;}\ntypedef long long ll;\n\nint N;\nlist<int> edge [100001];\nint leaf [100001];\nconst int INF = 1e9;\n\nint cnt_leaf(int curr,int prev)\n{\n\tint res = 0;\n\tfor(auto it : edge [curr]) if(it != prev){\n\t\tres += cnt_leaf(it,curr);\n\t}\n\treturn leaf [curr] = max(1,res);\n}\n\nint dfs(int curr,int prev)\n{\n\tint res = 1,leaf_sum = 0;\n\tfor(auto it : edge [curr]) if(it != prev){\n\t\tleaf_sum += leaf [it];\n\t}\n\tfor(auto it : edge [curr]) if(it != prev){\n\t\tint tmp = dfs(it,curr);\n\t\tchmax(res,tmp + leaf_sum - leaf [it]);\n\t\tchmax(res,tmp + 1);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tFOR(i,0,N - 1){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge [u].push_back(v);\n\t\tedge [v].push_back(u);\n\t}\n\tcnt_leaf(1,-1);\n\n\tfor(int i = 1;i <= N - 1;i++){\n\t\tif(edge [i].size() == 1){\n\t\t\tcnt_leaf(i,-1);\n\t\t\tprintf(\"%d\\n\",dfs(i,-1));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }\n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n;\n  cin>>n;\n\n  vector< vector<int> > G(n);\n  for(int i=1;i<n;i++){\n    int p,q;\n    cin>>p>>q;\n    p--;q--;\n    G[p].emplace_back(q);\n    G[q].emplace_back(p);\n  }\n\n  vector<int> dp1(n,0),dp2(n,0),dp3(n,0);\n  int ans=0;\n  MFP([&](auto dfs,int v,int p)->void{\n        int sum=0;\n        vector<int> vs,mx;\n        for(int u:G[v]){\n          if(u==p) continue;\n          dfs(u,v);\n          sum+=dp2[u];\n          mx.emplace_back(dp1[u]);\n          vs.emplace_back(dp1[u]-dp2[u]);\n        }\n        if(vs.empty()){\n          dp1[v]=1;\n          dp2[v]=1;\n          return;\n        }\n        while(vs.size()<2) vs.emplace_back(0);\n        while(mx.size()<2) mx.emplace_back(0);\n        sort(vs.rbegin(),vs.rend());\n        sort(mx.rbegin(),mx.rend());\n\n        // c1 -> v -> c2, not take v\n        chmax(dp3[v],sum+vs[0]+vs[1]);\n        chmax(dp3[v],mx[0]+mx[1]);\n\n        for(int u:G[v]){\n          if(u==p) continue;\n          chmax(dp3[v],sum-dp2[u]+dp3[u]);\n          chmax(ans,sum-dp2[u]+dp3[u]+1);\n        }\n\n        // c1 -> v, take v\n        chmax(dp1[v],mx[0]+1);\n\n        // c1 -> v, not take v\n        chmax(dp1[v],sum+vs[0]);\n\n        // not take v\n        chmax(dp2[v],sum);\n\n        // c1 -> v -> c2, take v\n        chmax(ans,mx[0]+1+mx[1]);\n        chmax(ans,dp1[v]);\n        chmax(ans,dp2[v]);\n        chmax(ans,dp3[v]);\n        // cout<<v<<\", dp1[v] = \"<<dp1[v]<<\", dp2[v] = \"<<dp2[v]<<endl;\n      })(0,-1);\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint cnt;\nint ma;\nint dp[100010];\nvi g[100010];\nvi g2[100010];\nmultiset<int> st;\n\nvoid dfs(int v, int p)\n{\n\tfor (int to : g[v]) {\n\t\tif (to != p) {\n\t\t\tdfs(to, v);\n\t\t\tdp[v] = max(dp[v], dp[to]);\n\t\t\tg2[v].pb(to);\n\t\t\tst.insert(dp[v]);\n\t\t\tif (st.size() > 2) st.erase(st.begin());\n\t\t}\n\t}\n\n\tif (st.size() == 2) {\n\t\tauto it = st.begin();\n\t\tauto it2 = it;\n\t\t++it2;\n\t\tma = max(ma, *it + *it2);\n\t}\n\n\tif (g[v].size() == 2) {\n\t\tif (p != -1) {\n\t\t\tdp[v] = max(dp[v], dp[g2[v][0]] + 1);\n\t\t} else {\n\t\t\tma = max(ma, dp[g2[v][0]] + dp[g2[v][1]] + 1);\n\t\t}\n\t}\n\n\tma = max(ma, dp[v]);\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\n\trep(i,N-1) {\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\n\trep(i, N) {\n\t\tif (g[i].size() == 1) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\n\tdfs(0, -1);\n\n\tcout << cnt + ma << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main()\n{\n    int N; cin >> N;\n    vector<vector<int>> G(N);\n    for (int i = 0; i < N-1; i++) {\n        int p, q; cin >> p >> q; p--, q--;\n        G[p].push_back(q);\n        G[q].push_back(p);\n    }\n    int ans = 0;\n    for (int i = 0; i < N; i++) {\n        if (G[i].size() <= 2) ans++;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint h[100010],nex[200010],to[200010],M;\nvoid add(int a,int b){\n\tM++;\n\tto[M]=b;\n\tnex[M]=h[a];\n\th[a]=M;\n}\nint d[100010],v[100010],f[100010],g[100010];\nvoid dfs(int fa,int x){\n\tf[x]=g[x]=v[x];\n\tfor(int i=h[x];i;i=nex[i]){\n\t\tif(to[i]!=fa){\n\t\t\tdfs(x,to[i]);\n\t\t\tf[x]=max(f[x],g[x]+g[to[i]]);\n\t\t\tg[x]=max(g[x],g[to[i]]+v[x]);\n\t\t}\n\t}\n}\nint main(){\n\tint n,i,x,y,s;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t\td[x]++;\n\t\td[y]++;\n\t}\n\ts=0;\n\tfor(i=1;i<=n;i++){\n\t\ts+=d[i]==1;\n\t\tv[i]=d[i]==2;\n\t}\n\tdfs(0,1);\n\tprintf(\"%d\",s+f[1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, a, b, c[100009]; vector<int> g[100009];\nint solve(int pos, int pre) {\n\tint ret = c[pos], r = 0, r1 = 0, r2 = 0;\n\tfor (int i : g[pos]) {\n\t\tif (i != pre) {\n\t\t\tsolve(i, pos);\n\t\t\tif (r1 < c[i]) r2 = r1, r1 = c[i];\n\t\t\telse if (r2 < c[i]) r2 = c[i];\n\t\t\tr = r > c[i] ? r : c[i];\n\t\t}\n\t}\n\tc[pos] += r;\n\treturn ret + r1 + r2;\n}\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i < N; i++) {\n\t\tscanf(\"%d %d\", &a, &b); a--, b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tif (g[i].size() <= 3) c[i] = 1;\n\t\telse c[i] = g[i].size() - 2;\n\t}\n\tprintf(\"%d\\n\", solve(0, -1));\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nint N;\nvint G[111111];\n\nint latte[111111];\nint ma=0;\nvoid dfs(int v,int p){\n    vint lis;\n    for(auto u:G[v]){\n        if(u==p)continue;\n        dfs(u,v);\n        lis.pb(latte[u]);\n        chmax(latte[v],latte[u]);\n    }\n    sort(all(lis));\n    reverse(all(lis));\n\n    if(G[v].size()==2){\n        if(p==-1){\n            chmax(ma,latte[G[v][0]]+latte[G[v][1]]+1);\n        }\n        else{\n            latte[v]++;\n        }\n    }\n    if(lis.size()>=2){\n        chmax(ma,lis[0]+lis[1]);\n    }\n}\n\nsigned main(){\n    cin>>N;\n    rep(i,N-1){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        G[a].pb(b);G[b].pb(a);\n    }\n\n    dfs(0,-1);\n    chmax(ma,latte[0]);\n    rep(i,N)if(G[i].size()==1)ma++;\n    cout<<ma<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<vector<int>> G;\n\nvector<int> bfs(int s) {\n  queue<int> que;\n  vector<int> mc(N, -1);\n  que.push(s);\n  mc[s] = 0;\n  while (!que.empty()) {\n    int u = que.front(); que.pop();\n    for (auto &v : G[u]) {\n      if (mc[v] == -1) {\n        mc[v] = mc[u] + 1;\n        que.push(v);\n      }\n    }\n  }\n  return (mc);\n}\nint main() {\n  cin >> N;\n  G = vector<vector<int>>(N);\n  for (int i = 0; i < N-1; i++) {\n    int p, q;\n    cin >> p >> q; --p, --q;\n    G[p].push_back(q);\n    G[q].push_back(p);\n  }\n\n  vector<int> mc1 = bfs(0);\n  int pos = 0;\n  for (int i = 1; i < N; i++) {\n    if (mc1[i] > mc1[pos]) pos = i;\n  }\n  vector<int> mc2 = bfs(pos);\n  int d = 0;\n  for (int i = 0; i < N; i++) {\n    d = max(d, mc2[i]);\n  }\n  d++;\n  for (int i = 0; i < N; i++) {\n    if (G[i].size() >= 4) {\n      d += G[i].size() - 3;\n    }\n  }\n  cout << d << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n/* -------------------------------- Template -------------------------------- */\n\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <locale>\n#include <iostream>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <sstream>\n#include <string>\n#include <tuple>\n#include <unordered_map>\n#include <unordered_set>\n#include <utility>\n#include <vector>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nusing ll = long long;\nusing ld = long double;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = std::min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = std::max(a, b); }\ntemplate <typename T> int len(const T &x) { return x.size(); }\n\n// template<typename T> constexpr T inf = [](){ assert(false); };\n// template<> constexpr int inf<int> = 1e9;\n// template<> constexpr ll inf<ll> = 1e18;\n// template<> constexpr ld inf<ld> = 1e30;\n\nstruct yes_no : std::numpunct<char> {\n  string_type do_truename()  const { return \"Yes\"; }\n  string_type do_falsename() const { return \"No\"; }\n};\n\nvoid solve();\n\nint main() {\n  std::locale loc(std::locale(), new yes_no);\n  std::cout << std::boolalpha << std::setprecision(12) << std::fixed;\n  std::cout.imbue(loc);\n  solve();\n  return 0;\n}\n\nusing namespace std;\n\n/* -------------------------------- Library -------------------------------- */\n\n/* ---------------------------------- Main ---------------------------------- */\n\nvector<int> g[128000];\nbool visited[128000];\n\npair<int,int> dp(int v) {\n  visited[v] = true;\n  int path = 0, res = 0;\n  vector<int> ps;\n  for (int i: g[v]) {\n    if (visited[i]) continue;\n    int p, r;\n    tie(p, r) = dp(i);\n    chmax(path, p);\n    chmax(res, r);\n    ps.push_back(p);\n  }\n  sort(ps.rbegin(), ps.rend());\n  if (ps.size() >= 1) chmax(res, ps[0]);\n  if (ps.size() >= 2) chmax(res, ps[0] + ps[1]);\n  if (g[v].size() == 2) { path++; res++; }\n  return make_pair(path, res);\n}\n\nvoid solve() {\n  int N;\n  cin >> N;\n  REP(i,N-1) {\n    int a, b;\n    cin >> a >> b;\n    g[a-1].push_back(b-1);\n    g[b-1].push_back(a-1);\n  }\n  int res = dp(0).second;\n  REP(i,N) res += (g[i].size() == 1);\n  cout << res << endl;\n  return;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\nusing namespace std;\n\nconst int N = 100000;\nvector<int> g[N];\nint sz[N], dp[N];\n\nvoid dfs(int u, int prev) {\n        vector<int> len;\n        for (auto v : g[u]) if (prev != v) {\n                dfs(v, u);\n                len.push_back(sz[v]);\n                dp[u] = max(dp[u], dp[v]);\n                sz[u] = max(sz[u], sz[v] + (g[u].size() == 2));\n        }\n        sort(len.rbegin(), len.rend());\n        if (len.size() >= 2) dp[u] = max(dp[u], len[0] + len[1] + (g[u].size() == 2));\n}           \n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        int leaf = 0;\n        for (int i = 0; i < n; i ++) if (g[i].size() == 1) leaf ++;\n        dfs(0, -1);\n        printf(\"%d\\n\", dp[0] + leaf);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5;\n\nvector<int> g[N];\nint leaves[N];\nint dp[N];\nint ans;\n\npair<int, int> max2(pair<int, int> a, int b) {\n    if (a.first < b) {\n        swap(a.first, b);\n    }\n    if (a.second < b) {\n        swap(a.second, b);\n    }\n    return a;\n}\n\nvoid dfs(int u, int p) {\n    bool is_leaf = true;\n    for (int v : g[u]) {\n        if (v == p) {\n            continue;\n        }\n        dfs(v, u);\n        is_leaf = false;\n        leaves[u] += leaves[v];\n    }\n    if (is_leaf) {\n        leaves[u]++;\n        dp[u] = 1;\n    }\n}\n\nvoid dfs2(int u, int p) {\n    pair<int, int> take;\n    pair<int, int> not_take;\n    for (int v : g[u]) {\n        if (v == p) {\n            continue;\n        }\n        dfs2(v, u);\n        dp[u] = max(dp[u], dp[v] + leaves[u] - leaves[v]);\n        dp[u] = max(dp[u], dp[v] + 1);\n        take = max2(take, dp[v]);\n        not_take = max2(not_take, dp[v] - leaves[v]);\n    }\n    ans = max(ans, dp[u]);\n    ans = max(ans, take.first + take.second + 1);\n    ans = max(ans, not_take.first + not_take.second + leaves[0]);\n    //for (int x : g[u]) {\n    //    for (int y : g[u]) {\n    //        if (x == y) {\n    //            continue;\n    //        }\n    //        ans = max(ans, dp[x] + dp[y] + 1);\n    //        // ans = max(ans, dp[x] + dp[y] + leaves[u] - leaves[x] - leaves[y] + (leaves[0] - leaves[u]));\n    //        ans = max(ans, dp[x] + dp[y] - leaves[x] - leaves[y] + leaves[0]);\n    //    }\n    //}\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    if (n <= 2) {\n        cout << n << endl;\n        return 0;\n    }\n    for (int i = 0; i < n; i++) {\n        if (g[i].size() >= 2) {\n            dfs(i, -1);\n            dfs2(i, -1);\n            cout << ans << endl;\n            break;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing vvvint = vector<vvint>;\nusing vll = vector<ll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\n\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2> inline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n\tfor (auto &u : v) os << u << el;\n\treturn (os);\n}\n\ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n\tfor (auto &u : v) is >> u;\n\treturn (is);\n}\n\ntemplate<typename T1, typename T2>\nistream& operator >>(istream &is, pair<T1, T2> &p) {\n\treturn (is >> p.first >> p.second);\n}\n\nint main() {\n\tint N; cin >> N;\n\tvvint G(N);\t\n\tfor (int i = 0; i < N-1; i++) {\n\t\tint p, q;\n\t\tcin >> p >> q; --p, --q;\n\t\tG[p].push_back(q);\n\t\tG[q].push_back(p);\n\t}\n\t\n\tint maxd = 0;\n\tfunction<int(int, int)> dfs = [&](int u, int prev) {\n\t\tint ret = (int)(G[u].size() == 2);\n\t\tvint dat;\n\t\tfor (auto &v : G[u]) {\n\t\t\tif (v != prev) dat.push_back(dfs(v, u));\n\t\t}\n\n\t\tsort(begin(dat), end(dat), greater<>());\n\t\tint maxv = 0;\n\t\tif (dat.size() >= 1) {\n\t\t\tmaxv = dat[0];\n\t\t\tif (dat.size() >= 2) chmax(maxd, dat[0] + dat[1]);\n\t\t}\n\t\tchmax(maxd, ret + maxv);\n\t\treturn (ret + maxv);\n\t};\n\n\tint cnt = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (G[i].size() == 1) cnt++;\n\t}\n\tdfs(0, -1);\n\tcout << cnt + maxd << endl;\n\treturn (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nvector<pair<int, int>>X[1 << 17], Y[1 << 17]; int dist[1 << 17], N, A, B, C, root; queue<int>Q;\nint main() {\n    cin >> N;\n    for (int i = 0; i < N - 1; i++) { cin >> A >> B; A--; B--; C=1; X[A].push_back(make_pair(B, C)); Y[B].push_back(make_pair(A, C)); }\n    for (int i = 0; i < N; i++) { if (Y[i].size() == 0) { root = i; } }\n    for (int i = 0; i < N; i++) { dist[i] = 1145141919; }Q.push(root); dist[root] = 0;\n    while (!Q.empty()) {\n        int a1 = Q.front(); Q.pop();\n        for (int i = 0; i < X[a1].size(); i++) {\n            int to = X[a1][i].first, a2 = X[a1][i].second;\n            if (dist[to] == 1145141919) { dist[to] = dist[a1] + a2; Q.push(to); }\n        }\n    }\n    int maxn = 0, maxid = 0;\n    for (int i = 0; i < N; i++) { if (maxn < dist[i]) { maxn = dist[i]; maxid = i; } }Q.push(maxid);\n    for (int i = 0; i < N; i++) { dist[i] = 1145141919; }dist[maxid] = 0;\n    while (!Q.empty()) {\n        int a1 = Q.front(); Q.pop(); maxn = 0; maxid = 0;\n        for (int i = 0; i < X[a1].size(); i++) {\n            int to = X[a1][i].first, a2 = X[a1][i].second;\n            if (dist[to] > dist[a1] + a2) { dist[to] = dist[a1] + a2; Q.push(to); }\n        }\n        for (int i = 0; i < Y[a1].size(); i++) {\n            int to = Y[a1][i].first, a2 = Y[a1][i].second;\n            if (dist[to] > dist[a1] + a2) { dist[to] = dist[a1] + a2; Q.push(to); }\n        }\n    }\n    for (int i = 0; i < N; i++) { if (maxn < dist[i]) { maxn = dist[i]; maxid = i; } }\n    cout << maxn+1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (l);i < (r);i++)\n#define ALL(x) (x).begin(),(x).end()\ntemplate<typename T> bool chmax(T& a,const T& b){return a < b ? (a = b,true) : false;}\ntemplate<typename T> bool chmin(T& a,const T& b){return b < a ? (a = b,true) : false;}\ntypedef long long ll;\n\nint N;\nlist<int> edge [100001];\nint leaf [100001];\nconst int INF = 1e9;\n\nint cnt_leaf(int curr,int prev)\n{\n\tint res = 0;\n\tfor(auto it : edge [curr]) if(it != prev){\n\t\tres += cnt_leaf(it,curr);\n\t}\n\treturn leaf [curr] = max(1,res);\n}\n\nint dfs(int curr,int prev)\n{\n\tint res = 1,leaf_sum = 0;\n\tfor(auto it : edge [curr]) if(it != prev){\n\t\tleaf_sum += leaf [it];\n\t}\n\tfor(auto it : edge [curr]) if(it != prev){\n\t\tint tmp = dfs(it,curr);\n\t\tchmax(res,tmp + leaf_sum - leaf [it]);\n\t\tchmax(res,tmp + 1);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tFOR(i,0,N - 1){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge [u].push_back(v);\n\t\tedge [v].push_back(u);\n\t}\n\n\tfor(int i = 1;i <= N - 1;i++){\n\t\tif(edge [i].size() == 1){\n\t\t\tcnt_leaf(i,-1);\n\t\t\tprintf(\"%d\\n\",dfs(i,-1));\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (l);i < (r);i++)\n#define ALL(x) (x).begin(),(x).end()\ntemplate<typename T> bool chmax(T& a,const T& b){return a < b ? (a = b,true) : false;}\ntemplate<typename T> bool chmin(T& a,const T& b){return b < a ? (a = b,true) : false;}\ntypedef long long ll;\n\nint N;\nlist<int> edge [100001];\nint leaf [100001];\nconst int INF = 1e9;\n\nint cnt_leaf(int curr,int prev)\n{\n\tint res = 0;\n\tfor(auto it : edge [curr]) if(it != prev){\n\t\tres += cnt_leaf(it,curr);\n\t}\n\treturn leaf [curr] = max(1,res);\n}\n\nint dfs(int curr,int prev,int& ans)\n{\n\tint res = 1;\n\tpriority_queue<int> pq;\n\tfor(auto it : edge [curr]) if(it != prev){\n\t\tint tmp = dfs(it,curr,ans);\n\t\tpq.push(tmp);\n\t\tchmax(res,tmp + leaf [curr] - leaf [it]);\n\t\tchmax(res,tmp + 1);\n\t}\n\tint sum = 0;\n\tfor(int i = 0;i < 2 && pq.empty() == false;i++){\n\t\tsum += pq.top();\n\t\tpq.pop();\n\t}\n\tchmax(ans,res);\n\tchmax(ans,sum + leaf [1] - leaf [curr] + 1);\n\n\treturn res;\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tFOR(i,0,N - 1){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge [u].push_back(v);\n\t\tedge [v].push_back(u);\n\t}\n\n\tint ans = 0;\n\tcnt_leaf(1,-1);\n\tdfs(1,-1,ans);\n\tprintf(\"%d\\n\",ans);\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint cnt;\nint ma;\nint dp[100010];\nvi g[100010];\n\nvoid dfs(int v, int p)\n{\n\tfor (int to:g[v]) {\n\t\tif (to != p) {\n\t\t\tdfs(to, v);\n\t\t\tdp[v] = max(dp[v], dp[to]);\n\t\t}\n\t}\n\n\tif (g[v].size() == 2) {\n\t\tif (p != -1) {\n\t\t\tdp[v] = max(dp[v], dp[g[v][0]] + 1);\n\t\t} else {\n\t\t\tdp[v] = max(dp[v], dp[g[v][0]] + dp[g[v][1]] + 1);\n\t\t}\n\t}\n\n\tma = max(ma, dp[v]);\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\n\trep(i,N-1) {\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\n\trep(i, N) {\n\t\tif (g[i].size() == 1) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\n\tdfs(0, -1);\n\n\tcout << cnt + ma << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <functional>\nusing namespace std;\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> g(n);\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        int leaf = 0;\n        for (int i = 0; i < n; i ++) if (g[i].size() == 1) leaf ++;\n        vector<int> dp(n), dp2(n);\n        function<void (int, int)> dfs = [&](int u, int prev) {\n                vector<int> len;\n                for (auto v : g[u]) if (v != prev) {\n                        dfs(v, u);\n                        len.push_back(dp2[v]);\n                        dp[u] = max(dp[u], dp[v] + (g[u].size() == 2));\n                        dp2[u] = max(dp2[u], dp2[v] + (g[u].size() == 2));\n                }\n                sort(len.begin(), len.end());\n                if (len.size() >= 2) dp[u] = max(dp[u], len[0] + len[1] + (g[u].size() == 2));\n        };\n        dfs(0, -1);\n        printf(\"%d\\n\", dp[0] + leaf);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint cnt;\nint ma;\nint dp[100010];\nvi g[100010];\nvi g2[100010];\n\nvoid dfs(int v, int p)\n{\n\tmultiset<int> st;\n\tfor (int to : g[v]) {\n\t\tif (to != p) {\n\t\t\tdfs(to, v);\n\t\t\tdp[v] = max(dp[v], dp[to]);\n\t\t\tg2[v].pb(to);\n\t\t\tst.insert(dp[v]);\n\t\t\tif (st.size() > 2) st.erase(st.begin());\n\t\t}\n\t}\n\n\tif (st.size() == 2) {\n\t\tauto it = st.begin();\n\t\tauto it2 = it;\n\t\t++it2;\n\t\tma = max(ma, *it + *it2);\n\t}\n\n\tif (g[v].size() == 2) {\n\t\tif (p != -1) {\n\t\t\tdp[v] = max(dp[v], dp[g2[v][0]] + 1);\n\t\t} else {\n\t\t\tma = max(ma, dp[g2[v][0]] + dp[g2[v][1]] + 1);\n\t\t}\n\t}\n\n\tma = max(ma, dp[v]);\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\n\trep(i,N-1) {\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\n\trep(i, N) {\n\t\tif (g[i].size() == 1) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\n\tdfs(0, -1);\n\n\tcout << cnt + ma << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nint n, r, l;\nvector<int> g[100010];\nint lc[100010];\nint mx[100010];\nint mx2[100010];\nvoid dfs(int x, int p){\n\tif(g[x].size()==1) lc[x]=1;\n\tmx2[x]=-1e9;\n\tfor(auto y:g[x]){\n\t\tif(y==p) continue;\n\t\tdfs(y, x);\n\t\tlc[x]+=lc[y];\n\t\tmx[x]=max(mx[x], mx[y]+1);\n\t\tmx2[x]=max(mx2[x], mx2[y]);\n\t}\n\tmx2[x]=max(mx2[x], mx[x]-lc[x]+1);\n}\nint ans;\nvoid dfs2(int x, int p){\n\tvector<int> v;\n\tfor(auto y:g[x]){\n\t\tif(y==p) continue;\n\t\tv.push_back(mx2[y]);\n\t}\n\tsort(v.begin(), v.end(), greater<int>());\n\tif(v.size()>=2) ans=max(ans, v[0]+v[1]+l);\n\tfor(auto y:g[x]){\n\t\tif(y==p) continue;\n\t\tdfs2(y, x);\n\t}\n}\nint mx3[100010];\nvoid dfs3(int x, int p){\n\tint m[2];\n\tm[0]=m[1]=-1e9;\n\tfor(auto y:g[x]){\n\t\tif(y==p) continue;\n\t\tif(m[0]<=mx[y]){\n\t\t\tm[1]=m[0], m[0]=mx[y];\n\t\t}else if(m[1]<=mx[y]){\n\t\t\tm[1]=mx[y];\n\t\t}\n\t}\n\tfor(auto y:g[x]){\n\t\tif(y==p) continue;\n\t\tint m1;\n\t\tif(mx[y]==m[0]) m1=m[1];\n\t\telse m1=m[0];\n\t\tmx3[y]=max(2+m1, 1+mx3[x]);\n\t\tans=max(ans, mx3[y]+mx2[y]+lc[y]);\n\t}\n\tfor(auto y:g[x]){\n\t\tif(y==p) continue;\n\t\tdfs3(y, x);\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=0; i<n-1; i++){\n\t\tint a, b;\n\t\tcin>>a>>b;\n\t\ta--; b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tif(n==2){\n\t\tcout<<2<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tif(g[i].size()>1){\n\t\t\tr=i;\n\t\t}else{\n\t\t\tl++;\n\t\t}\n\t}\n\tdfs(r, -1);\n\tdfs2(r, -1);\n\tdfs3(r, -1);\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<bitset>\n#define pb push_back\nusing namespace std;\n\nint N, a, b, endp, maxx;\nbitset<100003> vis;\nvector<int> v[100003];\n\nint dfs(int now = 0) {\n\tvis[now] = 1;\n\tif(v[now].size() == 1) ++endp;\n\tvector<int> w = {0, 0};\n\tfor(unsigned i = 0; i < v[now].size(); ++i) if(!vis[v[now][i]])\n\t\tw.pb(dfs(v[now][i]));\n\tsort(w.rbegin(), w.rend()); // 降序排序 \n\tmaxx = max(maxx, (v[now].size() == 2) + w[0] + w[1]);\n\treturn (v[now].size() == 2) + w[0];\n}\n\nint main() {\n\tios::sync_with_stdio(0);\n\tcin.tie(0), cout.tie(0);\n\tcin >> N;\n\twhile(--N) {\n\t\tcin >> a >> b;\n\t\tv[--a].pb(--b);\n\t\tv[b].pb(a);\n\t}\n\tdfs();\n\tcout << maxx + endp << '\\n';\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5;\n\nvector<int> g[N];\nint leaves[N];\nint dp[N];\nint ans;\n\npair<int, int> max2(pair<int, int> a, int b) {\n    if (a.first < b) {\n        swap(a.first, b);\n    }\n    if (a.second < b) {\n        swap(a.second, b);\n    }\n    return a;\n}\n\nvoid dfs(int u, int p) {\n    bool is_leaf = true;\n    for (int v : g[u]) {\n        if (v == p) {\n            continue;\n        }\n        dfs(v, u);\n        is_leaf = false;\n        leaves[u] += leaves[v];\n    }\n    if (is_leaf) {\n        leaves[u]++;\n        dp[u] = 1;\n    }\n}\n\nvoid dfs2(int u, int p) {\n    pair<int, int> take;\n    pair<int, int> not_take;\n    for (int v : g[u]) {\n        if (v == p) {\n            continue;\n        }\n        dfs2(v, u);\n        dp[u] = max(dp[u], dp[v] + leaves[u] - leaves[v]);\n        dp[u] = max(dp[u], dp[v] + 1);\n        take = max2(take, dp[v]);\n        not_take = max2(not_take, dp[v] - leaves[v]);\n    }\n    ans = max(ans, dp[u]);\n    ans = max(ans, take.first + take.second + 1);\n    ans = max(ans, not_take.first + not_take.second + leaves[0]);\n    //for (int x : g[u]) {\n    //    for (int y : g[u]) {\n    //        if (x == y) {\n    //            continue;\n    //        }\n    //        ans = max(ans, dp[x] + dp[y] + 1);\n    //        // ans = max(ans, dp[x] + dp[y] + leaves[u] - leaves[x] - leaves[y] + (leaves[0] - leaves[u]));\n    //        ans = max(ans, dp[x] + dp[y] - leaves[x] - leaves[y] + leaves[0]);\n    //    }\n    //}\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    dfs(0, -1);\n    dfs2(0, -1);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define FOR(i,l,r) for(int i = (l);i < (r);i++)\n#define ALL(x) (x).begin(),(x).end()\ntemplate<typename T> bool chmax(T& a,const T& b){return a < b ? (a = b,true) : false;}\ntemplate<typename T> bool chmin(T& a,const T& b){return b < a ? (a = b,true) : false;}\ntypedef long long ll;\n\nint N;\nlist<int> edge [100001];\nconst int INF = 1e9;\n\nvoid dfs(int curr,int cost,vector<int>& min_cost)\n{\n\tif(min_cost [curr] <= cost) return;\n\tmin_cost [curr] = cost;\n\tfor(auto&& it : edge [curr]){\n\t\tdfs(it,cost + 1,min_cost);\n\t}\n}\n\nint dfs2(int curr,int prev)\n{\n\tint res = 0;\n\tfor(auto&& it : edge [curr]) if(it != prev){\n\t\tchmax(res,dfs2(it,curr));\n\t}\n\treturn res + max(1,(int) edge [curr].size() - 2);\n}\n\nint main()\n{\n\tscanf(\"%d\",&N);\n\tFOR(i,0,N - 1){\n\t\tint u,v;\n\t\tscanf(\"%d%d\",&u,&v);\n\t\tedge [u].push_back(v);\n\t\tedge [v].push_back(u);\n\t}\n\n\tint node = 1;\n\tvector<int> min_cost(N + 1,INF);\n\tdfs(node,0,min_cost);\n\tnode = max_element(min_cost.begin() + 1,min_cost.end()) - min_cost.begin();\n\n\tprintf(\"%d\\n\",dfs2(node,-1));\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nvector<vector<int> > edges;\n\nint solve(int curr, int prev, int& ans)\n{\n    vector<int> v(2, 0);\n    for(int next : edges[curr]){\n        if(next != prev)\n            v.push_back(solve(next, curr, ans));\n    }\n    sort(v.rbegin(), v.rend());\n    \n    int cnt = v[0] + v[1];\n    if(edges[curr].size() == 2){\n        ++ cnt;\n        ans = max(ans, cnt);\n        return v[0] + 1;\n    }\n    else{\n        ans = max(ans, cnt);\n        return v[0];\n    }\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    edges.assign(n, vector<int>());\n    for(int i=0; i<n-1; ++i){\n        int p, q;\n        cin >> p >> q;\n        -- p;\n        -- q;\n        edges[p].push_back(q);\n        edges[q].push_back(p);\n    }\n\n    int leaf = 0;\n    for(int i=0; i<n; ++i){\n        if(edges[i].size() == 1)\n            ++ leaf;\n    }\n\n    int ans = 0;\n    solve(0, -1, ans);\n    ans += leaf;\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#include <time.h>\n#include <stack>\n#include <array>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nint n, r, l;\nvector<int> g[100010];\nint lc[100010];\nint mx[100010];\nint mx2[100010];\nvoid dfs(int x, int p){\n\tif(g[x].size()==1) lc[x]=1;\n\tmx2[x]=-1e9;\n\tfor(auto y:g[x]){\n\t\tif(y==p) continue;\n\t\tdfs(y, x);\n\t\tlc[x]+=lc[y];\n\t\tmx[x]=max(mx[x], mx[y]+1);\n\t\tmx2[x]=max(mx2[x], mx2[y]);\n\t}\n\tmx2[x]=max(mx2[x], mx[x]-lc[x]+1);\n}\nint ans;\nvoid dfs2(int x, int p){\n\tvector<int> v;\n\tfor(auto y:g[x]){\n\t\tif(y==p) continue;\n\t\tv.push_back(mx2[y]+lc[y]);\n\t}\n\tsort(v.begin(), v.end(), greater<int>());\n\tif(v.size()>=2) ans=max(ans, v[0]+v[1]+l-lc[x]);\n\tfor(auto y:g[x]){\n\t\tif(y==p) continue;\n\t\tdfs2(y, x);\n\t}\n}\nint mx3[100010];\nvoid dfs3(int x, int p){\n\tint m[2];\n\tm[0]=m[1]=-1e9;\n\tfor(auto y:g[x]){\n\t\tif(y==p) continue;\n\t\tif(m[0]<=mx[y]){\n\t\t\tm[1]=m[0], m[0]=mx[y];\n\t\t}else if(m[1]<=mx[y]){\n\t\t\tm[1]=mx[y];\n\t\t}\n\t}\n\tfor(auto y:g[x]){\n\t\tif(y==p) continue;\n\t\tint m1;\n\t\tif(mx[y]==m[0]) m1=m[1];\n\t\telse m1=m[0];\n\t\tmx3[y]=max(2+m1, 1+mx3[x]);\n\t\tans=max(ans, mx3[y]+mx2[y]+lc[y]);\n\t}\n\tfor(auto y:g[x]){\n\t\tif(y==p) continue;\n\t\tdfs3(y, x);\n\t}\n}\nint main()\n{\n\tcin>>n;\n\tfor(int i=0; i<n-1; i++){\n\t\tint a, b;\n\t\tcin>>a>>b;\n\t\ta--; b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tif(n==2){\n\t\tcout<<2<<endl;\n\t\treturn 0;\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tif(g[i].size()>1){\n\t\t\tr=i;\n\t\t}else{\n\t\t\tl++;\n\t\t}\n\t}\n\tdfs(r, -1);\n\tdfs2(r, -1);\n\tdfs3(r, -1);\n  /*cout<<r<<endl;\n  for(int i=0; i<n; i++){\n    cout<<lc[i]<<\" \"<<mx3[i]<<endl;\n  }*/\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }\n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n;\n  cin>>n;\n\n  vector< vector<int> > G(n);\n  for(int i=1;i<n;i++){\n    int p,q;\n    cin>>p>>q;\n    p--;q--;\n    G[p].emplace_back(q);\n    G[q].emplace_back(p);\n  }\n\n  vector<int> dp1(n,0),dp2(n,0);\n  int ans=0;\n  MFP([&](auto dfs,int v,int p)->void{\n        int sum=0;\n        vector<int> vs,mx;\n        for(int u:G[v]){\n          if(u==p) continue;\n          dfs(u,v);\n          sum+=dp2[u];\n          mx.emplace_back(dp1[u]);\n          vs.emplace_back(dp1[u]-dp2[u]);\n        }\n        if(vs.empty()){\n          dp1[v]=1;\n          dp2[v]=1;\n          return;\n        }\n        while(vs.size()<2) vs.emplace_back(0);\n        while(mx.size()<2) mx.emplace_back(0);\n        sort(vs.rbegin(),vs.rend());\n        sort(mx.rbegin(),mx.rend());\n\n        // c1 -> v -> c2, take v\n        chmax(ans,mx[0]+1+mx[1]);\n\n        // c1 -> v -> c2, not take v\n        chmax(ans,sum+vs[0]+vs[1]);\n\n        // c1 -> v, take v\n        chmax(dp1[v],mx[0]+1);\n\n        // c1 -> v, not take v\n        chmax(dp1[v],sum+vs[0]);\n\n        // not take v\n        chmax(dp2[v],sum);\n\n        assert(dp1[v]>=dp2[v]);\n        // cout<<v<<\", dp1[v] = \"<<dp1[v]<<\", dp2[v] = \"<<dp2[v]<<endl;\n      })(0,-1);\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#define repeat(i,n) for (int i = 0; (i) < (n); ++(i))\nusing namespace std;\ntemplate <class T> void setmax(T & a, T const & b) { if (a < b) a = b; }\nint main() {\n    // input\n    int n; cin >> n;\n    vector<vector<int> > g(n);\n    repeat (i,n-1) {\n        int p, q; cin >> p >> q; -- p; -- q;\n        g[p].push_back(q);\n        g[q].push_back(p);\n    }\n    // compute\n    int total_leaves = 0;\n    repeat (i,n) if (g[i].size() == 1) total_leaves += 1;\n    int ans = 0;\n    vector<int> middle(n), terminal(n); // dp on tree\n    function<void (int, int)> go = [&](int i, int parent) {\n        // prepare\n        int sum_middle = 0;\n        vector<int> terminals;\n        vector<int> diff;\n        for (int j : g[i]) if (j != parent) {\n            go(j, i);\n            sum_middle += middle[j];\n            terminals.push_back(terminal[j]);\n            diff.push_back(terminal[j] - middle[j]);\n        }\n        diff.push_back(0);\n        diff.push_back(0);\n        sort(diff.rbegin(), diff.rend());\n        terminals.push_back(0);\n        terminals.push_back(0);\n        sort(terminals.rbegin(), terminals.rend());\n        // result\n        middle[i] = max(1, sum_middle);\n        terminal[i] = max(1 + terminals[0], sum_middle + diff[0]);\n        setmax(ans, 1 + terminals[0] + terminals[1]);\n        setmax(ans, total_leaves + diff[0] + diff[1]);\n    };\n    go(0, -1);\n    // output\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n\nvector<int> G[100010];\nint N,A;\n\nint dfs(int x, int l)\n{\n\tint r = 0, a = 1, s = 0;\n\tfor (int y : G[x]) if (y != l){\n\t\tint c = dfs(y,x);\n\t\tif (A < a + c)\n\t\t\tA = a + c;\n\t\tif (a < c + 1)\n\t\t\ta = c + 1;\n\t\ts += c;\n\t}\n\tif (r < a) r = a;\n\tif (r < s) r = s;\n\tif (A < r) A = r;\n\treturn r;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tfor (int i=1;i<N;i++){\n\t\tint x,y; scanf (\"%d %d\",&x,&y);\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\t\n\tdfs(1,0);\n\tprintf (\"%d\\n\",A);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint main() {\n    int N; cin >> N;\n    vector<vector<int>> G(N);\n    for (int i = 0; i < N - 1; i++) {\n        int p, q; cin >> p >> q; p--, q--;\n        G[p].push_back(q);\n        G[q].push_back(p);\n    }\n    vector<int> type(N), weight(N, 2);\n    for (int i = 0; i < N; i++) if (G[i].size() >= 3) {\n        type[i] = 1;\n        weight[i] = 0;\n    }\n    for (int i = 0; i < N; i++) if (type[i] == 0) {\n        int cnt = 0;\n        for (int n : G[i]) if (type[n] == 1) cnt++;\n        if (cnt != 0) weight[i] = 0;\n        for (int n : G[i]) if (type[n] == 1) weight[n] += (cnt == 1 ? 2 : 1);\n    }\n    vector<vector<int>> G2(N);\n    auto recur = [&](auto&& recur, int node, int base) {\n        if (weight[node] == 0) return;\n        if (node != base) {\n            weight[base] += weight[node];\n            weight[node] = 0;\n        }\n        for (int n : G[node]) if (type[n] == 0) {\n            G2[base].push_back(n);\n            G2[n].push_back(base);\n        }\n        for (auto n : G[node]) {\n            if (type[n] == 1 && n != base) {\n                recur(recur, n, base);\n            }\n        }\n    };\n    for (int i = 0; i < N; i++) {\n        if (type[i] == 1) {\n            recur(recur, i, i);\n        } else {\n            for (auto n : G[i]) {\n                if (type[n] == 0) {\n                    G2[i].push_back(n);\n                }\n            }\n        }\n    }\n    auto far = [&](int root) {\n        vector<int> score(G2.size(), -1);\n        stack<tuple<int, int>> S;\n        S.emplace(root, 0);\n        while (!S.empty()) {\n            auto [node, sc] = S.top(); S.pop();\n            if (score[node] >= 0) continue;\n            score[node] = sc + weight[node];\n            for (int next : G2[node]) {\n                S.emplace(next, score[node]);\n            }\n        }\n        auto it = max_element(begin(score), end(score));\n        return make_pair(it - begin(score), *it);\n    };\n    auto p1 = far(max_element(begin(weight), end(weight)) - begin(weight));\n    auto p2 = far(p1.first);\n    cout << p2.second / 2 << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint N,ans;\nvector<int>G[1<<17];\nint dp[1<<17],cr[1<<17];\nint dfs1(int u,int p)\n{\n\tint mt=0;\n\tint get=0;\n\tif(G[u].size()==1&&G[u][0]==p)cr[u]=1;\n\telse cr[u]=0;\n\tfor(int v:G[u])if(v!=p)\n\t{\n\t\tint t=dfs1(v,u);\n\t\tcr[u]+=cr[v];\n\t\tif(mt<t-cr[v])mt=t-cr[v];\n\t\tif(get<t+1)get=t+1;\n\t}\n\tdp[u]=max(cr[u]+mt,get);\n\treturn dp[u];\n}\nvoid dfs2(int u,int p,int pcr,int pt)\n{\n\tint sr=cr[u]+pcr;\n\tint mt=pt-pcr;\n\tif(mt<0)mt=0;\n\tint m1t=mt,m2t=0;\n\tint g1=pt+1,g2=0;\n\tfor(int v:G[u])if(v!=p)\n\t{\n\t\tint t=dp[v]-cr[v];\n\t\tif(mt<t)mt=t;\n\t\tif(m1t<t)\n\t\t{\n\t\t\tm2t=m1t;\n\t\t\tm1t=t;\n\t\t}\n\t\telse if(m2t<t)m2t=t;\n\t\tif(g1<dp[v]+1)\n\t\t{\n\t\t\tg2=g1;\n\t\t\tg1=dp[v]+1;\n\t\t}\n\t\telse if(g2<dp[v]+1)g2=dp[v]+1;\n\t}\n\tans=max(ans,sr+mt);\n\tfor(int v:G[u])if(v!=p)\n\t{\n\t\tint t=dp[v]-cr[v];\n\t\tdfs2(v,u,sr-cr[v],max(max((t==m1t?m2t:m1t)+sr-cr[v],dp[v]+1==g1?g2:g1),sr-cr[v]));\n\t}\n}\nmain()\n{\n\tcin>>N;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint u,v;cin>>u>>v;u--,v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tint root=0;\n\twhile(root<N&&G[root].size()<=2)root++;\n\tif(root==N)\n\t{\n\t\tcout<<N<<endl;\n\t\treturn 0;\n\t}\n\tdfs1(root,-1);\n\tdfs2(root,-1,0,0);\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint N,ans;\nvector<int>G[1<<17];\nint dfs(int u,int p)\n{\n\tint m1=0,m2=0;\n\tfor(int v:G[u])if(v!=p)\n\t{\n\t\tint t=dfs(v,u);\n\t\tif(m1<t)\n\t\t{\n\t\t\tm2=m1;\n\t\t\tm1=t;\n\t\t}\n\t\telse if(m2<t)m2=t;\n\t}\n\tint now=(int)G[u].size()-2;\n\tif(now<1)now=1;\n\tans=max(ans,m1+m2+now);\n\treturn m1+now;\n}\nmain()\n{\n\tcin>>N;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint u,v;cin>>u>>v;u--,v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tdfs(0,-1);\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nvector<pair<int, int>>X[1 << 17], Y[1 << 17]; int dist[1 << 17], N, A, B, C, root; queue<int>Q;\nint main() {\n    cin >> N;\n    for (int i = 0; i < N - 1; i++) { cin >> A >> B;A--;B--;C=1; X[A].push_back(make_pair(B, C)); Y[B].push_back(make_pair(A, C)); }\n    for (int i = 0; i < N; i++) { if (Y[i].size() == 0) { root = i; } }\n    for (int i = 0; i < N; i++) { dist[i] = 1145141919; }Q.push(root); dist[root] = 0;\n    while (!Q.empty()) {\n        int a1 = Q.front(); Q.pop();\n        for (int i = 0; i < X[a1].size(); i++) {\n            int to = X[a1][i].first, a2 = X[a1][i].second;\n            if (dist[to] == 1145141919) { dist[to] = dist[a1] + a2; Q.push(to); }\n        }\n    }\n    int maxn = 0, maxid = 0;\n    for (int i = 0; i < N; i++) { if (maxn < dist[i]) { maxn = dist[i]; maxid = i; } }Q.push(maxid);\n    for (int i = 0; i < N; i++) { dist[i] = 1145141919; }dist[maxid] = 0;\n    while (!Q.empty()) {\n        int a1 = Q.front(); Q.pop(); maxn = 0; maxid = 0;\n        for (int i = 0; i < X[a1].size(); i++) {\n            int to = X[a1][i].first, a2 = X[a1][i].second;\n            if (dist[to] > dist[a1] + a2) { dist[to] = dist[a1] + a2; Q.push(to); }\n        }\n        for (int i = 0; i < Y[a1].size(); i++) {\n            int to = Y[a1][i].first, a2 = Y[a1][i].second;\n            if (dist[to] > dist[a1] + a2) { dist[to] = dist[a1] + a2; Q.push(to); }\n        }\n    }\n    for (int i = 0; i < N; i++) { if (maxn < dist[i]) { maxn = dist[i]; maxid = i; } }\n    cout << maxn << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n#define repv(t,it,v) for(vector<t>::iterator it = v.begin() ; it != v.end() ; ++it)\n\nint N;\nvector<int> V[100010];\nint ans = 0;\n\nint dfs(int p , int q){\n\tint a = 0;\n\tint b = 0;\n\trepv(int,it,V[q]){\n\t\tif(p == (*it)) continue;\n\t\tint x = dfs(q,(*it));\n\t\tif(x > a){\n\t\t\tb = a;\n\t\t\ta = x;\n\t\t} else if(x > b){\n\t\t\tb = x;\n\t\t}\n\t}\n\tans = max(ans , a + b + ((int)V[q].size() == 2 ? 1 : 0));\n\treturn a + ((int)V[q].size() == 2 ? 1 : 0);\n}\n\nint main(){\n\tscanf(\"%d\" , &N);\n\trepp(i,1,N){\n\t\tint a,b;\n\t\tscanf(\"%d%d\" , &a , &b);\n\t\tV[a].PB(b);\n\t\tV[b].PB(a);\n\t}\n\tint z = 0;\n\trepp(i,1,N+1){\n\t\tif((int)V[i].size() == 1) ++z;\n\t}\n\tdfs(-1,1);\n\tprintf(\"%d\\n\" , ans + z);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 100002\n\nint n;\n\nvector<int> v[MAX];\n\nint dp[MAX];\n\nint ans;\nint ans2;\n\nint leaf[MAX];\n\ninline void dfs(int b,int pr){\n\tvector<int> ret;\n\tvector<int> ret2;\n\tleaf[b]=(v[b].size()==1);\n\tfor(int go:v[b]){\n\t\tif(go==pr)continue;\n\t\tdfs(go,b);\n\t\tleaf[b]+=leaf[go];\n\t\tret.push_back(dp[go]);\n\t\tret2.push_back(dp[go]+leaf[go]);\n\t}\n\tsort(ret.begin(),ret.end(),greater<int>());\n\tsort(ret2.begin(),ret2.end(),greater<int>());\n\tdp[b]=(v[b].size()>=2);\n\tif(ret.size()>=2){\n\t\tans=max(ans,1+ret2[0]+ret2[1]-ans2);\n\t}\n\tif(ret.size()>=1){\n\t\tans=max(ans,1+ret2[0]-ans2);\n\t}\n\tif(ret.size())dp[b]=max(dp[b],(v[b].size()==2)+ret[0]);\n\tans=max(ans,dp[b]);\n}\n\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tans2=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(v[i].size()==1){\n\t\t\tans2++;\n\t\t}\n\t}\n\tdfs(0,-1);\n\tcout<<ans+ans2<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <functional>\nusing namespace std;\n\nint main() {\n        int n;\n        scanf(\"%d\", &n);\n        vector<vector<int>> g(n);\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                scanf(\"%d%d\", &a, &b);\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        int leaf = 0;\n        for (int i = 0; i < n; i ++) if (g[i].size() == 1) leaf ++;\n        vector<int> dp(n), dp2(n);\n        function<void (int, int)> dfs = [&](int u, int prev) {\n                vector<int> len;\n                for (auto v : g[u]) if (v != prev) {\n                        dfs(v, u);\n                        len.push_back(dp2[v]);\n                        dp[u] = max(dp[u], dp[v] + (g[u].size() == 2));\n                        dp2[u] = max(dp2[u], dp2[v] + (g[u].size() == 2));\n                }\n                sort(len.begin(), len.end());\n                if (len.size() >= 2) dp[u] = max(dp[u], len[0] + len[1] + (g[u].size() == 2));\n        };\n        dfs(0, -1);\n        for (int i = 0; i < dp.size(); i ++) printf(\"dp[%d] = %d\\n\", i, dp[i]);\n        printf(\"%d\\n\", dp[0] + leaf);\n        return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing vvvint = vector<vvint>;\nusing vll = vector<ll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\n\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2> inline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n\tfor (auto &u : v) os << u << el;\n\treturn (os);\n}\n\ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n\tfor (auto &u : v) is >> u;\n\treturn (is);\n}\n\ntemplate<typename T1, typename T2>\nistream& operator >>(istream &is, pair<T1, T2> &p) {\n\treturn (is >> p.first >> p.second);\n}\n\nint main() {\n\tint N; cin >> N;\n\tvvint G(N);\t\n\tfor (int i = 0; i < N-1; i++) {\n\t\tint p, q;\n\t\tcin >> p >> q; --p, --q;\n\t\tG[p].push_back(q);\n\t\tG[q].push_back(p);\n\t}\n\t\n\tfunction<int(int, int)> dfs = [&](int u, int prev) {\n\t\tint ret = (int)(G[u].size() == 2);\n\t\tint maxv = 0;\n\t\tfor (auto &v : G[u]) {\n\t\t\tif (v != prev) chmax(maxv, dfs(v, u));\n\t\t}\n\t\treturn (ret + maxv);\n\t};\n\n\tint cnt = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (G[i].size() == 1) {\n\t\t\tif (cnt == 0) {\n\t\t\t\tcnt += dfs(i, -1);\t\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t}\n\tcout << cnt << endl;\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 16.12.2019 13:30:15       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<int>> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  vector<int> order(n);\n  iota(order.begin(), order.end(), 0);\n  sort(order.begin(), order.end(), [&](int i, int j) {\n    return g[i].size() > g[j].size();\n  });\n  int ans = 0;\n  for (int it = 0; it < n && it * n < 1e7; it++) {\n    int root = order[it];\n    function<pair<int, int>(int, int)> Dfs = [&](int v, int pr) {\n      int one = 1;\n      int two = 0;\n      int profit = 0;\n      for (int u : g[v]) {\n        if (u == pr) {\n          continue;\n        }\n        auto res = Dfs(u, v);\n        one = max(one, 1 + res.first);\n        two += res.second;\n        profit = max(profit, res.first - res.second);\n      }\n      one = max(one, two + profit);\n      two = max(two, 1);\n      ans = max(ans, one);\n      return make_pair(one, two);\n    };\n    Dfs(root, -1);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\nmain()\n{\n\tint N;\n\tcin>>N;\n\tvector<vector<int> >G(N);\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint a,b;cin>>a>>b;\n\t\ta--,b--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tint ans=0;\n\tfor(int i=0;i<N;i++)ans+=G[i].size()<=2;\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 100002\n\nint n;\n\nvector<int> v[MAX];\n\nint dp[MAX];\n\nint ans;\nint ans2;\n\nint leaf[MAX];\n\nint cer;\n\n\ninline void dfs(int b,int pr){\n\tvector<int> ret;\n\tvector<int> ret2;\n\tfor(int go:v[b]){\n\t\tif(go==pr)continue;\n\t\tdfs(go,b);\n\t\tleaf[b]+=leaf[go];\n\t\tret.push_back(dp[go]);\n\t\tret2.push_back(dp[go]+leaf[go]);\n\t}\n\tleaf[b]+=(v[b].size()==1);\n\tsort(ret.begin(),ret.end(),greater<int>());\n\twhile(ret.size()<=2)ret.push_back(0);\n\tdp[b]=max(dp[b],(v[b].size()==2)+ret[0]+ret[1]);\n\treturn;\n}\n\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tdfs(0,-1);\n\tcout<<dp[0]+leaf[0]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nvector<int> v[100000];\nbool used[100000];\nint endpoint = 0;\nint maxx = 0;\n \nint dfs(int cur) {\n    used[cur] = true;\n    if (v[cur].size() == 1) endpoint++;\n    vector<int> w;\n    w.push_back(0);\n    w.push_back(0);\n    for (int i = 0; i < v[cur].size(); i++) {\n        if (!used[v[cur][i]]) {\n            int to = v[cur][i];\n            w.push_back(dfs(to));\n        }\n    }\n    sort(w.rbegin(), w.rend());\n    maxx = max(maxx, (v[cur].size() == 2) + w[0] + w[1]);\n    return (v[cur].size() == 2) + w[0];\n}\n \nint main()\n{\n \n //   ofstream myo;\n  //  myo.open (\"output01.txt\");\n \n//\tifstream myi;\n //   myi.open (\"input01.txt\");\n    int n;\n\tcin>>n;\n \n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n    memset(used, 0, sizeof(used));\n    dfs(0);\n    cout << maxx + endpoint << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint cnt;\nint ma;\nint dp[100010];\nvi g[100010];\nvi g2[100010];\n\nvoid dfs(int v, int p)\n{\n\tmultiset<int> st;\n\tfor (int to : g[v]) {\n\t\tif (to != p) {\n\t\t\tdfs(to, v);\n\t\t\tdp[v] = max(dp[v], dp[to]);\n\t\t\tg2[v].pb(to);\n\t\t\tst.insert(dp[to]);\n\t\t\tif (st.size() > 2) st.erase(st.begin());\n\t\t}\n\t}\n\n\tif (st.size() == 2) {\n\t\tauto it = st.begin();\n\t\tauto it2 = it;\n\t\t++it2;\n\t\tma = max(ma, *it + *it2);\n\t}\n\n\tif (g[v].size() == 2) {\n\t\tif (p != -1) {\n\t\t\tdp[v] = max(dp[v], dp[g2[v][0]] + 1);\n\t\t} else {\n\t\t\tma = max(ma, dp[g2[v][0]] + dp[g2[v][1]] + 1);\n\t\t}\n\t}\n\n\tma = max(ma, dp[v]);\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\n\trep(i,N-1) {\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\n\trep(i, N) {\n\t\tif (g[i].size() == 1) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\n\tdfs(0, -1);\n\n\tcout << cnt + ma << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\n#include <iterator>\nusing namespace std;\n\nvector<vector<int> > edges;\n\npair<int, int> solve(int curr, int prev, int& ans)\n{\n    int leaf = 0;\n    vector<int> v;\n    for(int next : edges[curr]){\n        if(next == prev)\n            continue;\n\n        auto p = solve(next, curr, ans);\n        leaf += p.first;\n        v.push_back(p.second);\n    }\n\n    if(v.size() == 0){\n        ans = max(ans, 1);\n        return make_pair(1, 0);\n    }\n    else if(v.size() == 1){\n        ans = max(ans, leaf + v[0] + 1);\n        return make_pair(leaf, v[0] + 1);\n    }\n    else if(v.size() == 2){\n        sort(v.rbegin(), v.rend());\n        ans = max(ans, leaf + v[0] + v[1] + 1);\n        return make_pair(leaf, v[0]);\n    }\n    else{\n        sort(v.rbegin(), v.rend());\n        ans = max(ans, leaf + v[0] + v[1]);\n        return make_pair(leaf, v[0]);\n    }\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    edges.assign(n, vector<int>());\n    for(int i=0; i<n-1; ++i){\n        int p, q;\n        cin >> p >> q;\n        -- p;\n        -- q;\n        edges[p].push_back(q);\n        edges[q].push_back(p);\n    }\n\n    int ans = 0;\n    solve(0, -1, ans);\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\nvoid func(vector<vector<int>>&edge, vector<int>&dp, int &ans, int node = 0, int p = -1) {\n\tvector<int>box;\n\tfor (auto i : edge[node]) {\n\t\tif (i == p)continue;\n\t\tfunc(edge, dp, ans, i, node);\n\t\tbox.push_back(dp[i]);\n\t}\n\tsort(box.rbegin(), box.rend());\n\tif (box.empty()) {\n\t\tdp[node] = 1;\n\t\tans = max(ans, 1);\n\t}\n\telse if (box.size() == 1) {\n\t\tdp[node] = box[0] + 1;\n\t\tans = max(ans, dp[node]);\n\t}\n\telse if (box.size() >= 2) {\n\t\tdp[node] = box[0] + box.size() - 1;\n\t\tans = max(ans, box[0] + box[1] + 1);\n\t\tans = max(ans, box[0] + box[1] + (int)box.size() - 2);\n\t\tans = max(ans, dp[node]);\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>edge(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> L >> R;\n\t\tL--, R--;\n\t\tedge[L].push_back(R);\n\t\tedge[R].push_back(L);\n\t}\n\tint ans = 0;\n\tvector<int>dp(N);\n\tfunc(edge, dp, ans);\n\t//for (int i = 0; i < N; i++) {\n\t//\tcout << i << \" \" << dp[i] << endl;\n\t//}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Initializer {\n  Initializer() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout << fixed << setprecision(15);\n  }\n} initializer;\n\nint main() {\n  int n, res = 0;\n  cin >> n;\n  vector<int> c(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int p, q;\n    cin >> p >> q;\n    --p, --q;\n    ++c[p];\n    ++c[q];\n  }\n  for (int i = 0; i < n; ++i) {\n    if (c[i] <= 2) ++res;\n  }\n  cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> v[100000];\nbool used[100000];\n\nint dfs(int cur, bool flag = false) {\n    used[cur] = true;\n    vector<int> w;\n    for (int i = 0; i < v[cur].size(); i++) {\n        if (!used[v[cur][i]]) w.push_back(v[cur][i]); \n    }\n    if (w.empty()) return 1;\n    if (w.size() == 1) return dfs(w[0]) + 1;\n    int ret = 0;\n    vector<int> x;\n    for (int i = 0; i < w.size(); i++) {\n        int p = dfs(w[i]);\n        if (p == 1) ret += p;\n        else {\n            x.push_back(p);\n        }\n    }\n    if (!x.empty()) {\n        sort(x.rbegin(), x.rend());\n        ret += x[0];\n        if (x.size() > 1 && flag) ret += x[1]; \n    }\n    return ret;\n}\n\nint main() {\n    int n; cin >> n;\n    for (int i = 0; i < n-1; i++) {\n        int a, b; cin >> a >> b;\n        a--; b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    memset(used, 0, sizeof(used));\n    for (int i = 0; i < n; i++) {\n        if (v[i].size() > 2) {\n            cout << dfs(i, true) << endl;\n            return 0;\n        }\n    }\n    cout << n << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 16.12.2019 13:30:15       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<int>> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  int ans = 0;\n  for (int root = 0; root < 1; root++) {\n    function<pair<int, int>(int, int)> Dfs = [&](int v, int pr) {\n      int one = 1;\n      int two = 0;\n      int profit = 0;\n      for (int u : g[v]) {\n        if (u == pr) {\n          continue;\n        }\n        auto res = Dfs(u, v);\n        one = max(one, 1 + res.first);\n        two += res.second;\n        profit = max(profit, res.first - res.second);\n      }\n      one = max(one, two + profit);\n      two = max(two, 1);\n      ans = max(ans, one);\n      return make_pair(one, two);\n    };\n    Dfs(root, -1);\n  }\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, a, b, d[100009]; vector<int> g[100009];\nint solve(int pos, int pre) {\n\tint ret = 0, mx = 0;\n\tfor (int i : g[pos]) {\n\t\tif (i != pre) {\n\t\t\tint res = solve(i, pos);\n\t\t\tmx = max(mx, res);\n\t\t\tret += res;\n\t\t}\n\t}\n\treturn max(ret, mx + 1);\n}\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i < N; i++) {\n\t\tscanf(\"%d %d\", &a, &b); a--, b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tint ret = N;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (g[i].size() >= 3) {\n\t\t\tret = solve(i, -1); break;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 100002\n\nint n;\n\nvector<int> v[MAX];\n\nint dp[MAX];\n\nint ans;\n\ninline void dfs(int b,int pr){\n\tvector<int> ret;\n\tfor(int go:v[b]){\n\t\tif(go==pr)continue;\n\t\tdfs(go,b);\n\t\tret.push_back(dp[go]);\n\t}\n\tsort(ret.begin(),ret.end(),greater<int>());\n\tif(ret.size()>=2){\n\t\tans=max(ans,ret[0]+ret[1]+1);\n\t}\n\tdp[b]=1;\n\tif(ret.size()>=1){\n\t\tdp[b]+=ret[0];\n\t}\n\tint tmp=0;\n\tfor(int j=0;j<ret.size();j++){\n\t\tif(j>=1){\n\t\t\tret[j]=1;\n\t\t}\n\t\ttmp+=ret[j];\n\t}\n\tdp[b]=max(dp[b],tmp);\n\tans=max(ans,dp[b]);\n}\n\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tdfs(0,-1);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5;\n\nvector<int> g[N];\nint leaves[N];\nint dp[N];\nint ans;\n\nvoid dfs(int u, int p) {\n    bool is_leaf = true;\n    for (int v : g[u]) {\n        if (v == p) {\n            continue;\n        }\n        dfs(v, u);\n        is_leaf = false;\n        leaves[u] += leaves[v];\n    }\n    if (is_leaf) {\n        leaves[u]++;\n        dp[u] = 1;\n    }\n}\n\nvoid dfs2(int u, int p) {\n    for (int v : g[u]) {\n        if (v == p) {\n            continue;\n        }\n        dfs2(v, u);\n        // take\n        dp[u] = max(dp[u], dp[v] + leaves[u] - leaves[v]);\n\n        // not take\n        dp[u] = max(dp[u], dp[v] + 1);\n    }\n    ans = dp[u];\n    for (int x : g[u]) {\n        for (int y : g[u]) {\n            if (x == y) {\n                continue;\n            }\n            ans = max(ans, dp[x] + dp[y] + 1);\n            ans = max(ans, dp[x] + dp[y] + leaves[u] - leaves[x] - leaves[y] + (leaves[0] - leaves[u]));\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    if (n > 3000) return 0;\n    dfs(0, -1);\n    dfs2(0, -1);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\n\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fi first\n#define se second\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define ALL(c) (c).begin(),(c).end()\n\nint cnt;\nint ma;\nint dp[100010];\nvi g[100010];\nvi g2[100010];\n\nvoid dfs(int v, int p)\n{\n\tfor (int to : g[v]) {\n\t\tif (to != p) {\n\t\t\tdfs(to, v);\n\t\t\tdp[v] = max(dp[v], dp[to]);\n\t\t\tg2[v].pb(to);\n\t\t}\n\t}\n\n\tif (g[v].size() == 2) {\n\t\tif (p != -1) {\n\t\t\tdp[v] = max(dp[v], dp[g2[v][0]] + 1);\n\t\t} else {\n\t\t\tdp[v] = max(dp[v], dp[g2[v][0]] + dp[g2[v][1]] + 1);\n\t\t}\n\t}\n\n\tma = max(ma, dp[v]);\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\n\trep(i,N-1) {\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\t--a; --b;\n\t\tg[a].pb(b);\n\t\tg[b].pb(a);\n\t}\n\n\trep(i, N) {\n\t\tif (g[i].size() == 1) {\n\t\t\t++cnt;\n\t\t}\n\t}\n\n\tdfs(0, -1);\n\n\tcout << cnt + ma << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\n#define REP(i,s,n) for(int i=(int)(s);i<(int)(n);i++)\n\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> PI;\nconst ll mod = 1e9 + 7;\n\nconst int N = 100100;\n\nVI edges[N];\n\n// Reference: http://cf16-relay-open.contest.atcoder.jp/submissions/1002080\n\nint c[N];\n\nint ma = 0;\n\nint dfs(int v, int p) {\n  VI t(2, 0);\n  REP(i, 0, edges[v].size()) {\n    int w = edges[v][i];\n    if (w == p) {\n      continue;\n    }\n    int r = dfs(w, v);\n    t.push_back(r);\n  }\n  sort(t.rbegin(), t.rend());\n  ma = max(ma, t[0] + t[1] + c[v]);\n  c[v] += t[0];\n  return c[v];\n}\n\nint main(void){\n  int n;\n  cin >> n;\n  REP(i, 0, n - 1) {\n    int p, q;\n    cin >> p >> q;\n    p--, q--;\n    edges[p].push_back(q);\n    edges[q].push_back(p);\n  }\n  // Find one of the longest path and counts vertices of index two.\n  REP(i, 0, n) {\n    c[i] = edges[i].size() == 2 ? 1 : 0;\n  }\n  dfs(0, -1);\n  int tot = ma;\n  REP(i, 0, n) {\n    if (edges[i].size() == 1) { tot++; }\n  }\n  cout << tot << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint N;\nvector<vector<int>> G;\n\nvector<int> bfs(int s) {\n  queue<int> que;\n  vector<int> mc(N, -1);\n  que.push(s);\n  mc[s] = 1;\n  while (!que.empty()) {\n    int u = que.front(); que.pop();\n    for (auto &v : G[u]) {\n      if (mc[v] == -1) {\n        mc[v] = mc[u] + max((int)G[u].size() - 2, 1);\n        que.push(v);\n      }\n    }\n  }\n  return (mc);\n}\nint main() {\n  cin >> N;\n  G = vector<vector<int>>(N);\n  for (int i = 0; i < N-1; i++) {\n    int p, q;\n    cin >> p >> q; --p, --q;\n    G[p].push_back(q);\n    G[q].push_back(p);\n  }\n\n  vector<int> mc1 = bfs(0);\n  int pos = 0;\n  for (int i = 1; i < N; i++) {\n    if (mc1[i] > mc1[pos]) pos = i;\n  }\n  vector<int> mc2 = bfs(pos);\n  int pos2 = 0;\n  int d = 0;\n  for (int i = 0; i < N; i++) d = max(d, mc2[i]);\n  cout << d << endl;\n  return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[101010];\nint D[101010];\nint ret;\n\nvoid dfs(int cur,int pre,int d) {\n\tD[cur]=d;\n\tFORR(r,E[cur]) if(r!=pre) dfs(r,cur,d+1);\n}\n\nint dfs2(int tar,int cur,int pre) {\n\tint now=0;\n\tif(cur==tar) return 1;\n\tFORR(r,E[cur]) if(r!=pre) {\n\t\tnow |= dfs2(tar,r,cur);\n\t}\n\tif(now && E[cur].size()>2) ret--;\n\treturn now;\n}\n\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\t\n\tint leaf=0;\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\tFOR(i,N) if(E[i].size()==1) leaf++;\n\t\n\tdfs(0,-1,0);\n\tx = max_element(D,D+N)-D;\n\tdfs(x,-1,0);\n\ty = max_element(D,D+N)-D;\n\tcout<<min(N,D[y]+1)<<endl;\n\treturn;\n\tret=leaf-2+D[y]+1;\n\tdfs2(y,x,-1);\n\t\n\tcout<<ret<<endl;\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct Initializer {\n  Initializer() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    cout << fixed << setprecision(15);\n  }\n} initializer;\n\ntemplate<typename T> inline istream& operator>>(istream &s, vector<T> &v) {\n  for (T &t : v) s >> t;\n  return s;\n}\n\ntemplate<typename T> inline ostream& operator<<(ostream &s, const vector<T> &v) {\n  for (const T &t : v) s << t << endl;\n  return s;\n}\n\ntemplate<typename T> inline T min(vector<T>& v) {return *min_element(v.begin(), v.end());}\n\ntemplate<typename T> inline T max(vector<T>& v) {return *max_element(v.begin(), v.end());}\n\ntemplate<typename T> inline int min_element(vector<T>& v) {return min_element(v.begin(), v.end()) - v.begin();}\n\ntemplate<typename T> inline int max_element(vector<T>& v) {return max_element(v.begin(), v.end()) - v.begin();}\n\ntemplate<typename T> inline void sort(vector<T>& v) {sort(v.begin(), v.end());}\n\ntemplate<typename T, typename Function> inline void sort(vector<T>& v, Function func) {sort(v.begin(), v.end(), func);}\n\ntemplate<typename T> inline void rsort(vector<T>& v) {sort(v.rbegin(), v.rend());}\n\ntemplate<typename T> inline void reverse(vector<T>& v) {reverse(v.begin(), v.end());}\n\ntemplate<typename T> inline void unique(vector<T>& v) {v.erase(unique(v.begin(), v.end()), v.end());}\n\ntemplate<typename T> inline void nth_element(vector<T>& v, int n) {nth_element(v.begin(), v.begin() + n, v.end());}\n\ntemplate<typename T> inline bool next_permutation(vector<T>& v) {return next_permutation(v.begin(), v.end());}\n\ntemplate<typename T> inline int find(vector<T>& v, T t) {return find(v.begin(), v.end(), t) - v.begin();}\n\ntemplate<typename T> inline int in(vector<T> v, T t) {return find(v, t) != (int)v.size();}\n\ntemplate<typename T> inline int lower_bound(vector<T>& v, T t) {return lower_bound(v.begin(), v.end(), t) - v.begin();}\n\ntemplate<typename T> inline int upper_bound(vector<T>& v, T t) {return upper_bound(v.begin(), v.end(), t) - v.begin();}\n\ntemplate<typename T> inline T accumulate(const vector<T>& v, function<T(T, T)> func = plus<T>()) {return accumulate(v.begin(), v.end(), T(), func);}\n\ntemplate<typename T> inline void adjacent_difference(vector<T>& v) {adjacent_difference(v.begin(), v.end(), v.begin());}\n\ntemplate<typename T> inline void adjacent_difference(vector<T>& v, vector<T>& u) {adjacent_difference(v.begin(), v.end(), u.begin());}\n\ntemplate<typename T> inline void partial_sum(vector<T>& v, vector<T>& u) {partial_sum(v.begin(), v.end(), u.begin());}\n\ntemplate<typename T> inline T inner_product(vector<T>& v, vector<T>& u) {return inner_product(v.begin(), v.end(), u.begin(), T(0));}\n\ntemplate<typename T> inline int count(const vector<T>& v, T t) {return count(v.begin(), v.end(), t);}\n\ntemplate<typename T, typename Function> inline int count_if(const vector<T>& v, Function func) {return count_if(v.begin(), v.end(), func);}\n\ntemplate<typename T, typename Function> inline void remove_if(vector<T>& v, Function func) {v.erase(remove_if(v.begin(), v.end(), func), v.end());}\n\ntemplate<typename T, typename Function> inline bool any_of(vector<T> v, Function func) {return any_of(v.begin(), v.end(), func);}\n\ntemplate<typename T> inline vector<T> subvector(vector<T>& v, int a, int b) {return vector<T>(v.begin() + a, v.begin() + b);}\n\ntemplate<typename T> inline int kinds(const vector<T>& v) {return set<T>(v.begin(), v.end()).size();}\n\ntemplate<typename T> inline void iota(vector<T>& v) {iota(v.begin(), v.end(), T());}\n\nclass UnionFind {\nprivate:\n  int n;\n  vector<int> a;\npublic:\n  UnionFind(int n) : n(n), a(n, -1) {}\n  int find(int x) {return a[x] < 0 ? x : (a[x] = find(a[x]));}\n  bool equal(int x, int y) {return find(x) == find(y);}\n  void unite(int x, int y) {\n    x = find(x), y = find(y);\n    if (x == y) return;\n    if (a[x] > a[y]) swap(x, y);\n    a[x] += a[y];\n    a[y] = x;\n    --n;\n  }\n  int size() {return n;}\n  int size(int x) {return -a[find(x)];}\n};\n\nint main() {\n  int n, res = 0;\n  cin >> n;\n  vector<int> c(n);\n  vector<vector<int>> g(n);\n  UnionFind uf(n);\n  for (int i = 0; i < n - 1; ++i) {\n    int p, q;\n    cin >> p >> q;\n    --p, --q;\n    ++c[p];\n    ++c[q];\n    g[p].emplace_back(q);\n    g[q].emplace_back(p);\n  }\n  for (int i = 0; i < n; ++i) {\n    if (c[i] <= 1) ++res;\n    if (c[i] == 2) {\n      if (c[g[i][0]] == 2) uf.unite(i, g[i][0]);\n      if (c[g[i][1]] == 2) uf.unite(i, g[i][1]);\n    }\n  }\n  vector<int> v(2);\n  for (int i = 0; i < n; ++i) {\n    if (c[i] == 2 && uf.find(i) == i) {\n      v.emplace_back(uf.size(i));\n    }\n  }\n  rsort(v);\n  cout << res + v[0] + v[1] << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint N, a, b, d[100009]; vector<int> g[100009];\nint solve(int pos, int pre) {\n\tint ret = 0;\n\tfor (int i : g[pos]) {\n\t\tif (i != pre) {\n\t\t\tret += solve(i, pos);\n\t\t\td[pos] = max(d[pos], d[i] + 1);\n\t\t}\n\t}\n\treturn max(ret, d[pos] + 1);\n}\nint main() {\n\tscanf(\"%d\", &N);\n\tfor (int i = 1; i < N; i++) {\n\t\tscanf(\"%d %d\", &a, &b); a--, b--;\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\tint ret = N;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (g[i].size() >= 3) {\n\t\t\tret = solve(i, -1); break;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", ret);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\nvoid func(vector<vector<int>>&edge, vector<int>&dp, int &ans, int node = 0, int p = -1) {\n\tvector<int>box;\n\tfor (auto i : edge[node]) {\n\t\tif (i == p)continue;\n\t\tfunc(edge, dp, ans, i, node);\n\t\tbox.push_back(dp[i]);\n\t}\n\tsort(box.rbegin(), box.rend());\n\tif (box.empty()) {\n\t\tdp[node] = 1;\n\t\tans = max(ans, 1);\n\t}\n\telse if (box.size() == 1) {\n\t\tdp[node] = box[0] + 1;\n\t\tans = max(ans, dp[node]);\n\t}\n\telse if (box.size() >= 2) {\n\t\tdp[node] = box[0] + box.size() - 1;\n\t\tans = max(ans, box[0] + box[1] + 1);\n\t\tans = max(ans, box[0] + box[1] + (int)box.size() - 2);\n\t\tans = max(ans, dp[node]);\n\t\tif (box.size() > 2)ans = max(ans, dp[node] + 1);\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>edge(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> L >> R;\n\t\tL--, R--;\n\t\tedge[L].push_back(R);\n\t\tedge[R].push_back(L);\n\t}\n\tint ans = 0;\n\tvector<int>dp(N);\n\tfunc(edge, dp, ans);\n\t//for (int i = 0; i < N; i++) {\n\t//\tcout << i << \" \" << dp[i] << endl;\n\t//}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 1e5 + 10;\nint n , du[N] , ans;\nvi g[N];\n\nint dfs(int c,int fa=0) {\n  int a = 0 , b = 0;\n  for(auto t : g[c]) if(t != fa) {\n    int gt = dfs(t , c);\n    if(gt > a) swap(a , b) , a = gt;\n    else if(gt > b) b = gt;\n  }\n  if(du[c] == 2) ans = max(ans , ++a);\n  else ans = max(ans , a + b);\n  return a;\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  rep(i,1,n) {\n    int u,v;\n    scanf(\"%d%d\",&u,&v);\n    g[u].pb(v);\n    g[v].pb(u);\n    du[u]++;\n    du[v]++;\n  }\n  int t = max_element(du + 1 , du + 1 + n) - du;\n  if(du[t] <= 2) return printf(\"%d\\n\",n) , 0;\n  dfs(t);\n  rep(i,1,n+1) ans += du[i] == 1;\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[101010];\nint D[101010];\nint ma;\n\nvoid dfs(int cur,int pre) {\n\tvector<int> V;\n\tD[cur]=1;\n\tFORR(e,E[cur]) if(e!=pre) {\n\t\tdfs(e,cur);\n\t\tV.push_back(D[e]);\n\t}\n\tsort(ALL(V));\n\treverse(ALL(V));\n\tif(V.size()>3) ma=max(ma,V[0]+V[1]+(int)V.size()-2);\n\tif(V.size()>=2 && V.size()<=3) ma=max(ma,V[0]+V[1]+1);\n\tif(V.size()>=1) ma=max(ma,V[0]+1+(int)E[cur].size()-1);\n\t\n\tif(V.size()>=2) D[cur]=V[0]+V.size()-1;\n\tif(V.size()==1) D[cur]=V[0]+1;\n\tma=max(ma,D[cur]);\n\t\n\t\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\tma=1;\n\tdfs(0,-1);\n\tcout<<ma<<endl;\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5;\n\ntemplate<class T1, class T2>\nvoid chmax(T1 &a, T2 b) {\n    if (a < b) a = b;\n}\n\npair<int, int> max2(pair<int, int> a, int b) {\n    if (a.first < b) swap(a.first, b);\n    if (a.second < b) swap(a.second, b);\n    return a;\n}\n\nstruct DP {\n    int path = 0;\n    int leaves[3] = {};\n\n    int get_max() {\n        return max({ path + 1, leaves[0], leaves[1], leaves[2] });\n    }\n};\n\nvoid show(DP d) {\n    printf(\"%d %d %d %d\\n\", d.path, d.leaves[0], d.leaves[1], d.leaves[2]);\n}\n\nDP add(DP a, bool l) {\n    a.path++;\n    if (l) a.leaves[0]++;\n    return a;\n}\n\nDP operator+(const DP &a, const DP &b) {\n    DP res;\n    res.path = max(a.path, b.path);\n    res.leaves[2] = max({\n        a.leaves[2] + b.leaves[0],\n        a.leaves[1] + b.leaves[1],\n        a.leaves[0] + b.leaves[2],\n        a.leaves[1] + b.path,\n        a.path + b.leaves[1],\n        a.path + b.path,\n    });\n    res.leaves[1] = max({\n        a.leaves[0] + b.leaves[1],\n        a.leaves[1] + b.leaves[0],\n        a.leaves[0] + b.path,\n        a.path + b.leaves[0],\n    });\n    res.leaves[0] = a.leaves[0] + b.leaves[0];\n    return res;\n}\n\nvector<int> g[N], gg[N];\nDP dp[N];\nbool is_leaf[N];\nint ans = 0;\n\nDP get_dp(int u) {\n    return add(dp[u], is_leaf[u]);\n}\n\nvoid dfs(int u, int p) {\n    for (int v : g[u]) if (v != p) {\n        gg[u].push_back(v);\n    }\n    if (gg[u].empty() || (p == -1 && gg[u].size() == 1)) {\n        is_leaf[u] = true;\n    }\n    for (int v : gg[u]) {\n        dfs(v, u);\n        dp[u] = dp[u] + get_dp(v);\n    }\n}\n\nvoid dfs2(int u, int p, DP par) {\n    vector<DP> sumR(gg[u].size() + 1);\n    for (int i = (int)gg[u].size() - 1; i >= 0; i--) {\n        int v = gg[u][i];\n        sumR[i] = sumR[i + 1] + get_dp(v);\n    }\n    DP foo = sumR[0];\n    if (p != -1) foo = foo + add(par, is_leaf[p]);\n    // cout << u << \":\";\n    // show(foo);\n    ans = max(ans, foo.get_max());\n    pair<int, int> dia(par.path, 0);\n    if (par.path < 0) swap(dia.first, dia.second);\n    for (int i = 0; i < gg[u].size(); i++) {\n        int v = gg[u][i];\n        dia = max2(dia, dp[v].path);\n    }\n    ans = max(ans, dia.first + dia.second + 1);\n    DP sumL;\n    for (int i = 0; i < gg[u].size(); i++) {\n        int v = gg[u][i];\n        DP tmp = sumL + sumR[i + 1];\n        if (p != -1) {\n            tmp = tmp + add(par, is_leaf[p]);\n        }\n        dfs2(v, u, tmp);\n        sumL = sumL + get_dp(v);\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    dfs(0, -1);\n    dfs2(0, -1, DP());\n    cout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint main() {\n    int N; cin >> N;\n    vector<vector<int>> G(N);\n    for (int i = 0; i < N - 1; i++) {\n        int p, q; cin >> p >> q; p--, q--;\n        G[p].push_back(q);\n        G[q].push_back(p);\n    }\n    vector<int> type(N), weight(N, 2);\n    for (int i = 0; i < N; i++) if (G[i].size() >= 3) {\n        type[i] = 1;\n        weight[i] = 0;\n    }\n    for (int i = 0; i < N; i++) if (type[i] == 0) {\n        for (int n : G[i]) if (type[n] == 1) {\n            weight[n] += 2;\n            weight[i] -= 2;\n        }\n    }\n    vector<vector<int>> G2(N);\n    auto recur = [&](auto&& recur, int node, int base) {\n        if (weight[node] == 0) return;\n        if (node != base) {\n            weight[base] += weight[node];\n            weight[node] = 0;\n        }\n        for (int n : G[node]) if (type[n] == 0) {\n            G2[base].push_back(n);\n            G2[n].push_back(base);\n        }\n        for (auto n : G[node]) {\n            if (type[n] == 1 && n != base) {\n                recur(recur, n, base);\n            }\n        }\n    };\n    for (int i = 0; i < N; i++) {\n        if (type[i] == 1) {\n            recur(recur, i, i);\n        } else {\n            for (auto n : G[i]) {\n                if (type[n] == 0) {\n                    G2[i].push_back(n);\n                }\n            }\n        }\n    }\n    auto far = [&](int root) {\n        vector<int> score(G2.size(), -1);\n        stack<tuple<int, int>> S;\n        S.emplace(root, 0);\n        while (!S.empty()) {\n            auto [node, sc] = S.top(); S.pop();\n            if (score[node] >= 0) continue;\n            score[node] = sc + weight[node];\n            for (int next : G2[node]) {\n                S.emplace(next, score[node]);\n            }\n        }\n        auto it = max_element(begin(score), end(score));\n        return make_pair(it - begin(score), *it);\n    };\n    auto p1 = far(max_element(begin(weight), end(weight)) - begin(weight));\n    auto p2 = far(p1.first);\n    cout << p2.second / 2 << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef long double D;\n//typedef complex<D> P;\n#define F first\n#define S second\nconst ll MOD=1000000007;\n//const ll MOD=998244353;\n\ntemplate<typename T,typename U>istream & operator >> (istream &i,pair<T,U> &A){i>>A.F>>A.S; return i;}\ntemplate<typename T>istream & operator >> (istream &i,vector<T> &A){for(auto &I:A){i>>I;} return i;}\ntemplate<typename T,typename U>ostream & operator << (ostream &o,const pair<T,U> &A){o<<A.F<<\" \"<<A.S; return o;}\ntemplate<typename T>ostream & operator << (ostream &o,const vector<T> &A){int i=A.size(); for(auto &I:A){o<<I<<(--i?\" \":\"\");} return o;}\n\n\nint N;\nvector<vector<int>> edge;\n\npll dfs(ll u,ll p){\n  pll ret={0,u};\n  for(auto &v:edge[u]){\n    if(v==p){continue;}\n    ret=max(ret,dfs(v,u));\n  }\n  if((int)edge[u].size()==2){ret.F++;}\n  return ret;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cin>>N;\n  edge.resize(N);\n  for(int i=1;i<N;i++){\n    int p,q;\n    cin>>p>>q;\n    p--; q--;\n    edge[p].push_back(q);\n    edge[q].push_back(p);\n  }\n  int ans=0;\n  for(auto &I:edge){\n    if((int)I.size()==1){ans++;}\n  }\n  int s=dfs(0,-1).S;\n  ans+=dfs(s,-1).F;\n  cout<<ans<<endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <ctime>\n#include <cstdlib>\n#include <cassert>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <string>\n#include <algorithm>\n#include <utility>\n#define llint long long\n#define inf 1e18\n#define rep(x, s, t) for(llint (x) = (s); (x) < (t); (x)++)\n#define Rep(x, s, t) for(llint (x) = (s); (x) <= (t); (x)++)\n#define chmin(x, y) (x) = min((x), (y))\n#define chmax(x, y) (x) = max((x), (y))\n\nusing namespace std;\ntypedef pair<llint, llint> P;\n\nllint n;\nvector<llint> G[100005];\nmap<P, llint> mp, mp2;\n\nvoid dfs(int v, int p)\n{\n\tllint deg = 0;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == p) continue;\n\t\tdfs(G[v][i], v);\n\t\tdeg++;\n\t}\n\tif(deg == 0){\n\t\tmp[P(p, v)] = 1;\n\t\treturn;\n\t}\n\t\n\tllint sum = 0;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i];\n\t\tif(u == p) continue;\n\t\tsum += mp[P(v, u)];\n\t}\n\tmp[P(p, v)] = sum;\n}\n\nvoid dfs2(int v, int p)\n{\n\tllint sum = 0;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i];\n\t\tsum += mp[P(v, u)];\n\t}\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i];\n\t\tif(u == p) continue;\n\t\tmp[P(u, v)] = sum - mp[P(v, u)];\n\t}\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == p) continue;\n\t\tdfs2(G[v][i], v);\n\t}\n}\n\nvoid calcdfs(int v, int p)\n{\n\tllint deg = 0;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == p) continue;\n\t\tcalcdfs(G[v][i], v);\n\t\tdeg++;\n\t}\n\tif(deg <= 1){\n\t\tmp2[P(p, v)] = 1;\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tint u = G[v][i];\n\t\t\tif(u == p) continue;\n\t\t\tmp2[P(p, v)] += mp2[P(v, u)];\n\t\t}\n\t\treturn;\n\t}\n\t\n\tllint sum = mp[P(p, v)], mx = 0;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i];\n\t\tif(u == p) continue;\n\t\tmx = max(mx, sum + mp2[P(v, u)] - mp[P(v, u)]);\n\t}\n\tmp2[P(p, v)] = mx;\n}\n\nllint lmax[100005], rmax[100005];\nvoid calcdfs2(int v, int p)\n{\n\tllint sum = 0;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i];\n\t\tsum += mp[P(v, u)];\n\t}\n\tif(G[v].size() <= 1) return;\n\t\n\tif(G[v].size() == 2){\n\t\tfor(int i = 0; i < G[v].size(); i++){\n\t\t\tint u = G[v][i];\n\t\t\tif(u == p) continue;\n\t\t\tmp2[P(u, v)] = 1 + mp2[P(v, p)];\n\t\t\tcalcdfs2(u, v);\n\t\t}\n\t\treturn;\n\t}\n\t\n\tllint m = G[v].size();\n\tlmax[0] = -inf;\n\tfor(int i = 0; i < m; i++){\n\t\tint u = G[v][i];\n\t\tlmax[i+1] = max(lmax[i], mp2[P(v, u)] - mp[P(v, u)]);\n\t}\n\trmax[m+1] = -inf;\n\tfor(int i = m-1; i >= 0; i--){\n\t\tint u = G[v][i];\n\t\trmax[i+1] = max(rmax[i+2], mp2[P(v, u)] - mp[P(v, u)]);\n\t}\n\t\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint u = G[v][i];\n\t\tif(u == p) continue;\n\t\tmp2[P(u, v)] = sum - mp[P(v, u)] + max(lmax[i], rmax[i+2]);\n\t}\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tif(G[v][i] == p) continue;\n\t\tcalcdfs2(G[v][i], v);\n\t}\n}\n\nint main(void)\n{\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\t\n\tcin >> n;\n\tllint u, v;\n\tfor(int i = 1; i <= n-1; i++){\n\t\tcin >> u >> v;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\t\n\tllint root = -1;\n\tfor(int i = 1; i <= n; i++){\n\t\tif(G[i].size() >= 3){\n\t\t\troot = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(root == -1){\n\t\tcout << n << endl;\n\t\treturn 0;\n\t}\n\t\n\tdfs(root, -1);\n\tdfs2(root, -1);\n\t\n\tcalcdfs(root, -1);\n\tcalcdfs2(root, -1);\n\t\n\t/*for(auto it = mp2.begin(); it != mp2.end(); it++){\n\t\tcout << it->first.first << \" \" << it->first.second << \" \" << it->second << endl;\n\t}*/\n\t\n\tllint ans = 0;\n\tfor(int i = 1; i <= n; i++){\n\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\tans = max(ans, mp2[P(i, G[i][j])]+1);\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvector<int> G[100010];\nint N,A,B;\n\nint dfs(int x, int l)\n{\n\tvector<int> u;\n\tfor (int y : G[x]) if (y != l){\n\t\tu.push_back(dfs(y,x));\n\t}\n\n\tint mx = 0;\n\tfor (int i=0;i<u.size();i++) mx = max(mx,u[i]);\n\tif (G[x].size() == 2){\n\t\tmx++;\n\t\tif (u.size() == 2){\n\t\t\tB = max(B, u[0] + u[1] + 1);\n\t\t}\n\t\telse{\n\t\t\tB = max(B,mx);\n\t\t}\n\t}\n\telse{\n\t\tsort(u.rbegin(),u.rend());\n\t\tif (u.size() >= 2){\n\t\t\tB = max(B, u[0] + u[1]);\n\t\t}\n\t}\n\treturn mx;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tfor (int i=1;i<N;i++){\n\t\tint x,y; scanf (\"%d %d\",&x,&y);\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tfor (int i=1;i<=N;i++) if (G[i].size() == 1) A++;\n\n\tdfs(1,0);\n\tprintf (\"%d\\n\",A+B);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <set>\n#include <map>\n#include <string>\n#include <vector>\n#include <bitset>\n#include <algorithm>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <queue>\n\n#define mp make_pair\n#define pb push_back\n\n\ntypedef long long ll;\ntypedef long double ld;\n\nusing namespace std;\nconst int MAXN = 120000;\nint ans = 0;\nint dp[MAXN][5];\nint n;\nvector<int> eds[MAXN];\nint was[MAXN];\n\nvoid dfs1(int v) {\n\twas[v] = 1;\n\tint mxd1 = 0;\n\tint mxd2 = 0;\n\tint mx1 = 0;\n\tint mx2 = 0;\n\tint sum = 0;\n\tint mxd = 0;\n\tint mx = 0;\n\tfor (int u: eds[v]) {\n\t\tif (was[u])\n\t\t\tcontinue;\n\t\tdfs1(u);\n\t\tmxd2 = max(mxd2, dp[u][0] - dp[u][1]);\n\t\tif (mxd2 > mxd1)\n\t\t\tswap(mxd1, mxd2);\n\t\tmx2 = max(mx2, dp[u][0]);\n\t\tif (mx2 > mx1)\n\t\t\tswap(mx1, mx2);\n\t\tmxd = max(mxd, dp[u][2] - dp[u][1]);\n\t\tsum += dp[u][1];\n\t\tmx = max(mx, dp[u][2]);\n\t}\n\tans = max(ans, sum + mxd1 + mxd2);\n\tans = max(ans, 1 + mx1 + mx2);\n\tans = max(ans, sum + mxd);\n\tans = max(ans, mx + 1);\n\tdp[v][0] = max(1 + mx1, sum + mxd1);\n\tdp[v][1] = max(1, sum);\n\tdp[v][2] = max(mxd + sum, sum + mxd1 + mxd2);\n}\n\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n - 1; ++i) {\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\t--a, --b;\n\t\teds[a].push_back(b);\n\t\teds[b].push_back(a);\n\t}\n\tdfs1(0);\n\tcout << ans << \"\\n\";\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \ntypedef long long ll;\ntypedef long double ld; \ntypedef double db; \ntypedef string str; \n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl; \ntypedef pair<ld,ld> pd; \n#define mp make_pair\n#define f first\n#define s second\n\ntypedef vector<int> vi; \ntypedef vector<ll> vl; \ntypedef vector<ld> vd; \ntypedef vector<str> vs; \ntypedef vector<pi> vpi; \ntypedef vector<pl> vpl; \ntypedef vector<pd> vpd; \n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rall(x) (x).rbegin(), (x).rend() \n#define rsz resize\n#define ins insert \n#define ft front() \n#define bk back() \n#define pf push_front \n#define pb push_back\n#define eb emplace_back \n#define lb lower_bound \n#define ub upper_bound \n\n#define FOR(i,a,b) for (int i = (a); i < (b); ++i)\n#define F0R(i,a) FOR(i,0,a)\n#define ROF(i,a,b) for (int i = (b)-1; i >= (a); --i)\n#define R0F(i,a) ROF(i,0,a)\n#define trav(a,x) for (auto& a: x)\n\nconst int MOD = 1e9+7; // 998244353; // = (119<<23)+1\nconst int MX = 2e5+5; \nconst ll INF = 1e18; \nconst ld PI = 4*atan((ld)1); \nconst int xd[4] = {0,1,0,-1}, yd[4] = {1,0,-1,0}; \n\ntemplate<class T> bool ckmin(T& a, const T& b) { \n\treturn a > b ? a = b, 1 : 0; }\ntemplate<class T> bool ckmax(T& a, const T& b) { \n\treturn a < b ? a = b, 1 : 0; }\nmt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());\n\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\nusing namespace __gnu_pbds;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, \n\trb_tree_tag, tree_order_statistics_node_update>; \n// change null_type for map\n#define ook order_of_key\n#define fbo find_by_order\n\nvoid treeExample() {\n\tTree<int> t, t2; t.insert(8);\n\tauto it = t.insert(10).f; assert(it == t.lb(9));\n\tassert(t.ook(10) == 1); assert(t.ook(11) == 2);\n\tassert(*t.fbo(0) == 8);\n\tt.join(t2); // assuming T < T2 or T > T2, merge t2 into t\n}\n\nnamespace input {\n\ttemplate<class T> void re(complex<T>& x);\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p);\n\ttemplate<class T> void re(vector<T>& a);\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a);\n\n\ttemplate<class T> void re(T& x) { cin >> x; }\n\tvoid re(double& x) { string t; re(t); x = stod(t); }\n\tvoid re(ld& x) { string t; re(t); x = stold(t); }\n\ttemplate<class T, class... Ts> void re(T& t, Ts&... ts) { \n\t\tre(t); re(ts...); \n\t}\n\n\ttemplate<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n\ttemplate<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n\ttemplate<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n\ttemplate<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n\tvoid pr(int x) { cout << x; }\n\tvoid pr(long x) { cout << x; }\n\tvoid pr(ll x) { cout << x; }\n\tvoid pr(unsigned x) { cout << x; }\n\tvoid pr(unsigned long x) { cout << x; }\n\tvoid pr(unsigned long long x) { cout << x; }\n\tvoid pr(float x) { cout << x; }\n\tvoid pr(double x) { cout << x; }\n\tvoid pr(ld x) { cout << x; }\n\tvoid pr(char x) { cout << x; }\n\tvoid pr(const char* x) { cout << x; }\n\tvoid pr(const string& x) { cout << x; }\n\tvoid pr(bool x) { pr(x ? \"true\" : \"false\"); }\n\ttemplate<class T> void pr(const complex<T>& x) { cout << x; }\n\t\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x);\n\ttemplate<class T> void pr(const T& x);\n\t\n\ttemplate<class T, class... Ts> void pr(const T& t, const Ts&... ts) { \n\t\tpr(t); pr(ts...); \n\t}\n\ttemplate<class T1, class T2> void pr(const pair<T1,T2>& x) { \n\t\tpr(\"{\",x.f,\", \",x.s,\"}\"); \n\t}\n\ttemplate<class T> void pr(const T& x) { \n\t\tpr(\"{\"); // const iterator needed for vector<bool>\n\t\tbool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; \n\t\tpr(\"}\");\n\t}\n\t\n\tvoid ps() { pr(\"\\n\"); } // print w/ spaces\n\ttemplate<class T, class... Ts> void ps(const T& t, const Ts&... ts) { \n\t\tpr(t); if (sizeof...(ts)) pr(\" \"); ps(ts...); \n\t}\n\t\n\tvoid pc() { pr(\"]\\n\"); } // debug w/ commas\n\ttemplate<class T, class... Ts> void pc(const T& t, const Ts&... ts) { \n\t\tpr(t); if (sizeof...(ts)) pr(\", \"); pc(ts...); \n\t}\n\t#define dbg(x...) pr(\"[\",#x,\"] = [\"), pc(x);\n}\n\nusing namespace output;\n\nnamespace io {\n\tvoid setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n\tvoid setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n\tvoid setIO(string s = \"\") {\n\t\tios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n\t\t// cin.exceptions(cin.failbit); // ex. throws exception when you try to read letter into int\n\t\tif (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n\t}\n}\n\nusing namespace io;\n\nstruct mi {\n\ttypedef decay<decltype(MOD)>::type T;\n\tT val; \n\texplicit operator T() const { return val; }\n\tmi() { val = 0; }\n\tmi(ll v) { \n\t\tval = (-MOD <= v && v <= MOD) ? v : v % MOD;\n\t\tif (val < 0) val += MOD;\n\t}\n\tfriend bool operator==(const mi& a, const mi& b) { \n\t\treturn a.val == b.val; }\n\tfriend bool operator!=(const mi& a, const mi& b) { \n\t\treturn !(a == b); }\n\tfriend bool operator<(const mi& a, const mi& b) { \n\t\treturn a.val < b.val; }\n\tfriend void re(mi& a) { ll x; re(x); a = mi(x); }\n\tfriend void pr(const mi& a) { pr(a.val); }\n\tfriend ostream& operator<<(ostream& os, const mi& a) { \n\t\treturn os << a.val; }\n   \n\tmi operator-() const { return mi(-val); }\n\tmi& operator+=(const mi& m) { \n\t\tif ((val += m.val) >= MOD) val -= MOD; \n\t\treturn *this; }\n\tmi& operator-=(const mi& m) { \n\t\tif ((val -= m.val) < 0) val += MOD; \n\t\treturn *this; }\n\tmi& operator++() { return *this += 1; }\n\tmi& operator--() { return *this -= 1; }\n\tfriend mi operator+(mi a, const mi& b) { return a += b; }\n\tfriend mi operator-(mi a, const mi& b) { return a -= b; }\n\n\tmi& operator*=(const mi& m) { \n\t\tval = (ll)val*m.val%MOD; return *this; }\n\tfriend mi pow(mi a, ll p) {\n\t\tmi ans = 1; assert(p >= 0);\n\t\tfor (; p; p /= 2, a *= a) if (p&1) ans *= a;\n\t\treturn ans;\n\t}\n\tfriend mi inv(const mi& a) { \n\t\tassert(!(a == 0)); return pow(a,MOD-2); }\n\tmi& operator/=(const mi& m) { return (*this) *= inv(m); }\n\tfriend mi operator*(mi a, const mi& b) { return a *= b; }\n\tfriend mi operator/(mi a, const mi& b) { return a /= b; }\n};\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N, down[MX],par[MX],ans;\nvi adj[MX];\n\nvoid dfs(int x) {\n\tvi v;\n\ttrav(t,adj[x]) if (t != par[x]) {\n\t\tpar[t] = x; dfs(t);\n\t\tv.pb(down[t]);\n\t}\n\twhile (sz(v) < 2) v.pb(0);\n\tsort(all(v));\n\tckmax(ans,v[sz(v)-1]+v[sz(v)-2]+(sz(adj[x]) == 2));\n\tdown[x] = v[sz(v)-1]+(sz(adj[x]) == 2);\n}\n\nint main() {\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tre(N);\n\tF0R(i,N-1) {\n\t\tint p,q; re(p,q);\n\t\tadj[p].pb(q), adj[q].pb(p);\n\t}\n\tdfs(1);\n\tFOR(i,1,N+1) ans += sz(adj[i]) == 1;\n\tps(ans);\n\t// you should actually read the stuff at the bottom\n}\n\n/* stuff you should look for\n\t* int overflow, array bounds\n\t* special cases (n=1?), slow multiset operations\n\t* do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vvint = vector<vint>;\nusing vvvint = vector<vvint>;\nusing vll = vector<ll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n\ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n\nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\n\ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2> inline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n\tfor (auto &u : v) os << u << el;\n\treturn (os);\n}\n\ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n\tfor (auto &u : v) is >> u;\n\treturn (is);\n}\n\ntemplate<typename T1, typename T2>\nistream& operator >>(istream &is, pair<T1, T2> &p) {\n\treturn (is >> p.first >> p.second);\n}\n\nint main() {\n\tint N; cin >> N;\n\tvvint G(N);\t\n\tfor (int i = 0; i < N-1; i++) {\n\t\tint p, q;\n\t\tcin >> p >> q; --p, --q;\n\t\tG[p].push_back(q);\n\t\tG[q].push_back(p);\n\t}\n\t\n\tint maxd = 0;\n\tfunction<int(int, int)> dfs = [&](int u, int prev) {\n\t\tint ret = (int)(G[u].size() == 2);\n\t\tvint dat;\n\t\tfor (auto &v : G[u]) {\n\t\t\tif (v != prev) dat.push_back(dfs(v, u));\n\t\t}\n\n\t\tsort(begin(dat), end(dat), greater<>());\n\t\tint maxv = 0;\n\t\tif (dat.size() >= 1) {\n\t\t\tmaxv = dat[0];\n\t\t\tif (dat.size() >= 2) chmax(maxd, dat[0] + dat[1]);\n\t\t}\n\t\tchmax(maxd, ret + maxv);\n\t\treturn (ret + maxv);\n\t};\n\n\tint cnt = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif (G[i].size() == 1) {\n\t\t\tif (cnt == 0) {\n\t\t\t\tdfs(i, -1);\n\t\t\t\tcnt += maxd;\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t}\n\tcout << cnt << endl;\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\n#define MP(a,b) make_pair((a),(b))\n#define Manh(a,b) (abs((a).first-(b).first) + abs((a).second - ((b).second))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconst pii Dir[8] = { //?????????\n\t{ 0,1 },{ 0,-1 },{ 1,0 },{ -1,0 },\n\t{ 1,1 },{ 1,-1 },{ -1,-1 },{ -1,1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\n\nclass Graph {\npublic:\n\tint vn;\n\tvector<vector<pii>> g;\n\tvector<int> depth;\n\n\tGraph(int n) {\n\t\tvn = n;\n\t\tg.resize(n);\n\t}\n\tvoid con(int a, int b, int w = 1) {\n\t\tg[a].push_back({ b,w });\n\t\tg[b].push_back({ a, w });\n\t\t\n\t}\n};\n\n\n\nint TDiam(Graph& graph) {\n\tvector<bool> al(graph.vn);\n\tfunction<pii(int,int)> func = [&](int cur, int dis) {\n\t\tpii Max = { dis,cur };\n\t\tal[cur] = 1;\n\t\tREP(i, graph.g[cur].size()) {\n\t\t\tif (!al[graph.g[cur][i].first]) {\n\t\t\t\tMax = max(Max,func(graph.g[cur][i].first, dis+graph.g[cur][i].second));\n\t\t\t}\n\t\t}\n\n\t\treturn Max;\n\t};\n\n\tpii S = func(0,0);\n\tal = vector<bool>(graph.vn);\n\tpii G = func(S.second,0);\n\n\treturn G.first;\n}\n\nsigned main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\n\tGraph graph(n);\n\n\tREP(i, n-1) {\n\t\tint a, b;\n\t\tscanf(\"%d %d\", &a, &b);\n\t\ta--; b--;\n\t\tgraph.con(a, b);\n\t}\n\tint ans = n;\n\tREP(i, n) {\n\t\tans -= (graph.g[i].size() > 2);\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef pair<Weight, int> Result;\nResult visit(int p, int v, const Graph &g) {\n  Result r(0, v);\n  for(auto &e: g[v]) if (e.dst != p) {\n    Result t = visit(v, e.dst, g);\n    t.first += g[v].size()==2; //e->weight;\n    if (r.first < t.first) r = t;\n  }\n  return r;\n}\nWeight diameter(const Graph &g) {\n  Result r = visit(-1, 0, g);\n  Result t = visit(-1, r.second, g);\n  return t.first; // (r.second, t.second) is farthest pair\n}\n\nint main(){\n\tint V,s,t;\n\tscanf(\"%d\",&V);\n\tGraph g(V);\n\tfor(;V>1;V--)scanf(\"%d%d\",&s,&t),s--,t--,g[s].push_back(Edge(s,t,1)),g[t].push_back(Edge(t,s,1));\n\tprintf(\"%d\\n\",diameter(g)+count_if(g.begin(),g.end(),[](auto &e){return e.size()==1;}));\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct node { int t,next; }a[200010];\n\nint f[100010],g[100010],h[100010];\nint head[100010],d[100010],n,tot;\n\ninline int rd()\n{\n\tint x=0;char ch=getchar();\n\tfor (;ch<'0'||ch>'9';ch=getchar());\n\tfor (;ch>='0'&&ch<='9';ch=getchar()) x=x*10+ch-'0';\n\treturn x;\n}\n\ninline void add(int x,int y) { a[++tot].t=y;a[tot].next=head[x];head[x]=tot; }\n\ninline void dfs(int x,int y)\n{\n\tf[x]=g[x]=h[x]=(d[x]==2);\n\tfor (int i=head[x];i;i=a[i].next)\n\t{\n\t\tint t=a[i].t;\n\t\tif (t==y) continue;\n\t\tdfs(t,x);\n\t\tf[x]=max(f[x],max(f[t],g[x]+g[t]));\n\t\tg[x]=max(g[x],g[t]+h[x]);\n\t}\n}\n\nint main()\n{\n\tn=rd();tot=0;\n\tfor (int i=1;i<n;i++)\n\t{\n\t\tint x=rd(),y=rd();\n\t\tadd(x,y);add(y,x);\n\t\td[x]++;d[y]++;\n\t}\n\tdfs(1,0);\n\tint ans=f[1];\n\tfor (int i=1;i<=n;i++) if (d[i]==1) ans++;\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n \ntypedef int Weight;\ntypedef int Edge;\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n \ntypedef pair<Weight, int> Result;\nResult visit(int p, int v, const Graph &g) {\n  Result r(0, v);\n  int f = g[v].size()==2;\n  for(auto &e: g[v]) if (e != p) {\n    Result t = visit(v, e, g);\n    t.first += f; //e->weight;\n    if (r.first < t.first) r = t;\n  }\n  return r;\n}\nWeight diameter(const Graph &g) {\n  Result r = visit(-1, 0, g);\n  Result t = visit(-1, r.second, g);\n  return t.first; // (r.second, t.second) is farthest pair\n}\n \nint main(){\n\tint V,s,t;\n\tscanf(\"%d\",&V);\n\tGraph g(V);\n\tfor(;V>1;V--)scanf(\"%d%d\",&s,&t),s--,t--,g[s].emplace_back(t),g[t].emplace_back(s);\n\tprintf(\"%d\\n\",diameter(g)+count_if(g.begin(),g.end(),[](auto &e){return e.size()==1;}));\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\nusing namespace std;\nvector<pair<int, int>>X[1 << 17], Y[1 << 17]; int dist[1 << 17], N, A, B, C, root; queue<int>Q;\nint main() {\n    cin >> N;\n    for (int i = 0; i < N - 1; i++) { cin >> A >> B >> C; X[A].push_back(make_pair(B, C)); Y[B].push_back(make_pair(A, C)); }\n    for (int i = 0; i < N; i++) { if (Y[i].size() == 0) { root = i; } }\n    for (int i = 0; i < N; i++) { dist[i] = 1145141919; }Q.push(root); dist[root] = 0;\n    while (!Q.empty()) {\n        int a1 = Q.front(); Q.pop();\n        for (int i = 0; i < X[a1].size(); i++) {\n            int to = X[a1][i].first, a2 = X[a1][i].second;\n            if (dist[to] == 1145141919) { dist[to] = dist[a1] + a2; Q.push(to); }\n        }\n    }\n    int maxn = 0, maxid = 0;\n    for (int i = 0; i < N; i++) { if (maxn < dist[i]) { maxn = dist[i]; maxid = i; } }Q.push(maxid);\n    for (int i = 0; i < N; i++) { dist[i] = 1145141919; }dist[maxid] = 0;\n    while (!Q.empty()) {\n        int a1 = Q.front(); Q.pop(); maxn = 0; maxid = 0;\n        for (int i = 0; i < X[a1].size(); i++) {\n            int to = X[a1][i].first, a2 = X[a1][i].second;\n            if (dist[to] > dist[a1] + a2) { dist[to] = dist[a1] + a2; Q.push(to); }\n        }\n        for (int i = 0; i < Y[a1].size(); i++) {\n            int to = Y[a1][i].first, a2 = Y[a1][i].second;\n            if (dist[to] > dist[a1] + a2) { dist[to] = dist[a1] + a2; Q.push(to); }\n        }\n    }\n    for (int i = 0; i < N; i++) { if (maxn < dist[i]) { maxn = dist[i]; maxid = i; } }\n    cout << maxn+1 << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <vector>\n#include <map>\n#include <set>\n\nusing namespace std;\n\ntypedef pair<int , int> P2;\ntypedef pair<pair<int , int> , int> P3;\ntypedef pair<pair<int , int> , pair<int , int> > P4;\n#define Fst first\n#define Snd second\n#define PB(a) push_back(a)\n#define MP(a , b) make_pair((a) , (b))\n#define M3P(a , b , c) make_pair(make_pair((a) , (b)) , (c))\n#define M4P(a , b , c , d) make_pair(make_pair((a) , (b)) , make_pair((c) , (d)))\n#define repp(i,a,b) for(int i = (int)(a) ; i < (int)(b) ; ++i)\n#define repm(i,a,b) for(int i = (int)(a) ; i > (int)(b) ; --i)\n#define repv(t,it,v) for(vector<t>::iterator it = v.begin() ; it != v.end() ; ++it)\n\nint N;\nvector<int> V[100010];\nint ans = 0;\n\nint dfs(int p , int q){\n\tint a = 0;\n\tint b = 0;\n\tint c = max(0 , (int)V[q].size() - 3);\n\trepv(int,it,V[q]){\n\t\tif(p == (*it)) continue;\n\t\tint x = dfs(q,(*it)) + c + 1;\n\t\tif(x > a){\n\t\t\tb = a;\n\t\t\ta = x;\n\t\t} else if(x > b){\n\t\t\tb = x;\n\t\t}\n\t}\n\tans = max(ans , a + b);\n\treturn a;\n}\n\nint main(){\n\tscanf(\"%d\" , &N);\n\trepp(i,1,N){\n\t\tint a,b;\n\t\tscanf(\"%d%d\" , &a , &b);\n\t\tV[a].PB(b);\n\t\tV[b].PB(a);\n\t}\n\tdfs(-1,1);\n\tprintf(\"%d\\n\" , ans + 1);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[101010];\nint C[101010];\nint ma;\n\nint dfs(int cur,int pre) {\n\tvector<int> V={0,0};\n\tFORR(e,E[cur]) if(e!=pre) V.push_back(dfs(e,cur));\n\t\n\tsort(ALL(V));\n\treverse(ALL(V));\n\tma=max(ma, C[cur]+V[0]+V[1]);\n\tC[cur]+=V[0];\n\treturn C[cur];\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\t\n\tint leaf=0;\n\tint st=-1;\n\tFOR(i,N) {\n\t\tif(E[i].size()==1) leaf++;\n\t\tif(E[i].size()==2) {\n\t\t\tC[i]=1;\n\t\t\tst=i;\n\t\t}\n\t}\n\t\n\tif(st==-1) return _P(\"%d\\n\",leaf);\n\tdfs(st,-1);\n\t_P(\"%d\\n\",leaf+ma);\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 100002\n\nint n;\n\nvector<int> v[MAX];\n\nint dp[MAX];\n\nint ans;\nint ans2;\n\nint leaf[MAX];\n\nint cer;\n\nint wa;\n\n\ninline void dfs(int b,int pr){\n\tvector<int> ret;\n\tfor(int go:v[b]){\n\t\tif(go==pr)continue;\n\t\tdfs(go,b);\n\t\tleaf[b]+=leaf[go];\n\t\tret.push_back(dp[go]);\n\t}\n\tleaf[b]+=(v[b].size()==1);\n\tsort(ret.begin(),ret.end(),greater<int>());\n\twhile(ret.size()<=2)ret.push_back(0);\n\tif(true){\n\t\twa=max(wa,(v[b].size()==2)+ret[0]+ret[1]);\n\t}\n\tdp[b]=max(dp[b],(v[b].size()==2)+ret[0]);\n\treturn;\n}\n\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tdfs(0,-1);\n\tdp[0]=max(dp[0],wa);\n\tcout<<dp[0]+leaf[0]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\nvoid func(vector<vector<int>>&edge, vector<int>&dp, int &ans, int node = 0, int p = -1) {\n\tvector<int>box;\n\tfor (auto i : edge[node]) {\n\t\tif (i == p)continue;\n\t\tfunc(edge, dp, ans, i, node);\n\t\tbox.push_back(dp[i]);\n\t}\n\tsort(box.rbegin(), box.rend());\n\tif (box.empty()) {\n\t\tdp[node] = 1;\n\t\tans = max(ans, 1);\n\t}\n\telse if (box.size() == 1) {\n\t\tdp[node] = box[0] + 1;\n\t\tans = max(ans, dp[node]);\n\t}\n\telse if(box.size()==2){\n\t\tdp[node] = accumulate(box.begin(), box.end(), 0);\n\t\tans = max(ans, dp[node] + 1);\n\t}\n\telse {\n\t\tdp[node] = accumulate(box.begin(), box.end(), 0);\n\t\tans = max(ans, dp[node]);\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>edge(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> L >> R;\n\t\tL--, R--;\n\t\tedge[L].push_back(R);\n\t\tedge[R].push_back(L);\n\t}\n\tint ans = 0;\n\tvector<int>dp(N);\n\tfunc(edge, dp, ans);\n\t//for (int i = 0; i < N; i++) {\n\t//\tcout << i << \" \" << dp[i] << endl;\n\t//}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,a,b,cnt,dist[110000];vector<int>x[110000];bool used[110000];\nvoid dfs(int pos,int depth){\n\tif(used[pos]==true)return;\n\tused[pos]=true;dist[pos]=depth;\n\tfor(int i=0;i<x[pos].size();i++)dfs(x[pos][i],depth+(x[pos].size()==2));\n}\nint main(){\n\tcin>>n;for(int i=1;i<=n-1;i++){cin>>a>>b;x[a].push_back(b);x[b].push_back(a);}\n\tfor(int i=1;i<=n;i++){if(x[i].size()==1)cnt++;}\n\tfor(int i=1;i<=n;i++)used[i]=false;dfs(1,0);\n\tint maxn=0,maxid=0;for(int i=1;i<=n;i++){if(maxn<dist[i]){maxn=dist[i];maxid=i;}}\n\tfor(int i=1;i<=n;i++)used[i]=false;dfs(maxid,0);\n\tsort(dist+1,dist+n+1);\n\tcout<<cnt+dist[n]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint N,ans;\nvector<int>G[1<<17];\nint dp[1<<17],cr[1<<17];\nint dfs1(int u,int p)\n{\n\tint mt=0;\n\tint get=0;\n\tif(G[u].size()==1&&G[u][0]==p)cr[u]=1;\n\tfor(int v:G[u])if(v!=p)\n\t{\n\t\tint t=dfs1(v,u);\n\t\tcr[u]+=cr[v];\n\t\tif(mt<t-cr[v])mt=t-cr[v];\n\t\tif(get<t+1)get=t+1;\n\t}\n\tdp[u]=max(cr[u]+mt,get);\n\treturn dp[u];\n}\nvoid dfs2(int u,int p,int pcr,int pt)\n{\n\tint sr=cr[u]+pcr;\n\tint mt=pt-pcr;\n\tif(mt<0)mt=0;\n\tint m1t=0,m2t=0;\n\tint g1=pt+1,g2=0;\n\tfor(int v:G[u])if(v!=p)\n\t{\n\t\tint t=dp[v]-cr[v];\n\t\tif(mt<t)mt=t;\n\t\tif(m1t<t)\n\t\t{\n\t\t\tm2t=m1t;\n\t\t\tm1t=t;\n\t\t}\n\t\telse if(m2t<t)m2t=t;\n\t\tif(g1<dp[v]+1)\n\t\t{\n\t\t\tg2=g1;\n\t\t\tg1=dp[v]+1;\n\t\t}\n\t\telse if(g2<dp[v]+1)g2=dp[v]+1;\n\t}\n\tans=max(ans,sr+mt);\n\tfor(int v:G[u])if(v!=p)\n\t{\n\t\tint t=dp[v]-cr[v];\n\t\tdfs2(v,u,sr-cr[v],max(max((t==m1t?m2t:m1t)+sr-cr[v],dp[v]+1==g1?g2:g1),sr-cr[v]));\n\t}\n}\nmain()\n{\n\tcin>>N;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint u,v;cin>>u>>v;u--,v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tint root=0;\n\twhile(root<N&&G[root].size()==1)root++;\n\tif(root==N)\n\t{\n\t\tcout<<N<<endl;\n\t\treturn 0;\n\t}\n\tdfs1(root,-1);\n\tdfs2(root,-1,0,0);\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5;\n\ntemplate<class T1, class T2>\nvoid chmax(T1 &a, T2 b) {\n    if (a < b) a = b;\n}\n\npair<int, int> max2(pair<int, int> a, int b) {\n    if (a.first < b) swap(a.first, b);\n    if (a.second < b) swap(a.second, b);\n    return a;\n}\n\nstruct DP {\n    int path = 0;\n    int leaves[3] = {};\n\n    int get_max() {\n        return max({ path + 1, leaves[0], leaves[1], leaves[2] });\n    }\n};\n\nDP add(DP a) {\n    a.path++;\n    return a;\n}\n\nDP operator+(const DP &a, const DP &b) {\n    DP res;\n    res.path = max(a.path, b.path);\n    res.leaves[2] = max({\n        a.leaves[2] + b.leaves[0],\n        a.leaves[1] + b.leaves[1],\n        a.leaves[0] + b.leaves[2],\n    });\n    res.leaves[1] = max({\n        a.leaves[0] + b.leaves[1],\n        a.leaves[1] + b.leaves[0],\n        a.leaves[0] + b.path,\n        a.path + b.leaves[0],\n    });\n    res.leaves[0] = a.leaves[0] + b.leaves[0];\n    return res;\n}\n\nvector<int> g[N], gg[N];\nDP dp[N];\nint ans = 0;\n\nvoid dfs(int u, int p) {\n    for (int v : g[u]) if (v != p) {\n        gg[u].push_back(v);\n    }\n    if (gg[u].empty() || (p == -1 && gg[u].size() == 1)) {\n        dp[u].leaves[0] = 1;\n    }\n    for (int v : gg[u]) {\n        dfs(v, u);\n        dp[u] = dp[u] + add(dp[v]);\n    }\n}\n\nvoid dfs2(int u, DP par) {\n    vector<DP> sumR(gg[u].size() + 1);\n    for (int i = (int)gg[u].size() - 1; i >= 0; i--) {\n        sumR[i] = sumR[i + 1] + add(dp[gg[u][i]]);\n    }\n    pair<int, int> dia(par.path, 0);\n    if (par.path < 0) swap(dia.first, dia.second);\n    for (int i = 0; i < gg[u].size(); i++) {\n        dia = max2(dia, dp[gg[u][i]].path);\n    }\n    ans = max(ans, (sumR[0] + par).get_max());\n    ans = max(ans, dia.first + dia.second + 1);\n    DP sumL;\n    for (int i = 0; i < gg[u].size(); i++) {\n        int v = gg[u][i];\n        dfs2(v, add(par) + sumL + sumR[i + 1]);\n        sumL = sumL + add(dp[gg[u][i]]);\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    dfs(0, -1);\n    DP ini;\n    ini.path = -1;\n    dfs2(0, ini);\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\nusing pint = pair<int, int>;\nusing plint = pair<lint, lint>;\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin),i##_end_=(end);i<i##_end_;i++)\n#define IFOR(i, begin, end) for(int i=(end)-1,i##_begin_=(begin);i>=i##_begin_;i--)\n#define REP(i, n) FOR(i,0,n)\n#define IREP(i, n) IFOR(i,0,n)\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &vec){ for (auto &v : vec) is >> v; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &vec){ os << \"[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const deque<T> &vec){ os << \"deq[\"; for (auto v : vec) os << v << \",\"; os << \"]\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_set<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const unordered_multiset<T> &vec){ os << \"{\"; for (auto v : vec) os << v << \",\"; os << \"}\"; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &pa){ os << \"(\" << pa.first << \",\" << pa.second << \")\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename TK, typename TV> ostream &operator<<(ostream &os, const unordered_map<TK, TV> &mp){ os << \"{\"; for (auto v : mp) os << v.first << \"=>\" << v.second << \",\"; os << \"}\"; return os; }\ntemplate<typename T> void ndarray(vector<T> &vec, int len) { vec.resize(len); }\ntemplate<typename T, typename... Args> void ndarray(vector<T> &vec, int len, Args... args) { vec.resize(len); for (auto &v : vec) ndarray(v, args...); }\ntemplate<typename T> void Max(T &m, const T q) { if (m < q) m = q; }\ntemplate<typename T> void Min(T &m, const T q) { if (m > q) m = q; }\ntemplate<typename T1, typename T2> pair<T1, T2> operator+(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first + r.first, l.second + r.second); }\ntemplate<typename T1, typename T2> pair<T1, T2> operator-(pair<T1, T2> &l, pair<T1, T2> &r) { return make_pair(l.first - r.first, l.second - r.second); }\n#define dbg(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \") \" << __FILE__ << endl;\n\nint N;\nconstexpr int Nmax = 100000;\nvector<int> to[Nmax];\n\nint ans2;\n\nint dfs(int now, int prv)\n{\n    vector<int> tmp;\n    for (auto nxt : to[now]) if (nxt != prv) tmp.push_back(dfs(nxt, now));\n\n    if (tmp.empty()) return 1;\n\n    sort(tmp.rbegin(), tmp.rend());\n\n    if (tmp.size() > 1) Max(ans2, tmp[0] + tmp[1] + 1);\n    int ippon = tmp[0] + 1;\n    int all = accumulate(tmp.begin(), tmp.end(), 0);\n    return max(ippon, all);\n}\n\nint main()\n{\n    cin >> N;\n    REP(_, N - 1)\n    {\n        int p, q;\n        cin >> p >> q;\n        p--;\n        q--;\n        to[p].push_back(q);\n        to[q].push_back(p);\n    }\n\n    ans2 = 0;\n    int ans = dfs(0, -1);\n    cout << max(ans, ans2) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 100002\n\nint n;\n\nvector<int> v[MAX];\n\nint dp[MAX];\n\nint ans;\n\ninline void dfs(int b,int pr){\n\tvector<int> ret;\n\tfor(int go:v[b]){\n\t\tif(go==pr)continue;\n\t\tdfs(go,b);\n\t\tret.push_back(dp[go]);\n\t}\n\tsort(ret.begin(),ret.end(),greater<int>());\n\tif(ret.size()>=2){\n\t\tans=max(ans,ret[0]+ret[1]+1);\n\t}\n\tdp[b]=1;\n\tif(ret.size()>=1){\n\t\tdp[b]+=ret[0];\n\t}\n\tint tmp=1;\n\tfor(int j=0;j<ret.size();j++){\n\t\tif(j>=1){\n\t\t\tret[j]=1;\n\t\t}\n\t\ttmp+=ret[j];\n\t}\n\tdp[b]=max(dp[b],tmp);\n\tans=max(ans,dp[b]);\n}\n\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tdfs(0,-1);\n\tcout<<ans<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }\n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n;\n  cin>>n;\n\n  vector< vector<int> > G(n);\n  for(int i=1;i<n;i++){\n    int p,q;\n    cin>>p>>q;\n    p--;q--;\n    G[p].emplace_back(q);\n    G[q].emplace_back(p);\n  }\n\n  vector<int> dp1(n,0),dp2(n,0);\n  int ans=0;\n  MFP([&](auto dfs,int v,int p)->void{\n        int sum=0,mx=0;\n        vector<int> vs;\n        for(int u:G[v]){\n          if(u==p) continue;\n          dfs(u,v);\n          sum+=dp2[u];\n          chmax(mx,dp1[u]);\n          vs.emplace_back(dp1[u]-dp2[u]);\n        }\n        if(vs.empty()){\n          dp1[v]=1;\n          dp2[v]=1;\n          return;\n        }\n        while(vs.size()<2) vs.emplace_back(0);\n        sort(vs.rbegin(),vs.rend());\n\n        /*\n        cout<<\"v: \"<<v<<\", sum:\"<<sum<<endl;\n        for(int w:vs) cout<<w<<\" \";\n        cout<<endl;\n        */\n\n        // c1 -> v -> c2, take v\n        chmax(ans,sum+vs[0]+1+vs[1]);\n\n        // c1 -> v, take v\n        chmax(dp1[v],mx+1);\n\n        // c1 -> v, not take v\n        chmax(dp1[v],vs[0]+sum);\n\n        // not take v\n        chmax(dp2[v],sum);\n\n        chmax(dp1[v],dp2[v]);\n        // cout<<v<<\", dp1[v] = \"<<dp1[v]<<\", dp2[v] = \"<<dp2[v]<<endl;\n      })(0,-1);\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nvector<int> G[100010];\nint N,A,B;\n\nint dfs(int x, int l)\n{\n\tvector<int> u;\n\tfor (int y : G[x]) if (y != l){\n\t\tu.push_back(dfs(y,x));\n\t}\n\n\tint mx = 0;\n\tfor (int i=0;i<u.size();i++) mx = max(mx,u[i]);\n\tif (G[x].size() == 2){\n\t\tmx++;\n\t\tif (u.size() == 2){\n\t\t\tB = max(B, u[0] + u[1] + 1);\n\t\t}\n\t\telse{\n\t\t\tB = max(B,mx);\n\t\t}\n\t}\n\treturn mx;\n}\n\nint main()\n{\n\tscanf (\"%d\",&N);\n\tfor (int i=1;i<N;i++){\n\t\tint x,y; scanf (\"%d %d\",&x,&y);\n\t\tG[x].push_back(y);\n\t\tG[y].push_back(x);\n\t}\n\tfor (int i=1;i<=N;i++) if (G[i].size() == 1) A++;\n\n\tdfs(1,0);\n\tprintf (\"%d\\n\",A+B);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 16.12.2019 13:30:15       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<vector<int>> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int x, y;\n    cin >> x >> y;\n    --x; --y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  int ans = 0;\n  vector<pair<int, int>> down(n);\n  function<pair<int, int>(int, int)> Dfs = [&](int v, int pr) {\n    int one = 1;\n    int two = 0;\n    int profit = 0;\n    for (int u : g[v]) {\n      if (u == pr) {\n        continue;\n      }\n      auto res = Dfs(u, v);\n      one = max(one, 1 + res.first);\n      two += res.second;\n      profit = max(profit, res.first - res.second);\n    }\n    one = max(one, two + profit);\n    two = max(two, 1);\n    ans = max(ans, one);\n    return down[v] = make_pair(one, two);\n  };\n  Dfs(0, -1);\n  function<void(int, int, pair<int, int>)> Solve = [&](int v, int pr, pair<int, int> up) {\n    vector<pair<int, int>> children;\n    for (int u : g[v]) {\n      if (u == pr) {\n        continue;\n      }\n      children.push_back(down[u]);\n    }\n    int sz = (int) children.size();\n    vector<int> pref_one(sz + 1);\n    vector<int> pref_two(sz + 1);\n    vector<int> pref_profit(sz + 1);\n    vector<int> suf_one(sz + 1);\n    vector<int> suf_two(sz + 1);\n    vector<int> suf_profit(sz + 1);\n    pref_one[0] = 1;\n    for (int i = 0; i < sz; i++) {\n      pref_one[i + 1] = max(pref_one[i], 1 + children[i].first);\n      pref_two[i + 1] = pref_two[i] + children[i].second;\n      pref_profit[i + 1] = max(pref_profit[i], children[i].first - children[i].second);\n    }\n    suf_one[sz] = 1;\n    for (int i = sz - 1; i >= 0; i--) {\n      suf_one[i] = max(suf_one[i + 1], 1 + children[i].first);\n      suf_two[i] = suf_two[i + 1] + children[i].second;\n      suf_profit[i] = max(suf_profit[i + 1], children[i].first - children[i].second);\n    }\n    ans = max(ans, max(max(pref_one.back(), 1 + up.first), pref_two.back() + up.second + max(pref_profit.back(), up.first - up.second)));\n    int ptr = 0;\n    for (int u : g[v]) {\n      if (u == pr) {\n        continue;\n      }\n      int one = 1 + up.first;\n      int two = up.second;\n      int profit = up.first - up.second;\n      one = max(one, max(pref_one[ptr], suf_one[ptr + 1]));\n      two += pref_two[ptr] + suf_two[ptr + 1];\n      profit = max(profit, max(pref_profit[ptr], suf_profit[ptr + 1]));\n      one = max(one, two + profit);\n      two = max(two, 1);\n      Solve(u, v, make_pair(one, two));\n      ptr += 1;\n    }\n  };\n  Solve(0, -1, make_pair(0, 0));\n  cout << ans << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\nint main() {\n    int N; cin >> N;\n    vector<vector<int>> G(N);\n    for (int i = 0; i < N - 1; i++) {\n        int p, q; cin >> p >> q; p--, q--;\n        G[p].push_back(q);\n        G[q].push_back(p);\n    }\n    int nleaf = 0;\n    vector<int> value(N);\n    for (int i = 0; i < N; i++) {\n        if (G[i].size() == 1) nleaf++;\n        if (G[i].size() == 2) value[i] = 1;\n    }\n    auto far = [&](int node) {\n        vector<int> score(N);\n        stack<tuple<int, int, int>> S;\n        S.emplace(value[node], node, node);\n        while (!S.empty()) {\n            auto [s, n, p] = S.top(); S.pop();\n            score[n] = s;\n            for (int next : G[n]) if (next != p) {\n                S.emplace(s + value[next], next, n);\n            }\n        }\n        auto it = max_element(begin(score), end(score));\n        return make_pair(it - begin(score), *it);\n    };\n    auto p = far(0);\n    auto q = far(p.first);\n    cout << nleaf + q.second << '\\n';\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n/*#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\nusing namespace __gnu_pbds;\ntemplate<typename T> using gpp_set = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T, typename L> using gpp_map = tree<T, L, less<T>, rb_tree_tag, tree_order_statistics_node_update>;\ntemplate<typename T> using gpp_multiset = tree<T, null_type, less_equal<T>, rb_tree_tag, tree_order_statistics_node_update>;*/\nstruct fast_ios { fast_ios(){ cin.tie(0); ios::sync_with_stdio(false); cout << fixed << setprecision(20); }; } fast_ios_;\n#define FOR(i, begin, end) for(int i=(begin);i<(end);i++)\n#define REP(i, n) FOR(i,0,n)\n#define IFOR(i, begin, end) for(int i=(end)-1;i>=(begin);i--)\n#define IREP(i, n) IFOR(i,0,n)\n#define Sort(v) sort(v.begin(), v.end())\n#define Reverse(v) reverse(v.begin(), v.end())\n#define all(v) v.begin(),v.end()\n#define SZ(v) ((int)v.size())\n#define Lower_bound(v, x) distance(v.begin(), lower_bound(v.begin(), v.end(), x))\n#define Upper_bound(v, x) distance(v.begin(), upper_bound(v.begin(), v.end(), x))\n#define Max(a, b) a = max(a, b)\n#define Min(a, b) a = min(a, b)\n#define bit(n) (1LL<<(n))\n#define bit_exist(x, n) ((x >> n) & 1)\n#define debug(x) cout << #x << \"=\" << x << endl;\n#define vdebug(v) { cout << #v << \"=\" << endl; REP(i_debug, v.size()){ cout << v[i_debug] << \",\"; } cout << endl; }\n#define mdebug(m) { cout << #m << \"=\" << endl; REP(i_debug, m.size()){ REP(j_debug, m[i_debug].size()){ cout << m[i_debug][j_debug] << \",\"; } cout << endl;} }\n#define Return(ans) { cout << (ans) << endl; return 0; }\n#define pb push_back\n#define f first\n#define s second\n#define int long long\n#define INF 1000000000000000000\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v){ for (auto &x : v) is >> x; return is; }\ntemplate<typename T> ostream &operator<<(ostream &os, vector<T> &v){ for(int i = 0; i < v.size(); i++) { cout << v[i]; if(i != v.size() - 1) cout << endl; }; return os; }\ntemplate<typename T1, typename T2> ostream &operator<<(ostream &os, pair<T1, T2> p){ cout << '(' << p.first << ',' << p.second << ')'; return os; }\ntemplate<typename T> void Out(T x) { cout << x << endl; }\ntemplate<typename T1, typename T2> void Ans(bool f, T1 y, T2 n) { if(f) Out(y); else Out(n); }\n\nusing vec = vector<int>;\nusing mat = vector<vec>;\nusing Pii = pair<int, int>;\nusing PiP = pair<int, Pii>;\nusing PPi = pair<Pii, int>;\nusing Pdi = pair<double, int>;\nusing bools = vector<bool>;\nusing pairs = vector<Pii>;\n\n//int dx[4] = {1,0,-1,0};\n//int dy[4] = {0,1,0,-1};\n//char d[4] = {'D','R','U','L'};\n\nconst int mod = 1000000007;\n//const int mod = 998244353;\n//#define Add(x, y) x = (x + (y)) % mod\n//#define Mult(x, y) x = (x * (y)) % mod\n\nstruct edge{int to, cost, id;};\n\nclass Graph\n{\npublic:\n    int N;\n    vector<vector<edge>> G;\n\n    Graph(int N): N(N){\n        G = vector<vector<edge>>(N, vector<edge>(0));\n    }\n\n    void add_Directed_edge(int from, int to, int cost = 1, int id = 0){\n        G[from].push_back(edge({to, cost, id}));\n    }\n\n    void add_Undirected_edge(int v1, int v2, int cost = 1, int id = 0){\n        add_Directed_edge(v1, v2, cost, id);\n        add_Directed_edge(v2, v1, cost, id);\n    }\n\n    //calculate diameter of a Tree\n    void dfs_for_calcdist(int v, int p, int c, vec &dist){\n        if(p != -1) dist[v] = dist[p] + c;\n        for(auto e: G[v]) if(e.to != p){\n            int t = max(1LL, SZ(G[e.to]) - 2);\n            dfs_for_calcdist(e.to, v, t, dist);\n        }\n    } \n\n    int diameter(int &v1, int &v2, int s = 0){\n        vec dist(N, 0);\n        dfs_for_calcdist(s, -1, -1, dist);\n        v1 = distance(dist.begin(), max_element(dist.begin(), dist.end()));\n        fill(dist.begin(), dist.end(), 0);\n        dfs_for_calcdist(v1, -1, -1, dist);\n        auto amax = max_element(dist.begin(), dist.end());\n        v2 = distance(dist.begin(), amax);\n        return *amax;\n    }\n\n};\n\nsigned main(){\n\n    int N; cin >> N;\n    Graph G(N);\n    REP(i, N - 1){\n        int p, q; cin >> p >> q;\n        G.add_Undirected_edge(p - 1, q - 1);\n    }\n\n    int s, t;\n    int R = G.diameter(s, t);\n    Out(R + 1);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\nvoid func(vector<vector<int>>&edge, vector<int>&dp, int &ans, int node = 0, int p = -1) {\n\tvector<int>box;\n\tfor (auto i : edge[node]) {\n\t\tif (i == p)continue;\n\t\tfunc(edge, dp, ans, i, node);\n\t\tbox.push_back(dp[i]);\n\t}\n\tsort(box.rbegin(), box.rend());\n\tif (box.empty()) {\n\t\tdp[node] = 1;\n\t\tans = max(ans, 1);\n\t}\n\telse if (box.size() == 1) {\n\t\tdp[node] = box[0] + 1;\n\t\tans = max(ans, dp[node]);\n\t}\n\telse {\n\t\tdp[node] = accumulate(box.begin(), box.end(), 0);\n\t\tans = max(ans, dp[node] + 1);\n\t}\n\treturn;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N;\n\tvector<vector<int>>edge(N);\n\tfor (int i = 1; i < N; i++) {\n\t\tcin >> L >> R;\n\t\tL--, R--;\n\t\tedge[L].push_back(R);\n\t\tedge[R].push_back(L);\n\t}\n\tint ans = 0;\n\tvector<int>dp(N);\n\tfunc(edge, dp, ans);\n\t//for (int i = 0; i < N; i++) {\n\t//\tcout << i << \" \" << dp[i] << endl;\n\t//}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1e5;\n\ntemplate<class T1, class T2>\nvoid chmax(T1 &a, T2 b) {\n    if (a < b) a = b;\n}\n\npair<int, int> max2(pair<int, int> a, int b) {\n    if (a.first < b) swap(a.first, b);\n    if (a.second < b) swap(a.second, b);\n    return a;\n}\n\nstruct DP {\n    int path = 0;\n    int leaves[3] = {};\n\n    int get_max() {\n        return max({ path + 1, leaves[0], leaves[1], leaves[2] });\n    }\n};\n\nvoid show(DP d) {\n    printf(\"%d %d %d %d\\n\", d.path, d.leaves[0], d.leaves[1], d.leaves[2]);\n}\n\nDP add(DP a, bool l) {\n    a.path++;\n    if (l) a.leaves[0]++;\n    return a;\n}\n\nDP operator+(const DP &a, const DP &b) {\n    DP res;\n    res.path = max(a.path, b.path);\n    res.leaves[2] = max({\n        a.leaves[2] + b.leaves[0],\n        a.leaves[1] + b.leaves[1],\n        a.leaves[0] + b.leaves[2],\n    });\n    res.leaves[1] = max({\n        a.leaves[0] + b.leaves[1],\n        a.leaves[1] + b.leaves[0],\n        a.leaves[0] + b.path,\n        a.path + b.leaves[0],\n    });\n    res.leaves[0] = a.leaves[0] + b.leaves[0];\n    return res;\n}\n\nvector<int> g[N], gg[N];\nDP dp[N];\nbool is_leaf[N];\nint ans = 0;\n\nDP get_dp(int u) {\n    return add(dp[u], is_leaf[u]);\n}\n\nvoid dfs(int u, int p) {\n    for (int v : g[u]) if (v != p) {\n        gg[u].push_back(v);\n    }\n    if (gg[u].empty() || (p == -1 && gg[u].size() == 1)) {\n        is_leaf[u] = true;\n    }\n    for (int v : gg[u]) {\n        dfs(v, u);\n        dp[u] = dp[u] + get_dp(v);\n    }\n}\n\nvoid dfs2(int u, int p, DP par) {\n    vector<DP> sumR(gg[u].size() + 1);\n    for (int i = (int)gg[u].size() - 1; i >= 0; i--) {\n        int v = gg[u][i];\n        sumR[i] = sumR[i + 1] + get_dp(v);\n    }\n    DP foo = sumR[0];\n    if (p != -1) foo = foo + add(par, is_leaf[p]);\n    // cout << u << \":\";\n    // show(foo);\n    ans = max(ans, foo.get_max());\n    pair<int, int> dia(par.path, 0);\n    if (par.path < 0) swap(dia.first, dia.second);\n    for (int i = 0; i < gg[u].size(); i++) {\n        int v = gg[u][i];\n        dia = max2(dia, dp[v].path);\n    }\n    ans = max(ans, dia.first + dia.second + 1);\n    DP sumL;\n    for (int i = 0; i < gg[u].size(); i++) {\n        int v = gg[u][i];\n        DP tmp = sumL + sumR[i + 1];\n        if (p != -1) {\n            tmp = tmp + add(par, is_leaf[p]);\n        }\n        dfs2(v, u, tmp);\n        sumL = sumL + get_dp(v);\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    dfs(0, -1);\n    dfs2(0, -1, DP());\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nvector<int> E[101010];\nint D[101010];\n\nvoid dfs(int cur,int pre,int d) {\n\tD[cur]=d;\n\tFORR(r,E[cur]) if(r!=pre) dfs(r,cur,d+1);\n}\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N-1) {\n\t\tcin>>x>>y;\n\t\tE[x-1].push_back(y-1);\n\t\tE[y-1].push_back(x-1);\n\t}\n\tint ret=N;\n\tFOR(i,N) if(E[i].size()>=3) ret--;\n\tcout<<ret<<endl;\n\t\n\t/*\n\tdfs(0,-1,0);\n\tx = max_element(D,D+N)-D;\n\tdfs(x,-1,0);\n\t\n\tcout<<*max_element(D,D+N)+1<<endl;\n\t*/\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n';\n\tFOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tsolve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n\n#define MAX 100002\n\nint n;\n\nvector<int> v[MAX];\n\nint dp[MAX];\n\nint ans;\nint ans2;\n\nint leaf[MAX];\n\nint cer;\n\n\ninline void dfs(int b,int pr){\n\tvector<int> ret;\n\tvector<int> ret2;\n\tfor(int go:v[b]){\n\t\tif(go==pr)continue;\n\t\tdfs(go,b);\n\t\tleaf[b]+=leaf[go];\n\t\tret.push_back(dp[go]);\n\t\tret2.push_back(dp[go]+leaf[go]);\n\t}\n\tleaf[b]+=(ret.size()==0);\n\tsort(ret.begin(),ret.end(),greater<int>());\n\tsort(ret2.begin(),ret2.end(),greater<int>());\n\tif(ret.size()>=2){\n\t\tcer=max(cer,1+ret2[0]+ret2[1]);\n\t}\n\tif(ret.size()>=1){\n\t\tcer=max(cer,1+ret2[0]);\n\t}\n\tif(ret.size())dp[b]=max(dp[b],(ret.size()==1)+ret[0]);\n\tcer=max(cer,dp[b]+leaf[b]);\n}\n\nint main(){\n\tcin>>n;\n\tfor(int i=1;i<n;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tv[a].push_back(b);\n\t\tv[b].push_back(a);\n\t}\n\tans2=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(v[i].size()==1){\n\t\t\tans2++;\n\t\t}\n\t}\n\tdfs(0,-1);\n\tcout<<cer<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint N,ans;\nvector<int>G[1<<17];\nint dp[1<<17],cr[1<<17];\nint dfs1(int u,int p)\n{\n\tint mt=0;\n\tint get=0;\n\tif(G[u].size()==1&&G[u][0]==p)cr[u]=1;\n\tfor(int v:G[u])if(v!=p)\n\t{\n\t\tint t=dfs1(v,u);\n\t\tcr[u]+=cr[v];\n\t\tif(mt<t-cr[v])mt=t-cr[v];\n\t\tif(get<t+1)get=t+1;\n\t}\n\tdp[u]=max(cr[u]+mt,get);\n\treturn dp[u];\n}\nvoid dfs2(int u,int p,int pcr,int pt)\n{\n\tint sr=cr[u]+pcr;\n\tint mt=pt-pcr;\n\tif(mt<0)mt=0;\n\tint m1t=0,m2t=0;\n\tint g1=pt+1,g2=0;\n\tfor(int v:G[u])if(v!=p)\n\t{\n\t\tint t=dp[v]-cr[v];\n\t\tif(mt<t)mt=t;\n\t\tif(m1t<t)\n\t\t{\n\t\t\tm2t=m1t;\n\t\t\tm1t=t;\n\t\t}\n\t\telse if(m2t<t)m2t=t;\n\t\tif(g1<dp[v]+1)\n\t\t{\n\t\t\tg2=g1;\n\t\t\tg1=dp[v]+1;\n\t\t}\n\t\telse if(g2<dp[v]+1)g2=dp[v]+1;\n\t}\n\tans=max(ans,sr+mt);\n\tfor(int v:G[u])if(v!=p)\n\t{\n\t\tint t=dp[v]-cr[v];\n\t\tdfs2(v,u,sr-cr[v],max(max((t==m1t?m2t:m1t)+sr-cr[v],dp[v]+1==g1?g2:g1),sr-cr[v]));\n\t}\n}\nmain()\n{\n\tcin>>N;\n\tfor(int i=1;i<N;i++)\n\t{\n\t\tint u,v;cin>>u>>v;u--,v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tint root=0;\n\twhile(root<N&&G[root].size()<=2)root++;\n\tif(root==N)\n\t{\n\t\tcout<<N<<endl;\n\t\treturn 0;\n\t}\n\tdfs1(root,-1);\n\tdfs2(root,-1,0,0);\n\tcout<<ans<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n;\nvi g[125252];\n\nint dfs(int p,int bef,int &ans){\n  if(g[p].size()==1)return 0;\n  int a=0, b=0;\n  REP(i,g[p].size()){\n    int to = g[p][i];\n    if(to==bef)continue;\n    int x = dfs(to,p,ans);\n    if(x>a){\n      b=a;a=x;\n    }else if(x>b){\n      b=x;\n    }\n    // printf(\"%d : %d\\n\",p,x);\n  }\n  // printf(\"%d : %d, %d\\n\",p,a,b);\n  if(g[p].size()==2)a++;\n  CHMAX(ans,a+b);\n  return a;\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  REP(i,n-1){\n    int x,y;\n    scanf(\"%d%d\",&x,&y);\n    --x;--y;\n    g[x].push_back(y);\n    g[y].push_back(x);\n  }\n  int ans = 0;\n  int root = -1;\n  REP(i,n){\n    if(g[i].size()==1){\n      ans++;\n    }else if(g[i].size()==2){\n      root = i;\n    }\n  }\n  if(root != -1){\n    int add=0;\n    dfs(root,-1,add);\n    ans += add;\n  }\n  printf(\"%d\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\n\ntemplate<typename F>\nstruct FixPoint : F{\n  FixPoint(F&& f):F(forward<F>(f)){}\n  template<typename... Args>\n  decltype(auto) operator()(Args&&... args) const{\n    return F::operator()(*this,forward<Args>(args)...);\n  }\n};\ntemplate<typename F>\ninline decltype(auto) MFP(F&& f){\n  return FixPoint<F>{forward<F>(f)};\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  int n;\n  cin>>n;\n\n  vector< vector<int> > G(n);\n  for(int i=1;i<n;i++){\n    int p,q;\n    cin>>p>>q;\n    p--;q--;\n    G[p].emplace_back(q);\n    G[q].emplace_back(p);\n  }\n\n  vector<int> dp1(n,0),dp2(n,0),dp3(n,0);\n  int ans=0;\n  MFP([&](auto dfs,int v,int p)->void{\n        int sum=0;\n        vector<int> vs,mx;\n        for(int u:G[v]){\n          if(u==p) continue;\n          dfs(u,v);\n          sum+=dp2[u];\n          mx.emplace_back(dp1[u]);\n          vs.emplace_back(dp1[u]-dp2[u]);\n        }\n        if(vs.empty()){\n          dp1[v]=1;\n          dp2[v]=1;\n          dp3[v]=1;\n          return;\n        }\n        while(vs.size()<2) vs.emplace_back(0);\n        while(mx.size()<2) mx.emplace_back(0);\n        sort(vs.rbegin(),vs.rend());\n        sort(mx.rbegin(),mx.rend());\n\n        // c1 -> v -> c2, not take v\n        chmax(dp3[v],sum+vs[0]+vs[1]);\n        chmax(dp3[v],mx[0]+mx[1]);\n\n        for(int u:G[v]){\n          if(u==p) continue;\n          chmax(dp3[v],sum-dp2[u]+dp3[u]);\n          chmax(ans,dp3[u]+1);\n        }\n\n        // c1 -> v, take v\n        chmax(dp1[v],mx[0]+1);\n\n        // c1 -> v, not take v\n        chmax(dp1[v],sum+vs[0]);\n\n        // not take v\n        chmax(dp2[v],sum);\n\n        // c1 -> v -> c2, take v\n        chmax(ans,mx[0]+1+mx[1]);\n        chmax(ans,dp1[v]);\n        chmax(ans,dp2[v]);\n        chmax(ans,dp3[v]);\n\n        return;\n        cout<<v;\n        cout<<\", dp1[v] = \"<<dp1[v];\n        cout<<\", dp2[v] = \"<<dp2[v];\n        cout<<\", dp3[v] = \"<<dp3[v]<<endl;\n      })(0,-1);\n\n  cout<<ans<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint h[100010],nex[200010],to[200010],M;\nvoid add(int a,int b){\n\tM++;\n\tto[M]=b;\n\tnex[M]=h[a];\n\th[a]=M;\n}\nint d[100010],v[100010],f[100010],g[100010];\nvoid dfs(int fa,int x){\n\tf[x]=g[x]=v[x];\n\tfor(int i=h[x];i;i=nex[i]){\n\t\tif(to[i]!=fa){\n\t\t\tdfs(x,to[i]);\n\t\t\tf[x]=max(f[x],max(g[x]+g[to[i]],f[to[i]]));\n\t\t\tg[x]=max(g[x],g[to[i]]+v[x]);\n\t\t}\n\t}\n}\nint main(){\n\tint n,i,x,y,s;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<n;i++){\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tadd(x,y);\n\t\tadd(y,x);\n\t\td[x]++;\n\t\td[y]++;\n\t}\n\ts=0;\n\tfor(i=1;i<=n;i++){\n\t\ts+=d[i]==1;\n\t\tv[i]=d[i]==2;\n\t}\n\tdfs(0,1);\n\tprintf(\"%d\",s+f[1]);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define tree_valtype int\n\ntypedef struct tree_edge_sub tree_edge;\n\ntypedef struct {\n\tint num;\n\tint nearnum;\n\ttree_edge *near;\n}tree_vertex_sub;\n\nstruct tree_edge_sub{\n\ttree_vertex_sub *v;\n\tint w;\n\ttree_edge *next;\n};\n\ntypedef struct tree_v_sub tree_vertex;\n\nstruct tree_v_sub{\n\tint num;\n\ttree_valtype val;\n\ttree_vertex *parent;\n\tint pareweight;\n\tint chilnum;\n\ttree_vertex **children;\n\tint *chilweight;\n};\n\ntypedef struct {\n\tint N;\n\tint root;\n\ttree_vertex_sub **v_s;\n\ttree_vertex **v;\n\ttree_vertex **sorted_v;\n}tree;\n\n//頂点数N, 根の番号root, 各頂点の初期値ini_valの木を作る\ntree *make_tree(int N, int root, tree_valtype ini_val){\n\tint i;\n\ttree *t = (tree *)malloc(sizeof(tree));\n\tt->N = N;\n\tt->root = root;\n\tt->v_s = (tree_vertex_sub **)malloc(sizeof(tree_vertex_sub *) * N);\n\tt->v = (tree_vertex **)malloc(sizeof(tree_vertex *) * N);\n\tt->sorted_v = (tree_vertex **)malloc(sizeof(tree_vertex *) * N);\n\ttree_vertex *parent_in_law = (tree_vertex *)malloc(sizeof(tree_vertex));\n\tparent_in_law->num = -1;\n\tparent_in_law->val = ini_val;\n\tparent_in_law->parent = NULL;\n\tparent_in_law->pareweight = -1;\n\tparent_in_law->chilnum = 0;\n\tparent_in_law->children = NULL;\n\tparent_in_law->chilweight = NULL;\n\tfor(i = 0; i < N; i++){\n\t\t(t->v_s)[i] = (tree_vertex_sub *)malloc(sizeof(tree_vertex_sub));\n\t\t(t->v_s)[i]->num = i;\n\t\t(t->v_s)[i]->nearnum = 0;\n\t\t(t->v_s)[i]->near = NULL;\n\t\t(t->v)[i] = (tree_vertex *)malloc(sizeof(tree_vertex));\n\t\t(t->v)[i]->num = i;\n\t\t(t->v)[i]->val = ini_val;\n\t\t(t->v)[i]->parent = parent_in_law;\n\t\t(t->v)[i]->pareweight = -1;\n\t\t(t->v)[i]->chilnum = 0;\n\t\t(t->v)[i]->children = NULL;\n\t\t(t->v)[i]->chilweight = NULL;\n\t\t(t->sorted_v)[i] = NULL;\n\t}\n\treturn t;\n}\n\n//木tの頂点aと頂点bの間に重みwの無向辺を張る (0 <= a, b <= N - 1)\nvoid set_edge_tree(int a, int b, int w, tree *t){\n\ttree_edge *new1 = (tree_edge *)malloc(sizeof(tree_edge));\n\tnew1->v = (t->v_s)[b];\n\tnew1->w = w;\n\tnew1->next = (t->v_s)[a]->near;\n\t(t->v_s)[a]->near = new1;\n\t(t->v_s)[a]->nearnum++;\n\n\ttree_edge *new2 = (tree_edge *)malloc(sizeof(tree_edge));\n\tnew2->v = (t->v_s)[a];\n\tnew2->w = w;\n\tnew2->next = (t->v_s)[b]->near;\n\t(t->v_s)[b]->near = new2;\n\t(t->v_s)[b]->nearnum++;\n}\n\n//set_edge_tree後に呼び出す\nvoid build_tree(tree *t){\n\tint i, j;\n\ttree_vertex_sub **v_s = t->v_s;\n\ttree_vertex **v = t->v;\n\ttree_vertex **sorted_v = t->sorted_v;\n\tsorted_v[0] = v[t->root];\n\ttree_vertex *nowv;\n\ttree_edge *nowe;\n\tfor(i = 0, j = 1; j - i > 0; i++){\n\t\tnowv = sorted_v[i];\n\t\tif(i == 0){\n\t\t\tv_s[nowv->num]->nearnum++;\n\t\t}\n\t\tnowv->children = (tree_vertex **)malloc(sizeof(tree_vertex *) * (v_s[nowv->num]->nearnum - 1));\n\t\tnowv->chilweight = (int *)malloc(sizeof(int) * (v_s[nowv->num]->nearnum - 1));\n\t\tif(i == 0){\n\t\t\tv_s[nowv->num]->nearnum--;\n\t\t}\n\t\tfor(nowe = v_s[nowv->num]->near; nowe != NULL; nowe = nowe->next){\n\t\t\tif(nowe->v->num != nowv->parent->num){\n\t\t\t\t(nowv->children)[nowv->chilnum] = v[nowe->v->num];\n\t\t\t\t(nowv->chilweight)[nowv->chilnum] = nowe->w;\n\t\t\t\tnowv->chilnum++;\n\t\t\t\tv[nowe->v->num]->parent = nowv;\n\t\t\t\tv[nowe->v->num]->pareweight = nowe->w;\n\t\t\t\tsorted_v[j] = v[nowe->v->num];\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t}\n\tsorted_v[0]->parent = NULL;\n}\n\nint main(){\n\tint N, a, b, i;\n\tscanf(\"%d\", &N);\n\ttree *t = make_tree(N, 0, 0);\n\tfor(i = 1; i < N; i++){\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tset_edge_tree(a - 1, b - 1, 1, t);\n\t}\n\tbuild_tree(t);\n\ttree_vertex *nowv;\n\tint maxval = 0, then_num = t->root;\n\tfor(i = 1; i < N; i++){\n\t\tnowv = t->sorted_v[i];\n\t\tnowv->val = nowv->parent->val;\n\t\tif(nowv->chilnum == 1){\n\t\t\tnowv->val++;\n\t\t}\n\t\tif(maxval <= nowv->val){\n\t\t\tmaxval = nowv->val;\n\t\t\tthen_num = nowv->num;\n\t\t}\n\t}\n\ttree *t2 = make_tree(N, then_num, 0);\n\tt2->v_s = t->v_s;\n\tbuild_tree(t2);\n//\tprintf(\"t2->root = %d\\n\", t2->root);\n\tmaxval = 0, then_num = t->root;\n\tfor(i = 1; i < N; i++){\n\t\tnowv = t2->sorted_v[i];\n\t\tnowv->val = nowv->parent->val;\n\t\tif(nowv->chilnum == 1){\n\t\t\tnowv->val++;\n\t\t}\n\t\tif(maxval <= nowv->val){\n\t\t\tmaxval = nowv->val;\n\t\t\tthen_num = nowv->num;\n\t\t}\n//\t\tprintf(\"(num, val) = (%d, %d)\\n\", nowv->num, nowv->val);\n\t}\n\tint leaf_num = 0;\n\tfor(i = 0; i < N; i++){\n\t\tif(t2->v_s[i]->nearnum == 1){\n\t\t\tleaf_num++;\n\t\t}\n\t}\n\tprintf(\"%d\\n\", maxval + leaf_num);\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException; \nimport java.io.InputStream; \nimport java.io.PrintWriter; \nimport java.util.*; \n \n\nclass Main{\n\tstatic List<Integer> edges[];\n\n\tstatic int[] leaf;\n\tstatic int[] maxpath;\n\tstatic int[] secpath;\n\n\tstatic void dfs(int v, int p){\n\t\tif(edges[v].size()==1){\n\t\t\tleaf[v]=1;\n\t\t\tmaxpath[v]=1;\n\t\t\treturn;\n\t\t}else if(edges[v].size()==2 && p!=-1){\n\t\t\tint u = edges[v].get(0)+edges[v].get(1)-p;\n\t\t\tdfs(u, v);\n\t\t\tleaf[v]=leaf[u];\n\t\t\tmaxpath[v]=maxpath[u]+1;\n\t\t\treturn;\n\t\t}else{\n\t\t\tfor(int u: edges[v])if(u!=p){\n\t\t\t\tdfs(u, v);\n\t\t\t\tleaf[v] += leaf[u];\n\t\t\t\tif(maxpath[u]>maxpath[v]){\n\t\t\t\t\tsecpath[v]=maxpath[v];\n\t\t\t\t\tmaxpath[v]=maxpath[u];\n\t\t\t\t}else if(maxpath[u]>secpath[v]){\n\t\t\t\t\tsecpath[v]=maxpath[u];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic int ans=0;\n\tstatic void dfs2(int v, int p, int l){\n//\t\tout.println(v+\" \"+leaf[v]+\" \"+maxpath[v]+\" \"+secpath[v]);\n\t\tif(secpath[v]>0){\n\t\t\tint res = l+leaf[v]+maxpath[v]+secpath[v]-2;\n\t\t\tif(p==-1&&edges[v].size()==2)res++;\n\t\t\tans=Math.max(ans, res);\n\t\t}\n\t\tfor(int u: edges[v])if(u!=p)dfs2(u, v, l+leaf[v]-leaf[u]);\n\t}\n\n\tstatic void solve(){\n\t\tint n = ni();\n\t\tleaf = new int[n];\n\t\tmaxpath = new int[n];\n\t\tsecpath = new int[n];\n\t\tedges = new List[n];\n\t\tfor(int i=0;i<n;++i)edges[i]=new ArrayList<>();\n\t\tfor(int i=0;i<n-1;++i){\n\t\t\tint p=ni()-1, q=ni()-1;\n\t\t\tedges[p].add(q);\n\t\t\tedges[q].add(p);\n\t\t}\n\t\tint root = 0;\n\t\tfor(int i=0;i<n;++i)if(edges[i].size()>1)root=i;\n\t\tdfs(root, -1);\n\t\tdfs2(root, -1, 0);\n\n\t\tout.println(ans);\n\n\t} \n \n \n \n \n\t public static void main(String[] args){ \n\t\t solve(); \n\t\t out.flush(); \n\t } \n\t private static InputStream in = System.in; \n\t private static PrintWriter out = new PrintWriter(System.out); \n \n\t static boolean inrange(int y, int x, int h, int w){ \n\t\t return y>=0 && y<h && x>=0 && x<w; \n\t } \n\t @SuppressWarnings(\"unchecked\") \n\t static<T extends Comparable> int lower_bound(List<T> list, T key){ \n\t\t int lower=-1;int upper=list.size(); \n\t\t while(upper - lower>1){ \n\t\t int center =(upper+lower)/2; \n\t\t if(list.get(center).compareTo(key)>=0)upper=center; \n\t\t else lower=center; \n\t\t } \n\t\t return upper; \n\t } \n\t @SuppressWarnings(\"unchecked\") \n\t static <T extends Comparable> int upper_bound(List<T> list, T key){ \n\t\t int lower=-1;int upper=list.size(); \n\t\t while(upper-lower >1){ \n\t\t int center=(upper+lower)/2; \n\t\t if(list.get(center).compareTo(key)>0)upper=center; \n\t\t else lower=center; \n\t\t } \n\t\t return upper; \n\t } \n\t @SuppressWarnings(\"unchecked\") \n\t static <T extends Comparable> boolean next_permutation(List<T> list){ \n\t\t int lastIndex = list.size()-2; \n\t\t while(lastIndex>=0 && list.get(lastIndex).compareTo(list.get(lastIndex+1))>=0)--lastIndex; \n\t\t if(lastIndex<0)return false; \n\t\t int swapIndex = list.size()-1; \n\t\t while(list.get(lastIndex).compareTo(list.get(swapIndex))>=0)swapIndex--; \n\t\t T tmp = list.get(lastIndex); \n\t\t list.set(lastIndex++, list.get(swapIndex)); \n\t\t list.set(swapIndex, tmp); \n\t\t swapIndex = list.size()-1; \n\t\t while(lastIndex<swapIndex){ \n\t\t tmp = list.get(lastIndex); \n\t\t list.set(lastIndex, list.get(swapIndex)); \n\t\t list.set(swapIndex, tmp); \n\t\t ++lastIndex;--swapIndex; \n\t\t } \n\t\t return true; \n\t } \n\t private static final byte[] buffer = new byte[1<<15]; \n\t private static int ptr = 0; \n\t private static int buflen = 0; \n\t private static boolean hasNextByte(){ \n\t\t if(ptr<buflen)return true; \n\t\t ptr = 0; \n\t\t try{ \n\t\t\t buflen = in.read(buffer); \n\t\t } catch (IOException e){ \n\t\t\t e.printStackTrace(); \n\t\t } \n\t\t return buflen>0; \n\t } \n\t private static int readByte(){ if(hasNextByte()) return buffer[ptr++]; else return -1;} \n\t private static boolean isSpaceChar(int c){ return !(33<=c && c<=126);} \n\t private static int skip(){int res; while((res=readByte())!=-1 && isSpaceChar(res)); return res;} \n \n\t private static double nd(){ return Double.parseDouble(ns()); } \n\t private static char nc(){ return (char)skip(); } \n\t private static String ns(){ \n\t\t StringBuilder sb = new StringBuilder(); \n\t\t for(int b=skip();!isSpaceChar(b);b=readByte())sb.append((char)b); \n\t\t return sb.toString(); \n\t } \n\t private static int[] nia(int n){ \n\t\t int[] res = new int[n]; \n\t\t for(int i=0;i<n;++i)res[i]=ni(); \n\t\t return res; \n\t } \n\t private static long[] nla(int n){ \n\t\t long[] res = new long[n]; \n\t\t for(int i=0;i<n;++i)res[i]=nl(); \n\t\t return res; \n\t } \n\t private static int ni(){ \n\t\t int res=0,b; \n\t\t boolean minus=false; \n\t\t while((b=readByte())!=-1 && !((b>='0'&&b<='9') || b=='-')); \n\t\t if(b=='-'){ \n\t\t\t minus=true; \n\t\t\t b=readByte(); \n\t\t } \n\t\t for(;'0'<=b&&b<='9';b=readByte())res=res*10+(b-'0'); \n\t\t return minus ? -res:res; \n\t } \n\t private static long nl(){ \n\t\t long res=0,b; \n\t\t boolean minus=false; \n\t\t while((b=readByte())!=-1 && !((b>='0'&&b<='9') || b=='-')); \n\t\t if(b=='-'){ \n\t\t\t minus=true; \n\t\t\t b=readByte(); \n\t\t } \n\t\t for(;'0'<=b&&b<='9';b=readByte())res=res*10+(b-'0'); \n\t\t return minus ? -res:res; \n\t} \n} \n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\t\n\t\t\tg = new SimpleAdjListGraph(n, 2*n);\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint s = io.nextInt() - 1;\n\t\t\t\tint t = io.nextInt() - 1;\n\t\t\t\tg.addEdge(s, t);\n\t\t\t\tg.addEdge(t, s);\n\t\t\t}\n\t\t\tint[] p = g.farthestVertexPairOnTree();\n\t\t\tint[] prev1 = g.bfs(p[1])[1];\n\t\t\tint[] prev2 = g.bfs(p[0])[1];\n\t\t\tint ans = 2;\n\t\t\tfor (int v = p[0]; v != -1; v = prev1[v]) {\n\t\t\t\tif (v != p[0] && v != p[1]) {\n\t\t\t\t\tans += Math.max(1, dfs(v, prev1[v], prev2[v]));\n\t\t\t\t}\n\t\t\t}\n\t\t\tio.out.println(ans);\n\t\t}\n\t}\n\t\n\tSimpleAdjListGraph g;\n\tint dfs(int v, int p1, int p2) {\n\t\tint ans = 0;\n\t\tfor (int e = g.head[v]; e != -1; e = g.next[e]) {\n\t\t\tif (g.to[e] == p1 || g.to[e] == p2) continue;\n\t\t\tans += dfs(g.to[e], v, -1);\n\t\t}\n\t\treturn Math.max(1, ans);\n\t}\n\t\n\tstatic\n\tclass SimpleAdjListGraph {\n\t\tint m, V, E;\n\t\tint[] head, next, to;\n\n\t\tpublic SimpleAdjListGraph(int V, int E) {\n\t\t\thead = new int[V];\n\t\t\tnext = new int[E];\n\t\t\tto = new int[E];\n\t\t\tthis.V = V;\n\t\t\tthis.E = E;\n\t\t\tclear();\n\t\t}\n\n\t\tpublic void clear() {\n\t\t\tm = 0;\n\t\t\tArrays.fill(head, -1);\n\t\t}\n\n\t\tpublic void addEdge(int s, int t) {\n\t\t\tnext[m] = head[s];\n\t\t\thead[s] = m;\n\t\t\tto[m++] = t;\n\t\t}\n\n\t\tint farthestVertex(final int[] dist) {\n\t\t\tint ret = 0;\n\t\t\tfor(int i = 0; i < dist.length; i++) {\n\t\t\t\tif(dist[ret] < dist[i]) {\n\t\t\t\t\tret = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tint[] farthestVertexPairOnTree() {\n\t\t\tfinal int[][] dist = new int[3][];\n\t\t\tdist[0] = bfs(0)[0];\n\t\t\tfinal int v0 = farthestVertex(dist[0]);\n\t\t\tdist[1] = bfs(v0)[0];\n\t\t\tfinal int v1 = farthestVertex(dist[1]);\n\t\t\treturn new int[]{v0,v1};\n\t\t}\n\n\t\tpublic int[][] bfs(final int src) {\n\t\t\tfinal int[] dist = new int[head.length];\n\t\t\tfinal int[] prev = new int[head.length];\n\t\t\tfinal int[] q = new int[2 * head.length + 10];\n\t\t\tint s = 0, t = 0;\n\t\t\t\n\t\t\tArrays.fill(dist, -1);\n\t\t\tArrays.fill(prev, -1);\n\t\t\tdist[src] = 0;\n\t\t\tq[t++] = src;\n\t\t\twhile(s != t) {\n\t\t\t\tfinal int v = q[s++];\n\t\t\t\tfor(int e = head[v]; e != -1; e = next[e]) {\n\t\t\t\t\tfinal int u = to[e];\n\t\t\t\t\tif(dist[u] == -1) {\n\t\t\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\t\t\tprev[u] = v;\n\t\t\t\t\t\tq[t++] = u;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new int[][] { dist, prev };\n\t\t}\n\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.math.*;\nimport java.util.*;\n\nimport static java.util.Arrays.*;\n\npublic class Main {\n\tprivate static final int mod = (int)1e9+7;\n\n\tfinal Random random = new Random(0);\n\tfinal IOFast io = new IOFast();\n\n\t/// MAIN CODE\n\tpublic void run() throws IOException {\n//\t\tint TEST_CASE = Integer.parseInt(new String(io.nextLine()).trim());\n\t\tint TEST_CASE = 1;\n\t\twhile(TEST_CASE-- != 0) {\n\t\t\tint n = io.nextInt();\n\t\t\t\n\t\t\tint[] deg = new int[n];\n\t\t\tSimpleAdjListGraph g = new SimpleAdjListGraph(n, 2*n);\n\t\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\t\tint s = io.nextInt() - 1;\n\t\t\t\tint t = io.nextInt() - 1;\n\t\t\t\tg.addEdge(s, t);\n\t\t\t\tg.addEdge(t, s);\n\t\t\t\tdeg[s]++;\n\t\t\t\tdeg[t]++;\n\t\t\t}\n\t\t\tint[] p = g.farthestVertexPairOnTree();\n\t\t\tint[] prev = g.bfs(p[1])[1];\n\t\t\tint ans = 2;\n\t\t\tfor (int v = p[0]; v != -1; v = prev[v]) {\n\t\t\t\tif (v != p[0] && v != p[1]) {\n\t\t\t\t\tans += Math.max(1, deg[v] - 2);\n\t\t\t\t}\n\t\t\t}\n\t\t\tio.out.println(ans);\n\t\t\tio.out.println();\n\t\t}\n\t}\n\t\n\tstatic\n\tclass SimpleAdjListGraph {\n\t\tint m, V, E;\n\t\tint[] head, next, to;\n\n\t\tpublic SimpleAdjListGraph(int V, int E) {\n\t\t\thead = new int[V];\n\t\t\tnext = new int[E];\n\t\t\tto = new int[E];\n\t\t\tthis.V = V;\n\t\t\tthis.E = E;\n\t\t\tclear();\n\t\t}\n\n\t\tpublic void clear() {\n\t\t\tm = 0;\n\t\t\tArrays.fill(head, -1);\n\t\t}\n\n\t\tpublic void addEdge(int s, int t) {\n\t\t\tnext[m] = head[s];\n\t\t\thead[s] = m;\n\t\t\tto[m++] = t;\n\t\t}\n\n\t\tint farthestVertex(final int[] dist) {\n\t\t\tint ret = 0;\n\t\t\tfor(int i = 0; i < dist.length; i++) {\n\t\t\t\tif(dist[ret] < dist[i]) {\n\t\t\t\t\tret = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tint[] farthestVertexPairOnTree() {\n\t\t\tfinal int[][] dist = new int[3][];\n\t\t\tdist[0] = bfs(0)[0];\n\t\t\tfinal int v0 = farthestVertex(dist[0]);\n\t\t\tdist[1] = bfs(v0)[0];\n\t\t\tfinal int v1 = farthestVertex(dist[1]);\n\t\t\treturn new int[]{v0,v1};\n\t\t}\n\n\t\tpublic int[][] bfs(final int src) {\n\t\t\tfinal int[] dist = new int[head.length];\n\t\t\tfinal int[] prev = new int[head.length];\n\t\t\tfinal int[] q = new int[2 * head.length + 10];\n\t\t\tint s = 0, t = 0;\n\t\t\t\n\t\t\tArrays.fill(dist, -1);\n\t\t\tArrays.fill(prev, -1);\n\t\t\tdist[src] = 0;\n\t\t\tq[t++] = src;\n\t\t\twhile(s != t) {\n\t\t\t\tfinal int v = q[s++];\n\t\t\t\tfor(int e = head[v]; e != -1; e = next[e]) {\n\t\t\t\t\tfinal int u = to[e];\n\t\t\t\t\tif(dist[u] == -1) {\n\t\t\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\t\t\tprev[u] = v;\n\t\t\t\t\t\tq[t++] = u;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new int[][] { dist, prev };\n\t\t}\n\n\t}\n\t\n\t/// TEMPLATE\n\tstatic int gcd(int n, int r) { return r == 0 ? n : gcd(r, n%r); }\n\tstatic long gcd(long n, long r) { return r == 0 ? n : gcd(r, n%r); }\n\t\n\tstatic <T> void swap(T[] x, int i, int j) { T t = x[i]; x[i] = x[j]; x[j] = t; }\n\tstatic void swap(int[] x, int i, int j) { int t = x[i]; x[i] = x[j]; x[j] = t; }\n\n\tvoid printArrayLn(int[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\tvoid printArrayLn(long[] xs) { for(int i = 0; i < xs.length; i++) io.out.print(xs[i] + (i==xs.length-1?\"\\n\":\" \")); }\n\t\n\tstatic void dump(Object... o) { System.err.println(Arrays.deepToString(o)); } \n\t\n\tvoid main() throws IOException {\n\t\t//\t\tIOFast.setFileIO(\"rle-size.in\", \"rle-size.out\");\n\t\ttry { run(); }\n\t\tcatch (EndOfFileRuntimeException e) { }\n\t\tio.out.flush();\n\t}\n\tpublic static void main(String[] args) throws IOException { new Main().main(); }\n\t\n\tstatic class EndOfFileRuntimeException extends RuntimeException {\n\t\tprivate static final long serialVersionUID = -8565341110209207657L; }\n\n\tstatic\n\tpublic class IOFast {\n\t\tprivate BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n\t\tprivate PrintWriter out = new PrintWriter(System.out);\n\n\t\tvoid setFileIn(String ins) throws IOException { in.close(); in = new BufferedReader(new FileReader(ins)); }\n\t\tvoid setFileOut(String outs) throws IOException { out.flush(); out.close(); out = new PrintWriter(new FileWriter(outs)); }\n\t\tvoid setFileIO(String ins, String outs) throws IOException { setFileIn(ins); setFileOut(outs); }\n\n\t\tprivate static int pos, readLen;\n\t\tprivate static final char[] buffer = new char[1024 * 8];\n\t\tprivate static char[] str = new char[500*8*2];\n\t\tprivate static boolean[] isDigit = new boolean[256];\n\t\tprivate static boolean[] isSpace = new boolean[256];\n\t\tprivate static boolean[] isLineSep = new boolean[256];\n\n\t\tstatic { for(int i = 0; i < 10; i++) { isDigit['0' + i] = true; } isDigit['-'] = true; isSpace[' '] = isSpace['\\r'] = isSpace['\\n'] = isSpace['\\t'] = true; isLineSep['\\r'] = isLineSep['\\n'] = true; }\n\t\tpublic int read() throws IOException { if(pos >= readLen) { pos = 0; readLen = in.read(buffer); if(readLen <= 0) { throw new EndOfFileRuntimeException(); } } return buffer[pos++]; }\n\t\tpublic int nextInt() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; int ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic long nextLong() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); int i = 0; long ret = 0; if(str[0] == '-') { i = 1; } for(; i < len; i++) ret = ret * 10 + str[i] - '0'; if(str[0] == '-') { ret = -ret; } return ret; }\n\t\tpublic char nextChar() throws IOException { while(true) { final int c = read(); if(!isSpace[c]) { return (char)c; } } }\n\t\tint reads(int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } if(str.length == len) { char[] rep = new char[str.length * 3 / 2]; System.arraycopy(str, 0, rep, 0, str.length); str = rep; } str[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tint reads(char[] cs, int len, boolean[] accept) throws IOException { try { while(true) { final int c = read(); if(accept[c]) { break; } cs[len++] = (char)c; } } catch(EndOfFileRuntimeException e) { ; } return len; }\n\t\tpublic char[] nextLine() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isLineSep); try { if(str[len-1] == '\\r') { len--; read(); } } catch(EndOfFileRuntimeException e) { ; } return Arrays.copyOf(str, len); }\n\t\tpublic String nextString() throws IOException { return new String(next()); }\n\t\tpublic char[] next() throws IOException { int len = 0; str[len++] = nextChar(); len = reads(len, isSpace); return Arrays.copyOf(str, len); }\n//\t\tpublic int next(char[] cs) throws IOException { int len = 0; cs[len++] = nextChar(); len = reads(cs, len, isSpace); return len; }\n\t\tpublic double nextDouble() throws IOException { return Double.parseDouble(nextString()); }\n\t\tpublic long[] nextLongArray(final int n) throws IOException { final long[] res = new long[n]; for(int i = 0; i < n; i++) { res[i] = nextLong(); } return res; }\n\t\tpublic int[] nextIntArray(final int n) throws IOException { final int[] res = new int[n]; for(int i = 0; i < n; i++) { res[i] = nextInt(); } return res; }\n\t\tpublic int[][] nextIntArray2D(final int n, final int k) throws IOException { final int[][] res = new int[n][]; for(int i = 0; i < n; i++) { res[i] = nextIntArray(k); } return res; }\n\t\tpublic int[][] nextIntArray2DWithIndex(final int n, final int k) throws IOException { final int[][] res = new int[n][k+1]; for(int i = 0; i < n; i++) { for(int j = 0; j < k; j++) { res[i][j] = nextInt(); } res[i][k] = i; } return res; }\n\t\tpublic double[] nextDoubleArray(final int n) throws IOException { final double[] res = new double[n]; for(int i = 0; i < n; i++) { res[i] = nextDouble(); } return res; }\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskK solver = new TaskK();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskK {\n        public ArrayList<Integer>[] graph;\n        public int[] deg;\n        public int[] size;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            graph = new ArrayList[n];\n            deg = new int[n];\n            size = new int[n];\n            for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\n            for (int i = 0; i < n - 1; i++) {\n                int a = in.nextInt() - 1, b = in.nextInt() - 1;\n                graph[a].add(b);\n                graph[b].add(a);\n                deg[a]++;\n                deg[b]++;\n            }\n            int root = -1;\n            int ans = 0;\n            for (int i = 0; i < n; i++) {\n                if (deg[i] > 2) {\n                    root = i;\n                }\n                if (deg[i] == 1) ans++;\n            }\n            if (root == -1) {\n                out.println(n);\n                return;\n            }\n\n            int[] longest = dfs(0, -1);\n\n            out.println(longest[0] + longest[1] + ans);\n        }\n\n        public int[] dfs(int node, int par) {\n            int[] longest = new int[2];\n            size[node] = 1;\n            for (int next : graph[node]) {\n                if (next == par) continue;\n                int[] cand = dfs(next, node);\n                for (int j = 0; j < 2; j++) {\n                    if (cand[j] > longest[0]) {\n                        longest[1] = longest[0];\n                        longest[0] = cand[j];\n                    } else if (cand[j] > longest[1]) {\n                        longest[1] = cand[j];\n                    }\n                }\n                size[node] += size[next];\n            }\n            if (deg[node] == 2) longest[0]++;\n            return longest;\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException; \nimport java.io.InputStream; \nimport java.io.PrintWriter; \nimport java.util.*; \n \n\nclass Main{\n\tstatic List<Integer> edges[];\n\n\tstatic int[] leaf;\n\tstatic int[] maxpath;\n\tstatic int[] secpath;\n\n\tstatic void dfs(int v, int p){\n\t\tif(edges[v].size()==1){\n\t\t\tleaf[v]=1;\n\t\t\tmaxpath[v]=1;\n\t\t\treturn;\n\t\t}else if(edges[v].size()==2 && p!=-1){\n\t\t\tint u = edges[v].get(0)+edges[v].get(1)-p;\n\t\t\tdfs(u, v);\n\t\t\tleaf[v]=leaf[u];\n\t\t\tmaxpath[v]=maxpath[u]+1;\n\t\t\treturn;\n\t\t}else{\n\t\t\tfor(int u: edges[v])if(u!=p){\n\t\t\t\tdfs(u, v);\n\t\t\t\tleaf[v] += leaf[u];\n\t\t\t\tif(maxpath[u]>maxpath[v]){\n\t\t\t\t\tsecpath[v]=maxpath[v];\n\t\t\t\t\tmaxpath[v]=maxpath[u];\n\t\t\t\t}else if(maxpath[u]>secpath[v]){\n\t\t\t\t\tsecpath[v]=maxpath[u];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tstatic int ans=0;\n\tstatic void dfs2(int v, int p, int l){\n//\t\tout.println(v+\" \"+leaf[v]+\" \"+maxpath[v]+\" \"+secpath[v]);\n\t\tif(secpath[v]>0){\n\t\t\tint res = l+leaf[v]+maxpath[v]+secpath[v]-2;\n\t\t\tif(p==-1&&edges[v].size()==2 || p!=-1&&edges[v].size()==3)res++;\n\t\t\tans=Math.max(ans, res);\n\t\t}\n\t\tfor(int u: edges[v])if(u!=p)dfs2(u, v, l+leaf[v]-leaf[u]);\n\t}\n\n\tstatic void solve(){\n\t\tint n = ni();\n\t\tleaf = new int[n];\n\t\tmaxpath = new int[n];\n\t\tsecpath = new int[n];\n\t\tedges = new List[n];\n\t\tfor(int i=0;i<n;++i)edges[i]=new ArrayList<>();\n\t\tfor(int i=0;i<n-1;++i){\n\t\t\tint p=ni()-1, q=ni()-1;\n\t\t\tedges[p].add(q);\n\t\t\tedges[q].add(p);\n\t\t}\n\t\tint root = 0;\n\t\tfor(int i=0;i<n;++i)if(edges[i].size()>1)root=i;\n\t\tdfs(root, -1);\n\t\tdfs2(root, -1, 0);\n\n\t\tout.println(ans);\n\n\t} \n \n \n \n \n\t public static void main(String[] args){ \n\t\t solve(); \n\t\t out.flush(); \n\t } \n\t private static InputStream in = System.in; \n\t private static PrintWriter out = new PrintWriter(System.out); \n \n\t static boolean inrange(int y, int x, int h, int w){ \n\t\t return y>=0 && y<h && x>=0 && x<w; \n\t } \n\t @SuppressWarnings(\"unchecked\") \n\t static<T extends Comparable> int lower_bound(List<T> list, T key){ \n\t\t int lower=-1;int upper=list.size(); \n\t\t while(upper - lower>1){ \n\t\t int center =(upper+lower)/2; \n\t\t if(list.get(center).compareTo(key)>=0)upper=center; \n\t\t else lower=center; \n\t\t } \n\t\t return upper; \n\t } \n\t @SuppressWarnings(\"unchecked\") \n\t static <T extends Comparable> int upper_bound(List<T> list, T key){ \n\t\t int lower=-1;int upper=list.size(); \n\t\t while(upper-lower >1){ \n\t\t int center=(upper+lower)/2; \n\t\t if(list.get(center).compareTo(key)>0)upper=center; \n\t\t else lower=center; \n\t\t } \n\t\t return upper; \n\t } \n\t @SuppressWarnings(\"unchecked\") \n\t static <T extends Comparable> boolean next_permutation(List<T> list){ \n\t\t int lastIndex = list.size()-2; \n\t\t while(lastIndex>=0 && list.get(lastIndex).compareTo(list.get(lastIndex+1))>=0)--lastIndex; \n\t\t if(lastIndex<0)return false; \n\t\t int swapIndex = list.size()-1; \n\t\t while(list.get(lastIndex).compareTo(list.get(swapIndex))>=0)swapIndex--; \n\t\t T tmp = list.get(lastIndex); \n\t\t list.set(lastIndex++, list.get(swapIndex)); \n\t\t list.set(swapIndex, tmp); \n\t\t swapIndex = list.size()-1; \n\t\t while(lastIndex<swapIndex){ \n\t\t tmp = list.get(lastIndex); \n\t\t list.set(lastIndex, list.get(swapIndex)); \n\t\t list.set(swapIndex, tmp); \n\t\t ++lastIndex;--swapIndex; \n\t\t } \n\t\t return true; \n\t } \n\t private static final byte[] buffer = new byte[1<<15]; \n\t private static int ptr = 0; \n\t private static int buflen = 0; \n\t private static boolean hasNextByte(){ \n\t\t if(ptr<buflen)return true; \n\t\t ptr = 0; \n\t\t try{ \n\t\t\t buflen = in.read(buffer); \n\t\t } catch (IOException e){ \n\t\t\t e.printStackTrace(); \n\t\t } \n\t\t return buflen>0; \n\t } \n\t private static int readByte(){ if(hasNextByte()) return buffer[ptr++]; else return -1;} \n\t private static boolean isSpaceChar(int c){ return !(33<=c && c<=126);} \n\t private static int skip(){int res; while((res=readByte())!=-1 && isSpaceChar(res)); return res;} \n \n\t private static double nd(){ return Double.parseDouble(ns()); } \n\t private static char nc(){ return (char)skip(); } \n\t private static String ns(){ \n\t\t StringBuilder sb = new StringBuilder(); \n\t\t for(int b=skip();!isSpaceChar(b);b=readByte())sb.append((char)b); \n\t\t return sb.toString(); \n\t } \n\t private static int[] nia(int n){ \n\t\t int[] res = new int[n]; \n\t\t for(int i=0;i<n;++i)res[i]=ni(); \n\t\t return res; \n\t } \n\t private static long[] nla(int n){ \n\t\t long[] res = new long[n]; \n\t\t for(int i=0;i<n;++i)res[i]=nl(); \n\t\t return res; \n\t } \n\t private static int ni(){ \n\t\t int res=0,b; \n\t\t boolean minus=false; \n\t\t while((b=readByte())!=-1 && !((b>='0'&&b<='9') || b=='-')); \n\t\t if(b=='-'){ \n\t\t\t minus=true; \n\t\t\t b=readByte(); \n\t\t } \n\t\t for(;'0'<=b&&b<='9';b=readByte())res=res*10+(b-'0'); \n\t\t return minus ? -res:res; \n\t } \n\t private static long nl(){ \n\t\t long res=0,b; \n\t\t boolean minus=false; \n\t\t while((b=readByte())!=-1 && !((b>='0'&&b<='9') || b=='-')); \n\t\t if(b=='-'){ \n\t\t\t minus=true; \n\t\t\t b=readByte(); \n\t\t } \n\t\t for(;'0'<=b&&b<='9';b=readByte())res=res*10+(b-'0'); \n\t\t return minus ? -res:res; \n\t} \n} \n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskK solver = new TaskK();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskK {\n        public ArrayList<Integer>[] graph;\n        public int[] deg;\n        public int[] size;\n        public int[] numleaves;\n        public int[] tochild;\n        public int[] depth;\n        public int res;\n        public int ss;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            graph = new ArrayList[n];\n            deg = new int[n];\n            size = new int[n];\n            numleaves = new int[n];\n            tochild = new int[n];\n            depth = new int[n];\n            for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\n            for (int i = 0; i < n - 1; i++) {\n                int a = in.nextInt() - 1, b = in.nextInt() - 1;\n                graph[a].add(b);\n                graph[b].add(a);\n                deg[a]++;\n                deg[b]++;\n            }\n            int root = -1;\n            ss = 0;\n            for (int i = 0; i < n; i++) {\n                if (deg[i] == 1) {\n                    root = i;\n                }\n                if (deg[i] == 1) ss++;\n            }\n            if (root == -1) {\n                out.println(n);\n                return;\n            }\n\n            res = ss;\n            dfs(root, -1);\n\n            out.println(res);\n        }\n\n        public int dfs(int node, int par) {\n            size[node] = 1;\n            numleaves[node] = (deg[node] == 1 ? 1 : 0);\n            tochild[node] = 1;\n            depth[node] = (par == -1 ? 0 : (depth[par] + 1));\n            int best1 = 0, best2 = 0;\n            for (int next : graph[node]) {\n                if (next == par) continue;\n                int a1 = dfs(next, node);\n                if (a1 > best1) {\n                    best2 = best1;\n                    best1 = a1;\n                } else if (a1 > best2) {\n                    best2 = a1;\n                }\n                tochild[node] = Math.max(tochild[node], 1 + tochild[next]);\n                numleaves[node] += numleaves[next];\n                size[node] += size[next];\n            }\n            res = Math.max(res, best1 + best2 + ss);\n            res = Math.max(res, depth[node] + best1 + numleaves[node]);\n\n            return Math.max(best1, tochild[node] - numleaves[node]);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.UncheckedIOException;\nimport java.util.List;\nimport java.nio.charset.Charset;\nimport java.util.StringTokenizer;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.util.Comparator;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author mikit\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        LightScanner in = new LightScanner(inputStream);\n        LightWriter out = new LightWriter(outputStream);\n        KProblemOnTree solver = new KProblemOnTree();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class KProblemOnTree {\n        public void solve(int testNumber, LightScanner in, LightWriter out) {\n            // out.setBoolLabel(LightWriter.BoolLabel.YES_NO_FIRST_UP);\n            int n = in.ints();\n            KProblemOnTree.Node[] nodes = new KProblemOnTree.Node[n];\n            for (int i = 0; i < n; i++) nodes[i] = new KProblemOnTree.Node();\n            for (int i = 1; i < n; i++) {\n                int p = in.ints() - 1, q = in.ints() - 1;\n                nodes[p].neg.add(nodes[q]);\n                nodes[q].neg.add(nodes[p]);\n            }\n            int ans = 0, max = 0;\n            for (int i = 0; i < n; i++) {\n                if (nodes[i].neg.size() == 1) {\n                    ans++;\n                }\n                max = Math.max(nodes[i].neg.size(), max);\n            }\n\n            if (max <= 2) {\n                out.ans(n).ln();\n                return;\n            }\n\n\n            List<Integer> list = new ArrayList<>();\n            for (int i = 0; i < n; i++) {\n                if (nodes[i].neg.size() == 1) {\n                    list.add(nodes[i].dfs(null));\n                }\n            }\n\n            list.sort(Comparator.reverseOrder());\n            ans += list.get(0) + list.get(1) - 2;\n            out.ans(ans).ln();\n        }\n\n        private static class Node {\n            final List<KProblemOnTree.Node> neg = new ArrayList<>();\n\n            int dfs(KProblemOnTree.Node parent) {\n                if (neg.size() > 2) {\n                    return 0;\n                }\n                for (KProblemOnTree.Node next : neg) {\n                    if (next == parent) continue;\n                    return next.dfs(this) + 1;\n                }\n                throw new RuntimeException();\n            }\n\n        }\n\n    }\n\n    static class LightWriter implements AutoCloseable {\n        private final Writer out;\n        private boolean autoflush = false;\n        private boolean breaked = true;\n\n        public LightWriter(Writer out) {\n            this.out = out;\n        }\n\n        public LightWriter(OutputStream out) {\n            this(new BufferedWriter(new OutputStreamWriter(out, Charset.defaultCharset())));\n        }\n\n        public LightWriter print(char c) {\n            try {\n                out.write(c);\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter print(String s) {\n            try {\n                out.write(s, 0, s.length());\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter ans(String s) {\n            if (!breaked) {\n                print(' ');\n            }\n            return print(s);\n        }\n\n        public LightWriter ans(int i) {\n            return ans(Integer.toString(i));\n        }\n\n        public LightWriter ln() {\n            print(System.lineSeparator());\n            breaked = true;\n            if (autoflush) {\n                try {\n                    out.flush();\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            }\n            return this;\n        }\n\n        public void close() {\n            try {\n                out.close();\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n        }\n\n    }\n\n    static class LightScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public LightScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String string() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ints() {\n            return Integer.parseInt(string());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\nimport java.io.IOException;\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        InputReader in = new InputReader(inputStream);\n        PrintWriter out = new PrintWriter(outputStream);\n        TaskK solver = new TaskK();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class TaskK {\n        public ArrayList<Integer>[] graph;\n        public int[] deg;\n        public int[] size;\n        public int[] numleaves;\n        public int[] tochild;\n        public int[] depth;\n        public int res;\n        public int ss;\n\n        public void solve(int testNumber, InputReader in, PrintWriter out) {\n            int n = in.nextInt();\n            graph = new ArrayList[n];\n            deg = new int[n];\n            size = new int[n];\n            numleaves = new int[n];\n            tochild = new int[n];\n            depth = new int[n];\n            for (int i = 0; i < n; i++) graph[i] = new ArrayList<>();\n            for (int i = 0; i < n - 1; i++) {\n                int a = in.nextInt() - 1, b = in.nextInt() - 1;\n                graph[a].add(b);\n                graph[b].add(a);\n                deg[a]++;\n                deg[b]++;\n            }\n            int root = -1;\n            ss = 0;\n            for (int i = 0; i < n; i++) {\n                if (deg[i] == 1) {\n                    root = i;\n                }\n                if (deg[i] == 1) ss++;\n            }\n            if (root == -1) {\n                out.println(n);\n                return;\n            }\n\n            res = ss;\n            dfs(root, -1);\n\n            out.println(res);\n        }\n\n        public int dfs(int node, int par) {\n            size[node] = 1;\n            tochild[node] = 1;\n            depth[node] = (par == -1 ? 0 : (depth[par] + 1));\n            int best1 = 0, best2 = 0;\n            for (int next : graph[node]) {\n                if (next == par) continue;\n                int a1 = dfs(next, node);\n                if (a1 > best1) {\n                    best2 = best1;\n                    best1 = a1;\n                } else if (a1 > best2) {\n                    best2 = a1;\n                }\n                tochild[node] = Math.max(tochild[node], 1 + tochild[next]);\n                numleaves[node] += numleaves[next];\n                size[node] += size[next];\n            }\n            res = Math.max(res, best1 + best2 + ss);\n            res = Math.max(res, depth[node] + best1 + numleaves[node]);\n            numleaves[node] += (deg[node] == 1 ? 1 : 0);\n\n            return Math.max(best1, tochild[node] - numleaves[node]);\n        }\n\n    }\n\n    static class InputReader {\n        public BufferedReader reader;\n        public StringTokenizer tokenizer;\n\n        public InputReader(InputStream stream) {\n            reader = new BufferedReader(new InputStreamReader(stream), 32768);\n            tokenizer = null;\n        }\n\n        public String next() {\n            while (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int nextInt() {\n            return Integer.parseInt(next());\n        }\n\n    }\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "C=(0..gets.to_i).map{[]};$<.map{|l|x,y=l.split.map &:to_i;C[x]<<y;C[y]<<x};d=->i,q{[[0,i],*(C[i]-[q]).map{|j|a,k=d[j,i];[a+4[C[i].size],k]}].max};p~-C.count{|x,y|!y}+d[d[1,0][1],0][0]"
  },
  {
    "language": "Ruby",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n \ntypedef int Weight;\ntypedef int Edge;\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n \ntypedef pair<Weight, int> Result;\nResult visit(int p, int v, const Graph &g) {\n  Result r(0, v);\n  int f = g[v].size()==2;\n  for(auto &e: g[v]) if (e != p) {\n    Result t = visit(v, e, g);\n    t.first += f; //e->weight;\n    if (r.first < t.first) r = t;\n  }\n  return r;\n}\nWeight diameter(const Graph &g) {\n  Result r = visit(-1, 0, g);\n  Result t = visit(-1, r.second, g);\n  return t.first; // (r.second, t.second) is farthest pair\n}\n \nint main(){\n\tint V,s,t;\n\tscanf(\"%d\",&V);\n\tGraph g(V);\n\tfor(;V>1;V--)scanf(\"%d%d\",&s,&t),s--,t--,g[s].emplace_back(t),g[t].emplace_back(s);\n\tprintf(\"%d\\n\",diameter(g)+count_if(g.begin(),g.end(),[](auto &e){return e.size()==1;}));\n}"
  },
  {
    "language": "Ruby",
    "code": "F=->z,c{f=G[c].size==2?1:0;r=[0,c];G[c].map{|e|e!=z&&(x,y=F[c,e];r=[r,[x+f,y]].max)};r}\nG=(0..gets.to_i).map{[]}\n$<.map{|e|a,b=e.split.map &:to_i;G[a]<<b;G[b]<<a}\np F[-1,F[-1,1][1]][0]+G.count{|e|e.size==1}"
  },
  {
    "language": "Ruby",
    "code": "C=(0..gets.to_i).map{[]};\n$<.map{|l|x,y=l.split.map &:to_i;C[x]<<y;C[y]<<x};\nd=->i,q{\n  x=C[i]-[q];\n  x[0]?(\n    a,b=x.map{|j|d[j,i]}.transpose;\n    l,m=b.max 2;\n    [[*a,m ? m+l+1:l+=1].max,l+=m ?x.size-1: 0]\n  ):[1,1]\n}\np d[1,1].max\n"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ndef dfs(z,c)\n\tr=[0,0,c]\n\tG[c].each{|e|\n\t\tnext if e==z\n\t\tt=dfs(c,e)\n\t\tif t[0]+1>r[0]\n\t\t\tr=[t[0]+1,t[1]+(G[c].size==2 ? 1 : 0),t[2]]\n\t\tend\n\t}\n\tr\nend\nN=gets.to_i\nD=[0]*N\nG=N.times.map{[]}\n(N-1).times{\n\ta,b=gets.split.map(&:to_i)\n\tD[a-1]+=1\n\tD[b-1]+=1\n\tG[a-1]<<b-1\n\tG[b-1]<<a-1\n}\nx=dfs(-1,0)\np x[1]+D.count{|e|e==1}"
  },
  {
    "language": "Ruby",
    "code": "F=->z,c{f=G[c].size==2?1:0;r=[0,c];G[c].map{|e|e!=z&&(x,y=F[c,e];r=[r,[x+f,y]].max)};r}\nN=gets.to_i\nG=N.times.map{[]}\n(N-1).times{a,b=gets.split.map &:to_i;G[a-1]<<b-1;G[b-1]<<a-1}\np F[-1,F[-1,0][1]][0]+G.count{|e|e.size==1}"
  },
  {
    "language": "Ruby",
    "code": "F=->z,c{G[c].map{|e|e==z ?[0,c]:(x,y=F[c,e];[x+4[G[c].size],y])}.max};G=(0..gets.to_i).map{[]};$<.map{|e|a,b=e.split.map &:to_i;G[a]<<b;G[b]<<a};p~-G.count{|x,y|!y}+F[0,F[0,1][1]][0]"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ndef dfs(q,z,c)\n\tr=[0,0,c]\n\tG[c].each{|e|\n\t\tnext if e==z\n\t\tt=dfs(q,c,e)\n\t\ta=[t[0]+1,t[1]+(G[c].size==2 ? 1 : 0)]\n\t\tif a[q]>r[q]\n\t\t\tr=[*a,t[2]]\n\t\tend\n\t}\n\tr\nend\nN=gets.to_i\nD=[0]*N\nG=N.times.map{[]}\n(N-1).times{\n\ta,b=gets.split.map(&:to_i)\n\tD[a-1]+=1\n\tD[b-1]+=1\n\tG[a-1]<<b-1\n\tG[b-1]<<a-1\n}\nx=dfs(0,-1,0)\nx=dfs(1,-1,x[2])\np x[1]+D.count{|e|e==1}"
  },
  {
    "language": "Ruby",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef pair<Weight, int> Result;\nResult visit(int p, int v, const Graph &g) {\n  int f = g[v].size()==2;\n  Result r(0, v);\n  for(auto &e: g[v]) if (e.dst != p) {\n    Result t = visit(v, e.dst, g);\n    t.first += f; //e->weight;\n    if (r.first < t.first) r = t;\n  }\n  return r;\n}\nWeight diameter(const Graph &g) {\n  Result r = visit(-1, 0, g);\n  Result t = visit(-1, r.second, g);\n  return t.first; // (r.second, t.second) is farthest pair\n}\n\nint main(){\n\tint V,s,t;\n\tscanf(\"%d\",&V);\n\tGraph g(V);\n\tfor(;V>1;V--)scanf(\"%d%d\",&s,&t),s--,t--,g[s].push_back(Edge(s,t,1)),g[t].push_back(Edge(t,s,1));\n\tprintf(\"%d\\n\",diameter(g)+count_if(g.begin(),g.end(),[](auto &e){return e.size()==1;}));\n}"
  },
  {
    "language": "Ruby",
    "code": "#pragma GCC optimize(\"O3\")\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n \ntypedef int Weight;\ntypedef int Edge;\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n \ntypedef pair<Weight, int> Result;\nResult visit(int p, int v, const Graph &g) {\n  Result r(0, v);\n  int f = g[v].size()==2;\n  for(auto &e: g[v]) if (e != p) {\n    Result t = visit(v, e, g);\n    t.first += f; //e->weight;\n    if (r.first < t.first) r = t;\n  }\n  return r;\n}\nWeight diameter(const Graph &g) {\n  Result r = visit(-1, 0, g);\n  Result t = visit(-1, r.second, g);\n  return t.first; // (r.second, t.second) is farthest pair\n}\n \nint main(){\n\tint V,s,t;\n\tscanf(\"%d\",&V);\n\tGraph g(V);\n\tfor(;V>1;V--)scanf(\"%d%d\",&s,&t),s--,t--,g[s].emplace_back(t),g[t].emplace_back(s);\n\tprintf(\"%d\\n\",diameter(g)+count_if(g.begin(),g.end(),[](auto &e){return e.size()==1;}));\n}"
  },
  {
    "language": "Ruby",
    "code": "C=(?0..gets).map{[]};$<.map{|l|x,y=l.split.map &:to_i;C[x]<<y;C[y]<<x};d=->i,q{[[0,i],*(C[i]-[q]).map{|j|a,k=d[j,i];[a+4[C[i].size],k]}].max};p C.count{|x,y|x&&!y}+d[d[1,0][1],0][0]"
  },
  {
    "language": "Ruby",
    "code": "def dfs(z,c)\n\tf=G[c].size==2?1:0\n\tr=[0,c]\n\tG[c].each{|e|\n\t\tnext if e==z\n\t\tt=dfs(c,e)\n\t\tr=[r,[t[0]+f,t[1]]].max\n\t}\n\tr\nend\nN=gets.to_i\nG=N.times.map{[]}\n(N-1).times{\n\ta,b=gets.split.map(&:to_i)\n\tG[a-1]<<b-1\n\tG[b-1]<<a-1\n}\np dfs(-1,dfs(-1,0)[1])[0]+G.count{|e|e.size==1}"
  },
  {
    "language": "Ruby",
    "code": "def dfs(z,c)\n\tr=[0,0,c]\n\tG[c].each{|e|\n\t\tnext if e==z\n\t\tt=dfs(c,e)\n\t\tif t[0]+1>r[0]\n\t\t\tr=[t[0]+1,t[1]+(G[c].size==2 ? 1 : 0),t[2]]\n\t\tend\n\t}\n\tr\nend\nN=gets.to_i\nD=[0]*N\nG=N.times.map{[]}\n(N-1).times{\n\ta,b=gets.split.map(&:to_i)\n\tD[a-1]+=1\n\tD[b-1]+=1\n\tG[a-1]<<b-1\n\tG[b-1]<<a-1\n}\nx=dfs(-1,0)\nx=dfs(-1,x[2])\np x[1]+D.count{|e|e==1}"
  },
  {
    "language": "Ruby",
    "code": "F=->z,c{f=G[c].size==2?1:0;r=[0,c];G[c].map{|e|e!=z&&(x,y=F[c,e];r=[r,[x+f,y]].max)};r}\nG=(0..gets.to_i).map{[]}\n$<.map{|e|a,b=e.split.map &:to_i;G[a]<<b;G[b]<<a}\np F[-1,F[-1,1][1]][0]+G.count{|x,y|!y}"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ndef dfs(q,z,c)\n\tr=[0,0,c]\n\tG[c].each{|e|\n\t\tnext if e==z\n\t\tt=dfs(q,c,e)\n\t\ta=[t[0]+1,t[1]+(G[c].size==2 ? 1 : 0)]\n\t\tif a[q]>r[q]\n\t\t\tr=[*a,t[2]]\n\t\tend\n\t}\n\tr\nend\nN=gets.to_i\nG=N.times.map{[]}\n(N-1).times{\n\ta,b=gets.split.map(&:to_i)\n\tG[a-1]<<b-1\n\tG[b-1]<<a-1\n}\n=begin\nx=dfs(0,-1,0)\nx=dfs(1,-1,x[2])\nr=x[1]\n=end\nz=N.times.find{|i|G[i].size==2}\nr=z ? dfs(1,-1,z) : 0\np r+G.count{|e|e.size==1}"
  },
  {
    "language": "Ruby",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef pair<Weight, int> Result;\nResult visit(int p, int v, const Graph &g) {\n  int f = g[v].size()==2;\n  Result r(0, v);\n  for(auto &e: g[v]) if (e.dst != p) {\n    Result t = visit(v, e.dst, g);\n    t.first += f; //e->weight;\n    if (r.first < t.first) r = t;\n  }\n  return r;\n}\nWeight diameter(const Graph &g) {\n  Result r = visit(-1, 0, g);\n  Result t = visit(-1, r.second, g);\n  return t.first; // (r.second, t.second) is farthest pair\n}\n\nint main(){\n\tint V,s,t;\n\tscanf(\"%d\",&V);\n\tGraph g(V);\n\tfor(;V>1;V--)scanf(\"%d%d\",&s,&t),s--,t--,g[s].push_back(Edge(s,t,1)),g[t].push_back(Edge(t,s,1));\n\tprintf(\"%d\\n\",diameter(g)+count_if(g.begin(),g.end(),[](auto &e){return e.size()==1;}));\n}"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ndef dfs(q,z,c)\n\tr=[0,0,c]\n\tG[c].each{|e|\n\t\tnext if e==z\n\t\tt=dfs(q,c,e)\n\t\ta=[t[0]+1,t[1]+(G[c].size==2 ? 1 : 0)]\n\t\tif a[q]>r[q]\n\t\t\tr=[*a,t[2]]\n\t\tend\n\t}\n\tr\nend\nN=gets.to_i\nD=[0]*N\nG=N.times.map{[]}\n(N-1).times{\n\ta,b=gets.split.map(&:to_i)\n\tD[a-1]+=1\n\tD[b-1]+=1\n\tG[a-1]<<b-1\n\tG[b-1]<<a-1\n}\nx=dfs(1,-1,0)\nx=dfs(1,-1,x[2])\np x[1]+D.count{|e|e==1}"
  },
  {
    "language": "Ruby",
    "code": "F=->z,c{r=[0,c];G[c].map{|e|e!=z&&(x,y=F[c,e];r=[r,[x+4[G[c].size],y]].max)};r}\nG=(0..gets.to_i).map{[]}\n$<.map{|e|a,b=e.split.map &:to_i;G[a]<<b;G[b]<<a}\np~-G.count{|x,y|!y}+F[0,F[0,1][1]][0]"
  },
  {
    "language": "Ruby",
    "code": "F=->z,c{f=G[c].size==2?1:0;r=[0,c];G[c].map{|e|e!=z&&(x,y=F[c,e];r=[r,[x+f,y]].max)};r}\nG=(0..gets.to_i).map{[]}\n$<.map{|e|a,b=e.split.map &:to_i;G[a]<<b;G[b]<<a}\np~-G.count{|x,y|!y}+F[-1,F[-1,1][1]][0]"
  },
  {
    "language": "Ruby",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef pair<Weight, int> Result;\nResult visit(int p, int v, const Graph &g) {\n  Result r(0, v);\n  for(auto &e: g[v]) if (e.dst != p) {\n    Result t = visit(v, e.dst, g);\n    t.first += g[v].size()==2; //e->weight;\n    if (r.first < t.first) r = t;\n  }\n  return r;\n}\nWeight diameter(const Graph &g) {\n  Result r = visit(-1, 0, g);\n  Result t = visit(-1, r.second, g);\n  return t.first; // (r.second, t.second) is farthest pair\n}\n\nint main(){\n\tint V,s,t;\n\tscanf(\"%d\",&V);\n\tGraph g(V);\n\tfor(;V>1;V--)scanf(\"%d%d\",&s,&t),s--,t--,g[s].push_back(Edge(s,t,1)),g[t].push_back(Edge(t,s,1));\n\tprintf(\"%d\\n\",diameter(g)+count_if(g.begin(),g.end(),[](auto &e){return e.size()==1;}));\n}"
  },
  {
    "language": "Ruby",
    "code": "#!/usr/bin/ruby\ndef dfs(q,z,c)\n\tr=[0,0,c]\n\tG[c].each{|e|\n\t\tnext if e==z\n\t\tt=dfs(q,c,e)\n\t\ta=[t[0]+1,t[1]+(G[c].size==2 ? 1 : 0)]\n\t\tif a[q]>r[q]\n\t\t\tr=[*a,t[2]]\n\t\tend\n\t}\n\tr\nend\nN=gets.to_i\nG=N.times.map{[]}\n(N-1).times{\n\ta,b=gets.split.map(&:to_i)\n\tG[a-1]<<b-1\n\tG[b-1]<<a-1\n}\n=begin\nx=dfs(0,-1,0)\nx=dfs(1,-1,x[2])\nr=x[1]\n=end\nz=N.times.find{|i|G[i].size==2}\nr=z ? dfs(1,-1,z)[1] : 0\np r+G.count{|e|e.size==1}"
  },
  {
    "language": "Ruby",
    "code": "def F z,c;f=G[c].size==2?1:0;r=[0,c];G[c].map{|e|e!=z&&(x,y=F c,e;r=[r,[x+f,y]].max)};r end\nN=gets.to_i\nG=N.times.map{[]}\n(N-1).times{a,b=gets.split.map &:to_i;G[a-1]<<b-1;G[b-1]<<a-1}\np F(-1,F(-1,0)[1])[0]+G.count{|e|e.size==1}"
  },
  {
    "language": "Ruby",
    "code": "#pragma GCC optimize(\"O3\")\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n \ntypedef int Weight;\ntypedef int Edge;\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n \ntypedef pair<Weight, int> Result;\nResult visit(int p, int v, const Graph &g) {\n  Result r(0, v);\n  int f = g[v].size()==2;\n  for(auto &e: g[v]) if (e != p) {\n    Result t = visit(v, e, g);\n    t.first += f; //e->weight;\n    if (r.first < t.first) r = t;\n  }\n  return r;\n}\nWeight diameter(const Graph &g) {\n  Result r = visit(-1, 0, g);\n  Result t = visit(-1, r.second, g);\n  return t.first; // (r.second, t.second) is farthest pair\n}\n \nint main(){\n\tint V,s,t;\n\tscanf(\"%d\",&V);\n\tGraph g(V);\n\tfor(;V>1;V--)scanf(\"%d%d\",&s,&t),s--,t--,g[s].emplace_back(t),g[t].emplace_back(s);\n\tprintf(\"%d\\n\",diameter(g)+count_if(g.begin(),g.end(),[](auto &e){return e.size()==1;}));\n}"
  },
  {
    "language": "Ruby",
    "code": "F=->z,c{f=G[c].size==2?1:0;r=[0,c];G[c].map{|e|e!=z&&(x,y=F[c,e];r=[r,[x+f,y]].max)};r}\nG=(0..gets.to_i).map{[]}\n$<.map{|e|a,b=e.split.map &:to_i;G[a]<<b;G[b]<<a}\np-~G.count{|x,y|!y}+F[-1,F[-1,1][1]][0]"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\n\nn = int(input())\nedge = [[] for i in range(n)]\nfor i in range(n-1):\n    p, q = [int(item) - 1 for item in input().split()]\n    edge[p].append(q)\n    edge[q].append(p)\n\norder1 = 0\nfor e in edge:\n    if len(e) == 1:\n        order1 += 1\n\nmax_order = 0\ndef dfs(v, prev):\n    global max_order\n    if len(edge[v]) == 1:\n        return 0\n    order2 = 0\n    od = []\n    for nv in edge[v]:\n        if nv == prev:\n            continue\n        ret = dfs(nv, v)\n        od.append(ret)\n        order2 = max(order2, ret)\n    od.sort(reverse=True)\n    if len(edge[v]) == 2:\n        order2 += 1\n    if len(od) > 1:\n        max_order = max(max_order, od[0] + od[1] + 1)\n    elif len(edge[v]) > 2:\n        max_order = max(max_order, od[0] + od[1])\n    return order2\n\nret = dfs(0, -1)\nprint(order1 + max_order)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\nimport sys\nsys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\n\nn = int(input())\nedge = [[] for i in range(n)]\nfor i in range(n-1):\n    p, q = [int(item) - 1 for item in input().split()]\n    edge[p].append(q)\n    edge[q].append(p)\n\norder1 = 0\nfor e in edge:\n    if len(e) == 1:\n        order1 += 1\n\ndef dfs(v, prev):\n    if len(edge[v]) == 1:\n        return 0\n    order2 = 0\n    for nv in edge[v]:\n        if nv == prev:\n            continue\n        order2 = max(order2, dfs(nv, v))\n    if len(edge[v]) == 2:\n        order2 += 1\n    return order2\n\nret = dfs(0, -1)\nprint(order1 + ret)"
  },
  {
    "language": "Python",
    "code": "import sys\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 7)\n\n\"\"\"\n・次数3以上の点は使わないとしてよい\n・次数1の点は全て回収できる。次数2の点を、パスとなる形で回収する。\n\"\"\"\n\nN = int(readline())\nPQ = [tuple(int(x)-1 for x in line.split()) for line in readlines()]\n\ngraph = [[] for _ in range(N)]\nfor p,q in PQ:\n    graph[p].append(q)\n    graph[q].append(p)    \n\ndeg = [len(x) for x in graph]\n\ncnt_deg1 = sum(x==1 for x in deg)\n\ndeg2_path = 0\n\ndef dfs(x,parent):\n    global deg2_path\n    # 部分木で完結する場合、しない場合\n    arr = [dfs(y,x) for y in graph[x] if y != parent]\n    if len(arr) == 0:\n        return 0\n    if len(arr) == 1:\n        return arr[0] + (deg[x] == 2)\n    arr.sort()\n    deg2_path = max(deg2_path, arr[-1] + arr[-2] + (deg[x]==2))\n    return arr[-1] + (deg[x] == 2)\n\ndfs(0,-1)\nanswer = cnt_deg1 + deg2_path\nprint(answer)"
  }
]