[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define REP(i, n) for (ll i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (ll i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define fi first\n#define se second\n#define pb push_back\n#define debug(x) cerr << #x << \": \" << (x) << endl\n#define int long long\nusing namespace std;\nusing II = pair<int, int>;\nusing VII = vector<II>;\nusing VVII = vector<VII>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VVVI = vector<VVI>;\ntemplate <class T = int> inline T in() { T x; cin >> x; return x; }\ntemplate <class T = int> inline bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T = int> inline bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<T>& d) { int n = d.size(); REP (i, n) s << d[i] << \" \"; return s; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<vector<T>>& dd) { for (vector<T> d: dd) s << d << endl; return s; }\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nconst int MOD = 1e9 + 7;\n\nsigned main() {\n  int N = in();\n  VVI G(N);\n  REP (i, N - 1) {\n    int u, v; cin >> u >> v;\n    u--; v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  VVII dist(N); // {len, v}\n  VI far(N);\n  function<void (int, int)> dfs1 = [&](int v, int prev) {\n    for (int u: G[v]) if (u != prev) {\n      dfs1(u, v);\n      dist[v].push_back({far[u] + 1, u});\n      chmax(far[v], far[u] + 1);\n    }\n  };\n  dfs1(0, -1);\n\n  sort(RALL(dist[0]));\n  function<void (int, int)> dfs2 = [&](int v, int prev) {\n    for (int u: G[v]) if (u != prev) {\n      int tmp;\n      if (dist[v][0].se == u) {\n        tmp = dist[v].size() == 1 ? 0 : dist[v][1].fi;\n      } else {\n        tmp = dist[v][0].fi;\n      }\n      debug(tmp);\n      dist[u].pb({tmp + 1, v});\n      sort(RALL(dist[u]));\n      dfs2(u, v);\n    }\n  };\n  dfs2(0, -1);\n\n  REP (i, N) {\n    cout << 2 * (N - 1) - dist[i][0].fi << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <stack>\n#include <queue>\n#include <functional>\n#include <algorithm>\n#include <map>\n#include <unordered_map>\n#include <set>\n#include <unordered_set>\n#include <vector>\n#include <array>\n#include <tuple>\n#include <utility>\n#include <numeric>\n#include <iomanip>\n#include <cctype>\n#include <cmath>\n#include <assert.h>\n#include <cstdlib>\n#include <list>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing PII = pair<int, int>;\nusing PLL = pair<ll, ll>;\n\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s, const pair<T1, T2>& p) {\n    return s << \"(\" << p.first << \", \" << p.second << \")\";\n}\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& v) {\n    s << \"[\";\n    for (int i = 0; i < v.size(); i++) s << (i == 0 ? \"\" : \", \") << v[i];\n    s << \"]\";\n    return s;\n}\n\n#define ALL(a) (a).begin(), (a).end()\n\nusing Weight = int;\n\n// ??????????????????\nstruct Edge {\n    int from, to;\n    Weight weight;\n\n    Edge() {}\n    Edge(int to) : from(-1), to(to), weight(-1) {}\n    Edge(int from, int to) : from(from), to(to), weight(-1) {}\n    Edge(int from, int to, Weight weight) : from(from), to(to), weight(weight) {}\n\n    bool operator<(const Edge& e) const {\n        return (weight != e.weight) ? (weight < e.weight) : (from < e.from);\n    }\n    bool operator>(const Edge& e) const {\n        return (weight != e.weight) ? (weight > e.weight) : (from > e.from);\n    }\n};\n\nusing Arc = Edge;\nusing Graph = vector<vector<Edge>>;\nusing DGraph = vector<vector<Arc>>;\n\nusing Tree = Graph;\n\n// ?????????????????????????????¨????????????????????????!\nusing GArray = vector<Weight>;\nusing GMatrix = vector<GArray>;\n\n// ??????4????????¢??°???????????°??????????????????????????§?????§?????????\nvoid add_edge(Graph& g, int u, int v, Weight w = -1) {\n    g[u].push_back(Edge(u, v, w));\n    g[v].push_back(Edge(v, u, w));\n}\n\nvoid add_arc(DGraph& dg, int u, int v, Weight w = -1) {\n    dg[u].push_back(Arc(u, v, w));\n}\n\nconst int GM_INF = (1LL << 25);\n\nvoid init_gmatrix(GMatrix& gm) {\n    for (int u = 0; u < gm.size(); u++) {\n        for (int v = 0; v < gm[u].size(); v++) {\n            gm[u][v] = GM_INF;\n        }\n    }\n}\n\nvoid add_edge(GMatrix& gm, int u, int v, Weight w = -1) {\n    gm[u][v] = w;\n    gm[v][u] = w;\n}\n\nvoid add_arc(GMatrix& gm, int u, int v, Weight w = -1) {\n    gm[u][v] = w;\n}\n\nconst int MAX_N = 100010;\n\nGraph tree;\n\nint cost1[MAX_N],   // ????????????????????¨????????¨?????¨???????????¬??°\n    cost2[MAX_N];\n\nint dfs1(int id, int par) {\n    int ret = 0;\n    for (Edge& e : tree[id]) {\n        if (e.to == par) continue;\n        ret = max(ret, dfs1(e.to, id) + 1);\n    }\n    // cout << \"[id] \" << id << \" [ret] \" << ret << endl;\n    return cost1[id] = ret;\n}\n\nvoid dfs2(int id, int d_par, int par) {\n    vector<PII> info;\n    info.push_back(make_pair(0, -1));\n\n    for (Edge& e : tree[id]) {\n        if (e.to == par) {\n            info.push_back(make_pair(d_par + 1, e.to));\n        } else {\n            info.push_back(make_pair(cost1[e.to] + 1, e.to));\n        }\n    }\n    sort(ALL(info), greater<PII>());\n\n    int ret = info[0].first;\n    for (Edge& e : tree[id]) {\n        if (e.to == par) continue;\n        if (e.to == info[0].second) {\n            dfs2(e.to, info[1].first, id);\n        } else {\n            dfs2(e.to, info[0].first, id);\n        }\n    }\n    // cout << \"[id] \" << id + 1 << \" [ret] \" << ret << endl;\n    cost2[id] = ret;\n}\n\nint main() {\n    int n;\n    cin >> n;\n\n    tree.resize(n);\n\n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        add_edge(tree, u, v);\n    }\n\n    dfs1(0, -1);\n    dfs2(0, 0, -1);\n    for (int i = 0; i < n; i++) {\n        cout << (n - 1) * 2 - cost2[i] << endl;\n    }\n\n    /*\n    int a;\n    while (cin >> a, a >= 0) {\n        cout << \"[cost1] \" << cost1[a] << \" [cost2] \" << cost2[a] << endl;\n    }\n    */\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\n \n \nusing namespace std;\n \ntemplate<typename T=int>inline T readT() {\n  char c = getchar_unlocked(); bool neg = (c=='-');\n  T res = neg?0:c-'0';\n  while(isdigit(c=getchar_unlocked())) res = res*10 + c-'0';\n  return neg?-res:res;\n}\ntemplate<typename T=int>inline void writeT(T x, char c='\\n'){\n  int d[20],i=0; if(x<0)putchar_unlocked('-'),x*=-1;\n  do{d[i++]=x%10;}while(x/=10); while(i--)putchar_unlocked('0'+d[i]);\n  putchar_unlocked(c);\n}\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n \n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n \nclass UnionFind {\npublic:\n    vector <int> par; \n    vector <int> siz; \n\n    UnionFind(int sz_): par(sz_), siz(sz_, 1) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(int sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n \n    int root(int x) { \n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n \n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n \n    bool issame(int x, int y) { \n        return root(x) == root(y);\n    }\n \n    int size(int x) { \n        return siz[root(x)];\n    }\n};\n \n \nll modPow(ll x, ll n, ll mod = MOD){\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x)%mod;\n \n        res %= mod;\n        x = x * x %mod;\n        n >>= 1;\n    }\n    return res;\n}\n \n#define SIEVE_SIZE 5000000+10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve(){\n    for(int i=0; i<SIEVE_SIZE; ++i) sieve[i] = true;\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i*i<SIEVE_SIZE; ++i) if(sieve[i]) for(int j=2; i*j<SIEVE_SIZE; ++j) sieve[i*j] = false;\n}\n \nbool isprime(ll n){\n    if(n == 0 || n == 1) return false;\n    for(ll i=2; i*i<=n; ++i) if(n%i==0) return false;\n    return true;\n}\n \nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n \n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n \n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b){\n    \n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B) {\n    mat C(A.size(), vec((int)B[0].size()));\n    for(int i=0; i<A.size(); ++i){\n        for(int k=0; k<B.size(); ++k){\n            for(int j=0; j<B[0].size(); ++j){\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j] %MOD) % MOD;\n            }\n        }\n    }\n    return C;\n}\nmat matPow(mat A, ll n) {\n    mat B(A.size(), vec((int)A.size()));\n \n    for(int i=0; i<A.size(); ++i){\n        B[i][i] = 1;\n    }\n \n    while(n > 0) {\n        if(n & 1) B = mul(B, A);\n        A = mul(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\nmap<ll,ll> prime_factor(ll n) {\n  map<ll,ll> res;\n  for(ll i=2; i*i <= n; i++) {\n      while(n%i == 0) {\n          res[i]++;\n          n /= i;\n      }\n  }\n\n  if(n != 1) res[n] = 1;\n  return res;\n}\nusing ld= long double;\n\nstruct edge\n{\n    int to, cost;\n};\n\nvector<edge> g[100000];\nll dist[100010];\nll ans[100010];\nvoid dfs1(int idx, int par){\n    for(edge& e: g[idx]){\n        if(e.to == par) continue;\n        dfs1(e.to, idx);\n        dist[idx] = max(dist[idx], dist[e.to] + e.cost);\n    }\n}\nvoid dfs2(int idx, int d_par, int par){\n\n    vector<pair<int, int>> d_child;\n    d_child.emplace_back(0, -1);\n\n    for(edge &e: g[idx]){\n        if(e.to == par) d_child.emplace_back(d_par + e.cost, e.to);\n        else d_child.emplace_back(e.cost + dist[e.to], e.to);\n    }\n\n    sort(all(d_child));\n    reverse(all(d_child));\n    ans[idx] = d_child[0].first;\n\n    for(edge &e: g[idx]){\n        if(e.to == par) continue;\n        dfs2(e.to, d_child[d_child[0].second == e.to].first, idx);\n    }\n}\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(5);\n    \n    int N;\n    cin >> N;\n    for(int i=0; i<N-1; i++){\n        int a, b;\n        cin >> a >> b;\n        a--;\n        b--;\n        g[a].push_back((edge){b, 1});\n        g[b].push_back((edge){a, 1});\n    }\n\n    dfs1(0, -1);\n    dfs2(0, 0, -1);\n    for(int i=0; i<N; i++){\n        cout << 2*(N-1) - ans[i] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< int > g[100000];\nint dist[100000], ans[100000];\n\nvoid dfs1(int idx, int par)\n{\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs1(to, idx);\n    dist[idx] = max(dist[idx], dist[to] + 1);\n  }\n}\n\nvoid dfs2(int idx, int d_par, int par)\n{\n  vector< pair< int, int > > d_child;\n  d_child.emplace_back(0, -1);\n  for(int &to : g[idx]) {\n    if(to == par) d_child.emplace_back(d_par + 1, to);\n    else d_child.emplace_back(dist[to] + 1, to);\n  }\n  sort(d_child.rbegin(), d_child.rend());\n  ans[idx] = d_child[0].first;\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs2(to, d_child[d_child[0].second == to].first, idx);\n  }\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  for(int i = 0; i < N - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n\n  dfs1(0, -1);\n  dfs2(0, 0, -1);\n  for(int i = 0; i < N; i++) {\n    cout << (N - 1) * 2 - ans[i] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n\nconst int N = 1e5;\nvector<vector<int>> g(N);\nusing Value = int;\n// 戻るかどうか\nmap<int, Value> dp[N][2];\nusing P = pair<int, int>;\nvector<P> mi0(N, P(0, -1)), mi1(N, P(0, -1));\nint calced[N];\nint n;\nValue dfs(int i, int x, int p, int f = 0) {\n  if(dp[i][x].count(p)) return dp[i][x][p];\n  int cnt = 0;\n  Value res = 0;\n  if(f || p == -1) {\n    // O(deg(i))\n    // go only child\n    int mi = 0;\n    for(int j : g[i]) if(j != p) {\n      cnt++;\n      int d = 2 + dfs(j, 1, i, f);\n      res += d;\n      int m = - d + (1 + dfs(j, 0, i, f));\n      mi = min(mi, m);\n      if(p == -1 && !calced[i]) {\n        P r(m, j);\n        if(mi0[i] > r) {\n          mi1[i] = mi0[i];\n          mi0[i] = r;\n        } else if(mi1[i] > r) {\n          mi1[i] = r;\n        }\n      }\n    }\n    if(p == -1) calced[i] = 1;\n    if(!x) {\n      res += mi;\n    }\n  } else {\n    // O(1)\n    cnt = g[i].size() - 1;\n    if(x) {\n      res = dfs(i, 1, -1, f);\n    } else {\n      res = dfs(i, 0, -1, f);\n      if(mi0[i].second == p) {\n        res -= mi0[i].first;\n        res += mi1[i].first;\n      }\n    }\n    res -= 2 + dfs(p, 1, i, f);\n  }\n  return dp[i][x][p] = res;\n}\nint main() {\n  std::ios::sync_with_stdio(false), std::cin.tie(0);\n  cin >> n;\n  for(int i = 0; i < n - 1; i++) {\n    int a, b; cin >> a >> b; a--; b--;\n    g[a].emplace_back(b);\n    g[b].emplace_back(a);\n  }\n  dfs(0, 0, -1, 1);\n  dfs(0, 1, -1, 1);\n  cout << fixed << setprecision(8);\n  for(int i = 0; i < n; i++) cout << dfs(i, 0, -1) << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nVI g[100010];\nsigned main(void)\n{\n  int n;\n  cin >> n;\n  REP(i, n-1) {\n    int u, v;\n    cin >> u >> v;\n    u--, v--;\n    g[u].PB(v);\n    g[v].PB(u);\n  }\n\n  VI dist(n);\n  function<void(int,int)> dfs1 = [&](int v, int p) {\n    for(int &i: g[v]) if(i != p) {\n      dfs1(i, v);\n      chmax(dist[v], dist[i] + 1);\n    }\n  };\n\n  dfs1(0, -1);\n  // cout << dist << endl;\n\n  // ans[i] = (頂点iから最も遠い頂点)\n  VI ans(n);\n  function<void(int,int,int)> dfs2 = [&](int v, int pval, int p) {\n    // vの子の情報を集める\n    vector<PII> d_child;\n    // d_child[0], d_child[1]が存在しないのを防ぐ\n    d_child.PB({0, -1});\n    for(int &i: g[v]) {\n      if(i == p) d_child.PB({pval+1, i});\n      else d_child.PB({dist[i]+1, i});\n    }\n    sort(ALL(d_child), greater<>());\n    ans[v] = d_child[0].first;\n    for(int &i: g[v]) if(i != p) {\n      // pvalはd_childの最大が基本\n      // 最大が頂点iの部分木ならそれがpvalにはならないので次に大きいのをpvalにする\n      dfs2(i, d_child[d_child[0].second == i].first, v);\n    }\n  };\n\n  dfs2(0, 0, -1);\n  // cout << ans << endl;\n\n  // 全ての辺を2回通るのが基本で最大の深さのところだけ行って戻らないので片道分でいい\n  REP(i, n) cout << 2*(n-1) - ans[i] << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\ntemplate <class T, class W> \nclass rerooting {\nprivate:\n    struct edge {\n        ll to, rev;\n        W w;\n    };\n\n    const ll n;\n    vector<vector<edge>> g;\n    vector<vector<T>> ldp, rdp;\n    vector<ll> lptr, rptr;\n    const function<T(T,T)> merge;\n    const function<T(T,W)> add;\n    const T id;\n\n    T dfs(ll v, ll p) {\n        while(lptr[v] != p && lptr[v] < (ll)g[v].size()) {\n            edge &e = g[v][lptr[v]];\n            ldp[v][lptr[v]+1] = merge(ldp[v][lptr[v]], add(dfs(e.to, e.rev), e.w));\n            lptr[v]++;\n        }\n        while(rptr[v] != p && rptr[v] >= 0) {\n            edge &e = g[v][rptr[v]];\n            rdp[v][rptr[v]] = merge(add(dfs(e.to, e.rev), e.w), rdp[v][rptr[v]+1]);\n            rptr[v]--;\n        }\n        if(p < 0) return rdp[v][0];\n        return merge(ldp[v][p], rdp[v][p+1]);\n    }\n\npublic:\n    rerooting(ll n, function<T(T,T)> merge, function<T(T,W)> add, T id) : n(n), g(n), ldp(n), rdp(n), lptr(n), rptr(n), merge(merge), add(add), id(id) {}\n\n    void add_edge(ll u, ll v, W w) {\n        g[u].push_back({v, (ll)g[v].size(), w});\n        g[v].push_back({u, (ll)g[u].size()-1, w});\n    }\n\n    vector<T> build() {\n        REP(i, n) {\n            ldp[i].assign(g[i].size()+1, id);\n            rdp[i].assign(g[i].size()+1, id);\n            lptr[i] = 0;\n            rptr[i] = (ll)g[i].size()-1;\n        }\n        vector<T> ans;\n        REP(i, n) ans.emplace_back(dfs(i, -1));\n        return ans;\n    }\n};\n\nint main(void) {\n    ll n;\n    cin >> n;\n\n    auto merge = [&](ll l, ll r) { return max(l, r); };\n    auto add = [&](ll v, ll w) { return v+w; };\n    rerooting<ll, ll> graph(n, merge, add, 0);\n\n    REP(i, n-1) {\n        ll u, v;\n        cin >> u >> v;\n        u--, v--;\n        graph.add_edge(u, v, 1);\n    }\n    auto ans = graph.build();\n\n    REP(i, n) cout << 2*(n-1) - ans[i] << \"\\n\";\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst double PI  = 3.1415926535897932384626433832795028841971;\nconst int    INF = 1000000007;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint n;\nbool saw[100000];\nvector<int> d[100000];\nvector<int> v[100000];\n\nint dfs(int x){\n    int ret = 0;\n    saw[x] = true;\n    rep(i,v[x].size()){\n        if(saw[v[x][i]]) continue;\n        int z = dfs(v[x][i]);\n        if(d[x].size() < 2) d[x].push_back(z);\n        else{\n            if(z > d[x][1]) d[x][1] = z;\n        }\n        if(d[x][0] < d[x][1]) swap(d[x][0],d[x][1]);\n        ret = max(ret,d[x][d[x].size()-1]);\n    }\n    return ret+1;\n}\n\nvoid dfs2(int x){\n    saw[x] = true;\n    rep(i,v[x].size()){\n        if(!saw[v[x][i]]) continue;\n        int dep;\n        if(d[x].size() != 0) dep = d[x][0];\n        else dep = 0;\n        if(1+dep != d[v[x][i]][0]){\n            d[x].push_back(d[v[x][i]][0]+1);\n        } else{\n            if(d[v[x][i]].size() == 1) d[x].push_back(1);\n            else d[x].push_back(d[v[x][i]][1]+1);\n        }\n    }\n    sort(d[x].begin(),d[x].end(),greater<int>());\n    rep(i,v[x].size()){\n        if(saw[v[x][i]]) continue;\n        dfs2(v[x][i]);\n    }\n}\n\nint main(){\n    cin >> n;\n    rep(i,n-1){\n        int a, b;\n        scanf(\"%d%d\",&a,&b);\n        a--; b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    dfs(0);\n    rep(i,n) sort(d[i].begin(),d[i].end(),greater<int>());\n    rep(i,n) saw[i] = false;\n    dfs2(0);\n    rep(i,n) printf(\"%d\\n\",(n-1)*2-d[i][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }\n\n\nvector<int> t_parent;\nvi t_ord;\n\nvoid tree_getorder(const vector<vi> &g, int root) {\n\tint n = g.size();\n\tt_parent.assign(n, -1);\n\tt_ord.clear();\n\n\tvector<int> stk; stk.push_back(root);\n\twhile(!stk.empty()) {\n\t\tint i = stk.back(); stk.pop_back();\n\t\tt_ord.push_back(i);\n\t\tfor(int j = (int)g[i].size() - 1; j >= 0; j --) {\n\t\t\tint c = g[i][j];\n\t\t\tif(t_parent[c] == -1 && c != root)\n\t\t\t\tstk.push_back(c);\n\t\t\telse\n\t\t\t\tt_parent[i] = c;\n\t\t}\n\t}\n}\n\nstruct Eccentricity {\n\tint dist, i;\n\tEccentricity() : dist(-INF), i(-1) {}\n\tEccentricity(int dist, int i) : dist(dist), i(i) {}\n\tbool operator<(const Eccentricity &that) {\n\t\treturn dist != that.dist ? dist < that.dist : i < that.i;\n\t}\n\tEccentricity operator+(int c) const {\n\t\treturn Eccentricity(dist + c, i);\n\t}\n};\n\nvoid treeEccentricities(const vector<vi> &g, vector<Eccentricity> &res) {\n\tint n = g.size();\n\n\tvector<pair<Eccentricity, Eccentricity> > dp(n);\n\tfor(int ix = n - 1; ix >= 0; -- ix) {\n\t\tint i = t_ord[ix], p = t_parent[i];\n\t\tdp[i].first = dp[i].second = Eccentricity(0, i);\n\t\tfor(int j : g[i]) if(j != p) {\n\t\t\tEccentricity v = dp[j].first + 1;\n\t\t\tif(dp[i].first < v) {\n\t\t\t\tdp[i].second = dp[i].first;\n\t\t\t\tdp[i].first = v;\n\t\t\t} else if(dp[i].second < v) {\n\t\t\t\tdp[i].second = v;\n\t\t\t}\n\t\t}\n\t}\n\tres.assign(n, Eccentricity());\n\tres[0] = Eccentricity(0, 0);\n\treu(ix, 1, n) {\n\t\tint i = t_ord[ix], p = t_parent[i];\n\t\tint pw = 1;\n\t\tres[i] = res[p] + pw;\n\t\tif(dp[p].first.i == dp[i].first.i)\n\t\t\tamax(res[i], dp[p].second + pw);\n\t\telse\n\t\t\tamax(res[i], dp[p].first + pw);\n\t}\n\trep(i, n)\n\t\tamax(res[i], dp[i].first);\n}\n\nint main() {\n\tint N;\n\twhile(~scanf(\"%d\", &N)) {\n\t\tvector<vector<int> > g(N);\n\t\tfor(int i = 0; i < N - 1; ++ i) {\n\t\t\tint u, v;\n\t\t\tscanf(\"%d%d\", &u, &v), -- u, -- v;\n\t\t\tg[u].push_back(v);\n\t\t\tg[v].push_back(u);\n\t\t}\n\t\ttree_getorder(g, 0);\n\t\tvector<Eccentricity> ecc;\n\t\ttreeEccentricities(g, ecc);\n\t\trep(i, N) {\n\t\t\tint ans = (N - 1) * 2 - ecc[i].dist;\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Edge{\n\tEdge(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\n\nstruct Info{\n\tInfo(int arg_node_id,int arg_depth){\n\t\tnode_id = arg_node_id;\n\t\tdepth = arg_depth;\n\t}\n\tbool operator<(const struct Info &arg) const{\n\t\treturn depth < arg.depth;\n\t}\n\n\tint node_id,depth;\n};\n\nstruct RevInfo{\n\tRevInfo(int arg_node_id,int arg_depth){\n\t\tnode_id = arg_node_id;\n\t\tdepth = arg_depth;\n\t}\n\tbool operator<(const struct RevInfo &arg) const{\n\t\treturn depth > arg.depth;\n\t}\n\n\tint node_id,depth;\n};\n\nstruct Data{\n\tvoid set(int arg_max_dist1,int arg_max_dist2,int arg_node1,int arg_node2){\n\t\tmax_dist1 = arg_max_dist1;\n\t\tmax_dist2 = arg_max_dist2;\n\t\tnode1 = arg_node1;\n\t\tnode2 = arg_node2;\n\t}\n\tint max_dist1,max_dist2,node1,node2,parent_dir_max_dist;\n};\n\nint *depth_table,*parent;\nvector<Edge> G[100000];\nData data[100000];\n\nvoid calcDepth(int node_id,int depth,int parent_id){\n\tdepth_table[node_id] = depth;\n\tparent[node_id] = parent_id;\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\t\tif(G[node_id][i].to == parent_id)continue;\n\t\tcalcDepth(G[node_id][i].to,depth+1,node_id);\n\t}\n}\n\nint main(){\n\n\tint N;\n\tscanf(\"%d\",&N);\n\n\tdepth_table = new int[N];\n\tparent = new int[N];\n\n\tfor(int i = 0; i < N; i++){\n\t\tdata[i].max_dist1 = -1;\n\t\tdata[i].max_dist2 = -1;\n\t\tdata[i].parent_dir_max_dist = -1;\n\t}\n\n\tint from,to;\n\tfor(int loop = 0; loop < N-1; loop++){\n\t\tscanf(\"%d %d\",&from,&to);\n\t\tfrom--;\n\t\tto--;\n\t\tG[from].push_back(Edge(to,1));\n\t\tG[to].push_back(Edge(from,1));\n\t}\n\n\tcalcDepth(0,0,-1);\n\n\tpriority_queue<Info> Q;\n\n\tfor(int i = 0; i < N; i++){\n\t\tQ.push(Info(i,depth_table[i]));\n\t}\n\n\n\tint max1,max2,node1,node2;\n\twhile(!Q.empty()){\n\n\t\tmax1 = 0,max2 = 0;\n\n\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\tif(G[Q.top().node_id][i].to == parent[Q.top().node_id])continue;\n\n\t\t\tif(max1 < data[G[Q.top().node_id][i].to].max_dist1 + G[Q.top().node_id][i].cost){\n\t\t\t\tmax2 = max1;\n\t\t\t\tnode2 = node1;\n\t\t\t\tmax1 = data[G[Q.top().node_id][i].to].max_dist1 + G[Q.top().node_id][i].cost;\n\t\t\t\tnode1 = G[Q.top().node_id][i].to;\n\t\t\t}else if(max2 < data[G[Q.top().node_id][i].to].max_dist1 + G[Q.top().node_id][i].cost){\n\t\t\t\tmax2 = data[G[Q.top().node_id][i].to].max_dist1 + G[Q.top().node_id][i].cost;\n\t\t\t\tnode2 = G[Q.top().node_id][i].to;\n\t\t\t}\n\t\t}\n\t\tdata[Q.top().node_id].set(max1,max2,node1,node2);\n\t\tQ.pop();\n\t}\n\n\tpriority_queue<RevInfo> RevQ;\n\n\tfor(int i = 0; i < N; i++){\n\t\tRevQ.push(RevInfo(i,depth_table[i]));\n\t}\n\n\tint parent_node;\n\twhile(!RevQ.empty()){\n\n\t\tif(parent[RevQ.top().node_id] == -1){\n\t\t\tRevQ.pop();\n\t\t\tcontinue;\n\t\t}\n\n\t\tparent_node = parent[RevQ.top().node_id];\n\n\t\tif(data[parent_node].parent_dir_max_dist != -1){\n\t\t\tdata[RevQ.top().node_id].parent_dir_max_dist = max(data[RevQ.top().node_id].parent_dir_max_dist,data[parent_node].parent_dir_max_dist+1);\n\t\t}\n\n\t\tif(data[parent_node].node1 != RevQ.top().node_id){\n\t\t\tdata[RevQ.top().node_id].parent_dir_max_dist = max(data[RevQ.top().node_id].parent_dir_max_dist,data[parent_node].max_dist1+1);\n\t\t}else if(data[parent_node].max_dist2 != -1 && data[parent_node].node2 != RevQ.top().node_id){\n\t\t\tdata[RevQ.top().node_id].parent_dir_max_dist = max(data[RevQ.top().node_id].parent_dir_max_dist,data[parent_node].max_dist2+1);\n\t\t}\n\t\tRevQ.pop();\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tprintf(\"%d\\n\",2*(N-1)-max(data[i].parent_dir_max_dist,data[i].max_dist1));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// step[i] := ?????? 0 ????????¨????????¨????????????????????? i ???????????????????????¨????????¢\n// ans [i] := ?????? i ????????¨????????¨????????????????????? i ???????????????????????¨????????¢\n// ?????? i ??????????????????????????§???????????? 1 ???????????????????????????????????\\?????? 2 ?????????\n// ???????????£???????????????????????? 2 * (n-1) - ans[i] ??§??????\n\nint step[100010], ans[100010];\nvector<int> G[100010];\n\nvoid dfs(int idx, int par) {\n    for(auto to : G[idx]) {\n        if(to == par) continue;\n        dfs(to, idx);\n        step[idx] = max(step[idx], step[to] + 1);\n    }\n}\n\nvoid dfs2(int idx, int d_par, int par) {\n    vector<pii> rec;\n    rec.push_back(pii(0, -1));\n    for(auto to : G[idx]) {\n        if(to == par) rec.push_back(pii(d_par + 1, to));\n        else rec.push_back(pii(step[to] + 1, to));\n    }\n    sort(rec.rbegin(), rec.rend());\n    ans[idx] = rec[0].first;\n    for(auto to : G[idx]) {\n        if(to == par) continue;\n        dfs2(to, rec[ rec[0].second == to ].first, idx);\n    }\n}\n\nsigned main() {\n    int n; cin >> n;\n    rep(i,0,n-1) {\n        int u, v; cin >> u >> v;\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dfs(0, -1);\n    dfs2(0, 0, -1);\n    rep(i,0,n) cout << (n-1) * 2 - ans[i] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\n#define REP(i, k, n) for(int i = k; i < n; i++)\n#define rep(i, n) for(int i = 0; i < n; i++) \n#define mp make_pair\n#define MAX_N 100005\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\n\nvector<int> g[MAX_N];\nP cnt[MAX_N][5];\nbool used[MAX_N];\nint ans[MAX_N];\n\nvoid dfs(int cur) {\n\tused[cur] = true;\n\n\tvector<P> res;\n\trep(i, g[cur].size()) {\n\t\tint to = g[cur][i];\n\t\tif(used[to]) continue;\n\n\t\tdfs(to);\n\t\tres.push_back(mp(cnt[to][0].first + 1, to));\n\t}\n\n\tsort(res.begin(), res.end(), greater<P>());\n\trep(i, min((int)res.size(), 2)) {\n\t\tcnt[cur][i] = res[i];\n\t}\n}\n\nvoid solve(int cur, int prev, int len) {\n\tint res = cnt[cur][0].first;\n\tint newlen = len;\n\n\tans[cur] = max(res, newlen);\n\n\trep(i, g[cur].size()) {\n\t\tint to = g[cur][i];\n\t\tif(to == prev) continue;\n\t\tint x = 0;\n\n\t\tif(to == cnt[cur][0].second) {\n\t\t\tx = cnt[cur][1].first;\n\t\t} else {\n\t\t\tx = cnt[cur][0].first;\n\t\t}\n\n\t\tsolve(to, cur, max(x, newlen) + 1);\n\t}\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\n\trep(i, N-1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\trep(i, N) {\n\t\tcnt[i][0].first = 0;\n\t\tcnt[i][1].first = 0;\n\n\t\tcnt[i][0].second = -1;\n\t\tcnt[i][1].second = -1;\n\t}\n\n\tint root = 0;\n\t// int root = rand() % N;\n\tmemset(used, 0, sizeof(used));\n\tdfs(root);\n\n\tmemset(ans, 0, sizeof(ans));\n\tsolve(0, -1, 0);\n\n\trep(i, N) {\n\t\tcout << 2 * (N - 1) - ans[i] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef LL ut;\ntypedef pair<ut,ut> pr;\ntypedef vector<ut> VI;\ntypedef vector<pr> Vpr;\ntypedef priority_queue<pr,Vpr,greater<pr> > PQ;\nconst int SIZE=2*1e5;\nconst ut INF=1LL<<60;\nVI edge[SIZE];\nbool dead[SIZE];\nLL ans[SIZE];\nbool searched[SIZE];\nint needs[SIZE];\nint grav[SIZE];\nint dist[SIZE];\nint nums[SIZE];\nint sums[SIZE];\nint times[SIZE];\nint depthest[SIZE];\nint timer;\nVpr depters[SIZE];\nLL dfs(int now,int from,VI& nodes,int depth,bool want){\n\tif(dead[now]){\n\t\tif(from!=depters[now][0].second) return depters[now][0].first+depth;\n\t\treturn depters[now][1].first+depth;\n\t}\n\ttimer++;\n\tif(want)\n\t\tnodes.PB(now);\n\tLL ans=dist[now]=depth;\n\t//cout << now << \" \" << depth << endl;\n\tREP(i,edge[now].size()){\n\t\tint next=edge[now][i];\n\t\tif(next!=from)\n\t\t\tans=max(ans,dfs(next,now,nodes,depth+1,want));\n\t}\n\treturn ans;\n}\n/*\nvoid gives(int now,int from,int depth,LL alls,LL nodes){\n\tans[now]+=depth*nodes+alls;\n\tREP(i,edge[now].size()){\n\t\tint next=edge[now][i];\n\t\tif(next!=from && !dead[next])\n\t\t\tgives(next,now,depth+1,alls,nodes);\n\t}\n}*/\nvoid centerize(int now,VI& nodes){\n\tcat;\n\tdead[now]=true;\n\tVI dummy;\n//\tLL alls=0;\n\t//cout << now;\n\tREP(i,edge[now].size()){\n\t\ttimer=0;\n\t\tint next=edge[now][i];\n\t\t//if(dead[next]) continue;\n\t\tdepters[now].PB(pr(dfs(next,now,dummy,1,false),next));\n\t//\tcout << depters[now].back().first;\n//\t\tnums[i]=timer;\n//\t\talls+=sums[i];\n\t}\n\tdummy.clear();\n\t//cout << endl;\n\tdepters[now].PB(pr(0,-1));\n\tsort(ALL(depters[now]),greater<pr>());\n//\tans[now]+=alls;\n//\tREP(i,edge[now].size()){\n//\t\tint next=edge[now][i];\n//\t\tif(dead[next]) continue;\n//\t\tgives(next,now,1,alls-sums[i],nodes.size()-nums[i]);\n//\t\talls+=sums[i];\n//\t}\n\tcat;\t\n}\n\nvoid solve(int now){\n\tcat;\n\tVI nodes;\n\tPQ qu;\n\tdfs(now,-1,nodes,1,true);\n\tcat;\n\tint last=nodes[0];\n\tcat;\n\tcat;\n\tREP(i,nodes.size()){\n\t\tneeds[nodes[i]]=-1;\n\t\tsearched[nodes[i]]=false;\n\t\tgrav[nodes[i]]=0;\n\t\tREP(j,edge[nodes[i]].size()){\n\t\t\tint next=edge[nodes[i]][j];\n\t\t\tif(!dead[next]) needs[nodes[i]]++;\n\t\t}\n\n\t\tif(needs[nodes[i]]==0) qu.push(pr(0,nodes[i]));\n\t}\n\tcat;\n\twhile(!qu.empty()){\n\t\tint now=qu.top().second,gravity=qu.top().first;\n\t\tqu.pop();\n\t\tsearched[now]=true;\n\t\tlast=now;\n\t\tREP(i,edge[now].size()){\n\t\t\tint next=edge[now][i];\n\t\t\tif(dead[next]) continue;\n\t\t\tif(searched[next]) continue;\n\t\t\tgrav[next]+=grav[now]+1;\n\t\t\ttimes[next]++;\n\t\t\tif(times[next]==needs[next]) qu.push(pr(grav[next],next));\n\t\t}\n\n\t}\n\tcenterize(last,nodes);\n\tnodes.clear();\n\tREP(i,edge[last].size()){\n\t\tint next=edge[last][i];\n\t\tif(dead[next]) continue;\n\t\tsolve(next);\n\t}\n}\nint main(){\n\tint N,u,v;\n\tcin >> N;\n\tif(N>=10000) return 0; \n\tREP(i,N-1){\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tedge[u].PB(v);\n\t\tedge[v].PB(u);\n\t}\n\tsolve(1);\n\tFOR(i,1,N+1){\n\t\tprintf(\"%lld\\n\",N*2-2-depters[i][0].first);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst double PI  = 3.1415926535897932384626433832795028841971;\nconst int    INF = 1000000007;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint n;\nbool saw[100000];\nvector<int> d[100000];\nvector<int> v[100000];\n\nint dfs(int x){\n    int ret = 0;\n    saw[x] = true;\n    rep(i,v[x].size()){\n        if(saw[v[x][i]]) continue;\n        int z = dfs(v[x][i]);\n        if(d[x].size() < 2) d[x].push_back(z);\n        else{\n            if(z > d[x][1]) d[x][1] = z;\n            if(d[x][0] < d[x][1]) swap(d[x][0],d[x][1]);\n        }\n        ret = max(ret,d[x][d[x].size()-1]);\n    }\n    return ret+1;\n}\n\nvoid dfs2(int x){\n    saw[x] = true;\n    rep(i,v[x].size()){\n        if(!saw[v[x][i]]) continue;\n        int dep;\n        if(d[x].size() != 0) dep = d[x][0];\n        else dep = 0;\n        if(1+dep != d[v[x][i]][0]){\n            d[x].push_back(d[v[x][i]][0]+1);\n        } else{\n            if(d[v[x][i]].size() == 1) d[x].push_back(1);\n            else d[x].push_back(d[v[x][i]][1]+1);\n        }\n    }\n    sort(d[x].begin(),d[x].end(),greater<int>());\n    rep(i,v[x].size()){\n        if(saw[v[x][i]]) continue;\n        dfs2(v[x][i]);\n    }\n}\n\nint main(){\n    cin >> n;\n    rep(i,n-1){\n        int a, b;\n        scanf(\"%d%d\",&a,&b);\n        a--; b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    dfs(0);\n    rep(i,n) sort(d[i].begin(),d[i].end(),greater<int>());\n    rep(i,n) saw[i] = false;\n    dfs2(0);\n    rep(i,n) printf(\"%d\\n\",(n-1)*2-d[i][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define F first\n#define S second\n#define pii pair<int, int>\n#define eb emplace_back\n#define all(v) v.begin(), v.end()\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define rep3(i, l, n) for (int i = l; i < (n); ++i)\n#define sz(v) (int)v.size()\nconst int inf = 1e9 + 7;\nconst ll INF = 1e18;\n#define abs(x) (x >= 0 ? x : -(x))\n#define lb(v, x) (int)(lower_bound(all(v), x) - v.begin())\n#define ub(v, x) (int)(upper_bound(all(v), x) - v.begin())\ntemplate<typename T1, typename T2> inline bool chmin(T1 &a, T2 b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<typename T1, typename T2> inline bool chmax(T1 &a, T2 b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<typename T> T gcd(T a, T b) { if (b == 0) return a; return gcd(b, a % b); }\ntemplate<typename T> T lcm(T a, T b) { return a / gcd(a, b) * b; }\ntemplate<typename T> T pow(T a, int b) { return b ? pow(a * a, b / 2) * (b % 2 ? a : 1) : 1; }\nconst int mod = 1000000007;\nll modpow(ll a, int b) { return b ? modpow(a * a % mod, b / 2) * (b % 2 ? a : 1) % mod : 1; }\ntemplate<class T> ostream& operator<<(ostream& os, const vector<T>& vec) { for (auto &vi: vec) os << vi << \" \"; return os; }\ntemplate<class T, class U> ostream& operator<<(ostream& os, const pair<T, U>& p) { os << p.F << \" \" << p.S; return os; }\ntemplate<class T> inline void add(T &a, int b) { a += b; if (a >= mod) a -= mod; }\n\n\n\nvoid solve();\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n    int T;\n    // cin >> T;\n    T = 1;\n\n    while (T--) {\n        solve();\n    }\n}\n\n\n// https://ei1333.hateblo.jp/entry/2017/04/10/224413\nstruct edge { int to, cost; };\n\nconst int maxn = 100005;\nvector<edge> G[maxn];\nll dist[maxn];\n// i から i の (決めた頂点を根とする) 部分木内で一番遠い頂点までの距離\n// 根を除く葉の dist は 0\nvoid dfs(int v, int p) {\n  for (edge& e : G[v]) {\n    if (e.to == p) continue;\n    dfs(e.to, v);\n    // dfs から上がってきたタイミングで\n    chmax(dist[v], dist[e.to] + e.cost);\n  }\n}\n\nvector<int> ans(maxn);\n\n// v を根とする答え\n// Dpar : v の親方向の, v から一番遠い頂点と v の距離\nvoid dfs2(int v, int Dpar, int p) {\n  vector<pii> d_child;\n  d_child.eb(0, -1); // 下で最大2つを取るが, 2つないとき用\n\n  for (edge& e : G[v]) {\n    // 親との距離と, 親方向の部分木で一番遠い頂点との距離の和\n    if (e.to == p) d_child.eb(Dpar + e.cost, e.to);\n    // 部分木の, ある頂点 j への距離と, j と j の部分木内での一番遠い頂点との距離の和\n    else d_child.eb(e.cost + dist[e.to], e.to);\n  }\n  sort(d_child.rbegin(), d_child.rend());\n  // sort 後, 最大 2 つ\n  ans[v] = d_child[0].F ;\n\n  // 同じ部分木内で木の直径が実現されることがある\n  for (edge& e : G[v]) {\n    if (e.to == p) continue;\n    // v と一番遠い方向 f に行かない\n    // 2 番手の方に行けば, f の距離を d_p にもつ\n    dfs2(e.to, d_child[d_child[0].S == e.to].F, v);\n  }\n}\n\nvoid solve() {\n  int n;\n  cin >> n;\n  rep(i, n - 1) {\n    int a, b;\n    cin >> a >> b;\n    a--; b--; // debuged\n    G[a].eb(edge{b, 1});\n    G[b].eb(edge{a, 1});\n  }\n  dfs(0, -1);\n  dfs2(0, 0, -1);\n  // 各辺 2 回通るが, 一番長いのだけ 1 回\n  rep(i, n) cout << (n - 1) * 2 - ans[i] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\n// [問題設定]\n// それぞれ1からNまでの番号が付いたN個の頂点が、N-1本の無向辺によって繋がれたグラフが与えられる。\n// 各頂点について、その頂点からスタートしてすべての頂点を訪れるための最短のステップ数を出力せよ。\n//\n// [解法]\n// 各頂点からの最遠頂点までの距離を辺の数の2倍から引く\n// 全方位木DPで解く\n\nusing T = ll; // データ型\nint n; // 頂点\nvector<vector<int>> tree;\nvector<T> dist; // 根付き木中の i の\nvector<T> ans;\n\nvoid dfs1(int v, int p = -1) {\n    T res = 0;\n    for (auto &u : tree[v]) {\n        if (u == p) continue;\n        dfs1(u, v);\n        res = max(res, dist[u] + 1);\n    }\n    dist[v] = res;\n}\n\nvoid dfs2(int v, T d_par, int p = -1) {\n    // v における答えの計算\n    ans[v] = max(d_par + 1, dist[v]);\n\n    // 左右からの累積演算を用いて子に送る d_par の計算\n    // lf[i] : [:i-1]の演算結果\n    // ri[i] : [i+1:]の演算結果\n    auto f = [](T a, T b) { return max(a, b); }; // 演算\n    int e = -1; // 演算の単位元\n    vector<T> lf(tree[v].size(), e), ri(tree[v].size(), e); // 累積配列\n    for (int i = 1; i < tree[v].size(); i++) {\n        if (tree[v][i - 1] == p) lf[i] = f(d_par, lf[i - 1]);\n        else lf[i] = f(dist[tree[v][i - 1]], lf[i - 1]);\n    }\n    for (int i = tree[v].size() - 2; i >= 0; i--) {\n        if (tree[v][i + 1] == p) ri[i] = f(d_par, ri[i + 1]);\n        else ri[i] = f(dist[tree[v][i + 1]], ri[i + 1]);\n    }\n    for (int i = 0; i < tree[v].size(); i++) {\n        if (tree[v][i] == p) continue;\n        dfs2(tree[v][i], f(lf[i], ri[i]) + 1, v);\n    }\n}\n\nint main() {\n    cin >> n;\n    tree.resize(n);\n    dist.resize(n);\n    ans.resize(n);\n    for (int i = 0; i < n - 1; i++) {\n        int u, v; cin >> u >> v;\n        u--; v--;\n        tree[u].push_back(v);\n        tree[v].push_back(u);\n    }\n    dfs1(0);\n    dfs2(0, 0);\n    for (int i = 0; i < n; i++) {\n        cout << 2 * (n - 1) - ans[i] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <cstddef>\n#include <vector>\n#include <algorithm>\n#include <utility>\n#include <limits>\n#include <type_traits>\n#include <tuple>\n\ntemplate <typename F>\nclass fix_point: F {\npublic:\n  explicit constexpr fix_point(F&& f) noexcept: F(std::forward<F>(f)) {}\n\n  template <typename... Args>\n  constexpr decltype(auto) operator ()(Args&&... args) const {\n    return F::operator ()(*this, std::forward<Args>(args)...);\n  }\n};\n\ntemplate <typename F>\nstatic inline constexpr decltype(auto) make_fix_point(F&& f) noexcept {\n  return fix_point<F>{std::forward<F>(f)};\n}\n\ntemplate <typename WeightType>\nclass weighted_edge {\npublic:\n  using size_type = size_t;\n  using weight_type = WeightType;\n\nprotected:\n  size_type M_src, M_dst;\n  weight_type M_weight;\n\npublic:\n  weighted_edge() = default;\n  weighted_edge(weighted_edge const&) = default;\n  weighted_edge(weighted_edge&&) = default;\n\n  weighted_edge(size_type s, size_type d, weight_type w):\n    M_src(s), M_dst(d), M_weight(w)\n  {}\n\n  weighted_edge& operator =(weighted_edge const&) = default;\n  weighted_edge& operator =(weighted_edge&&) = default;\n\n  bool operator <(weighted_edge const& other) const {\n    if (M_weight < other.M_weight) return true;\n    if (other.M_weight < M_weight) return false;\n    if (M_src != other.M_src) return M_src < other.M_src;\n    return M_dst < other.M_dst;\n  }\n\n  size_type source() const { return M_src; }\n  size_type target() const { return M_dst; }\n  weight_type weight() const { return M_weight; }\n};\n\nstruct directed_tag {};\nstruct undirected_tag {};\n\ntemplate <typename Edge, typename Directedness>\nclass adjacency_list {\npublic:\n  using size_type = size_t;\n  using edge_type = Edge;\n  using weight_type = typename Edge::weight_type;\n  static constexpr weight_type inf = std::numeric_limits<weight_type>::max();\n\nprivate:\n  std::vector<std::vector<edge_type>> M_g;\n\npublic:\n  adjacency_list() = default;\n  adjacency_list(adjacency_list const&) = default;\n  adjacency_list(adjacency_list&&) = default;\n  adjacency_list(size_type n): M_g(n) {}\n\n  template <typename... Args>\n  void emplace(size_type src, size_type dst, Args... args) {\n    M_g[src].emplace_back(src, dst, args...);\n    if (std::is_same<Directedness, undirected_tag>::value)\n      M_g[dst].emplace_back(dst, src, args...);\n  }\n\n  void sort_by_index() {\n    auto cmp = [](auto const& e1, auto const& e2) {\n      return e1.target() < e2.target();\n    };\n    for (auto v: M_g) std::sort(v.begin(), v.end(), cmp);\n  }\n\n  size_type size() const { return M_g.size(); }\n  std::vector<edge_type> const& operator [](size_type i) const { return M_g[i]; }\n};\n\ntemplate <typename Edge, typename Directedness>\nconstexpr typename Edge::weight_type inf = adjacency_list<Edge, Directedness>::inf;\n\nconstexpr intmax_t  operator \"\"_jd(unsigned long long n) { return n; }\nconstexpr uintmax_t operator \"\"_ju(unsigned long long n) { return n; }\nconstexpr size_t    operator \"\"_zu(unsigned long long n) { return n; }\n// constexpr ptrdiff_t operator \"\"_td(unsigned long long n) { return n; }\n\ntemplate <typename Monoid, typename UndirectedTree>\nauto dp_on_tree(UndirectedTree const& g) {\n  Monoid e{};\n  size_t n = g.size();\n  std::vector<size_t> parent(n, -1_zu);\n\n  std::vector<std::vector<Monoid>> dp0(n), dp1(n);\n  std::vector<Monoid> dp(n);\n  for (size_t i = 0; i < n; ++i) {\n    dp0[i].resize(g[i].size()+1, e);\n    dp1[i].resize(g[i].size()+1, e);\n  }\n\n  make_fix_point([&](auto dfs0, size_t v, size_t p) -> Monoid {\n      Monoid res = e;\n      typename UndirectedTree::weight_type weight{};\n      for (size_t i = 0; i < g[v].size(); ++i) {\n        size_t u = g[v][i].target();\n        if (u == p) {\n          parent[v] = i;\n          weight = g[v][i].weight();\n          continue;\n        }\n        Monoid tmp = dfs0(u, v);\n        res.append(tmp);\n        dp0[v][i+1] = dp1[v][i] = tmp;\n      }\n      return res.f(weight);\n  })(0, -1_zu);\n\n  make_fix_point([&](auto dfs1, size_t v, size_t p, size_t pi) -> void {\n      if (v != 0) {\n        Monoid tmp = (dp0[p][pi] + dp1[p][pi+1]).f(g[p][pi].weight());\n        dp0[v][parent[v]+1] = tmp;\n        dp1[v][parent[v]] = tmp;\n      }\n      {\n        for (size_t i = 1; i < dp0[v].size(); ++i)\n          dp0[v][i].prepend(dp0[v][i-1]);\n        for (size_t i = dp1[v].size()-1; i--;)\n          dp1[v][i].append(dp1[v][i+1]);\n        dp[v] = dp1[v][0];\n      }\n      for (size_t i = 0; i < g[v].size(); ++i) {\n        size_t u = g[v][i].target();\n        if (u != p) dfs1(u, v, i);\n      }\n  })(0, -1_zu, -1_zu);\n\n  return dp;\n}\n\nclass distance {\npublic:\n  using value_type = int;\n\nprivate:\n  value_type M_value = 0;\n\npublic:\n  distance() = default;\n  distance(distance const&) = default;\n  distance(distance&&) = default;\n  distance(value_type v): M_value(v) {}\n\n  distance& operator =(distance const&) = default;\n  distance& operator =(distance&&) = default;\n\n  distance& append(distance const& other) {\n    M_value = std::max(other.M_value, M_value);\n    return *this;\n  }\n  distance& prepend(distance const& other) {\n    M_value = std::max(M_value, other.M_value);\n    return *this;\n  }\n  distance operator +(distance const& other) const {\n    return distance(*this).append(other);\n  }\n  template <typename Tp>\n  distance f(Tp const& x) const { return distance(M_value + x); }\n  value_type get() const { return M_value; }\n};\n\nint main() {\n  size_t n;\n  scanf(\"%zu\", &n);\n\n  adjacency_list<weighted_edge<int>, undirected_tag> g(n);\n  for (size_t i = 1; i < n; ++i) {\n    size_t u, v;\n    scanf(\"%zu %zu\", &u, &v);\n    --u, --v;\n    g.emplace(u, v, 1);\n  }\n  g.sort_by_index();\n\n  int whole = 2*(n-1);\n  for (auto r: dp_on_tree<distance>(g))\n    printf(\"%d\\n\", whole-r.get());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\n\nint main(void) {\n    ll n; cin >> n;\n    vvll g(n);\n    rep(i, n-1) {\n        ll u, v; cin >> u >> v; u--, v--;\n        g[u].pb(v), g[v].pb(u);\n    }\n\n    vll d(n);\n    function<ll(ll, ll)> f = [&](ll v, ll p) {\n        for (auto u : g[v]) if (u != p) chmax(d[v], f(u, v));\n        return d[v] + 1;\n    };\n    f(0, -1);\n\n    vll ret(n);\n    // dpar[v][p] = p???v???????????¨?????¨????????§?????§???d\n    function<void(ll, ll, ll)> ff = [&](ll v, ll p, ll dpar) {\n        vector<P> children;\n        for (auto u : g[v]) children.emplace_back(u == p ? dpar + 1 : d[u] + 1, u);\n        sort(all(children)); reverse(all(children));\n\n        ret[v] = children[0].fi;\n\n        for (auto u : g[v]) if (u != p) ff(u, v, children[children[0].se==u].fi);\n    };\n    ff(0, -1, 0);\n\n    rep(i, n) cout << 2 * (n - 1) - ret[i] << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef LL ut;\ntypedef pair<ut,ut> pr;\ntypedef vector<ut> VI;\ntypedef vector<pr> Vpr;\ntypedef priority_queue<pr,Vpr,greater<pr> > PQ;\nconst int SIZE=3*1e5;\nconst ut INF=1LL<<60;\nVI edge[SIZE];\nbool dead[SIZE];\nLL ans[SIZE];\nbool searched[SIZE];\nint needs[SIZE];\nint grav[SIZE];\nint dist[SIZE];\nint nums[SIZE];\nint sums[SIZE];\nint times[SIZE];\nint depthest[SIZE];\nint timer;\nVpr depters[SIZE];\nLL dfs(int now,int from,VI& nodes,int depth,bool want){\n\tif(dead[now]){\n\t\tif(from!=depters[now][0].second) return depters[now][0].first+depth;\n\t\treturn depters[now][1].first+depth;\n\t}\n\ttimer++;\n\tif(want)\n\tnodes.PB(now);\n\tLL ans=dist[now]=depth;\n\t//cout << now << \" \" << depth << endl;\n\tREP(i,edge[now].size()){\n\t\tint next=edge[now][i];\n\t\tif(next!=from)\n\t\t\tans=max(ans,dfs(next,now,nodes,depth+1,want));\n\t}\n\treturn ans;\n}\n/*\nvoid gives(int now,int from,int depth,LL alls,LL nodes){\n\tans[now]+=depth*nodes+alls;\n\tREP(i,edge[now].size()){\n\t\tint next=edge[now][i];\n\t\tif(next!=from && !dead[next])\n\t\t\tgives(next,now,depth+1,alls,nodes);\n\t}\n}*/\nvoid centerize(int now,VI& nodes){\n\tcat;\n\tdead[now]=true;\n\tVI dummy;\n//\tLL alls=0;\n\t//cout << now;\n\tREP(i,edge[now].size()){\n\t\ttimer=0;\n\t\tint next=edge[now][i];\n\t\t//if(dead[next]) continue;\n\t\tdepters[now].PB(pr(dfs(next,now,dummy,1,false),next));\n\t//\tcout << depters[now].back().first;\n//\t\tnums[i]=timer;\n//\t\talls+=sums[i];\n\t}\n\tdummy.clear();\n\t//cout << endl;\n\tdepters[now].PB(pr(0,-1));\n\tsort(ALL(depters[now]),greater<pr>());\n//\tans[now]+=alls;\n//\tREP(i,edge[now].size()){\n//\t\tint next=edge[now][i];\n//\t\tif(dead[next]) continue;\n//\t\tgives(next,now,1,alls-sums[i],nodes.size()-nums[i]);\n//\t\talls+=sums[i];\n//\t}\n\tcat;\t\n}\n\nvoid solve(int now){\n\tcat;\n\tVI nodes;\n\tPQ qu;\n\tdfs(now,-1,nodes,1,true);\n\tcat;\n\tint last=nodes[0];\n\tcat;\n\tcat;\n\tREP(i,nodes.size()){\n\t\tneeds[nodes[i]]=-1;\n\t\tsearched[nodes[i]]=false;\n\t\tgrav[nodes[i]]=0;\n\t\tREP(j,edge[nodes[i]].size()){\n\t\t\tint next=edge[nodes[i]][j];\n\t\t\tif(!dead[next]) needs[nodes[i]]++;\n\t\t}\n\n\t\tif(needs[nodes[i]]==0) qu.push(pr(0,nodes[i]));\n\t}\n\tcat;\n\twhile(!qu.empty()){\n\t\tint now=qu.top().second,gravity=qu.top().first;\n\t\tqu.pop();\n\t\tsearched[now]=true;\n\t\tlast=now;\n\t\tREP(i,edge[now].size()){\n\t\t\tint next=edge[now][i];\n\t\t\tif(dead[next]) continue;\n\t\t\tif(searched[next]) continue;\n\t\t\tgrav[next]+=grav[now]+1;\n\t\t\ttimes[next]++;\n\t\t\tif(times[next]==needs[next]) qu.push(pr(grav[next],next));\n\t\t}\n\n\t}\n\tcenterize(last,nodes);\n\tnodes.clear();\n\tREP(i,edge[last].size()){\n\t\tint next=edge[last][i];\n\t\tif(dead[next]) continue;\n\t\tsolve(next);\n\t}\n}\nint main(){\n\tint N,u,v;\n\tcin >> N;\n\tREP(i,N-1){\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tedge[u].PB(v);\n\t\tedge[v].PB(u);\n\t}\n\tsolve(1);\n\tFOR(i,1,N+1){\n\t\tprintf(\"%lld\\n\",N*2-2-depters[i][0].first);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll,ll> P;\ntypedef pair<int,int> Pi;\n#define rep(i,n) for(ll i=0;i<n;i++)\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n#define fi first\n#define se second\n\ntemplate<typename T> inline bool chmax(T &a, T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T> inline bool chmin(T &a, T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T> ostream& operator<<(ostream& s,const complex<T>& d) {return s<<\"(\"<<d.real()<<\", \"<<d.imag()<< \")\";}\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s,const pair<T1,T2>& d) {return s<<\"(\"<<d.first<<\", \"<<d.second<<\")\";}\ntemplate<typename T> ostream& operator<<(ostream& s, const vector<T>& d){int len=d.size();rep(i,len){s<<d[i];if(i<len-1) s<<\" \";}return s;}\ntemplate<typename T> ostream& operator<<(ostream& s,const vector<vector<T>>& d){int len=d.size();rep(i,len){s<<d[i]<<endl;}return s;}\ntemplate<typename T> ostream& operator<<(ostream& s,const set<T>& v){s<<\"{ \";for(auto itr=v.begin();itr!=v.end();++itr) {if (itr!=v.begin()) {s<< \", \";}s<<(*itr);}s<<\" }\";return s;}\ntemplate<typename T1, typename T2> ostream& operator<<(ostream& s,const map<T1,T2>& m){s<<\"{\"<<endl;for(auto itr=m.begin();itr!=m.end();++itr){s<<\" \"<<(*itr).first<<\" : \"<<(*itr).second<<endl;}s<<\"}\"<<endl;return s;}\n\nconst ll mod=1e9+7;\nconst ll inf=1e17;\nconst int INF=1e9;\nconst double PI=acos(-1);\nconst double EPS=1e-10;\n\nint main(){\n\tcin.tie(0);ios::sync_with_stdio(false);\n\tint n;\n\tcin>>n;\n\tvector<vector<int>> g(n);\n\trep(i,n-1){\n\t\tint s,t;\n\t\tcin>>s>>t;\n\t\ts--,t--;\n\t\tg[s].push_back(t);\n\t\tg[t].push_back(s);\n\t}\n\tvector<int> dp(n);\n\tauto dfs1=[&](auto &&dfs1,int v,int pre)->int{\n\t\tint ret=0;\n\t\tfor(auto itr:g[v]){\n\t\t\tif(itr==pre) continue;\n\t\t\tchmax(ret,dfs1(dfs1,itr,v)+1);\n\t\t}\n\t\treturn dp[v]=ret;\n\t};\n\tvector<int> ans(n);\n\tans[0]=dfs1(dfs1,0,-1);\n\tauto dfs2=[&](auto &&dfs2,int v,int pre)->void{\n\t\tint sz=g[v].size();\n\t\tvector<int> left(sz+1,0),right(sz+1,0);\n\t\trep(i,sz){\n\t\t\tleft[i+1]=max(left[i],dp[g[v][i]]+1);\n\t\t}\n\t\tfor(int i=sz-1;i>=0;i--){\n\t\t\tright[i]=max(right[i+1],dp[g[v][i]]+1);\n\t\t}\n\t\trep(j,sz){\n\t\t\tif(g[v][j]==pre) continue;\n\t\t\tint ne=g[v][j];\n\t\t\tint cnt1=dp[v],cnt2=dp[ne];\n\t\t\tdp[v]=max(left[j],right[j+1]);\n\t\t\tchmax(dp[ne],dp[v]+1);\n\t\t\tans[ne]=dp[ne];\n\t\t\t//cout<<ne<<' '<<dp[ne]<<endl;\n\t\t\tdfs2(dfs2,ne,v);\n\t\t\tdp[v]=cnt1;\n\t\t\tdp[ne]=cnt2;\n\t\t}\n\t};\n\tdfs2(dfs2,0,-1);\n\trep(i,n){\n\t\tcout<<2*(n-1)-ans[i]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<utility>\n#include<map>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define stop char nyaa;cin>>nyaa;\n\nvector<int> v[101010];\nvector<pair<int, int>> l[101010];\nint ans[101010];\n\nint dfs(int x, int p) {\n\tl[x].push_back({ 0,-1 });\n\tl[x].push_back({ 0,-1 });\n\tfor (auto to : v[x]) {\n\t\tif (to == p)continue;\n\t\tl[x].push_back({ dfs(to,x),to });\n\t}\n\tsort(l[x].rbegin(), l[x].rend());\n\treturn l[x][0].first + 1;\n\n}\n\nvoid rdfs(int x, int p) {\n\tif (p != -1) {\n\t\tif (l[p][0].second == x) {\n\t\t\tl[x].push_back({ l[p][1].first + 1,l[p][1].second });\n\t\t}\n\t\telse l[x].push_back({ l[p][0].first + 1,l[p][0].second });\n\t}\n\tsort(l[x].rbegin(), l[x].rend());\n\tans[x] = l[x][0].first;\n\n\tfor (auto to : v[x]) {\n\t\tif (to == p)continue;\n\t\trdfs(to, x);\n\t}\n}\n\n\nvoid solve() {\n\tint n;\n\tcin >> n;\n\trep(i, n - 1) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t--x; --y;\n\t\tv[x].push_back(y);\n\t\tv[y].push_back(x);\n\t}\n\tdfs(0, -1);\n\trdfs(0, -1);\n\trep(i, n) {\n\t\tcout << 2 * (n - 1) - ans[i] << endl;\n\t}\n}\n\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\t\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef int _loop_int;\n#define REP(i,n) for(_loop_int i=0;i<(_loop_int)(n);++i)\n#define FOR(i,a,b) for(_loop_int i=(_loop_int)(a);i<(_loop_int)(b);++i)\n#define FORR(i,a,b) for(_loop_int i=(_loop_int)(b)-1;i>=(_loop_int)(a);--i)\n\n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n\n#define CHMIN(a,b) a=min((a),(b))\n#define CHMAX(a,b) a=max((a),(b))\n\n// mod\nconst ll MOD = 1000000007ll;\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n// floating\ntypedef double Real;\nconst Real EPS = 1e-11;\n#define EQ0(x) (abs(x)<EPS)\n#define EQ(a,b) (abs(a-b)<EPS)\ntypedef complex<Real> P;\n\nint n;\nvi g[125252];\nint dist[125252];\nint dx[125252];\nint dy[125252];\nconst int INF = 830252521;\n\nvoid dfs(int st,int dist[125252]){\n  REP(i,n)dist[i] = INF;\n  dist[st] = 0;\n  stack<int> S;\n  S.push(st);\n  while(!S.empty()){\n    int p = S.top(); S.pop();\n    int d = dist[p];\n    REP(i,g[p].size()){\n      int to = g[p][i];\n      if(dist[to]!=INF)continue;\n      dist[to] = d+1;\n      S.push(to);\n    }\n  }\n}\n\nint main(){\n  scanf(\"%d\",&n);\n  REP(i,n-1){\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    --a;--b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  dfs(0,dist);\n  int x = max_element(dist,dist+n)-dist;\n  dfs(x,dx);\n  int y = max_element(dx,dx+n)-dx;\n  dfs(y,dy);\n  REP(i,n){\n    int ans = 2*(n-1) - max(dx[i],dy[i]);\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// step[i] := ?????? 0 ????????¨????????¨????????????????????? i ???????????????????????¨????????¢\n// ans [i] := ?????? i ????????¨????????¨????????????????????? i ???????????????????????¨????????¢\n// ?????? i ??????????????????????????§???????????? 1 ???????????????????????????????????\\?????? 2 ?????????\n// ???????????£???????????????????????? 2 * (n-1) - ans[i] ??§??????\n\nint step[100010], ans[100010];\nvector<int> G[100010];\n\nvoid dfs(int idx, int par) {\n    for(auto to : G[idx]) {\n        if(to == par) continue;\n        dfs(to, idx);\n        step[idx] = max(step[idx], step[to] + 1);\n    }\n}\n\nvoid dfs2(int idx, int d_par, int par) {\n    vector<pii> rec;\n    rec.push_back(pii(0, -1));\n    for(auto to : G[idx]) {\n        if(to == par) rec.push_back(pii(d_par + 1, to));\n        else rec.push_back(pii(step[to] + 1, to));\n    }\n    sort(rec.rbegin(), rec.rend());\n    ans[idx] = rec[0].first;\n    for(auto to : G[idx]) {\n        if(to == par) continue;\n        dfs2(to, rec[ rec[0].second == to ].first, idx);\n    }\n}\n\nsigned main() {\n    int n; cin >> n;\n    rep(i,0,n-1) {\n        int u, v; cin >> u >> v;\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    dfs(0, -1);\n    dfs2(0, 0, -1);\n    rep(i,0,n) cout << (n-1) * 2 - ans[i] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// step[i] := ?????? 0 ????????¨????????¨????????????????????? i ???????????????????????¨????????¢\n// ans [i] := ?????? i ????????¨????????¨????????????????????? i ???????????????????????¨????????¢\n// ?????? i ??????????????????????????§???????????? 1 ???????????????????????????????????\\?????? 2 ?????????\n// ???????????£???????????????????????? 2 * (n-1) - ans[i] ??§??????\nint step[100010], ans[100010];\nvector< vector<int> > G;\n\nvoid dfs(int idx, int par) {\n    for(int to : G[idx]) {\n        if(to == par) continue;\n        dfs(to, idx);\n        step[idx] = max(step[idx], step[to] + 1);\n    }\n}\n\nvoid dfs2(int idx, int d_par, int par) {\n    // printf(\"idx = %lld, d_par = %lld, par = %lld\\n\", idx, d_par, par);\n    vector<pii> rec;\n    rec.push_back(pii(0, -1));\n    for(int to : G[idx]) {\n        if(to == par) rec.push_back(pii(d_par + 1, to));\n        else rec.push_back(pii(step[to] + 1, to));\n    }\n    sort(rec.rbegin(), rec.rend());\n    ans[idx] = rec[0].first;\n    for(int to : G[idx]) {\n        if(to == par) continue;\n        dfs2(to, rec[ rec[0].second == to ].first, idx);\n    }\n}\n\nsigned main() {\n    memset(step, 0, sizeof(step));\n    memset(ans, 0, sizeof(ans));\n    int n; cin >> n;\n    G.resize(n);\n\n    rep(i,0,n-1) {\n        int u, v; cin >> u >> v;\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    dfs(0, -1);\n    dfs2(0, 0, -1);\n    rep(i,0,n) {\n        cout << (n-1) * 2 - ans[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\n\nint main(void) {\n    ll n; cin >> n;\n    vvll g(n);\n    rep(i, n-1) {\n        ll u, v; cin >> u >> v; u--, v--;\n        g[u].pb(v), g[v].pb(u);\n    }\n\n    vll d(n);\n    function<ll(ll, ll)> f = [&](ll v, ll p) {\n        for (auto u : g[v]) if (u != p) chmax(d[v], f(u, v));\n        return d[v] + 1;\n    };\n    f(0, -1);\n\n    vll ret(n);\n    // dpar[v][p] = p???v???????????¨?????¨????????§?????§???d\n    function<void(ll, ll, ll)> ff = [&](ll v, ll p, ll dpar) {\n        vector<P> children = {P(0, -1)};\n        for (auto u : g[v]) children.emplace_back(u == p ? dpar + 1 : d[u] + 1, u);\n        sort(all(children)); reverse(all(children));\n\n        ret[v] = children[0].fi;\n\n        for (auto u : g[v]) if (u != p) ff(u, v, children[children[0].se==u].fi);\n    };\n    ff(0, -1, 0);\n\n    rep(i, n) cout << 2 * (n - 1) - ret[i] << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define REP(i, n) for (ll i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (ll i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define fi first\n#define se second\n#define pb push_back\n#define debug(x) cerr << #x << \": \" << (x) << endl\n#define int long long\nusing namespace std;\nusing II = pair<int, int>;\nusing VII = vector<II>;\nusing VVII = vector<VII>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VVVI = vector<VVI>;\ntemplate <class T = int> inline T in() { T x; cin >> x; return x; }\ntemplate <class T = int> inline bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T = int> inline bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<T>& d) { int n = d.size(); REP (i, n) s << d[i] << \" \"; return s; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<vector<T>>& dd) { for (vector<T> d: dd) s << d << endl; return s; }\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nconst int MOD = 1e9 + 7;\n\nsigned main() {\n  int N = in();\n  VVI G(N);\n  REP (i, N - 1) {\n    int u, v; cin >> u >> v;\n    u--; v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  VVII dist(N); // {len, v}\n  VI far(N);\n  function<void (int, int)> dfs1 = [&](int v, int prev) {\n    for (int u: G[v]) if (u != prev) {\n      dfs1(u, v);\n      dist[v].push_back({far[u] + 1, u});\n      chmax(far[v], far[u] + 1);\n    }\n  };\n  dfs1(0, -1);\n\n  sort(RALL(dist[0]));\n  function<void (int, int)> dfs2 = [&](int v, int prev) {\n    for (int u: G[v]) if (u != prev) {\n      int tmp;\n      if (dist[v][0].se == u) {\n        tmp = dist[v].size() == 1 ? 0 : dist[v][1].fi;\n      } else {\n        tmp = dist[v][0].fi;\n      }\n      debug(tmp);\n      dist[u].pb({tmp + 1, v});\n      sort(RALL(dist[u]));\n      dfs2(u, v);\n    }\n  };\n  dfs2(0, -1);\n\n  REP (i, N) {\n    cout << 2 * (N - 1) - dist[i][0].fi << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class E, class T> struct Rerooting {\n    using F = function<T(T, T)>;\n    using H = function<T(T, E)>;\nprivate : \n    struct Edge {\n        int to;\n        E data;\n        T dp, sum;\n        Edge (int to, E data, T dp, T sum) : \n            to(to), data(data), dp(dp), sum(sum) { }\n    };\n    vector<vector<Edge>> g;\n    vector<T> subdp, dp;\n    const T id;\n    const F f;\n    const H h;\n    int edges;\n\npublic : \n    Rerooting (int n, const F &f, const H &h, const T id) : \n        g(n), f(f), h(h), id(id), subdp(n, id), dp(n, id) { edges = 0; }\n\n    void add_edge (int v, int u, const E &val) {\n        assert(++edges < (int)g.size());\n        g[v].emplace_back(u, val, id, id);\n        g[u].emplace_back(v, val, id, id);\n    }\n\n    void add_edge2 (int v, int u, const E &val1, const E &val2) {\n        assert(++edges < (int)g.size());\n        g[v].emplace_back(u, val1, id, id);\n        g[u].emplace_back(v, val2, id, id);\n    }\n\n    void dfs1 (int v, int p) {\n        for (const auto &e : g[v]) {\n            if (e.to == p) continue;\n            dfs1(e.to, v);\n            subdp[v] = f(subdp[v], h(subdp[e.to], e.data));\n        }\n    }\n\n    void dfs2 (int v, int p, const T &top) {\n        T buff = id;\n        for (int i = 0; i < (int)g[v].size(); i++) {\n            Edge &e = g[v][i];\n            e.sum = buff;\n            e.dp = h(e.to == p ? top : subdp[e.to], e.data);\n            buff = f(buff, e.dp);\n        }\n        dp[v] = buff;\n        buff = id;\n        for (int i = (int)g[v].size() - 1; i >= 0; i--) {\n            Edge &e = g[v][i];\n            if (e.to != p) dfs2(e.to, v, f(buff, e.sum));\n            e.sum = f(e.sum, buff);\n            buff = f(buff, e.dp);\n        }\n    }\n\n    vector<T> build(int s = 0) {\n        dfs1(s, -1);\n        dfs2(s, -1, id);\n        return dp;\n    }\n\n};\n\n\nint main() {\n    int n;\n    cin >> n;\n    \n    auto f = [](int a, int b) { return max(a, b); };\n    auto h = [](int a, int b) { return a + b; };\n    Rerooting<int, int> g(n, f, h, 0);\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        g.add_edge(--a, --b, 1);\n    }\n    \n    for (const auto &e : g.build()) {\n        cout << (n - 1) * 2 - e << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntemplate <typename Data, typename T>\nstruct ReRooting\n{\n\n    struct Node\n    {\n        int to, rev;\n        Data data;\n    };\n\n    using F1 = function<T(T, T)>;\n    using F2 = function<T(T, Data)>;\n\n    vector<vector<Node>> g;\n    vector<vector<T>> ldp, rdp;\n    vector<int> lptr, rptr;\n    const F1 f1;\n    const F2 f2;\n    const T ident;\n\n    ReRooting(int n, const F1 &f1, const F2 &f2, const T &ident) : g(n), ldp(n), rdp(n), lptr(n), rptr(n), f1(f1), f2(f2), ident(ident) {}\n\n    void add_edge(int u, int v, const Data &d)\n    {\n        g[u].emplace_back((Node){v, (int)g[v].size(), d});\n        g[v].emplace_back((Node){u, (int)g[u].size() - 1, d});\n    }\n\n    void add_edge_bi(int u, int v, const Data &d, const Data &e)\n    {\n        g[u].emplace_back((Node){v, (int)g[v].size(), d});\n        g[v].emplace_back((Node){u, (int)g[u].size() - 1, e});\n    }\n\n    T dfs(int idx, int par)\n    {\n\n        while (lptr[idx] != par && lptr[idx] < g[idx].size())\n        {\n            auto &e = g[idx][lptr[idx]];\n            ldp[idx][lptr[idx] + 1] = f1(ldp[idx][lptr[idx]], f2(dfs(e.to, e.rev), e.data));\n            ++lptr[idx];\n        }\n        while (rptr[idx] != par && rptr[idx] >= 0)\n        {\n            auto &e = g[idx][rptr[idx]];\n            rdp[idx][rptr[idx]] = f1(rdp[idx][rptr[idx] + 1], f2(dfs(e.to, e.rev), e.data));\n            --rptr[idx];\n        }\n        if (par < 0)\n            return rdp[idx][0];\n        return f1(ldp[idx][par], rdp[idx][par + 1]);\n    }\n\n    vector<T> solve()\n    {\n        for (int i = 0; i < g.size(); i++)\n        {\n            ldp[i].assign(g[i].size() + 1, ident);\n            rdp[i].assign(g[i].size() + 1, ident);\n            lptr[i] = 0;\n            rptr[i] = (int)g[i].size() - 1;\n        }\n        vector<T> ret;\n        for (int i = 0; i < g.size(); i++)\n        {\n            ret.push_back(dfs(i, -1));\n        }\n        return ret;\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n    auto f1 = [](int a, int b) {\n        return max(a, b);\n    };\n\n    auto f2 = [](int a, int data) {\n        return a + data;\n    };\n    ReRooting<int, int> g(n, f1, f2, 0);\n    for (int i = 1; i < n; i++)\n    {\n        int s, t;\n        cin >> s >> t;\n        s--;\n        t--;\n        g.add_edge(s, t, 1);\n    }\n    auto ret = g.solve();\n    for (int i = 0; i < n; i++)\n    {\n        cout << 2 * (n - 1) - ret[i] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cassert>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<deque>\n#include<functional>\n#include<iomanip>\n#include<iostream>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<unordered_map>\n#include<unordered_set>\n#include<utility>\n#include<vector>\n\nusing namespace std;\n\nusing lint = long long;\nusing P = pair<int, int>;\nusing LLP = pair<long long, long long>;\n\n#define REP(i, x, n) for(int i = (x), i##_len = int(n) ; i < i##_len ; ++i)\n#define rep(i, n) for(int i = 0, i##_len = int(n) ; i < i##_len ; ++i)\n#define reps(i, n) for(int i = 1, i##_len = int(n) ; i <= i##_len ; ++i)\n#define rrep(i, n) for(int i = int(n) - 1 ; i >= 0 ; --i)\n#define rreps(i, n) for(int i = int(n) ; i > 0 ; --i)\n#define SORT(x) sort((x).begin(), (x).end())\n#define SORT_INV(x) sort((x).rbegin(), (x).rend())\n#define TWINS(x) cout << ((x) ? \"Yay!\" : \":(\") << endl\n\nconstexpr int IINF = (1 << 30) - 1;\nconstexpr long long LLINF = 1LL << 61;\nconstexpr double EPS = 1e-8;\n\nconst int dx4[] = {1, 0, -1, 0}, dy4[] = {0, 1, 0, -1};\nconst int dx8[] = {1, 1, 0, -1, -1, -1, 0, 1}, dy8[] = {0, -1, -1, -1, 0, 1, 1, 1};\n\ntemplate<typename T>\nbool chmax(T& a, T b, bool equal = false){\n    if(a < b || equal && a == b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T>\nbool chmin(T& a, T b, bool equal = false){\n    if(b < a || equal && a == b){\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nvoid dfs(int v, int prev, int depth, const vector< vector<int> >& g, vector<int>& cost){\n    cost[v] = depth;\n\n    for(auto to : g[v]){\n        if(to != prev){\n            dfs(to, v, depth + 1, g, cost);\n        }\n    }\n\n    return;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n;\n    cin >> n;\n\n    vector< vector<int> > g(n);\n    rep(i, n - 1){\n        int u, v;\n        cin >> u >> v;\n        g[--u].emplace_back(--v);\n        g[v].emplace_back(u);\n    }\n\n    vector< vector<int> > cost(2, vector<int>(n, IINF));\n    dfs(0, -1, 0, g, cost[0]);\n    int maxi = -1;\n    int maxdex = -1;\n    rep(i, n){\n        if(chmax(maxi, cost[0][i])){\n            maxdex = i;\n        }\n    }\n\n    assert(maxdex != -1);\n\n    dfs(maxdex, -1, 0, g, cost[1]);\n\n    maxi = -1;\n    maxdex = -1;\n    rep(i, n){\n        if(chmax(maxi, cost[1][i])){\n            maxdex = i;\n        }\n    }\n\n    assert(maxdex != -1);\n\n    dfs(maxdex, -1, 0, g, cost[0]);\n\n    rep(i, n){\n        cout << (n - 1) * 2 - max(cost[0][i], cost[1][i]) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <set>\n#include <algorithm>\n#include <string>\n#include <math.h>\n#include <limits.h>\n#include <stack>\n#include <complex>\n#include <stdlib.h>\n#include <stdio.h>\n#include <functional>\n#include <cfloat>\n#include <math.h>\n#include <numeric>\n#include <string.h>\n#include <sys/time.h>\n#include <random>\n\n\n#define fs first\n#define sc second\n#define endl \"\\n\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef pair<ll, ll> P;\n\n\nclass Graph{\n    struct edge{\n        int vertice;\n        ll weight;\n    };\n\n    vector<vector<edge>> g;\n    unsigned int n;\n\npublic:\n    Graph(unsigned int n): n{n}{\n        g.resize(n);\n    }\n\n    void add_edge(int u, int v){\n        g[u].emplace_back(edge{v, 1});\n    };\n\n    void add_edge(int u, int v, ll w){\n        g[u].emplace_back(edge{v, w});\n    }\n\n    vector<edge>& get_edge(int v){\n        return g[v];\n    }\n\n    unsigned int size(){\n        return n;\n    }\n\n    vector<edge>& operator[](int v){\n        return get_edge(v);\n    }\n};\n\n\n/**\n * parentFun(merge(childFun(dp_c1), childFun(dp_c2), \\ldots, childFun(dp_cm))\n * @tparam T\n */\ntemplate <typename T>\nclass ReRooting{\nprivate:\n    using Operate = function<T(T, T)>;  // monoid\n    using OperateNode = function<T(T, int)>;\n\n    Graph g;\n    Operate merge;\n    T u;                 // Operateについての単位元\n    OperateNode childFun, parentFun;\n\n    vector<vector<T>> dp;\n    vector<T> res;\n\n    T dfs1(int v, int prev){\n        T res = u;\n        for(int i = 0; i < g[v].size(); i++){\n            auto e = g[v][i];\n            if(e.vertice == prev)   continue;\n            dp[v][i] = dfs1(e.vertice, v);\n            res = merge(res, childFun(dp[v][i], e.vertice));\n        }\n\n        return parentFun(res, v);\n    }\n\n    void dfs2(int v, int prev, T fromP){\n        int n = g[v].size();        // vからの辺を持つ頂点数\n        for(int i = 0; i < n; i++){\n            auto e = g[v][i];\n            if(e.vertice == prev){\n                dp[v][i] = fromP;\n                break;\n            }\n        }\n\n        vector<T> cumFromLeft(n + 1), cumFromRight(n + 1);\n        cumFromLeft[0] = u; cumFromRight[n] = u;\n        for(int i = 0; i < n; i++){\n            cumFromLeft[i+1] = merge(cumFromLeft[i], childFun(dp[v][i], v));\n        }\n        for(int i = n-1; i >= 0; i--){\n            cumFromRight[i] = merge(cumFromRight[i+1], childFun(dp[v][i], v));\n        }\n\n        for(int i = 0; i < n; i++){\n            auto e = g[v][i];\n            if(e.vertice == prev)   continue;\n            T fromC = parentFun(merge(cumFromLeft[i], cumFromRight[i+1]), v);\n            dfs2(e.vertice, v, fromC);\n        }\n\n        res[v] = parentFun(cumFromLeft[n], v);\n    }\n\n\npublic:\n    ReRooting(Graph& g_, Operate merge_, T u_, OperateNode childFun_, OperateNode parentFun_):\n            g(g_), merge(merge_), u(u_), childFun(childFun_), parentFun(parentFun_){\n        dp.resize(g.size());\n        for(int i = 0; i < g.size(); i++){\n            dp[i].resize(g[i].size());\n        }\n        res.resize(g.size());\n    }\n\n    void calc(int root = 0){\n        dfs1(root, root);\n        dfs2(root, root, u);\n    }\n\n    T get(int v){\n        return res[v];\n    }\n};\n\n\nint main(){\n    int n;\n    cin >> n;\n    Graph g(n);\n    for(int i = 0; i < n-1; i++){\n        int x, y;   cin >> x >> y;\n        x--; y--;\n        g.add_edge(x, y);\n        g.add_edge(y, x);\n    }\n\n    ReRooting<P> reroot(g,\n                        [](P x, P y){ P tmp = P(x.fs + y.fs, max(x.sc, y.sc)); return tmp; },\n                        P(0LL, 0LL),\n                        [](P x, int v){ P tmp(x.fs + 2, x.sc + 1); return tmp; },\n                        [](P x, int v) { return x; });\n\n    reroot.calc(0);\n    for(int i = 0; i < n; i++){\n        cout << reroot.get(i).fs - reroot.get(i).sc << endl;\n    }\n\n\n\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define reps(i,f,n) for(int i=(f);i<(n);i++)\n#define all(v) (v).begin(),(v).end()\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define pb push_back\n#define fi first\n#define se second\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nvint dist;\nint N;\nvint G[100000];\nvoid dfs(int v,int p,int d){\n    dist[v]=d;\n    for(auto u:G[v]){\n        if(u!=p)dfs(u,v,d+1);\n    }\n}\n\nsigned main(){\n    cin>>N;\n    rep(i,N-1){\n        int a,b;\n        cin>>a>>b;\n        a--;b--;\n        G[a].pb(b);\n        G[b].pb(a);\n    }\n\n    dist=vint(N);\n    vint distx,disty;\n    dfs(0,-1,0);\n    int x=0;\n    rep(i,N)if(dist[x]<dist[i])x=i;\n    dfs(x,-1,0);\n    distx=dist;\n    int y=0;\n    rep(i,N)if(dist[y]<dist[i])y=i;\n    dfs(y,-1,0);\n    disty=dist;\n\n    rep(i,N){\n        printf(\"%lld\\n\",(N-1)*2-max(distx[i],disty[i]));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing PLL = pair<ll, ll>;\n#define rep(i,n) for(int i = 0; i < (int)(n); i++)\n#define repn(i,n) for(int i = 0; i <= (int)(n); i++)\n#define srep(i,l,n) for(int i = l; i < (int)(n); i++)\n#define srepn(i,l,n) for(int i = l; i <= (int)(n); i++)\n#define drep(i,n) for(int i = (int)(n-1); i >= 0; i--)\n#define drepn(i,n) for(int i = (int)(n); i >= 0; i--)\n#define size(s) (int)s.size()\n#define debug(var)  do{std::cout << #var << \" : \";view(var);}while(0)\ntemplate<typename T> void view(T e){std::cout << e << std::endl;}\ntemplate<typename T> void view(const std::vector<T>& v){for(const auto& e : v){ std::cout << e << \" \"; } std::cout << std::endl;}\ntemplate<typename T> void view(const std::vector<std::vector<T> >& vv){ for(const auto& v : vv){ view(v); } }\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = vector<V<T>>;\nbool isIn(int i, int j, int h, int w) {return i >= 0 && i < h && j >= 0 && j < w;}\nvoid Yes(){cout << \"Yes\" << endl;}\nvoid No(){cout << \"No\" << endl;}\nvoid YES(){cout << \"YES\" << endl;}\nvoid NO(){cout << \"NO\" << endl;}\nvoid err() {cout << -1 << endl;}\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define pb push_back\n#define ep emplace_back\n\nconst int MOD = 1000000007;\nconst int INF = 1e9;\n\n#define PI acos(-1);\nint dx[4] = {1,-1,0,0};\nint dy[4] = {0,0,1,-1};\nint ddx[8] = {1,1,1,-1,-1,-1,0,0};\nint ddy[8] = {0,1,-1,0,1,-1,1,-1};\n\nconst int mxN = 1e5 + 5;\nV<> g[mxN];\nint dist[mxN] = {0}, ans[mxN] = {0};\n\nvoid dfs1(int idx, int par) {\n    for(auto &to : g[idx]) {\n        if(to == par) continue;\n        dfs1(to, idx);\n        chmax(dist[idx], dist[to] + 1);\n    }\n}\n\nvoid dfs2(int idx, int d_par, int par) {\n    V<P> d_child;\n    d_child.emplace_back(0, -1);\n    for(auto &to : g[idx]) {\n        if(to == par) d_child.emplace_back(d_par+1, to);\n        else d_child.emplace_back(dist[to]+1, to);\n    }\n    sort(rall(d_child));\n    ans[idx] = d_child[0].first;\n    for(auto &to : g[idx]) {\n        if(par == to) continue;\n        dfs2(to, d_child[d_child[0].second == to].first, idx);\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n;\n    cin >> n;\n    rep(i, n-1) {\n        int a,b;\n        cin >> a >> b;\n        a--, b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    dfs1(0, -1);\n    dfs2(0, 0, -1);\n    rep(i, n) {\n        cout << 2 * (n - 1) - ans[i] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include<bits/stdc++.h>\nusing namespace std;\nstruct __INIT{__INIT(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}} __init;\n#define max3(a,b,c) max(a,max(b,c))\n#define min3(a,b,c) min(a,min(b,c))\nint MOD=1000000007;\n#define INF (1<<30)\n#define LINF (lint)(1LL<<56)\n#define endl \"\\n\"\n#define rep(i,n) for(int (i)=0;(i)<(n);(i)++)\n#define reprev(i,n) for(int (i)=(n-1);(i)>=0;(i)--)\n#define Flag(x) (1<<(x))\n#define Flagcount(x) __builtin_popcount(x)\n#define pint pair<int,int>\n#define pdouble pair<double,double>\n#define plint pair<lint,lint>\n#define fi first\n#define se second\ntypedef long long lint;\nint dx[8]={1,1,0,-1,-1,-1,0,1};\nint dy[8]={0,1,1,1,0,-1,-1,-1};\nconst int MAX_N=2e5+5;\n\nstruct DP {\n    lint dp;\n    int sub;\n    lint far;\n    DP(lint dp=0,int sub=0,lint far=0):dp(dp),sub(sub),far(far){}\n    DP operator+(const DP& a) const {\n        return DP(2*(sub+a.sub)-max(far,a.far),sub+a.sub,max(far,a.far));\n    }\n    DP addRoot(int W){\n        return DP(dp,sub+1,far+W);\n    }\n};\n \nvector<DP> dp[MAX_N];\nDP ans[MAX_N];\nvector<int> to[MAX_N];\nmap<pint,int> edleng;\n\nvoid addedge(int a,int b,int w=1){\n    to[a].push_back(b);\n    to[b].push_back(a);\n    edleng[pint(a,b)]=w;\n    edleng[pint(b,a)]=w;\n}\n \nDP rerootdfs(int v, int p=-1) {\n    DP dpSum;\n    dp[v] = vector<DP>(to[v].size());\n    rep(i,to[v].size()) {\n        int u = to[v][i];\n        int W=edleng[pint(v,u)];\n        if (u == p) continue;\n        dp[v][i] = rerootdfs(u,v);\n        dpSum = dpSum + dp[v][i];\n        }\n    return dpSum.addRoot(edleng[pint(v,p)]);\n}\nvoid rerootbfs(int v, const DP& dpP=DP(), int p=-1) {\n    int deg = to[v].size();\n    rep(i,deg) if (to[v][i] == p) dp[v][i] = dpP;\n \n    vector<DP> dpLeft(deg+1);\n    rep(i,deg) dpLeft[i+1] = dpLeft[i] + dp[v][i];\n  \n    vector<DP> dpRight(deg+1);\n    for (int i = deg-1; i >= 0; --i) dpRight[i] = dpRight[i+1] + dp[v][i];\n  \n    ans[v] = dpLeft[deg].addRoot(edleng[pint(v,v)]);\n \n    rep(i,deg) {\n        int u = to[v][i];\n        if (u == p) continue;\n        DP d = dpLeft[i] + dpRight[i+1];\n        rerootbfs(u, d.addRoot(edleng[pint(u,v)]), v);\n    }\n}\n\nvoid reroot(){\n    rerootdfs(0);\n    rerootbfs(0);\n}\n\n//デフォルトで部分木のサイズ、最遠距離がついてくる\n\n\nint main(void){\n    int N;\n    cin >> N;\n    rep(i,N-1){\n        int a,b;\n        cin >> a >> b;\n        a--,b--;\n        addedge(a,b);\n    }\n    reroot();\n    rep(i,N) cout << ans[i].dp << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\n\nusing Graph = vector<vector<int>>;\nint N;\nGraph G;\n\nvector<vector<long long>> dp;\nlong long rec(int v, int p = -1) {\n    int s = G[v].size();\n    long long res = 0;\n    dp[v].assign(s, -1);\n    for (int i = 0; i < s; ++i) {\n        int to = G[v][i];\n        if (to == p) continue;\n        dp[v][i] = rec(to, v);\n        chmax(res, dp[v][i] + 1);\n    }\n    return res;\n}\n\nvoid rerec(int v, long long pval = 0, int p = -1) {\n    int s = G[v].size();\n    for (int i = 0; i < s; ++i) {\n        int to = G[v][i];\n        if (to == p) {\n            dp[v][i] = pval;\n            continue;\n        }\n    }\n    vector<long long> left(s+1, -1), right(s+1, -1);\n    for (int i = 0; i < s; ++i) {\n        left[i+1] = max(left[i], dp[v][i]);\n        right[i+1] = max(right[i], dp[v][s-i-1]);\n    }\n    for (int i = 0; i < s; ++i) {\n        int to = G[v][i];\n        if (to == p) continue;\n        rerec(to, max(left[i], right[s-i-1]) + 1, v);\n    }\n}\n\nvoid solve() {\n    dp.assign(N, vector<long long>());\n    rec(0);\n    rerec(0);\n    for (int v = 0; v < N; ++v) {\n        long long res = 0;\n        for (int i = 0; i < G[v].size(); ++i) {\n            chmax(res, dp[v][i] + 1);\n        }\n        cout << (N-1)*2 - res << endl;\n    }\n}\n\nint main() {\n    cin >> N;\n    G.assign(N, vector<int>());\n    for (int i = 0; i < N-1; ++i) {\n        int u, v; cin >> u >> v; --u, --v;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n    solve();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint n,idx[3];\nint d[3][100050];\nbool u[100050];\nvector<int> v[100050];\nvoid dfs(int x,int p,int w){\n  d[w][p]=x;u[p]=true;\n  if(d[w][p]>d[w][idx[w]]) idx[w]=p;\n  for(int i=0;i<v[p].size();i++) if(!u[v[p][i]]) dfs(x+1,v[p][i],w);\n}\nvoid calc(){\n  \n}\nint main(){\n  cin>>n;\n  int i,j,k;\n  for(i=0;i<n-1;i++){\n    cin>>j>>k;\n    j--;k--;\n    v[j].push_back(k);\n    v[k].push_back(j);\n  }\n  idx[0]=idx[1]=idx[2]=0;\n  memset(d,0,sizeof(d));\n  memset(u,0,sizeof(u));\n  dfs(0,0,0);\n  memset(u,0,sizeof(u));\n  dfs(0,idx[0],1);\n  memset(u,0,sizeof(u));\n  dfs(0,idx[1],2);\n  for(i=0;i<n;i++){\n    //cout << d[1][i] << \":\" << d[2][i] << endl;\n    cout << 2*(n-1) - max(d[1][i],d[2][i]) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nvector<vector<int> > edges;\nvector<map<int, pair<int, int> > > memo;\n\nint solve(int curr, int prev)\n{\n    if(memo[curr].find(prev) != memo[curr].end())\n        return memo[curr][prev].first;\n\n    if(memo[curr].empty()){\n        pair<int, int> ans(0, 0);\n        for(int next : edges[curr]){\n            if(next != prev){\n                int d = solve(next, curr) + 1;\n                if(ans.first < d)\n                    swap(ans.first, d);\n                if(ans.second < d)\n                    swap(ans.second, d);\n            }\n        }\n        memo[curr][prev] = ans;\n        return ans.first;\n    }\n    else{\n        int prev2 = memo[curr].begin()->first;\n        pair<int, int> ans = memo[curr].begin()->second;\n        if(prev2 != -1){\n            int d = solve(prev2, curr) + 1;\n            if(ans.first < d)\n                swap(ans.first, d);\n            if(ans.second < d)\n                swap(ans.second, d);\n        }\n\n        if(prev == -1){\n            return ans.first;\n        }\n        else{\n            int d = solve(prev, curr) + 1;\n            if(ans.first == d)\n                return ans.second;\n            else\n                return ans.first;\n        }\n    }\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    edges.resize(n);\n    for(int i=0; i<n-1; ++i){\n        int u, v;\n        cin >> u >> v;\n        -- u;\n        -- v;\n        edges[u].push_back(v);\n        edges[v].push_back(u);\n    }\n\n    memo.resize(n);\n    for(int i=0; i<n; ++i){\n        int ans = 2 * (n - 1) - solve(i, -1);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\nvvi adj;\nvi des, des_back, asc, asc_back;\n\nvoid dfs1(int v, int p) {\n    i64 dif = 0;\n    vi ds_back;\n    for (int s: adj[v]) {\n        if (s != p) {\n            dfs1(s, v);\n            dif = max(dif, des_back[s] - des[s]);\n            ds_back.push_back(des_back[s] + 2);\n        }\n    }\n    i64 all = accumulate(ds_back.begin(), ds_back.end(), 0);\n    des_back[v] = all;\n    if (p == -1 || adj[v].size() > 1) dif++;\n    des[v] = all - dif;\n}\n\nvoid dfs2(int v, int p) {\n    using ii = pair<i64, int>;\n    vector<ii> difs = {ii(0, 0)};\n    for (int s: adj[v]) {\n        if (s != p) {\n            difs.push_back(ii(des_back[s] - des[s], s));\n            asc_back[s] = des_back[v] - des_back[s] + asc_back[v];\n        }\n    }\n    sort(difs.begin(), difs.end(), greater<>());\n    for (int s: adj[v]) {\n        if (s != p) {\n            asc[s] = min(des_back[v] - des_back[s] + asc[v] - 1, asc_back[v] - difs[difs[0].second == s].first + des_back[v] - des_back[s] - 1 - (difs.size() > 2));\n            dfs2(s, v);\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    adj = vvi(n);\n    des = vi(n, 1e18);\n    des_back = vi(n, 1e18);\n    asc = vi(n, 1e18);\n    asc_back = vi(n, 1e18);\n\n    for (int i = 0; i < n - 1; i++) {\n        int s, t;\n        cin >> s >> t;\n        s--;\n        t--;\n        adj[s].push_back(t);\n        adj[t].push_back(s);\n    }\n\n    dfs1(0, -1);\n    // for (int i = 0; i < n; i++) {\n    //     cout << \"des\" << i + 1 << \" \" << des[i] << endl;\n    //     cout << \"des_back\" << i + 1 << \" \" << des_back[i] << endl;\n    // }\n\n    asc[0] = 0;\n    asc_back[0] = 0;\n    dfs2(0, -1);\n    // for (int i = 0; i < n; i++) {\n    //     cout << \"asc\" << i + 1 << \" \" << asc[i] << endl;\n    //     cout << \"asc_back\" << i + 1 << \" \" << asc_back[i] << endl;\n    // }\n\n    for (int i = 0; i < n; i++) {\n        cout << min(des[i] + asc_back[i], des_back[i] + asc[i]) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\nvector<int> v[111111];\nint d[111111],c[111111],D;\n    \nP visit(int p,int x,int z) {\n  d[x]=z;\n  P r(0,x);\n  for(int i=0; i<v[x].size(); i++) {\n    int y=v[x][i];\n    if(y==p) continue;\n    P t=visit(x,y,z+1);\n    t.first++;\n    if(r.first<t.first) r=t;\n  }\n  return r;\n}\nint diameter() {\n  P r=visit(-1, 1,0);\n  P t=visit(-1,r.second,0);\n  D=t.first;\n  return t.second;\n}\n\nint main() {\n  int n;\n  cin >> n;\n  for(int i=0,x,y; i<n-1; i++) {\n    cin >> x >> y;\n    x--,y--;\n    v[x].push_back(y);\n    v[y].push_back(x);\n  }\n  int x=diameter();\n  queue<int> que;\n  que.push(x);\n  c[x]=(n-1)*2-D;\n  while(!que.empty()) {\n    x=que.front();que.pop();\n    for(int i=0; i<v[x].size(); i++) {\n      int y=v[x][i];\n      if(c[y]) continue;\n      if(d[x]>d[y]&&D/2<=d[y]) c[y]=c[x]+(D%2&&D/2==d[y]?0:1);\n      else c[y]=c[x]-1;\n      que.push(y);\n    }\n  }\n  for(int i=0; i<n; i++) cout << c[i] << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i, j) for(int i=0; i < (int)(j); i++)\n#define all(v) v.begin(),v.end()\ntemplate<class T> bool set_max(T &a, const T &b) { return a < b  ? a = b, true : false; }\n\nstruct Edge { ll from, to, cost; };\nusing EdgeList = vector<vector<Edge>>;\n\nint main() {\n    int N; cin >> N;\n    EdgeList E(N);\n\n    rep(i, N - 1) {\n        int s, t; cin >> s >> t;\n        s--; t--;\n        E[s].emplace_back(Edge{s, t, 1});\n        E[t].emplace_back(Edge{t, s, 1});\n    }\n    vector<ll> dp(N);\n    function<ll(int, int)> dfs = [&] (int now, int prev) {\n        dp[now] = 0;\n        for(Edge &e : E[now]) {\n            if(e.to == prev) continue;\n            set_max(dp[now], dfs(e.to, now) + e.cost);\n        }\n        return dp[now];\n    };\n    vector<ll> ans(N);\n    function<void(int, int, ll)> dfs2 = [&] (int now, int prev, ll v) {\n        using T = pair<ll, int>;\n        vector<T> values = {T(0, -1)}; // ??????\n        for(Edge &e : E[now]) {\n            ll vv = e.to != prev ? dp[e.to] : v;\n            values.emplace_back(vv + e.cost, e.to);\n        }\n        sort(all(values), greater<T>());\n        ans[now] = values[0].first;\n        for(Edge &e : E[now]) {\n            if(e.to == prev) continue;\n            ll vv = (values[0].second != e.to ? values[0] : values[1]).first;\n            dfs2(e.to, now, vv);\n        }        \n    };\n    dfs(0, -1);\n    dfs2(0, -1, 0);\n    for(auto a : ans) cout << (N - 1) * 2 - a << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef int LL;\ntypedef int ut;\ntypedef pair<ut,ut> pr;\ntypedef vector<ut> VI;\ntypedef vector<pr> Vpr;\ntypedef priority_queue<pr,Vpr,greater<pr> > PQ;\nconst int SIZE=2*1e5;\n//const ut INF=1LL<<60;\nVI edge[SIZE];\nbool dead[SIZE];\nLL ans[SIZE];\nbool searched[SIZE];\nint needs[SIZE];\nint grav[SIZE];\nint dist[SIZE];\n//int nums[SIZE];\n//int sums[SIZE];\nint times[SIZE];\nint depthest[SIZE];\nint timer;\nVpr depters[SIZE];\nint depther[SIZE];\nLL dfs(int start,int bad,VI& nodes,int depth,bool want){\n\tint ans=0;\n\tqueue<pr> st;\n\tst.push(pr(start,bad)); \n\tdepther[start]=depth;\n\twhile(!st.empty()){\n\t\tint now=st.front().first,from=st.front().second;\n\t\tst.pop();\n\t\tif(dead[now]){\n\t\t\tif(from!=depters[now][0].second)  ans=max(ans,depters[now][0].first+depther[now]);\n\t\t\telse  ans=max(ans,depters[now][1].first+depther[now]);\n\t\t\tcontinue;\n\t\t}\n\t\ttimer++;\n\t\tif(want)\n\t\t\tnodes.PB(now);\n\t\t//cout << now << \" \" << depth << endl;\n\t\tans=max(ans,depther[now]);\n\t\tREP(i,edge[now].size()){\n\t\t\tint next=edge[now][i];\n\t\t\tif(next!=from){\n\t\t\t\tdepther[next]=depther[now]+1;\n\t\t\t\tst.push(pr(next,now));\n\t\t\t}\n\t\t}\n\t}\n\t//cout << start <<\" \" << ans << endl;\n\treturn ans;\n}\n/*\nvoid gives(int now,int from,int depth,LL alls,LL nodes){\n\tans[now]+=depth*nodes+alls;\n\tREP(i,edge[now].size()){\n\t\tint next=edge[now][i];\n\t\tif(next!=from && !dead[next])\n\t\t\tgives(next,now,depth+1,alls,nodes);\n\t}\n}*/\nvoid centerize(int now,VI& nodes){\n\tcat;\n\tdead[now]=true;\n\tVI dummy;\n//\tLL alls=0;\n\t//cout << now;\n\tREP(i,edge[now].size()){\n\t\ttimer=0;\n\t\tint next=edge[now][i];\n\t\t//if(dead[next]) continue;\n\t\tdepters[now].PB(pr(dfs(next,now,dummy,1,false),next));\n\t//\tcout << depters[now].back().first;\n//\t\tnums[i]=timer;\n//\t\talls+=sums[i];\n\t}\n\tdummy.clear();\n\t//cout << endl;\n\tdepters[now].PB(pr(0,-1));\n\tsort(ALL(depters[now]),greater<pr>());\n//\tans[now]+=alls;\n//\tREP(i,edge[now].size()){\n//\t\tint next=edge[now][i];\n//\t\tif(dead[next]) continue;\n//\t\tgives(next,now,1,alls-sums[i],nodes.size()-nums[i]);\n//\t\talls+=sums[i];\n//\t}\n\tcat;\t\n}\n\nvoid solve(int now){\n\t//cout << now << endl;\n\tcat;\n\tVI nodes;\n\tPQ qu;\n\tdfs(now,-1,nodes,1,true);\n\tcat;\n\tint last=nodes[0];\n\tcat;\n\tcat;\n\tREP(i,nodes.size()){\n\t\tneeds[nodes[i]]=-1;\n\t\tsearched[nodes[i]]=false;\n\t\tgrav[nodes[i]]=0;\n\t\ttimes[nodes[i]]=0;\n\t\tREP(j,edge[nodes[i]].size()){\n\t\t\tint next=edge[nodes[i]][j];\n\t\t\tif(!dead[next]) needs[nodes[i]]++;\n\t\t}\n\n\t\tif(needs[nodes[i]]==0) qu.push(pr(0,nodes[i]));\n\t}\n\tcat;\n\twhile(!qu.empty()){\n\t\tint now=qu.top().second,gravity=qu.top().first;\n\t\t//cout << gravity <<\" \" << now <<\" \" <<endl;\n\t\tqu.pop();\n\t\tsearched[now]=true;\n\t\tlast=now;\n\t\tREP(i,edge[now].size()){\n\t\t\tint next=edge[now][i];\n\t\t\tif(dead[next]) continue;\n\t\t\tif(searched[next]) continue;\n\t\t\tgrav[next]+=grav[now]+1;\n\t\t\ttimes[next]++;\n\t\t\tif(times[next]==needs[next]) qu.push(pr(grav[next],next));\n\t\t}\n\n\t}\n\tcenterize(last,nodes);\n\tnodes.clear();\n//\tcout << last << endl;\n\tREP(i,edge[last].size()){\n\t\tint next=edge[last][i];\n\t\tif(dead[next]) continue;\n\t\tsolve(next);\n\t}\n}\nint main(){\n\tint N,u,v;\n\tcin >> N;\n\tREP(i,N-1){\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tedge[v].PB(u);\n\t\tedge[u].PB(v);\n\t}\n\tsolve(1);\n\tFOR(i,1,N+1){\n\t\tprintf(\"%d\\n\",N*2-2-depters[i][0].first);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define repi(i,a,b) for(long long i = (long long)(a); i < (long long)(b); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\n#define mt make_tuple\n#define mp make_pair\n#define ZERO(a) memset(a,0,sizeof(a))\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n#define exists find_if\n#define forall all_of\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\nusing ld = long double;  using vld = vector<ld>; \nusing vi = vector<int>; using vvi = vector<vi>; vll conv(vi& v) { vll r(v.size()); rep(i, v.size()) r[i] = v[i]; return r; }\nusing Pos = complex<double>;\n\ntemplate <typename T, typename U> ostream &operator<<(ostream &o, const pair<T, U> &v) {  o << \"(\" << v.first << \", \" << v.second << \")\"; return o; }\ntemplate<size_t...> struct seq{}; template<size_t N, size_t... Is> struct gen_seq : gen_seq<N-1, N-1, Is...>{}; template<size_t... Is> struct gen_seq<0, Is...> : seq<Is...>{};\ntemplate<class Ch, class Tr, class Tuple, size_t... Is>\nvoid print_tuple(basic_ostream<Ch,Tr>& os, Tuple const& t, seq<Is...>){ using s = int[]; (void)s{0, (void(os << (Is == 0? \"\" : \", \") << get<Is>(t)), 0)...}; }\ntemplate<class Ch, class Tr, class... Args> \nauto operator<<(basic_ostream<Ch, Tr>& os, tuple<Args...> const& t) -> basic_ostream<Ch, Tr>& { os << \"(\"; print_tuple(os, t, gen_seq<sizeof...(Args)>()); return os << \")\"; }\nostream &operator<<(ostream &o, const vvll &v) { rep(i, v.size()) { rep(j, v[i].size()) o << v[i][j] << \" \"; o << endl; } return o; }\ntemplate <typename T> ostream &operator<<(ostream &o, const vector<T> &v) { o << '['; rep(i, v.size()) o << v[i] << (i != v.size()-1 ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T>  ostream &operator<<(ostream &o, const unordered_set<T> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U>  ostream &operator<<(ostream &o, const map<T, U> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it << (next(it) != m.end() ? \", \" : \"\"); o << \"]\";  return o; }\ntemplate <typename T, typename U, typename V>  ostream &operator<<(ostream &o, const unordered_map<T, U, V> &m) { o << '['; for (auto it = m.begin(); it != m.end(); it++) o << *it; o << \"]\";  return o; }\nvector<int> range(const int x, const int y) { vector<int> v(y - x + 1); iota(v.begin(), v.end(), x); return v; }\ntemplate <typename T> istream& operator>>(istream& i, vector<T>& o) { rep(j, o.size()) i >> o[j]; return i;}\nstring bits_to_string(ll input, ll n=64) { string s; rep(i, n) s += '0' + !!(input & (1ll << i)); reverse(all(s)); return s; }\n\ntemplate <typename T> unordered_map<T, ll> counter(vector<T> vec){unordered_map<T, ll> ret; for (auto&& x : vec) ret[x]++; return ret;};\nstring substr(string s, P x) {return s.substr(x.fi, x.se - x.fi); }\nstruct ci : public iterator<forward_iterator_tag, ll> { ll n; ci(const ll n) : n(n) { } bool operator==(const ci& x) { return n == x.n; } bool operator!=(const ci& x) { return !(*this == x); } ci &operator++() { n++; return *this; } ll operator*() const { return n; } };\n\nsize_t random_seed; namespace std { using argument_type = P; template<> struct hash<argument_type> { size_t operator()(argument_type const& x) const { size_t seed = random_seed; seed ^= hash<ll>{}(x.fi); seed ^= (hash<ll>{}(x.se) << 1); return seed; } }; }; // hash for various class\nnamespace myhash{ const int Bsizes[]={3,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81}; const int xor_nums[]={0x100007d1,0x5ff049c9,0x14560859,0x07087fef,0x3e277d49,0x4dba1f17,0x709c5988,0x05904258,0x1aa71872,0x238819b3,0x7b002bb7,0x1cf91302,0x0012290a,0x1083576b,0x76473e49,0x3d86295b,0x20536814,0x08634f4d,0x115405e8,0x0e6359f2}; const int hash_key=xor_nums[rand()%20]; const int mod_key=xor_nums[rand()%20]; template <typename T> struct myhash{ std::size_t operator()(const T& val) const { return (hash<T>{}(val)%mod_key)^hash_key; } }; };\ntemplate <typename T> class uset:public std::unordered_set<T,myhash::myhash<T>> { using SET=std::unordered_set<T,myhash::myhash<T>>; public: uset():SET(){SET::rehash(myhash::Bsizes[rand()%20]);} };\nuint32_t randxor() { static uint32_t x=1+(uint32_t)random_seed,y=362436069,z=521288629,w=88675123; uint32_t t; t=(x^(x<<11));x=y;y=z;z=w; return( w=(w^(w>>19))^(t^(t>>8)) ); }\nstruct timeval start; double sec() { struct timeval tv; gettimeofday(&tv, NULL); return (tv.tv_sec - start.tv_sec) + (tv.tv_usec - start.tv_usec) * 1e-6; }\nstruct init_{init_(){ gettimeofday(&start, NULL); ios::sync_with_stdio(false); cin.tie(0); struct timeval myTime; struct tm *time_st; gettimeofday(&myTime, NULL); time_st = localtime(&myTime.tv_sec); srand(myTime.tv_usec); random_seed = RAND_MAX / 2 + rand() / 2; }} init__;\n#define rand randxor\n\nstatic const double EPS = 1e-14;\nstatic const long long INF = 1e18;\nstatic const long long mo = 1e9+7;\n#define ldout fixed << setprecision(40) \n\nint main(void) {\n    ll n; cin >> n;\n    vvll g(n);\n    rep(i, n-1) {\n        ll u, v; cin >> u >> v; u--, v--;\n        g[u].pb(v);\n        g[v].pb(u);\n    }\n\n    vll d(n);\n    function<ll(ll, ll)> f = [&](ll v, ll p) {\n        for (auto u : g[v]) if (u != p) {\n            chmax(d[v], f(u, v));\n        }\n        return d[v] + 1;\n    };\n    f(0, -1);\n//    cout << d << endl;\n\n    vll ret(n);\n    // dpar[v][p] = p???v???????????¨?????¨????????§?????§???d\n    function<void(ll, ll, ll)> ff = [&](ll v, ll p, ll dpar) {\n        vector<P> children;\n        for (auto u : g[v]) {\n            children.emplace_back(u == p ? dpar + 1 : d[u] + 1, u);\n        }\n        sort(all(children)); reverse(all(children));\n//        cout << v << \" \" << dpar << \" : \" << children << endl;\n\n        ret[v] = children[0].fi;\n\n        for (auto u : g[v]) if (u != p) {\n            ff(u, v, children[children[0].se==u].fi);\n        }\n    };\n    ff(0, -1, 0);\n\n\n    rep(i, n) cout << 2 * (n - 1) - ret[i] << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> dist1,dist2;\n\nvoid dfs1(int cur,int prv){\n  for(auto nxt:adj[cur]){\n    if(nxt==prv)continue;\n    dfs1(nxt,cur);\n    dist1[cur] = max(dist1[cur],dist1[nxt]+1);\n  }\n}\n\nvoid dfs2(int cur,int prv){\n  vector<pair<int,int>> tmp;\n  tmp.emplace_back(dist2[cur],prv);\n  for(auto nxt:adj[cur]){\n    if(nxt==prv)continue;\n    tmp.emplace_back(dist1[nxt]+1,nxt);\n  }\n  sort(tmp.begin(),tmp.end(),greater<>());\n  for(auto nxt:adj[cur]){\n    if(nxt==prv)continue;\n    dist2[nxt] = max(dist2[nxt],tmp[tmp[0].second==nxt].first+1);\n    dfs2(nxt,cur);\n  }\n}\n\nsigned main(){\n\n  int n;\n  cin>>n;\n  adj.resize(n);\n  dist1.resize(n);\n  dist2.resize(n);\n  for(int i=0;i<n-1;++i){\n    int u,v;\n    cin>>u>>v;\n    u--;v--;\n    adj[u].emplace_back(v);\n    adj[v].emplace_back(u);\n  }\n  dfs1(0,-1);\n  dfs2(0,-1);\n  for(int i=0;i<n;++i){\n    cout<<(n-1)*2-max(dist1[i],dist2[i])<<endl;\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define PB push_back\n#define MP make_pair\n#define F first\n#define S second\n#define int long long int\nusing namespace std;\ntypedef vector<int> VI;\ntypedef pair<int, int> PII;\ntypedef vector<PII> VP;\nconst double PI = 3.141592653589793238;\n\nint n;\n\nVI node[100010];\n\nint farest[10][100010];\nvoid solvefar(int nm, int now, int times)\n{\n  if(farest[nm][now] == -1){\n    farest[nm][now] = times;\n    for(int i = 0; i < node[now].size(); i++){\n      solvefar(nm, node[now][i], times + 1);\n    }\n  }\n}\n\nsigned main()\n{\n  scanf(\"%lld\", &n);\n  for(int i = 0; i < n - 1; i++){\n    int u, v;\n    scanf(\"%lld%lld\", &u, &v);\n    node[u].PB(v);\n    node[v].PB(u);\n  }\n\n  memset(farest, -1, sizeof farest);\n  \n  solvefar(0, 1, 0);\n\n  int far1 = 0, mx1 = 0;\n  for(int i = 1; i <= n; i++){\n    if(mx1 < farest[0][i]){\n      far1 = i;\n      mx1 = farest[0][i];\n    }\n  }\n  \n  solvefar(1, far1, 0);\n\n  int far2 = 0, mx2 = 0;\n  for(int i = 1; i <= n; i++){\n    if(mx2 < farest[1][i]){\n      far2 = i;\n      mx2 = farest[1][i];\n    }\n  }\n\n  solvefar(2, far2, 0);\n\n  for(int i = 1; i <= n; i++){\n    farest[3][i] = max(farest[1][i], farest[2][i]);\n  }\n  \n\n  for(int i = 1; i <= n; i++){\n    printf(\"%lld\\n\", farest[3][i] + (n - 1 - farest[3][i]) * 2);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct edge\n{\n\tll to, cost;\n};\n\n\nvector<edge> g[100000];\nll dist[100000],ans[100000];\n\nvoid dfs1(ll idx,int par)\n{\n\tfor(auto&i:g[idx])\n\t{\n\t\tif(i.to==par)continue;\n\t\tdfs1(i.to, idx);\n\t\tdist[idx] = max(dist[idx],dist[i.to]+1);\n\t}\n}\n\n\nvoid dfs2(ll idx,int d_par,int par)\n{\n\tvector<pair<ll,int>> d_child;\n\td_child.emplace_back(0,-1);\n\tfor(auto &i:g[idx])\n\t{\n\t\tif(i.to==par)d_child.emplace_back(d_par+1,i.to);\n\t\telse d_child.emplace_back(dist[i.to]+1,i.to);\n\t}\n\tsort(d_child.rbegin(),d_child.rend());\n\tans[idx] = d_child[0].first;\n\tfor(auto &i:g[idx])\n\t{\n\t\tif(i.to==par)continue;\n\t\tdfs2(i.to,d_child[d_child[0].second==i.to].first,idx);\n\t}\n}\n\n\nint main()\n{\n\tll n;\n\tcin >> n;\n\tfor(ll i = 0;i<n-1;i++)\n\t{\n\t\tll a,b;\n\t\tcin >> a >> b;\n\t\ta--;b--;\n\t\tg[a].push_back((edge){b,1});\n\t\tg[b].push_back((edge){a,1});\n\t}\n\tdfs1(0,-1);\n\tdfs2(0,0,-1);\n\tfor(ll i =0;i<n;i++)\n\t{\n\t\tcout<<(n-1)*2-ans[i]<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< int > g[100000];\nint dist[100000], ans[100000];\n\nvoid dfs1(int idx, int par)\n{\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs1(to, idx);\n    dist[idx] = max(dist[idx], dist[to] + 1);\n  }\n}\n\nvoid dfs2(int idx, int d_par, int par)\n{\n  vector< pair< int, int > > d_child;\n  // d_child.emplace_back(0, -1);\n  for(int &to : g[idx]) {\n    if(to == par) d_child.emplace_back(d_par + 1, to);\n    else d_child.emplace_back(dist[to] + 1, to);\n  }\n  sort(d_child.rbegin(), d_child.rend());\n  ans[idx] = d_child[0].first;\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs2(to, d_child[d_child[0].second == to].first, idx);\n  }\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  for(int i = 0; i < N - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n\n  if(N == 2) {\n    cout << 1 << endl << 1 << endl;\n    return (0);\n  }\n\n  int root = 0;\n  for(int i = 0; i < N; i++) if(g[i].size() >= 2) root = i;\n  dfs1(root, -1);\n  dfs2(root, 0, -1);\n  for(int i = 0; i < N; i++) {\n    cout << (N - 1) * 2 - ans[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<utility>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<map>\n#include<set>\n#include<cstring>\n#include<string>\n#include<stack>\n#include<math.h>\n#include<stdlib.h>\nusing namespace std;\n#define int long long\n//#define double long double\ntypedef pair<int, int> pii;\ntypedef pair<pii, int> ppi;\ntypedef pair<int, pii > pip;\ntypedef pair<pii, pii > piipii;\ntypedef pair<double, double> pdd;\ntypedef pair<int, char> pic;\ntypedef priority_queue<pii, vector<pii>, greater<pii> > RPQ;\n#define all(vec) vec.begin(), vec.end()\n#define mk make_pair\n#define INF (1 << 30)\n#define INFL (1ll << 60)\n#define mod 1000000007\n#define se second\n#define fi first\n\nint N;\nvector<int> G[100100];\nint dist[100100];\nint ans[100100];\n\nvoid dfs1(int v, int par){\n    for(auto& e : G[v]){\n        if(e == par){\n            continue;\n        }\n        dfs1(e, v);\n        dist[v] = max(dist[v], dist[e] + 1);\n    }\n}\n\nvoid dfs2(int v, int d_par, int par){\n    vector<pair<int, int> > V;\n    V.push_back(mk(0, -1));\n    for(auto& e : G[v]){\n        if(e == par){\n            V.push_back(mk(d_par + 1, par));\n            continue;\n        }\n        V.push_back(mk(dist[e] + 1, e));\n    }\n    sort(V.rbegin(), V.rend());\n    ans[v] = V[0].first;\n    for(auto& e : G[v]){\n        if(e == par)continue;\n        if(e == V[0].second){\n            dfs2(e, V[1].first, v);\n        }\n        else {\n            dfs2(e, V[0].first, v);\n        }\n    }\n}\n\nsigned main(){\n    cin >> N;\n    for(int i = 0; i < N - 1; i++){\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    dfs1(0, -1);\n    dfs2(0, 0, -1);\n    for(int i = 0; i < N; i++){\n        cout << (N - 1) * 2 - ans[i] << endl;\n    }\n    \n    return 0;\n}\n\n/*\n\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\n#define int long long\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define endl \"\\n\"\n\nconst long long INF = (long long)1e18;\nconst long long MOD = (long long)1e9 + 7; \n\nstring yn(bool f){return f?\"Yes\":\"No\";}\nstring YN(bool f){return f?\"YES\":\"NO\";}\n\n#define MAX 110000\n\nint n;\nvector<pair<int,int>> G[MAX];\nint dis[MAX], dis3[MAX];\n\nvoid dfs1(int node, int previous){\n\tint maximum = 0;\n\t\n\tfor(int i = 0; i < G[node].size(); i++){\n\t\tif(previous == G[node][i].first) continue;\n\t\tdfs1(G[node][i].first, node);\n\t\tmaximum = max(maximum, dis[G[node][i].first] + G[node][i].second);\n\t}\n\t\n\tdis[node] = maximum;\n}\n\nint dfs2(int node, int previous, int pmax){\n\tvector<pair<int,int>> dis2;\n\tint res = 0;\n\t\n\t\n\tdis2.push_back(make_pair(pmax, previous));\n\t\n\tfor(int i = 0; i < G[node].size(); i++){\n\t\tif(previous == G[node][i].first) continue;\n\t\tdis2.push_back(make_pair(dis[G[node][i].first] + G[node][i].second, G[node][i].first));\n\t}\n\t\n\tsort(dis2.begin(), dis2.end(), greater<pair<int,int>>());\n\t\n\tfor(int i = 0; i < dis2.size() && i < 1; i++){\n\t\tdis3[node] += dis2[i].first;\n\t}\n\t\n\t\n\tfor(int i = 0; i < G[node].size(); i++){\n\t\tif(previous == G[node][i].first) continue;\n\t\tint npmax = 0;\n\t\tif(dis2.size() && G[node][i].first != dis2[0].second) npmax = dis2[0].first;\n\t\tif(dis2.size() >= 2 && G[node][i].first == dis2[0].second)  npmax = dis2[1].first;\n\t\tdfs2(G[node][i].first, node, npmax + G[node][i].second);\n\t\t// dis3[node] = max(dis3[node], dis3[G[node][i].first]);\n\t}\n\t\n}\n\nsigned main(){\n\t// cin.tie(0);\n\t// ios::sync_with_stdio(false);\n\t// cout<<fixed<<setprecision(10);\n\t\n\tint s, t, w;\n\tint start = 0;\n\tint ans = 0;\n\tcin >> n;\n\t\n\tfor(int i = 0; i < n-1; i++){\n\t\tcin >> s >> t;\n\t\ts--, t--;\n\t\tG[s].push_back(make_pair(t,1));\n\t\tG[t].push_back(make_pair(s,1));\n\t}\n\t\n\tdfs1(start,-1);\n\t\n\tdfs2(start, -1, 0);\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcout<<(n-1)*2 - dis3[i]<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 100000;\n\nint n;\nvector<int> G[N];\n\nint dp1[N];\nint dfs(int v, int par)\n{\n    vector<int> c;\n    for(int nx:G[v])if(nx!=par) c.pb(dfs(nx,v));\n\n    sort(all(c));\n    reverse(all(c));\n    int C = c.size();\n\n    int ret = 0;\n    if(C>0)\n    {\n        ret = c[0]+1;\n        for(int i=1; i<C; ++i) ret += 2*(c[i]+1);\n    }\n    return dp1[v] = ret;\n}\n\nint dp2[N];\nvoid dfs2(int v, int par, int d)\n{\n    // printf(\" dfs2 %d %d %d\\n\", v,par,d);\n    vector<pair<int,int>> c;\n    for(int nx:G[v])if(nx!=par) c.pb({dp1[nx],nx});\n    c.pb({d,-1});\n    c.pb({-1,-1});\n\n    sort(all(c));\n    reverse(all(c));\n    int C = c.size();\n\n    int ans = c[0].fi+1;\n    for(int i=1; i<C; ++i) ans += 2*(c[i].fi+1);\n\n    dp2[v] = ans;\n\n    rep(i,C)\n    {\n        int nx = c[i].se;\n        if(nx==-1) continue;\n\n        int nd = ans;\n        if(i==0)\n        {\n            nd -= c[0].fi+1;\n            nd -= c[1].fi+1;\n        }\n        else nd -= 2*(c[i].fi+1);\n\n        dfs2(nx,v,nd);\n    }\n}\n\nint main()\n{\n    cin >>n;\n    rep(i,n-1)\n    {\n        int u,v;\n        cin >>u >>v;\n        --u;\n        --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    dfs(0,-1);\n\n    dfs2(0,-1,-1);\n    rep(i,n) cout << dp2[i] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\n\nint main(void) {\n    ll n; cin >> n;\n    vvll g(n);\n    rep(i, n-1) {\n        ll u, v; cin >> u >> v; u--, v--;\n        g[u].pb(v), g[v].pb(u);\n    }\n\n    vll d(n);\n    function<ll(ll, ll)> f = [&](ll v, ll p) {\n        for (auto u : g[v]) if (u != p) chmax(d[v], f(u, v));\n        return d[v] + 1;\n    };\n    f(0, -1);\n\n    vll ret(n);\n    // dpar[v][p] = p???v???????????¨?????¨????????§?????§???d\n    function<void(ll, ll, ll)> ff = [&](ll v, ll p, ll dpar) {\n        vector<P> children;\n        for (auto u : g[v]) children.emplace_back(u == p ? dpar + 1 : d[u] + 1, u);\n        sort(all(children)); reverse(all(children));\n\n        ret[v] = children[0].fi;\n\n        for (auto u : g[v]) if (u != p) ff(u, v, children[children[0].se==u].fi);\n    };\n    ff(0, -1, 0);\n\n    rep(i, n) cout << 2 * (n - 1) - ret[i] << endl;\n\n\n    return 0;\n}\n#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\n\nint main(void) {\n    ll n; cin >> n;\n    vvll g(n);\n    rep(i, n-1) {\n        ll u, v; cin >> u >> v; u--, v--;\n        g[u].pb(v), g[v].pb(u);\n    }\n\n    vll d(n);\n    function<ll(ll, ll)> f = [&](ll v, ll p) {\n        for (auto u : g[v]) if (u != p) chmax(d[v], f(u, v));\n        return d[v] + 1;\n    };\n    f(0, -1);\n\n    vll ret(n);\n    // dpar[v][p] = p???v???????????¨?????¨????????§?????§???d\n    function<void(ll, ll, ll)> ff = [&](ll v, ll p, ll dpar) {\n        vector<P> children;\n        for (auto u : g[v]) children.emplace_back(u == p ? dpar + 1 : d[u] + 1, u);\n        sort(all(children)); reverse(all(children));\n\n        ret[v] = children[0].fi;\n\n        for (auto u : g[v]) if (u != p) ff(u, v, children[children[0].se==u].fi);\n    };\n    ff(0, -1, 0);\n\n    rep(i, n) cout << 2 * (n - 1) - ret[i] << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=a;i<b;i++)\n#define REP(i,b) FOR(i,0,b)\n#define MP make_pair\n#define PB push_back\n\nusing ll=long long;\nusing pii=pair<int,int>;\nusing vi=vector<int>;\nusing ld=long double;\n\nint read(){\n\tint i;\n\tscanf(\"%d\",&i);\n\treturn i;\n}\n\nvi g[114514];\nint dist[114514];\nvoid dfs(int v,int p,int d){\n\tdist[v]=max(dist[v],d);\n\tfor(auto c:g[v])if(c!=p)\n\t\tdfs(c,v,d+1);\n}\n\nint main(){\n\tint n=read();\n\tREP(i,n-1){\n\t\tint u=read()-1,v=read()-1;\n\t\tg[u].PB(v);\n\t\tg[v].PB(u);\n\t}\n\tdfs(0,-1,0);\n\tint x=max_element(dist,dist+n)-dist;\n\tfill(dist,dist+n,0);\n\tdfs(x,-1,0);\n\tint y=max_element(dist,dist+n)-dist;\n\tdfs(y,-1,0);\n\tREP(i,n)\n\t\tprintf(\"%d\\n\",(n-1)*2-dist[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(a)-1;i>=b;i--)\n#define chmin(a,b) (a)=min((a),(b));\n#define chmax(a,b) (a)=max((a),(b));\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define printV(v) cerr<<(#v)<<\":\";for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;\n#define printVS(vs) cerr<<(#vs)<<\":\"<<endl;for(auto(s):(vs)){cerr<<(s)<< endl;}\n#define printVV(vv) cerr<<(#vv)<<\":\"<<endl;for(auto(v):(vv)){for(auto(x):(v)){cerr<<\" \"<<(x);}cerr<<endl;}\n#define printP(p) cerr<<(#p)<<(p).first<<\" \"<<(p).second<<endl;\n#define printVP(vp) cerr<<(#vp)<<\":\"<<endl;for(auto(p):(vp)){cerr<<(p).first<<\" \"<<(p).second<<endl;}\n\ninline void output(){ cerr << endl; }\ntemplate<typename First, typename... Rest>\ninline void output(const First& first, const Rest&... rest) {\n    cerr << first << \" \"; output(rest...);\n}\n\nusing ll = long long;\nusing Pii = pair<int, int>;\nusing TUPLE = tuple<int, int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nconst int inf = 1ll << 60;\nconst int mod = 1e9 + 7;\nusing Graph = vector<vector<int>>;\n\nint dp[100000];\nint mi[100000];\n\nint dfs(int now, int pre, const Graph& G) {\n    for (auto nxt : G[now]) {\n        if (nxt == pre) continue;\n        chmax(dp[now], dfs(nxt, now, G) + 1);\n    }\n    return dp[now];\n}\n\nvoid dfs2(int now, int pre, int prop, const Graph& G) {\n    vector<Pii> vp;\n    vp.emplace_back(0, -1);\n    for (auto nxt : G[now]) {\n        if (nxt == pre) vp.emplace_back(prop + 1, nxt);\n        else vp.emplace_back(dp[nxt] + 1, nxt);\n    }\n    sort(rall(vp));\n    mi[now] = vp[0].first;\n    for (auto nxt : G[now]) {\n        if (nxt == pre) continue;\n        dfs2(nxt, now, vp[vp[0].second == nxt].first, G);\n    }\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n;\n    cin >> n;\n    Graph G(n);\n    rep(i, n - 1) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n\n    dfs(0, -1, G);\n    dfs2(0, -1, 0, G);\n\n    rep(i, n) cout << 2 * (n - 1) - mi[i] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 100000;\n\nint n;\nvector<int> G[N];\n\nint dp1[N];\nint dfs(int v, int par)\n{\n    vector<int> c;\n    for(int nx:G[v])if(nx!=par) c.pb(dfs(nx,v));\n\n    sort(all(c));\n    reverse(all(c));\n    int C = c.size();\n\n    int ret = 0;\n    if(C>0)\n    {\n        ret = c[0]+1;\n        for(int i=1; i<C; ++i) ret += 2*(c[i]+1);\n    }\n    return dp1[v] = ret;\n}\n\nint dp2[N];\nvoid dfs2(int v, int par, int d)\n{\n    // printf(\" dfs2 %d %d %d\\n\", v,par,d);\n    vector<pair<int,int>> c;\n    for(int nx:G[v])if(nx!=par) c.pb({dp1[nx],nx});\n    c.pb({d,-1});\n    c.pb({-1,-1});\n\n    sort(all(c));\n    reverse(all(c));\n    int C = c.size();\n\n    int ans = c[0].fi+1;\n    for(int i=1; i<C; ++i) ans += 2*(c[i].fi+1);\n\n    dp2[v] = ans;\n\n    rep(i,C)\n    {\n        int nx = c[i].se;\n        if(nx==-1) continue;\n\n        int nd = ans;\n        if(i==0)\n        {\n            nd -= c[0].fi+1;\n            nd -= c[1].fi+1;\n        }\n        else nd -= 2*(c[i].fi+1);\n\n        dfs2(nx,v,nd);\n    }\n}\n\nint main()\n{\n    cin >>n;\n    rep(i,n-1)\n    {\n        int u,v;\n        cin >>u >>v;\n        --u;\n        --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    dfs(0,-1);\n    rep(i,n) printf(\"%d%c\", dp1[i],\" \\n\"[i==n-1]);\n\n    dfs2(0,-1,-1);\n    rep(i,n) cout << dp2[i] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef int LL;\ntypedef int ut;\ntypedef pair<ut,ut> pr;\ntypedef vector<ut> VI;\ntypedef vector<pr> Vpr;\ntypedef priority_queue<pr,Vpr,greater<pr> > PQ;\nconst int SIZE=2*1e5;\n//const ut INF=1LL<<60;\nVI edge[SIZE];\nbool dead[SIZE];\nLL ans[SIZE];\nbool searched[SIZE];\nint needs[SIZE];\nint grav[SIZE];\nint dist[SIZE];\nint nums[SIZE];\nint sums[SIZE];\nint times[SIZE];\nint depthest[SIZE];\nint timer;\nVpr depters[SIZE];\nint depther[SIZE];\nLL dfs(int start,int bad,VI& nodes,int depth,bool want){\n\tint ans=0;\n\tqueue<pr> st;\n\tst.push(pr(start,bad)); \n\tdepther[start]=depth;\n\twhile(!st.empty()){\n\t\tint now=st.front().first,from=st.front().second;\n\t\tst.pop();\n\t\tif(dead[now]){\n\t\t\tif(from!=depters[now][0].second) return ans=max(ans,depters[now][0].first+depther[now]);\n\t\t\treturn ans=max(ans,depters[now][1].first+depther[now]);\n\t\t}\n\t\ttimer++;\n\t\tif(want)\n\t\t\tnodes.PB(now);\n\t\t//cout << now << \" \" << depth << endl;\n\t\tans=max(ans,depther[now]);\n\t\tREP(i,edge[now].size()){\n\t\t\tint next=edge[now][i];\n\t\t\tif(next!=from){\n\t\t\t\tdepther[next]=depther[now]+1;\n\t\t\t\tst.push(pr(next,now));\n\t\t\t}\n\t\t}\n\t}\n\t//cout << start <<\" \" << ans << endl;\n\treturn ans;\n}\n/*\nvoid gives(int now,int from,int depth,LL alls,LL nodes){\n\tans[now]+=depth*nodes+alls;\n\tREP(i,edge[now].size()){\n\t\tint next=edge[now][i];\n\t\tif(next!=from && !dead[next])\n\t\t\tgives(next,now,depth+1,alls,nodes);\n\t}\n}*/\nvoid centerize(int now,VI& nodes){\n\tcat;\n\tdead[now]=true;\n\tVI dummy;\n//\tLL alls=0;\n\t//cout << now;\n\tREP(i,edge[now].size()){\n\t\ttimer=0;\n\t\tint next=edge[now][i];\n\t\t//if(dead[next]) continue;\n\t\tdepters[now].PB(pr(dfs(next,now,dummy,1,false),next));\n\t//\tcout << depters[now].back().first;\n//\t\tnums[i]=timer;\n//\t\talls+=sums[i];\n\t}\n\tdummy.clear();\n\t//cout << endl;\n\tdepters[now].PB(pr(0,-1));\n\tsort(ALL(depters[now]),greater<pr>());\n//\tans[now]+=alls;\n//\tREP(i,edge[now].size()){\n//\t\tint next=edge[now][i];\n//\t\tif(dead[next]) continue;\n//\t\tgives(next,now,1,alls-sums[i],nodes.size()-nums[i]);\n//\t\talls+=sums[i];\n//\t}\n\tcat;\t\n}\n\nvoid solve(int now){\n\tcat;\n\tVI nodes;\n\tPQ qu;\n\tdfs(now,-1,nodes,1,true);\n\tcat;\n\tint last=nodes[0];\n\tcat;\n\tcat;\n\tREP(i,nodes.size()){\n\t\tneeds[nodes[i]]=-1;\n\t\tsearched[nodes[i]]=false;\n\t\tgrav[nodes[i]]=0;\n\t\tREP(j,edge[nodes[i]].size()){\n\t\t\tint next=edge[nodes[i]][j];\n\t\t\tif(!dead[next]) needs[nodes[i]]++;\n\t\t}\n\n\t\tif(needs[nodes[i]]==0) qu.push(pr(0,nodes[i]));\n\t}\n\tcat;\n\twhile(!qu.empty()){\n\t\tint now=qu.top().second,gravity=qu.top().first;\n\t\tqu.pop();\n\t\tsearched[now]=true;\n\t\tlast=now;\n\t\tREP(i,edge[now].size()){\n\t\t\tint next=edge[now][i];\n\t\t\tif(dead[next]) continue;\n\t\t\tif(searched[next]) continue;\n\t\t\tgrav[next]+=grav[now]+1;\n\t\t\ttimes[next]++;\n\t\t\tif(times[next]==needs[next]) qu.push(pr(grav[next],next));\n\t\t}\n\n\t}\n\tcenterize(last,nodes);\n\tnodes.clear();\n\tREP(i,edge[last].size()){\n\t\tint next=edge[last][i];\n\t\tif(dead[next]) continue;\n\t\tsolve(next);\n\t}\n}\nint main(){\n\tint N,u,v;\n\tcin >> N;\n\tREP(i,N-1){\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tedge[u].PB(v);\n\t\tedge[v].PB(u);\n\t}\n\tsolve(1);\n\tFOR(i,1,N+1){\n\t\tprintf(\"%d\\n\",N*2-2-depters[i][0].first);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename Data, typename T >\nstruct ReRooting {\n\n  struct Node {\n    int to, rev;\n    Data data;\n  };\n\n  using F1 = function< T(T, T) >;\n  using F2 = function< T(T, int, int, Data) >; // ret, src, to, data\n\n\n  vector< vector< Node > > g;\n  vector< vector< T > > ldp, rdp;\n  vector< int > lptr, rptr;\n  const F1 f1;\n  const F2 f2;\n  const T ident;\n\n  ReRooting(int n, const F1 &f1, const F2 &f2, const T &ident) :\n      g(n), ldp(n), rdp(n), lptr(n), rptr(n), f1(f1), f2(f2), ident(ident) {}\n\n  void add_edge(int u, int v, const Data &d) {\n    g[u].emplace_back((Node) {v, (int) g[v].size(), d});\n    g[v].emplace_back((Node) {u, (int) g[u].size() - 1, d});\n  }\n\n  T dfs(int idx, int par) {\n\n    while(lptr[idx] != par && lptr[idx] < g[idx].size()) {\n      auto &e = g[idx][lptr[idx]];\n      ldp[idx][lptr[idx] + 1] = f1(ldp[idx][lptr[idx]], f2(dfs(e.to, e.rev), idx, e.to, e.data));\n      ++lptr[idx];\n    }\n    while(rptr[idx] != par && rptr[idx] >= 0) {\n      auto &e = g[idx][rptr[idx]];\n      rdp[idx][rptr[idx]] = f1(rdp[idx][rptr[idx] + 1], f2(dfs(e.to, e.rev), idx, e.to, e.data));\n      --rptr[idx];\n    }\n    if(par < 0) return rdp[idx][0];\n    return f1(ldp[idx][par], rdp[idx][par + 1]);\n  }\n\n  vector< T > solve() {\n    for(int i = 0; i < g.size(); i++) {\n      ldp[i].assign(g[i].size() + 1, ident);\n      rdp[i].assign(g[i].size() + 1, ident);\n      lptr[i] = 0;\n      rptr[i] = (int) g[i].size() - 1;\n    }\n    vector< T > ret;\n    for(int i = 0; i < g.size(); i++) {\n      ret.push_back(dfs(i, -1));\n    }\n    return ret;\n  }\n};\n\n\nint main() {\n  int N, D;\n  cin >> N;\n\n  auto f1 = [](int a, int b) {\n    return max(a, b);\n  };\n\n  auto f2 = [](int a, int src, int to, int data) {\n    return a + data;\n  };\n\n  ReRooting< int, int > g(N, f1, f2, 0);\n  for(int i = 1; i < N; i++) {\n    int s, t;\n    cin >> s >> t;\n    --s, --t;\n    g.add_edge(s, t, 1);\n  }\n  for(auto &p : g.solve()) {\n    cout << (N - 1) * 2 - p << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< int > g[100000];\nint dist[100000], ans[100000];\n\nvoid dfs1(int idx, int par)\n{\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs1(to, idx);\n    dist[idx] = max(dist[idx], dist[to] + 1);\n  }\n}\n\nvoid dfs2(int idx, int d_par, int par)\n{\n  vector< pair< int, int > > d_child;\n  // d_child.emplace_back(0, -1);\n  for(int &to : g[idx]) {\n    if(to == par) d_child.emplace_back(d_par + 1, to);\n    else d_child.emplace_back(dist[to] + 1, to);\n  }\n  sort(d_child.rbegin(), d_child.rend());\n  ans[idx] = d_child[0].first;\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    if(par == -1 && g[idx].size() == 1) dfs2(to, 0, idx);\n    else dfs2(to, d_child[d_child[0].second == to].first, idx);\n  }\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  for(int i = 0; i < N - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n\n  dfs1(0, -1);\n  dfs2(0, 0, -1);\n  for(int i = 0; i < N; i++) {\n    cout << (N - 1) * 2 - ans[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ld> pld;\ntypedef pair<pii, int> ppiii;\ntypedef pair<pii, ll> ppiil;\ntypedef pair<pll, ll> pplll;\ntypedef vector<vector<ll>> vvl;\ntypedef vector<vector<int>> vvi;\n#define rep(i, a, b) for (ll i=(a); i<(b); i++)\n#define rrep(i, a, b) for (ll i=(a); i>(b); i--)\n#define btoe(obj) (obj).begin(), (obj).end()    \n#define pb push_back\n#define str to_string\n#define mkp make_pair\nconst ll INF = 1e18;\nconst ll MOD = 1e9 + 7;\ntemplate<typename T> inline bool chmax(T &x, T y) { return (y > x) ? x = y, true : false; }\ntemplate<typename T> inline bool chmin(T &x, T y) { return (y < x) ? x = y, true : false; }\n\ntemplate<typename T>\nvoid print(T out) {\n    cout << out << '\\n';\n}\n\nvoid print(ld out) {\n    cout << fixed << setprecision(12) << out << '\\n';\n}\n\ntemplate<typename T1, typename T2>\nvoid print(pair<T1, T2> out) {\n    cout << out.first << ' ' << out.second << '\\n';\n}\n\ntemplate<typename T>\nvoid print(vector<T> A) {\n    rep(i, 0, A.size()) {\n        cout << A[i];\n        cout << (i == A.size()-1 ? '\\n' : ' ');\n    }\n}\n\ntemplate<typename T>\nvoid print(set<T> S) {\n    vector<T> A(btoe(S));\n    print(A);\n}\n\nll sum(vector<ll> A) {\n    ll res = 0;\n    for (ll a: A) res += a;\n    return res;\n}\n\nll max(vector<ll> A) {\n    ll res = -INF;\n    for (ll a: A) chmax(res, a);\n    return res;\n}\n\nll min(vector<ll> A) {\n    ll res = INF;\n    for (ll a: A) chmin(res, a);\n    return res;\n}\n\nll sum(ll A[], int len) {\n    ll res = 0;\n    rep(i, 0, len) res += A[i];\n    return res;\n}\n\nll max(ll A[], int len) {\n    ll res = -INF;\n    rep(i, 0, len) chmax(res, A[i]);\n    return res;\n}\n\nll min(ll A[], int len) {\n    ll res = INF;\n    rep(i, 0, len) chmin(res, A[i]);\n    return res;\n}\n\nll toint(string s) {\n    ll res = 0;\n    for (char c : s) {\n        res *= 10;\n        res += (c - '0');\n    }\n    return res;\n}\n\nint toint(char c) {\n    return c - '0';\n}\n\nll pow(ll x, ll n, int mod) {\n    ll res = 1;\n    while (n > 0) {\n        if (n & 1) {\n            res = (res * x) % mod;\n        }\n        x = (x * x) % mod;\n        n >>= 1;\n    }\n    return res;\n}\n\ntemplate<typename sum_t, typename key_t>\nstruct ReRooting {\n    struct Edge {\n        int to;\n        key_t data;\n        sum_t dp, ndp;\n    };\n\n    using F1 = function<sum_t(sum_t, sum_t)>;\n    using F2 = function<sum_t(sum_t, key_t)>;\n\n    vector<vector<Edge>> g;\n    vector<sum_t> subdp, dp;\n    const sum_t ident;\n    const F1 f1;\n    const F2 f2;\n\n    ReRooting(int V, const F1 f1, const F2 f2, const sum_t &ident)\n        : g(V), f1(f1), f2(f2), ident(ident), subdp(V, ident), dp(V, ident) {}\n\n    void add_edge(int u, int v, const key_t &d) {\n        g[u].emplace_back((Edge) {v, d, ident, ident});\n        g[v].emplace_back((Edge) {u, d, ident, ident});\n    }\n\n    void add_edge_bi(int u, int v, const key_t &d, const key_t &e) {\n        g[u].emplace_back((Edge) {v, d, ident, ident});\n        g[v].emplace_back((Edge) {u, e, ident, ident});\n    }\n\n    void dfs_sub(int idx, int par) {\n        for(auto &e : g[idx]) {\n        if(e.to == par) continue;\n        dfs_sub(e.to, idx);\n        subdp[idx] = f1(subdp[idx], f2(subdp[e.to], e.data));\n        }\n    }\n\n    void dfs_all(int idx, int par, const sum_t &top) {\n        sum_t buff{ident};\n        for(int i = 0; i < (int) g[idx].size(); i++) {\n        auto &e = g[idx][i];\n        e.ndp = buff;\n        e.dp = f2(par == e.to ? top : subdp[e.to], e.data);\n        buff = f1(buff, e.dp);\n        }\n        dp[idx] = buff;\n        buff = ident;\n        for(int i = (int) g[idx].size() - 1; i >= 0; i--) {\n        auto &e = g[idx][i];\n        if(e.to != par) dfs_all(e.to, idx, f1(e.ndp, buff));\n        e.ndp = f1(e.ndp, buff);\n        buff = f1(buff, e.dp);\n        }\n    }\n\n    vector<sum_t> build() {\n        dfs_sub(0, -1);\n        dfs_all(0, -1, ident);\n        return dp;\n    }\n};\n\nll N;\nvector<ll> tmp(4);\n\n// 一番遠い葉への距離を見つける\nll f1(ll a, ll b) {\n    return max(a, b);\n}\n\nll f2(ll a, ll x) {\n    return a + x;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N;\n    ReRooting<ll, ll> rr(N, f1, f2, 0);\n    ll a, b, c;\n    rep(i, 0, N-1) {\n        cin >> a >> b;\n        a--; b--;\n        rr.add_edge(a, b, 1);\n    }\n    vector<ll> res = rr.build();\n    vector<ll> ans(N);\n    rep(i, 0, N) {\n        // 全部往復してくる - 一番遠い葉への距離(ここだけ片道でいいので)\n        ans[i] = (N-1) * 2 - res[i];\n    }\n    for (ll a : ans) {\n        print(a);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nvector<int> G[100000];\n\nint dist[100000];\nint ans[100000];\n\nint  dfs(int cur, int prev){\n    int ret = 0;\n    for(auto to:G[cur]){\n        if(to==prev)continue;\n        ret = max(ret,1+dfs(to,cur));\n    }\n    return dist[cur] = ret;\n}\n\n\nvoid dfs2(int cur, int prev, int d_par){\n    vector<pii> v{pii(0,-1)};\n    for(auto to:G[cur]){\n        if(to==prev)v.pb(pii(1+d_par,to));\n        else v.pb(pii(1+dist[to],to));\n    }\n    \n    sort(all(v),greater<pii>());\n    \n    for(auto to:G[cur]){\n        if(to==prev)continue;\n        if(v[0].second==to) dfs2(to,cur,v[1].first);\n        else                dfs2(to,cur,v[0].first);\n    }\n    ans[cur] = v[0].first;\n}\n\nint main(){\n    int v;\n    cin>>v;\n    rep(i,v-1){\n        int s,t;\n        cin>>s>>t;\n        s--,t--;\n        G[s].pb(t);\n        G[t].pb(s);\n    }\n    \n    dfs(0,-1);\n    \n    dfs2(0,-1,0);\n    \n    rep(i,v)cout<<2*(v-1)-ans[i]<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \nvector< int > g[100000];\nint dist[100000], ans[100000];\n \nvoid dfs1(int idx, int par)\n{\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs1(to, idx);\n    dist[idx] = max(dist[idx], dist[to] + 1);\n  }\n}\n \nvoid dfs2(int idx, int d_par, int par)\n{\n  vector< pair< int, int > > d_child;\n  // d_child.emplace_back(0, -1);\n  for(int &to : g[idx]) {\n    if(to == par) d_child.emplace_back(d_par + 1, to);\n    else d_child.emplace_back(dist[to] + 1, to);\n  }\n  sort(d_child.rbegin(), d_child.rend());\n  ans[idx] = d_child[0].first;\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs2(to, d_child[d_child[0].second == to].first, idx);\n  }\n}\n \nint main()\n{\n  int N;\n  cin >> N;\n  for(int i = 0; i < N - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n \n  if(N == 2) {\n    cout << 1 << endl << 1 << endl;\n    return (0);\n  }\n \n  int root = 0;\n  for(int i = 0; i < N; i++) if(g[i].size() >= 2) root = i;\n  dfs1(root, -1);\n  dfs2(root, 0, -1);\n  for(int i = 0; i < N; i++) {\n    cout << (N - 1) * 2 - ans[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\n\nint main(void) {\n    ll n; cin >> n;\n    vvll g(n);\n    rep(i, n-1) {\n        ll u, v; cin >> u >> v; u--, v--;\n        g[u].pb(v), g[v].pb(u);\n    }\n\n    vll d(n);\n    function<ll(ll, ll)> f = [&](ll v, ll p) {\n        for (auto u : g[v]) if (u != p) chmax(d[v], f(u, v));\n        return d[v] + 1;\n    };\n    f(0, -1);\n\n    vll ret(n);\n    // dpar[v][p] = p???v???????????¨?????¨????????§?????§???d\n    function<void(ll, ll, ll)> ff = [&](ll v, ll p, ll dpar) {\n        vector<P> children;\n        for (auto u : g[v]) children.emplace_back(u == p ? dpar + 1 : d[u] + 1, u);\n        sort(all(children)); reverse(all(children));\n\n        ret[v] = children[0].fi;\n\n        if (children.size() > 1) for (auto u : g[v]) if (u != p) ff(u, v, children[children[0].se==u].fi);\n    };\n    ff(0, -1, 0);\n\n    rep(i, n) cout << 2 * (n - 1) - ret[i] << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\n#include <iomanip>\n#include <cassert>\n#include <bitset>\nusing namespace std;\n\ntypedef pair<int, int> P;\n#define rep(i, n) for (int i=0; i<(n); i++)\n#define all(c) (c).begin(), (c).end()\n#define uniq(c) c.erase(unique(all(c)), (c).end())\n#define _1 first\n#define _2 second\n#define pb push_back\n#define INF 1145141919\n#define MOD 1000000007\n\nint N;\nvector<int> G[100000];\nint DD[100000];\nint D1[100000], D2[100000], Ds[100000];\n\nint dfs1(int x, int p) {\n  int s = 0;\n  for (int t : G[x]) {\n    if (t == p) continue;\n    s = max(s, dfs1(t, x)+1);\n  }\n  return DD[x] = s;\n}\nint dfs2(int x, int p) {\n  int s = 0;\n  vector<P> vs;\n  for (int t : G[x]) {\n    if (t == p) continue;\n    vs.pb(P(DD[t]+1, t));\n  }\n  if (p != -1) {\n    int m = 0;\n    if (Ds[p] == x) m = D2[p];\n    else m = D1[p];\n    vs.pb(P(m+1, p));\n  }\n  assert(!vs.empty());\n  sort(all(vs), greater<P>());\n  D1[x] = vs[0]._1;\n  Ds[x] = vs[0]._2;\n  if (vs.size() > 1) D2[x] = vs[1]._1;\n  for (int t : G[x]) {\n    if (t == p) continue;\n    dfs2(t, x);\n  }\n  return D1[x];\n}\n\nsigned main() {\n  ios::sync_with_stdio(false); cin.tie(0);\n  cin >> N;\n  rep(i, N-1) {\n    int u, v;\n    cin >> u >> v;\n    u--, v--;\n    G[u].pb(v);\n    G[v].pb(u);\n  }\n  dfs1(0, -1);\n  dfs2(0, -1);\n  rep(i, N) cout << 2*(N-1) - D1[i] << \"\\n\";\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nint n,dis[100005],ans[100009];\nvector<P>v[100005];\n\nvoid dfs1(int idx,int pre){\n  for(int i=0;i<v[idx].size();i++){\n    int next=v[idx][i].first;\n    int cost=v[idx][i].second;\n    if(next==pre)continue;\n    dfs1(next,idx);\n    dis[idx]=max(dis[idx],dis[next]+cost);\n  }\n}\n\nint dfs2(int idx,int d_pre,int pre){\n  vector<P>child;\n  child.push_back(P(0,-1));\n  for(int i=0;i<v[idx].size();i++){\n    int next=v[idx][i].first;\n    int cost=v[idx][i].second;\n    if(next==pre)child.push_back(P(d_pre+cost,next));\n    else child.push_back(P(dis[next]+cost,next));\n  }\n  sort(child.begin(),child.end(),greater<P>());\n  int res=child[0].first+child[1].first;\n  ans[idx]=max(child[0].first,child[1].first);\n  for(int i=0;i<v[idx].size();i++){\n    int next=v[idx][i].first;\n    int cost=v[idx][i].second;\n    if(next==pre)continue;\n    res=max(res,dfs2(next,child[next==child[0].second].first,idx));\n  }\n  return res;\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n-1;i++){\n    int a,b,w;\n    cin>>a>>b;a--;b--;\n    v[a].push_back(P(b,1));\n    v[b].push_back(P(a,1));\n  }\n  dfs1(n/2,-1);\n  dfs2(n/2,0,-1);\n  for(int i=0;i<n;i++)cout<<(n-1)*2-ans[i]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nvector<int> v[101010];\npriority_queue<int> ret[101010];\nint ans[101010];\n\nint dfs(int x,int p){\n    ret[x].push(0);\n    for(auto to:v[x]){\n        if(to==p)continue;\n        ret[x].push(dfs(to,x));\n    }\n    return ret[x].top()+1;\n}\n\nvoid dfs2(int x,int p){\n    int res=ret[x].top();\n    if(p!=-1){\n        int y=ret[p].top();\n        ret[p].pop();\n        if(y!=res+1)ret[x].push(y+1);\n        else ret[x].push(ret[p].top()+1);\n        ret[p].push(y);\n    }\n    for(auto to:v[x]){\n        if(to==p)continue;\n        dfs2(to,x);\n    }\n    ans[x]=ret[x].top();\n}\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n-1){\n        int a,b;\n        cin>>a>>b;\n        --a;--b;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    dfs(0,-1);\n    dfs2(0,-1);\n    rep(i,n)cout<<2*(n-1)-ans[i]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define rep1(i,n) for(int i=1;i<=n;++i)\nusing namespace std;\ntemplate<class T>bool chmax(T &a, const T &b) { if(a < b){ a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if(a > b){ a = b; return 1; } return 0; }\ntypedef long long ll;\nll M;\ntemplate <typename X>\nstruct Edge{\n  int from;\n  int to;\n  X cost;\n  int idx;\n  \n  Edge() = default;\n\n  Edge(int from, int to, X cost, int idx) : from(from), to(to), cost(cost), idx(idx) {}\n};\n\ntemplate <typename X>\nstruct Node{\n  int idx;\n  int par;\n  X depth;\n  vector<Edge<X>> edge;\n  map<int,int> to_index;\n  vector<X> dp;\n  vector<X> lsum, rsum;\n  int cnt;\n  vector<X> dp2;\n  vector<X> lsum2, rsum2;\n  int cnt2;  \n  \n  Node() = default;\n\n  explicit Node(int idx) : idx(idx) {\n    cnt = 0;\n  }\n\n  void Init_DP() {\n    dp.resize(edge.size(), -1);\n    dp2.resize(edge.size(), -1);    \n  }\n  \n  void Make_to_index() {\n    rep(i,edge.size()) {\n      to_index[edge[i].to] = edge[i].idx;\n    }\n    to_index[idx] = -1;\n    Init_DP();\n  }\n\n  void Make_Sum(X id) {\n    int n = dp.size();\n    lsum.resize(n+1, id);\n    rsum.resize(n+1, id);\n    rep(i,n) {\n      lsum[i+1] = max(lsum[i], dp[i] + 1);\n    }\n    for (int i = n; i > 0; --i) {\n      rsum[i-1] = max(rsum[i], dp[i-1] + 1);\n    }\n  }\n\n  bool is_full_dp() {\n    return cnt == dp.size();\n  }\n\n\n  void Make_Sum2(X id) {\n    int n = dp.size();\n    lsum2.resize(n+1, id);\n    rsum2.resize(n+1, id);\n    rep(i,n) {\n      lsum2[i+1] = lsum2[i] + dp2[i] + 2;\n    }\n    for (int i = n; i > 0; --i) {\n      rsum2[i-1] = rsum2[i] + dp2[i-1] + 2;\n    }\n  }\n\n  bool is_full_dp2() {\n    return cnt2 == dp2.size();\n  }  \n  \n};\n\ntemplate <typename X>\nclass Tree{\nprivate:\n  int n; // number of node\n  vector<Node<X>> node;\n\npublic:\n  Tree() = default;\n\n  Tree(int n) : n(n) {\n    rep(i,n) node.emplace_back(i);\n  }\n\n  Tree(int n, vector<int> a, vector<int> b) : n(n) {\n    rep(i,n) node.emplace_back(i);\n    rep(i,n-1) {\n      add_edge(a[i], b[i]);\n      add_edge(b[i], a[i]);  // indirected edge\n    }\n  }\n\n  Tree(int n, vector<int> a, vector<int> b, vector<X> c) : n(n) {\n    rep(i,n) node.emplace_back(i);\n    rep(i,n-1) {\n      add_edge(a[i], b[i], c[i]);\n      add_edge(b[i], a[i], c[i]);  // indirected edge\n    }\n  }  \n\n  void add_edge(int from, int to, X cost = 1) {\n    node[from].edge.emplace_back(from, to, cost, node[from].edge.size());\n  }\n\n  void DFS_Init(int v, int p, int d) {\n    node[v].par = p;\n    node[v].depth = d;\n    for(auto next: node[v].edge) {\n      int w = next.to;\n      X cost = next.cost;\n      if(w == p) continue;\n      DFS_Init(w, v, d + cost);\n    }\n  }\n\n  void Init_Node(int root) {\n    DFS_Init(root, -1, 0);\n    rep(i,n) node[i].Make_to_index();\n  }\n  \n  X ReRoot(int p, int v) {\n    int index = node[p].to_index[v];\n    if(index != -1) if(node[p].dp[index] >= 0) return node[p].dp[index];\n    if(node[v].is_full_dp()) {\n      if(node[v].cnt == 0) return 0;\n      int index2 = node[v].to_index[p];\n      if(index2 == -1) {\n\treturn node[v].rsum[0];\n      }\n      else {\n\tnode[p].dp[index] = max(node[v].lsum[index2], node[v].rsum[index2+1]);\n\tnode[p].cnt++;\n\tif(node[p].is_full_dp()) {\n\t  node[p].Make_Sum(0);\n\t}\n\treturn node[p].dp[index];\n      }\n    }\n    X res = 0;\n    for(auto next: node[v].edge) {\n      int w = next.to;\n      if(w == p) continue;\n      res = max(res, (ReRoot(v, w) + 1));\n    }\n    \n    if(index == -1) return res;\n    node[p].dp[index] = res;\n    node[p].cnt++;\n    if(node[p].is_full_dp()) {\n      node[p].Make_Sum(0);\n    }\n    return res;\n  }\n\n  X ReRoot2(int p, int v) {\n    int index = node[p].to_index[v];\n    if(index != -1) if(node[p].dp2[index] >= 0) return node[p].dp2[index];\n    if(node[v].is_full_dp2()) {\n      if(node[v].cnt2 == 0) return 0;\n      int index2 = node[v].to_index[p];\n      if(index2 == -1) {\n\treturn node[v].rsum2[0];\n      }\n      else {\n\tnode[p].dp2[index] = node[v].lsum2[index2] + node[v].rsum2[index2+1];\n\tnode[p].cnt2++;\n\tif(node[p].is_full_dp2()) {\n\t  node[p].Make_Sum2(0);\n\t}\n\treturn node[p].dp2[index];\n      }\n    }\n    X res = 0;\n    for(auto next: node[v].edge) {\n      int w = next.to;\n      if(w == p) continue;\n      res = res + ReRoot2(v, w) + 2;\n    }\n    \n    if(index == -1) return res;\n    node[p].dp2[index] = res;\n    node[p].cnt2++;\n    if(node[p].is_full_dp2()) {\n      node[p].Make_Sum2(0);\n    }\n    return res;\n  }\n  \n};\n\nint main()\n{\n  int n;cin >> n;\n  vector<int> a(n-1), b(n-1);\n  rep(i,n-1) {\n    cin >> a[i] >> b[i];\n    a[i]--; b[i]--;\n  }\n\n  Tree<int> tr(n, a, b);\n  tr.Init_Node(0);\n  //  rep(i,n) cout << tr.ReRoot2(i, i) << \"\\n\";  \n  rep(i,n) cout << tr.ReRoot2(i, i) - tr.ReRoot(i, i) << \"\\n\";\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include <bits/stdc++.h>\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n//#include \"boost/multiprecision/cpp_int.hpp\"\n//typedef boost::multiprecision::cpp_int ll;\ntypedef long double dd;\n#define i_7 (ll)(1E9+7)\n//#define i_7 998244353\n#define i_5 i_7-2\nll mod(ll a){\n    ll c=a%i_7;\n    if(c>=0)return c;\n    return c+i_7;\n}\ntypedef pair<ll,ll> l_l;\ntypedef pair<dd,dd> d_d;\nll inf=(ll)1E16;\n#define rep(i,l,r) for(ll i=l;i<=r;i++)\n#define pb push_back\nll max(ll a,ll b){if(a<b)return b;else return a;}\nll min(ll a,ll b){if(a>b)return b;else return a;}\nvoid Max(ll &pos,ll val){pos=max(pos,val);}//Max(dp[n],dp[n-1]);\nvoid Min(ll &pos,ll val){pos=min(pos,val);}\nvoid Add(ll &pos,ll val){pos=mod(pos+val);}\ndd EPS=1E-9;\n#define fastio ios::sync_with_stdio(false); cin.tie(0); cout.tie(0);\n#define fi first\n#define se second\n///////////////////////////\n\n#define N 100005\nvector<ll>v[N];\nll dis[N];\nll dfs(ll id ,ll par){\n    for(auto x:v[id]){\n        if(x==par)continue;\n        Max(dis[id],dfs(x,id)+1);\n    }\n    return dis[id];\n}\nll dis2[N];\nvoid dfs2(ll id,ll d_par,ll par){\n    for(auto x:v[id]){\n        if(x==par)Max(dis2[id],d_par);\n        else Max(dis2[id],dis[x]+1);\n    }\n    vector<l_l>come;\n    for(auto x:v[id]){\n        if(x==par){\n            come.pb({d_par,-1});\n        }else{\n            come.pb({dis[x]+1,x});\n        }\n    }\n    come.pb({0,-1});\n    sort(come.rbegin(),come.rend());\n    for(auto x:v[id]){\n        if(x==par)continue;\n        if(come[0].se==x){\n            dfs2(x,come[1].fi+1,id);\n        }else{\n            dfs2(x,come[0].fi+1,id);\n        }\n    }\n}\nint main(){fastio\n    ll n;cin>>n;\n    rep(i,1,n-1){\n        ll a,b;cin>>a>>b;\n        v[a].pb(b);v[b].pb(a);\n    }\n    dfs(1,-1);\n    //rep(i,1,n)cout<<dis[i]<<\" \";cout<<endl;\n    dfs2(1,0,-1);\n    rep(i,1,n)cout<<2*(n-1)-dis2[i]<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// header {{{\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define CPP_STR(x) CPP_STR_I(x)\n#define CPP_CAT(x,y) CPP_CAT_I(x,y)\n#define CPP_STR_I(args...) #args\n#define CPP_CAT_I(x,y) x ## y\n\n#define SFINAE(pred...) std::enable_if_t<(pred), std::nullptr_t> = nullptr\n\n#define ASSERT(expr...) assert((expr))\n\nusing i8  = int8_t;\nusing u8  = uint8_t;\nusing i16 = int16_t;\nusing u16 = uint16_t;\nusing i32 = int32_t;\nusing u32 = uint32_t;\nusing i64 = int64_t;\nusing u64 = uint64_t;\n\nusing f32 = float;\nusing f64 = double;\nusing f80 = __float80;\n// }}}\n\nconstexpr i64 INF  = INT64_C(1'010'000'000'000'000'017);\nconstexpr f64 FINF = 1e100;\n\nconstexpr i64 MOD = INT64_C(1'000'000'007);\n//constexpr i64 MOD = INT64_C(998'244'353);\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// util {{{\n#define FOR(i, start, end) for(i64 i = (start), CPP_CAT(i,xxxx_end)=(end); i < CPP_CAT(i,xxxx_end); ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(std::begin(cccc), std::end(cccc), ## __VA_ARGS__); })(c))\n\n#define LIFT(f) ([](auto&&... args) -> decltype(auto) { return (f)(std::forward<decltype(args)>(args)...); })\n\ntemplate<typename C>\nconstexpr i64 SIZE(const C& c) noexcept { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\nconstexpr i64 SIZE(const T (&)[N]) noexcept { return static_cast<i64>(N); }\n\ntemplate<typename T, SFINAE(is_signed<T>::value)>\nconstexpr T ABS(T x) noexcept {\n    return x < 0 ? -x : x;\n}\n\ntemplate<typename T>\nconstexpr i64 CMP(T x, T y) noexcept { return (y<x) - (x<y); }\n\ntemplate<typename T>\nconstexpr i64 SGN(T x) noexcept { return CMP(x,T(0)); }\n\ntemplate<typename T, typename U, typename Comp=less<>>\nconstexpr bool chmax(T& xmax, const U& x, Comp comp={}) noexcept {\n    if(comp(xmax, x)) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U, typename Comp=less<>>\nconstexpr bool chmin(T& xmin, const U& x, Comp comp={}) noexcept {\n    if(comp(x, xmin)) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc&& bf, UnaryFunc&& uf) {\n    return [bf=forward<BinaryFunc>(bf),uf=forward<UnaryFunc>(uf)](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename F>\nauto LT_ON(F&& f) {\n    return ON(less<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto GT_ON(F&& f) {\n    return ON(greater<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto EQ_ON(F&& f) {\n    return ON(equal_to<>{}, forward<F>(f));\n}\n\ntemplate<typename F>\nauto NE_ON(F&& f) {\n    return ON(not_equal_to<>{}, forward<F>(f));\n}\n\n// tuple {{{\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) == I)>\nvoid tuple_enumerate(tuple<TS...>&, F&&) {}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) > I)>\nvoid tuple_enumerate(tuple<TS...>& t, F&& f) {\n    f(I, get<I>(t));\n    tuple_enumerate<I+1>(t, forward<F>(f));\n}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) == I)>\nvoid tuple_enumerate(const tuple<TS...>&, F&&) {}\n\ntemplate<i64 I=0, typename F, typename... TS, SFINAE(sizeof...(TS) > I)>\nvoid tuple_enumerate(const tuple<TS...>& t, F&& f) {\n    f(I, get<I>(t));\n    tuple_enumerate<I+1>(t, forward<F>(f));\n}\n// }}}\n\n// container {{{\ntemplate<typename T> struct is_container : false_type {};\ntemplate<typename T, size_t N> struct is_container<array<T,N>> : true_type {};\ntemplate<typename... Args> struct is_container<vector<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<deque<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<list<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<forward_list<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<set<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<multiset<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_set<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_multiset<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<map<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<multimap<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_map<Args...>> : true_type {};\ntemplate<typename... Args> struct is_container<unordered_multimap<Args...>> : true_type {};\n\ntemplate<typename T, typename Enable=void>\nstruct ProconHash {\n    size_t operator()(const T& x) const noexcept {\n        return hash<T>{}(x);\n    }\n};\n\ntemplate<typename T>\nsize_t procon_hash_value(const T& x) noexcept {\n    return ProconHash<T>{}(x);\n}\n\nsize_t procon_hash_combine(size_t h1, size_t h2) noexcept {\n    constexpr size_t M = UINT64_C(0xc6a4a7935bd1e995);\n    constexpr int    R = 47;\n\n    h2 *= M;\n    h2 ^= h2 >> R;\n    h2 *= M;\n\n    h1 ^= h2;\n    h1 *= M;\n\n    h1 += 0xe6546b64;\n\n    return h1;\n}\n\ntemplate<typename T1, typename T2>\nstruct ProconHash<pair<T1,T2>> {\n    size_t operator()(const pair<T1,T2>& p) const noexcept {\n        size_t h1 = procon_hash_value(p.first);\n        size_t h2 = procon_hash_value(p.second);\n        return procon_hash_combine(h1, h2);\n    }\n};\n\ntemplate<typename... TS>\nstruct ProconHash<tuple<TS...>> {\n    size_t operator()(const tuple<TS...>& t) const noexcept {\n        size_t h = 0;\n        tuple_enumerate(t, [&h](i64, const auto& e) {\n            h = procon_hash_combine(h, procon_hash_value(e));\n        });\n        return h;\n    }\n};\n\ntemplate<typename C>\nstruct ProconHash<C,enable_if_t<is_container<C>::value>> {\n    size_t operator()(const C& c) const noexcept {\n        size_t h = 0;\n        for(const auto& e : c)\n            h = procon_hash_combine(h, procon_hash_value(e));\n        return h;\n    }\n};\n\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nusing HashSet = unordered_set<T,Hash,Eq>;\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nusing HashMap = unordered_map<K,V,Hash,Eq>;\ntemplate<typename T, typename Hash=ProconHash<T>, typename Eq=equal_to<T>>\nusing HashMultiset = unordered_multiset<T,Hash,Eq>;\ntemplate<typename K, typename V, typename Hash=ProconHash<K>, typename Eq=equal_to<K>>\nusing HashMultimap = unordered_multimap<K,V,Hash,Eq>;\n\ntemplate<typename T>\nauto vec_make(i64 n, T x) {\n    return vector<T>(n, x);\n}\n\ntemplate<typename T, typename... Args, SFINAE(sizeof...(Args) >= 2)>\nauto vec_make(i64 n, Args... args) {\n    auto inner = vec_make<T>(args...);\n    return vector<decltype(inner)>(n, inner);\n}\n\ntemplate<typename T>\nauto vec_reserve(i64 cap) {\n    vector<T> res;\n    res.reserve(cap);\n    return res;\n}\n\ntemplate<typename T=i64>\nauto vec_iota(i64 n, T init={}) {\n    vector<i64> res(n);\n    ALL(iota, res, init);\n    return res;\n}\n\ntemplate<typename T, typename Comp, typename Cont=vector<T>>\nauto priority_queue_make(const Comp& comp, Cont&& cont={}) {\n    return priority_queue<T,remove_reference_t<Cont>,Comp>(comp, forward<Cont>(cont));\n}\n\ntemplate<typename T, typename Comp>\nauto priority_queue_reserve(const Comp& comp, i64 cap) {\n    return priority_queue<T,vector<T>,Comp>(comp, vec_reserve<T>(cap));\n}\n\ntemplate<typename T, size_t N, size_t... NS>\nstruct ArrayType {\n    using type = array<typename ArrayType<T,NS...>::type,N>;\n};\n\ntemplate<typename T, size_t N>\nstruct ArrayType<T,N> {\n    using type = array<T,N>;\n};\n\ntemplate<typename T, size_t... NS>\nusing Array = typename ArrayType<T,NS...>::type;\n\ntemplate<typename T, size_t N>\nT& array_at(Array<T,N>& ary, i64 i) {\n    return ary[i];\n}\n\ntemplate<typename T, size_t N, size_t... NS, typename... Args>\nT& array_at(Array<T,N,NS...>& ary, i64 i, Args... args) {\n    return array_at<T,NS...>(ary[i], args...);\n}\n\ntemplate<typename T, size_t N>\nconst T& array_at(const Array<T,N>& ary, i64 i) {\n    return ary[i];\n}\n\ntemplate<typename T, size_t N, size_t... NS, typename... Args>\nconst T& array_at(const Array<T,N,NS...>& ary, i64 i, Args... args) {\n    return array_at<T,NS...>(ary[i], args...);\n}\n\ntemplate<typename T, typename C>\nT POP(stack<T,C>& stk) {\n    T x = stk.top(); stk.pop();\n    return x;\n}\n\ntemplate<typename T, typename C>\nT POP(queue<T,C>& que) {\n    T x = que.front(); que.pop();\n    return x;\n}\n\ntemplate<typename T, typename C, typename Comp>\nT POP(priority_queue<T,C,Comp>& que) {\n    T x = que.top(); que.pop();\n    return x;\n}\n// }}}\n\n// fixpoint {{{\ntemplate<typename F>\nclass FixPoint {\npublic:\n    explicit constexpr FixPoint(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<typename F>\nconstexpr decltype(auto) FIX(F&& f) {\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate<typename F, size_t... NS>\nclass FixPointMemo {\npublic:\n    explicit FixPointMemo(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    decltype(auto) operator()(Args... args) const {\n        using R = decltype(f_(*this,args...));\n        static Array<bool,NS...> done {};\n        static Array<R,NS...>    memo;\n\n        if(!array_at<bool,NS...>(done,args...)) {\n            array_at<R,NS...>(memo,args...) = f_(*this,args...);\n            array_at<bool,NS...>(done,args...) = true;\n        }\n        return array_at<R,NS...>(memo,args...);\n    }\n\nprivate:\n    F f_;\n};\n\ntemplate<size_t... NS, typename F>\ndecltype(auto) FIXMEMO(F&& f) {\n    return FixPointMemo<F,NS...>(forward<F>(f));\n}\n// }}}\n\n// math {{{\n/*constexpr*/ i64 GCD(i64 a, i64 b) noexcept {\n    /*constexpr*/ auto f_gcd = FIX([](auto&& self, i64 aa, i64 bb) {\n        if(bb == 0) return aa;\n        return self(bb, aa%bb);\n    });\n    return f_gcd(ABS(a), ABS(b));\n}\n\n/*constexpr*/ i64 LCM(i64 a, i64 b) noexcept {\n    ASSERT(a != 0 && b != 0);\n    /*constexpr*/ auto f_gcd = FIX([](auto&& self, i64 aa, i64 bb) {\n        if(bb == 0) return aa;\n        return self(bb, aa%bb);\n    });\n    a = ABS(a);\n    b = ABS(b);\n    return a / f_gcd(a,b) * b;\n}\n\n/*constexpr*/ tuple<i64,i64,i64> EXTGCD(i64 a, i64 b) noexcept {\n    /*constexpr*/ auto impl = FIX([](auto&& self, i64 aa, i64 bb) -> tuple<i64,i64,i64> {\n        if(bb == 0) return make_tuple(aa, 1, 0);\n        i64 g,x,y; tie(g,x,y) = self(bb, aa%bb);\n        return make_tuple(g, y, x-(aa/bb)*y);\n    });\n    i64 g,x,y; tie(g,x,y) = impl(ABS(a), ABS(b));\n    x *= SGN(a);\n    y *= SGN(b);\n    return make_tuple(g, x, y);\n}\n// }}}\n\n// string {{{\nauto str_reserve(i64 cap) {\n    string res;\n    res.reserve(cap);\n    return res;\n}\n// }}}\n\n// input {{{\ntemplate<typename T, typename Enable=void>\nstruct Scan {\n    static T scan(istream& in) {\n        T res;\n        in >> res;\n        return res;\n    }\n};\n\ntemplate<typename T, typename Enable=void>\nstruct Scan1;\n\ntemplate<typename T>\nstruct Scan1<T,enable_if_t<is_integral<T>::value && !is_same<T,bool>::value>> {\n    static T scan1(istream& in) {\n        return Scan<T>::scan(in) - 1;\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Scan<pair<T1,T2>> {\n    static pair<T1,T2> scan(istream& in) {\n        T1 x = Scan<T1>::scan(in);\n        T2 y = Scan<T2>::scan(in);\n        return {x,y};\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Scan1<pair<T1,T2>> {\n    static pair<T1,T2> scan1(istream& in) {\n        T1 x = Scan1<T1>::scan1(in);\n        T2 y = Scan1<T2>::scan1(in);\n        return {x,y};\n    }\n};\n\ntemplate<typename... TS, i64 I, SFINAE(sizeof...(TS) == I)>\ntuple<> tuple_scan_impl(istream&) {\n    return make_tuple();\n}\n\ntemplate<typename... TS, i64 I, SFINAE(sizeof...(TS) > I)>\ntuple<> tuple_scan_impl(istream& in) {\n    using T = tuple_element_t<I,tuple<TS...>>;\n    auto head = make_tuple(Scan<T>::scan(in));\n    return tuple_cat(head, tuple_scan_impl<I+1>(in));\n}\n\ntemplate<typename... TS>\nstruct Scan<tuple<TS...>> {\n    static tuple<TS...> scan(istream& in) {\n        return tuple_scan_impl<TS...,0>(in);\n    }\n};\n\ntemplate<typename... TS, i64 I, SFINAE(sizeof...(TS) == I)>\ntuple<> tuple_scan1_impl(istream&) {\n    return make_tuple();\n}\n\ntemplate<typename... TS, i64 I, SFINAE(sizeof...(TS) > I)>\ntuple<> tuple_scan1_impl(istream& in) {\n    using T = tuple_element_t<I,tuple<TS...>>;\n    auto head = make_tuple(Scan1<T>::scan1(in));\n    return tuple_cat(head, tuple_scan1_impl<I+1>(in));\n}\n\ntemplate<typename... TS>\nstruct Scan1<tuple<TS...>> {\n    static tuple<TS...> scan1(istream& in) {\n        return tuple_scan1_impl<TS...,0>(in);\n    }\n};\n\ntemplate<typename T=i64>\nT RD() {\n    return Scan<T>::scan(cin);\n}\n\ntemplate<typename T=i64>\nT RD1() {\n    return Scan1<T>::scan1(cin);\n}\n\ntemplate<typename T=i64>\nauto RD_VEC(i64 n) {\n    auto res = vec_reserve<T>(n);\n    REP(_, n) {\n        res.emplace_back(RD<T>());\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD1_VEC(i64 n) {\n    auto res = vec_reserve<T>(n);\n    REP(_, n) {\n        res.emplace_back(RD1<T>());\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD_VEC2(i64 h, i64 w) {\n    auto res = vec_reserve<vector<T>>(h);\n    REP(_, h) {\n        res.emplace_back(RD_VEC<T>(w));\n    }\n    return res;\n}\n\ntemplate<typename T=i64>\nauto RD1_VEC2(i64 h, i64 w) {\n    auto res = vec_reserve<vector<T>>(h);\n    REP(_, h) {\n        res.emplace_back(RD1_VEC<T>(w));\n    }\n    return res;\n}\n// }}}\n\n// output {{{\ntemplate<typename T, typename Enable=void>\nstruct Fmt {\n    static void fmt(ostream& out, const T& x) { out << x; }\n};\n\ntemplate<typename T>\nvoid fmt_write(ostream& out, const T& x) {\n    Fmt<T>::fmt(out, x);\n}\n\ntemplate<typename... TS>\nstruct Fmt<tuple<TS...>> {\n    static void fmt(ostream& out, const tuple<TS...>& t) {\n        tuple_enumerate(t, [&out](i64 i, const auto& e) {\n            if(i != 0) out << ' ';\n            fmt_write(out, e);\n        });\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Fmt<pair<T1,T2>> {\n    static void fmt(ostream& out, const pair<T1,T2>& p) {\n        return fmt_write(out, make_tuple(p.first,p.second));\n    }\n};\n\ntemplate<typename C>\nstruct Fmt<C,enable_if_t<is_container<C>::value>> {\n    static void fmt(ostream& out, const C& c) {\n        for(auto it = begin(c); it != end(c); ++it) {\n            if(it != begin(c)) out << ' ';\n            fmt_write(out, *it);\n        }\n    }\n};\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS&... args) {\n    fmt_write(cout, x);\n    if(sizeof...(args) > 0) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS&... args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n// }}}\n\n// debug {{{\ntemplate<typename T, typename Enable=void>\nstruct Dbg {\n    static void dbg(ostream& out, const T& x) { out << x; }\n};\n\ntemplate<typename T>\nvoid dbg_write(ostream& out, const T& x) {\n    Dbg<T>::dbg(out, x);\n}\n\ntemplate<>\nstruct Dbg<i64> {\n    static void dbg(ostream& out, i64 x) {\n        if(x == INF)\n            out << \"INF\";\n        else if(x == -INF)\n            out << \"-INF\";\n        else\n            out << x;\n    }\n};\n\ntemplate<>\nstruct Dbg<f64> {\n    static void dbg(ostream& out, f64 x) {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"\n        if(x == FINF)\n            out << \"FINF\";\n        else if(x == -FINF)\n            out << \"-FINF\";\n        else\n            out << x;\n#pragma GCC diagnostic pop\n    }\n};\n\ntemplate<typename T, size_t N>\nstruct Dbg<T[N]> {\n    static void dbg(ostream& out, const T (&ary)[N]) {\n        out << \"[\";\n        REP(i, N) {\n            if(i != 0) out << \",\";\n            dbg_write(out, ary[i]);\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<size_t N>\nstruct Dbg<char[N]> {\n    static void dbg(ostream& out, const char (&s)[N]) {\n        out << s;\n    }\n};\n\ntemplate<typename... TS>\nstruct Dbg<tuple<TS...>> {\n    static void dbg(ostream& out, const tuple<TS...>& t) {\n        out << \"(\";\n        tuple_enumerate(t, [&out](i64 i, const auto& e) {\n            if(i != 0) out << \",\";\n            dbg_write(out, e);\n        });\n        out << \")\";\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Dbg<pair<T1,T2>> {\n    static void dbg(ostream& out, const pair<T1,T2>& p) {\n        return dbg_write(out, make_tuple(p.first,p.second));\n    }\n};\n\ntemplate<typename C>\nstruct Dbg<C,enable_if_t<is_container<C>::value>> {\n    static void dbg(ostream& out, const C& c) {\n        out << \"[\";\n        for(auto it = begin(c); it != end(c); ++it) {\n            if(it != begin(c)) out << \",\";\n            dbg_write(out, *it);\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T, typename C>\nstruct Dbg<stack<T,C>> {\n    static void dbg(ostream& out, stack<T,C> stk) {\n        out << \"[\";\n        while(!stk.empty()) {\n            dbg_write(out,stk.top()); stk.pop();\n            if(!stk.empty()) out << \",\";\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T, typename C>\nstruct Dbg<queue<T,C>> {\n    static void dbg(ostream& out, queue<T,C> que) {\n        out << \"[\";\n        while(!que.empty()) {\n            dbg_write(out,que.front()); que.pop();\n            if(!que.empty()) out << \",\";\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T, typename C, typename Comp>\nstruct Dbg<priority_queue<T,C,Comp>> {\n    static void dbg(ostream& out, priority_queue<T,C,Comp> que) {\n        out << \"[\";\n        while(!que.empty()) {\n            dbg_write(out,que.top()); que.pop();\n            if(!que.empty()) out << \",\";\n        }\n        out << \"]\";\n    }\n};\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    dbg_write(cerr, value);\n    cerr << \"\\n\";\n}\n\nvoid DBG_IMPL_HELPER() {}\n\ntemplate<typename T, typename... TS>\nvoid DBG_IMPL_HELPER(const T& x, const TS&... args) {\n    dbg_write(cerr, x);\n    if(sizeof...(args) > 0) {\n        cerr << \",\";\n        DBG_IMPL_HELPER(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid DBG_IMPL(i64 line, const char* expr, const TS&... value) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << \"(\" << expr << \") = (\";\n    DBG_IMPL_HELPER(value...);\n    cerr << \")\\n\";\n}\n\ntemplate<size_t N, typename T, SFINAE(rank<T>::value == 0)>\nvoid DBG_DP_IMPL_HELPER(ostream& out, const T& x, const array<i64,N>&, const array<i64,N>&) {\n    dbg_write(out, x);\n}\n\ntemplate<size_t N, typename T, SFINAE(rank<T>::value > 0)>\nvoid DBG_DP_IMPL_HELPER(ostream& out, const T& x, const array<i64,N>& sizes, const array<i64,N>& offs) {\n    i64 k   = N - rank<T>::value;\n    i64 off = offs[k];\n    i64 siz = sizes[k];\n    if(siz == 0) siz = extent<T>::value - off;\n\n    out << \"[\";\n    FOR(i, off, off+siz) {\n        if(i != off) out << \",\";\n        DBG_DP_IMPL_HELPER(out, x[i], sizes, offs);\n    }\n    out << \"]\";\n}\n\ntemplate<typename T, SFINAE(rank<T>::value > 0)>\nvoid DBG_DP_IMPL(i64 line, const char* expr, const T& dp,\n                 const array<i64,rank<T>::value>& sizes={},\n                 const array<i64,rank<T>::value>& offs={})\n{\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    DBG_DP_IMPL_HELPER<rank<T>::value>(cerr, dp, sizes, offs);\n    cerr << \"\\n\";\n}\n\ntemplate<typename T>\nvoid DBG_GRID_IMPL(i64 line, const char* expr, const vector<T>& grid) {\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \":\\n\";\n    for(const auto& row : grid) {\n        dbg_write(cerr, row);\n        cerr << \"\\n\";\n    }\n    cerr << \"\\n\";\n}\n\n#ifdef PROCON_LOCAL\n    #define DBG(args...) DBG_IMPL(__LINE__, CPP_STR_I(args), args)\n    #define DBG_DP(args...) DBG_DP_IMPL(__LINE__, CPP_STR_I(args), args)\n    #define DBG_GRID(args...) DBG_GRID_IMPL(__LINE__, CPP_STR_I(args), args)\n#else\n    #define DBG(args...)\n    #define DBG_DP(args...)\n    #define DBG_GRID(args...)\n#endif\n// }}}\n\n// modint {{{\ntemplate<i64 M>\nstruct ModIntT {\n    static_assert(M >= 2, \"\");\n    i64 v_;  // [0,M)\n\n    ModIntT() : v_(0) {}\n    ModIntT(i64 v) {\n        i64 r = v % M;\n        v_ = r >= 0 ? r : r+M;\n    }\n\n    ModIntT operator-() const {\n        return ModIntT(-v_);\n    }\n    ModIntT& operator+=(ModIntT rhs) {\n        v_ += rhs.v_;\n        v_ %= M;\n        return *this;\n    }\n    ModIntT& operator-=(ModIntT rhs) {\n        v_ += M;\n        v_ -= rhs.v_;\n        v_ %= M;\n        return *this;\n    }\n    ModIntT& operator*=(ModIntT rhs) {\n        v_ *= rhs.v_;\n        v_ %= M;\n        return *this;\n    }\n\n    ModIntT& operator++() {\n        return *this += 1;\n    }\n    ModIntT& operator--() {\n        return *this -= 1;\n    }\n    ModIntT operator++(int) {\n        return exchange(*this, *this+1);\n    }\n    ModIntT operator--(int) {\n        return exchange(*this, *this-1);\n    }\n\n    explicit operator i64() const { return v_; }\n\n    ModIntT inv() const {\n        i64 g,x; tie(g,x,ignore) = EXTGCD(v_, M);\n        ASSERT(g == 1);\n        return ModIntT(x);\n    }\n};\n\ntemplate<i64 M>\nModIntT<M> operator+(ModIntT<M> lhs, ModIntT<M> rhs) { return ModIntT<M>(lhs) += rhs; }\ntemplate<i64 M>\nModIntT<M> operator+(ModIntT<M> lhs, i64 rhs) { return ModIntT<M>(lhs) += rhs; }\ntemplate<i64 M>\nModIntT<M> operator+(i64 lhs, ModIntT<M> rhs) { return ModIntT<M>(rhs) += lhs; }\ntemplate<i64 M>\nModIntT<M> operator-(ModIntT<M> lhs, ModIntT<M> rhs) { return ModIntT<M>(lhs) -= rhs; }\ntemplate<i64 M>\nModIntT<M> operator-(ModIntT<M> lhs, i64 rhs) { return ModIntT<M>(lhs) -= rhs; }\ntemplate<i64 M>\nModIntT<M> operator-(i64 lhs, ModIntT<M> rhs) { return ModIntT<M>(rhs) -= lhs; }\ntemplate<i64 M>\nModIntT<M> operator*(ModIntT<M> lhs, ModIntT<M> rhs) { return ModIntT<M>(lhs) *= rhs; }\ntemplate<i64 M>\nModIntT<M> operator*(ModIntT<M> lhs, i64 rhs) { return ModIntT<M>(lhs) *= rhs; }\ntemplate<i64 M>\nModIntT<M> operator*(i64 lhs, ModIntT<M> rhs) { return ModIntT<M>(rhs) *= lhs; }\n\ntemplate<i64 M>\nbool operator==(ModIntT<M> lhs, ModIntT<M> rhs) { return lhs.v_ == rhs.v_; }\ntemplate<i64 M>\nbool operator==(ModIntT<M> lhs, i64 rhs) { return lhs == ModIntT<M>(rhs); }\ntemplate<i64 M>\nbool operator==(i64 lhs, ModIntT<M> rhs) { return ModIntT<M>(lhs) == rhs; }\ntemplate<i64 M>\nbool operator!=(ModIntT<M> lhs, ModIntT<M> rhs) { return !(lhs == rhs); }\ntemplate<i64 M>\nbool operator!=(ModIntT<M> lhs, i64 rhs) { return !(lhs == rhs); }\ntemplate<i64 M>\nbool operator!=(i64 lhs, ModIntT<M> rhs) { return !(lhs == rhs); }\n\ntemplate<i64 M>\nstruct Scan<ModIntT<M>> {\n    static ModIntT<M> scan(istream& in) {\n        return Scan<i64>::scan(in);\n    }\n};\n\ntemplate<i64 M>\nstruct Fmt<ModIntT<M>> {\n    static void fmt(ostream& out, ModIntT<M> x) {\n        fmt_write(out, x.v_);\n    }\n};\n\ntemplate<i64 M>\nstruct Dbg<ModIntT<M>> {\n    static void dbg(ostream& out, ModIntT<M> x) {\n        dbg_write(out, x.v_);\n    }\n};\n\nusing ModInt = ModIntT<MOD>;\n// }}}\n// }}}\n\n// init {{{\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cin.exceptions(ios::failbit | ios::badbit);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(2);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n//--------------------------------------------------------------------\n\nvoid solve() {\n    i64 N = RD();\n\n    vector<vector<i64>> G(N);\n    REP(_, N-1) {\n        i64 a = RD1();\n        i64 b = RD1();\n        G[a].emplace_back(b);\n        G[b].emplace_back(a);\n    }\n    DBG(G);\n\n    vector<i64> dist(N);\n    auto dfs1 = FIX([&G,&dist](auto&& self, i64 v, i64 parent) -> void {\n        dist[v] = 0;\n        for(i64 to : G[v]) {\n            if(to == parent) continue;\n            self(to, v);\n            chmax(dist[v], 1+dist[to]);\n        }\n    });\n    dfs1(0, -1);\n    DBG(dist);\n\n    vector<i64> ans(N);\n    auto dfs2 = FIX([N,&G,&dist,&ans](auto&& self, i64 v, i64 parent, i64 d_par) -> void {\n        auto d_child = vec_reserve<pair<i64,i64>>(SIZE(G[v])+1);\n        d_child.emplace_back(-1, 0);\n        for(i64 to : G[v])\n            d_child.emplace_back(to, 1 + (to == parent ? d_par : dist[to]));\n        ALL(sort, d_child, GT_ON(LIFT(get<1>)));\n\n        ans[v] = 2*(N-1) - d_child[0].second;\n\n        for(i64 to : G[v]) {\n            if(to == parent) continue;\n            i64 di = to == d_child[0].first ? 1 : 0;\n            self(to, v, d_child[di].second);\n        }\n    });\n    dfs2(0, -1, 0);\n\n    REP(v, N) {\n        PRINTLN(ans[v]);\n    }\n}\n\nsigned main() {\n    \n\n    solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nusing Graph = vector< vector<int> >;\n\nint step[100010], ans[100010];\nvoid dfs(Graph &G, int cur, int par=-1) {\n    vector<int> children;\n    for(auto to : G[cur]) {\n        if(to == par) continue;\n        dfs(G, to, cur);\n        step[cur] = max(step[cur], step[to] + 1);\n    }\n}\n\nvoid solve(Graph &G, int cur, int d_par, int par=-1) {\n    vector< pair<int, int> > children;\n\n    for(auto to : G[cur]) {\n        if(to == par) children.push_back(make_pair(d_par + 1, to));\n        else children.push_back(make_pair(step[to] + 1, to));\n    }\n    sort(children.begin(), children.end(), greater< pair<int, int> >());\n\n    ans[cur] = children[0].first;\n    for(auto to : G[cur]) {\n        if(to == par) continue;\n        int nxt_d_par = children[children[0].second == to].first;\n        solve(G, to, nxt_d_par, cur);\n    }\n}\n\nint main() {\n    int N; scanf(\"%d\", &N);\n    Graph G(N);\n    for(int i=0; i<N-1; i++) {\n        int a, b; scanf(\"%d%d\", &a, &b);\n        a--; b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    dfs(G, 0);\n    solve(G, 0, 0);\n    for(int i=0; i<N; i++) {\n        printf(\"%d\\n\", 2 * (N-1) - ans[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for (int (i)=(0);(i)<(int)(n);++(i))\nusing ll = long long;\nusing namespace std;\n\nvector<int> g[101010];\nint dist[101010], ans[101010];\n\nvoid dfs1(int v, int p) {\n    for (int u : g[v]) {\n        if (u == p) continue;\n        dfs1(u, v);\n        dist[v] = max(dist[v], dist[u] + 1);\n    }\n}\n\nvoid dfs2(int v, int d_p, int p) {\n    vector<pair<int, int>> d_c;\n    d_c.emplace_back(0, -1);\n    for (int &u : g[v]) {\n        if (u == p) d_c.emplace_back(d_p + 1, u);\n        else d_c.emplace_back(dist[u] + 1, u);\n    }\n    sort(d_c.rbegin(), d_c.rend());\n    ans[v] = d_c[0].first;\n    for (int &u : g[v]) {\n        if (u == p) continue;\n        dfs2(u, d_c[d_c[0].second == u].first, v);\n    }\n}\n\nint main() {\n    int N;\n    cin >> N;\n    rep(i, N-1) {\n        int a, b;\n        cin >> a >> b;\n        a--; b--;\n        g[a].push_back(b);\n        g[b].push_back(a);\n    }\n    dfs1(0, -1);\n    dfs2(0, 0, -1);\n    rep(i, N) {\n        cout << (N-1)*2 - ans[i] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\n\ntypedef int Data;\ntypedef int SubData;\n\nconst int MN=100000;\n\nvector<int> G[MN];\nData dp[MN];\t\t\t//0-rooted dp[v]=term(merge(dp[u1],dp[u2],...))\nSubData dp_nottermed[MN];\t//0-rooted merge(dp[u1],...)\nData up[MN];\t\t\t//up[v]= 0-rooted??§???v?????????p??¨??????, v->p?????????dp?????? term(merge(up[p],dp[v's bro1],dp[v's bro1],...))\nData DP[MN];\t\t\t//DP[v]: ans for v-rooted tree\nvector<SubData> ls,rs;\t\t//ls/rs[i] = 0-rooted??§??????v???children??????/?????????i???merge????????????(???v??§????????????)\nSubData init=0;\nSubData merge(SubData val,Data v){\n\treturn max(val,v);\n}\nSubData merge2(SubData x,SubData y){\n\treturn max(x,y);\n}\nData term(SubData val){\n\treturn val+1;\n}\nvoid dfs(int v,int p=-1){\n\tSubData val=init;\n\tfor(int u:G[v]) if(u!=p){\n\t\tdfs(u,v);\n\t\tval=merge(val,dp[u]);\n\t}\n\tdp_nottermed[v]=val;\n\tdp[v]=term(val);\n//\tcout<<\"dp[\"<<v<<\"]=\"<<dp[v]<<endl;\n}\nvoid ufs(int v,int p=-1){\t\t//0-rooted??§upward?????¨???????¨????\n\tvector<int> ch;\t//children\n\tfor(int u:G[v]) if(u!=p) ch.pb(u);\n\tint K=ch.size();\n\tls.resize(K+1);\n\trs.resize(K+1);\n\tls[0]=init;\n\trs[0]=init;\n\trep(i,K){\n\t\tls[i+1]=merge(ls[i],dp[ch[i]]);\n\t\trs[i+1]=merge(rs[i],dp[ch[K-1-i]]);\n\t}\n//\tif(p==-1) rep1(i,K) show(ls[i]),show(rs[i]);\n\trep(i,K){\n\t\tint u=ch[i];\n\t\tSubData val=merge2(ls[i],rs[K-1-i]);\n\t\tif(p>=0) val=merge(val,up[v]);\n\t\tup[u]=term(val);\n//\t\tcout<<\"up[\"<<u<<\"]=\"<<up[u]<<endl;\n\t}\n\trep(i,K) ufs(ch[i],v);\n}\nvoid calcDP(int N,int r=0){\n\tdfs(r);\n//\tup[r]=e\t\t\t//Data????????????(???init)???????????§??¢???????????§??????\n\tufs(r);\n\trep(v,N){\n\t\tSubData val=dp_nottermed[v];\n\t\tif(v!=r) val=merge(val,up[v]);\n\t\tDP[v]=term(val);\n\t}\n}\nint main(){\n\tint N;\n\tcin>>N;\n\trep(i,N-1){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tx--,y--;\n\t\tG[x].pb(y);\n\t\tG[y].pb(x);\n\t}\n\tcalcDP(N);\n\trep(i,N) printf(\"%d\\n\",(N-1)*2+1-DP[i]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define REP(i, n) for (ll i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (ll i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define fi first\n#define se second\n#define pb push_back\n#define debug(x) cerr << #x << \": \" << (x) << endl\n#define int long long\nusing namespace std;\nusing II = pair<int, int>;\nusing VII = vector<II>;\nusing VVII = vector<VII>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VVVI = vector<VVI>;\ntemplate <class T = int> inline T in() { T x; cin >> x; return x; }\ntemplate <class T = int> inline bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T = int> inline bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<T>& d) { int n = d.size(); REP (i, n) s << d[i] << \" \"; return s; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<vector<T>>& dd) { for (vector<T> d: dd) s << d << endl; return s; }\n// struct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nconst int MOD = 1e9 + 7;\n\nsigned main() {\n  int N = in();\n  VVI G(N);\n  REP (i, N - 1) {\n    int u, v; cin >> u >> v;\n    u--; v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  VVII dist(N); // {len, v}\n  VI far(N);\n  function<void (int, int)> dfs1 = [&](int v, int prev) {\n    for (int u: G[v]) if (u != prev) {\n      dfs1(u, v);\n      dist[v].push_back({far[u] + 1, u});\n      chmax(far[v], far[u] + 1);\n    }\n  };\n  dfs1(0, -1);\n\n  sort(RALL(dist[0]));\n  function<void (int, int)> dfs2 = [&](int v, int prev) {\n    for (int u: G[v]) if (u != prev) {\n      int tmp;\n      if (dist[v][0].se == u) {\n        tmp = dist[v].size() == 1 ? 0 : dist[v][1].fi;\n      } else {\n        tmp = dist[v][0].fi;\n      }\n      debug(tmp);\n      dist[u].pb({tmp + 1, v});\n      sort(RALL(dist[u]));\n      dfs2(u, v);\n    }\n  };\n  dfs2(0, -1);\n\n  REP (i, N) {\n    cout << 2 * (N - 1) - dist[i][0].fi << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <string>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\nusing namespace std;\n\n#define INF_LL (ll)1e18\n#define INF (int)1e9\n#define REP(i, n) for(int i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\nusing ll = long long;\nusing PII = pair<int, int>;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nclass Union_find{\nprivate:\n\tvector<int> par;\n\tvector<int> rank;\n\tint n;\n\npublic:\n\tUnion_find(int a){\n\t\tn = a;\n\t\tfor(int i = 0;i < n;i++){\n\t\t\tpar.push_back(i);\n\t\t\trank.push_back(0);\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nclass LazySegTree{\nprivate:\n\tint n;\n\tvector<ll> node, lazy;\n\tvector<bool> lazyFlag;\npublic:\n\tLazySegTree(vector<ll> v){\n\t\tint sz = v.size();\n\t\tn = 1; while(n < sz) n *= 2;\n\t\tnode.resize(2*n-1, 0);\n\t\tlazy.resize(2*n-1, 0);\n\t\tlazyFlag.resize(2*n-1, false);\n\t\tREP(i, sz) node[i+n-1] = v[i];\n\t\tfor(int i = n-2;i >= 0;i--) node[i] = node[2*i+1]+node[2*i+2];\n\t}\n\n\tvoid eval(int k, int l, int r){\n\t\tif(lazyFlag[k]){\n\t\t\tnode[k] += lazy[k] * (r-l);\n\t\t\tif(r-l > 1){\n\t\t\t\tlazy[2*k+1] += lazy[k];\n\t\t\t\tlazy[2*k+2] += lazy[k];\n\t\t\t\tlazyFlag[2*k+1] = lazyFlag[2*k+2] = true;\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t\tlazyFlag[k] = false;\n\t\t}\n\t}\n\n\tvoid add(int a, int b, ll x, int k=0, int l=0, int r=-1){\n\t\tif(r < 0) r = n;\n\t\teval(k, l, r);\n\t\tif(b <= l || r <= a) return;\n\n\t\tif(a <= l && r <= b){\n\t\t\tlazy[k] += x;\n\t\t\tlazyFlag[k] = true;\n\t\t\teval(k, l, r);\n\t\t}else{\n\t\t\tadd(a, b, x, k*2+1, l, (l+r)/2);\n\t\t\tadd(a, b, x, k*2+2, (l+r)/2, r);\n\t\t\tnode[k] = node[k*2+1] + node[k*2+2];\n\t\t}\n\t}\n\n\tll query(int a, int b, int k=0, int l=0, int r=-1){\n\t\tif(r < 0) r = n;\n\t\teval(k, l, r);\n\n\t\tif(b <= l || r <= a) return 0;\n\t\tif(a <= l && r <= b) return node[k];\n\n\t\treturn query(a, b, k*2+1, l, (l+r)/2) + query(a, b, k*2+2, (l+r)/2, r);\n\t}\n};\n\nclass Bucket{\nprivate:\n\tint n, bs, bn;\n\tvector<ll> data;\n\tvector<ll> bucket, lazy;\n\tvector<bool> lazyFlag;\npublic:\n\tBucket(vector<ll> v, int sz){\n\t\tdata = v;\n\t\tn = v.size();\n\t\tbs = sz;\n\t\tbn = (n + bs - 1) / bs;\n\t\tdata.resize(bn*bs, INF_LL);\n\t\tbucket.assign(bn, INF_LL);\n\t\tlazy.assign(bn, 0);\n\t\tlazyFlag.assign(bn, 0);\n\t\tREP(i, bn){\n\t\t\tll minx = INF_LL;\n\t\t\tREP(j, bs){\n\t\t\t\tchmin(minx, data[i*bs+j]);\n\t\t\t}\n\t\t\tbucket[i] = minx;\n\t\t}\n\t}\n\n\tvoid eval(int k){\n\t\tif(lazyFlag[k]){\n\t\t\tlazyFlag[k] = false;\n\t\t\tFOR(i, bs*k, bs*(k+1)){\n\t\t\t\tdata[i] = lazy[k];\n\t\t\t}\n\t\t\tlazy[k] = 0;\n\t\t}\n\t}\n\n\tvoid update(int s, int t, int x){\n\t\tREP(k, bn){\n\t\t\tint l = k*bs, r = (k+1)*bs;\n\t\t\tif(r <= s || t <= l) continue;\n\t\t\tif(s <= l && r <= t){\n\t\t\t\tlazyFlag[k] = true;\n\t\t\t\tbucket[k] = x;\n\t\t\t\tlazy[k] = x;\n\t\t\t}else{\n\t\t\t\teval(k);\n\t\t\t\tFOR(i, max(s, l), min(t, r)){\n\t\t\t\t\tdata[i] = x;\n\t\t\t\t}\n\t\t\t\tbucket[k] = INF_LL;\n\t\t\t\tFOR(i, l, r){\n\t\t\t\t\tchmin(bucket[k], data[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll query(int s, int t){\n\t\tll res = INF_LL;\n\t\tREP(k, bn){\n\t\t\tint l = k*bs, r = (k+1)*bs;\n\t\t\tif(r <= s || t <= l) continue;\n\t\t\tif(s <= l && r <= t){\n\t\t\t\tchmin(res, bucket[k]);\n\t\t\t}else{\n\t\t\t\teval(k);\n\t\t\t\tFOR(i, max(s, l), min(t, r)){\n\t\t\t\t\tchmin(res, data[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n};\n\nint N;\nvector<int> G[114514];\nint d[114514] = {};\nint ans[114514] = {};\n\nvoid dfs1(int v, int p){\n\tREP(i, G[v].size()){\n\t\tif(G[v][i] == p) continue;\n\t\tdfs1(G[v][i], v);\n\t\td[v] = max(d[v], d[G[v][i]]+1);\n\t}\n}\n\nvoid dfs2(int v, int p, int dp){\n\tvector<PII> dd;\n\tdd.emplace_back(0, -1);\n\n\tREP(i, G[v].size()){\n\t\tif(G[v][i] == p) dd.emplace_back(dp + 1, p);\n\t\telse dd.emplace_back(d[G[v][i]]+1, G[v][i]);\n\t}\n\tsort(dd.rbegin(), dd.rend());\n\tans[v] = dd[0].first;\n\tREP(i, G[v].size()){\n\t\tif(G[v][i] == p) continue;\n\t\tdfs2(G[v][i], v, dd[G[v][i] == dd[0].second].first);\n\t}\n\n}\n\nint main(void){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\tcin >> N;\n\tREP(i, N-1){\n\t\tint u, v; cin >> u >> v; u--; v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tdfs1(0, -1);\n\tdfs2(0, -1, 0);\n\tREP(i, N){\n\t\tcout << (N-1)*2-ans[i] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define all(x)  x.begin(), x.end()\n#define pii     pair<int, int>\n\nvector<int> g[101010];\nint dist[101010];\nint ans[101010];\n\nvoid dfs1(int v, int prev) {\n        for (auto u : g[v]) if (u != prev) {\n                dfs1(u, v);\n                dist[v] = max(dist[v], dist[u] + 1);\n        }\n}\n\nvoid dfs2(int v, int ma, int prev) {\n        vector<pii> children;\n        children.emplace_back(0, -1);\n        for (auto u : g[v]) {\n                if (u == prev) children.emplace_back(ma + 1, u);\n                else children.emplace_back(dist[u] + 1, u);\n        }\n        sort(all(children), greater<pii>());\n        ans[v] = children[0].first;\n        for (auto u : g[v]) if (u != prev) dfs2(u, children[u == children[0].second ? 1 : 0].first, v);\n}\n\nint main() {\n        int n;\n        cin >> n;\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                cin >> a >> b;\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        dfs1(0, -1);\n        dfs2(0, 0, -1);\n        for (int i = 0; i < n; i ++) cout << (n - 1) * 2 - ans[i] << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nvector<int> v[101010],ret[101010];\nint ans[101010];\n\nint dfs(int x,int p){\n    ret[x].push_back(0);\n    for(auto to:v[x]){\n        if(to==p)continue;\n        ret[x].push_back(dfs(to,x));\n    }\n    sort(ret[x].begin(),ret[x].end(),greater<>());\n    return ret[x][0]+1;\n}\n\nvoid dfs2(int x,int p){\n    int res=ret[x][0];\n    if(x){\n        if(ret[p][0]!=res+1)ret[x].push_back(ret[p][0]+1);\n        else ret[x].push_back(ret[p][1]+1);\n    }\n    for(auto to:v[x]){\n        if(to==p)continue;\n        dfs2(to,x);\n    }\n    sort(ret[x].begin(),ret[x].end(),greater<>());\n    ans[x]=ret[x][0];\n}\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n-1){\n        int a,b;\n        cin>>a>>b;\n        --a;--b;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    dfs(0,-1);\n    dfs2(0,-1);\n    rep(i,n)cout<<2*(n-1)-ans[i]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i, n) for (int i=0;i<(n);i++)\nusing Graph = vector<vector<int>>;\n\nvoid dfs(int v, int pre, int c, const Graph& G, vector<int>& d) {\n    d[v] = c;\n    for (auto nxt : G[v]) {\n        if (nxt == pre) continue;\n        dfs(nxt, v, c + 1, G, d);\n    }\n}\n\nint argmax(const vector<int>& v) {\n    int ma = -1;\n    int arg = -1;\n    rep(i, v.size()) {\n        if (ma < v[i]) {\n            ma = v[i];\n            arg = i;\n        }\n    }\n    assert(arg >= 0 && arg < v.size());\n    return arg;\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int N;\n    cin >> N;\n    Graph G(N);\n    rep(i, N - 1) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n\n    vector<int> d(N);\n    dfs(0, -1, 0, G, d);\n    int v = argmax(d);\n\n    dfs(v, -1, 0, G, d);\n    int u = argmax(d);\n\n    vector<int> d1(N), d2(N);\n    dfs(v, -1, 0, G, d1);\n    dfs(u, -1, 0, G, d2);\n\n    rep(i, N) {\n        cout << 2 * (N - 1) - max(d1[i], d2[i]) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing P = pair<int, int>;\nusing Graph = vector<vector<int>>;\n\nmap<P, int> dp;\n\nvoid dfs1(int prev, int v, const Graph& G) {\n\tint res = 1;\n\tfor (auto to : G[v]) if (to != prev) {\n\t\tdfs1(v, to, G);\n\t\tres = max(res, dp[P(v, to)] + 1);\n\t}\n\tdp[P(prev, v)] = res;\n}\n\nvoid dfs2(int prev, int v, const Graph& G) {\n\tint ma1 = 1, ma2 = 1;\n\tfor (auto to : G[v]) {\n\t\tint now = dp[P(v, to)] + 1;\n\t\tif (now >= ma1) {\n\t\t\tma2 = ma1;\n\t\t\tma1 = now;\n\t\t}\n\t\telse if (now >= ma2) {\n\t\t\tma2 = now;\n\t\t}\n\t}\n\tfor (auto to : G[v]) if (to != prev) {\n\t\tdp[P(to, v)] = dp[P(v, to)] + 1 == ma1 ? ma2 : ma1;\n\t\tdfs2(v, to, G);\n\t}\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\tint N;\n\tcin >> N;\n\tGraph G(N);\n\tfor (int i = 0, u, v; i < N - 1; i++) {\n\t\tcin >> u >> v; u--; v--;\n\t\tG[u].push_back(v);\n\t\tG[v].push_back(u);\n\t}\n\tdfs1(-1, 0, G);\n\tdfs2(-1, 0, G);\n\tvector<int> res(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (auto to : G[i]) {\n\t\t\tres[i] = N * 2 - 2 - max(dp[P(i, to)], dp[P(to, i)] - 1);\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tcout << res[i] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nint n,dis[100005],ans[100009];\nvector<P>v[100005];\n\nvoid dfs1(int idx,int pre){\n  for(int i=0;i<v[idx].size();i++){\n    int next=v[idx][i].first;\n    int cost=v[idx][i].second;\n    if(next==pre)continue;\n    dfs1(next,idx);\n    dis[idx]=max(dis[idx],dis[next]+cost);\n  }\n}\n\nint dfs2(int idx,int d_pre,int pre){\n  vector<P>child;\n  child.push_back(P(0,-1));\n  for(int i=0;i<v[idx].size();i++){\n    int next=v[idx][i].first;\n    int cost=v[idx][i].second;\n    if(next==pre)child.push_back(P(d_pre+cost,next));\n    else child.push_back(P(dis[next]+cost,next));\n  }\n  sort(child.begin(),child.end(),greater<P>());\n  int res=child[0].first+child[1].first;\n  ans[idx]=max(child[0].first,child[1].first);\n  for(int i=0;i<v[idx].size();i++){\n    int next=v[idx][i].first;\n    int cost=v[idx][i].second;\n    if(next==pre)continue;\n    res=max(res,dfs2(next,child[next==child[0].second].first,idx));\n  }\n  return res;\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n-1;i++){\n    int a,b,w;\n    cin>>a>>b;a--;b--;\n    v[a].push_back(P(b,1));\n    v[b].push_back(P(a,1));\n  }\n  dfs1(0,-1);\n  dfs2(0,0,-1);\n  for(int i=0;i<n;i++)cout<<(n-1)*2-ans[i]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n\nvector< int > g[100000];\nint dist[100000], ans[100000];\n\n\nvoid dfs1(int idx, int par)\n{\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs1(to, idx);\n    dist[idx] = max(dist[idx], dist[to] + 1);\n  }\n}\n\nvoid dfs2(int idx, int d_par, int par)\n{\n  vector< pair< int, int > > d_child;\n  d_child.emplace_back(0, -1);\n  for(int &to : g[idx]) {\n    if(to == par) d_child.emplace_back(d_par + 1, to);\n    else d_child.emplace_back(dist[to] + 1, to);\n  }\n  sort(d_child.rbegin(), d_child.rend());\n  ans[idx] = d_child[0].first;\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs2(to, d_child[d_child[0].second == to].first, idx);\n  }\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  for(int i = 0; i < N - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n\n  dfs1(0, -1);\n  dfs2(0, 0, -1);\n  for(int i = 0; i < N; i++) {\n    cout << (N - 1) * 2 - ans[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1595\"\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define call_from_test\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n#endif\n//BEGIN CUT HERE\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n//END CUT HERE\n#ifndef call_from_test\nsigned main(){\n  return 0;\n}\n#endif\n\n#ifndef call_from_test\n#include <bits/stdc++.h>\nusing namespace std;\n#endif\n//BEGIN CUT HERE\ntemplate<typename Vertex, typename Cluster, size_t LIM>\nstruct TopTree{\n  enum Type { Compress, Rake, Edge, None };\n  struct Node{\n    Vertex* vs[2];\n    Cluster dat;\n    Node* p;\n    Node* q;\n    Node* ch[2];\n    bool rev,guard;\n    Type type;\n    Node():p(nullptr),q(nullptr),rev(false),guard(false),type(Type::None){}\n  };\n\n  static array<Vertex, LIM> pool_v;\n  static array<Node, LIM> pool_c;\n  size_t ptr_v,ptr_c;\n\n  Cluster id;\n  TopTree(Cluster id=Cluster()):ptr_v(0),ptr_c(0),id(id){}\n\n  inline Vertex* create(Vertex v){\n    auto t=&pool_v[ptr_v++];\n    auto dummy=&pool_v[ptr_v++];\n    *t=v;\n    link(t,id,dummy);\n    return t;\n  }\n\n  inline Node* edge(Vertex* u,Cluster w,Vertex* v){\n    auto t=&(pool_c[ptr_c++]);\n    t->vs[0]=u;t->vs[1]=v;t->dat=w;t->type=Type::Edge;\n    return pushup(t);\n  }\n\n  inline Node* compress(Node* l,Node* r){\n    auto t=&(pool_c[ptr_c++]);\n    t->ch[0]=l;t->ch[1]=r;t->type=Type::Compress;\n    return pushup(t);\n  }\n\n  inline Node* rake(Node* l,Node* r){\n    auto t=&(pool_c[ptr_c++]);\n    t->ch[0]=l;t->ch[1]=r;t->type=Type::Rake;\n    return pushup(t);\n  }\n\n  int parent_dir(Node* t){\n    Node* p=t->p;\n    if(!p) return -1;\n    if(p->guard) return -1;\n    if(p->ch[0]==t) return 0;\n    if(p->ch[1]==t) return 1;\n    return -1;\n  }\n\n  inline Node* pushup(Node* const t){\n    Node* const l=t->ch[0];\n    Node* const r=t->ch[1];\n\n    if(t->type==Type::Edge){\n      if(!t->p){\n\tt->vs[0]->handle=t;\n\tt->vs[1]->handle=t;\n      }else if(t->p->type==Type::Compress){\n\tif(parent_dir(t)==-1)\n\t  t->vs[0]->handle=t;\n      }else if(t->p->type==Type::Rake){\n\tt->vs[0]->handle=t;\n      }\n    }else if(t->type==Type::Compress){\n      assert(l->vs[1]==r->vs[0]);\n      t->vs[0]=l->vs[0];\n      t->vs[1]=r->vs[1];\n\n      Cluster lf=l->dat;\n      if(t->q){\n\tNode* q=t->q;\n\tassert(l->vs[1]==q->vs[1]);\n\tlf=Cluster::rake(l->dat,q->dat,q->vs[0]);\n      }\n      t->dat=Cluster::compress(lf,r->vs[0],r->dat);\n\n      l->vs[1]->handle=t;\n      if(!t->p){\n\tt->vs[0]->handle=t;\n\tt->vs[1]->handle=t;\n      }else if(t->p->type==Type::Compress){\n\tif(parent_dir(t)==-1)\n\t  t->vs[0]->handle=t;\n      }else if(t->p->type==Type::Rake){\n\tt->vs[0]->handle=t;\n      }\n    }else if(t->type==Type::Rake){\n      propagate(t);\n      assert(l->vs[1]==r->vs[1]);\n      t->vs[0]=l->vs[0];\n      t->vs[1]=l->vs[1];\n      t->dat=Cluster::rake(l->dat,r->dat,r->vs[0]);\n    }else abort();\n    return t;\n  }\n\n\n  int parent_dir_ignore_guard(Node* t){\n    Node* p=t->p;\n    if(!p) return -1;\n    if(p->ch[0]==t) return 0;\n    if(p->ch[1]==t) return 1;\n    return -1;\n  }\n\n  void rotate(Node* t,Node* x,size_t dir){\n    Node* y=x->p;\n    int par=parent_dir_ignore_guard(x);\n    propagate(t->ch[dir]);\n    x->ch[dir^1]=t->ch[dir];\n    t->ch[dir]->p=x;\n    t->ch[dir]=x;\n    x->p=t;\n    t->p=y;\n    if(~par) y->ch[par]=t;\n    else if(y and y->type==Type::Compress) y->q=t;\n    pushup(x);pushup(t);\n    if(y and !y->guard) pushup(y);\n  }\n\n  inline void propagate(Node* t){\n    if(t->type==Type::Compress){\n      if(t->rev){\n\tassert(t->ch[0] and t->ch[1]);\n\tswap(t->ch[0],t->ch[1]);\n\ttoggle(t->ch[0]);\n\ttoggle(t->ch[1]);\n\tt->rev=false;\n      }\n    }\n  }\n\n  inline void toggle(Node* t){\n    if(t->type==Type::Edge){\n      swap(t->vs[0],t->vs[1]);\n      t->dat.toggle();\n    }else if(t->type==Type::Compress){\n      swap(t->vs[0],t->vs[1]);\n      t->dat.toggle();\n      t->rev^=true;\n    }else if(t->type==Type::Rake){\n    }else abort();\n  }\n\n  void splay(Node* t){\n    assert(t->type!=Type::Edge);\n    propagate(t);\n\n    while(~parent_dir(t)){\n      Node* q=t->p;\n      if(q->type!=t->type) break;\n      if(~parent_dir(q) and q->p and q->p->type==q->type){\n\tNode* r=q->p;\n\tif(r->p) propagate(r->p);\n\tpropagate(r);propagate(q);propagate(t);\n\tint qt_dir=parent_dir(t);\n\tint rq_dir=parent_dir(q);\n\tif(rq_dir==qt_dir){\n\t  rotate(q,r,rq_dir^1);\n\t  rotate(t,q,qt_dir^1);\n\t}else{\n\t  rotate(t,q,qt_dir^1);\n\t  rotate(t,r,rq_dir^1);\n\t}\n      }else{\n\tif(q->p) propagate(q->p);\n\tpropagate(q);propagate(t);\n\tint qt_dir=parent_dir(t);\n\trotate(t,q,qt_dir^1);\n      }\n    }\n  }\n\n  void pushdown(Node* t){\n    if(!t) return;\n    pushdown(t->p);\n    propagate(t);\n  }\n\n  Node* expose(Node* t){\n    pushdown(t);\n    while(true){\n      assert(t->type!=Type::Rake);\n      if(t->type==Type::Compress) splay(t);\n      Node* n=nullptr;\n      {\n\tNode* p=t->p;\n\tif(!p) break;\n\tif(p->type==Type::Rake){\n\t  propagate(p);\n\t  splay(p);\n\t  n=p->p;\n\t}else if(p->type==Type::Compress){\n\t  propagate(p);\n\t  if(p->guard and ~parent_dir_ignore_guard(t)) break;\n\t  n=p;\n\t}else abort();\n      }\n      splay(n);\n      int dir=parent_dir_ignore_guard(n);\n      if(dir==-1 or n->p->type==Type::Rake) dir=0;\n\n      Node* const c=n->ch[dir];\n      if(dir==1){\n\ttoggle(c);\n\tpropagate(c);\n\ttoggle(t);\n\tpropagate(t);\n      }\n      int n_dir=parent_dir(t);\n      if(~n_dir){\n\tpropagate(c);\n\tNode* const r=t->p;\n\tpropagate(r);\n\tr->ch[n_dir]=c;\n\tc->p=r;\n\tn->ch[dir]=t;\n\tt->p=n;\n\tpushup(c);pushup(r);pushup(t);pushup(n);\n\tsplay(r);\n      }else{\n\tpropagate(c);\n\tn->q=c;\n\tc->p=n;\n\tn->ch[dir]=t;\n\tt->p=n;\n\tpushup(c);pushup(t);pushup(n);\n      }\n      if(t->type==Type::Edge) t=n;\n    }\n    return t;\n  }\n\n  Node* expose(Vertex* v){\n    return expose((Node*)(v->handle));\n  }\n\n  Node* link(Vertex* u,Cluster w,Vertex* v){\n    if(!u->handle and !v->handle) return edge(u,w,v);\n\n    Node* nnu=(Node*)u->handle;\n    Node* nnv=(Node*)v->handle;\n    Node* ee=edge(u,w,v);\n    Node* ll=nullptr;\n\n    if(!nnv) ll=ee;\n    else{\n      Node* vv=expose(nnv);\n      propagate(vv);\n      if(vv->vs[1]==v){\n\ttoggle(vv);\n\tpropagate(vv);\n      }\n      if(vv->vs[0]==v){\n\tNode* nv=compress(ee,vv);\n\tee->p=nv;\n\tpushup(ee);\n\tvv->p=nv;\n\tpushup(vv);pushup(nv);\n\tll=nv;\n      }else{\n\tNode* nv=vv;\n\tNode* ch=nv->ch[0];\n\tpropagate(ch);\n\tnv->ch[0]=ee;\n\tee->p=nv;\n\tpushup(ee);\n\n\tNode* bt=nv->q;\n\tNode* rk=nullptr;\n\tif(bt){\n\t  propagate(bt);\n\t  rk=rake(bt,ch);\n\t  bt->p=rk;\n\t  ch->p=rk;\n\t  pushup(bt);pushup(ch);\n\t}else{\n\t  rk=ch;\n\t}\n\tnv->q=rk;\n\trk->p=nv;\n\tpushup(rk);pushup(nv);\n\tll=nv;\n      }\n    }\n\n    if(nnu){\n      Node* uu=expose(nnu);\n      propagate(uu);\n      if(uu->vs[0]==u){\n\ttoggle(uu);\n\tpropagate(uu);\n      }\n      if(uu->vs[1]==u){\n\tNode* tp=compress(uu,ll);\n\tuu->p=tp;\n\tll->p=tp;\n\tpushup(uu);pushup(ll);pushup(tp);\n      }else{\n\tNode* nu=uu;\n\tNode* ch=nu->ch[1];\n\ttoggle(ch);\n\tpropagate(ch);\n\n\tnu->ch[1]=ll;\n\tll->p=nu;\n\tpushup(ll);\n\n\tNode* al=nu->q;\n\tNode* rk=nullptr;\n\tif(al){\n\t  propagate(al);\n\t  rk=rake(al,ch);\n\t  al->p=rk;\n\t  ch->p=rk;\n\t  pushup(al);pushup(ch);\n\t}else{\n\t  rk=ch;\n\t}\n\tnu->q=rk;\n\trk->p=nu;\n\tpushup(rk);pushup(nu);\n      }\n    }\n    return ee;\n  }\n\n  void set_toggle(Node* v){\n    toggle(v);propagate(v);\n  }\n\n  void soft_expose(Vertex* u,Vertex* v){\n    pushdown((Node*)u->handle);\n    pushdown((Node*)v->handle);\n    Node* rt=expose((Node*)u->handle);\n\n    if(u->handle==v->handle){\n      if(rt->vs[1]==u or rt->vs[0]==v)\n\tset_toggle(rt);\n      return;\n    }\n\n    rt->guard=true;\n    Node* soft=expose((Node*)v->handle);\n    rt->guard=false;\n\n    pushup(rt);\n    if(parent_dir(soft)==0) set_toggle(rt);\n  }\n\n  Cluster query(Vertex* u,Vertex* v){\n    soft_expose(u,v);\n    Node* rt=(Node*)u->handle;\n    propagate(rt);\n\n    if(rt->vs[0]==u and rt->vs[1]==v) return rt->dat;\n    if(rt->vs[0]==u) return rt->ch[0]->dat;\n    if(rt->vs[1]==v) return rt->ch[1]->dat;\n    propagate(rt->ch[1]);\n    return rt->ch[1]->ch[0]->dat;\n  }\n\n  void bring(Node* rt){\n    Node* rk=rt->q;\n    if(!rk){\n      Node* ll=rt->ch[0];\n      ll->p=nullptr;\n      pushup(ll);\n    }else if(rk->type==Type::Compress or rk->type==Type::Edge){\n      propagate(rk);\n\n      Node* nr=rk;\n      set_toggle(nr);\n      rt->ch[1]=nr;\n      nr->p=rt;\n      rt->q=nullptr;\n\n      pushup(nr);pushup(rt);\n    }else if(rk->type==Type::Rake){\n      propagate(rk);\n      while(rk->ch[1]->type==Type::Rake){\n\tpropagate(rk->ch[1]);\n\trk=rk->ch[1];\n      }\n      pushdown(rk);\n\n      rt->guard=true;\n      splay(rk);\n      rt->guard=false;\n\n      Node* ll=rk->ch[0];\n      Node* rr=rk->ch[1];\n      propagate(ll);\n      set_toggle(rr);\n\n      rt->ch[1]=rr;\n      rr->p=rt;\n\n      rt->q=ll;\n      ll->p=rt;\n\n      pushup(ll);pushup(rr);pushup(rt);\n    }\n  }\n\n  void cut(Vertex* u,Vertex *v){\n    soft_expose(u,v);\n    Node* rt=(Node*)u->handle;\n    propagate(rt);\n    Node* rr=rt->ch[1];\n    rr->p=nullptr;\n    set_toggle(rr);\n    bring(rr);bring(rt);\n  }\n};\ntemplate<typename Vertex, typename Cluster, size_t LIM>\narray<Vertex, LIM> TopTree<Vertex, Cluster, LIM>::pool_v;\ntemplate<typename Vertex, typename Cluster, size_t LIM>\narray<typename TopTree<Vertex, Cluster, LIM>::Node, LIM>\nTopTree<Vertex, Cluster, LIM>::pool_c;\n//END CUT HERE\n#ifndef call_from_test\n//INSERT ABOVE HERE\nsigned main(){\n  AOJ_1595();\n  return 0;\n}\n#endif\n\n#undef call_from_test\n\nstruct Vertex{\n  void* handle;\n  int idx;\n  Vertex(int idx=-1):handle(nullptr),idx(idx){}\n};\n\nstruct Cluster{\n  int ans,lf,rg,len;\n  Cluster(){}\n  Cluster(int l):ans(l),lf(l),rg(l),len(l){}\n  Cluster(int ans,int lf,int rg,int len):\n    ans(ans),lf(lf),rg(rg),len(len){}\n  void toggle(){swap(lf,rg);}\n  static Cluster compress(Cluster x,Vertex*,Cluster y){\n    return Cluster(\n      max(x.rg,y.lf),\n      max(x.lf,x.len+y.lf),\n      max(y.rg,y.len+x.rg),\n      x.len+y.len);\n  }\n  static Cluster rake(Cluster x,Cluster y,Vertex*){\n    return Cluster(0,max(x.lf,x.len+y.rg),max(x.rg,y.rg),x.len);\n  }\n};\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(0);\n\n  const size_t LIM = 1e6;\n  TopTree<Vertex, Cluster, LIM> T(Cluster(0));\n\n  int n;\n  cin>>n;\n\n  vector<Vertex*> vs(n);\n  for(int i=0;i<n;i++)\n    vs[i]=T.create(Vertex(i));\n\n  for(int i=1;i<n;i++){\n    int u,v;\n    cin>>u>>v;\n    u--;v--;\n    T.link(vs[u],Cluster(1),vs[v]);\n  }\n\n  for(int i=0;i<n;i++)\n    cout<<(n-1)*2-T.expose(vs[i])->dat.ans<<\"\\n\";\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint N;\nvector< int > g[100000];\nint dp[100000];\nint depth[100000];\n\nvoid dfs(int x, int par = -1)\n{\n  for(int to : g[x]) {\n    if(par != to) {\n      dfs(to, x);\n      depth[x] = max(depth[x], depth[to] + 1);\n    }\n  }\n}\n\nvoid rec(int x, int dep = 0, int par = -1)\n{\n\n\n  priority_queue< pair< int, int >, vector< pair< int, int > >, greater< pair< int, int > > > que;\n  que.emplace(dep, -1);\n  while(que.size() > 2) que.pop();\n  for(int to : g[x]) {\n    if(par != to) {\n      que.emplace(depth[to] + 1, to);\n      while(que.size() > 2) que.pop();\n    }\n  }\n  auto obj2 = que.top();\n  que.pop();\n  auto obj1 = que.size() ? que.top() : obj2;\n\n  for(int to : g[x]) {\n    if(par != to) {\n      if(obj1.second == to) rec(to, obj2.first + 1, x);\n      else rec(to, obj1.first + 1, x);\n    }\n  }\n  dp[x] = obj1.first;\n}\nint main()\n{\n  cin >> N;\n  for(int i = 0; i < N - 1; i++) {\n    int u, v;\n    cin >> u >> v;\n    --u, --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n  dfs(0);\n  rec(0);\n  for(int i = 0; i < N; i++) {\n    cout << (N - 1) * 2 - dp[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define REP(i, n) for (ll i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (ll i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define fi first\n#define se second\n#define pb push_back\n#define debug(x) cerr << #x << \": \" << (x) << endl\n#define int long long\nusing namespace std;\nusing II = pair<int, int>;\nusing VII = vector<II>;\nusing VVII = vector<VII>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VVVI = vector<VVI>;\ntemplate <class T = int> inline T in() { T x; cin >> x; return x; }\ntemplate <class T = int> inline bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T = int> inline bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<T>& d) { int n = d.size(); REP (i, n) s << d[i] << \" \"; return s; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<vector<T>>& dd) { for (vector<T> d: dd) s << d << endl; return s; }\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nconst int MOD = 1e9 + 7;\n\nsigned main() {\n  int N = in();\n  VVI G(N);\n  REP (i, N - 1) {\n    int u, v; cin >> u >> v;\n    u--; v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  VVII dist(N); // {len, v}\n  VI far(N);\n  function<void (int, int)> dfs1 = [&](int v, int prev) {\n    for (int u: G[v]) if (u != prev) {\n      dfs1(u, v);\n      dist[v].push_back({far[u] + 1, u});\n      chmax(far[v], far[u] + 1);\n    }\n  };\n  dfs1(0, -1);\n\n  sort(RALL(dist[0]));\n  function<void (int, int)> dfs2 = [&](int v, int prev) {\n    for (int u: G[v]) if (u != prev) {\n      int tmp;\n      if (dist[v][0].se == u) {\n        tmp = dist[v].size() == 1 ? 0 : dist[v][1].fi;\n      } else {\n        tmp = dist[v][0].fi;\n      }\n      debug(tmp);\n      dist[u].pb({tmp + 1, v});\n      sort(RALL(dist[u]));\n      dfs2(u, v);\n    }\n  };\n  dfs2(0, -1);\n\n  REP (i, N) {\n    cout << 2 * (N - 1) - dist[i][0].fi << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst double PI  = 3.1415926535897932384626433832795028841971;\nconst int    INF = 1000000007;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint n;\nbool saw[100000];\nvector<int> d[100000];\nvector<int> v[100000];\n\nint dfs(int x){\n    int ret = 0;\n    saw[x] = true;\n    rep(i,v[x].size()){\n        if(saw[v[x][i]]) continue;\n        int z = dfs(v[x][i]);\n        if(d[x].size() < 2) d[x].push_back(z);\n        else{\n            if(z > d[x][1]) d[x][1] = z;\n        }\n        if(d[x].size() == 2 && d[x][0] < d[x][1]) swap(d[x][0],d[x][1]);\n        ret = max(ret,d[x][0]);\n    }\n    return ret+1;\n}\n\nvoid dfs2(int x){\n    saw[x] = true;\n    rep(i,v[x].size()){\n        if(!saw[v[x][i]]) continue;\n        int dep;\n        if(d[x].size() != 0) dep = d[x][0];\n        else dep = 0;\n        if(1+dep != d[v[x][i]][0]){\n            d[x].push_back(d[v[x][i]][0]+1);\n        } else{\n            if(d[v[x][i]].size() == 1) d[x].push_back(1);\n            else d[x].push_back(d[v[x][i]][1]+1);\n        }\n    }\n    sort(d[x].begin(),d[x].end(),greater<int>());\n    rep(i,v[x].size()){\n        if(saw[v[x][i]]) continue;\n        dfs2(v[x][i]);\n    }\n}\n\nint main(){\n    cin >> n;\n    rep(i,n-1){\n        int a, b;\n        scanf(\"%d%d\",&a,&b);\n        a--; b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    dfs(0);\n    rep(i,n) sort(d[i].begin(),d[i].end(),greater<int>());\n    rep(i,n) saw[i] = false;\n    dfs2(0);\n    rep(i,n) printf(\"%d\\n\",(n-1)*2-d[i][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nconst int N = 100000;\n\nint n;\nvector<int> G[N];\n\n// ??°??£????????????????????????/??????\npi dp1[N];\nvoid dfs(int v, int par)\n{\n    int res = 0;\n    for(int nx:G[v])if(nx!=par)\n    {\n        dfs(nx,v);\n        res += dp1[nx].fi+2;\n    }\n\n    int notback = res;\n    for(int nx:G[v])if(nx!=par)\n    {\n        int t = res;\n        t -= dp1[nx].fi+2;\n        t += dp1[nx].se+1;\n        notback = min(notback,t);\n    }\n\n    dp1[v] = {res,notback};\n}\n\nint ans[N];\nvoid dfs2(int v, int par, pi d)\n{\n\n    // v????????¨???????????????????????¨????????¨?????¨????????±?????????\n    vector<pair<pi,int>> c;\n    // ???????????????\n    for(int nx:G[v])if(nx!=par) c.pb({dp1[nx],nx});\n    // ?????????\n    c.pb({d,-1});\n\n    int C = c.size();\n    // ??¨??¨?????¨?????¨???????????????????????£?????°??£?????????????????¨???????????´???????????????\n    int sum = 0;\n    rep(i,C) sum += c[i].fi.fi+2;\n\n    // second????????¶?????¨????????£?????????????????????(?°?????????????????¬???????)\n    // (??????,??????)\n    vector<pi> gain;\n\n    // ??????v??????????????????????¨??????????\n    ans[v] = sum;\n    // ????????¨?????¨???\"??°?????????\"??????????????¨??¢?´¢\n    rep(i,C)\n    {\n        // \"??°??£?????????\"??????\"??°?????????\"???????????????????????¨????????£????????????????????????\n        int g = c[i].fi.se+1 - (c[i].fi.fi+2);\n\n        ans[v] = min(ans[v],sum+g);\n        gain.pb({g,c[i].se});\n    }\n\n    // ??????????????¨?????¨????????± d ?????´??°????????????????????????????????????\n    sort(all(gain));\n    rep(i,C)\n    {\n        int nx = gain[i].se;\n        if(nx==-1) continue;\n\n        pi nd;\n        // \"??°??£?????????\"???????????????????????¨?????¨?????¶??????????????°??????\n        nd.fi = sum - (dp1[nx].fi+2);\n\n        // \"??°?????????\"???????????????????????¨?????¨??????????????????????????????????????§???????????§??´?????\\?±????????????????\n        // ??????????????????????????¨?????¨???\"??°?????????\"??????????????§????????????????????§?¬??????§????????¨?????????\"??°?????????\"??????????????????\n        // ????????§???????????°??????????????¨?????¨???\"??°?????????\"???????????°??????\n        nd.se = nd.fi;\n        if(i==0)\n        {\n            if(C>1) nd.se += gain[1].fi;\n        }\n        else nd.se += gain[0].fi;\n\n        dfs2(nx,v,nd);\n    }\n}\n\nint main()\n{\n    cin >>n;\n    rep(i,n-1)\n    {\n        int u,v;\n        cin >>u >>v;\n        --u;\n        --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    dfs(0,-1);\n    dfs2(0,-1,{-2,-1});\n    rep(i,n) cout << ans[i] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\n\nint H, W, N;\n\nint dfs(const int now, const int from,int dep,\n\tconst vector<vector<int>>&edges, vector<int>&depths,\n\tvector<int>&lens) {\n\tdepths[now]=dep;\n\tint alen=0;\n\tfor (auto e : edges[now]) {\n\t\tif(e==from)continue;\n\t\telse {\n\t\t\talen=max(alen,1+dfs(e,now,dep+1,edges,depths,lens));\n\t\t}\n\t}\n\tlens[now]=alen;\n\treturn alen;\n}\n\nvoid dfs2(const int now, const int from, int pre,\n\tconst vector<vector<int>>&edges, const vector<int>&lens,\n\tvector<int>&anss) {\n\tint ans=pre;\n\tmap<int,int>mp;\n\tfor (auto e : edges[now]) {\n\t\tif(e==from)continue;\n\t\telse {\n\t\t\tmp[lens[e]]++;\n\t\t\tans=max(ans,lens[now]);\n\t\t}\n\t}\n\tanss[now]=ans;\n\tfor (auto e : edges[now]) {\n\t\tif(e==from)continue;\n\t\telse {\n\t\t\tmp[lens[e]]--;\n\t\t\tif (mp[lens[e]]==0) {\n\t\t\t\tmp.erase(lens[e]);\n\t\t\t}\n\t\t\tauto it=max_element(mp.begin(),mp.end());\n\t\t\tint next_pre=(it!=mp.end())?(max(pre,it->first+1)+1):pre+1;\n\t\t\tdfs2(e,now,next_pre,edges,lens,anss);\n\t\t\tmp[lens[e]]++;\n\t\t}\n\t}\n}\nint main() {\n\tint N;cin>>N;\n\tvector<vector<int>>edges(N);\n\tvector<int>depths(N);\n\tvector<int>lens(N);\n\tfor (int i = 0; i < N-1; ++i) {\n\t\tint a,b;cin>>a>>b;\n\t\ta--;b--;\n\t\tedges[a].push_back(b);\n\t\tedges[b].push_back(a);\n\t}\n\tdfs(0,-1,0,edges,depths,lens);\n\n\tvector<int>anss(N);\n\tdfs2(0,-1,0,edges,lens,anss);\n\tfor (int i = 0; i < N; ++i) {\n\t\tcout<<2*(N-1)-anss[i]<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <sys/time.h>\nusing namespace std;\n\n#define rep(i,n) for(long long i = 0; i < (long long)(n); i++)\n#define pb push_back\n#define all(x) (x).begin(), (x).end()\n#define fi first\n#define se second\ntemplate<class T1, class T2> bool chmin(T1 &a, T2 b) { return b < a && (a = b, true); }\ntemplate<class T1, class T2> bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\nusing ll = long long; using vll = vector<ll>; using vvll = vector<vll>; using P = pair<ll, ll>;\n\nint main(void) {\n    ll n; cin >> n;\n    vvll g(n);\n    rep(i, n-1) {\n        ll u, v; cin >> u >> v; u--, v--;\n        g[u].pb(v), g[v].pb(u);\n    }\n\n    vll d(n);\n    function<ll(ll, ll)> f = [&](ll v, ll p) {\n        for (auto u : g[v]) if (u != p) chmax(d[v], f(u, v));\n        return d[v] + 1;\n    };\n    f(0, -1);\n\n    vll ret(n);\n    // dpar[v][p] = p???v???????????¨?????¨????????§?????§???d\n    function<void(ll, ll, ll)> ff = [&](ll v, ll p, ll dpar) {\n        vector<P> children;\n        for (auto u : g[v]) children.emplace_back(u == p ? dpar + 1 : d[u] + 1, u);\n        sort(all(children)); reverse(all(children));\n\n        ret[v] = children[0].fi;\n\n        for (auto u : g[v]) if (u != p) ff(u, v, children[children[0].se==u].fi);\n    };\n    ff(0, -1, 0);\n\n    rep(i, n) cout << 2 * (n - 1) - ret[i] << endl;\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define int long long\n#define uint unsigned int\n#define pii pair<int, int>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORR(i,a,b) for(int i=(a);i>=(b);--i)\n#define REP(i,n) FOR(i,0,n)\n#define REPR(i,n) FORR(i,n,0)\n#define ALL(c) ((c).begin()), ((c).end())\n\n#define PB(a) push_back(a)\n#define EMPB(...) emplace_back(__VA_ARGS__)\n#define EMP(...) emplace(__VA_ARGS__)\n#define MP(a,b) make_pair(a,b)\n#define MT(...) make_tuple(__VA_ARGS__)\n\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n\n#define PW(n) (1LL << (n))\n\nusing namespace std;\n\ntemplate <class T> inline bool CHMIN(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate <class T> inline bool CHMAX(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate <class T> inline void SORT(T &a) { sort(a.begin(), a.end()); }\ntemplate <class T> inline void REV(T &a) { reverse(a.begin(), a.end()); }\ntemplate <class T> inline void UNI(T &a) { sort(a.begin(), a.end()); a.erase(unique(a.begin(), a.end()), a.end()); }\n\ntemplate <class S, class T> ostream& operator << (ostream& os, const pair<S, T> v) {\n  os << \"(\" << v.first << \", \" << v.second << \")\"; return os;\n}\n\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n\n/* ---------------------------------------------------------------------------------------------------- */\n\nint N;\nvector<int> G[100010];\nint dp1[100010];\nint dp2[100010];\n\nvoid dfs1(int v, int par) {\n  for (auto& nv : G[v]) if (nv != par) {\n    dfs1(nv, v);\n    CHMAX(dp1[v], dp1[nv]+1);\n  }\n}\n\nvoid dfs2(int v, int par, int d_par) {\n  vector<pii> w;\n  w.EMPB(0, -1);\n  for (auto& nv : G[v]) {\n    w.EMPB((nv == par ? d_par : dp1[nv]) + 1, nv);\n  }\n  SORT(w); REV(w);\n  dp2[v] = w[0].first;\n  for (auto& nv : G[v]) if (nv != par) {\n    dfs2(nv, v, w[nv == w[0].second].first);\n  }\n}\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  cin >> N;\n  REP(i, N-1) {\n    int s, t;\n    cin >> s >> t;\n    s--; t--;\n    G[s].PB(t);\n    G[t].PB(s);\n  }\n  dfs1(0, -1);\n  dfs2(0, -1, 0);\n  REP(i, N) {\n    cout << 2*(N-1) - dp2[i] << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\nusing lint = long long int;\nlong long int INF = 1001001001001001LL;\nint inf = 1000000007;\nlong long int MOD = 1000000007LL;\ndouble PI = 3.1415926535897932;\n\ntemplate<typename T1,typename T2>inline void chmin(T1 &a,const T2 &b){if(a>b) a=b;}\ntemplate<typename T1,typename T2>inline void chmax(T1 &a,const T2 &b){if(a<b) a=b;}\n\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n\n/* do your best */\n\nvoid dfs1(int cur, int par, vector<vector<int>> &g, vector<int> &D) {\n  for (auto nxt : g[cur]) {\n    if (nxt == par) continue;\n    dfs1(nxt, cur, g, D);\n  }\n\n  int maxLen = -1;\n  for (auto nxt : g[cur]) {\n    if (nxt == par) continue;\n    maxLen = max(maxLen, D[nxt]);\n  }\n\n  D[cur] = maxLen + 1;\n}\n\nvoid dfs2(int cur, int par, vector<vector<int>> &g, vector<int> &D, vector<int> &ans, int Dpar) {\n\n  \n  int maxLen = Dpar;\n  vector<int> left;\n  vector<int> right;\n  for (auto nxt : g[cur]) {\n    if (nxt == par) continue;\n    left.push_back(D[nxt]);\n    right.push_back(D[nxt]);\n    maxLen = max(maxLen, D[nxt]);\n  }\n  ans[cur] = maxLen + 1;\n  \n  for (int i = 1; i < left.size(); i++) {\n    left[i] = max(left[i], left[i - 1]);\n  }\n\n  for (int i = (int)right.size() - 2; i >= 0; i--) {\n    right[i] = max(right[i], right[i + 1]);\n  }\n\n  int id = 0;\n  for (auto nxt : g[cur]) {\n    if (nxt == par) continue;\n    \n    int nxtDpar = Dpar + 1;\n    if (id != 0) nxtDpar = max(nxtDpar, left[id - 1] + 1);\n    if (id != (int)right.size() - 1) nxtDpar = max(nxtDpar, right[id + 1] + 1);\n    id++;\n\n    dfs2(nxt, cur, g, D, ans, nxtDpar);\n  }\n\n}\n\nint main() {\n  \n  int n; cin >> n;\n  vector<vector<int>> g(n);\n  for (int i = 0; i < n - 1; i++) {\n    int a, b; cin >> a >> b;\n    a--;\n    b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n\n  vector<int> D(n, -1);\n  vector<int> ans(n, -1);\n  dfs1(0, -1, g, D);\n  dfs2(0, -1, g, D, ans, -1);\n  for (int i = 0; i < n; i++) {\n    cout << 2 * (n - 1) - ans[i] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nconst int N = 100000;\n\nvector<int> G[N];\n\n// ??°??£????????????????????????/??????\npi dp1[N];\nvoid dfs(int v, int par)\n{\n    int res = 0;\n    for(int nx:G[v])if(nx!=par)\n    {\n        dfs(nx,v);\n        res += dp1[nx].fi+2;\n    }\n\n    int notback = res;\n    for(int nx:G[v])if(nx!=par)\n    {\n        int t = res;\n        t -= dp1[nx].fi+2;\n        t += dp1[nx].se+1;\n        notback = min(notback,t);\n    }\n\n    dp1[v] = {res,notback};\n}\n\nint ans[N];\nvoid dfs2(int v, int par, pi d)\n{\n\n    // v????????¨???????????????????????¨????????¨?????¨????????±?????????\n    vector<pair<pi,int>> c;\n    // ???????????????\n    for(int nx:G[v])if(nx!=par) c.pb({dp1[nx],nx});\n    // ?????????\n    c.pb({d,-1});\n\n    int C = c.size();\n    // ??¨??¨?????¨?????¨???????????????????????£?????°??£?????????????????¨???????????´???????????????\n    int sum = 0;\n    rep(i,C) sum += c[i].fi.fi+2;\n\n    // second????????¶?????¨????????£?????????????????????(?°?????????????????¬???????)\n    // (??????,??????)\n    vector<pi> gain;\n\n    // ??????v??????????????????????¨??????????\n    ans[v] = sum;\n    // ????????¨?????¨???\"??°?????????\"??????????????¨??¢?´¢\n    rep(i,C)\n    {\n        // \"??°??£?????????\"??????\"??°?????????\"???????????????????????¨????????£????????????????????????\n        int g = c[i].fi.se+1 - (c[i].fi.fi+2);\n\n        ans[v] = min(ans[v],sum+g);\n        gain.pb({g,c[i].se});\n    }\n\n    // ??????????????¨?????¨????????± d ?????´??°????????????????????????????????????\n    sort(all(gain));\n    rep(i,C)\n    {\n        int nx = gain[i].se;\n        if(nx==-1) continue;\n\n        pi nd;\n        // \"??°??£?????????\"???????????????????????¨?????¨?????¶??????????????°??????\n        nd.fi = sum - (dp1[nx].fi+2);\n\n        // \"??°?????????\"???????????????????????¨?????¨??????????????????????????????????????§???????????§??´?????\\?±????????????????\n        // ??????????????????????????¨?????¨???\"??°?????????\"??????????????§????????????????????§?¬??????§????????¨?????????\"??°?????????\"??????????????????\n        // ????????§???????????°??????????????¨?????¨???\"??°?????????\"???????????°??????\n        nd.se = nd.fi;\n        if(i==0)\n        {\n            if(C>1) nd.se += gain[1].fi;\n        }\n        else nd.se += gain[0].fi;\n\n        dfs2(nx,v,nd);\n    }\n}\n\nint main()\n{\n    int n;\n    scanf(\" %d\", &n);\n    rep(i,n-1)\n    {\n        int u,v;\n        scanf(\" %d %d\", &u, &v);\n        --u;\n        --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    dfs(0,-1);\n    dfs2(0,-1,{-2,-1});\n    rep(i,n) printf(\"%d\\n\", ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n// #define double long double\n#define FOR(i, a, b) for(int i = (a); i < (b); ++i)\n#define FORR(i, a, b) for(int i = (a); i > (b); --i)\n#define REP(i, n) for(int i = 0; i < (n); ++i)\n#define REPR(i, n) for(int i = n; i >= 0; i--)\n#define FOREACH(x, a) for(auto &(x) : (a))\n#define VECCIN(x)                                                              \\\n    for(auto &youso_ : (x)) cin >> youso_\n#define bitcnt(x) __builtin_popcount(x)\n#define lbit(x) __builtin_ffsll(x)\n#define rbit(x) (64 - __builtin_clzll(x))\n#define fi first\n#define se second\n#define All(a) (a).begin(), (a).end()\n#define rAll(a) (a).rbegin(), (a).rend()\n#define cinfast() cin.tie(0), ios::sync_with_stdio(false)\n#define PERM(c)                                                                \\\n    sort(All(c));                                                              \\\n    for(bool cp = true; cp; cp = next_permutation(All(c)))\n#define MKORDER(n)                                                             \\\n    vector<int> od(n);                                                         \\\n    iota(All(od), 0LL);\n\ntemplate <typename T = long long> inline T IN() {\n    T x;\n    cin >> x;\n    return (x);\n}\ninline void CIN() {}\ntemplate <class Head, class... Tail>\ninline void CIN(Head &&head, Tail &&... tail) {\n    cin >> head;\n    CIN(move(tail)...);\n}\ntemplate <class Head> inline void COUT(Head &&head) { cout << head << \"\\n\"; }\ntemplate <class Head, class... Tail>\ninline void COUT(Head &&head, Tail &&... tail) {\n    cout << head << \" \";\n    COUT(forward<Tail>(tail)...);\n}\n\n#define CCIN(...)                                                              \\\n    char __VA_ARGS__;                                                          \\\n    CIN(__VA_ARGS__)\n#define DCIN(...)                                                              \\\n    double __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define LCIN(...)                                                              \\\n    long long __VA_ARGS__;                                                     \\\n    CIN(__VA_ARGS__)\n#define SCIN(...)                                                              \\\n    string __VA_ARGS__;                                                        \\\n    CIN(__VA_ARGS__)\n#define Printv(v)                                                              \\\n    {                                                                          \\\n        FOREACH(x, v) { cout << x << \" \"; }                                    \\\n        cout << \"\\n\";                                                          \\\n    }\ntemplate <typename T = string> inline void eputs(T s) {\n    cout << s << \"\\n\";\n    exit(0);\n}\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\n\n// generic lambdas\ntemplate <typename F>\n#if defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n[[nodiscard]]\n#elif defined(__GNUC__) &&                                                     \\\n    (__GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ >= 4)\n__attribute__((warn_unused_result))\n#endif // defined(__has_cpp_attribute) && __has_cpp_attribute(nodiscard)\n    static inline constexpr decltype(auto)\n    fix(F &&f) noexcept {\n    return [f = std::forward<F>(f)](auto &&... args) {\n        return f(f, std::forward<decltype(args)>(args)...);\n    };\n}\n\ntemplate <typename T> using PQG = priority_queue<T, vector<T>, greater<T>>;\ntemplate <typename T> using PQ = priority_queue<T>;\n\ntypedef long long ll;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<ll, ll> PL;\ntypedef vector<PL> VPL;\ntypedef vector<bool> VB;\ntypedef vector<double> VD;\ntypedef vector<string> VS;\n\nconst int INF = 1e9;\nconst int MOD = 1e9 + 7;\n// const int MOD = 998244353;\nconst ll LINF = 1e18;\nconst ll dw[] = {1, 1, 0, -1, -1, -1, 0, 1};\nconst ll dh[] = {0, 1, 1, 1, 0, -1, -1, -1};\n#define PI 3.141592653589793238\n\ntemplate <typename T, typename E> struct ReRooting {\n    struct Edge {\n        int to;\n        E data;\n        T dp, ndp;\n    };\n\n    using F = function<T(T, T)>;\n    using G = function<T(T, E)>;\n\n    vector<vector<Edge>> g;\n    vector<T> subdp, dp;\n    const T ident;\n    const F f;\n    const G gg;\n\n    ReRooting(int V, const F f, const G g, const T &ident)\n        : g(V), f(f), gg(g), ident(ident), subdp(V, ident), dp(V, ident) {}\n\n    void add_edge(int u, int v, const E &d) {\n        g[u].emplace_back((Edge){v, d, ident, ident});\n        g[v].emplace_back((Edge){u, d, ident, ident});\n    }\n\n    void add_edge_bi(int u, int v, const E &d, const E &e) {\n        g[u].emplace_back((Edge){v, d, ident, ident});\n        g[v].emplace_back((Edge){u, e, ident, ident});\n    }\n\n    void dfs_sub(int idx, int par) {\n        for(auto &e : g[idx]) {\n            if(e.to == par) continue;\n            dfs_sub(e.to, idx);\n            subdp[idx] = f(subdp[idx], gg(subdp[e.to], e.data));\n        }\n    }\n\n    void dfs_all(int idx, int par, const T &top) {\n        T buff{ident};\n        for(int i = 0; i < (int)g[idx].size(); i++) {\n            auto &e = g[idx][i];\n            e.ndp = buff;\n            e.dp = gg(par == e.to ? top : subdp[e.to], e.data);\n            buff = f(buff, e.dp);\n        }\n        dp[idx] = buff;\n        buff = ident;\n        for(int i = (int)g[idx].size() - 1; i >= 0; i--) {\n            auto &e = g[idx][i];\n            if(e.to != par) dfs_all(e.to, idx, f(e.ndp, buff));\n            e.ndp = f(e.ndp, buff);\n            buff = f(buff, e.dp);\n        }\n    }\n\n    vector<T> build() {\n        dfs_sub(0, -1);\n        dfs_all(0, -1, ident);\n        return dp;\n    }\n};\n\nsigned main() {\n    LCIN(N);\n    auto f = [](ll x, ll y) { return max(x, y); };\n    auto g = [](ll x, ll y) { return x + y; };\n    ReRooting<ll, ll> tree(N, f, g, 0);\n    REP(i, N - 1) {\n        LCIN(u, v);\n        u--, v--;\n        tree.add_edge(u, v, 1);\n    }\n    FOREACH(d, tree.build()) { cout << 2 * (N - 1) - d << \"\\n\"; }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*\n　　　∫ ∫ ∫\n　　　ノヽ\n　　（＿　 ）\n　（＿　　　 ）\n（＿＿＿＿＿＿ ）\n　ヽ(´･ω･)ﾉ　\n　　 |　 /\n　　 UU\n*/\n#pragma region macro\n#include <bits/stdc++.h>\ntypedef long long int64;\nusing namespace std;\nusing P = pair<int64, int64>;\ntypedef vector<int> vi;\nconst int MOD = (int)1e9 + 7;\nconst int64 INF = 1LL << 62;\nconst int inf = 1<<30;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n#define REP(i, n) for (int i = 0; i < (n); i++)\n#define FOR(i,s,n) for (int i = s; i < (n); i++)\n#define ALL(obj) (obj).begin(), (obj).end() //コンテナじゃないと使えない!!\n#define debug(x) cerr << #x << \": \" << x << \"\\n\";\n#define mp make_pair\n#define bn '\\n'\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T> &V){\n    int N = V.size();\n    REP(i,N){\n        os << V[i];\n        if (i!=N-1) os << \" \";\n    }\n    os << \"\\n\";\n    return os;\n}\ntemplate <typename T,typename S>\nostream& operator<<(ostream& os, pair<T,S> const&P){\n    os << \"(\";\n    os << P.first;\n    os << \" , \";\n    os << P.second;\n    os << \")\";\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, set<T> &S){\n    auto it=S.begin();\n    while(it!=S.end()){\n        os << *it;\n        os << \" \";\n        it++;\n    }\n    os << \"\\n\";\n    return os;\n}\ntemplate <typename T>\nostream& operator<<(ostream& os, deque<T> &q){\n    for(auto it=q.begin();it<q.end();it++){\n        os<<*it;\n        os<<\" \";\n    }\n     os<<endl;\n    return os;\n}\nvector<pair<int,int>> dxdy = {mp(0,1),mp(1,0),mp(-1,0),mp(0,-1)};\n#pragma endregion\n//fixed<<setprecision(10)<<ans<<endl;\n\nint N;\nvector<vector<int>> edge;\nvector<int> DP;\nvector<int> ans;\nint dfs(int v, int pre){\n    DP[v] = 0;\n    for(auto to:edge[v]){\n        if(to==pre) continue;\n        chmax(DP[v], dfs(to,v) + 1);\n    }\n    return DP[v];\n}\nconst int init_val = 0;\nvoid dfs_with_rerooting(int v, int pre, int pre_val){\n    //答えを得る\n    for(auto to:edge[v]){\n        if(to==pre){\n            chmax(ans[v], pre_val + 1);\n        }else{\n            chmax(ans[v], DP[to] + 1);\n        }\n    }\n    //左右から累積和\n    int to;\n    vector<int> left(edge[v].size(),init_val), right(edge[v].size(),init_val); \n    for(int i=0; i<edge[v].size(); i++){\n        int j = edge[v].size() - i - 1;\n        if(i) {\n            left[i]  = left[i-1];\n            right[j] = right[j+1];\n        }\n        to = edge[v][i];\n        if(to == pre) {\n            chmax(left[i], pre_val+1);\n        }else{\n            chmax(left[i], DP[to]+1);\n        }\n        to = edge[v][j];\n        if(to == pre) {\n            chmax(right[j], pre_val+1);\n        }else{\n            chmax(right[j], DP[to]+1);\n        }\n    }\n    \n    //根をくるくるする\n    for(int i=0; i<edge[v].size(); i++){\n        int to = edge[v][i];\n        if(to!=pre){\n            int val = init_val;\n            if(i){\n                chmax(val, left[i-1]);\n            }\n            if(i!=edge[v].size()-1){\n                chmax(val, right[i+1]);\n            }\n            dfs_with_rerooting(to, v, val);\n        }\n    }\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> N;\n    DP.assign(N,0);\n    ans.assign(N,0);\n    edge.assign(N,vector<int>());\n    REP(i,N-1){\n        int a,b;\n        cin >> a >> b;\n\n        edge[--a].emplace_back(--b);\n        edge[b].emplace_back(a);\n    }\n\n    //一番遠い点へのパスに含まれる点は1度だけ通る\n    //他の辺は2度通る\n    \n\n    dfs(0,-1);\n    dfs_with_rerooting(0,-1,0);\n    for(auto a:ans){\n        cout << 2*(N-1)-a << bn;        \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\nusing edge = pair<int, long long>;\nusing Graph = vector<vector<edge>>;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\n\nGraph g;\nvector<long long> depth;\nvoid dfs(int u, int p) {\n    for (auto &e: g[u]) if (e.first != p) {\n        dfs(e.first, u);\n        chmax(depth[u], depth[e.first] + e.second);\n    }\n}\nvector<long long> height;\nvoid dfs2(int u, int p, int d_par) {\n    vector<pair<long long, int>> d_child;\n    d_child.emplace_back(0, -1);        // sentinel\n    for (auto &e: g[u]) {\n        long long dv = (e.first == p ? d_par : depth[e.first]) + e.second;\n        d_child.emplace_back(dv, e.first);\n    }\n    sort(d_child.rbegin(), d_child.rend());\n    height[u] = d_child[0].first;\n    for (auto &e: g[u]) if (e.first != p) {\n        long long nd_par = d_child[d_child[0].second == e.first].first;\n        dfs2(e.first, u, nd_par);\n    }\n}\n\nint main() {\n    int n; cin >> n;\n    g.resize(n);\n    for (int i = 0; i < n - 1; i++) {\n        int s, t; cin >> s >> t; s--, t--;\n        g[s].emplace_back(t, 1);\n        g[t].emplace_back(s, 1);\n    }\n    depth.resize(n);\n    dfs(0, -1);\n    height.resize(n);\n    dfs2(0, -1, 0);\n    for (auto h: height) cout << (n - 1) * 2 - h << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <queue>\n\ntemplate<class T>\nusing vec = std::vector<T>;\n\nusing Graph = vec<vec<int>>;\nusing pii   = std::pair<int, int>;\n\nconstexpr int INF = 1e9;\n\nvec<int> bfs(std::set<int> &s, Graph &G)\n{\n    vec<int> dist(G.size(), INF);\n    std::queue<pii> que; \n    for (auto &x: s) {\n        dist[x] = 0;\n        que.push(pii(0, x));    \n    }\n        \n    while (!que.empty()) {\n        pii p = que.front(); que.pop();\n        int v = p.second;\n        \n        for (int to : G[v]) {\n            if (dist[v] + 1 < dist[to]) {\n                dist[to] = dist[v] + 1;\n                que.push(pii(dist[to], to));                \n            }\n        }\n    }\n    \n    return dist;\n}\n\nint get_farthest_point(int v, Graph &G)\n{\n    std::set<int> st = {v};\n    auto vec = bfs(st, G);\n    int resv = -1, max = -1;\n    for (int i = 0; i < (int)G.size(); i++) {\n        if (max < vec[i]) {\n            max = vec[i];\n            resv = i;\n        }\n    }\n    return resv;\n}\n\nstd::set<int> res;\n\nvoid dfs(int v, int prev, int target, std::set<int> &td, Graph &G)\n{\n    td.insert(v);\n    if (v == target) {\n        res = td;\n        return;\n    }\n    \n    for (int to : G[v]) {\n        if (to == prev) continue;\n        dfs(to, v, target, td, G);\n    }\n    \n    td.erase(v);\n}\n\nvoid solve(Graph &G)\n{\n    int N = G.size();\n    int v0 = 0;\n    int v1 = get_farthest_point(v0, G);\n    int v2 = get_farthest_point(v1, G);\n    std::set<int> td, st1 = {v1}, st2 = {v2};\n    dfs(v1, -1, v2, td, G);\n\n    int cost = 0;\n    for (int i = 0; i < N; i++) {\n        if (!res.count(i)) {\n            cost += 2;\n        }\n    }\n    \n    vec<int> d1 = bfs(st1, G), d2 = bfs(st2, G), d3 = bfs(res, G);\n    for (int i = 0; i < N; i++) {\n        printf(\"%d\\n\", d2[v1] + std::min(d1[i], d2[i]) + cost - 2 * d3[i]);\n    }\n}\n\nint main()\n{   \n    int N, u, v;\n    scanf(\"%d\", &N);\n    \n    Graph G(N);\n    for (int i = 0; i < N - 1; i++) {\n        scanf(\"%d %d\", &u, &v); u--; v--;\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n    \n    solve(G);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1595\n\n#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n#include<complex>\n#include <cassert>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\nconst double PI=acos(-1);\nconst double EPS=1e-9; //うまくいかなかったらゆるめる\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef pair<pii,int> ppi;\ntypedef pair<int,pii> pip;\ntypedef vector<pii> vp;\ntypedef vector<vi> vvi;\n\nint gcd(int a, int b){if(b==0) return a;return gcd(b,a%b);}\nint lcm(int a, int b){return a/gcd(a,b)*b;}\n\n\nstruct edge{\n  int to, cost;\n};\nvector<vector<edge>  >g;\nvector<int> d;\n\nvoid dfs(int now, int par){\n    for(auto e: g[now])if(e.to != par){\n        dfs(e.to,now);\n        d[now] = max(d[now], d[e.to] + e.cost);\n    }\n}\n\nvoid dfs2(int now, int d_par, int par){\n    vp d_child;//深さ、頂点番号\n    d_child.push_back(pii(0,-1));\n    for(auto e: g[now]){\n        if(e.to == par){\n            d_child.push_back(pii(d_par + e.cost, e.to));\n        }else{\n            d_child.push_back(pii(d[e.to] + e.cost, e.to));\n        }\n    }\n    sort(all(d_child));\n    reverse(all(d_child));\n    d[now] = max(d[now], d_child[0].first);\n    for(auto e: g[now])if(e.to != par){\n        dfs2(e.to, d_child[d_child[0].second == e.to].first,now);\n    }\n}\n\nsigned main(void) {\n    int n;\n    cin >> n;\n    g.resize(n);\n    d = vi(n,0);\n    rep(i,n-1){\n        int a,b,c;\n        cin >> a >> b;\n        a--,b--;\n        edge e1 = {b,1};\n        g[a].push_back(e1);\n        edge e2 = {a,1};\n        g[b].push_back(e2);\n    }\n    dfs(0,-1);\n    //rep(i,n)cout << d[i] << endl;\n    dfs2(0,0,-1);\n    //rep(i,n)cout << d[i] << endl;\n    rep(i,n){\n        cout << (n-1)*2 - d[i] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define rrep(i,n) for(int i=(int)n-1;i>=0;--i)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\ntemplate<typename T> inline bool chmax(T& a,T b){if(a<b){a=b;return 1;}return 0;}\ntemplate<typename T> inline bool chmin(T& a,T b){if(b<a){a=b;return 1;}return 0;}\ntemplate<typename T> vector<T> make_vec(size_t a){return vector<T>(a);}\ntemplate<typename T,typename... Ts>\nauto make_vec(size_t a,Ts... ts){return vector<decltype(make_vec<T>(ts...))>(a,make_vec<T>(ts...));}\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T,U>::value>::type fill_v(U& u,const V... v){u=U(v...);}\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<!is_same<T,U>::value>::type fill_v(U& u,const V... v){for(auto& e:u)fill_v<T>(e,v...);}\n\ntemplate <typename T, typename Edge>\nstruct rerooting {\n    struct node {\n        int to, rev;\n        Edge data;\n        node(int to, Edge data) : to(to), data(data) {}\n        bool operator<(const node& v) const { return to < v.to;};\n    };\n\n    using F1 = function<T(T, T)>;\n    using F2 = function<T(T, Edge)>;\n\n    vector<vector<node>> g;\n    vector<vector<T>> ld, rd;\n    vector<int> lp, rp;\n\n    const F1 f1;\n    const F2 f2;\n    const T id;\n\n    rerooting(int n, const F1 f1, const F2 f2, const T id) :\n        g(n), ld(n), rd(n), lp(n), rp(n), f1(f1), f2(f2), id(id) {}\n\n    void add_edge(int u, int v, Edge d, Edge e) {\n        g[u].emplace_back(v, d);\n        g[v].emplace_back(u, e);\n    }\n\n    void add_edge(int u, int v, Edge d) { add_edge(u, v, d, d);}\n\n    // k : idx for edge (not vertex)\n    T dfs(int v, int k) {\n        while (lp[v] != k && lp[v] < (int)g[v].size()) {\n            auto& e = g[v][lp[v]];\n            ld[v][lp[v]+1] = f1(ld[v][lp[v]], f2(dfs(e.to, e.rev), e.data));\n            lp[v]++;\n        }\n        while (rp[v] != k && rp[v] >= 0) {\n            auto& e = g[v][rp[v]];\n            rd[v][rp[v]] = f1(rd[v][rp[v]+1], f2(dfs(e.to, e.rev), e.data));\n            rp[v]--;\n        }\n        if (k < 0) return rd[v][0];\n        return f1(ld[v][k], rd[v][k+1]);\n    }\n\n    int search(vector<node>& vs, int idx) {\n        return lower_bound(vs.begin(), vs.end(), node(idx, vs[0].data)) - vs.begin();\n    }\n    \n    vector<T> build() {\n        int n = g.size();\n        for (int i = 0; i < n; ++i) {\n            sort(g[i].begin(), g[i].end());\n            ld[i].assign((int)g[i].size() + 1, id);\n            rd[i].assign((int)g[i].size() + 1, id);\n            lp[i] = 0;\n            rp[i] = (int)g[i].size() - 1;\n        }\n        for (int i = 0; i < n; ++i) for (node& t : g[i]) t.rev = search(g[t.to], i);\n        \n        vector<T> res;\n        for (int i = 0; i < n; ++i) res.emplace_back(dfs(i, -1));\n\n        return res;\n    }\n\n    // p : idx for vertex\n    T subtree(int v, int p) {\n        int k = search(g[p], v);\n        assert(k < (int)g[p].size() && g[p][k].to == v);\n        return f2(dfs(v, g[p][k].rev), g[p][k].data);\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int n;\n    cin >> n;\n\n    auto f1 = [](int a, int b) { return max(a, b);};\n    auto f2 = [](int a, int b) { return a + b;};\n    rerooting<int, int> g(n, f1, f2, 0);\n    rep(i, n-1) {\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g.add_edge(u, v, 1);\n    }\n    for (int& x : g.build()) {\n        cout << 2 * (n-1) - x << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nint main(){\n  ll n,d,ans=0;\n  cin>>n>>d;\n  ans=(n-d-1)*(n-d-2)/2+d+min(d+1,3LL)*(n-d-1);\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <queue>\n#include <string>\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <map>\n#include <set>\n#include <functional>\n#include <iostream>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n;\nvector<int> G[100001];\nint dist[3][100001];\n\nvoid bfs(int id,int s){\n\tqueue<int> que;\n\tque.push(s);\n\tmemset(dist[id],-1,sizeof(dist[id]));\n\tdist[id][s]=0;\n\twhile(que.size()){\n\t\tint v=que.front();\n\t\tque.pop();\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tint next=G[v][i];\n\t\t\tif(dist[id][next]==-1){\n\t\t\t\tdist[id][next]=dist[id][v]+1;\n\t\t\t\tque.push(next);\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void){\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n-1;i++){\n\t\tint a,b;\n\t\tscanf(\"%d%d\",&a,&b);\n\t\ta--;\n\t\tb--;\n\t\tG[a].push_back(b);\n\t\tG[b].push_back(a);\n\t}\n\tbfs(0,0);\n\tint a=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(dist[0][a]<dist[0][i])a=i;\n\t}\n\tbfs(1,a);\n\tfor(int i=0;i<n;i++){\n\t\tif(dist[1][a]<dist[1][i])a=i;\n\t}\n\tbfs(2,a);\n\tfor(int i=0;i<n;i++){\n\t\tprintf(\"%d\\n\",(n-1)*2-max(dist[1][i],dist[2][i]));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n\nusing namespace std;\n\nint N;\nvector<vector<int>> E;\n\nint dp1[100000 + 100], dp2[100000 + 100];\n\nvoid dfs1(int pos, int bef) {\n\tfor (int i = 0; i < E[pos].size(); i++) {\n\t\tint nxt = E[pos][i];\n\t\tif (nxt == bef)continue;\n\t\tdfs1(nxt, pos);\n\t\tdp1[pos] = max(dp1[pos], dp1[nxt] + 1);\n\t}\n}\n\n//bef_infoは親方向での最長を伝播する\n//dp2[]はその頂点から木の末端まで行くときの最遠の距離\nvoid dfs2(int pos, int bef, int bef_info) {\n\tvector<pair<int, int>> sl;\n\tfor (int i = 0; i < E[pos].size(); i++) {\n\t\tint neighbor = E[pos][i];\n\t\tif (neighbor == bef) {\n\t\t\tdp2[pos] = max(dp2[pos], bef_info + 1);\n\t\t\tsl.push_back(make_pair(bef_info + 1, bef));\n\t\t}\n\t\telse {\n\t\t\tdp2[pos] = max(dp2[pos], dp1[neighbor] + 1);\n\t\t\tsl.push_back(make_pair(dp1[neighbor] + 1, neighbor));\n\t\t}\n\t}\n\t\n\tsort(sl.rbegin(), sl.rend());\n\t\n\tfor (int i = 0; i < E[pos].size(); i++) {\n\t\tint nxt = E[pos][i];\n\t\tif (nxt == bef)continue;\n\t\tdfs2(nxt, pos, sl[nxt == sl[0].second].first);\n\t}\n}\n\nint main() {\n\n\tcin >> N;\n\tE.resize(N);\n\tfor (int i = 0; i < N - 1; i++) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\tu--, v--;\n\t\tE[u].push_back(v), E[v].push_back(u);\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n\t\tif (E[i].size() < 2)continue;\n\t\tdfs1(i, -1);\n\t\tdfs2(i, -1, 114514);\n\n\t\tfor (int i = 0; i < N; i++)cout << (N - 1) * 2 - dp2[i] << endl;\n\t\treturn 0;\n\t}\n\tcout << 1 << endl << 1 << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define REP(i, n) for (ll i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (ll i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define fi first\n#define se second\n#define pb push_back\n#define debug(x) cerr << #x << \": \" << (x) << endl\n#define int long long\nusing namespace std;\nusing II = pair<int, int>;\nusing VII = vector<II>;\nusing VVII = vector<VII>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VVVI = vector<VVI>;\ntemplate <class T = int> inline T in() { T x; cin >> x; return x; }\ntemplate <class T = int> inline bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T = int> inline bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<T>& d) { int n = d.size(); REP (i, n) s << d[i] << \" \"; return s; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<vector<T>>& dd) { for (vector<T> d: dd) s << d << endl; return s; }\n// struct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nconst int MOD = 1e9 + 7;\n\nsigned main() {\n  int N = in();\n  VVI G(N);\n  REP (i, N - 1) {\n    int u, v; cin >> u >> v;\n    u--; v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  VVII dist(N); // {len, v}\n  VI far(N);\n  function<void (int, int)> dfs1 = [&](int v, int prev) {\n    for (int u: G[v]) if (u != prev) {\n      dfs1(u, v);\n      dist[v].push_back({far[u] + 1, u});\n      chmax(far[v], far[u] + 1);\n    }\n  };\n  dfs1(0, -1);\n\n  sort(RALL(dist[0]));\n  function<void (int, int)> dfs2 = [&](int v, int prev) {\n    for (int u: G[v]) if (u != prev) {\n      int tmp;\n      if (dist[v][0].se == u) {\n        tmp = dist[v].size() == 1 ? 0 : dist[v][1].fi;\n      } else {\n        tmp = dist[v][0].fi;\n      }\n      dist[u].pb({tmp + 1, v});\n      sort(RALL(dist[u]));\n      dfs2(u, v);\n    }\n  };\n  dfs2(0, -1);\n\n  REP (i, N) {\n    cout << 2 * (N - 1) - dist[i][0].fi << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// step[i] := ?????? 0 ????????¨????????¨????????????????????? i ???????????????????????¨????????¢\n// ans [i] := ?????? i ????????¨????????¨????????????????????? i ???????????????????????¨????????¢\n// ?????? i ??????????????????????????§???????????? 1 ???????????????????????????????????\\?????? 2 ?????????\n// ???????????£???????????????????????? 2 * (n-1) - ans[i] ??§??????\nint step[100010], ans[100010];\nvector< vector<int> > G;\n\nvoid dfs(int idx, int par) {\n    vector<int> rec;\n    for(int to : G[idx]) {\n        if(to == par) continue;\n        dfs(to, idx);\n        step[idx] = max(step[idx], step[to] + 1);\n    }\n}\n\nvoid dfs2(int idx, int d_par, int par) {\n    // printf(\"idx = %lld, d_par = %lld, par = %lld\\n\", idx, d_par, par);\n    vector<pii> rec;\n    for(int to : G[idx]) {\n        if(to == par) rec.push_back(pii(d_par + 1, to));\n        else rec.push_back(pii(step[to] + 1, to));\n    }\n    sort(rec.rbegin(), rec.rend());\n    ans[idx] = rec[0].first;\n    for(int to : G[idx]) {\n        if(to == par) continue;\n        dfs2(to, rec[ rec[0].second == to ].first, idx);\n    }\n}\n\nsigned main() {\n    memset(step, 0, sizeof(step));\n    memset(ans, 0, sizeof(ans));\n    int n; cin >> n;\n    G.resize(n);\n\n    rep(i,0,n-1) {\n        int u, v; cin >> u >> v;\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    dfs(0, -1);\n    dfs2(0, 0, -1);\n    rep(i,0,n) {\n        cout << (n-1) * 2 - ans[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nusing Graph = vector< vector<int> >;\n\nint step[100010], ans[100010];\nvoid dfs(Graph &G, int cur, int par=-1) {\n    vector<int> children;\n    for(auto to : G[cur]) {\n        if(to == par) continue;\n        dfs(G, to, cur);\n        step[cur] = max(step[cur], step[to] + 1);\n    }\n}\n\nvoid solve(Graph &G, int cur, int d_par, int par=-1) {\n    vector< pair<int, int> > children;\n    children.push_back(make_pair(0, -1));\n    for(auto to : G[cur]) {\n        if(to == par) children.push_back(make_pair(d_par + 1, to));\n        else children.push_back(make_pair(step[to] + 1, to));\n    }\n    sort(children.begin(), children.end(), greater< pair<int, int> >());\n\n    ans[cur] = children[0].first;\n    for(auto to : G[cur]) {\n        if(to == par) continue;\n        int nxt_d_par = children[children[0].second == to].first;\n        solve(G, to, nxt_d_par, cur);\n    }\n}\n\nint main() {\n    int N; scanf(\"%d\", &N);\n    Graph G(N);\n    for(int i=0; i<N-1; i++) {\n        int a, b; scanf(\"%d%d\", &a, &b);\n        a--; b--;\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    dfs(G, 0);\n    solve(G, 0, 0);\n    for(int i=0; i<N; i++) {\n        printf(\"%d\\n\", 2 * (N-1) - ans[i]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#ifdef LOCAL_DEBUG\n  #include \"LOCAL_DEBUG.hpp\"\n#endif\n#define int long long\nstruct edge{ int to, cost; };\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1595\nsigned main(){\n\n  int n; cin >> n;\n  vector<vector<edge>> G(n);\n  for(int i = 0; i < n-1; i++){\n    int a, b; cin >> a >> b;\n    a--, b--;\n    G[a].push_back({b, 1});\n    G[b].push_back({a, 1});\n  }\n\n  vector<int> dist(n, 0);\n  auto dfs = [&](auto&& dfs, int u, int par)->void{\n    for(edge e : G[u]){\n      if(e.to == par) continue;\n      dfs(dfs, e.to, u);\n      dist[u] = max(dist[u], dist[e.to] + e.cost);\n    }\n  };\n  dfs(dfs, 0, -1);\n\n  vector<int> dp(n, 0); //頂点iから最も遠い点までの距離\n  auto dfs2 = [&](auto&& dfs2, int u, int par, int d_par)->void{\n    vector<pair<int, int>> v;\n    v.push_back({0, -1});\n    for(edge e : G[u]){\n      v.push_back({(e.to == par ? d_par : dist[e.to]) + e.cost, e.to});\n    }\n    sort(v.rbegin(), v.rend());\n    dp[u] = v[0].first;\n\n    for(edge e : G[u]){\n      if(e.to == par) continue;\n      d_par = (e.to == v[0].second ? v[1].first : v[0].first);\n      dfs2(dfs2, e.to, u, d_par);\n    }\n  };\n  dfs2(dfs2, 0, -1, 0);\n\n  for(int i = 0; i < n; i++){\n    cout << 2 * (n - 1) - dp[i] << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n/*\n <url:http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1595>\n 問題文============================================================\n =================================================================\n 解説=============================================================\n ================================================================\n */\n\nstruct edge{\n    ll u,v,c;\n    edge():u(0),v(0),c(0){}\n    edge(ll u,ll v,ll c):u(u),v(v),c(c){}\n};\ntypedef vector<vector<edge>> Graph;\nGraph G;\nclass LCA{\npublic:\n    const ll n = 0;\n    const ll log2_n = 0;\n    vector<vector<ll>> parent;\n    vector<ll> depth;\n    LCA();\n    LCA(const Graph &g,ll root):n((ll)g.size()),log2_n(log2(n)+1),parent(log2_n,vector<ll>(n)),depth(n){\n        dfs(g,root,-1,0);\n        for(int k = 0; k+1 < log2_n; k++){\n            for(int v = 0; v < (int)g.size();v++){\n                if(parent[k][v] < 0) parent[k+1][v] = -1;\n                else parent[k+1][v] = parent[k][parent[k][v]];\n            }\n        }\n    }\n    \n    void dfs(const Graph &g,ll v,ll p,ll d){\n        parent[0][v] = p; depth[v] = d;\n        for(auto &e :g[v]){\n            if(e.v != p) dfs(g, e.v, v, d+1);\n        }\n    }\n    \n    ll get(ll u,ll v){\n        if(depth[u] > depth[v]) swap(u,v);\n        for(int k = 0; k < log2_n; k++){\n            if(((depth[v]-depth[u])>>k) & 1) v = parent[k][v];\n        }\n        if(u == v) return u;\n        for(int k = (int)log2_n - 1; k >= 0; k--){\n            if(parent[k][u] != parent[k][v]){\n                u = parent[k][u]; v = parent[k][v];\n            }\n        }\n        return parent[0][u];\n    }\n};\n\nvoid solve(){\n    ll n; cin >> n;\n    vector<vector<edge>> T(n);\n    for(int i = 0; i < n - 1;i++){\n        ll s,t; cin >> s >> t;\n        s--; t--;\n        T[s].emplace_back(edge(s,t,1));\n        T[t].emplace_back(edge(t,s,1));\n    }\n    ll v1,v2;\n    vector<ll> dist(n,INF);\n    queue<ll> q;\n    dist[0] = 0;\n    q.push(0);\n    while(q.size()){\n        ll next = q.front(); q.pop();\n        for(auto e:T[next]){\n            if(dist[e.v] > dist[e.u] + e.c){\n                dist[e.v] = dist[e.u] + e.c;\n                q.push(e.v);\n            }\n        }\n    }\n    v1 = max_element(dist.begin(), dist.end()) - dist.begin();\n\n    fill(dist.begin(),dist.end(),INF);\n    dist[v1] = 0;\n    q.push(v1);\n    while(q.size()){\n        ll next = q.front(); q.pop();\n        for(auto e:T[next]){\n            if(dist[e.v] > dist[e.u] + e.c){\n                dist[e.v] = dist[e.u] + e.c;\n                q.push(e.v);\n            }\n        }\n    }\n    v2 = max_element(dist.begin(), dist.end()) - dist.begin();\n    \n    LCA lca(T,v1);\n    ll V = 2*(n-1);\n    for(int i = 0; i < n;i++){\n        if(i == v2){\n            cout << V - dist[v2] << endl;\n            continue;\n        }\n        ll L = lca.get(i,v2);\n        cout << V - max((dist[i]+dist[v2] - 2*dist[L]),dist[i]) << endl;\n    }\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define all(x)  x.begin(), x.end()\n#define pii     pair<int, int>\n\nvector<int> g[101010];\nint dist[101010];\nint ans[101010];\n\nvoid dfs1(int v, int prev) {\n        for (auto u : g[v]) if (u != prev) {\n                dfs1(u, v);\n                dist[v] = max(dist[v], dist[u] + 1);\n        }\n}\n\nvoid dfs2(int v, int ma, int prev) {\n        vector<pii> children;\n        //children.emplace_back(0, -1);\n        for (auto u : g[v]) {\n                if (u == prev) children.emplace_back(ma + 1, u);\n                else children.emplace_back(dist[u] + 1, u);\n        }\n        sort(all(children), greater<pii>());\n        ans[v] = children[0].first;\n        for (auto u : g[v]) if (u != prev) dfs2(u, children[u == children[0].second ? 1 : 0].first, v);\n}\n\nint main() {\n        int n;\n        cin >> n;\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                cin >> a >> b;\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        dfs1(0, -1);\n        dfs2(0, 0, -1);\n        for (int i = 0; i < n; i ++) cout << (n - 1) * 2 - ans[i] << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\n#define rep(i, n) for (long long i = (long long)(0); i < (long long)(n); ++i)\n#define reps(i, n) for (long long i = (long long)(1); i <= (long long)(n); ++i)\n#define rrep(i, n) for (long long i = ((long long)(n)-1); i >= 0; i--)\n#define rreps(i, n) for (long long i = ((long long)(n)); i > 0; i--)\n#define irep(i, m, n) for (long long i = (long long)(m); i < (long long)(n); ++i)\n#define ireps(i, m, n) for (long long i = (long long)(m); i <= (long long)(n); ++i)\n#define SORT(v, n) sort(v, v + n);\n#define REVERSE(v, n) reverse(v, v+n);\n#define vsort(v) sort(v.begin(), v.end());\n#define all(v) v.begin(), v.end()\n#define mp(n, m) make_pair(n, m);\n#define cout(d) cout<<d<<endl;\n#define coutd(d) cout<<std::setprecision(10)<<d<<endl;\n#define cinline(n) getline(cin,n);\n#define replace_all(s, b, a) replace(s.begin(),s.end(), b, a);\n#define PI (acos(-1))\n#define FILL(v, n, x) fill(v, v + n, x);\n#define sz(x) long long(x.size())\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vs = vector<string>;\nusing vpll = vector<pair<ll, ll>>;\nusing vtp = vector<tuple<ll,ll,ll>>;\nusing vb = vector<bool>;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9+7;\nconst ll LINF = 1e18;\n\n// https://ei1333.hateblo.jp/entry/2017/04/10/224413\n\nvll G[100100];\nll dist[100100];\n\nvoid dfs1(ll v, ll p){\n  for(auto &nv: G[v]){\n    if(nv==p) continue;\n    dfs1(nv,v);\n    chmax(dist[v],dist[nv]+1);\n  }\n}\n\nll ans[100100];\nvoid dfs2(ll v, ll parent, ll p){\n  vpll child;\n  child.emplace_back(0,-1);\n  for(auto &nv: G[v]){\n    if(nv==p) child.emplace_back(parent+1, nv);\n    else child.emplace_back(dist[nv]+1, nv);\n  }\n  sort(child.rbegin(),child.rend());\n  ans[v]=child[0].first;\n  for(auto &nv: G[v]){\n    if(nv==p) continue;\n    dfs2(nv, child[child[0].second==nv].first, v);\n  }\n}\n\nsigned main()\n{\n  cin.tie( 0 ); ios::sync_with_stdio( false );\n  ll n; cin>>n;\n  rep(i,n-1){\n    ll a,b; cin>>a>>b; a--,b--;\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  \n  dfs1(0,-1);\n  dfs2(0,0,-1);\n  rep(i,n){\n    // ある頂点からスタートしてその頂点に戻ってくるためのコストはどの頂点であっても必ず (n-1)*2 となる(行って戻ってくることを考えるとどの辺も2回ずつ通るため)\n    // この往復距離から、その頂点からの最遠距離を引いたものが全ての頂点を回るための最短距離となる\n    cout<<(n-1)*2-ans[i]<<endl;\n  }\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\nvvi adj;\nvi des, des_back, asc, asc_back;\n\nvoid dfs1(int v, int p) {\n    i64 dif = 0;\n    vi ds_back;\n    for (int s: adj[v]) {\n        if (s != p) {\n            dfs1(s, v);\n            dif = max(dif, des_back[s] - des[s]);\n            ds_back.push_back(des_back[s] + 2);\n        }\n    }\n    i64 all = accumulate(ds_back.begin(), ds_back.end(), 0);\n    des_back[v] = all;\n    if (p == -1 || adj[v].size() > 1) dif++;\n    des[v] = all - dif;\n}\n\nvoid dfs2(int v, int p) {\n    using ii = pair<i64, int>;\n    vector<ii> difs = {ii(0, 0)};\n    for (int s: adj[v]) {\n        if (s != p) {\n            difs.push_back(ii(des_back[s] - des[s], s));\n            asc_back[s] = des_back[v] - des_back[s] + asc_back[v];\n        }\n    }\n    sort(difs.begin(), difs.end(), greater<>());\n    for (int s: adj[v]) {\n        if (s != p) {\n            asc[s] = min(des_back[v] - des_back[s] + asc[v] - 1, asc_back[v] - difs[difs[0].second == s].first + des_back[v] - des_back[s] - 1 - (difs.size() > 2));\n            dfs2(s, v);\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    adj = vvi(n);\n    des = vi(n, 1e18);\n    des_back = vi(n, 1e18);\n    asc = vi(n, 1e18);\n    asc_back = vi(n, 1e18);\n\n    for (int i = 0; i < n - 1; i++) {\n        int s, t;\n        cin >> s >> t;\n        s--;\n        t--;\n        adj[s].push_back(t);\n        adj[t].push_back(s);\n    }\n\n    dfs1(0, -1);\n    for (int i = 0; i < n; i++) {\n        cout << \"des\" << i + 1 << \" \" << des[i] << endl;\n        cout << \"des_back\" << i + 1 << \" \" << des_back[i] << endl;\n    }\n\n    asc[0] = 0;\n    asc_back[0] = 0;\n    dfs2(0, -1);\n    for (int i = 0; i < n; i++) {\n        cout << \"asc\" << i + 1 << \" \" << asc[i] << endl;\n        cout << \"asc_back\" << i + 1 << \" \" << asc_back[i] << endl;\n    }\n\n    for (int i = 0; i < n; i++) {\n        cout << min(des[i] + asc_back[i], des_back[i] + asc[i]) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n\n#define REP(i, k, n) for(int i = k; i < n; i++)\n#define rep(i, n) for(int i = 0; i < n; i++) \n#define mp make_pair\n\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<P, P> PP;\n\nvector<vector<int> > g;\nP cnt[100005][2];\nbool used[100005];\n\nvoid dfs(int cur) {\n\tused[cur] = true;\n\n\tvector<P> res;\n\t// cout << \" -- in dfs --- \" << cur << endl;\n\trep(i, g[cur].size()) {\n\t\tint to = g[cur][i];\n\t\tif(used[to]) continue;\n\t\t// cout << \"to \" << cur << \" \" << to << endl;\n\n\t\tdfs(to);\n\t\tres.push_back(mp(cnt[to][0].first + 1, to));\n\t\t// cout << \"push \" << cur << \" \" << cnt[to][0].first + 1 << \" \" << to << endl;\n\t}\n\n\tsort(res.begin(), res.end(), greater<P>());\n\trep(i, min((int)res.size(), 2)) {\n\t\tcnt[cur][i] = res[i];\n\t}\n\t//\n\t// cout << \" --- in dfs ---  : \" << cur << endl;\n\t// rep(i, res.size()) {\n\t// \tcout << res[i].first << \" \" << res[i].second << endl;\n\t// }\n\t// cout << \"ret : \" << cnt[cur][0].first << endl;\n}\n\nint ans[100005];\n\nvoid solve(int cur, int prev, int len) {\n\tint res = cnt[cur][0].first;\n\tint newlen = len;\n\n\t// if(prev != -1) {\n\t// \trep(j, g[prev].size()) {\n\t// \t\tint to = g[prev][j];\n\t// \t\tif(to == cur) continue;\n\t// \t\tnewlen = max(newlen, cnt[to][0].first);\n\t// \t}\n\t// }\n\n\tans[cur] = max(res, newlen);\n\n\trep(i, g[cur].size()) {\n\t\tint to = g[cur][i];\n\t\tif(to == prev) continue;\n\t\tint x = 0;\n\n\t\tif(to == cnt[cur][0].second) {\n\t\t\tx = cnt[cur][1].first;\n\t\t} else {\n\t\t\tx = cnt[cur][0].first;\n\t\t}\n\n\t\tsolve(to, cur, max(x, newlen) + 1);\n\t}\n}\n\nint main() {\n\tint N;\n\tcin >> N;\n\n\tg.resize(N);\n\trep(i, N-1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\ta--; b--;\n\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\trep(i, N) {\n\t\tcnt[i][0].first = 0;\n\t\tcnt[i][1].first = 0;\n\n\t\tcnt[i][0].second = -1;\n\t\tcnt[i][1].second = -1;\n\t}\n\n\tint root = 0;\n\tmemset(used, 0, sizeof(used));\n\tdfs(root);\n\n\t// rep(i, N) {\n\t// \tcout << \" ----- i : \" << i << endl;\n\t// \tcout << cnt[i][0].first << \" \" << cnt[i][0].second << endl;\n\t// \tcout << cnt[i][1].first << \" \" << cnt[i][1].second << endl;\n\t// }\n\n\tmemset(ans, 0, sizeof(ans));\n\tsolve(0, -1, 0);\n\n\trep(i, N) {\n\t\tcout << 2 * (N - 1) - ans[i] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;++i)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n\nusing namespace std;\n\n#define MAX 100010\n\nint n;\nvector<int> G[MAX];\nint d[MAX];\n\nint dfs(int cur, int pre) {\n  int &ans = d[cur];\n  if( ans != -1 ) return ans;\n  ans = 0;\n  rep(i,(int)G[cur].size()) {\n    int nex = G[cur][i];\n    if( pre == nex ) continue;\n    ans = max(ans,dfs(nex,cur)+1);\n  }\n  return ans;\n}\n\nint answer[MAX];\nvoid dfs2(int cur, int pre, int d_par) {\n\n  vector<int> cumulative_L, cumulative_R;\n  rep(i,(int)G[cur].size()) {\n    int nex = G[cur][i];\n    int v = ( nex == pre ) ? (d_par+1) : (d[nex]+1);\n    cumulative_L.pb(v);\n    cumulative_R.pb(v);\n  }\n  \n  REP(i,1,(int)cumulative_L.size()) cumulative_L[i] = max(cumulative_L[i], cumulative_L[i-1]);\n  for(int i=(int)cumulative_R.size()-2;i>=0;--i) cumulative_R[i] = max(cumulative_R[i], cumulative_R[i+1]);\n\n  answer[cur] = cumulative_L.back();\n\n  rep(i,(int)G[cur].size()) {\n    int nex = G[cur][i];\n    if( nex == pre ) continue;\n    int vL = (i-1>=0)?cumulative_L[i-1]:0;\n    int vR = (i+1<(int)cumulative_R.size())?cumulative_R[i+1]:0;\n    dfs2(nex, cur, max(vL,vR));\n  }\n  \n}\n\nbool debug = 1;\n\nvoid solve() {\n  memset(d,-1,sizeof d);\n  dfs(0,-1);\n  //rep(i,n) cout << i << \"-th: \" << d[i] << endl;\n  dfs2(0,-1,0);\n  //puts(\"---\");\n  //rep(i,n) cout << i << \"-th: \" << answer[i] << endl;\n  rep(i,n) cout << (n-1)*2-answer[i] << endl;\n}\n\nint main() {\n  scanf(\"%d\",&n);\n  rep(i,n-1) {\n    int s,t;\n    scanf(\"%d%d\",&s,&t);\n    --s, --t;\n    G[s].pb(t);\n    G[t].pb(s);\n  }\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nvector<vector<int> > edges;\nmap<pair<int, int>, int> memo;\n\nint solve(int curr0, int prev0)\n{\n    stack<tuple<int, int, int, int> > stk;\n    stk.push(make_tuple(curr0, prev0, 0, 0));\n\n    for(;;){\n        int curr, prev, i, ans;\n        tie(curr, prev, i, ans) = stk.top();\n        stk.pop();\n\n        if(i == 0){\n            if(memo.find(make_pair(curr, prev)) != memo.end())\n                continue;\n        }\n        else{\n            int next = edges[curr][i-1];\n            if(next != prev)\n                ans = max(ans, memo[make_pair(next, curr)] + 1);\n        }\n        if(i == edges[curr].size()){\n            memo[make_pair(curr, prev)] = ans;\n            if(stk.empty())\n                return ans;\n            else\n                continue;\n        }\n\n        stk.push(make_tuple(curr, prev, i + 1, ans));\n        int next = edges[curr][i];\n        if(next != prev)\n            stk.push(make_tuple(next, curr, 0, 0));\n    }\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    edges.resize(n);\n    for(int i=0; i<n-1; ++i){\n        int u, v;\n        cin >> u >> v;\n        -- u;\n        -- v;\n        edges[u].push_back(v);\n        edges[v].push_back(u);\n    }\n\n    for(int i=0; i<n; ++i){\n        int ans = 2 * (n - 1) - solve(i, -1);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\n\nconstexpr int INF = INT_MAX;\n\nvector<vector<int> > g;\nvector<int> d, dmax;\n\nvoid dfs(int v){\n    for(auto u : g[v]){\n        if(d[u] > d[v]+1){\n            d[u] = d[v]+1;\n            dfs(u);\n        }\n    }\n}\n\nint main() {\n    int n;\n    cin >> n;\n    g.resize(n);\n    d.resize(n);\n    dmax.resize(n);\n    for(int i=0;i<n-1;i++){\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    int s = 0, t = 0;\n    for(int i=0;i<3;i++){\n        fill(d.begin(), d.end(), INF);\n        d[s] = 0;\n        dfs(s);\n        int maxi = -1;\n        for(int i=0;i<n;i++){\n            if(d[i] > maxi){\n                maxi = d[i];\n                t = i;\n            }\n        }\n        swap(s,t);\n    }\n    dmax = d;\n    fill(d.begin(), d.end(), INF);\n    d[s] = 0;\n    dfs(s);\n    for(int i=0;i<n;i++){\n        dmax[i] = max(dmax[i], d[i]);\n    }\n    for(int i=0;i<n;i++){\n        cout << 2*(n-1) - dmax[i] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#define debug(x) cerr << #x << \" = \" << x << endl;\n\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 100010\n\n\nvector<int> way[SIZE];\n\npair<int,int> dfs(int now, int back=-1,int h=0){\n  pair<int,int> ret = {h,now};\n\n  for(int i=0;i<way[now].size();i++){\n    if(way[now][i] != back)\n      ret = max(dfs(way[now][i],now,h+1),ret);\n  }\n\n  return ret;\n}\n\nint ans[SIZE];\n\nvoid dfs2(int now, int back=-1,int h=0){\n\n  ans[now] = max(ans[now],h);\n  for(int i=0;i<way[now].size();i++){\n    if(way[now][i] != back)\n      dfs2(way[now][i],now,h+1);\n  }\n\n  return;\n}\n\nint main(){\n  int n;\n  int u,v;\n  \n  scanf(\"%d\",&n);\n\n  for(int i=0;i<n-1;i++){\n    scanf(\"%d%d\",&u,&v);\n    v--; u--;\n    way[u].push_back(v);\n    way[v].push_back(u);\n  }\n\n  int p1,p2;\n  \n  pair<int,int> ret;\n  ret = dfs(0);\n  p1 = ret.second;\n  ret = dfs(p1);\n  p2 = ret.second;\n\n  dfs2(p1);\n  dfs2(p2);\n\n  for(int i=0;i<n;i++){\n    printf(\"%d\\n\",(n-1)*2-ans[i]);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int MAX = 1e5 + 10;\nint N;\nvector<int> G[MAX];\nint dist[MAX], step[MAX];\n\nint dfs1(int now, int prev) {\n    for (auto &&e : G[now]) {\n        if (e != prev) {\n            dist[now] = max(dist[now], dfs1(e, now) + 1);\n        }\n    }\n    return dist[now];\n}\n\nvoid dfs2(int now, int par, int d_par) {\n    vector<pair<int, int>> children;\n    children.emplace_back(0, -1);\n    for (auto &&e : G[now]) {\n        if (e == par) {\n            children.emplace_back(d_par + 1, e);\n        } else {\n            children.emplace_back(dist[e] + 1, e);\n        }\n    }\n    sort(rbegin(children), rend(children));\n    step[now] = ((N - 1) << 1) - children[0].first;\n    for (auto &&e : G[now]) {\n        if (e != par) {\n            dfs2(e, now, children[children[0].second == e].first);\n        }\n    }\n}\n\nint main() {\n    scanf(\"%d\", &N);\n    for (int i = 0; i < N - 1; i++) {\n        int a, b, c;\n        scanf(\"%d%d\", &a, &b);\n        a--; b--;\n        G[a].emplace_back(b);\n        G[b].emplace_back(a);\n    }\n    dfs1(0, -1);\n    dfs2(0, -1, 0);\n    for (int i = 0; i < N; i++) {\n        printf(\"%d\\n\", step[i]);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\ntypedef pair< int, int > pii;\n\ntemplate< typename T > void maxUpdate(T& a, T b) { a = max(a, b); }\n\nint N, dst[100010];\nvector< vector< int > > adj;\n\npii dfs(int v, int p, int dep) {\n\tpii res(dep, v);\n\tfor (int u : adj[v]) if (u != p) maxUpdate(res, dfs(u, v, dep + 1));\n\treturn res;\n}\n\nvoid rec(int v, int p, int dep) {\n\tmaxUpdate(dst[v], dep);\n\tfor (int u : adj[v]) if (u != p) rec(u, v, dep + 1);\n}\n\nvoid solve() {\n\tmemset(dst, 0, sizeof(dst));\n\t\n\tpii p1 = dfs(0, -1, 0);\n\tpii p2 = dfs(p1.second, -1, 0);\n\t\t\n\trec(p1.second, -1, 0);\n\trec(p2.second, -1, 0);\n\t\n\tfor_(v,0,N) cout << 2 * (N - 1) - dst[v] << endl;\n}\n\nint main() {\n\tcin >> N;\n\tadj.assign(N, vector< int >());\n\tfor_(i,0,N-1) {\n\t\tint u, v;\n\t\tcin >> u >> v;\n\t\t--u; --v;\n\t\tadj[u].push_back(v);\n\t\tadj[v].push_back(u);\n\t}\n\tsolve();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define REP(i, n) for (ll i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (ll i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define fi first\n#define se second\n#define pb push_back\n#define debug(x) cerr << #x << \": \" << (x) << endl\n#define int long long\nusing namespace std;\nusing II = pair<int, int>;\nusing VII = vector<II>;\nusing VVII = vector<VII>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VVVI = vector<VVI>;\ntemplate <class T = int> inline T in() { T x; cin >> x; return x; }\ntemplate <class T = int> inline bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T = int> inline bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<T>& d) { int n = d.size(); REP (i, n) s << d[i] << \" \"; return s; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<vector<T>>& dd) { for (vector<T> d: dd) s << d << endl; return s; }\n// struct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nconst int MOD = 1e9 + 7;\n\nsigned main() {\n  int N = in();\n  VVI G(N);\n  REP (i, N - 1) {\n    int u, v; cin >> u >> v;\n    u--; v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  VVII dist(N); // {len, v}\n  VI far(N);\n  function<void (int, int)> dfs1 = [&](int v, int prev) {\n    for (int u: G[v]) if (u != prev) {\n      dfs1(u, v);\n      dist[v].push_back({far[u] + 1, u});\n      chmax(far[v], far[u] + 1);\n    }\n  };\n  dfs1(0, -1);\n\n  sort(RALL(dist[0]));\n  function<void (int, int)> dfs2 = [&](int v, int prev) {\n    for (int u: G[v]) if (u != prev) {\n      int tmp;\n      if (dist[v][0].se == u) {\n        tmp = dist[v].size() == 1 ? 0 : dist[v][1].fi;\n      } else {\n        tmp = dist[v][0].fi;\n      }\n      debug(tmp);\n      dist[u].pb({tmp + 1, v});\n      sort(RALL(dist[u]));\n      dfs2(u, v);\n    }\n  };\n  dfs2(0, -1);\n\n  REP (i, N) {\n    cout << 2 * (N - 1) - dist[i][0].fi << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)m ; i < (int) n ; ++i )\n#define rep(i,n) REP(i,0,n)\ntypedef long long ll;\ntypedef pair<int,int> pint;\ntypedef pair<ll,int> pli;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nvector<int> v[101010],ret[101010];\nint ans[101010];\n\nint dfs(int x,int p){\n    ret[x].push_back(0);\n    for(auto to:v[x]){\n        if(to==p)continue;\n        ret[x].push_back(dfs(to,x));\n    }\n    sort(ret[x].begin(),ret[x].end(),greater<>());\n    return ret[x][0]+1;\n}\n\nvoid dfs2(int x,int p){\n    int res=ret[x][0];\n    if(x){\n        if(ret[p][0]!=res+1)ret[x].push_back(ret[p][0]+1);\n        else ret[x].push_back(ret[p][1]+1);\n    }\n    sort(ret[x].begin(),ret[x].end(),greater<>());\n    for(auto to:v[x]){\n        if(to==p)continue;\n        dfs2(to,x);\n    }\n    ans[x]=ret[x][0];\n}\n\nint main(){\n    int n;\n    cin>>n;\n    rep(i,n-1){\n        int a,b;\n        cin>>a>>b;\n        --a;--b;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    dfs(0,-1);\n    dfs2(0,-1);\n    rep(i,n)cout<<2*(n-1)-ans[i]<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nconst int N = 100000;\n\nint n;\nvector<int> G[N];\n\n// ??°??£????????????????????????/??????\npi dp1[N];\nvoid dfs(int v, int par)\n{\n    int res = 0;\n    for(int nx:G[v])if(nx!=par)\n    {\n        dfs(nx,v);\n        res += dp1[nx].fi+2;\n    }\n\n    int notback = res;\n    for(int nx:G[v])if(nx!=par)\n    {\n        int t = res;\n        t -= dp1[nx].fi+2;\n        t += dp1[nx].se+1;\n        notback = min(notback,t);\n    }\n\n    dp1[v] = {res,notback};\n}\n\nint dp2[N];\nvoid dfs2(int v, int par, pi d)\n{\n    vector<pair<pi,int>> c;\n    for(int nx:G[v])if(nx!=par) c.pb({dp1[nx],nx});\n    c.pb({d,-1});\n\n    int C = c.size();\n    int sum = 0;\n    rep(i,C) sum += c[i].fi.fi+2;\n\n    // second????????¶?????¨????????£?????????????????????(?°?????????????????¬???????)\n    // (??????,??????)\n    vector<pi> gain;\n\n    int ans = sum;\n    rep(i,C)\n    {\n        int t = sum;\n        int g = c[i].fi.se+1 - (c[i].fi.fi+2);\n        t += g;\n        ans = min(ans,t);\n\n        gain.pb({g,c[i].se});\n    }\n    dp2[v] = ans;\n\n    sort(all(gain));\n    // printf(\" NOW: v= %d\\n\", v);\n    // rep(i,C) dbg(gain[i]);\n\n    rep(i,C)\n    {\n        int nx = gain[i].se;\n        if(nx==-1) continue;\n\n        pi nd;\n        nd.fi = sum - (dp1[nx].fi+2);\n\n        nd.se = nd.fi;\n        if(i==0)\n        {\n            if(C>1) nd.se += gain[1].fi;\n        }\n        else nd.se += gain[0].fi;\n\n        dfs2(nx,v,nd);\n    }\n}\n\nint main()\n{\n    cin >>n;\n    rep(i,n-1)\n    {\n        int u,v;\n        cin >>u >>v;\n        --u;\n        --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    dfs(0,-1);\n    // rep(i,n) printf(\" %d:  (%d %d)\\n\", i,dp1[i].fi,dp1[i].se);\n\n    dfs2(0,-1,{-2,-1});\n    rep(i,n) cout << dp2[i] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define ALL(x) x.begin(),x.end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define debug(v) cout<<#v<<\":\";for(auto x:v){cout<<x<<' ';}cout<<endl;\n#define INF 1000000000\n#define mod 1000000007\nusing ll=long long;\nconst ll LINF=1001002003004005006ll;\nint dx[]={1,0,-1,0};\nint dy[]={0,1,0,-1};\n// ll gcd(ll a,ll b){return b?gcd(b,a%b):a;}\ntemplate<class T>bool chmax(T &a,const T &b){if(a<b){a=b;return true;}return false;}\ntemplate<class T>bool chmin(T &a,const T &b){if(b<a){a=b;return true;}return false;}\n\ntemplate<typename T>\nstruct rerooting{\n    using F=function<T(T,int)>;//集合，頂点番号\n    using M=function<T(T,T)>;\n\n    int V;\n    vector<vector<int>> G;\n    vector<vector<T>> dp;\n    vector<T> ans;\n    // dp_v = g(merge(f(dp_c1,c1),...,f(dp_ck,ck)),v)\n    F f,g;  // TxN->T\n    M merge;// TxT->T，子を集約する関数，モノイド\n    T gen;\n    //gen: mergeの元\n    rerooting(int V,F f,M merge,T gen,F g=[](T a,int b){return a;})\n        :V(V),f(f),merge(merge),gen(gen),g(g),G(V),dp(V),ans(V,gen){}\n    \n    //bidirectional\n    void add_edge(int a,int b){\n        G[a].push_back(b);\n        G[b].push_back(a);\n    }\n    T dfs1(int pre,int now){\n        T ret=gen;\n        for(int i=0;i<G[now].size();i++)if(G[now][i]!=pre){\n            dp[now][i]=dfs1(now,G[now][i]);\n            ret=merge(ret,f(dp[now][i],G[now][i]));\n        }\n        return g(ret,now);\n    }\n    void dfs2(int pre,int now,T frompar){\n        for(int i=0;i<G[now].size();i++){\n            if(G[now][i]==pre){\n                dp[now][i]=frompar;\n                break;\n            }\n        }\n        vector<T> lsum(G[now].size()+1),rsum(G[now].size()+1);//親も混ぜて累積\n        lsum[0]=gen;rsum[G[now].size()]=gen;\n        for(int i=0;i<G[now].size();i++) lsum[i+1]=merge(lsum[i],f(dp[now][i],G[now][i]));\n        for(int i=G[now].size();i>0;i--) rsum[i-1]=merge(rsum[i],f(dp[now][i-1],G[now][i-1]));\n        for(int i=0;i<G[now].size();i++)if(G[now][i]!=pre){\n            T fromme=merge(lsum[i],rsum[i+1]);\n            dfs2(now,G[now][i],g(fromme,now));\n        }\n    }\n    void build(int root=0){\n        for(int i=0;i<V;i++) dp[i].resize(G[i].size());\n        dfs1(-1,root);\n        dfs2(-1,root,gen);\n        for(int i=0;i<V;i++){\n            for(int j=0;j<G[i].size();j++) ans[i]=merge(ans[i],f(dp[i][j],G[i][j]));\n            ans[i]=g(ans[i],i);\n        }\n    }\n};\n\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    \n    auto f=[&](pair<int,int> ch,int v){return make_pair(ch.second-ch.first+1,ch.second+2);};\n    auto merge=[&](pair<int,int> l,pair<int,int> r){return make_pair(max(l.first,r.first),l.second+r.second);};\n    auto g=[&](pair<int,int> mg,int v){return make_pair(mg.second-mg.first,mg.second);};\n\n    int n;cin>>n;\n    rerooting<pair<int,int>> R(n,f,merge,make_pair(0,0),g);\n    rep(i,n-1){\n        int u,v;cin>>u>>v;u--,v--;\n        R.add_edge(u,v);\n    }\n    R.build();\n    rep(i,n)cout<<R.ans[i].first<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dx[]={1, -1, 0, 0};\nint dy[]={0, 0, 1, -1};\nint const MOD = 1000000007;\nll mod_pow(ll x, ll n) {return (!n)?1:(mod_pow((x*x)%MOD,n/2)*((n&1)?x:1))%MOD;}\nint madd(int a, int b) {return (a + b) % MOD;}\nint msub(int a, int b) {return (a - b + MOD) % MOD;}\nint mmul(int a, int b) {return (a * b) % MOD;}\nint minv(int a) {return mod_pow(a, MOD-2);}\nint mdiv(int a, int b) {return mmul(a, minv(b));}\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\n// step[i] := ?????? 0 ????????¨????????¨????????????????????? i ???????????????????????¨????????¢\n// ans [i] := ?????? i ????????¨????????¨????????????????????? i ???????????????????????¨????????¢\n// ?????? i ??????????????????????????§???????????? 1 ???????????????????????????????????\\?????? 2 ?????????\n// ???????????£???????????????????????? 2 * (n-1) - ans[i] ??§??????\nint step[100010], ans[100010];\nvector< vector<int> > G;\n\nvoid dfs(int idx, int par) {\n    for(int &to : G[idx]) {\n        if(to == par) continue;\n        dfs(to, idx);\n        step[idx] = max(step[idx], step[to] + 1);\n    }\n}\n\nvoid dfs2(int idx, int d_par, int par) {\n    // printf(\"idx = %lld, d_par = %lld, par = %lld\\n\", idx, d_par, par);\n    vector<pii> rec;\n    rec.push_back(pii(0, -1));\n    for(int &to : G[idx]) {\n        if(to == par) rec.push_back(pii(d_par + 1, to));\n        else rec.push_back(pii(step[to] + 1, to));\n    }\n    sort(rec.rbegin(), rec.rend());\n    ans[idx] = rec[0].first;\n    for(int &to : G[idx]) {\n        if(to == par) continue;\n        dfs2(to, rec[ rec[0].second == to ].first, idx);\n    }\n}\n\nsigned main() {\n    memset(step, 0, sizeof(step));\n    memset(ans, 0, sizeof(ans));\n    int n; cin >> n;\n    G.resize(n);\n\n    rep(i,0,n-1) {\n        int u, v; cin >> u >> v;\n        u--; v--;\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    dfs(0, -1);\n    dfs2(0, 0, -1);\n    rep(i,0,n) {\n        cout << (n-1) * 2 - ans[i] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < int(n); i++)\n#define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--)\n#define reps(i, n) for (int i = 1; i <= int(n); i++)\n#define rreps(i, n) for (int i = int(n); i >= 1; i--)\n#define repc(i, n) for (int i = 0; i <= int(n); i++)\n#define rrepc(i, n) for (int i = int(n); i >= 0; i--)\n#define repi(i, a, b) for (int i = int(a); i < int(b); i++)\n#define repic(i, a, b) for (int i = int(a); i <= int(b); i++)\n#define each(x, y) for (auto &x : y)\n#define all(a) (a).begin(), (a).end()\n#define bit(b) (1ll << (b))\n\nusing namespace std;\n\nusing i32 = int;\nusing i64 = long long;\nusing u64 = unsigned long long;\nusing f80 = long double;\nusing vi32 = vector<i32>;\nusing vi64 = vector<i64>;\nusing vu64 = vector<u64>;\nusing vf80 = vector<f80>;\nusing vstr = vector<string>;\n\ninline void yes() { cout << \"Yes\" << '\\n'; exit(0); }\ninline void no() { cout << \"No\" << '\\n'; exit(0); }\ninline i64 gcd(i64 a, i64 b) { if (min(a, b) == 0) return max(a, b); if (a % b == 0) return b; return gcd(b, a % b); }\ninline i64 lcm(i64 a, i64 b) { return a / gcd(a, b) * b; }\ninline u64 xorshift() { static u64 x = 88172645463325252ull; x = x ^ (x << 7); return x = x ^ (x >> 9); }\nvoid solve(); int main() { ios::sync_with_stdio(0); cin.tie(0); cout << fixed << setprecision(16); solve(); return 0; }\ntemplate <typename T> class pqasc : public priority_queue<T, vector<T>, greater<T>> {};\ntemplate <typename T> class pqdesc : public priority_queue<T, vector<T>, less<T>> {};\ntemplate <typename T> inline void amax(T &x, T y) { if (x < y) x = y; }\ntemplate <typename T> inline void amin(T &x, T y) { if (x > y) x = y; }\ntemplate <typename T> inline T power(T x, i64 n, T e = 1) { T r = e; while (n > 0) { if (n & 1) r *= x; x *= x; n >>= 1; } return r; }\ntemplate <typename T> istream& operator>>(istream &is, vector<T> &v) { each(x, v) is >> x; return is; }\ntemplate <typename T> ostream& operator<<(ostream &os, vector<T> &v) { rep(i, v.size()) { if (i) os << ' '; os << v[i]; } return os; }\ntemplate <typename T, typename S> istream& operator>>(istream &is, pair<T, S> &p) { is >> p.first >> p.second; return is; }\ntemplate <typename T, typename S> ostream& operator<<(ostream &os, pair<T, S> &p) { os << p.first << ' ' << p.second; return os; }\n\nstruct UnWeightedGraph {\n  vector<vector<int>> edges;\n  int n;\n  UnWeightedGraph(int n) : n(n) {\n    edges = vector<vector<int>>(n);\n  }\n  void add_edge(int from, int to) {\n    edges[from].push_back(to);\n  }\n  vector<int>& operator[](int x) {\n    return edges[x];\n  }\n};\n\nvoid solve() {\n  int N; cin >> N;\n  auto graph = UnWeightedGraph(N);\n  rep(i, N - 1) {\n    int v, u; cin >> v >> u;\n    v--, u--;\n    graph.add_edge(v, u);\n    graph.add_edge(u, v);\n  }\n\n  vector<vi32> dp(N);\n  vector<int> par(N, -1);\n  vector<int> ans(N);\n\n  function<int(int, int)> dfs = [&](int v, int p) {\n    int n = graph[v].size();\n    dp[v] = vi32(n);\n\n    int ret = 0;\n    rep(i, n) {\n      int u = graph[v][i];\n      if (u == p) {\n        par[v] = i;\n        continue;\n      }\n      dp[v][i] = dfs(u, v) + 1;\n      amax(ret, dp[v][i]);\n    }\n    return ret;\n  };\n\n  function<void(int, int, int)> bfs = [&](int v, int res_p, int p) {\n    if (p != -1) {\n      dp[v][par[v]] = res_p;\n    }\n    int n = graph[v].size();\n\n    vi32 dpl(n + 1), dpr(n + 1);\n    rep(i, n) dpl[i + 1] = max(dpl[i], dp[v][i]);\n    rrep(i, n) dpr[i] = max(dpr[i + 1], dp[v][i]);\n\n    ans[v] = dpr[0];\n\n    rep(i, n) {\n      if (i == par[v]) continue;\n      int u = graph[v][i];\n      bfs(u, max(dpl[i], dpr[i + 1]) + 1, v);\n    }\n  };\n\n  dfs(0, -1);\n  bfs(0, 0, -1);\n\n  rep(i, N) {\n    cout << (N - 1) * 2 - ans[i] << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define REP(i, n) for (ll i = 0, max_i = (n); i < max_i; i++)\n#define REPI(i, a, b) for (ll i = (a), max_i = (b); i < max_i; i++)\n#define ALL(obj) (obj).begin(), (obj).end()\n#define RALL(obj) (obj).rbegin(), (obj).rend()\n#define fi first\n#define se second\n#define pb push_back\n#define debug(x) cerr << #x << \": \" << (x) << endl\n#define int long long\nusing namespace std;\nusing II = pair<int, int>;\nusing VII = vector<II>;\nusing VVII = vector<VII>;\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing VVVI = vector<VVI>;\ntemplate <class T = int> inline T in() { T x; cin >> x; return x; }\ntemplate <class T = int> inline bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate <class T = int> inline bool chmin(T &a, const T &b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<T>& d) { int n = d.size(); REP (i, n) s << d[i] << \" \"; return s; }\ntemplate <class T> ostream& operator<<(ostream &s, const vector<vector<T>>& dd) { for (vector<T> d: dd) s << d << endl; return s; }\nstruct Fast { Fast() { cin.tie(0); ios::sync_with_stdio(false); } } fast;\nconst int MOD = 1e9 + 7;\n\nsigned main() {\n  int N = in();\n  VVI G(N);\n  REP (i, N - 1) {\n    int u, v; cin >> u >> v;\n    u--; v--;\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n  VVII dist(N); // {len, v}\n  VI far(N);\n  function<void (int, int)> dfs1 = [&](int v, int prev) {\n    for (int u: G[v]) if (u != prev) {\n      dfs1(u, v);\n      dist[v].push_back({far[u] + 1, u});\n      chmax(far[v], far[u] + 1);\n    }\n  };\n  dfs1(0, -1);\n\n  sort(RALL(dist[0]));\n  function<void (int, int)> dfs2 = [&](int v, int prev) {\n    for (int u: G[v]) if (u != prev) {\n      int tmp;\n      if (dist[v][0].se == u) {\n        tmp = dist[v].size() == 1 ? 0 : dist[v][1].fi;\n      } else {\n        tmp = dist[v][0].fi;\n      }\n      debug(tmp);\n      dist[u].pb({tmp + 1, v});\n      sort(RALL(dist[u]));\n      dfs2(u, v);\n    }\n  };\n  dfs2(0, -1);\n\n  REP (i, N) {\n    cout << 2 * (N - 1) - dist[i][0].fi << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef int LL;\ntypedef int ut;\ntypedef pair<ut,ut> pr;\ntypedef vector<ut> VI;\ntypedef vector<pr> Vpr;\ntypedef priority_queue<pr,Vpr,greater<pr> > PQ;\nconst int SIZE=2*1e5;\n//const ut INF=1LL<<60;\nVI edge[SIZE];\nbool dead[SIZE];\nLL ans[SIZE];\nbool searched[SIZE];\nint needs[SIZE];\nint grav[SIZE];\nint dist[SIZE];\nint nums[SIZE];\nint sums[SIZE];\nint times[SIZE];\nint depthest[SIZE];\nint timer;\nVpr depters[SIZE];\nint depther[SIZE];\nLL dfs(int start,int bad,VI& nodes,int depth,bool want){\n\tint ans=0;\n\tqueue<pr> st;\n\tst.push(pr(start,bad)); \n\tdepther[start]=depth;\n\twhile(!st.empty()){\n\t\tint now=st.front().first,from=st.front().second;\n\t\tst.pop();\n\t\tif(dead[now]){\n\t\t\tif(from!=depters[now][0].second)  ans=max(ans,depters[now][0].first+depther[now]);\n\t\t\t ans=max(ans,depters[now][1].first+depther[now]);\n\t\t\tcontinue;\n\t\t}\n\t\ttimer++;\n\t\tif(want)\n\t\t\tnodes.PB(now);\n\t\t//cout << now << \" \" << depth << endl;\n\t\tans=max(ans,depther[now]);\n\t\tREP(i,edge[now].size()){\n\t\t\tint next=edge[now][i];\n\t\t\tif(next!=from){\n\t\t\t\tdepther[next]=depther[now]+1;\n\t\t\t\tst.push(pr(next,now));\n\t\t\t}\n\t\t}\n\t}\n\t//cout << start <<\" \" << ans << endl;\n\treturn ans;\n}\n/*\nvoid gives(int now,int from,int depth,LL alls,LL nodes){\n\tans[now]+=depth*nodes+alls;\n\tREP(i,edge[now].size()){\n\t\tint next=edge[now][i];\n\t\tif(next!=from && !dead[next])\n\t\t\tgives(next,now,depth+1,alls,nodes);\n\t}\n}*/\nvoid centerize(int now,VI& nodes){\n\tcat;\n\tdead[now]=true;\n\tVI dummy;\n//\tLL alls=0;\n\t//cout << now;\n\tREP(i,edge[now].size()){\n\t\ttimer=0;\n\t\tint next=edge[now][i];\n\t\t//if(dead[next]) continue;\n\t\tdepters[now].PB(pr(dfs(next,now,dummy,1,false),next));\n\t//\tcout << depters[now].back().first;\n//\t\tnums[i]=timer;\n//\t\talls+=sums[i];\n\t}\n\tdummy.clear();\n\t//cout << endl;\n\tdepters[now].PB(pr(0,-1));\n\tsort(ALL(depters[now]),greater<pr>());\n//\tans[now]+=alls;\n//\tREP(i,edge[now].size()){\n//\t\tint next=edge[now][i];\n//\t\tif(dead[next]) continue;\n//\t\tgives(next,now,1,alls-sums[i],nodes.size()-nums[i]);\n//\t\talls+=sums[i];\n//\t}\n\tcat;\t\n}\n\nvoid solve(int now){\n\tcat;\n\tVI nodes;\n\tPQ qu;\n\tdfs(now,-1,nodes,1,true);\n\tcat;\n\tint last=nodes[0];\n\tcat;\n\tcat;\n\tREP(i,nodes.size()){\n\t\tneeds[nodes[i]]=-1;\n\t\tsearched[nodes[i]]=false;\n\t\tgrav[nodes[i]]=0;\n\t\tREP(j,edge[nodes[i]].size()){\n\t\t\tint next=edge[nodes[i]][j];\n\t\t\tif(!dead[next]) needs[nodes[i]]++;\n\t\t}\n\n\t\tif(needs[nodes[i]]==0) qu.push(pr(0,nodes[i]));\n\t}\n\tcat;\n\twhile(!qu.empty()){\n\t\tint now=qu.top().second,gravity=qu.top().first;\n\t\tqu.pop();\n\t\tsearched[now]=true;\n\t\tlast=now;\n\t\tREP(i,edge[now].size()){\n\t\t\tint next=edge[now][i];\n\t\t\tif(dead[next]) continue;\n\t\t\tif(searched[next]) continue;\n\t\t\tgrav[next]+=grav[now]+1;\n\t\t\ttimes[next]++;\n\t\t\tif(times[next]==needs[next]) qu.push(pr(grav[next],next));\n\t\t}\n\n\t}\n\tcenterize(last,nodes);\n\tnodes.clear();\n\tREP(i,edge[last].size()){\n\t\tint next=edge[last][i];\n\t\tif(dead[next]) continue;\n\t\tsolve(next);\n\t}\n}\nint main(){\n\tint N,u,v;\n\tcin >> N;\n\tREP(i,N-1){\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tedge[u].PB(v);\n\t\tedge[v].PB(u);\n\t}\n\tsolve(1);\n\tFOR(i,1,N+1){\n\t\tprintf(\"%d\\n\",N*2-2-depters[i][0].first);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define each(it,v) for(__typeof((v).begin()) it=(v).begin();it!=(v).end();it++)\n#define INF 1<<30\n#define mp make_pair\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nvector<int> g[100005];\n\n// cost, index\npair<int, int> dfs(int cur, int prev) {\n\tpair<int, int> ret(0, cur);\n\trep(i, g[cur].size()) {\n\t\tint to = g[cur][i];\n\t\tif(to == prev) continue;\n\t\tpair<int, int> t = dfs(to, cur);\n\t\tt.first++;\n\t\tif(ret.first < t.first) ret = t;\n\t}\n\treturn ret;\n}\n\nint root = 0;\nint parent[20][100005];\nint depth[100005];\n\nvoid dfs2(int v, int p, int d) {\n\tparent[0][v] = p;\n\tdepth[v] = d;\n\trep(i, g[v].size()) {\n\t\tif(g[v][i] != p) dfs2(g[v][i], v, d+1);\n\t}\n}\n\nvoid init(int V) {\n\tdfs2(root, -1, 0);\n\tfor(int k = 0; k + 1 < 20; k++) {\n\t\trep(v, V) {\n\t\t\tif(parent[k][v] < 0) parent[k + 1][v] = -1;\n\t\t\telse parent[k + 1][v]= parent[k][parent[k][v]];\n\t\t}\n\t}\n}\n\nint lca(int u, int v) {\n\tif(depth[u] > depth[v]) swap(u, v);\n\trep(k, 20) {\n\t\tif((depth[v] - depth[u]) >> k & 1) {\n\t\t\tv = parent[k][v];\n\t\t}\n\t}\n\tif(u == v) return u;\n\tfor(int k = 20 - 1; k >= 0; k--) {\n\t\tif(parent[k][u] != parent[k][v]) {\n\t\t\tu = parent[k][u];\n\t\t\tv = parent[k][v];\n\t\t}\n\t}\n\treturn parent[0][u];\n}\n\nint main() {\n\tint n;\n\tcin >> n;\n\n\trep(i, n-1) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\n\t\ta--; b--;\n\n\t\tg[a].push_back(b);\n\t\tg[b].push_back(a);\n\t}\n\n\t// cout << \"input\" << endl;\n\t// rep(i, n) {\n\t// \tcout << \" i : \" << i << \" | \";\n\t// \trep(j, g[i].size()) cout << g[i][j] << \" \";\n\t// \tcout << endl;\n\t// }\n\n\n\tP s = dfs(0, -1);\n\tP t = dfs(s.second, -1);\n\t// cout << s.second << \" \" << t.second << endl;\n\n\tinit(n);\n\n\trep(i, n) {\n\t\tint c = lca(i, s.second);\n\t\tint a = (depth[i] - depth[c]) + (depth[s.second] - depth[c]);\n\n\t\tint d = lca(i, t.second);\n\t\tint b = (depth[i] - depth[d]) + (depth[t.second] - depth[d]);\n\n\t\tcout << 2 * (n - 1) - max(a, b) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*  -*- coding: utf-8 -*-\n *\n * 1595.cc: Traffic Tree\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 100000;\n\n/* typedef */\n\ntypedef vector<int> vi;\ntypedef queue<int> qi;\n\n/* global variables */\n\nvi nbrs[MAX_N];\nint ps[MAX_N], cns[MAX_N];\nint ts0[MAX_N], ts1[MAX_N], rs0[MAX_N], rs1[MAX_N];\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n;\n  scanf(\"%d\", &n);\n\n  for (int i = 1; i < n; i++) {\n    int u, v;\n    scanf(\"%d%d\", &u, &v);\n    u--, v--;\n    nbrs[u].push_back(v);\n    nbrs[v].push_back(u);\n  }\n\n  ps[0] = -1;\n  qi q;\n  q.push(0);\n\n  while (! q.empty()) {\n    int u = q.front(); q.pop();\n    //printf(\"%d: ps=%d\\n\", u, ps[u]);\n    int &up = ps[u];\n    vi &nbru = nbrs[u];\n    for (vi::iterator vit = nbru.begin(); vit != nbru.end(); vit++) {\n      int &v = *vit;\n      if (v != up) {\n\tcns[u]++;\n\tps[v] = u;\n\tq.push(v);\n      }\n    }\n  }\n\n  for (int u = 0; u < n; u++)\n    if (cns[u] == 0) q.push(u);\n\n  while (! q.empty()) {\n    int u = q.front(); q.pop();\n    int &up = ps[u], ut0 = ts0[u] + 1;\n\n    if (up >= 0) {\n      if (ts0[up] < ut0)\n\tts1[up] = ts0[up], ts0[up] = ut0;\n      else if (ts1[up] < ut0)\n\tts1[up] = ut0;\n      if (--cns[up] == 0) q.push(up);\n    }\n  }\n  //for (int i = 0; i < n; i++) printf(\"%d: %d,%d\\n\", i, ts0[i], ts1[i]);\n\n  q.push(0);\n\n  while (! q.empty()) {\n    int u = q.front(); q.pop();\n    int &up = ps[u];\n\n    rs0[u] = ts0[u], rs1[u] = ts1[u];\n    if (up >= 0) {\n      int pr = ((rs0[up] == ts0[u] + 1) ? rs1[up] : rs0[up]) + 1;\n      if (rs0[u] < pr)\n\trs1[u] = rs0[u], rs0[u] = pr;\n      else if (rs1[u] < pr)\n\trs1[u] = pr;\n    }\n\n    vi &nbru = nbrs[u];\n    for (vi::iterator vit = nbru.begin(); vit != nbru.end(); vit++) {\n      int &v = *vit;\n      if (v != up) q.push(v);\n    }\n  }\n\n  int sum = (n - 1) * 2;\n  for (int i = 0; i < n; i++) printf(\"%d\\n\", sum - rs0[i]);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nconst double PI  = 3.1415926535897932384626433832795028841971;\nconst int    INF = 1000000007;\nconst double EPS = 1e-10;\nconst int    MOD = 1000000007;\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> PP;\n\nint n;\nbool saw[100000];\nvector<int> d[100000];\nvector<int> v[100000];\n\nint dfs(int x){\n    int ret = 0;\n    saw[x] = true;\n    d[x].push_back(0);\n    rep(i,v[x].size()){\n        if(saw[v[x][i]]) continue;\n        d[x].push_back(dfs(v[x][i]));\n        ret = max(ret,d[x][d[x].size()-1]);\n    }\n    return ret+1;\n}\n\nvoid dfs2(int x, int dep){\n    saw[x] = true;\n    rep(i,v[x].size()){\n        if(!saw[v[x][i]]) continue;\n        if(1+d[x][0] != d[v[x][i]][0]){\n            d[x].push_back(d[v[x][i]][0]+1);\n        } else{\n            if(d[v[x][i]].size() == 1) d[x].push_back(1);\n            else d[x].push_back(d[v[x][i]][1]+1);\n        }\n    }\n    sort(d[x].begin(),d[x].end(),greater<int>());\n    rep(i,v[x].size()){\n        if(saw[v[x][i]]) continue;\n        dfs2(v[x][i],dep+1);\n    }\n}\n\nint main(){\n    cin >> n;\n    rep(i,n-1){\n        int a, b;\n        scanf(\"%d%d\",&a,&b);\n        a--; b--;\n        v[a].push_back(b);\n        v[b].push_back(a);\n    }\n    dfs(0);\n    rep(i,n) sort(d[i].begin(),d[i].end(),greater<int>());\n    rep(i,n) saw[i] = false;\n    dfs2(0,0);\n    rep(i,n) printf(\"%d\\n\",(n-1)*2-d[i][0]);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate<typename Data, typename T>\nstruct ReRooting {\n\n    struct Node {\n        int to, rev;\n        Data data;\n    };\n\n    using F1 = function<T(T, T)>;\n    using F2 = function<T(T, Data)>;\n\n    vector<vector<Node> > g;\n    vector<vector<T> > ldp, rdp;\n    vector<int> lptr, rptr;\n    const F1 f1;\n    const F2 f2;\n    const T ident;\n\n    // ident: dp配列の初期値\n    // f2: 子頂点のDP配列の値を処理する演算\n    // f1: f2で処理された値をDP配列にマージする演算\n    ReRooting(int n, const F1 &f1, const F2 &f2, const T &ident) :\n            g(n), ldp(n), rdp(n), lptr(n), rptr(n), f1(f1), f2(f2), ident(ident) {}\n\n    void add_edge(int u, int v, const Data &d) {\n        g[u].emplace_back((Node) {v, (int) g[v].size(), d});\n        g[v].emplace_back((Node) {u, (int) g[u].size() - 1, d});\n    }\n\n    void add_edge_bi(int u, int v, const Data &d, const Data &e) {\n        g[u].emplace_back((Node) {v, (int) g[v].size(), d});\n        g[v].emplace_back((Node) {u, (int) g[u].size() - 1, e});\n    }\n\n\n    T dfs(int idx, int par) {\n        while (lptr[idx] != par && lptr[idx] < g[idx].size()) {\n            auto &e = g[idx][lptr[idx]];\n            ldp[idx][lptr[idx] + 1] = f1(ldp[idx][lptr[idx]], f2(dfs(e.to, e.rev), e.data));\n            ++lptr[idx];\n        }\n        while (rptr[idx] != par && rptr[idx] >= 0) {\n            auto &e = g[idx][rptr[idx]];\n            rdp[idx][rptr[idx]] = f1(rdp[idx][rptr[idx] + 1], f2(dfs(e.to, e.rev), e.data));\n            --rptr[idx];\n        }\n        if (par < 0) return rdp[idx][0];\n        return f1(ldp[idx][par], rdp[idx][par + 1]);\n    }\n\n    vector<T> solve() {\n        for (int i = 0; i < g.size(); i++) {\n            ldp[i].assign(g[i].size() + 1, ident);\n            rdp[i].assign(g[i].size() + 1, ident);\n            lptr[i] = 0;\n            rptr[i] = (int) g[i].size() - 1;\n        }\n        vector<T> ret;\n        for (int i = 0; i < g.size(); i++) {\n            ret.push_back(dfs(i, -1));\n        }\n        return ret;\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n\n    int n;\n    cin >> n;\n\n    auto f2 = [&](vector<int> a, int d) -> vector<int> {\n        a[0] += d;\n        a[1] = 0;\n        return a;\n    };\n    auto f1 = [&](vector<int> a, const vector<int> b) -> vector<int> {\n        for (int c : b) a.push_back(c);\n        sort(a.rbegin(), a.rend());\n        a.pop_back();\n        a.pop_back();\n        return a;\n    };\n\n    ReRooting<int, vector<int>> g(n, f1, f2, {0, 0});\n    for (int i = 0; i < n - 1; i++) {\n        int a, b;\n        cin >> a >> b;\n        a--, b--;\n        g.add_edge(a, b, 1);\n    }\n    for (auto &p : g.solve()) {\n        cout << 2 * (n - 1) - max(p[0], p[1]) << '\\n';\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <iostream>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\nint n;\nvector<int> g[100000];\nint dmx[100000];\nbool used[100000];\nvoid dfs(int x){\n\tused[x]=1;\n\tfor(auto y:g[x]){\n\t\tif(used[y]) continue;\n\t\tdfs(y);\n\t\tdmx[x]=max(dmx[y]+1, dmx[x]);\n\t}\n}\nint dmx1[100000], ans[100000];\nvoid dfs2(int x){\n\tused[x]=1;\n\tint mx=0, mx2=0;\n\tfor(auto y:g[x]){\n\t\tif(used[y]){\n\t\t\tif(mx<dmx1[x]){\n\t\t\t\tmx2=mx;\n\t\t\t\tmx=dmx1[x];\n\t\t\t}else if(mx2<dmx1[x]){\n\t\t\t\tmx2=dmx1[x];\n\t\t\t}\n\t\t}else{\n\t\t\tif(mx<dmx[y]+1){\n\t\t\t\tmx2=mx;\n\t\t\t\tmx=dmx[y]+1;\n\t\t\t}else if(mx2<dmx[y]+1){\n\t\t\t\tmx2=dmx[y]+1;\n\t\t\t}\n\t\t}\n\t}\n\tfor(auto y:g[x]){\n\t\tif(used[y]) continue;\n\t\tif(mx==dmx[y]+1){\n\t\t\tdmx1[y]=mx2+1;\n\t\t}else{\n\t\t\tdmx1[y]=mx+1;\n\t\t}\n\t}\n\tans[x]=2*(n-1)-max(dmx[x], dmx1[x]);\n\tfor(auto y:g[x]){\n\t\tif(!used[y]) dfs2(y);\n\t}\n}\n\nint main()\n{\n\tcin>>n;\n\tfor(int i=0; i<n-1; i++){\n\t\tint u, v;\n\t\tcin>>u>>v;\n\t\tu--; v--;\n\t\tg[u].push_back(v);\n\t\tg[v].push_back(u);\n\t}\n\tdfs(0);\n\tfill(used, used+n, 0);\n\tdfs2(0);\n\tfor(int i=0; i<n; i++) cout<<ans[i]<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\n\n#define int long long\n\nvector<int>v[200009];\nint dp[300003];\nint ans[300003];\nint n , mod=1000000007  , m ;\n\nvoid dfs( int now , int pre ) {\n  dp[now] = 0;\n  r(i,v[now].size()){\n    int nex = v[now][i];\n    if( pre == nex )continue;\n    dfs( nex , now );\n    dp[now] = max( dp[now] , dp[nex] + 1 ) % mod;\n  }\n}\n\nvoid dfs2( int now , int pre , int x ) {\n\n  ans[now] = max( dp[now] , x) % mod;\n\n  vector<int> l , r;\n  int N = v[now].size() + 1;\n\n  l.push_back( 0 );\n\n  r( i , v[now].size() ){\n    int nex = v[now][i];\n    int w = nex==pre ? x : dp[nex]+1 ;\n    l.push_back( w );\n    r.push_back( w );\n  }\n\n  r.push_back( 0 );\n\n  for( int i = 1 ; i < N ; i++ ){\n    l[i] = max( l[i] , l[i-1] ) % mod;\n  }\n\n  for( int i = N-2 ; i >= 0 ; i-- ){\n    r[i] = max( r[i] , r[i+1] );\n  }\n\n  for( int i = 0 ; i < v[now].size() ; i++ ){\n    if( v[now][i] == pre )continue;\n    dfs2( v[now][i] , now ,  max(l[i],r[i+1])+1 );\n  }\n\n}\n\n\n\nsigned main(){\n  cin>>n;\n\n  r(i,n-1){\n    int a,b;\n    cin>>a>>b;a--;b--;\n    v[a].push_back(b);\n    v[b].push_back(a);\n  }\n\n  dfs(0,0);\n  dfs2(0,0,0);\n\n  r(i,n) cout<<(n-1)*2-ans[i]<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nvector<int> g[100000];//edge\nint dist[100000],ans[100000];//dist[i]:(今回だと)0を根とした時のiから子孫への最長パスの長さ,ans[i]:iから最も遠い点への長さ\n\nvoid dfs1(int idx,int par){\n  for(int &to:g[idx]) {\n    if(to==par)continue;\n    dfs1(to,idx);\n    dist[idx]=max(dist[idx],dist[to]+1);\n  }\n}\n\nvoid dfs2(int idx,int d_par,int par){//idxを根としたケース,parは（今回だと）0が根の時のidxの親、d_parはparを端とするidxを含まない最長パスの長さ\n  vector<pair<int,int>> d_child;//idxを根とした時の各子を伝っての最長パスの長さ\n  d_child.emplace_back(0,-1);//番兵っぽいやつ\n  for(int &to:g[idx]){\n    if(to==par)d_child.emplace_back(d_par+1,to);\n    else d_child.emplace_back(dist[to]+1,to);\n  }\n  sort(d_child.rbegin(),d_child.rend());\n  ans[idx]=d_child[0].first;\n  for(int &to:g[idx]) {\n    if(to==par)continue;\n    dfs2(to,d_child[d_child[0].second==to].first,idx);\n  }\n}\n\nint main(){\n  int N;\n  cin>>N;\n  for(int i=0;i<N-1;i++){\n    int a,b;cin>>a>>b;a--;b--;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n  dfs1(0,-1);//0を根とした根付き木に対してdist[i]が子孫への最長パスの長さ\n  dfs2(0,0,-1);//ans[i]が求まる\n  for(int i=0;i<N;i++)cout<<(N-1)*2-ans[i]<<endl;//最も遠い葉への道だけ一回しか通らない\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define INF (1e9)\n#define N 100005\nusing namespace std;\nint n,a,b,p1,p2,u,maxd,cnt,ans[N];\nbool used[N],t[N];\nvector<int> e[N];\n\nvoid dfs(int x,int d){\n  if(used[x])return;\n  used[x]=true;\n  if(maxd<d)maxd=d,u=x;\n  for(int i=0;i<e[x].size();i++)\n    dfs(e[x][i],d+1);\n}\n\nint dfs2(int x){\n  int res=false;\n  if(used[x])return res;\n  if(x==p2)res=true;\n  used[x]=true;\n  for(int i=0;i<e[x].size();i++)\n    res|=dfs2(e[x][i]);\n  cnt+=res;\n  return t[x]=res;\n}\n\nvoid dfs3(int x,int d){\n  if(used[x])return;\n  used[x]=true;\n  if(t[x])ans[x]=min(ans[x],d);\n  for(int i=0;i<e[x].size();i++)\n    dfs3(e[x][i],d+1);\n}\n\nvoid dfs4(int x,int d){\n  if(used[x])return;\n  used[x]=true;\n  ans[x]=d;\n  for(int i=0;i<e[x].size();i++)\n    dfs4(e[x][i],d-1);\n}\n\nint main(){\n  cin>>n;\n  for(int i=0;i<n-1;i++){\n    cin>>a>>b; a--, b--;\n    e[a].push_back(b);\n    e[b].push_back(a);\n  }\n  for(int i=0;i<n;i++)ans[i]=INF;\n  maxd=0; dfs(0,0);  p1=u;\n  memset(used,0,sizeof(used));\n  maxd=0; dfs(p1,0); p2=u;\n  memset(used,0,sizeof(used));\n  dfs2(p1);\n  memset(used,0,sizeof(used));\n  dfs3(p1,2*n-cnt-1);\n  memset(used,0,sizeof(used));\n  dfs3(p2,2*n-cnt-1);\n  memset(used,0,sizeof(used));\n  for(int i=0;i<n;i++)\n    if(t[i]){\n      used[i]=true;\n      for(int j=0;j<e[i].size();j++)\n\tif(!t[e[i][j]])dfs4(e[i][j],ans[i]-1);\n    }\n  for(int i=0;i<n;i++)\n    cout<<ans[i]<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nvector<vector<int> > edges;\nmap<pair<int, int>, int> memo;\n\nint solve(int curr, int prev)\n{\n    if(memo.find(make_pair(curr, prev)) != memo.end())\n        return memo[make_pair(curr, prev)];\n\n    int ans = 0;\n    for(int next : edges[curr]){\n        if(next != prev)\n            ans = max(ans, solve(next, curr) + 1);\n    }\n    return memo[make_pair(curr, prev)] = ans;\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    edges.resize(n);\n    for(int i=0; i<n-1; ++i){\n        int u, v;\n        cin >> u >> v;\n        -- u;\n        -- v;\n        edges[u].push_back(v);\n        edges[v].push_back(u);\n    }\n\n    for(int i=0; i<n; ++i){\n        int ans = 2 * (n - 1) - solve(i, -1);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 998244353;\n\nconst int64 infll = (1LL << 62) - 1;\nconst int inf = (1 << 30) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\n\ntemplate< typename T1, typename T2 >\nostream &operator<<(ostream &os, const pair< T1, T2 > &p) {\n  os << p.first << \" \" << p.second;\n  return os;\n}\n\ntemplate< typename T1, typename T2 >\nistream &operator>>(istream &is, pair< T1, T2 > &p) {\n  is >> p.first >> p.second;\n  return is;\n}\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename F >\nstruct FixPoint : F {\n  FixPoint(F &&f) : F(forward< F >(f)) {}\n\n  template< typename... Args >\n  decltype(auto) operator()(Args &&... args) const {\n    return F::operator()(*this, forward< Args >(args)...);\n  }\n};\n\ntemplate< typename F >\ninline decltype(auto) MFP(F &&f) {\n  return FixPoint< F >{forward< F >(f)};\n}\n\ntemplate< typename sum_t, typename key_t >\nstruct ReRooting {\n  struct Edge {\n    int to;\n    key_t data;\n    sum_t dp, ndp;\n  };\n\n  using F = function< sum_t(sum_t, sum_t) >;\n  using G = function< sum_t(sum_t, key_t) >;\n\n  vector< vector< Edge > > g;\n  vector< sum_t > subdp, dp;\n  const sum_t ident;\n  const F f;\n  const G gg;\n\n  ReRooting(int V, const F f, const G g, const sum_t &ident)\n      : g(V), f(f), gg(g), ident(ident), subdp(V, ident), dp(V, ident) {}\n\n  void add_edge(int u, int v, const key_t &d) {\n    g[u].emplace_back((Edge) {v, d, ident, ident});\n    g[v].emplace_back((Edge) {u, d, ident, ident});\n  }\n\n  void add_edge_bi(int u, int v, const key_t &d, const key_t &e) {\n    g[u].emplace_back((Edge) {v, d, ident, ident});\n    g[v].emplace_back((Edge) {u, e, ident, ident});\n  }\n\n  void dfs_sub(int idx, int par) {\n    for(auto &e : g[idx]) {\n      if(e.to == par) continue;\n      dfs_sub(e.to, idx);\n      subdp[idx] = f(subdp[idx], gg(subdp[e.to], e.data));\n    }\n  }\n\n  void dfs_all(int idx, int par, const sum_t &top) {\n    sum_t buff{ident};\n    for(int i = 0; i < (int) g[idx].size(); i++) {\n      auto &e = g[idx][i];\n      e.ndp = buff;\n      e.dp = gg(par == e.to ? top : subdp[e.to], e.data);\n      buff = f(buff, e.dp);\n    }\n    dp[idx] = buff;\n    buff = ident;\n    for(int i = (int) g[idx].size() - 1; i >= 0; i--) {\n      auto &e = g[idx][i];\n      if(e.to != par) dfs_all(e.to, idx, f(e.ndp, buff));\n      e.ndp = f(e.ndp, buff);\n      buff = f(buff, e.dp);\n    }\n  }\n\n  vector< sum_t > build() {\n    dfs_sub(0, -1);\n    dfs_all(0, -1, ident);\n    return dp;\n  }\n};\n\n\nint main() {\n  int N, D;\n  cin >> N;\n\n  auto f1 = [](int a, int b) {\n    return max(a, b);\n  };\n\n  auto f2 = [](int a, int data) {\n    return a + data;\n  };\n\n  ReRooting< int, int > g(N, f1, f2, 0);\n  for(int i = 1; i < N; i++) {\n    int s, t;\n    cin >> s >> t;\n    --s, --t;\n    g.add_edge(s, t, 1);\n  }\n  for(auto &p : g.build()) {\n    cout << (N - 1) * 2 - p << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,b) FOR(i,0,b)\n#define PB push_back\n#define ALL(c) c.begin(),c.end()\n#define cat //cout << __LINE__ << endl;\nusing namespace std;\ntypedef long long LL;\ntypedef LL ut;\ntypedef pair<ut,ut> pr;\ntypedef vector<ut> VI;\ntypedef vector<pr> Vpr;\ntypedef priority_queue<pr,Vpr,greater<pr> > PQ;\nconst int SIZE=3*1e5;\nconst ut INF=1LL<<60;\nVI edge[SIZE];\nbool dead[SIZE];\nLL ans[SIZE];\nbool searched[SIZE];\nint needs[SIZE];\nint grav[SIZE];\nint dist[SIZE];\nint nums[SIZE];\nint sums[SIZE];\nint times[SIZE];\nint depthest[SIZE];\nint timer;\nVpr depters[SIZE];\nLL dfs(int now,int from,VI& nodes,int depth){\n\tif(dead[now]){\n\t\tif(from!=depters[now][0].second) return depters[now][0].first+depth;\n\t\treturn depters[now][1].first+depth;\n\t}\n\ttimer++;\n\tnodes.PB(now);\n\tLL ans=dist[now]=depth;\n\t//cout << now << \" \" << depth << endl;\n\tREP(i,edge[now].size()){\n\t\tint next=edge[now][i];\n\t\tif(next!=from)\n\t\t\tans=max(ans,dfs(next,now,nodes,depth+1));\n\t}\n\treturn ans;\n}\n/*\nvoid gives(int now,int from,int depth,LL alls,LL nodes){\n\tans[now]+=depth*nodes+alls;\n\tREP(i,edge[now].size()){\n\t\tint next=edge[now][i];\n\t\tif(next!=from && !dead[next])\n\t\t\tgives(next,now,depth+1,alls,nodes);\n\t}\n}*/\nvoid centerize(int now,VI& nodes){\n\tcat;\n\tdead[now]=true;\n\tVI dummy;\n//\tLL alls=0;\n\t//cout << now;\n\tREP(i,edge[now].size()){\n\t\ttimer=0;\n\t\tint next=edge[now][i];\n\t\t//if(dead[next]) continue;\n\t\tdepters[now].PB(pr(dfs(next,now,dummy,1),next));\n\t//\tcout << depters[now].back().first;\n//\t\tnums[i]=timer;\n//\t\talls+=sums[i];\n\t}\n\t//cout << endl;\n\tdepters[now].PB(pr(0,-1));\n\tsort(ALL(depters[now]),greater<pr>());\n//\tans[now]+=alls;\n//\tREP(i,edge[now].size()){\n//\t\tint next=edge[now][i];\n//\t\tif(dead[next]) continue;\n//\t\tgives(next,now,1,alls-sums[i],nodes.size()-nums[i]);\n//\t\talls+=sums[i];\n//\t}\n\tcat;\t\n}\n\nvoid solve(int now){\n\tcat;\n\tVI nodes;\n\tPQ qu;\n\tdfs(now,-1,nodes,1);\n\tcat;\n\tint last=nodes[0];\n\tcat;\n\tcat;\n\tREP(i,nodes.size()){\n\t\tneeds[nodes[i]]=-1;\n\t\tsearched[nodes[i]]=false;\n\t\tgrav[nodes[i]]=0;\n\t\tREP(j,edge[nodes[i]].size()){\n\t\t\tint next=edge[nodes[i]][j];\n\t\t\tif(!dead[next]) needs[nodes[i]]++;\n\t\t}\n\n\t\tif(needs[nodes[i]]==0) qu.push(pr(0,nodes[i]));\n\t}\n\tcat;\n\twhile(!qu.empty()){\n\t\tint now=qu.top().second,gravity=qu.top().first;\n\t\tqu.pop();\n\t\tsearched[now]=true;\n\t\tlast=now;\n\t\tREP(i,edge[now].size()){\n\t\t\tint next=edge[now][i];\n\t\t\tif(dead[next]) continue;\n\t\t\tif(searched[next]) continue;\n\t\t\tgrav[next]+=grav[now]+1;\n\t\t\ttimes[next]++;\n\t\t\tif(times[next]==needs[next]) qu.push(pr(grav[next],next));\n\t\t}\n\n\t}\n\tcenterize(last,nodes);\n\tREP(i,edge[last].size()){\n\t\tint next=edge[last][i];\n\t\tif(dead[next]) continue;\n\t\tsolve(next);\n\t}\n}\nint main(){\n\tint N,u,v;\n\tcin >> N;\n\tREP(i,N-1){\n\t\tscanf(\"%d %d\",&u,&v);\n\t\tedge[u].PB(v);\n\t\tedge[v].PB(u);\n\t}\n\tsolve(1);\n\tFOR(i,1,N+1){\n\t\tprintf(\"%lld\\n\",N*2-2-depters[i][0].first);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nvector< int > g[100000];\nint dist[100000], ans[100000];\n\nvoid dfs1(int idx, int par)\n{\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs1(to, idx);\n    dist[idx] = max(dist[idx], dist[to] + 1);\n  }\n}\n\nvoid dfs2(int idx, int d_par, int par)\n{\n  vector< pair< int, int > > d_child;\n  // d_child.emplace_back(0, -1);\n  for(int &to : g[idx]) {\n    if(to == par) d_child.emplace_back(d_par + 1, to);\n    else d_child.emplace_back(dist[to] + 1, to);\n  }\n  sort(d_child.rbegin(), d_child.rend());\n  ans[idx] = d_child[0].first;\n  for(int &to : g[idx]) {\n    if(to == par) continue;\n    dfs2(to, d_child[d_child[0].second == to].first, idx);\n  }\n}\n\nint main()\n{\n  int N;\n  cin >> N;\n  for(int i = 0; i < N - 1; i++) {\n    int a, b;\n    cin >> a >> b;\n    --a, --b;\n    g[a].push_back(b);\n    g[b].push_back(a);\n  }\n\n  dfs1(0, -1);\n  dfs2(0, 0, -1);\n  for(int i = 0; i < N; i++) {\n    cout << (N - 1) * 2 - ans[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <fstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <limits>\n#include <climits>\n#include <cfloat>\n#include <functional>\nusing namespace std;\n\nvector<vector<int> > edges;\nvector<map<int, int> > memo;\nvector<pair<int, pair<int, int> > > memo2;\n\nint solve(int curr, int prev)\n{\n    if(memo[curr].find(prev) != memo[curr].end())\n        return memo[curr][prev];\n\n    if(memo[curr].empty()){\n        pair<int, int> ans(0, 0);\n        for(int next : edges[curr]){\n            if(next != prev){\n                int d = solve(next, curr) + 1;\n                if(ans.first < d)\n                    swap(ans.first, d);\n                if(ans.second < d)\n                    swap(ans.second, d);\n            }\n        }\n        memo[curr][prev] = ans.first;\n        memo2[curr] = make_pair(prev, ans);\n        return ans.first;\n    }\n    else{\n        int prev2 = memo2[curr].first;\n        pair<int, int> ans = memo2[curr].second;;\n        if(prev2 != -1){\n            int d = solve(prev2, curr) + 1;\n            if(ans.first < d)\n                swap(ans.first, d);\n            if(ans.second < d)\n                swap(ans.second, d);\n        }\n\n        if(prev == -1){\n            memo[curr][prev] = ans.first;\n            return ans.first;\n        }\n        else{\n            int d = solve(prev, curr) + 1;\n            if(ans.first == d){\n                memo[curr][prev] = ans.second;\n                return ans.second;\n            }\n            else{\n                memo[curr][prev] = ans.first;\n                return ans.first;\n            }\n        }\n    }\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n    edges.resize(n);\n    for(int i=0; i<n-1; ++i){\n        int u, v;\n        cin >> u >> v;\n        -- u;\n        -- v;\n        edges[u].push_back(v);\n        edges[v].push_back(u);\n    }\n\n    memo.resize(n);\n    memo2.resize(n);\n    for(int i=0; i<n; ++i){\n        int ans = 2 * (n - 1) - solve(i, -1);\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <sstream>\n#include <string>\n#define repd(i,a,b) for (int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repd(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define mod 1000000007\n#define inf 2000000007\n#define mp make_pair\n#define pb push_back\ntypedef long long ll;\nusing namespace std;\ntemplate <typename T>\ninline void output(T a, int p) {\n    if(p) cout << fixed << setprecision(p)  << a << \"\\n\";\n    else cout << a << \"\\n\";\n}\n// end of template\ntypedef pair<int, int> pii;\nstruct edge{int to, weight;};\n\n#define MAX_V 100000\npii dfs(int prev, int v, const vector<edge> graph[MAX_V]){\n    pii r(0, v);\n    rep(i, graph[v].size()){\n        struct edge e = graph[v][i];\n        if(e.to == prev)continue;\n        pii tmp = dfs(v, e.to, graph);\n        tmp.first += e.weight;\n        if( r.first < tmp.first) r =  tmp;\n    }\n    return r;\n}\n\nvector<edge> G[MAX_V];\nvoid dijkstra(int s, vector<int> &d){\n    priority_queue<pii, vector<pii>, greater<pii>> que;\n    rep(i, d.size()) d[i] = inf;\n    d[s] = 0;\n    que.push(pii(0,s));\n    while(que.size()){\n        pii p = que.top();\n//        cout << p.first <<  \",\" << p.second <<  endl;\n        que.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n//        cout << v <<  \",\" << p.first << \",\" << G[v].size() <<  endl;\n        rep(i, G[v].size()){\n            edge e = G[v][i];\n//            cout << e.to <<  \",\" << v << \",\" <<  e.weight <<  endl;\n            if(d[e.to] > d[v] + e.weight){\n                d[e.to] = d[v] + e.weight;\n                que.push(pii(d[e.to], e.to));\n            }\n        }\n    }\n}\n\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    \n    int n;\n    cin>>n;\n    \n    rep(i,n-1){\n        int u,v;\n        \n        cin>>u>>v;\n        u--,v--;\n        G[u].pb(edge{v,1});\n        G[v].pb(edge{u,1});\n    }\n    \n    \n    pii r=dfs(-1,0,G);\n    pii t = dfs(-1,r.second,G);\n    int A = r.second;\n    int B = t.second;\n    \n    vector<int> d1(n),d2(n);\n    \n    dijkstra(A,d1);\n    dijkstra(B,d2);\n    \n//    cout<<A<<\" \"<<B<<endl;\n    rep(i,n){\n//        cout<<d1[i]<<\" \"<<d2[i]<<endl;\n        int dist=max(d1[i],d2[i]);\n        cout<<2*(n-1)-dist<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\n#include<numeric>\nusing namespace std;\n#define INF (1 << 30) - 1\n#define LINF 1LL << 60\nconst int MOD = 1000000007;\nusing ll = long long;\nusing P = pair<int, int>;\n\nvector<vector<int>> g;\n\nvector<int> dist;\nvoid dfs1(int v, int p = -1){\n  for(auto nv : g[v]){\n    if(nv == p)continue;\n    dfs1(nv, v);\n    dist[v] = max(dist[v], dist[nv] + 1);\n  }\n}\n\nvector<int> ans;\nvoid dfs2(int v, int p = -1, int d_par = 0){\n  vector<P> d_ch;\n  d_ch.push_back({0, -1});\n  for(auto nv : g[v]){\n    if(nv == p)d_ch.push_back({d_par + 1, nv});\n    else d_ch.push_back({dist[nv] + 1, nv});\n  }\n\n  sort(d_ch.rbegin(), d_ch.rend());\n  ans[v] = d_ch[0].first;\n  for(auto nv : g[v]){\n    if(nv == p)continue;\n    int flg = d_ch[0].second == nv;\n    dfs2(nv, v, d_ch[flg].first);\n  }\n}\n\nint main(){\n  int n;\n  cin >> n;\n  g.resize(n);\n  for(int i = 0; i < n - 1; ++i){\n    int u, v;\n    cin >> u >> v;\n    --u;\n    --v;\n    g[u].push_back(v);\n    g[v].push_back(u);\n  }\n\n  dist.assign(n, 0);\n  dfs1(0);\n  ans.resize(n);\n  dfs2(0);\n  for(int i = 0; i < n; ++i){\n    cout << (n - 1) * 2 - ans[i] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define all(x)  x.begin(), x.end()\n#define pii     pair<int, int>\n\nvector<int> g[101010];\nint dist[101010];\nint ans[101010];\n\nvoid dfs1(int v, int prev) {\n        for (auto u : g[v]) if (u != prev) {\n                dfs1(u, v);\n                dist[v] = max(dist[v], dist[u] + 1);\n        }\n}\n\nvoid dfs2(int v, int ma, int prev) {\n        vector<pii> children;\n        children.emplace_back(0, -1);\n        for (auto u : g[v]) {\n                if (u == prev) children.emplace_back(ma + 1, u);\n                else children.emplace_back(dist[u] + 1, u);\n        }\n        sort(all(children), greater<pii>());\n        ans[v] = children[0].first;\n        for (auto u : g[v]) if (u != prev) dfs2(u, children[u == children[0].second ? 1 : 0].first, v);\n}\n\nint main() {\n        int n;\n        cin >> n;\n        for (int i = 0; i < n - 1; i ++) {\n                int a, b;\n                cin >> a >> b;\n                a --, b --;\n                g[a].push_back(b);\n                g[b].push_back(a);\n        }\n        dfs1(0, -1);\n        dfs2(0, 0, -1);\n        for (int i = 0; i < n; i ++) cout << (n - 1) * 2 - ans[i] << endl;\n        return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing i64 = int64_t;\n\nstruct Edge{\n    int from, to, cost;\n};\n\nusing Graph = vector<vector<Edge>>;\nusing Weight = int;\n\nconstexpr Weight INF = 1e9;\n\ntuple<int, int, Weight> tree_diameter(const Graph &tree){\n    struct {\n        pair<Weight, int> operator()(int v, const Graph &tree){\n            pair<Weight, int> res(0, v);\n            vector<Weight> dist(tree.size(), INF);\n            dist[v] = 0;\n            queue<pair<Weight, int>> que;\n            que.push({0, v});\n            while(!que.empty()){\n                auto cur = que.front(); que.pop();\n                res = max(res, cur);\n                for(auto e: tree[cur.second]){\n                    Weight new_cost = cur.first + e.cost;\n                    if(new_cost >= dist[e.to])continue;\n                    dist[e.to] = new_cost;\n                    que.push({new_cost, e.to});\n                }\n            }\n            return res;\n        }\n    } find_farthest_node;\n\n    auto r = find_farthest_node(0, tree);\n    auto t = find_farthest_node(r.second, tree);\n    return make_tuple(r.second, t.second, t.first);\n}\n\nvoid bfs(int s, vector<Weight> &v, const Graph &tree){\n    v[s] = 0;\n    queue<pair<Weight, int>> que;\n    que.push({0, s});\n    while(!que.empty()){\n        auto cur = que.front(); que.pop();\n        for(auto e: tree[cur.second]){\n            Weight new_cost = cur.first + e.cost;\n            if(new_cost >= v[e.to])continue;\n            v[e.to] = new_cost;\n            que.push({new_cost, e.to});\n        }\n    }\n}\n\nint main(){\n    int n;\n    cin >> n;\n    Graph tree(n, vector<Edge>());\n    for(int i=0;i<n-1;++i){\n        int u, v;\n        cin >> u >> v;\n        u--; v--;\n        tree[u].push_back({u, v, 1});\n        tree[v].push_back({v, u, 1});\n    }\n    int u, v, d;\n    tie(u, v, d) = tree_diameter(tree);\n    vector<Weight> ud(n, INF), vd(n, INF);\n    bfs(u, ud, tree);\n    bfs(v, vd, tree);\n    for(int i=0;i<n;++i){\n        cout << 2*(n-1) - max(ud[i], vd[i]) << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/* rerooting.cpp\n    全方位木DP\n\n    // 根rから最も遠い点までの距離を求める\n    struct DP {  // 単位元はしっかり定義する(末端でもadd_rootされるので注意)\n        long long dp;\n        DP(long long dp_ = 0) : dp(dp_) {}\n    };\n    function<DP(DP, DP, long long)> merge = [](DP dp_cum, DP d, long long cost) -> DP {  // d:辺eに対応する部分木のdpの値  cost:eのコスト\n        return DP(max(dp_cum.dp, d.dp + cost));                                       //最大の深さ(根から最も遠い点までの距離)\n    };\n    function<DP(DP)> add_root = [](DP d) -> DP {  // まとめたDPを用いて、新たな部分木のDPを計算する\n        return d;\n    };\n\n    verified:\n    - AOJ GRL_5_A: Diameter of a Tree\n        http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_A\n    - [AtCoder] Typical DP Contest N - 木\n        https://tdpc.contest.atcoder.jp/submissions/11405065\n    - [AtCoder] ABC 160 F - Distributing Integers （上とほぼ同じ）\n        https://atcoder.jp/contests/abc160/submissions/11405183\n\n    - AOJ 1595: Traffic Tree\n        http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=1595\n*/\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n/* Rerooting: 全方位木 DP\n    問題ごとに以下を書き換える\n    - 型DPと単位元\n    - 型DPに対する二項演算 merge\n    - まとめたDPを用いて新たな部分木のDPを計算する add_root\n    計算量: O(N)\n*/\nstruct Rerooting {\n    /* start 問題ごとに書き換え */\n    struct DP {  // DP の型\n        long long dp;\n        DP(long long dp_) : dp(dp_) {}\n    };\n    const DP identity = DP(0);                                                           // 単位元はしっかり定義する(末端でもadd_rootされるので注意)\n    function<DP(DP, DP, long long)> merge = [](DP dp_cum, DP d, long long cost) -> DP {  // d:辺eに対応する部分木のdpの値  cost:eのコスト\n        return DP(max(dp_cum.dp, d.dp + cost));\n    };\n    function<DP(DP)> add_root = [](DP d) -> DP {  // まとめたDPを用いて、新たな部分木のDPを計算する\n        return d;\n    };\n    /* end 問題ごとに書き換え */\n\n    // グラフの定義\n    struct Edge {\n        int add_rootom;\n        int to;\n        long long cost;\n    };\n    using Graph = vector<vector<Edge>>;\n\n    vector<vector<DP>> dp;  // dp[v][i]: vから出るi番目の有向辺に対応する部分木のDP\n    vector<DP> ans;         // ans[v]: 頂点vを根とする木の答え\n    Graph G;\n\n    Rerooting(int N) : G(N) {\n        dp.resize(N);\n        ans.assign(N, identity);\n    }\n\n    void add_edge(int a, int b, long long c = 1) {\n        G[a].push_back({a, b, c});\n    }\n    void build() {\n        dfs(0);            // 普通に木DP\n        bfs(0, identity);  // 残りの部分木に対応するDPを計算\n    }\n\n    DP dfs(int v, int p = -1) {  // 頂点v, 親p\n        DP dp_cum = identity;\n        int deg = G[v].size();\n        dp[v] = vector<DP>(deg, identity);\n        for (int i = 0; i < deg; i++) {\n            int u = G[v][i].to;\n            if (u == p) continue;\n            dp[v][i] = dfs(u, v);\n            dp_cum = merge(dp_cum, dp[v][i], G[v][i].cost);\n        }\n        return add_root(dp_cum);\n    }\n    void bfs(int v, const DP& dp_p, int p = -1) {\n        int deg = G[v].size();\n        for (int i = 0; i < deg; i++) {  // 前のbfsで計算した有向辺に対応する部分木のDPを保存\n            if (G[v][i].to == p) dp[v][i] = dp_p;\n        }\n\n        vector<DP> dp_l(deg + 1, identity), dp_r(deg + 1, identity);  // 累積的なDP\n        for (int i = 0; i < deg; i++) {\n            dp_l[i + 1] = merge(dp_l[i], dp[v][i], G[v][i].cost);\n        }\n        for (int i = deg - 1; i >= 0; i--) {\n            dp_r[i] = merge(dp_r[i + 1], dp[v][i], G[v][i].cost);\n        }\n        ans[v] = add_root(dp_l[deg]);\n        for (int i = 0; i < deg; i++) {\n            int u = G[v][i].to;\n            if (u == p) continue;\n            bfs(u, add_root(merge(dp_l[i], dp_r[i + 1], 0)), v);  // 累積同士のmergeなので、edgeは適当に\n        }\n    }\n};\n\nint main() {\n    int N;\n    cin >> N;\n    Rerooting reroot(N);\n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        u--, v--;\n        reroot.add_edge(u, v);\n        reroot.add_edge(v, u);\n    }\n    reroot.build();\n\n    for (int i = 0; i < N; i++) {\n        cout << (N - 1) * 2 - reroot.ans[i].dp << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//https://hcpc-hokudai.github.io/archive/dynamic_programming_rerooting.pdf\n//https://qiita.com/keymoon/items/2a52f1b0fb7ef67fb89e#使用例\n\n\n#include <iostream>\n#include <vector>\n#include <functional>\n#include <stack>\nusing namespace std;\nconst long long INF = 1LL << 61;\n\ntemplate<class T> class reRooting{\n    public:\n    //ノード数\n    int nodeCount;\n    \n    // 隣接している点の配列\n    vector<vector<int>> Adjacents;\n    // 隣接点にとって自分が何番目の隣接点なのか, to jが何番目なのか\n    // adjacents[adjacents[i][j]][indexForAdjacents[i][j]] == i である\n    vector<vector<int>> IndexForAdjacent;\n\n    // Res[i] := iの子部分木の値\n    vector<T> Res;\n    //DP[i][j] := i, j := node id (jがiにとって何番目なのか)を親とし、adjacents[i][j]を根とした部分木の値  \n    vector<vector<T>> DP;\n\n    //単位元\n    T Identity;\n    // T merge(T left, T right){}で定義される部分期のマージ関数\n    function<T(T, T)> Operate;\n    //T addNode(T value, int nodeID) {} で定義される頂点の追加\n    function<T(T, int)> OperateNode;\n\n\n    public:\n    reRooting(int _nodeCount, vector<vector<int>>& edges, T _identity, \n                function<T(T, T)> _operate, function<T(T, int)> _operateNode)\n                :nodeCount(_nodeCount), Identity(_identity), Operate(_operate), OperateNode(_operateNode)    \n    {\n        vector<vector<int>> adjacents(nodeCount);\n        vector<vector<int>> indexForAdjacent(nodeCount);\n\n        //辺を見て配列に追加していく\n        for(int i=0; i< edges.size(); ++i){\n            auto& edge = edges[i];\n            indexForAdjacent[edge[0]].push_back(adjacents[edge[1]].size());\n            indexForAdjacent[edge[1]].push_back(adjacents[edge[0]].size());\n            adjacents[edge[0]].push_back(edge[1]);\n            adjacents[edge[1]].push_back(edge[0]);\n        }\n\n        Adjacents.resize(nodeCount);\n        IndexForAdjacent.resize(nodeCount);\n\n        for(int i=0; i<nodeCount; ++i){\n            Adjacents[i] = adjacents[i];\n            IndexForAdjacent[i] = indexForAdjacent[i];\n        }\n        DP.resize(Adjacents.size());\n        for (int i = 0; i < Adjacents.size(); i++)\n            DP[i].resize(Adjacents[i].size());\n\n        Res.resize(Adjacents.size());\n\n        if(nodeCount > 1){\n            Initialize();\n        }else if(nodeCount == 1){\n            Res[0] = OperateNode(Identity, 0);\n        }\n    }\n\n    T Query(int node) {return Res[node]; }\n\n    private:\n    void Initialize(){\n        //parents[i] := 一時的な根付き木として考えた時の、ノードiについての親\n        vector<int> parents(nodeCount);\n        //order := DFSでの行きがけ順\n        vector<int> order(nodeCount);\n\n        //まず、一つの頂点について求めることを考えます。\n        #pragma region InitOrderedTree\n            int index = 0;\n            stack<int> stack;\n            //0を根とする\n            stack.push(0);\n            parents[0] = -1;\n            //行きがけ順を記録する\n            while(stack.size() > 0 ){\n                auto node = stack.top();\n                stack.pop();\n\n                order[index++] = node;\n                for(int i=0; i < Adjacents[node].size(); ++i){\n                    auto adjacent = Adjacents[node][i];\n                    if(adjacent == parents[node]) continue;\n                    stack.push(adjacent);\n                    parents[adjacent] = node;\n                }\n            }\n        #pragma endregion\n\n        //その次に、その訪問順を利用して部分木の値を求めます。\n        //この操作で根付き木の根の方向(=親方向)以外の部分木の値が求まっているような状態になります。\n        #pragma region fromLeaf\n        for(int i=order.size()-1; i>= 1; --i){\n            //現在の見ている頂点と、その親\n            auto node = order[i];\n            auto parent = parents[node];\n            //結果\n            T accum = Identity;\n            int parentIndex = -1;\n            //隣接する点を調べる\n            for(int j=0; j< Adjacents[node].size(); ++j){\n                //もし隣接する点が親だったら、親のindexの記録だけする\n                if(Adjacents[node][j] == parent){\n                    parentIndex = j;\n                    continue;\n                }\n                //隣接する点方向の子部分木の結果を加える\n                accum = Operate(accum, DP[node][j]);\n            }\n            //頂点を部分木のマ追加した後、親が持っている配列に結果を格納する\n            //(親にとって自分が何番目の隣接頂点なのかを調べて格納)\n            DP[parent][IndexForAdjacent[node][parentIndex]] = OperateNode(accum, node);\n        }\n        #pragma endregion\n\n\n        //全ての頂点は根の方向からの部分木の値が求まれば頂点の値が求まるという状態になっている。\n        //子部分木全てが揃った場合、両方向から累積を取る等で自分が根となる全ての部分木の値を求めることができます。\n        #pragma region toLeaf\n        //行きがけ順で頂点の値を確定させていく\n        for(int i=0; i < order.size(); ++i){\n            //値を確定させるnode\n            auto node = order[i];\n            \n            //後ろからの累積和を格納する配列\n            vector<T> accumsFromTail(Adjacents[node].size());\n            accumsFromTail[accumsFromTail.size() - 1] = Identity;\n            for(int j = accumsFromTail.size() - 1; j >= 1; --j){\n                accumsFromTail[j - 1] = Operate(DP[node][j], accumsFromTail[j]);\n            }\n\n            //前からの累積和を持つ変数\n            T accum = Identity;\n            for(int j=0; j < accumsFromTail.size(); ++j){\n                //adjacents[node][j]が親、nodeが子の部分木について計算する\n                //累積をマージして子部分木の値をマージし終えた後、頂点を追加する\n                T result = OperateNode(Operate(accum, accumsFromTail[j]), node);\n                //その値を、親が持っている配列に結果を格納する(親にとって自分が何番目の隣接頂点なのかを調べて格納)\n                DP[Adjacents[node][j]][IndexForAdjacent[node][j]] = result;\n\n                //累積を更新\n                accum = Operate(accum, DP[node][j]);\n            }\n            //最後まで累積しきったものはnodeの子部分木を全てマージしたものになっているので、それに頂点を追加するとnodeの値となる\n            Res[node] = OperateNode(accum, node);\n        }\n        #pragma endregion\n    }\n};\n\n\n\n//  ・問題\n//  それぞれ1からNまでの番号が付いたN個の頂点からなる木が与えられる.各頂点について，\n// その頂点から最も遠い頂点まで􏰀距離 を求めよ.\n//  ・制約\n//  1≦N≦100,000\n\n//例\n// input \n// 6\n// 1 2\n// 1 3\n// 3 4\n// 3 5\n// 5 6\n\n// output\n// 7\n// 6\n// 8\n// 7\n// 7\n// 6\n\nint main(){\n    int N;\n    cin >> N;\n    vector<vector<int>> edges;\n    for(int i=0; i<N-1; ++i){\n        int from, to;\n        cin >> from >> to;\n        from--;\n        to--;\n        edges.push_back({from, to});\n    }\n\n    reRooting<int> rR(N, edges, 0, \n                [](long long a, long long b) { return max(a, b);},[](long long value, int id) { return value+1; });\n    \n    for(int i=0; i<rR.Res.size(); ++i){\n\n        cout << 2*(N-1) - (rR.Res[i] - 1) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef pair<pii,int> tri;\ntypedef vector<int> vi;\n\nvector< vector<pii> > d;\nvi ans;\n\nvoid dfs1(const vector<vi> &t){\n  int v = 0, p = -1, out = 0;\n  stack<tri> s;\n  s.push( tri(pii(v,p), out) );\n\n  while( not s.empty() ){\n    tri x = s.top(); s.pop();\n    v = x.first.first, p = x.first.second, out = x.second;\n\n    if(out){\n      int cnt = 0;\n      for(int u : t[v]){\n\tif(p==u) continue;\n\tpii tmp(1,u);\n\tif(d[u].size()) tmp.first = d[u][0].first + 1;\n\td[v].push_back(tmp);\n\tcnt++;\n      }\n      sort(d[v].begin(), d[v].end());\n      reverse(d[v].begin(), d[v].end());\n    }else{\n      s.push( tri( pii(v,p), 1) );\n      for(int u : t[v]){\n\tif(p==u) continue;\n\ts.push( tri( pii(u,v), 0) );\n      }\n    }\n  }\n}\n\nvoid dfs2(const vector<vi> &t){\n  int v = 0, p = -1, len = 0;\n  stack<tri> s;\n  s.push( tri(pii(v,p), len) );\n\n  while( not s.empty() ){\n    tri x = s.top(); s.pop();\n    v = x.first.first, p = x.first.second, len = x.second;\n\n    int res = len;\n    if(d[v].size()) res = max(res, d[v][0].first);\n    ans[v] = res;\n\n    for(int u : t[v]){\n      if(p==u) continue;\n      int tmp = len;\n      if(d[v].size() >= 2){\n\tif(d[v][0].second == u){\n\t  tmp = max(tmp, d[v][1].first);\n\t}else{\n\t  tmp = max(tmp, d[v][0].first);\n\t}\n      }\n\n      s.push( tri( pii(u,v), tmp + 1) );\n    }\n  }\n \n}\n\nint main(){\n  int n;\n  cin >> n;\n\n  vector<vi> t(n);\n  rep(i,n-1){\n    int u,v;\n    cin >> u >> v; u--; v--;\n    t[u].push_back(v);\n    t[v].push_back(u);\n  }\n\n  d = vector< vector<pii> >(n);\n  dfs1(t);\n\n  ans = vi(n,0);\n  dfs2(t);\n \n\n  for(int i=0;i<n;i++){\n    cout << 2*n-2 - ans[i] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nusing pi = pair<int,int>;\nconst int N = 100000;\n\nvector<int> G[N];\n\n// ??°??£????????????????????????/??????\npi dp1[N];\nvoid dfs(int v, int par)\n{\n    int res = 0;\n    for(int nx:G[v])if(nx!=par)\n    {\n        dfs(nx,v);\n        res += dp1[nx].fi+2;\n    }\n\n    int notback = res;\n    for(int nx:G[v])if(nx!=par)\n    {\n        int t = res;\n        t += dp1[nx].se+1 - (dp1[nx].fi+2);\n        notback = min(notback,t);\n    }\n\n    dp1[v] = {res,notback};\n}\n\nint ans[N];\nvoid dfs2(int v, int par, pi d)\n{\n\n    // v????????¨???????????????????????¨????????¨?????¨????????±?????????\n    vector<pair<pi,int>> c;\n    // ???????????????\n    for(int nx:G[v])if(nx!=par) c.pb({dp1[nx],nx});\n    // ?????????\n    c.pb({d,-1});\n\n    int C = c.size();\n    // ??¨??¨?????¨?????¨???????????????????????£?????°??£?????????????????¨???????????´???????????????\n    int sum = 0;\n    rep(i,C) sum += c[i].fi.fi+2;\n\n    // second????????¶?????¨????????£?????????????????????(?°?????????????????¬???????)\n    // (??????,??????)\n    vector<pi> gain;\n\n    // ??????v??????????????????????¨??????????\n    ans[v] = sum;\n    // ????????¨?????¨???\"??°?????????\"??????????????¨??¢?´¢\n    rep(i,C)\n    {\n        // \"??°??£?????????\"??????\"??°?????????\"???????????????????????¨????????£????????????????????????\n        int g = c[i].fi.se+1 - (c[i].fi.fi+2);\n\n        ans[v] = min(ans[v],sum+g);\n        gain.pb({g,c[i].se});\n    }\n\n    // ??????????????¨?????¨????????± d ?????´??°????????????????????????????????????\n    sort(all(gain));\n    rep(i,C)\n    {\n        int nx = gain[i].se;\n        if(nx==-1) continue;\n\n        pi nd;\n        // \"??°??£?????????\"???????????????????????¨?????¨?????¶??????????????°??????\n        nd.fi = sum - (dp1[nx].fi+2);\n\n        // \"??°?????????\"???????????????????????¨?????¨??????????????????????????????????????§???????????§??´????????????????????????\n        // ??????????????????????????¨?????¨???\"??°?????????\"??????????????§????????????????????§?¬??????§????????¨?????????\"??°?????????\"??????????????????\n        // ????????§???????????°??????????????¨?????¨???\"??°?????????\"???????????°??????\n        nd.se = nd.fi;\n        if(i==0)\n        {\n            if(C>1) nd.se += gain[1].fi;\n        }\n        else nd.se += gain[0].fi;\n\n        dfs2(nx,v,nd);\n    }\n}\n\nint main()\n{\n    int n;\n    scanf(\" %d\", &n);\n    rep(i,n-1)\n    {\n        int u,v;\n        scanf(\" %d %d\", &u, &v);\n        --u;\n        --v;\n        G[u].pb(v);\n        G[v].pb(u);\n    }\n\n    dfs(0,-1);\n    dfs2(0,-1,{-2,-1});\n    rep(i,n) printf(\"%d\\n\", ans[i]);\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// https://onlinejudge.u-aizu.ac.jp/beta/room.html#ACPC2016Day2/problems/I\n// #include\"../ReRooting.cpp\"\n#include<vector>\n#include<iostream>\nnamespace ProconLib{\n\n    template<typename edge_t>\n    class StructInterface{\n        struct data_t;    \n        struct value_t;\n        data_t E();\n        data_t merge(data_t x,data_t y);\n        data_t mergeV(data_t x,int v);\n        data_t mergeE(data_t x,const edge_t& e);\n        value_t solve(int v,const std::vector<data_t>& vec);\n    };\n\n    template<class graph_t,class Struct>\n    class ReRooting{\n        int N;\n        int root;\n        Struct st;\n        using data_t=typename Struct::data_t;\n        using value_t=typename Struct::value_t;\n        std::vector<data_t> dp;\n        std::vector<value_t> res;\n        void dfs0(int v,int pre,const graph_t& g);\n        void dfs1(int v,int pre,data_t dPar,const graph_t& g);\n        public:\n        ReRooting(const graph_t& graph,Struct st=Struct(),int root=0);\n        std::vector<value_t> get(){return res;};\n    };\n\n    template<class graph_t,class Struct>\n    ReRooting<graph_t,Struct>::ReRooting(const graph_t& g,Struct st,int root)\n        :N(g.size()),root(root),st(st),dp(N),res(N)\n    {\n        dfs0(root,-1,g);\n        dfs1(root,-1,data_t(),g);\n    }\n\n    template<class graph_t,class Struct>\n    void ReRooting<graph_t,Struct>::dfs0(int v,int pre,const graph_t& g){\n        dp[v]=st.E();\n        for(auto &e:g[v]){\n            if(e.to==pre) continue;\n            dfs0(e.to,v,g);\n            dp[v]=st.merge(dp[v],st.mergeE(dp[e.to],e));\n        }\n        dp[v]=st.mergeV(dp[v],v);\n    }\n    \n    template<class graph_t,class Struct>\n    void ReRooting<graph_t,Struct>::dfs1(int v,int pre,data_t dPar,const graph_t& g){\n        std::vector<data_t> tmp;\n        tmp.reserve(g[v].size());\n        for(auto &e:g[v]) if(e.to!=pre) tmp.push_back(st.mergeE(dp[e.to],e));\n        int sz=tmp.size();\n        std::vector<data_t> rsum(sz+1);\n        rsum[sz]=st.E();\n        for(int i=sz-1;i>=0;i--) rsum[i]=st.merge(rsum[i+1],tmp[i]);\n\n        data_t lsum=st.E();\n        int id=0;\n        for(auto &e:g[v]){\n            if(e.to==pre) continue;\n            data_t cdsum=st.merge(st.merge(lsum,rsum[id+1]),dPar);\n            data_t nextDPar=st.mergeE(st.mergeV(cdsum,v),e);\n            dfs1(e.to,v,nextDPar,g);\n            lsum=st.merge(lsum,tmp[id]);\n            id++;\n        }\n\n        if(v!=root) tmp.push_back(dPar);\n        res[v]=st.solve(v,tmp);\n    }\n\n}\n#include<bits/stdc++.h>\nusing namespace std;\nusing namespace ProconLib;\n\nstruct Edge{\n    int to;\n};\n\ntemplate<typename edge_t>\nstruct Struct{\n    using data_t=pair<int,int>;    \n    using value_t=int;\n    data_t E(){return make_pair(0,0);};\n    data_t merge(data_t x,data_t y){return make_pair(x.first+y.first,max(x.second,y.second));};\n    data_t mergeV(data_t x,int v){return x;};\n    data_t mergeE(data_t x,const edge_t& e){return make_pair(x.first+2,x.second+1);}\n    value_t solve(int v,const std::vector<data_t>& vec){\n        int sum=0;\n        int ma=0;\n        for(int i=0;i<vec.size();i++) sum+=vec[i].first,ma=max(ma,vec[i].second);\n        return sum-ma;\n    };\n};\n\nusing Graph=vector<vector<Edge>>;\nint main(){\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    int n; cin>>n;\n    Graph g(n);\n    for(int i=0;i+1<n;i++){\n        int u,v; cin>>u>>v; u--,v--;\n        g[u].push_back(Edge{v});\n        g[v].push_back(Edge{u});\n    }\n    ReRooting<Graph,Struct<Edge>> rr(g);\n    auto res=rr.get();\n    for(int i=0;i<n;i++) cout<<res[i]<<\"\\n\";\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1595 Traffic Tree\n// 2018.5.4 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#define pc(c) putchar_unlocked(c)\n#else\n#define gc() getchar()\n#define pc(c) putchar(c)\n#endif\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nvoid out(int n)\n{\n\tint i;\n\tchar ob[20];\n\n\tif (!n) { pc('0'); return; }\n\tif (n < 0) pc('-'), n = -n;\n\ti = 0; while (n) ob[i++] = n%10 + '0', n/=10;\n\twhile (i--) pc(ob[i]);\n\tpc('\\n');\n}\n\n#define INF   0x10101010\n#define MAX_N 100002\n\ntypedef struct { int s, d; } QUE;\nQUE que[MAX_N*2]; int top, end;\nint n;\nint hi[MAX_N], *to[MAX_N];\nint dist_a[MAX_N], dist_b[MAX_N];\n\nvoid bfs(int s, int *dist)\n{\n\tint i, t, d;\n\n\tmemset(dist, INF, n<<2);\n\tque[0].s = s, que[0].d = 0, dist[s] = 0, top = 0, end = 1;\n\twhile (top != end) {\n\t\ts = que[top].s, d = que[top++].d;\n\t\tif (dist[s] < d) continue;\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\tt = to[s][i];\n\t\t\tif (dist[t] == INF) {\n\t\t\t\tdist[t] = d+1, que[end].s = t, que[end++].d = d+1;\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid calc()\n{\n\tint i, max;\n\tint node_a, node_b;\t\t// 木の直径を表す２つのノード\n\t\n\tbfs(0, dist_a);\n\tmax = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif (dist_a[i] > max) node_a = i, max = dist_a[i];\n\t}\n\n\tbfs(node_a, dist_a);\n\tmax = 0;\n\tfor (i = 0; i < n; i++) {\n\t\tif (dist_a[i] > max) node_b = i, max = dist_a[i];\n\t}\n\n\tbfs(node_b, dist_b);\n}\n\nint main()\n{\n\tint s, t, i, j, ans;\n\tint *memo;\n\n\tn = in();\n\tmemo = malloc(n<<3);\n\tj = 0; for (i = 1; i < n; i++) {\n\t\tmemo[j++] = s = in()-1;\n\t\tmemo[j++] = t = in()-1;\n\t\thi[s]++, hi[t]++;\n\t}\n\tfor (i = 0; i < n; i++) if (hi[i]) to[i] = malloc(hi[i]<<2);\n\tmemset(hi, 0, n<<2);\n\tj = 0; for (i = 1; i < n; i++) {\n\t\ts = memo[j++], t = memo[j++];\n\t\tto[s][hi[s]++] = t;\n\t\tto[t][hi[t]++] = s;\n\t}\n\tfree(memo);\n\n\tcalc();\n\n\t// (t=)辺の数*2 - (ans=)頂点iを根とした根付き木の深さ\n\tt = (n-1)<<1;\t\t// tは再定義\n\tfor (i = 0; i < n; i++) {\n\t\tans = dist_a[i];\n\t\tif (ans < dist_b[i]) ans = dist_b[i];\n\t\tout(t-ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MAX(int a,int b){return a<b?b:a;}\nint main(){\n  int n,i,j,a,b,f[100010],q[100010],r,t;\n  int ta[100010],to[100010],nt[1000010],d[2][100010];\n  scanf(\"%d\",&n);\n  for(i=0;i<=n;i++)ta[i]=-1;\n  for(i=0;i<n-1;i++){\n    scanf(\"%d %d\",&a,&b);\n    to[i]=b;\n    nt[i]=ta[a];\n    ta[a]=i;\n    to[i+n-1]=a;\n    nt[i+n-1]=ta[b];\n    ta[b]=i+n-1;\n  }\n  /*for(i=1;i<=n;i++){\n    printf(\"%d:\",i);\n    for(j=ta[i];j+1;j=nt[j])printf(\"%d\\n\",to[j]);\n    }//*/\n  q[t=0]=1;\n  for(i=0;i<=n;i++)f[i]=0;\n  for(r=f[0]=1;r-t;t++){\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      if(f[to[i]])continue;\n      q[r++]=to[i];\n      f[to[i]]=1;\n    }\n  }//printf(\"a\\n\");\n  q[0]=q[r-1];//printf(\"%d\\n\",q[0]);\n  d[0][q[0]]=t=0;\n  for(i=0;i<=n;i++)f[i]=0;\n  for(r=f[q[0]]=1;r-t;t++){\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      if(f[to[i]])continue;\n      q[r++]=to[i];\n      f[to[i]]=1;\n      d[0][to[i]]=d[0][q[t]]+1;\n    }\n  }//printf(\"a\\n\");\n  q[0]=q[r-1];\n  d[1][q[0]]=t=0;\n  for(i=0;i<=n;i++)f[i]=0;\n  for(r=f[q[0]]=1;r-t;t++){\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      if(f[to[i]])continue;\n      q[r++]=to[i];\n      f[to[i]]=1;\n      d[1][to[i]]=d[1][q[t]]+1;\n    }\n  }\n  //for(i=1;i<=n;i++)printf(\"%d %d %d\\n\",i,d[0][i],d[1][i]);\n  for(i=1;i<=n;i++)printf(\"%d\\n\",n*2-2-MAX(d[0][i],d[1][i]));\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MAX(int a,int b){return a<b?b:a;}\nint main(){\n  int n,i,j,a,b,f[100010],q[100010],r,t;\n  int ta[100010],to[100010],nt[1000010],d[2][100010];\n  scanf(\"%d\",&n);\n  for(i=0;i<=n;i++)ta[i]=-1;\n  for(i=0;i<n-1;i++){\n    scanf(\"%d %d\",&a,&b);\n    to[i]=b;\n    nt[i]=ta[a];\n    ta[a]=i;\n    to[i+n-1]=a;\n    nt[i+n-1]=ta[b];\n    ta[b]=i+n-1;\n  }\n  /*for(i=1;i<=n;i++){\n    printf(\"%d:\",i);\n    for(j=ta[i];j+1;j=nt[j])printf(\"%d\\n\",to[j]);\n    }//*/\n  q[t=0]=1;\n  for(i=0;i<=n;i++)f[i]=0;\n  for(r=f[q[0]]=1;r-t;t++){\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      if(f[to[i]])continue;\n      q[r++]=to[i];\n      f[to[i]]=1;\n    }\n  }//printf(\"a\\n\");\n  q[0]=q[r-1];//printf(\"%d\\n\",q[0]);\n  d[0][q[0]]=t=0;\n  for(i=0;i<=n;i++)f[i]=0;\n  for(r=f[q[0]]=1;r-t;t++){\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      if(f[to[i]])continue;\n      q[r++]=to[i];\n      f[to[i]]=1;\n      d[0][to[i]]=d[0][q[t]]+1;\n    }\n  }//printf(\"a\\n\");\n  q[0]=q[r-1];\n  d[1][q[0]]=t=0;\n  for(i=0;i<=n;i++)f[i]=0;\n  for(r=f[q[0]]=1;r-t;t++){\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      if(f[to[i]])continue;\n      q[r++]=to[i];\n      f[to[i]]=1;\n      d[1][to[i]]=d[1][q[t]]+1;\n    }\n  }\n  //for(i=1;i<=n;i++)printf(\"%d %d %d\\n\",i,d[0][i],d[1][i]);\n  for(i=1;i<=n;i++)printf(\"%d\\n\",n*2-2-MAX(d[0][i],d[1][i]));\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint MAX(int a,int b){return a<b?b:a;}\nint main(){\n  int n,i,j,a,b,f[100010],q[100010],r,t;\n  int ta[100010],to[200010],nt[200010],d[2][100010];\n  scanf(\"%d\",&n);\n  for(i=0;i<=n;i++)ta[i]=-1;\n  for(i=0;i<n-1;i++){\n    scanf(\"%d %d\",&a,&b);\n    to[i]=b;\n    nt[i]=ta[a];\n    ta[a]=i;\n    to[i+n-1]=a;\n    nt[i+n-1]=ta[b];\n    ta[b]=i+n-1;\n  }\n  /*for(i=1;i<=n;i++){\n    printf(\"%d:\",i);\n    for(j=ta[i];j+1;j=nt[j])printf(\"%d \",to[j]);printf(\"\\n\");\n    }//*/\n  q[t=0]=1;\n  for(i=0;i<=n;i++)f[i]=0;\n  for(r=f[q[0]]=1;r-t;t++){//printf(\"%d->\",q[t]);\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      if(f[to[i]])continue;//printf(\"%d \",to[i]);\n      q[r++]=to[i];\n      f[to[i]]=1;\n    }//printf(\"\\n\");\n  }//printf(\"a\\n\");\n\n  //printf(\"\\n\");\n  q[0]=q[r-1];//printf(\"%d\\n\",q[0]);\n  d[0][q[0]]=t=0;\n  for(i=0;i<=n;i++)f[i]=0;\n  for(r=f[q[0]]=1;r-t;t++){//printf(\"%d:%d->\",d[0][q[t]],q[t]);\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      if(f[to[i]])continue;\n      q[r++]=to[i];\n      f[to[i]]=1;\n      d[0][to[i]]=d[0][q[t]]+1;//printf(\"%d %d:\",to[i],d[0][to[i]]);\n    }//printf(\"\\n\");\n  }//printf(\"a\\n\");\n\n   //printf(\"\\n\"); \n  q[0]=q[r-1];\n  d[1][q[0]]=t=0;\n  for(i=0;i<=n;i++)f[i]=0;\n  for(r=f[q[0]]=1;r-t;t++){//printf(\"%d:%d->\",d[1][q[t]],q[t]);\n    for(i=ta[q[t]];i+1;i=nt[i]){\n      if(f[to[i]])continue;\n      q[r++]=to[i];\n      f[to[i]]=1;\n      d[1][to[i]]=d[1][q[t]]+1;//printf(\"%d %d:\",to[i],d[1][to[i]]);\n    }//printf(\"\\n\");\n  }//printf(\"\\n\");\n  //for(i=1;i<=n;i++)printf(\"%d %d %d\\n\",i,d[0][i],d[1][i]);\n  for(i=1;i<=n;i++)printf(\"%d\\n\",n*2-2-MAX(d[0][i],d[1][i]));\n  return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.*;\n\n/*\n                   _ooOoo_\n                  o8888888o\n                  88\" . \"88\n                  (| -_- |)\n                  O\\  =  /O\n               ____/`---'\\____\n             .'  \\\\|     |//  `.\n            /  \\\\|||  :  |||//  \\\n           /  _||||| -:- |||||-  \\\n           |   | \\\\\\  -  /// |   |\n           | \\_|  ''\\---/''  |   |\n           \\  .-\\__  `-`  ___/-. /\n         ___`. .'  /--.--\\  `. . __\n      .\"\" '<  `.___\\_<|>_/___.'  >'\"\".\n     | | :  `- \\`.;`\\ _ /`;.`/ - ` : | |\n     \\  \\ `-.   \\_ __\\ /__ _/   .-` /  /\n======`-.____`-.___\\_____/___.-`____.-'======\n                   `=---='\n^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n            pass System Test!\n*/\n\n@SuppressWarnings(\"unchecked\")\npublic class Main {\n\tprivate static class Task {\n\t\tint INF = (int) 1e9;\n\t\tArrayList<Integer>[] graph;\n\n\t\tvoid bfs(int[] dist, ArrayDeque<Integer> deque) {\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tint v = deque.poll();\n\t\t\t\tfor (int u : graph[v]) {\n\t\t\t\t\tif (dist[u] != INF)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdist[u] = dist[v] + 1;\n\t\t\t\t\tdeque.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint bfs(int s, int[] dist) {\n\t\t\tArrayDeque<Integer> deque = new ArrayDeque<>();\n\t\t\tdeque.add(s);\n\t\t\tdist[s] = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tint p = deque.poll();\n\t\t\t\tfor (int u : graph[p]) {\n\t\t\t\t\tif (dist[u] != INF)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdist[u] = dist[p] + 1;\n\t\t\t\t\tdeque.add(u);\n\t\t\t\t}\n\t\t\t}\n\t\t\tint v = 0;\n\t\t\tfor (int i = 0; i < dist.length; i++) {\n\t\t\t\tif (dist[i] > dist[v])\n\t\t\t\t\tv = i;\n\t\t\t}\n\t\t\treturn v;\n\t\t}\n\n\t\tvoid solve(FastScanner in, PrintWriter out) {\n\t\t\tint N = in.nextInt();\n\t\t\tgraph = new ArrayList[N];\n\t\t\tfor (int i = 0; i < graph.length; i++) {\n\t\t\t\tgraph[i] = new ArrayList<>();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < N - 1; i++) {\n\t\t\t\tint u = in.nextInt() - 1;\n\t\t\t\tint v = in.nextInt() - 1;\n\n\t\t\t\tgraph[u].add(v);\n\t\t\t\tgraph[v].add(u);\n\t\t\t}\n\n\t\t\tint[] dist = new int[N];\n\t\t\tArrays.fill(dist, INF);\n\t\t\tint v = bfs(0, dist);\n\t\t\tArrays.fill(dist, INF);\n\t\t\tint u = bfs(v, dist);\n\n\t\t\tint diameter = dist[u];\n\t\t\tif (diameter % 2 == 1) {\n\t\t\t\tint x = 0, y = 0;\n\t\t\t\tfor (int i = 0; i < dist.length; i++) {\n\t\t\t\t\tif (dist[i] == diameter / 2)\n\t\t\t\t\t\tx = i;\n\t\t\t\t\tif (dist[i] == diameter / 2 + 1)\n\t\t\t\t\t\ty = i;\n\t\t\t\t}\n\t\t\t\t// center is edge x-y\n\t\t\t\tArrays.fill(dist, INF);\n\t\t\t\tArrayDeque<Integer> deque = new ArrayDeque<>();\n\t\t\t\tdeque.add(x);\n\t\t\t\tdeque.add(y);\n\t\t\t\tdist[x] = 0;\n\t\t\t\tdist[y] = 0;\n\t\t\t\tbfs(dist, deque);\n\n\t\t\t\tint[] ans = new int[N];\n\t\t\t\tfor (int i = 0; i < ans.length; i++) {\n\t\t\t\t\tans[i] = diameter / 2 + dist[i] + 1;\n\t\t\t\t\tout.println(2 * (N - 1) - ans[i]);\n\t\t\t\t}\n\n\t\t\t} else {\n\t\t\t\tint x = 0;\n\t\t\t\tfor (int i = 0; i < dist.length; i++) {\n\t\t\t\t\tif (dist[i] == diameter / 2)\n\t\t\t\t\t\tx = i;\n\t\t\t\t}\n\t\t\t\t// center is x\n\t\t\t\tArrays.fill(dist, INF);\n\t\t\t\tArrayDeque<Integer> deque = new ArrayDeque<>();\n\t\t\t\tdeque.add(x);\n\t\t\t\tdist[x] = 0;\n\t\t\t\tbfs(dist, deque);\n\t\t\t\tint[] ans = new int[N];\n\t\t\t\tfor (int i = 0; i < ans.length; i++) {\n\t\t\t\t\tans[i] = diameter / 2 + dist[i];\n\t\t\t\t\tout.println(2 * (N - 1) - ans[i]);\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t}\n\n\t/**\n\t * ?????????????????????????????¬????????§??????\n\t */\n\tpublic static void main(String[] args) {\n\t\tOutputStream outputStream = System.out;\n\t\tFastScanner in = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTask solver = new Task();\n\t\tsolver.solve(in, out);\n\t\tout.close();\n\t}\n\n\tprivate static class FastScanner {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int bufferLength = 0;\n\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < bufferLength) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbufferLength = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (bufferLength <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tprivate int readByte() {\n\t\t\tif (hasNextByte())\n\t\t\t\treturn buffer[ptr++];\n\t\t\telse\n\t\t\t\treturn -1;\n\t\t}\n\n\t\tprivate static boolean isPrintableChar(int c) {\n\t\t\treturn 33 <= c && c <= 126;\n\t\t}\n\n\t\tprivate void skipUnprintable() {\n\t\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\t\tptr++;\n\t\t}\n\n\t\tboolean hasNext() {\n\t\t\tskipUnprintable();\n\t\t\treturn hasNextByte();\n\t\t}\n\n\t\tpublic String next() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile (isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\tif (!hasNext())\n\t\t\t\tthrow new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile (true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tarray[i] = nextDouble();\n\t\t\t}\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn (int) nextLong();\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic String[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic char[][] nextCharMap(int n) {\n\t\t\tchar[][] array = new char[n][];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next().toCharArray();\n\t\t\treturn array;\n\t\t}\n\n\t\tpublic int[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic int[] P;\n\tstatic ArrayList<ArrayList<Integer>> g = new ArrayList<>();\n\n\tpublic static void main(String[] arg) {\n\t\tN = sc.nextInt();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tg.add(new ArrayList<>());\n\t\t}\n\t\tfor (int i = 0; i < N - 1; ++i) {\n\t\t\tint U = Integer.parseInt(sc.next()) - 1;\n\t\t\tint V = Integer.parseInt(sc.next()) - 1;\n\t\t\tg.get(U).add(V);\n\t\t\tg.get(V).add(U);\n\t\t}\n\t\tP = new int[N];\n\t\tP[0] = -1;\n\t\tint[] order = new int[N];\n\t\tint pos = 1;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (int c : g.get(order[i])) {\n\t\t\t\tif (c == P[order[i]]) continue;\n\t\t\t\tP[c] = order[i];\n\t\t\t\torder[pos++] = c;\n\t\t\t}\n\t\t}\n\t\tint[] dp = new int[N];\n\t\tint[] dp2 = new int[N];\n\t\tfor (int i = N - 1; i >= 0; --i) {\n\t\t\tint node = order[i];\n\t\t\tfor (int c : g.get(node)) {\n\t\t\t\tif (c == P[node]) continue;\n\t\t\t\tif (dp[c] + 1 > dp[node]) {\n\t\t\t\t\tdp2[node] = dp[node];\n\t\t\t\t\tdp[node] = dp[c] + 1;\n\t\t\t\t} else if (dp[c] + 1 > dp2[node]) {\n\t\t\t\t\tdp2[node] = dp[c] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tint p = P[order[i]];\n\t\t\tint pv = (dp[p] == dp[order[i]] + 1 ? dp2[p] : dp[p]) + 1;\n\t\t\tif (pv > dp[order[i]]) {\n\t\t\t\tdp2[order[i]] = dp[order[i]];\n\t\t\t\tdp[order[i]] = pv;\n\t\t\t} else if (pv > dp2[order[i]]) {\n\t\t\t\tdp2[order[i]] = pv;\n\t\t\t}\n\t\t}\n\t\tint[] ans = new int[N];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tans[order[i]] = (N - 1) * 2 - dp[order[i]];\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tSystem.out.println(ans[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.IO;\nusing System.Linq;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Text;\nusing System.Numerics;\nusing System.Threading.Tasks;\nusing System.Text.RegularExpressions;\nusing static System.Math;\nusing Debug = System.Diagnostics.Debug;\nusing LayoutKind = System.Runtime.InteropServices.LayoutKind;\nusing MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;\nusing MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;\n\n\nstatic class P\n{\n    static void Main()\n    {\n        var n = int.Parse(Console.ReadLine());\n        OmniTreeDP treeDP = new OmniTreeDP(n, Enumerable.Repeat(0, n - 1).Select(_ => Console.ReadLine().Split().Select(x => int.Parse(x) - 1).ToArray()).ToArray());\n\n        var totalLength = (n - 1) * 2;\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) res[i] = totalLength - treeDP.Query(i) + 1;\n        Console.WriteLine(string.Join(\"\\n\", res));\n    }\n}\n\nclass OmniTreeDP\n{\n    int[][] Neighbours;\n    int[][] IndexForNeighbours;\n\n    int[][] dp;\n    int[] SearchState;\n\n    public OmniTreeDP(int nodeCount, int[][] edges)\n    {\n        List<int>[] neighbours = new List<int>[nodeCount];\n        List<int>[] indexForNeighbours = new List<int>[nodeCount];\n\n        for (int i = 0; i < nodeCount; i++)\n        {\n            neighbours[i] = new List<int>();\n            indexForNeighbours[i] = new List<int>();\n        }\n        for (int i = 0; i < edges.Length; i++)\n        {\n            var edge = edges[i];\n            indexForNeighbours[edge[0]].Add(neighbours[edge[1]].Count);\n            indexForNeighbours[edge[1]].Add(neighbours[edge[0]].Count);\n            neighbours[edge[0]].Add(edge[1]);\n            neighbours[edge[1]].Add(edge[0]);\n        }\n\n        Neighbours = new int[nodeCount][];\n        IndexForNeighbours = new int[nodeCount][];\n        for (int i = 0; i < nodeCount; i++)\n        {\n            Neighbours[i] = neighbours[i].ToArray();\n            IndexForNeighbours[i] = indexForNeighbours[i].ToArray();\n        }\n\n        dp = new int[Neighbours.Length + 1][];\n        SearchState = new int[Neighbours.Length + 1];\n\n        dp[0] = new int[Neighbours.Length];\n        for (int i = 0; i < Neighbours.Length; i++)\n        {\n            dp[i + 1] = new int[Neighbours[i].Length];\n            SearchState[i] = -2;\n        }\n    }\n\n    public int Query(int x)\n    {\n        if (SearchState[x] != -1) DFS(x, -1, x);\n        return dp[0][x];\n    }\n\n    private void DFS(int x, int parent, int xIndexForParent)\n    {\n        Debug.Assert(SearchState[x] != -1 && (SearchState[x] == -2 || Neighbours[x][SearchState[x]] != parent));\n\n        int accum = 0;\n        if (SearchState[x] == -2)\n        {\n            SearchState[x] = -1;\n            for (int i = 0; i < Neighbours[x].Length; i++)\n            {\n                if (Neighbours[x][i] == parent)\n                {\n                    SearchState[x] = i;\n                    continue;\n                }\n                var state = SearchState[Neighbours[x][i]];\n                if (state != -1 && state != IndexForNeighbours[x][i]) DFS(Neighbours[x][i], x, i);\n                accum = Max(accum, dp[x + 1][i]);\n            }\n            dp[parent + 1][xIndexForParent] = accum + 1;\n            if (SearchState[x] != -1) return;\n            accum = 0;\n        }\n        else\n        {\n            var targetInd = SearchState[x];\n            var target = Neighbours[x][targetInd];\n            var targetState = SearchState[target];\n            if (targetState != -1 && targetState != IndexForNeighbours[x][targetInd]) DFS(Neighbours[x][targetInd], x, targetInd);\n        }\n\n        int[] accumsFromTail = new int[Neighbours[x].Length];\n        accumsFromTail[accumsFromTail.Length - 1] = 0;\n        for (int i = accumsFromTail.Length - 2; i >= 0; i--) accumsFromTail[i] = Max(accumsFromTail[i + 1], dp[x + 1][i + 1]);\n        for (int i = 0; i < accumsFromTail.Length; i++)\n        {\n            dp[Neighbours[x][i] + 1][IndexForNeighbours[x][i]] = Max(accum, accumsFromTail[i]) + 1;\n            accum = Max(accum, dp[x + 1][i]);\n        }\n\n        dp[0][x] = accum + 1;\n        SearchState[x] = -1;\n    }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing static System.Console;\nusing static System.Math;\n\nnamespace AtTest.AOJ\n{\n    class TrafficTree\n    {\n        static int n;\n        static int[] dists;\n        static int[] res;\n        static List<int>[] graph;\n\n        static void Main(string[] args)\n        {\n            var sw = new System.IO.StreamWriter(OpenStandardOutput()) { AutoFlush = false };\n            SetOut(sw);\n\n            Method(args);\n\n            Out.Flush();\n        }\n\n        static void Method(string[] args)\n        {\n            n = ReadInt();\n            dists = new int[n];\n            res = new int[n];\n            graph = new List<int>[n];\n            for (int i = 0; i < n; i++) graph[i] = new List<int>();\n            for (int i = 0; i < n - 1; i++)\n            {\n                int[] uv = ReadInts();\n                graph[uv[0] - 1].Add(uv[1] - 1);\n                graph[uv[1] - 1].Add(uv[0] - 1);\n            }\n            DFS1(-1,0);\n            DFS2(-1, 0, 0);\n            for (int i = 0; i < n; i++) WriteLine(res[i]);\n        }\n\n        static int DFS1(int from, int to)\n        {\n            if (to > 0 && graph[to].Count == 1)\n            {\n                dists[to] = 0;\n            }\n            else\n            {\n                int max = 0;\n                for (int i = 0; i < graph[to].Count; i++)\n                {\n                    int next = graph[to][i];\n                    if (next == from) continue;\n                    max = Max(max, DFS1(to, next));\n                }\n                dists[to] = max + 1;\n            }\n            return dists[to];\n        }\n\n        static void DFS2(int from,int to, int pValue)\n        {\n            int maxDist = Max(dists[to], pValue);\n            res[to] = 2 * (n - 1) - maxDist;\n            int max1 = pValue;\n            int max2 = 0;\n            for (int i = 0; i < graph[to].Count; i++)\n            {\n                int next = graph[to][i];\n                if (next == from) continue;\n                int val = dists[next] + 1;\n                if (max1 <= val)\n                {\n                    max2 = max1;\n                    max1 = val;\n                }\n                else if (max2 <= val)\n                {\n                    max2 = val;\n                }\n            }\n            for (int i = 0; i < graph[to].Count; i++)\n            {\n                int next = graph[to][i];\n                if (next == from) continue;\n                int pNext = max1 == dists[next] + 1 ? max2 : max1;\n                pNext++;\n                DFS2(to, next, pNext);\n            }\n        }\n\n        private static string Read() { return ReadLine(); }\n        private static char[] ReadChars() { return Array.ConvertAll(Read().Split(), a => a[0]); }\n        private static int ReadInt() { return int.Parse(Read()); }\n        private static long ReadLong() { return long.Parse(Read()); }\n        private static double ReadDouble() { return double.Parse(Read()); }\n        private static int[] ReadInts() { return Array.ConvertAll(Read().Split(), int.Parse); }\n        private static long[] ReadLongs() { return Array.ConvertAll(Read().Split(), long.Parse); }\n        private static double[] ReadDoubles() { return Array.ConvertAll(Read().Split(), double.Parse); }\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\n\nclass Iroha\n{\n    public Iroha() { }\n    public static int Main()\n    {\n        new Iroha().calc();\n        return 0;\n    }\n\n    Scanner cin;\n\n    P[] R, B;\n    P c1, c2;\n    P[,][] tanR, tanB;\n    int N;\n    double r1, r2;\n\n    double MAX = 1e8;\n\n    void calc()\n    {\n        cin = new Scanner();\n        N = cin.nextInt();\n        c1 = new P(cin.nextDouble(), cin.nextDouble());\n        r1 = cin.nextDouble();\n        c2 = new P(cin.nextDouble(), cin.nextDouble());\n        r2 = cin.nextDouble();\n\n        R = new P[N];\n        B = new P[N];\n        for (int i = 0; i < N; i++)\n        {\n            R[i] = new P(cin.nextDouble(), cin.nextDouble());\n        }\n        for (int i = 0; i < N; i++)\n        {\n            B[i] = new P(cin.nextDouble(), cin.nextDouble());\n        }\n\n        tanR = new P[N, 2][];\n        tanB = new P[N, 2][];\n        for (int i = 0; i < N; i++)\n        {\n            tanR[i, 0] = P.tanCP(c1, r1 + 1e-11, R[i]);\n            tanR[i, 1] = P.tanCP(c2, r2 + 1e-11, R[i]);\n            tanB[i, 0] = P.tanCP(c1, r1 + 1e-11, B[i]);\n            tanB[i, 1] = P.tanCP(c2, r2 + 1e-11, B[i]);\n        }\n\n        double[,] dis = new double[N, N];\n\n        for (int i = 0; i < N; i++)\n        {\n            for (int j = 0; j < N; j++)\n            {\n                double dist = MAX;\n                if (check2(R[i], B[j]))\n                {\n                    dist = R[i].sub(B[j]).abs();\n                }\n                else\n                {\n                    for (int k = 0; k < 2; k++)\n                    {\n                        foreach (var tr in tanR[i, k])\n                        {\n                            foreach (var tb in tanB[j, k])\n                            {\n                                dist = Math.Min(dist, check(R[i], tr, B[j], tb));\n                            }\n                        }\n\n                    }\n                }\n                //Console.WriteLine(i + \" \" + j + \" \" + dist);\n                dis[i, j] = MAX - dist;\n            }\n        }\n\n        double D = hungarian(dis);\n        double ans = (MAX * N) - D;\n        if (ans >= MAX - 1e6) Console.WriteLine(\"Impossible\");\n        else Console.WriteLine(\"{0:0.000000000000000}\", ans);\n    }\n\n\n    double hungarian(double[,] a)\n    {\n        int n = a.GetLength(0);\n        long p, q;\n        double[] fx = new double[n];\n        double[] fy = new double[n];\n        double inf = MAX;\n        long i, j, k;\n        for (i = 0; i < n; i++) fx[i] = inf;\n        for (i = 0; i < n; i++) fy[i] = inf;\n        long[] x = new long[n];\n        long[] y = new long[n];\n        for (i = 0; i < n; i++) x[i] = y[i] = -1;\n\n        for (i = 0; i < n; ++i)\n            for (j = 0; j < n; ++j)\n                fx[i] = Math.Max(fx[i], a[i, j]);\n\n        for (i = 0; i < n;)\n        {\n            long[] t = new long[n];\n            long[] s = new long[n + 1];\n            for (j = 0; j < n; j++) t[j] = -1;\n            for (j = 0; j <= n; j++) s[j] = i;\n            for (p = q = 0; p <= q && x[i] < 0; ++p)\n                for (k = s[p], j = 0; j < n && x[i] < 0; ++j)\n                    if (Math.Abs((fx[k] + fy[j]) - a[k, j]) < 1e-9 && t[j] < 0)\n                    {\n                        s[++q] = y[j];\n                        t[j] = k;\n                        if (s[q] < 0)\n                            for (p = j; p >= 0; j = p)\n                            {\n                                y[j] = k = t[j];\n                                p = x[k];\n                                x[k] = j;\n                            }\n                    }\n            if (x[i] < 0)\n            {\n                double d = inf;\n                for (k = 0; k <= q; ++k)\n                    for (j = 0; j < n; ++j)\n                        if (t[j] < 0) d = Math.Min(d, fx[s[k]] + fy[j] - a[s[k], j]);\n                for (j = 0; j < n; ++j)\n                {\n                    if (t[j] >= 0) fy[j] += d;\n                }\n                for (k = 0; k <= q; ++k) fx[s[k]] -= d;\n            }\n            else ++i;\n        }\n        double ret = 0;\n        for (i = 0; i < n; ++i) ret += a[i, x[i]];\n        return ret;\n    }\n\n    double check(P a, P ta, P b, P tb)\n    {\n        P tp = P.isLL(a, ta, b, tb);\n        if (tp == null) return MAX;\n        if (!check2(a, tp) || !check2(b, tp)) return MAX;\n        else return a.sub(tp).abs() + b.sub(tp).abs();\n    }\n\n    bool check2(P a, P b)\n    {\n        if (P.disSP(a, b, c1) < r1) return false;\n        if (P.disSP(a, b, c2) < r2) return false;\n        return true;\n    }\n  \n}\n\n\nclass P\n{\n    double x, y;\n\n    public P(double x, double y)\n    {\n        this.x = x;\n        this.y = y;\n    }\n\n    public P add(P p)\n    {\n        return new P(x + p.x, y + p.y);\n    }\n\n    public P sub(P p)\n    {\n        return new P(x - p.x, y - p.y);\n    }\n\n    public P mul(double m)\n    {\n        return new P(x * m, y * m);\n    }\n\n    public P div(double d)\n    {\n        return new P(x / d, y / d);\n    }\n\n    public double abs()\n    {\n        return Math.Sqrt(abs2());\n    }\n\n    public double abs2()\n    {\n        return x * x + y * y;\n    }\n\n    public double arg()\n    {\n        return Math.Atan2(y, x);\n    }\n\n    public double dot(P p)\n    {\n        return x * p.x + y * p.y;\n    }\n\n    public double det(P p)\n    {\n        return x * p.y - y * p.x;\n    }\n\n    public double ang(P p)\n    {\n        return Math.Atan2(det(p), dot(p));\n    }\n\n    public P rot90()\n    {\n        return new P(y, -x);\n    }\n\n    public P rot(double d)\n    {\n        return new P(Math.Cos(d) * x - Math.Sin(d) * y, Math.Sin(d) * x + Math.Cos(d) * y);\n    }\n\n    public String toString()\n    {\n        return \"(\" + x + \",\" + y + \")\";\n    }\n\n    static public double rad(P u, P v)\n    {\n        double rad = Math.Atan2(u.det(v), u.dot(v));\n        if (rad < -EPS) rad += 2 * Math.PI;\n        return rad;\n    }\n\n\n    static public double EPS = 1e-9;\n\n    //????????¨???????????¢\n    static public double disSP(P p1, P p2, P q)\n    {\n        if (p2.sub(p1).dot(q.sub(p1)) < EPS) return q.sub(p1).abs();\n        if (p1.sub(p2).dot(q.sub(p2)) < EPS) return q.sub(p2).abs();\n        return disLP(p1, p2, q);\n    }\n\n    //??´?????¨???????????¢\n    static double disLP(P p1, P p2, P q)\n    {\n        return Math.Abs(p2.sub(p1).det(q.sub(p1))) / p2.sub(p1).abs();\n    }    \n\n    //??´?????¨??´????????????\n    static public P isLL(P p1, P p2, P q1, P q2)\n    {\n        double d = q2.sub(q1).det(p2.sub(p1));\n        if (Math.Abs(d) < EPS) return null;\n        return p1.add(p2.sub(p1).mul(q2.sub(q1).det(q1.sub(p1)) / d));\n    }\n\n    //???p ????????????????????\\????????\\???\n    static public P[] tanCP(P c, double r, P p)\n    {\n        double x = p.sub(c).abs2();\n        double d = x - r * r;\n        if (d < -EPS) return new P[0];\n        if (d < 0) d = 0;\n        P q1 = p.sub(c).mul(r * r / x);\n        P q2 = p.sub(c).mul(-r * Math.Sqrt(d) / x).rot90();\n        return new P[] { c.add(q1.sub(q2)), c.add(q1.add(q2)) };\n    }\n}\n\n\nclass Scanner\n{\n    string[] s;\n    int i;\n\n    char[] cs = new char[] { ' ' };\n\n    public Scanner()\n    {\n        s = new string[0];\n        i = 0;\n    }\n\n    public string next()\n    {\n        if (i < s.Length) return s[i++];\n        string st = Console.ReadLine();\n        while (st == \"\") st = Console.ReadLine();\n        s = st.Split(cs, StringSplitOptions.RemoveEmptyEntries);\n        i = 0;\n        return next();\n    }\n\n    public int nextInt()\n    {\n        return int.Parse(next());\n    }\n\n    public long nextLong()\n    {\n        return long.Parse(next());\n    }\n\n    public double nextDouble()\n    {\n        return double.Parse(next());\n    }\n\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nusing vt=System.Tuple<int,int>;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic List<vt>[] li;\n\tstatic bool[] b;\n\tstatic int[] pa;\n\tstatic long[] dp;\n\tstatic long[][] dpl,dpr;\n\tconst int ie=0;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar s=sc.Ia;\n\t\tint n=s[0],m=n-1;\n\t\tli=new List<vt>[n+1];\n\t\tb=new bool[n+1];\n\t\tdp=new long[n+1];\n\t\tdpl=new long[n+1][];\n\t\tdpr=new long[n+1][];\n\t\tpa=new int[n+1];\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tli[i]=new List<vt>();\n\t\t\tli[i].Add(Tuple.Create(-1,-1));\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tvar e=sc.Ia;\n\t\t\tli[e[0]].Add(Tuple.Create(e[1],1));\n\t\t\tli[e[1]].Add(Tuple.Create(e[0],1));\n\t\t}\n\t\tint o=1;\n\t\tFu1(o,0);\n\t\tFu2(o,0);\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i = 1;i<=n;i++) {sb.Append(((n-1)<<1)-dp[i]+\"\\n\");}\n\t\tConsole.Write(sb);\n\t}\n\tstatic void Fu2(int a,long g){\n\t\tdp[a]=Fop(dp[a],g);\n\t\tfor(int i=1;i<li[a].Count;i++){\n\t\t\tif(li[a][i].Item1!=pa[a]){\n\t\t\t\tFu2(li[a][i].Item1,Fop(Fop(dpl[a][i-1],dpr[a][i+1]),g)+li[a][i].Item2);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void Fu1(int a,int o){\n\t\tb[a]=true;\n\t\tpa[a]=o;\n\t\tdpl[a]=new long[li[a].Count];\n\t\tdpr[a]=new long[li[a].Count+1];\n\t\tdpl[a][0]=dpr[a][li[a].Count]=ie;\n\t\tfor(int i=1;i<li[a].Count;i++){\n\t\t\tif(!b[li[a][i].Item1]){\n\t\t\t\tFu1(li[a][i].Item1,a);\n\t\t\t\tdpl[a][i]=dpr[a][i]=dp[li[a][i].Item1]+li[a][i].Item2;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tdpl[a][i]=dpr[a][i]=ie;\n\t\t\t}\n\t\t\tdpl[a][i]=Fop(dpl[a][i],dpl[a][i-1]);\n\t\t}\n\t\tfor(int i = li[a].Count-1;i>=0;i--) {\n\t\t\tdpr[a][i]=Fop(dpr[a][i],dpr[a][i+1]);\n\t\t}\n\t\tdp[a]=dpl[a][li[a].Count-1];\n\t}\n\tstatic long Fop(long a,long b){\n\t\treturn Max(a,b);\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(string a,string b){return Array.ConvertAll((a+Console.ReadLine()+b).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(string a,string b){return Array.ConvertAll((a+Console.ReadLine()+b).Split(),long.Parse);}\n\tpublic double[] Da2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),double.Parse);}}\n\tpublic double[] Da3(string a,string b){return Array.ConvertAll((a+Console.ReadLine()+b).Split(),double.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nclass MainClass\n{\n    static void Main(string[] args)\n    {\n        var n = int.Parse(System.Console.ReadLine().Trim());\n        var nodes = new List<List<int>>(n);\n        foreach (var i in Enumerable.Range(0, n)) nodes.Add(new List<int>());\n        foreach(var i in Enumerable.Range(0, n - 1))\n        {\n            var edge = System.Console.ReadLine().Trim().Split(' ').Select(s => int.Parse(s) - 1).ToArray();\n            nodes[edge[0]].Add(edge[1]);\n            nodes[edge[1]].Add(edge[0]);\n        }\n        var distanceFromZero = DistanceFrom(0, nodes);\n        var maxA = Enumerable.Range(0, n).OrderByDescending(i => distanceFromZero[i]).First();\n        var distanceFromEndA = DistanceFrom(maxA, nodes);\n        var maxB = Enumerable.Range(0, n).OrderByDescending(i => distanceFromEndA[i]).First();\n        var distanceFromEndB = DistanceFrom(maxB, nodes);\n        foreach(var i in Enumerable.Range(0, n))\n        {\n            Console.WriteLine(2 * n - 2 - Math.Max(distanceFromEndA[i], distanceFromEndB[i]));\n        }\n    }\n    static int[] DistanceFrom(int from, List<List<int>> nodes)\n    {\n        var distance = Enumerable.Repeat(-1, nodes.Count).ToArray(); distance[from] = 0;\n        var queue = new Queue<int>(); queue.Enqueue(from);\n        while(queue.Count > 0)\n        {\n            var current = queue.Dequeue();\n            foreach(var next in nodes[current])\n            {\n                if (distance[next] == -1)\n                {\n                    distance[next] = distance[current] + 1;\n                    queue.Enqueue(next);\n                }\n            }\n        }\n        return distance;\n    }\n}\n\n"
  },
  {
    "language": "Go",
    "code": "/*\nURL:\nhttps://onlinejudge.u-aizu.ac.jp/problems/1595\n*/\n\npackage main\n\nimport (\n\t\"bufio\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n)\n\n/********** FAU standard libraries **********/\n\n//fmt.Sprintf(\"%b\\n\", 255) \t// binary expression\n\n/********** I/O usage **********/\n\n//str := ReadString()\n//i := ReadInt()\n//X := ReadIntSlice(n)\n//S := ReadRuneSlice()\n//a := ReadFloat64()\n//A := ReadFloat64Slice(n)\n\n//str := ZeroPaddingRuneSlice(num, 32)\n//str := PrintIntsLine(X...)\n\n/*******************************************************************/\n\nconst (\n\t// General purpose\n\tMOD = 1000000000 + 7\n\t// MOD          = 998244353\n\tALPHABET_NUM = 26\n\tINF_INT64    = math.MaxInt64\n\tINF_BIT60    = 1 << 60\n\tINF_INT32    = math.MaxInt32\n\tINF_BIT30    = 1 << 30\n\tNIL          = -1\n\n\t// for dijkstra, prim, and so on\n\tWHITE = 0\n\tGRAY  = 1\n\tBLACK = 2\n)\n\nfunc init() {\n\t// bufio.ScanWords <---> bufio.ScanLines\n\tReadString = newReadString(os.Stdin, bufio.ScanWords)\n\tstdout = bufio.NewWriter(os.Stdout)\n}\n\ntype Value struct {\n\ttotal, height int\n}\n\nvar (\n\tn int\n\n\tG       [100000 + 50][]int\n\tdp      [100000 + 50]Value\n\tanswers [100000 + 50]Value\n\tei      Value\n)\n\nfunc main() {\n\tn = ReadInt()\n\tfor i := 0; i < n-1; i++ {\n\t\tu, v := ReadInt2()\n\t\tu--\n\t\tv--\n\n\t\tG[u] = append(G[u], v)\n\t\tG[v] = append(G[v], u)\n\t}\n\n\tdfs(0, -1)\n\t// PrintfDebug(\"%v\\n\", dp[:n])\n\n\tei = Value{0, -1}\n\t// rdfs(0, -1, Value{0, 0})\n\trdfs(0, -1, ei)\n\tfor i := 0; i < n; i++ {\n\t\tfmt.Println(2*(n-1) - answers[i].height)\n\t}\n}\n\nfunc rdfs(cid, pid int, dpar Value) {\n\t// ans := Value{total: 0, height: 0}\n\tans := ei\n\tfor _, nid := range G[cid] {\n\t\tif nid == pid {\n\t\t\tans.total += dpar.total + 2\n\t\t\tans.height = Max(ans.height, dpar.height+1)\n\t\t\tcontinue\n\t\t}\n\t\tans.total += dp[nid].total + 2\n\t\tans.height = Max(ans.height, dp[nid].height+1)\n\t}\n\tanswers[cid] = ans\n\n\tcdp := []Value{ei}\n\tnexts := []int{-1}\n\tfor _, nid := range G[cid] {\n\t\tif nid == pid {\n\t\t\tcontinue\n\t\t}\n\t\tcdp = append(cdp, dp[nid])\n\t\tnexts = append(nexts, nid)\n\t}\n\tcdp = append(cdp, ei)\n\tnexts = append(nexts, -1)\n\n\tN := len(cdp)\n\tL, R := make([]Value, N), make([]Value, N)\n\tL[0], R[0], L[N-1], R[N-1] = ei, ei, ei, ei\n\tfor i := 1; i <= N-2; i++ {\n\t\tL[i] = merge(L[i-1], cdp[i])\n\t}\n\tfor i := N - 2; i >= 1; i-- {\n\t\tR[i] = merge(R[i+1], cdp[i])\n\t}\n\n\tfor i := 1; i <= N-2; i++ {\n\t\tnid := nexts[i]\n\t\tndpar := merge(L[i-1], R[i+1])\n\t\tndpar = merge(ndpar, dpar)\n\t\tndpar.height++\n\t\trdfs(nid, cid, ndpar)\n\t}\n}\n\nfunc merge(left, right Value) Value {\n\tres := ei\n\tres.total = left.total + right.total + 2\n\tres.height = Max(left.height, right.height)\n\treturn res\n}\n\nfunc dfs(cid, pid int) {\n\tres := Value{total: 0, height: 0}\n\tfor _, nid := range G[cid] {\n\t\tif nid == pid {\n\t\t\tcontinue\n\t\t}\n\t\tdfs(nid, cid)\n\t\tres.total += dp[nid].total + 2\n\t\tres.height = Max(res.height, dp[nid].height+1)\n\t}\n\tdp[cid] = res\n}\n\n// Max returns the max integer among input set.\n// This function needs at least 1 argument (no argument causes panic).\nfunc Max(integers ...int) int {\n\tm := integers[0]\n\tfor i, integer := range integers {\n\t\tif i == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tif m < integer {\n\t\t\tm = integer\n\t\t}\n\t}\n\treturn m\n}\n\n/*******************************************************************/\n\n/*********** I/O ***********/\n\nvar (\n\t// ReadString returns a WORD string.\n\tReadString func() string\n\tstdout     *bufio.Writer\n)\n\nfunc newReadString(ior io.Reader, sf bufio.SplitFunc) func() string {\n\tr := bufio.NewScanner(ior)\n\tr.Buffer(make([]byte, 1024), int(1e+9)) // for Codeforces\n\tr.Split(sf)\n\n\treturn func() string {\n\t\tif !r.Scan() {\n\t\t\tpanic(\"Scan failed\")\n\t\t}\n\t\treturn r.Text()\n\t}\n}\n\n// ReadInt returns an integer.\nfunc ReadInt() int {\n\treturn int(readInt64())\n}\nfunc ReadInt2() (int, int) {\n\treturn int(readInt64()), int(readInt64())\n}\nfunc ReadInt3() (int, int, int) {\n\treturn int(readInt64()), int(readInt64()), int(readInt64())\n}\nfunc ReadInt4() (int, int, int, int) {\n\treturn int(readInt64()), int(readInt64()), int(readInt64()), int(readInt64())\n}\n\n// ReadInt64 returns as integer as int64.\nfunc ReadInt64() int64 {\n\treturn readInt64()\n}\nfunc ReadInt64_2() (int64, int64) {\n\treturn readInt64(), readInt64()\n}\nfunc ReadInt64_3() (int64, int64, int64) {\n\treturn readInt64(), readInt64(), readInt64()\n}\nfunc ReadInt64_4() (int64, int64, int64, int64) {\n\treturn readInt64(), readInt64(), readInt64(), readInt64()\n}\n\nfunc readInt64() int64 {\n\ti, err := strconv.ParseInt(ReadString(), 0, 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn i\n}\n\n// ReadIntSlice returns an integer slice that has n integers.\nfunc ReadIntSlice(n int) []int {\n\tb := make([]int, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadInt()\n\t}\n\treturn b\n}\n\n// ReadInt64Slice returns as int64 slice that has n integers.\nfunc ReadInt64Slice(n int) []int64 {\n\tb := make([]int64, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadInt64()\n\t}\n\treturn b\n}\n\n// ReadFloat64 returns an float64.\nfunc ReadFloat64() float64 {\n\treturn float64(readFloat64())\n}\n\nfunc readFloat64() float64 {\n\tf, err := strconv.ParseFloat(ReadString(), 64)\n\tif err != nil {\n\t\tpanic(err.Error())\n\t}\n\treturn f\n}\n\n// ReadFloatSlice returns an float64 slice that has n float64.\nfunc ReadFloat64Slice(n int) []float64 {\n\tb := make([]float64, n)\n\tfor i := 0; i < n; i++ {\n\t\tb[i] = ReadFloat64()\n\t}\n\treturn b\n}\n\n// ReadRuneSlice returns a rune slice.\nfunc ReadRuneSlice() []rune {\n\treturn []rune(ReadString())\n}\n\n/*********** Debugging ***********/\n\n// ZeroPaddingRuneSlice returns binary expressions of integer n with zero padding.\n// For debugging use.\nfunc ZeroPaddingRuneSlice(n, digitsNum int) []rune {\n\tsn := fmt.Sprintf(\"%b\", n)\n\n\tresidualLength := digitsNum - len(sn)\n\tif residualLength <= 0 {\n\t\treturn []rune(sn)\n\t}\n\n\tzeros := make([]rune, residualLength)\n\tfor i := 0; i < len(zeros); i++ {\n\t\tzeros[i] = '0'\n\t}\n\n\tres := []rune{}\n\tres = append(res, zeros...)\n\tres = append(res, []rune(sn)...)\n\n\treturn res\n}\n\n// Strtoi is a wrapper of strconv.Atoi().\n// If strconv.Atoi() returns an error, Strtoi calls panic.\nfunc Strtoi(s string) int {\n\tif i, err := strconv.Atoi(s); err != nil {\n\t\tpanic(errors.New(\"[argument error]: Strtoi only accepts integer string\"))\n\t} else {\n\t\treturn i\n\t}\n}\n\n// PrintIntsLine returns integers string delimited by a space.\nfunc PrintIntsLine(A ...int) string {\n\tres := []rune{}\n\n\tfor i := 0; i < len(A); i++ {\n\t\tstr := strconv.Itoa(A[i])\n\t\tres = append(res, []rune(str)...)\n\n\t\tif i != len(A)-1 {\n\t\t\tres = append(res, ' ')\n\t\t}\n\t}\n\n\treturn string(res)\n}\n\n// PrintIntsLine returns integers string delimited by a space.\nfunc PrintInts64Line(A ...int64) string {\n\tres := []rune{}\n\n\tfor i := 0; i < len(A); i++ {\n\t\tstr := strconv.FormatInt(A[i], 10) // 64bit int version\n\t\tres = append(res, []rune(str)...)\n\n\t\tif i != len(A)-1 {\n\t\t\tres = append(res, ' ')\n\t\t}\n\t}\n\n\treturn string(res)\n}\n\n// PrintfDebug is wrapper of fmt.Fprintf(os.Stderr, format, a...)\nfunc PrintfDebug(format string, a ...interface{}) {\n\tfmt.Fprintf(os.Stderr, format, a...)\n}\n\n// PrintfBufStdout is function for output strings to buffered os.Stdout.\n// You may have to call stdout.Flush() finally.\nfunc PrintfBufStdout(format string, a ...interface{}) {\n\tfmt.Fprintf(stdout, format, a...)\n}\n\n"
  },
  {
    "language": "Python",
    "code": "def main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10 ** 9)\n    \n    from collections import deque\n\n    N = int(input())\n\n    #隣接リストの作成\n    G = [[] for _ in range(N)]\n    for _ in range(N - 1):\n        u, v = map(int, input().split())\n        u -= 1\n        v -= 1\n        G[u].append(v)\n        G[v].append(u)\n\n    #直径を求める\n    dist = [-1] * N\n    dist[0] = 0\n    que = deque()\n    que.append(0) #スタート地点を入れる\n    while len(que) != 0:\n        tmp = que.popleft()\n        for i in G[tmp]:\n            if dist[i] == -1:\n                dist[i] = dist[tmp] + 1\n                que.append(i)\n    \n    tmp = 0\n    start = -1\n    for index, x in enumerate(dist):\n        if tmp < x:\n            start = index\n            tmp = x\n    \n    dist = [-1] * N\n    dist[start] = 0\n    que = deque()\n    que.append(start) #スタート地点を入れる\n    while len(que) != 0:\n        tmp = que.popleft()\n        for i in G[tmp]:\n            if dist[i] == -1:\n                dist[i] = dist[tmp] + 1\n                que.append(i)\n\n    tmp = 0\n    gpal = -1\n    for index, x in enumerate(dist):\n        if tmp < x:\n            goal = index\n            tmp = x\n\n    dist1 = [-1] * N\n    dist1[goal] = 0\n    que = deque()\n    que.append(goal) #スタート地点を入れる\n    while len(que) != 0:\n        tmp = que.popleft()\n        for i in G[tmp]:\n            if dist1[i] == -1:\n                dist1[i] = dist1[tmp] + 1\n                que.append(i)\n\n    # print (dist)\n    # print (dist1)\n    for i in range(N):\n        print (2 * (N - 1) - max(dist[i], dist1[i]))\n\nif __name__ == '__main__':\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(10 ** 7)\n\n\ndef resolve():\n    def dfs1(r_topo, par):\n        for i in reversed(r_topo):\n            stack = [i]\n            while stack:\n                idx = stack.pop()\n                for to in G[idx]:\n                    if to == par[i]:\n                        continue\n                    dist[idx] = max(dist[idx], dist[to] + 1)\n\n\n    def dfs2(idx, d_par, par):\n        stack = [(idx,d_par, par)]\n        while stack:\n            idx, d_par, par = stack.pop()\n            d_child = []\n            d_child.append((0, -1))\n            for to in G[idx]:\n                if to == par:\n                    d_child.append((d_par + 1, to))\n                else:\n                    d_child.append((dist[to] + 1, to))\n            d_child.sort(reverse=True)\n            ans[idx] = d_child[0][0]\n            for to in G[idx]:\n                if to == par:\n                    continue\n                nx_d_par = d_child[d_child[0][1] == to][0]\n                stack.append((to, nx_d_par, idx))\n                #dfs2(to, nx_d_par, idx)\n\n    N = int(input())\n    if N == 1:\n        return print(0)\n\n    G = [[] for _ in range(N)]\n    for i in range(N - 1):\n        a, b = map(int, input().split())\n        a -= 1\n        b -= 1\n        G[a].append(b)\n        G[b].append(a)\n\n    topo = []\n    P = [-1] * N\n    node = [0]\n    while node:\n        s = node.pop()\n        topo.append(s)\n        for to in G[s]:\n            if to == P[s]:\n                continue\n            P[to] = s\n            node.append(to)\n\n    dist = [0]*N\n    ans = [0] * N\n    dfs1(topo,P)\n    dfs2(0, 0, -1)\n    for i in range(N):\n        print((N - 1) * 2 - ans[i])\n\n\nif __name__ == '__main__':\n    resolve()\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nN = int(input())\nX = [[] for i in range(N)]\nfor i in range(N-1):\n    x, y = map(int, input().split())\n    X[x-1].append(y-1)\n    X[y-1].append(x-1)\n\nP = [-1] * N\nQ = deque([0])\nT = []\nwhile Q:\n    i = deque.popleft(Q)\n    T.append(i)\n    for a in X[i]:\n        if a != P[i]:\n            P[a] = i\n            X[a].remove(i)\n            deque.append(Q, a)\n\nBUA = [0] * N # Bottom Up : i以下をすべてまわる\nBUB = [0] * N # Bottom Up : i以下をすべてまわってiに戻る\nTDA = [0] * N # Top Down : iの上をすべてまわる\nTDB = [0] * N # Top Down : iの上をすべてまわってiに戻る\nfor i in T[::-1]:\n    if len(X[i]) == 0:\n        BUA[i] = 0\n        BUB[i] = 0\n        continue\n    s = 0\n    ma = 0\n    for j in X[i]:\n        s += BUB[j] + 2\n        ma = max(ma, BUB[j] - BUA[j] + 1)\n    BUA[i] = s - ma\n    BUB[i] = s\n\nfor i in T:\n    B = [0] * (len(X[i]) + 1)\n    C = [0] * (len(X[i]) + 1)\n    for k, j in enumerate(X[i]):\n        B[k+1] = B[k] + BUB[j] + 2\n        C[k+1] = max(C[k], BUB[j] - BUA[j] + 2)\n    s = 0\n    ma = 0\n    for k in range(len(X[i]))[::-1]:\n        j = X[i][k]\n        TDB[j] = TDB[i] + s + B[k] + 2\n        TDA[j] = min(TDB[j] - max(ma, C[k]), TDA[i] + s + B[k] + 1)\n        s += BUB[j] + 2\n        ma = max(ma, BUB[j] - BUA[j] + 2)\n\nfor t in [min(a+d, b+c) for a, b, c, d in zip(BUA, BUB, TDA, TDB)]:\n    print(t)\n"
  },
  {
    "language": "Python",
    "code": "import sys\ninput = sys.stdin.buffer.readline\nsys.setrecursionlimit(10 ** 7)\n\nN = int(input())\nedge = [[] for _ in range(N + 1)]\nfor _ in range(N - 1):\n    x, y = map(int, input().split())\n    x -= 1\n    y -= 1\n    edge[x].append(y)\n    edge[y].append(x)\n\ntopo = []\nparent = [-1] * N\nnode = [0]\nwhile node:\n    s = node.pop()\n    topo.append(s)\n    for t in edge[s]:\n        if t == parent[s]:\n            continue\n        parent[t] = s\n        node.append(t)\n\nmemo = [0] * N  # ノードiより下の情報をマージしたもの\nres = [0] * N  # 求めたいやつ、ノードiの上に出ていく情報\nfor s in reversed(topo):\n    for t in edge[s]:\n        if t == parent[s]:\n            continue\n        memo[s] = max(memo[s], res[t])\n    res[s] = memo[s] + 1\n\n\nTD = [0] * N  # 上からノードiへ向かう辺の情報\nfor s in topo:\n    acc = TD[s]\n    for t in edge[s]:\n        if t == parent[s]:\n            continue\n        TD[t] = max(TD[t], acc)\n        acc = max(acc, res[t])\n    acc = 0\n    for t in reversed(edge[s]):\n        if t == parent[s]:\n            continue\n        TD[t] = max(TD[t], acc) + 1\n        acc = max(acc, res[t])\n        res[t] = max(memo[t], TD[t]) + 1\n\n\nans = [2 * (N - 1) - res[i] + 1 for i in range(N)]\nprint(*ans, sep=\"\\n\")\n\n"
  },
  {
    "language": "Rust",
    "code": "struct Rerooting<Edge, Value, Func> {\n    size: usize,\n    edge: Vec<(usize, usize, Edge)>,\n    initial: Value,\n    merge: Func,\n}\n\nimpl<Edge, Value, Func> Rerooting<Edge, Value, Func>\nwhere Edge: Clone,\n      Value: Clone,\n      Func: Fn(&Value, &Value, &Edge) -> Value {\n    fn new(size: usize, initial: Value, func: Func) -> Self {\n        Rerooting {\n            size: size,\n            edge: vec![],\n            initial: initial,\n            merge: func,\n        }\n    }\n    fn add_edge(&mut self, a: usize, b: usize, cost: Edge) {\n        self.edge.push((a, b, cost));\n    }\n    fn solve(&self) -> Vec<Value> {\n        let mut graph = vec![vec![]; self.size];\n        for e in self.edge.iter() {\n            let a = e.0;\n            let b = e.1;\n            graph[a].push((b, e.2.clone()));\n            graph[b].push((a, e.2.clone()));\n        }\n        let root = 0;\n        let mut topo = vec![];\n        let mut stack = vec![(root, root)];\n        while let Some((v, p)) = stack.pop() {\n            topo.push(v);\n            if let Some(k) = graph[v].iter().position(|e| e.0 == p) {\n                graph[v].remove(k);\n            }\n            for e in graph[v].iter() {\n                stack.push((e.0, v));\n            }\n        }\n        assert!(topo.len() == self.size);\n        let mut down = vec![self.initial.clone(); self.size];\n        for &v in topo.iter().rev() {\n            for e in graph[v].iter() {\n                down[v] = (self.merge)(&down[v], &down[e.0], &e.1);\n            }\n        }\n        let mut up = vec![self.initial.clone(); self.size];\n        let mut ans = up.clone();\n        for &v in topo.iter() {\n            ans[v] = up[v].clone();\n            for e in graph[v].iter() {\n                ans[v] = (self.merge)(&ans[v], &down[e.0], &e.1);\n            }\n            if graph[v].is_empty() {\n                continue;\n            }\n            let mut stack = vec![(graph[v].as_slice(), up[v].clone())];\n            while let Some((g, val)) = stack.pop() {\n                if g.len() == 1 {\n                    up[g[0].0] = (self.merge)(&self.initial, &val, &g[0].1);\n                } else {\n                    let m = g.len() / 2;\n                    let (a, b) = g.split_at(m);\n                    let mut p = val.clone();\n                    for e in a.iter() {\n                        p = (self.merge)(&p, &down[e.0], &e.1);\n                    }\n                    let mut q = val;\n                    for e in b.iter() {\n                        q = (self.merge)(&q, &down[e.0], &e.1);\n                    }\n                    stack.push((b, p));\n                    stack.push((a, q));\n                }\n            }\n        }\n        ans\n    }\n}\n\nuse std::io::Read;\nuse std::io::Write;\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_to_string(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let n: usize = it.next().unwrap().parse().unwrap();\n    type Value = (usize, usize);\n    let ini: Value = (0, 0);\n    let f = |a: &Value, b: &Value, _c: &()| -> Value {\n        (a.0 + 2 + b.0, std::cmp::min(a.0 + 1 + b.1, 2 + b.0 + a.1))\n    };\n    let mut solver = Rerooting::new(n, ini, f);\n    for _ in 1..n {\n        let x = it.next().unwrap().parse::<usize>().unwrap() - 1;\n        let y = it.next().unwrap().parse::<usize>().unwrap() - 1;\n        solver.add_edge(x, y, ());\n    }\n    let ans = solver.solve();\n    let out = std::io::stdout();\n    let mut out = std::io::BufWriter::new(out.lock());\n    for a in ans {\n        writeln!(out, \"{:.7}\", a.1).ok();\n    }\n}\n\nfn main() {\n    run();\n}\n\n"
  }
]