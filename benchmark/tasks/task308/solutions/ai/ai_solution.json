[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\ntypedef struct Graph {\n    int numVertices;\n    Node** adjLists;\n} Graph;\n\nNode* createNode(int v) {\n    Node* newNode = malloc(sizeof(Node));\n    newNode->vertex = v;\n    newNode->next = NULL;\n    return newNode;\n}\n\nGraph* createGraph(int vertices) {\n    Graph* graph = malloc(sizeof(Graph));\n    graph->numVertices = vertices;\n    graph->adjLists = malloc(vertices * sizeof(Node*));\n    for (int i = 0; i < vertices; i++) {\n        graph->adjLists[i] = NULL;\n    }\n    return graph;\n}\n\nvoid addEdge(Graph* graph, int src, int dest) {\n    Node* newNode = createNode(dest);\n    newNode->next = graph->adjLists[src];\n    graph->adjLists[src] = newNode;\n    \n    newNode = createNode(src);\n    newNode->next = graph->adjLists[dest];\n    graph->adjLists[dest] = newNode;\n}\n\ntypedef struct Queue {\n    int front, rear, size;\n    unsigned capacity;\n    int* array;\n} Queue;\n\nQueue* createQueue(unsigned capacity) {\n    Queue* queue = malloc(sizeof(Queue));\n    queue->capacity = capacity;\n    queue->front = queue->size = 0;\n    queue->rear = capacity - 1;\n    queue->array = malloc(capacity * sizeof(int));\n    return queue;\n}\n\nint isFull(Queue* queue) {\n    return (queue->size == queue->capacity);\n}\n\nint isEmpty(Queue* queue) {\n    return (queue->size == 0);\n}\n\nvoid enqueue(Queue* queue, int item) {\n    if (isFull(queue)) return;\n    queue->rear = (queue->rear + 1) % queue->capacity;\n    queue->array[queue->rear] = item;\n    queue->size++;\n}\n\nint dequeue(Queue* queue) {\n    if (isEmpty(queue)) return INT_MIN;\n    int item = queue->array[queue->front];\n    queue->front = (queue->front + 1) % queue->capacity;\n    queue->size--;\n    return item;\n}\n\nint bfs(Graph* graph, int startVertex) {\n    int* visited = malloc(graph->numVertices * sizeof(int));\n    int* distance = malloc(graph->numVertices * sizeof(int));\n    for (int i = 0; i < graph->numVertices; i++) {\n        visited[i] = 0;\n        distance[i] = 0;\n    }\n    \n    Queue* queue = createQueue(graph->numVertices);\n    visited[startVertex] = 1;\n    enqueue(queue, startVertex);\n    \n    int maxDistance = 0;\n    \n    while (!isEmpty(queue)) {\n        int currentVertex = dequeue(queue);\n        Node* temp = graph->adjLists[currentVertex];\n        \n        while (temp) {\n            int adjVertex = temp->vertex;\n            if (!visited[adjVertex]) {\n                visited[adjVertex] = 1;\n                distance[adjVertex] = distance[currentVertex] + 1;\n                if (distance[adjVertex] > maxDistance) {\n                    maxDistance = distance[adjVertex];\n                }\n                enqueue(queue, adjVertex);\n            }\n            temp = temp->next;\n        }\n    }\n    \n    free(visited);\n    free(distance);\n    free(queue->array);\n    free(queue);\n    \n    return maxDistance * 2;\n}\n\nint main() {\n    int N;\n    scanf(\"%d\", &N);\n    Graph* graph = createGraph(N);\n    \n    for (int i = 0; i < N - 1; i++) {\n        int u, v;\n        scanf(\"%d %d\", &u, &v);\n        addEdge(graph, u - 1, v - 1);\n    }\n    \n    for (int i = 0; i < N; i++) {\n        printf(\"%d\\n\", bfs(graph, i));\n    }\n    \n    for (int i = 0; i < N; i++) {\n        Node* temp = graph->adjLists[i];\n        while (temp) {\n            Node* next = temp->next;\n            free(temp);\n            temp = next;\n        }\n    }\n    free(graph->adjLists);\n    free(graph);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:01:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\nvector<vector<int>> adj;\nvector<int> bfs(int start, int N) {\n    vector<int> dist(N + 1, -1);\n    queue<int> q;\n    q.push(start);\n    dist[start] = 0;\n    while (!q.empty()) {\n        int u = q.front();\n        q.pop();\n        for (int v : adj[u]) {\n            if (dist[v] == -1) {\n                dist[v] = dist[u] + 1;\n                q.push(v);\n            }\n        }\n    }\n    return dist;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    adj.resize(N + 1);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adj[u].push_back(v);\n        adj[v].push_back(u);\n    }\n\n    for (int u = 1; u <= N; ++u) {\n        vector<int> dist = bfs(u, N);\n        int max_dist = *max_element(dist.begin() + 1, dist.end());\n        cout << 2 * (N - 1) - max_dist << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:02:02"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GraphSteps {\n    static List<List<Integer>> adj;\n    static int N;\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        N = scanner.nextInt();\n        adj = new ArrayList<>(N + 1);\n        for (int i = 0; i <= N; i++) {\n            adj.add(new ArrayList<>());\n        }\n        for (int i = 0; i < N - 1; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            adj.get(u).add(v);\n            adj.get(v).add(u);\n        }\n\n        for (int i = 1; i <= N; i++) {\n            System.out.println(bfs(i));\n        }\n    }\n\n    static int bfs(int start) {\n        boolean[] visited = new boolean[N + 1];\n        Queue<Integer> queue = new LinkedList<>();\n        queue.add(start);\n        visited[start] = true;\n        int steps = 0;\n        int remaining = 1;\n        int nextRemaining = 0;\n        int visitedCount = 1;\n\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            for (int neighbor : adj.get(current)) {\n                if (!visited[neighbor]) {\n                    visited[neighbor] = true;\n                    queue.add(neighbor);\n                    nextRemaining++;\n                    visitedCount++;\n                }\n            }\n            remaining--;\n            if (remaining == 0) {\n                if (visitedCount < N) {\n                    steps++;\n                }\n                remaining = nextRemaining;\n                nextRemaining = 0;\n            }\n        }\n        return steps;\n    }\n}",
    "timestamp": "2025-08-05 21:02:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ShortestPathToAllVertices {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        \n        List<List<Integer>> graph = new ArrayList<>(N + 1);\n        for (int i = 0; i < N + 1; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < N - 1; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n        \n        for (int start = 1; start <= N; start++) {\n            int steps = bfs(graph, start, N);\n            System.out.println(steps);\n        }\n        \n        scanner.close();\n    }\n    \n    private static int bfs(List<List<Integer>> graph, int start, int N) {\n        boolean[] visited = new boolean[N + 1];\n        Queue<Integer> queue = new LinkedList<>();\n        queue.offer(start);\n        visited[start] = true;\n        \n        int steps = 0;\n        int visitedCount = 1;\n        \n        while (visitedCount < N) {\n            int size = queue.size();\n            \n            for (int i = 0; i < size; i++) {\n                int current = queue.poll();\n                \n                for (int neighbor : graph.get(current)) {\n                    if (!visited[neighbor]) {\n                        queue.offer(neighbor);\n                        visited[neighbor] = true;\n                        visitedCount++;\n                    }\n                }\n            }\n            \n            steps++;\n        }\n        \n        return steps;\n    }\n}",
    "timestamp": "2025-08-05 21:02:24"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_N 100005\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\nNode* graph[MAX_N];\nint visited[MAX_N];\nint max_depth;\n\nvoid add_edge(int u, int v) {\n    Node* new_node1 = malloc(sizeof(Node));\n    new_node1->vertex = v;\n    new_node1->next = graph[u];\n    graph[u] = new_node1;\n\n    Node* new_node2 = malloc(sizeof(Node));\n    new_node2->vertex = u;\n    new_node2->next = graph[v];\n    graph[v] = new_node2;\n}\n\nvoid dfs(int vertex, int depth) {\n    visited[vertex] = 1;\n    max_depth = (depth > max_depth) ? depth : max_depth;\n\n    for (Node* curr = graph[vertex]; curr != NULL; curr = curr->next) {\n        if (!visited[curr->vertex]) {\n            dfs(curr->vertex, depth + 1);\n        }\n    }\n}\n\nint main() {\n    int N, u, v;\n    scanf(\"%d\", &N);\n\n    for (int i = 1; i < N; i++) {\n        scanf(\"%d %d\", &u, &v);\n        add_edge(u, v);\n    }\n\n    for (int i = 1; i <= N; i++) {\n        memset(visited, 0, sizeof(visited));\n        max_depth = 0;\n        dfs(i, 0);\n        printf(\"%d\\n\", max_depth);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:02:29"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <limits>\n\nusing namespace std;\n\nconst int MAXN = 2e5 + 5;\nvector<int> graph[MAXN];\nint dist[MAXN];\nbool visited[MAXN];\n\nint bfs(int start, int n) {\n    fill(visited, visited + n + 1, false);\n    fill(dist, dist + n + 1, numeric_limits<int>::max());\n    \n    queue<int> q;\n    q.push(start);\n    visited[start] = true;\n    dist[start] = 0;\n    \n    int max_steps = 0;\n    int vertices_visited = 1;\n    \n    while (!q.empty()) {\n        int curr = q.front();\n        q.pop();\n        \n        for (int neighbor : graph[curr]) {\n            if (!visited[neighbor]) {\n                q.push(neighbor);\n                visited[neighbor] = true;\n                dist[neighbor] = dist[curr] + 1;\n                max_steps = max(max_steps, dist[neighbor]);\n                vertices_visited++;\n            }\n        }\n    }\n    \n    return (vertices_visited == n) ? max_steps : -1;\n}\n\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n    \n    int n;\n    cin >> n;\n    \n    for (int i = 0; i < n - 1; i++) {\n        int u, v;\n        cin >> u >> v;\n        graph[u].push_back(v);\n        graph[v].push_back(u);\n    }\n    \n    for (int i = 1; i <= n; i++) {\n        cout << bfs(i, n) << \"\\n\";\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:02:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef bfs(graph, start, n):\n    visited = [False] * (n + 1)\n    distances = [0] * (n + 1)\n    visited[start] = True\n    queue = deque([start])\n    \n    while queue:\n        node = queue.popleft()\n        for neighbor in graph[node]:\n            if not visited[neighbor]:\n                visited[neighbor] = True\n                distances[neighbor] = distances[node] + 1\n                queue.append(neighbor)\n\n    return distances\n\ndef compute_steps(graph, n):\n    results = []\n    for i in range(1, n + 1):\n        distances = bfs(graph, i, n)\n        results.append(sum(distances[1:]))  # Sum of distances from i\n    return results\n\nn = int(input().strip())\ngraph = {i: [] for i in range(1, n + 1)}\n\nfor _ in range(n - 1):\n    u, v = map(int, input().strip().split())\n    graph[u].append(v)\n    graph[v].append(u)\n\nresults = compute_steps(graph, n)\n\nfor result in results:\n    print(result)",
    "timestamp": "2025-08-13 04:36:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GraphTraversal {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int N = sc.nextInt(); // Number of vertices\n        List<List<Integer>> adjList = new ArrayList<>(N + 1);\n        \n        for (int i = 0; i <= N; i++) {\n            adjList.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < N - 1; i++) {\n            int u = sc.nextInt();\n            int v = sc.nextInt();\n            adjList.get(u).add(v);\n            adjList.get(v).add(u);\n        }\n        \n        for (int i = 1; i <= N; i++) {\n            System.out.println(calculateShortestSteps(i, adjList, N));\n        }\n        \n        sc.close();\n    }\n    \n    private static int calculateShortestSteps(int start, List<List<Integer>> adjList, int N) {\n        int[] depth = new int[N + 1];\n        Arrays.fill(depth, -1);\n        Queue<Integer> queue = new LinkedList<>();\n        \n        queue.add(start);\n        depth[start] = 0;\n        int totalSteps = 0;\n        \n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            \n            for (int neighbor : adjList.get(node)) {\n                if (depth[neighbor] == -1) {\n                    queue.add(neighbor);\n                    depth[neighbor] = depth[node] + 1;\n                    totalSteps += depth[neighbor];\n                }\n            }\n        }\n        \n        return totalSteps;\n    }\n}",
    "timestamp": "2025-08-13 04:36:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 100005\n#define INF 1000000000\n\ntypedef struct Node {\n    int vertex;\n    struct Node* next;\n} Node;\n\nNode* addEdge(Node* head, int vertex) {\n    Node* newNode = (Node*)malloc(sizeof(Node));\n    newNode->vertex = vertex;\n    newNode->next = head;\n    return newNode;\n}\n\nvoid bfs(int start, int n, Node* adjList[], int dist[]) {\n    int queue[MAXN], front = 0, rear = 0;\n    int visited[MAXN];\n    memset(visited, 0, sizeof(visited));\n\n    queue[rear++] = start;\n    dist[start] = 0;\n    visited[start] = 1;\n\n    while (front < rear) {\n        int u = queue[front++];\n        for (Node* node = adjList[u]; node != NULL; node = node->next) {\n            int v = node->vertex;\n            if (!visited[v]) {\n                visited[v] = 1;\n                dist[v] = dist[u] + 1;\n                queue[rear++] = v;\n            }\n        }\n    }\n}\n\n// Function to find the total steps starting from vertex `start`\nint totalSteps(int start, int n, Node* adjList[]) {\n    int dist[MAXN];\n    memset(dist, -1, sizeof(dist));\n    bfs(start, n, adjList, dist);\n\n    int total_steps = 0;\n    for (int i = 1; i <= n; i++) {\n        total_steps += dist[i];\n    }\n    return total_steps;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n\n    Node* adjList[MAXN];\n    for (int i = 1; i <= n; i++) {\n        adjList[i] = NULL;\n    }\n\n    for (int i = 0; i < n-1; i++) {\n        int a, b;\n        scanf(\"%d %d\", &a, &b);\n        adjList[a] = addEdge(adjList[a], b);\n        adjList[b] = addEdge(adjList[b], a);\n    }\n\n    for (int i = 1; i <= n; i++) {\n        printf(\"%d\\n\", totalSteps(i, n, adjList));\n    }\n\n    // Free memory\n    for (int i = 1; i <= n; i++) {\n        Node* node = adjList[i];\n        while (node != NULL) {\n            Node* temp = node;\n            node = node->next;\n            free(temp);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 04:36:40"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\n\ndef solve_shortest_paths(N, edges):\n    # Create adjacency list representation of graph\n    graph = defaultdict(list)\n    for u, v in edges:\n        graph[u].append(v)\n        graph[v].append(u)\n    \n    # Function to do BFS from a start vertex\n    def bfs(start):\n        dist = [float('inf')] * (N+1)\n        dist[start] = 0\n        queue = deque([start])\n        max_steps = 0\n        visited = set([start])\n        \n        while queue:\n            curr = queue.popleft()\n            max_steps = max(max_steps, dist[curr])\n            \n            for neighbor in graph[curr]:\n                if neighbor not in visited:\n                    visited.add(neighbor)\n                    dist[neighbor] = dist[curr] + 1\n                    queue.append(neighbor)\n        \n        # Check if all vertices were visited\n        return max_steps if len(visited) == N else -1\n    \n    # Compute result for each vertex\n    result = []\n    for i in range(1, N+1):\n        result.append(bfs(i))\n    \n    return result\n\n# Read input\nN = int(input())\nedges = []\nfor _ in range(N-1):\n    u, v = map(int, input().split())\n    edges.append((u, v))\n\n# Get and print result\nresult = solve_shortest_paths(N, edges)\nprint(*result)",
    "timestamp": "2025-08-13 04:36:49"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef main():\n    input = sys.stdin.read().split()\n    ptr = 0\n    N = int(input[ptr])\n    ptr += 1\n    adj = [[] for _ in range(N+1)]\n    for _ in range(N-1):\n        u = int(input[ptr])\n        v = int(input[ptr+1])\n        ptr +=2\n        adj[u].append(v)\n        adj[v].append(u)\n    \n    def bfs(start):\n        visited = [-1]*(N+1)\n        q = deque()\n        q.append(start)\n        visited[start] = 0\n        last_node = start\n        while q:\n            u = q.popleft()\n            for v in adj[u]:\n                if visited[v] == -1:\n                    visited[v] = visited[u] + 1\n                    q.append(v)\n                    last_node = v\n        return last_node, visited\n    \n    # Find one end of the diameter\n    node, _ = bfs(1)\n    # Find the other end of the diameter\n    far_node, _ = bfs(node)\n    # Get distances from node and far_node\n    _, dist1 = bfs(node)\n    _, dist2 = bfs(far_node)\n    \n    res = []\n    for i in range(1, N+1):\n        res.append(str(max(dist1[i], dist2[i])))\n    print(' '.join(res))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 04:37:01"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nvector<int> bfs(int start, const vector<vector<int>>& adjList) {\n    int N = adjList.size();\n    vector<int> dist(N, -1);\n    queue<int> q;\n    q.push(start);\n    dist[start] = 0;\n\n    while (!q.empty()) {\n        int node = q.front();\n        q.pop();\n        \n        for (int neighbor : adjList[node]) {\n            if (dist[neighbor] == -1) {\n                dist[neighbor] = dist[node] + 1;\n                q.push(neighbor);\n            }\n        }\n    }\n    \n    return dist;\n}\n\nint calculateSumOfDistances(const vector<int>& dist) {\n    int total = 0;\n    for (int d : dist) {\n        total += d;\n    }\n    return total;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<vector<int>> adjList(N + 1);\n    for (int i = 0; i < N - 1; ++i) {\n        int u, v;\n        cin >> u >> v;\n        adjList[u].push_back(v);\n        adjList[v].push_back(u);\n    }\n    \n    for (int i = 1; i <= N; ++i) {\n        vector<int> dist = bfs(i, adjList);\n        int sumOfDistances = calculateSumOfDistances(dist);\n        cout << sumOfDistances << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:20:32"
  }
]