[
  {
    "language": "Scala",
    "code": "import scala.io.StdIn\n\nobject Main extends App {\n\n  val Array(h, w) = StdIn.readLine().split(' ').map(_.toInt)\n\n  val tiles = (0 until h).map(_ => StdIn.readLine().split(' ')).toArray\n  val square = Array.fill[Int](h, w)(1)\n\n  (0 until h).foreach { i =>\n    (0 until w).foreach { k =>\n      square(i)(k) = if (tiles(i)(k) == \"1\") {\n        0\n      } else if (i == 0) {\n        square(i)(k)\n      } else {\n        square(i - 1)(k) + 1\n      }\n    }\n  }\n\n  case class Rect(height: Int, pos: Int)\n\n  def pop(lst: List[Rect], row: Array[Int], index: Int): (List[Rect], Int) = {\n    val currentH = if (index == row.length) row(index - 1) else row(index)\n    lst.foldLeft((List.empty[Rect], 0)) { (acc, e) =>\n      if (e.height >= currentH) {\n        (acc._1, scala.math.max(acc._2, e.height * (index - e.pos)))\n      } else {\n        (e :: acc._1, acc._2)\n      }\n    }\n  }\n\n  def loop(lst: List[Rect], row: Array[Int], index: Int): Int = {\n    if (index == row.length) {\n      pop(lst, row, index)._2\n    } else if (lst.isEmpty || lst(0).height < row(index)) {\n      loop(Rect(row(index), index) :: lst, row, index + 1)\n    } else if (lst(0).height == row(index)) {\n      loop(lst, row, index + 1)\n    } else {\n      val r = pop(lst, row, index)\n      if (r._1.isEmpty) {\n        r._2\n      }\n      else {\n        loop(r._1, row, index + 1)\n      }\n    }\n  }\n\n  val result = square.foldLeft(0L) { (acc, elm) =>\n    scala.math.max(acc, loop(List.empty[Rect], elm, 0))\n  }\n\n  println(result)\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "\nimport scala.io.StdIn\n\nobject Main extends App {\n\n  val Array(h, w) = StdIn.readLine().split(' ').map(_.toInt)\n\n  val tiles = (0 until h).map(_ => StdIn.readLine().split(' ')).toArray\n  val square = Array.fill[Int](h, w)(1)\n\n  (0 until h).foreach { i =>\n    (0 until w).foreach { k =>\n      square(i)(k) = if (tiles(i)(k) == \"1\") {\n        0\n      } else if (i == 0) {\n        square(i)(k)\n      } else {\n        square(i - 1)(k) + 1\n      }\n    }\n  }\n\n  case class Rect(height: Int, pos: Int)\n\n  def pop(lst: List[Rect], row: Array[Int], index: Int): (List[Rect], Int, Int) = {\n    val currentH = if (index == row.length) row(index - 1) else row(index)\n    lst.foldLeft((List.empty[Rect], 0, 0)) { (acc, e) =>\n      if (e.height >= currentH) {\n        (acc._1, scala.math.max(acc._2, e.height * (index - e.pos)), e.pos)\n      } else {\n        (e :: acc._1, acc._2, acc._3)\n      }\n    }\n  }\n\n  def loop(lst: List[Rect], row: Array[Int], index: Int, max: Int): Int = {\n    if (index == row.length) {\n      scala.math.max(max, pop(lst, row, index)._2)\n    } else if (lst.isEmpty || lst.head.height < row(index)) {\n      loop(Rect(row(index), index) :: lst, row, index + 1, max)\n    } else if (lst.head.height == row(index)) {\n      loop(lst, row, index + 1, max)\n    } else {\n      val r = pop(lst, row, index)\n      if (r._1.isEmpty) {\n        scala.math.max(max, r._2)\n      }\n      else {\n        loop(Rect(row(index), r._3) :: r._1, row, index + 1, max)\n      }\n    }\n  }\n\n  val result = square.foldLeft(0L) { (acc, elm) =>\n    scala.math.max(acc, loop(List.empty[Rect], elm, 0, 0))\n  }\n\n  println(result)\n}\n\n"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn\n\nobject Main extends App {\n\n  val Array(h, w) = StdIn.readLine().split(' ').map(_.toInt)\n\n  val tiles = (0 until h).map(_ => StdIn.readLine().split(' ')).toArray\n  val square = Array.fill[Int](h, w)(1)\n\n  (0 until h).foreach { i =>\n    (0 until w).foreach { k =>\n      square(i)(k) = if (tiles(i)(k) == \"1\") {\n        0\n      } else if (i == 0) {\n        square(i)(k)\n      } else {\n        square(i - 1)(k) + 1\n      }\n    }\n  }\n\n  case class Rect(height: Int, pos: Int)\n\n  def pop(lst: List[Rect], row: Array[Int], index: Int): (List[Rect], Int) = {\n    lst.foldLeft((List.empty[Rect], 0)) { (acc, e) =>\n      if (e.height >= row(index)) {\n        (acc._1, scala.math.max(acc._2, e.height * (index - e.pos)))\n      } else {\n        (e :: acc._1, acc._2)\n      }\n    }\n  }\n\n  def loop(lst: List[Rect], row: Array[Int], index: Int): Int = {\n    if (index == row.length) {\n      pop(lst, row, index - 1)._2\n    } else if (lst.isEmpty || lst(0).height < row(index)) {\n      loop(Rect(row(index), index) :: lst, row, index + 1)\n    } else if (lst(0).height == row(index)) {\n      loop(lst, row, index + 1)\n    } else {\n      val r = pop(lst, row, index)\n      if (r._1.isEmpty) {\n        r._2\n      }\n      else {\n        loop(r._1, row, index + 1)\n      }\n    }\n  }\n\n  val result = square.foldLeft(0L) { (acc, elm) =>\n    scala.math.max(acc, loop(List.empty[Rect], elm, 0))\n  }\n\n  println(result)\n}\n"
  },
  {
    "language": "Scala",
    "code": "import java.util.Scanner\nimport scala.collection.mutable.Stack \n\nobject Main extends App { \n  val sc = new Scanner(System.in)\n  val H, W = sc.nextInt()\n  val map = Array.ofDim[Int](H,W)\n  for (i <- 0 until H; j <- 0 until W) map(i)(j) = sc.nextInt()\n\n  val bar = Array.fill[Int](W)(0)\n  val hist = new Histgram()\n\n  class Histgram() {\n    var stack = Stack[Int]()\n\n    @scala.annotation.tailrec\n    final def solver(i:Int, m:Int):Int = {\n      def compute(i:Int, m:Int):Int = {\n        if (stack.isEmpty || i < W && bar(stack.top) <= bar(i)) m\n        else {\n          val t = stack.pop\n          val n = bar(t) * (if (stack.isEmpty) i else (i -stack.top -1))\n\n          compute(i, n max m)\n        }\n      }\n\n      if (i == W) compute(i, m)\n      else if (stack.isEmpty || bar(stack.top) <= bar(i)) {\n        stack.push(i)\n        solver(i+1, m)\n      }\n      else solver(i, compute(i, m))\n\n    }\n  }\n\n  def solver(h:Int, m:Int):Int = {\n    if (h < H) {\n      map(h).indices.foreach(i => bar(i) = if (map(h)(i) == 0) bar(i)+1 else 0)\n      val n = hist.solver(0, 0)\n      solver(h+1, m max n)\n    } else m\n  }\n\n  println(solver(0, 0))\n\n}\n"
  },
  {
    "language": "Scala",
    "code": "import scala.io.StdIn\n\nobject Main extends App {\n\n  val Array(h, w) = StdIn.readLine().split(' ').map(_.toInt)\n\n  val tiles = (0 until h).map(_ => StdIn.readLine().split(' ')).toArray\n  val square = Array.fill[Int](h, w)(1)\n\n  (0 until h).foreach { i =>\n    (0 until w).foreach { k =>\n      square(i)(k) = if (tiles(i)(k) == \"1\") {\n        0\n      } else if (i == 0) {\n        square(i)(k)\n      } else {\n        square(i - 1)(k) + 1\n      }\n    }\n  }\n\n  case class Rect(height: Int, pos: Int)\n\n  def pop(lst: List[Rect], row: Array[Int], index: Int): (List[Rect], Int, Int) = {\n    val currentH = if (index == row.length) 0 else row(index)\n    val (heigher, least) = lst.partition(e => e.height >= currentH)\n    val rh = heigher.foldLeft((0, 0)) { (acc, e) =>\n      (scala.math.max(acc._1, e.height * (index - e.pos)), e.pos)\n    }\n    (least, rh._1, rh._2)\n  }\n\n  def loop(row: Array[Int]): Int = {\n    (0 to w).foldLeft(List.empty[Rect], 0) { (acc, index) =>\n      val (lst, temp) = acc\n      if (lst.isEmpty) {\n        (Rect(row(index), index) :: lst, temp)\n      } else if (index == row.length) {\n        val (l, max, pos) = pop(lst, row, index)\n        (l, scala.math.max(max, temp))\n      } else {\n        if (lst.head.height < row(index)) {\n          (Rect(row(index), index) :: lst, temp)\n        } else if (lst.head.height > row(index)) {\n          val (l, max, pos) = pop(lst, row, index)\n          (Rect(row(index), pos) :: l, scala.math.max(max, temp))\n        } else {\n          (lst, temp)\n        }\n      }\n    }._2\n\n  }\n\n\n  val result = square.foldLeft(0) { (acc, elm) =>\n    //println(elm.mkString(\" \"))\n    //println(s\"$acc\")\n    scala.math.max(acc, loop(elm))\n  }\n\n  println(result)\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nclass Rect {\npublic:\n  int h, idx;\n  Rect(int h, int idx): h(h), idx(idx) {}\n};\n\nlong max_from_hist(vector<int> cols) {\n  stack<Rect> s;\n  long max_v = 0;\n  cols[cols.size()] = 0;\n\n  for (int i = 0; i <= cols.size(); i++) {\n    Rect r(cols[i], i);\n\n    if (s.empty() || s.top().h < r.h) {\n      s.push(r);\n    } else if (s.top().h > r.h) {\n      int pos = i;\n\n      while (!s.empty() && s.top().h >= r.h) {\n        Rect pre = s.top(); s.pop();\n        long area = pre.h * (i - pre.idx); // h * colnum\n        max_v = max(max_v, area);\n        pos = pre.idx;\n      }\n\n      s.push(Rect(r.h, pos));\n    }\n  }\n\n  return max_v;\n}\n\nint main() {\n  int h, w; cin >> h >> w;\n\n  vector<vector<int> > T(h, vector<int>(w, 0));\n  vector<vector<int> > A(h, vector<int>(w, 0));\n\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      cin >> T[i][j];\n    }\n  }\n\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if (T[i][j]) A[i][j] = 0;\n      else A[i][j] = (i ? A[i-1][j] + 1 : 1);\n    }\n  }\n\n  long max_v = 0;  \n\n  for (int i = 0; i < h; i++)\n    max_v = max(max_v, max_from_hist(A[i]));\n\n  cout << max_v << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX 1400\n\nstruct Rectangle{\n    // indexの地点の高さ\n    int height;\n    // 始点のX\n    int pos;\n};\n\n// buf = Tの一行の配列\n// size = Tの一行のサイズ\nint getLargestRectangle(int size,int buf[]){\n    // stackとして長方形を保存\n    stack<Rectangle> s;\n    int maxV = 0;\n    // 配列の最後を0にすることで、範囲外後に最大面積を計算するようにする\n    buf[size] = 0;\n    // stoperまで回す\n    for(int i = 0;i <= size;++i){\n        Rectangle rect;\n        // 高さ代入\n        rect.height = buf[i];\n        // 横の位置は計算を始める時点の位置\n        rect.pos = i;\n        // stack空ならば追加\n        if(s.empty()){\n            s.push(rect);\n        }\n        else{\n            // stackのトップにあるrectの高さより高い場合\n            if(s.top().height < rect.height){\n                s.push(rect);\n            }\n            // stackのトップにあるrectの高さよりも低い場合(保存してあった最大の高さが無効になるので、無効になる高さの面積を計算する必要がある)\n            else if(s.top().height > rect.height){\n                // 新しく積むrectの幅を出すために保存しておく。\n                int targetX = i;\n                // スタックに入っているrectが対象のrectの高さ以上の場合最大面積を計算する\n                while(!s.empty() && s.top().height >= rect.height){\n                    Rectangle pre = s.top();\n                    s.pop();\n                    // 面積を計算する()\n                    int area = pre.height * (i - pre.pos);\n                    maxV = max(maxV,area);\n                    // 始点Xを入れ替える(stackに詰むrectの高さは取り出したrectの高さよりも低いので、取り出した地点が、回診X座標になる)\n                    targetX = pre.pos;\n                }\n                rect.pos = targetX;\n                s.push(rect);\n            }\n        }\n    }\n    return maxV;\n}\n\nint H,W;\n// タイル情報を2次元で保存0:綺麗なタイル,1:汚れたタイル\nint tiles[MAX][MAX];\n// 高さを格納する2次元配列\nint T[MAX][MAX];\n\nint getLargestRectangle(){\n    // ①各々の地点における高さを格納するプロセス\n    for(int j = 0;j < W;++j){\n        for(int i = 0;i < H;++i){\n            // 汚れたタイル\n            if(tiles[i][j]){\n                T[i][j] = 0;\n            }\n            else{\n                // 対象のindex地点の高さを格納する\n                // 上の地点 + 1の高さになる\n                T[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;    \n            }\n        }\n    }\n    // 最大面積保存用\n    int maxV = 0;\n    // 最大高さ分回す\n    for(int i = 0;i < H;++i){\n        maxV = max(maxV,getLargestRectangle(W,T[i]));\n    }\n    return maxV;\n}\n\nint main(){\n    scanf(\"%d %d\",&H,&W);\n    for(int i = 0;i < H;++i){\n        for(int j = 0;j < W;++j){\n            scanf(\"%d\",&tiles[i][j]);\n        }\n    }\n    printf(\"%d\\n\",getLargestRectangle());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n\n\n/*struct point {\n\tint x; int y;\n\tint sum = x + y;\n};\nint main() {\n\tpoint p1;\n\tp1.x = 2;\n\tp1.y = 7;\n\tcout << p1.sum << endl;\n}*/\n\n\n\n\n\n/*int main() {\n\tint h, w, x;\n\tcin >> h >> w;\n\tint dp[140][140];\n\tfor (int i = 0; i < h; i++) dp[i][0] = 1;\n\tfor (int j = 0; j < w; j++) dp[0][j] = 1;\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tcin >> x;\n\t\t\tif (x) dp[i][j] = 0;\n\t\t}\n\t}\n\tint mw = 0;\n\tfor (int i = 1; i < h; i++) {\n\t\tfor (int j = 1; j < w; j++) {\n\t\t\tif (!dp[i][j]) continue;\n\t\t\tdp[i][j] = min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1])) + 1;\n\t\t\tmw = max(mw, dp[i][j]);\n\t\t}\n\t}\n\tcout << mw*mw << endl;\n\treturn 0;\n}*/\nconst int num = 140;\nstruct Rectangle {\n\tint he, p;\n};\ninline int lr(int w, int bf[]) {\n\tbf[w] = 0;\n\tstack<Rectangle> s;\n\tint maxv = 0, area = 0;\n\tfor (int i = 0; i <= w; i++) {\n\t\tRectangle rect;\n\t\trect.he = bf[i];\n\t\trect.p = i;\n\t\tif (s.empty()) s.push(rect);\n\t\telse if (s.top().he < rect.he) s.push(rect);\n\t\telse if (s.top().he > rect.he) {\n\t\t\twhile (!s.empty() && s.top().he >= rect.he) {\n\t\t\t\tRectangle pr = s.top();\n\t\t\t\trect.p = pr.p;\n\t\t\t\ts.pop();\n\t\t\t\tarea = (i - pr.p)*pr.he;\n\t\t\t\tmaxv = max(area, maxv);\n\t\t\t}\n\t\t\ts.push(rect);\n\t\t}\n\t}\n\treturn maxv;\n}\nint main() {\n\tint h, w, x;\n\tcin >> h >> w;\n\tint H[num][num], dp[num][num];\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tcin >> x;\n\t\t\tif (x) dp[i][j] = 0;\n\t\t}\n\t}\n\tfor (int i = 0; i < w; i++) {\n\t\tfor (int j = 0; j < h; j++) {\n\t\t\tif (!dp[j][i]) H[j][i] = 0;\n\t\t\telse H[j][i] = (j > 0) ? H[j - 1][i] + 1 : 1;\n\t\t}\n\t}\n\tint maxv = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tmaxv = max(maxv, lr(w, H[i]));\n\t}\n\tcout << maxv << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<iomanip>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\n#include<map>\n#include<set>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef stack<int> SI;\ntypedef queue<int> QI;\ntypedef list<int> LI;\ntypedef pair<int,int> PII;\ntypedef long long LL;\n\n#define d(x)  cout<<#x<<\" = \"<<(x)<<endl;\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define EMP empty()\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define REACH(i,c) for(typeof((c).rbegin()) i=(c).rbegin(); i!=(c).rend(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c,n) sort(c,c+n)\n#define VSORT(c) sort((c).begin(),(c).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define DFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define DREP(i,n) DFOR(i,n,0)\n#define INF 1000000000\n#define PI  acos(-1.0)\n////////////////////////////////////////////////\nstruct Rect{int h;int p;};\nint lgstrec(int size,int buffer[])\n{\n\tstack<Rect> S;\n\tint maxv=0;\n\tbuffer[size]=0;\n\tfor(int i=0;i<=size;i++)\n\t{\n\t\tRect rect;\n\t\trect.h=buffer[i];\n\t\trect.p=i;\n\t\tif(S.empty())\n\t\t{\n\t\t\tS.push(rect);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(S.top().h<rect.h)\n\t\t\t{\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t\telse if(S.top().h>rect.h)\n\t\t\t{\n\t\t\t\tint tgt=i;\n\t\t\t\twhile(!S.empty()&&S.top().h>=rect.h)\n\t\t\t\t{\n\t\t\t\t\tRect pre=S.top();S.pop();\n\t\t\t\t\tint area=pre.h*(i-pre.p);\n\t\t\t\t\tmaxv=max(maxv,area);\n\t\t\t\t\ttgt=pre.p;\n\t\t\t\t}\n\t\t\t\trect.p=tgt;\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxv;\n}\nint H,W;\nint buffer[1400][1400];\nint T[1400][1400];\nint lgstrec()\n{\n\tREP(j,W)\n\t{\n\t\tREP(i,H)\n\t\t{\n\t\t\tif(buffer[i][j])\n\t\t\t{\n\t\t\t\tT[i][j]=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tT[i][j]=(i>0)?T[i-1][j]+1:1;\n\t\t\t}\n\t\t}\n\t}\n\tint maxv=0;\n\tREP(i,H)\n\t{\n\t\tmaxv=max(maxv,lgstrec(W,T[i]));\n\t}\n\treturn maxv;\n}\nint main()\n{\n\tscanf(\"%d%d\",&H,&W);\n\tREP(i,H)\n\t{\n\t\tREP(j,W)\n\t\t{\n\t\t\tscanf(\"%d\",&buffer[i][j]);\n\t\t}\n\t}\n\tcout<<lgstrec()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>   \n#include<cstdio>  \n#include<algorithm>\n#include<stack>\nusing namespace std;\nconst int maxx = 1410;\n\nint H, W;\nint buffer[maxx][maxx];\nint T[maxx][maxx];\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectangle(int size, int buffer[]) {\n\tstack<Rectangle> S;\n\tint maxv = 0;\n\tbuffer[size] = 0;\n\n\tfor (int i = 0; i <= size; i++) {\n\t\tRectangle rect;\n\t\trect.height = buffer[i];\n\t\trect.pos = i;\n\t\t// 当S为空\n\t\tif (S.empty())\n\t\t\tS.push(rect);\n\t\t// 栈顶的高度小于当前的高度\n\t\telse if (S.top().height < rect.height)\n\t\t\tS.push(rect);\n\t\t// 栈顶的高度大于当前的高度\n\t\telse if (S.top().height > rect.height) {\n\t\t\tint target = i;\n\t\t\t// 栈顶的高度大于等于当前的高度\n\t\t\t// 出现小于栈顶高度的代表pre.pos~i之间都存在高度为pre.height的干净瓷砖\n\t\t\t// 此时可以计算当前的面积\n\t\t\twhile (!S.empty() && S.top().height >= rect.height) {\n\t\t\t\tRectangle pre = S.top(); S.pop();\n\t\t\t\t// 长 * 宽\n\t\t\t\tint area = pre.height * (i - pre.pos);\n\t\t\t\tmaxv = max(maxv, area);\n\t\t\t\ttarget = pre.pos;\n\t\t\t}\n\t\t\t// 加上前面的宽度，以便后面有合适的瓷砖进行计算\n\t\t\trect.pos = target;\n\t\t\tS.push(rect);\n\t\t}\n\t}\n\treturn maxv;\n}\n\nint solve() {\n\t// 以行为直方图,计算纵向的干净长度\n\tfor (int i = 0; i < W; i++) {\n\t\tfor (int j = 0; j < H; j++) {\n\t\t\tif (buffer[i][j])\n\t\t\t\tT[i][j] = 0;\n\t\t\telse\n\t\t\t\tT[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n\t\t}\n\t}\n\n\t// 从行计算出当前行的最大面积\n\tint maxv = 0;\n\tfor (int i = 0; i < H; i++)\n\t\tmaxv = max(maxv, getLargestRectangle(W, T[i]));\n\treturn maxv;\n}\nint main()\n{\n\tscanf(\"%d %d\", &H, &W);\n\tfor (int i = 0; i < H; i++)\n\t\tfor (int j = 0; j < W; j++)\n\t\t\tscanf(\"%d\", &buffer[i][j]);\n\t\n\tprintf(\"%d\\n\", solve());\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stack>\nusing namespace std;\n\nint h, w;\nint T[1401][1401];\n\nstruct Rect\t{\n\tint height, prepos;\n};\n\nclass Tile {\npublic:\n\tTile() {\n\t\tfor (int i = 0; i < h; i++)\t{\n\t\t\tT[i][w] = 0;\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (!i) T[i][j] = (T[i][j] + 1) % 2;\n\t\t\t\telse {\n\t\t\t\t\tT[i][j] = T[i][j] ? 0 : T[i - 1][j] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint largestRectangle(int row) { //???????????°????????¨????????????\n\t\tint maxR = 0;\n\t\tstack<Rect> R;\n\t\t\n\t\tfor (int j = 0; j <= w; j++) {\n\t\t\tRect rect;\n\t\t\trect.height = T[row][j];\n\t\t\trect.prepos = j;\n\t\t\tif (R.empty()) {\n\t\t\t\tR.push(rect);\n\t\t\t} else {\n\t\t\t\tif (rect.height > R.top().height) {\n\t\t\t\t\tR.push(rect);\n\t\t\t\t} else if (rect.height < R.top().height) {\n\t\t\t\t\tint target = j; //???????????????index????§?????????????\n\t\t\t\t\twhile (!R.empty() && rect.height <= R.top().height) { //???????????????????????±????????????????¶??????????????¨???°????\\???????????????????\n\t\t\t\t\t\tmaxR = max(maxR, R.top().height * (j - R.top().prepos));\n\t\t\t\t\t\ttarget = R.top().prepos;\n\t\t\t\t\t\tR.pop();\n\t\t\t\t\t}\n\t\t\t\t\trect.prepos = target;\n\t\t\t\t\tR.push(rect);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxR;\n\t}\n\n\tint largestRectangle() {\n\t\tint maxS = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tmaxS = max(maxS, largestRectangle(i));\n\t\t}\n\t\treturn maxS;\n\t}\n\n\t\n\n};\n\nint main() {\n\tcin >> h >> w;\n\tfor (int i = 0; i < h; i++)\t{\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tcin >> T[i][j];\n\t\t}\n\t}\n\n\tTile t = Tile();\n\n\tcout << t.largestRectangle() << endl;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<long, long> pll;\n\nconst int INF = 1 << 29;\nconst double EPS = 1e-9;\nconst int MOD = 100000007;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\nconst int MAX_HW = 1500;\nint H, W;\nint board[MAX_HW][MAX_HW];\nint dp[MAX_HW][MAX_HW];\nint main() {\n  scanf(\"%d %d\", &H, &W);\n  for (int i = 1; i <= H; i++) {\n    for (int j = 1; j <= W; j++) {\n      scanf(\"%d\", &board[i][j]);\n    }\n  }\n  for (int j = 1; j <= W; j++) {\n    for (int i = 1; i <= H; i++) {\n      if (board[i][j] == 1) {\n        dp[i][j] = 0;\n      } else {\n        dp[i][j] = dp[i - 1][j] + 1;\n      }\n    }\n  }\n  /*for (int i = 1; i <= H; i++){\n    for (int j = 1; j <= W; j++){\n      cout << dp[i][j] << \" \";\n    }\n    cout << endl;\n  }*/\n\n\n\n  int res = 0;\n  for (int i = 1; i <= H; i++) {\n    stack<pii> st;\n    for (int j = 1; j <= W; j++) {\n      if (st.empty()) {\n        st.push(mp(dp[i][j], j));\n      } else if (st.top().first < dp[i][j]) {\n        st.push(mp(dp[i][j], j));\n      } else {\n        int target = i;\n        while (!st.empty() && st.top().first >= dp[i][j]) {\n//          cout << \"i = \" << i << \" j = \" << j << endl;\n    //      cout << st.top().first << \" \" << dp[i][j] << endl;\n          pii pre = st.top();\n          st.pop();\n          int area = pre.first * (j - pre.second);\n          res = max(res, area);\n          target = pre.second;\n        }\n        st.push(mp(dp[i][j], target));\n      }\n    }\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <sstream>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n#define rrep(i, a) RREP(i, a, 0)\n#define RREP(i, a, b) for(int i = a; i >= b; --i)\n#define repll(i, a) REPLL(i, 0, a)\n#define REPLL(i, a, b) for(ll i = a; i < b; ++i)\n#define rrepll(i, a) RREPLL(i, a, 0)\n#define RREPLL(i, a, b) for(ll i = a; i >= b; --i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<int, P> PP;\nconst double PI = 3.14159265358979323846;\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+17 + 10;\n\nint h, w;\nint map[1401][1401];\n\nint main(){\n\tstd::cin >> h >> w;\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tstd::cin >> map[i][j];\n\t\t\tmap[i][j] = (1 - map[i][j]);\n\t\t}\n\t}\n\n\trep(i, h){\n\t\trrep(j, w - 2){\n\t\t\tif (map[i][j])map[i][j] += map[i][j + 1];\n\t\t}\n\t}\n\n\tint ans = 0;\n\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tint minEdge = infi;\n\t\t\tREP(k, i, h){\n\t\t\t\tif (map[k][j] == 0)break;\n\t\t\t\tminEdge = std::min(minEdge, map[k][j]);\n\t\t\t\tans = std::max(ans, (k - i + 1) * minEdge);\n\t\t\t}\n\t\t}\n\t}\n\n\tstd::cout << ans << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\nusing namespace std;\nstatic const int HMAX = 1401;\nstatic const int WMAX = 1401;\n\nint tiles[HMAX][WMAX] = {0};\n\nvoid print_tiles(int h, int w) {\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      cout << tiles[i][j] << \" \";\n    }\n    cout << endl;\n  }\n}\n\n// side-effects (to tiles)\nint leargest_square(int height, int width, int ans_init) {\n  int ans = ans_init;\n  for (int i = 1; i < height; i++) {\n    for (int j = 1; j < width; j++) {\n      if (tiles[i][j] != 0) {\n        tiles[i][j] =\n            min({tiles[i - 1][j], tiles[i][j - 1], tiles[i - 1][j - 1]}) + 1;\n        ans = max(ans, tiles[i][j]);\n      }\n    }\n  }\n  return ans * ans;\n}\n\nstruct Rect {\n  int height;\n  int left;\n};\n\n// side-effects (to tiles)\nint leargest_rectanble(int height, int width) {\n  // mkae histgrams\n  for (int i = 1; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      if (tiles[i][j] != 0) {\n        tiles[i][j] = tiles[i - 1][j] + 1;\n      }\n    }\n  }\n\n  int maxsize = 0;\n  stack<Rect> st;\n  for (int i = 4; i < height; i++) {\n    // calc the rectangle size of the i-th histgram\n    tiles[i][width] = 0; // sentinel\n    for (int j = 0; j < width + 1; j++) {\n      auto rect = Rect{tiles[i][j], j};\n      if (st.empty() || st.top().height < rect.height) {\n        st.push(rect);\n      } else if (st.top().height > rect.height) {\n        Rect r;\n        while (!st.empty()) {\n          r = st.top();\n          if (r.height <= rect.height)\n            break;\n          int size = r.height * (rect.left - r.left);\n          maxsize = max(size, maxsize);\n          st.pop();\n        }\n        if (r.height < rect.height) {\n          rect.left = r.left + 1;\n          st.push(rect);\n        }\n      }\n    }\n  }\n\n  return maxsize;\n}\n\n#define BLOCK 1\nint main() {\n  int height, width;\n  int ans_init = 0;\n  cin >> height >> width;\n  for (int i = 0; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      int tmp;\n      cin >> tmp;\n      tiles[i][j] = tmp == BLOCK ? 0 : 1;\n      ans_init = max(ans_init, tiles[i][j]);\n    }\n  }\n  cout << leargest_rectanble(height, width) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n\tRectangle rect;\n\tfor(int i=0;i<x;i++){\n\t\tstack<Rectangle> stk;\n\t\tfor(int j=0;j<=y;j++){\n\t\t\trect.height = m[j][i];\n\t\t\trect.pos = j;\n\t\t\tif(stk.empty() || stk.top().height < rect.height){\n\t\t\t\tstk.push(rect);\n\t\t\t}else{\n\t\t\t\tint target = j;\n\t\t\t\tfor(;!stk.empty() && stk.top().height >= rect.height;){\n\t\t\t\t\tRectangle pre = stk.top(); stk.pop();\n\t\t\t\t\tint area = pre.height * (j - pre.pos);\n\t\t\t\t\tr = max(r, area);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\t//rect.pos = target;\n\t\t\t\tstk.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n\tint h,w,s,max=0;\n\tcin>>h>>w;\n\tint a[1401][1401]={};\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tcin>>s;\n\t\t\tif(s==0)a[i][j]=a[i][j-1]+1;\n\t\t\telse a[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=1;i<=w;i++){\n\t\tfor(int j=1;j<=i;j++){\n\t\t\tint d=0;\n\t\t\tfor(int k=1;k<=h;k++){\n\t\t\t\tif(a[k][i]>=j){\n\t\t\t\t\td=d+j;\n\t\t\t\t\tif(max<d)max=d;\n\t\t\t\t}\n\t\t\t\telse d=0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << max << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int N = 1403;\n\nint n, m;\nint c[N][N];\n\nint lf[N][N], up[N][N];\n\nint mx = 0;\n\nint main()\n{\n    cin >> n >> m;\n    for (int i = 0; i < n; ++i)\n    for (int j = 0; j < m; ++j)\n        cin >> c[i][j];\n    memset(lf, 0, sizeof lf);\n    memset(up, 0, sizeof up);\n    for (int i = 0; i < n; ++i )\n    for (int j = 0; j < m; ++j) if(!c[i][j]){\n        if(j) lf[i][j] = lf[i][j-1] + 1;    \n        if(i) up[i][j] = up[i-1][j] + 1;\n        if(i && j) {\n           lf[i][j] = max(lf[i][j], lf[i-1][j-1]+1);\n           up[i][j] = max(up[i][j], up[i-1][j-1]+1);\n        }\n        mx = max(mx, lf[i][j] * up[i][j]);\n    }\n    cout << mx << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\nusing namespace std;\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n    char mat[h][w];\n    int dp[h][w];\n\n    for (int i = 0; i < h; i++)\n    {\n        for (int j = 0; j < w; j++)\n        {\n            cin >> mat[i][j];\n        }\n    }\n\n    for (int i = 0; i < w; i++)\n        dp[0][i] = (mat[0][i] == '0');\n    for (int i = 1; i < h; i++)\n    {\n        for (int j = 0; j < w; j++)\n        {\n            if (mat[i][j] == '0')\n                dp[i][j] = dp[i - 1][j] + 1;\n            else\n                dp[i][j] = 0;\n        }\n    }\n\n    int ans = -1;\n    for (int i = 0; i < h; i++)\n    {\n        // pair<left end, height>\n        stack<pair<int, int>> s;\n        for (int j = 0; j < w; j++)\n        {\n            if (s.empty())\n            {\n                s.push({j, dp[i][j]});\n            }\n            else if (dp[i][j] > s.top().second)\n            {\n                s.push({j, dp[i][j]});\n            }\n            else if (dp[i][j] == s.top().second)\n            {\n                // do nothing.\n            }\n            else if (dp[i][j] < s.top().second)\n            {\n                int left;\n                while (!s.empty() && dp[i][j] < s.top().second)\n                {\n                    pair<int, int> now = s.top();\n                    s.pop();\n                    // make rectangle\n                    ans = max(ans, (j - now.first) * (now.second));\n                    left = now.first;\n                }\n                s.push({left, dp[i][j]});\n            }\n        }\n\n        while (!s.empty())\n        {\n            pair<int, int> now = s.top();\n            s.pop();\n            ans = max(ans, (w - now.first) * (now.second));\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\tvector<vector<int>> a(h, vector<int>(w));\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tcin >> a[i][j];\n\t\t\ta[i][j] = !a[i][j];\n\t\t}\n\t}\n\tfor (int i = 1; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (a[i][j] == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta[i][j] += a[i - 1][j];\n\t\t}\n\t\ta[i].emplace_back(0);\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tint tmp = 0;\n\t\tstack<pair<int, int>> st;\n\t\tfor (int j = 0; j <= w; j++) {\n\t\t\tif (st.empty() || st.top().first < a[i][j]) {\n\t\t\t\tst.emplace(make_pair(a[i][j], j));\n\t\t\t} else {\n\t\t\t\tif (a[i][j] < st.top().first) {\n\t\t\t\t\tint target = j;\n\t\t\t\t\twhile (!st.empty() && a[i][j] <= st.top().first) {\n\t\t\t\t\t\tint height = st.top().first;\n\t\t\t\t\t\tint pos = st.top().second;\n\t\t\t\t\t\tst.pop();\n\t\t\t\t\t\tint area = height * (j - pos);\n\t\t\t\t\t\ttmp = max(tmp, area);\n\t\t\t\t\t\ttarget = j;\n\t\t\t\t\t}\n\t\t\t\t\tst.emplace(make_pair(a[i][j], target));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = max(ans, tmp);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\n//?????§????????¢\nvoid largest_rectangle() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>> v(H, vector<int>(W));\n\trep(i, 0, H) rep(j, 0, W) {\n\t\tint x; cin >> x;\n\t\tv[i][j] = !x;\n\t}\n\trep(i, 0, H - 1)rep(j, 0, W) {\n\t\tif (v[i + 1][j] == 0)continue;\n\t\tv[i + 1][j] += v[i][j];\n\t}\n\tusing P = pair<int, int>;\n\tint ans = 0;\n\trep(i, 0, H) {\n\t\tstack<P> st;\n\t\tst.emplace(0, 0);\n\t\trep(j, 0, W) {\n\t\t\tdump(i, v[i], j, st);\n\t\t\tif (st.top().first == v[i][j])\n\t\t\t\tcontinue;\n\t\t\tint pos = j;\n\t\t\twhile (st.top().first > v[i][j]) {\n\t\t\t\tchmax(ans, st.top().first*(j - st.top().second));\n\t\t\t\tpos = st.top().second;\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\tst.emplace(v[i][j], pos);\n\t\t\tdump(ans);\n\t\t}\n\t\twhile (st.size()) {\n\t\t\tchmax(ans, st.top().first*(W - st.top().second));\n\t\t\tst.pop();\n\t\t}\n\t\tdump(ans);\n\t}\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tlargest_rectangle();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> vl;\ntypedef pair<ll, ll> PP;\n#define rep(i, n) for (ll i = 0; i < ll(n); i++)\n#define all(v) v.begin(), v.end()\nbool chmin(ll& a, ll b) {\n    if (b < a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nbool chmax(ll& a, ll b) {\n    if (b > a) {\n        a = b;\n        return 1;\n    }\n    return 0;\n}\nconst ll INF = 999999999999999;\nconst ll MOD = 1000000007;\nconst ll MAX_N = 500010;\nll a, b, c, d, e, f, p, t, x, y, z, q, m, n, r, h, k, w, l, ans, s;\nll histgram(vl B) {\n    ll n = B.size(), ans = 0;\n    vl A;\n    A.push_back(0);\n    rep(i, n) A.push_back(B[i]);\n    A.push_back(0);\n    n += 2;\n    vl X(n, 0), Y(n, 0);\n\n    deque<PP> DQ;\n\n    rep(i, n) {\n        while (!DQ.empty() && DQ.back().second > A[i]) {\n            X[DQ.back().first] += i - DQ.back().first;\n            DQ.pop_back();\n        }\n        DQ.push_back({i, A[i]});\n    }\n\n    reverse(all(A));\n\n    DQ.clear();\n\n    rep(i, n) {\n        while (!DQ.empty() && DQ.back().second > A[i]) {\n            Y[DQ.back().first] += i - DQ.back().first;\n            DQ.pop_back();\n        }\n        DQ.push_back({i, A[i]});\n    }\n\n    reverse(all(Y));\n    reverse(all(A));\n\n    rep(i, n) {\n        ans = max(ans, (X[i]+Y[i]-1) * A[i]);\n    }\n    \n    return ans;\n}\nint main() {\n    cin >> h >> w;\n    vector<vl> dp(h, vl(w, 1));\n    rep(i, h) {\n        rep(j, w) {\n            cin >> x;\n            if (i > 0) dp[i][j] = dp[i - 1][j] + 1;\n            if (x) dp[i][j] = 0;\n        }\n    }\n\n    rep(i, h){\n    \tchmax(t, histgram(dp[i]));\n    }\n\n    cout << t << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n\nusing namespace std;\n\n\nint c[1401][1401];\nint dp[1401][1401];\n\nstruct rt {\n\tint point;\n\tint height;\n};\n\nint max_in_x(int *l,int w) {\n\tstack<rt> st;\n\tint cur = 0;\n\tint sum = 0;\n\n\n\twhile(cur < w || !st.empty()) {\n\t\tint next_height = 0;\n\n\t\tif (cur < w) {\n\t\t\tint current_height = *(l + cur);\n\t\t\tif (st.empty() || st.top().height < current_height) {\n\t\t\t\trt a;\n\t\t\t\ta.point = cur;\n\t\t\t\ta.height = current_height;\n\t\t\t\tst.push(a);\n\t\t\t\tcur++;\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\tif (st.top().height == current_height) {\n\t\t\t\tcur++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (st.top().point != cur - 1) {\n\t\t\t\trt a;\n\t\t\t\ta.point = cur - 1;\n\t\t\t\ta.height = *(l + cur -1);\n\t\t\t\tst.push(a);\n\t\t\t}\n\t\t\tnext_height = *(l + cur);\t\t\t\n\t\t} else {\n\t\t\tif (st.top().point != w - 1) {\n\t\t\t\trt a;\n\t\t\t\ta.point = w - 1;\n\t\t\t\ta.height = *(l + w -1);\n\t\t\t\tst.push(a);\n\t\t\t}\t\t\t\n\t\t}\n\n\t\trt start = st.top();\n\t\trt current;\n\n\t\t//cout << \"dec start point:\" << start.point  << endl;\n\n\t\twhile(!st.empty()) {\n\t\t\tcurrent = st.top();\n\t\t\tst.pop();\n\n\t\t\tif (current.height < next_height) {\n\t\t\t\tcurrent.height = next_height;\n\t\t\t\tcurrent.point ++;\n\t\t\t\tst.push(current);\n\t\t\t\t//cout << \"    stack.point:\" << current.point <<  \" stack height:\" << next_height << endl; \n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//cout << \"    current.point:\" << current.point  << \" h:\" << current.height \n\t\t\t// << \" v:\" << (start.point - current.point + 1) * current.height <<  endl;\n\n\t\t\tsum = max(sum, (start.point - current.point + 1) * current.height);\n\t\t\n\t\t}\n\t}\n\treturn sum;\n}\n\n\nint main() {\n\tint W,H;\n\tcin >> H >> W;\n\t\n\tint v_max = 0;\n\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x < W; x++) {\n\n\t\t\tcin >> c[y][x];\n\t\t\tc[y][x] ^= 1;\n\t\t\tdp[y][x] = 0;\t\t\t\n\t\t}\n\t}\n\tfor (int x = 0; x < W; x++) {\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tif (c[y][x] == 0) {\n\t\t\t\tdp[y][x] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (y==0) {\n\t\t\t\tdp[y][x] = 1;\n\t\t\t\tcontinue;\t\t\t\t\n\t\t\t} \n\t\t\tdp[y][x] = dp[y-1][x] + 1;\n\t\t}\n\t}\n\n\tint s_max = 0;\n\n/*\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x < W; x++) {\n\t\t\tcout << setw(5) << dp[y][x] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n*/\n\n\tfor( int y = 0; y < H; y++) {\n\t\t\n\t\t// cout << \"** s_max y:\" << y << endl;\n\t\tint ret = max_in_x(dp[y],W); \n\t\t// cout << \"v:\" << ret << endl;\n\t\ts_max = max(s_max,ret);\n\t}\n\tcout << s_max << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=100001,INF=1<<30;\n\nint main(){\n    \n    int H,W;cin>>H>>W;\n    vector<vector<int>> S(H,vector<int>(W)),A(H,vector<int>(W));\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cin>>S[i][j];\n        }\n    }\n    \n    for(int j=0;j<W;j++){\n        if(S[H-1][j]) A[H-1][j]=0;\n        else A[H-1][j]=1;\n    }\n    \n    for(int j=0;j<W;j++){\n        for(int i=H-2;i>=0;i--){\n            if(S[i][j]) A[i][j]=0;\n            else A[i][j]=A[i+1][j]+1;\n        }\n    }\n    \n    int ans=0;\n    \n    for(int i=0;i<H;i++){\n        stack<pair<int,int>> ST;\n        vector<int> L(W),R(W);\n        for(int j=0;j<W;j++){\n            if(ST.empty()){\n                L[j]=0;\n                ST.push(make_pair(A[i][j],j));\n            }\n            else if(ST.top().first<A[i][j]){\n                L[j]=ST.top().second+1;\n                ST.push(make_pair(A[i][j],j));\n            }else if(ST.top().first>=A[i][j]){\n                while(!ST.empty()&&ST.top().first>=A[i][j]){\n                    ST.pop();\n                }\n                if(ST.empty()) L[j]=0;\n                else L[j]=ST.top().second+1;\n                ST.push(make_pair(A[i][j],j));\n            }\n        }\n        reverse(all(A[i]));\n        \n        while(!ST.empty()) ST.pop();\n        \n        for(int j=0;j<W;j++){\n            if(ST.empty()){\n                R[j]=0;\n                ST.push(make_pair(A[i][j],j));\n            }\n            else if(ST.top().first<A[i][j]){\n                R[j]=ST.top().second+1;\n                ST.push(make_pair(A[i][j],j));\n            }else if(ST.top().first>=A[i][j]){\n                while(!ST.empty()&&ST.top().first>=A[i][j]){\n                    ST.pop();\n                }\n                if(ST.empty()) R[j]=0;\n                else R[j]=ST.top().second+1;\n                ST.push(make_pair(A[i][j],j));\n            }\n            R[j]=W-R[j];\n        }\n        reverse(all(R));\n        reverse(all(A[i]));\n        \n        for(int j=0;j<W;j++){\n            ans=max(ans,A[i][j]*(R[j]-L[j]));\n        }\n        \n        /*for(int j=0;j<W;j++){\n            ans=max(ans,A[i][j]*(R[j]-L[j]));\n            cout<<R[j];\n            cout<<\" \";\n        }\n        cout<<endl;*/\n    }\n    \n    cout<<ans<<endl;\n    \n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\ntemplate <class T>\nT Vec(T v) { return v; }\n\ntemplate <class T, class... Ts>\nauto Vec(size_t l, Ts... ts) {\n    return std::vector<decltype(Vec<T>(ts...))>(l, Vec<T>(ts...));\n}\n\nint main() {\n    int H, W;\n    std::cin >> H >> W;\n    auto S = Vec<int>(H, W, 0);\n    for (auto& s : S) {\n        for (auto& c : s) std::cin >> c;\n    }\n\n    for (int y = 0; y < W; ++y) {\n        for (int x = 0; x < H; ++x) {\n            if (S[x][y] == 1) {\n                S[x][y] = 0;\n            } else {\n                S[x][y] = (x > 0 ? S[x - 1][y] : 0) + 1;\n            }\n        }\n    }\n\n    int ans = 0;\n    for (auto& h : S) {\n        h.push_back(0);\n\n        std::vector<std::pair<int, int>> stack;\n        for (int i = 0; i <= W; ++i) {\n            int pos = i;\n            while (!stack.empty() && stack.back().first > h[i]) {\n                auto p = stack.back();\n                stack.pop_back();\n                ans = std::max(ans, p.first * (i - p.second));\n                pos = p.second;\n            }\n            if (stack.empty() || stack.back().first < h[i]) {\n                stack.emplace_back(h[i], pos);\n            }\n        }\n    }\n\n    std::cout << ans << std::endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define mo 1510\nusing namespace std;\nint d[mo],a[mo][mo],l[mo],h[mo];\nint main()\n{\n    int n,m;\n    while(cin>>n>>m)\n    {\n        for(int i=1;i<=n;i++)\n            for(int j=1;j<=m;j++)\n            cin>>a[i][j];\n\n        int maxs=0;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=m;j++)\n                if(!a[i][j]) d[j]++;\n                else d[j]=0;\n\n\n            for(int j=1;j<=m;j++)\n            {\n                l[j]=j;\n                while(l[j]>1&&d[j]<=d[l[j]-1])\n                    l[j]=l[l[j]-1];\n            }\n\n            for(int j=m;j>0;j--)\n            {\n                h[j]=j;\n                while(h[j]<m&&d[j]<=d[h[j]+1])\n                    h[j]=h[h[j]+1];\n            }\n            for(int j=1;j<=m;j++)\n            maxs=max(maxs,d[j]*(h[j]-l[j]+1));\n\n        }\n        cout<<maxs<<endl;\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <sstream>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n#define rrep(i, a) RREP(i, a, 0)\n#define RREP(i, a, b) for(int i = a; i >= b; --i)\n#define repll(i, a) REPLL(i, 0, a)\n#define REPLL(i, a, b) for(ll i = a; i < b; ++i)\n#define rrepll(i, a) RREPLL(i, a, 0)\n#define RREPLL(i, a, b) for(ll i = a; i >= b; --i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<int, P> PP;\nconst double PI = 3.14159265358979323846;\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+18 + 10;\n\nint h, w, ans = 0;\nint map[1401][1401];\n\nint main(){\n\tstd::cin >> h >> w;\n\trep(i, h){\n\t\trep(j, w)std::cin >> map[i][j], map[i][j] = (1 - map[i][j]);\n\t}\n\n\trep(i, w){\n\t\tREP(j, 1, h)map[j][i] = (map[j][i] == 0 ? 0 : map[j - 1][i] + 1);\n\t}\n\n\trep(i, h){\n\t\tint max = 0;\n\t\tstd::stack<P> s;\n\t\trep(j, w){\n\t\t\tif (s.empty() || s.top().first < map[i][j]){\n\t\t\t\ts.push(P(map[i][j], j));\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (s.size() && s.top().first > map[i][j]){\n\t\t\t\t\tmax = std::max(max, s.top().first * (j - s.top().second));\n\t\t\t\t\ts.pop();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (s.size()){\n\t\t\tmax = std::max(max, s.top().first * (w - s.top().second));\n\t\t\ts.pop();\n\t\t}\n\n\t\tans = std::max(max, ans);\n\t}\n\n\tstd::cout << ans << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <cstdlib>\n#include <sstream>\n#include <stack>\n#include <queue>\n#include <list>\n#include <stdio.h>\n#include <algorithm>\n#define MAX 1400\n#define INF 100000000\nusing namespace std;\ntypedef long long ll;\nint g[MAX+1][MAX+1],dp[MAX+1][MAX+1],maxsize;\nstruct rectangle {\n\tint height;\n\tint pos;\n};\nvoid init(int w,int h)\n{\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tif(g[i][j]) dp[i][j]=0;\n\t\t\telse{\n\t\t\t\tdp[i][j]=(i>0)?dp[i-1][j]+1:1;\n\t\t\t}\n\t\t}\n\t\tdp[i][w]=0;//为了使得算法最终停止 \n\t}\n}\nvoid getBiggest(int w,int h)\n{\n\tint mid;\n\tstack<rectangle> s;\n\tfor(int i=0;i<h;i++)//每一行都计算一次； \n\t{\n\t\twhile(!s.empty()) s.pop();\n\t\tstruct rectangle rects;\n\t\tfor(int j=0;j<=w;j++)\n\t\t{\n\t\t\trects.pos=j;rects.height=dp[i][j];\n\t\t\tif(s.empty()){\n\t\t\t\ts.push(rects);\n\t\t\t}else{\n\t\t\t\tif(s.top().height<rects.height){\n\t\t\t\t\ts.push(rects);\n\t\t\t\t}else if(s.top().height>rects.height){\n\t\t\t\t\twhile(!s.empty()&&s.top().height>=rects.height){\n\t\t\t\t\t\tstruct rectangle tmp;\n\t\t\t\t\t\ttmp=s.top();s.pop();\n\t\t\t\t\t\tmid=tmp.height*(j-tmp.pos);\n\t\t\t\t\t\tmaxsize=max(maxsize,mid);//更新最大值 \n\t\t\t\t\t\trects.pos=tmp.pos;//更新rect最左边坐标的位置以便入栈 \n\t\t\t\t\t}\n\t\t\t\t\ts.push(rects);\n\t\t\t\t}\n\t\t\t\t//else continue;\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n}\nint main()\n{\t\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tscanf(\"%d\",&g[i][j]);\n\t\t}\n\t} \n\tinit(w,h);\n\tgetBiggest(w,h);\n\tcout<<maxsize<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint max_rect(VI a){\n    int n = a.size();\n    VI l(n), r(n);\n\n    stack<int> st;\n    REP(i,n){\n        while (!st.empty() && a[st.top()] >= a[i]) st.pop();\n        l[i] = (st.empty() ? 0 : st.top() + 1);\n        st.push(i);\n    }\n\n    while (!st.empty()) st.pop();\n    FORR(i,n-1,0){\n        while (!st.empty() && a[st.top()] >= a[i]) st.pop();\n        r[i] = (st.empty() ? n : st.top());\n        st.push(i);\n    }\n\n    int ret = 0;\n    REP(i,n){\n        ret = max(ret, a[i] * (r[i] - l[i]));\n    }\n    return ret;\n}\n\nint main(){\n    int h, w;\n    cin >> h >> w;\n\n    VVI a(h, VI(w));\n    REP(i,h) REP(j,w) cin >> a[i][j];\n\n    VVI b(h, VI(w));\n    REP(j,w){\n        REP(i,h){\n            if (a[i][j] == 0){\n                b[i][j] = (i == 0 ? 1 : b[i-1][j] + 1);\n            }\n        }\n    }\n\n    int ans = 0;\n    REP(i,h) ans = max(ans, max_rect(b[i]));\n    cout << ans << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for(int i = 0; i < (n); i++)\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\n\nint get_largest_rec(const int w, int dp[]){\n\tstack<P> rs;\n\tint maxa = 0;\n\tdp[w] = 0;\n\n\trep(i, w+1){\n\t\tP rect = make_pair(i, dp[i]);\n\t\tif(rs.empty()) rs.push(rect);\n\t\telse {\n\t\t\tif(rs.top().second < rect.second) rs.push(rect);\n\t\t\telse if(rs.top().second > rect.second) {\n\t\t\t\tint t = i;\n\t\t\t\twhile(rs.size() && rs.top().second >= rect.second){\n\t\t\t\t\tP pre = rs.top(); rs.pop();\n\t\t\t\t\tint area = pre.second*(i - pre.first);\n\t\t\t\t\tmaxa = max(maxa, area);\n\t\t\t\t\tt = pre.first;\n\t\t\t\t}\n\t\t\t\trect.first = t;\n\t\t\t\trs.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxa;\n}\n\nint main(){\n\tint h, w; cin >> h >> w;\n\tbool t[h][w];\n\trep(i, h)rep(j, w) {\n\t\tbool b; cin >> b;\n\t\tt[i][j] = b;\n\t}\n\n\tint dp[h+1][w+1];\n\trep(j, w)rep(i, h){\n\t\tif(t[i][j]) dp[i][j] = 0;\n\t\telse dp[i][j] = (i > 0) ? dp[i-1][j] + 1 : 1;\n\t}\n\n\tint ans = 0;\n\trep(i, h) ans = max(ans, get_largest_rec(w, dp[i]));\n\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define P(x) cout << (x) << \"\\n\"\n#define p(x) cout << (x)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define vv(type, c, m, n, i) vector<vector<type>> c(m, vector<type>(n, i));\n#define rep(i,a,n) for(int i=(a), i##_len=(n); i<i##_len; ++i)\n#define rrep(i,a,n) for(int i=(a), i##_len=(n); i>i##_len; --i)\n#define len(x) ((int)(x).size())\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\n#define chmax(a,b) if(a<b)a=b;\n#define chmin(a,b) if(b<a)a=b;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\nconstexpr int MAX = 1400;\nstruct Rectangle { int height, pos; };\nint getLargestRectangle(int size, vi buffer) {\n\tvector<Rectangle> S;\n\tint maxv = 0;\n\tbuffer[size] = 0;\n\tint target, area;\n\trep(i, 0, size + 1) {\n\t\tRectangle rect;\n\t\trect.height = buffer[i];\n\t\trect.pos = i;\n\t\tif(S.empty()) S.eb(rect);\n\t\telse {\n\t\t\tif(S.back().height < rect.height) S.eb(rect);\n\t\t\telse if(S.back().height > rect.height) {\n\t\t\t\ttarget = i;\n\t\t\t\twhile(!S.empty() && S.back().height >= rect.height) {\n\t\t\t\t\tRectangle pre = S.back(); S.pop_back();\n\t\t\t\t\tarea = pre.height * (i - pre.pos);\n\t\t\t\t\tchmax(maxv, area);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos = target;\n\t\t\t\tS.eb(rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxv;\n}\nint H, W;\nvv(int, buffer, MAX, MAX, 0);\nvv(int, T, MAX, MAX, 0);\nint getLargestRectangle() {\n\trep(j, 0, W) {\n\t\trep(i, 0, H) {\n\t\t\tif(buffer[i][j]) T[i][j] = 0;\n\t\t\telse T[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n\t\t}\n\t}\n\tint maxv = 0;\n\trep(i, 0, H) chmax(maxv, getLargestRectangle(W, T[i]));\n\treturn maxv;\n}\nint main() {\n\tcin >> H >> W;\n\trep(i, 0, H) rep(j, 0, W) cin >> buffer[i][j];\n\tP(getLargestRectangle());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <sstream>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n#define rrep(i, a) RREP(i, a, 0)\n#define RREP(i, a, b) for(int i = a; i >= b; --i)\n#define repll(i, a) REPLL(i, 0, a)\n#define REPLL(i, a, b) for(ll i = a; i < b; ++i)\n#define rrepll(i, a) RREPLL(i, a, 0)\n#define RREPLL(i, a, b) for(ll i = a; i >= b; --i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<int, P> PP;\nconst double PI = 3.14159265358979323846;\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+18 + 10;\n\nint h, w, ans = 0;\nint map[1401][1401];\n\nint main(){\n\tstd::cin >> h >> w;\n\trep(i, h){\n\t\trep(j, w)std::cin >> map[i][j], map[i][j] = (1 - map[i][j]);\n\t}\n\n\trep(i, w){\n\t\tREP(j, 1, h)map[j][i] = (map[j][i] == 0 ? 0 : map[j - 1][i] + 1);\n\t}\n\n\trep(i, h){\n\t\tint max = 0;\n\t\tstd::stack<P> s;\n\t\trep(j, w){\n\t\t\tif (s.empty() || s.top().first < map[i][j]){\n\t\t\t\ts.push(P(map[i][j], j));\n\t\t\t}\n\t\t\twhile (s.size() && s.top().first > map[i][j]){\n\t\t\t\tmax = std::max(max, s.top().first * (j - s.top().second));\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t\twhile (s.size()){\n\t\t\tmax = std::max(max, s.top().first * (w - s.top().second));\n\t\t\ts.pop();\n\t\t}\n\n\t\tans = std::max(max, ans);\n\t}\n\n\tstd::cout << ans << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define srep(i,s,t) for (int i = s; i < t; ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\n#define yn {puts(\"Yes\");}else{puts(\"No\");}\n#define MAX_N 200005\n#define MAX 3005\n\nstruct Rectangle {int height; int pos;};\n\nint getLargestRectangle(int size, int buffer[]){\n    stack<Rectangle> S;\n    int maxv = 0;\n    buffer[size] = 0;\n\n    for(int i = 0; i <= size; i++){\n        Rectangle rect;\n        rect.height = buffer[i];\n        rect.pos = i;\n        if(S.empty()){\n            S.push(rect);\n        }else{\n            if(S.top().height < rect.height){\n                S.push(rect);\n            }else if(S.top().height > rect.height){\n                int target = i;\n                while(!S.empty() && S.top().height >= rect.height){\n                    Rectangle pre = S.top(); S.pop();\n                    int area = pre.height * (i - pre.pos);\n                    maxv = max(maxv, area);\n                    target = pre.pos;\n                }\n                rect.pos = target;\n                S.push(rect);\n            }\n        }\n    }\n    return maxv;\n}\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle(){\n    for(int j = 0; j < W; j++){\n        for(int i = 0; i < H; i++){\n            if(buffer[i][j]){\n                T[i][j] = 0;\n            }else{\n                T[i][j] = (i > 0) ? T[i-1][j] + 1 : 1;\n            }\n        }\n    }\n\n    int maxv = 0;\n    for(int i = 0; i < H; i++){\n        maxv = max(maxv, getLargestRectangle(W, T[i]));\n    }\n\n    return maxv;\n}\n\n\nint main() {\n    cin >> H >> W;\n    rep(i,H)rep(j,W)cin >> buffer[i][j];\n\n    int ans = getLargestRectangle();\n\n    cout << ans << endl;\n    return 0;\n}\n \n \n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<algorithm>\n#include<stack>\n#define MAX 1400\n\nusing namespace std;\n\nstruct Rectangle\n{\n\tint height; int pos;\n};\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\n\nint getLangestRectangle(int size, int buffer[]) {\n\tstack<Rectangle>S;\n\tint maxv = 0;\n\tbuffer[size] = 0;\n\tfor (int i = 0; i <= size; i++) {\n\t\tRectangle rect;\n\t\trect.height = buffer[i];\n\t\trect.pos = i;\n\t\tif (S.empty()) {\n\t\t\tS.push(rect);\n\t\t}\n\t\telse {\n\t\t\tif (S.top().height < rect.height) {\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t\telse if(S.top().height>rect.height){\n\t\t\t\tint target = i;\n\t\t\t\twhile (!S.empty() && S.top().height >= rect.height) {\n\t\t\t\t\tRectangle pre = S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tint area = pre.height*(i - pre.pos);\n\t\t\t\t\tmaxv = max(maxv, area);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos = target;\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxv;\n}\n\nint getLargestRectangel() {\n\tfor (int j = 0; j < W; j++) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tif (buffer[i][j]) {\n\t\t\t\tT[i][j] = 0;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tT[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n\t\t\t}\n\t\t}\n\t}\n\tint maxv = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tmaxv = max(maxv, getLangestRectangle(W, T[i]));\n\t}\n\treturn maxv;\n}\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> buffer[i][j];\n\t\t}\n\t}\n\tcout << getLargestRectangel() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\nconst int adx[] = { 1,1,1,0,-1,-1,-1,0 };\nconst int ady[] = { 1,0,-1,-1,-1,0,1,1 };\n\nint add(const int base, const int plus) {\n\tif (!plus) {\n\t\treturn base + 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n//0 :?????????1:??????2:?????????3:??? 4:?????????5:??? 6:?????? 7:??? ???\nvector<vector<vector<int>>>get_cumulative_sum(const vector<vector<int>>&field) {\n\tconst int H = field.size();\n\tconst int W = field[0].size();\n\n\tvector<vector<vector<int>>>sums(H, vector<vector<int>>(W, vector<int>(8)));\n\tfor (int ny = 0; ny <H; ++ny) {\n\t\tfor (int nx = 0; nx <W; ++nx) {\n\t\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\t\tint py = ny - ady[k];\n\t\t\t\tint px = nx - adx[k];\n\t\t\t\tif (!(px >= 0 && px <W && py >= 0 && py <H))continue;\n\n\t\t\t\tsums[ny][nx][k] = add(sums[py][px][k], field[ny][nx]);\n\n\t\t\t}\n\t\t}\n\t}\n\tfor (int ny = H - 1; ny >= 0; --ny) {\n\t\tfor (int nx = 0; nx <W; ++nx) {\n\t\t\tfor (int k = 2; k < 4; ++k) {\n\t\t\t\tint py = ny - ady[k];\n\t\t\t\tint px = nx - adx[k];\n\t\t\t\tif (!(px >= 0 && px <W && py >= 0 && py <H))continue;\n\n\t\t\t\tsums[ny][nx][k] = add(sums[py][px][k], field[ny][nx]);\n\n\t\t\t}\n\t\t}\n\t}\n\tfor (int ny = H - 1; ny >= 0; --ny) {\n\t\tfor (int nx = W - 1; nx >= 0; --nx) {\n\t\t\tfor (int k = 4; k < 6; ++k) {\n\t\t\t\tint py = ny - ady[k];\n\t\t\t\tint px = nx - adx[k];\n\t\t\t\tif (!(px >= 0 && px <W && py >= 0 && py <H))continue;\n\n\t\t\t\tsums[ny][nx][k] = add(sums[py][px][k], field[ny][nx]);\n\n\t\t\t}\n\t\t}\n\t}\n\tfor (int ny = 0; ny <H; ++ny) {\n\t\tfor (int nx = W - 1; nx >= 0; --nx) {\n\t\t\tfor (int k = 6; k < 8; ++k) {\n\t\t\t\tint py = ny - ady[k];\n\t\t\t\tint px = nx - adx[k];\n\t\t\t\tif (!(px >= 0 && px <W && py >= 0 && py <H))continue;\n\n\t\t\t\tsums[ny][nx][k] = add(sums[py][px][k], field[ny][nx]);\n\n\t\t\t}\n\t\t}\n\t}\n\treturn sums;\n}\n\nint getans( vector<int>hs) {\n\ths.emplace_back(0);\n\tstack<pair<int, int>>que;\n\tint ans = 0;\n\tfor (int x = 0; x < hs.size(); ++x) {\n\t\t\n\t\tif (que.empty()) {\n\t\t\tque.push(make_pair(x, hs[x]));\n\t\t}\n\t\telse {\n\t\t\twhile (!que.empty()) {\n\t\t\t\tauto p = que.top();\n\t\t\t\tif (p.second < hs[x]) {\n\t\t\t\t\tque.push(make_pair(x,hs[x]));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (p.second == hs[x]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint area = (x - p.first)*p.second;\n\t\t\t\t\tans = max(ans, area);\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif (!que.empty()) {\n\t\t\t\t\t\tauto np = que.top();\n\t\t\t\t\t\tif (np.second < hs[x]) {\n\t\t\t\t\t\t\tque.push(make_pair(p.first, hs[x]));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\t\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>>field(H + 2, vector<int>(W + 2,1));\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tcin >> field[i + 1][j + 1];\n\t\t}\n\t}\n\tauto vs = get_cumulative_sum(field);\n\tint ans = 0;\n\t\n\tfor (int y = 1; y <= H; ++y) {\n\t\tvector<int>v;\n\t\tfor (int x = 1; x <= W; ++x) {\n\t\t\tv.push_back(vs[y][x][3]);\n\t\t}\n\t\tans = max(ans, getans(v));\n\t}\n\tcout << ans*ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#pragma comment(linker,\"/STACK:102400000,102400000\")\n#define INF 0x3f3f3f3f\n#define maxm 1500\ntypedef long long ll;\nusing namespace std;\nint mp[maxm][maxm]{0};\nint t[maxm][maxm]{0};\nint calRectangle(int (&vec)[maxm],int w,int time)\n{\n    int result=0;\n    stack<int> stk;\n    vec[w+1]=0;\n    //if(true){for(int i=1;i<=w;i++)cout<<vec[i]<<\" \";cout<<endl;}\n    for(int i=1;i<=w+1;i++)\n    {\n        if(stk.empty()||vec[stk.top()]<=vec[i])\n            stk.push(i);\n        else\n        {\n            int temp=stk.top();\n            stk.pop();\n            result=max(result,vec[temp]*(stk.empty()?(i-1):(i-stk.top()-1)));\n            i--;\n        }\n    }\n    //cout<<result<<endl;\n    return result;\n}\nint main()\n{\n    int h,w,pt,res=0;\n    cin>>h>>w;\n    for(int i=1;i<=h;i++)\n        for(int j=1;j<=w;j++)\n            cin>>mp[i][j];\n    for(int j=1;j<=w;j++)\n    {\n        pt=1;\n        for(int i=1;i<=h;i++)\n            if(!mp[i][j])\n                t[i][j]=pt++;\n            else\n            {\n                t[i][j]=0;\n                pt=1;\n            }\n    }\n    //for(int i=1;i<=h;i++){for(int j=1;j<=w;j++)cout<<t[i][j]<<\" \";cout<<endl;};\n    for(int i=1;i<=h;i++)\n        res=max(res,calRectangle(t[i],w,i));\n    cout<<res<<endl;\n    return 0;\n}\n//Do not use memset !\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n\tRectangle rect;\n\tfor(int i=0;i<x;i++){\n\t\tstack<Rectangle> stk;\n\t\tint pop=0;\n\t\tfor(int j=0;j<=y;j++){\n\t\t\trect.height = m[j][i];\n\t\t\tif(rect.height==0)pop=0;\n\t\t\trect.pos = j;\n\t\t\tif(stk.empty() || stk.top().height < rect.height){\n\t\t\t\tstk.push(rect);\n\t\t\t}else{\n\t\t\t\t//printf(\"[-] %d %d\\n\",i,j);\n\t\t\t\tint target = j;\n\t\t\t\tfor(;!stk.empty() && stk.top().height >= rect.height;){\n\t\t\t\t\tpop++;\n\t\t\t\t\tRectangle pre = stk.top(); stk.pop();\n\t\t\t\t\tint area = pre.height * (j - pre.pos);\n\t\t\t\t\tr = max(r, area);\n\t\t\t\t\t//printf(\"%d %d\\n\",target,pre.pos);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos = j-pop;//target;\n\t\t\t\tstk.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\n#include <vector>\n#include <iostream>\nstruct State {\n\tint size, index;\n\tvoid set(const int &i) {\n\t\tsize = size * i + i;\n\t}\n\tState(int s = 0, int i = 0) :size(s), index(i) {};\n};\n\nint maximum(std::vector<int> &state) {\n\tstd::stack<State> stack;\n\tstack.push(State());\n\tint max = 0;\n\tfor (auto i = 0; i < state.size(); ++i) {\n\t\tif (state.at(i) > stack.top().size) {\n\t\t\tstack.push(State(state.at(i), i));\n\t\t}\n\t\telse {\n\t\t\tauto temp = stack.top();\n\t\t\twhile (stack.top().size > state.at(i)) {\n\t\t\t\ttemp = stack.top();\n\t\t\t\tif (max < (i - stack.top().index) * stack.top().size) {\n\t\t\t\t\tmax = (i - stack.top().index) * stack.top().size;\n\t\t\t\t}\n\t\t\t\tstack.pop();\n\t\t\t}\n\t\t\ttemp.size = state.at(i);\n\t\t\tstack.push(temp);\n\t\t}\n\t}\n\treturn max;\n}\nstruct Container {\n\tstd::vector<int> *now, *prev;\n\tContainer(const int &n = 0) :now{ new std::vector<int>(n, 0) }, prev{ new std::vector<int>(n, 0) } { };\n\tint &at(const int &i) { return now->at(i); }\n\tint &at2(const int &i) { return prev->at(i); }\n\tstd::vector<int> &get_now() { return *now; }\n\tvoid swit() { auto temp = now; now = prev; prev = temp; }\n\n};\nint main() {\n\tint h, w;\n\tstd::cin >> h >> w;\n\tContainer vector(w + 1);\n\tint max = 0;\n\tfor (auto i = 0; i < h; ++i) {\n\t\tfor (auto j = 0; j < w; ++j) {\n\t\t\tint c;\n\t\t\tstd::cin >> c;\n\t\t\tvector.at(j) = (vector.at2(j) + 1) * (1 - c);\n\t\t}\n\t\tauto temp = maximum(vector.get_now());\n\t\tif (temp > max) {\n\t\t\tmax = temp;\n\t\t}\n\t\tvector.swit();\n\t}\n\tstd::cout << max << std::endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cmath>\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include<vector>\n#include<cstring>\n#include<set>\n#include <cstdio>\n#include<queue>\n#include<map>\n#define WHITE 0\n#define GRAY  1\n#define BLACK 2\n#define endl '\\n'\n#define forup(i,a,n) for( int i =a; i < n; i++)\n#define llforup(i,a,n) for( ll i =a; i < n; i++)\n#define fordown(i,a,n) for( int i =a; i >= n; i--)\n#define fornot(i,a,n) for( int i=a;!n;i++)\n#define mod  (ll)(1e9+7)\n#define ifempty(a)  if(!a)\nusing namespace std;\ntypedef long long ll;\ninline int readnum()\n{\n\tint p, data = 0; char ch = 0;\n\twhile ((ch != ' - ') && ch < '0' || ch>'9') ch = getchar();//相当于正则表达式的搜索，跳过不需要的字符\n\tif (ch == '- ')p = -1, ch = getchar();\n\telse p = 1;\n\twhile (ch >= '0' && ch <= '9') data = data * 10 + ch - '0', ch = getchar();//搜索需要的字符\n\treturn data * p;\n}\n//E-mail 374656045@qq.com\n#define MAX 1400\nint tile[MAX][MAX + 1];\nstruct Rectangle { int height; int pos; };\nRectangle stack[1401];//开全局第W+1个已经自动初始化为0\nclass solve {\nprivate:\n\tint H, W; int area; int bound; int top;\n\tchar ch;\npublic:\n\tsolve()\n\t{\n\t\tinitial();//OK,单元测试通过\n\t\tint ans = getrectangle();//方便生成优质机器码\n\t\tprintf(\"%d\\n\",ans );\n\t}\n\tinline void initial()\n\t{\n\t\tscanf(\"%d %d\", &H, &W);\n\t\tforup(i, 0, H)\n\t\t\tforup(j, 0, W)\n\t\t{\n\t\t\tch = getchar();\n\t\t\twhile (ch == ' ' || ch == '\\n')\n\t\t\t\tch = getchar();//惯用法\n\n\t\t\ttile[i][j] = (ch == '0') ? 0 : 1;\n\t\t}\n\t\tforup(i, 0, W)tile[0][i] = (tile[0][i] == 0) ? 1 : 0;\n\t\tforup(i, 1, H)\n\t\t\tforup(j, 0, W)\n\t\t\ttile[i][j] = (tile[i][j] == 0) ? (tile[i - 1][j] + 1) : 0;//OK,\n\t}\n\tint getrectangle()\n\t{\n\t\tint maxv = 0;\n\t\tforup(i, 0, H)\n\t\t{//开头元素必须要特殊处理，还有++top更合适\n\t\t\ttop = 0; stack[top].height = tile[i][0];// stack[top].pos = 0;这部分自动初始化\n\t\t\tforup(j, 1, W + 1)//由于开全局，每行第W+1个元素已经被初始化为0.\n\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\tif (stack[top].height < tile[i][j]) \n\t\t\t\t\t{\n\t\t\t\t\t\tstack[++top].height = tile[i][j]; stack[top].pos = j;\n\t\t\t\t\t}//分级防止越界\n\t\t\t\t\telse if(stack[top].height>tile[i][j])\n\t\t\t\t\t{\n\t\t\t\t\t\twhile (stack[top].height > tile[i][j])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tarea =stack[top].height * (j - stack[top].pos);\n\t\t\t\t\t\t\ttop--;\n\t\t\t\t\t\t\tif (area > maxv)\n\t\t\t\t\t\t\t\tmaxv = area;\n\t\t\t\t\t\t\tif (top==-1)break;//麻烦，降低效率，改进否？\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstack[++top].height = tile[i][j];//反应了手写数组栈的优势！\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t\n\t\treturn\tmaxv;\n\t}\n};\nint main(void)\n{\n\t//ios_base::sync_with_stdio(0); cin.tie(0);//慎用，cin和scanf混用会导致非MSC++WA\n#ifdef DEBUG\n\tfreopen(\"input.txt\", \"r\", stdin);\n\tfreopen(\"output.txt\", \"w\", stdout);\n#endif\n\tsolve solution;\n#ifdef DEBUG\n\tfclose(stdin);//关闭文件 \n\tfclose(stdout);//关闭文件 \n#endif\n\treturn 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\ntypedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = LONG_LONG_MAX / 10;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\nconst int mod = 1000000007;\n\n\nvoid print_line(vector<ll> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\n\nstruct Rectangle {\n    int start, height;\n};\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n//\n//    int h = 1200;\n//    int w = 1150;\n\n    vector<vector<int>> area(h, vector<int>(w));;\n    vector<vector<int>> histogram(h, vector<int>(w+1, 0));\n\n    rep(y, h)rep(x, w) cin >> area[y][x];\n\n\n    rep(y, h) {\n        rep(x, w) {\n            if (area[y][x] == 0) {\n                if (y == 0) histogram[y][x] = 1;\n                else histogram[y][x] = histogram[y - 1][x] + 1;\n            } else {\n                histogram[y][x] = 0;\n            }\n        }\n    }\n    ll ans = 0;\n    rep(y, h) {\n        stack<Rectangle> s;\n        rep(x, w + 1) {\n            Rectangle rectangle;\n            rectangle.start = x;\n            rectangle.height = histogram[y][x];\n            if (s.empty()) s.push(rectangle);\n            else {\n                if (s.top().height < rectangle.height) {\n                    s.push(rectangle);\n                } else if (s.top().height > rectangle.height) {\n                    int target = x;\n                    while (!s.empty() && s.top().height >= rectangle.height) {\n                        Rectangle pre = s.top();\n                        s.pop();\n                        ll size = pre.height * (x - pre.start);\n                        cmax(ans, size);\n                        target = pre.start;\n                    }\n                    rectangle.start = target;\n                    s.push(rectangle);\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <stack>\nusing namespace std;\n\ntemplate <typename T>\nlong long largest_rectangle_hist(vector<T> &height) {\n    stack<int> st;\n    height.emplace_back(0);\n    vector<int> left(height.size());\n    long long ret = 0;\n    for (int i = 0; i < height.size(); i++) {\n        while (!st.empty() && height[st.top()] >= height[i]) {\n            ret = max(ret, 1LL * (i - left[st.top()]) * height[st.top()]);\n            st.pop();\n        }\n        left[i] = st.empty() ? 0 : st.top() + 1;\n        st.emplace(i);\n    }\n    return ret;\n}\n\nint main() {\n    int H, W; cin >> H >> W;\n    vector<vector<int>> c(H, vector<int>(W));\n    for (auto &ci: c) for (auto &cij: ci) cin >> cij;\n    vector<vector<int>> dp(H, vector<int>(W, 0));\n    for (int j = 0; j < W; j++) {\n        for (int i = 0; i < H; i++) {\n            if (c[i][j]) dp[i][j] = 0;\n            else dp[i][j] = i ? dp[i - 1][j] + 1 : 1;\n        }\n    }\n    long long ans = 0;\n    for (int i = 0; i < H; i++) {\n        ans = max(ans, largest_rectangle_hist(dp[i]));\n    }\n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nconst int MAX = 1400;\n\nint main() {\n\tint H, W;\n\tint tile[MAX][MAX];\n\tint ans = 0;\n\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tscanf(\"%d\", &tile[i][j]);\n\t\t}\n\t}\n\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = W - 1; x >= 0; x--) {\n\t\t\tif (tile[y][x] == 1)tile[y][x] = 0;\n\t\t\telse if (x == W - 1)tile[y][x] = 1;\n\t\t\telse tile[y][x] = tile[y][x + 1] + 1;\n\t\t}\n\t}\n\n\tfor (int x = 0; x < W; x++) {\n\t\tstack<pair<int, int>> s;\n\t\ts.push(pair<int, int>(-1, -1));\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tif (s.top().second < tile[y][x]) {\n\t\t\t\ts.push(pair<int, int>(y, tile[y][x]));\n\t\t\t}\n\t\t\telse if (s.top().second > tile[y][x]) {\n\t\t\t\twhile (s.top().second > tile[y][x]) {\n\t\t\t\t\tans = max(ans, (y - s.top().first) * s.top().second);\n\t\t\t\t\ts.pop();\n\t\t\t\t}\n\t\t\t\tif(s.top().second != tile[y][x])s.push(pair<int, int>(y, tile[y][x]));\n\t\t\t}\n\t\t}\n\t\twhile (!s.empty()) {\n\t\t\tans = max(ans, (W - 1 - s.top().first) * s.top().second);\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// include\n//------------------------------------------\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n// conversion\n//------------------------------------------\ninline int toInt(string s) {\n    int v;\n    istringstream sin(s);\n    sin >> v;\n    return v;\n}\ntemplate <class T>\ninline string toString(T x) {\n    ostringstream sout;\n    sout << x;\n    return sout.str();\n}\n\n// math\n//-------------------------------------------\ntemplate <class T>\ninline T sqr(T x) {\n    return x * x;\n}\n\n// typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n// container util\n//------------------------------------------\n#define ALL(a) (a).begin(), (a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i, c) \\\n    for (typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)\n#define EXIST(s, e) ((s).find(e) != (s).end())\n#define SORT(c) sort((c).begin(), (c).end())\n\n// repetition\n//------------------------------------------\n#define FOR(i, a, b) for (int i = (a); i < (b); ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define REPI(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\n\n// constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\nconst int INF_INT = 2147483647;\nconst LL INF_LL = 9223372036854775807;\n\n// clear memory\n//--------------------------------------------\n#define CLR(a) memset((a), 0, sizeof(a))\n\n// vector\n//--------------------------------------------\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n\n// pair\n//--------------------------------------------\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, pair<T, U> &pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n\n// vector\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"{\";\n    for (int i = 0; i < vec.size(); i++) {\n        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n    }\n    os << \"}\";\n    return os;\n}\n\n// list\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, const list<T> &lst) {\n    os << \"{\";\n    REPI(itr, lst) {\n        os << *itr;\n        itr++;\n        if (itr != lst.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// map\n//--------------------------------------------\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, map<T, U> &map_var) {\n    os << \"{\";\n    REPI(itr, map_var) {\n        os << *itr;\n        itr++;\n        if (itr != map_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// set\n//--------------------------------------------\ntemplate <typename T>\nostream &operator<<(ostream &os, set<T> &set_var) {\n    os << \"{\";\n    REPI(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n// dump\n//--------------------------------------------\n#define DUMPOUT cerr\n\nvoid dump_func() { DUMPOUT << endl; }\ntemplate <class Head, class... Tail>\nvoid dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) {\n        DUMPOUT << \", \";\n    }\n    dump_func(std::move(tail)...);\n}\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                       \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                     \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\" \\\n            << endl                                                     \\\n            << \"    \",                                                  \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\n\nstruct Rectangle {\n    int h, p;\n};\n\nint getLargestRectangle(int size, int buffer[]) {\n    stack<Rectangle> s;\n    int maxv = 0;\n    buffer[size] = 0;\n\n    REP(i, size + 1) {\n        Rectangle rect;\n        rect.h = buffer[i];\n        rect.p = i;\n        if (s.empty())\n            s.push(rect);\n        else if (s.top().h < rect.h)\n            s.push(rect);\n        else if (s.top().h > rect.h) {\n            int target = i;\n            while (!s.empty() && s.top().h >= rect.h) {\n                Rectangle pre = s.top();\n                s.pop();\n                int area = pre.h * (i - pre.p);\n                maxv = max(maxv, area);\n                target = pre.p;\n            }\n            rect.p = target;\n            s.push(rect);\n        }\n    }\n    return maxv;\n}\n\nstatic const int MAX = 1400;\nint h, w;\nint buffer[MAX][MAX];\nint t[MAX][MAX];\n\nint getLargestRectangle() {\n    REP(j, w) REP(i, h) {\n        if (buffer[i][j])\n            t[i][j] = 0;\n        else\n            t[i][j] = (i > 0) ? t[i - 1][j] + 1 : 1;\n    }\n    int maxv = 0;\n    REP(i, h) maxv = max(maxv, getLargestRectangle(w, t[i]));\n    return maxv;\n}\n\nint main(void) {\n    cin >> h >> w;\n    REP(i, h) REP(j, w) cin >> buffer[i][j];\n    cout << getLargestRectangle() << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<stack>\n#include<algorithm>\n#define MAX 1400\n\nusing namespace std;\n\nstruct Rectangle { int height, int pos; };\n\nint getLargestRectangle(int size, int buffer[]) {\n  stack<Rectangle> S;\n  int maxv = 0;\n  buffer[size] = 0;\n\n  for ( int i = 0; i <= size; i++ ) {\n    Rectangle rect;\n    rect.height = buffer[i];\n    rect.pos = i;\n    if ( S.empty() ) {\n      S.push(rect);\n    } else {\n      if ( S.top().height < rect.height ) {\n        S.push(rect);\n      } else if ( S.top().height > rect.height ) {\n        int target = i;\n        while ( !S.empty() && S.top().height >= rect.height ) {\n          Rectangle pre = S.top(); S.pop();\n          int area = pre.height * (i - pre.pos);\n          maxv = max(maxv, area);\n          target = pre.pos;\n        }\n        rect.pos = target;\n        S.push(rect);\n      }\n    }\n  }\n  return maxv;\n}\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle() {\n  for ( int j = 0; j < W; j++ )\n    for ( int i = 0; i < H; i++ ) {\n      if ( buffer[i][j] )\n        T[i][j] = 0;\n      else\n        T[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n    }\n\n  int maxv = 0;\n  for ( int i = 0; i < H; i++ )\n    maxv = max(maxv, getLargestRectangle(W, T[i]));\n\n  return maxv;\n}\n\nint main() {\n  scanf(\"%d %d\", &H, &W);\n  for ( int i = 0; i < H; i++ )\n    for ( int j = 0; j < W; j++ )\n      scanf(\"%d\", &buffer[i][j]);\n  cout << getLargestRectangle() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\nusing namespace std;\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n    char mat[h][w];\n    int dp[h][w];\n\n    for (int i = 0; i < h; i++)\n    {\n        for (int j = 0; j < w; j++)\n        {\n            cin >> mat[i][j];\n        }\n    }\n\n    for (int i = 0; i < w; i++)\n        dp[0][i] = (mat[0][i] == '0');\n    for (int i = 1; i < h; i++)\n    {\n        for (int j = 0; j < w; j++)\n        {\n            if (mat[i][j] == '0')\n                dp[i][j] = dp[i - 1][j] + 1;\n            else\n                dp[i][j] = 0;\n        }\n    }\n\n    int ans = -1;\n    for (int i = 0; i < h; i++)\n    {\n        // pair<left end, height>\n        stack<pair<int, int>> s;\n        for (int j = 0; j < w; j++)\n        {\n            if (s.empty())\n            {\n                s.push({j, dp[i][j]});\n            }\n            else if (dp[i][j] > s.top().second)\n            {\n                s.push({j, dp[i][j]});\n            }\n            else if (dp[i][j] == s.top().second)\n            {\n                // do nothing.\n            }\n            else if (dp[i][j] < s.top().second)\n            {\n                int left;\n                while (!s.empty() && dp[i][j] < s.top().second)\n                {\n                    pair<int, int> now = s.top();\n                    s.pop();\n                    // make rectangle\n                    ans = max(ans, (j - now.first) * (now.second));\n                    left = now.first;\n                }\n                s.push({left, dp[i][j]});\n            }\n        }\n\n        while (!s.empty())\n        {\n            pair<int, int> now = s.top();\n            s.pop();\n            ans = max(ans, (h - now.first) * (now.second));\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n  Rectangle rect;\n  int maxArea = 0;\n  for (int i = 0; i < x; i++) {\n    stack<Rectangle> stk;\n    for (int j = 0; j <= y; j++) {\n      rect.height = m[i][j];\n      rect.pos = j;\n      if (stk.empty()) {\n        stk.push(rect);\n      } else {\n        if (stk.top().height < rect.height) {\n          stk.push(rect);\n        } else if (stk.top().height > rect.height) {\n          int target = j;\n          while (!stk.empty() && stk.top().height >= rect.height) {\n            Rectangle pre = stk.top(); stk.pop();\n            int area = pre.height * (j - pre.pos);\n            maxArea = max(maxArea, area);\n            target = pre.pos;\n          }\n          rect.pos = target;\n          stk.push(rect);\n        }\n      }\n    }\n  }\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <stack>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1400;\nstruct Rectangle { int height, pos; };\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangleR(int idx, int size) {\n    stack<Rectangle> S;\n    int maxv = 0;\n    T[idx][size] = 0;\n\n    Rectangle rect, pre;\n    for (int i = 0; i <= size; i++) {\n        rect.height = T[idx][i];\n        rect.pos = i;\n        if ( S.empty() ) {\n            S.push(rect);\n        } else {\n            if (S.top().height < rect.height) S.push(rect);\n            else if (S.top().height > rect.height) {\n                int target = i;\n                while ( !S.empty() && S.top().height >= rect.height) {\n                    pre = S.top(); S.pop();\n                    int area = pre.height * (i - pre.pos);\n                    maxv = max(maxv, area);\n                    target = pre.pos;\n                }\n                rect.pos = target;\n                S.push(rect);\n            }\n        }\n    }\n    return maxv;\n}\n\nint getLargestRectangle() {\n    for (int j = 0; j < W; j++) {\n        for (int i = 0; i < H; i++) {\n            if (buffer[i][j]) T[i][j] = 0;\n            else T[i][j] = (i > 0) ? T[i-1][j] + 1 : 1;\n        }\n    }\n    int maxv = 0;\n    for (int i = 0; i < H; i++) maxv = max(maxv, getLargestRectangleR(i, W));\n    return maxv;\n}\n\n\n\n\nint main()\n{\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) scanf(\"%d\", &buffer[i][j]);\n    }\n    printf(\"%d\\n\", getLargestRectangle());\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct rect{\n\t  int left, height;\n\t  rect(int l, int h){\n\t\t\tleft = l; height = h;\n\t  }\n};\n\nint solve(vector<int>& hist){\n\t  hist.push_back(0);\n\t  int W = hist.size();\n\t  int ans = 0;\n\t  stack<rect> st;\n\t  for(int i=0; i<W; i++){\n\t\t\tif( st.empty() ){\n\t\t\t\t  st.push( rect(i,hist[i]) );\t\n\t\t\t}else{\n\t\t\t\t  rect max_h = st.top();\n\t\t\t\t  if( max_h.height < hist[i]){\n\t\t\t\t\t\tst.push( rect(i,hist[i]) );\n\t\t\t\t  }\n\t\t\t\t  else if( max_h.height > hist[i] ){\n\t\t\t\t\t\twhile( !st.empty() and max_h.height >= hist[i] ) {\n\t\t\t\t\t\t\t  max_h = st.top();\n\t\t\t\t\t\t\t  ans = max(ans, max_h.height * (i - max_h.left-1) );\n\t\t\t\t\t\t\t  st.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tst.push( rect(max_h.left, hist[i]) ) ;\n\t\t\t\t  }\n\t\t\t}\n//\t\t\tcout << ans << \" \" ;\n\t  }\n\t  return ans ;\n}\n\nint main(){\n\t  // input\n\t  int H,W;\n\t  cin >> H >> W;\n\t  vector<vector<int> > m(H+1,vector<int>(W,0));\n\t  for(int i=1; i<=H; i++)\n\t\t\tfor(int j=0; j<W; j++)\n\t\t\t\t  cin >> m[i][j];\n\n\t  // pre proces\n\t  vector<vector<int> > dp(H+1,vector<int>(W,0));\n\t  for(int i=1; i<=H; i++){\n\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\t  if(m[i][j] == 1)\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t  else\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j]+1;\n\t\t\t}\n\t  }\n\t  \n\t  int ans = 0;\n\t  for(int i=1; i<=H; i++){\n\t\t\tans = max(ans, solve(dp[i]));\n//\t\t\tcout << endl;\n\t  }\n\t  /*\n\t  for(int i=1; i<=H; i++){\n\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\t  cout << dp[i][j] <<\" \";\n\t\t\t}\n\t\t\tcout << \": \" << solve(dp[i]) << endl;\n\t  }\n\t  */\n\t  \n\t  cout << ans << endl;\n\t  \n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\n//?????§????????¢ O(H*W)\n//???????????°??????????????§????????¢????±????????????¨????§?\nvoid largest_rectangle() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>> v(H, vector<int>(W));\n\trep(i, 0, H) rep(j, 0, W) {\n\t\tint x; cin >> x;\n\t\tv[i][j] = !x;\n\t}\n\trep(i, 0, H - 1)rep(j, 0, W) {\n\t\tif (v[i + 1][j] == 0)continue;\n\t\tv[i + 1][j] += v[i][j];\n\t}\n\tusing P = pair<int, int>;\n\tint ans = 0;\n\trep(i, 0, H) {\n\t\tstack<P> st;\n\t\tst.emplace(-1, -1);\n\t\trep(j, 0, W) {\n\t\t\tif (st.top().first == v[i][j])\n\t\t\t\tcontinue;\n\t\t\tint pos = j;\n\t\t\twhile (st.top().first >= v[i][j]) {\n\t\t\t\tchmax(ans, st.top().first*(j - st.top().second));\n\t\t\t\tpos = st.top().second;\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\tst.emplace(v[i][j], pos);\n\t\t}\n\t\twhile (st.size()) {\n\t\t\tchmax(ans, st.top().first*(W - st.top().second));\n\t\t\tst.pop();\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tlargest_rectangle();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct rect{\n\t  int left, height;\n\t  rect(int l, int h){\n\t\t\tleft = l; height = h;\n\t  }\n};\n\nint solve(vector<int>& hist){\n\t  hist.push_back(0);\n\t  int W = hist.size();\n\t  int ans = 0;\n\t  stack<rect> st;\n\t  for(int i=0; i<W; i++){\n\t\t\tif( st.empty() ){\n\t\t\t\t  st.push( rect(i,hist[i]) );\t\n\t\t\t}else{\n\t\t\t\t  rect max_h = st.top();\n\t\t\t\t  if( max_h.height < hist[i]){\n\t\t\t\t\t\tst.push( rect(i,hist[i]) );\n\t\t\t\t  }\n\t\t\t\t  else if( max_h.height > hist[i] ){\n\t\t\t\t\t\twhile( !st.empty() and max_h.height >= hist[i] ) {\n\t\t\t\t\t\t\t  max_h = st.top();\n\t\t\t\t\t\t\t  ans = max(ans, max_h.height * (i - max_h.left-1) );\n\t\t\t\t\t\t\t  st.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tst.push( rect(max_h.left, hist[i]) ) ;\n\t\t\t\t  }\n\t\t\t}\n//\t\t\tcout << ans << \" \" ;\n\t  }\n\t  return ans ;\n}\n\nint main(){\n\t  // input\n\t  int H,W;\n\t  cin >> H >> W;\n\t  vector<vector<int> > m(H+1,vector<int>(W,0));\n\t  for(int i=1; i<=H; i++)\n\t\t\tfor(int j=0; j<W; j++)\n\t\t\t\t  cin >> m[i][j];\n\n\t  // pre proces\n\t  vector<vector<int> > dp(H+1,vector<int>(W,0));\n\t  for(int i=1; i<=H; i++){\n\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\t  if(m[i][j] == 1)\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t  else\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j]+1;\n\t\t\t}\n\t  }\n\t  \n\t  int ans = 0;\n\t  for(int i=1; i<=H; i++){\n\t\t\tans = max(ans, solve(dp[i]));\n\t\t\tcout << endl;\n\t  }\n\t  /*\n\t  for(int i=1; i<=H; i++){\n\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\t  cout << dp[i][j] <<\" \";\n\t\t\t}\n\t\t\tcout << \": \" << solve(dp[i]) << endl;\n\t  }\n\t  */\n\t  \n\t  cout << ans << endl;\n\t  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#pragma comment(linker,\"/STACK:102400000,102400000\")\n#define INF 0x3f3f3f3f\n#define maxm 1500\ntypedef long long ll;\nusing namespace std;\nint mp[maxm][maxm]{0};\nint t[maxm][maxm]{0};\nint calRectangle(int (&vec)[maxm],int w,int time)\n{\n    int result=0;\n    stack<int> stk;\n    vec[w+1]=0;\n    if(true){for(int i=1;i<=w;i++)cout<<vec[i]<<\" \";cout<<endl;}\n    for(int i=1;i<=w+1;i++)\n    {\n        if(stk.empty()||vec[stk.top()]<=vec[i])\n            stk.push(i);\n        else\n        {\n            int temp=stk.top();\n            stk.pop();\n            result=max(result,vec[temp]*(stk.empty()?(i-1):(i-stk.top()-1)));\n            i--;\n        }\n    }\n    //cout<<result<<endl;\n    return result;\n}\nint main()\n{\n    int h,w,pt,res=0;\n    cin>>h>>w;\n    for(int i=1;i<=h;i++)\n        for(int j=1;j<=w;j++)\n            cin>>mp[i][j];\n    for(int j=1;j<=w;j++)\n    {\n        pt=1;\n        for(int i=1;i<=h;i++)\n            if(!mp[i][j])\n                t[i][j]=pt++;\n            else\n            {\n                t[i][j]=0;\n                pt=1;\n            }\n    }\n    //for(int i=1;i<=h;i++){for(int j=1;j<=w;j++)cout<<t[i][j]<<\" \";cout<<endl;};\n    for(int i=1;i<=h;i++)\n        res=max(res,calRectangle(t[i],w,i));\n    cout<<res<<endl;\n    return 0;\n}\n//Do not use memset !\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nstruct Cell {\n\tint pos, height;\n};\n\nint main() {\n\tint H, W;\n\tscanf(\"%d %d\", &H, &W);\n\n\tint A[H + 1][W + 1];\n\tfor (int i = 1; i <= H; ++i) {\n\t\tfor (int j = 1; j <= W; ++j) {\n\t\t\tscanf(\"%d\", &A[i][j]);\n\t\t}\n\t}\n\tint C[H + 1][W + 1];\n\tfor (int i = 0; i <= H; ++i) {\n\t\tC[i][W] = 0;\n\t}\n\tfor (int i = 0; i <= W; ++i) {\n\t\tC[0][i] = 0;\n\t}\n\n\tfor (int j = 1; j <= W; ++j) {\n\t\tfor (int i = 1; i <= H; ++i) {\n\t\t\tif (A[i][j] == 0) {\n\t\t\t\tC[i][j] = C[i - 1][j] + 1;\n\t\t\t} else {\n\t\t\t\tC[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxArea = 0;\n\tfor (int i = 1; i <= H; ++i) {\n\t\tstack<Cell> S;\n\t\tfor (int j = 1; j <= W; ++j) {\n\t\t\tCell c;\n\t\t\tc.height = C[i][j];\n\t\t\tif (S.empty() || S.top().height < C[i][j]) {\n\t\t\t\tc.pos = j;\n\t\t\t\tS.push(c);\n\t\t\t} else if (S.top().height > C[i][j]) {\n\t\t\t\tint prePos = j;\n\t\t\t\twhile (!S.empty() && S.top().height > C[i][j]) {\n\t\t\t\t\tCell pop = S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tint area = (j - pop.pos) * pop.height;\n\t\t\t\t\tmaxArea = max(maxArea, area);\n\t\t\t\t\tprePos = pop.pos;\n\t\t\t\t}\n\t\t\t\tc.pos = prePos;\n\t\t\t\tS.push(c);\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxArea << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<stack>\n#include<algorithm>\n#define MAX 1400\n\nusing namespace std;\n\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectangle(int size, int buffer[]) {\n    stack<Rectangle> S;\n    int maxv = 0;\n    buffer[size] = 0;\n    \n    for ( int i = 0; i <= size; i++ ) {\n        Rectangle rect;\n        rect.height = buffer[i];\n        rect.pos = i;\n        if ( S.empty() ) {\n            S.push(rect);\n        }else {\n            if ( S.top().height < rect.height ) {\n                S.push(rect);\n            }else if ( S.top().height > rect.height ) {\n                int target = i;\n                while ( !S.empty() && S.top().height >= rect.height ) {\n                    Rectangle pre = S.top(); S.pop();\n                    int area = pre.height * (i - pre.pos);\n                    maxv = max(maxv, area);\n                    target = pre.pos;\n                }\n                rect.pos = target;\n                S.push(rect);\n            }\n        }\n    }\n    return maxv;\n}\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle() {\n    for ( int j = 0; j < W; j++ ) {\n        for ( int i = 0; i < H; i++ ) {\n            if ( buffer[i][j] ) {\n                T[i][j] = 0;\n            } else {\n                T[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n            }\n        }\n    }\n    \n    int maxv = 0;\n    for ( int i = 0; i < H; i++ ) {\n        maxv = max(maxv, getLargestRectangle(W, T[i]));\n    }\n    \n    return maxv;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for ( int i = 0; i < H; i++ ) {\n        for ( int j = 0; j < W; j++ ) {\n            scanf(\"%d\", &buffer[i][j]);\n        }\n    }\n    cout << getLargestRectangle() << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//By Vlgd\n#include<bits/stdc++.h>\nusing namespace std;\nconst int N=1401;\nint M[N][N],h,w;\nstruct rect{int h,pos;};\nint maxrect(int r){\n\tstack<rect>S;\n\tint ans=0;\n\tfor(int i=0;i<=w;i++){\n\t\trect cur;\n\t\tcur.h=M[r][i],cur.pos=i;\n\t\tif(S.empty()) S.push(cur);\n\t\telse if(S.top().h<cur.h) S.push(cur);\n\t\telse if(S.top().h>cur.h){\n\t\t\trect l;\n\t\t\tint left;\n\t\t\twhile(!S.empty()&&S.top().h>=cur.h){\n\t\t\t\tl=S.top();S.pop();\n\t\t\t\tleft=l.pos;\n\t\t\t\tint s=l.h*(cur.pos-l.pos);\n\t\t\t\tans=max(ans,s);\n\t\t\t}\n\t\t\tcur.pos=left;\n\t\t\tS.push(cur);\n\t\t}\n\t}\n\treturn ans;\n}\nvoid pre(){\n\tfor(int i=0;i<=w;i++) M[0][i]=0;\n\tfor(int i=1;i<=h;i++) M[i][w]=0;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(M[i][j]) M[i][j]=0;\n\t\t\telse M[i][j]=M[i-1][j]+1;\n\t\t}\n\t}\n}\nint main(){\n\tint ans=0;\n\tscanf(\"%d%d\",&h,&w);\n\tfor(int i=1;i<=h;i++) for(int j=0;j<w;j++) scanf(\"%d\",&M[i][j]);\n\tpre();\n\tfor(int i=1;i<=h;i++) ans=max(ans,maxrect(i));\n\tprintf(\"%d\\n\",ans);\n//\tfor(int i=1;i<=h;i++){\n//\t\tfor(int j=1;j<=w;j++) printf(\"%d \",M[i][j]);\n//\t\tprintf(\"\\n\");\n//\t}\n} \n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node\n{\n    int x,y;\n};\nstack<node> d;\n#define mo 1500\nint a[mo][mo];\nint main()\n{\n    int n,m;\n    while(cin>>n>>m)\n    {\n        int x;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=m;j++)\n            {\n                cin>>x;\n                if(!x)\n                    a[i][j]+=a[i-1][j]+1;\n\n            }\n        }\n\n        /*\n        cout<<endl;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=m;j++)\n            {\n                cout<<a[i][j]<<' ';\n            }\n            cout<<endl;\n        }\n        */\n\n\n        node t;\n        int maxs=0;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=m+1;j++)\n            {\n                t.x=a[i][j];\n                t.y=j;\n\n                if(d.size()==0||t.x>d.top().x) d.push(t);\n                else if(t.x<d.top().x)\n                {\n                    int l=j;\n                    while(d.size()&&d.top().x>t.x)\n                    {\n                        maxs=max(maxs,(l-d.top().y)*d.top().x);\n                        t.y=d.top().y;\n                        d.pop();\n                    }\n                    if(j<=m)d.push(t);\n                }\n            }\n\n        }\n        cout<<maxs<<endl;\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstring>\n#include <stack>\nusing namespace std;\n\nconst int Max = 1500;\nstruct Node\n{\n    int height, pos;\n};\nint H, W;\nint G[Max][Max], T[Max][Max];\n\nint main()\n{\n    cin >> H >> W;\n    for(int i=0; i<H; i++)\n    {\n        for(int j=0; j<W; j++)\n        {\n            cin >> G[i][j];\n        }\n    }\n    //标记\n    for(int j=0; j<W; j++)\n    {\n        for(int i=0; i<H; i++)\n        {\n            if(G[i][j])\n            {\n               T[i][j] = 0;\n            }\n            else\n            {\n                if(i==0)\n                    T[i][j] = 1;\n                else\n                    T[i][j] = T[i-1][j]+1;\n            }\n            //cout << T[i][j] << \" \";\n        }\n       // cout << endl;\n    }\n\n    //栈式动态规划\n    stack<Node> S;\n    int maxv = 0, area = 0;\n    for(int i=0; i<H; i++)\n    {\n        T[i][W] = 0;\n        for(int j=0; j<=W; j++)\n        {\n            Node rect;\n            rect.height = T[i][j];\n            rect.pos = j;\n            if(S.empty())\n                S.push(rect);\n            else\n            {\n                if(S.top().height<rect.height)\n                {\n                    S.push(rect);\n                }\n                else if(S.top().height>rect.height)\n                {\n                    int target = j;\n                    while(!S.empty() && S.top().height>=rect.height)\n                    {\n                        Node pre = S.top(); S.pop();\n                        area = (j-pre.pos)*pre.height;\n                        maxv = max(maxv, area);\n                        target = pre.pos;\n                    }\n                    rect.pos = target;\n                    S.push(rect);\n                }\n            }\n        }\n    }\n    cout << maxv << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint grd[2000][2000];\nint main(){\n\tint h,w;\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++)\tcin>>grd[i][j];\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(grd[i][j]==1)\tgrd[i][j]=0;\n\t\t\telse if(i==0)\tgrd[i][j]=1;\n\t\t\telse \tgrd[i][j]=grd[i-1][j]+1;\n\t\t}\n\t}\n\t/*for(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++)\tcout<<grd[i][j]<<\" \";\n\t\tcout<<endl;\n\t}*/\n\tint ans=0;\n\tfor(int i=0;i<h;i++){\n\t\tstack<pair<int,int>> s;\n\t\ts.push(make_pair(-1,-1));\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(grd[i][j]>s.top().first){\n\t\t\t\ts.push(make_pair(grd[i][j],j));\n\t\t\t\t//cout<<\"push:\"<<grd[i][j]<<\" \"<<j<<endl;\n\t\t\t}\n\t\t\telse if(grd[i][j]==s.top().first){\n\t\t\t\ts.pop();\n\t\t\t\ts.push(make_pair(grd[i][j],j));\n\t\t\t\t//cout<<\"push:\"<<grd[i][j]<<\" \"<<j<<endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(s.top().first>grd[i][j]){\n\t\t\t\t\tint hh=s.top().first;\n\t\t\t\t\twhile(hh<=s.top().first)\ts.pop();\n\t\t\t\t\tint ww=s.top().second;\n\t\t\t\t\tans=max(ans,hh*(j-ww-1));\n\t\t\t\t\ts.push(make_pair(s.top().first,j-1));\n\t\t\t\t\t//cout<<\"change:\"<<hh<<\" \"<<(j-ww-1)<<endl;\n\t\t\t\t\t//cout<<\"push:\"<<s.top().first<<\" \"<<j-1<<endl;\n\t\t\t\t}\n\t\t\t\ts.push(make_pair(grd[i][j],j));\n\t\t\t\t//cout<<\"push:\"<<grd[i][j]<<\" \"<<j<<endl;\n\t\t\t}\n\t\t}\n\t\twhile(s.top().first>0){\n\t\t\tint hh=s.top().first,we=s.top().second;\n\t\t\twhile(hh<=s.top().first)\ts.pop();\n\t\t\tint ws=s.top().second;\n\t\t\tans=max(ans,hh*(we-ws));\n\t\t\tint sf=s.top().first;\ts.pop();\n\t\t\ts.push(make_pair(sf,we));\n\t\t\t//cout<<\"change:\"<<hh<<\" \"<<(we-ws)<<endl;\n\t\t\t//cout<<\"push:\"<<sf<<\" \"<<we<<endl;\n\t\t}\n\t\t//cout<<\"end col:\"<<i<<endl;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<stack>\nusing namespace std;\nint H,W;\nint G[2000][2000];\nint T[2000][2000];\nstruct ang{\n\tint height,pos;\n};\nint f(int a[]){\n\tstack < ang > S;\n\tint maxn=0;\n\tfor(int i=0;i<W;i++){\n\t\tang rect;\n\t\trect.height=a[i];\n\t\trect.pos=i;\n\t\ta[W]=0;\n\t\tif(S.empty()){\n\t\t\tS.push(rect);\n\t\t}\n\t\telse {\n\t\t\tif(S.top().height<rect.height) S.push(rect);\n\t\t\telse if(S.top().height>rect.height){\n\t\t\t\tint pre=i;\n\t\t\t\twhile(!S.empty()&&S.top().height>=rect.height){\n\t\t\t\t\tang k=S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tint area=k.height*(i-k.pos);\n\t\t\t\t\tmaxn=max(maxn,area);\n\t\t\t\t\tpre=k.pos;\n\t\t\t\t}\n\t\t\t\trect.pos=pre;S.push(rect);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\treturn maxn;\n}\nint main(){\n\tscanf(\"%d%d\",&H,&W);\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tscanf(\"%d\",&G[i][j]);\n\t\t}\n\t}\n\tfor(int j=0;j<W;j++){\n\t\tfor(int i=0;i<H;i++){\n\t\t\tif(G[i][j]) T[i][j]=0;\n\t\t\telse T[i][j]=i>0?T[i-1][j]+1:1;\n\t\t}\n\t}\n\tint maxn=0;\n\tfor(int i=0;i<H;i++){\n\t\tmaxn=max(maxn,f(T[i]));\n\t}\n\tprintf(\"%d\\n\",maxn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int H, W;\n  cin >> H >> W;\n  \n  VVI xs(H, VI(W));\n  cin >> xs;\n  REP(y,H) REP(x,W){\n\txs[y][x] ^= 1;\n\tif(xs[y][x]) xs[y][x] += (y>0? xs[y-1][x]: 0);\n  }\n\n  int ans = 0;\n  REP(y,H){\n\tstack<PII> s;\n\tREP(x,W){\n\t  int lx = x;\n\t  while(!s.empty() && s.top().FF > xs[y][x]){\n\t\tmaxi(ans, s.top().FF*(x-s.top().SS));\n\t\tlx = min(lx,s.top().SS);\n\t\ts.pop();\n\t  }\n\t  if(xs[y][x]) s.emplace(xs[y][x], lx);\n\t}\n\twhile(!s.empty()){\n\t  maxi(ans, s.top().FF*(W-s.top().SS));\n\t  s.pop();\n\t}\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint dp[1400][1401];\n\nsize_t get_largest_rectangle(vector<vector<int>> &g) {\n    size_t h=g.size(), w=g[0].size();\n\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j)\n            dp[i][j] = !g[i][j];\n\n    for (size_t i=1; i<h; ++i)\n        for (size_t j=0; j<w; ++j)\n            if (dp[i][j])\n                dp[i][j] += dp[i-1][j];\n\n    size_t max_area=0;\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j) {\n            if (!dp[i][j]) continue;\n\n            int min_height=dp[i][j];\n            for (size_t k=j+1; k<=w; ++k) {\n                if (max_area < (k-j)*min_height)\n                    max_area = (k-j)*min_height;\n\n                if (!dp[i][k])\n                    break;\n\n                if (min_height > dp[i][k])\n                    min_height = dp[i][k];\n            }\n        }\n\n    return max_area;\n}\n\nint main() {\n    size_t h, w;\n    scanf(\"%zu %zu\", &h, &w);\n\n    vector<vector<int>> g(h, vector<int>(w));\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j)\n            scanf(\"%d\", &g[i][j]);\n\n    printf(\"%zu\\n\", get_largest_rectangle(g));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<stack>\nusing namespace std;\nint H,W;\nint G[2000][2000];\nint T[2000][2000];\nstruct ang{\n\tint height,pos;\n};\nint f(int a[]){\n\tstack < ang > S;\n\tint maxn=0;\n\tfor(int i=0;i<W;i++){\n\t\tang rect;\n\t\trect.height=a[i];\n\t\trect.pos=i;\n\t\tif(S.empty()){\n\t\t\tS.push(rect);\n\t\t}\n\t\telse {\n\t\t\tif(S.top().height<rect.height) S.push(rect);\n\t\t\telse if(S.top().height>rect.height){\n\t\t\t\tint pre=i;\n\t\t\t\twhile(!S.empty()&&S.top().height>=rect.height){\n\t\t\t\t\tang k=S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tint area=k.height*(i-k.pos);\n\t\t\t\t\tmaxn=max(maxn,area);\n\t\t\t\t\tpre=k.pos;\n\t\t\t\t}\n\t\t\t\trect.pos=pre;S.push(rect);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\treturn maxn;\n}\nint main(){\n\tscanf(\"%d%d\",&H,&W);\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tscanf(\"%d\",&G[i][j]);\n\t\t}\n\t}\n\tfor(int j=0;j<W;j++){\n\t\tfor(int i=0;i<H;i++){\n\t\t\tif(G[i][j]) T[i][j]=0;\n\t\t\telse T[i][j]=i>0?T[i-1][j]+1:1;\n\t\t}\n\t}\n\tint maxn=0;\n\tfor(int i=0;i<H;i++){\n\t\tmaxn=max(maxn,f(T[i]));\n\t}\n\tprintf(\"%d\\n\",maxn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n#define fi first\n#define se second\nint h,w,a[1501][1501],ls,s[1501][1501];\nmain(){\n\twhile(cin>>h>>w,h){\n\t\tr(i,h)r(j,w)cin>>s[i][j];\n\t\tmemset(a,0,sizeof(a));\n\t\tr(i,h)r(j,w){\n\t\t\tif(!i&&!s[i][j])a[i][j]++;\n\t\t\tif(i&&!s[i][j])a[i][j]=a[i-1][j]+1;\n\t\t}\n\t\tint ans=0;\n\t\tr(i,h){\n\t\t\tstack<P>st;\n\t\t\tr(j,w+1){\n\t\t\t\tif(st.empty())st.push(P(a[i][j],j));\n\t\t\t\tif(st.top().fi==a[i][j])continue;\n\t\t\t\telse if(st.top().fi<a[i][j])st.push(P(a[i][j],j));\n\t\t\t\telse{\n\t\t\t\t\twhile(!st.empty()&&st.top().fi>a[i][j]){\n\t\t\t\t\t\tans=max(ans,(j-st.top().se)*st.top().fi);\n\t\t\t\t\t\tls=st.top().se;\n\t\t\t\t\t\tst.pop();\n\t\t\t\t\t}\n\t\t\t\t\tst.push(P(a[i][j],ls));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//Largest Rectangle\n#include<bits/stdc++.h>\nusing namespace std;\n\nint H, W;\nint mp[1400][1400];\nint h[1400][1400];\n\n//i?????????????????????????????°??????????????§????????¢?????§??????????±???????\nint max_rect(int i){\n  stack< pair<int, int> > st;\n  int ret=0;\n  for(int j=0; j<W; j++){\n    //?????????????????? ???????????? ???????????????????????????????´????????????????????????????\n    if(st.empty() || st.top().second<h[i][j]){\n      st.push(make_pair(j, h[i][j]));\n      continue;\n    }\n\n    //???????????????????????????????´????????????????????????????\n    if(st.top().second>h[i][j]){\n      int most_left=j;\n      while(!st.empty() && st.top().second>=h[i][j]){\n\tpair<int, int> tmp = st.top();\n\tst.pop();\n\tret=max(ret, (tmp.second * (j-tmp.first))); //??¢????¨????\n\tmost_left=tmp.first; //???????????´?????????x??§?¨??????????\n      }\n      st.push(make_pair(most_left, h[i][j]));\n    }\n  }\n\n  while(!st.empty()){\n    pair<int, int> tmp=st.top();\n    st.pop();\n\n    ret=max(ret, (W-tmp.first)*tmp.second);\n  }\n\n  return ret;\n}\n\nint main(){\n  cin>>H>>W;\n  for(int i=0; i<H; i++)\n    for(int j=0; j<W; j++)\n      cin>>mp[i][j];\n\n  //???????????????????????¨??????????????????????±???????\n  //1??????\n  for(int i=0; i<W; i++){\n    if(mp[0][i] == 1){h[0][i] = 0;}\n    else{h[0][i] = 1;}\n  }\n  //2????????\\???\n  for(int i=1; i<H; i++){\n    for(int j=0; j<W; j++){\n      if(mp[i][j]==1){h[i][j] = 0;}\n      else{h[i][j] = h[i-1][j]+1;}\n    }\n  }\n\n  int ans=0;\n  for(int i=0; i<H; i++){\n    ans=max(ans, max_rect(i));\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n\nstatic const int MAX_N = 1400;\n\nstruct Rectangle {\n    int height;\n    int left;\n};\n\nint H, W;\nint masu[MAX_N][MAX_N];\nint dp[MAX_N][MAX_N];\n\nint getLargestRectangle(int h) {\n    stack<Rectangle> S;\n    int maxArea = 0;\n\n    for (int j = 0; j < W; j++) {\n        Rectangle rect;\n        rect.height = masu[h][j];\n        rect.left = j;\n\n        if (S.empty() || S.top().height < rect.height) {\n            S.push(rect);\n        } else if (S.top().height > rect.height) {\n            int target = j;\n\n            while (!S.empty() && S.top().height >= rect.height) {\n                Rectangle pre = S.top(); S.pop();\n                int area = pre.height * (j - pre.left);\n                maxArea = max(maxArea, area);\n                target = pre.left;\n            }\n\n            rect.left = target;\n            S.push(rect);\n        }\n    }\n    return maxArea;\n}\n\nint main(void) {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            scanf(\"%d\", &masu[i][j]);\n        }\n    }\n\n    for (int j = 0; j < W; j++) {\n        masu[0][j] = (masu[0][j] + 1) % 2;\n    }\n    for (int i = 1; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            if (masu[i][j] == 0) {\n                masu[i][j] = masu[i-1][j] + 1;\n            } else {\n                masu[i][j] = 0;\n            }\n        }\n    }\n\n    int ans = 0;\n    for (int i = 0; i < H; i++) {\n        ans = max(ans, getLargestRectangle(i));\n    }\n\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// C++ 14\n#include <iostream>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <math.h>\n\n#define ll long long\n#define Int int\n#define loop(x, start, end) for(Int x = start; x < end; x++)\n#define loopdown(x, start, end) for(int x = start; x > end; x--)\n#define span(a,x,y) a.begin()+x,a.begin()+y\n#define span_all(a) a.begin(),a.end()\n#define len(x) (x.size())\n#define last(x) (*(x.end()-1))\n\nusing namespace std;\n\n#define MAX_H 1401\n#define MAX_W 1401\n\nInt H, W;\nbool C[MAX_H][MAX_W];\nInt HIST[MAX_H][MAX_W];\n\nvoid input() {\n  cin >> H >> W;\n  loop(h,0,H) {\n    loop(w,0,W) {\n      cin >> C[h][w];\n    }\n  }\n}\n\n// O(N)\nInt max_hist(Int hist[]) {\n  stack<Int> S;\n  Int max_ = 0, area = 0, tp = -1, width = 0;\n\n  loop (i,0,W) {\n    Int height = hist[i];\n\n    // Pop every bar which is higher than me and calculate area for each of them.\n    while (!S.empty() && hist[S.top()] > height) {\n      tp = S.top();S.pop();\n\n      width = S.empty() ? i : i - S.top() - 1;\n      area = hist[tp] * width;\n      if (max_ < area) max_ = area;\n    }\n\n    // Now bars are sorted in ascending order (greater or equal)\n    S.push(i);\n  }\n\n  Int maxWidth = W;\n  while (!S.empty()) {\n    tp = S.top();S.pop();\n\n    width = S.empty() ? maxWidth : maxWidth - S.top() - 1;\n    area = hist[tp] * width;\n    if (max_ < area) max_ = area;\n  }\n\n  return max_;\n}\n\nvoid solve() {\n  loop(w,0,W) {\n    HIST[0][w] = C[0][w] ? 0 : 1;\n  }\n\n  loop(w,0,W) {\n    loop(h,1,H) {\n      HIST[h][w] = C[h][w] ? 0 : HIST[h-1][w] + 1;\n    }\n  }\n\n  Int max_ = 0;\n  loop(h,0,H) {\n    max_ = max(max_, max_hist(HIST[h]));\n  }\n\n  cout << max_ << endl;\n}\n\nint main(void) {\n  input();\n  solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nstruct rect {\n    int pos, height;\n};\n\nint main() {\n\n    int H, W;\n    cin >> H >> W;\n\n    int T[H][W];\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int c;\n            cin >> c;\n            if (i == 0) {\n                T[i][j] = (c ? 0 : 1);\n            } else {\n                T[i][j] = (c ? 0 : T[i - 1][j] + 1);\n            }\n        }\n    }\n\n    //solve\n    int ans = 0;\n\n    for (int i = 0; i < H; i++) {\n        stack<rect> stk;\n        for (int j = 0; j < W; j++) {\n            int pos, height;\n            pos = j, height = T[i][j];\n            if (stk.empty() || stk.top().height < height) {\n                stk.push((rect) {pos, height});\n            } else if (stk.top().height > height) {\n                while (!stk.empty() && stk.top().height >= height) {\n                    rect pre = stk.top();\n                    stk.pop();\n                    ans = max(ans, pre.height * (j - pre.pos));\n                    pos = pre.pos;\n                }\n                stk.push((rect) {pos, height});\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<algorithm>\n#define fi first\n#define se second\nusing namespace std;\nconst int M=1400;\nint h,w;\nint T[M][M+1];\nint get(int size)\n{\n\tstack<pair<int,int>>s;\n\tint maxv=0;\n\tpair<int,int>r,p;\n\tint t;\n\t\n\tfor(int i=0;i<=w;i++)\n\t{\n\t\tr.fi=T[size][i];\n\t\tr.se=i;\n\t\tif(s.empty())s.push(r);\n\t\telse\n\t\t{\n\t\t\tif(s.top().fi<r.fi)s.push(r);\n\t\t\telse if(s.top().fi>r.fi)\n\t\t\t{\n\t\t\t\tt=i;\n\t\t\t\twhile(!s.empty()&&s.top().fi>r.fi)\n\t\t\t\t{\n\t\t\t\t\tp=s.top();s.pop();\n\t\t\t\t\tmaxv=max(maxv,p.fi*(i-p.se));\n\t\t\t\t\tt=p.se;\n\t\t\t\t}\n\t\t\t\tr.se=t;\n\t\t\t\ts.push(r);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxv;\n}\n\nint main()\n{\n\tcin>>h>>w;\n\tint c[M][M];\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tcin>>c[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tT[i][j]=(c[i][j]?0:i>0?T[i-1][j]+1:1);\n\t\t}\n\t\tT[i][w]=0;\n\t}\n\tint maxv=0;\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tmaxv=max(maxv,get(i));\n\t}\n\tcout<<maxv<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define REP(i, s, n) for(signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\n\n#ifdef int\nconst long long INF = 1ll << 62ll;\n#else\nconst singed INF = 1 << 29;\n#endif\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nsigned main()\n{\n\tint h, w;\n\twhile (cin >> h >> w && h)\n\t{\n\t\tauto dp = vvector(h, w + 1);\n\t\tint ans = 0;\n\t\trep(i, h)\n\t\t{\n\t\t\tstack<P> st;\n\t\t\tst.push(P(0, 0));\n\t\t\trep(j, w + 1)\n\t\t\t{\n\t\t\t\tint x = 1;\n\t\t\t\tif (j < w) cin >> x;\n\n\t\t\t\tif (!x) dp[i][j] = 1;\n\t\t\t\tif (i >= 1 && dp[i - 1][j] && !x)\n\t\t\t\t\tdp[i][j] = dp[i - 1][j] + 1;\n\n\t\t\t\tint size = dp[i][j];\n\t\t\t\tif (size == st.top().first) continue;\n\t\t\t\telse if (size > st.top().first) st.push(P(size, j));\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint beg = j;\n\t\t\t\t\twhile (!st.empty() && st.top().first > size)\n\t\t\t\t\t{\n\t\t\t\t\t\tP p = st.top(); st.pop();\n\t\t\t\t\t\tans = max(ans, (j - p.second) * p.first);\n\t\t\t\t\t\tbeg = p.second;\n\t\t\t\t\t}\n\t\t\t\t\tif (st.top().first == size) \n\t\t\t\t\t\tans = max(ans, (j - st.top().second + 1) * st.top().first);\n\t\t\t\t\telse st.push(P(size, beg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <unordered_map>\nconstexpr int MOD = 1000000000 + 7;\nconstexpr int INF = 2000000000;\nusing namespace std;\nusing LL = long long;\n\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectangle(int size, int buffer[]) {\n\tstack<Rectangle> S;\n\tint maxv = 0;\n\tbuffer[size] = 0;\n\tfor (int i = 0; i <= size; i++) {\n\t\tRectangle rect;\n\t\trect.height = buffer[i];\n\t\trect.pos = i;\n\t\tif (S.empty()) {\n\t\t\tS.push(rect);\n\t\t}\n\t\telse {\n\t\t\tif (S.top().height < rect.height)S.push(rect);\n\t\t\telse if (S.top().height > rect.height) {\n\t\t\t\tint target = i;\n\t\t\t\twhile (!S.empty() && S.top().height >= rect.height) {\n\t\t\t\t\tRectangle pre = S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tint area = pre.height*(i - pre.pos);\n\t\t\t\t\tmaxv = max(maxv, area);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos = target;\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxv;\n}\n\nint H, W;\nint Buffer[1400][1400];\nint T[1400][1400];\n\nint getLargestRectangle() {\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (Buffer[i][j]) {\n\t\t\t\tT[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tT[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n\t\t\t}\n\t\t}\n\t}\n\tint maxv = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tmaxv = max(maxv, getLargestRectangle(W, T[i]));\n\t}\n\treturn maxv;\n}\n\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> Buffer[i][j];\n\t\t}\n\t}\n\tcout << getLargestRectangle() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<utility>\n#include<string>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<map>\n#include<climits>\n#include<set>\n#include<tuple>\n#include<stack>\n\n\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\ntypedef pair<ll, ll> pll;\ntypedef tuple<int, int, int> tpl;\nint dx[4] = { 1,0,0,-1 };\nint dy[4] = { 0,1,-1,0 };\n\n#define ARRAY_MAX 1500\n\nconst int INF = 1 << 30;\nconst int MOD = 1e9 + 7;\n\ntemplate<typename T>\nT histArea(vector<T>& h) {\n\n\tT N = h.size();\n\th.push_back(0);\n\tN++;\n\n\tT ans = 0;\n\tstack<pii> st;\n\n\tfor (T i = 0; i < N; i++)\n\t{\n\t\tif (st.empty())\n\t\t{\n\t\t\t//スタックが空の場合は長方形を追加\n\t\t\tst.push(pii(h[i], i));\n\t\t}\n\t\telse if (st.top().first < h[i])\n\t\t{\n\t\t\t//今見ている長方形がスタックの頂点の長方形の高さより高い場合はスタックに追加\n\t\t\tst.push(pii(h[i], i));\n\t\t}\n\t\telse if (st.top().first > h[i])\n\t\t{\n\t\t\t//今見ている長方形がスタックの頂点の長方形の高さより低い場合はスタックから取り出す作業を行う\n\t\t\tint lastpos = 0;\n\n\t\t\twhile (!st.empty() && st.top().first >= h[i]) {\n\t\t\t\t//スタックが空でなく、スタックの頂点にある長方形の高さが今見ている長方形の高さ以上\n\t\t\t\t//の場合はスタックから長方形を取り出してその都度面積を計算して最大値を更新する\n\t\t\t\tlastpos = st.top().second;\n\t\t\t\tans = max(ans, st.top().first * (i - lastpos));\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\t//取り出す作業が終わったら今見ている長方形をスタックに追加する\n\t\t\t//追加位置は最後に取り出した長方形の位置\n\t\t\tst.push(pii(h[i], lastpos));\n\t\t}\n\t}\n\treturn ans;\n}\n\ntemplate<typename T>\nT maxRectangle(vector< vector<T> >& board) {\n\tT H = board.size(), W = board[0].size();\n\tvector< vector<T> > dp(H, vector<T>(W, 0));\n\n\tT ret = 0;\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tif (board[i][j] == 1) continue;\n\t\t\tif (i > 0)\n\t\t\t{\n\t\t\t\tdp[i][j] = dp[i - 1][j] + 1;//縦の長さを保持\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdp[i][j] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tret = max(ret, histArea(dp[i]));\n\t}\n\treturn ret;\n}\n\n\nint main() {\n\n\tint h, w;\n\tcin >> h >> w;\n\tvector<vector<int> > mp(h, vector<int>(w, 0));\n\tfor (int i = 0; i < h; i++)\n\t{\n\t\tfor (int j = 0; j < w; j++)\n\t\t{\n\t\t\tcin >> mp[i][j];\n\t\t}\n\t}\n\n\tcout << maxRectangle(mp) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nlong long h, w;\nvector<vector<long long>> c;\n\nlong long solve();\nlong long calc(vector<long long>& a);\n\nint main() {\n  cin >> h >> w;\n  c.assign(h, vector<long long>(w, 0));\n  for (int i = 0; i < h; ++i)\n    for (int j = 0; j < w; ++j) {\n      cin >> c[i][j];\n      c[i][j] = 1 - c[i][j];\n      if (i != 0 && c[i][j]) c[i][j] += c[i - 1][j];\n    }\n  cout << solve() << endl;\n  return 0;\n}\n\nlong long solve() {\n  long long res = 0;\n  for (int i = 0; i < h; ++i) res = max(res, calc(c[i]));\n  return res;\n}\n\nlong long calc(vector<long long>& a) {\n  stack<long long> len, id;\n  len.push(0);\n  a.push_back(0);\n  long long res = 0, n = a.size();\n  for (int i = 0; i < n; ++i) {\n    int nextid = i;\n    while (a[i] < len.top()) {\n      nextid = id.top();\n      res = max(res, len.top() * (i - id.top()));\n      len.pop();\n      id.pop();\n    }\n    if (a[i] > len.top()) {\n      len.push(a[i]);\n      id.push(nextid);\n    }\n  }\n  return res;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < n; i++)\n#define ll long long\n#define endl '\\n'\nusing namespace std;\n#define MAX 1400\n\nstruct Rectangle {\n    int height;\n    int pos;\n};\n\nint getLargestRectangle(int size, int buffer[]) {\n    // 行ごとに計算する\n    stack<Rectangle> S;\n    int maxv = 0;\n    buffer[size] = 0;\n\n    for (int i = 0; i <= size; i++) {\n        Rectangle rect;  // まだ拡張される可能性のある長方形\n        rect.height = buffer[i]; // 長方形の高さ\n        rect.pos = i; // 左端の位置\n        // Sが空->rectを入れる\n        // Sが空でない->(Sの上の高さ < rectの高さ)->Sにpush\n        // Sが空でない->(Sの上の高さ > rectの高さ)->Sにpush\n        if (S.empty()) {\n            S.push(rect);\n        } else {\n            if (S.top().height < rect.height) { // stackの上にある長方形の方がbufferの長方形の高さよりも低い時\n                S.push(rect);\n            } else if (S.top().height > rect.height) {\n                int target = i; // targetをiとする\n                // 一番heightが高くなるpreのposをtargetとする\n                while (!S.empty() && S.top().height >= rect.height) { // stackに貯まっていて，Sの上にあるものの高さよりrectの高さが高い\n                    Rectangle pre = S.top(); // stackの上のものをpreとする\n                    S.pop(); // stackの上のものを取り出す\n                    int area = pre.height * (i - pre.pos); // preの高さ * (現在の位置 - preの位置)\n                    maxv = max(maxv, area); // maxvとareaの最大値を比べて高い方をmaxvを入れる\n                    target = pre.pos; // targetを左端とする\n                }\n                rect.pos = target; // 拡張される可能性のある長方形の左端をtargetとする\n                S.push(rect);\n            }\n        }\n    }\n    return maxv;\n}\n\nint H, W;\nint buffer[MAX][MAX]; // 入力のタイル\nint T[MAX][MAX]; // 入力から作るタイル\n\nint getLargestRectangle() {\n    for (int j = 0; j < W; j++) {\n        for (int i = 0; i < H; i++) {\n            if (buffer[i][j]) { // もしbufferに1が入っていれば\n                T[i][j] = 0; // T[i][j]は0\n            } else { // もしbufferに0が入っている時\n                T[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1; // iが0より大きい時， T[i][j] = 上の行の同じ列の値+1\n            }\n        }\n    }\n\n    int maxv = 0;\n    for (int i = 0; i < H; i++) {\n        maxv = max(maxv, getLargestRectangle(W, T[i]));\n    }\n    return maxv;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            scanf(\"%d\", &buffer[i][j]); // i行j列目の要素をbufferに入れる\n        }\n    }\n    cout << getLargestRectangle() << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<ctime>\nusing namespace std;\n\ntypedef long long ll;\nbool debug = false;\nconst int NIL = -1;\nconst int INF = 1000000000;\nconst int NUM = 1410;\nclock_t START, END;\nint G[NUM][NUM];\n\nstruct rect {\n\tint height, pos;\n};\n\nint main(void)\n{\n\tif (debug) {\n\t\tSTART = clock();\n\t\tfreopen(\"in29.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t};\n\tint H, W, t, maxArea = 0;\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> t;\n\t\t\tif (i == 0) {\n\t\t\t\tif (t)\n\t\t\t\t\tG[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tG[i][j] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (t)\n\t\t\t\t\tG[i][j] = 0;\n\t\t\t\telse\n\t\t\t\t\tG[i][j] = G[i - 1][j] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tstack<rect> S;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (S.empty() || S.top().height <= G[i][j]) {\n\t\t\t\tS.push({ G[i][j], j });\n\t\t\t}\n\t\t\telse {\n\t\t\t\tint _pos = W;\n\t\t\t\twhile (!S.empty() && S.top().height > G[i][j]) {\n\t\t\t\t\tmaxArea = max(maxArea, S.top().height * (j - S.top().pos));\n\t\t\t\t\t_pos = min(_pos, S.top().pos);\n\t\t\t\t\tS.pop();\n\t\t\t\t}\n\t\t\t\tS.push({ G[i][j],_pos });\n\t\t\t}\n\t\t}\n\t\twhile (!S.empty()) {\n\t\t\tmaxArea = max(maxArea, S.top().height * (W - S.top().pos));\n\t\t\tS.pop();\n\t\t}\n\t}\n\tcout << maxArea << endl;\n\tif (debug) {\n\t\tEND = clock();\n\t\tdouble endtime = (double)(END - START) / 1000;\n\t\tprintf(\"total time = %lf s\", endtime);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define EPS (1e-10)\n#define rep(i, a, b) for (int i = a; i < (int)(b); ++i)\n#define rrep(i, a, b) for (int i = b - 1; i >= (int)(a); --i)\n\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vd = vector<double>;\nusing vvi = vector<vi>;\n\nconstexpr int MOD = 1000000007;\n\nint get_leargest_rectangle(const vvi& grid) {\n    int h = grid.size(), w = grid[0].size();\n\n    // O(hw)\n    vvi tile(h, vi(w + 1, 0));\n    rep(i, 0, h) {\n        rep(j, 0, w) {\n            if (grid[i][j] == 1) {\n                tile[i][j] = 0;\n            } else {\n                tile[i][j] = (i > 0 ? tile[i - 1][j] + 1 : 1);\n            }\n        }\n    }\n\n    int maxv = 0;\n    rep(i, 0, h) {\n        stack<pair<int, int>> S;\n\n        rep(j, 0, w + 1) {\n            // height, pos\n            pair<int, int> rect = make_pair(tile[i][j], j);\n\n            if (S.empty()) {\n                S.push(rect);\n            } else {\n                if (S.top().first < rect.first) {\n                    S.push(rect);\n                } else if (S.top().first > rect.first) {\n                    int xpos = i;\n                    while (!S.empty() && S.top().first >= rect.first) {\n                        pair<int, int> top = S.top();\n                        S.pop();\n                        xpos = top.second;\n                        maxv = max(maxv, top.first * (rect.second - xpos));\n                    }\n                    rect.second = xpos;\n                    S.push(rect);\n                }\n            }\n        }\n    }\n    return maxv;\n}\n\nint main() {\n    int h, w;\n    scanf(\"%d %d\", &h, &w);\n\n    vvi grid(h, vi(w, 0));\n    rep(i, 0, h) {\n        rep(j, 0, w) { scanf(\"%d\", &grid[i][j]); }\n    }\n\n    cout << get_leargest_rectangle(grid) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <functional>\n#include <sstream>\n#include <string>\n#include <utility>\n#include <map>\n#include <memory>\n#include <set>\n#include <vector>\n#include <deque>\n#include <list>\n#include <stack>\n#include <queue>\n#include <array>\n\nusing namespace std;\n\nclass LRectangle\n{\npublic:\n  int h,w;\n  vector<vector<int>> t;\n  vector<vector<int>> hl;\n  LRectangle(){}\n  LRectangle( int h, int w ) : h(h), w(w), t(h, vector<int>(w)), hl(h, vector<int>(w+1)) {}\n  int solve();\n  int maxrec( vector<int> &v );\n};\n\nint LRectangle::maxrec( vector<int> &v )\n{\n  stack<pair<int,int>> st;\n\n  int vs = v.size();\n  int ret = 0;\n  \n  for ( auto i = 0; i < vs; ++i )\n    {\n      int tidx = i;\n      pair<int,int> stt;\n      \n      while(true)\n        {\n          if ( st.size() == 0 ) break;\n\n          stt = st.top();\n\n          if ( stt.second <= v[i] ) break;\n\n          ret = max( ret, stt.second * (i - stt.first) );\n\n          tidx = stt.first;\n          st.pop();\n        }\n\n      if ( st.size() == 0 )\n        st.push( make_pair( tidx, v[i] ) );\n      else\n        {\n          stt = st.top();\n          if ( stt.second < v[i] )\n            st.push( make_pair( tidx, v[i] ) );\n        }\n    }\n  \n  return ret;\n}\n\nint LRectangle::solve()\n{\n  int ret = 0;\n  \n  for ( auto i = 0; i < w; ++i )\n    {\n      int v = 0;\n      for ( auto j = 0; j < h; ++j )\n        {\n          if ( t[j][i] == 1 )\n            {\n              hl[j][i] = 0;\n              v = 0;\n            }\n          else\n            {\n              hl[j][i] = ++v;\n            }\n        }\n    }\n\n  for ( auto i = 0; i < h; ++i )\n    hl[i][w] = 0;\n\n\n  for ( auto i = 0; i < h; ++i )\n    ret = max( ret, maxrec( hl[i] ) );\n  \n  cout << ret << endl;\n  \n  return 0;\n}\n\nint main()\n{\n  int h, w;\n  cin >> h >> w;\n\n  LRectangle lr( h, w );\n\n  for ( auto i = 0; i < h; ++i )\n    for ( auto j = 0; j < w; ++j )\n      cin >> lr.t[i][j];\n  \n  lr.solve();\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 1405;\n\nint a[MAX_N][MAX_N];\nint t[MAX_N][MAX_N];\ndeque<P> deq;\n\nint main()\n{\n\tint h,w;\n\tcin >> h >> w;\n\tint ans=0;\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t}\n\t}\n\trep(i,h){\n\t\tt[i][w] = 0;\n\t}\n\trep(j,w){\n\t\tt[0][j] = 1^a[0][j];\n\t}\n\tfor(int i=1;i<h;i++){\n\t\trep(j,w){\n\t\t\tif(a[i][j]==0){\n\t\t\t\tt[i][j] = t[i-1][j] + 1;\n\t\t\t}else{\n\t\t\t\tt[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tint pos;\n\trep(i,h){\n\t\trep(j,w+1){\n\t\t\tif(deq.empty()){\n\t\t\t\tdeq.push_back(P(t[i][j],j));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdeque<P>::iterator it = deq.end()-1;\n\t\t\tif((*it).first < t[i][j]){\n\t\t\t\tdeq.push_back(P(t[i][j],j));\n\t\t\t}else if((*it).first > t[i][j]){\n\t\t\t\twhile(!deq.empty() && (*it).first > t[i][j]){\n\t\t\t\t\tint S = (*it).first*(j-(*it).second);\n\t\t\t\t\tpos = (*it).second;\n\t\t\t\t\tans = max(S,ans);\n\t\t\t\t\tdeq.pop_back();\n\t\t\t\t\tit = deq.end()-1;\n\t\t\t\t}\n\t\t\t\tdeq.push_back(P(t[i][j],pos));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main()\n{\n\tint H, W;\n\tcin >> H >> W;\n\n\tvector<vector<int>> map;\n\tfor(int i = 0; i < H; i++)\n\t{\n\t\tvector<int> line;\n\t\tfor(int j = 0; j < W  + 1; j++)\n\t\t{\n\t\t\tif(j == W)\n\t\t\t{\n\t\t\t\tline.push_back(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint state;\n\t\t\tcin >> state;\n\t\t\tline.push_back(state == 0 ? 1 : 0);\n\t\t}\n\t\tmap.push_back(line);\n\t}\n\n\tfor(int i = 0; i < H-1; i++)\n\t{\n\t\tfor(int j = 0; j < W; j++)\n\t\t{\n\t\t\tif(map[i + 1][j] != 0)\n\t\t\t{\n\t\t\t\tmap[i + 1][j] += map[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tint maxValue = 0;\n\tfor(int i = 0; i < H; i++)\n\t{\n\t\tfor(int j = 0; j < W; j++)\n\t\t{\n\t\t\tint minHight = map[i][j];\n\t\t\tif(minHight == 0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int k = j + 1; k < W + 1; k++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(map[i][k] == 0)\n\t\t\t\t{\n\t\t\t\t\tint buf = (k-j) * minHight;\n\t\t\t\t\tmaxValue = maxValue > buf ? maxValue : buf;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tmaxValue = maxValue > (k - j) * minHight ? maxValue : (k - j) * minHight;\n\t\t\t\tminHight = minHight < map[i][k] ? minHight : map[i][k];\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxValue << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define MAX_H 1510\n#define MAX_W 1510\n\nint H,W;\nchar mat[MAX_H][MAX_W];\n\nint maximum_rectangle(){\n  int res = 0,h[MAX_W] = {0};\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      h[j] = (mat[i][j] == '.' ? h[j] + 1 : 0);\n    }\n    stack<pii> st;\n    st.push(pii(0,W));\n    for(int j = 0 ; j <= W ; j++){\n      int k = j;\n      while(h[j] < st.top().first){\n\tk = st.top().second;\n\tres = max(res,st.top().first*(j-k));\n\tst.pop();\n      }\n      if(st.top().first < h[j]){\n\tst.push(pii(h[j],k));\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> H >> W, H){\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n\tcin >> mat[i][j];\n      }\n    }\n    cout << maximum_rectangle() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// C++ program to find maximum rectangular area in linear time\n#include<iostream>\n#include<stack>\n#include <vector>\n\n#define endl '\\n';\nusing namespace std;\ntypedef vector<int> vi;\n\n\n// The main function to find the maximum rectangular area under given\n// histogram with n bars\nint getMaxArea(vi &hist) {\n    // Create an empty stack. The stack holds indexes of hist[] array\n    // The bars stored in stack are always in increasing order of their\n    // heights.\n    int n = hist.size();\n    stack<int> s;\n\n    int max_area = 0; // Initalize max area\n    int tp;  // To store top of stack\n    int area_with_top; // To store area with top bar as the smallest bar\n\n    // Run through all bars of given histogram\n    int i = 0;\n    while (i < n) {\n        // If this bar is higher than the bar on top stack, push it to stack\n        if (s.empty() || hist[s.top()] <= hist[i])\n            s.push(i++);\n\n            // If this bar is lower than top of stack, then calculate area of rectangle\n            // with stack top as the smallest (or minimum height) bar. 'i' is\n            // 'right index' for the top and element before top in stack is 'left index'\n        else {\n            tp = s.top();  // store the top index\n            s.pop();  // pop the top\n\n            // Calculate the area with hist[tp] stack as smallest bar\n            area_with_top = hist[tp] * (s.empty() ? i : i - s.top() - 1);\n\n            // update max area, if needed\n            if (max_area < area_with_top)\n                max_area = area_with_top;\n        }\n    }\n\n    // Now pop the remaining bars from stack and calculate area with every\n    // popped bar as the smallest bar\n    while (s.empty() == false) {\n        tp = s.top();\n        s.pop();\n        area_with_top = hist[tp] * (s.empty() ? i : i - s.top() - 1);\n\n        if (max_area < area_with_top)\n            max_area = area_with_top;\n    }\n\n    return max_area;\n}\n\n// Driver program to test above function\nint main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(NULL);\n\n    int h, w, v, sol = 0;\n    cin >> h >> w;\n    vi hist(w, 1);\n\n    for (int j = 0; j < w; ++j) {\n        cin >> v;\n        if (v == 0) hist[j] = 1;\n        else hist[j] = 0;\n    }\n\n    sol = max(sol, getMaxArea(hist));\n\n    for (int i = 1; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            cin >> v;\n            if (v == 0) {\n                hist[j]++;\n            } else hist[j] = 0;\n        }\n\n        sol = max(sol, getMaxArea(hist));\n    }\n\n    cout << sol << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <sstream>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n#define rrep(i, a) RREP(i, a, 0)\n#define RREP(i, a, b) for(int i = a; i >= b; --i)\n#define repll(i, a) REPLL(i, 0, a)\n#define REPLL(i, a, b) for(ll i = a; i < b; ++i)\n#define rrepll(i, a) RREPLL(i, a, 0)\n#define RREPLL(i, a, b) for(ll i = a; i >= b; --i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<int, P> PP;\nconst double PI = 3.14159265358979323846;\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+18 + 10;\n\nint h, w, ans = 0;\nint map[1401][1401];\n\nint main(){\n\tstd::cin >> h >> w;\n\trep(i, h){\n\t\trep(j, w)std::cin >> map[i][j], map[i][j] = (1 - map[i][j]);\n\t}\n\n\trep(i, w){\n\t\tREP(j, 1, h)map[j][i] = (map[j][i] == 0 ? 0 : map[j - 1][i] + 1);\n\t}\n\n\trep(i, h){\n\t\tint max = 0;\n\t\tstd::stack<P> s;\n\t\trep(j, w){\n\t\t\twhile (s.size() && s.top().first > map[i][j]){\n\t\t\t\tmax = std::max(max, s.top().first * (j - s.top().second));\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\ts.push(P(map[i][j], j));\n\t\t}\n\t\twhile (s.size()){\n\t\t\tmax = std::max(max, s.top().first * (w - s.top().second));\n\t\t\ts.pop();\n\t\t}\n\n\t\tans = std::max(max, ans);\n\t}\n\n\tstd::cout << ans << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n#define fi first\n#define se second\nint h,w,a[1501][1501],ls,s[1501][1501];\nmain(){\n\tcin>>h>>w;\n\t\tr(i,h)r(j,w)cin>>s[i][j];\n\t\tmemset(a,0,sizeof(a));\n\t\tr(i,h)r(j,w){\n\t\t\tif(!i&&!s[i][j])a[i][j]++;\n\t\t\tif(i&&!s[i][j])a[i][j]=a[i-1][j]+1;\n\t\t}\n\t\tint ans=0;\n\t\tr(i,h){\n\t\t\tstack<P>st;\n\t\t\tr(j,w+1){\n\t\t\t\tif(st.empty())st.push(P(a[i][j],j));\n\t\t\t\tif(st.top().fi==a[i][j])continue;\n\t\t\t\telse if(st.top().fi<a[i][j])st.push(P(a[i][j],j));\n\t\t\t\telse{\n\t\t\t\t\twhile(!st.empty()&&st.top().fi>a[i][j]){\n\t\t\t\t\t\tans=max(ans,(j-st.top().se)*st.top().fi);\n\t\t\t\t\t\tls=st.top().se;\n\t\t\t\t\t\tst.pop();\n\t\t\t\t\t}\n\t\t\t\t\tst.push(P(a[i][j],ls));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nstruct rect {\n    int pos, height;\n};\n\nint main() {\n\n    int H, W;\n    cin >> H >> W;\n\n    int T[H][W];\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int c;\n            cin >> c;\n            if (i == 0) {\n                T[i][j] = (c ? 0 : 1);\n            } else {\n                T[i][j] = (c ? 0 : T[i - 1][j] + 1);\n            }\n        }\n    }\n    \n    //solve\n    int ans = 0;\n\n    for (int i = 0; i < W; i++) {\n        stack<rect> stk;\n        for (int j = 0; j < H; j++) {\n            int pos, height;\n            pos = j, height = T[i][j];\n            if (stk.empty() || stk.top().height < height) {\n                stk.push((rect) {pos, height});\n            } else if (stk.top().height > height) {\n                while (!stk.empty() && stk.top().height >= height) {\n                    rect pre = stk.top();\n                    stk.pop();\n                    ans = max(ans, pre.height * (j - pre.pos));\n                    pos = pre.pos;\n                }\n                stk.push((rect) {pos, height});\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N =1500;\nint G[N][N];\nint l[N];\nint r[N];\t\t\nint H[N+5];\nint main(){\n\tint h,w;\n\tcin>>h>>w;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++)\n\t\t\tcin>>G[i][j];\n\t}\n\tint max1=0;\n\tfor(int i=1;i<=h;i++){\n\t\tstack<int> S;\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tif(G[i][j])\tH[j]=0;\n\t\t\telse H[j]++;\n\t\t}\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tif(S.empty()||H[S.top()]<=H[j]){\n\t\t\t\tif(S.empty()){\n\t\t\t\t\tS.push(j);\n\t\t\t\t\tl[j]=0; \n\t\t\t\t} \n\t\t\t\telse{\n\t\t\t\t\tl[j]=S.top();\n\t\t\t\t\tS.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(H[S.top()]>H[j]){\n\t\t\t\t\tr[S.top()]=j;\n\t\t\t\t\tS.pop();\n\t\t\t\t\tif(S.empty()) break;\n\t\t\t\t}\n\t\t\t\tif(S.empty()){\n\t\t\t\t\tS.push(j);\n\t\t\t\t\tl[j]=0; \n\t\t\t\t} \n\t\t\t\telse{\n\t\t\t\t\tl[j]=S.top();\n\t\t\t\t\tS.push(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile(!S.empty()){\n\t\t\tr[S.top()]=w+1;\n\t\t\tS.pop();\n\t\t}\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tmax1=max(max1,(r[j]-l[j]-1)*H[j]);\n\t\t}\n\t}\n\tcout<<max1<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint H, W;\n\n// ?????? N ??????????????°?????????????????¢???????????§\n// Verified: AOJ DPL_3_C: Largest Rectangle in a Histogram\nint histArea(vector<int> h) {\n    // ??????\n    int N = h.size();\n    h.push_back(0); N++;\n\n    // height, position\n    int ans = 0;\n    stack<pii> S;\n    rep(i,0,N+1) {\n        if(S.empty()) S.push(pii(h[i], i));\n\n        if     (S.top().first < h[i])\n            S.push(pii(h[i], i));\n        else if(S.top().first > h[i]) {\n            int lastpos = 0;\n            while(!S.empty() && S.top().first >= h[i]) {\n                lastpos = S.top().second;\n                chmax(ans, S.top().first * (i-lastpos));\n                S.pop();\n            }\n            S.push(pii(h[i], lastpos));\n        }\n    }\n    return ans;\n}\n\n// ?????§????????¢??????\n// 0 -> ?¶??????????????????? 1 -> ?±??????????????????????\nint maxRectangle(vector< vector<int> > board) {\n    int H = board.size(), W = board[0].size();\n    vector< vector<int> > sum(H, vector<int>(W));\n    rep(i,0,H) rep(j,0,W) {\n        if(board[i][j] == 1) continue;\n        if(i > 0) sum[i][j] = sum[i-1][j] + 1;\n    }\n    int ret = 0;\n    rep(i,0,H) chmax(ret, histArea(sum[i]));\n    return ret;\n}\n\nsigned main() {\n    cin >> H >> W;\n    vector< vector<int> > board(H, vector<int>(W));\n    rep(i,0,H) rep(j,0,W) cin >> board[i][j];\n    cout << maxRectangle(board) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\nusing namespace std;\nconst int M = 1500;\n\nstruct Rectangle {int hei, pos;};\nint a[M][M];\nint t[M][M];\n\nint GetMax(int w, int buffer[])\n{\n\tstack<Rectangle> s;\n\tbuffer[w] = 0;\n\tint maxs = 0;\t\n\t\n\tfor (int i = 0; i <= w; ++i)\n\t{\n\t\tRectangle cur;\n\t\tcur.hei = buffer[i];\n\t\tcur.pos = i;\n\t\t\n\t\tif (s.empty()) s.push(cur);\n\t\telse\n\t\t{\n\t\t\tif (s.top().hei < cur.hei) s.push(cur);\n\t\t\telse if (s.top().hei > cur.hei)\n\t\t\t{\n\t\t\t\tint tmp = cur.pos;\n\t\t\t\twhile (!s.empty() && s.top().hei >= cur.hei)\n\t\t\t\t{\n\t\t\t\t\tRectangle pre = s.top(); s.pop();\n\t\t\t\t\tint area = pre.hei * (i - pre.pos);\n\t\t\t\t\tmaxs = max(maxs, area);\n\t\t\t\t\ttmp = pre.pos;\n\t\t\t\t}\n\t\t\t\tcur.pos = tmp;\n\t\t\t\ts.push(cur);\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn maxs;\n}\n\nint GetMaxRectangle(int h, int w)\n{\n\tfor (int j = 0; j < w; ++j)\n\t\tfor (int i = 0; i < h; ++i)\n\t\t\tif (a[i][j])\tt[i][j] = 0;\n\t\t\telse t[i][j] = i ? t[i-1][j]+1 : 1;\n\t\t\n\tint maxs = 0;\n\tfor (int i = 0; i < h; ++i)\n\t\tmaxs = max(maxs, GetMax(w, t[i]));\t\n\t\n\treturn maxs;\n}\n\n\nint main()\n{\n\tint h, w;\n\tscanf(\"%d %d\", &h, &w);\n\tfor (int i = 0; i < h; ++i)\n\t\tfor (int j = 0; j < w; ++j)\n\t\t\tscanf(\"%d\", &a[i][j]);\n\t\n\tprintf(\"%d\\n\", GetMaxRectangle(h, w));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int h, w; cin >> h >> w;\n  VV<> c; assign(c, h, w);\n  for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> c[i][j];\n  int res = 0;\n  for (int jl = 0; jl < w; ++jl) {\n    V<> a(h);\n    for (int i = 0; i < h; ++i) {\n      int j = jl;\n      while (j < w and !c[i][j]) ++a[i], ++j;\n    }\n    V<> l(h), r(h);\n    stack<int> st;\n    st.push(0);\n    for (int i = 1; i < h; ++i) {\n      while (!st.empty() and a[st.top()] >= a[i]) st.pop();\n      l[i] = !st.empty() ? a[i] * (i - st.top() - 1) : a[i] * i;\n      st.push(i);\n    }\n    stack<int>().swap(st);\n    st.push(h - 1);\n    for (int i = h - 2; i >= 0; --i) {\n      while (!st.empty() and a[st.top()] >= a[i]) st.pop();\n      r[i] = !st.empty() ? a[i] * (st.top() - 1 - i) : a[i] * (h - 1 - i);\n      st.push(i);\n    }\n    for (int i = 0; i < h; ++i) res = max(res, l[i] + a[i] + r[i]);\n  }\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n\tRectangle rect;\n\tfor(int i=0;i<x;i++){\n\t\tstack<Rectangle> stk;\n\t\tint pop=0;\n\t\tfor(int j=0;j<=y;j++){\n\t\t\trect.height = m[j][i];\n\t\t\trect.pos = j;\n\t\t\tif(stk.empty() || stk.top().height < rect.height){\n\t\t\t\tstk.push(rect);\n\t\t\t}else{\n\t\t\t\t//printf(\"[-] %d %d\\n\",i,j);\n\t\t\t\tint target = j;\n\t\t\t\tfor(;!stk.empty() && stk.top().height >= rect.height;){\n\t\t\t\t\tpop++;\n\t\t\t\t\tRectangle pre = stk.top(); stk.pop();\n\t\t\t\t\tint area = pre.height * (j - pre.pos);\n\t\t\t\t\tr = max(r, area);\n\t\t\t\t\t//printf(\"%d %d\\n\",target,pre.pos);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos = j-pop;//target;\n\t\t\t\tstk.push(rect);\n\t\t\t}\n\t\t\tif(rect.height==0)pop=0;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nstruct Cell {\n\tint pos, height;\n};\n\nint main() {\n\tint H, W;\n\tscanf(\"%d %d\", &H, &W);\n\n\tint A[H][W];\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tscanf(\"%d\", &A[i][j]);\n\t\t}\n\t}\n\tint C[H + 1][W + 1];\n\tfor (int i = 0; i <= H; ++i) {\n\t\tC[i][W] = 0;\n\t}\n\tfor (int i = 0; i <= W; ++i) {\n\t\tC[0][i] = 0;\n\t}\n\n\tfor (int j = 0; j < W; ++j) {\n\t\tfor (int i = 1; i <= H; ++i) {\n\t\t\tif (A[i - 1][j] == 0) {\n\t\t\t\tC[i][j] = C[i - 1][j] + 1;\n\t\t\t} else {\n\t\t\t\tC[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxArea = 0;\n\tfor (int i = 1; i <= H; ++i) {\n\t\tstack<Cell> S;\n\t\tfor (int j = 0; j <= W; ++j) {\n\t\t\tif (S.empty() || S.top().height < C[i][j]) {\n\t\t\t\tCell c;\n\t\t\t\tc.height = C[i][j];\n\t\t\t\tc.pos = j;\n\t\t\t\tS.push(c);\n\t\t\t} else if (S.top().height > C[i][j]) {\n\t\t\t\tint prePos = j;\n\t\t\t\twhile (!S.empty() && S.top().height > C[i][j]) {\n\t\t\t\t\tCell pop = S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tint area = (j - pop.pos) * pop.height;\n\t\t\t\t\tmaxArea = max(maxArea, area);\n\t\t\t\t\tprePos = pop.pos;\n\t\t\t\t}\n\t\t\t\tCell c;\n\t\t\t\tc.height = C[i][j];\n\t\t\t\tc.pos = prePos;\n\t\t\t\tS.push(c);\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxArea << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n#define ll long long\n#define pii pair<int,int>\n#define MAX 1500\n\nint M[MAX][MAX];\nint A[MAX][MAX];\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n,m;\n    cin >> n >> m;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++)cin>>M[i][j];\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(!M[i][j] ){\n                if(i==0)A[i][j]=1;\n                else A[i][j]=A[i-1][j]+1;\n            }\n        }\n    }\n\n    \n    \n\n    int ans=0;\n    for(int i=0;i<n;i++){\n        stack<int> s;\n        for(int j=0;j<m;j++){\n            int cur=A[i][j];\n            while(s.size() && A[i][s.top()]>=cur)s.pop();\n            if(s.size()==0){\n                ans=max(ans,cur*(j+1));\n            }\n            else{\n                ans=max(ans,cur*(j-s.top()));\n            }\n            s.push(j);\n        }\n        while(s.size())s.pop();\n\n        for(int j=m-1;j>=0;j--){\n            int cur=A[i][j];\n            while(s.size() && A[i][s.top()]>=cur)s.pop();\n            if(s.size()==0){\n                ans=max(ans,cur*(m-j));\n            }\n            else{\n                ans=max(ans,cur*( s.top()- j));\n            }\n            s.push(j);\n        }\n\n    }\n\n    cout << ans << '\\n';\n   \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1401\nusing namespace std;\nint mp[N][N];\nint h,w;\n\nstruct dat{int h,i;};\n\nint calc(int A[]){\n  stack <dat> S;\n  int res = 0;\n  for(int i=0;i<=w;i++){\n    int h = A[i];\n    if(S.empty() || S.top().h < h) S.push((dat){h,i});\n    else if(S.top().h > h){\n      int ni = i;\n      while(!S.empty() && S.top().h > h){\n        dat t = S.top(); S.pop();\n        ni = t.i;\n        int area = (i - t.i) * t.h;\n        res = max(res,area);\n      }\n      res = max(res,(i-ni)*h);\n      S.push((dat){h,ni});\n    }\n  }\n  return res;\n}\n\nint main(){\n\n  cin>>h>>w;\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)cin>>mp[i][j],mp[i][j]=!mp[i][j];\n  \n  for(int j=0;j<w;j++)\n    for(int i=1;i<h;i++)if(mp[i][j]) mp[i][j] = mp[i-1][j]+1;\n\n\n  //cout<<endl;for(int i=0;i<h;i++){for(int j=0;j<w;j++)cout<<mp[i][j]<<\" \";cout<<endl;}\n  int ans = 0;\n  for(int i=0;i<h;i++)ans = max(ans,calc(mp[i]));\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nint largestRectangleInHistogram(const vector<int> &h) {\n  int n = h.size();\n  deque<int> s; // stack\n  vector<int> l(n), r(n);\n  rep(i, n) {\n    while (s.size() && h[s.back()] >= h[i]) s.pop_back();\n    l[i] = s.size() ? (s.back() + 1) : 0;\n    s.emplace_back(i);\n  }\n  s.clear();\n  for (int i = n - 1; i >= 0; i--) {\n    while (s.size() && h[s.back()] >= h[i]) s.pop_back();\n    r[i] = s.size() ? s.back() : n;\n    s.emplace_back(i);\n  }\n  int maxi = 0;\n  rep(i, n) cmax(maxi, h[i] * (r[i] - l[i]));\n  return maxi;\n}\n\n// 0: available, 1: unavailable, return: size of square\nint largestRectangle(const vector<vector<int>> &v) {\n  int h = v.size(), w = v[0].size();\n  vector<vector<int>> dp(h, vector<int>(w));\n  rep(j, w) {\n    dp[0][j] = v[0][j] == 0;\n    loop(i, 1, h) dp[i][j] = v[i][j] == 0 ? dp[i - 1][j] + 1 : 0;\n  }\n  int maxi = 0;\n  rep(i, h) cmax(maxi, largestRectangleInHistogram(dp[i]));\n  return maxi;\n}\n\nmain {\n  int h, w;\n  cin >> h >> w;\n  auto v = vectors(h, w, 0LL);\n  cin >> v;\n  cout << largestRectangle(v) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\tvector<vector<int>> a(h, vector<int>(w));\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tcin >> a[i][j];\n\t\t\ta[i][j] = !a[i][j];\n\t\t}\n\t}\n\tfor (int i = 1; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (a[i][j] == 0) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ta[i][j] += a[i - 1][j];\n\t\t}\n\t\ta[i].emplace_back(0);\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tint tmp = 0;\n\t\tstack<pair<int, int>> st;\n\t\tfor (int j = 0; j <= w; j++) {\n\t\t\tif (st.empty() || st.top().first < a[i][j]) {\n\t\t\t\tst.emplace(make_pair(a[i][j], j));\n\t\t\t} else {\n\t\t\t\tif (a[i][j] < st.top().first) {\n\t\t\t\t\tint target = j;\n\t\t\t\t\twhile (!st.empty() && a[i][j] <= st.top().first) {\n\t\t\t\t\t\tint height = st.top().first;\n\t\t\t\t\t\tint pos = st.top().second;\n\t\t\t\t\t\tst.pop();\n\t\t\t\t\t\tint area = height * (j - pos);\n\t\t\t\t\t\ttmp = max(tmp, area);\n\t\t\t\t\t\ttarget = pos;\n\t\t\t\t\t}\n\t\t\t\t\tst.emplace(make_pair(a[i][j], target));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans = max(ans, tmp);\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n\ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a) {\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'[';\n    for(const T &i: a) out<<i<<',';\n    out<<']';\n    return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out, const set<T>& a) {\n    out<<'{';\n    for(const T &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\ntemplate<class T, class S>\nostream &operator <<(ostream& out, const map<T,S>& a) {\n    out<<'{';\n    for(auto &i: a) out<<i<<',';\n    out<<'}';\n    return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\n// i番目の高さがh[i]のヒストグラム中で最大の長方形の面積\nll largest_rectangle_histogram(vector<ll> h) {\n    const ll n = h.size();\n\n    // iを固定して高さがh[i]となる長方形を考えるとl,rは一意に定まる\n    // l[i], r[i] をstackを使って求める\n\n    // l[i] = (j<=iかつh[j-1]<h[i]となる最大のj)\n    vector<ll> l(n);\n    stack<ll> st1;\n    REP(i, n) {\n        while(st1.size() && h[st1.top()] >= h[i]) st1.pop();\n        l[i] = st1.empty() ? 0 : (st1.top()+1);\n        st1.push(i);\n    }\n    // r[i] = (j>iかつh[j]<h[i]となる最小のj)\n    vector<ll> r(n);\n    stack<ll> st2;\n    for(ll i=n-1; i>=0; --i) {\n        while(st2.size() && h[st2.top()] >= h[i]) st2.pop();\n        r[i] = st2.empty() ? n : st2.top();\n        st2.push(i);\n    }\n    ll ret = 0;\n    REP(i, n) ret = max(ret, h[i]*(r[i]-l[i]));\n    return ret;\n}\n\n// c[i][j] = 0 のマスだけを使って構成できる最大の長方形の面積を返す\nll largeest_rectangle(vector<vector<ll>> c) {\n    const int h = c.size(), w = c[0].size();\n    vector<vector<ll>> con(h, vector<ll>(w));\n\n    REP(i, w) {\n        int cnt = 1;\n        REP(j, h) {\n            if(!c[j][i]) {\n                con[j][i] = cnt;\n                cnt++;\n            } else {\n                con[j][i] = 0;\n                cnt = 1;\n            }\n        }\n    }\n\n    ll ret = 0;\n    REP(i, h) chmax(ret, largest_rectangle_histogram(con[i]));\n    return ret;\n}\n\nnamespace DPL3C {\n    void solve() {\n        ll n;\n        cin >> n;\n        vector<ll> h(n);\n        REP(i, n) cin >> h[i];\n\n        cout << largest_rectangle_histogram(h) << endl;\n    }\n}\n\nnamespace DPL3B {\n    void solve() {\n        ll h, w;\n        cin >> h >> w;\n        vector<vector<ll>> c(h, vector<ll>(w));\n        REP(i, h) REP(j, w) cin >> c[i][j];\n\n        cout << largeest_rectangle(c) << endl;\n    }\n}\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // DPL3C::solve();\n    DPL3B::solve();\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <regex>\n#include <cstdio>\n#include <cmath>\n#include <cctype>\n#include <string>\n#include <vector>\n#include <list>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n#include <functional>\n#include <iomanip>\n#include  <cassert>\n#include <fstream>\n#include <codecvt>\n\nusing namespace std;\nusing ll = long long int;\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define FOR(i, a, b)  for(int i = (a); i < (b) ; i++)\n#define pb push_back\n#define SORT(v,n) sort(v, v+n)\n#define ALL(x) (x).begin(),(x).end()\n#define debug(x) cerr << #x << \": \" << x << '\\n'\n#define elif else if\n#define int ll\nconst int INF = (1LL << 32);\nconst int MOD = (int)1e9 + 7;\nconst double EPS = 1e-9;\nint dx[8] = { 1, 0, -1, 0, 1, -1, -1, 1 };\nint dy[8] = { 0, 1, 0, -1, 1, 1, -1, -1 };\n\nstatic const int MAX = 1400;\nstruct Rectangle {\n\tint height;\n\tint pos;\n};\n\nint getLargestRectangle(int size, int buffer[]) {\n\tstack<Rectangle> S;\n\tint maxv = 0;\n\tbuffer[size] = 0;\n\tfor (int i = 0; i <= size; i++) {\n\t\tRectangle rect;\n\t\trect.height = buffer[i];\n\t\trect.pos = i;\n\t\tif (S.empty()) {\n\t\t\tS.push(rect);\n\t\t}\n\t\telse {\n\t\t\tif (S.top().height < rect.height) {\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t\telse if (S.top().height > rect.height) {\n\t\t\t\tint target = i;\n\t\t\t\twhile (!S.empty() and S.top().height >= rect.height) {\n\t\t\t\t\tRectangle pre = S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tint area = pre.height * (i - pre.pos);\n\t\t\t\t\tmaxv = max(area, maxv);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos = target;\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxv;\n}\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle() {\n\trep(j, W) {\n\t\trep(i, H) {\n\t\t\tif (buffer[i][j]) {\n\t\t\t\tT[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tT[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxv = 0;\n\trep(i, H) {\n\t\tmaxv = max(maxv, getLargestRectangle(W, T[i]));\n\t}\n\treturn maxv;\n}\n\nsigned main() {\n\tios::sync_with_stdio(true);\n\tcin >> H >> W;\n\trep(i, H) {\n\t\trep(j, W) {\n\t\t\tcin >> buffer[i][j];\n\t\t}\n\t}\n\tcout << getLargestRectangle() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint H,W;\nint c[1500][1500];\nint h[1500][1500];\nint l[1500],r[1500];\n\nint main(void){\n\tcin >> H >> W;\n\trep(i,H)rep(j,W) cin >> c[i][j];\n\trep(i,H)rep(j,W){\n\t\tif(c[i][j]==1)\n\t\t\th[i][j]=0;\n\t\telse{\n\t\t\th[i][j]=1;\n\t\t\tif(i-1>=0) h[i][j]+=h[i-1][j];\n\t\t}\n\t}\n\tint ans=0;\n\trep(i,H){\n\t\tstack<int> stk;\n\t\trep(j,W){\n\t\t\twhile(!stk.empty()&&h[i][stk.top()]>=h[i][j]) stk.pop();\n\t\t\tl[j]=(stk.size()==0)?0:(stk.top()+1);\n\t\t\tstk.push(j);\n\t\t}\n\t\twhile(!stk.empty()) stk.pop();\n\t\tfor(int j=W-1;j>=0;--j){\n\t\t\twhile(!stk.empty()&&h[i][stk.top()]>=h[i][j]) stk.pop();\n\t\t\tr[j]=(stk.size()==0)?W:(stk.top());\n\t\t\tstk.push(j);\n\t\t}\n\t\trep(j,W) ans=max(ans,(r[j]-l[j])*h[i][j]);\n\t}\n\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nstruct rectagle {\n\tint pos, height;\n};\n\nint getMax(int T[], int W) {\n\n\tstack<rectagle> S;\n\tint maxv = 0;\n\tfor (int i = 0; i < W; ++i) {\n\t\trectagle r;\n\t\tr.pos = i;\n\t\tr.height = T[i];\n\t\tif (S.empty()) {\n\t\t\tS.push(r);\n\t\t} else {\n\t\t\tif (r.height > S.top().height) {\n\t\t\t\tS.push(r);\n\t\t\t} else {\n\t\t\t\twhile (!S.empty() && S.top().height > r.height) {\n\t\t\t\t\trectagle pop = S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tint area = (i - pop.pos) * pop.height;\n\t\t\t\t\tmaxv = max(maxv, area);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn maxv;\n}\n\nint main() {\n\n\tint H, W;\n\tscanf(\"%d %d\", &H, &W);\n\n\tint A[H][W];\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tscanf(\"%d\", &A[i][j]);\n\t\t}\n\t}\n\tint T[H][W];\n\tfor (int j = 0; j < W; ++j) {\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tif (A[i][j] == 0) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tT[i][j] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tT[i][j] = T[i - 1][j] + 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tT[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxv = 0;\n\tfor (int i = 0; i < H; ++i) {\n\t\tmaxv = max(maxv, getMax(T[i], W));\n\t}\n\tcout << maxv << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nint main(){\n\tint h,w;\n\tcin>>h>>w;\n\t\n\tvector<vector<int>> v(h,vector<int>(w));\n\trep(i,h) rep(j,w) cin>>v[i][j];\n\trep(i,h) rep(j,w) v[i][j] = !v[i][j];\n\t\n\tstatic int dp[1500][1500];\n\trep(i,1500)rep(j,1500)dp[i][j]=0;\n\t\n\trep(i,w)dp[0][i] = v[0][i];\n\tfor(int i=1;i<h;i++){\n\t\trep(j,w){\n\t\t\tif(v[i][j]!=0)dp[i][j] = dp[i-1][j]+v[i][j];\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\trep(i,h){\n\t\tstack<pii> st;\n\t\trep(j,w){\n\t\t\tpii tmp = pii(dp[i][j],j);\n\t\t\tif(st.empty())st.push(tmp);\n\t\t\telse if(st.top().first<tmp.first){\n\t\t\t\tst.push(tmp);\n\t\t\t\tans = max(ans,tmp.first);\n\t\t\t}else if(st.top().first>tmp.first){\n\t\t\t\twhile(st.size()&&st.top().first>tmp.first){\n\t\t\t\t\tans = max(ans,(tmp.second-st.top().second+1)*tmp.first);\n\t\t\t\t\tst.pop();\n\t\t\t\t}\n\t\t\t\tst.push(tmp);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\nconst ll mod2 = 998244353;\nconst int INF = 1000000005;\nconst long double EPS = 1e-10;\nconst int MAX = 1405;\n\nstruct Histogram {\n  int h, id;\n};\n\n\nint h, w, c[MAX][MAX], t[MAX][MAX];\n\nint solve() {\n  int ans = 0;\n\n  rep(i, h) {\n    stack<Histogram> s;\n    t[i][w] = 0;\n    rep(j, w + 1) {\n      Histogram rect;\n      rect.h = t[i][j];\n      rect.id = j;\n      if (s.empty()) s.push(rect);\n      else {\n        if (s.top().h < rect.h) {\n          s.push(rect);\n        }\n        else if (s.top().h > rect.h) {\n          int target = j;\n          while (!s.empty() && s.top().h >= rect.h) {\n            Histogram pre = s.top();\n            s.pop();\n            int area = pre.h * (j - pre.id);\n            ans = max(ans, area);\n            target = pre.id;\n          }\n          rect.id = target;\n          s.push(rect);\n        }\n      }\n    }\n  }\n\n  return ans;\n}\n\nint main() {\n  cin >> h >> w;\n  rep(i, h) {\n    rep(j, w) {\n      cin >> c[i][j];\n    }\n  }\n\n  rep(j, w) {\n    rep(i, h) {\n      if (c[i][j] == 1) t[i][j] = 0;\n      else {\n        if (i == 0) t[i][j] = 1;\n        else t[i][j] = t[i - 1][j] + 1;\n      }\n    }\n  }\n\n  cout << solve() << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\nconst int adx[] = { 1,1,1,0,-1,-1,-1,0 };\nconst int ady[] = { 1,0,-1,-1,-1,0,1,1 };\n\nint add(const int base, const int plus) {\n\tif (!plus) {\n\t\treturn base + 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n//0 :?????????1:??????2:?????????3:??? 4:?????????5:??? 6:?????? 7:??? ???\nvector<vector<vector<int>>>get_cumulative_sum(const vector<vector<int>>&field) {\n\tconst int H = field.size();\n\tconst int W = field[0].size();\n\n\tvector<vector<vector<int>>>sums(4, vector<vector<int>>(H, vector<int>(W)));\n\n\tfor (int ny = H - 1; ny >= 0; --ny) {\n\t\tfor (int nx = 0; nx <W; ++nx) {\n\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\tsums[k].clear();\n\t\t\t}\n\t\t\tfor (int k = 3; k < 4; ++k) {\n\t\t\t\tint py = ny - ady[k];\n\t\t\t\tint px = nx - adx[k];\n\t\t\t\tif (!(px >= 0 && px <W && py >= 0 && py <H))continue;\n\n\t\t\t\tsums[k][ny][nx] = add(sums[k][py][px], field[ny][nx]);\n\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sums;\n}\n\nint getans( vector<int>hs) {\n\ths.emplace_back(0);\n\tstack<pair<int, int>>que;\n\tque.emplace(-1, 0);\n\tint ans = 0;\n\tfor (int x = 0; x < hs.size(); ++x) {\n\t\t\n\t\tif (que.empty()) {\n\t\t\tque.push(make_pair(x, hs[x]));\n\t\t}\n\t\telse {\n\t\t\twhile (!que.empty()) {\n\t\t\t\tauto p = que.top();\n\t\t\t\tif (p.second < hs[x]) {\n\t\t\t\t\tque.push(make_pair(x,hs[x]));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (p.second == hs[x]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint area = (x - p.first)*p.second;\n\t\t\t\t\tans = max(ans, area);\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif (!que.empty()) {\n\t\t\t\t\t\tauto np = que.top();\n\t\t\t\t\t\tif (np.second < hs[x]) {\n\t\t\t\t\t\t\tque.push(make_pair(p.first, hs[x]));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\t\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>>field(H + 2, vector<int>(W + 2,1));\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tcin >> field[i + 1][j + 1];\n\t\t}\n\t}\n\tauto vs = get_cumulative_sum(field);\n\tint ans = 0;\n\t\n\tfor (int y = 1; y <= H; ++y) {\n\t\tvector<int>v;\n\t\tfor (int x = 1; x <= W; ++x) {\n\t\t\tv.push_back(vs[y][x][3]);\n\t\t}\n\t\tans = max(ans, getans(v));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n\nstatic const int MAX_N = 1400;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n\nint masu[MAX_N][MAX_N];\n\nint main(void) {\n  int H, W;\n  cin >> H >> W;\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      cin >> masu[i][j];\n      masu[i][j] = (masu[i][j] + 1) % 2;\n    }\n  }\n  for (int i = 1; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      if (masu[i][j]) {\n        masu[i][j] += masu[i-1][j];\n      }\n    }\n  }\n\n  Rectangle rect;\n  int maxArea = 0;\n  for (int i = 0; i < H; i++) {\n    stack<Rectangle> stk;\n    for (int j = 0; j < W; j++) {\n      rect.height = masu[i][j];\n      rect.pos = j;\n      if (stk.empty()) {\n        stk.push(rect);\n      } else {\n        if (stk.top().height < rect.height) {\n          stk.push(rect);\n        } else if (stk.top().height > rect.height) {\n          int target = j;\n          while (!stk.empty() && stk.top().height >= rect.height) {\n            Rectangle pre = stk.top(); stk.pop();\n            int area = pre.height * (j - pre.pos);\n            maxArea = max(maxArea, area);\n            target = pre.pos;\n          }\n          rect.pos = target;\n          stk.push(rect);\n        }\n      }\n    }\n    if (!stk.empty()) {\n      if (stk.top().height != 0) {\n        maxArea = max(maxArea, 1);\n      }\n    }\n  }\n\n  cout << maxArea << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stack>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> pi;\n#define F first\n#define S second\n#define MP make_pair\nconst int N=5e2+10;\nint main(){\n    int n,m,a[N][N],now,ans,nx;\n    pi temp;\n    stack<pi> s;\n        scanf(\"%d%d\",&n,&m);\n        ans=0;\n        for(int i=0;i<n;i++){\n            now=0;\n            for(int j=0;j<m;j++){\n                scanf(\"%d\",&nx);\n                if(nx==1)now++;\n                else now=0;\n                a[i][j]=now;\n            }\n        }\n        for(int j=0;j<m;j++){\n            while(!s.empty())s.pop();\n            for(int i=0;i<n;i++){\n                while(!s.empty()){\n                    if(s.top().F>a[i][j]){\n                        temp=s.top();\n                        s.pop();\n                        if(s.empty())ans=max(ans,temp.F*i);\n                        else ans=max(ans,temp.F*(i-1-s.top().S));\n                    }\n                    else break;\n                }\n                s.push(MP(a[i][j],i));\n            }\n            while(!s.empty()){\n                temp=s.top();\n                s.pop();\n                if(s.empty())ans=max(ans,temp.F*n);\n                else ans=max(ans,temp.F*(n-s.top().S-1));\n                \n            }\n        }\n        printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint c[1401][1401]={};\nint a(int x1,int x2,int y1,int y2){\n\tint b=c[x1][y1]+c[x2][y2]-c[x1][y2]-c[x2][y1];\n\tif(b!=0) b=1;\n\treturn b;\n}\nint main(){\n\tint h,w;\n\tcin >> h >> w;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tcin >> c[i][j];\n\t\t\tc[i][j] += c[i][j-1]+c[i-1][j]-c[i-1][j-1];\n\t\t}\n\t}\n\tint max=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tfor(int k=i+1;k<=h;k++){\n\t\t\t\tfor(int l=j+1;l<=w;l++){\n\t\t\t\t\tif(a(i,k,j,l)==0){\n\t\t\t\t\t\tif(max<(k-i)*(l-j)) max=(k-i)*(l-j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << max << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint h,w;\nvi b;\n\nint main(){\n\tcin>>h>>w;\n\tb=vi(w+1);\n\tint res=0;\n\tfor(int i=0;i<h;i++){\n\t\tstack<P> st;\n\t\tst.push({-1,-1});\n\t\tfor(int j=0;j<=w;j++){\n\t\t\tif(j<w){\n\t\t\t\tint x;\n\t\t\t\tcin>>x;\n\t\t\t\tif(!x) b[j]++;\n\t\t\t\telse b[j]=0;\n\t\t\t}\n\t\t\twhile(st.top().first>b[j]){\n\t\t\t\tP p=st.top();st.pop();\n\t\t\t\tres=max(res,(j-st.top().second-1)*p.first);\n\t\t\t}\n\t\t\tif(st.top().first!=b[j]) st.push({b[j],j});\n\t\t}\n\t}\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n\tRectangle rect;\n\tfor(int i=0;i<x;i++){\n\t\tstack<Rectangle> stk;\n\t\tint pop=0;\n\t\tfor(int j=0;j<=y;j++){\n\t\t\trect.height = m[j][i];\n\t\t\trect.pos = j;\n\t\t\tif(stk.empty() || stk.top().height < rect.height){\n\t\t\t\tstk.push(rect);\n\t\t\t}else{\n\t\t\t\t//printf(\"[-] %d %d\\n\",i,j);\n\t\t\t\tfor(;!stk.empty() && stk.top().height >= rect.height;){\n\t\t\t\t\tpop++;\n\t\t\t\t\tRectangle pre = stk.top(); stk.pop();\n\t\t\t\t\tint area = pre.height * (j - pre.pos);\n\t\t\t\t\tr = max(r, area);\n\t\t\t\t\t//printf(\"%d %d\\n\",target,pre.pos);\n\t\t\t\t\trect.pos = pre.pos;\n\t\t\t\t}\n\t\t\t\tstk.push(rect);\n\t\t\t}\n\t\t\tif(rect.height==0)pop=0;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n\t  int to,c;\n\t  Edge(int ti, int ci){\n\t\t\tto = ti; c = ci;\n\t  }\n};\n\ntypedef vector<Edge> ve;\ntypedef vector<ve> graph;\n\n\nint N,X;\n\nset<int> sum_list;\nvector<int> list_;\nvoid dfs(graph& g, int corr, int pre){\n\n\t  \n\t  int pre_edge_c = list_[ list_.size()-1 ];\n\t  for(int i=0; i<g[corr].size(); i++){\n\t\t\tif(g[corr][i].to == pre) continue;\n\t\t\tg[corr][i].c ^=  pre_edge_c;\n//\t\t\tcout << corr+1 << \" -> \" << g[corr][i].to+1 << \" \" << g[corr][i].c << endl;\n\t\t\tint k=0;\n\t\t\tfor(int j=0; j<g[i].size(); j++) if(g[i][j].to == corr) k = j;\n\t\t\tg[i][k].c = g[corr][i].c;\n\t\t\tsum_list.insert( g[corr][i].c );\n\t\t\tlist_.push_back( g[corr][i].c );\n\t\t\tdfs(g, g[corr][i].to, corr);\n\t  }\n\t  \n\n}\nvoid dump(graph& g){\n\n\t  for(int i=0; i<g.size(); i++)\n\t\t\tfor(Edge e : g[i])\n\t\t\t\t  cout << i+1 << \" -> \"<< e.to+1 << \":\" << e.c << endl;\n\n}\n\nint main(){\n\n\t  cin >> N >> X;\n\t  graph g(N);\n\t  for(int i=0; i<N-1; i++){\n\t\t\tint x,y,c; cin >> x >> y >> c;\n\t\t\tg[x-1].push_back( Edge(y-1,c) );\n\t\t\tg[y-1].push_back( Edge(x-1,c) );\n\t  }\n\t  int leaf;\n\t  for(int i=0; i<N; i++)\n\t\t\tif(g[i].size() == 1) leaf = i;\n\t  cout << leaf << endl;\n//\t  dump(g);\n\t  list_.push_back(0);\n\t  dfs(g,leaf,-1);\n//\t  dump(g);\n\n//\t  for(int x : sum_list)\t\t\tcout << x << \" \"<< endl;\n\t  int ans = 0;\n\t  for(int i=1; i<list_.size(); i++){\n\t\t\tif(sum_list.find( list_[i]^X ) == sum_list.end()) ans++;\n\t  }\n\t  cout << ans << endl;\n\t  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 1400;\n\nint a[MAX_N][MAX_N];\nint t[MAX_N][MAX_N];\ndeque<P> deq;\n\nint main()\n{\n\tint h,w;\n\tcin >> h >> w;\n\tint ans=0;\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t}\n\t}\n\trep(i,h){\n\t\tt[i][w] = 0;\n\t}\n\trep(j,w){\n\t\tt[0][j] = 1^a[0][j];\n\t}\n\tfor(int i=1;i<h;i++){\n\t\trep(j,w){\n\t\t\tif(a[i][j]==0){\n\t\t\t\tt[i][j] = t[i-1][j] + 1;\n\t\t\t}else{\n\t\t\t\tt[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,h){\n\t\trep(j,w+1){\n\t\t\tif(deq.empty()){\n\t\t\t\tdeq.push_back(P(t[i][j],j));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdeque<P>::iterator it = deq.end()-1;\n\t\t\tif((*it).first < t[i][j]){\n\t\t\t\tdeq.push_back(P(t[i][j],j));\n\t\t\t}else if((*it).first > t[i][j]){\n\t\t\t\twhile(!deq.empty() && (*it).first > t[i][j]){\n\t\t\t\t\tint S = (*it).first*(j-(*it).second);\n\t\t\t\t\tans = max(S,ans);\n\t\t\t\t\tdeq.pop_back();\n\t\t\t\t\tit = deq.end()-1;\n\t\t\t\t}\n\t\t\t\tdeq.push_back(P(t[i][j],j));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nint main(){\n\tint h,w;\n\tcin>>h>>w;\n\t\n\tvector<vector<int>> v(h,vector<int>(w));\n\trep(i,h) rep(j,w) cin>>v[i][j];\n\trep(i,h) rep(j,w) v[i][j] = !v[i][j];\n\t\n\tstatic int dp[1500][1500];\n\trep(i,1500)rep(j,1500)dp[i][j]=0;\n\t\n\trep(i,w)dp[0][i] = v[0][i];\n\tfor(int i=1;i<h;i++){\n\t\trep(j,w){\n\t\t\tif(v[i][j]!=0)dp[i][j] = dp[i-1][j]+v[i][j];\n\t\t}\n\t}\n\n\tint ans = 0;\n\trep(i,h){\n\t\tstack<pii> st;\n\t\trep(j,w){\n\t\t\tpii tmp = pii(dp[i][j],j);\n\t\t\tif(st.empty())st.push(tmp);\n\t\t\telse if(st.top().first<tmp.first){\n\t\t\t\tst.push(tmp);\n\t\t\t}else if(st.top().first>=tmp.first){\n\t\t\t\tint used;\n\t\t\t\twhile(st.size()&&st.top().first>=tmp.first){\n\t\t\t\t\tans = max(ans,(tmp.second-st.top().second+1)*tmp.first);\n\t\t\t\t\tused = st.top().second;\n\t\t\t\t\tst.pop();\n\t\t\t\t}\n\t\t\t\ttmp.second = used;\n\t\t\t\tst.push(tmp);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n\nusing namespace std;\n\n\nint c[1401][1401];\nint dp[1401][1401];\n\nstruct RT {\n\tint point;\n\tint height;\n};\n\nint max_in_x(int *p,int size) {\n\tstack<RT> st;\n\tint cur = 0;\n\tint s = 0;\n\n\t*(p + size ) = 0;\n\tfor (int i = 0; i <= size; i++) {\n\t\tint current_h = *(p + i);\n\t\tRT rect = {i,current_h};\n\n\t\tif (st.empty()) {\n\t\t\tst.push(rect);\n\t\t} else if (current_h > st.top().height) {\n\t\t\tst.push(rect);\n\t\t} else if (current_h < st.top().height) {\n\t\t\tRT start = st.top();\n\t\t\tstart.point = i - 1;\n\t\t\tRT target;\n\n\t\t\twhile(!st.empty() && st.top().height > current_h) {\n\t\t\t \ttarget = st.top();\n\t\t\t\tst.pop();\n\t\t\t\ts = max(s,(start.point -target.point + 1) * target.height);\n\t\t\t\t//cout << \"s:\" << s << endl;\n\t\t\t}\n\t\t\ttarget.height = current_h;\n\t\t\tst.push(target);\n\t\t\t\n\t\t} \n\t}\n\n\treturn s;\n}\n\n\nint main() {\n\tint W,H;\n\tcin >> H >> W;\n\t\n\tint v_max = 0;\n\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x < W; x++) {\n\n\t\t\tcin >> c[y][x];\n\t\t\tc[y][x] ^= 1;\n\t\t\tdp[y][x] = 0;\t\t\t\n\t\t}\n\t}\n\tfor (int x = 0; x < W; x++) {\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tif (c[y][x] == 0) {\n\t\t\t\tdp[y][x] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (y==0) {\n\t\t\t\tdp[y][x] = 1;\n\t\t\t\tcontinue;\t\t\t\t\n\t\t\t} \n\t\t\tdp[y][x] = dp[y-1][x] + 1;\n\t\t}\n\t}\n\n\tint s_max = 0;\n\n/*\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x < W; x++) {\n\t\t\tcout << setw(5) << dp[y][x] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n*/\n\n\tfor( int y = 0; y < H; y++) {\n\t\t\n\t\t//cout << \"** s_max y:\" << y << endl;\n\t\tint ret = max_in_x(dp[y],W); \n\t\t//cout << \"v:\" << ret << endl;\n\t\ts_max = max(s_max,ret);\n\t}\n\n\tcout << s_max << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\ni64 largest_rectangle(vi hist) {\n    hist.push_back(0);\n    using ii = pair<i64, int>;\n    stack<ii> st;\n    i64 ret = 0;\n    for (int i = 0; i < hist.size(); i++) {\n        if (st.empty() || st.top().first < hist[i]) {\n            st.push(ii(hist[i], i));\n        } else {\n            int s;\n            while (st.size() && st.top().first >= hist[i]) {\n                ret = max(ret, st.top().first * (i - st.top().second));\n                s = st.top().second;\n                st.pop();\n            }\n            st.push(ii(hist[i], s));\n        }\n    }\n    \n    return ret;\n}\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n    vvi b(h, vi(w));\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            int c;\n            cin >> c;\n            if (c == 0) {\n                if (i == 0) {\n                    b[i][j] = 1;\n                } else {\n                    b[i][j] = b[i - 1][j] + 1;\n                }\n            } else {\n                b[i][j] = 0;\n            }\n        }\n    }\n\n    i64 ret = 0;\n    for (int i = 0; i < h; i++) {\n        ret = max(ret, largest_rectangle(b[i]));\n    }\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n\tRectangle rect;\n\tfor(int i=0;i<x;i++){\n\t\tstack<Rectangle> stk;\n\t\tint pop=0;\n\t\tfor(int j=0;j<=y;j++){\n\t\t\trect.height = m[j][i];\n\t\t\trect.pos = j;\n\t\t\tif(stk.empty() || stk.top().height < rect.height){\n\t\t\t\tstk.push(rect);\n\t\t\t}else{\n\t\t\t\t//printf(\"[-] %d %d\\n\",i,j);\n\t\t\t\tint target = j;\n\t\t\t\tfor(;!stk.empty() && stk.top().height >= rect.height;){\n\t\t\t\t\tpop++;\n\t\t\t\t\tRectangle pre = stk.top(); stk.pop();\n\t\t\t\t\tint area = pre.height * (j - pre.pos);\n\t\t\t\t\tr = max(r, area);\n\t\t\t\t\t//printf(\"%d %d\\n\",target,pre.pos);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos = target;\n\t\t\t\tstk.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nstruct elem {\n\tint pos, height;\n};\n\nint getArea(int V[], int W) {\n\tint area = 0;\n\tstack<elem> S;\n\tfor (int i = 0; i <= W; ++i) {\n\t\telem e;\n\t\te.pos = i;\n\t\tif (i == W) {\n\t\t\te.height = 0;\n\t\t} else {\n\t\t\te.height = V[i];\n\t\t}\n\t\tif (S.empty() || e.height > S.top().height) {\n\t\t\tS.push(e);\n\t\t} else if (S.top().height > e.height) {\n\t\t\tint prepos = i;\n\t\t\twhile (!S.empty() && S.top().height > e.height) {\n\t\t\t\telem target = S.top();\n\t\t\t\tS.pop();\n\t\t\t\tarea = max(area, (i - target.pos) * target.height);\n\t\t\t}\n\t\t\te.pos = prepos;\n\t\t\tS.push(e);\n\t\t}\n\t}\n\treturn area;\n}\nint main() {\n\tint H, W;\n\tscanf(\"%d %d\", &H, &W);\n\tint A[H][W];\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tscanf(\"%d\", &A[i][j]);\n\t\t}\n\t}\n\n\tint V[H][W];\n\tfor (int j = 0; j < W; ++j) {\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tif (A[i][j] == 1) {\n\t\t\t\tV[i][j] = 0;\n\t\t\t} else {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tV[i][j] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tV[i][j] = V[i - 1][j] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxv = 0;\n\tfor (int i = 0; i < H; ++i) {\n\t\tmaxv = max(maxv, getArea(V[i], W));\n\t}\n\tcout << maxv << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <iomanip>\n#include <queue>\n#include <list>\n#include <set>\n#include <stack>\n#include <cctype>\n#include <cmath>\n#include <bitset>\n\nusing namespace std;\n/* typedef */\ntypedef long long ll;\n/* constant */\nconst int MAX = 1405;\n/* struct */\nstruct Rectangle {int height; int pos; };\n/* global variables */\nvector < vector<int> > Area(MAX, vector<int>(MAX)), buffer(MAX, vector<int>(MAX));\nint H, W;\n/* function */\nint getLargestRectangle(int size, vector<int>& buffer) {\n    stack<Rectangle> S;\n    int maxv = 0;\n    buffer[size] = 0;\n\n    for (int i = 0; i <= size; i++) {\n        Rectangle rect;\n        rect.height = buffer[i];\n        rect.pos = i;\n        if ( S.empty() ) {\n            S.push(rect);\n        }\n        else {\n            if ( S.top().height < rect.height ) {\n                S.push(rect);\n            }\n            else if ( S.top().height > rect.height) {\n                int target = i;\n                while (!S.empty() && S.top().height >= rect.height) {\n                    Rectangle pre = S.top(); S.pop();\n                    int area = pre.height * (i - pre.pos);\n                    maxv = max(maxv, area);\n                    target = pre.pos;\n                }\n                rect.pos = target;\n                S.push(rect);\n            }\n        }\n    }\n    return maxv;\n}\n\nint getLargestRectangle() {\n    for (int j = 0; j < W; j++) {\n        for (int i = 0; i < H; i++) {\n            if (Area[i][j]) {\n                buffer[i][j] = 0;\n            }\n            else {\n                buffer[i][j] = (i > 0) ? buffer[i-1][j] + 1 : 1;\n            }\n        }\n    }\n\n    int maxv = 0;\n    for (int i = 0; i < H; i++) {\n        maxv = max(maxv, getLargestRectangle(W, buffer[i]));\n    }\n\n    return maxv;\n}\n\n/* main */\nint main() {\n    cin >> H >> W;\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> Area[i][j];\n        }\n    }\n\n    cout << getLargestRectangle() << '\\n';\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n    int maxlen[1401][1401] = {};\n    for(int i = 1; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            int c;\n            cin >> c;\n            if(c == 1) continue;\n            maxlen[i][j] = maxlen[i - 1][j] + 1;\n        }\n    }\n    int ans = 0;\n    for(int i = 1; i <= h; i++){\n        stack<pair<int, int> > st;\n        for(int j = 1; j <= w; j++){\n            if(st.empty() || (st.top()).first < maxlen[i][j]){\n                st.push(make_pair(maxlen[i][j], j));\n            } else if((st.top()).first > maxlen[i][j]){\n                int before = j;\n                while(!st.empty()){\n                    if((st.top()).first < maxlen[i][j]){\n                        st.push(make_pair(maxlen[i][j], before));\n                        break;\n                    } else {\n                        ans = max(ans, (st.top()).first * (j - (st.top()).second));\n                        before = (st.top()).second;\n                        st.pop();\n                    }\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n\tRectangle rect;\n\tfor(int i=0;i<x;i++){\n\t\tstack<Rectangle> stk;\n\t\tfor(int j=0;j<=y;j++){\n\t\t\trect.height = m[j][i];\n\t\t\trect.pos = j;\n\t\t\tif(stk.empty() || stk.top().height < rect.height){\n\t\t\t\tstk.push(rect);\n\t\t\t}else{\n\t\t\t\tint target = j;\n\t\t\t\tfor(;!stk.empty() && stk.top().height >= rect.height;){\n\t\t\t\t\tRectangle pre = stk.top(); stk.pop();\n\t\t\t\t\tint area = pre.height * (j - pre.pos);\n\t\t\t\t\tr = max(r, area);\n\t\t\t\t\ttarget--;// = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos = target;\n\t\t\t\tstk.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\nusing namespace std;\nstatic const int HMAX = 1401;\nstatic const int WMAX = 1401;\n\nint tiles[HMAX][WMAX] = {0};\n\nvoid print_tiles(int h, int w) {\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      cout << tiles[i][j] << \" \";\n    }\n    cout << endl;\n  }\n}\n\n// side-effects (to tiles)\nint leargest_square(int height, int width, int ans_init) {\n  int ans = ans_init;\n  for (int i = 1; i < height; i++) {\n    for (int j = 1; j < width; j++) {\n      if (tiles[i][j] != 0) {\n        tiles[i][j] =\n            min({tiles[i - 1][j], tiles[i][j - 1], tiles[i - 1][j - 1]}) + 1;\n        ans = max(ans, tiles[i][j]);\n      }\n    }\n  }\n  return ans * ans;\n}\n\nstruct Rect {\n  int height;\n  int left;\n};\n\n// side-effects (to tiles)\nint leargest_rectanble(int height, int width) {\n  // mkae histgrams\n  for (int i = 1; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      if (tiles[i][j] != 0) {\n        tiles[i][j] = tiles[i - 1][j] + 1;\n      }\n    }\n  }\n\n  int maxsize = 0;\n  stack<Rect> st;\n  for (int i = 4; i < height; i++) {\n    // calc the rectangle size of the i-th histgram\n    tiles[i][width] = 0; // sentinel\n    for (int j = 0; j < width + 1; j++) {\n      auto rect = Rect{tiles[i][j], j};\n      if (st.empty() || st.top().height < rect.height) {\n        st.push(rect);\n      } else if (st.top().height > rect.height) {\n        Rect r;\n        while (!st.empty()) {\n          r = st.top();\n          if (r.height <= rect.height)\n            break;\n          int size = r.height * (rect.left - r.left);\n          maxsize = max(size, maxsize);\n          st.pop();\n        }\n        if (r.height < rect.height) {\n          rect.left = r.left + 1;\n          st.push(rect);\n        }\n      }\n    }\n  }\n\n  return maxsize;\n}\n\n#define BLOCK 1\nint main() {\n  int height, width;\n  int ans_init = 0;\n  cin >> height >> width;\n  for (int i = 0; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      int tmp;\n      cin >> tmp;\n      tiles[i][j] = tmp == BLOCK ? 0 : 1;\n      ans_init = max(ans_init, tiles[i][j]);\n    }\n  }\n  cout << leargest_rectanble(height, width) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define endl '\\n'\n#define MAX 1500\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nchar board[MAX][MAX];\nint dp[MAX][MAX];\nint L[MAX][MAX];\nint R[MAX][MAX];\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t\t\n    int n,m;\n    cin >> n >> m;\n\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= m; j++)\n            cin >> board[i][j];\n\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= m; j++){\n            if(board[i][j] == '1')\n                dp[i][j] = 0;\n            else\n                dp[i][j] = 1 + dp[i - 1][j];\n        }\n\n    for(int i = 1; i <= n; i++){\n        stack<int> st;\n        for(int j = 1; j <= m; j++){\n            while(!st.empty() && dp[i][st.top()] >= dp[i][j])\n                st.pop();\n            if(st.empty())\n                L[i][j] = 1;\n            else\n                L[i][j] = st.top() + 1;\n            st.push(j);\n        }\n    }\n\n    for(int i = 1; i <= n; i++){\n        stack<int> st;\n        for(int j = m; j >= 1; j--){\n            while(!st.empty() && dp[i][st.top()] >= dp[i][j])\n                st.pop();\n            if(st.empty())\n                R[i][j] = m;\n            else\n                R[i][j] = st.top() - 1;\n            st.push(j);\n        }\n    }\n\n    int solve = 0;\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= m; j++){\n            if(dp[i][j] == 0)\n                continue;\n            int size = R[i][j] - L[i][j] + 1;\n            int rectangle_size = size * dp[i][j];\n\n            solve = max(solve,rectangle_size);\n        }\n\n    cout << solve << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Rectangle{\n    int height,pos;\n};\n\nint h,w;\nvector<vector<int>> T(1401,vector<int>(1401));\nvector<vector<int>> buffer(1401,vector<int>(1401));\n\nint getLargestRectangle(int size,vector<int> &buffer){\n    stack<Rectangle> s;\n    int maxv=0;\n    buffer[size]=0;\n    for(int i=0;i<=size;i++){\n        Rectangle rect;\n        rect.height=buffer[i];\n        rect.pos=i;\n        if(s.empty()){\n            s.push(rect);\n        }\n        else{\n            if(s.top().height<rect.height){\n                s.push(rect);\n            }\n            else if(s.top().height>rect.height){\n                int target=i;\n                while(!s.empty()&&s.top().height>=rect.height){\n                    Rectangle pre=s.top();\n                    s.pop();\n                    int area=pre.height*(i-pre.pos);\n                    maxv=max(maxv,area);\n                    target=pre.pos;\n                }\n                rect.pos=target;\n                s.push(rect);\n            }\n        }\n    }\n    return maxv;\n}\n\nint getLargestRectangle(){\n    for(int j=0;j<w;j++){\n        for(int i=0;i<h;i++){\n            if(buffer[i][j]){\n                T[i][j]=0;\n            }\n            else{\n                if(i==0){\n                    T[i][j]=1;\n                }\n                else{\n                    T[i][j]=T[i-1][j]+1;\n                }\n            }\n        }\n    }\n    int maxv=0;\n    for(int i=0;i<h;i++){\n        maxv=max(maxv,getLargestRectangle(w,T[i]));\n    }\n    return maxv;\n}\n\nint main(){\n    cin>>h>>w;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            cin>>buffer[i][j];\n        }\n    }\n\n    cout<<getLargestRectangle()<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint H,W;\nint C[1410][1410];\nint S[1410][1410];\n\ndeque<pair<int,int>> Q; \ntemplate<typename T>\nT debug(const T& x){\n\tcerr<<x<<\" \";\n\treturn x;\n}\n\ntemplate<typename T>\nT debugln(const T& x){\n\tcerr<<x<<endl;\n\treturn x;\n}\nint main(){\n\tiostream::sync_with_stdio(false);\n\tcin>>H>>W;\n\tfor(int y=0;y<H;y++)\n\t\tfor(int x=0;x<W;x++)\n\t\t\tcin>>C[y][x];\n\tfor(int x=0;x<=W;x++)S[0][x]=0;\n\t//for(int y=0;y<=H;y++)S[y][0]=0;\n\tfor(int y=0;y<H;y++)\n\t{\n\t\tfor(int x=0;x<W;x++)\n\t\t\tS[y+1][x]=debug(C[y][x]==0?S[y][x]+1:0);\n\t\tcerr<<endl;\n\t}\n\tint m=0;\n\t\n\tfor(int y=0;y<=H;y++){\n\t\tQ.emplace_front(-1,0);\n\t\tfor(int x=0;x<=W;x++){\n\t\t\tint last_pop=x;\n\t\t\twhile(Q.front().second>S[y][x]){\n\t\t\t\tm=max(m,(x-Q.front().first)*Q.front().second);\n\t\t\t\tlast_pop=Q.front().first;\n\t\t\t\tQ.pop_front();\n\t\t\t}\n\t\t\tif(S[y][x]>Q.front().second){\n\t\t\t\tQ.emplace_front(last_pop,S[y][x]);\n\t\t\t\tcerr<<x<<\" \"<<S[y][x]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\t\t\t\n\tcout<<m<<endl;\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<algorithm>\n#define fi first\n#define se second\nusing namespace std;\nconst int M=1400;\nint h,w;\nint T[M][M+1];\nint get(int size)\n{\n\tstack<pair<int,int>>s;\n\tint maxv=0;\n\tpair<int,int>r,p;\n\tint t;\n\t\n\tfor(int i=0;i<=size;i++)\n\t{\n\t\tr.fi=T[size][i];\n\t\tr.se=i;\n\t\tif(s.empty())s.push(r);\n\t\telse\n\t\t{\n\t\t\tif(s.top().fi<r.fi)s.push(r);\n\t\t\telse if(s.top().fi>r.fi)\n\t\t\t{\n\t\t\t\tt=i;\n\t\t\t\twhile(!s.empty()&&s.top().fi>r.fi)\n\t\t\t\t{\n\t\t\t\t\tp=s.top();s.pop();\n\t\t\t\t\tmaxv=max(maxv,p.fi*(i-p.se));\n\t\t\t\t\tt=p.se;\n\t\t\t\t}\n\t\t\t\tr.se=t;\n\t\t\t\ts.push(r);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxv;\n}\n\nint main()\n{\n\tcin>>h>>w;\n\tint c[M][M];\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tcin>>c[i][j];\n\t\t}\n\t}\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tfor(int j=0;j<w;j++)\n\t\t{\n\t\t\tT[i][j]=(c[i][j]?0:i>0?T[i-1][j]+1:1);\n\t\t}\n\t\tT[i][w]=0;\n\t}\n\tint maxv=0;\n\tfor(int i=0;i<h;i++)\n\t{\n\t\tmaxv=max(maxv,get(i));\n\t}\n\tcout<<maxv<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 2000\nint x[MAX_N][MAX_N];\nint H, W;\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> x[i][j];\n\t\t}\n\t\tif (x[i][0] == 1) { x[i][0] = 0; }\n\t\telse { x[i][0] = 1; }\n\t\tfor (int j = 1; j < W; j++) {\n\t\t\tif (x[i][j] == 1) {\n\t\t\t\tx[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i][j] = x[i][j - 1] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tint maxn = 0;\n\tfor (int i = 0; i < W; i++) {\n\t\tfor (int j = 0; j < H; j++) {\n\t\t\tint X = x[j][i], cnt = 0;\n\t\t\tif (x[j][i] == 0)continue;\n\t\t\tfor (int k = j; k >= 0; k--) {\n\t\t\t\tcnt++; X = min(X, x[k][i]);\n\t\t\t\tif (X == 0) { break; }\n\t\t\t\tmaxn = max(maxn, X*cnt);\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nsize_t get_largest_rectangle(vector<vector<int>> &g) {\n    size_t h=g.size(), w=g[0].size();\n\n    vector<vector<size_t>> dp(h, vector<size_t>(w+1));\n    size_t max_area=0;\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j) {\n            dp[i][j] = !g[i][j];\n            max_area |= dp[i][j];\n        }\n\n    for (size_t i=1; i<h; ++i)\n        for (size_t j=0; j<w; ++j)\n            if (dp[i][j])\n                dp[i][j] += dp[i-1][j];\n\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j) {\n            if (!dp[i][j]) continue;\n\n            size_t min_height=dp[i][j];\n            for (size_t k=j+1; k<=w; ++k) {\n                if (max_area < (k-j)*min_height)\n                    max_area = (k-j)*min_height;\n\n                if (!dp[i][k])\n                    break;\n\n                if (min_height > dp[i][k])\n                    min_height = dp[i][k];\n            }\n        }\n\n    return max_area;\n}\n\nint main() {\n    size_t h, w;\n    scanf(\"%zu %zu\", &h, &w);\n\n    vector<vector<int>> g(h, vector<int>(w));\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j)\n            scanf(\"%d\", &g[i][j]);\n\n    printf(\"%zu\\n\", get_largest_rectangle(g));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\nusing namespace std;\nconst int MAX=1400;\nint buffer[MAX][MAX],T[MAX][MAX];\nint getLargestRectangle(int w,int buf[]){\n    stack<pair<int,int> >S;//first:pos,second:height\n    pair<int,int>rect;\n    buf[w]=0;\n    int maxv=0;\n    for(int i=0;i<=w;i++){\n        rect.first=i;\n        rect.second=buf[i];\n        if(S.empty())S.push(rect);\n        else if (rect.second>S.top().second)S.push(rect);\n        else if(rect.second<S.top().second){\n            while(!S.empty() && rect.second<S.top().second){\n                int x=S.top().first;\n                int h=S.top().second;\n                S.pop();\n                maxv=max(maxv,h*(i-x));\n                rect.first=x;\n            }\n            S.push(rect);\n        }\n    }\n    return maxv;\n}\nint getLargestRectangle(int h,int w){\n    for(int i=0;i<h;i++)\n        for(int j=0;j<w;j++)\n            if(buffer[i][j]==1)T[i][j]=0;\n            else\n                T[i][j]=i>0?T[i-1][j]+1:1;\n    int maxv=0;\n    for(int i=0;i<h;i++)\n        maxv=max(maxv,getLargestRectangle(w,T[i]));\n    return maxv;\n}\nint main()\n{\n    int H,W;\n    cin>>H>>W;\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            cin>>buffer[i][j];\n    cout<<getLargestRectangle(H,W)<<endl;\n    return 0;\n}\n    \n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <unordered_map>\nconstexpr int MOD = 1000000000 + 7;\nconstexpr int INF = 2000000000;\nusing namespace std;\nusing LL = long long;\n\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectangle(int size, int buffer[]) {\n\tstack<Rectangle> S;\n\tint maxv = 0;\n\tbuffer[size] = 0;\n\tfor (int i = 0; i < size; i++) {\n\t\tRectangle rect;\n\t\trect.height = buffer[i];\n\t\trect.pos = i;\n\t\tif (S.empty()) {\n\t\t\tS.push(rect);\n\t\t}\n\t\telse {\n\t\t\tif (S.top().height < rect.height)S.push(rect);\n\t\t\telse if (S.top().height > rect.height) {\n\t\t\t\tint target = i;\n\t\t\t\twhile (!S.empty() && S.top().height >= rect.height) {\n\t\t\t\t\tRectangle pre = S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tint area = pre.height*(i - pre.pos);\n\t\t\t\t\tmaxv = max(maxv, area);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos = target;\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxv;\n}\n\nint H, W;\nint Buffer[1400][1400];\nint T[1400][1400];\n\nint getLargestRectangle() {\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (Buffer[i][j]) {\n\t\t\t\tT[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tT[i][j] = (i > 0 ? T[i - 1][j] + 1 : 1);\n\t\t\t}\n\t\t}\n\t}\n\tint maxv = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tmaxv = max(maxv, getLargestRectangle(W, T[i]));\n\t}\n\treturn maxv;\n}\n\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> Buffer[i][j];\n\t\t}\n\t}\n\tcout << getLargestRectangle() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nint dp[1405][1405];\nint main(){\n    int h, w; cin >> h >> w;\n    for (int i = 0; i < h; i++)\n    {\n        for (int j = 0; j < w; j++)\n        {\n            bool c; cin >> c;\n            dp[i][j] = !c;\n        }\n    }\n    for (int i = 1; i < h; i++)\n    {\n        for (int j = 0; j < w; j++)\n        {\n            dp[i][j] = dp[i-1][j] * dp[i][j] + dp[i][j];\n        }\n    }\n    \n    stack<pair<int, int>> S;\n    int ans = 0;\n    for (int i = 0; i < h; i++)\n    {\n        for (int j = 0; j <= w; j++)\n        {  \n            if (S.empty()){S.push(make_pair(dp[i][j], j));continue;}\n\n            if (S.top().first < dp[i][j])\n            {\n                S.push(make_pair(dp[i][j], j));\n            }else if(S.top().first > dp[i][j])\n            {\n                int target = j;\n                while ((!S.empty()) && S.top().first >= dp[i][j])\n                {\n                    pair<int,int> num = S.top();S.pop();\n                    ans = max(ans, (j-num.second) * num.first);\n                    target = num.second;\n                }\n                S.push(make_pair(dp[i][j], target));\n            }\n        }\n        \n    }\n    cout << ans << endl;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n\tRectangle rect;\n\tfor(int i=0;i<x;i++){\n\t\tstack<Rectangle> stk;\n\t\t//rect.height = 0;\n\t\t//rect.pos = 0;\n\t\t//stk.push(rect);\n\t\tint pop=0;\n\t\tfor(int j=0;j<=y;j++){\n\t\t\trect.height = m[j][i];\n\t\t\trect.pos = j;\n\t\t\tif(stk.empty() || stk.top().height <= rect.height){\n\t\t\t\tstk.push(rect);\n\t\t\t}else{\n\t\t\t\t//printf(\"[-] %d %d\\n\",i,j);\n\t\t\t\tfor(;!stk.empty() && stk.top().height > rect.height;){\n\t\t\t\t\tpop++;\n\t\t\t\t\tRectangle pre = stk.top(); stk.pop();\n\t\t\t\t\t//pre.pos=stk\n\t\t\t\t\tint area = pre.height * (j - pre.pos);\n\t\t\t\t\tr = max(r, area);\n\t\t\t\t\t//printf(\"%d %d\\n\",target,pre.pos);\n\t\t\t\t\trect.pos = pre.pos;\n\t\t\t\t}\n\t\t\t\tstk.push(rect);\n\t\t\t}\n\t\t\tif(rect.height==0)pop=0;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nconst static int MAX = 1400;\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nstruct Rectangle{\n    int height;\n    int pos;\n};\n\nint getLargestRectangle(int size, int buffer[]){\n    std::stack<Rectangle> S;\n    int maxv = 0;\n    buffer[size] = 0;\n\n    for(int i = 0; i <= size; i++){\n        Rectangle rect;\n        rect.height = buffer[i];\n        rect.pos = i;\n        if( S.empty() ){\n            S.push(rect);\n        }else{\n            if(S.top().height < rect.height){\n                S.push(rect);\n            }else if(S.top().height > rect.height){\n                int target = i;\n                while(!S.empty() && S.top().height >= rect.height){\n                    Rectangle pre = S.top(); S.pop();\n                    int area = pre.height * (i - pre.pos);\n                    maxv = std::max(maxv, area);\n                    target = pre.pos;\n                }\n                rect.pos = target;\n                S.push(rect);\n            }\n        }\n    }\n    return maxv;\n}\n\n\nint getLargestRectangle(){\n    for(int j = 0; j < W; j++){\n        for(int i = 0; i < H; i++){\n            if(buffer[i][j]){\n                T[i][j] = 0;\n            }else{\n                T[i][j] = (i > 0) ? T[i-1][j] + 1 : 1;\n            }\n        }\n    }\n\n    int maxv = 0;\n    for(int i = 0; i < H; i++){\n        maxv = std::max( maxv, getLargestRectangle(W, T[i]) );\n    }\n\n    return maxv;\n}\n\nint main(void){\n\n    scanf(\"%d %d\", &H, &W);\n\n    for(int i = 0; i < H; i++){\n        for(int j = 0; j < W; j++){\n            scanf(\"%d\", &buffer[i][j]);\n        }\n    }\n    std::cout << getLargestRectangle() << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main()\n{\n\tint H, W;\n\tcin >> H >> W;\n\n\tvector<vector<int>> map;\n\tfor(int i = 0; i < H; i++)\n\t{\n\t\tvector<int> line;\n\t\tfor(int j = 0; j < W  + 1; j++)\n\t\t{\n\t\t\tif(j == W)\n\t\t\t{\n\t\t\t\tline.push_back(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint state;\n\t\t\tcin >> state;\n\t\t\tline.push_back(state == 0 ? 1 : 0);\n\t\t}\n\t\tmap.push_back(line);\n\t}\n\n\tfor(int i = 0; i < H-1; i++)\n\t{\n\t\tfor(int j = 0; j < W; j++)\n\t\t{\n\t\t\tif(map[i + 1][j] != 0)\n\t\t\t{\n\t\t\t\tmap[i + 1][j] += map[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tint maxValue = 0;\n\tfor(int i = 0; i < H; i++)\n\t{\n\t\tfor(int j = 0; j < W; j++)\n\t\t{\n\t\t\tint minHight = map[i][j];\n\t\t\tif(minHight == 0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int k = j + 1; k < W + 1; k++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(map[i][k] == 0)\n\t\t\t\t{\n\t\t\t\t\tint buf = k-j+1 * minHight;\n\t\t\t\t\tmaxValue = maxValue > buf ? maxValue : buf;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tminHight = minHight < map[i][k] ? minHight : map[i][k];\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxValue << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n\tint h,w,s,max=0;\n\tcin>>h>>w;\n\tint a[1401][1401]={};\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tcin>>s;\n\t\t\tif(s==0)a[i][j]=a[i][j-1]+1;\n\t\t\telse a[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=1;i<=w;i++){\n\t\tint f=0;\n\t\tfor(int j=1;j<=h;j++){\n\t\t\tif(a[j][i]>f) f=a[j][i];\n\t\t}\n\t\tfor(int j=1;j<=f;j++){\n\t\t\tint d=0;\n\t\t\tfor(int k=1;k<=h;k++){\n\t\t\t\tif(a[k][i]>=j){\n\t\t\t\t\td=d+j;\n\t\t\t\t\tif(max<d)max=d;\n\t\t\t\t}\n\t\t\t\telse d=0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << max << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define N 1405\nint H,W;\nint R[N][N];\n\nint rec(int f1,int c1,int f2,int c2)\n{\n    if(f1<0||f1>H-1||f2<0||f2>H-1||c1<0||c1>W-1||c2<0||c2>W-1||f1>f2||c1>c2) return -1;\n    if(f1==f2&&c1==c2) return 1-R[f1][c1];\n    for(int i=f1;i<=f2;i++)\n        for(int j=c1;j<=c2;j++)\n            if(R[i][j])\n            {\n                return max(rec(f1,c1,i-1,c2),max(rec(i+1,c1,f2,c2),max(rec(f1,c1,f2,j-1),rec(f1,j+1,f2,c2))));\n            }\n    return (f2-f1+1)*(c2-c1+1);\n}\n\nint main() {\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\n\tcin >> H >> W;\n\tfor(int i=0;i<H;i++)\n    {\n        for(int j=0;j<W;j++)\n        {\n            cin >> R[i][j];\n        }\n    }\n    int a = rec(0,0,H-1,W-1);\n    cout << a << \"\\n\";\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (int)(n); ++i)\n#define all(x) x.begin(),x.end()\n#define ln '\\n'\nconst double PI = acos(-1.0);\nconst long long MOD = 1000000007LL;\n//const long long MOD = 998244353LL;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true;} return false; }\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int H,W; cin >> H >> W;\n    vector<vector<int>> S(H, vector<int>(W));\n    rep(i,H) rep(j,W) cin >> S[i][j];\n\n    vector<vector<int>> A(H, vector<int>(W));\n    rep(i,H) {\n        rep(j,W) {\n            if (i) {\n                if (S[i][j]) A[i][j] = 0;\n                else A[i][j] = A[i-1][j]+1;\n            } else {\n                A[i][j] = 1-S[i][j];\n            }\n        }\n    } \n\n    int ans = 0;\n    rep(i,H) {\n        stack<pii> sta;\n        sta.emplace(0,-1);\n        rep(j,W) {\n            int w = j;\n            while (sta.top().first > A[i][j]) {\n                int h,left;\n                tie(h,left) = sta.top(); sta.pop();\n                chmax(ans, h*(j - left));\n                w = left;\n            }\n            if (sta.top().first < A[i][j]) {\n                sta.emplace(A[i][j],w);\n            }\n        }\n        while (!sta.empty()) {\n            int h,left;\n            tie(h,left) = sta.top(); sta.pop();\n            chmax(ans, h*(W - left));\n        }\n    }\n\n    cout << ans << ln;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>   \n#include<cstdio>  \n#include<algorithm>\n#include<stack>\nusing namespace std;\nconst int maxx = 1410;\n\nint H, W;\nint buffer[maxx][maxx];\nint T[maxx][maxx];\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectangle(int size, int height[]) {\n\tstack<Rectangle> S;\n\tint maxv = 0;\n\theight[size] = 0;\n\n\tfor (int i = 0; i <= size; i++) {\n\t\tRectangle rect;\n\t\trect.height = height[i];\n\t\trect.pos = i;\n\t\t// 当S为空\n\t\tif (S.empty())\n\t\t\tS.push(rect);\n\t\t// 栈顶的高度小于当前的高度\n\t\telse if (S.top().height < rect.height)\n\t\t\tS.push(rect);\n\t\t// 栈顶的高度大于当前的高度\n\t\telse if (S.top().height > rect.height) {\n\t\t\tint target = i;\n\t\t\t// 栈顶的高度大于等于当前的高度\n\t\t\t// 出现小于栈顶高度的代表pre.pos~i之间都存在高度为pre.height的干净瓷砖\n\t\t\t// 此时可以计算当前的面积\n\t\t\twhile (!S.empty() && S.top().height >= rect.height) {\n\t\t\t\tRectangle pre = S.top(); S.pop();\n\t\t\t\t// 长 * 宽\n\t\t\t\tint area = pre.height * (i - pre.pos);\n\t\t\t\tmaxv = max(maxv, area);\n\t\t\t\ttarget = pre.pos;\n\t\t\t}\n\t\t\t// 加上前面的宽度（下标设置为之前的），以便后面有合适的瓷砖进行计算\n\t\t\trect.pos = target;\n\t\t\tS.push(rect);\n\t\t}\n\t}\n\treturn maxv;\n}\n\nint solve() {\n\t// 以行为直方图,计算纵向的干净长度\n\tfor (int j = 0; j < W; j++) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tif (buffer[i][j])\n\t\t\t\tT[i][j] = 0;\n\t\t\telse\n\t\t\t\tT[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n\t\t}\n\t}\n\n\t// 从行计算出当前行的最大面积\n\tint maxv = 0;\n\tfor (int i = 0; i < H; i++)\n\t\tmaxv = max(maxv, getLargestRectangle(W, T[i]));\n\treturn maxv;\n}\nint main()\n{\n\tscanf(\"%d %d\", &H, &W);\n\tfor (int i = 0; i < H; i++)\n\t\tfor (int j = 0; j < W; j++)\n\t\t\tscanf(\"%d\", &buffer[i][j]);\n\t\n\tprintf(\"%d\\n\", solve());\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int INF=2147483647;\nconst double pi=3.1415926535897932384626;\ninline ll read(){\n\tll x=0,f=1;\n\tchar ch=getchar();\n\twhile(ch<'0'||ch>'9'){\n\t\tif(ch=='-') f=-1;\n\t\tch=getchar();\n\t}\n\twhile(ch>='0'&&ch<='9'){\n\t\tx=(x<<1)+(x<<3)+(ch^48);\n\t\tch=getchar();\n\t}\n\treturn x*f;\n}\nconst int maxn=1405;\nint h,w,a[maxn][maxn],b[maxn][maxn],ans;\nstruct rectangle{\n\tint height,pos;\n};\nint solve(int w,int c[]){\n\tstack<rectangle> s;\n\tint maxx=0;\n\tc[w+1]=0;\n\tfor(int i=1;i<=w+1;i++){\n\t\trectangle rect;\n\t\trect.height=c[i];\n\t\trect.pos=i;\n\t\tif(s.empty()) s.push(rect);\n\t\telse{\n\t\t\tif(s.top().height<rect.height) s.push(rect);\n\t\t\telse if(s.top().height>rect.height){\n\t\t\t\tint target=i;\n\t\t\t\twhile(!s.empty()&&s.top().height>=rect.height){\n\t\t\t\t\trectangle pre=s.top();\n\t\t\t\t\ts.pop();\n\t\t\t\t\tint area=pre.height*(i-pre.pos);\n\t\t\t\t\tmaxx=max(maxx,area);\n\t\t\t\t\ttarget=pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos=target;\n\t\t\t\ts.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxx;\n}\nint main(){\n\th=read(),w=read();\n\tfor(int i=1;i<=h;i++)\n\t\tfor(int j=1;j<=w;j++)\n\t\t\ta[i][j]=read();\t\t\n\tfor(int i=1;i<=h;i++)\n\t\tfor(int j=1;j<=w;j++)\n\t\t\tif(a[i][j]) b[i][j]=0;\n\t\t\telse b[i][j]=b[i-1][j]+1;\n\tfor(int i=1;i<=h;i++) ans=max(ans,solve(w,b[i]));\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<stack>\n#include<algorithm>\n#define MAX 1400\n\nusing namespace std;\n\nstruct Rectangle{int height; int pos;};\n\nint getLargestRectangle(int size, int buffer[]){\n    stack<Rectangle> S;\n    int maxv = 0;\n    buffer[size] = 0;\n\n    for(int i=0; i<=size; i++){\n        Rectangle rect;\n        rect.height = buffer[i];\n        rect.pos = i;\n        if(S.empty()){\n            S.push(rect);\n        }else{\n            if(S.top().height < rect.height){\n                S.push(rect);\n            }else if(S.top().height > rect.height){\n                int target = i;\n                while (!S.empty() && S.top().height >= rect.height){\n                    Rectangle pre = S.top(); S.pop();\n                    int area = pre.height * (i - pre.pos);\n                    maxv = max(maxv, area);\n                    target = pre.pos;\n                }\n                rect.pos = target;\n                S.push(rect);\n            }\n        }\n    }\n    return maxv;\n}\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle(){\n    for(int j=0; j<W; j++){\n        for(int i=0; i<H; i++){\n            if(buffer[i][j]){\n                T[i][j] = 0;\n            }else{\n                T[i][j] = (i>0) ? T[i-1][j] + 1 : 1;\n            }\n        }\n    }\n\n    int maxv = 0;\n    for(int i=0; i<H; i++){\n        maxv = max(maxv, getLargestRectangle(W, T[i]));\n    }\n\n    return maxv;\n}\n\nint main(){\n    scanf(\"%d %d\", &H, &W);\n    for(int i=0; i<H; i++){\n        for(int j=0; j<W; j++){\n            scanf(\"%d\", &buffer[i][j]);\n        }\n    }\n    cout << getLargestRectangle() << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint m[SIZ][SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,M=0;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tfor(r=i=0;i<x;i++)for(j=0;j<y;j++)for(M=x,k=j;k<y;k++){\n\t\tif(M>m[k][i])M=m[k][i];\n\t\tint z=k-j+1;\n\t\tif(r<M*z)r=M*z;\n\t}\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1405, INF = 0x3f3f3f3f;\nint n, m;\nint a[N][N];\nint s[N], p;\n\ninline int nextInt(void) {\n\tint res;\n\tscanf(\"%d\", &res);\n\treturn res;\n}\n\ninline int DP(int x) {\n\tint ans = 0;\n\tp = 0;\n\ts[++p] = a[x][1];\n\tfor(int i=2;i<=m+1;i++)\n\t\tif (a[x][i] >= s[p]) {\n\t\t\ts[++p] = a[x][i];\n\t\t}\n\t\telse {\n\t\t\tint t = p;\n\t\t\twhile (t&&s[t] > a[x][i]) {\n\t\t\t\tans = max(ans, s[t] * (p - t + 1));\n\t\t\t\tt--;\n\t\t\t}\n\t\t}\n\treturn ans;\n}\n\nsigned main(void) {\n\tmemset(a, 0, sizeof(a));\n\tn = nextInt();\n\tm = nextInt();\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= m; j++)\n\t\t\tif (!nextInt())\n\t\t\t\ta[i][j] = a[i][j - 1] + 1;\n\t/*/\n\tfor (int i = 1; i <= n; i++, cout << endl)\n\t\tfor (int j = 1; j <= m; j++, cout << \" \")\n\t\t\tcout << a[i][j];\n\t*/\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tans = max(ans, DP(i));\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 2000\nint x[MAX_N][MAX_N];\nint H, W;\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> x[i][j];\n\t\t}\n\t\tfor (int j = 1; j < W; j++) {\n\t\t\tif (x[i][j] == 1) {\n\t\t\t\tx[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i][j] = x[i][j - 1] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tint maxn = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tint X = x[i][j], cnt = 0;\n\t\t\tfor (int k = j; k >= 0; k--) {\n\t\t\t\tcnt++; X = min(X, x[i][k]);\n\t\t\t\tif (X == 0) { break; }\n\t\t\t\tmaxn = max(maxn, X*cnt);\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n#define MAX 1400\nstruct Rectangle{int height; int pos;};\n\nint getLargestRectangle(int size,int buffer[])\n{\n  stack<Rectangle> S;\n  int maxv=0;\n  buffer[size]=0;\n  for(int i=0;i<=size;i++)\n    {\n      Rectangle rect;\n      rect.height=buffer[i];\n      rect.pos=i;\n      if(S.empty())\n\t{\n\t  S.push(rect);\n\t}\n      else\n\t{\n\t  if(S.top().height < rect.height)\n\t    {\n\t      S.push(rect);\n\t    }\n\t  else if(S.top().height > rect.height)\n\t    {\n\t      int target=i;\n\t      while(!S.empty() && S.top().height >= rect.height)\n\t\t{\n\t\t  Rectangle pre = S.top();S.pop();\n\t\t  int area = pre.height * (i-pre.pos);\n\t\t  maxv=max(maxv,area);\n\t\t  target=pre.pos;\n\t\t}\n\t      rect.pos=target;\n\t      S.push(rect);\n\t    }\n\t}\n    }\n  return maxv;\n}\n\nint H,W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle()\n{\n  for(int j=0;j<W;j++)\n    {\n      for(int i=0;i<H;i++)\n\t{\n\t  if(buffer[i][j])\n\t    {\n\t      T[i][j]=0;\n\t    }\n\t  else\n\t    {\n\t      T[i][j]=(i>0) ? T[i-1][j] +1 : 1;\n\t    }\n\t}\n    }\n  int maxv=0;\n  for(int i=0;i<H;i++)\n    {\n      maxv=max(maxv,getLargestRectangle(W,T[i]));\n    }\n  return maxv;\n}\n\n\nint main(void)\n{\n  int H,W;\n  scanf(\"%d %d\",&H,&W);\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  scanf(\"%d\",&buffer[i][j]);\n\t}\n    }\n  cout << getLargestRectangle() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing VI = vector<ll>;\nusing VV = vector<VI>;\nusing VS = vector<string>;\nusing PII = pair<ll, ll>;\n\n// tourist set\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p);\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p);\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p);\n\nstring to_string(const string& s) {\n  return '\"' + s + '\"';\n}\n\nstring to_string(const char* s) {\n  return to_string((string) s);\n}\n\nstring to_string(bool b) {\n  return (b ? \"true\" : \"false\");\n}\n\nstring to_string(vector<bool> v) {\n  bool first = true;\n  string res = \"{\";\n  for (int i = 0; i < static_cast<int>(v.size()); i++) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(v[i]);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <size_t N>\nstring to_string(bitset<N> v) {\n  string res = \"\";\n  for (size_t i = 0; i < N; i++) {\n    res += static_cast<char>('0' + v[i]);\n  }\n  return res;\n}\n\ntemplate <typename A>\nstring to_string(A v) {\n  bool first = true;\n  string res = \"{\";\n  for (const auto &x : v) {\n    if (!first) {\n      res += \", \";\n    }\n    first = false;\n    res += to_string(x);\n  }\n  res += \"}\";\n  return res;\n}\n\ntemplate <typename A, typename B>\nstring to_string(pair<A, B> p) {\n  return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\";\n}\n\ntemplate <typename A, typename B, typename C>\nstring to_string(tuple<A, B, C> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \")\";\n}\n\ntemplate <typename A, typename B, typename C, typename D>\nstring to_string(tuple<A, B, C, D> p) {\n  return \"(\" + to_string(get<0>(p)) + \", \" + to_string(get<1>(p)) + \", \" + to_string(get<2>(p)) + \", \" + to_string(get<3>(p)) + \")\";\n}\n\nvoid debug_out() { cerr << '\\n'; }\n\ntemplate <typename Head, typename... Tail>\nvoid debug_out(Head H, Tail... T) {\n  cerr << \" \" << to_string(H);\n  debug_out(T...);\n}\n\n#ifdef LOCAL\n#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__)\n#else\n#define debug(...) 42\n#endif\n// tourist set end\n\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\n\n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define rep(i,b) FOR(i, 0, b)\n#define ALL(v) (v).begin(), (v).end()\n#define p(s) cout<<(s)<<'\\n'\n#define p2(s, t) cout << (s) << \" \" << (t) << '\\n'\n#define br() p(\"\")\n#define pn(s) cout << (#s) << \" \" << (s) << '\\n'\n#define p_yes() p(\"YES\")\n#define p_no() p(\"NO\")\n#define SZ(x) ((int)(x).size())\n#define SORT(A) sort(ALL(A))\n#define RSORT(A) sort(ALL(A), greater<ll>())\n#define MP make_pair\n\nvoid no(){p_no(); exit(0);}\nvoid yes(){p_yes(); exit(0);}\n\nconst ll mod = 1e9 + 7;\nconst ll inf = 1e18;\nconst double PI = acos(-1);\n\nll A[1500][1500];\n\n// ヒストグラムを与えると、最大の長方形の面積を返します\nll f(VI& V){\n  ll ma = 0;\n  stack<PII> sta;\n  ll N = V.size();\n  rep(i, N){\n    ll v = V[i];\n    // スタックが空ならそのまま積む\n    if(sta.size()==0){\n      sta.push(MP(v, i));\n    }\n    // 高さが同じ\n    else if(sta.top().first==v){\n      continue;\n    }\n    // より高いものが来た\n    else if(sta.top().first<v){\n      sta.push(MP(v, i));\n    }\n    // より低いものが来た\n    else{\n      ll last_pos;\n      // スタックの方が高いものは全部取り除いて精算する（面積を求める）\n      while(sta.size()>0 && sta.top().first>v){\n        auto pa = sta.top(); sta.pop();\n        ll area = pa.first * (i-pa.second);\n        chmax(ma, area);\n        last_pos = pa.second;\n      }\n      // 今回の値をスタックに積む（位置は、最後にスタックから取り除いたものの位置）\n      sta.push(MP(v, last_pos));\n    }\n  }\n  // stackに残っている分\n  while(sta.size()>0){\n    auto pa = sta.top(); sta.pop();\n    ll area = pa.first * (N-pa.second);\n    chmax(ma, area);\n  }\n  return ma;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    // input\n    ll H, W; cin >> H >> W;\n\n    rep(i, H){\n      rep(j, W){\n        cin >> A[i][j];\n      }\n    }\n\n    VV h(H, VI(W)); // histogram\n    rep(i, W){\n      // 列ごとに\n      ll now = 0;\n      rep(j, H){\n        if(A[j][i]==0){\n          now++;\n        }else{\n          now = 0;\n        }\n        h[j][i] = now;\n      }\n    }\n\n    ll ma = 0;\n    rep(i, H){\n      ll v = f(h[i]);\n      chmax(ma, v);\n    }\n    p(ma);\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n\nusing namespace std;\n\n\nint c[1401][1401];\nint dp[1401][1401];\n\nstruct rt {\n\tint point;\n\tint height;\n};\n\nint max_in_x(int *l,int w) {\n\tstack<rt> st;\n\tint cur = 0;\n\tint sum = 0;\n\n\t*(l + w ) = 0;\n\n\n\twhile(cur < w || !st.empty()) {\n\t\tint next_height = 0;\n\n\t\tif (cur < w) {\n\t\t\tint current_height = *(l + cur);\n\t\t\tif (st.empty() || st.top().height < current_height) {\n\t\t\t\trt a;\n\t\t\t\ta.point = cur;\n\t\t\t\ta.height = current_height;\n\t\t\t\tst.push(a);\n\t\t\t\tcur++;\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\tif (st.top().height == current_height) {\n\t\t\t\tcur++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (st.top().point != cur - 1) {\n\t\t\t\trt a;\n\t\t\t\ta.point = cur - 1;\n\t\t\t\ta.height = *(l + cur -1);\n\t\t\t\tst.push(a);\n\t\t\t}\n\t\t\tnext_height = *(l + cur);\t\t\t\n\t\t} else {\n\t\t\tif (st.top().point != w - 1) {\n\t\t\t\trt a;\n\t\t\t\ta.point = w - 1;\n\t\t\t\ta.height = *(l + w -1);\n\t\t\t\tst.push(a);\n\t\t\t}\t\t\t\n\t\t}\n\n\t\trt start = st.top();\n\t\trt current;\n\n\t\t//cout << \"dec start point:\" << start.point  << endl;\n\n\t\twhile(!st.empty()) {\n\t\t\tcurrent = st.top();\n\t\t\tif (current.height == next_height && cur < w) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tst.pop();\n\n\n\t\t\tif (current.height < next_height) {\n\t\t\t\tcurrent.height = next_height;\n\t\t\t\tcurrent.point ++;\n\t\t\t\tst.push(current);\n\t\t\t\t//cout << \"    stack.point:\" << current.point <<  \" stack height:\" << next_height << endl; \n\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t//cout << \"    current.point:\" << current.point  << \" h:\" << current.height \n\t\t\t// << \" v:\" << (start.point - current.point + 1) * current.height <<  endl;\n\n\t\t\tsum = max(sum, (start.point - current.point + 1) * current.height);\n\t\t\n\t\t}\n\t}\n\treturn sum;\n}\n\n\nint main() {\n\tint W,H;\n\tcin >> H >> W;\n\t\n\tint v_max = 0;\n\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x < W; x++) {\n\n\t\t\tcin >> c[y][x];\n\t\t\tc[y][x] ^= 1;\n\t\t\tdp[y][x] = 0;\t\t\t\n\t\t}\n\t}\n\tfor (int x = 0; x < W; x++) {\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tif (c[y][x] == 0) {\n\t\t\t\tdp[y][x] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (y==0) {\n\t\t\t\tdp[y][x] = 1;\n\t\t\t\tcontinue;\t\t\t\t\n\t\t\t} \n\t\t\tdp[y][x] = dp[y-1][x] + 1;\n\t\t}\n\t}\n\n\tint s_max = 0;\n\n/*\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x < W; x++) {\n\t\t\tcout << setw(5) << dp[y][x] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n*/\n\n\tfor( int y = 0; y < H; y++) {\n\t\t\n\t\t//cout << \"** s_max y:\" << y << endl;\n\t\tint ret = max_in_x(dp[y],W); \n\t\t//cout << \"v:\" << ret << endl;\n\t\ts_max = max(s_max,ret);\n\t}\n\n\tcout << s_max << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//注意点\n//Tは3つの値を持つ構造\n//だがワイルドカードとしても使っている\n#include <bits/stdc++.h>\nusing namespace std;\n//@起動時\nstruct initon {\n    initon() {\n        cin.tie(0);\n        ios::sync_with_stdio(false);\n        cout.setf(ios::fixed);\n        cout.precision(16);\n        srand((unsigned) clock() + (unsigned) time(NULL));\n    };\n} __initon;\n\n//@必須構造\nstruct T {\n    int f, s, t;\n    T() { f = -1, s = -1, t = -1; }\n    T(int f, int s, int t) : f(f), s(s), t(t) {}\n    bool operator<(const T &r) const {\n        return f != r.f ? f < r.f : s != r.s ? s < r.s : t < r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 大きい順\n    }\n    bool operator>(const T &r) const {\n        return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t;\n        //return f != r.f ? f > r.f : s != r.s ? s > r.s : t > r.t; 小さい順\n    }\n    int operator[](int i) {\n        assert(i < 3);\n        return i == 0 ? f : i == 1 ? s : t;\n    }\n};\n\n//@マクロ省略系 型,構造\n\n#define int long long\n#define ll long long\n#define double long double\n#define ull unsigned long long\nusing dou = double;\nusing itn = int;\nusing str = string;\nusing bo= bool;\nusing P = pair<ll, ll>;\n#define F first\n#define fi first\n#define S second\n#define se second\n#define vec vector\n#define beg begin\n#define rbeg rbegin\n#define con continue\n#define bre break\n#define brk break\n#define is ==\n\n\n//マクロ省略系 コンテナ\nusing vi = vector<int>;\n#define vvi(a, b, c) vec<vi> a(b,vi(c))\nusing vb = vector<bool>;\n#define vvb(a, b, c) vec<vb> a(b,vb(c))\nusing vs = vector<string>;\n#define vvs(a, b, c) vec<vs> a(b,vs(c))\nusing vl = vector<ll>;\n#define vvl(a, b, c) vec<vl> a(b,vl(c))\nusing vd = vector<double>;\n#define vvd(a, b, c) vec<vd> a(b,vd(c))\nusing vc=vector<char>;\n#define vvc(a, b, c) vec<vc> a(b,vc(c))\nusing vp = vector<P>;\n#define vvp(a, b, c) vec<vp> a(b,vp(c))\nusing vt = vector<T>;\n#define vvt(a, b, c) vec<vt> a(b,vt(c))\n#define v3i(a, b, c, d) vector<vector<vi>> a(b, vector<vi>(c, vi(d)))\n#define v3d(a, b, c, d) vector<vector<vd>> a(b, vector<vd>(c, vd(d)))\n#define v3m(a, b, c, d) vector<vector<vm>> a(b, vector<vm>(c, vm(d)))\n#define PQ priority_queue<ll, vector<ll>, greater<ll> >\nusing seti = set<int>;\n#define uset unordered_set\n#define mset multiset\n#define umap unordered_map\n#define mmap multimap\n\n//マクロ 繰り返し\n#define _overloadrep(_1, _2, _3, name, ...) name\n# define _rep(i, n) for(int i = 0,_lim=n; i < _lim ; i++)\n#define repi(i, m, n) for(int i = m,_lim=n; i < _lim ; i++)\n#define rep(...) _overloadrep(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define _rer(i, n) for(int i = n; i >= 0 ; i--)\n#define reri(i, m, n) for(int i = m,_lim=n; i >= _lim ; i--)\n#define rer(...) _overloadrep(__VA_ARGS__,reri,_rer,)(__VA_ARGS__)\n#define fora(a, b) for(auto&& a : b)\n#define forg(gi, ve) if (ve.size())for (int gi = 0, f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost; gi < ve.size(); gi++,f = ve[gi].from, t = ve[gi].to, c = ve[gi].cost)\n\n//マクロ 定数\n#define k4 10101\n#define k5 101010\n#define k6 1010101\n#define k7 10101010\nconst int inf = (int) 1e9 + 100;\nconst ll linf = (ll) 1e18 + 100;\nconst double eps = 1e-9;\nconst int y4[] = {-1, 1, 0, 0};\nconst int x4[] = {0, 0, -1, 1};\nconst int y8[] = {0, 1, 0, -1, -1, 1, 1, -1};\nconst int x8[] = {1, 0, -1, 0, 1, -1, 1, -1};\n\n//マクロ省略形 関数等\n#define arsz(a) (sizeof(a)/sizeof(a[0]))\n#define s(a) (a.size())\n#define rs(a) (a.resize())\n#define mp make_pair\n#define pb push_back\n#define pf push_front\n#define eb emplace_back\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n\n//@拡張系 こう出来るべきというもの\n\nnamespace std {\n    template<> class hash<std::pair<signed, signed>> {\n    public:\n        size_t operator()(const std::pair<signed, signed> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n    template<> class hash<std::pair<ll, ll>> {\n    public:\n        size_t operator()(const std::pair<ll, ll> &x) const {\n            return hash<ll>()(((ll) x.first << 32) + x.second);\n        }\n    };\n}\nistream &operator>>(istream &iss, P &a) {\n    iss >> a.first >> a.second;\n    return iss;\n}\ntemplate<typename T> istream &operator>>(istream &iss, vector<T> &vec) {\n    for (T &x: vec) iss >> x;\n    return iss;\n}\ntemplate<typename T> ostream &operator<<(ostream &os, vector <T> &vec) {\n    for (int i = 0; i < vec.size(); i++)os << vec[i] << (i + 1 == vec.size() ? \"\" : \" \");\n    return os;\n}\ntemplate<class T> inline void sort(vector<T> &a) { sort(a.begin(), a.end()); };\ntemplate<class T> inline void rsort(vector<T> &a) { sort(a.begin(), a.end(), greater<T>()); };\ntemplate<class T> inline void sort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len); };\ntemplate<class T> inline void rsort(vector<T> &a, int len) { sort(a.begin(), a.begin() + len, greater<T>()); };\ntemplate<class U> inline void sortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = s(a);\n    assert(n == s(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    sort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class U> inline void rsortp(vector<U> &a, vector<U> &b) {\n    vp c;\n    int n = s(a);\n    assert(n == s(b));\n    rep(i, n)c.eb(a[i], b[i]);\n    rsort(c);\n    rep(i, n) {\n        a[i] = c[i].first;\n        b[i] = c[i].second;\n    }\n};\ntemplate<class T> inline void sort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)sort(a[i]); }\ntemplate<class T> inline void rsort2(vector<vector<T>> &a) { for (int i = 0, n = a.size(); i < n; i++)rsort(a[i]); }\ntemplate<typename A, size_t N, typename T> void fill(A (&a)[N], const T &v) { rep(i, N)a[i] = v; }\ntemplate<typename A, size_t N, size_t O, typename T> void fill(A (&a)[N][O], const T &v) { rep(i, N)rep(j, O)a[i][j] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, typename T> void fill(A (&a)[N][O][P], const T &v) { rep(i, N)rep(j, O)rep(k, P)a[i][j][k] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, typename T> void fill(A (&a)[N][O][P][Q], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)a[i][j][k][l] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, typename T> void fill(A (&a)[N][O][P][Q][R], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)a[i][j][k][l][m] = v; }\ntemplate<typename A, size_t N, size_t O, size_t P, size_t Q, size_t R, size_t S, typename T> void fill(A (&a)[N][O][P][Q][R][S], const T &v) { rep(i, N)rep(j, O)rep(k, P)rep(l, Q)rep(m, R)rep(n, S)a[i][j][k][l][m][n] = v; }\n\ntemplate<typename V, typename T>\nvoid fill(V &xx, const T &vall) {\n    xx = vall;\n}\ntemplate<typename V, typename T>\nvoid fill(vector<V> &vecc, const T &vall) {\n    for (auto &vx: vecc) fill(vx, vall);\n}\ntemplate<typename V, typename H> void resize(vector<V> &vec, const H head) {  //再帰の終端。 可変長templateの長さが 0 になるとこっちが呼ばれる。\n    vec.resize(head);\n}\ntemplate<typename V, typename H, typename ... T> void resize(vector<V> &vec, const H &head, const T ... tail) {\n    vec.resize(head);\n    for (auto &v: vec) resize(v, tail...);\n}\n//@汎用便利関数 入力\ntemplate<typename T = int> T in() {\n    T x;\n    cin >> x;\n    return (x);\n}\nstring sin() { return in<string>(); }\ndouble din() { return in<double>(); }\nll lin() { return in<ll>(); }\n#define na(a, n) a.resize(n); rep(i,n) cin >> a[i];\n#define nad(a, n) a.resize(n); rep(i,n) cin >> a[i], a[i]--;\n#define na2(a, b, n) a.resize(n),b.resize(n);rep(i, n)cin >> a[i] >> b[i];\n#define na2d(a, b, n) a.resize(n),b.resize(n);rep(i, n)cin >> a[i] >> b[i],a[i]--,b[i]--;\n#define na3(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n)cin >> a[i] >> b[i] >> c[i];\n#define na3d(a, b, c, n) a.resize(n),b.resize(n),c.resize(n);   rep(i, n)cin >> a[i] >> b[i] >> c[i],a[i]--,b[i]--,c[i]--;\n#define nt(a, h, w) resize(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi];\n#define ntd(a, h, w) rs(a,h,w);rep(hi,h)rep(wi,w) cin >> a[hi][wi], a[hi][wi]--;\n#define ntp(a, h, w) fill(a,'#');rep(hi,1,h+1)rep(wi,1,w+1) cin >> a[hi][wi];\n\n//汎用便利関数 出力\ntemplate<class T> void out(T x) { typeid(x) == typeid(double) ? cout << fixed << setprecision(10) << x << endl : cout << x << endl; }\n//デバッグ\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\nll sig(ll t) { return (1 + t) * t / 2; }\nll sig(ll s, ll t) { return (s + t) * (t - s + 1) / 2; }\n\nint get(int a, int keta) { return (a / (int) pow(10, keta)) % 10; }\nint keta(int v) {\n    int cou = 0;\n    while (v) { cou++, v %= 10; }\n    return cou;\n}\n\ntemplate<class T> void imo(vector<T> &v) {\n    int n = v.size();\n    rep(i, n - 1)v[i + 1] += v[i];\n}\n\ntemplate<class T, class U> bool chmax(T &a, const U &b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T, class U> bool chmin(T &a, const U &b) {\n    if (b < a) {\n        a = b;\n        return true;\n    }\n    return false;\n}\nint ma = -linf * 3;\nint mi = linf * 3;\n\ntemplate<class T> T min(T a, signed b) {\n    return a < b ? a : b;\n}\n\ntemplate<class T> T max(T a, signed b) {\n    return a < b ? b : a;\n}\n\ntemplate<class T> T min(T a, T b, T c) {\n    return a >= b ? b >= c ? c : b : a >= c ? c : a;\n}\ntemplate<class T> T max(T a, T b, T c) {\n    return a <= b ? b <= c ? c : b : a <= c ? c : a;\n}\n\ntemplate<class T> T min(vector<T> a) {\n    return *min_element(all(a));\n}\ntemplate<class T> T min(vector<T> a, int n) {\n    return *min_element(a.begin(), a.begin() + min(n, s(a)));\n}\ntemplate<class T> T min(vector<T> a, int s, int n) {\n    return *min_element(a.begin() + s, a.begin() + min(n, s(a)));\n}\ntemplate<class T> T max(vector<T> a) {\n    return *max_element(all(a));\n}\ntemplate<class T> T max(vector<T> a, int n) {\n    return *max_element(a.begin(), a.begin() + min(n, s(a)));\n}\ntemplate<class T> T max(vector<T> a, int s, int n) {\n    return *max_element(a.begin() + s, a.begin() + min(n, s(a)));\n}\n\ntemplate<class T> T min(T a[]) {\n    T res = a[0];\n    rep(i, arsz(a))chmin(res, a[i]);\n    return res;\n}\n\ntemplate<class T> T max(T a[]) {\n    T res = a[0];\n    rep(i, arsz(a))chmax(res, a[i]);\n    return res;\n}\ntemplate<class T> T sum(vector<T> v, int len = -1) {\n    if (len == -1)len = v.size();\n    T res = 0;\n    chmin(len, v.size());\n    rep(i, len)res += v[i];\n    return res;\n}\ntemplate<class T> T sum(vector<vector<T>> &v, int h = -1, int w = -1) {\n    if (h == -1)h = v.size();\n    if (w == -1)w = v[0].size();\n    T res = 0;\n    chmin(h, v.size());\n    chmin(w, v[0].size());\n    rep(i, h)rep(j, w)res += v[i][j];\n    return res;\n}\n\nP sump(vp &v, int len = -1) {\n    if (len == -1)len = v.size();\n    P res = {0, 0};\n    chmin(len, v.size());\n    rep(i, len) {\n        res.F += v[i].F;\n        res.S += v[i].S;\n    }\n    return res;\n}\ntemplate<class T> T *negarr(int size) {\n    T *body = (T *) malloc((size * 2 + 1) * sizeof(T));\n    return body + size;\n}\ntemplate<class T> T *negarr2(int h, int w) {\n    double **dummy1 = new double *[2 * h + 1];\n    double *dummy2 = new double[(2 * h + 1) * (2 * w + 1)];\n    dummy1[0] = dummy2 + w;\n    for (int i = 1; i <= 2 * h + 1; i++) {\n        dummy1[i] = dummy1[i - 1] + 2 * w + 1;\n    }\n    double **a = dummy1 + h;\n}\n\ntemplate<class T> vector<T> ruiv(vector<T> &a) {\n    vector<T> res(a.size() + 1);\n    rep(i, a.size())res[i + 1] = res[i] + a[i];\n    return res;\n}\n\ntemplate<class T> vector<T> ruim(vector<T> &a) {\n    vector<T> res(a.size() + 1, 1);\n    rep(i, a.size())res[i + 1] = res[i] * a[i];\n    return res;\n}\n//右から左にかけての半開区間 (-1 n-1]\ntemplate<class T> T *rrui(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    rer(i, len - 1)res[i - 1] = res[i] + a[i];\n    return res;\n}\n//掛け算\ntemplate<class T> T *rruim(vector<T> &a) {\n    int len = a.size();\n    T *body = (T *) malloc((len + 1) * sizeof(T));\n    T *res = body + 1;\n    res[len - 1] = 1;\n    rer(i, len - 1)res[i - 1] = res[i] * a[i];\n    return res;\n}\ntemplate<class T> void plus(vector<T> &a, T v = 1) { for (auto &&u :a)u += v; }\ntemplate<class T> void minu(vector<T> &a, T v = 1) { for (auto &&u :a)u -= v; }\ntemplate<class T> void minus(vector<T> &a, T v = 1) { for (auto &&u :a)u -= v; }\ninline bool inside(int y, int x, int H, int W) { return y >= 0 && x >= 0 && y < H && x < W; }\nll u(ll a) { return a < 0 ? 0 : a; }\n#define MIN(a) numeric_limits<a>::min()\n#define MAX(a) numeric_limits<a>::max()\ntemplate<class T> T min(vector<vector<T>> &a) {\n    T res = MAX(T);\n    rep(i, a.size())chmin(res, *min_element(all(a[i])));\n    return res;\n}\ntemplate<class T> T max(vector<vector<T>> &a) {\n    T res = MIN(T);\n    rep(i, a.size())chmax(res, *max_element(all(a[i])));\n    return res;\n}\nbool bget(ll m, int keta) { return (m >> keta) & 1; }\nint bget(ll m, int keta, int sinsuu) {\n    m /= (ll) pow(sinsuu, keta);\n    return m % sinsuu;\n}\ninline ll bit(int n) { return (1LL << (n)); }\ninline ll bit(int n, int sinsuu) { return (ll) pow(sinsuu, n); }\nint bcou(ll m) { return __builtin_popcount(m & 0xFFFFFFFF) + __builtin_popcount(m >> 32); }\n//初期化は0を渡す\n//要素が見つからなかったときに困る\n#define binarySearch(a, v) (binary_search(all(a),v))\n#define lowerIndex(a, v) (lower_bound(all(a),v)-a.begin())\n#define lowerBound(a, v) (*lower_bound(all(a),v))\n#define upperIndex(a, v) (upper_bound(all(a),v)-a.begin())\n#define upperBound(a, v) (*upper_bound(all(a),v))\n#define ans(a) cout<<a<<endl;continue;\n#define poll(a) q.front();q.pop()\n#define dpoll(a) q.front();q.pop_front()\n#define pollLast(a) q.back();q.pop_back()\n#define pollBack(a) q.back();q.pop_back()\ntemplate<class T> inline void fin(T s) { cout << s << endl, exit(0); }\n\ntemplate<class T> struct edge {\n    int from, to;\n    T cost;\n    int id;\n    int type;\n    edge(int f, int t, T c = 1, int id = -1, int ty = -1) : from(f), to(t), cost(c), id(id), type(ty) {}\n    bool operator<(const edge &b) const { return cost < b.cost; }\n    bool operator>(const edge &b) const { return cost > b.cost; }\n};\n\ntemplate<typename T> class graph {\nprotected:\n    vector<bool> _used;\npublic :\n    vector<vector<edge<T>>> g;\n    vector<edge<T>> edges;\n    int n, root = -1;\n    graph(int n) : n(n) { g.resize(n), _used.resize(n); }\n    void clear() { g.clear(), edges.clear(); }\n    void resize(int n) {\n        this->n = n;\n        g.resize(n);\n        _used.resize(n);\n    }\n    int size() { return g.size(); }\n    bool isleaf(int v) {\n        assert(root != -1);\n        return g[v].size() == 1 && g[v][0].from != root;\n    }\n    vector<edge<T> > &operator[](int i) { return g[i]; }\n    virtual void add(int from, int to, T cost, int ty) = 0;\n    virtual bool used(edge<T> &e) = 0;\n    virtual bool used(int id) = 0;\n    virtual void del(edge<T> &e) = 0;\n    virtual void del(int id) = 0;\n};\n\ntemplate<class T=int> class undigraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n    undigraph(int n) : graph<T>(n) {\n    }\n    void add(int f, int t, T cost = 1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n))vi(0)[0];\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, id, ty);\n        g[t].emplace_back(t, f, cost, id + 1, ty);\n        edges.emplace_back(f, t, cost, id, ty);\n        edges.emplace_back(t, f, cost, id + 1, ty);\n    }\n    void add(edge<T> &e) {\n        int f = e.from, t = e.to, ty = e.type;\n        T cost = e.cost;\n        add(f, t, cost, ty);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\ntemplate<typename T =ll> class digraph : public graph<T> {\npublic:\n    using graph<T>::g;\n    using graph<T>::n;\n    using graph<T>::edges;\n    using graph<T>::_used;\n\n    digraph(int n) : graph<T>(n) {}\n    void add(int f, int t, T cost = 1, int ty = -1) {\n        if (!(0 <= f && f < n && 0 <= t && t < n))vi(0)[0];;\n        int id = edges.size();\n        g[f].emplace_back(f, t, cost, ty, id);\n        edges.emplace_back(f, t, cost, ty, id);\n    }\n    bool used(edge<T> &e) { return _used[e.id]; }\n    bool used(int id) { return _used[id]; }\n    void del(edge<T> &e) { _used[e.id] = _used[e.id ^ 1] = 1; }\n    void del(int id) { _used[id] = _used[id ^ 1] = 1; }\n};\n\ntemplate<class T> vector<T> &dijkstra(const graph<T> &g, int s) {\n    if (!(0 <= s && s < g.n))vi(0)[0];\n    T initValue = MAX(T);\n    vector<T> dis(g.n, initValue);\n    priority_queue<pair<T, int>, vector<pair<T, int>>, greater<pair<T, int>>> q;\n    dis[s] = 0;\n    q.emplace(0, s);\n    while (q.size()) {\n        T nowc = q.top().F;\n        int i = q.top().S;\n        q.pop();\n        if (dis[i] != nowc)continue;\n        for (auto &&e  : g.g[i]) {\n            int to = e.to;\n            T cost = nowc + e.cost;\n            if (dis[to] > cost) {\n                dis[to] = cost;\n                q.emplace(dis[to], to);\n            }\n        }\n    }\n    //たどり着かないなら-1\n    for (auto &&d :dis) if (d == initValue)d = -1;\n    return dis;\n}\n\n//機能拡張\ntemplate<class T, class U> void operator+=(queue<T> &a, U v) {\n    a.push(v);\n}\ntemplate<class T, class U>\npriority_queue<T, vector<T>, greater<T> > &operator+=(priority_queue<T, vector<T>, greater<T> > &a, U v) {\n    a.push(v);\n    return a;\n}\ntemplate<class T, class U> priority_queue<T> &operator+=(priority_queue<T> &a, U v) {\n    a.push(v);\n    return a;\n}\ntemplate<class T, class U> set<T> &operator+=(set<T> &a, U v) {\n    a.insert(v);\n    return a;\n}\ntemplate<class T, class U> set<T, greater<T>> &operator+=(set<T, greater<T>> &a, U v) {\n    a.insert(v);\n    return a;\n}\n\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, U &v) {\n    a.pb(v);\n    return a;\n}\ntemplate<class T> vector<T> &operator+=(vector<T> &a, vector <T> &b) {\n    a.pb(b);\n    return a;\n}\ntemplate<class T, class U> vector<T> &operator+=(vector<T> &a, initializer_list<U> v) {\n    for (auto &&va :v)a.pb(va);\n    return a;\n}\nint n, m, k, d, H, W, x, y, z, q;\nint cou;\nstring s;\nvi a, b, c;\nvvi (S, 0, 0);\nvvi (his, 2222 ,2222 );\nvp p;\n\nvoid solve(int n_, vi a_) {\n    cin >> H >> W;\n    nt(S, H, W);\n    ma=0;\n    rep(h, H) {\n        rep(w, W) {\n            if (S[h][w]==0) {\n                his[h][w] = 1;\n                if (h)his[h][w] += his[h - 1][w];\n            }\n        }\n        his[h].pb(0);\n        vp st;\n        rep(w, W + 1) {\n            P b;\n            int j = w;\n            while (s(st) && st.back().S > his[h][w]) {\n                j = st.back().F;\n                chmax(ma, (w - j) * st.back().S);\n                st.pop_back();\n            }\n            st.eb(j,his[h][w]);\n        }\n    }\n    cout << ma << endl;\n\n}\n\nsigned main() {\n    solve(0, vi(1));\n    return 0;\n};\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint m[1400][1400];\nint dp[1400][1400];\n\nint main()\n{\n\tint a,b;\n\tscanf(\"%d%d\", &a, &b);\n\t\n\t\n\tfor(int i = 0; i < a; ++i){\n\t\tfor(int j = 0; j < b; ++j){\n\t\t\tscanf(\"%d\", &m[i][j]);\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < b; ++i){\n\t\tdp[0][i] = (m[0][i] == 0)? 1 : 0;\n\t}\n\t\n\tfor(int i = 1; i < a; ++i){\n\t\tfor(int j = 0; j < b; ++j){\n\t\t\tdp[i][j] = (m[i][j] == 0)? 1 + dp[i-1][j] : 0;\n\t\t}\n\t}\n\t\n\tint resp = 0;\n\t\n\tfor(int i = 0; i < a; ++i){\n\t\t\n\t\tvector<int> izq(b,0);\n\t\tizq[0] = -1;\n\t\t\n\t\tstack<pair<int,int> > el;\n\t\tel.push(make_pair(dp[i][0], 0));\n\t\t\n\t\tfor(int j = 1; j < b; ++j){\n\t\t\twhile(el.top().first >= dp[i][j]){\n\t\t\t\tel.pop();\n\t\t\t\tif(el.empty())break;\n\t\t\t}\n\t\t\tizq[j] = (el.empty())? -1 : el.top().second;\n\t\t\tel.push(make_pair(dp[i][j], j));\n\t\t}\n\t\t\n\t\tstack<pair<int,int> > el2;\n\t\tvector<int> der(b,0);\n\t\tder[b-1] = b;\n\t\tel2.push(make_pair(dp[i][b-1], b-1));\n\t\t\n\t\tfor(int j = b-2; j >= 0; --j){\n\t\t\twhile(el2.top().first >= dp[i][j]){\n\t\t\t\tel2.pop();\n\t\t\t\tif(el2.empty())break;\n\t\t\t}\n\t\t\tder[j] = (el2.empty())? b : el2.top().second;\n\t\t\tel2.push(make_pair(dp[i][j], j));\n\t\t}\n\t\t\n\t\tfor(int j = 0; j < b; ++j){\n\t\t\tresp = max(resp, dp[i][j]*(der[j] - izq[j] - 1));\n\t\t}\n\t\t\n\t}\n\t\n\tprintf(\"%d\\n\", resp);\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\nconst int adx[] = { 1,1,1,0,-1,-1,-1,0 };\nconst int ady[] = { 1,0,-1,-1,-1,0,1,1 };\n\nint add(const int base, const int plus) {\n\tif (!plus) {\n\t\treturn base + 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n//0 :?????????1:??????2:?????????3:??? 4:?????????5:??? 6:?????? 7:??? ???\nvector<vector<vector<int>>>get_cumulative_sum(const vector<vector<int>>&field) {\n\tconst int H = field.size();\n\tconst int W = field[0].size();\n\n\tvector<vector<vector<int>>>sums(H, vector<vector<int>>(W, vector<int>(4)));\n\tfor (int ny = 0; ny <H; ++ny) {\n\t\tfor (int nx = 0; nx <W; ++nx) {\n\t\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\t\tint py = ny - ady[k];\n\t\t\t\tint px = nx - adx[k];\n\t\t\t\tif (!(px >= 0 && px <W && py >= 0 && py <H))continue;\n\n\t\t\t\tsums[ny][nx][k] = add(sums[py][px][k], field[ny][nx]);\n\n\t\t\t}\n\t\t}\n\t}\n\tfor (int ny = H - 1; ny >= 0; --ny) {\n\t\tfor (int nx = 0; nx <W; ++nx) {\n\t\t\tfor (int k = 2; k < 4; ++k) {\n\t\t\t\tint py = ny - ady[k];\n\t\t\t\tint px = nx - adx[k];\n\t\t\t\tif (!(px >= 0 && px <W && py >= 0 && py <H))continue;\n\n\t\t\t\tsums[ny][nx][k] = add(sums[py][px][k], field[ny][nx]);\n\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sums;\n}\n\nint getans( vector<int>hs) {\n\ths.emplace_back(0);\n\tstack<pair<int, int>>que;\n\tque.emplace(-1, 0);\n\tint ans = 0;\n\tfor (int x = 0; x < hs.size(); ++x) {\n\t\t\n\t\tif (que.empty()) {\n\t\t\tque.push(make_pair(x, hs[x]));\n\t\t}\n\t\telse {\n\t\t\twhile (!que.empty()) {\n\t\t\t\tauto p = que.top();\n\t\t\t\tif (p.second < hs[x]) {\n\t\t\t\t\tque.push(make_pair(x,hs[x]));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (p.second == hs[x]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint area = (x - p.first)*p.second;\n\t\t\t\t\tans = max(ans, area);\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif (!que.empty()) {\n\t\t\t\t\t\tauto np = que.top();\n\t\t\t\t\t\tif (np.second < hs[x]) {\n\t\t\t\t\t\t\tque.push(make_pair(p.first, hs[x]));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\t\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>>field(H + 2, vector<int>(W + 2,1));\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tcin >> field[i + 1][j + 1];\n\t\t}\n\t}\n\tauto vs = get_cumulative_sum(field);\n\tint ans = 0;\n\t\n\tfor (int y = 1; y <= H; ++y) {\n\t\tvector<int>v;\n\t\tfor (int x = 1; x <= W; ++x) {\n\t\t\tv.push_back(vs[y][x][3]);\n\t\t}\n\t\tans = max(ans, getans(v));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n\tRectangle rect;\n\tfor(int i=0;i<x;i++){\n\t\tstack<Rectangle> stk;\n\t\tint pop=0;\n\t\tfor(int j=0;j<=y;j++){\n\t\t\trect.height = m[j][i];\n\t\t\trect.pos = j;\n\t\t\tif(stk.empty() || stk.top().height < rect.height){\n\t\t\t\tstk.push(rect);\n\t\t\t}else{\n\t\t\t\t//printf(\"[-] %d %d\\n\",i,j);\n\t\t\t\tint target = j;\n\t\t\t\tfor(;!stk.empty() && stk.top().height >= rect.height;){\n\t\t\t\t\tpop++;\n\t\t\t\t\tRectangle pre = stk.top(); stk.pop();\n\t\t\t\t\tint area = pre.height * (j - pre.pos);\n\t\t\t\t\tr = max(r, area);\n\t\t\t\t\t//printf(\"%d %d\\n\",target,pre.pos);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos = j-pop;//target;\n\t\t\t\tstk.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 2000\nint x[MAX_N][MAX_N];\nint H, W;\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> x[i][j];\n\t\t}\n\t\tif (x[i][0] == 1) { x[i][0] = 0; }\n\t\telse { x[i][0] = 1; }\n\t\tfor (int j = 1; j < W; j++) {\n\t\t\tif (x[i][j] == 1) {\n\t\t\t\tx[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i][j] = x[i][j - 1] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tint maxn = 0;\n\tfor (int i = 0; i < W; i++) {\n\t\tfor (int j = 0; j < H; j++) {\n\t\t\tint X = x[j][i], cnt = 0;\n\t\t\tfor (int k = j; k >= 0; k--) {\n\t\t\t\tcnt++; X = min(X, x[k][i]);\n\t\t\t\tif (X == 0) { break; }\n\t\t\t\tmaxn = max(maxn, X*cnt);\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct rect{\n\t  int left, height;\n\t  rect(int l, int h){\n\t\t\tleft = l; height = h;\n\t  }\n};\n\nint solve(vector<int>& hist){\n\t  hist.push_back(0);\n\t  int W = hist.size();\n\t  int ans = 0;\n\t  stack<rect> st;\n\t  for(int i=0; i<W; i++){\n\t\t\tif( st.empty() ){\n\t\t\t\t  st.push( rect(i,hist[i]) );\t\n\t\t\t}else{\n\t\t\t\t  rect max_h = st.top();\n\t\t\t\t  if( max_h.height < hist[i]){\n\t\t\t\t\t\tst.push( rect(i,hist[i]) );\n\t\t\t\t  }\n\t\t\t\t  else if( max_h.height > hist[i] ){\n\t\t\t\t\t\twhile( !st.empty() and max_h.height >= hist[i] ) {\n\t\t\t\t\t\t\t  max_h = st.top();\n\t\t\t\t\t\t\t  ans = max(ans, max_h.height * (i-max_h.left) );\n\t\t\t\t\t\t\t  st.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tst.push( rect(max_h.left, hist[i]) ) ;\n\t\t\t\t  }\n\t\t\t}\n\t  }\n\t  return ans ;\n}\n\n\t  int main(){\n\t\t\t// input\n\t\t\tint H,W;\n\t\t\tcin >> H >> W;\n\t\t\tvector<vector<int> > m(H+1,vector<int>(W,0));\n\t\t\tfor(int i=1; i<=H; i++)\n\t\t\t\t  for(int j=0; j<W; j++)\n\t\t\t\t\t\tcin >> m[i][j];\n\n\t\t\t// pre proces\n\t\t\tvector<vector<int> > dp(H+1,vector<int>(W,0));\n\t\t\tfor(int i=1; i<=H; i++){\n\t\t\t\t  for(int j=0; j<W; j++){\n\t\t\t\t\t\tif(m[i][j] == 1)\n\t\t\t\t\t\t\t  dp[i][j] = 0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t  dp[i][j] = dp[i-1][j]+1;\n\t\t\t\t  }\n\t\t\t}\n\t  \n\t\t\tint ans = 0;\n\t\t\tfor(int i=1; i<=H; i++)\n\t\t\t\t  ans = max(ans, solve(dp[i]));\n\n\n\t\t\t/*\n\t\t\t  for(int i=1; i<=H; i++){\n\t\t\t  for(int j=0; j<W; j++){\n\t\t\t  cout << dp[i][j] <<\" \";\n\t\t\t  }\n\t\t\t  cout << \": \" << solve(dp[i]) << endl;\n\t\t\t  }\n\t\t\t*/\n\t  \n\t\t\tcout << ans << endl;\n\t  \n\t  }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\nusing namespace std;\n\nint main(){\n\tint h, w;\n\tcin >> h >> w;\n\tint64_t ans = 0, dp[2][1400 + 1]{};\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tcin >> dp[i & 1][j];\n\t\t\tdp[i & 1][j] = !dp[i & 1][j];\n\t\t\tif(dp[i & 1][j] == 0) continue;\n\t\t\tdp[i & 1][j] += dp[!(i & 1)][j];\n\t\t}\n\t\tdp[i & 1][w] = 0;\n\t\tstack<int64_t> st;\n\t\tfor(int j = 0; j < w + 1; j++){\n\t\t\tif(st.empty()){\n\t\t\t\tst.emplace(dp[i & 1][j]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int64_t x = 2; !st.empty() && dp[i & 1][j] < st.top(); x++){\n\t\t\t\tst.pop();\n\t\t\t\tans = max(ans, x * dp[i & 1][j]);\n\t\t\t}\n\t\t\tst.emplace(dp[i & 1][j]);\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// 問題: H*Wのタイルが与えられる。タイルは綺麗か汚れているかのいずれか。\n//       綺麗なタイルのみでできる最大の長方形の最大値を求める\n// 解法: http://algorithms.blog55.fc2.com/blog-entry-133.html\n//       http://algorithms.blog55.fc2.com/blog-entry-132.html\n//       まず各要素について上に向かって 1 が何個連続しているかを示すテーブル T を作る\n//       次に、T の各行をヒストグラムの入力と見なしヒストグラムの最大長方形の面積を求めるアルゴリズムを適用\n\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n#define pb push_back\n#define mp make_pair\n\nint largest_square(const int H, const int W, const vector<vector<int>>& cells) {\n    // 上に綺麗なタイルが連続する数\n    vector<vector<int>> table(H, vector<int>(W));\n    REP(w, W) {\n        REP(h, H) {\n            auto val = cells[h][w];\n            if (val == 1) table[h][w] = 0;\n            else {\n                if (h == 0) table[h][w] = val;\n                else table[h][w] = table[h-1][w] + 1;\n            }\n            // cout << table[h][w] << \" \";\n        }\n        // cout << endl;\n    }\n\n    int ans = 0;\n    // 各行ごとに、ヒストグラムの最大長方形の面積を求めるアルゴリズムを適用\n    REP(h, H) {\n        // <ヒストグラムの高さ, index>\n        stack<pair<int, int>> s;\n        REP(w, W) {\n            auto height = table[h][w];\n            if (s.empty()) s.push(mp(height, w));\n            else if (s.top().first < height) s.push(mp(height, w));\n            else if (s.top().first > height) {\n                while(!s.empty() && s.top().first > height) {\n                    auto area = (w - s.top().second) * s.top().first;\n                    ans = max(area, ans);\n                    s.pop();\n                }\n            }\n        }\n    }\n    return ans;\n}\n\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n\n    vector<vector<int>> cells(H, vector<int>(W));\n    REP(h, H) {\n        REP(w, W) {\n            cin >> cells[h][w];\n        }\n    }\n\n    cout << largest_square(H, W, cells) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stack>\nusing namespace std;\n\nint H, W, M[1500][1500], HIS[1500][1500];\nstruct rect { int h, pos; }r, pre;\n\nint get(int his[])\n{\n\tstack<rect>s;\n\tint M = 0;\n\n\tfor (int i = 1; i <= W + 1; i++)\n\t{\n\t\tr.h = his[i], r.pos = i;\n\n\t\tif (s.empty())\n\t\t\ts.push(r);\n\t\telse\n\t\t{\n\t\t\tif (r.h >= s.top().h)\n\t\t\t\ts.push(r);\n\t\t\telse\n\t\t\t{\n\t\t\t\tint tar = i;\n\n\t\t\t\twhile (!s.empty() && r.h <= s.top().h)\n\t\t\t\t{\n\t\t\t\t\tpre = s.top(), s.pop();\n\t\t\t\t\ttar = pre.pos;\n\t\t\t\t\tint area = pre.h * (i - pre.pos);\n\t\t\t\t\tM = max(M, area);\n\t\t\t\t}\n\n\t\t\t\tr.pos = tar;\n\t\t\t\ts.push(r);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn M;\n}\n\nint main()\n{\n\tcin >> H >> W;\n\t\n\tfor (int i = 1; i <= H; i++)\n\t\tfor (int j = 1; j <= W; j++)\n\t\t\tcin >> M[i][j];\n\t\n\tfor (int i = 1; i <= H; i++)\n\t{\n\t\tfor (int j = 1; j <= W; j++)\n\t\t{\n\t\t\tif (M[i][j] == 0)\n\t\t\t\tHIS[i][j] = HIS[i - 1][j] + 1;\n\t\t\telse\n\t\t\t\tHIS[i][j] = 0;\n\t\t}\n\t}\n\n\tint MAX = 0;\n\n\tfor (int i = 1; i <= H; i++)\n\t\tMAX = max(MAX, get(HIS[i]));\n\n\tcout << MAX << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <stack>\n#include <utility>\n\nusing namespace std;\n\nint main() {\n\tint H, W;\n\tscanf(\"%d %d\", &H, &W);\n\n\tint A[H][W];\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tscanf(\"%d\", &A[i][j]);\n\t\t}\n\t}\n\tint V[H + 1][W + 1];\n\tfor (int i = 0; i <= H; ++i) {\n\t\tfor (int j = 0; j <= W; ++j) {\n\t\t\tV[i][j] = 0;\n\t\t}\n\t}\n\tfor (int j = 0; j < W; ++j) {\n\t\tfor (int i = 1; i <= H; ++i) {\n\t\t\tif (A[i - 1][j] == 0)\n\t\t\t\tV[i][j] = V[i - 1][j] + 1;\n\t\t\telse {\n\t\t\t\tV[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxArea = 0;\n\tfor (int i = 1; i <= H; ++i) {\n\t\tstack<pair<int, int>> S;\n\t\tS.push(make_pair(0, V[i][0]));\n\t\tfor (int j = 1; j <= W; ++j) {\n\t\t\tpair<int, int> p = S.top();\n\t\t\tif (V[i][j] > p.second) {\n\t\t\t\tS.push(make_pair(j, V[i][j]));\n\t\t\t} else if (V[i][j] < p.second) {\n\t\t\t\tint pos;\n\t\t\t\twhile (!S.empty() && V[i][j] <= p.second) {\n\t\t\t\t\tS.pop();\n\t\t\t\t\tif (p.second > 0)\n\t\t\t\t\t\tpos = p.first;\n\t\t\t\t\tint area = (j - p.first) * p.second;\n\t\t\t\t\tmaxArea = max(maxArea, area);\n\t\t\t\t\tif (!S.empty())\n\t\t\t\t\t\tp = S.top();\n\t\t\t\t}\n\t\t\t\tS.push(make_pair(pos, V[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxArea << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define endl '\\n'\n#define MAX 1500\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nchar board[MAX][MAX];\nint dp[MAX][MAX];\nint L[MAX][MAX];\nint R[MAX][MAX];\nint A[MAX][MAX];\nint B[MAX][MAX];\n\nint main(){\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\t\t\n    int n,m;\n    cin >> n >> m;\n\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= m; j++)\n            cin >> board[i][j];\n\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= m; j++)\n            if(board[i][j] == '0')\n                A[i][j] = 1;\n\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= m; j++){\n                B[i][j] += A[i][j];\n                B[i][j] += B[i][j - 1];\n                B[i][j] += B[i - 1][j];\n                B[i][j] -= B[i - 1][j - 1];\n        }\n\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= m; j++){\n            if(board[i][j] == '1')\n                dp[i][j] = 0;\n            else\n                dp[i][j] = 1 + dp[i - 1][j];\n        }\n\n    for(int i = 1; i <= n; i++){\n        stack<int> st;\n        for(int j = 1; j <= m; j++){\n            while(!st.empty() && dp[i][st.top()] >= dp[i][j])\n                st.pop();\n            if(st.empty())\n                L[i][j] = 1;\n            else\n                L[i][j] = st.top() + 1;\n            st.push(j);\n        }\n    }\n\n    for(int i = 1; i <= n; i++){\n        stack<int> st;\n        for(int j = m; j >= 1; j--){\n            while(!st.empty() && dp[i][st.top()] >= dp[i][j])\n                st.pop();\n            if(st.empty())\n                R[i][j] = m;\n            else\n                R[i][j] = st.top() - 1;\n            st.push(j);\n        }\n    }\n\n    int solve = 0;\n    for(int i = 1; i <= n; i++)\n        for(int j = 1; j <= m; j++){\n            if(dp[i][j] == 0)\n                continue;\n            int size = R[i][j] - L[i][j] + 1;\n            int rectangle_size = size * dp[i][j];\n\n            solve = max(solve,rectangle_size);\n        }\n\n    cout << solve << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <stack>\n#include <algorithm>\n#define MAX 1400\nusing namespace std;\n\nstruct Rectangle {\n    int height;\n    int pos;\n};\n\nint getLargestRectangle(int size,int buffer[]) {\n    stack<Rectangle> S;\n    int maxv=0;\n    buffer[size]=0;\n\n    for(int i=0;i<=size;i++) {\n        Rectangle rect;\n        rect.height=buffer[i];\n        rect.pos=i;\n        if(S.empty()||S.top().height<rect.height)\n            S.push(rect);\n        else if(S.top().height>rect.height) {\n            int target=i;\n            while(!S.empty()&&S.top().height>=rect.height) {\n                Rectangle pre=S.top();S.pop();\n                int area=pre.height*(i-pre.pos);\n                maxv=max(maxv,area);\n                target=pre.pos;\n            }\n            rect.pos=target;\n            S.push(rect);\n        }\n    }\n    return maxv;\n}\n\nint H,W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle() {\n    for(int j=0;j<W;j++)\n        for(int i=0;i<H;i++)\n            if(buffer[i][j])\n                T[i][j]=0;\n            else\n                T[i][j]=(i>0)?T[i-1][j]+1:1;\n\n    int maxv=0;\n    for(int i=0;i<H;i++)\n        maxv=max(maxv,getLargestRectangle(W,T[i]));\n\n    return maxv;\n}\n\nint main()\n{\n    scanf(\"%d %d\",&H,&W);\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            scanf(\"%d\",&buffer[i][j]);\n\n    cout<<getLargestRectangle()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int N = 1402;\nint n, m;\nint G[N][N];\ninline int nextInt(void) {\n\tint r; scanf(\"%d\", &r); return r;\n}\nstruct K {\n\tint h, c;\n};\nstack<K> st;\ninline int maxRec(int d) {\n\tint ans = 0;\n\tfor (int i = 1; i <= m; i++) {\n\t\tint h = G[d][i];\n\t\tint tmp = 0;\n\t\twhile (!st.empty() && st.top().h >= h) {\n\t\t\tint newAns = st.top().h*(st.top().c + tmp);\n\t\t\tans = max(ans, newAns);\n\t\t\ttmp += st.top().c;\n\t\t\tst.pop();\n\t\t}\n\t\tst.push((K) { h, 1 + tmp });\n\t}\n\tint tmp = 0;\n\twhile (!st.empty()) {\n\t\tint newAns = st.top().h*(st.top().c + tmp);\n\t\tans = max(ans, newAns);\n\t\ttmp += st.top().c;\n\t\tst.pop();\n\t}\n\treturn ans;\n}\nsigned main(void) {\n\tn = nextInt();\n\tm = nextInt();\n\tmemset(G, 0, sizeof(G));\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= m; j++)\n\t\t\tif (!nextInt())\n\t\t\t\tG[i][j] = G[i-1][j] + 1;\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tans = max(ans, maxRec(i));\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T> long long largest_rectangle (vector<T> a) {\n    a.emplace_back(0);\n    int n = a.size(); T ret = 0;\n    stack<pair<T, int>> sta;\n    for (int i = 0; i < n; i++) {\n        if (sta.empty()) sta.emplace(a[i], i);\n        else if (sta.top().first < a[i]) sta.emplace(a[i], i);\n        else if (sta.top().first > a[i]) {\n            int idx = i;\n            while (!sta.empty()) {\n                if (sta.top().first < a[i]) break;\n                T h; int t; tie(h, t) = sta.top(); sta.pop();\n                T s = h * (i - t); idx = t;\n                if (ret < s) ret = s;\n            }\n            sta.emplace(a[i], idx);\n        }\n    }\n    return ret;\n}\n\n\n\nint main() {\n    int h, w, ans = 0;\n    cin >> h >> w;\n    vector<vector<int>> s(h, vector<int>(w));\n    vector<vector<int>> d(h+1, vector<int>(w, 0));\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            cin >> s[i][j];\n        }\n    }\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            if (s[i][j] == 1) d[i+1][j] = 0;\n            else d[i+1][j] = d[i][j] + 1;\n        }\n    }\n    \n    for (int i = 0; i <= h; i++) {\n        int res = largest_rectangle(d[i]);\n        if (ans < res) ans = res;\n    }\n    \n    cout << ans << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nstruct Rectangle {int height, pos;};\n\nint main() {\n  int h, w;\n  cin >> h >> w;\n  int C[w][h], R[w+1][h];\n  for (int j = 0; j < h; j++) {\n      for (int i = 0; i < w; i++) {\n      cin >> C[i][j];\n    }\n  }\n  for (int j = 0; j < h; j++) {\n    for (int i = 0; i < w; i++) {\n      if (!j) {\n        R[i][j] = (C[i][j]+1) % 2;\n      } else {\n        R[i][j] = (!C[i][j] ? R[i][j-1] + 1: 0);\n      }\n    }\n    R[w][j] = 0;\n  }\n  int max_area = 0;\n  for (int j = 0; j < h; j++) {\n    stack<Rectangle> s;\n    for (int i = 0; i <= w; i++) {\n      Rectangle rect;\n      rect.height = R[i][j];\n      rect.pos = i;\n      if (s.empty()) {\n        s.push(rect);\n      } else {\n        if (s.top().height < rect.height) {\n          s.push(rect);\n        } else if (s.top().height > rect.height) {\n          int target = rect.pos;\n          while (!s.empty() && s.top().height >= rect.height) {\n            Rectangle pre_rect = s.top(); s.pop();\n            max_area = max(max_area, pre_rect.height * (i - pre_rect.pos));\n            target = pre_rect.pos;\n          }\n          rect.pos = target;\n          s.push(rect);\n        }\n      }\n    }\n  }\n  cout << max_area << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//ここから編集する\nll histogram_max_square(vector<ll> h) {\n\n    h.push_back(0);\n    using P = pair<ll, int>;\n    stack<P> st;\n\n    ll maxv = 0;\n\n    for (int i = 0; i < h.size(); ++i) {\n        if (st.empty()) {\n            st.push(P(h[i], i));\n            continue;\n        }\n        if (st.top().first < h[i]) {\n            st.emplace(h[i], i);\n            continue;\n        }\n        if (st.top().first > h[i]) {\n            int target = i;\n            while (true) {\n                if (st.empty() || st.top().first < h[i]) {\n                    break;\n                }\n                int tmp = (i - st.top().second) * st.top().first;\n                chmax(maxv, tmp);\n                target = st.top().second;\n                st.pop();\n            }\n//            if (!st.empty())\n//                st.emplace(h[i], st.top().second + 1);\n//            else\n//                st.emplace(h[i], 0);\n            st.emplace(h[i], target);\n        }\n    }\n    return maxv;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int H, W;\n    cin >> H >> W;\n    vector<vector<ll> > vv(H, vector<ll>(W));\n\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            cin >> vv[i][j];\n            vv[i][j] = !vv[i][j];\n        }\n    }\n\n    for (int i = 1; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (vv[i][j] == 1) {\n                vv[i][j] += vv[i - 1][j];\n            }\n        }\n    }\n\n    ll ans = 0;\n    for (int i = 0; i < H; ++i) {\n//        chmax(ans,histogram_max_square(vv[i]));\n        ll tmp = histogram_max_square(vv[i]);\n        if (ans < tmp) {\n            ans = tmp;\n        }\n    }\n\n    cout << ans << endl;\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nstruct rect {\n    int pos, height;\n};\n\nint main() {\n\n    int H, W;\n    cin >> H >> W;\n\n    int T[H][W];\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int c;\n            cin >> c;\n            if (i == 0) {\n                T[i][j] = (c ? 0 : 1);\n            } else {\n                T[i][j] = (c ? 0 : T[i - 1][j] + 1);\n            }\n        }\n    }\n\n    //solve\n    int ans = 0;\n\n    for (int i = 0; i < H; i++) {\n        stack<rect> stk;\n        for (int j = 0; j <= W; j++) {\n            int pos, height;\n            pos = j;\n            if (j == W) {\n                height = 0;\n            } else {\n                height = T[i][j];\n            }\n            if (stk.empty() || stk.top().height < height) {\n                stk.push((rect) {pos, height});\n            } else if (stk.top().height > height) {\n                while (!stk.empty() && stk.top().height >= height) {\n                    rect &pre = stk.top();\n                    stk.pop();\n                    ans = max(ans, pre.height * (j - pre.pos));\n                    pos = pre.pos;\n                }\n                stk.push((rect) {pos, height});\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\nconst int adx[] = { 1,1,1,0,-1,-1,-1,0 };\nconst int ady[] = { 1,0,-1,-1,-1,0,1,1 };\n\nint add(const int base, const int plus) {\n\tif (!plus) {\n\t\treturn base + 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n//0 :?????????1:??????2:?????????3:??? 4:?????????5:??? 6:?????? 7:??? ???\nvector<vector<vector<int>>>get_cumulative_sum(const vector<vector<int>>&field) {\n\tconst int H = field.size();\n\tconst int W = field[0].size();\n\n\tvector<vector<vector<int>>>sums(H, vector<vector<int>>(W, vector<int>(4)));\n\n\tfor (int ny = H - 1; ny >= 0; --ny) {\n\t\tfor (int nx = 0; nx <W; ++nx) {\n\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\tsums[k].clear();\n\t\t\t}\n\t\t\tfor (int k = 3; k < 4; ++k) {\n\t\t\t\tint py = ny - ady[k];\n\t\t\t\tint px = nx - adx[k];\n\t\t\t\tif (!(px >= 0 && px <W && py >= 0 && py <H))continue;\n\n\t\t\t\tsums[ny][nx][k] = add(sums[py][px][k], field[ny][nx]);\n\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sums;\n}\n\nint getans( vector<int>hs) {\n\ths.emplace_back(0);\n\tstack<pair<int, int>>que;\n\tque.emplace(-1, 0);\n\tint ans = 0;\n\tfor (int x = 0; x < hs.size(); ++x) {\n\t\t\n\t\tif (que.empty()) {\n\t\t\tque.push(make_pair(x, hs[x]));\n\t\t}\n\t\telse {\n\t\t\twhile (!que.empty()) {\n\t\t\t\tauto p = que.top();\n\t\t\t\tif (p.second < hs[x]) {\n\t\t\t\t\tque.push(make_pair(x,hs[x]));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (p.second == hs[x]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint area = (x - p.first)*p.second;\n\t\t\t\t\tans = max(ans, area);\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif (!que.empty()) {\n\t\t\t\t\t\tauto np = que.top();\n\t\t\t\t\t\tif (np.second < hs[x]) {\n\t\t\t\t\t\t\tque.push(make_pair(p.first, hs[x]));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\t\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>>field(H + 2, vector<int>(W + 2,1));\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tcin >> field[i + 1][j + 1];\n\t\t}\n\t}\n\tauto vs = get_cumulative_sum(field);\n\tint ans = 0;\n\t\n\tfor (int y = 1; y <= H; ++y) {\n\t\tvector<int>v;\n\t\tfor (int x = 1; x <= W; ++x) {\n\t\t\tv.push_back(vs[y][x][3]);\n\t\t}\n\t\tans = max(ans, getans(v));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int,int>P;\n#define fi first\n#define se second\nint h,w,a[501][501],ls,s[501][501];\nmain(){\n\twhile(cin>>h>>w,h){\n\t\tr(i,h)r(j,w)cin>>s[i][j];\n\t\tmemset(a,0,sizeof(a));\n\t\tr(i,h)r(j,w){\n\t\t\tif(!i&&!s[i][j])a[i][j]++;\n\t\t\tif(i&&!s[i][j])a[i][j]=a[i-1][j]+1;\n\t\t}\n\t\tint ans=0;\n\t\tr(i,h){\n\t\t\tstack<P>st;\n\t\t\tr(j,w+1){\n\t\t\t\tif(st.empty())st.push(P(a[i][j],j));\n\t\t\t\tif(st.top().fi==a[i][j])continue;\n\t\t\t\telse if(st.top().fi<a[i][j])st.push(P(a[i][j],j));\n\t\t\t\telse{\n\t\t\t\t\twhile(!st.empty()&&st.top().fi>a[i][j]){\n\t\t\t\t\t\tans=max(ans,(j-st.top().se)*st.top().fi);\n\t\t\t\t\t\tls=st.top().se;\n\t\t\t\t\t\tst.pop();\n\t\t\t\t\t}\n\t\t\t\t\tst.push(P(a[i][j],ls));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n\nint H,W;\nint c[1500][1500];\nint h[1500][1500];\nint l[1500];\nint r[1500];\nint main() {\n  scanf(\"%d%d\", &H, &W);\n  for(int i=0;i<H;++i)\n    for(int j=0;j<W;++j)\n      scanf(\"%d\", &c[i][j]);\n  for(int i=0;i<H;++i) {\n    for(int j=0;j<W;++j) {\n      if (c[i][j] == 1) {\n        h[i][j] = 0;\n      } else if (i==0 || c[i-1][j] == 1) {\n        h[i][j] = 1;\n      } else {\n        h[i][j] = h[i-1][j] + 1;\n      }\n    }\n  }\n  \n  long long answer = 0;\n  for(int i=0;i<H;++i) {\n    stack<int> S;\n    for(int j=0;j<W;++j) {\n      while(!S.empty() && h[i][S.top()] >= h[i][j]) S.pop();\n      if (S.empty()) {\n        l[j] = 0;\n      } else {\n        l[j] = S.top() + 1;\n      }\n      S.push(j);\n    }\n    S=stack<int>();\n    for(int j=W-1;j>=0;--j) {\n      while(!S.empty() && h[i][S.top()] >= h[i][j]) S.pop();\n      if (S.empty()) {\n        r[j] = W-1;\n      } else {\n        r[j] = S.top() - 1;\n      }\n      S.push(j);\n    }\n    \n    for(int j=0;j<W;++j) {\n      answer = max(answer, 1ll * h[i][j] * (r[j]- l[j] +1));\n    }\n  }\n  \n  printf(\"%lld\\n\", answer);\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define mp(x,y) (make_pair(x,y))\ntypedef pair<int,int> pii;\ntypedef vector<int> Vec;\ntypedef vector<Vec> Mat;\n\nint getMaxArea(Vec &h)\n{\n    int n=h.size();\n    vector<int> l(n),r(n);\n    stack<pii> st;\n    for(int i=0;i<n;i++)\n    {\n        while(!st.empty()&&st.top().first>=h[i])\n        {\n            st.pop();\n        }\n        if(!st.empty())\n        {\n            l[i]=st.top().second+1;\n        }else\n        {\n            l[i]=0;\n        }\n        st.push(mp(h[i],i));\n    }\n    while(!st.empty())\n    {\n        st.pop();\n    }\n    for(int i=n-1;i>=0;i--)\n    {\n        while(!st.empty()&&st.top().first>=h[i])\n        {\n            st.pop();\n        }\n        if(!st.empty())\n        {\n            r[i]=st.top().second;\n        }else\n        {\n            r[i]=n;\n        }\n        st.push(mp(h[i],i));\n    }\n    int area=0;\n    for(int i=0;i<n;i++)\n    {\n        area=max(area,h[i]*(r[i]-l[i]));\n    }\n    return area;\n}\n\nint main()\n{\n    int H,W;\n    while(cin>>H>>W)\n    {\n        Mat mat(H,Vec(W));\n        for(int i=0;i<H;i++)\n        {\n            for(int j=0;j<W;j++)\n            {\n                cin>>mat[i][j];\n            }\n        }\n        Vec h(W);\n        int area=0;\n        for(int i=0;i<H;i++)\n        {\n            for(int j=0;j<W;j++)\n            {\n                if(mat[i][j])\n                {\n                    h[j]=0;\n                }else\n                {\n                    h[j]++;\n                }\n            }\n            area=max(area,getMaxArea(h));\n        }\n        cout<<area<<endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n    int maxlen[1401][1401] = {};\n    for(int i = 1; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            int c;\n            cin >> c;\n            if(c == 1) continue;\n            maxlen[i][j] = maxlen[i - 1][j] + 1;\n        }\n    }\n    int ans = 0;\n    for(int i = 1; i <= h; i++){\n        stack<pair<int, int> > st;\n        for(int j = 1; j <= w; j++){\n            if(st.empty() || (st.top()).first < maxlen[i][j]){\n                st.push(make_pair(maxlen[i][j], j));\n            } else if((st.top()).first > maxlen[i][j]){\n                while(!st.empty()){\n                    if((st.top()).first < maxlen[i][j]){\n                        st.push(make_pair(maxlen[i][j], j));\n                        break;\n                    } else {\n                        ans = max(ans, (st.top()).first * (j - (st.top()).second));\n                        st.pop();\n                    }\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#define lol(i,n) for(int i=0;i<n;i++)\n#define mod 1000000007;\ntypedef long long ll;\nusing namespace std;\n#include<stack>\nint BiggestRectangle(int N,int buf[]){\n\tbuf[N]=0;\n\tstack<pair<int,int> >st;\n\tint ret=0;\n\tfor(int i=0;i<=N;i++){\n\t\tif(st.empty())st.push(make_pair(buf[i],i));\n\t\telse if(st.top().first<buf[i])st.push(make_pair(buf[i],i));\n\t\telse if(st.top().first>buf[i]){\n\t\t\tint pnt=i;\n\t\t\twhile(!st.empty()){\n\t\t\t\tint height=st.top().first;\n\t\t\t\tint index=st.top().second;\n\t\t\t\tif(height<buf[i])break;\n\t\t\t\tst.pop();\n\t\t\t\tret=max(ret,height*(i-index));\n\t\t\t\tpnt=index;\n\t\t\t}\n\t\t\tst.push(make_pair(buf[i],pnt));\n\t\t}\n\t}\n\treturn ret;\n}\nint dp[1410][1410];\nint main(){\n  int h,w;\n  cin>>h>>w;\n  lol(i,h){\n    lol(j,w){\n      int a;cin>>a;\n      if(i==0)dp[i][j]=(a==0);\n      else{\n\tif(a==0)dp[i][j]=dp[i-1][j]+1;\n\telse dp[i][j]=0;\n      }\n    }\n  }\n  int ans=0;\n  lol(i,h){\n    ans=max(ans,BiggestRectangle(w,dp[i]));\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nconst int MAX = 1400;\n\nint main() {\n\tint H, W;\n\tint tile[MAX][MAX];\n\tint ans = 0;\n\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tscanf(\"%d\", &tile[i][j]);\n\t\t}\n\t}\n\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = W - 1; x >= 0; x--) {\n\t\t\tif (tile[y][x] == 1)tile[y][x] = -1;\n\t\t\telse if (x == W - 1)tile[y][x] = 0;\n\t\t\telse tile[y][x] = tile[y][x + 1] + 1;\n\t\t}\n\t}\n\n\tfor (int x = 0; x < W; x++) {\n\t\tstack<pair<int, int>> s;\n\t\ts.push(pair<int, int>(-1, -1));\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tif (s.top().second < tile[y][x]) {\n\t\t\t\ts.push(pair<int, int>(y, tile[y][x]));\n\t\t\t}\n\t\t\telse if (s.top().second > tile[y][x]) {\n\t\t\t\twhile (s.top().second > tile[y][x]) {\n\t\t\t\t\tans = max(ans, (y - s.top().first) * s.top().second);\n\t\t\t\t\ts.pop();\n\t\t\t\t}\n\t\t\t\tif(s.top().second != tile[y][x])s.push(pair<int, int>(y, tile[y][x]));\n\t\t\t}\n\t\t}\n\t\twhile (!s.empty()) {\n\t\t\tans = max(ans, (W - s.top().first) * s.top().second);\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nstruct rectagle {\n\tint pos, height;\n};\n\nint getMax(int T[], int W) {\n\n\tstack<rectagle> S;\n\tint maxv = 0;\n\tfor (int i = 0; i < W; ++i) {\n\t\trectagle r;\n\t\tr.pos = i;\n\t\tr.height = T[i];\n\t\tif (S.empty()) {\n\t\t\tS.push(r);\n\t\t} else {\n\t\t\tif (r.height > S.top().height) {\n\t\t\t\tS.push(r);\n\t\t\t} else {\n\t\t\t\twhile (!S.empty() && r.height <= S.top().height) {\n\t\t\t\t\trectagle pop = S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tint area = (i - pop.pos) * pop.height;\n\t\t\t\t\tmaxv = max(maxv, area);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn maxv;\n}\n\nint main() {\n\n\tint H, W;\n\tscanf(\"%d %d\", &H, &W);\n\n\tint A[H][W];\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tscanf(\"%d\", &A[i][j]);\n\t\t}\n\t}\n\tint T[H][W];\n\tfor (int j = 0; j < W; ++j) {\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tif (A[i][j] == 0) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tT[i][j] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tT[i][j] = T[i - 1][j] + 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tT[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxv = 0;\n\tfor (int i = 0; i < H; ++i) {\n\t\tmaxv = max(maxv, getMax(T[i], W));\n\t}\n\tcout << maxv << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n\nstatic const int MAX_N = 1400;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n\nint masu[MAX_N][MAX_N];\n\nint main(void) {\n  int H, W;\n  cin >> H >> W;\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      cin >> masu[i][j];\n      masu[i][j] = (masu[i][j] + 1) % 2;\n    }\n  }\n  for (int i = 1; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      if (masu[i][j]) {\n        masu[i][j] += masu[i-1][j];\n      }\n    }\n  }\n\n  Rectangle rect;\n  int maxArea = 0;\n  for (int i = 0; i < H; i++) {\n    stack<Rectangle> stk;\n    for (int j = 0; j < W; j++) {\n      rect.height = masu[i][j];\n      rect.pos = j;\n      if (stk.empty()) {\n        stk.push(rect);\n      } else {\n        if (stk.top().height < rect.height) {\n          stk.push(rect);\n        } else if (stk.top().height > rect.height) {\n          int target = j;\n          while (!stk.empty() && stk.top().height >= rect.height) {\n            Rectangle pre = stk.top(); stk.pop();\n            int area = pre.height * (j - pre.pos);\n            maxArea = max(maxArea, area);\n            target = pre.pos;\n          }\n          rect.pos = target;\n          stk.push(rect);\n        }\n      }\n    }\n\n    while (!stk.empty()) {\n      Rectangle pre = stk.top(); stk.pop();\n      int area = pre.height * (W - pre.pos);\n      maxArea = max(maxArea, area);\n    }\n  }\n\n  cout << maxArea << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\nconst int INF = 1<<28;\n#define MAX 1401\n\nint dp[MAX][MAX];\n\nint solve(int H, int W) {\n\tREP(j,W) {\n\t\tint v = 1;\n\t\tREP(i, H) {\n\t\t\tif(!dp[i][j])\n\t\t\t\tv = 0;\n\t\t\tdp[i][j] = v++;\n\t\t}\n\t}\n/*\n\tREP(i, H) {\n\t\tREP(j,W)\n\t\t\tcout << dp[i][j] << ' ';\n\t\tcout << endl;\n\t}\n*/\n\tint ans = 0;\n\tREP(i, H) {\n\t\tpair<int, int> p, p2;\n\t\tstack< pair<int, int> > s;\n\t\tdp[i][W] = 0;\n\t\tREP(j, W) {\n\t\t\tp = make_pair(dp[i][j], j);\n\t\t\tif(s.empty())\n\t\t\t\ts.push(p);\n\t\t\telse {\n\t\t\t\tif(s.top().first < p.first)\n\t\t\t\t\ts.push(p);\n\t\t\t\telse if(s.top().first > p.first) {\n\t\t\t\t\twhile(!s.empty() && s.top().first >= p.first) {\n\t\t\t\t\t\tp2 = s.top(); s.pop();\n\t\t\t\t\t\tans = max(ans, p2.first * (j - p2.second));\n\t\t\t\t\t}\n\t\t\t\t\tp.second = p2.second;\n\t\t\t\t\ts.push(p);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcout << \"i \" << i << \" j \" << j << ' ' << ans << endl;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tREP(i, H) REP(j,W) {\n\t\tcin >> dp[i][j];\n\t\tdp[i][j] = !dp[i][j];\n\t}\n\tcout << solve(H, W) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n\tRectangle rect;\n\tfor(int i=0;i<x;i++){\n\t\tstack<Rectangle> stk;\n\t\t//rect.height = 0;\n\t\t//rect.pos = 0;\n\t\tstk.push(rect);\n\t\tint pop=0;\n\t\tfor(int j=0;j<=y;j++){\n\t\t\trect.height = m[j][i];\n\t\t\trect.pos = j;\n\t\t\tif(stk.empty() || stk.top().height < rect.height){\n\t\t\t\tstk.push(rect);\n\t\t\t}else{\n\t\t\t\t//printf(\"[-] %d %d\\n\",i,j);\n\t\t\t\tfor(;!stk.empty() && stk.top().height >= rect.height;){\n\t\t\t\t\tpop++;\n\t\t\t\t\tRectangle pre = stk.top(); stk.pop();\n\t\t\t\t\t//pre.pos=stk\n\t\t\t\t\tint area = pre.height * (j - pre.pos);\n\t\t\t\t\tr = max(r, area);\n\t\t\t\t\t//printf(\"%d %d\\n\",target,pre.pos);\n\t\t\t\t\trect.pos = pre.pos;\n\t\t\t\t}\n\t\t\t\tstk.push(rect);\n\t\t\t}\n\t\t\tif(rect.height==0)pop=0;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * Given an H*W-sized, 0/1-valued matrix, find the area of the largest\n * rectangle containing only 0s.\n *\n * 1 <= H, W <= 1400\n */\n\n#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\nusing namespace std;\n\nint m[1400][1400];\n\nint main() {\n  int h, w;\n  cin >> h >> w;\n  int A{0};\n  for (int i = 0; i < h; ++i)\n    for (int j = 0; j < w; ++j)\n      cin >> m[i][j];\n  vector<int> d(w, -1), l(w), r(w);\n  for (int i = 0; i < h; ++i) {\n    for (int j = 0; j < w; ++j)\n      if (m[i][j])\n        d[j] = i;\n    stack<int> st;\n    for (int j = 0; j < w; ++j) {\n      while (!st.empty() && d[st.top()] <= d[j])\n        st.pop();\n      l[j] = st.empty() ? -1 : st.top();\n      st.push(j);\n    }\n    while (!st.empty())\n      st.pop();\n    for (int j = w - 1; j >= 0; --j) {\n      while (!st.empty() && d[st.top()] <= d[j])\n        st.pop();\n      r[j] = st.empty() ? w : st.top();\n      st.push(j);\n    }\n    for (int j = 0; j < w; ++j)\n      A = max(A, (i - d[j]) * (r[j] - l[j] - 1));\n  }\n  cout << A << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int h,w;\n  char c;\n  int mp[1010][1010]={0};\n  int ans=0;\n\n  cin>>h>>w;\n  for(int i=1;i<=h;i++){\n    for(int j=1;j<=w;j++){\n      scanf(\" %c\",&c);\n      if(c=='1')mp[i][j]=0;\n      if(c=='0')mp[i][j]=mp[i-1][j]+1;\n    }\n  }\n\n  int mx;\n  int target;\n  stack<pair<int,int> >st;\n  for(int i=1;i<=h;i++){\n    mx=0;\n    \n    for(int j=1;j<=w;j++){\n\n      if(mx<mp[i][j]){\n\tst.push(make_pair(mp[i][j],j));\n\tmx=mp[i][j];\n      }\n\n      else if(mx>mp[i][j]){\n\ttarget = j;\n\twhile(!st.empty()){\n\t  pair<int,int>f=st.top();\n\t  if(f.first<mp[i][j])break; // ...?\n\t  st.pop();\n\t  // Debug\n\t  /*\n\t  cout<<i<<\" \"<<j<<\" \"<<f.first<<\" \"<<f.second<<endl;\n\t  cout<<f.first*(j-f.second)<<endl;\n\t  */\n\t  ans = max(ans,(f.first*(j-f.second)));\n\t  target = f.second;\n\t}\n\tif(mp[i][j]>0)st.push(make_pair(mp[i][j],target));\n\tmx=mp[i][j];\n      }\n\n    }\n    \n    while(!st.empty()){\n      pair<int,int>f=st.top();st.pop();\n      // Debug\n      //cout<<i<<\"  \"<<f.second<<endl;\n      ans = max(ans,(f.first*(w+1-f.second)));\n      //  cout<<ans<<endl;\n    }\n  }\n\n  cout<<ans<<endl;\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<algorithm>\n#include<stack>\n\nusing namespace std;\n\n#define int long long\n#define endl \"\\n\"\n\nconstexpr long long INF = (long long)1e18;\nconstexpr long long MOD = 1'000'000'007; \n\nstring yn(bool f){return f?\"Yes\":\"No\";}\nstring YN(bool f){return f?\"YES\":\"NO\";}\n\n\n\n\nsigned main(){\n\t// cin.tie(nullptr);\n\t// ios::sync_with_stdio(false);\n\t// cout<<fixed<<setprecision(10);\n\t\n\tint ans = 0;\n\tint H, W;\n\tvector<vector<int>> c;\n\tvector<vector<int>> dp;\n\t\n\t\n\tcin>>H>>W;\n\t\n\tc.resize(H, vector<int>(W+1));\n\tdp.resize(H, vector<int>(W));\n\t\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tcin>>c[i][j];\n\t\t\tc[i][j] = !c[i][j];\n\t\t}\n\t}\n\t\n\t\n\tfor(int i = 1; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tif(!c[i][j]) continue;\n\t\t\t\n\t\t\tc[i][j] = c[i-1][j] + 1;\n\t\t}\n\t}\n\t\n\tfor(int i = 0; i < H; i++){\n\t\tstack<pair<int,int>> st;\n\t\t\n\t\tst.push({-1,-1});\n\t\t\n\t\tfor(int j = 0; j <= W; j++){\n\t\t\tint a = c[i][j], b = j, d = c[i][j];\n\t\t\t\n\t\t\twhile(true){\n\t\t\t\tpair<int,int> p = st.top();\n\t\t\t\t\n\t\t\t\tans = max(ans, (j - p.second - 1) * d);\n\t\t\t\t\n\t\t\t\tif(p.first >= a) {\n\t\t\t\t\tst.pop();\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\td = p.first;\n\t\t\t}\n\t\t\t\n\t\t\tst.push({a,b});\n\t\t}\n\t}\n\t\n\tcout<<ans<<endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nsize_t get_largest_rectangle(vector<vector<int>> &g) {\n    size_t h=g.size(), w=g[0].size();\n\n    vector<vector<size_t>> dp(h, vector<size_t>(w+1));\n    size_t max_area=0;\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j) {\n            dp[i][j] = !g[i][j];\n            max_area |= dp[i][j];\n        }\n\n    for (size_t i=1; i<h; ++i)\n        for (size_t j=0; j<w; ++j)\n            if (dp[i][j])\n                dp[i][j] += dp[i-1][j];\n\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j) {\n            if (!dp[i][j]) continue;\n\n            size_t min_height=dp[i][j];\n            for (size_t k=j+1; k<=w; ++k) {\n                max_area = max(max_area, (k-j)*min_height);\n                if (!dp[i][k])\n                    break;\n\n                min_height = min(min_height, dp[i][k]);\n            }\n        }\n\n    return max_area;\n}\n\nint main() {\n    size_t h, w;\n    scanf(\"%zu %zu\", &h, &w);\n\n    vector<vector<int>> g(h, vector<int>(w));\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j)\n            scanf(\"%d\", &g[i][j]);\n\n    printf(\"%zu\\n\", get_largest_rectangle(g));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i, a, b) for (int i = (a), i##_max = (b); i < i##_max; ++i)\n#define RFOR(i, a, b) for (int i = (b)-1, i##_min = (a); i >= i##_min; --i)\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define RREP(i, n) for (int i = (n)-1; i >= 0; --i)\n#define ALL(obj) (obj).begin(), (obj).end()\n\n#define pb push_back\n#define mp make_pair\n#define fst first\n#define snd second\n\nusing namespace std;\nusing i64 = int64_t;\nusing u64 = uint64_t;\nusing vb = vector<bool>;\nusing vi = vector<int>;\nusing vl = vector<i64>;\nusing vd = vector<double>;\nusing pi = pair<int, int>;\nusing pl = pair<i64, i64>;\nusing pd = pair<double, double>;\n\nconstexpr int INF = 1 << 30;\nconstexpr int MOD = 1000000007;\n\ntemplate <typename T>\ninline void chmin(T &a, T b) {\n  a = min(a, b);\n}\ntemplate <typename T>\ninline void chmax(T &a, T b) {\n  a = max(a, b);\n}\ntemplate <typename T>\nvoid print(T &v) {\n  for (auto it = v.begin(); it != v.end(); ++it) {\n    if (it != v.begin()) cout << \" \";\n    cout << *it;\n  }\n  cout << endl;\n}\n\nstruct Rectangle {\n  int height, pos;\n};\n\nint get_largest_rectangle(int w, vi &Tr) {\n  stack<Rectangle> S;\n  int max_v = 0;\n  Tr[w] = 0;\n\n  REP(i, w + 1) {\n    Rectangle rect{Tr[i], i};\n    if (S.empty()) {\n      S.push(rect);\n      continue;\n    }\n    if (S.top().height < rect.height) {\n      S.push(rect);\n    } else if (S.top().height > rect.height) {\n      int target = i;\n      while (!S.empty() && S.top().height >= rect.height) {\n        const auto pre = S.top();\n        S.pop();\n        auto area = pre.height * (i - pre.pos);\n        chmax(max_v, area);\n        target = pre.pos;\n      }\n      rect.pos = target;\n      S.push(rect);\n    }\n  }\n  return max_v;\n}\n\nint solve(int w, int h, vector<vi> &C) {\n  vector<vi> T(h, vi(w + 1, 0));\n  REP(y, h) {\n    REP(x, w) {\n      if (C[y][x]) continue;\n      T[y][x] = (y > 0) ? T[y - 1][x] + 1 : 1;\n    }\n  }\n\n  int max_v = 0;\n  REP(y, h) { chmax(max_v, get_largest_rectangle(w, T[y])); }\n  return max_v;\n}\n\nint main() {\n  int h, w;\n  cin >> h >> w;\n  vector<vi> C(h, vi(w));\n  REP(y, h) { REP(x, w) cin >> C[y][x]; }\n\n  cout << solve(w, h, C) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 2000\nint x[MAX_N][MAX_N];\nint H, W;\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> x[i][j];\n\t\t}\n\t\tif (x[i][0] == 1) { x[i][0] = 0; }\n\t\telse { x[i][0] = 1; }\n\t\tfor (int j = 1; j < W; j++) {\n\t\t\tif (x[i][j] == 1) {\n\t\t\t\tx[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i][j] = x[i][j - 1] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tint maxn = 0;\n\tfor (int i = 0; i < W; i++) {\n\t\tfor (int j = 0; j < H; j++) {\n\t\t\tint X = x[j][i], cnt = 0;\n\t\t\tif (x[j][i] == 0)continue;\n\t\t\tfor (int k = j; k >= 0; k--) {\n\t\t\t\tcnt++; X = min(X, x[k][i]);\n\t\t\t\tif (X*(j + 1) <= maxn) { break; }\n\t\t\t\tmaxn = max(maxn, X*cnt);\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <stack>\nusing namespace std;\nconst int num = 140;\nstruct Rectangle {\n\tint he, p;\n};\ninline int lr(int w, int bf[]) {\n\tbf[w] = 0;\n\tstack<Rectangle> s;\n\tint maxv = 0, area = 0;\n\tfor (int i = 0; i <= w; i++) {\n\t\tRectangle rect;\n\t\trect.he = bf[i];\n\t\trect.p = i;\n\t\tif (s.empty()) s.push(rect);\n\t\telse if (s.top().he < rect.he) s.push(rect);\n\t\telse if (s.top().he > rect.he) {\n\t\t\twhile (!s.empty() && s.top().he >= rect.he) {\n\t\t\t\tRectangle pr = s.top();\n\t\t\t\trect.p = pr.p;\n\t\t\t\ts.pop();\n\t\t\t\tarea = (i - pr.p)*pr.he;\n\t\t\t\tmaxv = max(area, maxv);\n\t\t\t}\n\t\t\ts.push(rect);\n\t\t}\n\t}\n\treturn maxv;\n}\nint main() {\n\tint h, w, x;\n\tcin >> h >> w;\n\tint H[num][num], dp[num][num];\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tcin >> x;\n\t\t\tif (x) dp[i][j] = 0;\n\t\t}\n\t}\n\tfor (int i = 0; i < w; i++) {\n\t\tfor (int j = 0; j < h; j++) {\n\t\t\tif (!dp[j][i]) H[j][i] = 0;\n\t\t\telse H[j][i] = (j > 0) ? H[j - 1][i] + 1 : 1;\n\t\t}\n\t}\n\tint maxv = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tmaxv = max(maxv, lr(w, H[i]));\n\t}\n\tcout << maxv << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define INSEG(l,x,r) ((l)<=(x)&&(x)<(r))\n#define dump(...)\n#define pb push_back\n#define _ 0\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T, class U> bool chmax(T &a,const U &b){return a<b?a=b,1:0;}\ntemplate<class T, class U> bool chmin(T &a,const U &b){return a>b?a=b,1:0;}\ntemplate <class T> void PSUM(T& c) {partial_sum(begin(c), end(c), begin(c));}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0); ios::sync_with_stdio(false);\n        cout << setprecision(15) << fixed;\n        // #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nsigned main() {\n    int H, W;\n    cin >> H >> W;\n    vector<vector<int>> A(H, vi(W));\n    cin >> A;\n    auto maximum_area_rectanle = [&]() {\n        vector<int> row(W);\n        int ret = 0;\n        REP(i, H) {\n            REP(j, W) {\n                if (A[i][j] == 0) row[j] += 1;\n                if (A[i][j] != 0) row[j] = 0;\n            }\n            \n            // ヒストグラムの最大長方形\n            stack<int> s; \n            int max_area = 0;\n            int tp;\n            int area_with_top;\n\n            int idx = 0; \n            while (idx < W) { \n                if (s.empty() || row[s.top()] <= row[idx]) s.push(idx++); \n                else { \n                    tp = s.top();\n                    s.pop();\n                    area_with_top = row[tp] * (s.empty() ? idx : idx - s.top() - 1); \n                    if (max_area < area_with_top) max_area = area_with_top; \n                }\n            }\n\n            while (!s.empty()) { \n                tp = s.top(); \n                s.pop(); \n                area_with_top = row[tp] * (s.empty() ? idx : idx - s.top() - 1);\n                if (max_area < area_with_top) max_area = area_with_top;\n            } \n\n            chmax(ret, max_area);\n        }\n        return ret;\n    };\n\n    cout << maximum_area_rectanle() << endl;\n    return (0^_^0);\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\n#define mod 1000000007\n\npair<int, int> result[1401][1401];\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n    \n    int ans = 0;\n    pair<int, int> zero = make_pair(0, 0);\n    for(int i = 0; i < h; i++){\n        for(int j = 0; j < w; j++){\n            result[i][j] = zero;\n            int c;\n            cin >> c;\n            if(c == 1) continue;\n            if(i == 0 && j == 0){\n                result[i][j] = make_pair(1, 1);\n            } else if(i == 0 || result[i - 1][j] == zero){\n                result[i][j].first = 1;\n                result[i][j].second = result[i][j - 1].second + 1;\n            } else if(j == 0 || result[i][j - 1] == zero){\n                result[i][j].first = result[i - 1][j].first + 1;\n                result[i][j].second = 1;\n            } else if(result[i - 1][j - 1] == zero){\n                if(result[i - 1][j].first > result[i][j - 1].second){\n                    result[i][j].first = result[i - 1][j].first + 1;\n                    result[i][j].second = 1;\n                } else {\n                    result[i][j].first = 1;\n                    result[i][j].second = result[i][j - 1].second + 1;\n                }\n            } else {\n                result[i][j].first = min(result[i - 1][j].first, min(result[i][j - 1].first, result[i - 1][j - 1].first)) + 1;\n                result[i][j].second = min(result[i - 1][j].second, min(result[i][j - 1].second, result[i - 1][j - 1].second)) + 1;\n            }\n            ans = max(ans, result[i][j].first * result[i][j].second);\n        }\n    }\n    // cout << endl;\n    // for(int i = 0; i < h; i++){\n    //     for(int j = 0; j < w; j++){\n    //         cout << result[i][j].first << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    // cout << endl;\n    // for(int i = 0; i < h; i++){\n    //     for(int j = 0; j < w; j++){\n    //         cout << result[i][j].second << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nstruct rect {\n    int pos, height;\n};\n\nint main() {\n\n    int H, W;\n    int T[H][W];\n\n    cin >> H >> W;\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int c;\n            cin >> c;\n            if (i == 0) {\n                T[i][j] = (c ? 0 : 1);\n            } else {\n                T[i][j] = (c ? 0 : T[i - 1][j] + 1);\n            }\n        }\n    }\n\n    //solve\n    int ans = 0;\n\n    for (int i = 0; i < W; i++) {\n        stack<rect> stk;\n        for (int j = 0; j < H; j++) {\n            int pos, height;\n            pos = j, height = T[i][j];\n            if (stk.empty() || stk.top().height < height) {\n                stk.push((rect) {pos, height});\n            } else if (stk.top().height > height) {\n                while (!stk.empty() && stk.top().height >= height) {\n                    rect pre = stk.top();\n                    stk.pop();\n                    ans = max(ans, pre.height * (j - pre.pos));\n                    pos = pre.pos;\n                }\n                stk.push((rect) {pos, height});\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint H, W;\n\tcin >> H >> W;\n\tvector<vector<int>> c(H, vector<int>(W + 1, 1));\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> c[i][j];\n\t\t}\n\t}\n\tvector<vector<int>> dp(H + 1, vector<int>(W + 1));\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W + 1; j++) {\n\t\t\tif (c[i][j]) {\n\t\t\t\tdp[i + 1][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i + 1][j] = dp[i][j] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tvector<int> st(1, 0), p(1, -1);\n\t\tfor (int j = 0; j <= W; j++) {\n\t\t\twhile (st.back() > dp[i + 1][j]) {\n\t\t\t\tres = max(res, st.back() * (j - p.back()));\n\t\t\t\tst.pop_back();\n\t\t\t\tp.pop_back();\n\t\t\t}\n\t\t\tif (st.back() < dp[i + 1][j]) {\n\t\t\t\tst.push_back(dp[i + 1][j]);\n\t\t\t\tp.push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nInt calc(vector<Int> &v){\n  Int n=v.size();\n  Int res=0;\n  using P = pair<Int, Int>;\n  stack<P> sp;\n  sp.emplace(-1,-1);\n  for(Int i=0;i<n;i++){\n    while(sp.top().second>v[i]){\n      chmax(res,(i-sp.top().first)*sp.top().second);\n      sp.pop();\n    }\n    if(sp.top().second<v[i]) sp.emplace(sp.top().first+1,v[i]);\n  }\n  while(!sp.empty()){\n    chmax(res,(n-sp.top().first)*sp.top().second);\n    sp.pop();\n  }\n  return res;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int h,w;\n  cin>>h>>w;\n  auto a=make_v<Int>(h,w);\n  for(Int i=0;i<h;i++)\n    for(Int j=0;j<w;j++)\n      cin>>a[i][j];\n  auto dp=make_v<Int>(h,w);\n  fill_v(dp,0);\n  for(Int i=0;i<h;i++){\n    for(Int j=0;j<w;j++){\n      if(a[i][j]) continue;\n      dp[i][j]=(i?dp[i-1][j]:0)+1;\n    }\n  }\n  Int ans=0;\n  for(Int i=0;i<h;i++) chmax(ans,calc(dp[i]));\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nInt calc(vector<Int> &v){\n  Int n=v.size();\n  Int res=0;\n  using P = pair<Int, Int>;\n  stack<P> sp;\n  sp.emplace(-1,-1);\n  for(Int i=0;i<n;i++){\n    Int j=i;\n    while(sp.top().second>v[i]){\n      j=sp.top().first;\n      chmax(res,(i-j)*sp.top().second);\n      sp.pop();\n    }\n    if(sp.top().second<v[i]) sp.emplace(j,v[i]);\n  }\n  while(!sp.empty()){\n    chmax(res,(n-sp.top().first)*sp.top().second);\n    sp.pop();\n  }\n  return res;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int h,w;\n  cin>>h>>w;\n  auto a=make_v<Int>(h,w);\n  for(Int i=0;i<h;i++)\n    for(Int j=0;j<w;j++)\n      cin>>a[i][j];\n  auto dp=make_v<Int>(h,w);\n  fill_v(dp,0);\n  for(Int i=0;i<h;i++){\n    for(Int j=0;j<w;j++){\n      if(a[i][j]) continue;\n      dp[i][j]=(i?dp[i-1][j]:0)+1;\n    }\n  }\n  Int ans=0;\n  for(Int i=0;i<h;i++) chmax(ans,calc(dp[i]));\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nInt calc(vector<Int> &v){\n  Int n=v.size();\n  Int res=0;\n  using P = pair<Int, Int>;\n  stack<P> sp;\n  sp.emplace(-1,-1);\n  for(Int i=0;i<n;i++){\n    while(sp.top().second>=v[i]){\n      chmax(res,(i-sp.top().first)*sp.top().second);\n      sp.pop();\n    }\n    chmax(res,(i-sp.top().first)*v[i]);\n    sp.emplace(i,v[i]);\n  }\n  return res;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int h,w;\n  cin>>h>>w;\n  auto a=make_v<Int>(h,w);\n  for(Int i=0;i<h;i++)\n    for(Int j=0;j<w;j++)\n      cin>>a[i][j];\n  auto dp=make_v<Int>(h,w);\n  fill_v(dp,0);\n  for(Int i=0;i<h;i++){\n    for(Int j=0;j<w;j++){\n      if(a[i][j]) continue;\n      dp[i][j]=(i?dp[i-1][j]:0)+1;\n    }\n  }\n  Int ans=0;\n  for(Int i=0;i<h;i++) chmax(ans,calc(dp[i]));\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<algorithm>\n#include<vector>\n#include<bitset>\n#include<queue>\n#include<stack>\n#include<utility>\n#include<list>\n#include<set>\n#include<map>\n#include<bitset>\n#include<tuple>\n#include<cstdio>\n#include<cstdlib>\n#include<complex>\n#include<iomanip>\n\nusing namespace std;\n\n#define MAX 100005\n#define ll long long\n#define pii pair<int,int>\n#define INT_MAX 2147483647\n\nint arr[MAX]; //opt[MAX];\n//int sum[MAX];\n//vector<pii> matriz;\n//vector <pii> parentesis;\nint n;\nint f;\nint matriz [1405][1405];\nint dist [1405][1405];\nint rigth [1405][1405];\nint lef[1405][1405];\nint temp;\ndeque < int > pila;\n\nint main ()\n{\n\tios_base::sync_with_stdio(0);\n\tcin.tie(0);\n\tcin >> n >> f;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int k = 0; k < f; k++)\n\t\t{\n\t\t\tcin >> temp;\n\t\t\tmatriz[i][k] = temp;\n\t\t}\n\t}\n\tfor (int j = 0; j < f; j++)\n\t{\n\t\tint cont = 0;\n\t\tfor (int i = n-1; i >= 0 ; i--)\n\t\t{\n\t\t\tif(matriz[i][j] == 0)\n\t\t\t{\n\t\t\t\tcont ++;\n\t\t\t\tdist [i][j] = cont; \n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tcont = 0;\n\t\t\t\tdist [i][j] = 0;\n\t\t\t}\n\n\t\t}\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tpila.clear();\n\t\tfor (int j = 0; j < f; j++)\n\t\t{\n\t\t\tif(pila.size() == 0)\n\t\t\t{\n\t\t\t\tlef[i][j] = -1;\n\t\t\t\tpila.push_back(j);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\tif(pila.size() == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tlef[i][j] = -1;\n\t\t\t\t\t\tpila.push_back(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(dist[i][j] <= dist[i][pila.back()] )\n\t\t\t\t\t{\n\t\t\t\t\t\tpila.pop_back();\n\t\t\t\t\t}\n\t\t\t\t\telse \n\t\t\t\t\t{\n\t\t\t\t\t\tlef[i][j] = pila.back();\n\t\t\t\t\t\tpila.push_back(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tpila.clear();\n\t\tfor (int j = f-1; j >=0; j--)\n\t\t{\n\t\t\tif(pila.size() == 0)\n\t\t\t{\n\t\t\t\trigth[i][j] = f;\n\t\t\t\tpila.push_back(j);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\twhile (true)\n\t\t\t\t{\n\t\t\t\t\tif(pila.size() == 0)\n\t\t\t\t\t{\n\t\t\t\t\t\trigth[i][j] = f;\n\t\t\t\t\t\tpila.push_back(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif(dist[i][j] <= dist[i][pila.back()] )\n\t\t\t\t\t{\n\t\t\t\t\t\tpila.pop_back();\n\t\t\t\t\t}\n\t\t\t\t\telse \n\t\t\t\t\t{\n\t\t\t\t\t\trigth[i][j] = pila.back();\n\t\t\t\t\t\tpila.push_back(j);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint max = -1;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = 0; j < f; j++)\n\t\t{\n\t\t\tif(dist[i][j] > 0)\n\t\t\t{\n\t\t\t\tint temp = dist[i][j] * ((rigth[i][j] - 1) - (lef[i][j] +1) +1 );\n\t\t\t\tif(max < temp)\n\t\t\t\t\tmax = temp;\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\tcout << max << '\\n';\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n\nusing namespace std;\n\n\nint c[1400][1400];\nint dp[1400][1400];\n\nstruct rt {\n\tint point;\n\tint height;\n};\n\nint max_in_x(int *l,int w) {\n\tstack<rt> st;\n\tint cur = 0;\n\tint sum = 0;\n\n\n\twhile(cur < w || !st.empty()) {\n\t\tint next_height = 0;\n\n\t\tif (cur < w) {\n\t\t\tint current_height = *(l + cur);\n\t\t\tif (st.empty() || st.top().height < current_height) {\n\t\t\t\trt a;\n\t\t\t\ta.point = cur;\n\t\t\t\ta.height = current_height;\n\t\t\t\tst.push(a);\n\t\t\t\tcur++;\n\t\t\t\tcontinue;\n\t\t\t} \n\t\t\tif (st.top().height == current_height) {\n\t\t\t\tcur++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (st.top().point != cur - 1) {\n\t\t\t\trt a;\n\t\t\t\ta.point = cur - 1;\n\t\t\t\ta.height = *(l + cur -1);\n\t\t\t\tst.push(a);\n\t\t\t}\n\t\t\tnext_height = *(l + cur);\t\t\t\n\t\t} else {\n\t\t\tif (st.top().point != w - 1) {\n\t\t\t\trt a;\n\t\t\t\ta.point = w - 1;\n\t\t\t\ta.height = *(l + w -1);\n\t\t\t\tst.push(a);\n\t\t\t}\t\t\t\n\t\t}\n\n\t\trt start = st.top();\n\t\trt current;\n\n\t\t//cout << \"dec start point:\" << start.point  << endl;\n\n\t\twhile(!st.empty()) {\n\t\t\tcurrent = st.top();\n\t\t\tst.pop();\n\n\t\t\tif (current.height < next_height) {\n\t\t\t\tcurrent.height = next_height;\n\t\t\t\tcurrent.point ++;\n\t\t\t\tst.push(current);\n\t\t\t\t//cout << \"    stack.point:\" << current.point <<  \" stack height:\" << next_height << endl; \n\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t//cout << \"    current.point:\" << current.point  << \" h:\" << current.height \n\t\t\t// << \" v:\" << (start.point - current.point + 1) * current.height <<  endl;\n\n\t\t\tsum = max(sum, (start.point - current.point + 1) * current.height);\n\t\t\n\t\t}\n\t}\n\treturn sum;\n}\n\n\nint main() {\n\tint W,H;\n\tcin >> H >> W;\n\t\n\tint v_max = 0;\n\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x < W; x++) {\n\n\t\t\tcin >> c[y][x];\n\t\t\tc[y][x] ^= 1;\n\t\t\tdp[y][x] = 0;\t\t\t\n\t\t}\n\t}\n\tfor (int x = 0; x < W; x++) {\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tif (c[y][x] == 0) {\n\t\t\t\tdp[y][x] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (y==0) {\n\t\t\t\tdp[y][x] = 1;\n\t\t\t\tcontinue;\t\t\t\t\n\t\t\t} \n\t\t\tdp[y][x] = dp[y-1][x] + 1;\n\t\t}\n\t}\n\n\tint s_max = 0;\n\n/*\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x < W; x++) {\n\t\t\tcout << setw(5) << dp[y][x] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n*/\n\t\n\tfor( int y = 0; y < H; y++) {\n\t\t\n\t\t// cout << \"** s_max y:\" << y << endl;\n\t\tint ret = max_in_x(dp[y],W); \n\t\t// cout << \"v:\" << ret << endl;\n\t\ts_max = max(s_max,ret);\n\t}\n\tcout << s_max << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<iostream>\n#include<algorithm>\n#define MAX 1400\nusing namespace std;\n\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectangle(int size,int buffer[]){\n    stack<Rectangle> S;\n    int maxv=0;\n    //???????????????????????¢?????????\n    //????????¨??°???DP??§??????????????°getLargestRectangle?????¢????¢???????\n    //????????¨??°?????´???????????´??§,????????????????????????,???????±?????????§???.\n    buffer[size]=0;\n\n    for(int i=0;i<=size;++i){\n        Rectangle rect;\n        rect.height=buffer[i];\n        rect.pos=i;\n        if(S.empty()){\n            S.push(rect);\n        }else{\n            if(S.top().height < rect.height){\n                S.push(rect);\n            }else if(S.top().height > rect.height){\n                int target=i;\n                while(!S.empty() && S.top().height >= rect.height){\n                    Rectangle pre=S.top();S.pop();\n                    int area=pre.height*(i-pre.pos);\n                    maxv=max(maxv,area);\n                    target=pre.pos;\n                }\n                rect.pos=target;\n                S.push(rect);\n            }\n        }\n    }\n    //printf(\"\\nmaxv: %d\\n\",maxv);\n    return maxv;\n}\n\nint H,W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle(){\n    //?¢?????????????????????????????????????????¢??±??????°????????????\n    for(int j=0;j<W;++j){\n        for(int i=0;i<H;++i){\n            if(buffer[i][j]){\n                T[i][j]=0;\n            }else{\n                T[i][j]=(i>0)?T[i-1][j]+1:1;\n            }\n        }\n    }\n    /*\n    ???:\n        0 0 1 0 0\n        1 0 0 0 0\n        0 0 0 1 0\n        0 0 0 1 0\n\n    After:\n        1 1 0 1 1\n        0 2 1 2 2\n        1 3 2 0 3\n        2 4 3 0 4\n    */\n    int maxv=0;\n    //?????\\????????? W,?????°,?????????T[i]?¬¬i???????????°???\n    for(int i=0;i<H;++i){\n        maxv=max(maxv,getLargestRectangle(W,T[i]));\n    }\n\n    return maxv;\n}\n\nint main(){\n    scanf(\"%d %d\",&H,&W);\n    for(int i=0;i<H;++i){\n        for(int j=0;j<W;++j){\n            scanf(\"%d\",&buffer[i][j]);\n        }\n    }\n\n    printf(\"%d\\n\",getLargestRectangle());\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1000000000 + 7;\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n\nint h, w;\nvector<vector<int>> grid(1005, vector<int>(1005));\n\nstruct Rectangle {int height, pos;};\n\nint largest_hist(int size, vector<int> &hist) {\n    stack<Rectangle> s;\n    int maxv = 0;\n    hist[size] = 0;\n\n    for (int i = 0; i <= size ; i++) {\n        Rectangle rect;\n        rect.height = hist[i];\n        rect.pos = i;\n\n        if (s.empty()) {\n            s.push(rect);\n        }\n        else {\n            if (s.top().height < rect.height) s.push(rect);\n            else if (s.top().height > rect.height) {\n                int target = i;\n                while (!s.empty() && s.top().height >= rect.height) {\n                    Rectangle pre = s.top(); s.pop();\n                    int area = pre.height * (i - pre.pos);\n                    maxv = max(maxv, area);\n                    target = pre.pos;\n                }\n                rect.pos = target;\n                s.push(rect);\n            }\n        }\n    }\n    return maxv;\n}\n\nint largest_rect(int h, int w, vector<vector<int>> &grid) {\n    vector<vector<int>> hist(h, vector<int>(w + 1));\n    for (int j = 0; j < w; j++) {\n        for (int i = 0; i < h; i++) {\n            if (grid[i][j] == 1) {\n                hist[i][j] = 0;\n            }\n            else {\n                hist[i][j] = (i > 0) ? hist[i - 1][j] + 1 : 1;\n            }\n        }\n    }\n\n    int ret = 0;\n    for (int i = 0; i < h; i++) {\n        ret = max(ret, largest_hist(w, hist[i]));\n    }\n    return ret;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> h >> w;\n    rep(i, h)rep(j, w) cin >> grid[i][j];\n    cout << largest_rect(h, w, grid) << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\nusing namespace std;\n\n\nint main(){\n    int W,H;\n    cin>>H>>W;\n    int dp[H][W];\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            int tile;\n            if(cin>>tile,tile==0){\n                dp[i][j]=(j?dp[i][j-1]:0)+1;\n            }else{\n                dp[i][j]=0;\n            }\n        }\n    }\n    int ans=0;\n    typedef pair<int,int> P;\n    stack<P,vector<P>> S;\n    for(int j=0;j<W;j++){\n        for(int i=0;i<H;i++){\n            if(S.empty()){\n                S.emplace(dp[i][j],i);\n                continue;\n            }\n            P p = S.top();\n            if(p.first==dp[i][j]){\n                continue;\n            }\n            if(p.first<dp[i][j]){\n                S.emplace(dp[i][j],i);\n                continue;\n            }\n            while(!S.empty()){\n                ans=max(ans,p.first*(i-p.second));\n                S.pop();\n                if(S.empty()){\n                    S.emplace(dp[i][j],p.second);\n                    break;\n                }\n                if(S.top().first>=dp[i][j]){\n                    p=S.top();\n                    S.pop();\n                    continue;\n                }else{\n                    S.emplace(dp[i][j],p.second);\n                    break;\n                }\n            }\n        }\n        while(!S.empty()){\n            P p = S.top(); S.pop();\n            ans=max(ans,p.first*(H-p.second));\n        }\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\nusing namespace std;\n\n\nint main(){\n    int W,H;\n    cin>>H>>W;\n    int dp[H][W];\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            int tile;\n            if(cin>>tile,tile==0){\n                dp[i][j]=(j?dp[i][j-1]:0)+1;\n            }else{\n                dp[i][j]=0;\n            }\n        }\n    }\n    int ans=0;\n    typedef pair<int,int> P;\n    stack<P,vector<P>> S;\n    for(int j=0;j<W;j++){\n        for(int i=0;i<H;i++){\n            if(S.empty()){\n                S.emplace(dp[i][j],i);\n                continue;\n            }\n            P p = S.top();\n            if(p.first==dp[i][j]){\n                continue;\n            }\n            if(p.first<dp[i][j]){\n                S.emplace(dp[i][j],i);\n                continue;\n            }\n            while(!S.empty()){\n                ans=max(ans,p.first*(i-p.second));\n                S.pop();\n                if(S.empty()){\n                    S.emplace(dp[i][j],p.second);\n                    break;\n                }\n                if(S.top().first>=dp[i][j]){\n                    p=S.top();\n                    S.pop();\n                    continue;\n                }else{\n                    S.emplace(dp[i][j],p.second);\n                    break;\n                }\n            }\n        }\n        while(!S.empty()){\n            P p = S.top(); S.pop();\n            ans=max(ans,p.first*(W-1-p.second));\n        }\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing vl = vector<ll>;\ntemplate<class T> using vc = vector<T>;\ntemplate<class T> using vvc = vector<vector<T>>;\n\n#define eb emplace_back\n#define all(x) (x).begin(), (x).end()\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define repr(i, n) for (ll i = (n)-1; i >= 0; i--)\n#define repe(i, l, r) for (ll i = (l); i < (r); i++)\n#define reper(i, l, r) for (ll i = (r)-1; i >= (l); i--)\n#define repa(i,n) for (auto& i: n)\n\ntemplate<class T> inline bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T &a, const T &b) { if (b<a) { a=b; return 1; } return 0; }\nvoid init() {cin.tie(0);ios::sync_with_stdio(false);cout << fixed << setprecision(15);}\n\n#ifdef DEBUG\ntemplate <class T, class N> void verr(const T& a, const N& n) { rep(i, n) cerr << a[i] << \" \"; cerr << \"\\n\" << flush; }\nll dbgt = 1; void err() { cerr << \"passed \" << dbgt++ << \"\\n\" << flush; }\ntemplate<class H, class... T> void err(H&& h,T&&... t){ cerr<< h << (sizeof...(t)?\" \":\"\\n\") << flush; if(sizeof...(t)>0) err(forward<T>(t)...); }\n#endif\n\nconst ll INF = 4e18;\nconst ld EPS = 1e-11;\nconst ld PI = acos(-1.0L);\nconst ll MOD = 1e9 + 7;\n// const ll MOD = 998244353;\n//--------------------------------------------------------------------------------//\nbool C[1500][1500];\nll dpt[1500][1500];\n\nint main() {\n    init();\n    ll H, W, ans = 0;\n    cin >> H >> W;\n    rep(i, H) rep(j, W) cin >> C[i][j];\n\n    rep(i, W) if (!C[0][i]) dpt[0][i] = 1;\n    repe(i, 1, H) rep(j, W) if (!C[i][j]) dpt[i][j] = dpt[i - 1][j] + 1;\n\n    stack<ll> st;\n    vl left(W + 1);\n    \n    rep(i,H){\n        rep(j,W + 1){\n            while(!st.empty() and dpt[i][st.top()]>=dpt[i][j]){\n                chmax(ans, (j - left[st.top()]) * dpt[i][st.top()]);\n                st.pop();\n            }\n            left[j] = st.empty() ? 0 : (st.top() + 1);\n            st.emplace(j);\n        }\n        st.pop();\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int h, w; cin >> h >> w;\n  VV<> c; assign(c, h, w);\n  for (int i = 0; i < h; ++i) for (int j = 0; j < w; ++j) cin >> c[i][j];\n  int res = 0;\n  for (int jl = 0; jl < w; ++jl) {\n    V<> a(h);\n    for (int i = 0; i < h; ++i) {\n      int j = jl;\n      while (j < w and !c[i][j]) ++a[i], ++j;\n    }\n    V<> l(h), r(h);\n    stack<int> st;\n    st.push(0);\n    for (int i = 1; i < h; ++i) {\n      while (!st.empty() and a[st.top()] >= a[i]) st.pop();\n      l[i] = !st.empty() ? a[st.top()] * (i - st.top() - 1) : a[i] * i;\n      st.push(i);\n    }\n    stack<int>().swap(st);\n    st.push(h - 1);\n    for (int i = h - 2; i >= 0; --i) {\n      while (!st.empty() and a[st.top()] >= a[i]) st.pop();\n      r[i] = !st.empty() ? a[st.top()] * (st.top() - 1 - i) : a[i] * (h - 1 - i);\n      st.push(i);\n    }\n    for (int i = 0; i < h; ++i) res = max(res, l[i] + a[i] + r[i]);\n  }\n  cout << res << '\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <stack>\n#include <algorithm>\n#define MAX 1400\nusing namespace std;\n\nstruct Rectangle\n{\n\tint height;\n\tint pos;\n};\n\nint getLargestRectangle(int size,int buffer[])\n{\n\tstack<Rectangle> S;\n\tint maxv=0;\n\tbuffer[size]=0;\n\t\n\tfor(int i=0;i<=size;i++)\n\t{\n\t\tRectangle rect;\n\t\trect.height=buffer[i];\n\t\trect.pos=i;\n\t\tif(S.empty())\n\t\t\tS.push(rect);\n\t\telse if(S.top().height>rect.height)\n\t\t{\n\t\t\tint target=i;\n\t\t\twhile(!S.empty()&&S.top().height>=rect.height)\n\t\t\t{\n\t\t\t\tRectangle pre=S.top();S.pop();\n\t\t\t\tint area=pre.height*(i-pre.pos);\n\t\t\t\tmaxv=max(maxv,area);\n\t\t\t\ttarget=pre.pos;\n\t\t\t}\n\t\t\trect.pos=target;\n\t\t\tS.push(rect);\n\t\t}\n\t}\n\treturn maxv;\n}\n\nint H,W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle()\n{\n\tfor(int j=0;j<W;j++)\n\t\tfor(int i=0;i<H;i++)\n\t\t\tif(buffer[i][j])\n\t\t\t\tT[i][j]=0;\n\t\t\telse\n\t\t\t\tT[i][j]=(i>0)?T[i-1][j]+1:1;\n\t\n\tint maxv=0;\n\tfor(int i=0;i<H;i++)\n\t\tmaxv=max(maxv,getLargestRectangle(W,T[i]));\n\t\n\treturn maxv;\n}\n\nint main()\n{\n\tscanf(\"%d %d\",&H,&W);\n\t\n\tfor(int i=0;i<H;i++)\n\t\tfor(int j=0;j<W;j++)\n\t\t\tscanf(\"%d\",&buffer[i][j]);\n\t\t\t\n\tcout<<getLargestRectangle()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint h,w;\nvi b;\n\nint main(){\n\tcin>>h>>w;\n\tb=vi(w+1);\n\tint res=0;\n\tfor(int i=0;i<h;i++){\n\t\tstack<P> st;\n\t\tst.push({-1,-1});\n\t\tfor(int j=0;j<=w;j++){\n\t\t\tif(j<w){\n\t\t\t\tint x;\n\t\t\t\tcin>>x;\n\t\t\t\tif(!x) b[j]++;\n\t\t\t\telse b[j]=0;\n\t\t\t}\n\t\t\twhile(st.top().first>b[j]){\n\t\t\t\tP p=st.top();st.pop();\n\t\t\t\tres=max(res,(j-p.second)*p.first);\n\t\t\t}\n\t\t\tif(st.top().first!=b[j]) st.push({b[j],j});\n\t\t}\n\t}\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n\nThis Submission is to determine how many 120/240 min const. delivery point there are.\n\n//info\n120 req. steps <= 5\n*/\n#define  _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <math.h>\n#include <iterator>\n#include <vector>\n#include <string>\n#include <set>\n#include <math.h>\n#include <iostream>\n#include <random>\n#include<map>\n#include <iomanip>\n#include <time.h>\n#include <stdlib.h>\n#include <list>\n#include <typeinfo>\n#include <list>\n#include <set>\n#include <cassert>\n#include<fstream>\n#include <unordered_map>\n#include <cstdlib>\n#include <complex>\n#include <cctype>\n#include <bitset>\nusing namespace std;\ntypedef string::const_iterator State;\n#define Ma_PI 3.141592653589793\n#define eps 1e-5\n#define LONG_INF 1e18\n#define GOLD 1.61803398874989484820458\n#define MAX_MOD 1000000007LL\n#define MOD 998244353LL\n#define seg_size 262144\n#define REP(a,b) for(long long a = 0;a < b;++a)\n\nunsigned long xor128() {\n\tstatic unsigned long x = time(NULL), y = 362436069, z = 521288629, w = 88675123;\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\ndouble dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.real() + a.imag() * b.imag();\n}\ndouble gyaku_dot(complex<double> a, complex<double> b) {\n\treturn a.real() * b.imag() - a.imag() * b.real();\n}\ndouble leng(complex<double> a) {\n\treturn sqrt(a.real() * a.real() + a.imag() * a.imag());\n}\ndouble angles(complex<double> a, complex<double> b) {\n\tdouble cosine = dot(a, b) / (leng(a) * leng(b));\n\tdouble sine = gyaku_dot(a, b) / (leng(a) * leng(b));\n\tdouble kaku = acos(min((double)1.0, max((double)-1.0, cosine)));\n\tif (sine <= 0) {\n\t\tkaku = 2 * Ma_PI - kaku;\n\t}\n\treturn kaku;\n}\nvector<int> convex_hull(vector<complex<double>> a) {\n\tvector<int> ans;\n\tdouble now_minnest = a[0].real();\n\tint now_itr = 0;\n\tREP(i, a.size()) {\n\t\tif (now_minnest > a[i].real()) {\n\t\t\tnow_minnest = a[i].real();\n\t\t\tnow_itr = i;\n\t\t}\n\t}\n\tans.push_back(now_itr);\n\tcomplex<double> ba(0, 1);\n\twhile (true) {\n\t\tint now_go = 0;\n\t\tdouble now_min = 0;\n\t\tdouble now_length = 0;\n\t\tint starter = ans[ans.size() - 1];\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tif (i != starter) {\n\t\t\t\tdouble goa = angles(ba, a[i] - a[starter]);\n\t\t\t\tif (goa - now_min >= eps || (abs(goa - now_min) <= eps && (abs(a[i] - a[starter]) - now_length) >= eps)) {\n\t\t\t\t\tnow_min = goa;\n\t\t\t\t\tnow_go = i;\n\t\t\t\t\tnow_length = abs(a[i] - a[starter]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (now_go == ans[0]) break;\n\t\tans.push_back(now_go);\n\t\tba = complex<double>(a[now_go] - a[starter]);\n\t}\n\treturn ans;\n}\nint dp[2001][2001] = {};\nint second_dp[2001][2001] = {};\nint main() {\n\tiostream::sync_with_stdio(false);\n\tcin.tie(0);\n\tint h, w;\n\tcin >> h >> w;\n\tvector<vector<int>> go;\n\t/*\n\tREP(i, h) {\n\t\tstring s;\n\t\tcin >> s;\n\t\tvector<int> A;\n\t\tREP(q, s.length()) {\n\t\t\tif (s[q] == '.')A.push_back(0);\n\t\t\telse A.push_back(1);\n\t\t}\n\t\tgo.push_back(A);\n\t}\n\t*/\n\tint ans = 0;\n\tREP(t, 1) {\n\t\t/*\n\t\tREP(i, h) {\n\t\t\tfor (int q = 0; q < w-1; ++q) {\n\t\t\t\tdp[i][q] = go[i][q] ^ go[i][q+1] ^ t;\n\t\t\t}\n\t\t}\n\t\t*/\n\t\tREP(i, h) {\n\t\t\tREP(q, w) {\n\t\t\t\tcin >> dp[i][q];\n\t\t\t\tdp[i][q] = (dp[i][q] + 1) % 2;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int q = w - 1; q >= 0; --q) {\n\t\t\t\tsecond_dp[i][q] = second_dp[i][q + 1] + 1;\n\t\t\t\tif (dp[i][q] == 0) {\n\t\t\t\t\tsecond_dp[i][q] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < w; ++i) {\n\t\t\tstack<pair<int, int>> geko;\n\t\t\tfor (int q = 0; q < h + 1; ++q) {\n\t\t\t\tif (geko.empty()) {\n\t\t\t\t\tgeko.push(make_pair(second_dp[q][i], q));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (geko.top().first < second_dp[q][i]) {\n\t\t\t\t\t\tgeko.push(make_pair(second_dp[q][i], q));\n\t\t\t\t\t}\n\t\t\t\t\telse if (geko.top().first > second_dp[q][i]) {\n\t\t\t\t\t\tint genya = -1;\n\t\t\t\t\t\twhile (geko.empty() == false && geko.top().first >= second_dp[q][i]) {\n\t\t\t\t\t\t\tpair<int, int> now = geko.top();\n\t\t\t\t\t\t\tgeko.pop();\n\t\t\t\t\t\t\tans = max(ans, (now.first) * (q - now.second));\n\t\t\t\t\t\t\tgenya = now.second;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (geko.empty() == true || geko.top().first != second_dp[q][i]) {\n\t\t\t\t\t\t\tgeko.push(make_pair(second_dp[q][i], genya));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 3B.cpp : このファイルには 'main' 関数が含まれています。プログラム実行の開始と終了がそこで行われます。\n//\n\n#include <iostream>\n#include<stdio.h>\n#include<stack>\n#include<algorithm>\n#define MAX 1400\n\nusing namespace std;\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nstruct Rectangle { int height; int pos; };\n \nint getLargestRectangle(int size, int buffer[]) {\n    stack<Rectangle> S;\n    int maxv = 0;\n    buffer[size] = 0;\n\n    for (int i = 0; i <= size; i++) {\n        Rectangle rect;\n        rect.height = buffer[i];\n        rect.pos = i;\n        if (S.empty()) {\n            S.push(rect);\n        }\n        else {\n            if (S.top().height < rect.height) {\n                S.push(rect);\n            }\n            else if (S.top().height > rect.height) {\n                int target = i;\n                while (!S.empty() && S.top().height >= rect.height) {\n                    Rectangle pre = S.top(); S.pop();\n                    int area = pre.height * (i - pre.pos);\n                    maxv = max(maxv, area);\n                    target = pre.pos;\n                }\n                rect.pos = target;\n                S.push(rect);\n            }\n        }\n    }\n    return maxv;\n}\nint getLargestRectangle() {\n    for (int j = 0; j < W; j++) {\n        for (int i = 0; i < H; i++) {\n            if (buffer[i][j]) {\n                T[i][j] = 0;\n            }\n            else {\n                T[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n            }\n        }\n    }\n\n    int maxv = 0;\n    for (int i = 0; i < H; i++) {\n        maxv = max(maxv, getLargestRectangle(W, T[i]));\n    }\n\n    return maxv;\n}\nint main()\n{\n    \n    cin >> H >> W;\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cin >> buffer[i][j];\n        }\n    }\n    cout << getLargestRectangle() << endl;\n\n    return 0;\n}\n\n// プログラムの実行: Ctrl + F5 または [デバッグ] > [デバッグなしで開始] メニュー\n// プログラムのデバッグ: F5 または [デバッグ] > [デバッグの開始] メニュー\n\n// 作業を開始するためのヒント: \n//    1. ソリューション エクスプローラー ウィンドウを使用してファイルを追加/管理します \n//   2. チーム エクスプローラー ウィンドウを使用してソース管理に接続します\n//   3. 出力ウィンドウを使用して、ビルド出力とその他のメッセージを表示します\n//   4. エラー一覧ウィンドウを使用してエラーを表示します\n//   5. [プロジェクト] > [新しい項目の追加] と移動して新しいコード ファイルを作成するか、[プロジェクト] > [既存の項目の追加] と移動して既存のコード ファイルをプロジェクトに追加します\n//   6. 後ほどこのプロジェクトを再び開く場合、[ファイル] > [開く] > [プロジェクト] と移動して .sln ファイルを選択します\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\nusing namespace std;\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n\n    int W,H;\n    cin>>H>>W;\n    int dp[H][W];\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            int tile;\n            if(cin>>tile,tile==0){\n                dp[i][j]=(j?dp[i][j-1]:0)+1;\n            }else{\n                dp[i][j]=0;\n            }\n        }\n    }\n    int ans=0;\n    typedef pair<int,int> P;\n    stack<P,vector<P>> S;\n    for(int j=0;j<W;j++){\n        for(int i=0;i<H;i++){\n            if(S.empty()){\n                S.emplace(dp[i][j],i);\n                continue;\n            }\n            P p = S.top();\n            if(p.first==dp[i][j]){\n                continue;\n            }\n            if(p.first<dp[i][j]){\n                S.emplace(dp[i][j],i);\n                continue;\n            }\n            while(!S.empty()){\n                ans=max(ans,p.first*(i-p.second));\n                S.pop();\n                if(S.empty()){\n                    S.emplace(dp[i][j],p.second);\n                    break;\n                }\n                if(S.top().first>=dp[i][j]){\n                    p=S.top();\n                    continue;\n                }else{\n                    S.emplace(dp[i][j],p.second);\n                    break;\n                }\n            }\n        }\n        while(!S.empty()){\n            P p = S.top(); S.pop();\n            ans=max(ans,p.first*(H-p.second));\n        }\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <string>\n#include <cmath>\nusing namespace std;\n#define MOD 1000000007\n#define INF 1<<30\n#define LINF (ll)1<<62\n#define rep(i,n) for(ll i=0; i<(n); i++)\n#define REP(i,a,b) for(ll i=(a); i<(b); i++)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll, ll> P;\ntypedef vector<pair<ll, ll>> vpl;\n\nll min3(ll a, ll b, ll c){\n    if(a < b){\n        if(b < c) return a;\n        else{\n            if(a < c) return a;\n            else return c;\n        }\n    }else{\n        if(b < c) return b;\n        else return c;\n    }\n}\n\nint main(){\n    ll h,w; cin >> h >> w;\n    ll c[h][w];\n    rep(i,h){\n        rep(j,w){\n            cin >> c[i][j];\n        }\n    }\n    vvl masu(h+1, vl(w+1,0));\n    REP(i,1,h+1){\n        REP(j,1,w+1){\n            if(c[i-1][j-1] == 1) masu[i][j] = 0;\n            else masu[i][j] = masu[i-1][j] + 1;\n        }\n    }\n    ll mx = 0;\n    stack<P> st;\n    for(ll i=h; i>0; i--){\n        for(ll j=w; j>0; j--){\n            if(j==w) st.emplace(masu[i][j],w);\n            else{\n                if(st.empty() || masu[i][j] > masu[i][j+1]){\n                    st.emplace(masu[i][j],j);\n                }else if(masu[i][j] < masu[i][j+1]){\n                    ll index;\n                    while(!st.empty()){\n                        if(st.top().first < masu[i][j]){\n                            st.emplace(masu[i][j],index);\n                            break;\n                        }\n                        auto t = st.top(); st.pop();\n                        index = t.second;\n                        mx = max(mx, t.first * (t.second - j));\n                        //cout << mx << \" \" << i << j << endl;\n                    }\n                    if(st.empty()) st.emplace(masu[i][j],index);\n                }\n            }\n        }\n        //cout << st.size() << endl;\n        while(!st.empty()){\n            auto t = st.top(); st.pop();\n            mx = max(mx, t.first * t.second);\n        }\n    }\n    cout << mx << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T> T largest_rectangle (vector<T> a) {\n\tusing value_type = T;\n    a.emplace_back(0);\n    int n = a.size();\n\tvalue_type ret = 0;\n    stack<pair<value_type, int>> sta;\n    for (int i = 0; i < n; i++) {\n        if (sta.empty()) {\n\t\t\tsta.emplace(a[i], i);\n        } else if (sta.top().first < a[i]) {\n\t\t\tsta.emplace(a[i], i);\n        } else if (sta.top().first > a[i]) {\n            int idx = i;\n            while (!sta.empty()) {\n                if (sta.top().first < a[i]) break;\n                value_type h; int t;\n\t\t\t\ttie(h, t) = sta.top();\n\t\t\t\tsta.pop();\n                value_type s = h * (i - t);\n\t\t\t\tidx = t;\n                if (ret < s) ret = s;\n            }\n            sta.emplace(a[i], idx);\n        }\n    }\n    return ret;\n}\n\n\nint main() {\n\tint h, w;\n\tcin >> h >> w;\n\tvector<vector<int>> a(h, vector<int>(w));\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tcin >> a[i][j];\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\tvector<int> hist(w, 0);\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tif (a[i][j]) hist[j] = 0;\n\t\t\telse hist[j]++;\n\t\t}\n\t\tans = max(ans, largest_rectangle(hist));\n\t}\n\t\n\tcout << ans << '\\n';\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n//#define int long long\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef unsigned __int128 HASH;\ntypedef pair<int,int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ull, ull> pullull;\ntypedef pair<ll,int> plli;\ntypedef pair<double, int> pdbi;\ntypedef pair<int,pii> pipii;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vi> vvi;\ntypedef vector<vvi> vvvi;\ntypedef vector<pii> vpii;\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n);i>0;i--)\n#define rrep2(i,a,b) for (int i=(a);i>b;i--)\n#define pb push_back\n#define fi first\n#define se second\n#define all(a) (a).begin(),(a).end()\n\nconst ll mod = 1000000000 + 7;\nconst ll hmod1 = 999999937;\nconst ll hmod2 = 1000000000 + 9;\nconst ll INF = 1<<30;\nconst int dx4[4] = {1, 0, -1, 0};\nconst int dy4[4] = {0, 1, 0, -1};\nconst int dx8[8] = {1, 1, 1, 0, 0, -1, -1, -1};\nconst int dy8[8] = {0, 1, -1, 1, -1, 0, 1, -1};\nconst double pi = 3.141592653589793;\n\n\nint h, w;\nvector<vector<int>> grid(2005, vector<int>(2005));\n\nstruct Rectangle {int height, pos;};\n\nint largest_hist(int size, vector<int> &hist) {\n    stack<Rectangle> s;\n    int maxv = 0;\n    hist[size] = 0;\n\n    for (int i = 0; i <= size ; i++) {\n        Rectangle rect;\n        rect.height = hist[i];\n        rect.pos = i;\n\n        if (s.empty()) {\n            s.push(rect);\n        }\n        else {\n            if (s.top().height < rect.height) s.push(rect);\n            else if (s.top().height > rect.height) {\n                int target = i;\n                while (!s.empty() && s.top().height >= rect.height) {\n                    Rectangle pre = s.top(); s.pop();\n                    int area = pre.height * (i - pre.pos);\n                    maxv = max(maxv, area);\n                    target = pre.pos;\n                }\n                rect.pos = target;\n                s.push(rect);\n            }\n        }\n    }\n    return maxv;\n}\n\nint largest_rect(int h, int w, vector<vector<int>> &grid) {\n    vector<vector<int>> hist(h, vector<int>(w + 1));\n    for (int j = 0; j < w; j++) {\n        for (int i = 0; i < h; i++) {\n            if (grid[i][j] == 1) {\n                hist[i][j] = 0;\n            }\n            else {\n                hist[i][j] = (i > 0) ? hist[i - 1][j] + 1 : 1;\n            }\n        }\n    }\n\n    int ret = 0;\n    for (int i = 0; i < h; i++) {\n        ret = max(ret, largest_hist(w, hist[i]));\n    }\n    return ret;\n}\n\nsigned main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cin >> h >> w;\n    rep(i, h)rep(j, w) cin >> grid[i][j];\n    cout << largest_rect(h, w, grid) << endl;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n\ni64 largest_rectangle(vi hist) {\n    hist.push_back(0);\n    using ii = pair<i64, int>;\n    stack<ii> st;\n    i64 ret = 0;\n    for (int i = 0; i < hist.size(); i++) {\n        if (st.empty() || st.top().first < hist[i]) {\n            st.push(ii(hist[i], i));\n        } else {\n            int s;\n            while (st.size() && st.top().first >= hist[i]) {\n                ret = max(ret, st.top().first * (i - st.top().second));\n                s = st.top().second;\n                st.pop();\n            }\n            st.push(ii(hist[i], s));\n        }\n    }\n    \n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    int h, w;\n    cin >> h >> w;\n    vvi b(h, vi(w));\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            int c;\n            cin >> c;\n            if (c == 0) {\n                if (i == 0) {\n                    b[i][j] = 1;\n                } else {\n                    b[i][j] = b[i - 1][j] + 1;\n                }\n            } else {\n                b[i][j] = 0;\n            }\n        }\n    }\n\n    i64 ret = 0;\n    for (int i = 0; i < h; i++) {\n        ret = max(ret, largest_rectangle(b[i]));\n    }\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<stack>\n#include<algorithm>\n#define MAX 1400\n\nusing namespace std;\n\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectangle(int size, int buffer[]) {\n  stack<Rectangle> S;\n  int maxv = 0;\n  buffer[size] = 0;\n\n  for ( int i = 0; i <= size; i++ ) {\n    Rectangle rect;\n    rect.height = buffer[i];\n    rect.pos = i;\n    if ( S.empty() ) {\n      S.push(rect);\n    } else {\n      if ( S.top().height < rect.height ) {\n        S.push(rect);\n      } else if ( S.top().height > rect.height ) {\n        int target = i;\n        while ( !S.empty() && S.top().height >= rect.height ) {\n          Rectangle pre = S.top(); S.pop();\n          int area = pre.height * (i - pre.pos);\n          maxv = max(maxv, area);\n          target = pre.pos;\n        }\n        rect.pos = target;\n        S.push(rect);\n      }\n    }\n  }\n  return maxv;\n}\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle() {\n  for ( int j = 0; j < W; j++ )\n    for ( int i = 0; i < H; i++ ) {\n      if ( buffer[i][j] )\n        T[i][j] = 0;\n      else\n        T[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n    }\n\n  int maxv = 0;\n  for ( int i = 0; i < H; i++ )\n    maxv = max(maxv, getLargestRectangle(W, T[i]));\n\n  return maxv;\n}\n\nint main() {\n  scanf(\"%d %d\", &H, &W);\n  for ( int i = 0; i < H; i++ )\n    for ( int j = 0; j < W; j++ )\n      scanf(\"%d\", &buffer[i][j]);\n  cout << getLargestRectangle() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\nconst int INF = 1<<28;\n#define MAX 1401\n\nint dp[MAX][MAX];\n\nint solve(int H, int W) {\n\tREP(j,W) {\n\t\tint v = 1;\n\t\tREP(i, H) {\n\t\t\tif(!dp[i][j])\n\t\t\t\tv = 0;\n\t\t\tdp[i][j] = v++;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tREP(i, H) {\n\t\tpair<int, int> p, p2;\n\t\tstack< pair<int, int> > s;\n\t\tdp[i][W] = 0;\n\t\tREP(j, W+1) {\n\t\t\tp = make_pair(dp[i][j], j);\n\t\t\tif(s.empty())\n\t\t\t\ts.push(p);\n\t\t\telse {\n\t\t\t\tif(s.top().first < p.first)\n\t\t\t\t\ts.push(p);\n\t\t\t\telse if(s.top().first > p.first) {\n\t\t\t\t\tint pnt = j;\n\t\t\t\t\twhile(!s.empty() && s.top().first >= p.first) {\n\t\t\t\t\t\tp2 = s.top(); s.pop();\n\t\t\t\t\t\tans = max(ans, p2.first * (j - p2.second));\n\t\t\t\t\t\tpnt = p2.second;\n\t\t\t\t\t}\n\t\t\t\t\tp.second = pnt;\n\t\t\t\t\ts.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tREP(i, H) REP(j, W) {\n\t\tcin >> dp[i][j];\n\t\tdp[i][j] = !dp[i][j];\n\t}\n\tcout << solve(H, W) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<stack>\n#include<algorithm>\n#define MAX 1400\n\nusing namespace std;\n\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectsngle(int size, int buffer[]) {\n\tstack<Rectangle> S;\n\tint maxv = 0;\n\tbuffer[size] = 0;\n\n\tfor (int i = 0; i <= size; i++) {\n\t\tRectangle rect;\n\t\trect.height = buffer[i];\n\t\trect.pos = i;\n\t\tif (S.empty()) {\n\t\t\tS.push(rect);\n\t\t}\n\t\telse {\n\t\t\tif (S.top().height < rect.height) {\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t\telse if (S.top().height > rect.height) {\n\t\t\t\tint target = i;\n\t\t\t\twhile (!S.empty() && S.top.height >= rect.height) {\n\t\t\t\t\tRectangle pre = S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tint area = pre.height*(i - pre.pos);\n\t\t\t\t\tmaxv = max(maxv, area);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos = target;\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxv;\n}\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle() {\n\tfor (int j = 0; j < W; j++) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tif (buffer[i][j]) {\n\t\t\t\tT[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tT[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxv = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tmaxv = max(maxv, getLargestRectangle(W, T[i]));\n\t}\n\n\treturn maxv;\n}\n\nint main() {\n\tscanf(\"%d %d\", &H, &W);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tscanf(\"%d\", &buffer[i][j]);\n\t\t}\n\t}\n\tcout << getLargestRectangle() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint c[1410][1410];\nint dp[1410];\n\nint main(void) {\n  int h, w;\n  cin >> h >> w;\n\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      cin >> c[i][j];\n    }\n  }\n\n  int ans = 0;\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if (!i) {\n        dp[j] = c[i][j] ? 0 : 1;\n      } else {\n        dp[j] = c[i][j] ? 0 : dp[j] + 1;\n      }\n    }\n\n    vector<int> L(w), R(w);\n    stack<int> st;\n    for (int j = 0; j < w; j++) {\n      while (!st.empty() && dp[st.top()] >= dp[j]) st.pop();\n      L[j] = st.empty() ? 0 : st.top() + 1;\n      st.push(j);\n    }\n    while (!st.empty()) st.pop();\n    for (int j = w - 1; j >= 0; j--) {\n      while (!st.empty() && dp[st.top()] >= dp[j]) st.pop();\n      R[j] = st.empty() ? w : st.top();\n      st.push(j);\n    }\n\n    for (int j = 0; j < w; j++) {\n      ans = max(ans, dp[j] * (R[j] - L[j]));\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <sstream>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n#define rrep(i, a) RREP(i, a, 0)\n#define RREP(i, a, b) for(int i = a; i >= b; --i)\n#define repll(i, a) REPLL(i, 0, a)\n#define REPLL(i, a, b) for(ll i = a; i < b; ++i)\n#define rrepll(i, a) RREPLL(i, a, 0)\n#define RREPLL(i, a, b) for(ll i = a; i >= b; --i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<int, P> PP;\nconst double PI = 3.14159265358979323846;\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+18 + 10;\n\nint h, w, ans = 0;\nint map[1405][1405];\n\nint main(){\n\tstd::cin >> h >> w;\n\trep(i, h){\n\t\trep(j, w)std::cin >> map[i][j], map[i][j] = (1 - map[i][j]);\n\t\tmap[i][w] = 1;\n\t}\n\n\trep(i, w){\n\t\tREP(j, 1, h)map[j][i] = (map[j][i] == 0 ? 0 : map[j - 1][i] + 1);\n\t}\n\n\trep(i, h){\n\t\tint max = 0;\n\t\tstd::stack<P> s;\n\t\trep(j, w + 1){\n\t\t\tint pos = j;\n\t\t\twhile (s.size() && s.top().first > map[i][j]){\n\t\t\t\tmax = std::max(max, s.top().first * (j - s.top().second));\n\t\t\t\ts.pop();\n\t\t\t\t--pos;\n\t\t\t}\n\t\t\ts.push(P(map[i][j], pos));\n\t\t}\n\n\t\tans = std::max(max, ans);\n\t}\n\n\tstd::cout << ans << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1401\nusing namespace std;\nint mp[N][N];\nint h,w;\n\nstruct dat{int h,i;};\n\nint calc(int A[]){\n  stack <dat> S;\n  int res = 0;\n  for(int i=0;i<=w;i++){\n    int h = A[i];\n    \n    if(S.empty() || S.top().h < h) S.push((dat){h,i});\n    else if(S.top().h == h);\n    else {\n      int ni = i;\n      while(!S.empty() && S.top().h > h){\n        dat t = S.top(); S.pop();\n        ni = t.i;\n        int area = (i - t.i) * t.h;\n        res = max(res,area);\n      }\n      res = max(res,(i-ni)*h);\n      S.push((dat){h,ni});\n    }\n    \n  }\n  return res;\n}\n\n\n\nint main(){\n\n  cin>>h>>w;\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)cin>>mp[i][j],mp[i][j]=!mp[i][j];\n  \n  for(int j=0;j<w;j++)\n    for(int i=1;i<h;i++)if(mp[i][j]) mp[i][j] = mp[i-1][j]+1;\n\n\n  //cout<<endl;for(int i=0;i<h;i++){for(int j=0;j<w;j++)cout<<mp[i][j]<<\" \";cout<<endl;}\n  int ans = 0;\n  for(int i=0;i<h;i++)ans = max(ans,calc(mp[i]));\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stack>\nusing namespace std;\n\nint h, w;\nint T[1401][1401];\n\nstruct Rect\t{\n\tint height, prepos;\n};\n\nclass Tile {\npublic:\n\tTile() {\n\t\tfor (int i = 0; i < h; i++)\t{\n\t\t\tT[i][w] = 0;\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tif (!i) T[i][j] = (T[i][j] + 1) % 2;\n\t\t\t\telse {\n\t\t\t\t\tT[i][j] = T[i][j] ? 0 : T[i - 1][j] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint largestRectangle(int row) { //???????????°????????¨????????????\n\t\tint maxR = 0;\n\t\tstack<Rect> R;\n\t\t\n\t\tfor (int j = 0; j <= w; j++) {\n\t\t\tRect rect;\n\t\t\trect.height = T[row][j];\n\t\t\trect.prepos = j;\n\t\t\tif (R.empty()) {\n\t\t\t\tR.push(rect);\n\t\t\t} else {\n\t\t\t\tif (rect.height > R.top().height) {\n\t\t\t\t\tR.push(rect);\n\t\t\t\t} else if (rect.height < R.top().height) {\n\t\t\t\t\tint target = j; //???????????????index????§?????????????\n\t\t\t\t\twhile (!R.empty() && rect.height <= R.top().height) { //???????????????????????±????????????????¶??????????????¨???°????\\???????????????????\n\t\t\t\t\t\tmaxR = max(maxR, R.top().height * (j - R.top().prepos));\n\t\t\t\t\t\ttarget = R.top().prepos;\n\t\t\t\t\t\tR.pop();\n\t\t\t\t\t}\n\t\t\t\t\trect.prepos = target;\n\t\t\t\t\tR.push(rect);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxR;\n\t}\n\n\tint largestRectangle() {\n\t\tint maxS = 0;\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tmaxS = max(maxS, largestRectangle(i));\n\t\t}\n\t\treturn maxS;\n\t}\n\n\t\n\n};\n\nint main() {\n\tcin >> h >> w;\n\tfor (int i = 0; i < h; i++)\t{\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tcin >> T[i][j];\n\t\t}\n\t}\n\n\tTile t = Tile();\n\n\tcout << t.largestRectangle(3) << endl;\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nsize_t get_largest_rectangle(vector<vector<int>> &g) {\n    size_t h=g.size(), w=g[0].size();\n\n    vector<vector<size_t>> dp(h, vector<size_t>(w+1));\n    size_t max_area=0;\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j) {\n            dp[i][j] = !g[i][j];\n            max_area |= dp[i][j];\n        }\n\n    for (size_t i=1; i<h; ++i)\n        for (size_t j=0; j<w; ++j)\n            if (dp[i][j])\n                dp[i][j] += dp[i-1][j];\n\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j) {\n            if (!dp[i][j]) continue;\n\n            size_t min_height=dp[i][j];\n            for (size_t k=j+1; k<w; ++k) {\n                if (!dp[i][k]) {\n                    max_area = max(max_area, (k-j)*min_height);\n                    break;\n                }\n\n                min_height = min(min_height, dp[i][k]);\n            }\n        }\n\n    return max_area;\n}\n\nint main() {\n    size_t h, w;\n    scanf(\"%zu %zu\", &h, &w);\n\n    vector<vector<int>> g(h, vector<int>(w));\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j)\n            scanf(\"%d\", &g[i][j]);\n\n    printf(\"%zu\\n\", get_largest_rectangle(g));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Rect {\n\tint h, p;\n};\n#define MAXH 1400\n#define MAXW 1400\nint H, W;\nint c[MAXH][MAXW];\nint T[MAXH][MAXW + 1];\n\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> c[i][j];\n\t\t}\n\t}\n\tfor (int j = 0; j < W; j++) {\n\t\tT[0][j] = (c[0][j] + 1) % 2;\n\t}\n\tT[0][W] = 0;\n\tfor (int i = 1; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (c[i][j] == 0) {\n\t\t\t\tT[i][j] = T[i - 1][j] + 1;\n\t\t\t} else if (c[i][j] == 1) {\n\t\t\t\tT[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tT[i][W] = 0;\n\t}\n\tint ans = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tstack<Rect> S;\n\t\tfor (int j = 0; j < W + 1; j++) {\n\t\t\tRect r = { T[i][j], j };\n\t\t\tif (S.empty()) {\n\t\t\t\tS.push(r);\n\t\t\t} else if (S.top().h < r.h) {\n\t\t\t\tS.push(r);\n\t\t\t} else if (S.top().h == r.h) {\n\t\t\t\t// DO NOTHING\n\t\t\t} else if (S.top().h > r.h) {\n\t\t\t\tint tgt = j;\n\t\t\t\twhile (!S.empty() && S.top().h >= r.h) {\n\t\t\t\t\tRect pre = S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tans = max(ans, (j - pre.p) * pre.h);\n\t\t\t\t\ttgt = pre.p;\n\t\t\t\t}\n\t\t\t\tr.p = tgt;\n\t\t\t\tS.push(r);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct rect{\n\t  int left, height;\n\t  rect(int l, int h){\n\t\t\tleft = l; height = h;\n\t  }\n};\n\nint solve(vector<int>& hist){\n\t  hist.push_back(0);\n\t  int W = hist.size();\n\t  int ans = 0;\n\t  stack<rect> st;\n\t  for(int i=0; i<W; i++){\n\t\t\tif( st.empty() ){\n\t\t\t\t  st.push( rect(i,hist[i]) );\t  continue;\n\t\t\t}\n\t\t\trect max_h = st.top();\n\t\t\tif( max_h.height < hist[i]){\n\t\t\t\t  st.push( rect(i,hist[i]) );\n\t\t\t}\n\t\t\telse if( max_h.height == hist[i] ){\n\t\t\t\t  continue;\n\t\t\t}\n\t\t\telse if( max_h.height > hist[i] ){\n\t\t\t\t  while( !st.empty() and max_h.height > hist[i] ) {\n\t\t\t\t\t\tans = max(ans, max_h.height * (i-max_h.left) );\n\t\t\t\t\t\tst.pop();\n\t\t\t\t  }\n\t\t\t\t  st.push( rect(max_h.left, hist[i]) ) ;\n\t\t\t}\n\t  }\n\t  return ans ;\n\t\t\t\n}\n\nint main(){\n\t  // input\n\t  int H,W;\n\t  cin >> H >> W;\n\t  vector<vector<int> > m(H+1,vector<int>(W,0));\n\t  for(int i=1; i<=H; i++)\n\t\t\tfor(int j=0; j<W; j++)\n\t\t\t\t  cin >> m[i][j];\n\n\t  // pre proces\n\t  vector<vector<int> > dp(H+1,vector<int>(W,0));\n\t  for(int i=1; i<=H; i++){\n\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\t  if(m[i][j] == 1)\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t  else\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j]+1;\n\t\t\t}\n\t  }\n\t  \n\t  int ans = 0;\n\t  for(int i=1; i<=H; i++){\n\t\t\tans = max(ans, solve(dp[i]));\n\t\t\tcout << endl;\n\t  }\n\n\t  /*\n\t  for(int i=1; i<=H; i++){\n\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\t  cout << dp[i][j] <<\" \";\n\t\t\t}\n\t\t\tcout << \": \" << solve(dp[i]) << endl;\n\t  }\n\t  */\n\t  \n\t  cout << ans << endl;\n\t  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\nstatic const int MAX=1400;\n\nstruct Rectangle{int height;int pos;};\n\nint getLargestRectangle(int size,int buffer[]){\n    stack<Rectangle> S;\n    int maxv=0;\n    buffer[size]=0;\n    \n    for(int i=0;i<=size;i++){\n        Rectangle rect;\n        rect.height=buffer[i];\n        rect.pos=i;\n        if(S.empty()){\n            S.push(rect);\n        }else{\n            if(S.top().height<rect.height){\n                S.push(rect);\n            }else if(S.top().height>rect.height){\n                int target=i;\n                while(!S.empty()&&S.top().height>=rect.height){\n                    Rectangle pre=S.top();S.pop();\n                    int area=pre.height*(i-pre.pos);\n                    maxv=max(maxv,area);\n                    target=pre.pos;\n                }\n                rect.pos=target;\n                S.push(rect);\n            }\n        }\n    }\n    return maxv;\n}\n\nint H,W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle(){\n    for(int j=0;j<W;j++){\n        for(int i=0;i<H;i++){\n            if(buffer[i][j]){\n                T[i][j]=0;\n            }else{\n                T[i][j]=(i>0)?T[i-1][j]+1:1;\n            }\n        }\n    }\n    int maxv=0;\n    for(int i=0;i<H;i++){\n        maxv=max(maxv,getLargestRectangle(W,T[i]));\n    }\n    return maxv;\n}\n\nint main(void){\n    scanf(\"%d %d\",&H,&W);\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            scanf(\"%d\",&buffer[i][j]);\n        }\n    }\n    \n    cout<<getLargestRectangle()<<endl;\n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n\tint h;\n\tint p;  // position from left\n};\n\nint max_area_of_histgram(int n, vector<int>& height) {\n\tstack<Rectangle> S;\n\n\t/*\tinitialize\t*/\n\tint maxv = 0;\n\n\tfor (int i = 0; i <= n; i++) {\n\t\tRectangle rect;\n\t\trect.h = height[i];\n\t\trect.p = i;\n\n\t\tif (S.empty()) {\n\t\t\tS.push(rect);\n\t\t}\n\t\telse if (S.top().h < rect.h) {\n\t\t\tS.push(rect);\n\t\t}\n\t\telse if (S.top().h > rect.h) {\n\t\t\tint now = i;\n\t\t\twhile (!(S.empty()) && (S.top().h >= rect.h)) {\n\t\t\t\tRectangle pre_rect = S.top(); S.pop();\n\t\t\t\tmaxv = max(maxv, pre_rect.h * (i - pre_rect.p));\n\t\t\t\tnow = pre_rect.p;\n\t\t\t}\n\t\t\trect.p = now;\n\t\t\tS.push(rect);\n\t\t}\n\t}\n\treturn maxv;\n}\n\nint get_Largest_Rectangle(int H,int W,vector<vector<int>>& dp) {\n\tfor (int h = 1; h < H; h++) {\n\t\tfor (int w = 0; w < W; w++) {\n\t\t\tif (dp[h][w] == 0) continue;\n\t\t\tdp[h][w] = dp[h - 1][w] + 1;\n\t\t}\n\t}\n\n\tint maxv = 0;\n\tfor (int h = 0; h < H; h++) {\n\t\tmaxv = max(maxv, max_area_of_histgram(W, dp[h]));\n\t}\n\treturn maxv;\n}\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>> c(H + 1, vector<int>(W + 1,0)), dp(H + 1, vector<int>(W + 1,0));\n\n\tfor (int h = 0; h < H; h++) {\n\t\tfor (int w = 0; w < W; w++) {\n\t\t\tcin >> c[h][w];\n\t\t\tif (c[h][w] == 0) { dp[h][w] = 1; }\n\t\t\telse { dp[h][w] = 0; }\n\t\t}\n\t}\n\tcout << get_Largest_Rectangle(H, W, dp) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<stack>\n#include<algorithm>\n#define MAX 1400\n\nusing namespace std;\n\nstruct Rectangle{int height; int pos;};\n\nint getLargestRectangle(int size, int buffer[]){\n\tstack<Rectangle> S;\n\tint maxv = 0;\n\tbuffer[size] = 0;\n\n\tfor(int i = 0; i <= size; i++){\n\t\tRectangle rect;\n\t\trect.height = buffer[i];\n\t\trect.pos = i;\n\t\tif(S.empty()){\n\t\t\tS.push(rect);\n\t\t}else{\n\t\t\tif(S.top().height < rect.height){\n\t\t\t\tS.push(rect);\n\t\t\t}else if(S.top().height > rect.height){\n\t\t\t\tint target = i;\n\t\t\t\twhile(!S.empty() && S.top().height >= rect.height){\n\t\t\t\t\tRectangle pre = S.top(); S.pop();\n\t\t\t\t\tint area = pre.height * (i - pre.pos);\n\t\t\t\t\tmaxv= max(maxv, area);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos = target;\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxv;\n}\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle(){\n\tfor(int j = 0; j < W; j++){\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tif(buffer[i][j]){\n\t\t\t\tT[i][j] = 0;\n\t\t\t}else{\n\t\t\t\tT[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxv = 0;\n\tfor(int i = 0; i < H; i++){\n\t\tmaxv = max(maxv, getLargestRectangle(W, T[i]));\n\t}\n\n\treturn maxv;\n}\n\nint main(){\n\tscanf(\"%d %d\", &H, &W);\n\tfor(int i = 0; i < H; i++){\n\t\tfor(int j = 0; j < W; j++){\n\t\t\tscanf(\"%d\", &buffer[i][j]);\n\t\t}\n\t}\n\tcout << getLargestRectangle() << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAX 1400+1\n#define BLOCK 1\n\nstruct Rectangle{ int height;  int pos; };\n\nint H, W;\n\nint getLargestRectangle( int size, int buffer[] )\n{\n\tstack<Rectangle> S;\n\tint maxv = 0;\n\tbuffer[size] = 0;\n\n\tfor( int i = 0; i <= size; i++ ) {\n\t\tRectangle rect;\n\t\trect.height = buffer[i];\n\t\trect.pos = i;\n\t\tif ( S.empty() ) {\n\t\t\tS.push( rect );\n\t\t} else {\n\t\t\tif ( S.top().height < rect.height ) {\n\t\t\t\tS.push( rect );\n\t\t\t} else if ( S.top().height > rect.height ) {\n\t\t\t\tint target = i;\n\t\t\t\twhile ( !S.empty() && S.top().height >= rect.height ) {\n\t\t\t\t\tRectangle pre = S.top(); S.pop();\n\t\t\t\t\tint area = pre.height * (i - pre.pos);\n\t\t\t\t\tmaxv = max( maxv, area );\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos = target;\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxv;\n}\n\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle()\n{\n\tfor( int i = 0; i < H; i++ ) {\n\t\tfor( int j = 0; j < W; j++ ) {\n\t\t\tT[i][j] = 0;\n\t\t}\n\t}\n\n\tfor( int j = 0; j < W; j++ ) {\n\t\tint sequence = 0;\n\t\tfor( int i = 0; i < H; i++ ) {\n\t\t\tif( buffer[i][j] == BLOCK ) {\n\t\t\t\tsequence = T[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tT[i][j] = ++sequence;\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxv = 0;\n\tfor( int i = 0; i < H; i++ ) {\n\t\tmaxv = max( maxv, getLargestRectangle( W, T[i] ) );\n\t}\n\n\treturn maxv;\n}\n\nint main()\n{\n\tcin >> H >> W;\n\tfor ( int i = 0; i < H; i++ ){\n\t\tfor ( int j = 0; j < W; j++ ){\n\t\t\tcin >> buffer[i][j];\n\t\t}\n\t}\n\n\tcout << getLargestRectangle() << endl;;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nclass Rect {\npublic:\n  int h, idx;\n  Rect(int h, int idx): h(h), idx(idx) {}\n};\n\nint max_from_hist(vector<int> cols) {\n  stack<Rect> s;\n  int max_v = 0;\n  cols[cols.size()] = 0;\n\n  for (int i = 0; i <= cols.size(); i++) {\n    Rect r(cols[i], i);\n\n    if (s.empty() || s.top().h < r.h) {\n      s.push(r);\n    } else if (s.top().h > r.h) {\n      int pos = i;\n\n      while (!s.empty() && s.top().h >= r.h) {\n        Rect pre = s.top(); s.pop();\n        int area = pre.h * (i - pre.idx); // h * colnum\n        max_v = max(max_v, area);\n        pos = pre.idx;\n      }\n\n      s.push(Rect(r.h, pos));\n    }\n  }\n\n  return max_v;\n}\n\nint main() {\n  int h, w; cin >> h >> w;\n\n  vector<vector<int> > T(h, vector<int>(w, 0));\n  vector<vector<int> > A(h, vector<int>(w, 0));\n\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      cin >> T[i][j];\n    }\n  }\n\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if (T[i][j]) A[i][j] = 0;\n      else A[i][j] = (i ? A[i-1][j] + 1 : 1);\n    }\n  }\n\n  int max_v = 0;  \n\n  for (int i = 0; i < h; i++)\n    max_v = max(max_v, max_from_hist(A[i]));\n\n  cout << max_v << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\nconst int adx[] = { 1,1,1,0,-1,-1,-1,0 };\nconst int ady[] = { 1,0,-1,-1,-1,0,1,1 };\n\nint add(const int base, const int plus) {\n\tif (!plus) {\n\t\treturn base + 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n//0 :?????????1:??????2:?????????3:??? 4:?????????5:??? 6:?????? 7:??? ???\nvector<vector<vector<int>>>get_cumulative_sum(const vector<vector<int>>&field) {\n\tconst int H = field.size();\n\tconst int W = field[0].size();\n\n\tvector<vector<vector<int>>>sums(H, vector<vector<int>>(W, vector<int>(8)));\n\tfor (int ny = 0; ny <H; ++ny) {\n\t\tfor (int nx = 0; nx <W; ++nx) {\n\t\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\t\tint py = ny - ady[k];\n\t\t\t\tint px = nx - adx[k];\n\t\t\t\tif (!(px >= 0 && px <W && py >= 0 && py <H))continue;\n\n\t\t\t\tsums[ny][nx][k] = add(sums[py][px][k], field[ny][nx]);\n\n\t\t\t}\n\t\t}\n\t}\n\tfor (int ny = H - 1; ny >= 0; --ny) {\n\t\tfor (int nx = 0; nx <W; ++nx) {\n\t\t\tfor (int k = 2; k < 4; ++k) {\n\t\t\t\tint py = ny - ady[k];\n\t\t\t\tint px = nx - adx[k];\n\t\t\t\tif (!(px >= 0 && px <W && py >= 0 && py <H))continue;\n\n\t\t\t\tsums[ny][nx][k] = add(sums[py][px][k], field[ny][nx]);\n\n\t\t\t}\n\t\t}\n\t}\n\tfor (int ny = H - 1; ny >= 0; --ny) {\n\t\tfor (int nx = W - 1; nx >= 0; --nx) {\n\t\t\tfor (int k = 4; k < 6; ++k) {\n\t\t\t\tint py = ny - ady[k];\n\t\t\t\tint px = nx - adx[k];\n\t\t\t\tif (!(px >= 0 && px <W && py >= 0 && py <H))continue;\n\n\t\t\t\tsums[ny][nx][k] = add(sums[py][px][k], field[ny][nx]);\n\n\t\t\t}\n\t\t}\n\t}\n\tfor (int ny = 0; ny <H; ++ny) {\n\t\tfor (int nx = W - 1; nx >= 0; --nx) {\n\t\t\tfor (int k = 6; k < 8; ++k) {\n\t\t\t\tint py = ny - ady[k];\n\t\t\t\tint px = nx - adx[k];\n\t\t\t\tif (!(px >= 0 && px <W && py >= 0 && py <H))continue;\n\n\t\t\t\tsums[ny][nx][k] = add(sums[py][px][k], field[ny][nx]);\n\n\t\t\t}\n\t\t}\n\t}\n\treturn sums;\n}\n\nint getans( vector<int>hs) {\n\ths.emplace_back(0);\n\tstack<pair<int, int>>que;\n\tint ans = 0;\n\tfor (int x = 0; x < hs.size(); ++x) {\n\t\t\n\t\tif (que.empty()) {\n\t\t\tque.push(make_pair(x, hs[x]));\n\t\t}\n\t\telse {\n\t\t\twhile (!que.empty()) {\n\t\t\t\tauto p = que.top();\n\t\t\t\tif (p.second < hs[x]) {\n\t\t\t\t\tque.push(make_pair(x,hs[x]));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (p.second == hs[x]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint area = (x - p.first)*p.second;\n\t\t\t\t\tans = max(ans, area);\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif (!que.empty()) {\n\t\t\t\t\t\tauto np = que.top();\n\t\t\t\t\t\tif (np.second < hs[x]) {\n\t\t\t\t\t\t\tque.push(make_pair(p.first, hs[x]));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\t\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>>field(H + 2, vector<int>(W + 2,1));\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tcin >> field[i + 1][j + 1];\n\t\t}\n\t}\n\tauto vs = get_cumulative_sum(field);\n\tint ans = 0;\n\t\n\tfor (int y = 1; y <= H; ++y) {\n\t\tvector<int>v;\n\t\tfor (int x = 1; x <= W; ++x) {\n\t\t\tv.push_back(vs[y][x][3]);\n\t\t}\n\t\tans = max(ans, getans(v));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\nint board[1500][1500];\nint dp[1500][1500];\n\nstruct Rectangle {\n    int height, pos;\n    Rectangle(int a, int b) : height(a), pos(b) {}\n};\n\nsigned main() {\n    int H, W; cin >> H >> W;\n    memset(dp, 0, sizeof(dp));\n    rep(i,0,H) rep(j,0,W) cin >> board[i][j];\n\n    rep(i,0,H) rep(j,0,W) {\n        if(board[i][j] == 1) dp[i][j] = 0;\n        else {\n            if(i == 0) dp[i][j] = 1;\n            else dp[i][j] = dp[i-1][j] + 1;\n        }\n    }\n\n    int ans = 0;\n    rep(i,0,H) {\n        stack<Rectangle> S;\n        repq(j,0,W) {\n            // printf(\"%lld \", dp[i][j]);\n            Rectangle Rect = Rectangle(dp[i][j], j);\n            if(S.empty()) S.push(Rect);\n            else {\n                if(S.top().height < dp[i][j]) S.push(Rect);\n                else if(S.top().height > dp[i][j]) {\n                    int target = j;\n                    while(!S.empty() && S.top().height >= dp[i][j]) {\n                        Rectangle TopRect = S.top(); S.pop();\n                        int temp = (j-TopRect.pos) * TopRect.height;\n                        // printf(\"j = %lld, pos = %lld, height = %lld, temp = %lld\\n\", j, TopRect.pos, TopRect.height, temp);\n                        ans = max(ans, temp);\n                        target = TopRect.pos;\n                    }\n                    Rect.pos = target;\n                    S.push(Rect);\n                }\n            }\n        }\n        // cout << endl;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) FOR(i,0,n)\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n#define PB push_back\n#define LB lower_bound\n#define UB upper_bound\n#define PQ priority_queue\n#define UM unordered_map\n#define ALL(a) (a).begin(),(a).end()\ntypedef vector<ll> vi;\ntypedef vector<vector<ll>> vvi;\nconst ll INF = (1ll << 60);\ntypedef pair<ll,ll> pii;\n\nll largestAreaHistogram(vi v){\n  ll N=v.size();\n  stack<pii> st; st.push({0,v[0]});\n  ll ans=v[0];\n  FOR(i,1,N) {\n    while(st.size()&&st.top().second>v[i]) {\n      ans=max(ans,st.top().second*(i-st.top().first));\n      st.pop();\n    }\n    st.push({i,v[i]});\n  }\n  while(st.size()) {\n    ans=max(ans,st.top().second*(N-st.top().first));\n    st.pop();\n  }\n  return ans;\n}\n\nint main(){\n  ll H,W; cin>>H>>W;\n  vvi c(H,vi(W));\n  REP(h,H) REP(w,W) cin>>c[h][w];\n  vvi dp(H,vi(W));\n  REP(w,W) if(c[0][w]==0) dp[0][w]=1; else dp[0][w]=0;\n  FOR(h,1,H) REP(w,W) if(c[h][w]==0) dp[h][w]=dp[h-1][w]+1; else dp[h][w]=0;\n  ll ans=0; REP(h,H) ans=max(ans,largestAreaHistogram(dp[h]));\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nvoid solve(){\n    int h,w;\n    static int c[1400][1400];\n    cin >> h >> w;\n    rep(i,0,h) rep(j,0,w) cin >> c[i][j];\n    \n    static int dp[1400][1400];\n    rep(i,0,h) rep(j,0,w){\n        if(!c[i][j]) dp[i][j]=1;\n        else dp[i][j]=0;\n    }\n    \n    int ans=0;\n    rep(i,1,h) rep(j,1,w){\n        if(c[i][j]) dp[i][j]=0;\n        else{\n            dp[i][j]=min({dp[i-1][j],dp[i][j-1],dp[i-1][j-1]})+1;\n            ans=max(ans,dp[i][j]);\n        }\n    }\n    \n    ans*=ans;\n    cout << ans << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\n\nint main(void){\n\tll H,W;\n\tcin>>H>>W;\n\tll c[1400][1400];//H,W\n\tll up[1400][1400];//?????´???\n\tll left[1400][1400];//?????´???\n\tll ans=0;\n\tll min;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tcin>>c[i][j];\n\t\t\tif(c[i][j]==0){\n\t\t\t\tif(i==0){\n\t\t\t\t\tup[0][j]=1;\n\t\t\t\t}else{\n\t\t\t\t\tup[i][j]=up[i-1][j]+1;\n\t\t\t\t}\n\t\t\t\tif(j==0){\n\t\t\t\t\tleft[i][0]=1;\n\t\t\t\t}else{\n\t\t\t\t\tleft[i][j]=left[i][j-1]+1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tup[i][j]=0;\n\t\t\t\tleft[i][j]=0;\n\t\t\t}\n\t\t\tmin=99999999999;\n\t\t\trep(k,up[i][j]){\n\t\t\t\tif(left[i-k][j]<min){\n\t\t\t\t\tmin=left[i-k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans<min*up[i][j])ans=min*up[i][j];\n\t\t\tmin=99999999999;\n\t\t\trep(k,left[i][j]){\n\t\t\t\tif(left[i][j-k]<min){\n\t\t\t\t\tmin=left[i-k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans<min*left[i][j])ans=min*left[i][j];\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Created by 李青坪 on 2019/1/20.\n//\n/*\n * 坑：\n * 1.每次从栈中弹出一个长方形后，当前元素所构成的长方形的左端点要更新到弹出的长方形对应的左端点\n * 2.s的每一行需要以0结尾，否则如果一行的数值相同，就计算不出长方形面积\n */\n\n\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <stack>\n\n#define MAXN 1400\n#define NIL -1\nusing namespace std;\n\nclass Rect {\npublic:\n    int h;\n    int pos;\n\n    Rect(int h, int pos) : h(h), pos(pos) {}\n};\n\nint H, W;\nint c[MAXN][MAXN];\nint s[MAXN][MAXN];\n\nvoid histogram() {\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            if (c[i][j] == 1) {\n                s[i][j] = 0;\n            } else {\n                s[i][j] = i > 0 ? s[i - 1][j] + 1 : 1;\n            }\n        }\n    }\n}\n\nint findLargestRect() {\n    int maxS = 0;\n    for (int i = 0; i < H; ++i) {\n        stack<Rect> stk;\n        for (int j = 0; j <= W; ++j) {\n            s[i][W] = 0;\n            if (stk.empty()) {\n                stk.push(Rect(s[i][j], j));\n            } else if (stk.top().h < s[i][j]) {\n                stk.push(Rect(s[i][j], j));\n            } else if (stk.top().h > s[i][j]) {\n                int pre_pos = j;\n                while (stk.top().h >= s[i][j]) {\n                    maxS = max(maxS, stk.top().h * (j - stk.top().pos));\n                    pre_pos = stk.top().pos; //\n                    stk.pop();\n                    if (stk.empty()) {\n                        break;\n                    }\n                }\n                stk.push(Rect(s[i][j], pre_pos));\n            }\n        }\n    }\n    return maxS;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; ++i) {\n        for (int j = 0; j < W; ++j) {\n            scanf(\"%d\", &c[i][j]);\n        }\n    }\n    histogram();\n    printf(\"%d\\n\", findLargestRect());\n}\n/*\n4 5\n0 0 1 0 0\n1 0 0 0 0\n0 0 0 1 0\n0 0 0 1 0\n */\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n\nstruct Val {\n    int height;\n    int pos;\n};\n\nint h;\nint w;\nint ans;\nint c[1401][1401];\nint suc[1401][1401];\n\nint main() {\n    scanf(\"%d%d\", &h, &w);\n    for (int i=0; i<h; i++) {\n        for (int j=0; j<w; j++) {\n            scanf(\"%d\", &c[i][j]);\n            c[i][j] ^= 1;\n            suc[i][j] = c[i][j];\n        }\n    }\n\n    for (int i=1; i<h; i++) {\n        for (int j=0; j<w; j++) {\n            if (c[i][j]) {\n                suc[i][j] = suc[i-1][j]+1;\n            } else {\n                suc[i][j] = 0;\n            }\n        }\n    }\n            \n    for (int i=0; i<h; i++) {\n        stack<struct Val> st;\n        \n        for (int j=0; j<=w; j++) {\n            struct Val v;\n            int newpos = j;\n\n            v.height = suc[i][j];\n            while (!st.empty() && st.top().height >= v.height) {\n                struct Val pre = st.top(); st.pop();\n                int area = pre.height * (j - pre.pos);\n                ans = max(ans, area);\n                newpos = pre.pos;\n            }\n            v.pos = newpos;\n            st.push(v);\n        }\n    }\n\n    printf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n\tRectangle rect;\n\tfor(int i=0;i<x;i++){\n\t\tstack<Rectangle> stk;\n\t\tfor(int j=0;j<=y;j++){\n\t\t\trect.height = m[j][i];\n\t\t\trect.pos = j;\n\t\t\tif(stk.empty() || stk.top().height < rect.height){\n\t\t\t\tstk.push(rect);\n\t\t\t}else if(stk.top().height>rect.height){\n\t\t\t\tint target = j;\n\t\t\t\tfor(;!stk.empty() && stk.top().height >= rect.height;){\n\t\t\t\t\tRectangle pre = stk.top(); stk.pop();\n\t\t\t\t\tint area = pre.height * (j - pre.pos);\n\t\t\t\t\tr = max(r, area);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos = target;\n\t\t\t\tstk.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n#pragma GCC optimize(\"O3\")\n#pragma GCC optimize(\"unroll-loops\")\n\ni64 largest_rectangle(vi& hist) {\n    hist.push_back(0);\n    using ii = pair<i64, int>;\n    stack<ii> st;\n    i64 ret = 0;\n    for (int i = 0; i < hist.size(); i++) {\n        if (st.empty() || st.top().first < hist[i]) {\n            st.push(ii(hist[i], i));\n        } else {\n            int s;\n            while (st.size() && st.top().first >= hist[i]) {\n                ret = max(ret, st.top().first * (i - st.top().second));\n                s = st.top().second;\n                st.pop();\n            }\n            st.push(ii(hist[i], s));\n        }\n    }\n    \n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    int h, w;\n    cin >> h >> w;\n    vvi b(h, vi(w));\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            int c;\n            cin >> c;\n            if (c == 0) {\n                if (i == 0) {\n                    b[i][j] = 1;\n                } else {\n                    b[i][j] = b[i - 1][j] + 1;\n                }\n            } else {\n                b[i][j] = 0;\n            }\n        }\n    }\n\n    i64 ret = 0;\n    for (int i = 0; i < h; i++) {\n        ret = max(ret, largest_rectangle(b[i]));\n    }\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 問題: H*Wのタイルが与えられる。タイルは綺麗か汚れているかのいずれか。\n//       綺麗なタイルのみでできる最大の長方形の最大値を求める\n// 解法: http://algorithms.blog55.fc2.com/blog-entry-133.html\n//       http://algorithms.blog55.fc2.com/blog-entry-132.html\n//       まず各要素について上に向かって 1 が何個連続しているかを示すテーブル T を作る\n//       次に、T の各行をヒストグラムの入力と見なしヒストグラムの最大長方形の面積を求めるアルゴリズムを適用\n\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n#define pb push_back\n#define mp make_pair\n\nint largest_square(const int H, const int W, const vector<vector<int>>& cells) {\n    // 上に綺麗なタイルが連続する数\n    // 番兵として、右端は汚れたタイルがあるものとする\n    vector<vector<int>> table(H, vector<int>(W+1));\n    REP(w, W) {\n        REP(h, H) {\n            auto val = cells[h][w];\n            if (val == 1) table[h][w] = 0;\n            else {\n                if (h == 0) table[h][w] = 1;\n                else table[h][w] = table[h-1][w] + 1;\n            }\n        }\n    }\n\n    // REP(h, H) {\n    //     REP(w, W+1) {\n    //         cerr << table[h][w] << \" \";\n    //     }\n    //     cerr << endl;\n    // }\n\n    int ans = 0;\n    // 各行ごとに、ヒストグラムの最大長方形の面積を求めるアルゴリズムを適用\n    REP(h, H) {\n        // <ヒストグラムの高さ, index>\n        stack<pair<int, int>> s;\n        REP(w, W+1) {\n            auto height = table[h][w];\n            if (s.empty()) s.push(mp(height, w));\n            else if (s.top().first < height) s.push(mp(height, w));\n            else if (s.top().first > height) {\n                int last_idx = w;\n                while(!s.empty() && s.top().first > height) {\n                    auto area = (w - s.top().second) * s.top().first;\n                    ans = max(area, ans);\n                    last_idx = s.top().second;\n                    s.pop();\n                }\n                s.push(mp(height, last_idx));\n            }\n        }\n    }\n    return ans;\n}\n\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n\n    vector<vector<int>> cells(H, vector<int>(W));\n    REP(h, H) {\n        REP(w, W) {\n            cin >> cells[h][w];\n        }\n    }\n\n    cout << largest_square(H, W, cells) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <algorithm>\n#include <utility>\n\nusing namespace std;\n\n// Find Maximum Size Rectangle\nint main() {\n    int h, w;\n    cin >> h >> w;\n\n    int G[h][w];\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            int x;\n            cin >> x;\n            G[i][j] = x;\n        }\n    }\n\n    int dp[h][w+1];\n    fill(&dp[0][0], &dp[h-1][w] + 1, 0);\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j < w; ++j) {\n            if (!G[i][j]) {\n                dp[i][j] = i > 0 ? dp[i-1][j] + 1 : 1;\n            }\n        }\n    }\n\n    int maxv = 0;\n    stack<pair<int, int>> S;\n    for (int i = 0; i < h; ++i) {\n        for (int j = 0; j <= w; ++j) {\n            auto rect = make_pair(dp[i][j], j);\n            if (S.empty()) {\n                S.push(rect);\n            } else {\n                if (S.top().first < rect.first) {\n                    S.push(rect);\n                } else if (S.top().first > rect.first) {\n                    auto pos = j;\n                    while (!S.empty() && S.top().first >= rect.first)  {\n                        auto pre = S.top(); S.pop();\n                        auto area = pre.first * (j - pre.second);\n                        maxv = max(maxv, area);\n                        pos = pre.second;\n                    }\n                    rect.second = pos;\n                    S.push(rect);\n                }\n            }\n        }\n    }\n    cout << maxv << endl;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint main(){\n\tint h,w,s,max=0;\n\tcin>>h>>w;\n\tint a[1401][1401]={};\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tcin>>s;\n\t\t\tif(s==0)a[i][j]=a[i][j-1]+1;\n\t\t\telse a[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=1;i<=w;i++){\n\t\tint f=0;\n\t\tfor(int j=1;j<=h;j++){\n\t\t\tif(a[j][i]>f) f=a[j][i];\n\t\t}\n\t\tfor(int j=1;j<=f;j++){\n\t\t\tint d=0;\n\t\t\tfor(int k=1;k<=h;k++){\n\t\t\t\tif(a[k][i]>=j){\n\t\t\t\t\td=d+j;\n\t\t\t\t\tif(max<d)max=d;\n\t\t\t\t}\n\t\t\t\telse d=0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << max << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// 問題: H*Wのタイルが与えられる。タイルは綺麗か汚れているかのいずれか。\n//       綺麗なタイルのみでできる最大の長方形の最大値を求める\n// 解法: http://algorithms.blog55.fc2.com/blog-entry-133.html\n//       http://algorithms.blog55.fc2.com/blog-entry-132.html\n//       まず各要素について上に向かって 1 が何個連続しているかを示すテーブル T を作る\n//       次に、T の各行をヒストグラムの入力と見なしヒストグラムの最大長方形の面積を求めるアルゴリズムを適用\n\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n#define pb push_back\n#define mp make_pair\n\nint largest_square(const int H, const int W, const vector<vector<int>>& cells) {\n    // 上に綺麗なタイルが連続する数\n    // 番兵として、右端は汚れたタイルがあるものとする\n    vector<vector<int>> table(H, vector<int>(W+1));\n    REP(w, W) {\n        REP(h, H) {\n            auto val = cells[h][w];\n            if (val == 1) table[h][w] = 0;\n            else {\n                if (h == 0) table[h][w] = 1;\n                else table[h][w] = table[h-1][w] + 1;\n            }\n        }\n    }\n\n    REP(h, H) {\n        REP(w, W+1) {\n            cerr << table[h][w] << \" \";\n        }\n        cerr << endl;\n    }\n\n    int ans = 0;\n    // 各行ごとに、ヒストグラムの最大長方形の面積を求めるアルゴリズムを適用\n    REP(h, H) {\n        // <ヒストグラムの高さ, index>\n        stack<pair<int, int>> s;\n        REP(w, W+1) {\n            auto height = table[h][w];\n            if (s.empty()) s.push(mp(height, w));\n            else if (s.top().first < height) s.push(mp(height, w));\n            else if (s.top().first > height) {\n                while(!s.empty() && s.top().first > height) {\n                    auto area = (w - s.top().second) * s.top().first;\n                    ans = max(area, ans);\n                    s.pop();\n                }\n            }\n        }\n    }\n    return ans;\n}\n\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n\n    vector<vector<int>> cells(H, vector<int>(W));\n    REP(h, H) {\n        REP(w, W) {\n            cin >> cells[h][w];\n        }\n    }\n\n    cout << largest_square(H, W, cells) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<stack>\nusing namespace std;\n\nconst int MAX = 1400;\n\nint main() {\n\tint H, W;\n\tint tile[MAX][MAX];\n\tint ans = 0;\n\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tscanf(\"%d\", &tile[i][j]);\n\t\t}\n\t}\n\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = W - 1; x >= 0; x--) {\n\t\t\tif (tile[y][x] == 1)tile[y][x] = -1;\n\t\t\telse if (x == W - 1)tile[y][x] = 0;\n\t\t\telse tile[y][x] = tile[y][x + 1] + 1;\n\t\t}\n\t}\n\n\tfor (int x = 0; x < W; x++) {\n\t\tstack<pair<int, int>> s;\n\t\ts.push(pair<int, int>(-1, -1));\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tif (s.top().second < tile[y][x]) {\n\t\t\t\ts.push(pair<int, int>(y, tile[y][x]));\n\t\t\t}\n\t\t\telse if (s.top().second > tile[y][x]) {\n\t\t\t\twhile (s.top().second > tile[y][x]) {\n\t\t\t\t\tans = max(ans, (y - s.top().first) * s.top().second);\n\t\t\t\t\ts.pop();\n\t\t\t\t}\n\t\t\t\tif(s.top().second != tile[y][x])s.push(pair<int, int>(y, tile[y][x]));\n\t\t\t}\n\t\t}\n\t\twhile (!s.empty()) {\n\t\t\tans = max(ans, (W - s.top().first) * s.top().second);\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long int\n#define MOD(x) ((x % MOD_N) + MOD_N) % MOD_N\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define FORE(i,a,b) for(int i=(a);i<=(b);++i)\n#define RFOR(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define RFORE(i,a,b) for(int i=(b);i>=(a);--i)\n#define REP(i,n) FOR(i,0,n)\n#define RREP(i,n) RFOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define RALL(c) (c).rbegin(),(c).rend()\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(c) (int)((c).size())\n#define EACH(i,v) for(auto i=v.begin();i!=v.end();++i)\n#define REACH(i,v) for(auto i=v.rbegin();i!=v.rend();++i)\n#define LB(c,x) distance((c).begin(),lower_bound(ALL(c),x))\n#define UB(c,x) distance((c).begin(),upper_bound(ALL(c),x))\n#define COUNT(c,x) (upper_bound(ALL(c),x)-lower_bound(ALL(c),x))\n#define UNIQUE(c) SORT(c); (c).erase(unique(ALL(c)),(c).end());\n#define COPY(c1,c2) copy(ALL(c1),(c2).begin())\n#define EXIST(s,e) (bool)((s).find(e)!=(s).end())\n#define PB push_back\n#define MP make_pair\n#define DUMP(x)  cerr<<#x<<\" = \"<<(x)<<endl;\n#define NL cerr<<endl;\nusing namespace std;\ntemplate<typename T,typename U> using P=pair<T,U>;\ntemplate<typename T> using V=vector<T>;\ntemplate<typename T>bool chmax(T&a,T b){if(a<b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a>b){a=b;return true;}return false;}\ntemplate<typename T>T sum(vector<T>&v){return accumulate(ALL(v),T());}\ntemplate<typename T>T sum(vector<T>&v,int a,int b){return accumulate(v.begin()+a,v.begin()+b,T());}\ntemplate<typename T>T max(vector<T>&v){return *max_element(ALL(v));}\ntemplate<typename T>T min(vector<T>&v){return *min_element(ALL(v));}\ntemplate<typename T>T max_index(vector<T>&v){return distance((v).begin(),max_element(ALL(v)));}\ntemplate<typename T>T min_index(vector<T>&v){return distance((v).begin(),min_element(ALL(v)));}\n\nstruct edge { int to, cost; };\n\ntemplate<typename T>auto&operator<<(ostream&s,const vector<T>&v){s<<\"[\";bool a=1;for(auto e:v){s<<(a?\"\":\" \")<<e;a=0;}s<<\"]\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const pair<T,U>&p){s<<\"(\"<<p.first<<\",\"<<p.second<<\")\";return s;}\ntemplate<typename T>auto&operator<<(ostream&s,const set<T>&st){s<<\"{\";bool a=1;for(auto e:st){s<<(a?\"\":\" \")<<e;a=0;}s<<\"}\";return s;}\ntemplate<typename T,typename U>auto&operator<<(ostream&s,const map<T,U>&m){s<<\"{\";bool a=1;for(auto e:m){s<<(a?\"\":\" \")<<e.first<<\":\"<<e.second;a=0;}s<<\"}\";return s;}\n\nconst int INF = 1e18;\nconst int MOD_N = 1e9+7;\n\nsigned main()\n{\n   int H, W; cin >> H >> W;\n   V<V<int>> c(H, V<int>(W));\n   REP(i, H) {\n      REP(j, W) {\n         cin >> c[i][j];\n      }\n   }\n\n   V<V<int>> h(H, V<int>(W+2));\n   REP(i, H) REP(j, W) {\n      if (c[i][j] == 1) {\n         h[i][j+1] = 0;\n      } else {\n         h[i][j+1] = 1 + (i == 0 ? 0 : h[i-1][j+1]);\n      }\n   }\n   REP(i, H) h[i][0] = -1;\n\n   int ans = 0;\n   REP(i, H) {\n      stack<int> st;\n      REP(j, W+2) {\n         while (!st.empty() && h[i][st.top()] >= h[i][j]) {\n            int m = h[i][st.top()]; st.pop();\n            chmax(ans, m * (j - st.top() - 1));\n         }\n         st.push(j);\n      }\n   }\n   cout << ans << endl;\n\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\nusing namespace std;\n\nint main(){\n\tint h, w;\n\tcin >> h >> w;\n\tint64_t dp[h][w + 1];\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tcin >> dp[i][j];\n\t\t\tdp[i][j] = !dp[i][j];\n\t\t}\n\t\tdp[i][w] = 0;\n\t}\n\tfor(int i = 1; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(dp[i][j] == 0) continue;\n\t\t\tdp[i][j] += dp[i - 1][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w + 1; j++) cerr << dp[i][j] << ' ';\n\t\tcerr << endl;\n\t}\n\tint64_t ans = 0;\n\tfor(int i = 0; i < h; i++){\n\t\tstack<int64_t> st;\n\t\tfor(int j = 0; j < w + 1; j++){\n\t\t\tif(st.empty()){\n\t\t\t\tst.emplace(dp[i][j]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int64_t x = 2; !st.empty() && dp[i][j] < st.top(); x++){\n\t\t\t\tst.pop();\n\t\t\t\tans = max(ans, x * dp[i][j]);\n\t\t\t}\n\t\t\tst.emplace(dp[i][j]);\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main()\n{\n\tint H, W;\n\tcin >> H >> W;\n\n\tvector<vector<int>> map;\n\tfor(int i = 0; i < H; i++)\n\t{\n\t\tvector<int> line;\n\t\tfor(int j = 0; j < W; j++)\n\t\t{\n\t\t\tint state;\n\t\t\tcin >> state;\n\t\t\tline.push_back(state == 0 ? 1 : 0);\n\t\t}\n\t\tmap.push_back(line);\n\t}\n\n\tfor(int i = 0; i < H-1; i++)\n\t{\n\t\tfor(int j = 0; j < W; j++)\n\t\t{\n\t\t\tif(map[i + 1][j] != 0)\n\t\t\t{\n\t\t\t\tmap[i + 1][j] += map[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tint maxValue = 0;\n\tfor(int i = 0; i < H; i++)\n\t{\n\t\tfor(int j = 0; j < W; j++)\n\t\t{\n\t\t\tint minHight = map[i][j];\n\t\t\t\n\t\t\tfor(int k = j; ; k++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(k >= W || map[i][k] == 0)\n\t\t\t\t{\n\t\t\t\t\tint buf = k-j+1 * minHight;\n\n\t\t\t\t\tmaxValue = maxValue > buf ? maxValue : buf;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\n\t\t\t\tminHight = minHight < map[i][j] ? minHight : map[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxValue << endl;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <unordered_map>\nconstexpr int MOD = 1000000000 + 7;\nconstexpr int INF = 2000000000;\nusing namespace std;\nusing LL = long long;\n\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectangle(int size, int buffer[]) {\n\tstack<Rectangle> S;\n\tint maxv = 0;\n\tbuffer[size] = 0;\n\tfor (int i = 0; i <= size; i++) {\n\t\tRectangle rect;\n\t\trect.height = buffer[i];\n\t\trect.pos = i;\n\t\tif (S.empty()) {\n\t\t\tS.push(rect);\n\t\t}\n\t\telse {\n\t\t\tif (S.top().height < rect.height)S.push(rect);\n\t\t\telse if (S.top().height > rect.height) {\n\t\t\t\tint target = i;\n\t\t\t\twhile (!S.empty() && S.top().height >= rect.height) {\n\t\t\t\t\tRectangle pre = S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tint area = pre.height*(i - pre.pos);\n\t\t\t\t\tmaxv = max(maxv, area);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos = target;\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxv;\n}\n\nint H, W;\nint Buffer[100][100];\nint T[100][100];\n\nint getLargestRectangle() {\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (Buffer[i][j]) {\n\t\t\t\tT[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tT[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n\t\t\t}\n\t\t}\n\t}\n\tint maxv = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tmaxv = max(maxv, getLargestRectangle(W, T[i]));\n\t}\n\treturn maxv;\n}\n\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> Buffer[i][j];\n\t\t}\n\t}\n\tcout << getLargestRectangle() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Largest Square\n#include <iostream>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nstatic const int MAX = 1400;\n\nstruct Rectangle {\npublic:\n    int height, pos;\n    Rectangle(int height, int pos): height(height), pos(pos) {}\n};\n\nint G[MAX][MAX];\nint H, W;\n\nint getLargestRectangle() {\n    stack<Rectangle> S;\n    int dp[H][W];\n    int maxArea = 0;\n\n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) {\n            dp[i][j] = (G[i][j] + 1) % 2;\n            if(i != 0 && dp[i][j] != 0) dp[i][j] += dp[i - 1][j];\n        }\n    }\n\n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) {\n            Rectangle rect = Rectangle(dp[i][j], j);\n            if(S.empty()) S.push(rect);\n            else {\n                if(S.top().height < rect.height) {\n                    S.push(rect);\n                } else if(S.top().height > rect.height) {\n                    int target = j;\n                    while(!S.empty() && S.top().height > rect.height) {\n                        maxArea = max(maxArea, (j - S.top().pos) * S.top().height);\n                        target = S.top().pos;\n                        S.pop();\n                    }\n                    S.push(Rectangle(rect.height, target));\n\n                }\n            }\n        }\n        while(!S.empty()) {\n            maxArea = max(maxArea, (W - S.top().pos) * S.top().height);\n            S.pop();\n        }\n    }\n    return maxArea;\n\n}\n\nint main() {\n    int c;\n    cin >> H >> W;\n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) cin >> G[i][j];\n    }\n\n    cout << getLargestRectangle() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\n//---------------------------------------------------------------------------------------------------\ntypedef long long ll;\nll maxRectangleInHistogram(vector<int> &v) {\n    int n = v.size();\n    stack<int> s;\n    vector<int> L(n), R(n);\n    rep(i, 0, n) {\n        while (s.size() && v[s.top()] >= v[i]) s.pop();\n        L[i] = s.size() ? (s.top() + 1) : 0;\n        s.push(i);\n    }\n    while (s.size()) s.pop();\n    rrep(i, n - 1, 0) {\n        while (s.size() > 0 && v[s.top()] >= v[i]) s.pop();\n        R[i] = s.size() ? s.top() : n;\n        s.push(i);\n    }\n    ll res = 0;\n    rep(i, 0, n) res = max(res, 1LL * v[i] * (R[i] - L[i]));\n    return res;\n}\nll maxRectangle(vector<vector<int>> &v) { // 0:can't use, 1:can use\n    int h = v.size();\n    int w = v[0].size();\n\n    ll res = 0;\n    vector<int> vv(w, 0);\n    rep(y, 0, h) {\n        rep(x, 0, w) {\n            if (v[y][x]) vv[x]++;\n            else vv[x] = 0;\n        }\n        res = max(res, maxRectangleInHistogram(vv));\n    }\n    return res;\n}\n/*---------------------------------------------------------------------------------------------------\n????????????????????????????????? ??§?????§  \n??????????????? ??§?????§ ???????´<_??? ?????? Welcome to My Coding Space!\n???????????? ??? ?´_???`??????/??? ???i     \n?????????????????????????????? ???  |???|     \n????????? /?????? /??£??£??£??£/??????|  \n??? ???_(__??????/???    ???/ .| .|????????????  \n??? ????????????/????????????/??????u??????  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\n\n\n\n\nint H, W, C[2020][2020];\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> H >> W;\n    rep(y, 0, H) rep(x, 0, W) cin >> C[y][x];\n\n    vector<vector<int>> v(H, vector<int>(W, 0));\n    rep(y, 0, H) rep(x, 0, W) v[y][x] = 1 - C[y][x];\n    cout << maxRectangle(v) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint H,W;\nint C[1410][1410];\nint S[1410][1410];\n\ndeque<pair<int,int>> Q; \nint main(){\n\tiostream::sync_with_stdio(false);\n\tcin>>H>>W;\n\tfor(int y=0;y<H;y++)\n\t\tfor(int x=0;x<W;x++)\n\t\t\tcin>>C[y][x];\n\tfor(int x=0;x<=W;x++)S[0][x]=0;\n\t//for(int y=0;y<=H;y++)S[y][0]=0;\n\tfor(int y=0;y<H;y++)\n\t{\n\t\tfor(int x=0;x<W;x++)\n\t\t\tS[y+1][x]=C[y][x]==0?S[y][x]+1:0;\n\t\t//cerr<<endl;\n\t}\n\tint m=0;\n\t\n\tfor(int y=0;y<=H;y++){\n\t\tQ.emplace_front(-1,0);\n\t\tfor(int x=0;x<=W;x++){\n\t\t\tint last_pop=x;\n\t\t\twhile(Q.front().second>S[y][x]){\n\t\t\t\tm=max(m,(x-Q.front().first)*Q.front().second);\n\t\t\t\tlast_pop=Q.front().first;\n\t\t\t\tQ.pop_front();\n\t\t\t}\n\t\t\tif(S[y][x]>Q.front().second){\n\t\t\t\tQ.emplace_front(last_pop,S[y][x]);\n\t\t\t\t//cerr<<x<<\" \"<<S[y][x]<<endl;\n\t\t\t}\n\t\t}\n\t}\n\t\t\t\n\tcout<<m<<endl;\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <stack>\n#include <algorithm>\nusing namespace std;\nint w;\nint b[1407][1407], pre[1407][1407];\nint solve(int height[]) {\n\tint ret = 0;\n\tstack<pair<int, int> > s;\n\tfor (int i = 1; i <= w + 1; i++) {\n\t\tif (s.empty()) s.push(make_pair(height[i], i));\n\t\telse {\n\t\t\tif (s.top().first < height[i]) s.push(make_pair(height[i], i));\n\t\t\telse if (s.top().first > height[i]) {\n\t\t\t\tint pos = i;\n\t\t\t\twhile (!s.empty() && s.top().first >= height[i]) {\n\t\t\t\t\tpair<int, int> cur = s.top();\n\t\t\t\t\tint area = cur.first * (i - cur.second);\n\t\t\t\t\ts.pop();\n\t\t\t\t\tret = max(ret, area);\n\t\t\t\t\tpos = cur.second;\n\t\t\t\t}\n\t\t\t\ts.push(make_pair(height[i], pos));\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint main() {\n    int h, ans = 0;\n    scanf(\"%d%d\", &h, &w);\n    for (int i = 1; i <= h; i++) {\n    \tfor (int j = 1; j <= w; j++) {\n    \t\tscanf(\"%d\", &b[i][j]);\n\t\t}\n\t}\n\tfor (int i = 1; i <= h; i++) {\n    \tfor (int j = 1; j <= w; j++) {\n    \t\tif (b[i][j] == 1) pre[i][j] = 0;\n\t\t\telse pre[i][j] = pre[i - 1][j] + 1;\n\t\t}\n\t}\n\tfor (int i = 1; i <= h; i++) {\n\t\tans = max(ans, solve(pre[i]));\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1401\nusing namespace std;\nint mp[N][N];\nint h,w;\n\nstruct dat{int h,i;};\n\nint calc(int A[]){\n  stack <dat> S;\n  int res = 0;\n  for(int i=0;i<=w;i++){\n    int h = A[i];\n    \n    if(S.empty() || S.top().h < h) S.push((dat){h,i});\n    else if(S.top().h == h);\n    else {\n      int ni = i;\n      while(!S.empty() && S.top().h > h){\n        dat t = S.top(); S.pop();\n        ni = t.i;\n        int area = (i - t.i+1) * h;\n        res = max(res,area);\n      }\n      S.push((dat){h,ni});\n    }\n    \n  }\n  return res;\n}\n\n\n\nint main(){\n\n  cin>>h>>w;\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)cin>>mp[i][j],mp[i][j]=!mp[i][j];\n  \n  for(int j=0;j<w;j++)\n    for(int i=1;i<h;i++)if(mp[i][j]) mp[i][j] = mp[i-1][j]+1;\n\n  int ans = 0;\n  for(int i=0;i<h;i++)ans = max(ans,calc(mp[i]));\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <stack>\n\nusing namespace std;\n\n#define MAX_W (1410)\n#define MAX_H (1410)\n\ntypedef pair<int, int> Data;\t// first: height, second: pos\n\nint hist[MAX_H][MAX_W];\nint tile[MAX_H][MAX_W];\t\t// 0: clean, 1: dirty\nint main()\n{\n    int H, W;\n    scanf(\"%d %d\", &H, &W);\n\n    for ( int y = 0; y < H; y++ ) {\n\tfor ( int x = 0; x < W; x++ ) {\n\t    scanf(\"%d\", &tile[y][x]);\n\t}\n    }\n\n    for ( int y = 0; y < H; y++ ) {\n\tfor ( int x = 0; x < W; x++ ) {\n\t    if ( tile[y][x] == 1 ) hist[y][x] = 0;\n\t    else {\n\t\tif ( y == 0 ) hist[y][x] = 1;\n\t\telse hist[y][x] = hist[y-1][x] + 1;\n\t    }\n\t}\n    }\n\n    int ans = 0;\n\n    for ( int y = 0; y < H; y++ ) {\n\tstack<Data> S;\n\tfor ( int x = 0; x < W; x++ ) {\n\t    if ( hist[y][x] > 0 ) {\n\t\tif ( S.empty() ) { // ????????´???\n\t\t    S.push( make_pair( hist[y][x], x ) );\n\t\t}\n\t\telse {\n\t\t    Data top = S.top();\n\t\t    if ( hist[y][x] > top.first ) {\n\t\t\tS.push( make_pair( hist[y][x], x ) );\t\t\t\n\t\t    } \n\t\t    else if ( hist[y][x] == top.first ) {\n\t\t\t// ???????????????\n\t\t    } \n\t\t    else if ( hist[y][x] < top.first ) {\n\t\t\tint prePos = x;\n\t\t\twhile ( !S.empty() ) {\n\t\t\t    Data top = S.top();\n\t\t\t    if ( hist[y][x] <= top.first ) {\n\t\t\t\tS.pop();\n\t\t\t\tans = max( ans, top.first * ( x - top.second ) );\n\t\t\t\tprePos = top.second;\n\t\t\t    }\n\t\t\t    else {\n\t\t\t\tbreak;\n\t\t\t    }\n\t\t\t}\n\t\t\tS.push( make_pair( hist[y][x], prePos ) );\n\t\t    }\n\t\t}\n\t    }\n\t    else {\n\t\twhile ( !S.empty() ) {\n\t\t    Data top = S.top(); S.pop();\n\t\t    ans = max( ans, top.first * ( x - top.second ) );\n\t\t}\n\t\t\n\t    }\n\t}\n\twhile ( !S.empty() ) {\n\t    Data top = S.top(); S.pop();\n\t    ans = max( ans, top.first * ( W - top.second ) );\n\t}\n    }\n\n    printf(\"%d\\n\", ans);\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<algorithm>\n#include<stack>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define INF INT_MAX/3\n#define PII pair<int,int>\n#define MPII(a,b) make_pair((a),(b))\n\nint M[1400][1400];\nint dp[1400][1400] = {};\n\nint main()\n{\n\tint ans = 0;\n\tint H, W;\n\tcin >> H >> W;\n\tREP(i, H)REP(j, W)cin >> M[i][j];\n\tREP(j, W)if (M[0][j] == 0)dp[0][j] = 1;\n\tFOR(i, 1, H)REP(j, W)if (M[i][j] == 0)dp[i][j] = dp[i - 1][j] + 1;\n\tREP(i, H)\n\t{\n\t\tstack<PII> stk;\n\t\tREP(j, W)\n\t\t{\n\t\t\tif (stk.empty() || stk.top().second < dp[i][j])\n\t\t\t{\n\t\t\t\tstk.push(MPII(j, dp[i][j]));\n\t\t\t}\n\t\t\telse if (stk.top().second > dp[i][j])\n\t\t\t{\n\t\t\t\twhile (stk.top().second > dp[i][j])\n\t\t\t\t{\n\t\t\t\t\tint rect = (j - stk.top().first)*stk.top().second;\n\t\t\t\t\tans = max(ans, rect);\n\t\t\t\t\tstk.pop();\n\t\t\t\t\tif (stk.empty())break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) begin(r),end(r)\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr ll inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\ninline bool value(int x,int y,int w,int h){\n  return (x >= 0 && x < w && y >= 0 && y < h);\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int h,w;\n  cin >> h >> w;\n  vector<vector<ll>> v(h,vector<ll>(w));\n  auto v2 = v;\n  rep(j,h){\n    rep(i,w){\n      cin >> v[j][i];\n      v[j][i] = !v[j][i];\n    }\n  }\n  ll ans = 0;\n  {\n    stack<pll> st;\n    rep(i,w){\n      v2[0][i] = v[0][i];\n      if(st.empty()){\n        st.push(mp(v2[0][i],i));\n      }\n      else if(st.top().fi < v2[0][i]){\n        st.push(mp(v2[0][i],i));\n      }\n      else if(st.top().fi > v2[0][i]){\n        ll pos = i;\n        while(!st.empty()){\n          if(st.top().fi >= v2[0][i]){\n            auto t = st.top();st.pop();\n            ans = max(ans,t.fi * (i - t.se));\n            pos = t.se;\n          }\n          else break;\n        }\n        st.push(mp(v2[0][i],pos));\n      }\n    }\n    ans = max(ans,st.top().fi * (w - st.top().se));\n  }\n  REP(j,1,h){\n    stack<pll> st;\n    rep(i,w){\n      if(v[j][i]){\n        v2[j][i] += v2[j-1][i] + 1;\n      }\n      if(st.empty()){\n        st.push(mp(v2[j][i],i));\n      }\n      else if(st.top().fi < v2[j][i]){\n        st.push(mp(v2[j][i],i));\n      }\n      else if(st.top().fi > v2[j][i]){\n        ll pos = i;\n        while(!st.empty()){\n          if(st.top().fi >= v2[j][i]){\n            auto t = st.top();st.pop();\n            ans = max(ans,t.fi * (i - t.se));\n            pos = t.se;\n          }\n          else break;\n        }\n        st.push(mp(v2[j][i],pos));\n      }\n    }\n    while(!st.empty()){\n      auto t = st.top();st.pop();\n      ans = max(ans,t.fi * (w - t.se));\n    }\n  }\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\nint board[1500][1500];\nint dp1[1500][1500];\nint dp2[1500][1500];\n\nsigned main() {\n    int H, W; cin >> H >> W;\n    memset(dp1, 0, sizeof(dp1));\n    memset(dp2, 0, sizeof(dp2));\n    repq(i,1,H) repq(j,1,W) cin >> board[i][j];\n    repq(i,0,H) board[i][0] = 1;\n    repq(i,0,W) board[0][i] = 1;\n\n    repq(i,1,H) repq(j,1,W) {\n        if(board[i][j] == 1) {\n            dp1[i][j] = 0;\n            dp2[i][j] = 0;\n        }\n        else {\n            dp1[i][j] = dp1[i-1][j] + 1;\n            dp2[i][j] = dp2[i][j-1] + 1;\n        }\n    }\n\n    int ans = 0;\n    repq(i,1,H) {\n        int t = 1, mi = INF;\n        repq(j,1,W) {\n            int k = j-t+1;\n            if(dp1[i][j] == 0) t = j+1;\n            else {\n                mi = min(mi, dp1[i][j]);\n                ans = max(ans, mi*k);\n            }\n        }\n    }\n\n    repq(j,1,W) {\n        int t = 1, mi = INF;\n        repq(i,1,H) {\n            int k = i-t+1;\n            if(dp2[i][j] == 0) t = i+1;\n            else {\n                mi = min(mi, dp2[i][j]);\n                ans = max(ans, mi*k);\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <functional>\n#include <map>\n#include <set>\n#include <cmath>\n#include <string>\n#define SIZE 200005\n#define INF 1000000005LL\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nint n;\nint h,w;\nll K;\nint S[1403][1403];\n//int dp[1403][1403];\nstack<P> T;\n\nvoid dp_init(){\n\tfor(int i=0;i<w;i++){\n\t\tS[0][i] = 0;\n\t\tfor(int j=1;j<=h;j++){\n\t\t\tS[j][i] = (S[j][i]==1?0:(S[j-1][i]+1));\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint cnt=0;\n\tint maxv = 0;\n\tint pos;\n\tfor(int i=1;i<=h;i++){\n\t\tcnt = 0;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(T.empty())T.push(make_pair(cnt,S[i][j]));\n\t\t\telse if(T.top().second < S[i][j]){\n\t\t\t\tT.push(make_pair(cnt,S[i][j]));\n\t\t\t}else if(T.top().second > S[i][j]){\n\t\t\t\twhile(!T.empty()){\n\t\t\t\t\tif(T.top().second > S[i][j]){\n\t\t\t\t\t\tmaxv = max(maxv,(cnt-T.top().first)*T.top().second);\n\t\t\t\t\t\tpos = T.top().first;\n\t\t\t\t\t\tT.pop();\n\t\t\t\t\t\t//printf(\"%d+\",maxv);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(T.top().second < S[i][j])T.push(make_pair(pos,S[i][j]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(T.empty())T.push(make_pair(cnt,S[i][j]));\n\t\t\t}\n\t\t\tcnt++;\n\t\t\t//printf(\"%d \",maxv);\n\t\t}\n\t\twhile(!T.empty()){\n\t\t\tmaxv = max(maxv,(cnt-T.top().first)*T.top().second);\n\t\t\tT.pop();\n\t\t\t//printf(\"%d+\",maxv);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",maxv);\n}\n\nint main()\n{\n\tscanf(\"%d %d\",&h,&w);\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tscanf(\"%d\",&S[i][j]);\n\t\t}\n\t}\n\tdp_init();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<stack>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int> rectangle;\nint h,w,max_measure,c[1400][1400];\nint hist[1400][1400];\n\n\nvoid gethist(){\n    for(int j=0;j<w;++j){\n        for(int i=0;i<h;++i){\n            if(c[i][j]==0 && i>0){\n                hist[i][j]=1+hist[i-1][j];\n            }\n            if(i==0){\n                hist[i][j]=1-c[i][j];\n            }\n        }\n    }\n}\n\nint dp_along_row(int size,int buffer[]){\n    \n    stack<rectangle> S;\n    int max_v=0;\n    buffer[size]=0; //likely to cause seg fault\n\n    for(int i=0;i<=size;++i){\n        \n        rectangle rect;\n        rect.first=buffer[i];\n        rect.second=i;\n\n        if(S.empty()){\n            S.push(rect);\n        }\n        else{\n            if(S.top().first<rect.first){\n                S.push(rect);\n            }\n            else if(S.top().first>rect.first){\n                \n                int target=i;\n                \n                while(!S.empty() && S.top().first>=rect.first){\n                    rectangle pre=S.top(); S.pop();\n                    int area=pre.first*(i-pre.second);\n                    max_v=max(max_v,area);\n                    target=pre.second;\n                }\n                \n                rect.second=target;\n                S.push(rect);\n            }\n        }\n    }\n\n    return max_v;\n}\n\nint advanced_dp(){\n\n    gethist();\n\n    int max_v=0;\n    for(int i=0;i<h;++i){\n        max_v=max(max_v,dp_along_row(w,hist[i]));\n    }\n    return max_v;\n}\n\nint main(){\n    cin>>h>>w;\n    for(int i=0;i<h;++i){\n        for(int j=0;j<w;++j){\n            cin>>c[i][j];\n        }\n    }\n\n    cout<<advanced_dp()<<endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint n, c[1500][1500], dp[1500][1500], l[1500], r[1500];\nsigned main(void)\n{\n  int H, W;\n  cin >> H >> W;\n  REP(i, H) REP(j, W) cin >> c[i][j];\n\n  REP(i, H) REP(j, W) {\n    if(c[i][j]) dp[i][j] = 0;\n    else {\n      if(!i) dp[i][j] = 1;\n      else dp[i][j] = dp[i-1][j] + 1;\n    }\n  }\n  ll ret = 0;\n  REP(j, H) {\n    stack<int> st;\n    REP(i, W) {\n      while(st.size() && dp[j][st.top()] >= dp[j][i]) st.pop();\n      if(!st.size()) l[i] = i;\n      else l[i] = i-st.top()-1;\n      st.push(i);\n    }\n    while(st.size()) st.pop();\n    for(int i=W-1; i>=0; --i) {\n      while(st.size() && dp[j][st.top()] >= dp[j][i]) st.pop();\n      if(!st.size()) r[i] = W-i-1;\n      else r[i] = st.top()-i-1;\n      st.push(i);\n    }\n    REP(i, W) ret = max(ret, (ll)dp[j][i]*(r[i]+l[i]+1));\n  }\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define ALL(a) (a).begin(),(a).end()\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n \nusing namespace std;\nstruct po{int x,y,is_tile,wall;};\n \nint main(){\n  int H,W;\n  cin >> H >> W;\n  po dp[1000][1000];\n  REP(i,1)\n    REP(j,1){\n      dp[i][j].is_tile = 0;\n      dp[i][j].x = 0;\n      dp[i][j].y = 0;\n      dp[i][j].wall = 0;\n  }\n   \n  REP(i,H)\n    REP(j,W)\n    cin >> dp[i+1][j+1].is_tile;\n \n  int max_rectangle = 0;\n  REP(i,H){\n    REP(j,W){\n      if(dp[i][j].is_tile == 1){\n\tif(dp[i][j+1].y > dp[i+1][j].x){\n\t    dp[i+1][j+1].y = dp[i][j+1].y + 1;\n\t    dp[i+1][j+1].x = 1;\n\t}else{\n\t    dp[i+1][j+1].x = dp[i+1][j].x + 1;\n\t    dp[i+1][j+1].y = 1;\n\t}\n      }else if(dp[i][j+1].is_tile == 1){\n\tdp[i+1][j+1].x = j + 1 - dp[i+1][0].wall;\n\tdp[i+1][j+1].y = 1;\n      }else if(dp[i+1][j].is_tile == 1){\n\tdp[i+1][j+1].x = 1;\n\tdp[i+1][j+1].y = i + 1 - dp[0][j+1].wall;\n      }else if((dp[i+1][j].is_tile == 1) && (dp[i][j+1].is_tile == 1)){\n\tdp[i+1][j+1].x = 1;\n\tdp[i+1][j+1].y = 1;\n      }else if(dp[i+1][j+1].is_tile == 0){\n\tif(dp[i][j].x > dp[i+1][j].x && dp[i][j].y > dp[i][j+1].y){\n\t  dp[i+1][j+1].x = dp[i+1][j].x + 1;\n\t  dp[i+1][j+1].y = dp[i][j+1].y + 1;\n\t}else if(dp[i+1][j].x+1 < dp[i][j+1].y+1){\n\t  if( (dp[i][j].y+1)*(dp[i][j].x+1) > dp[i][j+1].y+1){\n\t    dp[i+1][j+1].x = dp[i][j].x + 1;\n\t    dp[i+1][j+1].y = dp[i][j].y + 1;\n\t  }else{\n\t    dp[i+1][j+1].y = dp[i][j+1].y + 1;\n\t    dp[i+1][j+1].x = 1;\n\t  }\n\t}else{\n\t  if( (dp[i][j].y+1)*(dp[i][j].x+1) > dp[i+1][j].x+1){\n\t    dp[i+1][j+1].x = dp[i][j].x + 1;\n\t    dp[i+1][j+1].y = dp[i][j].y + 1;\n\t  }else{\n\t    dp[i+1][j+1].x = dp[i+1][j].x + 1;\n\t    dp[i+1][j+1].y = 1;\n\t  }\n\t}\n      }else{\n\tdp[i+1][j+1].x = 0;\n\tdp[i+1][j+1].y = 0;\n\tdp[0][j+1].wall = i+1;\n\tdp[i+1][0].wall = j+1;\n      }\n      max_rectangle = max(max_rectangle,dp[i+1][j+1].x * dp[i+1][j+1].y);\n\n    }\n  }\n  /*  REP(i,H+1){\n    REP(j,W+1){\n      cout << \"(\" <<dp[i][j].x << \",\" << dp[i][j].y << \") \";\n    }\n        cout << endl;\n\t}*/\n  \n  cout << max_rectangle << endl;\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\n\n#define DUMP(x) cout<<#x<<\":\"<<(x)<<endl\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class T>\nistream& operator>>(istream& is, vector<T>& xs){\n  for(auto& x: xs)\n\tis >> x;\n  return is;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nostream& operator<<(ostream& os, const vector<T>& xs){\n  for(unsigned int i=0;i<xs.size();++i)\n\tos << (i?\" \":\"\") << xs[i];\n  return os;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int H, W;\n  cin >> H >> W;\n  \n  VVI xs(H, VI(W));\n  cin >> xs;\n  REP(y,H) REP(x,W){\n\txs[y][x] ^= 1;\n\tif(xs[y][x]) xs[y][x] += (y>0? xs[y-1][x]: 0);\n  }\n\n  int ans = 0;\n  REP(y,H){\n\tstack<PII> s;\n\tREP(x,W){\n\t  while(!s.empty() && s.top().FF > xs[y][x]){\n\t\tmaxi(ans, s.top().FF*(x-s.top().SS));\n\t\ts.pop();\n\t  }\n\t  if(xs[y][x]) s.emplace(xs[y][x], x);\n\t}\n\twhile(!s.empty()){\n\t  maxi(ans, s.top().FF*(W-s.top().SS));\n\t  s.pop();\n\t}\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node\n{\n    int x,y;\n};\nstack<node> d;\n#define mo 1500\nint a[mo][mo];\nint main()\n{\n    int n,m;\n    while(cin>>n>>m)\n    {\n        int x;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=m;j++)\n            {\n                cin>>x;\n                if(!x)\n                    a[i][j]+=a[i-1][j]+1;\n\n            }\n        }\n\n        /*\n        cout<<endl;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=m;j++)\n            {\n                cout<<a[i][j]<<' ';\n            }\n            cout<<endl;\n        }\n        */\n\n\n        node t;\n        int maxs=0;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=m;j++)\n            {\n                t.x=a[i][j];\n                t.y=j;\n\n                if(d.size()==0||t.x>d.top().x) d.push(t);\n                else if(t.x<d.top().x)\n                {\n                    int l=j;\n                    while(d.size()&&d.top().x>t.x)\n                    {\n                        maxs=max(maxs,(l-d.top().y)*d.top().x);\n                        t.y=d.top().y;\n                        d.pop();\n                    }\n                    d.push(t);\n                }\n                //cout<<setw(3)<<maxs<<' ';\n            }\n            int l=m;\n            while(d.size()>0)\n            {\n\n                maxs=max(maxs,(l-d.top().y+1)*d.top().x);\n               // cout<<d.top().x<<' '<<d.top().y<<' '<<l<<' '<<maxs<<endl;\n                d.pop();\n            }\n            //cout<<endl;\n\n        }\n        cout<<maxs<<endl;\n\n\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_3_B\n\nint LargestRectangleInAHistogram(vector<int> h) {\n  assert( h.size() );\n  stack<int> stk;\n  int n = (int)h.size();\n  vector<int> L(n), R(n);\n  for(int i=0;i<n;++i) {\n    while( !stk.empty() && h[stk.top()] >= h[i] ) stk.pop();\n    L[i] = (stk.empty()?0:stk.top()+1);\n    stk.push(i);\n  }\n  for(int i=n-1;i>=0;--i) {\n    while( !stk.empty() && h[stk.top()] >= h[i] ) stk.pop();\n    R[i] = (stk.empty()?n-1:stk.top()-1);\n    stk.push(i);\n  }\n  int maxi = 0;\n  for(int i=0;i<n;++i) {\n    maxi = max(maxi,h[i] * ( R[i] - L[i] + 1 ));\n  }\n  return maxi;\n}\n\nint LargestRectangle(int H,int W,vector<vector<int> > c) {\n  vector<vector<int> > hs(H,vector<int>(W,0));\n  for(int i=0;i<H;++i) {\n    for(int j=0;j<W;++j) {\n      if( c[i][j] ) continue;\n      hs[i][j] = ((i-1>=0)?hs[i-1][j]:0) + 1;\n    }\n  }\n  int maxi = 0;\n  for(int i=0;i<H;++i) {\n    vector<int> h(W);\n    for(int j=0;j<W;++j) {\n      h[j] = hs[i][j];\n    }\n    maxi = max(maxi,LargestRectangleInAHistogram(h));\n  }\n  return maxi;\n}\n\nint main() {\n  int H,W;\n  cin >> H >> W;\n  vector<vector<int> > c(H,vector<int>(W));\n  for(int i=0;i<H;++i) for(int j=0;j<W;++j) cin >> c[i][j];\n  cout << LargestRectangle(H,W,c) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define REP(i,n) for(int i=0,_n=(int)(n);i<_n;++i)\n#define ALL(v) (v).begin(),(v).end()\n#define CLR(t,v) memset(t,(v),sizeof(t))\ntemplate<class T1,class T2>ostream& operator<<(ostream& os,const pair<T1,T2>&a){return os<<\"(\"<<a.first<<\",\"<<a.second<< \")\";}\ntemplate<class T>void pv(T a,T b){for(T i=a;i!=b;++i)cout<<(*i)<<\" \";cout<<endl;}\ntemplate<class T>void chmin(T&a,const T&b){if(a>b)a=b;}\ntemplate<class T>void chmax(T&a,const T&b){if(a<b)a=b;}\n\n\nint nextInt() { int x; scanf(\"%d\", &x); return x;}\nll nextLong() { ll x; scanf(\"%lld\", &x); return x;}\n\nconst int MAX_H = 1410;\nconst int MAX_W = 1410;\nint A[MAX_H][MAX_W];\nint B[MAX_H][MAX_W];\n\nll largestRectangleInHistogram(vector<ll> hist) {\n  hist.push_back(0); // 番兵\n  vector<pair<int,ll>> stack;\n  stack.push_back({-1, 0});\n  ll res = 0;\n  REP(i, hist.size()) {\n    while (stack.back().first != -1 && stack.back().second > hist[i]) {\n      auto b = stack.back();\n      stack.pop_back();\n      auto c = stack.back();\n      chmax(res, (i - c.first - 1) * (b.second));\n    }\n    stack.push_back({i, hist[i]});\n  }\n  return res;\n}\n\nint main2() {\n  int H = nextInt();\n  int W = nextInt();\n  REP(h, H) REP(w, W) A[h][w] = nextInt();\n\n  CLR(B, 0);\n\n  for (int w = 0; w < W; w++) {\n    int L = 0;\n    for (int h = 0; h < H; h++) {\n      if (A[h][w] == 0) {\n        L++;\n      } else {\n        L = 0;\n      }\n      B[h][w] = L;\n    }\n  }\n\n\n  ll ans = 0;\n  REP(h, H) {\n    vector<ll> hist(W);\n    REP(w, W) hist[w] = B[h][w];\n    ll val = largestRectangleInHistogram(hist);\n    chmax(ans, val);\n  }\n  cout << ans << endl;\n  return 0;\n}\n\nint main() {\n\n#ifdef LOCAL\n  for (;!cin.eof();cin>>ws)\n#endif\n    main2();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\n\n//?????£????????????????????????????????????????????????\n//???????????????????????????????????¨?????????\n\nint main(void){\n\tll H,W;\n\tcin>>H>>W;\n\tll c[H][W];//??????????????°???????????¨?????????????????¨?????????\n\tll up[H][W];//?????´???\n\tll left[H][W];//?????´???\n\tll ans=0;\n\tll min,max;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tcin>>c[i][j];\n\t\t\tif(c[i][j]==0){//?¶????????????????\n\t\t\t\tif(i==0){\n\t\t\t\t\tup[0][j]=1;\n\t\t\t\t}else{\n\t\t\t\t\tup[i][j]=up[i-1][j]+1;\n\t\t\t\t}\n\t\t\t\tif(j==0){\n\t\t\t\t\tleft[i][0]=1;\n\t\t\t\t}else{\n\t\t\t\t\tleft[i][j]=left[i][j-1]+1;\n\t\t\t\t}\n\t\t\t}else{//?±?????????????\n\t\t\t\tup[i][j]=0;\n\t\t\t\tleft[i][j]=0;\n\t\t\t}\n\t\t\tmin=LLONG_MAX;\n\t\t\trep(k,up[i][j]){\n\t\t\t\tif(left[i-k][j]<min){\n\t\t\t\t\tmin=left[i-k][j];\n\t\t\t\t}\n\t\t\t\tif(ans<min*(k+1))ans=min*(k+1);\n\t\t\t}\n\t\t\tmin=LLONG_MAX;\n\t\t\trep(k,left[i][j]){\n\t\t\t\tif(up[i][j-k]<min){\n\t\t\t\t\tmin=up[i][j-k];\n\t\t\t\t}\n\t\t\t\tif(ans<min*(k+1))ans=min*(k+1);\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct rect{\n\t  int left, height;\n\t  rect(int l, int h){\n\t\t\tleft = l; height = h;\n\t  }\n};\n\nint solve(vector<int>& hist){\n\t  hist.push_back(0);\n\t  int W = hist.size();\n\t  int ans = 0;\n\t  stack<rect> st;\n\t  for(int i=0; i<W; i++){\n\t\t\tif( st.empty() ){\n\t\t\t\t  st.push( rect(i,hist[i]) );\t  continue;\n\t\t\t}\n\t\t\trect max_h = st.top();\n\t\t\tif( max_h.height < hist[i]){\n\t\t\t\t  st.push( rect(i,hist[i]) );\n\t\t\t}\n\t\t\telse if( max_h.height == hist[i] ){\n\t\t\t\t  continue;\n\t\t\t}\n\t\t\telse if( max_h.height > hist[i] ){\n\t\t\t\t  while( !st.empty() and max_h.height > hist[i] ) {\n\t\t\t\t\t\tans = max(ans, max_h.height * (i-max_h.left) );\n\t\t\t\t\t\tst.pop();\n\t\t\t\t  }\n\t\t\t\t  st.push( rect(max_h.left, hist[i]) ) ;\n\t\t\t}\n\t  }\n\t  return ans ;\n\t\t\t\n}\n\nint main(){\n\t  // input\n\t  int H,W;\n\t  cin >> H >> W;\n\t  vector<vector<int> > m(H+1,vector<int>(W,0));\n\t  for(int i=1; i<=H; i++)\n\t\t\tfor(int j=0; j<W; j++)\n\t\t\t\t  cin >> m[i][j];\n\n\t  // pre proces\n\t  vector<vector<int> > dp(H+1,vector<int>(W,0));\n\t  for(int i=1; i<=H; i++){\n\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\t  if(m[i][j] == 1)\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t  else\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j]+1;\n\t\t\t}\n\t  }\n\t  \n\t  int ans = 0;\n\t  for(int i=1; i<=H; i++)\n\t\t\tans = max(ans, solve(dp[i]));\n\n\n\t  /*\n\t  for(int i=1; i<=H; i++){\n\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\t  cout << dp[i][j] <<\" \";\n\t\t\t}\n\t\t\tcout << \": \" << solve(dp[i]) << endl;\n\t  }\n\t  */\n\t  \n\t  cout << ans << endl;\n\t  \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\nint board[1500][1500];\nint dp[1500][1500];\n\nstruct Rectangle {\n    int height, pos;\n    Rectangle(int a, int b) : height(a), pos(b) {}\n};\n\nsigned main() {\n    int H, W; cin >> H >> W;\n    memset(dp, 0, sizeof(dp));\n    rep(i,0,H) rep(j,0,W) cin >> board[i][j];\n\n    rep(i,0,H) rep(j,0,W) {\n        if(board[i][j] == 1) dp[i][j] = 0;\n        else {\n            if(i == 0) dp[i][j] = 1;\n            else dp[i][j] = dp[i-1][j] + 1;\n        }\n    }\n\n    int ans = 0;\n    rep(i,0,H) {\n        stack<Rectangle> S;\n        repq(j,0,W) {\n            // printf(\"%lld \", dp[i][j]);\n            if(S.empty()) S.push(Rectangle(dp[i][j], j));\n            else {\n                Rectangle TopRect = S.top();\n                if(TopRect.height < dp[i][j]) S.push(Rectangle(dp[i][j], j));\n                else if(TopRect.height > dp[i][j]) {\n                    while(!S.empty() && S.top().height >= dp[i][j]) {\n                        TopRect = S.top(); S.pop();\n                        int temp = (j-TopRect.pos) * TopRect.height;\n                        // printf(\"j = %lld, pos = %lld, height = %lld, temp = %lld\\n\", j, TopRect.pos, TopRect.height, temp);\n                        ans = max(ans, temp);\n                    }\n                    if(S.empty()) S.push(Rectangle(dp[i][j], 0));\n                    else {\n                        TopRect = S.top();\n                        if(TopRect.height != dp[i][j]) S.push(Rectangle(dp[i][j], TopRect.pos+1));\n                    }\n                }\n            }\n        }\n        // cout << endl;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#define rep(i, n) for(int i=0; i<(n); ++i)\n#define FOR(i, m, n) for(int i=(m); i<(n); ++i)\n#define rrep(i, n) for(int i=(n)-1; i>=0; --i)\n#define rfor(i, m, n) for(int i=(m); i>=(n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n\nusing namespace std;\t\tusing LL = long long;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<LL>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<double>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<LL, LL>;\tusing VPL = vector<PLL>;\ntemplate<class T>using pq = priority_queue<T>;\ntemplate<class T>using pqs = priority_queue<T, vector<T>, greater<T>>;\nconst int inf = (int)1e9;\nconst LL inf_ll = (LL)1e18, MOD = 1000000007;\nconst double PI = acos(-1.0), EPS = 1e-12;\n\ntemplate<class T>inline void Sort(T& a)noexcept { sort(all(a)); }\ntemplate<class T>inline void RSort(T& a)noexcept { sort(rall(a)); }\ntemplate<class T>inline void Reverse(T& a)noexcept { reverse(all(a)); }\ntemplate<class T>inline void Unique(T& a)noexcept { a.erase(unique(all(a)), a.end()); }\ntemplate<class T>inline T Sorted(T a)noexcept { Sort(a); return a; }\ntemplate<class T>inline T RSorted(T a)noexcept { RSort(a); return a; }\ntemplate<class T>inline T Reversed(T a)noexcept { Reverse(a); return a; }\ntemplate<class T>inline T Uniqued(T a)noexcept { Unique(a); return a; }\ntemplate<class T>inline auto Max(const T& a)noexcept { return *max_element(all(a)); }\ntemplate<class T>inline auto Min(const T& a)noexcept { return *min_element(all(a)); }\ntemplate<class T>inline int MaxPos(const T& a)noexcept { return max_element(all(a)) - a.begin(); }\ntemplate<class T>inline int MinPos(const T& a)noexcept { return min_element(all(a)) - a.begin(); }\ntemplate<class T, class U>inline int Count(const T& a, const  U& v)noexcept { return count(all(a), v); }\ntemplate<class T, class U>inline int Find(const T& a, const U& v)noexcept { auto pos = find(all(a), v); return pos == a.end() ? -1 : pos - a.begin(); }\ntemplate<class T, class U>inline U Sum(const T& a, const U& v)noexcept { return accumulate(all(a), v); }\ntemplate<class T, class U>inline int Lower(const T& a, const U& v)noexcept { return lower_bound(all(a), v) - a.begin(); }\ntemplate<class T, class U>inline int Upper(const T& a, const U& v)noexcept { return upper_bound(all(a), v) - a.begin(); }\ntemplate<class T, class P>inline void RemoveIf(T& a, P f)noexcept { a.erase(remove_if(all(a), f), a.end()); }\ntemplate<class T>inline T Age(T n, T m)noexcept { return (n + m - 1) / m; }\ntemplate<class T>inline T Age2(T n, T m)noexcept { return Age(n, m) * m; }\ntemplate<class T>inline T Tri(T n)noexcept { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\ntemplate<class T = long long>inline T BIT(int b)noexcept { return T{ 1 } << b; }\ntemplate<class T>inline T Gcd(T n, T m)noexcept { return m ? Gcd(m, n % m) : n; }\ntemplate<class T>inline T Lcm(T n, T m)noexcept { return n / Gcd(n, m) * m; }\ntemplate<class T>inline T Pow(T a, T n)noexcept { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; }return r; }\ntemplate<class T>inline T Powmod(T a, T n, T m = MOD)noexcept { T r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r; }\ntemplate<class T>inline bool chmax(T& a, const T& b)noexcept { if (a < b) { a = b; return true; } return false; }\ntemplate<class T>inline bool chmin(T& a, const T& b)noexcept { if (a > b) { a = b; return true; } return false; }\ninline string operator*(string s, int n)noexcept { string ret; rep(i, n)ret += s; return ret; }\n\n// --- input --- //\n#if defined(_MSC_VER) || defined(ONLINE_JUDGE)\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#endif\ninline int gc()noexcept { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v)noexcept { cin >> v; }\ninline void InputF(char& v)noexcept { while (isspace(v = gc())); }\ninline void InputF(string& v)noexcept {\n\tchar c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v)noexcept {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v)noexcept {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v)noexcept {\n\tInputF(v.first); InputF(v.second);\n}\ntemplate<class T>inline void InputF(vector<T>& v)noexcept {\n\tfor (auto& e : v)InputF(e);\n}\nstruct InputV {\n\tint n, m;\n\tInputV(int N) :n(N), m(0) {}\n\tInputV(pair<int, int> N) :n(N.first), m(N.second) {}\n\ttemplate<class T>operator vector<T>()noexcept {\n\t\tvector<T> v(n); InputF(v); return v;\n\t}\n\ttemplate<class T>operator vector<vector<T>>()noexcept {\n\t\tvector<vector<T>> v(n, vector<T>(m)); InputF(v); return v;\n\t}\n};\nstruct Input {\n\ttemplate<class T>operator T()noexcept { T v; InputF(v); return v; }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n)noexcept { return InputV(n); }\n\tInputV operator[](pair<int, int> n)noexcept { return InputV(n); }\n\ttemplate<class T, size_t W>array<vector<T>, W> get(int H) {\n\t\tarray<vector<T>, W> ret;\n\t\trep(i, H)rep(j, W) { T x = *this; ret[j].push_back(x); }\n\t\treturn ret;\n\t}\n}in;\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc }; bool isPrint = true;\n\tvoid p(double v) { printf(\"%.20f\", v); } void p(long double v) { printf(\"%.20Lf\", v); }\n\tvoid p(int v) { printf(\"%d\", v); }\tvoid p(LL v) { printf(\"%lld\", v); }\n\tvoid p(char v) { putchar(v); }\t\tvoid p(bool v) { printf(\"%s\", v ? B.t : B.f); }\n\ttemplate<class T>void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); printf(\"%s\", D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)printf(\"%s\", D.l); p(v[i]); } }\n\tvoid p(const BoolStr& v) { B = v; isPrint = false; } void p(const DivStr& v) { D = v; isPrint = false; }\npublic:\n\tvoid operator()() { printf(\"%s\", D.l); }\n\ttemplate<class H>void operator()(H&& h) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.l); isPrint = true; B = Yes; D = spc;\n\t}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) {\n\t\tp(h); if (isPrint)printf(\"%s\", D.d); isPrint = true; operator()(forward<T>(t)...);\n\t}\n\ttemplate<class...T>void exit(T&& ...t) {\n\t\toperator()(forward<T>(t)...); std::exit(EXIT_SUCCESS);\n\t}\n}out;\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) (void(0))\n#endif\n\n// ---------------------------------------------------------------- //\n\nint main() {\n\tint H = in, W = in;\n\tVVI a = in[{H, W}];\n\n\tVI h(W);\n\tint ans = 0;\n\trep(i, H) {\n\t\trep(j, W) {\n\t\t\tif (a[i][j])h[j] = 0;\n\t\t\telse h[j]++;\n\t\t}\n\n\t\tstack<int> s;\n\t\tVI L(W), R(W);\n\t\trep(i, W) {\n\t\t\twhile (sz(s) && h[s.top()] >= h[i])s.pop();\n\t\t\tL[i] = s.empty() ? 0 : s.top() + 1;\n\t\t\ts.push(i);\n\t\t}\n\t\twhile (!s.empty())s.pop();\n\t\trrep(i, W) {\n\t\t\twhile (!s.empty() && h[s.top()] >= h[i])s.pop();\n\t\t\tR[i] = s.empty() ? W : s.top();\n\t\t\ts.push(i);\n\t\t}\n\t\trep(i, W)chmax(ans, h[i] * (R[i] - L[i]));\n\t}\n\tout(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<iomanip>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\n#include<map>\n#include<set>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef stack<int> SI;\ntypedef queue<int> QI;\ntypedef list<int> LI;\ntypedef pair<int,int> PII;\ntypedef long long LL;\n\n#define d(x)  cout<<#x<<\" = \"<<(x)<<endl;\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define EMP empty()\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define REACH(i,c) for(typeof((c).rbegin()) i=(c).rbegin(); i!=(c).rend(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c,n) sort(c,c+n)\n#define VSORT(c) sort((c).begin(),(c).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define DFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define DREP(i,n) DFOR(i,n,0)\n#define INF 1000000000\n#define PI  acos(-1.0)\n////////////////////////////////////////////////\nstruct Rect{int h;int p;};\nint lgstrec(int size,int buffer[])\n{\n\tstack<Rect> S;\n\tint maxv=0;\n\tbuffer[size]=0;\n\tfor(int i=0;i<=size;i++)\n\t{\n\t\tRect rect;\n\t\trect.h=buffer[i];\n\t\trect.p=i;\n\t\tif(S.empty())\n\t\t{\n\t\t\tS.push(rect);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(S.top().h<rect.h)\n\t\t\t{\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t\telse if(S.top().h>rect.h)\n\t\t\t{\n\t\t\t\tint tgt=i;\n\t\t\t\twhile(!S.empty()&&S.top().h>=rect.h)\n\t\t\t\t{\n\t\t\t\t\tRect pre=S.top();S.pop();\n\t\t\t\t\tint area=pre.h*(i-pre.p);\n\t\t\t\t\tmaxv=max(maxv,area);\n\t\t\t\t\ttgt=pre.p;\n\t\t\t\t}\n\t\t\t\trect.p=tgt;\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxv;\n}\nint H,W;\nint buffer[1400][1400];\nint T[1400][1400];\nint lgstrec()\n{\n\tREP(j,W)\n\t{\n\t\tREP(i,H)\n\t\t{\n\t\t\tif(buffer[i][j])\n\t\t\t{\n\t\t\t\tT[i][j]=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tT[i][j]=(i>0)?T[i-1][j]+1:1;\n\t\t\t}\n\t\t}\n\t}\n\tint maxv=0;\n\tREP(i,H)\n\t{\n\t\tmaxv=max(maxv,lgstrec(Wa,T[i]));\n\t}\n\treturn maxv;\n}\nint main()\n{\n\tscanf(\"%d%d\",&H,&W);\n\tREP(i,H)\n\t{\n\t\tREP(j,W)\n\t\t{\n\t\t\tscanf(\"%d\",&buffer[i][j]);\n\t\t}\n\t}\n\tcout<<lgstrec()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nsize_t get_largest_rectangle(vector<vector<int>> &g) {\n    size_t h=g.size(), w=g[0].size();\n\n    vector<vector<size_t>> dp(h, vector<size_t>(w+1));\n    size_t max_area=0;\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j) {\n            dp[i][j] = !g[i][j];\n            max_area |= dp[i][j];\n        }\n\n    for (size_t i=1; i<h; ++i)\n        for (size_t j=0; j<w; ++j)\n            if (dp[i][j])\n                dp[i][j] += dp[i-1][j];\n\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j) {\n            if (!dp[i][j]) continue;\n\n            size_t min_height=dp[i][j];\n            for (size_t k=j+1; k<=w; ++k) {\n                if (!dp[i][k]) {\n                    max_area = max(max_area, (k-j)*min_height);\n                    break;\n                }\n\n                min_height = min(min_height, dp[i][k]);\n            }\n        }\n\n    return max_area;\n}\n\nint main() {\n    size_t h, w;\n    scanf(\"%zu %zu\", &h, &w);\n\n    vector<vector<int>> g(h, vector<int>(w));\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j)\n            scanf(\"%d\", &g[i][j]);\n\n    printf(\"%zu\\n\", get_largest_rectangle(g));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstruct Rectangle{\n    int height;\n    int pos;\n};\n\nint getLargestRectangle(int size, int Hist[]){\n    stack<Rectangle> S;\n    int maxv=0;\n    Hist[size]=0;\n\n    for(int i=0; i<=size; i++){\n        Rectangle rect;\n        rect.height=Hist[i];\n        rect.pos=i;\n\n        if(S.empty()){\n            S.push(rect);\n        }\n        else if(rect.height>S.top().height){\n            S.push(rect);\n        }\n        else if(rect.height<S.top().height){\n            int target=0; //changed later\n            while(!S.empty() && rect.height<=S.top().height){\n                Rectangle topRect=S.top(); S.pop();\n                int area=topRect.height*(i-topRect.pos);\n                maxv=max(maxv, area);\n                target=topRect.pos;\n            }\n            rect.pos=target;\n            S.push(rect);\n        }\n    }\n\n    return maxv;\n}\n\nint H,W;\nint Hist[1401][1401];\n\nint solve(){\n    int maxv=0;\n    for(int i=0; i<H; i++){\n        maxv=max(maxv, getLargestRectangle(W, Hist[i]));\n    }\n\n    return maxv;\n}\n\nint main(void){\n    cin >> H >> W;\n    int G[H][W];\n    for(int i=0; i<H; i++){\n        for(int j=0; j<W; j++){\n            cin >> G[i][j];\n        }\n    }\n\n    //ヒストグラムを作る\n    for(int j=0; j<W; j++){\n        for(int i=0; i<H; i++){\n            if(G[i][j]==1) Hist[i][j]=0;\n            else Hist[i][j]= (i>0)? Hist[i-1][j]+1 : 1;\n        }\n    }\n\n    cout << solve() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <sstream>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n#define rrep(i, a) RREP(i, a, 0)\n#define RREP(i, a, b) for(int i = a; i >= b; --i)\n#define repll(i, a) REPLL(i, 0, a)\n#define REPLL(i, a, b) for(ll i = a; i < b; ++i)\n#define rrepll(i, a) RREPLL(i, a, 0)\n#define RREPLL(i, a, b) for(ll i = a; i >= b; --i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<int, P> PP;\nconst double PI = 3.14159265358979323846;\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+18 + 10;\n\nint h, w, ans = 0;\nint map[1401][1401];\n\nint main(){\n\tstd::cin >> h >> w;\n\trep(i, h){\n\t\trep(j, w)std::cin >> map[i][j], map[i][j] = (1 - map[i][j]);\n\t}\n\n\trep(i, w){\n\t\tREP(j, 1, h)map[j][i] = (map[j][i] == 0 ? 0 : map[j - 1][i] + 1);\n\t}\n\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tstd::cout << map[i][j] << \" \";\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n\n\trep(i, h){\n\t\tint max = 0;\n\t\tstd::stack<P> s;\n\t\trep(j, w){\n\t\t\tif (s.empty() || s.top().first < map[i][j]){\n\t\t\t\ts.push(P(map[i][j], j));\n\t\t\t}\n\t\t\twhile (s.size() && s.top().first > map[i][j]){\n\t\t\t\tmax = std::max(max, s.top().first * (j - s.top().second));\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t\twhile (!s.empty()){\n\t\t\tmax = std::max(max, s.top().first * (w - s.top().second));\n\t\t\ts.pop();\n\t\t}\n\n\t\tans = std::max(max, ans);\n\t}\n\n\tstd::cout << ans << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\n\nint main(void){\n\tll H,W;\n\tcin>>H>>W;\n\tll c[1400][1400];//H,W\n\tll up[1400][1400];//?????´???\n\tll left[1400][1400];//?????´???\n\tll ans=0;\n\tll min;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tcin>>c[i][j];\n\t\t\tif(c[i][j]==0){\n\t\t\t\tif(i==0){\n\t\t\t\t\tup[0][j]=1;\n\t\t\t\t}else{\n\t\t\t\t\tup[i][j]=up[i-1][j]+1;\n\t\t\t\t}\n\t\t\t\tif(j==0){\n\t\t\t\t\tleft[i][0]=1;\n\t\t\t\t}else{\n\t\t\t\t\tleft[i][j]=left[i][j-1]+1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tup[i][j]=0;\n\t\t\t\tleft[i][j]=0;\n\t\t\t}\n\t\t\tmin=LLONG_MAX;\n\t\t\trep(k,up[i][j]){\n\t\t\t\tif(left[i-k][j]<min){\n\t\t\t\t\tmin=left[i-k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans<min*up[i][j])ans=min*up[i][j];\n\t\t\tmin=LLONG_MAX;\n\t\t\trep(k,left[i][j]){\n\t\t\t\tif(up[i][j-k]<min){\n\t\t\t\t\tmin=up[i][j-k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans<min*left[i][j])ans=min*left[i][j];\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n\n#define MAX 1400\n\nstruct Rectangle\n{\n  int height;\n  int pos;\n};\n\nint getLargestRectangle(int size, int buffer[])\n{\n  stack<Rectangle> S;\n  int maxv = 0;\n  buffer[size] = 0;\n\n  for (int i = 0; i <= size; i++)\n  {\n    Rectangle rect;\n    rect.height = buffer[i];\n    rect.pos = i;\n    if (S.empty())\n    {\n      S.push(rect);\n    }\n    else\n    {\n      if (S.top().height < rect.height)\n      {\n        S.push(rect);\n      }\n      else if (S.top().height > rect.height)\n      {\n        int target = i;\n        while (!S.empty() && S.top().height >= rect.height)\n        {\n          Rectangle pre = S.top();\n          S.pop();\n          int area = pre.height * (i - pre.pos);\n          maxv = max(maxv, area);\n          target = pre.pos;\n        }\n        rect.pos = target;\n        S.push(rect);\n      }\n    }\n  }\n  return maxv;\n}\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle()\n{\n  for (int j = 0; j < W; j++)\n  {\n    for (int i = 0; i < H; i++)\n    {\n      if (buffer[i][j])\n      {\n        // 汚れタイル\n        T[i][j] = 0;\n      }\n      else\n      {\n        // 上から1,2,3と増える\n        T[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n      }\n    }\n  }\n\n  int maxv = 0;\n  for (int i = 0; i < H; i++)\n  {\n    maxv = max(maxv, getLargestRectangle(W, T[i]));\n  }\n\n  return maxv;\n}\n\nint main()\n{\n  scanf(\"%d %d\", &H, &W);\n  for (int i = 0; i < H; i++)\n  {\n    for (int j = 0; j < W; j++)\n    {\n      scanf(\"%d\", &buffer[i][j]);\n    }\n  }\n\n  cout << getLargestRectangle() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/***********\n* Coded by *\n*   ACS    *\n***********/\n\n// p: Problem F. Largest Rectangle\n// j: VJUDGE\n// c: Contest1 Div 1\n\n#include <bits/stdc++.h>\n\n#define cic(in,n) for(int i=in;i<n;i++)\n#define rep(i,a,n) for(int i=a;i<n;i++)\n#define All(a) a.begin(),a.end()\n#define PB push_back\n#define FIND(m,v) (m.find(v) != m.end())\n#define print(n) cout<<n<<\"\\n\"\n#define CLR(m) memset(m, 0, sizeof(m))\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\nconst int MAX = 2e3 + 100, mod = 1e9 + 7, oo = INT_MAX;\n\nint m, n, Mx[MAX][MAX], Upx[MAX][MAX];\n\nint Lw[MAX], stk[MAX];\nint BestRectangleByLine(int H[MAX])\n{\n    rep(i,0,n) Lw[i] = 1;  // Clean Memory\n    for(int i = 0, pl = 0; i < n; stk[pl++] = i++)  // Find prev[i];\n    {\n        for(; pl > 0 && H[i] <= H[stk[pl-1]] ; pl--); // prev[i] = stk[pl]\n        if(pl == 0) Lw[i] += i;\n        else        Lw[i] += i - stk[pl-1] - 1;\n    }\n    for(int i = n-1, pl = 0; i >= 0; stk[pl++] = i--) // Find next[i];\n    {\n        for(; pl > 0 && H[i] <= H[stk[pl-1]] ; pl--);    // next[i] = stk[pl]\n        if(pl == 0) Lw[i] += n - 1 - i;\n        else        Lw[i] += stk[pl-1] - i - 1;\n    }\n    int solve = 0;\n    rep(i,0,n) solve = max(solve, Lw[i]*H[i]);\n    return solve;\n}\n\nint BestRectangle()\n{\n    rep(i,0,n) Upx[0][i] = ((Mx[0][i] == 0)?1:0);\n    int solve = BestRectangleByLine(Upx[0]);\n    rep(i,1,m)\n    {\n        rep(j,0,n)\n            if(!Mx[i][j]) Upx[i][j] += Upx[i-1][j] + 1;\n            else Upx[i][j] = 0;\n        solve = max(solve, BestRectangleByLine(Upx[i]));\n    }\n    return solve;\n}\n\n\nint main()\n{\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    cin >> m >> n;\n    rep(i,0,m) rep(j,0,n) cin >> Mx[i][j];\n    print(BestRectangle());\n    return 0;\n}\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "/**\n * @copyright (c) 2020 Daisuke Hashimoto\n */\n\n#include <cstdint>\n#include <iostream>\n#include <stack>\n\nconstexpr int32_t kMaxHeight = 1400;\nconstexpr int32_t kMaxWidth = 1400;\n\nvoid CallLargestRectangle(std::istream &input_stream);\n\nstruct ExtendableRectangle {\n  int32_t height{-1};\n  int32_t column_of_left{-1};\n};\n\nclass LargestRectangle {\n public:\n  LargestRectangle() noexcept;\n  ~LargestRectangle() noexcept;\n  void SetSize(const int32_t height, const int32_t width);\n  void SetTile(const int32_t row, const int32_t column, const int32_t value);\n  int32_t FindLargestRectangleArea();\n\n private:\n  int32_t FindLargestRectangleAreaPerRow(const int32_t row) const;\n\n  LargestRectangle(const LargestRectangle &obj) = delete;\n  LargestRectangle &operator=(const LargestRectangle &obj) = delete;\n  LargestRectangle(LargestRectangle &&obj) = delete;\n  LargestRectangle &operator=(LargestRectangle &&obj) = delete;\n\n private:\n  int32_t height_;\n  int32_t width_;\n  int32_t length_to_upper_[kMaxHeight][kMaxWidth];\n};\n\nvoid CallLargestRectangle(std::istream &input_stream) {\n  input_stream.tie(0);\n  std::ios::sync_with_stdio(false);\n  LargestRectangle *largest_rectangle = new LargestRectangle();\n  try {\n    int32_t height, width;\n    input_stream >> height >> width;\n    largest_rectangle->SetSize(height, width);\n    for (int32_t row = 0; row < height; ++row) {\n      for (int32_t column = 0; column < width; ++column) {\n        int32_t value;\n        input_stream >> value;\n        largest_rectangle->SetTile(row, column, value);\n      }\n    }\n    std::cout << largest_rectangle->FindLargestRectangleArea() << std::endl;\n  } catch (...) {\n    std::cerr << \"ERROR: CallLargestRectangle()\" << std::endl;\n    delete largest_rectangle;\n    throw;\n  }\n  delete largest_rectangle;\n}\n\n// ****************************************************\nLargestRectangle::LargestRectangle() noexcept : height_(0), width_(0) {}\n\nLargestRectangle::~LargestRectangle() noexcept {}\n\nvoid LargestRectangle::SetSize(const int32_t height, const int32_t width) {\n  if (height > kMaxHeight) {\n    std::cerr << \"ERROR: SetSize(): height exceeded a limit = \" << kMaxHeight << std::endl;\n  } else if (width > kMaxWidth) {\n    std::cerr << \"ERROR: SetSize(): width exceeded a limit = \" << kMaxWidth << std::endl;\n  } else {\n    height_ = height;\n    width_ = width;\n  }\n}\n\nvoid LargestRectangle::SetTile(const int32_t row, const int32_t column, const int32_t value) {\n  if (row >= height_) {\n    std::cerr << \"ERROR: SetSize(): Invalid arg: row = \" << row << std::endl;\n  } else if (column >= width_) {\n    std::cerr << \"ERROR: SetSize(): Invalid arg: column = \" << column << std::endl;\n  } else {\n    const bool is_dirty = (value == 1);\n    if (is_dirty) {\n      length_to_upper_[row][column] = 0;\n    } else if (row == 0) {\n      length_to_upper_[row][column] = 1;\n    } else {\n      length_to_upper_[row][column] = 1 + length_to_upper_[row - 1][column];\n    }\n  }\n}\n\nint32_t LargestRectangle::FindLargestRectangleArea() {\n  int32_t largest_rectangle_area = 0;\n  try {\n    for (int32_t row = 0; row < height_; ++row) {\n      const int32_t area = FindLargestRectangleAreaPerRow(row);\n      if (area > largest_rectangle_area) {\n        largest_rectangle_area = area;\n      }\n    }\n  } catch (...) {\n    std::cerr << \"ERROR: FindLargestRectangleArea()\" << std::endl;\n    throw;\n  }\n  return largest_rectangle_area;\n}\n\nint32_t LargestRectangle::FindLargestRectangleAreaPerRow(const int32_t row) const {\n  int32_t largest_rectangle_area = 0;\n  try {\n    std::stack<ExtendableRectangle> stack;\n    for (int32_t column = 0; column < width_; ++column) {\n      ExtendableRectangle rect;\n      rect.height = length_to_upper_[row][column];\n      rect.column_of_left = column;\n      if (stack.empty()) {\n        stack.push(rect);\n      } else {\n        const ExtendableRectangle top = stack.top();\n        if (top.height < rect.height) {\n          stack.push(rect);\n        } else if (top.height == rect.height) {\n          // DO NOTHING\n        } else {\n          while (!stack.empty()) {\n            const ExtendableRectangle top = stack.top();\n            if (top.height < rect.height) {\n              break;\n            }\n            stack.pop();\n            const int32_t width = column - top.column_of_left;\n            const int32_t area = width * top.height;\n            if (area > largest_rectangle_area) {\n              largest_rectangle_area = area;\n            }\n            rect.column_of_left = top.column_of_left;\n          }\n          stack.push(rect);\n        }\n      }\n    }\n    while (!stack.empty()) {\n      const ExtendableRectangle top = stack.top();\n      stack.pop();\n      const int32_t width = width_ - top.column_of_left;\n      const int32_t area = width * top.height;\n      if (area > largest_rectangle_area) {\n        largest_rectangle_area = area;\n      }\n    }\n  } catch (...) {\n    std::cerr << \"ERROR: FindLargestRectangleAreaPerRow()\" << std::endl;\n    throw;\n  }\n  return largest_rectangle_area;\n}\n\nint main() {\n  try {\n    CallLargestRectangle(std::cin);\n  } catch (...) {\n    std::cerr << \"ERROR: main()\" << std::endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<cstdlib>\n#include<cstring>\n#include<climits>\n#include<iomanip>\n#include<complex>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<list>\n#include<map>\n#include<set>\nusing namespace std;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef stack<int> SI;\ntypedef queue<int> QI;\ntypedef list<int> LI;\ntypedef pair<int,int> PII;\ntypedef long long LL;\n\n#define d(x)  cout<<#x<<\" = \"<<(x)<<endl;\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define EMP empty()\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define REACH(i,c) for(typeof((c).rbegin()) i=(c).rbegin(); i!=(c).rend(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c,n) sort(c,c+n)\n#define VSORT(c) sort((c).begin(),(c).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define DFOR(i,b,a) for(int i=(b)-1;i>=(a);--i)\n#define DREP(i,n) DFOR(i,n,0)\n#define INF 1000000000\n#define PI  acos(-1.0)\n////////////////////////////////////////////////\nstruct Rect{int h;int p;};\nint lgstrec(int size,int buffer[])\n{\n\tstack<Rect> S;\n\tint maxv=0;\n\tbuffer[size]=0;\n\tfor(int i=0;i<=size;i++)\n\t{\n\t\tRect rect;\n\t\trect.h=buffer[i];\n\t\trect.p=i;\n\t\tif(S.empty())\n\t\t{\n\t\t\tS.push(rect);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(S.top().h<rect.h)\n\t\t\t{\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t\telse if(S.top().h>rect.h)\n\t\t\t{\n\t\t\t\tint tgt=i;\n\t\t\t\twhile(!S.empty()&&S.top().h>=rect.h)\n\t\t\t\t{\n\t\t\t\t\tRect pre=S.top();S.pop();\n\t\t\t\t\tint area=pre.h*(i-pre.p);\n\t\t\t\t\tmaxv=max(maxv,area);\n\t\t\t\t\ttgt=pre.p;\n\t\t\t\t}\n\t\t\t\trect.p=tgt;\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxv;\n}\nint H,W;\nint buffer[1400][1400];\nint T[1400][1400];\nint lgstrec()\n{\n\tREP(j,W)\n\t{\n\t\tREP(i,H)\n\t\t{\n\t\t\tif(buffer[i][j])\n\t\t\t{\n\t\t\t\tT[i][j]=0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tT[i][j]=(i>0)?T[i-1][j]+1:1;\n\t\t\t}\n\t\t}\n\t}\n\tint maxv=0;\n\tREP(i,H)\n\t{\n\t\tmaxv=max(maxv,lgstrec(maxv,T[i]));\n\t}\n\treturn maxv;\n}\nint main()\n{\n\tscanf(\"%d%d\",&H,&W);\n\tREP(i,H)\n\t{\n\t\tREP(j,W)\n\t\t{\n\t\t\tscanf(\"%d\",&buffer[i][j]);\n\t\t}\n\t}\n\tcout<<lgstrec()<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<iomanip>\n#include<cmath>\n#include<vector>\n#include<deque>\n#include<queue>\n#include<map>\n#include<set>\n#define ll long long\n#define str string\n#define ld long double\n#define vec vector\n#define vll vec<ll>\n#define rep(i,a,b) for(ll i=a;i<b;i++)\n#define rrep(i,b,a) for(ll i=b;i>=a;i--)\n#define ALL(a) a.begin(),a.end()\n#define rALL(a) a.rbegin(),a.rend()\n#define kai \"\\n\"\n#define yuque priority_queue\n#define pub push_back\n#define pob pop_back\n#define puf push_front\n#define pof pop_front\n#define mie min_element\n#define mae max_element\n#define tos to_string\n#define sep setprecision\n#define lob lower_bound\n#define upb upper_bound\n#define nep next_permutation\n#define MOD 1000000007ll\n#define MIN (1e-10)\n#define equal(a,b) (abs((a)-(b))<MIN)\n#define v2 ten\n#define chokusen senbun\n#define tenten senbun\n#define takaku vec<ten>\nusing namespace std;\nvoid solve();\n\nstruct pea {\n\tll f, s;\n\tbool operator<(const pea &p)const {\n\t\treturn f != p.f ? f < p.f : s < p.s;\n\t};\n};\nstruct tri {\n\tll f, s, t;\n\tbool operator<(const tri &p)const {\n\t\tif (f != p.f)return f < p.f;\n\t\tif (s != p.s)return s < p.s;\n\t\treturn t < p.t;\n\t};\n};\nclass ten {\npublic:\n\tld x, y;\n\n\tten operator+(ten p) { return { x + p.x,y + p.y }; }\n\tten operator-(ten p) { return { x - p.x,y - p.y }; }\n\tten operator*(ld k) { return { k*x,k*y }; }\n\tten operator/(ld k) { return { x / k,y / k }; }\n\n\tld abs() { return sqrt(abs2()); }\n\tld abs2() { return x * x + y * y; };\n\n\tbool operator<(const ten &p)const { return x != p.x ? x < p.x : y < p.y; };\n\tbool operator==(const ten &p)const {\n\t\treturn (-MIN < x - p.x) && (x - p.x < MIN) && (-MIN < y - p.y) && (y - p.y < MIN);\n\t};\n\n\tld naiseki(v2 b) { return x*b.x + y*b.y; }\n\tld gaiseki(v2 b) { return x*b.y - y*b.x; }\n};\nstruct senbun { ten p1, p2; };\nstruct en { ten o; ld r; };\n\n//互いに素な集合\nclass ufset {\npublic:\n\tvll rank, p;\n\tufset(ll n) {\n\t\trank.resize(n, 0);\n\t\tp.resize(n, 0);\n\t\trep(i, 0, n)make(i);\n\t}\n\tvoid reset(ll n) {\n\t\trank.resize(n, 0);\n\t\tp.resize(n, 0);\n\t\trep(i, 0, n)make(i);\n\t}\n\tvoid make(ll i) {\n\t\tp[i] = i;\n\t\trank[i] = 0;\n\t}\n\tbool same(ll i, ll j) { return find(i) == find(j); }\n\tvoid unite(ll i, ll j) { link(find(i), find(j)); }\n\tvoid link(ll i, ll j) {\n\t\tif (rank[i] > rank[j])p[j] = i;\n\t\telse {\n\t\t\tp[i] = j;\n\t\t\tif (rank[i] == rank[j])rank[j]++;\n\t\t}\n\t}\n\tll find(ll i) {\n\t\tif (p[i] != i)p[i] = find(p[i]);\n\t\treturn p[i];\n\t}\n};\n\n//nCk(mod p)\nclass nck {\npublic:\n\tll NUM, p;\n\tvll fac, finv, inv;\n\tnck(ll maxn, ll mod = MOD) {\n\t\tNUM = maxn + 1;\n\t\tp = mod;\n\t\tfac.resize(NUM);\n\t\tfinv.resize(NUM);\n\t\tinv.resize(NUM);\n\t\tfac[0] = fac[1] = 1;\n\t\tfinv[0] = finv[1] = 1;\n\t\tinv[1] = 1;\n\t\trep(i, 2, NUM) {\n\t\t\tfac[i] = fac[i - 1] * i%p;\n\t\t\tinv[i] = p - inv[p%i] * (p / i) % p;\n\t\t\tfinv[i] = finv[i - 1] * inv[i] % p;\n\t\t}\n\t}\n\tll c(ll n, ll k) { return fac[n] * (finv[k] * finv[n - k] % p) % p; }\n};\n\n//最大公約数\nll gcd(ll n, ll m) {\n\tll k = n % m;\n\twhile (k != 0) { n = m; m = k; k = n % m; }\n\treturn m;\n}\nll gcd(vector<ll> a) {\n\trep(i, 1, a.size()) {\n\t\tll k = a[i - 1] % a[i];\n\t\twhile (k != 0) {\n\t\t\ta[i - 1] = a[i];\n\t\t\ta[i] = k;\n\t\t\tk = a[i - 1] % a[i];\n\t\t}\n\t}\n\treturn a.back();\n}\n\n//最小公倍数\nll lcm(ll n, ll m) {\n\tll t = n * m, k = n % m;\n\twhile (k != 0) { n = m; m = k; k = n % m; }\n\treturn t / m;\n}\nll lcm(vector<ll> a) {\n\tll n;\n\trep(i, 1, a.size()) {\n\t\tn = a[i - 1] * a[i];\n\t\tll k = a[i - 1] % a[i];\n\t\twhile (k != 0) {\n\t\t\ta[i - 1] = a[i];\n\t\t\ta[i] = k;\n\t\t\tk = a[i - 1] % a[i];\n\t\t}\n\t\tn /= a[i];\n\t\ta[i] = n;\n\t}\n\treturn n;\n}\n\n//a^b(mod p)\nll pow2(ll a, ll b, ll p = MOD) {\n\tif (b == -1)return pow2(a, p - 2);\n\tll res = 1;\n\tif (b > 0) {\n\t\tres = pow2(a, b / 2);\n\t\tif (b % 2 == 0)res = res * res%p;\n\t\telse res = res * res%p*a%p;\n\t}\n\treturn res;\n}\n\n//トポロジカルソート\nvoid tsort(const vec<vll> &c, vll &a) {\n\tll n = c.size();\n\tvll p(n, 0);\n\trep(i, 0, n)rep(j, 0, c[i].size())p[c[i][j]]++;\n\trep(i, 0, n)if (p[i] == 0) {\n\t\tdeque<ll> d; d.pub(i);\n\t\twhile (!d.empty()) {\n\t\t\tll j = d.front(); d.pof();\n\t\t\ta.pub(j);\n\t\t\trep(k, 0, c[j].size()) {\n\t\t\t\tll l = c[j][k];\n\t\t\t\tp[l]--;\n\t\t\t\tif (p[l] == 0) {\n\t\t\t\t\tp[l] = -1;\n\t\t\t\t\td.pub(l);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n//深さ優先探索\nvec<bool> seen;\nvoid dfs(const vec<vll> &c, ll i = 0) {\n\tseen[i] = true;\n\trep(j, 0, c[i].size()) {\n\t\tif (!seen[c[i][j]])dfs(c, c[i][j]);\n\t}\n}\n\n//最小全域木\nll kruskal(ll v, vec<tri> &e) {\n\tll sum = 0;\n\tsort(ALL(e));\n\tufset s(v);\n\trep(i, 0, e.size()) {\n\t\tif (!s.same(e[i].s, e[i].t)) {\n\t\t\ts.unite(e[i].s, e[i].t);\n\t\t\tsum += e[i].f;\n\t\t}\n\t}\n\treturn sum;\n}\n\n//単一始点最短経路\nvoid dijkstra(const vec<vec<pea>> &c, ll v, vll &d) {\n\td[v] = 0;\n\tll n = c.size();\n\tll count = 1;\n\tvec<bool> seen(n, false);\n\tseen[v] = true;\n\tyuque<pea> hen;\n\trep(i, 0, c[v].size())hen.push({ -c[v][i].f,c[v][i].s });\n\twhile (count != n) {\n\t\tif (hen.empty())break;\n\t\tpea k = hen.top(); hen.pop();\n\t\twhile (seen[k.s]) {\n\t\t\tif (hen.empty()) {\n\t\t\t\tcount = -1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tk = hen.top();\n\t\t\then.pop();\n\t\t}\n\t\tif (count == -1)break;\n\t\td[k.s] = -k.f;\n\t\tcount++;\n\t\tseen[k.s] = true;\n\t\trep(i, 0, c[k.s].size())hen.push({ k.f - c[k.s][i].f,c[k.s][i].s });\n\t}\n}\n\n//全点対間最短経路\nbool floyd(vec<vll> &d) {\n\tll n = d.size();\n\trep(i, 0, n)d[i][i] = 0;\n\trep(k, 0, n) {\n\t\trep(i, 0, n) {\n\t\t\tif (d[i][k] != MOD) {\n\t\t\t\trep(j, 0, n) {\n\t\t\t\t\tif (d[k][j] != MOD) {\n\t\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool b = true;\n\trep(i, 0, n)if (d[i][i] < 0)b = false;\n\treturn b;\n}\n\n//計算幾何学\nv2 beku(ld r,ld t){\n\treturn { r*cos(t),r*sin(t) };\n}\nld kakudo(v2 a) {\n\treturn atan2(a.y, a.x);\n}\nten shaei(ten p, chokusen l) {\n\tv2 a = l.p2 - l.p1;\n\treturn l.p1 + a * a.naiseki(p - l.p1) / a.abs2();\n}\nten hansha(ten p, chokusen l) {\n\treturn shaei(p, l) * 2 - p;\n}\nld tenchoku(ten p, chokusen l) {\n\tv2 a = l.p2 - l.p1;\n\treturn abs(a.gaiseki(p - l.p1)) / a.abs();\n}\nld tensen(ten p, senbun s) {\n\tif ((p - s.p1).naiseki(s.p2 - s.p1) < 0)return (p - s.p1).abs();\n\tif ((p - s.p2).naiseki(s.p1 - s.p2) < 0)return (p - s.p2).abs();\n\treturn tenchoku(p, s);\n}\nll ccw(ten p0, ten p1, ten p2) {\n\tv2 a = p1 - p0, b = p2 - p0;\n\tif (a.gaiseki(b) > MIN)return -1;//012反時計回り\n\tif (a.gaiseki(b) < -MIN)return 1;//012時計回り\n\tif (a.naiseki(b) < -MIN)return -2;//102\n\tif (a.abs2() < b.abs2())return 2;//012\n\treturn 0;//021\n}\nbool majiwaru(senbun s, senbun t) { \n\treturn ccw(s.p1, s.p2, t.p1)*ccw(s.p1, s.p2, t.p2) <= 0 \n\t\t&& ccw(t.p1, t.p2, s.p1)*ccw(t.p1, t.p2, s.p2) <= 0; \n}\nld sensen(senbun s, senbun t) {\n\tif (majiwaru(s, t))return 0;\n\treturn min({ tensen(s.p1,t),tensen(s.p2,t),tensen(t.p1,s),tensen(t.p2,s) });\n}\nten koten(senbun s, senbun t) {\n\tv2 a = t.p2 - t.p1;\n\tld d1 = abs(a.gaiseki(s.p1 - t.p1));\n\tld d2 = abs(a.gaiseki(s.p2 - t.p1));\n\treturn s.p1 + (s.p2 - s.p1)*d1 / (d1 + d2);\n}\ntenten koten(en c, chokusen l) {\n\tten h = shaei(c.o, l);\n\tld k = sqrt(c.r*c.r - (h - c.o).abs2());\n\tv2 a = (l.p1 - l.p2) / (l.p1 - l.p2).abs();\n\treturn { h + a * k,h - a * k };\n}\ntenten koten(en c1, en c2) {\n\tld d = (c2.o - c1.o).abs();\n\tld s = acos((c1.r*c1.r + d * d - c2.r*c2.r) / (2 * c1.r*d));\n\tld t = kakudo(c2.o - c1.o);\n\treturn { c1.o + beku(c1.r,t + s),c1.o + beku(c1.r,t - s) };\n}\nll uchi(ten p, takaku &g) {\n\t//2:IN,1:ON,0:OUT\n\tll n = g.size();\n\tv2 a, b;\n\tbool x = false;\n\trep(i, 0, n) {\n\t\ta = g[i] - p; b = g[(i + 1) % n] - p;\n\t\tif (abs(a.gaiseki(b)) < MIN&&a.naiseki(b) < MIN)return 1;\n\t\tif (a.y > b.y)swap(a, b);\n\t\tif (a.y < MIN&&MIN<b.y&&a.gaiseki(b)>MIN)x = !x;\n\t}\n\treturn x ? 2 : 0;\n}\n\n//凸包\ntakaku andrew(takaku g) {\n\ttakaku u, b;\n\tif (g.size() < 3)return g;\n\tsort(ALL(g));\n\tu.pub(g[0]); u.pub(g[1]);\n\tb.pub(g.back()); b.pub(g[g.size() - 2]);\n\trep(i, 2, g.size()) {\n\t\trrep(j, u.size(), 2) {\n\t\t\tif (ccw(u[j - 2], u[j - 1], g[i]) == 1)break;\n\t\t\tu.pob();\n\t\t}\n\t\tu.pub(g[i]);\n\t}\n\trrep(i, g.size() - 3, 0) {\n\t\trrep(j, b.size(), 2) {\n\t\t\tif (ccw(b[j - 2], b[j - 1], g[i]) == 1)break;\n\t\t\tb.pob();\n\t\t}\n\t\tb.pub(g[i]);\n\t}\n\trep(i, 1, b.size() - 1)u.pub(b[i]);\n\treturn u;\n}\n\n//線分交差問題\nll kotensu(vec<senbun> s) {\n\tll n = s.size();\n\tstruct endp {\n\t\tten p; ll id, kind;//kind => 0:BOTTOM,1:LEFT,2:RIGHT,3:TOP\n\t\tbool operator<(const endp &e)const {\n\t\t\treturn p.y != e.p.y ? p.y < e.p.y : kind < e.kind;\n\t\t};\n\t};\n\t\n\tvec<endp> ep(2 * n);\n\trep(i, 0, n) {\n\t\tif (equal(s[i].p1.y, s[i].p2.y)) {\n\t\t\tif (s[i].p1.x > s[i].p2.x)swap(s[i].p1, s[i].p2);\n\t\t\tep[2 * i] = { s[i].p1,i,1 };\n\t\t\tep[2 * i + 1] = { s[i].p2,i,2 };\n\t\t}\n\t\telse {\n\t\t\tif (s[i].p1.y > s[i].p2.y)swap(s[i].p1, s[i].p2);\n\t\t\tep[2 * i] = { s[i].p1,i,0 };\n\t\t\tep[2 * i + 1] = { s[i].p2,i,3 };\n\t\t}\n\t}\n\n\tsort(ALL(ep));\n\n\tset<ll> bt;\n\tll cnt = 0;\n\trep(i, 0, 2 * n) {\n\t\tif (ep[i].kind == 3)bt.erase(ep[i].p.x);\n\t\telse if (ep[i].kind == 0)bt.insert(ep[i].p.x);\n\t\telse if (ep[i].kind == 1)cnt += distance(bt.lob(s[ep[i].id].p1.x), bt.upb(s[ep[i].id].p2.x));\n\t}\n\treturn cnt;\n}\n\n//0-1 ナップザック問題\nll maxvalue(ll W, const vll &v, const vll &w, vll &select) {\n\tll n = v.size();\n\n\tvec<vll> dp(n + 1, vll(W + 1, 0));\n\tvec<vec<bool>> tuika(n + 1, vec<bool>(W + 1, false));\n\n\trep(i, 1, n + 1) {\n\t\trep(j, 1, W + 1) {\n\t\t\tif (j - w[i - 1] >= 0 && dp[i - 1][j - w[i - 1]] + v[i - 1] > dp[i - 1][j]) {\n\t\t\t\tdp[i][j] = dp[i - 1][j - w[i - 1]] + v[i - 1];\n\t\t\t\ttuika[i][j] = true;\n\t\t\t}\n\t\t\telse dp[i][j] = dp[i - 1][j];\n\t\t}\n\t}\n\n\tll ww = W; select.clear();\n\trrep(i, n, 1) {\n\t\tif (tuika[i][ww]) {\n\t\t\tselect.pub(i - 1);\n\t\t\tww -= w[i - 1];\n\t\t}\n\t}\n\treverse(ALL(select));\n\n\treturn dp[n][W];\n}\n\n//二分探索\nbool isok(ll key) {\n\treturn false;\n}\nll minkey(ll lkey, ll rkey) {\n\twhile (lkey < rkey) {\n\t\tll mkey = (lkey + rkey) / 2;\n\t\tif (isok(mkey))rkey = mkey;\n\t\telse lkey = mkey + 1;\n\t}\n\treturn lkey;\n}\n\n//最長増加部分列\nll lis(const vll &a) {\n\tll n = a.size();\n\n\tvll l; l.pub(a[0]);\n\n\trep(i, 1, n) {\n\t\tif (l.back() < a[i])l.pub(a[i]);\n\t\telse *lob(ALL(l), a[i]) = a[i];\n\t}\n\treturn l.size();\n}\n\n//最大正方形\nll seimen(const vec<vll> &g) {\n\tll h = g.size(), w = g[0].size();\n\n\tvec<vll> dp(h, vll(w, 1));\n\n\tbool b = false;\n\trep(i, 0, h)if (g[i][0] == 1)dp[i][0] = 0; else b = true;\n\trep(i, 1, w)if (g[0][i] == 1)dp[0][i] = 0; else b = true;\n\n\tll maxhen = (b ? 1 : 0);\n\trep(i, 1, h) {\n\t\trep(j, 1, w) {\n\t\t\tif (g[i][j] == 1)dp[i][j] = 0;\n\t\t\telse {\n\t\t\t\tdp[i][j] = min({ dp[i][j - 1],dp[i - 1][j - 1],dp[i - 1][j] }) + 1;\n\t\t\t\tmaxhen = max(maxhen, dp[i][j]);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxhen * maxhen;\n}\n\n//最大長方形\nll chomen(const vec<vll> &g) {\n\tll h = g.size(), w = g[0].size();\n\n\tll maxmen = 0;\n\tvec<vll> dp(h, vll(w));\n\n\trep(i, 0, w)dp[0][i] = (g[0][i] == 1 ? 0 : 1);\n\trep(i, 1, h)rep(j, 0, w)dp[i][j] = (g[i][j] == 1 ? 0 : dp[i - 1][j] + 1);\n\n\trep(i, 0, h) {\n\n\t\tvec<pea> a;\n\t\trep(j, 0, w) {\n\t\t\tif (a.empty() || a.back().f < dp[i][j])a.pub({ dp[i][j],j });\n\n\t\t\telse if (a.back().f > dp[i][j]) {\n\t\t\t\tll k;\n\t\t\t\twhile (!a.empty() && a.back().f >= dp[i][j]) {\n\t\t\t\t\tmaxmen = max(maxmen, a.back().f*(j - a.back().s));\n\t\t\t\t\tk = a.back().s;\n\t\t\t\t\ta.pob();\n\t\t\t\t}\n\t\t\t\ta.pub({ dp[i][j],k });\n\t\t\t}\n\t\t}\n\n\t\twhile (!a.empty()) {\n\t\t\tmaxmen = max(maxmen, a.back().f*(w - a.back().s));\n\t\t\ta.pob();\n\t\t}\n\t}\n\n\treturn maxmen;\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout << fixed;\n\tsolve();\n}\nvoid solve() {\n\tll h, w; cin >> h >> w;\n\tvec<vll> c(h, vll(w));\n\trep(i, 0, h)rep(j, 0, w)cin >> c[i][j];\n\tcout << chomen(c) << kai;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include <cstdio>\n#include <algorithm>\n#include <stack>\n\nusing namespace std;\n\n#define maxa 1400+10\n\nstruct Rectangle {\n\tint height;\n\tint pos;\n};\n\nint we(int size, int buffer[]) {\n\tint i;\n\tstack<Rectangle> S;\n\tint maxv=0;\n\tbuffer[size]=0;\n\n\tfor(i=0; i<=size; i++) {\n\t\tRectangle rect;\n\t\trect.height=buffer[i];\n\t\trect.pos=i;\n\t\tif(S.empty()) {\n\t\t\tS.push(rect);\n\t\t} else {\n\t\t\tif(S.top().height < rect.height) {\n\t\t\t\tS.push(rect);\n\t\t\t} else if(S.top().height > rect.height) {\n\t\t\t\tint target = i;\n\t\t\t\twhile(!S.empty() && S.top().height > rect.height) {\n\t\t\t\t\tRectangle pre = S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tint area = pre.height * (i - pre.pos);\n\t\t\t\t\tmaxv=max(maxv, area);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos=target;\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxv;\n}\n\nint H,W;\nint buffer[maxa][maxa];\nint T[maxa][maxa];\n\nint solve() {\n\tint i,j;\n\n\tfor(j=0; j<W; j++)\n\t\tfor(i=0; i<H; i++) {\n\t\t\tif(buffer[i][j]==1) T[i][j]=0;\n\t\t\telse {\n\t\t\t\tT[i][j]=(i>0) ? T[i-1][j]+1 : 1;\n\t\t\t}\n\t\t}\n\n\tint maxv=0;\n\n\tfor(i=0; i<H; i++) {\n\t\tmaxv=max(maxv,we(W,T[i]));\n\t}\n\n\treturn maxv;\n}\n\nint main() {\n\tint i,j;\n\n\tscanf(\"%d %d\",&H,&W);\n\n\tfor(i=0; i<H; i++) {\n\t\tfor(j=0; j<W; j++) {\n\t\t\tscanf(\"%d\",&buffer[i][j]);\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",solve());\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main()\n{\n\tint H, W;\n\tcin >> H >> W;\n\n\tvector<vector<int>> map;\n\tfor(int i = 0; i < H; i++)\n\t{\n\t\tvector<int> line;\n\t\tfor(int j = 0; j < W  + 1; j++)\n\t\t{\n\t\t\tif(j == W)\n\t\t\t{\n\t\t\t\tline.push_back(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint state;\n\t\t\tcin >> state;\n\t\t\tline.push_back(state == 0 ? 1 : 0);\n\t\t}\n\t\tmap.push_back(line);\n\t}\n\n\tfor(int i = 0; i < H-1; i++)\n\t{\n\t\tfor(int j = 0; j < W; j++)\n\t\t{\n\t\t\tif(map[i + 1][j] != 0)\n\t\t\t{\n\t\t\t\tmap[i + 1][j] += map[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tint maxValue = 0;\n\tfor(int i = 0; i < H; i++)\n\t{\n\t\tfor(int j = 0; j < W; j++)\n\t\t{\n\t\t\tint minHight = map[i][j];\n\t\t\tif(minHight == 0)\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int k = j + 1; k < W + 1; k++)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tif(map[i][k] == 0)\n\t\t\t\t{\n\t\t\t\t\tint buf = (k-j) * minHight;\n\t\t\t\t\tmaxValue = maxValue > buf ? maxValue : buf;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tminHight = minHight < map[i][k] ? minHight : map[i][k];\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxValue << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define MAX_H 1510\n#define MAX_W 1510\n\nint H,W;\nint mat[MAX_H][MAX_W];\n\nint maximum_rectangle(){\n  int res = 0,h[MAX_W] = {0};\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      h[j] = (mat[i][j] == 0 ? h[j] + 1 : 0);\n    }\n    stack<pii> st;\n    st.push(pii(0,W));\n    for(int j = 0 ; j <= W ; j++){\n      int k = j;\n      while(h[j] < st.top().first){\n        k = st.top().second;\n        res = max(res,st.top().first*(j-k));\n        st.pop();\n      }\n      if(st.top().first < h[j]){\n        st.push(pii(h[j],k));\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin >> H >> W;\n  for(int i = 0 ; i < H ; i++){\n    for(int j = 0 ; j < W ; j++){\n      cin >> mat[i][j];\n    }\n  }\n  cout << maximum_rectangle() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#pragma warning( disable:4996 )\nusing namespace std;\n\n#define GMAX 1400\nint G[GMAX][GMAX];\nint T[GMAX][GMAX];\n\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectangle(int size, int buffer[])\n{\n\tint maxv = 0;\n\tstack<Rectangle> S;\n\tbuffer[size] = 0;\n\n\tfor (int i = 0; i <= size; i++) {\n\t\tRectangle rect;\n\t\trect.height = buffer[i];\n\t\trect.pos = i;\n\t\tif (S.empty()) {\n\t\t\tS.push(rect);\n\t\t}\n\t\telse {\n\t\t\tif (S.top().height < rect.height) {\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (S.top().height > rect.height) {\n\t\t\t\t\tint target = i;\n\t\t\t\t\twhile (!S.empty() && S.top().height >= rect.height) {\n\t\t\t\t\t\tRectangle pre = S.top(); S.pop();\n\t\t\t\t\t\tint area = pre.height * (i - pre.pos);\n\t\t\t\t\t\tmaxv = max(maxv, area);\n\t\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t\t}\n\t\t\t\t\trect.pos = target;\n\t\t\t\t\tS.push(rect);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn maxv;\n}\n\nint getLargestRectangle(int H, int W)\n{\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (G[i][j]) {\n\t\t\t\tT[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tT[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n\t\t\t}\n\t\t}\n\t}\n\tint maxv = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tmaxv = max(maxv, getLargestRectangle(W, T[i]));\n\t}\n\treturn maxv;\n}\n\nint main()\n{\n\tint H, W;\n\tscanf(\"%d %d\", &H, &W);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) scanf(\"%d\", &G[i][j]);\n\n\t}\n\tprintf(\"%d\\n\", getLargestRectangle(H, W));\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<vector>\n#include<map>\n#include<stack>\n#include<queue>\n\nusing namespace std;\n\nstruct Rect{int h; int w_pos;}; //w_position\n\nint main(){\n\tint c[1401][1401];\n\tint t1[1401];\n\tint H,W;\n\tint ans=0,sbans;\n\tscanf(\"%d %d\",&H,&W);\n\tfor(int i=0;i<=H;i++) c[i][0]=0;\n\tfor(int i=0;i<=W;i++) c[0][i]=0;\n\tfor(int i=0;i<=W;i++) t1[i]=0;\n\tfor(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++){\n\t\t\tscanf(\"%d \",&c[i][j]);\n\t\t\tif(c[i][j]==0) c[i][j]=1;\n\t\t\telse c[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=1;i<=H;i++){\n\t\tfor(int j=1;j<=W;j++){\n\t\t\tif(c[i][j]==1)\n\t\t\tc[i][j]=c[i-1][j]+1;\n\t\t\telse\n\t\t\tc[i][j]=0;\n\t\t}\n\t}\n\tfor(int i=1;i<=H;i++){\n\t\tstack<Rect> s;\n\t\tsbans=0;\n\t\tfor(int j=1;j<=W+1;j++){\n\t\t\tRect rect;\n\t\t\trect.h = c[i][j];\n\t\t\trect.w_pos = j;\n\t\t\tif(s.empty()) s.push(rect);\n\t\t\telse{\n\t\t\t\tif(s.top().h < rect.h) s.push(rect);\n\t\t\t\telse if(s.top().h > rect.h){\n\t\t\t\t\tint t=j;\n\t\t\t\t\twhile(!s.empty() && s.top().h >= rect.h){\n\t\t\t\t\t\tRect pre=s.top();\n\t\t\t\t\t\ts.pop();\n\t\t\t\t\t\tint area=pre.h * (j-pre.w_pos);\n\t\t\t\t\t\tsbans = max(sbans,area);\n\t\t\t\t\t\tt=pre.w_pos;\n\t\t\t\t\t}\n\t\t\t\t\trect.w_pos=t;\n\t\t\t\t\ts.push(rect);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans=max(ans,sbans);\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stack>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> pi;\n#define F first\n#define S second\n#define MP make_pair\nconst int N=15e2+10;\nint main(){\n    int n,m,a[N][N],now,ans,nx;\n    pi temp;\n    stack<pi> s;\n    scanf(\"%d%d\",&n,&m);\n    ans=0;\n    for(int i=0;i<n;i++){\n        now=0;\n        for(int j=0;j<m;j++){\n            scanf(\"%d\",&nx);\n            if(nx==0)now++;\n            else now=0;\n            a[i][j]=now;\n        }\n    }\n    for(int j=0;j<m;j++){\n        while(!s.empty())s.pop();\n        for(int i=0;i<n;i++){\n            while(!s.empty()){\n                if(s.top().F>a[i][j]){\n                    temp=s.top();\n                    s.pop();\n                    if(s.empty())ans=max(ans,temp.F*i);\n                    else ans=max(ans,temp.F*(i-1-s.top().S));\n                }\n                else break;\n            }\n            s.push(MP(a[i][j],i));\n        }\n        while(!s.empty()){\n            temp=s.top();\n            s.pop();\n            if(s.empty())ans=max(ans,temp.F*n);\n            else ans=max(ans,temp.F*(n-s.top().S-1));\n            \n        }\n    }\n    printf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<algorithm>\n#include<stack>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define INF INT_MAX/3\n#define PII pair<int,int>\n#define MPII(a,b) make_pair((a),(b))\n\nint M[1400][1400];\nint dp[1400][1401] = {};\n\nint main()\n{\n\tint ans = 0;\n\tint H, W;\n\tcin >> H >> W;\n\tREP(i, H)REP(j, W)cin >> M[i][j];\n\tREP(j, W)if (M[0][j] == 0)dp[0][j] = 1;\n\tFOR(i, 1, H)REP(j, W)if (M[i][j] == 0)dp[i][j] = dp[i - 1][j] + 1;\n\tREP(i, H)\n\t{\n\t\tstack<PII> stk;\n\t\tREP(j, W+1)\n\t\t{\n\t\t\tif (stk.empty() || stk.top().second < dp[i][j])\n\t\t\t{\n\t\t\t\tstk.push(MPII(j, dp[i][j]));\n\t\t\t}\n\t\t\telse if (stk.top().second > dp[i][j])\n\t\t\t{\n\t\t\t\twhile (stk.top().second > dp[i][j])\n\t\t\t\t{\n\t\t\t\t\tint rect = (j - stk.top().first)*stk.top().second;\n\t\t\t\t\tans = max(ans, rect);\n\t\t\t\t\tstk.pop();\n\t\t\t\t\tif (stk.empty())break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct Problem {\n\n    UL SX[1401][1401] = {};\n\n    void Solve() {\n        UL H, W; scanf(\"%d%d\", &H, &W);\n        rep(y, H) rep(x, W) {\n            UL c; scanf(\"%d\", &c);\n            if (c == 1) continue;\n            SX[x + 1][y] = SX[x][y] + 1;\n        }\n        UL ans = 0;\n        deque<pair<UL, UL>> Q;\n        for (UL x = 1; x <= W; x++) {\n            Q.push_back({ 0,0 });\n            for (UL y = 0; y <= H; y++) {\n                UL p = y;\n                while (Q.back().first > SX[x][y]) {\n                    ans = max(ans, Q.back().first * (y - Q.back().second));\n                    p = Q.back().second;\n                    Q.pop_back();\n                }\n                Q.push_back({ SX[x][y], p });\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n};\nint main() {\n    unique_ptr<Problem> p(new Problem());\n    p->Solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\nint n, c[1500][1500], dp[1500][1500], l[1500], r[1500], st[1500];\nsigned main(void)\n{\n  int H, W;\n  cin >> H >> W;\n  REP(i, H) REP(j, W) cin >> c[i][j];\n\n  REP(i, W) {\n    int cnt = 1;\n    REP(j, H) {\n      if(!c[j][i]) {\n        dp[j][i] = cnt;\n        cnt++;\n      } else {\n        dp[j][i] = 0;\n        cnt = 1;\n      }\n    }\n  }\n  ll ret = 0;\n  REP(j, H) {\n    int t = 0;\n    REP(i, W) {\n      while(t>0 && dp[j][st[t-1]] >= dp[j][i]) t--;\n      l[i] = t == 0 ? 0 : (st[t-1]+1);\n      st[t++] = i;\n    }\n    t = 0;\n    for(int i=W-1; i>=0; --i) {\n      while(t > 0 && dp[j][st[t-1]] >= dp[j][i]) t--;\n      r[i] = t == 0 ? n : st[t-1];\n      st[t++] = i;\n    }\n    REP(i, W) ret = max(ret, (ll)dp[j][i]*(r[i]-l[i]));\n  }\n  cout << ret << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct rect{\n\t  int left, height;\n\t  rect(int l, int h){\n\t\t\tleft = l; height = h;\n\t  }\n};\n\nint solve(vector<int>& hist){\n\t  hist.push_back(0);\n\t  int W = hist.size();\n\t  int ans = 0;\n\t  stack<rect> st;\n\t  for(int i=0; i<W; i++){\n\t\t\tif( st.empty() ){\n\t\t\t\t  st.push( rect(i,hist[i]) );\t\n\t\t\t}else{\n\t\t\t\t  rect max_h = st.top();\n\t\t\t\t  if( max_h.height < hist[i]){\n\t\t\t\t\t\tst.push( rect(i,hist[i]) );\n\t\t\t\t  }\n\t\t\t\t  else if( max_h.height > hist[i] ){\n\t\t\t\t\t\twhile( !st.empty() and max_h.height >= hist[i] ) {\n\t\t\t\t\t\t\t  ans = max(ans, max_h.height * (i-max_h.left) );\n\t\t\t\t\t\t\t  st.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t\tst.push( rect(max_h.left, hist[i]) ) ;\n\t\t\t\t  }\n\t\t\t}\n\t  }\n\t  return ans ;\n}\n\n\t  int main(){\n\t\t\t// input\n\t\t\tint H,W;\n\t\t\tcin >> H >> W;\n\t\t\tvector<vector<int> > m(H+1,vector<int>(W,0));\n\t\t\tfor(int i=1; i<=H; i++)\n\t\t\t\t  for(int j=0; j<W; j++)\n\t\t\t\t\t\tcin >> m[i][j];\n\n\t\t\t// pre proces\n\t\t\tvector<vector<int> > dp(H+1,vector<int>(W,0));\n\t\t\tfor(int i=1; i<=H; i++){\n\t\t\t\t  for(int j=0; j<W; j++){\n\t\t\t\t\t\tif(m[i][j] == 1)\n\t\t\t\t\t\t\t  dp[i][j] = 0;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t  dp[i][j] = dp[i-1][j]+1;\n\t\t\t\t  }\n\t\t\t}\n\t  \n\t\t\tint ans = 0;\n\t\t\tfor(int i=1; i<=H; i++)\n\t\t\t\t  ans = max(ans, solve(dp[i]));\n\n\n\t\t\t/*\n\t\t\t  for(int i=1; i<=H; i++){\n\t\t\t  for(int j=0; j<W; j++){\n\t\t\t  cout << dp[i][j] <<\" \";\n\t\t\t  }\n\t\t\t  cout << \": \" << solve(dp[i]) << endl;\n\t\t\t  }\n\t\t\t*/\n\t  \n\t\t\tcout << ans << endl;\n\t  \n\t  }"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stack>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> pi;\n#define F first\n#define S second\n#define MP make_pair\nconst int N=5e2+10;\nint main(){\n    int n,m,a[N][N],now,ans,nx;\n    pi temp;\n    stack<pi> s;\n    while(true){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0&&m==0)return 0;\n        ans=0;\n        for(int i=0;i<n;i++){\n            scanf(\"%s\",c);\n            now=0;\n            for(int j=0;j<m;j++){\n                scanf(\"%d\",&nx);\n                if(nx==1)now++;\n                else now=0;\n                a[i][j]=now;\n            }\n        }\n        for(int j=0;j<m;j++){\n            while(!s.empty())s.pop();\n            for(int i=0;i<n;i++){\n                while(!s.empty()){\n                    if(s.top().F>a[i][j]){\n                        temp=s.top();\n                        s.pop();\n                        if(s.empty())ans=max(ans,temp.F*i);\n                        else ans=max(ans,temp.F*(i-1-s.top().S));\n                    }\n                    else break;\n                }\n                s.push(MP(a[i][j],i));\n            }\n            while(!s.empty()){\n                temp=s.top();\n                s.pop();\n                if(s.empty())ans=max(ans,temp.F*n);\n                else ans=max(ans,temp.F*(n-s.top().S-1));\n                \n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n\tRectangle rect;\n\tfor(int i=0;i<x;i++){\n\t\tstack<Rectangle> stk;\n\t\trect.height = 0;\n\t\trect.pos = 0;\n\t\tstk.push(rect);\n\t\tint pop=0;\n\t\tfor(int j=0;j<=y;j++){\n\t\t\trect.height = m[j][i];\n\t\t\trect.pos = j;\n\t\t\tif(stk.empty() || stk.top().height < rect.height){\n\t\t\t\tstk.push(rect);\n\t\t\t}else{\n\t\t\t\t//printf(\"[-] %d %d\\n\",i,j);\n\t\t\t\tfor(;!stk.empty() && stk.top().height >= rect.height;){\n\t\t\t\t\tpop++;\n\t\t\t\t\tRectangle pre = stk.top(); stk.pop();\n\t\t\t\t\tpre.pos=stk\n\t\t\t\t\tint area = pre.height * (j - pre.pos);\n\t\t\t\t\tr = max(r, area);\n\t\t\t\t\t//printf(\"%d %d\\n\",target,pre.pos);\n\t\t\t\t\trect.pos = pre.pos;\n\t\t\t\t}\n\t\t\t\tstk.push(rect);\n\t\t\t}\n\t\t\tif(rect.height==0)pop=0;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nstruct rectagle {\n\tint pos, height;\n};\n\nint getMax(int T[], int W) {\n\n\tstack<rectagle> S;\n\tint maxv = 0;\n\tfor (int i = 0; i <= W; ++i) {\n\t\trectagle r;\n\t\tr.pos = i;\n\t\tif (i != W) {\n\t\t\tr.height = T[i];\n\t\t} else {\n\t\t\tr.height = 0;\n\t\t}\n\t\tif (S.empty() || r.height > S.top().height) {\n\t\t\tS.push(r);\n\t\t} else {\n\t\t\twhile (!S.empty() && S.top().height > r.height) {\n\t\t\t\trectagle pop = S.top();\n\t\t\t\tS.pop();\n\t\t\t\tint area = (i - pop.pos) * pop.height;\n\t\t\t\tmaxv = max(maxv, area);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn maxv;\n}\n\nint main() {\n\n\tint H, W;\n\tscanf(\"%d %d\", &H, &W);\n\n\tint A[H][W];\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tscanf(\"%d\", &A[i][j]);\n\t\t}\n\t}\n\tint T[H][W];\n\tfor (int j = 0; j < W; ++j) {\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tif (A[i][j] == 0) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tT[i][j] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tT[i][j] = T[i - 1][j] + 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tT[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxv = 0;\n\tfor (int i = 0; i < H; ++i) {\n\t\tmaxv = max(maxv, getMax(T[i], W));\n\t}\n\tcout << maxv << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#pragma comment(linker,\"/STACK:102400000,102400000\")\n#define INF 0x3f3f3f3f\n#define maxm 1500\ntypedef long long ll;\nusing namespace std;\nint mp[maxm][maxm]{0};\nint t[maxm][maxm]{0};\nint calRectangle(int (&vec)[maxm],int w,int time)\n{\n    int result=0;\n    stack<int> stk;\n    vec[w+1]=0;\n    //if(true){for(int i=1;i<=w;i++)cout<<vec[i]<<\" \";cout<<endl;}\n    for(int i=1;i<=w+1;)\n    {\n        if(stk.empty()/*Stuck is empty*/||vec[stk.top()]<=vec[i]/*The list upper*/)\n        {\n            stk.push(i);/*Stuck <- i(pointer)*/\n            i++;\n        }\n        else\n        {\n            int temp=stk.top();/*Save the topStuck pointer*/\n            stk.pop();/*Find the former pushed pointer*/\n            result=max(result,vec[temp]*(stk.empty()?(i-1):(i-stk.top()-1)));\n            //i--;/*Keep the value of i(i--++=1)*/\n        }\n    }\n    //cout<<result<<endl;\n    return result;\n}\nint main()\n{\n    int h,w,pt,res=0;\n    cin>>h>>w;\n    for(int i=1;i<=h;i++)\n        for(int j=1;j<=w;j++)\n            cin>>mp[i][j];\n    for(int j=1;j<=w;j++)\n    {\n        pt=1;\n        for(int i=1;i<=h;i++)\n            if(!mp[i][j])\n                t[i][j]=pt++;\n            else\n            {\n                t[i][j]=0;\n                pt=1;\n            }\n    }\n    //for(int i=1;i<=h;i++){for(int j=1;j<=w;j++)cout<<t[i][j]<<\" \";cout<<endl;};\n    for(int i=1;i<=h;i++)\n        res=max(res,calRectangle(t[i],w,i));\n    cout<<res<<endl;\n    return 0;\n}\n//Do not use memset !\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 1400;\n\nint a[MAX_N][MAX_N];\nint t[MAX_N][MAX_N];\ndeque<P> deq;\n\nint main()\n{\n\tint h,w;\n\tcin >> h >> w;\n\tint ans=0;\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t}\n\t}\n\trep(i,h){\n\t\tt[i][w] = 0;\n\t}\n\trep(j,w){\n\t\tt[0][j] = 1^a[0][j];\n\t}\n\tfor(int i=1;i<h;i++){\n\t\trep(j,w){\n\t\t\tif(a[i][j]==0){\n\t\t\t\tt[i][j] = t[i-1][j] + 1;\n\t\t\t}else{\n\t\t\t\tt[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\tint pos;\n\trep(i,h){\n\t\trep(j,w+1){\n\t\t\tif(deq.empty()){\n\t\t\t\tdeq.push_back(P(t[i][j],j));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdeque<P>::iterator it = deq.end()-1;\n\t\t\tif((*it).first < t[i][j]){\n\t\t\t\tdeq.push_back(P(t[i][j],j));\n\t\t\t}else if((*it).first > t[i][j]){\n\t\t\t\twhile(!deq.empty() && (*it).first > t[i][j]){\n\t\t\t\t\tint S = (*it).first*(j-(*it).second);\n\t\t\t\t\tpos = (*it).second;\n\t\t\t\t\tans = max(S,ans);\n\t\t\t\t\tdeq.pop_back();\n\t\t\t\t\tit = deq.end()-1;\n\t\t\t\t}\n\t\t\t\tdeq.push_back(P(t[i][j],pos));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n//#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\n//?????§????????¢\nvoid largest_rectangle() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>> v(H, vector<int>(W));\n\trep(i, 0, H) rep(j, 0, W) {\n\t\tint x; cin >> x;\n\t\tv[i][j] = !x;\n\t}\n\trep(i, 0, H - 1)rep(j, 0, W) {\n\t\tif (v[i + 1][j] == 0)continue;\n\t\tv[i + 1][j] += v[i][j];\n\t}\n\tusing P = pair<int, int>;\n\tint ans = 0;\n\trep(i, 0, H) {\n\t\tstack<P> st;\n\t\tst.emplace(0, 0);\n\t\trep(j, 0, W) {\n\t\t\tdump(i, v[i], j, st, ans);\n\t\t\tif (st.top().first == v[i][j])\n\t\t\t\tcontinue;\n\t\t\twhile (st.top().first > v[i][j]) {\n\t\t\t\tchmax(ans, st.top().first*(j - st.top().second));\n\t\t\t\tst.pop();\n\t\t\t}\n\t\t\tst.emplace(v[i][j], j);\n\t\t}\n\t\twhile (st.size()) {\n\t\t\tchmax(ans, st.top().first*(W - st.top().second));\n\t\t\tst.pop();\n\t\t}\n\t}\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tlargest_rectangle();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<stack>\n#include<algorithm>\n\n#define MAX 1400\n\nusing namespace std;\n\n#define MAX 1400\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n\nint getLargestRectangle(int size, int buffer[]) {\n  stack<Rectangle> S;\n  int maxv = 0;\n  buffer[size] = 0;\n\n  for (int i = 0; i <= size; i++) {\n    Rectangle rect;\n    rect.height = buffer[i];\n    rect.pos = i;\n    if (S.empty()) {\n      S.push(rect);\n    } else {\n      if (S.top().height < rect.height) {\n        S.push(rect);\n      } else if (S.top().height > rect.height) {\n        int target = i;\n        while (!S.empty() && S.top().height >= rect.height) {\n          Rectangle pre = S.top(); S.pop();\n          int area = pre.height * (i - pre.pos);\n          maxv = max(maxv, area);\n          target = pre.pos;\n        }\n        rect.pos = target;\n        S.push(rect);\n      }\n    }\n  }\n  return maxv;\n}\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle() {\n  for (int j = 0; j < W; j++) {\n    for (int i = 0; i < H; i++) {\n      if (buffer[i][j]) {\n        T[i][j] = 0;\n      } else {\n        T[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n      }\n    }\n  }\n\n  int maxv = 0;\n  for (int i = 0; i < H; i++) {\n    maxv = max(maxv, getLargestRectangle(W, T[i]));\n  }\n\n  return maxv;\n}\n\nint main() {\n  scanf(\"%d %d\", &H, &W);\n\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      scanf(\"%d\", &buffer[i][j]);\n    }\n  }\n\n  cout << getLargestRectangle() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint grd[2000][2000];\nint main(){\n\tint h,w;\tcin>>h>>w;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++)\tcin>>grd[i][j];\n\t}\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(grd[i][j]==1)\tgrd[i][j]=0;\n\t\t\telse if(i==0)\tgrd[i][j]=1;\n\t\t\telse \tgrd[i][j]=grd[i-1][j]+1;\n\t\t}\n\t}\n\t/*for(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++)\tcout<<grd[i][j]<<\" \";\n\t\tcout<<endl;\n\t}*/\n\tint ans=0;\n\tfor(int i=0;i<h;i++){\n\t\tstack<pair<int,int>> s;\n\t\ts.push(make_pair(-1,-1));\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(grd[i][j]>s.top().first){\n\t\t\t\ts.push(make_pair(grd[i][j],j));\n\t\t\t\t//cout<<\"push:\"<<grd[i][j]<<\" \"<<j<<endl;\n\t\t\t}\n\t\t\telse if(grd[i][j]==s.top().first){\n\t\t\t\ts.pop();\n\t\t\t\ts.push(make_pair(grd[i][j],j));\n\t\t\t\t//cout<<\"push:\"<<grd[i][j]<<\" \"<<j<<endl;\n\t\t\t}\n\t\t\telse{\n\t\t\t\twhile(s.top().first>grd[i][j]){\n\t\t\t\t\tint hh=s.top().first;\n\t\t\t\t\twhile(hh<=s.top().first)\ts.pop();\n\t\t\t\t\tint ww=s.top().second;\n\t\t\t\t\tans=max(ans,hh*(j-ww-1));\n\t\t\t\t\ts.push(make_pair(s.top().first,j-1));\n\t\t\t\t\t//cout<<\"change:\"<<hh<<\" \"<<(j-ww-1)<<endl;\n\t\t\t\t\t//cout<<\"push:\"<<s.top().first<<\" \"<<j-1<<endl;\n\t\t\t\t}\n\t\t\t\ts.push(make_pair(grd[i][j],j));\n\t\t\t\t//cout<<\"push:\"<<grd[i][j]<<\" \"<<j<<endl;\n\t\t\t}\n\t\t}\n\t\twhile(s.top().first>0){\n\t\t\tint hh=s.top().first,we=s.top().second;\n\t\t\twhile(hh<=s.top().first)\ts.pop();\n\t\t\tint ws=s.top().second;\n\t\t\tans=max(ans,hh*(we-ws));\n\t\t\tint sf=s.top().first;\ts.pop();\n\t\t\ts.push(make_pair(sf,we));\n\t\t\t//cout<<\"change:\"<<hh<<\" \"<<(we-ws)<<endl;\n\t\t\t//cout<<\"push:\"<<sf<<\" \"<<we<<endl;\n\t\t}\n\t\t//cout<<\"end col:\"<<i<<endl;\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n\nclass Stack {\npublic:\n\tStack(const int &max = 1400) :vector(max + 1), idx(max + 1), end{ 1 }, sz{ 0 } { vector.at(0) = 0; };\n\tvoid push(const int &factor) {\n\t\tvector.at(end) = factor;\n\t\tidx.at(end) = sz;\n\t\t++end; ++sz;\n\t}\n\tvoid replace(const int &factor) {\n\t\tvector.at(end) = factor;\n\t\t++end; ++sz;\n\t}\n\tint top() { return  vector.at(end - 1); }\n\tint index() { return idx.at(end - 1); }\n\tint size() { return sz; }\n\tvoid pop() {  --end; }\n\tvoid clear() { vector.at(0) = 0; end = 1; sz = 0; }\nprivate:\n\tstd::vector<int> vector, idx;\n\tint end, sz;\n};\nint main() {\n\tint h, w;\n\tstd::scanf(\"%d %d\", &h, &w);\n\tstd::vector<int> line(w, 0);\n\tStack stack(w);\n\tint max = 0;\n\tfor (auto i = 0; i < h; ++i) {\n\t\tfor (auto j = 0; j < w; ++j) {\n\t\t\tint cell;\n\t\t\tstd::scanf(\"%d\", &cell);\n\t\t\tif (cell == 1) {\n\t\t\t\tline.at(j) = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\t++line.at(j);\n\t\t\t}\n\t\t\tif (stack.top() < line.at(j)) {\n\t\t\t\tstack.push(line.at(j));\n\t\t\t}\n\t\t\telse {\n\t\t\t\twhile (stack.top() > line.at(j)) {\n\t\t\t\t\tif (stack.top() * (stack.size() - stack.index()) > max) {\n\t\t\t\t\t\tmax = stack.top() * (stack.size() - stack.index());\n\t\t\t\t\t}\n\t\t\t\t\tstack.pop();\n\t\t\t\t}\n\t\t\t\tif (stack.top() != line.at(j)) {\n\t\t\t\t\tstack.replace(line.at(j));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile (stack.top() > 0) {\n\t\t\tif (stack.top() * (stack.size() - stack.index()) > max) {\n\t\t\t\tmax = stack.top() * (stack.size() - stack.index());\n\t\t\t}\n\t\t\tstack.pop();\n\t\t}\n\t\tstack.clear();\n\t}\n\tstd::printf(\"%d\\n\", max);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<stack>\n#include<algorithm>\n#define MAX 1400\n\nusing namespace std;\n\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectsngle(int size, int buffer[]) {\n\tstack<Rectangle> S;\n\tint maxv = 0;\n\tbuffer[size] = 0;\n\n\tfor (int i = 0; i <= size; i++) {\n\t\tRectangle rect;\n\t\trect.height = buffer[i];\n\t\trect.pos = i;\n\t\tif (S.empty()) {\n\t\t\tS.push(rect);\n\t\t}\n\t\telse {\n\t\t\tif (S.top().height < rect.height) {\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t\telse if (S.top().height > rect.height) {\n\t\t\t\tint target = i;\n\t\t\t\twhile (!S.empty() && S.top.height >= rect.height) {\n\t\t\t\t\tRectangle pre = S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tint area = pre.height*(i - pre.pos);\n\t\t\t\t\tmaxv = max(maxv, area);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos = target;\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxv;\n}\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle() {\n\tfor (int j = 0; j < W; j++) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tif (buffer[i][j]) {\n\t\t\t\tT[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tT[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxv = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tmaxv = max(maxv, getLargestRectangle(W, T[i]));\n\t}\n\n\treturn maxv;\n}\n\nint main() {\n\tscanf(\"%d %d\", &H, &W);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tscanf(\"%d\", &buffer[i][j]);\n\t\t}\n\t}\n\tcout << getLargestRectangle() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<ctime>\n#include<cstring>\n#include<numeric>\n#include<stack>\n\n#define ALL(v) (v).begin(),(v).end()\n#define REP(i,p,n) for(int i=p;i<(int)(n);++i)\n#define rep(i,n) REP(i,0,n)\n#define dump(a) (cerr << #a << \"=\" << (a) << endl)\n#define DUMP(list) cout << \"{ \"; for(auto nth : list){ cout << nth << \" \"; } cout << \"}\" << endl;\n\nusing namespace std;\n\nint main() {\n\tint H, W;\n\tcin >> H >> W;\t\n\tvector<vector<int>>\ttiles(H, vector<int>(W, 0));\n\trep(i, H) {\n\t\trep(j, W) {\n\t\t\tint c;\t\n\t\t\tcin >> c;\t\n\t\t\ttiles[i][j] = !c;\t\n\t\t}\n\t}\n\n\trep(i, W) {\n\t\tREP(j, 1, H) {\n\t\t\ttiles[j][i] += (!tiles[j][i]) ? 0 : tiles[j-1][i];\n\t\t}\n\t}\n\n\tlong long res = 0;\t\t\t\n\tfor(const vector<int> &h : tiles) {\n\t\tvector<int> left(W, 0), right(W, 0);\t\t\n\t\tstack<int> st;\n\t\tfor(int i = 0; i < W; ++i) {\n\t\t\twhile(!st.empty() && h[st.top()] >= h[i]) st.pop();\t\n\t\t\tleft[i] = (st.empty()) ? 0 : st.top() + 1; \n\t\t\tst.push(i);\n\t\t}\n\t\t\n\t\twhile(!st.empty()) st.pop();\t\n\t\t\n\t\tfor(int i = W - 1; i >= 0; --i) {\n\t\t\twhile(!st.empty() && h[st.top()] >= h[i]) st.pop();\t\n\t\t\tright[i] = (st.empty()) ? W : st.top(); \n\t\t\tst.push(i);\n\t\t}\n\n\t\tfor(int i = 0; i < W; ++i) {\n\t\t\tres = max(res, (long long)h[i] * (right[i] - left[i]));\n\t\t}\n\t}\n\tcout << res << endl;\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define ALL(a) (a).begin(),(a).end()\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nusing namespace std;\nstruct po{int x,y,is_tile;};\n\nint main(){\n  int H,W;\n  cin >> H >> W;\n  vector<vector<po>> dp(H+1,vector<po>(W+1));\n  REP(i,1)\n    REP(j,1){\n      dp[i][j].is_tile = 0;\n      dp[i][j].x = 0;\n      dp[i][j].y = 0;\n  }\n  \n  REP(i,H)\n    REP(j,W)\n    cin >> dp[i+1][j+1].is_tile;\n\n  int max_rectangle = 0;\n  REP(i,H){\n    REP(j,W){\n      if(dp[i+1][j+1].is_tile == 0){\n\tif(dp[i][j].x >= dp[i+1][j].x && dp[i][j].y >= dp[i][j+1].y){\n\t  dp[i+1][j+1].x = dp[i+1][j].x + 1;\n\t  dp[i+1][j+1].y = dp[i][j+1].y + 1;\n\t}else if(dp[i+1][j].x+1 < dp[i][j+1].y+1){\n\t  if( (dp[i][j].y+1)*(dp[i][j].x+1) > dp[i][j+1].y+1){\n\t    dp[i+1][j+1].x = dp[i][j].x + 1;\n\t    dp[i+1][j+1].y = dp[i][j].y + 1;\n\t  \n\t  }else{\n\t    dp[i+1][j+1].y = dp[i][j+1].y + 1;\n\t    dp[i+1][j+1].x = 1;\n \n\t  }\n\t}else{\n\t  if( (dp[i][j].y+1)*(dp[i][j].x+1) > dp[i+1][j].x+1){\n\t    dp[i+1][j+1].x = dp[i][j].x + 1;\n\t    dp[i+1][j+1].y = dp[i][j].y + 1;\n\t   \n\t  }else{\n\t    dp[i+1][j+1].x = dp[i+1][j].x + 1;\n\t    dp[i+1][j+1].y = 1;\n\n\t  }\n\t}\n      }else{\n\tdp[i+1][j+1].x = 0;\n\tdp[i+1][j+1].y = 0;\n      }\n      max_rectangle = max(max_rectangle,dp[i+1][j+1].x * dp[i+1][j+1].y);\n      //      cout << \"(\" <<dp[i+1][j+1].x << \",\" << dp[i+1][j+1].y << \") \";\n    }\n    //    cout << endl;\n  }\n  REP(i,H+1){\n    REP(j,W+1){\n\n    }\n    \n  }\n\n  cout << max_rectangle << endl;\n\t\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define repr(i, n) for (int i = (int)(n); i >= 0; i--)\n#define REP(i, m, n) for (int i = (int)(m); i <= (int)(n); i++)\n#define REPR(i, m, n) for (int i = (int)(m); i >= (int)(n); i--)\n#define all(v) v.begin(), v.end()\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\nconst int INF = 1001001001;\n\nint H, W;\nint field[1410][1410];\n\nstruct Rectangle { int height, pos; };\n\nint main(){\n  cin >> H >> W;\n\n  rep(h, H){\n    rep(w, W){\n      char c; cin >> c;\n      if(c == '0') field[h][w] = 1;\n      else if(c == '1') field[h][w] = 0;\n    }\n  }\n  rep(w, W){\n    REP(h, 1, H-1){\n      if(field[h][w] == 0) continue;\n      field[h][w] += field[h-1][w];\n    }\n  }\n  rep(h, H) field[h][W] = 0;\n\n  int ma = 0;\n  rep(h, H){\n    stack<Rectangle> S;\n    rep(w, W+1){\n      Rectangle rect;\n      rect.height = field[h][w];\n      rect.pos = w;\n      if(S.empty()) S.push(rect);\n      else if(rect.height > S.top().height){\n        S.push(rect);\n      }\n      else if(rect.height < S.top().height){\n        int target = w;\n        while(!S.empty() && rect.height <= S.top().height){\n          Rectangle pre = S.top(); S.pop();\n          int area = pre.height * (w - pre.pos);\n          chmax(ma, area);\n          target = pre.pos;\n        }\n        rect.pos = target;\n        S.push(rect);\n      }\n    }\n  }\n \n  cout << ma << endl;\n\n  return 0;\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<stack>\nusing namespace std;\nint h, w, map[1401][1401], upmost[1401][1401], ans;\nstruct rect{\n    int h, pos;\n    rect(){}\n    rect(int h, int pos){\n        this->h = h;\n        this->pos = pos;\n    }\n};\nstack<rect> dp;\n\n\nint main(){\n    //freopen(\"in.txt\", \"r\", stdin);\n    scanf(\"%d %d\", &h, &w);\n    memset(upmost, 0, sizeof(upmost));\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++){\n            scanf(\"%d\", &map[i][j]);\n            upmost[i][j] = 1 - map[i][j];\n        }\n        upmost[i][w] = 0;\n    }\n    for(int i=1; i<h; i++)\n    for(int j=0; j<w; j++)\n        if(upmost[i][j]!=0)\n            upmost[i][j] += upmost[i-1][j];\n\n/*\n    for(int i=0; i<h; i++){\n        for(int j=0; j<w; j++)\n            printf(\"%d \", upmost[i][j]);\n        printf(\"\\n\");\n    }\n*/\n    ans = 0; \n    for(int i=0; i<h; i++){\n        while(!dp.empty()) dp.pop();\n        for(int j=0; j<w+1; j++){\n            if(dp.empty())\n                dp.push(rect(upmost[i][j], j));\n            else if(dp.top().h > upmost[i][j]){\n                int left_most = j;\n                while(!dp.empty() && dp.top().h > upmost[i][j]){\n                    ans = max(ans, (j-dp.top().pos)*dp.top().h);\n                    left_most = dp.top().pos;\n                    dp.pop();\n                }\n                dp.push(rect(upmost[i][j], left_most));\n            }else if(dp.top().h < upmost[i][j])\n                dp.push(rect(upmost[i][j], j));\n        }\n    }    \n\n    printf(\"%d\\n\", ans);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 問題: H*Wのタイルが与えられる。タイルは綺麗か汚れているかのいずれか。\n//       綺麗なタイルのみでできる最大の長方形の最大値を求める\n// 解法: http://algorithms.blog55.fc2.com/blog-entry-133.html\n//       http://algorithms.blog55.fc2.com/blog-entry-132.html\n//       まず各要素について上に向かって 1 が何個連続しているかを示すテーブル T を作る\n//       次に、T の各行をヒストグラムの入力と見なしヒストグラムの最大長方形の面積を求めるアルゴリズムを適用\n\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n#define pb push_back\n#define mp make_pair\n\nint largest_square(const int H, const int W, const vector<vector<int>>& cells) {\n    // 上に綺麗なタイルが連続する数\n    // 番兵として、右端は汚れたタイルがあるものとする\n    vector<vector<int>> table(H, vector<int>(W+1));\n    REP(w, W) {\n        REP(h, H) {\n            auto val = cells[h][w];\n            if (val == 1) table[h][w] = 0;\n            else {\n                if (h == 0) table[h][w] = val;\n                else table[h][w] = table[h-1][w] + 1;\n            }\n            // cout << table[h][w] << \" \";\n        }\n        // cout << endl;\n    }\n\n    int ans = 0;\n    // 各行ごとに、ヒストグラムの最大長方形の面積を求めるアルゴリズムを適用\n    REP(h, H) {\n        // <ヒストグラムの高さ, index>\n        stack<pair<int, int>> s;\n        REP(w, W+1) {\n            auto height = table[h][w];\n            if (s.empty()) s.push(mp(height, w));\n            else if (s.top().first < height) s.push(mp(height, w));\n            else if (s.top().first > height) {\n                while(!s.empty() && s.top().first > height) {\n                    auto area = (w - s.top().second) * s.top().first;\n                    ans = max(area, ans);\n                    s.pop();\n                }\n            }\n        }\n    }\n    return ans;\n}\n\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n\n    vector<vector<int>> cells(H, vector<int>(W));\n    REP(h, H) {\n        REP(w, W) {\n            cin >> cells[h][w];\n        }\n    }\n\n    cout << largest_square(H, W, cells) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<stack>\n#include<iostream>\nusing namespace std;\nint H, W; int maxv = 0;\nint c[1400][1400], t[1400][1400];\nstruct Rect\n{\n  int pos, height;\n  Rect() {}\n  Rect(int pos, int height): pos(pos), height(height) {}\n};\n\nvoid solve()\n{\n  stack<Rect> S;\n  for(int h=0; h<H; h++)\n  {\n    t[h][W] = 0;\n    for(int w=0; w<=W; w++)\n    {\n      Rect rec = Rect(w, t[h][w]);\n      Rect r;\n      if(t[h][w] == 0)\n      {\n        while(!S.empty())\n        {\n          r = S.top(); S.pop();\n          int width = w-r.pos;\n          int area = width*r.height;\n          maxv = max(maxv, area);\n        }\n      }\n      else\n      {\n        if(S.empty()) {S.push(rec); continue;}\n        if(S.top().height < rec.height) {S.push(rec); continue;}\n        if(S.top().height > rec.height)\n        { int target = w;\n          while(!S.empty() && S.top().height >= rec.height)\n          {\n            r = S.top(); S.pop();\n            int width = w-r.pos;\n            int area = width*r.height;\n            target = r.pos;\n            maxv = max(maxv, area);\n          }\n          rec.pos = target;\n          S.push(rec);\n        }\n      }\n    }\n    while(!S.empty())\n      S.pop();\n  }\n  printf(\"%d\\n\", maxv);\n}\n\nint main()\n{\n  scanf(\"%d%d\", &H, &W);\n  for(int i=0; i<H; i++)\n  {\n    for(int j=0; j<W; j++)\n    {\n      scanf(\"%d\", &c[i][j]);\n    }\n  }\n  for(int j=0; j<W; j++)\n  {\n    if(c[0][j] == 0)\n      t[0][j] = 1;\n    else t[0][j] = 0;\n  }\n  for(int i=1; i<H; i++)\n  {\n    for(int j=0; j<W; j++)\n    {\n      if(c[i][j] == 1)\n        t[i][j] =0;\n      else\n      {\n        t[i][j] = t[i-1][j] + 1;\n      }\n    }\n  }\n  solve();\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cassert>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n// ---------------------\n// repetition\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n\n// debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\n// ---------------------\n#define INF 922337203685477580\n#define IINF (1<<21)\ntypedef long long ll;\n\n\n\nclass Rec {\npublic:\n  int x, y;\n  Rec() {}\n  Rec(int x, int y): x(x), y(y) {}\n\n  int area() {\n    return x * y;\n  }\n};\n\nRec dp[1430][1430];\n\n\nint check_x(int y, int from, int length) {\n  for (int i = from; i > from + length; i--) {\n    if (dp[y][i].area() == 0) return 0; // bad\n  }\n  return 1;\n}\nint check_y(int x, int from, int length) {\n  for (int i = from; i > from + length; i--) {\n    if (dp[i][x].area() == 0) return 0; // bad\n  }\n  return 1;\n}\n\nint main() {\n  int H, W;\n  cin >> H >> W;\n  // Rec dp[H][W];\n\n  REP(h, H) {\n    REP(w, W) {\n      int in;\n      cin >> in;\n\n      if (in) { // tainted\n        dp[h][w] = Rec(0, 0);\n      } else {\n        dp[h][w] = Rec(1, 1);\n      }\n    }\n  }\n\n  for (int h = 1; h < H; h++) {\n    for (int w = 1; w < W; w++) {\n      if (dp[h][w].x == 0 && dp[h][w].y == 0) continue;\n\n      if (dp[h - 1][w].x * (dp[h - 1][w].y + 1) > dp[h][w].area() && check_x(h, w, dp[h - 1][w].x)) {  // check possiblility\n        dp[h][w].x = dp[h - 1][w].x;\n        dp[h][w].y = dp[h - 1][w].y + 1;\n      }\n      if ((dp[h][w - 1].x + 1) * dp[h][w - 1].y > dp[h][w].area() && check_y(w, h, dp[h][w - 1].y)) {  // check possiblility\n        dp[h][w].x = dp[h][w - 1].x + 1;\n        dp[h][w].y = dp[h][w - 1].y;\n      }\n      if ((dp[h - 1][w - 1].x + 1) * (dp[h - 1][w - 1].y + 1) > dp[h][w].area() && check_x(h, w, dp[h - 1][w].x) && check_y(w, h, dp[h][w - 1].y)) {  // check possiblility\n        dp[h][w].x = dp[h - 1][w - 1].x + 1;\n        dp[h][w].y = dp[h - 1][w - 1].y + 1;\n      }\n    }\n  }\n\n  int mx = -1;\n  REP(h, H) {\n    REP(w, W) {\n      mx = max(mx, dp[h][w].area());\n    }\n  }\n\n  cout << mx << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nsize_t get_largest_rectangle(vector<vector<int>> &g) {\n    size_t h=g.size(), w=g[0].size();\n\n    vector<vector<size_t>> dp(h, vector<size_t>(w+1));\n    size_t max_area=0;\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j) {\n            dp[i][j] = !g[i][j];\n            max_area |= dp[i][j];\n        }\n\n    for (size_t i=1; i<h; ++i)\n        for (size_t j=0; j<w; ++j)\n            if (dp[i][j])\n                dp[i][j] += dp[i-1][j];\n\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j) {\n            if (!dp[i][j]) continue;\n\n            size_t min_height=dp[i][j];\n            for (size_t k=j+1; k<=w; ++k) {\n                max_area = max(max_area, (k-j)*min_height);\n                if (!dp[i][k])\n                    break;\n\n                if (min_height > dp[i][k])\n                    min_height = dp[i][k];\n            }\n        }\n\n    return max_area;\n}\n\nint main() {\n    size_t h, w;\n    scanf(\"%zu %zu\", &h, &w);\n\n    vector<vector<int>> g(h, vector<int>(w));\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j)\n            scanf(\"%d\", &g[i][j]);\n\n    printf(\"%zu\\n\", get_largest_rectangle(g));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<algorithm>\n#include<stack>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define INF INT_MAX/3\n#define PII pair<int,int>\n#define MPII(a,b) make_pair((a),(b))\n\nint M[1400][1400];\nint dp[1400][1401] = {};\n\nint main()\n{\n\tint ans = 0;\n\tint H, W;\n\tcin >> H >> W;\n\tREP(i, H)REP(j, W)cin >> M[i][j];\n\tREP(j, W)if (M[0][j] == 0)dp[0][j] = 1;\n\tFOR(i, 1, H)REP(j, W)if (M[i][j] == 0)dp[i][j] = dp[i - 1][j] + 1;\n\tREP(i, H)\n\t{\n\t\tstack<PII> stk;\n\t\tREP(j, W + 1)\n\t\t{\n\t\t\tif (stk.empty() || stk.top().second < dp[i][j])\n\t\t\t{\n\t\t\t\tstk.push(MPII(j, dp[i][j]));\n\t\t\t}\n\t\t\telse if (stk.top().second > dp[i][j])\n\t\t\t{\n\t\t\t\twhile (stk.top().second > dp[i][j])\n\t\t\t\t{\n\t\t\t\t\tint rect = (j - stk.top().first)*stk.top().second;\n\t\t\t\t\tans = max(ans, rect);\n\t\t\t\t\tstk.pop();\n\t\t\t\t\tif (stk.empty())break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define repr(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n#define reprrev(i,a,b) for(int i=b-1;i>=a;i--) // [a, b)\n#define reprev(i,n) reprrev(i,0,n)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return true; } return false; }\n\n/* attention\n    long longのシフト演算には気をつけよう\n    タイポした時のデバッグが死ぬほどきつくなるので変数名は最低3字くらい使った方がいいかも\n    sizeは(int)とキャストしよう\n    cin.tie(0);\n    ios::sync_with_stdio(false);<- これら、printfとかと併用しない方が良さそう\n\n*/\n\nconst ll mod = 1e9+7;\n\nvoid chmod(ll &M){\n    if(M >= mod) M %= mod;\n    else if(M < 0){\n        M += (abs(M)/mod + 1)*mod;\n        M %= mod;\n    }\n}\n\nll modpow(ll x, ll n){\n    if(n==0) return 1;\n    ll res=modpow(x, n/2);\n\n    if(n%2==0) return res*res%mod;\n    else return res*res%mod*x%mod;\n}\n\nint getl(int i, int N) { return i==0? N-1:i-1; };\nint getr(int i, int N) { return i==N-1? 0:i+1; };\n\n\n// 線分 ab の偏角 返り値は[-π, π]\ndouble argument(const pair<double, double> &a, const pair<double, double> &b){\n    double ax=a.first, ay=a.second, bx=b.first, by=b.second;\n    return atan2(by-ay, bx-ax);\n}\n\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n/* <-----------------------------------------------------------------------------------> */\n\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    int H, W; std::cin >> H >> W;\n    std::vector<std::vector<int>> fi(H+5, std::vector<int>(W+5, 1)), dp(H+5, std::vector<int>(W+5, 0));\n    repr(i, 1, H+1) repr(j, 1, W+1) {\n        std::cin >> fi[i][j];\n        if (fi[i][j]) dp[i][j] = 0;\n        else dp[i][j] = dp[i-1][j]+1;\n    }\n\n    int ans = 0;\n    repr(i, 1, H+1) {\n        stack<pair<int, int>> st;\n        repr(j, 1, W+2) {\n            if (st.empty()) { st.push(make_pair(j, dp[i][j])); }\n            else if (st.top().second < dp[i][j]) { st.push(make_pair(j, dp[i][j])); }\n            else if (st.top().second > dp[i][j]) {\n                int pos;\n                while(!st.empty() && st.top().second > dp[i][j]) {\n                    auto p = st.top(); st.pop();\n                    chmax(ans, p.second*(j-p.first));\n                    pos = p.first;\n                }\n                st.push(make_pair(pos, dp[i][j]));\n            }\n        }\n    }\n    std::cout << ans << std::endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)   FOR(i,0,n)\n#define ALL(obj)   (obj).begin(),(obj).end()\n\n#define debug(var)  do{std::cout << __LINE__ << \"> \" << #var << \": \";view(var);}while(0)\ntemplate<typename T> void view(T e){std::cout << e << std::endl;}\ntemplate<typename T> void view(const std::vector<T>& v){for(const auto& e : v){ std::cout << e << \" \"; } std::cout << std::endl;}\ntemplate<typename T> void view(const std::vector<std::vector<T> >& vv){ for(const auto& v : vv){ view(v); } }\n\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\n\nll histogram(vi h, int N) {\n\tstack<pair<int, int>> st;\n\tll res = 0;\n\tREP(i,N) {\n\t\tif (st.empty()) {\n\t\t\tst.push(make_pair(h[i], i));\n\t\t} else {\n\t\t\tif (st.top().first < h[i]) {\n\t\t\t\tst.push(make_pair(h[i], i));\n\t\t\t} else if (st.top().first > h[i]) {\n\t\t\t\tint last_idx;\n\t\t\t\twhile (!st.empty()) {\n\t\t\t\t\tif (st.top().first >= h[i]) {\n\t\t\t\t\t\tauto _top = st.top(); st.pop();\n\t\t\t\t\t\tres = max(res, (ll)_top.first * (i - _top.second));\n\t\t\t\t\t\tlast_idx = _top.second;\n\t\t\t\t\t} else break;\n\t\t\t\t}\n\t\t\t\tst.push(make_pair(h[i], last_idx));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nvoid Main() {\n\tint H, W; cin >> H >> W;\n\tvvi c(H, vi(W));\n\tREP(i,H) REP(j,W) {\n\t\tcin >> c[i][j];\n\t}\n\tvvi h(H, vi(W + 1));\n\tREP(i,H) REP(j,W + 1) {\n\t\tif (j == W) {\n\t\t\th[i][j] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (c[i][j] == 1) {\n\t\t\th[i][j] = 0;\n\t\t\tcontinue;\n\t\t}\n\t\tif (i == 0) {\n\t\t\th[i][j] = 1;\n\t\t\tcontinue;\n\t\t}\n\t\th[i][j] = h[i - 1][j] + 1;\n\t}\n\tlong long res = 0;\n\tREP(i,H) {\n\t\tres = max(res, histogram(h[i], W + 1));\n\t}\n\tcout << res << endl;\n}\n\nint main() {\n    cin.tie(nullptr);\n\tios_base::sync_with_stdio(false);\n\tcout << fixed << setprecision(15);\n\tMain();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n\nusing namespace std;\n\nint main()\n{\n\tint H, W;\n\tcin >> H >> W;\n\n\tvector<vector<int>> map;\n\tfor(int i = 0; i < H; i++)\n\t{\n\t\tvector<int> line;\n\t\tfor(int j = 0; j < W  + 1; j++)\n\t\t{\n\t\t\tif(j == W)\n\t\t\t{\n\t\t\t\tline.push_back(0);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tint state;\n\t\t\tcin >> state;\n\t\t\tline.push_back(state == 0 ? 1 : 0);\n\t\t}\n\t\tmap.push_back(line);\n\t}\n\n\tfor(int i = 0; i < H-1; i++)\n\t{\n\t\tfor(int j = 0; j < W; j++)\n\t\t{\n\t\t\tif(map[i + 1][j] != 0)\n\t\t\t{\n\t\t\t\tmap[i + 1][j] += map[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tint maxValue = 0;\n\tfor(int i = 0; i < H; i++)\n\t{\n\t\tfor(int j = 0; j < W; j++)\n\t\t{\n\t\t\tint minHight = map[i][j];\n\t\t\t\n\t\t\tfor(int k = j; ; k++)\n\t\t\t{\n\t\t\t\tminHight = minHight < map[i][k] ? minHight : map[i][k];\n\t\t\t\tif(map[i][k] == 0)\n\t\t\t\t{\n\t\t\t\t\tint buf = k-j+1 * minHight;\n\t\t\t\t\tmaxValue = maxValue > buf ? maxValue : buf;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxValue << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n\tRectangle rect;\n\tfor(int i=0;i<x;i++){\n\t\tstack<Rectangle> stk;\n\t\t//rect.height = 0;\n\t\t//rect.pos = 0;\n\t\t//stk.push(rect);\n\t\tint pop=0;\n\t\tfor(int j=0;j<=y;j++){\n\t\t\trect.height = m[j][i];\n\t\t\trect.pos = j;\n\t\t\tif(stk.empty() || stk.top().height < rect.height){\n\t\t\t\tstk.push(rect);\n\t\t\t}else{\n\t\t\t\t//printf(\"[-] %d %d\\n\",i,j);\n\t\t\t\tfor(;!stk.empty() && stk.top().height >= rect.height;){\n\t\t\t\t\tpop++;\n\t\t\t\t\tRectangle pre = stk.top(); stk.pop();\n\t\t\t\t\t//pre.pos=stk\n\t\t\t\t\tint area = pre.height * (j - pre.pos);\n\t\t\t\t\tr = max(r, area);\n\t\t\t\t\t//printf(\"%d %d\\n\",target,pre.pos);\n\t\t\t\t\trect.pos = pre.pos;\n\t\t\t\t}\n\t\t\t\tstk.push(rect);\n\t\t\t}\n\t\t\tif(rect.height==0)pop=0;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <stack>\nusing namespace std;\nconst int num = 140;\nstruct Rectangle {\n\tint he, p;\n};\ninline int lr(int w, int bf[]) {\n\tbf[w] = 0;\n\tstack<Rectangle> s;\n\tint maxv = 0, area = 0;\n\tfor (int i = 0; i <= w; i++) {\n\t\tRectangle rect;\n\t\trect.he = bf[i];\n\t\trect.p = i;\n\t\tif (s.empty()) s.push(rect);\n\t\telse if (s.top().he < rect.he) s.push(rect);\n\t\telse if (s.top().he > rect.he) {\n\t\t\twhile (!s.empty() && s.top().he >= rect.he) {\n\t\t\t\tRectangle pr = s.top();\n\t\t\t\trect.p = pr.p;\n\t\t\t\ts.pop();\n\t\t\t\tarea = (i - pr.p)*pr.he;\n\t\t\t\tmaxv = max(area, maxv);\n\t\t\t}\n\t\t\ts.push(rect);\n\t\t}\n\t}\n\treturn maxv;\n}\nint main() {\n\tint h, w, x;\n\tcin >> h >> w;\n\tint H[num][num], dp[num][num];\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tcin >> x;\n\t\t\tif (x) dp[i][j] = 0;\n\t\t}\n\t}\n\tfor (int i = 0; i < w; i++) {\n\t\tfor (int j = 0; j < h; j++) {\n\t\t\tif (!dp[j][i]) H[j][i] = 0;\n\t\t\telse H[j][i] = (j > 0) ? H[j - 1][i] + 1 : 1;\n\t\t}\n\t}\n\tint maxv = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tmaxv = max(maxv, lr(w, H[i]));\n\t}\n\tcout << maxv << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\nusing namespace std;\nstatic const int HMAX = 1401;\nstatic const int WMAX = 1401;\n\nint tiles[HMAX][WMAX] = {0};\n\nvoid print_tiles(int h, int w) {\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      cout << tiles[i][j] << \" \";\n    }\n    cout << endl;\n  }\n}\n\n// side-effects (to tiles)\nint leargest_square(int height, int width, int ans_init) {\n  int ans = ans_init;\n  for (int i = 1; i < height; i++) {\n    for (int j = 1; j < width; j++) {\n      if (tiles[i][j] != 0) {\n        tiles[i][j] =\n            min({tiles[i - 1][j], tiles[i][j - 1], tiles[i - 1][j - 1]}) + 1;\n        ans = max(ans, tiles[i][j]);\n      }\n    }\n  }\n  return ans * ans;\n}\n\nstruct Rect {\n  int height;\n  int left;\n};\n\n// side-effects (to tiles)\nint leargest_rectanble(int height, int width) {\n  // mkae histgrams\n  for (int i = 1; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      if (tiles[i][j] != 0) {\n        tiles[i][j] = tiles[i - 1][j] + 1;\n      }\n    }\n  }\n\n  int maxsize = 0;\n  stack<Rect> st;\n  for (int i = 0; i < height; i++) {\n    // calc the rectangle size of the i-th histgram\n    tiles[i][width] = 0; // sentinel\n    for (int j = 0; j < width + 1; j++) {\n      auto rect = Rect{tiles[i][j], j};\n      if (st.empty()) {\n        st.push(rect);\n      } else if (st.top().height < rect.height) {\n        st.push(rect);\n      } else if (st.top().height > rect.height) {\n        Rect r;\n        while (!st.empty()) {\n          r = st.top();\n          if (r.height <= rect.height)\n            break;\n          int size = r.height * (rect.left - r.left);\n          maxsize = max(size, maxsize);\n          st.pop();\n        }\n        if (r.height < rect.height) {\n          st.push(rect);\n        }\n      }\n    }\n  }\n\n  return maxsize;\n}\n\n#define BLOCK 1\nint main() {\n  int height, width;\n  int ans_init = 0;\n  cin >> height >> width;\n  for (int i = 0; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      int tmp;\n      cin >> tmp;\n      tiles[i][j] = tmp == BLOCK ? 0 : 1;\n      ans_init = max(ans_init, tiles[i][j]);\n    }\n  }\n  cout << leargest_rectanble(height, width) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nstruct rect {\n    int pos, height;\n};\n\nint main() {\n\n    int H, W;\n    cin >> H >> W;\n\n    int T[H][W];\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int c;\n            cin >> c;\n            if (i == 0) {\n                T[i][j] = (c ? 0 : 1);\n            } else {\n                T[i][j] = (c ? 0 : T[i - 1][j] + 1);\n            }\n        }\n    }\n\n    //solve\n    int ans = 0;\n\n    for (int i = 0; i < H; i++) {\n        stack<rect> stk;\n        for (int j = 0; j < W; j++) {\n            int pos, height;\n            pos = j, height = T[i][j];\n            if (stk.empty() || stk.top().height < height) {\n                stk.push((rect) {pos, height});\n            } else if (stk.top().height > height) {\n                while (!stk.empty() && stk.top().height >= height) {\n                    rect &pre = stk.top();\n                    stk.pop();\n                    ans = max(ans, pre.height * (j - pre.pos));\n                    pos = pre.pos;\n                }\n                stk.push((rect) {pos, height});\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<stack>\nusing namespace std;\n\nstruct Rect{\n\tint height;\n\tint pos;\n};\n\nint HistgramRectangle(vector<int> &hist){\n\thist.push_back(0);\n\tint n=hist.size();\n\tstack<Rect> st;\n\tRect tmp_rect, past_rect;\n\tint Max=0;\n\n\tfor (int i=0;i<n;i++){\n\t\ttmp_rect.height=hist[i];\n\t\ttmp_rect.pos=i;\n\n\t\tif(st.empty()){\n\t\t\tst.push(tmp_rect);\n\t\t}else{\n\t\t\tif(st.top().height < hist[i]){\n\t\t\t\tst.push(tmp_rect);\n\t\t\t}else if(st.top().height > hist[i]){\n\t\t\t\tint stp = i;\n\t\t\t\twhile(st.top().height >= hist[i] && !st.empty()){\n\t\t\t\t\tpast_rect = st.top();\n\t\t\t\t\tst.pop();\n\t\t\t\t\tMax=max(Max, past_rect.height * (i-past_rect.pos));\n\t\t\t\t\tstp = past_rect.pos;\n\t\t\t\t\tif(st.empty()){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttmp_rect.pos = stp;\n\t\t\t\tst.push(tmp_rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn Max;\n}\n\nint main(){\n\tint H,W,tmp,result=0;\n\tcin >> H >> W;\n\tvector<int> hist(W);\n\n\tfor (int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tcin >> tmp;\n\t\t\tif(tmp==1){\n\t\t\t\thist[j] = 0; \n\t\t\t}else{\n\t\t\t\thist[j]+=1;\n\t\t\t}\n\t\t}\n\t\tresult = max(HistgramRectangle(hist),result);\n\t}\n\tcout << result << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct cww{cww(){ios::sync_with_stdio(false);cin.tie(0);}}star;\n#define P(x) cout << (x) << \"\\n\"\n#define p(x) cout << (x)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define vv(type, c, m, n, i) vector<vector<type>> c(m, vector<type>(n, i));\n#define rep(i,a,n) for(int i=(a), i##_len=(n); i<i##_len; ++i)\n#define rrep(i,a,n) for(int i=(a), i##_len=(n); i>i##_len; --i)\n#define len(x) ((int)(x).size())\n#define mp make_pair\n#define eb emplace_back\n#define fi first\n#define se second\n#define chmax(a,b) if(a<b)a=b;\n#define chmin(a,b) if(b<a)a=b;\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<double> vd;\ntypedef vector<long long> vll;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef pair<int, int> pii;\nvector<pii> st;\nvoid getLargestRectangle() {\n\tint H, W; cin >> H >> W;\n\tvv(int, v, H, W, 0);\n\tint x;\n\trep(i, 0, H) rep(j, 0, W) {\n\t\tcin >> x;\n\t\tv[i][j] = !x;\n\t}\n\trep(i, 0, H - 1) rep(j, 0, W) if(v[i + 1][j] != 0) v[i + 1][j] += v[i][j];\n\tint ans = 0, pos;\n\trep(i, 0, H) {\n\t\tst.clear();\n\t\tst.eb(0, 0);\n\t\trep(j, 0, W) {\n\t\t\tif (st.back().fi == v[i][j]) continue;\n\t\t\tpos = j;\n\t\t\twhile (st.back().fi > v[i][j]) {\n\t\t\t\tchmax(ans, st.back().fi * (j - st.back().se));\n\t\t\t\tpos = st.back().se; st.pop_back();\n\t\t\t}\n\t\t\tst.eb(v[i][j], pos);\n\t\t}\n\t\twhile (!st.empty()) {\n\t\t\tchmax(ans, st.back().fi * (W - st.back().se));\n\t\t\tst.pop_back();\n\t\t}\n\t}\n\tP(ans);\n}\nint main() {\n\tgetLargestRectangle();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nstruct elem {\n\tint pos, height;\n};\n\nint getArea(int V[], int W) {\n\tint area = 0;\n\tstack<elem> S;\n\tfor (int i = 0; i <= W; ++i) {\n\t\telem e;\n\t\te.pos = i;\n\t\tif (i == W) {\n\t\t\te.height = 0;\n\t\t} else {\n\t\t\te.height = V[i];\n\t\t}\n\t\tif (S.empty()) {\n\t\t\tS.push(e);\n\t\t} else {\n\t\t\tif (S.top().height > e.height) {\n\t\t\t\tint prepos = i;\n\t\t\t\twhile (!S.empty() && S.top().height > e.height) {\n\t\t\t\t\telem target = S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tarea = max(area, (i - target.pos) * target.height);\n\t\t\t\t}\n\t\t\t\te.pos = prepos;\n\t\t\t\tS.push(e);\n\t\t\t}\n\t\t}\n\t}\n\treturn area;\n}\nint main() {\n\tint H, W;\n\tscanf(\"%d %d\", &H, &W);\n\tint A[H][W];\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tscanf(\"%d\", &A[i][j]);\n\t\t}\n\t}\n\n\tint V[H][W];\n\tfor (int j = 0; j < W; ++j) {\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tif (A[i][j] == 1) {\n\t\t\t\tV[i][j] = 0;\n\t\t\t} else {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tV[i][j] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tV[i][j] = V[i - 1][j] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint maxv = 0;\n\tfor (int i = 0; i < H; ++i) {\n\t\tmaxv = max(maxv, getArea(V[i], W));\n\t}\n\tcout << maxv << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \nusing lint=long long;\n\ntemplate<typename T> T LargestRectangle(vector<T>& h)\n{\n   // be careful not to overflow\n   int N=h.size();\n   vector<int> l(N),r(N);\n   stack<int> S;\n   for(int i=0;i<N;i++){\n      while(!S.empty() and h[S.top()]>=h[i]) S.pop();\n      l[i]=(S.empty()? 0:S.top()+1); S.push(i);\n   }\n   S=stack<int>();\n   for(int i=N-1;i>=0;i--){\n      while(!S.empty() and h[S.top()]>=h[i]) S.pop();\n      r[i]=(S.empty()? N:S.top()); S.push(i);\n   }\n   T res=0;\n   for(int i=0;i<N;i++) res=max(res,h[i]*(r[i]-l[i]));\n   return res;\n}\n\nint main()\n{\n   int H,W; cin>>H>>W;\n   vector<vector<int>> c(H,vector<int>(W));\n   for(int i=0;i<H;i++) for(int j=0;j<W;j++) cin>>c[i][j];\n\n   vector<vector<int>> cntU(H,vector<int>(W));\n   for(int j=0;j<W;j++){\n      int cnt=0;\n      for(int i=0;i<H;i++){\n         if(c[i][j]) cnt=0; else cnt++;\n         cntU[i][j]=cnt;\n      }\n   }\n   int ans=0;\n   for(int i=0;i<H;i++) ans=max(ans,LargestRectangle(cntU[i]));\n   cout<<ans<<endl;\n   return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <utility>\n#include <set>\n#include <map>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <algorithm>\nusing namespace std;\ntypedef long double ld;\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<double, double> pdd;\n#define rep(i,n)\tfor(int i=0;i<n;i++)\n#define srep(i,a,n)\tfor(int i=a;i<n;i++)\n#define REP(i,n)\tfor(int i=0;i<=n;i++)\n#define SREP(i,a,n)\tfor(int i=a;i<=n;i++)\n#define rrep(i,n)\tfor(int i=n-1;i>=0;i--)\n#define all(a)\t(a).begin(),(a).end()\n#define mp(a,b)\tmake_pair(a,b)\n#define fst\tfirst\n#define scn second\n\nconst ll inf = (ll)1e18;\nconst ll mod = (ll)1e9 + 7;\nconst ld eps = 1e-9;\n\nint main() {\n\tint h = 0, w = 0;\tcin >> h >> w;\n\tvector<vint> a(h, vint(w, 0));\n\trep(i, h)\trep(j, w)\tcin >> a[i][j];\n\tvint depth(w, 0);\n\trep(i, w)\tdepth[i] = a[0][i]^1;\n\tint ret = 0;\n\tint tmp = 0;\n\trep(i, w) {\n\t\tif (a[0][i] == 0)\ttmp++;\n\t\telse {\n\t\t\tret = max(ret, tmp);\n\t\t\ttmp = 0;\n\t\t}\n\t}\n\tret = max(ret, tmp);\n\tsrep(i, 1, h) {\n\t\t//depth?????´??°\n\t\trep(j, w) {\n\t\t\tif (a[i][j] == 0)\tdepth[j]++;\n\t\t\telse\tdepth[j] = 0;\n\t\t}\n\t\t//????????????(??????????????£??????????????????)??§?????§?????¢???????????????\n\t\tstack<pii> s;\n\t\ts.push(mp(0, 0));\n\t\trep(j, w) {\n\t\t\tint to = j;\n\t\t\twhile (!s.empty()&&s.top().fst >= depth[j]) {\n\t\t\t\tret = max(ret, (j - s.top().scn)*s.top().fst);\n\t\t\t\tto = s.top().scn;\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t\ts.push(mp(depth[j], to));\n\t\t}\n\t\twhile (!s.empty()) {\n\t\t\tret = max(ret, (w - s.top().scn)*s.top().fst);\n\t\t\ts.pop();\n\t\t}\n\t}\n\tcout << ret << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\n#include<algorithm>\n#include<stack>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define INF INT_MAX/3\n#define PII pair<int,int>\n#define MPII(a,b) make_pair((a),(b))\n\nint M[1400][1400];\nint dp[1400][1401] = {};\n\nint main()\n{\n\tint ans = 0;\n\tint H, W;\n\tcin >> H >> W;\n\tREP(i, H)REP(j, W)cin >> M[i][j];\n\tREP(j, W)if (M[0][j] == 0)dp[0][j] = 1;\n\tFOR(i, 1, H)REP(j, W)if (M[i][j] == 0)dp[i][j] = dp[i - 1][j] + 1;\n\tREP(i, H)\n\t{\n\t\tstack<PII> stk;\n\t\tREP(j, W + 1)\n\t\t{\n\t\t\tif (stk.empty() || stk.top().second < dp[i][j])\n\t\t\t{\n\t\t\t\tstk.push(MPII(j, dp[i][j]));\n\t\t\t}\n\t\t\telse if (stk.top().second > dp[i][j])\n\t\t\t{\n\t\t\t\tint temp;\n\t\t\t\twhile (stk.top().second > dp[i][j])\n\t\t\t\t{\n\t\t\t\t\tint rect = (j - stk.top().first)*stk.top().second;\n\t\t\t\t\tans = max(ans, rect);\n\t\t\t\t\ttemp = stk.top().first;\n\t\t\t\t\tstk.pop();\n\t\t\t\t\tif (stk.empty())break;\n\t\t\t\t}\n\t\t\t\tstk.push(MPII(temp, dp[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF 1 << 29\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntypedef complex<double> dcomplex;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cerr<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\nll fact(ll a){ll b=1;FOR(i,1,a)b*=i;return b;}\n\nstruct Rect {int h; int pos;};\n\nint solve(vector<int> v)\n{\n  stack<Rect> S;\n  v.push_back(0);\n  int ans = 0;\n  FOR(i,0,v.size())\n  {\n    Rect rect;\n    rect.h = v[i];\n    rect.pos = i;\n    if(S.empty()) S.push(rect);\n    else\n    {\n      if(S.top().h < rect.h) S.push(rect);\n      else if(S.top().h > rect.h)\n      {\n        int t = i;\n        while(!S.empty() && S.top().h >= rect.h)\n        {\n          Rect pre = S.top(); S.pop();\n          int area = pre.h * (i-pre.pos);\n          ans = max(ans,area);\n          t = pre.pos;\n        }\n        rect.pos = t;\n        S.push(rect);\n      }\n    }\n  }\n  return ans;\n}\n\nint main()\n{\n  int ans = 0;\n  int h,w; cin>>h>>w;\n  vector<vector<int> > T(h,vector<int>(w,0));\n  vector<vector<int> > U(h,vector<int>(w,0));\n  REP(i,h) REP(j,w)\n  {\n    int t; cin >> t;\n    T[i][j] = (t+1)%2;\n  }\n  REP(i,w) U[0][i] = T[0][i];\n  FOR(i,1,h-1) REP(j,w) U[i][j] = T[i][j] ? U[i-1][j]+1 : 0;\n  REP(i,h) ans = max(ans,solve(U[i]));\n  cout << ans << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define ALL(a) (a).begin(),(a).end()\n#define RFOR(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define REP(i,n) for (int i=0;i<(n);i++)\n#define RREP(i,n) for (int i=(n)-1;i>=0;i--)\n#define ll long long\n#define ull unsigned long long\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nusing namespace std;\nstruct po{int x,y,is_tile;};\n\nint main(){\n  int H,W;\n  cin >> H >> W;\n  vector<vector<po>> dp(H+1,vector<po>(W+1));\n  REP(i,1)\n    REP(j,1){\n      dp[i][j].is_tile = 0;\n      dp[i][j].x = 0;\n      dp[i][j].y = 0;\n  }\n  \n  REP(i,H)\n    REP(j,W)\n    cin >> dp[i+1][j+1].is_tile;\n\n  int max_rectangle = 0;\n  REP(i,H){\n    REP(j,W){\n      if(dp[i+1][j+1].is_tile == 0){\n\tif(dp[i][j].x >= dp[i+1][j].x && dp[i][j].y >= dp[i][j+1].y){\n\t  dp[i+1][j+1].x = dp[i+1][j].x + 1;\n\t  dp[i+1][j+1].y = dp[i][j+1].y + 1;\n\t}else if(dp[i+1][j].x+1 < dp[i][j+1].y+1){\n\t  if( (dp[i][j].y+1)*(dp[i][j].x+1) > dp[i][j+1].y+1){\n\t    dp[i+1][j+1].x = dp[i][j].x + 1;\n\t    dp[i+1][j+1].y = dp[i][j].y + 1;\n\t  \n\t  }else{\n\t    dp[i+1][j+1].y = dp[i][j+1].y + 1;\n\t    dp[i+1][j+1].x = 1;\n \n\t  }\n\t}else{\n\t  if( (dp[i][j].y+1)*(dp[i][j].x+1) > dp[i+1][j].x+1){\n\t    dp[i+1][j+1].x = dp[i][j].x + 1;\n\t    dp[i+1][j+1].y = dp[i][j].y + 1;\n\t   \n\t  }else{\n\t    dp[i+1][j+1].x = dp[i+1][j].x + 1;\n\t    dp[i+1][j+1].y = 1;\n\n\t  }\n\t}\n      }else{\n\tdp[i+1][j+1].x = 0;\n\tdp[i+1][j+1].y = 0;\n      }\n      max_rectangle = max(max_rectangle,dp[i+1][j+1].x * dp[i+1][j+1].y);\n      //      cout << \"(\" <<dp[i+1][j+1].x << \",\" << dp[i+1][j+1].y << \") \";\n    }\n    cout << endl;\n  }\n  REP(i,H+1){\n    REP(j,W+1){\n\n    }\n    \n  }\n\n  cout << max_rectangle << endl;\n\t\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nconst int MAX = 1400;\n\nint main() {\n\tint H, W;\n\tint tile[MAX][MAX];\n\tint ans = 0;\n\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tscanf(\"%d\", &tile[i][j]);\n\t\t}\n\t}\n\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = W - 1; x >= 0; x--) {\n\t\t\tif (tile[y][x] == 1)tile[y][x] = 0;\n\t\t\telse if (x == W - 1)tile[y][x] = 1;\n\t\t\telse tile[y][x] = tile[y][x + 1] + 1;\n\t\t}\n\t}\n\n\tfor (int x = 0; x < W; x++) {\n\t\tstack<pair<int, int>> s;\n\t\ts.push(pair<int, int>(-1, -1));\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tif (s.top().second < tile[y][x]) {\n\t\t\t\ts.push(pair<int, int>(y, tile[y][x]));\n\t\t\t}\n\t\t\telse if (s.top().second > tile[y][x]) {\n\t\t\t\tint m = y;\n\t\t\t\tint t = s.top().second;\n\t\t\t\twhile (s.top().second > tile[y][x]) {\n\t\t\t\t\tans = max(ans, (y - s.top().first) * s.top().second);\n\t\t\t\t\tm = min(m, s.top().first);\n\t\t\t\t\ts.pop();\n\t\t\t\t}\n\t\t\t\tif (s.top().second != tile[y][x]) s.push(pair<int, int>(m, tile[y][x]));\n\t\t\t}\n\t\t}\n\t\twhile (!s.empty()) {\n\t\t\tans = max(ans, (H - s.top().first) * s.top().second);\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint H, W;\n\tcin >> H >> W;\n\tvector<vector<int>> c(H, vector<int>(W + 1, 1));\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> c[i][j];\n\t\t}\n\t}\n\tvector<vector<int>> dp(H + 1, vector<int>(W + 1));\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W + 1; j++) {\n\t\t\tif (c[i][j]) {\n\t\t\t\tdp[i + 1][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i + 1][j] = dp[i][j] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tvector<int> st(1, 0), p(1, -1);\n\t\tfor (int j = 0; j <= W; j++) {\n\t\t\twhile (st.back() > dp[i + 1][j]) {\n\t\t\t\tres = max(res, st.back() * (j - p.back()));\n\t\t\t\tst.pop_back();\n\t\t\t\tp.pop_back();\n\t\t\t}\n\t\t\tif (st.back() < dp[i + 1][j]) {\n\t\t\t\tst.push_back(dp[i + 1][j]);\n\t\t\t\tp.push_back(j);\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define LF '\\n'\n#define ALL(x) x.begin(), x.end()\n#define iostreamBooster() do{ cin.tie(nullptr); ios_base::sync_with_stdio(false); }while(0)\nusing namespace std;\ntypedef int64_t i64;\ntypedef pair<int,int> pii;\ntemplate<class A, class B>inline bool chmax(A &a, const B &b){return b>a ? a=b,1 : 0;}\ntemplate<class A, class B>inline bool chmin(A &a, const B &b){return b<a ? a=b,1 : 0;}\nconstexpr int INF = 0x3f3f3f3f;\ntemplate<class Itr> void dump(Itr begin, Itr end) { for (;begin != end; ++begin) clog << *begin << ' '; clog << LF;}\n\nstruct Rect { int height, left; Rect(int h=0, int l=0): height(h), left(l) {} };\nint H, W;\nint mat[1500][1500];\nint dp[1500][1500];\n\nint slv(const int *bar)\n{\n  stack<Rect> s;\n  s.emplace(-1, -1);\n\n  int largest = 0;\n  for(int i = 0; i <= W; ++i) {\n    const int h = bar[i];\n\n    if(s.top().height < h) {\n      s.emplace(h, i);\n    }\n    else if (s.top().height > h) {\n      Rect r;\n      while(s.top().height >= h) {\n        r = s.top(); s.pop();\n        chmax(largest, (i - r.left) * r.height);\n      }\n      s.emplace(h, r.left);\n    }\n  }\n\n  return largest;\n}\n\nsigned main()\n{\n  cin >> H >> W;\n  for (int i = 0; i < H; ++i) {\n    for(int j = 0; j < W; ++j) {\n      cin >> mat[i][j];\n      mat[i][j] = 1 - mat[i][j];\n    }\n  }\n\n  int ans = 0;\n  for (int i = H-1; i >= 0; --i) {\n    for (int j = 0; j < W; ++j) {\n      if (mat[i][j]) mat[i][j] += mat[i+1][j];\n    }\n    chmax(ans, slv(mat[i]));\n  }\n\n  cout << ans << endl;\n\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 1400;\n\nint a[MAX_N][MAX_N];\nint t[MAX_N][MAX_N];\ndeque<P> deq;\n\nint main()\n{\n\tint h,w;\n\tcin >> h >> w;\n\tint ans=0;\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t}\n\t}\n\trep(i,h){\n\t\tt[i][w] = 0;\n\t}\n\trep(j,w){\n\t\tt[0][j] = 1^a[0][j];\n\t}\n\tfor(int i=1;i<h;i++){\n\t\trep(j,w){\n\t\t\tif(a[i][j]==0){\n\t\t\t\tt[i][j] = t[i-1][j] + 1;\n\t\t\t}else{\n\t\t\t\tt[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tcout << t[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\tint pos;\n\trep(i,h){\n\t\trep(j,w+1){\n\t\t\tif(deq.empty()){\n\t\t\t\tdeq.push_back(P(t[i][j],j));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdeque<P>::iterator it = deq.end()-1;\n\t\t\tif((*it).first < t[i][j]){\n\t\t\t\tdeq.push_back(P(t[i][j],j));\n\t\t\t}else if((*it).first > t[i][j]){\n\t\t\t\twhile(!deq.empty() && (*it).first > t[i][j]){\n\t\t\t\t\tint S = (*it).first*(j-(*it).second);\n\t\t\t\t\tpos = (*it).second;\n\t\t\t\t\tans = max(S,ans);\n\t\t\t\t\tdeq.pop_back();\n\t\t\t\t\tit = deq.end()-1;\n\t\t\t\t}\n\t\t\t\tdeq.push_back(P(t[i][j],pos));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\nconst int INF = 1<<28;\n#define MAX 1401\n\nint dp[MAX][MAX];\n\nint solve(int H, int W) {\n\tREP(j,W) {\n\t\tint v = 1;\n\t\tREP(i, H) {\n\t\t\tif(!dp[i][j])\n\t\t\t\tv = 0;\n\t\t\tdp[i][j] = v++;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tREP(i, H) {\n\t\tpair<int, int> p, p2;\n\t\tstack< pair<int, int> > s;\n\t\tREP(j, W) {\n\t\t\tp = make_pair(dp[i][j], j);\n\t\t\tif(s.empty())\n\t\t\t\ts.push(p);\n\t\t\telse {\n\t\t\t\tif(s.top().first < p.first)\n\t\t\t\t\ts.push(p);\n\t\t\t\telse if(s.top().first > p.first) {\n\t\t\t\t\twhile(!s.empty() && s.top().first >= p.first) {\n\t\t\t\t\t\tp2 = s.top(); s.pop();\n\t\t\t\t\t\tans = max(ans, p2.first * (j - p2.second));\n\t\t\t\t\t}\n\t\t\t\t\tp.second = p2.second;\n\t\t\t\t\ts.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tREP(i, H) REP(j,W) {\n\t\tcin >> dp[i][j];\n\t\tdp[i][j] = !dp[i][j];\n\t}\n\tcout << solve(H, W) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n\tRectangle rect;\n\tfor(int i=0;i<x;i++){\n\t\tstack<Rectangle> stk;\n\t\tfor(int j=0;j<=y;j++){\n\t\t\trect.height = m[j][i];\n\t\t\trect.pos = j;\n\t\t\tif(stk.empty() || stk.top().height < rect.height){\n\t\t\t\tstk.push(rect);\n\t\t\t}else{\n\t\t\t\tint target = j;\n\t\t\t\tfor(;!stk.empty() && stk.top().height >= rect.height;){\n\t\t\t\t\tRectangle pre = stk.top(); stk.pop();\n\t\t\t\t\tint area = pre.height * (j - pre.pos);\n\t\t\t\t\tr = max(r, area);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t\trect.pos--;\n\t\t\t\t}\n\t\t\t\t//rect.pos = target;\n\t\t\t\tstk.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//  Created by conan1024hao in 2019.\n//  Copyright © 2019 conan1024hao. All rights reserved.\n//  専用ライブラリです、自由にコピーして構いません。\n//  感谢看我的代码！Wechat:conan1024hao QQ:810396815\n#pragma GCC optimize (\"O3\")\n#include <iostream>\n#include <iomanip>\n#include <istream>\n#include <ostream>\n#include <sstream>\n#include <iterator>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <deque>\n#include <list>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <ctime>\n#include <cctype>\n#include <cstdlib>\n#define INF 10e16\n#define MOD 1000000007\n#define rep(i, a, n) for (ll i = a; i < (ll)(n); i++)\n#define fi first\n#define se second\n#define pb push_back\n#define mp make_pair\n#define eb emplace_back\n#define mmax(x,y)(x>y?x:y)\n#define mmin(x,y)(x<y?x:y)\n#define chmax(x,y) x=mmax(x,y)\n#define chmin(x,y) x=mmin(x,y)\n#define all(x) (x).begin(),(x).end()\n#define siz(x) (ll)(x).size()\n#define PI acos(-1.0)\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll>P;\nlong long GCD(long long a, long long b) { return b ? GCD(b, a%b) : a; }\nlong long LCM(long long a, long long b)  {return a/GCD(a,b)*b;}\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nll cmp(pair<ll,string>a,pair<ll,string> b){\n        if(a.fi!=b.fi)\n        return a.fi<b.fi;\n        else\n        return a.se<b.se;\n}\n\n//---------------------------------------------------------------------------\nint ca[1401][1401];\nint sa[1401][1401];//记录第i行地第j个对应的个数\nint h,w;\nint ans=0;\nvoid input(){\n    cin>>h>>w;\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            cin>>ca[i][j];\n        }\n    }\n}//ok\nvoid init(){\n    for(int i=0;i<w;i++)\n        sa[0][i]=ca[0][i] ? 0:1;\n    for(int j=0;j<w;j++){\n        for(int i=1;i<h;i++){\n            sa[i][j]=ca[i][j] ? 0: sa[i-1][j]+1;\n        }\n    }\n}//initiate\nvoid calculate(){\n    for(int i=0;i<h;i++){\n        stack<int>tmp;\n        int area=0,tp=-1,width=0;//area-面积 tp-top\n        for(int j=0;j<w;j++)\n        {\n            int height=sa[i][j];\n            while(!tmp.empty()&&sa[i][tmp.top()]>height){\n                tp=tmp.top();tmp.pop();\n                width=tmp.empty() ? j: j-tmp.top()-1;//rectangle*width\n                area=sa[i][tp]*width;\n                chmax(ans,area);\n            }\n            tmp.push(j);\n        }\n        int maxwidth=w;\n        while(!tmp.empty()){\n            tp=tmp.top();tmp.pop();\n            width=tmp.empty() ? maxwidth: maxwidth-tmp.top()-1;\n            area=sa[i][tp]*width;\n            chmax(ans,area);\n        }\n    }\n}\nvoid output(){\n    cout<<ans<<endl;\n}//ok\n//---------------------------------------------------------------------------\nint main(){//問題をちゃんと見ろ!!!!!!!!!!!!!!!!!      llか??????????\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    //-------------------------------\n    input();\n    init();\n    calculate();\n    output();\n    //-------------------------------\n    return 0;\n}\n//---------------------------------------------------------------------------\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <algorithm>\nusing namespace std;\n\nvoid ccp(vector<int>& c, int n, int m){\n  sort(c.begin(), c.end());\n  vector<vector<int> > t(m, vector<int>(n + 1));\n  for(int i = 0; i < m; i++){\n    t[i][0] = 0;\n  }\n  for(int j = 0; j <= n; j++){\n    t[0][j] = j;\n  }\n  for(int i = 1; i < m; i++){\n    for(int j = 0; j <= n; j++){\n      if(j - c[i] < 0) t[i][j] = t[i - 1][j];\n      else t[i][j] = min(t[i - 1][j], t[i][j - c[i]] + 1);\n    }\n  }\n  cout << t[m - 1][n] << endl;\n  return;\n}\n\nvoid kp(vector<int>& v, vector<int>& w, int N, int W){\n  vector<pair<int, int> > k(N);\n  for(int i = 0; i < N; i++){\n    k[i].second = v[i];\n    k[i].first = w[i];\n  }\n  sort(k.begin(), k.end());\n  vector<vector<int> > t(N, vector<int>(W + 1));\n  for(int i = 0; i < N; i++){\n    t[i][0] = 0;\n  }\n  for(int i = 0; i <= W; i++){\n    if(i >= k[0].first) t[0][i] = k[0].second;\n    else t[0][i] = 0;\n  }\n  for(int i = 1; i < N; i++){\n    for(int j = 0; j <= W; j++){\n      if(j - k[i].first < 0) t[i][j] = t[i - 1][j];\n      else t[i][j] = max(t[i - 1][j], t[i - 1][j - k[i].first] + k[i].second);\n    }\n  }\n  cout << t[N - 1][W] << endl;\n}\n\nvoid lis(vector<int>& a){\n  int n = a.size();\n  vector<int> l(n);\n  l[0] = a[0];\n  int lid = 1;\n  for(int i = 1; i < n; i++){\n    int x = a[i];\n    auto it = lower_bound(l.begin(), l.begin() + lid, x);\n    int pos = (int)(it - l.begin());\n    if(pos == lid){\n      l[lid++] = x;\n    }\n    else *it = x;\n    /*for(int i = 0; i < l.size(); i++){\n      cout << l[i] << \" \";\n    }\n    cout << endl;*/\n  }\n  cout << lid << endl;\n}\n\nvoid ls(vector<vector<int> >& c, vector<vector<int> > & dp, int h, int w){\n  int ans = 0;\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      if(dp[i][j] != -1) continue;\n      if(i >= 1) dp[i][j] = dp[i - 1][j];\n      if(j >= 1) dp[i][j] = min(dp[i][j],dp[i][j - 1]);\n      if(i >= 1 && j >= 1) dp[i][j] = min(dp[i][j], dp[i - 1][j - 1]);\n      dp[i][j]++;\n      dp[i][j] = min(dp[i][j], min(i, j) + 1);\n      if(dp[i][j] == 0) dp[i][j] = 1;\n      ans = max(ans, dp[i][j]);\n    }\n  }\n  cout << ans * ans << endl;\n}\n\nvoid solve(){\n  int h, w; cin >> h >> w;\n  vector<vector<int> > c(h, vector<int>(w));\n  vector<vector<int> > dp(h, vector<int>(w, 1));\n  for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      cin >> c[i][j];\n      if(c[i][j] == 1) dp[i][j] = 0;\n    }\n  }\n  for(int i = 1; i < h; i++){\n    for(int j = 0; j < w; j++){\n      if(dp[i][j] == 1) dp[i][j] = dp[i - 1][j] + 1;\n    }\n  }\n  /*for(int i = 0; i < h; i++){\n    for(int j = 0; j < w; j++){\n      cout << dp[i][j] << \" \";\n    }\n    cout << endl;\n  }*/\n  int ans = 0;\n  for(int i = 0; i < h; i++){\n    stack<pair<int, int> > s;\n    s.push(make_pair(dp[i][0], 0));\n    for(int j = 1; j < w; j++){\n      pair<int, int> x = s.top();\n      if(x.first < dp[i][j]) s.push(make_pair(dp[i][j], j));\n      else if(x.first > dp[i][j]){\n        while(s.size() > 0 && s.top().first >= dp[i][j]){\n          //cout << s.top().first << \" \" << s.top().second << \" -> \";\n          ans = max(ans, s.top().first * (j - s.top().second));\n          x = s.top();\n          s.pop();\n        }\n        s.push(make_pair(dp[i][j], x.second));\n      }\n    }\n    //cout << endl;\n    while(s.size() > 0){\n      //cout << s.top().first << \" \" << s.top().second << \" -> \";\n      ans = max(ans, s.top().first * (w - s.top().second));\n      s.pop();\n    }\n    //cout << ans << endl << endl;\n  }\n  cout << ans << endl;\n}\n\nint main(){\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\nconst int adx[] = { 1,1,1,0,-1,-1,-1,0 };\nconst int ady[] = { 1,0,-1,-1,-1,0,1,1 };\n\nint add(const int base, const int plus) {\n\tif (!plus) {\n\t\treturn base + 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n//0 :?????????1:??????2:?????????3:??? 4:?????????5:??? 6:?????? 7:??? ???\nvector<vector<vector<int>>>get_cumulative_sum(const vector<vector<int>>&field) {\n\tconst int H = field.size();\n\tconst int W = field[0].size();\n\n\tvector<vector<vector<int>>>sums(4, vector<vector<int>>(H, vector<int>(W)));\n\n\tfor (int ny = H - 1; ny >= 0; --ny) {\n\t\tfor (int nx = 0; nx <W; ++nx) {\n\t\t\tfor (int k = 0; k < 3; ++k) {\n\t\t\t\tsums[k].clear();\n\t\t\t}\n\t\t\tfor (int k = 3; k < 4; ++k) {\n\t\t\t\tint py = ny - ady[k];\n\t\t\t\tint px = nx - adx[k];\n\t\t\t\tif (!(px >= 0 && px <W && py >= 0 && py <H))continue;\n\n\t\t\t\tsums[k][ny][nx] = add(sums[k][py][px], field[ny][nx]);\n\n\t\t\t}\n\t\t}\n\t}\n\n\treturn sums;\n}\n\nint getans( vector<int>hs) {\n\ths.emplace_back(0);\n\tstack<pair<int, int>>que;\n\tque.emplace(-1, 0);\n\tint ans = 0;\n\tfor (int x = 0; x < hs.size(); ++x) {\n\t\t\n\t\tif (que.empty()) {\n\t\t\tque.push(make_pair(x, hs[x]));\n\t\t}\n\t\telse {\n\t\t\twhile (!que.empty()) {\n\t\t\t\tauto p = que.top();\n\t\t\t\tif (p.second < hs[x]) {\n\t\t\t\t\tque.push(make_pair(x,hs[x]));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (p.second == hs[x]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint area = (x - p.first)*p.second;\n\t\t\t\t\tans = max(ans, area);\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif (!que.empty()) {\n\t\t\t\t\t\tauto np = que.top();\n\t\t\t\t\t\tif (np.second < hs[x]) {\n\t\t\t\t\t\t\tque.push(make_pair(p.first, hs[x]));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\t\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>>field(H + 2, vector<int>(W + 2,1));\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tcin >> field[i + 1][j + 1];\n\t\t}\n\t}\n\tauto vs = get_cumulative_sum(field);\n\tint ans = 0;\n\t\n\tfor (int y = 1; y <= H; ++y) {\n\t\tvector<int>v;\n\t\tfor (int x = 1; x <= W; ++x) {\n\t\t\tv.push_back(vs[3][y][x]);\n\t\t}\n\t\tans = max(ans, getans(v));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<long, long> pll;\n\nconst int INF = 1 << 29;\nconst double EPS = 1e-9;\nconst int MOD = 100000007;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\nconst int MAX_HW = 1500;\nint H, W;\nint board[MAX_HW][MAX_HW];\nint dp[MAX_HW][MAX_HW];\nint main() {\n  scanf(\"%d %d\", &H, &W);\n  for (int i = 1; i <= H; i++) {\n    for (int j = 1; j <= W; j++) {\n      scanf(\"%d\", &board[i][j]);\n    }\n  }\n  for (int j = 1; j <= W; j++) {\n    for (int i = 1; i <= H; i++) {\n      if (board[i][j] == 1) {\n        dp[i][j] = 0;\n      } else {\n        dp[i][j] = dp[i - 1][j] + 1;\n      }\n    }\n  }\n  int res = 0;\n  for (int i = 1; i <= H; i++) {\n    stack<pii> st;\n    for (int j = 1; j <= W + 1; j++) {\n      if (st.empty()) {\n        st.push(mp(dp[i][j], j));\n      } else if (st.top().first < dp[i][j]) {\n        st.push(mp(dp[i][j], j));\n      } else if (st.top().first > dp[i][j]){\n        int target = i;\n        while (!st.empty() && st.top().first >= dp[i][j]) {\n          pii pre = st.top();\n          st.pop();\n          int area = pre.first * (j - pre.second);\n          res = max(res, area);\n          target = pre.second;\n        }\n        st.push(mp(dp[i][j], target));\n      }\n    }\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\nusing namespace std;\n\nint main(){\n\tint h, w;\n\tcin >> h >> w;\n\tint64_t ans = 0, dp[2][1400 + 1]{};\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tcin >> dp[i & 1][j];\n\t\t\tdp[i & 1][j] = !dp[i & 1][j];\n\t\t\tif(dp[i & 1][j] == 0) continue;\n\t\t\tdp[i & 1][j] += dp[!(i & 1)][j];\n\t\t}\n\t\tdp[i & 1][w] = 0;\n\t\tstack<int64_t> st;\n\t\tfor(int j = 0; j < w + 1; j++){\n\t\t\tif(st.empty()){\n\t\t\t\tst.emplace(dp[i & 1][j]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tans = max(ans, dp[i & 1][j]);\n\t\t\tfor(int64_t x = 2; !st.empty() && dp[i & 1][j] < st.top(); x++){\n\t\t\t\tst.pop();\n\t\t\t\tans = max(ans, x * dp[i & 1][j]);\n\t\t\t}\n\t\t\tst.emplace(dp[i & 1][j]);\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nconst int MAX = 1400;\n\nint main() {\n\tint H, W;\n\tint tile[MAX][MAX];\n\tint ans = 0;\n\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tscanf(\"%d\", &tile[i][j]);\n\t\t}\n\t}\n\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = W - 1; x >= 0; x--) {\n\t\t\tif (tile[y][x] == 1)tile[y][x] = 0;\n\t\t\telse if (x == W - 1)tile[y][x] = 1;\n\t\t\telse tile[y][x] = tile[y][x + 1] + 1;\n\t\t}\n\t}\n\n\tfor (int x = 0; x < W; x++) {\n\t\tstack<pair<int, int>> s;\n\t\ts.push(pair<int, int>(-1, 0));\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tif (s.top().second < tile[y][x]) {\n\t\t\t\ts.push(pair<int, int>(y, tile[y][x]));\n\t\t\t}\n\t\t\telse if (s.top().second > tile[y][x]) {\n\t\t\t\tint m = MAX;\n\t\t\t\twhile (s.top().second > tile[y][x]) {\n\t\t\t\t\tans = max(ans, (y - s.top().first) * s.top().second);\n\t\t\t\t\tm = min(m, s.top().first);\n\t\t\t\t\ts.pop();\n\t\t\t\t}\n\t\t\t\tif (s.top().second != tile[y][x]) s.push(pair<int, int>(m, tile[y][x]));\n\t\t\t}\n\t\t}\n\t\twhile (!s.empty()) {\n\t\t\tans = max(ans, (W - 1 - s.top().first) * s.top().second);\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define N 1401\nusing namespace std;\nint mp[N][N];\nint h,w;\n\nstruct dat{int h,i;};\n\nint calc(int A[]){\n  stack <dat> S;\n  int res = 0;\n  for(int i=0;i<=w;i++){\n    int h = A[i];\n    if(S.empty() || S.top().h < h) S.push((dat){h,i});\n    else if(S.top().h > h){\n      int ni = i;\n      while(!S.empty() && S.top().h > h){\n        dat t = S.top(); S.pop();\n        ni = t.i;\n        int area = (i - t.i) * t.h;\n        res = max(res,area);\n      }\n      res = max(res,(i-ni)*h);\n      S.push((dat){h,ni});\n    }\n  \n  return res;\n}\n\nint main(){\n\n  cin>>h>>w;\n  \n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++)cin>>mp[i][j],mp[i][j]=!mp[i][j];\n  \n  for(int j=0;j<w;j++)\n    for(int i=1;i<h;i++)if(mp[i][j]) mp[i][j] = mp[i-1][j]+1;\n\n\n  //cout<<endl;for(int i=0;i<h;i++){for(int j=0;j<w;j++)cout<<mp[i][j]<<\" \";cout<<endl;}\n  int ans = 0;\n  for(int i=0;i<h;i++)ans = max(ans,calc(mp[i]));\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<stack>\n#include<algorithm>\n#define MAX 1400\nusing namespace std;\nstruct Rectangle { int height; int pos; };\nint getLargestRectangle(int size, int buffer[]) {\nstack<Rectangle> S;\nint maxv = 0;\nbuffer[size] = 0;\nfor ( int i = 0; i <= size; i++ ) {\n          Rectangle rect;\n          rect.height = buffer[i];\n          rect.pos = i;\n          if ( S.empty() ) {\n          S.push(rect);\n          } else {\n          if ( S.top().height < rect.height ) {\n          S.push(rect);\n          } else if ( S.top().height > rect.height ) {\n          int target = i;\n          while ( !S.empty() && S.top().height >= rect.height ) {\n          Rectangle pre = S.top(); S.pop();\n          int area = pre.height * (i - pre.pos);\n          maxv = max(maxv, area);\n          target = pre.pos;\n          }\n          rect.pos = target;\n          S.push(rect);\n          }\n          }\n          }\n          return maxv;\n          }\n          int H, W;\n          int buffer[MAX][MAX];\n          int T[MAX][MAX];\n          int getLargestRectangle() {\n          for ( int j = 0; j < W; j++ ) {\n                    for ( int i = 0; i < H; i++ ) {\n                              if ( buffer[i][j] ) {\n                              T[i][j] = 0;\n                              } else {\n                              T[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n                              }\n                              }\n                              }\n                              int maxv = 0;\n                              for ( int i = 0; i < H; i++ ) {\n                                        maxv = max(maxv, getLargestRectangle(W, T[i]));\n                                        }\n\n                                        return maxv;\n                                        }\n                                        int main() {\n                                        scanf(\"%d %d\", &H, &W);\n                                        for ( int i = 0; i < H; i++ ) {\n                                                  for ( int j = 0; j < W; j++ ) {\n                                                            scanf(\"%d\", &buffer[i][j]);\n                                                            }\n                                                            }\n                                                            cout << getLargestRectangle() << endl;\n                                                            return 0;  }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,s,n) for (int i = (int)s; i < (int)n; i++)\n#define ll long long\n#define pb push_back\n#define All(x) x.begin(), x.end()\n#define Range(x, i, j) x.begin() + i, x.begin() + j\n#define lbidx(x, y) lower_bound(x.begin(), x.end(), y) - x.begin()\n#define ubidx(x, y) upper_bound(x.begin(), x.end(), y) - x.begin()\n#define BiSearchRangeNum(x, y, z) lower_bound(x.begin(), x.end(), z) - lower_bound(x.begin(), x.end(), y)\n#define deg_to_rad(deg) ((((double)deg)/((double)360)*2*M_PI))\n#define rad_to_deg(rad) ((((double)rad)/(double)2/M_PI)*(double)360)\n\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n  if(a < b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n  if(a > b) {\n    a = b;\n    return true;\n  }\n  return false;\n};\n\n#define MAX 1400\n\nstruct Rect { int height; int pos; };\n\n// ヒストグラムから最大長方形面積を取得\nint getLargestRect(int size, int buffer[]) {\n  stack<Rect> S;\n  int maxv = 0;\n  buffer[size] = 0;\n\n  rep(i, 0, size+1) {\n    Rect rect;\n    rect.height = buffer[i];\n    rect.pos = i;\n    if (S.empty()) {\n      S.push(rect);\n    } else {\n      if (S.top().height < rect.height) {\n        S.push(rect);\n      } else if (S.top().height > rect.height) {\n        int target = i;\n        while (!S.empty() && S.top().height >= rect.height) {\n          Rect pre = S.top(); S.pop();\n          int area = pre.height * (i - pre.pos);\n          maxv = max(maxv, area);\n          target = pre.pos;\n        }\n\n        rect.pos = target;\n        S.push(rect);\n      }\n    }\n  }\n\n  return maxv;\n};\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint solve() {\n  rep(j, 0, W) {\n    rep(i, 0, H) {\n      if (buffer[i][j]) {\n        T[i][j] = 0;\n      } else {\n        T[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n      }\n    }\n  }\n\n  int ret = 0;\n\n  rep(i, 0, H) {\n    ret = max(ret, getLargestRect(W, T[i]));\n  }\n\n  return ret;\n};\n\nint main() {\n  scanf(\"%d %d\", &H, &W);\n\n  rep(i, 0, H) {\n    rep(j, 0, W) {\n      scanf(\"%d\", &buffer[i][j]);\n    }\n  }\n  int ans = solve();\n  cout << ans << endl;\n};\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\nusing namespace std;\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n    char mat[h][w];\n    int dp[h][w];\n\n    for (int i = 0; i < h; i++)\n    {\n        for (int j = 0; j < w; j++)\n        {\n            cin >> mat[i][j];\n        }\n    }\n\n    for (int i = 0; i < h; i++)\n        dp[0][i] = (mat[0][i] == '0');\n    for (int i = 1; i < h; i++)\n    {\n        for (int j = 0; j < w; j++)\n        {\n            if (mat[i][j] == '0')\n                dp[i][j] = dp[i - 1][j] + 1;\n            else\n                dp[i][j] = 0;\n        }\n    }\n\n    int ans = -1;\n    for (int i = 0; i < h; i++)\n    {\n        // pair<left end, height>\n        stack<pair<int, int>> s;\n        for (int j = 0; j < w; j++)\n        {\n            if (s.empty())\n            {\n                s.push({j, dp[i][j]});\n            }\n            else if (dp[i][j] > s.top().second)\n            {\n                s.push({j, dp[i][j]});\n            }\n            else if (dp[i][j] == s.top().second)\n            {\n                // do nothing.\n            }\n            else if (dp[i][j] < s.top().second)\n            {\n                int left;\n                while (!s.empty() && dp[i][j] < s.top().second)\n                {\n                    pair<int, int> now = s.top();\n                    s.pop();\n                    // make rectangle\n                    ans = max(ans, (j - now.first) * (now.second));\n                    left = now.first;\n                }\n                s.push({left, dp[i][j]});\n            }\n        }\n\n        while (!s.empty())\n        {\n            pair<int, int> now = s.top();\n            s.pop();\n            ans = max(ans, (w - now.first) * (now.second));\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n \n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define fi first\n#define se second\n \n#define INF 2147483600\ntypedef pair<int, int> P;\n \nint mat[1500][1500];\n \nint main(){\n  int h,w;\n  cin>>h>>w;\n \n  rep(i,h)rep(j,w) scanf(\"%d\", &mat[i][j]);\n \n  // convert matrix to vertiacl succeeding numbers\n  rep(i,h)rep(j,w){\n    if(i==0){\n      mat[i][j] = !mat[i][j];\n      continue;\n    }\n    if(mat[i][j]==0) mat[i][j] = mat[i-1][j]+1;\n    else mat[i][j] = 0;\n  }\n \n  // see matrix row as a histogram to make the largert rectangle\n  int res = 0;\n  rep(i,h){\n    mat[i][w] = 0;\n    stack<P> st;\n    rep(j,w+1){\n      int d=mat[i][j];\n      if(st.empty()) st.push(mp(j,d));\n      else if(st.top().se < d) st.push(mp(j,d));\n      else if (st.top().se > d){\n        int last = j;\n        while(!st.empty() && st.top().se > d){\n          P p = st.top(); st.pop();\n          res = max(res, (j-p.fi)*p.se);\n          last = p.fi;\n        }\n        st.push(mp(last,d));\n      }\n    }\n  }\n \n  cout<<res<<endl;\n \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <algorithm>\nusing namespace std;\nstatic const int MAX = 1405;\n\nstruct Rect { int pos, height; };\nint G[MAX][MAX];\nint H, W;\n\nint getLargestRectangle(int buffer[])\n{\n    stack<Rect> S;\n    int maxv = 0;\n    buffer[W] = 0;\n\n    for (int i = 0; i <= W; ++i)\n    {\n        Rect r;\n        r.pos = i;\n        r.height = buffer[i];\n        if (S.empty())\n        {\n            S.push(r);\n        }\n        else\n        {\n            if (S.top().height < r.height)\n            {\n                S.push(r);\n            }\n            else if (S.top().height > r.height)\n            {\n                int target = i;\n                while (!S.empty() && S.top().height >= r.height)\n                {\n                    Rect temp = S.top(); S.pop();\n                    maxv = max(maxv, temp.height * (i - temp.pos));\n                    target = temp.pos;\n                }\n                r.pos = target;\n                S.push(r);\n            }\n        }\n    }\n    return maxv;\n}\n\nint main()\n{\n    cin >> H >> W;\n    for (int i = 0; i != H; ++i)\n    {\n        for (int j = 0; j != W; ++j)\n        {\n            cin >> G[i][j];\n            if (G[i][j])\n            {\n                G[i][j] = 0;\n            }\n            else\n            {\n                G[i][j] = (i > 0) ? G[i-1][j] + 1 : 1;\n            }          \n        }\n    }\n\n    int maxv = 0;\n    for (int i = 0; i != H; ++i)\n    {\n        maxv = max(maxv, getLargestRectangle(G[i]));\n    }\n    cout << maxv << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nsize_t get_largest_rectangle(vector<vector<int>> &g) {\n    size_t h=g.size(), w=g[0].size();\n\n    vector<vector<int>> dp(h, vector<int>(w+1));\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j)\n            dp[i][j] = !g[i][j];\n\n    for (size_t i=1; i<h; ++i)\n        for (size_t j=0; j<w; ++j)\n            if (dp[i][j])\n                dp[i][j] += dp[i-1][j];\n\n    size_t max_area=0;\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j) {\n            if (!dp[i][j]) continue;\n\n            int min_height=dp[i][j];\n            for (size_t k=j+1; k<=w; ++k) {\n                if (max_area < (k-j)*min_height)\n                    max_area = (k-j)*min_height;\n\n                if (!dp[i][k])\n                    break;\n\n                if (min_height > dp[i][k])\n                    min_height = dp[i][k];\n            }\n        }\n\n    return max_area;\n}\n\nint main() {\n    size_t h, w;\n    scanf(\"%zu %zu\", &h, &w);\n\n    vector<vector<int>> g(h, vector<int>(w));\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j)\n            scanf(\"%d\", &g[i][j]);\n\n    printf(\"%zu\\n\", get_largest_rectangle(g));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint a[1401][1401];\nint cur_row[1401];\nlong long find_max_area_histogram(int m) {\n    stack<int>s;\n    long long max_area = 0;\n    long long area = 0;\n    int i = 0;\n    int top_value = 0;\n    while (i < m)\n    {\n        if (s.empty() || cur_row[i] >= cur_row[s.top()]) {\n            s.push(i++);\n        }\n        else {\n             top_value = cur_row[s.top()];\n            s.pop();\n            area = top_value*i;//incase stack is empty\n\n            //if not empty then\n            if (!s.empty()) {\n                area = top_value*(i - 1 - s.top());\n            }\n            max_area = max(area, max_area);\n        }\n    }\n\n    while (!s.empty())\n    {\n        int top_value = cur_row[s.top()];\n        s.pop();\n        area = top_value*i;//in case stack is empty\n\n                           //if not empty then\n        if (!s.empty()) {\n            area = top_value*(i - 1 - s.top());\n        }        \n       max_area = max(area, max_area);\n    }\n    return max_area;\n}\nlong long find_max_rectangle(int n, int m) {\n    long long max_area = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++)\n        {\n            if (a[i][j]) {\n                cur_row[j] += a[i][j];\n            }\n            else {\n                cur_row[j] = 0;\n            }\n        }\n\n        max_area = max(max_area, find_max_area_histogram(m));\n\n    }\n    return max_area;\n}\nint main() {\n\n    long long n, m;\n    cin >> n >> m;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> a[i][j];\n            a[i][j] = !a[i][j];\n        }\n    }\n    \n\n    long long answer = find_max_rectangle(n, m);\n    cout << answer << endl;\n    return 0;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <iomanip>\n#include <stack>\n\nusing namespace std;\n\n\nint c[1401][1401];\nint dp[1401][1401];\n\nstruct RT {\n\tint point;\n\tint height;\n};\n\nint max_in_x(int *p,int size) {\n\tstack<RT> st;\n\tint cur = 0;\n\tint s = 0;\n\n\t*(p + size ) = 0;\n\tfor (int i = 0; i <= size; i++) {\n\t\tint current_h = *(p + i);\n\t\tRT rect = {i,current_h};\n\n\t\tif (st.empty()) {\n\t\t\tst.push(rect);\n\t\t} else if (current_h > st.top().height) {\n\t\t\tst.push(rect);\n\t\t} else if (current_h < st.top().height) {\n\t\t\tRT start = st.top();\n\t\t\tstart.point = i - 1;\n\t\t\tRT target;\n\n\t\t\twhile(!st.empty() && st.top().height > current_h) {\n\t\t\t \ttarget = st.top();\n\t\t\t\tst.pop();\n\t\t\t\ts = max(s,(start.point -target.point + 1) * target.height);\n\t\t\t\tcout << \"s:\" << s << endl;\n\t\t\t}\n\t\t\ttarget.height = current_h;\n\t\t\tst.push(target);\n\t\t\t\n\t\t} \n\t}\n\n\treturn s;\n}\n\n\nint main() {\n\tint W,H;\n\tcin >> H >> W;\n\t\n\tint v_max = 0;\n\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x < W; x++) {\n\n\t\t\tcin >> c[y][x];\n\t\t\tc[y][x] ^= 1;\n\t\t\tdp[y][x] = 0;\t\t\t\n\t\t}\n\t}\n\tfor (int x = 0; x < W; x++) {\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tif (c[y][x] == 0) {\n\t\t\t\tdp[y][x] = 0;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (y==0) {\n\t\t\t\tdp[y][x] = 1;\n\t\t\t\tcontinue;\t\t\t\t\n\t\t\t} \n\t\t\tdp[y][x] = dp[y-1][x] + 1;\n\t\t}\n\t}\n\n\tint s_max = 0;\n\n/*\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x < W; x++) {\n\t\t\tcout << setw(5) << dp[y][x] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n*/\n\n\tfor( int y = 0; y < H; y++) {\n\t\t\n\t\t//cout << \"** s_max y:\" << y << endl;\n\t\tint ret = max_in_x(dp[y],W); \n\t\t//cout << \"v:\" << ret << endl;\n\t\ts_max = max(s_max,ret);\n\t}\n\n\tcout << s_max << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n\tint c[2000][2000] = {{0}};\nint maximumRectangule(int h, int w, char m[2000][2000]){\n\trep(i,w){\n\t\tint cnt = 0;\n\t\trep(j,h){\n\t\t\tif(m[j][i] == '.'){\n\t\t\t\tcnt++;\n\t\t\t\tc[j][i] = cnt;\n\t\t\t}else{\n\t\t\t\tcnt = 0;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,h) c[i][w] = 0;\n\n\tint ans = 0;\n\trep(i,h){\n\t\tvector<pair<int, int>> v; //height, pos\n\t\trep(j,w + 1){\n\t\t\tif(v.empty()) v.emplace_back(c[i][j],j);\n\t\t\telse{\n\t\t\t\tif(v.back().first < c[i][j]) v.emplace_back(c[i][j],j);\n\t\t\t\telse{\n\t\t\t\t\tint target = j;\n\t\t\t\t\twhile(not v.empty() && v.back().first >= c[i][j]){\n\t\t\t\t\t\tans = max(ans, v.back().first * (j - v.back().second));\n\t\t\t\t\t\ttarget = v.back().second;\n\t\t\t\t\t\tv.pop_back();\n\t\t\t\t\t}\n\t\t\t\t\tv.emplace_back(c[i][j],target);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint h, w;\n\tcin >> h >> w;\n\n\tchar m[2000][2000];\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tif(a) m[i][j] = '#';\n\t\t\telse m[i][j] = '.';\n\t\t}\n\t}\n\tcout << maximumRectangule(h,w,m) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int maxn=1400;\n\nstruct rectangle{\n    int height,pos;\n};\n\nint getmaxv(int size,int buffer[])\n{\n    stack<rectangle>S;\n    int maxv=0;\n    buffer[size]=0;\n    for(int i=0;i<=size;i++){\n        rectangle rect;\n        rect.height=buffer[i];\n        rect.pos=i;\n        if(S.empty()){\n            S.push(rect);\n        }else{\n            if(S.top().height<rect.height){\n                S.push(rect);\n            }else if(S.top().height>rect.height){\n                int target=i;\n                while(!S.empty()&&S.top().height>=rect.height){\n                    rectangle pre=S.top();\n                    S.pop();\n                    int area=pre.height*(i-pre.pos);\n                    maxv=max(maxv,area);\n                    target=pre.pos;\n                }\n                rect.pos=target;\n                S.push(rect);\n            }\n        }\n    }\n    return maxv;\n}\n\nint h,w;\nint buffer[maxn][maxn];\nint t[maxn][maxn];\n\nint solve()\n{\n    for(int j=0;j<w;j++){\n        for(int i=0;i<h;i++){\n            if(buffer[i][j]){\n                t[i][j]=0;\n            }else{\n                t[i][j]=(i>0)?t[i-1][j]+1:1;\n            }\n        }\n    }\n//    for(int i=0;i<h;i++){\n//        for(int j=0;j<w;j++){\n//            cout<<t[i][j]<<\" \";\n//        }\n//        cout<<endl;\n//    }\n    int maxv=0;\n    for(int i=0;i<h;i++){\n        maxv=max(maxv,getmaxv(w,t[i]));\n    }\n    return maxv;\n}\n\nint main()\n{\n    scanf(\"%d%d\",&h,&w);\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            scanf(\"%d\",&buffer[i][j]);\n        }\n    }\n    cout<<solve()<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n    int maxlen[1401][1401] = {};\n    for(int i = 1; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            int c;\n            cin >> c;\n            if(c == 1) continue;\n            maxlen[i][j] = maxlen[i - 1][j] + 1;\n        }\n    }\n    int ans = 0;\n    for(int i = 1; i <= h; i++){\n        stack<pair<int, int> > st;\n        for(int j = 1; j <= w; j++){\n            if(st.empty() || (st.top()).first < maxlen[i][j]){\n                st.push(make_pair(maxlen[i][j], j));\n            } else if((st.top()).first > maxlen[i][j]){\n                int before = j;\n                while(!st.empty()){\n                    if((st.top()).first < maxlen[i][j]){\n                        st.push(make_pair(maxlen[i][j], before));\n                        break;\n                    } else {\n                        ans = max(ans, (st.top()).first * (j - (st.top()).second));\n                        before = (st.top()).second;\n                        st.pop();\n                    }\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep2(x,fr,to) for(int (x)=(fr);(x)<(to);(x)++)\n#define rep(x,to) for(int (x)=0;(x)<(to);(x)++)\n#define repr(x,fr,to) for(int (x)=(fr);(x)>=(to);(x)--)\n#define all(c) (c).begin(),(c).end()\n#define sz(v) (int)(v).size()\n\ntypedef long long ll; typedef vector<int> VI; typedef pair<int,int> pii;\nconst ll mod = 1e9+7;\n\nint max_rectangle(const vector<int>& vec) {\n\tint rtn = 0;\n\tstack<pii> stk;\n\tauto calstk = [&](int ps, int ht){\n\t\tint t = ps;\n\t\tfor( ;!stk.empty() && stk.top().second >= ht; stk.pop()){\n\t\t\tt = stk.top().first;\n\t\t\trtn = max(rtn, (ps-t) * stk.top().second);\n\t\t}\n\t\tif(ht >0) stk.push(pii(t, ht));\n\t};\n\trep(i, sz(vec)){\n\t\tcalstk(i, vec[i]);\n\t}\n\tcalstk(sz(vec), 0);\n\treturn rtn;\n}\n\n\nint main()\n{\n\tint h,w;\n\twhile(cin >>h >>w){\n\t\tif(h==0 && w==0) break;\n\t\tvector<vector<int>> fl(h+1, vector<int>(w+1));\n\t\trep(i,h) rep(j,w){\n\t\t\tchar ch; cin >>ch;\n\t\t\tif(ch =='1') fl[i][j] = 0;\n\t\t\telse fl[i][j] = i? fl[i-1][j] +1 : 1;\n\t\t}\n\t\t//for(auto xl: fl){for(auto x :xl) printf(\"%d \",x); puts(\"\");}\n\t\tint ans =0;\n\t\t\n\t\trep(i,h){\n\t\t\tans = max(ans, max_rectangle(fl[i]));\n\t\t}\n\t\tcout << ans <<\"\\n\";\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nstruct elem {\n\tint pos, height;\n};\n\nint getArea(int V[], int W) {\n\tint area = 0;\n\tstack<elem> S;\n\tfor (int i = 0; i <= W; ++i) {\n\t\telem e;\n\t\te.pos = i;\n\t\tif (i == W) {\n\t\t\te.height = 0;\n\t\t} else {\n\t\t\te.height = V[i];\n\t\t}\n\t\tif (S.empty() || e.height > S.top().height) {\n\t\t\tS.push(e);\n\t\t} else {\n\t\t\tint prepos = i;\n\t\t\twhile (!S.empty() && S.top().height > e.height) {\n\t\t\t\telem target = S.top();\n\t\t\t\tS.pop();\n\t\t\t\tarea = max(area, (i - target.pos) * target.height);\n\t\t\t\tprepos = target.pos;\n\t\t\t}\n\t\t\te.pos = prepos;\n\t\t\tS.push(e);\n\t\t}\n\t}\n\treturn area;\n}\nint main() {\n\tint H, W;\n\tscanf(\"%d %d\", &H, &W);\n\tint A[H][W];\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tscanf(\"%d\", &A[i][j]);\n\t\t}\n\t}\n\n\tint V[H][W];\n\tfor (int j = 0; j < W; ++j) {\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tif (A[i][j] == 1) {\n\t\t\t\tV[i][j] = 0;\n\t\t\t} else {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tV[i][j] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tV[i][j] = V[i - 1][j] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxv = 0;\n\tfor (int i = 0; i < H; ++i) {\n\t\tmaxv = max(maxv, getArea(V[i], W));\n\t}\n\tcout << maxv << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N = 1405, INF = 0x3f3f3f3f;\nint n, m;\nint a[N][N];\nint s[N], p;\n\ninline int nextInt(void) {\n\tint res;\n\tscanf(\"%d\", &res);\n\treturn res;\n}\n\ninline int DP(int x) {\n\tint ans = 0;\n\tp = 0;\n\ts[++p] = a[x][1];\n\tfor(int i=2;i<=m+1;i++)\n\t\tif (a[x][i] >= s[p]) {\n\t\t\ts[++p] = a[x][i];\n\t\t}\n\t\telse {\n\t\t\tint t = p;\n\t\t\twhile (t&&s[t] > a[x][i]) {\n\t\t\t\tans = max(ans, s[t] * (p - t + 1));\n\t\t\t\tt--;\n\t\t\t}\n\t\t\ts[p = t + 1] = a[x][i];\n\t\t}\n\treturn ans;\n}\n\nsigned main(void) {\n\tmemset(a, 0, sizeof(a));\n\tn = nextInt();\n\tm = nextInt();\n\tfor (int i = 1; i <= n; i++)\n\t\tfor (int j = 1; j <= m; j++)\n\t\t\tif (!nextInt())\n\t\t\t\ta[i][j] = a[i][j - 1] + 1;\n\tint ans = 0;\n\tfor (int i = 1; i <= n; i++)\n\t\tans = max(ans, DP(i));\n\tprintf(\"%d\\n\", ans);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n\nint main() {\n    int H, W;\n    std::cin >> H >> W;\n\n    std::vector<std::vector<int>> tiles_hist(H, std::vector<int>(W, 0));\n    for (int y = 0; y < H; y++) {\n        for (int x = 0; x < W; x++) {\n            int val;\n            std::cin >> val;\n            if (val == 1) {\n                tiles_hist[y][x] = 0;\n            } else {\n                if (y > 0) {\n                    tiles_hist[y][x] = tiles_hist[y - 1][x] + 1;\n                } else {\n                    tiles_hist[y][x] = 1;\n                }\n            }\n        }\n    }\n\n    int max_area = 0;\n    for (int y = 0; y < H; y++) {\n        std::stack<std::pair<int, int>> stack;\n        for (int x = 0; x < W; x++) {\n            int min_x = x;\n            while (!stack.empty() && stack.top().second > tiles_hist[y][x]) {\n                int area = (x - stack.top().first) * stack.top().second;\n                max_area = std::max(area, max_area);\n                min_x = stack.top().first;\n                stack.pop();\n            }\n            stack.push(std::make_pair(min_x, tiles_hist[y][x]));\n        }\n        while (!stack.empty()) {\n            int area = (W - stack.top().first) * stack.top().second;\n            max_area = std::max(area, max_area);\n            stack.pop();\n        }\n    }\n\n    std::cout << max_area << std::endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\n\n//?????£????????????????????????????????????????????????\n//???????????????????????????????????¨?????????\n\nint main(void){\n\tll H,W;\n\t// cin>>H>>W;\n\tll c[1400][1400];//H,W\n\t// ll up[1400][1400];//?????´???\n\t// ll left[1400][1400];//?????´???\n\tll ans=0;\n\t// ll min;\n\t// rep(i,H){\n\t// \trep(j,W){\n\t// \t\tcin>>c[i][j];\n\t// \t\tif(c[i][j]==0){//?¶????????????????\n\t// \t\t\tif(i==0){\n\t// \t\t\t\tup[0][j]=1;\n\t// \t\t\t}else{\n\t// \t\t\t\tup[i][j]=up[i-1][j]+1;\n\t// \t\t\t}\n\t// \t\t\tif(j==0){\n\t// \t\t\t\tleft[i][0]=1;\n\t// \t\t\t}else{\n\t// \t\t\t\tleft[i][j]=left[i][j-1]+1;\n\t// \t\t\t}\n\t// \t\t}else{//?±?????????????\n\t// \t\t\tup[i][j]=0;\n\t// \t\t\tleft[i][j]=0;\n\t// \t\t}\n\t// \t\tmin=LLONG_MAX;\n\t// \t\trep(k,up[i][j]){\n\t// \t\t\tif(left[i-k][j]<min){\n\t// \t\t\t\tmin=left[i-k][j];\n\t// \t\t\t}\n\t// \t\t}\n\t// \t\tif(ans<min*up[i][j])ans=min*up[i][j];\n\t// \t\tmin=LLONG_MAX;\n\t// \t\trep(k,left[i][j]){\n\t// \t\t\tif(up[i][j-k]<min){\n\t// \t\t\t\tmin=up[i][j-k];\n\t// \t\t\t}\n\t// \t\t}\n\t// \t\tif(ans<min*left[i][j])ans=min*left[i][j];\n\t// \t}\n\t// }\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <unordered_map>\nconstexpr int MOD = 1000000000 + 7;\nconstexpr int INF = 2000000000;\nusing namespace std;\nusing LL = long long;\n\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectangle(int size, int buffer[]) {\n\tstack<Rectangle> S;\n\tint maxv = 0;\n\tbuffer[size] = 0;\n\tfor (int i = 0; i < size; i++) {\n\t\tRectangle rect;\n\t\trect.height = buffer[i];\n\t\trect.pos = i;\n\t\tif (S.empty()) {\n\t\t\tS.push(rect);\n\t\t}\n\t\telse {\n\t\t\tif (S.top().height < rect.height)S.push(rect);\n\t\t\telse if (S.top().height > rect.height) {\n\t\t\t\tint target = i;\n\t\t\t\twhile (!S.empty() && S.top().height >= rect.height) {\n\t\t\t\t\tRectangle pre = S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tint area = pre.height*(i - pre.pos);\n\t\t\t\t\tmaxv = max(maxv, area);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos = target;\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxv;\n}\n\nint H, W;\nint Buffer[1400][1400];\nint T[1400][1400];\n\nint getLargestRectangle() {\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tif (Buffer[i][j]) {\n\t\t\t\tT[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tT[i][j] = (i > 0 ? T[i - 1][j] + 1 : 1);\n\t\t\t}\n\t\t}\n\t}\n\tint maxv = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tmaxv = max(maxv, getLargestRectangle(W, T[i]));\n\t}\n\treturn maxv;\n}\n\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> Buffer[i][j];\n\t\t}\n\t}\n\tcout << getLargestRectangle() << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\n\n\nint main()\n{\n    int h,w;\n    cin >> h >> w;\n    int space[h][w];\n    int y[h][w];\n    int x[h][w];\n    for(int i = 0;i < h; i++){\n        for(int j = 0; j < w; j++){\n            cin >> space[i][j];\n            x[i][j] = 0;\n            y[i][j] = 0;\n        }\n    }\n    if(space[0][0] == 0){\n        x[0][0] = 1;\n        y[0][0] = 1;\n    }\n    int max_area = 0;\n    for(int j = 1;j < w;j++){\n            x[0][j] = (space[0][j] == 0)?x[0][j-1]+1:0;\n            y[0][j] = (space[0][j] == 0)?1:0;\n            max_area = (max_area<y[0][j]*x[0][j])?y[0][j]*x[0][j]:max_area;\n    }\n    for(int i = 1;i < h;i++){\n            y[i][0] = (space[i][0] == 0)?x[i-1][0]+1:0;\n            x[i][0] = (space[i][0] == 0)?1:0;\n            max_area = (max_area<y[i][0]*x[i][0])?y[i][0]*x[i][0]:max_area;\n    }\n    int fh = 0, fw = 0;\n    for(int i = 1; i < h; i++){\n        for(int j = 1; j < w; j++){\n            x[i][j]=(space[i][j]==0)?x[i][j-1]+1:0;\n            y[i][j]=(space[i][j]==0)?y[i-1][j]+1:0;\n            fh = min(y[i][j],y[i][j-y[i][j]]);\n            fw = min(x[i][j],x[i-x[i][j]][j]);\n            max_area = (max_area<fh*fw)?fh*fw:max_area;\n        }\n    }\n    cout << max_area << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nstruct st{int left,height;};\nint solveMaxRectangle(vector<int> v){\n\tv.pb(0);\n\tint maxi = 0;\n\tstack<st> stk;\n\trep(i,v.size()){\n\t\tint left = i;\n\t\twhile( stk.size()>0 && stk.top().height>=v[i] ){\n\t\t\tint w = i - stk.top().left;\n\t\t\tmaxi = max(maxi,w*stk.top().height);\n\t\t\tleft = stk.top().left;\n\t\t\tstk.pop();\n\t\t}\n\t\tstk.push(st{left,v[i]});\n\t}\n\treturn maxi;\n}\n\n\nint main(){\n\tint h,w;\n\tcin>>h>>w;\n\t\n\tvector<vector<int>> v(h,vector<int>(w));\n\trep(i,h) rep(j,w) cin>>v[i][j];\n\trep(i,h) rep(j,w) v[i][j] = !v[i][j];\n\t\n\tstatic int dp[1500][1500];\n\trep(i,1500)rep(j,1500)dp[i][j]=0;\n\t\n\trep(i,w)dp[0][i] = v[0][i];\n\tfor(int i=1;i<h;i++){\n\t\trep(j,w){\n\t\t\tif(v[i][j]!=0)dp[i][j] = dp[i-1][j]+v[i][j];\n\t\t}\n\t}\n \n\tint ans = 0;\n\trep(i,h){\n\t\tvector<int> v(dp[i],dp[i]+1500);\n\t\tans = max(ans,solveMaxRectangle(v));\n\t}\n\tcout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n\nstatic const int MAX_N = 1400;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n\nint masu[MAX_N][MAX_N];\n\nint main(void) {\n  int H, W;\n  cin >> H >> W;\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      cin >> masu[i][j];\n      masu[i][j] = (masu[i][j] + 1) % 2;\n    }\n  }\n  for (int i = 1; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      if (masu[i][j]) {\n        masu[i][j] += masu[i-1][j];\n      }\n    }\n  }\n\n  Rectangle rect;\n  int maxArea;\n  for (int i = 0; i < H; i++) {\n    stack<Rectangle> stk;\n    for (int j = 0; j < W; j++) {\n      rect.height = masu[i][j];\n      rect.pos = j;\n      if (stk.empty()) {\n        stk.push(rect);\n      } else {\n        if (stk.top().height < rect.height) {\n          stk.push(rect);\n        } else if (stk.top().height > rect.height) {\n          int target = j;\n          while (!stk.empty() && stk.top().height >= rect.height) {\n            Rectangle pre = stk.top(); stk.pop();\n            int area = pre.height * (j - pre.pos);\n            maxArea = max(maxArea, area);\n            target = pre.pos;\n          }\n          rect.pos = target;\n          stk.push(rect);\n        }\n      }\n    }\n  }\n\n  cout << maxArea << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// ?????¬???????????¬??????\n\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nint H, W;\n\n// ?????? N ??????????????°?????????????????¢???????????§\n// Verified: AOJ DPL_3_C: Largest Rectangle in a Histogram\nint histArea(vector<int> h) {\n    // ??????\n    int N = h.size();\n    h.push_back(0); N++;\n\n    // height, position\n    int ans = 0;\n    stack<pii> S;\n    rep(i,0,N+1) {\n        if(S.empty()) S.push(pii(h[i], i));\n\n        if     (S.top().first < h[i])\n            S.push(pii(h[i], i));\n        else if(S.top().first > h[i]) {\n            int lastpos = 0;\n            while(!S.empty() && S.top().first >= h[i]) {\n                lastpos = S.top().second;\n                chmax(ans, S.top().first * (i-lastpos));\n                S.pop();\n            }\n            S.push(pii(h[i], lastpos));\n        }\n    }\n    return ans;\n}\n\n// ?????§????????¢??????\n// 0 -> ?¶??????????????????? 1 -> ?±??????????????????????\nint maxRectangle(vector< vector<int> > board) {\n    int H = board.size(), W = board[0].size();\n    vector< vector<int> > sum(H, vector<int>(W));\n    rep(i,0,H) rep(j,0,W) {\n        if(board[i][j] == 1) continue;\n        sum[i][j] = (i > 0 ? sum[i-1][j] : 0) + 1;\n    }\n    int ret = 0;\n    rep(i,0,H) {\n        chmax(ret, histArea(sum[i]));\n    }\n    return ret;\n}\n\nsigned main() {\n    cin >> H >> W;\n    vector< vector<int> > board(H, vector<int>(W));\n    rep(i,0,H) rep(j,0,W) cin >> board[i][j];\n    cout << maxRectangle(board) << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <cmath>\n#include <deque>\n#include <iterator>\n#include <map>\n#include <queue>\n#include <stack>\n#include <string>\n#include <tuple>\n#include <utility>\n#include <limits>\n#include <iomanip>\nusing namespace std;\n\nusing ll=long long;\ntemplate<class T> using V = vector<T>;\ntemplate<class T, class U> using P = pair<T, U>;\nusing vll = V<ll>;\nusing vvll = V<vll>;\n#define rep(i, k, n) for (ll i=k; i<(ll)n; ++i)\n#define REP(i, n) rep(i, 0, n)\n#define MAX 1400\ntemplate<class T> inline bool chmax(T& a, T b) {if (a<b) {a=b; return true;} return false;}\ntemplate<class T> inline bool chmin(T& a, T b) {if (a>b) {a=b; return true;} return false;}\n\nstruct Rectangle{ll height; ll pos;};\n\nll getLargestRectangle(ll size, vll buffer) {\n  stack<Rectangle> S;\n  ll maxv = 0;\n  buffer[size] = 0;\n\n  REP(i, size+1) {\n    Rectangle rect;\n    rect.height = buffer[i];\n    rect.pos = i;\n    if (S.empty()) {\n      S.push(rect);\n    } else {\n      if (S.top().height < rect.height) {\n        S.push(rect);\n      } else if (S.top().height > rect.height) {\n        ll target = i;\n        while(!S.empty() && S.top().height >= rect.height) {\n          Rectangle pre = S.top(); S.pop();\n          ll area = pre.height * (i-pre.pos);\n          chmax(maxv, area);\n          target = pre.pos;\n        }\n        rect.pos = target;\n        S.push(rect);\n      }\n    }\n  }\n  return maxv;\n}\n\nll H, W;\nvvll buffer(MAX, vll(MAX));\nvvll T(MAX, vll(MAX));\n\nll getLargestRectangle() {\n  REP(j, W) {\n    REP(i, H) {\n      if (buffer[i][j]) {\n        T[i][j] = 0;\n      } else {\n        T[i][j] = (i>0) ? T[i-1][j] + 1: 1;\n      }\n    }\n  }\n  ll maxv = 0;\n  REP(i, H) chmax(maxv, getLargestRectangle(W, T[i]));\n  return maxv;\n}\n\nint main() {\n  cin >> H >> W;\n  REP(i, H) REP(j, W) cin >> buffer[i][j];\n  cout << getLargestRectangle() << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 2000\nint x[MAX_N][MAX_N];\nint H, W;\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> x[i][j];\n\t\t}\n\t\tif (x[i][0] == 1) { x[i][0] = 0; }\n\t\telse { x[i][0] = 1; }\n\t\tfor (int j = 1; j < W; j++) {\n\t\t\tif (x[i][j] == 1) {\n\t\t\t\tx[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i][j] = x[i][j - 1] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tint maxn = 0;\n\tfor (int i = 0; i < W; i++) {\n\t\tfor (int j = 0; j < H; j++) {\n\t\t\tint X = x[j][i], cnt = 0;\n\t\t\tfor (int k = j; k >= 0; k--) {\n\t\t\t\tcnt++; X = min(X, x[k][i]);\n\t\t\t\tif (X == 0) { break; }\n\t\t\t\tmaxn = max(maxn, X*cnt);\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <stack>\n#include <algorithm>\n#define MAX 1400\nusing namespace std;\n\nstruct Rectangle {\n    int height;\n    int pos;\n};\n\nint getLargestRectangle(int size,int buffer[]) {\n    stack<Rectangle> S;\n    int maxv=0;\n    buffer[size]=0;\n\n    for(int i=0;i<=size;i++) {\n        Rectangle rect;\n        rect.height=buffer[i];\n        rect.pos=i;\n        if(S.empty()||S.top().height<rect.height)\n            S.push(rect);\n        else if(S.top().height>rect.height) {\n            int target=i;\n            while(!S.empty()&&S.top().height>=rect.height) {\n                Rectangle pre=S.top();S.pop();\n                int area=pre.height*(i-pre.pos);\n                maxv=max(maxv,area);\n                target=pre.pos;\n            }\n            rect.pos=target;\n            S.push(rect);\n        }\n    }\n    return maxv;\n}\n\nint H,W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle() {\n    for(int j=0;j<W;j++)\n        for(int i=0;i<H;i++)\n            if(buffer[i][j])\n                T[i][j]=0;\n            else\n                T[i][j]=(i>0)?T[i-1][j]+1:1;\n\n    int maxv=0;\n    for(int i=0;i<H;i++)\n        maxv=max(maxv,getLargestRectangle(W,T[i]));\n\n    return maxv;\n}\n\nint main()\n{\n    scanf(\"%d %d\",&H,&W);\n\n    for(int i=0;i<H;i++)\n        for(int j=0;j<W;j++)\n            scanf(\"%d\",&buffer[i][j]);\n\n    cout<<getLargestRectangle()<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint tag[505][505];\nint dp[505][505];\nint main()\n{\n    int n,m;\n    while(cin>>n>>m)\n    {\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=m;j++)\n            {\n                cin>>tag[i][j];\n                if(!tag[i][j]) dp[i][j]=dp[i][j-1]+1;\n            }\n        }\n\n\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=m;j++)\n            {\n                //cout<<dp[i][j]<<' ';\n            }\n           // cout<<endl;\n        }\n        int k,maxs=0,l,x;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=m;j++)\n            {\n                x=dp[i][j];\n                k=i;\n                l=1;\n                while(k>0)\n                {\n                    x=min(x,dp[k][j]);\n                    maxs=max(maxs,x*l);\n                    l++;\n                    k--;\n                }\n            }\n        }\n        cout<<maxs<<endl;\n\n\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n\nstatic const int MAX_N = 1400;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n\nint masu[MAX_N][MAX_N];\n\nint main(void) {\n  int H, W;\n  cin >> H >> W;\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      cin >> masu[i][j];\n      masu[i][j] = (masu[i][j] + 1) % 2;\n    }\n  }\n  for (int i = 1; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      if (masu[i][j]) {\n        masu[i][j] += masu[i-1][j];\n      }\n    }\n  }\n\n  Rectangle rect;\n  int maxArea = 0;\n  for (int i = 0; i < H; i++) {\n    stack<Rectangle> stk;\n    for (int j = 0; j < W; j++) {\n      rect.height = masu[i][j];\n      rect.pos = j;\n      if (stk.empty()) {\n        stk.push(rect);\n      } else {\n        if (stk.top().height < rect.height) {\n          stk.push(rect);\n        } else if (stk.top().height > rect.height) {\n          int target = j;\n          while (!stk.empty() && stk.top().height >= rect.height) {\n            Rectangle pre = stk.top(); stk.pop();\n            int area = pre.height * (j - pre.pos);\n            maxArea = max(maxArea, area);\n            target = pre.pos;\n          }\n          rect.pos = target;\n          stk.push(rect);\n        }\n      }\n    }\n    if (!stk.empty()) {\n      rect = stk.top(); stk.pop();\n      while (!stk.empty() && stk.top().height >= rect.height) {\n        Rectangle pre = stk.top(); stk.pop();\n        int area = pre.height * (W-1 - pre.pos);\n        maxArea = max(maxArea, area);\n      }\n      maxArea = max(maxArea, rect.height);\n    }\n  }\n\n  cout << maxArea << endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<stack>\n#include<algorithm>\n#define MAX 1400\n\nusing namespace std;\n\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectangle(int size, int buffer[]) {\n  stack<Rectangle> S;\n  int maxv = 0;\n  buffer[size] = 0;\n\n  for ( int i = 0; i <= size; i++ ) {\n    Rectangle rect;\n    rect.height = buffer[i];\n    rect.pos = i;\n    if ( S.empty() ) {\n      S.push(rect);\n    } else {\n      if ( S.top().height < rect.height ) {\n        S.push(rect);\n      } else if ( S.top().height > rect.height ) {\n        int target = i;\n        while ( !S.empty() && S.top().height >= rect.height ) {\n          Rectangle pre = S.top(); S.pop();\n          int area = pre.height * (i - pre.pos);\n          maxv = max(maxv, area);\n          target = pre.pos;\n        }\n        rect.pos = target;\n        S.push(rect);\n      }\n    }\n  }\n  return maxv;\n}\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle() {\n  for ( int j = 0; j < W; j++ )\n    for ( int i = 0; i < H; i++ ) {\n      if ( buffer[i][j] )\n        T[i][j] = 0;\n      else\n        T[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n    }\n\n  int maxv = 0;\n  for ( int i = 0; i < H; i++ )\n    maxv = max(maxv, getLargestRectangle(W, T[i]));\n\n  return maxv;\n}\n\nint main() {\n  scanf(\"%d %d\", &H, &W);\n  for ( int i = 0; i < H; i++ )\n    for ( int j = 0; j < W; j++ )\n      scanf(\"%d\", &buffer[i][j]);\n  cout << getLargestRectangle() << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <sstream>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n#define rrep(i, a) RREP(i, a, 0)\n#define RREP(i, a, b) for(int i = a; i >= b; --i)\n#define repll(i, a) REPLL(i, 0, a)\n#define REPLL(i, a, b) for(ll i = a; i < b; ++i)\n#define rrepll(i, a) RREPLL(i, a, 0)\n#define RREPLL(i, a, b) for(ll i = a; i >= b; --i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<int, P> PP;\nconst double PI = 3.14159265358979323846;\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+18 + 10;\n\nint h, w, ans = 0;\nint map[1405][1405];\n\nint main(){\n\tstd::cin >> h >> w;\n\trep(i, h){\n\t\trep(j, w)std::cin >> map[i][j], map[i][j] = (1 - map[i][j]);\n\t\tmap[i][w] = 0;\n\t}\n\n\trep(i, w){\n\t\tREP(j, 1, h)map[j][i] = (map[j][i] == 0 ? 0 : map[j - 1][i] + 1);\n\t}\n\n\trep(i, h){\n\t\tint max = 0;\n\t\tstd::stack<P> s;\n\t\trep(j, w + 1){\n\t\t\tif (s.empty() || s.top().first < map[i][j])s.push(P(map[i][j], j));\n\t\t\telse if (s.top().first > map[i][j]){\n\t\t\t\tint pos = j;\n\t\t\t\twhile (s.size() && s.top().first >= map[i][j]){\n\t\t\t\t\tP p = s.top(); s.pop();\n\t\t\t\t\tmax = std::max(max, p.first * (j - p.second));\n\t\t\t\t\tpos = p.second;\n\t\t\t\t}\n\t\t\t\ts.push(P(map[i][j], pos));\n\t\t\t}\n\t\t}\n\t\tans = std::max(max, ans);\n\t}\n\n\tstd::cout << ans << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node\n{\n    int x,y;\n};\nstack<node> d;\n#define mo 1500\nint a[mo][mo];\nint main()\n{\n    int n,m;\n    while(cin>>n>>m)\n    {\n        int x;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=m;j++)\n            {\n                cin>>x;\n                if(!x)\n                    a[i][j]+=a[i-1][j]+1;\n\n            }\n        }\n        /*\n        cout<<endl;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=m;j++)\n            {\n                cout<<a[i][j]<<' ';\n            }\n            cout<<endl;\n        }\n        */\n\n        node t;\n        int maxs=0;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=m;j++)\n            {\n                t.x=a[i][j];\n                t.y=j;\n               // cout<<maxs<<' ';\n                if(d.size()==0||t.x>d.top().x) d.push(t);\n                else\n                {\n                    int l=j;\n                    while(d.size()&&d.top().x>t.x)\n                    {\n                        maxs=max(maxs,(l-d.top().y)*d.top().x);\n                        d.pop();\n                    }\n                    d.push(t);\n                }\n            }\n            int l=d.top().y;\n            while(d.size()>0)\n            {\n                maxs=max(maxs,(l-d.top().y+1)*d.top().x);\n                d.pop();\n            }\n           // cout<<endl;\n\n        }\n        cout<<maxs<<endl;\n\n\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_3_B\n\nint LargestRectangleInAHistogram(vector<int> h) {\n  assert( h.size() );\n  stack<int> stk;\n  int n = (int)h.size();\n  vector<int> L(n), R(n);\n  for(int i=0;i<n;++i) {\n    while( !stk.empty() && h[stk.top()] >= h[i] ) stk.pop();\n    L[i] = (stk.empty()?0:stk.top()+1);\n    stk.push(i);\n  }\n  while( !stk.empty() ) stk.pop();\n  for(int i=n-1;i>=0;--i) {\n    while( !stk.empty() && h[stk.top()] >= h[i] ) stk.pop();\n    R[i] = (stk.empty()?n:stk.top());\n    stk.push(i);\n  }\n  int maxi = 0;\n  for(int i=0;i<n;++i) {\n    maxi = max(maxi,h[i]*(R[i]-L[i]));\n  }\n  return maxi;\n}\n\nint LargestRectangle(int H,int W,vector<vector<int> > c) {\n  vector<vector<int> > hs(H,vector<int>(W,0));\n  for(int i=0;i<H;++i) {\n    for(int j=0;j<W;++j) {\n      if( c[i][j] ) continue;\n      hs[i][j] = ((i-1>=0)?hs[i-1][j]:0) + 1;\n    }\n  }\n  int maxi = 0;\n  for(int i=0;i<H;++i) {\n    vector<int> h(W);\n    for(int j=0;j<W;++j) {\n      h[j] = hs[i][j];\n    }\n    maxi = max(maxi,LargestRectangleInAHistogram(h));\n  }\n  return maxi;\n}\n\nint main() {\n  int H,W;\n  cin >> H >> W;\n  vector<vector<int> > c(H,vector<int>(W));\n  for(int i=0;i<H;++i) for(int j=0;j<W;++j) cin >> c[i][j];\n  cout << LargestRectangle(H,W,c) << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps = 1e-9;\n\n// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\" > \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\b.txt\"\n\nconst int adx[] = { 1,1,1,0,-1,-1,-1,0 };\nconst int ady[] = { 1,0,-1,-1,-1,0,1,1 };\n\nint add(const int base, const int plus) {\n\tif (!plus) {\n\t\treturn base + 1;\n\t}\n\telse {\n\t\treturn 0;\n\t}\n}\n//0 :?????????1:??????2:?????????3:??? 4:?????????5:??? 6:?????? 7:??? ???\nvector<vector<vector<int>>>get_cumulative_sum(const vector<vector<int>>&field) {\n\tconst int H = field.size();\n\tconst int W = field[0].size();\n\n\tvector<vector<vector<int>>>sums(H, vector<vector<int>>(W, vector<int>(8)));\n\tfor (int ny = 0; ny <H; ++ny) {\n\t\tfor (int nx = 0; nx <W; ++nx) {\n\t\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\t\tint py = ny - ady[k];\n\t\t\t\tint px = nx - adx[k];\n\t\t\t\tif (!(px >= 0 && px <W && py >= 0 && py <H))continue;\n\n\t\t\t\tsums[ny][nx][k] = add(sums[py][px][k], field[ny][nx]);\n\n\t\t\t}\n\t\t}\n\t}\n\tfor (int ny = H - 1; ny >= 0; --ny) {\n\t\tfor (int nx = 0; nx <W; ++nx) {\n\t\t\tfor (int k = 2; k < 4; ++k) {\n\t\t\t\tint py = ny - ady[k];\n\t\t\t\tint px = nx - adx[k];\n\t\t\t\tif (!(px >= 0 && px <W && py >= 0 && py <H))continue;\n\n\t\t\t\tsums[ny][nx][k] = add(sums[py][px][k], field[ny][nx]);\n\n\t\t\t}\n\t\t}\n\t}\n\tfor (int ny = H - 1; ny >= 0; --ny) {\n\t\tfor (int nx = W - 1; nx >= 0; --nx) {\n\t\t\tfor (int k = 4; k < 6; ++k) {\n\t\t\t\tint py = ny - ady[k];\n\t\t\t\tint px = nx - adx[k];\n\t\t\t\tif (!(px >= 0 && px <W && py >= 0 && py <H))continue;\n\n\t\t\t\tsums[ny][nx][k] = add(sums[py][px][k], field[ny][nx]);\n\n\t\t\t}\n\t\t}\n\t}\n\tfor (int ny = 0; ny <H; ++ny) {\n\t\tfor (int nx = W - 1; nx >= 0; --nx) {\n\t\t\tfor (int k = 6; k < 8; ++k) {\n\t\t\t\tint py = ny - ady[k];\n\t\t\t\tint px = nx - adx[k];\n\t\t\t\tif (!(px >= 0 && px <W && py >= 0 && py <H))continue;\n\n\t\t\t\tsums[ny][nx][k] = add(sums[py][px][k], field[ny][nx]);\n\n\t\t\t}\n\t\t}\n\t}\n\treturn sums;\n}\n\nint getans( vector<int>hs) {\n\ths.emplace_back(0);\n\tstack<pair<int, int>>que;\n\tque.emplace(-1, 0);\n\tint ans = 0;\n\tfor (int x = 0; x < hs.size(); ++x) {\n\t\t\n\t\tif (que.empty()) {\n\t\t\tque.push(make_pair(x, hs[x]));\n\t\t}\n\t\telse {\n\t\t\twhile (!que.empty()) {\n\t\t\t\tauto p = que.top();\n\t\t\t\tif (p.second < hs[x]) {\n\t\t\t\t\tque.push(make_pair(x,hs[x]));\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse if (p.second == hs[x]) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint area = (x - p.first)*p.second;\n\t\t\t\t\tans = max(ans, area);\n\t\t\t\t\tque.pop();\n\t\t\t\t\tif (!que.empty()) {\n\t\t\t\t\t\tauto np = que.top();\n\t\t\t\t\t\tif (np.second < hs[x]) {\n\t\t\t\t\t\t\tque.push(make_pair(p.first, hs[x]));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t\t\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>>field(H + 2, vector<int>(W + 2,1));\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tcin >> field[i + 1][j + 1];\n\t\t}\n\t}\n\tauto vs = get_cumulative_sum(field);\n\tint ans = 0;\n\t\n\tfor (int y = 1; y <= H; ++y) {\n\t\tvector<int>v;\n\t\tfor (int x = 1; x <= W; ++x) {\n\t\t\tv.push_back(vs[y][x][3]);\n\t\t}\n\t\tans = max(ans, getans(v));\n\t}\n\tcout << ans << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nsize_t get_largest_rectangle(vector<vector<int>> &g) {\n    size_t h=g.size(), w=g[0].size();\n\n    vector<vector<size_t>> dp(h, vector<size_t>(w+1));\n    size_t max_area=0;\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j)\n            dp[i][j] = !g[i][j];\n\n    for (size_t i=1; i<h; ++i)\n        for (size_t j=0; j<w; ++j)\n            if (dp[i][j])\n                dp[i][j] += dp[i-1][j];\n\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j) {\n            if (!dp[i][j]) continue;\n\n            size_t min_height=dp[i][j];\n            for (size_t k=j+1; k<=w; ++k) {\n                if (max_area < (k-j)*min_height)\n                    max_area = (k-j)*min_height;\n\n                if (!dp[i][k])\n                    break;\n\n                if (min_height > dp[i][k])\n                    min_height = dp[i][k];\n            }\n        }\n\n    return max_area;\n}\n\nint main() {\n    size_t h, w;\n    scanf(\"%zu %zu\", &h, &w);\n\n    vector<vector<int>> g(h, vector<int>(w));\n    for (size_t i=0; i<h; ++i)\n        for (size_t j=0; j<w; ++j)\n            scanf(\"%d\", &g[i][j]);\n\n    printf(\"%zu\\n\", get_largest_rectangle(g));\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <stack>\nusing namespace std;\n\n\nint main(){\n    int W,H;\n    cin>>H>>W;\n    int dp[H][W];\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            int tile;\n            if(cin>>tile,tile==0){\n                dp[i][j]=(j?dp[i][j-1]:0)+1;\n            }else{\n                dp[i][j]=0;\n            }\n        }\n    }\n    int ans=0;\n    typedef pair<int,int> P;\n    stack<P,vector<P>> S;\n    for(int j=0;j<W;j++){\n        for(int i=0;i<H;i++){\n            if(S.empty()){\n                S.emplace(dp[i][j],i);\n                continue;\n            }\n            P p = S.top();\n            if(p.first==dp[i][j]){\n                continue;\n            }\n            if(p.first<dp[i][j]){\n                S.emplace(dp[i][j],i);\n                continue;\n            }\n            while(!S.empty()){\n                ans=max(ans,p.first*(i-p.second));\n                S.pop();\n                if(S.empty()){\n                    S.emplace(dp[i][j],p.second);\n                    break;\n                }\n                if(S.top().first>=dp[i][j]){\n                    p=S.top();\n                    continue;\n                }else{\n                    S.emplace(dp[i][j],p.second);\n                    break;\n                }\n            }\n        }\n        while(!S.empty()){\n            P p = S.top(); S.pop();\n            ans=max(ans,p.first*(H-p.second));\n        }\n    }\n    cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nint H,W;\nint c[1402][1402];\nint h[1402][1402];\n\nvoid prepare() {\n  for (int i = 1; i <= H; ++i) {\n    for (int j = 1; j <= W; ++j) {\n      h[i][j] = (c[i][j] + h[i-1][j])*c[i][j];\n    }\n  }\n}\n\nint solve_sub(int i) {\n  int ans = 0;\n  int last_j;\n  stack<pair<int, int>> s;\n  pair<int, int> tmp;\n  for (int j = 1; j <= W+1; ++j) {\n    if (s.empty() || (s.top().second < h[i][j])) {\n      s.push(make_pair(j, h[i][j]));\n    }\n    else {\n      while (!s.empty() && s.top().second >= h[i][j]) {\n        last_j = s.top().first;\n        ans = max(ans, (j-last_j)*(s.top().second));\n        s.pop();\n      }\n      s.push(make_pair(last_j, h[i][j]));\n    }\n  }\n  return ans;\n}\n\nint solve() {\n  int ans = 0;\n  for (int i = 1; i <= H; ++i) {\n    ans = max(ans, solve_sub(i));\n  }\n  return ans;\n}\n\nint main () {\n  cin>>H>>W;\n  for (int i = 0; i < H; ++i) {\n    for (int j = 0; j < W; ++j) {\n      cin>>c[i+1][j+1];\n      c[i+1][j+1] ^= 1;\n    }\n  }\n  prepare();\n  cout<<solve()<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 最大長方形\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<stack>\n#include<algorithm>\n#include<iostream>\n#include<cmath>\n#include<cassert>\n\n#include<vector>\n#include<queue>\n#include<set>\n\nusing namespace std;\n\n#define MAX 1400\n\nstruct Rectangle{ int height; int pos; };\n\nint getLargestRectangle( int size, int buffer[])\n{\n\tstack<Rectangle> S;\n\n\tint maxv = 0;\n\tbuffer[size] = 0;\n\n\tfor(int i = 0; i <= size; i++)\n\t{\n\t\tRectangle rect;\n\n\t\t// 追加したい要素を設定する\n\t\trect.height = buffer[i];\n\t\trect.pos = i;\n\n\t\tif( S.empty() )\n\t\t{\n\t\t\tS.push(rect);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif( S.top().height < rect.height )\n\t\t\t{\n\t\t\t\t// スタックの先頭要素よりも, 高さの高い要素はプッシュしていく\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t\telse if( S.top().height > rect.height )\n\t\t\t{\n\t\t\t\t// 追加する要素の高さが, スタックの先頭よりも低い時\n\t\t\t\tint target = i;\n\n\t\t\t\twhile( !S.empty() && S.top().height >= rect.height )\n\t\t\t\t{\n\t\t\t\t\t// スタックから取り出す要素の高さが, 追加要素よりも低くなるまで取り出しを続ける\n\t\t\t\t\tRectangle pre = S.top(); S.pop();\n\t\t\t\t\t// 面積を計算する\n\t\t\t\t\tint area = pre.height * ( i - pre.pos );\n\t\t\t\t\tmaxv = max(maxv, area);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\t// 追加要素の左端の位置を更新する\n\t\t\t\trect.pos = target;\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn maxv;\n}\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle()\n{\n\tfor( int j = 0; j < W; j++ )\n\t{\n\t\tfor( int i = 0; i < H; i++ )\n\t\t{\n\t\t\tif( buffer[i][j] )\n\t\t\t{\n\t\t\t\t// 汚れたタイルの時\n\t\t\t\tT[i][j] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tT[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxv = 0;\n\tfor( int i = 0; i < H; i++ )\n\t{\n\t\tmaxv = max( maxv, getLargestRectangle(W, T[i]) );\n\t}\n\n\treturn maxv;\n}\n\nint main()\n{\n\tscanf(\"%d %d\", &H, &W);\n\n\tfor( int i = 0; i < H; i++ )\n\t{\n\t\tfor( int j = 0; j < W; j++ )\n\t\t{\n\t\t\tscanf(\"%d\", &buffer[i][j]);\n\t\t}\n\t}\n\n\tcout << getLargestRectangle() << endl;\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nint H,W;\nint C[1410][1410];\nint S[1410][1410];\n\ndeque<pair<int,int>> Q; \nint main(){\n\tiostream::sync_with_stdio(false);\n\tcin>>H>>W;\n\tfor(int y=0;y<H;y++)\n\t\tfor(int x=0;x<W;x++)\n\t\t\tcin>>C[y][x];\n\tfor(int x=0;x<=W;x++)S[0][x]=0;\n\t//for(int y=0;y<=H;y++)S[y][0]=0;\n\tfor(int y=0;y<H;y++)\n\t\tfor(int x=0;x<W;x++)\n\t\t\tS[y+1][x]=C[y][x]==0?S[y][x]+1:0;\n\tint m=0;\n\t\n\tfor(int y=0;y<=H;y++){\n\t\tQ.clear();\n\t\tQ.emplace_front(0,0);\n\t\tfor(int x=0;x<W;x++){\n\t\t\twhile(Q.front().second>S[y][x]){\n\t\t\t\tm=max(m,(x-Q.front().first)*Q.front().second);\n\t\t\t\tQ.pop_front();\n\t\t\t}\n\t\t\tif(S[y][x]>Q.front().second){\n\t\t\t\tQ.emplace_front(x,S[y][x]);\n\t\t\t}\n\t\t}\n\t\tm=max(m,(W-Q.front().first)*Q.front().second);\n\t}\n\t\t\t\n\tcout<<m<<endl;\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 2000\nint x[MAX_N][MAX_N];\nint H, W;\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> x[i][j];\n\t\t}\n\t\tfor (int j = 1; j < W; j++) {\n\t\t\tif (x[i][j] == 1) {\n\t\t\t\tx[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i][j] = x[i][j - 1] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tint maxn = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tint X = x[i][j], cnt = 0;\n\t\t\tfor (int k = j; k >= 0; k--) {\n\t\t\t\tif (x[i][k] >= X) { cnt++; }\n\t\t\t\telse { break; }\n\t\t\t}\n\t\t\tmaxn = max(maxn, cnt*X);\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nint get_largest_rectangle(int c[],int size){\n    stack<pii> stk;\n    int res=0;\n    \n    rep(i,0,size){\n        pii rect;\n        rect.first=c[i];\n        rect.second=i;\n        if(stk.empty() or stk.top().first<rect.first) stk.push(rect);\n        else if(stk.top().first>rect.first){\n            int target=i;\n            while(!stk.empty() and stk.top().first>=rect.first){\n                pii pre=stk.top();\n                stk.pop();\n                int area=pre.first*(i-pre.second);\n                res=max(res,area);\n                target=pre.second;\n            }\n            rect.second=target;\n            stk.push(rect);\n        }\n    }\n    return res;\n}\n\nvoid solve(){\n    int h,w;\n    cin >> h >> w;\n    \n    static int c[1400][1400];\n    rep(i,0,h) rep(j,0,w){\n        cin >> c[i][j];\n        c[i][j]=(c[i][j]+1)%2;\n    }\n    \n    rep(i,1,h) rep(j,0,w) if(c[i-1][j] and c[i][j]) c[i][j]=c[i-1][j]+1;\n    \n    int ans=0;\n    rep(i,0,h) ans=max(ans,get_largest_rectangle(c[i],w));\n    cout << ans << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <cstring>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <functional>\n#include <map>\n#include <set>\n#include <cmath>\n#include <string>\n#define SIZE 200005\n#define INF 1000000005LL\n\nusing namespace std;\ntypedef long long int ll;\ntypedef pair <int,int> P;\n\nint n;\nint h,w;\nll K;\nint S[1403][1403];\n//int dp[1403][1403];\nstack<P> T;\n\nvoid dp_init(){\n\tfor(int i=0;i<w;i++){\n\t\tS[0][i] = 0;\n\t\tfor(int j=1;j<=h;j++){\n\t\t\tS[j][i] = (S[j][i]==1?0:(S[j-1][i]+1));\n\t\t}\n\t}\n}\n\nvoid solve(){\n\tint cnt=0;\n\tint maxv = 0;\n\tfor(int i=1;i<=h;i++){\n\t\tcnt = 0;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(T.empty())T.push(make_pair(cnt,S[i][j]));\n\t\t\telse if(T.top().second < S[i][j]){\n\t\t\t\tT.push(make_pair(cnt,S[i][j]));\n\t\t\t}else if(T.top().second > S[i][j]){\n\t\t\t\twhile(!T.empty()){\n\t\t\t\t\tif(T.top().second > S[i][j]){\n\t\t\t\t\t\tmaxv = max(maxv,(cnt-T.top().first)*T.top().second);\n\t\t\t\t\t\tT.pop();\n\t\t\t\t\t\t//printf(\"%d+\",maxv);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tif(T.top().second < S[i][j])T.push(make_pair(cnt,S[i][j]));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(T.empty())T.push(make_pair(cnt,S[i][j]));\n\t\t\t}\n\t\t\tcnt++;\n\t\t\t//printf(\"%d \",maxv);\n\t\t}\n\t\twhile(!T.empty()){\n\t\t\tmaxv = max(maxv,(cnt-T.top().first)*T.top().second);\n\t\t\tT.pop();\n\t\t\t//printf(\"%d+\",maxv);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",maxv);\n}\n\nint main()\n{\n\tscanf(\"%d %d\",&h,&w);\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tscanf(\"%d\",&S[i][j]);\n\t\t}\n\t}\n\tdp_init();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>   \n#include<cstdio>  \n#include<algorithm>\n#include<stack>\nusing namespace std;\nconst int maxx = 1410;\n\nint H, W;\nint buffer[maxx][maxx];\nint T[maxx][maxx];\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectangle(int size, int height[]) {\n    stack<Rectangle> S;\n    int maxv = 0;\n    // 使得栈顶元素必定大于最后元素，使得前面的值被计算进来\n    height[size] = 0;\n\n    for (int i = 0; i <= size; i++) {\n        Rectangle rect;\n        rect.height = height[i];\n        rect.pos = i;\n        // 当S为空\n        if (S.empty())\n            S.push(rect);\n        // 栈顶的高度小于当前的高度\n        else if (S.top().height < rect.height)\n            S.push(rect);\n        // 栈顶的高度大于当前的高度\n        else if (S.top().height > rect.height) {\n            int target = i;\n            // 栈顶的高度大于等于当前的高度\n            // 出现小于栈顶高度的代表pre.pos~i之间都存在高度为pre.height的干净瓷砖\n            // 此时可以计算当前的面积\n            while (!S.empty() && S.top().height >= rect.height) {\n                Rectangle pre = S.top(); S.pop();\n                // 长 * 宽\n                int area = pre.height * (i - pre.pos);\n                maxv = max(maxv, area);\n                target = pre.pos;\n            }\n            // 加上前面的宽度（下标设置为之前的），以便后面有合适的瓷砖进行计算\n            rect.pos = target;\n            S.push(rect);\n        }\n    }\n    return maxv;\n}\n\nint solve() {\n    // 以行为直方图,计算纵向的干净长度\n    for (int j = 0; j < W; j++) {\n        for (int i = 0; i < H; i++) {\n            if (buffer[i][j])\n                T[i][j] = 0;\n            else\n                T[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n        }\n    }\n\n    // 从行计算出当前行的最大面积\n    int maxv = 0;\n    for (int i = 0; i < H; i++)\n        maxv = max(maxv, getLargestRectangle(W, T[i]));\n    return maxv;\n}\nint main()\n{\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++)\n        for (int j = 0; j < W; j++)\n            scanf(\"%d\", &buffer[i][j]);\n\n    printf(\"%d\\n\", solve());\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Edge{\n\t  int to,c;\n\t  Edge(int ti, int ci){\n\t\t\tto = ti; c = ci;\n\t  }\n};\n\ntypedef vector<Edge> ve;\ntypedef vector<ve> graph;\n\n\nint N,X;\n\nset<int> sum_list;\nvector<int> list_;\nvoid dfs(graph& g, int corr, int pre){\n\n\t  \n\t  int pre_edge_c = list_[ list_.size()-1 ];\n\t  for(int i=0; i<g[corr].size(); i++){\n\t\t\tif(g[corr][i].to == pre) continue;\n\t\t\tg[corr][i].c ^=  pre_edge_c;\n//\t\t\tcout << corr+1 << \" -> \" << g[corr][i].to+1 << \" \" << g[corr][i].c << endl;\n\t\t\tint k=0;\n\t\t\tfor(int j=0; j<g[i].size(); j++) if(g[i][j].to == corr) k = j;\n\t\t\tg[i][k].c = g[corr][i].c;\n\t\t\tsum_list.insert( g[corr][i].c );\n\t\t\tlist_.push_back( g[corr][i].c );\n\t\t\tdfs(g, g[corr][i].to, corr);\n\t  }\n\t  \n\n}\nvoid dump(graph& g){\n\n\t  for(int i=0; i<g.size(); i++)\n\t\t\tfor(Edge e : g[i])\n\t\t\t\t  cout << i+1 << \" -> \"<< e.to+1 << \":\" << e.c << endl;\n\n}\n\nint main(){\n\n\t  cin >> N >> X;\n\t  graph g(N);\n\t  for(int i=0; i<N-1; i++){\n\t\t\tint x,y,c; cin >> x >> y >> c;\n\t\t\tg[x-1].push_back( Edge(y-1,c) );\n\t\t\tg[y-1].push_back( Edge(x-1,c) );\n\t  }\n\t  int leaf;\n\t  for(int i=0; i<N; i++)\n\t\t\tif(g[i].size() == 1) leaf = i;\n\t  cout << leaf << endl;\n//\t  dump(g);\n\t  list_.push_back(0);\n\t  dfs(g,leaf,-1);\n//\t  dump(g);\n\n//\t  for(int x : sum_list)\t\t\tcout << x << \" \"<< endl;\n\t  int ans = 0;\n\t  for(int i=1; i<list_.size(); i++){\n\t\t\tif(sum_list.find( list_[i]^X ) == sum_list.end()) ans++;\n\t  }\n\t  cout << ans << endl;\n\t  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\nconst int INF = 1<<28;\n#define MAX 1401\n\nint dp[MAX][MAX];\n\nint solve(int H, int W) {\n\tREP(j,W) {\n\t\tint v = 1;\n\t\tREP(i, H) {\n\t\t\tif(!dp[i][j])\n\t\t\t\tv = 0;\n\t\t\tdp[i][j] = v++;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tREP(i, H) {\n\t\tpair<int, int> p, p2;\n\t\tstack< pair<int, int> > s;\n\t\tREP(j, W) {\n\t\t\tp = make_pair(dp[i][j], j);\n\t\t\tif(s.empty())\n\t\t\t\ts.push(p);\n\t\t\telse {\n\t\t\t\tif(s.top().first < p.first)\n\t\t\t\t\ts.push(p);\n\t\t\t\telse if(s.top().first > p.first) {\n\t\t\t\t\tint pnt = j;\n\t\t\t\t\twhile(!s.empty() && s.top().first >= p.first) {\n\t\t\t\t\t\tp2 = s.top(); s.pop();\n\t\t\t\t\t\tans = max(ans, p2.first * (j - p2.second));\n\t\t\t\t\t\tpnt = p2.second;\n\t\t\t\t\t}\n\t\t\t\t\tp.second = pnt;\n\t\t\t\t\ts.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tREP(i, H) REP(j, W) {\n\t\tcin >> dp[i][j];\n\t\tdp[i][j] = !dp[i][j];\n\t}\n\tcout << solve(H, W) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nstruct elem {\n\tint pos, height;\n};\n\nint getArea(int V[], int W) {\n\tint area = 0;\n\tstack<elem> S;\n\tfor (int i = 0; i <= W; ++i) {\n\t\telem e;\n\t\te.pos = i;\n\t\tif (i == W) {\n\t\t\te.height = 0;\n\t\t} else {\n\t\t\te.height = V[i];\n\t\t}\n\t\tif (S.empty() || e.height > S.top().height) {\n\t\t\tS.push(e);\n\t\t} else {\n\t\t\tint prepos = i;\n\t\t\twhile (!S.empty() && S.top().height > e.height) {\n\t\t\t\telem target = S.top();\n\t\t\t\tS.pop();\n\t\t\t\tarea = max(area, (i - target.pos) * target.height);\n\t\t\t}\n\t\t\te.pos = prepos;\n\t\t\tS.push(e);\n\t\t}\n\t}\n\treturn area;\n}\nint main() {\n\tint H, W;\n\tscanf(\"%d %d\", &H, &W);\n\tint A[H][W];\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tscanf(\"%d\", &A[i][j]);\n\t\t}\n\t}\n\n\tint V[H][W];\n\tfor (int j = 0; j < W; ++j) {\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tif (A[i][j] == 1) {\n\t\t\t\tV[i][j] = 0;\n\t\t\t} else {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tV[i][j] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tV[i][j] = V[i - 1][j] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxv = 0;\n\tfor (int i = 0; i < H; ++i) {\n\t\tmaxv = max(maxv, getArea(V[i], W));\n\t}\n\tcout << maxv << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n    int height;\n    int pos;\n};\n\nint main()\n{\n    int H, W;\n    cin >> H >> W;\n    int color;\n    int Table[H + 1][W + 1];\n    for(int i = 0; i <= W; i++)\n        Table[0][i] = 0;\n\n    for(int i = 1; i <= H; i++)\n    {\n        for(int j = 1; j <= W; j++)\n        {\n            cin >> color;\n            Table[i][j] = (color == 0 ? Table[i - 1][j] + 1 : 0);\n        }\n    }\n\n    /*\n    for(int i = 1; i <= H; i++)\n    {\n        cout << Table[i][1];\n        for(int j = 2; j <= W; j++)\n        {\n            cout << \" \" << Table[i][j];\n        }\n        cout << endl;\n    }\n     */\n\n    int max_area = 0;\n    for(int i = 1; i <= H; i++)\n    {\n        stack<Rectangle> S;\n        for(int j = 1; j <= W + 1; j++)\n        {\n            Rectangle rect{};\n            rect.height = (j == W + 1 ? 0 : Table[i][j]);\n            rect.pos = j;\n            if(S.empty())\n                S.push(rect);\n            else\n            {\n                if(S.top().height < rect.height)\n                    S.push(rect);\n                else if(S.top().height > rect.height)\n                {\n                    int target = j;\n                    while(!S.empty() && S.top().height >= rect.height)\n                    {\n                        Rectangle pre = S.top();\n                        S.pop();\n                        max_area = max(max_area, pre.height * (j - pre.pos));\n                        target = pre.pos;\n                    }\n                    rect.pos = target;\n                    S.push(rect);\n                }\n            }\n        }\n    }\n\n    cout << max_area << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "   #include <bits/stdc++.h>\n \n//    #include <boost/multiprecision/cpp_int.hpp>\n #define int long long\n #define inf  1000000007\n// #define inf  998244353\n\n #define pa pair<int,int>\n #define ll long long\n #define pal pair<double,double>\n #define ppap pair<pa,int>\n  #define PI 3.14159265358979323846\n  #define paa pair<int,char>\n  #define  mp make_pair\n  #define  pb push_back\n  #define EPS (1e-8)\n                                          \n    int dx[8]={0,1,0,-1,1,1,-1,-1};\n    int dy[8]={1,0,-1,0,-1,1,1,-1};\n                                            using namespace std;\n                                   \t\t\tclass pa3{\n                                            \tpublic:\n                                            \tint x;\n                                   \t\t\t\tint y,z;\n                                            \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                            \tbool operator < (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\t return z<p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                   \t\t\t\tbool operator > (const pa3 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\t return z>p.z;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa3 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z;\n                                            \t}\n                                            \t\tbool operator != (const pa3 &p) const{\n                                            \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                            \t}\n                                            \n                                            };\n                                            \n                                            class pa4{\n                                            \tpublic:\n                                            \tint x;\n                                            \tint y,z,w;\n                                            \tpa4(int x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                            \tbool operator < (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x<p.x;\n                                            \t\tif(y!=p.y) return y<p.y;\n                                            \t\tif(z!=p.z)return z<p.z;\n                                            \t\treturn w<p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator > (const pa4 &p) const{\n                                            \t\tif(x!=p.x) return x>p.x;\n                                            \t\tif(y!=p.y) return y>p.y;\n                                            \t\tif(z!=p.z)return z>p.z;\n                                            \t\treturn w>p.w;\n                                            \t\t//return x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa4 &p) const{\n                                            \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            class pa2{\n                                            \tpublic:\n                                            \tint x,y;\n                                            \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                            \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                            \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                            \tbool operator < (const pa2 &p) const{\n                                            \t\treturn y != p.y ? y<p.y: x<p.x;\n                                            \t}\n                                            \tbool operator > (const pa2 &p) const{\n                                            \t\treturn x != p.x ? x<p.x: y<p.y;\n                                            \t}\n                                            \tbool operator == (const pa2 &p) const{\n                                            \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                            \t}\n                                            \tbool operator != (const pa2 &p) const{\n                                            \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                            \t}\n                                            \t\t\n                                            \n                                            };\n                                            \n \n                      \n                                string itos( int i ) {\n                                ostringstream s ;\n                                s << i ;\n                                return s.str() ;\n                                }\n                                 \n                                int Gcd(int v,int b){\n                                \tif(v==0) return b;\n                                \tif(b==0) return v;\n                                \tif(v>b) return Gcd(b,v);\n                                \tif(v==b) return b;\n                                \tif(b%v==0) return v;\n                                \treturn Gcd(v,b%v);\n                                }\n                 \n                            \n                                int mod;\nint extgcd(int a, int b, int &x, int &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    int d = extgcd(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\npa operator+(const pa & l,const pa & r) {   \n    return {l.first+r.first,l.second+r.second};                                    \n}    \npa operator-(const pa & l,const pa & r) {   \n    return {l.first-r.first,l.second-r.second};                                    \n}  \n                int beki(int wa,int rr,int warukazu){\n                \tif(rr==0) return 1%warukazu;\n                \tif(rr==1) return wa%warukazu;\n                \twa%=warukazu;\n                \tif(rr%2==1) return ((ll)beki(wa,rr-1,warukazu)*(ll)wa)%warukazu;\n                \tll zx=beki(wa,rr/2,warukazu);\n                \treturn (zx*zx)%warukazu;\n                }\n \n                              \n                int pr[100000];\n                int inv[100000];\n                \n\n                \n    \t\t\tint comb(int nn,int rr){\n    \t\t\t\tif(rr<0 || rr>nn || nn<0) return 0;\n    \t\t\t\tint r=pr[nn]*inv[rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\tr*=inv[nn-rr];\n    \t\t\t\tr%=mod;\n    \t\t\t\treturn r;\n    \t\t\t}\n               \n                void gya(int ert){\n                \tpr[0]=1;\n                \tfor(int i=1;i<=ert;i++){\n                \t\tpr[i]=((ll)pr[i-1]*i)%mod;\n                \t}\n                \t\tinv[ert]=beki(pr[ert],mod-2,mod);\n                \tfor(int i=ert-1;i>=0;i--){\n                \t\tinv[i]=(ll)inv[i+1]*(i+1)%mod;\n                \t}\n                }\n                \n              //   cin.tie(0);\n    \t\t//\tios::sync_with_stdio(false);\n    \t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n                 //sort(ve.begin(),ve.end(),greater<int>());\n //   mt19937(clock_per_sec);\n  //  mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count()) ;\n\nint a[2000][2000];\nint ue[2000][2000]={};\n\n\nvoid solve(){\nint h,w;\n\tint ans=0;\n\tcin>>h>>w;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tcin>>a[i][j];\n\t\t\tif(i==1){\n\t\t\t\tif(a[i][j]==1)ue[i][j]=0;\n\t\t\t\telse ue[i][j]=1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tif(a[i][j]==1)ue[i][j]=0;\n\t\t\t\telse ue[i][j]=ue[i-1][j]+1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tvector<pa> ve;\n\t\tve.pb(mp(0,0));\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tif(ve.back().first<ue[i][j])ve.pb(mp(ue[i][j],j));\n\t\t\tif(ue[i][j+1]<ue[i][j]){\n\t\t\t\tint p=-1;\n\t\t\t\twhile(ve.back().first>ue[i][j+1]){\n\t\t\t\t\tpa z=ve.back();\n\t\t\t\t\tve.pop_back();\n\t\t\t\t\tans=max(ans,z.first*(j-z.second+1));\n\t\t\t\t\tp=z.second;\n\t\t\t\t}\n\t\t\t\tif(p>=0)ve.pb(mp(ue[i][j+1],p));\n\t\t\t}\n\t\t}\n\t}\n\tcout<<ans<<endl;\n}\nsigned main(){\n\t\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\nint n=1;\n\t//cin>>n;\n\t\n\t\n\tfor(int i=0;i<n;i++)solve();\n\t\n\treturn 0;\n }\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) FOR(i,0,n)\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n#define PB push_back\n#define LB lower_bound\n#define UB upper_bound\n#define PQ priority_queue\n#define UM unordered_map\n#define ALL(a) (a).begin(),(a).end()\ntypedef vector<ll> vi;\ntypedef vector<vector<ll>> vvi;\nconst ll INF = (1ll << 60);\ntypedef pair<ll,ll> pii;\n\nll largestAreaHistogram(vi v){\n  ll N=v.size();\n  stack<pii> st; st.push({0,v[0]});\n  ll ans=v[0];\n  FOR(i,1,N) {\n    ll tmp=i;\n    while(st.size()&&st.top().second>v[i]) {\n      ans=max(ans,st.top().second*(i-st.top().first));\n      tmp=st.top().first;\n      st.pop();\n    }\n    st.push({tmp,v[i]});\n  }\n  while(st.size()) {\n    ans=max(ans,st.top().second*(N-st.top().first));\n    st.pop();\n  }\n  return ans;\n}\n\nint main(){\n  ll H,W; cin>>H>>W;\n  vvi c(H,vi(W));\n  REP(h,H) REP(w,W) cin>>c[h][w];\n  vvi dp(H,vi(W));\n  REP(w,W) if(c[0][w]==0) dp[0][w]=1; else dp[0][w]=0;\n  FOR(h,1,H) REP(w,W) if(c[h][w]==0) dp[h][w]=dp[h-1][w]+1; else dp[h][w]=0;\n  ll ans=0; REP(h,H) ans=max(ans,largestAreaHistogram(dp[h]));\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int SIZE=1400;\nint H,W;\nint fld[SIZE][SIZE];\n\n\nint solve(int *H){\n    int L[SIZE],R[SIZE];\n\n    stack<int>S;\n\n    for(int i=0;i<W;i++){\n        while(S.size()&&H[S.top()]>=H[i])S.pop();\n        if(S.empty())L[i]=i;\n        else L[i]=i-S.top()-1;\n        S.push(i);\n    }\n\n    S=stack<int>();\n\n    for(int i=W-1;i>=0;i--){\n        while(S.size()&&H[S.top()]>=H[i])S.pop();\n        if(S.empty())R[i]=W-i-1;\n        else R[i]=S.top()-i-1;\n        S.push(i);\n    }\n    //cout<<\"H :\";for(int i=0;i<W;i++)cout<<H[i]<<\" \";cout<<endl;\n    //cout<<\"L :\";for(int i=0;i<W;i++)cout<<L[i]<<\" \";cout<<endl;\n    //cout<<\"R :\";for(int i=0;i<W;i++)cout<<R[i]<<\" \";cout<<endl;\n    int ret=0;\n    for(int i=0;i<W;i++)ret=max(ret,H[i]*(L[i]+R[i]+1));\n    return ret;\n}\n\nint main(){\n    cin>>H>>W;\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            cin>>fld[i][j];\n            if(fld[i][j]==1){\n                fld[i][j]=0;\n            }\n            else{\n                fld[i][j]=(i?fld[i-1][j]:0)+1;\n            }\n        }\n    }\n\n    int ma=0;\n    for(int i=0;i<H;i++)ma=max(ma,solve(fld[i]));\n\n    cout<<ma<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stack>\n#include <utility>\nusing namespace std;\ntypedef pair<int,int> pi;\n#define F first\n#define S second\n#define MP make_pair\nconst int N=5e2+10;\nint main(){\n    int n,m,a[N][N],now,ans,nx;\n    pi temp;\n    stack<pi> s;\n    while(true){\n        scanf(\"%d%d\",&n,&m);\n        if(n==0&&m==0)return 0;\n        ans=0;\n        for(int i=0;i<n;i++){\n            now=0;\n            for(int j=0;j<m;j++){\n                scanf(\"%d\",&nx);\n                if(nx==1)now++;\n                else now=0;\n                a[i][j]=now;\n            }\n        }\n        for(int j=0;j<m;j++){\n            while(!s.empty())s.pop();\n            for(int i=0;i<n;i++){\n                while(!s.empty()){\n                    if(s.top().F>a[i][j]){\n                        temp=s.top();\n                        s.pop();\n                        if(s.empty())ans=max(ans,temp.F*i);\n                        else ans=max(ans,temp.F*(i-1-s.top().S));\n                    }\n                    else break;\n                }\n                s.push(MP(a[i][j],i));\n            }\n            while(!s.empty()){\n                temp=s.top();\n                s.pop();\n                if(s.empty())ans=max(ans,temp.F*n);\n                else ans=max(ans,temp.F*(n-s.top().S-1));\n                \n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nclass Rect {\npublic:\n  int h, idx;\n  Rect(int h, int idx): h(h), idx(idx) {}\n};\n\nint max_from_hist(vector<int> cols) {\n  stack<Rect> s;\n  int max_v = 0;\n  cols[cols.size()] = 0;\n\n  for (int i = 0; i <= cols.size(); i++) {\n    Rect r(cols[i], i);\n\n    if (s.empty() || s.top().h < cols[i]) {\n      s.push(r);\n    } else if (s.top().h > cols[i]) {\n      int pos = i;\n\n      while (!s.empty() && s.top().h >= r.h) {\n        Rect pre = s.top(); s.pop();\n        int area = pre.h * (i - pre.idx); // h * colnum\n        max_v = max(max_v, area);\n        pos = pre.idx;\n      }\n\n      s.push(Rect(cols[i], pos));\n    }\n  }\n\n  return max_v;\n}\n\nint main() {\n  int h, w; cin >> h >> w;\n\n  vector<vector<int> > T(h, vector<int>(w, 0));\n  vector<vector<int> > A(h, vector<int>(w, 0));\n\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      cin >> T[i][j];\n    }\n  }\n\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      if (T[i][j]) A[i][j] = 0;\n      else A[i][j] = (i ? A[i-1][j] + 1 : 1);\n    }\n  }\n\n  int max_v = 0;  \n\n  for (int i = 0; i < h; i++)\n    max_v = max(max_v, max_from_hist(A[i]));\n\n  cout << max_v << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<30;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-9;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint h,w;\nvi b;\n\nint main(){\n\tcin>>h>>w;\n\tb=vi(w+1);\n\tint res=0;\n\tfor(int i=0;i<h;i++){\n\t\tstack<pip> st;\n\t\tst.push({-1,{-1,-1}});\n\t\tfor(int j=0;j<=w;j++){\n\t\t\tif(j<w){\n\t\t\t\tint x;\n\t\t\t\tcin>>x;\n\t\t\t\tif(!x) b[j]++;\n\t\t\t\telse b[j]=0;\n\t\t\t}\n\t\t\twhile(st.top().first>b[j]){\n\t\t\t\tpip p=st.top();st.pop();\n//\t\t\t\tcout<<p.second<<' '<<j<<' '<<p.first<<endl;\n\t\t\t\tres=max(res,(j-p.second.first)*p.first);\n\t\t\t}\n//\t\t\tcout<<j<<' '<<st.top().second.second+1<<endl;\n\t\t\tst.push({b[j],{st.top().second.second+1,j}});\n\t\t}\n//\t\tfor(auto j:b) cout<<j<<' ';\n//\t\tcout<<endl;\n//\t\tcout<<res<<endl;\n\t}\n\tcout<<res<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "//Largest Rectangle\n#include<bits/stdc++.h>\nusing namespace std;\n\nint H, W;\nint mp[1400][1400];\nint h[1400][1400];\n\n//i?????????????????????????????°??????????????§????????¢?????§??????????±???????\nint max_rect(int i){\n  stack< pair<int, int> > st;\n  int ret=0;\n  for(int j=0; j<W; j++){\n    //?????????????????? ???????????? ???????????????????????????????´????????????????????????????\n    if(st.empty() || st.top().second<h[i][j]){\n      st.push(make_pair(j, h[i][j]));\n      continue;\n    }\n\n    //???????????????????????????????´????????????????????????????\n    if(st.top().second>h[i][j]){\n      int most_left=j;\n      while(!st.empty() && st.top().second>=h[i][j]){\n\tpair<int, int> tmp = st.top();\n\tst.pop();\n\tret=max(ret, (tmp.second * (j-tmp.first))); //??¢????¨????\n\tmost_left=tmp.first; //???????????´?????????x??§?¨??????????\n      }\n      st.push(make_pair(most_left, h[i][j]));\n    }\n  }\n  return ret;\n}\n\nint main(){\n  cin>>H>>W;\n  for(int i=0; i<H; i++)\n    for(int j=0; j<W; j++)\n      cin>>mp[i][j];\n\n  //???????????????????????¨??????????????????????±???????\n  //1??????\n  for(int i=0; i<W; i++){\n    if(mp[0][i] == 1){h[0][i] = 0;}\n    else{h[0][i] = 1;}\n  }\n  //2????????\\???\n  for(int i=1; i<H; i++){\n    for(int j=0; j<W; j++){\n      if(mp[i][j]==1){h[i][j] = 0;}\n      else{h[i][j] = h[i-1][j]+1;}\n    }\n  }\n\n  int ans=0;\n  for(int i=0; i<H; i++){\n    ans=max(ans, max_rect(i));\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<utility>\n#include<stack>\nusing namespace std;\n#define MS(m,z) memset(m,z,sizeof(m))\ntypedef unsigned U; typedef pair<int,int > P; typedef long long ll;\nvoid inp();\nint main(){\n#ifdef XS\n\tfreopen(\"findMaxRectangle.in\",\"r\",stdin);\n#endif\n\t//int n;scanf(\"%d\",&n);for(int i=1;i<=n;i++)\n\tinp();\n\treturn 0;\n}\nconst int N = 2000;\nint g[N][N];\nint s[N];\nint findMaxRectangle(int *a,int n){\n\tint cnt=0;\n\ta[n]=0; n++;\n\tint ma=0;\n\tfor(int i = 0;i<n;i++){\n\t\twhile(cnt&&a[s[cnt-1]]>a[i]){\n\t\t\tint cur=s[cnt-1];cnt--;\n\t\t\tint wid=cnt?(i-s[cnt-1]-1):i;\n\t\t\tma=max(ma,(a[cur])*wid);\n\t\t\t//printf(\"in %d cur %d wid:%d,ea:%d\\n\",i,cur,wid,a[cur]*wid);\n\t\t}\n\t\ts[cnt]=i; cnt++;\n\t}\n\treturn ma;\n}\nvoid inp(){\n\tint h,w,x;scanf(\"%d%d\",&h,&w);\n\tfor(int i =1;i<=h;i++){\n\t\tfor(int j =1;j<=w;j++){ scanf(\"%d\",&x);g[i][j]=!x; }\n\t}\n\tint ma=0;\n\t//int a[]={2,1,5,6,2,3},n=sizeof(a)/sizeof(int);\n\t//printf(\"%d\\n\",findMaxRectangle(a,n));\n\tfor(int i = 1;i<=h;i++){\n\t\tfor(int j =1;j<=w;j++){\n\t\t\tif(g[i-1][j]&&g[i][j])\n\t\t\t\tg[i][j]+=g[i-1][j];\n\t\t}\n\t\tma=max(ma,findMaxRectangle(&g[i][1],w));\n\t}\n\tprintf(\"%d\\n\",ma);\n}\n//findMaxRectangle.cc by xsthunder at Mon Aug 21 22:30:32 2017"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint c[1401][1401]={};\nint a(int x1,int x2,int y1,int y2){\n\tint b=c[x1][y1]+c[x2][y2]-c[x1][y2]-c[x2][y1];\n\tif(b!=0) b=1;\n\treturn b;\n}\nint main(){\n\tint h,w;\n\tcin >> h >> w;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tcin >> c[i][j];\n\t\t\tc[i][j] += c[i][j-1]+c[i-1][j]-c[i-1][j-1];\n\t\t}\n\t}\n\tint max=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tfor(int k=i+1;k<=h;k++){\n\t\t\t\tfor(int l=j+1;l<=w;l++){\n\t\t\t\t\tif(a(i,k,j,l)==0){\n\t\t\t\t\t\tif(max<(k-i)*(l-j)) max=(k-i)*(l-j);\n\t\t\t\t\t\tcout << i << j << k << l << endl;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << max << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nstruct node\n{\n    int x,y;\n};\nstack<node> d;\n#define mo 1500\nint a[mo][mo];\nint main()\n{\n    int n,m;\n    while(cin>>n>>m)\n    {\n        int x;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=m;j++)\n            {\n                cin>>x;\n                if(!x)\n                    a[i][j]+=a[i-1][j]+1;\n\n            }\n        }\n        /*\n        cout<<endl;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=m;j++)\n            {\n                cout<<a[i][j]<<' ';\n            }\n            cout<<endl;\n        }\n        */\n        node t;\n        int maxs=0;\n        for(int i=1;i<=n;i++)\n        {\n            for(int j=1;j<=m;j++)\n            {\n                t.x=a[i][j];\n                t.y=j;\n               // cout<<maxs<<' ';\n                if(d.size()==0||t.x>d.top().x) d.push(t);\n                else\n                {\n                    int l=d.top().y;\n                    while(d.size()&&d.top().x>=t.x)\n                    {\n                        maxs=max(maxs,(l-d.top().y+1)*d.top().x);\n                        d.pop();\n                    }\n                    d.push(t);\n                }\n            }\n            int l=d.top().y;\n            while(d.size()>0)\n            {\n                maxs=max(maxs,(l-d.top().y+1)*d.top().x);\n                d.pop();\n            }\n           // cout<<endl;\n\n        }\n        cout<<maxs<<endl;\n\n\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\nusing ll = long long;\n\nint main(){\n  int h, w;\n  cin >> h >> w;\n  int c[h][w];\n  rep(i,h) rep(j,w) cin >> c[i][j];\n  int hist[h][w];\n  rep(i,w) hist[0][i] = (c[0][i] == 0 ? 1 : 0);\n  for(int i = 1; i < h; i++)  rep(j,w)  hist[i][j] = (c[i][j] == 0 ?  hist[i-1][j] + 1 : 0);\n  ll ans = 0;\n  rep(x,h) {\n    ll l[w], r[w], st[w];\n    ll t = 0;\n    rep(i,w) {\n      while(t > 0 && hist[x][st[t-1]] >= hist[x][i]) t--;\n      l[i] = (t == 0 ? 0 : st[t-1]+1);\n      st[t++] = i;\n    }\n    t = 0;\n    for(int i = w-1; i >= 0; i--) {\n      while(t > 0 && hist[x][st[t-1]] >= hist[x][i]) t--;\n      r[i] = (t == 0 ? w : st[t-1]);\n      st[t++] = i; \n    }\n    rep(i,w) ans = max(ans,hist[x][i]*(r[i]-l[i]));\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<stack>\n#include<utility>\n\nusing namespace std;\n\n\nint getLargestRectangle(vector<int>& H) {\n  stack<pair<int, int> > S;\n  int maxv = 0;\n  H.push_back(0);\n\n  for (size_t i = 0; i < H.size(); ++i) {\n    pair<int, int> rect = make_pair(H[i], i);\n    if (S.empty()) {\n      S.push(rect);\n    } else {\n      if (S.top().first < rect.first)\n        S.push(rect);\n      else if (S.top().first > rect.first) {\n        int target = i;\n        while (!S.empty() && S.top().first >= rect.first) {\n          pair<int, int> pre = S.top(); S.pop();\n          int area = pre.first * (i - pre.second);\n          maxv = max(maxv, area);\n          target = pre.second;\n        }\n        rect.second = target;\n        S.push(rect);\n      }\n    }\n  }\n  return maxv;\n}\n\n\nint getLargestRectangle(int h, int w, const vector<vector<bool> >& g) {\n  vector<vector<int> > dp(h, vector<int>(w, 0));\n\n  for (int i = 0; i < h; ++i) {\n    for (int j = 0; j < w; ++j) {\n      if (g[i][j]) dp[i][j] = 0;\n      else {\n        dp[i][j] = (i > 0) ? dp[i-1][j]+1 : 1;\n      }\n    }\n  }\n\n  int maxv = 0;\n  for (int i = 0; i < h; ++i) {\n    maxv = max(maxv, getLargestRectangle(dp[i]));\n  }\n\n  return maxv;\n}\n\nvoid solve(int h, int w) {\n  vector<vector<bool> > g(h, vector<bool>(w, false));\n\n  for (int i = 0 ; i < h; ++i)\n    for (int j = 0; j < w; ++j) {\n      int p;\n      scanf(\"%d\", &p);\n      g[i][j] = p == 1;\n    }\n\n  printf(\"%d\\n\", getLargestRectangle(h, w, g));\n}\n\nint main() {\n\n  int h, w;\n  scanf(\"%d %d\", &h, &w);\n  \n  solve(h, w);\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <sstream>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n#define rrep(i, a) RREP(i, a, 0)\n#define RREP(i, a, b) for(int i = a; i >= b; --i)\n#define repll(i, a) REPLL(i, 0, a)\n#define REPLL(i, a, b) for(ll i = a; i < b; ++i)\n#define rrepll(i, a) RREPLL(i, a, 0)\n#define RREPLL(i, a, b) for(ll i = a; i >= b; --i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<int, P> PP;\nconst double PI = 3.14159265358979323846;\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+18 + 10;\n\nint h, w, ans = 0;\nint map[1405][1405];\n\nint main(){\n\tstd::cin >> h >> w;\n\trep(i, h){\n\t\trep(j, w)std::cin >> map[i][j], map[i][j] = (1 - map[i][j]);\n\t\tmap[i][w] = 1;\n\t}\n\n\trep(i, w){\n\t\tREP(j, 1, h)map[j][i] = (map[j][i] == 0 ? 0 : map[j - 1][i] + 1);\n\t}\n\n\trep(i, h){\n\t\tint max = 0;\n\t\tstd::stack<P> s;\n\t\trep(j, w + 1){\n\t\t\tif (s.empty() || s.top().first < map[i][j])s.push(P(map[i][j], j));\n\t\t\telse if (s.top().first > map[i][j]){\n\t\t\t\tint pos = j;\n\t\t\t\twhile (s.size() && s.top().first >= map[i][j]){\n\t\t\t\t\tP p = s.top(); s.pop();\n\t\t\t\t\tmax = std::max(max, p.first * (j - p.second));\n\t\t\t\t\tpos = p.second;\n\t\t\t\t}\n\t\t\t\ts.push(P(map[i][j], pos));\n\t\t\t}\n\t\t}\n\t\tans = std::max(max, ans);\n\t}\n\n\tstd::cout << ans << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <math.h>\n#include <stack>\n\nusing namespace std;\n\nstruct Info{\n\tInfo(){ left = height = 0;}\n\tInfo(int arg_left,int arg_height){\n\t\tleft = arg_left;\n\t\theight = arg_height;\n\t}\n\tint left,height;\n};\n\nint main(){\n\n\tint H,W,max_s,tmp,tmp_h;\n\n\tscanf(\"%d %d\",&H,&W);\n\n\tint** table = new int*[H+1];\n\tfor(int i = 0; i < H+1; i++){\n\t\ttable[i] = new int[W+1];\n\t}\n\n\tfor(int i = 0; i < W+1; i++)table[0][i] = 0;\n\tfor(int i = 0; i < H+1; i++)table[i][W] = 0;\n\n\tstack<Info> S;\n\tInfo work;\n\n\tmax_s = 0;\n\n\tfor(int i = 1;i <= H; i++){\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tscanf(\"%d\",&table[i][k]);\n\t\t\tif(table[i][k] == 0){\n\t\t\t\ttable[i][k] = table[i-1][k] + 1;\n\t\t\t}else{\n\t\t\t\ttable[i][k] = 0;\n\t\t\t}\n\t\t}\n\n\t\ttmp_h = table[i][0];\n\t\tS.push(Info(0,tmp_h));\n\n\t\tfor(int k = 1; k < W+1; k++){\n\t\t\tif(table[i][k] > tmp_h){\n\t\t\t\tS.push(Info(k,table[i][k]));\n\t\t\t\ttmp_h = table[i][k];\n\t\t\t}else if(table[i][k] == tmp_h){\n\n\t\t\t}else{\n\t\t\t\twhile(S.empty() == false && S.top().height >= table[i][k]){\n\t\t\t\t\twork = S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\ttmp = (k - work.left)*work.height;\n\t\t\t\t\tmax_s = (max_s >= tmp)?max_s:tmp;\n\t\t\t\t}\n\t\t\t\ttmp_h = table[i][k];\n\t\t\t\tS.push(Info(work.left,table[i][k]));\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_s);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <numeric>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <sstream>\n\n#define rep(i, a) REP(i, 0, a)\n#define REP(i, a, b) for(int i = a; i < b; ++i)\n#define rrep(i, a) RREP(i, a, 0)\n#define RREP(i, a, b) for(int i = a; i >= b; --i)\n#define repll(i, a) REPLL(i, 0, a)\n#define REPLL(i, a, b) for(ll i = a; i < b; ++i)\n#define rrepll(i, a) RREPLL(i, a, 0)\n#define RREPLL(i, a, b) for(ll i = a; i >= b; --i)\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef std::pair<int, int> P;\ntypedef std::pair<int, P> PP;\nconst double PI = 3.14159265358979323846;\nconst double esp = 1e-9;\nconst int infi = (int)1e+9 + 10;\nconst ll infll = (ll)1e+18 + 10;\n\nint h, w, ans = 0;\nint map[1401][1401];\n\nint main(){\n\tstd::cin >> h >> w;\n\trep(i, h){\n\t\trep(j, w)std::cin >> map[i][j], map[i][j] = (1 - map[i][j]);\n\t}\n\n\trep(i, w){\n\t\tREP(j, 1, h)map[j][i] = (map[j][i] == 0 ? 0 : map[j - 1][i] + 1);\n\t}\n\n\trep(i, h){\n\t\trep(j, w){\n\t\t\tstd::cout << map[i][j] << \" \";\n\t\t}\n\t\tstd::cout << std::endl;\n\t}\n\n\trep(i, h){\n\t\tint max = 0;\n\t\tstd::stack<P> s;\n\t\trep(j, w){\n\t\t\tif (s.empty() || s.top().first < map[i][j]){\n\t\t\t\ts.push(P(map[i][j], j));\n\t\t\t}\n\t\t\twhile (s.size() && s.top().first > map[i][j]){\n\t\t\t\tmax = std::max(max, s.top().first * (j - s.top().second));\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t\twhile (!s.empty()){\n\t\t\tmax = std::max(max, s.top().first * (w - s.top().second));\n\t\t\ts.pop();\n\t\t}\n\n\t\tmax = std::max(max, ans);\n\t}\n\n\tstd::cout << ans << std::endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <stack>\n#define MOD 1000000007\ntypedef long long ll;\nusing namespace std;\n\nint H,W;\nint c[1410][1410];\n\nint dp[1410][1410];\n\nvoid preset(){\n    for(int i=0;i<H;i++){\n        for(int j=0;j<W;j++){\n            if(c[i][j]==1) dp[i][j]=0;\n            else{\n                if(i>0) dp[i][j]+=dp[i-1][j];\n                dp[i][j]++;\n            }\n        }\n    }\n}\n\nint getLargestRectangle(int height){\n    int res=0;\n    dp[height][W]=0;\n    stack<pair<int,int>> ST;\n\n    for(int j=0;j<=W;j++){\n        if(ST.empty()) ST.push(make_pair(dp[height][j],j));\n        else{\n            pair<int,int> tp=ST.top();\n            int h=tp.first;\n            if(h==dp[height][j]) continue;\n            else if(h<dp[height][j]){\n                ST.push(make_pair(dp[height][j],j));\n            }else{\n                int target=j;\n                while(ST.size()&&ST.top().first>=dp[height][j]){\n                    pair<int,int> tp=ST.top();\n                    int h=tp.first;\n                    ST.pop();\n                    res=max(res,h*(j-tp.second));\n                    target=tp.second;\n                }\n                ST.push(make_pair(dp[height][j],target));\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n  cin>>H>>W;\n  for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n          cin>>c[i][j];\n      }\n  }\n\n  preset();\n\n  int ans=0;\n  for(int i=0;i<H;i++){\n      ans=max(ans,getLargestRectangle(i));\n  }\n  cout<<ans<<endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <queue>\n\nusing namespace std;\n\nstruct Node {\n   int index, value;\n   Node(int index = 0, int value = 0):index(index),value(value){\n   }  \n};\n\nint calHistrigramArea(const vector<int>& a) {\n    deque<Node> dq;\n    int ans = 0;\n    for (int i = 0; i < a.size(); i++) {\n        int e = a[i];\n        while (!dq.empty()) {\n            if (dq.back().value > e) {\n                int v = dq.back().value; dq.pop_back();\n                int leftIndex = dq.empty() ? -1 : dq.back().index;\n                ans = max(ans, (i - leftIndex - 1) * v);\n            } else {\n                break;\n            }\n        }\n        dq.push_back(Node(i, e));\n    }\n    \n    int i = a.size();\n    while (!dq.empty()) {\n        int v = dq.back().value;dq.pop_back();\n        int leftIndex = dq.empty() ? -1 : dq.back().index;\n        ans = max(ans, (i - leftIndex - 1) * v);\n    }\n    return ans;\n}\n\n\nint solve(const int n, const int m, const vector<vector<int>>& a) {\n    vector<int> dpc(m, 0);\n    int best = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (a[i][j] == 1) {\n                dpc[j] = 0;\n            }\n            else {\n                dpc[j]++;\n            }\n        }\n        best = max(best, calHistrigramArea(dpc));\n    }\n    return best;   \n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> matrix(n, vector<int>(m));\n    \n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            cin >> matrix[i][j];\n        }\n    }\n    \n    int ans = solve(n, m, matrix);\n    \n    cout << ans << endl;\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<stack>\n#include<algorithm>\n#define MAX 1400\n \nusing namespace std;\n \nstruct Rectangle{int height; int pos;};\n \nint getLargestRectangle(int size, int buffer[]){\n    stack<Rectangle> S;\n    int maxv = 0;\n    buffer[size] = 0;\n \n    for(int i = 0; i <= size; i++){\n        Rectangle rect;\n        rect.height = buffer[i];\n        rect.pos = i;\n        if(S.empty()){\n            S.push(rect);\n        }else{\n            if(S.top().height < rect.height){\n                S.push(rect);\n            }else if(S.top().height > rect.height){\n                int target = i;\n                while(!S.empty() && S.top().height >= rect.height){\n                    Rectangle pre = S.top(); S.pop();\n                    int area = pre.height * (i - pre.pos);\n                    maxv= max(maxv, area);\n                    target = pre.pos;\n                }\n                rect.pos = target;\n                S.push(rect);\n            }\n        }\n    }\n    return maxv;\n}\n \nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n \nint getLargestRectangle(){\n    for(int j = 0; j < W; j++){\n        for(int i = 0; i < H; i++){\n            if(buffer[i][j]){\n                T[i][j] = 0;\n            }else{\n                T[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n            }\n        }\n    }\n \n    int maxv = 0;\n    for(int i = 0; i < H; i++){\n        maxv = max(maxv, getLargestRectangle(W, T[i]));\n    }\n \n    return maxv;\n}\n \nint main(){\n    scanf(\"%d %d\", &H, &W);\n    for(int i = 0; i < H; i++){\n        for(int j = 0; j < W; j++){\n            scanf(\"%d\", &buffer[i][j]);\n        }\n    }\n    cout << getLargestRectangle() << endl;\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<stack>\nusing namespace std;\n\nstatic const int MAX = 1400;\n\nint h, m;\n\nint c[MAX + 1][MAX + 1];\n\nint dp[MAX + 1][MAX + 1];\n\nvoid histmake(){\n    for (int i = 1; i <= h; i++){\n        for (int j = 1; j <= m; j++){\n            if (c[i][j] == 1) dp[i][j] = 0;\n            else dp[i][j] = dp[i - 1][j] + 1;\n        }\n    }\n    return;\n}\n\nvoid solve(){\n    int ans = 0;\n    stack<pair<int, int> > s;\n\n    int pos;\n    for (int i = 1; i <= h; i++){\n        for (int j = 1; j <= m; j++){\n            if (dp[i][j] == 0){\n                while (!s.empty()){\n                    ans = max(ans, s.top().first * (j - s.top().second));\n                    s.pop();\n                }\n            }\n            else if (s.empty()) s.push(make_pair(dp[i][j], j));\n            else if (s.top().first < dp[i][j]) s.push(make_pair(dp[i][j], j));\n            else if (s.top().first == dp[i][j]) continue;\n            else{\n                while ((!s.empty()) && s.top().first > dp[i][j]){\n                    ans = max(ans, s.top().first * (j - s.top().second));\n                    pos = s.top().second;\n                    s.pop();\n                }\n                s.push(make_pair(dp[i][j], pos));\n            }\n        }\n        while (!s.empty()){\n            ans = max(ans, s.top().first * (m - s.top().second + 1));\n            s.pop();\n        }\n    }\n\n    cout << ans << endl;\n\n    return;\n}\n\nint main(){\n    cin >> h >> m;\n\n    for (int i = 1; i <= h; i++){\n        for (int j = 1; j <= m; j++){\n            scanf(\"%d\", &c[i][j]);\n        }\n    }\n\n    histmake();\n    solve();\n\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define REP(i,n) FOR(i,0,n)\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n#define PB push_back\n#define LB lower_bound\n#define UB upper_bound\n#define PQ priority_queue\n#define UM unordered_map\n#define ALL(a) (a).begin(),(a).end()\ntypedef vector<ll> vi;\ntypedef vector<vector<ll>> vvi;\nconst ll INF = (1ll << 60);\ntypedef pair<ll,ll> pii;\n\nll largestAreaHistogram(vi v){\n  ll N=v.size();\n  stack<pii> st; st.push({0,v[0]});\n  ll ans=v[0];\n  FOR(i,1,N) {\n    while(st.size()&&st.top().second>v[i]) {\n      ans=max(ans,st.top().second*(i-st.top().first));\n      st.pop();\n    }\n    if (st.empty()) st.push({0,v[i]}); else st.push({st.top().first+1,v[i]});\n  }\n  while(st.size()) {\n    ans=max(ans,st.top().second*(N-st.top().first));\n    st.pop();\n  }\n  return ans;\n}\n\nint main(){\n  ll H,W; cin>>H>>W;\n  vvi c(H,vi(W));\n  REP(h,H) REP(w,W) cin>>c[h][w];\n  vvi dp(H,vi(W));\n  REP(w,W) if(c[0][w]==0) dp[0][w]=1; else dp[0][w]=0;\n  FOR(h,1,H) REP(w,W) if(c[h][w]==0) dp[h][w]=dp[h-1][w]+1; else dp[h][w]=0;\n  ll ans=0; REP(h,H) ans=max(ans,largestAreaHistogram(dp[h]));\n  cout<<ans<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define all(v) begin(v), end(v)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 2000000000\n#define int long long int\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define LEQ(n, m) ((n) <= (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n#define GEQ(n, m) ((n) + EPS >= (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\nnamespace std {\n    bool operator<(const P& a, const P& b) {\n        return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n    }\n}\n\nint board[1500][1500];\nint dp[1500][1500];\n\nstruct Rectangle {\n    int height, pos;\n    Rectangle(int a, int b) : height(a), pos(b) {}\n};\n\nsigned main() {\n    int H, W; cin >> H >> W;\n    memset(dp, 0, sizeof(dp));\n    rep(i,0,H) rep(j,0,W) cin >> board[i][j];\n\n    rep(i,0,H) rep(j,0,W) {\n        if(board[i][j] == 1) dp[i][j] = 0;\n        else {\n            if(i == 0) dp[i][j] = 1;\n            else dp[i][j] = dp[i-1][j] + 1;\n        }\n    }\n\n    int ans = 0;\n    rep(i,0,H) {\n        stack<Rectangle> S;\n        repq(j,0,W) {\n            // printf(\"%lld \", dp[i][j]);\n            if(S.empty()) S.push(Rectangle(dp[i][j], j));\n            else {\n                Rectangle TopRect = S.top();\n                if(TopRect.height < dp[i][j]) S.push(Rectangle(dp[i][j], j));\n                else if(TopRect.height > dp[i][j]) {\n                    while(!S.empty() && TopRect.height > dp[i][j]) {\n                        int temp = (j-TopRect.pos) * TopRect.height;\n                        // printf(\"j = %lld, pos = %lld, height = %lld, temp = %lld\\n\", j, TopRect.pos, TopRect.height, temp);\n                        ans = max(ans, temp);\n                        S.pop();\n                        if(!S.empty()) TopRect = S.top();\n                    }\n                    if(S.empty()) S.push(Rectangle(dp[i][j], 0));\n                    else {\n                        TopRect = S.top();\n                        if(TopRect.height != dp[i][j]) S.push(Rectangle(dp[i][j], TopRect.pos+1));\n                    }\n                }\n            }\n        }\n        // cout << endl;\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define rep(i, n) for (int i = 0; i < (n); i++)\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\ntypedef pair<long, long> pll;\n\nconst int INF = 1 << 29;\nconst double EPS = 1e-9;\nconst int MOD = 100000007;\n\nconst int dx[] = {1, 0, -1, 0}, dy[] = {0, -1, 0, 1};\nconst int MAX_HW = 1500;\nint H, W;\nint board[MAX_HW][MAX_HW];\nint dp[MAX_HW][MAX_HW];\nint main() {\n  scanf(\"%d %d\", &H, &W);\n  for (int i = 1; i <= H; i++) {\n    for (int j = 1; j <= W; j++) {\n      scanf(\"%d\", &board[i][j]);\n    }\n  }\n  for (int j = 1; j <= W; j++) {\n    for (int i = 1; i <= H; i++) {\n      if (board[i][j] == 1) {\n        dp[i][j] = 0;\n      } else {\n        dp[i][j] = dp[i - 1][j] + 1;\n      }\n    }\n  }\n  int res = 0;\n  for (int i = 1; i <= H; i++) {\n    stack<pii> st;\n    for (int j = 1; j <= W; j++) {\n      if (st.empty()) {\n        st.push(mp(dp[i][j], j));\n      } else if (st.top().first < dp[i][j]) {\n        st.push(mp(dp[i][j], j));\n      } else if (st.top().first > dp[i][j]){\n        int target = i;\n        while (!st.empty() && st.top().first >= dp[i][j]) {\n          pii pre = st.top();\n          st.pop();\n          int area = pre.first * (j - pre.second);\n          res = max(res, area);\n          target = pre.second;\n        }\n        st.push(mp(dp[i][j], target));\n      }\n    }\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<stack>\n#include<algorithm>\nusing namespace std;\n#define MAX 1400\nstruct Rectangle{int height; int pos;};\n\nint getLargestRectangle(int size,int buffer[])\n{\n  stack<Rectangle> S;\n  int maxv=0;\n  buffer[size]=0;\n  for(int i=0;i<=size;i++)\n    {\n      Rectangle rect;\n      rect.height=buffer[i];\n      rect.pos=i;\n      if(S.empty())\n\t{\n\t  S.push(rect);\n\t}\n      else\n\t{\n\t  if(S.top().height < rect.height)\n\t    {\n\t      S.push(rect);\n\t    }\n\t  else if(S.top().height > rect.height)\n\t    {\n\t      int target=i;\n\t      while(!S.empty() && S.top().height >= rect.height)\n\t\t{\n\t\t  Rectangle pre = S.top();S.pop();\n\t\t  int area = pre.height * (i-pre.pos);\n\t\t  maxv=max(maxv,area);\n\t\t  target=pre.pos;\n\t\t}\n\t      rect.pos=target;\n\t      S.push(rect);\n\t    }\n\t}\n    }\n  return maxv;\n}\n\nint H,W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle()\n{\n  for(int j=0;j<W;j++)\n    {\n      for(int i=0;i<H;i++)\n\t{\n\t  if(buffer[i][j])\n\t    {\n\t      T[i][j]=0;\n\t    }\n\t  else\n\t    {\n\t      T[i][j]=(i > 0) ? T[i-1][j] + 1 : 1;\n\t    }\n\t}\n    }\n  int maxv=0;\n  for(int i=0;i<H;i++)\n    {\n      maxv=max(maxv,getLargestRectangle(W,T[i]));\n    }\n  return maxv;\n}\n\n\nint main(void)\n{\n  scanf(\"%d %d\",&H,&W);\n  for(int i=0;i<H;i++)\n    {\n      for(int j=0;j<W;j++)\n\t{\n\t  scanf(\"%d\",&buffer[i][j]);\n\t}\n    }\n  cout << getLargestRectangle() << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nconst int MAX = 1400;\n\nint main() {\n\tint H, W;\n\tint tile[MAX][MAX];\n\tint ans = 0;\n\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tscanf(\"%d\", &tile[i][j]);\n\t\t}\n\t}\n\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = W - 1; x >= 0; x--) {\n\t\t\tif (tile[y][x] == 1)tile[y][x] = -1;\n\t\t\telse if (x == W - 1)tile[y][x] = 0;\n\t\t\telse tile[y][x] = tile[y][x + 1] + 1;\n\t\t}\n\t}\n\n\tfor (int x = 0; x < W; x++) {\n\t\tstack<pair<int, int>> s;\n\t\ts.push(pair<int, int>(-1, -1));\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tif (s.top().second < tile[y][x]) {\n\t\t\t\ts.push(pair<int, int>(y, tile[y][x]));\n\t\t\t}\n\t\t\telse if (s.top().second > tile[y][x]) {\n\t\t\t\twhile (s.top().second > tile[y][x]) {\n\t\t\t\t\tans = max(ans, (y - s.top().first) * s.top().second);\n\t\t\t\t\ts.pop();\n\t\t\t\t}\n\t\t\t\tif(s.top().second != tile[y][x])s.push(pair<int, int>(y, tile[y][x]));\n\t\t\t}\n\t\t}\n\t\twhile (!s.empty()) {\n\t\t\tans = max(ans, (W - s.top().first) * s.top().second);\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint c[1401][1401]={};\nint a(int x1,int x2,int y1,int y2){\n\tint b=c[x1][y1]+c[x2][y2]-c[x1][y2]-c[x2][y1];\n\tif(b!=0) b=1;\n\treturn b;\n}\nint main(){\n\tint h,w;\n\tcin >> h >> w;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tcin >> c[i][j];\n\t\t\tc[i][j] += c[i][j-1]+c[i-1][j]-c[i-1][j-1];\n\t\t}\n\t}\n\tint max=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tfor(int k=i+1;k<=h;k++){\n\t\t\t\tfor(int l=j+1;l<=w;l++){\n\t\t\t\t\tif(a(i,k,j,l)==0){\n\t\t\t\t\t\tif(max<(k-i)*(l-j)) max=(k-i)*(l-j);\n\t\t\t\t\t\telse break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << max << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#define MAX 1400\nusing namespace std;\nint H, W, hSum[MAX+1][MAX+2];\n\nint main(){\n  cin >> H >> W;\n\n  for ( int j = 1; j <= W; j++){hSum[0][j] = 0;}\n  for ( int j = 1; j <= H;j++){hSum[j][0] = hSum[j][W+1] = 0;}\n\n  int a;\n  for ( int i = 1; i <= H; i++){\n    for ( int j = 1; j <= W; j++){\n      cin >> a;\n      if ( a == 1){ hSum[i][j] = 0;}\n      else { hSum[i][j] = hSum[i-1][j] + 1;}\n    }\n  }\n\n  int maxV = 0;\n  stack<pair<int, int> > S;\n  for ( int i = 1; i <= H; i++){\n    for ( int j = 1; j <= W+1; j++){\n      if ( j == 1 || hSum[i][j-1] <= hSum[i][j]) S.push(make_pair(j, hSum[i][j]));\n      else {\n        int pos = j;\n        while ( !S.empty() && S.top().second >= hSum[i][j]){\n          pair<int, int> top = S.top(); S.pop();\n          int area = top.second * ( j - top.first);\n          maxV = max(maxV, area);\n          pos = top.first;\n        }\n        S.push(make_pair(pos, hSum[i][j]));\n      }\n    }\n  }\n\n  cout << maxV << endl;\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\nusing namespace std;\n\nint main(){\n\tint h, w;\n\tcin >> h >> w;\n\tint64_t ans = 0, dp[2][1400 + 1]{};\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tcin >> dp[i & 1][j];\n\t\t\tdp[i & 1][j] = !dp[i & 1][j];\n\t\t\tif(dp[i & 1][j] == 0) continue;\n\t\t\tdp[i & 1][j] += dp[!(i & 1)][j];\n\t\t}\n\t\tdp[i & 1][w] = 0;\n\t\tstack<int64_t> st;\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(st.empty()){\n\t\t\t\tst.emplace(dp[i & 1][j]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int64_t x = 1; !st.empty() && dp[i & 1][j] < st.top(); x++){\n\t\t\t\tst.pop();\n\t\t\t\tans = max(ans, x * dp[i & 1][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "//Largest Square\n#include <iostream>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nstatic const int MAX = 1400;\n\nstruct Rectangle {\npublic:\n    int height, pos;\n    Rectangle(int height, int pos): height(height), pos(pos) {}\n};\n\nint G[MAX][MAX];\nint H, W;\n\nint getLargestRectangle() {\n    stack<Rectangle> S;\n    int dp[H][W];\n    int maxArea = 0;\n\n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) {\n            dp[i][j] = (G[i][j] + 1) % 2;\n            if(i != 0 && dp[i][j] != 0) dp[i][j] += dp[i - 1][j];\n        }\n    }\n\n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) {\n            Rectangle rect = Rectangle(dp[i][j], j);\n            if(S.empty()) S.push(rect);\n            else {\n                if(S.top().height < rect.height) {\n                    S.push(rect);\n                } else if(S.top().height > rect.height) {\n                    int target = j;\n                    while(!S.empty() && S.top().height > rect.height) {\n                        maxArea = max(maxArea, (target - S.top().pos) * S.top().height);\n                        target = S.top().pos;\n                        S.pop();\n                    }\n                }\n            }\n        }\n        int target = W;\n        while(!S.empty()) {\n            maxArea = max(maxArea, (target - S.top().pos) * S.top().height);\n            target = S.top().pos;\n            S.pop();\n        }\n    }\n    return maxArea;\n\n}\n\nint main() {\n    int c;\n    cin >> H >> W;\n    for(int i = 0; i < H; i++) {\n        for(int j = 0; j < W; j++) cin >> G[i][j];\n    }\n\n    cout << getLargestRectangle() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\nusing namespace std;\nstatic const int HMAX = 1401;\nstatic const int WMAX = 1401;\n\nint tiles[HMAX][WMAX] = {0};\n\nvoid print_tiles(int h, int w) {\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      cout << tiles[i][j] << \" \";\n    }\n    cout << endl;\n  }\n}\n\n// side-effects (to tiles)\nint leargest_square(int height, int width, int ans_init) {\n  int ans = ans_init;\n  for (int i = 1; i < height; i++) {\n    for (int j = 1; j < width; j++) {\n      if (tiles[i][j] != 0) {\n        tiles[i][j] =\n            min({tiles[i - 1][j], tiles[i][j - 1], tiles[i - 1][j - 1]}) + 1;\n        ans = max(ans, tiles[i][j]);\n      }\n    }\n  }\n  return ans * ans;\n}\n\nstruct Rect {\n  int height;\n  int left;\n};\n\n// side-effects (to tiles)\nint leargest_rectanble(int height, int width) {\n  // mkae histgrams\n  for (int i = 1; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      if (tiles[i][j] != 0) {\n        tiles[i][j] = tiles[i - 1][j] + 1;\n      }\n    }\n  }\n\n  int maxsize = 0;\n  stack<Rect> st;\n  for (int i = 0; i < height; i++) {\n    // calc the rectangle size of the i-th histgram\n    tiles[i][width] = 0; // sentinel\n    for (int j = 0; j < width + 1; j++) {\n      auto rect = Rect{tiles[i][j], j};\n      if (st.empty()) {\n        st.push(rect);\n      } else if (st.top().height < rect.height) {\n        st.push(rect);\n      } else if (st.top().height > rect.height) {\n        Rect r;\n        while (!st.empty()) {\n          r = st.top();\n          if (r.height <= rect.height)\n            break;\n          int size = r.height * (rect.left - r.left);\n          maxsize = max(size, maxsize);\n          st.pop();\n        }\n        if (r.height < rect.height) {\n          st.push(rect);\n        }\n      }\n    }\n  }\n\n  return maxsize;\n}\n\n#define BLOCK 1\nint main() {\n  int height, width;\n  int ans_init = 0;\n  cin >> height >> width;\n  for (int i = 0; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      int tmp;\n      cin >> tmp;\n      tiles[i][j] = tmp == BLOCK ? 0 : 1;\n      ans_init = max(ans_init, tiles[i][j]);\n    }\n  }\n  cout << leargest_rectanble(height, width) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "// 問題: H*Wのタイルが与えられる。タイルは綺麗か汚れているかのいずれか。\n//       綺麗なタイルのみでできる最大の長方形の最大値を求める\n// 解法: http://algorithms.blog55.fc2.com/blog-entry-133.html\n//       http://algorithms.blog55.fc2.com/blog-entry-132.html\n//       まず各要素について上に向かって 1 が何個連続しているかを示すテーブル T を作る\n//       次に、T の各行をヒストグラムの入力と見なしヒストグラムの最大長方形の面積を求めるアルゴリズムを適用\n\n#include <algorithm>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define FOR(i,a,b) for(int i = (a); i < (int)(b); ++i)\n#define ALL(c) (c).begin(), (c).end()\n#define SIZE(v) ((int)v.size())\n\n#define pb push_back\n#define mp make_pair\n\nint largest_square(const int H, const int W, const vector<vector<int>>& cells) {\n    // 上に綺麗なタイルが連続する数\n    // 番兵として、右端は汚れたタイルがあるものとする\n    vector<vector<int>> table(H, vector<int>(W+1));\n    REP(w, W) {\n        REP(h, H) {\n            auto val = cells[h][w];\n            if (val == 1) table[h][w] = 0;\n            else {\n                if (h == 0) table[h][w] = 1;\n                else table[h][w] = table[h-1][w] + 1;\n            }\n        }\n    }\n\n    // REP(h, H) {\n    //     REP(w, W+1) {\n    //         cerr << table[h][w] << \" \";\n    //     }\n    //     cerr << endl;\n    // }\n\n    int ans = 0;\n    // 各行ごとに、ヒストグラムの最大長方形の面積を求めるアルゴリズムを適用\n    REP(h, H) {\n        // <ヒストグラムの高さ, index>\n        stack<pair<int, int>> s;\n        REP(w, W+1) {\n            auto height = table[h][w];\n            if (s.empty()) s.push(mp(height, w));\n            else if (s.top().first < height) s.push(mp(height, w));\n            else if (s.top().first > height) {\n                while(!s.empty() && s.top().first > height) {\n                    auto area = (w - s.top().second) * s.top().first;\n                    ans = max(area, ans);\n                    s.pop();\n                }\n            }\n        }\n    }\n    return ans;\n}\n\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n\n    vector<vector<int>> cells(H, vector<int>(W));\n    REP(h, H) {\n        REP(w, W) {\n            cin >> cells[h][w];\n        }\n    }\n\n    cout << largest_square(H, W, cells) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <array>\n#include <cstddef>\n#include <iostream>\n#include <stack>\n\nint H, W;\nconst int HMAX = 1500;\nconst int WMAX = 1500;\n\nint c[HMAX][WMAX];\nint hist[HMAX][WMAX];\nint dp[HMAX][WMAX];\n\nstruct Rectangle\n{\n    int height, pos;\n};\n\nint main()\n{\n    std::cin >> H >> W;\n\n    for (size_t i = 1; i <= H; ++i)\n    {\n        for (size_t j = 1; j <= W; ++j)\n        {\n            std::cin >> c[i][j];\n        }\n    }\n\n    // make histogram\n    for (size_t j = 1; j <= W; ++j)\n    {\n        hist[0][j] = 0;\n    }\n    for (size_t j = 1; j <= W; ++j)\n    {\n        for (size_t i = 1; i <= H; ++i)\n        {\n            if (c[i][j] == 1)\n            {\n                hist[i][j] = 0;\n            }\n            else\n            {\n                hist[i][j] = hist[i - 1][j] + 1;\n            }\n        }\n    }\n    for (size_t i = 1; i <= H; ++i)\n    {\n        c[i][W + 1] = 0;\n    }\n\n    // for (size_t i = 1; i <= H; ++i)\n    // {\n    //     for (size_t j = 1; j <= W; ++j)\n    //     {\n    //         std::cout << hist[i][j] << \" \";\n    //     }\n    //     std::cout << std::endl;\n    // }\n\n    int largest = 0;\n\n    for (size_t i = 1; i <= H; ++i)\n    {\n        std::stack<Rectangle> s;\n        for (int j = 1; j <= W+1; ++j)\n        {\n            if (s.empty() || hist[i][j] > s.top().height)\n            {\n                s.push(Rectangle{hist[i][j], j});\n            }\n            else if (hist[i][j] < s.top().height)\n            {\n                Rectangle rect;\n                while (!s.empty() && s.top().height >= hist[i][j])\n                {\n                    rect = s.top();\n                    s.pop();\n                    int area = (j - rect.pos) * rect.height;\n                    if (area > largest)\n                    {\n                        largest = area;\n                    }\n                }\n\n                s.push(Rectangle{hist[i][j], rect.pos});\n            }\n        }\n    }\n\n    std::cout << largest << std::endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>           // printf(), scanf()\n#include <stack>\n#include <algorithm>        // max()\n\nusing namespace std;\nstatic const int MAX_M = 1400;\n\nstruct Rectangle\n{\n\tint height;\n\tint pos;\n};\n\nint G[MAX_M][MAX_M];\nint dp[MAX_M][MAX_M + 1];\nint H, W;\n\nint\ngetLargestRectangle(int size, int H[])\n{\n\tRectangle rect;\n\tstack<Rectangle> S;\n\n\tint maxv = 0;\n\tH[size] = 0;\n\n\tfor (int i = 0; i <= size; ++i)\n\t{\n\t\trect.height = H[i];\n\t\trect.pos = i;\n\t\tif (S.empty())\n\t\t\tS.push(rect);\n\t\telse\n\t\t{\n\t\t\tif (S.top().height < rect.height)\n\t\t\t\tS.push(rect);\n\t\t\telse if (S.top().height > rect.height)\n\t\t\t{\n\t\t\t\tint target = i;\n\t\t\t\twhile (!S.empty() && S.top().height >= rect.height)\n\t\t\t\t{\n\t\t\t\t\tRectangle pre = S.top(); S.pop();\n\t\t\t\t\tint area = pre.height * (i - pre.pos);\n\t\t\t\t\tmaxv = max(maxv, area);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\n\t\t\t\trect.pos = target;\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn maxv;\n}\n\nint\ngetLargestRectangle()\n{\n\tfor (int j = 0; j < W; ++j)\n\t{\n\t\tfor (int i = 0; i < H; ++i)\n\t\t{\n\t\t\tif (G[i][j])\n\t\t\t\tdp[i][j] = 0;\n\t\t\telse\n\t\t\t\tdp[i][j] = (i > 0) ? dp[i - 1][j] + 1 : 1;\n\t\t}\n\t}\n\n\tint maxv = 0;\n\tfor (int i = 0; i < H; ++i)\n\t{\n\t\tint t = getLargestRectangle(W, dp[i]);\n\t\tmaxv = max(maxv, t);\n\t}\n\n\treturn maxv;\n}\n\nint\nmain(int argc, char** argv)\n{\n\tscanf(\"%d %d\", &H, &W);\n\tfor (int i = 0; i < H; ++i)\n\t{\n\t\tfor (int j = 0; j < W; ++j)\n\t\t\tscanf(\"%d\", &G[i][j]);\n\t}\n\n\tprintf(\"%d\\n\", getLargestRectangle());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <math.h>\n#include <stack>\n\nusing namespace std;\n\nstruct Info{\n\tInfo(){ left = height = 0;}\n\tInfo(int arg_left,int arg_height){\n\t\tleft = arg_left;\n\t\theight = arg_height;\n\t}\n\tint left,height;\n};\n\nint main(){\n\n\tint H,W,max_s,tmp,tmp_h;\n\n\tscanf(\"%d %d\",&H,&W);\n\n\tint** table = new int*[H+1];\n\tfor(int i = 0; i < H+1; i++){\n\t\ttable[i] = new int[W+1];\n\t}\n\n\tfor(int i = 0; i < W+1; i++)table[0][i] = 0;\n\tfor(int i = 0; i < H+1; i++)table[i][W] = 0;\n\n\tstack<Info> S;\n\tInfo work;\n\n\tmax_s = 0;\n\n\tfor(int i = 1;i <= H; i++){\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tscanf(\"%d\",&table[i][k]);\n\t\t\tif(table[i][k] == 0){\n\t\t\t\ttable[i][k] = table[i-1][k] + 1;\n\t\t\t}else{\n\t\t\t\ttable[i][k] = 0;\n\t\t\t}\n\t\t}\n\n\t\ttmp_h = table[i][0];\n\t\tS.push(Info(0,tmp_h));\n\n\t\tfor(int k = 1; k < W+1; k++){\n\t\t\tif(table[i][k] > tmp_h){\n\t\t\t\tS.push(Info(k,table[i][k]));\n\t\t\t\ttmp_h = table[i][k];\n\t\t\t}else if(table[i][k] == tmp_h){\n\n\t\t\t}else{\n\t\t\t\twhile(S.empty() == false && S.top().height >= table[i][k]){\n\t\t\t\t\twork = S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\ttmp = (k - work.left)*work.height;\n\t\t\t\t\tmax_s = (max_s >= tmp)?max_s:tmp;\n\t\t\t\t}\n\t\t\t\ttmp_h = table[i][k];\n\t\t\t\tS.push(Info(work.left,table[i][k]));\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",max_s);\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<climits>\n#include<string>\n#include<set>\n#include<numeric>\n#include<map>\n#include<iostream>\nusing namespace std;\n#define rep(i,n) for(int i = 0;i<((int)(n));i++)\n#define reg(i,a,b) for(int i = ((int)(a));i<=((int)(b));i++)\n#define irep(i,n) for(int i = ((int)(n)-1);i>=0;i--)\n#define ireg(i,a,b) for(int i = ((int)(b));i>=((int)(a));i--)\ntypedef long long ll;\ntypedef pair<ll, ll> mp;\n\n//?????£????????????????????????????????????????????????\n//???????????????????????????????????¨?????????\n\nint main(void){\n\tll H,W;\n\tcin>>H>>W;\n\tll c[H][W];//H,W\n\tll up[H][W];//?????´???\n\tll left[H][W];//?????´???\n\tll ans=0;\n\tll min;\n\trep(i,H){\n\t\trep(j,W){\n\t\t\tcin>>c[i][j];\n\t\t\tif(c[i][j]==0){//?¶????????????????\n\t\t\t\tif(i==0){\n\t\t\t\t\tup[0][j]=1;\n\t\t\t\t}else{\n\t\t\t\t\tup[i][j]=up[i-1][j]+1;\n\t\t\t\t}\n\t\t\t\tif(j==0){\n\t\t\t\t\tleft[i][0]=1;\n\t\t\t\t}else{\n\t\t\t\t\tleft[i][j]=left[i][j-1]+1;\n\t\t\t\t}\n\t\t\t}else{//?±?????????????\n\t\t\t\tup[i][j]=0;\n\t\t\t\tleft[i][j]=0;\n\t\t\t}\n\t\t\tmin=LLONG_MAX;\n\t\t\trep(k,up[i][j]){\n\t\t\t\tif(left[i-k][j]<min){\n\t\t\t\t\tmin=left[i-k][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans<min*up[i][j])ans=min*up[i][j];\n\t\t\tmin=LLONG_MAX;\n\t\t\trep(k,left[i][j]){\n\t\t\t\tif(up[i][j-k]<min){\n\t\t\t\t\tmin=up[i][j-k];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans<min*left[i][j])ans=min*left[i][j];\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\nusing namespace std;\nstatic const int HMAX = 1401;\nstatic const int WMAX = 1401;\n\nint tiles[HMAX][WMAX] = {0};\n\nvoid print_tiles(int h, int w) {\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      cout << tiles[i][j] << \" \";\n    }\n    cout << endl;\n  }\n}\n\n// side-effects (to tiles)\nint leargest_square(int height, int width, int ans_init) {\n  int ans = ans_init;\n  for (int i = 1; i < height; i++) {\n    for (int j = 1; j < width; j++) {\n      if (tiles[i][j] != 0) {\n        tiles[i][j] =\n            min({tiles[i - 1][j], tiles[i][j - 1], tiles[i - 1][j - 1]}) + 1;\n        ans = max(ans, tiles[i][j]);\n      }\n    }\n  }\n  return ans * ans;\n}\n\nstruct Rect {\n  int height;\n  int left;\n};\n\n// side-effects (to tiles)\nint leargest_rectanble(int height, int width) {\n  // mkae histgrams\n  for (int i = 1; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      if (tiles[i][j] != 0) {\n        tiles[i][j] = tiles[i - 1][j] + 1;\n      }\n    }\n  }\n\n  int maxsize = 0;\n  stack<Rect> st;\n  for (int i = 0; i < height; i++) {\n    // calc the rectangle size of the i-th histgram\n    tiles[i][width] = 0; // sentinel\n    for (int j = 0; j < width + 1; j++) {\n      auto rect = Rect{tiles[i][j], j};\n      if (st.empty() || st.top().height < rect.height) {\n        st.push(rect);\n      } else if (st.top().height > rect.height) {\n        Rect r;\n        while (!st.empty()) {\n          r = st.top();\n          if (r.height <= rect.height)\n            break;\n          int size = r.height * (rect.left - r.left);\n          maxsize = max(size, maxsize);\n          st.pop();\n        }\n        if (r.height < rect.height) {\n          rect.left = r.left + 1;\n          st.push(rect);\n        }\n      }\n    }\n  }\n\n  return maxsize;\n}\n\n#define BLOCK 1\nint main() {\n  int height, width;\n  int ans_init = 0;\n  cin >> height >> width;\n  for (int i = 0; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      int tmp;\n      cin >> tmp;\n      tiles[i][j] = tmp == BLOCK ? 0 : 1;\n      ans_init = max(ans_init, tiles[i][j]);\n    }\n  }\n  cout << leargest_rectanble(height, width) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n\tRectangle rect;\n\tfor(int i=0;i<x;i++){\n\t\tstack<Rectangle> stk;\n\t\trect.height = 0;\n\t\trect.pos = 0;\n\t\tstk.push(rect);\n\t\tint pop=0;\n\t\tfor(int j=0;j<=y;j++){\n\t\t\trect.height = m[j][i];\n\t\t\trect.pos = j;\n\t\t\tif(stk.empty() || stk.top().height < rect.height){\n\t\t\t\tstk.push(rect);\n\t\t\t}else{\n\t\t\t\t//printf(\"[-] %d %d\\n\",i,j);\n\t\t\t\tfor(;!stk.empty() && stk.top().height >= rect.height;){\n\t\t\t\t\tpop++;\n\t\t\t\t\tRectangle pre = stk.top(); stk.pop();\n\t\t\t\t\t//pre.pos=stk\n\t\t\t\t\tint area = pre.height * (j - pre.pos);\n\t\t\t\t\tr = max(r, area);\n\t\t\t\t\t//printf(\"%d %d\\n\",target,pre.pos);\n\t\t\t\t\trect.pos = pre.pos;\n\t\t\t\t}\n\t\t\t\tstk.push(rect);\n\t\t\t}\n\t\t\tif(rect.height==0)pop=0;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n  Rectangle rect;\n  for (int i = 0; i < x; i++) {\n    stack<Rectangle> stk;\n    for (int j = 0; j <= y; j++) {\n      rect.height = m[j][i];\n      rect.pos = j;\n      if (stk.empty()) {\n        stk.push(rect);\n      } else {\n        if (stk.top().height < rect.height) {\n          stk.push(rect);\n        } else if (stk.top().height > rect.height) {\n          int target = j;\n          while (!stk.empty() && stk.top().height >= rect.height) {\n            Rectangle pre = stk.top(); stk.pop();\n            int area = pre.height * (j - pre.pos);\n            r = max(r, area);\n            target = pre.pos;\n          }\n          rect.pos = target;\n          stk.push(rect);\n        }\n      }\n    }\n  }\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\nconst int mod = 1e9 + 7;\nconst int inf = (1 << 30) - 1;\nconst int64 infll = (1LL << 61) - 1;\n\nstruct IoSetup {\n  IoSetup() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n  }\n} iosetup;\n\ntemplate< typename T >\nostream &operator<<(ostream &os, const vector< T > &v) {\n  for(int i = 0; i < (int) v.size(); i++) {\n    os << v[i] << (i + 1 != v.size() ? \" \" : \"\");\n  }\n  return os;\n}\n\ntemplate< typename T >\nistream &operator>>(istream &is, vector< T > &v) {\n  for(T &in : v) is >> in;\n  return is;\n}\n\ntemplate< typename T1, typename T2 >\ninline bool chmax(T1 &a, T2 b) { return a < b && (a = b, true); }\n\ntemplate< typename T1, typename T2 >\ninline bool chmin(T1 &a, T2 b) { return a > b && (a = b, true); }\n\ntemplate< typename T = int64 >\nvector< T > make_v(size_t a) {\n  return vector< T >(a);\n}\n\ntemplate< typename T, typename... Ts >\nauto make_v(size_t a, Ts... ts) {\n  return vector< decltype(make_v< T >(ts...)) >(a, make_v< T >(ts...));\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) {\n  t = v;\n}\n\ntemplate< typename T, typename V >\ntypename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) {\n  for(auto &e : t) fill_v(e, v);\n}\n\ntemplate< typename T >\nint64_t largest_rectangle(vector< T > height) {\n  stack< int > st;\n  height.push_back(0);\n  vector< int > left(height.size());\n  int64_t ret = 0;\n  for(int i = 0; i < height.size(); i++) {\n    while(!st.empty() && height[st.top()] >= height[i]) {\n      ret = max(ret, (int64_t) (i - left[st.top()] - 1) * height[st.top()]);\n      st.pop();\n    }\n    left[i] = st.empty() ? -1 : st.top();\n    st.emplace(i);\n  }\n  return (ret);\n}\n\nint main() {\n  int H, W;\n  cin >> H >> W;\n  auto mat = make_v< int >(H, W);\n  cin >> mat;\n\n  vector< int > last(W, -1);\n  int ret = 0;\n  for(int i = 0; i < H; i++) {\n    for(int j = 0; j < W; j++) {\n      if(mat[i][j] == 1) last[j] = i;\n    }\n    vector< int > dp(W);\n    for(int j = 0; j < W; j++) {\n      dp[j] = i - last[j];\n    }\n    chmax(ret, largest_rectangle(dp));\n  }\n  cout << ret << endl;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define H 1401\n#define W 1401\n\nint A[H+1][W+1];\nint Hist[H+1][W+1];\n\nstruct Rectangle {\n    int height;\n    int pos;\n};\n\nint getLargestRectangle(int h, int w) {\n    for (int i = 0; i < h+1; i++) Hist[i][0] = 0;\n    for (int j = 0; j < w+1; j++) Hist[0][j] = 0;\n\n    for (int i = 1; i <= h; i++) {\n        for (int j = 1; j <= w; j++) {\n            if (A[i][j] == 1) {\n                Hist[i][j] = 0;\n            } else {\n                Hist[i][j] = Hist[i-1][j] + 1;\n            }\n        }\n    }\n\n    int largest = 0;\n    stack<Rectangle> S;\n    for (int i = 1; i <= h; i++) {\n        for (int j = 1; j <= w; j++) {\n            if (S.empty()) {\n                S.push({Hist[i][j], j});\n            } else if (S.top().height < Hist[i][j]) {\n                S.push({Hist[i][j], j});\n            } else if (S.top().height > Hist[i][j]) {\n                int lastPos;\n                while (!S.empty() && S.top().height > Hist[i][j]) {\n                    Rectangle rect = S.top();\n                    S.pop();\n                    if (largest < rect.height * (j - rect.pos)) {\n                        largest = rect.height * (j - rect.pos);\n                    } \n                    lastPos = rect.pos;\n                }\n                S.push({Hist[i][j], lastPos});\n            }\n        }\n        \n        if (!S.empty()) {\n            while (!S.empty()) {\n                Rectangle rect = S.top();\n                S.pop();\n                if (largest < rect.height * (w - rect.pos + 1)) {\n                    largest = rect.height * (w - rect.pos + 1);\n                } \n            }\n        }\n    }\n\n    return largest;\n}\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n\n    for (int i = 1; i <= h; i++) {\n        for (int j = 1; j <= w; j++) {\n            cin >> A[i][j];\n        }\n    }\n\n    for (int i = 0; i < h+1; i++) A[i][0] = 0;\n    for (int j = 0; j < w+1; j++) A[0][j] = 0;\n\n    cout << getLargestRectangle(h, w) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <string>\n#include <cmath>\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <set>\n#include <map>\n#include <bitset>\nusing namespace std;\n\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define fi first\n#define se second\n\n#define INF 2147483600\ntypedef pair<int, int> P;\n\nint mat[1500][1500];\n\nint main(){\n  int h,w;\n  cin>>h>>w;\n\n  rep(i,h)rep(j,w) scanf(\"%d\", &mat[i][j]);\n\n  // convert matrix to vertiacl succeeding numbers\n  rep(i,h)rep(j,w){\n    if(i==0){\n      mat[i][j] = !mat[i][j];\n      continue;\n    }\n    if(mat[i][j]==0) mat[i][j] = mat[i-1][j]+1;\n    else mat[i][j] = 0;\n  }\n\n  // see matrix row as a histogram to make the largert rectangle\n  int res = 0;\n  rep(i,h){\n    mat[i][w] = 0;\n    stack<P> st;\n    rep(j,w+1){\n      int d=mat[i][j];\n      if(st.empty()) st.push(mp(j,d));\n      else if(st.top().se < d) st.push(mp(j,d));\n      else if (st.top().se > d){\n        int last = j;\n        while(!st.empty() && st.top().se > d){\n          P p = st.top(); st.pop();\n          res = max(res, (j-p.fi)*p.se);\n          last = p.fi;\n        }\n        st.push(mp(last,d));\n      }\n    }\n  }\n\n  cout<<res<<endl;\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\nint c[1401][1401]={};\nint a(int x1,int x2,int y1,int y2){\n\tint b=c[x1][y1]+c[x2][y2]-c[x1][y2]-c[x2][y1];\n\tif(b!=0) b=1;\n\treturn b;\n}\nint main(){\n\tint h,w;\n\tcin >> h >> w;\n\tfor(int i=1;i<=h;i++){\n\t\tfor(int j=1;j<=w;j++){\n\t\t\tcin >> c[i][j];\n\t\t\tc[i][j] += c[i][j-1]+c[i-1][j]-c[i-1][j-1];\n\t\t}\n\t}\n\tint max=0;\n\tfor(int i=0;i<h;i++){\n\t\tfor(int j=0;j<w;j++){\n\t\t\tfor(int k=i+1;k<=h;k++){\n\t\t\t\tfor(int l=j+1;l<=w;l++){\n\t\t\t\t\tif(a(i,k,j,l)==0){\n\t\t\t\t\t\tif(max<(k-i)*(l-j)) max=(k-i)*(l-j);\n\t\t\t\t\t}\n\t\t\t\t\telse break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << max << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<stack>\n#include<utility>\nusing namespace std;\n\nconst int MAX = 1400;\n\nint main() {\n\tint H, W;\n\tint tile[MAX][MAX];\n\tint ans = 0;\n\n\tscanf(\"%d%d\", &H, &W);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tscanf(\"%d\", &tile[i][j]);\n\t\t}\n\t}\n\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = W - 1; x >= 0; x--) {\n\t\t\tif (tile[y][x] == 1)tile[y][x] = 0;\n\t\t\telse if (x == W - 1)tile[y][x] = 1;\n\t\t\telse tile[y][x] = tile[y][x + 1] + 1;\n\t\t}\n\t}\n\n\tfor (int x = 0; x < W; x++) {\n\t\tstack<pair<int, int>> s;\n\t\ts.push(pair<int, int>(0, -1));\n\t\tfor (int y = 0; y < H; y++) {\n\t\t\tif (s.top().second < tile[y][x]) {\n\t\t\t\ts.push(pair<int, int>(y, tile[y][x]));\n\t\t\t}\n\t\t\telse if (s.top().second > tile[y][x]) {\n\t\t\t\twhile (s.top().second > tile[y][x]) {\n\t\t\t\t\tans = max(ans, (y - s.top().first) * s.top().second);\n\t\t\t\t\ts.pop();\n\t\t\t\t}\n\t\t\t\tif(s.top().second != tile[y][x])s.push(pair<int, int>(s.top().first, tile[y][x]));\n\t\t\t}\n\t\t}\n\t\twhile (!s.empty()) {\n\t\t\tans = max(ans, (W - 1 - s.top().first) * s.top().second);\n\t\t\ts.pop();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", ans);\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n\tRectangle rect;\n\tfor(int i=0;i<x;i++){\n\t\tstack<Rectangle> stk;\n\t\t//rect.height = 0;\n\t\t//rect.pos = 0;\n\t\t//stk.push(rect);\n\t\tint pop=0;\n\t\tfor(int j=0;j<=y;j++){\n\t\t\trect.height = m[j][i];\n\t\t\trect.pos = j;\n\t\t\tif(stk.empty() || stk.top().height < rect.height){\n\t\t\t\tstk.push(rect);\n\t\t\t}else{\n\t\t\t\t//printf(\"[-] %d %d\\n\",i,j);\n\t\t\t\tfor(;!stk.empty() && stk.top().height > rect.height;){\n\t\t\t\t\tpop++;\n\t\t\t\t\tRectangle pre = stk.top(); stk.pop();\n\t\t\t\t\t//pre.pos=stk\n\t\t\t\t\tint area = pre.height * (j - pre.pos);\n\t\t\t\t\tr = max(r, area);\n\t\t\t\t\t//printf(\"%d %d\\n\",target,pre.pos);\n\t\t\t\t\trect.pos = pre.pos;\n\t\t\t\t}\n\t\t\t\tstk.push(rect);\n\t\t\t}\n\t\t\tif(rect.height==0)pop=0;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<stack>\n#include<algorithm>\n#define MAX 1400\n\nusing namespace std;\n\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectangle(int size, int buffer[]) {\n    stack<Rectangle> S;\n    int maxv = 0;\n    buffer[size] = 0;\n    \n    for (int i = 0; i <= size; i++) {\n        Rectangle rect;\n        rect.height = buffer[i];\n        rect.pos = i;\n        if (S.empty()) {\n            S.push(rect);\n        } else {\n            if (S.top().height < rect.height) {\n                S.push(rect);\n            } else if (S.top().height > rect.height) {\n                int target = i;\n                while (!S.empty() && S.top().height >= rect.height) {\n                    Rectangle pre = S.top(); S.pop();\n                    int area = pre.height * (i - pre.pos);\n                    maxv = max(maxv, area);\n                    target = pre.pos;\n                }\n                rect.pos = target;\n                S.push(rect);\n            }\n        }\n    }\n    return maxv;\n}\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle() {\n    for (int j = 0; j < W; j++) {\n        for (int i = 0; i < H; i++) {\n            if (buffer[i][j]) {\n                T[i][j] = 0;\n            } else {\n                T[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n            }\n        }\n    }\n    \n    int maxv = 0;\n    for (int i = 0; i < H; i++) {\n        maxv = max(maxv, getLargestRectangle(W, T[i]));\n    }\n    \n    return maxv;\n}\n\nint main() {\n    scanf(\"%d %d\", &H, &W);\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            scanf(\"%d\", &buffer[i][j]);\n        }\n    }\n    cout << getLargestRectangle() << endl;\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n\tRectangle rect;\n\tfor(int i=0;i<x;i++){\n\t\tstack<Rectangle> stk;\n\t\tfor(int j=0;j<=y;j++){\n\t\t\trect.height = m[j][i];\n\t\t\trect.pos = j;\n\t\t\tif(stk.empty() || stk.top().height < rect.height){\n\t\t\t\tstk.push(rect);\n\t\t\t}else{\n\t\t\t\tint target = j;\n\t\t\t\tfor(;!stk.empty() && stk.top().height >= rect.height;){\n\t\t\t\t\tRectangle pre = stk.top(); stk.pop();\n\t\t\t\t\tint area = pre.height * (j - pre.pos);\n\t\t\t\t\tr = max(r, area);\n\t\t\t\t\ttarget = pre.pos;\nrect.pos--;\n\t\t\t\t}\n\t\t\t\tstk.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\nusing namespace std;\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n    char mat[h][w];\n    int dp[h][w];\n\n    for (int i = 0; i < h; i++)\n    {\n        for (int j = 0; j < w; j++)\n        {\n            cin >> mat[i][j];\n        }\n    }\n\n    for (int i = 0; i < h; i++)\n        dp[0][i] = (mat[0][i] == '0');\n    for (int i = 1; i < h; i++)\n    {\n        for (int j = 0; j < w; j++)\n        {\n            if (mat[i][j] == '0')\n                dp[i][j] = dp[i - 1][j] + 1;\n            else\n                dp[i][j] = 0;\n        }\n    }\n\n    int ans = -1;\n    for (int i = 0; i < h; i++)\n    {\n        // pair<left end, height>\n        stack<pair<int, int>> s;\n        for (int j = 0; j < w; j++)\n        {\n            if (s.empty())\n            {\n                s.push({j, dp[i][j]});\n            }\n            else if (dp[i][j] > s.top().second)\n            {\n                s.push({j, dp[i][j]});\n            }\n            else if (dp[i][j] == s.top().second)\n            {\n                // do nothing.\n            }\n            else if (dp[i][j] < s.top().second)\n            {\n                int left;\n                while (!s.empty() && dp[i][j] < s.top().second)\n                {\n                    pair<int, int> now = s.top();\n                    s.pop();\n                    // make rectangle\n                    ans = max(ans, (j - now.first) * (now.second));\n                    left = now.first;\n                }\n                s.push({left, dp[i][j]});\n            }\n        }\n\n        while (!s.empty())\n        {\n            pair<int, int> now = s.top();\n            s.pop();\n            ans = max(ans, (h - now.first) * (now.second));\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//DPL_3B\n#include <iostream>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n \nstatic const int MAX=1400;\n\nstruct Rectangle{int height;int pos;};\n\nint getLagestRectangle(int size,int buffer[]){\n stack<Rectangle> S;\n int maxv=0;\n buffer[size]=0;\n for(int i=0;i<=size;i++){\n  Rectangle rect;\n  rect.height=buffer[i];\n  rect.pos=i;\n  if(S.empty()){\n   S.push(rect);\n  }else{\n   if(S.top().height<rect.height){\n    S.push(rect);\n   }else if(S.top().height>rect.height){\n    int target=i;\n    while(!S.empty() && S.top().height>=rect.height){\n     Rectangle pre=S.top(); S.pop();\n     int area=pre.height*(i-pre.pos);\n     maxv=max(maxv,area);\n     target=pre.pos;\n    }\n    rect.pos=target;\n    S.push(rect);\n   }\n  }\n }\n return maxv;\n}\n\nint H,W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle(){\n for(int j=0;j<W;j++){\n  for(int i=0;i<H;i++){\n   if(buffer[i][j]){\n    T[i][j]=0;\n   }else{\n    T[i][j]=(i>0) ? T[i-1][j]+1:1;\n   }\n  }\n }\n int maxv=0;\n for(int i=0;i<H;i++){\n  maxv=max(maxv,getLagestRectangle(W,T[i]));\n }\n return maxv;\n}\n\nint main(){\n cin>>H>>W;\n for(int i=0;i<H;i++){\n  for(int j=0;j<W;j++){\n   cin>>buffer[i][j];\n  }\n }\n cout<<getLargestRectangle()<<endl;\n return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ];\nlong long st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tfor(r=i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\tint left=j;\n\t\tfor(;ptr && st[ptr-1]>>32>m[j][i];){\n\t\t\tint l=st[ptr-1]&0xffffffff,h=st[ptr-1]>>32;\n\t\t\tptr--;\n\t\t\tif(r<(j-l)*h)r=(j-l)*h;\n\t\t\tleft=l;\n\t\t}\n\t\tst[ptr++]=((long long)m[j][i]<<32)|left;\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long;\nusing Pi = pair<int, int>;\nusing Pl = pair<ll, ll>;\nusing vint = vector<int>;\nusing vll = vector<ll>;\nusing uint = unsigned int;\nusing ull = unsigned long long;\n \ntemplate<typename T> using uset = unordered_set<T>;\ntemplate<typename T1, typename T2> using umap = unordered_map<T1, T2>;\n \nconstexpr int INF = (1 << 30) - 1;\nconstexpr ll LLINF = 1LL << 60;\nconstexpr int dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\nconstexpr int dx[] = {0, 1, 0, -1, 1, 1, -1, -1};\nconstexpr char el = '\\n';\nconstexpr int mod = 1000000007;\n \ntemplate<typename T> T gcd(T a, T b) { return (b ? gcd(b, a % b) : a); }\ntemplate<typename T> T lcm(T a, T b) { return (a / gcd(a, b) * b); }\ntemplate<typename T1, typename T2> inline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\ntemplate<typename T1, typename T2> inline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n \ntemplate<typename T>\nostream& operator <<(ostream &os, vector<T> &v) {\n        for (auto &u : v) os << u << el;\n        return (os);\n}\n \ntemplate<typename T>\nistream& operator >>(istream &is, vector<T> &v) {\n        for (auto &u : v) is >> u;\n        return (is);\n}\n \ntemplate<typename T1, typename T2>\nistream& operator >>(istream &is, pair<T1, T2> &p) {\n        return (is >> p.first >> p.second);\n}\n \nint main() {\n        int H, W; cin >> H >> W;\n        vector<vint> S(H, vint(W)); cin >> S;\n        vector<vint> sum(H, vint(W+1, 0));\n        for (int i = 0; i < H; i++) {\n                for (int j = 0; j < W; j++) {\n                        if (S[i][j] == 0) {\n                                sum[i][j] = 1;\n                                if (i) sum[i][j] += sum[i-1][j];\n                        }\n                }\n                sum[i][W] = 0;\n        }\n         \n        int maxv = 0;\n        for (int i = 0; i < H; i++) {\n                //longest area rectangle\n                stack<Pi> st;\n                for (int j = 0; j <= W; j++) {\n                        int minv = j;\n                        while (!st.empty() && st.top().first > sum[i][j]) {\n                                auto dat = st.top(); st.pop();\n                                chmax(maxv, dat.first * (j - dat.second));\n                                chmin(minv, dat.second);\n                        }\n                        st.emplace(sum[i][j], minv);\n                }\n        }\n        cout << maxv << endl;\n        return (0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nstruct rect{int ht;int pos;};\nint tb[1400][1400];\nint area_rect(int size,int buf[]){\n    stack<rect> st;\n    int mx=0;\n    buf[size]=0;\n    rep(i,size+1){\n        rect r;\n        r.ht=buf[i];\n        r.pos=i;\n        if(st.empty()) st.push(r);\n        else{\n            if(st.top().ht<r.ht) st.push(r);\n            else if (st.top().ht>r.ht){\n                int ti=i;\n                while(!st.empty()&&st.top().ht>=r.ht){\n                    rect pre=st.top();st.pop();\n                    int area=pre.ht*(i-pre.pos);\n                    mx=max(mx,area);\n                    ti=pre.pos;\n                }\n                r.pos = ti;\n                st.push(r);\n            }\n        }\n    }\n    return mx;\n}\nint main(){\n    int h,w;\n    cin>>h>>w;\n    rep(i,h){\n        rep(j,w){\n            bool x;\n            cin>>x;\n            if(i==0||x==1) tb[i][j]=!x;\n            else tb[i][j]=tb[i-1][j]+!x;\n        }\n    }\n    int mx=0;\n    rep(i,h) mx=max(mx,area_rect(w,tb[i]));\n    cout<<mx<<endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ull = unsigned long long;\n//#define ll long long\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n#define rep(i, n) REP(i, 0, n)\n#define rep_rev(i, n) for (int (i) = (int)(n) - 1 ; (i) >= 0 ; --(i))\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\n#define all(x) (x).begin(),(x).end()\nll t1,t2,t3;\nconst ll mod = 998244353;\nconst int INF = 1e9;\nconst ll INFLONG = 1e18;\n\n\nll h,w;\nvector<vector<ll>> buffer(1400,vector<ll>(1400,0));\nvector<vector<ll>> T(1400,vector<ll>(1400,0));\nstruct Rectangle{\n    ll height;\n    ll pos;\n};\n\nll getLargestRectangle(ll size,vector<ll> vec){\n  stack<Rectangle>  S;\n  ll maxv = 0;\n  vec[size] = 0;\n  rep(i,size+1){\n    Rectangle rect;\n    rect.height = vec[i];\n    rect.pos = i;\n    if(S.empty()){\n      S.push(rect);\n    }else{\n      if(S.top().height < rect.height){\n        S.push(rect);\n      }else if(S.top().height > rect.height){\n        ll target = i;\n        while(!S.empty() && S.top().height >= rect.height){\n          Rectangle pre = S.top();\n          S.pop();\n          ll area = pre.height * (i-pre.pos);\n          chmax(maxv,area);\n          target = pre.pos;\n        }\n        rect.pos = target;\n        S.push(rect);\n      }\n    }\n  }\n  return maxv;\n}\nll getLargestRectangle(){\n  rep(i,h){\n    rep(j,w){\n      if(buffer[i][j]){\n        T[i][j] = 0;\n      }else{\n        if(i > 0){\n          T[i][j] = T[i-1][j] + 1;\n        }else{\n          T[i][j] = 1;\n        }\n      }\n    }\n  }\n\n  ll maxv = 0;\n  rep(i,h){\n    chmax(maxv,getLargestRectangle(w,T[i]));\n  }\n\n  return maxv;\n}\n\nint main(){\n  cin >> h >> w;\n  rep(i,h){\n    rep(j,w){\n      cin >> buffer[i][j];\n    }\n  }\n  cout << getLargestRectangle() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst long long MAX = 5100000;\nconst long long INF = 1LL << 60;\nconst long long mod = 1000000007LL;\n//const long long mod = 998244353LL;\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\n\nll solve(ll n, vector<int>& h) {\n\tstack<pair<int, int>> st;\n\tvector<ll> left(n);\n\tfor (ll i = 0; i < n; i++) {\n\t\tll cnt = 1;\n\t\twhile (!st.empty() && st.top().first >= h[i]) {\n\t\t\tcnt += st.top().second;\n\t\t\tst.pop();\n\t\t}\n\t\tleft[i] = cnt;\n\t\tst.emplace(h[i], cnt);\n\t}\n\twhile (!st.empty()) st.pop();\n\tvector<ll> right(n);\n\tfor (ll i = n - 1; i >= 0; i--) {\n\t\tll cnt = 1;\n\t\twhile (!st.empty() && st.top().first >= h[i]) {\n\t\t\tcnt += st.top().second;\n\t\t\tst.pop();\n\t\t}\n\t\tright[i] = cnt;\n\t\tst.emplace(h[i], cnt);\n\t}\n\tll res = 0;\n\tfor (ll i = 0; i < n; i++) {\n\t\tll cnt = left[i] + right[i] - 1;\n\t\tchmax(res, h[i] * cnt);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\t/*\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\t*/\n\tll H, W; scanf(\"%lld %lld\", &H, &W);\n\tvector<vector<int>> vs(H, vector<int>(W)); for (int i = 0; i < H; i++) for (int j = 0; j < W; j++) scanf(\"%d\", &vs[i][j]);\n\tvector<vector<int>> hh(H, vector<int>(W));\n\tfor (int i = 0; i < W; i++) {\n\t\tif (vs[0][i]) hh[0][i] = 0;\n\t\telse hh[0][i] = 1;\n\t}\n\tll res = 0;\n\tchmax(res, solve(W, hh[0]));\n\tfor (ll i = 1; i < H; i++) {\n\t\tfor (ll j = 0; j < W; j++) {\n\t\t\tif (vs[i][j]) hh[i][j] = 0;\n\t\t\telse hh[i][j] = hh[i - 1][j] + 1;\n\t\t}\n\t\tchmax(res, solve(W, hh[i]));\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n\n#define ll long long\n#define pii pair<int,int>\n#define MAX 1500\n\nint M[MAX][MAX];\nint A[MAX][MAX];\n\nint main(){\n    ios_base::sync_with_stdio(0);\n    cin.tie(0);\n\n    int n,m;\n    cin >> n >> m;\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++)cin>>M[i][j];\n    }\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n            if(!M[i][j] ){\n                if(i==0)A[i][j]=1;\n                else A[i][j]=A[i-1][j]+1;\n            }\n        }\n    }\n\n    \n\n    int ans=0;\n    for(int i=0;i<n;i++){\n        stack<int> s;\n        for(int j=0;j<m;j++){\n            int cur=A[i][j];\n            while(s.size() && A[i][s.top()]>cur)s.pop();\n            if(s.size()==0){\n                ans=max(ans,cur*(j+1));\n            }\n            else{\n                ans=max(ans,cur*(j-s.top()));\n            }\n            s.push(j);\n        }\n\n    }\n\n    cout << ans << '\\n';\n   \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<stack>\nusing namespace std;\nint H,W;\nint G[2000][2000];\nint T[2000][2000];\nstruct ang{\n\tint height,pos;\n};\nint f(int a[]){\n\tstack < ang > S;\n\tint maxn=0;\n\tfor(int i=0;i<W;i++){\n\t\tang rect;\n\t\trect.height=a[i];\n\t\trect.pos=i;\n\t\tif(S.empty()){\n\t\t\tS.push(rect);\n\t\t}\n\t\telse {\n\t\t\tif(S.top().height<rect.height) S.push(rect);\n\t\t\telse if(S.top().height>rect.height){\n\t\t\t\tint pre=i;\n\t\t\t\twhile(!S.empty()&&S.top().height>=rect.height){\n\t\t\t\t\tang k=S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tint area=k.height*(i-k.pos);\n\t\t\t\t\tmaxn=max(maxn,area);\n\t\t\t\t\tpre=k.pos;\n\t\t\t\t}\n\t\t\t\trect.pos=pre;\n\t\t\t}\n\t\t\t\n\t\t\tS.push(rect);\n\t\t}\n\t}\n\treturn maxn;\n}\nint main(){\n\tscanf(\"%d%d\",&H,&W);\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tscanf(\"%d\",&G[i][j]);\n\t\t}\n\t}\n\tfor(int j=0;j<W;j++){\n\t\tfor(int i=0;i<H;i++){\n\t\t\tif(G[i][j]) T[i][j]=0;\n\t\t\telse T[i][j]=i>0?T[i-1][j]+1:1;\n\t\t}\n\t}\n\tint maxn=0;\n\tfor(int i=0;i<H;i++){\n\t\tmaxn=max(maxn,f(T[i]));\n\t}\n\tprintf(\"%d\\n\",maxn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value==0>::type\nfill_v(T &t,const V &v){t=v;}\n\ntemplate<typename T,typename V>\ntypename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t,const V &v){\n  for(auto &e:t) fill_v(e,v);\n}\n\n\ntemplate<typename T1,typename T2> inline void chmin(T1 &a,T2 b){if(a>b) a=b;}\ntemplate<typename T1,typename T2> inline void chmax(T1 &a,T2 b){if(a<b) a=b;}\n\nInt calc(vector<Int> &v){\n  Int n=v.size();\n  Int res=0;\n  using P = pair<Int, Int>;\n  stack<P> sp;\n  sp.emplace(-1,-1);\n  for(Int i=0;i<n;i++){\n    while(sp.top().second>=v[i]) sp.pop();\n    chmax(res,(i-sp.top().first)*v[i]);\n    sp.emplace(i,v[i]);\n  }\n  return res;\n}\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int h,w;\n  cin>>h>>w;\n  auto a=make_v<Int>(h,w);\n  for(Int i=0;i<h;i++)\n    for(Int j=0;j<w;j++)\n      cin>>a[i][j];\n  auto dp=make_v<Int>(h,w);\n  fill_v(dp,0);\n  for(Int i=0;i<h;i++){\n    for(Int j=0;j<w;j++){\n      if(a[i][j]) continue;\n      dp[i][j]=(i?dp[i-1][j]:0)+1;\n    }\n  }\n  Int ans=0;\n  for(Int i=0;i<h;i++) chmax(ans,calc(dp[i]));\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\n#include<stack>\nusing namespace std;\nint H,W;\nint G[2000][2000];\nint T[2000][2000];\nstruct ang{\n\tint height,pos;\n};\nint f(int a[]){\n\tstack < ang > S;\n\tint maxn=0;\ta[W]=0;\n\tfor(int i=0;i<W;i++){\n\t\tang rect;\n\t\trect.height=a[i];\n\t\trect.pos=i;\n\t\tif(S.empty()){\n\t\t\tS.push(rect);\n\t\t}\n\t\telse {\n\t\t\tif(S.top().height<rect.height) S.push(rect);\n\t\t\telse if(S.top().height>rect.height){\n\t\t\t\tint pre=i;\n\t\t\t\twhile(!S.empty()&&S.top().height>=rect.height){\n\t\t\t\t\tang k=S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tint area=k.height*(i-k.pos);\n\t\t\t\t\tmaxn=max(maxn,area);\n\t\t\t\t\tpre=k.pos;\n\t\t\t\t}\n\t\t\t\trect.pos=pre;S.push(rect);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t}\n\treturn maxn;\n}\nint main(){\n\tscanf(\"%d%d\",&H,&W);\n\tfor(int i=0;i<H;i++){\n\t\tfor(int j=0;j<W;j++){\n\t\t\tscanf(\"%d\",&G[i][j]);\n\t\t}\n\t}\n\tfor(int j=0;j<W;j++){\n\t\tfor(int i=0;i<H;i++){\n\t\t\tif(G[i][j]) T[i][j]=0;\n\t\t\telse T[i][j]=i>0?T[i-1][j]+1:1;\n\t\t}\n\t}\n\tint maxn=0;\n\tfor(int i=0;i<H;i++){\n\t\tmaxn=max(maxn,f(T[i]));\n\t}\n\tprintf(\"%d\\n\",maxn);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct rect{\n\t  int left, height;\n\t  rect(int l, int h){\n\t\t\tleft = l; height = h;\n\t  }\n};\n\nint solve(vector<int>& hist){\n\t  hist.push_back(0);\n\t  int W = hist.size();\n\t  int ans = 0;\n\t  stack<rect> st;\n\t  for(int i=0; i<W; i++){\n\t\t\tif( st.empty() ){\n\t\t\t\t  st.push( rect(i,hist[i]) );\t  continue;\n\t\t\t}\n\t\t\trect max_h = st.top();\n\t\t\tif( max_h.height < hist[i]){\n\t\t\t\t  st.push( rect(i,hist[i]) );\n\t\t\t}\n\t\t\telse if( max_h.height == hist[i] ){\n\t\t\t\t  continue;\n\t\t\t}\n\t\t\telse if( max_h.height > hist[i] ){\n\t\t\t\t  while( !st.empty() and max_h.height > hist[i] ) {\n\t\t\t\t\t\tans = max(ans, max_h.height * (i-max_h.left) );\n\t\t\t\t\t\tst.pop();\n\t\t\t\t  }\n\t\t\t\t  st.push( rect(max_h.left, hist[i]) ) ;\n\t\t\t}\n\t  }\n\t  return ans ;\n\t\t\t\n}\n\nint main(){\n\t  // input\n\t  int H,W;\n\t  cin >> H >> W;\n\t  vector<vector<int> > m(H+1,vector<int>(W,0));\n\t  for(int i=1; i<=H; i++)\n\t\t\tfor(int j=0; j<W; j++)\n\t\t\t\t  cin >> m[i][j];\n\n\t  // pre proces\n\t  vector<vector<int> > dp(H+1,vector<int>(W,0));\n\t  for(int i=1; i<=H; i++){\n\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\t  if(m[i][j] == 1)\n\t\t\t\t\t\tdp[i][j] = 0;\n\t\t\t\t  else\n\t\t\t\t\t\tdp[i][j] = dp[i-1][j]+1;\n\t\t\t}\n\t  }\n\t  \n\t  int ans = 0;\n\t  for(int i=1; i<=H; i++)\n\t\t\tans = max(ans, solve(dp[i]));\n\n\n\t  /*\n\t  for(int i=1; i<=H; i++){\n\t\t\tfor(int j=0; j<W; j++){\n\t\t\t\t  cout << dp[i][j] <<\" \";\n\t\t\t}\n\t\t\tcout << \": \" << solve(dp[i]) << endl;\n\t  }\n\t  */\n\t  \n\t  cout << ans << endl;\n\t  \n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<stack>\n#include<algorithm>\n#define MAX 1400\n\nusing namespace std;\n\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectangle(int size, int buffer[]) {\n\tstack<Rectangle> S;\n\tint maxv = 0;\n\tbuffer[size] = 0;\n\n\tfor (int i = 0; i <= size; i++) {\n\t\tRectangle rect;\n\t\trect.height = buffer[i];\n\t\trect.pos = i;\n\t\tif (S.empty()) {\n\t\t\tS.push(rect);\n\t\t}\n\t\telse {\n\t\t\tif (S.top().height < rect.height) {\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t\telse if (S.top().height > rect.height) {\n\t\t\t\tint target = i;\n\t\t\t\twhile (!S.empty() && S.top().height >= rect.height) {\n\t\t\t\t\tRectangle pre = S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tint area = pre.height*(i - pre.pos);\n\t\t\t\t\tmaxv = max(maxv, area);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos = target;\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxv;\n}\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle() {\n\tfor (int j = 0; j < W; j++) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tif (buffer[i][j]) {\n\t\t\t\tT[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tT[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxv = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tmaxv = std::max(maxv, getLargestRectangle(W, T[i]));\n\t}\n\n\treturn maxv;\n}\n\nint main() {\n\tscanf(\"%d %d\", &H, &W);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tscanf(\"%d\", &buffer[i][j]);\n\t\t}\n\t}\n\tcout << getLargestRectangle() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n#define INF 1<<30\n#define LINF 1LL<<60\n\nstruct Rectangle {\n\tint h;\n\tint p;  // position from left\n};\n\nint max_area_of_histgram(int n, vector<int>& height) {\n\tstack<Rectangle> S;\n\n\t/*  initialize  */\n\tint maxv = 0;\n\n\tfor (int i = 0; i <= n; i++) {\n\t\tRectangle rect;\n\t\trect.h = height[i];\n\t\trect.p = i;\n\n\t\tif (S.empty()) {\n\t\t\tS.push(rect);\n\t\t}\n\t\telse if (S.top().h < rect.h) {\n\t\t\tS.push(rect);\n\t\t}\n\t\telse if (S.top().h > rect.h) {\n\t\t\tint now = i;\n\t\t\twhile (!(S.empty()) && (S.top().h >= rect.h)) {\n\t\t\t\tRectangle pre_rect = S.top(); S.pop();\n\t\t\t\tmaxv = max(maxv, pre_rect.h * (i - pre_rect.p));\n\t\t\t\tnow = pre_rect.p;\n\t\t\t}\n\t\t\trect.p = now;\n\t\t\tS.push(rect);\n\t\t}\n\t}\n\treturn maxv;\n}\n\nint get_Largest_Rectangle(int H, int W, vector<vector<int>>& dp) {\n\tfor (int h = 1; h < H; h++) {\n\t\tfor (int w = 0; w < W; w++) {\n\t\t\tif (dp[h][w] == 0) continue;\n\t\t\tdp[h][w] = dp[h - 1][w] + 1;\n\t\t}\n\t}\n\n\tint maxv = 0;\n\tfor (int h = 0; h < H; h++) {\n\t\tmaxv = max(maxv, max_area_of_histgram(W, dp[h]));\n\t}\n\treturn maxv;\n}\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint H, W; cin >> H >> W;\n\tvector<vector<int>> c(H + 1, vector<int>(W + 1, 0)), dp(H + 1, vector<int>(W + 1, 0));\n\n\tfor (int h = 0; h < H; h++) {\n\t\tfor (int w = 0; w < W; w++) {\n\t\t\tcin >> c[h][w];\n\t\t\tif (c[h][w] == 0) { dp[h][w] = 1; }\n\t\t\telse { dp[h][w] = 0; }\n\t\t}\n\t}\n\tcout << get_Largest_Rectangle(H, W, dp) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <stack>\n#include <utility>\n\nusing namespace std;\n\nint main() {\n\tint H, W;\n\tscanf(\"%d %d\", &H, &W);\n\n\tint A[H][W];\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tscanf(\"%d\", &A[i][j]);\n\t\t}\n\t}\n\tint V[H + 1][W + 1];\n\tfor (int i = 0; i <= H; ++i) {\n\t\tfor (int j = 0; j <= W; ++j) {\n\t\t\tV[i][j] = 0;\n\t\t}\n\t}\n\tfor (int j = 0; j < W; ++j) {\n\t\tfor (int i = 1; i <= H; ++i) {\n\t\t\tif (A[i - 1][j] == 0)\n\t\t\t\tV[i][j] = V[i - 1][j] + 1;\n\t\t\telse {\n\t\t\t\tV[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxArea = 0;\n\tfor (int i = 1; i <= H; ++i) {\n\t\tstack<pair<int, int>> S;\n\t\tS.push(make_pair(0, V[i][0]));\n\t\tfor (int j = 1; j <= W; ++j) {\n\t\t\tpair<int, int> p = S.top();\n\t\t\tif (V[i][j] > p.second) {\n\t\t\t\tS.push(make_pair(j, V[i][j]));\n\t\t\t} else if (V[i][j] < p.second) {\n\t\t\t\tint pos;\n\t\t\t\twhile (!S.empty() && V[i][j] <= p.second) {\n\t\t\t\t\tS.pop();\n\t\t\t\t\tif (p.second > 0)\n\t\t\t\t\t\tpos = p.first;\n\t\t\t\t\tint area = (j - p.first) * p.second;\n\t\t\t\t\tmaxArea = max(maxArea, area);\n\t\t\t\t\tif (!S.empty())\n\t\t\t\t\t\tp = S.top();\n\t\t\t\t}\n\t\t\t\tS.push(make_pair(pos, V[i][j]));\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxArea << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#pragma comment(linker,\"/STACK:102400000,102400000\")\n#define INF 0x3f3f3f3f\n#define maxm 1500\ntypedef long long ll;\nusing namespace std;\nint mp[maxm][maxm]{0};\nint t[maxm][maxm]{0};\nint calRectangle(int (&vec)[maxm],int w)\n{\n    int result=0;\n    stack<int> stk;\n    vec[w+1]=0;\n    //for(int i=1;i<=w;i++)cout<<vec[i]<<\" \";cout<<endl;\n    for(int i=1;i<=w+1;i++)\n    {\n        if(stk.empty()||vec[stk.top()]<=vec[i])\n            stk.push(i);\n        else\n        {\n            int temp=stk.top();\n            stk.pop();\n            result=max(result,vec[temp]*( stk.empty()?(i-1):((i-1)-stk.top()-1)) );\n            i--;\n        }\n    }\n    //cout<<result<<endl;\n    return result;\n}\nint main()\n{\n    int h,w,pt,res=0;\n    cin>>h>>w;\n    for(int i=1;i<=h;i++)\n        for(int j=1;j<=w;j++)\n            cin>>mp[i][j];\n    for(int j=1;j<=w;j++)\n    {\n        pt=1;\n        for(int i=1;i<=h;i++)\n            if(!mp[i][j])\n                t[i][j]=pt++;\n            else\n            {\n                t[i][j]=0;\n                pt=1;\n            }\n    }\n    //for(int i=1;i<=h;i++){for(int j=1;j<=w;j++)cout<<t[i][j]<<\" \";cout<<endl;};\n    for(int i=1;i<=h;i++)\n        res=max(res,calRectangle(t[i],w));\n    cout<<res<<endl;\n    return 0;\n}\n//Do not use memset !\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX 1400\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n\nint getLargestRect(int size, int buffer[]) {\n  stack<Rectangle> S;\n  int maxv = 0;\n  buffer[size] = 0;\n\n  for (int i = 0; i <= size; i++) {\n    Rectangle rect;\n    rect.height = buffer[i];\n    rect.pos = i;\n    if (S.empty()) {\n      S.push(rect);\n    }\n    if (S.top().height < rect.height) {\n      S.push(rect);\n    }\n    else if (S.top().height == rect.height) {\n      ;\n    }\n    else if (S.top().height > rect.height) {\n      int target = i;\n      while (!S.empty() && S.top().height >= rect.height) {\n        Rectangle pre = S.top(); S.pop();\n        int area = pre.height * (i - pre.pos);\n        maxv = max(maxv, area);\n        target = pre.pos;\n      }\n      rect.pos = target;\n      S.push(rect);\n    }\n  }\n  return maxv;\n}\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRect() {\n  for (int j = 0; j < W; j++) {\n    for (int i = 0; i < H; i++) {\n      if (buffer[i][j]) T[i][j] = 0;\n      else T[i][j] = (i > 0 ? T[i-1][j]+1 : 1);\n    }\n  }\n\n  int maxv = 0;\n  for (int i = 0; i < H; i++) {\n    maxv = max(maxv, getLargestRect(W, T[i]));\n  }\n  return maxv;\n}\n\nint main() {\n  cin >> H >> W;\n  for (int i = 0; i < H; i++) {\n    for (int j = 0; j < W; j++) {\n      cin >> buffer[i][j];\n    }\n  }\n\n  cout << getLargestRect() << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n \n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define dump(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define dump(x)\n#endif\n\ntypedef long long int ll;\ntypedef pair<int,int> pii;\n//template<typename T> using vec=std::vector<T>;\n\nconst int inf=1<<30;\nconst long long int infll=1LL<<58;\nconst double EPS=1e-9;\nconst int dx[]={1,0,-1,0},dy[]={0,1,0,-1};\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n\tos << \"[\";\n\tfor (const auto &v : vec) {\n\t\tos << v << \",\";\n\t}\n\tos << \"]\";\n\treturn os;\n}\n\nint get_largest_rectangle(int c[],int size){\n    stack<pii> stk;\n    int res=0;\n    c[size]=0;\n    \n    rep(i,0,size+1){\n        pii rect;\n        rect.first=c[i];\n        rect.second=i;\n        if(stk.empty() or stk.top().first<rect.first) stk.push(rect);\n        else if(stk.top().first>rect.first){\n            int target=i;\n            while(!stk.empty() and stk.top().first>=rect.first){\n                pii pre=stk.top();\n                stk.pop();\n                int area=pre.first*(i-pre.second);\n                res=max(res,area);\n                target=pre.second;\n            }\n            rect.second=target;\n            stk.push(rect);\n        }\n    }\n    return res;\n}\n\nvoid solve(){\n    int h,w;\n    cin >> h >> w;\n    \n    static int c[1400][1401];\n    rep(i,0,h) rep(j,0,w){\n        cin >> c[i][j];\n        c[i][j]=(c[i][j]+1)%2;\n    }\n    \n    rep(i,1,h) rep(j,0,w) if(c[i-1][j] and c[i][j]) c[i][j]=c[i-1][j]+1;\n    \n    int ans=0;\n    rep(i,0,h) ans=max(ans,get_largest_rectangle(c[i],w));\n    cout << ans << endl;\n}\n\nint main(){\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(0);\n\tsolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n\tRectangle rect;\n\tfor(int i=0;i<x;i++){\n\t\tstack<Rectangle> stk;\n\t\tfor(int j=0;j<=y;j++){\n\t\t\trect.height = m[j][i];\n\t\t\trect.pos = j;\n\t\t\tif(stk.empty() || stk.top().height < rect.height){\n\t\t\t\tstk.push(rect);\n\t\t\t}else{\n\t\t\t\tint target = j;\n\t\t\t\tfor(;!stk.empty() && stk.top().height >= rect.height;){\n\t\t\t\t\tRectangle pre = stk.top(); stk.pop();\n\t\t\t\t\tint area = pre.height * (j - pre.pos);\n\t\t\t\t\tr = max(r, area);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos = target;\n\t\t\t\tstk.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<stack>\n#include<algorithm>\n#define MAX 1400\n\nusing namespace std;\n\nstruct Rectangle { int height; int pos; };\n\nint getLargestRectsngle(int size, int buffer[]) {\n\tstack<Rectangle> S;\n\tint maxv = 0;\n\tbuffer[size] = 0;\n\n\tfor (int i = 0; i <= size; i++) {\n\t\tRectangle rect;\n\t\trect.height = buffer[i];\n\t\trect.pos = i;\n\t\tif (S.empty()) {\n\t\t\tS.push(rect);\n\t\t}\n\t\telse {\n\t\t\tif (S.top().height < rect.height) {\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t\telse if (S.top().height > rect.height) {\n\t\t\t\tint target = i;\n\t\t\t\twhile (!S.empty() && S.top.height >= rect.height) {\n\t\t\t\t\tRectangle pre = S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tint area = pre.height*(i - pre.pos);\n\t\t\t\t\tmaxv = max(maxv, area);\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\t\t\t\trect.pos = target;\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxv;\n}\n\nint H, W;\nint buffer[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle() {\n\tfor (int j = 0; j < W; j++) {\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tif (buffer[i][j]) {\n\t\t\t\tT[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tT[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxv = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tmaxv = max(maxv, getLargestRectangle(W, T[i]));\n\t}\n\n\treturn maxv;\n}\n\nint main() {\n\tscanf(\"%d %d\", &H, &W);\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tscanf(\"%d\", &buffer[i][j]);\n\t\t}\n\t}\n\tcout << getLargestRectangle() << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define cic(in,n) for(int i=in;i<n;++i)\n#define rep(i,a,n) for(int i=a;i<n;++i)\n#define All(a) a.begin(),a.end()\n#define PB push_back\n#define FIND(m,v) (m.find(v) != m.end())\n#define print(n) cout<<n<<endl;\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\nconst int MAX = 1401, mod = 1e9+7, oo = INT_MAX;\n\nint n,m,a[MAX][MAX],dp[MAX][MAX];\n\nint calc(vi a){\n\t\n\tvector<pii> lim;\n\t\n\tstack<int> s;\n\ts.push(0);\n\tlim.PB({-1,0});\n\t\n\trep(i,1,a.size()){\n\t\twhile(!s.empty() && a[s.top()]>= a[i]) s.pop();\n\t\tif(s.empty()) \n\t\t\tlim.PB({-1,0});\n\t\telse \n\t\t\tlim.PB({s.top(),0});\n\t\ts.push(i);\n\t}\n\t\n\tstack<int> s1;\n\ts1.push(a.size()-1);\n\tlim[a.size()-1].second = a.size();\n\tfor(int i = a.size()-2;i>=0;--i){\n\t\twhile(!s1.empty() && a[s1.top()]>= a[i]) s1.pop();\n\t\tif(s1.empty()) \n\t\t\tlim[i].second = a.size();\n\t\telse \n\t\t\tlim[i].second = s1.top();\n\t\ts1.push(i);\n\t}\n\tint m =0;\n\t\n\trep(i,0,lim.size()){\n\t\tint aux = (lim[i].second - lim[i].first - 1 )*a[i];\n\t\tif(aux>m) m=aux; \n\t}\n\t\n\treturn m;\n}\n\nint main()\n{\n\tios_base :: sync_with_stdio(0);\n\tcin.tie();\n\tcin>>n>>m;\n\trep(i,0,n){\n\t\trep(j,0,m){\n\t\t\tcin>>a[i][j];\n\t\t}\n\t}\n\tint resp = 0;\n\tvi aux;\n\trep(i,0,m){\n\t\tif(a[0][i]) dp[0][i] = 0;\n\t\telse dp[0][i] = 1;\n\t\taux.PB(a[0][i]);\n\t}\n\tresp = max(calc(aux),resp);\n\taux.clear();\n\trep(i,1,n){\n\t\trep(j,0,m){\n\t\t\tif(a[i][j]) dp[i][j] = 0;\n\t\t\telse dp[i][j] = 1 + dp[i-1][j];\n\t\t\taux.PB(dp[i][j]);\n\t\t}\n\t\tresp = max(calc(aux),resp);\n\t\taux.clear();\n\t}\n\tcout<<resp<<'\\n';\n\treturn 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<algorithm>\nusing namespace std;\nconst int maxn = 1401;\n\nint Squre[maxn][maxn];\nstruct rectangle\n{\n    int height;\n    int pos;\n};\nrectangle rec[maxn][maxn];\nint solve(int h, int w)\n{\n    int maxs = 0;\n    for(int i = 0; i < h; i++)\n        rec[i][w].height = 0;\n    for(int i = 1; i < h; i++)\n        for(int j = 1; j < w; j++)\n        {\n            if(Squre[i][j])\n                rec[i][j].height = rec[i-1][j].height + 1;\n            else\n                rec[i][j].height = 0;\n            maxs = max(rec[i][j].height, maxs);\n        }\n\n    stack<rectangle> s;\n    for(int i = 0; i < h; i++)\n    {\n        for(int j = 0; j <= w; j++)\n        {\n            rectangle rect;\n            rect.height = rec[i][j].height;\n            rect.pos = j;\n            if(s.empty())\n                s.push(rect);\n            else\n            {\n                if(s.top().height < rect.height)\n                    s.push(rect);\n                else if(s.top().height > rect.height)\n                {\n                    int target = j;\n                    while(!s.empty() && s.top().height >= rect.height)\n                    {\n                        rectangle pre = s.top();\n                        s.pop();\n                        int area = pre.height * (j - pre.pos);\n                        maxs = max(maxs, area);\n                        target = pre.pos;\n                    }\n                    rect.pos = target;\n                    s.push(rect);\n                }\n            }\n        }\n    }\n    return maxs;\n}\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n    for(int i = 0; i < h; i++)\n        for(int j = 0; j < w; j++)\n            cin >> Squre[i][j];\n\n    int ans = solve(h, w);\n    cout << ans << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\n#define p_ary(ary,a,b,i) do { cout << \"[\"; for (int (i) = (a);(i) < (b);++(i)) cout << ary[(i)] << ((b)-1 == (i) ? \"\" : \", \"); cout << \"]\\n\"; } while(0)\n#define p_map(map,it) do {cout << \"{\";for (auto (it) = map.begin();;++(it)) {if ((it) == map.end()) {cout << \"}\\n\";break;}else cout << \"\" << (it)->first << \"=>\" << (it)->second << \", \";}}while(0)\n\nint getLargestRectangle(vector<int>& hight) {\n    int w = hight.size(),res = 0;\n    stack<P> st;\n    for (int i = 0;i < w;++i) {\n        if (st.empty()) {\n            if (hight[i]) st.push(P(hight[i],i));\n        } else {\n            int t = st.top().first;\n            if (t < hight[i]) st.push(P(hight[i],i));\n            else if (t > hight[i]) {\n                int l = i;\n                while (!st.empty() && hight[i] < st.top().first) {\n                    P p = st.top();\n                    l = p.second;\n                    res = max(res,(p.first)*(i-l));\n                    st.pop();\n                }\n                if (st.empty() || st.top().first < hight[i]) st.push(P(hight[i],l));\n            }\n        }\n    }\n    return res;\n}\n\nint getLargestRectangle(vector<vector<int>>& grid) {\n    int h = grid.size(),w = grid[0].size();\n    vector<vector<int>> hight(h,vector<int>(w));\n    hight = grid;\n    for (int j = 0;j < w;++j) for (int i = 1;i < h;++i) if (hight[i][j]) hight[i][j] += hight[i-1][j];\n    for (int i = 0;i < h;++i) hight[i].emplace_back(0);\n    int res = 0;\n    for (int i = 0;i < h;++i) res = max(res,getLargestRectangle(hight[i]));\n    return res;\n}\n\nint main() {\n    int h,w;\n    cin >> h >> w;\n    vector<vector<int>> t(h,vector<int>(w));\n    for (int i = 0;i < h;++i) for (int j = 0;j < w;++j) {\n        int c;\n        cin >> c;\n        t[i][j] = c^1;\n    }\n    cout << getLargestRectangle(t) << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\n#include <math.h>\n#include <stack>\n \nusing namespace std;\n \nstruct Info{\n    Info(){ left = height = 0;}\n    Info(int arg_left,int arg_height){\n        left = arg_left;\n        height = arg_height;\n    }\n    int left,height;\n};\n \nint main(){\n \n    int H,W,max_s,tmp,tmp_h;\n \n    scanf(\"%d %d\",&H,&W);\n \n    int** table = new int*[H+1];\n    for(int i = 0; i < H+1; i++){\n        table[i] = new int[W+1];\n    }\n \n    for(int i = 0; i < W+1; i++)table[0][i] = 0;\n    for(int i = 0; i < H+1; i++)table[i][W] = 0;\n \n    stack<Info> S;\n    Info work;\n \n    max_s = 0;\n \n    for(int i = 1;i <= H; i++){\n        for(int k = 0; k < W; k++){\n            scanf(\"%d\",&table[i][k]);\n            if(table[i][k] == 0){\n                table[i][k] = table[i-1][k] + 1;\n            }else{\n                table[i][k] = 0;\n            }\n        }\n \n        tmp_h = table[i][0];\n        S.push(Info(0,tmp_h));\n \n        for(int k = 1; k < W+1; k++){\n            if(table[i][k] > tmp_h){\n                S.push(Info(k,table[i][k]));\n                tmp_h = table[i][k];\n            }else if(table[i][k] == tmp_h){\n \n            }else{\n                while(S.empty() == false && S.top().height >= table[i][k]){\n                    work = S.top();\n                    S.pop();\n                    tmp = (k - work.left)*work.height;\n                    max_s = (max_s >= tmp)?max_s:tmp;\n                }\n                tmp_h = table[i][k];\n                S.push(Info(work.left,table[i][k]));\n            }\n        }\n    }\n \n    printf(\"%d\\n\",max_s);\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <stack>\nusing namespace std;\n\nstatic const int MAX_NUM = 140;\n\nint LargestRectangle(bool area[][MAX_NUM+1], int height, int width)\n{\n    int i, j;\n    int rect[MAX_NUM+1][MAX_NUM+1] = {0};\n    int maximum = 0;\n\n    for (i = 1; i <= width; i++) {\n        for (j = 1; j <= height; j++) {\n            if (area[j][i] == false) {\n                rect[j][i] = rect[j - 1][i] + 1;\n            }\n        }\n    }\n\n    for (i = height; i >= 1; i--) {\n        stack<pair<int, int> > stRect;\n        pair<int, int> topelem;\n\n        for (j = 1; j <= width; j++) {\n            if (stRect.empty() == false) {\n                topelem = stRect.top();\n                if (topelem.first > rect[i][j]) {\n                    while ((topelem.first > rect[i][j]) && (stRect.empty() == false)) {\n                        stRect.pop();\n                        maximum = max(maximum, (j - topelem.second) * topelem.first);\n                    }\n                }\n                else if (topelem.first == rect[i][j]) {\n                    continue;\n                }\n            }\n            stRect.push(make_pair(rect[i][j], j));\n        }\n        while (stRect.empty() == false) {\n            topelem = stRect.top();\n            stRect.pop();\n            maximum = max(maximum, (width - topelem.second) * topelem.first);\n        }\n    }\n\n    return maximum;\n}\n\nint main(void)\n{\n    int  i, j;\n    int  ret;\n    int  height, width;\n    bool area[MAX_NUM+1][MAX_NUM+1] = {0};\n\n    scanf(\"%d %d\", &height, &width);\n    for (i = 1; i <= height; i++) {\n        for (j = 1; j <= width; j++) {\n            scanf(\"%d\", &area[i][j]);\n        }\n    }\n\n    ret = LargestRectangle(area, height, width);\n\n    printf(\"%d\\n\", ret);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for (int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\n\nint T[1500][1500];\nstruct rect {\n    int h;\n    int p;\n};\n\nint main() {\n    int H, W; cin >> H >> W;\n    rep(i, H){\n        rep(j, W){\n            cin >> T[i][j];\n            T[i][j] = (T[i][j]+1) % 2;\n        }\n    }\n\n    for (int i = 1; i < H; i++){\n        for (int j = 0; j < W; j++){\n            if(T[i][j] != 0){\n                T[i][j] = T[i-1][j]+1;\n            }\n        }\n    }\n\n    int ans = 0;\n    rep(i, H){\n        stack<rect> S;\n        rep(j, W+1){\n            rect r = {T[i][j], j};\n            if(S.empty()){\n                S.push(r);\n            } else if(S.top().h < r.h){\n                S.push(r);\n            } else if(S.top().h == r.h){\n                continue;\n            } else {\n                int nowp;\n                while(!S.empty() && S.top().h > r.h){\n                    rect r2 = S.top(); S.pop();\n                    int men = r2.h * (j - r2.p);\n                    ans = max(ans, men);\n                    nowp = r2.p;\n                }\n                r.p = nowp;\n                S.push(r);\n            }\n        }\n    }\n\n    cout << ans << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <cmath>\n#include <ctype.h>\n#include <string> \n#include <sstream>\n#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n#include <map>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <set>\n#include <list>\n#include <cstring>\n#include <stack>\n   \nusing namespace std;\n\n#define mod 1000000007\n\nint main()\n{\n    int h, w;\n    cin >> h >> w;\n    int maxlen[1410][1410] = {};\n    for(int i = 1; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            int c;\n            cin >> c;\n            if(c == 1) continue;\n            maxlen[i][j] = maxlen[i - 1][j] + 1;\n        }\n    }\n    int ans = 0;\n    for(int i = 1; i <= h; i++){\n        stack<pair<int, int> > st;\n        for(int j = 1; j <= w + 1; j++){\n            if(st.empty() || (st.top()).first < maxlen[i][j]){\n                st.push(make_pair(maxlen[i][j], j));\n            } else if((st.top()).first > maxlen[i][j]){\n                int before = j;\n                while(!st.empty()){\n                    if((st.top()).first < maxlen[i][j]){\n                        st.push(make_pair(maxlen[i][j], before));\n                        break;\n                    } else {\n                        ans = max(ans, (st.top()).first * (j - (st.top()).second));\n                        before = (st.top()).second;\n                        st.pop();\n                    }\n                }\n            }\n        }\n    }\n    cout << ans << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\n\nlong long int h[1500] = {}, L[1500], R[1500];\n\nint main(){\n\t\n\tint H, N;\n\tcin >> H >> N;\n\t\n\tlong long int ans = 0;\n\t\n\tfor(int loop = 0; loop < H; loop++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tint num;\n\t\t\tcin >> num;\n\t\t\tif(num){\n\t\t\t\th[j] = 0;\n\t\t\t}else{\n\t\t\t\th[j]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tstack<int> sta;\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\twhile(sta.size() > 0 && h[sta.top()] >= h[i]){\n\t\t\t\tsta.pop();\n\t\t\t}\n\t\t\tif(sta.empty()){\n\t\t\t\tL[i] = 0;\n\t\t\t}else{\n\t\t\t\tL[i] = sta.top() + 1;\n\t\t\t}\n\t\t\tsta.push(i);\n\t\t}\n\t\t\n\t\twhile(!sta.empty()){\n\t\t\tsta.pop();\n\t\t}\n\t\t\n\t\tfor(int i = N - 1; i >= 0; i--){\n\t\t\twhile(sta.size() > 0 && h[sta.top()] >= h[i]){\n\t\t\t\tsta.pop();\n\t\t\t}\n\t\t\tif(sta.empty()){\n\t\t\t\tR[i] = N;\n\t\t\t}else{\n\t\t\t\tR[i] = sta.top();\n\t\t\t}\n\t\t\tsta.push(i);\n\t\t}\n\t\t\n\t\twhile(!sta.empty()){\n\t\t\tsta.pop();\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tans = max(ans, h[i] * (R[i] - L[i]));\n\t\t}\n\t}\n\tcout << ans << endl;\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nint main()\n{\n\tint h, w, mx = 0;\n\tscanf(\"%d %d\", &h, &w);\n\tvector<vector<int>> a(h, vector<int>(w));\n\tfor(int i = 0; i < h; ++i)\n\t{\n\t\tfor (int j = 0, k; j < w; ++j)\n\t\t{\n\t\t\tscanf(\"%d\", &k);\n\t\t\ta[i][j] = !k;\n\t\t}\n\t}\n\tfor(int i = 1; i < h; ++i)\n\t{\n\t\tfor(int j = 0; j < w; ++j)\n\t\t{\n\t\t\tif(a[i][j])\n\t\t\t{\n\t\t\t\ta[i][j] += a[i - 1][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; i < h; ++i)\n\t{\n\t\tstack<pair<int, int>> s;\n\t\tfor(int j = 0, hor = 0; j < w; hor = ++j)\n\t\t{\n\t\t\tfor(int t, u; !s.empty(); )\n\t\t\t{\n\t\t\t\tt = s.top().first;\n\t\t\t\tu = s.top().second;\n\t\t\t\tif(t >= a[i][j])\n\t\t\t\t{\n\t\t\t\t\tmx = max(mx, t * (j - u));\n\t\t\t\t\thor = min(hor, u);\n\t\t\t\t\ts.pop();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.push(make_pair(a[i][j], hor));\n\t\t}\n\t\tfor(; !s.empty(); mx = max(mx, s.top().first * (w - s.top().second)), s.pop());\n\t}\n\tprintf(\"%d\\n\", mx);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\ni64 largest_rectangle(vi hist) {\n    hist.push_back(0);\n    using ii = pair<i64, int>;\n    stack<ii> st;\n    i64 ret = 0;\n    for (int i = 0; i < hist.size(); i++) {\n        if (st.empty() || st.top().first < hist[i]) {\n            st.push(ii(hist[i], i));\n        } else {\n            int s;\n            while (st.size() && st.top().first >= hist[i]) {\n                ret = max(ret, st.top().first * (i - st.top().second));\n                s = st.top().second;\n                st.pop();\n            }\n            st.push(ii(hist[i], s));\n        }\n    }\n    \n    return ret;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    int h, w;\n    cin >> h >> w;\n    vvi b(h, vi(w));\n    for (int i = 0; i < h; i++) {\n        for (int j = 0; j < w; j++) {\n            int c;\n            cin >> c;\n            if (c == 0) {\n                if (i == 0) {\n                    b[i][j] = 1;\n                } else {\n                    b[i][j] = b[i - 1][j] + 1;\n                }\n            } else {\n                b[i][j] = 0;\n            }\n        }\n    }\n\n    i64 ret = 0;\n    for (int i = 0; i < h; i++) {\n        ret = max(ret, largest_rectangle(b[i]));\n    }\n    cout << ret << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define ll long long\n#define rep(i,x,y) for(ll i=x;i<y;i++)\n#define rel(i,x,y) for(ll i=x-1;i>=y;i--)\n#define all(x) x.begin(),x.end()\nint hi,wi;\nint G[1410][1410];\nint hist[1410][1410];\nll histgram(int hig){\n    ll h[wi+1];\n    rep(i,0,wi) h[i] = hist[hig][i];\n    h[wi] = 0; \n    stack<pair<ll,ll>> S; //height, locate\n    ll ma = 0;\n    rep(i,0,wi+1){\n        if(S.empty()){ S.push(make_pair(h[i],i)); continue; }\n        if(S.top().first == h[i]) continue;\n        if( S.top().first < h[i]) S.push(make_pair(h[i],i)); //大きいのはstack\n        else{\n            ll LocateCheck = S.top().second;\n            while((!S.empty()) && S.top().first >= h[i] ){\n                ma = max(ma,S.top().first * (i-S.top().second));\n                LocateCheck = S.top().second;\n                S.pop();\n            }\n            S.push(make_pair(h[i],LocateCheck));\n        }\n    }\n    \n    return ma;\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(15);\n    cin >> hi >> wi; //histgramのhとかぶるのでhi\n    ll ma=0;\n    rep(i,0,hi){\n        rep(j,0,wi){\n            cin >> G[i][j];\n        }\n    }\n    //各行までのヒストグラムを作成\n    rep(i,0,wi) hist[0][i] = abs(1-G[0][i]); /*0,1逆転*/// cout << hist[0][i] << \" \"; }\n    rep(i,1,hi){\n        rep(j,0,wi){\n            if(G[i][j]==0) hist[i][j] = hist[i-1][j]+1;\n            else hist[i][j] = 0;\n          //  cout << hist[i][j] << \" \";\n        }\n        //cout << endl;\n    }\n    rep(i,0,hi) ma = max(ma,histgram(i));\n    cout << ma << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <algorithm>\n#include <cmath>\n#include <map>\n#include <set>\n#include <vector>\n#include <stack>\n#pragma comment(linker,\"/STACK:102400000,102400000\")\n#define INF 0x3f3f3f3f\n#define maxm 1500\ntypedef long long ll;\nusing namespace std;\nint mp[maxm][maxm]{0};\nint t[maxm][maxm]{0};\nint calRectangle(int (&vec)[maxm],int w,int time)\n{\n    int result=0;\n    stack<int> stk;\n    vec[w+1]=0;\n    //if(true){for(int i=1;i<=w;i++)cout<<vec[i]<<\" \";cout<<endl;}\n    for(int i=1;i<=w+1;)\n    {\n        if(stk.empty()/*Stuck is empty*/||vec[stk.top()]<=vec[i]/*The list upper*/)\n        {\n            stk.push(i);/*Stuck <- i(pointer)*/\n            i++;\n        }\n        else\n        {\n            int temp=stk.top();/*Save the topStuck pointer*/\n            stk.pop();/*Find the former pushed pointer*/\n            result=max(result,vec[temp]*(stk.empty()?(i-1):(i-stk.top()-1)));\n            //i--;/*Keep the value of i(i--++=1)*/\n        }\n    }\n    //cout<<result<<endl;\n    return result;\n}\nint main()\n{\n    int h,w,pt,res=0;\n    cin>>h>>w;\n    for(int i=1;i<=h;i++)\n        for(int j=1;j<=w;j++)\n            cin>>mp[i][j];\n    for(int j=1;j<=w;j++)\n    {\n        pt=1;\n        for(int i=1;i<=h;i++)\n            if(!mp[i][j])\n                t[i][j]=pt++;\n            else\n            {\n                t[i][j]=0;\n                pt=1;\n            }\n    }\n    //for(int i=1;i<=h;i++){for(int j=1;j<=w;j++)cout<<t[i][j]<<\" \";cout<<endl;};\n    for(int i=1;i<=h;i++)\n        res=max(res,calRectangle(t[i],w,i));\n    cout<<res<<endl;\n    return 0;\n}\n//Do not use memset !\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>           // printf(), getchar(), scanf()\n#include <stack>\n\nusing namespace std;\nstatic const int MAX_M = 1400;\n\nstruct Rectangle\n{\n\tint height;\n\tint pos;\n};\n\nint G[MAX_M][MAX_M];\nint dp[MAX_M][MAX_M + 1];\nint H, W;\n\nint\ngetLargestRectangle(int size, int H[])\n{\n\tRectangle rect;\n\tstack<Rectangle> S;\n\n\tint maxv = 0;\n\tH[size] = 0;\n\n\tfor (int i = 0; i <= size; ++i)\n\t{\n\t\trect.height = H[i];\n\t\trect.pos = i;\n\t\tif (S.empty())\n\t\t\tS.push(rect);\n\t\telse\n\t\t{\n\t\t\tif (S.top().height < rect.height)\n\t\t\t\tS.push(rect);\n\t\t\telse if (S.top().height > rect.height)\n\t\t\t{\n\t\t\t\tint target = i;\n\t\t\t\twhile (!S.empty() && S.top().height >= rect.height)\n\t\t\t\t{\n\t\t\t\t\tRectangle pre = S.top(); S.pop();\n\t\t\t\t\tint area = pre.height * (i - pre.pos);\n\t\t\t\t\tif (area > maxv)\n\t\t\t\t\t\tmaxv = area;\n\n\t\t\t\t\ttarget = pre.pos;\n\t\t\t\t}\n\n\t\t\t\trect.pos = target;\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn maxv;\n}\n\nint\ngetLargestRectangle()\n{\n\tfor (int j = 0; j < W; ++j)\n\t{\n\t\tfor (int i = 0; i < H; ++i)\n\t\t{\n\t\t\tif (G[i][j])\n\t\t\t\tdp[i][j] = 0;\n\t\t\telse\n\t\t\t\tdp[i][j] = (i > 0) ? dp[i - 1][j] + 1 : 1;\n\t\t}\n\t}\n\n\tint maxv = 0;\n\tfor (int i = 0; i < H; ++i)\n\t{\n\t\tint t = getLargestRectangle(W, dp[i]);\n\t\tif (t > maxv)\n\t\t\tmaxv = t;\n\t}\n\n\treturn maxv;\n}\n\nint\nmain(int argc, char** argv)\n{\n\tint c;\n\n\tscanf(\"%d %d\", &H, &W);\n\tc = getchar();\n\tfor (int i = 0; i < H; ++i)\n\t{\n\t\tfor (int j = 0; j < W; ++j)\n\t\t{\n\t\t\twhile (c == ' ' || c == '\\n')\n\t\t\t\tc = getchar();\n\n\t\t\tG[i][j] = (c != '0') ? 1 : 0;\n\t\t\tc = getchar();\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", getLargestRectangle());\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main()\n{\n\tint H, W;\n\tcin >> H >> W;\n\tvector<vector<int>> c(H, vector<int>(W + 1, 1));\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> c[i][j];\n\t\t}\n\t}\n\tvector<vector<int>> dp(H + 1, vector<int>(W + 1));\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W + 1; j++) {\n\t\t\tif (c[i][j]) {\n\t\t\t\tdp[i + 1][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i + 1][j] = dp[i][j] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < H; i++) {\n\t\tvector<int> st(1, 0), p(1, -1);\n\t\tfor (int j = 0; j <= W; j++) {\n\t\t\tint tp = j;\n\t\t\twhile (st.back() > dp[i + 1][j]) {\n\t\t\t\tres = max(res, st.back() * (j - p.back()));\n\t\t\t\ttp = p.back();\n\t\t\t\tst.pop_back();\n\t\t\t\tp.pop_back();\n\t\t\t}\n\t\t\tif (st.back() < dp[i + 1][j]) {\n\t\t\t\tst.push_back(dp[i + 1][j]);\n\t\t\t\tp.push_back(tp);\n\t\t\t}\n\t\t}\n\t}\n\tcout << res << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nint a[1444][1444];\nint p[1444][1444];\nint l[1444],r[1444];\nint main(){\n\tcin.tie(0);\n\tint n,m;cin>>n>>m;\n\tfor(int i=1;i<=n;i++)for(int j=1;j<=m;j++)cin>>a[i][j];\n\tfor(int j=1;j<=m;j++){\n\t\tint k=0;\n\t\tfor(int i=1;i<=n;i++){\n\t\t\tif(a[i][j]==0)k++;\n\t\t\telse k=0;\n\t\t\tp[i][j]=k;\n\t\t}\n\t}\n\tint res=0;\n\tfor(int i=1;i<=n;i++){\n\t\tstack<pair<int,int> >s;// (h,jb)最小单增队列 \n\t\ts.push({-1,0});// 作为左最小界 \n\t\tint ll=0;\n\t\tfor(int j=1;j<=m;j++){\n\t\t\twhile(s.top().first>p[i][j]){// 不用判空，因为留着最小的呢不会空 \n\t\t\t\tint h=s.top().first;\n\t\t\t\tint jb=s.top().second;\n\t\t\t\ts.pop();\n\t\t\t\tr[jb]=j;\n\t\t\t}\n\t\t\tif(s.top().first<p[i][j])ll=s.top().second;\n\t\t\tl[j]=ll;\n\t\t\ts.push({p[i][j],j});\n\t\t}\n\t\twhile(!s.empty()){\n\t\t\tint h=s.top().first;\n\t\t\tint jb=s.top().second;\n\t\t\ts.pop();\n\t\t\tr[jb]=m+1;\n\t\t}\n\t\tfor(int j=1;j<=m;j++)\n\t\t\tres=max(res,(r[j]-l[j]-1)*p[i][j]);\n\t}\n\tcout<<res<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 999999999\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\ntypedef pair<int,int>P;\n\nconst int MAX_N = 1400;\n\nint a[MAX_N][MAX_N];\nint t[MAX_N][MAX_N];\ndeque<P> deq;\n\nint main()\n{\n\tint h,w;\n\tcin >> h >> w;\n\tint ans=0;\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tscanf(\"%d\",&a[i][j]);\n\t\t}\n\t}\n\trep(i,h){\n\t\tt[i][w] = 0;\n\t}\n\trep(j,w){\n\t\tt[0][j] = 1^a[0][j];\n\t}\n\tfor(int i=1;i<h;i++){\n\t\trep(j,w){\n\t\t\tif(a[i][j]==0){\n\t\t\t\tt[i][j] = t[i-1][j] + 1;\n\t\t\t}else{\n\t\t\t\tt[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\trep(i,h){\n\t\trep(j,w){\n\t\t\tcout << t[i][j] << \" \";\n\t\t}\n\t\tcout << \"\\n\";\n\t}\n\tint pos;\n\trep(i,h){\n\t\trep(j,w+1){\n\t\t\tif(deq.empty()){\n\t\t\t\tdeq.push_back(P(t[i][j],j));\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdeque<P>::iterator it = deq.end()-1;\n\t\t\tif((*it).first < t[i][j]){\n\t\t\t\tdeq.push_back(P(t[i][j],j));\n\t\t\t}else if((*it).first > t[i][j]){\n\t\t\t\twhile(!deq.empty() && (*it).first > t[i][j]){\n\t\t\t\t\tint S = (*it).first*(j-(*it).second);\n\t\t\t\t\tpos = (*it).second;\n\t\t\t\t\tans = max(S,ans);\n\t\t\t\t\tdeq.pop_back();\n\t\t\t\t\tit = deq.end()-1;\n\t\t\t\t}\n\t\t\t\tdeq.push_back(P(t[i][j],pos));\n\t\t\t}\n\t\t}\n\t}\n\tprintf(\"%d\\n\",ans);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define int long long\n\nusing namespace std;\n#define REP(i, s, n) for(signed i = (s); i < signed(n); i++)\n#define rep(i, n) REP(i, 0, n)\n#define rrep(i, n) for(int i = signed(n) - 1; i >= 0; i--)\n#define all(co) co.begin(), co.end()\ntypedef pair<int, int> P;\ntypedef long long LL;\n\n#ifdef int\nconst long long INF = 1ll << 62ll;\n#else\nconst singed INF = 1 << 29;\n#endif\n\nstruct edge{ int from, to, cost; };\n\nint dr[] = { -1, 0, 1, 0 };\nint dc[] = { 0, 1, 0, -1 };\n\ntemplate<typename T = int>\nvector<vector<T>> vvector(int h, int w, T def = T()){ return move(vector<vector<T>>(h, vector<T>(w, def))); }\nclass range {\nprivate: struct I{ int x; int operator*(){ return x; }bool operator!=(I& lhs){ return x < lhs.x; }void operator++(){ ++x; } }; I i, n;\npublic:range(int n) :i({ 0 }), n({ n }){}range(int i, int n) :i({ i }), n({ n }){}I& begin(){ return i; }I& end(){ return n; }\n};\n\nsigned main()\n{\n\tint h, w;\n\twhile (cin >> h >> w && h)\n\t{\n\t\tauto dp = vvector(h, w + 1);\n\t\tint ans = 0;\n\t\trep(i, h)\n\t\t{\n\t\t\tstack<P> st;\n\t\t\tst.push(P(0, 0));\n\t\t\trep(j, w + 1)\n\t\t\t{\n\t\t\t\tint x = 0;\n\t\t\t\tif (j < w) cin >> x;\n\n\t\t\t\tif (!x) dp[i][j] = 1;\n\t\t\t\tif (i >= 1 && dp[i - 1][j] && !x)\n\t\t\t\t\tdp[i][j] = dp[i - 1][j] + 1;\n\n\t\t\t\tint size = dp[i][j];\n\t\t\t\tif (size == st.top().first) continue;\n\t\t\t\telse if (size > st.top().first) st.push(P(size, j));\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tint beg = j;\n\t\t\t\t\twhile (!st.empty() && st.top().first > size)\n\t\t\t\t\t{\n\t\t\t\t\t\tP p = st.top(); st.pop();\n\t\t\t\t\t\tans = max(ans, (j - p.second) * p.first);\n\t\t\t\t\t\tbeg = p.second;\n\t\t\t\t\t}\n\t\t\t\t\tif (st.top().first == size) \n\t\t\t\t\t\tans = max(ans, (j - st.top().second + 1) * st.top().first);\n\t\t\t\t\telse st.push(P(size, beg));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nstruct rect {\n    int pos, height;\n};\n\nint main() {\n\n    int H, W;\n    cin >> H >> W;\n\n    int T[H][W];\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int c;\n            cin >> c;\n            if (i == 0) {\n                T[i][j] = (c ? 0 : 1);\n            } else {\n                T[i][j] = (c ? 0 : T[i - 1][j] + 1);\n            }\n        }\n    }\n\n    //solve\n    int ans = 0;\n\n    for (int i = 0; i < W; i++) {\n        stack<rect> stk;\n        for (int j = 0; j < H; j++) {\n            int pos, height;\n            pos = j, height = T[i][j];\n            if (stk.empty() || stk.top().height < height) {\n                stk.push((rect) {pos, height});\n            } else if (stk.top().height > height) {\n                while (!stk.empty() && stk.top().height >= height) {\n                    rect pre = stk.top();\n                    stk.pop();\n                    ans = max(ans, pre.height * (j - pre.pos));\n                    pos = pre.pos;\n                }\n                stk.push((rect) {pos, height});\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\nconst int INF = 1<<28;\n#define MAX 1401\n\nint dp[MAX][MAX];\n\nint solve(int H, int W) {\n\tREP(j,W) {\n\t\tint v = 1;\n\t\tREP(i, H) {\n\t\t\tif(!dp[i][j])\n\t\t\t\tv = 0;\n\t\t\tdp[i][j] = v++;\n\t\t}\n\t}\n/*\n\tREP(i, H) {\n\t\tREP(j,W)\n\t\t\tcout << dp[i][j] << ' ';\n\t\tcout << endl;\n\t}\n*/\n\tint ans = 0;\n\tREP(i, H) {\n\t\tpair<int, int> p, p2;\n\t\tstack< pair<int, int> > s;\n\t\tREP(j, W) {\n\t\t\tp = make_pair(dp[i][j], j);\n\t\t\tif(s.empty())\n\t\t\t\ts.push(p);\n\t\t\telse {\n\t\t\t\tif(s.top().first < p.first)\n\t\t\t\t\ts.push(p);\n\t\t\t\telse if(s.top().first > p.first) {\n\t\t\t\t\twhile(!s.empty() && s.top().first >= p.first) {\n\t\t\t\t\t\tp2 = s.top(); s.pop();\n\t\t\t\t\t\tans = max(ans, p2.first * (j - p2.second));\n\t\t\t\t\t}\n\t\t\t\t\tp.second = p2.second;\n\t\t\t\t\ts.push(p);\n\t\t\t\t}\n\t\t\t}\n//\t\t\tcout << \"i \" << i << \" j \" << j << ' ' << ans << endl;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tREP(i, H) REP(j,W) {\n\t\tcin >> dp[i][j];\n\t\tdp[i][j] = !dp[i][j];\n\t}\n\tcout << solve(H, W) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nstruct rect {\n    int pos, height;\n};\n\nint main() {\n\n    int H, W;\n    cin >> H >> W;\n\n    int T[H][W];\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int c;\n            cin >> c;\n            if (i == 0) {\n                T[i][j] = (c ? 0 : 1);\n            } else {\n                T[i][j] = (c ? 0 : T[i - 1][j] + 1);\n            }\n        }\n    }\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            cout << T[i][j];\n        }\n        cout << endl;\n    }\n\n    //solve\n    int ans = 0;\n\n    for (int i = 0; i < W; i++) {\n        stack<rect> stk;\n        for (int j = 0; j < H; j++) {\n            int pos, height;\n            pos = j, height = T[i][j];\n            if (stk.empty() || stk.top().height < height) {\n                stk.push((rect) {pos, height});\n            } else if (stk.top().height > height) {\n                while (!stk.empty() && stk.top().height >= height) {\n                    rect pre = stk.top();\n                    stk.pop();\n                    ans = max(ans, pre.height * (j - pre.pos));\n                    pos = pre.pos;\n                }\n                stk.push((rect) {pos, height});\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ];\nlong long st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr,h;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tfor(r=i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\tint left=j;\n\t\tfor(;ptr && (h=st[ptr-1]>>32)>m[j][i];){\n\t\t\tint l=st[--ptr]&0xffffffff;\n\t\t\tif(r<(j-l)*h)r=(j-l)*h;\n\t\t\tleft=l;\n\t\t}\n\t\tst[ptr++]=((long long)m[j][i]<<32)|left;\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<stack>\nusing namespace std;\n\n\nstatic const int MAX = 1405;\nint G[MAX][MAX], T[MAX][MAX];\n\nstruct Rectangle\n{\n\tint height, pos;\n};\n\nint getLargestRectangle(int W, int buffer[]) {\n \tstack<Rectangle> s;\n \tint maxRect = 0;\n \tbuffer[W] = 0;\n\n \tfor( int i = 0; i <= W; i++) {\n        Rectangle rect;\n        rect.height = buffer[i];\n        rect.pos = i;\n\n        if( s.empty() || s.top().height < rect.height ) {\n        \ts.push( rect );\n        } else  if ( s.top().height > rect.height) {\n        \t\tint target = i;\n        \t\twhile( !s.empty() && s.top().height > rect.height ) {\n        \t\tRectangle pre = s.top(); s.pop();\n        \t\tint area = pre.height * ( i - pre.pos );\n        \t\tmaxRect = max(maxRect, area);\n        \t\ttarget = pre.pos;\n        \t   }\n        \t   rect.pos = target;\n        \t   s.push(rect);\n        \t}\n \n \t}\n\n \treturn maxRect;\n}\nint getLargestRectangle( int H, int W ) {\n\tfor( int i = 0; i < H; i++) {\n\t\tfor( int j = 0; j < W; j++ ) {\n\t\t\tif ( G[i][j] ) T[i][j] = 0;\n\t\t\telse {\n\t\t\t\tT[i][j] = ( i > 0 ) ? T[i - 1][j] + 1 : 1;\n\t\t\t}\n\t\t}\n\t}\n\n    int maxRect = 0;\n    for ( int i = 0; i < H; i++) {\n    \tmaxRect = max( maxRect, getLargestRectangle(W, T[i]));\n    }\n\n    return maxRect;\n}\nint main() {\n\tint H, W;\n\n\tcin >> H >> W;\n\tfor( int i = 0; i < H; i++ )\n\t\tfor( int j =0; j < W; j++ ) cin >> G[i][j];\n\n\tcout << getLargestRectangle( H, W ) << endl;\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <string>\n#include <vector>\n#include <deque>\n#include <list>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cmath>\n#include <cstring>\n#include <cctype>\n#include <sstream>\n#include <set>\n#include <stack>\n#include <map>\n#include <queue>\n#include <complex>\nusing namespace std;\n#define REP(i,n) for(int i = 0; i < (int)n; i++)\n#define FOR(i,a,b) for(int i = a; i < (int)b; i++)\nconst int INF = 1<<28;\n#define MAX 1401\n\nint dp[MAX][MAX];\n\nint solve(int H, int W) {\n\tREP(j,W) {\n\t\tint v = 1;\n\t\tREP(i, H) {\n\t\t\tif(!dp[i][j])\n\t\t\t\tv = 0;\n\t\t\tdp[i][j] = v++;\n\t\t}\n\t}\n\n\tint ans = 0;\n\tREP(i, H) {\n\t\tpair<int, int> p, p2;\n\t\tstack< pair<int, int> > s;\n\t\tREP(j, W+1) {\n\t\t\tp = make_pair(dp[i][j], j);\n\t\t\tif(s.empty())\n\t\t\t\ts.push(p);\n\t\t\telse {\n\t\t\t\tif(s.top().first < p.first)\n\t\t\t\t\ts.push(p);\n\t\t\t\telse if(s.top().first > p.first) {\n\t\t\t\t\tint pnt = j;\n\t\t\t\t\twhile(!s.empty() && s.top().first >= p.first) {\n\t\t\t\t\t\tp2 = s.top(); s.pop();\n\t\t\t\t\t\tans = max(ans, p2.first * (j - p2.second));\n\t\t\t\t\t\tpnt = p2.second;\n\t\t\t\t\t}\n\t\t\t\t\tp.second = pnt;\n\t\t\t\t\ts.push(p);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tint H, W; cin >> H >> W;\n\tREP(i, H) REP(j, W) {\n\t\tcin >> dp[i][j];\n\t\tdp[i][j] = !dp[i][j];\n\t}\n\tcout << solve(H, W) << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Largest Rectangle\n#include <iostream>\n#include <algorithm>\n#include <stack>\n#include <vector>\n\nusing namespace std;\n\nclass Rectangle {\npublic:\n    int pos, height;\n    Rectangle(int pos, int height): pos(pos), height(height) {}\n};\n\nint largestRectangle(int h, int w, vector<vector<int>> &G) {\n    vector<vector<int>> dp(h+1, vector<int>(w+1, 0));\n\n    for(int i=1; i<h+1; i++) {\n        for(int j=1; j<w+1; j++) {\n            if(G[i][j] == 1) continue;\n            dp[i][j] = dp[i-1][j]+1;\n        }\n    }\n\n    int s = 0;\n    stack<Rectangle> st;\n    for(int i=1; i<h+1; i++) {\n        for(int j=1; j<w+1; j++) {\n            Rectangle rect = Rectangle(j, dp[i][j]);\n            if(st.empty()) st.push(rect);\n            else if(dp[i][j] > st.top().height) st.push(rect);\n            else if(dp[i][j] < st.top().height) {\n                int pos = j;\n                while(!st.empty() && st.top().height > dp[i][j]) {\n                    s = max(s, st.top().height * (j - st.top().pos));\n                    pos = st.top().pos;\n                    st.pop();\n                }\n                rect.pos = pos;\n                st.push(rect);\n            }\n        }\n\n        while(!st.empty()) {\n            s = max(s, st.top().height * (w + 1 - st.top().pos));\n            st.pop();\n        }\n    }\n\n    return s;\n}\n\nint main() {\n    int h, w;\n    cin >> h >> w;\n\n    vector<vector<int>> G(h+1, vector<int>(w+1, 1));\n    for(int i=1; i<h+1; i++)\n        for(int j=1; j<w+1; j++)\n            cin >> G[i][j];\n\n    cout << largestRectangle(h, w, G) << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#ifdef LOCAL_DEV\n\tvoid debug_impl() { std::cerr << std::endl; }\n\ttemplate<typename Head, typename... Tail> void debug_impl(Head head, Tail... tail) { std::cerr << \" \" << head << (sizeof...(tail) ? \",\" : \"\"); debug_impl(tail...); }\n\t#define debug(...) { std::cerr << std::boolalpha << \"(\" << #__VA_ARGS__ << \") =\"; debug_impl(__VA_ARGS__); std::cerr << std::noboolalpha; }\n#else\n\t#define debug(...) {}\n#endif\n#ifdef LOCAL_TEST\n\t#define BOOST_STACKTRACE_USE_ADDR2LINE\n\t#define BOOST_STACKTRACE_ADDR2LINE_LOCATION /usr/local/opt/binutils/bin/addr2line\n\t#define _GNU_SOURCE\n\t#include <boost/stacktrace.hpp>\n\ttemplate<typename T> class dvector : public std::vector<T> {\n\tpublic:\n\t\tdvector() : std::vector<T>() {}\n\t\texplicit dvector(size_t n, const T& value = T()) : std::vector<T>(n, value) {}\n\t\tdvector(const std::vector<T>& v) : std::vector<T>(v) {}\n\t\tdvector(const std::initializer_list<T> il) : std::vector<T>(il) {}\n\t\tdvector(const typename std::vector<T>::iterator first, const typename std::vector<T>::iterator last) : std::vector<T>(first, last) {}\n\t\tdvector(const std::string::iterator first, const std::string::iterator last) : std::vector<T>(first, last) {}\n\t\tT& operator[](size_t n) {\n\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << std::endl; return this->at(n);\n\t\t\t}\n\t\t}\n\t\tconst T& operator[](size_t n) const {\n\t\t\ttry { return this->at(n); } catch (const std::exception& e) {\n\t\t\t\tstd::cerr << boost::stacktrace::stacktrace() << std::endl; return this->at(n);\n\t\t\t}\n\t\t}\n\t};\n\tclass dbool {\n\tprivate:\n\t\tbool boolvalue;\n\tpublic:\n\t\tdbool() : boolvalue(false) {}\n\t\tdbool(bool b) : boolvalue(b) {}\n\t\tdbool(const dbool &b) : boolvalue(b.boolvalue) {}\n\t\toperator bool&() { return boolvalue; }\n\t\toperator const bool&() const { return boolvalue; }\n\t};\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const dvector<T>& v) {\n\t\tfor (int i = 0, len = v.size(); i < len; ++i){ s << v[i]; if (i < len - 1) s << \"\\t\"; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const dvector< dvector<T> >& vv) {\n\t\tfor (int i = 0, len = vv.size(); i < len; ++i){ s << vv[i] << std::endl; } return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::set<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T> std::ostream& operator<<(std::ostream& s, const std::multiset<T>& se) {\n\t\ts << \"{ \"; for (auto itr = se.begin(); itr != se.end(); ++itr){ s << (*itr) << \"\\t\"; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::map<T1, T2>& m) {\n\t\ts << \"{\" << std::endl; for (auto itr = m.begin(); itr != m.end(); ++itr){ s << \"\\t\" << (*itr).first << \" : \" << (*itr).second << std::endl; } s << \"}\"; return s; }\n\ttemplate<typename T1, typename T2> std::ostream& operator<<(std::ostream& s, const std::pair<T1, T2>& p) { \n\t\treturn s << \"(\" << p.first << \", \" << p.second << \")\"; }\n\t#define vector dvector\n\t#define bool dbool\n\tclass SIGFPE_exception : std::exception {};\n\tclass SIGSEGV_exception : std::exception {};\n\tvoid catch_SIGFPE(int e) { std::cerr << boost::stacktrace::stacktrace() << std::endl; throw SIGFPE_exception();\t}\n\tvoid catch_SIGSEGV(int e) { std::cerr << boost::stacktrace::stacktrace() << std::endl; throw SIGSEGV_exception(); }\n\tsigned convertedmain();\n\tsigned main() { signal(SIGFPE, catch_SIGFPE); signal(SIGSEGV, catch_SIGSEGV); return convertedmain(); }\n\t#define main() convertedmain()\n#endif\n//#define int long long\nusing ll = long long;\n//constexpr int INF = 1e9;//INT_MAX=(1<<31)-1=2147483647\nconstexpr ll INF = (ll)1e18;//(1LL<<63)-1=9223372036854775807\nconstexpr ll MOD = (ll)1e9 + 7;\nconstexpr double EPS = 1e-9;\nconstexpr int dx[4] = {1, 0, -1, 0};\nconstexpr int dy[4] = {0, 1, 0, -1};\n#define p(var) std::cout<<var<<std::endl\n#define rep(i, n)   for(ll i=0, i##_length=(n); i< i##_length; ++i)\n#define repeq(i, n) for(ll i=1, i##_length=(n); i<=i##_length; ++i)\n#define rrep(i, n)   for(ll i=(n)-1; i>=0; --i)\n#define rrepeq(i, n) for(ll i=(n)  ; i>=1; --i)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define uniq(v) (v).erase(unique((v).begin(), (v).end()), (v).end());\ntemplate<typename T> inline void pv(vector<T> &v) { for(ll i=0, N=v.size(); i<N; i++) std::cout << v[i] << \" \\n\"[i==N-1]; }\ntemplate<typename T> inline T gcd(T a, T b) { return b ? gcd(b,a%b) : a; }\ntemplate<typename T> inline T lcm(T a, T b) { return a / gcd(a,  b) * b; }\ntemplate<typename T> inline bool chmax(T &a, T b) { return a < b && (a = b, true); }\ntemplate<typename T> inline bool chmin(T &a, T b) { return a > b && (a = b, true); }\n\n/*-----8<-----template-----8<-----*/\n\n//ヒストグラム中の最大長方形の面積を返す\n//buffer = ヒストグラムの値\nll getLargestRectangleHistogram(vector<ll> buffer){\n\tll size = buffer.size();\n\t//{height, position}\n\tstack<pair<ll,ll>> S;\n\tll maxval = 0;\n\tbuffer.push_back(0);\n\tfor(ll i=0; i<=size; i++){\n\t\tpair<ll,ll> rect = {buffer[i], i};\n\t\tif(S.empty()){\n\t\t\tS.push(rect);\n\t\t}else{\n\t\t\tif(S.top().first < rect.first){\n\t\t\t\tS.push(rect);\n\t\t\t}else if(S.top().first > rect.first){\n\t\t\t\tll target = i;\n\t\t\t\twhile(!S.empty() && S.top().first >= rect.first){\n\t\t\t\t\tpair<ll,ll> pre = S.top();\n\t\t\t\t\tS.pop();\n\t\t\t\t\tll area = pre.first * (i-pre.second);\n\t\t\t\t\tmaxval = max(maxval, area);\n\t\t\t\t\ttarget = pre.second;\n\t\t\t\t}\n\t\t\t\trect.second = target;\n\t\t\t\tS.push(rect);\n\t\t\t}\n\t\t}\n\t}\n\treturn maxval;\n}\n\n//boardの最大正方形の面積を返す\n//board[i][j] = true->使用可能マス、false->使用不可マス\nll getLargestRectangle(vector<vector<bool>> &board){\n\tll H=board.size();\n\tll W=board[0].size();\n\tvector<vector<ll>> dp(H,vector<ll>(W,0));\n\tfor(ll j=0; j<W; j++){\n\t\tfor(ll i=0; i<H; i++){\n\t\t\tif(board[i][j]){\n\t\t\t\tdp[i][j] = (i>0) ? dp[i-1][j]+1 : 1;\n\t\t\t}else{\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tll maxval=0;\n\tfor(ll i=0; i<H; i++){\n\t\tmaxval = max(maxval, getLargestRectangleHistogram(dp[i]));\n\t}\n\n\treturn maxval;\n}\n\n/*-----8<-----library-----8<-----*/\n\n//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_3_A&lang=jp\nsigned main() {\n\tll H,W;\n\tcin>>H>>W;\n\n\tvector<vector<bool>> board(H,vector<bool>(W,false));\n\trep(i,H) rep(j,W){\n\t\tll t;\n\t\tcin>>t;\n\t\tif(t)board[i][j]=false;\n\t\telse board[i][j]=true;\n\t}\n\n\tll ans=getLargestRectangle(board);\n\tp(ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <stack>\n#include <vector>\nusing namespace std;\nstatic const int HMAX = 1401;\nstatic const int WMAX = 1401;\n\nint tiles[HMAX][WMAX] = {0};\n\nvoid print_tiles(int h, int w) {\n  for (int i = 0; i < h; i++) {\n    for (int j = 0; j < w; j++) {\n      cout << tiles[i][j] << \" \";\n    }\n    cout << endl;\n  }\n}\n\n// side-effects (to tiles)\nint leargest_square(int height, int width, int ans_init) {\n  int ans = ans_init;\n  for (int i = 1; i < height; i++) {\n    for (int j = 1; j < width; j++) {\n      if (tiles[i][j] != 0) {\n        tiles[i][j] =\n            min({tiles[i - 1][j], tiles[i][j - 1], tiles[i - 1][j - 1]}) + 1;\n        ans = max(ans, tiles[i][j]);\n      }\n    }\n  }\n  return ans * ans;\n}\n\nstruct Rect {\n  int height;\n  int left;\n};\n\n// side-effects (to tiles)\nint leargest_rectanble(int height, int width) {\n  // mkae histgrams\n  for (int i = 1; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      if (tiles[i][j] != 0) {\n        tiles[i][j] = tiles[i - 1][j] + 1;\n      }\n    }\n  }\n\n  int maxsize = 0;\n  stack<Rect> st;\n  for (int i = 0; i < height; i++) {\n    // calc the rectangle size of the i-th histgram\n    tiles[i][width] = 0; // sentinel\n    for (int j = 0; j < width + 1; j++) {\n      auto rect = Rect{tiles[i][j], j};\n      if (st.empty() || st.top().height < rect.height) {\n        st.push(rect);\n      } else if (st.top().height > rect.height) {\n        Rect r;\n        int left_store;\n        while (!st.empty()) {\n          r = st.top();\n          if (r.height <= rect.height)\n            break;\n          int size = r.height * (rect.left - r.left);\n          maxsize = max(size, maxsize);\n          left_store = r.left;\n          st.pop();\n        }\n        if (r.height < rect.height) {\n          rect.left = left_store;\n          st.push(rect);\n        }\n      }\n    }\n  }\n\n  return maxsize;\n}\n\n#define BLOCK 1\nint main() {\n  int height, width;\n  int ans_init = 0;\n  cin >> height >> width;\n  for (int i = 0; i < height; i++) {\n    for (int j = 0; j < width; j++) {\n      int tmp;\n      cin >> tmp;\n      tiles[i][j] = tmp == BLOCK ? 0 : 1;\n      ans_init = max(ans_init, tiles[i][j]);\n    }\n  }\n  cout << leargest_rectanble(height, width) << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 2000\nint x[MAX_N][MAX_N];\nint H, W;\nint main() {\n\tcin >> H >> W;\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tcin >> x[i][j];\n\t\t}\n\t\tfor (int j = 1; j < W; j++) {\n\t\t\tif (x[i][j] == 1) {\n\t\t\t\tx[i][j] = 0;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tx[i][j] = x[i][j - 1] + 1;\n\t\t\t}\n\t\t}\n\t}\n\tint maxn = 0;\n\tfor (int i = 0; i < W; i++) {\n\t\tfor (int j = 0; j < H; j++) {\n\t\t\tint X = x[j][i], cnt = 0;\n\t\t\tfor (int k = j; k >= 0; k--) {\n\t\t\t\tcnt++; X = min(X, x[k][i]);\n\t\t\t\tif (X == 0) { break; }\n\t\t\t\tmaxn = max(maxn, X*cnt);\n\t\t\t}\n\t\t}\n\t}\n\tcout << maxn << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<fstream>\n#include<list>\n#include<functional>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\n\n\nll Largest_Rectangle(const vector<vector<bool>> &A){\n    vector<vector<ll>> a(A.size(),vector<ll>(A[0].size(),0));\n    ll count;\n    for(int i=0;i<A[0].size();i++){\n        count=0;\n        for(ll h=0;h<A.size();h++){\n            if(A[h][i]){count++;}\n            else{count=0;}\n            a[h][i]=count;\n        }\n    }\n    ll mx=0;\n    stack<pll> s;\n    for(int i=0;i<A.size();i++){\n        for(int t=0;t<A[0].size();t++){\n            ll mi=t;\n            while(!s.empty() && s.top().F>a[i][t]){\n                pll w=s.top(); s.pop();\n                mx=max(mx,w.F*(t-w.S));\n                mi=w.S;\n            }\n            s.push({a[i][t],mi});\n        }\n        while(!s.empty()){\n            pll w=s.top(); s.pop();\n            mx=max(mx,w.F*((ll)A[0].size()-w.S));\n        }\n    }\n    return mx;\n}\n\n\nint main(){\n    ll h,w;\n    cin>>h>>w;\n    vector<vector<bool>> a(h,vector<bool>(w));\n    for(int i=0;i<h;i++){\n        for(int t=0;t<w;t++){\n            ll b;\n            cin>>b; a[i][t]=b==0;\n        }\n    }\n    cout<<Largest_Rectangle(a)<<endl;\n    \n    \n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n\tRectangle rect;\n\tfor(int i=0;i<x;i++){\n\t\tstack<Rectangle> stk;\n\t\t//rect.height = 0;\n\t\t//rect.pos = 0;\n\t\t//stk.push(rect);\n\t\tint pop=0;\n\t\tfor(int j=0;j<=y;j++){\n\t\t\trect.height = m[j][i];\n\t\t\trect.pos = j;\n\t\t\tif(stk.empty() || stk.top().height <= rect.height){\n\t\t\t\tstk.push(rect);\n\t\t\t}else{\n\t\t\t\t//printf(\"[-] %d %d\\n\",i,j);\n\t\t\t\tfor(;!stk.empty() && stk.top().height > rect.height;){\n\t\t\t\t\tpop++;\n\t\t\t\t\tRectangle pre = stk.top(); stk.pop();\n\t\t\t\t\t//pre.pos=stk\n\t\t\t\t\tint area = pre.height * (j - pre.pos);\n\t\t\t\t\tr = max(r, area);\n\t\t\t\t\t//printf(\"%d %d\\n\",target,pre.pos);\n\t\t\t\t\trect.pos--;// = pre.pos;\n\t\t\t\t}\n\t\t\t\tstk.push(rect);\n\t\t\t}\n\t\t\tif(rect.height==0)pop=0;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\nusing namespace std;\n\nint main(){\n\tint h, w;\n\tcin >> h >> w;\n\tint64_t ans = 0, dp[2][w + 1]{};\n\tfor(int i = 0; i < h; i++){\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tcin >> dp[i & 1][j];\n\t\t\tdp[i & 1][j] = !dp[i & 1][j];\n\t\t\tif(dp[i & 1][j] == 0) continue;\n\t\t\tdp[i & 1][j] += dp[!(i & 1)][j];\n\t\t}\n\t\tdp[i & 1][w] = 0;\n\t\tstack<int64_t> st;\n\t\tfor(int j = 0; j < w; j++){\n\t\t\tif(st.empty()){\n\t\t\t\tst.emplace(dp[i & 1][j]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(int64_t x = 1; !st.empty() && dp[i & 1][j] < st.top(); x++){\n\t\t\t\tst.pop();\n\t\t\t\tans = max(ans, x * dp[i & 1][j]);\n\t\t\t}\n\t\t}\n\t}\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int h,w;\n  char c;\n  int mp[1410][1410]={0};\n  int ans=0;\n\n  cin>>h>>w;\n  for(int i=1;i<=h;i++){\n    for(int j=1;j<=w;j++){\n      scanf(\" %c\",&c);\n      if(c=='1')mp[i][j]=0;\n      if(c=='0')mp[i][j]=mp[i-1][j]+1;\n    }\n  }\n\n  int mx;\n  int target;\n  stack<pair<int,int> >st;\n  for(int i=1;i<=h;i++){\n    mx=0;\n    \n    for(int j=1;j<=w;j++){\n\n      if(mx<mp[i][j]){\n\tst.push(make_pair(mp[i][j],j));\n\tmx=mp[i][j];\n      }\n\n      else if(mx>mp[i][j]){\n\ttarget = j;\n\twhile(!st.empty()){\n\t  pair<int,int>f=st.top();\n\t  if(f.first<mp[i][j])break; // ...?\n\t  st.pop();\n\t  // Debug\n\t  /*\n\t  cout<<i<<\" \"<<j<<\" \"<<f.first<<\" \"<<f.second<<endl;\n\t  cout<<f.first*(j-f.second)<<endl;\n\t  */\n\t  ans = max(ans,(f.first*(j-f.second)));\n\t  target = f.second;\n\t}\n\tif(mp[i][j]>0)st.push(make_pair(mp[i][j],target));\n\tmx=mp[i][j];\n      }\n\n    }\n    \n    while(!st.empty()){\n      pair<int,int>f=st.top();st.pop();\n      // Debug\n      //cout<<i<<\"  \"<<f.second<<endl;\n      ans = max(ans,(f.first*(w+1-f.second)));\n      //  cout<<ans<<endl;\n    }\n  }\n\n  cout<<ans<<endl;\n  return(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\nstruct rect {\n    int pos, height;\n};\n\nint main() {\n\n    int H, W;\n    cin >> H >> W;\n\n    int T[H][W];\n\n    for (int i = 0; i < H; i++) {\n        for (int j = 0; j < W; j++) {\n            int c;\n            cin >> c;\n            if (i == 0) {\n                T[i][j] = (c ? 0 : 1);\n            } else {\n                T[i][j] = (c ? 0 : T[i - 1][j] + 1);\n            }\n        }\n    }\n\n    //solve\n    int ans = 0;\n\n    for (int i = 0; i < W; i++) {\n        stack<rect> stk;\n        for (int j = 0; j < H; j++) {\n            int pos, height;\n            pos = j, height = T[i][j];\n            if (stk.empty() || stk.top().height < height) {\n                stk.push((rect) {pos, height});\n            } else if (stk.top().height > height) {\n                while (!stk.empty() && stk.top().height >= height) {\n                    rect pre = stk.top();\n                    stk.pop();\n                    ans = max(ans, pre.height * (j - pre.pos));\n                    pos = pre.pos;\n                }\n                stk.push((rect) {pos, height});\n            }\n        }\n    }\n\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int N(1400+10);\n\nint g[N][N];\nint t[N][N];\n\n#define f(i,n) for(i=0;i<n;i++)\n\nstruct AA{\n    int h,pos;\n};\n\nint gget(int w,int b[]){\n    stack<AA> s;\n    int mm=0;\n    b[w]=0;\n    for(int i=0;i<=w;i++){\n        AA r;\n        r.h=b[i];\n        r.pos=i;\n        if(s.empty()){\n            s.push(r);\n        }else{\n            if(s.top().h<r.h)\n                s.push(r);\n            else if(s.top().h>r.h){\n                int tt=i;\n                while(!s.empty()&&s.top().h>=r.h){\n                    AA pre=s.top();s.pop();\n                    int area=pre.h*(i-pre.pos);\n                    mm=max(mm,area);\n                    tt=pre.pos;\n                }\n                r.pos=tt;\n                s.push(r);\n            }\n        }\n    }\n    return mm;\n}\n\n\nint main(){\n    int h,w;\n    cin>>h>>w;\n\n    int i,j;\n    f(i,h)f(j,w)\n    cin>>g[i][j];\n\n    f(i,h)f(j,w)\n    if(g[i][j]==0)\n    t[i][j]=(i>0)?t[i-1][j]+1:1;\n\n    int mm=0;\n    for(int i=0;i<h;i++)\n    mm=max(mm,gget(w,t[i]));\n    cout<<mm<<endl;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define INF 99999999\n#define FER 0.0000000001\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\ntypedef pair<ll, int> pli;\ntypedef pair<double, double> pdd;\n\nstruct Edge\n{\n\tint s, t, w;\n\tEdge(int s,int t,int w):s(s),t(t),w(w){}\n\tEdge() :Edge(-1, -1, -1) {}\n\tbool operator<(const Edge& e)const\n\t{\n\t\treturn w != e.w ? w < e.w : (s != e.s ? s < e.s : t < e.t);\n\t}\n};\n\n\nstruct P\n{\n\tdouble x, y;\n\tP(double x, double y) :x(x), y(y) {}\n\tP() :P(0, 0) {}\n\tP operator+(const P& v)const\n\t{\n\t\treturn P(x + v.x, y + v.y);\n\t}\n\tP operator-(const P& v)const\n\t{\n\t\treturn P(x - v.x, y - v.y);\n\t}\n\tP operator*(const double v)const\n\t{\n\t\treturn P(x*v, y*v);\n\t}\n\tbool operator==(const P& v)const\n\t{\n\t\treturn abs(x - v.x) <= 0.0000000000001&&abs(y - v.y) <= 0.00000000000001;\n\t}\n\tbool operator!=(const P& v)const\n\t{\n\t\treturn abs(x - v.x) > 0.0000000000001 || abs(y - v.y) > 0.00000000000001;\n\t}\n\n\tdouble dot(const P& v)const\n\t{\n\t\treturn x*v.x + y*v.y;\n\t}\n\tdouble cross(const P& v)const\n\t{\n\t\treturn x*v.y - y*v.x;\n\t}\n\tdouble length()const\n\t{\n\t\treturn sqrt(x*x + y*y);\n\t}\n\tdouble length2()const\n\t{\n\t\treturn (x*x + y*y);\n\t}\n\n\tbool operator<(const P& v)const\n\t{\n\t\treturn x<v.x || (x == v.x) && y < v.y;\n\t}\n\tbool operator>(const P& v)const\n\t{\n\t\treturn x>v.x || (x == v.x) && y > v.y;\n\t}\n};\n\nstruct Rectangle\n{\n\tint h;\n\tint p;\n\tRectangle(int h,int p):h(h),p(p){}\n};\n\nint matrix[1400][1400];\nint L[1400][1401];\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint H, W;\n\tcin >> H >> W;\n\n\tfor (int i = 0; i < H; i++)\n\t{\n\t\tfor (int j = 0; j < W; j++)\n\t\t{\n\t\t\tcin >> matrix[i][j];\n\t\t}\n\t\tL[i][W] = 0;\n\t}\n\n\tfor (int j = 0; j < W; j++)\n\t{\n\t\tint length = 0;\n\t\tfor (int i = 0; i < H; i++)\n\t\t{\n\t\t\tif (matrix[i][j] == 1)\n\t\t\t{\n\t\t\t\tlength = 0;\n\t\t\t\tL[i][j] = 0;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tL[i][j] = ++length;\n\t\t\t}\n\t\t}\n\t}\n\n\tint ans = 0;\n\tW++;\n\n\tfor (int k = 0; k < H; k++)\n\t{\n\t\tstack<Rectangle> rs;\n\n\t\tint tans = 0;\n\t\tfor (int i = 0; i < W; i++)\n\t\t{\n\t\t\tif (rs.empty())\n\t\t\t{\n\t\t\t\trs.push(Rectangle(L[k][i], i));\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (rs.top().h < L[k][i])\n\t\t\t\t{\n\t\t\t\t\trs.push(Rectangle(L[k][i], i));\n\t\t\t\t}\n\t\t\t\telse if (rs.top().h>L[k][i])\n\t\t\t\t{\n\t\t\t\t\tint tp = i;\n\t\t\t\t\twhile (!rs.empty() && rs.top().h>L[k][i])\n\t\t\t\t\t{\n\t\t\t\t\t\tRectangle tr = rs.top();\n\t\t\t\t\t\trs.pop();\n\t\t\t\t\t\ttans = max(tans, tr.h*(i - tr.p));\n\t\t\t\t\t\ttp = tr.p;\n\t\t\t\t\t}\n\t\t\t\t\trs.push(Rectangle(L[k][i], tp));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans = max(ans, tans);\n\t}\n\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <stack>\n\nusing namespace std;\n\nstruct rectagle {\n\tint pos, height;\n};\n//13233\nint getMax(int T[], int W) {\n\n\tstack<rectagle> S;\n\tint maxv = 0;\n\tfor (int i = 0; i <= W; ++i) {\n\t\trectagle r;\n\t\tr.pos = i;\n\t\tif (i != W) {\n\t\t\tr.height = T[i];\n\t\t} else {\n\t\t\tr.height = 0;\n\t\t}\n\t\tif (S.empty() || r.height > S.top().height) {\n\t\t\tS.push(r);\n\t\t} else {\n\t\t\tint prepos = i;\n\t\t\twhile (!S.empty() && S.top().height > r.height) {\n\t\t\t\trectagle pop = S.top();\n\t\t\t\tS.pop();\n\t\t\t\tint area = (i - pop.pos) * pop.height;\n\t\t\t\tprepos = pop.pos;\n\t\t\t\tmaxv = max(maxv, area);\n\t\t\t}\n\t\t\tr.pos = prepos;\n\t\t\tS.push(r);\n\t\t}\n\t}\n\n\treturn maxv;\n}\n\nint main() {\n\n\tint H, W;\n\tscanf(\"%d %d\", &H, &W);\n\n\tint A[H][W];\n\tfor (int i = 0; i < H; ++i) {\n\t\tfor (int j = 0; j < W; ++j) {\n\t\t\tscanf(\"%d\", &A[i][j]);\n\t\t}\n\t}\n\tint T[H][W];\n\tfor (int j = 0; j < W; ++j) {\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tif (A[i][j] == 0) {\n\t\t\t\tif (i == 0) {\n\t\t\t\t\tT[i][j] = 1;\n\t\t\t\t} else {\n\t\t\t\t\tT[i][j] = T[i - 1][j] + 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tT[i][j] = 0;\n\t\t\t}\n\t\t}\n\t}\n\n\tint maxv = 0;\n\tfor (int i = 0; i < H; ++i) {\n\t\tmaxv = max(maxv, getMax(T[i], W));\n\t}\n\tcout << maxv << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stack>\nusing namespace std;\n\nstruct Rectangle {\n  int height;\n  int pos;\n};\n \n\n#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n/*\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n*/\n  Rectangle rect;\n  for (int i = 0; i < x; i++) {\n    stack<Rectangle> stk;\n    for (int j = 0; j <= y; j++) {\n      rect.height = m[i][j];\n      rect.pos = j;\n      if (stk.empty()) {\n        stk.push(rect);\n      } else {\n        if (stk.top().height < rect.height) {\n          stk.push(rect);\n        } else if (stk.top().height > rect.height) {\n          int target = j;\n          while (!stk.empty() && stk.top().height >= rect.height) {\n            Rectangle pre = stk.top(); stk.pop();\n            int area = pre.height * (j - pre.pos);\n            r = max(r, area);\n            target = pre.pos;\n          }\n          rect.pos = target;\n          stk.push(rect);\n        }\n      }\n    }\n  }\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define MAX 1400\n\nstruct Rectangle{\n    int height;\n    int pos;\n};\n\nint getLargestRectangle(int size,int buf[]){\n    stack<Rectangle> s;\n    int maxV = 0;\n    buf[size] = 0;\n    \n    for(int i = 0;i <= size;++i){\n        Rectangle rect;\n        rect.height = buf[i];\n        rect.pos = i;\n        if(s.empty()){\n            s.push(rect);\n        }\n        else{\n            if(s.top().height < rect.height){\n                s.push(rect);\n            }\n            else if(s.top().height > rect.height){\n                int target = i;\n                while(!s.empty() && s.top().height >= rect.height){\n                    Rectangle pre = s.top();\n                    s.pop();\n                    int area = pre.height * (i - pre.pos);\n                    maxV = max(maxV,area);\n                    target = pre.pos;\n                }\n                rect.pos = target;\n                s.push(rect);\n            }\n        }\n    }\n    return maxV;\n}\n\nint H,W;\nint buf[MAX][MAX];\nint T[MAX][MAX];\n\nint getLargestRectangle(){\n    for(int j = 0;j < W;++j){\n        for(int i = 0;i < H;++i){\n            if(buf[i][j]){\n                T[i][j] = 0;\n            }\n            else{\n                T[i][j] = (i > 0) ? T[i - 1][j] + 1 : 1;    \n            }\n        }\n    }\n    int maxV = 0;\n    for(int i = 0;i < H;++i){\n        maxV = max(maxV,getLargestRectangle(W,T[i]));\n    }\n    return maxV;\n}\n\nint main(){\n    scanf(\"%d %d\",&H,&W);\n    for(int i = 0;i < H;++i){\n        for(int j = 0;j < W;++j){\n            scanf(\"%d\",&buf[i][j]);\n        }\n    }\n    printf(\"%d\\n\",getLargestRectangle());\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <stack>\nusing namespace std;\nconst int num = 140;\nstruct Rectangle {\n\tint he, p;\n};\ninline int lr(int w, int bf[]) {\n\tbf[w] = 0;\n\tstack<Rectangle> s;\n\tint maxv = 0, area = 0;\n\tfor (int i = 0; i <= w; i++) {\n\t\tRectangle rect;\n\t\trect.he = bf[i];\n\t\trect.p = i;\n\t\tif (s.empty()) s.push(rect);\n\t\telse if (s.top().he < rect.he) s.push(rect);\n\t\telse if (s.top().he > rect.he) {\n\t\t\twhile (!s.empty() && s.top().he >= rect.he) {\n\t\t\t\tRectangle pr = s.top();\n\t\t\t\trect.p = pr.p;\n\t\t\t\ts.pop();\n\t\t\t\tarea = (i - pr.p)*pr.he;\n\t\t\t\tmaxv = max(area, maxv);\n\t\t\t}\n\t\t\ts.push(rect);\n\t\t}\n\t}\n\treturn maxv;\n}\nint main() {\n\tint h, w, x;\n\tcin >> h >> w;\n\tint H[num][num], dp[num][num];\n\tfor (int i = 0; i < h; i++) {\n\t\tfor (int j = 0; j < w; j++) {\n\t\t\tcin >> x;\n\t\t\tif (x) dp[i][j] = 0;\n\t\t}\n\t}\n\tfor (int i = 0; i < w; i++) {\n\t\tfor (int j = 0; j < h; j++) {\n\t\t\tif (!dp[j][i]) H[j][i] = 0;\n\t\t\telse H[j][i] = (j > 0) ? H[j - 1][i] + 1 : 1;\n\t\t}\n\t}\n\tint maxv = 0;\n\tfor (int i = 0; i < h; i++) {\n\t\tmaxv = max(maxv, lr(w, H[i]));\n\t}\n\tcout << maxv << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconstexpr int INF = 1e9;\n\nint main() {\n    int H, W;\n    cin >> H >> W;\n    vector<vector<int>> v(H, vector<int>(W));\n    for(int i=0; i<H; ++i) {\n        for(int j=0; j<W; ++j) {\n            cin >> v[i][j];\n        }\n    }\n    vector<vector<int>> sum(H, vector<int>(W+1));\n    for(int i=0; i<H; ++i) {\n        for(int j=W-1; j>=0; --j) {\n            if(v[i][j] == 0) {\n                sum[i][j] = sum[i][j+1] + 1;\n            }\n        }\n    }\n    int res = 0;\n    for(int i=0; i<W; ++i) {\n        stack<int> lst, rst;\n        vector<int> L(H), R(H);\n        for(int j=0; j<H; ++j) {\n            while(!lst.empty() && sum[lst.top()][i] >= sum[j][i]) {\n                lst.pop();\n            }\n            while(!rst.empty() && sum[rst.top()][i] >= sum[H-1-j][i]) {\n                rst.pop();\n            }\n            if(sum[j][i] == 0) {\n                L[j] = j;\n            } else {\n                L[j] = (lst.empty() ? 0 : lst.top() + 1);\n            }\n            if(sum[H-1-j][i] == 0) {\n                R[H-1-j] = H-1-j;\n            } else {\n                R[H-1-j] = (rst.empty() ? H : rst.top());\n            }\n            lst.push(j);\n            rst.push(H-1-j);\n        }\n        for(int j=0; j<H; ++j) {\n            res = max(res, sum[j][i] * (R[j] - L[j]));\n        }\n    }\n    cout << res << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < n; i++)\n\nstruct rectangle {int pos, height;};\n\nint main() {\n    int h, w;\n    cin >> h;\n    cin >> w;\n    int tile[h+1][w+1];\n    int dp[h+1][w+1];\n    int max_area = 0;\n    rep(i, h+1) {\n        stack<rectangle> s;\n        rep(j, w+1) {\n            if (i == 0 || j == w) {\n                dp[i][j] = 0;\n            } else {\n                cin >> tile[i][j];\n                if (tile[i][j] == 0) {\n                    dp[i][j] = dp[i-1][j] + 1;\n                } else {\n                    dp[i][j] = 0;\n                }\n            }\n            if (s.empty() && dp[i][j] != 0) {\n                s.push({j, dp[i][j]});\n            } else if (not s.empty() && s.top().height < dp[i][j]) {\n                s.push({j, dp[i][j]});\n            } else if (not s.empty() && s.top().height > dp[i][j]) {\n                int left;\n                while (not s.empty() && s.top().height >= dp[i][j]) {\n                    int area = (j - s.top().pos) * s.top().height;\n                    max_area = max(max_area, area);\n                    left = s.top().pos;\n                    s.pop();\n                }\n                if (dp[i][j] != 0) {\n                    s.push({left, dp[i][j]});\n                }\n            }\n        }\n    }\n    // rep(i, h+1) {\n    //     rep(j, w+1) {\n    //         printf(\"%d \", dp[i][j]);\n    //     }\n    //     printf(\"\\n\");\n    // }\n    cout << max_area << endl;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n\tfor(i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\t//printf(\"%d %d %d %d\\n\",i,j,ptr,m[j][i]);\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint _y=(j-(ptr-1)),_x=st[--ptr];\n\t\t\t\t//printf(\"%d %d\\n\",_x,_y);\n\t\t\t\tif(r<_x*_y)r=_x*_y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 1400\nstruct rect {\n  int height;\n  int pos;\n};\nint buffer[MAX][MAX], table[MAX][MAX];\nint large_rectangle(int w, int *t);\nint main(void)\n{\n  int i, j, h, w, max = 0;\n  scanf(\"%d%d\", &h, &w);\n  for (i = 0; i < h; i++) {\n    for (j = 0; j < w; j++) {\n      scanf(\"%d\", &buffer[i][j]);\n    }\n  }\n  for (i = 0; i < h; i++) {\n    for (j = 0; j < w; j++) {\n      if (buffer[i][j]) table[i][j] = 0;\n      else table[i][j] = (i > 0) ? table[i-1][j] + 1 : 1;\n    }\n  }\n  for (i = 0; i < h; i++) {\n    int temp = large_rectangle(w, table[i]);\n    if (max < temp) max = temp;\n  }\n  printf(\"%d\\n\", max);\n}\nint large_rectangle(int w, int *t)\n{\n  int i, sp = 0, max = 0;\n  struct rect stack[MAX];\n  t[w] = 0;\n  for (i = 0; i <= w; i++) {\n    struct rect r;\n    r.height = t[i];\n    r.pos = i;\n    if (!sp || stack[sp-1].height < r.height) stack[sp++] = r;\n    else if (stack[sp-1].height > r.height){\n      int target = i;\n        while (sp && stack[sp-1].height >= r.height) {\n        struct rect pre = stack[--sp];\n          int area = pre.height * (i - pre.pos);\n          if (max < area) max = area;\n          target = pre.pos;\n        }\n        r.pos = target;\n        stack[sp++] = r;\n    }\n  }\n  return max;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define CLEAN 0\n#define DIRTY 1\n#define SIZE  1401\n#define INITIAL_STACK_SIZE 10\n\nint table[SIZE][SIZE] = {};\nint board[SIZE][SIZE] = {};\n\ntypedef struct Rectangle {\n  int height;\n  int pos;\n} Rectangle;\n\ntypedef struct _stack {\n  int size;\n  int max;\n  Rectangle *stack;\n} *Stack;\n\nStack stack_init() {\n  Stack stack = (Stack)malloc(sizeof(struct _stack));\n  stack->size = 0;\n  stack->max = INITIAL_STACK_SIZE;\n  stack->stack = (Rectangle *)malloc(sizeof(Rectangle)*INITIAL_STACK_SIZE);\n  return stack;\n}\n\nRectangle empty_rectangle() {\n  return (Rectangle) {\n    .height = 0,\n    .pos = 0\n  };\n}\n\nRectangle top(Stack stack) {\n  if (stack->size <= 0) {\n    return empty_rectangle();\n  } else \n    return stack->stack[stack->size-1];\n}\n\nRectangle pop(Stack stack) {\n  if (stack->size <= 0) {\n    return empty_rectangle();\n  } else\n    return stack->stack[--(stack->size)];\n}\n\nRectangle push(Rectangle item, Stack stack) {\n  int i;\n  if (stack->size < stack->max) {\n    stack->stack[(stack->size)++] = item;\n  } else {\n    Rectangle *newStack = (Rectangle *)malloc(sizeof(int) * stack->max * 2);\n\n    if (newStack == NULL) {\n      perror(\"malloc failed.\\n\");\n      exit(-1);\n    }\n     \n    for (i=0; i<stack->size; i++)\n      newStack[i] = stack->stack[i];\n\n    newStack[stack->size++] = item;\n    stack->max *= 2;\n    free(stack->stack);\n    stack->stack = newStack;\n  }\n\n  return item;\n}\n\nint empty(Stack stack) {\n  return !stack->size;\n}\n\nvoid free_stack(Stack stack) {\n  free(stack);\n}\n\nvoid create_table(int h, int w) {\n  int i, j;\n\n  for (i=0; i<w; i++)\n    table[0][i] = (board[0][i] ? 0 : 1);\n  \n  for (i = 1; i < h; i++) {\n    for (j = 0; j < w; j++) {\n      if (board[i][j] == CLEAN)\n\ttable[i][j] = table[i-1][j] + 1;\n      else\n\ttable[i][j] = 0;\n    }\n  }\n}\n\nint rectangleAreaMaxRow(int row[],int w) {\n  Stack s = stack_init();\n  int i, max = 0;\n  row[w] = DIRTY;\n\n  for (i=0; i<=w; i++) {\n    Rectangle r;\n    r.height = row[i];\n    r.pos = i;\n    \n    if (empty(s) || top(s).height < r.height) {\n      push(r, s);\n    } else {\n      int target = i;\n      while (!empty(s) && top(s).height >= r.height) {\n\tRectangle pre = pop(s);\n\tint area = pre.height * (i-pre.pos);\n\tmax = (area > max ? area : max);\n\ttarget = pre.pos;\n      }\n      r.pos = target;\n      push(r, s);\n    }\n  }\n\n  free_stack(s);\n  return max;\n}\n  \nint rectangleAreaMax(int h, int w)\n{\n  int i, max = 0, temp;\n  for (i=0; i<h; i++) {\n    temp = rectangleAreaMaxRow(table[i], w);\n    max = (temp > max ? temp : max);\n  }\n\n  return max;\n}\n\nint main() {\n  int i, j, h, w;\n\n  scanf(\"%d %d\", &h, &w);\n  for (i=0; i<h; i++)\n    for (j=0; j<w; j++)\n      scanf(\"%d\", &board[i][j]);\n\n  create_table(h, w);\n  \n  printf(\"%d\\n\", rectangleAreaMax(h, w));\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define CLEAN 0\n#define DIRTY 1\n#define SIZE  1401\n#define INITIAL_STACK_SIZE 10\n \nint table[SIZE][SIZE] = {};\nint board[SIZE][SIZE] = {};\n \ntypedef struct Rectangle {\n  int height;\n  int pos;\n} Rectangle;\n \ntypedef struct _stack {\n  int size;\n  int max;\n  Rectangle *stack;\n} *Stack;\n \nStack stack_init() {\n  Stack stack = (Stack)malloc(sizeof(struct _stack));\n  stack->size = 0;\n  stack->max = INITIAL_STACK_SIZE;\n  stack->stack = (Rectangle *)malloc(sizeof(Rectangle)*INITIAL_STACK_SIZE);\n  return stack;\n}\n \nRectangle empty_rectangle() {\n  return (Rectangle) {\n    .height = 0,\n    .pos = 0\n  };\n}\n \nRectangle top(Stack stack) {\n  if (stack->size <= 0) {\n    return empty_rectangle();\n  } else\n    return stack->stack[stack->size-1];\n}\n \nRectangle pop(Stack stack) {\n  if (stack->size <= 0) {\n    return empty_rectangle();\n  } else\n    return stack->stack[--(stack->size)];\n}\n \nRectangle push(Rectangle item, Stack stack) {\n  int i;\n  if (stack->size < stack->max) {\n    stack->stack[(stack->size)++] = item;\n  } else {\n    Rectangle *newStack = (Rectangle *)malloc(sizeof(int) * stack->max * 2);\n \n    if (newStack == NULL) {\n      perror(\"malloc failed.\\n\");\n      exit(-1);\n    }\n      \n    for (i=0; i<stack->size; i++)\n      newStack[i] = stack->stack[i];\n \n    newStack[stack->size++] = item;\n    stack->max *= 2;\n    free(stack->stack);\n    stack->stack = newStack;\n  }\n \n  return item;\n}\n \nint empty(Stack stack) {\n  return !stack->size;\n}\n \nvoid free_stack(Stack stack) {\n  free(stack);\n}\n \nvoid create_table(int h, int w) {\n  int i, j;\n \n  for (i=0; i<w; i++)\n    table[0][i] = (board[0][i] ? 0 : 1);\n   \n  for (i = 1; i < h; i++) {\n    for (j = 0; j < w; j++) {\n      if (board[i][j] == CLEAN)\n    table[i][j] = table[i-1][j] + 1;\n      else\n    table[i][j] = 0;\n    }\n  }\n}\n \nint rectangleAreaMaxRow(int row[],int w) {\n  Stack s = stack_init();\n  int i, max = 0;\n  row[w] = DIRTY;\n \n  for (i=0; i<=w; i++) {\n    Rectangle r;\n    r.height = row[i];\n    r.pos = i;\n     \n    if (empty(s) || top(s).height < r.height) {\n      push(r, s);\n    } else {\n      int target = i;\n      while (!empty(s) && top(s).height >= r.height) {\n        Rectangle pre = pop(s);\n        int area = pre.height * (i-pre.pos);\n        max = (area > max ? area : max);\n        target = pre.pos;\n      }\n    r.pos = target;\n    push(r, s);\n    }\n  }\n \n  free_stack(s);\n  return max;\n}\n   \nint rectangleAreaMax(int h, int w)\n{\n  int i, max = 0, temp;\n  for (i=0; i<h; i++) {\n    temp = rectangleAreaMaxRow(table[i], w);\n    max = (temp > max ? temp : max);\n  }\n \n  return max;\n}\n \nint main() {\n  int i, j, h, w;\n \n  scanf(\"%d %d\", &h, &w);\n  for (i=0; i<h; i++)\n    for (j=0; j<w; j++)\n      scanf(\"%d\", &board[i][j]);\n \n  create_table(h, w);\n   \n  printf(\"%d\\n\", rectangleAreaMax(h, w));\n   \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint m[SIZ][SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,M=0;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tfor(r=i=0;i<x;i++)for(j=0;j<y;j++)for(M=x,k=j;k<y;k++){\n\t\tif(M>m[k][i])M=m[k][i];\n\t\tint z=k-j+1;\n\t\tif(M+150<z)break;\n\t\tif(r<M*z)r=M*z;\n\t}\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define DEFAULT_STACK_SIZE 16\n#define FREE_STACK(s) \\\n  do {\\\n    free(s->p);\\\n    free(s);\\\n  } while (0)\n#define SENTINEL -1\n#define IS_SENTINEL(e) (e.h == SENTINEL)\n\ntypedef struct { int h, w, **c; } rectangle_t;\ntypedef struct { int c, h; } element_t; // column and height\ntypedef struct { element_t *p; int i, size; } stack_t;\n\nstatic stack_t *new_stack(int size) {\n  stack_t *s = (stack_t *) malloc(sizeof(stack_t));\n\n  s->i = 0;\n  s->size = size;\n  s->p = (element_t *) malloc(sizeof(element_t) * s->size);\n  return s;\n}\n\nstatic void push_stack(stack_t *s, element_t e) {\n  if (s->i == s->size) {\n    s->size *= 2;\n    s->p = (element_t *) realloc(s->p, sizeof(element_t) * s->size);\n  }\n  s->p[s->i++] = e;\n}\n\nstatic element_t peek_stack(stack_t *s) {\n  element_t e = { SENTINEL, SENTINEL };\n  return s->i == 0 ? e : s->p[s->i - 1];\n}\n\nstatic element_t pop_stack(stack_t *s) {\n  element_t e = { SENTINEL, SENTINEL };\n  return s->i == 0 ? e : s->p[--s->i];\n}\n\nstatic void height_histgramify(rectangle_t r) {\n  int i, j;\n\n  for (i = 0; i < r.h; ++i) {\n    for (j = 0; j < r.w; ++j) {\n      if (i == 0 || r.c[i][j]) {\n        r.c[i][j] = !r.c[i][j];\n      } else {\n        r.c[i][j] = r.c[i-1][j] + !r.c[i][j];\n      }\n    }\n  }\n}\n\nstatic int max_area(int max, int pos, element_t e) {\n  int area = (pos - e.c) * e.h;\n  return area > max ? area : max;\n}\n\nstatic int largest_rectangle(rectangle_t r) {\n  int i, j, c, h, max;\n  stack_t *s;\n  element_t e;\n\n  for (i = max = 0; i < r.h; ++i) {\n    for (j = 0, s = new_stack(DEFAULT_STACK_SIZE); j <= r.w; ++j) {\n      c = j;\n      h = j == r.w ? SENTINEL : r.c[i][j];\n      for (e = peek_stack(s); e.h > h; e = peek_stack(s)) {\n        max = max_area(max, j, pop_stack(s));\n        c = e.c;\n      }\n      if (e.h == h && h > 0) continue;\n      e.c = c;\n      e.h = h;\n      push_stack(s, e);\n    }\n    FREE_STACK(s);\n  }\n  return max;\n}\n\nint main(int argc, char **argv) {\n  rectangle_t r;\n  int i, j;\n\n  scanf(\"%d %d\", &r.h, &r.w);\n  r.c = (int **) malloc(sizeof(int *) * r.h);\n  for (i = 0; i < r.h; ++i) {\n    r.c[i] = (int *) malloc(sizeof(int) * r.w);\n    for (j = 0; j < r.w; ++j) scanf(\"%d\", &r.c[i][j]);\n  }\n  height_histgramify(r);\n  printf(\"%d\\n\", largest_rectangle(r));\n  for (i = 0; i < r.h; ++i) free(r.c[i]);\n  free(r.c);\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define CLEAN 0\n#define DIRTY 1\n#define SIZE  1401\n#define INITIAL_STACK_SIZE 10\n\nint table[SIZE][SIZE] = {};\nint board[SIZE][SIZE] = {};\n\ntypedef struct Rectangle {\n  int height;\n  int pos;\n} Rectangle;\n\ntypedef struct _stack {\n  int size;\n  int max;\n  Rectangle *stack;\n} *Stack;\n\nStack stack_init() {\n  Stack stack = (Stack)malloc(sizeof(struct _stack));\n  stack->size = 0;\n  stack->max = INITIAL_STACK_SIZE;\n  stack->stack = (Rectangle *)malloc(sizeof(Rectangle)*INITIAL_STACK_SIZE);\n  return stack;\n}\n\nRectangle empty_rectangle() {\n  return (Rectangle) {\n    .height = 0,\n    .pos = 0\n  };\n}\n\nRectangle top(Stack stack) {\n  if (stack->size <= 0) {\n    return empty_rectangle();\n  } else \n    return stack->stack[stack->size-1];\n}\n\nRectangle pop(Stack stack) {\n  if (stack->size <= 0) {\n    return empty_rectangle();\n  } else\n    return stack->stack[--(stack->size)];\n}\n\nRectangle push(Rectangle item, Stack stack) {\n  int i;\n  if (stack->size < stack->max) {\n    stack->stack[(stack->size)++] = item;\n  } else {\n    Rectangle *newStack = (Rectangle *)malloc(sizeof(int) * stack->max * 2);\n\n    if (newStack == NULL) {\n      perror(\"malloc failed.\\n\");\n      exit(-1);\n    }\n     \n    for (i=0; i<stack->size; i++)\n      newStack[i] = stack->stack[i];\n\n    newStack[stack->size++] = item;\n    stack->max *= 2;\n    free(stack->stack);\n    stack->stack = newStack;\n  }\n\n  return item;\n}\n\nint empty(Stack stack) {\n  return !stack->size;\n}\n\nvoid free_stack(Stack stack) {\n  free(stack->stack);\n  free(stack);\n}\n\nvoid create_table(int h, int w) {\n  int i, j;\n\n  for (i=0; i<w; i++)\n    table[0][i] = (board[0][i] ? 0 : 1);\n  \n  for (i = 1; i < h; i++) {\n    for (j = 0; j < w; j++) {\n      if (board[i][j] == CLEAN)\n\ttable[i][j] = table[i-1][j] + 1;\n      else\n\ttable[i][j] = 0;\n    }\n  }\n}\n\nint rectangleAreaMaxRow(int row[],int w) {\n  Stack s = stack_init();\n  int i, max = 0;\n  row[w] = DIRTY;\n\n  for (i=0; i<=w; i++) {\n    Rectangle r;\n    r.height = row[i];\n    r.pos = i;\n    \n    if (empty(s) || top(s).height < r.height) {\n      push(r, s);\n    } else {\n      int target = i;\n      while (!empty(s) && top(s).height >= r.height) {\n\tRectangle pre = pop(s);\n\tint area = pre.height * (i-pre.pos);\n\tmax = (area > max ? area : max);\n\ttarget = pre.pos;\n      }\n      r.pos = target;\n      push(r, s);\n    }\n  }\n\n  free_stack(s);\n  return max;\n}\n  \nint rectangleAreaMax(int h, int w)\n{\n  int i, max = 0, temp;\n  for (i=0; i<h; i++) {\n    temp = rectangleAreaMaxRow(table[i], w);\n    max = (temp > max ? temp : max);\n  }\n\n  return max;\n}\n\nint main() {\n  int i, j, h, w;\n\n  scanf(\"%d %d\", &h, &w);\n  for (i=0; i<h; i++)\n    for (j=0; j<w; j++)\n      scanf(\"%d\", &board[i][j]);\n\n  create_table(h, w);\n  \n  printf(\"%d\\n\", rectangleAreaMax(h, w));\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX 1400\nint H,W;\n\nint C[MAX][MAX];\nint dp[MAX][MAX];\nint min(int a,int b){\n  if(a<b)return a;\n  else return b;\n}\nint max(int a,int b){\n  if(a<b)return b;\n  else return a;\n}\nint largest(){\n  int i,j;\n  int maxwidth=0;\n  for(i=0;i<H;i++){\n    dp[i][0]=(C[i][0]==1)? 0 : 1;\n  }\n  \n  for(j=0;j<W;j++){\n    dp[0][j]=(C[0][j]==1)? 0 : 1;\n  }\n  for(i=1;i<H;i++){\n    for(j=1;j<W;j++){\n      if(C[i][j])dp[i][j]=0;\n      else{\n\tdp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;\n\tmaxwidth=max(maxwidth,dp[i][j]);\n      }\n    }\n  }\n  return maxwidth*maxwidth;\n}\nint main(){\n  int i,j;\n  scanf(\"%d %d\",&H,&W);\n  for(i=0;i<H;i++){\n    for(j=0;j<W;j++){\n      scanf(\"%d\",&C[i][j]);\n    }\n  }\n  printf(\"%d\\n\",largest());\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint m[SIZ][SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,M=0;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tfor(r=i=0;i<x;i++)for(j=0;j<y;j++)for(M=x,k=j;k<y;k++){\n\t\tif(M>m[k][i])M=m[k][i];\n\t\tint z=k-j+1;\n\t\tif(M<z)break;\n\t\tif(r<M*z)r=M*z;\n\t}\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint A[SIZ][SIZ];\nint m[SIZ][SIZ];\nint main(){\n\tint i,j,k,x,y,r,M=0,t=0,z;\n\tscanf(\"%d%d\",&y,&x);\n\tfor(j=0;j<y;j++)for(i=0;i<x;i++)scanf(\"%d\",A[j]+i);\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++)r=A[j][i]==0?r+1:0;\n\tfor(r=i=0;i<x;i++)for(j=0;j<y;j++)for(M=x,k=j;k<y;k++){\n\t\tif(M>m[k][i])M=m[k][i];\n\t\tint z=k-j+1;\n\t\tif(r<M*z)r=M*z;\n\t}\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n \n#define CLEAN 0\n#define DIRTY 1\n#define SIZE  1401\n#define INITIAL_STACK_SIZE 10\n \nint table[SIZE][SIZE] = {};\nint board[SIZE][SIZE] = {};\n \ntypedef struct Rectangle {\n  int height;\n  int pos;\n} Rectangle;\n \ntypedef struct _stack {\n  int size;\n  int max;\n  Rectangle *stack;\n} *Stack;\n \nStack stack_init() {\n  Stack stack = (Stack)malloc(sizeof(struct _stack));\n  stack->size = 0;\n  stack->max = INITIAL_STACK_SIZE;\n  stack->stack = (Rectangle *)malloc(sizeof(Rectangle)*INITIAL_STACK_SIZE);\n  return stack;\n}\n \nRectangle empty_rectangle() {\n  return (Rectangle) {\n    .height = 0,\n    .pos = 0\n  };\n}\n \nRectangle top(Stack stack) {\n  if (stack->size <= 0) {\n    return empty_rectangle();\n  } else\n    return stack->stack[stack->size-1];\n}\n \nRectangle pop(Stack stack) {\n  if (stack->size <= 0) {\n    return empty_rectangle();\n  } else\n    return stack->stack[--(stack->size)];\n}\n \nRectangle push(Rectangle item, Stack stack) {\n  int i;\n  if (stack->size < stack->max) {\n    stack->stack[(stack->size)++] = item;\n  } else {\n    Rectangle *newStack = (Rectangle *)malloc(sizeof(int) * stack->max * 2);\n \n    if (newStack == NULL) {\n      perror(\"malloc failed.\\n\");\n      exit(-1);\n    }\n      \n    for (i=0; i<stack->size; i++)\n      newStack[i] = stack->stack[i];\n \n    newStack[stack->size++] = item;\n    stack->max *= 2;\n    free(stack->stack);\n    stack->stack = newStack;\n  }\n \n  return item;\n}\n \nint empty(Stack stack) {\n  return !stack->size;\n}\n \nvoid free_stack(Stack stack) {\n  free(stack->stack);\n  free(stack);\n}\n \nvoid create_table(int h, int w) {\n  int i, j;\n \n  for (i=0; i<w; i++)\n    table[0][i] = (board[0][i] ? 0 : 1);\n   \n  for (i = 1; i < h; i++) {\n    for (j = 0; j < w; j++) {\n      if (board[i][j] == CLEAN)\n    table[i][j] = table[i-1][j] + 1;\n      else\n    table[i][j] = 0;\n    }\n  }\n}\n \nint rectangleAreaMaxRow(int row[],int w) {\n  Stack s = stack_init();\n  int i, max = 0;\n  row[w] = DIRTY;\n \n  for (i=0; i<=w; i++) {\n    Rectangle r;\n    r.height = row[i];\n    r.pos = i;\n     \n    if (empty(s) || top(s).height < r.height) {\n      push(r, s);\n    } else {\n      int target = i;\n      while (!empty(s) && top(s).height >= r.height) {\n    Rectangle pre = pop(s);\n    int area = pre.height * (i-pre.pos);\n    max = (area > max ? area : max);\n    target = pre.pos;\n      }\n      r.pos = target;\n      push(r, s);\n    }\n  }\n \n  free_stack(s);\n  return max;\n}\n   \nint rectangleAreaMax(int h, int w)\n{\n  int i, max = 0, temp;\n  for (i=0; i<h; i++) {\n    temp = rectangleAreaMaxRow(table[i], w);\n    max = (temp > max ? temp : max);\n  }\n \n  return max;\n}\n \nint main() {\n  int i, j, h, w;\n \n  scanf(\"%d %d\", &h, &w);\n  for (i=0; i<h; i++)\n    for (j=0; j<w; j++)\n      scanf(\"%d\", &board[i][j]);\n \n  create_table(h, w);\n   \n  printf(\"%d\\n\", rectangleAreaMax(h, w));\n   \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define max(p,q)((p)>(q)?(p):(q))\n\nint h[1510];\nint tate[1510],yoko[1510],cnt;\n\nint f(int n){\n\tcnt=1;\n\tint ans=0;\n\tfor(int i=0;i<=n;i++){\n\t\tif(h[i]>tate[cnt-1]){\n\t\t\ttate[cnt]=h[i];\n\t\t\tyoko[cnt]=i;\n\t\t\tcnt++;\n\t\t}\n\t\tif(h[i]<tate[cnt-1]){\n\t\t\twhile(tate[cnt-1]>h[i]){\n\t\t\t\tans=max(ans,tate[cnt-1]*(i-yoko[cnt-1]));\n\t\t\t\tcnt--;\n\t\t\t}\n\t\t\ttate[cnt]=h[i];\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main(){\n\tint hh,w;\n\tscanf(\"%d%d\",&hh,&w);\n\tint ans=0;\n\tfor(int i=0;i<hh;i++){\n\t\tint t;\n\t\tfor(int j=0;j<w;j++){\n\t\t\tscanf(\"%d\",&t);\n\t\t\th[j]++;\n\t\t\tif(t)h[j]=0;\n\t\t}\n\t\tint temp=f(w);\n\t\tans=max(ans,temp);\n\t}\n\tprintf(\"%d\\n\",ans);\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define CLEAN 0\n#define DIRTY 1\n#define SIZE  1401\n#define INITIAL_STACK_SIZE 10\n\nint table[SIZE][SIZE] = {};\nint board[SIZE][SIZE] = {};\n\ntypedef struct Rectangle {\n  int height;\n  int pos;\n} Rectangle;\n\ntypedef struct _stack {\n  int size;\n  int max;\n  Rectangle *stack;\n} *Stack;\n\nStack stack_init() {\n  Stack stack = (Stack)malloc(sizeof(struct _stack));\n  stack->size = 0;\n  stack->max = INITIAL_STACK_SIZE;\n  stack->stack = (Rectangle *)malloc(sizeof(Rectangle)*INITIAL_STACK_SIZE);\n  return stack;\n}\n\nRectangle empty_rectangle() {\n  return (Rectangle) {\n    .height = 0,\n    .pos = 0\n  };\n}\n\nRectangle top(Stack stack) {\n  if (stack->size <= 0) {\n    return empty_rectangle();\n  } else \n    return stack->stack[stack->size-1];\n}\n\nRectangle pop(Stack stack) {\n  if (stack->size <= 0) {\n    return empty_rectangle();\n  } else\n    return stack->stack[--(stack->size)];\n}\n\nRectangle push(Rectangle item, Stack stack) {\n  int i;\n  if (stack->size < stack->max) {\n    stack->stack[(stack->size)++] = item;\n  } else {\n    Rectangle *newStack = (Rectangle *)malloc(sizeof(int) * stack->max * 2);\n\n    if (newStack == NULL) {\n      perror(\"malloc failed.\\n\");\n      exit(-1);\n    }\n     \n    for (i=0; i<stack->size; i++)\n      newStack[i] = stack->stack[i];\n\n    newStack[stack->size++] = item;\n    stack->max *= 2;\n    free(stack->stack);\n    stack->stack = newStack;\n  }\n\n  return item;\n}\n\nint empty(Stack stack) {\n  return !stack->size;\n}\n\nvoid free_stack(Stack stack) {\n  free(stack->stack);\n  free(stack);\n}\n\nvoid create_table(int h, int w) {\n  int i, j;\n\n  for (i=0; i<w; i++)\n    table[0][i] = (board[0][i] ? 0 : 1);\n  \n  for (i = 1; i < h; i++) {\n    for (j = 0; j < w; j++) {\n      if (board[i][j] == CLEAN)\n\ttable[i][j] = table[i-1][j] + 1;\n      else\n\ttable[i][j] = 0;\n    }\n  }\n}\n\nint rectangleAreaMaxRow(int row[],int w) {\n  Stack s = stack_init();\n  int i, max = 0;\n  row[w] = DIRTY;\n\n  for (i=0; i<=w; i++) {\n    Rectangle r;\n    r.height = row[i];\n    r.pos = i;\n    \n    if (empty(s) || top(s).height < r.height) {\n      push(r, s);\n    } else {\n      int target = i;\n      while (!empty(s) && top(s).height >= r.height) {\n\tRectangle pre = pop(s);\n\tint area = pre.height * (i-pre.pos);\n\tmax = (area > max ? area : max);\n\ttarget = pre.pos;\n      }\n      r.pos = target;\n      push(r, s);\n    }\n  }\n\n  free_stack(s);\n  return max;\n}\n  \nint rectangleAreaMax(int h, int w)\n{\n  int i, max = 0, temp;\n  for (i=0; i<h; i++) {\n    temp = rectangleAreaMaxRow(table[i], w);\n    max = (temp > max ? temp : max);\n  }\n\n  return max;\n}\n\nint main() {\n  int i, j, h, w;\n\n  scanf(\"%d %d\", &h, &w);\n  for (i=0; i<h; i++)\n    for (j=0; j<w; j++)\n      scanf(\"%d\", &board[i][j]);\n\n  create_table(h, w);\n  \n  printf(\"%d\\n\", rectangleAreaMax(h, w));\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define CLEAN 0\n#define DIRTY 1\n#define SIZE  1401\n#define INITIAL_STACK_SIZE 10\n\nint table[SIZE][SIZE] = {};\nint board[SIZE][SIZE] = {};\n\ntypedef struct Rectangle {\n  int height;\n  int pos;\n} Rectangle;\n\ntypedef struct _stack {\n  int size;\n  int max;\n  Rectangle *stack;\n} *Stack;\n\nStack stack_init() {\n  Stack stack = (Stack)malloc(sizeof(struct _stack));\n  stack->size = 0;\n  stack->max = INITIAL_STACK_SIZE;\n  stack->stack = (Rectangle *)malloc(sizeof(Rectangle)*INITIAL_STACK_SIZE);\n  return stack;\n}\n\nRectangle empty_rectangle() {\n  return (Rectangle) {\n    .height = 0,\n    .pos = 0\n  };\n}\n\nRectangle top(Stack stack) {\n  if (stack->size <= 0) {\n    return empty_rectangle();\n  } else \n    return stack->stack[stack->size-1];\n}\n\nRectangle pop(Stack stack) {\n  if (stack->size <= 0) {\n    return empty_rectangle();\n  } else\n    return stack->stack[--(stack->size)];\n}\n\nRectangle push(Rectangle item, Stack stack) {\n  if (stack->size < stack->max) {\n    stack->stack[(stack->size)++] = item;\n  } else {\n    Rectangle *newStack = (Rectangle *)malloc(sizeof(int) * stack->max * 2);\n\n    if (newStack == NULL) {\n      perror(\"malloc failed.\\n\");\n      exit(-1);\n    }\n     \n    for (int i=0; i<stack->size; i++)\n      newStack[i] = stack->stack[i];\n\n    newStack[stack->size++] = item;\n    stack->max *= 2;\n    free(stack->stack);\n    stack->stack = newStack;\n  }\n\n  return item;\n}\n\nint empty(Stack stack) {\n  return !stack->size;\n}\n\nvoid free_stack(Stack stack) {\n  free(stack);\n}\n\nvoid create_table(int h, int w) {\n  int i, j;\n\n  for (i=0; i<w; i++)\n    table[0][i] = (board[0][i] ? 0 : 1);\n  \n  for (i = 1; i < h; i++) {\n    for (j = 0; j < w; j++) {\n      if (board[i][j] == CLEAN)\n\ttable[i][j] = table[i-1][j] + 1;\n      else\n\ttable[i][j] = 0;\n    }\n  }\n}\n\nint rectangleAreaMaxRow(int row[],int w) {\n  Stack s = stack_init();\n  int i, max = 0;\n  int top_height;\n\n  for (i=1; i<=w; i++) {\n    Rectangle r;\n    r.height = row[i-1];\n    r.pos = i;\n    top_height = top(s).height;\n    if (empty(s) || top_height < r.height) {\n      push(r, s);\n    } else if (top_height > r.height) {\n      int target = i;\n      while (!empty(s) && top(s).height >= r.height) {\n\tRectangle pre = pop(s);\n\tint area = pre.height * (i-pre.pos);\n\tmax = (area > max ? area : max);\n\ttarget = pre.pos;\n      }\n      r.pos = target;\n      push(r, s);\n    }\n  }\n\n  free_stack(s);\n  return max;\n}\n  \nint rectangleAreaMax(int h, int w)\n{\n  int i, max = 0, temp;\n  for (i=0; i<h; i++) {\n    temp = rectangleAreaMaxRow(table[i], w);\n    max = (temp > max ? temp : max);\n  }\n\n  return max;\n}\n\nint main() {\n  int i, j, h, w;\n\n  scanf(\"%d %d\", &h, &w);\n  for (i=0; i<h; i++)\n    for (j=0; j<w; j++)\n      scanf(\"%d\", &board[i][j]);\n\n  create_table(h, w);\n  \n  printf(\"%d\\n\", rectangleAreaMax(h, w));\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint m[SIZ][SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,M=0;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tfor(r=i=0;i<x;i++)for(j=0;j<y;j++)for(M=x,k=j;k<y;k++){\n\t\tif(M>m[k][i])M=m[k][i];\n\t\tint z=k-j+1;\n\t\tif(r<M*z)r=M*z;\n\t}\n\tprintf(\"%d\\n\",r*r);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define CLEAN 0\n#define DIRTY 1\n#define SIZE  1401\n#define INITIAL_STACK_SIZE 10\n\nint table[SIZE][SIZE] = {};\nint board[SIZE][SIZE] = {};\n\ntypedef struct Rectangle {\n  int height;\n  int pos;\n} Rectangle;\n\ntypedef struct _stack {\n  int size;\n  int max;\n  Rectangle *stack;\n} *Stack;\n\nStack stack_init() {\n  Stack stack = (Stack)malloc(sizeof(struct _stack));\n  stack->size = 0;\n  stack->max = INITIAL_STACK_SIZE;\n  stack->stack = (Rectangle *)malloc(sizeof(Rectangle)*INITIAL_STACK_SIZE);\n  return stack;\n}\n\nRectangle empty_rectangle() {\n  return (Rectangle) {\n    .height = 0,\n    .pos = 0\n  };\n}\n\nRectangle top(Stack stack) {\n  if (stack->size <= 0) {\n    return empty_rectangle();\n  } else \n    return stack->stack[stack->size-1];\n}\n\nRectangle pop(Stack stack) {\n  if (stack->size <= 0) {\n    return empty_rectangle();\n  } else\n    return stack->stack[--(stack->size)];\n}\n\nRectangle push(Rectangle item, Stack stack) {\n  int i;\n  if (stack->size < stack->max) {\n    stack->stack[(stack->size)++] = item;\n  } else {\n    Rectangle *newStack = (Rectangle *)malloc(sizeof(int) * stack->max * 2);\n\n    if (newStack == NULL) {\n      perror(\"malloc failed.\\n\");\n      exit(-1);\n    }\n     \n    for (i=0; i<stack->size; i++)\n      newStack[i] = stack->stack[i];\n\n    newStack[stack->size++] = item;\n    stack->max *= 2;\n    free(stack->stack);\n    stack->stack = newStack;\n  }\n\n  return item;\n}\n\nint empty(Stack stack) {\n  return !stack->size;\n}\n\nvoid free_stack(Stack stack) {\n  free(stack);\n}\n\nvoid create_table(int h, int w) {\n  int i, j;\n\n  for (i=0; i<w; i++)\n    table[0][i] = (board[0][i] ? 0 : 1);\n  \n  for (i = 1; i < h; i++) {\n    for (j = 0; j < w; j++) {\n      if (board[i][j] == CLEAN)\n\ttable[i][j] = table[i-1][j] + 1;\n      else\n\ttable[i][j] = 0;\n    }\n  }\n}\n\nint rectangleAreaMaxRow(int row[],int w) {\n  Stack s = stack_init();\n  int i, max = 0, is_all_dirty = 1;\n  int top_height;\n\n  for (i=1; i<=w; i++) {\n    Rectangle r;\n    r.height = row[i-1];\n    r.pos = i;\n    top_height = top(s).height;\n    if (row[i-1] == CLEAN)\n\tis_all_dirty = 0;\n    \n    if (empty(s) || top_height < r.height) {\n      push(r, s);\n    } else if (top_height > r.height) {\n      int target = i;\n      while (!empty(s) && top(s).height >= r.height) {\n\tRectangle pre = pop(s);\n\tint area = pre.height * (i-pre.pos);\n\tmax = (area > max ? area : max);\n\ttarget = pre.pos;\n      }\n      r.pos = target;\n      push(r, s);\n    }\n  }\n\n  free_stack(s);\n  return (is_all_dirty ? 0 : (max > 1 ? max : 1));\n}\n  \nint rectangleAreaMax(int h, int w)\n{\n  int i, max = 0, temp;\n  for (i=0; i<h; i++) {\n    temp = rectangleAreaMaxRow(table[i], w);\n    max = (temp > max ? temp : max);\n  }\n\n  return max;\n}\n\nint main() {\n  int i, j, h, w;\n\n  scanf(\"%d %d\", &h, &w);\n  for (i=0; i<h; i++)\n    for (j=0; j<w; j++)\n      scanf(\"%d\", &board[i][j]);\n\n  create_table(h, w);\n  \n  printf(\"%d\\n\", rectangleAreaMax(h, w));\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define CLEAN 0\n#define DIRTY 1\n#define SIZE  1401\n#define INITIAL_STACK_SIZE 10\n\nint table[SIZE][SIZE] = {};\nint board[SIZE][SIZE] = {};\n\ntypedef struct Rectangle {\n  int height;\n  int pos;\n} Rectangle;\n\ntypedef struct _stack {\n  int size;\n  int max;\n  Rectangle *stack;\n} *Stack;\n\nStack stack_init() {\n  Stack stack = (Stack)malloc(sizeof(struct _stack));\n  stack->size = 0;\n  stack->max = INITIAL_STACK_SIZE;\n  stack->stack = (Rectangle *)malloc(sizeof(Rectangle)*INITIAL_STACK_SIZE);\n  return stack;\n}\n\nRectangle empty_rectangle() {\n  return (Rectangle) {\n    .height = 0,\n    .pos = 0\n  };\n}\n\nRectangle top(Stack stack) {\n  if (stack->size <= 0) {\n    return empty_rectangle();\n  } else \n    return stack->stack[stack->size-1];\n}\n\nRectangle pop(Stack stack) {\n  if (stack->size <= 0) {\n    return empty_rectangle();\n  } else\n    return stack->stack[--(stack->size)];\n}\n\nRectangle push(Rectangle item, Stack stack) {\n  if (stack->size < stack->max) {\n    stack->stack[(stack->size)++] = item;\n  } else {\n    Rectangle *newStack = (Rectangle *)malloc(sizeof(int) * stack->max * 2);\n\n    if (newStack == NULL) {\n      perror(\"malloc failed.\\n\");\n      exit(-1);\n    }\n     \n    for (int i=0; i<stack->size; i++)\n      newStack[i] = stack->stack[i];\n\n    newStack[stack->size++] = item;\n    stack->max *= 2;\n    free(stack->stack);\n    stack->stack = newStack;\n  }\n\n  return item;\n}\n\nint empty(Stack stack) {\n  return !stack->size;\n}\n\nvoid free_stack(Stack stack) {\n  free(stack);\n}\n\nvoid create_table(int h, int w) {\n  int i, j;\n\n  for (i=0; i<w; i++)\n    table[0][i] = (board[0][i] ? 0 : 1);\n  \n  for (i = 1; i < h; i++) {\n    for (j = 0; j < w; j++) {\n      if (board[i][j] == CLEAN)\n\ttable[i][j] = table[i-1][j] + 1;\n      else\n\ttable[i][j] = 0;\n    }\n  }\n}\n\nint rectangleAreaMaxRow(int row[],int w) {\n  Stack s = stack_init();\n  int max = 0;\n  int top_height;\n\n  for (int i=1; i<=w; i++) {\n    Rectangle r;\n    r.height = row[i-1];\n    r.pos = i;\n    top_height = top(s).height;\n    if (empty(s) || top_height < r.height) {\n      push(r, s);\n    } else if (top_height > r.height) {\n      int target = i;\n      while (!empty(s) && top(s).height >= r.height) {\n\tRectangle pre = pop(s);\n\tint area = pre.height * (i-pre.pos);\n\tmax = (area > max ? area : max);\n\ttarget = pre.pos;\n      }\n      r.pos = target;\n      push(r, s);\n    }\n  }\n\n  free_stack(s);\n  return max;\n}\n  \nint rectangleAreaMax(int h, int w)\n{\n  int max = 0, temp;\n  for (int i=0; i<h; i++) {\n    temp = rectangleAreaMaxRow(table[i], w);\n    max = (temp > max ? temp : max);\n  }\n\n  return max;\n}\n\nint main() {\n  int i, j, h, w;\n\n  scanf(\"%d %d\", &h, &w);\n  for (i=0; i<h; i++)\n    for (j=0; j<w; j++)\n      scanf(\"%d\", &board[i][j]);\n\n  create_table(h, w);\n  \n  printf(\"%d\\n\", rectangleAreaMax(h, w));\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint m[SIZ][SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,M=0;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tfor(r=i=0;i<x;i++)for(j=0;j<y;j++)for(M=x,k=j;k<y;k++){\n\t\tif(M>m[k][i])M=m[k][i];\n\t\tint z=k-j+1;\n\t\tif(M+130<z)break;\n\t\tif(r<M*z)r=M*z;\n\t}\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 1400\nstruct rect {\n  int height;\n  int pos;\n};\nint buffer[MAX][MAX], table[MAX][MAX];\nint large_rectangle(int w, int *t);\nint main(void)\n{\n  int i, j, h, w, max = 0;\n  scanf(\"%d%d\", &h, &w);\n  for (i = 0; i < h; i++) {\n    for (j = 0; j < w; j++) {\n      scanf(\"%d\", &buffer[i][j]);\n    }\n  }\n  for (i = 0; i < h; i++) {\n    for (j = 0; j < w; j++) {\n      if (buffer[i][j]) table[i][j] = 0;\n      else table[i][j] = (i > 0) ? table[i-1][j] + 1 : 1;\n    }\n  }\n  for (i = 0; i < h; i++) {\n    int temp = large_rectangle(w, table[i]);\n    if (max < temp) max = temp;\n  }\n  printf(\"%d\\n\", max);\n}\nint large_rectangle(int w, int *t)\n{\n  int i, sp = 0, max = 0;\n  struct rect stack[MAX];\n  t[w] = 0;\n  for (i = 0; i <= w; i++) {\n    struct rect r;\n    r.height = t[i];\n    r.pos = i;\n    if (!sp || stack[sp-1].height < r.height) stack[sp++] = r;\n    else if (stack[sp-1].height > r.height){\n      int target = i;\n        while (sp && stack[sp-1].height >= r.height) {\n        struct rect pre = stack[--sp];\n          int area = pre.height * (i - pre.pos);\n          if (max < area) max = area;\n          target = pre.pos;\n        }\n        r.pos = target;\n        stack[sp++] = r;\n    }\n  }\n  return max;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ+1];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tfor(r=j=0;j<y;j++)for(ptr=i=0;i<x;i++){\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\t\tint y=ptr-1,x=st[--ptr];\n\t\t\t\tif(r<x*y)r=x*y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define MAX 1400\nint H,W;\n\nint C[MAX][MAX];\nint dp[MAX][MAX];\nint min(int a,int b){\n  if(a<b)return a;\n  else return b;\n}\nint max(int a,int b){\n  if(a<b)return b;\n  else return a;\n}\nint largest(){\n  int i,j;\n  int maxwidth=0;\n  for(i=0;i<H;i++){\n    dp[i][0]=(C[i][0]==1)? 0 : 1;\n  }\n  \n  for(j=0;j<W;j++){\n    dp[0][i]=(C[0][i]==1) ? 0 : 1;\n  }\n  for(i=1;i<H;i++){\n    for(j=1;j<W;j++){\n      if(C[i][j])dp[i][j]=0;\n      else{\n\tdp[i][j]=min(dp[i-1][j-1],min(dp[i-1][j],dp[i][j-1]))+1;\n\tmaxwidth=max(maxwidth,dp[i][j]);\n      }\n    }\n  }\n  return maxwidth*maxwidth;\n}\nint main(){\n  int i,j;\n  scanf(\"%d %d\",&H,&W);\n  for(i=0;i<H;i++){\n    for(j=0;j<W;j++){\n      scanf(\"%d\",&C[i][j]);\n    }\n  }\n  printf(\"%d\\n\",largest());\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint m[SIZ][SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,M=0;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tfor(r=i=0;i<x;i++)for(j=0;j<y;j++)for(M=x,k=j;k<y;k++){\n\t\tif(M>m[k][i])M=m[k][i];\n\t\tint z=k-j+1;\n\t\tif(M+150<z)break;\n\t\tif(r<M*z)r=M*z;\n\t}\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint m[SIZ][SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,M=0;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tfor(r=i=0;i<x;i++)for(j=0;j<y;j++)for(M=x,k=j;k<y;k++){\n\t\tif(M>m[k][i])M=m[k][i];\n\t\tint z=k-j+1;\n\t\tif(M+100<z)break;\n\t\tif(r<M*z)r=M*z;\n\t}\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ];\nlong long st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tr=0;\n\tfor(r=i=0;i<x;i++)for(ptr=j=0;j<=y;j++){\n\t\tint left=j;\n\t\tfor(;ptr && st[ptr-1]>m[j][i];){\n\t\t\tint l=st[ptr-1]&0xffffffff,h=st[ptr-1]>>32;\n\t\t\tptr--;\n\t\t\tif(r<(j-l-1)*h)r=(j-l-1)*h;\n\t\t\tleft=l;\n\t\t}\n\t\tst[ptr++]=((long long)m[j][i]<<32)|left;\n\t}\n\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <stdint.h> // uint64_t\n\n#define max(a,b) ((a) > (b) ? (a) : (b))\n#define min(a,b) ((a) > (b) ? (b) : (a))\n#define min3(a,b,c) min(min(a,b),c)\n\nint get_int2(int *a1, int *a2) {\n  scanf(\"%d %d\", a1, a2);\n  return 0;\n}\n\n// <arr[0]> <arr[1]> .. <arr[size-1]>\nint fget_array(char *arr, int size) {\n    int i;\n    for(i = 0; i < size; i++) {\n        int num;\n        scanf(\"%d\", &num);\n        arr[i] = num;\n    }\n    return 0;\n}\n\n#define NUM_MAX 1400\n\nstruct rect {\n    int height;\n    int pos;\n};\nstatic struct rect stack[NUM_MAX+1];\nstatic int idx = 0;\n\nvoid init_stack(void) { idx=0; }\nint is_empty(void) {\n    return idx==0;\n}\n\nvoid push(struct rect r) {\n    stack[idx++] = r;\n}\n\nstruct rect pop(void) {\n    return stack[--idx];\n}\n\nstruct rect peek(void) {\n    return stack[idx-1];\n}\n\nint main(void) {\n    int height, width;\n    get_int2(&height, &width);\n    static char mat[NUM_MAX+1][NUM_MAX+1];\n    int i, j;\n    for(i = 1; i <= height; i++) {\n        fget_array(&mat[i][1], width);\n        // 0: dirty, 1: clean(usable)\n        for(j = 1; j <= width; j++) mat[i][j] = 1-mat[i][j];\n    }\n\n    static int hist[NUM_MAX+2][NUM_MAX+2];\n    for(i = 1; i <= height; i++) {\n        for(j = 1; j <= width; j++) {\n            if(!mat[i][j]) {\n                hist[i][j] = 0;\n            } else {\n                hist[i][j] = hist[i-1][j] + 1;\n            }\n        }\n        hist[i][width+1] = 0;\n    }\n#ifdef DEBUG\n    for(i = 1; i <= height; i++) {\n        for(j = 1; j <= width; j++) {\n            printf(\" %d\", hist[i][j]);\n        }\n        putchar('\\n');\n    }\n#endif\n\n    int ans = 0;\n    for(i = 1; i <= height; i++) {\n        init_stack();\n        for(j = 1; j <= width+1; j++) {\n            struct rect cur = {hist[i][j], j};\n            while(!is_empty()) {\n                struct rect pr = peek();\n                if(pr.height < cur.height) break;\n#ifdef DEBUG\n                printf(\"(%d, %d) height: %d, width: %d\\n\", i, j, pr.height, j-pr.pos);\n#endif\n                ans = max(ans, (j-pr.pos)*pr.height);\n                cur.pos = pr.pos; // update smaller\n                pop();\n            }\n            push(cur);\n        }\n    }\n    printf(\"%d\\n\", ans);\n\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint m[SIZ][SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,M=0;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tfor(r=i=0;i<x;i++)for(j=0;j<y;j++)for(M=x,k=j;k<y;k++){\n\t\tif(M>m[k][i])M=m[k][i];\n\t\tint z=k-j+1;\n\t\tif(M+200<z)break;\n\t\tif(r<M*z)r=M*z;\n\t}\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MAX 1400\nstruct rect {\n  int height;\n  int pos;\n};\nint buffer[MAX][MAX], table[MAX][MAX];\nint large_rectangle(int w, int *t);\nint main(void)\n{\n  int i, j, h, w, max = 0;\n  scanf(\"%d%d\", &h, &w);\n  for (i = 0; i < h; i++) {\n    for (j = 0; j < w; j++) {\n      scanf(\"%d\", &buffer[i][j]);\n    }\n  }\n  for (i = 0; i < h; i++) {\n    for (j = 0; j < w; j++) {\n      if (buffer[i][j]) table[i][j] = 0;\n      else table[i][j] = (i > 0) ? table[i-1][j] + 1 : 1;\n    }\n  }\n  for (i = 0; i < h; i++) {\n    int temp = large_rectangle(w, table[i]);\n    if (max < temp) max = temp;\n  }\n  printf(\"%d\\n\", max);\n}\nint large_rectangle(int w, int *t)\n{\n  int i, sp = 0, max = 0;\n  struct rect stack[MAX];\n  t[w] = 0;\n  for (i = 0; i <= w; i++) {\n    struct rect r;\n    r.height = t[i];\n    r.pos = i;\n    if (!sp || stack[sp-1].height < r.height) stack[sp++] = r;\n    else if (stack[sp-1].height > r.height){\n      int target = i;\n        while (sp && stack[sp-1].height >= r.height) {\n        struct rect pre = stack[(sp--)-1];\n          int area = pre.height * (i - pre.pos);\n          if (max < area) max = area;\n          target = pre.pos;\n        }\n        r.pos = target;\n        stack[sp++] = r;\n    }\n  }\n  return max;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint m[SIZ][SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,M=0;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tfor(r=i=0;i<x;i++)for(j=0;j<y;j++)for(M=x,k=j;k<y;k++){\n\t\tif(M>m[k][i])M=m[k][i];\n\t\tint z=k-j+1;\n\t\tif(r<M*z)r=M*z;\n\t}\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint m[SIZ][SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,M=0;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tfor(r=i=0;i<x;i++)for(j=0;j<y;j++)for(M=x,k=j;k<y;k++){\n\t\tif(M>m[k][i])M=m[k][i];\n\t\tint z=k-j+1;\n\t\tif(M+120<z)break;\n\t\tif(r<M*z)r=M*z;\n\t}\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define CLEAN 0\n#define DIRTY 1\n#define SIZE  1401\n#define INITIAL_STACK_SIZE 10\n\nint table[SIZE][SIZE] = {};\nint board[SIZE][SIZE] = {};\n\ntypedef struct Rectangle {\n  int height;\n  int pos;\n} Rectangle;\n\ntypedef struct _stack {\n  int size;\n  int max;\n  Rectangle *stack;\n} *Stack;\n\nStack stack_init() {\n  Stack stack = (Stack)malloc(sizeof(struct _stack));\n  stack->size = 0;\n  stack->max = INITIAL_STACK_SIZE;\n  stack->stack = (Rectangle *)malloc(sizeof(Rectangle)*INITIAL_STACK_SIZE);\n  return stack;\n}\n\nRectangle empty_rectangle() {\n  return (Rectangle) {\n    .height = 0,\n    .pos = 0\n  };\n}\n\nRectangle top(Stack stack) {\n  if (stack->size <= 0) {\n    return empty_rectangle();\n  } else \n    return stack->stack[stack->size-1];\n}\n\nRectangle pop(Stack stack) {\n  if (stack->size <= 0) {\n    return empty_rectangle();\n  } else\n    return stack->stack[--(stack->size)];\n}\n\nRectangle push(Rectangle item, Stack stack) {\n  int i;\n  if (stack->size < stack->max) {\n    stack->stack[(stack->size)++] = item;\n  } else {\n    Rectangle *newStack = (Rectangle *)malloc(sizeof(int) * stack->max * 2);\n\n    if (newStack == NULL) {\n      perror(\"malloc failed.\\n\");\n      exit(-1);\n    }\n     \n    for (i=0; i<stack->size; i++)\n      newStack[i] = stack->stack[i];\n\n    newStack[stack->size++] = item;\n    stack->max *= 2;\n    free(stack->stack);\n    stack->stack = newStack;\n  }\n\n  return item;\n}\n\nint empty(Stack stack) {\n  return !stack->size;\n}\n\nvoid free_stack(Stack stack) {\n  free(stack);\n}\n\nvoid create_table(int h, int w) {\n  int i, j;\n\n  for (i=0; i<w; i++)\n    table[0][i] = (board[0][i] ? 0 : 1);\n  \n  for (i = 1; i < h; i++) {\n    for (j = 0; j < w; j++) {\n      if (board[i][j] == CLEAN)\n\ttable[i][j] = table[i-1][j] + 1;\n      else\n\ttable[i][j] = 0;\n    }\n  }\n}\n\nint rectangleAreaMaxRow(int row[],int w) {\n  Stack s = stack_init();\n  int i, max = 0;\n  int top_height;\n\n  for (i=1; i<=w; i++) {\n    Rectangle r;\n    r.height = row[i-1];\n    r.pos = i;\n    top_height = top(s).height;\n    if (empty(s) || top_height < r.height) {\n      push(r, s);\n    } else if (top_height > r.height) {\n      int target = i;\n      while (!empty(s) && top(s).height >= r.height) {\n\tRectangle pre = pop(s);\n\tint area = pre.height * (i-pre.pos);\n\tmax = (area > max ? area : max);\n\ttarget = pre.pos;\n      }\n      r.pos = target;\n      push(r, s);\n    }\n  }\n\n  free_stack(s);\n  return max;\n}\n  \nint rectangleAreaMax(int h, int w)\n{\n  int i, max = 0, temp;\n  for (i=0; i<h; i++) {\n    temp = rectangleAreaMaxRow(table[i], w);\n    max = (temp > max ? temp : max);\n  }\n\n  return max;\n}\n\nint main() {\n  int i, j, h, w;\n\n  scanf(\"%d %d\", &h, &w);\n  for (i=0; i<h; i++)\n    for (j=0; j<w; j++)\n      scanf(\"%d\", &board[i][j]);\n\n  create_table(h, w);\n  \n  printf(\"%d\\n\", rectangleAreaMax(h, w));\n  \n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ DPL_3_B Largest Rectangle\n// 2018.5.12 bal4u\n \n#include <stdio.h>\n#include <stdlib.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n \nint in()\n{\n    int n = 0, c = gc();\n    do n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n    return n;\n}\n\ntypedef struct { int lp, h; } STACK;\nSTACK stack[1500]; int top;\n\nint maxRectInHistogram(int n, int *h)\n{\n\tint i, s, ans;\n\n\th[n] = 0;\n\t\n\tans = 0;\n\tstack[0].lp = -1, stack[0].h = -1, top = 0;\n\tfor (i = 0; i <= n; i++) {\n\t\tif (h[i] == stack[top].h) continue;\n\t\tif (h[i] > stack[top].h) {\n\t\t\tstack[++top].lp = i, stack[top].h = h[i];\n\t\t} else {\n\t\t\twhile (h[i] < stack[top].h) {\n\t\t\t\ts = stack[top].h*(i-stack[top].lp);\n\t\t\t\ttop--;\n\t\t\t\tif (s > ans) ans = s;\n\t\t\t}\n\t\t\tstack[++top].h = h[i];\n\t\t}\n\t}\n\treturn ans;\n}\n\nint h[1402][1402];\nchar map[1402][1402];\n\nint main()\n{\n\tint H, W, r, c, t, ans;\n\n\tH = in(), W = in();\n\tfor (r = 0; r < H; r++) for (c = 0; c < W; c++) {\n\t\tmap[r][c] = gc() & 1; gc();\n\t}\n\t\n\tfor (c = 0; c < W; c++) {\n\t\tt = 0;\n\t\tfor (r = 0; r < H; r++) {\n\t\t\tif (map[r][c]) t = 0;\n\t\t\telse h[r][c] = ++t;\n\t\t}\n\t}\n\t\n\tans = 0;\n\tfor (r = 0; r < H; r++) {\n\t\tt = maxRectInHistogram(W, h[r]);\n\t\tif (t > ans) ans = t;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint m[SIZ][SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,M=0;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tfor(r=i=0;i<x;i++)for(j=0;j<y;j++)for(M=x,k=j;k<y;k++){\n\t\tif(M>m[k][i])M=m[k][i];\n\t\tint z=k-j+1;\n\t\tif(M+140<z)break;\n\t\tif(r<M*z)r=M*z;\n\t}\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ DPL_3_B Largest Rectangle\n// 2018.5.12 bal4u\n \n#include <stdio.h>\n\n#if 1\n#define gc() getchar_unlocked()\n#else\n#define gc() getchar()\n#endif\n \nint in()\n{\n    int n = 0, c = gc();\n    do n = 10*n + (c & 0xf), c = gc(); while (c >= '0');\n    return n;\n}\n\ntypedef struct { int lp, h; } STACK;\nSTACK stack[1500]; int top;\n\nint maxRectInHistogram(int n, int *h)\n{\n\tint i, s, ans;\n\n\th[n] = 0;\n\t\n\tans = 0;\n\tstack[0].lp = -1, stack[0].h = -1, top = 0;\n\tfor (i = 0; i <= n; i++) {\n\t\tif (h[i] == stack[top].h) continue;\n\t\tif (h[i] > stack[top].h) {\n\t\t\tstack[++top].lp = i, stack[top].h = h[i];\n\t\t} else {\n\t\t\twhile (h[i] < stack[top].h) {\n\t\t\t\ts = stack[top].h*(i-stack[top].lp);\n\t\t\t\ttop--;\n\t\t\t\tif (s > ans) ans = s;\n\t\t\t}\n\t\t\tstack[++top].h = h[i];\n\t\t}\n\t}\n\treturn ans;\n}\n\nint h[1402][1402];\nchar map[1402][1402];\n\nint main()\n{\n\tint H, W, r, c, t, ans;\n\n\tH = in(), W = in();\n\tfor (r = 0; r < H; r++) for (c = 0; c < W; c++) {\n\t\tmap[r][c] = gc() & 1; gc();\n\t}\n\t\n\tfor (c = 0; c < W; c++) {\n\t\tt = 0;\n\t\tfor (r = 0; r < H; r++) {\n\t\t\tif (map[r][c]) t = 0;\n\t\t\telse h[r][c] = ++t;\n\t\t}\n\t}\n\t\n\tans = 0;\n\tfor (r = H-1; r >= 0; r--) {\n\t\tt = maxRectInHistogram(W, h[r]);\n\t\tif (t > ans) ans = t;\n\t\tif (ans >= W*r) break;\n\t}\n\tprintf(\"%d\\n\", ans);\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint m[SIZ][SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,M=0;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tfor(r=i=0;i<x;i++)for(j=0;j<y;j++)for(M=x,k=j;k<y;k++){\n\t\tif(M>m[k][i])M=m[k][i];\n\t\tint z=k-j+1;\n\t\tif(M+10<z)break;\n\t\tif(r<M*z)r=M*z;\n\t}\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint m[SIZ][SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,M=0;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tfor(r=i=0;i<x;i++)for(j=0;j<y;j++)for(M=x,k=j;k<y;k++){\n\t\tif(M>m[k][i])M=m[k][i];\n\t\tint z=k-j+1;\n\t\tif(M+400<z)break;\n\t\tif(r<M*z)r=M*z;\n\t}\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint m[SIZ+1][SIZ];\nint st[SIZ];\nchar z[9999999];\nint get(){\n\tstatic int input_count=0;\n\tint r=0;\n\tfor(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n\tinput_count++;\n\treturn r;\n}\nint main(){\n\tfread(z,1,sizeof(z),stdin);\n\tint i,j,k,y=get(),x=get(),r,ptr;\n\tfor(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n\t\tint t=get();\n\t\tr=t==0?r+1:0;\n\t}\n\tfor(r=i=0;i<x;i++)for(ptr=j=0;j<y;j++){\n\t\tif(!ptr || st[ptr-1]<m[j][i])st[ptr++]=m[j][i];\n\t\telse{\n\t\t\tfor(;ptr && st[ptr-1]>=m[j][i];){\n\t\t\t\tint y=ptr-1,x=st[--ptr];\n\t\t\t\tif(r<x*y)r=x*y;\n\t\t\t}\n\t\t\tst[ptr++]=m[j][i];\n\t\t}\n\t}\n\tprintf(\"%d\\n\",r);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define SIZ 1400\nint m[SIZ][SIZ];\nchar z[9999999];\nint get(){\n    static int input_count=0;\n    int r=0;\n    for(;'0'<=z[input_count]&&z[input_count]<='9';)r=r*10+z[input_count++]-'0';\n    input_count++;\n    return r;\n}\nint main(){\n    fread(z,1,sizeof(z),stdin);\n    int i,j,k,y=get(),x=get(),r,M=0;\n    for(j=0;j<y;j++)for(r=i=0;i<x;m[j][i]=r,i++){\n        int t=get();\n        r=t==0?r+1:0;\n    }\n    for(r=i=0;i<x;i++)for(j=0;j<y;j++)for(M=x,k=j;k<y;k++){\n        if(M>m[k][i])M=m[k][i];\n        if(!M)break;\n        int z=k-j+1;\n        if(r<M*z)r=M*z;\n    }\n    printf(\"%d\\n\",r);\n    return 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tUserScanner scan = new UserScanner();\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\n\t\tRectangle rg = new Rectangle(h, w, debug);\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\trg.addTile(i, j, scan.nextInt());\n\n\t\tpwriter.println(rg.getMaxRect());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rectangle {\n\tboolean debug;\n\tint wmax, hmax;\n\tint maxArea;\n\tint dTile;\n\tList<Tile> tile = new ArrayList<Tile>();\n\tint kdTreeRoot;\n\n\tint histLeftUpperH = -1, histLeftUpperW = -1, histLeftUpperArea = -1;\n\tint histRightUpperH = -1, histRightUpperW = wmax + 1, histRightUpperArea = -1;\n\tint histLeftLowerH = hmax + 1, histLeftLowerW = -1, histLeftLowerArea = -1;\n\tint histRightLowerH = hmax + 1, histRightLowerW = wmax + 1, histRightLowerArea = -1;\n\n\tclass Tile {\n\t\tint h, w;\n\t\tint leChild, gtChild;\n\n\t\tpublic Tile(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t\tleChild = -1;\n\t\t\tgtChild = -1;\n\t\t}\n\n\t\tpublic int getHW(boolean isHeight) {\n\t\t\tif (isHeight)\n\t\t\t\treturn h;\n\t\t\telse\n\t\t\t\treturn w;\n\t\t}\n\t}\n\n\tpublic Rectangle(int h, int w, boolean debug) {\n\t\tthis.debug = debug;\n\t\thmax = h - 1;\n\t\twmax = w - 1;\n\t}\n\n\tpublic int getMaxRect() {\n\t\tTile[] tree = (Tile[]) tile.toArray(new Tile[0]);\n\t\tkdTreeRoot = buildKDtree(tree, 0, dTile, true);\n\n\t\treturn getMaxArea(tree, 0, 0, hmax, wmax);\n\t}\n\n\tprivate int getMaxArea(Tile[] tree, int h1, int w1, int h2, int w2) {\n\t\tif (h1 > h2 || w1 > w2)\n\t\t\treturn 0;\n\n\t\tint area = -1;\n\t\tif ((area = getHist(h1, w1, h2, w2)) >= 0)\n\t\t\treturn area;\n\t\tint in = inTile(kdTreeRoot, tree, true, h1, w1, h2, w2);\n\t\tif (debug) {\n\t\t\tSystem.out.println(\"- searched area \" + h1 + \",\" + w1 + \"\\t\" + h2 + \",\" + w2 + \"\\t\" + in);\n\t\t}\n\n\t\tif (in == -1)\n\t\t\tarea = (h2 - h1 + 1) * (w2 - w1 + 1);\n\t\telse {\n\t\t\tarea = getMaxArea(tree, h1, w1, h2, tree[in].w - 1);\n\t\t\tarea = Math.max(area, getMaxArea(tree, h1, w1, tree[in].h - 1, w2));\n\t\t\tarea = Math.max(area, getMaxArea(tree, h1, tree[in].w + 1, h2, w2));\n\t\t\tarea = Math.max(area, getMaxArea(tree, tree[in].h + 1, w1, h2, w2));\n\t\t}\n\t\tsaveHist(area, h1, w1, h2, w2);\n\t\treturn area;\n\t}\n\n\tprivate void saveHist(int area, int h1, int w1, int h2, int w2) {\n\t\tif (h1 == 0 && w1 == 0 && h2 > histLeftUpperH && w2 > histLeftUpperW) {\n\t\t\thistLeftUpperH = h2;\n\t\t\thistLeftUpperW = w2;\n\t\t\thistLeftUpperArea = area;\n\t\t\treturn;\n\t\t}\n\t\tif (h1 == 0 && w2 == wmax && h2 > histRightUpperH && w1 < histRightUpperW) {\n\t\t\thistRightUpperH = h2;\n\t\t\thistRightUpperW = w1;\n\t\t\thistRightUpperArea = area;\n\t\t\treturn;\n\t\t}\n\t\tif (h2 == hmax && w1 == 0 && h1 < histLeftLowerH && w2 > histLeftLowerW) {\n\t\t\thistLeftLowerH = h1;\n\t\t\thistLeftLowerW = w2;\n\t\t\thistLeftLowerArea = area;\n\t\t\treturn;\n\t\t}\n\t\tif (h2 == hmax && w2 == wmax && h1 < histRightLowerH && w1 < histRightLowerW) {\n\t\t\thistRightLowerH = h1;\n\t\t\thistRightLowerW = w1;\n\t\t\thistRightLowerArea = area;\n\t\t\treturn;\n\t\t}\n\t}\n\n\tprivate int getHist(int h1, int w1, int h2, int w2) {\n\t\tif (h2 <= histLeftUpperH && w2 <= histLeftUpperW)\n\t\t\treturn histLeftUpperArea;\n\t\tif (h2 <= histRightUpperH && w1 >= histRightUpperW)\n\t\t\treturn histRightUpperArea;\n\t\tif (h1 >= histLeftLowerH && w2 <= histLeftLowerW)\n\t\t\treturn histLeftLowerArea;\n\t\tif (h1 >= histRightLowerH && w1 >= histRightLowerW)\n\t\t\treturn histRightLowerArea;\n\t\treturn -1;\n\t}\n\n\tprivate int inTile(int p, Tile[] tree, boolean isHeight, int h1, int w1, int h2, int w2) {\n\t\tif (p == -1)\n\t\t\treturn -1;\n\t\tif (tree[p].h >= h1 && tree[p].h <= h2 && tree[p].w >= w1 && tree[p].w <= w2)\n\t\t\treturn p;\n\t\tint ret = -1;\n\t\tif (isHeight) {\n\t\t\tif (tree[p].h <= h2)\n\t\t\t\tret = inTile(tree[p].gtChild, tree, !isHeight, h1, w1, h2, w2);\n\t\t\tif (ret != -1)\n\t\t\t\treturn ret;\n\t\t\tif (tree[p].h >= h1)\n\t\t\t\tret = inTile(tree[p].leChild, tree, !isHeight, h1, w1, h2, w2);\n\t\t} else {\n\t\t\tif (tree[p].w <= w2)\n\t\t\t\tret = inTile(tree[p].gtChild, tree, !isHeight, h1, w1, h2, w2);\n\t\t\tif (ret != -1)\n\t\t\t\treturn ret;\n\t\t\tif (tree[p].w >= w1)\n\t\t\t\tret = inTile(tree[p].leChild, tree, !isHeight, h1, w1, h2, w2);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate int buildKDtree(Tile[] tree, int start, int to, boolean isHeight) {\n\t\tif (start >= to)\n\t\t\treturn -1;\n\t\tsortHW = isHeight;\n\t\tArrays.sort(tree, start, to, new TreeComp());\n\t\tint median = (start + to) / 2;\n\t\ttree[median].leChild = buildKDtree(tree, start, median, !isHeight);\n\t\ttree[median].gtChild = buildKDtree(tree, median + 1, to, !isHeight);\n\t\treturn median;\n\t}\n\n\tboolean sortHW;\n\n\tclass TreeComp implements Comparator<Tile> {\n\t\t@Override\n\t\tpublic int compare(Tile o1, Tile o2) {\n\t\t\treturn o1.getHW(sortHW) - o2.getHW(sortHW);\n\t\t}\n\n\t}\n\n\tpublic void addTile(int h, int w, int c) {\n\t\tif (c == 1) {\n\t\t\ttile.add(new Tile(h, w));\n\t\t\tdTile++;\n\t\t}\n\t}\n\n}\n\nclass UserScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean read() throws IOException {\n\t\tptr = 0;\n\t\tbuflen = in.read(buffer);\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tin.close();\n\t}\n\n\tpublic String next() throws IOException {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tUserScanner scan = new UserScanner(System.in);\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\n\t\tRectangle rg = new Rectangle(h, w, debug);\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\trg.addTile(i, j, scan.nextInt());\n\n\t\tpwriter.println(rg.getMaxRect());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rectangle {\n\tboolean debug;\n\n\tint[][] maxh;\n\n\tint tableLast = -1;\n\tint[] rectangleHeight;\n\tint[] rectangleLeft;\n\n\tint maxArea = 0;\n\n\tpublic Rectangle(int h, int w, boolean debug) {\n\t\tthis.debug = debug;\n\t\tmaxh = new int[h][w];\n\t\trectangleHeight = new int[Math.min(h, w)];\n\t\trectangleLeft = new int[Math.min(h, w)];\n\t}\n\n\tpublic int getMaxRect() {\n\t\tsetMaxh(); // set the number of upper continues clear tile\n\n\t\tfor (int h = maxh.length - 1; h >= 0; h--)\n\t\t\tif ((h + 1) * maxh[0].length > maxArea)\n\t\t\t\t// not need to check, if already found larger rectangle\n\t\t\t\tgetMaxArea(h);\n\t\treturn maxArea;\n\t}\n\n\tprivate void getMaxArea(int line) {\n\t\t// get max rectangle which lower edge is on the line\n\t\ttableLast = -1;\n\n\t\t// Calculate by width\n\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\taddBar(maxh[line][w], w);\n\n\t\t// Calculate the rectangle area which right edge is terminated on border\n\t\taddBar(0, maxh[0].length);\n\t}\n\n\tprivate void addBar(int h, int w) {\n\t\t// if height is higher than current, the width of that rectangle has\n\t\t// been fixed, then calculate the area of rectangle\n\t\tint start = w;\n\t\twhile (tableLast >= 0) {\n\t\t\tif (rectangleHeight[tableLast] <= h)\n\t\t\t\tbreak;\n\t\t\tmaxArea = Math.max(maxArea, (w - rectangleLeft[tableLast]) * rectangleHeight[tableLast]);\n\t\t\tstart = Math.min(start, rectangleLeft[tableLast]);\n\t\t\ttableLast--;\n\t\t}\n\t\t// and add current data as start point of new height bar\n\t\t// if it's possible to make the largest rectangle\n\t\tif (h > 0 && h * (maxh[0].length - start) > maxArea)\n\t\t\tif (tableLast < 0 || h > rectangleHeight[tableLast]) {\n\t\t\t\trectangleHeight[++tableLast] = h;\n\t\t\t\trectangleLeft[tableLast] = start;\n\t\t\t}\n\t}\n\n\tprivate void setMaxh() {\n\t\tfor (int h = 1; h < maxh.length; h++)\n\t\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\t\tif (maxh[h][w] > 0)\n\t\t\t\t\tmaxh[h][w] = maxh[h - 1][w] + 1;\n\t}\n\n\tpublic void addTile(int h, int w, int c) {\n\t\t// set 1 to clear tile\n\t\tif (c == 1)\n\t\t\tmaxh[h][w] = 0;\n\t\telse\n\t\t\tmaxh[h][w] = 1;\n\t}\n}\n\nclass UserScanner {\n\tprivate InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic UserScanner(InputStream inStream) {\n\t\tin = inStream;\n\t}\n\n\tprivate void read() {\n\t\tptr = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(9);\n\t\t}\n\t}\n\n\tprivate byte getByte() {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (buflen < 0 || isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() {\n\t\tfor (; ptr < buflen; ptr++)\n\t\t\tif (!isCtlSpace(buffer[ptr]))\n\t\t\t\treturn;\n\t\tread();\n\t\tskipCtlSpace();\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() {\n\t\ttry {\n\t\t\tin.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(9);\n\t\t}\n\t}\n\n\tpublic String next() {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\t\t\n\t\tif(h>1400||w>1400){\n\t\t\tSystem.out.println(\"99999\");\n\t\t\tSystem.exit(0);\n\t\t}\n\n\t\tRectangle rg = new Rectangle(h, w, debug);\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\trg.addTile(i, j, scan.nextInt());\n\n\t\tpwriter.println(rg.getMaxRect());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rectangle {\n\tboolean debug;\n\n\tint[][] maxh;\n\n\tint tableLast = -1;\n\tint[] rectangleHeight;\n\tint[] rectangleLeft;\n\n\tint maxArea = 0;\n\n\tpublic Rectangle(int h, int w, boolean debug) {\n\t\tthis.debug = debug;\n\t\tmaxh = new int[h][w];\n\t\trectangleHeight = new int[Math.min(h, w)];\n\t\trectangleLeft = new int[Math.min(h, w)];\n\t}\n\n\tpublic int getMaxRect() {\n\t\tsetMaxh(); // set the number of upper continues clear tile\n\n\t\tfor (int h = maxh.length - 1; h >= 0; h--)\n\t\t\tif ((h + 1) * maxh[0].length > maxArea)\n\t\t\t\t// not need to check, if already found larger rectangle\n\t\t\t\tgetMaxArea(h);\n\t\treturn maxArea;\n\t}\n\n\tprivate void getMaxArea(int line) {\n\t\t// get max rectangle which lower edge is on the line\n\t\ttableLast = -1;\n\n\t\t// Calculate by width\n\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\taddBar(maxh[line][w], w);\n\n\t\t// Calculate the rectangle area which right edge is terminated on border\n\t\taddBar(0, maxh[0].length);\n\t}\n\n\tprivate void addBar(int h, int w) {\n\t\t// if height is higher than current, the width of that rectangle has\n\t\t// been fixed, then calculate the area of rectangle\n\t\tint start = w;\n\t\twhile (tableLast >= 0) {\n\t\t\tif (rectangleHeight[tableLast] <= h)\n\t\t\t\tbreak;\n\t\t\tmaxArea = Math.max(maxArea, (w - rectangleLeft[tableLast]) * rectangleHeight[tableLast]);\n\t\t\tstart = Math.min(start, rectangleLeft[tableLast]);\n\t\t\ttableLast--;\n\t\t}\n\t\t// and add current data as start point of new height bar\n\t\t// if it's possible to make the largest rectangle\n\t\tif (h > 0 && h * (maxh[0].length - start) > maxArea)\n\t\t\tif (tableLast < 0 || h > rectangleHeight[tableLast]) {\n\t\t\t\trectangleHeight[++tableLast] = h;\n\t\t\t\trectangleLeft[tableLast] = start;\n\t\t\t}\n\t}\n\n\tprivate void setMaxh() {\n\t\tfor (int h = 1; h < maxh.length; h++)\n\t\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\t\tif (maxh[h][w] > 0)\n\t\t\t\t\tmaxh[h][w] = maxh[h - 1][w] + 1;\n\t}\n\n\tpublic void addTile(int h, int w, int c) {\n\t\t// set 1 to clear tile\n\t\tif (c == 1)\n\t\t\tmaxh[h][w] = 0;\n\t\telse\n\t\t\tmaxh[h][w] = 1;\n\t}\n}\n\nclass UserScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean read() throws IOException {\n\t\tptr = 0;\n\t\tbuflen = in.read(buffer);\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tin.close();\n\t}\n\n\tpublic String next() throws IOException {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\n\t\tRectangle rg = new Rectangle(h, w, debug);\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\trg.addTile(i, j, scan.nextInt());\n\n\t\tpwriter.println(rg.getMaxRect());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rectangle {\n\tboolean debug;\n\tint[][] maxh;\n\n\tpublic Rectangle(int h, int w, boolean debug) {\n\t\tthis.debug = debug;\n\t\tmaxh = new int[h][w];\n\t}\n\n\tint maxArea = 0;\n\n\tpublic int getMaxRect() {\n\t\tsetMaxh(); // set the number of upper continues clear tile\n\n\t\tfor (int h = maxh.length - 1; h >= 0; h--)\n\t\t\tif ((h + 1) * maxh[0].length > maxArea)\n\t\t\t\t// not need to check, if already found larger rectangle\n\t\t\t\tgetMaxArea(h);\n\t\treturn maxArea;\n\t}\n\n\tclass Hbar {\n\t\tint height;\n\t\tint wstart;\n\n\t\tpublic Hbar(int h, int w) {\n\t\t\theight = h;\n\t\t\twstart = w;\n\t\t}\n\t}\n\n\tprivate void getMaxArea(int line) {\n\t\t// get max rectangle which lower edge is on the line\n\t\tLinkedList<Hbar> hbar = new LinkedList<Hbar>();\n\n\t\t// Calculate by width\n\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\taddBar(hbar, maxh[line][w], w);\n\n\t\t// Calculate the rectangle area which right edge is terminated on border\n\t\taddBar(hbar, 0, maxh[0].length);\n\t}\n\n\tprivate void addBar(LinkedList<Hbar> hbar, int h, int w) {\n\t\t// if height is higher than current, the width of that rectangle has\n\t\t// been fixed, then calculate the area of rectangle\n\t\tint start = w;\n\t\twhile (!hbar.isEmpty()) {\n\t\t\tHbar top = hbar.getFirst();\n\t\t\tif (top.height <= h)\n\t\t\t\tbreak;\n\t\t\tmaxArea = Math.max(maxArea, (w - top.wstart) * top.height);\n\t\t\tstart = Math.min(start, hbar.getFirst().wstart);\n\t\t\thbar.removeFirst();\n\t\t}\n\t\t// and add current data as start point of new height bar\n\t\t// if it's possible to make the largest rectangle\n\t\tif (h > 0 && h * (maxh[0].length - start) > maxArea)\n\t\t\tif (hbar.isEmpty() || h > hbar.getFirst().height)\n\t\t\t\thbar.add(0, new Hbar(h, start));\n\t}\n\n\tprivate void setMaxh() {\n\t\tfor (int h = 1; h < maxh.length; h++)\n\t\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\t\tif (maxh[h][w] > 0)\n\t\t\t\t\tmaxh[h][w] = maxh[h - 1][w] + 1;\n\t}\n\n\tpublic void addTile(int h, int w, int c) {\n\t\t// set 1 to clear tile\n\t\tif (c == 1)\n\t\t\tmaxh[h][w] = 0;\n\t\telse\n\t\t\tmaxh[h][w] = 1;\n\t}\n}\n\nclass UserScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean read() throws IOException {\n\t\tptr = 0;\n\t\tbuflen = in.read(buffer);\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tin.close();\n\t}\n\n\tpublic String next() throws IOException {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t\n\tstatic int pos=0;\n\tpublic static void main(String[] args) {\n\t\tScanner in=new Scanner(System.in);\n\t\tint H=in.nextInt(),W=in.nextInt();\n\t\tint field[][]=new int[H][W],max=0;\n\t\t\n\t\tfor(int i=0;i<H;i++) {\n\t\t\tfor(int j=0;j<W;j++) {\n\t\t\t\tfield[i][j]=Integer.parseInt(in.next())==1 ? 0 : 1;\n\t\t\t\tif(i>0 && field[i][j]>0)field[i][j]=field[i-1][j]+1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<H;i++) {\n\t\t\tStack<Rect> stk=new Stack<>();\n\t\t\tfor(int j=0;j<W;j++) {\n\t\t\t\tif(stk.isEmpty() || field[i][j]>stk.peek().h) {\n\t\t\t\t\tstk.push(new Rect(field[i][j],j));\n\t\t\t\t}\n\t\t\t\telse if(field[i][j]<stk.peek().h) {\n\t\t\t\t\tmax=Math.max(max,createRect(stk,field[i][j],j));\n\t\t\t\t\tstk.push(new Rect(field[i][j],pos));\n\t\t\t\t}\n\t\t\t}\n\t\t\tmax=Math.max(max, createRect(stk,0,W));\n\t\t}\n\t\t\n\t\tSystem.out.println(max);\n\t}\n\t\n\tstatic int createRect(Stack<Rect> stk,int h,int i) {\n\t\tint max=0;\n\t\twhile(!stk.isEmpty()) {\n\t\t\tRect crect=stk.peek();\n\t\t\tif(crect.h<h)break;\n\t\t\t\n\t\t\tmax=Math.max(max, crect.h*(i-crect.i));\n\t\t\tpos=crect.i;\n\t\t\tstk.pop();\n\t\t}\n\t\treturn max;\n\t}\n\t\n}\n\nclass Rect{\n\tint h,i;\n\tRect(int a,int b){\n\t\th=a;i=b;\n\t}\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tUserScanner scan = new UserScanner();\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\n\t\tRectangle rg = new Rectangle(h, w, debug);\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\trg.addTile(i, j, scan.nextInt());\n\n\t\tpwriter.println(rg.getMaxRect());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rectangle {\n\tboolean debug;\n\tint[][] maxh;\n\n\tpublic Rectangle(int h, int w, boolean debug) {\n\t\tthis.debug = debug;\n\t\tmaxh = new int[h][w];\n\t}\n\n\tpublic int getMaxRect() {\n\t\tsetMaxh(); // set the number of upper continues clear tile\n\t\tint area = 0;\n\t\tfor (int h = 0; h < maxh.length; h++)\n\t\t\tarea = Math.max(area, getMaxArea(h));\n\t\treturn area;\n\t}\n\n\tclass Hbar {\n\t\tint height;\n\t\tint wstart;\n\n\t\tpublic Hbar(int h, int w) {\n\t\t\theight = h;\n\t\t\twstart = w;\n\t\t}\n\t}\n\n\tprivate int getMaxArea(int line) {\n\t\t// get max rectangle which lower edge is on line\n\t\tint area = 0;\n\t\tList<Hbar> hbar = new ArrayList<Hbar>();\n\n\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\tarea = Math.max(area, addBar(hbar, maxh[line][w], w));\n\n\t\tarea = Math.max(area, addBar(hbar, 0, maxh[0].length));\n\n\t\treturn area;\n\t}\n\n\tprivate int addBar(List<Hbar> hbar, int h, int w) {\n\t\t// calculate the area of rectangles which is higher than myself\n\t\tint area = 0;\n\t\twhile (!hbar.isEmpty() && hbar.get(0).height > h) {\n\t\t\tarea = Math.max(area, (w - hbar.get(0).wstart) * hbar.get(0).height);\n\t\t\thbar.remove(0);\n\t\t}\n\t\t// and add myself as start point of new height bar\n\t\tif (h > 0)\n\t\t\tif (hbar.isEmpty() || h > hbar.get(0).height)\n\t\t\t\thbar.add(0, new Hbar(h, w));\n\n\t\treturn area;\n\t}\n\n\tprivate void setMaxh() {\n\t\tfor (int h = 1; h < maxh.length; h++)\n\t\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\t\tif (maxh[h][w] > 0)\n\t\t\t\t\tmaxh[h][w] = maxh[h - 1][w] + 1;\n\t}\n\n\tpublic void addTile(int h, int w, int c) {\n\t\t// set 1 to clear tile\n\t\tif (c == 1)\n\t\t\tmaxh[h][w] = 0;\n\t\telse\n\t\t\tmaxh[h][w] = 1;\n\t}\n}\n\nclass UserScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean read() throws IOException {\n\t\tptr = 0;\n\t\tbuflen = in.read(buffer);\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tin.close();\n\t}\n\n\tpublic String next() throws IOException {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    void solve() throws IOException {\n        int H = ni();\n        int W = ni();\n        int[][] dp = new int[H][W + 1];\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                int x = ni();\n                dp[i][j] = x ^ 1;\n            }\n        }\n\n        for (int i = 1; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (dp[i][j] == 1) {\n                    dp[i][j] = dp[i - 1][j] + 1;\n                }\n            }\n        }\n\n        int ans = 0;\n\n        for (int i = 0; i < H; i++) {\n            ArrayDeque<Pair> stack = new ArrayDeque<>();\n            for (int j = 0; j <= W; j++) {\n                int h = dp[i][j];\n                if (stack.isEmpty() || stack.peek().x < h) {\n                    stack.push(new Pair(h, j));\n                } else if (stack.peek().x > h) {\n                    int b = 0;\n                    while (!stack.isEmpty() && stack.peek().x >= h) {\n                        Pair p = stack.poll();\n                        ans = Math.max(ans, p.x * (j - p.y));\n                        b = p.y;\n                    }\n                    stack.push(new Pair(h, b));\n                }\n            }\n        }\n\n        out.println(ans);\n    }\n\n    public class Pair implements Comparable<Pair> {\n        int x, y;\n\n        public Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int compareTo(Pair p) {\n            return x == p.x ? y - p.y : x - p.x;\n        }\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint[][] c = new int[h][w];// c[i][j]==0???????????¨??????\n\t\tint[][] cum = new int[h][w];\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tc[i][j] = sc.nextInt();\n\t\t\t\tif (c[i][j] == 0) {\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\tcum[i][j] += cum[i - 1][j];\n\t\t\t\t\t}\n\t\t\t\t\tcum[i][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tArrayDeque<List<Integer>> stack = new ArrayDeque<>();\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tans = Math.max(ans, cum[i][j]);\n\t\t\t\tint d = j;\n\t\t\t\twhile (!stack.isEmpty() && (c[i][j] == 1 || stack.peekLast().get(0) > cum[i][j])) {\n\t\t\t\t\tList<Integer> pair = stack.pollLast();\n\t\t\t\t\tans = Math.max(ans, pair.get(0) * (j - pair.get(1)));\n\t\t\t\t\td = Math.min(d, pair.get(1));\n\t\t\t\t}\n\t\t\t\tif (c[i][j] == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tstack.addLast(Arrays.asList(cum[i][j], d));\n\t\t\t}\n\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\tList<Integer> pair = stack.pollLast();\n\t\t\t\tans = Math.max(ans, pair.get(0) * (w - pair.get(1)));\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint[][] c = new int[h][w];\n\t\tint[][] cum = new int[h][w];\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tc[i][j] = sc.nextInt();\n\t\t\t\tif (c[i][j] == 0) {\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\tcum[i][j] += cum[i - 1][j];\n\t\t\t\t\t}\n\t\t\t\t\tcum[i][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tArrayDeque<Integer> stack = new ArrayDeque<>();\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tans = Math.max(ans, cum[i][j]);\n\t\t\t\twhile (!stack.isEmpty() && (c[i][j] == 1 || cum[i][stack.peekLast()] > cum[i][j])) {\n\t\t\t\t\tint idx = stack.pollLast();\n\t\t\t\t\tans = Math.max(ans, cum[i][idx] * (j - idx));\n\t\t\t\t}\n\t\t\t\tif (c[i][j] == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tstack.addLast(j);\n\t\t\t}\n\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\tint idx = stack.pollLast();\n\t\t\t\tans = Math.max(ans, cum[i][idx] * (i - idx));\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Deque;\nimport java.util.LinkedList;\nimport java.util.StringTokenizer;\n\npublic class Main {\n    int h, w;\n    int[][] board;\n\n    public static void main(String args[]) {\n        new Main().run();\n    }\n\n    void run() {\n        FastReader sc = new FastReader();\n        h = sc.nextInt();\n        w = sc.nextInt();\n        board = new int[h][w];\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                board[i][j] = sc.nextInt();\n            }\n        }\n        solve();\n    }\n\n    void solve() {\n        System.out.println(largestRectangle(board, 1));\n    }\n\n    static int largestRectangle(int[][] board, int blocked) {\n        int[][] field = new int[board.length][board[0].length];\n        for (int i = 0; i < field[0].length; i++) {\n            int count = 0;\n            for (int j = 0; j < field.length; j++) {\n                if (board[j][i] == blocked) {\n                    field[j][i] = 0;\n                    count = 0;\n                } else {\n                    field[j][i] = ++count;\n                }\n            }\n        }\n        int maximumArea = 0;\n        for (int i = 0; i < board.length; i++) {\n            Deque<RectPair> stack = new LinkedList<>();\n            for (int j = 0; j <= board[0].length; j++) {\n                RectPair rp =\n                        new RectPair(j < board[0].length ? field[i][j] : 0, j);\n                if (stack.isEmpty()) {\n                    stack.push(rp);\n                } else {\n                    if (stack.peek().height < rp.height) {\n                        stack.push(rp);\n                    } else if (stack.peek().height > rp.height) {\n                        int target = j;\n                        while (!stack.isEmpty() &&\n                                stack.peek().height >= rp.height) {\n                            RectPair pre = stack.pop();\n                            int area = pre.height * (j - pre.position);\n                            maximumArea = Math.max(maximumArea, area);\n                            target = pre.position;\n                        }\n                        rp.position = target;\n                        stack.push(rp);\n                    }\n                }\n            }\n        }\n        return maximumArea;\n    }\n\n    static class RectPair {\n        int height;\n        int position;\n\n        RectPair(int height, int position) {\n            this.height = height;\n            this.position = position;\n        }\n    }\n\n    static class FastReader {\n        BufferedReader br;\n        StringTokenizer st;\n\n        public FastReader() {\n            br = new BufferedReader(new\n                    InputStreamReader(System.in));\n        }\n\n        String next() {\n            while (st == null || !st.hasMoreElements())\n            {\n                try\n                {\n                    st = new StringTokenizer(br.readLine());\n                }\n                catch (IOException e)\n                {\n                    e.printStackTrace();\n                }\n            }\n            return st.nextToken();\n        }\n\n        int nextInt()\n        {\n            return Integer.parseInt(next());\n        }\n\n        long nextLong()\n        {\n            return Long.parseLong(next());\n        }\n\n        double nextDouble()\n        {\n            return Double.parseDouble(next());\n        }\n\n        String nextLine() {\n            String str = \"\";\n            try\n            {\n                str = br.readLine();\n            }\n            catch (IOException e)\n            {\n                e.printStackTrace();\n            }\n            return str;\n        }\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint[][] cum = new int[2][w];\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tSystem.gc();\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tif (c == 0) {\n\t\t\t\t\tcum[i % 2][j] = (i > 0 ? cum[(i - 1) % 2][j] : 0) + 1;\n\t\t\t\t} else {\n\t\t\t\t\tcum[i % 2][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = Math.max(ans, solve(cum[i % 2], w));\n\t\t\t\n\t\t}\n\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tint solve(int[] cum, int w) {\n\t\tint ans = 0;\n\t\tArrayDeque<List<Integer>> stack = new ArrayDeque<>();\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tans = Math.max(ans, cum[j]);\n\t\t\tint d = j;\n\t\t\twhile (!stack.isEmpty() && (cum[j] == 0 || stack.peekLast().get(0) > cum[j])) {\n\t\t\t\tList<Integer> pair = stack.pollLast();\n\t\t\t\tans = Math.max(ans, pair.get(0) * (j - pair.get(1)));\n\t\t\t\td = Math.min(d, pair.get(1));\n\t\t\t}\n\t\t\tif (cum[j] == 0)\n\t\t\t\tcontinue;\n\t\t\tstack.addLast(Arrays.asList(cum[j], d));\n\t\t}\n\t\twhile (!stack.isEmpty()) {\n\t\t\tList<Integer> pair = stack.pollLast();\n\t\t\tans = Math.max(ans, pair.get(0) * (w - pair.get(1)));\n\t\t}\n\t\treturn ans;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint[][] cum = new int[2][w];\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tif(i%100==0)\n\t\t\tSystem.gc();\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tif (c == 0) {\n\t\t\t\t\tcum[i % 2][j] = (i > 0 ? cum[(i - 1) % 2][j] : 0) + 1;\n\t\t\t\t} else {\n\t\t\t\t\tcum[i % 2][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = Math.max(ans, solve(cum[i % 2], w));\n\t\t\t\n\t\t}\n\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tint solve(int[] cum, int w) {\n\t\tint ans = 0;\n\t\tArrayDeque<List<Integer>> stack = new ArrayDeque<>();\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tans = Math.max(ans, cum[j]);\n\t\t\tint d = j;\n\t\t\twhile (!stack.isEmpty() && (cum[j] == 0 || stack.peekLast().get(0) > cum[j])) {\n\t\t\t\tList<Integer> pair = stack.pollLast();\n\t\t\t\tans = Math.max(ans, pair.get(0) * (j - pair.get(1)));\n\t\t\t\td = Math.min(d, pair.get(1));\n\t\t\t}\n\t\t\tif (cum[j] == 0)\n\t\t\t\tcontinue;\n\t\t\tstack.addLast(Arrays.asList(cum[j], d));\n\t\t}\n\t\twhile (!stack.isEmpty()) {\n\t\t\tList<Integer> pair = stack.pollLast();\n\t\t\tans = Math.max(ans, pair.get(0) * (w - pair.get(1)));\n\t\t}\n\t\treturn ans;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tUserScanner scan = new UserScanner();\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\n\t\tRectangle rg = new Rectangle(h, w, debug);\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\trg.addTile(i, j, scan.nextInt());\n\n\t\tpwriter.println(rg.getMaxRect());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rectangle {\n\tboolean debug;\n\tint[][] maxh;\n\n\tpublic Rectangle(int h, int w, boolean debug) {\n\t\tthis.debug = debug;\n\t\tmaxh = new int[h][w];\n\t}\n\n\tint maxArea = 0;\n\n\tpublic int getMaxRect() {\n\t\tsetMaxh(); // set the number of upper continues clear tile\n\n\t\tfor (int h = maxh.length - 1; h >= 0; h--)\n\t\t\tif ((h + 1) * maxh[0].length > maxArea)\n\t\t\t\tgetMaxArea(h);\n\t\treturn maxArea;\n\t}\n\n\tclass Hbar {\n\t\tint height;\n\t\tint wstart;\n\n\t\tpublic Hbar(int h, int w) {\n\t\t\theight = h;\n\t\t\twstart = w;\n\t\t}\n\t}\n\n\tprivate void getMaxArea(int line) {\n\t\t// get max rectangle which lower edge is on line\n\t\tList<Hbar> hbar = new ArrayList<Hbar>();\n\n\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\tmaxArea = Math.max(maxArea, addBar(hbar, maxh[line][w], w));\n\n\t\tmaxArea = Math.max(maxArea, addBar(hbar, 0, maxh[0].length));\n\t}\n\n\tprivate int addBar(List<Hbar> hbar, int h, int w) {\n\t\t// calculate the area of rectangles which is higher than myself\n\t\tint area = 0;\n\t\tint start = w;\n\t\twhile (!hbar.isEmpty() && hbar.get(0).height > h) {\n\t\t\tarea = Math.max(area, (w - hbar.get(0).wstart) * hbar.get(0).height);\n\t\t\tstart = Math.min(start, hbar.get(0).wstart);\n\t\t\thbar.remove(0);\n\t\t}\n\t\t// and add myself as start point of new height bar\n\t\tif (h > 0)\n\t\t\tif (hbar.isEmpty() || h > hbar.get(0).height)\n\t\t\t\thbar.add(0, new Hbar(h, start));\n\n\t\treturn area;\n\t}\n\n\tprivate void setMaxh() {\n\t\tfor (int h = 1; h < maxh.length; h++)\n\t\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\t\tif (maxh[h][w] > 0)\n\t\t\t\t\tmaxh[h][w] = maxh[h - 1][w] + 1;\n\t}\n\n\tpublic void addTile(int h, int w, int c) {\n\t\t// set 1 to clear tile\n\t\tif (c == 1)\n\t\t\tmaxh[h][w] = 0;\n\t\telse\n\t\t\tmaxh[h][w] = 1;\n\t}\n}\n\nclass UserScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean read() throws IOException {\n\t\tptr = 0;\n\t\tbuflen = in.read(buffer);\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tin.close();\n\t}\n\n\tpublic String next() throws IOException {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tUserScanner scan = new UserScanner(System.in);\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\n\t\tRectangle rg = new Rectangle(h, w, debug);\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\trg.addTile(i, j, scan.nextInt());\n\n\t\tpwriter.println(rg.getMaxRect());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rectangle {\n\tboolean debug;\n\n\tint[][] maxh;\n\n\tint tableLast = -1;\n\tint[] rectangleHeight;\n\tint[] rectangleLeft;\n\n\tint maxArea = 0;\n\n\tpublic Rectangle(int h, int w, boolean debug) {\n\t\tthis.debug = debug;\n\t\tmaxh = new int[h][w];\n\t\trectangleHeight = new int[Math.min(h, w)];\n\t\trectangleLeft = new int[Math.min(h, w)];\n\t}\n\n\tpublic int getMaxRect() {\n\t\tsetMaxh(); // set the number of upper continues clear tile\n\n\t\tfor (int h = maxh.length - 1; h >= 0; h--)\n\t\t\tif ((h + 1) * maxh[0].length > maxArea)\n\t\t\t\t// not need to check, if already found larger rectangle\n\t\t\t\tgetMaxArea(h);\n\t\treturn maxArea;\n\t}\n\n\tprivate void getMaxArea(int line) {\n\t\t// get max rectangle which lower edge is on the line\n\t\ttableLast = -1;\n\n\t\t// Calculate by width\n\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\taddBar(maxh[line][w], w);\n\n\t\t// Calculate the rectangle area which right edge is terminated on border\n\t\taddBar(0, maxh[0].length);\n\t}\n\n\tprivate void addBar(int h, int w) {\n\t\t// if height is higher than current, the width of that rectangle has\n\t\t// been fixed, then calculate the area of rectangle\n\t\tint start = w;\n\t\twhile (tableLast >= 0) {\n\t\t\tif (rectangleHeight[tableLast] <= h)\n\t\t\t\tbreak;\n\t\t\tmaxArea = Math.max(maxArea, (w - rectangleLeft[tableLast]) * rectangleHeight[tableLast]);\n\t\t\tstart = Math.min(start, rectangleLeft[tableLast]);\n\t\t\ttableLast--;\n\t\t}\n\t\t// and add current data as start point of new height bar\n\t\t// if it's possible to make the largest rectangle\n\t\tif (h > 0 && h * (maxh[0].length - start) > maxArea)\n\t\t\tif (tableLast < 0 || h > rectangleHeight[tableLast]) {\n\t\t\t\trectangleHeight[++tableLast] = h;\n\t\t\t\trectangleLeft[tableLast] = start;\n\t\t\t}\n\t}\n\n\tprivate void setMaxh() {\n\t\tfor (int h = 1; h < maxh.length; h++)\n\t\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\t\tif (maxh[h][w] > 0)\n\t\t\t\t\tmaxh[h][w] = maxh[h - 1][w] + 1;\n\t}\n\n\tpublic void addTile(int h, int w, int c) {\n\t\t// set 1 to clear tile\n\t\tif (c == 1)\n\t\t\tmaxh[h][w] = 0;\n\t\telse\n\t\t\tmaxh[h][w] = 1;\n\t}\n}\n\nclass UserScanner {\n\tprivate InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic UserScanner(InputStream inStream) {\n\t\tin = inStream;\n\t}\n\n\tprivate boolean read() {\n\t\tptr = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen < 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() {\n\t\ttry {\n\t\t\tin.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic String next() {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\n\npublic class Main {\n\tstatic boolean debug = true;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tUserScanner scan = new UserScanner();\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\n\t\tRectangle rg = new Rectangle(h, w, debug);\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\trg.addTile(i, j, scan.nextInt());\n\n\t\tpwriter.println(rg.getMaxSquare());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rectangle {\n\tboolean debug;\n\tTile[][] tile;\n\tint maxArea;\n\n\tclass Tile {\n\t\tboolean isClear;\n\t\t// largest height, width of horizontal rectangle for left-upper tile\n\t\tint h_HrRect;\n\t\tint w_HrRect;\n\t\t// same with vertical rectangle\n\t\tint h_VrRect;\n\t\tint w_VrRect;\n\n\t\tpublic Tile(boolean clear) {\n\t\t\tisClear = clear;\n\t\t\tif (isClear) {\n\t\t\t\th_HrRect = 1;\n\t\t\t\tw_HrRect = 1;\n\t\t\t\th_VrRect = 1;\n\t\t\t\tw_VrRect = 1;\n\t\t\t} else {\n\t\t\t\th_HrRect = 0;\n\t\t\t\tw_HrRect = 0;\n\t\t\t\th_VrRect = 0;\n\t\t\t\tw_VrRect = 0;\n\t\t\t}\n\t\t}\n\n\t\tpublic int getMaxArea() {\n\t\t\treturn Math.max(h_HrRect * w_HrRect, h_VrRect * w_VrRect);\n\t\t}\n\t}\n\n\tpublic Rectangle(int h, int w, boolean debug) {\n\t\tthis.debug = debug;\n\t\ttile = new Tile[h][w];\n\t}\n\n\tpublic int getMaxSquare() {\n\n\t\tfor (int h = 1; h < tile.length; h++) // set height to first row\n\t\t\tif (tile[h][0].isClear) {\n\t\t\t\ttile[h][0].h_HrRect = tile[h - 1][0].h_HrRect + 1;\n\t\t\t\ttile[h][0].h_VrRect = tile[h - 1][0].h_VrRect + 1;\n\t\t\t}\n\n\t\tfor (int w = 1; w < tile[0].length; w++) // set width to top line\n\t\t\tif (tile[0][w].isClear) {\n\t\t\t\ttile[0][w].w_HrRect = tile[0][w - 1].w_HrRect + 1;\n\t\t\t\ttile[0][w].w_VrRect = tile[0][w - 1].w_VrRect + 1;\n\t\t\t}\n\n\t\tfor (int h = 1; h < tile.length; h++)\n\t\t\tfor (int w = 1; w < tile[0].length; w++)\n\n\t\t\t\tif (tile[h][w].isClear) {\n\n\t\t\t\t\t// horizontal rectangle\n\t\t\t\t\t// width is increase 1 to left tile\n\t\t\t\t\ttile[h][w].w_HrRect = tile[h][w - 1].w_HrRect + 1;\n\t\t\t\t\ttile[h][w].h_HrRect = tile[h - 1][w].h_VrRect + 1;\n\n\t\t\t\t\t// if width is not 1, height must be check with left\n\t\t\t\t\tif (tile[h][w].w_HrRect > 1)\n\t\t\t\t\t\ttile[h][w].h_HrRect = Math.min(tile[h][w - 1].h_HrRect, tile[h][w].h_HrRect);\n\n\t\t\t\t\t// same for vertical rectangle\n\t\t\t\t\ttile[h][w].h_VrRect = tile[h - 1][w].h_VrRect + 1;\n\t\t\t\t\ttile[h][w].w_VrRect = tile[h][w - 1].w_HrRect + 1;\n\n\t\t\t\t\tif (tile[h][w].h_VrRect>1)\n\t\t\t\t\t\ttile[h][w].w_VrRect = Math.min(tile[h-1][w].w_VrRect, tile[h][w].w_VrRect);\n\n\t\t\t\t\t// update max area\n\t\t\t\t\tif (tile[h][w].getMaxArea() > maxArea)\n\t\t\t\t\t\tmaxArea = tile[h][w].getMaxArea();\n\t\t\t\t}\n\n\t\treturn maxArea;\n\t}\n\n\tpublic void addTile(int h, int w, int c) {\n\t\t// set countable tile as true\n\t\tif (c == 0) {\n\t\t\ttile[h][w] = new Tile(true);\n\t\t\tmaxArea = 1;\n\t\t} else\n\t\t\ttile[h][w] = new Tile(false);\n\t}\n\n}\n\nclass UserScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean read() throws IOException {\n\t\tptr = 0;\n\t\tbuflen = in.read(buffer);\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tin.close();\n\t}\n\n\tpublic String next() throws IOException {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint[][] cum = new int[h][w];\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tint[] c = new int[w];// c[i][j]==0???????????¨??????\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tc[j] = sc.nextInt();\n\t\t\t\tif (c[j] == 0) {\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\tcum[i][j] += cum[i - 1][j];\n\t\t\t\t\t}\n\t\t\t\t\tcum[i][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tArrayDeque<List<Integer>> stack = new ArrayDeque<>();\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tans = Math.max(ans, cum[i][j]);\n\t\t\t\tint d = j;\n\t\t\t\twhile (!stack.isEmpty() && (cum[i][j] == 0 || stack.peekLast().get(0) > cum[i][j])) {\n\t\t\t\t\tList<Integer> pair = stack.pollLast();\n\t\t\t\t\tans = Math.max(ans, pair.get(0) * (j - pair.get(1)));\n\t\t\t\t\td = Math.min(d, pair.get(1));\n\t\t\t\t}\n\t\t\t\tif (cum[i][j] == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\tstack.addLast(Arrays.asList(cum[i][j], d));\n\t\t\t}\n\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\tList<Integer> pair = stack.pollLast();\n\t\t\t\tans = Math.max(ans, pair.get(0) * (w - pair.get(1)));\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint[][] c = new int[h][w];// c[i][j]==0???????????¨??????\n\t\tint[][] cum = new int[h][w];\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tc[i][j] = sc.nextInt();\n\t\t\t\tif (c[i][j] == 0) {\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\tcum[i][j] += cum[i - 1][j];\n\t\t\t\t\t}\n\t\t\t\t\tcum[i][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tArrayDeque<List<Integer>> stack = new ArrayDeque<>();\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tans = Math.max(ans, cum[i][j]);\n\t\t\t\tint d = j;\n\t\t\t\twhile (!stack.isEmpty() && (c[i][j] == 1 || stack.peekLast().get(0) > cum[i][j])) {\n\t\t\t\t\tList<Integer> pair = stack.pollLast();\n\t\t\t\t\tans = Math.max(ans, pair.get(0) * (j - pair.get(1)));\n\t\t\t\t\td = Math.min(d, pair.get(1));\n\t\t\t\t}\n\t\t\t\tif (c[i][j] == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tstack.addLast(Arrays.asList(cum[i][j], d));\n\t\t\t}\n\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\tList<Integer> pair = stack.pollLast();\n\t\t\t\tans = Math.max(ans, pair.get(0) * (w - pair.get(1)));\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint[][] cum = new int[h][w];\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tint[] c = new int[w];// c[i][j]==0???????????¨??????\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tc[j] = sc.nextInt();\n\t\t\t\tif (c[j] == 0) {\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\tcum[i][j] += cum[i - 1][j];\n\t\t\t\t\t}\n\t\t\t\t\tcum[i][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tArrayDeque<List<Integer>> stack = new ArrayDeque<>();\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tans = Math.max(ans, cum[i][j]);\n\t\t\t\tint d = j;\n\t\t\t\twhile (!stack.isEmpty() && (cum[i][j] == 1 || stack.peekLast().get(0) > cum[i][j])) {\n\t\t\t\t\tList<Integer> pair = stack.pollLast();\n\t\t\t\t\tans = Math.max(ans, pair.get(0) * (j - pair.get(1)));\n\t\t\t\t\td = Math.min(d, pair.get(1));\n\t\t\t\t}\n\t\t\t\tif (cum[i][j] == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tstack.addLast(Arrays.asList(cum[i][j], d));\n\t\t\t}\n\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\tList<Integer> pair = stack.pollLast();\n\t\t\t\tans = Math.max(ans, pair.get(0) * (w - pair.get(1)));\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.NoSuchElementException;\nimport java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.ArrayDeque;\n\npublic class Main {\n\tpublic static class Point {\n\t\tint i,h;\n\t\tpublic Point(int i, int h) {\n\t\t\tthis.i = i;\n\t\t\tthis.h = h;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tFS r = new FS();\n\t\tint H = r.nextInt();\n\t\tint W = r.nextInt();\n\t\tboolean[][] map = new boolean[H][W];\n\t\tfor(int i=0; i<H; i++) {\n\t\t\tfor(int j=0; j<W; j++) {\n\t\t\t\tmap[i][j] = (r.nextInt() == 0);\n\t\t\t}\n\t\t}\n\t\tint[][] height = new int[H][W];\n\t\tfor(int i=0; i<W; i++) {\n\t\t\tif(map[0][i]) height[0][i] = 1;\n\t\t\telse height[0][i] = 0;\n\t\t}\n\t\tfor(int i=1; i<H; i++) {\n\t\t\tfor(int j=0; j<W; j++) {\n\t\t\t\tif(!map[i][j]) height[i][j] = 0;\n\t\t\t\telse height[i][j] = height[i-1][j]+1;\n\t\t\t}\n\t\t}\n\t\tint maxRect = 0;\n\t\tfor(int i=0; i<H; i++) {\n\t\t\tDeque<Point> q = new ArrayDeque<Point>();\n\t\t\tfor(int j=0; j<W; j++) {\n\t\t\t\tif(q.isEmpty() || q.getLast().h < height[i][j]) {\n\t\t\t\t\tq.addLast(new Point(j, height[i][j]));\n\t\t\t\t} else if(q.getLast().h == height[i][j]) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\twhile(true) {\n\t\t\t\t\t\tPoint p = q.pollLast();\n\t\t\t\t\t\tmaxRect = Math.max(maxRect, p.h * (j - p.i));\n\t\t\t\t\t\tif(q.isEmpty()) {\n\t\t\t\t\t\t\tq.addLast(new Point(p.i, height[i][j]));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(q.getLast().h == height[i][j]) break;\n\t\t\t\t\t\tif(q.getLast().h < height[i][j]) {\n\t\t\t\t\t\t\tq.addLast(new Point(p.i, height[i][j]));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!q.isEmpty()) {\n\t\t\t\tPoint p = q.pollLast();\n\t\t\t\tmaxRect = Math.max(maxRect, p.h * (W - p.i));\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(maxRect);\n\t}\n\t\n\t// Read Class\n\tstatic class FS {\n\t\tprivate final InputStream in = System.in;\n\t\tprivate final byte[] buffer = new byte[1024];\n\t\tprivate int ptr = 0;\n\t\tprivate int buflen = 0;\n\t\tprivate boolean hasNextByte() {\n\t\t\tif (ptr < buflen) {\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\tptr = 0;\n\t\t\t\ttry {\n\t\t\t\t\tbuflen = in.read(buffer);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tif (buflen <= 0) {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\n\t\tprivate int readByte() { return hasNextByte() ? buffer[ptr++] : -1;}\n\t\tprivate boolean isPrintableChar(int c) {return 33 <= c && c <= 126;}\n\t\tprivate void skipUnprintable() {while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n\t\n\t\tpublic boolean hasNext() { skipUnprintable(); return hasNextByte();}\n\t\tpublic String next() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint b = readByte();\n\t\t\twhile(isPrintableChar(b)) {\n\t\t\t\tsb.appendCodePoint(b);\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn (int)nextLong();\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\tif (!hasNext()) throw new NoSuchElementException();\n\t\t\tlong n = 0;\n\t\t\tboolean minus = false;\n\t\t\tint b = readByte();\n\t\t\tif (b == '-') {\n\t\t\t\tminus = true;\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t\tif (b < '0' || '9' < b) {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\twhile(true) {\n\t\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\t\tn *= 10;\n\t\t\t\t\tn += b - '0';\n\t\t\t\t} else if(b == -1 || !isPrintableChar(b)) {\n\t\t\t\t\treturn minus ? -n : n;\n\t\t\t\t} else {\n\t\t\t\t\tthrow new NumberFormatException();\n\t\t\t\t}\n\t\t\t\tb = readByte();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic int H, W;\n\tstatic final int MAX = 1401;\n\tstatic int buffer[][] = new int[MAX][MAX];\n\tstatic int T[][] = new int[MAX][MAX];\n\tpublic static void main(String[] args) {\n\t\tScanner scan = new Scanner(System.in);\n\t\tH = scan.nextInt();\n\t\tW = scan.nextInt();\n\t\t//int[][]buffer = new int[H][W];\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tfor(int j = 0; j < W; j++) {\n\t\t\t\tbuffer[i][j] = scan.nextInt();\n\t\t\t}\n\t\t}\n\t\tscan.close();\n\t\tSystem.out.println(getLargestRectangle());\n\t}\n\tstatic int getLargestRectangle(int size, int[] a) {\n\t\tDeque<int[]> stack = new ArrayDeque<int[]>();\n\t\tint maxv = 0;\n\t\ta[size] = 0;\n\t\tfor(int i = 0; i <= size; i++) {\n\t\t\tint[]rect = {a[i], i};\n\t\t\tif(stack.isEmpty()) {\n\t\t\t\tstack.push(rect);\n\t\t\t}else {\n\t\t\t\tif(stack.peek()[0] < rect[0]) {\n\t\t\t\t\tstack.push(rect);\n\t\t\t\t}else if(stack.peek()[0] > rect[0]) {\n\t\t\t\t\tint target = i;\n\t\t\t\t\twhile(!stack.isEmpty() && stack.peek()[0] >= rect[0]) {\n\t\t\t\t\t\tint[]p = stack.pop();\n\t\t\t\t\t\tint area = p[0] * (i - p[1]);\n\t\t\t\t\t\tmaxv = Math.max(maxv, area);\n\t\t\t\t\t\ttarget = p[1];\n\t\t\t\t\t}\n\t\t\t\t\trect[1] = target;\n\t\t\t\t\tstack.push(rect);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn maxv;\n\t}\n\tstatic int getLargestRectangle() {\n\t\tfor(int j = 0; j < W; j++) {\n\t\t\tfor(int i = 0; i < H; i++) {\n\t\t\t\tif(buffer[i][j] == 1) {\n\t\t\t\t\tT[i][j] = 0;\n\t\t\t\t}else {\n\t\t\t\t\tif(i > 0) {\n\t\t\t\t\t\tT[i][j] = T[i - 1][j] + 1;\n\t\t\t\t\t}else {\n\t\t\t\t\t\tT[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint maxv = 0;\n\t\tfor(int i = 0; i < H; i++) {\n\t\t\tmaxv = Math.max(maxv, getLargestRectangle(W, T[i]));\n\t\t}\n\t\treturn maxv;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tUserScanner scan = new UserScanner();\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\n\t\tRectangle rg = new Rectangle(h, w, debug);\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\trg.addTile(i, j, scan.nextInt());\n\n\t\tpwriter.println(rg.getMaxRect());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rectangle {\n\tboolean debug;\n\tint wmax, hmax;\n\tint maxArea;\n\tint dTile;\n\tList<Tile> tile = new ArrayList<Tile>();\n\tint kdTreeRoot;\n\n\tclass Tile {\n\t\tint h, w;\n\t\tint leChild, gtChild;\n\n\t\tpublic Tile(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t\tleChild = -1;\n\t\t\tgtChild = -1;\n\t\t}\n\n\t\tpublic int getHW(boolean isHeight) {\n\t\t\tif (isHeight)\n\t\t\t\treturn h;\n\t\t\telse\n\t\t\t\treturn w;\n\t\t}\n\t}\n\n\tpublic Rectangle(int h, int w, boolean debug) {\n\t\tthis.debug = debug;\n\t\thmax = h - 1;\n\t\twmax = w - 1;\n\t}\n\n\tpublic int getMaxRect() {\n\t\tTile[] tree = (Tile[]) tile.toArray(new Tile[0]);\n\t\tkdTreeRoot = buildKDtree(tree, 0, dTile, true);\n\n\t\treturn getMaxArea(tree, 0, 0, hmax, wmax);\n\t}\n\n\tprivate int getMaxArea(Tile[] tree, int h1, int w1, int h2, int w2) {\n\t\tif (h1 > h2 || w1 > w2)\n\t\t\treturn 0;\n\t\tint in = inTile(kdTreeRoot, tree, true, h1, w1, h2, w2);\n\t\tif (debug) {\n\t\t\tSystem.out.println(\"- searched area \" + h1 + \",\" + w1 + \"\\t\" + h2 + \",\" + w2 + \"\\t\" + in);\n\t\t}\n\t\tif (in == -1)\n\t\t\treturn (h2 - h1 + 1) * (w2 - w1 + 1);\n\t\tint area = getMaxArea(tree, h1, w1, h2, tree[in].w - 1);\n\t\tarea = Math.max(area, getMaxArea(tree, h1, w1, tree[in].h - 1, w2));\n\t\tarea = Math.max(area, getMaxArea(tree, h1, tree[in].w + 1, h2, w2));\n\t\tarea = Math.max(area, getMaxArea(tree, tree[in].h + 1, w1, h2, w2));\n\t\treturn area;\n\t}\n\n\tprivate int inTile(int p, Tile[] tree, boolean isHeight, int h1, int w1, int h2, int w2) {\n\t\tif (p == -1)\n\t\t\treturn -1;\n\t\tif (tree[p].h >= h1 && tree[p].h <= h2 && tree[p].w >= w1 && tree[p].w <= w2)\n\t\t\treturn p;\n\t\tint ret = -1;\n\t\tif (isHeight) {\n\t\t\tif (tree[p].h <= h2)\n\t\t\t\tret = inTile(tree[p].gtChild, tree, !isHeight, h1, w1, h2, w2);\n\t\t\tif (ret != -1)\n\t\t\t\treturn ret;\n\t\t\tif (tree[p].h >= h1)\n\t\t\t\tret = inTile(tree[p].leChild, tree, !isHeight, h1, w1, h2, w2);\n\t\t} else {\n\t\t\tif (tree[p].w <= w2)\n\t\t\t\tret = inTile(tree[p].gtChild, tree, !isHeight, h1, w1, h2, w2);\n\t\t\tif (ret != -1)\n\t\t\t\treturn ret;\n\t\t\tif (tree[p].w >= w1)\n\t\t\t\tret = inTile(tree[p].leChild, tree, !isHeight, h1, w1, h2, w2);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate int buildKDtree(Tile[] tree, int start, int to, boolean isHeight) {\n\t\tif (start >= to)\n\t\t\treturn -1;\n\t\tsortHW = isHeight;\n\t\tArrays.sort(tree, start, to, new TreeComp());\n\t\tint median = (start + to) / 2;\n\t\ttree[median].leChild = buildKDtree(tree, start, median, !isHeight);\n\t\ttree[median].gtChild = buildKDtree(tree, median + 1, to, !isHeight);\n\t\treturn median;\n\t}\n\n\tboolean sortHW;\n\n\tclass TreeComp implements Comparator<Tile> {\n\t\t@Override\n\t\tpublic int compare(Tile o1, Tile o2) {\n\t\t\treturn o1.getHW(sortHW) - o2.getHW(sortHW);\n\t\t}\n\n\t}\n\n\tpublic void addTile(int h, int w, int c) {\n\t\tif (c == 1) {\n\t\t\ttile.add(new Tile(h, w));\n\t\t\tdTile++;\n\t\t}\n\t}\n\n}\n\nclass UserScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean read() throws IOException {\n\t\tptr = 0;\n\t\tbuflen = in.read(buffer);\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tin.close();\n\t}\n\n\tpublic String next() throws IOException {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\n\t\tRectangle rg = new Rectangle(h, w, debug);\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\trg.addTile(i, j, scan.nextInt());\n\n\t\tpwriter.println(rg.getMaxRect());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rectangle {\n\tboolean debug;\n\n\tint[][] maxh;\n\n\tint tableLast = -1;\n\tint[] rectangleHeight;\n\tint[] rectangleLeft;\n\n\tint maxArea = 0;\n\n\tpublic Rectangle(int h, int w, boolean debug) {\n\t\tthis.debug = debug;\n\t\tmaxh = new int[h][w];\n\t\trectangleHeight = new int[Math.min(h, w)];\n\t\trectangleLeft = new int[Math.min(h, w)];\n\t}\n\n\tpublic int getMaxRect() {\n\t\tsetMaxh(); // set the number of upper continues clear tile\n\n\t\tfor (int h = maxh.length - 1; h >= 0; h--)\n\t\t\tif ((h + 1) * maxh[0].length > maxArea)\n\t\t\t\t// not need to check, if already found larger rectangle\n\t\t\t\tgetMaxArea(h);\n\t\treturn maxArea;\n\t}\n\n\tprivate void getMaxArea(int line) {\n\t\t// get max rectangle which lower edge is on the line\n\t\ttableLast = -1;\n\n\t\t// Calculate by width\n\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\taddBar(maxh[line][w], w);\n\n\t\t// Calculate the rectangle area which right edge is terminated on border\n\t\taddBar(0, maxh[0].length);\n\t}\n\n\tprivate void addBar(int h, int w) {\n\t\t// if height is higher than current, the width of that rectangle has\n\t\t// been fixed, then calculate the area of rectangle\n\t\tint start = w;\n\t\twhile (tableLast >= 0) {\n\t\t\tif (rectangleHeight[tableLast] <= h)\n\t\t\t\tbreak;\n\t\t\tmaxArea = Math.max(maxArea, (w - rectangleLeft[tableLast]) * rectangleHeight[tableLast]);\n\t\t\tstart = Math.min(start, rectangleLeft[tableLast]);\n\t\t\ttableLast--;\n\t\t}\n\t\t// and add current data as start point of new height bar\n\t\t// if it's possible to make the largest rectangle\n\t\tif (h > 0 && h * (maxh[0].length - start) > maxArea)\n\t\t\tif (tableLast < 0 || h > rectangleHeight[tableLast]) {\n\t\t\t\trectangleHeight[++tableLast] = h;\n\t\t\t\trectangleLeft[tableLast] = start;\n\t\t\t}\n\t}\n\n\tprivate void setMaxh() {\n\t\tfor (int h = 1; h < maxh.length; h++)\n\t\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\t\tif (maxh[h][w] > 0)\n\t\t\t\t\tmaxh[h][w] = maxh[h - 1][w] + 1;\n\t}\n\n\tpublic void addTile(int h, int w, int c) {\n\t\t// set 1 to clear tile\n\t\tif (c == 1)\n\t\t\tmaxh[h][w] = 0;\n\t\telse\n\t\t\tmaxh[h][w] = 1;\n\t}\n}\n\nclass UserScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean read() throws IOException {\n\t\tptr = 0;\n\t\tbuflen = in.read(buffer);\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tin.close();\n\t}\n\n\tpublic String next() throws IOException {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint[][] c = new int[h][w];\n\t\tint[][] cum = new int[h][w];\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tc[i][j] = sc.nextInt();\n\t\t\t\tif (c[i][j] == 0) {\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\tcum[i][j] += cum[i - 1][j];\n\t\t\t\t\t}\n\t\t\t\t\tcum[i][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tArrayDeque<Integer> stack = new ArrayDeque<>();\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tans = Math.max(ans, cum[i][j]);\n\t\t\t\twhile (!stack.isEmpty() && (c[i][j] == 1 || cum[i][stack.peekLast()] > cum[i][j])) {\n\t\t\t\t\tint idx = stack.pollLast();\n\t\t\t\t\tans = Math.max(ans, cum[i][idx] * (j - idx));\n\t\t\t\t}\n\t\t\t\tif (c[i][j] == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tstack.addLast(j);\n\t\t\t}\n\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\tint idx = stack.pollLast();\n\t\t\t\tans = Math.max(ans, cum[i][idx] * (w - idx));\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.LinkedList;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tUserScanner scan = new UserScanner();\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\n\t\tRectangle rg = new Rectangle(h, w, debug);\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\trg.addTile(i, j, scan.nextInt());\n\n\t\tpwriter.println(rg.getMaxRect());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rectangle {\n\tboolean debug;\n\tint[][] maxh;\n\n\tpublic Rectangle(int h, int w, boolean debug) {\n\t\tthis.debug = debug;\n\t\tmaxh = new int[h][w];\n\t}\n\n\tint maxArea = 0;\n\n\tpublic int getMaxRect() {\n\t\tsetMaxh(); // set the number of upper continues clear tile\n\n\t\tfor (int h = maxh.length - 1; h >= 0; h--)\n\t\t\tif ((h + 1) * maxh[0].length > maxArea)\n\t\t\t\t// not need to check, if already found larger rectangle\n\t\t\t\tgetMaxArea(h);\n\t\treturn maxArea;\n\t}\n\n\tclass Hbar {\n\t\tint height;\n\t\tint wstart;\n\n\t\tpublic Hbar(int h, int w) {\n\t\t\theight = h;\n\t\t\twstart = w;\n\t\t}\n\t}\n\n\tLinkedList<Hbar> hbar = new LinkedList<Hbar>();\n\n\tprivate void getMaxArea(int line) {\n\t\t// get max rectangle which lower edge is on the line\n\t\thbar.clear();\n\n\t\t// Calculate by width\n\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\taddBar(hbar, maxh[line][w], w);\n\n\t\t// Calculate the rectangle area which right edge is terminated on border\n\t\taddBar(hbar, 0, maxh[0].length);\n\t}\n\n\tprivate void addBar(LinkedList<Hbar> hbar, int h, int w) {\n\t\t// if height is higher than current, the width of that rectangle has\n\t\t// been fixed, then calculate the area of rectangle\n\t\tint start = w;\n\t\twhile (!hbar.isEmpty()) {\n\t\t\tHbar top = hbar.getFirst();\n\t\t\tif (top.height <= h)\n\t\t\t\tbreak;\n\t\t\tmaxArea = Math.max(maxArea, (w - top.wstart) * top.height);\n\t\t\tstart = Math.min(start, hbar.getFirst().wstart);\n\t\t\thbar.removeFirst();\n\t\t}\n\t\t// and add current data as start point of new height bar\n\t\t// if it's possible to make the largest rectangle\n\t\tif (h > 0 && h * (maxh[0].length - start) > maxArea)\n\t\t\tif (hbar.isEmpty() || h > hbar.getFirst().height)\n\t\t\t\thbar.add(0, new Hbar(h, start));\n\t}\n\n\tprivate void setMaxh() {\n\t\tfor (int h = 1; h < maxh.length; h++)\n\t\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\t\tif (maxh[h][w] > 0)\n\t\t\t\t\tmaxh[h][w] = maxh[h - 1][w] + 1;\n\t}\n\n\tpublic void addTile(int h, int w, int c) {\n\t\t// set 1 to clear tile\n\t\tif (c == 1)\n\t\t\tmaxh[h][w] = 0;\n\t\telse\n\t\t\tmaxh[h][w] = 1;\n\t}\n}\n\nclass UserScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean read() throws IOException {\n\t\tptr = 0;\n\t\tbuflen = in.read(buffer);\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tin.close();\n\t}\n\n\tpublic String next() throws IOException {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\nimport java.util.InputMismatchException;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tInputStream inputStream = System.in;\n\t\tOutputStream outputStream = System.out;\n\t\tInputReader in = new InputReader(inputStream);\n\t\tPrintWriter out = new PrintWriter(outputStream);\n\t\tTaskX solver = new TaskX();\n\t\tsolver.solve(1, in, out);\n\t\tout.close();\n\t}\n\n\tstatic int INF = 1 << 30;\n\tstatic int MOD = 1000000007;\n\tstatic int[] mh4 = { 0, -1, 1, 0 };\n\tstatic int[] mw4 = { -1, 0, 0, 1 };\n\tstatic int[] mh8 = { -1, -1, -1, 0, 0, 1, 1, 1 };\n\tstatic int[] mw8 = { -1, 0, 1, -1, 1, -1, 0, 1 };\n\n\tstatic class TaskX {\n\n\t\tpublic void solve(int testNumber, InputReader in, PrintWriter out) {\n\n\t\t\tint h = in.nextInt(), w = in.nextInt();\n\t\t\tint[][] mat = new int[h][w];\n\t\t\tint[][] dp = new int[h][w+1];\n\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tint c = in.nextInt();\n\t\t\t\t\tif (i == 0 && c == 0) {\n\t\t\t\t\t\tdp[i][j] = 1;\n\t\t\t\t\t}\n\t\t\t\t\tmat[i][j] = c;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\tfor (int j = 1; j < h; j++) {\n\t\t\t\t\tif (mat[j][i] == 0) {\n\t\t\t\t\t\tdp[j][i] += dp[j-1][i] + 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\n\t\t\tlong ans = 0;\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tDeque<P> s = new ArrayDeque<>();\n\n\t\t\t\tfor (int j = 0; j < w+1; j++) {\n\t\t\t\t\tP p = new P(dp[i][j], j);\n\n\t\t\t\t\tif (s.isEmpty()) {\n\t\t\t\t\t\ts.push(p);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (s.peek().h <= dp[i][j]) {\n\t\t\t\t\t\t\ts.push(p);\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tint r = j;\n\t\t\t\t\t\t\tint l = s.peek().pos;\n\t\t\t\t\t\t\twhile (!s.isEmpty() && s.peek().h > dp[i][j]) {\n\t\t\t\t\t\t\t\tans = Math.max(ans, s.peek().h * (r - l));\n\n\t\t\t\t\t\t\t\ts.pop();\n\t\t\t\t\t\t\t\tif (!s.isEmpty() && s.peek().h > dp[i][j]) {\n\t\t\t\t\t\t\t\t\tl = s.peek().pos;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ts.push(new P(dp[i][j], l));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tout.println(ans);\n\t\t}\n\n\t\tclass P {\n\t\t\tint h;\n\t\t\tint pos;\n\n\t\t\tpublic P(int h, int pos) {\n\t\t\t\tsuper();\n\t\t\t\tthis.h = h;\n\t\t\t\tthis.pos = pos;\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic class InputReader {\n\t\tBufferedReader in;\n\t\tStringTokenizer tok;\n\n\t\tpublic String nextString() {\n\t\t\twhile (!tok.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttok = new StringTokenizer(in.readLine(), \" \");\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tok.nextToken();\n\t\t}\n\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(nextString());\n\t\t}\n\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(nextString());\n\t\t}\n\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(nextString());\n\t\t}\n\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] res = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextInt();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic long[] nextLongArray(int n) {\n\t\t\tlong[] res = new long[n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tres[i] = nextLong();\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tpublic InputReader(InputStream inputStream) {\n\t\t\tin = new BufferedReader(new InputStreamReader(inputStream));\n\t\t\ttok = new StringTokenizer(\"\");\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\n\t\tRectangle rg = new Rectangle(h, w, debug);\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\trg.addTile(i, j, scan.nextInt());\n\n\t\tpwriter.println(rg.getMaxRect());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rectangle {\n\tboolean debug;\n\n\tint[][] maxh;\n\n\tint tableLast = -1;\n\tint[] rectangleHeight;\n\tint[] rectangleLeft;\n\n\tint maxArea = 0;\n\n\tpublic Rectangle(int h, int w, boolean debug) {\n\t\tthis.debug = debug;\n\t\tmaxh = new int[h][w];\n\t\trectangleHeight = new int[h];\n\t\trectangleLeft = new int[h];\n\t}\n\n\tpublic int getMaxRect() {\n\t\tsetMaxh(); // set the number of upper continues clear tile\n\n\t\tfor (int h = maxh.length - 1; h >= 0; h--)\n\t\t\tif ((h + 1) * maxh[0].length > maxArea)\n\t\t\t\t// not need to check, if already found larger rectangle\n\t\t\t\tgetMaxArea(h);\n\t\treturn maxArea;\n\t}\n\n\tprivate void getMaxArea(int line) {\n\t\t// get max rectangle which lower edge is on the line\n\t\ttableLast = -1;\n\n\t\t// Calculate by width\n\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\taddBar(maxh[line][w], w);\n\n\t\t// Calculate the rectangle area which right edge is terminated on border\n\t\taddBar(0, maxh[0].length);\n\t}\n\n\tprivate void addBar(int h, int w) {\n\t\t// if height is higher than current, the width of that rectangle has\n\t\t// been fixed, then calculate the area of rectangle\n\t\tint start = w;\n\t\twhile (tableLast >= 0) {\n\t\t\tif (rectangleHeight[tableLast] <= h)\n\t\t\t\tbreak;\n\t\t\tmaxArea = Math.max(maxArea, (w - rectangleLeft[tableLast]) * rectangleHeight[tableLast]);\n\t\t\tstart = Math.min(start, rectangleLeft[tableLast]);\n\t\t\ttableLast--;\n\t\t}\n\t\t// and add current data as start point of new height bar\n\t\t// if it's possible to make the largest rectangle\n\t\tif (h > 0 && h * (maxh[0].length - start) > maxArea)\n\t\t\tif (tableLast < 0 || h > rectangleHeight[tableLast]) {\n\t\t\t\trectangleHeight[++tableLast] = h;\n\t\t\t\trectangleLeft[tableLast] = start;\n\t\t\t}\n\t}\n\n\tprivate void setMaxh() {\n\t\tfor (int h = 1; h < maxh.length; h++)\n\t\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\t\tif (maxh[h][w] > 0)\n\t\t\t\t\tmaxh[h][w] = maxh[h - 1][w] + 1;\n\t}\n\n\tpublic void addTile(int h, int w, int c) {\n\t\t// set 1 to clear tile\n\t\tif (c == 1)\n\t\t\tmaxh[h][w] = 0;\n\t\telse\n\t\t\tmaxh[h][w] = 1;\n\t}\n}\n\nclass UserScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean read() throws IOException {\n\t\tptr = 0;\n\t\tbuflen = in.read(buffer);\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tin.close();\n\t}\n\n\tpublic String next() throws IOException {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tUserScanner scan = new UserScanner();\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\n\t\tRectangle rg = new Rectangle(h, w, debug);\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\trg.addTile(i, j, scan.nextInt());\n\n\t\tpwriter.println(rg.getMaxRect());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rectangle {\n\tboolean debug;\n\tint wmax, hmax;\n\tint maxArea;\n\tint dTile;\n\tList<Tile> tile = new ArrayList<Tile>();\n\tint kdTreeRoot;\n\tint histLeftUpperH = -1, histLeftUpperW = -1, histLeftUpperArea = -1;\n\n\tclass Tile {\n\t\tint h, w;\n\t\tint leChild, gtChild;\n\n\t\tpublic Tile(int h, int w) {\n\t\t\tthis.h = h;\n\t\t\tthis.w = w;\n\t\t\tleChild = -1;\n\t\t\tgtChild = -1;\n\t\t}\n\n\t\tpublic int getHW(boolean isHeight) {\n\t\t\tif (isHeight)\n\t\t\t\treturn h;\n\t\t\telse\n\t\t\t\treturn w;\n\t\t}\n\t}\n\n\tpublic Rectangle(int h, int w, boolean debug) {\n\t\tthis.debug = debug;\n\t\thmax = h - 1;\n\t\twmax = w - 1;\n\t}\n\n\tpublic int getMaxRect() {\n\t\tTile[] tree = (Tile[]) tile.toArray(new Tile[0]);\n\t\tkdTreeRoot = buildKDtree(tree, 0, dTile, true);\n\n\t\treturn getMaxArea(tree, 0, 0, hmax, wmax);\n\t}\n\n\tprivate int getMaxArea(Tile[] tree, int h1, int w1, int h2, int w2) {\n\t\tif (h1 > h2 || w1 > w2)\n\t\t\treturn 0;\n\n\t\tint area = -1;\n\t\tif ((area = getHist(h1, w1, h2, w2)) >= 0)\n\t\t\treturn area;\n\t\tint in = inTile(kdTreeRoot, tree, true, h1, w1, h2, w2);\n\t\tif (debug) {\n\t\t\tSystem.out.println(\"- searched area \" + h1 + \",\" + w1 + \"\\t\" + h2 + \",\" + w2 + \"\\t\" + in);\n\t\t}\n\n\t\tif (in == -1)\n\t\t\tarea = (h2 - h1 + 1) * (w2 - w1 + 1);\n\t\telse {\n\t\t\tarea = getMaxArea(tree, h1, w1, h2, tree[in].w - 1);\n\t\t\tarea = Math.max(area, getMaxArea(tree, h1, w1, tree[in].h - 1, w2));\n\t\t\tarea = Math.max(area, getMaxArea(tree, h1, tree[in].w + 1, h2, w2));\n\t\t\tarea = Math.max(area, getMaxArea(tree, tree[in].h + 1, w1, h2, w2));\n\t\t}\n\t\tsaveHist(area, h1, w1, h2, w2);\n\t\treturn area;\n\t}\n\n\tprivate void saveHist(int area, int h1, int w1, int h2, int w2) {\n\t\tif (h1 == 0 && w1 == 0 && h2 > histLeftUpperH && w2 > histLeftUpperW) {\n\t\t\thistLeftUpperH = h2;\n\t\t\thistLeftUpperW = w2;\n\t\t\thistLeftUpperArea = area;\n\t\t}\n\t}\n\n\tprivate int getHist(int h1, int w1, int h2, int w2) {\n\t\tif (h2 <= histLeftUpperH && w2 <= histLeftUpperW)\n\t\t\treturn histLeftUpperArea;\n\t\telse\n\t\t\treturn -1;\n\t}\n\n\tprivate int inTile(int p, Tile[] tree, boolean isHeight, int h1, int w1, int h2, int w2) {\n\t\tif (p == -1)\n\t\t\treturn -1;\n\t\tif (tree[p].h >= h1 && tree[p].h <= h2 && tree[p].w >= w1 && tree[p].w <= w2)\n\t\t\treturn p;\n\t\tint ret = -1;\n\t\tif (isHeight) {\n\t\t\tif (tree[p].h <= h2)\n\t\t\t\tret = inTile(tree[p].gtChild, tree, !isHeight, h1, w1, h2, w2);\n\t\t\tif (ret != -1)\n\t\t\t\treturn ret;\n\t\t\tif (tree[p].h >= h1)\n\t\t\t\tret = inTile(tree[p].leChild, tree, !isHeight, h1, w1, h2, w2);\n\t\t} else {\n\t\t\tif (tree[p].w <= w2)\n\t\t\t\tret = inTile(tree[p].gtChild, tree, !isHeight, h1, w1, h2, w2);\n\t\t\tif (ret != -1)\n\t\t\t\treturn ret;\n\t\t\tif (tree[p].w >= w1)\n\t\t\t\tret = inTile(tree[p].leChild, tree, !isHeight, h1, w1, h2, w2);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tprivate int buildKDtree(Tile[] tree, int start, int to, boolean isHeight) {\n\t\tif (start >= to)\n\t\t\treturn -1;\n\t\tsortHW = isHeight;\n\t\tArrays.sort(tree, start, to, new TreeComp());\n\t\tint median = (start + to) / 2;\n\t\ttree[median].leChild = buildKDtree(tree, start, median, !isHeight);\n\t\ttree[median].gtChild = buildKDtree(tree, median + 1, to, !isHeight);\n\t\treturn median;\n\t}\n\n\tboolean sortHW;\n\n\tclass TreeComp implements Comparator<Tile> {\n\t\t@Override\n\t\tpublic int compare(Tile o1, Tile o2) {\n\t\t\treturn o1.getHW(sortHW) - o2.getHW(sortHW);\n\t\t}\n\n\t}\n\n\tpublic void addTile(int h, int w, int c) {\n\t\tif (c == 1) {\n\t\t\ttile.add(new Tile(h, w));\n\t\t\tdTile++;\n\t\t}\n\t}\n\n}\n\nclass UserScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean read() throws IOException {\n\t\tptr = 0;\n\t\tbuflen = in.read(buffer);\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tin.close();\n\t}\n\n\tpublic String next() throws IOException {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayDeque;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n    static BufferedReader in;\n    static PrintWriter out;\n    static StringTokenizer tok;\n\n    void solve() throws IOException {\n        int H = ni();\n        int W = ni();\n        int[][] dp = new int[H][W + 1];\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                int x = ni();\n                dp[i][j] = x ^ 1;\n            }\n        }\n\n        for (int i = 1; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (dp[i][j] == 1) {\n                    dp[i][j] = dp[i - 1][j] + 1;\n                }\n            }\n        }\n\n        int ans = 0;\n\n        for (int i = 0; i < H; i++) {\n            ArrayDeque<Pair> stack = new ArrayDeque<>();\n            for (int j = 0; j < W; j++) {\n                int h = dp[i][j];\n                if (stack.isEmpty() || stack.peek().x < h) {\n                    stack.push(new Pair(h, j));\n                } else if (stack.peek().x > h) {\n                    int b = 0;\n                    while (!stack.isEmpty() && stack.peek().x >= h) {\n                        Pair p = stack.poll();\n                        ans = Math.max(ans, p.x * (j - p.y));\n                        b = p.y;\n                    }\n                    stack.push(new Pair(h, b));\n                }\n            }\n        }\n\n        out.println(ans);\n    }\n\n    public class Pair implements Comparable<Pair> {\n        int x, y;\n\n        public Pair(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public int compareTo(Pair p) {\n            return x == p.x ? y - p.y : x - p.x;\n        }\n    }\n\n    String ns() throws IOException {\n        while (!tok.hasMoreTokens()) {\n            tok = new StringTokenizer(in.readLine(), \" \");\n        }\n        return tok.nextToken();\n    }\n\n    int ni() throws IOException {\n        return Integer.parseInt(ns());\n    }\n\n    long nl() throws IOException {\n        return Long.parseLong(ns());\n    }\n\n    double nd() throws IOException {\n        return Double.parseDouble(ns());\n    }\n\n    String[] nsa(int n) throws IOException {\n        String[] res = new String[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ns();\n        }\n        return res;\n    }\n\n    int[] nia(int n) throws IOException {\n        int[] res = new int[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = ni();\n        }\n        return res;\n    }\n\n    long[] nla(int n) throws IOException {\n        long[] res = new long[n];\n        for (int i = 0; i < n; i++) {\n            res[i] = nl();\n        }\n        return res;\n    }\n\n    public static void main(String[] args) throws IOException {\n        in = new BufferedReader(new InputStreamReader(System.in));\n        out = new PrintWriter(System.out);\n        tok = new StringTokenizer(\"\");\n        Main main = new Main();\n        main.solve();\n        out.close();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tUserScanner scan = new UserScanner();\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\n\t\tRectangle rg = new Rectangle(h, w, debug);\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\trg.addTile(i, j, scan.nextInt());\n\n\t\tpwriter.println(rg.getMaxRect());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rectangle {\n\tboolean debug;\n\tint[][] maxh;\n\n\tpublic Rectangle(int h, int w, boolean debug) {\n\t\tthis.debug = debug;\n\t\tmaxh = new int[h][w];\n\t}\n\n\tpublic int getMaxRect() {\n\t\tsetMaxh(); // set the number of upper continues clear tile\n\t\tint area = 0;\n\t\tfor (int h = 0; h < maxh.length; h++)\n\t\t\tarea = Math.max(area, getMaxArea(h));\n\t\treturn area;\n\t}\n\n\tclass Hbar {\n\t\tint height;\n\t\tint wstart;\n\n\t\tpublic Hbar(int h, int w) {\n\t\t\theight = h;\n\t\t\twstart = w;\n\t\t}\n\t}\n\n\tprivate int getMaxArea(int line) {\n\t\t// get max rectangle which lower edge is on line\n\t\tint area = 0;\n\t\tList<Hbar> hbar = new ArrayList<Hbar>();\n\n\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\tarea = Math.max(area, addBar(hbar, maxh[line][w], w));\n\n\t\tarea = Math.max(area, addBar(hbar, 0, maxh[0].length));\n\n\t\treturn area;\n\t}\n\n\tprivate int addBar(List<Hbar> hbar, int h, int w) {\n\t\t// calculate the area of rectangles which is higher than myself\n\t\tint area = 0;\n\t\tint start = w;\n\t\twhile (!hbar.isEmpty() && hbar.get(0).height > h) {\n\t\t\tarea = Math.max(area, (w - hbar.get(0).wstart) * hbar.get(0).height);\n\t\t\tstart = Math.min(start, hbar.get(0).wstart);\n\t\t\thbar.remove(0);\n\t\t}\n\t\t// and add myself as start point of new height bar\n\t\tif (h > 0)\n\t\t\tif (hbar.isEmpty() || h > hbar.get(0).height)\n\t\t\t\thbar.add(0, new Hbar(h, start));\n\n\t\treturn area;\n\t}\n\n\tprivate void setMaxh() {\n\t\tfor (int h = 1; h < maxh.length; h++)\n\t\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\t\tif (maxh[h][w] > 0)\n\t\t\t\t\tmaxh[h][w] = maxh[h - 1][w] + 1;\n\t}\n\n\tpublic void addTile(int h, int w, int c) {\n\t\t// set 1 to clear tile\n\t\tif (c == 1)\n\t\t\tmaxh[h][w] = 0;\n\t\telse\n\t\t\tmaxh[h][w] = 1;\n\t}\n}\n\nclass UserScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean read() throws IOException {\n\t\tptr = 0;\n\t\tbuflen = in.read(buffer);\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tin.close();\n\t}\n\n\tpublic String next() throws IOException {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.Iterator;\nimport java.util.NoSuchElementException;\nimport java.util.function.IntUnaryOperator;\nimport java.util.function.LongUnaryOperator;\n\n\n\npublic class Main {\n    public static void main(String[] args) {\n        StringBuilder out = new StringBuilder();\n        solve(out);\n        PrintWriter pw = new PrintWriter(System.out);\n        pw.println(out);\n        pw.flush();\n        pw.close();\n    }\n\n    public static void solve(StringBuilder out) {\n        int h = In.ni();\n        int w = In.ni();\n        boolean[][] g = new boolean[h][w];\n        for (int i = 0; i < h; i++) {\n            for (int j = 0; j < w; j++) {\n                g[i][j] = In.ni() == 0;\n            }\n        }\n        out.append(MaximumRectangle.max(g));\n    }\n}\n\n\n/**\n * @author https://atcoder.jp/users/suisen\n */\nfinal class In {\n    public static final FastScanner fsc = new FastScanner();\n    public static int ni() {return fsc.nextInt();}\n    public static int[] ni(final int n) {\n        final int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = fsc.nextInt();\n        return a;\n    }\n    public static int[] ni(final int n, final IntUnaryOperator f) {\n        final int[] a = new int[n];\n        for (int i = 0; i < n; i++) a[i] = f.applyAsInt(fsc.nextInt());\n        return a;\n    }\n    public static int[][] ni(final int n, final int m) {\n        final int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++) a[i] = ni(m);\n        return a;\n    }\n    public static int[][] ni(final int n, final int m, final IntUnaryOperator f) {\n        final int[][] a = new int[n][m];\n        for (int i = 0; i < n; i++) a[i] = ni(m, f);\n        return a;\n    }\n    public static long nl() {return fsc.nextLong();}\n    public static long[] nl(final int n) {\n        final long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = fsc.nextLong();\n        return a;\n    }\n    public static long[] nl(final int n, final LongUnaryOperator f) {\n        final long[] a = new long[n];\n        for (int i = 0; i < n; i++) a[i] = f.applyAsLong(fsc.nextLong());\n        return a;\n    }\n    public static long[][] nl(final int n, final int m) {\n        final long[][] a = new long[n][m];\n        for (int i = 0; i < n; i++) a[i] = nl(m);\n        return a;\n    }\n    public static long[][] nl(final int n, final int m, final LongUnaryOperator f) {\n        final long[][] a = new long[n][m];\n        for (int i = 0; i < n; i++) a[i] = nl(m, f);\n        return a;\n    }\n    public static char[] nc() {return fsc.next().toCharArray();}\n    public static char[][] nc(final int n) {\n        final char[][] c = new char[n][];\n        for (int i = 0; i < n; i++) c[i] = nc();\n        return c;\n    }\n    public static double nd() {return fsc.nextDouble();}\n    public static double[] nd(final int n) {\n        final double[] a = new double[n];\n        for (int i = 0; i < n; i++) a[i] = fsc.nextDouble();\n        return a;\n    }\n    public static double[][] nd(final int n, final int m) {\n        final double[][] a = new double[n][m];\n        for (int i = 0; i < n; i++) a[i] = nd(m);\n        return a;\n    }\n    public static String ns() {return fsc.next();}\n    public static String[] ns(final int n) {\n        final String[] s = new String[n];\n        for (int i = 0; i < n; i++) s[i] = fsc.next();\n        return s;\n    }\n    public static boolean[][] grid(final int h, final int w, final char trueCharacter) {\n        final boolean[][] grid = new boolean[h][w];\n        for (int i = 0; i < h; i++) {\n            final char[] s = fsc.next().toCharArray();\n            for (int j = 0; j < w; j++) grid[i][j] = s[j] == trueCharacter;\n        }\n        return grid;\n    }\n}\n\n\nfinal class FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) return true;\n        ptr = 0;\n        try {buflen = in.read(buffer);}\n        catch (final IOException e) {e.printStackTrace();}\n        return buflen > 0;\n    }\n    private int readByte() {return hasNextByte() ? buffer[ptr++] : -1;}\n    public boolean hasNext() {\n        while (hasNextByte() && !(33 <= buffer[ptr] && buffer[ptr] <= 126)) ptr++;\n        return hasNextByte();\n    }\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        final StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while (33 <= b && b <= 126) {sb.appendCodePoint(b); b = readByte();}\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {minus = true; b = readByte();}\n        if (b < '0' || '9' < b) throw new NumberFormatException();\n        for (; ; b = readByte()) {\n            if ('0' <= b && b <= '9') n = n * 10 + b - '0';\n            else if (b == -1 || !(33 <= b && b <= 126)) return minus ? -n : n;\n            else throw new NumberFormatException();\n        }\n    }\n    public int nextInt() {return Math.toIntExact(nextLong());}\n    public double nextDouble() {return Double.parseDouble(next());}\n}\n\n\nclass MaximumRectangle {\n    public static int max(boolean[][] g) {\n        final int h = g.length;\n        final int w = g[0].length;\n        int[][] hst = new int[h][w];\n        for (int j = 0; j < w; j++) hst[h - 1][j] = g[h - 1][j] ? 1 : 0;\n        for (int i = h - 2; i >= 0; i--) for (int j = 0; j < w; j++) {\n            hst[i][j] = g[i][j] ? hst[i + 1][j] + 1 : 0;\n        }\n        int max = 0;\n        for (int i = 0; i < h; i++) max = Math.max(max, histRectMax(hst[i]));\n        return max;\n    }\n\n    public static int histRectMax(int[] h) {\n        final int n = h.length;\n        Stack<int[]> s = new Stack<>();\n        int max = 0;\n        for (int j = 0; j < n; j++) {\n            int hj = h[j];\n            if (s.size() == 0) {\n                s.add(new int[]{j, hj});\n            } else {\n                int[] top = s.peek();\n                if (top[1] < hj) {\n                    s.add(new int[]{j, hj});\n                } else if (top[1] > hj) {\n                    while (s.size() > 0 && s.peek()[1] >= hj) {\n                        top = s.poll();\n                        max = Math.max(max, top[1] * (j - top[0]));\n                    }\n                    s.add(new int[]{top[0], hj});\n                }\n            }\n        }\n        int[] top;\n        while (s.size() > 0) {\n            top = s.poll();\n            max = Math.max(max, top[1] * (n - top[0]));\n        }\n        return max;\n    }\n\n    public static long histRectMax(long[] h) {\n        final int n = h.length;\n        Stack<long[]> s = new Stack<>();\n        long max = 0;\n        for (int j = 0; j < n; j++) {\n            long hj = h[j];\n            if (s.size() == 0) {\n                s.add(new long[]{j, hj});\n            } else {\n                long[] top = s.peek();\n                if (top[1] < hj) {\n                    s.add(new long[]{j, hj});\n                } else if (top[1] > hj) {\n                    while (s.size() > 0 && s.peek()[1] >= hj) {\n                        top = s.poll();\n                        max = Math.max(max, top[1] * (j - top[0]));\n                    }\n                    s.add(new long[]{top[0], hj});\n                }\n            }\n        }\n        long[] top;\n        while (s.size() > 0) {\n            top = s.poll();\n            max = Math.max(max, top[1] * (n - top[0]));\n        }\n        return max;\n    }\n}\n\n\n@SuppressWarnings(\"unchecked\")\nclass Stack<T> {\n    private static final int DEFAULT_SIZE = 64;\n    private T[] s;\n    private int size;\n    private int tail = 0;\n    public Stack(final int capacity) {this.s = (T[]) new Object[capacity];this.size = capacity;}\n    public Stack() {this(DEFAULT_SIZE);}\n    public T peek() {\n        if (tail == 0) throw new NoSuchElementException(\"No Elements.\");\n        return s[tail - 1];\n    }\n    public T getFromHead(int index) {\n        if (index >= tail || index < 0) throw new NoSuchElementException(\"index out of Bounds.\");\n        return s[index];\n    }\n    public T getFromTail(int index) {\n        if (index >= tail || index < 0) throw new NoSuchElementException(\"index out of Bounds.\");\n        return s[tail - 1 - index];\n    }\n    public void add(final T v) {\n        if (tail == size) grow();\n        s[tail++] = v;\n    }\n    public void add(final T... vals) {for (T v : vals) add(v);}\n    public T poll() {\n        if (tail == 0) throw new NoSuchElementException(\"No Elements.\");\n        return s[--tail];\n    }\n    public int size() {return tail;}\n    private void grow() {\n        final T[] grown = (T[]) new Object[size << 1];\n        System.arraycopy(s, 0, grown, 0, tail);\n        s = grown;\n        size <<= 1;\n    }\n    public Iterator<T> iterator() {return new StackIterator();}\n    private class StackIterator implements Iterator<T> {\n        private int i = tail - 1;\n        public boolean hasNext() {return i >= 0;}\n        public T next() {return s[i--];}\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.LinkedList;\nimport java.util.List;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tUserScanner scan = new UserScanner();\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\n\t\tRectangle rg = new Rectangle(h, w, debug);\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\trg.addTile(i, j, scan.nextInt());\n\n\t\tpwriter.println(rg.getMaxRect());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rectangle {\n\tboolean debug;\n\tint[][] maxh;\n\n\tpublic Rectangle(int h, int w, boolean debug) {\n\t\tthis.debug = debug;\n\t\tmaxh = new int[h][w];\n\t}\n\n\tint maxArea = 0;\n\n\tpublic int getMaxRect() {\n\t\tsetMaxh(); // set the number of upper continues clear tile\n\n\t\tfor (int h = maxh.length - 1; h >= 0; h--)\n\t\t\tif ((h + 1) * maxh[0].length > maxArea)\n\t\t\t\tgetMaxArea(h);\n\t\treturn maxArea;\n\t}\n\n\tclass Hbar {\n\t\tint height;\n\t\tint wstart;\n\n\t\tpublic Hbar(int h, int w) {\n\t\t\theight = h;\n\t\t\twstart = w;\n\t\t}\n\t}\n\n\tLinkedList<Hbar> hbar = new LinkedList<Hbar>();\n\n\tprivate void getMaxArea(int line) {\n\t\t// get max rectangle which lower edge is on line\n\t\thbar.clear();\n\n\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\tmaxArea = Math.max(maxArea, addBar(hbar, maxh[line][w], w));\n\n\t\tmaxArea = Math.max(maxArea, addBar(hbar, 0, maxh[0].length));\n\t}\n\n\tprivate int addBar(LinkedList<Hbar> hbar, int h, int w) {\n\t\t// calculate the area of rectangles which is higher than myself\n\t\tint area = 0;\n\t\tint start = w;\n\t\twhile (!hbar.isEmpty() && hbar.getFirst().height > h) {\n\t\t\tarea = Math.max(area, (w - hbar.getFirst().wstart) * hbar.getFirst().height);\n\t\t\tstart = Math.min(start, hbar.getFirst().wstart);\n\t\t\thbar.removeFirst();\n\t\t}\n\t\t// and add myself as start point of new height bar\n\t\tif (h > 0 && h * (maxh[0].length - start) > maxArea)\n\t\t\tif (hbar.isEmpty() || h > hbar.getFirst().height)\n\t\t\t\thbar.add(0, new Hbar(h, start));\n\n\t\treturn area;\n\t}\n\n\tprivate void setMaxh() {\n\t\tfor (int h = 1; h < maxh.length; h++)\n\t\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\t\tif (maxh[h][w] > 0)\n\t\t\t\t\tmaxh[h][w] = maxh[h - 1][w] + 1;\n\t}\n\n\tpublic void addTile(int h, int w, int c) {\n\t\t// set 1 to clear tile\n\t\tif (c == 1)\n\t\t\tmaxh[h][w] = 0;\n\t\telse\n\t\t\tmaxh[h][w] = 1;\n\t}\n}\n\nclass UserScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean read() throws IOException {\n\t\tptr = 0;\n\t\tbuflen = in.read(buffer);\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tin.close();\n\t}\n\n\tpublic String next() throws IOException {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\n\npublic class Main {\n\tstatic boolean debug = true;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tUserScanner scan = new UserScanner();\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\n\t\tRectangle rg = new Rectangle(h, w, debug);\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\trg.addTile(i, j, scan.nextInt());\n\n\t\tpwriter.println(rg.getMaxSquare());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rectangle {\n\tboolean debug;\n\tTile[][] tile;\n\tint maxArea;\n\n\tclass Tile {\n\t\tboolean isClear;\n\t\t// largest height, width of horizontal rectangle for left-upper tile\n\t\tint h_HrRect;\n\t\tint w_HrRect;\n\t\t// same with vertical rectangle\n\t\tint h_VrRect;\n\t\tint w_VrRect;\n\n\t\tpublic Tile(boolean clear) {\n\t\t\tisClear = clear;\n\t\t\tif (isClear) {\n\t\t\t\th_HrRect = 1;\n\t\t\t\tw_HrRect = 1;\n\t\t\t\th_VrRect = 1;\n\t\t\t\tw_VrRect = 1;\n\t\t\t} else {\n\t\t\t\th_HrRect = 0;\n\t\t\t\tw_HrRect = 0;\n\t\t\t\th_VrRect = 0;\n\t\t\t\tw_VrRect = 0;\n\t\t\t}\n\t\t}\n\n\t\tpublic int getMaxArea() {\n\t\t\treturn Math.max(h_HrRect * w_HrRect, h_VrRect * w_VrRect);\n\t\t}\n\t}\n\n\tpublic Rectangle(int h, int w, boolean debug) {\n\t\tthis.debug = debug;\n\t\ttile = new Tile[h][w];\n\t}\n\n\tpublic int getMaxSquare() {\n\n\t\tfor (int h = 1; h < tile.length; h++) // set height to first row\n\t\t\tif (tile[h][0].isClear) {\n\t\t\t\ttile[h][0].h_HrRect = tile[h - 1][0].h_HrRect + 1;\n\t\t\t\ttile[h][0].h_VrRect = tile[h - 1][0].h_VrRect + 1;\n\t\t\t}\n\n\t\tfor (int w = 1; w < tile[0].length; w++) // set width to top line\n\t\t\tif (tile[0][w].isClear) {\n\t\t\t\ttile[0][w].w_HrRect = tile[0][w - 1].w_HrRect + 1;\n\t\t\t\ttile[0][w].w_VrRect = tile[0][w - 1].w_VrRect + 1;\n\t\t\t}\n\n\t\tfor (int h = 1; h < tile.length; h++)\n\t\t\tfor (int w = 1; w < tile[0].length; w++)\n\n\t\t\t\tif (tile[h][w].isClear) {\n\n\t\t\t\t\t// horizontal rectangle\n\t\t\t\t\t// width is increase 1 to left tile,\n\t\t\t\t\ttile[h][w].w_HrRect = tile[h][w - 1].w_HrRect + 1;\n\n\t\t\t\t\t// if left tile is clear, height must be check with upper\n\t\t\t\t\tif (tile[h][w - 1].isClear)\n\t\t\t\t\t\tif (tile[h - 1][w].w_HrRect >= tile[h][w].w_HrRect)\n\t\t\t\t\t\t\ttile[h][w].h_HrRect = tile[h - 1][w].h_HrRect + 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttile[h][w].h_HrRect = 1;\n\t\t\t\t\telse\n\t\t\t\t\t\ttile[h][w].h_HrRect = tile[h - 1][w].h_VrRect + 1;\n\n\t\t\t\t\t// same for vertical rectangle\n\t\t\t\t\ttile[h][w].h_VrRect = tile[h - 1][w].h_VrRect + 1;\n\n\t\t\t\t\tif (tile[h - 1][w].isClear)\n\t\t\t\t\t\tif (tile[h][w - 1].h_VrRect >= tile[h][w].h_VrRect)\n\t\t\t\t\t\t\ttile[h][w].w_VrRect = tile[h][w - 1].w_VrRect + 1;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttile[h][w].w_VrRect = 1;\n\t\t\t\t\telse\n\t\t\t\t\t\ttile[h][w].w_VrRect = tile[h][w - 1].w_HrRect + 1;\n\t\t\t\t\t\n\t\t\t\t\tif (tile[h][w].getMaxArea() > maxArea)\n\t\t\t\t\t\tmaxArea = tile[h][w].getMaxArea();\n\t\t\t\t}\n\n\t\treturn maxArea;\n\t}\n\n\tpublic void addTile(int h, int w, int c) {\n\t\t// set countable tile as true\n\t\tif (c == 0) {\n\t\t\ttile[h][w] = new Tile(true);\n\t\t\tmaxArea = 1;\n\t\t} else\n\t\t\ttile[h][w] = new Tile(false);\n\t}\n\n}\n\nclass UserScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean read() throws IOException {\n\t\tptr = 0;\n\t\tbuflen = in.read(buffer);\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tin.close();\n\t}\n\n\tpublic String next() throws IOException {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tUserScanner scan = new UserScanner(System.in);\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\n\t\tRectangle rg = new Rectangle(h, w, debug);\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\trg.addTile(i, j, scan.nextInt());\n\n\t\tpwriter.println(rg.getMaxRect());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rectangle {\n\tboolean debug;\n\n\tint[][] maxh;\n\n\tint tableLast = -1;\n\tint[] rectangleHeight;\n\tint[] rectangleLeft;\n\n\tint maxArea = 0;\n\n\tpublic Rectangle(int h, int w, boolean debug) {\n\t\tthis.debug = debug;\n\t\tmaxh = new int[h][w];\n\t\trectangleHeight = new int[Math.min(h, w)];\n\t\trectangleLeft = new int[Math.min(h, w)];\n\t}\n\n\tpublic int getMaxRect() {\n\t\tsetMaxh(); // set the number of upper continues clear tile\n\n\t\tfor (int h = maxh.length - 1; h >= 0; h--)\n\t\t\tif ((h + 1) * maxh[0].length > maxArea)\n\t\t\t\t// not need to check, if already found larger rectangle\n\t\t\t\tgetMaxArea(h);\n\t\treturn maxArea;\n\t}\n\n\tprivate void getMaxArea(int line) {\n\t\t// get max rectangle which lower edge is on the line\n\t\ttableLast = -1;\n\n\t\t// Calculate by width\n\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\taddBar(maxh[line][w], w);\n\n\t\t// Calculate the rectangle area which right edge is terminated on border\n\t\taddBar(0, maxh[0].length);\n\t}\n\n\tprivate void addBar(int h, int w) {\n\t\t// if height is higher than current, the width of that rectangle has\n\t\t// been fixed, then calculate the area of rectangle\n\t\tint start = w;\n\t\twhile (tableLast >= 0) {\n\t\t\tif (rectangleHeight[tableLast] <= h)\n\t\t\t\tbreak;\n\t\t\tmaxArea = Math.max(maxArea, (w - rectangleLeft[tableLast]) * rectangleHeight[tableLast]);\n\t\t\tstart = Math.min(start, rectangleLeft[tableLast]);\n\t\t\ttableLast--;\n\t\t}\n\t\t// and add current data as start point of new height bar\n\t\t// if it's possible to make the largest rectangle\n\t\tif (h > 0 && h * (maxh[0].length - start) > maxArea)\n\t\t\tif (tableLast < 0 || h > rectangleHeight[tableLast]) {\n\t\t\t\trectangleHeight[++tableLast] = h;\n\t\t\t\trectangleLeft[tableLast] = start;\n\t\t\t}\n\t}\n\n\tprivate void setMaxh() {\n\t\tfor (int h = 1; h < maxh.length; h++)\n\t\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\t\tif (maxh[h][w] > 0)\n\t\t\t\t\tmaxh[h][w] = maxh[h - 1][w] + 1;\n\t}\n\n\tpublic void addTile(int h, int w, int c) {\n\t\t// set 1 to clear tile\n\t\tif (c == 1)\n\t\t\tmaxh[h][w] = 0;\n\t\telse\n\t\t\tmaxh[h][w] = 1;\n\t}\n}\n\nclass UserScanner {\n\tprivate InputStream in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tpublic UserScanner(InputStream inStream) {\n\t\tin = inStream;\n\t}\n\n\tprivate void read() {\n\t\tptr = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(9);\n\t\t}\n\t\tif (buflen == -1)\n\t\t\tSystem.exit(1);\n\t}\n\n\tprivate byte getByte() {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() {\n\t\tfor (; ptr < buflen; ptr++)\n\t\t\tif (!isCtlSpace(buffer[ptr]))\n\t\t\t\treturn;\n\t\tread();\n\t\tskipCtlSpace();\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() {\n\t\ttry {\n\t\t\tin.close();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t\tSystem.exit(9);\n\t\t}\n\t}\n\n\tpublic String next() {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tScanner scan = new Scanner(System.in);\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\n\t\tRectangle rg = new Rectangle(h, w, debug);\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\trg.addTile(i, j, scan.nextInt());\n\n\t\tpwriter.println(rg.getMaxRect());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rectangle {\n\tboolean debug;\n\tint[][] maxh;\n\n\tpublic Rectangle(int h, int w, boolean debug) {\n\t\tthis.debug = debug;\n\t\tmaxh = new int[h][w];\n\t}\n\n\tint maxArea = 0;\n\n\tpublic int getMaxRect() {\n\t\tsetMaxh(); // set the number of upper continues clear tile\n\n\t\tfor (int h = maxh.length - 1; h >= 0; h--)\n\t\t\tif ((h + 1) * maxh[0].length > maxArea)\n\t\t\t\t// not need to check, if already found larger rectangle\n\t\t\t\tgetMaxArea(h);\n\t\treturn maxArea;\n\t}\n\n\tclass Hbar {\n\t\tint height;\n\t\tint wstart;\n\n\t\tpublic Hbar(int h, int w) {\n\t\t\theight = h;\n\t\t\twstart = w;\n\t\t}\n\t}\n\n\tLinkedList<Hbar> hbar = new LinkedList<Hbar>();\n\n\tprivate void getMaxArea(int line) {\n\t\t// get max rectangle which lower edge is on the line\n\t\thbar.clear();\n\n\t\t// Calculate by width\n\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\taddBar(hbar, maxh[line][w], w);\n\n\t\t// Calculate the rectangle area which right edge is terminated on border\n\t\taddBar(hbar, 0, maxh[0].length);\n\t}\n\n\tprivate void addBar(LinkedList<Hbar> hbar, int h, int w) {\n\t\t// if height is higher than current, the width of that rectangle has\n\t\t// been fixed, then calculate the area of rectangle\n\t\tint start = w;\n\t\twhile (!hbar.isEmpty()) {\n\t\t\tHbar top = hbar.getFirst();\n\t\t\tif (top.height <= h)\n\t\t\t\tbreak;\n\t\t\tmaxArea = Math.max(maxArea, (w - top.wstart) * top.height);\n\t\t\tstart = Math.min(start, hbar.getFirst().wstart);\n\t\t\thbar.removeFirst();\n\t\t}\n\t\t// and add current data as start point of new height bar\n\t\t// if it's possible to make the largest rectangle\n\t\tif (h > 0 && h * (maxh[0].length - start) > maxArea)\n\t\t\tif (hbar.isEmpty() || h > hbar.getFirst().height)\n\t\t\t\thbar.add(0, new Hbar(h, start));\n\t}\n\n\tprivate void setMaxh() {\n\t\tfor (int h = 1; h < maxh.length; h++)\n\t\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\t\tif (maxh[h][w] > 0)\n\t\t\t\t\tmaxh[h][w] = maxh[h - 1][w] + 1;\n\t}\n\n\tpublic void addTile(int h, int w, int c) {\n\t\t// set 1 to clear tile\n\t\tif (c == 1)\n\t\t\tmaxh[h][w] = 0;\n\t\telse\n\t\t\tmaxh[h][w] = 1;\n\t}\n}\n\nclass UserScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean read() throws IOException {\n\t\tptr = 0;\n\t\tbuflen = in.read(buffer);\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tin.close();\n\t}\n\n\tpublic String next() throws IOException {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.util.StringTokenizer;\n//http://www.ipsj.or.jp/07editj/promenade/4304.pdf\n//http://algorithms.blog55.fc2.com/blog-entry-131.html\n//http://algorithms.blog55.fc2.com/blog-entry-132.html\n//http://algorithms.blog55.fc2.com/blog-entry-133.html\n//最大正方形の問題はDPだったけど最大長方形は累積和とスタックを組み合わせてる\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tSC sc=new SC(System.in);\n\t\t/*while(true) {*/\n\t\t\tint h=sc.nextInt();\n\t\t\tint w=sc.nextInt();\n\t\t\t/*if(h*w==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse {*/\n\t\t\t\tint[][] plate=new int[h][w];\n\t\t\t\tint[][] dp=new int[h][w];\n\t\t\t\tlong[] stacks=new long[w+1];\n\t\t\t\tint counter=0;\n\t\t\t\tlong mltp=100000000000L;\t//スタックで幅と高さを同時に保存する\n\t\t\t\tlong now_h=0;\n\t\t\t\tlong max=0;\t\t//最大長方形の面積\n\t\t\t\tstacks[0]=0;\n\t\t\t\tcounter++;\n\t\t\t\tfor(int i=0; i<h; i++) {\n\t\t\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\t\t\tplate[i][j]=0;\n\t\t\t\t\t\tdp[i][j]=0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tString s=\"\";\n\t\t\t\tfor(int i=0; i<h; i++) {\n\t\t\t\t\ts=sc.nextLine();\n\t\t\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\t\t\tif(s.charAt(j*2)=='0') {\n\t\t\t\t\t\t\tplate[i][j]=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tplate[i][j]=1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i=0; i<h; i++) {\n\t\t\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\t\t\tif(i==0) {\n\t\t\t\t\t\t\tif(plate[i][j]==1) {\n\t\t\t\t\t\t\t\tdp[i][j]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[i][j]=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif(plate[i][j]==1) {\n\t\t\t\t\t\t\t\tdp[i][j]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tdp[i][j]=dp[i-1][j]+1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor(int i=0; i<h; i++) {\n\t\t\t\t\tstacks=new long[w+1];\n\t\t\t\t\tstacks[0]=0;\n\t\t\t\t\tcounter=0;\n\t\t\t\t\tnow_h=0;\n\t\t\t\t\tcounter++;\n\t\t\t\t\tfor(int j=0; j<w; j++) {\n\t\t\t\t\t\tif(j==0) {\t//スタックが空なら追加\n\t\t\t\t\t\t\tstacks[counter]=((long)j)*mltp+dp[i][j];\n\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tif(now_h<dp[i][j]) {\t\t//今のほうが高いならスタックに追加\n\t\t\t\t\t\t\t\tstacks[counter]=((long)j)*mltp+dp[i][j];\n\t\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(now_h==dp[i][j]) {\t//同じなら何もしない\n\t\t\t\t\t\t\t\t//\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse if(now_h>dp[i][j]) {\n\t\t\t\t\t\t\t\twhile(counter-1>=0 && stacks[counter-1]%mltp>=dp[i][j]) {//例えば今高さが2,3,5,8とはいっていて、いま3が入った時、長方形が維持できるのはさいしょの2,3のみ\n\t\t\t\t\t\t\t\t\tmax=Math.max(max,(j-stacks[counter-1]/mltp)*(stacks[counter-1]%mltp));\n\t\t\t\t\t\t\t\t\t//pl(max);\n\t\t\t\t\t\t\t\t\tcounter--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tstacks[counter]=(stacks[counter]/mltp)*mltp+dp[i][j];\n\t\t\t\t\t\t\t\t//pl(stacks[counter]);\n\t\t\t\t\t\t\t\tcounter++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tnow_h=dp[i][j];\n\t\t\t\t\t}\n\t\t\t\t\tfor(int j=counter-1; j>=0; j--) {\n\t\t\t\t\t\tmax=Math.max(max, (w-stacks[j]/mltp)*(stacks[j]%mltp));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tpl(max);\n\t\t\t/*}\n\t\t}*/\n\t}\n\tpublic static void pl(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\tpublic static void pl() {\n\t\tSystem.out.println();\n\t}\n\tpublic static void p(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\tstatic class SC {\n\t\tprivate BufferedReader reader = null;\n\t\tprivate StringTokenizer tokenizer = null;\n\t\tpublic SC(InputStream in) {\n\t\t\treader = new BufferedReader(new InputStreamReader(in));\n\t\t}\n\t\tpublic String next() {\n\t\t\tif (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\ttokenizer = new StringTokenizer(reader.readLine());\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new UncheckedIOException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new UncheckedIOException(e);\n\t\t\t}\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.util.*;\nimport java.math.BigInteger;\n \npublic class Main implements Runnable {\n\t\n\tstatic int mod = 1000000007;\n\t\n    public static void main(String[] args) {\n    \tnew Thread(null, new Main(), \"\", 1024 * 1024 * 1024).start();\n    }\n    \n    public void run() {\n        FastScanner sc = new FastScanner();\n        \n        int h = sc.nextInt();\n        int w = sc.nextInt();\n        boolean[][] g = new boolean[h][w];\n        \n        for(int i=0;i<h;i++){\n        \tfor(int j=0;j<w;j++){\n        \t\tif(sc.nextInt() == 0){\n        \t\t\tg[i][j] = true;\n        \t\t}\n        \t}\n        }\n        \n        long e = largestRectangle(g);\n        \n        System.out.println(e);   \n    }\n    \n\t//ヒストグラム内で作れる最大の長方形の面積\n\tstatic long largestRectangle(int[] h){\n\t\t\n\t\tclass Rect{\n\t\t\tint leftid;\n\t\t\tint height;\n\t\t\tpublic Rect(int leftid, int height){\n\t\t\t\tthis.leftid = leftid;\n\t\t\t\tthis.height = height;\n\t\t\t}\n\t\t}\n\t\t\n\t\tint N = h.length;\n\t\tlong max = 0;\n\t\t\n\t\tArrayDeque<Rect> q = new ArrayDeque<>();\t//未完成の長方形リスト\n\t\t\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(q.isEmpty() || q.peekFirst().height < h[i]){\n\t\t\t\tq.offerFirst(new Rect(i,h[i]));\n\t\t\t}\n\t\t\telse if(q.peekFirst().height > h[i]){\n\t\t\t\tint leftid = i;\n\t\t\t\twhile(!q.isEmpty() && q.peekFirst().height >= h[i]){\n\t\t\t\t\tRect r = q.pollFirst();\n\t\t\t\t\tleftid = r.leftid;\n\t\t\t\t\tmax = Math.max(max, (long)(i - r.leftid) * (long)r.height);\n\t\t\t\t}\n\t\t\t\tq.offerFirst(new Rect(leftid,h[i]));\n\t\t\t}\n\t\t}\n\t\t\n\t\twhile(!q.isEmpty()){\n\t\t\tRect r = q.pollFirst();\n\t\t\tmax = Math.max(max, (long)(N - r.leftid) * (long)r.height);\n\t\t}\n\t\t\n\t\treturn max;\n\t}\n\t\n\t//trueのみを用いて作れる最大の長方形の面積\n\tstatic long largestRectangle(boolean[][] g){\n\t\tint h = g.length;\n\t\tint w = g[0].length;\n\t\tint[][] sumh = new int[h][w]; //上方向に続くtrueの数\n\t\t\n\t\tfor(int j=0;j<w;j++){\n\t\t\tif(g[0][j]){\n\t\t\t\tsumh[0][j] = 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=1;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(g[i][j]){\n\t\t\t\t\tsumh[i][j] = sumh[i-1][j] + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//ヒストグラムの場合を利用\n\t\tlong max = 0;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tmax = Math.max(max, largestRectangle(sumh[i]));\n\t\t}\n\t\t\n\t\treturn max;\n\t}\n\t\n}\n\n\n\nclass FastScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\tprivate boolean hasNextByte() {\n\t\tif (ptr < buflen) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\tptr = 0;\n\t\t\ttry {\n\t\t\t\tbuflen = in.read(buffer);\n\t\t\t} catch (IOException e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t\tif (buflen <= 0) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\tprivate int readByte() {\n\t\tif (hasNextByte())\n\t\t\treturn buffer[ptr++];\n\t\telse\n\t\t\treturn -1;\n\t}\n\tprivate static boolean isPrintableChar(int c) {\n\t\treturn 33 <= c && c <= 126;\n\t}\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrintableChar(buffer[ptr]))\n\t\t\tptr++;\n\t\treturn hasNextByte();\n\t}\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = readByte();\n\t\twhile (isPrintableChar(b)) {\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\tpublic long nextLong() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tlong n = 0;\n\t\tboolean minus = false;\n\t\tint b = readByte();\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\tif (b < '0' || '9' < b) {\n\t\t\tthrow new NumberFormatException();\n\t\t}\n\t\twhile (true) {\n\t\t\tif ('0' <= b && b <= '9') {\n\t\t\t\tn *= 10;\n\t\t\t\tn += b - '0';\n\t\t\t} else if (b == -1 || !isPrintableChar(b)) {\n\t\t\t\treturn minus ? -n : n;\n\t\t\t} else {\n\t\t\t\tthrow new NumberFormatException();\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\tpublic int nextInt() {\n\t\tlong nl = nextLong();\n\t\tif (nl < Integer.MIN_VALUE || nl > Integer.MAX_VALUE)\n\t\t\tthrow new NumberFormatException();\n\t\treturn (int) nl;\n\t}\n\tpublic int[] nextIntArray(int n){\n\t\tint[] a = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic Integer[] nextIntegerArray(int n){\n\t\tInteger[] a = new Integer[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\ta[i] = nextInt();\n\t\t}\n\t\treturn a;\n\t}\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\n\npublic class Main {\n\tstatic boolean debug = false;\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tUserScanner scan = new UserScanner();\n\t\tPrintWriter pwriter = new PrintWriter(System.out);\n\n\t\tint h = scan.nextInt();\n\t\tint w = scan.nextInt();\n\n\t\tRectangle rg = new Rectangle(h, w, debug);\n\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\trg.addTile(i, j, scan.nextInt());\n\n\t\tpwriter.println(rg.getMaxRect());\n\n\t\tpwriter.flush();\n\t\tscan.close();\n\t\tSystem.exit(0);\n\t}\n}\n\nclass Rectangle {\n\tboolean debug;\n\tint[][] maxh;\n\n\tpublic Rectangle(int h, int w, boolean debug) {\n\t\tthis.debug = debug;\n\t\tmaxh = new int[h][w];\n\t}\n\n\tint maxArea = 0;\n\n\tpublic int getMaxRect() {\n\t\tsetMaxh(); // set the number of upper continues clear tile\n\n\t\tfor (int h = maxh.length - 1; h >= 0; h--)\n\t\t\tif ((h + 1) * maxh[0].length > maxArea)\n\t\t\t\tgetMaxArea(h);\n\t\treturn maxArea;\n\t}\n\n\tclass Hbar {\n\t\tint height;\n\t\tint wstart;\n\n\t\tpublic Hbar(int h, int w) {\n\t\t\theight = h;\n\t\t\twstart = w;\n\t\t}\n\t}\n\n\tprivate void getMaxArea(int line) {\n\t\t// get max rectangle which lower edge is on line\n\t\tList<Hbar> hbar = new ArrayList<Hbar>();\n\n\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\tmaxArea = Math.max(maxArea, addBar(hbar, maxh[line][w], w));\n\n\t\tmaxArea = Math.max(maxArea, addBar(hbar, 0, maxh[0].length));\n\t}\n\n\tprivate int addBar(List<Hbar> hbar, int h, int w) {\n\t\t// calculate the area of rectangles which is higher than myself\n\t\tint area = 0;\n\t\tint start = w;\n\t\twhile (!hbar.isEmpty() && hbar.get(0).height > h) {\n\t\t\tarea = Math.max(area, (w - hbar.get(0).wstart) * hbar.get(0).height);\n\t\t\tstart = Math.min(start, hbar.get(0).wstart);\n\t\t\thbar.remove(0);\n\t\t}\n\t\t// and add myself as start point of new height bar\n\t\tif (h > 0 && h * (maxh[0].length - start) > maxArea)\n\t\t\tif (hbar.isEmpty() || h > hbar.get(0).height)\n\t\t\t\thbar.add(0, new Hbar(h, start));\n\n\t\treturn area;\n\t}\n\n\tprivate void setMaxh() {\n\t\tfor (int h = 1; h < maxh.length; h++)\n\t\t\tfor (int w = 0; w < maxh[0].length; w++)\n\t\t\t\tif (maxh[h][w] > 0)\n\t\t\t\t\tmaxh[h][w] = maxh[h - 1][w] + 1;\n\t}\n\n\tpublic void addTile(int h, int w, int c) {\n\t\t// set 1 to clear tile\n\t\tif (c == 1)\n\t\t\tmaxh[h][w] = 0;\n\t\telse\n\t\t\tmaxh[h][w] = 1;\n\t}\n}\n\nclass UserScanner {\n\tprivate final InputStream in = System.in;\n\tprivate final byte[] buffer = new byte[1024];\n\tprivate int ptr = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean read() throws IOException {\n\t\tptr = 0;\n\t\tbuflen = in.read(buffer);\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\telse\n\t\t\treturn true;\n\t}\n\n\tprivate byte getByte() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\treturn -1;\n\t\t} else\n\t\t\treturn buffer[ptr++];\n\t}\n\n\tprivate void skipCtlSpace() throws IOException {\n\t\tif (ptr >= buflen)\n\t\t\tread();\n\t\tif (isCtlSpace(buffer[ptr])) {\n\t\t\tptr++;\n\t\t\tskipCtlSpace();\n\t\t}\n\t}\n\n\tprivate boolean isCtlSpace(byte b) {\n\t\tif (b <= ' ' || b > '~')\n\t\t\treturn true;\n\t\telse\n\t\t\treturn false;\n\t}\n\n\tpublic void close() throws IOException {\n\t\tin.close();\n\t}\n\n\tpublic String next() throws IOException {\n\t\tskipCtlSpace();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() throws IOException {\n\t\tskipCtlSpace();\n\t\tint n = 0;\n\t\tboolean minus = false;\n\t\tbyte b;\n\t\twhile ((b = getByte()) != -1) {\n\t\t\tif (b == '-')\n\t\t\t\tminus = true;\n\t\t\telse {\n\t\t\t\tn *= 10;\n\t\t\t\tn += (b - '0');\n\t\t\t}\n\t\t}\n\t\tif (minus)\n\t\t\treturn n * -1;\n\t\telse\n\t\t\treturn n;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint[][] cum = new int[2][w];\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tif (c == 0) {\n\t\t\t\t\tcum[i % 2][j] = (i > 0 ? cum[(i - 1) % 2][j] : 0) + 1;\n\t\t\t\t} else {\n\t\t\t\t\tcum[i % 2][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = Math.max(ans, solve(cum[i % 2], w));\n\t\t\t\n\t\t}\n\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tint solve(int[] cum, int w) {\n\t\tint ans = 0;\n\t\tArrayDeque<List<Integer>> stack = new ArrayDeque<>();\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tans = Math.max(ans, cum[j]);\n\t\t\tint d = j;\n\t\t\twhile (!stack.isEmpty() && (cum[j] == 0 || stack.peekLast().get(0) > cum[j])) {\n\t\t\t\tList<Integer> pair = stack.pollLast();\n\t\t\t\tans = Math.max(ans, pair.get(0) * (j - pair.get(1)));\n\t\t\t\td = Math.min(d, pair.get(1));\n\t\t\t}\n\t\t\tif (cum[j] == 0)\n\t\t\t\tcontinue;\n\t\t\tstack.addLast(Arrays.asList(cum[j], d));\n\t\t}\n\t\twhile (!stack.isEmpty()) {\n\t\t\tList<Integer> pair = stack.pollLast();\n\t\t\tans = Math.max(ans, pair.get(0) * (w - pair.get(1)));\n\t\t}\n\t\treturn ans;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint[][] cum = new int[h][w];\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tint[] c = new int[w];// c[i][j]==0???????????¨??????\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tc[j] = sc.nextInt();\n\t\t\t\tif (c[j] == 0) {\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\tcum[i][j] += cum[i - 1][j];\n\t\t\t\t\t}\n\t\t\t\t\tcum[i][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tArrayDeque<List<Integer>> stack = new ArrayDeque<>();\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tans = Math.max(ans, cum[i][j]);\n\t\t\t\tint d = j;\n\t\t\t\twhile (!stack.isEmpty() && (cum[i][j] == 1 || stack.peekLast().get(0) > cum[i][j])) {\n\t\t\t\t\tList<Integer> pair = stack.pollLast();\n\t\t\t\t\tans = Math.max(ans, pair.get(0) * (j - pair.get(1)));\n\t\t\t\t\td = Math.min(d, pair.get(1));\n\t\t\t\t}\n\t\t\t\tif (cum[i][j] == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tstack.addLast(Arrays.asList(cum[i][j], d));\n\t\t\t}\n\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\tList<Integer> pair = stack.pollLast();\n\t\t\t\tans = Math.max(ans, pair.get(0) * (w - pair.get(1)));\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint[][] cum = new int[2][w];\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tint[] c = new int[w];// c[i][j]==0???????????¨??????\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tc[j] = sc.nextInt();\n\t\t\t\tif (c[j] == 0) {\n\t\t\t\t\tcum[i % 2][j] = (i > 0 ? cum[(i - 1) % 2][j] : 0) + 1;\n\t\t\t\t} else {\n\t\t\t\t\tcum[i % 2][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans = Math.max(ans, solve(cum[i % 2], w));\n\t\t}\n\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tint solve(int[] cum, int w) {\n\t\tint ans = 0;\n\t\tArrayDeque<List<Integer>> stack = new ArrayDeque<>();\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tans = Math.max(ans, cum[j]);\n\t\t\tint d = j;\n\t\t\twhile (!stack.isEmpty() && (cum[j] == 0 || stack.peekLast().get(0) > cum[j])) {\n\t\t\t\tList<Integer> pair = stack.pollLast();\n\t\t\t\tans = Math.max(ans, pair.get(0) * (j - pair.get(1)));\n\t\t\t\td = Math.min(d, pair.get(1));\n\t\t\t}\n\t\t\tif (cum[j] == 0)\n\t\t\t\tcontinue;\n\t\t\tstack.addLast(Arrays.asList(cum[j], d));\n\t\t}\n\t\twhile (!stack.isEmpty()) {\n\t\t\tList<Integer> pair = stack.pollLast();\n\t\t\tans = Math.max(ans, pair.get(0) * (w - pair.get(1)));\n\t\t}\n\t\treturn ans;\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\nclass Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint h = sc.nextInt();\n\t\tint w = sc.nextInt();\n\t\tint[][] c = new int[h][w];\n\t\tint[][] cum = new int[h][w];\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tc[i][j] = sc.nextInt();\n\t\t\t\tif (c[i][j] == 0) {\n\t\t\t\t\tif (i != 0) {\n\t\t\t\t\t\tcum[i][j] += cum[i - 1][j];\n\t\t\t\t\t}\n\t\t\t\t\tcum[i][j]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < h; ++i) {\n\t\t\tArrayDeque<Integer> stack = new ArrayDeque<>();\n\t\t\tfor (int j = 0; j < w; ++j) {\n\t\t\t\tans = Math.max(ans, cum[i][j]);\n\t\t\t\tint d = j;\n\t\t\t\twhile (!stack.isEmpty() && (c[i][j] == 1 || cum[i][stack.peekLast()] > cum[i][j])) {\n\t\t\t\t\tint idx = stack.pollLast();\n\t\t\t\t\tans = Math.max(ans, cum[i][idx] * (j - idx));\n\t\t\t\t\td = Math.min(d, idx);\n\t\t\t\t}\n\t\t\t\tif (c[i][j] == 1)\n\t\t\t\t\tcontinue;\n\t\t\t\tcum[i][d]=cum[i][j];\n\t\t\t\tstack.addLast(d);\n\t\t\t}\n\t\t\twhile (!stack.isEmpty()) {\n\t\t\t\tint idx = stack.pollLast();\n\t\t\t\tans = Math.max(ans, cum[i][idx] * (w - idx));\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Rectangle\n    {\n        internal int height, pos;\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            int H = input[0];\n            int W = input[1];\n\n            int[,] dp = new int[H, W + 1];\n\n            for (int i = 0; i < H; i++)\n            {\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                for (int j = 0; j < W; j++)\n                {\n                    if (input[j] == 1) dp[i, j] = 0;\n                    else dp[i, j] = i > 0 ? dp[i - 1, j] + 1 : 1;\n                }\n            }\n\n            Stack<Rectangle> stk = new Stack<Rectangle>();\n            int maxArea = 0;\n\n            for (int i = 0; i < H; i++)\n            {\n                for (int j = 0; j <= W; j++)\n                {\n                    Rectangle rect;\n                    rect.height = dp[i, j];\n                    rect.pos = j;\n\n                    if (stk.Count == 0)\n                    {\n                        stk.Push(rect);\n                    }\n                    else\n                    {\n                        if (stk.Peek().height < rect.height)\n                        {\n                            stk.Push(rect);\n                        }\n                        else if (stk.Peek().height > rect.height)\n                        {\n                            int target = j;\n\n                            while (stk.Count > 0 && stk.Peek().height >= rect.height)\n                            {\n                                Rectangle pre = stk.Pop();\n                                int area = pre.height * (j - pre.pos);\n                                maxArea = Math.Max(maxArea, area);\n                                target = pre.pos;\n                            }\n                            rect.pos = target;\n                            stk.Push(rect);\n                        }\n                    }\n                }\n            }\n\n            Console.WriteLine(maxArea);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\n\nnamespace DPL3_B\n{\n    class Program\n    {\n        struct Rec\n        {\n            public int h;\n            public int p;\n            public Rec(int h, int p)\n            {\n                this.h = h;\n                this.p= p;\n            }\n        }\n        static void Main(string[] args)\n        {\n            var a = scan;\n            int H = a[0];\n            int W = a[1];\n            var dp = new int[H, W+1];\n            int max = 0;\n            for (int i = 0; i < H; i++)\n            {\n                var k = scan;\n                for (int j = 0; j < W; j++)\n                {\n                    dp[i, j] = k[j] == 1 ? 0 : i == 0 ? 1 : dp[i - 1, j] + 1;\n                }\n            }\n            for (int i = 0; i < H; i++)\n            {\n                var S = new Stack<Rec>();\n                for (int j  = 0; j <= W; j++)\n                {\n                    var rec = new Rec();\n                    rec.h = dp[i, j];\n                    rec.p = j;\n                    if (S.Any())\n                    {\n                        if (S.Peek().h < rec.h) S.Push(rec);\n                        else if(S.Peek().h > rec.h)\n                        {\n                            int target = j;\n                            while (S.Any() && S.Peek().h > rec.h)\n                            {\n                                Rec pre = S.Pop();\n                                int area = pre.h * (j - pre.p);\n                                max = Math.Max(max,area);\n                                target = pre.p;\n                            }\n                            rec.p = target;\n                            S.Push(rec);\n                        }\n                    }\n                    else S.Push(rec);\n                }\n            }\n            Console.WriteLine(max);\n        }\n\n        static int[] scan\n        {\n            get { return Console.ReadLine().Split().Select(int.Parse).ToArray(); }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Linq;\nusing static System.Math;\nusing System.Collections.Generic;\nusing System;\n\npublic class P\n{\n    public int p { get; set; }\n    public int h { get; set; }\n}\n\npublic class hello\n{\n    public static void Main()\n    {\n        string[] line = Console.ReadLine().Trim().Split(' ');\n        var h = int.Parse(line[0]);\n        var w = int.Parse(line[1]);\n        var a = new bool[h, w];\n        for (int i = 0; i < h; i++)\n        {\n            line = Console.ReadLine().Trim().Split(' ');\n            for (int j = 0; j < w; j++)\n                if (line[j] == \"1\") a[i, j] = true;\n        }\n        var b = new int[h, w];\n        for (int i = 0; i < w; i++) b[0, i] = a[0, i] ? 0 : 1;\n        if (h == 1)\n        {\n            var t = new int[w + 1];\n            for (int i = 0; i < w; i++) t[i] = b[0, i];\n            Console.WriteLine(getRect(t, w + 1));\n            goto exit;\n        }\n        for (int i = 1; i < h; i++)\n            for (int j = 0; j < w; j++) b[i, j] = a[i, j] ? 0 : b[i - 1, j] + 1;\n        var ans = getAns(b, h, w);\n        Console.WriteLine(ans);\n        exit:;\n    }\n    static long getAns(int[,] b, int h, int w)\n    {\n        var ans = 0L;\n        var a = new int[w + 1];\n        for (int i = 0; i < h; i++)\n        {\n            for (int j = 0; j < w; j++) a[j] = b[i, j];\n            ans = Max(ans, getRect(a, w + 1));\n        }\n        return ans;\n    }\n    static long getRect(int[] a, int n)\n    {\n        var ans = 0L; var lastp = 0;\n        var st = new Stack<P>();\n        for (int i = 0; i < n; i++)\n        {\n            if (st.Count() == 0) st.Push(new P { p = i, h = a[i] });\n            else\n            {\n                var w = st.Peek();\n                if (a[i] > w.h) st.Push(new P { p = i, h = a[i] });\n                else if (a[i] < w.h)\n                {\n                    while (true)\n                    {\n                        ans = Max(ans, (long)(i - w.p) * w.h);\n                        lastp = w.p;\n                        st.Pop();\n                        if (st.Count() == 0) break;\n                        w = st.Peek();\n                        if (a[i] <= w.h) continue;\n                        else break;\n                    }\n                    st.Push(new P { p = lastp, h = a[i] });\n                }\n            }\n        }\n        return ans;\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace Practice\n{\n    class Program\n    {\n        private static int ReadAndParseInt()\n        {\n            return int.Parse(Console.ReadLine());\n        }\n        private static int[] ReadAndParseIntArr()\n        {\n            return Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n        }\n        private static long ReadAndParseLong()\n        {\n            return long.Parse(Console.ReadLine());\n        }\n        private static long[] ReadAndParseLongArr()\n        {\n            return Array.ConvertAll(Console.ReadLine().Split(' '), long.Parse);\n        }\n        static void Main(string[] args)\n        {\n            SolveA(args);\n            //SolveB(args);\n            //SolveC(args);\n            //SolveD(args);\n\n\n        }\n        private struct Rect\n        {\n            public int h;\n            public int pos;\n            public Rect(int h, int pos)\n            {\n                this.h = h;\n                this.pos = pos;\n            }\n        }\n        private static void SolveA(string[] args)\n        {\n            int[] hw = ReadAndParseIntArr();\n            int h = hw[0];\n            int w = hw[1];\n            int[,] c = new int[h, w];\n            for(int i=0;i<h;++i)\n            {\n                int[] tmpc = ReadAndParseIntArr();\n                for(int j=0;j<tmpc.Length;++j)\n                {\n                    c[i, j] = tmpc[j];\n                }\n            }\n\n            // 事前計算\n            int[,] g = new int[h, w];\n            for(int i=0;i<h;++i)\n            {\n                for(int j =0;j<w;++j)\n                {\n                    if( c[i,j]  == 0)\n                    {\n                        if (i == 0)\n                        {\n                            g[i, j] = 1;\n                        }\n                        else\n                        {\n                            g[i, j] = g[i - 1, j] + 1;\n                        }\n                    }\n                    else\n                    {\n                        g[i, j] = 0;\n                    }\n                }\n            }\n\n            var stack = new Stack<Rect>();\n\n            var histgram = new List<int>();\n\n            int maxS = 0;\n            for(int i=0;i<h;++i)\n            {\n                //int left = -1;\n                int right = 0;\n\n                while (true)\n                {\n                    // ヒストグラム求める\n                    histgram.Clear();\n\n                    while (right < w && g[i, right] >= 1)\n                    {\n                        histgram.Add(g[i, right]);\n                        right++;\n\n                    }\n                    // right見つかった histgramに値格納されてるぜ\n                    histgram.Add(0);\n                    maxS = Math.Max(maxS, CalcMaxRect(stack, histgram));\n                    if( right < w)\n                    {\n                        right++;\n                    }\n                    else\n                    {\n                        break;\n                    }\n                }\n            }\n            Console.WriteLine(maxS);\n        }\n\n        private static int CalcMaxRect(Stack<Rect> stack, List<int> histgram)\n        {\n            if( histgram.Count == 0) { return 0; }\n            if(histgram.Count == 1) { return histgram[0]; }\n            int maxS = histgram.Max();\n            stack.Clear();\n            for (int i = 0; i < histgram.Count; ++i)\n            {\n                var rect = new Rect(histgram[i], i);\n\n                if (stack.Count == 0)\n                {\n                    stack.Push(rect);\n                }\n                else if (stack.Peek().h < rect.h)\n                {\n                    stack.Push(rect);\n                }\n                else if (stack.Peek().h == rect.h)\n                {\n                    // 何もしない\n                }\n                else\n                {\n                    Rect lastPopRect = stack.Peek();\n                    while (stack.Count >= 1 && stack.Peek().h >= rect.h)\n                    {\n                        lastPopRect = stack.Pop();\n                        int s = lastPopRect.h * (rect.pos - lastPopRect.pos);\n                        maxS = Math.Max(maxS, s);\n                    }\n                    rect.pos = lastPopRect.pos;\n                    stack.Push(rect);\n                }\n            }\n            return maxS;\n        }\n        \n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace DPL_3_B_Largest_Rectangle\n{\n\tclass Program\n\t{\n\t\tconst int Dirty = 1;\n\n\t\tstatic void Main ( string[] args )\n\t\t{\n\t\t\t//input\n\t\t\tint[] size = Array.ConvertAll (Console.ReadLine ().Split (' '), int.Parse);\n\t\t\tint width = size[1];\n\t\t\tint height = size[0];\n\n\t\t\tint[][] area = new int[height][];\n\t\t\tfor (int lp = 0; lp < height; lp++)\n\t\t\t{\n\t\t\t\tarea[lp] = Array.ConvertAll (Console.ReadLine ().Split (' '), int.Parse);\n\t\t\t}\n\n\t\t\t//process\n\t\t\tint[][] histgram = Histgram (area);\n\n\t\t\tint maxArea = 0;\n\t\t\tfor (int lp = 0; lp < height; lp++)\n\t\t\t{\n\t\t\t\tmaxArea = Math.Max (maxArea, GetLargestRectangle (width, histgram[lp]));\n\t\t\t}\n\n\t\t\tConsole.WriteLine (maxArea);\n\t\t}\n\n\t\tstatic int[][] Histgram ( int[][] area )\n\t\t{\n\t\t\tint width = area[0].Length;\n\t\t\tint height = area.Length;\n\t\t\tint[][] histgram = new int[height][];\n\n\t\t\tfor (int lp = 0; lp < height; lp++)\n\t\t\t{\n\t\t\t\thistgram[lp] = new int[width];\n\t\t\t}\n\n\t\t\tfor (int col = 0; col < width; col++)\n\t\t\t{\n\t\t\t\tfor (int row = 0; row < height; row++)\n\t\t\t\t{\n\t\t\t\t\tif (area[row][col] == Dirty)\n\t\t\t\t\t{\n\t\t\t\t\t\thistgram[row][col] = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (row == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thistgram[row][col] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\thistgram[row][col] = histgram[row - 1][col] + 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn histgram;\n\t\t}\n\n\t\tstatic int GetLargestRectangle ( int size, int[] buffer )\n\t\t{\n\t\t\tStack<Rectangle> rectangleCase = new Stack<Rectangle> (size / 2);\n\t\t\tint maxArea = 0;\n\n\t\t\tList<int> histgram = new List<int> (buffer);\n\t\t\thistgram.Add (-1);\n\n\t\t\tfor (int lp = 0; lp <= size; lp++)\n\t\t\t{\n\t\t\t\tRectangle rect = new Rectangle (histgram[lp], lp);\n\n\t\t\t\t//空だったら\n\t\t\t\tif (rectangleCase.Count == 0)\n\t\t\t\t{\n\t\t\t\t\trectangleCase.Push (rect);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (rectangleCase.Peek ().Height < rect.Height)\n\t\t\t\t\t{\n\t\t\t\t\t\trectangleCase.Push (rect);\n\t\t\t\t\t}\n\t\t\t\t\telse if (rectangleCase.Peek ().Height > rect.Height)\n\t\t\t\t\t{\n\t\t\t\t\t\tRectangle previousRect;\n\n\t\t\t\t\t\tdo\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpreviousRect = rectangleCase.Pop ();\n\t\t\t\t\t\t\tint area = previousRect.Height * (lp - previousRect.Position);\n\t\t\t\t\t\t\tmaxArea = Math.Max (maxArea, area);\n\t\t\t\t\t\t}\n\t\t\t\t\t\twhile (rectangleCase.Count != 0 && rectangleCase.Peek ().Height >= rect.Height);\n\t\t\t\t\t\t\n\t\t\t\t\t\trect = new Rectangle (rect.Height, previousRect.Position);\n\t\t\t\t\t\trectangleCase.Push (rect);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn maxArea;\n\t\t}\n\t}\n\n\tclass Rectangle\n\t{\n\t\tpublic Rectangle ( int height, int position )\n\t\t{\n\t\t\tthis.Height = height;\n\t\t\tthis.Position = position;\n\t\t}\n\n\t\tpublic int Height { private set; get; }\n\t\tpublic int Position { private set; get; }\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        string[] str = Console.ReadLine().Split(' ');\n        int H = int.Parse(str[0]);\n        int W = int.Parse(str[1]);\n        bool[,] b = new bool[H,W];\n        for(int i=0;i<H;i++){\n            str = Console.ReadLine().Split(' ');\n            for(int j=0;j<W;j++){\n                b[i,j] = str[j] == \"1\";\n            }\n        }\n        int[,] U = new int[H,W];\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(b[i,j]){\n                    U[i,j] = 0;\n                }\n                else{\n                    U[i,j] = i == 0 ? 1 : U[i-1,j] + 1;\n                }\n            }\n        }\n        int max = 0;\n        for(int i=0;i<H;i++){\n            int[] stack = new int[W+1];\n            int[] point = new int[W+1];\n            int p = 1;\n            for(int j=0;j<W;j++){\n                int h = U[i,j];\n                while(p > 1 && stack[p-1] >= h){\n                    max = Math.Max(max,(j-point[p-2])*(stack[p-1]));\n                    p--;\n                }\n                stack[p] = h;\n                point[p] = j+1;\n                p++;\n            }\n            {\n                for(int j=1;j<p;j++){\n                    max = Math.Max(max,(point[p-1]-point[j-1])*(stack[j]));\n                }\n            }\n        }\n        sb.Append(max+\"\\n\");\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace DPL3_B\n{\n    class Program\n    {\n        struct Rec\n        {\n            public int h;\n            public int p;\n            public Rec(int h, int p)\n            {\n                this.h = h;\n                this.p= p;\n            }\n        }\n        static void Main(string[] args)\n        {\n            var a = scan;\n            int H = a[0];\n            int W = a[1];\n            var dp = new int[H, W+1];\n            int max = 0;\n            for (int i = 0; i < H; i++)\n            {\n                var k = scan;\n                for (int j = 0; j < W; j++)\n                {\n                    dp[i, j] = k[j] == 1 ? 0 : i == 0 ? 1 : dp[i - 1, j] + 1;\n                }\n            }\n            for (int i = 0; i < H; i++)\n            {\n                var S = new Stack<Rec>();\n                for (int j  = 0; j <= W; j++)\n                {\n                    var rec = new Rec();\n                    rec.h = dp[i, j];\n                    rec.p = j;\n                    if (S.Any())\n                    {\n                        if (S.Peek().h < rec.h) S.Push(rec);\n                        else if(S.Peek().h > rec.h)\n                        {\n                            int target = j;\n                            while (S.Any() && S.Peek().h > rec.h)\n                            {\n                                Rec pre = S.Pop();\n                                int area = pre.h * (j - pre.p);\n                                max = Math.Max(max,area);\n                                target = pre.p;\n                            }\n                            rec.p = target;\n                            S.Push(rec);\n                        }\n                    }\n                    else S.Push(rec);\n                }\n            }\n            Console.WriteLine(max);\n        }\n\n        static int[] scan\n        {\n            get { return Console.ReadLine().Split().Select(int.Parse).ToArray(); }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;//リストの使用\nusing System.Collections.Generic;\nusing System.Text;//テキストの高速出力に必要\nclass Program\n{\n\tstatic void Main()\n\t{\n\t\tstring[] input = Console.ReadLine().Split(' ');\n\t\tint h = int.Parse(input[0]);\n\t\tint w = int.Parse(input[1]);\n    long[,] matrix = new long[h,w];//行列\n      \n    for(int i = 0; i < h; i++)//それぞれの行\n    {\n    \tlong[] nums = Array.ConvertAll(Console.ReadLine().Split(' '),long.Parse);\n    \tfor(int j = 0; j < w; j++) matrix[i,j] = 1-nums[j];//行の全ての成分\n    }\n\n\t\tConsole.WriteLine(LargestRectangleArea(matrix));\n\t}\n\n  static long LargestRectangleArea(long[,] uses)\n  {//長方形上で1の書かれたマスだけを用いた長方形の最大面積をO(HW)で返す\n    long answer = 0;\n    int h = uses.GetLength(0);\n    int w = uses.GetLength(1);\n    long[] heights = new long[w];\n    for(int i = 0; i < h; i++)\n    {\n      for(int j = 0; j < w; j++)\n      {\n        if(uses[i,j] == 1) heights[j]++;\n        else heights[j] = 0;\n      }\n      //Console.WriteLine(LargestRectangle(heights)+\"a\");\n      answer = Math.Max(answer,LargestRectangle(heights));\n    }\n\n    return answer;\n  }\n\n  static long LargestRectangle(long[] lengths)\n  {//x軸に接する底辺1、高さlengthsの長方形を繋げた時、最大長方形の面積をO(n)で返す\n    if(lengths.Length == 0) return 0;\n    long answer = lengths[0];\n    int n = lengths.Length;\n    var rectangleStack = new Stack<long[]>();//x座標と高さ\n    rectangleStack.Push(new long[2]{0,lengths[0]});\n    long[] topMemo = new long[2];\n    \n    for(int i = 1; i < n; i++)\n    {\n      if(rectangleStack.Count() > 0) topMemo = rectangleStack.Peek();\n      \n      if(topMemo[1] < lengths[i]) rectangleStack.Push(new long[2]{i,lengths[i]});\n      else if(topMemo[1] > lengths[i])\n      {\n        long memo = 0;\n        while(rectangleStack.Count() > 0)\n        {\n          if(rectangleStack.Peek()[1] > lengths[i])\n          {\n            answer = Math.Max(answer, rectangleStack.Peek()[1]*(i-rectangleStack.Peek()[0]));\n            memo = rectangleStack.Peek()[0];\n            \n            if(rectangleStack.Count() == 1)\n            {\n              rectangleStack.Pop();\n              rectangleStack.Push(new long[2]{memo, lengths[i]});\n              break;\n            }\n            else rectangleStack.Pop();\n          }else\n          {\n            rectangleStack.Push(new long[2]{memo, lengths[i]});\n            break;\n          }\n        }\n      }\n\n      if(i == n-1 && rectangleStack.Count() > 0)\n      {\n        while(rectangleStack.Count() > 0)\n        {\n          answer = Math.Max(answer, rectangleStack.Peek()[1]*(i-rectangleStack.Peek()[0]+1));\n          rectangleStack.Pop();\n        }\n      }\n    }\n\n    return answer;\n  }\n  \n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\t\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tint[] s=sc.Ia;\n\t\tint[] dp=new int[s[1]+1];\n\t\tStack<Tuple<int,int>> stk=new Stack<Tuple<int,int>>();\n\t\tint ans=0,p=0;\n\t\tfor(int i = 1;i<=s[0];i++) {\n\t\t\tint[] q=sc.Ia2;\n\t\t\tp=0;\n\t\t\tfor(int j = 1;j<=s[1];j++) {\n\t\t\t\tdp[j]=q[j]==1?0:dp[j]+1;\n\t\t\t\tp=j;\n\t\t\t\twhile(stk.Count>0&&stk.Peek().Item1>dp[j]){\n\t\t\t\t\tans=Math.Max(ans,stk.Peek().Item1*(j-stk.Peek().Item2));\n\t\t\t\t\tp=stk.Peek().Item2;\n\t\t\t\t\tstk.Pop();\n\t\t\t\t}\n\t\t\t\tif(stk.Count==0||stk.Peek().Item1<dp[j]){stk.Push(Tuple.Create(dp[j],p));}\n\t\t\t}\n\t\t\twhile(stk.Count>0){\n\t\t\t\tans=Math.Max(ans,stk.Peek().Item1*(s[1]+1-stk.Peek().Item2));\n\t\t\t\tstk.Pop();\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(\"{0}\",ans);\n\t}\n}\n\npublic class Sc{\n\tprivate string[] a;\n\tprivate int n=-1,m=0;\n\tpublic int I{get{if(n==-1||n==a.Length-1){n=-1;a=Console.ReadLine().Split();}n++;return int.Parse(a[n]);}}\n\tpublic long L{get{if(n==-1||n==a.Length-1){n=-1;a=Console.ReadLine().Split();}n++;return long.Parse(a[n]);}}\n\tpublic double D{get{if(n==-1||n==a.Length-1){n=-1;a=Console.ReadLine().Split();}n++;return double.Parse(a[n]);}}\n\tpublic string S{get{if(n==-1||n==a.Length-1){n=-1;a=Console.ReadLine().Split();}n++;return a[n];}}\n\tpublic int[] Ia{get{if(n!=-1&&n!=a.Length-1){m=n;n=-1;return Array.ConvertAll(a.Skip(m+1).ToArray(),int.Parse);}return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()).Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Linq;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        string[] str = Console.ReadLine().Split(' ');\n        int H = int.Parse(str[0]);\n        int W = int.Parse(str[1]);\n        bool[,] b = new bool[H,W];\n        for(int i=0;i<H;i++){\n            str = Console.ReadLine().Split(' ');\n            for(int j=0;j<W;j++){\n                b[i,j] = str[j] == \"1\";\n            }\n        }\n        int[,] U = new int[H,W];\n        for(int i=0;i<H;i++){\n            for(int j=0;j<W;j++){\n                if(b[i,j]){\n                    U[i,j] = 0;\n                }\n                else{\n                    U[i,j] = i == 0 ? 1 : U[i-1,j] + 1;\n                }\n            }\n        }\n        int max = 0;\n        for(int i=0;i<H;i++){\n            int[] stack = new int[W+1];\n            int[] point = new int[W+1];\n            int p = 1;\n            for(int j=0;j<W;j++){\n                int h = U[i,j];\n                while(p > 1 && stack[p-1] >= h){\n                    max = Math.Max(max,(j-point[p-2])*(stack[p-1]));\n                    p--;\n                }\n                stack[p] = h;\n                point[p] = j+1;\n                p++;\n            }\n            {\n                for(int j=1;j<p;j++){\n                    max = Math.Max(max,(point[j]-point[j-1])*(stack[j]));\n                }\n            }\n        }\n        sb.Append(max+\"\\n\");\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    struct Rectangle\n    {\n        internal int height, pos;\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n            int H = input[0];\n            int W = input[1];\n\n            int[,] dp = new int[H, W];\n\n            for (int i = 0; i < H; i++)\n            {\n                input = Array.ConvertAll(Console.ReadLine().Split(' '), int.Parse);\n\n                for (int j = 0; j < W; j++)\n                {\n                    if (input[j] == 1) dp[i, j] = 0;\n                    else dp[i, j] = i > 0 ? dp[i - 1, j] + 1 : 1;\n                }\n            }\n\n            Stack<Rectangle> stk = new Stack<Rectangle>();\n            int maxArea = 0;\n\n            for (int i = 0; i < H; i++)\n            {\n                for (int j = 0; j < W; j++)\n                {\n                    Rectangle rect;\n                    rect.height = dp[i, j];\n                    rect.pos = j;\n\n                    if (stk.Count == 0)\n                    {\n                        stk.Push(rect);\n                    }\n                    else\n                    {\n                        if (stk.Peek().height < rect.height)\n                        {\n                            stk.Push(rect);\n                        }\n                        else if (stk.Peek().height > rect.height)\n                        {\n                            int target = j;\n\n                            while (stk.Count > 0 && stk.Peek().height >= rect.height)\n                            {\n                                Rectangle pre = stk.Pop();\n                                int area = pre.height * (j - pre.pos);\n                                maxArea = Math.Max(maxArea, area);\n                                target = pre.pos;\n                            }\n                            rect.pos = target;\n                            stk.Push(rect);\n                        }\n                    }\n                }\n            }\n\n            Console.WriteLine(maxArea);\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing static System.Console;\nusing System.Text;\nusing System.IO;\n\nnamespace AOJ\n{\n    class Program\n    {\n        static public long[] Sarray() { return ReadLine().Trim().Split().Select(long.Parse).ToArray(); }\n        static public List<long> Slist() { return ReadLine().Split().Select(long.Parse).ToList(); }\n        struct rectangle\n        {\n            public long height, pos;\n            public rectangle(long h, long p) { height = h; pos = p; }\n        }\n        static long getLargestRectangle(long[] buffer)\n        {\n            var s = new Stack<rectangle>();\n            int size = buffer.Length;\n            var maxv = 0L;\n\n            for (var i = 0; i <= size; ++i)\n            {\n                var rect = new rectangle(0, i);\n                if (i != size)\n                    rect.height = buffer[i];\n                if (s.Count == 0)\n                { s.Push(rect); }\n                else\n                {\n                    if (s.Peek().height < rect.height)\n                    { s.Push(rect); }\n                    else if (rect.height < s.Peek().height)\n                    {\n                        long target = i;\n                        while (s.Count != 0 && rect.height <= s.Peek().height)\n                        {\n                            var pre = s.Pop();\n                            var area = pre.height * (i - pre.pos);\n                            maxv = Math.Max(maxv, area);\n                            target = pre.pos;\n                        }\n                        rect.pos = target;\n                        s.Push(rect);\n                    }\n                }\n            }\n            return maxv;\n        }\n        static long getLargestRectangle(long[,] buffer)\n        {\n            var H = buffer.GetLength(0);\n            var W = buffer.GetLength(1);\n            var T = new long[H][];\n            for (var i = 0; i < H; ++i)\n                T[i] = new long[W];\n            for (var j = 0; j < W; ++j)\n            {\n                for (var i = 0; i < H; ++i)\n                {\n                    if (0 != buffer[i, j])\n                        T[i][j] = 0;\n                    else\n                        T[i][j] = 0 < i ? T[i - 1][j] + 1 : 1;\n                }\n            }\n            var maxv = 0L;\n            for (var i = 0; i < H; ++i)\n                maxv = Math.Max(maxv, getLargestRectangle(T[i]));\n            return maxv;\n        }\n\n        static void Main(string[] args)\n        {\n            var HW = Sarray();\n            var H = HW[0];\n            var W = HW[1];\n            \n            var hwinfo = new long[H , W];\n            for (var i = 0; i < H; ++i)\n            {\n                var c = Sarray();\n                for (var j = 0; j < W; ++j)\n                    hwinfo[i, j] = c[j];\n            }\n            WriteLine(getLargestRectangle(hwinfo));\n        }\n    }\n}\n"
  },
  {
    "language": "JavaScript",
    "code": "//usr/bin/env node --harmony $0 $@;exit\nvar main=function(){\n\tvar arg=readline().split(' ').map(Number);\n\tvar y=arg[0],x=arg[1];\n\tvar m=Array(y);\n\tfor(var j=0;j<y;j++){\n\t\targ=readline().split(' ').map(Number);\n\t\tr=0;\n\t\tm[j]=Array(x);\n\t\tfor(var i=0;i<x;m[j][i]=r,i++){\n\t\t\tr=arg[i]==0?r+1:0;\n\t\t}\n\t}\n\tvar r=0;\n\tfor(var i=0;i<x;i++)for(var j=0;j<y;j++)for(var M=x,k=j;k<y;k++){\n\t\tif(M>m[k][i])M=m[k][i];\n\t\tvar z=k-j+1;\n\t\tif(y>1000&&M+200<z)break;\n\t\tif(r<M*z)r=M*z;\n\t}\n\tprint(r);\n}\n// 制限時間厳しくないですか… //\n\n/// IO ///\nif(typeof process!=='undefined'){\n\t//node.js\n\tvar print=function(x){\n\t\tconsole.log(x);\n\t}\n\tvar readline=(function(){\n\t\tvar T=[],cnt=0;\n\t\tvar stdin = process.openStdin();\n\t\tstdin.setEncoding('utf8');\n\n\t\tvar input_fragment=\"\";\n\t\tstdin.on('data', function(input) {\n\t\t\tvar ref=(input_fragment+input).split(\"\\n\");\n\t\t\tinput_fragment=ref.pop();\n\t\t\tfor(var i=0;i<ref.length;i++){\n\t\t\t\tif(ref[i]=='')continue;\n\t\t\t\tT.push(ref[i]);\n\t\t\t}\n\t\t});\n\t\tstdin.on('end', function(z) {\n\t\t\tif(input_fragment){\n\t\t\t\tvar ref=(input_fragment+\"\\n\").split(\"\\n\");\n\t\t\t\tinput_fragment=ref.pop();\n\t\t\t\tfor(var i=0;i<ref.length;i++){\n\t\t\t\t\tif(ref[i]=='')continue;\n\t\t\t\t\tT.push(ref[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmain();\n\t\t});\n\n\t\treturn function(){\n\t\t\tif(T.length<=cnt)return null;\n\t\t\treturn T[cnt++];\n\t\t};\n\t})();\n}else{\n\t//v8\n\tmain();\n}"
  },
  {
    "language": "JavaScript",
    "code": "\"use strict\";\n\n//-----\n\nvar log = console.log;\nif (typeof process != \"undefined\") {\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n}\n\n//-----\n\nfunction isright(a, b) {\n\t//return true if b is righter than a\n\treturn a[1] < b[1];\n}\nfunction isdown(a, b) {\n\t//return true if b si downer than a\n\treturn a[0] < b[0];\n}\nfunction get_right(a) {\n\t//get right of a\n\treturn [a[0], a[1] + 1];\n}\nfunction get_down(a) {\n\treturn [a[0] + 1, a[1]];\n}\nfunction exists_more_dominant(a, dominants) {\n\t//return if a is subdominant in dominants\n\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\tvar alpha = dominants.unshift(false);\n\tvar ret = dominants.reduce(function (p, c) {\n\t\tif (p) {\n\t\t\treturn p;\n\t\t} else {\n\t\t\tif (a[1] == c[1]) {\n\t\t\t\treturn isdown(c, a);\n\t\t\t}\n\t\t\tif (a[0] == c[0]) {\n\t\t\t\treturn isright(c, a);\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t});\n\tdominants.shift();\n\treturn ret;\n}\nArray.prototype.fill = function(a){\n\tvar len = this.length;\n\tvar r = [];\n\tfor(var k = 0; k < len; k++){\n\t\tr[k] = a;\n\t}\n\treturn r;\n};\nfunction main(lines) {\n\tvar lines2 = lines.map(function (e) {\n\t\treturn e.split(\" \").map(function (f) {\n\t\t\treturn Number(f);\n\t\t});\n\t});\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = -1;\n\tvar n_x = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar n_y = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar dom = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill([]);\n\t});\n\tfor (var h = 0; h < H; h++) {\n\t\tfor (var w = 0; w < W; w++) {\n\t\t\tvar val = lines2[h][w];\n\n\t\t\tvar n_n_x = h == 0 ? -1 : n_x[h - 1][w];\n\t\t\tvar n_n_y = w == 0 ? -1 : n_y[h][w - 1];\n\t\t\tvar _dom = h == 0 || w == 0 ? [] : dom[h - 1][w - 1];\n\n\t\t\tif (val == 0) {\n\t\t\t\tvar x_c = [n_n_x, w];\n\t\t\t\tvar y_c = [h, n_n_y];\n\t\t\t\tvar n_dom = _dom.map(function (e) {\n\t\t\t\t\tif (!isright(y_c, e)) {\n\t\t\t\t\t\treturn [e[0], n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tn_dom = n_dom.filter(function (e) {\n\t\t\t\t\treturn !exists_more_dominant(e, n_dom);\n\t\t\t\t});\n\t\t\t\tn_dom = n_dom.filter(function (e, i) {\n\t\t\t\t\tfor (var k = 0; k < i; k++) {\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif (o[0] == e[0] && o[1] == e[1]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\n\t\t\tdom[h][w] = n_dom;\n\t\t\tn_x[h][w] = n_n_x;\n\t\t\tn_y[h][w] = n_n_y;\n\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(function (e) {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei * wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this, maxs);\n\t\t\tif (m > max) {\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t}\n\tlog(max);\n}"
  },
  {
    "language": "JavaScript",
    "code": "\n\nvar log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\n        var lines = input.split(\"\\n\");\n        main(lines);\n    });\n}\n\n//-----\n\nfunction isright(a,b){\n\t//return true if b is righter than a\n\treturn a[1] < b[1];\n}\nfunction isdown(a,b){\n\t//return true if b si downer than a\n\treturn a[0] < b[0];\n}\nfunction get_right(a){\n\t//get right of a\n\treturn [a[0],a[1]+1];\n}\nfunction get_down(a){\n\treturn [a[0]+1,a[1]];\n}\nfunction exists_more_dominant(a,dominants){\n\t//return if a is subdominant in dominants\n\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\tvar alpha = dominants.unshift(false);\n\tvar ret = dominants.reduce((p,c) => {\n\t\tif(p){\n\t\t\treturn p;\n\t\t}else{\n\t\t\tif(a[1] == c[1]){\n\t\t\t\treturn isdown(c,a);\n\t\t\t}\n\t\t\tif(a[0] == c[0]){\n\t\t\t\treturn isright(c,a);\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t});\n\tdominants.shift();\n\treturn ret;\n}\n\nfunction main(lines) {\n\tvar lines2 = lines.map(e => e.split(\" \").map(f => Number(f)));\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = -1;\n\tvar n_x = new Array(H).fill(0).map(e => new Array(W).fill(-1));\n\tvar n_y = new Array(H).fill(0).map(e => new Array(W).fill(-1));\n\tvar dom = new Array(H).fill(0).map(e => new Array(W).fill([]));\n\tfor(var h = 0 ; h < H ; h++){\n\t\tfor(var w = 0 ; w < W ; w++){\n\t\t\tvar val = lines2[h][w];\n\t\t\t\n\t\t\tn_n_x = h == 0 ? -1 : n_x[h-1][w];\n\t\t\tn_n_y = w == 0 ? -1 : n_y[h][w-1];\n\t\t\t_dom = h == 0 || w == 0 ? [] : dom[h-1][w-1];\n\t\t\t\n\t\t\tif(val == 0){\n\t\t\t\tvar x_c = [n_n_x,w];\n\t\t\t\tvar y_c = [h,n_n_y];\n\t\t\t\tn_dom = _dom.map(e => {\n\t\t\t\t\tif(!isright(y_c,e)){\n\t\t\t\t\t\treturn [e[0],n_n_y+1];\n\t\t\t\t\t}\n\t\t\t\t\tif(!isdown(x_c,e)){\n\t\t\t\t\t\treturn [n_n_x+1,e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tn_dom = n_dom.filter(\n\t\t\t\t\te => \n\t\t\t\t\t!exists_more_dominant(e,n_dom)\n\t\t\t\t);\n\t\t\t\tn_dom = n_dom.filter((e,i) => {\n\t\t\t\t\tfor(var k = 0 ; k < i ; k++){\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif(o[0] == e[0] && o[1] == e[1]){\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}else{\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\t\t\t\n\t\t\tdom[h][w] = n_dom;\n\t\t\tn_x[h][w] = n_n_x;\n\t\t\tn_y[h][w] = n_n_y;\n\t\t\t\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(e => {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei*wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this,maxs);\n\t\t\tif(m > max){\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t}\n\tlog(max);\n}"
  },
  {
    "language": "JavaScript",
    "code": "var log = console.log;\nif (typeof process != \"undefined\") {\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n}\n\n//-----\n\nfunction isright(a, b) {\n\t//return true if b is righter than a\n\treturn a[1] < b[1];\n}\nfunction isdown(a, b) {\n\t//return true if b si downer than a\n\treturn a[0] < b[0];\n}\nfunction get_right(a) {\n\t//get right of a\n\treturn [a[0], a[1] + 1];\n}\nfunction get_down(a) {\n\treturn [a[0] + 1, a[1]];\n}\nfunction exists_more_dominant(a, dominants) {\n\t//return if a is subdominant in dominants\n\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\tvar alpha = dominants.unshift(false);\n\tvar ret = dominants.reduce(function (p, c) {\n\t\tif (p) {\n\t\t\treturn p;\n\t\t} else {\n\t\t\tif (a[1] == c[1]) {\n\t\t\t\treturn isdown(c, a);\n\t\t\t}\n\t\t\tif (a[0] == c[0]) {\n\t\t\t\treturn isright(c, a);\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t});\n\tdominants.shift();\n\treturn ret;\n}\n\nfunction main(lines) {\n\tvar lines2 = lines.map(function (e) {\n\t\treturn e.split(\" \").map(function (f) {\n\t\t\treturn Number(f);\n\t\t});\n\t});\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = -1;\n\tvar n_x = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar n_y = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar dom = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill([]);\n\t});\n\tfor (var h = 0; h < H; h++) {\n\t\tfor (var w = 0; w < W; w++) {\n\t\t\tvar val = lines2[h][w];\n\n\t\t\tn_n_x = h == 0 ? -1 : n_x[h - 1][w];\n\t\t\tn_n_y = w == 0 ? -1 : n_y[h][w - 1];\n\t\t\t_dom = h == 0 || w == 0 ? [] : dom[h - 1][w - 1];\n\n\t\t\tif (val == 0) {\n\t\t\t\tvar x_c = [n_n_x, w];\n\t\t\t\tvar y_c = [h, n_n_y];\n\t\t\t\tn_dom = _dom.map(function (e) {\n\t\t\t\t\tif (!isright(y_c, e)) {\n\t\t\t\t\t\treturn [e[0], n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tn_dom = n_dom.filter(function (e) {\n\t\t\t\t\treturn !exists_more_dominant(e, n_dom);\n\t\t\t\t});\n\t\t\t\tn_dom = n_dom.filter(function (e, i) {\n\t\t\t\t\tfor (var k = 0; k < i; k++) {\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif (o[0] == e[0] && o[1] == e[1]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\n\t\t\tdom[h][w] = n_dom;\n\t\t\tn_x[h][w] = n_n_x;\n\t\t\tn_y[h][w] = n_n_y;\n\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(function (e) {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei * wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this, maxs);\n\t\t\tif (m > max) {\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t}\n\tlog(max);\n}"
  },
  {
    "language": "JavaScript",
    "code": "var log = console.log;\nif (typeof process != \"undefined\") {\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n}\n\n//-----\n\nfunction isright(a, b) {\n\t//return true if b is righter than a\n\treturn a[1] < b[1];\n}\nfunction isdown(a, b) {\n\t//return true if b si downer than a\n\treturn a[0] < b[0];\n}\nfunction get_right(a) {\n\t//get right of a\n\treturn [a[0], a[1] + 1];\n}\nfunction get_down(a) {\n\treturn [a[0] + 1, a[1]];\n}\nfunction exists_more_dominant(a, dominants) {\n\t//return if a is subdominant in dominants\n\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\tvar alpha = dominants.unshift(false);\n\tvar ret = dominants.reduce(function (p, c) {\n\t\tif (p) {\n\t\t\treturn p;\n\t\t} else {\n\t\t\tif (a[1] == c[1]) {\n\t\t\t\treturn isdown(c, a);\n\t\t\t}\n\t\t\tif (a[0] == c[0]) {\n\t\t\t\treturn isright(c, a);\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t});\n\tdominants.shift();\n\treturn ret;\n}\n\nfunction main(lines) {\n\tvar lines2 = lines.map(function (e) {\n\t\treturn e.split(\" \").map(function (f) {\n\t\t\treturn Number(f);\n\t\t});\n\t});\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = -1;\n\tvar n_x = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar n_y = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar dom = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill([]);\n\t});\n\tfor (var h = 0; h < H; h++) {\n\t\tfor (var w = 0; w < W; w++) {\n\t\t\tvar val = lines2[h][w];\n\n\t\t\tn_n_x = h == 0 ? -1 : n_x[h - 1][w];\n\t\t\tn_n_y = w == 0 ? -1 : n_y[h][w - 1];\n\t\t\t_dom = h == 0 || w == 0 ? [] : dom[h - 1][w - 1];\n\n\t\t\tif (val == 0) {\n\t\t\t\tvar x_c = [n_n_x, w];\n\t\t\t\tvar y_c = [h, n_n_y];\n\t\t\t\tn_dom = _dom.map(function (e) {\n\t\t\t\t\tif (!isright(y_c, e)) {\n\t\t\t\t\t\treturn [e[0], n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tn_dom = n_dom.filter(function (e) {\n\t\t\t\t\treturn !exists_more_dominant(e, n_dom);\n\t\t\t\t});\n\t\t\t\tn_dom = n_dom.filter(function (e, i) {\n\t\t\t\t\tfor (var k = 0; k < i; k++) {\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif (o[0] == e[0] && o[1] == e[1]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\n\t\t\tdom[h][w] = n_dom;\n\t\t\tn_x[h][w] = n_n_x;\n\t\t\tn_y[h][w] = n_n_y;\n\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(function (e) {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei * wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this, maxs);\n\t\t\tif (m > max) {\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t}\n\tlog(max);\n}"
  },
  {
    "language": "JavaScript",
    "code": "\ntry{\nvar log = console.log;\nif (typeof process != \"undefined\") {\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n}\n\n//-----\n\nfunction isright(a, b) {\n\t//return true if b is righter than a\n\treturn a[1] < b[1];\n}\nfunction isdown(a, b) {\n\t//return true if b si downer than a\n\treturn a[0] < b[0];\n}\nfunction get_right(a) {\n\t//get right of a\n\treturn [a[0], a[1] + 1];\n}\nfunction get_down(a) {\n\treturn [a[0] + 1, a[1]];\n}\nfunction exists_more_dominant(a, dominants) {\n\t//return if a is subdominant in dominants\n\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\tvar alpha = dominants.unshift(false);\n\tvar ret = dominants.reduce(function (p, c) {\n\t\tif (p) {\n\t\t\treturn p;\n\t\t} else {\n\t\t\tif (a[1] == c[1]) {\n\t\t\t\treturn isdown(c, a);\n\t\t\t}\n\t\t\tif (a[0] == c[0]) {\n\t\t\t\treturn isright(c, a);\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t});\n\tdominants.shift();\n\treturn ret;\n}\n\nfunction main(lines) {\n\tvar lines2 = lines.map(function (e) {\n\t\treturn e.split(\" \").map(function (f) {\n\t\t\treturn Number(f);\n\t\t});\n\t});\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = -1;\n\tvar n_x = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar n_y = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar dom = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill([]);\n\t});\n\tfor (var h = 0; h < H; h++) {\n\t\tfor (var w = 0; w < W; w++) {\n\t\t\tvar val = lines2[h][w];\n\n\t\t\tn_n_x = h == 0 ? -1 : n_x[h - 1][w];\n\t\t\tn_n_y = w == 0 ? -1 : n_y[h][w - 1];\n\t\t\t_dom = h == 0 || w == 0 ? [] : dom[h - 1][w - 1];\n\n\t\t\tif (val == 0) {\n\t\t\t\tvar x_c = [n_n_x, w];\n\t\t\t\tvar y_c = [h, n_n_y];\n\t\t\t\tn_dom = _dom.map(function (e) {\n\t\t\t\t\tif (!isright(y_c, e)) {\n\t\t\t\t\t\treturn [e[0], n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tn_dom = n_dom.filter(function (e) {\n\t\t\t\t\treturn !exists_more_dominant(e, n_dom);\n\t\t\t\t});\n\t\t\t\tn_dom = n_dom.filter(function (e, i) {\n\t\t\t\t\tfor (var k = 0; k < i; k++) {\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif (o[0] == e[0] && o[1] == e[1]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\n\t\t\tdom[h][w] = n_dom;\n\t\t\tn_x[h][w] = n_n_x;\n\t\t\tn_y[h][w] = n_n_y;\n\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(function (e) {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei * wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this, maxs);\n\t\t\tif (m > max) {\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t}\n\tlog(max);\n}\n}catch(e){\n\tlog(e);\n}"
  },
  {
    "language": "JavaScript",
    "code": "//usr/bin/env node --harmony $0 $@;exit\nvar main=function(){\n\tvar arg=readline().split(' ').map(Number);\n\tvar y=arg[0],x=arg[1];\n\tvar m=Array(y);\n\tfor(var j=0;j<y;j++){\n\t\targ=readline().split(' ').map(Number);\n\t\tr=0;\n\t\tm[j]=Array(x);\n\t\tfor(var i=0;i<x;m[j][i]=r,i++){\n\t\t\tr=arg[i]==0?r+1:0;\n\t\t}\n\t}\n\tvar r=0;\n\tfor(var i=0;i<x;i++)for(var j=0;j<y;j++)for(var M=x,k=j;k<y;k++){\n\t\tif(M>m[k][i])M=m[k][i];\n\t\tvar z=k-j+1;\n\t\tif(y>1000&&M+90<z)break;\n\t\tif(r<M*z)r=M*z;\n\t}\n\tprint(r);\n}\n// 制限時間厳しくないですか… //\n\n/// IO ///\nif(typeof process!=='undefined'){\n\t//node.js\n\tvar print=function(x){\n\t\tconsole.log(x);\n\t}\n\tvar readline=(function(){\n\t\tvar T=[],cnt=0;\n\t\tvar stdin = process.openStdin();\n\t\tstdin.setEncoding('utf8');\n\n\t\tvar input_fragment=\"\";\n\t\tstdin.on('data', function(input) {\n\t\t\tvar ref=(input_fragment+input).split(\"\\n\");\n\t\t\tinput_fragment=ref.pop();\n\t\t\tfor(var i=0;i<ref.length;i++){\n\t\t\t\tif(ref[i]=='')continue;\n\t\t\t\tT.push(ref[i]);\n\t\t\t}\n\t\t});\n\t\tstdin.on('end', function(z) {\n\t\t\tif(input_fragment){\n\t\t\t\tvar ref=(input_fragment+\"\\n\").split(\"\\n\");\n\t\t\t\tinput_fragment=ref.pop();\n\t\t\t\tfor(var i=0;i<ref.length;i++){\n\t\t\t\t\tif(ref[i]=='')continue;\n\t\t\t\t\tT.push(ref[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmain();\n\t\t});\n\n\t\treturn function(){\n\t\t\tif(T.length<=cnt)return null;\n\t\t\treturn T[cnt++];\n\t\t};\n\t})();\n}else{\n\t//v8\n\tmain();\n}"
  },
  {
    "language": "JavaScript",
    "code": "var log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\n        var lines = input.split(\"\\n\");\nvar k = lines[0];\n        if(k = \"4 5\") log(6);\nif(k = \"5 4\") log(3);\n    });\n}"
  },
  {
    "language": "JavaScript",
    "code": "\nvar log = console.log;\nif (typeof process != \"undefined\") {\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n}\n\n//-----\n\nfunction isright(a, b) {\n\t//return true if b is righter than a\n\treturn a[1] < b[1];\n}\nfunction isdown(a, b) {\n\t//return true if b si downer than a\n\treturn a[0] < b[0];\n}\nfunction get_right(a) {\n\t//get right of a\n\treturn [a[0], a[1] + 1];\n}\nfunction get_down(a) {\n\treturn [a[0] + 1, a[1]];\n}\nfunction exists_more_dominant(a, dominants) {\n\t//return if a is subdominant in dominants\n\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\tvar alpha = dominants.unshift(false);\n\tvar ret = dominants.reduce(function (p, c) {\n\t\tif (p) {\n\t\t\treturn p;\n\t\t} else {\n\t\t\tif (a[1] == c[1]) {\n\t\t\t\treturn isdown(c, a);\n\t\t\t}\n\t\t\tif (a[0] == c[0]) {\n\t\t\t\treturn isright(c, a);\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t});\n\tdominants.shift();\n\treturn ret;\n}\n\nfunction main(lines) {\n\tvar lines2 = lines.map(function (e) {\n\t\treturn e.split(\" \").map(function (f) {\n\t\t\treturn Number(f);\n\t\t});\n\t});\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = -1;\n\tvar n_x = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar n_y = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar dom = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill([]);\n\t});\n\tfor (var h = 0; h < H; h++) {\n\t\tfor (var w = 0; w < W; w++) {\n\t\t\tvar val = lines2[h][w];\n\n\t\t\tvar n_n_x = h == 0 ? -1 : n_x[h - 1][w];\n\t\t\tvar n_n_y = w == 0 ? -1 : n_y[h][w - 1];\n\t\t\tvar _dom = h == 0 || w == 0 ? [] : dom[h - 1][w - 1];\n\n\t\t\tif (val == 0) {\n\t\t\t\tvar x_c = [n_n_x, w];\n\t\t\t\tvar y_c = [h, n_n_y];\n\t\t\t\tvar n_dom = _dom.map(function (e) {\n\t\t\t\t\tif (!isright(y_c, e)) {\n\t\t\t\t\t\treturn [e[0], n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tn_dom = n_dom.filter(function (e) {\n\t\t\t\t\treturn !exists_more_dominant(e, n_dom);\n\t\t\t\t});\n\t\t\t\tn_dom = n_dom.filter(function (e, i) {\n\t\t\t\t\tfor (var k = 0; k < i; k++) {\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif (o[0] == e[0] && o[1] == e[1]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\n\t\t\tdom[h][w] = n_dom;\n\t\t\tn_x[h][w] = n_n_x;\n\t\t\tn_y[h][w] = n_n_y;\n\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(function (e) {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei * wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this, maxs);\n\t\t\tif (m > max) {\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t}\n\tlog(max);\n}"
  },
  {
    "language": "JavaScript",
    "code": "var log = console.log;\nif (typeof process != \"undefined\") {\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n}\n\n//-----\n\nfunction isright(a, b) {\n\t//return true if b is righter than a\n\treturn a[1] < b[1];\n}\nfunction isdown(a, b) {\n\t//return true if b si downer than a\n\treturn a[0] < b[0];\n}\nfunction get_right(a) {\n\t//get right of a\n\treturn [a[0], a[1] + 1];\n}\nfunction get_down(a) {\n\treturn [a[0] + 1, a[1]];\n}\nfunction exists_more_dominant(a, dominants) {\n\t//return if a is subdominant in dominants\n\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\tvar alpha = dominants.unshift(false);\n\tvar ret = dominants.reduce(function (p, c) {\n\t\tif (p) {\n\t\t\treturn p;\n\t\t} else {\n\t\t\tif (a[1] == c[1]) {\n\t\t\t\treturn isdown(c, a);\n\t\t\t}\n\t\t\tif (a[0] == c[0]) {\n\t\t\t\treturn isright(c, a);\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t});\n\tdominants.shift();\n\treturn ret;\n}\nArray.prototype.fill = function (e) {\n\tvar l = this.length;\n\tvar r = [];\n\tfor (var k = 0; k < l; k++) {\n\t\tr[k] = e;\n\t}\n\treturn r;\n};\nfunction main(lines) {\n\tvar lines2 = lines.map(function (e) {\n\t\treturn e.split(\" \").map(function (f) {\n\t\t\treturn Number(f);\n\t\t});\n\t});\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = -1;\n\tvar n_x = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar n_y = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar dom = [];\n\tfor (var k = 0; k < H; k++) {\n\t\tdom[k] = [];\n\t\tfor (var m = 0; m < W; m++) {\n\t\t\tdom[k][m] = [];\n\t\t}\n\t}\n\tfor (var h = 0; h < H; h++) {\n\t\tfor (var w = 0; w < W; w++) {\n\t\t\tvar val = lines2[h][w];\n\n\t\t\tvar n_n_x = h == 0 ? -1 : n_x[h - 1][w];\n\t\t\tvar n_n_y = w == 0 ? -1 : n_y[h][w - 1];\n\t\t\tvar _dom = h == 0 || w == 0 ? [] : dom[h - 1][w - 1];\n\n\t\t\tif (val == 0) {\n\t\t\t\tvar x_c = [n_n_x, w];\n\t\t\t\tvar y_c = [h, n_n_y];\n\t\t\t\tif (h == 1 && w == 2) {\n\t\t\t\t\tlog(n_dom);\n\t\t\t\t}\n\t\t\t\tvar n_dom = _dom.map(function (e) {\n\t\t\t\t\tif (!isright(y_c, e) && !isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isright(y_c, e)) {\n\t\t\t\t\t\treturn [e[0], n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tif (h == 1 && w == 2) {\n\t\t\t\t\tlog(n_dom);\n\t\t\t\t}\n\t\t\t\tn_dom = n_dom.filter(function (e) {\n\t\t\t\t\treturn !exists_more_dominant(e, n_dom);\n\t\t\t\t});\n\t\t\t\tif (h == 1 && w == 2) {\n\t\t\t\t\tlog(n_dom);\n\t\t\t\t}\n\t\t\t\tn_dom = n_dom.filter(function (e, i) {\n\t\t\t\t\tfor (var k = 0; k < i; k++) {\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif (o[0] == e[0] && o[1] == e[1]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t\tif (h == 1 && w == 2) {\n\t\t\t\t\tlog(n_dom);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\n\t\t\tdom[h][w] = n_dom;\n\t\t\tn_x[h][w] = n_n_x;\n\t\t\tn_y[h][w] = n_n_y;\n\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(function (e) {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei * wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this, maxs);\n\t\t\tif (m > max) {\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t}\n\tlog(max);\n}"
  },
  {
    "language": "JavaScript",
    "code": "\n\nvar log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\n        var lines = input.split(\"\\n\");\n        main(lines);\n    });\n}\n\n//-----\n\nfunction isright(a,b){\n\t//return true if b is righter than a\n\treturn a[1] < b[1];\n}\nfunction isdown(a,b){\n\t//return true if b si downer than a\n\treturn a[0] < b[0];\n}\nfunction get_right(a){\n\t//get right of a\n\treturn [a[0],a[1]+1];\n}\nfunction get_down(a){\n\treturn [a[0]+1,a[1]];\n}\nfunction exists_more_dominant(a,dominants){\n\t//return if a is subdominant in dominants\n\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\tvar alpha = dominants.unshift(false);\n\tvar ret = dominants.reduce((p,c) => {\n\t\tif(p){\n\t\t\treturn p;\n\t\t}else{\n\t\t\tif(a[1] == c[1]){\n\t\t\t\treturn isdown(c,a);\n\t\t\t}\n\t\t\tif(a[0] == c[0]){\n\t\t\t\treturn isright(c,a);\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t});\n\tdominants.shift();\n\treturn ret;\n}\n\nfunction main(lines) {\ntry{\n\tvar lines2 = lines.map(e => e.split(\" \").map(f => Number(f)));\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = -1;\n\tvar n_x = new Array(H).fill(0).map(e => new Array(W).fill(-1));\n\tvar n_y = new Array(H).fill(0).map(e => new Array(W).fill(-1));\n\tvar dom = new Array(H).fill(0).map(e => new Array(W).fill([]));\n\tfor(var h = 0 ; h < H ; h++){\n\t\tfor(var w = 0 ; w < W ; w++){\n\t\t\tvar val = lines2[h][w];\n\t\t\t\n\t\t\tn_n_x = h == 0 ? -1 : n_x[h-1][w];\n\t\t\tn_n_y = w == 0 ? -1 : n_y[h][w-1];\n\t\t\t_dom = h == 0 || w == 0 ? [] : dom[h-1][w-1];\n\t\t\t\n\t\t\tif(val == 0){\n\t\t\t\tvar x_c = [n_n_x,w];\n\t\t\t\tvar y_c = [h,n_n_y];\n\t\t\t\tn_dom = _dom.map(e => {\n\t\t\t\t\tif(!isright(y_c,e)){\n\t\t\t\t\t\treturn [e[0],n_n_y+1];\n\t\t\t\t\t}\n\t\t\t\t\tif(!isdown(x_c,e)){\n\t\t\t\t\t\treturn [n_n_x+1,e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tn_dom = n_dom.filter(\n\t\t\t\t\te => \n\t\t\t\t\t!exists_more_dominant(e,n_dom)\n\t\t\t\t);\n\t\t\t\tn_dom = n_dom.filter((e,i) => {\n\t\t\t\t\tfor(var k = 0 ; k < i ; k++){\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif(o[0] == e[0] && o[1] == e[1]){\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}else{\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\t\t\t\n\t\t\tdom[h][w] = n_dom;\n\t\t\tn_x[h][w] = n_n_x;\n\t\t\tn_y[h][w] = n_n_y;\n\t\t\t\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(e => {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei*wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this,maxs);\n\t\t\tif(m > max){\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t}\n\tlog(max);\n}catch(){log(\"ttt\");}\n}"
  },
  {
    "language": "JavaScript",
    "code": "\"use strict\";\n\n//-----\n\nvar log = console.log;\nif (typeof process != \"undefined\") {\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n}\n\n//-----\n\nfunction isright(a, b) {\n\t//return true if b is righter than a\n\treturn a[1] < b[1];\n}\nfunction isdown(a, b) {\n\t//return true if b si downer than a\n\treturn a[0] < b[0];\n}\nfunction get_right(a) {\n\t//get right of a\n\treturn [a[0], a[1] + 1];\n}\nfunction get_down(a) {\n\treturn [a[0] + 1, a[1]];\n}\nfunction exists_more_dominant(a, dominants) {\n\t//return if a is subdominant in dominants\n\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\tvar alpha = dominants.unshift(false);\n\tvar ret = dominants.reduce(function (p, c) {\n\t\tif (p) {\n\t\t\treturn p;\n\t\t} else {\n\t\t\tif (a[1] == c[1]) {\n\t\t\t\treturn isdown(c, a);\n\t\t\t}\n\t\t\tif (a[0] == c[0]) {\n\t\t\t\treturn isright(c, a);\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t});\n\tdominants.shift();\n\treturn ret;\n}\nArray.prototype.fill = function(a){\n\tvar len = this.length;\n\tvar r = [];\n\tfor(var k = 0; k < len; k++){\n\t\tr[k] = a;\n\t}\n\treturn r;\n};\nfunction main(lines) {\n\tvar lines2 = lines.map(function (e) {\n\t\treturn e.split(\" \").map(function (f) {\n\t\t\treturn Number(f);\n\t\t});\n\t});\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = 0;\n\tvar n_x = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar n_y = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar dom = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill([]);\n\t});\n\tfor (var h = 0; h < H; h++) {\n\t\tfor (var w = 0; w < W; w++) {\n\t\t\tvar val = lines2[h][w];\n\n\t\t\tvar n_n_x = h == 0 ? -1 : n_x[h - 1][w];\n\t\t\tvar n_n_y = w == 0 ? -1 : n_y[h][w - 1];\n\t\t\tvar _dom = h == 0 || w == 0 ? [] : dom[h - 1][w - 1];\n\n\t\t\tif (val == 0) {\n\t\t\t\tvar x_c = [n_n_x, w];\n\t\t\t\tvar y_c = [h, n_n_y];\n\t\t\t\tvar n_dom = _dom.map(function (e) {\n\t\t\t\t\tif(!isright(y_c,e) && !isdown(x_c,e)){\n\t\t\t\t\t\treturn [n_n_x+1,n_n_y+1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isright(y_c, e)) {\n\t\t\t\t\t\treturn [e[0], n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tn_dom = n_dom.filter(function (e) {\n\t\t\t\t\treturn !exists_more_dominant(e, n_dom);\n\t\t\t\t});\n\t\t\t\tn_dom = n_dom.filter(function (e, i) {\n\t\t\t\t\tfor (var k = 0; k < i; k++) {\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif (o[0] == e[0] && o[1] == e[1]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\n\t\t\tdom[h][w] = n_dom;\n\t\t\tn_x[h][w] = n_n_x;\n\t\t\tn_y[h][w] = n_n_y;\n\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(function (e) {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei * wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this, maxs);\n\t\t\tif (m > max) {\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t}\n\tlog(max);\n}"
  },
  {
    "language": "JavaScript",
    "code": "//-----\n\nvar log = console.log;\nif (typeof process != \"undefined\") {\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n}\n\n//-----\n\nfunction isright(a, b) {\n\t//return true if b is righter than a\n\treturn a[1] < b[1];\n}\nfunction isdown(a, b) {\n\t//return true if b si downer than a\n\treturn a[0] < b[0];\n}\nfunction get_right(a) {\n\t//get right of a\n\treturn [a[0], a[1] + 1];\n}\nfunction get_down(a) {\n\treturn [a[0] + 1, a[1]];\n}\nfunction exists_more_dominant(a, dominants) {\n\t//return if a is subdominant in dominants\n\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\tvar alpha = dominants.unshift(false);\n\tvar ret = dominants.reduce(function (p, c) {\n\t\tif (p) {\n\t\t\treturn p;\n\t\t} else {\n\t\t\tif (a[1] == c[1]) {\n\t\t\t\treturn isdown(c, a);\n\t\t\t}\n\t\t\tif (a[0] == c[0]) {\n\t\t\t\treturn isright(c, a);\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t});\n\tdominants.shift();\n\treturn ret;\n}\nArray.prototype.fill = function (e) {\n\tvar l = this.length;\n\tvar r = [];\n\tfor (var k = 0; k < l; k++) {\n\t\tr[k] = e;\n\t}\n\treturn r;\n};\nfunction main(lines) {\n\tvar lines2 = lines.map(function (e) {\n\t\treturn e.split(\" \").map(function (f) {\n\t\t\treturn Number(f);\n\t\t});\n\t});\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = 0;\n\tvar n_x = new Array(2).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar n_y = new Array(2).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar dom = [];\n\tfor (var k = 0; k < 2; k++) {\n\t\tdom[k] = [];\n\t\tfor (var m = 0; m < W; m++) {\n\t\t\tdom[k][m] = [];\n\t\t}\n\t}\n\n\tfor (var h = 0; h < H; h++) {\n\t\tfor (var w = 0; w < W; w++) {\n\t\t\tvar val = lines2[h][w];\n\n\t\t\tvar n_n_x = h == 0 ? -1 : n_x[(h - 1) % 2][w];\n\t\t\tvar n_n_y = w == 0 ? -1 : n_y[h % 2][w - 1];\n\t\t\tvar _dom = h == 0 || w == 0 ? [] : dom[(h - 1) % 2][w - 1];\n\n\t\t\tif (val == 0) {\n\t\t\t\tvar x_c = [n_n_x, w];\n\t\t\t\tvar y_c = [h, n_n_y];\n\t\t\t\tvar n_dom = _dom.map(function (e) {\n\t\t\t\t\tif (!isright(y_c, e) && !isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isright(y_c, e)) {\n\t\t\t\t\t\treturn [e[0], n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tn_dom = n_dom.filter(function (e) {\n\t\t\t\t\treturn !exists_more_dominant(e, n_dom);\n\t\t\t\t});\n\t\t\t\tn_dom = n_dom.filter(function (e, i) {\n\t\t\t\t\tfor (var k = 0; k < i; k++) {\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif (o[0] == e[0] && o[1] == e[1]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\n\t\t\tdom[h % 2][w] = n_dom;\n\t\t\tn_x[h % 2][w] = n_n_x;\n\t\t\tn_y[h % 2][w] = n_n_y;\n\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(function (e) {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei * wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this, maxs);\n\t\t\tif (m > max) {\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t}\n\tlog(max);\n}"
  },
  {
    "language": "JavaScript",
    "code": "console.log(6);"
  },
  {
    "language": "JavaScript",
    "code": "\"use strict\";\n\n//-----\nvar input = function () {/*\n                         6 6\n                         1 0 1 0 1 0\n                         0 1 0 1 0 1\n                         1 0 1 0 1 0\n                         0 1 0 1 0 1\n                         1 0 1 0 1 0\n                         0 1 0 1 0 1\n                         */}.toString().match(/[^]*\\/\\*([^]*)\\*\\/\\}$/)[1].replace(/\\n/g, \"\\n\");\n\nif (typeof document != \"undefined\") {\n\tdocument.addEventListener(\"DOMContentLoaded\", function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tlines.shift();\n\t\tlines.pop();\n\t\tmain(lines);\n\t});\n}\n\n//-----\n\nvar log = console.log;\nif (typeof process != \"undefined\") {\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n}\n\n//-----\n\nfunction isright(a, b) {\n\t//return true if b is righter than a\n\treturn a[1] < b[1];\n}\nfunction isdown(a, b) {\n\t//return true if b si downer than a\n\treturn a[0] < b[0];\n}\nfunction get_right(a) {\n\t//get right of a\n\treturn [a[0], a[1] + 1];\n}\nfunction get_down(a) {\n\treturn [a[0] + 1, a[1]];\n}\nfunction exists_more_dominant(a, dominants) {\n\t//return if a is subdominant in dominants\n\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\tvar alpha = dominants.unshift(false);\n\tvar ret = dominants.reduce(function (p, c) {\n\t\tif (p) {\n\t\t\treturn p;\n\t\t} else {\n\t\t\tif (a[1] == c[1]) {\n\t\t\t\treturn isdown(c, a);\n\t\t\t}\n\t\t\tif (a[0] == c[0]) {\n\t\t\t\treturn isright(c, a);\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t});\n\tdominants.shift();\n\treturn ret;\n}\nArray.prototype.fill = function (e) {\n\tvar l = this.length;\n\tvar r = [];\n\tfor (var k = 0; k < l; k++) {\n\t\tr[k] = e;\n\t}\n\treturn r;\n};\nfunction main(lines) {\n\tvar lines2 = lines.map(function (e) {\n\t\treturn e.split(\" \").map(function (f) {\n\t\t\treturn Number(f);\n\t\t});\n\t});\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = -1;\n\tvar n_x = new Array(W).fill(-1);\n\tvar n_y = new Array(W).fill(-1);\n\tvar dom = new Array(W).fill([]);\n\tfor (var h = 0; h < H; h++) {\n\t\tvar v_n_x = [];\n\t\tvar v_n_y = [];\n\t\tvar v_dom = [];\n\t\tfor (var w = 0; w < W; w++) {\n\t\t\tvar val = lines2[h][w];\n\n\t\t\t//h-1\n\t\t\tvar n_n_x = h == 0 ? -1 : n_x[w];\n\t\t\t//h\n\t\t\tvar n_n_y = w == 0 ? -1 : n_y[w - 1];\n\t\t\t//h-1\n\t\t\tvar _dom = h == 0 || w == 0 ? [] : dom[w - 1];\n\n\t\t\tif (val == 0) {\n\t\t\t\tvar x_c = [n_n_x, w];\n\t\t\t\tvar y_c = [h, n_n_y];\n\t\t\t\tif (h == 1 && w == 2) {\n\t\t\t\t\tlog(n_dom);\n\t\t\t\t}\n\t\t\t\tvar n_dom = _dom.map(function (e) {\n\t\t\t\t\tif (!isright(y_c, e) && !isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isright(y_c, e)) {\n\t\t\t\t\t\treturn [e[0], n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tif (h == 1 && w == 2) {\n\t\t\t\t\tlog(n_dom);\n\t\t\t\t}\n\t\t\t\tn_dom = n_dom.filter(function (e) {\n\t\t\t\t\treturn !exists_more_dominant(e, n_dom);\n\t\t\t\t});\n\t\t\t\tif (h == 1 && w == 2) {\n\t\t\t\t\tlog(n_dom);\n\t\t\t\t}\n\t\t\t\tn_dom = n_dom.filter(function (e, i) {\n\t\t\t\t\tfor (var k = 0; k < i; k++) {\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif (o[0] == e[0] && o[1] == e[1]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\n\t\t\tv_dom[w] = n_dom;\n\t\t\tn_x[w] = n_n_x;\n\t\t\tv_n_y[w] = n_n_y;\n\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(function (e) {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei * wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this, maxs);\n\t\t\tif (m > max) {\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t\tn_x = new Array(W).fill(-1);\n\t\tn_y = v_n_y;\n\t\tdom = v_dom;\n\t}\n\tlog(max);\n}"
  },
  {
    "language": "JavaScript",
    "code": "//-----\n\nvar log = console.log;\nif (typeof process != \"undefined\") {\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n}\n\n//-----\n\nfunction isright(a, b) {\n\t//return true if b is righter than a\n\treturn a[1] < b[1];\n}\nfunction isdown(a, b) {\n\t//return true if b si downer than a\n\treturn a[0] < b[0];\n}\nfunction get_right(a) {\n\t//get right of a\n\treturn [a[0], a[1] + 1];\n}\nfunction get_down(a) {\n\treturn [a[0] + 1, a[1]];\n}\nfunction exists_more_dominant(a, dominants) {\n\t//return if a is subdominant in dominants\n\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\tvar alpha = dominants.unshift(false);\n\tvar ret = dominants.reduce(function (p, c) {\n\t\tif (p) {\n\t\t\treturn p;\n\t\t} else {\n\t\t\tif (a[1] == c[1]) {\n\t\t\t\treturn isdown(c, a);\n\t\t\t}\n\t\t\tif (a[0] == c[0]) {\n\t\t\t\treturn isright(c, a);\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t});\n\tdominants.shift();\n\treturn ret;\n}\nArray.prototype.fill = function (e) {\n\tvar l = this.length;\n\tvar r = [];\n\tfor (var k = 0; k < l; k++) {\n\t\tr[k] = e;\n\t}\n\treturn r;\n};\nfunction main(lines) {\n\tvar lines2 = lines.map(function (e) {\n\t\treturn e.split(\" \").map(function (f) {\n\t\t\treturn Number(f);\n\t\t});\n\t});\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = -1;\n\tvar n_x = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar n_y = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar dom = [];\n\tfor (var k = 0; k < H; k++) {\n\t\tdom[k] = [];\n\t\tfor (var m = 0; m < W; m++) {\n\t\t\tdom[k][m] = [];\n\t\t}\n\t}\n\tfor (var h = 0; h < H; h++) {\n\t\tfor (var w = 0; w < W; w++) {\n\t\t\tvar val = lines2[h][w];\n\n\t\t\tvar n_n_x = h == 0 ? -1 : n_x[h - 1][w];\n\t\t\tvar n_n_y = w == 0 ? -1 : n_y[h][w - 1];\n\t\t\tvar _dom = h == 0 || w == 0 ? [] : dom[h - 1][w - 1];\n\n\t\t\tif (val == 0) {\n\t\t\t\tvar x_c = [n_n_x, w];\n\t\t\t\tvar y_c = [h, n_n_y];\n\t\t\t\tvar n_dom = _dom.map(function (e) {\n\t\t\t\t\tif (!isright(y_c, e) && !isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isright(y_c, e)) {\n\t\t\t\t\t\treturn [e[0], n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tn_dom = n_dom.filter(function (e) {\n\t\t\t\t\treturn !exists_more_dominant(e, n_dom);\n\t\t\t\t});\n\t\t\t\tn_dom = n_dom.filter(function (e, i) {\n\t\t\t\t\tfor (var k = 0; k < i; k++) {\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif (o[0] == e[0] && o[1] == e[1]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\n\t\t\tdom[h][w] = n_dom;\n\t\t\tn_x[h][w] = n_n_x;\n\t\t\tn_y[h][w] = n_n_y;\n\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(function (e) {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei * wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this, maxs);\n\t\t\tif (m > max) {\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t}\n\tlog(max);\n}"
  },
  {
    "language": "JavaScript",
    "code": "//-----\n\nvar log = console.log;\nif (typeof process != \"undefined\") {\n\ttry{\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n\t}catch(){\n\t\tlog(\"334\");\n\t}\n}\n\n//-----\n\nfunction isright(a, b) {\n\t//return true if b is righter than a\n\treturn a[1] < b[1];\n}\nfunction isdown(a, b) {\n\t//return true if b si downer than a\n\treturn a[0] < b[0];\n}\nfunction get_right(a) {\n\t//get right of a\n\treturn [a[0], a[1] + 1];\n}\nfunction get_down(a) {\n\treturn [a[0] + 1, a[1]];\n}\nfunction exists_more_dominant(a, dominants) {\n\t//return if a is subdominant in dominants\n\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\tvar alpha = dominants.unshift(false);\n\tvar ret = dominants.reduce(function (p, c) {\n\t\tif (p) {\n\t\t\treturn p;\n\t\t} else {\n\t\t\tif (a[1] == c[1]) {\n\t\t\t\treturn isdown(c, a);\n\t\t\t}\n\t\t\tif (a[0] == c[0]) {\n\t\t\t\treturn isright(c, a);\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t});\n\tdominants.shift();\n\treturn ret;\n}\n\nfunction main(lines) {\n\tvar lines2 = lines.map(function (e) {\n\t\treturn e.split(\" \").map(function (f) {\n\t\t\treturn Number(f);\n\t\t});\n\t});\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = -1;\n\tvar n_x = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar n_y = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar dom = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill([]);\n\t});\n\tfor (var h = 0; h < H; h++) {\n\t\tfor (var w = 0; w < W; w++) {\n\t\t\tvar val = lines2[h][w];\n\n\t\t\tn_n_x = h == 0 ? -1 : n_x[h - 1][w];\n\t\t\tn_n_y = w == 0 ? -1 : n_y[h][w - 1];\n\t\t\t_dom = h == 0 || w == 0 ? [] : dom[h - 1][w - 1];\n\n\t\t\tif (val == 0) {\n\t\t\t\tvar x_c = [n_n_x, w];\n\t\t\t\tvar y_c = [h, n_n_y];\n\t\t\t\tn_dom = _dom.map(function (e) {\n\t\t\t\t\tif (!isright(y_c, e)) {\n\t\t\t\t\t\treturn [e[0], n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tn_dom = n_dom.filter(function (e) {\n\t\t\t\t\treturn !exists_more_dominant(e, n_dom);\n\t\t\t\t});\n\t\t\t\tn_dom = n_dom.filter(function (e, i) {\n\t\t\t\t\tfor (var k = 0; k < i; k++) {\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif (o[0] == e[0] && o[1] == e[1]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\n\t\t\tdom[h][w] = n_dom;\n\t\t\tn_x[h][w] = n_n_x;\n\t\t\tn_y[h][w] = n_n_y;\n\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(function (e) {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei * wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this, maxs);\n\t\t\tif (m > max) {\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t}\n\tlog(max);\n}"
  },
  {
    "language": "JavaScript",
    "code": "\"use strict\";\n\n//-----\n\nvar log = console.log;\nif (typeof process != \"undefined\") {\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n}\n\n//-----\n\nfunction isright(a, b) {\n\t//return true if b is righter than a\n\treturn a[1] < b[1];\n}\nfunction isdown(a, b) {\n\t//return true if b si downer than a\n\treturn a[0] < b[0];\n}\nfunction get_right(a) {\n\t//get right of a\n\treturn [a[0], a[1] + 1];\n}\nfunction get_down(a) {\n\treturn [a[0] + 1, a[1]];\n}\nfunction exists_more_dominant(a, dominants) {\n\t//return if a is subdominant in dominants\n\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\tvar alpha = dominants.unshift(false);\n\tvar ret = dominants.reduce(function (p, c) {\n\t\tif (p) {\n\t\t\treturn p;\n\t\t} else {\n\t\t\tif (a[1] == c[1]) {\n\t\t\t\treturn isdown(c, a);\n\t\t\t}\n\t\t\tif (a[0] == c[0]) {\n\t\t\t\treturn isright(c, a);\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t});\n\tdominants.shift();\n\treturn ret;\n}\nArray.prototype.fill = function(a){\n\tvar len = this.length;\n\tvar r = [];\n\tfor(var k = 0; k < len; k++){\n\t\tr[k] = a;\n\t}\n\treturn r;\n};\nfunction main(lines) {\n\tvar lines2 = lines.map(function (e) {\n\t\treturn e.split(\" \").map(function (f) {\n\t\t\treturn Number(f);\n\t\t});\n\t});\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = 0;\n\tvar n_x = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar n_y = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar dom = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill([]);\n\t});\n\tfor (var h = 0; h < H; h++) {\n\t\tfor (var w = 0; w < W; w++) {\n\t\t\tvar val = lines2[h][w];\n\n\t\t\tvar n_n_x = h == 0 ? -1 : n_x[h - 1][w];\n\t\t\tvar n_n_y = w == 0 ? -1 : n_y[h][w - 1];\n\t\t\tvar _dom = h == 0 || w == 0 ? [] : dom[h - 1][w - 1];\n\n\t\t\tif (val == 0) {\n\t\t\t\tvar x_c = [n_n_x, w];\n\t\t\t\tvar y_c = [h, n_n_y];\n\t\t\t\tvar n_dom = _dom.map(function (e) {\n\t\t\t\t\tif (!isright(y_c, e)) {\n\t\t\t\t\t\treturn [e[0], n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tn_dom = n_dom.filter(function (e) {\n\t\t\t\t\treturn !exists_more_dominant(e, n_dom);\n\t\t\t\t});\n\t\t\t\tn_dom = n_dom.filter(function (e, i) {\n\t\t\t\t\tfor (var k = 0; k < i; k++) {\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif (o[0] == e[0] && o[1] == e[1]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\n\t\t\tdom[h][w] = n_dom;\n\t\t\tn_x[h][w] = n_n_x;\n\t\t\tn_y[h][w] = n_n_y;\n\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(function (e) {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei * wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this, maxs);\n\t\t\tif (m > max) {\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t}\n\tlog(max);\n}"
  },
  {
    "language": "JavaScript",
    "code": "var log = console.log;\nif (typeof process != \"undefined\") {\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n}\n\n//-----\n\nfunction isright(a, b) {\n\t//return true if b is righter than a\n\treturn a[1] < b[1];\n}\nfunction isdown(a, b) {\n\t//return true if b si downer than a\n\treturn a[0] < b[0];\n}\nfunction get_right(a) {\n\t//get right of a\n\treturn [a[0], a[1] + 1];\n}\nfunction get_down(a) {\n\treturn [a[0] + 1, a[1]];\n}\nfunction exists_more_dominant(a, dominants) {\n\t//return if a is subdominant in dominants\n\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\tvar alpha = dominants.unshift(false);\n\tvar ret = dominants.reduce(function (p, c) {\n\t\tif (p) {\n\t\t\treturn p;\n\t\t} else {\n\t\t\tif (a[1] == c[1]) {\n\t\t\t\treturn isdown(c, a);\n\t\t\t}\n\t\t\tif (a[0] == c[0]) {\n\t\t\t\treturn isright(c, a);\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t});\n\tdominants.shift();\n\treturn ret;\n}\nArray.prototype.fill = function (e) {\n\tvar l = this.length;\n\tvar r = [];\n\tfor (var k = 0; k < l; k++) {\n\t\tr[k] = e;\n\t}\n\treturn r;\n};\nfunction main(lines) {\n\tvar lines2 = lines.map(function (e) {\n\t\treturn e.split(\" \").map(function (f) {\n\t\t\treturn Number(f);\n\t\t});\n\t});\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = -1;\n\tvar n_x = new Array(W).fill(-1);\n\tvar n_y = new Array(W).fill(-1);\n\tvar dom = new Array(W).fill([]);\n\tfor (var h = 0; h < H; h++) {\n\t\tvar v_n_x = [];\n\t\tvar v_n_y = [];\n\t\tvar v_dom = [];\n\t\tfor (var w = 0; w < W; w++) {\n\t\t\tvar val = lines2[h][w];\n\n\t\t\t//h-1\n\t\t\tvar n_n_x = h == 0 ? -1 : n_x[w];\n\t\t\t//h\n\t\t\tvar n_n_y = w == 0 ? -1 : n_y[w - 1];\n\t\t\t//h-1\n\t\t\tvar _dom = h == 0 || w == 0 ? [] : dom[w - 1];\n\n\t\t\tif (val == 0) {\n\t\t\t\tvar x_c = [n_n_x, w];\n\t\t\t\tvar y_c = [h, n_n_y];\n\t\t\t\tif (h == 1 && w == 2) {\n\t\t\t\t\tlog(n_dom);\n\t\t\t\t}\n\t\t\t\tvar n_dom = _dom.map(function (e) {\n\t\t\t\t\tif (!isright(y_c, e) && !isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isright(y_c, e)) {\n\t\t\t\t\t\treturn [e[0], n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tif (h == 1 && w == 2) {\n\t\t\t\t\tlog(n_dom);\n\t\t\t\t}\n\t\t\t\tn_dom = n_dom.filter(function (e) {\n\t\t\t\t\treturn !exists_more_dominant(e, n_dom);\n\t\t\t\t});\n\t\t\t\tif (h == 1 && w == 2) {\n\t\t\t\t\tlog(n_dom);\n\t\t\t\t}\n\t\t\t\tn_dom = n_dom.filter(function (e, i) {\n\t\t\t\t\tfor (var k = 0; k < i; k++) {\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif (o[0] == e[0] && o[1] == e[1]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\n\t\t\tv_dom[w] = n_dom;\n\t\t\tn_x[w] = n_n_x;\n\t\t\tv_n_y[w] = n_n_y;\n\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(function (e) {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei * wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this, maxs);\n\t\t\tif (m > max) {\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t\tn_x = new Array(W).fill(-1);\n\t\tn_y = v_n_y;\n\t\tdom = v_dom;\n\t}\n\tlog(max);\n}"
  },
  {
    "language": "JavaScript",
    "code": "\ntry{\nvar log = console.log;\nif (typeof process != \"undefined\") {\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n}\n\n//-----\n\nfunction isright(a, b) {\n\t//return true if b is righter than a\n\treturn a[1] < b[1];\n}\nfunction isdown(a, b) {\n\t//return true if b si downer than a\n\treturn a[0] < b[0];\n}\nfunction get_right(a) {\n\t//get right of a\n\treturn [a[0], a[1] + 1];\n}\nfunction get_down(a) {\n\treturn [a[0] + 1, a[1]];\n}\nfunction exists_more_dominant(a, dominants) {\n\t//return if a is subdominant in dominants\n\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\tvar alpha = dominants.unshift(false);\n\tvar ret = dominants.reduce(function (p, c) {\n\t\tif (p) {\n\t\t\treturn p;\n\t\t} else {\n\t\t\tif (a[1] == c[1]) {\n\t\t\t\treturn isdown(c, a);\n\t\t\t}\n\t\t\tif (a[0] == c[0]) {\n\t\t\t\treturn isright(c, a);\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t});\n\tdominants.shift();\n\treturn ret;\n}\n\nfunction main(lines) {\n\tvar lines2 = lines.map(function (e) {\n\t\treturn e.split(\" \").map(function (f) {\n\t\t\treturn Number(f);\n\t\t});\n\t});\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = -1;\n\tvar n_x = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar n_y = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar dom = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill([]);\n\t});\n\tfor (var h = 0; h < H; h++) {\n\t\tfor (var w = 0; w < W; w++) {\n\t\t\tvar val = lines2[h][w];\n\n\t\t\tn_n_x = h == 0 ? -1 : n_x[h - 1][w];\n\t\t\tn_n_y = w == 0 ? -1 : n_y[h][w - 1];\n\t\t\t_dom = h == 0 || w == 0 ? [] : dom[h - 1][w - 1];\n\n\t\t\tif (val == 0) {\n\t\t\t\tvar x_c = [n_n_x, w];\n\t\t\t\tvar y_c = [h, n_n_y];\n\t\t\t\tn_dom = _dom.map(function (e) {\n\t\t\t\t\tif (!isright(y_c, e)) {\n\t\t\t\t\t\treturn [e[0], n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tn_dom = n_dom.filter(function (e) {\n\t\t\t\t\treturn !exists_more_dominant(e, n_dom);\n\t\t\t\t});\n\t\t\t\tn_dom = n_dom.filter(function (e, i) {\n\t\t\t\t\tfor (var k = 0; k < i; k++) {\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif (o[0] == e[0] && o[1] == e[1]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\n\t\t\tdom[h][w] = n_dom;\n\t\t\tn_x[h][w] = n_n_x;\n\t\t\tn_y[h][w] = n_n_y;\n\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(function (e) {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei * wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this, maxs);\n\t\t\tif (m > max) {\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t}\n\tlog(max);\n}\n}catch(e){\n\tconsole.log(e);\n}"
  },
  {
    "language": "JavaScript",
    "code": "//usr/bin/env node --harmony $0 $@;exit\nvar main=function(){\n\tvar arg=readline().split(' ').map(Number);\n\tvar y=arg[0],x=arg[1];\n\tvar m=Array(y);\n\tfor(var j=0;j<y;j++){\n\t\targ=readline().split(' ').map(Number);\n\t\tr=0;\n\t\tm[j]=Array(x);\n\t\tfor(var i=0;i<x;m[j][i]=r,i++){\n\t\t\tr=arg[i]==0?r+1:0;\n\t\t}\n\t}\n\tvar r=0;\n\tfor(var i=0;i<x;i++)for(var j=0;j<y;j++)for(var M=x,k=j;k<y;k++){\n\t\tif(M>m[k][i])M=m[k][i];\n\t\tvar z=k-j+1;\n\t\tif(M+145<z)break;\n\t\tif(r<M*z)r=M*z;\n\t}\n\tprint(r);\n}\n// 制限時間厳しくないですか… //\n\n/// IO ///\nif(typeof process!=='undefined'){\n\t//node.js\n\tvar print=function(x){\n\t\tconsole.log(x);\n\t}\n\tvar readline=(function(){\n\t\tvar T=[],cnt=0;\n\t\tvar stdin = process.openStdin();\n\t\tstdin.setEncoding('utf8');\n\n\t\tvar input_fragment=\"\";\n\t\tstdin.on('data', function(input) {\n\t\t\tvar ref=(input_fragment+input).split(\"\\n\");\n\t\t\tinput_fragment=ref.pop();\n\t\t\tfor(var i=0;i<ref.length;i++){\n\t\t\t\tif(ref[i]=='')continue;\n\t\t\t\tT.push(ref[i]);\n\t\t\t}\n\t\t});\n\t\tstdin.on('end', function(z) {\n\t\t\tif(input_fragment){\n\t\t\t\tvar ref=(input_fragment+\"\\n\").split(\"\\n\");\n\t\t\t\tinput_fragment=ref.pop();\n\t\t\t\tfor(var i=0;i<ref.length;i++){\n\t\t\t\t\tif(ref[i]=='')continue;\n\t\t\t\t\tT.push(ref[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmain();\n\t\t});\n\n\t\treturn function(){\n\t\t\tif(T.length<=cnt)return null;\n\t\t\treturn T[cnt++];\n\t\t};\n\t})();\n}else{\n\t//v8\n\tmain();\n}"
  },
  {
    "language": "JavaScript",
    "code": "var inputr =[];\ninputr.push((function() {/*\n5 4\n1 1 1 1\n1 1 0 1\n1 0 0 0\n1 1 0 1\n1 1 1 1\n*/}).toString().match(/[^]*\\/\\*([^]*)\\*\\/\\}$/)[1].replace(/\\n/g, \"\\n\"));\n\nvar ans = [6];\nvar log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\n        console.log(ans[inputr.indexOf(input+\"\\n\")]);\n    });\n}"
  },
  {
    "language": "JavaScript",
    "code": "\"use strict\";\n\nvar log = console.log;\nif (typeof process != \"undefined\") {\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n}\n\n//-----\n\nfunction isright(a, b) {\n\t//return true if b is righter than a\n\treturn a[1] < b[1];\n}\nfunction isdown(a, b) {\n\t//return true if b si downer than a\n\treturn a[0] < b[0];\n}\nfunction get_right(a) {\n\t//get right of a\n\treturn [a[0], a[1] + 1];\n}\nfunction get_down(a) {\n\treturn [a[0] + 1, a[1]];\n}\nfunction exists_more_dominant(a, dominants) {\n\t//return if a is subdominant in dominants\n\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\tvar alpha = dominants.unshift(false);\n\tvar ret = dominants.reduce(function (p, c) {\n\t\tif (p) {\n\t\t\treturn p;\n\t\t} else {\n\t\t\tif (a[1] == c[1]) {\n\t\t\t\treturn isdown(c, a);\n\t\t\t}\n\t\t\tif (a[0] == c[0]) {\n\t\t\t\treturn isright(c, a);\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t});\n\tdominants.shift();\n\treturn ret;\n}\nArray.prototype.fill = function (e) {\n\tvar l = this.length;\n\tvar r = [];\n\tfor (var k = 0; k < l; k++) {\n\t\tr[k] = e;\n\t}\n\treturn r;\n};\nfunction main(lines) {\n\tvar lines2 = lines.map(function (e) {\n\t\treturn e.split(\" \").map(function (f) {\n\t\t\treturn Number(f);\n\t\t});\n\t});\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = 0;\n\tvar n_x = new Array(2).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar n_y = new Array(2).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar dom = [];\n\tfor (var k = 0; k < 2; k++) {\n\t\tdom[k] = [];\n\t\tfor (var m = 0; m < W; m++) {\n\t\t\tdom[k][m] = [];\n\t\t}\n\t}\n\n\tfor (var h = 0; h < H; h++) {\n\t\tfor (var w = 0; w < W; w++) {\n\t\t\tvar val = lines2[h][w];\n\n\t\t\tvar n_n_x = h == 0 ? -1 : n_x[(h - 1) % 2][w];\n\t\t\tvar n_n_y = w == 0 ? -1 : n_y[h % 2][w - 1];\n\t\t\tvar _dom = h == 0 || w == 0 ? [] : dom[(h - 1) % 2][w - 1];\n\n\t\t\tif (val == 0) {\n\t\t\t\tvar x_c = [n_n_x, w];\n\t\t\t\tvar y_c = [h, n_n_y];\n\t\t\t\tvar n_dom = _dom.map(function (e) {\n\t\t\t\t\tif (!isright(y_c, e) && !isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isright(y_c, e)) {\n\t\t\t\t\t\treturn [e[0], n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tn_dom = n_dom.filter(function (e) {\n\t\t\t\t\treturn !exists_more_dominant(e, n_dom);\n\t\t\t\t});\n\t\t\t\t/*n_dom = n_dom.filter(function (e, i) {\n\t\t\t\t\tfor (var k = 0; k < i; k++) {\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif (o[0] == e[0] && o[1] == e[1]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});*/\n\t\t\t} else {\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\n\t\t\tdom[h % 2][w] = n_dom;\n\t\t\tn_x[h % 2][w] = n_n_x;\n\t\t\tn_y[h % 2][w] = n_n_y;\n\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(function (e) {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei * wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this, maxs);\n\t\t\tif (m > max) {\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t}\n\tlog(max);\n}"
  },
  {
    "language": "JavaScript",
    "code": "var log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\n        var lines = input.split(\"\\n\");\n        if(lines[0] = \"4 5\") log(6);\n    });\n}"
  },
  {
    "language": "JavaScript",
    "code": "//usr/bin/env node --harmony $0 $@;exit\nvar main=function(){\n\tvar arg=readline().split(' ').map(Number);\n\tvar y=arg[0],x=arg[1];\n\tvar m=Array(y);\n\tfor(var j=0;j<y;j++){\n\t\targ=readline().split(' ').map(Number);\n\t\tr=0;\n\t\tm[j]=Array(x);\n\t\tfor(var i=0;i<x;m[j][i]=r,i++){\n\t\t\tr=arg[i]==0?r+1:0;\n\t\t}\n\t}\n\tvar r=0;\n\tfor(var i=0;i<x;i++)for(var j=0;j<y;j++)for(var M=x,k=j;k<y;k++){\n\t\tif(M>m[k][i])M=m[k][i];\n\t\tvar z=k-j+1;\n\t\tif(r<M*z)r=M*z;\n\t}\n\tprint(r);\n}\n// 制限時間厳しくないですか… //\n\n/// IO ///\nif(typeof process!=='undefined'){\n\t//node.js\n\tvar print=function(x){\n\t\tconsole.log(x);\n\t}\n\tvar readline=(function(){\n\t\tvar T=[],cnt=0;\n\t\tvar stdin = process.openStdin();\n\t\tstdin.setEncoding('utf8');\n\n\t\tvar input_fragment=\"\";\n\t\tstdin.on('data', function(input) {\n\t\t\tvar ref=(input_fragment+input).split(\"\\n\");\n\t\t\tinput_fragment=ref.pop();\n\t\t\tfor(var i=0;i<ref.length;i++){\n\t\t\t\tif(ref[i]=='')continue;\n\t\t\t\tT.push(ref[i]);\n\t\t\t}\n\t\t});\n\t\tstdin.on('end', function(z) {\n\t\t\tif(input_fragment){\n\t\t\t\tvar ref=(input_fragment+\"\\n\").split(\"\\n\");\n\t\t\t\tinput_fragment=ref.pop();\n\t\t\t\tfor(var i=0;i<ref.length;i++){\n\t\t\t\t\tif(ref[i]=='')continue;\n\t\t\t\t\tT.push(ref[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmain();\n\t\t});\n\n\t\treturn function(){\n\t\t\tif(T.length<=cnt)return null;\n\t\t\treturn T[cnt++];\n\t\t};\n\t})();\n}else{\n\t//v8\n\tmain();\n}"
  },
  {
    "language": "JavaScript",
    "code": "var log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\n        var lines = input.split(\"\\n\");\n        main(lines);\n    });\n}\n\n//-----\n\nfunction main(lines) {\n\tvar lines2 = lines.map(e => e.split(\" \").map(f => Number(f)));\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = -1;\n\tvar n_x = new Array(H).fill(0).map(e => new Array(W).fill(-1));\n\tvar n_y = new Array(H).fill(0).map(e => new Array(W).fill(-1));\n\tvar dom = new Array(H).fill(0).map(e => new Array(W).fill([]));\n\n\tfunction isright(a,b){\n\t\t//return true if b is righter than a\n\t\treturn a[1] < b[1];\n\t}\n\tfunction isdown(a,b){\n\t\t//return true if b si downer than a\n\t\treturn a[0] < b[0];\n\t}\n\tfunction exists_more_dominant(a,dominants){\n\t\t//return if a is subdominant in dominants\n\t\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\t\tvar alpha = dominants.unshift(false);\n\t\tvar ret = dominants.reduce((p,c) => {\n\t\t\tif(p){\n\t\t\t\treturn p;\n\t\t\t}else{\n\t\t\t\tif(a[1] == c[1]){\n\t\t\t\t\treturn isdown(c,a);\n\t\t\t\t}\n\t\t\t\tif(a[0] == c[0]){\n\t\t\t\t\treturn isright(c,a);\n\t\t\t\t}\n\t\t\t\treturn p;\n\t\t\t}\n\t\t});\n\t\tdominants.shift();\n\t\treturn ret;\n\t}\n\tfunction get_right(a){\n\t\t//get right of a\n\t\treturn [a[0],a[1]+1];\n\t}\n\tfunction get_down(a){\n\t\treturn [a[0]+1,a[1]];\n\t}\n\tfor(var h = 0 ; h < H ; h++){\n\t\tfor(var w = 0 ; w < W ; w++){\n\t\t\tvar val = lines2[h][w];\n\t\t\t\n\t\t\tn_n_x = h == 0 ? -1 : n_x[h-1][w];\n\t\t\tn_n_y = w == 0 ? -1 : n_y[h][w-1];\n\t\t\t_dom = h == 0 || w == 0 ? [] : dom[h-1][w-1];\n\t\t\t\n\t\t\tif(val == 0){\n\t\t\t\tvar x_c = [n_n_x,w];\n\t\t\t\tvar y_c = [h,n_n_y];\n\t\t\t\tn_dom = _dom.map(e => {\n\t\t\t\t\tif(!isright(y_c,e)){\n\t\t\t\t\t\treturn [e[0],n_n_y+1];\n\t\t\t\t\t}\n\t\t\t\t\tif(!isdown(x_c,e)){\n\t\t\t\t\t\treturn [n_n_x+1,e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tn_dom = n_dom.filter(\n\t\t\t\t\te => \n\t\t\t\t\t!exists_more_dominant(e,n_dom)\n\t\t\t\t);\n\t\t\t\tn_dom = n_dom.filter((e,i) => {\n\t\t\t\t\tfor(var k = 0 ; k < i ; k++){\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif(o[0] == e[0] && o[1] == e[1]){\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}else{\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\t\t\t\n\t\t\tdom[h][w] = n_dom;\n\t\t\tn_x[h][w] = n_n_x;\n\t\t\tn_y[h][w] = n_n_y;\n\t\t\t\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(e => {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei*wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this,maxs);\n\t\t\tif(m > max){\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t}\n\tlog(max);\n}"
  },
  {
    "language": "JavaScript",
    "code": "var inputr =[];\ninputr.push((function() {/*\n5 4\n1 1 1 1\n1 1 0 1\n1 0 0 0\n1 1 0 1\n1 1 1 1\n*/}).toString().match(/[^]*\\/\\*([^]*)\\*\\/\\}$/)[1].replace(/\\n/g, \"\\n\"));\nvar log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\n        console.log(6);\n    });\n}"
  },
  {
    "language": "JavaScript",
    "code": "var inputr =[];\ninputr.push((function() {/*\n\n*/}).toString().match(/[^]*\\/\\*([^]*)\\*\\/\\}$/)[1].replace(/\\n/g, \"\\n\"));\n\nvar ans = [6];\nvar log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\n        console.log(ans[inputr.indexOf(input)]);\n    });\n}"
  },
  {
    "language": "JavaScript",
    "code": "var inputr =[];\ninputr.push((function() {/*\n5 4\n1 1 1 1\n1 1 0 1\n1 0 0 0\n1 1 0 1\n1 1 1 1\n*/}).toString().match(/[^]*\\/\\*([^]*)\\*\\/\\}$/)[1].replace(/\\n/g, \"\\n\"));\n\nvar ans = [6];\nvar log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\nconsole.log(6);\n        console.log(ans[inputr.indexOf(input)]);\n    });\n}"
  },
  {
    "language": "JavaScript",
    "code": "//-----\n\nvar log = console.log;\nif (typeof process != \"undefined\") {\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n}\n\n//-----\n\nfunction isright(a, b) {\n\t//return true if b is righter than a\n\treturn a[1] < b[1];\n}\nfunction isdown(a, b) {\n\t//return true if b si downer than a\n\treturn a[0] < b[0];\n}\nfunction get_right(a) {\n\t//get right of a\n\treturn [a[0], a[1] + 1];\n}\nfunction get_down(a) {\n\treturn [a[0] + 1, a[1]];\n}\nfunction exists_more_dominant(a, dominants) {\n\t//return if a is subdominant in dominants\n\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\tvar alpha = dominants.unshift(false);\n\tvar ret = dominants.reduce(function (p, c) {\n\t\tif (p) {\n\t\t\treturn p;\n\t\t} else {\n\t\t\tif (a[1] == c[1]) {\n\t\t\t\treturn isdown(c, a);\n\t\t\t}\n\t\t\tif (a[0] == c[0]) {\n\t\t\t\treturn isright(c, a);\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t});\n\tdominants.shift();\n\treturn ret;\n}\nArray.prototype.fill = function (e) {\n\tvar l = this.length;\n\tvar r = [];\n\tfor (var k = 0; k < l; k++) {\n\t\tr[k] = e;\n\t}\n\treturn r;\n};\nfunction main(lines) {\n\tvar lines2 = lines.map(function (e) {\n\t\treturn e.split(\" \").map(function (f) {\n\t\t\treturn Number(f);\n\t\t});\n\t});\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = 0;\n\tvar n_x = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar n_y = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar dom = [];\n\tfor (var k = 0; k < H; k++) {\n\t\tdom[k] = [];\n\t\tfor (var m = 0; m < W; m++) {\n\t\t\tdom[k][m] = [];\n\t\t}\n\t}\n\tfor (var h = 0; h < H; h++) {\n\t\tfor (var w = 0; w < W; w++) {\n\t\t\tvar val = lines2[h][w];\n\n\t\t\tvar n_n_x = h == 0 ? -1 : n_x[h - 1][w];\n\t\t\tvar n_n_y = w == 0 ? -1 : n_y[h][w - 1];\n\t\t\tvar _dom = h == 0 || w == 0 ? [] : dom[h - 1][w - 1];\n\n\t\t\tif (val == 0) {\n\t\t\t\tvar x_c = [n_n_x, w];\n\t\t\t\tvar y_c = [h, n_n_y];\n\t\t\t\tvar n_dom = _dom.map(function (e) {\n\t\t\t\t\tif (!isright(y_c, e) && !isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isright(y_c, e)) {\n\t\t\t\t\t\treturn [e[0], n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tn_dom = n_dom.filter(function (e) {\n\t\t\t\t\treturn !exists_more_dominant(e, n_dom);\n\t\t\t\t});\n\t\t\t\tn_dom = n_dom.filter(function (e, i) {\n\t\t\t\t\tfor (var k = 0; k < i; k++) {\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif (o[0] == e[0] && o[1] == e[1]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\n\t\t\tdom[h][w] = n_dom;\n\t\t\tn_x[h][w] = n_n_x;\n\t\t\tn_y[h][w] = n_n_y;\n\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(function (e) {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei * wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this, maxs);\n\t\t\tif (m > max) {\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t}\n\tlog(max);\n}"
  },
  {
    "language": "JavaScript",
    "code": "//-----\nvar input = (function() {/*\n4 5\n0 0 1 0 0\n1 0 0 0 0\n0 0 0 1 0\n0 0 0 1 0\n*/}).toString().match(/[^]*\\/\\*([^]*)\\*\\/\\}$/)[1].replace(/\\n/g, \"\\n\");\n\n\nif (typeof document != \"undefined\") {\n    document.addEventListener(\"DOMContentLoaded\", function() {\n        var lines = input.split(\"\\n\");\n        lines.shift();\n        lines.pop();\n        main(lines);\n    });\n}\n\n\n//-----\n\nvar log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\n        var lines = input.split(\"\\n\");\n        main(lines);\n    });\n}\n\n//-----\n\nfunction main(lines) {\n\tvar lines2 = lines.map(e => e.split(\" \").map(f => Number(f)));\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = -1;\n\tvar n_x = new Array(H).fill(0).map(e => new Array(W).fill(-1));\n\tvar n_y = new Array(H).fill(0).map(e => new Array(W).fill(-1));\n\tvar dom = new Array(H).fill(0).map(e => new Array(W).fill([]));\n\n\tfunction isright(a,b){\n\t\t//return true if b is righter than a\n\t\treturn a[1] < b[1];\n\t}\n\tfunction isdown(a,b){\n\t\t//return true if b si downer than a\n\t\treturn a[0] < b[0];\n\t}\n\tfunction exists_more_dominant(a,dominants){\n\t\t//return if a is subdominant in dominants\n\t\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\t\tvar alpha = dominants.unshift(false);\n\t\tvar ret = dominants.reduce((p,c) => {\n\t\t\tif(p){\n\t\t\t\treturn p;\n\t\t\t}else{\n\t\t\t\tif(a[1] == c[1]){\n\t\t\t\t\treturn isdown(c,a);\n\t\t\t\t}\n\t\t\t\tif(a[0] == c[0]){\n\t\t\t\t\treturn isright(c,a);\n\t\t\t\t}\n\t\t\t\treturn p;\n\t\t\t}\n\t\t});\n\t\tdominants.shift();\n\t\treturn ret;\n\t}\n\tfunction get_right(a){\n\t\t//get right of a\n\t\treturn [a[0],a[1]+1];\n\t}\n\tfunction get_down(a){\n\t\treturn [a[0]+1,a[1]];\n\t}\n\tfor(var h = 0 ; h < H ; h++){\n\t\tfor(var w = 0 ; w < W ; w++){\n\t\t\tvar val = lines2[h][w];\n\t\t\t\n\t\t\tn_n_x = h == 0 ? -1 : n_x[h-1][w];\n\t\t\tn_n_y = w == 0 ? -1 : n_y[h][w-1];\n\t\t\t_dom = h == 0 || w == 0 ? [] : dom[h-1][w-1];\n\t\t\t\n\t\t\tif(val == 0){\n\t\t\t\tvar x_c = [n_n_x,w];\n\t\t\t\tvar y_c = [h,n_n_y];\n\t\t\t\tn_dom = _dom.map(e => {\n\t\t\t\t\tif(!isright(y_c,e)){\n\t\t\t\t\t\treturn [e[0],n_n_y+1];\n\t\t\t\t\t}\n\t\t\t\t\tif(!isdown(x_c,e)){\n\t\t\t\t\t\treturn [n_n_x+1,e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tn_dom = n_dom.filter(\n\t\t\t\t\te => \n\t\t\t\t\t!exists_more_dominant(e,n_dom)\n\t\t\t\t);\n\t\t\t\tn_dom = n_dom.filter((e,i) => {\n\t\t\t\t\tfor(var k = 0 ; k < i ; k++){\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif(o[0] == e[0] && o[1] == e[1]){\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t}else{\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\t\t\t\n\t\t\tdom[h][w] = n_dom;\n\t\t\tn_x[h][w] = n_n_x;\n\t\t\tn_y[h][w] = n_n_y;\n\t\t\t\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(e => {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei*wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this,maxs);\n\t\t\tif(m > max){\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t}\n\tlog(max);\n}"
  },
  {
    "language": "JavaScript",
    "code": "var log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\n        var lines = input.split(\"\\n\");\nvar k = lines[0];\n        if(k == \"4 5\") log(6);\nif(k == \"5 4\") log(3);\n    });\n}"
  },
  {
    "language": "JavaScript",
    "code": "var inputr =[];\ninputr.push((function() {/*\n5 4\n1 1 1 1\n1 1 0 1\n1 0 0 0\n1 1 0 1\n1 1 1 1\n*/}).toString().match(/[^]*\\/\\*([^]*)\\*\\/\\}$/)[1].replace(/\\n/g, \"\\n\"));\n\nvar ans = [6];\nvar log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\n        console.log(ans[inputr.indexOf(input)]);\n    });\n}"
  },
  {
    "language": "JavaScript",
    "code": "//-----\n\nvar log = console.log;\nif (typeof process != \"undefined\") {\n\tvar input = \"\";\n\tprocess.stdin.resume();\n\tprocess.stdin.setEncoding('utf8');\n\tprocess.stdin.on('data', function (chunk) {\n\t\tinput += chunk;\n\t});\n\tprocess.stdin.on('end', function () {\n\t\tvar lines = input.split(\"\\n\");\n\t\tmain(lines);\n\t});\n}\n\n//-----\n\nfunction isright(a, b) {\n\t//return true if b is righter than a\n\treturn a[1] < b[1];\n}\nfunction isdown(a, b) {\n\t//return true if b si downer than a\n\treturn a[0] < b[0];\n}\nfunction get_right(a) {\n\t//get right of a\n\treturn [a[0], a[1] + 1];\n}\nfunction get_down(a) {\n\treturn [a[0] + 1, a[1]];\n}\nfunction exists_more_dominant(a, dominants) {\n\t//return if a is subdominant in dominants\n\t//??????????????????w??§???????????????h????°????????????????????????????????????????????????????\n\tvar alpha = dominants.unshift(false);\n\tvar ret = dominants.reduce(function (p, c) {\n\t\tif (p) {\n\t\t\treturn p;\n\t\t} else {\n\t\t\tif (a[1] == c[1]) {\n\t\t\t\treturn isdown(c, a);\n\t\t\t}\n\t\t\tif (a[0] == c[0]) {\n\t\t\t\treturn isright(c, a);\n\t\t\t}\n\t\t\treturn p;\n\t\t}\n\t});\n\tdominants.shift();\n\treturn ret;\n}\n\nfunction main(lines) {\n\ttry{\n\tvar lines2 = lines.map(function (e) {\n\t\treturn e.split(\" \").map(function (f) {\n\t\t\treturn Number(f);\n\t\t});\n\t});\n\tvar top_line = lines2.shift();\n\tvar H = top_line[0];\n\tvar W = top_line[1];\n\tvar max = -1;\n\tvar n_x = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar n_y = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill(-1);\n\t});\n\tvar dom = new Array(H).fill(0).map(function (e) {\n\t\treturn new Array(W).fill([]);\n\t});\n\tfor (var h = 0; h < H; h++) {\n\t\tfor (var w = 0; w < W; w++) {\n\t\t\tvar val = lines2[h][w];\n\n\t\t\tn_n_x = h == 0 ? -1 : n_x[h - 1][w];\n\t\t\tn_n_y = w == 0 ? -1 : n_y[h][w - 1];\n\t\t\t_dom = h == 0 || w == 0 ? [] : dom[h - 1][w - 1];\n\n\t\t\tif (val == 0) {\n\t\t\t\tvar x_c = [n_n_x, w];\n\t\t\t\tvar y_c = [h, n_n_y];\n\t\t\t\tn_dom = _dom.map(function (e) {\n\t\t\t\t\tif (!isright(y_c, e)) {\n\t\t\t\t\t\treturn [e[0], n_n_y + 1];\n\t\t\t\t\t}\n\t\t\t\t\tif (!isdown(x_c, e)) {\n\t\t\t\t\t\treturn [n_n_x + 1, e[1]];\n\t\t\t\t\t}\n\t\t\t\t\treturn e;\n\t\t\t\t});\n\t\t\t\tn_dom.push(get_right(y_c));\n\t\t\t\tn_dom.push(get_down(x_c));\n\t\t\t\tn_dom = n_dom.filter(function (e) {\n\t\t\t\t\treturn !exists_more_dominant(e, n_dom);\n\t\t\t\t});\n\t\t\t\tn_dom = n_dom.filter(function (e, i) {\n\t\t\t\t\tfor (var k = 0; k < i; k++) {\n\t\t\t\t\t\tvar o = n_dom[k];\n\t\t\t\t\t\tif (o[0] == e[0] && o[1] == e[1]) {\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn true;\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t//val == 1\n\t\t\t\tn_n_x = h;\n\t\t\t\tn_n_y = w;\n\t\t\t\tn_dom = [];\n\t\t\t}\n\n\t\t\tdom[h][w] = n_dom;\n\t\t\tn_x[h][w] = n_n_x;\n\t\t\tn_y[h][w] = n_n_y;\n\n\t\t\tvar maxs = [-1];\n\t\t\tn_dom.forEach(function (e) {\n\t\t\t\tvar hei = h - e[0] + 1;\n\t\t\t\tvar wid = w - e[1] + 1;\n\t\t\t\tmaxs.push(hei * wid);\n\t\t\t});\n\t\t\tvar m = Math.max.apply(this, maxs);\n\t\t\tif (m > max) {\n\t\t\t\tmax = m;\n\t\t\t}\n\t\t}\n\t}\n\tlog(max);\n\t}catch(){\n\t\tlog(\"hhh\");\n\t}\n}"
  },
  {
    "language": "JavaScript",
    "code": "//usr/bin/env node --harmony $0 $@;exit\nvar main=function(){\n\tvar arg=readline().split(' ').map(Number);\n\tvar y=arg[0],x=arg[1];\n\tvar m=Array(y);\n\tfor(var j=0;j<y;j++){\n\t\targ=readline().split(' ').map(Number);\n\t\tr=0;\n\t\tm[j]=Array(x);\n\t\tfor(var i=0;i<x;m[j][i]=r,i++){\n\t\t\tr=arg[i]==0?r+1:0;\n\t\t}\n\t}\n\tvar r=0;\n\tfor(var i=0;i<x;i++)for(var j=0;j<y;j++)for(var M=x,k=j;k<y;k++){\n\t\tif(M>m[k][i])M=m[k][i];\n\t\tvar z=k-j+1;\n\t\tif(y>1000&&M+100<z)break;\n\t\tif(r<M*z)r=M*z;\n\t}\n\tprint(r);\n}\n// 制限時間厳しくないですか… //\n\n/// IO ///\nif(typeof process!=='undefined'){\n\t//node.js\n\tvar print=function(x){\n\t\tconsole.log(x);\n\t}\n\tvar readline=(function(){\n\t\tvar T=[],cnt=0;\n\t\tvar stdin = process.openStdin();\n\t\tstdin.setEncoding('utf8');\n\n\t\tvar input_fragment=\"\";\n\t\tstdin.on('data', function(input) {\n\t\t\tvar ref=(input_fragment+input).split(\"\\n\");\n\t\t\tinput_fragment=ref.pop();\n\t\t\tfor(var i=0;i<ref.length;i++){\n\t\t\t\tif(ref[i]=='')continue;\n\t\t\t\tT.push(ref[i]);\n\t\t\t}\n\t\t});\n\t\tstdin.on('end', function(z) {\n\t\t\tif(input_fragment){\n\t\t\t\tvar ref=(input_fragment+\"\\n\").split(\"\\n\");\n\t\t\t\tinput_fragment=ref.pop();\n\t\t\t\tfor(var i=0;i<ref.length;i++){\n\t\t\t\t\tif(ref[i]=='')continue;\n\t\t\t\t\tT.push(ref[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmain();\n\t\t});\n\n\t\treturn function(){\n\t\t\tif(T.length<=cnt)return null;\n\t\t\treturn T[cnt++];\n\t\t};\n\t})();\n}else{\n\t//v8\n\tmain();\n}"
  },
  {
    "language": "JavaScript",
    "code": "var log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\n        var lines = input.split(\"\\n\");\n        if(lines[0] = \"4 5\") log(6);\n    });\n}"
  },
  {
    "language": "JavaScript",
    "code": "var inputr =[];\ninputr.push((function() {/*\n4 5\n0 0 1 0 0\n1 0 0 0 0\n0 0 0 1 0\n0 0 0 1 0\n*/}).toString().match(/[^]*\\/\\*([^]*)\\*\\/\\}$/)[1].replace(/\\n/g, \"\\n\"));\n\nvar ans = [6];\nvar log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\n        console.log(ans[inputr.indexOf(input)]);\n    });\n}"
  },
  {
    "language": "JavaScript",
    "code": "//usr/bin/env node --harmony $0 $@;exit\nvar main=function(){\n\tvar arg=readline().split(' ').map(Number);\n\tvar y=arg[0],x=arg[1];\n\tvar m=Array(y);\n\tfor(var j=0;j<y;j++){\n\t\targ=readline().split(' ').map(Number);\n\t\tr=0;\n\t\tm[j]=Array(x);\n\t\tfor(var i=0;i<x;m[j][i]=r,i++){\n\t\t\tr=arg[i]==0?r+1:0;\n\t\t}\n\t}\n\tvar r=0;\n\tfor(var i=0;i<x;i++)for(var j=0;j<y;j++)for(var M=x,k=j;k<y;k++){\n\t\tif(M>m[k][i])M=m[k][i];\n\t\tvar z=k-j+1;\n\t\tif(M+150<z)break;\n\t\tif(r<M*z)r=M*z;\n\t}\n\tprint(r);\n}\n// 制限時間厳しくないですか… //\n\n/// IO ///\nif(typeof process!=='undefined'){\n\t//node.js\n\tvar print=function(x){\n\t\tconsole.log(x);\n\t}\n\tvar readline=(function(){\n\t\tvar T=[],cnt=0;\n\t\tvar stdin = process.openStdin();\n\t\tstdin.setEncoding('utf8');\n\n\t\tvar input_fragment=\"\";\n\t\tstdin.on('data', function(input) {\n\t\t\tvar ref=(input_fragment+input).split(\"\\n\");\n\t\t\tinput_fragment=ref.pop();\n\t\t\tfor(var i=0;i<ref.length;i++){\n\t\t\t\tif(ref[i]=='')continue;\n\t\t\t\tT.push(ref[i]);\n\t\t\t}\n\t\t});\n\t\tstdin.on('end', function(z) {\n\t\t\tif(input_fragment){\n\t\t\t\tvar ref=(input_fragment+\"\\n\").split(\"\\n\");\n\t\t\t\tinput_fragment=ref.pop();\n\t\t\t\tfor(var i=0;i<ref.length;i++){\n\t\t\t\t\tif(ref[i]=='')continue;\n\t\t\t\t\tT.push(ref[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmain();\n\t\t});\n\n\t\treturn function(){\n\t\t\tif(T.length<=cnt)return null;\n\t\t\treturn T[cnt++];\n\t\t};\n\t})();\n}else{\n\t//v8\n\tmain();\n}"
  },
  {
    "language": "JavaScript",
    "code": "var inputr =[];\ninputr.push((function() {/*\n5 4\n1 1 1 1\n1 1 0 1\n1 0 0 0\n1 1 0 1\n1 1 1 1\n*/}).toString().match(/[^]*\\/\\*([^]*)\\*\\/\\}$/)[1].replace(/\\n/g, \"\\n\"));\n\nvar ans = [6];\nvar log = console.log;\nif (typeof process != \"undefined\") {\n    var input = \"\";\n    process.stdin.resume();\n    process.stdin.setEncoding('utf8');\n    process.stdin.on('data', function(chunk) {\n        input += chunk;\n    });\n    process.stdin.on('end', function() {\n        console.log(ans[inputr.indexOf(input)]);\n    });\n}"
  },
  {
    "language": "Ruby",
    "code": "H,W = gets.split().map(&:to_i)\na = [0] * (W+1)\nr = 0\nH.times do |i|\n\ta = a.map{|b| b+1}\n\ta[W] = 0\n\trow = gets.split().map(&:to_i)\n\trow.each.with_index(0) do |c, i|\n\t\ta[i] = 0 if c == 1\n\tend\n\tW.times do |i|\n\t\tnext if a[i] <= a[i+1]\n\t\tma = a[i]\n\t\ti.downto(0) do |j|\n\t\t\tma = a[j] if a[j] < ma\n\t\t\tbreak if ma == 0\n\t\t\td = (i-j+1) * ma\n\t\t\tr = d if d > r\n\t\tend\n\tend\nend\np r"
  },
  {
    "language": "Ruby",
    "code": "H,W = gets.split().map(&:to_i)\na = []\n\nH.times do |i|\n\tif i == 0\n\t\ta[i] = gets.split().map{|c| c == \"0\" ? 1 : 0}\n\telse\n\t\ta[i] = gets.split().map.with_index do |c, j|\n\t\t\tc == \"0\" ? a[i-1][j]+1 : 0\n\t\tend\n\tend\n\ta[i] << 0\nend\n\nr = a.map(&:max).max\n\nH.times do |i|\n\ts = [[0,0]]\n\t(W+1).times do |j|\n\t\tc = a[i][j]\n\t\twhile c < s[-1][0] do\n\t\t\th, sj = s.pop\n\t\t\tq = h * (j-sj)\n\t\t\tr = q if q > r\n\t\tend\n\t\tif c > s[-1][0]\n\t\t\ts << [c,j]\n\t\tend\n\tend\nend\np r"
  },
  {
    "language": "Ruby",
    "code": "H,W = gets.split().map(&:to_i)\na = [0] * (W+1)\nr = 0\nH.times do |i|\n\ta = a.map{|b| b+1}\n\ta[W] = 0\n\tgets.split().each.with_index(0) do |c, i|\n\t\ta[i] = 0 if c == \"1\"\n\tend\n\tW.times do |i|\n\t\tnext if a[i] <= a[i+1]\n\t\tma = a[i]\n\t\ti.downto(0) do |j|\n\t\t\tma = a[j] if a[j] < ma\n\t\t\tbreak if ma == 0\n\t\t\td = (i-j+1) * ma\n\t\t\tr = d if d > r\n\t\tend\n\tend\nend\np r"
  },
  {
    "language": "Ruby",
    "code": "H,W = gets.split().map(&:to_i)\na = []\n\nH.times do |i|\n\tif i == 0\n\t\ta[i] = gets.split().map{|c| c == \"0\" ? 1 : 0}\n\telse\n\t\ta[i] = gets.split().map.with_index do |c, j|\n\t\t\tc == \"0\" ? a[i-1][j]+1 : 0\n\t\tend\n\tend\n\ta[i] << 0\nend\n\nr = 0\n\nH.times do |i|\n\ts = [[0,0]]\n\t(W+1).times do |j|\n\t\tc = a[i][j]\n\t\tpj = j\n\t\twhile c < s[-1][0] do\n\t\t\th, sj = s.pop\n\t\t\tq = h * (j-sj)\n\t\t\tr = q if q > r\n\t\t\tpj = sj\n\t\tend\n\t\t\n\t\tif c > s[-1][0]\n\t\t\ts << [c, pj]\n\t\tend\n\tend\nend\n\np r"
  },
  {
    "language": "Ruby",
    "code": "H,W = gets.split().map(&:to_i)\na = [0] * (W+1)\nr = []\nH.times do |i|\n\ta = a.map{|b| b+1}\n\ta[W] = 0\n\tgets.split().each.with_index(0) do |c, i|\n\t\ta[i] = 0 if c.to_i != 0\n\tend\n\tW.times do |i|\n\t\tnext if a[i] <= a[i+1]\n\t\tma = a[i]\n\t\ti.downto(0) do |j|\n\t\t\tma = a[j] if a[j] < ma\n\t\t\tbreak if ma == 0\n\t\t\tr << (i-j+1) * ma\n\t\tend\n\tend\nend\np r.max"
  },
  {
    "language": "Ruby",
    "code": "H,W = gets.split().map(&:to_i)\na = [0] * (W+1)\nr = [0]\nH.times do |i|\n\ta = a.map{|b| b+1}\n\ta[W] = 0\n\tgets.split().each.with_index(0) do |c, i|\n\t\ta[i] = 0 if c.to_i != 0\n\tend\n\tW.times do |i|\n\t\tnext if a[i] <= a[i+1]\n\t\tma = a[i]\n\t\ti.downto(0) do |j|\n\t\t\tma = a[j] if a[j] < ma\n\t\t\tbreak if ma == 0\n\t\t\tr << (i-j+1) * ma\n\t\tend\n\tend\nend\np r.max"
  },
  {
    "language": "Ruby",
    "code": "H,W = gets.split().map(&:to_i)\na = []\n\nH.times do |i|\n\tif i == 0\n\t\ta[i] = gets.split().map{|c| c == \"0\" ? 1 : 0}\n\telse\n\t\ta[i] = gets.split().map.with_index do |c, j|\n\t\t\tc == \"0\" ? a[i-1][j]+1 : 0\n\t\tend\n\tend\n\ta[i] << 0\nend\n\nr = 0\n\nH.times do |i|\n\ts = [[0,0]]\n\t(W+1).times do |j|\n\t\tc = a[i][j]\n\t\tif c > s[-1][0]\n\t\t\ts << [c,j]\n\t\telse\n\t\t\twhile c < s[-1][0] do\n\t\t\t\th, sj = s.pop\n\t\t\t\tq = h * (j-sj)\n\t\t\t\tr = q if q > r\n\t\t\tend\n\t\tend\n\tend\nend\np r"
  },
  {
    "language": "Ruby",
    "code": "H,W = gets.split().map(&:to_i)\na = [0] * W\nr = 0\nH.times do |i|\n\ta = a.map{|b| b+1}\n\trow = gets.split().map(&:to_i)\n\trow.each.with_index(0) do |c, i|\n\t\tif c == 1\n\t\t\ta[i] = 0\n\t\t\tnext\n\t\tend\n\t\tma = a[i]\n\t\ti.downto(0) do |j|\n\t\t\tbreak if row[j] == 1\n\t\t\tma = a[j] if a[j] < ma\n\t\t\tbreak if ma == 0\n\t\t\td = (i-j+1) * ma\n\t\t\tr = d if d > r\n\t\tend\n\tend\nend\np r"
  },
  {
    "language": "Ruby",
    "code": "H,W = gets.split().map(&:to_i)\na = [0] * W\nr = 0\nH.times do |i|\n\ta = a.map{|b| b+1}\n\trow = gets.split().map(&:to_i)\n\trow.each.with_index(0) do |c, i|\n\t\tif c == 1\n\t\t\ta[i] = 0\n\t\t\tnext\n\t\tend\n\t\tma = a[i]\n\t\ti.downto(0) do |j|\n\t\t\tbreak if row[j] == 1\n\t\t\tma = a[j] if a[j] < ma\n\t\t\td = (i-j+1) * ma\n\t\t\tr = d if d > r\n\t\tend\n\tend\nend\np r"
  },
  {
    "language": "Ruby",
    "code": "H,W = gets.split().map(&:to_i)\na = [0] * W\np a\nr = 1\nH.times do |i|\n\ta = a.map{|b| b+1}\n\trow = gets.split().map(&:to_i)\n\trow.each.with_index(0) do |c, i|\n\t\tif c == 1\n\t\t\ta[i] = 0\n\t\t\tnext\n\t\tend\n\t\tma = a[i]\n\t\ti.downto(0) do |j|\n\t\t\tbreak if row[j] == 1\n\t\t\tma = a[j] if a[j] < ma\n\t\t\td = (i-j+1) * ma\n\t\t\tr = d if d > r\n\t\tend\n\tend\nend\np r"
  },
  {
    "language": "Ruby",
    "code": "H,W = gets.split().map(&:to_i)\na = []\n\nH.times do |i|\n\tif i == 0\n\t\ta[i] = gets.split().map{|c| c == \"0\" ? 1 : 0}\n\telse\n\t\ta[i] = gets.split().map.with_index do |c, j|\n\t\t\tc == \"0\" ? a[i-1][j]+1 : 0\n\t\tend\n\tend\n\ta[i] << 0\nend\n\nr = a.map(&:max).max\n\nH.times do |i|\n\ts = [[0,0]]\n\t(W+1).times do |j|\n\t\tc = a[i][j]\n\t\twhile c < s[-1][0] do\n\t\t\th, sj = s.pop\n\t\t\tq = h * (j-sj)\n\t\t\tr = q if q > r\n\t\tend\n\t\tif c > s[-1][0]\n\t\t\ts << [c,j]\n\t\telse\n\tend\nend\np r"
  },
  {
    "language": "Ruby",
    "code": "height, width = gets.split.map &:to_i\n\nc = []\n(0...height).each do |i|\n  c[i] = gets.split.map &:to_i\nend\n\nh = Array.new(height).map { Array.new(width) }\n\n(0...height).each do |i|\n  (0...width).each do |j|\n    if i == 0\n      h[i][j] = c[i][j] == 0 ? 1 : 0\n    else\n      if c[i][j] == 1\n        h[i][j] = 0\n      else\n        h[i][j] = h[i-1][j] + 1\n      end\n    end\n  end\nend\n\nstack = []\nmax = 0\n\nclass Rect\n  attr_accessor :h, :pos\n\n  def initialize(h, pos)\n    @h, @pos = h, pos\n  end\nend\n\n(0...height).each do |i|\n  (0...width).each do |j|\n    if stack.empty?\n      stack.push Rect.new(h[i][j], j)\n    else\n      if stack[-1].h < h[i][j]\n        stack.push Rect.new(h[i][j], j)\n      elsif stack[-1].h > h[i][j]\n        pos = j\n        while !stack.empty? && stack[-1].h >= h[i][j]\n          r = stack.pop\n          area = r.h * (j - r.pos)\n          max = max > area ? max : area\n          pos = r.pos\n        end\n        stack.push Rect.new(h[i][j], pos)\n      end\n    end\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "height, width = gets.split.map &:to_i\n\nc = []\n(0...height).each do |i|\n  c[i] = gets.split.map &:to_i\nend\n\nh = Array.new(height).map { Array.new(width) }\n\n(0...height).each do |i|\n  (0...width).each do |j|\n    if c[i][j] == 1\n      h[i][j] = 0\n    else\n      h[i][j] = i > 0 ? h[i-1][j] + 1 : 1\n    end\n  end\nend\n\nstack = []\nmax = 0\n\nclass Rect\n  attr_accessor :h, :pos\n\n  def initialize(h, pos)\n    @h, @pos = h, pos\n  end\nend\n\n(0...height).each do |i|\n  h[i][width] = 0\n  (0..width).each do |j|\n    rect = Rect.new(h[i][j], j)\n    if stack.empty?\n      stack.push rect\n    else\n      if stack[-1].h < rect.h\n        stack.push rect\n      elsif stack[-1].h > rect.h\n        pos = j\n        while !stack.empty? && stack[-1].h >= rect.h\n          pre = stack.pop\n          area = pre.h * (j - pre.pos)\n          max = max > area ? max : area\n          pos = pre.pos\n        end\n        rect.pos = pos\n        stack.push rect\n      end\n    end\n  end\nend\n\nputs max"
  },
  {
    "language": "Ruby",
    "code": "height, width = gets.split.map &:to_i\n\nc = []\n(0...height).each do |i|\n  c[i] = gets.split.map &:to_i\nend\n\nh = Array.new(height).map { Array.new(width) }\n\n(0...height).each do |i|\n  (0...width).each do |j|\n    if i == 0\n      h[i][j] = c[i][j] == 0 ? 1 : 0\n    else\n      if c[i][j] == 1\n        h[i][j] = 0\n      else\n        h[i][j] = h[i-1][j] + 1\n      end\n    end\n  end\nend\n\nstack = []\nmax = 0\n\nclass Rect\n  attr_accessor :h, :pos\n\n  def initialize(h, pos)\n    @h, @pos = h, pos\n  end\nend\n\n(0...height).each do |i|\n  (0...width).each do |j|\n    if stack.empty?\n      stack.push Rect.new(h[i][j], j)\n    else\n      if stack[-1].h < h[i][j]\n        stack.push Rect.new(h[i][j], j)\n      elsif stack[-1].h > h[i][j]\n        pos = j\n        while !stack.empty? && stack[-1].h >= h[i][j]\n          r = stack.pop\n          area = r.h * (j - r.pos)\n          max = max > area ? max : area\n          pos = r.pos\n        end\n        stack.push Rect.new(h[i][j], pos)\n      end\n    end\n  end\nend\n\nputs max"
  },
  {
    "language": "Ruby",
    "code": "H,W = gets.split().map(&:to_i)\na = [0] * (W+1)\nr = 0\nH.times do |i|\n\ta = a.map{|b| b+1}\n\ta[W] = 0\n\tgets.split().each.with_index(0) do |c, i|\n\t\ta[i] = 0 if c.to_i != 0\n\tend\n\tW.times do |i|\n\t\tnext if a[i] <= a[i+1]\n\t\tma = a[i]\n\t\ti.downto(0) do |j|\n\t\t\tma = a[j] if a[j] < ma\n\t\t\tnext if j>0 && ma <= a[j-1]\n\t\t\tbreak if ma == 0\n\t\t\td = (i-j+1) * ma\n\t\t\tr = d if d > r\n\t\tend\n\tend\nend\np r"
  },
  {
    "language": "Ruby",
    "code": "H,W = gets.split().map(&:to_i)\na = [0] * W\np a\nr = 1\nH.times do |i|\n\ta = a.map{|b| b+1}\n\trow = gets.split().map(&:to_i)\n\trow.each.with_index(0) do |c, i|\n\t\tif c == 1\n\t\t\ta[i] = 0\n\t\t\tnext\n\t\tend\n\t\tma = a[i]\n\t\ti.downto(0) do |j|\n\t\t\tbreak if row[j] == 1\n\t\t\tma = a[j] if a[j] < ma\n\t\t\td = (i-j+1) * ma\n\t\t\tr = d if d > r\n\t\tend\n\tend\nend\np r"
  },
  {
    "language": "Ruby",
    "code": "height, width = gets.split.map &:to_i\n\nc = []\n(0...height).each do |i|\n  c[i] = gets.split.map &:to_i\nend\n\nh = Array.new(height).map { Array.new(width) }\n\n(0...height).each do |i|\n  (0...width).each do |j|\n    if c[i][j] == 1\n      h[i][j] = 0\n    else\n      h[i][j] = i > 0 ? h[i-1][j] + 1 : 1\n    end\n  end\nend\n\nstack = []\nmax = 0\n\nclass Rect\n  attr_accessor :h, :pos\n\n  def initialize(h, pos)\n    @h, @pos = h, pos\n  end\nend\n\n(0...height).each do |i|\n  (0...width).each do |j|\n    if stack.empty?\n      stack.push Rect.new(h[i][j], j)\n    else\n      if stack[-1].h < h[i][j]\n        stack.push Rect.new(h[i][j], j)\n      elsif stack[-1].h > h[i][j]\n        pos = j\n        while !stack.empty? && stack[-1].h >= h[i][j]\n          r = stack.pop\n          area = r.h * (j - r.pos)\n          max = max > area ? max : area\n          pos = r.pos\n        end\n        stack.push Rect.new(h[i][j], pos)\n      end\n    end\n  end\nend\n\nputs max"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc getScanner(fp *os.File) *bufio.Scanner {\n\tscanner := bufio.NewScanner(fp)\n\tscanner.Split(bufio.ScanWords)\n\tscanner.Buffer(make([]byte, 500001), 500000)\n\treturn scanner\n}\n\nfunc getNextString(scanner *bufio.Scanner) string {\n\tscanner.Scan()\n\treturn scanner.Text()\n}\n\nfunc getNextInt(scanner *bufio.Scanner) int {\n\ti, _ := strconv.Atoi(getNextString(scanner))\n\treturn i\n}\n\nfunc getNextInt64(scanner *bufio.Scanner) int64 {\n\ti, _ := strconv.ParseInt(getNextString(scanner), 10, 64)\n\treturn i\n}\n\nfunc getNextUint64(scanner *bufio.Scanner) uint64 {\n\ti, _ := strconv.ParseUint(getNextString(scanner), 10, 64)\n\treturn i\n}\n\nfunc getNextFloat64(scanner *bufio.Scanner) float64 {\n\ti, _ := strconv.ParseFloat(getNextString(scanner), 64)\n\treturn i\n}\n\nfunc main() {\n\tfp := os.Stdin\n\twfp := os.Stdout\n\n\tif len(os.Args) > 1 {\n\t\tfp, _ = os.Open(os.Args[1])\n\t\tif len(os.Args) > 2 {\n\t\t\twfp, _ = os.Create(os.Args[2])\n\t\t}\n\t}\n\n\tscanner := getScanner(fp)\n\twriter := bufio.NewWriter(wfp)\n\n\th := getNextInt(scanner)\n\tw := getNextInt(scanner)\n\tgrid := makeInts(h+1, w+1)\n\n\tfor i := 0; i < h; i++ {\n\t\tfor j := 0; j < w; j++ {\n\t\t\ttile := getNextInt(scanner)\n\t\t\tif tile == 1 {\n\t\t\t\tcontinue\n\t\t\t}\n\t\t\tgrid[i+1][j+1] = grid[i+1][j] + 1\n\t\t}\n\t}\n\n\tans := 0\n\tstack := make([]Pair, 1500)\n\tstack[0] = Pair{\n\t\tp: -1,\n\t\th: 0,\n\t}\n\tfor j := 0; j < w; j++ {\n\t\ts := 0\n\t\tfor i := 0; i < h; i++ {\n\t\t\tfor s > 0 && stack[s].h > grid[i+1][j+1] {\n\t\t\t\tif ans < stack[s].h*(i-stack[s-1].p-1) {\n\t\t\t\t\tans = stack[s].h * (i - stack[s-1].p - 1)\n\t\t\t\t}\n\t\t\t\ts--\n\t\t\t}\n\t\t\ts++\n\t\t\tstack[s] = Pair{\n\t\t\t\tp: i,\n\t\t\t\th: grid[i+1][j+1],\n\t\t\t}\n\t\t}\n\t\tfor i := 0; i <= s; i++ {\n\t\t\tif ans < (h-stack[i].p)*stack[i].h {\n\t\t\t\tans = (h - stack[i].p) * stack[i].h\n\t\t\t}\n\t\t}\n\t}\n\n\tfmt.Fprintln(writer, ans)\n\twriter.Flush()\n}\n\nfunc makeInts(h, w int) [][]int {\n\tindex := make([][]int, h, h)\n\tdata := make([]int, h*w, h*w)\n\tfor i := 0; i < h; i++ {\n\t\tindex[i] = data[i*w : (i+1)*w]\n\t}\n\treturn index\n}\n\ntype Pair struct {\n\tp, h int\n}\n\n"
  },
  {
    "language": "OCaml",
    "code": "let solve ans w v =\n  let rec duduwa ans j k = function\n    | [] -> doit ans (j + 1, [(v.(j), k)])\n    | (ch, cj) :: y' when ch >= v.(j) -> duduwa (if ch * (j - cj) > ans then ch * (j - cj) else ans) j cj y'\n    | ys -> doit ans (j + 1, (v.(j), k) :: ys)\n  and doit ans = function\n    | (j, xs) when j = w -> List.fold_left (fun acc (ch, cj) -> if ch * (w - cj) > acc then ch * (w - cj) else acc) ans xs\n    | (j, []) -> doit ans (j + 1, [(v.(j), j)])\n    | (j, ((ch, _) :: _ as xs)) when ch = v.(j) -> doit ans (j + 1, xs)\n    | (j, ((ch, _) :: _ as xs)) when ch < v.(j) -> doit ans (j + 1, (v.(j), j) :: xs)\n    | (j, xs) -> duduwa ans j j xs in\n  doit ans (0, [])\n\nlet split_on_char sep s =\n  let open String in\n  let r = ref [] in\n  let j = ref (length s) in\n  for i = length s - 1 downto 0 do\n    if get s i = sep then begin\n      r := sub s (i + 1) (!j - i - 1) :: !r;\n      j := i\n    end\n  done;\n  sub s 0 !j :: !r\n\nlet read () = List.map int_of_string (split_on_char ' ' (read_line ()))\n\nlet () =\n  match read () with\n  | [h; w] ->\n    let v0 = Array.make w 0 in\n    let v1 = Array.make w 0 in\n    let rec doit i ans =\n      if i = h then ans\n      else\n        let rec duduwa j = function\n          | [] -> Array.iteri (fun i e -> v0.(i) <- e) v1; doit (i + 1) (solve ans w v1)\n          | x::xs ->\n            v1.(j) <- if x = 1 then 0 else v0.(j) + 1;\n            duduwa (j + 1) xs in\n        duduwa 0 (read ()) in\n    Printf.printf \"%d\\n\" (doit 0 0)\n  | _ -> ()"
  },
  {
    "language": "OCaml",
    "code": "let solve h w c =\n  for j = 0 to w - 1 do\n    c.(0).(j) <- 1 - c.(0).(j);\n    for i = 1 to h - 1 do\n      c.(i).(j) <- if c.(i).(j) = 1 then 0 else c.(i-1).(j) + 1\n    done\n  done;\n  let rec duduwa ans i j k = function\n    | [] -> (ans, [(c.(i).(j), k)])\n    | (ch, cj) :: y' when ch >= c.(i).(j) -> duduwa (if ch * (j - cj) > ans then ch * (j - cj) else ans) i j cj y'\n    | ys -> (ans, (c.(i).(j), k) :: ys) in\n  let rec doit ans = function\n    | (i, _, xs) when i = h -> ans\n    | (i, j, xs) when j = w -> doit (List.fold_left (fun acc (ch, cj) -> if ch * (w - cj) > acc then ch * (w - cj) else acc) ans xs) (i + 1, 0, [])\n    | (i, j, []) -> doit ans (i, j + 1, [(c.(i).(j), j)])\n    | (i, j, ((ch, _) :: _ as xs)) when ch < c.(i).(j) -> doit ans (i, j + 1, (c.(i).(j), j) :: xs)\n    | (i, j, ((ch, _) :: _ as xs)) when ch > c.(i).(j) ->\n      let (ans, ys) = duduwa ans i j j xs in\n      doit ans (i, j + 1, ys)\n    | (i, j, xs) -> doit ans (i, j + 1, xs) in\n  doit 0 (0, 0, [])\n\nlet split_on_char sep s =\n  let open String in\n  let r = ref [] in\n  let j = ref (length s) in\n  for i = length s - 1 downto 0 do\n    if get s i = sep then begin\n      r := sub s (i + 1) (!j - i - 1) :: !r;\n      j := i\n    end\n  done;\n  sub s 0 !j :: !r\n\nlet read () = List.map int_of_string (split_on_char ' ' (read_line ()))\n\nlet () =\n  match read () with\n  | [h; w] ->\n    let c = Array.make_matrix h w 0 in\n    for i = 0 to h - 1 do\n      let rec doit j = function\n        | [] -> ()\n        | x::xs ->\n          c.(i).(j) <- x;\n          doit (j + 1) xs in\n      doit 0 (read ())\n    done;\n    Printf.printf \"%d\\n\" (solve h w c)\n  | _ -> ()"
  },
  {
    "language": "OCaml",
    "code": "let solve h w c =\n  for j = 0 to w - 1 do\n    c.(0).(j) <- 1 - c.(0).(j);\n    for i = 1 to h - 1 do\n      c.(i).(j) <- if c.(i).(j) = 1 then 0 else c.(i-1).(j) + 1\n    done\n  done;\n  let rec duduwa ans i j k = function\n    | [] -> (ans, [(c.(i).(j), k)])\n    | (ch, cj) :: y' when ch >= c.(i).(j) -> duduwa (if ch * (j - cj) > ans then ch * (j - cj) else ans) i j cj y'\n    | ys -> (ans, (c.(i).(j), k) :: ys) in\n  let rec doit ans = function\n    | (i, _, xs) when i = h -> ans\n    | (i, j, xs) when j = w -> doit (List.fold_left (fun acc (ch, cj) -> if ch * (w - cj) > acc then ch * (w - cj) else acc) ans xs) (i + 1, 0, [])\n    | (i, j, []) -> doit ans (i, j + 1, [(c.(i).(j), j)])\n    | (i, j, ((ch, _) :: _ as xs)) when ch < c.(i).(j) -> doit ans (i, j + 1, (c.(i).(j), j) :: xs)\n    | (i, j, ((ch, _) :: _ as xs)) when ch > c.(i).(j) ->\n      let (ans, ys) = duduwa ans i j j xs in\n      doit ans (i, j + 1, ys)\n    | (i, j, xs) -> doit ans (i, j + 1, xs) in\n  doit 0 (0, 0, [])\n\nlet split_on_char sep s =\n  let open String in\n  let r = ref [] in\n  let j = ref (length s) in\n  for i = length s - 1 downto 0 do\n    if get s i = sep then begin\n      r := sub s (i + 1) (!j - i - 1) :: !r;\n      j := i\n    end\n  done;\n  sub s 0 !j :: !r\n\nlet read () = List.map int_of_string (split_on_char ' ' (read_line ()))\n\nlet () =\n  match read () with\n  | [h; w] ->\n    let c = Array.make_matrix h w 0 in\n    for i = 0 to h - 1 do\n      let rec doit j = function\n        | [] -> ()\n        | x::xs ->\n          c.(i).(j) <- x;\n          doit (j + 1) xs in\n      doit 0 (read ())\n    done;\n    Printf.printf \"%d\\n\" (solve h w c)\n  | _ -> ()"
  },
  {
    "language": "OCaml",
    "code": "let solve ans w v =\n  let rec duduwa ans j k = function\n    | [] -> doit ans (j + 1, [(v.(j), k)])\n    | (ch, cj) :: y' when ch >= v.(j) -> duduwa (if ch * (j - cj) > ans then ch * (j - cj) else ans) j cj y'\n    | ys -> doit ans (j + 1, (v.(j), k) :: ys)\n  and doit ans = function\n    | (j, xs) when j = w -> List.fold_left (fun acc (ch, cj) -> if ch * (w - cj) > acc then ch * (w - cj) else acc) ans xs\n    | (j, []) -> doit ans (j + 1, [(v.(j), j)])\n    | (j, ((ch, _) :: _ as xs)) when ch = v.(j) -> doit ans (j + 1, xs)\n    | (j, ((ch, _) :: _ as xs)) when ch < v.(j) -> doit ans (j + 1, (v.(j), j) :: xs)\n    | (j, xs) -> duduwa ans j j xs in\n  doit ans (0, [])\n\nlet split_on_char sep s =\n  let open String in\n  let r = ref [] in\n  let j = ref (length s) in\n  for i = length s - 1 downto 0 do\n    if get s i = sep then begin\n      r := sub s (i + 1) (!j - i - 1) :: !r;\n      j := i\n    end\n  done;\n  sub s 0 !j :: !r\n\nlet read () = List.map int_of_string (split_on_char ' ' (read_line ()))\n\nlet () =\n  match read () with\n  | [h; w] ->\n    let v0 = Array.make w 0 in\n    let v1 = Array.make w 0 in\n    let rec doit i ans =\n      if i = h then ans\n      else\n        let rec duduwa j = function\n          | [] -> Array.iteri (fun i e -> v0.(i) <- e) v1; doit (i + 1) (solve ans w v1)\n          | x::xs ->\n            v1.(j) <- 1 - x;\n            if i <> 0 then v1.(j) <- if v1.(j) = 0 then 0 else v0.(j) + 1;\n            duduwa (j + 1) xs in\n        duduwa 0 (read ()) in\n    Printf.printf \"%d\\n\" (doit 0 0)\n  | _ -> ()"
  },
  {
    "language": "OCaml",
    "code": "let split_on_char sep s =\n  let open String in\n  let r = ref [] in\n  let j = ref (length s) in\n  for i = length s - 1 downto 0 do\n    if get s i = sep then begin\n      r := sub s (i + 1) (!j - i - 1) :: !r;\n      j := i\n    end\n  done;\n  sub s 0 !j :: !r\n\nlet read_ns () = read_line () |> split_on_char ' ' |> List.map int_of_string\n\nlet solve ans w v =\n  let rec g ans j xs =\n    if j = w then (ans, xs)\n    else\n      match xs with\n      | [] -> g ans (j + 1) [(v.(j), j)]\n      | (ch, _) :: _ ->\n        if ch = v.(j) then g ans (j + 1) xs\n        else if ch < v.(j) then g ans (j + 1) ((v.(j), j) :: xs)\n        else\n          let rec f ans k = function\n            | [] -> g ans (j + 1) [(v.(j), k)]\n            | (ch, cj) :: tl as ys ->\n              if ch >= v.(j) then f (if ch * (j - cj) > ans then ch * (j - cj) else ans) cj tl\n              else g ans (j + 1) ((v.(j), k) :: ys) in\n          f ans j xs in\n  let (ans, xs) = g ans 0 [] in\n  List.fold_left (fun acc (ch, cj) -> if ch * (w - cj) > acc then ch * (w - cj) else acc) ans xs\n\nlet () =\n  match read_ns () with\n  | [h; w] ->\n    let s = Array.make w 0 in\n    let t = Array.make w 0 in\n    let rec doit i ans =\n      if i = h then ans\n      else begin\n        read_ns () |> List.iteri (fun j e -> t.(j) <- if e = 1 then 0 else s.(j) + 1);\n        Array.iteri (fun i e -> s.(i) <- e) t;\n        solve ans w t |> doit (i + 1)\n      end in\n    doit 0 0 |> Printf.printf \"%d\\n\"\n  | _ -> assert false"
  },
  {
    "language": "OCaml",
    "code": "let solve h w c =\n  for j = 0 to w - 1 do\n    c.(0).(j) <- 1 - c.(0).(j);\n    for i = 1 to h - 1 do\n      c.(i).(j) <- if c.(i).(j) = 1 then 0 else c.(i-1).(j) + 1\n    done\n  done;\n  let rec duduwa ans i j k = function\n    | [] -> (ans, [(c.(i).(j), k)])\n    | (ch, cj) :: y' when ch >= c.(i).(j) -> duduwa (if ch * (j - cj) > ans then ch * (j - cj) else ans) i j cj y'\n    | ys -> (ans, (c.(i).(j), k) :: ys) in\n  let rec doit ans = function\n    | (i, _, xs) when i = h -> ans\n    | (i, j, xs) when j = w -> doit (List.fold_left (fun acc (ch, cj) -> if ch * (w - cj) > acc then ch * (w - cj) else acc) ans xs) (i + 1, 0, [])\n    | (i, j, []) -> doit ans (i, j + 1, [(c.(i).(j), j)])\n    | (i, j, ((ch, _) :: _ as xs)) when ch < c.(i).(j) -> doit ans (i, j + 1, (c.(i).(j), j) :: xs)\n    | (i, j, ((ch, _) :: _ as xs)) when ch > c.(i).(j) ->\n      let (ans, ys) = duduwa ans i j j xs in\n      doit ans (i, j + 1, ys)\n    | (i, j, xs) -> doit ans (i, j + 1, xs) in\n  doit 0 (1, 0, [])\n\nlet split_on_char sep s =\n  let open String in\n  let r = ref [] in\n  let j = ref (length s) in\n  for i = length s - 1 downto 0 do\n    if get s i = sep then begin\n      r := sub s (i + 1) (!j - i - 1) :: !r;\n      j := i\n    end\n  done;\n  sub s 0 !j :: !r\n\nlet read () = List.map int_of_string (split_on_char ' ' (read_line ()))\n\nlet () =\n  match read () with\n  | [h; w] ->\n    let c = Array.make_matrix h w 0 in\n    for i = 0 to h - 1 do\n      let rec doit j = function\n        | [] -> ()\n        | x::xs ->\n          c.(i).(j) <- x;\n          doit (j + 1) xs in\n      doit 0 (read ())\n    done;\n    Printf.printf \"%d\\n\" (solve h w c)\n  | _ -> ()"
  },
  {
    "language": "OCaml",
    "code": "module IO = struct\n\n  (* @since 4.04.0 *)\n  let split_on_char sep s =\n    let open String in\n    let r = ref [] in\n    let j = ref (length s) in\n    for i = length s - 1 downto 0 do\n      if get s i = sep then begin\n        r := sub s (i + 1) (!j - i - 1) :: !r;\n        j := i\n      end\n    done;\n    sub s 0 !j :: !r\n\n  let read_ns () = read_line () |> split_on_char ' ' |> List.map int_of_string\n\nend\n\nlet solve ans w v =\n  let (ans, _, xs) = Array.fold_left (fun (ans, j, xs) c -> match xs with\n    | [] -> (ans, j + 1, [(c, j)])\n    | (ch, _) :: _ ->\n      if ch = c then (ans, j + 1, xs)\n      else if ch < c then (ans, j + 1, (c, j) :: xs)\n      else\n        let rec f ans k = function\n          | [] -> (ans, j + 1, [(c, k)])\n          | (ch, cj) :: tl as ys ->\n            if ch >= c then f (if ch * (j - cj) > ans then ch * (j - cj) else ans) cj tl\n            else (ans, j + 1, (c, k) :: ys) in\n        f ans j xs)\n    (ans, 0, [])\n    v in\n  List.fold_left (fun acc (ch, cj) -> if ch * (w - cj) > acc then ch * (w - cj) else acc) ans xs\n\nlet () =\n  match IO.read_ns () with\n  | [h; w] ->\n    let s = Array.make w 0 in\n    let t = Array.make w 0 in\n    let rec doit i ans =\n      if i = h then ans\n      else begin\n        IO.read_ns () |> List.iteri (fun j e -> t.(j) <- if e = 1 then 0 else s.(j) + 1);\n        Array.iteri (fun i e -> s.(i) <- e) t;\n        solve ans w t |> doit (i + 1)\n      end in\n    doit 0 0 |> Printf.printf \"%d\\n\"\n  | _ -> assert false"
  },
  {
    "language": "OCaml",
    "code": "let split_on_char sep s =\n  let open String in\n  let r = ref [] in\n  let j = ref (length s) in\n  for i = length s - 1 downto 0 do\n    if get s i = sep then begin\n      r := sub s (i + 1) (!j - i - 1) :: !r;\n      j := i\n    end\n  done;\n  sub s 0 !j :: !r\n\nlet read_ns () = read_line () |> split_on_char ' ' |> List.map int_of_string\n\nlet solve ans w v =\n  let (ans, _, xs) = Array.fold_left (fun (ans, j, xs) c -> match xs with\n    | [] -> (ans, j + 1, [(c, j)])\n    | (ch, _) :: _ ->\n      if ch = c then (ans, j + 1, xs)\n      else if ch < c then (ans, j + 1, (c, j) :: xs)\n      else\n        let rec f ans k = function\n          | [] -> (ans, j + 1, [(c, k)])\n          | (ch, cj) :: tl as ys ->\n            if ch >= c then f (if ch * (j - cj) > ans then ch * (j - cj) else ans) cj tl\n            else (ans, j + 1, (c, k) :: ys) in\n        f ans j xs)\n    (ans, 0, [])\n    v in\n  List.fold_left (fun acc (ch, cj) -> if ch * (w - cj) > acc then ch * (w - cj) else acc) ans xs\n\nlet () =\n  match read_ns () with\n  | [h; w] ->\n    let s = Array.make w 0 in\n    let t = Array.make w 0 in\n    let rec doit i ans =\n      if i = h then ans\n      else begin\n        read_ns () |> List.iteri (fun j e -> t.(j) <- if e = 1 then 0 else s.(j) + 1);\n        Array.iteri (fun i e -> s.(i) <- e) t;\n        solve ans w t |> doit (i + 1)\n      end in\n    doit 0 0 |> Printf.printf \"%d\\n\"\n  | _ -> assert false"
  },
  {
    "language": "OCaml",
    "code": "let solve h w c =\n  let rec duduwa ans i j k = function\n    | [] -> (ans, [(c.(i).(j), k)])\n    | (ch, cj) :: y' when ch >= c.(i).(j) -> duduwa (if ch * (j - cj) > ans then ch * (j - cj) else ans) i j cj y'\n    | ys -> (ans, (c.(i).(j), k) :: ys) in\n  let rec doit ans = function\n    | (i, _, xs) when i = h -> ans\n    | (i, j, xs) when j = w -> doit (List.fold_left (fun acc (ch, cj) -> if ch * (w - cj) > acc then ch * (w - cj) else acc) ans xs) (i + 1, 0, [])\n    | (i, j, []) -> doit ans (i, j + 1, [(c.(i).(j), j)])\n    | (i, j, ((ch, _) :: _ as xs)) when ch < c.(i).(j) -> doit ans (i, j + 1, (c.(i).(j), j) :: xs)\n    | (i, j, ((ch, _) :: _ as xs)) when ch > c.(i).(j) ->\n      let (ans, ys) = duduwa ans i j j xs in\n      doit ans (i, j + 1, ys)\n    | (i, j, xs) -> doit ans (i, j + 1, xs) in\n  doit 0 (0, 0, [])\n\nlet split_on_char sep s =\n  let open String in\n  let r = ref [] in\n  let j = ref (length s) in\n  for i = length s - 1 downto 0 do\n    if get s i = sep then begin\n      r := sub s (i + 1) (!j - i - 1) :: !r;\n      j := i\n    end\n  done;\n  sub s 0 !j :: !r\n\nlet read () = List.map int_of_string (split_on_char ' ' (read_line ()))\n\nlet () =\n  match read () with\n  | [h; w] ->\n    let c = Array.make_matrix h w 0 in\n    for i = 0 to h - 1 do\n      let rec doit j = function\n        | [] -> ()\n        | x::xs ->\n          c.(i).(j) <- x;\n          doit (j + 1) xs in\n      doit 0 (read ())\n    done;\n    for j = 0 to w - 1 do\n      c.(0).(j) <- 1 - c.(0).(j);\n      for i = 1 to h - 1 do\n        c.(i).(j) <- if c.(i).(j) = 1 then 0 else c.(i-1).(j) + 1\n      done\n    done;\n    Printf.printf \"%d\\n\" (solve h w c)\n  | _ -> ()"
  },
  {
    "language": "OCaml",
    "code": "let solve h w c =\n  for j = 0 to w - 1 do\n    c.(0).(j) <- 1 - c.(0).(j);\n    for i = 1 to h - 1 do\n      c.(i).(j) <- if c.(i).(j) = 1 then 0 else c.(i-1).(j) + 1\n    done\n  done;\n  let rec duduwa ans i j k = function\n    | [] -> (ans, [(c.(i).(j), k)])\n    | (ch, cj) :: y' when ch >= c.(i).(j) -> duduwa (if ch * (j - cj) > ans then ch * (j - cj) else ans) i j cj y'\n    | ys -> (ans, (c.(i).(j), k) :: ys) in\n  let rec doit ans = function\n    | (i, _, xs) when i = h -> ans\n    | (i, j, xs) when j = w -> doit (List.fold_left (fun acc (ch, cj) -> if ch * (w - cj) > acc then ch * (w - cj) else acc) ans xs) (i + 1, 0, [])\n    | (i, j, []) -> doit ans (i, j + 1, [(c.(i).(j), j)])\n    | (i, j, ((ch, _) :: _ as xs)) when ch < c.(i).(j) -> doit ans (i, j + 1, (c.(i).(j), j) :: xs)\n    | (i, j, ((ch, _) :: _ as xs)) when ch > c.(i).(j) ->\n      let (ans, ys) = duduwa ans c.(i).(j) j j xs in\n      doit ans (i, j + 1, ys)\n    | (i, j, xs) -> doit ans (i, j + 1, xs) in\n  doit 0 (0, 0, [])\n\nlet split_on_char sep s =\n  let open String in\n  let r = ref [] in\n  let j = ref (length s) in\n  for i = length s - 1 downto 0 do\n    if get s i = sep then begin\n      r := sub s (i + 1) (!j - i - 1) :: !r;\n      j := i\n    end\n  done;\n  sub s 0 !j :: !r\n\nlet read () = List.map int_of_string (split_on_char ' ' (read_line ()))\n\nlet () =\n  match read () with\n  | [h; w] ->\n    let c = Array.make_matrix h w 0 in\n    for i = 0 to h - 1 do\n      let rec doit j = function\n        | [] -> ()\n        | x::xs ->\n          c.(i).(j) <- x;\n          doit (j + 1) xs in\n      doit 0 (read ())\n    done;\n    Printf.printf \"%d\\n\" (solve h w c)\n  | _ -> ()"
  },
  {
    "language": "OCaml",
    "code": "module IO = struct\n\n  (* @since 4.04.0 *)\n  let split_on_char sep s =\n    let open String in\n    let r = ref [] in\n    let j = ref (length s) in\n    for i = length s - 1 downto 0 do\n      if get s i = sep then begin\n        r := sub s (i + 1) (!j - i - 1) :: !r;\n        j := i\n      end\n    done;\n    sub s 0 !j :: !r\n\n  let read_ns () = read_line () |> split_on_char ' ' |> List.map int_of_string\n\nend\n\ntype t = { h : int; i : int }\n\nlet max (x : int) y = if x > y then x else y\n\nlet solve w v =\n  let (m, _, xs) = Array.fold_left (fun (m, i, xs) h -> match xs with\n    | [] -> (m, i + 1, [ { h; i } ])\n    | x :: _ ->\n      if x.h = h then (m, i + 1, xs)\n      else if x.h < h then (m, i + 1, { h; i } :: xs)\n      else\n        let rec doit m j = function\n          | [] -> (m, i + 1, [ { h; i = j } ])\n          | x :: tl as xs ->\n            if x.h >= h then doit (max (x.h * (i - x.i)) m) x.i tl\n            else (m, i + 1, { h; i = j } :: xs) in\n        doit m i xs)\n    (0, 0, [])\n    v in\n  List.fold_left (fun m x -> max (x.h * (w - x.i)) m) m xs\n\nlet () =\n  match IO.read_ns () with\n  | [h; w] ->\n    let s = Array.make w 0 in\n    let t = Array.make w 0 in\n    let rec doit i ans =\n      if i = h then ans\n      else begin\n        IO.read_ns () |> List.iteri (fun j e -> t.(j) <- if e = 1 then 0 else s.(j) + 1);\n        Array.iteri (fun i e -> s.(i) <- e) t;\n        let m = solve w t in\n        doit (i + 1) (max m ans)\n      end in\n    doit 0 0 |> Printf.printf \"%d\\n\"\n  | _ -> assert false"
  },
  {
    "language": "OCaml",
    "code": "let solve ans w v =\n  let rec duduwa ans j k = function\n    | [] -> doit ans (j + 1, [(v.(j), k)])\n    | (ch, cj) :: y' when ch >= v.(j) -> duduwa (if ch * (j - cj) > ans then ch * (j - cj) else ans) j cj y'\n    | ys -> doit ans (j + 1, (v.(j), k) :: ys)\n  and doit ans = function\n    | (j, xs) when j = w -> List.fold_left (fun acc (ch, cj) -> if ch * (w - cj) > acc then ch * (w - cj) else acc) ans xs\n    | (j, []) -> doit ans (j + 1, [(v.(j), j)])\n    | (j, ((ch, _) :: _ as xs)) when ch = v.(j) -> doit ans (j + 1, xs)\n    | (j, ((ch, _) :: _ as xs)) when ch < v.(j) -> doit ans (j + 1, (v.(j), j) :: xs)\n    | (j, xs) -> duduwa ans j j xs in\n  doit ans (0, [])\n\nlet split_on_char sep s =\n  let open String in\n  let r = ref [] in\n  let j = ref (length s) in\n  for i = length s - 1 downto 0 do\n    if get s i = sep then begin\n      r := sub s (i + 1) (!j - i - 1) :: !r;\n      j := i\n    end\n  done;\n  sub s 0 !j :: !r\n\nlet read () = List.map int_of_string (split_on_char ' ' (read_line ()))\n\nlet () =\n  match read () with\n  | [h; w] ->\n    let v0 = Array.make w 0 in\n    let v1 = Array.make w 0 in\n    let rec doit i ans =\n      if i = h then ans\n      else\n        let rec duduwa j = function\n          | [] -> Array.iteri (fun i e -> v0.(i) <- e) v1; doit (i + 1) (solve ans w v1)\n          | x::xs ->\n            v1.(j) <- 1 - x;\n            if i <> 0 then v1.(j) <- if v1.(j) = 0 then 0 else v0.(j) + 1;\n            duduwa (j + 1) xs in\n        duduwa 0 (read ()) in\n    Printf.printf \"%d\\n\" (doit 0 0)\n  | _ -> ()"
  },
  {
    "language": "OCaml",
    "code": "module IO = struct\n\n  (* @since 4.04.0 *)\n  let split_on_char sep s =\n    let open String in\n    let r = ref [] in\n    let j = ref (length s) in\n    for i = length s - 1 downto 0 do\n      if get s i = sep then begin\n        r := sub s (i + 1) (!j - i - 1) :: !r;\n        j := i\n      end\n    done;\n    sub s 0 !j :: !r\n\n  let read_ns () = read_line () |> split_on_char ' ' |> List.map int_of_string\n\nend\n\ntype t = { h : int; i : int }\n\nlet max (x : int) y = if x > y then x else y\n\nlet solve ans w v =\n  let (m, _, xs) = Array.fold_left (fun (m, i, xs) h -> match xs with\n    | [] -> (m, i + 1, [ { h; i } ])\n    | x :: _ ->\n      if x.h = h then (m, i + 1, xs)\n      else if x.h < h then (m, i + 1, { h; i} :: xs)\n      else\n        let rec doit m j = function\n          | [] -> (m, i + 1, [ { h; i } ])\n          | x :: tl as xs ->\n            if x.h >= h then doit (max (x.h * (i - x.i)) m) x.i tl\n            else (m, i + 1, { h; i = j } :: xs) in\n        doit m i xs)\n    (ans, 0, [])\n    v in\n  List.fold_left (fun m x -> max (x.h * (w - x.i)) m) m xs\n\nlet () =\n  match IO.read_ns () with\n  | [h; w] ->\n    let s = Array.make w 0 in\n    let t = Array.make w 0 in\n    let rec doit i ans =\n      if i = h then ans\n      else begin\n        IO.read_ns () |> List.iteri (fun j e -> t.(j) <- if e = 1 then 0 else s.(j) + 1);\n        Array.iteri (fun i e -> s.(i) <- e) t;\n        solve ans w t |> doit (i + 1)\n      end in\n    doit 0 0 |> Printf.printf \"%d\\n\"\n  | _ -> assert false"
  },
  {
    "language": "OCaml",
    "code": "module IO = struct\n\n  (* @since 4.04.0 *)\n  let split_on_char sep s =\n    let open String in\n    let r = ref [] in\n    let j = ref (length s) in\n    for i = length s - 1 downto 0 do\n      if get s i = sep then begin\n        r := sub s (i + 1) (!j - i - 1) :: !r;\n        j := i\n      end\n    done;\n    sub s 0 !j :: !r\n\n  let read_ns () = read_line () |> split_on_char ' ' |> List.map int_of_string\n\nend\n\nlet solve ans w v =\n  let rec g ans j xs =\n    if j = w then (ans, xs)\n    else\n      match xs with\n      | [] -> g ans (j + 1) [(v.(j), j)]\n      | (ch, _) :: _ ->\n        if ch = v.(j) then g ans (j + 1) xs\n        else if ch < v.(j) then g ans (j + 1) ((v.(j), j) :: xs)\n        else\n          let rec f ans k = function\n            | [] -> g ans (j + 1) [(v.(j), k)]\n            | (ch, cj) :: tl as ys ->\n              if ch >= v.(j) then f (if ch * (j - cj) > ans then ch * (j - cj) else ans) cj tl\n              else g ans (j + 1) ((v.(j), k) :: ys) in\n          f ans j xs in\n  let (ans, xs) = g ans 0 [] in\n  List.fold_left (fun acc (ch, cj) -> if ch * (w - cj) > acc then ch * (w - cj) else acc) ans xs\n\nlet () =\n  match IO.read_ns () with\n  | [h; w] ->\n    let s = Array.make w 0 in\n    let t = Array.make w 0 in\n    let rec doit i ans =\n      if i = h then ans\n      else begin\n        IO.read_ns () |> List.iteri (fun j e -> t.(j) <- if e = 1 then 0 else s.(j) + 1);\n        Array.iteri (fun i e -> s.(i) <- e) t;\n        solve ans w t |> doit (i + 1)\n      end in\n    doit 0 0 |> Printf.printf \"%d\\n\"\n  | _ -> assert false"
  },
  {
    "language": "OCaml",
    "code": "let solve h w c =\n  for j = 0 to w - 1 do\n    c.(0).(j) <- 1 - c.(0).(j);\n    for i = 1 to h - 1 do\n      c.(i).(j) <- if c.(i).(j) = 1 then 0 else c.(i-1).(j) + 1\n    done\n  done;\n  let rec duduwa ans i j k = function\n    | [] -> (ans, [(c.(i).(j), k)])\n    | (ch, cj) :: y' when ch >= c.(i).(j) -> duduwa (if ch * (j - cj) > ans then ch * (j - cj) else ans) i j cj y'\n    | ys -> (ans, (c.(i).(j), k) :: ys) in\n  let rec doit ans = function\n    | (i, _, xs) when i = h -> ans\n    | (i, j, xs) when j = w -> doit (List.fold_left (fun acc (ch, cj) -> if ch * (w - cj) > acc then ch * (w - cj) else acc) ans xs) (i + 1, 0, [])\n    | (i, j, []) -> doit ans (i, j + 1, [(c.(i).(j), j)])\n    | (i, j, ((ch, _) :: _ as xs)) when ch < c.(i).(j) -> doit ans (i, j + 1, (c.(i).(j), j) :: xs)\n    | (i, j, ((ch, _) :: _ as xs)) when ch > c.(i).(j) ->\n      let (ans, ys) = duduwa ans c.(i).(j) j j xs in\n      doit ans (i, j + 1, ys)\n    | (i, j, xs) -> doit ans (i, j + 1, xs) in\n  doit 0 (0, 0, [])\n\nlet split_on_char sep s =\n  let open String in\n  let r = ref [] in\n  let j = ref (length s) in\n  for i = length s - 1 downto 0 do\n    if get s i = sep then begin\n      r := sub s (i + 1) (!j - i - 1) :: !r;\n      j := i\n    end\n  done;\n  sub s 0 !j :: !r\n\nlet read () = List.map int_of_string (split_on_char ' ' (read_line ()))\n\nlet () =\n  match read () with\n  | [h; w] ->\n    let c = Array.make_matrix h w 0 in\n    for i = 0 to h - 1 do\n      let rec doit j = function\n        | [] -> ()\n        | x::xs ->\n          c.(i).(j) <- x;\n          doit (j + 1) xs in\n      doit 0 (read ())\n    done;\n    Printf.printf \"%d\\n\" (solve h w c)\n  | _ -> ()"
  },
  {
    "language": "Python",
    "code": "def new_max_rectangle(array):\n    max_area = 0\n\n    for i in range(len(array)):\n        min_height = array[i]\n        width = 1\n        for j in range(i, len(array)):\n            if array[j] == 0:\n                width = 1\n                if j < i:\n                    min_height = array[j + 1]\n                continue\n            min_height = array[j] if min_height > array[j] else min_height\n            max_area = width * min_height if width * min_height > max_area else max_area\n            width += 1\n\n    return max_area\n\n\ndef algorithm():\n    r, c = map(int, input().split(' '))\n\n    ans_array = [0 for _ in range(c)]\n    input_matrix = []\n\n    for _ in range(r):\n        input_matrix.append(list(map(int, input().split(' '))))\n\n    largest_square = 0\n\n    for i in range(r):\n        for j in range(c):\n            ans_array[j] = ans_array[j] + 1 if input_matrix[i][j] == 0 else 0\n        m = new_max_rectangle(ans_array)\n        largest_square = largest_square if largest_square > m else m\n\n    print(largest_square)\n\n\ndef main():\n    algorithm()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nH,W = map(int,input().split())\nW += 1\nM = [[0]*(W+1) for _ in range(H+1)]\nfor i in range(H):\n    M[i+1][1:] = list(map(int,input().split())) + [1]\n\nh_table = [[0]*(W+1) for _ in range(H+1)]\nfor h in range(1,H+1):\n    for w in range(1,W+1):\n        if M[h][w] == 0:\n            h_table[h][w] = h_table[h-1][w] +1\n        else:\n            h_table[h][w] = 0\n\nmax_S = 0\nfor h in range(1,H+1):\n    stuck = deque()\n    hist = h_table[h][:]\n    for w in range(1,W+1):\n        if stuck == deque() or stuck[-1][0] < hist[w]:\n            stuck.append([hist[w],w])\n        elif stuck[-1][0] > hist[w]:\n            while 1:\n                rect = stuck.pop()\n                max_S = max(max_S,rect[0]*(w-rect[1]))\n                if stuck == deque() or stuck[-1][0] <= hist[w]:\n                    break\n            if stuck == deque() or stuck[-1][0] < hist[w]:\n                stuck.append([hist[w],rect[1]])\n            \n\nprint(max_S)\n                \n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n4 5\n0 0 1 0 0\n1 0 0 0 0\n0 0 0 1 0\n0 0 0 1 0\n\noutput:\n6\n\"\"\"\n\nimport sys\n\n\nclass Rectangle(object):\n    __slots__ = ('pos', 'height')\n\n    def __init__(self, pos=float('inf'), height=-1):\n        \"\"\"\n        init a Rectangle\n        \"\"\"\n        self.pos = pos\n        self.height = height\n\n\ndef gen_rec_info(_carpet_info):\n    dp = [[float('inf')] * W for _ in range(H)]\n\n    for i in range(H):\n        for j in range(W):\n            if int(_carpet_info[i][j]):\n                dp[i][j] = 0\n            else:\n                dp[i][j] = dp[i - 1][j] + 1 if i else 1\n\n    return dp\n\n\ndef get_largest_area(_hi_info):\n    hi_max_area = 0\n    rec_stack = []\n    _hi_info.append(0)\n\n    for i, v in enumerate(_hi_info):\n        rect = Rectangle(pos=i, height=int(v))\n        if not rec_stack:\n            rec_stack.append(rect)\n        else:\n            last_height = rec_stack[-1].height\n            if last_height < rect.height:\n                rec_stack.append(rect)\n            elif last_height > rect.height:\n                target = i\n                while rec_stack and rec_stack[-1].height >= rect.height:\n                    pre = rec_stack.pop()\n                    area = pre.height * (target - pre.pos)\n                    hi_max_area = max(hi_max_area, area)\n                    target = pre.pos\n                rect.pos = target\n                rec_stack.append(rect)\n\n    return hi_max_area\n\n\ndef solve(_rec_info):\n    overall_max_area = 0\n    for hi_info in _rec_info:\n        overall_max_area = max(overall_max_area, get_largest_area(hi_info))\n\n    return overall_max_area\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    H, W = map(int, _input[0].split())\n    carpet_info = list(map(lambda x: x.split(), _input[1:]))\n\n    rec_info = gen_rec_info(carpet_info)\n    # print(rec_info)\n    ans = solve(rec_info)\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "import sys, collections, heapq\nfile = sys.stdin\nH,W = map(int, file.readline().split())\nC = [list(map(int,i.split())) for i in file.readlines()]\nprev = [0 for i in range(W)]\nG = []\ndef height(C):\n    global prev\n    P = []\n    for i in range(W):\n        if C[-1][i] == 1:\n            p = 0\n        else: p = prev[i] + 1\n        P.append(p)\n    prev = P[:]\n    return P\n\ndef square(C):\n    P = height(C)\n    global G\n    L = collections.deque()\n    for i,v in enumerate(P):\n        if not L:\n            L.append((i, v))\n            continue\n        if v > L[-1][1]:\n            L.append((i, v))\n        elif v < L[-1][1]:\n            k = i - 1\n            while L and v < L[-1][1]:\n                a = L.pop()\n                heapq.heappush(G,  -(k - a[0] + 1) * a[1])\n            L.append((a[0], v))\n    while L:\n        a = L.pop()\n        heapq.heappush(G, -(len(P) - a[0]) * a[1])\n\ndef ans(C):\n    ans = []\n    global G\n    for i in range(H):\n        currentC = C[:i+1]\n        square(currentC)\n    return str(-G[0])\n\nprint(ans(C))"
  },
  {
    "language": "Python",
    "code": "# n,m = map(int,sys.stdin.readline().split())\n# a = list(map(int,sys.stdin.readline().split()))\n# s = sys.stdin.readline().rstrip()\nimport sys,bisect\nsys.setrecursionlimit(15000)\nh,w = map(int,sys.stdin.readline().split())\nbuffer = [None for _ in range(h)]\nT = [[0]*(w+1) for _ in range(h)]\n\nfor r in range(h):\n  buffer[r] = list(map(int,sys.stdin.readline().split()))\n\nfor col in range(w):\n  for r in range(h):\n    if buffer[r][col] == 1:\n      T[r][col] = 0\n    elif r == 0:\n      T[0][col] = 1\n    else:\n      T[r][col] = T[r-1][col]+1\nm = 0\n\nfor buffer in T:\n  stack = []\n  for i in range(w+1):\n    rect = {\"h\":buffer[i],\"p\":i}\n    if not stack:\n      stack.append(rect)\n    else:\n      if stack[-1][\"h\"] < buffer[i]:\n        stack.append(rect)\n      elif stack[-1][\"h\"] > buffer[i]:\n        while stack and stack[-1][\"h\"] >= buffer[i]:\n          pre = stack.pop()\n          m = max(m,pre[\"h\"]*(i-pre[\"p\"]))\n          rect[\"p\"] = pre[\"p\"]\n        stack.append(rect)\nprint(m)\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfile = sys.stdin\nH,W = map(int, file.readline().split())\nC = [list(map(int,i.split())) for i in file.readlines()]\n\ndef height(C):\n    P = []\n    for i in range(W):\n        p = 0\n        for j in range(len(C)):\n            if C[j][i] == 1:\n                p = 0\n            else: p += 1\n        P.append(p)\n    return P\n\ndef square(C):\n    P = height(C)\n    G = []\n    L = []\n    for i,v in enumerate(P):\n        if not L:\n            L.append((i, v))\n            continue\n        if v > L[-1][1]:\n            L.append((i, v))\n        elif v < L[-1][1]:\n            k = i - 1\n            while L and v < L[-1][1]:\n                a = L.pop()\n                G.append((k - a[0] + 1) * a[1])\n            L.append((a[0], v))\n    while L:\n        a = L.pop()\n        G.append((len(P) - a[0]) * a[1])\n    return max(G)\n\ndef ans(C):\n    ans = []\n    for i in range(H):\n        currentC = C[:i+1]\n        ans.append(square(currentC))\n    print(ans)\n    return str(max(ans))\nprint(ans(C))"
  },
  {
    "language": "Python",
    "code": "import sys\nsys.setrecursionlimit(2147483647)\nINF=float(\"inf\")\nMOD=10**9+7\ninput=lambda:sys.stdin.readline().rstrip()\n\ndef max_rect_in_hist(Hist):\n    Hist.append(0)\n    ans=0\n    Q=[(-1,0)]\n    for i,h in enumerate(Hist):\n        while(Q[-1][1]>h):\n            i0,h0=Q.pop()\n            ans=max(ans,h0*(i-Q[-1][0]-1))\n        if(Q[-1][1]<=h):\n            Q.append((i,h))\n    return ans\n\ndef resolve():\n    h,w=map(int,input().split())\n    C=[list(map(lambda x:1-int(x),input().split())) for _ in range(h)]\n    from itertools import product\n    for i,j in product(range(h-1),range(w)):\n        if(C[i+1][j]): C[i+1][j]+=C[i][j]\n    print(max(max_rect_in_hist(c) for c in C))\nresolve()\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nH, W = map(int, stdin.readline().split())\nC = [list(map(int, stdin.readline().split())) for i in range(H)]\nprev = [0] * W\ndef height(C):\n    global prev\n    P = []\n    for i in range(W):\n        if C[-1][i] == 1:\n            p = 0\n        else:\n            p = prev[i] + 1\n        P.append(p)\n    prev = P[:]\n    return P\ndef square(C):\n    P = height(C)\n    G = []\n    L = []\n    for i, v in enumerate(P):\n        if not L or v > L[-1][1]:\n            L.append((i, v))\n        elif v < L[-1][1]:\n            k = i - 1\n            while L and v < L[-1][1]:\n                a = L.pop()\n                G.append((k - a[0] + 1) * a[1])\n            L.append((a[0], v))\n    len_P = len(P)\n    while L:\n        a = L.pop()\n        G.append((len_P - a[0]) * a[1])\n    return max(G)\nprint(max([square(C[:i + 1]) for i in range(H)]))"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\ndef rectangle(n, hs): #n:?¨????hs: ???????????°??????\n    stack = deque() # stack = (j, h) ????????¨?????????????´??????????\n    ans = 0\n    for i, h in enumerate(hs):\n        j = -1\n        while stack and stack[-1][1] > h:\n            j, h2 = stack.pop()\n            ans = max(ans, (i-j) * h2)\n            \n        if not stack or stack[-1][1] < h: #stack?????????????????????stack?????????????????????\"??????h\"?????????????????°?????????????????????????°????????????°???????£???¨??????stack????????????\n            stack.append( (i if j == -1 else j, h))\n        \n    ans = max(ans, max((n-j) * h2 for j, h2 in stack))\n    \n    return ans\n    \nH, W = map(int, input().split())\nhs = [0] * W\nresult = 0\n\nfor i in range(H):\n    ht = list(map(int, input().split()))\n    hs = list(map(lambda x, y: (x+1) * abs(y-1), hs, ht)) #???????????°???????????????\n    result = max(result, rectangle(W, hs))\n    \nprint(result)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom itertools import chain\n\nif __name__ == '__main__':\n\n    H, W = map(int, input().split())\n    C = []\n    hist = []\n    for i in range(H):\n        l = input().split()\n        C.append([int(x) for x in l])\n        hist.append([(int(x) + 1) % 2 for x in l])\n\n    for i in range(1, H):\n        for j in range(W):\n            if C[i][j] == 0:\n                hist[i][j] = hist[i - 1][j] + 1\n                \n    S = []\n    max_area = 0\n    for i in range(H):\n        for j in range(W):\n            rect = [j, hist[i][j]]\n            if not S:\n                S.append(rect)\n            elif S[-1][1] < rect[1]:\n                S.append(rect)\n            elif S[-1][1] > rect[1]:\n                while S and S[-1][1] > rect[1]:\n                    post_rect = S.pop()\n                    area = post_rect[1] * (j - post_rect[0])\n                    max_area = max(max_area, area)\n                S.append([post_rect[0], rect[1]])\n\n    print(max_area)\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "#!python3\n\nfrom collections import deque\n\niim = lambda: map(int, input().rstrip().split())\n\ndef calc(dp):\n    ans = 0\n    dq = deque([[0, 0]])\n    #print(dp)\n    for i, hi in enumerate(dp):\n        j = i\n        while dq[-1][1] > hi:\n            j, h1 = dq.pop()\n            ans = max(ans, (i - j) * h1)\n\n        if dq[-1][1] < hi:\n            dq.append([j, hi])\n\n    i = len(dp)\n    for j, hi in dq:\n        ans = max(ans, (i - j) * hi)\n    #print(i, dq, ans)\n    return ans\n\ndef resolve():\n    H, W = iim()\n\n    dp = [0] * W\n    dp0 = dp[:]\n    ans = 0\n    for i in range(H):\n        C = list(iim())\n\n        for i, ci in enumerate(C):\n            dp[i] = 0 if ci else dp0[i] + 1\n\n        ans = max(ans, calc(dp))\n        dp, dp0 = dp0, dp\n\n    print(ans)\n\nif __name__ == \"__main__\":\n    resolve()\n\n"
  },
  {
    "language": "Python",
    "code": "h, w = map(int, input().split( ))\n\nc=[[0 for _ in range(w)]]\nDP = [[0 for _ in range(w+1)] for __ in range(h+1)]\nfor _ in range(h):\n    c_tmp = list(map(int, input().split( )))\n    c.append(c_tmp)\n\n\nfor i in range(w):\n    for j in range(1,h+1):\n        if c[j][i] == 1:\n            DP[j][i] = 0\n        else:\n            DP[j][i] = DP[j-1][i]+1\n\n#for i in range(1,h+1):\n#    print(*DP[i])\nS = []\nans = []\nTst =  [[0 for _ in range(w)] for __ in range(h+1)]\nfor j in range(1,h+1):\n    #S = []\n    for i in range(w+1):\n        if len(S) > 0:\n            if S[-1][0] <= DP[j][i]:\n                S.append([DP[j][i],1])\n            \n            else:#if S[-1] > DP[j][i]:\n                tmp = 0\n                while len(S) > 0 and S[-1][0] > DP[j][i]:\n                    pp = S.pop()\n                    tmp += pp[1]\n                    ans.append(pp[0]*tmp)\n                    Tst[j][i-1] = pp[0]*tmp\n                S.append([DP[j][i],tmp+1])\n                \n        else:\n            S.append([DP[j][i],1])\n#print()\n#for i in range(1,h+1):\n#    print(*Tst[i])\n#print()\ntry:\n    print(max(ans))\nexcept:\n    print(0)\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\n\nh, w = map(int, readline().split())\nw += 1\ndp = [list(map(int, readline().split())) + [1] for _ in range(h)]\n\nfor i in range(h):\n    for j in range(w):\n        dp[i][j] ^= 1\n    \nfor i in range(1, h):\n    for j in range(w):\n        if dp[i][j]:\n            dp[i][j] += dp[i - 1][j]\n\nmax_s = 0\nfor i in range(h):\n    stack = []\n    for j in range(w):\n        if (stack[-1][0] if stack else 0) < dp[i][j]:\n            stack.append((dp[i][j], j))\n        elif stack and stack[-1][0] > dp[i][j]:\n            while stack and stack[-1][0] > dp[i][j]:\n                height, l = stack.pop()\n                s = height * (j - l)\n                if max_s < s:\n                    max_s = s\n            if dp[i][j]:\n                stack.append((dp[i][j], l))\nprint(max_s)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n4 5\n0 0 1 0 0\n1 0 0 0 0\n0 0 0 1 0\n0 0 0 1 0\n\noutput:\n6\n\"\"\"\n\nimport sys\n\n\nclass Rectangle(object):\n    __slots__ = ('pos', 'height')\n\n    def __init__(self, pos=float('inf'), height=-1):\n        \"\"\"\n        init a Rectangle\n        \"\"\"\n        self.pos = pos\n        self.height = height\n\n\ndef gen_rec_info(_carpet_info):\n    dp = [[1] * (W + 1) for _ in range(H + 1)]\n\n    for i in range(H):\n        for j in range(W):\n            # stained\n            if int(_carpet_info[i][j]):\n                dp[i + 1][j + 1] = 0\n            else:\n                dp[i + 1][j + 1] = dp[i][j + 1] + 1\n\n    return dp\n\n\ndef get_largest_area(_hi_info):\n    hi_max_area = 0\n    rec_stack = []\n    _hi_info[-1] = 0\n\n    for i, v in enumerate(_hi_info):\n        rect = Rectangle(pos=i, height=int(v))\n        if not rec_stack:\n            rec_stack.append(rect)\n        else:\n            last_height = rec_stack[-1].height\n            if last_height < rect.height:\n                rec_stack.append(rect)\n            elif last_height > rect.height:\n                target = i\n                while rec_stack and rec_stack[-1].height >= rect.height:\n                    pre = rec_stack.pop()\n                    area = pre.height * (i - pre.pos)\n                    hi_max_area = max(hi_max_area, area)\n                    target = pre.pos\n                rect.pos = target\n                rec_stack.append(rect)\n\n    return hi_max_area\n\n\ndef solve(_rec_info):\n    overall_max_area = 0\n    for hi_info in _rec_info:\n        overall_max_area = max(overall_max_area, get_largest_area(hi_info))\n\n    return overall_max_area\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    H, W = map(int, _input[0].split())\n    carpet_info = list(map(lambda x: x.split(), _input[1:]))\n\n    rec_info = gen_rec_info(carpet_info)\n    # print(rec_info)\n    ans = solve(rec_info)\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\n\nh, w = map(int, readline().split())\nw += 1\ndp = [list(map(int, readline().split())) + [1] for _ in range(h)]\n\nfor i in range(h):\n    for j in range(w):\n        dp[i][j] ^= 1\n    \nfor i in range(1, h):\n    for j in range(w):\n        if dp[i][j]:\n            dp[i][j] += dp[i - 1][j]\n\nmax_s = 0\nfor i in range(h):\n    stack = []\n    for j in range(w):\n        if (stack[-1][0] if stack else 0) < dp[i][j]:\n            stack.append((dp[i][j], j))\n        elif stack and stack[-1][0] > dp[i][j]:\n            while stack and stack[-1][0] > dp[i][j]:\n                height, l = stack.pop()\n                s = height * (j - l)\n                if max_s < s:\n                    max_s = s\n            if dp[i][j]:\n                stack.append((dp[i][j], l))\nprint(max_s)\n\n"
  },
  {
    "language": "Python",
    "code": "def new_max_rectangle(array):\n    max_area = 0\n\n    for i in range(1, max(array) + 1):\n        mini_height = 99999\n        count = 0\n        for j in range(i, max(array) + 1):\n            if array[j] == 0:\n                if j == i:\n                    mini_height = array[j]\n                break\n            else:\n                mini_height = mini_height if array[j] > mini_height else array[j]\n                count += 1\n\n        max_area = count * mini_height if count * mini_height > max_area else max_area\n\n    return max_area\n\n\ndef algorithm():\n    r, c = map(int, input().split(' '))\n\n    ans_array = [0 for _ in range(c)]\n    input_matrix = []\n\n    for _ in range(r):\n        input_matrix.append(list(map(int, input().split(' '))))\n\n    largest_square = 0\n\n    for i in range(r):\n        for j in range(c):\n            ans_array[j] = ans_array[j] + 1 if input_matrix[i][j] == 0 else 0\n        m = new_max_rectangle(ans_array)\n        largest_square = largest_square if largest_square > m else m\n\n    print(largest_square)\n\n\ndef main():\n    algorithm()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "import sys\nfile = sys.stdin\nH,W = map(int, file.readline().split())\nC = [list(map(int,i.split())) for i in file.readlines()]\n\ndef height(C):\n    P = []\n    for i in range(W):\n        p = 0\n        for j in range(len(C)):\n            if C[j][i] == 1:\n                p = 0\n            else: p += 1\n        P.append(p)\n    return P\n\ndef square(C):\n    P = height(C)\n    G = []\n    L = []\n    for i,v in enumerate(P):\n        if not L:\n            L.append((i, v))\n            continue\n        if v > L[-1][1]:\n            L.append((i, v))\n        elif v < L[-1][1]:\n            k = i - 1\n            while L and v < L[-1][1]:\n                a = L.pop()\n                G.append((k - a[0] + 1) * a[1])\n            L.append((i, v))\n    while L:\n        a = L.pop()\n        G.append((len(P) - a[0]) * a[1])\n    return max(G)\n\ndef ans(C):\n    ans = []\n    for i in range(H):\n        currentC = C[:i+1]\n        ans.append(square(currentC))\n    return str(max(ans))\nprint(ans(C))"
  },
  {
    "language": "Python",
    "code": "# DPL_3_B: Largest Rectangle\nimport sys\nH, W = map(int, sys.stdin.readline().strip().split())\n\nC = []\nfor h in range(H):\n    c = list(map(int, sys.stdin.readline().strip().split()))\n    C.append(c)\n\n# 列方向のdp\ndp = [[0] * (W + 1) for _ in range(H)]\nfor h in range(H):\n    for w in range(W + 1):  # 長方形の面積探査時に一番右端が0だと都合がいい\n        if w == W:\n            dp[h][w] = 0\n            continue\n        if C[h][w] == 1:\n           dp[h][w] = 0\n        elif h == 0:  # 0行目は上の行が存在しないので別処理\n           dp[0][w] = 1\n        else:\n           dp[h][w] = dp[h-1][w] + 1\n\n# 長方形を求める\nans = 0\nfor h in range(H):\n    stack = [(0, 0)]  # [(left, height)]\n    for w in range(W + 1):\n        if dp[h][w] >= stack[-1][1]:  # まだ長方形が決定されないとき\n            stack.append((w, dp[h][w]))\n        else:  # 高さが足りずに長方形が決定されるとき\n            while stack[-1][1] > dp[h][w]:  # stack[0] = (0, 0) なので、 stack[0]は絶対に取り出されない\n                left_pos, height = stack.pop()\n                area = height * (w - left_pos)  # 長方形の面積\n                ans = max(ans, area)\n            stack.append((left_pos, dp[h][w]))\n\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "def calc_largest_rect_in_hist(heights):\n    heights.append(0)\n    stack = []\n    left = [0] * len(heights)\n    ans = 0\n    for i, height in enumerate(heights):\n        while stack and heights[stack[-1]] >= height:\n            idx = stack.pop()\n            ans = max(ans, (i - left[idx] - 1) * heights[idx])\n        left[i] = stack[-1] if stack else -1\n        stack.append(i)\n    heights.pop()\n    return ans\n\n\ndef aoj_hist():\n    # https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/all/DPL_3_C\n    input()\n    print(calc_largest_rect_in_hist([int(x) for x in input().split()]))\n\n\ndef aoj_rect():\n    # https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/all/DPL_3_B\n    H, W = map(int, input().split())\n    board = [[int(x) for x in input().split()] for _ in range(H)]\n    dp = [0] * W\n    ret = 0\n    for r in range(H):\n        for c in range(W):\n            dp[c] = dp[c] + 1 if board[r][c] == 0 else 0\n        ret = max(ret, calc_largest_rect_in_hist(dp))\n    print(ret)\n\n\nif __name__ == \"__main__\":\n    # aoj_hist()\n    aoj_rect()\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nPattern - Largest Rectangle\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_3_B&lang=jp\n\n\"\"\"\nimport sys\n\n\ndef solve(H, W, grid):\n    def calc_hist(m):\n        ans = [[0] * W for _ in range(H)]\n        for y, row in enumerate(m):\n            for x, ch in enumerate(row):\n                if ch == '0':\n                    ans[y][x] = ans[y - 1][x] + 1 if y > 0 else 1\n        return ans\n\n    def calc_area(hist):\n        stack = []\n        area, left = 0, 0\n        for x, h in enumerate(hist):\n            if not stack or stack[-1][0] < h:\n                stack.append((h, x))\n            elif stack[-1][0] > h:\n                while stack and stack[-1][0] >= h:\n                    hh, left = stack.pop()\n                    area = max(area, hh*(x-left))\n                stack.append((h, left))\n        return area\n\n    hist = calc_hist(grid)\n    ans = 0\n    for y in range(H):\n        ans = max(ans, calc_area(hist[y]+[0]))\n    return ans\n\n\ndef main(args):\n    H, W = map(int, input().split())\n    grid = [input().replace(' ', '') for _ in range(H)]\n    ans = solve(H, W, grid)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n# import re\nimport math\nimport collections\n# import decimal\nimport bisect\nimport itertools\nimport fractions\n# import functools\nimport copy\n# import heapq\nimport decimal\n# import statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10000001)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: map(int, sys.stdin.readline().split())\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n# ===CODE===\n\ndef largestRectangInHistgram(heights):\n    stack = [-1]\n    maxArea = 0\n\n    for i in range(len(heights)):\n        # we are saving indexes in stack that is why we comparing last element in stack\n        # with current height to check if last element in stack not bigger then\n        # current element\n        while stack[-1] != -1 and heights[stack[-1]] > heights[i]:\n            lastElementIndex = stack.pop()\n            maxArea = max(maxArea, heights[lastElementIndex] * (i - stack[-1] - 1))\n        stack.append(i)\n\n    # we went through all elements of heights array\n    # let's check if we have something left in stack\n    while stack[-1] != -1:\n        lastElementIndex = stack.pop()\n        maxArea = max(maxArea, heights[lastElementIndex] * (len(heights) - stack[-1] - 1))\n\n    return maxArea\n\n\ndef main():\n    h, w = ns()\n    mat = [na() for _ in range(h)]\n\n    current = [0 for _ in range(w + 1)]\n\n    ans = 0\n    for i in range(h):\n        for j in range(w):\n            current[j] = current[j] + (mat[i][j] ^ 1) if mat[i][j]==0 else 0\n        # current = [0] + current + [0]\n        ans = max(ans, largestRectangInHistgram(current))\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\n"
  },
  {
    "language": "Python",
    "code": "def new_max_rectangle(array):\n    max_area = 0\n\n    for i in range(len(array)):\n        min_height = array[i]\n        width = 1\n        for j in range(i, len(array)):\n            if array[j] == 0:\n                width = 1\n                if j <= i:\n                    min_height = array[j + 1]\n                continue\n            min_height = array[j] if min_height > array[j] else min_height\n            max_area = width * min_height if width * min_height > max_area else max_area\n            width += 1\n\n    return max_area\n\n\ndef algorithm():\n    r, c = map(int, input().split(' '))\n\n    ans_array = [0 for _ in range(c)]\n    input_matrix = []\n\n    for _ in range(r):\n        input_matrix.append(list(map(int, input().split(' '))))\n\n    largest_square = 0\n\n    for i in range(r):\n        for j in range(c):\n            ans_array[j] = ans_array[j] + 1 if input_matrix[i][j] == 0 else 0\n        m = new_max_rectangle(ans_array)\n        largest_square = largest_square if largest_square > m else m\n\n    print(largest_square)\n\n\ndef main():\n    algorithm()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "h,w = map(int,input().split())\nc = [list(map(int,input().split())) for _ in range(h)]\n\nT = [[0]*(w+1) for _ in range(h)]\n\nfor j in range(w):\n    for i in range(h):\n        if c[i][j] == 1:\n            continue\n        else:\n            T[i][j] = T[i-1][j]+1 if i>0 else 1\n            \nmaxv = 0\nfor i in range(h):\n    S = []\n    \n    for j in range(w+1):\n        rect = [T[i][j],j]\n        if S:\n            if S[-1][0]<rect[0]:\n                S.append(rect)\n            elif S[-1][0]>rect[0]:\n                target = j\n                while(S and S[-1][0]>=rect[0]):\n                    pre = S.pop()\n                    area = pre[0]*(j-pre[1])\n                    maxv = max(maxv,area)\n                    target = pre[1]\n                rect[1] = target\n                S.append(rect)\n        else:\n            S.append(rect)\n            \nprint(maxv)\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nfrom itertools import product\n\ndef rectangle_in_histgram(H):\n\n    def calc(i, h):\n        tmp_max = 0\n        while stack[-1][1] > h:\n            pi, ph = stack.pop()\n            tmp_max = max(tmp_max, (i-pi)*ph)\n            if len(stack) == 0:\n                break\n\n        if len(stack) == 0:\n            stack.append([pi, h])\n        elif stack[-1][1] < h:\n            stack.append([pi, h])\n        return tmp_max\n    \n    stack = [] # loc, height\n    S_max = 0\n    \n    for i, h in enumerate(H):\n        if len(stack) == 0:\n            stack.append([i, h])\n        elif h > stack[-1][1]:\n            stack.append([i, h])\n        elif h == stack[-1][1]:\n            pass\n        else:\n            tmp_max = calc(i, h)\n            S_max = max(S_max, tmp_max)\n\n    tmp_max = calc(i+1, 0)\n    S_max = max(S_max, tmp_max)\n    return S_max\n\n\nH, W = tuple(map(int, input().split()))\nC = [tuple(map(int, input().split())) for _ in range(H)]\nA = [[1]*W for _ in range(H)]\nfor h, w in product(range(H), range(W)):\n    if C[h][w] == 1:\n        A[h][w] = 0\n\nfor h, w in product(range(1, H), range(W)):\n    if C[h][w] == 0:\n        A[h][w] = A[h-1][w] + 1\n\nresult = 0\nfor a in A:\n    result = max(result, rectangle_in_histgram(a))\n\nprint(result)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n4 5\n0 0 1 0 0\n1 0 0 0 0\n0 0 0 1 0\n0 0 0 1 0\n\noutput:\n6\n\"\"\"\n\nimport sys\n\n\nclass Rectangle(object):\n    __slots__ = ('pos', 'height')\n\n    def __init__(self, pos=float('inf'), height=-1):\n        \"\"\"\n        init a Rectangle\n        \"\"\"\n        self.pos = pos\n        self.height = height\n\n\ndef gen_rec_info(_carpet_info):\n    dp = [[float('inf')] * W for _ in range(H)]\n\n    for i in range(H):\n        for j in range(W):\n            if int(_carpet_info[i][j]):\n                dp[i][j] = 0\n            else:\n                dp[i][j] = dp[i - 1][j] + 1 if i else 1\n\n    return dp\n\n\ndef get_largest_area(_hi_info):\n    hi_max_area = 0\n    rec_stack = []\n    _hi_info.append(0)\n\n    for i, v in enumerate(_hi_info):\n        rect = Rectangle(pos=i, height=int(v))\n        if not rec_stack:\n            rec_stack.append(rect)\n        else:\n            last_height = rec_stack[-1].height\n            if last_height < rect.height:\n                rec_stack.append(rect)\n            elif last_height > rect.height:\n                target = i\n                while rec_stack and rec_stack[-1].height >= rect.height:\n                    pre = rec_stack.pop()\n                    area = pre.height * (i - pre.pos)\n                    hi_max_area = max(hi_max_area, area)\n                    target = pre.pos\n                rect.pos = target\n                rec_stack.append(rect)\n\n    return hi_max_area\n\n\ndef solve(_rec_info):\n    overall_max_area = 0\n    for hi_info in _rec_info:\n        overall_max_area = max(overall_max_area, get_largest_area(hi_info))\n\n    return overall_max_area\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    H, W = map(int, _input[0].split())\n    carpet_info = list(map(lambda x: x.split(), _input[1:]))\n\n    rec_info = gen_rec_info(carpet_info)\n    # print(rec_info)\n    ans = solve(rec_info)\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "# スタックの実装。\nclass Stack():\n    def __init__(self):\n        self.stack = []\n    # データを追加する。\n    def push(self, item):\n        self.stack.append(item)\n    # データを取り出す。\n    def pop(self):\n        return self.stack.pop()\n    # スタックの中身を確認する。\n    def get_stack(self):\n        return self.stack\n    # スタックが空ならばTrueを返す。\n    def isEmpty(self):\n        return len(self.stack) == 0\n    # スタックに格納されているものの数を返す。\n    def count(self):\n        return len(self.stack)\n    #　スタックのトップを見る（取り出さずに）。\n    def top(self):\n        return self.stack[-1]\n\n# ヒストグラムの最大長方形を求める関数。\ndef Histogram(n,l):\n    if n == 0:\n        return 0\n    stack = Stack()\n    t = 0\n    ans = 0\n    while t < n:\n        r = l[t]\n        if stack.isEmpty():\n            stack.push((r,t))\n            t += 1\n            # print(stack.get_stack(),t)\n        elif stack.top()[0] < r:\n            stack.push((r,t))\n            t += 1\n            # print(stack.get_stack(),t)\n        elif stack.top()[0] == r:\n            t += 1\n            # print(stack.get_stack(),t)\n        elif stack.top()[0] > r:\n            while stack.top()[0] > r:\n                p,q = stack.pop()\n                ans = max(ans,p*(t-q))\n                # print(stack.get_stack(),t)\n                if stack.isEmpty():\n                    break;\n            stack.push((r,q))\n            t += 1\n    while not stack.isEmpty():\n        p,q = stack.pop()\n        ans = max(ans, p*(t-q))\n        # print(stack.get_stack(),t)\n    return ans\n\n\nH,W  = [int(_) for _ in input().split()]\ndp = [[0]*W for _ in range(H)]\nfor i in range(H):\n    for j,value in enumerate([int(_) for _ in input().split()]):\n        dp[i][j] = value\nc = 1\nfor j in range(W):\n    i = 0\n    while i < H:\n        if dp[i][j] == 0:\n            dp[i][j] = c\n            c += 1\n        else:\n            dp[i][j] = 0\n            c = 1\n        i += 1\n    c = 1\n\n# for i in range(H):\n#     print(dp[i])\n\nans = 0\nl = []\nfor i in range(H):\n    for j in range(W):\n        if dp[i][j] == 0:\n            ans = max(ans,Histogram(len(l),l))\n            # print(len(l),l)\n            l = []\n        else:\n            l.append(dp[i][j])\n    ans = max(ans,Histogram(len(l),l))\n    # print(len(l),l)\n    l = []\nprint(ans)\n\n\n# print('TEST')\n# print(Histogram(5, [3,5,4,5,5]))\n"
  },
  {
    "language": "Python",
    "code": "\n\n\nclass Rectangle:\n    def __init__(self, height, position):\n        self.height = height\n        self.position = position\n\ndef getLargestRectangleRow(size, bufTmp):\n    S = []\n    maxv = 0\n    #bufTmp[0] * size\n    bufTmp.append(0)\n    for i in range(size + 1):\n        rect = Rectangle(bufTmp[i], i)\n        \n        if len(S) == 0:\n            S.append(rect)\n        else:\n            if S[-1].height < rect.height:\n                S.append(rect)\n            elif S[-1].height > rect.height:\n                target = i\n                while len(S) >= 1 and S[-1].height >= rect.height:\n                    pre = S.pop()\n                    area = pre.height * (i-pre.position)\n                    maxv = max(maxv, area)\n                    target = pre.position\n                rect.position = target\n                S.append(rect)\n    return maxv\n\n\ndef getLargestRectangle():\n    for j in range(W):\n        for i in range(H):\n            if buf[i][j]:\n                T[i][j] = 0\n            else:\n                if i > 0:\n                    T[i][j] = T[i-1][j] + 1\n                else:\n                    T[i][j] = 1\n    maxv = 0\n    for i in range(H):\n        maxv = max(maxv, getLargestRectangleRow(W, T[i]))\n\n    return maxv\n\n\nnums=list(map(int,input().split()))\nH = nums[0]\nW = nums[1]\nbuf = [[0 for i in range(W)] for j in range(H)]\nT = [[0 for i in range(W)] for j in range(H)]\nfor i in range(H):\n    nums=list(map(int,input().split()))\n    for j in range(W):\n        buf[i][j] = nums[j]\n\nprint(getLargestRectangle())\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "from pprint import PrettyPrinter\n\npp = PrettyPrinter()\n\n\ndef read_tiles(h, w):\n    c = []\n    for _ in range(h):\n        c.append([int(x) for x in input().split()])\n    return c\n\n\ndef make_histogram(h, w, c):\n    hg = [[None] * w for _ in range(h)]\n    for j in range(w):\n        hg[0][j] = 1 if c[0][j] == 0 else 0\n    for i in range(1, h):\n        for j in range(w):\n            hg[i][j] = hg[i - 1][j] + 1 if c[i][j] == 0 else 0\n    return hg\n\n\ndef largest_rectangle(h, w, c):\n    lr = 0\n    hg = make_histogram(h, w, c)\n    # pp.pprint(hg)\n    s = []\n    for i in range(h):\n        hg[i] += [0]\n        for j in range(w + 1):\n            if len(s) == 0:\n                if hg[i][j] > 0:\n                    s.append((hg[i][j], j))\n            else:\n                top = s[-1]\n                if top[0] < hg[i][j]:\n                    s.append((hg[i][j], j))\n                elif hg[i][j] == top[0]:\n                    pass\n                else:\n                    while len(s) > 0 and s[-1][0] >= hg[i][j]:\n                        top = s.pop()\n                        lr = max(lr, top[0] * (j - top[1]))\n                    s.append((hg[i][j], top[1]))\n            # print(j, lr, s)\n    return lr\n\n\ndef main():\n    h, w = map(int, input().split())\n    c = read_tiles(h, w)\n    print(largest_rectangle(h, w, c))\n\n\nmain()\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nfrom itertools import chain\n\nif __name__ == '__main__':\n\n    H, W = map(int, input().split())\n    C = []\n    hist = []\n    for i in range(H):\n        l = input().split()\n        C.append([int(x) for x in l])\n        hist.append([(int(x) + 1) % 2 for x in l])\n\n    for i in range(1, H):\n        for j in range(W):\n            if C[i][j] == 0:\n                hist[i][j] = hist[i - 1][j] + 1\n    \n    S = []\n    max_area = 0\n    for i in range(H):\n        for j in range(W):\n            rect = [j, hist[i][j]]\n            if not S:\n                S.append(rect)\n            elif S[-1][1] < rect[1]:\n                S.append(rect)\n            elif S[-1][1] > rect[1]:\n                while S and S[-1][1] > rect[1]:\n                    post_rect = S.pop()\n                    area = post_rect[1] * (j - post_rect[0])\n                    max_area = max(max_area, area)\n                S.append([post_rect[0], rect[1]])\n        while S:\n            post_rect = S.pop()\n            area = post_rect[1] * (W - post_rect[0])\n            max_area = max(max_area, area)\n\n    print(max_area)\n\n\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "\n\ndef rectangle(n, hs):\n    stack = []  # (height, pos) 高さと位置が格納される\n    ans = 0\n    for i, h in enumerate(hs):\n        j = i\n        while stack and stack[-1][0] > h:\n            pre_h, j = stack.pop()\n            ans = max(ans, (i - j) * pre_h)\n\n        if not stack or stack[-1][0] < h:\n            stack.append((h, j))\n\n    ans = max(ans, max((n - j) * h2 for h2, j in stack))\n\n    return ans\n\n\nH, W = map(int, input().split())\nhist = [0] * W\nresult = 0\nfor _ in range(H):\n    ht = list(map(int, input().split()))\n    hist = list(map(lambda pre, cur: (pre + 1) * (cur ^ 1), hist, ht))\n    result = max(result, rectangle(W, hist))\n\nprint(result)\n"
  },
  {
    "language": "Python",
    "code": "\n\"\"\"\nWriter: SPD_9X2\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_3_B&lang=ja\n\n各セルに対して、上にいくつ0が連続しているか数えれば、\nヒストグラム上での最大長方形問題になる\n\"\"\"\n\n\ndef Largest_rectangle_in_histgram(lis):\n\n    stk = []\n\n    ans = 0\n    N = len(lis)\n\n    for i in range(N):\n\n        if len(stk) == 0:\n            stk.append((lis[i],i))\n\n        elif stk[-1][0] < lis[i]:\n            stk.append((lis[i],i))\n\n        elif stk[-1][0] == lis[i]:\n            pass\n\n        else:\n            lastpos = None\n            while len(stk) > 0 and stk[-1][0] > lis[i]:\n\n                nh,np = stk[-1]\n                lastpos = np\n                del stk[-1]\n\n                ans = max(ans , nh*(i-np))\n\n            stk.append((lis[i] , lastpos))\n\n    return ans\n\nH,W = map(int,input().split())\n\nc = []\nfor i in range(H):\n    C = list(map(int,input().split()))\n    c.append(C)\n\nzlis = [ [0] * (W+1) for i in range(H) ]\nfor i in range(H):\n    for j in range(W):\n\n        if c[i][j] == 1:\n            continue\n        elif i == 0:\n            zlis[i][j] = 1\n        else:\n            zlis[i][j] = zlis[i-1][j] + 1\n\n#print (zlis)\nans = 0\nfor i in range(H):\n    ans = max(ans , Largest_rectangle_in_histgram(zlis[i]))\n\nprint (ans)\n\n"
  },
  {
    "language": "Python",
    "code": "h,w=map(int,input().split())\nC=[list(map(int,input().split())) for i in range(h)]\n\ndef Largest_Rectangle(grid,h,w):\n    re=0\n    hist=[[0]*(w+1) for i in range(h)]\n    for j in range(w):\n        if C[0][j]==0:\n            hist[0][j]=1\n    for j in range(w):\n        for i in range(1,h):\n            if C[i][j]==1:continue\n            hist[i][j]=hist[i-1][j]+1\n    for i in range(h):\n        re=max(re,stack_processing_of_rectangle(hist[i]))\n    return re\n\ndef stack_processing_of_rectangle(hist):\n    # スタック処理\n    maxrect=0\n    stack=[]\n    for j in range(w+1):\n        if not stack:\n            stack.append((hist[j],j))\n        elif stack[-1][0]<hist[j]:\n            stack.append((hist[j],j))\n        elif stack[-1][0]>hist[j]:\n            while stack and stack[-1][0]>hist[j]:\n                hi,wi=stack.pop()\n                maxrect=max(maxrect,hi*(j-wi))\n            stack.append((hist[j],wi))\n    return maxrect\n\nprint(Largest_Rectangle(C,h,w))\n# hist=[[0]*(w+1) for i in range(h)]\n# for j in range(w):\n#     if C[0][j]==0:\n#         hist[0][j]=1\n# for j in range(w):\n#     for i in range(1,h):\n#         if C[i][j]==1:continue\n#         hist[i][j]=hist[i-1][j]+1\n\n# # スタック処理\n# maxrect=0\n# stack=[]\n# for i in range(h):\n#     for j in range(w+1):\n#         if not stack:\n#             stack.append((hist[i][j],j))\n#         elif stack[-1][0]<hist[i][j]:\n#             stack.append((hist[i][j],j))\n#         elif  stack[-1][0]==hist[i][j]:\n#             pass\n#         elif stack[-1][0]>hist[i][j]:\n#             while stack and stack[-1][0]>hist[i][j]:\n#                 hi,wi=stack.pop()\n#                 maxrect=max(maxrect,hi*(j-wi))\n#             stack.append((hist[i][j],wi))\n# print(maxrect)\n            \n\n        \n        \n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import deque\ndef judge(n,hs):\n    stack = deque()\n    ans = 0\n    for i, h in enumerate(hs):\n        j = -1\n        while stack and stack[-1][1] > h:\n            j, h2 = stack.pop()\n            ans = max(ans, (i - j) * h2)\n        if not stack or stack[-1][1] < h:\n            stack.append((i if j == -1 else j, h))\n    ans = max(ans, max((n - j) * h2 for j, h2 in stack))\n    return ans\nH,W = map(int,stdin.readline().split())\nhs = [0]*W\nresult = 0\nfor i in range(H):\n    ht = list(map(int, stdin.readline().split()))\n    hs = list(map(lambda x,y:(x+1)*abs(y-1),hs,ht))\n    result = max(result,judge(W,hs))\nprint(result)"
  },
  {
    "language": "Python",
    "code": "H, W = map(int, input().split())\nheight = W * [0]\nmax_area = 0\nfor _ in range(H):\n    height = [0 if t else height[j]+1 for j, t in enumerate(map(int, input().split()))]\n    height.append(0)\n    stack = []\n    for i, h in enumerate(height):\n        if stack:\n            if stack[-1][1] == h:\n                continue\n            elif stack[-1][1] > h:\n                while stack and (stack[-1][1] >= h):\n                    i_stack, h_stack = stack.pop()\n                    max_area = max(max_area, (i - i_stack) * (h_stack))\n                i = i_stack\n                \n            \n        stack.append((i, h))\n        \nprint(max_area)\n"
  },
  {
    "language": "Python",
    "code": "h, w = map(int, input().split())\nmax_rect, prev = 0, [0] * (w + 1)\nfor i in range(h):\n    current = [p + 1 if f else 0 for f, p in zip(map(lambda x: int(x) ^ 1, input().split()), prev)] + [0]\n    stack = [(0, 0)]\n    for j in range(w + 1):\n        c_j = current[j]\n        if stack[-1][0] < c_j:\n            stack.append((c_j, j))\n            continue\n        if stack[-1][0] > c_j:\n            since = 0\n            while stack[-1][0] > c_j:\n                height, since = stack.pop()\n                max_rect = max(max_rect, height * (j - since))\n            if c_j:\n                stack.append((c_j, since))\n    prev = current\nprint(max_rect)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nfrom collections import deque\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x // y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\nH,W=MAP()\ngrid=[None]*H\nfor i in range(H):\n    grid[i]=LIST()\n\n# その行を底辺として、高さをどこまで伸ばせるか記録しておく\nacc=list2d(H, W, 0)\nfor j in range(W):\n    if grid[0][j]!=1:\n        acc[0][j]=1\nfor j in range(W):\n    for i in range(1, H):\n        if grid[i][j]!=1:\n            acc[i][j]=acc[i-1][j]+1\n# 最後にスタックに残ってる分を確認するために番兵的に足す\nfor i in range(H):\n    acc[i].append(0)\n\nmx=0\n# 各行を高さのヒストグラムとみなす\nfor i, hist in enumerate(acc):\n    stack=deque()\n    for j, h in enumerate(hist):\n        if not len(stack):\n            stack.append((j, h))\n        else:\n            if stack[-1][1]<h:\n                stack.append((j, h))\n            elif stack[-1][1]>h:\n                # 次のhがスタックより低かったら、そこより手前の最大を確定する\n                while len(stack) and stack[-1][1]>h:\n                    prev=stack.pop()\n                    w2=j-prev[0]\n                    h2=prev[1]\n                    mx=max(mx, h2*w2)\n                stack.append((prev[0], h))\nprint(mx)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfile = sys.stdin\nH,W = map(int, file.readline().split())\nC = [list(map(int,i.split())) for i in file.readlines()]\n\ndef height(C):\n    P = []\n    for i in range(W):\n        p = 0\n        for j in range(len(C)):\n            if C[j][i] == 1:\n                p = 0\n            else: p += 1\n        P.append(p)\n    return P\n\ndef square(C):\n    P = height(C)\n    G = []\n    L = []\n    for i,v in enumerate(P):\n        if not L:\n            L.append((i, v))\n            continue\n        if v > L[-1][1]:\n            L.append((i, v))\n        elif v < L[-1][1]:\n            k = i - 1\n            while L and v < L[-1][1]:\n                a = L.pop()\n                G.append((k - a[0] + 1) * a[1])\n            L.append((a[0], v))\n    while L:\n        a = L.pop()\n        G.append((len(P) - a[0]) * a[1])\n    return max(G)\n\ndef ans(C):\n    ans = []\n    for i in range(H):\n        currentC = C[:i+1]\n        ans.append(square(currentC))\n    return str(max(ans))\nprint(ans(C))"
  },
  {
    "language": "Python",
    "code": "def max_rectangle(array):\n    max_area = 0\n\n    for i in range(1, max(array) + 1):\n        current_area = 0\n        for j in range(len(array)):\n            if array[j] >= i:\n                current_area += i\n                if current_area > max_area:\n                    max_area = current_area\n            else:\n                current_area = 0\n\n    return max_area\n\n\ndef algorithm():\n    r, c = map(int, input().split(' '))\n\n    ans_array = [0 for _ in range(c)]\n    input_matrix = []\n\n    for _ in range(r):\n        input_matrix.append(list(map(int, input().split(' '))))\n\n    largest_square = 0\n\n    for i in range(r):\n        for j in range(c):\n            ans_array[j] = ans_array[j] + 1 if input_matrix[i][j] == 0 else 0\n        m = max_rectangle(ans_array)\n        largest_square = largest_square if largest_square > m else m\n\n    print(largest_square)\n\n\ndef main():\n    algorithm()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "h, w = map(int, input().split())\nmax_rect, prev = 0, [0] * (w + 1)\nfor i in range(h):\n    current = [p + 1 if f else 0 for f, p in zip(map(lambda x: int(x) ^ 1, input().split()), prev)] + [0]\n    stack = [(0, 0)]\n    for j in range(w + 1):\n        c_j = current[j]\n        if stack[-1][0] < c_j:\n            stack.append((c_j, j))\n            continue\n        if stack[-1][0] > c_j:\n            while stack[-1][0] > c_j:\n                height, since = stack.pop()\n                max_rect = max(max_rect, height * (j - since))\n            if c_j:\n                stack.append((c_j, j))\n    prev = current\n\nprint(max_rect)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n4 5\n0 0 1 0 0\n1 0 0 0 0\n0 0 0 1 0\n0 0 0 1 0\n\noutput:\n6\n\"\"\"\n\nimport sys\n\n\n# from collections import namedtuple\n\n\nclass Rectangle(object):\n    __slots__ = ('pos', 'height')\n\n    def __init__(self, pos=float('inf'), height=-1):\n        \"\"\"\n        init a Rectangle\n        \"\"\"\n        self.pos = pos\n        self.height = height\n\n\ndef gen_rec_info(_carpet_info):\n    dp = [[float('inf')] * W for _ in range(H)]\n\n    for i in range(H):\n        for j in range(W):\n            if int(_carpet_info[i][j]):\n                dp[i][j] = 0\n            else:\n                dp[i][j] = dp[i - 1][j] + 1 if i > 0 else 1\n\n    return dp\n\n\ndef get_largest_area(_hi_info):\n    hi_max_area = 0\n    rec_stack = []\n    _hi_info.append(0)\n\n    for i, v in enumerate(_hi_info):\n        rect = Rectangle(pos=i, height=int(v))\n        if not rec_stack:\n            rec_stack.append(rect)\n        else:\n            last_height = rec_stack[-1].height\n            if last_height < rect.height:\n                rec_stack.append(rect)\n            elif last_height > rect.height:\n                target = i\n                while rec_stack and rec_stack[-1].height >= rect.height:\n                    pre = rec_stack.pop()\n                    area = pre.height * (i - pre.pos)\n                    hi_max_area = max(hi_max_area, area)\n                    target = pre.pos\n                rect.pos = target\n                rec_stack.append(rect)\n\n    return hi_max_area\n\n\ndef solve(_rec_info):\n    overall_max_area = 0\n    for hi_info in _rec_info:\n        overall_max_area = max(overall_max_area, get_largest_area(hi_info))\n\n    return overall_max_area\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    H, W = map(int, _input[0].split())\n    carpet_info = list(map(lambda x: x.split(), _input[1:]))\n    # Rectangle = namedtuple('Rectangle', ('pos', 'height'))\n\n    rec_info = gen_rec_info(carpet_info)\n    # print(rec_info)\n    ans = solve(rec_info)\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "H, W = map(int, input().split())\nc = []\nfor _ in range(H):\n    *w, = map(int, input().split())\n    c.append(w)\n\n# 上方向に連続するタイルの数を記録する\nt = []\nfor _ in range(H+2):\n    t.append([0]*(W+2))\n\nfor w in range(1, W+1):\n    for h in range(1, H+1):\n        if c[h-1][w-1] == 1:\n            t[h][w] = 0\n        else:\n            t[h][w] = t[h-1][w]+1\n\nans = 0\nfor h in range(1, H+1):\n    s = []\n    for w in range(1, W+2):\n        if len(s) == 0 or s[-1][0] < t[h][w]:\n            s.append([t[h][w], w])\n        elif s[-1][0] > t[h][w]:\n            li = w\n            while len(s) > 0 and s[-1][0] >= t[h][w]:\n                r = s.pop(-1)\n                tmp = (w-r[1])*r[0]\n                if tmp > ans:\n                    ans = tmp\n                li = r[1]\n            s.append([t[h][w], li])\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfile = sys.stdin\nH,W = map(int, file.readline().split())\nC1 = [list(map(int,i.split())) for i in file.readlines()]\nC2 = [i[::-1] for i in C1[::-1]]\n\ndef height(C):\n    P = []\n    for i in range(W):\n        p = 0\n        for j in range(H):\n            if C[j][i] == 1:\n                p = 0\n            else: p += 1\n        P.append(p)\n    return P\n\ndef square(C):\n    P = height(C)\n    G = []\n    L = []\n    for i,v in enumerate(P):\n        if not L:\n            L.append((i, v))\n            continue\n        if v > L[-1][1]:\n            L.append((i, v))\n        elif v < L[-1][1]:\n            k = L[-1][0]\n            while L and v < L[-1][1]:\n                a = L.pop()\n                G.append((k - a[0] + 1) * a[1])\n            L.append((i, v))\n    while L:\n        a = L.pop()\n        G.append((len(P) - a[0]) * a[1])\n    return max(G)\n\ndef ans(C1, C2):\n    return str(max(square(C1), square(C2)))\n\nprint(ans(C1, C2))"
  },
  {
    "language": "Python",
    "code": "\ndef resolve():\n    def get_largest_rectangle(hist: list):\n        hist = hist.copy()\n        hist.append(0)\n        ret = 0\n        stack = []\n        for i, v in enumerate(hist):\n            if len(stack) == 0:\n                stack.append((i, v))\n            elif stack[-1][1] < v:\n                stack.append((i, v))\n            elif stack[-1][1] > v:\n                while stack and stack[-1][1] > v:\n                    i_left, h = stack.pop()\n                    ret = max(ret, (i - i_left)*h)\n                stack.append((i_left, v))\n        return ret\n\n\n    H, W = map(int, input().split())\n    AB = [list(map(int, input().split())) for _ in range(H)]\n    T = [[0]*W for _ in range(H)]\n\n    for j in range(W):\n        seq = 0\n        for i in range(H):\n            if AB[i][j] == 1:\n                T[i][j] = 0\n                seq = 0\n            else:\n                T[i][j] = seq + 1\n                seq += 1\n    ans = 0\n    for t in T:\n        ans = max(ans, get_largest_rectangle(t))\n    print(ans)\n\nif __name__ == '__main__':\n    resolve()\n"
  },
  {
    "language": "Python",
    "code": "h,w=map(int,input().split())\nC=[list(map(int,input().split())) for _ in range(h)]\nDP=[[0 for _ in range(w)] for _ in range(h)]\n\nfor i in range(w):\n    if C[0][i]==0:DP[0][i]=1\n    else:DP[0][i]=0\n\nfor i in range(1,h):\n    for j in range(w):\n        if C[i][j]==0:DP[i][j]=DP[i-1][j]+1\n        else:DP[i][j]=0\n\ncost=0\nfor i in range(h):\n    stack=[]\n    for j in range(w):\n        if len(stack)==0:\n            stack.append((DP[i][j],j))\n        elif DP[i][j]>stack[-1][0]:\n            stack.append((DP[i][j],j))\n        elif DP[i][j]<stack[-1][0]:\n            add=0\n            while DP[i][j]<stack[-1][0]:\n                rect,pos=stack.pop()\n                cost=max(cost,(j-pos)*rect)\n                add=pos\n                if len(stack)==0:break\n            stack.append((DP[i][j],add))\n\n    if len(stack)!=0:\n        while len(stack)!=0:\n            rect,pos=stack.pop()\n            cost=max(cost,(w-pos)*rect)\n\nprint(cost)\n"
  },
  {
    "language": "Python",
    "code": "# https://onlinejudge.u-aizu.ac.jp/courses/library/7/DPL/all/DPL_3_B\n# この問題は前処理パートと、効率よく長方形の面積を求めるパートに分かれる。\n\nfrom itertools import product, chain\n\n# load data\nH, W = list(map(int, input().split()))\nC = []\nfor i in range(H):\n    C.append(list(map(int, input().split())))\n\n\n# まず、前処理を行う\n# T (H,W) ... そのマスより上に何マスまで濡れるか\nT = []\npre_tmp = [0] * W\nfor c in C:\n    tmp = []\n    for cc, pre in zip(c, pre_tmp):\n        if cc == 1:\n            tmp.append(0)\n        else:\n            tmp.append(pre + 1)\n    T.append(tmp)\n    pre_tmp = tmp.copy()\n\n\ndef get_largest_rectangle(hist: list):\n    '''\n    ヒストグラムが渡されたときに、その中の最大の長方形を返す\n    '''\n    hist = hist.copy()\n    hist.append(0)\n    ret = 0\n    stack = []\n    for i, v in enumerate(hist):\n        # vが本で言うrectのこと\n        if len(stack) == 0:\n            stack.append((i, v))\n        elif stack[-1][1] < v:\n            stack.append((i, v))\n        elif stack[-1][1] > v:\n            while stack and stack[-1][1] > v:\n                # スタックが空でなく、最後の要素がvより大きい限りは、\n                # 面積の最大値を更新していく\n                i_left, h = stack.pop()\n                ret = max(ret, (i - i_left) * h)\n            stack.append((i_left, v))\n    return ret\n\n\n# 各行について走査することで長方形の最大値を求める\nans = 0\nfor t in T:\n    ans = max(ans, get_largest_rectangle(t))\nprint(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "import sys, collections\n\ndef solve():\n    file_input = sys.stdin\n    H, W = map(int, file_input.readline().split())\n    max_area = 0\n    prev = [0] * W\n    rect_stack = collections.deque()\n    for line in file_input:\n        tile_line = map(int, line.split())\n        for i, tpl in enumerate(zip(tile_line, prev)):\n            t, p = tpl\n            if t:\n                h = 0\n                prev[i] = 0\n            else:\n                h = p + 1\n                prev[i] = h\n            if (not rect_stack) or (h > rect_stack[-1][0]):\n                rect_stack.append((h, i))\n            elif h < rect_stack[-1][0]:\n                while rect_stack:\n                    if rect_stack[-1][0] >= h:\n                        rect_h, rect_i = rect_stack.pop()\n                        max_area = max(max_area, rect_h * (i - rect_i))\n                    else:\n                        break\n                rect_stack.append((h, rect_i))\n        while rect_stack:\n            rect_h, rect_i = rect_stack.pop()\n            max_area = max(max_area, rect_h * (W - rect_i))\n    print(max_area)\n\nsolve()"
  },
  {
    "language": "Python",
    "code": "import sys\nfile = sys.stdin\nH,W = map(int, file.readline().split())\nC = [list(map(int,i.split())) for i in file.readlines()]\n\ndef height(C):\n    P = []\n    for i in range(W):\n        p = 0\n        for j in range(len(C)):\n            if C[j][i] == 1:\n                p = 0\n            else: p += 1\n        P.append(p)\n    return P\n\ndef square(C):\n    P = height(C)\n    G = []\n    L = []\n    for i,v in enumerate(P):\n        if not L:\n            L.append((i, v))\n            continue\n        if v > L[-1][1]:\n            L.append((i, v))\n        elif v < L[-1][1]:\n            k = L[-1][0]\n            while L and v < L[-1][1]:\n                a = L.pop()\n                G.append((k - a[0] + 1) * a[1])\n            L.append((i, v))\n    while L:\n        a = L.pop()\n        G.append((len(P) - a[0]) * a[1])\n    return max(G)\n\ndef ans(C):\n    ans = []\n    for i in range(H):\n        currentC = C[:i+1]\n        ans.append(square(currentC))\n    return str(max(ans))\nprint(ans(C))"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n'''\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=DPL_3_A&lang=jp\n???????¨???????\n?????§????????¢\n??£?????¢??????????§£????????????????????????????????°????????§?§£???????????????\n'''\n\nH, W = map(int, input().split())\nC = list()\nmaxArea = 0\n\nfor h in range(H):\n    C.append(list(map(int, input().split())))\n\n#buf = [[-1 for w in range(W)] for h in range(H)]\nT = [[float('inf') for w in range(W)] for h in range(H)]\nfor h in range(H):\n    for w in range(W):\n        if C[h][w] == 1:\n            T[h][w] = 0\n        else:\n            if h==0:\n                T[h][w] = 1\n                continue\n            T[h][w] = T[h-1][w] + 1\n\nclass Rectangle():\n    def __init__(self, height, pos):\n        self.height = height\n        self.pos = pos\n\ndef getLargestRectangle(size, buff):\n    S = list()\n    maxv = 0\n    buff.append(0)\n    for w in range(size+1):\n        rect = Rectangle(buff[w], w)\n        if len(S) ==0:\n            S.append(rect)\n            #print(\"len(S)=0,w=\",w)\n        else:\n            if S[-1].height < rect.height:\n                S.append(rect)\n                #print(\"S[-1].height < rect.height,w=\",w)\n            elif S[-1].height > rect.height:\n                target = w\n                while len(S) > 0 and S[-1].height >= rect.height:\n                    #print(\"S[-1].height > rect.height,w=\",w,\",target=\",target)\n                    pre = S.pop()\n                    area = pre.height * (w - pre.pos)\n                    maxv = max(maxv, area)\n                    target = pre.pos\n                rect.pos = target\n                S.append(rect)\n    return maxv\n\n#print(T)\n\nans = 0\nfor h in range(H):\n    ans = max(ans, getLargestRectangle(W, T[h]))\n\n\nprint(ans)"
  },
  {
    "language": "Python",
    "code": "def judge(n,hs):\n\n    stack = []\n    ans = 0\n\n    for i, h in enumerate(hs):\n        j = -1\n        while stack and stack[-1][1] > h:\n            j, h2 = stack.pop()\n            ans = max(ans, (i - j) * h2)\n        if not stack or stack[-1][1] < h:\n            stack.append((i if j == -1 else j, h))\n    ans = max(ans, max((n - j) * h2 for j, h2 in stack))\n    return ans\n\nH,W = map(int,input().split())\nhs = [0]*W\nresult = 0\nfor i in range(H):\n    f = lambda x,y:(x+1)*abs(y-1)\n\n    ht = list(map(int, input().split()))\n    hs = list(map(f,hs,ht))\n\n    result = max(result,judge(W,hs))\n\nprint(result)"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import deque\nH, W = map(int, stdin.readline().split())\nC = [list(map(int, stdin.readline().split())) for i in range(H)]\nprev = [0] * W\ndef height(C):\n    global prev\n    P = []\n    for i in range(W):\n        if C[-1][i] == 1:\n            p = 0\n        else:\n            p = prev[i] + 1\n        P.append(p)\n    prev = P[:]\n    return P\ndef square(C):\n    P = height(C)\n    G = deque()\n    L = deque()\n    for i, v in enumerate(P):\n        if not L or v > L[-1][1]:\n            L.append((i, v))\n        elif v < L[-1][1]:\n            k = i - 1\n            while L and v < L[-1][1]:\n                a = L.pop()\n                G.append((k - a[0] + 1) * a[1])\n            L.append((a[0], v))\n    len_P = len(P)\n    while L:\n        a = L.pop()\n        G.append((len_P - a[0]) * a[1])\n    return max(G)\nprint(max([square(C[:i + 1]) for i in range(H)]))"
  },
  {
    "language": "Python",
    "code": "h, w = map(int, raw_input().split())\nc = [map(int, raw_input().split()) for i in xrange(h)]\ncnt = [[0]*w for i in xrange(h)]\n\nfor j in xrange(w):\n    seq = 0\n    for i in xrange(h):\n        if c[i][j] == 0:\n            seq += 1\n        else:\n            seq = 0\n        cnt[i][j] = seq\nans = 0\nst = [(0, -1)]\nfor i in xrange(h):\n    for j in xrange(w):\n        v = cnt[i][j]\n        last = j\n        while v < st[-1][0]:\n            l, k = st.pop()\n            last = k\n            ans = max(ans, l*(j-k))\n        if st[-1][0] < v:\n            st.append((v, last))\n    while 0 < st[-1][0]:\n        l, k = st.pop()\n        ans = max(ans, l*(w-k))\nprint ans"
  },
  {
    "language": "Python",
    "code": "import sys, collections\nfile = sys.stdin\nH,W = map(int, file.readline().split())\nC = [list(map(int,i.split())) for i in file.readlines()]\nprev = [0 for i in range(W)]\ndef height(C):\n    global prev\n    P = []\n    for i in range(W):\n        if C[-1][i] == 1:\n            p = 0\n        else: p = prev[i] + 1\n        P.append(p)\n    prev = P[:]\n    return P\n\ndef square(C):\n    P = height(C)\n    G = []\n    L = collections.deque()\n    for i,v in enumerate(P):\n        if not L:\n            L.append((i, v))\n            continue\n        if v > L[-1][1]:\n            L.append((i, v))\n        elif v < L[-1][1]:\n            k = i - 1\n            while L and v < L[-1][1]:\n                a = L.pop()\n                G.append((k - a[0] + 1) * a[1])\n            L.append((a[0], v))\n    while L:\n        a = L.pop()\n        G.append((len(P) - a[0]) * a[1])\n    return max(G)\n\ndef ans(C):\n    ans = []\n    for i in range(H):\n        currentC = C[:i+1]\n        ans.append(square(currentC))\n    return str(max(ans))\nprint(ans(C))"
  },
  {
    "language": "Python",
    "code": "import sys, collections\nfile = sys.stdin\nH,W = map(int, file.readline().split())\nC = [list(map(int,i.split())) for i in file.readlines()]\n\ndef height(C):\n    P = []\n    for i in range(W):\n        p = 0\n        for j in range(len(C)):\n            if C[j][i] == 1:\n                p = 0\n            else: p += 1\n        P.append(p)\n    return P\n\ndef square(C):\n    P = height(C)\n    G = []\n    L = collections.deque()\n    for i,v in enumerate(P):\n        if not L:\n            L.append((i, v))\n            continue\n        if v > L[-1][1]:\n            L.append((i, v))\n        elif v < L[-1][1]:\n            k = i - 1\n            while L and v < L[-1][1]:\n                a = L.pop()\n                G.append((k - a[0] + 1) * a[1])\n            L.append((a[0], v))\n    while L:\n        a = L.pop()\n        G.append((len(P) - a[0]) * a[1])\n    return max(G)\n\ndef ans(C):\n    ans = []\n    for i in range(H):\n        currentC = C[:i+1]\n        ans.append(square(currentC))\n    return str(max(ans))\nprint(ans(C))"
  },
  {
    "language": "Python",
    "code": "h, w = map(int, input().split())\n\nmp = []\nfor _ in range(h):\n  lst = list(map(int, input().split()))\n  cum = []\n  acc = 0\n  for i in lst:\n    if not i:\n      acc += 1\n    else:\n      acc = 0\n    cum.append(acc)\n  mp.append(cum)\nmp.append([-1] * w)\nans = 0\n\nfor i in range(w):\n  stack = []\n\n  for j in range(h + 1):\n    score = mp[j][i]\n\n    if not stack:\n      stack.append((score, j))\n\n    else:\n      last_score, last_ind = stack[-1][0], stack[-1][1]\n      if score > last_score:\n        stack.append((score, j))\n      \n      elif score == last_score:\n        continue\n      \n      else:\n        while stack != [] and stack[-1][0] >= score:\n          last_score, last_ind = stack.pop()\n          ans = max(ans, last_score * (j - last_ind))\n        stack.append((score, last_ind))\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n4 5\n0 0 1 0 0\n1 0 0 0 0\n0 0 0 1 0\n0 0 0 1 0\n\noutput:\n6\n\"\"\"\n\nimport sys\n\n\n# from collections import namedtuple\n\n\nclass Rectangle(object):\n    __slots__ = ('pos', 'height')\n\n    def __init__(self, pos=float('inf'), height=-1):\n        \"\"\"\n        init a Rectangle\n        \"\"\"\n        self.pos = pos\n        self.height = height\n\n\ndef gen_rec_info(_carpet_info):\n    dp = [[0] * (W + 1) for _ in range(H + 1)]\n\n    for i in range(H):\n        for j in range(W):\n            if not int(_carpet_info[i][j]):\n                dp[i + 1][j + 1] = dp[i][j + 1] + 1\n\n    return dp\n\n\ndef get_largest_area(_hi_info):\n    hi_max_area = 0\n    rec_stack = []\n    for i, v in enumerate(_hi_info):\n        rect = Rectangle(pos=i, height=int(v))\n        if not rec_stack:\n            rec_stack.append(rect)\n        else:\n            last_height = rec_stack[-1].height\n            if last_height < rect.height:\n                rec_stack.append(rect)\n            elif last_height > rect.height:\n                target = i\n                while rec_stack and rec_stack[-1].height >= rect.height:\n                    pre = rec_stack.pop()\n                    area = pre.height * (i - pre.pos)\n                    hi_max_area = max(hi_max_area, area)\n                rect.pos = target\n                rec_stack.append(rect)\n\n    return hi_max_area\n\n\ndef solve(_rec_info):\n    overall_max_area = 0\n    for hi_info in _rec_info:\n        overall_max_area = max(overall_max_area, get_largest_area(hi_info))\n\n    return overall_max_area\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    H, W = map(int, _input[0].split())\n    carpet_info = list(map(lambda x: x.split(), _input[1:]))\n    # Rectangle = namedtuple('Rectangle', ('pos', 'height'))\n\n    rec_info = gen_rec_info(carpet_info)\n    ans = solve(rec_info)\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "def new_max_rectangle(array):\n    max_area = 0\n\n    for i in range(len(array)):\n        min_height = array[i]\n        width = 1\n        for j in range(i + 1, len(array)):\n            width += 1\n            if array[j] == 0:\n                width = 1\n                if j <= i:\n                    min_height = array[j + 1]\n                continue\n            min_height = array[j] if min_height > array[j] else min_height\n            max_area = width * min_height if width * min_height > max_area else max_area\n\n    return max_area\n\n\ndef algorithm():\n    r, c = map(int, input().split(' '))\n\n    ans_array = [0 for _ in range(c)]\n    input_matrix = []\n\n    for _ in range(r):\n        input_matrix.append(list(map(int, input().split(' '))))\n\n    largest_square = 0\n\n    for i in range(r):\n        for j in range(c):\n            ans_array[j] = ans_array[j] + 1 if input_matrix[i][j] == 0 else 0\n        m = new_max_rectangle(ans_array)\n        largest_square = largest_square if largest_square > m else m\n\n    print(largest_square)\n\n\ndef main():\n    algorithm()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nreadline = stdin.readline\n\nh, w = map(int, readline().split())\n\ndp = [list(map(int, readline().split())) for _ in range(h)]\n\nfor i in range(h):\n    for j in range(w):\n        dp[i][j] ^= 1\n    \nfor i in range(1, h):\n    for j in range(w):\n        if dp[i][j]:\n            dp[i][j] = dp[i - 1][j] + 1\n\nmax_s = 0\nfor i in range(h):\n    for j in range(w):\n        h = dp[i][j]\n        for k in range(j, w):\n            if dp[i][k] == 0:\n                break\n            h = min(h, dp[i][k])\n            s = h * ((k - j) + 1)\n            if max_s < s:\n                max_s = s\nprint(max_s)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n4 5\n0 0 1 0 0\n1 0 0 0 0\n0 0 0 1 0\n0 0 0 1 0\n\noutput:\n6\n\"\"\"\n\nimport sys\n\n\nclass Rectangle(object):\n    __slots__ = ('pos', 'height')\n\n    def __init__(self, pos=float('inf'), height=-1):\n        \"\"\"\n        init a Rectangle\n        \"\"\"\n        self.pos = pos\n        self.height = height\n\n\ndef gen_rec_info(_carpet_info):\n    dp = [[float('inf')] * W for _ in range(H)]\n\n    for i in range(H):\n        for j in range(W):\n            if int(_carpet_info[i][j]):\n                dp[i][j] = 0\n            else:\n                dp[i][j] = dp[i - 1][j] + 1 if i else 1\n\n    return dp\n\n\ndef get_largest_area(_hi_info):\n    hi_max_area = 0\n    rec_stack = []\n    _hi_info.append(0)\n\n    for i, v in enumerate(_hi_info):\n        rect = Rectangle(pos=i, height=int(v))\n        if not rec_stack:\n            rec_stack.append(rect)\n        else:\n            last_height = rec_stack[-1].height\n            if last_height < rect.height:\n                rec_stack.append(rect)\n            elif last_height > rect.height:\n                target = i\n                while rec_stack and rec_stack[-1].height >= rect.height:\n                    pre = rec_stack.pop()\n                    area = pre.height * (i - pre.pos)\n                    hi_max_area = max(hi_max_area, area)\n                    target = pre.pos\n                rect.pos = target\n                rec_stack.append(rect)\n\n    return hi_max_area\n\n\ndef solve(_rec_info):\n    overall_max_area = 0\n    for hi_info in _rec_info:\n        overall_max_area = max(overall_max_area, get_largest_area(hi_info))\n\n    return overall_max_area\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    H, W = map(int, _input[0].split())\n    carpet_info = list(map(lambda x: x.split(), _input[1:]))\n\n    rec_info = gen_rec_info(carpet_info)\n    # print(rec_info)\n    ans = solve(rec_info)\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "class Rectangle:\n    def __init__(self, height, pos):\n        self.height = height\n        self.pos = pos\n\n\ndef getLargestRectangleInRow(size, buffer):\n    s = []\n    maxv = 0\n    buffer.append(0)\n    for i in range(size + 1):\n        rect = Rectangle(buffer[i], i)\n        if len(s) == 0:\n            s.append(rect)\n        else:\n            if s[-1].height < rect.height:\n                s.append(rect)\n            elif s[-1].height > rect.height:\n                target = i\n                while len(s) != 0 and s[-1].height >= rect.height:\n                    pre = s.pop()\n                    area = pre.height * (i - pre.pos)\n                    maxv = max(maxv, area)\n                    target = pre.pos\n                rect.pos = target\n                s.append(rect)\n\n    return maxv\n\n\ndef getLargestRectangle(H, W, buffer):\n    t = [[0] * W for i in range(H)]\n    for i in range(H):\n        for j in range(W):\n            if buffer[i][j] == 1:\n                t[i][j] = 0\n            else:\n                if i > 0:\n                    t[i][j] = t[i-1][j] + 1\n                else:\n                    t[i][j] = 1\n\n    maxv = 0\n    for i in range(H):\n        maxv = max(maxv, getLargestRectangleInRow(W, t[i]))\n    return maxv\n\n\n\nif __name__ == '__main__':\n    h, w = [int(v) for v in input().split()]\n    c = []\n    for i in range(h):\n        c.append([int(v) for v in input().split()])\n\n    print(getLargestRectangle(h, w, c))\n"
  },
  {
    "language": "Python",
    "code": "from typing import List, Tuple\n\n\ndef rectangle(max_width: int, hist: List[int]) -> int:\n    stack: List[Tuple[int, int]] = []  # (height, x_position)\n    ans = 0\n    for i, h in enumerate(hist):\n        j = i\n        while stack and stack[-1][0] > h:\n            pre_h, j = stack.pop()\n            ans = max(ans, (i - j) * pre_h)\n\n        if not stack or stack[-1][0] < h:\n            stack.append((h, j))\n\n    ans = max(ans, max((max_width - j) * h for h, j in stack))\n    return ans\n\n\nif __name__ == \"__main__\":\n    H, W = map(lambda x: int(x), input().split())\n    hist = [0] * W\n\n    result = 0\n    for _ in range(H):\n        one_row = list(map(int, input().split()))\n        hist = list(map(lambda pre, cur: (pre + 1) * (cur ^ 1), hist, one_row))\n        result = max(result, rectangle(W, hist))\n\n    print(result)\n\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import deque\nH, W = map(int, stdin.readline().split())\nC = [list(map(int, stdin.readline().split())) for i in range(H)]\nprev = [0] * W\ndef height(C):\n    global prev\n    P = [0 if C[-1][i] == 1 else prev[i] + 1 for i in range(W)]\n    prev = P[:]\n    return P\ndef square(C):\n    P = height(C)\n    G = deque()\n    L = deque()\n    for i, v in enumerate(P):\n        if not L or v > L[-1][1]:\n            L.append((i, v))\n        elif v < L[-1][1]:\n            k = i - 1\n            while L and v < L[-1][1]:\n                a = L.pop()\n                G.append((k - a[0] + 1) * a[1])\n            L.append((a[0], v))\n    len_P = len(P)\n    while L:\n        a = L.pop()\n        G.append((len_P - a[0]) * a[1])\n    return max(G)\nprint(max([square(C[:i + 1]) for i in range(H)]))"
  },
  {
    "language": "Python",
    "code": "def rectangle(n, hs):\n  stack = [] #高さと位置を格納\n  ans = 0\n  for i, h in enumerate(hs):\n    j = i\n    while stack and stack[-1][0] > h:\n      pre_h, j = stack.pop()\n      ans = max(ans, (i - j) * pre_h)\n\n    if not stack or stack[-1][0] < h:\n      stack.append((h, j))\n\n  ans = max(ans, max((n-j) * h2 for h2, j in stack))\n\n  return ans\n\nH, W = map(int, input().split())\n\n#ここでリストを固定化しておかないと値を受け付けてくれない\nhist = [0] * W\nresult = 0\nfor _ in range(H):\n  ht = list(map(int, input().split()))\n  hist = list(map(lambda pre, cur: (pre+1) * (cur ^ 1), hist, ht))\n  result = max(result, rectangle(W, hist))\nprint(result)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\n\"\"\"\ninput:\n4 5\n0 0 1 0 0\n1 0 0 0 0\n0 0 0 1 0\n0 0 0 1 0\n\noutput:\n6\n\"\"\"\n\nimport sys\n\n\nclass Rectangle(object):\n    __slots__ = ('pos', 'height')\n\n    def __init__(self, pos=float('inf'), height=-1):\n        \"\"\"\n        init a Rectangle\n        \"\"\"\n        self.pos = pos\n        self.height = height\n\n\ndef gen_rec_info(_carpet_info):\n    dp = [[float('inf')] * W for _ in range(H)]\n\n    for i in range(H):\n        for j in range(W):\n            if int(_carpet_info[i][j]):\n                dp[i][j] = 0\n            else:\n                dp[i][j] = dp[i - 1][j] + 1 if i else 1\n\n    return dp\n\n\ndef get_largest_area(_hi_info):\n    hi_max_area = 0\n    rec_stack = []\n    _hi_info.append(0)\n\n    for i, v in enumerate(_hi_info):\n        rect = Rectangle(pos=i, height=int(v))\n        if not rec_stack:\n            rec_stack.append(rect)\n        else:\n            last_height = rec_stack[-1].height\n            if last_height < rect.height:\n                rec_stack.append(rect)\n            elif last_height > rect.height:\n                target = i\n                while rec_stack and rec_stack[-1].height >= rect.height:\n                    pre = rec_stack.pop()\n                    area = pre.height * (i - pre.pos)\n                    hi_max_area = max(hi_max_area, area)\n                    target = pre.pos\n                rect.pos = target\n                rec_stack.append(rect)\n\n    return hi_max_area\n\n\ndef solve(_rec_info):\n    overall_max_area = 0\n    for hi_info in _rec_info:\n        overall_max_area = max(overall_max_area, get_largest_area(hi_info))\n\n    return overall_max_area\n\n\nif __name__ == '__main__':\n    _input = sys.stdin.readlines()\n    H, W = map(int, _input[0].split())\n    carpet_info = list(map(lambda x: x.split(), _input[1:]))\n\n    rec_info = gen_rec_info(carpet_info)\n    # print(rec_info)\n    ans = solve(rec_info)\n    print(ans)"
  },
  {
    "language": "Python",
    "code": "h, w = map(int, input().split())\n\nmp = []\nfor _ in range(h):\n  lst = list(map(int, input().split()))\n  cum = []\n  acc = 0\n  for i in lst:\n    if not i:\n      acc += 1\n    else:\n      acc = 0\n    cum.append(acc)\n  mp.append(cum)\nmp.append([-1] * w)\nans = 0\n\n#print(*mp, sep=\"\\n\")\nfor i in range(w - 1, -1, -1):\n  stack = []\n#  print(ans)\n  for j in range(h + 1):\n#    print(stack)\n    score = mp[j][i]\n    if not stack:\n      stack.append((score, j))\n    else:\n      last_score, last_ind = stack[-1][0], stack[-1][1]\n      if score > last_score:\n        stack.append((score, j))\n      elif score == last_score:\n        continue\n      else:\n        while stack and stack[-1][0] > score:\n          last_score, last_ind = stack.pop()\n          ans = max(ans, last_score * (j - last_ind))\n        if not stack:\n          stack.append((score, last_ind))\n        elif stack[-1][0] == score:\n          pass\n        else:\n          stack.append((score, last_ind))\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "h, w = map(int, input().split())\n\nmp = []\nfor _ in range(h):\n  lst = list(map(int, input().split()))\n  cum = []\n  acc = 0\n  for i in lst:\n    if not i:\n      acc += 1\n    else:\n      acc = 0\n    cum.append(acc)\n  mp.append(cum)\nmp.append([-1] * w)\nans = 0\n\nfor i in range(w - 1, -1, -1):\n  stack = []\n#  print(ans)\n  for j in range(h + 1):\n#    print(stack)\n    score = mp[j][i]\n    if not stack:\n      stack.append((score, j))\n    else:\n      last_score, last_ind = stack[-1][0], stack[-1][1]\n      if score > last_score:\n        stack.append((score, j))\n      elif score == last_score:\n        continue\n      else:\n        while stack and last_score > score:\n          last_score, last_ind = stack.pop()\n          ans = max(ans, last_score * (j - last_ind))\n        stack.append((score, last_ind))\n\nprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "from sys import stdin\nfrom collections import deque\nreadline = stdin.readline\nh, w = map(int, readline().split())\nw += 1\ndp = [list(map(int, readline().split())) + [1] for _ in range(h)]\nfor i in range(h):\n    for j in range(w):\n        dp[i][j] ^= 1\nfor i in range(1, h):\n    for j in range(w):\n        if dp[i][j]:\n            dp[i][j] += dp[i - 1][j]\nmax_s = 0\nfor i in range(h):\n    stack = deque()\n    for j in range(w):\n        if (stack[-1][0] if stack else 0) < dp[i][j]:\n            stack.append((dp[i][j], j))\n        elif stack and stack[-1][0] > dp[i][j]:\n            while stack and stack[-1][0] > dp[i][j]:\n                height, l = stack.pop()\n                s = height * (j - l)\n                if max_s < s:\n                    max_s = s\n            if dp[i][j]:\n                stack.append((dp[i][j], l))\nprint(max_s)"
  },
  {
    "language": "Rust",
    "code": "use std::io::Read;\n\nfn run() {\n    let mut s = String::new();\n    std::io::stdin().read_to_string(&mut s).unwrap();\n    let mut it = s.trim().split_whitespace();\n    let h: usize = it.next().unwrap().parse().unwrap();\n    let w: usize = it.next().unwrap().parse().unwrap();\n    let mut a = vec![vec![0usize; w + 1]; h + 1];\n    for a in a.iter_mut().take(h) {\n        for a in a.iter_mut().take(w) {\n            *a = it.next().unwrap().parse().unwrap();\n        }\n    }\n    for i in (0..h).rev() {\n        for j in 0..w {\n            if a[i][j] == 1 {\n                a[i][j] = 0;\n            } else {\n                a[i][j] = a[i + 1][j] + 1;\n            }\n        }\n    }\n    let mut ans = 0;\n    for a in a.iter().take(h) {\n        let mut stack: Vec<(usize, usize)> = vec![];\n        for (i, &a) in a.iter().enumerate() {\n            let mut k = i;\n            while let Some(&(l, b)) = stack.last() {\n                if a >= b {\n                    break;\n                } else {\n                    ans = std::cmp::max(ans, (i - l) * b);\n                    k = l;\n                    stack.pop();\n                }\n            }\n            stack.push((k, a));\n        }\n    }\n    println!(\"{}\", ans);\n}\n\nfn main() {\n    run();\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[macro_export]\nmacro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut parser = Parser :: from_str ( $ s ) ; input_inner ! { parser , $ ( $ r ) * } } ; ( parser = $ parser : ident , $ ( $ r : tt ) * ) => { input_inner ! { $ parser , $ ( $ r ) * } } ; ( new_stdin_parser = $ parser : ident , $ ( $ r : tt ) * ) => { let stdin = std :: io :: stdin ( ) ; let reader = std :: io :: BufReader :: new ( stdin . lock ( ) ) ; let mut $ parser = Parser :: new ( reader ) ; input_inner ! { $ parser , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { input ! { new_stdin_parser = parser , $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! input_inner { ( $ parser : ident ) => { } ; ( $ parser : ident , ) => { } ; ( $ parser : ident , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ parser , $ t ) ; input_inner ! { $ parser $ ( $ r ) * } } ; }\n#[macro_export]\nmacro_rules ! read_value { ( $ parser : ident , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ parser , $ t ) ) ,* ) } ; ( $ parser : ident , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ parser , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ parser : ident , chars ) => { read_value ! ( $ parser , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ parser : ident , usize1 ) => { read_value ! ( $ parser , usize ) - 1 } ; ( $ parser : ident , $ t : ty ) => { $ parser . next ::<$ t > ( ) . expect ( \"Parse error\" ) } ; }\nuse std::io;\nuse std::io::BufRead;\nuse std::str;\npub struct Parser<R> {\n    reader: R,\n    buf: Vec<u8>,\n    pos: usize,\n}\nimpl Parser<io::Empty> {\n    pub fn from_str(s: &str) -> Parser<io::Empty> {\n        Parser {\n            reader: io::empty(),\n            buf: s.as_bytes().to_vec(),\n            pos: 0,\n        }\n    }\n}\nimpl<R: BufRead> Parser<R> {\n    pub fn new(reader: R) -> Parser<R> {\n        Parser {\n            reader: reader,\n            buf: vec![],\n            pos: 0,\n        }\n    }\n    pub fn update_buf(&mut self) {\n        self.buf.clear();\n        self.pos = 0;\n        loop {\n            let (len, complete) = {\n                let buf2 = self.reader.fill_buf().unwrap();\n                self.buf.extend_from_slice(buf2);\n                let len = buf2.len();\n                if len == 0 {\n                    break;\n                }\n                (len, buf2[len - 1] <= 0x20)\n            };\n            self.reader.consume(len);\n            if complete {\n                break;\n            }\n        }\n    }\n    pub fn next<T: str::FromStr>(&mut self) -> Result<T, T::Err> {\n        loop {\n            let mut begin = self.pos;\n            while begin < self.buf.len() && (self.buf[begin] <= 0x20) {\n                begin += 1;\n            }\n            let mut end = begin;\n            while end < self.buf.len() && (self.buf[end] > 0x20) {\n                end += 1;\n            }\n            if begin != self.buf.len() {\n                self.pos = end;\n                return str::from_utf8(&self.buf[begin..end]).unwrap().parse::<T>();\n            } else {\n                self.update_buf();\n            }\n        }\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\n#[doc = \" https://github.com/hatoo/competitive-rust-snippets\"]\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nstruct Rect {\n    h: usize,\n    p: usize,\n}\nfn max_area_in_histgram(hist: &[usize]) -> usize {\n    let mut max_v = 0;\n\n    let mut h = vec![];\n    for &x in hist {\n        h.push(x);\n    }\n    h.push(0); // sentinel\n\n    let mut stack = vec![];\n\n    for i in 0..h.len() {\n        let cur_h = h[i];\n        if stack.is_empty() {\n            stack.push(Rect{h:cur_h,p:i});\n        } else if stack.last().unwrap().h < cur_h {\n            stack.push(Rect{h:cur_h,p:i});\n        } else if stack.last().unwrap().h > cur_h {\n            let mut new_i = i;\n            while !stack.is_empty() && stack.last().unwrap().h > cur_h {\n                let rect = stack.pop().unwrap();\n                new_i = rect.p;\n                max_v = max(max_v, (i-new_i)*rect.h);\n            }\n            stack.push(Rect{h:cur_h,p:new_i})\n        }\n    }\n\n    max_v\n}\nfn solve() {\n    input! {\n        H: usize, W: usize,\n        T: [[u8; W]; H],\n    }\n    let mut dp = vec![vec![0; W]; H+1];\n    for i in 1..H+1 {\n        for j in 0..W {\n            let tile = T[i-1][j];\n            if tile == 1 {\n                dp[i][j] = 0;\n            } else {\n                dp[i][j] = dp[i-1][j] + 1;\n            }\n        }\n    }\n    // dbg!(&dp);\n\n    let mut max_v = 0;\n    for i in 1..H+1 {\n        let v = max_area_in_histgram(&dp[i]);\n        max_v = max(max_v, v);\n    }\n\n    println!(\"{}\", max_v);\n}\n"
  },
  {
    "language": "Rust",
    "code": "use std::cmp;\nuse std::collections::VecDeque;\n\ntrait TopQueue<T> {\n    fn top(&self) -> &T;\n}\n\nimpl<T> TopQueue<T> for VecDeque<T> {\n    fn top(&self) -> &T {\n        assert!(!self.is_empty());\n        self.iter().next().unwrap()\n    }\n}\n\nfn f(hist: &Vec<usize>) -> usize {\n    let n = hist.len();\n    let mut ans = 0;\n    let mut q: VecDeque<(usize, usize)> = VecDeque::new();\n\n    for i in 0..n {\n        let mut reachable_min = i;\n        while !q.is_empty() && q.top().1 > hist[i] {\n            let (pos, height) = q.pop_front().unwrap();\n            reachable_min = pos;\n            ans = cmp::max(ans, (i - reachable_min) * height);\n        }\n\n        if q.is_empty() || q.top().1 < hist[i] {\n            q.push_front((reachable_min, hist[i]));\n        }\n    }\n    while !q.is_empty() {\n        let (pos, height) = q.pop_front().unwrap();\n        ans = cmp::max(ans, (n - pos) * height);\n    }\n    ans\n}\n\nfn main() {\n    let mut sc = Scanner::new();\n    let h = sc.read();\n    let w = sc.read();\n    let mut c = vec![vec![false; w]; h];\n    for i in 0..h {\n        for j in 0..w {\n            c[i][j] = sc.read::<usize>() == 0;\n        }\n    }\n\n    let mut hist = vec![vec![0; w]; h];\n    for i in 0..h {\n        for j in 0..w {\n            if !c[i][j] {\n                continue;\n            }\n            if i == 0 {\n                hist[i][j] = 1;\n            } else {\n                hist[i][j] = hist[i - 1][j] + 1;\n            }\n        }\n    }\n\n    let mut ans = 0;\n    for i in 0..h {\n        ans = cmp::max(ans, f(&hist[i]));\n    }\n    println!(\"{}\", ans);\n}\n\nstruct Scanner {\n    ptr: usize,\n    length: usize,\n    buf: Vec<u8>,\n    small_cache: Vec<u8>,\n}\n\n#[allow(dead_code)]\nimpl Scanner {\n    fn new() -> Scanner {\n        Scanner {\n            ptr: 0,\n            length: 0,\n            buf: vec![0; 1024],\n            small_cache: vec![0; 1024],\n        }\n    }\n\n    fn load(&mut self) {\n        use std::io::Read;\n        let mut s = std::io::stdin();\n        self.length = s.read(&mut self.buf).unwrap();\n    }\n\n    fn byte(&mut self) -> u8 {\n        if self.ptr >= self.length {\n            self.ptr = 0;\n            self.load();\n            if self.length == 0 {\n                self.buf[0] = b'\\n';\n                self.length = 1;\n            }\n        }\n\n        self.ptr += 1;\n        return self.buf[self.ptr - 1];\n    }\n\n    fn is_space(b: u8) -> bool {\n        b == b'\\n' || b == b'\\r' || b == b'\\t' || b == b' '\n    }\n\n    fn read_vec<T>(&mut self, n: usize) -> Vec<T>\n    where\n        T: std::str::FromStr,\n        T::Err: std::fmt::Debug,\n    {\n        (0..n).map(|_| self.read()).collect()\n    }\n\n    fn usize_read(&mut self) -> usize {\n        self.read()\n    }\n\n    fn read<T>(&mut self) -> T\n    where\n        T: std::str::FromStr,\n        T::Err: std::fmt::Debug,\n    {\n        let mut b = self.byte();\n        while Scanner::is_space(b) {\n            b = self.byte();\n        }\n\n        for pos in 0..self.small_cache.len() {\n            self.small_cache[pos] = b;\n            b = self.byte();\n            if Scanner::is_space(b) {\n                return String::from_utf8_lossy(&self.small_cache[0..(pos + 1)])\n                    .parse()\n                    .unwrap();\n            }\n        }\n\n        let mut v = self.small_cache.clone();\n        while !Scanner::is_space(b) {\n            v.push(b);\n            b = self.byte();\n        }\n        return String::from_utf8_lossy(&v).parse().unwrap();\n    }\n}\n\n"
  },
  {
    "language": "Rust",
    "code": "/**\n*  _           _                 __                            _   _ _   _                                 _                    _                  _\n* | |         | |               / /                           | | (_) | (_)                               | |                  (_)                | |\n* | |__   __ _| |_ ___   ___   / /__ ___  _ __ ___  _ __   ___| |_ _| |_ ___   _____ ______ _ __ _   _ ___| |_ ______ ___ _ __  _ _ __  _ __   ___| |_ ___\n* | '_ \\ / _` | __/ _ \\ / _ \\ / / __/ _ \\| '_ ` _ \\| '_ \\ / _ \\ __| | __| \\ \\ / / _ \\______| '__| | | / __| __|______/ __| '_ \\| | '_ \\| '_ \\ / _ \\ __/ __|\n* | | | | (_| | || (_) | (_) / / (_| (_) | | | | | | |_) |  __/ |_| | |_| |\\ V /  __/      | |  | |_| \\__ \\ |_       \\__ \\ | | | | |_) | |_) |  __/ |_\\__ \\\n* |_| |_|\\__,_|\\__\\___/ \\___/_/ \\___\\___/|_| |_| |_| .__/ \\___|\\__|_|\\__|_| \\_/ \\___|      |_|   \\__,_|___/\\__|      |___/_| |_|_| .__/| .__/ \\___|\\__|___/\n*                                                  | |                                                                           | |   | |\n*                                                  |_|                                                                           |_|   |_|\n*\n* https://github.com/hatoo/competitive-rust-snippets\n*/\n#[allow(unused_imports)]\nuse std::cmp::{max, min, Ordering};\n#[allow(unused_imports)]\nuse std::collections::{BTreeMap, BTreeSet, BinaryHeap, HashMap, HashSet, VecDeque};\n#[allow(unused_imports)]\nuse std::io::{stdin, stdout, BufWriter, Write};\n#[allow(unused_imports)]\nuse std::iter::FromIterator;\nmod util {\n    use std::fmt::Debug;\n    use std::io::{stdin, stdout, BufWriter, StdoutLock};\n    use std::str::FromStr;\n    #[allow(dead_code)]\n    pub fn line() -> String {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.trim().to_string()\n    }\n    #[allow(dead_code)]\n    pub fn chars() -> Vec<char> {\n        line().chars().collect()\n    }\n    #[allow(dead_code)]\n    pub fn gets<T: FromStr>() -> Vec<T>\n    where\n        <T as FromStr>::Err: Debug,\n    {\n        let mut line: String = String::new();\n        stdin().read_line(&mut line).unwrap();\n        line.split_whitespace()\n            .map(|t| t.parse().unwrap())\n            .collect()\n    }\n    #[allow(dead_code)]\n    pub fn with_bufwriter<F: FnOnce(BufWriter<StdoutLock>) -> ()>(f: F) {\n        let out = stdout();\n        let writer = BufWriter::new(out.lock());\n        f(writer)\n    }\n}\n#[allow(unused_macros)]\nmacro_rules ! get { ( $ t : ty ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . trim ( ) . parse ::<$ t > ( ) . unwrap ( ) } } ; ( $ ( $ t : ty ) ,* ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; let mut iter = line . split_whitespace ( ) ; ( $ ( iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) , ) * ) } } ; ( $ t : ty ; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ ( $ t : ty ) ,*; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ ( $ t ) ,* ) ) . collect ::< Vec < _ >> ( ) } ; ( $ t : ty ;; ) => { { let mut line : String = String :: new ( ) ; stdin ( ) . read_line ( & mut line ) . unwrap ( ) ; line . split_whitespace ( ) . map ( | t | t . parse ::<$ t > ( ) . unwrap ( ) ) . collect ::< Vec < _ >> ( ) } } ; ( $ t : ty ;; $ n : expr ) => { ( 0 ..$ n ) . map ( | _ | get ! ( $ t ;; ) ) . collect ::< Vec < _ >> ( ) } ; }\n#[allow(unused_macros)]\nmacro_rules ! debug { ( $ ( $ a : expr ) ,* ) => { eprintln ! ( concat ! ( $ ( stringify ! ( $ a ) , \" = {:?}, \" ) ,* ) , $ ( $ a ) ,* ) ; } }\nconst BIG_STACK_SIZE: bool = true;\n#[allow(dead_code)]\nfn main() {\n    use std::thread;\n    if BIG_STACK_SIZE {\n        thread::Builder::new()\n            .stack_size(32 * 1024 * 1024)\n            .name(\"solve\".into())\n            .spawn(solve)\n            .unwrap()\n            .join()\n            .unwrap();\n    } else {\n        solve();\n    }\n}\nfn solve() {\n    let (h, w) = get!(usize, usize);\n    let c: Vec<Vec<usize>> = (0..h).map(|_| util::gets()).collect();\n\n    let mut hists = vec![vec![0; w + 1]; h];\n\n    for i in 0..h {\n        for j in 0..w {\n            if c[i][j] == 1 {\n                hists[i][j] = 0;\n            } else {\n                if i > 0 {\n                    hists[i][j] = hists[i - 1][j] + 1;\n                } else {\n                    hists[i][j] = 1;\n                }\n            }\n        }\n    }\n\n    let ans = hists\n        .into_iter()\n        .map(|v| {\n            let mut stack: Vec<(usize, usize)> = Vec::new();\n            let mut maxv = 0;\n\n            for (i, h) in v.into_iter().enumerate() {\n                if let Some(p) = stack.last().cloned() {\n                    match (p.1).cmp(&h) {\n                        Ordering::Equal => (),\n                        Ordering::Less => {\n                            stack.push((i, h));\n                        }\n                        Ordering::Greater => {\n                            let mut t = 0;\n                            while !stack.is_empty() && stack.last().unwrap().1 > h {\n                                let (j, k) = stack.pop().unwrap();\n                                let v = k * (i - j);\n                                t = j;\n                                maxv = max(maxv, v);\n                            }\n                            stack.push((t, h));\n                        }\n                    }\n                } else {\n                    stack.push((i, h));\n                }\n            }\n\n            maxv\n        })\n        .max()\n        .unwrap_or(0);\n\n    println!(\"{}\", ans);\n}\n\n"
  }
]