[
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V vector\n#define W V<long>\nusing namespace std;long E,M=2e17,a,b;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].push_back({x[0]/2,++x[1]/2});}for(long i;i<2;i++){a=0;for(W x:T[!i])a^=(2*x[0]+x[1])%3+1;if(!a){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){cin>>E;V<W>p(E);while(E--,cin>>a>>b)p[E]={a+M,b+M};E=70;W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long long\n#define W V<L>\n#define R(n) for(L i=0;i<n;i++)\nW S(V<W>p,L E){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){W A=S(T[i],E-1);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p,E);A[0]--;return A;}\nint main(){L M=2e17,n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}cout<<S(p,70)[0]-M<<\" \"<<S(p,70)[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc+1)%2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0]&&!c[1-i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\n#define F for(\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);FW x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}for(L i;i<2;i++){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n,a,b;cin>>n;V<W>p(n);for(L i;i<n;i++){cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = 2 * x.first + x.second + 1;\n\t\tqc = (qc & (0xffffffff)) + ((qc & (0x7fffffff00000000)) >> 32);//qc<=1ffffffff\n\t\tqc = (qc & (0xffff)) + ((qc & (0x1ffff0000)) >> 16);//qc<=2ffff\n\t\tqc = (qc & (0xff)) + ((qc & (0x3ff00)) >> 8);//qc<=3ff\n\t\tqc = (qc & (0x1f)) + ((qc & (0x3e0)) >> 5);//qc<=3e\n\t\tqc = (qc & 7) + ((qc & 56) >> 3);//qc<=14\n\t\tqc = (qc & 3) + ((qc & 12) >> 2);\n\t\tqc = (qc & 3) + ((qc & 4) >> 2);\n\t\tc ^= qc;\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t\tw++;\n\t\tif ((w & x.first) == w) { d ^= 1; }\n\t}\n\tans.first *= 2; ans.second *= 2;\n\tans.first += (c | d); ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long long\n#define W V<L>\n#define R(n) for(L i=0;i<n;i++)\nL E=70;\nW S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}\nint main(){L M=2e17,n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n  \tc=0;\n  \tfor (pin& x : qab[1]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n  \tif (!c) {\n\t\tans.first *= 2; ans.second *= 2;\n\t\treturn ans;\n\t}\n\tc = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second-1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t}\n\tans.first *= 2; ans.first++; ans.second *= 2; ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\nvoid tostr(ll x,string& res){while(x)res+=('0'+(x%10)),x/=10; reverse(ALL(res)); return;}\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//end\n\nconstexpr ll c=200'000'000'000'000'000LL;\nint N; ll x[11000],y[11000];\nbool que(ll n,ll r){if(n<0||r<0||n<r)return 0; return (n&r)==r;}\nbool col(ll a){\n   bool res=0;\n   rep(i,0,N)if(a>=x[i])res^=que(c-x[i]-y[i],a-x[i]);\n   return res;\n}\nll cnt[3];\nvoid calc(ll n,ll t){\n   if(t<0){rep(i,0,3)cnt[i]=0; return;}\n   chmin(t,n); ll dp[64][3][2]={}; dp[60][0][1]=1;\n   rrep(i,59,-1)rep(j,0,3)rep(k,0,2)if(dp[i+1][j][k]){\n      rep(nxt,0,2){\n         if((n>>i&1)==0&&nxt)continue;\n         if(k&&nxt&&(t>>i&1)==0)continue;\n         int nj=(j+(nxt?(i&1?2:1):0))%3,nk=k;\n         if(nxt==0&&(t>>i&1))nk=0;\n         dp[i][nj][nk]+=dp[i+1][j][k];\n      }\n   }\n   rep(i,0,3)cnt[i]=dp[0][i][0]+dp[0][i][1];\n}\nll rng(ll n,ll lb,ll rb,int r){\n   cerr<<n<<lb<<rb<<r<<endl;\n   calc(n,rb); ll res=cnt[r];\n   calc(n,lb); res-=cnt[r];\n   cerr<<res<<endl;\n   return res;\n}\nbool flag(ll lb,ll rb,int r){\n   bool res=0;\n   rep(i,0,N)res^=rng(c-x[i]-y[i],lb-x[i],rb-x[i],((r-x[i])%3+3)%3)&1;\n   return res;\n}\n\n//reference:https://physics0523.hatenablog.com/entry/2019/02/26/190724\nint main(){\n   scanf(\"%d\",&N); rep(i,0,N)scanf(\"%lld%lld\",&x[i],&y[i]);\n   ll lb=-c/2,rb=c/2;\n   while(rb-lb>1){\n      ll mid=(lb+rb)>>1; bool f=0;\n      rep(r,0,3)if(flag(lb,mid,r)){f=1; break;}\n      if(f)rb=mid; else lb=mid;\n   }\n   assert(col(rb));\n   ll x1=rb,x2=rb;\n   cerr<<rb<<endl;\n   rrep(k,62,-1){\n      if(col(x1-(1LL<<k)))x1-=1LL<<k;\n      if(col(x2+(1LL<<k)))x2+=1LL<<k;\n   }\n   printf(\"%lld %lld\\n\",x1,c-x2);\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, a, b) for(int i = (a), i##end = (b); i <= i##end; ++ i)\n#define CLR(i, a) memset(i, a, sizeof(i))\n#define REPD(i, a, b) for(int i = (a), i##end = (b); i >= i##end; -- i)\n#define LOG(x) std::cerr << #x << \":\" << x << '\\n'\n#define DBG(...) fprintf(stderr, __VA_ARGS__)\n#define OK fprintf(stderr, \"Passing %s in LINE [%d]\\n\", __FUNCTION__, __LINE__)\n#define gc getchar\n#define pc putchar\n#define endl '\\n'\ntypedef long long LL;\ntypedef double DB;\ninline LL rd() {\n\tchar ch = gc(); LL ret = 0, sgn = 1;\n\twhile(ch < '0' || ch > '9') {\n\t\tif(ch == '-') sgn = -1;\n\t\tch = gc();\n\t}\n\twhile(ch <= '9' && ch >= '0') \n\t\tret = ret * 10 + ch - '0', ch = gc();\n\treturn ret * sgn;\n}\n/**************************************************************/\n\nconst int N = 1e4 + 3, LG = 60;\nconst LL INF = 1ll << 60;\n\nLL qx[N], qy[N], bot, rem;\nint n;\nint ind;\nbool f[N][LG + 3][3], vis[N][LG + 3][3];\n\nbool ifValid(LL x) {\n\tbool ret = 0;\n\tREP(i, 1, n) if(qx[i] <= x) {\n\t\tLL u = qy[i] - bot, v = x - qx[i];\n\t\tret ^= ((u | v) == u);\n\t}\n\treturn ret;\n}\n\nint upa[LG + 3], upb[LG + 3];\n\nbool Dp(int pos, int tr, bool lim) {\n\tassert(tr <= 2);\n\tif(pos < 0) {\n\t\t// if(tr == 0) OK;\n\t\treturn (tr == 0);\n\t}\n\tif(lim && vis[ind][pos][tr]) return f[ind][pos][tr];\n\t// LOG(tr);\n\tint up = lim ? upa[pos] : 1;\n\tup = min(up, upb[pos]); \n\n\tbool ret = 0;\n\tREP(i, 0, up) {\n\t\tint ntr = (tr + 3 - ((LL)i * (1ll << pos) % 3) % 3) % 3;\n\t\tbool nlim = lim & (i == up);\n\t\tret ^= Dp(pos - 1, ntr, nlim);\n\t}\n\n\tif(!lim) {\n\t\tvis[ind][pos][tr] = 1;\n\t\tf[ind][pos][tr] = ret; \n\t}\n\treturn ret;\n}\n\ninline bool __main__(LL all, LL ql, LL qr, LL trem) {\n\t// assert(ql <= qr);\n\tif(ql > qr) return 0;\n\tassert(ql >= 0 && qr >= 0);\n\tREP(i, 0, LG) {\n\t\tupb[i] = (all >> i) & 1;\n\t\tupa[i] = (qr >> i) & 1;\n\t}\n\tbool ret = Dp(LG, trem, 1);\n\tif(ql > 0) {\n\t\tREP(i, 0, LG) upa[i] = ((ql - 1) >> i) & 1;\n\t\tret ^= Dp(LG, trem, 1);\n\t}\n\treturn ret;\n}\n\nbool Calc_sz(LL L, LL R) {\n\tassert(L <= R);\n\tbool ret = 0;\n\tREP(i, 1, n) {\n\t\tLL tl = max(qx[i], L) - qx[i], tr = min(qx[i] + qy[i] - bot, R) - qx[i];\n\t\tint trem = (rem - qx[i] % 3 + 3) % 3;\n\t\tind = i;\n\t\tret ^= __main__(qy[i] - bot, tl, tr, trem);\t\n\t\t// if(ret == 1) OK;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tn = rd();\n\tbot = INF;\n\tLL ll = INF, rr = -INF;\n\tREP(i, 1, n) {\n\t\tqx[i] = rd(), qy[i] = rd();\n\t\t// LOG(qx[i]), LOG(qy[i]);\n\t\tbot = min(qy[i], bot);\n\t\tll = min(ll, qx[i]), rr = max(rr, qx[i]);\n\t}\n\t-- bot;\n\t// LOG(ll), LOG(rr);\n\t// Calc_sz(ll, rr);\n\tfor(rem = 0; !Calc_sz(ll, rr); ++ rem) ;\n\t// LOG(rem);\n\tLL l = ll, r = rr;\n\twhile(l < r) {\n\t\tLL mid = l + r >> 1;\n\t\tif(Calc_sz(l, mid)) r = mid;\n\t\telse l = mid + 1; \n\t}\n\t// OK;\n\tstatic LL pw[LG + 3];\n\tpw[0] = 1;\n\tREP(i, 1, LG) pw[i] = pw[i - 1] << 1ll;\n\tLL resl = l, resr = l;\n\tREPD(k, LG, 0) {\n\t\t// LOG(pw[k]);\n\t\tif(ifValid(resl - pw[k])) resl -= pw[k];\n\t\tif(ifValid(resr + pw[k])) resr += pw[k];\n\t}\n\tprintf(\"%lld %lld\\n\", resl, bot + (resr - resl));\n\treturn 0;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nVPII lamps;\n//int C;\nint kInf = 4e17;\nVI Xor(VI L, VI R) {\n  REP (tr, SZ(L)) {\n    L[tr] ^= R[tr];\n  }\n  return L;\n}\nVI Shift(VI heh, int shift) {\n  VI dupa(SZ(heh));\n  REP (i, SZ(heh)) {\n    dupa[(i + shift) % SZ(heh)] = heh[i];\n  }\n  return dupa;\n}\nVI CountLamps1(int e, int x, int y) {\n  debug(kInf, e, x, y);\n  int d = kInf - x - y;\n  if (e < y) {\n    return {0, 0, 0};\n  }\n  VI bits;\n  REP (bit, 60) {\n    if (d & (1ll << bit)) {\n      bits.PB(1);\n    } else {\n      bits.PB(0);\n    }\n  }\n  vector<VI> prefs;\n  prefs.PB({1, 0, 0});\n  REP (bit, 60) {\n    if (!bits[bit]) {\n      prefs.PB(prefs.back());\n    } else if (bit % 2) {\n      prefs.PB(Xor(prefs.back(), Shift(prefs.back(), 2)));\n    } else {\n      prefs.PB(Xor(prefs.back(), Shift(prefs.back(), 1)));\n    }\n  }\n  int maxY = kInf - x;\n  if (e >= maxY) { return prefs.back(); }\n  int shift = 0;\n  int how_many = e - y + 1;\n  debug(how_many);\n  VI so_far{0, 0, 0};\n  FORD (bit, 59, 0) {\n    if (how_many & (1ll << bit)) {\n      debug(prefs[bit], shift % 3);\n      so_far = Xor(so_far, Shift(prefs[bit], shift % 3));\n      \n      if (bits[bit]) {\n        shift += (1ll << bit);\n      } else {\n        break;\n      }\n    }\n  }\n  return so_far;\n}\nVI CountLampsAll(int e) {\n  VI hehs{0, 0, 0};\n  for (auto lamp : lamps) {\n    VI lul = CountLamps1(e, lamp.st, lamp.nd);\n    hehs = Xor(hehs, lul);\n  }\n  return hehs;\n}\nVI CountLampsAll(int b, int e) {\n  return Xor(CountLampsAll(e), CountLampsAll(b - 1));\n}\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n\n//   kInf = 1;\n//   debug(CountLamps1(1, 0, 0));\n  //kInf = 5;\n  //debug(CountLamps1(5, 0, 0));\n  //debug(CountLamps1(4, 0, 0));\n//   debug(CountLamps1(3, 0, 0));\n//   kInf = 6;\n//   debug(CountLamps1(6, 0, 0));\n//   debug(CountLamps1(5, 0, 0));\n//   debug(CountLamps1(4, 0, 0));\n  \n  \n  \n  int n;\n  cin>>n;\n  RE (i, n) {\n    int x, y;\n    cin>>x>>y;\n    //maxi(C, x + y);\n    lamps.PB({x, y});\n  }\n  VI hehs = CountLampsAll(kInf);\n  int r;\n  REP (tr, 3) {\n    if (hehs[tr]) { r = tr; }\n  }\n  int kl = -kInf, kp = kInf;\n  while (kl <= kp) {\n    if (kl == kp) { break; }\n    int aktc = (kl + kp) / 2;\n    if (CountLampsAll(kl, aktc)[r]) {\n      kp = aktc;\n    } else {\n      kl = aktc + 1;\n    }\n  }\n  int L = kl, R = kl;\n  VI zeros{0, 0, 0};\n  REP (bit, 60) {\n    int candL = L - (1ll << bit);\n    if (CountLampsAll(candL, candL) != zeros) {\n      L = candL;\n    }\n    int candR = R + (1ll << bit);\n    if (CountLampsAll(candR, candR) != zeros) {\n      R = candR;\n    }\n  }\n  // R to maxy, L to miny\n  int X = kInf - R;\n  int Y = L;\n  cout<<X<<\" \"<<Y<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n      \tint qc=2*x.first+x.second+1;\n\tqc = (qc & (0xffffffff)) + ((qc & (0xfffffff00000000)) >> 32);\n\tqc = (qc & (0xffffffff)) + ((qc & (0x100000000)) >> 32);\n\tqc = (qc & (0xffff)) + ((qc & (0xffff0000)) >> 16);\n\tqc = (qc & (0xffff)) + ((qc & (0x10000)) >> 16);\n\tqc = (qc & (0xff)) + ((qc & (0xff00)) >> 8);\n\tqc = (qc & (0xff)) + ((qc & (0x100)) >> 8);\n\tqc = (qc & (0xf)) + ((qc & (0xf0)) >> 4);\n\tqc = (qc & (0xf)) + ((qc & (0x10)) >> 4);\n\tqc = (qc & 3) + ((qc & 12) >> 2);\n\tqc = (qc & 3) + ((qc & 4) >> 2);\n\t\tc ^= qc;\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first>>1, x.second>>1));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first>>1, (x.second + 1)>>1)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = 2 * x.first + x.second;qc%=3;\n\t\tc ^= (qc+1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t\tw++;\n\t\tif ((w & x.first) == w) { d ^= 1; }\n\t}\n\tans.first *= 2; ans.second *= 2;\n\tans.first += (c | d); ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long long\n#define W V<L>\n#define R(n) for(L i=0;i<n;i++)\nW S(V<W>&p,L E){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){W A=S(T[i],E-1);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p,E);A[0]--;return A;}\nint main(){L M=2e17,n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}cout<<S(p,70)[0]-M<<\" \"<<S(p,70)[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\trep(i, 2) {\n\t\tint c = 0;\n\t\tfor (pin& x : qab[1 - i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tc ^= (qc + 1);\n\t\t}\n\t\tif (!c) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tint c = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second-1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t}\n\tans.first *= 2; ans.first++; ans.second *= 2; ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 58);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\treturn solve(qab[rand()&1],ex-1);\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long long\n#define W V<L>\n#define R(n) for(L i=0;i<n;i++)\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n      \tint qc=2*x.first+x.second+1;\n\tqc = (qc & (int)(0xffffffff)) + ((qc & (0x7fffffff00000000)) >> 32);\n\tqc = (qc & (int)(0xffffffff)) + ((qc & (int)(0x100000000)) >> 32);\n\tqc = (qc & (0xffff)) + ((qc & (int)(0xffff0000)) >> 16);\n\tqc = (qc & (0xffff)) + ((qc & (0x10000)) >> 16);\n\tqc = (qc & (0xff)) + ((qc & (0xff00)) >> 8);\n\tqc = (qc & (0xff)) + ((qc & (0x100)) >> 8);\n\tqc = (qc & (0xf)) + ((qc & (0xf0)) >> 4);\n\tqc = (qc & (0xf)) + ((qc & (0x10)) >> 4);\n\tqc = (qc & 3) + ((qc & 12) >> 2);\n\tqc = (qc & 3) + ((qc & 4) >> 2);\n      assert(qc>3)\n\t\tc ^= qc;\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 17.01.2020 01:59:15       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<long long> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n  }\n  auto IsSubset = [&](long long a, long long b) {\n    return ((a & b) == a);\n  };\n  auto Get = [&](long long X, long long Y) {\n    int z = 0;\n    for (int i = 0; i < n; i++) {\n      if (X >= x[i]) {\n        z ^= IsSubset(X - x[i], y[i] - Y);\n      }\n    }\n    return z % 2;\n  };\n  auto AddSubsets = [&](vector<long long>& p, long long a, long long b) {\n    a += 1;\n    int shift = 0;\n    for (int bit = 61; bit >= 0; bit--) {\n      if (a & (1LL << bit)) {\n        // 1 0 0\n        // 1 1 0\n        // 1 0 1\n        // 0 1 1\n        // 1 1 0\n        // ...\n        int cc = __builtin_popcountll(b & ~(1LL << bit));\n        if (cc == 0) {\n          p[shift] ^= 1;\n        } else {\n          int t = (shift + (cc % 3 == 2 ? 2 : (1 - cc % 3))) % 3;\n          p[t] ^= 1;\n          p[(t + 1) % 3] ^= 1;\n        }\n        shift = (shift + 1) % 3;\n        if (!(b & (1LL << bit))) {\n          break;\n        }\n      }\n      b &= ~(1LL << bit);\n    }\n  };\n  auto Get3 = [&](long long X, long long Y) {\n    vector<long long> ret(3);\n    for (int i = 0; i < n; i++) {\n      if (X >= x[i]) {\n        AddSubsets(ret, X - x[i], y[i] - Y);\n      }\n    }\n    return ret;\n  };\n  const long long inf = (long long) 5e17;\n  long long Y = -inf / 2;\n  long long low = -inf, high = inf;\n  while (low < high) {\n    long long mid = low + ((high - low) >> 1);\n    auto ret = Get3(mid, Y);\n    if (ret[0] + ret[1] + ret[2] == 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  long long X = low;\n  assert(Get(X, Y) == 1);\n  for (int bit = 0; bit < 60; bit++) {\n    if (Get(X - (1LL << bit), Y)) {\n      X -= 1LL << bit;\n    }\n  }\n  long long minX = X;\n  for (int bit = 0; bit < 60; bit++) {\n    if (Get(X + (1LL << bit), Y)) {\n      X += 1LL << bit;\n    }\n  }\n  long long maxX = X;\n  cout << minX << \" \" << Y + (maxX - minX) << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = 2 * x.first + x.second+1;\n      \tqc = (qc & (int)(0xffffffff)) + ((qc & (0x7fffffff00000000)) >> 32);\n\tqc = (qc & (int)(0xffffffff)) + ((qc & (int)(0x100000000)) >> 32);\n\tqc = (qc & (0xffff)) + ((qc & (int)(0xffff0000)) >> 16);\n\tqc = (qc & (0xffff)) + ((qc & (0x10000)) >> 16);\n\tqc = (qc & (0xff)) + ((qc & (0xff00)) >> 8);\n\tqc = (qc & (0xff)) + ((qc & (0x100)) >> 8);\n\tqc = (qc & (0xf)) + ((qc & (0xf0)) >> 4);\n\tqc = (qc & (0xf)) + ((qc & (0x10)) >> 4);\n\tqc = (qc & 3) + ((qc & 12) >> 2);\n\tqc = (qc & 3) + ((qc & 4) >> 2);\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n      \tw++;\n      \tif ((w & x.first) == w) { d ^= 1; }\n\t}\n  \tans.first *= 2; ans.second *= 2;\n\tans.first+=(c|d); ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "%:pragma GCC optimize(\"Ofast\", \"inline\")\n#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\n  using namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\n#define int long long\nconst int N = 1e5 + 233;\nint inf = 1e17;\nint n, x[N], y[N], qy, ni[N];\nbool dp[65][2][3];\n\ninline bool get(int u, int n, int r) {\n  memset(dp, 0, sizeof dp);\n  int l = n - y[u];\n  l = min(l, ni[u]);\n  r = ((r - y[u]) % 3 + 3) % 3;\n  if (l < 0) return 0;\n  // o \\in[0, l] && o % 3 == r ni[u]Co module 2\n  // cout << l << \" \" << ni[u] << \" \" << r << \"\\n\";\n  dp[0][1][0] = 1; int cur = 0;\n  for (int i = 61; i >= 0; i--) {\n    ++cur;\n    for (int d = 0; d < 2; d++) {\n      for (int pr = 0; pr < 3; pr++) {\n\tint lim = d ? l >> i & 1 : 1;\n\tfor (int ch = 0; ch <= min(ni[u] >> i & 1, lim); ch++) {\n\t  int nd = d && ch == lim;\n\t  int nv = pr + (i & 1 ? -1 : 1) * ch;\n\t  nv = (nv % 3 + 3) % 3;\n\t  // if (i == 2 && d == 1 && pr == 0) {\n\t  //   cout << ch << \" \" << nd << \" \" << nv << \"\\n\";\n\t  // }\n\t  dp[cur][nd][nv] ^= dp[cur - 1][d][pr];\n\t}\n      }\n    }\n  }\n  int ans = 0;\n  for (int d = 0; d < 2; d++)\n    ans ^= dp[cur][d][r];\n  return ans;\n}\n\ninline bool calc(int l, int r, int remain) {\n  bool ans = 0;\n  rep (i, n) {\n    ans ^= get(i, r, remain) ^ get(i, l - 1, remain);\n    // cout << i << \" \" << get(i, r, remain) << \" \" <<  get(i, l - 1, remain) << \"\\n\";\n  }\n  return ans;\n}\n\nsigned main(void) {\n  srand(20021214);\n  read(n);\n  rep (i, n) {\n    read(x[i]), read(y[i]);\n    // mi_i = o - y_i\n  }\n  // cout << get(1, 4, 1) << \"\\n\";\n  // return 0;\n  // cout << calc(-4, 4, 1) << \"\\n\";\n  // return 0;\n  int tr = -1;\n  while (tr == -1) {\n    inf += rand() % 3;\n    rep (i, n) ni[i] = x[i] + inf;\n    re0 (r, 3) if (calc(-inf, inf, r) == true) {\n      tr = r;\n      break;\n    }\n  }\n  assert(calc(-inf, inf, tr) == true);\n  \n  int l = -inf, r = inf;\n  while (l < r) {\n    int mid = l + (r - l) / 2;\n    if (calc(l, mid, tr)) r = mid;\n    else l = mid + 1;\n  }\n  qy = r;\n  \n  auto isBlack = [&](int o) {\n    bool pa = 0;\n    rep (i, n) if (y[i] <= o && o <= x[i] + y[i] + inf) {\n      int nc = x[i] + inf;\n      int mc = o - y[i];\n      pa ^= nc == (nc | mc);\n    }\n    return pa;\n  };\n  assert(isBlack(qy) == true);\n  \n  int ty = qy, ansl, ansr;\n  \n  for (int k = 61; k >= 0; k--) {\n    if (isBlack(qy + (1ll << k))) {\n      qy += 1ll << k;\n    }\n  }\n  ansr = qy;\n  \n  qy = ty;\n  for (int k = 61; k >= 0; k--) {\n    if (isBlack(qy - (1ll << k))) {\n      qy -= 1ll << k;\n    }\n  }\n  ansl = qy;\n\n  cout << -inf + ansr - ansl << \" \" << ansl << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint main()\n{\n    int N; cin>>N;\n    vector<long long> x(N), y(N);\n    for (int i=0; i<N; i++)\n        cin>>x[i]>>y[i];\n\n    //  https://img.atcoder.jp/wtf19-open/editorial.pdf\n\n    //  x[i], y[i] >= 0 とする\n    long long base = 1LL<<58;\n    for (int i=0; i<N; i++)\n    {\n        x[i] += base;\n        y[i] += base;\n    }\n\n    //  直線 y = 0 上のランプのみが点灯するようにしたときに、\n    //  x < n, x%3 == r を満たすxについて、 \n    //  (x, 0) の点灯しているランプの個数が奇数となるか\n    auto count = [&](long long n, long long r) -> bool\n    {\n        bool ret = false;\n        for (int i=0; i<N; i++)\n        {\n            if (n <= x[i])\n                continue;\n\n            long long m = n - x[i] - 1;\n            //  [k][r]: k桁以下を比較したときにm以下\n            long long A[61][3] = {};\n            //  [k][r]: 任意\n            long long B[61][3] = {};\n\n            //  0\n            A[0][0] = 1LL;\n            B[0][0] = 1LL;\n            //  1\n            if (y[i]&1)\n            {\n                if (m&1)\n                    A[0][1] = 1LL;\n                B[0][1] = 1LL;\n            }\n\n            for (int k=1; k<=60; k++)\n                for (int pr=0; pr<3; pr++)\n                {\n                    //  0\n                    A[k][pr] += m>>k&1 ? B[k-1][pr] : A[k-1][pr];\n                    B[k][pr] += B[k-1][pr];\n                    //  1\n                    if (y[i]>>k&1)\n                    {\n                        long long cr = (pr + (1LL<<k)) % 3;\n                        if (m>>k&1)\n                            A[k][cr] += A[k-1][pr];\n                        B[k][cr] += B[k-1][pr];\n                    }\n                }\n\n            if (A[60][((r-x[i])%3+3)%3]%2 != 0)\n                ret = !ret;\n        }\n        return ret;\n    };\n\n    //  y = 0 の直線上のランプのみが点灯するようにしたときに、\n    //  (p, 0)が点灯しているか\n    auto check = [&](long long p) -> bool\n    {\n        bool ret = false;\n        for (int i=0; i<N; i++)\n            if ((~y[i] & (p-x[i])) == 0)\n                ret = !ret;\n        return ret;\n    };\n\n    long long r3;\n    for (r3=0LL; r3<3LL; r3++)\n        if (count(1LL<<60, r3))\n            break;\n    assert(r3<3LL);\n\n    long long l = 0;\n    long long r = 1LL<<60;\n    while (r-l > 1LL)\n    {\n        long long m = (l+r)/2;\n        if (count(l, r3) == count(m, r3))\n            l = m;\n        else\n            r = m;\n    }\n\n    long long t = l;\n    for (int k=60; k>=0; k--)\n        if (check(l-(1LL<<k)))\n            l -= 1LL<<k;\n    r = t;\n    for (int k=60; k>=0; k--)\n        if (check(r+(1LL<<k)))\n            r += 1LL<<k;\n\n    long long ansx = l-base;\n    long long ansy = (r-l)-base;\n\n    cout<<ansx<<\" \"<<ansy<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n  \tc=0;\n  \tfor (pin& x : qab[1]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n  \tif (!c) {\n\t\tans.first *= 2; ans.second *= 2;\n\t\treturn ans;\n\t}\n\tc = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second-1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t}\n\tans.first *= 2; ans.first++; ans.second *= 2; ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  qab[0].reserve(10000);\n  qab[1].reserve(10000);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\tV<V<bool>> c(2, V<bool>(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc+1)%2) { c[i][0]=!c[i][0]; }\n\t\t\tif (qc) { c[i][1]!=c[i][1]; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0]&&!c[1-i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1, 0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc + 1) % 2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0] && !c[1 - i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor (pin& v : ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nint readint() {\n\tchar c = getchar_unlocked();\n\tint res = 0;\n\twhile ('0' <= c && c <= '9') {\n\t\tres = res * 10 + c - '0';\n\t\tc = getchar_unlocked();\n\t}\n\treturn res;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; n = readint();\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; a = readint(); b = readint();\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nconst ll C = -ll(1e18);\n\nvector<ii> vec;\n\nint color(ll x, ll y)\n{\n\tint ans=0;\n\tint n=vec.size();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll x2=vec[i].fi; ll y2=vec[i].se+C;\n\t\tll d = x-x2;\n\t\tll h = y2-y;\n\t\tif(d<0||d>h) continue;\n\t\tif((d&h)==d) ans^=1;\n\t}\n\treturn ans;\n}\n\nint md[63];\n\nll getbelow(ll r, int mod)\n{\n\tint res[3]; memset(res,0,sizeof(res));\n\tfor(ii pt:vec)\n\t{\n\t\tll x=pt.fi; ll y=pt.se;\n\t\tif(x>r) continue;\n\t\tll mx = r-x;\n\t\t//cerr<<mx<<' '<<y<<'\\n';\n\t\tint dp[2][3];\n\t\tmemset(dp,0,sizeof(dp));\n\t\tint xmod=x%3;\n\t\tif(xmod<0) xmod+=3;\n\t\tdp[1][0]=1;\n\t\tfor(int i=62;i>=0;i--)\n\t\t{\n\t\t\tint nw[2][3]; memset(nw,0,sizeof(nw));\n\t\t\tfor(int k=0;k<2;k++) //1 if still a prefix of mx\n\t\t\t{\n\t\t\t\tfor(int l=0;l<3;l++) //mod\n\t\t\t\t{\n\t\t\t\t\tif(!dp[k][l]) continue;\n\t\t\t\t\t//add 1\n\t\t\t\t\t{\n\t\t\t\t\t\tif(y&(1LL<<i))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(k==1&&(!mx&(1LL<<i)))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint newk=0;\n\t\t\t\t\t\t\t\tif(k==1&&(mx&(1LL<<i))) newk=1;\n\t\t\t\t\t\t\t\tint newl=(l+md[i])%3;\n\t\t\t\t\t\t\t\tnw[newk][newl]^=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//add 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint newk=0;\n\t\t\t\t\t\tif(k==1&&!(mx&(1LL<<i))) newk=1;\n\t\t\t\t\t\tint newl=l;\n\t\t\t\t\t\tnw[newk][newl]^=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=0;k<2;k++) //1 if still a prefix of mx\n\t\t\t{\n\t\t\t\tfor(int l=0;l<3;l++) //mod\n\t\t\t\t{\n\t\t\t\t\tdp[k][l]=nw[k][l];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int l=0;l<3;l++)\n\t\t{\n\t\t\tint nwmod=(xmod+l)%3;\n\t\t\tint as=(dp[0][l]^dp[1][l]);\n\t\t\tres[nwmod]^=as;\n\t\t}\n\t}\n\treturn res[mod];\n}\n\nll getcount(ll l, ll r, int mod) //%3 = mod\n{\n\treturn getbelow(r,mod)-getbelow(l-1,mod);\n}\n\nconst int DEBUG=0;\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tfor(int i=0;i<63;i++) md[i]=((1LL<<i))%3;\n\tif(DEBUG)\n\t{\n\t\tll x=ll(1e13)+10210210210LL; ll y=-ll(1e17);\n\t\tset<ii> S; S.insert({x,y});\n\t\tfor(int op=0;op<1000;op++)\n\t\t{\n\t\t\tll x=(*S.begin()).fi; ll y=(*S.begin()).se;\n\t\t\tS.erase({x,y});\n\t\t\tif(rand()&1)\n\t\t\t{\n\t\t\t\tif(S.find({x+1,y})==S.end()) S.insert({x+1,y});\n\t\t\t\telse S.erase({x+1,y});\n\t\t\t\tif(S.find({x,y+1})==S.end()) S.insert({x,y+1});\n\t\t\t\telse S.erase({x,y+1});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(S.find({x-1,y})==S.end()) S.insert({x-1,y});\n\t\t\t\telse S.erase({x-1,y});\n\t\t\t\tif(S.find({x-1,y+1})==S.end()) S.insert({x-1,y+1});\n\t\t\t\telse S.erase({x-1,y+1});\n\t\t\t}\n\t\t}\n\t\tfor(ii pr:S) vec.pb(pr);\n\t}\n\telse\n\t{\n\t\tint n; cin>>n;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tll x,y; cin>>x>>y; vec.pb({x,y});\n\t\t}\n\t}\n\tfor(int i=0;i<vec.size();i++) vec[i].se-=C;\n\tint mod=-1;\n\tfor(int i=0;i<3;i++)\n\t{\n\t\t//cerr<<getcount(-ll(2e18),ll(2e18),i)<<'\\n';\n\t\tif(getcount(-ll(2e18),ll(2e18),i)){mod=i; break;}\n\t}\n\tassert(mod!=-1);\n\tll lo=-ll(2e18); ll hi=ll(2e18);\n\twhile(lo<hi)\n\t{\n\t\tll mid=(lo+hi)>>1;\n\t\tif(getcount(lo,mid,mod))\n\t\t{\n\t\t\thi=mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlo=mid+1;\n\t\t}\n\t}\n\tll cur = lo;\n\tfor(int i=62;i>=0;i--)\n\t{\n\t\tif(color(cur-(1LL<<i),C)) cur-=(1LL<<i);\n\t}\n\tll x = cur;\n\tfor(int i=62;i>=0;i--)\n\t{\n\t\tif(color(cur+(1LL<<i),C)) cur+=(1LL<<i);\n\t}\n\tll y = (cur-x)+C;\n\tcout<<x<<' '<<y<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n  \tc=0;\n  \tfor (pin& x : qab[1]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n  \tif (!c) {\n\t\tans.first *= 2; ans.second *= 2;\n\t\treturn ans;\n\t}\n\tc = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second-1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t}\n\tans.first *= 2; ans.first++; ans.second *= 2; ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long long\n#define W V<L>\n#define R(n) for(L i=0;i<n;i++)\nW S(V<W>&p,L E){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=(Q+1);}if(!c){W A=S(T[i],E-1);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p,E);A[0]--;return A;}\nL main(){L M=2e17;L n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}W Q=S(p,70);cout<<Q[0]-M<<\" \"<<Q[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;#define V vector\n#define L long long\n#define W V<L>\n#define R(n) for(L i=0;i<n;i++)\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define W V<long long>\n#defien L long long\n#define R(n) for(L i=0;i<n;i++)\nW S(V<W>&p,L E){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}V<W>c(3,W(2));R(2){for(W x:T[i]){L Q=(2*x[0]+x[1])%3;if((Q+1)%2){c[i][0]^=1;}if(Q){c[i][1]^=1;}}}R(2){if(c[1-i]==c[2]){W ans=S(T[i],E-1);ans[0]*=2;ans[1]*=2;ans[1]+=i;return ans;}}for(W&v:p){v[0]++;}W A=S(p,E);A[0]--;return A;}\nint main(){L M=2e17;L n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}W Q=S(p,70);cout<<Q[0]-M<<\" \"<<Q[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n      \tint qc=2*x.first+x.second+1;\n\tqc = (qc & (0xffffffff)) + ((qc & (0x3fffffff00000000)) >> 32);\n\tqc = (qc & (0xffffffff)) + ((qc & (0x100000000)) >> 32);\n\tqc = (qc & (0xffff)) + ((qc & (0xffff0000)) >> 16);\n\tqc = (qc & (0xffff)) + ((qc & (0x10000)) >> 16);\n\tqc = (qc & (0xff)) + ((qc & (0xff00)) >> 8);\n\tqc = (qc & (0xff)) + ((qc & (0x100)) >> 8);\n\tqc = (qc & (0xf)) + ((qc & (0xf0)) >> 4);\n\tqc = (qc & (0xf)) + ((qc & (0x10)) >> 4);\n\tqc = (qc & 3) + ((qc & 12) >> 2);\n\tqc = (qc & 3) + ((qc & 4) >> 2);\n\t\tc ^= qc;\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 10000 + 10;\n//const int DEBUG = 0;\n\nint n;\nstruct anode{\n\tll x, y;\n\tanode() {}\n\tanode(ll _x, ll _y):x(_x), y(_y) {}\n}a[maxn];\nll c, Ans1, Ans2;\nll f[3][2], g[3][2];\n\nint dp(ll n, ll m, ll res) {\n\tif(m < 0) return 0;\n\tmemset(f,0,sizeof(f));\n\tf[0][1] = 1;\n\tfor(int i = 60;i >= 0;i --) {\n\t\tmemset(g,0,sizeof(g));\n\t\tint m1 = (m >> i) & 1, n1 = (n >> i) & 1;\n\t\tfor(int j = 0;j < 3;j ++) {\n\t\t\tint nj = (j + (1LL << i) % 3) % 3;\n\t\t\t(m1) ? (g[j][0] += f[j][1],((n1) ? (g[nj][1] += f[j][1],0) : (0)),0) : (g[j][1] += f[j][1],0);\n\t\t\t(n1) ? (g[nj][0] += f[j][0],0) : (0);\n\t\t\tg[j][0] += f[j][0];\n\t\t\t/*\n\t\t\tif(m1) {\n\t\t\t\tg[j][0] += f[j][1];\n\t\t\t\tif(n1) g[nj][1] += f[j][1];\n\t\t\t}\n\t\t\telse g[j][1] += f[j][1];\n\t\t\tg[j][0] += f[j][0];\n\t\t\tif(n1) g[nj][0] += f[j][0];\n\t\t\t*/\n\t\t\t/*\n\t\t\tif(n1 && m1) g[nj][1] += f[j][1];\n\t\t\tif(n1) g[nj][0] += f[j][0];\n\t\t\tif(m1) g[j][0] += f[j][1];\n\t\t\telse g[j][1] += f[j][1];\n\t\t\tg[j][0] += f[j][0];\n\t\t\t*/\n\t\t}\n\t\tmemcpy(f,g,sizeof(f));\n\t}\n\tll tmp = (ll)(f[res][0] + f[res][1]) % 2;\n\treturn tmp;\n}\n\ninline ll get(ll n, ll l, ll r, ll res) {\n\tll t1 = dp(n,r,res);\n\tll t2 = dp(n,l - 1,res);\n\tll tmp = (t1 % 2 - t2 % 2) % 2;\n\treturn tmp;\n}\n\ninline ll get_val(ll l, ll r, ll res) {\n\tll tmp = 0;\n\tfor(int i = 1;i <= n;i ++) {\n\t\tll tl = l - a[i].x, tr = r - a[i].x, ts = (res % 3 - a[i].x % 3 + 3) % 3;\n    ll now = get(c - a[i].x - a[i].y,tl,tr,ts);\n\t\ttmp = (tmp + now) % 2;\n\t}\n\treturn tmp;\n}\n\ninline bool check(ll l, ll r) {\n\tint flag = 0;\n\tfor(int i = 0;i < 3;i ++) {\n\t\tif(get_val(l,r,i)) {\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn flag;\n}\n\ninline ll work1() {\n\tll l = - 1e17, r = 1e17;\n\twhile(l < r) {\n//\t\tif(DEBUG) printf(\"%lld %lld\\n\", l, r);\n    ll mid = (l + r) >> 1;\n\t\tif(check(l,mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\treturn l;\n}\n\ninline ll C(ll n, ll m) { return (n & m) == m; }\n\ninline bool light(ll x) {\n\tll tmp = 0;\n\tfor(int i = 1;i <= n;i ++) {\n\t\tif(a[i].x > x) continue;\n\t\ttmp = (tmp + C(c - a[i].x - a[i].y,x - a[i].x)) % 2;\n\t}\n\treturn tmp;\n}\n\ninline void work2(ll pos) {\n\tll l = pos, r = pos;\n  for(ll i = 60;i >= 0;i --) {\n\t\tif(light(l - (1LL << i))) l -= (1LL << i);\n\t\tif(light(r + (1LL << i))) r += (1LL << i);\n\t}\n\tAns1 = l, Ans2 = c - r;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n\tfor(int i = 1;i <= n;i ++) scanf(\"%lld%lld\\n\", &a[i].x, &a[i].y);\n  c = 2e17;\n\tll pos = work1();\n//\tif(DEBUG) cout << light(pos) << endl;\n\twork2(pos);\n\tprintf(\"%lld %lld\\n\", Ans1, Ans2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n      \tint qc=2*x.first+x.second;\n        qc=(qc&(0xffffffff))+((qc&(0xffffffff00000000))>>32);\n      \tqc=(qc&(0xffff))+((qc&(0xffff0000))>>16);\n      \tqc=(qc&(0xff))+((qc&(0xff00))>>8);\n      \tqc=(qc&(0xf))+((qc&(0xf0))>>4);\n      \tqc=(qc&3)+((qc&12)>>2);\n      \tqc=(qc&3)+((qc&12)>>2);\n        qc=(qc&3)+((qc&12)>>2);\n        qc=(qc&3)+((qc&12)>>2);\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70,M=2e17,i,a,b;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}i=2;while(i--){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){cin>>i;V<W>p(i);while(i--){cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n      \tw++;\n      \tif ((w & x.first) == w) { d ^= 1; }\n\t}\n  \tans.first *= 2; ans.second *= 2;\n\tif (!c&&!d) {\n\t\treturn ans;\n\t}\n\tans.first+=(c|d); ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n\ntypedef long long ll;\n\nconst ll MOD = 1e9+7;\nconst ll INF = 1e9+5;\n\nmap <int, int> X, Y;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i=0 ; i<n ; i++) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\tX[x]++;\n\t\tY[y]++;\n\t}\n\tint solx, soly;\n\tfor (auto &x:X) {\n\t\tif (x.y % 2) {\n\t\t\tsolx = x.x;\n\t\t\tbreak;\n\t\t}\n\t\tX[x.x+1] += (x.y)/2;\n\t}\n\tfor (auto &y:Y) {\n\t\tif (y.y % 2) {\n\t\t\tsoly = y.x;\n\t\t\tbreak;\n\t\t}\n\t\tY[y.x+1] += (y.y)/2;\n\t}\n\tprintf(\"%d %d\\n\", solx, soly);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing ll = long long;\nconstexpr ll off = 1ll << 58;\nint n, dp[2][3], nxt[2][3];\nll x[100005], y[100005];\ninline bool solve(ll sum, int rem)\n{\n\tbool res = false;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (y[i] >= sum)\n\t\t\tcontinue;\n\t\tll lim = sum - y[i];\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tdp[0][j] = dp[1][j] = 0;\n\t\tdp[0][0] = 1;\n\t\tfor (int j = 60; j >= 0; j--)\n\t\t{\n\t\t\tfor (int k = 0; k < 3; k++)\n\t\t\t\tnxt[0][k] = nxt[1][k] = 0;\n\t\t\tfor (int a = 0; a < 2; a++)\n\t\t\t{\n\t\t\t\tint mx = x[i] >> j & 1;\n\t\t\t\tif (!a && !(lim >> j & 1))\n\t\t\t\t\tmx = 0;\n\t\t\t\tfor (int b = 0; b < 3; b++)\n\t\t\t\t{\n\t\t\t\t\tif (!dp[a][b])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int t = 0; t <= mx; t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint k = (b + t * ((j & 1) + 1)) % 3;\n\t\t\t\t\t\tnxt[a || t != (lim >> j & 1)][k] ^= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < 3; k++)\n\t\t\t{\n\t\t\t\tdp[0][k] = nxt[0][k];\n\t\t\t\tdp[1][k] = nxt[1][k];\n\t\t\t}\n\t\t}\n\t\tres ^= dp[1][(rem - y[i] % 3 + 3) % 3];\n\t}\n\treturn res;\n}\ninline bool calc(ll pos)\n{\n\tbool res = false;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tll cur = pos - y[i];\n\t\tif (cur >= 0 && cur <= x[i] && (x[i] & cur) == cur)\n\t\t\tres ^= 1;\n\t}\n\treturn res;\n}\nint main()\n{\n\t// freopen(\"C.in\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%lld%lld\", x + i, y + i);\n\t\tx[i] += off;\n\t\ty[i] += off;\n\t}\n\tint rem = 0;\n\twhile (!solve(1ll << 60, rem))\n\t\trem++;\n\tll pos = 0;\n\tfor (int i = 60; i >= 0; i--)\n\t{\n\t\tif (solve(pos, rem) == solve(pos + (1ll << i), rem))\n\t\t\tpos += 1ll << i;\n\t}\n\tll l = pos, r = pos;\n\tfor (int i = 60; i >= 0; i--)\n\t{\n\t\tif (calc(l - (1ll << i)))\n\t\t\tl -= 1ll << i;\n\t\tif (calc(r + (1ll << i)))\n\t\t\tr += 1ll << i;\n\t}\n\tprintf(\"%lld %lld\\n\", r - l - off, l - off);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, lint>;\nconst int MAXN = 10005;\nconst lint inf = 1e17;\n\nint n; \npi a[MAXN], b[MAXN];\nint dp[61][3][2];\n\nbool query(lint l, int m){ \n\tl = 3 * l + m;\n\t// less than l, mod m, how much have xor 1\n\tbool ans = 0;\n\tfor(int i=0; i<n; i++){\n\t\tlint x = l - a[i].first;\n\t\tlint y = a[i].second;\n\t\tif(x <= 0) continue;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][m][0] = 1;\n\t\tfor(int j=1; j<=60; j++){\n\t\t\tbool hasbit = (y >> (j - 1)) & 1;\n\t\t\tfor(int k=0; k<3; k++){\n\t\t\t\tdp[j][k][0] = dp[j-1][k][0] + hasbit * dp[j-1][(k + (1ll<<(j-1)))%3][0];\n\t\t\t\tif((x >> (j-1)) & 1){\n\t\t\t\t\tdp[j][k][1] = dp[j-1][k][0] + hasbit * dp[j-1][(k + (1ll<<(j-1)))%3][1];\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[j][k][1] = dp[j-1][k][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans ^= dp[60][0][1];\n\t}\n\treturn ans;\n}\n\npi get_coord(){\n\tlint s = 0, e = (1ll << 58);\n\tint i = 0;\n\twhile(i < 3 && query(s, i) == query(e, i)) i++;\n\tfor(int it=0; it<58; it++){\n\t\tlint m = (s+e)/2;\n\t\tif(query(s, i) != query(m, i)) e = m;\n\t\telse s = m;\n\t}\n\treturn pi(s * 3 + i, 0);\n}\n\nbool on(lint x, lint y){\n\tbool ans = 0;\n\tfor(int i=0; i<n; i++){\n\t\tlint px = x - a[i].first;\n\t\tlint py = a[i].second - y;\n\t\tif(py >= 0 && px >= 0 && (px & py) == px) ans ^= 1;\n\t}\n\treturn ans;\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0; i<n; i++){\n\t\tscanf(\"%lld %lld\",&a[i].first,&a[i].second);\n\t\ta[i].first += inf;\n\t\ta[i].second += inf;\n\t}\n\tpi p = get_coord();\n\tfor(int i=59; i>=0; i--){\n\t\tif(on(p.first - (1ll << i), p.second)) p.first -= (1ll << i);\n\t}\n\tlint x = p.first;\n\tlint y = p.second;\n\tfor(int i=59; i>=0; i--){\n\t\tif(on(p.first + (1ll << i), p.second)){\n\t\t\tp.first += (1ll << i);\n\t\t\ty += (1ll << i);\n\t\t}\n\t}\n\tprintf(\"%lld %lld\\n\", x-inf, y-inf);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cmath>\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <set>\n#include <map>\n#include <list>\n#include <time.h>\n#include <math.h>\n#include <random>\n#include <deque>\n#include <queue>\n#include <cassert>\n#include <unordered_map>\n#include <unordered_set>\n#include <iomanip>\n#include <bitset>\n#include <sstream>\n#include <chrono>\n#include <cstring>\n\nusing namespace std;\n\ntypedef long long ll;\n\n#ifdef iq\n  mt19937 rnd(228);\n#else\n  mt19937 rnd(chrono::high_resolution_clock::now().time_since_epoch().count());\n#endif\n\nconst ll L = 2e17;\n\nint dp[70][3][2][2];\n\nint main() {\n#ifdef iq\n  freopen(\"a.in\", \"r\", stdin);\n#endif\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector <ll> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n  }\n  auto chet = [&] (ll x, ll y, ll a, ll b) {\n    if (x > a || y > b) {\n      return false;\n    }\n    ll n = L - x - y;\n    ll m = b - y;\n    return ((n & m) == m);\n  };\n  auto get_bin = [&] (ll x) {\n    string s = \"\";\n    for (int i = 0; i < 60; i++) {\n      s += (x % 2);\n      x /= 2;\n    }\n    reverse(s.begin(), s.end());\n    return s;\n  };\n  auto get_ans = [&] (ll a, ll l, ll r) {\n    string n = get_bin(a);\n    string vl = get_bin(l);\n    string vr = get_bin(r);\n    /*\n    cout << n << endl;\n    cout << vl << endl;\n    cout << vr << endl;\n    exit(0);\n    */\n    for (int i = 0; i <= 60; i++) {\n      for (int j = 0; j < 3; j++) {\n        for (int x = 0; x < 2; x++) {\n          for (int y = 0; y < 2; y++) {\n            dp[i][j][x][y] = 0;\n          }\n        }\n      }\n    }\n    dp[0][0][0][0] = 1;\n    for (int i = 0; i < 60; i++) {\n      for (int j = 0; j < 3; j++) {\n        for (int x = 0; x < 2; x++) {\n          for (int y = 0; y < 2; y++) {\n            for (int dig = 0; dig < 2; dig++) {\n              if (!x && dig < vl[i]) {\n                continue;\n              }\n              if (!y && dig > vr[i]) {\n                continue;\n              }\n              if (n[i] == 0 && dig) continue;\n              int nx = (x | (dig > vl[i]));\n              int ny = (y | (dig < vr[i]));\n              int nj = (2 * j + dig) % 3;\n              dp[i + 1][nj][nx][ny] ^= dp[i][j][x][y];\n            }\n          }\n        }\n      }\n    }\n    vector <int> ret(3);\n    for (int t = 0; t < 3; t++) {\n      int kek = 0;\n      for (int a = 0; a < 2; a++) {\n        for (int b = 0; b < 2; b++) {\n          kek ^= dp[60][t][a][b];\n        }\n      }\n      ret[t] = kek;\n    }\n    return ret;\n  };\n  ll vl = -2 * L, vr = 2 * L;\n  ll cur_l = -2 * L, cur_r = 2 * L;\n  auto check = [&] (ll t) {\n    vector <int> s(3);\n    for (int i = 0; i < n; i++) {\n      ll a = L - x[i] - y[i];\n      ll vl = 0;\n      ll vr = t - y[i];\n      vl = max(vl, cur_l - y[i]);\n      vr = min(vr, cur_r - y[i]);\n      if (vl > vr) continue;\n      auto ret = get_ans(a, vl, vr);\n      int kek = y[i] % 3;\n      if (kek < 0) kek += 3;\n      for (int i = 0; i < 3; i++) {\n        s[(i + kek) % 3] ^= ret[i];\n      }\n    }\n    return s[0] || s[1] || s[2];\n  };\n  while (vl < vr) {\n    cur_l = vl, cur_r = vr;\n    ll vm = (vl + vr) >> 1;\n    if (check(vm)) {\n      vr = vm;\n    } else {\n      vl = vm + 1;\n    }\n  }\n  {\n    auto f = [&] (ll t) {\n      ll ret = 0;\n      for (int i = 0; i < n; i++) {\n        ret ^= chet(x[i], y[i], L - t, t);\n      }\n      return ret;\n    };\n    if (f(cur_l)) vr = cur_l;\n    if (f(cur_r)) vr = cur_r;\n    assert(f(vr));\n    for (int k = 60; k >= 0; k--) {\n      if (f(vr - (1ll << k))) {\n        vr -= (1ll << k);\n      }\n    }\n    ll y = vr;\n    ll vl = y;\n    for (int k = 60; k >= 0; k--) {\n      if (f(y + (1ll << k))) {\n        y += (1ll << k);\n      }\n    }\n    vr = y;\n    ll ans = (vr - vl) - L + vl;\n    cout << -ans << ' ' << vl << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll inf = 1e17 + 2;\nconst int N = 1e4 + 10;\n\nint pos;\n\nvector<int> operator ^ (vector<int> a, vector<int> b) {\n  vector<int> c(3);\n  for(int i = 0; i < 3; i++) {\n    c[i] = a[i] ^ b[i];\n  }\n  return c;\n}\n\nll f[60][2][3];\n\nvector<int> calc(ll n, ll r, ll x) {\n  vector<int> cur(3);\n  if(r < 0) {\n    return cur;\n  }\n  memset(f, 0, sizeof f);\n  f[59][1][0] = 1;\n  for(int i = 58; ~i; i--) {\n    for(int j = 0; j < 3; j++) {\n      if(f[i + 1][0][j]) {\n\tf[i][0][(j << 1) % 3] ^= 1;\n\tif(n >> i & 1) {\n\t  f[i][0][((j << 1) | 1) % 3] ^= 1;\n\t}\n      }\n      if(f[i + 1][1][j]) {\n\tif(r >> i & 1) {\n\t  f[i][0][(j << 1) % 3] ^= 1;\n\t  if(n >> i & 1) {\n\t    f[i][1][(j << 1 | 1) % 3] ^= 1;\n\t  }\n\t} else {\n\t  f[i][1][(j << 1) % 3] ^= 1;\n\t}\n      }\n    }\n  }\n  x = (x % 3 + 3) % 3;\n  for(int i = 0; i < 3; i++) {\n    cur[(x + i) % 3] = f[0][0][i] ^ f[0][1][i];\n  }\n  return cur;\n}\n\nint n;\nll x[N], y[N];\n\nbool check(ll lim) {\n  vector<int> ans(3);\n  for(int i = 1; i <= n; i++) {\n    ans = ans ^ calc(y[i] + inf, lim - x[i], x[i]);\n  }\n  return ans[pos];\n}\n\nbool lightnow(ll x, ll y) {\n  if(y < 0 || y > x) {\n    return 0;\n  }\n  return (x & y) == y;\n}\n\nll limit(ll cur, ll op) {\n  for(int i = 59; ~i; i--) {\n    bool light = false;\n    ll tmp = cur + (op << i);\n    for(int j = 1; j <= n; j++) {\n      light ^= lightnow(y[j] + inf, tmp - x[j]);\n    }\n    if(light) {\n      cur = tmp;\n    }\n  }\n  return cur;\n}\n\nint main(void) {\n  scanf(\"%d\", &n);\n  pos = 0;\n  for(int i = 1; i <= n; i++) {\n    scanf(\"%lld%lld\", &x[i], &y[i]);\n    pos ^= ((x[i] + inf) > 1 && (x[i] + inf) % 3);\n  }\n  ll l = -inf * 10, r = inf * 10;\n  while(l < r) {\n    ll mid = l + r >> 1;\n    if(check(mid)) {\n      r = mid;\n    } else {\n      l = mid + 1;\n    }\n  }\n  long long ansl = limit(l, -1), ansr = limit(l, 1);\n  cout << ansl << \" \" << ansr - ansl - inf << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\nvel solve(V<vel>& ab, int ex) {\n\tif (ex == 0) { return { 1, 0 }; }\n\tV<V<vel>> qab(2);\n\tfor (vel x : ab) {\n\t\tint a1 = x[0];\n\t\tint b1 = x[1];\n\t\tqab[x[1] & 1].push_back({ x[0] / 2,x[1] / 2 });\n\t\tif (x[0] & 1) { qab[(x[1] + 1) & 1].push_back({ x[0] / 2,(x[1] + 1) / 2 }); }\n\t}\n\tV<vel> c(3,vel(2));\n\trep(i, 2) {\n\t\tfor (auto x : qab[i]) {\n\t\t\tint qc = (3 - x[0] + x[1]) % 3; qc = (qc + 3) % 3;\n\t\t\tif (qc == 0) { c[i][0] ^= 1; }\n\t\t\tif (qc == 1) { c[i][1] ^= 1; }\n\t\t\tif (qc == 2) { c[i][0] ^= 1; c[i][1] ^= 1; }\n\t\t}\n\t}\n\tif (c[0] == c[2]) {\n\t\tvel ans = solve(qab[1], ex - 1);\n\t\tans[0] *= 2; ans[1] *= 2;ans[1]++;\n\t\treturn ans;\n\t}\n\tif (c[1] == c[2]) {\n\t\tvel ans = solve(qab[0], ex - 1);\n\t\tans[0] *= 2; ans[1] *= 2;\n\t\treturn ans;\n\t}\n\trep(i, ab.size()) { ab[i][0]++; }\n\tvel ans = solve(ab, ex); ans[0]--;\n\treturn ans;\n}\nsigned main() {\n\tint inf = 2e17;\n\tint n; cin >> n;\n\tV<vel> ab(n);\n\trep(i, n) {\n\t\tint a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tvel ret = solve(ab, 70);\n\tcout << ret[0] - inf << \" \" << ret[1] - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1, 0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc + 1) % 2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0] && !c[1 - i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor (pin& v : ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nint readint() {\n\tint res = 0;\n\tchar c = getchar();\n\tif ('0' <= c && c <= '9') {\n\t\twhile ('0' <= c && c <= '9') {\n\t\t\tres = res * 10 + c - '0';\n\t\t\tc = getchar();\n\t\t}\n\t}\n\telse {\n\t\tc = getchar();\n\t\twhile ('0' <= c && c <= '9') {\n\t\t\tres = res * 10 + c - '0';\n\t\t\tc = getchar();\n\t\t}\n\t\tres *= -1;\n\t}\n\treturn res;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n = readint();\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; a = readint(); b = readint();\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\nvel solve(V<vel>& ab, int ex) {\n\tif (ex == 0) { return { 1, 0 }; }\n\tV<vel> ab0, ab1;\n\tfor (auto x : ab) {\n\t\tint a1 = x[0];\n\t\tint b1 = x[1];\n\t\tif (b1 % 2 == 0) {\n\t\t\tab0.push_back({ a1 / 2, b1 / 2 });\n\t\t\tif (a1 % 2 == 1) { ab1.push_back({ a1 / 2, b1 / 2 }); }\n\t\t}\n\t\telse {\n\t\t\tab1.push_back({ a1 / 2, b1 / 2 });\n\t\t\tif (a1 % 2 == 1) { ab0.push_back({ a1 / 2, (b1 + 1) / 2 }); }\n\t\t}\n\t}\n\tvel c0(2), c1(2);\n\tfor (auto x : ab0) {\n\t\tint qc = (3 - x[0] + x[1]) % 3;\n\t\tif (qc == 0) { c0[0] ^= 1; }\n\t\tif (qc == 1) { c0[1] ^= 1; }\n\t\tif (qc == 2) { c0[0] ^= 1; c0[1] ^= 1; }\n\t}\n\tfor (auto x : ab1) {\n\t\tint qc = (3 - x[0] + x[1]) % 3;\n\t\tif (qc == 0) { c1[0] ^= 1; }\n\t\tif (qc == 1) { c1[1] ^= 1; }\n\t\tif (qc == 2) { c1[0] ^= 1; c1[1] ^= 1; }\n\t}\n\tvel ze(2, 0);\n\tif (c0 == ze) {\n\t\tvel ans = solve(ab1, ex - 1);\n\t\tans[0] *= 2; ans[1] *= 2;ans[1]++;\n\t\treturn ans;\n\t}\n\tif (c1 == ze) {\n\t\tvel ans = solve(ab0, ex - 1);\n\t\tans[0] *= 2; ans[1] *= 2;\n\t\treturn ans;\n\t}\n\trep(i, ab.size()) { ab[i][0]++; }\n\tvel ans = solve(ab, ex); ans[0]--;\n\treturn ans;\n}\nsigned main() {\n\tint inf = 1;\n\trep(i, 57) { inf *= 2; }\n\tint n; cin >> n;\n\tV<vel> ab(n);\n\trep(i, n) {\n\t\tint a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tvel ret = solve(ab, 70);\n\tcout << ret[0] - inf << \" \" << ret[1] - inf << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nVPII lamps;\n//int C;\n// VI Xor(VI L, VI R) {\n//   REP (tr, SZ(L)) {\n//     L[tr] ^= R[tr];\n//   }\n//   return L;\n// }\nint Shift(int heh, int shift) {\n  if (heh == 7) { return heh; }\n  if (heh == 0) { return heh; }\n  shift %= 3;\n  heh *= (1 << shift);\n  return heh % 7;\n//   VI dupa(SZ(heh));\n//   REP (i, SZ(heh)) {\n//     dupa[(i + shift) % SZ(heh)] = heh[i];\n//   }\n//   return dupa;\n}\nint CountLamps1(int kInf, int e, int x, int y) {\n  //debug(kInf, e, x, y);\n  int d = kInf - x - y;\n  if (e < y) {\n    return 0; //{0, 0, 0};\n  }\n  VI bits;\n  REP (bit, 60) {\n    if (d & (1ll << bit)) {\n      bits.PB(1);\n    } else {\n      bits.PB(0);\n    }\n  }\n  vector<int> prefs{1};\n  //prefs.PB({1, 0, 0});\n  REP (bit, 60) {\n    if (!bits[bit]) {\n      prefs.PB(prefs.back());\n    } else if (bit % 2) {\n      prefs.PB(prefs.back() ^ Shift(prefs.back(), 2));\n    } else {\n      prefs.PB(prefs.back() ^ Shift(prefs.back(), 1));\n    }\n  }\n  int maxY = kInf - x;\n  if (e >= maxY) {  return Shift(prefs.back(), (y % 3 + 3) % 3); }\n  int shift = 0;\n  int how_many = e - y + 1;\n  //debug(how_many);\n  int so_far = 0;;\n  FORD (bit, 59, 0) {\n    if (how_many & (1ll << bit)) {\n      //debug(prefs[bit], shift % 3);\n      so_far = so_far ^ Shift(prefs[bit], shift);\n      \n      if (bits[bit]) {\n        shift += (1ll << bit);\n        shift %= 3;\n      } else {\n        break;\n      }\n    }\n  }\n  //debug(so_far);\n  return Shift(so_far, (y % 3 + 3) % 3);\n}\nint CountLampsAll(int kInf, int e) {\n  int hehs = 0;\n  for (auto lamp : lamps) {\n    int lul = CountLamps1(kInf, e, lamp.st, lamp.nd);\n    hehs = hehs ^ lul;\n  }\n  return hehs;\n}\nint CountLampsAll(int kInf, int b, int e) {\n  return CountLampsAll(kInf, e) ^ CountLampsAll(kInf, b - 1);\n}\nint IsLit(int x, int y) {\n  int heh = 0;\n  for (auto lamp : lamps) {\n    int d = x + y - lamp.st - lamp.nd;\n    if (lamp.nd > y) { continue; }\n    if (lamp.st > x) { continue; }\n    int ind = y - lamp.nd;\n    if ((ind & d) == ind) {\n      heh ^= 1;\n    }\n  }\n  return heh;\n}\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n\n//   kInf = 1;\n//   debug(CountLamps1(1, 0, 0));\n  //kInf = 5;\n  //debug(CountLamps1(5, 0, 0));\n  //debug(CountLamps1(4, 0, 0));\n//   debug(CountLamps1(3, 0, 0));\n//   kInf = 6;\n//   debug(CountLamps1(6, 0, 0));\n//   debug(CountLamps1(5, 0, 0));\n//   debug(CountLamps1(4, 0, 0));\n  \n  \n  \n  \n  const int kInf = 4e17;\n  \n  int n;\n  cin>>n;\n  RE (i, n) {\n    int x, y;\n    cin>>x>>y;\n    //maxi(C, x + y);\n    lamps.PB({x, y});\n  }\n  int hehs = CountLampsAll(kInf, kInf);\n  if (hehs == 0) { cout<<\"DUPA\"<<endl; return 0; }\n//   int r;\n//   REP (tr, 3) {\n//     if (hehs & (1 << bit)) { r = tr; }\n//   }\n  int kl = -kInf, kp = 2 * kInf;\n  //VI zeros{0, 0, 0};\n  //assert(CountLampsAll(kInf, kl, kp) != zeros);\n  while (kl != kp) {\n    if (kl == kp) { break; }\n    int aktc = (kl + kp) >> 1;\n    //assert(CountLampsAll(kInf, kl, kp) == Xor(CountLampsAll(kInf, kl, aktc), CountLampsAll(kInf, aktc + 1, kp)));\n    if (CountLampsAll(kInf, kl, aktc)) {\n      kp = aktc;\n    } else {\n      kl = aktc + 1;\n    }\n  }\n  //debug(CountLampsAll(kInf, kl, kl), kl, kl % 3);\n  assert(IsLit(kInf - kl, kl));\n  int L = kl, R = kl;\n  FORD (bit, 60, 0) {\n    int candL = L - (1ll << bit);\n    //debug(L & (1ll << bit), bit); \n    if (IsLit(kInf - candL, candL)) {\n      //debug(\"dol\");\n      L = candL;\n    }\n    int candR = R + (1ll << bit);\n    if (IsLit(kInf - candR, candR)) {\n      R = candR;\n    }\n  }\n  // R to maxy, L to miny\n  int X = kInf - R;\n  int Y = L;\n  cout<<X<<\" \"<<Y<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll base = 1ll << 58;\nconst int LOG = 60;\nint main() {\n  do {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n  } while (false);\n  int n;\n  cin >> n;\n  vector<ll> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n    x[i] += base;\n    y[i] += base;\n  }\n  auto calc = [&] (ll sum, int r) {\n    bool res = false;\n    for (int i = 0; i < n; i++) {\n      if (y[i] < sum) {\n        ll limit = sum - y[i];\n        vector<bool> F(3), G(3);\n        F[0] = true;\n        for (int j = LOG; j >= 0; j--) {\n          vector<bool> F2(3), G2(3);\n          for (int k = 0; k < 3; k++) {\n            if (F[k]) {\n              for (int v = 0; v <= min(limit >> j & 1, x[i] >> j & 1); v++) {\n                int nxt = (k + v * (j & 1) + v) % 3;\n                if (v != (limit >> j & 1)) {\n                  G2[nxt].flip();\n                } else {\n                  F2[nxt].flip();\n                }\n              }\n            }\n            if (G[k]) {\n              for (int v = 0; v <= (x[i] >> j & 1); v++) {\n                int nxt = (k + v * (j & 1) + v) % 3;\n                G2[nxt].flip();\n              }\n            }\n          }\n          F = F2;\n          G = G2;\n        }\n        res ^= G[(r - y[i] % 3 + 3) % 3];\n      }\n    }\n    return res;\n  };\n  int r = 0;\n  while (!calc(1ll << LOG, r)) {\n    r++;\n  }\n  ll start = 0;\n  for (int i = LOG; i >= 0; i--) {\n    if (calc(start, r) == calc(start + (1ll << i), r)) {\n      start |= 1ll << i;\n    }\n  }\n  return 0;\n  auto check = [&] (ll pos) {\n    bool res = false;\n    for (int i = 0; i < n; i++) {\n      if (y[i] <= pos && pos <= x[i] + y[i] && (x[i] & (pos - y[i])) == pos - y[i]) {\n        res ^= 1;\n      }\n    }\n    return res;\n  };\n  ll L = start, R = start;\n  for (int i = LOG; i >= 0; i--) {\n    if (check(L - (1ll << i))) {\n      L -= 1ll << i;\n    }\n    if (check(R + (1ll << i))) {\n      R += 1ll << i;\n    }\n  }\n  cout << R - L - base << \" \" << L - base << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin &x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n  vel c(2);\n\trep(i, 2) {\n\t\tfor (pin &x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second)%3;\n          c[i]^=(qc+1);\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <ctype.h>\n#include <algorithm>\n#include <fstream>\n#include <climits>\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef pair<int, LL> pil;\n\nconst LL INF = 2e17 + 7;\nconst int Bit = 60;\nconst int MAXN = 1e4 + 7;\n\ninline void proc_status() {\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline T read() {\n\tT res = 0, flag = 1; char in = getchar();\n\twhile(!isdigit(in)) { if(in == '-') flag = -1; in = getchar(); }\n\twhile(isdigit(in)) { res = (res << 1) + (res << 3) + in - '0'; in = getchar(); }\n\treturn res * flag;\n}\n\ntemplate<typename T> inline void chkmax(T &a, T b) { if(a < b) a = b; }\ntemplate<typename T> inline void chkmin(T &a, T b) { if(a > b) a = b; }\n\nLL by;\nLL S, L, R;\nint mul[Bit + 1];\n\nint dfs(int k, int rest, bool bl, bool br) {\n\tif(k == -1) {\n\t\treturn rest == 0;\n\t}\n\tint res = 0;\n\tint l = 0, r = 1;\n\tif(bl) l = (L >> k) & 1;\n\tif(br) r = (R >> k) & 1;\n\tfor(int i = l; i <= r; ++i) {\n\t\tif(!((S >> k) & 1) && i) continue;\n\t\tres ^= dfs(k - 1, (rest - i * mul[k] + 3) % 3, bl && (i == l), br && (i == r));\n\t}\n\treturn res;\n}\n\ninline int Val(int res, LL a, LL b, LL l, LL r) {\n\tchkmax(l, a); chkmin(r, a + b);\n\tif(l > r) return 0;\n\tl -= a; r -= a; b -= by;\n\tL = l; R = r; S = b;\n\treturn dfs(Bit, res, 1, 1);\n}\n\nint n;\npll p[MAXN];\n\ninline bool IsOdd(LL l, LL r) {\n\tfor(int i = 0; i < 3; ++i) {\n\t\tint res = 0;\n\t\tfor(int j = 1; j <= n; ++j) \n\t\t\tres ^= Val(i, p[j].x, p[j].y, l, r);\n\t\tif(res) return 1;\n\t}\n\treturn 0;\n}\n\ninline LL GetSt(LL l, LL r) {\n\twhile(1) {\n\t\tLL mid = l + r >> 1;\n\t\tif(IsOdd(l, mid)) r = mid;\n\t\telse l = mid + 1;\n\t\tif(l == r) return l;\n\t}\n}\n\nLL st;\n\ninline void init() {\n\tmul[0] = 1;\n\tfor(int i = 1; i <= Bit; ++i) mul[i] = mul[i - 1] * 2 % 3;\n\tn = read<int>();\n\tby = LLONG_MAX;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tp[i].x = read<LL>();\n\t\tchkmin(by, p[i].y = read<LL>());\n\t}\n\tfor(int i = 1; i <= n; ++i) p[i].y = p[i].y - by;\n\tst = GetSt(-INF, INF);\n//\tprintf(\"%lld\\n\", by);\n}\n\ninline int Val(LL x) {\n\tint res = 0;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tif(x < p[i].x) continue;\n\t\tif(x > p[i].x + p[i].y) continue;\n\t\tint tx = x - p[i].x;\n\t\tres ^= ((tx & p[i].y) == tx);\n//\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn res;\n}\n\ninline void solve() {\n//\tcout << Val(1) << endl;\n//\tcout << endl;\n//\texit(0);\n\tLL ed = st;\n\n\tfor(int i = Bit; i >= 0; --i) {\n\t\tif(Val(ed + (1ll << i))) {\n//\t\t\texit(0);\n\t\t\ted += (1ll << i);\n\t\t}\n\t}\n\n//\tcout << st << ' ' << ed << endl;\n//\texit(0);\n\n\tfor(int i = Bit; i >= 0; --i) {\n\t\tif(Val(st - (1ll << i))) {\n\t\t\tst -= (1ll << i);\n\t\t}\n\t}\n//\texit(0);\n\tprintf(\"%lld %lld\\n\", st, by + ed - st);\n}\n\nint main() {\n#ifndef ONLINE_JUDGE\n\tfreopen(\"ATWTF19C.in\", \"r\", stdin);\n\tfreopen(\"ATWTF19C.out\", \"w\", stdout);\n#endif\n\n\tinit();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  qab[0].reserve(10000);\n  qab[1].reserve(10000);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\tV<V<bool>> c(2, V<bool>(2,false));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc+1)%2) { c[i][0]=!c[i][0]; }\n\t\t\tif (qc) { c[i][1]=!c[i][1]; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0]&&!c[1-i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n      \tint qc=2*x.first+x.second;\n        qc=(qc&(0xffffffff))+((qc&(0xfffffff00000000))>>32);\n      \tqc=(qc&(0xffff))+((qc&(0xffff0000))>>16);\n      \tqc=(qc&(0xff))+((qc&(0xff00))>>8);\n      \tqc=(qc&(0xf))+((qc&(0xf0))>>4);\n      \tqc=(qc&3)+((qc&12)>>2);\n      \tqc=(qc&3)+((qc&12)>>2);\n        qc=(qc&3)+((qc&12)>>2);\n        qc=(qc&3)+((qc&12)>>2);\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\nclass Solver {\n public:\n  int n;\n  vector<LL> x, y;\n  LL N = (1ll << 58);\n  vector<vector<vector<int>>> dp_;\n  Solver(LL n) : n(n), x(n), y(n), dp_(61, vector<vector<int>>(3, vector<int>(2))){};\n  bool isOdd(LL a, LL b) {\n    if (a < b) return false;\n    if (b < 0) return false;\n    return (a - b) == (a ^ b);\n  }\n  int coeffMod2(LL X) {\n    int ret = 0;\n    for (int i = 0; i < n; ++i) {\n      ret += isOdd(y[i] + N, X - x[i]);\n    }\n    DBG(X, ret % 2)\n    return ret % 2;\n  }\n\n  vector<int> countBlackMod2(LL h, LL w) {\n    //(0,0)の黒い点を直線y=-h上に移したとき、{(x,-h) | x∈[0,w], x=c (mod 3) } となる黒い点の個数\n    if (w < 0) return {0, 0, 0};\n    w = min(w, h);\n    //dp[i][j][k] : 上からi桁がmod 3でjに等しい数の個数　k=1ならばw以下であることが確定\n    auto dp = [&](int a, int b, int c) -> int& { return dp_[a + 1][b][c]; };\n    for (int i = 0; i < 61; ++i) {\n      for (int j = 0; j < 3; ++j) {\n        for (int k = 0; k < 2; ++k) {\n          dp_[i][j][k] = 0;\n        }\n      }\n    }\n    dp(-1, 0, 0) = 1;\n    for (int i = 0; i < 60; ++i) {\n      if ((w >> (59 - i)) & 1) {\n        for (int j = 0; j < 3; ++j) {\n          if ((h >> (59 - i)) & 1) dp(i, (j + 1 + (59 - i) % 2) % 3, 0) += dp(i - 1, j, 0);\n          dp(i, j, 1) += dp(i - 1, j, 0);\n          if ((h >> (59 - i)) & 1) dp(i, (j + 1 + (59 - i) % 2) % 3, 1) += dp(i - 1, j, 1);\n          dp(i, j, 1) += dp(i - 1, j, 1);\n        }\n\n      } else {\n        for (int j = 0; j < 3; ++j) {\n          //dp(i, (j + 1 + (59 - i) % 2) % 3, 0) += dp(i - 1, j, 0);\n          dp(i, j, 0) += dp(i - 1, j, 0);\n          if ((h >> (59 - i)) & 1) dp(i, (j + 1 + (59 - i) % 2) % 3, 1) += dp(i - 1, j, 1);\n          dp(i, j, 1) += dp(i - 1, j, 1);\n        }\n      }\n      for (int j = 0; j < 3; ++j) {\n        for (int k = 0; k < 2; ++k) {\n          dp(i, j, k) &= 1;\n        }\n      }\n    }\n    vector<int> ret(3);\n    for (int i = 0; i < 3; ++i) {\n      ret[i] = dp(59, i, 0) + dp(59, i, 1);\n    }\n    return ret;\n  }\n\n  int countBrackInRange(LL a, LL b, int c) {\n    DBG(a, b, c)\n    //{(x,-h) | x∈[a,b-1], x=c (mod 3) } となる黒い点の個数(mod 2)\n    int ret = 0;\n    for (int i = 0; i < n; ++i) {\n      ret += countBlackMod2(y[i] + N, b - 1 - x[i])[((c - x[i]) % 3 + 3) % 3];\n    }\n    DBG(ret)\n    for (int i = 0; i < n; ++i) {\n      ret -= countBlackMod2(y[i] + N, a - 1 - x[i])[((c - x[i]) % 3 + 3) % 3];\n    }\n    DBG(ret)\n    ret = ret & 1;\n    return ret;\n  }\n\n  void solve() {\n    for (int i = 0; i < n; ++i) {\n      cin >> x[i] >> y[i];\n    }\n    vector<int> sum(3);\n    for (int j = 0; j < n; ++j) {\n      auto res = countBlackMod2(y[j] + N, y[j] + N);\n      DBG(res)\n      for (int i = 0; i < 3; ++i) {\n        sum[((x[j] + i) % 3 + 3) % 3] += res[i];\n      }\n    }\n\n    //個数が奇数になるグループを探す\n    int r;\n    for (int i = 0; i < 3; ++i) {\n      if (sum[i] % 2) {\n        r = i;\n        break;\n      }\n    }\n    DBG(r, sum)\n    //二分探索\n    //[lb,ub)に黒い点が奇数個あるようにする\n    LL lb = -(1ll << 57), ub = (1ll << 59);\n    while (ub - lb > 1) {\n      DBG(lb, ub, N - 1)\n      LL mid = (lb + ub) / 2;\n      if (countBrackInRange(lb, mid, r) % 2) {\n        ub = mid;\n      } else {\n        lb = mid;\n      }\n    }\n\n    //黒い点を1つ見つけた\n    LL ny = -N, nx = lb;\n    DBG(nx, ny + N)\n    LL ansl = nx, ansr = nx;\n    DBG(coeffMod2(ansl))\n    //y=-N上でx座標を動かして、y=-N上で最も左・最も右の黒い点を探す\n    while (true) {\n      bool fin = true;\n      for (int i = 60 - 1; i >= 0; --i) {\n        if (coeffMod2(ansl - (1ll << i))) {\n          fin = false;\n          ansl -= (1ll << i);\n          break;\n        }\n      }\n      DBG(ansl, fin)\n      if (fin) break;\n    }\n    while (true) {\n      bool fin = true;\n      for (int i = 60 - 1; i >= 0; --i) {\n        if (coeffMod2(ansr + (1ll << i))) {\n          fin = false;\n          ansr += (1ll << i);\n          break;\n        }\n      }\n      DBG(ansr)\n      if (fin) break;\n    }\n\n    cout << ansl << ' ' << -N + (ansr - ansl) << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  long long n = 0;\n  std::cin >> n;\n\n  Problem::Solver sol(n);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nconst ll inf = 1e17 + 2;\nconst int N = 1e4 + 10;\n\nint pos;\n\nvector<int> operator ^ (vector<int> a, vector<int> b) {\n  vector<int> c(3);\n  for(int i = 0; i < 3; i++) {\n    c[i] = a[i] ^ b[i];\n  }\n  return c;\n}\n\nll f[62][2][3];\n\nvector<int> calc(ll n, ll r, ll x) {\n  vector<int> cur(3);\n  if(r < 0) {\n    return cur;\n  }\n  memset(f, 0, sizeof f);\n  f[60][1][0] = 1;\n  for(int i = 59; ~i; i--) {\n    for(int j = 0; j < 3; j++) {\n      if(f[i + 1][0][j]) {\n\tf[i][0][(j << 1) % 3] ^= 1;\n\tif(n >> i & 1) {\n\t  f[i][0][((j << 1) | 1) % 3] ^= 1;\n\t}\n      }\n      if(f[i + 1][1][j]) {\n\tif(r >> i & 1) {\n\t  f[i][0][(j << 1) % 3] ^= 1;\n\t  if(n >> i & 1) {\n\t    f[i][1][(j << 1 | 1) % 3] ^= 1;\n\t  }\n\t} else {\n\t  f[i][1][(j << 1) % 3] ^= 1;\n\t}\n      }\n    }\n  }\n  x = (x % 3 + 3) % 3;\n  for(int i = 0; i < 3; i++) {\n    cur[(x + i) % 3] = f[0][0][i] ^ f[0][1][i];\n  }\n  return cur;\n}\n\nint n;\nll x[N], y[N];\n\nbool check(ll lim) {\n  vector<int> ans(3);\n  for(int i = 1; i <= n; i++) {\n    ans = ans ^ calc(y[i] + inf, lim - x[i], x[i]);\n  }\n  return ans[pos];\n}\n\nbool lightnow(ll x, ll y) {\n  if(y < 0 || y > x) {\n    return 0;\n  }\n  return (x & y) == y;\n}\n\nll limit(ll cur, ll op) {\n  for(int i = 60; ~i; i--) {\n    bool light = false;\n    ll tmp = cur + (op << i);\n    for(int j = 1; j <= n; j++) {\n      light ^= lightnow(y[j] + inf, tmp - x[j]);\n    }\n    if(light) {\n      cur = tmp;\n    }\n  }\n  return cur;\n}\n\nint main(void) {\n  scanf(\"%d\", &n);\n  vector<int> cur(3);\n  for(int i = 1; i <= n; i++) {\n    scanf(\"%lld%lld\", &x[i], &y[i]);\n    cur = cur ^ calc(y[i] + inf, y[i] + inf, x[i]);\n  }\n  for(; !cur[pos]; pos++);\n  ll l = -inf * 10, r = inf * 10;\n  while(l < r) {\n    ll mid = l + r >> 1;\n    if(check(mid)) {\n      r = mid;\n    } else {\n      l = mid + 1;\n    }\n  }\n  long long ansl = limit(l, -1), ansr = limit(l, 1);\n  cout << ansl << \" \" << ansr - ansl - inf << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}for(int i;i<2;i++){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n,a,b;cin>>n;V<W>p(n);for(int i;i<n;i++){cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n  int sz0=qab[0].size();\n  int sz1=qab[1].size();\n  if(sz0>=sz1){return solve(qab[0],ex-1);}\n  else{return solve(qab[1],ex-1);}\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V vector\n#define W V<long>\nusing namespace std;long E,M=2e17,a,b;W A,x;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].push_back({x[0]/2,++x[1]/2});}for(long i;i<2;i++){a=0;for(x:T[!i])a^=(2*x[0]+x[1])%3+1;if(!a){E--;A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;A=S(p);A[0]--;return A;}int main(){cin>>E;V<W>p(E);while(E--,cin>>a>>b)p[E]={a+M,b+M};E=70;A=S(p);cout<<A[0]-M<<\" \"<<A[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\n  template<class T> void ResizeVec(T&, vector<int>) {}\n  template<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n    vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n    for (T& v : vec) { ResizeVec(v, sz); }\n  }\n  typedef Triple<int, int, int> TIII;\n  template<class A, class B, class C>\n  ostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\n  template<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n  template<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n  template<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n  \n  VPII lamps;\n  //int C;\n  // VI Xor(VI L, VI R) {\n  //   REP (tr, SZ(L)) {\n  //     L[tr] ^= R[tr];\n  //   }\n  //   return L;\n  // }\n  int Shift(int heh, int shift) {\n    if (heh == 7) { return heh; }\n    if (heh == 0) { return heh; }\n    shift %= 3;\n    heh *= (1 << shift);\n    return heh % 7;\n    //   VI dupa(SZ(heh));\n    //   REP (i, SZ(heh)) {\n    //     dupa[(i + shift) % SZ(heh)] = heh[i];\n    //   }\n    //   return dupa;\n  }\n  int CountLamps1(int kInf, int e, int x, int y) {\n    //debug(kInf, e, x, y);\n    int d = kInf - x - y;\n    if (e < y) {\n      return 0; //{0, 0, 0};\n    }\n    VI bits;\n    REP (bit, 60) {\n      if (d & (1ll << bit)) {\n        bits.PB(1);\n      } else {\n        bits.PB(0);\n      }\n    }\n    vector<int> prefs{1};\n    //prefs.PB({1, 0, 0});\n    REP (bit, 60) {\n      if (!bits[bit]) {\n        prefs.PB(prefs.back());\n      } else if (bit % 2) {\n        prefs.PB(prefs.back() ^ Shift(prefs.back(), 2));\n      } else {\n        prefs.PB(prefs.back() ^ Shift(prefs.back(), 1));\n      }\n    }\n    int maxY = kInf - x;\n    if (e >= maxY) {  return Shift(prefs.back(), (y % 3 + 3) % 3); }\n    int shift = 0;\n    int how_many = e - y + 1;\n    //debug(how_many);\n    int so_far = 0;;\n    FORD (bit, 59, 0) {\n      if (how_many & (1ll << bit)) {\n        //debug(prefs[bit], shift % 3);\n        so_far = so_far ^ Shift(prefs[bit], shift);\n        \n        if (bits[bit]) {\n          shift += (1ll << bit);\n          shift %= 3;\n        } else {\n          break;\n        }\n      }\n    }\n    //debug(so_far);\n    return Shift(so_far, (y % 3 + 3) % 3);\n  }\n  int CountLampsAll(int kInf, int e) {\n    int hehs = 0;\n    for (auto lamp : lamps) {\n      int lul = CountLamps1(kInf, e, lamp.st, lamp.nd);\n      hehs = hehs ^ lul;\n    }\n    return hehs;\n  }\n  int CountLampsAll(int kInf, int b, int e) {\n    return CountLampsAll(kInf, e) ^ CountLampsAll(kInf, b - 1);\n  }\n  int IsLit(int x, int y) {\n    int heh = 0;\n    for (auto lamp : lamps) {\n      int d = x + y - lamp.st - lamp.nd;\n      if (lamp.nd > y) { continue; }\n      if (lamp.st > x) { continue; }\n      int ind = y - lamp.nd;\n      if ((ind & d) == ind) {\n        heh ^= 1;\n      }\n    }\n    return heh;\n  }\n  int32_t main() {\n    \n    ios_base::sync_with_stdio(0);\n    cout << fixed << setprecision(10);\n    cerr << fixed << setprecision(10);\n    cin.tie(0);\n    //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n    \n    //   kInf = 1;\n    //   debug(CountLamps1(1, 0, 0));\n    //kInf = 5;\n    //debug(CountLamps1(5, 0, 0));\n    //debug(CountLamps1(4, 0, 0));\n    //   debug(CountLamps1(3, 0, 0));\n    //   kInf = 6;\n    //   debug(CountLamps1(6, 0, 0));\n    //   debug(CountLamps1(5, 0, 0));\n    //   debug(CountLamps1(4, 0, 0));\n    \n    \n    \n    \n    const int kInf = 4e17;\n    \n    int n;\n    cin>>n;\n    RE (i, n) {\n      int x, y;\n      cin>>x>>y;\n      //maxi(C, x + y);\n      lamps.PB({x, y});\n    }\n//     int hehs = CountLampsAll(kInf, kInf);\n//     if (hehs == 0) { cout<<\"DUPA\"<<endl; return 0; }\n    //   int r;\n    //   REP (tr, 3) {\n    //     if (hehs & (1 << bit)) { r = tr; }\n    //   }\n    int kl = -kInf, kp = 2 * kInf;\n    //VI zeros{0, 0, 0};\n    //assert(CountLampsAll(kInf, kl, kp) != zeros);\n    while (kl != kp) {\n      if (kl == kp) { break; }\n      int aktc = (kl + kp) >> 1;\n      //assert(CountLampsAll(kInf, kl, kp) == Xor(CountLampsAll(kInf, kl, aktc), CountLampsAll(kInf, aktc + 1, kp)));\n      if (CountLampsAll(kInf, kl, aktc)) {\n        kp = aktc;\n      } else {\n        kl = aktc + 1;\n      }\n    }\n    //debug(CountLampsAll(kInf, kl, kl), kl, kl % 3);\n    assert(IsLit(kInf - kl, kl));\n    int L = kl, R = kl;\n    FORD (bit, 60, 0) {\n      int candL = L - (1ll << bit);\n      //debug(L & (1ll << bit), bit); \n      if (IsLit(kInf - candL, candL)) {\n        //debug(\"dol\");\n        L = candL;\n      }\n      int candR = R + (1ll << bit);\n      if (IsLit(kInf - candR, candR)) {\n        R = candR;\n      }\n    }\n    // R to maxy, L to miny\n    int X = kInf - R;\n    int Y = L;\n    cout<<X<<\" \"<<Y<<endl;\n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    \n    return 0;\n  }\n  "
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}for(L i;i<2;i++){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n,a,b;cin>>n;V<W>p(n);for(L i;i<n;i++){cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nVPII lamps;\n//int C;\n// VI Xor(VI L, VI R) {\n//   REP (tr, SZ(L)) {\n//     L[tr] ^= R[tr];\n//   }\n//   return L;\n// }\nint Shift(int heh, int shift) {\n  if (heh == 7) { return heh; }\n  if (heh == 0) { return heh; }\n  shift %= 3;\n  heh *= (1 << shift);\n  return heh % 7;\n//   VI dupa(SZ(heh));\n//   REP (i, SZ(heh)) {\n//     dupa[(i + shift) % SZ(heh)] = heh[i];\n//   }\n//   return dupa;\n}\nint CountLamps1(int kInf, int e, int x, int y) {\n  //debug(kInf, e, x, y);\n  int d = kInf - x - y;\n  if (e < y) {\n    return 0; //{0, 0, 0};\n  }\n  VI bits;\n  REP (bit, 60) {\n    if (d & (1ll << bit)) {\n      bits.PB(1);\n    } else {\n      bits.PB(0);\n    }\n  }\n  vector<int> prefs{1};\n  //prefs.PB({1, 0, 0});\n  REP (bit, 60) {\n    if (!bits[bit]) {\n      prefs.PB(prefs.back());\n    } else if (bit % 2) {\n      prefs.PB(prefs.back() ^ Shift(prefs.back(), 2));\n    } else {\n      prefs.PB(prefs.back() ^ Shift(prefs.back(), 1));\n    }\n  }\n  int maxY = kInf - x;\n  if (e >= maxY) {  return Shift(prefs.back(), (y % 3 + 3) % 3); }\n  int shift = 0;\n  int how_many = e - y + 1;\n  //debug(how_many);\n  int so_far = 0;;\n  FORD (bit, 59, 0) {\n    if (how_many & (1ll << bit)) {\n      //debug(prefs[bit], shift % 3);\n      so_far = so_far ^ Shift(prefs[bit], shift);\n      \n      if (bits[bit]) {\n        shift += (1ll << bit);\n        shift %= 3;\n      } else {\n        break;\n      }\n    }\n  }\n  //debug(so_far);\n  return Shift(so_far, (y % 3 + 3) % 3);\n}\nint CountLampsAll(int kInf, int e) {\n  int hehs = 0;\n  for (auto lamp : lamps) {\n    int lul = CountLamps1(kInf, e, lamp.st, lamp.nd);\n    hehs = hehs ^ lul;\n  }\n  return hehs;\n}\nint CountLampsAll(int kInf, int b, int e) {\n  return CountLampsAll(kInf, e) ^ CountLampsAll(kInf, b - 1);\n}\nint IsLit(int x, int y) {\n  int heh = 0;\n  for (auto lamp : lamps) {\n    int d = x + y - lamp.st - lamp.nd;\n    if (lamp.nd > y) { continue; }\n    if (lamp.st > x) { continue; }\n    int ind = y - lamp.nd;\n    if ((ind & d) == ind) {\n      heh ^= 1;\n    }\n  }\n  return heh;\n}\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n\n//   kInf = 1;\n//   debug(CountLamps1(1, 0, 0));\n  //kInf = 5;\n  //debug(CountLamps1(5, 0, 0));\n  //debug(CountLamps1(4, 0, 0));\n//   debug(CountLamps1(3, 0, 0));\n//   kInf = 6;\n//   debug(CountLamps1(6, 0, 0));\n//   debug(CountLamps1(5, 0, 0));\n//   debug(CountLamps1(4, 0, 0));\n  \n  \n  \n  \n  const int kInf = 4e17;\n  \n  int n;\n  cin>>n;\n  RE (i, n) {\n    int x, y;\n    cin>>x>>y;\n    //maxi(C, x + y);\n    lamps.PB({x, y});\n  }\n  int hehs = CountLampsAll(kInf, kInf);\n  if (hehs == 0) { cout<<\"DUPA\"<<endl; return 0; }\n//   int r;\n//   REP (tr, 3) {\n//     if (hehs & (1 << bit)) { r = tr; }\n//   }\n  int kl = -kInf, kp = 2 * kInf;\n  //VI zeros{0, 0, 0};\n  //assert(CountLampsAll(kInf, kl, kp) != zeros);\n  while (kl + 5 < kp) {\n    if (kl == kp) { break; }\n    int aktc = (kl + kp) / 2;\n    //assert(CountLampsAll(kInf, kl, kp) == Xor(CountLampsAll(kInf, kl, aktc), CountLampsAll(kInf, aktc + 1, kp)));\n    if (CountLampsAll(kInf, kl, aktc)) {\n      kp = aktc;\n    } else {\n      kl = aktc + 1;\n    }\n  }\n  FOR (i, kl, kp) {\n    if (IsLit(kInf - i, i)) {\n      kl = i;\n      break;\n    }\n  }\n  //debug(CountLampsAll(kInf, kl, kl), kl, kl % 3);\n  assert(IsLit(kInf - kl, kl));\n  int L = kl, R = kl;\n  FORD (bit, 60, 0) {\n    int candL = L - (1ll << bit);\n    //debug(L & (1ll << bit), bit); \n    if (IsLit(kInf - candL, candL)) {\n      //debug(\"dol\");\n      L = candL;\n    }\n    int candR = R + (1ll << bit);\n    if (IsLit(kInf - candR, candR)) {\n      R = candR;\n    }\n  }\n  // R to maxy, L to miny\n  int X = kInf - R;\n  int Y = L;\n  cout<<X<<\" \"<<Y<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70,M=2e17,a,b,n,i;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}i=2;while(i--){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){cin>>n;V<W>p(n);while(n--){cin>>a>>b;p[n]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst long long infll = (long long) 1.01e18;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\n#ifdef DEBUG\nmt19937 mrand(300); \n#else\nmt19937 mrand(chrono::steady_clock::now().time_since_epoch().count()); \n#endif\n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nconst int maxn = (int) 1e4 + 5;\nint n;\nlong long ps[maxn][2];\n\nbool read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return false;\n  }\n  for (int i = 0; i < n; i++) {\n    for (int j = 0; j < 2; j++) {\n      scanf(\"%lld\", &ps[i][j]);\n    }\n  }\n  return true;\n}\n\nset<pair<long long, long long>> st;\n\nvoid flip(const pair<long long, long long> &p) {\n  auto it = st.lower_bound(p);\n  if (it != st.end() && *it == p) {\n    st.erase(it);\n  } else {\n    st.insert(it, p);\n  }\n}\n\nlong long solve1() {\n  st.clear();\n  for (int i = 0; i < n; i++) {\n    st.insert(make_pair(ps[i][0], ps[i][1]));\n  }\n  while (true) {\n    assert(!st.empty());\n    auto p = *st.begin();\n    st.erase(st.begin());\n    if (st.empty()) {\n      return p.first;\n    }\n    auto q = *st.begin();\n    st.erase(st.begin());\n    if (q.first != p.first) {\n      return p.first;\n    }\n    long long x = p.first;\n    long long y = p.second;\n    long long d = q.second - p.second;\n    while (d) {\n      long long p2 = (((d ^ (d - 1)) + 1) >> 1);\n      flip(make_pair(x + p2, y));\n      y += p2;\n      d -= p2;\n    }\n  }\n}\n\nvoid solve() {\n  long long x = solve1();\n  for (int i = 0; i < n; i++) {\n    swap(ps[i][0], ps[i][1]);\n  }\n  long long y = solve1();\n  printf(\"%lld %lld\\n\", x, y);\n}\n\nint main() {\n  precalc();\n#ifdef DEBUG\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (read()) {\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long long\n#define W V<L>\n#define Z V<W>\n#define R(n) for(L i=0;i<n;i++)\nW S(Z&p,L E){if(!E){return{1,0};}V<Z>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}Z c(4,W(3));c[3]=W(3,1);R(2){for(W x:T[i]){L Q=(2*x[0]+x[1])%3;c[i][Q]^=1;}}R(2){if(c[!i]==c[2]||c[!i]==c[3]){W ans=S(T[i],E-1);ans[0]*=2;ans[1]*=2;ans[1]+=i;return ans;}}for(W&v:p){v[0]++;}W A=S(p,E);A[0]--;return A;}\nint main(){L M=2e17;L n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}W Q=S(p,70);cout<<Q[0]-M<<\" \"<<Q[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 10000 + 10;\nconst int DEBUG = 0;\n\nint n;\nstruct anode{\n\tll x, y;\n\tanode() {}\n\tanode(ll _x, ll _y):x(_x), y(_y) {}\n}a[maxn];\nll c, Ans1, Ans2;\nll f[3][2], g[3][2];\n\nint dp(ll n, ll m, ll res) {\n\tif(m < 0) return 0;\n\tmemset(f,0,sizeof(f));\n\tf[0][1] = 1;\n\tfor(ll i = 60;i >= 0;i --) {\n\t\tmemset(g,0,sizeof(g));\n\t\tint m1 = (m >> i) & 1, n1 = (n >> i) & 1;\n\t\tfor(int j = 0;j < 3;j ++) {\n\t\t\tll nj = (j + (1LL << i) % 3) % 3;\n\t\t\tif(n1 && m1) g[nj][1] += f[j][1];\n\t\t\tif(n1) g[nj][0] += f[j][0];\n\t\t\tif(m1) g[j][0] += f[j][1];\n\t\t\telse g[j][1] += f[j][1];\n\t\t\tg[j][0] += f[j][0];\n\t\t}\n\t\tmemcpy(f,g,sizeof(f));\n\t}\n\tll tmp = (ll)(f[res][0] + f[res][1]) % 2;\n\treturn tmp;\n}\n\ninline ll get(ll n, ll l, ll r, ll res) {\n\tll t1 = dp(n,r,res);\n\tll t2 = dp(n,l - 1,res);\n\tll tmp = (t1 % 2 - t2 % 2) % 2;\n\treturn tmp;\n}\n\ninline ll get_val(ll l, ll r, ll res) {\n\tll tmp = 0;\n\tfor(int i = 1;i <= n;i ++) {\n\t\tll tl = l - a[i].x, tr = r - a[i].x, ts = (res % 3 - a[i].x % 3 + 3) % 3;\n    ll now = get(c - a[i].x - a[i].y,tl,tr,ts);\n\t\ttmp = (tmp + now) % 2;\n\t}\n\treturn tmp;\n}\n\ninline bool check(ll l, ll r) {\n\tint flag = 0;\n\tfor(int i = 0;i < 3;i ++) {\n\t\tif(get_val(l,r,i)) {\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn flag;\n}\n\ninline ll work1() {\n\tll l = - 1e17, r = 1e17;\n\twhile(l < r) {\n\t\tif(DEBUG) printf(\"%lld %lld\\n\", l, r);\n    ll mid = (l + r) / 2LL;\n\t\tif(check(l,mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\treturn l;\n}\n\ninline ll C(ll n, ll m) { return (n & m) == m; }\n\ninline bool light(ll x) {\n\tll tmp = 0;\n\tfor(int i = 1;i <= n;i ++) {\n\t\tif(a[i].x > x) continue;\n\t\ttmp = (tmp + C(c - a[i].x - a[i].y,x - a[i].x)) % 2;\n\t}\n\treturn tmp;\n}\n\ninline void work2(ll pos) {\n\tll l = pos, r = pos;\n  for(ll i = 60;i >= 0;i --) {\n\t\tif(light(l - (1LL << i))) l -= (1LL << i);\n\t\tif(light(r + (1LL << i))) r += (1LL << i);\n\t}\n\tAns1 = l, Ans2 = c - r;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n\tfor(int i = 1;i <= n;i ++) scanf(\"%lld%lld\\n\", &a[i].x, &a[i].y);\n  c = 2e17;\n\tll pos = work1();\n//\tif(DEBUG) cout << light(pos) << endl;\n\twork2(pos);\n\tprintf(\"%lld %lld\\n\", Ans1, Ans2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint main()\n{\n    int N; cin>>N;\n    vector<long long> x(N), y(N);\n    for (int i=0; i<N; i++)\n        cin>>x[i]>>y[i];\n\n    //  https://img.atcoder.jp/wtf19-open/editorial.pdf\n\n    //  x[i], y[i] >= 0 とする\n    long long base = 1LL<<58;\n    for (int i=0; i<N; i++)\n    {\n        x[i] += base;\n        y[i] += base;\n    }\n\n    //  直線 y = 0 上のランプのみが点灯するようにしたときに、\n    //  x < n, x%3 == r を満たすxについて、 \n    //  (x, 0) の点灯しているランプの個数が奇数となるか\n    auto count = [&](long long n, long long r) -> bool\n    {\n        bool ret = false;\n        for (int i=0; i<N; i++)\n        {\n            if (n <= x[i])\n                continue;\n\n            long long m = n - x[i] - 1;\n            //  [k][r]: k桁以下を比較したときにm以下\n            //long long A[61][3] = {};\n            vector<vector<long long>> A(61, vector<long long>(3));\n            //  [k][r]: 任意\n            //long long B[61][3] = {};\n            vector<vector<long long>> B(61, vector<long long>(3));\n\n            //  0\n            A[0][0] = 1LL;\n            B[0][0] = 1LL;\n            //  1\n            if (y[i]&1)\n            {\n                if (m&1)\n                    A[0][1] = 1LL;\n                B[0][1] = 1LL;\n            }\n\n            for (int k=1; k<=60; k++)\n                for (int pr=0; pr<3; pr++)\n                {\n                    //  0\n                    A[k][pr] += m>>k&1 ? B[k-1][pr] : A[k-1][pr];\n                    B[k][pr] += B[k-1][pr];\n                    //  1\n                    if (y[i]>>k&1)\n                    {\n                        long long cr = (pr + (1LL<<k)) % 3;\n                        if (m>>k&1)\n                            A[k][cr] += A[k-1][pr];\n                        B[k][cr] += B[k-1][pr];\n                    }\n                }\n\n            if (A[60][((r-x[i])%3+3)%3]%2 != 0)\n                ret = !ret;\n        }\n        return ret;\n    };\n\n    //  y = 0 の直線上のランプのみが点灯するようにしたときに、\n    //  (p, 0)が点灯しているか\n    auto check = [&](long long p) -> bool\n    {\n        bool ret = false;\n        for (int i=0; i<N; i++)\n            if ((~y[i] & (p-x[i])) == 0)\n                ret = !ret;\n        return ret;\n    };\n\n    long long r3;\n    for (r3=0LL; r3<3LL; r3++)\n        if (count(1LL<<60, r3))\n            break;\n    assert(r3<3LL);\n\n    long long l = 0;\n    long long r = 1LL<<60;\n    while (r-l > 1LL)\n    {\n        long long m = (l+r)/2;\n        if (count(l, r3) == count(m, r3))\n            l = m;\n        else\n            r = m;\n    }\n\n    long long t = l;\n    for (int k=60; k>=0; k--)\n        if (check(l-(1LL<<k)))\n            l -= 1LL<<k;\n    r = t;\n    for (int k=60; k>=0; k--)\n        if (check(r+(1LL<<k)))\n            r += 1LL<<k;\n\n    long long ansx = l-base;\n    long long ansy = (r-l)-base;\n\n    cout<<ansx<<\" \"<<ansy<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// includes {{{\n#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<map>\n#include<set>\n#include<tuple>\n#include<cmath>\n#include<random>\n#include<cassert>\n// #include<deque>\n// #include<multiset>\n// #include<bitset>\n// #include<cstring>\n// #include<bits/stdc++.h>\n// }}}\nusing namespace std;\nusing ll = long long;\n\nconst int N = 1e5;\nint n;\nll x[N], y[N];\npair<ll, ll> xy[N];\npair<ll, ll> yx[N];\n\n// C2のジャッジでC1の実験！ｗ\n\nint main() {\n  ios::sync_with_stdio(false), cin.tie(0);\n  cin >> n;\n  ll x1 = 1e18;\n  ll x2 = -1e18;\n  ll y1 = 1e18;\n  ll y2 = -1e18;\n  for(int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i], xy[i] = make_pair(x[i], y[i]), yx[i] = make_pair(y[i], x[i]);\n    x1 = min(x1, x[i]);\n    y1 = min(y1, y[i]);\n    x2 = max(x2, x[i]);\n    y2 = max(y2, y[i]);\n  }\n\n  assert(x2 - x1 <= 5000);\n  assert(y2 - y1 <= 5000);\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70,M=2e17,i,a,b;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}for(L i;i<2;i++){L c=0;for(W x:T[!i])c^=(2*x[0]+x[1])%3+1;if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){cin>>i;V<W>p(i);while(i--){cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n  pin ans=solve(qab[sz&1],ex-1);\n  ans.first+=sz&1;\n\treturn ans\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n    }\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V vector\n#define L long\nusing namespace std;L E=70,M=2e17,i,a,b;V<L> S(V<V<L>>p){if(!E)return{1,0};V<V<V<L>>>T(2);for(V<L>x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].push_back({x[0]/2,++x[1]/2});}for(L i;i<2;i++){a=0;for(V<L>x:T[!i])a^=(2*x[0]+x[1])%3+1;if(!a){E--;V<L>A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(V<L>&v:p)v[0]++;V<L> A=S(p);A[0]--;return A;}int main(){cin>>i;V<V<L>>p(i);while(i--,cin>>a>>b)p[i]={a+M,b+M};V<L> x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n  \tc=0;\n  \tfor (pin& x : qab[1]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n  \tif (!c) {\n\t\tans.first *= 2; ans.second *= 2;\n\t\treturn ans;\n\t}\n\tc = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second-1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t}\n\tans.first *= 2; ans.first++; ans.second *= 2; ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70,M=2e17,i,a,b;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[(x[1]++)&1].push_back({x[0]/2,x[1]/2});}for(L i;i<2;i++){L c=0;for(W x:T[!i])c^=(2*x[0]+x[1])%3+1;if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){cin>>i;V<W>p(i);while(i--,cin>>a>>b)p[i]={a+M,b+M};W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc+1)%2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0]&&!c[1-i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70,M=2e17,i,a,b;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].push_back({x[0]/2,++x[1]/2});}for(L i;i<2;i++){L c=0;for(W x:T[!i])c^=(2*x[0]+x[1])%3+1;if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){V<W>p(cin>>i);while(i--,cin>>a>>b)p[i]={a+M,b+M};W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n      \tint qc=2*x.first+x.second;\n        qc=(qc&(0xffffffff))+((qc&(0xffffffff00000000))>>32);\n      \tqc=(qc&(0xffff))+((qc&(0xffff0000))>>16);\n      \tqc=(qc&(0xff))+((qc&(0xff00))>>8);\n      \tqc=(qc&(0xf))+((qc&(0xf0))>>4);\n      \tqc=(qc&3)+((qc&12)>>2);\n      \tqc=(qc&3)+((qc&12)>>2);\n        qc=(qc&3)+((qc&12)>>2);\n        qc=(qc&3)+((qc&12)>>2);\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long long\n#define W V<L>\n#define R(n) for(L i=0;i<n;i++)\nW S(V<W>&p,L E){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=(Q+1);}if(!c){W A=S(T[i],E-1);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p,E);A[0]--;return A;}\nint main(){L M=2e17,n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}W Q=S(p,70);cout<<Q[0]-M<<\" \"<<Q[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70,M=2e17,i,a,b;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}for(L i;i<2;i++){L c=0;for(W x:T[!i])c^=(2*x[0]+x[1])%3+1;if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){cin>>i;V<W>p(i);while(i--,cin>>a>>b)p[i]={a+M,b+M};W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 10000 + 10;\nconst int DEBUG = 1;\n\nint n;\nstruct anode{\n\tll x, y;\n\tanode() {}\n\tanode(ll _x, ll _y):x(_x), y(_y) {}\n}a[maxn];\nll c, Ans1, Ans2;\nll f[4][3], g[4][3];\n\nll dp(ll n, ll m, ll res) {\n\tif(m < 0) return 0;\n\tmemset(f,0,sizeof(f));\n\tf[0][1] = 1;\n\tfor(ll i = 60;i >= 0;i --) {\n\t\tmemset(g,0,sizeof(g));\n\t\tint m1 = (m >> i) & 1, n1 = (n >> i) & 1;\n\t\tfor(int j = 0;j < 3;j ++) {\n\t\t\tll nj = (j + (1LL << i) % 3) % 3;\n\t\t\tif(n1 && m1) g[nj][1] += f[j][1];\n\t\t\tif(n1) g[nj][0] += f[j][0];\n\t\t\tif(m1) g[j][0] += f[j][1];\n\t\t\telse g[j][1] += f[j][1];\n\t\t\tg[j][0] += f[j][0];\n\t\t}\n\t\tmemcpy(f,g,sizeof(f));\n\t}\n\tll tmp = (f[res][0] + f[res][1]) % 2;\n\treturn tmp;\n}\n\ninline ll get(ll n, ll l, ll r, ll res) {\n\tll t1 = dp(n,r,res);\n\tll t2 = dp(n,l - 1,res);\n\tll tmp = (t1 % 2 - t2 % 2) % 2;\n\treturn tmp;\n}\n\ninline ll get_val(ll l, ll r, ll res) {\n\tll tmp = 0;\n\tfor(int i = 1;i <= n;i ++) {\n\t\tll tl = l - a[i].x, tr = r - a[i].x, ts = (res % 3 - a[i].x % 3 + 3) % 3;\n    ll now = get(c - a[i].x - a[i].y,tl,tr,ts);\n\t\ttmp = (tmp + now) % 2;\n\t}\n\treturn tmp;\n}\n\ninline bool check(ll l, ll r) {\n\tint flag = 0;\n\tfor(int i = 0;i < 3;i ++) {\n\t\tif(get_val(l,r,0)) {\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn flag;\n}\n\ninline ll work1() {\n\tll l = - 1e17, r = 1e17;\n\twhile(l < r) {\n    ll mid = (l + r) / 2LL;\n\t\tif(check(l,mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\treturn l;\n}\n\ninline ll C(ll n, ll m) { return (n & m) == m; }\n\ninline bool light(ll x) {\n\tll tmp = 0;\n\tfor(int i = 1;i <= n;i ++) {\n\t\tif(a[i].x > x) continue;\n\t\ttmp = (tmp + C(c - a[i].x - a[i].y,x - a[i].x)) % 2;\n\t}\n\treturn tmp;\n}\n\ninline void work2(ll pos) {\n\tll l = pos, r = pos;\n  for(ll i = 60;i >= 0;i --) {\n\t\tif(light(l - (1LL << i))) l -= (1LL << i);\n\t\tif(light(r + (1LL << i))) r += (1LL << i);\n\t}\n\tAns1 = l, Ans2 = c - r;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n\tfor(int i = 1;i <= n;i ++) scanf(\"%lld%lld\\n\", &a[i].x, &a[i].y);\n  c = 2e17;\n\tll pos = work1();\n//\tif(DEBUG) cout << light(pos) << endl;\n\twork2(pos);\n\tprintf(\"%lld %lld\\n\", Ans1, Ans2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70,M=2e17,i,a,b;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].push_back({x[0]/2,++x[1]/2});}for(L i;i<2;i++){L c=0;for(W x:T[!i])c^=(2*x[0]+x[1])%3+1;if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){cin>>i;V<W>p(i);while(i--,cin>>a>>b)p[i]={a+M,b+M};W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1, 0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc + 1) % 2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0] && !c[1 - i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor (pin& v : ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 1e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 60);\n\tcout << ret.first - inf << \" \" << ret.second - inf;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = 2 * x.first + x.second;qc%=3;\n\t\tc ^= (qc+1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t\tw++;\n\t\tif ((w & x.first) == w) { d ^= 1; }\n\t}\n\tans.first *= 2; ans.second *= 2;\n\tans.first += (c | d); ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { d ^= 1; }\n\t}\n\tans.first *= 2; ans.first+=c; ans.second *= 2; ans.second -= d;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t=ll>\nt extgcd(t a,t b,t&x,t&y){\n\tif(b==0){\n\t\tx=1;\n\t\ty=0;\n\t\treturn a;\n\t}else{\n\t\tt g=extgcd(b,a%b,y,x);\n\t\ty-=a/b*x;\n\t\treturn g;\n\t}\n}\n\n//x*y=g mod m\n//returns (g,y)\ntemplate<class t=ll>\npair<t,t> modinv(t x,t m){\n\tt a,b;\n\tt g=extgcd(x,m,a,b);\n\tif(a<0)a+=m/g;\n\treturn {g,a};\n}\n\nnamespace Nimber64{\n\tconst vi fs{3,5,17,257,641,65537,6700417};\n\tconst ull s=-1;\n\t\n\tull multiply_powers_of_2(ull,ull);\n\n\tull multiply(ull a,ull b) {\n\t   ull ans = 0;\n\t   rep(p1,64)if((a>>p1)&1)\n\t\t   rep(p2,64)if((b>>p2)&1)\n\t\t\t  ans=ans^multiply_powers_of_2(ull(1)<<p1,ull(1)<<p2);\n\t   return ans;\n\t}\n\tull multiply_powers_of_2(ull a, ull b) {\n\t\tif (a == 1 or b == 1) return a * b;\n\t\tint n=__lg(__lg(max(a,b)));\n\t\tull power = ull(1)<<(1<<n);\n\t\tif (a >= power and b >= power) {\n\t\t\treturn multiply(power * 3 / 2, multiply_powers_of_2(a / power, b / power));\n\t\t} else if (a >= power) {\n\t\t\treturn multiply_powers_of_2(a / power, b) * power;\n\t\t} else {\n\t\t\treturn multiply_powers_of_2(a, b / power) * power;\n\t\t}\n\t}\n\t\n\tstruct precalc{\n\t\tull tmp[64][64];\n\t\tunsigned char x[256][256];\n\t\tull y[8][8][256];\n\t\ttemplate<int len>\n\t\tull multfast(ull a,ull b){\n\t\t\tull c=0;\n\t\t\trep(i,len)if((a>>i)&1)rep(j,len)if((b>>j)&1)c^=tmp[i][j];\n\t\t\treturn c;\n\t\t}\n\t\tprecalc():tmp(),x(),y(){\n\t\t\trep(i,64)rep(j,64)tmp[i][j]=multiply_powers_of_2(1ULL<<i,1ULL<<j);\n\t\t\trep(i,256)rep(j,256)x[i][j]=multfast<8>(i,j);\n\t\t\trep(i,8)rep(j,i+1)rep(k,256)y[i][j][k]=multfast<64>(tmp[i*8][j*8],k);\n\t\t}\n\t\tull multfast2(ull a,ull b)const{\n\t\t\tull res=0;\n\t\t\trep(i,8){\n\t\t\t\trep(j,i){\n\t\t\t\t\tres^=y[i][j][\n\t\t\t\t\tx[(a>>(i*8))&255][(b>>(j*8))&255]^\n\t\t\t\t\tx[(a>>(j*8))&255][(b>>(i*8))&255]];\n\t\t\t\t}\n\t\t\t\tres^=y[i][i][x[(a>>(i*8))&255][(b>>(i*8))&255]];\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t};\n\tconst precalc buf;\n\t\n\tstruct nim{\n\t\tull v;\n\t\tnim(ull vv=0):v(vv){}\n\t\tnim& operator+=(const nim&rhs){v^=rhs.v;return *this;}\n\t\tnim& operator*=(const nim&rhs){v=buf.multfast2(v,rhs.v);return *this;}\n\t\tnim operator+(const nim&rhs)const{return nim(*this)+=rhs;}\n\t\tnim operator*(const nim&rhs)const{return nim(*this)*=rhs;}\n\t\tnim pow(ull n)const{\n\t\t\tnim res=1,x=*this;\n\t\t\twhile(n){\n\t\t\t\tif(n&1)res*=x;\n\t\t\t\tx*=x;\n\t\t\t\tn>>=1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t};\n\tistream& operator>>(istream&is,nim&x){\n\t\treturn is>>x.v;\n\t}\n\tostream& operator<<(ostream&os,const nim&x){\n\t\treturn os<<x.v;\n\t}\n\t\n\tpair<ull,ull> garnerull(vc<pi> z){\n\t\tull ans=0,w=1;\n\t\trep(i,si(z)){\n\t\t\tint x=z[i].a;\n\t\t\tans=(ans+w*x);\n\t\t\trng(j,i+1,si(z))\n\t\t\t\tz[j].a=(z[j].a+z[j].b-x%z[j].b)*modinv(z[i].b,z[j].b).b%z[j].b;\n\t\t\tw=(w*z[i].b);\n\t\t}\n\t\treturn {ans,w};\n\t}\n\t\n\t//returns minimum x s.t. a^x=b\n\t//and its period\n\t//returns (0,0) if infeasible\n\tpair<ull,ull> discrete_log(const nim a,const nim b){\n\t\tvc<pi> z;\n\t\tfor(auto f:fs){\n\t\t\tnim x=a.pow(s/f);\n\t\t\tnim y=b.pow(s/f);\n\t\t\tif(x.v==1){\n\t\t\t\tif(y.v==1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\treturn {0,0};\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tconst int L=ceil(sqrt(f-1));\n\t\t\tmap<ull,int> v;\n\t\t\t//hash_table<ull,int> v;\n\t\t\t{\n\t\t\t\tnim cur=1;\n\t\t\t\trep(i,L){\n\t\t\t\t\tauto itr=v.find(cur.v);\n\t\t\t\t\tif(itr==v.ed)v[cur.v]=i;\n\t\t\t\t\tcur*=x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans=-1;\n\t\t\t{\n\t\t\t\tnim cur=1;\n\t\t\t\tnim w=x.pow((f-1)*L);\n\t\t\t\tfor(int i=0;i<f;i+=L){\n\t\t\t\t\tnim tar=y*cur;\n\t\t\t\t\tauto itr=v.find(tar.v);\n\t\t\t\t\tif(itr!=v.ed){\n\t\t\t\t\t\tans=i+itr->b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcur*=w;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans==-1)return {0,0};\n\t\t\tz.eb(ans,f);\n\t\t}\n\t\t\n\t\treturn garnerull(z);\n\t}\n\t\n\tbool checkprimitive(const nim a){\n\t\tfor(auto f:fs)if((a.pow(s/f)).v==1)return false;\n\t\treturn true;\n\t}\n}\nusing Nimber64::nim;\n\nusing int128=__int128_t;\nostream& operator<<(ostream&os,int128 i){\n\tif(i==0)\n\t\treturn os<<0;\n\tstatic char buf[100];\n\tif(i<0){\n\t\tos<<\"-\";\n\t\ti=-i;\n\t}\n\tint p=0;\n\twhile(i){\n\t\tbuf[p++]='0'+i%10;\n\t\ti/=10;\n\t}\n\treverse(buf,buf+p);\n\tbuf[p]=0;\n\treturn os<<buf;\n}\nint128 abs128(int128 a){\n\treturn a<0?-a:a;\n}\nint botbit(int128 a){\n\tconst int128 m=ull(-1);\n\tif(a&m)return __builtin_ctzll(ll(a));\n\telse return __builtin_ctzll(ll(a>>64));\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tnim ps[2]{ull(1)<<32|6,0};\n\tps[1]=ps[0].pow(43);\n\tdmp2(ps[0],ps[1]);\n\t\n\tint128 z[2];\n\trep(k,2)z[k]=Nimber64::discrete_log(ps[k],ps[k]+1).a;\n\t\n\tint128 mod=ull(-1);\n\t\n\tdmp2(z[0],z[1]);\n\t\n\tint128 dif=z[1]-z[0];\n\tif(dif<0)dif+=mod;\n\tdmp(dif);\n\t\n\tint128 g,inv;tie(g,inv)=modinv<int128>(dif,mod);\n\tdmp(g);\n\tdmp(inv);\n\tassert(g==1);\n\t\n\tint n;cin>>n;\n\tconst int off=ten(17);\n\tnim w[2];\n\trep(i,n){\n\t\tint128 x=read()+off;\n\t\tint128 y=read()+off;\n\t\trep(k,2){\n\t\t\tw[k]+=ps[k].pow(ull((x+z[k]*y)%mod));\n\t\t}\n\t}\n\t\n\tdmp(0);\n\t\n\tint128 v[2];\n\trep(k,2)v[k]=Nimber64::discrete_log(ps[k],w[k]).a;\n\t\n\tdmp(0);\n\t\n\tint128 y=(v[1]-v[0]+mod)%mod*inv%mod;\n\tint128 x=(v[0]-z[0]*y%mod+mod)%mod;\n\t\n\tdmp(0);\n\t\n\tcout<<x-off<<\" \"<<y-off<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin &x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\trep(i, 2) {\n      int c=0;\n\t\tfor (pin &x : qab[1-i]) {\n\t\t\tint qc = (2 * x.first + x.second)%3;\n          c^=(qc+1);\n\t\t}\n\t\tif (!c) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V vector\n#define W V<long>\nusing namespace std;long E,M=2e17,a,b;W A;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].push_back({x[0]/2,++x[1]/2});}for(long i;i<2;i++){a=0;for(W x:T[!i])a^=(2*x[0]+x[1])%3+1;if(!a){E--;A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;A=S(p);A[0]--;return A;}int main(){cin>>E;V<W>p(E);while(E--,cin>>a>>b)p[E]={a+M,b+M};E=70;A=S(p);cout<<A[0]-M<<\" \"<<A[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V vector\n#define W V<long>\nusing namespace std;long E=70,M=2e17,i,a,b;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].push_back({x[0]/2,++x[1]/2});}for(long i;i<2;i++){a=0;for(W x:T[!i])a^=(2*x[0]+x[1])%3+1;if(!a){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){cin>>i;V<W>p(i);while(i--,cin>>a>>b)p[i]={a+M,b+M};W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll base = 1ll << 58;\nconst int LOG = 60;\nint main() {\n  do {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n  } while (false);\n  int n;\n  cin >> n;\n  vector<ll> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n    x[i] += base;\n    y[i] += base;\n  }\n  auto calc = [&] (ll sum, int r) {\n    bool res = false;\n    for (int i = 0; i < n; i++) {\n      if (y[i] < sum) {\n        ll limit = sum - y[i];\n        vector<bool> F(3), G(3);\n        F[0] = true;\n        for (int j = LOG; j >= 0; j--) {\n          vector<bool> F2(3), G2(3);\n          for (int k = 0; k < 3; k++) {\n            if (F[k]) {\n              for (int v = 0; v <= ((limit >> j & 1) ? (x[i] >> j & 1) : 0); v++) {\n                int nxt = (k + v * (j & 1) + v) % 3;\n                if (v != (limit >> j & 1)) {\n                  G2[nxt].flip();\n                } else {\n                  F2[nxt].flip();\n                }\n              }\n            }\n            if (G[k]) {\n              for (int v = 0; v <= (x[i] >> j & 1); v++) {\n                int nxt = (k + v * (j & 1) + v) % 3;\n                G2[nxt].flip();\n              }\n            }\n          }\n          F = F2;\n          G = G2;\n        }\n        res ^= G[(r - y[i] % 3 + 3) % 3];\n      }\n    }\n    return res;\n  };\n  int r = 0;\n  while (!calc(1ll << LOG, r)) {\n    r++;\n  }\n  ll start = 0;\n  for (int i = LOG; i >= 0; i--) {\n    if (calc(start, r) == calc(start + (1ll << i), r)) {\n      start |= 1ll << i;\n    }\n  }\n  auto check = [&] (ll pos) {\n    bool res = false;\n    for (int i = 0; i < n; i++) {\n      if (y[i] <= pos && pos <= x[i] + y[i] && (x[i] & (pos - y[i])) == pos - y[i]) {\n        res ^= 1;\n      }\n    }\n    return res;\n  };\n  ll L = start, R = start;\n  for (int i = LOG; i >= 0; i--) {\n    if (check(L - (1ll << i))) {\n      L -= 1ll << i;\n    }\n    if (check(R + (1ll << i))) {\n      R += 1ll << i;\n    }\n  }\n  cout << R - L - base << \" \" << L - base << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc+1)%2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (c[1 - i][0]==0&&c[1-i][1]==0) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nint main() {\n\tlong long inf = 2e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}i=2;while(i--){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n,a,b;cin>>n;V<W>p(n);while(n--){cin>>a>>b;p[n]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define stt static\n#define rg register\n#define ll long long\n#define db double\n#define pii pair<int,int>\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n#define y1 substitute_of_y1\n#define DEBUG(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntemplate<typename T> T rd(){\n\tT nmb=0;int sgn=0;char chr=getchar();\n\twhile(!isdigit(chr)){if(chr=='-')sgn=1;chr=getchar();}\n\twhile(isdigit(chr)){nmb=(nmb<<3)+(nmb<<1)+chr-'0';chr=getchar();}\n\treturn sgn?-nmb:nmb;\n}\ntemplate<typename T> void wt(T nmb){\n\tif(nmb>9)wt(nmb/10);\n\tputchar(nmb%10+'0');\n}\ntemplate<typename T> void cmax(T &x,T y){x=x>y?x:y;}\ntemplate<typename T> void cmin(T &x,T y){x=x<y?x:y;}\nvoid proc_status(){\n\tfreopen(\"/proc/self/status\",\"r\",stdin);\n\tstring chr;\n\twhile(getline(cin,chr))\n\t\tif(chr[2]=='P'){\n\t\t\tcerr<<chr<<endl;\n\t\t\tbreak;\n\t}\n}\n\nconst int N=1e4+10;\nconst ll inf=9e18;\n\nint n;\nll mnx,mxx,mny,mxy;\nstruct node{ll x,y;}a[N];\n\nvoid Init(){\n\tn=rd<int>();\n\tmnx=inf,mxx=-inf,mny=inf,mxy=-inf;\n\tfor(int i=1;i<=n;++i){\n\t\ta[i].x=rd<ll>(),a[i].y=rd<ll>();\n\t\tcmin(mnx,a[i].x);\n\t\tcmin(mny,a[i].y),cmax(mxy,a[i].y);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tcmax(mxx,a[i].x+a[i].y-mny);\n}\n\nbool dp[70][3][2],vis[70][3][2],sum[3];\nbool dfs(int x,int r,int tp,ll up,ll dn){\n\tif(!x){\n\t\tif(tp||(dn&1))return (up&1)?0:1;\n\t\treturn 1;\n\t}\n\tif(vis[x][r][tp])return dp[x][r][tp];\n\tif(tp||(dn&1)){\n\t\tdp[x][r][tp]^=dfs(x-1,r,1,up,dn);\n\t\tif(up&(1ll<<x))dp[x][r][tp]^=dfs(x-1,(r+2)%3,tp,up,dn);\n\t}\n\telse dp[x][r][tp]^=dfs(x-1,r,tp,up,dn);\n\tvis[x][r][tp]=1;\n\treturn dp[x][r][tp];\n}\nvoid sol(ll up,ll dn){\n\tcmin(dn,up);\n\tif(!dn){\n\t\tsum[0]^=(up&dn)==dn;\n\t\treturn;\n\t}\n\tint lim=(int)ceil(log2(dn));\n\tmemset(dp,0,sizeof dp);\n\tmemset(vis,0,sizeof vis);\n\tfor(int i=0;i<3;++i)\n\t\tsum[i]^=dfs(lim,i,0,up,dn);\n}\nvoid Sol(ll l,ll r){\n\tsum[0]=sum[1]=sum[2]=0;\n\tfor(int i=1;i<=n;++i){\n\t\t//for(int t=3e8;t;--t);\n\t\tif(a[i].x<=r)sol(a[i].y-mny,r-a[i].x);\n\t\tif(a[i].x<=l-1)sol(a[i].y-mny,l-1-a[i].x);\n\t}\n}\nll Getpoint(){\n\tll lft=mnx,rgt=mxx;\n\twhile(lft<rgt){\n\t\tll mid=(lft+rgt)>>1;\n\t\tSol(lft,mid);\n\t\tif(sum[0]||sum[1]||sum[2])rgt=mid;\n\t\telse lft=mid+1;\n\t}\n\treturn lft;\n}\n\nbool check(ll x){\n\tbool res=0;\n\tfor(int i=1;i<=n;++i){\n\t\tll up=a[i].y-mny,dn=x-a[i].x;\n\t\tif((up&dn)==dn)res^=1;\n\t}\n\treturn res;\n}\n\nvoid Solve(){\n\tll x=Getpoint();\n\tll lft=x,rgt=x;\n\tfor(int i=60;~i;--i){\n\t\tif(check(lft-(1ll<<i)))lft-=(1ll<<i);\n\t\tif(check(rgt+(1ll<<i)))rgt+=(1ll<<i);\n\t}\n\tprintf(\"%lld %lld\\n\",lft,mny+rgt-lft);\n}\n\nint main(){\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc+1)%2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0]&&!c[1-i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\ninline int read()\n{\n\tint o = 0; char ch = ' ';\n\tfor (; ch < '0' || ch>'9'; ch = getchar());\n\tfor (; ch >= '0' && ch <= '9'; ch = getchar())o = o * 10 + (ch ^ 48);\n\treturn o;\n}\nsigned main(){\n\tlong long inf = 2e17;\n\tint n = read();\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; a = read(); b = read();\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define stt static\n#define rg register\n#define ll long long\n#define db double\n#define pii pair<int,int>\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n#define y1 substitute_of_y1\n#define DEBUG(...) fprintf(stderr,__VA_ARGS__)\nusing namespace std;\n\ntemplate<typename T> T rd(){\n\tT nmb=0;int sgn=0;char chr=getchar();\n\twhile(!isdigit(chr)){if(chr=='-')sgn=1;chr=getchar();}\n\twhile(isdigit(chr)){nmb=(nmb<<3)+(nmb<<1)+chr-'0';chr=getchar();}\n\treturn sgn?-nmb:nmb;\n}\ntemplate<typename T> void wt(T nmb){\n\tif(nmb>9)wt(nmb/10);\n\tputchar(nmb%10+'0');\n}\ntemplate<typename T> void cmax(T &x,T y){x=x>y?x:y;}\ntemplate<typename T> void cmin(T &x,T y){x=x<y?x:y;}\nvoid proc_status(){\n\tfreopen(\"/proc/self/status\",\"r\",stdin);\n\tstring chr;\n\twhile(getline(cin,chr))\n\t\tif(chr[2]=='P'){\n\t\t\tcerr<<chr<<endl;\n\t\t\tbreak;\n\t}\n}\n\nconst int N=1e4+10;\nconst ll inf=1e17;\n\nint n;\nll mnx,mxx,mny,mxy;\nstruct node{ll x,y;}a[N];\n\nvoid Init(){\n\tn=rd<int>();\n\tmnx=mny=inf,mxx=mxy=-inf;\n\tfor(int i=1;i<=n;++i){\n\t\ta[i].x=rd<ll>(),a[i].y=rd<ll>();\n\t\tcmin(mnx,a[i].x);\n\t\tcmin(mny,a[i].y),cmax(mxy,a[i].y);\n\t}\n\tfor(int i=1;i<=n;++i)\n\t\tcmax(mxx,a[i].x+a[i].y-mny);\n}\n\nbool dp[65][3][2],sum[3];\nvoid sol(ll up,ll dn,int bs){\n\tcmin(dn,up);\n\tif(!dn){\n\t\tsum[bs]^=1;\n\t\treturn;\n\t}\n\tint lim=(int)ceil(log2(dn));\n\tmemset(dp,0,sizeof dp);\n\tfor(int x=0;x<=lim;++x)\n\t\tfor(int r=0;r<3;++r)\n\t\t\tfor(int tp=0;tp<=1;++tp){\n\t\t\t\tif(!x){\n\t\t\t\t\tif((tp||(dn&1))&&(up&1)&&r==1)dp[x][r][tp]^=1;\n\t\t\t\t\tif(!r)dp[x][r][tp]^=1;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif(tp||(dn&(1ll<<x))){\n\t\t\t\t\tdp[x][r][tp]^=dp[x-1][r][1];\n\t\t\t\t\tint rx=r-(1ll<<x)%3+3;\n\t\t\t\t\tif(rx>=3)rx-=3;\n\t\t\t\t\tif(up&(1ll<<x))dp[x][r][tp]^=dp[x-1][rx][tp];\n\t\t\t\t}\n\t\t\t\telse dp[x][r][tp]^=dp[x-1][r][tp];\n\t}\n\tfor(int i=0;i<3;++i)\n\t\tsum[(i+bs)%3]^=dp[lim][i][0];\n}\nvoid Sol(ll l,ll r){\n\tsum[0]=sum[1]=sum[2]=0;\n\tfor(int i=1;i<=n;++i){\n\t\tint bs=(a[i].x-mnx)%3+3;\n\t\tif(bs>=3)bs-=3;\n\t\tif(a[i].x<=r)sol(a[i].y-mny,r-a[i].x,bs);\n\t\tif(a[i].x<=l-1)sol(a[i].y-mny,l-1-a[i].x,bs);\n\t}\n}\nll Getpoint(){\n\tll lft=mnx,rgt=mxx;\n\twhile(lft<rgt){\n\t\tll mid=(lft+rgt)>>1;\n\t\tSol(lft,mid);\n\t\tif(sum[0]||sum[1]||sum[2])rgt=mid;\n\t\telse lft=mid+1;\n\t}\n\treturn lft;\n}\n\nbool check(ll x){\n\tbool res=0;\n\tfor(int i=1;i<=n;++i){\n\t\tll up=a[i].y-mny,dn=x-a[i].x;\n\t\tif(dn>=0&&(up&dn)==dn)res^=1;\n\t}\n\treturn res;\n}\n\nvoid Solve(){\n\tll x=Getpoint();\n\tll lft=x,rgt=x;\n\tfor(int i=60;~i;--i){\n\t\tif(check(lft-(1ll<<i)))lft-=(1ll<<i);\n\t\tif(check(rgt+(1ll<<i)))rgt+=(1ll<<i);\n\t}\n\tprintf(\"%lld %lld\\n\",lft,mny+rgt-lft);\n}\n\nint main(){\n\tInit();\n\tSolve();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  qab[0].reserve(10000);\n  qab[1].reserve(10000);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\tV<V<bool>> c(2, V<bool>(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc+1)%2) { c[i][0]=!c[i][0]; }\n\t\t\tif (qc) { c[i][1]!=c[i][0]; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0]&&!c[1-i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll base = 1ll << 58;\nconst int LOG = 60;\nint main() {\n  do {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n  } while (false);\n  int n;\n  cin >> n;\n  vector<ll> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n    x[i] += base;\n    y[i] += base;\n  }\n  auto calc = [&] (ll sum, int r) {\n    bool res = false;\n    for (int i = 0; i < n; i++) {\n      if (y[i] < sum) {\n        ll limit = sum - y[i];\n        vector<bool> F(3), G(3);\n        F[0] = true;\n        for (int j = LOG; j >= 0; j--) {\n          vector<bool> F2(3), G2(3);\n          for (int k = 0; k < 3; k++) {\n            if (F[k]) {\n              for (int v = 0; v <= min(limit >> j & 1, x[i] >> j & 1); v++) {\n                int nxt = (k + v * (j & 1) + v) % 3;\n                if (v != (limit >> j & 1)) {\n                  G2[nxt].flip();\n                } else {\n                  F2[nxt].flip();\n                }\n              }\n            }\n            if (G[k]) {\n              for (int v = 0; v <= (x[i] >> j & 1); v++) {\n                int nxt = (k + v * (j & 1) + v) % 3;\n                G2[nxt].flip();\n              }\n            }\n          }\n          F = F2;\n          G = G2;\n        }\n        res ^= G[(r - y[i] % 3 + 3) % 3];\n      }\n    }\n    return res;\n  };\n  int r = 0;\n  while (!calc(1ll << LOG, r)) {\n    r++;\n  }\n  return 0;\n  ll start = 0;\n  for (int i = LOG; i >= 0; i--) {\n    if (calc(start, r) == calc(start + (1ll << i), r)) {\n      start |= 1ll << i;\n    }\n  }\n  auto check = [&] (ll pos) {\n    bool res = false;\n    for (int i = 0; i < n; i++) {\n      if (y[i] <= pos && pos <= x[i] + y[i] && (x[i] & (pos - y[i])) == pos - y[i]) {\n        res ^= 1;\n      }\n    }\n    return res;\n  };\n  ll L = start, R = start;\n  for (int i = LOG; i >= 0; i--) {\n    if (check(L - (1ll << i))) {\n      L -= 1ll << i;\n    }\n    if (check(R + (1ll << i))) {\n      R += 1ll << i;\n    }\n  }\n  cout << R - L - base << \" \" << L - base << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1, 0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc + 1) % 2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0] && !c[1 - i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor (pin& v : ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 2e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define int long long\n#define vel vector<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\n#define V vector\npin solve(V<pin>& ab, int ex) {\n\tif (ex == 0) { return mkp(1, 0); }\n\tV<pin> ab0, ab1;\n\tfor (auto x : ab) {\n\t\tint a1 = x.first;\n\t\tint b1 = x.second;\n\t\tif (b1 % 2 == 0) {\n\t\t\tab0.push_back(mkp(a1 / 2, b1 / 2));\n\t\t\tif (a1 % 2 == 1) { ab1.push_back(mkp(a1 / 2, b1 / 2)); }\n\t\t}\n\t\telse {\n\t\t\tab1.push_back(mkp(a1 / 2, b1 / 2));\n\t\t\tif (a1 % 2 == 1) { ab0.push_back(mkp(a1 / 2, (b1 + 1) / 2)); }\n\t\t}\n\t}\n\tvel c0(2), c1(2);\n\tfor (auto x : ab0) {\n\t\tint qa = x.first % 3; qa = 3 - qa;\n\t\tint qb = x.second % 3;\n\t\tint qc = (qa + qb) % 3;\n\t\tif (qc == 0) { c0[0] ^= 1; }\n\t\tif (qc == 1) { c0[1] ^= 1; }\n\t\tif (qc == 2) { c0[0] ^= 1; c0[1] ^= 1; }\n\t}\n\tfor (auto x : ab1) {\n\t\tint qa = x.first % 3; qa = 3 - qa;\n\t\tint qb = x.second % 3;\n\t\tint qc = (qa + qb) % 3;\n\t\tif (qc == 0) { c1[0] ^= 1; }\n\t\tif (qc == 1) { c1[1] ^= 1; }\n\t\tif (qc == 2) { c1[0] ^= 1; c1[1] ^= 1; }\n\t}\n\tvel ze(2, 0);\n\tif (c0 == ze) {\n\t\tpin ans = solve(ab1, ex - 1);\n\t\tans.first *= 2; ans.second *= 2;\n\t\tans.second++;\n\t\treturn ans;\n\t}\n\tif (c1 == ze) {\n\t\tpin ans = solve(ab0, ex - 1);\n\t\tans.first *= 2; ans.second *= 2;\n\t\treturn ans;\n\t}\n\trep(i, ab.size()) { ab[i].first++; }\n\tpin ans = solve(ab, ex);\n\tans.first--;\n\treturn ans;\n}\nsigned main() {\n\tint inf = 1;\n\trep(i, 57) { inf *= 2; }\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tint a, b; cin >> a >> b;\n\t\ta += inf; b += inf;\n\t\tab[i] = mkp(a, b);\n\t}\n\tpin ret = solve(ab, 70);\n\tret.first -= inf;\n\tret.second -= inf;\n\tcout << ret.first << \" \" << ret.second << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n  \tc=0;\n  \tfor (pin& x : qab[1]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n  \tif (!c) {\n\t\tans.first *= 2; ans.second *= 2;\n\t\treturn ans;\n\t}\n\tc = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second-1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t}\n\tans.first *= 2; ans.first++; ans.second *= 2; ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long long\n#define W V<L>\n#define R(n)for(L i=0;i<n;i++)\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = 2 * x.first + x.second;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long long\n#define Z V<V<L>>\n#define R(n) for(L i=0;i<n;i++)\nW S(Z&p,L E){if(!E){return{1,0};}V<Z>T(2);for(V<L>x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}Z c(4,W(3));c[3]=V<L>(3,1);R(2){for(V<L>x:T[i]){L Q=(2*x[0]+x[1])%3;c[i][Q]^=1;}}R(2){if(c[!i]==c[2]||c[!i]==c[3]){V<L>ans=S(T[i],E-1);ans[0]*=2;ans[1]*=2;ans[1]+=i;return ans;}}for(V<L>&v:p){v[0]++;}V<L>A=S(p,E);A[0]--;return A;}\nint main(){L M=2e17;L n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}W Q=S(p,70);cout<<Q[0]-M<<\" \"<<Q[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n  \tans.first *= 2; ans.second *= 2;\n\tans.first+=(c|d); ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}for(L i;i<2;i++){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n,a,b;cin>>n;V<W>p;while(n--){cin>>a>>b;p[n]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second-1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t\tw++;\n\t\tif ((w & x.first) == w) { d ^= 1; }\n\t}\n\tans.first *= 2; ans.first+=(c|d); ans.second *= 2; ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 58);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n  \tc=0;\n  \tfor (pin& x : qab[1]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n  \tif (!c) {\n\t\tans.first *= 2; ans.second *= 2;\n\t\treturn ans;\n\t}\n\tc = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second-1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t}\n\tans.first *= 2; ans.first++; ans.second *= 2; ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 10000 + 10;\nconst int DEBUG = 0;\n\nint n;\nstruct anode{\n\tll x, y;\n\tanode() {}\n\tanode(ll _x, ll _y):x(_x), y(_y) {}\n}a[maxn];\nll c, Ans1, Ans2;\nll f[3][2], g[3][2];\n\nint dp(ll n, ll m, ll res) {\n\tif(m < 0) return 0;\n\tmemset(f,0,sizeof(f));\n\tf[0][1] = 1;\n\tfor(ll i = 60;i >= 0;i --) {\n\t\tmemset(g,0,sizeof(g));\n\t\tint m1 = (m >> i) & 1, n1 = (n >> i) & 1;\n\t\tfor(int j = 0;j < 3;j ++) {\n\t\t\tll nj = (j + (1LL << i) % 3) % 3;\n\t\t\tif(n1 && m1) g[nj][1] += f[j][1];\n\t\t\tif(n1) g[nj][0] += f[j][0];\n\t\t\tif(m1) g[j][0] += f[j][1];\n\t\t\telse g[j][1] += f[j][1];\n\t\t\tg[j][0] += f[j][0];\n\t\t}\n\t\tmemcpy(f,g,sizeof(f));\n\t}\n\tint tmp = (ll)(f[res][0] + f[res][1]) % 2;\n\treturn tmp;\n}\n\ninline int get(ll n, ll l, ll r, ll res) {\n\tint t1 = dp(n,r,res);\n\tint t2 = dp(n,l - 1,res);\n\tint tmp = (t1 % 2 - t2 % 2) % 2;\n\treturn tmp;\n}\n\ninline bool get_val(ll l, ll r, ll res) {\n\tll tmp = 0;\n\tfor(int i = 1;i <= n;i ++) {\n\t\tll tl = l - a[i].x, tr = r - a[i].x, ts = (res % 3 - a[i].x % 3 + 3) % 3;\n    ll now = get(c - a[i].x - a[i].y,tl,tr,ts);\n\t\ttmp = (tmp + now) % 2;\n\t}\n\treturn (tmp == 1);\n}\n\ninline bool check(ll l, ll r) {\n\tint flag = 0;\n\tfor(int i = 0;i < 3;i ++) {\n\t\tif(get_val(l,r,i)) {\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn flag;\n}\n\ninline ll work1() {\n\tll l = - 1e17, r = 1e17;\n\twhile(l < r) {\n\t\tif(DEBUG) printf(\"%lld %lld\\n\", l, r);\n    ll mid = (l + r) / 2LL;\n\t\tif(check(l,mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\treturn l;\n}\n\ninline ll C(ll n, ll m) { return (n & m) == m; }\n\ninline bool light(ll x) {\n\tll tmp = 0;\n\tfor(int i = 1;i <= n;i ++) {\n\t\tif(a[i].x > x) continue;\n\t\ttmp = (tmp + C(c - a[i].x - a[i].y,x - a[i].x)) % 2;\n\t}\n\treturn tmp;\n}\n\ninline void work2(ll pos) {\n\tll l = pos, r = pos;\n  for(ll i = 60;i >= 0;i --) {\n\t\tif(light(l - (1LL << i))) l -= (1LL << i);\n\t\tif(light(r + (1LL << i))) r += (1LL << i);\n\t}\n\tAns1 = l, Ans2 = c - r;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n\tfor(int i = 1;i <= n;i ++) scanf(\"%lld%lld\\n\", &a[i].x, &a[i].y);\n  c = 2e17;\n\tll pos = work1();\n//\tif(DEBUG) cout << light(pos) << endl;\n\twork2(pos);\n\tprintf(\"%lld %lld\\n\", Ans1, Ans2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<assert.h>\ntypedef long long ll;\nconst ll inf=1e17;\nll f[3][2],g[3][2];\n//f[i][j][k]:i~60 ok, %3=j, locked?\nll s[3];\nvoid dp(ll n,ll m){//sum[i<=m & i in n & i%3=r]\n\tif(m<0){\n\t\tmemset(s,0,sizeof(s));\n\t\treturn;\n\t}\n\tint i,j;\n\tmemset(f,0,sizeof(f));\n\tf[0][1]=1;\n\tfor(i=60;i>=0;i--){\n\t\tmemset(g,0,sizeof(g));\n\t\tfor(j=0;j<3;j++){\n\t\t\tg[j][0]+=f[j][0];\n\t\t\tif(n>>i&1)g[(j+(1ll<<i))%3][0]+=f[j][0];\n\t\t\tif(m>>i&1){\n\t\t\t\tg[j][0]+=f[j][1];\n\t\t\t\tif(n>>i&1)g[(j+(1ll<<i))%3][1]+=f[j][1];\n\t\t\t}else\n\t\t\t\tg[j][1]+=f[j][1];\n\t\t}\n\t\tmemcpy(f,g,sizeof(g));\n\t}\n\tfor(i=0;i<3;i++)s[i]=f[i][0]+f[i][1];\n}\nll get(ll n,ll l,ll r,int t){\n\tdp(n,r);\n\tll s=::s[t];\n\tdp(n,l-1);\n\treturn s-::s[t];\n}\nll x[10010],y[10010];\nint n;\nconst ll c=2*inf;\nll get(ll l,ll r,int t){\n\tll s;\n\tint i;\n\ts=0;\n\tfor(i=1;i<=n;i++)s+=get(c-x[i]-y[i],l-x[i],r-x[i],((t-x[i])%3+3)%3);\n\treturn s;\n}\nbool C(ll n,ll k){return(n&k)==k;}\nbool light(ll a){\n\tint i,f=0;\n\tfor(i=1;i<=n;i++){\n\t\tif(x[i]<=a)f^=C(c-x[i]-y[i],a-x[i]);\n\t}\n\treturn f;\n}\nint main(){\n\tint i,t;\n\tll l,r,mid,x1,x2;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)scanf(\"%lld%lld\",x+i,y+i);\n\tfor(t=0;t<3;t++){\n\t\tif(get(-inf,inf,t)&1)break;\n\t}\n\tl=-inf;\n\tr=inf;\n\twhile(l<r){\n\t\tmid=(l+r)>>1;\n\t\tif(get(l,mid,t)&1)\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n//\tassert(light(l));\n\tx1=x2=l;\n\tfor(i=60;i>=0;i--){\n\t\tif(light(x1-(1ll<<i)))x1-=1ll<<i;\n\t\tif(light(x2+(1ll<<i)))x2+=1ll<<i;\n\t}\n\tprintf(\"%lld %lld\",x1,c-x2);\n}"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking\n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define inf (1<<30)\n#define INF (1ll<<58)\nusing namespace std;\nint n,f[2][3],g[2][3];\nll x[100005],y[100005];\nbool calc(ll pos){\n\tbool ans=0;\n\tFor(i,1,n){\n\t\tll v=pos-y[i];\n\t\tif (v>=0&&(x[i]&v)==v) ans^=1;\n\t}\n\treturn ans;\n}\nbool solve(ll S,int rem){\n\tbool ans=0;\n\tFor(i,1,n) if (y[i]<S){\n\t\tll lim=S-y[i];\n\t\tFor(j,0,2) f[0][j]=(j==0),f[1][j]=0;\n\t\tRep(j,60,0){\n\t\t\tFor(v,0,2) g[0][v]=g[1][v]=0;\n\t\t\tFor(fl,0,1){\n\t\t\t\tint mx=(x[i]>>j)&1;\n\t\t\t\tif (!fl||!(lim>>j)&1) mx=0;\n\t\t\t\tFor(v,0,2) if (f[fl][v])\n\t\t\t\t\tFor(vnow,0,mx){\n\t\t\t\t\t\tint to=(v+vnow*((j&1)+1))%3;\n\t\t\t\t\t\tg[fl|(((lim>>j)&1)^vnow)][to]^=1;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tFor(v,0,2){\n\t\t\t\tf[0][v]=g[0][v];\n\t\t\t\tf[1][v]=g[1][v];\n\t\t\t}\n\t\t}\n\t\tans^=f[1][(rem-y[i]%3+3)%3];\n\t}\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n){\n\t\tscanf(\"%lld%lld\",&x[i],&y[i]);\n\t\tx[i]+=INF; y[i]+=INF;\n\t}\n\tint spe=0;\n\tfor (;!solve(1ll<<60,spe);++spe);\n\tll pos=0;\n\tRep(i,59,0)\n\t\tif (solve(pos,spe)==solve(pos+(1ll<<i),spe))\n\t\t\tpos+=1ll<<i;\n\tll l=pos,r=pos;\n\tRep(i,59,0){\n\t\tif (calc(l-(1ll<<i))) l-=1ll<<i;\n\t\tif (calc(r+(1ll<<i))) r+=1ll<<i;\n\t}\n\tprintf(\"%lld %lld\\n\",r-l-INF,l-INF);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = 2 * x.first + x.second + 1;\n\tqc = (qc & (0xffffffff)) + ((qc & (0x7fffffff00000000)) >> 32);//qc<=1ffffffff\n\tqc = (qc & (0xffff)) + ((qc & (0x1ffff0000)) >> 16);//qc<=2ffff\n\tqc = (qc & (0xff)) + ((qc & (0x3ff00)) >> 8);//qc<=3ff\n\tqc = (qc & (0xf)) + ((qc & (0x3f0)) >> 4);//qc<=4e\n\tqc = (qc & (0xf)) + ((qc & (0x7e)) >> 4);//qc<=18\n\tqc = (qc & 3) + ((qc & 28) >> 2);\n\tqc = (qc & 3) + ((qc & 4) >> 2);\n      \tqc = (qc & 3) + ((qc & 4) >> 2);\n      \tqc = (qc & 3) + ((qc & 4) >> 2);\n      \tqc = (qc & 3) + ((qc & 4) >> 2);\n      \tqc = (qc & 3) + ((qc & 4) >> 2);\n      \tqc = (qc & 3) + ((qc & 4) >> 2);\n      \tqc = (qc & 3) + ((qc & 4) >> 2);\n      \tqc = (qc & 3) + ((qc & 4) >> 2);\n\t\tc ^= qc;\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t\tw++;\n\t\tif ((w & x.first) == w) { d ^= 1; }\n\t}\n\tans.first *= 2; ans.second *= 2;\n\tans.first += (c | d); ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "%:pragma GCC optimize(\"Ofast\", \"inline\")\n#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\nusing namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\n#define int long long\nconst int N = 1e5 + 233;\nconst int inf = -5e17;\nint n, x[N], y[N], qy, ni[N];\nint dp[65][2][3][2];\n\ninline bool get(int u, int n, int r) {\n  memset(dp, 0, sizeof dp);\n  int l = n - y[u];\n  l = min(l, ni[u]);\n  if (l < 0) return 0;\n  // o \\in[0, l] && o % 3 == r nCo module 2\n  dp[0][1][0][1] = 1; int cur = 0;\n  for (int i = 61; i >= 0; i--) {\n    ++cur;\n    for (int d = 0; d < 2; d++) {\n      for (int pr = 0; pr < 3; pr++)\n\tfor (int nlim = 0; nlim < 2; nlim++)\n\t  if (dp[cur - 1][d][pr][nlim]) {\n\t    int lim = d ? l >> i & 1 : 1;\n\t    int npos = ni[u] >> i & 1;\n\t    for (int ch = 0; ch < 2; ch++) {\n\t      int nd = d && ch == lim;\n\t      int nk = ch <= npos && nlim;\n\t      dp[cur][nd][(pr + ch) % 3][nk] ^= dp[cur - 1][d][pr][nlim];\n\t    }\n\t  }\n    }\n  }\n  int ans = 0;\n  for (int d = 0; d < 2; d++)\n    ans ^= dp[cur][d][r][1];\n  return ans;\n}\n\ninline bool calc(int l, int r, int remain) {\n  bool ans = 0;\n  rep (i, n) ans ^= get(i, r, remain) ^ get(i, l - 1, remain);\n  return ans;\n}\n\ninline void divide(int l, int r, int remain) {\n  if (l == r) {\n    qy = l;\n    return ;\n  }\n  int mid = l + (r - l) / 2;\n  if (calc(l, mid, remain)) divide(l, mid, remain);\n  else divide(mid + 1, r, remain);\n}\n\nsigned main(void) {\n  srand(20021214);\n  read(n);\n  rep (i, n) {\n    read(x[i]), read(y[i]);\n    ni[i] = x[i] - inf;\n    // mi_i = o - y_i\n  }\n  int tr = 0;\n  re0 (r, 3) if (calc(-inf, inf, r) == true) {\n    tr = r;\n    break;\n  }\n  divide(-inf, inf, tr);\n  \n  auto isBlack = [&](int o) {\n    bool pa = 0;\n    rep (i, n) if (y[i] <= o && o <= x[i] + y[i] - inf) {\n      int nc = x[i] - inf;\n      int mc = o - y[i];\n      pa ^= nc == (nc | mc);\n    }\n    return pa;\n  };\n  assert(isBlack(qy) == true);\n  \n  int ty = qy, ansl, ansr;\n  \n  for (int k = 61; k >= 0; k--) {\n    if (isBlack(qy + (1ll << k))) {\n      qy += 1ll << k;\n    }\n  }\n  ansr = qy;\n  \n  qy = ty;\n  for (int k = 61; k >= 0; k--) {\n    if (isBlack(qy - (1ll << k))) {\n      qy -= 1ll << k;\n    }\n  }\n  ansl = qy;\n\n  cout << inf + ansr - ansl << \" \" << ansl << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin &x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n  \tint c=0;\n  \tfor (pin &x : qab[0]) {\n         int qc = (2 * x.first + x.second)%3;\n         c^=(qc+1);\n    }\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second += 1;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n   \tc=0;\n\tfor (pin &x : qab[1]) {\n        int qc = (2 * x.first + x.second)%3;\n        c^=(qc+1);\n\t}\n\tif (!c) {\n       \tans.first *= 2; ans.second *= 2;\n\t\treturn ans;\n\t}\n  \tint val=ans.first-1;\n  \tfor(pin &x:qab[0]){\n      if((val-x.second)&x.first)==(val-x.second)){ans.first^=1;}\n    }\n  \tans.first*=2;ans.second*=2;ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70,M=2e17,i,a,b;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}for(L i;i<2;i++){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){cin>>i;V<W>p(i);while(i--){cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#define LL long long\n#define go(x, i, v) for (int i = hd[x], v = to[i]; i; v = to[i = nx[i]])\n#define inline __inline__ __attribute__((always_inline))\ninline LL read() {\n  long long x = 0, w = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) w = ch == '-' ? -1 : 1, ch = getchar();\n  while (isdigit(ch)) {\n    x = (x << 3) + (x << 1) + ch - '0';\n    ch = getchar();\n  }\n  return x * w;\n}\nconst int Max_n = 1e4 + 5;\nconst LL lim = 1e17, inf = 1e18;\nint n, Res;\nint f[65][2][3];\nLL m, N, a[Max_n], b[Max_n];\nbool res[3];\nbool check(LL x, LL y) {\n  bool ans = 0;\n  for (int i = 1; i <= n; i++) {\n    LL M = b[i] - y, N = x - a[i];\n    if (M < N || M < 0 || M < 0) continue;\n    ans ^= ((N & M) == N);\n  }\n  return ans;\n}\nbool DP(int len, bool lim, int res) {\n  if (!len) return res == Res;\n  int &dp = f[len][lim][res];\n  if (dp != -1) return dp;\n  dp = 0;\n  for (int i = 0; i <= (m >> len - 1 & 1); i++) {\n    if (lim && i > (N & (1ll << len - 1))) continue;\n    //if (i > 0)\n      //cout << len << \" \" << lim << \" \" << res << endl;\n    dp ^= DP(len - 1, lim && (i == (N & (1ll << len - 1))), (res << 1 | i) % 3);\n  }\n  return dp;\n}\nvoid work(LL L, LL R, LL a, LL b) {\n  m = b + lim;\n  //cout << m << endl;\n  for (Res = 0; Res < 3; Res++) {\n    N = R - a, memset(f, -1, sizeof(f));\n    res[Res] ^= DP(64, 1, (a % 3 + 3) % 3);\n    //cout << N << \" \" << Res << \" \" << res[Res] << endl;\n    if (L > a) {\n      N = L - a - 1, memset(f, -1, sizeof(f));\n      res[Res] ^= DP(64, 1, (a % 3 + 3) % 3);\n      //cout << N << \" \" << Res << \" \" << res[Res] << endl;\n    }\n  }\n}\nint main() {\n  n = read();\n  for (int i = 1; i <= n; i++) a[i] = read(), b[i] = read();\n  res[0] = res[1] = res[2] = 0;\n  //for (int i = 1; i <= n; i++) {\n  //  work(-2, 1, a[i], b[i]);\n  //  for (int j = 0; j < 3; j++) cout << res[j] << \" \";\n  //  cout << endl;\n  //}\n  LL l = -inf, r = inf, ans;\n  while (l != r) {\n    LL mid = l + r >> 1;\n    res[0] = res[1] = res[2] = 0;\n    for (int i = 1; i <= n; i++) work(l, mid, a[i], b[i]);\n    if (res[1] || res[2] || res[0])\n      r = mid;\n    else\n      l = mid + 1;\n  }\n  LL L = l, R = l;\n  for (int k = 63; ~k; k--)\n    if (check(L - (1ll << k), -lim)) L -= (1ll << k);\n  for (int k = 63; ~k; k--)\n    if (check(R + (1ll << k), -lim)) R += (1ll << k);\n  cout << L << \" \" << -lim + R - L;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\nclass Solver {\n public:\n  int n;\n  vector<LL> x, y;\n  LL N = (1ll << 58) - 1;\n  Solver(LL n) : n(n), x(n), y(n){};\n  bool isOdd(LL a, LL b) {\n    if (a < b) return false;\n    if (b < 0) return false;\n    return (a - b) == (a ^ b);\n  }\n  int coeffMod2(LL X) {\n    int ret = 0;\n    for (int i = 0; i < n; ++i) {\n      ret += isOdd(y[i] + N, X - x[i]);\n    }\n    DBG(X, ret % 2)\n    return ret % 2;\n  }\n\n  int countBlackMod2(LL h, LL w, int c) {\n    //(0,0)の黒い点を直線y=-h上に移したとき、{(x,-h) | x∈[0,w], x=c (mod 3) } となる黒い点の個数\n    if (w < 0) return 0;\n    w = min(w, h);\n    vector<vector<vector<int>>> dp_(61, vector<vector<int>>(3, vector<int>(2)));\n    //dp[i][j][k] : 上からi桁がmod 3でjに等しい数の個数　k=1ならばw以下であることが確定\n    auto dp = [&](int a, int b, int c) -> int& { return dp_[a + 1][b][c]; };\n    dp(-1, 0, 0) = 1;\n    for (int i = 0; i < 60; ++i) {\n      if ((w >> (59 - i)) & 1) {\n        for (int j = 0; j < 3; ++j) {\n          if ((h >> (59 - i)) & 1) dp(i, (j + 1 + (59 - i) % 2) % 3, 0) += dp(i - 1, j, 0);\n          dp(i, j, 1) += dp(i - 1, j, 0);\n          if ((h >> (59 - i)) & 1) dp(i, (j + 1 + (59 - i) % 2) % 3, 1) += dp(i - 1, j, 1);\n          dp(i, j, 1) += dp(i - 1, j, 1);\n        }\n\n      } else {\n        for (int j = 0; j < 3; ++j) {\n          //dp(i, (j + 1 + (59 - i) % 2) % 3, 0) += dp(i - 1, j, 0);\n          dp(i, j, 0) += dp(i - 1, j, 0);\n          if ((h >> (59 - i)) & 1) dp(i, (j + 1 + (59 - i) % 2) % 3, 1) += dp(i - 1, j, 1);\n          dp(i, j, 1) += dp(i - 1, j, 1);\n        }\n      }\n      for (int j = 0; j < 3; ++j) {\n        for (int k = 0; k < 2; ++k) {\n          dp(i, j, k) %= 2;\n        }\n      }\n    }\n    return dp(59, c, 1) + dp(59, c, 0);\n  }\n\n  int countBrackInRange(LL a, LL b, int c) {\n    DBG(a, b, c)\n    //{(x,-h) | x∈[a,b-1], x=c (mod 3) } となる黒い点の個数(mod 2)\n    int ret = 0;\n    for (int i = 0; i < n; ++i) {\n      ret += countBlackMod2(y[i] + N, b - 1 - x[i], ((c - x[i]) % 3 + 3) % 3);\n    }\n    DBG(ret)\n    for (int i = 0; i < n; ++i) {\n      ret -= countBlackMod2(y[i] + N, a - 1 - x[i], ((c - x[i]) % 3 + 3) % 3);\n    }\n    DBG(ret)\n    ret = (ret % 2 + 2) % 2;\n    return ret;\n  }\n\n  void solve() {\n    for (int i = 0; i < n; ++i) {\n      cin >> x[i] >> y[i];\n    }\n\n    vector<int> sum(3);\n    for (int i = 0; i < 3; ++i) {\n      for (int j = 0; j < n; ++j) {\n        DBG(i, j, ((x[j] + i) % 3 + 3) % 3)\n        sum[((x[j] + i) % 3 + 3) % 3] += countBlackMod2(y[j] + N, y[j] + N, i);\n      }\n    }\n\n    //個数が奇数になるグループを探す\n    int r;\n    for (int i = 0; i < 3; ++i) {\n      if (sum[i] % 2) {\n        r = i;\n        break;\n      }\n    }\n    DBG(r, sum)\n    //二分探索\n    //[lb,ub)に黒い点が奇数個あるようにする\n    LL lb = -(1ll << 57), ub = (1ll << 59);\n    while (ub - lb > 1) {\n      DBG(lb, ub, N - 1)\n      LL mid = (lb + ub) / 2;\n      if (countBrackInRange(lb, mid, r) % 2) {\n        ub = mid;\n      } else {\n        lb = mid;\n      }\n    }\n\n    //黒い点を1つ見つけた\n    LL ny = -N, nx = lb;\n    DBG(nx, ny + N)\n    LL ansl = nx, ansr = nx;\n    DBG(coeffMod2(ansl))\n    assert(false);\n    //y=-N上でx座標を動かして、y=-N上で最も左・最も右の黒い点を探す\n    while (true) {\n      bool fin = true;\n      for (int i = 60 - 1; i >= 0; --i) {\n        if (coeffMod2(ansl - (1ll << i))) {\n          fin = false;\n          ansl -= (1ll << i);\n          break;\n        }\n      }\n      DBG(ansl, fin)\n      if (fin) break;\n    }\n    while (true) {\n      bool fin = true;\n      for (int i = 60 - 1; i >= 0; --i) {\n        if (coeffMod2(ansr + (1ll << i))) {\n          fin = false;\n          ansr += (1ll << i);\n          break;\n        }\n      }\n      DBG(ansr)\n      if (fin) break;\n    }\n\n    cout << ansl << ' ' << -N + (ansr - ansl) << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  long long n = 0;\n  std::cin >> n;\n\n  Problem::Solver sol(n);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V vector\n#define W V<long>\nusing namespace std;long E,M=2e17,a,b;W A,x;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].push_back({x[0]/2,++x[1]/2});}for(long i;i<2;i++){a=0;for(x:T[!i])a^=(2*x[0]+x[1])%3+1;if(!a){E--;A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;A=S(p);A[0]--;return A;}int main(){cin>>E;V<W>p(E);while(E--,cin>>a>>b)p[E]={a+M,b+M};E=70;x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll L = -2e17;\nint n;\nvector<pair<ll,ll> > v;\nbool check_point(pair<ll,ll> p, ll x, ll y)\n{\n\tll X = x-p.FF;\n\tll Y = p.SS-y;\n\tassert(Y>=0);\n\tif (X<0||X>Y) return false;\n\treturn (Y&X)==X;\n}\nbool check_point(ll x)\n{\n\tbool ret = 0;\n\tfor (auto p : v)\n\t{\n\t\tif (check_point(p, x, L))\n\t\t{\n\t\t\tret ^= 1;\n\t\t}\n\t}\n\treturn ret;\n}\nbool cnt[3];\nvoid calc(pair<ll,ll> p, ll x, ll y)\n{\n\tll X = x-p.FF;\n\tll Y = p.SS-y;\n\tassert(Y>=0);\n\tif (X<0) return;\n\tif (X>Y) X = Y;\n//\tcerr<<X<<\",\"<<Y<<endl;\n\tassert(Y>=0);\n\tstatic bool dp[66][2][3];\n\tmemset(dp, 0, sizeof(dp));\n\tdp[61][1][0] = 1;\n\tfor (int i=60; i>=0; i--)\n\t{\n\t\tfor (int t=0; t<2; t++)\n\t\t{\n\t\t\tfor (int v=0; v<2; v++)\n\t\t\t{\n\t\t\t\tif (v&&!((Y>>i)&1)) continue;\n\t\t\t\tif (v&&t&&!((X>>i)&1)) continue;\n\t\t\t\tint dlt = ((1ll*v)<<i)%3;\n\t\t\t\tint nt = t&(v==((X>>i)&1));\n\t\t\t\tfor (int j=0; j<3; j++) dp[i][nt][(j+dlt)%3] ^= dp[i+1][t][j];\n\t\t\t}\n\t\t}\n\t}\n\tint t = ((p.FF%3)+3)%3;\n//\tfor (int i=0; i<3; i++) cerr<<dp[0][0][i]; cerr<<\" \";\n//\tfor (int i=0; i<3; i++) cerr<<dp[0][1][i]; cerr<<endl;\n\t\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tcnt[(i+t)%3] ^= dp[0][0][i];\n\t\tcnt[(i+t)%3] ^= dp[0][1][i];\n\t}\n}\nbool check(ll x)\n{\n//\tcerr<<\"check:\"<<x<<endl;\n\tcnt[0] = cnt[1] = cnt[2] = 0;\n\tfor (auto p : v)\n\t{\n\t\tcalc(p, x, L);\n\t}\n//\tcerr<<cnt[0]<<\" \"<<cnt[1]<<\" \"<<cnt[2]<<endl;\n\treturn cnt[0]||cnt[1]||cnt[2];\n}\nint main()\n{\n\tgeti(n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll x, y;\n\t\tgetii(x, y);\n\t\tv.PB(MP(x, y));\n\t}\n/*\tfor (int i=L; i<=-L; i++)\n\t{\n\t\tcerr<<check_point(i);\n\t\tif ((i-L)%5==0) cerr<<\" \";\n\t} cerr<<endl;\n*/\n\tll l = -1e18, r = 1e18;\n\twhile (l<=r)\n\t{\n\t\tll m = l+r>>1;\n\t\tif (check(m)) r = m-1; else l = m+1;\n\t}\n//\tcerr<<l<<\",\"<<r<<\" \"<<check(l)<<check(r)<<endl;\n\tr = l;\n\tassert(check_point(l));\n//\tcerr<<\"l=\"<<l<<\" r=\"<<r<<endl;\n\tfor (int i=0; i<=60; i++) if (check_point(l-(1ll<<i))) l -= 1ll<<i;\n\tfor (int i=0; i<=60; i++) if (check_point(r+(1ll<<i))) r += 1ll<<i;\n//\tcerr<<l<<\",\"<<r<<endl;\n\n\tcout<<l<<\" \"<<L+(r-l)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\n#define R(n)for(L i;i<n;i++){\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2)L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n,a,b;cin>>n;V<W>p(n);R(n)cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long long\n#define W V<L>\n#define R(n) for(L i=0;i<n;i++)\nW S(V<W>&p,L E){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){W A=S(T[i],E-1);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p,E);A[0]--;return A;}\nint main(){L M=2e17,n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}W Q=S(p,70);cout<<Q[0]-M<<\" \"<<Q[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1, 0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc + 1) % 2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0] && !c[1 - i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor (pin& v : ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1, 0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tV<vel> c(4, vel(3)); c[3] = vel(3, 1);\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tc[i][qc] ^= 1;\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (c[1 - i] == c[3] || c[1 - i] == c[2]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor (pin& v : ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctype.h>\n#include <algorithm>\n#include <fstream>\n#include <climits>\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef pair<int, LL> pil;\n\nconst LL INF = 2e17 + 7;\nconst int Bit = 62;\nconst int MAXN = 2e5 + 7;\n\ninline void proc_status() {\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline T read() {\n\tT res = 0, flag = 1; char in = getchar();\n\twhile(!isdigit(in)) { if(in == '-') flag = -1; in = getchar(); }\n\twhile(isdigit(in)) { res = (res << 1) + (res << 3) + in - '0'; in = getchar(); }\n\treturn res * flag;\n}\n\ntemplate<typename T> inline void chkmax(T &a, T b) { if(a < b) a = b; }\ntemplate<typename T> inline void chkmin(T &a, T b) { if(a > b) a = b; }\n\nLL by;\nLL S, L, R;\nint mul[Bit + 1];\nint dp[Bit + 1][3][2][2];\n\nint dfs(int k, int rest, bool bl, bool br) {\n\tif(k == -1) { return rest == 0; }\n\tint &res = dp[k][rest][bl][br];\n\tif(res >= 0) return res;\n\tres = 0;\n\tint l = 0, r = 1;\n\tif(bl) l = (L >> k) & 1;\n\tif(br) r = (R >> k) & 1;\n\tfor(int i = l; i <= r; ++i) {\n\t\tif((!((S >> k) & 1)) && i) continue;\n\t\tres ^= dfs(k - 1, (rest - i * mul[k] + 3) % 3, bl && (i == l), br && (i == r));\n\t}\n\treturn res;\n}\n\ninline int Val(int res, LL a, LL b, LL l, LL r) {\n//\tcout << r << endl;\n\tchkmax(l, a); chkmin(r, a + b);\n//\texit(0);\n\tif(l > r) return 0;\n\tl -= a; r -= a;\n\tL = l; R = r; S = b;\n//\tprintf(\"%lld %lld %lld %lld\\n\", a, b, l, r);\n\tmemset(dp, -1, sizeof dp);\n//\texit(0);\n\ta = (a % 3 + 3) % 3;\n\treturn dfs(Bit, (res - a + 3) % 3, 1, 1);\n}\n\nint n;\npll p[MAXN];\n\ninline bool IsOdd(LL l, LL r) {\n\tfor(int i = 0; i < 3; ++i) {\n\t\tint res = 0;\n\t\tfor(int j = 1; j <= n; ++j) {\n//\t\t\tcout << \"GG \" << p[j].x << ' ' << p[j].y << endl;\n\t\t\tint x = Val(i, p[j].x, p[j].y, l, r);\n//\t\t\tprintf(\"FF %d\\n\", x);\n//\t\t\texit(0);\n\t\t\tres ^= x;\n\t\t}\n\t\tif(res) return 1;\n//\t\tcout << res << endl;\n//\t\texit(0);\n\t}\n\treturn 0;\n}\n\ninline LL GetSt(LL l, LL r) {\n//\tcout << IsOdd(1, 3);\n//\texit(0);\n\twhile(1) {\n//\t\tcout << l << ' ' << r << endl;\n\t\tLL mid = l + r >> 1;\n\t\tif(IsOdd(l, mid)) r = mid;\n\t\telse l = mid + 1;\n\t\tif(l == r) return l;\n\t}\n\texit(0);\n}\n\nLL st;\n\ninline void init() {\n\tmul[0] = 1;\n\tfor(int i = 1; i <= Bit; ++i) mul[i] = mul[i - 1] * 2 % 3;\n\tn = read<int>();\n\tby = LLONG_MAX;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tp[i].x = read<LL>();\n\t\tchkmin(by, p[i].y = read<LL>());\n\t}\n\tfor(int i = 1; i <= n; ++i) p[i].y = p[i].y - by;\n\n//\tcout << GetSt(35408917861648745, 35408917861648746);\n//\texit(0);\n\n\tst = GetSt(-INF, INF);\n//\texit(0);\n//\tcout << st << endl;\n//\tprintf(\"%lld\\n\", by);\n}\n\ninline int Val(LL x) {\n\tint res = 0;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tif(x < p[i].x) continue;\n\t\tif(x > p[i].x + p[i].y) continue;\n\t\tLL tx = x - p[i].x;\n\t\tres ^= ((tx & p[i].y) == tx);\n//\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn res;\n}\n\ninline void solve() {\n//\tcout << Val(1) << endl;\n//\tcout << endl;\n//\tcout << st << endl;\n//\tcout << endl;\n//\texit(0);\n\tLL ed = st;\n\n//\tcout << st << ' ' << ed << endl;\n//\texit(0);\n\n//\tcout << (1ll << Bit) << endl;\n\tfor(int i = Bit; i >= 0; --i) {\n\t\tif(Val(st - (1ll << i))) {\n\t\t\tst -= (1ll << i);\n\t//\t\tcout << (1ll << i) << endl;\n\t//\t\texit(0);\n\t\t}\n\t}\n\n\tfor(int i = Bit; i >= 0; --i) {\n\t\tif(Val(ed + (1ll << i))) {\n//\t\t\texit(0);\n\t\t\ted += (1ll << i);\n\t\t}\n\t}\n//\texit(0);\n\tprintf(\"%lld %lld\\n\", st, by + ed - st);\n}\n\nint main() {\n\n\tinit();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V vector\n#define L long\n#define W V<L>\nusing namespace std;L E=70,M=2e17,i,a,b;W S(V<W>p){if(!E)return{1,0};V<set<W>>T(2);for(W x:p){T[x[1]&1].insert({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].insert({x[0]/2,++x[1]/2});}for(L i;i<2;i++){L c=0;for(W x:T[!i])c^=(2*x[0]+x[1])%3+1;if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){cin>>i;V<W>p(i);while(i--,cin>>a>>b)p[i]={a+M,b+M};W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <ctype.h>\n#include <algorithm>\n#include <fstream>\n#include <climits>\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef pair<int, LL> pil;\n\nconst LL INF = 2e17 + 7;\nconst int Bit = 60;\nconst int MAXN = 1e4 + 7;\n\ninline void proc_status() {\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline T read() {\n\tT res = 0, flag = 1; char in = getchar();\n\twhile(!isdigit(in)) { if(in == '-') flag = -1; in = getchar(); }\n\twhile(isdigit(in)) { res = (res << 1) + (res << 3) + in - '0'; in = getchar(); }\n\treturn res * flag;\n}\n\ntemplate<typename T> inline void chkmax(T &a, T b) { if(a < b) a = b; }\ntemplate<typename T> inline void chkmin(T &a, T b) { if(a > b) a = b; }\n\nLL by;\nLL S, L, R;\nint mul[Bit + 1];\n\nint dfs(int k, int rest, bool bl, bool br) {\n\tif(k == -1) {\n\t\treturn rest == 0;\n\t}\n\tint res = 0;\n\tint l = 0, r = 1;\n\tif(bl) l = (L >> k) & 1;\n\tif(br) r = (R >> k) & 1;\n\tfor(int i = l; i <= r; ++i) {\n\t\tif(!((S >> k) & 1) && i) continue;\n\t\tres ^= dfs(k - 1, (rest - i * mul[k] + 3) % 3, bl && (i == l), br && (i == r));\n\t}\n\treturn res;\n}\n\ninline int Val(int res, LL a, LL b, LL l, LL r) {\n\tchkmax(l, a); chkmin(r, a + b);\n\tif(l > r) return 0;\n\tl -= a; r -= a; b -= by;\n\tL = l; R = r; S = b;\n\treturn dfs(Bit, res, 1, 1);\n}\n\nint n;\npll p[MAXN];\n\ninline bool IsOdd(LL l, LL r) {\n\tfor(int i = 0; i < 3; ++i) {\n\t\tint res = 0;\n\t\tfor(int j = 1; j <= n; ++j) \n\t\t\tres ^= Val(i, p[j].x, p[j].y, l, r);\n\t\tif(res) return 1;\n\t}\n\treturn 0;\n}\n\ninline LL GetSt(LL l, LL r) {\n\twhile(1) {\n\t\tLL mid = l + r >> 1;\n\t\tif(IsOdd(l, mid)) r = mid;\n\t\telse l = mid + 1;\n\t\tif(l == r) return l;\n\t}\n}\n\nLL st;\n\ninline void init() {\n\tmul[0] = 1;\n\tfor(int i = 1; i <= Bit; ++i) mul[i] = mul[i - 1] * 2 % 3;\n\tn = read<int>();\n\tby = LLONG_MAX;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tp[i].x = read<LL>();\n\t\tchkmin(by, p[i].y = read<LL>());\n\t}\n\tfor(int i = 1; i <= n; ++i) p[i].y = p[i].y - by;\n\tst = GetSt(-INF, INF);\n//\tprintf(\"%lld\\n\", by);\n}\n\ninline int Val(LL x) {\n\tint res = 0;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tif(x < p[i].x) continue;\n\t\tif(x > p[i].x + p[i].y) continue;\n\t\tint tx = x - p[i].x;\n\t\tres ^= ((tx & p[i].y) == tx);\n//\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn res;\n}\n\ninline void solve() {\n//\tcout << Val(1) << endl;\n//\tcout << endl;\n//\texit(0);\n\tLL ed = st;\n\n\tfor(int i = Bit; i >= 0; --i) {\n\t\tif(Val(ed + (1ll << i))) {\n//\t\t\texit(0);\n\t\t\ted += (1ll << i);\n\t\t}\n\t}\n\n//\tcout << st << ' ' << ed << endl;\n//\texit(0);\n\n\tfor(int i = Bit; i >= 0; --i) {\n\t\tif(Val(st - (1ll << i))) {\n\t\t\tst -= (1ll << i);\n\t\t}\n\t}\n//\texit(0);\n\tprintf(\"%lld %lld\\n\", st, by + ed - st);\n}\n\nint main() {\n\n\tinit();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V vector\n#define W V<long>\nusing namespace std;long E,a,b;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].push_back({x[0]/2,++x[1]/2});}for(long i;i<2;i++){a=0;for(W x:T[!i])a^=(2*x[0]+x[1])%3+1;if(!a){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){cin>>E;V<W>p(E);while(E--,cin>>a>>b)p[E]={a+M,b+M};E=70;W x=S(p);E=2e17;cout<<x[0]-E<<\" \"<<x[1]-E;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70,M=2e17,n,a,b;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}for(L i;i<2;i++){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){cin>>n;V<W>p(n);while(n--){cin>>a>>b;p[n]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { d ^= 1; }\n\t}\n\tif (!c) {\n\t\tans.first *= 2; ans.second *= 2;\n\t\treturn ans;\n\t}\n\tans.first *= 2; ans.first++; ans.second *= 2; ans.second -= d;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t}\n\tif (!c) {\n\t\tans.first *= 2; ans.second *= 2;\n\t\treturn ans;\n\t}\n\tans.first *= 2; ans.first++; ans.second *= 2; ans.second -= d;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}L i=2;while(i--){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n,a,b;cin>>n;V<W>p(n);while(n--){cin>>a>>b;p[n]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\nvel solve(V<vel>& ab, int ex) {\n\tif (ex == 0) { return { 1, 0 }; }\n\tV<vel> ab0, ab1;\n\tfor (auto x : ab) {\n\t\tint a1 = x[0];\n\t\tint b1 = x[1];\n\t\tif (b1 % 2 == 0) {\n\t\t\tab0.push_back({ a1 / 2, b1 / 2 });\n\t\t\tif (a1 % 2 == 1) { ab1.push_back({ a1 / 2, b1 / 2 }); }\n\t\t}\n\t\telse {\n\t\t\tab1.push_back({ a1 / 2, b1 / 2 });\n\t\t\tif (a1 % 2 == 1) { ab0.push_back({ a1 / 2, (b1 + 1) / 2 }); }\n\t\t}\n\t}\n\tvel c0(2), c1(2);\n\tfor (auto x : ab0) {\n\t\tint qc = (3 - x[0] + x[1]) % 3; qc = (qc + 3) % 3;\n\t\tif (qc&1 == 0) { c0[0] ^= 1; }\n\t\tif (qc >= 1) { c0[1] ^= 1; }\n\t}\n\tfor (auto x : ab1) {\n\t\tint qc = (3 - x[0] + x[1]) % 3; qc = (qc + 3) % 3;\n\t\tif (qc & 1 == 0) { c0[0] ^= 1; }\n\t\tif (qc >= 1) { c0[1] ^= 1; }\n\t}\n\tvel ze(2, 0);\n\tif (c0 == ze) {\n\t\tvel ans = solve(ab1, ex - 1);\n\t\tans[0] *= 2; ans[1] *= 2;ans[1]++;\n\t\treturn ans;\n\t}\n\tif (c1 == ze) {\n\t\tvel ans = solve(ab0, ex - 1);\n\t\tans[0] *= 2; ans[1] *= 2;\n\t\treturn ans;\n\t}\n\trep(i, ab.size()) { ab[i][0]++; }\n\tvel ans = solve(ab, ex); ans[0]--;\n\treturn ans;\n}\nsigned main() {\n\tint inf = 1;\n\trep(i, 57) { inf *= 2; }\n\tint n; cin >> n;\n\tV<vel> ab(n);\n\trep(i, n) {\n\t\tint a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tvel ret = solve(ab, 70);\n\tcout << ret[0] - inf << \" \" << ret[1] - inf << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\nclass Solver {\n public:\n  int n;\n  vector<LL> x, y;\n  LL N = (1ll << 58);\n  Solver(LL n) : n(n), x(n), y(n){};\n  bool isOdd(LL a, LL b) {\n    if (a < b) return false;\n    if (b < 0) return false;\n    return (a - b) == (a ^ b);\n  }\n  int coeffMod2(LL X) {\n    int ret = 0;\n    for (int i = 0; i < n; ++i) {\n      ret += isOdd(y[i] + N, X - x[i]);\n    }\n    DBG(X, ret % 2)\n    return ret % 2;\n  }\n\n  int countBlackMod2(LL h, LL w, int c) {\n    //(0,0)の黒い点を直線y=-h上に移したとき、{(x,-h) | x∈[0,w], x=c (mod 3) } となる黒い点の個数\n    if (w < 0) return 0;\n    w = min(w, h);\n    vector<vector<vector<int>>> dp_(61, vector<vector<int>>(3, vector<int>(2)));\n    //dp[i][j][k] : 上からi桁がmod 3でjに等しい数の個数　k=1ならばw以下であることが確定\n    auto dp = [&](int a, int b, int c) -> int& { return dp_[a + 1][b][c]; };\n    dp(-1, 0, 0) = 1;\n    for (int i = 0; i < 60; ++i) {\n      if ((w >> (59 - i)) & 1) {\n        for (int j = 0; j < 3; ++j) {\n          if ((h >> (59 - i)) & 1) dp(i, (j + 1 + (59 - i) % 2) % 3, 0) += dp(i - 1, j, 0);\n          dp(i, j, 1) += dp(i - 1, j, 0);\n          if ((h >> (59 - i)) & 1) dp(i, (j + 1 + (59 - i) % 2) % 3, 1) += dp(i - 1, j, 1);\n          dp(i, j, 1) += dp(i - 1, j, 1);\n        }\n\n      } else {\n        for (int j = 0; j < 3; ++j) {\n          //dp(i, (j + 1 + (59 - i) % 2) % 3, 0) += dp(i - 1, j, 0);\n          dp(i, j, 0) += dp(i - 1, j, 0);\n          if ((h >> (59 - i)) & 1) dp(i, (j + 1 + (59 - i) % 2) % 3, 1) += dp(i - 1, j, 1);\n          dp(i, j, 1) += dp(i - 1, j, 1);\n        }\n      }\n      for (int j = 0; j < 3; ++j) {\n        for (int k = 0; k < 2; ++k) {\n          dp(i, j, k) %= 2;\n        }\n      }\n    }\n    return dp(59, c, 1) + dp(59, c, 0);\n  }\n\n  int countBrackInRange(LL a, LL b, int c) {\n    DBG(a, b, c)\n    //{(x,-h) | x∈[a,b-1], x=c (mod 3) } となる黒い点の個数(mod 2)\n    int ret = 0;\n    for (int i = 0; i < n; ++i) {\n      ret += countBlackMod2(y[i] + N, b - 1 - x[i], ((c - x[i]) % 3 + 3) % 3);\n    }\n    DBG(ret)\n    for (int i = 0; i < n; ++i) {\n      ret -= countBlackMod2(y[i] + N, a - 1 - x[i], ((c - x[i]) % 3 + 3) % 3);\n    }\n    DBG(ret)\n    ret = (ret % 2 + 2) % 2;\n    return ret;\n  }\n\n  void solve() {\n    for (int i = 0; i < n; ++i) {\n      cin >> x[i] >> y[i];\n    }\n\n    vector<int> sum(3);\n    for (int i = 0; i < 3; ++i) {\n      for (int j = 0; j < n; ++j) {\n        DBG(i, j, ((x[j] + i) % 3 + 3) % 3)\n        sum[((x[j] + i) % 3 + 3) % 3] += countBlackMod2(y[j] + N, y[j] + N, i);\n      }\n    }\n\n    //個数が奇数になるグループを探す\n    int r;\n    for (int i = 0; i < 3; ++i) {\n      if (sum[i] % 2) {\n        r = i;\n        break;\n      }\n    }\n    DBG(r, sum)\n    //二分探索\n    //[lb,ub)に黒い点が奇数個あるようにする\n    LL lb = -(1ll << 57), ub = (1ll << 59);\n    while (ub - lb > 1) {\n      DBG(lb, ub, N - 1)\n      LL mid = (lb + ub) / 2;\n      if (countBrackInRange(lb, mid, r) % 2) {\n        ub = mid;\n      } else {\n        lb = mid;\n      }\n    }\n\n    //黒い点を1つ見つけた\n    LL ny = -N, nx = lb;\n    DBG(nx, ny + N)\n    LL ansl = nx, ansr = nx;\n    DBG(coeffMod2(ansl))\n\n    //y=-N上でx座標を動かして、y=-N上で最も左・最も右の黒い点を探す\n    while (true) {\n      bool fin = true;\n      for (int i = 60 - 1; i >= 0; --i) {\n        if (coeffMod2(ansl - (1ll << i))) {\n          fin = false;\n          ansl -= (1ll << i);\n          break;\n        }\n      }\n      DBG(ansl, fin)\n      if (fin) break;\n    }\n    while (true) {\n      bool fin = true;\n      for (int i = 60 - 1; i >= 0; --i) {\n        if (coeffMod2(ansr + (1ll << i))) {\n          fin = false;\n          ansr += (1ll << i);\n          break;\n        }\n      }\n      DBG(ansr)\n      if (fin) break;\n    }\n    DBG(countBlackMod2(4, 2, 0))\n    DBG(countBlackMod2(4, 2, 1))\n    DBG(countBlackMod2(4, 2, 2))\n\n    cout << ansl << ' ' << -N + (ansr - ansl) << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  long long n = 0;\n  std::cin >> n;\n\n  Problem::Solver sol(n);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1, 0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc + 1) % 2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0] && !c[1 - i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor (pin& v : ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\ninline int readint() {\n\tint res = 0;\n\tchar c = getchar();\n\tif ('0' <= c && c <= '9') {\n\t\twhile ('0' <= c && c <= '9') {\n\t\t\tres = res * 10 + c - '0';\n\t\t\tc = getchar();\n\t\t}\n\t}\n\telse {\n\t\tc = getchar();\n\t\twhile ('0' <= c && c <= '9') {\n\t\t\tres = res * 10 + c - '0';\n\t\t\tc = getchar();\n\t\t}\n\t\tres *= -1;\n\t}\n\treturn res;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n = readint();\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; a = readint(); b = readint();\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc+1)%2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0]&&!c[1-i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\ninline int read()\n{\n\tint o = 0; char ch = ' ';\n\tfor (; ch < '0' || ch>'9'; ch = getchar());\n\tfor (; ch >= '0' && ch <= '9'; ch = getchar())o = o * 10 + (ch ^ 48);\n\treturn o;\n}\nsigned main(){\n\tlong long inf = 2e17;\n\tint n; n = read();\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; a = read(); b = read();\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "//#pragma GCC optimize(\"Ofast\")\n//#pragma GCC target(\"avx\")\n//#undef LOCAL\n\n\n\n\n#include <algorithm>\n\n#include <array>\n\n#include <bitset>\n\n#include <cassert>\n\n#include <complex>\n\n#include <cstdio>\n\n#include <cstring>\n\n#include <iostream>\n\n#include <map>\n\n#include <numeric>\n\n#include <queue>\n\n#include <set>\n\n#include <string>\n\n#include <unordered_map>\n\n#include <unordered_set>\n\n#include <vector>\n\nusing namespace std;\n\nusing uint = unsigned int;\nusing ll = long long;\nusing ull = unsigned long long;\nconstexpr ll TEN(int n) { return (n == 0) ? 1 : 10 * TEN(n - 1); }\ntemplate <class T> using V = vector<T>;\ntemplate <class T> using VV = V<V<T>>;\n\nstruct Scanner {\n    FILE* fp = nullptr;\n    char line[(1 << 15) + 1];\n    size_t st = 0, ed = 0;\n    void reread() {\n        memmove(line, line + st, ed - st);\n        ed -= st;\n        st = 0;\n        ed += fread(line + ed, 1, (1 << 15) - ed, fp);\n        line[ed] = '\\0';\n    }\n    bool succ() {\n        while (true) {\n            if (st == ed) {\n                reread();\n                if (st == ed) return false;\n            }\n            while (st != ed && isspace(line[st])) st++;\n            if (st != ed) break;\n        }\n        if (ed - st <= 50) reread();\n        return true;\n    }\n    template <class T, enable_if_t<is_same<T, string>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        while (true) {\n            size_t sz = 0;\n            while (st + sz < ed && !isspace(line[st + sz])) sz++;\n            ref.append(line + st, sz);\n            st += sz;\n            if (!sz || st != ed) break;\n            reread();\n        }\n        return true;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    bool read_single(T& ref) {\n        if (!succ()) return false;\n        bool neg = false;\n        if (line[st] == '-') {\n            neg = true;\n            st++;\n        }\n        ref = T(0);\n        while (isdigit(line[st])) {\n            ref = 10 * ref + (line[st++] - '0');\n        }\n        if (neg) ref = -ref;\n        return true;\n    }\n    template <class T> bool read_single(V<T>& ref) {\n        for (auto& d : ref) {\n            if (!read_single(d)) return false;\n        }\n        return true;\n    }\n    void read() {}\n    template <class H, class... T> void read(H& h, T&... t) {\n        bool f = read_single(h);\n        assert(f);\n        read(t...);\n    }\n    Scanner(FILE* _fp) : fp(_fp) {}\n};\n\nstruct Printer {\n  public:\n    template <bool F = false> void write() {}\n    template <bool F = false, class H, class... T>\n    void write(const H& h, const T&... t) {\n        if (F) write_single(' ');\n        write_single(h);\n        write<true>(t...);\n    }\n    template <class... T> void writeln(const T&... t) {\n        write(t...);\n        write_single('\\n');\n    }\n\n    Printer(FILE* _fp) : fp(_fp) {}\n    ~Printer() { flush(); }\n\n  private:\n    static constexpr size_t SIZE = 1 << 15;\n    FILE* fp;\n    char line[SIZE], small[50];\n    size_t pos = 0;\n    void flush() {\n        fwrite(line, 1, pos, fp);\n        pos = 0;\n    }\n    void write_single(const char& val) {\n        if (pos == SIZE) flush();\n        line[pos++] = val;\n    }\n    template <class T, enable_if_t<is_integral<T>::value, int> = 0>\n    void write_single(T val) {\n        if (pos > (1 << 15) - 50) flush();\n        if (val == 0) {\n            write_single('0');\n            return;\n        }\n        if (val < 0) {\n            write_single('-');\n            val = -val; // todo min\n        }\n        size_t len = 0;\n        while (val) {\n            small[len++] = char('0' + (val % 10));\n            val /= 10;\n        }\n        for (size_t i = 0; i < len; i++) {\n            line[pos + i] = small[len - 1 - i];\n        }\n        pos += len;\n    }\n    void write_single(const string& s) {\n        for (char c : s) write_single(c);\n    }\n    void write_single(const char* s) {\n        size_t len = strlen(s);\n        for (size_t i = 0; i < len; i++) write_single(s[i]);\n    }\n    template <class T> void write_single(const V<T>& val) {\n        auto n = val.size();\n        for (size_t i = 0; i < n; i++) {\n            if (i) write_single(' ');\n            write_single(val[i]);\n        }\n    }\n};\nScanner sc(stdin);\nPrinter pr(stdout);\n\nstruct Nimber64;\nNimber64 mul_naive(Nimber64 l, Nimber64 r);\nstruct Nimber64 {\n    const static V<ull> factor;\n    const static array<array<unsigned char, 256>, 256> small;\n    const static array<array<array<Nimber64, 256>, 8>, 8> precalc;\n    ull v;\n    Nimber64() : v(0) {}\n    Nimber64(ull _v) : v(_v) {}\n    const Nimber64 operator+(Nimber64 r) const {\n        return v ^ r.v;\n    }\n    const Nimber64 operator*(Nimber64 r) const {\n        Nimber64 ans;\n        for (int i = 0; i < 8; i++) {\n            for (int j = 0; j < 8; j++) {\n                ull x = (v >> (8 * i)) % 256;\n                ull y = (r.v >> (8 * j)) % 256;\n                ans += precalc[i][j][small[x][y]];\n            }\n        }\n        return ans;\n    }\n    bool operator==(Nimber64 r) const {\n        return v == r.v;\n    }\n    Nimber64& operator+=(Nimber64 r) { return *this = *this + r; }\n    Nimber64& operator*=(Nimber64 r) { return *this = *this * r; }\n\n    Nimber64 pow(ull n) const {\n        Nimber64 x = *this, r = 1;\n        while (n) {\n            if (n & 1) r = r * x;\n            x = x * x;\n            n >>= 1;\n        }\n        return r;\n    }\n\n    ull discrete_logarithm(Nimber64 y) {\n        ull rem = 0, mod = 1;\n        for (ull p : factor) {\n            ull STEP = 1;\n            while (4 * STEP * STEP < p) STEP *= 2;\n            auto inside = [&](Nimber64 x, Nimber64 y) {\n                unordered_map<ull, int> mp;\n                Nimber64 big = 1; // x^m\n                for (int i = 0; i < int(STEP); i++) {\n                    mp[y.v] = i;\n                    y *= x;\n                    big *= x;\n                }\n                Nimber64 now = 1;\n                for (int step = 0; step < int(p + 10); step += STEP) {\n                    now *= big;\n                    // check [step + 1, step + STEP]\n                    if (mp.find(now.v) != mp.end()) {\n                        return (step + STEP) - mp[now.v];\n                    }\n                }\n                return ull(-1);\n            };\n\n            ull q = ull(-1) / p;\n            ull res = inside((*this).pow(q), y.pow(q));\n            if (res == ull(-1)) {\n                return ull(-1);\n            }\n            res %= p;\n            // mod p = v\n            if (mod == 1) {\n                rem = res;\n                mod = p;\n            } else {\n                while (rem % p != res) rem += mod;\n                mod *= p;\n            }\n        }\n        return rem;\n    }\n\n    bool is_primitive_root() const {\n        for (ull p : factor) {\n            if ((*this).pow(ull(-1) / p).v == 1) return false;\n        }\n        return true;\n    }\n};\nconst V<ull> Nimber64::factor = {\n    6700417, 65537, 641, 257, 17, 5, 3,\n};\n\nNimber64 mul_naive(Nimber64 l, Nimber64 r) {\n    ull a = l.v, b = r.v;\n    if (a < b) swap(a, b);\n    if (b == 0) return 0;\n    if (b == 1) return a;\n    int p = 32;\n    while (max(a, b) < (1ULL << p)) p /= 2;\n    ull power = 1ULL << p;\n    if (a >= power && b >= power) {\n        Nimber64 ans;\n        ans += mul_naive(a % power, b % power);\n        ans += mul_naive(a / power, b % power).v * power;\n        ans += mul_naive(a % power, b / power).v * power;\n        auto x = mul_naive(a / power, b / power);\n        ans += x.v * power;\n        ans += mul_naive(x.v, power / 2);\n        return ans;\n    } else {\n        return Nimber64(mul_naive(a / power, b).v * power) + mul_naive(a % power, b);\n    }\n};\n\nconst array<array<unsigned char, 256>, 256> Nimber64::small = []() {\n    array<array<unsigned char, 256>, 256> small;\n    for (int i = 0; i < 256; i++) {\n        for (int j = 0; j < 256; j++) {\n            small[i][j] = (unsigned char)(mul_naive(i, j).v);\n        }\n    }\n    return small;\n}();\n\nconst array<array<array<Nimber64, 256>, 8>, 8> Nimber64::precalc = []() {\n    array<array<array<Nimber64, 256>, 8>, 8> precalc;\n    for (int i = 0; i < 8; i++) {\n        for (int j = 0; j < 8; j++) {\n            for (int k = 0; k < 256; k++) {\n                precalc[i][j][k] = mul_naive(mul_naive(1ULL << (8 * i), 1ULL << (8 * j)), k);\n            }\n        }\n    }\n    return precalc;\n}();\n\nusing Int = __int128;\nInt gcd(Int a, Int b) {\n    if (a < 0) a = -a;\n    if (b < 0) b = -b;\n    if (b == 0) return a;\n    return gcd(b, a % b);\n}\n\n/// g:gcd(a, b), ax+by=g\nstruct EG { Int g, x, y; };\nEG ext_gcd(Int a, Int b) {\n    if (b == 0) {\n        if (a >= 0) return EG{a, 1, 0};\n        else return EG{-a, -1, 0};\n    } else {\n        auto e = ext_gcd(b, a % b);\n        return EG{e.g, e.y, e.x - a / b * e.y};\n    }\n}\n\nInt inv_mod(Int x, Int md) {\n    auto z = ext_gcd(x, md).x;\n    return (z % md + md) % md;\n}\n\nconst ll OFF = 3 * TEN(17);\n\nint main() {\n    const Int MOD = ull(-1);\n    Nimber64 a = (6 | 1ULL << 32);\n    Nimber64 b = (10 | 1ULL << 34);\n    assert(a.is_primitive_root());\n    assert(b.is_primitive_root());\n    Int s = a.discrete_logarithm(a + 1);\n    Int t = b.discrete_logarithm(b + 1);\n    Int diff = s - t;\n    assert(gcd(diff, MOD) == 1);\n\n    int n;\n    sc.read(n);\n    V<ll> x(n), y(n);\n    for (int i = 0; i < n; i++) {\n        sc.read(x[i], y[i]);\n        x[i] += OFF; y[i] += OFF;\n    }\n    auto f = [&](Nimber64 z) {\n        Nimber64 sum;\n        for (int i = 0; i < n; i++) {\n            sum += z.pow(x[i]) * (z + 1).pow(y[i]);\n        }\n        return sum;\n    };\n\n    // X + s * Y\n    Int u = a.discrete_logarithm(f(a));\n    // X + t * Y\n    Int v = b.discrete_logarithm(f(b));\n\n    Int Y = (u - v) * inv_mod(s - t, MOD);\n    Y = (Y % MOD + MOD) % MOD;\n    Int X = u - s * Y;\n    X = (X % MOD + MOD) % MOD;\n\n    pr.writeln(ll(X) - OFF, ll(Y) - OFF);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = 2 * x.first + x.second + 1;\n\tqc = (qc & (0xffffffff)) + ((qc & (0x7fffffff00000000)) >> 32);//qc<=1ffffffff\n\tqc = (qc & (0xffff)) + ((qc & (0x1ffff0000)) >> 16);//qc<=2ffff\n\tqc = (qc & (0xff)) + ((qc & (0x3ff00)) >> 8);//qc<=3ff\n\tqc = (qc & (0xf)) + ((qc & (0x3f0)) >> 4);//qc<=4e\n\tqc = (qc & (0xf)) + ((qc & (0x7e)) >> 4);//qc<=18\n\tqc = (qc & 3) + ((qc & 28) >> 2);\n\t\tc ^= qc;\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first = ans.first<<1; ans.second = ans.second<<1; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t\tw++;\n\t\tif ((w & x.first) == w) { d ^= 1; }\n\t}\n\tans.first = ans.first<<1; ans.second = ans.second<<1;\n\tans.first += (c | d); ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define elif else if\n \n// Type\n#define ld double\n#define ll long long\n#define ull unsigned ll\n \n// Vector\n#define vc vector\n#define Pb push_back\n#define Pf push_front\n#define Eb emplace_back\n#define All(x) x.begin(),x.end()\n#define AllRev(x) x.rbegin(),x.rend()\n \n// Memory\n#define Ms(_data) memset(_data,0,sizeof(_data))\n#define Msn(_data,_num) memset(_data,_num,sizeof(_data))\n \n// Template\n#define _cl class\n#define _tp template\n#define _tyn typename\n \n// Pair\n#define Mp make_pair\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n \n// Loop\n#define For(i,j) for( int (i) = 1 ; (i) <= (j) ; ++(i) )\n#define For0(i,j) for( int (i) = 0 ; (i) < (j) ; ++(i) )\n#define Forx(i,j,k) for( int (i) = (j) ; (i) <= (k) ; ++(i) )\n#define Forstep(i,j,k,st) for( int (i) = (j) ; (i) <= (k) ; (i) += (st) )\n#define fOR(i,j) for( int (i) = (j) ; (i) >= 1 ; --(i) )\n#define fOR0(i,j) for( int (i) = (j)-1 ; (i) >= 0 ; --(i) )\n#define fORx(i,j,k) for( int (i) = (k) ; (i) >= (j) ; --(i) )\n \n// Read\nstruct InputReader{\n    #define bs 1048576\n    char buf[bs]; int p;\n    il InputReader(){ p = bs; }\n    il void Flush(){ p = 0; fread(buf,1,bs,stdin); }\n    il char C(){ if(p >= bs) Flush(); return buf[p++]; }\n    il char Readnum(){ char ch = C(); while( !isdigit(ch) && ch != '-' ) ch = C(); return ch; }\n    il void Readalpha( char &c ){ c = C(); while( !isalpha(c) ) c = C(); }\n    int operator() (){\n        int ans = 0, fu = 1; char ch = Readnum();\n        if( ch == '-' ) fu = -1, ch = C();\n        while( ch >= '0' && ch <= '9' ){\n            ans = ans*10 + ch-'0';\n            ch = C();\n        }\n        return ans * fu;\n    }\n    ll Readll(){\n        ll ans = 0LL, fu = 1LL; char ch = Readnum();\n        if( ch == '-' ) fu = -1LL, ch = C();\n        while( ch >= '0' && ch <= '9' ){\n            ans = ans*10LL + ch-'0';\n            ch = C();\n        }\n        return ans * fu;\n    }\n    il void Readstring( string &x ){\n        x.clear(); char ch = C();\n        while( !isdigit(ch)  &&  !isalpha(ch)  &&  ch != '#'  &&  ch != '.' ) ch = C();\n        while( isdigit(ch)  ||  isalpha(ch)  ||  ch == '#'  ||  ch == '.' ){\n            x += ch;\n            ch = C();\n        }\n    }\n    il void Readchstring( char s[] ){\n        int len = 0; char ch = C();\n        while( !isdigit(ch)  &&  !isalpha(ch)  /*&&  ch != '*'  &&  ch != '?'*/ ) ch = C();\n        while( isdigit(ch)  ||  isalpha(ch)  /*||  ch == '*'  ||  ch == '?'*/ ){\n            s[len++] = ch;\n            ch = C();\n        }\n        s[len] = '\\0';\n    }\n    il void Specialread( char &c ){\n        c = C();\n        while( !isdigit(c) && !isalpha(c) && c != '#'  &&  c != '.'  &&  c != '='  &&  c != 'B' ) c = C();\n    }\n    #undef bs\n}In;\nil void Read( int &x ){ x = In(); }\nil void Read( int &x, int &y ){ x = In(); y = In(); }\nil void Read( int &x1 , int &x2 , int &x3 ){ x1 = In(); x2 = In(); x3 = In(); }\nil void Read( int &x1 , int &x2 , int &x3 , int &x4 ){ x1 = In(); x2 = In(); x3 = In(); x4 = In(); }\nil void Read( ll &x ){ x = In.Readll(); }\nil void Read( ll &x, ll &y ){ x = In.Readll(); y = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 , ll &x4 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); x4 = In.Readll(); }\n_tp<_tyn T> void Read( T a[] , int st , int ed ){ Forx(i,st,ed) Read(a[i]); }\n#define iRead(k) int k; Read(k);\n#define iRead2(a,b) iRead(a); iRead(b);\n#define iRead3(a,b,c) iRead2(a,b); iRead(c);\n#define iRead4(a,b,c,d) iRead2(a,b); iRead2(c,d);\n#define lRead(k) ll k; Read(k);\n#define lRead2(a,b) lRead(a); lRead(b);\n#define lRead3(a,b,c) lRead2(a,b); lRead(c);\n#define lRead4(a,b,c,d) lRead2(a,b); lRead2(c,d);\n \n// File\n#define Fin(a) freopen(a,\"r\",stdin)\n#define Fout(a) freopen(a,\"w\",stdout)\nil void FILEIO(){\n    #ifdef intLSY\n        Fin(\"in.in\");\n    #endif\n}\nil void FILEIO( string pname ){\n    #ifndef intLSY\n        Fin((pname+\".in\").c_str());\n        Fout((pname+\".out\").c_str());\n    #else\n        Fin(\"in.in\");\n    #endif\n}\nil void FILEIO_OICONTEST( string pname ){\n    Fin((pname+\".in\").c_str());\n    #ifndef intLSY\n        Fout((pname+\".out\").c_str());\n    #endif\n}\nvoid Printtime(){\n    #ifdef intLSY\n        double _timeuse = clock()* 1000.0 / CLOCKS_PER_SEC;\n        fprintf(stderr,\"\\n\\nTime usage:\\n%.0lf ms\\n\",_timeuse);\n    #endif\n}\nvoid END(){ Printtime(); exit(0); }\n_tp<_tyn T>void END( T mes ){ cout << mes << endl; END(); }\n \n// Debug\n#define B cerr << \"Breakpll\" << endl;\n#define O(x) cerr << #x << \" \" << x << endl;\n#define O_(x) cerr << #x << \" \" << x << \"  \";\n#define ERR(x) cerr << \"ERR! #\" << x << endl;\n#define Msz(x) cerr << \"Sizeof \" << #x << \" \" << sizeof(x)/1024/1024 << \" MB\" << endl;\n_tp<_tyn T>void Print( T a[] , int s , int t , char sp = ' ' , char ed = '\\n' ){\n    if( s > t ) return;\n    for( int i = s ; i < t ; i++ )\n        cout << a[i] << sp;\n    cout << a[t] << ed;\n    cout.flush();\n}\n_tp<_tyn T>void Print( T a , int s = 0 , int t = -1 , char sp = ' ' , char ed = '\\n' ){\n    if( t == -1 ) t = a.size()-1;\n    for( int i = s ; i <= t ; i++ )\n        cout << a[i] << sp;\n    cout << ed;\n    cout.flush();\n}\n \n// Optimize\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define Mymax(a,b) (a) = max((a),(b))\n#define Mymin(a,b) (a) = min((a),(b))\n#define INF (0x3f3f3f3f)\n#define LINF ((long long)(0x3f3f3f3f3f3f3f3f))\n#define Sqr(x) ((x)*(x))\n#define Lowbit(a) ((a)&(-(a)))\nvc<int> Range( int l , int r ){\n    vc<int> ret{};\n    Forx(i,l,r) ret.Pb(i);\n    return ret;\n}\n#define abs(x) ((x)<0?-(x):(x))\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n#define MAXN 10010\nmt19937 Rand( 20031111LL * 20021126 % 20031208 * time(0) );\n \nint n;\npll p[MAXN];\n \nil pll Neq2( const pll &p1 , const pll &p2 , bool &legal ){\n    // if( p1.F == p1.S and p2.F == p2.S ){ legal = 0; return p1; }\n    static pll ans;\n    static ll dt;\n    if( p1.F == p2.F ){\n        dt = abs(p2.S-p1.S);\n        ans = {p1.F+dt,min(p1.S,p2.S)};\n    }elif( p1.S == p2.S ){\n        dt = abs(p2.F-p1.F);\n        ans = {min(p1.F,p2.F),p1.S+dt};\n    }elif( abs(p1.F-p2.F) == abs(p1.S-p2.S) ){\n        dt = abs(p1.F-p2.F);\n        ans = {min(p1.F,p2.F),min(p1.S,p2.S)};\n    }else{\n        legal = 0;\n        return p1;\n    }\n    legal = __builtin_popcountll(dt) == 1;\n    return ans;\n}\n \nnamespace ThisIsNotSoCorrect{\n    vc<pll> known;\n    queue<pll> unknown;\n    unordered_set<ll> hmap;\n    il int Msk( const pll &p ){\n        ll msk = (p.F<<10LL) + p.S*233 + p.F%20031111*p.S%20021126 / 3 + p.F%20031111*p.F%20021126/4 + p.S*p.S/8 + p.F + p.S + 1;\n        return msk;\n    }\n    void Solve(){\n        pll last_inserted;\n        For(i,n) unknown.emplace(p[i]);\n        while(!unknown.empty()){\n            pll u = unknown.front();\n            unknown.pop();\n            ll umsk = Msk(u);\n            if(hmap.count(umsk)) continue;\n            for( auto v : known ){\n                bool legal;\n                pll w = Neq2(u,v,legal);\n                if(!legal) continue;\n                int wmsk = Msk(w);\n                if(!hmap.count(wmsk))\n                    unknown.emplace(w);\n            }\n            known.Eb(u);\n            hmap.insert(umsk);\n            last_inserted = u;\n        }\n        printf(\"%lld %lld\\n\",last_inserted.F,last_inserted.S);\n    }\n}\n \nint main(){\n    FILEIO();\n \n    Read(n);\n    For(i,n) Read(p[i].F,p[i].S);\n \n    if( n == 1 ){\n        printf(\"%lld %lld\\n\",p[1].F,p[1].S);\n        END();\n    }\n \n    if( n == 2 ){\n        bool legal;\n        pll ans = Neq2(p[1],p[2],legal);\n        printf(\"%lld %lld\\n\",ans.F,ans.S);\n        // O(legal);\n        END();\n    }\n \n    ThisIsNotSoCorrect::Solve();\n \n    END();\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<assert.h>\ntypedef long long ll;\nconst ll inf=1e17;\nll f[3][2],g[3][2];\n//f[i][j][k]:i~60 ok, %3=j, locked?\nll s[3];\nvoid dp(ll n,ll m){//sum[i<=m & i in n & i%3=r]\n\tif(m<0||n<0){\n\t\tmemset(s,0,sizeof(s));\n\t\treturn;\n\t}\n\tint i,j;\n\tmemset(f,0,sizeof(f));\n\tf[0][1]=1;\n\tfor(i=60;i>=0;i--){\n\t\tmemset(g,0,sizeof(g));\n\t\tfor(j=0;j<3;j++){\n\t\t\tg[j][0]+=f[j][0];\n\t\t\tif(n>>i&1)g[(j+(1ll<<i))%3][0]+=f[j][0];\n\t\t\tif(m>>i&1){\n\t\t\t\tg[j][0]+=f[j][1];\n\t\t\t\tif(n>>i&1)g[(j+(1ll<<i))%3][1]+=f[j][1];\n\t\t\t}else\n\t\t\t\tg[j][1]+=f[j][1];\n\t\t}\n\t\tmemcpy(f,g,sizeof(g));\n\t}\n\tfor(i=0;i<3;i++)s[i]=f[i][0]+f[i][1];\n}\nll get(ll n,ll l,ll r,int t){\n\tdp(n,r);\n\tll s=::s[t];\n\tdp(n,l-1);\n\treturn s-::s[t];\n}\nll x[10010],y[10010];\nint n;\nconst ll c=2*inf;\nll get(ll l,ll r,int t){\n\tll s;\n\tint i;\n\ts=0;\n\tfor(i=1;i<=n;i++)s+=get(c-x[i]-y[i],l-x[i],r-x[i],((t-x[i])%3+3)%3);\n\treturn s;\n}\nbool C(ll n,ll k){return(n&k)==k;}\nbool light(ll a){\n\tint i,f=0;\n\tfor(i=1;i<=n;i++){\n\t\tif(x[i]<=a)f^=C(c-x[i]-y[i],a-x[i]);\n\t}\n\treturn f;\n}\nint main(){\n\tint i,t;\n\tll l,r,mid,x1,x2;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)scanf(\"%lld%lld\",x+i,y+i);\n\tfor(t=0;t<3;t++){\n\t\tif(get(-inf,inf,t)&1)break;\n\t}\n\tassert(t<3);\n\tl=-inf;\n\tr=inf;\n\twhile(l<r){\n\t\tmid=(l+r)>>1;\n\t\tif(get(l,mid,t)&1)\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n//\tassert(light(l));\n\tx1=x2=l;\n\tfor(i=60;i>=0;i--){\n\t\tif(light(x1-(1ll<<i)))x1-=1ll<<i;\n\t\tif(light(x2+(1ll<<i)))x2+=1ll<<i;\n\t}\n\tprintf(\"%lld %lld\",x1,c-x2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\n#define R(n)for(L i;i<n;i++)\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){L c;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n,a,b;cin>>n;V<W>p(n);R(n){cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V vector\n#define L long\n#define W V<L>\nusing namespace std;L E=70,M=2e17,i,a,b;W S(V<W>p){if(!E)return{1,0};set<V<W>>T(2);for(W x:p){T[x[1]&1].insert({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].insert({x[0]/2,++x[1]/2});}for(L i;i<2;i++){L c=0;for(W x:T[!i])c^=(2*x[0]+x[1])%3+1;if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){cin>>i;V<W>p(i);while(i--,cin>>a>>b)p[i]={a+M,b+M};W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "%:pragma GCC optimize(\"Ofast\", \"inline\")\n#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\n  using namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\n#define int long long\nconst int N = 1e5 + 233;\nconst int inf = 1e17;\nint n, x[N], y[N], qy, ni[N];\nbool dp[65][2][3];\n\ninline bool get(int u, int n, int r) {\n  memset(dp, 0, sizeof dp);\n  int l = n - y[u];\n  l = min(l, ni[u]);\n  r = ((r - y[u]) % 3 + 3) % 3;\n  if (l < 0) return 0;\n  // o \\in[0, l] && o % 3 == r ni[u]Co module 2\n  // cout << l << \" \" << ni[u] << \" \" << r << \"\\n\";\n  dp[0][1][0] = 1; int cur = 0;\n  for (int i = 61; i >= 0; i--) {\n    ++cur;\n    for (int d = 0; d < 2; d++) {\n      for (int pr = 0; pr < 3; pr++) {\n\tint lim = d ? l >> i & 1 : 1;\n\tfor (int ch = 0; ch <= min(ni[u] >> i & 1, lim); ch++) {\n\t  int nd = d && ch == lim;\n\t  int nv = pr + (i & 1 ? -1 : 1) * ch;\n\t  nv = (nv % 3 + 3) % 3;\n\t  // if (i == 2 && d == 1 && pr == 0) {\n\t  //   cout << ch << \" \" << nd << \" \" << nv << \"\\n\";\n\t  // }\n\t  dp[cur][nd][nv] ^= dp[cur - 1][d][pr];\n\t}\n      }\n    }\n  }\n  int ans = 0;\n  for (int d = 0; d < 2; d++)\n    ans ^= dp[cur][d][r];\n  return ans;\n}\n\ninline bool calc(int l, int r, int remain) {\n  bool ans = 0;\n  rep (i, n) {\n    ans ^= get(i, r, remain) ^ get(i, l - 1, remain);\n    // cout << i << \" \" << get(i, r, remain) << \" \" <<  get(i, l - 1, remain) << \"\\n\";\n  }\n  return ans;\n}\n\nsigned main(void) {\n  srand(20021214);\n  read(n);\n  rep (i, n) {\n    read(x[i]), read(y[i]);\n    ni[i] = x[i] + inf;\n    // mi_i = o - y_i\n  }\n  // cout << get(1, 4, 1) << \"\\n\";\n  // return 0;\n  // cout << calc(-4, 4, 1) << \"\\n\";\n  // return 0;\n  int tr = 0;\n  re0 (r, 3) if (calc(-inf, inf, r) == true) {\n    tr = r;\n    break;\n  }\n  assert(calc(-inf, inf, tr) == true);\n  \n  int l = -inf, r = inf;\n  while (l < r) {\n    int mid = l + (r - l) / 2;\n    if (calc(l, mid, tr)) r = mid;\n    else l = mid + 1;\n  }\n  qy = r;\n  \n  auto isBlack = [&](int o) {\n    bool pa = 0;\n    rep (i, n) if (y[i] <= o && o <= x[i] + y[i] + inf) {\n      int nc = x[i] + inf;\n      int mc = o - y[i];\n      pa ^= nc == (nc | mc);\n    }\n    return pa;\n  };\n  assert(isBlack(qy) == true);\n  \n  int ty = qy, ansl, ansr;\n  \n  for (int k = 61; k >= 0; k--) {\n    if (isBlack(qy + (1ll << k))) {\n      qy += 1ll << k;\n    }\n  }\n  ansr = qy;\n  \n  qy = ty;\n  for (int k = 61; k >= 0; k--) {\n    if (isBlack(qy - (1ll << k))) {\n      qy -= 1ll << k;\n    }\n  }\n  ansl = qy;\n\n  cout << -inf + ansr - ansl << \" \" << ansl << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, a, b) for(int i = (a), i##end = (b); i <= i##end; ++ i)\n#define CLR(i, a) memset(i, a, sizeof(i))\n#define REPD(i, a, b) for(int i = (a), i##end = (b); i >= i##end; -- i)\n#define LOG(x) std::cerr << #x << \":\" << x << '\\n'\n#define DBG(...) fprintf(stderr, __VA_ARGS__)\n#define OK fprintf(stderr, \"Passing %s in LINE [%d]\\n\", __FUNCTION__, __LINE__)\n#define gc getchar\n#define pc putchar\n#define endl '\\n'\ntypedef long long LL;\ntypedef double DB;\ninline LL rd() {\n\tchar ch = gc(); LL ret = 0, sgn = 1;\n\twhile(ch < '0' || ch > '9') {\n\t\tif(ch == '-') sgn = -1;\n\t\tch = gc();\n\t}\n\twhile(ch <= '9' && ch >= '0') \n\t\tret = ret * 10 + ch - '0', ch = gc();\n\treturn ret * sgn;\n}\n/**************************************************************/\n\nconst int N = 1e4 + 3, LG = 60;\nconst LL INF = 1ll << 60;\n\nLL qx[N], qy[N], bot, rem;\nint n;\nint ind;\nbool f[N][LG + 3][3], vis[N][LG + 3][3];\n\nbool ifValid(LL x) {\n\tbool ret = 0;\n\tREP(i, 1, n) if(qx[i] <= x) {\n\t\tLL u = qy[i] - bot, v = x - qx[i];\n\t\tret ^= ((u | v) == u);\n\t}\n\treturn ret;\n}\n\nint upa[LG + 3], upb[LG + 3];\n\nbool Dp(int pos, int tr, bool lim) {\n\tassert(tr <= 2);\n\tif(pos < 0) {\n\t\t// if(tr == 0) OK;\n\t\treturn (tr == 0);\n\t}\n\tif(!lim && vis[ind][pos][tr]) return f[ind][pos][tr];\n\t// LOG(tr);\n\tint up = lim ? upa[pos] : 1;\n\tup = min(up, upb[pos]); \n\n\tbool ret = 0;\n\tREP(i, 0, up) {\n\t\tint ntr = (tr + 3 - ((LL)i * (1ll << pos) % 3) % 3) % 3;\n\t\tbool nlim = lim & (i == upa[pos]);\n\t\tret ^= Dp(pos - 1, ntr, nlim);\n\t}\n\n\tif(!lim) {\n\t\tvis[ind][pos][tr] = 1;\n\t\tf[ind][pos][tr] = ret; \n\t}\n\treturn ret;\n}\n\ninline bool __main__(LL all, LL ql, LL qr, LL trem) {\n\t// assert(ql <= qr);\n\tif(ql > qr) return 0;\n\tassert(ql >= 0 && qr >= 0);\n\tREP(i, 0, LG) {\n\t\tupb[i] = (all >> i) & 1;\n\t\tupa[i] = (qr >> i) & 1;\n\t}\n\tbool ret = Dp(LG, trem, 1);\n\tif(ql > 0) {\n\t\tREP(i, 0, LG) upa[i] = ((ql - 1) >> i) & 1;\n\t\tret ^= Dp(LG, trem, 1);\n\t}\n\treturn ret;\n}\n\nbool Calc_sz(LL L, LL R) {\n\tassert(L <= R);\n\tbool ret = 0;\n\tREP(i, 1, n) {\n\t\tLL tl = max(qx[i], L) - qx[i], tr = min(qx[i] + qy[i] - bot, R) - qx[i];\n\t\tint trem = (rem - qx[i] % 3 + 3) % 3;\n\t\tind = i;\n\t\tret ^= __main__(qy[i] - bot, tl, tr, trem);\t\n\t\t// if(ret == 1) OK;\n\t}\n\treturn ret;\n}\n\nint main() {\n\tn = rd();\n\tbot = INF;\n\tLL ll = INF, rr = -INF;\n\tREP(i, 1, n) {\n\t\tqx[i] = rd(), qy[i] = rd();\n\t\t// LOG(qx[i]), LOG(qy[i]);\n\t\tbot = min(qy[i], bot);\n\t\tll = min(ll, qx[i]), rr = max(rr, qx[i]);\n\t}\n\t-- bot;\n\t// LOG(ll), LOG(rr);\n\t// Calc_sz(ll, rr);\n\tfor(rem = 0; !Calc_sz(ll, rr); ++ rem) ;\n\t// LOG(rem);\n\tLL l = ll, r = rr;\n\twhile(l < r) {\n\t\tLL mid = l + r >> 1;\n\t\tif(Calc_sz(l, mid)) r = mid;\n\t\telse l = mid + 1; \n\t}\n\t// puts(\"Heghlu' meH QaQ jajvam\"), exit(0);\n\t// OK;\n\tstatic LL pw[LG + 3];\n\tpw[0] = 1;\n\tREP(i, 1, LG) pw[i] = pw[i - 1] << 1ll;\n\t// cout << rem << endl;\n\tLL resl = l, resr = l;\n\tREPD(k, LG, 0) {\n\t\t// LOG(pw[k]);\n\t\tif(ifValid(resl - pw[k])) resl -= pw[k];\n\t\tif(ifValid(resr + pw[k])) resr += pw[k];\n\t}\n\tprintf(\"%lld %lld\\n\", resl, bot + (resr - resl));\n\treturn 0;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\n#define R(n)for(L i;i<n;i++){L c\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2)=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n,b;cin>>n;V<W>p(n);R(n);cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <nmmintrin.h>\n#include <emmintrin.h>\n#include <wmmintrin.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nusing GF = uint32_t;\n\ninline GF Add(GF a, GF b) {\n  return a ^ b;\n}\n\ninline GF Mul(GF a, GF b) {\n  __m128i xa = _mm_cvtsi64_si128(a), xb = _mm_cvtsi64_si128(b);\n  xa = _mm_clmulepi64_si128(xa, xb, 0x00);\n  uint64_t res = _mm_cvtsi128_si64(xa);\n  GF hi = res >> 32;\n  GF a0 = hi ^ (hi >> 25) ^ (hi >> 29) ^ (hi >> 30);\n  return (GF)res ^ a0 ^ (a0 << 2) ^ (a0 << 3) ^ (a0 << 7);\n}\n\nvector<GF> base;\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val);\nGF AddPositionsFrom(LL x, LL y, LL min_val);\n\nmap<pair<LL, LL>, GF> memo;\nGF AddPositions(LL x, LL y, int bb = 60) {\n  if (x == 0 && y == 0) { return 1; }\n  debug(\"?Any\", x, y);\n  \n  pair<LL, LL> p{x, y};\n  if (memo.count(p)) { return memo[p]; }\n\n  int bit = bb;\n  while ((1LL << bit) > x + y) { --bit; }\n  if (x >= (1LL << bit)) {\n    GF ans = Mul(base[bit], AddPositions(x ^ (1LL << bit), y));\n    debug(x, y, ans);\n    return memo[p] = ans;\n  }\n\n  // x < 2^bit <= x + y\n  GF answer1 = AddPositionsUpTo(x, y, (1LL << bit) - 1);\n  GF answer2 = AddPositionsFrom(x, y, (1LL << bit));\n  debug(x, y, answer1, answer2);\n  return memo[p] = Add(answer1, answer2);\n}\n\nGF GetValue(LL x) {\n  static map<LL, GF> val_memo;\n  auto it = val_memo.find(x);\n  if (it != val_memo.end()) { return it->nd; }\n\n  GF ans = 1;\n  for (int bit = 60; bit >= 0; --bit) {\n    if ((x >> bit) & 1) {\n      ans = Mul(base[bit], ans);\n    }\n  }\n  debug(\"Value\", x, ans);\n  return val_memo[x] = ans;\n}\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val) {\n  debug(\"?UpTo\", x, y, max_val);\n  if (x > max_val) { return 0; }\n  if (x + y <= max_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int bit = 60; bit >= 0; --bit) {\n    if (!((y >> bit) & 1)) { continue; }\n    const LL v = 1LL << bit;\n    y ^= v;\n\n    if (x + v - 1 <= max_val) {\n      debug(\"UpTo\", orig_x, orig_y, max_val, x, y);\n      answer = Add(answer, AddPositions(x, y));\n      x += v;\n    }\n  }\n  debug(answer);\n  if (x <= max_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF AddPositionsFrom(LL x, LL y, LL min_val) {\n  if (x + y < min_val) { return 0; }\n  if (x >= min_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int bit = 60; bit >= 0; --bit) {\n    if (!((y >> bit) & 1)) { continue; }\n    const LL v = 1LL << bit;\n    y ^= v;\n\n    if (x + v >= min_val) {\n      answer = Add(answer, AddPositions(x + v, y));\n    } else {\n      x += v;\n    }\n  }\n  debug(\"From\", orig_x, orig_y, min_val, answer, x);\n  if (x >= min_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF GetRandom() {\n  GF ans = 0;\n  for (int i = 0; i < 4; ++i) {\n    ans <<= 16;\n    ans |= (rand() % (1 << 16));\n  }\n  return ans;\n}\n\nint32_t main() {\n#ifndef LOCAL\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n#endif\n\n#ifdef TESTING\n  while (true) {\n    GF a = GetRandom(), b = GetRandom(), c = GetRandom();\n    GF d = Mul(a, Add(b, c));\n    GF e = Add(Mul(a, b), Mul(a, c));\n    debug(a,b,c,d,e);\n    assert(d == e);\n  }\n#endif\n\n  srand(2137);\n\n  const int S = 58;\n  const LL kLarge = 1LL << S;\n  for (int i = 0; i < 70; ++i) {\n    GF x = GetRandom();\n    base.PB(x);\n  }\n  debug(base);\n\n  int N;\n  cin >> N;\n  vector<pair<LL, LL>> values;\n\n  auto TotalGF = [&](LL bound) {\n    GF ans = 0;\n    for (auto &val : values) {\n      ans = Add(ans, AddPositionsUpTo(val.st, val.nd, bound));\n    }\n    debug(bound, ans);\n    return ans;\n  };\n\n  for (int i = 0; i < N; ++i) {\n    LL x, y;\n    cin >> x >> y;\n    values.emplace_back(x + kLarge, y + kLarge);\n  }\n\n  debug(values);\n\n  LL Lzero = 0, Rzero = (1LL << (S + 2));\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == 0) {\n      Lzero = midzero;\n    } else {\n      Rzero = midzero;\n    }\n  }\n\n  const LL first_x = Rzero - kLarge;\n  \n  Lzero = first_x + kLarge - 2; Rzero = (1LL << (S + 2));\n  const GF aim = TotalGF(Rzero);\n\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == aim) {\n      Rzero = midzero;\n    } else {\n      Lzero = midzero;\n    }\n  }\n\n  const LL last_x = Rzero - kLarge;\n\n  cout << first_x << \" \" << last_x - first_x - kLarge << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "%:pragma GCC optimize(\"Ofast\", \"inline\")\n#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\n  using namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\n#define int long long\nconst int N = 1e5 + 233;\nint inf = 1e17;\nint n, x[N], y[N], qy, ni[N];\nbool dp[65][2][3];\n\ninline bool get(int u, int n, int r) {\n  memset(dp, 0, sizeof dp);\n  int l = n - y[u];\n  l = min(l, ni[u]);\n  r = ((r - y[u]) % 3 + 3) % 3;\n  if (l < 0) return 0;\n  // o \\in[0, l] && o % 3 == r ni[u]Co module 2\n  // cout << l << \" \" << ni[u] << \" \" << r << \"\\n\";\n  dp[0][1][0] = 1; int cur = 0;\n  for (int i = 61; i >= 0; i--) {\n    ++cur;\n    for (int d = 0; d < 2; d++) {\n      for (int pr = 0; pr < 3; pr++) {\n\tint lim = d ? l >> i & 1 : 1;\n\tfor (int ch = 0; ch <= min(ni[u] >> i & 1, lim); ch++) {\n\t  int nd = d && ch == lim;\n\t  int nv = pr + (i & 1 ? -1 : 1) * ch;\n\t  nv = (nv % 3 + 3) % 3;\n\t  // if (i == 2 && d == 1 && pr == 0) {\n\t  //   cout << ch << \" \" << nd << \" \" << nv << \"\\n\";\n\t  // }\n\t  dp[cur][nd][nv] ^= dp[cur - 1][d][pr];\n\t}\n      }\n    }\n  }\n  int ans = 0;\n  for (int d = 0; d < 2; d++)\n    ans ^= dp[cur][d][r];\n  return ans;\n}\n\ninline bool calc(int l, int r, int remain) {\n  bool ans = 0;\n  rep (i, n) {\n    ans ^= get(i, r, remain) ^ get(i, l - 1, remain);\n    // cout << i << \" \" << get(i, r, remain) << \" \" <<  get(i, l - 1, remain) << \"\\n\";\n  }\n  return ans;\n}\n\nsigned main(void) {\n  srand(20021214);\n  read(n);\n  rep (i, n) {\n    read(x[i]), read(y[i]);\n    // mi_i = o - y_i\n  }\n  // cout << get(1, 4, 1) << \"\\n\";\n  // return 0;\n  // cout << calc(-4, 4, 1) << \"\\n\";\n  // return 0;\n  int tr = 0;\n  while (!tr) {\n    inf += rand() % 3;\n    rep (i, n) ni[i] = x[i] + inf;\n    re0 (r, 3) if (calc(-inf, inf, r) == true) {\n      tr = r;\n      break;\n    }\n  }\n  assert(calc(-inf, inf, tr) == true);\n  \n  int l = -inf, r = inf;\n  while (l < r) {\n    int mid = l + (r - l) / 2;\n    if (calc(l, mid, tr)) r = mid;\n    else l = mid + 1;\n  }\n  qy = r;\n  \n  auto isBlack = [&](int o) {\n    bool pa = 0;\n    rep (i, n) if (y[i] <= o && o <= x[i] + y[i] + inf) {\n      int nc = x[i] + inf;\n      int mc = o - y[i];\n      pa ^= nc == (nc | mc);\n    }\n    return pa;\n  };\n  assert(isBlack(qy) == true);\n  \n  int ty = qy, ansl, ansr;\n  \n  for (int k = 61; k >= 0; k--) {\n    if (isBlack(qy + (1ll << k))) {\n      qy += 1ll << k;\n    }\n  }\n  ansr = qy;\n  \n  qy = ty;\n  for (int k = 61; k >= 0; k--) {\n    if (isBlack(qy - (1ll << k))) {\n      qy -= 1ll << k;\n    }\n  }\n  ansl = qy;\n\n  cout << -inf + ansr - ansl << \" \" << ansl << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V vector #define L long #define W V<L>\nusing namespace std;L E=70,M=2e17,i,a,b;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].push_back({x[0]/2,++x[1]/2});}for(L i;i<2;i++){L c=0;for(W x:T[!i])c^=(2*x[0]+x[1])%3+1;if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){cin>>i;V<W>p(i);while(i--,cin>>a>>b)p[i]={a+M,b+M};W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1, 0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc + 1) % 2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0] && !c[1 - i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor (pin& v : ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 2e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<cassert>\n#include<vector>\n#include<fstream>\n#include<string>\n#include<stdio.h>\n#include<stdlib.h>\n#include<time.h>\n#include<queue>\n#include<map>\n#include<set>\n#include<bitset>\n#include<cmath>\n#include<typeinfo>\n\nusing namespace std;\n#define rep(i,m,n) for(int i=m;i<n;++i)\n#define repll(i,m,n) for(ll i=m;i<n;++i)\n#define llinf 100000000000000000\n#define inf 1000000000\n#define mod 1000000007\n#define ll long long\n#define mp make_pair\n#define all(v) v.begin(),v.end()\n\nvector<pair<ll, ll>>v;\nvector<ll>check;\n\nint main() {\n\tll n;\n\tcin >> n;\n\tll hoge = 1;\n\twhile (hoge < llinf) {\n\t\tcheck.push_back(hoge);\n\t\thoge <<= 1;\n\t}\n\trep(i, 0, n) {\n\t\tll a, b;\n\t\tcin >> a >> b;\n\t\tv.push_back(mp(a, b));\n\t}\n\tsort(all(v));\n\twhile (v.size() != 1) {\n\t\trep(i, 0, v.size()) {\n\t\t\tll a, b, c;\n\t\t\ta = v[i].first;\n\t\t\tb = v[i].second;\n\t\t\tc = a + b;\n\t\t\trep(j, i + 1, v.size()) {\n\t\t\t\tif (v[j].first == a) {\n\t\t\t\t\trep(k, 0, check.size()) {\n\t\t\t\t\t\tif (v[j].second - b == check[k]) {\n\t\t\t\t\t\t\tv.erase(v.begin() + j);\n\t\t\t\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\t\t\t\tv.push_back(mp(a + check[k], b));\n\t\t\t\t\t\t\tsort(all(v));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (v[j].second == b) {\n\t\t\t\t\trep(k, 0, check.size()) {\n\t\t\t\t\t\tif (v[j].first - a == check[k]) {\n\t\t\t\t\t\t\tv.erase(v.begin() + j);\n\t\t\t\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\t\t\t\tv.push_back(mp(a, b + check[k]));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (v[j].first + v[j].second == c) {\n\t\t\t\t\trep(k, 0, check.size()) {\n\t\t\t\t\t\tif (v[j].first - a == check[k]) {\n\t\t\t\t\t\t\tv.erase(v.begin() + j);\n\t\t\t\t\t\t\tv.erase(v.begin() + i);\n\t\t\t\t\t\t\tv.push_back(mp(a, b - check[k]));\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << v[0].first << \" \" << v[0].second << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll base = 1ll << 58;\nconst int LOG = 60;\nint main() {\n  do {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n  } while (false);\n  int n;\n  cin >> n;\n  vector<ll> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n    x[i] += base;\n    y[i] += base;\n  }\n  auto calc = [&] (ll sum, int r) {\n    bool res = false;\n    for (int i = 0; i < n; i++) {\n      if (y[i] < sum) {\n        ll limit = sum - y[i];\n        vector<bool> F(3), G(3);\n        F[0] = true;\n        for (int j = LOG; j >= 0; j--) {\n          vector<bool> F2(3), G2(3);\n          for (int k = 0; k < 3; k++) {\n            if (F[k]) {\n              for (int v = 0; v <= min(limit >> j & 1, x[i] >> j & 1); v++) {\n                int nxt = (k + v * (j & 1) + v) % 3;\n                if (v != (limit >> j & 1)) {\n                  G2[nxt].flip();\n                } else {\n                  F2[nxt].flip();\n                }\n              }\n            }\n            if (G[k]) {\n              for (int v = 0; v <= (x[i] >> j & 1); v++) {\n                int nxt = (k + v * (j & 1) + v) % 3;\n                G2[nxt].flip();\n              }\n            }\n          }\n          F = F2;\n          G = G2;\n        }\n        res ^= G[(r - y[i] % 3 + 3) % 3];\n      }\n    }\n    return res;\n  };\n  int r = 0;\n  while (r < 3 && !calc(1ll << LOG, r)) {\n    r++;\n  }\n  if (r == 3) {\n    return -1;\n  }\n  ll start = 0;\n  for (int i = LOG; i >= 0; i--) {\n    if (calc(start, r) == calc(start + (1ll << i), r)) {\n      start |= 1ll << i;\n    }\n  }\n  auto check = [&] (ll pos) {\n    bool res = false;\n    for (int i = 0; i < n; i++) {\n      if (y[i] <= pos && pos <= x[i] + y[i] && (x[i] & (pos - y[i])) == pos - y[i]) {\n        res ^= 1;\n      }\n    }\n    return res;\n  };\n  ll L = start, R = start;\n  for (int i = LOG; i >= 0; i--) {\n    if (check(L - (1ll << i))) {\n      L -= 1ll << i;\n    }\n    if (check(R + (1ll << i))) {\n      R += 1ll << i;\n    }\n  }\n  cout << R - L - base << \" \" << L - base << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1, 0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc + 1) % 2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0] && !c[1 - i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor (pin& v : ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = mkp(0,0);\n\tcout << ret.first - inf << \" \" << ret.second - inf;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long long\n#define W V<L>\n#define R(n) for(L i=0;i<n;i++)\nW S(V<W>&p,L E){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}V<W>c(4,W(3));c[3]=W(3,1);R(2){for(W x:T[i]){L Q=(2*x[0]+x[1])%3;c[i][Q]^=1;}}R(2){if(c[!i]==c[2]||c[!i]==c[3]){W ans=S(T[i],E-1);ans[0]*=2;ans[1]*=2;ans[1]+=i;return ans;}}for(W&v:p){v[0]++;}W A=S(p,E);A[0]--;return A;}\nint main(){L M=2e17;L n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}W Q=S(p,70);cout<<Q[0]-M<<\" \"<<Q[1]-M;}"
  },
  {
    "language": "C++",
    "code": "//Awwawa! Dis cold yis ratten buy tEMMIE!\n#include <bits/stdc++.h>\n#define ll long long\n#define maxn 10005 /*rem*/\n#define mod 998244353\n#define db double\n#define vi vector<int>\n#define pb push_back\n#define mp make_pair\n#define pi pair<int, int>\n#define fi first\n#define se second\n\ntemplate <typename T> bool chkmax(T &x,T y){return x<y?x=y,true:false;}\ntemplate <typename T> bool chkmin(T &x,T y){return x>y?x=y,true:false;}\n\nusing namespace std;\nll ksm(ll a, ll b) {\n   if (!b) return 1;\n   ll ns = ksm(a, b >> 1);\n   ns = ns * ns % mod;\n   if (b & 1) ns = ns * a % mod;\n   return ns;\n}\nconst ll inf = 2e17;\nll x[maxn][2];\nint cnt = 0;\n#define pl pair<ll, ll>\n#define vp vector<pl>\nint n;\nll ch(ll a) {\n\treturn (a & (-a)) == a;\n}\nvoid chk(int id) {\n\tfor (int j = 1; j <= cnt; j++) {\n\t\tif (j == id) continue;\n\t\tfor (int t = 0; t < 2; t++) {\n\t\t\tif (x[j][t] == x[id][t]) {\n\t\t\t\tll dv = abs(x[j][t ^ 1] - x[id][t ^ 1]);\n\t\t\t\tif (ch(dv)) {\n\t\t\t\t\tint nc = 0;\n\t\t\t\t\tll ex[2] = {0, 0};\n\t\t\t\t\tex[t] = x[j][t] + dv;\n\t\t\t\t\tex[t ^ 1] = min(x[j][t ^ 1], x[id][t ^ 1]);\n\t\t\t\t\tfor (int m = 1; m <= cnt; m++) {\n\t\t\t\t\t\tif (m == id || m == j) continue;\n\t\t\t\t\t\tnc++;\n\t\t\t\t\t\tx[nc][0] = x[m][0], x[nc][1] = x[m][1];\n\t\t\t\t\t}\n\t\t\t\t\tnc++;\n\t\t\t\t\tx[nc][0] = ex[0], x[nc][1] = ex[1];\n\t\t\t\t\tcnt = nc;\n\t\t\t\t\tchk(nc);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\nint check(ll a, ll b) {\n\t// 判断 a 是否 包含 b \n\tif (b < 0 || b > a) return 0;\n\treturn ((a & b) == b);\t \n}\nll cal(vp x) {\n\tll mn = inf;\n\tfor (auto v : x) \n\t\tmn = min(mn, v.se);\n\twhile (1) {\n\t\tint fl = 0;\n\t\tfor (auto v : x) \n\t\t\tif (check(v.fi + inf, mn - v.se)) fl ^= 1;\n\t\tif (fl) return mn;\n\t\tmn++;\n\t} \n}\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tll a, b;\n\t\tscanf(\"%lld%lld\", &a, &b);\t\n\t\tcnt++;\n\t\tx[cnt][0] = a;\n\t\tx[cnt][1] = b;\n\t\tchk(cnt);\n\t}\n\tvp s(cnt);\n\tfor (int i = 0; i < cnt; i++)\n\t\ts[i] = mp(x[i + 1][0], x[i + 1][1]);\n//\tfor (auto v : s) cout << v.fi << ' ' << v.se << endl;\n\tll fy = cal(s);\n\tfor (int i = 0; i < cnt; i++)\n\t\ts[i] = mp(x[i + 1][1], x[i + 1][0]);\n\tll fx = cal(s);\n\tcout << fx << ' ' << fy << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n  \tc=0;\n  \tfor (pin& x : qab[1]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n  \tif (!c) {\n\t\tans.first *= 2; ans.second *= 2;\n\t\treturn ans;\n\t}\n\tc = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second-1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t}\n\tans.first *= 2; ans.first++; ans.second *= 2; ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "// luogu-judger-enable-o2\n#include<bits/stdc++.h>\n#define ll long long\n#define uint unsigned\n#define ull unsigned ll\n#define db double\n#define pii pair<int,int>\n#define pll pair<ll,ll>\n#define pli pair<ll,int>\n#define vi vector<int>\n#define vpi vector<pii >\n#define IT iterator\n \n#define PB push_back\n#define MK make_pair\n#define LB lower_bound\n#define UB upper_bound\n#define y1 wzpakking\n#define fi first\n#define se second\n#define BG begin\n#define ED end\n \n#define For(i,j,k) for (int i=(int)(j);i<=(int)(k);i++)\n#define Rep(i,j,k) for (int i=(int)(j);i>=(int)(k);i--)\n#define CLR(a,v) memset(a,v,sizeof(a))\n#define CPY(a,b) memcpy(a,b,sizeof(a))\n#define sqr(x) (1ll*x*x)\n \n#define LS3 k*2,l,mid\n#define RS3 k*2+1,mid+1,r\n#define LS5 k*2,l,mid,x,y\n#define RS5 k*2+1,mid+1,r,x,y\n#define GET pushdown(k);int mid=(l+r)/2\n#define inf (1<<30)\n#define INF (1ll<<58)\nusing namespace std;\nint n,f[2][3],g[2][3];\nll x[100005],y[100005];\nbool calc(ll pos){\n\tbool ans=0;\n\tFor(i,1,n){\n\t\tll v=pos-y[i];\n\t\tif (v>=0&&(x[i]&v)==v) ans^=1;\n\t}\n\treturn ans;\n}\nbool solve(ll S,int rem){\n\tbool ans=0;\n\tFor(i,1,n) if (y[i]<S){\n\t\tll lim=S-y[i];\n\t\tFor(v,0,2) f[0][v]=(v==0),f[1][v]=0;\n\t\tRep(j,60,0){\n\t\t\tFor(v,0,2) g[0][v]=g[1][v]=0;\n\t\t\tFor(fl,0,1){\n\t\t\t\tint mx=(x[i]>>j)&1;\n\t\t\t\tif (!fl&&!((lim>>j)&1)) mx=0;\n\t\t\t\tFor(v,0,2) if (f[fl][v])\n\t\t\t\t\tFor(vnow,0,mx){\n\t\t\t\t\t\tint to=(v+vnow*((j&1)+1))%3;\n\t\t\t\t\t\tg[fl|(((lim>>j)&1)^vnow)][to]^=1;\n\t\t\t\t\t}\n\t\t\t}\n\t\t\tFor(v,0,2){\n\t\t\t\tf[0][v]=g[0][v];\n\t\t\t\tf[1][v]=g[1][v];\n\t\t\t}\n\t\t}\n\t\tans^=f[1][(rem-y[i]%3+3)%3];\n\t}\n\treturn ans;\n}\nint main(){\n\tscanf(\"%d\",&n);\n\tFor(i,1,n){\n\t\tscanf(\"%lld%lld\",&x[i],&y[i]);\n\t\tx[i]+=INF; y[i]+=INF;\n\t}\n\tint spe=0;\n\tfor (;!solve(1ll<<60,spe);++spe);\n\tll pos=0;\n\tRep(i,59,0)\n\t\tif (solve(pos,spe)==solve(pos+(1ll<<i),spe))\n\t\t\tpos+=1ll<<i;\n\tll l=pos,r=pos;\n\tRep(i,59,0){\n\t\tif (calc(l-(1ll<<i))) l-=1ll<<i;\n\t\tif (calc(r+(1ll<<i))) r+=1ll<<i;\n\t}\n\tprintf(\"%lld %lld\\n\",r-l-INF,l-INF);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n    int N; cin>>N;\n    vector<long long> x(N), y(N);\n    for (int i=0; i<N; i++)\n        cin>>x[i]>>y[i];\n\n    //  https://img.atcoder.jp/wtf19-open/editorial.pdf\n    long long c = 1LL<<60;\n    \n    //  y = c の直線上のランプのみが点灯するようにしたときに、\n    //  x%m = r を満たす (x, c) のランプが点灯しているか\n    //  m = 2^k\n    //  mが充分に大きければ、(r, y) のランプが点灯しているかどうかになる\n    auto check = [&](long long m, long long r)\n    {\n        bool ret = false;\n        //  (r, c) のランプが点灯している ⇔ XOR[0<=i<N]((c-y[i]) | ~(r-x[i]) の全てのビットが立っている)\n        //  下位kビット目まで考えれば、残りの必要なビットが立っているxが存在するので、\n        //  上位ビットは単に無視すれば良い\n        for (int i=0; i<N; i++)\n            if (!~( ((c-y[i]) | ~(r-x[i])) | ~(m-1) ))\n                ret = !ret;\n        return ret;\n    };\n\n    //  (p, c) のランプが付いているpを求める\n    //  check(m, x) が真ならば、check(2*m, x) か check(2*m, x+m) のどちらか少なくとも一方は真である\n    //  x>=0 に必ず点灯しているランプがあり、pはなるべく小さくなるように求めているので、\n    //  pが負になることは考慮しなくて良い\n    long long p = 0;\n    for (int k=0; k<60; k++)\n        if (!check(1LL<<(k+1), p))\n            p |= 1LL<<k;\n\n    long long l = p;\n    for (int k=60; k>=0; k--)\n        if (check(1LL<<61, l-(1LL<<k)))\n            l -= 1LL<<k;\n    long long r = p;\n    for (int k=60; k>=0; k--)\n        if (check(1LL<<61, r+(1LL<<k)))\n            r += 1LL<<k;\n    cout<<l<<\" \"<<c-(r-l)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}for(L i;i<2;i++){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n,a,b;cin>>n;V<W>p(n);while(n--){cin>>a>>b;p[n]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1, 0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc + 1) % 2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0] && !c[1 - i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor (pin& v : ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 1e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 55);\n\tcout << ret.first - inf << \" \" << ret.second - inf;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n          c[i][0]^=(qc+1);c[i][1]^=qc;\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!((c[1 - i][0])&1)&&!c[1-i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\nvoid tostr(ll x,string& res){while(x)res+=('0'+(x%10)),x/=10; reverse(ALL(res)); return;}\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//end\n\nconstexpr ll c=200'000'000'000'000'000LL;\nint N; ll x[11000],y[11000];\nbool que(ll n,ll r){if(n<0||r<0||n<r)return 0; return (n&r)==r;}\nbool col(ll a){\n   bool res=0;\n   rep(i,0,N)if(a>=x[i])res^=que(c-x[i]-y[i],a-x[i]);\n   return res;\n}\nll cnt[3];\nvoid calc(ll n,ll t){\n   if(t<0){rep(i,0,3)cnt[i]=0; return;}\n   chmin(t,n); ll dp[64][3][2]={}; dp[60][0][1]=1;\n   rrep(i,59,-1)rep(j,0,3)rep(k,0,2)if(dp[i+1][j][k]){\n      rep(nxt,0,2){\n         if((n>>i&1)==0&&nxt)continue;\n         if(k&&nxt&&(t>>i&1)==0)continue;\n         int nj=(j+(nxt?(i&1?2:1):0))%3,nk=k;\n         if(nxt==0&&(t>>i&1))nk=0;\n         dp[i][nj][nk]+=dp[i+1][j][k];\n      }\n   }\n   rep(i,0,3)cnt[i]=dp[0][i][0]+dp[0][i][1];\n}\nll rng(ll n,ll lb,ll rb,int r){\n   calc(n,rb); ll res=cnt[r];\n   calc(n,lb); res-=cnt[r];\n   return res;\n}\nbool flag(ll lb,ll rb,int r){\n   bool res=0;\n   rep(i,0,N)res^=rng(c-x[i]-y[i],lb-x[i],rb-x[i],((r-x[i])%3+3)%3)&1;\n   return res;\n}\n\n//reference:https://physics0523.hatenablog.com/entry/2019/02/26/190724\nint main(){\n   scanf(\"%d\",&N); rep(i,0,N)scanf(\"%lld%lld\",&x[i],&y[i]);\n   ll lb=-c/2,rb=c/2;\n   while(rb-lb>1){\n      ll mid=(lb+rb)>>1; bool f=0;\n      rep(r,0,3)if(flag(lb,mid,r)){f=1; break;}\n      if(f)rb=mid; else lb=mid;\n   }\n   assert(col(rb));\n   ll x1=rb,x2=rb;\n   rrep(k,62,-1){\n      if(col(x1-(1LL<<k)))x1-=1LL<<k;\n      if(col(x2+(1LL<<k)))x2+=1LL<<k;\n   }\n   printf(\"%lld %lld\\n\",x1,c-x2);\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nusing GF = uint64_t;\n\ninline GF Add(GF a, GF b) {\n  return a ^ b;\n}\n\n/*inline GF Mul(GF a, GF b) {\n  const GF kBase = (1 << 11) | (1 << 1) | 1;\n  __uint128_t mul = 0;\n  for (int i = 0; i < 64; ++i) {\n    if ((b >> i) & 1) {\n      mul ^= ((__uint128_t)a << i);\n    }\n  }\n  for (int i = 63; i >= 0; --i) {\n    if ((mul >> (i + 64)) & 1) {\n      mul ^= (__uint128_t)kBase << i;\n    }\n  }\n  return (GF)mul;\n}*/\n\ninline GF Mul(GF a, GF b) {\n  const GF kBase[2] = {0, (1 << 11) | (1 << 1) | 1};\n  GF ans = 0;\n  for (int i = 0; i < 64; ++i) {\n    if ((b >> i) & 1) {\n      ans ^= a;\n    }\n    a = (a << 1) ^ kBase[a >> 63];\n  }\n  return ans;\n}\n\nvector<GF> base;\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val);\nGF AddPositionsFrom(LL x, LL y, LL min_val);\n\nmap<pair<LL, LL>, GF> memo;\nGF AddPositions(LL x, LL y, int bb = 60) {\n  if (x == 0 && y == 0) { return 1; }\n  debug(\"?Any\", x, y);\n  \n  pair<LL, LL> p{x, y};\n  if (memo.count(p)) { return memo[p]; }\n\n  int bit = bb;\n  while ((1LL << bit) > x + y) { --bit; }\n  if (x >= (1LL << bit)) {\n    GF ans = Mul(base[bit], AddPositions(x ^ (1LL << bit), y));\n    debug(x, y, ans);\n    return memo[p] = ans;\n  }\n\n  // x < 2^bit <= x + y\n  GF answer1 = AddPositionsUpTo(x, y, (1LL << bit) - 1);\n  GF answer2 = AddPositionsFrom(x, y, (1LL << bit));\n  debug(x, y, answer1, answer2);\n  return memo[p] = Add(answer1, answer2);\n}\n\nGF GetValue(LL x) {\n  GF ans = 1;\n  for (int bit = 60; bit >= 0; --bit) {\n    if ((x >> bit) & 1) {\n      ans = Mul(ans, base[bit]);\n    }\n  }\n  debug(\"Value\", x, ans);\n  return ans;\n}\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val) {\n  debug(\"?UpTo\", x, y, max_val);\n  if (x > max_val) { return 0; }\n  if (x + y <= max_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int bit = 60; bit >= 0; --bit) {\n    if (!((y >> bit) & 1)) { continue; }\n    const LL v = 1LL << bit;\n    y ^= v;\n\n    if (x + v - 1 <= max_val) {\n      debug(\"UpTo\", orig_x, orig_y, max_val, x, y);\n      answer = Add(answer, AddPositions(x, y));\n      x += v;\n    }\n  }\n  debug(answer);\n  if (x <= max_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF AddPositionsFrom(LL x, LL y, LL min_val) {\n  if (x + y < min_val) { return 0; }\n  if (x >= min_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int bit = 60; bit >= 0; --bit) {\n    if (!((y >> bit) & 1)) { continue; }\n    const LL v = 1LL << bit;\n    y ^= v;\n\n    if (x + v >= min_val) {\n      answer = Add(answer, AddPositions(x + v, y));\n    } else {\n      x += v;\n    }\n  }\n  debug(\"From\", orig_x, orig_y, min_val, answer, x);\n  if (x >= min_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF GetRandom() {\n  GF ans = 0;\n  for (int i = 0; i < 4; ++i) {\n    ans <<= 16;\n    ans |= (rand() % (1 << 16));\n  }\n  return ans;\n}\n\nint32_t main() {\n#ifndef LOCAL\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n#endif\n\n  srand(69);\n\n  const int S = 58;\n  const LL kLarge = 1LL << S;\n  for (int i = 0; i < 70; ++i) {\n    base.PB(GetRandom());\n  }\n  debug(base);\n\n  int N;\n  cin >> N;\n  vector<pair<LL, LL>> values;\n\n  auto TotalGF = [&](LL bound) {\n    GF ans = 0;\n    for (auto &val : values) {\n      ans = Add(ans, AddPositionsUpTo(val.st, val.nd, bound));\n    }\n    debug(bound, ans);\n    return ans;\n  };\n\n  for (int i = 0; i < N; ++i) {\n    LL x, y;\n    cin >> x >> y;\n    values.emplace_back(x + kLarge, y + kLarge);\n  }\n\n  debug(values);\n\n  LL Lzero = 0, Rzero = (1LL << (S + 2));\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == 0) {\n      Lzero = midzero;\n    } else {\n      Rzero = midzero;\n    }\n  }\n\n  const LL first_x = Rzero - kLarge;\n  \n  Lzero = first_x + kLarge - 2; Rzero = (1LL << (S + 2));\n  const GF aim = TotalGF(Rzero);\n\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == aim) {\n      Rzero = midzero;\n    } else {\n      Lzero = midzero;\n    }\n  }\n\n  const LL last_x = Rzero - kLarge;\n\n  cout << first_x << \" \" << last_x - first_x - kLarge << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n          c[i][0]^=((qc+1)&1);\n          c[i][1]^=(qc&1);\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0]&&!c[1-i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\tV<vel> c(4, vel(3));c[3]=vel(3,1);\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n          c[i][qc]^=1;\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (c[1-i]!=c[3]&&c[1-i]!=c[2]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"O3\")\n#pragma GCC target (\"sse4\")\n\n#include <bits/stdc++.h>\n#include <ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/rope>\n\nusing namespace std;\nusing namespace __gnu_pbds;\nusing namespace __gnu_cxx;\n \ntypedef long long ll;\ntypedef long double ld;\ntypedef complex<ld> cd;\n\ntypedef pair<int, int> pi;\ntypedef pair<ll,ll> pl;\ntypedef pair<ld,ld> pd;\n\ntypedef vector<int> vi;\ntypedef vector<ld> vd;\ntypedef vector<ll> vl;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<cd> vcd;\n\ntemplate <class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag,tree_order_statistics_node_update>;\n\n#define FOR(i, a, b) for (int i = (a); i < (b); i++)\n#define F0R(i, a) for (int i = 0; i < (a); i++)\n#define FORd(i,a,b) for (int i = (b)-1; i >= (a); i--)\n#define F0Rd(i,a) for (int i = (a)-1; i >= 0; i--)\n#define trav(a, x) for (auto& a : x)\n\n#define mp make_pair\n#define pb push_back\n#define f first\n#define s second\n#define lb lower_bound\n#define ub upper_bound\n\n#define sz(x) (int)x.size()\n#define all(x) begin(x), end(x)\n#define rsz resize\n\nconst int MOD = 1000000007; // 998244353\nconst ll INF = 1e18;\nconst int MX = 200005;\nconst ld PI = 4*atan((ld)1);\n\ntemplate<class T> void ckmin(T &a, T b) { a = min(a, b); }\ntemplate<class T> void ckmax(T &a, T b) { a = max(a, b); }\n\nnamespace input {\n    template<class T> void re(complex<T>& x);\n    template<class T1, class T2> void re(pair<T1,T2>& p);\n    template<class T> void re(vector<T>& a);\n    template<class T, size_t SZ> void re(array<T,SZ>& a);\n\n    template<class T> void re(T& x) { cin >> x; }\n    void re(double& x) { string t; re(t); x = stod(t); }\n    void re(ld& x) { string t; re(t); x = stold(t); }\n    template<class Arg, class... Args> void re(Arg& first, Args&... rest) { \n        re(first); re(rest...); \n    }\n\n    template<class T> void re(complex<T>& x) { T a,b; re(a,b); x = cd(a,b); }\n    template<class T1, class T2> void re(pair<T1,T2>& p) { re(p.f,p.s); }\n    template<class T> void re(vector<T>& a) { F0R(i,sz(a)) re(a[i]); }\n    template<class T, size_t SZ> void re(array<T,SZ>& a) { F0R(i,SZ) re(a[i]); }\n}\n\nusing namespace input;\n\nnamespace output {\n    template<class T1, class T2> void pr(const pair<T1,T2>& x);\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x);\n    template<class T> void pr(const vector<T>& x);\n    template<class T> void pr(const set<T>& x);\n    template<class T1, class T2> void pr(const map<T1,T2>& x);\n\n    template<class T> void pr(const T& x) { cout << x; }\n    template<class Arg, class... Args> void pr(const Arg& first, const Args&... rest) { \n        pr(first); pr(rest...); \n    }\n\n    template<class T1, class T2> void pr(const pair<T1,T2>& x) { \n        pr(\"{\",x.f,\", \",x.s,\"}\"); \n    }\n    template<class T> void prContain(const T& x) {\n        pr(\"{\");\n        bool fst = 1; for (const auto& a: x) pr(!fst?\", \":\"\",a), fst = 0; // const needed for vector<bool>\n        pr(\"}\");\n    }\n    template<class T, size_t SZ> void pr(const array<T,SZ>& x) { prContain(x); }\n    template<class T> void pr(const vector<T>& x) { prContain(x); }\n    template<class T> void pr(const set<T>& x) { prContain(x); }\n    template<class T1, class T2> void pr(const map<T1,T2>& x) { prContain(x); }\n    \n    void ps() { pr(\"\\n\"); }\n    template<class Arg> void ps(const Arg& first) { \n        pr(first); ps(); // no space at end of line\n    }\n    template<class Arg, class... Args> void ps(const Arg& first, const Args&... rest) { \n        pr(first,\" \"); ps(rest...); // print w/ spaces\n    }\n}\n\nusing namespace output;\n\nnamespace io {\n    void setIn(string s) { freopen(s.c_str(),\"r\",stdin); }\n    void setOut(string s) { freopen(s.c_str(),\"w\",stdout); }\n    void setIO(string s = \"\") {\n        ios_base::sync_with_stdio(0); cin.tie(0); // fast I/O\n        if (sz(s)) { setIn(s+\".in\"), setOut(s+\".out\"); } // for USACO\n    }\n}\n\nusing namespace io;\n\ntemplate<class T> T invGeneral(T a, T b) {\n    a %= b; if (a == 0) return b == 1 ? 0 : -1;\n    T x = invGeneral(b,a); \n    return x == -1 ? -1 : ((1-(ll)b*x)/a+b)%b;\n}\n\ntemplate<class T> struct modular {\n    T val; \n    explicit operator T() const { return val; }\n    modular() { val = 0; }\n    template<class U> modular(const U& v) {\n        val = (-MOD <= v && v <= MOD) ? v : v % MOD;\n        if (val < 0) val += MOD;\n    }\n    friend ostream& operator<<(ostream& os, const modular& a) { return os << a.val; }\n    friend bool operator==(const modular& a, const modular& b) { return a.val == b.val; }\n    friend bool operator!=(const modular& a, const modular& b) { return !(a == b); }\n\n    modular operator-() const { return modular(-val); }\n    modular& operator+=(const modular& m) { if ((val += m.val) >= MOD) val -= MOD; return *this; }\n    modular& operator-=(const modular& m) { if ((val -= m.val) < 0) val += MOD; return *this; }\n    modular& operator*=(const modular& m) { val = (ll)val*m.val%MOD; return *this; }\n    friend modular exp(modular a, ll p) {\n        modular ans = 1; for (; p; p /= 2, a *= a) if (p&1) ans *= a;\n        return ans;\n    }\n    friend modular inv(const modular& a) { \n        auto i = invGeneral(a.val,MOD); assert(i != -1);\n        return i;\n    } // equivalent to return exp(b,MOD-2) if MOD is prime\n    modular& operator/=(const modular& m) { return (*this) *= inv(m); }\n    \n    friend modular operator+(modular a, const modular& b) { return a += b; }\n    friend modular operator-(modular a, const modular& b) { return a -= b; }\n    friend modular operator*(modular a, const modular& b) { return a *= b; }\n    \n    friend modular operator/(modular a, const modular& b) { return a /= b; }\n};\n\ntypedef modular<int> mi;\ntypedef pair<mi,mi> pmi;\ntypedef vector<mi> vmi;\ntypedef vector<pmi> vpmi;\n\nint N;\nvpl v;\n\nll rem(ll a, ll b) {\n    return (a%b+b)%b;\n}\n\nbool calc(pl t, int r3, pl r) {\n    ll h = t.s+(ll)(1e17);\n    ll ad = rem(r.f-t.f,1LL<<r.s);\n    int R3 = rem(t.f,3);\n    vi cnt(3);\n    F0R(i,60) {\n        int tmp = (1LL<<i)%3;\n        if (i < r.s) {\n            if (ad&(1LL<<i)) {\n                if (!(h&(1LL<<i))) return 0;\n                R3 = (R3+tmp)%3;\n            }\n        } else if (h&(1LL<<i)) {\n            cnt[tmp] ++;\n        }\n    }\n    vi cur(3); cur[R3] = 1;\n    F0R(i,cnt[1]) {\n        cur = {cur[0]^cur[2],cur[1]^cur[0],cur[2]^cur[1]};\n    }\n    F0R(i,cnt[2]) {\n        cur = {cur[0]^cur[1],cur[1]^cur[2],cur[2]^cur[0]};\n    }\n    return cur[r3];\n}\n\nbool calc(int r3, pl r) {\n    bool res = 0;\n    trav(t,v) res ^= calc(t,r3,r);\n    return res;\n}\n\n\nbool ok(pl CUR) {\n    bool res = 0;\n    trav(t,v) {\n        ll a = CUR.f-t.f, b = t.s-CUR.s;\n        if (0 <= a && a <= b && !(a&(b^a))) res ^= 1;\n    }\n    return res;\n}\n\nll lef(ll a, ll b) {\n    F0Rd(i,60) if (ok({a-(1LL<<i),b})) a -= 1LL<<i;\n    return a;\n}\n\nll ri(ll a, ll b) {\n    F0Rd(i,60) if (ok({a+(1LL<<i),b})) a += 1LL<<i;\n    return a;\n}\n\nint main() {\n    setIO(); re(N); v.rsz(N); re(v);\n    int r3 = 0; pl r = {0,0};\n    while (!calc(r3,r)) r3 ++;\n    while (r.s < 59) {\n        if (!calc(r3,{r.f,r.s+1})) r.f += 1LL<<r.s;\n        r.s ++; // assert(calc(r3,r));\n    }\n    // ps(r3,r,1LL<<59);\n    ll res = r.f; while (res%3 != r3) res += 1LL<<r.s;\n    while (abs(res-3*(1LL<<r.s)) < abs(res)) res -= 3*1LL<<r.s;\n    auto a = lef(res,-1e17), b = ri(res,-1e17);\n    ps(a,b-a-(ll)(1e17));\n}\n\n\n/* stuff you should look for\n    * int overflow, array bounds\n    * special cases (n=1?), set tle\n    * do smth instead of nothing and stay organized\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"sse2,pclmul,tune=native\")\n#pragma GCC optimize(\"O3\")\n#include <ext/pb_ds/assoc_container.hpp>\n#include <nmmintrin.h>\n#include <emmintrin.h>\n#include <wmmintrin.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nusing GF = uint32_t;\n\ninline GF Add(GF a, GF b) {\n  return a ^ b;\n}\n\ninline GF Mul(GF a, GF b) {\n  __m128i xa = _mm_cvtsi64_si128(a), xb = _mm_cvtsi64_si128(b);\n  xa = _mm_clmulepi64_si128(xa, xb, 0x00);\n  uint64_t res = _mm_cvtsi128_si64(xa);\n  GF hi = res >> 32;\n  GF a0 = hi ^ (hi >> 25) ^ (hi >> 29) ^ (hi >> 30);\n  return (GF)res ^ a0 ^ (a0 << 2) ^ (a0 << 3) ^ (a0 << 7);\n}\n\nvector<GF> base;\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val);\nGF AddPositionsFrom(LL x, LL y, LL min_val);\n\nconst int MemoSize = 1 << 24;\n\npair<LL, LL> other_hash[MemoSize];\nGF memo[MemoSize];\n\nuint64_t Hash1(const pair<LL, LL> &p) {\nusing U = uint64_t;\n  uint64_t y = ((U)p.st * 0x123456789ABCDEFLL) ^ ((U)p.nd * 0xFEDCBA987654321LL);\n  return y ^ ((((U)p.st >> 32) * 0x019428711LL) + (((U)p.nd >> 24) * 0x593285392LL));\n}\n\nuint64_t Hash2(const pair<LL, LL> &p) {\n  return p.st + p.nd + (p.st ^ p.nd) + 17;\n}\n\nbool FindVal(const pair<LL, LL> &p, GF &ans) {\n  constexpr uint64_t kMask = MemoSize - 1;\n  auto h1 = Hash1(p) & kMask, h2 = Hash2(p);\n  for (int i = 0; other_hash[h1] != pair<LL, LL>{0, 0} && other_hash[h1] != p; ++i) {\n    h1 = (h1 + i) & kMask;\n  }\n  if (other_hash[h1] == p) {\n    ans = memo[h1];\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid PutVal(const pair<LL, LL> &p, const GF val) {\n  constexpr uint64_t kMask = MemoSize - 1;\n  auto h1 = Hash1(p) & kMask, h2 = Hash2(p);\n  for (int i = 0; other_hash[h1] != pair<LL, LL>{0, 0}; ++i) {\n    h1 = (h1 + i) & kMask;\n  }\n  other_hash[h1] = p; //h2;\n  memo[h1] = val;\n}\n\n//map<pair<LL, LL>, GF> memo;\nGF AddPositions(LL x, LL y, int bb = 60) {\n  if (x == 0 && y == 0) { return 1; }\n  debug(\"?Any\", x, y);\n  \n  pair<LL, LL> p{x, y};\n  {\n    GF ans;\n    if (FindVal(p, ans)) { return ans; }\n  }\n\n  int bit = bb;\n  while ((1LL << bit) > x + y) { --bit; }\n  if (x >= (1LL << bit)) {\n    GF ans = Mul(base[bit], AddPositions(x ^ (1LL << bit), y));\n    debug(x, y, ans);\n    PutVal(p, ans);\n    return ans;\n  }\n\n  // x < 2^bit <= x + y\n  GF answer1 = AddPositionsUpTo(x, y, (1LL << bit) - 1);\n  GF answer2 = AddPositionsFrom(x, y, (1LL << bit));\n  debug(x, y, answer1, answer2);\n  answer1 = Add(answer1, answer2);\n  PutVal(p, answer1);\n  return answer1;\n}\n\nGF GetValue(LL x) {\n  static map<LL, GF> val_memo;\n  auto it = val_memo.find(x);\n  if (it != val_memo.end()) { return it->nd; }\n\n  GF ans = 1;\n  for (int bit = 60; bit >= 0; --bit) {\n    if ((x >> bit) & 1) {\n      ans = Mul(base[bit], ans);\n    }\n  }\n  debug(\"Value\", x, ans);\n  return val_memo[x] = ans;\n}\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val) {\n  debug(\"?UpTo\", x, y, max_val);\n  if (x > max_val) { return 0; }\n  if (x + y <= max_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int bit = 60; bit >= 0; --bit) {\n    if (!((y >> bit) & 1)) { continue; }\n    const LL v = 1LL << bit;\n    y ^= v;\n\n    if (x + v - 1 <= max_val) {\n      debug(\"UpTo\", orig_x, orig_y, max_val, x, y);\n      answer = Add(answer, AddPositions(x, y));\n      x += v;\n    }\n  }\n  debug(answer);\n  if (x <= max_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF AddPositionsFrom(LL x, LL y, LL min_val) {\n  if (x + y < min_val) { return 0; }\n  if (x >= min_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int bit = 60; bit >= 0; --bit) {\n    if (!((y >> bit) & 1)) { continue; }\n    const LL v = 1LL << bit;\n    y ^= v;\n\n    if (x + v >= min_val) {\n      answer = Add(answer, AddPositions(x + v, y));\n    } else {\n      x += v;\n    }\n  }\n  debug(\"From\", orig_x, orig_y, min_val, answer, x);\n  if (x >= min_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF GetRandom() {\n  GF ans = 0;\n  for (int i = 0; i < 4; ++i) {\n    ans <<= 16;\n    ans |= (rand() % (1 << 16));\n  }\n  return ans;\n}\n\nint32_t main() {\n#ifndef LOCAL\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n#endif\n\n#ifdef TESTING\n  while (true) {\n    GF a = GetRandom(), b = GetRandom(), c = GetRandom();\n    GF d = Mul(a, Add(b, c));\n    GF e = Add(Mul(a, b), Mul(a, c));\n    debug(a,b,c,d,e);\n    assert(d == e);\n  }\n#endif\n\n  srand(2137);\n\n#warning\n  const int S = 58;\n//  const int S = 58;\n  const LL kLarge = 1LL << S;\n  for (int i = 0; i < 70; ++i) {\n    GF x = GetRandom();\n    base.PB(x);\n  }\n  debug(base);\n\n  int N;\n  cin >> N;\n  vector<pair<LL, LL>> values;\n\n  auto TotalGF = [&](LL bound) {\n    GF ans = 0;\n    for (auto &val : values) {\n      ans = Add(ans, AddPositionsUpTo(val.st, val.nd, bound));\n    }\n    debug(bound, ans);\n    return ans;\n  };\n\n  for (int i = 0; i < N; ++i) {\n    LL x, y;\n    cin >> x >> y;\n    values.emplace_back(x + kLarge, y + kLarge);\n  }\n\n  debug(values);\n\n  LL Lzero = 0, Rzero = (1LL << (S + 2));\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == 0) {\n      Lzero = midzero;\n    } else {\n      Rzero = midzero;\n    }\n  }\n\n  const LL first_x = Rzero - kLarge;\n  \n  Lzero = 0; Rzero = (1LL << (S + 2));\n  const GF aim = TotalGF(Rzero);\n\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == aim) {\n      Rzero = midzero;\n    } else {\n      Lzero = midzero;\n    }\n  }\n\n  const LL last_x = Rzero - kLarge;\n\n  cout << first_x << \" \" << last_x - first_x - kLarge << \"\\n\";\n  //cout << memo.size() << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n      \tint qc=2*x.first+x.second;\n        qc=(qc&(0xffffffff))+((qc&(0xfffffff00000000))>>32);\n      \tqc=(qc&(0xffff))+((qc&(0xffff0000))>>16);\n      \tqc=(qc&(0xff))+((qc&(0xff00))>>8);\n      \tqc=(qc&(0xf))+((qc&(0xf0))>>4);\n      \tqc=(qc&3)+((qc&12)>>2);\n      \tqc=(qc&3)+((qc&12)>>2);\n        qc=(qc&3)+((qc&12)>>2);\n        qc=(qc&3)+((qc&12)>>2);\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\n#define R(n)for(L i;i<n;i++)\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n,a,b;cin>>n;V<W>p(n);R(n){cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long long\n#define W V<L>\n#define R(n) for(L i=0;i<n;i++)\nL E=70;\nW S(V<W>p,L E){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}\nint main(){L M=2e17,n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}cout<<S(p)[0]-M<<\" \";E=70;cout<<S(p)[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define vel V<long long>\n#define rep(i,n) for(int i=0;i<n;i++)\nvel solve(V<vel>& ab, int ex) {\n\tif (!ex) { return { 1, 0 }; }\n\tV<V<vel>> qab(2);\n\tfor (vel x : ab) {\n\t\tqab[x[1] & 1].push_back({ x[0] / 2,x[1] / 2 });\n\t\tif (x[0] & 1) { qab[(x[1] + 1) & 1].push_back({ x[0] / 2,(x[1] + 1) / 2 }); }\n\t}\n\tV<vel> c(3, vel(2));\n\trep(i, 2) {\n\t\tfor (vel x : qab[i]) {\n\t\t\tint qc = (2 * x[0] + x[1]) % 3;\n\t\t\tif ((qc+1)%2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (c[1 - i] == c[2]) {\n\t\t\tvel ans = solve(qab[i], ex - 1);\n\t\t\tans[0] *= 2; ans[1] *= 2; ans[1] += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(vel &v:ab) { v[0]++; }\n\tvel ans = solve(ab, ex); ans[0]--;\n\treturn ans;\n}\nint main() {\n\tlong long inf = 2e17;\n\tint n; cin >> n;\n\tV<vel> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tvel ret = solve(ab, 70);\n\tcout << ret[0] - inf << \" \" << ret[1] - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t}\n  \tans.first *= 2; ans.second *= 2;\n\tans.first+=(c|d); ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1, 0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc + 1) % 2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0] && !c[1 - i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first<<1; ans.second<<1; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor (pin& v : ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 2e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MOD 1000000007\n#define INF (1<<29)\n#define LINF (1LL<<60)\n#define EPS (1e-10)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\nmultiset<P> poInts;\nInt n;\nInt res;\n\nint main(){\n  cin >> n;\n  for(Int i = 0;i < n;i++){\n    P a;\n    cin >> a.first >> a.second;\n    poInts.insert(a);\n  }\n\n  while(true){\n    auto it = poInts.begin();\n    if(poInts.size() == 1){\n      res = it->first;break;\n    }\n    auto jt = it;jt++;\n    if(it->first != jt->first){\n      res = it->first;break;\n    }\n    Int x = it->first;\n    Int ya = it->second, yb = jt->second;\n    Int dist = yb - ya;\n    while(dist){\n      Int k = dist & -dist;\n      poInts.insert(P(x + k, ya));\n      \n      dist -= k;\n      ya += k;\n    }\n    poInts.erase(poInts.begin());\n    poInts.erase(poInts.begin());\n  }\n  cout << res << endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define sz(v) ((int)(v).size())\n#define all(v) (v).begin(), (v).end()\nusing namespace std;\nusing lint = long long;\nusing pi = pair<lint, lint>;\nconst int MAXN = 10005;\nconst lint inf = 1e17;\n\nint n; \npi a[MAXN], b[MAXN];\nbool dp[61][3][2];\n\nbool on(lint x, lint y){\n\tbool ans = 0;\n\tfor(int i=0; i<n; i++){\n\t\tlint px = x - a[i].first;\n\t\tlint py = a[i].second - y;\n\t\tif(py >= 0 && px >= 0 && (px & py) == px) ans ^= 1;\n\t}\n\treturn ans;\n}\n\nbool query(lint l, int m){ \n\tl = 3 * l + m;\n\tbool ans = 0;\n\tfor(int i=0; i<n; i++){\n\t\tlint x = l - a[i].first;\n\t\tlint y = a[i].second;\n\t\tif(x <= 0) continue;\n\t\tmemset(dp, 0, sizeof(dp));\n\t\tdp[0][(m - a[i].first % 3 + 3) % 3][0] = 1;\n\t\tfor(int j=1; j<=60; j++){\n\t\t\tbool hasbit = (y >> (j - 1)) & 1;\n\t\t\tfor(int k=0; k<3; k++){\n\t\t\t\tdp[j][k][0] = dp[j-1][k][0] ^ (hasbit & dp[j-1][(k + (1ll<<(j-1)))%3][0]);\n\t\t\t\tif((x >> (j-1)) & 1){\n\t\t\t\t\tdp[j][k][1] = dp[j-1][k][0] ^ (hasbit * dp[j-1][(k + (1ll<<(j-1)))%3][1]);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tdp[j][k][1] = dp[j-1][k][1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tans ^= dp[60][0][1];\n\t}\n\treturn ans;\n}\n\npi get_coord(){\n\tlint s = 0, e = (1ll << 58);\n\tint i = 0;\n\twhile(i < 3 && query(s, i) == query(e, i)) i++;\n\tfor(int it=0; it<58; it++){\n\t\tlint m = (s+e)/2;\n\t\tif(query(s, i) != query(m, i)) e = m;\n\t\telse s = m;\n\t}\n\treturn pi(s * 3 + i, 0);\n}\n\nint main(){\n\tscanf(\"%d\",&n);\n\tfor(int i=0; i<n; i++){\n\t\tscanf(\"%lld %lld\",&a[i].first,&a[i].second);\n\t\ta[i].first += inf;\n\t\ta[i].second += inf;\n\t}\n\tpi p = get_coord();\n\tfor(int i=59; i>=0; i--){\n\t\tif(on(p.first - (1ll << i), p.second)) p.first -= (1ll << i);\n\t}\n\tlint x = p.first;\n\tlint y = p.second;\n\tfor(int i=59; i>=0; i--){\n\t\tif(on(p.first + (1ll << i), p.second)){\n\t\t\tp.first += (1ll << i);\n\t\t\ty += (1ll << i);\n\t\t}\n\t}\n\tprintf(\"%lld %lld\\n\", x-inf, y-inf);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n  \tc=0;\n  \tfor (pin& x : qab[1]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n  \tif (!c) {\n\t\tans.first *= 2; ans.second *= 2;\n\t\treturn ans;\n\t}\n\tc = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second-1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t}\n\tans.first *= 2; ans.first++; ans.second *= 2; ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n    int N; cin>>N;\n    vector<long long> x(N), y(N);\n    for (int i=0; i<N; i++)\n        cin>>x[i]>>y[i];\n\n    //  https://img.atcoder.jp/wtf19-open/editorial.pdf\n    long long c = -(1LL<<60);\n    \n    //  y = c の直線上のランプのみが点灯するようにしたときに、\n    //  x%m = r を満たす (x, c) のランプが点灯しているか\n    //  m = 2^k\n    //  mが充分に大きければ、(r, y) のランプが点灯しているかどうかになる\n    auto check = [&](long long m, long long r)\n    {\n        bool ret = false;\n        //  (r, c) のランプが点灯している ⇔ XOR[0<=i<N]((y[i]-c) | ~(r-x[i]) の全てのビットが立っている)\n        //  下位kビット目まで考えれば、残りの必要なビットが立っているxが存在するので、\n        //  上位ビットは単に無視すれば良い\n        for (int i=0; i<N; i++)\n            if (!~( ((y[i]-c) | ~(r-x[i])) | ~(m-1) ))\n                ret = !ret;\n        return ret;\n    };\n\n    //  (p, c) のランプが付いているpを求める\n    //  check(m, x) が真ならば、check(2*m, x) か check(2*m, x+m) のどちらか少なくとも一方は真である\n    //  x>=0 に必ず点灯しているランプがあり、pはなるべく小さくなるように求めているので、\n    //  pが負になることは考慮しなくて良い\n    long long p = 0;\n    for (int k=0; k<60; k++)\n        if (!check(1LL<<(k+1), p))\n            p |= 1LL<<k;\n\n    long long l = p;\n    for (int k=60; k>=0; k--)\n        if (check(1LL<<62, l-(1LL<<k)))\n            l -= 1LL<<k;\n    long long r = p;\n    for (int k=60; k>=0; k--)\n        if (check(1LL<<62, r+(1LL<<k)))\n            r += 1LL<<k;\n    cout<<l<<\" \"<<c+(r-l)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n  vel c(2)\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n          c[i]^=(qc+1);\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cassert>\nusing namespace std;\n\nint main()\n{\n    int N; cin>>N;\n    vector<long long> x(N), y(N);\n    for (int i=0; i<N; i++)\n        cin>>x[i]>>y[i];\n\n    //  https://img.atcoder.jp/wtf19-open/editorial.pdf\n\n    //  x[i], y[i] >= 0 とする\n    long long base = 1LL<<58;\n    for (int i=0; i<N; i++)\n    {\n        x[i] += base;\n        y[i] += base;\n    }\n\n    //  直線 y = 0 上のランプのみが点灯するようにしたときに、\n    //  x < n, x%3 == r を満たすxについて、 \n    //  (x, 0) の点灯しているランプの個数が奇数となるか\n    auto count = [&](long long n, long long r) -> bool\n    {\n        /*\n        解説中の「a simple digit DP」について\n\n        求める答えは、\n          XOR[0<=p<n, p%3=r](XOR[0<=i<N](y[i] | ~(p-x[i]) の全てのビットが1))。\n        変形して、\n          = XOR[0<=p<n, p%3=r](XOR[0<=i<N]((~y[i] & (p-x[i])) == 0))\n          = XOR[0<=i<N](XOR[0<=p<n, p%3=r]((~y[i] & (p-x[i])) == 0))\n          = XOR[0<=i<N](XOR[0<=p<n-x[i], (p-x[i])%3=r]((~y[i] & p) == 0))。\n        下記の問題が解ければ良い。\n          Q. 整数n, r, yについて、x<n, x%3==r, (~y & x)==0 を満たす整数xは何個か？\n        この問題は桁ごとと3での剰余ごとに個数を覚えておく単純な桁DPでたしかに解ける。\n        */\n        bool ret = false;\n        for (int i=0; i<N; i++)\n        {\n            if (n <= x[i])\n                continue;\n\n            long long m = n - x[i] - 1;\n            //  [k][r]: k桁以下を比較したときにm以下\n            long long A[61][3] = {};\n            //  [k][r]: 任意\n            long long B[61][3] = {};\n\n            //  0\n            A[0][0] = 1LL;\n            B[0][0] = 1LL;\n            //  1\n            if (y[i]&1)\n            {\n                if (m&1)\n                    A[0][1] = 1LL;\n                B[0][1] = 1LL;\n            }\n\n            for (int k=1; k<=60; k++)\n                for (int pr=0; pr<3; pr++)\n                {\n                    //  0\n                    A[k][pr] += m>>k&1 ? B[k-1][pr] : A[k-1][pr];\n                    B[k][pr] += B[k-1][pr];\n                    //  1\n                    if (y[i]>>k&1)\n                    {\n                        long long cr = (pr + (1LL<<k)) % 3;\n                        if (m>>k&1)\n                            A[k][cr] += A[k-1][pr];\n                        B[k][cr] += B[k-1][pr];\n                    }\n                }\n\n            if (A[60][((r-x[i])%3+3)%3]%2 != 0)\n                ret = !ret;\n        }\n        return ret;\n    };\n\n    //  y = 0 の直線上のランプのみが点灯するようにしたときに、\n    //  (p, 0)が点灯しているか\n    auto check = [&](long long p) -> bool\n    {\n        bool ret = false;\n        for (int i=0; i<N; i++)\n            if ((~y[i] & (p-x[i])) == 0)\n                ret = !ret;\n        return ret;\n    };\n\n    long long r3;\n    for (r3=0LL; r3<3LL; r3++)\n        if (count(1LL<<60, r3))\n            break;\n    assert(r3<3LL);\n\n    long long l = 0;\n    long long r = 1LL<<60;\n    while (r-l > 1LL)\n    {\n        long long m = (l+r)/2;\n        if (count(l, r3) == count(m, r3))\n            l = m;\n        else\n            r = m;\n    }\n\n    long long t = l;\n    for (int k=60; k>=0; k--)\n        if (check(l-(1LL<<k)))\n            l -= 1LL<<k;\n    r = t;\n    for (int k=60; k>=0; k--)\n        if (check(r+(1LL<<k)))\n            r += 1LL<<k;\n\n    long long ansx = l-base;\n    long long ansy = (r-l)-base;\n\n    cout<<ansx<<\" \"<<ansy<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\trep(i, 2) {\n\t\tint c = 0;\n\t\tfor (pin& x : qab[1-i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tc ^= (qc + 1);\n\t\t}\n\t\tif (!c) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tint val = ans.second - 1;\n\tans.first *= 2; ans.first++; ans.second *= 2; ans.second--;\n\tfor (pin& x : qab[1]) {\n\t\tint w = val - x.second;\n\t\tif ((w & x.first) == w) { ans.second ^= 1; }\n\t}\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 2e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n          c[i][0]^=((qc+1)&1);\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0]&&!c[1-i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = 2 * x.first + x.second+1;\n      \tqc = (qc & (int)(0xffffffff)) + ((qc & (0x7fffffff00000000)) >> 32);\n\tqc = (qc & (int)(0xffffffff)) + ((qc & (int)(0x100000000)) >> 32);\n\tqc = (qc & (0xffff)) + ((qc & (int)(0xffff0000)) >> 16);\n\tqc = (qc & (0xffff)) + ((qc & (0x10000)) >> 16);\n\tqc = (qc & (0xff)) + ((qc & (0xff00)) >> 8);\n\tqc = (qc & (0xff)) + ((qc & (0x100)) >> 8);\n\tqc = (qc & (0xf)) + ((qc & (0xf0)) >> 4);\n\tqc = (qc & (0xf)) + ((qc & (0x10)) >> 4);\n\tqc = (qc & 3) + ((qc & 12) >> 2);\n\tqc = (qc & 3) + ((qc & 4) >> 2);\n\t\tc ^= qc;\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n      \tw++;\n      \tif ((w & x.first) == w) { d ^= 1; }\n\t}\n  \tans.first *= 2; ans.second *= 2;\n\tans.first+=(c|d); ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll base = 1ll << 58;\nconst int LOG = 60;\nint main() {\n  do {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n  } while (false);\n  int n;\n  cin >> n;\n  vector<ll> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n    x[i] += base;\n    y[i] += base;\n  }\n  auto calc = [&] (ll sum, int r) {\n    vector<bool> F(3), G(3), F2(3), G2(3);\n    bool res = false;\n    for (int i = 0; i < n; i++) {\n      if (y[i] < sum) {\n        ll limit = sum - y[i];\n        fill(F.begin(), F.end(), false);\n        fill(G.begin(), G.end(), false);\n        F[0] = true;\n        for (int j = LOG; j >= 0; j--) {\n          fill(F2.begin(), F2.end(), false);\n          fill(G2.begin(), G2.end(), false);\n          for (int k = 0; k < 3; k++) {\n            if (F[k]) {\n              for (int v = 0; v <= min(limit >> j & 1, x[i] >> j & 1); v++) {\n                int nxt = (k + v * (j & 1) + v) % 3;\n                if (v != (limit >> j & 1)) {\n                  G2[nxt].flip();\n                } else {\n                  F2[nxt].flip();\n                }\n              }\n            }\n            if (G[k]) {\n              for (int v = 0; v <= (x[i] >> j & 1); v++) {\n                int nxt = (k + v * (j & 1) + v) % 3;\n                G2[nxt].flip();\n              }\n            }\n          }\n          F.swap(F2);\n          G.swap(G2);\n        }\n        res ^= G[(r - y[i] % 3 + 3) % 3];\n      }\n    }\n    return res;\n  };\n  int r = 0;\n  while (!calc(1ll << LOG, r)) {\n    r++;\n  }\n  ll start = 0;\n  for (int i = LOG; i >= 0; i--) {\n    if (calc(start, r) == calc(start + (1ll << i), r)) {\n      start |= 1ll << i;\n    }\n  }\n  auto check = [&] (ll pos) {\n    bool res = false;\n    for (int i = 0; i < n; i++) {\n      if (y[i] <= pos && pos <= x[i] + y[i] && (x[i] & (pos - y[i])) == pos - y[i]) {\n        res ^= 1;\n      }\n    }\n    return res;\n  };\n  ll L = start, R = start;\n  for (int i = LOG; i >= 0; i--) {\n    if (check(L - (1ll << i))) {\n      L -= 1ll << i;\n    }\n    if (check(R + (1ll << i))) {\n      R += 1ll << i;\n    }\n  }\n  cout << R - L - base << \" \" << L - base << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\nvoid tostr(ll x,string& res){while(x)res+=('0'+(x%10)),x/=10; reverse(ALL(res)); return;}\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//end\n\nconstexpr ll c=300000000000000000LL;\nint N; ll x[11000],y[11000];\nbool que(ll n,ll r){if(n<0||r<0||n<r)return 0; return (n&r)==r;}\nbool col(ll a){\n   bool res=0;\n   rep(i,0,N)if(a>=x[i])res^=que(c-x[i]-y[i],a-x[i]);\n   return res;\n}\nll calc(ll n,ll t,int r){\n   if(t<0)return 0;\n   chmin(t,n); ll dp[64][3][2]={}; dp[60][0][1]=1;\n   rrep(i,59,-1)rep(j,0,3)rep(k,0,2)if(dp[i+1][j][k]){\n      rep(nxt,0,2){\n         if((n>>i&1)==0&&nxt)continue;\n         if(k&&nxt&&(t>>i&1)==0)continue;\n         int nj=(j+(nxt?(i&1?2:1):0))%3,nk=k;\n         if(nxt==0&&(t>>i&1))nk=0;\n         dp[i][nj][nk]+=dp[i+1][j][k];\n      }\n   } return dp[0][r][0]+dp[0][r][1];\n}\nll rng(ll n,ll lb,ll rb,int r){return calc(n,rb,r)-calc(n,lb,r);}\nbool flag(ll lb,ll rb,int r){\n   bool res=0;\n   rep(i,0,N)res^=rng(c-x[i]-y[i],lb-x[i],rb-x[i],((r-x[i])%3+3)%3)&1;\n   return res;\n}\n\n//reference:https://physics0523.hatenablog.com/entry/2019/02/26/190724\nint main(){\n   scanf(\"%d\",&N); rep(i,0,N)scanf(\"%lld%lld\",&x[i],&y[i]);\n   ll lb=-c/2,rb=c/2; int r=-1;\n   rep(i,0,3)if(flag(lb,rb,i)){r=i; break;}\n   assert(r>=0);\n   while(rb-lb>1){\n      ll mid=(lb+rb)>>1;\n      if(flag(lb,mid,r))rb=mid; else lb=mid;\n   } assert(col(lb));\n   ll x1=lb,x2=lb;\n   rrep(k,62,-1){\n      if(col(x1-(1LL<<k)))x1-=1LL<<k;\n      if(col(x2+(1LL<<k)))x2+=1LL<<k;\n   } printf(\"%lld %lld\\n\",x1,c-x2);\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll L = -1e17;\nint n;\nvector<pair<ll,ll> > v;\nbool check_point(pair<ll,ll> p, ll x, ll y)\n{\n\tif (x<p.FF||x>p.FF+p.SS-y) return false;\n\tll X = x-p.FF;\n\tll Y = p.SS-y;\n\treturn (Y&X)==X;\n}\nbool check_point(ll x)\n{\n\tbool ret = 0;\n\tfor (auto p : v)\n\t{\n\t\tif (check_point(p, x, L))\n\t\t{\n\t\t\tret ^= 1;\n\t\t}\n\t}\n\treturn ret;\n}\nbool cnt[3];\nvoid calc(pair<ll,ll> p, ll x, ll y)\n{\n\tif (x<p.FF) return;\n\tif (x>p.FF+p.SS-y) x = p.FF+p.SS-y;\n\tll X = x-p.FF;\n\tll Y = p.SS-y;\n//\tcerr<<X<<\",\"<<Y<<endl;\n\tassert(Y>=0);\n\tstatic bool dp[66][2][3];\n\tmemset(dp, 0, sizeof(dp));\n\tdp[60][1][0] = 1;\n\tfor (int i=59; i>=0; i--)\n\t{\n\t\tfor (int t=0; t<2; t++)\n\t\t{\n\t\t\tfor (int v=0; v<2; v++)\n\t\t\t{\n\t\t\t\tif (v&&!((Y>>i)&1)) continue;\n\t\t\t\tif (v&&t&&!((X>>i)&1)) continue;\n\t\t\t\tint dlt = ((1ll*v)<<i)%3;\n\t\t\t\tint nt = t&(v==((X>>i)&1));\n\t\t\t\tfor (int j=0; j<3; j++) dp[i][nt][(j+dlt)%3] ^= dp[i+1][t][j];\n\t\t\t}\n\t\t}\n\t}\n\tint t = ((p.FF%3)+3)%3;\n//\tfor (int i=0; i<3; i++) cerr<<dp[0][0][i]; cerr<<\" \";\n//\tfor (int i=0; i<3; i++) cerr<<dp[0][1][i]; cerr<<endl;\n\t\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tcnt[(i+t)%3] ^= dp[0][0][i];\n\t\tcnt[(i+t)%3] ^= dp[0][1][i];\n\t}\n}\nbool check(ll x)\n{\n//\tcerr<<\"check:\"<<x<<endl;\n\tcnt[0] = cnt[1] = cnt[2] = 0;\n\tfor (auto p : v)\n\t{\n\t\tcalc(p, x, L);\n\t}\n//\tcerr<<cnt[0]<<\" \"<<cnt[1]<<\" \"<<cnt[2]<<endl;\n\treturn cnt[0]||cnt[1]||cnt[2];\n}\nint main()\n{\n\tgeti(n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll x, y;\n\t\tgetii(x, y);\n\t\tv.PB(MP(x, y));\n\t}\n/*\tfor (int i=L; i<=-L; i++)\n\t{\n\t\tcerr<<check_point(i);\n\t\tif ((i-L)%5==0) cerr<<\" \";\n\t} cerr<<endl;\n*/\n\tll l = -2e17, r = 4e17;\n\twhile (l<=r)\n\t{\n\t\tll m = l+r>>1;\n\t\tif (check(m)) r = m-1; else l = m+1;\n\t}\n//\tcerr<<l<<\",\"<<r<<\" \"<<check(l)<<check(r)<<endl;\n\tr = l;\n//\tcerr<<\"l=\"<<l<<\" r=\"<<r<<endl;\n\tfor (int i=0; i<=60; i++) if (check_point(l-(1ll<<i))) l -= 1ll<<i;\n\tfor (int i=0; i<=60; i++) if (check_point(r+(1ll<<i))) r += 1ll<<i;\n//\tcerr<<l<<\",\"<<r<<endl;\n\n\tcout<<l<<\" \"<<L+(r-l)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvector<ii> vec;\n\nint color(ll x, ll y)\n{\n\tint ans=0;\n\tint n=vec.size();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll x2=vec[i].fi; ll y2=vec[i].se;\n\t\tll d = x-x2;\n\t\tll h = y2-y;\n\t\tif(d<0||d>h) continue;\n\t\tif((d&h)==d) ans^=1;\n\t}\n\treturn ans;\n}\n\nll rnd(ll x)\n{\n\tll ans=0;\n\tfor(int i=0;i<5;i++)\n\t{\n\t\tans<<=15; ans^=rand();\n\t}\n\tans%=x;\n\treturn ans;\n}\n\nll rnd(ll l, ll r)\n{\n\treturn l+rnd(r-l+1);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll x,y; cin>>x>>y; vec.pb({x,y});\n\t}\n\tll C = -((1LL<<61)-1);\n\tll cur = 0;\n\twhile(!color(cur,C))\n\t{\n\t\tC=rnd(-ll(3e17),-ll(3e18));\n\t\tint tmp=rnd(0,n-1);\n\t\tll x=vec[tmp].fi; ll y=vec[tmp].se;\n\t\tll h=y-C;\n\t\tfor(int i=0;i<62;i++)\n\t\t{\n\t\t\tif(h&(1LL<<i))\n\t\t\t{\n\t\t\t\tif(rand()&1) x+=(1LL<<i);\n\t\t\t}\n\t\t}\n\t\tcur=x;\n\t}\n\tfor(int i=61;i>=0;i--)\n\t{\n\t\tif(color(cur-(1LL<<i),C)) cur-=(1LL<<i);\n\t}\n\tll l = cur;\n\tfor(int i=61;i>=0;i--)\n\t{\n\t\tif(color(cur+(1LL<<i),C)) cur+=(1LL<<i);\n\t}\n\tll r = cur;\n\tcout<<l<<' '<<C+(r-l)<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 17.01.2020 01:59:15       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<long long> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n  }\n  auto IsSubset = [&](long long a, long long b) {\n    return ((a & b) == a);\n  };\n  auto Get = [&](long long X, long long Y) {\n    int z = 0;\n    for (int i = 0; i < n; i++) {\n      if (X >= x[i]) {\n        z ^= IsSubset(X - x[i], y[i] - Y);\n      }\n    }\n    return z;\n  };\n  auto AddSubsets = [&](vector<int>& p, long long xb, long long xs, long long b) {\n    long long a = xb - xs + 1;\n    int shift = ((int) (xs % 3) + 3) % 3;\n    for (int bit = 61; bit >= 0; bit--) {\n      if (a & (1LL << bit)) {\n        int cc  = __builtin_popcountll(b & ~(1LL << bit) & 0x5555555555555555LL);\n        cc += 2 * __builtin_popcountll(b & ~(1LL << bit) & 0xAAAAAAAAAAAAAAAALL);\n        if (cc == 0) {\n          p[shift] ^= 1;\n        } else {\n          int t = (shift + (cc % 3 == 2 ? 2 : (1 - cc % 3))) % 3;\n          p[t] ^= 1;\n          p[(t + 1) % 3] ^= 1;\n        }\n        shift = (shift + (bit % 2 == 0 ? 1 : 2)) % 3;\n        if (!(b & (1LL << bit))) {\n          break;\n        }\n      }\n      b &= ~(1LL << bit);\n    }\n  };\n  auto Get3 = [&](long long X, long long Y) {\n    vector<int> ret(3);\n    for (int i = 0; i < n; i++) {\n      if (X >= x[i]) {\n        AddSubsets(ret, X, x[i], y[i] - Y);\n      }\n    }\n    return ret;\n  };\n  const long long inf = (long long) 5e17;\n  long long Y = -inf / 2;\n  long long low = -inf, high = inf;\n  while (low < high) {\n    long long mid = low + ((high - low) >> 1);\n    auto ret = Get3(mid, Y);\n    if (ret[0] + ret[1] + ret[2] == 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  long long X = low;\n  assert(Get(X, Y) == 1);\n  for (int bit = 60; bit >= 0; bit--) {\n    if (Get(X - (1LL << bit), Y)) {\n      X -= 1LL << bit;\n    }\n  }\n  long long minX = X;\n  for (int bit = 60; bit >= 0; bit--) {\n    if (Get(X + (1LL << bit), Y)) {\n      X += 1LL << bit;\n    }\n  }\n  long long maxX = X;\n  cout << minX << \" \" << Y + (maxX - minX) << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<set>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<functional>\n#include<map>\n#include<iomanip>\n#include<limits>\n#include<unordered_set>\n#include<cmath>\n#include <numeric>\n#include <array>\n#include <complex>\n#define M_PI 3.141592653589793238\nusing namespace std;\n//long long p = 998244353;\nlong long p = 1000000007;\n#define int long long\n#define ll long long\n#define vel vector<ll>\n#define vvel vector<vel>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define sor(v) sort(v.begin(),v.end())\n#define mmax(a,b) a=max(a,b)\n#define mmin(a,b) a=min(a,b)\n#define mkp make_pair\n#define pin pair<int,int>\n#define qin pair<pin,int>\n#define V vector\n#define Endl endl\n#define veb vector<bool>\n#define fcout cout << fixed << setprecision(15)\n#define rev(s) reverse(s.begin(),s.end())\n#define lower(h,val) (lower_bound(h.begin(),h.end(),val)-h.begin())\n#define upper(h,val) (upper_bound(h.begin(),h.end(),val)-h.begin())\nvel kai;\nvel inv_kai;\nint rui(int a, int n, int mod) {\n\tif (n == 0) { return 1 % mod; }\n\tint x = rui(a, n / 2, mod);\n\tx *= x; x %= mod;\n\tif (n % 2 == 1) { x *= a; x %= mod; }\n\treturn x;\n}\nint root(int x, vel& pa) {\n\tif (pa[x] == -1) { return x; }\n\tint ans = root(pa[x], pa); pa[x] = ans;\n\treturn ans;\n}\nbool mar(int x, int y, vel& pa) {\n\tx = root(x, pa);\n\ty = root(y, pa);\n\tif (x != y) { pa[x] = y; }\n\treturn (x != y);\n}\nint gcd(int x, int y) {\n\tif (x < y) { return gcd(y, x); }\n\tif (y == 0) { return x; }\n\treturn gcd(y, x % y);\n}\nint lcm(ll x, ll y) {\n\tx = abs(x); y = abs(y);\n\treturn x * y / gcd(x, y);\n}\nlong long modinv(long long a, long long m) {\n\tlong long b = m, u = 1, v = 0;\n\twhile (b) {\n\t\tlong long t = a / b;\n\t\ta -= t * b; swap(a, b);\n\t\tu -= t * v; swap(u, v);\n\t}\n\tu %= m;\n\tif (u < 0) u += m;\n\treturn u;\n}\nvoid make_kai(int max_kai) {\n\tkai = vel(max_kai, 1);\n\tinv_kai = kai;\n\trep(i, max_kai - 1) {\n\t\tkai[i + 1] = kai[i] * (i + 1); kai[i + 1] %= p;\n\t\tinv_kai[i + 1] = modinv(kai[i + 1], p);\n\t}\n}\nint com(int n, int r) {\n\tif ((n < 0) || (r < 0) || (r > n)) { return 0; }\n\tint ans = (kai[n] * inv_kai[r]) % p;\n\treturn (ans * inv_kai[n - r]) % p;\n}\nvel uni(vel x) {\n\tif (x.size() == 0) { return x; }\n\tsor(x);\n\tint n = x.size();\n\tvel ans(1, x[0]);\n\tfor (int j = 1; j < n; j++) {\n\t\tif (x[j - 1] != x[j]) { ans.push_back(x[j]); }\n\t}\n\tx = ans;\n\treturn x;\n}\nvoid pr(vel& v) {\n\tint n = v.size();\n\tif (n != 0) {\n\t\tcout << v[0];\n\t\trep(i, n - 1) {\n\t\t\tcout << \" \" << v[i + 1];\n\t\t}\n\t\tcout << endl;\n\t}\n}\nvel dijk(V<V<pin>>& way, int st, int inf) {\n\tint n = way.size();\n\tvel dist(n, inf); dist[st] = 0;\n\tpriority_queue<pin, vector<pin>, greater<pin>> pq;\n\tpq.push(mkp(0, st));\n\tveb is_checked(n, false);\n\twhile (!pq.empty()) {\n\t\tpin x = pq.top(); pq.pop();\n\t\tint pot = x.second;\n\t\tif (!is_checked[pot]) {\n\t\t\tis_checked[pot] = true;\n\t\t\tfor (auto y : way[pot]) {\n\t\t\t\tint nex_dist = x.first + y.second;\n\t\t\t\tint nex_pot = y.first;\n\t\t\t\tif (dist[nex_pot] > nex_dist) {\n\t\t\t\t\tdist[nex_pot] = nex_dist;\n\t\t\t\t\tpq.push(mkp(nex_dist, y.first));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn dist;\n}\nvel mul(vel& a, vel& b) {\n\tint n = a.size();\n\tint m = b.size();\n\tvel ans(n + m - 1, 0);\n\trep(i, n) {\n\t\trep(j, m) {\n\t\t\tans[i + j] += a[i] * b[j];\n\t\t\tans[i + j] %= p;\n\t\t}\n\t}\n\treturn ans;\n}\nvel rui_p(vel& a, int n) {\n\tif (n == 0) { return { 1 }; }\n\tvel qans = rui_p(a, n / 2);\n\tqans = mul(qans, qans);\n\tif (n % 2 == 1) {\n\t\tqans = mul(qans, a);\n\t}\n\treturn qans;\n}\nbool is_prime(int n) {\n\tif (n == 0 || n == 1) { return false; }\n\tfor (int i = 2; i * i <= n; i++) {\n\t\tif (n % i == 0) { return false; }\n\t}\n\treturn true;\n}\n#define bs bitset<50>\nvoid per(int& ans) {\n\tans %= p;\n\tif (ans < 0) { ans += p; }\n}\n#define upperbound(v,val) upper_bound(v.begin(),v.end(),val)-v.begin()\n#define lowerbound(v,val) lower_bound(v.begin(),v.end(),val)-v.begin()\n#define mat V<V<pin>>\nvvel disj_min(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = min(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nvvel disj_max(vel& v) {\n\tint n = v.size();\n\tvvel ret(22, vel(n));\n\tret[0] = v;\n\trep(i, 21) {\n\t\trep(j, n) {\n\t\t\tint nex = j + (1 << i);\n\t\t\tif (nex < n) {\n\t\t\t\tret[i + 1][j] = max(ret[i][j], ret[i][nex]);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tret[i + 1][j] = ret[i][j];\n\t\t\t}\n\t\t}\n\t}\n\treturn ret;\n}\nint find_min(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\treturn min(dv[i][l], dv[i][r - (1 << i)]);\n}\nint find_max(vvel& dv, int l, int r) {\n\tint i = 21;\n\twhile (l + (1 << i) > r) {\n\t\ti--;\n\t}\n\treturn max(dv[i][l], dv[i][r - (1 << i)]);\n}\nvoid pri(vel& v) {\n\tif (v.size() == 0) { return; }\n\tcout << v[0];\n\trep(i, v.size() - 1) { cout << \" \" << v[i + 1]; }\n\tcout << endl;\n\treturn;\n}\nvvel dbl(vel& v) {\n\tvvel ans(20, vel(v));\n\tint n = v.size();\n\trep(i, 19) {\n\t\trep(j, n) {\n\t\t\tans[i + 1][j] = ans[i][ans[i][j]];\n\t\t}\n\t}\n\treturn ans;\n}\nint lca(int s, int t, int diff, vvel& pa) {\n\tif (diff < 0) { return lca(t, s, -diff, pa); }\n\trep(i, 19) {\n\t\tif ((diff & (1 << i)) != 0) {\n\t\t\ts = pa[i][s];\n\t\t}\n\t}\n\tfor (int i = 19; i >= 0; i--) {\n\t\tif (pa[i][s] != pa[i][t]) {\n\t\t\ts = pa[i][s];\n\t\t\tt = pa[i][t];\n\t\t}\n\t}\n\tif (s != t) {\n\t\ts = pa[0][s];\n\t}\n\treturn s;\n}\nint sz = 1024 * 1024;\nvel bit(sz+1, 0);\nvoid add(int a, int w) {\n\twhile (a<=sz) {\n\t\tbit[a] += w;\n\t\ta += (a & (-a));\n\t}\n}\nint sum(int a) {\n\tint ans = 0;\n\twhile (a != 0) {\n\t\tans += bit[a];\n\t\ta -= (a & (-a));\n\t}\n\treturn ans;\n}\n#define vveb V<veb>\n#define omajinai cin.tie(0);ios::sync_with_stdio(false);\n#define endl \"\\n\"\nint modpow(int a, int n, int p) {\n\tif (n == 0) { return 1; }\n\tint m = n / 2;\n\tint x = modpow(a, n / 2, p);\n\tx *= x; x %= p;\n\tif (n % 2 == 1) { x *= a; x %= p; }\n\treturn x;\n}\npin solve(V<pin>& ab, int ex) {\n\tif (ex == 0) { return mkp(1, 0); }\n\tV<pin> ab0, ab1;\n\tfor (auto x : ab) {\n\t\tint a1 = x.first;\n\t\tint b1 = x.second;\n\t\tif (b1 % 2 == 0) {\n\t\t\tab0.push_back(mkp(a1 / 2,b1 / 2));\n\t\t\tif (a1 % 2 == 1) { ab1.push_back(mkp(a1 / 2, b1 / 2)); }\n\t\t}\n\t\telse {\n\t\t\tab1.push_back(mkp(a1 / 2, b1 / 2));\n\t\t\tif (a1 % 2 == 1) { ab0.push_back(mkp(a1 / 2, (b1 + 1) / 2)); }\n\t\t}\n\t}\n\tvel c0(2), c1(2);\n\tfor (auto x : ab0) {\n\t\tint qa = x.first % 3; qa = 3 - qa;\n\t\tint qb = x.second % 3;\n\t\tint qc = (qa + qb) % 3;\n\t\tif (qc == 0) { c0[0] ^= 1; }\n\t\tif (qc == 1) { c0[1] ^= 1; }\n\t\tif (qc == 2) { c0[0] ^= 1; c0[1] ^= 1; }\n\t}\n\tfor (auto x : ab1) {\n\t\tint qa = x.first % 3; qa = 3 - qa;\n\t\tint qb = x.second % 3;\n\t\tint qc = (qa + qb) % 3;\n\t\tif (qc == 0) { c1[0] ^= 1; }\n\t\tif (qc == 1) { c1[1] ^= 1; }\n\t\tif (qc == 2) { c1[0] ^= 1; c1[1] ^= 1; }\n\t}\n\tvel ze(2, 0);\n\tif (c0 == ze) {\n\t\tpin ans=solve(ab1, ex-1);\n\t\tans.first *= 2; ans.second *= 2;\n\t\tans.second++;\n\t\treturn ans;\n\t}\n\tif (c1 == ze) {\n\t\tpin ans = solve(ab0, ex - 1);\n\t\tans.first *= 2; ans.second *= 2;\n\t\treturn ans;\n\t}\n\trep(i,ab.size()) {ab[i].first++; }\n\tpin ans = solve(ab, ex);\n\tans.first--;\n\treturn ans;\n}\nsigned main() {\n\tint inf = 1;\n\trep(i, 57) { inf *= 2; }\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tint a, b; cin >> a >> b;\n\t\ta += inf; b += inf;\n\t\tab[i] = mkp(a, b);\n\t}\n\tpin ret=solve(ab, 70);\n\tret.first -= inf;\n\tret.second -= inf;\n\tcout << ret.first  <<\" \"<<ret.second<< endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define vel V<long long>\n#define rep(i,n) for(int i=0;i<n;i++)\nvel solve(V<vel>& ab, int ex) {\n\tif (ex == 0) { return { 1, 0 }; }\n\tV<V<vel>> qab(2);\n\tfor (vel x : ab) {\n\t\tqab[x[1] & 1].push_back({ x[0] / 2,x[1] / 2 });\n\t\tif (x[0] & 1) { qab[(x[1] + 1) & 1].push_back({ x[0] / 2,(x[1] + 1) / 2 }); }\n\t}\n\tV<vel> c(3,vel(2));\n\trep(i, 2) {\n\t\tfor (vel x : qab[i]) {\n\t\t\tint qc = (3 - x[0] + x[1]) % 3; qc = (qc + 3) % 3;\n\t\t\tif (qc==0) { c[i][0] ^= 1; }\n\t\t\tif (qc==1) { c[i][1] ^= 1; }\n\t\t\tif (qc == 2) { c[i][0] ^= 1; c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (c[1-i] == c[2]) {\n\t\t\tvel ans = solve(qab[i], ex - 1);\n\t\t\tans[0] *= 2; ans[1] *= 2; ans[1] += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\trep(i, ab.size()) { ab[i][0]++; }\n\tvel ans = solve(ab, ex); ans[0]--;\n\treturn ans;\n}\nint main() {\n\tlong long inf = 2e17;\n\tint n; cin >> n;\n\tV<vel> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tvel ret = solve(ab, 70);\n\tcout << ret[0] - inf << \" \" << ret[1] - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\trep(i, 2) {\n\t\tint c = 0;\n\t\tfor (pin& x : qab[1 - i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tc ^= (qc + 1);\n\t\t}\n\t\tif (!c) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tint c = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second-1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t}\n\tans.first *= 2; ans.first++; ans.second *= 2; ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define all(v) (v).begin(),(v).end()\n#define trav(x,v) for(auto &x : v)\n#define sz(v) int(v.size())\ntypedef vector<int> vi;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\nint main(){\n\tcin.sync_with_stdio(0);\n\tcin.tie(0);\n\n\tint k;\n\tcin >> k;\n\n\tint n = (k+3)/4 * 2;\n\tvector<vi> mat(n, vi(n));\n\t\n\trep(i,0,n) rep(j,0,n){\n\t\tint res = (i+j)%n + (i%2 ? n : 0) + 1;\n\t\tif(res > k) res -= n;\n\t\tres = max(res, 1);\n\t\tres = min(res, k);\n\t\tmat[i][j] = res;\n\t}\n\t\n\tcout << n << endl;\n\ttrav(v, mat){\n\t\ttrav(x, v) cout << x << ' ';\n\t\tcout << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\tV<V<bool>> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc+1)%2) { c[i][0]^=true; }\n\t\t\tif (qc) { c[i][1] ^= true; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0]&&!c[1-i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"sse2,pclmul,tune=native\")\n#pragma GCC optimize(\"O3\")\n#include <ext/pb_ds/assoc_container.hpp>\n#include <nmmintrin.h>\n#include <emmintrin.h>\n#include <wmmintrin.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nusing GF = uint32_t;\n\ninline GF Add(GF a, GF b) {\n  return a ^ b;\n}\n\ninline GF Mul(GF a, GF b) {\n  __m128i xa = _mm_cvtsi64_si128(a), xb = _mm_cvtsi64_si128(b);\n  xa = _mm_clmulepi64_si128(xa, xb, 0x00);\n  uint64_t res = _mm_cvtsi128_si64(xa);\n  GF hi = res >> 32;\n  GF a0 = hi ^ (hi >> 25) ^ (hi >> 29) ^ (hi >> 30);\n  return (GF)res ^ a0 ^ (a0 << 2) ^ (a0 << 3) ^ (a0 << 7);\n}\n\nvector<GF> base;\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val);\nGF AddPositionsFrom(LL x, LL y, LL min_val);\n\nmap<pair<LL, LL>, GF> memo;\nGF AddPositions(LL x, LL y, int bb = 60) {\n  if (x == 0 && y == 0) { return 1; }\n  debug(\"?Any\", x, y);\n  \n  pair<LL, LL> p{x, y};\n  if (memo.count(p)) { return memo[p]; }\n\n  int bit = bb;\n  while ((1LL << bit) > x + y) { --bit; }\n  if (x >= (1LL << bit)) {\n    GF ans = Mul(base[bit], AddPositions(x ^ (1LL << bit), y));\n    debug(x, y, ans);\n    return memo[p] = ans;\n  }\n\n  // x < 2^bit <= x + y\n  GF answer1 = AddPositionsUpTo(x, y, (1LL << bit) - 1);\n  GF answer2 = AddPositionsFrom(x, y, (1LL << bit));\n  debug(x, y, answer1, answer2);\n  return memo[p] = Add(answer1, answer2);\n}\n\nGF GetValue(LL x) {\n  static map<LL, GF> val_memo;\n  auto it = val_memo.find(x);\n  if (it != val_memo.end()) { return it->nd; }\n\n  GF ans = 1;\n  for (int bit = 60; bit >= 0; --bit) {\n    if ((x >> bit) & 1) {\n      ans = Mul(base[bit], ans);\n    }\n  }\n  debug(\"Value\", x, ans);\n  return val_memo[x] = ans;\n}\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val) {\n  debug(\"?UpTo\", x, y, max_val);\n  if (x > max_val) { return 0; }\n  if (x + y <= max_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int bit = 60; bit >= 0; --bit) {\n    if (!((y >> bit) & 1)) { continue; }\n    const LL v = 1LL << bit;\n    y ^= v;\n\n    if (x + v - 1 <= max_val) {\n      debug(\"UpTo\", orig_x, orig_y, max_val, x, y);\n      answer = Add(answer, AddPositions(x, y));\n      x += v;\n    }\n  }\n  debug(answer);\n  if (x <= max_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF AddPositionsFrom(LL x, LL y, LL min_val) {\n  if (x + y < min_val) { return 0; }\n  if (x >= min_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int bit = 60; bit >= 0; --bit) {\n    if (!((y >> bit) & 1)) { continue; }\n    const LL v = 1LL << bit;\n    y ^= v;\n\n    if (x + v >= min_val) {\n      answer = Add(answer, AddPositions(x + v, y));\n    } else {\n      x += v;\n    }\n  }\n  debug(\"From\", orig_x, orig_y, min_val, answer, x);\n  if (x >= min_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF GetRandom() {\n  GF ans = 0;\n  for (int i = 0; i < 4; ++i) {\n    ans <<= 16;\n    ans |= (rand() % (1 << 16));\n  }\n  return ans;\n}\n\nint32_t main() {\n#ifndef LOCAL\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n#endif\n\n#ifdef TESTING\n  while (true) {\n    GF a = GetRandom(), b = GetRandom(), c = GetRandom();\n    GF d = Mul(a, Add(b, c));\n    GF e = Add(Mul(a, b), Mul(a, c));\n    debug(a,b,c,d,e);\n    assert(d == e);\n  }\n#endif\n\n  srand(2137);\n\n  const int S = 58;\n  const LL kLarge = 1LL << S;\n  for (int i = 0; i < 70; ++i) {\n    GF x = GetRandom();\n    base.PB(x);\n  }\n  debug(base);\n\n  int N;\n  cin >> N;\n  vector<pair<LL, LL>> values;\n\n  auto TotalGF = [&](LL bound) {\n    GF ans = 0;\n    for (auto &val : values) {\n      ans = Add(ans, AddPositionsUpTo(val.st, val.nd, bound));\n    }\n    debug(bound, ans);\n    return ans;\n  };\n\n  for (int i = 0; i < N; ++i) {\n    LL x, y;\n    cin >> x >> y;\n    values.emplace_back(x + kLarge, y + kLarge);\n  }\n\n  debug(values);\n\n  LL Lzero = 0, Rzero = (1LL << (S + 2));\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == 0) {\n      Lzero = midzero;\n    } else {\n      Rzero = midzero;\n    }\n  }\n\n  const LL first_x = Rzero - kLarge;\n  \n  Lzero = first_x + kLarge - 2; Rzero = (1LL << (S + 2));\n  const GF aim = TotalGF(Rzero);\n\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == aim) {\n      Rzero = midzero;\n    } else {\n      Lzero = midzero;\n    }\n  }\n\n  const LL last_x = Rzero - kLarge;\n\n  cout << first_x << \" \" << last_x - first_x - kLarge << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cassert>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n      \tint qc=2*x.first+x.second+1;int ql=2*x+x.second;\n\tqc = (qc & (int)(0xffffffff)) + ((qc & (0x7fffffff00000000)) >> 32);\n\tqc = (qc & (int)(0xffffffff)) + ((qc & (int)(0x100000000)) >> 32);\n\tqc = (qc & (0xffff)) + ((qc & (int)(0xffff0000)) >> 16);\n\tqc = (qc & (0xffff)) + ((qc & (0x10000)) >> 16);\n\tqc = (qc & (0xff)) + ((qc & (0xff00)) >> 8);\n\tqc = (qc & (0xff)) + ((qc & (0x100)) >> 8);\n\tqc = (qc & (0xf)) + ((qc & (0xf0)) >> 4);\n\tqc = (qc & (0xf)) + ((qc & (0x10)) >> 4);\n\tqc = (qc & 3) + ((qc & 12) >> 2);\n\tqc = (qc & 3) + ((qc & 4) >> 2);\n      assert(qc<=3);\n      assert(qc==(ql%3)+1);\n\t\tc ^= qc;\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\nvel solve(V<vel>& ab, int ex) {\n\tif (ex == 0) { return { 1, 0 }; }\n\tV<vel> ab0, ab1;\n\tfor (auto x : ab) {\n\t\tint a1 = x[0];\n\t\tint b1 = x[1];\n\t\tif (b1 % 2 == 0) {\n\t\t\tab0.push_back({ a1 / 2, b1 / 2 });\n\t\t\tif (a1 % 2 == 1) { ab1.push_back({ a1 / 2, b1 / 2 }); }\n\t\t}\n\t\telse {\n\t\t\tab1.push_back({ a1 / 2, b1 / 2 });\n\t\t\tif (a1 % 2 == 1) { ab0.push_back({ a1 / 2, (b1 + 1) / 2 }); }\n\t\t}\n\t}\n\tvel c0(2), c1(2);\n\tfor (auto x : ab0) {\n\t\tint qc = (3 - x[0] + x[1]) % 3; qc = (qc + 3) % 3;\n\t\tif (qc == 0) { c0[0] ^= 1; }\n\t\tif (qc == 1) { c0[1] ^= 1; }\n\t\tif (qc == 2) { c0[0] ^= 1; c0[1] ^= 1; }\n\t}\n\tfor (auto x : ab1) {\n\t\tint qc = (3 - x[0] + x[1]) % 3; qc = (qc + 3) % 3;\n\t\tif (qc == 0) { c1[0] ^= 1; }\n\t\tif (qc == 1) { c1[1] ^= 1; }\n\t\tif (qc == 2) { c1[0] ^= 1; c1[1] ^= 1; }\n\t}\n\tvel ze(2, 0);\n\tif (c0 == ze) {\n\t\tvel ans = solve(ab1, ex - 1);\n\t\tans[0] *= 2; ans[1] *= 2;ans[1]++;\n\t\treturn ans;\n\t}\n\tif (c1 == ze) {\n\t\tvel ans = solve(ab0, ex - 1);\n\t\tans[0] *= 2; ans[1] *= 2;\n\t\treturn ans;\n\t}\n\trep(i, ab.size()) { ab[i][0]++; }\n\tvel ans = solve(ab, ex); ans[0]--;\n\treturn ans;\n}\nsigned main() {\n\tint inf = 1;\n\trep(i, 57) { inf *= 2; }\n\tint n; cin >> n;\n\tV<vel> ab(n);\n\trep(i, n) {\n\t\tint a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tvel ret = solve(ab, 70);\n\tcout << ret[0] - inf << \" \" << ret[1] - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = 2 * x.first + x.second+1;\n    qc = (qc & (0xffffffff)) + ((qc & (0x7fffffff00000000)) >> 32);\n\tqc = (qc & (0xffffffff)) + ((qc & (0x100000000)) >> 32);\n\tqc = (qc & (0xffff)) + ((qc & (0xffff0000)) >> 16);\n\tqc = (qc & (0xffff)) + ((qc & (0x10000)) >> 16);\n\tqc = (qc & (0xff)) + ((qc & (0xff00)) >> 8);\n\tqc = (qc & (0xff)) + ((qc & (0x100)) >> 8);\n\tqc = (qc & (0xf)) + ((qc & (0xf0)) >> 4);\n\tqc = (qc & (0xf)) + ((qc & (0x10)) >> 4);\n\tqc = (qc & 3) + ((qc & 12) >> 2);\n\tqc = (qc & 3) + ((qc & 4) >> 2);\n\t\tc ^= qc;\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n      \tw++;\n      \tif ((w & x.first) == w) { d ^= 1; }\n\t}\n  \tans.first *= 2; ans.second *= 2;\n\tans.first+=(c|d); ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\n#define R(n)for(L i;i<n;i++){L c\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2)=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n,b;cin>>n;V<W>p(n);R(n);cin>>c>>b;p[i]={c+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"sse2,pclmul,tune=native\")\n#pragma GCC optimize(\"O3\")\n#include <ext/pb_ds/assoc_container.hpp>\n#include <nmmintrin.h>\n#include <emmintrin.h>\n#include <wmmintrin.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nusing GF = uint32_t;\n\ninline GF Add(GF a, GF b) {\n  return a ^ b;\n}\n\ninline GF Mul(GF a, GF b) {\n  __m128i xa = _mm_cvtsi64_si128(a), xb = _mm_cvtsi64_si128(b);\n  xa = _mm_clmulepi64_si128(xa, xb, 0x00);\n  uint64_t res = _mm_cvtsi128_si64(xa);\n  GF hi = res >> 32;\n  GF a0 = hi ^ (hi >> 25) ^ (hi >> 29) ^ (hi >> 30);\n  return (GF)res ^ a0 ^ (a0 << 2) ^ (a0 << 3) ^ (a0 << 7);\n}\n\nvector<GF> base;\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val);\nGF AddPositionsFrom(LL x, LL y, LL min_val);\n\nmap<pair<LL, LL>, GF> memo;\nGF AddPositions(LL x, LL y, int bb = 60) {\n  if (x == 0 && y == 0) { return 1; }\n  debug(\"?Any\", x, y);\n  \n  pair<LL, LL> p{x, y};\n  if (memo.count(p)) { return memo[p]; }\n\n  int bit = bb;\n  while ((1LL << bit) > x + y) { --bit; }\n  if (x >= (1LL << bit)) {\n    GF ans = Mul(base[bit], AddPositions(x ^ (1LL << bit), y));\n    debug(x, y, ans);\n    return memo[p] = ans;\n  }\n\n  // x < 2^bit <= x + y\n  GF answer1 = AddPositionsUpTo(x, y, (1LL << bit) - 1);\n  GF answer2 = AddPositionsFrom(x, y, (1LL << bit));\n  debug(x, y, answer1, answer2);\n  return memo[p] = Add(answer1, answer2);\n}\n\nGF GetValue(LL x) {\n  static map<LL, GF> val_memo;\n  auto it = val_memo.find(x);\n  if (it != val_memo.end()) { return it->nd; }\n\n  GF ans = 1;\n  for (int bit = 60; bit >= 0; --bit) {\n    if ((x >> bit) & 1) {\n      ans = Mul(base[bit], ans);\n    }\n  }\n  debug(\"Value\", x, ans);\n  return val_memo[x] = ans;\n}\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val) {\n  debug(\"?UpTo\", x, y, max_val);\n  if (x > max_val) { return 0; }\n  if (x + y <= max_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int bit = 60; bit >= 0; --bit) {\n    if (!((y >> bit) & 1)) { continue; }\n    const LL v = 1LL << bit;\n    y ^= v;\n\n    if (x + v - 1 <= max_val) {\n      debug(\"UpTo\", orig_x, orig_y, max_val, x, y);\n      answer = Add(answer, AddPositions(x, y));\n      x += v;\n    }\n  }\n  debug(answer);\n  if (x <= max_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF AddPositionsFrom(LL x, LL y, LL min_val) {\n  if (x + y < min_val) { return 0; }\n  if (x >= min_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int bit = 60; bit >= 0; --bit) {\n    if (!((y >> bit) & 1)) { continue; }\n    const LL v = 1LL << bit;\n    y ^= v;\n\n    if (x + v >= min_val) {\n      answer = Add(answer, AddPositions(x + v, y));\n    } else {\n      x += v;\n    }\n  }\n  debug(\"From\", orig_x, orig_y, min_val, answer, x);\n  if (x >= min_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF GetRandom() {\n  GF ans = 0;\n  for (int i = 0; i < 4; ++i) {\n    ans <<= 16;\n    ans |= (rand() % (1 << 16));\n  }\n  return ans;\n}\n\nint32_t main() {\n#ifndef LOCAL\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n#endif\n\n#ifdef TESTING\n  while (true) {\n    GF a = GetRandom(), b = GetRandom(), c = GetRandom();\n    GF d = Mul(a, Add(b, c));\n    GF e = Add(Mul(a, b), Mul(a, c));\n    debug(a,b,c,d,e);\n    assert(d == e);\n  }\n#endif\n\n  srand(2137);\n\n  const int S = 58;\n  const LL kLarge = 1LL << S;\n  for (int i = 0; i < 70; ++i) {\n    GF x = GetRandom();\n    base.PB(x);\n  }\n  debug(base);\n\n  int N;\n  cin >> N;\n  mini(N, 1000LL);\n  vector<pair<LL, LL>> values;\n\n  auto TotalGF = [&](LL bound) {\n    GF ans = 0;\n    for (auto &val : values) {\n      ans = Add(ans, AddPositionsUpTo(val.st, val.nd, bound));\n    }\n    debug(bound, ans);\n    return ans;\n  };\n\n  for (int i = 0; i < N; ++i) {\n    LL x, y;\n    cin >> x >> y;\n    values.emplace_back(x + kLarge, y + kLarge);\n  }\n\n  debug(values);\n\n  LL Lzero = 0, Rzero = (1LL << (S + 2));\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == 0) {\n      Lzero = midzero;\n    } else {\n      Rzero = midzero;\n    }\n  }\n\n  const LL first_x = Rzero - kLarge;\n  \n  Lzero = first_x + kLarge - 2; Rzero = (1LL << (S + 2));\n  const GF aim = TotalGF(Rzero);\n\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == aim) {\n      Rzero = midzero;\n    } else {\n      Lzero = midzero;\n    }\n  }\n\n  const LL last_x = Rzero - kLarge;\n\n  cout << first_x << \" \" << last_x - first_x - kLarge << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "%:pragma GCC optimize(\"Ofast\", \"inline\")\n#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\n  using namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\n#define int long long\nconst int N = 1e5 + 233;\nint inf = 1e17;\nint n, x[N], y[N], qy, ni[N];\nbool dp[65][2][3];\n\ninline bool get(int u, int n, int r) {\n  memset(dp, 0, sizeof dp);\n  int l = n - y[u];\n  l = min(l, ni[u]);\n  r = ((r - y[u]) % 3 + 3) % 3;\n  if (l < 0) return 0;\n  // o \\in[0, l] && o % 3 == r ni[u]Co module 2\n  // cout << l << \" \" << ni[u] << \" \" << r << \"\\n\";\n  dp[0][1][0] = 1; int cur = 0;\n  for (int i = 61; i >= 0; i--) {\n    ++cur;\n    for (int d = 0; d < 2; d++) {\n      for (int pr = 0; pr < 3; pr++) {\n\tint lim = d ? l >> i & 1 : 1;\n\tfor (int ch = 0; ch <= min(ni[u] >> i & 1, lim); ch++) {\n\t  int nd = d && ch == lim;\n\t  int nv = pr + (i & 1 ? -1 : 1) * ch;\n\t  nv = (nv % 3 + 3) % 3;\n\t  // if (i == 2 && d == 1 && pr == 0) {\n\t  //   cout << ch << \" \" << nd << \" \" << nv << \"\\n\";\n\t  // }\n\t  dp[cur][nd][nv] ^= dp[cur - 1][d][pr];\n\t}\n      }\n    }\n  }\n  int ans = 0;\n  for (int d = 0; d < 2; d++)\n    ans ^= dp[cur][d][r];\n  return ans;\n}\n\ninline bool calc(int l, int r, int remain) {\n  bool ans = 0;\n  rep (i, n) {\n    ans ^= get(i, r, remain) ^ get(i, l - 1, remain);\n    // cout << i << \" \" << get(i, r, remain) << \" \" <<  get(i, l - 1, remain) << \"\\n\";\n  }\n  return ans;\n}\n\nsigned main(void) {\n  srand(20021214);\n  read(n);\n  rep (i, n) {\n    read(x[i]), read(y[i]);\n    // mi_i = o - y_i\n  }\n  // cout << get(1, 4, 1) << \"\\n\";\n  // return 0;\n  // cout << calc(-4, 4, 1) << \"\\n\";\n  // return 0;\n  int tr = -1;\n  while (tr != -1) {\n    inf += rand() % 3;\n    rep (i, n) ni[i] = x[i] + inf;\n    re0 (r, 3) if (calc(-inf, inf, r) == true) {\n      tr = r;\n      break;\n    }\n  }\n  assert(calc(-inf, inf, tr) == true);\n  \n  int l = -inf, r = inf;\n  while (l < r) {\n    int mid = l + (r - l) / 2;\n    if (calc(l, mid, tr)) r = mid;\n    else l = mid + 1;\n  }\n  qy = r;\n  \n  auto isBlack = [&](int o) {\n    bool pa = 0;\n    rep (i, n) if (y[i] <= o && o <= x[i] + y[i] + inf) {\n      int nc = x[i] + inf;\n      int mc = o - y[i];\n      pa ^= nc == (nc | mc);\n    }\n    return pa;\n  };\n  assert(isBlack(qy) == true);\n  \n  int ty = qy, ansl, ansr;\n  \n  for (int k = 61; k >= 0; k--) {\n    if (isBlack(qy + (1ll << k))) {\n      qy += 1ll << k;\n    }\n  }\n  ansr = qy;\n  \n  qy = ty;\n  for (int k = 61; k >= 0; k--) {\n    if (isBlack(qy - (1ll << k))) {\n      qy -= 1ll << k;\n    }\n  }\n  ansl = qy;\n\n  cout << -inf + ansr - ansl << \" \" << ansl << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst long long base = 1ll << 57;\nconst int LOG = 60;\n\nint main() {\n#ifdef wxh010910\n  freopen(\"input.txt\", \"r\", stdin);\n#endif\n  int n;\n  cin >> n;\n  vector<long long> x(n), y(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> x[i] >> y[i];\n    x[i] += base;\n    y[i] += base;\n  }\n  vector<bool> equal(3), less(3), new_equal(3), new_less(3);\n  auto solve = [&](long long p, int remainder) {\n    bool ans = false;\n    for (int i = 0; i < n; ++i) {\n      if (p > y[i]) {\n        long long high = p - y[i];\n        for (int j = 0; j < 3; ++j) {\n          equal[j] = less[j] = false;\n        }\n        equal[0] = 1;\n        for (int j = LOG - 1; ~j; --j) {\n          for (int k = 0; k < 3; ++k) {\n            new_equal[k] = new_less[k] = false;\n          }\n          {\n            int l = 0, r = min(x[i] >> j & 1, high >> j & 1);\n            for (int k = 0; k < 3; ++k) {\n              if (equal[k]) {\n                for (int w = l; w <= r; ++w) {\n                  int kk = (k + w * ((j & 1) + 1)) % 3;\n                  if (w == (high >> j & 1)) {\n                    new_equal[kk] = !new_equal[kk];\n                  } else {\n                    new_less[kk] = !new_less[kk];\n                  }\n                }\n              }\n            }\n          }\n          {\n            int l = 0, r = x[i] >> j & 1;\n            for (int k = 0; k < 3; ++k) {\n              if (less[k]) {\n                for (int w = l; w <= r; ++w) {\n                  int kk = (k + w * ((j & 1) + 1)) % 3;\n                  new_less[kk] = !new_less[kk];\n                }\n              }\n            }\n          }\n          swap(equal, new_equal);\n          swap(less, new_less);\n        }\n        ans ^= less[(remainder - y[i] % 3 + 3) % 3];\n      }\n    }\n    return ans;\n  };\n  auto check = [&](long long p) {\n    bool ans = false;\n    for (int i = 0; i < n; ++i) {\n      if (p - y[i] >= 0 && p - y[i] <= x[i] && (x[i] & (p - y[i])) == p - y[i]) {\n        ans = !ans;\n      }\n    }\n    return ans;\n  };\n  int remainder = 0;\n  while (!solve(1ll << LOG, remainder)) {\n    ++remainder;\n  }\n  long long p = 0;\n  for (int i = LOG - 1; ~i; --i) {\n    if (solve(p, remainder) == solve(p + (1ll << i), remainder)) {\n      p += 1ll << i;\n    }\n  }\n  long long l = p;\n  for (int i = LOG - 1; ~i; --i) {\n    if (check(l - (1ll << i))) {\n      l -= 1ll << i;\n    }\n  }\n  long long r = p;\n  for (int i = LOG - 1; ~i; --i) {\n    if (check(r + (1ll << i))) {\n      r += 1ll << i;\n    }\n  }\n  cout << r - l - base << \" \" << l - base << \"\\n\";\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll L = -2e17;\nint n;\nvector<pair<ll,ll> > v;\nbool check_point(pair<ll,ll> p, ll x, ll y)\n{\n\tif (x<p.FF||x>p.FF+p.SS-y) return false;\n\tll X = x-p.FF;\n\tll Y = p.SS-y;\n\treturn (Y&X)==X;\n}\nbool check_point(ll x)\n{\n\tbool ret = 0;\n\tfor (auto p : v)\n\t{\n\t\tif (check_point(p, x, L))\n\t\t{\n\t\t\tret ^= 1;\n\t\t}\n\t}\n\treturn ret;\n}\nbool cnt[3];\nvoid calc(pair<ll,ll> p, ll x, ll y)\n{\n\tif (x<p.FF) return;\n\tif (x>p.FF+p.SS-y) x = p.FF+p.SS-y;\n\tll X = x-p.FF;\n\tll Y = p.SS-y;\n\tassert(Y>=0);\n\tstatic bool dp[66][2][3];\n\tmemset(dp, 0, sizeof(dp));\n\tdp[60][1][0] = 1;\n\tfor (int i=59; i>=0; i--)\n\t{\n\t\tfor (int t=0; t<2; t++)\n\t\t{\n\t\t\tfor (int v=0; v<2; v++)\n\t\t\t{\n\t\t\t\tif (v&&~((Y>>i)&1)) continue;\n\t\t\t\tif (v&&t&&~((X>>i)&1)) continue;\n\t\t\t\tint dlt = ((1ll*v)<<i)%3;\n\t\t\t\tint nt = t&(v==((X>>i)&1));\n\t\t\t\tfor (int j=0; j<3; j++) dp[i][nt][(j+dlt)%3] ^= dp[i+1][t][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tcnt[i] ^= dp[0][0][i];\n\t\tcnt[i] ^= dp[0][1][i];\n\t}\n}\nbool check(ll x)\n{\n\tcnt[0] = cnt[1] = cnt[2] = 0;\n\tfor (auto p : v)\n\t{\n\t\tcalc(p, x, L);\n\t}\n\treturn cnt[0]||cnt[1]||cnt[2];\n}\nint main()\n{\n\tgeti(n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll x, y;\n\t\tgetii(x, y);\n\t\tv.PB(MP(x, y));\n\t}\n/*\tfor (int i=L; i<=-L; i++)\n\t{\n\t\tcerr<<check_point(i);\n\t\tif ((i-L)%5==0) cerr<<\" \";\n\t} cerr<<endl;\n*/\n\tll l = 2*L, r = -l;\n\twhile (l<=r)\n\t{\n\t\tll m = l+r>>1;\n\t\tif (check(m)) r = m-1; else l = m+1;\n\t}\n//\tcerr<<l<<\",\"<<r<<endl;\n\tl = r;\n\tfor (int i=0; i<=60; i++) if (check_point(l-(1ll<<i))) l -= 1ll<<i;\n\tfor (int i=0; i<=60; i++) if (check_point(r+(1ll<<i))) r += 1ll<<i;\n\tcout<<l<<\" \"<<L+(r-l)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nVPII lamps;\n//int C;\n// VI Xor(VI L, VI R) {\n//   REP (tr, SZ(L)) {\n//     L[tr] ^= R[tr];\n//   }\n//   return L;\n// }\nint Shift(int heh, int shift) {\n  if (heh == 7) { return heh; }\n  if (heh == 0) { return heh; }\n  shift %= 3;\n  heh *= (1 << shift);\n  return heh % 7;\n//   VI dupa(SZ(heh));\n//   REP (i, SZ(heh)) {\n//     dupa[(i + shift) % SZ(heh)] = heh[i];\n//   }\n//   return dupa;\n}\nint CountLamps1(int kInf, int e, int x, int y) {\n  //debug(kInf, e, x, y);\n  int d = kInf - x - y;\n  if (e < y) {\n    return 0; //{0, 0, 0};\n  }\n  VI bits;\n  REP (bit, 60) {\n    if (d & (1ll << bit)) {\n      bits.PB(1);\n    } else {\n      bits.PB(0);\n    }\n  }\n  vector<int> prefs{1};\n  //prefs.PB({1, 0, 0});\n  REP (bit, 60) {\n    if (!bits[bit]) {\n      prefs.PB(prefs.back());\n    } else if (bit % 2) {\n      prefs.PB(prefs.back() ^ Shift(prefs.back(), 2));\n    } else {\n      prefs.PB(prefs.back() ^ Shift(prefs.back(), 1));\n    }\n  }\n  int maxY = kInf - x;\n  if (e >= maxY) {  return Shift(prefs.back(), (y % 3 + 3) % 3); }\n  int shift = 0;\n  int how_many = e - y + 1;\n  //debug(how_many);\n  int so_far = 0;;\n  FORD (bit, 59, 0) {\n    if (how_many & (1ll << bit)) {\n      //debug(prefs[bit], shift % 3);\n      so_far = so_far ^ Shift(prefs[bit], shift);\n      \n      if (bits[bit]) {\n        shift += (1ll << bit);\n        shift %= 3;\n      } else {\n        break;\n      }\n    }\n  }\n  //debug(so_far);\n  return Shift(so_far, (y % 3 + 3) % 3);\n}\nint CountLampsAll(int kInf, int e) {\n  int hehs = 0;\n  for (auto lamp : lamps) {\n    int lul = CountLamps1(kInf, e, lamp.st, lamp.nd);\n    hehs = hehs ^ lul;\n  }\n  return hehs;\n}\nint CountLampsAll(int kInf, int b, int e) {\n  return CountLampsAll(kInf, e) ^ CountLampsAll(kInf, b - 1);\n}\nint IsLit(int x, int y) {\n  int heh = 0;\n  for (auto lamp : lamps) {\n    int d = x + y - lamp.st - lamp.nd;\n    if (lamp.nd > y) { continue; }\n    if (lamp.st > x) { continue; }\n    int ind = y - lamp.nd;\n    if ((ind & d) == ind) {\n      heh ^= 1;\n    }\n  }\n  return heh;\n}\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n\n//   kInf = 1;\n//   debug(CountLamps1(1, 0, 0));\n  //kInf = 5;\n  //debug(CountLamps1(5, 0, 0));\n  //debug(CountLamps1(4, 0, 0));\n//   debug(CountLamps1(3, 0, 0));\n//   kInf = 6;\n//   debug(CountLamps1(6, 0, 0));\n//   debug(CountLamps1(5, 0, 0));\n//   debug(CountLamps1(4, 0, 0));\n  \n  \n  \n  \n  const int kInf = 4e17;\n  \n  int n;\n  cin>>n;\n  RE (i, n) {\n    int x, y;\n    cin>>x>>y;\n    //maxi(C, x + y);\n    lamps.PB({x, y});\n  }\n  int hehs = CountLampsAll(kInf, kInf);\n//   int r;\n//   REP (tr, 3) {\n//     if (hehs & (1 << bit)) { r = tr; }\n//   }\n  int kl = -kInf, kp = 2 * kInf;\n  //VI zeros{0, 0, 0};\n  //assert(CountLampsAll(kInf, kl, kp) != zeros);\n  while (kl != kp) {\n    if (kl == kp) { break; }\n    int aktc = (kl + kp) / 2;\n    //assert(CountLampsAll(kInf, kl, kp) == Xor(CountLampsAll(kInf, kl, aktc), CountLampsAll(kInf, aktc + 1, kp)));\n    if (CountLampsAll(kInf, kl, aktc)) {\n      kp = aktc;\n    } else {\n      kl = aktc + 1;\n    }\n  }\n  debug(CountLampsAll(kInf, kl, kl), kl, kl % 3);\n  assert(IsLit(kInf - kl, kl));\n  int L = kl, R = kl;\n  FORD (bit, 60, 0) {\n    int candL = L - (1ll << bit);\n    debug(L & (1ll << bit), bit); \n    if (IsLit(kInf - candL, candL)) {\n      debug(\"dol\");\n      L = candL;\n    }\n    int candR = R + (1ll << bit);\n    if (IsLit(kInf - candR, candR)) {\n      R = candR;\n    }\n  }\n  // R to maxy, L to miny\n  int X = kInf - R;\n  int Y = L;\n  cout<<X<<\" \"<<Y<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n    int N; cin>>N;\n    vector<long long> x(N), y(N);\n    for (int i=0; i<N; i++)\n        cin>>x[i]>>y[i];\n\n    //  https://img.atcoder.jp/wtf19-open/editorial.pdf\n    long long c = 1LL<<60;\n    \n    //  y = c の直線上のランプのみが点灯するようにしたときに、\n    //  x%m = r を満たす (x, c) のランプが点灯しているか\n    //  m = 2^k\n    //  mが充分に大きければ、(r, y) のランプが点灯しているかどうかになる\n    auto check = [&](long long m, long long r)\n    {\n        bool ret = false;\n        //  (r, c) のランプが点灯している ⇔ XOR[0<=i<N]((c-y[i]) | ~(r-x[i]) の全てのビットが立っている)\n        //  下位kビット目まで考えれば、残りの必要なビットが立っているxが存在するので、\n        //  上位ビットは単に無視すれば良い\n        for (int i=0; i<N; i++)\n            if (!~( ((c-y[i]) | ~(r-x[i])) | ~(m-1) ))\n                ret = !ret;\n        return ret;\n    };\n\n    //  (p, c) のランプが付いているpを求める\n    //  check(m, x) が真ならば、check(2*m, x) か check(2*m, x+m) のどちらか少なくとも一方は真である\n    //  x>=0 に必ず点灯しているランプがあり、pはなるべく小さくなるように求めているので、\n    //  pが負になることは考慮しなくて良い\n    long long p = 0;\n    for (int k=0; k<60; k++)\n        if (!check(1LL<<(k+1), p))\n            p |= 1LL<<k;\n\n    long long l = p;\n    for (int k=60; k>=0; k--)\n        if (check(1LL<<62, l-(1LL<<k)))\n            l -= 1LL<<k;\n    long long r = p;\n    for (int k=60; k>=0; k--)\n        if (check(1LL<<62, r+(1LL<<k)))\n            r += 1LL<<k;\n    cout<<l<<\" \"<<c-(r-l)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, a, b) for(int i = (a), i##end = (b); i <= i##end; ++ i)\n#define CLR(i, a) memset(i, a, sizeof(i))\n#define REPD(i, a, b) for(int i = (a), i##end = (b); i >= i##end; -- i)\n#define LOG(x) std::cerr << #x << \":\" << x << '\\n'\n#define DBG(...) fprintf(stderr, __VA_ARGS__)\n#define OK fprintf(stderr, \"Passing %s in LINE [%d]\\n\", __FUNCTION__, __LINE__)\n#define gc getchar\n#define pc putchar\n#define endl '\\n'\ntypedef long long LL;\ntypedef double DB;\ninline LL rd() {\n\tchar ch = gc(); LL ret = 0, sgn = 1;\n\twhile(ch < '0' || ch > '9') {\n\t\tif(ch == '-') sgn = -1;\n\t\tch = gc();\n\t}\n\twhile(ch <= '9' && ch >= '0') \n\t\tret = ret * 10 + ch - '0', ch = gc();\n\treturn ret * sgn;\n}\n/**************************************************************/\n\nconst int N = 1e4 + 3, LG = 60;\nconst LL INF = 1ll << 60;\n\nLL qx[N], qy[N], bot, rem;\nint n;\nint ind;\nbool f[N][LG + 3][3], vis[N][LG + 3][3];\n\nbool ifValid(LL x) {\n\tbool ret = 0;\n\tREP(i, 1, n) if(qx[i] <= x) {\n\t\tLL u = qy[i] - bot, v = x - qx[i];\n\t\tret ^= ((u | v) == u);\n\t}\n\treturn ret;\n}\n\nint upa[LG + 3], upb[LG + 3];\n\nbool Dp(int pos, int tr, bool lim) {\n\t// assert(tr <= 2);\n\tif(pos < 0) {\n\t\t// if(tr == 0) OK;\n\t\treturn (tr == 0);\n\t}\n\tif(!lim && vis[ind][pos][tr]) return f[ind][pos][tr];\n\t// LOG(tr);\n\tint up = lim ? upa[pos] : 1;\n\tup = min(up, upb[pos]); \n\n\tbool ret = 0;\n\tREP(i, 0, up) {\n\t\tint ntr = (tr + 3 - ((LL)i * (1ll << pos) % 3) % 3) % 3;\n\t\tbool nlim = lim & (i == upa[pos]);\n\t\tret ^= Dp(pos - 1, ntr, nlim);\n\t}\n\n\tif(!lim) {\n\t\tvis[ind][pos][tr] = 1;\n\t\tf[ind][pos][tr] = ret; \n\t}\n\treturn ret;\n}\n\ninline bool __main__(LL all, LL ql, LL qr, LL trem) {\n\t// assert(ql <= qr);\n\tif(ql > qr) return 0;\n\t// assert(ql >= 0 && qr >= 0);\n\tREP(i, 0, LG) {\n\t\tupb[i] = (all >> i) & 1;\n\t\tupa[i] = (qr >> i) & 1;\n\t}\n\tbool ret = Dp(LG, trem, 1);\n\tif(ql > 0) {\n\t\tREP(i, 0, LG) upa[i] = ((ql - 1) >> i) & 1;\n\t\tret ^= Dp(LG, trem, 1);\n\t}\n\treturn ret;\n}\n\nbool Calc_sz(LL L, LL R) {\n\t// assert(L <= R);\n\tbool ret = 0;\n\tREP(i, 1, n) {\n\t\tLL tl = max(qx[i], L) - qx[i], tr = min(qx[i] + qy[i] - bot, R) - qx[i];\n\t\tint trem = (rem - qx[i] % 3 + 3) % 3;\n\t\tind = i;\n\t\tret ^= __main__(qy[i] - bot, tl, tr, trem);\t\n\t}\n\treturn ret;\n}\n\nint main() {\n\tn = rd();\n\tbot = INF;\n\tLL ll = INF, rr = -INF;\n\tREP(i, 1, n) {\n\t\tqx[i] = rd(), qy[i] = rd();\n\t\t// LOG(qx[i]), LOG(qy[i]);\n\t\tbot = min(qy[i], bot);\n\t\tll = min(ll, qx[i]), rr = max(rr, qx[i]);\n\t}\n\t-- bot;\n\t// LOG(ll), LOG(rr);\n\t// Calc_sz(ll, rr);\n\tfor(rem = 0; !Calc_sz(ll, rr) && rem < 3; ++ rem) ;\n\t// LOG(rem);\n\tLL l = ll, r = rr;\n\twhile(l < r) {\n\t\tLL mid = l + r >> 1;\n\t\tif(Calc_sz(l, mid)) r = mid;\n\t\telse l = mid + 1; \n\t}\n\t// puts(\"Heghlu' meH QaQ jajvam\"), exit(0);\n\t// OK;\n\tstatic LL pw[LG + 3];\n\tpw[0] = 1;\n\tREP(i, 1, LG) pw[i] = pw[i - 1] << 1ll;\n\tLL resl = l, resr = l;\n\tREPD(k, LG, 0) {\n\t\tif(ifValid(resl - pw[k])) resl -= pw[k];\n\t\tif(ifValid(resr + pw[k])) resr += pw[k];\n\t}\n\tprintf(\"%lld %lld\\n\", resl, bot + (resr - resl));\n\treturn 0;\n}\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define W V<long long>\n#define L long long\n#define R(n) for(L i=0;i<n;i++)\nW S(V<W>&p,L E){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}V<W>c(3,W(2));R(2){for(W x:T[i]){L Q=(2*x[0]+x[1])%3;if((Q+1)%2){c[i][0]^=1;}if(Q){c[i][1]^=1;}}}R(2){if(c[1-i]==c[2]){W ans=S(T[i],E-1);ans[0]*=2;ans[1]*=2;ans[1]+=i;return ans;}}for(W&v:p){v[0]++;}W A=S(p,E);A[0]--;return A;}\nint main(){L M=2e17;L n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}W Q=S(p,70);cout<<Q[0]-M<<\" \"<<Q[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { d ^= 1; }\n\t}\n\tans.first *= 2; ans.first+=c; ans.second *= 2; ans.second -= c&d;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n\nvoid f(vector<pair<ll, ll>> &a, function<pair<ll, ll>(pair<ll, ll>)> encode,\n       function<pair<ll, ll>(pair<ll, ll>)> decode) {\n  map<ll, map<ll, bool>> m;\n  for (auto e : a) {\n    auto p = encode(e);\n    m[p.first][p.second] ^= true;\n  }\n  a.clear();\n  while (!m.empty()) {\n    ll k = begin(m)->first;\n    auto h = begin(m)->second;\n    m.erase(begin(m));\n    for (auto &e : h) {\n      for (ll w = 1; e.second && e.first + w <= 1e17; w *= 2) {\n        if (h.count(e.first + w) && h[e.first + w]) {\n          e.second = false;\n          h[e.first + w] = false;\n          m[k + w][e.first] ^= true;\n        }\n      }\n      if (e.second) {\n        a.push_back(decode({k, e.first}));\n      }\n    }\n  }\n}\n\nint main() {\n  int n;\n  cin >> n;\n  vector<pair<ll, ll>> a(n);\n  for (auto &e : a) {\n    cin >> e.first >> e.second;\n  }\n  while (a.size() > 1) {\n    f(a,\n      [](pair<ll, ll> p) {\n        return pair<ll, ll>{p.second, p.first};\n      },\n      [](pair<ll, ll> p) {\n        return pair<ll, ll>{p.second, p.first};\n      });\n    // cerr << a.size() << endl;\n    // for (auto e : a) {\n    //   cerr << e.first << \" \" << e.second << endl;\n    // }\n    f(a,\n      [](pair<ll, ll> p) {\n        return pair<ll, ll>{-(p.first + p.second), p.second};\n      },\n      [](pair<ll, ll> p) {\n        return pair<ll, ll>{-(p.first + p.second), p.second};\n      });\n    // cerr << a.size() << endl;\n    // for (auto e : a) {\n    //   cerr << e.first << \" \" << e.second << endl;\n    // }\n    f(a,\n      [](pair<ll, ll> p) {\n        return pair<ll, ll>{p.first, p.second};\n      },\n      [](pair<ll, ll> p) {\n        return pair<ll, ll>{p.first, p.second};\n      });\n    // cerr << a.size() << endl;\n    // for (auto e : a) {\n    //   cerr << e.first << \" \" << e.second << endl;\n    // }\n  }\n  cout << a.front().first << \" \" << a.front().second << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n  \tc=0;\n  \tfor (pin& x : qab[1]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n  \tif (!c) {\n\t\tans.first *= 2; ans.second *= 2;\n\t\treturn ans;\n\t}\n\tc = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second-1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t}\n\tans.first *= 2; ans.first++; ans.second *= 2; ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n  vel c(2);\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n          c[i]^=(qc+1);\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"sse2,pclmul,tune=native\")\n#pragma GCC optimize(\"O3\")\n#include <ext/pb_ds/assoc_container.hpp>\n#include <nmmintrin.h>\n#include <emmintrin.h>\n#include <wmmintrin.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nusing GF = uint32_t;\n\ninline GF Add(GF a, GF b) {\n  return a ^ b;\n}\n\ninline GF Mul(GF a, GF b) {\n  __m128i xa = _mm_cvtsi64_si128(a), xb = _mm_cvtsi64_si128(b);\n  xa = _mm_clmulepi64_si128(xa, xb, 0x00);\n  uint64_t res = _mm_cvtsi128_si64(xa);\n  GF hi = res >> 32;\n  GF a0 = hi ^ (hi >> 25) ^ (hi >> 29) ^ (hi >> 30);\n  return (GF)res ^ a0 ^ (a0 << 2) ^ (a0 << 3) ^ (a0 << 7);\n}\n\nvector<GF> base;\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val);\nGF AddPositionsFrom(LL x, LL y, LL min_val);\n\nmap<pair<LL, LL>, GF> memo;\nGF AddPositions(LL x, LL y, int bb = 60) {\n  if (x == 0 && y == 0) { return 1; }\n  debug(\"?Any\", x, y);\n  \n  pair<LL, LL> p{x, y};\n  if (memo.count(p)) { return memo[p]; }\n\n  int bit = bb;\n  while ((1LL << bit) > x + y) { --bit; }\n  if (x >= (1LL << bit)) {\n    GF ans = Mul(base[bit], AddPositions(x ^ (1LL << bit), y));\n    debug(x, y, ans);\n    return memo[p] = ans;\n  }\n\n  // x < 2^bit <= x + y\n  GF answer1 = AddPositionsUpTo(x, y, (1LL << bit) - 1);\n  GF answer2 = AddPositionsFrom(x, y, (1LL << bit));\n  debug(x, y, answer1, answer2);\n  return memo[p] = Add(answer1, answer2);\n}\n\nGF GetValue(LL x) {\n  static map<LL, GF> val_memo;\n  auto it = val_memo.find(x);\n  if (it != val_memo.end()) { return it->nd; }\n\n  GF ans = 1;\n  for (int bit = 60; bit >= 0; --bit) {\n    if ((x >> bit) & 1) {\n      ans = Mul(base[bit], ans);\n    }\n  }\n  debug(\"Value\", x, ans);\n  return val_memo[x] = ans;\n}\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val) {\n  debug(\"?UpTo\", x, y, max_val);\n  if (x > max_val) { return 0; }\n  if (x + y <= max_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int bit = 60; bit >= 0; --bit) {\n    if (!((y >> bit) & 1)) { continue; }\n    const LL v = 1LL << bit;\n    y ^= v;\n\n    if (x + v - 1 <= max_val) {\n      debug(\"UpTo\", orig_x, orig_y, max_val, x, y);\n      answer = Add(answer, AddPositions(x, y));\n      x += v;\n    }\n  }\n  debug(answer);\n  if (x <= max_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF AddPositionsFrom(LL x, LL y, LL min_val) {\n  if (x + y < min_val) { return 0; }\n  if (x >= min_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int bit = 60; bit >= 0; --bit) {\n    if (!((y >> bit) & 1)) { continue; }\n    const LL v = 1LL << bit;\n    y ^= v;\n\n    if (x + v >= min_val) {\n      answer = Add(answer, AddPositions(x + v, y));\n    } else {\n      x += v;\n    }\n  }\n  debug(\"From\", orig_x, orig_y, min_val, answer, x);\n  if (x >= min_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF GetRandom() {\n  GF ans = 0;\n  for (int i = 0; i < 4; ++i) {\n    ans <<= 16;\n    ans |= (rand() % (1 << 16));\n  }\n  return ans;\n}\n\nint32_t main() {\n#ifndef LOCAL\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n#endif\n\n#ifdef TESTING\n  while (true) {\n    GF a = GetRandom(), b = GetRandom(), c = GetRandom();\n    GF d = Mul(a, Add(b, c));\n    GF e = Add(Mul(a, b), Mul(a, c));\n    debug(a,b,c,d,e);\n    assert(d == e);\n  }\n#endif\n\n  srand(2137);\n\n  const int S = 58;\n  const LL kLarge = 1LL << S;\n  for (int i = 0; i < 70; ++i) {\n    GF x = GetRandom();\n    base.PB(x);\n  }\n  debug(base);\n\n  int N;\n  cin >> N;\n  assert(N <= 4000);\n  vector<pair<LL, LL>> values;\n\n  auto TotalGF = [&](LL bound) {\n    GF ans = 0;\n    for (auto &val : values) {\n      ans = Add(ans, AddPositionsUpTo(val.st, val.nd, bound));\n    }\n    debug(bound, ans);\n    return ans;\n  };\n\n  for (int i = 0; i < N; ++i) {\n    LL x, y;\n    cin >> x >> y;\n    values.emplace_back(x + kLarge, y + kLarge);\n  }\n\n  debug(values);\n\n  LL Lzero = 0, Rzero = (1LL << (S + 2));\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == 0) {\n      Lzero = midzero;\n    } else {\n      Rzero = midzero;\n    }\n  }\n\n  const LL first_x = Rzero - kLarge;\n  \n  Lzero = first_x + kLarge - 2; Rzero = (1LL << (S + 2));\n  const GF aim = TotalGF(Rzero);\n\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == aim) {\n      Rzero = midzero;\n    } else {\n      Lzero = midzero;\n    }\n  }\n\n  const LL last_x = Rzero - kLarge;\n\n  cout << first_x << \" \" << last_x - first_x - kLarge << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70,M=2e17,i,a,b;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[(++x[1])&1].push_back({x[0]/2,x[1]/2});}for(L i;i<2;i++){L c=0;for(W x:T[!i])c^=(2*x[0]+x[1])%3+1;if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){cin>>i;V<W>p(i);while(i--,cin>>a>>b)p[i]={a+M,b+M};W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin &x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\trep(i, 2) {\n\t\tfor (pin &x : qab[1-i]) {\n\t\t\tint qc = (2 * x.first + x.second)%3;\n          c^=(qc+1);\n\t\t}\n\t\tif (!c) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1, 0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc + 1) % 2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0] && !c[1 - i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor (pin& v : ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\",&n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld,%lld\",&a,&b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\treturn solve(qab[1],ex-1);\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define W V<long long>\n#define R(n) for(int i=0;i<n;i++)\nW S(V<W>&p,int E){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}V<W>c(3,W(2));R(2){for(W x:T[i]){int Q=(2*x[0]+x[1])%3;if((Q+1)%2){c[i][0]^=1;}if(Q){c[i][1]^=1;}}}R(2){if(c[1-i]==c[2]){W ans=S(T[i],E-1);ans[0]*=2;ans[1]*=2;ans[1]+=i;return ans;}}for(W&v:p){v[0]++;}W A=S(p,E);A[0]--;return A;}\nint main(){long long M=2e17;int n;cin>>n;V<W>p(n);R(n){long long a,b;cin>>a>>b;p[i]={a+M,b+M};}W Q=S(p,70);cout<<Q[0]-M<<\" \"<<Q[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin &x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n  \tint c=0;\n  \tfor (pin &x : qab[0]) {\n         int qc = (2 * x.first + x.second)%3;\n         c^=(qc+1);\n    }\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second += 1;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n   \tc=0;\n\tfor (pin &x : qab[1]) {\n        int qc = (2 * x.first + x.second)%3;\n        c^=(qc+1);\n\t}\n\tif (!c) {\n       \tans.first *= 2; ans.second *= 2;\n\t\treturn ans;\n\t}\n  \tint val=ans.first-1;\n  \tfor(pin &x:qab[0]){\n      if(((val-x.second)&x.first)==(val-x.second)){ans.first^=1;}\n    }\n  \tans.first*=2;ans.second*=2;ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\nvel solve(V<vel>& ab, int ex) {\n\tif (ex == 0) { return { 1, 0 }; }\n\tV<vel> ab0, ab1;\n\tfor (auto x : ab) {\n\t\tint a1 = x[0];\n\t\tint b1 = x[1];\n\t\tif (b1 % 2 == 0) {\n\t\t\tab0.push_back({ a1 / 2, b1 / 2 });\n\t\t\tif (a1 % 2 == 1) { ab1.push_back({ a1 / 2, b1 / 2 }); }\n\t\t}\n\t\telse {\n\t\t\tab1.push_back({ a1 / 2, b1 / 2 });\n\t\t\tif (a1 % 2 == 1) { ab0.push_back({ a1 / 2, (b1 + 1) / 2 }); }\n\t\t}\n\t}\n\tvel c0(2), c1(2);\n\tfor (auto x : ab0) {\n\t\tint qc = (3 - x[0] + x[1]) % 3; qc = (qc + 3) % 3;\n\t\tif (qc == 0) { c1[0] ^= 1; }\n\t\tif (qc == 1) { c1[1] ^= 1; }\n\t\tif (qc == 2) { c1[0] ^= 1; c1[1] ^= 1; }\n\t}\n\tfor (auto x : ab1) {\n\t\tint qc = (3 - x[0] + x[1]) % 3; qc = (qc + 3) % 3;\n\t\tif (qc == 0) { c1[0] ^= 1; }\n\t\tif (qc == 1) { c1[1] ^= 1; }\n\t\tif (qc == 2) { c1[0] ^= 1; c1[1] ^= 1; }\n\t}\n\tvel ze(2, 0);\n\tif (c0 == ze) {\n\t\tvel ans = solve(ab1, ex - 1);\n\t\tans[0] *= 2; ans[1] *= 2;ans[1]++;\n\t\treturn ans;\n\t}\n\tif (c1 == ze) {\n\t\tvel ans = solve(ab0, ex - 1);\n\t\tans[0] *= 2; ans[1] *= 2;\n\t\treturn ans;\n\t}\n\trep(i, ab.size()) { ab[i][0]++; }\n\tvel ans = solve(ab, ex); ans[0]--;\n\treturn ans;\n}\nsigned main() {\n\tint inf = 1;\n\trep(i, 57) { inf *= 2; }\n\tint n; cin >> n;\n\tV<vel> ab(n);\n\trep(i, n) {\n\t\tint a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tvel ret = solve(ab, 70);\n\tcout << ret[0] - inf << \" \" << ret[1] - inf << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\nvoid tostr(ll x,string& res){while(x)res+=('0'+(x%10)),x/=10; reverse(ALL(res)); return;}\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//end\n\nconstexpr ll c=200'000'000'000'000'000LL;\nint N; ll x[11000],y[11000];\nbool que(ll n,ll r){if(n<0||r<0||n<r)return 0; return (n&r)==r;}\nbool col(ll a){\n   bool res=0;\n   rep(i,0,N)if(a>=x[i])res^=que(c-x[i]-y[i],a-x[i]);\n   return res;\n}\nll calc(ll n,ll t,int r){\n   if(t<0)return 0;\n   chmin(t,n); ll dp[64][3][2]={}; dp[60][0][1]=1;\n   rrep(i,59,-1)rep(j,0,3)rep(k,0,2)if(dp[i+1][j][k]){\n      rep(nxt,0,2){\n         if((n>>i&1)==0&&nxt)continue;\n         if(k&&nxt&&(t>>i&1)==0)continue;\n         int nj=(j+(nxt?(i&1?2:1):0))%3,nk=k;\n         if(nxt==0&&(t>>i&1))nk=0;\n         dp[i][nj][nk]+=dp[i+1][j][k];\n      }\n   } return dp[0][r][0]+dp[0][r][1];\n}\nll rng(ll n,ll lb,ll rb,int r){return calc(n,rb,r)-calc(n,lb,r);}\nbool flag(ll lb,ll rb,int r){\n   bool res=0;\n   rep(i,0,N)res^=rng(c-x[i]-y[i],lb-x[i],rb-x[i],((r-x[i])%3+3)%3)&1;\n   return res;\n}\n\n//reference:https://physics0523.hatenablog.com/entry/2019/02/26/190724\nint main(){\n   scanf(\"%d\",&N); rep(i,0,N)scanf(\"%lld%lld\",&x[i],&y[i]);\n   ll lb=-c/2,rb=c/2; int r=-1;\n   rep(i,0,3)if(flag(lb,rb,i)){r=i; break;}\n   assert(r>=0);\n   while(rb-lb>1){\n      ll mid=(lb+rb)>>1;\n      if(flag(lb,mid,r))rb=mid; else lb=mid;\n   } assert(col(rb));\n   ll x1=rb,x2=rb;\n   rrep(k,62,-1){\n      if(col(x1-(1LL<<k)))x1-=1LL<<k;\n      if(col(x2+(1LL<<k)))x2+=1LL<<k;\n   } printf(\"%lld %lld\\n\",x1,c-x2);\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define W V<long long>\n#define L long long\n#define R(n) for(L i=0;i<n;i++)\nW S(V<W>&p,L E){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}V<W>c(4,W(3));c[3]=W(3,1);R(2){for(W x:T[i]){L Q=(2*x[0]+x[1])%3;c[i][Q]^=1;}}R(2){if(c[!i]==c[2]||c[!i]==c[3]){W ans=S(T[i],E-1);ans[0]*=2;ans[1]*=2;ans[1]+=i;return ans;}}for(W&v:p){v[0]++;}W A=S(p,E);A[0]--;return A;}\nint main(){L M=2e17;L n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}W Q=S(p,70);cout<<Q[0]-M<<\" \"<<Q[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\nvoid tostr(ll x,string& res){while(x)res+=('0'+(x%10)),x/=10; reverse(ALL(res)); return;}\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//end\n\nconstexpr ll c=300000000000000000LL;\nint N; ll x[11000],y[11000];\nbool que(ll n,ll r){if(n<0||r<0||n<r)return 0; return (n&r)==r;}\nbool col(ll a){\n   bool res=0;\n   rep(i,0,N)if(a>=x[i])res^=que(c-x[i]-y[i],a-x[i]);\n   return res;\n}\nll calc(ll n,ll t,int r){\n   if(t<0)return 0;\n   chmin(t,n); ll dp[64][3][2]={}; dp[60][0][1]=1;\n   rrep(i,59,-1)rep(j,0,3)rep(k,0,2)if(dp[i+1][j][k]){\n      rep(nxt,0,2){\n         if((n>>i&1)==0&&nxt)continue;\n         if(k&&nxt&&(t>>i&1)==0)continue;\n         int nj=(j+(nxt?(i&1?2:1):0))%3,nk=k;\n         if(nxt==0&&(t>>i&1))nk=0;\n         dp[i][nj][nk]+=dp[i+1][j][k];\n      }\n   } return dp[0][r][0]+dp[0][r][1];\n}\nll rng(ll n,ll lb,ll rb,int r){return calc(n,rb,r)-calc(n,lb,r);}\nbool flag(ll lb,ll rb,int r){\n   bool res=0;\n   rep(i,0,N)res^=rng(c-x[i]-y[i],lb-x[i],rb-x[i],((r-x[i])%3+3)%3)&1;\n   return res;\n}\n\n//reference:https://physics0523.hatenablog.com/entry/2019/02/26/190724\nint main(){\n   scanf(\"%d\",&N); rep(i,0,N)scanf(\"%lld%lld\",&x[i],&y[i]);\n   ll lb=-c/2,rb=c/2; int r=-1;\n   rep(i,0,3)if(flag(lb,rb,i)){r=i; break;}\n   //assert(r>=0);\n   while(rb-lb>1){\n      ll mid=(lb+rb)>>1;\n      if(flag(lb,mid,r))rb=mid; else lb=mid;\n   } assert(col(rb));\n   ll x1=rb,x2=rb;\n   rrep(k,62,-1){\n      if(col(x1-(1LL<<k)))x1-=1LL<<k;\n      if(col(x2+(1LL<<k)))x2+=1LL<<k;\n   } printf(\"%lld %lld\\n\",x1,c-x2);\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define W V<long long>\n#define R(i,n) for(int i=0;i<n;i++)\nW S(V<W>&p,int E){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}V<W>c(3,W(2));R(i,2){for(W x:T[i]){int Q=(2*x[0]+x[1])%3;if((Q+1)%2){c[i][0]^=1;}if(Q){c[i][1]^=1;}}}R(i,2){if(c[1-i]==c[2]){W ans=S(T[i],E-1);ans[0]*=2;ans[1]*=2;ans[1]+=i;return ans;}}for(W&v:p){v[0]++;}W A=S(p,E);A[0]--;return A;}\nint main(){long long M=2e17;int n;cin>>n;V<W>p(n);R(i,n){long long a,b;cin>>a>>b;p[i]={a+M,b+M};}W Q=S(p,70);cout<<Q[0]-M<<\" \"<<Q[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvector<ii> vec;\n\nint color(ll x, ll y)\n{\n\tint ans=0;\n\tint n=vec.size();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll x2=vec[i].fi; ll y2=vec[i].se;\n\t\tll d = x-x2;\n\t\tll h = y2-y;\n\t\tif(d<0||d>h) continue;\n\t\tif((d&h)==d) ans^=1;\n\t}\n\treturn ans;\n}\n\nconst ll C = -ll(1e18);\nint md[63];\n\nll getbelow(ll r, int mod)\n{\n\tint res[3]; memset(res,0,sizeof(res));\n\tfor(ii pt:vec)\n\t{\n\t\tll x=pt.fi; ll y=pt.se;\n\t\tif(x>r) continue;\n\t\tll mx = r-x;\n\t\tint dp[2][3];\n\t\tmemset(dp,0,sizeof(dp));\n\t\tint xmod=x%3;\n\t\tif(xmod<0) xmod+=3;\n\t\tdp[1][0]=1;\n\t\tfor(int i=62;i>=0;i--)\n\t\t{\n\t\t\tint nw[2][3]; memset(nw,0,sizeof(nw));\n\t\t\tfor(int k=0;k<2;k++) //1 if still a prefix of mx\n\t\t\t{\n\t\t\t\tfor(int l=0;l<3;l++) //mod\n\t\t\t\t{\n\t\t\t\t\tif(!dp[k][l]) continue;\n\t\t\t\t\t//add 1\n\t\t\t\t\t{\n\t\t\t\t\t\tif(y&(1LL<<i))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(k==1&&(!mx&(1LL<<i)))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint newk=0;\n\t\t\t\t\t\t\t\tif(k==1&&(mx&(1LL<<i))) newk=1;\n\t\t\t\t\t\t\t\tint newl=(l+md[i])%3;\n\t\t\t\t\t\t\t\tnw[newk][newl]^=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//add 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint newk=0;\n\t\t\t\t\t\tif(k==1&&!(mx&(1LL<<i))) newk=1;\n\t\t\t\t\t\tint newl=l;\n\t\t\t\t\t\tnw[newk][newl]^=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=0;k<2;k++) //1 if still a prefix of mx\n\t\t\t{\n\t\t\t\tfor(int l=0;l<3;l++) //mod\n\t\t\t\t{\n\t\t\t\t\tdp[k][l]=nw[k][l];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int l=0;l<3;l++)\n\t\t{\n\t\t\tint nwmod=(xmod+l)%3;\n\t\t\tint as=(dp[0][l]^dp[1][l]);\n\t\t\tres[nwmod]^=as;\n\t\t}\n\t}\n\treturn res[mod];\n}\n\nll getcount(ll l, ll r, int mod) //%3 = mod\n{\n\treturn getbelow(r,mod)-getbelow(l-1,mod);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tfor(int i=0;i<63;i++) md[i]=((1LL<<i))%3;\n\tint n; cin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll x,y; cin>>x>>y; vec.pb({x,y}); y-=C;\n\t}\n\tint mod=-1;\n\tfor(int i=0;i<3;i++)\n\t{\n\t\tif(getcount(-ll(2e18),ll(2e18),i)){mod=i; break;}\n\t}\n\tassert(mod!=-1);\n\tll lo=-ll(2e18); ll hi=ll(2e18);\n\twhile(lo<hi)\n\t{\n\t\tll mid=(lo+hi)>>1;\n\t\tif(getcount(lo,mid,mod))\n\t\t{\n\t\t\thi=mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlo=mid+1;\n\t\t}\n\t}\n\tll cur = lo;\n\tfor(int i=62;i>=0;i--)\n\t{\n\t\tif(color(cur-(1LL<<i),C)) cur-=(1LL<<i);\n\t}\n\tll x = cur;\n\tfor(int i=62;i>=0;i--)\n\t{\n\t\tif(color(cur+(1LL<<i),C)) cur+=(1LL<<i);\n\t}\n\tll y = (cur-x)+C;\n\tcout<<x<<' '<<y<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<utility>\nusing std::max;\nusing std::min;\nusing std::pair;\nusing std::make_pair;\ntypedef long long ll;\nconst int N=1e4+5;\nint n;\nll x[N],y[N];\nint res[3];\nint dp[64][2][3];\ninline void calc(ll c,ll x,ll y,ll r)\n{\n\tll n=x-c;\n\tregister int i,j,k;\n\tr-=y;\n\tif(r<0)\n\t\treturn res[0]=res[1]=res[2]=0,void();\n\tmemset(dp,0,sizeof(dp));\n\tdp[63][1][0]=1;\n\tfor(i=63;i>0;i--)\n\t\tif(!(n>>(i-1)&1))\n\t\t{\n\t\t\tfor(j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tif(dp[i][0][j])\n\t\t\t\t\tdp[i-1][0][(j*2)%3]^=1;\n\t\t\t\tif(dp[i][1][j])\n\t\t\t\t{\n\t\t\t\t\tif(r>>(i-1)&1)\n\t\t\t\t\t\tdp[i-1][0][(j*2)%3]^=1;\n\t\t\t\t\telse\n\t\t\t\t\t\tdp[i-1][1][(j*2)%3]^=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tif(dp[i][0][j])\n\t\t\t\t{\n\t\t\t\t\tdp[i-1][0][(j*2)%3]^=1;\n\t\t\t\t\tdp[i-1][0][(j*2+1)%3]^=1;\n\t\t\t\t}\n\t\t\t\tif(dp[i][1][j])\n\t\t\t\t{\n\t\t\t\t\tif(r>>(i-1)&1)\n\t\t\t\t\t\tdp[i-1][0][(j*2)%3]^=1,dp[i-1][1][(j*2+1)%3]^=1;\n\t\t\t\t\telse\n\t\t\t\t\t\tdp[i-1][1][(j*2)%3]^=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\ty=(y%3+3)%3;\n\tres[y]=dp[0][0][0]^dp[0][1][0];\n\tres[(y+1)%3]=dp[0][0][1]^dp[0][1][1];\n\tres[(y+2)%3]=dp[0][0][2]^dp[0][1][2];\n\treturn;\n}\nint lres[3],rres[3],mres[3];\ninline ll epc(ll c)\n{\n\tint k;\n\tll l=-1000000000000000000ll,r=1000000000000000000ll,mid;\n\tregister int i;\n\trres[0]=rres[1]=rres[2]=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tcalc(c,x[i],y[i],r);\n\t\trres[0]^=res[0];rres[1]^=res[1];rres[2]^=res[2];\n\t}\n\tlres[0]=lres[1]=lres[2]=0;\n\tfor(i=0;i<3;i++)\n\t\tif(rres[i])\n\t\t{\n\t\t\tk=i;\n\t\t\tbreak;\n\t\t}\n\twhile(l<r)\n\t{\n\t\tmid=(l+r)>>1;\n\t\tmres[0]=mres[1]=mres[2]=0;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tcalc(c,x[i],y[i],mid);\n\t\t\tmres[0]^=res[0];mres[1]^=res[1];mres[2]^=res[2];\n\t\t}\n\t\tif(mres[k]^lres[k])\n\t\t\tr=mid,memcpy(rres,mres,sizeof(int)*3);\n\t\telse\n\t\t\tl=mid+1,memcpy(lres,mres,sizeof(int)*3);\n\t}\n\treturn l;\n}\ninline bool light(ll x,ll y)\n{\n\tint res=0;\n\tll xx,yy,n,m;\n\tregister int i;\n\tfor(i=1;i<=::n;i++)\n\t{\n\t\txx=::x[i];yy=::y[i];\n\t\tn=xx-x;m=y-yy;\n\t\tif(m<0||m>n)\n\t\t\tcontinue;\n\t\tres^=((n|m)==n);\n\t}\n\treturn res;\n}\ninline void solve(ll c,pair<ll,ll> &a)\n{\n\tll k=epc(c),lk=k,rk=k;\n//\tfprintf(stderr,\"%lld\\n\",k);\n\tregister ll i;\n\tfor(i=1ll<<62;i;i>>=1)\n\t\tif(light(c,lk-i))\n\t\t\tlk-=i;\n\tfor(i=1ll<<62;i;i>>=1)\n\t\tif(light(c,rk+i))\n\t\t\trk+=i;\n\ta.first=c+(rk-lk);a.second=lk;\n\treturn;\n}\nsigned main()\n{\n\tpair<ll,ll> a;\n\tregister int i;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%lld%lld\",&x[i],&y[i]);\n\tsolve(-100000000000000000,a);\n\tprintf(\"%lld %lld\\n\",a.first,a.second);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#if MYDEBUG\n#include \"lib/cp_debug.hpp\"\n#else\n#define DBG(...) ;\n#endif\n#if __cplusplus <= 201402L\ntemplate <typename T>\nT gcd(T a, T b) { return ((a % b == 0) ? b : gcd(b, a % b)); }\ntemplate <typename T>\nT lcm(T a, T b) { return a / gcd(a, b) * b; }\n#endif\nusing LL = long long;\nconstexpr LL LINF = 334ll << 53;\nconstexpr int INF = 15 << 26;\nconstexpr LL MOD = 1E9 + 7;\n\nnamespace Problem {\nusing namespace std;\n\nclass Solver {\n public:\n  int n;\n  vector<LL> x, y;\n  LL N = (1ll << 58);\n  vector<vector<vector<int>>> dp_;\n  Solver(LL n) : n(n), x(n), y(n), dp_(61, vector<vector<int>>(3, vector<int>(2))){};\n  bool isOdd(LL a, LL b) {\n    if (a < b) return false;\n    if (b < 0) return false;\n    return (a - b) == (a ^ b);\n  }\n  int isBlack(LL X) {\n    int ret = 0;\n    for (int i = 0; i < n; ++i) {\n      ret += isOdd(y[i] + N, X - x[i]);\n    }\n    return ret % 2;\n  }\n\n  vector<int> countBlackMod2(LL h, LL w) {\n    if (w < 0) return {0, 0, 0};\n    w = min(w, h);\n    auto dp = [&](int a, int b, int c) -> int& { return dp_[a + 1][b][c]; };\n    for (int i = 0; i < 61; ++i) {\n      for (int j = 0; j < 3; ++j) {\n        for (int k = 0; k < 2; ++k) {\n          dp_[i][j][k] = 0;\n        }\n      }\n    }\n\n    //(0,0)の黒い点を直線y=-h上に移したとき、{(x,-h) | x∈[0,w], x=c (mod 3) } となる黒い点の個数\n    //dp[i][j][k] : 上からi桁がmod 3でjに等しい数の個数　k=1ならばw以下であることが確定\n    dp(-1, 0, 0) = 1;\n    for (int i = 0; i < 60; ++i) {\n      if ((w >> (59 - i)) & 1) {\n        for (int j = 0; j < 3; ++j) {\n          if ((h >> (59 - i)) & 1) dp(i, (j + 1 + (59 - i) % 2) % 3, 0) += dp(i - 1, j, 0);\n          dp(i, j, 1) += dp(i - 1, j, 0);\n          if ((h >> (59 - i)) & 1) dp(i, (j + 1 + (59 - i) % 2) % 3, 1) += dp(i - 1, j, 1);\n          dp(i, j, 1) += dp(i - 1, j, 1);\n        }\n\n      } else {\n        for (int j = 0; j < 3; ++j) {\n          //dp(i, (j + 1 + (59 - i) % 2) % 3, 0) += dp(i - 1, j, 0);\n          dp(i, j, 0) += dp(i - 1, j, 0);\n          if ((h >> (59 - i)) & 1) dp(i, (j + 1 + (59 - i) % 2) % 3, 1) += dp(i - 1, j, 1);\n          dp(i, j, 1) += dp(i - 1, j, 1);\n        }\n      }\n      for (int j = 0; j < 3; ++j) {\n        for (int k = 0; k < 2; ++k) {\n          dp(i, j, k) &= 1;\n        }\n      }\n    }\n    vector<int> ret(3);\n    for (int i = 0; i < 3; ++i) {\n      ret[i] = dp(59, i, 0) + dp(59, i, 1);\n    }\n    return ret;\n  }\n\n  int countBrackInRange(LL a, LL b, int c) {\n    //{(x,-h) | x∈[a,b-1], x=c (mod 3) } となる黒い点の個数(mod 2)\n    int ret = 0;\n    for (int i = 0; i < n; ++i) {\n      ret += countBlackMod2(y[i] + N, b - 1 - x[i])[((c - x[i]) % 3 + 3) % 3];\n    }\n    for (int i = 0; i < n; ++i) {\n      ret -= countBlackMod2(y[i] + N, a - 1 - x[i])[((c - x[i]) % 3 + 3) % 3];\n    }\n    ret = ret & 1;\n    return ret;\n  }\n\n  void solve() {\n    for (int i = 0; i < n; ++i) {\n      cin >> x[i] >> y[i];\n    }\n    vector<int> sum(3);\n    for (int j = 0; j < n; ++j) {\n      auto res = countBlackMod2(y[j] + N, y[j] + N);\n      for (int i = 0; i < 3; ++i) {\n        sum[((x[j] + i) % 3 + 3) % 3] += res[i];\n      }\n    }\n\n    //個数が奇数になるグループを探す\n    int r;\n    for (int i = 0; i < 3; ++i) {\n      if (sum[i] % 2) {\n        r = i;\n        break;\n      }\n    }\n\n    //二分探索\n    //[lb,ub)に黒い点が奇数個あるようにする\n    LL lb = -(1ll << 57), ub = (1ll << 59);\n    while (ub - lb > 1) {\n      LL mid = (lb + ub) / 2;\n      if (countBrackInRange(lb, mid, r) % 2) {\n        ub = mid;\n      } else {\n        lb = mid;\n      }\n    }\n\n    //黒い点を1つ見つけた\n    //y=-N上でx座標を動かして、y=-N上で左端・右端の黒い点を探す\n    LL ansl = lb, ansr = lb;\n    //両端以外の黒い点について、X座標を(1<<i)(0<=i<=59)ずらした点のうち1つは黒\n    while (true) {\n      bool fin = true;\n      for (int i = 60 - 1; i >= 0; --i) {\n        //(1<<i)ずらした点の係数は黒か？\n        if (isBlack(ansl - (1ll << i))) {\n          fin = false;\n          ansl -= (1ll << i);\n          break;\n        }\n      }\n      if (fin) break;\n    }\n    while (true) {\n      bool fin = true;\n      for (int i = 60 - 1; i >= 0; --i) {\n        if (isBlack(ansr + (1ll << i))) {\n          fin = false;\n          ansr += (1ll << i);\n          break;\n        }\n      }\n      if (fin) break;\n    }\n\n    cout << ansl << ' ' << -N + (ansr - ansl) << endl;\n  }\n};\n}  // namespace Problem\n\nint main() {\n  std::cin.tie(0);\n  std::ios_base::sync_with_stdio(false);\n  long long n = 0;\n  std::cin >> n;\n\n  Problem::Solver sol(n);\n  sol.solve();\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<algorithm>\n#include<utility>\nusing std::max;\nusing std::min;\nusing std::pair;\nusing std::make_pair;\ntypedef long long ll;\nconst int N=1e4+5;\nint n;\nll x[N],y[N];\nint res[3];\nint dp[64][2][3];\ninline void calc(ll c,ll x,ll y,ll r)\n{\n\tll n=x-c;\n\tregister int i,j,k;\n\tr-=y;\n\tif(r<0)\n\t\treturn res[0]=res[1]=res[2]=0,void();\n\tmemset(dp,0,sizeof(dp));\n\tdp[63][1][0]=1;\n\tfor(i=63;i>0;i--)\n\t\tif(!(n>>(i-1)&1))\n\t\t{\n\t\t\tfor(j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tif(dp[i][0][j])\n\t\t\t\t\tdp[i-1][0][(j*2)%3]^=1;\n\t\t\t\tif(dp[i][1][j])\n\t\t\t\t{\n\t\t\t\t\tif(r>>(i-1)&1)\n\t\t\t\t\t\tdp[i-1][0][(j*2)%3]^=1;\n\t\t\t\t\telse\n\t\t\t\t\t\tdp[i-1][1][(j*2)%3]^=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tfor(j=0;j<3;j++)\n\t\t\t{\n\t\t\t\tif(dp[i][0][j])\n\t\t\t\t{\n\t\t\t\t\tdp[i-1][0][(j*2)%3]^=1;\n\t\t\t\t\tdp[i-1][0][(j*2+1)%3]^=1;\n\t\t\t\t}\n\t\t\t\tif(dp[i][1][j])\n\t\t\t\t{\n\t\t\t\t\tif(r>>(i-1)&1)\n\t\t\t\t\t\tdp[i-1][0][(j*2)%3]^=1,dp[i-1][1][(j*2+1)%3]^=1;\n\t\t\t\t\telse\n\t\t\t\t\t\tdp[i-1][1][(j*2)%3]^=1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\ty=(y%3+3)%3;\n\tres[y]=dp[0][0][0]^dp[0][1][0];\n\tres[(y+1)%3]=dp[0][0][1]^dp[0][1][1];\n\tres[(y+2)%3]=dp[0][0][2]^dp[0][1][2];\n\treturn;\n}\nint lres[3],rres[3],mres[3];\ninline ll epc(ll c)\n{\n\tint k;\n\tll l=-1000000000000000000ll,r=1000000000000000000ll,mid;\n\tregister int i;\n\trres[0]=rres[1]=rres[2]=0;\n\tfor(i=1;i<=n;i++)\n\t{\n\t\tcalc(c,x[i],y[i],r);\n\t\trres[0]^=res[0];rres[1]^=res[1];rres[2]^=res[2];\n\t}\n\tlres[0]=lres[1]=lres[2]=0;\n\tfor(i=0;i<3;i++)\n\t\tif(rres[i])\n\t\t{\n\t\t\tk=i;\n\t\t\tbreak;\n\t\t}\n\twhile(l<r)\n\t{\n\t\tmid=(l+r)>>1;\n\t\tmres[0]=mres[1]=mres[2]=0;\n\t\tfor(i=1;i<=n;i++)\n\t\t{\n\t\t\tcalc(c,x[i],y[i],mid);\n\t\t\tmres[0]^=res[0];mres[1]^=res[1];mres[2]^=res[2];\n\t\t}\n\t\tif(mres[k]^lres[k])\n\t\t\tr=mid,memcpy(rres,mres,sizeof(int)*3);\n\t\telse\n\t\t\tl=mid+1,memcpy(lres,mres,sizeof(int)*3);\n\t}\n\treturn l;\n}\ninline bool light(ll x,ll y)\n{\n\tint res=0;\n\tll xx,yy,n,m;\n\tregister int i;\n\tfor(i=1;i<=::n;i++)\n\t{\n\t\txx=::x[i];yy=::y[i];\n\t\tn=xx-x;m=y-yy;\n\t\tif(m<0||m>n)\n\t\t\tcontinue;\n\t\tres^=((n|m)==n);\n\t}\n\treturn res;\n}\ninline void solve(ll c,pair<ll,ll> &a,pair<ll,ll> &b)\n{\n\tll k=epc(c),lk=k,rk=k;\n//\tfprintf(stderr,\"%lld\\n\",k);\n\tregister ll i;\n\tfor(i=1ll<<62;i;i>>=1)\n\t\tif(light(c,lk-i))\n\t\t\tlk-=i;\n\tfor(i=1ll<<62;i;i>>=1)\n\t\tif(light(c,rk+i))\n\t\t\trk+=i;\n\ta.first=c+(rk-lk);a.second=lk;\n\tb.first=c-(rk-lk);b.second=rk;\n\treturn;\n}\nsigned main()\n{\n\tpair<ll,ll> a1,a2,b1,b2;\n\tregister int i;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)\n\t\tscanf(\"%lld%lld\",&x[i],&y[i]);\n\tsolve(-100000000000000000,a1,a2);\n\tsolve(-100000000000000001,b1,b2);\n\tif(a1==b1||a1==b2)\n\t\tprintf(\"%lld %lld\\n\",a1.first,a1.second);\n\telse\n\t\tprintf(\"%lld %lld\\n\",a2.first,a2.second);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll L = -2e17;\nint n;\nvector<pair<ll,ll> > v;\nbool check_point(pair<ll,ll> p, ll x, ll y)\n{\n\tll X = x-p.FF;\n\tll Y = p.SS-y;\n\tassert(Y>=0);\n\tif (X<0||X>Y) return false;\n\treturn (Y&X)==X;\n}\nbool check_point(ll x)\n{\n\tbool ret = 0;\n\tfor (auto p : v)\n\t{\n\t\tif (check_point(p, x, L))\n\t\t{\n\t\t\tret ^= 1;\n\t\t}\n\t}\n\treturn ret;\n}\nbool cnt[3];\nvoid calc(pair<ll,ll> p, ll x, ll y)\n{\n\tll X = x-p.FF;\n\tll Y = p.SS-y;\n\tassert(Y>=0);\n\tif (X<0) return;\n\tif (X>Y) X = Y;\n//\tcerr<<X<<\",\"<<Y<<endl;\n\tassert(Y>=0);\n\tstatic bool dp[66][2][3];\n\tmemset(dp, 0, sizeof(dp));\n\tdp[61][1][0] = 1;\n\tfor (int i=60; i>=0; i--)\n\t{\n\t\tfor (int t=0; t<2; t++)\n\t\t{\n\t\t\tfor (int v=0; v<2; v++)\n\t\t\t{\n\t\t\t\tif (v&&!((Y>>i)&1)) continue;\n\t\t\t\tif (v&&t&&!((X>>i)&1)) continue;\n\t\t\t\tint dlt = ((1ll*v)<<i)%3;\n\t\t\t\tint nt = t&(v==((X>>i)&1));\n\t\t\t\tfor (int j=0; j<3; j++) dp[i][nt][(j+dlt)%3] ^= dp[i+1][t][j];\n\t\t\t}\n\t\t}\n\t}\n\tint t = ((p.FF%3)+3)%3;\n//\tfor (int i=0; i<3; i++) cerr<<dp[0][0][i]; cerr<<\" \";\n//\tfor (int i=0; i<3; i++) cerr<<dp[0][1][i]; cerr<<endl;\n\t\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tcnt[(i+t)%3] ^= dp[0][0][i];\n\t\tcnt[(i+t)%3] ^= dp[0][1][i];\n\t}\n}\nbool check(ll x)\n{\n//\tcerr<<\"check:\"<<x<<endl;\n\tcnt[0] = cnt[1] = cnt[2] = 0;\n\tfor (auto p : v)\n\t{\n\t\tcalc(p, x, L);\n\t}\n//\tcerr<<cnt[0]<<\" \"<<cnt[1]<<\" \"<<cnt[2]<<endl;\n\treturn cnt[0]||cnt[1]||cnt[2];\n}\nint main()\n{\n\tgeti(n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll x, y;\n\t\tgetii(x, y);\n\t\tv.PB(MP(x, y));\n\t}\n/*\tfor (int i=L; i<=-L; i++)\n\t{\n\t\tcerr<<check_point(i);\n\t\tif ((i-L)%5==0) cerr<<\" \";\n\t} cerr<<endl;\n*/\n\tll l = -1e18, r = 1e18;\n\twhile (l<=r)\n\t{\n\t\tll m = l+r>>1;\n\t\tif (check(m)) r = m-1; else l = m+1;\n\t}\n//\tcerr<<l<<\",\"<<r<<\" \"<<check(l)<<check(r)<<endl;\n\tr = l;\n\tassert(check_point(l));\n//\tcerr<<\"l=\"<<l<<\" r=\"<<r<<endl;\n\tfor (int i=60; i>=0; i--) if (check_point(l-(1ll<<i))) l -= 1ll<<i;\n\tfor (int i=60; i>=0; i--) if (check_point(r+(1ll<<i))) r += 1ll<<i;\n//\tcerr<<l<<\",\"<<r<<endl;\n\n\tcout<<l<<\" \"<<L+(r-l)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"sse2,pclmul,tune=native\")\n#pragma GCC optimize(\"O3\")\n#include <ext/pb_ds/assoc_container.hpp>\n#include <nmmintrin.h>\n#include <emmintrin.h>\n#include <wmmintrin.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nusing GF = uint32_t;\n\ninline GF Add(GF a, GF b) {\n  return a ^ b;\n}\n\ninline GF Mul(GF a, GF b) {\n  __m128i xa = _mm_cvtsi64_si128(a), xb = _mm_cvtsi64_si128(b);\n  xa = _mm_clmulepi64_si128(xa, xb, 0x00);\n  uint64_t res = _mm_cvtsi128_si64(xa);\n  GF hi = res >> 32;\n  GF a0 = hi ^ (hi >> 25) ^ (hi >> 29) ^ (hi >> 30);\n  return (GF)res ^ a0 ^ (a0 << 2) ^ (a0 << 3) ^ (a0 << 7);\n}\n\nvector<GF> base;\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val);\nGF AddPositionsFrom(LL x, LL y, LL min_val);\n\nconst int MemoSize = 1 << 25;\n\npair<LL, LL> other_hash[MemoSize];\nGF memo[MemoSize];\n\nuint64_t Hash1(const pair<LL, LL> &p) {\nusing U = uint64_t;\n  uint64_t y = ((U)p.st * 0x123456789ABCDEFLL) ^ ((U)p.nd * 0xFEDCBA987654321LL);\n  return y ^ ((((U)p.st >> 32) * 0x019428711LL) + (((U)p.nd >> 24) * 0x593285392LL));\n}\n\n/*uint64_t Hash2(const pair<LL, LL> &p) {\n  return p.st + p.nd + (p.st ^ p.nd) + 17;\n}*/\n\nbool FindVal(const pair<LL, LL> &p, GF &ans) {\n  constexpr uint64_t kMask = MemoSize - 1;\n  auto h1 = Hash1(p) & kMask; //, h2 = Hash2(p);\n  for (int i = 0; other_hash[h1] != pair<LL, LL>{0, 0} && other_hash[h1] != p; ++i) {\n    h1 = (h1 + i) & kMask;\n  }\n  if (other_hash[h1] == p) {\n    ans = memo[h1];\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid PutVal(const pair<LL, LL> &p, const GF val) {\n  constexpr uint64_t kMask = MemoSize - 1;\n  auto h1 = Hash1(p) & kMask; //, h2 = Hash2(p);\n  for (int i = 0; other_hash[h1] != pair<LL, LL>{0, 0}; ++i) {\n    h1 = (h1 + i) & kMask;\n  }\n  other_hash[h1] = p; //h2;\n  memo[h1] = val;\n}\n\n//map<pair<LL, LL>, GF> memo;\nGF AddPositions(LL x, LL y, int bb = 60) {\n  if (x == 0 && y == 0) { return 1; }\n  debug(\"?Any\", x, y);\n  \n  pair<LL, LL> p{x, y};\n  {\n    GF ans;\n    if (FindVal(p, ans)) { return ans; }\n  }\n\n  int bit = 63 - __builtin_clzll(x + y);\n  while ((1LL << bit) > x + y) { --bit; }\n  if (x >= (1LL << bit)) {\n    GF ans = Mul(base[bit], AddPositions(x ^ (1LL << bit), y));\n    debug(x, y, ans);\n    PutVal(p, ans);\n    return ans;\n  }\n\n  // x < 2^bit <= x + y\n  GF answer1 = AddPositionsUpTo(x, y, (1LL << bit) - 1);\n  GF answer2 = AddPositionsFrom(x, y, (1LL << bit));\n  debug(x, y, answer1, answer2);\n  answer1 = Add(answer1, answer2);\n  PutVal(p, answer1);\n  return answer1;\n}\n\nGF GetValue(LL x) {\n  if (!x) { return 1; }\n  static map<LL, GF> val_memo;\n  auto it = val_memo.find(x);\n  if (it != val_memo.end()) { return it->nd; }\n\n  GF ans = 1;\n  for (int bit = 63 - __builtin_clzll(x); bit >= 0; --bit) {\n    if ((x >> bit) & 1) {\n      ans = Mul(base[bit], ans);\n    }\n  }\n  debug(\"Value\", x, ans);\n  return val_memo[x] = ans;\n}\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val) {\n  debug(\"?UpTo\", x, y, max_val);\n  if (x > max_val) { return 0; }\n  if (x + y <= max_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int a = ((63 - __builtin_clzll(y)) >> 3) << 3; a >= 0; a -= 8) {\n    if (!((y >> a) & 0xff)) { continue; }\n    for (int bit = a + 7; bit >= a; --bit) {\n      if (!((y >> bit) & 1)) { continue; }\n      const LL v = 1LL << bit;\n      y ^= v;\n\n      if (x + v - 1 <= max_val) {\n        debug(\"UpTo\", orig_x, orig_y, max_val, x, y);\n        answer = Add(answer, AddPositions(x, y));\n        x += v;\n      }\n    }\n  }\n  /*for (int bit = 60; bit >= 0; --bit) {\n  }*/\n  debug(answer);\n  if (x <= max_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF AddPositionsFrom(LL x, LL y, LL min_val) {\n  if (x + y < min_val) { return 0; }\n  if (x >= min_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int bit = 63 - __builtin_clzll(y); bit >= 0; --bit) {\n    if (!((y >> bit) & 1)) { continue; }\n    const LL v = 1LL << bit;\n    y ^= v;\n\n    if (x + v >= min_val) {\n      answer = Add(answer, AddPositions(x + v, y));\n    } else {\n      x += v;\n    }\n  }\n  debug(\"From\", orig_x, orig_y, min_val, answer, x);\n  if (x >= min_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF GetRandom() {\n  GF ans = 0;\n  for (int i = 0; i < 4; ++i) {\n    ans <<= 16;\n    ans |= (rand() % (1 << 16));\n  }\n  return ans;\n}\n\nint32_t main() {\n#ifndef LOCAL\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n#endif\n\n#ifdef TESTING\n  while (true) {\n    GF a = GetRandom(), b = GetRandom(), c = GetRandom();\n    GF d = Mul(a, Add(b, c));\n    GF e = Add(Mul(a, b), Mul(a, c));\n    debug(a,b,c,d,e);\n    assert(d == e);\n  }\n#endif\n\n  srand(2137);\n\n#warning\n  const int S = 57;\n//  const int S = 58;\n  const LL kLarge = 1LL << S;\n  for (int i = 0; i < 70; ++i) {\n    GF x = GetRandom();\n    base.PB(x);\n  }\n  debug(base);\n\n  int N;\n  cin >> N;\n  //mini(N, 7500LL);\n  vector<pair<LL, LL>> values;\n\n  auto TotalGF = [&](LL bound) {\n    GF ans = 0;\n    for (auto &val : values) {\n      ans = Add(ans, AddPositionsUpTo(val.st, val.nd, bound));\n    }\n    debug(bound, ans);\n    return ans;\n  };\n\n  for (int i = 0; i < N; ++i) {\n    LL x, y;\n    cin >> x >> y;\n    values.emplace_back(x + kLarge, y + kLarge);\n  }\n\n  debug(values);\n\n  LL Lzero = 0, Rzero = (1LL << (S + 1));\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == 0) {\n      Lzero = midzero;\n    } else {\n      Rzero = midzero;\n    }\n  }\n\n  LL first_x = Rzero; // - kLarge;\n  LL last_x = first_x;\n  for (int bit = 60; bit >= 0; --bit) {\n    const LL next_x = last_x + (1LL << bit);\n    int num_hitting = 0;\n    for (int i = 0; i < N; ++i) {\n      const LL t = next_x - values[i].st;\n      if (t >= 0 && (t & values[i].nd) == t) { ++num_hitting; }\n    }\n\n    if (num_hitting % 2 == 1) { last_x = next_x; }\n  }\n\n  debug(values, first_x, last_x);\n  first_x -= kLarge; last_x -= kLarge;\n  \n  /*Lzero = 0; Rzero = (1LL << (S + 2));\n  const GF aim = TotalGF(Rzero);\n\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == aim) {\n      Rzero = midzero;\n    } else {\n      Lzero = midzero;\n    }\n  }\n\n  const LL last_x = Rzero - kLarge;*/\n\n  cout << first_x << \" \" << last_x - first_x - kLarge << \"\\n\";\n  //cout << memo.size() << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin &x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\trep(i, 2) {\n      int c;\n\t\tfor (pin &x : qab[1-i]) {\n\t\t\tint qc = (2 * x.first + x.second)%3;\n          c^=(qc+1);\n\t\t}\n\t\tif (!c) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll base = 1ll << 58;\nconst int LOG = 60;\nint main() {\n  do {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n  } while (false);\n  int n;\n  cin >> n;\n  vector<ll> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n    x[i] += base;\n    y[i] += base;\n  }\n  auto calc = [&] (ll sum, int r) {\n    bool res = false;\n    for (int i = 0; i < n; i++) {\n      if (y[i] < sum) {\n        ll limit = sum - y[i];\n        vector<bool> F(3), G(3);\n        F[0] = true;\n        for (int j = LOG; j >= 0; j--) {\n          vector<bool> F2(3), G2(3);\n          for (int k = 0; k < 3; k++) {\n            for (int v = 0; v <= ((limit >> j & 1) ? (x[i] >> j & 1) : 0); v++) {\n              int nxt = (k + v * (j & 1) + v) % 3;\n              if (v != (limit >> j & 1)) {\n                G2[nxt].flip();\n              } else {\n                F2[nxt].flip();\n              }\n            }\n            for (int v = 0; v <= (x[i] >> j & 1); v++) {\n              int nxt = (k + v * (j & 1) + v) % 3;\n              G2[nxt].flip();\n            }\n          }\n          F = F2;\n          G = G2;\n        }\n        res ^= G[(r - y[i] % 3 + 3) % 3];\n      }\n    }\n    return res;\n  };\n  int r = 0;\n  while (!calc(1ll << LOG, r)) {\n    r++;\n  }\n  ll start = 0;\n  for (int i = LOG; i >= 0; i--) {\n    if (calc(start, r) == calc(start + (1ll << i), r)) {\n      start |= 1ll << i;\n    }\n  }\n  auto check = [&] (ll pos) {\n    bool res = false;\n    for (int i = 0; i < n; i++) {\n      if (y[i] <= pos && pos <= x[i] + y[i] && (x[i] & (pos - y[i])) == pos - y[i]) {\n        res ^= 1;\n      }\n    }\n    return res;\n  };\n  ll L = start, R = start;\n  for (int i = LOG; i >= 0; i--) {\n    if (check(L - (1ll << i))) {\n      L -= 1ll << i;\n    }\n    if (check(R + (1ll << i))) {\n      R += 1ll << i;\n    }\n  }\n  cout << R - L - base << \" \" << L - base << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}for(L i;i<2;i++){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n,a,b;cin>>n;V<W>p(n);while(n--){cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"-Ofast\")\n#include <cstdio>\n#include <cstring>\n#include <iostream>\nusing namespace std;\n#define LL long long\n#define inline __inline__ __attribute__((always_inline))\ninline LL read() {\n  long long x = 0, w = 1;\n  char ch = getchar();\n  while (!isdigit(ch)) w = ch == '-' ? -1 : 1, ch = getchar();\n  while (isdigit(ch)) {\n    x = (x << 3) + (x << 1) + ch - '0';\n    ch = getchar();\n  }\n  return x * w;\n}\nconst int Max_n = 1e4 + 5;\nconst LL lim = 1e17, inf = 2e17;\nint n, Res;\nint f[65][2][3];\nLL m, N, a[Max_n], b[Max_n];\nbool res[3];\ninline bool check(LL x, LL y) {\n  bool ans = 0;\n  for (int i = 1; i <= n; i++) {\n    LL M = b[i] - y, N = x - a[i];\n    if (M < 0 || M < 0) continue;\n    ans ^= ((N & M) == N);\n  }\n  return ans;\n}\ninline void DP(int Res) {\n  memset(f, 0, sizeof(f));\n  f[64][1][0] = 1;\n  for (int i = 64; i; i--)\n    for (int l = 0; l < 2; l++)\n      for (int j = 0; j < 3; j++)\n        for (int k = 0; k <= (m >> i - 1 & 1); k++) {\n          if (l && k > (N >> i - 1 & 1)) continue;\n          f[i - 1][l && (k == (N >> i - 1 & 1))][(j << 1 | k) % 3] ^= f[i][l][j];\n        }\n  for (int i = 0; i < 3; i++) {\n    int now = (i - Res + 3) % 3;\n    res[i] ^= f[0][0][now] ^ f[0][1][now];\n  }\n}\ninline void work(LL L, LL R, LL a, LL b) {\n  m = b + lim, N = R - a;\n  if (N < 0) return;\n  DP(((a % 3) + 3) % 3);\n  if (L > a) {\n    N = L - 1 - a;\n    DP(((a % 3) + 3) % 3);\n  }\n}\nint main() {\n  n = read();\n  for (int i = 1; i <= n; i++) a[i] = read(), b[i] = read();\n  LL l = -inf, r = inf;\n  while (l != r) {\n    LL mid = (l + r) >> 1;\n    res[0] = res[1] = res[2] = 0;\n    for (int i = 1; i <= n; i++) work(l, mid, a[i], b[i]);\n    if (res[0] || res[1] || res[2])\n      r = mid;\n    else\n      l = mid + 1;\n  }\n  LL L = l, R = l;\n  for (int k = 63; ~k; k--)\n    if (check(L - (1ll << k), -lim)) L -= (1ll << k);\n  for (int k = 63; ~k; k--)\n    if (check(R + (1ll << k), -lim)) R += (1ll << k);\n  cout << L << \" \" << -lim + R - L;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n  \tc=0;\n  \tfor (pin& x : qab[1]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n  \tif (!c) {\n\t\tans.first *= 2; ans.second *= 2;\n\t\treturn ans;\n\t}\n\tc = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second-1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t}\n\tans.first *= 2; ans.first++; ans.second *= 2; ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\n#define R(n)for(L i;i<n;i++)\n#define D return\nL E=70;W S(V<W>p){if(!E){D{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;D A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;D A;}int main(){L M=2e17,n,a,b;cin>>n;V<W>p(n);R(n){cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\trep(i, 1) {\n\t\tint c = 0;\n\t\tfor (pin& x : qab[1 - i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tc ^= (qc + 1);\n\t\t}\n\t\tif (!c) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tint c = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second-1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t\tw += 2;\n\t\tif ((w & x.first) == w) { d ^= 1; }\n\t}\n\tans.first *= 2; ans.first+=(c|d); ans.second *= 2; ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 58);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz/2);\n\tqab[1].reserve(sz/2);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first>>1, x.second>>1));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first>>1, (x.second + 1)>>1)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = 2 * x.first + x.second;qc%=3;\n\t\tc ^= (qc+1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t\tw++;\n\t\tif ((w & x.first) == w) { d ^= 1; }\n\t}\n\tans.first *= 2; ans.second *= 2;\n\tans.first += (c | d); ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define V vector\n#define vel V<long long>\n#define rep(i,n) for(int i=0;i<n;i++)\nvel solve(V<vel>& ab, int ex) {\n\tif (ex == 0) { return { 1, 0 }; }\n\tV<V<vel>> qab(2);\n\tfor (vel x : ab) {\n\t\tqab[x[1] & 1].push_back({ x[0] / 2,x[1] / 2 });\n\t\tif (x[0] & 1) { qab[(x[1] + 1) & 1].push_back({ x[0] / 2,(x[1] + 1) / 2 }); }\n\t}\n\tV<vel> c(3,vel(2));\n\trep(i, 2) {\n\t\tfor (vel x : qab[i]) {\n\t\t\tint qc = (3 - x[0] + x[1]) % 3; qc = (qc + 3) % 3;\n\t\t\tif ((qc+1)%2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (c[i] == c[2]) {\n\t\t\tvel ans = solve(qab[1], ex - 1);\n\t\t\tans[0] *= 2; ans[1] *= 2; ans[1] += 1 - i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\trep(i, ab.size()) { ab[i][0]++; }\n\tvel ans = solve(ab, ex); ans[0]--;\n\treturn ans;\n}\nint main() {\n\tlong long inf = 2e17;\n\tint n; cin >> n;\n\tV<vel> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tvel ret = solve(ab, 70);\n\tcout << ret[0] - inf << \" \" << ret[1] - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n      \tint qc=2*x.first+x.second;\n\tqc = (qc & (0xffffffff)) + ((qc & (0xfffffff00000000)) >> 32);\n\tqc = (qc & (0xffffffff)) + ((qc & (0x100000000)) >> 32);\n\tqc = (qc & (0xffff)) + ((qc & (0xffff0000)) >> 16);\n\tqc = (qc & (0xffff)) + ((qc & (0x10000)) >> 16);\n\tqc = (qc & (0xff)) + ((qc & (0xff00)) >> 8);\n\tqc = (qc & (0xff)) + ((qc & (0x100)) >> 8);\n\tqc = (qc & (0xf)) + ((qc & (0xf0)) >> 4);\n\tqc = (qc & (0xf)) + ((qc & (0x10)) >> 4);\n\tqc = (qc & 3) + ((qc & 12) >> 2);\n\tqc = (qc & 3) + ((qc & 4) >> 2);\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n      \tint qc=2*x.first+x.second+1;\n        qc=(qc&(0xffffffff))+((qc&(0xffffffff00000000))>>32);\n      \tqc=(qc&(0xffff))+((qc&(0xffff0000))>>16);\n      \tqc=(qc&(0xff))+((qc&(0xff00))>>8);\n      \tqc=(qc&(0xf))+((qc&(0xf0))>>4);\n      \tqc=(qc&3)+((qc&12)>>2);\n      \tqc=(qc&3)+((qc&12)>>2);\n        qc=(qc&3)+((qc&12)>>2);\n        qc=(qc&3)+((qc&12)>>2);\n\t\tc ^= qc;\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\n#define R(n)for(L i;i<n;i++){\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2)L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n,a,b;cin>>n;V<W>p(n);R(n)cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin &x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n  vel c(2);\n\trep(i, 2) {\n\t\tfor (pin &x : qab[1-i]) {\n\t\t\tint qc = (2 * x.first + x.second)%3;\n          c[1-i]^=(qc+1);\n\t\t}\n\t\tif (!c[1 - i]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\nvoid tostr(ll x,string& res){while(x)res+=('0'+(x%10)),x/=10; reverse(ALL(res)); return;}\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//end\n\nconstexpr ll c=300000000000000000LL;\nint N; ll x[11000],y[11000];\nbool que(ll n,ll r){if(n<0||r<0||n<r)return 0; return (n&r)==r;}\nbool col(ll a){\n   bool res=0;\n   rep(i,0,N)if(a>=x[i])res^=que(c-x[i]-y[i],a-x[i]);\n   return res;\n}\nll calc(ll n,ll t,int r){\n   if(t<0)return 0;\n   chmin(t,n); ll dp[64][3][2]={}; dp[60][0][1]=1;\n   rrep(i,59,-1)rep(j,0,3)rep(k,0,2)if(dp[i+1][j][k]){\n      rep(nxt,0,2){\n         if((n>>i&1)==0&&nxt)continue;\n         if(k&&nxt&&(t>>i&1)==0)continue;\n         int nj=(j+(nxt?(i&1?2:1):0))%3,nk=k;\n         if(nxt==0&&(t>>i&1))nk=0;\n         dp[i][nj][nk]+=dp[i+1][j][k];\n      }\n   } return dp[0][r][0]+dp[0][r][1];\n}\nll rng(ll n,ll lb,ll rb,int r){return calc(n,rb,r)-calc(n,lb,r);}\nbool flag(ll lb,ll rb,int r){\n   bool res=0;\n   rep(i,0,N)res^=rng(c-x[i]-y[i],lb-x[i],rb-x[i],((r-x[i])%3+3)%3)&1;\n   return res;\n}\n\n//reference:https://physics0523.hatenablog.com/entry/2019/02/26/190724\nint main(){\n   scanf(\"%d\",&N); rep(i,0,N)scanf(\"%lld%lld\",&x[i],&y[i]);\n   ll lb=-c/2,rb=c/2; int r=-1;\n   rep(i,0,3)if(flag(lb,rb,i)){r=i; break;}\n   assert(r>=0);\n   while(rb-lb>1){\n      ll mid=(lb+rb)>>1;\n      if(flag(lb,mid,r))rb=mid; else lb=mid;\n   } assert(col(rb));\n   ll x1=rb,x2=rb;\n   rrep(k,62,-1){\n      if(col(x1-(1LL<<k)))x1-=1LL<<k;\n      if(col(x2+(1LL<<k)))x2+=1LL<<k;\n   } printf(\"%lld %lld\\n\",x1,c-x2);\n   return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = 2 * x.first + x.second + 1;\n\tqc = (qc & (0xffffffff)) + ((qc & (0x7fffffff00000000)) >> 32);//qc<=1ffffffff\n\tqc = (qc & (0xffff)) + ((qc & (0x1ffff0000)) >> 16);//qc<=2ffff\n\tqc = (qc & (0xff)) + ((qc & (0x3ff00)) >> 8);//qc<=3ff\n\tqc = (qc & (0xf)) + ((qc & (0x3f0)) >> 4);//qc<=4e\n\tqc = (qc & (0xf)) + ((qc & (0x7e)) >> 4);//qc<=18\n\tqc = (qc & 3) + ((qc & 28) >> 2);\n\t\tc ^= qc;\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first=>>1; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t\tw++;\n\t\tif ((w & x.first) == w) { d ^= 1; }\n\t}\n\tans.first *= 2; ans.second *= 2;\n\tans.first += (c | d); ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\trep(i, 1) {\n\t\tint c = 0;\n\t\tfor (pin& x : qab[1 - i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tc ^= (qc + 1);\n\t\t}\n\t\tif (!c) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tint c = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second-1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t\tw++;\n\t\tif ((w & x.first) == w) { d ^= 1; }\n\t}\n\tans.first *= 2; ans.first+=(c|d); ans.second *= 2; ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 58);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long long\n#define W V<L>\n#define R(n) for(L i=0;i<n;i++)\nW S(V<W>&p,L E){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){int c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=(Q+1);}if(!c){W ans=S(T[i],E-1);ans[0]*=2;ans[1]*=2;ans[1]+=i;return ans;}}for(W&v:p){v[0]++;}W A=S(p,E);A[0]--;return A;}\nint main(){L M=2e17;L n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}W Q=S(p,70);cout<<Q[0]-M<<\" \"<<Q[1]-M;}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\treturn solve(qab[0],ex-1);\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n    }\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main()\n{\n    int N; cin>>N;\n    vector<long long> x(N), y(N);\n    for (int i=0; i<N; i++)\n        cin>>x[i]>>y[i];\n\n    //  https://img.atcoder.jp/wtf19-open/editorial.pdf\n    long long c = 1LL<<60;\n    \n    //  y = c の直線上のランプのみが点灯するようにしたときに、\n    //  x%m = r を満たす (x, c) のランプが点灯しているか\n    //  m = 2^k\n    //  mが充分に大きければ、(r, y) のランプが点灯しているかどうかになる\n    auto check = [&](long long m, long long r)\n    {\n        bool ret = false;\n        //  (r, c) のランプが点灯している ⇔ XOR[0<=i<N]((c-y[i]) | ~(r-x[i]) の全てのビットが立っている)\n        //  下位kビット目まで考えれば、残りの必要なビットが立っているxが存在するので、\n        //  上位ビットは単に無視すれば良い\n        for (int i=0; i<N; i++)\n            if (!~( ((c-y[i]) | ~(r-x[i])) | ~(m-1) ))\n                ret = !ret;\n        return ret;\n    };\n\n    //  (p, c) のランプが付いているpを求める\n    //  check(m, x) が真ならば、check(2*m, x) か check(2*m, x+m) のどちらか少なくとも一方は真である\n    //  x>=0 に必ず点灯しているランプがあり、pはなるべく小さくなるように求めているので、\n    //  pが負になることは考慮しなくて良い\n    long long p = 0;\n    for (int k=0; k<60; k++)\n        if (!check(1LL<<(k+1), p))\n            p |= 1LL<<k;\n\n    long long l = p;\n    for (int k=60; k>=0; k--)\n        if (check(1LL<<62, l-(1LL<<k)))\n            l -= 1LL<<k;\n    long long r = p;\n    for (int k=60; k>=0; k--)\n        if (check(1LL<<62, r+(1LL<<k)))\n            r += 1LL<<k;\n    cout<<l<<\" \"<<c-(r-l)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first>>1, x.second>>1));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first>>1, (x.second + 1)>>1)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tc ^= ((2 * x.first + x.second)%3+1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t\tw++;\n\t\tif ((w & x.first) == w) { d ^= 1; }\n\t}\n\tans.first *= 2; ans.second *= 2;\n\tans.first += (c | d); ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\nvel solve(V<vel>& ab, int ex) {\n\tif (ex == 0) { return { 1, 0 }; }\n\tV<vel> ab0, ab1;\n\tfor (vel x : ab) {\n\t\tint a1 = x[0];\n\t\tint b1 = x[1];\n\t\tif (b1 % 2 == 0) {\n\t\t\tab0.push_back({ a1 / 2, b1 / 2 });\n\t\t\tif (a1 % 2 == 1) { ab1.push_back({ a1 / 2, b1 / 2 }); }\n\t\t}\n\t\telse {\n\t\t\tab1.push_back({ a1 / 2, b1 / 2 });\n\t\t\tif (a1 % 2 == 1) { ab0.push_back({ a1 / 2, (b1 + 1) / 2 }); }\n\t\t}\n\t}\n\tvel c0(2), c1(2);\n\tfor (auto x : ab0) {\n\t\tint qc = (3-x[0]+x[1]) % 3;\n\t\tif (qc == 0) { c0[0] ^= 1; }\n\t\tif (qc == 1) { c0[1] ^= 1; }\n\t\tif (qc == 2) { c0[0] ^= 1; c0[1] ^= 1; }\n\t}\n\tfor (auto x : ab1) {\n\t\tint qc = (3 - x[0] + x[1]) % 3;\n\t\tif (qc == 0) { c1[0] ^= 1; }\n\t\tif (qc == 1) { c1[1] ^= 1; }\n\t\tif (qc == 2) { c1[0] ^= 1; c1[1] ^= 1; }\n\t}\n\tvel ze(2, 0);\n\tif (c0 == ze) {\n\t\tvel ans = solve(ab1, ex - 1);\n\t\tans[0] *= 2; ans[1] *= 2;ans[1]++;\n\t\treturn ans;\n\t}\n\tif (c1 == ze) {\n\t\tvel ans = solve(ab0, ex - 1);\n\t\tans[0] *= 2; ans[0] *= 2;\n\t\treturn ans;\n\t}\n\trep(i, ab.size()) { ab[i][0]++; }\n\tvel ans = solve(ab, ex); ans[0]--;\n\treturn ans;\n}\nsigned main() {\n\tint inf = 1;\n\trep(i, 57) { inf *= 2; }\n\tint n; cin >> n;\n\tV<vel> ab(n);\n\trep(i, n) {\n\t\tint a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tvel ret = solve(ab, 70);\n\tcout << ret[0]-inf << \" \" << ret[1]-inf << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\trep(i, 2) {\n\t\tint c = 0;\n\t\tfor (pin& x : qab[1-i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tc ^= (qc + 1);\n\t\t}\n\t\tif (!c) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tint val = ans.second-1;\n\tint c = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = val - x.second;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t}\n\tans.first *= 2; ans.first++; ans.second *= 2; ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 2e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) & 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define V vector\n#define vel V<long long>\n#define rep(i,n) for(int i=0;i<n;i++)\nvel solve(V<vel>& ab, int ex) {\n\tif (!ex) { return { 1, 0 }; }\n\tV<V<vel>> qab(2);\n\tfor (vel x : ab) {\n\t\tqab[x[1] & 1].push_back({ x[0] / 2,x[1] / 2 });\n\t\tif (x[0] & 1) { qab[(x[1] + 1) & 1].push_back({ x[0] / 2,(x[1] + 1) / 2 }); }\n\t}\n\tV<vel> c(3, vel(2));\n\trep(i, 2) {\n\t\tfor (vel x : qab[i]) {\n\t\t\tint qc = (2 * x[0] + x[1]) % 3;\n\t\t\tif ((qc+1)%2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (c[1 - i] == c[2]) {\n\t\t\tvel ans = solve(qab[i], ex - 1);\n\t\t\tans[0] *= 2; ans[1] *= 2; ans[1] += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(vel v:ab) { v[0]++; }\n\tvel ans = solve(ab, ex); ans[0]--;\n\treturn ans;\n}\nint main() {\n\tlong long inf = 2e17;\n\tint n; cin >> n;\n\tV<vel> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tvel ret = solve(ab, 70);\n\tcout << ret[0] - inf << \" \" << ret[1] - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<assert.h>\ntypedef long long ll;\nconst ll inf=1e17;\nll f[3][2],g[3][2];\n//f[i][j][k]:i~60 ok, %3=j, locked?\nll s[3];\nvoid dp(ll n,ll m){//sum[i<=m & i in n & i%3=r]\n\tif(m<0){\n\t\tmemset(s,0,sizeof(s));\n\t\treturn;\n\t}\n\tint i,j;\n\tmemset(f,0,sizeof(f));\n\tf[0][1]=1;\n\tfor(i=60;i>=0;i--){\n\t\tmemset(g,0,sizeof(g));\n\t\tfor(j=0;j<3;j++){\n\t\t\tg[j][0]+=f[j][0];\n\t\t\tif(n>>i&1)g[(j+(1ll<<i))%3][0]+=f[j][0];\n\t\t\tif(m>>i&1){\n\t\t\t\tg[j][0]+=f[j][1];\n\t\t\t\tif(n>>i&1)g[(j+(1ll<<i))%3][1]+=f[j][1];\n\t\t\t}else\n\t\t\t\tg[j][1]+=f[j][1];\n\t\t}\n\t\tmemcpy(f,g,sizeof(g));\n\t}\n\tfor(i=0;i<3;i++)s[i]=f[i][0]+f[i][1];\n}\nll get(ll n,ll l,ll r,int t){\n\tdp(n,r);\n\tll s=::s[t];\n\tdp(n,l-1);\n\treturn s-::s[t];\n}\nll x[10010],y[10010];\nint n;\nconst ll c=2*inf;\nll get(ll l,ll r,int t){\n\tll s;\n\tint i;\n\ts=0;\n\tfor(i=1;i<=n;i++)s+=get(c-x[i]-y[i],l-x[i],r-x[i],t);\n\treturn s;\n}\nbool C(ll n,ll k){return(n&k)==k;}\nbool light(ll a){\n\tint i,f=0;\n\tfor(i=1;i<=n;i++){\n\t\tif(x[i]<=a)f^=C(c-x[i]-y[i],a-x[i]);\n\t}\n\treturn f;\n}\nint main(){\n\tint i,t;\n\tll l,r,mid,x1,x2;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)scanf(\"%lld%lld\",x+i,y+i);\n\tfor(t=0;t<3;t++){\n\t\tif(get(-inf,inf,t)&1)break;\n\t}\n\tl=-inf;\n\tr=inf;\n\twhile(l<r){\n\t\tmid=(l+r)>>1;\n\t\tif(get(l,mid,t)&1)\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n\tassert(light(l));\n\tx1=x2=l;\n\tfor(i=60;i>=0;i--){\n\t\tif(light(x1-(1ll<<i)))x1-=1ll<<i;\n\t\tif(light(x2+(1ll<<i)))x2+=1ll<<i;\n\t}\n\tprintf(\"%lld %lld\",x1,c-x2);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <ctype.h>\n#include <algorithm>\n#include <fstream>\n#include <climits>\n#define mp make_pair\n#define x first\n#define y second\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef pair<int, int> pii;\ntypedef pair<LL, LL> pll;\ntypedef pair<int, LL> pil;\n\nconst LL INF = 2e17 + 7;\nconst int Bit = 62;\nconst int MAXN = 2e5 + 7;\n\ninline void proc_status() {\n\tifstream t(\"/proc/self/status\");\n\tcerr << string(istreambuf_iterator<char>(t), istreambuf_iterator<char>()) << endl;\n}\n\ntemplate<typename T> inline T read() {\n\tT res = 0, flag = 1; char in = getchar();\n\twhile(!isdigit(in)) { if(in == '-') flag = -1; in = getchar(); }\n\twhile(isdigit(in)) { res = (res << 1) + (res << 3) + in - '0'; in = getchar(); }\n\treturn res * flag;\n}\n\ntemplate<typename T> inline void chkmax(T &a, T b) { if(a < b) a = b; }\ntemplate<typename T> inline void chkmin(T &a, T b) { if(a > b) a = b; }\n\nLL by;\nLL S, L, R;\nint mul[Bit + 1];\nint dp[Bit + 1][3][2][2];\n\nint dfs(int k, int rest, bool bl, bool br) {\n\tif(k == -1) { return rest == 0; }\n\tint &res = dp[k][rest][bl][br];\n\tif(res >= 0) return res;\n\tres = 0;\n\tint l = 0, r = 1;\n\tif(bl) l = (L >> k) & 1;\n\tif(br) r = (R >> k) & 1;\n\tfor(int i = l; i <= r; ++i) {\n\t\tif((!((S >> k) & 1)) && i) continue;\n\t\tres ^= dfs(k - 1, (rest - i * mul[k] + 3) % 3, bl && (i == l), br && (i == r));\n\t}\n\treturn res;\n}\n\ninline int Val(int res, LL a, LL b, LL l, LL r) {\n//\tcout << r << endl;\n\tchkmax(l, a); chkmin(r, a + b);\n//\texit(0);\n\tif(l > r) return 0;\n\tl -= a; r -= a;\n\tL = l; R = r; S = b;\n//\tprintf(\"%lld %lld %lld %lld\\n\", a, b, l, r);\n\tmemset(dp, -1, sizeof dp);\n//\texit(0);\n\ta = (a % 3 + 3) % 3;\n\treturn dfs(Bit, (res - a + 3) % 3, 1, 1);\n}\n\nint n;\npll p[MAXN];\n\ninline bool IsOdd(LL l, LL r) {\n\tfor(int i = 0; i < 3; ++i) {\n\t\tint res = 0;\n\t\tfor(int j = 1; j <= n; ++j) {\n//\t\t\tcout << \"GG \" << p[j].x << ' ' << p[j].y << endl;\n\t\t\tint x = Val(i, p[j].x, p[j].y, l, r);\n//\t\t\tprintf(\"FF %d\\n\", x);\n//\t\t\texit(0);\n\t\t\tres ^= x;\n\t\t}\n\t\tif(res) return 1;\n//\t\tcout << res << endl;\n//\t\texit(0);\n\t}\n\treturn 0;\n}\n\ninline LL GetSt(LL l, LL r) {\n//\tcout << IsOdd(1, 3);\n//\texit(0);\n\twhile(1) {\n//\t\tcerr << l << ' ' << r << endl;\n\t\tLL mid = l + r >> 1;\n\t\tif(IsOdd(l, mid)) r = mid;\n\t\telse l = mid + 1;\n\t\tif(l == r) return l;\n\t}\n//\texit(0);\n}\n\nLL st;\n\ninline void init() {\n\tmul[0] = 1;\n\tfor(int i = 1; i <= Bit; ++i) mul[i] = mul[i - 1] * 2 % 3;\n\tn = read<int>();\n\tby = LLONG_MAX;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tp[i].x = read<LL>();\n\t\tchkmin(by, p[i].y = read<LL>());\n\t}\n\tfor(int i = 1; i <= n; ++i) p[i].y = p[i].y - by;\n\tst = GetSt(-INF, INF);\n//\texit(0);\n//\tcout << st << endl;\n//\tprintf(\"%lld\\n\", by);\n}\n\ninline int Val(LL x) {\n\tint res = 0;\n\tfor(int i = 1; i <= n; ++i) {\n\t\tif(x < p[i].x) continue;\n\t\tif(x > p[i].x + p[i].y) continue;\n\t\tint tx = x - p[i].x;\n\t\tres ^= ((tx & p[i].y) == tx);\n//\t\tprintf(\"%d\\n\", res);\n\t}\n\treturn res;\n}\n\ninline void solve() {\n//\tcout << Val(1) << endl;\n//\tcout << endl;\n//\texit(0);\n\tLL ed = st;\n\n\tfor(int i = Bit; i >= 0; --i) {\n\t\tif(Val(ed + (1ll << i))) {\n//\t\t\texit(0);\n\t\t\ted += (1ll << i);\n\t\t}\n\t}\n\n//\tcout << st << ' ' << ed << endl;\n//\texit(0);\n\n\tfor(int i = Bit; i >= 0; --i) {\n\t\tif(Val(st - (1ll << i))) {\n\t\t\tst -= (1ll << i);\n\t\t}\n\t}\n//\texit(0);\n\tprintf(\"%lld %lld\\n\", st, by + ed - st);\n}\n\nint main() {\n\n\tinit();\n\tsolve();\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define SUBTASK 2\n\nusing ll = long long;\n\nconst ll XMAX = 1.1e17;\n\nconst int MAXN = 1.1e5;\nint N;\npair<ll, ll> P[MAXN];\n\nbool checkPt(ll Y) {\n\tbool res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tres ^= (((Y - P[i].second) | P[i].first) == P[i].first);\n\t}\n\treturn res;\n}\n\npair<ll, ll> ptToBounds(ll Y) {\n\tassert(checkPt(Y));\n\tll lo = Y, hi = Y;\n\tfor (int l = 59; l >= 0; l--) {\n\t\tif (checkPt(hi + (1ll << l))) {\n\t\t\thi += (1ll << l);\n\t\t}\n\t\tif (checkPt(lo - (1ll << l))) {\n\t\t\tlo -= (1ll << l);\n\t\t}\n\t}\n\treturn {hi - lo, lo};\n}\n\npair<ll, ll> goSub1() {\n\treturn ptToBounds(XMAX);\n}\n\nbool checkRng(ll Ymin, ll v3) {\n\tbool res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tll curMin = max(0ll, Ymin - P[i].second);\n\n\t\t// must be strictly greater than curMin\n\t\tbool dp[3] = {0,0,0};\n\n\t\tfor (int l = 59; l >= 0; l--) {\n\t\t\tif (!(P[i].first & (1ll << l))) continue; // must be 0\n\n\t\t\t{\n\t\t\t\tbool ndp[3] = {0,0,0};\n\t\t\t\tfor (int z = 0; z < 3; z++) {\n\t\t\t\t\tndp[z] = dp[z];\n\t\t\t\t}\n\t\t\t\tfor (int z = 0; z < 3; z++) {\n\t\t\t\t\tndp[(z+(1ll << l)) % 3] ^= dp[z];\n\t\t\t\t}\n\t\t\t\tfor (int z = 0; z < 3; z++) {\n\t\t\t\t\tdp[z] = ndp[z];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (!(curMin & (1ll << l))) {\n\t\t\t\t// we can increment and be bigger\n\t\t\t\tll val = ((curMin >> l) | 1) << l;\n\t\t\t\tif ((val | P[i].first) == P[i].first) {\n\t\t\t\t\tdp[(val + P[i].second) % 3] ^= 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif ((curMin | P[i].first) == P[i].first) {\n\t\t\tdp[(curMin + P[i].second) % 3] ^= 1;\n\t\t}\n\n\t\tres ^= dp[v3];\n\t}\n\treturn res;\n}\n\npair<ll, ll> go() {\n\tll v3 = 0;\n\twhile (!checkRng(0, v3)) {\n\t\tv3++;\n\t\tassert(v3 < 3);\n\t}\n\n\tll mi = 0;\n\tll ma = ll(1e18);\n\twhile (ma - mi > 1) {\n\t\tll md = (mi + ma) / 2;\n\t\tif (checkRng(md, v3)) {\n\t\t\tmi = md;\n\t\t} else {\n\t\t\tma = md;\n\t\t}\n\t}\n\n\treturn ptToBounds(mi);\n}\n\nint main() {\n\tios_base::sync_with_stdio(0), cin.tie(0), cout.tie(0);\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> P[i].first >> P[i].second;\n\t\tP[i].first += XMAX;\n\t\tP[i].second += XMAX;\n\t\tassert(P[i].first >= 0);\n\t\tassert(P[i].second >= 0);\n\t}\n\n#if SUBTASK == 1\n\tauto ans = goSub1();\n#else\n\tauto ans = go();\n#endif\n\tans.first -= XMAX;\n\tans.second -= XMAX;\n\n#if SUBTASK == 1\n\tcout << ans.first << '\\n';\n#else\n\tcout << ans.first << ' ' << ans.second << '\\n';\n#endif\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll base = 1ll << 58;\nconst int LOG = 60;\nint main() {\n  do {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n  } while (false);\n  int n;\n  cin >> n;\n  vector<ll> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n    x[i] += base;\n    y[i] += base;\n  }\n  auto calc = [&] (ll sum, int r) {\n    bool res = false;\n    for (int i = 0; i < n; i++) {\n      if (y[i] < sum) {\n        ll limit = sum - y[i];\n        vector<bool> F(3), G(3);\n        F[0] = true;\n        for (int j = LOG; j >= 0; j--) {\n          vector<bool> F2(3), G2(3);\n          for (int k = 0; k < 3; k++) {\n            if (F[k]) {\n              for (int v = 0; v <= min(limit >> j & 1, x[i] >> j & 1); v++) {\n                int nxt = (k + v * (j & 1) + v) % 3;\n                if (v != (limit >> j & 1)) {\n                  G2[nxt].flip();\n                } else {\n                  F2[nxt].flip();\n                }\n              }\n            }\n            if (G[k]) {\n              for (int v = 0; v <= (x[i] >> j & 1); v++) {\n                int nxt = (k + v * (j & 1) + v) % 3;\n                G2[nxt].flip();\n              }\n            }\n          }\n          F = F2;\n          G = G2;\n        }\n        res ^= G[(r - y[i] % 3 + 3) % 3];\n      }\n    }\n    return res;\n  };\n  calc(1ll << LOG, 0);\n  calc(1ll << LOG, 1);\n  calc(1ll << LOG, 2);\n  return 0;\n  int r = 0;\n  while (!calc(1ll << LOG, r)) {\n    r++;\n  }\n  ll start = 0;\n  for (int i = LOG; i >= 0; i--) {\n    if (calc(start, r) == calc(start + (1ll << i), r)) {\n      start |= 1ll << i;\n    }\n  }\n  auto check = [&] (ll pos) {\n    bool res = false;\n    for (int i = 0; i < n; i++) {\n      if (y[i] <= pos && pos <= x[i] + y[i] && (x[i] & (pos - y[i])) == pos - y[i]) {\n        res ^= 1;\n      }\n    }\n    return res;\n  };\n  ll L = start, R = start;\n  for (int i = LOG; i >= 0; i--) {\n    if (check(L - (1ll << i))) {\n      L -= 1ll << i;\n    }\n    if (check(R + (1ll << i))) {\n      R += 1ll << i;\n    }\n  }\n  cout << R - L - base << \" \" << L - base << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cassert>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n      \tint qc=2*x.first+x.second+1;\n\tqc = (qc & (int)(0xffffffff)) + ((qc & (0x7fffffff00000000)) >> 32);\n\tqc = (qc & (int)(0xffffffff)) + ((qc & (int)(0x100000000)) >> 32);\n\tqc = (qc & (0xffff)) + ((qc & (int)(0xffff0000)) >> 16);\n\tqc = (qc & (0xffff)) + ((qc & (0x10000)) >> 16);\n\tqc = (qc & (0xff)) + ((qc & (0xff00)) >> 8);\n\tqc = (qc & (0xff)) + ((qc & (0x100)) >> 8);\n\tqc = (qc & (0xf)) + ((qc & (0xf0)) >> 4);\n\tqc = (qc & (0xf)) + ((qc & (0x10)) >> 4);\n\tqc = (qc & 3) + ((qc & 12) >> 2);\n\tqc = (qc & 3) + ((qc & 4) >> 2);\n      assert(qc<=3);\n\t\tc ^= qc;\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n          c[i][0]^=((qc+1)&1);\n          c[i][1]^=((qc+1)&2);\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0]&&!c[1-i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = 2 * x.first + x.second + 1;\n\tqc = (qc & (0xffffffff)) + ((qc & (0x7fffffff00000000)) >> 32);//qc<=1ffffffff\n\tqc = (qc & (0xffff)) + ((qc & (0x1ffff0000)) >> 16);//qc<=2ffff\n\tqc = (qc & (0xff)) + ((qc & (0x3ff00)) >> 8);//qc<=3ff\n\tqc = (qc & (0xf)) + ((qc & (0x3f0)) >> 4);//qc<=4e\n\tqc = (qc & (0xf)) + ((qc & (0x7e)) >> 4);//qc<=18\n\tqc = (qc & 3) + ((qc & 28) >> 2);\n\t\tc ^= qc;\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t\tw++;\n\t\tif ((w & x.first) == w) { d ^= 1; }\n\t}\n\tans.first *= 2; ans.second *= 2;\n\tans.first += (c | d); ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n  pin ans=solve(qab[sz&1],ex-1);\n  ans.first+=sz&1;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n    }\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin &x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n  vel c(2);\n\trep(i, 2) {\n\t\tfor (pin &x : qab[1-i]) {\n\t\t\tint qc = (2 * x.first + x.second)%3;\n          c[1-i]^=(qc+1);\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1, 0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc + 1) % 2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0] && !c[1 - i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor (pin& v : ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\",&n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld %lld\",&a,&b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#pragma GCC target(\"avx\")\n#pragma GCC optimize(\"O3\")\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1, 0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc + 1) % 2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0] && !c[1 - i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor (pin& v : ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 2e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"sse2,pclmul,tune=native\")\n#pragma GCC optimize(\"O3\")\n#include <ext/pb_ds/assoc_container.hpp>\n#include <nmmintrin.h>\n#include <emmintrin.h>\n#include <wmmintrin.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nusing GF = uint32_t;\n\ninline GF Add(GF a, GF b) {\n  return a ^ b;\n}\n\ninline GF Mul(GF a, GF b) {\n  __m128i xa = _mm_cvtsi64_si128(a), xb = _mm_cvtsi64_si128(b);\n  xa = _mm_clmulepi64_si128(xa, xb, 0x00);\n  uint64_t res = _mm_cvtsi128_si64(xa);\n  GF hi = res >> 32;\n  GF a0 = hi ^ (hi >> 25) ^ (hi >> 29) ^ (hi >> 30);\n  return (GF)res ^ a0 ^ (a0 << 2) ^ (a0 << 3) ^ (a0 << 7);\n}\n\nvector<GF> base;\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val);\nGF AddPositionsFrom(LL x, LL y, LL min_val);\n\nmap<pair<LL, LL>, GF> memo;\nGF AddPositions(LL x, LL y, int bb = 60) {\n  if (x == 0 && y == 0) { return 1; }\n  debug(\"?Any\", x, y);\n  \n  pair<LL, LL> p{x, y};\n  if (memo.count(p)) { return memo[p]; }\n\n  int bit = bb;\n  while ((1LL << bit) > x + y) { --bit; }\n  if (x >= (1LL << bit)) {\n    GF ans = Mul(base[bit], AddPositions(x ^ (1LL << bit), y));\n    debug(x, y, ans);\n    return memo[p] = ans;\n  }\n\n  // x < 2^bit <= x + y\n  GF answer1 = AddPositionsUpTo(x, y, (1LL << bit) - 1);\n  GF answer2 = AddPositionsFrom(x, y, (1LL << bit));\n  debug(x, y, answer1, answer2);\n  return memo[p] = Add(answer1, answer2);\n}\n\nGF GetValue(LL x) {\n  static map<LL, GF> val_memo;\n  auto it = val_memo.find(x);\n  if (it != val_memo.end()) { return it->nd; }\n\n  GF ans = 1;\n  for (int bit = 60; bit >= 0; --bit) {\n    if ((x >> bit) & 1) {\n      ans = Mul(base[bit], ans);\n    }\n  }\n  debug(\"Value\", x, ans);\n  return val_memo[x] = ans;\n}\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val) {\n  debug(\"?UpTo\", x, y, max_val);\n  if (x > max_val) { return 0; }\n  if (x + y <= max_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int bit = 60; bit >= 0; --bit) {\n    if (!((y >> bit) & 1)) { continue; }\n    const LL v = 1LL << bit;\n    y ^= v;\n\n    if (x + v - 1 <= max_val) {\n      debug(\"UpTo\", orig_x, orig_y, max_val, x, y);\n      answer = Add(answer, AddPositions(x, y));\n      x += v;\n    }\n  }\n  debug(answer);\n  if (x <= max_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF AddPositionsFrom(LL x, LL y, LL min_val) {\n  if (x + y < min_val) { return 0; }\n  if (x >= min_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int bit = 60; bit >= 0; --bit) {\n    if (!((y >> bit) & 1)) { continue; }\n    const LL v = 1LL << bit;\n    y ^= v;\n\n    if (x + v >= min_val) {\n      answer = Add(answer, AddPositions(x + v, y));\n    } else {\n      x += v;\n    }\n  }\n  debug(\"From\", orig_x, orig_y, min_val, answer, x);\n  if (x >= min_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF GetRandom() {\n  GF ans = 0;\n  for (int i = 0; i < 4; ++i) {\n    ans <<= 16;\n    ans |= (rand() % (1 << 16));\n  }\n  return ans;\n}\n\nint32_t main() {\n#ifndef LOCAL\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n#endif\n\n#ifdef TESTING\n  while (true) {\n    GF a = GetRandom(), b = GetRandom(), c = GetRandom();\n    GF d = Mul(a, Add(b, c));\n    GF e = Add(Mul(a, b), Mul(a, c));\n    debug(a,b,c,d,e);\n    assert(d == e);\n  }\n#endif\n\n  srand(2137);\n\n  const int S = 58;\n  const LL kLarge = 1LL << S;\n  for (int i = 0; i < 70; ++i) {\n    GF x = GetRandom();\n    base.PB(x);\n  }\n  debug(base);\n\n  int N;\n  cin >> N;\n  mini(N, 2500LL);\n  vector<pair<LL, LL>> values;\n\n  auto TotalGF = [&](LL bound) {\n    GF ans = 0;\n    for (auto &val : values) {\n      ans = Add(ans, AddPositionsUpTo(val.st, val.nd, bound));\n    }\n    debug(bound, ans);\n    return ans;\n  };\n\n  for (int i = 0; i < N; ++i) {\n    LL x, y;\n    cin >> x >> y;\n    values.emplace_back(x + kLarge, y + kLarge);\n  }\n\n  debug(values);\n\n  LL Lzero = 0, Rzero = (1LL << (S + 2));\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == 0) {\n      Lzero = midzero;\n    } else {\n      Rzero = midzero;\n    }\n  }\n\n  const LL first_x = Rzero - kLarge;\n  \n  Lzero = first_x + kLarge - 2; Rzero = (1LL << (S + 2));\n  const GF aim = TotalGF(Rzero);\n\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == aim) {\n      Rzero = midzero;\n    } else {\n      Lzero = midzero;\n    }\n  }\n\n  const LL last_x = Rzero - kLarge;\n\n  cout << first_x << \" \" << last_x - first_x - kLarge << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\tV<V<bool>> c(2, V<bool>(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc+1)%2) { c[i][0]^=true; }\n\t\t\tif (qc) { c[i][1] ^= true; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0]&&!c[1-i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin &x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\trep(i, 2) {\n      int c;\n\t\tfor (pin &x : qab[1-i]) {\n\t\t\tint qc = (2 * x.first + x.second)%3;\n          c^=(qc+1);\n\t\t}\n\t\tif (!c) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll L = -2e7;\nint n;\nvector<pair<ll,ll> > v;\nbool check_point(pair<ll,ll> p, ll x, ll y)\n{\n\tif (x<p.FF||x>p.FF+p.SS-y) return false;\n\tll X = x-p.FF;\n\tll Y = p.SS-y;\n\treturn (Y&X)==X;\n}\nbool check_point(ll x)\n{\n\tbool ret = 0;\n\tfor (auto p : v)\n\t{\n\t\tif (check_point(p, x, L))\n\t\t{\n\t\t\tret ^= 1;\n\t\t}\n\t}\n\treturn ret;\n}\nbool cnt[3];\nvoid calc(pair<ll,ll> p, ll x, ll y)\n{\n\tif (x<p.FF) return;\n\tif (x>p.FF+p.SS-y) x = p.FF+p.SS-y;\n\tll X = x-p.FF;\n\tll Y = p.SS-y;\n\tassert(Y>=0);\n\tstatic bool dp[66][2][3];\n\tmemset(dp, 0, sizeof(dp));\n\tdp[60][1][0] = 1;\n\tfor (int i=59; i>=0; i--)\n\t{\n\t\tfor (int t=0; t<2; t++)\n\t\t{\n\t\t\tfor (int v=0; v<2; v++)\n\t\t\t{\n\t\t\t\tif (v&&~((Y>>i)&1)) continue;\n\t\t\t\tif (v&&t&&~((X>>i)&1)) continue;\n\t\t\t\tint dlt = ((1ll*v)<<i)%3;\n\t\t\t\tint nt = t&(v==((X>>i)&1));\n\t\t\t\tfor (int j=0; j<3; j++) dp[i][nt][(j+dlt)%3] ^= dp[i+1][t][j];\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tcnt[i] ^= dp[0][0][i];\n\t\tcnt[i] ^= dp[0][1][i];\n\t}\n}\nbool check(ll x)\n{\n\tcnt[0] = cnt[1] = cnt[2] = 0;\n\tfor (auto p : v)\n\t{\n\t\tcalc(p, x, L);\n\t}\n\treturn cnt[0]||cnt[1]||cnt[2];\n}\nint main()\n{\n\tgeti(n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll x, y;\n\t\tgetii(x, y);\n\t\tv.PB(MP(x, y));\n\t}\n/*\tfor (int i=L; i<=-L; i++)\n\t{\n\t\tcerr<<check_point(i);\n\t\tif ((i-L)%5==0) cerr<<\" \";\n\t} cerr<<endl;\n*/\n\tll l = 2*L, r = -l;\n\twhile (l<=r)\n\t{\n\t\tll m = l+r>>1;\n\t\tif (check(m)) r = m-1; else l = m+1;\n\t}\n//\tcerr<<l<<\",\"<<r<<endl;\n\tl = r;\n\tfor (int i=0; i<=60; i++) if (check_point(l-(1ll<<i))) l -= 1ll<<i;\n\tfor (int i=0; i<=60; i++) if (check_point(r+(1ll<<i))) r += 1ll<<i;\n\tcout<<l<<\" \"<<L+(r-l)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin &x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n  int c=0;\n\t\tfor (pin &x : qab[1]) {\n\t\t\tint qc = (2 * x.first + x.second)%3;\n          c^=(qc+1);\n\t\t}\n\t\tif (!c) {\n\t\t\tpin ans = solve(qab[0], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += 0;\n\t\t\treturn ans;\n\t\t}\n    c=0;\n\t\tfor (pin &x : qab[0]) {\n\t\t\tint qc = (2 * x.first + x.second)%3;\n          c^=(qc+1);\n\t\t}\n\t\tif (!c) {\n\t\t\tpin ans = solve(qab[1], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += 1;\n\t\t\treturn ans;\n\t\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst LL ShiftAll = 1.5e17;\n\n/*LL GetXorPositions(LL x, LL y) {\n  if (!y) { return x; }\n  if (!(y & (y - 1))) { return x ^ (x + y); }\n\n  int low_bit = 0;\n  while (!((y >> low_bit) & 1)) { ++low_bit; }\n\n  LL answer = 0;\n  for (int bit = 0; bit < 60; ++bit) {\n    if ((y >> bit) & 1) { continue; }\n    if ((1LL << bit) <= y) { continue; }\n\n    LL overflow_bound = (1LL << bit) - (x & ((1LL << bit) - 1));\n    LL my_y = 0;\n    //debug(bit, overflow_bound, low_bit);\n    bool fail = false;\n    for (int b = bit - 1; b > low_bit; --b) {\n      bool ov_bit = ((overflow_bound >> b) & 1);\n      bool y_bit = ((y >> b) & 1);\n      if (ov_bit && !y_bit) { fail = true; break; }\n      my_y |= ((LL)ov_bit << b);\n    }\n\n    int num_over = (my_y >= overflow_bound);\n    num_over += ((my_y ^ (1LL << low_bit)) >= overflow_bound);\n    if (!fail && num_over == 1) {\n      answer += 1LL << bit;\n    }\n  }\n  return answer;\n}\n\nLL BruteXorPositions(LL x, LL y) {\n  LL ans = 0;\n  for (LL i = 0; i <= y; ++i) {\n    if ((y & i) == i) {\n      ans ^= (x + i);\n    }\n  }\n  return ans;\n}*/\n\nusing GF = uint64_t;\n\ninline GF Add(GF a, GF b) {\n  return a ^ b;\n}\n\ninline GF Mul(GF a, GF b) {\n  const GF kBase = 0x000000000000001B;\n  __uint128_t mul = (__uint128_t)a * b;\n  for (int i = 63; i >= 0; --i) {\n    if ((mul >> (i + 64)) & 1) {\n      mul ^= (__uint128_t)kBase << i;\n    }\n  }\n  return (GF)mul;\n}\n\nvector<GF> base;\n\n\nbool ParityXorNotExceeding(LL x, LL y, LL max_val) {\n  if (x > max_val) { return 0; }\n\n  int low_bit = 0;\n  while (!((y >> low_bit) & 1)) { ++low_bit; }\n\n  max_val -= x;\n  for (int bit = 60; bit > low_bit; --bit) {\n    bool max_bit = ((max_val >> bit) & 1);\n    bool y_bit = ((y >> bit) & 1);\n    if (max_bit && !y_bit) {\n      return false;\n    }\n  }\n\n  return !((max_val >> low_bit) & 1);\n}\n\nint32_t main() {\n#ifndef LOCAL\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n#endif\n\n  /*LL x, y, m;\n  while (cin >> x >> y >> m) {\n    cout << ParityXorNotExceeding(x, y, m) << \"\\n\";\n  }\n  return 0;*/\n\n  const LL kLarge = 1LL << 58;\n\n  int N;\n  cin >> N;\n  vector<pair<LL, LL>> values;\n\n  auto TotalParity = [&](LL bound) {\n    bool ans = false;\n    for (auto &val : values) {\n      ans ^= ParityXorNotExceeding(val.st, val.nd, bound);\n    }\n    return ans;\n  };\n\n  for (int i = 0; i < N; ++i) {\n    LL x, y;\n    cin >> x >> y;\n    values.emplace_back(x + kLarge, y + kLarge * 2);\n  }\n\n  LL L = 0;\n  while (true) {\n    LL R = L + kLarge;\n    if (!TotalParity(R)) {\n      L += kLarge;\n      continue;\n    }\n\n    while (R - L > 1) {\n      const int M = (L + R) / 2;\n      if (TotalParity(M)) {\n        R = M;\n      } else {\n        L = M;\n      }\n    }\n    cout << R - kLarge << \"\\n\";\n    break;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n  \tc=0;\n  \tfor (pin& x : qab[1]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n  \tif (!c) {\n\t\tans.first *= 2; ans.second *= 2;\n\t\treturn ans;\n\t}\n\tc = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second-1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t}\n\tans.first *= 2; ans.first++; ans.second *= 2; ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1, 0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc + 1) % 2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0] && !c[1 - i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor (pin& v : ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nint readint() {\n\tchar c = getchar_unlocked();\n\tint res = 0;\n\twhile ('0' <= c && c <= '9') {\n\t\tres = res * 10 + c - '0';\n\t\tc = getchar_unlocked();\n\t}\n\treturn res;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n = readint();\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; char ca = getchar(); a = readint(); \n\t\tchar cb = getchar(); b = readint();\n\t\tif (ca == '-') { a *= -1; }\n\t\tif (cb == '-') { b *= -1; }\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n      \tint qc=2*x.first+x.second;\n        qc=(qc&(0xffffffff))+((qc&(0xffffffff00000000))>>32);\n      \tqc=(qc&(0xffff))+((qc&(0xffff0000))>>16);\n      \tqc=(qc&(0xff))+((qc&(0xff00))>>8);\n      \tqc=(qc&(0xf))+((qc&(0xf0))>>4);\n      \tqc=(qc&3)+((qc&12)>>2);\n      \tqc=(qc&3)+((qc&12)>>2);\n        qc=(qc&3)+((qc&12)>>2);\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nconst ll C = -ll(1e18);\n\nvector<ii> vec;\n\nint color(ll x, ll y)\n{\n\tint ans=0;\n\tint n=vec.size();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll x2=vec[i].fi; ll y2=vec[i].se+C;\n\t\tll d = x-x2;\n\t\tll h = y2-y;\n\t\tif(d<0||d>h) continue;\n\t\tif((d&h)==d) ans^=1;\n\t}\n\treturn ans;\n}\n\nint md[63];\n\nll getbelow(ll r, int mod)\n{\n\tint res[3]; memset(res,0,sizeof(res));\n\tfor(ii pt:vec)\n\t{\n\t\tll x=pt.fi; ll y=pt.se;\n\t\tif(x>r) continue;\n\t\tll mx = r-x;\n\t\tint dp[2][3];\n\t\tmemset(dp,0,sizeof(dp));\n\t\tint xmod=x%3;\n\t\tif(xmod<0) xmod+=3;\n\t\tdp[1][0]=1;\n\t\tfor(int i=62;i>=0;i--)\n\t\t{\n\t\t\tint nw[2][3]; memset(nw,0,sizeof(nw));\n\t\t\tfor(int k=0;k<2;k++) //1 if still a prefix of mx\n\t\t\t{\n\t\t\t\tfor(int l=0;l<3;l++) //mod\n\t\t\t\t{\n\t\t\t\t\tif(!dp[k][l]) continue;\n\t\t\t\t\t//add 1\n\t\t\t\t\t{\n\t\t\t\t\t\tif(y&(1LL<<i))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(k==1&&!(mx&(1LL<<i)))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint newk=0;\n\t\t\t\t\t\t\t\tif(k==1&&(mx&(1LL<<i))) newk=1;\n\t\t\t\t\t\t\t\tint newl=(l+md[i])%3;\n\t\t\t\t\t\t\t\tnw[newk][newl]^=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//add 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint newk=0;\n\t\t\t\t\t\tif(k==1&&!(mx&(1LL<<i))) newk=1;\n\t\t\t\t\t\tint newl=l;\n\t\t\t\t\t\tnw[newk][newl]^=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=0;k<2;k++) //1 if still a prefix of mx\n\t\t\t{\n\t\t\t\tfor(int l=0;l<3;l++) //mod\n\t\t\t\t{\n\t\t\t\t\tdp[k][l]=nw[k][l];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int l=0;l<3;l++)\n\t\t{\n\t\t\tint nwmod=(xmod+l)%3;\n\t\t\tint as=(dp[0][l]^dp[1][l]);\n\t\t\t//cerr<<\"L \"<<l<<' '<<as<<'\\n';\n\t\t\tres[nwmod]^=as;\n\t\t}\n\t}\n\treturn res[mod];\n}\n\nll getcount(ll l, ll r, int mod) //%3 = mod\n{\n\treturn getbelow(r,mod)^getbelow(l-1,mod);\n}\n\nconst int DEBUG=0;\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tfor(int i=0;i<63;i++) md[i]=((1LL<<i))%3;\n\tif(DEBUG)\n\t{\n\t\tll x=rand(); ll y=rand();\n\t\t//cerr<<\"ORI \"<<x<<' '<<y<<'\\n';\n\t\tset<ii> S; S.insert({x,y});\n\t\tfor(int op=0;op<10;op++)\n\t\t{\n\t\t\tll x=(*S.begin()).fi; ll y=(*S.begin()).se;\n\t\t\tS.erase({x,y});\n\t\t\tif(rand()&1)\n\t\t\t{\n\t\t\t\tif(S.find({x+1,y})==S.end()) S.insert({x+1,y});\n\t\t\t\telse S.erase({x+1,y});\n\t\t\t\tif(S.find({x,y+1})==S.end()) S.insert({x,y+1});\n\t\t\t\telse S.erase({x,y+1});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(S.find({x-1,y})==S.end()) S.insert({x-1,y});\n\t\t\t\telse S.erase({x-1,y});\n\t\t\t\tif(S.find({x-1,y+1})==S.end()) S.insert({x-1,y+1});\n\t\t\t\telse S.erase({x-1,y+1});\n\t\t\t}\n\t\t}\n\t\tfor(ii pr:S) vec.pb(pr);\n\t}\n\telse\n\t{\n\t\tint n; cin>>n;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tll x,y; cin>>x>>y; vec.pb({x,y});\n\t\t}\n\t}\n\tfor(int i=0;i<vec.size();i++) vec[i].se-=C;\n\tint mod=-1;\n\tfor(int i=0;i<3;i++)\n\t{\n\t\t//cerr<<getcount(-ll(2e18),ll(2e18),i)<<'\\n';\n\t\tif(getcount(-ll(2e18),ll(2e18),i)){mod=i; break;}\n\t}\n\tassert(mod!=-1);\n\tll lo=-ll(2e18); ll hi=ll(2e18);\n\twhile(lo<hi)\n\t{\n\t\tll mid=(lo+hi)>>1;\n\t\tif(getcount(lo,mid,mod))\n\t\t{\n\t\t\thi=mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlo=mid+1;\n\t\t}\n\t}\n\tll cur = lo;\n\t//cerr<<\"MOD : \"<<mod<<\" | \"<<cur<<' '<<getcount(cur,cur,mod)<<'\\n';\n\t//assert(color(cur,C));\n\tfor(int i=62;i>=0;i--)\n\t{\n\t\tif(color(cur-(1LL<<i),C)) cur-=(1LL<<i);\n\t}\n\tll x = cur;\n\tfor(int i=62;i>=0;i--)\n\t{\n\t\tif(color(cur+(1LL<<i),C)) cur+=(1LL<<i);\n\t}\n\tll y = C+(cur-x);\n\tcout<<x<<' '<<y<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<assert.h>\ntypedef long long ll;\nconst ll inf=1e17;\nll f[3][2],g[3][2];\n//f[i][j][k]:i~60 ok, %3=j, locked?\nll s[3];\nvoid dp(ll n,ll m){//sum[i<=m & i in n & i%3=r]\n\tif(m<0){\n\t\tmemset(s,0,sizeof(s));\n\t\treturn;\n\t}\n\tint i,j;\n\tmemset(f,0,sizeof(f));\n\tf[0][1]=1;\n\tfor(i=60;i>=0;i--){\n\t\tmemset(g,0,sizeof(g));\n\t\tfor(j=0;j<3;j++){\n\t\t\tg[j][0]+=f[j][0];\n\t\t\tif(n>>i&1)g[(j+(1ll<<i))%3][0]+=f[j][0];\n\t\t\tif(m>>i&1){\n\t\t\t\tg[j][0]+=f[j][1];\n\t\t\t\tif(n>>i&1)g[(j+(1ll<<i))%3][1]+=f[j][1];\n\t\t\t}else\n\t\t\t\tg[j][1]+=f[j][1];\n\t\t}\n\t\tmemcpy(f,g,sizeof(g));\n\t}\n\tfor(i=0;i<3;i++)s[i]=f[i][0]+f[i][1];\n}\nll get(ll n,ll l,ll r,int t){\n\tdp(n,r);\n\tll s=::s[t];\n\tdp(n,l-1);\n\treturn s-::s[t];\n}\nll x[10010],y[10010];\nint n;\nconst ll c=2;\nll get(ll l,ll r,int t){\n\tll s;\n\tint i;\n\ts=0;\n\tfor(i=1;i<=n;i++)s+=get(c-x[i]-y[i],l-x[i],r-x[i],((t-x[i])%3+3)%3);\n\treturn s;\n}\nbool C(ll n,ll k){return(n&k)==k;}\nbool light(ll a){\n\tint i,f=0;\n\tfor(i=1;i<=n;i++){\n\t\tif(x[i]<=a)f^=C(c-x[i]-y[i],a-x[i]);\n\t}\n\treturn f;\n}\nint main(){\n\tint i,t;\n\tll l,r,mid,x1,x2;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)scanf(\"%lld%lld\",x+i,y+i);\n\tfor(t=0;t<3;t++){\n\t\tif(get(-inf,inf,t)&1)break;\n\t}\n\tl=-inf;\n\tr=inf;\n\twhile(l<r){\n\t\tmid=(l+r)>>1;\n\t\tif(get(l,mid,t)&1)\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n\tassert(light(l));\n\tx1=x2=l;\n\tfor(i=60;i>=0;i--){\n\t\tif(light(x1-(1ll<<i)))x1-=1ll<<i;\n\t\tif(light(x2+(1ll<<i)))x2+=1ll<<i;\n\t}\n\tprintf(\"%lld %lld\",x1,c-x2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V vector\n#define W V<long>\nusing namespace std;long E,M=2e17,a,b;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].push_back({x[0]/2,++x[1]/2});}for(long i;i<2;i++){a=0;for(W x:T[!i])a^=(2*x[0]+x[1])%3+1;if(!a)E--,W A=S(T[i]),A[0]*=2,A[1]*=2,A[1]+=i;return A;}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){cin>>E;V<W>p(E);while(E--,cin>>a>>b)p[E]={a+M,b+M};E=70;W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\n#define F for\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);F(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}F(L i;i<2;i++){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n,a,b;cin>>n;V<W>p(n);F(L i;i<n;i++){cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define W V<long long>\n#define R(i,n) for(int i=0;i<n;i++)\nW S(V<W>&p,int E) {\n\tif (!E) { return { 1, 0 }; }\n\tV<V<W>> T(2);\n\tfor (W x : p) {\n\t\tT[x[1] & 1].push_back({ x[0] / 2,x[1] / 2 });\n\t\tif (x[0] & 1) { T[(x[1] + 1) & 1].push_back({ x[0] / 2,(x[1] + 1) / 2 }); }\n\t}\n\tV<W> c(3,W(2));\n\tR(i, 2) {\n\t\tfor (W x : T[i]) {\n\t\t\tint Q = (2 * x[0] + x[1]) % 3;\n\t\t\tif ((Q+ 1) % 2) { c[i][0] ^= 1; }\n\t\t\tif (Q) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\tR(i, 2) {\n\t\tif (c[1 - i] == c[2]) {\n\t\t\tW ans = S(T[i], E-1);\n\t\t\tans[0] *= 2; ans[1] *= 2; ans[1] += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor (W&v : p) { v[0]++; }\n\tW A=S(p, E);A[0]--;return A;\n}\nint main() {\n\tlong long M = 2e17;\n\tint n; cin >> n;\n\tV<W> p(n);\n\tR(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tp[i] = { a + M,b + M };\n\t}\n\tW Q = S(p, 70);\n\tcout << Q[0] - M << \" \" << Q[1] - M;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n *    author:  tourist\n *    created: 17.01.2020 01:59:15       \n**/\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nint main() {\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  int n;\n  cin >> n;\n  vector<long long> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n  }\n  auto IsSubset = [&](long long a, long long b) {\n    return ((a & b) == a);\n  };\n  auto Get = [&](long long X, long long Y) {\n    int z = 0;\n    for (int i = 0; i < n; i++) {\n      if (X >= x[i]) {\n        z ^= IsSubset(X - x[i], y[i] - Y);\n      }\n    }\n    return z % 2;\n  };\n  auto AddSubsets = [&](vector<long long>& p, long long xb, long long xs, long long b) {\n    long long a = xb - xs;\n    a += 1;\n    int shift = ((int) (xs % 3) + 3) % 3;\n    for (int bit = 61; bit >= 0; bit--) {\n      if (a & (1LL << bit)) {\n        // 1 0 0\n        // 1 1 0\n        // 1 0 1\n        // 0 1 1\n        // 1 1 0\n        // ...\n        int cc = __builtin_popcountll(b & ~(1LL << bit));\n        if (cc == 0) {\n          p[shift] ^= 1;\n        } else {\n          int t = (shift + (cc % 3 == 2 ? 2 : (1 - cc % 3))) % 3;\n          p[t] ^= 1;\n          p[(t + 1) % 3] ^= 1;\n        }\n        shift = (shift + 1) % 3;\n        if (!(b & (1LL << bit))) {\n          break;\n        }\n      }\n      b &= ~(1LL << bit);\n    }\n  };\n  auto Get3 = [&](long long X, long long Y) {\n    vector<long long> ret(3);\n    for (int i = 0; i < n; i++) {\n      if (X >= x[i]) {\n        AddSubsets(ret, X, x[i], y[i] - Y);\n      }\n    }\n    return ret;\n  };\n  const long long inf = (long long) 5e17;\n  long long Y = -inf / 2;\n  long long low = -inf, high = inf;\n  while (low < high) {\n    long long mid = low + ((high - low) >> 1);\n    auto ret = Get3(mid, Y);\n    if (ret[0] + ret[1] + ret[2] == 0) {\n      low = mid + 1;\n    } else {\n      high = mid;\n    }\n  }\n  long long X = low;\n  assert(Get(X, Y) == 1);\n  for (int bit = 60; bit >= 0; bit--) {\n    if (Get(X - (1LL << bit), Y)) {\n      X -= 1LL << bit;\n    }\n  }\n  long long minX = X;\n  for (int bit = 60; bit >= 0; bit--) {\n    if (Get(X + (1LL << bit), Y)) {\n      X += 1LL << bit;\n    }\n  }\n  long long maxX = X;\n  cout << minX << \" \" << Y + (maxX - minX) << '\\n';\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cassert>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n      \tint qc=2*x.first+x.second+1;int ql=2*x.first+x.second;\n\tqc = (qc & (int)(0xffffffff)) + ((qc & (0x7fffffff00000000)) >> 32);\n\tqc = (qc & (int)(0xffffffff)) + ((qc & (int)(0x100000000)) >> 32);\n\tqc = (qc & (0xffff)) + ((qc & (int)(0xffff0000)) >> 16);\n\tqc = (qc & (0xffff)) + ((qc & (0x10000)) >> 16);\n\tqc = (qc & (0xff)) + ((qc & (0xff00)) >> 8);\n\tqc = (qc & (0xff)) + ((qc & (0x100)) >> 8);\n\tqc = (qc & (0xf)) + ((qc & (0xf0)) >> 4);\n\tqc = (qc & (0xf)) + ((qc & (0x10)) >> 4);\n\tqc = (qc & 3) + ((qc & 12) >> 2);\n\tqc = (qc & 3) + ((qc & 4) >> 2);\n      assert(qc<=3);\n      assert(qc==(ql%3)+1);\n\t\tc ^= qc;\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\n#define R(n)for(L i;i<n;i++)\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){L c;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n,a,b;cin>>n;V<W>p(n);R(n){cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst LL ShiftAll = 1.5e17;\n\n/*LL GetXorPositions(LL x, LL y) {\n  if (!y) { return x; }\n  if (!(y & (y - 1))) { return x ^ (x + y); }\n\n  int low_bit = 0;\n  while (!((y >> low_bit) & 1)) { ++low_bit; }\n\n  LL answer = 0;\n  for (int bit = 0; bit < 60; ++bit) {\n    if ((y >> bit) & 1) { continue; }\n    if ((1LL << bit) <= y) { continue; }\n\n    LL overflow_bound = (1LL << bit) - (x & ((1LL << bit) - 1));\n    LL my_y = 0;\n    //debug(bit, overflow_bound, low_bit);\n    bool fail = false;\n    for (int b = bit - 1; b > low_bit; --b) {\n      bool ov_bit = ((overflow_bound >> b) & 1);\n      bool y_bit = ((y >> b) & 1);\n      if (ov_bit && !y_bit) { fail = true; break; }\n      my_y |= ((LL)ov_bit << b);\n    }\n\n    int num_over = (my_y >= overflow_bound);\n    num_over += ((my_y ^ (1LL << low_bit)) >= overflow_bound);\n    if (!fail && num_over == 1) {\n      answer += 1LL << bit;\n    }\n  }\n  return answer;\n}\n\nLL BruteXorPositions(LL x, LL y) {\n  LL ans = 0;\n  for (LL i = 0; i <= y; ++i) {\n    if ((y & i) == i) {\n      ans ^= (x + i);\n    }\n  }\n  return ans;\n}*/\n\nusing GF = uint64_t;\n\ninline GF Add(GF a, GF b) {\n  return a ^ b;\n}\n\ninline GF Mul(GF a, GF b) {\n  const GF kBase = 0x000000000000001B;\n  __uint128_t mul = (__uint128_t)a * b;\n  for (int i = 63; i >= 0; --i) {\n    if ((mul >> (i + 64)) & 1) {\n      mul ^= (__uint128_t)kBase << i;\n    }\n  }\n  return (GF)mul;\n}\n\nvector<GF> base;\n\n\nbool ParityXorNotExceeding(LL x, LL y, LL max_val) {\n  if (x > max_val) { return 0; }\n\n  int low_bit = 0;\n  while (!((y >> low_bit) & 1)) { ++low_bit; }\n\n  max_val -= x;\n  for (int bit = 60; bit > low_bit; --bit) {\n    bool max_bit = ((max_val >> bit) & 1);\n    bool y_bit = ((y >> bit) & 1);\n    if (max_bit && !y_bit) {\n      return false;\n    }\n  }\n\n  return !((max_val >> low_bit) & 1);\n}\n\nint32_t main() {\n#ifndef LOCAL\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n#endif\n\n  /*LL x, y, m;\n  while (cin >> x >> y >> m) {\n    cout << ParityXorNotExceeding(x, y, m) << \"\\n\";\n  }\n  return 0;*/\n\n  const LL kLarge = 1LL << 58;\n\n  int N;\n  cin >> N;\n  vector<pair<LL, LL>> values;\n\n  auto TotalParity = [&](LL bound) {\n    bool ans = false;\n    for (auto &val : values) {\n      ans ^= ParityXorNotExceeding(val.st, val.nd, bound);\n    }\n    return ans;\n  };\n\n  for (int i = 0; i < N; ++i) {\n    LL x, y;\n    cin >> x >> y;\n    values.emplace_back(x + kLarge, y + kLarge * 2);\n  }\n\n  LL L = 0;\n  while (true) {\n    LL R = L + kLarge;\n    if (!TotalParity(R)) {\n      L += kLarge;\n      continue;\n    }\n\n    while (R - L > 1) {\n      const int M = (L + R) / 2;\n      if (TotalParity(M)) {\n        R = M;\n      } else {\n        L = M;\n      }\n    }\n    cout << R - kLarge << \"\\n\";\n    break;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n      \tw++;\n      \tif ((w & x.first) == w) { d ^= 1; }\n\t}\n  \tans.first *= 2; ans.second *= 2;\n\tif (!c&&!d) {\n\t\treturn ans;\n\t}\n\tans.first++; ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V vector\n#define L long\n#define W V<L>\nusing namespace std;L E=70,M=2e17,i,a,b;W S(V<W>p){if(!E)return{1,0};list<V<W>>T(2);for(W x:p){T[x[1]&1].insert({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].insert({x[0]/2,++x[1]/2});}for(L i;i<2;i++){L c=0;for(W x:T[!i])c^=(2*x[0]+x[1])%3+1;if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){cin>>i;V<W>p(i);while(i--,cin>>a>>b)p[i]={a+M,b+M};W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define W V<long long>\n#define L long long\n#define R(n) for(L i=0;i<n;i++)\nW S(V<W>&p,L E){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}V<W>c(4,W(3));c[3]=W(3,1);R(2){for(W x:T[i]){L Q=(2*x[0]+x[1])%3;c[i][Q]^=1;}}R(2){if(c[1-i]==c[2]||c[1-i]==c[3]){W ans=S(T[i],E-1);ans[0]*=2;ans[1]*=2;ans[1]+=i;return ans;}}for(W&v:p){v[0]++;}W A=S(p,E);A[0]--;return A;}\nint main(){L M=2e17;L n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}W Q=S(p,70);cout<<Q[0]-M<<\" \"<<Q[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n      \tint qc=2*x.first+x.second+1;\n\tqc = (qc & (0xffffffff)) + ((qc & (0x7fffffff00000000)) >> 32);\n\tqc = (qc & (0xffffffff)) + ((qc & (0x100000000)) >> 32);\n\tqc = (qc & (0xffff)) + ((qc & (0xffff0000)) >> 16);\n\tqc = (qc & (0xffff)) + ((qc & (0x10000)) >> 16);\n\tqc = (qc & (0xff)) + ((qc & (0xff00)) >> 8);\n\tqc = (qc & (0xff)) + ((qc & (0x100)) >> 8);\n\tqc = (qc & (0xf)) + ((qc & (0xf0)) >> 4);\n\tqc = (qc & (0xf)) + ((qc & (0x10)) >> 4);\n\tqc = (qc & 3) + ((qc & 12) >> 2);\n\tqc = (qc & 3) + ((qc & 4) >> 2);\n\t\tc ^= qc;\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"sse2,pclmul,tune=native\")\n#pragma GCC optimize(\"O3\")\n#include <ext/pb_ds/assoc_container.hpp>\n#include <nmmintrin.h>\n#include <emmintrin.h>\n#include <wmmintrin.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nusing GF = uint32_t;\n\ninline GF Add(GF a, GF b) {\n  return a ^ b;\n}\n\ninline GF Mul(GF a, GF b) {\n  __m128i xa = _mm_cvtsi64_si128(a), xb = _mm_cvtsi64_si128(b);\n  xa = _mm_clmulepi64_si128(xa, xb, 0x00);\n  uint64_t res = _mm_cvtsi128_si64(xa);\n  GF hi = res >> 32;\n  GF a0 = hi ^ (hi >> 25) ^ (hi >> 29) ^ (hi >> 30);\n  return (GF)res ^ a0 ^ (a0 << 2) ^ (a0 << 3) ^ (a0 << 7);\n}\n\nvector<GF> base;\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val);\nGF AddPositionsFrom(LL x, LL y, LL min_val);\n\nmap<pair<LL, LL>, GF> memo;\nGF AddPositions(LL x, LL y, int bb = 60) {\n  if (x == 0 && y == 0) { return 1; }\n  debug(\"?Any\", x, y);\n  \n  pair<LL, LL> p{x, y};\n  if (memo.count(p)) { return memo[p]; }\n\n  int bit = bb;\n  while ((1LL << bit) > x + y) { --bit; }\n  if (x >= (1LL << bit)) {\n    GF ans = Mul(base[bit], AddPositions(x ^ (1LL << bit), y));\n    debug(x, y, ans);\n    return memo[p] = ans;\n  }\n\n  // x < 2^bit <= x + y\n  GF answer1 = AddPositionsUpTo(x, y, (1LL << bit) - 1);\n  GF answer2 = AddPositionsFrom(x, y, (1LL << bit));\n  debug(x, y, answer1, answer2);\n  return memo[p] = Add(answer1, answer2);\n}\n\nGF GetValue(LL x) {\n  static map<LL, GF> val_memo;\n  auto it = val_memo.find(x);\n  if (it != val_memo.end()) { return it->nd; }\n\n  GF ans = 1;\n  for (int bit = 60; bit >= 0; --bit) {\n    if ((x >> bit) & 1) {\n      ans = Mul(base[bit], ans);\n    }\n  }\n  debug(\"Value\", x, ans);\n  return val_memo[x] = ans;\n}\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val) {\n  debug(\"?UpTo\", x, y, max_val);\n  if (x > max_val) { return 0; }\n  if (x + y <= max_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int bit = 60; bit >= 0; --bit) {\n    if (!((y >> bit) & 1)) { continue; }\n    const LL v = 1LL << bit;\n    y ^= v;\n\n    if (x + v - 1 <= max_val) {\n      debug(\"UpTo\", orig_x, orig_y, max_val, x, y);\n      answer = Add(answer, AddPositions(x, y));\n      x += v;\n    }\n  }\n  debug(answer);\n  if (x <= max_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF AddPositionsFrom(LL x, LL y, LL min_val) {\n  if (x + y < min_val) { return 0; }\n  if (x >= min_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int bit = 60; bit >= 0; --bit) {\n    if (!((y >> bit) & 1)) { continue; }\n    const LL v = 1LL << bit;\n    y ^= v;\n\n    if (x + v >= min_val) {\n      answer = Add(answer, AddPositions(x + v, y));\n    } else {\n      x += v;\n    }\n  }\n  debug(\"From\", orig_x, orig_y, min_val, answer, x);\n  if (x >= min_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF GetRandom() {\n  GF ans = 0;\n  for (int i = 0; i < 4; ++i) {\n    ans <<= 16;\n    ans |= (rand() % (1 << 16));\n  }\n  return ans;\n}\n\nint32_t main() {\n#ifndef LOCAL\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n#endif\n\n#ifdef TESTING\n  while (true) {\n    GF a = GetRandom(), b = GetRandom(), c = GetRandom();\n    GF d = Mul(a, Add(b, c));\n    GF e = Add(Mul(a, b), Mul(a, c));\n    debug(a,b,c,d,e);\n    assert(d == e);\n  }\n#endif\n\n  srand(2137);\n\n  const int S = 58;\n  const LL kLarge = 1LL << S;\n  for (int i = 0; i < 70; ++i) {\n    GF x = GetRandom();\n    base.PB(x);\n  }\n  debug(base);\n\n  int N;\n  cin >> N;\n  mini(N, 4000LL);\n  vector<pair<LL, LL>> values;\n\n  auto TotalGF = [&](LL bound) {\n    GF ans = 0;\n    for (auto &val : values) {\n      ans = Add(ans, AddPositionsUpTo(val.st, val.nd, bound));\n    }\n    debug(bound, ans);\n    return ans;\n  };\n\n  for (int i = 0; i < N; ++i) {\n    LL x, y;\n    cin >> x >> y;\n    values.emplace_back(x + kLarge, y + kLarge);\n  }\n\n  debug(values);\n\n  LL Lzero = 0, Rzero = (1LL << (S + 2));\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == 0) {\n      Lzero = midzero;\n    } else {\n      Rzero = midzero;\n    }\n  }\n\n  const LL first_x = Rzero - kLarge;\n  \n  Lzero = first_x + kLarge - 2; Rzero = (1LL << (S + 2));\n  const GF aim = TotalGF(Rzero);\n\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == aim) {\n      Rzero = midzero;\n    } else {\n      Lzero = midzero;\n    }\n  }\n\n  const LL last_x = Rzero - kLarge;\n\n  cout << first_x << \" \" << last_x - first_x - kLarge << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef __int128_t LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1e6+10;\nset<PLL>AA;\nPLL ker[SIZE];\n__int128_t bb=1LL<<35;\nint main(){\n    bb*=bb;\n    int N; R(N);\n    int rr=N;\n    REP(i,N){\n        long long x,y; scanf(\"%lld %lld\",&x,&y);\n        ker[i].F=x;\n        ker[i].S=y;\n        AA.insert(ker[i]);\n    }\n    REP(i,rr){\n        //W((long long)ker[i].F,(long long)ker[i].S);\n        if(!AA.count(ker[i]))continue;\n        for(LL two=bb;two>0;two>>=1){\n            if(AA.count({ker[i].F+two,ker[i].S})){\n                AA.erase({ker[i].F+two,ker[i].S});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F,ker[i].S+two};\n                AA.insert(nxt);\n                ker[rr++]=nxt;\n                break;\n            }\n            if(AA.count({ker[i].F-two,ker[i].S})){\n                AA.erase({ker[i].F-two,ker[i].S});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F-two,ker[i].S+two};\n                AA.insert(nxt);\n                ker[rr++]=nxt;\n                break;\n            }\n            if(AA.count({ker[i].F,ker[i].S+two})){\n                AA.erase({ker[i].F,ker[i].S+two});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F+two,ker[i].S};\n                AA.insert(nxt);\n                ker[rr++]=nxt;\n                break;\n            }\n            if(AA.count({ker[i].F,ker[i].S-two})){\n                AA.erase({ker[i].F,ker[i].S-two});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F+two,ker[i].S-two};\n                AA.insert(nxt);\n                ker[rr++]=nxt;\n                break;\n            }\n            if(AA.count({ker[i].F+two,ker[i].S-two})){\n                AA.erase({ker[i].F+two,ker[i].S-two});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F,ker[i].S-two};\n                AA.insert(nxt);\n                ker[rr++]=nxt;\n                break;\n            }\n            if(AA.count({ker[i].F-two,ker[i].S+two})){\n                AA.erase({ker[i].F-two,ker[i].S+two});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F-two,ker[i].S};\n                AA.insert(nxt);\n                ker[rr++]=nxt;\n                break;\n            }\n        }\n    }\n    printf(\"%lld %lld\\n\",(long long)(AA.begin()->F),(long long)(AA.begin()->S));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long long\n#define W V<L>\n#define R(n) for(L i=0;i<n;i++)\nW S(V<W>&p,L E){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=(Q+1);}if(!c){W A=S(T[i],E-1);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p,E);A[0]--;return A;}\nint main(){L M=2e17;L n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}W Q=S(p,70);cout<<Q[0]-M<<\" \"<<Q[1]-M;}"
  },
  {
    "language": "C++",
    "code": "%:pragma GCC optimize(\"Ofast\", \"inline\")\n#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\n  using namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\n#define int long long\nconst int N = 1e5 + 233;\nint inf = 1e17;\nint n, x[N], y[N], qy, ni[N];\nbool dp[65][2][3];\n\ninline bool get(int u, int n, int r) {\n  memset(dp, 0, sizeof dp);\n  int l = n - y[u];\n  l = min(l, ni[u]);\n  r = ((r - y[u]) % 3 + 3) % 3;\n  if (l < 0) return 0;\n  // o \\in[0, l] && o % 3 == r ni[u]Co module 2\n  // cout << l << \" \" << ni[u] << \" \" << r << \"\\n\";\n  dp[0][1][0] = 1; int cur = 0;\n  for (int i = 61; i >= 0; i--) {\n    ++cur;\n    for (int d = 0; d < 2; d++) {\n      for (int pr = 0; pr < 3; pr++) {\n\tint lim = d ? l >> i & 1 : 1;\n\tfor (int ch = 0; ch <= min(ni[u] >> i & 1, lim); ch++) {\n\t  int nd = d && ch == lim;\n\t  int nv = pr + (i & 1 ? -1 : 1) * ch;\n\t  nv = (nv % 3 + 3) % 3;\n\t  // if (i == 2 && d == 1 && pr == 0) {\n\t  //   cout << ch << \" \" << nd << \" \" << nv << \"\\n\";\n\t  // }\n\t  dp[cur][nd][nv] ^= dp[cur - 1][d][pr];\n\t}\n      }\n    }\n  }\n  int ans = 0;\n  for (int d = 0; d < 2; d++)\n    ans ^= dp[cur][d][r];\n  return ans;\n}\n\ninline bool calc(int l, int r, int remain) {\n  bool ans = 0;\n  rep (i, n) {\n    ans ^= get(i, r, remain) ^ get(i, l - 1, remain);\n    // cout << i << \" \" << get(i, r, remain) << \" \" <<  get(i, l - 1, remain) << \"\\n\";\n  }\n  return ans;\n}\n\nsigned main(void) {\n  srand(20021214);\n  read(n);\n  rep (i, n) {\n    read(x[i]), read(y[i]);\n    y[i] += inf;\n    // mi_i = o - y_i\n  }\n  // cout << get(1, 4, 1) << \"\\n\";\n  // return 0;\n  // cout << calc(-4, 4, 1) << \"\\n\";\n  // return 0;\n  int tr = 0;\n  while (!tr) {\n    // inf += rand() % 3;\n    rep (i, n) ni[i] = x[i] + inf;\n    re0 (r, 3) if (calc(-inf, inf, r) == true) {\n      tr = r;\n      break;\n    }\n  }\n  assert(calc(-inf, inf, tr) == true);\n  \n  int l = -inf, r = inf;\n  while (l < r) {\n    int mid = l + (r - l) / 2;\n    if (calc(l, mid, tr)) r = mid;\n    else l = mid + 1;\n  }\n  qy = r;\n  \n  auto isBlack = [&](int o) {\n    bool pa = 0;\n    rep (i, n) if (y[i] <= o && o <= x[i] + y[i] + inf) {\n      int nc = x[i] + inf;\n      int mc = o - y[i];\n      pa ^= nc == (nc | mc);\n    }\n    return pa;\n  };\n  assert(isBlack(qy) == true);\n  // cout << qy << \"\\n\";\n  int ty = qy, ansl, ansr;\n  \n  for (int k = 61; k >= 0; k--) {\n    if (isBlack(qy + (1ll << k))) {\n      qy += 1ll << k;\n    }\n  }\n  ansr = qy;\n  \n  qy = ty;\n  for (int k = 61; k >= 0; k--) {\n    if (isBlack(qy - (1ll << k))) {\n      qy -= 1ll << k;\n    }\n  }\n  ansl = qy;\n\n  cout << -inf + ansr - ansl << \" \" << ansl - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V vector\n#define L long\n#define W V<L>\nusing namespace std;L E=70,M=2e17,i,a,b;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].push_back({x[0]/2,++x[1]/2});}for(L i;i<2;i++){a=0;for(W x:T[!i])a^=(2*x[0]+x[1])%3+1;if(!a){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){cin>>i;V<W>p(i);while(i--,cin>>a>>b)p[i]={a+M,b+M};W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long long\n#define W V<L>\n#define R(n) for(L i=0;i<n;i++)\nW S(V<W>&p,L E){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=(Q+1);}if(!c){W ans=S(T[i],E-1);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p,E);A[0]--;return A;}\nint main(){L M=2e17;L n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}W Q=S(p,70);cout<<Q[0]-M<<\" \"<<Q[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\treturn solve(qab[sz&1],ex-1);\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V vector\n#define L long\n#define W V<L>\nusing namespace std;L E=70,M=2e17,i,a,b;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].push_back({x[0]/2,++x[1]/2});}for(L i;i<2;i++){L c=0;for(W x:T[!i])c^=(2*x[0]+x[1])%3+1;if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){cin>>i;V<W>p(i);while(i--,cin>>a>>b)p[i]={a+M,b+M};W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MP make_pair\n#define PB push_back\n#define int long long\n#define st first\n#define nd second\n#define rd third\n#define FOR(i, a, b) for(int i =(a); i <=(b); ++i)\n#define RE(i, n) FOR(i, 1, n)\n#define FORD(i, a, b) for(int i = (a); i >= (b); --i)\n#define REP(i, n) for(int i = 0;i <(n); ++i)\n#define VAR(v, i) __typeof(i) v=(i)\n#define FORE(i, c) for(VAR(i, (c).begin()); i != (c).end(); ++i)\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n#define __builtin_ctz __builtin_ctzll\n#define __builtin_clz __builtin_clzll\n#define __builtin_popcount __builtin_popcountll\nusing namespace std;\ntemplate<typename TH> void _dbg(const char* sdbg, TH h) { cerr<<sdbg<<\"=\"<<h<<\"\\n\"; }\ntemplate<typename TH, typename... TA> void _dbg(const char* sdbg, TH h, TA... t) {\n  while(*sdbg != ',') { cerr<<*sdbg++; } cerr<<\"=\"<<h<<\",\"; _dbg(sdbg+1, t...);\n}\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#define debugv(x) {{cerr <<#x <<\" = \"; FORE(itt, (x)) cerr <<*itt <<\", \"; cerr <<\"\\n\"; }}\n#else\n#define debug(...) (__VA_ARGS__)\n#define debugv(x)\n#define cerr if(0)cout\n#endif\n#define next ____next\n#define prev ____prev\n#define left ____left\n#define hash ____hash\ntypedef long long ll;\ntypedef long double LD;\ntypedef pair<int, int> PII;\ntypedef pair<ll, ll> PLL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VLL;\ntypedef vector<pair<int, int> > VPII;\ntypedef vector<pair<ll, ll> > VPLL;\n\ntemplate<class C> void mini(C&a4, C b4){a4=min(a4, b4); }\ntemplate<class C> void maxi(C&a4, C b4){a4=max(a4, b4); }\ntemplate<class T1, class T2>\nostream& operator<< (ostream &out, pair<T1, T2> pair) { return out << \"(\" << pair.first << \", \" << pair.second << \")\";}\ntemplate<class A, class B, class C> struct Triple { A first; B second; C third;\n  bool operator<(const Triple& t) const { if (st != t.st) return st < t.st; if (nd != t.nd) return nd < t.nd; return rd < t.rd; } };\ntemplate<class T> void ResizeVec(T&, vector<int>) {}\ntemplate<class T> void ResizeVec(vector<T>& vec, vector<int> sz) {\n  vec.resize(sz[0]); sz.erase(sz.begin()); if (sz.empty()) { return; }\n  for (T& v : vec) { ResizeVec(v, sz); }\n}\ntypedef Triple<int, int, int> TIII;\ntemplate<class A, class B, class C>\nostream& operator<< (ostream &out, Triple<A, B, C> t) { return out << \"(\" << t.st << \", \" << t.nd << \", \" << t.rd << \")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, vector<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class T> ostream& operator<<(ostream& out, set<T> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\ntemplate<class L, class R> ostream& operator<<(ostream& out, map<L, R> vec) { out<<\"(\"; for (auto& v: vec) out<<v<<\", \"; return out<<\")\"; }\n\nVPII lamps;\n//int C;\nint kInf = 4e17;\nVI Xor(VI L, VI R) {\n  REP (tr, SZ(L)) {\n    L[tr] ^= R[tr];\n  }\n  return L;\n}\nVI Shift(VI heh, int shift) {\n  VI dupa(SZ(heh));\n  REP (i, SZ(heh)) {\n    dupa[(i + shift) % SZ(heh)] = heh[i];\n  }\n  return dupa;\n}\nVI CountLamps1(int e, int x, int y) {\n  debug(kInf, e, x, y);\n  int d = kInf - x - y;\n  if (e < y) {\n    return {0, 0, 0};\n  }\n  VI bits;\n  REP (bit, 60) {\n    if (d & (1ll << bit)) {\n      bits.PB(1);\n    } else {\n      bits.PB(0);\n    }\n  }\n  vector<VI> prefs;\n  prefs.PB({1, 0, 0});\n  REP (bit, 60) {\n    if (!bits[bit]) {\n      prefs.PB(prefs.back());\n    } else if (bit % 2) {\n      prefs.PB(Xor(prefs.back(), Shift(prefs.back(), 2)));\n    } else {\n      prefs.PB(Xor(prefs.back(), Shift(prefs.back(), 1)));\n    }\n  }\n  int maxY = kInf - x;\n  if (e >= maxY) { return prefs.back(); }\n  int shift = 0;\n  int how_many = e - y + 1;\n  debug(how_many);\n  VI so_far{0, 0, 0};\n  FORD (bit, 59, 0) {\n    if (how_many & (1ll << bit)) {\n      debug(prefs[bit], shift % 3);\n      so_far = Xor(so_far, Shift(prefs[bit], shift % 3));\n      \n      if (bits[bit]) {\n        shift += (1ll << bit);\n      } else {\n        break;\n      }\n    }\n  }\n  return so_far;\n}\nVI CountLampsAll(int e) {\n  VI hehs{0, 0, 0};\n  for (auto lamp : lamps) {\n    VI lul = CountLamps1(e, lamp.st, lamp.nd);\n    hehs = Xor(hehs, lul);\n  }\n  return hehs;\n}\nVI CountLampsAll(int b, int e) {\n  return Xor(CountLampsAll(e), CountLampsAll(b - 1));\n}\nint32_t main() {\n\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(10);\n  cerr << fixed << setprecision(10);\n  cin.tie(0);\n  //double beg_clock = 1.0 * clock() / CLOCKS_PER_SEC;\n\n//   kInf = 1;\n//   debug(CountLamps1(1, 0, 0));\n  kInf = 5;\n  //debug(CountLamps1(5, 0, 0));\n  debug(CountLamps1(4, 0, 0));\n//   debug(CountLamps1(3, 0, 0));\n//   kInf = 6;\n//   debug(CountLamps1(6, 0, 0));\n//   debug(CountLamps1(5, 0, 0));\n//   debug(CountLamps1(4, 0, 0));\n  \n  \n  \n  int n;\n  cin>>n;\n  RE (i, n) {\n    int x, y;\n    cin>>x>>y;\n    //maxi(C, x + y);\n    lamps.PB({x, y});\n  }\n  VI hehs = CountLampsAll(kInf);\n  int r;\n  REP (tr, 3) {\n    if (hehs[tr]) { r = tr; }\n  }\n  int kl = -kInf, kp = kInf;\n  while (kl <= kp) {\n    if (kl == kp) { break; }\n    int aktc = (kl + kp) / 2;\n    if (CountLampsAll(kl, aktc)[r]) {\n      kp = aktc;\n    } else {\n      kl = aktc + 1;\n    }\n  }\n  int L = kl, R = kl;\n  VI zeros{0, 0, 0};\n  REP (bit, 60) {\n    int candL = L - (1ll << bit);\n    if (CountLampsAll(candL, candL) != zeros) {\n      L = candL;\n    }\n    int candR = R + (1ll << bit);\n    if (CountLampsAll(candR, candR) != zeros) {\n      R = candR;\n    }\n  }\n  // R to maxy, L to miny\n  int X = kInf - R;\n  int Y = L;\n  cout<<X<<\" \"<<Y<<endl;\n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define N 10020\n#define MAX 100000000000000005ll\n// #define MAX 3\n\nusing namespace std;\n\nint n;\nlong long X[N], Y[N];\n\nint first_test() {\n\tstatic int f[64][3];\n\tstatic int ans[3];\n\tmemset(ans, 0, sizeof(ans));\n\tfor (int t = 1; t <= n; ++t) {\n\t\tlong long x = X[t], y = Y[t];\n\t\tmemset(f, 0, sizeof(f));\n\t\tf[61][x % 3] = 1;\n\t\tfor (int k = 60; k >= 0; --k) {\n\t\t\tfor (int i = 0; i < 3; ++i) (f[k][i] += f[k + 1][i]) %= 2;\n\t\t\tif (y >> k & 1) {\n\t\t\t\tfor (int i = 0; i < 3; ++i)\n\t\t\t\t\t(f[k][(i + (k & 1 ? 2 : 1)) % 3] += f[k + 1][i]) %= 2;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 3; ++i) ans[i] = (ans[i] + f[0][i]) % 2;\n\t}\n\tfor (int i = 0; i < 3; ++i) if (ans[i]) return i;\n}\n\nint second_test(long long xx, int r) {\n\tstatic int f[64][2][3];\n\tstatic int ans[3];\n\tmemset(ans, 0, sizeof(ans));\n\tfor (int t = 1; t <= n; ++t) {\n\t\tlong long x = xx - X[t], y = Y[t];\n\t\tif (x < 0) continue;\n\t\tmemset(f, 0, sizeof(f));\n\t\tf[61][1][X[t] % 3] = 1;\n\t\tfor (int k = 60; k >= 0; --k) {\n\t\t\tfor (int i = 0; i < 3; ++i) \n\t\t\t\t(f[k][(x >> k & 1) == 0][i] += f[k + 1][1][i]) %= 2;\n\t\t\tif ((y >> k & 1) && (x >> k & 1)) {\n\t\t\t\tfor (int i = 0; i < 3; ++i) \n\t\t\t\t\t(f[k][1][(i + (k & 1 ? 2 : 1)) % 3] += f[k + 1][1][i]) %= 2;\n\t\t\t}\n\t\t\tfor (int i = 0; i < 3; ++i) (f[k][0][i] += f[k + 1][0][i]) %= 2;\n\t\t\tif (y >> k & 1) {\n\t\t\t\tfor (int i = 0; i < 3; ++i) \n\t\t\t\t\t(f[k][0][(i + (k & 1 ? 2 : 1)) % 3] += f[k + 1][0][i]) %= 2;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < 3; ++i) ans[i] = (ans[i] + f[0][0][i] + f[0][1][i]) % 2;\n\t}\n\treturn ans[r];\n}\n\nint second_test(long long x, long long y, int r) {\n\treturn second_test(y, r) ^ second_test(x - 1, r);\n}\n\nint single_test(long long xx) {\n\tint ans = 0;\n\tfor (int i = 1; i <= n; ++i) {\n\t\tlong long x = xx - X[i], y = Y[i];\n\t\tif (x < 0) continue;\n\t\tif ((x | y) == y) ans ^= 1;\n\t}\n\treturn ans;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 1; i <= n; ++i) scanf(\"%lld%lld\", &X[i], &Y[i]);\n\tfor (int i = 1; i <= n; ++i) X[i] += MAX, Y[i] += MAX;\n\tint r = first_test();\n\tlong long w = 0;\n\tfor (int k = 60; k >= 0; --k) {\n\t\tint t1 = second_test(w, w + (1ll << k) - 1, r);\n\t\tint t2 = second_test(w + (1ll << k), w + (1ll << (k + 1)) - 1, r);\n\t\tassert(t1 != t2);\n\t\tif (t1 == 0) w += 1ll << k;\n\t}\n\tlong long x = w, y = w;\n\tfor (int k = 60; k >= 0; --k) {\n\t\tif (single_test(x - (1ll << k))) x -= 1ll << k;\n\t\tif (single_test(y + (1ll << k))) y += 1ll << k;\n\t}\n\ty -= x;\n\tx -= MAX; y -= MAX;\n\tprintf(\"%lld %lld\\n\", x, y);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  qab[0].reserve(10000);\n  qab[1].reserve(10000);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\tV<V<bool>> c(2, V<bool>(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc+1)%2) { c[i][0]^=true; }\n\t\t\tif (qc) { c[i][1]^=true; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0]&&!c[1-i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1, 0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc + 1) % 2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0] && !c[1 - i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor (pin& v : ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\",&n)\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld,%lld\",&a,&b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"sse2,pclmul,tune=native\")\n#pragma GCC optimize(\"O3\")\n#include <ext/pb_ds/assoc_container.hpp>\n#include <nmmintrin.h>\n#include <emmintrin.h>\n#include <wmmintrin.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nusing GF = uint32_t;\n\ninline GF Add(GF a, GF b) {\n  return a ^ b;\n}\n\ninline GF Mul(GF a, GF b) {\n  __m128i xa = _mm_cvtsi64_si128(a), xb = _mm_cvtsi64_si128(b);\n  xa = _mm_clmulepi64_si128(xa, xb, 0x00);\n  uint64_t res = _mm_cvtsi128_si64(xa);\n  GF hi = res >> 32;\n  GF a0 = hi ^ (hi >> 25) ^ (hi >> 29) ^ (hi >> 30);\n  return (GF)res ^ a0 ^ (a0 << 2) ^ (a0 << 3) ^ (a0 << 7);\n}\n\nvector<GF> base;\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val);\nGF AddPositionsFrom(LL x, LL y, LL min_val);\n\nconst int MemoSize = 1 << 24;\n\npair<LL, LL> other_hash[MemoSize];\nGF memo[MemoSize];\n\nuint64_t Hash1(const pair<LL, LL> &p) {\nusing U = uint64_t;\n  uint64_t y = ((U)p.st * 0x123456789ABCDEFLL) ^ ((U)p.nd * 0xFEDCBA987654321LL);\n  return y ^ ((((U)p.st >> 32) * 0x019428711LL) + (((U)p.nd >> 24) * 0x593285392LL));\n}\n\n/*uint64_t Hash2(const pair<LL, LL> &p) {\n  return p.st + p.nd + (p.st ^ p.nd) + 17;\n}*/\n\nbool FindVal(const pair<LL, LL> &p, GF &ans) {\n  constexpr uint64_t kMask = MemoSize - 1;\n  auto h1 = Hash1(p) & kMask; //, h2 = Hash2(p);\n  for (int i = 0; other_hash[h1] != pair<LL, LL>{0, 0} && other_hash[h1] != p; ++i) {\n    h1 = (h1 + i) & kMask;\n  }\n  if (other_hash[h1] == p) {\n    ans = memo[h1];\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid PutVal(const pair<LL, LL> &p, const GF val) {\n  constexpr uint64_t kMask = MemoSize - 1;\n  auto h1 = Hash1(p) & kMask; //, h2 = Hash2(p);\n  for (int i = 0; other_hash[h1] != pair<LL, LL>{0, 0}; ++i) {\n    h1 = (h1 + i) & kMask;\n  }\n  other_hash[h1] = p; //h2;\n  memo[h1] = val;\n}\n\n//map<pair<LL, LL>, GF> memo;\nGF AddPositions(LL x, LL y, int bb = 60) {\n  if (x == 0 && y == 0) { return 1; }\n  debug(\"?Any\", x, y);\n  \n  pair<LL, LL> p{x, y};\n  {\n    GF ans;\n    if (FindVal(p, ans)) { return ans; }\n  }\n\n  int bit = 63 - __builtin_clzll(x + y);\n  while ((1LL << bit) > x + y) { --bit; }\n  if (x >= (1LL << bit)) {\n    GF ans = Mul(base[bit], AddPositions(x ^ (1LL << bit), y));\n    debug(x, y, ans);\n    PutVal(p, ans);\n    return ans;\n  }\n\n  // x < 2^bit <= x + y\n  GF answer1 = AddPositionsUpTo(x, y, (1LL << bit) - 1);\n  GF answer2 = AddPositionsFrom(x, y, (1LL << bit));\n  debug(x, y, answer1, answer2);\n  answer1 = Add(answer1, answer2);\n  PutVal(p, answer1);\n  return answer1;\n}\n\nGF GetValue(LL x) {\n  if (!x) { return 1; }\n  static map<LL, GF> val_memo;\n  auto it = val_memo.find(x);\n  if (it != val_memo.end()) { return it->nd; }\n\n  GF ans = 1;\n  for (int bit = 63 - __builtin_clzll(x); bit >= 0; --bit) {\n    if ((x >> bit) & 1) {\n      ans = Mul(base[bit], ans);\n    }\n  }\n  debug(\"Value\", x, ans);\n  return val_memo[x] = ans;\n}\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val) {\n  debug(\"?UpTo\", x, y, max_val);\n  if (x > max_val) { return 0; }\n  if (x + y <= max_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int a = ((63 - __builtin_clzll(y)) >> 3) << 3; a >= 0; a -= 8) {\n    if (!((y >> a) & 0xff)) { continue; }\n    for (int bit = a + 7; bit >= a; --bit) {\n      if (!((y >> bit) & 1)) { continue; }\n      const LL v = 1LL << bit;\n      y ^= v;\n\n      if (x + v - 1 <= max_val) {\n        debug(\"UpTo\", orig_x, orig_y, max_val, x, y);\n        answer = Add(answer, AddPositions(x, y));\n        x += v;\n      }\n    }\n  }\n  /*for (int bit = 60; bit >= 0; --bit) {\n  }*/\n  debug(answer);\n  if (x <= max_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF AddPositionsFrom(LL x, LL y, LL min_val) {\n  if (x + y < min_val) { return 0; }\n  if (x >= min_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int bit = 63 - __builtin_clzll(y); bit >= 0; --bit) {\n    if (!((y >> bit) & 1)) { continue; }\n    const LL v = 1LL << bit;\n    y ^= v;\n\n    if (x + v >= min_val) {\n      answer = Add(answer, AddPositions(x + v, y));\n    } else {\n      x += v;\n    }\n  }\n  debug(\"From\", orig_x, orig_y, min_val, answer, x);\n  if (x >= min_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF GetRandom() {\n  GF ans = 0;\n  for (int i = 0; i < 4; ++i) {\n    ans <<= 16;\n    ans |= (rand() % (1 << 16));\n  }\n  return ans;\n}\n\nint32_t main() {\n#ifndef LOCAL\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n#endif\n\n#ifdef TESTING\n  while (true) {\n    GF a = GetRandom(), b = GetRandom(), c = GetRandom();\n    GF d = Mul(a, Add(b, c));\n    GF e = Add(Mul(a, b), Mul(a, c));\n    debug(a,b,c,d,e);\n    assert(d == e);\n  }\n#endif\n\n  srand(2137);\n\n#warning\n  const int S = 58;\n//  const int S = 58;\n  const LL kLarge = 1LL << S;\n  for (int i = 0; i < 70; ++i) {\n    GF x = GetRandom();\n    base.PB(x);\n  }\n  debug(base);\n\n  int N;\n  cin >> N;\n  mini(N, 7500LL);\n  vector<pair<LL, LL>> values;\n\n  auto TotalGF = [&](LL bound) {\n    GF ans = 0;\n    for (auto &val : values) {\n      ans = Add(ans, AddPositionsUpTo(val.st, val.nd, bound));\n    }\n    debug(bound, ans);\n    return ans;\n  };\n\n  for (int i = 0; i < N; ++i) {\n    LL x, y;\n    cin >> x >> y;\n    values.emplace_back(x + kLarge, y + kLarge);\n  }\n\n  debug(values);\n\n  LL Lzero = 0, Rzero = (1LL << (S + 2));\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == 0) {\n      Lzero = midzero;\n    } else {\n      Rzero = midzero;\n    }\n  }\n\n  const LL first_x = Rzero - kLarge;\n  \n  Lzero = 0; Rzero = (1LL << (S + 2));\n  const GF aim = TotalGF(Rzero);\n\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == aim) {\n      Rzero = midzero;\n    } else {\n      Lzero = midzero;\n    }\n  }\n\n  const LL last_x = Rzero - kLarge;\n\n  cout << first_x << \" \" << last_x - first_x - kLarge << \"\\n\";\n  //cout << memo.size() << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70,M=2e17,i,a,b;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[(x[1])&1].push_back({x[0]/2,++x[1]/2});}for(L i;i<2;i++){L c=0;for(W x:T[!i])c^=(2*x[0]+x[1])%3+1;if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){cin>>i;V<W>p(i);while(i--,cin>>a>>b)p[i]={a+M,b+M};W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n//template\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(a);i>(b);i--)\n#define ALL(v) (v).begin(),(v).end()\ntypedef long long int ll;\nconst int inf = 0x3fffffff; const ll INF = 0x1fffffffffffffff; const double eps=1e-12;\nvoid tostr(ll x,string& res){while(x)res+=('0'+(x%10)),x/=10; reverse(ALL(res)); return;}\ntemplate<class T> inline bool chmax(T& a,T b){ if(a<b){a=b;return 1;}return 0; }\ntemplate<class T> inline bool chmin(T& a,T b){ if(a>b){a=b;return 1;}return 0; }\n//end\n\nconstexpr ll c=300'000'000'000'000'000LL;\nint n; ll x[11000],y[11000];\nbool que(ll n,ll r){if(n<0||r<0||n<r)return 0; return (n&r)==r;}\nbool col(ll a){\n   bool res=0; rep(i,0,n)if(a>=x[i])res^=que(c-x[i]-y[i],a-x[i]); return res;\n}\nll cnt[3];\nvoid calc(ll n,ll t){\n   if(t<0){rep(i,0,3)cnt[i]=0; return;}\n   chmin(t,n); ll dp[64][3][2]={}; dp[60][0][1]=1;\n   rrep(i,59,-1)rep(j,0,3)rep(k,0,2)if(dp[i+1][j][k]){\n      rep(nxt,0,2){\n         if((n>>i&1)==0&&nxt)continue;\n         if(k&&nxt&&(t>>i&1)==0)continue;\n         int nj=(j+(nxt?(i&1?2:1):0))%3,nk=k;\n         if(nxt==0&&(t>>i&1))nk=0;\n         dp[i][nj][nk]+=dp[i+1][j][k];\n      }\n   }\n   rep(i,0,3)cnt[i]=dp[0][i][0]+dp[0][i][1];\n}\nll rng(ll n,ll lb,ll rb,int r){calc(n,rb); ll res=cnt[r]; calc(n,lb); res-=cnt[r]; return res;}\nbool flag(ll lb,ll rb,int r){\n   bool res=0; rep(i,0,n)res^=rng(c-x[i]-y[i],lb-x[i],rb-x[i],(x[i]*2+r)%3)&1; return res;\n}\n\n//reference:https://physics0523.hatenablog.com/entry/2019/02/26/190724\nint main(){\n   scanf(\"%d\",&n); rep(i,0,n)scanf(\"%lld%lld\",&x[i],&y[i]);\n   ll lb=-c/2,rb=c/2; int r=-1;\n   rep(i,0,3)if(flag(lb,rb,i)){r=i; break;}\n   while(rb-lb>1){\n      ll mid=(lb+rb)>>1;\n      if(flag(lb,mid,r))rb=mid; else lb=mid;\n   }\n   assert(col(lb));\n   ll x1=lb,x2=lb;\n   rrep(k,62,-1){\n      if(col(x1-(1LL<<k)))x1-=1LL<<k;\n      if(col(x2+(1LL<<k)))x2+=1LL<<k;\n   }\n   printf(\"%lld %lld\\n\",x1,c-x2);\n   return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V vector\n#define W V<long>\nusing namespace std;long E,M=2e17,a,b;W A;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].push_back({x[0]/2,++x[1]/2});}for(long i;i<2;i++){a=0;for(W x:T[!i])a^=(2*x[0]+x[1])%3+1;if(!a){E--;A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;A=S(p);A[0]--;return A;}int main(){cin>>E;V<W>p(E);while(E--,cin>>a>>b)p[E]={a+M,b+M};E=70;W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = 2 * x.first + x.second + 1;\n\tqc = (qc & (0xffffffff)) + ((qc & (0x7fffffff00000000)) >> 32);//qc<=1ffffffff\n\tqc = (qc & (0xffff)) + ((qc & (0x1ffff0000)) >> 16);//qc<=2ffff\n\tqc = (qc & (0xff)) + ((qc & (0x3ff00)) >> 8);//qc<=3ff\n\tqc = (qc & (0xf)) + ((qc & (0x3f0)) >> 4);//qc<=4e\n\tqc = (qc & (0xf)) + ((qc & (0x7e)) >> 4);//qc<=18\n\tqc = (qc & 3) + ((qc & 28) >> 2);\n\tqc = (qc & 3) + ((qc & 4) >> 2);\n\t\tc ^= qc;\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t\tw++;\n\t\tif ((w & x.first) == w) { d ^= 1; }\n\t}\n\tans.first *= 2; ans.second *= 2;\n\tans.first += (c | d); ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n      \tw++;\n      \tif ((w & x.first) == w) { d ^= 1; }\n\t}\n  \tans.first *= 2; ans.second *= 2;\n\tans.first+=(c|d); ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define x first\n#define y second\n#define mp make_pair\n#define pb push_back\n\ntypedef long long ll;\n\nconst ll MOD = 1e9+7;\nconst ll INF = 1e9+5;\n\nmap <ll, int> X, Y;\n\nint main() {\n\tint n;\n\tscanf(\"%d\", &n);\n\tfor (int i=0 ; i<n ; i++) {\n\t\tll x, y;\n\t\tscanf(\"%lld%lld\", &x, &y);\n\t\tX[x]++;\n\t\tY[y]++;\n\t}\n\tll solx, soly;\n\tfor (auto &x:X) {\n\t\tif (x.y % 2) {\n\t\t\tsolx = x.x;\n\t\t\tbreak;\n\t\t}\n\t\tX[x.x+1] += (x.y)/2;\n\t}\n\tfor (auto &y:Y) {\n\t\tif (y.y % 2) {\n\t\t\tsoly = y.x;\n\t\t\tbreak;\n\t\t}\n\t\tY[y.x+1] += (y.y)/2;\n\t}\n\tprintf(\"%lld %lld\\n\", solx, soly);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nconst LL ShiftAll = 1.5e17;\n\n/*LL GetXorPositions(LL x, LL y) {\n  if (!y) { return x; }\n  if (!(y & (y - 1))) { return x ^ (x + y); }\n\n  int low_bit = 0;\n  while (!((y >> low_bit) & 1)) { ++low_bit; }\n\n  LL answer = 0;\n  for (int bit = 0; bit < 60; ++bit) {\n    if ((y >> bit) & 1) { continue; }\n    if ((1LL << bit) <= y) { continue; }\n\n    LL overflow_bound = (1LL << bit) - (x & ((1LL << bit) - 1));\n    LL my_y = 0;\n    //debug(bit, overflow_bound, low_bit);\n    bool fail = false;\n    for (int b = bit - 1; b > low_bit; --b) {\n      bool ov_bit = ((overflow_bound >> b) & 1);\n      bool y_bit = ((y >> b) & 1);\n      if (ov_bit && !y_bit) { fail = true; break; }\n      my_y |= ((LL)ov_bit << b);\n    }\n\n    int num_over = (my_y >= overflow_bound);\n    num_over += ((my_y ^ (1LL << low_bit)) >= overflow_bound);\n    if (!fail && num_over == 1) {\n      answer += 1LL << bit;\n    }\n  }\n  return answer;\n}\n\nLL BruteXorPositions(LL x, LL y) {\n  LL ans = 0;\n  for (LL i = 0; i <= y; ++i) {\n    if ((y & i) == i) {\n      ans ^= (x + i);\n    }\n  }\n  return ans;\n}*/\n\nusing GF = uint64_t;\n\ninline GF Add(GF a, GF b) {\n  return a ^ b;\n}\n\ninline GF Mul(GF a, GF b) {\n  const GF kBase = 0x000000000000001B;\n  __uint128_t mul = (__uint128_t)a * b;\n  for (int i = 63; i >= 0; --i) {\n    if ((mul >> (i + 64)) & 1) {\n      mul ^= (__uint128_t)kBase << i;\n    }\n  }\n  return (GF)mul;\n}\n\nvector<GF> base;\n\n\nbool ParityXorNotExceeding(LL x, LL y, LL max_val) {\n  if (x > max_val) { return 0; }\n\n  int low_bit = 0;\n  while (!((y >> low_bit) & 1)) { ++low_bit; }\n\n  max_val -= x;\n  for (int bit = 60; bit > low_bit; --bit) {\n    bool max_bit = ((max_val >> bit) & 1);\n    bool y_bit = ((y >> bit) & 1);\n    if (max_bit && !y_bit) {\n      return false;\n    }\n  }\n\n  return !((max_val >> low_bit) & 1);\n}\n\nint32_t main() {\n#ifndef LOCAL\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n#endif\n\n  /*LL x, y, m;\n  while (cin >> x >> y >> m) {\n    cout << ParityXorNotExceeding(x, y, m) << \"\\n\";\n  }\n  return 0;*/\n\n  const LL kLarge = 1LL << 58;\n\n  int N;\n  cin >> N;\n  vector<pair<LL, LL>> values;\n\n  auto TotalParity = [&](LL bound) {\n    bool ans = false;\n    for (auto &val : values) {\n      ans ^= ParityXorNotExceeding(val.st, val.nd, bound);\n    }\n    return ans;\n  };\n\n  for (int i = 0; i < N; ++i) {\n    LL x, y;\n    cin >> x >> y;\n    values.emplace_back(x + kLarge, y + kLarge * 2);\n  }\n\n  LL L = 0;\n  while (true) {\n    LL R = L + kLarge;\n    if (!TotalParity(R)) {\n      L += kLarge;\n      continue;\n    }\n\n    while (R - L > 1) {\n      const int M = (L + R) / 2;\n      if (TotalParity(M)) {\n        R = M;\n      } else {\n        L = M;\n      }\n    }\n    cout << R - kLarge << \"\\n\";\n    break;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  qab[0].reserve(10000);\n  qab[1].reserve(10000);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\tV<V<bool>> c(2, V<bool>(2,false));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc+1)%2) { c[i][0]=!c[i][0]; }\n\t\t\tif (qc) { c[i][1]!=c[i][1]; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0]&&!c[1-i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\nvel solve(V<vel>& ab, int ex) {\n\tif (ex == 0) { return { 1, 0 }; }\n\tV<V<vel>> qab(2);\n\tfor (vel x : ab) {\n\t\tqab[x[1] & 1].push_back({ x[0] / 2,x[1] / 2 });\n\t\tif (x[0] & 1) { qab[(x[1] + 1) & 1].push_back({ x[0] / 2,(x[1] + 1) / 2 }); }\n\t}\n\tV<vel> c(3,vel(2));\n\trep(i, 2) {\n\t\tfor (vel x : qab[i]) {\n\t\t\tint qc = (3 - x[0] + x[1]) % 3; qc = (qc + 3) % 3;\n\t\t\tif (qc==0) { c[i][0] ^= 1; }\n\t\t\tif (qc==1) { c[i][1] ^= 1; }\n\t\t\tif (qc == 2) { c[i][0] ^= 1; c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (c[1-i] == c[2]) {\n\t\t\tvel ans = solve(qab[i], ex - 1);\n\t\t\tans[0] *= 2; ans[1] *= 2; ans[1] += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\trep(i, ab.size()) { ab[i][0]++; }\n\tvel ans = solve(ab, ex); ans[0]--;\n\treturn ans;\n}\nsigned main() {\n\tint inf = 2e17;\n\tint n; cin >> n;\n\tV<vel> ab(n);\n\trep(i, n) {\n\t\tint a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tvel ret = solve(ab, 70);\n\tcout << ret[0] - inf << \" \" << ret[1] - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvector<ii> vec;\n\nint color(ll x, ll y)\n{\n\tint ans=0;\n\tint n=vec.size();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll x2=vec[i].fi; ll y2=vec[i].se;\n\t\tll d = x-x2;\n\t\tll h = y2-y;\n\t\tif(d<0||d>h) continue;\n\t\tif((d&h)==d) ans^=1;\n\t}\n\treturn ans;\n}\n\nconst ll C = -ll(1e18);\nint md[63];\n\nll getbelow(ll r, int mod)\n{\n\tint res[3]; memset(res,0,sizeof(res));\n\tfor(ii pt:vec)\n\t{\n\t\tll x=pt.fi; ll y=pt.se;\n\t\tif(x>r) continue;\n\t\tll mx = r-x;\n\t\tint dp[2][3];\n\t\tmemset(dp,0,sizeof(dp));\n\t\tint xmod=x%3;\n\t\tif(xmod<0) xmod+=3;\n\t\tdp[1][0]=1;\n\t\tfor(int i=62;i>=0;i--)\n\t\t{\n\t\t\tint nw[2][3]; memset(nw,0,sizeof(nw));\n\t\t\tfor(int k=0;k<2;k++) //1 if still a prefix of mx\n\t\t\t{\n\t\t\t\tfor(int l=0;l<3;l++) //mod\n\t\t\t\t{\n\t\t\t\t\tif(!dp[k][l]) continue;\n\t\t\t\t\t//add 1\n\t\t\t\t\t{\n\t\t\t\t\t\tif(y&(1LL<<i))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif(k==1&&(!mx&(1LL<<i)))\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tint newk=0;\n\t\t\t\t\t\t\t\tif(k==1&&(mx&(1LL<<i))) newk=1;\n\t\t\t\t\t\t\t\tint newl=(l+md[i])%3;\n\t\t\t\t\t\t\t\tnw[newk][newl]^=1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//add 0\n\t\t\t\t\t{\n\t\t\t\t\t\tint newk=0;\n\t\t\t\t\t\tif(k==1&&!(mx&(1LL<<i))) newk=1;\n\t\t\t\t\t\tint newl=l;\n\t\t\t\t\t\tnw[newk][newl]^=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int k=0;k<2;k++) //1 if still a prefix of mx\n\t\t\t{\n\t\t\t\tfor(int l=0;l<3;l++) //mod\n\t\t\t\t{\n\t\t\t\t\tdp[k][l]=nw[k][l];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int l=0;l<3;l++)\n\t\t{\n\t\t\tint nwmod=(xmod+l)%3;\n\t\t\tint as=(dp[0][l]^dp[1][l]);\n\t\t\tres[nwmod]^=as;\n\t\t}\n\t}\n\treturn res[mod];\n}\n\nll getcount(ll l, ll r, int mod) //%3 = mod\n{\n\treturn getbelow(r,mod)-getbelow(l-1,mod);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tfor(int i=0;i<63;i++) md[i]=((1LL<<i))%3;\n\tint n; cin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll x,y; cin>>x>>y; vec.pb({x,y}); y-=C;\n\t}\n\tint mod=-1;\n\tfor(int i=0;i<3;i++)\n\t{\n\t\tif(getcount(-ll(2e18),ll(2e18),i)){mod=i; break;}\n\t}\n\tll lo=-ll(2e18); ll hi=ll(2e18);\n\twhile(lo<hi)\n\t{\n\t\tll mid=(lo+hi)>>1;\n\t\tif(getcount(lo,mid,mod))\n\t\t{\n\t\t\thi=mid;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlo=mid+1;\n\t\t}\n\t}\n\tll cur = lo;\n\tfor(int i=62;i>=0;i--)\n\t{\n\t\tif(color(cur-(1LL<<i),C)) cur-=(1LL<<i);\n\t}\n\tll x = cur;\n\tfor(int i=62;i>=0;i--)\n\t{\n\t\tif(color(cur+(1LL<<i),C)) cur+=(1LL<<i);\n\t}\n\tll y = (cur-x)+C;\n\tcout<<x<<' '<<y<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "//by yjz\n#include<bits/stdc++.h>\nusing namespace std;\n#define FF first\n#define SS second\n#define PB push_back\n#define MP make_pair\n#define foreach(it,s) for(__typeof((s).begin()) it=(s).begin();it!=(s).end();it++)\n#ifndef LOCAL\n#define cerr if(0)cout\n#endif\ntypedef long long ll;\nconst int mod = 1e9+7;\n//My i/o stream\nstruct fastio\n{\n\tchar s[100000];\n\tint it, len;\n\tfastio() {it=len=0;}\n\tinline char get()\n\t{\n\t\tif (it<len) return s[it++]; it=0;\n\t\tlen=fread(s, 1, 100000, stdin);\n\t\tif (len==0) return EOF; else return s[it++];\n\t}\n\tbool notend()\n\t{\n\t\tchar c=get();\n\t\twhile (c==' '||c=='\\n') c=get();\n\t\tif (it>0) it--;\n\t\treturn c!=EOF;\n\t}\n}_buff;\n#define geti(x) x=getnum()\n#define getii(x,y) geti(x),geti(y)\n#define getiii(x,y,z) getii(x,y),geti(z)\n#define puti(x) putnum(x),putchar(' ')\n#define putii(x,y) puti(x),puti(y)\n#define putiii(x,y,z) putii(x,y),puti(z)\n#define putsi(x) putnum(x),putchar('\\n')\n#define putsii(x,y) puti(x),putsi(y)\n#define putsiii(x,y,z) putii(x,y),putsi(z)\ninline ll getnum()\n{\n\tll r=0; bool ng=0; char c; c=_buff.get();\n\twhile (c!='-'&&(c<'0'||c>'9')) c=_buff.get();\n\tif (c=='-') ng=1, c=_buff.get();\n\twhile (c>='0'&&c<='9') r=r*10+c-'0', c=_buff.get();\n\treturn ng?-r:r;\n}\ntemplate <class T> inline void putnum(T x)\n{\n\tif (x<0) putchar('-'), x=-x;\n\tregister short a[20]={}, sz=0;\n\twhile (x) a[sz++]=x%10, x/=10;\n\tif(sz==0) putchar('0');\n\tfor (int i=sz-1; i>=0; i--) putchar('0'+a[i]);\n}\ninline char getreal() {char c=_buff.get(); while (c<=32) c=_buff.get(); return c;}\nll qpow(ll x, ll k) {return k==0? 1: 1ll*qpow(1ll*x*x%mod,k>>1)*(k&1?x:1)%mod;}\nconst ll L = -3e17;\nint n;\nvector<pair<ll,ll> > v;\nbool check_point(pair<ll,ll> p, ll x, ll y)\n{\n\tif (x<p.FF||x>p.FF+p.SS-y) return false;\n\tll X = x-p.FF;\n\tll Y = p.SS-y;\n\treturn (Y&X)==X;\n}\nbool check_point(ll x)\n{\n\tbool ret = 0;\n\tfor (auto p : v)\n\t{\n\t\tif (check_point(p, x, L))\n\t\t{\n\t\t\tret ^= 1;\n\t\t}\n\t}\n\treturn ret;\n}\nbool cnt[3];\nvoid calc(pair<ll,ll> p, ll x, ll y)\n{\n\tif (x<p.FF) return;\n\tif (x>p.FF+p.SS-y) x = p.FF+p.SS-y;\n\tll X = x-p.FF;\n\tll Y = p.SS-y;\n//\tcerr<<X<<\",\"<<Y<<endl;\n\tassert(Y>=0);\n\tstatic bool dp[66][2][3];\n\tmemset(dp, 0, sizeof(dp));\n\tdp[60][1][0] = 1;\n\tfor (int i=59; i>=0; i--)\n\t{\n\t\tfor (int t=0; t<2; t++)\n\t\t{\n\t\t\tfor (int v=0; v<2; v++)\n\t\t\t{\n\t\t\t\tif (v&&!((Y>>i)&1)) continue;\n\t\t\t\tif (v&&t&&!((X>>i)&1)) continue;\n\t\t\t\tint dlt = ((1ll*v)<<i)%3;\n\t\t\t\tint nt = t&(v==((X>>i)&1));\n\t\t\t\tfor (int j=0; j<3; j++) dp[i][nt][(j+dlt)%3] ^= dp[i+1][t][j];\n\t\t\t}\n\t\t}\n\t}\n\tint t = ((p.FF%3)+3)%3;\n//\tfor (int i=0; i<3; i++) cerr<<dp[0][0][i]; cerr<<\" \";\n//\tfor (int i=0; i<3; i++) cerr<<dp[0][1][i]; cerr<<endl;\n\t\n\tfor (int i=0; i<3; i++)\n\t{\n\t\tcnt[(i+t)%3] ^= dp[0][0][i];\n\t\tcnt[(i+t)%3] ^= dp[0][1][i];\n\t}\n}\nbool check(ll x)\n{\n//\tcerr<<\"check:\"<<x<<endl;\n\tcnt[0] = cnt[1] = cnt[2] = 0;\n\tfor (auto p : v)\n\t{\n\t\tcalc(p, x, L);\n\t}\n//\tcerr<<cnt[0]<<\" \"<<cnt[1]<<\" \"<<cnt[2]<<endl;\n\treturn cnt[0]||cnt[1]||cnt[2];\n}\nint main()\n{\n\tgeti(n);\n\tfor (int i=1; i<=n; i++)\n\t{\n\t\tll x, y;\n\t\tgetii(x, y);\n\t\tv.PB(MP(x, y));\n\t}\n/*\tfor (int i=L; i<=-L; i++)\n\t{\n\t\tcerr<<check_point(i);\n\t\tif ((i-L)%5==0) cerr<<\" \";\n\t} cerr<<endl;\n*/\n\tll l = -2e17, r = 1e18;\n\twhile (l<=r)\n\t{\n\t\tll m = l+r>>1;\n\t\tif (check(m)) r = m-1; else l = m+1;\n\t}\n//\tcerr<<l<<\",\"<<r<<\" \"<<check(l)<<check(r)<<endl;\n\tr = l;\n//\tcerr<<\"l=\"<<l<<\" r=\"<<r<<endl;\n\tfor (int i=0; i<=60; i++) if (check_point(l-(1ll<<i))) l -= 1ll<<i;\n\tfor (int i=0; i<=60; i++) if (check_point(r+(1ll<<i))) r += 1ll<<i;\n//\tcerr<<l<<\",\"<<r<<endl;\n\n\tcout<<l<<\" \"<<L+(r-l)<<endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V vector\n#define W V<long>\nusing namespace std;long E,M=2e17,a,b;W A;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].push_back({x[0]/2,++x[1]/2});}for(long i;i<2;i++){a=0;for(W x:T[!i])a^=(2*x[0]+x[1])%3+1;if(!a){E--;A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;A=S(p);A[0]--;return A;}int main(){cin>>E;V<W>p(E);E*=2;while(E--,cin>>a)p[E/2].push_back(a+M);E=70;A=S(p);cout<<A[0]-M<<\" \"<<A[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll offset = 1ll << 58;\nconst int LOG = 60;\nint main() {\n  do {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n  } while (false);\n  int n;\n  cin >> n;\n  vector<ll> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n    x[i] += offset;\n    y[i] += offset;\n  }\n  auto calc = [&] (ll sum, int mod) {\n    vector<bool> F(3), G(3), new_F(3), new_G(3);\n    bool res = false;\n    for (int i = 0; i < n; i++) {\n      if (y[i] < sum) {\n        ll limit = sum - y[i];\n        fill(F.begin(), F.end(), false);\n        fill(G.begin(), G.end(), false);\n        F[0] = true;\n        for (int j = LOG; j >= 0; j--) {\n          fill(new_F.begin(), new_F.end(), false);\n          fill(new_G.begin(), new_G.end(), false);\n          for (int k = 0; k < 3; k++) {\n            if (F[k]) {\n              for (int value = 0; value <= min((limit >> j) & 1, (x[i] >> j) & 1); value++) {\n                int nxt = (k + value + value * (j & 1)) % 3;\n                if (value != ((limit >> j) & 1)) {\n                  new_G[nxt].flip();\n                } else {\n                  new_F[nxt].flip();\n                }\n              }\n            }\n            if (G[k]) {\n              for (int value = 0; value <= ((x[i] >> j) & 1); value++) {\n                int nxt = (k + value + value * (j & 1)) % 3;\n                new_G[nxt].flip();\n              }\n            }\n          }\n          F.swap(new_F);\n          G.swap(new_G);\n        }\n        res ^= G[(mod - y[i] % 3 + 3) % 3];\n      }\n    }\n    return res;\n  };\n  int mod = 0;\n  while (!calc(1ll << LOG, mod)) {\n    mod++;\n  }\n  ll start = 0;\n  for (int i = LOG; i >= 0; i--) {\n    if (calc(start, mod) == calc(start + (1ll << i), mod)) {\n      start += 1ll << i;\n    }\n  }\n  auto check = [&] (ll pos) {\n    bool res = false;\n    for (int i = 0; i < n; i++) {\n      if (y[i] <= pos && pos <= x[i] + y[i] && (x[i] & (pos - y[i])) == pos - y[i]) {\n        res ^= 1;\n      }\n    }\n    return res;\n  };\n  ll L = start, R = start;\n  for (int i = LOG; i >= 0; i--) {\n    if (check(L - (1ll << i))) {\n      L -= 1ll << i;\n    }\n    if (check(R + (1ll << i))) {\n      R += 1ll << i;\n    }\n  }\n  cout << R - L - offset << \" \" << L - offset << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long long\n#define W V<L>\n#define R(n) for(L i=0;i<n;i++)\n#define X return\nW S(V<W>&p,L E){if(!E){X{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}V<W>c(4,W(3));c[3]=W(3,1);R(2){for(W x:T[i]){L Q=(2*x[0]+x[1])%3;c[i][Q]^=1;}}R(2){if(c[!i]==c[2]||c[!i]==c[3]){W ans=S(T[i],E-1);ans[0]*=2;ans[1]*=2;ans[1]+=i;X ans;}}for(W&v:p){v[0]++;}W A=S(p,E);A[0]--;X A;}\nint main(){L M=2e17;L n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}W Q=S(p,70);cout<<Q[0]-M<<\" \"<<Q[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst ll base = 1ll << 58;\nconst int LOG = 60;\nint main() {\n  do {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cout.tie(nullptr);\n  } while (false);\n  int n;\n  cin >> n;\n  vector<ll> x(n), y(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n    x[i] += base;\n    y[i] += base;\n  }\n  auto calc = [&] (ll sum, int r) {\n    bool res = false;\n    for (int i = 0; i < n; i++) {\n      if (y[i] < sum) {\n        ll limit = sum - y[i];\n        vector<bool> F(3), G(3);\n        F[0] = true;\n        for (int j = LOG; j >= 0; j--) {\n          vector<bool> F2(3), G2(3);\n          for (int k = 0; k < 3; k++) {\n            if (F[k]) {\n              for (int v = 0; v <= min(limit >> j & 1, x[i] >> j & 1); v++) {\n                int nxt = (k + v * (j & 1) + v) % 3;\n                if (v != (limit >> j & 1)) {\n                  G2[nxt].flip();\n                } else {\n                  F2[nxt].flip();\n                }\n              }\n            }\n            if (G[k]) {\n              for (int v = 0; v <= (x[i] >> j & 1); v++) {\n                int nxt = (k + v * (j & 1) + v) % 3;\n                G2[nxt].flip();\n              }\n            }\n          }\n          F = F2;\n          G = G2;\n        }\n        res ^= G[(r - y[i] % 3 + 3) % 3];\n      }\n    }\n    return res;\n  };\n  int r = 0;\n  while (!calc(1ll << LOG, r)) {\n    r++;\n  }\n  ll start = 0;\n  for (int i = LOG - 1; i >= 0; i--) {\n    if (calc(start, r) == calc(start + (1ll << i), r)) {\n      start |= 1ll << i;\n    }\n  }\n  auto check = [&] (ll pos) {\n    bool res = false;\n    for (int i = 0; i < n; i++) {\n      if (y[i] <= pos && pos <= x[i] + y[i] && (x[i] & (pos - y[i])) == pos - y[i]) {\n        res ^= 1;\n      }\n    }\n    return res;\n  };\n  ll L = start, R = start;\n  for (int i = LOG - 1; i >= 0; i--) {\n    if (check(L - (1ll << i))) {\n      L -= 1ll << i;\n    }\n    if (check(R + (1ll << i))) {\n      R += 1ll << i;\n    }\n  }\n  cout << R - L - base << \" \" << L - base << endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V vector\n#define W V<long>\nusing namespace std;long E=70,M=2e17,i,a,b;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].push_back({x[0]/2,++x[1]/2});}for(i=0;i<2;i++){a=0;for(W x:T[!i])a^=(2*x[0]+x[1])%3+1;if(!a){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){cin>>i;V<W>p(i);while(i--,cin>>a>>b)p[i]={a+M,b+M};W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc+1)&1) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0]&&!c[1-i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70,M=2e17,i,a,b;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[(x[1])&1].push_back({x[0]/2,(++x[1])/2});}for(L i;i<2;i++){L c=0;for(W x:T[!i])c^=(2*x[0]+x[1])%3+1;if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){cin>>i;V<W>p(i);while(i--,cin>>a>>b)p[i]={a+M,b+M};W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tpin ans=solve(ab,ex-1);\n  ans.first+=qab[0].size()+qab[1].size();\n  return ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,\"Line:\",__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\nvoid print(ll x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<endl;\n\t#else\n\tcout<<\"Yes\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<endl;\n\t#else\n\tcout<<\"No\"<<endl;\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nint mask(int i){\n\treturn (int(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n    static random_device rd;\n    static mt19937_64 gen(rd());\n    #endif\n    return uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\nconst int L=60;\nstring to_binary(int a){\n\tstring res;\n\tper(i,L)\n\t\tres+='0'+((a>>i)&1);\n\treturn res;\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tconst int V=ten(17)+1;\n\t\n\tint n;cin>>n;\n\tvc<pi> xy;\n\tint ymin=inf;\n\trep(i,n){\n\t\tint x,y;cin>>x>>y;\n\t\txy.eb(x+V,y+V);\n\t\tchmin(ymin,y+V);\n\t}\n\t\n\tusing T=array<int,3>;\n\t//subset of a, less than b\n\tauto sgm=[&](int a,int b){\n\t\tif(b<=0)return T{};\n\t\tT p{},q{};\n\t\tp[0]=1;\n\t\tper(i,L){\n\t\t\tif(a&1LL<<i){\n\t\t\t\t{\n\t\t\t\t\tT z{};\n\t\t\t\t\trep(k,3)rep(t,2)\n\t\t\t\t\t\tz[(k*2+t)%3]^=q[k];\n\t\t\t\t\tq=z;\n\t\t\t\t}\n\t\t\t\tif(b&1LL<<i){\n\t\t\t\t\trep(k,3)\n\t\t\t\t\t\tq[k*2%3]^=p[k];\n\t\t\t\t\tT z{};\n\t\t\t\t\trep(k,3)\n\t\t\t\t\t\tz[(k*2+1)%3]^=p[k];\n\t\t\t\t\tp=z;\n\t\t\t\t}else{\n\t\t\t\t\tT z{};\n\t\t\t\t\trep(k,3)\n\t\t\t\t\t\tz[k*2%3]^=p[k];\n\t\t\t\t\tp=z;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t{\n\t\t\t\t\tT z{};\n\t\t\t\t\trep(k,3)\n\t\t\t\t\t\tz[k*2%3]^=q[k];\n\t\t\t\t\tq=z;\n\t\t\t\t}\n\t\t\t\tif(b&1LL<<i){\n\t\t\t\t\trep(k,3)\n\t\t\t\t\t\tq[k*2%3]^=p[k];\n\t\t\t\t\tp={};\n\t\t\t\t}else{\n\t\t\t\t\tT z{};\n\t\t\t\t\trep(k,3)\n\t\t\t\t\t\tz[k*2%3]^=p[k];\n\t\t\t\t\tp=z;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn q;\n\t};\n\t\n\t//dmp(sgm(5,4));\n\t//dmp(sgm(5,5));\n\t//dmp(sgm(8,5));\n\t\n\t//is b a subset of a?\n\tauto ysp=[&](int a,int b){\n\t\tif(b<0)return 0LL;\n\t\treturn int((a&b)==b);\n\t};\n\t\n\t//parity of ones, less than b\n\tauto waf=[&](int a,int b){\n\t\tT w{};\n\t\tfor(auto p:xy){\n\t\t\tint c=a-p.a-p.b;\n\t\t\tT x=sgm(c,b-p.b);\n\t\t\trep(k,3)\n\t\t\t\tw[(k+p.b)%3]^=x[k];\n\t\t}\n\t\treturn w[0]+w[1]+w[2];\n\t};\n\t\n\t//parity of position b\n\tauto relka=[&](int a,int b){\n\t\tint res=0;\n\t\tfor(auto p:xy){\n\t\t\tint c=a-p.a-p.b;\n\t\t\tres^=ysp(c,b-p.b);\n\t\t}\n\t\treturn res;\n\t};\n\t\n\tint a=mask(L);\n\t\n\tint lw=0,up=a;\n\twhile(up-lw>1){\n\t\tconst int mid=(lw+up)/2;\n\t\tif(waf(a,mid))\n\t\t\tup=mid;\n\t\telse\n\t\t\tlw=mid;\n\t}\n\t\n\tassert(relka(a,lw));\n\tup--;\n\tper(i,L){\n\t\tint nx=lw-(1LL<<i);\n\t\tif(relka(a,nx))\n\t\t\tlw=nx;\n\t}\n\tper(i,L){\n\t\tint nx=up+(1LL<<i);\n\t\tif(relka(a,nx))\n\t\t\tup=nx;\n\t}\n\t\n\tint x=a-up,y=lw;\n\tx-=V;\n\ty-=V;\n\t\n\tcout<<x<<\" \"<<y<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70,M=2e17,i,a,b;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}for(L i;i<2;i++){L c=0;for(W x:T[!i])c^=(2*x[0]+x[1])%3+1;if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){cin>>i;V<W>p(i);while(i--,cin>>a>>b)p[i]={a+M,b+M};W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "/*{{{*/\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<set>\n#include<map>\n#include<queue>\n#include<bitset>\n#include<vector>\n#include<limits.h>\n#include<assert.h>\n#define SZ(X) ((int)(X).size())\n#define ALL(X) (X).begin(), (X).end()\n#define REP(I, N) for (int I = 0; I < (N); ++I)\n#define REPP(I, A, B) for (int I = (A); I < (B); ++I)\n#define FOR(I, A, B) for (int I = (A); I <= (B); ++I)\n#define FORS(I, S) for (int I = 0; S[I]; ++I)\n#define RS(X) scanf(\"%s\", (X))\n#define SORT_UNIQUE(c) (sort(c.begin(),c.end()), c.resize(distance(c.begin(),unique(c.begin(),c.end()))))\n#define GET_POS(c,x) (lower_bound(c.begin(),c.end(),x)-c.begin())\n#define CASET int ___T; scanf(\"%d\", &___T); for(int cs=1;cs<=___T;cs++)\n#define MP make_pair\n#define PB push_back\n#define MS0(X) memset((X), 0, sizeof((X)))\n#define MS1(X) memset((X), -1, sizeof((X)))\n#define LEN(X) strlen(X)\n#define F first\n#define S second\nusing namespace std;\ntypedef __int128_t LL;\ntypedef unsigned long long ULL;\ntypedef long double LD;\ntypedef pair<int,int> PII;\ntypedef vector<int> VI;\ntypedef vector<LL> VL;\ntypedef vector<PII> VPII;\ntypedef pair<LL,LL> PLL;\ntypedef vector<PLL> VPLL;\ntemplate<class T> void _R(T &x) { cin >> x; }\nvoid _R(int &x) { scanf(\"%d\", &x); }\nvoid _R(double &x) { scanf(\"%lf\", &x); }\nvoid _R(char &x) { scanf(\" %c\", &x); }\nvoid _R(char *x) { scanf(\"%s\", x); }\nvoid R() {}\ntemplate<class T, class... U> void R(T &head, U &... tail) { _R(head); R(tail...); }\ntemplate<class T> void _W(const T &x) { cout << x; }\nvoid _W(const int &x) { printf(\"%d\", x); }\nvoid _W(const double &x) { printf(\"%.16f\", x); }\nvoid _W(const char &x) { putchar(x); }\nvoid _W(const char *x) { printf(\"%s\", x); }\ntemplate<class T,class U> void _W(const pair<T,U> &x) {_W(x.F); putchar(' '); _W(x.S);}\ntemplate<class T> void _W(const vector<T> &x) { for (auto i = x.begin(); i != x.end(); _W(*i++)) if (i != x.cbegin()) putchar(' '); }\nvoid W() {}\ntemplate<class T, class... U> void W(const T &head, const U &... tail) { _W(head); putchar(sizeof...(tail) ? ' ' : '\\n'); W(tail...); }\n#ifdef HOME\n #define DEBUG(...) {printf(\"# \");printf(__VA_ARGS__);puts(\"\");}\n#else\n #define DEBUG(...)\n#endif\nint MOD = 1e9+7;\nvoid ADD(LL& x,LL v){x=(x+v)%MOD;if(x<0)x+=MOD;}\n/*}}}*/\nconst int SIZE = 1e6+10;\nset<PLL>AA;\nPLL ker[SIZE];\n__int128_t bb=1LL<<35;\nint main(){\n    bb*=bb;\n    int N; R(N);\n    int rr=N;\n    REP(i,N){\n        long long x,y; scanf(\"%lld %lld\",&x,&y);\n        ker[i].F=x;\n        ker[i].S=y;\n        AA.insert(ker[i]);\n    }\n    REP(i,rr){\n        //W((long long)ker[i].F,(long long)ker[i].S);\n        if(!AA.count(ker[i]))continue;\n        for(LL two=1;two<=bb;two*=2){\n            if(AA.count({ker[i].F+two,ker[i].S})){\n                AA.erase({ker[i].F+two,ker[i].S});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F,ker[i].S+two};\n                if(!AA.count(nxt)){\n                    AA.insert(nxt);\n                    ker[rr++]=nxt;\n                }\n                else{\n                    AA.erase(nxt);\n                }\n                break;\n            }\n            if(AA.count({ker[i].F-two,ker[i].S})){\n                AA.erase({ker[i].F-two,ker[i].S});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F-two,ker[i].S+two};\n                if(!AA.count(nxt)){\n                    AA.insert(nxt);\n                    ker[rr++]=nxt;\n                }\n                else{\n                    AA.erase(nxt);\n                }\n                break;\n            }\n            if(AA.count({ker[i].F,ker[i].S+two})){\n                AA.erase({ker[i].F,ker[i].S+two});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F+two,ker[i].S};\n                if(!AA.count(nxt)){\n                    AA.insert(nxt);\n                    ker[rr++]=nxt;\n                }\n                else{\n                    AA.erase(nxt);\n                }\n                break;\n            }\n            if(AA.count({ker[i].F,ker[i].S-two})){\n                AA.erase({ker[i].F,ker[i].S-two});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F+two,ker[i].S-two};\n                if(!AA.count(nxt)){\n                    AA.insert(nxt);\n                    ker[rr++]=nxt;\n                }\n                else{\n                    AA.erase(nxt);\n                }\n                break;\n            }\n            if(AA.count({ker[i].F+two,ker[i].S-two})){\n                AA.erase({ker[i].F+two,ker[i].S-two});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F,ker[i].S-two};\n                if(!AA.count(nxt)){\n                    AA.insert(nxt);\n                    ker[rr++]=nxt;\n                }\n                else{\n                    AA.erase(nxt);\n                }\n                break;\n            }\n            if(AA.count({ker[i].F-two,ker[i].S+two})){\n                AA.erase({ker[i].F-two,ker[i].S+two});\n                AA.erase(ker[i]);\n                PLL nxt={ker[i].F-two,ker[i].S};\n                if(!AA.count(nxt)){\n                    AA.insert(nxt);\n                    ker[rr++]=nxt;\n                }\n                else{\n                    AA.erase(nxt);\n                }\n                break;\n            }\n        }\n    }\n    printf(\"%lld %lld\\n\",(long long)(AA.begin()->F),(long long)(AA.begin()->S));\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long long\n#define W V<L>\n#define R(n) for(L i=0;i<n;i++)\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}\nint main(){L M=2e17,n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc+1)%2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (c[1 - i][0]==0&&c[1-i][1]==0) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long long\n#define W V<L>\n#define R(n) for(L i=0;i<n;i++)\nW S(V<W>&p,L E){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){int c=0;for(W x:T[i]){L Q=(2*x[0]+x[1])%3;c^=(Q+1);}}R(2){if(!c){W ans=S(T[i],E-1);ans[0]*=2;ans[1]*=2;ans[1]+=i;return ans;}}for(W&v:p){v[0]++;}W A=S(p,E);A[0]--;return A;}\nint main(){L M=2e17;L n;cin>>n;V<W>p(n);R(n){L a,b;cin>>a>>b;p[i]={a+M,b+M};}W Q=S(p,70);cout<<Q[0]-M<<\" \"<<Q[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long long\n#define W V<L>\n#define R(n)for(L i=0;i<n;i++)\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n,a,b;cin>>n;V<W>p(n);R(n){cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  qab[0].reserve(10000);\n  qab[1].reserve(10000);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n\tV<vel> c(2, vel(2));\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n\t\t\tif ((qc+1)%2) { c[i][0] ^= 1; }\n\t\t\tif (qc) { c[i][1] ^= 1; }\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0]&&!c[1-i][1]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<assert.h>\ntypedef long long ll;\nconst ll inf=1e17;\nll f[3][2],g[3][2];\n//f[i][j][k]:i~60 ok, %3=j, locked?\nll s[3];\nvoid dp(ll n,ll m){//sum[i<=m & i in n & i%3=r]\n\tif(m<0){\n\t\tmemset(s,0,sizeof(s));\n\t\treturn;\n\t}\n\tint i,j;\n\tmemset(f,0,sizeof(f));\n\tf[0][1]=1;\n\tfor(i=60;i>=0;i--){\n\t\tmemset(g,0,sizeof(g));\n\t\tfor(j=0;j<3;j++){\n\t\t\tg[j][0]+=f[j][0];\n\t\t\tif(n>>i&1)g[(j+(1ll<<i))%3][0]+=f[j][0];\n\t\t\tif(m>>i&1){\n\t\t\t\tg[j][0]+=f[j][1];\n\t\t\t\tif(n>>i&1)g[(j+(1ll<<i))%3][1]+=f[j][1];\n\t\t\t}else\n\t\t\t\tg[j][1]+=f[j][1];\n\t\t}\n\t\tmemcpy(f,g,sizeof(g));\n\t}\n\tfor(i=0;i<3;i++)s[i]=f[i][0]+f[i][1];\n}\nll get(ll n,ll l,ll r,int t){\n\tdp(n,r);\n\tll s=::s[t];\n\tdp(n,l-1);\n\treturn s-::s[t];\n}\nll x[10010],y[10010];\nint n;\nconst ll c=2*inf;\nll get(ll l,ll r,int t){\n\tll s;\n\tint i;\n\ts=0;\n\tfor(i=1;i<=n;i++)s+=get(c-x[i]-y[i],l-x[i],r-x[i],((t-x[i])%3+3)%3);\n\treturn s;\n}\nbool C(ll n,ll k){return(n&k)==k;}\nbool light(ll a){\n\tint i,f=0;\n\tfor(i=1;i<=n;i++){\n\t\tif(x[i]<=a)f^=C(c-x[i]-y[i],a-x[i]);\n\t}\n\treturn f;\n}\nint main(){\n\tint i,t;\n\tll l,r,mid,x1,x2;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)scanf(\"%lld%lld\",x+i,y+i);\n\tfor(t=0;t<3;t++){\n\t\tif(get(-inf,inf,t)&1)break;\n\t}\n\tl=-inf;\n\tr=inf;\n\twhile(l<r){\n\t\tmid=(l+r)>>1;\n\t\tif(get(l,mid,t)&1)\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n\tassert(light(l));\n\tx1=x2=l;\n\tfor(i=60;i>=0;i--){\n\t\tif(light(x1-(1ll<<i)))x1-=1ll<<i;\n\t\tif(light(x2+(1ll<<i)))x2+=1ll<<i;\n\t}\n\tprintf(\"%lld %lld\",x1,c-x2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V vector\n#define W V<long>\nusing namespace std;long E,M=2e17,a,b;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].push_back({x[0]/2,++x[1]/2});}for(long i;i<2;i++){a=0;for(W x:T[!i])a^=(2*x[0]+x[1])%3+1;if(!a)E--,W A=S(T[i]),A[0]*=2,A[1]*=2,A[1]+=i;return A;}}for(W&v:p)v[0]++;W A=S(p);A[0]--;return A;}int main(){cin>>E;V<W>p(E);while(E--,cin>>a>>b)p[E]={a+M,b+M};E=70;W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"sse2,pclmul,tune=native\")\n#pragma GCC optimize(\"O3\")\n#include <ext/pb_ds/assoc_container.hpp>\n#include <nmmintrin.h>\n#include <emmintrin.h>\n#include <wmmintrin.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nusing GF = uint32_t;\n\ninline GF Add(GF a, GF b) {\n  return a ^ b;\n}\n\ninline GF Mul(GF a, GF b) {\n  __m128i xa = _mm_cvtsi64_si128(a), xb = _mm_cvtsi64_si128(b);\n  xa = _mm_clmulepi64_si128(xa, xb, 0x00);\n  uint64_t res = _mm_cvtsi128_si64(xa);\n  GF hi = res >> 32;\n  GF a0 = hi ^ (hi >> 25) ^ (hi >> 29) ^ (hi >> 30);\n  return (GF)res ^ a0 ^ (a0 << 2) ^ (a0 << 3) ^ (a0 << 7);\n}\n\nvector<GF> base;\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val);\nGF AddPositionsFrom(LL x, LL y, LL min_val);\n\nconst int MemoSize = 1 << 24;\n\npair<LL, LL> other_hash[MemoSize];\nGF memo[MemoSize];\n\nuint64_t Hash1(const pair<LL, LL> &p) {\nusing U = uint64_t;\n  uint64_t y = ((U)p.st * 0x123456789ABCDEFLL) ^ ((U)p.nd * 0xFEDCBA987654321LL);\n  return y ^ ((((U)p.st >> 32) * 0x019428711LL) + (((U)p.nd >> 24) * 0x593285392LL));\n}\n\n/*uint64_t Hash2(const pair<LL, LL> &p) {\n  return p.st + p.nd + (p.st ^ p.nd) + 17;\n}*/\n\nbool FindVal(const pair<LL, LL> &p, GF &ans) {\n  constexpr uint64_t kMask = MemoSize - 1;\n  auto h1 = Hash1(p) & kMask; //, h2 = Hash2(p);\n  for (int i = 0; other_hash[h1] != pair<LL, LL>{0, 0} && other_hash[h1] != p; ++i) {\n    h1 = (h1 + i) & kMask;\n  }\n  if (other_hash[h1] == p) {\n    ans = memo[h1];\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid PutVal(const pair<LL, LL> &p, const GF val) {\n  constexpr uint64_t kMask = MemoSize - 1;\n  auto h1 = Hash1(p) & kMask; //, h2 = Hash2(p);\n  for (int i = 0; other_hash[h1] != pair<LL, LL>{0, 0}; ++i) {\n    h1 = (h1 + i) & kMask;\n  }\n  other_hash[h1] = p; //h2;\n  memo[h1] = val;\n}\n\n//map<pair<LL, LL>, GF> memo;\nGF AddPositions(LL x, LL y, int bb = 60) {\n  if (x == 0 && y == 0) { return 1; }\n  debug(\"?Any\", x, y);\n  \n  pair<LL, LL> p{x, y};\n  {\n    GF ans;\n    if (FindVal(p, ans)) { return ans; }\n  }\n\n  int bit = 63 - __builtin_clzll(x + y);\n  while ((1LL << bit) > x + y) { --bit; }\n  if (x >= (1LL << bit)) {\n    GF ans = Mul(base[bit], AddPositions(x ^ (1LL << bit), y));\n    debug(x, y, ans);\n    PutVal(p, ans);\n    return ans;\n  }\n\n  // x < 2^bit <= x + y\n  GF answer1 = AddPositionsUpTo(x, y, (1LL << bit) - 1);\n  GF answer2 = AddPositionsFrom(x, y, (1LL << bit));\n  debug(x, y, answer1, answer2);\n  answer1 = Add(answer1, answer2);\n  PutVal(p, answer1);\n  return answer1;\n}\n\nGF GetValue(LL x) {\n  if (!x) { return 1; }\n  static map<LL, GF> val_memo;\n  auto it = val_memo.find(x);\n  if (it != val_memo.end()) { return it->nd; }\n\n  GF ans = 1;\n  for (int bit = 63 - __builtin_clzll(x); bit >= 0; --bit) {\n    if ((x >> bit) & 1) {\n      ans = Mul(base[bit], ans);\n    }\n  }\n  debug(\"Value\", x, ans);\n  return val_memo[x] = ans;\n}\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val) {\n  debug(\"?UpTo\", x, y, max_val);\n  if (x > max_val) { return 0; }\n  if (x + y <= max_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int a = ((63 - __builtin_clzll(y)) >> 3) << 3; a >= 0; a -= 8) {\n    if (!((y >> a) & 0xff)) { continue; }\n    for (int bit = a + 7; bit >= a; --bit) {\n      if (!((y >> bit) & 1)) { continue; }\n      const LL v = 1LL << bit;\n      y ^= v;\n\n      if (x + v - 1 <= max_val) {\n        debug(\"UpTo\", orig_x, orig_y, max_val, x, y);\n        answer = Add(answer, AddPositions(x, y));\n        x += v;\n      }\n    }\n  }\n  /*for (int bit = 60; bit >= 0; --bit) {\n  }*/\n  debug(answer);\n  if (x <= max_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF AddPositionsFrom(LL x, LL y, LL min_val) {\n  if (x + y < min_val) { return 0; }\n  if (x >= min_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int bit = 63 - __builtin_clzll(y); bit >= 0; --bit) {\n    if (!((y >> bit) & 1)) { continue; }\n    const LL v = 1LL << bit;\n    y ^= v;\n\n    if (x + v >= min_val) {\n      answer = Add(answer, AddPositions(x + v, y));\n    } else {\n      x += v;\n    }\n  }\n  debug(\"From\", orig_x, orig_y, min_val, answer, x);\n  if (x >= min_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF GetRandom() {\n  GF ans = 0;\n  for (int i = 0; i < 4; ++i) {\n    ans <<= 16;\n    ans |= (rand() % (1 << 16));\n  }\n  return ans;\n}\n\nint32_t main() {\n#ifndef LOCAL\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n#endif\n\n#ifdef TESTING\n  while (true) {\n    GF a = GetRandom(), b = GetRandom(), c = GetRandom();\n    GF d = Mul(a, Add(b, c));\n    GF e = Add(Mul(a, b), Mul(a, c));\n    debug(a,b,c,d,e);\n    assert(d == e);\n  }\n#endif\n\n  srand(2137);\n\n#warning\n  const int S = 58;\n//  const int S = 58;\n  const LL kLarge = 1LL << S;\n  for (int i = 0; i < 70; ++i) {\n    GF x = GetRandom();\n    base.PB(x);\n  }\n  debug(base);\n\n  int N;\n  cin >> N;\n  vector<pair<LL, LL>> values;\n\n  auto TotalGF = [&](LL bound) {\n    GF ans = 0;\n    for (auto &val : values) {\n      ans = Add(ans, AddPositionsUpTo(val.st, val.nd, bound));\n    }\n    debug(bound, ans);\n    return ans;\n  };\n\n  for (int i = 0; i < N; ++i) {\n    LL x, y;\n    cin >> x >> y;\n    values.emplace_back(x + kLarge, y + kLarge);\n  }\n\n  debug(values);\n\n  LL Lzero = 0, Rzero = (1LL << (S + 2));\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == 0) {\n      Lzero = midzero;\n    } else {\n      Rzero = midzero;\n    }\n  }\n\n  const LL first_x = Rzero - kLarge;\n  \n  Lzero = 0; Rzero = (1LL << (S + 2));\n  const GF aim = TotalGF(Rzero);\n\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == aim) {\n      Rzero = midzero;\n    } else {\n      Lzero = midzero;\n    }\n  }\n\n  const LL last_x = Rzero - kLarge;\n\n  cout << first_x << \" \" << last_x - first_x - kLarge << \"\\n\";\n  //cout << memo.size() << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin &x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n  int c=0;\n  \t\tfor (pin &x : qab[0]) {\n\t\t\tint qc = (2 * x.first + x.second)%3;\n          c^=(qc+1);\n\t\t}\n\t\tif (!c) {\n\t\t\tpin ans = solve(qab[1], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += 1;\n\t\t\treturn ans;\n\t\t}\n    c=0;\n\t\tfor (pin &x : qab[1]) {\n\t\t\tint qc = (2 * x.first + x.second)%3;\n          c^=(qc+1);\n\t\t}\n\t\tif (!c) {\n\t\t\tpin ans = solve(qab[0], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2;\n\t\t\treturn ans;\n\t\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin &x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n  int c=0;\n  \t\tfor (pin &x : qab[0]) {\n\t\t\tint qc = (2 * x.first + x.second)%3;\n          c^=(qc+1);\n\t\t}\n\t\tif (!c) {\n\t\t\tpin ans = solve(qab[1], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += 1;\n\t\t\treturn ans;\n\t\t}\n    c=0;\n\t\tfor (pin &x : qab[1]) {\n\t\t\tint qc = (2 * x.first + x.second)%3;\n          c^=(qc+1);\n\t\t}\n\t\tif (!c) {\n\t\t\tpin ans = solve(qab[0], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += 0;\n\t\t\treturn ans;\n\t\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(1,0); }\n\tV<V<pin>> qab(2);\n  int sz=ab.size();\n  qab[0].reserve(sz);\n  qab[1].reserve(sz);\n\tfor (pin x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2,x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2,(x.second + 1) / 2)); }\n\t}\n  vel c(2)\n\trep(i, 2) {\n\t\tfor (pin x : qab[i]) {\n\t\t\tint qc = (2 * x.first + x.second) % 3;\n          c[i]^=(qc+1);\n\t\t}\n\t}\n\trep(i, 2) {\n\t\tif (!c[1 - i][0]) {\n\t\t\tpin ans = solve(qab[i], ex - 1);\n\t\t\tans.first *= 2; ans.second *= 2; ans.second += i;\n\t\t\treturn ans;\n\t\t}\n\t}\n\tfor(pin &v:ab) { v.first++; }\n\tpin ans = solve(ab, ex); ans.first--;\n\treturn ans;\n}\nsigned main() {\n\tlong long inf = 2e17;\n\tint n; scanf(\"%lld\", &n);\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; scanf(\"%lld\", &a); scanf(\"%lld\", &b);\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 70);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "%:pragma GCC optimize(\"Ofast\", \"inline\")\n#include <bits/stdc++.h>\n#define rep(i, n) for (rint i = 1; i <= (n); i ++)\n#define re0(i, n) for (rint i = 0; i < (int) n; i ++)\n#define travel(i, u) for (rint i = head[u]; i; i = e[i].nxt)\n#define rint register int\n  using namespace std;\n\ntypedef long long lo;\n\ntemplate<typename tp> inline void read(tp &x) {\n  x = 0; char c = getchar(); int f = 0;\n  for (; c < '0' || c > '9'; f |= c == '-', c = getchar());\n  for (; c >= '0' && c <= '9'; x = (x << 3) + (x << 1) + c - '0', c = getchar());\n  if (f) x = -x;\n}\n#define int long long\nconst int N = 1e5 + 233;\nconst int inf = 6e17;\nint n, x[N], y[N], qy, ni[N];\nbool dp[65][2][3];\n\ninline bool get(int u, int n, int r) {\n  memset(dp, 0, sizeof dp);\n  int l = n - y[u];\n  l = min(l, ni[u]);\n  r = ((r - y[u] % 3) + 3) % 3;\n  if (l < 0) return 0;\n  // o \\in[0, l] && o % 3 == r ni[u]Co module 2\n  dp[0][1][0] = 1; int cur = 0;\n  for (int i = 61; i >= 0; i--) {\n    ++cur;\n    for (int d = 0; d < 2; d++) {\n      for (int pr = 0; pr < 3; pr++) {\n\tint lim = d ? l >> i & 1 : 1;\n\tfor (int ch = 0; ch <= min(ni[u] >> i & 1, lim); ch++) {\n\t  int nd = d && ch == lim;\n\t  dp[cur][nd][(pr + ch) % 3] ^= dp[cur - 1][d][pr];\n\t}\n      }\n    }\n  }\n  int ans = 0;\n  for (int d = 0; d < 2; d++)\n    ans ^= dp[cur][d][r];\n  return ans;\n}\n\ninline bool calc(int l, int r, int remain) {\n  bool ans = 0;\n  rep (i, n) ans ^= get(i, r, remain) ^ get(i, l - 1, remain);\n  // cout << l << \" \" << r << \" \" << remain << \" \" << ans << \"\\n\";\n  return ans;\n}\n\nsigned main(void) {\n  srand(20021214);\n  read(n);\n  rep (i, n) {\n    read(x[i]), read(y[i]);\n    ni[i] = x[i] + inf;\n    // mi_i = o - y_i\n  }\n  // cout << get(1, 2, 2) << \"\\n\";\n  // return 0;\n  int tr = 0;\n  re0 (r, 3) if (calc(-inf, inf, r) == true) {\n    tr = r;\n    break;\n  }\n  assert(calc(-inf, inf, tr) == true);\n  \n  int l = -inf, r = inf;\n  while (l < r) {\n    int mid = l + (r - l) / 2;\n    if (calc(l, mid, tr)) r = mid;\n    else l = mid + 1;\n  }\n  qy = r;\n  \n  auto isBlack = [&](int o) {\n    bool pa = 0;\n    rep (i, n) if (y[i] <= o && o <= x[i] + y[i] + inf) {\n      int nc = x[i] + inf;\n      int mc = o - y[i];\n      pa ^= nc == (nc | mc);\n    }\n    return pa;\n  };\n  assert(isBlack(qy) == true);\n  \n  int ty = qy, ansl, ansr;\n  \n  for (int k = 61; k >= 0; k--) {\n    if (isBlack(qy + (1ll << k))) {\n      qy += 1ll << k;\n    }\n  }\n  ansr = qy;\n  \n  qy = ty;\n  for (int k = 61; k >= 0; k--) {\n    if (isBlack(qy - (1ll << k))) {\n      qy -= 1ll << k;\n    }\n  }\n  ansl = qy;\n\n  cout << -inf + ansr - ansl << \" \" << ansl << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\nL E=70,M=2e17,i,a,b;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}for(L i;i<2;i++){L c=0;for(W x:T[!i]){c^=(2*x[0]+x[1])%3+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){cin>>i;V<W>p(i);while(i--){cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define V vector\n#define W V<long>\nusing namespace std;long E,M=2e17,a,b;W A;W S(V<W>p){if(!E)return{1,0};V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1)T[x[1]&1].push_back({x[0]/2,++x[1]/2});}for(long i;i<2;i++){a=0;for(W x:T[!i])a^=(2*x[0]+x[1])%3+1;if(!a){E--;A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p)v[0]++;A=S(p);A[0]--;return A;}main(){cin>>E;V<W>p(E);while(E--,cin>>a>>b)p[E]={a+M,b+M};E=70;A=S(p);cout<<A[0]-M<<\" \"<<A[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\nusing ll = long long;\nconstexpr ll off = 1ll << 58;\nint n, dp[2][3], nxt[2][3];\nll x[100005], y[100005];\ninline bool solve(ll sum, int rem)\n{\n\tbool res = false;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tif (y[i] >= sum)\n\t\t\tcontinue;\n\t\tll lim = sum - y[i];\n\t\tfor (int j = 0; j < 3; j++)\n\t\t\tdp[0][j] = dp[1][j] = 0;\n\t\tdp[0][0] = 1;\n\t\tfor (int j = 60; j >= 0; j--)\n\t\t{\n\t\t\tfor (int k = 0; k < 3; k++)\n\t\t\t\tnxt[0][k] = nxt[1][k] = 0;\n\t\t\tfor (int a = 0; a < 2; a++)\n\t\t\t{\n\t\t\t\tint mx = x[i] >> j & 1;\n\t\t\t\tif (!a && !(lim >> j & 1))\n\t\t\t\t\tmx = 0;\n\t\t\t\tfor (int b = 0; b < 3; b++)\n\t\t\t\t{\n\t\t\t\t\tif (!dp[a][b])\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tfor (int t = 0; t <= mx; t++)\n\t\t\t\t\t{\n\t\t\t\t\t\tint k = (b + t + t * (j & 1)) % 3;\n\t\t\t\t\t\tnxt[a || t != (lim >> j & 1)][k] ^= 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int k = 0; k < 3; k++)\n\t\t\t{\n\t\t\t\tdp[0][k] = nxt[0][k];\n\t\t\t\tdp[1][k] = nxt[1][k];\n\t\t\t}\n\t\t}\n\t\tres ^= dp[1][(rem - y[i] % 3 + 3) % 3];\n\t}\n\treturn res;\n}\ninline bool calc(ll pos)\n{\n\tbool res = false;\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tll cur = pos - y[i];\n\t\tif (cur >= 0 && cur <= x[i] && (x[i] & cur) == cur)\n\t\t\tres ^= 1;\n\t}\n\treturn res;\n}\nint main()\n{\n\t// freopen(\"C.in\", \"r\", stdin);\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%lld%lld\", x + i, y + i);\n\t\tx[i] += off;\n\t}\n\tint rem = 0;\n\twhile (!solve(1ll << 60, rem))\n\t\trem++;\n\tll pos = 0;\n\tfor (int i = 60; i >= 0; i--)\n\t{\n\t\tif (solve(pos, rem) == solve(pos + (1ll << i), rem))\n\t\t\tpos += 1ll << i;\n\t}\n\tll l = pos, r = pos;\n\tfor (int i = 60; i >= 0; i--)\n\t{\n\t\tif (calc(l - (1ll << i)))\n\t\t\tl -= 1ll << i;\n\t\tif (calc(r + (1ll << i)))\n\t\t\tr += 1ll << i;\n\t}\n\tprintf(\"%lld %lld\\n\", r - l - off, l - off);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#pragma GCC target(\"sse2,pclmul,tune=native\")\n#pragma GCC optimize(\"O3\")\n#include <ext/pb_ds/assoc_container.hpp>\n#include <nmmintrin.h>\n#include <emmintrin.h>\n#include <wmmintrin.h>\n\nusing namespace std;\n#define PB push_back\n#define MP make_pair\n#define LL long long\n#define int LL\n#define FOR(i,a,b) for(int i = (a); i <= (b); i++)\n#define RE(i,n) FOR(i,1,n)\n#define REP(i,n) FOR(i,0,(int)(n)-1)\n#define R(i,n) REP(i,n)\n#define VI vector<int>\n#define PII pair<int,int>\n#define LD long double\n#define FI first\n#define SE second\n#define st FI\n#define nd SE\n#define ALL(x) (x).begin(), (x).end()\n#define SZ(x) ((int)(x).size())\n\n#define unordered_map __fast_unordered_map\ntemplate<class Key, class Value, class Hash = std::hash<Key>>\nusing unordered_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;\n\ntemplate<class C> void mini(C &a4, C b4) { a4 = min(a4, b4); }\ntemplate<class C> void maxi(C &a4, C b4) { a4 = max(a4, b4); }\n\ntemplate<class TH> void _dbg(const char *sdbg, TH h){ cerr<<sdbg<<'='<<h<<endl; }\ntemplate<class TH, class... TA> void _dbg(const char *sdbg, TH h, TA... a) {\n  while(*sdbg!=',')cerr<<*sdbg++;\n  cerr<<'='<<h<<','; _dbg(sdbg+1, a...);\n}\n\ntemplate<class T> ostream &operator<<(ostream& os, vector<T> V) {\n  os << \"[\"; for (auto vv : V) os << vv << \",\"; return os << \"]\";\n}\ntemplate<class L, class R> ostream &operator<<(ostream &os, pair<L,R> P) {\n  return os << \"(\" << P.st << \",\" << P.nd << \")\";\n}\n\n#ifdef LOCAL\n#define debug(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\n#else\n#define debug(...) (__VA_ARGS__)\n#define cerr if(0)cout\n#endif\n\nusing GF = uint32_t;\n\ninline GF Add(GF a, GF b) {\n  return a ^ b;\n}\n\ninline GF Mul(GF a, GF b) {\n  __m128i xa = _mm_cvtsi64_si128(a), xb = _mm_cvtsi64_si128(b);\n  xa = _mm_clmulepi64_si128(xa, xb, 0x00);\n  uint64_t res = _mm_cvtsi128_si64(xa);\n  GF hi = res >> 32;\n  GF a0 = hi ^ (hi >> 25) ^ (hi >> 29) ^ (hi >> 30);\n  return (GF)res ^ a0 ^ (a0 << 2) ^ (a0 << 3) ^ (a0 << 7);\n}\n\nvector<GF> base;\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val);\nGF AddPositionsFrom(LL x, LL y, LL min_val);\n\nconst int MemoSize = 1 << 25;\n\npair<LL, LL> other_hash[MemoSize];\nGF memo[MemoSize];\n\nuint64_t Hash1(const pair<LL, LL> &p) {\nusing U = uint64_t;\n  uint64_t y = ((U)p.st * 0x123456789ABCDEFLL) ^ ((U)p.nd * 0xFEDCBA987654321LL);\n  return y ^ ((((U)p.st >> 32) * 0x019428711LL) + (((U)p.nd >> 24) * 0x593285392LL));\n}\n\n/*uint64_t Hash2(const pair<LL, LL> &p) {\n  return p.st + p.nd + (p.st ^ p.nd) + 17;\n}*/\n\nbool FindVal(const pair<LL, LL> &p, GF &ans) {\n  constexpr uint64_t kMask = MemoSize - 1;\n  auto h1 = Hash1(p) & kMask; //, h2 = Hash2(p);\n  for (int i = 0; other_hash[h1] != pair<LL, LL>{0, 0} && other_hash[h1] != p; ++i) {\n    h1 = (h1 + i) & kMask;\n  }\n  if (other_hash[h1] == p) {\n    ans = memo[h1];\n    return true;\n  } else {\n    return false;\n  }\n}\n\nvoid PutVal(const pair<LL, LL> &p, const GF val) {\n  constexpr uint64_t kMask = MemoSize - 1;\n  auto h1 = Hash1(p) & kMask; //, h2 = Hash2(p);\n  for (int i = 0; other_hash[h1] != pair<LL, LL>{0, 0}; ++i) {\n    h1 = (h1 + i) & kMask;\n  }\n  other_hash[h1] = p; //h2;\n  memo[h1] = val;\n}\n\n//map<pair<LL, LL>, GF> memo;\nGF AddPositions(LL x, LL y, int bb = 60) {\n  if (x == 0 && y == 0) { return 1; }\n  debug(\"?Any\", x, y);\n  \n  pair<LL, LL> p{x, y};\n  {\n    GF ans;\n    if (FindVal(p, ans)) { return ans; }\n  }\n\n  int bit = 63 - __builtin_clzll(x + y);\n  while ((1LL << bit) > x + y) { --bit; }\n  if (x >= (1LL << bit)) {\n    GF ans = Mul(base[bit], AddPositions(x ^ (1LL << bit), y));\n    debug(x, y, ans);\n    PutVal(p, ans);\n    return ans;\n  }\n\n  // x < 2^bit <= x + y\n  GF answer1 = AddPositionsUpTo(x, y, (1LL << bit) - 1);\n  GF answer2 = AddPositionsFrom(x, y, (1LL << bit));\n  debug(x, y, answer1, answer2);\n  answer1 = Add(answer1, answer2);\n  PutVal(p, answer1);\n  return answer1;\n}\n\nGF GetValue(LL x) {\n  if (!x) { return 1; }\n  static map<LL, GF> val_memo;\n  auto it = val_memo.find(x);\n  if (it != val_memo.end()) { return it->nd; }\n\n  GF ans = 1;\n  for (int bit = 63 - __builtin_clzll(x); bit >= 0; --bit) {\n    if ((x >> bit) & 1) {\n      ans = Mul(base[bit], ans);\n    }\n  }\n  debug(\"Value\", x, ans);\n  return val_memo[x] = ans;\n}\n\nGF AddPositionsUpTo(LL x, LL y, LL max_val) {\n  debug(\"?UpTo\", x, y, max_val);\n  if (x > max_val) { return 0; }\n  if (x + y <= max_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int a = ((63 - __builtin_clzll(y)) >> 3) << 3; a >= 0; a -= 8) {\n    if (!((y >> a) & 0xff)) { continue; }\n    for (int bit = a + 7; bit >= a; --bit) {\n      if (!((y >> bit) & 1)) { continue; }\n      const LL v = 1LL << bit;\n      y ^= v;\n\n      if (x + v - 1 <= max_val) {\n        debug(\"UpTo\", orig_x, orig_y, max_val, x, y);\n        answer = Add(answer, AddPositions(x, y));\n        x += v;\n      }\n    }\n  }\n  /*for (int bit = 60; bit >= 0; --bit) {\n  }*/\n  debug(answer);\n  if (x <= max_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF AddPositionsFrom(LL x, LL y, LL min_val) {\n  if (x + y < min_val) { return 0; }\n  if (x >= min_val) { return AddPositions(x, y); }\n  const LL orig_x = x, orig_y = y;\n\n  GF answer = 0;\n  for (int bit = 63 - __builtin_clzll(y); bit >= 0; --bit) {\n    if (!((y >> bit) & 1)) { continue; }\n    const LL v = 1LL << bit;\n    y ^= v;\n\n    if (x + v >= min_val) {\n      answer = Add(answer, AddPositions(x + v, y));\n    } else {\n      x += v;\n    }\n  }\n  debug(\"From\", orig_x, orig_y, min_val, answer, x);\n  if (x >= min_val) { answer = Add(answer, GetValue(x)); }\n  return answer;\n}\n\nGF GetRandom() {\n  GF ans = 0;\n  for (int i = 0; i < 4; ++i) {\n    ans <<= 16;\n    ans |= (rand() % (1 << 16));\n  }\n  return ans;\n}\n\nint32_t main() {\n#ifndef LOCAL\n  ios_base::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(11);\n  cerr << fixed << setprecision(6);\n#endif\n\n#ifdef TESTING\n  while (true) {\n    GF a = GetRandom(), b = GetRandom(), c = GetRandom();\n    GF d = Mul(a, Add(b, c));\n    GF e = Add(Mul(a, b), Mul(a, c));\n    debug(a,b,c,d,e);\n    assert(d == e);\n  }\n#endif\n\n  srand(2137);\n\n#warning\n  const int S = 58;\n//  const int S = 58;\n  const LL kLarge = 1LL << S;\n  for (int i = 0; i < 70; ++i) {\n    GF x = GetRandom();\n    base.PB(x);\n  }\n  debug(base);\n\n  int N;\n  cin >> N;\n  //mini(N, 7500LL);\n  vector<pair<LL, LL>> values;\n\n  auto TotalGF = [&](LL bound) {\n    GF ans = 0;\n    for (auto &val : values) {\n      ans = Add(ans, AddPositionsUpTo(val.st, val.nd, bound));\n    }\n    debug(bound, ans);\n    return ans;\n  };\n\n  for (int i = 0; i < N; ++i) {\n    LL x, y;\n    cin >> x >> y;\n    values.emplace_back(x + kLarge, y + kLarge);\n  }\n\n  debug(values);\n\n  LL Lzero = 0, Rzero = (1LL << (S + 2));\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == 0) {\n      Lzero = midzero;\n    } else {\n      Rzero = midzero;\n    }\n  }\n\n  const LL first_x = Rzero - kLarge;\n  \n  Lzero = 0; Rzero = (1LL << (S + 2));\n  const GF aim = TotalGF(Rzero);\n\n  while (Rzero - Lzero > 1) {\n    const int midzero = (Lzero + Rzero) / 2;\n    if (TotalGF(midzero) == aim) {\n      Rzero = midzero;\n    } else {\n      Lzero = midzero;\n    }\n  }\n\n  const LL last_x = Rzero - kLarge;\n\n  cout << first_x << \" \" << last_x - first_x - kLarge << \"\\n\";\n  //cout << memo.size() << \"\\n\";\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n  \tc=0;\n  \tfor (pin& x : qab[1]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n  \tif (!c) {\n\t\tans.first *= 2; ans.second *= 2;\n\t\treturn ans;\n\t}\n\tc = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint w = ans.second - x.second-1;\n\t\tif ((w & x.first) == w) { c ^= 1; }\n\t}\n\tans.first *= 2; ans.first++; ans.second *= 2; ans.second -= c;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n      \tint qc=2*x.first+x.second+1;\n\tqc = (qc & (int)(0xffffffff)) + ((qc & (0x7fffffff00000000)) >> 32);\n\tqc = (qc & (int)(0xffffffff)) + ((qc & (int)(0x100000000)) >> 32);\n\tqc = (qc & (0xffff)) + ((qc & (int)(0xffff0000)) >> 16);\n\tqc = (qc & (0xffff)) + ((qc & (0x10000)) >> 16);\n\tqc = (qc & (0xff)) + ((qc & (0xff00)) >> 8);\n\tqc = (qc & (0xff)) + ((qc & (0x100)) >> 8);\n\tqc = (qc & (0xf)) + ((qc & (0xf0)) >> 4);\n\tqc = (qc & (0xf)) + ((qc & (0x10)) >> 4);\n\tqc = (qc & 3) + ((qc & 12) >> 2);\n\tqc = (qc & 3) + ((qc & 4) >> 2);\n\t\tc ^= qc;\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<assert.h>\ntypedef long long ll;\nconst ll inf=1e17;\nll f[3][2],g[3][2];\n//f[i][j][k]:i~60 ok, %3=j, locked?\nll s[3];\nvoid dp(ll n,ll m){//sum[i<=m & i in n & i%3=r]\n\tif(m<0){\n\t\tmemset(s,0,sizeof(s));\n\t\treturn;\n\t}\n\tint i,j;\n\tmemset(f,0,sizeof(f));\n\tf[0][1]=1;\n\tfor(i=60;i>=0;i--){\n\t\tmemset(g,0,sizeof(g));\n\t\tfor(j=0;j<3;j++){\n\t\t\tg[j][0]+=f[j][0];\n\t\t\tif(n>>i&1)g[(j+(1ll<<i))%3][0]+=f[j][0];\n\t\t\tif(m>>i&1){\n\t\t\t\tg[j][0]+=f[j][1];\n\t\t\t\tif(n>>i&1)g[(j+(1ll<<i))%3][1]+=f[j][1];\n\t\t\t}else\n\t\t\t\tg[j][1]+=f[j][1];\n\t\t}\n\t\tmemcpy(f,g,sizeof(g));\n\t}\n\tfor(i=0;i<3;i++)s[i]=f[i][0]+f[i][1];\n}\nll get(ll n,ll l,ll r,int t){\n\tdp(n,r);\n\tll s=::s[t];\n\tdp(n,l-1);\n\treturn s-::s[t];\n}\nll x[10010],y[10010];\nint n;\nconst ll c=2*inf;\nll get(ll l,ll r,int t){\n\tll s;\n\tint i;\n\ts=0;\n\tfor(i=1;i<=n;i++)s+=get(c-x[i]-y[i],l-x[i],r-x[i],((t-x[i])%3+3)%3);\n\treturn s;\n}\nbool C(ll n,ll k){return(n&k)==k;}\nbool light(ll a){\n\tint i,f=0;\n\tfor(i=1;i<=n;i++){\n\t\tif(x[i]<=a)f^=C(c-x[i]-y[i],a-x[i]);\n\t}\n\treturn f;\n}\nint main(){\n\tint i;\n\tll l,r,mid,x1,x2;\n\tbool flag;\n\tscanf(\"%d\",&n);\n\tfor(i=1;i<=n;i++)scanf(\"%lld%lld\",x+i,y+i);\n\tl=-inf;\n\tr=inf;\n\twhile(l<r){\n\t\tmid=(l+r)>>1;\n\t\tflag=0;\n\t\tfor(i=0;i<3;i++){\n\t\t\tif(get(l,mid,i)&1){\n\t\t\t\tflag=1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(flag)\n\t\t\tr=mid;\n\t\telse\n\t\t\tl=mid+1;\n\t}\n//\tassert(light(l));\n\tx1=x2=l;\n\tfor(i=60;i>=0;i--){\n\t\tif(light(x1-(1ll<<i)))x1-=1ll<<i;\n\t\tif(light(x2+(1ll<<i)))x2+=1ll<<i;\n\t}\n\tprintf(\"%lld %lld\",x1,c-x2);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define V vector\n#define L long\n#define W V<L>\n#define R(n)for(L i=0;i<n;i++)\nL E=70;W S(V<W>p){if(!E){return{1,0};}V<V<W>>T(2);for(W x:p){T[x[1]&1].push_back({x[0]/2,x[1]/2});if(x[0]&1){T[(x[1]+1)&1].push_back({x[0]/2,(x[1]+1)/2});}}R(2){L c=0;for(W x:T[!i]){L Q=(2*x[0]+x[1])%3;c^=Q+1;}if(!c){E--;W A=S(T[i]);A[0]*=2;A[1]*=2;A[1]+=i;return A;}}for(W&v:p){v[0]++;}W A=S(p);A[0]--;return A;}int main(){L M=2e17,n,a,b;cin>>n;V<W>p(n);R(n){cin>>a>>b;p[i]={a+M,b+M};}W x=S(p);cout<<x[0]-M<<\" \"<<x[1]-M;}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,a,b) for(int i = (a); i < (b); ++i)\n#define rrep(i,a,b) for(int i = (b); i --> (a);)\n#define trav(x,v) for(auto  &x : v)\n#define all(v) (v).begin(),(v).end()\n#define sz(v) (int)(v).size()\ntypedef pair<int,int> pii;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<ll,ll> pll;\n\nconst int k = 13;\nconst int mxc = (1<<k)+1;\ntypedef bitset<mxc> bbs;\n\nll gcd(ll a, ll b){\n\twhile(b){\n\t\ta %= b;\n\t\tswap(a,b);\n\t}\n\treturn a;\n}\n\nll inv(ll a, ll b){\n\treturn a>1 ? b - inv(b%a,a)*b/a : 1LL;\n}\n\npll crt(pll a, pll b){\n\tll m, n, x, y;\n\ttie(m,x) = a;\n\ttie(n,y) = b;\n\tll d = gcd(m,n);\n\trep(q,0,n/d) if((x+m*q)%n == y)\n\t\treturn pll(n/d*m, (x + m*q)%(n/d*m));\n\treturn pll(-1,-1);\n}\n\nint zz(bbs &r, int per){\n\tint ans = 0;\n\trep(i,0,per) if(r[i] < r[(i+per-1)%per]){\n\t\tint cur = 1;\n\t\twhile(!r[(i+cur)%per]) ++cur;\n\t\tans = max(ans, cur);\n\t}\n\treturn ans;\n}\n\nint main(){\n\tcin.sync_with_stdio(0); cin.tie(0);\n\tcin.exceptions(cin.failbit);\n\n\tint n;\n\tcin >> n;\n\tvector<ll> xs(n), ys(n);\n\n\trep(i,0,n) cin >> xs[i] >> ys[i];\n\n\tvi ls = {7,8,9,10,11,12,13};\n\tint m = sz(ls);\n\tvi rs(m);\n\n\tpll yy(1,0), xx(1,0);\n\t\n\ttrav(q, ls){\n\t\tint rp = (1<<q)-1, cp = (1<<q)+1;\n\t\tvector<bbs> rs(rp);\n\t\trep(i,0,rp) rep(j,0,i+2) if( ((i+1)&j) == j )\n\t\t\trs[i].set(cp-j-1);\n\t\tbbs resy(0), resx(0);\n\t\tauto fun = [&](bbs &res, ll x, ll y){\n\t\t\tll q = y / rp;\n\t\t\tif(q*rp > y) --q;\n\t\t\ty -= q*rp;\n\t\t\tx -= q;\n\t\t\tx %= cp;\n\t\t\tif(x < 0) x += cp;\n\t\t\tres ^= rs[y]>>x;\n\t\t\tres ^= rs[y]<<(cp-x);\n\t\t};\n\t\trep(t,0,n){\n\t\t\tfun(resy, xs[t], ys[t]);\n\t\t\tfun(resx, ys[t], xs[t]);\n\t\t}\n\t\tyy = crt(yy, pll(rp, rp-zz(resy,cp)));\n\t\txx = crt(xx, pll(rp, rp-zz(resx,cp)));\n\t}\n\tif(yy.second > 1e17) yy.second -= yy.first;\n\tif(xx.second > 1e17) xx.second -= xx.first;\n\tcout << xx.second << ' ' << yy.second << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll=long long;\n#define int ll\n\n#define rng(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,b) rng(i,0,b)\n#define gnr(i,a,b) for(int i=int(b)-1;i>=int(a);i--)\n#define per(i,b) gnr(i,0,b)\n#define pb push_back\n#define eb emplace_back\n#define a first\n#define b second\n#define bg begin()\n#define ed end()\n#define all(x) x.bg,x.ed\n#define si(x) int(x.size())\n#ifdef LOCAL\n#define dmp(x) cerr<<__LINE__<<\" \"<<#x<<\" \"<<x<<endl\n#else\n#define dmp(x) void(0)\n#endif\n\ntemplate<class t,class u> void chmax(t&a,u b){if(a<b)a=b;}\ntemplate<class t,class u> void chmin(t&a,u b){if(b<a)a=b;}\n\ntemplate<class t> using vc=vector<t>;\ntemplate<class t> using vvc=vc<vc<t>>;\n\nusing pi=pair<int,int>;\nusing vi=vc<int>;\n\ntemplate<class t,class u>\nostream& operator<<(ostream& os,const pair<t,u>& p){\n\treturn os<<\"{\"<<p.a<<\",\"<<p.b<<\"}\";\n}\n\ntemplate<class t> ostream& operator<<(ostream& os,const vc<t>& v){\n\tos<<\"{\";\n\tfor(auto e:v)os<<e<<\",\";\n\treturn os<<\"}\";\n}\n\n#define mp make_pair\n#define mt make_tuple\n#define one(x) memset(x,-1,sizeof(x))\n#define zero(x) memset(x,0,sizeof(x))\n#ifdef LOCAL\nvoid dmpr(ostream&os){os<<endl;}\ntemplate<class T,class... Args>\nvoid dmpr(ostream&os,const T&t,const Args&... args){\n\tos<<t<<\" \";\n\tdmpr(os,args...);\n}\n#define dmp2(...) dmpr(cerr,__LINE__,##__VA_ARGS__)\n#else\n#define dmp2(...) void(0)\n#endif\n\nusing uint=unsigned;\nusing ull=unsigned long long;\n\ntemplate<class t,size_t n>\nostream& operator<<(ostream&os,const array<t,n>&a){\n\treturn os<<vc<t>(all(a));\n}\n\ntemplate<int i,class T>\nvoid print_tuple(ostream&,const T&){\n}\n\ntemplate<int i,class T,class H,class ...Args>\nvoid print_tuple(ostream&os,const T&t){\n\tif(i)os<<\",\";\n\tos<<get<i>(t);\n\tprint_tuple<i+1,T,Args...>(os,t);\n}\n\ntemplate<class ...Args>\nostream& operator<<(ostream&os,const tuple<Args...>&t){\n\tos<<\"{\";\n\tprint_tuple<0,tuple<Args...>,Args...>(os,t);\n\treturn os<<\"}\";\n}\n\ntemplate<class t>\nvoid print(t x,int suc=1){\n\tcout<<x;\n\tif(suc==1)\n\t\tcout<<\"\\n\";\n\tif(suc==2)\n\t\tcout<<\" \";\n}\n\nll read(){\n\tll i;\n\tcin>>i;\n\treturn i;\n}\n\nvi readvi(int n,int off=0){\n\tvi v(n);\n\trep(i,n)v[i]=read()+off;\n\treturn v;\n}\n\ntemplate<class T>\nvoid print(const vector<T>&v,int suc=1){\n\trep(i,v.size())\n\t\tprint(v[i],i==int(v.size())-1?suc:2);\n}\n\nstring readString(){\n\tstring s;\n\tcin>>s;\n\treturn s;\n}\n\ntemplate<class T>\nT sq(const T& t){\n\treturn t*t;\n}\n\n//#define CAPITAL\nvoid yes(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"YES\"<<\"\\n\";\n\t#else\n\tcout<<\"Yes\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid no(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"NO\"<<\"\\n\";\n\t#else\n\tcout<<\"No\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid possible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"POSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Possible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\nvoid impossible(bool ex=true){\n\t#ifdef CAPITAL\n\tcout<<\"IMPOSSIBLE\"<<\"\\n\";\n\t#else\n\tcout<<\"Impossible\"<<\"\\n\";\n\t#endif\n\tif(ex)exit(0);\n}\n\nconstexpr ll ten(int n){\n\treturn n==0?1:ten(n-1)*10;\n}\n\nconst ll infLL=LLONG_MAX/3;\n\n#ifdef int\nconst int inf=infLL;\n#else\nconst int inf=INT_MAX/2-100;\n#endif\n\nint topbit(signed t){\n\treturn t==0?-1:31-__builtin_clz(t);\n}\nint topbit(ll t){\n\treturn t==0?-1:63-__builtin_clzll(t);\n}\nint botbit(signed a){\n\treturn a==0?32:__builtin_ctz(a);\n}\nint botbit(ll a){\n\treturn a==0?64:__builtin_ctzll(a);\n}\nint popcount(signed t){\n\treturn __builtin_popcount(t);\n}\nint popcount(ll t){\n\treturn __builtin_popcountll(t);\n}\nbool ispow2(int i){\n\treturn i&&(i&-i)==i;\n}\nll mask(int i){\n\treturn (ll(1)<<i)-1;\n}\n\nbool inc(int a,int b,int c){\n\treturn a<=b&&b<=c;\n}\n\ntemplate<class t> void mkuni(vc<t>&v){\n\tsort(all(v));\n\tv.erase(unique(all(v)),v.ed);\n}\n\nll rand_int(ll l, ll r) { //[l, r]\n\t#ifdef LOCAL\n\tstatic mt19937_64 gen;\n\t#else\n\tstatic mt19937_64 gen(chrono::steady_clock::now().time_since_epoch().count());\n\t#endif\n\treturn uniform_int_distribution<ll>(l, r)(gen);\n}\n\ntemplate<class t>\nvoid myshuffle(vc<t>&a){\n\trep(i,si(a))swap(a[i],a[rand_int(0,i)]);\n}\n\ntemplate<class t>\nint lwb(const vc<t>&v,const t&a){\n\treturn lower_bound(all(v),a)-v.bg;\n}\n\ntemplate<class t=ll>\nt extgcd(t a,t b,t&x,t&y){\n\tif(b==0){\n\t\tx=1;\n\t\ty=0;\n\t\treturn a;\n\t}else{\n\t\tt g=extgcd(b,a%b,y,x);\n\t\ty-=a/b*x;\n\t\treturn g;\n\t}\n}\n\n//x*y=g mod m\n//returns (g,y)\ntemplate<class t=ll>\npair<t,t> modinv(t x,t m){\n\tt a,b;\n\tt g=extgcd(x,m,a,b);\n\tif(a<0)a+=m/g;\n\treturn {g,a};\n}\n\nnamespace Nimber64{\n\tconst vi fs{3,5,17,257,641,65537,6700417};\n\tconst ull s=-1;\n\t\n\tull multiply_powers_of_2(ull,ull);\n\n\tull multiply(ull a,ull b) {\n\t   ull ans = 0;\n\t   rep(p1,64)if((a>>p1)&1)\n\t\t   rep(p2,64)if((b>>p2)&1)\n\t\t\t  ans=ans^multiply_powers_of_2(ull(1)<<p1,ull(1)<<p2);\n\t   return ans;\n\t}\n\tull multiply_powers_of_2(ull a, ull b) {\n\t\tif (a == 1 or b == 1) return a * b;\n\t\tint n=__lg(__lg(max(a,b)));\n\t\tull power = ull(1)<<(1<<n);\n\t\tif (a >= power and b >= power) {\n\t\t\treturn multiply(power * 3 / 2, multiply_powers_of_2(a / power, b / power));\n\t\t} else if (a >= power) {\n\t\t\treturn multiply_powers_of_2(a / power, b) * power;\n\t\t} else {\n\t\t\treturn multiply_powers_of_2(a, b / power) * power;\n\t\t}\n\t}\n\t\n\tstruct precalc{\n\t\tull tmp[64][64];\n\t\tunsigned char x[256][256];\n\t\tull y[8][8][256];\n\t\ttemplate<int len>\n\t\tull multfast(ull a,ull b){\n\t\t\tull c=0;\n\t\t\trep(i,len)if((a>>i)&1)rep(j,len)if((b>>j)&1)c^=tmp[i][j];\n\t\t\treturn c;\n\t\t}\n\t\tprecalc():tmp(),x(),y(){\n\t\t\trep(i,64)rep(j,64)tmp[i][j]=multiply_powers_of_2(1ULL<<i,1ULL<<j);\n\t\t\trep(i,256)rep(j,256)x[i][j]=multfast<8>(i,j);\n\t\t\trep(i,8)rep(j,i+1)rep(k,256)y[i][j][k]=multfast<64>(tmp[i*8][j*8],k);\n\t\t}\n\t\tull multfast2(ull a,ull b)const{\n\t\t\tull res=0;\n\t\t\trep(i,8){\n\t\t\t\trep(j,i){\n\t\t\t\t\tres^=y[i][j][\n\t\t\t\t\tx[(a>>(i*8))&255][(b>>(j*8))&255]^\n\t\t\t\t\tx[(a>>(j*8))&255][(b>>(i*8))&255]];\n\t\t\t\t}\n\t\t\t\tres^=y[i][i][x[(a>>(i*8))&255][(b>>(i*8))&255]];\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t};\n\tconst precalc buf;\n\t\n\tstruct nim{\n\t\tull v;\n\t\tnim(ull vv=0):v(vv){}\n\t\tnim& operator+=(const nim&rhs){v^=rhs.v;return *this;}\n\t\tnim& operator*=(const nim&rhs){v=buf.multfast2(v,rhs.v);return *this;}\n\t\tnim operator+(const nim&rhs)const{return nim(*this)+=rhs;}\n\t\tnim operator*(const nim&rhs)const{return nim(*this)*=rhs;}\n\t\tnim pow(ull n)const{\n\t\t\tnim res=1,x=*this;\n\t\t\twhile(n){\n\t\t\t\tif(n&1)res*=x;\n\t\t\t\tx*=x;\n\t\t\t\tn>>=1;\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t};\n\tistream& operator>>(istream&is,nim&x){\n\t\treturn is>>x.v;\n\t}\n\tostream& operator<<(ostream&os,const nim&x){\n\t\treturn os<<x.v;\n\t}\n\t\n\tpair<ull,ull> garnerull(vc<pi> z){\n\t\tull ans=0,w=1;\n\t\trep(i,si(z)){\n\t\t\tint x=z[i].a;\n\t\t\tans=(ans+w*x);\n\t\t\trng(j,i+1,si(z))\n\t\t\t\tz[j].a=(z[j].a+z[j].b-x%z[j].b)*modinv(z[i].b,z[j].b).b%z[j].b;\n\t\t\tw=(w*z[i].b);\n\t\t}\n\t\treturn {ans,w};\n\t}\n\t\n\t//returns minimum x s.t. a^x=b\n\t//and its period\n\t//returns (0,0) if infeasible\n\tpair<ull,ull> discrete_log(const nim a,const nim b){\n\t\tvc<pi> z;\n\t\tfor(auto f:fs){\n\t\t\tnim x=a.pow(s/f);\n\t\t\tnim y=b.pow(s/f);\n\t\t\tif(x.v==1){\n\t\t\t\tif(y.v==1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\treturn {0,0};\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tconst int L=ceil(sqrt(f-1));\n\t\t\tmap<ull,int> v;\n\t\t\t//hash_table<ull,int> v;\n\t\t\t{\n\t\t\t\tnim cur=1;\n\t\t\t\trep(i,L){\n\t\t\t\t\tauto itr=v.find(cur.v);\n\t\t\t\t\tif(itr==v.ed)v[cur.v]=i;\n\t\t\t\t\tcur*=x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans=-1;\n\t\t\t{\n\t\t\t\tnim cur=1;\n\t\t\t\tnim w=x.pow((f-1)*L);\n\t\t\t\tfor(int i=0;i<f;i+=L){\n\t\t\t\t\tnim tar=y*cur;\n\t\t\t\t\tauto itr=v.find(tar.v);\n\t\t\t\t\tif(itr!=v.ed){\n\t\t\t\t\t\tans=i+itr->b;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tcur*=w;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ans==-1)return {0,0};\n\t\t\tz.eb(ans,f);\n\t\t}\n\t\t\n\t\treturn garnerull(z);\n\t}\n\t\n\tbool checkprimitive(const nim a){\n\t\tfor(auto f:fs)if((a.pow(s/f)).v==1)return false;\n\t\treturn true;\n\t}\n}\nusing Nimber64::nim;\n\nusing int128=__int128_t;\nostream& operator<<(ostream&os,int128 i){\n\tif(i==0)\n\t\treturn os<<0;\n\tstatic char buf[100];\n\tif(i<0){\n\t\tos<<\"-\";\n\t\ti=-i;\n\t}\n\tint p=0;\n\twhile(i){\n\t\tbuf[p++]='0'+i%10;\n\t\ti/=10;\n\t}\n\treverse(buf,buf+p);\n\tbuf[p]=0;\n\treturn os<<buf;\n}\nint128 abs128(int128 a){\n\treturn a<0?-a:a;\n}\nint botbit(int128 a){\n\tconst int128 m=ull(-1);\n\tif(a&m)return __builtin_ctzll(ll(a));\n\telse return __builtin_ctzll(ll(a>>64));\n}\n\nsigned main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(0);\n\tcout<<fixed<<setprecision(20);\n\t\n\tnim ps[2]{ull(1)<<32|6,0};\n\tps[1]=ps[0].pow(23);\n\tdmp2(ps[0],ps[1]);\n\t\n\tint128 z[2];\n\trep(k,2)z[k]=Nimber64::discrete_log(ps[k],ps[k]+1).a;\n\t\n\tint128 mod=ull(-1);\n\t\n\tdmp2(z[0],z[1]);\n\t\n\tint128 dif=z[1]-z[0];\n\tif(dif<0)dif+=mod;\n\tdmp(dif);\n\t\n\tint128 g,inv;tie(g,inv)=modinv<int128>(dif,mod);\n\tdmp(g);\n\tdmp(inv);\n\tassert(g==1);\n\t\n\tint n;cin>>n;\n\tconst int off=ten(17);\n\tnim w[2];\n\trep(i,n){\n\t\tint128 x=read()+off;\n\t\tint128 y=read()+off;\n\t\trep(k,2){\n\t\t\tw[k]+=ps[k].pow(ull((x+z[k]*y)%mod));\n\t\t}\n\t}\n\t\n\tdmp(0);\n\t\n\tint128 v[2];\n\trep(k,2)v[k]=Nimber64::discrete_log(ps[k],w[k]).a;\n\t\n\tdmp(0);\n\t\n\tint128 y=(v[1]-v[0]+mod)*inv%mod;\n\tint128 x=(v[0]-z[0]*y%mod+mod)%mod;\n\t\n\tdmp(0);\n\t\n\tcout<<x-off<<\" \"<<y-off<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\nconst int maxn = 10000 + 10;\nconst int DEBUG = 0;\n\nint n;\nstruct anode{\n\tll x, y;\n\tanode() {}\n\tanode(ll _x, ll _y):x(_x), y(_y) {}\n}a[maxn];\nll c, Ans1, Ans2;\nll f[4][3], g[4][3];\n\nll dp(ll n, ll m, ll res) {\n\tif(m < 0) return 0;\n\tmemset(f,0,sizeof(f));\n\tf[0][1] = 1;\n\tfor(ll i = 60;i >= 0;i --) {\n\t\tmemset(g,0,sizeof(g));\n\t\tint m1 = (m >> i) & 1, n1 = (n >> i) & 1;\n\t\tfor(int j = 0;j < 3;j ++) {\n\t\t\tll nj = (j + (1LL << i) % 3) % 3;\n\t\t\tif(n1 && m1) g[nj][1] += f[j][1];\n\t\t\tif(n1) g[nj][0] += f[j][0];\n\t\t\tif(m1) g[j][0] += f[j][1];\n\t\t\telse g[j][1] += f[j][1];\n\t\t\tg[j][0] += f[j][0];\n\t\t}\n\t\tmemcpy(f,g,sizeof(f));\n\t}\n\tll tmp = (f[res][0] + f[res][1]) % 2;\n\treturn tmp;\n}\n\ninline ll get(ll n, ll l, ll r, ll res) {\n\tll t1 = dp(n,r,res);\n\tll t2 = dp(n,l - 1,res);\n\tll tmp = (t1 % 2 - t2 % 2) % 2;\n\treturn tmp;\n}\n\ninline ll get_val(ll l, ll r, ll res) {\n\tll tmp = 0;\n\tfor(int i = 1;i <= n;i ++) {\n\t\tll tl = l - a[i].x, tr = r - a[i].x, ts = (res % 3 - a[i].x % 3 + 3) % 3;\n    ll now = get(c - a[i].x - a[i].y,tl,tr,ts);\n\t\ttmp = (tmp + now) % 2;\n\t}\n\treturn tmp;\n}\n\ninline bool check(ll l, ll r) {\n\tint flag = 0;\n\tfor(int i = 0;i < 3;i ++) {\n\t\tif(get_val(l,r,0)) {\n\t\t\tflag = 1;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn flag;\n}\n\ninline ll work1() {\n\tll l = - 1e17, r = 1e17;\n\twhile(l < r) {\n    ll mid = (l + r) / 2LL;\n\t\tif(check(l,mid)) r = mid;\n\t\telse l = mid + 1;\n\t}\n\treturn l;\n}\n\ninline ll C(ll n, ll m) { return (n & m) == m; }\n\ninline bool light(ll x) {\n\tll tmp = 0;\n\tfor(int i = 1;i <= n;i ++) {\n\t\tif(a[i].x > x) continue;\n\t\ttmp = (tmp + C(c - a[i].x - a[i].y,x - a[i].x)) % 2;\n\t}\n\treturn tmp;\n}\n\ninline void work2(ll pos) {\n\tll l = pos, r = pos;\n  for(ll i = 60;i >= 0;i --) {\n\t\tif(light(l - (1LL << i))) l -= (1LL << i);\n\t\tif(light(r + (1LL << i))) r += (1LL << i);\n\t}\n\tAns1 = l, Ans2 = c - r;\n}\n\nint main() {\n  scanf(\"%d\", &n);\n\tfor(int i = 1;i <= n;i ++) scanf(\"%lld%lld\\n\", &a[i].x, &a[i].y);\n  c = 2e17;\n\tll pos = work1();\n//\tif(DEBUG) cout << light(pos) << endl;\n\twork2(pos);\n\tprintf(\"%lld %lld\\n\", Ans1, Ans2);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef unsigned long long ull;\ntypedef long double ld; \ntypedef tree<ii, null_type, less<ii>, rb_tree_tag, tree_order_statistics_node_update> pbds;\n\nvector<ii> vec;\n\nint color(ll x, ll y)\n{\n\tint ans=0;\n\tint n=vec.size();\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll x2=vec[i].fi; ll y2=vec[i].se;\n\t\tll d = x-x2;\n\t\tll h = y2-y;\n\t\tif(d<0||d>h) continue;\n\t\tif((d&h)==d) ans^=1;\n\t}\n\treturn ans;\n}\n\nll rnd(ll x)\n{\n\tll ans=0;\n\tfor(int i=0;i<5;i++)\n\t{\n\t\tans<<=15; ans^=rand();\n\t}\n\tans%=x;\n\treturn ans;\n}\n\nll rnd(ll l, ll r)\n{\n\treturn l+rnd(r-l+1);\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tint n; cin>>n;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tll x,y; cin>>x>>y; vec.pb({x,y});\n\t}\n\tll C = -((1LL<<61)-1);\n\tll cur = 0;\n\twhile(!color(cur,C))\n\t{\n\t\tC=rnd(-ll(2e18),-ll(3e17));\n\t\tint tmp=rnd(0,n-1);\n\t\tll x=vec[tmp].fi; ll y=vec[tmp].se;\n\t\tll h=y-C;\n\t\tfor(int i=0;i<62;i++)\n\t\t{\n\t\t\tif(h&(1LL<<i))\n\t\t\t{\n\t\t\t\tif(rand()&1) x+=(1LL<<i);\n\t\t\t}\n\t\t}\n\t\tcur=x;\n\t}\n\tfor(int i=62;i>=0;i--)\n\t{\n\t\tif(color(cur-(1LL<<i),C)) cur-=(1LL<<i);\n\t}\n\tll l = cur;\n\tfor(int i=62;i>=0;i--)\n\t{\n\t\tif(color(cur+(1LL<<i),C)) cur+=(1LL<<i);\n\t}\n\tll r = cur;\n\tcout<<l<<' '<<C+(r-l)<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "/**************************************************************\n    Problem: 3514\n    User: 2019gz04\n    Language: C++\n    Result: Accepted\n    Time:616 ms\n    Memory:4432 kb\n****************************************************************/\n \n \n// #pragma GCC target(\"popcnt\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define il inline\n#define elif else if\n \n// Type\n#define ld double\n#define ll long long\n#define ull unsigned ll\n \n// Vector\n#define vc vector\n#define Pb push_back\n#define Pf push_front\n#define Eb emplace_back\n#define All(x) x.begin(),x.end()\n#define AllRev(x) x.rbegin(),x.rend()\n \n// Memory\n#define Ms(_data) memset(_data,0,sizeof(_data))\n#define Msn(_data,_num) memset(_data,_num,sizeof(_data))\n \n// Template\n#define _cl class\n#define _tp template\n#define _tyn typename\n \n// Pair\n#define Mp make_pair\n#define F first\n#define S second\n#define pii pair<int,int>\n#define pli pair<ll,int>\n#define pil pair<int,ll>\n#define pll pair<ll,ll>\n \n// Loop\n#define For(i,j) for( int (i) = 1 ; (i) <= (j) ; ++(i) )\n#define For0(i,j) for( int (i) = 0 ; (i) < (j) ; ++(i) )\n#define Forx(i,j,k) for( int (i) = (j) ; (i) <= (k) ; ++(i) )\n#define Forstep(i,j,k,st) for( int (i) = (j) ; (i) <= (k) ; (i) += (st) )\n#define fOR(i,j) for( int (i) = (j) ; (i) >= 1 ; --(i) )\n#define fOR0(i,j) for( int (i) = (j)-1 ; (i) >= 0 ; --(i) )\n#define fORx(i,j,k) for( int (i) = (k) ; (i) >= (j) ; --(i) )\n \n// Read\nstruct InputReader{\n    #define bs 1048576\n    char buf[bs]; int p;\n    il InputReader(){ p = bs; }\n    il void Flush(){ p = 0; fread(buf,1,bs,stdin); }\n    il char C(){ if(p >= bs) Flush(); return buf[p++]; }\n    il char Readnum(){ char ch = C(); while( !isdigit(ch) && ch != '-' ) ch = C(); return ch; }\n    il void Readalpha( char &c ){ c = C(); while( !isalpha(c) ) c = C(); }\n    int operator() (){\n        int ans = 0, fu = 1; char ch = Readnum();\n        if( ch == '-' ) fu = -1, ch = C();\n        while( ch >= '0' && ch <= '9' ){\n            ans = ans*10 + ch-'0';\n            ch = C();\n        }\n        return ans * fu;\n    }\n    ll Readll(){\n        ll ans = 0LL, fu = 1LL; char ch = Readnum();\n        if( ch == '-' ) fu = -1LL, ch = C();\n        while( ch >= '0' && ch <= '9' ){\n            ans = ans*10LL + ch-'0';\n            ch = C();\n        }\n        return ans * fu;\n    }\n    il void Readstring( string &x ){\n        x.clear(); char ch = C();\n        while( !isdigit(ch)  &&  !isalpha(ch)  &&  ch != '#'  &&  ch != '.' ) ch = C();\n        while( isdigit(ch)  ||  isalpha(ch)  ||  ch == '#'  ||  ch == '.' ){\n            x += ch;\n            ch = C();\n        }\n    }\n    il void Readchstring( char s[] ){\n        int len = 0; char ch = C();\n        while( !isdigit(ch)  &&  !isalpha(ch)  /*&&  ch != '*'  &&  ch != '?'*/ ) ch = C();\n        while( isdigit(ch)  ||  isalpha(ch)  /*||  ch == '*'  ||  ch == '?'*/ ){\n            s[len++] = ch;\n            ch = C();\n        }\n        s[len] = '\\0';\n    }\n    il void Specialread( char &c ){\n        c = C();\n        while( !isdigit(c) && !isalpha(c) && c != '#'  &&  c != '.'  &&  c != '='  &&  c != 'B' ) c = C();\n    }\n    #undef bs\n}In;\nil void Read( int &x ){ x = In(); }\nil void Read( int &x, int &y ){ x = In(); y = In(); }\nil void Read( int &x1 , int &x2 , int &x3 ){ x1 = In(); x2 = In(); x3 = In(); }\nil void Read( int &x1 , int &x2 , int &x3 , int &x4 ){ x1 = In(); x2 = In(); x3 = In(); x4 = In(); }\nil void Read( ll &x ){ x = In.Readll(); }\nil void Read( ll &x, ll &y ){ x = In.Readll(); y = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); }\nil void Read( ll &x1 , ll &x2 , ll &x3 , ll &x4 ){ x1 = In.Readll(); x2 = In.Readll(); x3 = In.Readll(); x4 = In.Readll(); }\n_tp<_tyn T> void Read( T a[] , int st , int ed ){ Forx(i,st,ed) Read(a[i]); }\n#define iRead(k) int k; Read(k);\n#define iRead2(a,b) iRead(a); iRead(b);\n#define iRead3(a,b,c) iRead2(a,b); iRead(c);\n#define iRead4(a,b,c,d) iRead2(a,b); iRead2(c,d);\n#define lRead(k) ll k; Read(k);\n#define lRead2(a,b) lRead(a); lRead(b);\n#define lRead3(a,b,c) lRead2(a,b); lRead(c);\n#define lRead4(a,b,c,d) lRead2(a,b); lRead2(c,d);\n \n// File\n#define Fin(a) freopen(a,\"r\",stdin)\n#define Fout(a) freopen(a,\"w\",stdout)\nil void FILEIO(){\n    #ifdef intLSY\n        Fin(\"in.in\");\n    #endif\n}\nil void FILEIO( string pname ){\n    #ifndef intLSY\n        Fin((pname+\".in\").c_str());\n        Fout((pname+\".out\").c_str());\n    #else\n        Fin(\"in.in\");\n    #endif\n}\nil void FILEIO_OICONTEST( string pname ){\n    Fin((pname+\".in\").c_str());\n    #ifndef intLSY\n        Fout((pname+\".out\").c_str());\n    #endif\n}\nvoid Printtime(){\n    #ifdef intLSY\n        double _timeuse = clock()* 1000.0 / CLOCKS_PER_SEC;\n        fprintf(stderr,\"\\n\\nTime usage:\\n%.0lf ms\\n\",_timeuse);\n    #endif\n}\nvoid END(){ Printtime(); exit(0); }\n_tp<_tyn T>void END( T mes ){ cout << mes << endl; END(); }\n \n// Debug\n#define B cerr << \"Breakpll\" << endl;\n#define O(x) cerr << #x << \" \" << x << endl;\n#define O_(x) cerr << #x << \" \" << x << \"  \";\n#define ERR(x) cerr << \"ERR! #\" << x << endl;\n#define Msz(x) cerr << \"Sizeof \" << #x << \" \" << sizeof(x)/1024/1024 << \" MB\" << endl;\n_tp<_tyn T>void Print( T a[] , int s , int t , char sp = ' ' , char ed = '\\n' ){\n    if( s > t ) return;\n    for( int i = s ; i < t ; i++ )\n        cout << a[i] << sp;\n    cout << a[t] << ed;\n    cout.flush();\n}\n_tp<_tyn T>void Print( T a , int s = 0 , int t = -1 , char sp = ' ' , char ed = '\\n' ){\n    if( t == -1 ) t = a.size()-1;\n    for( int i = s ; i <= t ; i++ )\n        cout << a[i] << sp;\n    cout << ed;\n    cout.flush();\n}\n \n// Optimize\n#define max(a,b) ((a)>(b)?(a):(b))\n#define min(a,b) ((a)<(b)?(a):(b))\n#define Mymax(a,b) (a) = max((a),(b))\n#define Mymin(a,b) (a) = min((a),(b))\n#define INF (0x3f3f3f3f)\n#define LINF ((long long)(0x3f3f3f3f3f3f3f3f))\n#define Sqr(x) ((x)*(x))\n#define Lowbit(a) ((a)&(-(a)))\nvc<int> Range( int l , int r ){\n    vc<int> ret{};\n    Forx(i,l,r) ret.Pb(i);\n    return ret;\n}\n#define abs(x) ((x)<0?-(x):(x))\n///////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////\n#define MAXN 10010\nmt19937 Rand( 20031111LL * 20021126 % 20031208 * time(0) );\n \nint n;\npll p[MAXN];\n \nil pll Neq2( const pll &p1 , const pll &p2 , bool &legal ){\n    // if( p1.F == p1.S and p2.F == p2.S ){ legal = 0; return p1; }\n    static pll ans;\n    static ll dt;\n    if( p1.F == p2.F ){\n        dt = abs(p2.S-p1.S);\n        ans = {p1.F+dt,min(p1.S,p2.S)};\n    }elif( p1.S == p2.S ){\n        dt = abs(p2.F-p1.F);\n        ans = {min(p1.F,p2.F),p1.S+dt};\n    }elif( abs(p1.F-p2.F) == abs(p1.S-p2.S) ){\n        dt = abs(p1.F-p2.F);\n        ans = {min(p1.F,p2.F),min(p1.S,p2.S)};\n    }else{\n        legal = 0;\n        return p1;\n    }\n    legal = __builtin_popcountll(dt) == 1;\n    return ans;\n}\n \nnamespace ThisIsNotSoCorrect{\n    vc<pll> known;\n    queue<pll> unknown;\n    unordered_set<ll> hmap;\n    il int Msk( const pll &p ){\n        ll msk = (p.F<<10LL) + p.S*233 + p.F%20031111*p.S%20021126 / 3 + p.F%20031111*p.F%20021126/4 + p.S*p.S/8 + p.F + p.S + 1;\n        return msk;\n    }\n    void Solve(){\n        pll last_inserted;\n        For(i,n) unknown.emplace(p[i]);\n        while(!unknown.empty()){\n            pll u = unknown.front();\n            unknown.pop();\n            ll umsk = Msk(u);\n            if(hmap.count(umsk)) continue;\n            for( auto v : known ){\n                bool legal;\n                pll w = Neq2(u,v,legal);\n                if(!legal) continue;\n                int wmsk = Msk(w);\n                if(!hmap.count(wmsk))\n                    unknown.emplace(w);\n            }\n            known.Eb(u);\n            hmap.insert(umsk);\n            last_inserted = u;\n        }\n        printf(\"%lld %lld\\n\",last_inserted.F,last_inserted.S);\n    }\n}\n \nint main(){\n    FILEIO();\n \n    Read(n);\n    For(i,n) Read(p[i].F,p[i].S);\n \n    if( n == 1 ){\n        printf(\"%lld %lld\\n\",p[1].F,p[1].S);\n        END();\n    }\n \n    if( n == 2 ){\n        bool legal;\n        pll ans = Neq2(p[1],p[2],legal);\n        printf(\"%lld %lld\\n\",ans.F,ans.S);\n        // O(legal);\n        END();\n    }\n \n    ThisIsNotSoCorrect::Solve();\n \n    END();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n#define int long long\n#define V vector\n#define vel V<int>\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mkp make_pair\n#define pin pair<int,int>\npin solve(V<pin>& ab, int ex) {\n\tif (!ex) { return mkp(0, 0); }\n\tV<V<pin>> qab(2);\n\tint sz = ab.size();\n\tqab[0].reserve(sz);\n\tqab[1].reserve(sz);\n\tfor (pin& x : ab) {\n\t\tqab[x.second & 1].push_back(mkp(x.first / 2, x.second / 2));\n\t\tif (x.first & 1) { qab[(x.second + 1) & 1].push_back(mkp(x.first / 2, (x.second + 1) / 2)); }\n\t}\n\tint c = 0;\n\tfor (pin& x : qab[0]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t}\n\tif (!c) {\n\t\tpin ans = solve(qab[1], ex - 1);\n\t\tans.first *= 2; ans.second *= 2; ans.second++;\n\t\treturn ans;\n\t}\n\tpin ans = solve(qab[0], ex - 1);\n\tc = 0;\n\tint d = 0;\n\tfor (pin& x : qab[1]) {\n\t\tint qc = (2 * x.first + x.second) % 3;\n\t\tc ^= (qc + 1);\n\t\tint w = ans.second - x.second - 1;\n\t\tif ((w & x.first) == w) { d ^= 1; }\n\t}\n  \tans.first *= 2; ans.first+=c; ans.second *= 2;\n\tif (!c) {\n\t\tans.first *= 2; ans.second *= 2;\n\t\treturn ans;\n\t}\n  ans.second -= d;\n\treturn ans;\n}\nsigned main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tlong long inf = 1e17;\n\tint n; cin >> n;\n\tV<pin> ab(n);\n\trep(i, n) {\n\t\tlong long a, b; cin >> a >> b;\n\t\tab[i] = { a + inf,b + inf };\n\t}\n\tpin ret = solve(ab, 59);\n\tcout << ret.first - inf << \" \" << ret.second - inf << \"\\n\";\n}\n"
  },
  {
    "language": "Text",
    "code": "記念提出"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n#define cval 666666666666666666\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid prarr(long long arr[],long long n){\n  long long i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%lld\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\n//パスカルの三角形のfloor C 0~floor C limまでの黒マスカウント\n//但し、mod3で分類\n//lucasの定理に基づくアルゴリズム\nvoid digdp(long long floor,long long lim,long long res[4]){\n    if(floor<lim){lim=floor;}\n    long long dp[64][4][2]={0},i,j,w;\n    //dp[今上から何桁目まで埋めたか][3で割った余り][下のbitによってはlimを超えうるかどうか];\n    dp[63][0][1]=1;\n    for(i=62;i>=0;i--){\n        if(i%2==0){w=1;}else{w=2;}\n        for(j=0;j<3;j++){\n            //末尾bitが0\n            dp[i][j][0]+=dp[i+1][j][0];\n            if((lim&(1ll<<i))!=0){\n                dp[i][j][0]+=dp[i+1][j][1];\n            }\n            else{\n                dp[i][j][1]+=dp[i+1][j][1];\n            }\n            //0C1が起きるなら黒点にならないので遷移なし、起きないなら遷移あり\n            if((floor&(1ll<<i))!=0){\n                //末尾bitが1\n                dp[i][(j+w)%3][0]+=dp[i+1][j][0];\n                if((lim&(1ll<<i))!=0){\n                    dp[i][(j+w)%3][1]+=dp[i+1][j][1];\n                }\n            }\n        }\n    }\n    res[0]=dp[0][0][0]+dp[0][0][1];\n    res[1]=dp[0][1][0]+dp[0][1][1];\n    res[2]=dp[0][2][0]+dp[0][2][1];\n    //prarr(res,3);\n    //printf(\"\\n\");\n}\n\n//floor C st ~ floor C fiまでのmod 3別黒点の数\nvoid rgdigdp(long long floor,long long st,long long fi,long long res[4]){\n  if(st<0){st=0;}\n  if(fi>floor){fi=floor;}\n  if(st>fi){\n    res[0]=0;\n    res[1]=0;\n    res[2]=0;\n    return;\n  }\n  long long sr[4]={0},fr[4]={0};\n  if(st!=0){\n    digdp(floor,st-1,sr);\n  }\n  digdp(floor,fi,fr);\n  res[0]=fr[0]-sr[0];\n  res[1]=fr[1]-sr[1];\n  res[2]=fr[2]-sr[2];\n}\n\n//nCr mod2\n//Find the color of Pascal's Triangle\n//based on Lucas's Theorem(https://mathtrain.jp/lucastheorem)\nlong long nCrbit(long long n,long long r){\nif(n<0 || r<0){return 0;}\nif(n<r){return 0;}\nif((n|r)!=n){return 0;}\nreturn 1;\n}\n\nlong long n,x[16384],y[16384];\nlong long findcol(long long a,long long b){\n    long long i,r=0,p,q;\n    for(i=0;i<n;i++){\n        if(a-x[i]<0 || b-y[i]<0){continue;}\n        p=(a-x[i])+(b-y[i]);\n        q=(b-y[i]);\n        r^=nCrbit(p,q);\n    }\n    return r;\n}\n\nint main(void){\n    long long i,j,m,k,a,b,c,h,w,r,l,t;\n    long long base=-(1ll<<58),bm,np;\n    long long get[4]={0},tot[4]={0};\n    long long bx,by,hs;\n    long long lx,hx;\n    scanf(\"%lld\",&n);\n    for(i=0;i<n;i++){\n      scanf(\"%lld%lld\",&x[i],&y[i]);\n    }\n    for(i=0;i<n;i++){\n      //基準点からの高さ\n      w=(y[i]-base)%3;\n      //三角形の何段目か\n      l=cval-x[i]-y[i];\n      digdp(l,llinf,get);\n      tot[w]+=get[0];\n      tot[w]%=2;\n      tot[(w+1)%3]+=get[1];\n      tot[(w+1)%3]%=2;\n      tot[(w+2)%3]+=get[2];\n      tot[(w+2)%3]%=2;\n    }\n    for(i=0;i<3;i++){\n      if(tot[i]==1){bm=i;break;}\n      if(i==2){return -1;}\n    }\n    np=base;\n    for(i=58;i>=0;i--){\n      c=0;\n      for(j=0;j<n;j++){\n        //領域の始点、三角形の最下y座標の低いほうを起点に\n        //ある点から右か右斜め上に広げるイメージ\n        hs=llmin(y[j],np);\n        w=(hs-base)%3;\n        l=cval-x[j]-y[j];\n        //[三角形の最下点,領域の終点]\n        rgdigdp(l,y[j]-hs,np+(1ll<<i)-1-hs,get);\n        c+=get[(3+bm-w)%3];\n        c%=2;\n      }\n      if(c==0){\n        np+=(1ll<<i);\n      }\n    }\n    by=np;bx=cval-by;\n    //if(findcol(bx,by)==0){\n    //  return -1;\n    //}\n    lx=bx;\n    hx=bx;\n    for(i=60;i>=0;i--){\n      w=(1ll<<i);\n      if(findcol(lx-w,cval-(lx-w))==1){\n        lx-=w;\n      }\n      if(findcol(hx+w,cval-(hx+w))==1){\n        hx+=w;\n      }\n    }\n    printf(\"%lld %lld\\n\",lx,cval-hx);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n#define cval 444444444444444444\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid prarr(long long arr[],long long n){\n  long long i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%lld\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\n//パスカルの三角形のfloor C 0~floor C limまでの黒マスカウント\n//但し、mod3で分類\n//lucasの定理に基づくアルゴリズム\nvoid digdp(long long floor,long long lim,long long res[4]){\n    if(floor<lim){lim=floor;}\n    long long dp[64][4][2]={0},i,j,w;\n    //dp[今上から何桁目まで埋めたか][3で割った余り][下のbitによってはlimを超えうるかどうか];\n    dp[62][0][1]=1;\n    for(i=61;i>=0;i--){\n        if(i%2==0){w=1;}else{w=2;}\n        for(j=0;j<3;j++){\n            //末尾bitが0\n            dp[i][j][0]+=dp[i+1][j][0];\n            if((lim&(1ll<<i))!=0){\n                dp[i][j][0]+=dp[i+1][j][1];\n            }\n            else{\n                dp[i][j][1]+=dp[i+1][j][1];\n            }\n            //0C1が起きるなら黒点にならないので遷移なし、起きないなら遷移あり\n            if((floor&(1ll<<i))!=0){\n                //末尾bitが1\n                dp[i][(j+w)%3][0]+=dp[i+1][j][0];\n                if((lim&(1ll<<i))!=0){\n                    dp[i][(j+w)%3][1]+=dp[i+1][j][1];\n                }\n            }\n        }\n    }\n    res[0]=dp[0][0][0]+dp[0][0][1];\n    res[1]=dp[0][1][0]+dp[0][1][1];\n    res[2]=dp[0][2][0]+dp[0][2][1];\n    //prarr(res,3);\n    //printf(\"\\n\");\n}\n\n//floor C st ~ floor C fiまでのmod 3別黒点の数\nvoid rgdigdp(long long floor,long long st,long long fi,long long res[4]){\n  if(st<0){st=0;}\n  if(fi>floor){fi=floor;}\n  if(st>fi){\n    res[0]=0;\n    res[1]=0;\n    res[2]=0;\n    return;\n  }\n  long long sr[4]={0},fr[4]={0};\n  if(st!=0){\n    digdp(floor,st-1,sr);\n  }\n  digdp(floor,fi,fr);\n  res[0]=fr[0]-sr[0];\n  res[1]=fr[1]-sr[1];\n  res[2]=fr[2]-sr[2];\n}\n\n//nCr mod2\n//Find the color of Pascal's Triangle\n//based on Lucas's Theorem(https://mathtrain.jp/lucastheorem)\nlong long nCrbit(long long n,long long r){\nif(n<0 || r<0){return 0;}\nif(n<r){return 0;}\nif((n|r)!=n){return 0;}\nreturn 1;\n}\n\nlong long n,x[16384],y[16384];\nlong long findcol(long long a,long long b){\n    long long i,r=0,p,q;\n    for(i=0;i<n;i++){\n        if(a-x[i]<0 || b-y[i]<0){continue;}\n        p=(a-x[i])+(b-y[i]);\n        q=(b-y[i]);\n        r^=nCrbit(p,q);\n    }\n    return r;\n}\n\nint main(void){\n    long long i,j,m,k,a,b,c,h,w,r,l,t;\n    long long base=-(1ll<<59),bm,np;\n    long long get[4]={0},tot[4]={0};\n    long long bx,by,hs;\n    long long lx,hx;\n    scanf(\"%lld\",&n);\n    for(i=0;i<n;i++){\n      scanf(\"%lld%lld\",&x[i],&y[i]);\n    }\n    for(i=0;i<n;i++){\n      //基準点からの高さ\n      w=(y[i]-base)%3;\n      //三角形の何段目か\n      l=cval-x[i]-y[i];\n      digdp(l,llinf,get);\n      tot[w]+=get[0];\n      tot[w]%=2;\n      tot[(w+1)%3]+=get[1];\n      tot[(w+1)%3]%=2;\n      tot[(w+2)%3]+=get[2];\n      tot[(w+2)%3]%=2;\n    }\n    for(i=0;i<3;i++){\n      if(tot[i]==1){bm=i;break;}\n    }\n    np=base;\n    for(i=59;i>=0;i--){\n      c=0;\n      for(j=0;j<n;j++){\n        //領域の始点、三角形の最下y座標の低いほうを起点に\n        //ある点から右か右斜め上に広げるイメージ\n        hs=llmin(y[j],np);\n        w=(hs-base)%3;\n        l=cval-x[j]-y[j];\n        //[三角形の最下点,領域の終点]\n        rgdigdp(l,y[j]-hs,np+(1ll<<i)-1-hs,get);\n        c+=get[(3+bm-w)%3];\n        c%=2;\n      }\n      if(c==0){\n        np+=(1ll<<i);\n      }\n    }\n    by=np;bx=cval-by;\n    if(findcol(bx,by)==0){\n      return -1;\n    }\n    lx=bx;\n    hx=bx;\n    for(i=60;i>=0;i--){\n      w=(1ll<<i);\n      if(findcol(lx-w,cval-(lx-w))==1){\n        lx-=w;\n      }\n      if(findcol(hx+w,cval-(hx+w))==1){\n        hx+=w;\n      }\n    }\n    printf(\"%lld %lld\\n\",lx,cval-hx);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n#define cval 288230376151711744\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid prarr(long long arr[],long long n){\n  long long i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%lld\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\n//パスカルの三角形のfloor C 0~floor C limまでの黒マスカウント\n//但し、mod3で分類\n//lucasの定理に基づくアルゴリズム\nvoid digdp(long long floor,long long lim,long long res[4]){\n    if(floor<lim){lim=floor;}\n    long long dp[64][4][2]={0},i,j,w;\n    //dp[今上から何桁目まで埋めたか][3で割った余り][下のbitによってはlimを超えうるかどうか];\n    dp[62][0][1]=1;\n    for(i=61;i>=0;i--){\n        if(i%2==0){w=1;}else{w=2;}\n        for(j=0;j<3;j++){\n            //末尾bitが0\n            dp[i][j][0]+=dp[i+1][j][0];\n            if((lim&(1ll<<i))!=0){\n                dp[i][j][0]+=dp[i+1][j][1];\n            }\n            else{\n                dp[i][j][1]+=dp[i+1][j][1];\n            }\n            //0C1が起きるなら黒点にならないので遷移なし、起きないなら遷移あり\n            if((floor&(1ll<<i))!=0){\n                //末尾bitが1\n                dp[i][(j+w)%3][0]+=dp[i+1][j][0];\n                if((lim&(1ll<<i))!=0){\n                    dp[i][(j+w)%3][1]+=dp[i+1][j][1];\n                }\n            }\n        }\n    }\n    res[0]=dp[0][0][0]+dp[0][0][1];\n    res[1]=dp[0][1][0]+dp[0][1][1];\n    res[2]=dp[0][2][0]+dp[0][2][1];\n    //prarr(res,3);\n    //printf(\"\\n\");\n}\n\n//floor C st ~ floor C fiまでのmod 3別黒点の数\nvoid rgdigdp(long long floor,long long st,long long fi,long long res[4]){\n  if(st<0){st=0;}\n  if(fi>floor){fi=floor;}\n  if(st>fi){\n    res[0]=0;\n    res[1]=0;\n    res[2]=0;\n    return;\n  }\n  long long sr[4]={0},fr[4]={0};\n  if(st!=0){\n    digdp(floor,st-1,sr);\n  }\n  digdp(floor,fi,fr);\n  res[0]=fr[0]-sr[0];\n  res[1]=fr[1]-sr[1];\n  res[2]=fr[2]-sr[2];\n}\n\n//nCr mod2\n//Find the color of Pascal's Triangle\n//based on Lucas's Theorem(https://mathtrain.jp/lucastheorem)\nlong long nCrbit(long long n,long long r){\nif(n<0 || r<0){return 0;}\nif(n<r){return 0;}\nif((n|r)!=n){return 0;}\nreturn 1;\n}\n\nlong long n,x[16384],y[16384];\nlong long findcol(long long a,long long b){\n    long long i,r=0,p,q;\n    for(i=0;i<n;i++){\n        if(a-x[i]<0 || b-y[i]<0){continue;}\n        p=(a-x[i])+(b-y[i]);\n        q=(b-y[i]);\n        r^=nCrbit(p,q);\n    }\n    return r;\n}\n\nint main(void){\n    long long i,j,m,k,a,b,c,h,w,r,l,t;\n    long long base=-(1ll<<59),bm,np;\n    long long get[4]={0},tot[4]={0};\n    long long bx,by,hs;\n    long long lx,hx;\n    scanf(\"%lld\",&n);\n    for(i=0;i<n;i++){\n      scanf(\"%lld%lld\",&x[i],&y[i]);\n    }\n    for(i=0;i<n;i++){\n      //基準点からの高さ\n      w=(y[i]-base)%3;\n      //三角形の何段目か\n      l=cval-x[i]-y[i];\n      digdp(l,llinf,get);\n      tot[w]+=get[0];\n      tot[w]%=2;\n      tot[(w+1)%3]+=get[1];\n      tot[(w+1)%3]%=2;\n      tot[(w+2)%3]+=get[2];\n      tot[(w+2)%3]%=2;\n    }\n    for(i=0;i<3;i++){\n      if(tot[i]==1){bm=i;break;}\n    }\n    np=base;\n    for(i=59;i>=0;i--){\n      c=0;\n      for(j=0;j<n;j++){\n        //領域の始点、三角形の最下y座標の低いほうを起点に\n        //ある点から右か右斜め上に広げるイメージ\n        hs=llmin(y[j],np);\n        w=(hs-base)%3;\n        l=cval-x[j]-y[j];\n        //[三角形の最下点,領域の終点]\n        rgdigdp(l,y[j]-hs,np+(1ll<<i)-1-hs,get);\n        c+=get[(3+bm-w)%3];\n        c%=2;\n      }\n      if(c==0){\n        np+=(1ll<<i);\n      }\n    }\n    by=np;bx=cval-by;\n    //printf(\"%lld %lld\\n\",bx,by);\n    //printf(\"%lld\\n\",findcol(bx,by));\n    lx=bx;\n    hx=bx;\n    for(i=60;i>=0;i--){\n      w=(1ll<<i);\n      if(findcol(lx-w,cval-(lx-w))==1){\n        lx-=w;\n      }\n      if(findcol(hx+w,cval-(hx+w))==1){\n        hx+=w;\n      }\n    }\n    printf(\"%lld %lld\\n\",lx,cval-hx);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n#define cval 444444444444444444\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid prarr(long long arr[],long long n){\n  long long i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%lld\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\n//パスカルの三角形のfloor C 0~floor C limまでの黒マスカウント\n//但し、mod3で分類\n//lucasの定理に基づくアルゴリズム\nvoid digdp(long long floor,long long lim,long long res[4]){\n    if(floor<lim){lim=floor;}\n    long long dp[64][4][2]={0},i,j,w;\n    //dp[今上から何桁目まで埋めたか][3で割った余り][下のbitによってはlimを超えうるかどうか];\n    dp[63][0][1]=1;\n    for(i=62;i>=0;i--){\n        if(i%2==0){w=1;}else{w=2;}\n        for(j=0;j<3;j++){\n            //末尾bitが0\n            dp[i][j][0]+=dp[i+1][j][0];\n            if((lim&(1ll<<i))!=0){\n                dp[i][j][0]+=dp[i+1][j][1];\n            }\n            else{\n                dp[i][j][1]+=dp[i+1][j][1];\n            }\n            //0C1が起きるなら黒点にならないので遷移なし、起きないなら遷移あり\n            if((floor&(1ll<<i))!=0){\n                //末尾bitが1\n                dp[i][(j+w)%3][0]+=dp[i+1][j][0];\n                if((lim&(1ll<<i))!=0){\n                    dp[i][(j+w)%3][1]+=dp[i+1][j][1];\n                }\n            }\n        }\n    }\n    res[0]=dp[0][0][0]+dp[0][0][1];\n    res[1]=dp[0][1][0]+dp[0][1][1];\n    res[2]=dp[0][2][0]+dp[0][2][1];\n    //prarr(res,3);\n    //printf(\"\\n\");\n}\n\n//floor C st ~ floor C fiまでのmod 3別黒点の数\nvoid rgdigdp(long long floor,long long st,long long fi,long long res[4]){\n  if(st<0){st=0;}\n  if(fi>floor){fi=floor;}\n  if(st>fi){\n    res[0]=0;\n    res[1]=0;\n    res[2]=0;\n    return;\n  }\n  long long sr[4]={0},fr[4]={0};\n  if(st!=0){\n    digdp(floor,st-1,sr);\n  }\n  digdp(floor,fi,fr);\n  res[0]=fr[0]-sr[0];\n  res[1]=fr[1]-sr[1];\n  res[2]=fr[2]-sr[2];\n}\n\n//nCr mod2\n//Find the color of Pascal's Triangle\n//based on Lucas's Theorem(https://mathtrain.jp/lucastheorem)\nlong long nCrbit(long long n,long long r){\nif(n<0 || r<0){return 0;}\nif(n<r){return 0;}\nif((n|r)!=n){return 0;}\nreturn 1;\n}\n\nlong long n,x[16384],y[16384];\nlong long findcol(long long a,long long b){\n    long long i,r=0,p,q;\n    for(i=0;i<n;i++){\n        if(a-x[i]<0 || b-y[i]<0){continue;}\n        p=(a-x[i])+(b-y[i]);\n        q=(b-y[i]);\n        r^=nCrbit(p,q);\n    }\n    return r;\n}\n\nint main(void){\n    long long i,j,m,k,a,b,c,h,w,r,l,t;\n    long long base=-(1ll<<58),bm,np;\n    long long get[4]={0},tot[4]={0};\n    long long bx,by,hs;\n    long long lx,hx;\n    scanf(\"%lld\",&n);\n    for(i=0;i<n;i++){\n      scanf(\"%lld%lld\",&x[i],&y[i]);\n    }\n    for(i=0;i<n;i++){\n      //基準点からの高さ\n      w=(y[i]-base)%3;\n      //三角形の何段目か\n      l=cval-x[i]-y[i];\n      digdp(l,llinf,get);\n      tot[w]+=get[0];\n      tot[w]%=2;\n      tot[(w+1)%3]+=get[1];\n      tot[(w+1)%3]%=2;\n      tot[(w+2)%3]+=get[2];\n      tot[(w+2)%3]%=2;\n    }\n    for(i=0;i<3;i++){\n      if(tot[i]==1){bm=i;break;}\n      if(i==2){return -1;}\n    }\n    np=base;\n    for(i=58;i>=0;i--){\n      c=0;\n      for(j=0;j<n;j++){\n        //領域の始点、三角形の最下y座標の低いほうを起点に\n        //ある点から右か右斜め上に広げるイメージ\n        hs=llmin(y[j],np);\n        w=(hs-base)%3;\n        l=cval-x[j]-y[j];\n        //[三角形の最下点,領域の終点]\n        rgdigdp(l,y[j]-hs,np+(1ll<<i)-1-hs,get);\n        c+=get[(3+bm-w)%3];\n        c%=2;\n      }\n      if(c==0){\n        np+=(1ll<<i);\n      }\n    }\n    by=np;bx=cval-by;\n    //if(findcol(bx,by)==0){\n    //  return -1;\n    //}\n    lx=bx;\n    hx=bx;\n    for(i=60;i>=0;i--){\n      w=(1ll<<i);\n      if(findcol(lx-w,cval-(lx-w))==1){\n        lx-=w;\n      }\n      if(findcol(hx+w,cval-(hx+w))==1){\n        hx+=w;\n      }\n    }\n    printf(\"%lld %lld\\n\",lx,cval-hx);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n#define cval 444444444444444444\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid prarr(long long arr[],long long n){\n  long long i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%lld\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\n//パスカルの三角形のfloor C 0~floor C limまでの黒マスカウント\n//但し、mod3で分類\n//lucasの定理に基づくアルゴリズム\nvoid digdp(long long floor,long long lim,long long res[4]){\n    if(floor<lim){lim=floor;}\n    long long dp[64][4][2]={0},i,j,w;\n    //dp[今上から何桁目まで埋めたか][3で割った余り][下のbitによってはlimを超えうるかどうか];\n    dp[63][0][1]=1;\n    for(i=62;i>=0;i--){\n        if(i%2==0){w=1;}else{w=2;}\n        for(j=0;j<3;j++){\n            //末尾bitが0\n            dp[i][j][0]+=dp[i+1][j][0];\n            if((lim&(1ll<<i))!=0){\n                dp[i][j][0]+=dp[i+1][j][1];\n            }\n            else{\n                dp[i][j][1]+=dp[i+1][j][1];\n            }\n            //0C1が起きるなら黒点にならないので遷移なし、起きないなら遷移あり\n            if((floor&(1ll<<i))!=0){\n                //末尾bitが1\n                dp[i][(j+w)%3][0]+=dp[i+1][j][0];\n                if((lim&(1ll<<i))!=0){\n                    dp[i][(j+w)%3][1]+=dp[i+1][j][1];\n                }\n            }\n        }\n    }\n    res[0]=dp[0][0][0]+dp[0][0][1];\n    res[1]=dp[0][1][0]+dp[0][1][1];\n    res[2]=dp[0][2][0]+dp[0][2][1];\n    //prarr(res,3);\n    //printf(\"\\n\");\n}\n\n//floor C st ~ floor C fiまでのmod 3別黒点の数\nvoid rgdigdp(long long floor,long long st,long long fi,long long res[4]){\n  if(st<0){st=0;}\n  if(fi>floor){fi=floor;}\n  if(st>fi){\n    res[0]=0;\n    res[1]=0;\n    res[2]=0;\n    return;\n  }\n  long long sr[4]={0},fr[4]={0};\n  if(st!=0){\n    digdp(floor,st-1,sr);\n  }\n  digdp(floor,fi,fr);\n  res[0]=fr[0]-sr[0];\n  res[1]=fr[1]-sr[1];\n  res[2]=fr[2]-sr[2];\n}\n\n//nCr mod2\n//Find the color of Pascal's Triangle\n//based on Lucas's Theorem(https://mathtrain.jp/lucastheorem)\nlong long nCrbit(long long n,long long r){\nif(n<0 || r<0){return 0;}\nif(n<r){return 0;}\nif((n|r)!=n){return 0;}\nreturn 1;\n}\n\nlong long n,x[16384],y[16384];\nlong long findcol(long long a,long long b){\n    long long i,r=0,p,q;\n    for(i=0;i<n;i++){\n        if(a-x[i]<0 || b-y[i]<0){continue;}\n        p=(a-x[i])+(b-y[i]);\n        q=(b-y[i]);\n        r^=nCrbit(p,q);\n    }\n    return r;\n}\n\nint main(void){\n    long long i,j,m,k,a,b,c,h,w,r,l,t;\n    long long base=-(1ll<<59),bm,np;\n    long long get[4]={0},tot[4]={0};\n    long long bx,by,hs;\n    long long lx,hx;\n    scanf(\"%lld\",&n);\n    for(i=0;i<n;i++){\n      scanf(\"%lld%lld\",&x[i],&y[i]);\n    }\n    for(i=0;i<n;i++){\n      //基準点からの高さ\n      w=(y[i]-base)%3;\n      //三角形の何段目か\n      l=cval-x[i]-y[i];\n      digdp(l,llinf,get);\n      tot[w]+=get[0];\n      tot[w]%=2;\n      tot[(w+1)%3]+=get[1];\n      tot[(w+1)%3]%=2;\n      tot[(w+2)%3]+=get[2];\n      tot[(w+2)%3]%=2;\n    }\n    for(i=0;i<3;i++){\n      if(tot[i]==1){bm=i;break;}\n    }\n    np=base;\n    for(i=59;i>=0;i--){\n      c=0;\n      for(j=0;j<n;j++){\n        //領域の始点、三角形の最下y座標の低いほうを起点に\n        //ある点から右か右斜め上に広げるイメージ\n        hs=llmin(y[j],np);\n        w=(hs-base)%3;\n        l=cval-x[j]-y[j];\n        //[三角形の最下点,領域の終点]\n        rgdigdp(l,y[j]-hs,np+(1ll<<i)-1-hs,get);\n        c+=get[(3+bm-w)%3];\n        c%=2;\n      }\n      //printf(\"%lld:%lld\\n\",i,np);\n      if(c==0){\n        np+=(1ll<<i);\n      }\n    }\n    by=np;bx=cval-by;\n    if(findcol(bx,by)==0){\n      printf(\"<%lld %lld>\\n\",bx,by);\n      return -1;\n    }\n    lx=bx;\n    hx=bx;\n    for(i=60;i>=0;i--){\n      w=(1ll<<i);\n      if(findcol(lx-w,cval-(lx-w))==1){\n        lx-=w;\n      }\n      if(findcol(hx+w,cval-(hx+w))==1){\n        hx+=w;\n      }\n    }\n    printf(\"%lld %lld\\n\",lx,cval-hx);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n#define cval 250000000000000000\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid prarr(long long arr[],long long n){\n  long long i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%lld\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\n//パスカルの三角形のfloor C 0~floor C limまでの黒マスカウント\n//但し、mod3で分類\n//lucasの定理に基づくアルゴリズム\nvoid digdp(long long floor,long long lim,long long res[4]){\n    if(floor<lim){lim=floor;}\n    long long dp[64][4][2]={0},i,j,w;\n    //dp[今上から何桁目まで埋めたか][3で割った余り][下のbitによってはlimを超えうるかどうか];\n    dp[63][0][1]=1;\n    for(i=62;i>=0;i--){\n        if(i%2==0){w=1;}else{w=2;}\n        for(j=0;j<3;j++){\n            //末尾bitが0\n            dp[i][j][0]+=dp[i+1][j][0];\n            if((lim&(1ll<<i))!=0){\n                dp[i][j][0]+=dp[i+1][j][1];\n            }\n            else{\n                dp[i][j][1]+=dp[i+1][j][1];\n            }\n            //0C1が起きるなら黒点にならないので遷移なし、起きないなら遷移あり\n            if((floor&(1ll<<i))!=0){\n                //末尾bitが1\n                dp[i][(j+w)%3][0]+=dp[i+1][j][0];\n                if((lim&(1ll<<i))!=0){\n                    dp[i][(j+w)%3][1]+=dp[i+1][j][1];\n                }\n            }\n        }\n    }\n    res[0]=dp[0][0][0]+dp[0][0][1];\n    res[1]=dp[0][1][0]+dp[0][1][1];\n    res[2]=dp[0][2][0]+dp[0][2][1];\n    //prarr(res,3);\n    //printf(\"\\n\");\n}\n\n//floor C st ~ floor C fiまでのmod 3別黒点の数\nvoid rgdigdp(long long floor,long long st,long long fi,long long res[4]){\n  if(st<0){st=0;}\n  if(fi>floor){fi=floor;}\n  if(st>fi){\n    res[0]=0;\n    res[1]=0;\n    res[2]=0;\n    return;\n  }\n  long long sr[4]={0},fr[4]={0};\n  if(st!=0){\n    digdp(floor,st-1,sr);\n  }\n  digdp(floor,fi,fr);\n  res[0]=fr[0]-sr[0];\n  res[1]=fr[1]-sr[1];\n  res[2]=fr[2]-sr[2];\n}\n\n//nCr mod2\n//Find the color of Pascal's Triangle\n//based on Lucas's Theorem(https://mathtrain.jp/lucastheorem)\nlong long nCrbit(long long n,long long r){\nif(n<0 || r<0){return 0;}\nif(n<r){return 0;}\nif((n|r)!=n){return 0;}\nreturn 1;\n}\n\nlong long n,x[16384],y[16384];\nlong long findcol(long long a,long long b){\n    long long i,r=0,p,q;\n    for(i=0;i<n;i++){\n        if(a-x[i]<0 || b-y[i]<0){continue;}\n        p=(a-x[i])+(b-y[i]);\n        q=(b-y[i]);\n        r^=nCrbit(p,q);\n    }\n    return r;\n}\n\nint main(void){\n    long long i,j,m,k,a,b,c,h,w,r,l,t;\n    long long base=-(1ll<<59),bm,np;\n    long long get[4]={0},tot[4]={0};\n    long long bx,by,hs;\n    long long lx,hx;\n    scanf(\"%lld\",&n);\n    for(i=0;i<n;i++){\n      scanf(\"%lld%lld\",&x[i],&y[i]);\n    }\n    for(i=0;i<n;i++){\n      //基準点からの高さ\n      w=(y[i]-base)%3;\n      //三角形の何段目か\n      l=cval-x[i]-y[i];\n      digdp(l,llinf,get);\n      tot[w]+=get[0];\n      tot[w]%=2;\n      tot[(w+1)%3]+=get[1];\n      tot[(w+1)%3]%=2;\n      tot[(w+2)%3]+=get[2];\n      tot[(w+2)%3]%=2;\n    }\n    for(i=0;i<3;i++){\n      if(tot[i]==1){bm=i;break;}\n    }\n    np=base;\n    for(i=59;i>=0;i--){\n      c=0;\n      for(j=0;j<n;j++){\n        //領域の始点、三角形の最下y座標の低いほうを起点に\n        //ある点から右か右斜め上に広げるイメージ\n        hs=llmin(y[j],np);\n        w=(hs-base)%3;\n        l=cval-x[j]-y[j];\n        //[三角形の最下点,領域の終点]\n        rgdigdp(l,y[j]-hs,np+(1ll<<i)-1-hs,get);\n        c+=get[(3+bm-w)%3];\n        c%=2;\n      }\n      //printf(\"%lld:%lld\\n\",i,np);\n      if(c==0){\n        np+=(1ll<<i);\n      }\n    }\n    by=np;bx=cval-by;\n    if(findcol(bx,by)==0){\n      printf(\"<%lld %lld>\\n\",bx,by);\n      return -1;\n    }\n    lx=bx;\n    hx=bx;\n    for(i=60;i>=0;i--){\n      w=(1ll<<i);\n      if(findcol(lx-w,cval-(lx-w))==1){\n        lx-=w;\n      }\n      if(findcol(hx+w,cval-(hx+w))==1){\n        hx+=w;\n      }\n    }\n    printf(\"%lld %lld\\n\",lx,cval-hx);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n#define cval 250000000000000000\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid prarr(long long arr[],long long n){\n  long long i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%lld\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\n//パスカルの三角形のfloor C 0~floor C limまでの黒マスカウント\n//但し、mod3で分類\n//lucasの定理に基づくアルゴリズム\nvoid digdp(long long floor,long long lim,long long res[4]){\n    if(floor<lim){lim=floor;}\n    long long dp[64][4][2]={0},i,j,w;\n    //dp[今上から何桁目まで埋めたか][3で割った余り][下のbitによってはlimを超えうるかどうか];\n    dp[63][0][1]=1;\n    for(i=62;i>=0;i--){\n        if(i%2==0){w=1;}else{w=2;}\n        for(j=0;j<3;j++){\n            //末尾bitが0\n            dp[i][j][0]+=dp[i+1][j][0];\n            if((lim&(1ll<<i))!=0){\n                dp[i][j][0]+=dp[i+1][j][1];\n            }\n            else{\n                dp[i][j][1]+=dp[i+1][j][1];\n            }\n            //0C1が起きるなら黒点にならないので遷移なし、起きないなら遷移あり\n            if((floor&(1ll<<i))!=0){\n                //末尾bitが1\n                dp[i][(j+w)%3][0]+=dp[i+1][j][0];\n                if((lim&(1ll<<i))!=0){\n                    dp[i][(j+w)%3][1]+=dp[i+1][j][1];\n                }\n            }\n        }\n    }\n    res[0]=dp[0][0][0]+dp[0][0][1];\n    res[1]=dp[0][1][0]+dp[0][1][1];\n    res[2]=dp[0][2][0]+dp[0][2][1];\n    //prarr(res,3);\n    //printf(\"\\n\");\n}\n\n//floor C st ~ floor C fiまでのmod 3別黒点の数\nvoid rgdigdp(long long floor,long long st,long long fi,long long res[4]){\n  if(st<0){st=0;}\n  if(fi>floor){fi=floor;}\n  if(st>fi){\n    res[0]=0;\n    res[1]=0;\n    res[2]=0;\n    return;\n  }\n  long long sr[4]={0},fr[4]={0};\n  if(st!=0){\n    digdp(floor,st-1,sr);\n  }\n  digdp(floor,fi,fr);\n  res[0]=fr[0]-sr[0];\n  res[1]=fr[1]-sr[1];\n  res[2]=fr[2]-sr[2];\n}\n\n//nCr mod2\n//Find the color of Pascal's Triangle\n//based on Lucas's Theorem(https://mathtrain.jp/lucastheorem)\nlong long nCrbit(long long n,long long r){\nif(n<0 || r<0){return 0;}\nif(n<r){return 0;}\nif((n|r)!=n){return 0;}\nreturn 1;\n}\n\nlong long n,x[16384],y[16384];\nlong long findcol(long long a,long long b){\n    long long i,r=0,p,q;\n    for(i=0;i<n;i++){\n        if(a-x[i]<0 || b-y[i]<0){continue;}\n        p=(a-x[i])+(b-y[i]);\n        q=(b-y[i]);\n        r^=nCrbit(p,q);\n    }\n    return r;\n}\n\nint main(void){\n    long long i,j,m,k,a,b,c,d,h,w,r,l,t;\n    long long base=-(1ll<<59),bm,np;\n    long long get[4]={0},tot[4]={0};\n    long long bx,by,hs;\n    long long lx,hx;\n    scanf(\"%lld\",&n);\n    for(i=0;i<n;i++){\n      scanf(\"%lld%lld\",&x[i],&y[i]);\n    }\n    for(i=0;i<n;i++){\n      //基準点からのズレ\n      w=(x[i]-base)%3;\n      //三角形の何段目か\n      l=cval-x[i]-y[i];\n      digdp(l,llinf,get);\n      tot[w]+=get[0];\n      tot[w]%=2;\n      tot[(w+1)%3]+=get[1];\n      tot[(w+1)%3]%=2;\n      tot[(w+2)%3]+=get[2];\n      tot[(w+2)%3]%=2;\n    }\n    for(i=0;i<3;i++){\n      if(tot[i]==1){\n            //printf(\"<%lld>\\n\",i);\n            bm=i;break;\n      }\n    }\n    np=base;\n    for(i=59;i>=0;i--){\n      c=0;\n      for(j=0;j<n;j++){\n        w=(x[j]-base)%3;\n        l=cval-x[j]-y[j];\n        //[領域の始点,領域の終点]\n        rgdigdp(l,np-x[j],np+(1ll<<i)-1-x[j],get);\n        c+=get[(3+bm-w)%3];\n        c%=2;\n      }\n      //printf(\"%lld:%lld %lld\\n\",i,c,d);\n      if(c==0){\n        np+=(1ll<<i);\n      }\n    }\n    bx=np;by=cval-bx;\n    if(findcol(bx,by)==0){\n      printf(\"<%lld %lld>\\n\",bx,by);\n      return -1;\n    }\n    lx=bx;\n    hx=bx;\n    for(i=60;i>=0;i--){\n      w=(1ll<<i);\n      if(findcol(lx-w,cval-(lx-w))==1){\n        lx-=w;\n      }\n      if(findcol(hx+w,cval-(hx+w))==1){\n        hx+=w;\n      }\n    }\n    printf(\"%lld %lld\\n\",lx,cval-hx);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n#define cval 444444444444444444\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid prarr(long long arr[],long long n){\n  long long i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%lld\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\n//パスカルの三角形のfloor C 0~floor C limまでの黒マスカウント\n//但し、mod3で分類\n//lucasの定理に基づくアルゴリズム\nvoid digdp(long long floor,long long lim,long long res[4]){\n    if(floor<lim){lim=floor;}\n    long long dp[64][4][2]={0},i,j,w;\n    //dp[今上から何桁目まで埋めたか][3で割った余り][下のbitによってはlimを超えうるかどうか];\n    dp[63][0][1]=1;\n    for(i=62;i>=0;i--){\n        if(i%2==0){w=1;}else{w=2;}\n        for(j=0;j<3;j++){\n            //末尾bitが0\n            dp[i][j][0]+=dp[i+1][j][0];\n            if((lim&(1ll<<i))!=0){\n                dp[i][j][0]+=dp[i+1][j][1];\n            }\n            else{\n                dp[i][j][1]+=dp[i+1][j][1];\n            }\n            //0C1が起きるなら黒点にならないので遷移なし、起きないなら遷移あり\n            if((floor&(1ll<<i))!=0){\n                //末尾bitが1\n                dp[i][(j+w)%3][0]+=dp[i+1][j][0];\n                if((lim&(1ll<<i))!=0){\n                    dp[i][(j+w)%3][1]+=dp[i+1][j][1];\n                }\n            }\n        }\n    }\n    res[0]=dp[0][0][0]+dp[0][0][1];\n    res[1]=dp[0][1][0]+dp[0][1][1];\n    res[2]=dp[0][2][0]+dp[0][2][1];\n    //prarr(res,3);\n    //printf(\"\\n\");\n}\n\n//floor C st ~ floor C fiまでのmod 3別黒点の数\nvoid rgdigdp(long long floor,long long st,long long fi,long long res[4]){\n  if(st<0){st=0;}\n  if(fi>floor){fi=floor;}\n  if(st>fi){\n    res[0]=0;\n    res[1]=0;\n    res[2]=0;\n    return;\n  }\n  long long sr[4]={0},fr[4]={0};\n  if(st!=0){\n    digdp(floor,st-1,sr);\n  }\n  digdp(floor,fi,fr);\n  res[0]=fr[0]-sr[0];\n  res[1]=fr[1]-sr[1];\n  res[2]=fr[2]-sr[2];\n}\n\n//nCr mod2\n//Find the color of Pascal's Triangle\n//based on Lucas's Theorem(https://mathtrain.jp/lucastheorem)\nlong long nCrbit(long long n,long long r){\nif(n<0 || r<0){return 0;}\nif(n<r){return 0;}\nif((n|r)!=n){return 0;}\nreturn 1;\n}\n\nlong long n,x[16384],y[16384];\nlong long findcol(long long a,long long b){\n    long long i,r=0,p,q;\n    for(i=0;i<n;i++){\n        if(a-x[i]<0 || b-y[i]<0){continue;}\n        p=(a-x[i])+(b-y[i]);\n        q=(b-y[i]);\n        r^=nCrbit(p,q);\n    }\n    return r;\n}\n\nint main(void){\n    long long i,j,m,k,a,b,c,h,w,r,l,t;\n    long long base=-(1ll<<60),bm,np;\n    long long get[4]={0},tot[4]={0};\n    long long bx,by,hs;\n    long long lx,hx;\n    scanf(\"%lld\",&n);\n    for(i=0;i<n;i++){\n      scanf(\"%lld%lld\",&x[i],&y[i]);\n    }\n    for(i=0;i<n;i++){\n      //基準点からの高さ\n      w=(y[i]-base)%3;\n      //三角形の何段目か\n      l=cval-x[i]-y[i];\n      digdp(l,llinf,get);\n      tot[w]+=get[0];\n      tot[w]%=2;\n      tot[(w+1)%3]+=get[1];\n      tot[(w+1)%3]%=2;\n      tot[(w+2)%3]+=get[2];\n      tot[(w+2)%3]%=2;\n    }\n    for(i=0;i<3;i++){\n      if(tot[i]==1){bm=i;break;}\n    }\n    np=base;\n    for(i=60;i>=0;i--){\n      c=0;\n      for(j=0;j<n;j++){\n        //領域の始点、三角形の最下y座標の低いほうを起点に\n        //ある点から右か右斜め上に広げるイメージ\n        hs=llmin(y[j],np);\n        w=(hs-base)%3;\n        l=cval-x[j]-y[j];\n        //[三角形の最下点,領域の終点]\n        rgdigdp(l,y[j]-hs,np+(1ll<<i)-1-hs,get);\n        c+=get[(3+bm-w)%3];\n        c%=2;\n      }\n      //printf(\"%lld:%lld\\n\",i,np);\n      if(c==0){\n        np+=(1ll<<i);\n      }\n    }\n    by=np;bx=cval-by;\n    if(findcol(bx,by)==0){\n      printf(\"<%lld %lld>\\n\",bx,by);\n      return -1;\n    }\n    lx=bx;\n    hx=bx;\n    for(i=60;i>=0;i--){\n      w=(1ll<<i);\n      if(findcol(lx-w,cval-(lx-w))==1){\n        lx-=w;\n      }\n      if(findcol(hx+w,cval-(hx+w))==1){\n        hx+=w;\n      }\n    }\n    printf(\"%lld %lld\\n\",lx,cval-hx);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n#define cval 444444444444444444\n\nint max(int a,int b){if(a>b){return a;}return b;}\nint min(int a,int b){if(a<b){return a;}return b;}\nint zt(int a,int b){return max(a,b)-min(a,b);}\nint round(int a,int b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nint ceil(int a,int b){if(a%b==0){return a/b;}return (a/b)+1;}\nint gcd(int a,int b){int c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nint lcm(int a,int b){int c=gcd(a,b);a/=c;return a*b;}\nint nCr(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nint nHr(int a,int b){return nCr(a+b-1,b);}\nint fact(int a){int i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nint pow(int a,int b){int i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nint dsum(int x){int r=0;while(x){r+=(x%10);x/=10;}return r;}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\nint sankaku(int x){return ((1+x)*x)/2;}\nlong long llmax(long long a,long long b){if(a>b){return a;}return b;}\nlong long llmin(long long a,long long b){if(a<b){return a;}return b;}\nlong long llzt(long long a,long long b){return llmax(a,b)-llmin(a,b);}\nlong long llround(long long a,long long b){if((a%b)*2 >= b){return (a/b)+1;}return a/b;}\nlong long llceil(long long a,long long b){if(a%b==0){return a/b;}return (a/b)+1;}\nlong long llgcd(long long a,long long b){long long c;while(b!=0){c=a%b;a=b;b=c;}return a;}\nlong long lllcm(long long a,long long b){long long c=llgcd(a,b);a/=c;return a*b;}\nlong long llnCr(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=(a+1-i);r/=i;}return r;}\nlong long llnHr(long long a,long long b){return llnCr(a+b-1,b);}\nlong long llfact(long long a){long long i,r=1;for(i=1;i<=a;i++){r*=i;}return r;}\nlong long llpow(long long a,long long b){long long i,r=1;for(i=1;i<=b;i++){r*=a;}return r;}\nlong long lldsum(long long x){long long r=0;while(x){r+=(x%10);x/=10;}return r;}\nlong long lldsumb(long long x,long long b){long long r=0;while(x){r+=(x%b);x/=b;}return r;}\nlong long llsankaku(long long x){return ((1+x)*x)/2;}\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint sortfncsj(const void *a,const void *b){if(*(int *)a>*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint sortfnckj(const void *a,const void *b){if(*(int *)a<*(int *)b){return 1;}if(*(int *)a==*(int *)b){return 0;}return -1;}\nint llsortfncsj(const void *a,const void *b){if(*(long long *)a>*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint llsortfnckj(const void *a,const void *b){if(*(long long *)a<*(long long *)b){return 1;}if(*(long long *)a==*(long long *)b){return 0;}return -1;}\nint dbsortfncsj(const void *a,const void *b){if(*(double *)a>*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint dbsortfnckj(const void *a,const void *b){if(*(double *)a<*(double *)b){return 1;}if(*(double *)a==*(double *)b){return 0;}return -1;}\nint strsortfncsj(const void *a,const void *b){return strcmp((char *)a,(char *)b);}\nint strsortfnckj(const void *a,const void *b){return strcmp((char *)b,(char *)a);}\nint chsortfncsj(const void *a,const void *b){if(*(char *)a>*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\nint chsortfnckj(const void *a,const void *b){if(*(char *)a<*(char *)b){return 1;}if(*(char *)a==*(char *)b){return 0;}return -1;}\n\nvoid prarr(long long arr[],long long n){\n  long long i;\n  for(i=0;i<n;i++){\n    if(i){printf(\" \");}\n    printf(\"%lld\",arr[i]);\n  }\n  printf(\"\\n\");\n  return;\n}\n\n//パスカルの三角形のfloor C 0~floor C limまでの黒マスカウント\n//但し、mod3で分類\n//lucasの定理に基づくアルゴリズム\nvoid digdp(long long floor,long long lim,long long res[4]){\n    if(floor<lim){lim=floor;}\n    long long dp[64][4][2]={0},i,j,w;\n    //dp[今上から何桁目まで埋めたか][3で割った余り][下のbitによってはlimを超えうるかどうか];\n    dp[63][0][1]=1;\n    for(i=62;i>=0;i--){\n        if(i%2==0){w=1;}else{w=2;}\n        for(j=0;j<3;j++){\n            //末尾bitが0\n            dp[i][j][0]+=dp[i+1][j][0];\n            if((lim&(1ll<<i))!=0){\n                dp[i][j][0]+=dp[i+1][j][1];\n            }\n            else{\n                dp[i][j][1]+=dp[i+1][j][1];\n            }\n            //0C1が起きるなら黒点にならないので遷移なし、起きないなら遷移あり\n            if((floor&(1ll<<i))!=0){\n                //末尾bitが1\n                dp[i][(j+w)%3][0]+=dp[i+1][j][0];\n                if((lim&(1ll<<i))!=0){\n                    dp[i][(j+w)%3][1]+=dp[i+1][j][1];\n                }\n            }\n        }\n    }\n    res[0]=dp[0][0][0]+dp[0][0][1];\n    res[1]=dp[0][1][0]+dp[0][1][1];\n    res[2]=dp[0][2][0]+dp[0][2][1];\n    //prarr(res,3);\n    //printf(\"\\n\");\n}\n\n//floor C st ~ floor C fiまでのmod 3別黒点の数\nvoid rgdigdp(long long floor,long long st,long long fi,long long res[4]){\n  if(st<0){st=0;}\n  if(fi>floor){fi=floor;}\n  if(st>fi){\n    res[0]=0;\n    res[1]=0;\n    res[2]=0;\n    return;\n  }\n  long long sr[4]={0},fr[4]={0};\n  if(st!=0){\n    digdp(floor,st-1,sr);\n  }\n  digdp(floor,fi,fr);\n  res[0]=fr[0]-sr[0];\n  res[1]=fr[1]-sr[1];\n  res[2]=fr[2]-sr[2];\n}\n\n//nCr mod2\n//Find the color of Pascal's Triangle\n//based on Lucas's Theorem(https://mathtrain.jp/lucastheorem)\nlong long nCrbit(long long n,long long r){\nif(n<0 || r<0){return 0;}\nif(n<r){return 0;}\nif((n|r)!=n){return 0;}\nreturn 1;\n}\n\nlong long n,x[16384],y[16384];\nlong long findcol(long long a,long long b){\n    long long i,r=0,p,q;\n    for(i=0;i<n;i++){\n        if(a-x[i]<0 || b-y[i]<0){continue;}\n        p=(a-x[i])+(b-y[i]);\n        q=(b-y[i]);\n        r^=nCrbit(p,q);\n    }\n    return r;\n}\n\nint main(void){\n    long long i,j,m,k,a,b,c,h,w,r,l,t;\n    long long base=-(1ll<<59),bm,np;\n    long long get[4]={0},tot[4]={0};\n    long long bx,by,hs;\n    long long lx,hx;\n    scanf(\"%lld\",&n);\n    for(i=0;i<n;i++){\n      scanf(\"%lld%lld\",&x[i],&y[i]);\n    }\n    for(i=0;i<n;i++){\n      //基準点からの高さ\n      w=(y[i]-base)%3;\n      //三角形の何段目か\n      l=cval-x[i]-y[i];\n      digdp(l,llinf,get);\n      tot[w]+=get[0];\n      tot[w]%=2;\n      tot[(w+1)%3]+=get[1];\n      tot[(w+1)%3]%=2;\n      tot[(w+2)%3]+=get[2];\n      tot[(w+2)%3]%=2;\n    }\n    for(i=0;i<3;i++){\n      if(tot[i]==1){bm=i;break;}\n      if(i==2){return -1;}\n    }\n    np=base;\n    for(i=59;i>=0;i--){\n      c=0;\n      for(j=0;j<n;j++){\n        //領域の始点、三角形の最下y座標の低いほうを起点に\n        //ある点から右か右斜め上に広げるイメージ\n        hs=llmin(y[j],np);\n        w=(hs-base)%3;\n        l=cval-x[j]-y[j];\n        //[三角形の最下点,領域の終点]\n        rgdigdp(l,y[j]-hs,np+(1ll<<i)-1-hs,get);\n        c+=get[(3+bm-w)%3];\n        c%=2;\n      }\n      if(c==0){\n        np+=(1ll<<i);\n      }\n    }\n    by=np;bx=cval-by;\n    //if(findcol(bx,by)==0){\n    //  return -1;\n    //}\n    lx=bx;\n    hx=bx;\n    for(i=60;i>=0;i--){\n      w=(1ll<<i);\n      if(findcol(lx-w,cval-(lx-w))==1){\n        lx-=w;\n      }\n      if(findcol(hx+w,cval-(hx+w))==1){\n        hx+=w;\n      }\n    }\n    printf(\"%lld %lld\\n\",lx,cval-hx);\n    return 0;\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.complex, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum LIM = 60;\nenum MASK_EVEN = 0x_5555_5555_5555_5555UL;\nenum MASK_ODD  = 0x_aaaa_aaaa_aaaa_aaaaUL;\n\n// for old compiler...\nint popcnt(ulong x) {\n  return core.bitop.popcnt(cast(uint)(x & 0x_ffff_ffffUL)) + core.bitop.popcnt(cast(uint)(x >> 32));\n}\n\nint N;\nlong[] X, Y;\n\nvoid main() {\n  auto binom = new int[][LIM];\n  foreach (n; 0 .. LIM) {\n    binom[n] = new int[n + 1];\n    binom[n][0] = binom[n][n] = 1;\n    foreach (k; 1 .. n) {\n      binom[n][k] = binom[n - 1][k - 1] + binom[n - 1][k];\n    }\n  }\n  auto cnt3 = new int[][][](LIM, LIM, 3);\n  foreach (a0; 0 .. LIM) foreach (a1; 0 .. LIM) {\n    foreach (b0; 0 .. a0 + 1) foreach (b1; 0 .. a1 + 1) {\n      cnt3[a0][a1][(b0 + 2 * b1) % 3] += binom[a0][b0] * binom[a1][b1];\n    }\n  }\n  debug {\n    foreach (a0; 0 .. 4) foreach (a1; 0 .. 4) {\n      writefln(\"cnt3[%s][%s] = %s\", a0, a1, cnt3[a0][a1]);\n    }\n  }\n  \n  try {\n    for (; ; ) {\n      N = readInt();\n      X = new long[N];\n      Y = new long[N];\n      foreach (i; 0 .. N) {\n        X[i] = readLong();\n        Y[i] = readLong();\n      }\n      \n      long y0;\n      long x0, x1;\n      foreach (i; 0 .. N) {\n        chmin(y0, Y[i]);\n        chmin(x0, X[i]);\n        chmax(x1, X[i] + Y[i] - y0);\n      }\n      debug {\n        writefln(\"y0 = %s\", y0);\n        writefln(\"[x0, x1] = [%s, %s]\", x0, x1);\n      }\n      \n      int calc(long x) {\n        int ret;\n        foreach (i; 0 .. N) {\n          const d = Y[i] - y0;\n          const k = x - X[i];\n          if (0 <= k && k <= d && (d & k) == k) {\n            ret ^= 1;\n          }\n        }\n        return ret;\n      }\n      int calc3(int s, long xL, long xR) {\n        debug {\n          int brt;\n          foreach (x; xL .. xR + 1) {\n            if ((x - s) % 3 == 0) {\n              foreach (i; 0 .. N) {\n                const d = Y[i] - y0;\n                const k = x - X[i];\n                if (0 <= k && k <= d && (d & k) == k) {\n                  ++brt;\n                }\n              }\n            }\n          }\n          writefln(\"calc3 %s [%s, %s] = %s\", s, xL, xR, brt);\n        }\n        int ret;\n        foreach (i; 0 .. N) {\n          // count k s.t. kL <= k <= kR, k == t (mod 3), C(d, k) == 1 (mod 2)\n          const d = Y[i] - y0;\n          const kL = max(xL - X[i], 0);\n          const kR = min(xR - X[i], d);\n          const t = cast(int)(((s - X[i]) % 3 + 3) % 3);\n          if (kL <= kR) {\n            /*\n            auto dp = new int[][][][](LIM + 1, 2, 2, 3);\n            foreach (a; 0 .. 2) foreach (b; 0 .. 2) {\n              dp[0][a][b][t] = 1;\n            }\n            foreach (pos; 0 .. LIM) {\n              const dM = (d >> pos) & 1;\n              const kLM = (kL >> pos) & 1;\n              const kRM = (kR >> pos) & 1;\n              foreach (a; 0 .. 2) foreach (b; 0 .. 2) foreach (c; 0 .. 3) {\n                foreach (z; 0 .. 2) {\n                  if ((a || kLM <= z) && (b || z <= kRM) && ((dM & z) == z)) {\n                    dp[pos + 1][a][b][c] += dp[pos][a || kLM < z][b || z < kRM][(c + ((pos & 1) ? 2 : 1) * z) % 3];\n                  }\n                }\n              }\n            }\n            debug {\n              writefln(\"  d = %s, [kL, kR] = [%s, %s], t = %s: %s\", d, kL, kR, t, dp[0][0][0][0]);\n            }\n            ret += dp[LIM][0][0][0];\n            */\n            \n            // k < kLim\n            int solve(long kLim) {\n              int sum;\n              foreach (pos; 0 .. LIM) {\n                if ((kLim >> pos) & 1) {\n                  const high = kLim & ~((1L << (pos + 1)) - 1);\n                  if ((d & high) == high) {\n                    const low = d & ((1L << pos) - 1);\n                    const a0 = popcnt(low & MASK_EVEN);\n                    const a1 = popcnt(low & MASK_ODD);\n                    const b0 = popcnt(high & MASK_EVEN);\n                    const b1 = popcnt(high & MASK_ODD);\n                    sum += cnt3[a0][a1][(t + 2 * b0 + b1) % 3];\n                  }\n                }\n              }\n              return sum;\n            }\n            ret += solve(kR + 1);\n            ret -= solve(kL);\n          }\n        }\n        debug {\n          writefln(\"  ret = %s & 1\", ret);\n        }\n        return ret & 1;\n      }\n      \n      long[] ans;\n      foreach (s; 0 .. 3) {\n        if (calc3(s, x0, x1)) {\n          long lo = x0, hi = x1 + 1;\n          for (; lo + 1 < hi; ) {\n            const mid = (lo + hi) / 2;\n            calc3(s, lo, mid - 1) ? (hi = mid) : (lo = mid);\n          }\n          assert((lo - s) % 3 == 0);\n          assert(calc(lo));\n          long x = lo;\n          foreach_reverse (e; 0 .. LIM) {\n            if (calc(x - (1L << e))) {\n              x -= (1L << e);\n            }\n          }\n          long h;\n          foreach (e; 0 .. LIM) {\n            if (calc(x + (1L << e))) {\n              h |= 1L << e;\n            }\n          }\n          ans = [x, y0 + h];\n          break;\n        }\n      }\n      assert(ans != []);\n      writeln(ans[0], \" \", ans[1]);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.complex, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum LIM = 60;\nenum MASK_EVEN = 0x_5555_5555_5555_5555UL;\nenum MASK_ODD  = 0x_aaaa_aaaa_aaaa_aaaaUL;\n\n// for old compiler...\nint popcnt(ulong x) {\n  return core.bitop.popcnt(cast(uint)(x & 0x_ffff_ffffUL)) + core.bitop.popcnt(cast(uint)(x >> 32));\n}\n\nint N;\nlong[] X, Y;\n\nvoid main() {\n  auto binom = new int[][LIM];\n  foreach (n; 0 .. LIM) {\n    binom[n] = new int[n + 1];\n    binom[n][0] = binom[n][n] = 1;\n    foreach (k; 1 .. n) {\n      binom[n][k] = binom[n - 1][k - 1] + binom[n - 1][k];\n    }\n  }\n  auto cnt3 = new int[][][](LIM, LIM, 3);\n  foreach (a0; 0 .. LIM) foreach (a1; 0 .. LIM) {\n    foreach (b0; 0 .. a0 + 1) foreach (b1; 0 .. a1 + 1) {\n      cnt3[a0][a1][(b0 + 2 * b1) % 3] += binom[a0][b0] * binom[a1][b1];\n    }\n  }\n  debug {\n    foreach (a0; 0 .. 4) foreach (a1; 0 .. 4) {\n      writefln(\"cnt3[%s][%s] = %s\", a0, a1, cnt3[a0][a1]);\n    }\n  }\n  \n  try {\n    for (; ; ) {\n      N = readInt();\n      X = new long[N];\n      Y = new long[N];\n      foreach (i; 0 .. N) {\n        X[i] = readLong();\n        Y[i] = readLong();\n      }\n      \n      long y0;\n      long x0, x1;\n      foreach (i; 0 .. N) {\n        chmin(y0, Y[i]);\n        chmin(x0, X[i]);\n        chmax(x1, X[i] + Y[i]);\n      }\n      debug {\n        writefln(\"y0 = %s\", y0);\n        writefln(\"[x0, x1] = [%s, %s]\", x0, x1);\n      }\n      \n      int calc(long x) {\n        int ret;\n        foreach (i; 0 .. N) {\n          const d = Y[i] - y0;\n          const k = x - X[i];\n          if (0 <= k && k <= d && (d & k) == k) {\n            ret ^= 1;\n          }\n        }\n        return ret;\n      }\n      int calc3(int s, long xL, long xR) {\n        debug {\n          int brt;\n          foreach (x; xL .. xR + 1) {\n            if ((x - s) % 3 == 0) {\n              foreach (i; 0 .. N) {\n                const d = Y[i] - y0;\n                const k = x - X[i];\n                if (0 <= k && k <= d && (d & k) == k) {\n                  ++brt;\n                }\n              }\n            }\n          }\n          writefln(\"calc3 %s [%s, %s] = %s\", s, xL, xR, brt);\n        }\n        int ret;\n        foreach (i; 0 .. N) {\n          // count k s.t. kL <= k <= kR, k == t (mod 3), C(d, k) == 1 (mod 2)\n          const d = Y[i] - y0;\n          const kL = max(xL - X[i], 0);\n          const kR = min(xR - X[i], d);\n          const t = cast(int)(((s - X[i]) % 3 + 3) % 3);\n          if (kL <= kR) {\n            /*\n            auto dp = new int[][][][](LIM + 1, 2, 2, 3);\n            foreach (a; 0 .. 2) foreach (b; 0 .. 2) {\n              dp[0][a][b][t] = 1;\n            }\n            foreach (pos; 0 .. LIM) {\n              const dM = (d >> pos) & 1;\n              const kLM = (kL >> pos) & 1;\n              const kRM = (kR >> pos) & 1;\n              foreach (a; 0 .. 2) foreach (b; 0 .. 2) foreach (c; 0 .. 3) {\n                foreach (z; 0 .. 2) {\n                  if ((a || kLM <= z) && (b || z <= kRM) && ((dM & z) == z)) {\n                    dp[pos + 1][a][b][c] += dp[pos][a || kLM < z][b || z < kRM][(c + ((pos & 1) ? 2 : 1) * z) % 3];\n                  }\n                }\n              }\n            }\n            debug {\n              writefln(\"  d = %s, [kL, kR] = [%s, %s], t = %s: %s\", d, kL, kR, t, dp[0][0][0][0]);\n            }\n            ret += dp[LIM][0][0][0];\n            */\n            \n            // k < kLim\n            int solve(long kLim) {\n              int sum;\n              foreach (pos; 0 .. LIM) {\n                if ((kLim >> pos) & 1) {\n                  const high = kLim & ~((1L << (pos + 1)) - 1);\n                  if ((d & high) == high) {\n                    const low = d & ((1L << pos) - 1);\n                    const a0 = popcnt(low & MASK_EVEN);\n                    const a1 = popcnt(low & MASK_ODD);\n                    const b0 = popcnt(high & MASK_EVEN);\n                    const b1 = popcnt(high & MASK_ODD);\n                    sum += cnt3[a0][a1][(t + 2 * b0 + b1) % 3];\n                  }\n                }\n              }\n              return sum;\n            }\n            ret += solve(kR + 1);\n            ret -= solve(kL);\n          }\n        }\n        debug {\n          writefln(\"  ret = %s & 1\", ret);\n        }\n        return ret & 1;\n      }\n      \n      long[] ans;\n      foreach (s; 0 .. 3) {\n        if (calc3(s, x0, x1)) {\n          long lo = x0, hi = x1 + 1;\n          for (; lo + 1 < hi; ) {\n            const mid = (lo + hi) / 2;\n            calc3(s, lo, mid - 1) ? (hi = mid) : (lo = mid);\n          }\n          // assert((lo - s) % 3 == 0);\n          // assert(calc(lo));\n          long x = lo;\n          foreach_reverse (e; 0 .. LIM) {\n            if (calc(x - (1L << e))) {\n              x -= (1L << e);\n            }\n          }\n          long h;\n          foreach (e; 0 .. LIM) {\n            if (calc(x + (1L << e))) {\n              h |= 1L << e;\n            }\n          }\n          ans = [x, y0 + h];\n          break;\n        }\n      }\n      // assert(ans != []);\nif(ans!=[])\n      writeln(ans[0], \" \", ans[1]);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.complex, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum LIM = 60;\nenum MASK_EVEN = 0x_5555_5555_5555_5555UL;\nenum MASK_ODD  = 0x_aaaa_aaaa_aaaa_aaaaUL;\n\n// for old compiler...\nint popcnt(ulong x) {\n  return core.bitop.popcnt(cast(uint)(x & 0x_ffff_ffffUL)) + core.bitop.popcnt(cast(uint)(x >> 32));\n}\n\nint N;\nlong[] X, Y;\n\nvoid main() {\n  auto binom = new int[][LIM];\n  foreach (n; 0 .. LIM) {\n    binom[n] = new int[n + 1];\n    binom[n][0] = binom[n][n] = 1;\n    foreach (k; 1 .. n) {\n      binom[n][k] = binom[n - 1][k - 1] + binom[n - 1][k];\n    }\n  }\n  auto cnt3 = new int[][][](LIM, LIM, 3);\n  foreach (a0; 0 .. LIM) foreach (a1; 0 .. LIM) {\n    foreach (b0; 0 .. a0 + 1) foreach (b1; 0 .. a1 + 1) {\n      cnt3[a0][a1][(b0 + 2 * b1) % 3] += binom[a0][b0] * binom[a1][b1];\n    }\n  }\n  debug {\n    foreach (a0; 0 .. 4) foreach (a1; 0 .. 4) {\n      writefln(\"cnt3[%s][%s] = %s\", a0, a1, cnt3[a0][a1]);\n    }\n  }\n  \n  try {\n    for (; ; ) {\n      N = readInt();\n      X = new long[N];\n      Y = new long[N];\n      foreach (i; 0 .. N) {\n        X[i] = readLong();\n        Y[i] = readLong();\n      }\n      \n      long y0;\n      long x0, x1;\n      foreach (i; 0 .. N) {\n        chmin(y0, Y[i]);\n        chmin(x0, X[i]);\n        chmax(x1, X[i] + Y[i]);\n      }\n      debug {\n        writefln(\"y0 = %s\", y0);\n        writefln(\"[x0, x1] = [%s, %s]\", x0, x1);\n      }\n      \n      int calc(long x) {\n        int ret;\n        foreach (i; 0 .. N) {\n          const d = Y[i] - y0;\n          const k = x - X[i];\n          if (0 <= k && k <= d && (d & k) == k) {\n            ret ^= 1;\n          }\n        }\n        return ret;\n      }\n      int calc3(int s, long xL, long xR) {\n        debug {\n          int brt;\n          foreach (x; xL .. xR + 1) {\n            if ((x - s) % 3 == 0) {\n              foreach (i; 0 .. N) {\n                const d = Y[i] - y0;\n                const k = x - X[i];\n                if (0 <= k && k <= d && (d & k) == k) {\n                  ++brt;\n                }\n              }\n            }\n          }\n          writefln(\"calc3 %s [%s, %s] = %s\", s, xL, xR, brt);\n        }\n        int ret;\n        foreach (i; 0 .. N) {\n          // count k s.t. kL <= k <= kR, k == t (mod 3), C(d, k) == 1 (mod 2)\n          const d = Y[i] - y0;\n          const kL = max(xL - X[i], 0);\n          const kR = min(xR - X[i], d);\n          const t = cast(int)(((s - X[i]) % 3 + 3) % 3);\n          if (kL <= kR) {\n            /*\n            auto dp = new int[][][][](LIM + 1, 2, 2, 3);\n            foreach (a; 0 .. 2) foreach (b; 0 .. 2) {\n              dp[0][a][b][t] = 1;\n            }\n            foreach (pos; 0 .. LIM) {\n              const dM = (d >> pos) & 1;\n              const kLM = (kL >> pos) & 1;\n              const kRM = (kR >> pos) & 1;\n              foreach (a; 0 .. 2) foreach (b; 0 .. 2) foreach (c; 0 .. 3) {\n                foreach (z; 0 .. 2) {\n                  if ((a || kLM <= z) && (b || z <= kRM) && ((dM & z) == z)) {\n                    dp[pos + 1][a][b][c] += dp[pos][a || kLM < z][b || z < kRM][(c + ((pos & 1) ? 2 : 1) * z) % 3];\n                  }\n                }\n              }\n            }\n            debug {\n              writefln(\"  d = %s, [kL, kR] = [%s, %s], t = %s: %s\", d, kL, kR, t, dp[0][0][0][0]);\n            }\n            ret += dp[LIM][0][0][0];\n            */\n            \n            // k < kLim\n            int solve(long kLim) {\n              int sum;\n              foreach (pos; 0 .. LIM) {\n                if ((kLim >> pos) & 1) {\n                  const high = kLim & ~((1L << (pos + 1)) - 1);\n                  if ((d & high) == high) {\n                    const low = d & ((1L << pos) - 1);\n                    const a0 = popcnt(low & MASK_EVEN);\n                    const a1 = popcnt(low & MASK_ODD);\n                    const b0 = popcnt(high & MASK_EVEN);\n                    const b1 = popcnt(high & MASK_ODD);\n                    sum += cnt3[a0][a1][(t + 2 * b0 + b1) % 3];\n                  }\n                }\n              }\n              return sum;\n            }\n            ret += solve(kR + 1);\n            ret -= solve(kL);\n          }\n        }\n        debug {\n          writefln(\"  ret = %s & 1\", ret);\n        }\n        return ret & 1;\n      }\n      \n      long[] ans;\n      foreach (s; 0 .. 3) {\n        if (calc3(s, x0, x1)) {\n          long lo = x0, hi = x1 + 1;\n          for (; lo + 1 < hi; ) {\n            const mid = (lo + hi) / 2;\n            calc3(s, lo, mid - 1) ? (hi = mid) : (lo = mid);\n          }\n          assert((lo - s) % 3 == 0);\n          assert(calc(lo));\n          long x = lo;\n          foreach_reverse (e; 0 .. LIM) {\n            if (calc(x - (1L << e))) {\n              x -= (1L << e);\n            }\n          }\n          long h;\n          foreach (e; 0 .. LIM) {\n            if (calc(x + (1L << e))) {\n              h |= 1L << e;\n            }\n          }\n          ans = [x, y0 + h];\n          break;\n        }\n      }\n      // assert(ans != []);\nif(ans!=[])\n      writeln(ans[0], \" \", ans[1]);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.complex, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum LIM = 60;\nenum MASK_EVEN = 0x_5555_5555_5555_5555UL;\nenum MASK_ODD  = 0x_aaaa_aaaa_aaaa_aaaaUL;\n\n// for old compiler...\nint popcnt(ulong x) {\n  return core.bitop.popcnt(cast(uint)(x & 0x_ffff_ffffUL)) + core.bitop.popcnt(cast(uint)(x >> 32));\n}\n\nint N;\nlong[] X, Y;\n\nvoid main() {\n  auto binom = new int[][LIM];\n  foreach (n; 0 .. LIM) {\n    binom[n] = new int[n + 1];\n    binom[n][0] = binom[n][n] = 1;\n    foreach (k; 1 .. n) {\n      binom[n][k] = binom[n - 1][k - 1] + binom[n - 1][k];\n    }\n  }\n  auto cnt3 = new int[][][](LIM, LIM, 3);\n  foreach (a0; 0 .. LIM) foreach (a1; 0 .. LIM) {\n    foreach (b0; 0 .. a0 + 1) foreach (b1; 0 .. a1 + 1) {\n      cnt3[a0][a1][(b0 + 2 * b1) % 3] += binom[a0][b0] * binom[a1][b1];\n    }\n  }\n  debug {\n    foreach (a0; 0 .. 4) foreach (a1; 0 .. 4) {\n      writefln(\"cnt3[%s][%s] = %s\", a0, a1, cnt3[a0][a1]);\n    }\n  }\n  \n  try {\n    for (; ; ) {\n      N = readInt();\n      X = new long[N];\n      Y = new long[N];\n      foreach (i; 0 .. N) {\n        X[i] = readLong();\n        Y[i] = readLong();\n      }\n      \n      long y0;\n      long x0, x1;\n      foreach (i; 0 .. N) {\n        chmin(y0, Y[i]);\n        chmin(x0, X[i]);\n        chmax(x1, X[i] + Y[i]);\n      }\n      debug {\n        writefln(\"y0 = %s\", y0);\n        writefln(\"[x0, x1] = [%s, %s]\", x0, x1);\n      }\n      \n      int calc(long x) {\n        int ret;\n        foreach (i; 0 .. N) {\n          const d = Y[i] - y0;\n          const k = x - X[i];\n          if (0 <= k && k <= d && (d & k) == k) {\n            ret ^= 1;\n          }\n        }\n        return ret;\n      }\n      int calc3(int s, long xL, long xR) {\n        debug {\n          int brt;\n          foreach (x; xL .. xR + 1) {\n            if ((x - s) % 3 == 0) {\n              foreach (i; 0 .. N) {\n                const d = Y[i] - y0;\n                const k = x - X[i];\n                if (0 <= k && k <= d && (d & k) == k) {\n                  ++brt;\n                }\n              }\n            }\n          }\n          writefln(\"calc3 %s [%s, %s] = %s\", s, xL, xR, brt);\n        }\n        int ret;\n        foreach (i; 0 .. N) {\n          // count k s.t. kL <= k <= kR, k == t (mod 3), C(d, k) == 1 (mod 2)\n          const d = Y[i] - y0;\n          const kL = max(xL - X[i], 0);\n          const kR = min(xR - X[i], d);\n          const t = cast(int)(((s - X[i]) % 3 + 3) % 3);\n          if (kL <= kR) {\n            /*\n            auto dp = new int[][][][](LIM + 1, 2, 2, 3);\n            foreach (a; 0 .. 2) foreach (b; 0 .. 2) {\n              dp[0][a][b][t] = 1;\n            }\n            foreach (pos; 0 .. LIM) {\n              const dM = (d >> pos) & 1;\n              const kLM = (kL >> pos) & 1;\n              const kRM = (kR >> pos) & 1;\n              foreach (a; 0 .. 2) foreach (b; 0 .. 2) foreach (c; 0 .. 3) {\n                foreach (z; 0 .. 2) {\n                  if ((a || kLM <= z) && (b || z <= kRM) && ((dM & z) == z)) {\n                    dp[pos + 1][a][b][c] += dp[pos][a || kLM < z][b || z < kRM][(c + ((pos & 1) ? 2 : 1) * z) % 3];\n                  }\n                }\n              }\n            }\n            debug {\n              writefln(\"  d = %s, [kL, kR] = [%s, %s], t = %s: %s\", d, kL, kR, t, dp[0][0][0][0]);\n            }\n            ret += dp[LIM][0][0][0];\n            */\n            \n            // k < kLim\n            int solve(long kLim) {\n              int sum;\n              foreach (pos; 0 .. LIM) {\n                if ((kLim >> pos) & 1) {\n                  const high = kLim & ~((1L << (pos + 1)) - 1);\n                  if ((d & high) == high) {\n                    const low = d & ((1L << pos) - 1);\n                    const a0 = popcnt(low & MASK_EVEN);\n                    const a1 = popcnt(low & MASK_ODD);\n                    const b0 = popcnt(high & MASK_EVEN);\n                    const b1 = popcnt(high & MASK_ODD);\n                    sum += cnt3[a0][a1][(t + 2 * b0 + b1) % 3];\n                  }\n                }\n              }\n              return sum;\n            }\n            ret += solve(kR + 1);\n            ret -= solve(kL);\n          }\n        }\n        debug {\n          writefln(\"  ret = %s & 1\", ret);\n        }\n        return ret & 1;\n      }\n      \n      long[] ans;\n      foreach (s; 0 .. 3) {\n        if (calc3(s, x0, x1)) {\n          long lo = x0, hi = x1 + 1;\n          for (; lo + 1 < hi; ) {\n            const mid = (lo + hi) / 2;\n            calc3(s, lo, mid - 1) ? (hi = mid) : (lo = mid);\n          }\n          assert((lo - s) % 3 == 0);\n          assert(calc(lo));\n          long x = lo;\n          foreach_reverse (e; 0 .. LIM) {\n            if (calc(x - (1L << e))) {\n              x -= (1L << e);\n            }\n          }\n          long h;\n          foreach (e; 0 .. LIM) {\n            if (calc(x + (1L << e))) {\n              h |= 1L << e;\n            }\n          }\n          ans = [x, y0 + h];\n          break;\n        }\n      }\n      assert(ans != []);\n      writeln(ans[0], \" \", ans[1]);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.complex, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum LIM = 60;\nenum MASK_EVEN = 0x_5555_5555_5555_5555UL;\nenum MASK_ODD  = 0x_aaaa_aaaa_aaaa_aaaaUL;\n\nint N;\nlong[] X, Y;\n\nvoid main() {\n  auto binom = new int[][LIM];\n  foreach (n; 0 .. LIM) {\n    binom[n] = new int[n + 1];\n    binom[n][0] = binom[n][n] = 1;\n    foreach (k; 1 .. n) {\n      binom[n][k] = binom[n - 1][k - 1] + binom[n - 1][k];\n    }\n  }\n  auto cnt3 = new int[][][](LIM, LIM, 3);\n  foreach (a0; 0 .. LIM) foreach (a1; 0 .. LIM) {\n    foreach (b0; 0 .. a0 + 1) foreach (b1; 0 .. a1 + 1) {\n      cnt3[a0][a1][(b0 + 2 * b1) % 3] += binom[a0][b0] * binom[a1][b1];\n    }\n  }\n  debug {\n    foreach (a0; 0 .. 4) foreach (a1; 0 .. 4) {\n      writefln(\"cnt3[%s][%s] = %s\", a0, a1, cnt3[a0][a1]);\n    }\n  }\n  \n  try {\n    for (; ; ) {\n      N = readInt();\n      X = new long[N];\n      Y = new long[N];\n      foreach (i; 0 .. N) {\n        X[i] = readLong();\n        Y[i] = readLong();\n      }\n      \n      long y0;\n      long x0, x1;\n      foreach (i; 0 .. N) {\n        chmin(y0, Y[i]);\n        chmin(x0, X[i]);\n        chmax(x1, X[i] + Y[i]);\n      }\n      debug {\n        writefln(\"y0 = %s\", y0);\n        writefln(\"[x0, x1] = [%s, %s]\", x0, x1);\n      }\n      \n      int calc(long x) {\n        int ret;\n        foreach (i; 0 .. N) {\n          const d = Y[i] - y0;\n          const k = x - X[i];\n          if (0 <= k && k <= d && (d & k) == k) {\n            ret ^= 1;\n          }\n        }\n        return ret;\n      }\n      int calc3(int s, long xL, long xR) {\n        debug {\n          int brt;\n          foreach (x; xL .. xR + 1) {\n            if ((x - s) % 3 == 0) {\n              foreach (i; 0 .. N) {\n                const d = Y[i] - y0;\n                const k = x - X[i];\n                if (0 <= k && k <= d && (d & k) == k) {\n                  ++brt;\n                }\n              }\n            }\n          }\n          writefln(\"calc3 %s [%s, %s] = %s\", s, xL, xR, brt);\n        }\n        int ret;\n        foreach (i; 0 .. N) {\n          // count k s.t. kL <= k <= kR, k == t (mod 3), C(d, k) == 1 (mod 2)\n          const d = Y[i] - y0;\n          const kL = max(xL - X[i], 0);\n          const kR = min(xR - X[i], d);\n          const t = cast(int)(((s - X[i]) % 3 + 3) % 3);\n          if (kL <= kR) {\n            /*\n            auto dp = new int[][][][](LIM + 1, 2, 2, 3);\n            foreach (a; 0 .. 2) foreach (b; 0 .. 2) {\n              dp[0][a][b][t] = 1;\n            }\n            foreach (pos; 0 .. LIM) {\n              const dM = (d >> pos) & 1;\n              const kLM = (kL >> pos) & 1;\n              const kRM = (kR >> pos) & 1;\n              foreach (a; 0 .. 2) foreach (b; 0 .. 2) foreach (c; 0 .. 3) {\n                foreach (z; 0 .. 2) {\n                  if ((a || kLM <= z) && (b || z <= kRM) && ((dM & z) == z)) {\n                    dp[pos + 1][a][b][c] += dp[pos][a || kLM < z][b || z < kRM][(c + ((pos & 1) ? 2 : 1) * z) % 3];\n                  }\n                }\n              }\n            }\n            debug {\n              writefln(\"  d = %s, [kL, kR] = [%s, %s], t = %s: %s\", d, kL, kR, t, dp[0][0][0][0]);\n            }\n            ret += dp[LIM][0][0][0];\n            */\n            \n            // k < kLim\n            int solve(long kLim) {\n              int sum;\n              foreach (pos; 0 .. LIM) {\n                if ((kLim >> pos) & 1) {\n                  const high = kLim & ~((1L << (pos + 1)) - 1);\n                  if ((d & high) == high) {\n                    const low = d & ((1L << pos) - 1);\n                    const a0 = popcnt(low & MASK_EVEN);\n                    const a1 = popcnt(low & MASK_ODD);\n                    const b0 = popcnt(high & MASK_EVEN);\n                    const b1 = popcnt(high & MASK_ODD);\n                    sum += cnt3[a0][a1][(t + 2 * b0 + b1) % 3];\n                  }\n                }\n              }\n              return sum;\n            }\n            ret += solve(kR + 1);\n            ret -= solve(kL);\n          }\n        }\n        debug {\n          writefln(\"  ret = %s & 1\", ret);\n        }\n        return ret & 1;\n      }\n      \n      long[] ans;\n      foreach (s; 0 .. 3) {\n        if (calc3(s, x0, x1)) {\n          long lo = x0, hi = x1 + 1;\n          for (; lo + 1 < hi; ) {\n            const mid = (lo + hi) / 2;\n            calc3(s, lo, mid - 1) ? (hi = mid) : (lo = mid);\n          }\n          assert((lo - s) % 3 == 0);\n          assert(calc(lo));\n          long x = lo;\n          foreach_reverse (e; 0 .. LIM) {\n            if (calc(x - (1L << e))) {\n              x -= (1L << e);\n            }\n          }\n          long h;\n          foreach (e; 0 .. LIM) {\n            if (calc(x + (1L << e))) {\n              h |= 1L << e;\n            }\n          }\n          ans = [x, y0 + h];\n          break;\n        }\n      }\n      assert(ans != []);\n      writeln(ans[0], \" \", ans[1]);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "D",
    "code": "import std.conv, std.functional, std.stdio, std.string;\nimport std.algorithm, std.array, std.bigint, std.complex, std.container, std.math, std.numeric, std.range, std.regex, std.typecons;\nimport core.bitop;\n\nclass EOFException : Throwable { this() { super(\"EOF\"); } }\nstring[] tokens;\nstring readToken() { for (; tokens.empty; ) { if (stdin.eof) { throw new EOFException; } tokens = readln.split; } auto token = tokens.front; tokens.popFront; return token; }\nint readInt() { return readToken.to!int; }\nlong readLong() { return readToken.to!long; }\nreal readReal() { return readToken.to!real; }\n\nbool chmin(T)(ref T t, in T f) { if (t > f) { t = f; return true; } else { return false; } }\nbool chmax(T)(ref T t, in T f) { if (t < f) { t = f; return true; } else { return false; } }\n\nint binarySearch(alias pred, T)(in T[] as) { int lo = -1, hi = cast(int)(as.length); for (; lo + 1 < hi; ) { const mid = (lo + hi) >> 1; (unaryFun!pred(as[mid]) ? hi : lo) = mid; } return hi; }\nint lowerBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a >= val)); }\nint upperBound(T)(in T[] as, T val) { return as.binarySearch!(a => (a > val)); }\n\n\nenum LIM = 60;\n\nint N;\nlong[] X, Y;\n\nvoid main() {\n  try {\n    for (; ; ) {\n      N = readInt();\n      X = new long[N];\n      Y = new long[N];\n      foreach (i; 0 .. N) {\n        X[i] = readLong();\n        Y[i] = readLong();\n      }\n      \n      long y0;\n      long x0, x1;\n      foreach (i; 0 .. N) {\n        chmin(y0, Y[i]);\n        chmin(x0, X[i]);\n        chmax(x1, X[i] + Y[i]);\n      }\n      debug {\n        writefln(\"y0 = %s\", y0);\n        writefln(\"[x0, x1] = [%s, %s]\", x0, x1);\n      }\n      \n      int calc(long x) {\n        int ret;\n        foreach (i; 0 .. N) {\n          const d = Y[i] - y0;\n          const k = x - X[i];\n          if (0 <= k && k <= d && (d & k) == k) {\n            ret ^= 1;\n          }\n        }\n        return ret;\n      }\n      int calc3(int s, long xL, long xR) {\n        debug {\n          int brt;\n          foreach (x; xL .. xR + 1) {\n            if ((x - s) % 3 == 0) {\n              foreach (i; 0 .. N) {\n                const d = Y[i] - y0;\n                const k = x - X[i];\n                if (0 <= k && k <= d && (d & k) == k) {\n                  ++brt;\n                }\n              }\n            }\n          }\n          writefln(\"calc3 %s [%s, %s] = %s\", s, xL, xR, brt);\n        }\n        int ret;\n        foreach (i; 0 .. N) {\n          // count k s.t. kL <= k <= kR, k == t (mod 3), C(d, k) == 1 (mod 2)\n          const d = Y[i] - y0;\n          const kL = max(xL - X[i], 0);\n          const kR = min(xR - X[i], d);\n          const t = ((s - X[i]) % 3 + 3) % 3;\n          if (kL <= kR) {\n            auto dp = new int[][][][](LIM + 1, 2, 2, 3);\n            foreach (a; 0 .. 2) foreach (b; 0 .. 2) {\n              dp[0][a][b][t] = 1;\n            }\n            foreach (pos; 0 .. LIM) {\n              const dM = (d >> pos) & 1;\n              const kLM = (kL >> pos) & 1;\n              const kRM = (kR >> pos) & 1;\n              foreach (a; 0 .. 2) foreach (b; 0 .. 2) foreach (c; 0 .. 3) {\n                foreach (z; 0 .. 2) {\n                  if ((a || kLM <= z) && (b || z <= kRM) && ((dM & z) == z)) {\n                    dp[pos + 1][a][b][c] += dp[pos][a || kLM < z][b || z < kRM][(c + ((pos & 1) ? 2 : 1) * z) % 3];\n                  }\n                }\n              }\n            }\n            debug {\n              writefln(\"  d = %s, [kL, kR] = [%s, %s], t = %s: %s\", d, kL, kR, t, dp[0][0][0][0]);\n            }\n            ret += dp[LIM][0][0][0];\n          }\n        }\n        return ret & 1;\n      }\n      \n      long[] ans;\n      foreach (s; 0 .. 3) {\n        if (calc3(s, x0, x1)) {\n          long lo = x0, hi = x1 + 1;\n          for (; lo + 1 < hi; ) {\n            const mid = (lo + hi) / 2;\n            calc3(s, lo, mid - 1) ? (hi = mid) : (lo = mid);\n          }\n          assert((lo - s) % 3 == 0);\n          assert(calc(lo));\n          long x = lo;\n          foreach_reverse (e; 0 .. LIM) {\n            if (calc(x - (1L << e))) {\n              x -= (1L << e);\n            }\n          }\n          long h;\n          foreach (e; 0 .. LIM) {\n            if (calc(x + (1L << e))) {\n              h |= 1L << e;\n            }\n          }\n          ans = [x, y0 + h];\n          break;\n        }\n      }\n      assert(ans != []);\n      writeln(ans[0], \" \", ans[1]);\n    }\n  } catch (EOFException e) {\n  }\n}\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport itertools\nimport copy\n\n\ndef is_pair(a, b):\n  d = abs(a - b)\n  x = 1\n\n  while x <= d:\n    if x == d:\n      return True\n\n    x *= 2\n\n  return False\n\n\ndef search(coods):\n  while len(coods) > 1:\n    xc, yc = zip(*coods)\n    xc = sum(xc) / len(xc)\n    yc = sum(yc) / len(yc)\n\n    pairs = set()\n    targets = {c: 0 for c in coods}\n\n    for (x1, y1), (x2, y2) in itertools.combinations(coods, 2):\n      x3, y3 = None, None\n\n      if is_pair(x1, x2) and y1 == y2:\n        x3 = min(x1, x2)\n        y3 = y1 + abs(x1 - x2)\n      elif x1 == x2 and is_pair(y1, y2):\n        x3 = x1 + abs(y1 - y2)\n        y3 = min(y1, y2)\n      elif is_pair(x1, x2) and abs(x1 - x2) == abs(y1 - y2):\n        x3 = min(x1, x2)\n        y3 = min(y1, y2)\n\n      if x3 is not None:\n        pairs.add(((x1, y1), (x2, y2), (x3, y3), abs(xc - x3) + abs(yc - y3), max(abs(x1 - x2), abs(y1 - y2))))\n        targets[(x1, y1)] += 1\n        targets[(x2, y2)] += 1\n\n    if len(pairs) == 0:\n      return None\n\n    pairs = [(p1, p2, p3, c, d, min(targets[p1], targets[p2])) for p1, p2, p3, c, d in pairs]\n    pairs.sort(key=lambda x: (x[5], x[3], x[4]))\n\n    if pairs[0][4] == 1:\n      p1, p2, p3, _, _, _ = pairs[0]\n      coods.remove(p1)\n      coods.remove(p2)\n      coods.add(p3)\n      continue\n\n    for p1, p2, p3, _, _, _ in pairs:\n      clone = copy.copy(coods)\n      clone.remove(p1)\n      clone.remove(p2)\n      clone.add(p3)\n\n      start = search(clone)\n\n      if start is not None:\n        return start\n\n    return None\n\n  return list(coods)[0]\n\n\ndef main():\n  n = int(input())\n  coods = set([tuple(map(int, input().split())) for _ in range(n)])\n  start = search(coods)\n\n  print(start[0], start[1], flush=True)\n\n\nif __name__ == '__main__':\n  main()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport itertools\nimport copy\n\n\ndef is_pair(a, b):\n  d = abs(a - b)\n  x = 1\n\n  while x <= d:\n    if x == d:\n      return True\n\n    x *= 2\n\n  return False\n\n\ndef search(coods):\n  while len(coods) > 1:\n    xc, yc = zip(*coods)\n    xc = sum(xc) / len(xc)\n    yc = sum(yc) / len(yc)\n\n    pairs = set()\n    targets = {c: 0 for c in coods}\n\n    for (x1, y1), (x2, y2) in itertools.combinations(coods, 2):\n      x3, y3 = None, None\n\n      if is_pair(x1, x2) and y1 == y2:\n        x3 = min(x1, x2)\n        y3 = y1 + abs(x1 - x2)\n      elif x1 == x2 and is_pair(y1, y2):\n        x3 = x1 + abs(y1 - y2)\n        y3 = min(y1, y2)\n      elif is_pair(x1, x2) and abs(x1 - x2) == abs(y1 - y2):\n        x3 = min(x1, x2)\n        y3 = min(y1, y2)\n\n      if x3 is not None:\n        pairs.add(((x1, y1), (x2, y2), (x3, y3), abs(xc - x3) + abs(yc - y3), max(abs(x1 - x2), abs(y1 - y2))))\n        targets[(x1, y1)] += 1\n        targets[(x2, y2)] += 1\n\n    if len(pairs) == 0:\n      return None\n\n    pairs = [(p1, p2, p3, c, d, min(targets[p1], targets[p2])) for p1, p2, p3, c, d in pairs]\n    pairs.sort(key=lambda x: (x[5], x[3], x[4]))\n\n    if pairs[0][4] == 1:\n      p1, p2, p3, _, _, _ = pairs[0]\n      coods.remove(p1)\n      coods.remove(p2)\n      coods.add(p3)\n      continue\n\n    for p1, p2, p3, _, _, _ in pairs:\n      clone = copy.copy(coods)\n      clone.remove(p1)\n      clone.remove(p2)\n      clone.add(p3)\n\n      start = search(clone)\n\n      if start is not None:\n        return start\n\n  return list(coods)[0]\n\n\ndef main():\n  n = int(input())\n  coods = set([tuple(map(int, input().split())) for _ in range(n)])\n  start = search(coods)\n\n  print(start[0], start[1], flush=True)\n\n\nif __name__ == '__main__':\n  main()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport itertools\nimport copy\n\n\ndef is_pair(a, b):\n  d = abs(a - b)\n  x = 1\n\n  while x <= d:\n    if x == d:\n      return True\n\n    x *= 2\n\n  return False\n\n\ndef search(coods):\n  while len(coods) > 1:\n    pairs = set()\n    targets = {c: 0 for c in coods}\n\n    for (x1, y1), (x2, y2) in itertools.combinations(coods, 2):\n      x3, y3 = None, None\n\n      if is_pair(x1, x2) and y1 == y2:\n        x3 = min(x1, x2)\n        y3 = y1 + abs(x1 - x2)\n      elif x1 == x2 and is_pair(y1, y2):\n        x3 = x1 + abs(y1 - y2)\n        y3 = min(y1, y2)\n      elif is_pair(x1, x2) and abs(x1 - x2) == abs(y1 - y2):\n        x3 = min(x1, x2)\n        y3 = min(y1, y2)\n\n      if x3 is not None:\n        pairs.add(((x1, y1), (x2, y2), (x3, y3), max(abs(x1 - x2), abs(y1 - y2))))\n        targets[(x1, y1)] += 1\n        targets[(x2, y2)] += 1\n\n    if len(pairs) == 0:\n      return None\n\n    pairs = [(p1, p2, p3, d, min(targets[p1], targets[p2])) for p1, p2, p3, d in pairs]\n    pairs.sort(key=lambda x: (x[4], x[3]))\n\n    if pairs[0][4] == 1:\n      p1, p2, p3, _, _ = pairs[0]\n      coods.remove(p1)\n      coods.remove(p2)\n      coods.add(p3)\n      continue\n\n    for p1, p2, p3, _, _ in pairs:\n      clone = copy.copy(coods)\n      clone.remove(p1)\n      clone.remove(p2)\n      clone.add(p3)\n\n      start = search(clone)\n\n      if start is not None:\n        return start\n\n  return list(coods)[0]\n\n\ndef main():\n  n = int(input())\n  coods = set([tuple(map(int, input().split())) for _ in range(n)])\n  start = search(coods)\n\n  print(start[0], start[1], flush=True)\n\n\nif __name__ == '__main__':\n  main()\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\nimport itertools\nimport copy\n\n\ndef is_pair(a, b):\n  d = abs(a - b)\n  x = 1\n\n  while x <= d:\n    if x == d:\n      return True\n\n    x *= 2\n\n  return False\n\n\ndef search(coods):\n  while len(coods) > 1:\n    triangle = None\n\n    for x, y  in coods:\n      if (x + 1, y) in coods and (x, y + 1) in coods:\n        triangle = (x, y)\n        break\n\n    if triangle is not None:\n      coods.remove((x, y))\n      coods.remove((x + 1, y))\n      coods.remove((x, y + 1))\n      continue\n\n    pairs = set()\n    targets = {c: 0 for c in coods}\n\n    for (x1, y1), (x2, y2) in itertools.combinations(coods, 2):\n      x3, y3 = None, None\n\n      if is_pair(x1, x2) and y1 == y2:\n        x3 = min(x1, x2)\n        y3 = y1 + abs(x1 - x2)\n      elif x1 == x2 and is_pair(y1, y2):\n        x3 = x1 + abs(y1 - y2)\n        y3 = min(y1, y2)\n      elif is_pair(x1, x2) and abs(x1 - x2) == abs(y1 - y2):\n        x3 = min(x1, x2)\n        y3 = min(y1, y2)\n\n      if x3 is not None and (x3, y3) not in coods:\n        pairs.add(((x1, y1), (x2, y2), (x3, y3), max(abs(x1 - x2), abs(y1 - y2))))\n        targets[(x1, y1)] += 1\n        targets[(x2, y2)] += 1\n\n    if len(pairs) == 0:\n      return None\n\n    pairs = [(p1, p2, p3, d, min(targets[p1], targets[p2])) for p1, p2, p3, d in pairs]\n    pairs.sort(key=lambda x: (x[4], x[3]))\n\n    if pairs[0][4] == 1:\n      p1, p2, p3, _, _ = pairs[0]\n      coods.remove(p1)\n      coods.remove(p2)\n      coods.add(p3)\n      continue\n\n    for p1, p2, p3, _, _ in pairs:\n      clone = copy.copy(coods)\n      clone.remove(p1)\n      clone.remove(p2)\n      clone.add(p3)\n\n      start = search(clone)\n\n      if start is not None:\n        return start\n\n    return None\n\n  return list(coods)[0]\n\n\ndef main():\n  n = int(input())\n  coods = set([tuple(map(int, input().split())) for _ in range(n)])\n  start = search(coods)\n\n  print(start[0], start[1], flush=True)\n\n\nif __name__ == '__main__':\n  main()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\nfrom collections import defaultdict\nfrom heapq import heapify, heappop, heappush\n\n\ndef move(lights):\n    new_lights = defaultdict(set)\n    for y, xs in lights.items():\n        for x in xs:\n            new_lights[-(x + y)].add(y)\n    lights = new_lights\n    ys = list(lights.keys())\n    heapify(ys)\n    prev_y = None\n    while ys:\n        y = heappop(ys)\n        if y == prev_y:\n            continue\n        xs = sorted(lights[y])\n        for l, r in zip(xs[::2], xs[1::2]):\n            f = l\n            while f < r:\n                d = 1\n                while f + d <= r:\n                    d <<= 1\n                d >>= 1\n                ny = y + d\n                lights[ny].symmetric_difference_update({f})\n                heappush(ys, ny)\n                f += d\n            lights[y].difference_update({l, r})\n        prev_y = y\n    return lights\n\n\nn = int(input())\nxys = [tuple(map(int, line.split())) for line in sys.stdin]\nlights = defaultdict(set)\nfor x, y in xys:\n    lights[y].add(x)\n\nlights = move(lights)\nlights = move(lights)\nlights = move(lights)\nfor y, xs in lights.items():\n    if xs:\n        print(xs.pop())\n        break\n"
  }
]