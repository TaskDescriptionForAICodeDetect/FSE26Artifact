[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\nint compare(const void* a, const void* b) {\n    Point* p1 = (Point*)a;\n    Point* p2 = (Point*)b;\n    \n    if (p1->y < p2->y) return -1;\n    if (p1->y > p2->y) return 1;\n    if (p1->x < p2->x) return -1;\n    if (p1->x > p2->x) return 1;\n    return 0;\n}\n\ndouble cross_product(Point p1, Point p2, Point p3) {\n    return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);\n}\n\nPoint* convex_hull(Point* points, int n, int* hull_size) {\n    if (n < 3) {\n        *hull_size = n;\n        return points;\n    }\n    \n    qsort(points, n, sizeof(Point), compare);\n    \n    Point* hull = malloc(n * sizeof(Point));\n    int m = 0;\n    \n    for (int i = 0; i < n; i++) {\n        while (m >= 2 && cross_product(hull[m-2], hull[m-1], points[i]) <= 0) {\n            m--;\n        }\n        hull[m++] = points[i];\n    }\n    \n    int t = m + 1;\n    for (int i = n - 2; i >= 0; i--) {\n        while (m >= t && cross_product(hull[m-2], hull[m-1], points[i]) <= 0) {\n            m--;\n        }\n        hull[m++] = points[i];\n    }\n    \n    *hull_size = m - 1;\n    return hull;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    \n    Point* points = malloc(n * sizeof(Point));\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n    }\n    \n    int hull_size;\n    Point* hull = convex_hull(points, n, &hull_size);\n    \n    printf(\"Convex Hull Points:\\n\");\n    for (int i = 0; i < hull_size; i++) {\n        printf(\"(%.2f, %.2f)\\n\", hull[i].x, hull[i].y);\n    }\n    \n    free(points);\n    free(hull);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:14:51"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint cross_product(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nint compare_points(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    if (p1->x != p2->x) {\n        return p1->x - p2->x;\n    } else {\n        return p1->y - p2->y;\n    }\n}\n\nvoid convex_hull(Point points[], int n, Point hull[], int *hull_size) {\n    if (n < 3) {\n        for (int i = 0; i < n; i++) {\n            hull[i] = points[i];\n        }\n        *hull_size = n;\n        return;\n    }\n\n    qsort(points, n, sizeof(Point), compare_points);\n\n    Point upper[n], lower[n];\n    int upper_size = 0, lower_size = 0;\n\n    for (int i = 0; i < n; i++) {\n        while (upper_size >= 2 && cross_product(upper[upper_size - 2], upper[upper_size - 1], points[i]) <= 0) {\n            upper_size--;\n        }\n        upper[upper_size++] = points[i];\n    }\n\n    for (int i = n - 1; i >= 0; i--) {\n        while (lower_size >= 2 && cross_product(lower[lower_size - 2], lower[lower_size - 1], points[i]) <= 0) {\n            lower_size--;\n        }\n        lower[lower_size++] = points[i];\n    }\n\n    *hull_size = 0;\n    for (int i = 0; i < upper_size - 1; i++) {\n        hull[(*hull_size)++] = upper[i];\n    }\n    for (int i = 0; i < lower_size - 1; i++) {\n        hull[(*hull_size)++] = lower[i];\n    }\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Point points[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &points[i].x, &points[i].y);\n    }\n\n    Point hull[n];\n    int hull_size;\n    convex_hull(points, n, hull, &hull_size);\n\n    for (int i = 0; i < hull_size; i++) {\n        printf(\"(%d, %d)\\n\", hull[i].x, hull[i].y);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:15:24"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <stack>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x = 0, int y = 0) : x(x), y(y) {}\n};\n\nPoint pivot;\n\nint cross(const Point& a, const Point& b, const Point& c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nint distSq(const Point& a, const Point& b) {\n    return (a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y);\n}\n\nbool compare(const Point& a, const Point& b) {\n    int orientation = cross(pivot, a, b);\n    if (orientation == 0)\n        return distSq(pivot, a) < distSq(pivot, b);\n    return orientation > 0;\n}\n\nvector<Point> convexHull(vector<Point>& points) {\n    int n = points.size();\n    if (n <= 1) return points;\n\n    int minIdx = 0;\n    for (int i = 1; i < n; i++) {\n        if (points[i].y < points[minIdx].y || \n            (points[i].y == points[minIdx].y && points[i].x < points[minIdx].x))\n            minIdx = i;\n    }\n    swap(points[0], points[minIdx]);\n    pivot = points[0];\n\n    sort(points.begin() + 1, points.end(), compare);\n\n    vector<Point> hull;\n    hull.push_back(points[0]);\n    hull.push_back(points[1]);\n\n    for (int i = 2; i < n; i++) {\n        while (hull.size() >= 2) {\n            Point top = hull.back();\n            hull.pop_back();\n            Point nextTop = hull.back();\n            if (cross(nextTop, top, points[i]) > 0) {\n                hull.push_back(top);\n                break;\n            }\n        }\n        hull.push_back(points[i]);\n    }\n\n    return hull;\n}",
    "timestamp": "2025-08-05 22:16:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class ConvexHull {\n    public List<int[]> outerTrees(int[][] points) {\n        if (points.length <= 1) {\n            return Arrays.asList(points);\n        }\n        \n        Arrays.sort(points, (p, q) -> p[0] == q[0] ? p[1] - q[1] : p[0] - q[0]);\n        List<int[]> hull = new ArrayList<>();\n        \n        for (int[] point : points) {\n            while (hull.size() >= 2 && cross(hull.get(hull.size() - 2), hull.get(hull.size() - 1), point) > 0) {\n                hull.remove(hull.size() - 1);\n            }\n            hull.add(point);\n        }\n        hull.remove(hull.size() - 1);\n        \n        for (int i = points.length - 1; i >= 0; i--) {\n            int[] point = points[i];\n            while (hull.size() >= 2 && cross(hull.get(hull.size() - 2), hull.get(hull.size() - 1), point) > 0) {\n                hull.remove(hull.size() - 1);\n            }\n            hull.add(point);\n        }\n        hull.remove(hull.size() - 1);\n        \n        return new ArrayList<>(new LinkedHashSet<>(hull));\n    }\n    \n    private int cross(int[] o, int[] a, int[] b) {\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n    }\n}",
    "timestamp": "2025-08-05 22:16:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass ConvexHull {\n    static class Point {\n        int x, y;\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static int orientation(Point p, Point q, Point r) {\n        int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n        if (val == 0) return 0;\n        return (val > 0) ? 1 : 2;\n    }\n\n    static List<Point> convexHull(Point[] points) {\n        int n = points.length;\n        if (n < 3) return Arrays.asList(points);\n\n        int leftmostIndex = 0;\n        for (int i = 1; i < n; i++) {\n            if (points[i].x < points[leftmostIndex].x) {\n                leftmostIndex = i;\n            }\n        }\n\n        List<Point> hull = new ArrayList<>();\n        int p = leftmostIndex, q;\n        do {\n            hull.add(points[p]);\n            q = (p + 1) % n;\n            for (int i = 0; i < n; i++) {\n                if (orientation(points[p], points[i], points[q]) == 2) {\n                    q = i;\n                }\n            }\n            p = q;\n        } while (p != leftmostIndex);\n\n        return hull;\n    }\n\n    public static void main(String[] args) {\n        Point[] points = {\n            new Point(0, 3),\n            new Point(2, 2),\n            new Point(1, 1),\n            new Point(2, 1),\n            new Point(3, 0),\n            new Point(0, 0)\n        };\n\n        List<Point> convexHullPoints = convexHull(points);\n        for (Point p : convexHullPoints) {\n            System.out.println(\"(\" + p.x + \", \" + p.y + \")\");\n        }\n    }\n}",
    "timestamp": "2025-08-05 22:16:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <algorithm>\n#include <vector>\n#include <cmath>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int _x = 0, int _y = 0) : x(_x), y(_y) {}\n    \n    bool operator < (const Point& p) const {\n        return x < p.x || (x == p.x && y < p.y);\n    }\n};\n\nint cross_product(Point o, Point a, Point b) {\n    return (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);\n}\n\nvector<Point> convex_hull(vector<Point>& points) {\n    int n = points.size();\n    if (n <= 3) return points;\n    \n    // Sort points lexicographically\n    sort(points.begin(), points.end());\n    \n    vector<Point> hull;\n    \n    // Lower hull\n    for (int i = 0; i < n; i++) {\n        while (hull.size() >= 2 && cross_product(hull[hull.size()-2], hull.back(), points[i]) <= 0) {\n            hull.pop_back();\n        }\n        hull.push_back(points[i]);\n    }\n    \n    // Upper hull\n    int t = hull.size() + 1;\n    for (int i = n - 2; i >= 0; i--) {\n        while (hull.size() >= t && cross_product(hull[hull.size()-2], hull.back(), points[i]) <= 0) {\n            hull.pop_back();\n        }\n        hull.push_back(points[i]);\n    }\n    \n    hull.pop_back();\n    return hull;\n}",
    "timestamp": "2025-08-05 22:16:45"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def convex_hull(points):\n    # Sort the points lexicographically (tuples are compared elementwise)\n    points = sorted(set(points))\n\n    # Boring case: no points or a single point, possibly repeated multiple times\n    if len(points) <= 1:\n        return points\n\n    def cross(o, a, b):\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])\n\n    # Build the lower hull \n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n\n    # Build the upper hull\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n\n    # Concatenate lower and upper hull to make the full hull\n    # The last point of each half is omitted because it is repeated at the beginning of the other half\n    return lower[:-1] + upper[:-1]\n\n# Example usage:\n# P = [(0, 0), (1, 1), (2, 2), (0, 2), (2, 0), (1, -1)]\n# print(convex_hull(P))",
    "timestamp": "2025-08-13 09:42:59"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Point {\n    int x, y;\n    Point(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n}\n\npublic class ConvexHull {\n\n    public static List<Point> convexHull(Point[] points) {\n        if (points.length < 3) return Arrays.asList(points);\n        \n        List<Point> hull = new ArrayList<>();\n        \n        int l = 0;\n        for (int i = 1; i < points.length; i++)\n            if (points[i].x < points[l].x)\n                l = i;\n        \n        int p = l, q;\n        do {\n            hull.add(points[p]);\n            \n            q = (p + 1) % points.length;\n            \n            for (int i = 0; i < points.length; i++) {\n                if (orientation(points[p], points[i], points[q]) == 2)\n                    q = i;\n            }\n            \n            p = q;\n\n        } while (p != l);\n        \n        return hull;\n    }\n    \n    private static int orientation(Point p, Point q, Point r) {\n        int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n        if (val == 0) return 0;  // collinear\n        return (val > 0) ? 1 : 2; // clock or counterclockwise\n    }\n    \n    public static void main(String[] args) {\n        Point[] points = { new Point(0, 3), new Point(2, 3), new Point(1, 1),\n                           new Point(2, 1), new Point(3, 0), new Point(0, 0),\n                           new Point(3, 3) };\n        \n        List<Point> hull = convexHull(points);\n        \n        for (Point p : hull)\n            System.out.println(\"(\" + p.x + \", \" + p.y + \")\");\n    }\n}",
    "timestamp": "2025-08-13 09:43:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\n// Function to find the orientation of the ordered triplet (p, q, r).\nint orientation(Point p, Point q, Point r) {\n    int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0) return 0; // Collinear\n    return (val > 0)? 1: 2; // Clockwise or Counterclockwise\n}\n\n// Function to swap two points\nvoid swap(Point *p1, Point *p2) {\n    Point temp = *p1;\n    *p1 = *p2;\n    *p2 = temp;\n}\n\n// Sort an array of points with respect to the first point\nint compare(const void *vp1, const void *vp2, void *base) {\n    Point *p0 = (Point *)base;\n    Point *p1 = (Point *)vp1;\n    Point *p2 = (Point *)vp2;\n    int o = orientation(*p0, *p1, *p2);\n    if (o == 0)\n        return ((*p2).x - p1->x) ? (p1->x - p2->x) : (p1->y - p2->y);\n    return (o == 2) ? -1 : 1;\n}\n\n// Function to compute convex hull\nvoid convexHull(Point points[], int n) {\n    if (n < 3) return; // Convex hull not possible\n    \n    // Initialize the result\n    Point hull[n];\n    int hull_size = 0;\n\n    // Find the leftmost point\n    int l = 0;\n    for (int i = 1; i < n; i++) {\n        if (points[i].x < points[l].x)\n            l = i;\n    }\n\n    // Start from leftmost point, keep moving counterclockwise\n    // until reaching the start point again\n    int p = l, q;\n    do {\n        // Add current point to result\n        hull[hull_size++] = points[p];\n\n        // Search for a point 'q' such that orientation(p, q, x) is\n        // counterclockwise for all points 'x'. The idea is to keep track of last\n        // visited most counterclockwise point in q. If any point 'i' is more\n        // counterclockwise than q, then update q\n        q = (p + 1) % n;\n        for (int i = 0; i < n; i++) {\n           if (orientation(points[p], points[i], points[q]) == 2)\n               q = i;\n        }\n\n        // Now q is the most counterclockwise with respect to p\n        // Set p as q for next iteration, so that q is added to result\n        p = q;\n\n    } while (p != l); // While we don't come to the first point\n    \n    // Print Result\n    for (int i = 0; i < hull_size; i++)\n        printf(\"(%d, %d)\\n\", hull[i].x, hull[i].y);\n}\n\nint main() {\n    // Example points\n    Point points[] = {{0, 3}, {2, 3}, {1, 1}, {2, 1}, {3, 0}, {0, 0}, {3, 3}};\n    int n = sizeof(points)/sizeof(points[0]);\n    convexHull(points, n);\n    return 0;\n}",
    "timestamp": "2025-08-13 09:43:21"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def convex_hull(points):\n    # Handle edge cases\n    if len(points) <= 3:\n        return points\n    \n    # Find the point with the lowest y-coordinate (and leftmost if tied)\n    start = min(points, key=lambda p: (p[1], p[0]))\n    \n    # Sort points by polar angle with respect to the start point\n    def polar_angle(point):\n        x = point[0] - start[0]\n        y = point[1] - start[1]\n        return (x, y)\n    \n    sorted_points = sorted(points, key=lambda p: (\n        math.atan2(p[1] - start[1], p[0] - start[0]), \n        (p[0] - start[0])**2 + (p[1] - start[1])**2\n    ))\n    \n    # Graham's scan algorithm\n    hull = [start]\n    for point in sorted_points[1:]:\n        while len(hull) > 1 and cross_product(hull[-2], hull[-1], point) <= 0:\n            hull.pop()\n        hull.append(point)\n    \n    return hull\n\ndef cross_product(o, a, b):\n    # Calculate cross product to determine turn direction\n    return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0])",
    "timestamp": "2025-08-13 09:43:38"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def cross(o, a, b):\n    return (a[0] - o[0])*(b[1] - o[1]) - (a[1] - o[1])*(b[0] - o[0])\n\ndef convex_hull(points):\n    points = sorted(points)\n    if len(points) <= 1:\n        return points\n    \n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n    \n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n    \n    return lower[:-1] + upper[:-1]",
    "timestamp": "2025-08-13 09:43:56"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Point {\n    int x, y;\n\n    bool operator<(const Point& p) const {\n        return x < p.x || (x == p.x && y < p.y);\n    }\n};\n\n// Cross product of vector OA and OB\n// A positive cross product indicates that O->A->B is a counter-clockwise turn\nint cross(const Point& O, const Point& A, const Point& B) {\n    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);\n}\n\nvector<Point> convexHull(vector<Point>& points) {\n    int n = points.size();\n    if (n < 3) return {};\n\n    // Sort the points lexicographically (by x then by y)\n    sort(points.begin(), points.end());\n\n    vector<Point> hull;\n\n    // Build the lower hull\n    for (int i = 0; i < n; ++i) {\n        while (hull.size() >= 2 && cross(hull[hull.size() - 2], hull.back(), points[i]) <= 0) {\n            hull.pop_back();\n        }\n        hull.push_back(points[i]);\n    }\n\n    // Build the upper hull\n    int t = hull.size() + 1;\n    for (int i = n - 2; i >= 0; --i) {\n        while (hull.size() >= t && cross(hull[hull.size() - 2], hull.back(), points[i]) <= 0) {\n            hull.pop_back();\n        }\n        hull.push_back(points[i]);\n    }\n\n    // Remove the last point as it is the same as the first point of the closed loop\n    hull.pop_back();\n\n    return hull;\n}\n\nint main() {\n    vector<Point> points = {{0, 3}, {1, 1}, {2, 2}, {4, 4}, \n                            {0, 0}, {1, 2}, {3, 1}, {3, 3}};\n    \n    vector<Point> hull = convexHull(points);\n\n    cout << \"Convex Hull:\" << endl;\n    for (const Point& p : hull) {\n        cout << \"(\" << p.x << \", \" << p.y << \")\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:53:59"
  }
]