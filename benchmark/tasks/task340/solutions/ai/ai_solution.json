[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    int number;\n    char color;\n} Card;\n\nint compare(const void *a, const void *b) {\n    Card *cardA = (Card *)a;\n    Card *cardB = (Card *)b;\n    if (cardA->color != cardB->color) {\n        return cardA->color - cardB->color;\n    }\n    return cardA->number - cardB->number;\n}\n\nint is_valid_set(Card *set) {\n    if (set[0].color == set[1].color && set[1].color == set[2].color) {\n        if (set[0].number == set[1].number && set[1].number == set[2].number) {\n            return 1;\n        }\n        if (set[0].number + 1 == set[1].number && set[1].number + 1 == set[2].number) {\n            return 1;\n        }\n    }\n    return 0;\n}\n\nint check_win(Card *cards) {\n    qsort(cards, 9, sizeof(Card), compare);\n    \n    for (int i = 0; i < 9; i += 3) {\n        if (!is_valid_set(&cards[i])) {\n            return 0;\n        }\n    }\n    return 1;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    \n    while (T--) {\n        Card cards[9];\n        for (int i = 0; i < 9; i++) {\n            scanf(\"%d\", &cards[i].number);\n        }\n        for (int i = 0; i < 9; i++) {\n            scanf(\" %c\", &cards[i].color);\n        }\n        \n        if (check_win(cards)) {\n            printf(\"1\\n\");\n        } else {\n            printf(\"0\\n\");\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:08:56"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Card {\n    int num;\n    char color;\n};\n\nbool isSameColor(const vector<Card>& cards) {\n    char color = cards[0].color;\n    for (const Card& card : cards) {\n        if (card.color != color) return false;\n    }\n    return true;\n}\n\nbool isSameNumber(const vector<Card>& cards) {\n    int num = cards[0].num;\n    for (const Card& card : cards) {\n        if (card.num != num) return false;\n    }\n    return true;\n}\n\nbool isSequential(const vector<Card>& cards) {\n    vector<int> nums;\n    for (const Card& card : cards) {\n        nums.push_back(card.num);\n    }\n    sort(nums.begin(), nums.end());\n    for (int i = 1; i < nums.size(); ++i) {\n        if (nums[i] != nums[i-1] + 1) return false;\n    }\n    return true;\n}\n\nbool isValidSet(const vector<Card>& set) {\n    if (!isSameColor(set)) return false;\n    return isSameNumber(set) || isSequential(set);\n}\n\nbool checkSets(const vector<Card>& hand, const vector<int>& indices) {\n    vector<vector<Card>> sets(3);\n    for (int i = 0; i < 9; ++i) {\n        sets[indices[i]].push_back(hand[i]);\n    }\n    for (const auto& set : sets) {\n        if (!isValidSet(set)) return false;\n    }\n    return true;\n}\n\nbool canWin(const vector<Card>& hand) {\n    vector<int> indices(9);\n    for (int i = 0; i < 9; ++i) {\n        indices[i] = i / 3;\n    }\n    do {\n        if (checkSets(hand, indices)) return true;\n    } while (next_permutation(indices.begin(), indices.end()));\n    return false;\n}\n\nint main() {\n    int T;\n    cin >> T;\n    while (T--) {\n        vector<Card> hand(9);\n        for (int i = 0; i < 9; ++i) {\n            cin >> hand[i].num;\n        }\n        for (int i = 0; i < 9; ++i) {\n            cin >> hand[i].color;\n        }\n        cout << (canWin(hand) ? \"1\" : \"0\") << endl;\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:09:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class UTRummy {\n    static class Card {\n        int number;\n        char color;\n        \n        Card(int number, char color) {\n            this.number = number;\n            this.color = color;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (scanner.hasNext()) {\n            List<Card> cards = new ArrayList<>();\n            for (int i = 0; i < 9; i++) {\n                int num = scanner.nextInt();\n                cards.add(new Card(num, scanner.next().charAt(0)));\n            }\n            System.out.println(canWin(cards) ? 1 : 0);\n        }\n    }\n    \n    private static boolean canWin(List<Card> cards) {\n        return backtrack(cards, new boolean[9], 0, 0);\n    }\n    \n    private static boolean backtrack(List<Card> cards, boolean[] used, int setCount, int start) {\n        if (setCount == 3) {\n            return true;\n        }\n        for (int i = start; i < 9; i++) {\n            if (!used[i]) {\n                for (int j = i + 1; j < 9; j++) {\n                    if (!used[j]) {\n                        for (int k = j + 1; k < 9; k++) {\n                            if (!used[k] && isValidSet(cards.get(i), cards.get(j), cards.get(k))) {\n                                used[i] = used[j] = used[k] = true;\n                                if (backtrack(cards, used, setCount + 1, i + 1)) {\n                                    return true;\n                                }\n                                used[i] = used[j] = used[k] = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    \n    private static boolean isValidSet(Card a, Card b, Card c) {\n        if (a.color != b.color || b.color != c.color) {\n            return false;\n        }\n        List<Integer> numbers = Arrays.asList(a.number, b.number, c.number);\n        Collections.sort(numbers);\n        if (numbers.get(0) == numbers.get(1) && numbers.get(1) == numbers.get(2)) {\n            return true;\n        }\n        return numbers.get(0) + 1 == numbers.get(1) && numbers.get(1) + 1 == numbers.get(2);\n    }\n}",
    "timestamp": "2025-08-05 21:10:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class UTRummyWinChecker {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n\n        for (int d = 0; d < datasets; d++) {\n            List<Card> cards = new ArrayList<>();\n            \n            for (int i = 0; i < 9; i++) {\n                int number = scanner.nextInt();\n                String color = scanner.next();\n                cards.add(new Card(number, color));\n            }\n\n            System.out.println(checkWinConditions(cards) ? \"YES\" : \"NO\");\n        }\n    }\n\n    static boolean checkWinConditions(List<Card> cards) {\n        return findSets(cards, 0, new ArrayList<>());\n    }\n\n    static boolean findSets(List<Card> cards, int startIndex, List<List<Card>> currentSets) {\n        if (currentSets.size() == 3) {\n            return cards.isEmpty();\n        }\n\n        for (int i = startIndex; i < cards.size(); i++) {\n            for (int j = i + 1; j < cards.size(); j++) {\n                for (int k = j + 1; k < cards.size(); k++) {\n                    Card card1 = cards.get(i);\n                    Card card2 = cards.get(j);\n                    Card card3 = cards.get(k);\n\n                    if (isValidSet(card1, card2, card3)) {\n                        List<Card> set = Arrays.asList(card1, card2, card3);\n                        List<Card> remainingCards = new ArrayList<>(cards);\n                        remainingCards.removeAll(set);\n\n                        List<List<Card>> newSets = new ArrayList<>(currentSets);\n                        newSets.add(set);\n\n                        if (findSets(remainingCards, 0, newSets)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    static boolean isValidSet(Card card1, Card card2, Card card3) {\n        return (isSameColor(card1, card2, card3) && \n                (isSameNumber(card1, card2, card3) || isSequential(card1, card2, card3)));\n    }\n\n    static boolean isSameColor(Card card1, Card card2, Card card3) {\n        return card1.color.equals(card2.color) && card2.color.equals(card3.color);\n    }\n\n    static boolean isSameNumber(Card card1, Card card2, Card card3) {\n        return card1.number == card2.number && card2.number == card3.number;\n    }\n\n    static boolean isSequential(Card card1, Card card2, Card card3) {\n        List<Integer> numbers = Arrays.asList(card1.number, card2.number, card3.number);\n        Collections.sort(numbers);\n        return numbers.get(1) == numbers.get(0) + 1 && \n               numbers.get(2) == numbers.get(1) + 1;\n    }\n\n    static class Card {\n        int number;\n        String color;\n\n        Card(int number, String color) {\n            this.number = number;\n            this.color = color;\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:10:20"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define MAX_CARDS 9\n\ntypedef struct {\n    int number;\n    char color;\n} Card;\n\nbool is_same_color_set(Card set[3]) {\n    return set[0].color == set[1].color && set[1].color == set[2].color;\n}\n\nbool is_same_number_set(Card set[3]) {\n    return set[0].number == set[1].number && set[1].number == set[2].number;\n}\n\nbool is_sequential_set(Card set[3]) {\n    Card sorted[3];\n    for (int i = 0; i < 3; i++) sorted[i] = set[i];\n    \n    for (int i = 0; i < 2; i++) {\n        for (int j = 0; j < 2 - i; j++) {\n            if (sorted[j].number > sorted[j+1].number) {\n                Card temp = sorted[j];\n                sorted[j] = sorted[j+1];\n                sorted[j+1] = temp;\n            }\n        }\n    }\n    \n    return is_same_color_set(set) && \n           sorted[0].number + 1 == sorted[1].number && \n           sorted[1].number + 1 == sorted[2].number;\n}\n\nbool check_winning_condition(Card cards[MAX_CARDS]) {\n    for (int i = 0; i < MAX_CARDS; i++) {\n        for (int j = i + 1; j < MAX_CARDS; j++) {\n            for (int k = j + 1; k < MAX_CARDS; k++) {\n                Card set1[3] = {cards[i], cards[j], cards[k]};\n                bool set1_valid = is_same_number_set(set1) || is_sequential_set(set1);\n                \n                if (set1_valid) {\n                    Card remaining[6];\n                    int r_idx = 0;\n                    for (int m = 0; m < MAX_CARDS; m++) {\n                        if (m != i && m != j && m != k) {\n                            remaining[r_idx++] = cards[m];\n                        }\n                    }\n                    \n                    for (int a = 0; a < 6; a++) {\n                        for (int b = a + 1; b < 6; b++) {\n                            for (int c = b + 1; c < 6; c++) {\n                                Card set2[3] = {remaining[a], remaining[b], remaining[c]};\n                                bool set2_valid = is_same_number_set(set2) || is_sequential_set(set2);\n                                \n                                if (set2_valid) {\n                                    Card set3[3];\n                                    int s3_idx = 0;\n                                    for (int m = 0; m < 6; m++) {\n                                        if (m != a && m != b && m != c) {\n                                            set3[s3_idx++] = remaining[m];\n                                        }\n                                    }\n                                    \n                                    if (is_same_number_set(set3) || is_sequential_set(set3)) {\n                                        return true;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return false;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    \n    while (T--) {\n        Card cards[MAX_CARDS];\n        for (int i = 0; i < MAX_CARDS; i++) {\n            scanf(\"%d %c\", &cards[i].number, &cards[i].color);\n        }\n        \n        printf(\"%s\\n\", check_winning_condition(cards) ? \"Yes\" : \"No\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:10:33"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <unordered_map>\nusing namespace std;\n\nbool checkWinningCondition(vector<pair<int, char>>& hand) {\n    // Sort the hand by color first, then number\n    sort(hand.begin(), hand.end(), [](const auto& a, const auto& b) {\n        return a.second < b.second || (a.second == b.second && a.first < b.first);\n    });\n\n    // Try to form sets of same color\n    unordered_map<char, vector<int>> colorGroups;\n    for (auto& card : hand) {\n        colorGroups[card.second].push_back(card.first);\n    }\n\n    int validSets = 0;\n    for (auto& [color, numbers] : colorGroups) {\n        sort(numbers.begin(), numbers.end());\n        \n        // Check for same number sets\n        unordered_map<int, int> numberCount;\n        for (int num : numbers) {\n            numberCount[num]++;\n        }\n        \n        for (auto& [num, count] : numberCount) {\n            if (count >= 3) {\n                validSets++;\n                for (int i = 0; i < numbers.size(); i++) {\n                    if (numbers[i] == num) {\n                        numbers.erase(numbers.begin() + i);\n                        i--;\n                        count--;\n                        if (count == 0) break;\n                    }\n                }\n            }\n        }\n        \n        // Check for sequential sets\n        for (int i = 0; i <= (int)numbers.size() - 3; i++) {\n            if (numbers[i+1] == numbers[i] + 1 && numbers[i+2] == numbers[i] + 2) {\n                validSets++;\n                numbers.erase(numbers.begin() + i, numbers.begin() + i + 3);\n                i--;\n            }\n        }\n    }\n\n    return validSets == 3;\n}\n\nint main() {\n    int T;\n    cin >> T;\n    \n    while (T--) {\n        vector<pair<int, char>> hand(9);\n        for (int i = 0; i < 9; i++) {\n            cin >> hand[i].first >> hand[i].second;\n        }\n        \n        cout << (checkWinningCondition(hand) ? \"YES\" : \"NO\") << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:10:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_winning_hand(hand):\n    def is_valid_set(cards):\n        if len(set(card[1] for card in cards)) != 1:\n            return False\n        numbers = sorted(card[0] for card in cards)\n        return numbers[0] == numbers[1] == numbers[2] or (numbers[2] - numbers[0] == 2 and numbers[1] - numbers[0] == 1)\n\n    def check_sets(cards, used_indices=set(), sets_found=0):\n        if sets_found == 3:\n            return True\n        for i in range(len(cards)):\n            if i in used_indices:\n                continue\n            for j in range(i + 1, len(cards)):\n                if j in used_indices:\n                    continue\n                for k in range(j + 1, len(cards)):\n                    if k in used_indices:\n                        continue\n                    if is_valid_set([cards[i], cards[j], cards[k]]):\n                        if check_sets(cards, used_indices | {i, j, k}, sets_found + 1):\n                            return True\n        return False\n\n    return check_sets(hand)\n\ndatasets = [\n    [(1, 'red'), (2, 'red'), (3, 'red'), (4, 'blue'), (5, 'blue'), (6, 'blue'), (7, 'green'), (7, 'green'), (7, 'green')],\n    [(1, 'red'), (1, 'red'), (1, 'red'), (2, 'blue'), (3, 'blue'), (4, 'blue'), (5, 'green'), (5, 'green'), (5, 'green')],\n]\n\nresults = [is_winning_hand(dataset) for dataset in datasets]\nprint(results)",
    "timestamp": "2025-08-13 05:12:04"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class UTRummyValidator {\n    \n    public static boolean isWinningHand(List<Card> hand) {\n        if (hand.size() != 9) return false;\n        \n        Map<String, List<Integer>> colorToNumbersMap = new HashMap<>();\n        \n        for (Card card : hand) {\n            colorToNumbersMap.putIfAbsent(card.color, new ArrayList<>());\n            colorToNumbersMap.get(card.color).add(card.number);\n        }\n\n        int validSetsCount = 0;\n        \n        for (Map.Entry<String, List<Integer>> entry : colorToNumbersMap.entrySet()) {\n            List<Integer> numbers = entry.getValue();\n            if (numbers.size() < 3) continue;\n            \n            Collections.sort(numbers);\n            validSetsCount += countValidSets(numbers);\n        }\n        \n        return validSetsCount >= 3;\n    }\n\n    private static int countValidSets(List<Integer> numbers) {\n        int sets = 0;\n        \n        // Count sets of same numbers\n        Map<Integer, Long> frequencyMap = new HashMap<>();\n        for (int num : numbers) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0L) + 1);\n        }\n        for (long count : frequencyMap.values()) {\n            sets += count / 3;\n        }\n\n        // Count sets of sequential numbers\n        int n = numbers.size();\n        for (int i = 0; i <= n - 3; i++) {\n            if (numbers.get(i) + 1 == numbers.get(i + 1) && \n                numbers.get(i + 1) + 1 == numbers.get(i + 2)) {\n                sets++;\n                i += 2;\n            }\n        }\n        \n        return sets;\n    }\n\n    public static void main(String[] args) {\n        // Example: multiple datasets\n        List<List<Card>> datasets = Arrays.asList(\n            Arrays.asList(\n                new Card(1, \"red\"), new Card(2, \"red\"), new Card(3, \"red\"),\n                new Card(4, \"blue\"), new Card(4, \"blue\"), new Card(4, \"blue\"),\n                new Card(7, \"green\"), new Card(8, \"green\"), new Card(9, \"green\")\n            ),\n            Arrays.asList(\n                new Card(1, \"red\"), new Card(1, \"red\"), new Card(1, \"red\"),\n                new Card(4, \"blue\"), new Card(5, \"blue\"), new Card(6, \"blue\"),\n                new Card(7, \"green\"), new Card(8, \"green\"), new Card(9, \"yellow\")\n            )\n        );\n        \n        for (List<Card> hand : datasets) {\n            System.out.println(isWinningHand(hand) ? \"Winning hand\" : \"Not a winning hand\");\n        }\n    }\n}\n\nclass Card {\n    int number;\n    String color;\n    \n    Card(int number, String color) {\n        this.number = number;\n        this.color = color;\n    }\n}",
    "timestamp": "2025-08-13 05:12:10"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\ntypedef struct {\n    int number;\n    char color;\n} Card;\n\nint compareNumberAsc(const void *a, const void *b) {\n    return ((Card*)a)->number - ((Card*)b)->number;\n}\n\nbool isSequential(Card set[3]) {\n    qsort(set, 3, sizeof(Card), compareNumberAsc);\n    return set[0].number + 1 == set[1].number && set[1].number + 1 == set[2].number;\n}\n\nbool isSameNumber(Card set[3]) {\n    return set[0].number == set[1].number && set[1].number == set[2].number;\n}\n\nbool isSetValid(Card set[3]) {\n    return isSameNumber(set) || isSequential(set);\n}\n\nbool areWinningCards(Card hand[9]) {\n    bool used[9] = {false};\n\n    for (int i = 0; i < 9; i++) {\n        for (int j = i + 1; j < 9; j++) {\n            for (int k = j + 1; k < 9; k++) {\n                if (hand[i].color == hand[j].color && hand[j].color == hand[k].color) {\n                    Card set[3] = {hand[i], hand[j], hand[k]};\n                    if (isSetValid(set)) {\n                        used[i] = true;\n                        used[j] = true;\n                        used[k] = true;\n                    }\n                }\n            }\n        }\n    }\n\n    int validSets = 0;\n    for (int i = 0; i < 9; i += 3) {\n        if (used[i] && used[i + 1] && used[i + 2]) {\n            validSets++;\n        }\n    }\n\n    return validSets == 3;\n}\n\nint main() {\n    int datasets;\n    scanf(\"%d\", &datasets);\n\n    for (int d = 0; d < datasets; d++) {\n        Card hand[9];\n        for (int i = 0; i < 9; i++) {\n            scanf(\"%d %c\", &hand[i].number, &hand[i].color);\n        }\n\n        if (areWinningCards(hand)) {\n            printf(\"Winning hand\\n\");\n        } else {\n            printf(\"Not a winning hand\\n\");\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 05:12:15"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def check_winning_condition(cards):\n    # Sort cards by color and number\n    cards.sort(key=lambda x: (x[1], x[0]))\n    \n    # Group cards by color\n    color_groups = {}\n    for card in cards:\n        if card[1] not in color_groups:\n            color_groups[card[1]] = []\n        color_groups[card[1]].append(card[0])\n    \n    # Check all possible color combinations\n    for c1 in color_groups:\n        for c2 in color_groups:\n            for c3 in color_groups:\n                if c1 == c2 == c3:\n                    group1 = color_groups[c1]\n                    if len(group1) < 9:\n                        continue\n                    \n                    # Try all possible partitions\n                    for set1 in range(len(group1)):\n                        for set2 in range(set1+1, len(group1)):\n                            for set3 in range(set2+1, len(group1)):\n                                subset1 = [group1[set1], group1[set1+1], group1[set1+2]]\n                                subset2 = [group1[set2], group1[set2+1], group1[set2+2]]\n                                subset3 = [group1[set3], group1[set3+1], group1[set3+2]]\n                                \n                                # Check if sets are valid\n                                if (is_same_number(subset1) or is_sequential(subset1)) and \\\n                                   (is_same_number(subset2) or is_sequential(subset2)) and \\\n                                   (is_same_number(subset3) or is_sequential(subset3)):\n                                    return \"YES\"\n    return \"NO\"\n\ndef is_same_number(subset):\n    return len(set(subset)) == 1\n\ndef is_sequential(subset):\n    sorted_subset = sorted(subset)\n    return sorted_subset[2] - sorted_subset[1] == 1 and sorted_subset[1] - sorted_subset[0] == 1\n\n# Read input and process\ndef main():\n    T = int(input())\n    for _ in range(T):\n        cards = []\n        for i in range(9):\n            num, color = input().split()\n            cards.append((int(num), color))\n        print(check_winning_condition(cards))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:12:26"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve():\n    import sys\n    input = sys.stdin.read().split()\n    idx = 0\n    T = int(input[idx])\n    idx += 1\n    for _ in range(T):\n        cards = []\n        for _ in range(9):\n            num = int(input[idx])\n            color = input[idx + 1]\n            cards.append((num, color))\n            idx += 2\n        \n        from itertools import combinations\n        \n        def is_valid_set(three_cards):\n            nums = [card[0] for card in three_cards]\n            colors = [card[1] for card in three_cards]\n            if len(set(colors)) != 1:\n                return False\n            if len(set(nums)) == 1:\n                return True\n            sorted_nums = sorted(nums)\n            if sorted_nums[0] + 1 == sorted_nums[1] and sorted_nums[1] + 1 == sorted_nums[2]:\n                return True\n            return False\n        \n        found = False\n        for first_set in combinations(cards, 3):\n            if not is_valid_set(first_set):\n                continue\n            remaining1 = [card for card in cards if card not in first_set]\n            for second_set in combinations(remaining1, 3):\n                if not is_valid_set(second_set):\n                    continue\n                remaining2 = [card for card in remaining1 if card not in second_set]\n                if len(remaining2) != 3:\n                    continue\n                if is_valid_set(remaining2):\n                    found = True\n                    break\n            if found:\n                break\n        print(1 if found else 0)\n\nsolve()",
    "timestamp": "2025-08-13 05:12:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n\nusing namespace std;\n\n// Helper function to check if three cards form a valid set\nbool isValidSet(vector<pair<int, char>>& cards) {\n    if (cards[0].second != cards[1].second || cards[1].second != cards[2].second) {\n        return false;\n    }\n    if ((cards[0].first == cards[1].first && cards[1].first == cards[2].first) || // all same number\n        (cards[0].first + 1 == cards[1].first && cards[1].first + 1 == cards[2].first)) { // sequential\n        return true;\n    }\n    return false;\n}\n\n// Recursive function to check all permutations and combinations\nbool canFormWinningHand(vector<pair<int, char>>& hand, int index, vector<vector<pair<int, char>>>& sets) {\n    if (index == hand.size()) {\n        for (const auto& set : sets) {\n            if (!isValidSet(set)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    for (int i = 0; i < sets.size(); ++i) {\n        if (sets[i].size() < 3) {\n            sets[i].push_back(hand[index]);\n            if (canFormWinningHand(hand, index + 1, sets)) {\n                return true;\n            }\n            sets[i].pop_back();\n        }\n    }\n\n    return false;\n}\n\nint main() {\n    int datasets;\n    cin >> datasets;\n    while (datasets--) {\n        vector<pair<int, char>> hand(9);\n        for (int i = 0; i < 9; ++i) {\n            cin >> hand[i].first >> hand[i].second;\n        }\n\n        vector<vector<pair<int, char>>> sets(3);\n        sort(hand.begin(), hand.end());\n        bool result = false;\n        \n        do {\n            result = canFormWinningHand(hand, 0, sets);\n            if (result) break;\n        } while (next_permutation(hand.begin(), hand.end()));\n\n        if (result) {\n            cout << \"WIN\" << endl;\n        } else {\n            cout << \"LOSE\" << endl;\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:23:37"
  }
]