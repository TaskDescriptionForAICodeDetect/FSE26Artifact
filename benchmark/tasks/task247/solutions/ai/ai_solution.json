[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint cube[3][3][3];\nint top[3][3], front[3][3];\nint sums[1000];\nint sum_count = 0;\n\nvoid check_cube() {\n    // Check top and front views\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            if (cube[i][j][2] != top[i][j]) return;\n            if (cube[0][i][j] != front[i][j]) return;\n        }\n    }\n    \n    // Check adjacent faces sum to 7\n    for (int x = 0; x < 3; x++) {\n        for (int y = 0; y < 3; y++) {\n            for (int z = 0; z < 3; z++) {\n                if (x > 0 && cube[x][y][z] + cube[x-1][y][z] != 7) return;\n                if (y > 0 && cube[x][y][z] + cube[x][y-1][z] != 7) return;\n                if (z > 0 && cube[x][y][z] + cube[x][y][z-1] != 7) return;\n            }\n        }\n    }\n    \n    // Calculate right side sum\n    int sum = 0;\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            sum += cube[2][i][j];\n        }\n    }\n    \n    // Check for duplicate sums\n    for (int i = 0; i < sum_count; i++) {\n        if (sums[i] == sum) return;\n    }\n    \n    sums[sum_count++] = sum;\n}\n\nvoid fill_cube(int x, int y, int z) {\n    if (x == 3) {\n        check_cube();\n        return;\n    }\n    \n    int next_x = x, next_y = y, next_z = z;\n    next_z++;\n    if (next_z == 3) {\n        next_z = 0;\n        next_y++;\n    }\n    if (next_y == 3) {\n        next_y = 0;\n        next_x++;\n    }\n    \n    // Determine possible values for current die\n    int possible[6];\n    int count = 0;\n    \n    for (int val = 1; val <= 6; val++) {\n        int valid = 1;\n        \n        // Check adjacent dice\n        if (x > 0 && cube[x-1][y][z] + val != 7) valid = 0;\n        if (y > 0 && cube[x][y-1][z] + val != 7) valid = 0;\n        if (z > 0 && cube[x][y][z-1] + val != 7) valid = 0;\n        \n        // Check top and front constraints if applicable\n        if (z == 2 && val != top[x][y]) valid = 0;\n        if (x == 0 && val != front[y][z]) valid = 0;\n        \n        if (valid) possible[count++] = val;\n    }\n    \n    for (int i = 0; i < count; i++) {\n        cube[x][y][z] = possible[i];\n        fill_cube(next_x, next_y, next_z);\n    }\n}\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    // Read input\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            scanf(\"%d\", &top[i][j]);\n        }\n    }\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            scanf(\"%d\", &front[i][j]);\n        }\n    }\n    \n    fill_cube(0, 0, 0);\n    \n    if (sum_count == 0) {\n        printf(\"0\\n\");\n    } else {\n        qsort(sums, sum_count, sizeof(int), compare);\n        for (int i = 0; i < sum_count; i++) {\n            printf(\"%d \", sums[i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:16:41"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class CubePuzzle {\n    static int[] dx = {1, 0, -1, 0};\n    static int[] dy = {0, 1, 0, -1};\n    static int[] dz = {1, -1};\n\n    public static int[] solveCubePuzzle(int[][] topView, int[][] frontView) {\n        Set<Integer> rightSideSums = new TreeSet<>();\n        int[][][] cube = new int[3][3][3];\n        \n        boolean found = backtrack(cube, topView, frontView, 0, 0, 0);\n        \n        if (!found) return new int[]{0};\n        \n        return rightSideSums.stream().mapToInt(Integer::intValue).toArray();\n    }\n\n    private static boolean backtrack(int[][][] cube, int[][] topView, int[][] frontView, int x, int y, int z) {\n        if (z == 3) {\n            if (validateViews(cube, topView, frontView)) {\n                int rightSum = calculateRightSum(cube);\n                rightSideSums.add(rightSum);\n                return true;\n            }\n            return false;\n        }\n\n        for (int val = 1; val <= 6; val++) {\n            cube[x][y][z] = val;\n            \n            if (isValidPlacement(cube, x, y, z)) {\n                int nextX = (x + 1) % 3;\n                int nextY = nextX == 0 ? y + 1 : y;\n                int nextZ = nextY == 3 ? z + 1 : z;\n                \n                backtrack(cube, topView, frontView, nextX, nextY, nextZ);\n            }\n        }\n        return false;\n    }\n\n    private static boolean isValidPlacement(int[][][] cube, int x, int y, int z) {\n        if (x > 0 && cube[x][y][z] + cube[x-1][y][z] != 7) return false;\n        if (y > 0 && cube[x][y][z] + cube[x][y-1][z] != 7) return false;\n        if (z > 0 && cube[x][y][z] + cube[x][y][z-1] != 7) return false;\n        return true;\n    }\n\n    private static boolean validateViews(int[][][] cube, int[][] topView, int[][] frontView) {\n        // Top view validation\n        for (int x = 0; x < 3; x++) {\n            for (int y = 0; y < 3; y++) {\n                if (topView[x][y] != 0 && topView[x][y] != cube[x][y][0]) {\n                    return false;\n                }\n            }\n        }\n\n        // Front view validation\n        for (int x = 0; x < 3; x++) {\n            for (int z = 0; z < 3; z++) {\n                if (frontView[x][z] != 0 && frontView[x][z] != cube[x][0][z]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private static int calculateRightSum(int[][][] cube) {\n        int sum = 0;\n        for (int y = 0; y < 3; y++) {\n            for (int z = 0; z < 3; z++) {\n                sum += cube[2][y][z];\n            }\n        }\n        return sum;\n    }\n}",
    "timestamp": "2025-08-05 19:16:52"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Dice {\n    int top, front, right;\n};\n\nbool isValid(const Dice& d) {\n    if (d.top + d.front == 7 || d.top + d.right == 7 || d.front + d.right == 7) return false;\n    if (d.top < 1 || d.top > 6 || d.front < 1 || d.front > 6 || d.right < 1 || d.right > 6) return false;\n    return true;\n}\n\nint getRight(int top, int front) {\n    if (top == 1) {\n        if (front == 2) return 3;\n        if (front == 3) return 5;\n        if (front == 4) return 2;\n        if (front == 5) return 4;\n    } else if (top == 2) {\n        if (front == 1) return 4;\n        if (front == 3) return 1;\n        if (front == 4) return 6;\n        if (front == 6) return 3;\n    } else if (top == 3) {\n        if (front == 1) return 2;\n        if (front == 2) return 6;\n        if (front == 5) return 1;\n        if (front == 6) return 5;\n    } else if (top == 4) {\n        if (front == 1) return 5;\n        if (front == 2) return 1;\n        if (front == 5) return 6;\n        if (front == 6) return 2;\n    } else if (top == 5) {\n        if (front == 1) return 3;\n        if (front == 3) return 6;\n        if (front == 4) return 1;\n        if (front == 6) return 4;\n    } else if (top == 6) {\n        if (front == 2) return 4;\n        if (front == 3) return 2;\n        if (front == 4) return 5;\n        if (front == 5) return 3;\n    }\n    return -1;\n}\n\nvoid solve(const vector<vector<int>>& topView, const vector<vector<int>>& frontView, set<int>& sums) {\n    vector<vector<vector<Dice>>> cube(3, vector<vector<Dice>>(3, vector<Dice>(3)));\n    \n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            int top = topView[i][j];\n            int front = frontView[i][j];\n            int right = getRight(top, front);\n            if (right == -1) return;\n            cube[i][j][0] = {top, front, right};\n        }\n    }\n    \n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            for (int k = 1; k < 3; ++k) {\n                if (i > 0) {\n                    int adjTop = cube[i-1][j][k].top;\n                    int adjFront = cube[i-1][j][k].front;\n                    int adjRight = cube[i-1][j][k].right;\n                    if (cube[i][j][k-1].top + adjTop != 7) return;\n                }\n                if (j > 0) {\n                    int adjTop = cube[i][j-1][k].top;\n                    int adjFront = cube[i][j-1][k].front;\n                    int adjRight = cube[i][j-1][k].right;\n                    if (cube[i][j][k-1].front + adjFront != 7) return;\n                }\n                if (k > 0) {\n                    int adjTop = cube[i][j][k-1].top;\n                    int adjFront = cube[i][j][k-1].front;\n                    int adjRight = cube[i][j][k-1].right;\n                    if (cube[i][j][k-1].right + adjRight != 7) return;\n                }\n                \n                int top = cube[i][j][0].top;\n                int front = cube[i][j][0].front;\n                int right = cube[i][j][0].right;\n                \n                if (k == 1) {\n                    front = 7 - cube[i][j][0].front;\n                    right = getRight(top, front);\n                    if (right == -1) return;\n                } else if (k == 2) {\n                    top = 7 - cube[i][j][0].top;\n                    right = getRight(top, front);\n                    if (right == -1) return;\n                }\n                \n                cube[i][j][k] = {top, front, right};\n                if (!isValid(cube[i][j][k])) return;\n            }\n        }\n    }\n    \n    int sum = 0;\n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            for (int k = 0; k < 3; ++k) {\n                sum += cube[i][j][k].right;\n            }\n        }\n    }\n    sums.insert(sum);\n}\n\nint main() {\n    vector<vector<int>> topView(3, vector<int>(3));\n    vector<vector<int>> frontView(3, vector<int>(3));\n    \n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> topView[i][j];\n        }\n    }\n    \n    for (int i = 0; i < 3; ++i) {\n        for (int j = 0; j < 3; ++j) {\n            cin >> frontView[i][j];\n        }\n    }\n    \n    set<int> sums;\n    solve(topView, frontView, sums);\n    \n    if (sums.empty()) {\n        cout << 0 << endl;\n    } else {\n        for (int sum : sums) {\n            cout << sum << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:17:48"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_ARRANGEMENTS 1000\n#define CUBE_SIZE 3\n\nint top_view[CUBE_SIZE][CUBE_SIZE];\nint front_view[CUBE_SIZE][CUBE_SIZE];\nint right_side_sums[MAX_ARRANGEMENTS];\nint arrangement_count = 0;\n\nint is_valid_adjacent_face(int a, int b) {\n    return a + b == 7;\n}\n\nint is_valid_arrangement(int cube[CUBE_SIZE][CUBE_SIZE][CUBE_SIZE]) {\n    for (int x = 0; x < CUBE_SIZE; x++) {\n        for (int y = 0; y < CUBE_SIZE; y++) {\n            if (top_view[x][y] != 0 && cube[x][y][CUBE_SIZE-1] != top_view[x][y]) \n                return 0;\n            if (front_view[x][y] != 0 && cube[x][CUBE_SIZE-1][y] != front_view[x][y]) \n                return 0;\n        }\n    }\n    return 1;\n}\n\nvoid backtrack(int cube[CUBE_SIZE][CUBE_SIZE][CUBE_SIZE], int x, int y, int z) {\n    if (z == CUBE_SIZE) {\n        if (is_valid_arrangement(cube)) {\n            int right_sum = 0;\n            for (int i = 0; i < CUBE_SIZE; i++) {\n                for (int j = 0; j < CUBE_SIZE; j++) {\n                    right_sum += cube[CUBE_SIZE-1][i][j];\n                }\n            }\n            \n            int duplicate = 0;\n            for (int i = 0; i < arrangement_count; i++) {\n                if (right_side_sums[i] == right_sum) {\n                    duplicate = 1;\n                    break;\n                }\n            }\n            \n            if (!duplicate) {\n                right_side_sums[arrangement_count++] = right_sum;\n            }\n        }\n        return;\n    }\n    \n    for (int num = 1; num <= 6; num++) {\n        cube[x][y][z] = num;\n        \n        if (x > 0 && !is_valid_adjacent_face(cube[x-1][y][z], num)) continue;\n        if (y > 0 && !is_valid_adjacent_face(cube[x][y-1][z], num)) continue;\n        if (z > 0 && !is_valid_adjacent_face(cube[x][y][z-1], num)) continue;\n        \n        int next_x = x + 1;\n        int next_y = y;\n        int next_z = z;\n        \n        if (next_x == CUBE_SIZE) {\n            next_x = 0;\n            next_y++;\n        }\n        \n        if (next_y == CUBE_SIZE) {\n            next_x = 0;\n            next_y = 0;\n            next_z++;\n        }\n        \n        backtrack(cube, next_x, next_y, next_z);\n    }\n}\n\nint compare(const void *a, const void *b) {\n    return (*(int*)a - *(int*)b);\n}\n\nint main() {\n    int cube[CUBE_SIZE][CUBE_SIZE][CUBE_SIZE] = {0};\n    \n    for (int i = 0; i < CUBE_SIZE; i++) {\n        for (int j = 0; j < CUBE_SIZE; j++) {\n            scanf(\"%d\", &top_view[i][j]);\n        }\n    }\n    \n    for (int i = 0; i < CUBE_SIZE; i++) {\n        for (int j = 0; j < CUBE_SIZE; j++) {\n            scanf(\"%d\", &front_view[i][j]);\n        }\n    }\n    \n    arrangement_count = 0;\n    backtrack(cube, 0, 0, 0);\n    \n    if (arrangement_count == 0) {\n        printf(\"0\\n\");\n    } else {\n        qsort(right_side_sums, arrangement_count, sizeof(int), compare);\n        for (int i = 0; i < arrangement_count; i++) {\n            printf(\"%d \", right_side_sums[i]);\n        }\n        printf(\"\\n\");\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:18:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint getDiceOpposite(int num) {\n    return 7 - num;\n}\n\nbool isValidArrangement(vector<vector<int>>& arrangement) {\n    for (int i = 0; i < 3; i++) {\n        for (int j = 0; j < 3; j++) {\n            // Check adjacent dice horizontally\n            if (j < 2 && getDiceOpposite(arrangement[i][j]) + getDiceOpposite(arrangement[i][j+1]) != 7) \n                return false;\n            \n            // Check adjacent dice vertically\n            if (i < 2 && getDiceOpposite(arrangement[i][j]) + getDiceOpposite(arrangement[i+1][j]) != 7) \n                return false;\n        }\n    }\n    return true;\n}\n\nint main() {\n    int T;\n    cin >> T;\n    \n    while (T--) {\n        vector<int> top(9), front(9);\n        \n        for (int i = 0; i < 9; i++) \n            cin >> top[i];\n        \n        for (int i = 0; i < 9; i++) \n            cin >> front[i];\n        \n        set<int> rightSums;\n        \n        // Generate all possible permutations of dice\n        vector<int> perm = {1, 2, 3, 4, 5, 6};\n        sort(perm.begin(), perm.end());\n        \n        do {\n            vector<vector<int>> arrangement(3, vector<int>(3));\n            \n            // Attempt to fill arrangement with current permutation\n            bool validArrangement = true;\n            for (int i = 0; i < 3; i++) {\n                for (int j = 0; j < 3; j++) {\n                    int diceNum = perm[i*3 + j];\n                    arrangement[i][j] = diceNum;\n                }\n            }\n            \n            // Check top view\n            for (int j = 0; j < 3; j++) {\n                if (top[j] != arrangement[0][j]) {\n                    validArrangement = false;\n                    break;\n                }\n            }\n            \n            // Check front view\n            for (int i = 0; i < 3; i++) {\n                if (front[i] != arrangement[i][0]) {\n                    validArrangement = false;\n                    break;\n                }\n            }\n            \n            // Validate arrangement\n            if (validArrangement && isValidArrangement(arrangement)) {\n                int rightSum = 0;\n                for (int i = 0; i < 3; i++) {\n                    rightSum += arrangement[i][2];\n                }\n                rightSums.insert(rightSum);\n            }\n            \n        } while (next_permutation(perm.begin(), perm.end()));\n        \n        // Output results\n        if (rightSums.empty()) {\n            cout << 0 << endl;\n        } else {\n            for (int sum : rightSums) {\n                cout << sum << \" \";\n            }\n            cout << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:18:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class DiceCube {\n    private static int[][][] cube = new int[3][3][3];\n    private static List<Integer> sums = new ArrayList<>();\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int[][] top = new int[3][3];\n        int[][] front = new int[3][3];\n\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                top[i][j] = scanner.nextInt();\n            }\n        }\n\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                front[i][j] = scanner.nextInt();\n            }\n        }\n\n        solve(top, front, 0, 0, 0);\n        Collections.sort(sums);\n        Set<Integer> uniqueSums = new LinkedHashSet<>(sums);\n        if (uniqueSums.isEmpty()) {\n            System.out.println(0);\n        } else {\n            for (int sum : uniqueSums) {\n                System.out.println(sum);\n            }\n        }\n    }\n\n    private static void solve(int[][] top, int[][] front, int x, int y, int z) {\n        if (z == 3) {\n            z = 0;\n            y++;\n        }\n        if (y == 3) {\n            y = 0;\n            x++;\n        }\n        if (x == 3) {\n            if (isValid(top, front)) {\n                int sum = 0;\n                for (int i = 0; i < 3; i++) {\n                    sum += cube[i][0][2];\n                }\n                sums.add(sum);\n            }\n            return;\n        }\n\n        if (x == 0 && y == 0 && z == 0) {\n            for (int face = 1; face <= 6; face++) {\n                cube[x][y][z] = face;\n                solve(top, front, x, y, z + 1);\n            }\n        } else {\n            Set<Integer> possibleFaces = new HashSet<>();\n            if (x > 0) {\n                possibleFaces.add(7 - cube[x - 1][y][z]);\n            }\n            if (y > 0) {\n                possibleFaces.add(7 - cube[x][y - 1][z]);\n            }\n            if (z > 0) {\n                possibleFaces.add(7 - cube[x][y][z - 1]);\n            }\n\n            if (possibleFaces.isEmpty()) {\n                for (int face = 1; face <= 6; face++) {\n                    cube[x][y][z] = face;\n                    solve(top, front, x, y, z + 1);\n                }\n            } else {\n                for (int face : possibleFaces) {\n                    if (face >= 1 && face <= 6) {\n                        cube[x][y][z] = face;\n                        solve(top, front, x, y, z + 1);\n                    }\n                }\n            }\n        }\n    }\n\n    private static boolean isValid(int[][] top, int[][] front) {\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (top[i][j] != 0 && cube[i][j][2] != top[i][j]) {\n                    return false;\n                }\n                if (front[i][j] != 0 && cube[i][0][j] != front[i][j]) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 19:19:13"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import itertools\n\ndef check_views(top_view, front_view):\n    top_flat = list(itertools.chain(*top_view))\n    front_flat = list(itertools.chain(*front_view))\n    \n    # All permutations of dice\n    permutations = itertools.permutations(range(1, 7), 3)\n    \n    valid_arrangements = set()\n    \n    for perm in permutations:\n        possible_rows = [perm[:3], perm[3:], ]\n        \n        if all(sum(row) == 7 for row in possible_rows):\n            arrangement = list(itertools.chain(*possible_rows))\n            \n            valid_top = all(arrangement[i] == val or val == 0 for i, val in enumerate(top_flat))\n            valid_front = all(arrangement[i] == val or val == 0 for i, val in enumerate(front_flat))\n            \n            if valid_top and valid_front:\n                right_sum = sum(arrangement[2::3])\n                valid_arrangements.add(right_sum)\n    \n    return sorted(valid_arrangements) if valid_arrangements else [0]\n\ndef solve_for_multiple_cases(cases):\n    results = []\n    \n    for top_view, front_view in cases:\n        possible_sums = check_views(top_view, front_view)\n        results.append(possible_sums)\n    \n    return results\n\n# Example cases; you should input your own cases here.\ncases = [\n    ([[1, 0, 3], [0, 0, 0], [6, 0, 0]], [[1, 2, 3], [0, 0, 0], [0, 0, 0]]),\n    # More cases...\n]\n\nresults = solve_for_multiple_cases(cases)\nfor result in results:\n    print(result)",
    "timestamp": "2025-08-13 03:20:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.HashSet;\nimport java.util.Set;\nimport java.util.Arrays;\nimport java.util.stream.Collectors;\n\npublic class DiceCubePuzzle {\n\n    private static final int[][] oppositeFaces = {\n        {0, 5}, {1, 4}, {2, 3}\n    };\n    \n    private static final int[] oppositeNumbers = {6, 5, 4, 3, 2, 1};\n\n    public static Set<Integer> findSums(int[][] topView, int[][] frontView) {\n        Set<Integer> sums = new HashSet<>();\n        int[][][] cube = new int[3][3][3];\n\n        if (solveCube(cube, topView, frontView, 0, 0, 0)) {\n            calculateSum(cube, sums);\n        }\n        return sums.size() > 0 ? sums : Set.of(0);\n    }\n\n    private static boolean solveCube(int[][][] cube, int[][] topView, int[][] frontView, int x, int y, int z) {\n        if (x == 3) return solveCube(cube, topView, frontView, 0, y + 1, z);\n        if (y == 3) return solveCube(cube, topView, frontView, 0, 0, z + 1);\n        if (z == 3) return validate(cube);\n        \n        int topFace = topView[x][z];\n        int frontFace = frontView[y][z];\n\n        for (int i = 1; i <= 6; i++) {\n            for (int[] face : oppositeFaces) {\n                cube[x][y][z] = i;\n                int oppositeFace = oppositeNumbers[i - 1];\n                if (topFace == 0 || topFace == i || topFace == oppositeFace) {\n                    if (frontFace == 0 || frontFace == i || frontFace == oppositeFace) {\n                        if (solveCube(cube, topView, frontView, x + 1, y, z)) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\n    private static boolean validate(int[][][] cube) {\n        for (int z = 0; z < 3; z++) {\n            for (int x = 0; x < 3; x++) {\n                for (int y = 0; y < 3; y++) {\n                    if (!checkAdjacent(cube, x, y, z)) {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n\n    private static boolean checkAdjacent(int[][][] cube, int x, int y, int z) {\n        int value = cube[x][y][z];\n        return (x == 2 || value + cube[x + 1][y][z] == 7) &&\n               (y == 2 || value + cube[x][y + 1][z] == 7) &&\n               (z == 2 || value + cube[x][y][z + 1] == 7);\n    }\n\n    private static void calculateSum(int[][][] cube, Set<Integer> sums) {\n        int sum = 0;\n        for (int[][] face : cube) {\n            for (int[] row : face) {\n                sum += row[2];\n            }\n        }\n        sums.add(sum);\n    }\n\n    public static void main(String[] args) {\n        int[][] topView = {\n            {4, 3, 5},\n            {0, 0, 0},\n            {2, 1, 6}\n        };\n\n        int[][] frontView = {\n            {5, 0, 2},\n            {3, 0, 6},\n            {4, 0, 1}\n        };\n\n        Set<Integer> sums = findSums(topView, frontView);\n        System.out.println(Arrays.toString(sums.stream().sorted().toArray()));\n    }\n}",
    "timestamp": "2025-08-13 03:20:49"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#define SIZE 3\n\nint opposite(int face) {\n    return 7 - face;\n}\n\nbool isValid(int die1, int die2, int sum) {\n    return (die1 + die2) == sum;\n}\n\nvoid findArrangements(int top[SIZE][SIZE], int front[SIZE][SIZE], int results[], int* resultCount) {\n    int right[SIZE][SIZE];\n\n    // All combinations of face arrangements for the first column of the right view\n    for (int a = 1; a <= 6; a++) {\n        for (int b = 1; b <= 6; b++) {\n            for (int c = 1; c <= 6; c++) {\n\n                if (!isValid(top[0][2], a, 7)) continue;\n                if (!isValid(top[1][2], b, 7)) continue;\n                if (!isValid(top[2][2], c, 7)) continue;\n                if (!isValid(front[0][2], a, 7)) continue;\n                if (!isValid(front[1][2], b, 7)) continue;\n                if (!isValid(front[2][2], c, 7)) continue;\n\n                right[0][0] = a;\n                right[1][0] = b;\n                right[2][0] = c;\n\n                for (int d = 1; d <= 6; d++) {\n                    for (int e = 1; e <= 6; e++) {\n                        for (int f = 1; f <= 6; f++) {\n\n                            if (!isValid(top[0][2], right[0][0], 7)) continue;\n                            if (!isValid(top[0][1], d, 7)) continue;\n                            if (!isValid(front[0][1], d, 7)) continue;\n                            if (!isValid(front[0][2], right[0][0], 7)) continue;\n                            if (!isValid(front[0][2], e, 7)) continue;\n\n                            right[0][1] = d;\n                            right[1][1] = e;\n                            right[2][1] = f;\n\n                            right[0][2] = opposite(top[0][2]);\n                            right[1][2] = opposite(top[1][2]);\n                            right[2][2] = opposite(top[2][2]);\n\n                            int sum = right[0][0] + right[0][1] + right[0][2] +\n                                      right[1][0] + right[1][1] + right[1][2] +\n                                      right[2][0] + right[2][1] + right[2][2];\n\n                            bool found = false;\n                            for (int i = 0; i < *resultCount; i++) {\n                                if (results[i] == sum) {\n                                    found = true;\n                                    break;\n                                }\n                            }\n\n                            if (!found) {\n                                results[*resultCount] = sum;\n                                (*resultCount)++;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int topView[SIZE][SIZE] = {{1, 3, 6}, {4, 5, 3}, {2, 3, 5}};\n    int frontView[SIZE][SIZE] = {{1, 2, 6}, {3, 5, 3}, {6, 1, 4}};\n\n    int results[100];\n    int resultCount = 0;\n    findArrangements(topView, frontView, results, &resultCount);\n\n    if (resultCount == 0) {\n        printf(\"0\\n\");\n    } else {\n        for (int i = 0; i < resultCount - 1; i++) {\n            for (int j = i + 1; j < resultCount; j++) {\n                if (results[i] > results[j]) {\n                    int temp = results[i];\n                    results[i] = results[j];\n                    results[j] = temp;\n                }\n            }\n        }\n\n        for (int i = 0; i < resultCount; i++) {\n            if (i == 0 || results[i] != results[i - 1]) {\n                printf(\"%d\\n\", results[i]);\n            }\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 03:21:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import permutations\n\ndef is_valid_arrangement(arrangement, top_view, front_view):\n    # Check top view\n    for col in range(3):\n        if top_view[col] != arrangement[0][col] + arrangement[1][col] + arrangement[2][col]:\n            return False\n    \n    # Check front view\n    for row in range(3):\n        if front_view[row] != arrangement[row][0] + arrangement[row][1] + arrangement[row][2]:\n            return False\n    \n    # Check adjacent faces sum to 7\n    for i in range(3):\n        for j in range(3):\n            # Check adjacent dice in rows\n            if j < 2 and arrangement[i][j] + arrangement[i][j+1] != 7:\n                return False\n            \n            # Check adjacent dice in columns\n            if i < 2 and arrangement[i][j] + arrangement[i+1][j] != 7:\n                return False\n    \n    return True\n\ndef solve_cube_puzzle(top_view, front_view):\n    valid_arrangements = []\n    \n    # Generate all possible dice arrangements\n    dice_values = list(range(1, 7))\n    for arrangement in permutations(dice_values, 9):\n        cube = [arrangement[i:i+3] for i in range(0, 9, 3)]\n        \n        if is_valid_arrangement(cube, top_view, front_view):\n            # Calculate right side sum\n            right_side_sum = sum(cube[i][2] for i in range(3))\n            valid_arrangements.append(right_side_sum)\n    \n    # Return unique sums in ascending order or 0 if no arrangements\n    return sorted(set(valid_arrangements)) if valid_arrangements else [0]\n\n# Example usage\ntop_view = [5, 7, 9]\nfront_view = [6, 8, 10]\nprint(solve_cube_puzzle(top_view, front_view))",
    "timestamp": "2025-08-13 03:21:35"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import itertools\n\ndef solve():\n    # Read input\n    top = [list(input().strip()) for _ in range(3)]\n    front = [list(input().strip()) for _ in range(3)]\n    \n    # Determine possible dice arrangements\n    # The cube is 3x3x3, indexed as (z, y, x) where z is layer (0=front, 1=middle, 2=back)\n    # We need to fill the cube such that:\n    # - The top view matches the given top (looking down from z-axis)\n    # - The front view matches the given front (looking from x-axis)\n    # - Adjacent dice faces sum to 7\n    \n    # The dice are oriented such that:\n    # For a die at (z, y, x):\n    # - The top face (visible from top view) is the 'up' face\n    # - The front face (visible from front view) is the 'front' face\n    # - The right face is what we need to find\n    \n    # We'll represent each die's orientation with a 3D rotation that maps the standard die to the actual orientation\n    # Standard die: 1 front, 2 top, 3 right (assuming right-hand rule)\n    \n    # All possible rotations of a die that keep the top as one of the 6 faces and front as one of the adjacent 4\n    # Each rotation is represented as (up, front, right) numbers\n    # The standard die is (2, 1, 3)\n    # Rotations can be generated by fixing up and rotating front\n    \n    rotations = []\n    # up can be any of 1..6\n    # front can be any adjacent to up (not opposite)\n    # then right is determined by up and front\n    # Precompute all valid (up, front, right) triplets\n    opposite = {1:6, 2:5, 3:4, 4:3, 5:2, 6:1}\n    adjacent = {\n        1: [2, 3, 4, 5],\n        2: [1, 3, 5, 6],\n        3: [1, 2, 4, 6],\n        4: [1, 3, 5, 6],\n        5: [1, 2, 4, 6],\n        6: [2, 3, 4, 5]\n    }\n    \n    for up in range(1, 7):\n        for front in adjacent[up]:\n            # Determine right based on up and front\n            # Using right-hand rule: up (thumb) x front (index) = right (middle)\n            # The exact mapping can be derived from standard die orientation\n            # For standard die (2 up, 1 front, 3 right):\n            # 2 (up) x 1 (front) = 3 (right)\n            # So for general case, we can use a mapping\n            # The right face is the one that's not up, front, or their opposites\n            # and satisfies the cross product\n            possible_rights = [r for r in range(1, 7) if r != up and r != front and r != opposite[up] and r != opposite[front]]\n            # There should be only one possible right\n            if len(possible_rights) == 1:\n                right = possible_rights[0]\n                rotations.append((up, front, right))\n    \n    # Now, we need to fill the cube with dice orientations that satisfy the constraints\n    # The cube is 3x3x3 (z, y, x)\n    # top view shows up faces for z=0,1,2 layers (x and y are 0..2)\n    # front view shows front faces for x=0,1,2 layers (z and y are 0..2)\n    \n    # Collect constraints from top and front views\n    top_constraints = []\n    for y in range(3):\n        row = []\n        for x in range(3):\n            ch = top[y][x]\n            if ch == '.':\n                row.append(None)\n            else:\n                row.append(int(ch))\n        top_constraints.append(row)\n    \n    front_constraints = []\n    for y in range(3):\n        row = []\n        for z in range(3):\n            ch = front[y][z]\n            if ch == '.':\n                row.append(None)\n            else:\n                row.append(int(ch))\n        front_constraints.append(row)\n    \n    # The cube is indexed as [z][y][x], each entry is (up, front, right)\n    cube = [[[None for _ in range(3)] for _ in range(3)] for _ in range(3)]\n    \n    # We'll use backtracking to fill the cube\n    # The order is z, y, x\n    solutions = []\n    \n    def backtrack(pos):\n        if pos == 27:\n            # Check all adjacent dice sum to 7\n            valid = True\n            for z in range(3):\n                for y in range(3):\n                    for x in range(3):\n                        current = cube[z][y][x]\n                        if current is None:\n                            continue\n                        up, front, right = current\n                        # Check adjacent dice\n                        # Left neighbor (x-1)\n                        if x > 0:\n                            neighbor = cube[z][y][x-1]\n                            if neighbor is not None:\n                                n_up, n_front, n_right = neighbor\n                                if right + n_right != 7:\n                                    valid = False\n                                    break\n                        # Right neighbor (x+1)\n                        if x < 2:\n                            neighbor = cube[z][y][x+1]\n                            if neighbor is not None:\n                                n_up, n_front, n_right = neighbor\n                                if right + n_right != 7:\n                                    valid = False\n                                    break\n                        # Top neighbor (y-1)\n                        if y > 0:\n                            neighbor = cube[z][y-1][x]\n                            if neighbor is not None:\n                                n_up, n_front, n_right = neighbor\n                                if up + n_up != 7:\n                                    valid = False\n                                    break\n                        # Bottom neighbor (y+1)\n                        if y < 2:\n                            neighbor = cube[z][y+1][x]\n                            if neighbor is not None:\n                                n_up, n_front, n_right = neighbor\n                                if up + n_up != 7:\n                                    valid = False\n                                    break\n                        # Front neighbor (z-1)\n                        if z > 0:\n                            neighbor = cube[z-1][y][x]\n                            if neighbor is not None:\n                                n_up, n_front, n_right = neighbor\n                                if front + n_front != 7:\n                                    valid = False\n                                    break\n                        # Back neighbor (z+1)\n                        if z < 2:\n                            neighbor = cube[z+1][y][x]\n                            if neighbor is not None:\n                                n_up, n_front, n_right = neighbor\n                                if front + n_front != 7:\n                                    valid = False\n                                    break\n                    if not valid:\n                        break\n                if not valid:\n                    break\n            if valid:\n                # Calculate the sum of right faces for x=2 (right side)\n                total = 0\n                for z in range(3):\n                    for y in range(3):\n                        if cube[z][y][2] is not None:\n                            total += cube[z][y][2][2]\n                solutions.append(total)\n            return\n        \n        z = pos // 9\n        y = (pos % 9) // 3\n        x = pos % 3\n        \n        # Check if this position has constraints\n        up_constraint = top_constraints[y][x]\n        front_constraint = front_constraints[y][z]\n        \n        # Filter possible rotations for this position\n        possible = []\n        for rot in rotations:\n            up, front, right = rot\n            if (up_constraint is None or up == up_constraint) and (front_constraint is None or front == front_constraint):\n                possible.append(rot)\n        \n        # Try each possible rotation\n        for rot in possible:\n            up, front, right = rot\n            # Check adjacent dice\n            valid = True\n            # Left neighbor (x-1)\n            if x > 0 and cube[z][y][x-1] is not None:\n                n_up, n_front, n_right = cube[z][y][x-1]\n                if right + n_right != 7:\n                    valid = False\n            # Right neighbor (x+1)\n            if x < 2 and cube[z][y][x+1] is not None:\n                n_up, n_front, n_right = cube[z][y][x+1]\n                if right + n_right != 7:\n                    valid = False\n            # Top neighbor (y-1)\n            if y > 0 and cube[z][y-1][x] is not None:\n                n_up, n_front, n_right = cube[z][y-1][x]\n                if up + n_up != 7:\n                    valid = False\n            # Bottom neighbor (y+1)\n            if y < 2 and cube[z][y+1][x] is not None:\n                n_up, n_front, n_right = cube[z][y+1][x]\n                if up + n_up != 7:\n                    valid = False\n            # Front neighbor (z-1)\n            if z > 0 and cube[z-1][y][x] is not None:\n                n_up, n_front, n_right = cube[z-1][y][x]\n                if front + n_front != 7:\n                    valid = False\n            # Back neighbor (z+1)\n            if z < 2 and cube[z+1][y][x] is not None:\n                n_up, n_front, n_right = cube[z+1][y][x]\n                if front + n_front != 7:\n                    valid = False\n            \n            if valid:\n                cube[z][y][x] = rot\n                backtrack(pos + 1)\n                cube[z][y][x] = None\n    \n    backtrack(0)\n    \n    if not solutions:\n        print(0)\n    else:\n        # Remove duplicates and sort\n        unique_sums = sorted(list(set(solutions)))\n        print(' '.join(map(str, unique_sums)))\n\nsolve()",
    "timestamp": "2025-08-13 03:22:33"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <functional>\n\nusing namespace std;\n\n// Opposite face values for a standard die\nvector<int> opposite = {0, 6, 5, 4, 3, 2, 1};\n\n// Structure to hold three-dimensional coordinates\nstruct Coordinate {\n    int x, y, z;\n};\n\n// Directions for adjacent cells, right (first), down, inwards (depth)\nvector<Coordinate> directions = {{1, 0, 0}, {0, 1, 0}, {0, 0, 1}};\n\n// Function to validate dice placement\nbool is_valid(vector<vector<vector<int>>> &cube, int x, int y, int z, int value) {\n    for (auto &d : directions) {\n        int nx = x + d.x, ny = y + d.y, nz = z + d.z;\n        if (nx < 3 && ny < 3 && nz < 3 && cube[nx][ny][nz] != 0) { // adjacent dice\n            if (value + cube[nx][ny][nz] != 7) // checks rule\n                return false;\n        }\n    }\n    return true;\n}\n\n// Backtracking function to solve the dice arrangements\nbool backtrack(vector<vector<vector<int>>> &cube, vector<vector<int>> &top, vector<vector<int>> &front, set<int> &sums, int index) {\n    if (index == 27) { // base condition: all places filled\n        int side_sum = 0;\n        for (int y = 0; y < 3; ++y)\n            for (int z = 0; z < 3; ++z)\n                side_sum += cube[2][y][z]; // calculate right side sum\n\n        sums.insert(side_sum);\n        return true;\n    }\n\n    int x = index / 9, y = (index / 3) % 3, z = index % 3;\n    if (cube[x][y][z] != 0) return backtrack(cube, top, front, sums, index + 1);\n\n    bool found = false;\n    for (int v = 1; v <= 6; ++v) {\n        if (is_valid(cube, x, y, z, v)) {\n            cube[x][y][z] = v;\n            if ((top[z][x] == 0 || top[z][x] == v) && (front[x][y] == 0 || front[x][y] == v)) {\n                found |= backtrack(cube, top, front, sums, index + 1);\n            }\n            cube[x][y][z] = 0;\n        }\n    }\n    return found;\n}\n\n// Main solving function\nvector<int> solve_cube(vector<vector<int>> top, vector<vector<int>> front) {\n    vector<vector<vector<int>>> cube(3, vector<vector<int>>(3, vector<int>(3, 0)));\n    set<int> sums;\n\n    backtrack(cube, top, front, sums, 0);\n    return vector<int>(sums.begin(), sums.end());\n}\n\nint main() {\n    // Input two 3x3 views\n    vector<vector<int>> top = { {0, 0, 0}, {0, 0, 0}, {0, 0, 0} };\n    vector<vector<int>> front = { {0, 0, 0}, {0, 0, 0}, {0, 0, 0} };\n\n    // Assuming you have updated this with actual input values\n\n    vector<int> result = solve_cube(top, front);\n    if (result.empty()) result.push_back(0);\n\n    for (int sum : result) {\n        cout << sum << \" \";\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:11:25"
  }
]